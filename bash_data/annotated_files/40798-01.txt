22705: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18056:  * vim: set ts=4 sw=4 et tw=99:
17181:  *
17181:  * ***** BEGIN LICENSE BLOCK *****
17181:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
17181:  *
17181:  * The contents of this file are subject to the Mozilla Public License Version
17181:  * 1.1 (the "License"); you may not use this file except in compliance with
17181:  * the License. You may obtain a copy of the License at
17181:  * http://www.mozilla.org/MPL/
17181:  *
17181:  * Software distributed under the License is distributed on an "AS IS" basis,
17181:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
17181:  * for the specific language governing rights and limitations under the
17181:  * License.
17181:  *
17181:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
17181:  * May 28, 2008.
17181:  *
17181:  * The Initial Developer of the Original Code is
17339:  *   Brendan Eich <brendan@mozilla.org>
17181:  *
17181:  * Contributor(s):
17339:  *   Andreas Gal <gal@mozilla.com>
17671:  *   Mike Shaver <shaver@mozilla.org>
17671:  *   David Anderson <danderson@mozilla.com>
17181:  *
17181:  * Alternatively, the contents of this file may be used under the terms of
17181:  * either of the GNU General Public License Version 2 or later (the "GPL"),
17181:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
17181:  * in which case the provisions of the GPL or the LGPL are applicable instead
17181:  * of those above. If you wish to allow use of your version of this file only
17181:  * under the terms of either the GPL or the LGPL, and not to allow others to
17181:  * use your version of this file under the terms of the MPL, indicate your
17181:  * decision by deleting the provisions above and replace them with the notice
17181:  * and other provisions required by the GPL or the LGPL. If you do not delete
17181:  * the provisions above, a recipient may use your version of this file under
17181:  * the terms of any one of the MPL, the GPL or the LGPL.
17181:  *
17181:  * ***** END LICENSE BLOCK ***** */
17181: 
26316: #include "jsstdint.h"
17923: #include "jsbit.h"              // low-level (NSPR-based) headers next
17923: #include "jsprf.h"
17666: #include <math.h>               // standard headers next
26053: 
26053: #if defined(_MSC_VER) || defined(__MINGW32__)
26053: #include <malloc.h>
17666: #ifdef _MSC_VER
17666: #define alloca _alloca
17666: #endif
26053: #endif
19058: #ifdef SOLARIS
19058: #include <alloca.h>
19058: #endif
25627: #include <limits.h>
17181: 
21062: #include "nanojit/nanojit.h"
25718: #include "jsapi.h"              // higher-level library and API headers
25718: #include "jsarray.h"
17421: #include "jsbool.h"
17630: #include "jscntxt.h"
32738: #include "jsdate.h"
17949: #include "jsdbgapi.h"
17949: #include "jsemit.h"
17630: #include "jsfun.h"
17630: #include "jsinterp.h"
17899: #include "jsiter.h"
31900: #include "jsmath.h"
17666: #include "jsobj.h"
17863: #include "jsopcode.h"
18115: #include "jsregexp.h"
17949: #include "jsscope.h"
17630: #include "jsscript.h"
20969: #include "jsstaticcheck.h"
17407: #include "jstracer.h"
28175: #include "jsxml.h"
37754: #include "jstypedarray.h"
17293: 
30283: #include "jsatominlines.h"
40359: #include "jspropertycacheinlines.h"
37685: #include "jsobjinlines.h"
34349: #include "jsscopeinlines.h"
32737: #include "jsscriptinlines.h"
30283: 
17666: #include "jsautooplen.h"        // generated headers last
23075: #include "imacros.c.out"
17597: 
37762: #if defined(NANOJIT_ARM) && defined(__GNUC__) && defined(AVMPLUS_LINUX)
37741: #include <stdlib.h>
37741: #include <unistd.h>
37741: #include <sys/types.h>
37741: #include <sys/stat.h>
37741: #include <sys/mman.h>
37741: #include <fcntl.h>
37741: #include <string.h>
37741: #include <elf.h>
37741: #endif
37741: 
37741: namespace nanojit {
37741: using namespace js;
37741: 
37741: /* Implement embedder-specific nanojit members. */
37741: 
37741: void*
37741: nanojit::Allocator::allocChunk(size_t nbytes)
37741: {
37741:     VMAllocator *vma = (VMAllocator*)this;
37741:     JS_ASSERT(!vma->outOfMemory());
37741:     void *p = calloc(1, nbytes);
37741:     if (!p) {
37741:         JS_ASSERT(nbytes < sizeof(vma->mReserve));
37741:         vma->mOutOfMemory = true;
37741:         p = (void*) &vma->mReserve[0];
37741:     }
37741:     vma->mSize += nbytes;
37741:     return p;
37741: }
37741: 
37741: void
37741: nanojit::Allocator::freeChunk(void *p) {
37741:     VMAllocator *vma = (VMAllocator*)this;
37741:     if (p != &vma->mReserve[0])
37741:         free(p);
37741: }
37741: 
37741: void
37741: nanojit::Allocator::postReset() {
37741:     VMAllocator *vma = (VMAllocator*)this;
37741:     vma->mOutOfMemory = false;
37741:     vma->mSize = 0;
37741: }
37741: 
40248: int
40248: StackFilter::getTop(LIns* guard)
37741: {
37741:     VMSideExit* e = (VMSideExit*)guard->record()->exit;
40248:     return e->sp_adj;
37741: }
37741: 
37741: #if defined NJ_VERBOSE
37741: void
40300: LInsPrinter::formatGuard(InsBuf *buf, LIns *ins)
40300: {
40300:     RefBuf b1, b2;
40300:     VMSideExit *x = (VMSideExit *)ins->record()->exit;
40300:     VMPI_snprintf(buf->buf, buf->len,
37741:             "%s: %s %s -> pc=%p imacpc=%p sp%+ld rp%+ld (GuardID=%03d)",
40300:             formatRef(&b1, ins),
40300:             lirNames[ins->opcode()],
40300:             ins->oprnd1() ? formatRef(&b2, ins->oprnd1()) : "",
37741:             (void *)x->pc,
37741:             (void *)x->imacpc,
37741:             (long int)x->sp_adj,
37741:             (long int)x->rp_adj,
40300:             ins->record()->profGuardID);
37741: }
38603: 
38603: void
40300: LInsPrinter::formatGuardXov(InsBuf *buf, LIns *ins)
40300: {
40300:     RefBuf b1, b2, b3;
40300:     VMSideExit *x = (VMSideExit *)ins->record()->exit;
40300:     VMPI_snprintf(buf->buf, buf->len,
38603:             "%s = %s %s, %s -> pc=%p imacpc=%p sp%+ld rp%+ld (GuardID=%03d)",
40300:             formatRef(&b1, ins),
40300:             lirNames[ins->opcode()],
40300:             formatRef(&b2, ins->oprnd1()),
40300:             formatRef(&b3, ins->oprnd2()),
38603:             (void *)x->pc,
38603:             (void *)x->imacpc,
38603:             (long int)x->sp_adj,
38603:             (long int)x->rp_adj,
40300:             ins->record()->profGuardID);
38603: }
37741: #endif
37741: 
37741: } /* namespace nanojit */
37741: 
37741: namespace js {
37741: 
30860: using namespace nanojit;
30860: 
28175: #if JS_HAS_XML_SUPPORT
33542: #define RETURN_VALUE_IF_XML(val, ret)                                         \
28175:     JS_BEGIN_MACRO                                                            \
37003:         if (!JSVAL_IS_PRIMITIVE(val) && JSVAL_TO_OBJECT(val)->isXML())        \
33542:             RETURN_VALUE("xml detected", ret);                                \
28175:     JS_END_MACRO
28175: #else
33542: #define RETURN_IF_XML(val, ret) ((void) 0)
33542: #endif
33542: 
33542: #define RETURN_IF_XML_A(val) RETURN_VALUE_IF_XML(val, ARECORD_STOP)
33542: #define RETURN_IF_XML(val)   RETURN_VALUE_IF_XML(val, RECORD_STOP)
30860: 
37741: JS_STATIC_ASSERT(sizeof(TraceType) == 1);
37037: JS_STATIC_ASSERT(offsetof(TraceNativeStorage, stack_global_buf) % 16 == 0);
27541: 
20399: /* Map to translate a type tag into a printable representation. */
27541: static const char typeChar[] = "OIDXSNBF";
23075: static const char tagChar[]  = "OIDISIBI";
20399: 
25627: /* Blacklist parameters. */
25627: 
30860: /*
30860:  * Number of iterations of a loop where we start tracing.  That is, we don't
30860:  * start tracing until the beginning of the HOTLOOP-th iteration.
30860:  */
17821: #define HOTLOOP 2
17821: 
25627: /* Attempt recording this many times before blacklisting permanently. */
25937: #define BL_ATTEMPTS 2
25627: 
28409: /* Skip this many hits before attempting recording again, after an aborted attempt. */
25627: #define BL_BACKOFF 32
25627: 
17821: /* Number of times we wait to exit on a side exit before we try to extend the tree. */
18290: #define HOTEXIT 1
17821: 
25627: /* Number of times we try to extend the tree along a side exit. */
25627: #define MAXEXIT 3
25627: 
25627: /* Maximum number of peer trees allowed. */
25627: #define MAXPEERS 9
25627: 
33564: /* Max number of hits to a RECURSIVE_UNLINKED exit before we trash the tree. */
33564: #define MAX_RECURSIVE_UNLINK_HITS 64
33564: 
18051: /* Max call depths for inlining. */
19070: #define MAX_CALLDEPTH 10
17852: 
34322: /* Max number of slots in a table-switch. */
34322: #define MAX_TABLE_SWITCH 256
34322: 
23447: /* Max memory needed to rebuild the interpreter stack when falling off trace. */
23447: #define MAX_INTERP_STACK_BYTES                                                \
23447:     (MAX_NATIVE_STACK_SLOTS * sizeof(jsval) +                                 \
28086:      MAX_CALL_STACK_ENTRIES * sizeof(JSInlineFrame) +                         \
28086:      sizeof(JSInlineFrame)) /* possibly slow native frame at top of stack */
23447: 
18781: /* Max number of branches per tree. */
26534: #define MAX_BRANCHES 32
18781: 
27933: #define CHECK_STATUS(expr)                                                    \
27933:     JS_BEGIN_MACRO                                                            \
33542:         RecordingStatus _status = (expr);                                     \
33542:         if (_status != RECORD_CONTINUE)                                       \
27933:           return _status;                                                     \
27933:     JS_END_MACRO
27933: 
33542: #define CHECK_STATUS_A(expr)                                                  \
33542:     JS_BEGIN_MACRO                                                            \
33542:         AbortableRecordingStatus _status = InjectStatus((expr));              \
33542:         if (_status != ARECORD_CONTINUE)                                      \
33542:           return _status;                                                     \
33542:     JS_END_MACRO
33542: 
21459: #ifdef JS_JIT_SPEW
33542: #define RETURN_VALUE(msg, value)                                              \
27933:     JS_BEGIN_MACRO                                                            \
33542:         debug_only_printf(LC_TMAbort, "trace stopped: %d: %s\n", __LINE__, (msg)); \
27933:         return (value);                                                       \
27933:     JS_END_MACRO
17630: #else
33542: #define RETURN_VALUE(msg, value)   return (value)
33542: #endif
33542: 
33542: #define RETURN_STOP(msg)     RETURN_VALUE(msg, RECORD_STOP)
33542: #define RETURN_STOP_A(msg)   RETURN_VALUE(msg, ARECORD_STOP)
33542: #define RETURN_ERROR(msg)    RETURN_VALUE(msg, RECORD_ERROR)
33542: #define RETURN_ERROR_A(msg)  RETURN_VALUE(msg, ARECORD_ERROR)
27933: 
21459: #ifdef JS_JIT_SPEW
19592: struct __jitstats {
19592: #define JITSTAT(x) uint64 x;
19592: #include "jitstats.tbl"
19592: #undef JITSTAT
19623: } jitstats = { 0LL, };
19623: 
19623: JS_STATIC_ASSERT(sizeof(jitstats) % sizeof(uint64) == 0);
19592: 
19592: enum jitstat_ids {
19592: #define JITSTAT(x) STAT ## x ## ID,
19592: #include "jitstats.tbl"
19592: #undef JITSTAT
19598:     STAT_IDS_TOTAL
19592: };
19592: 
40792: static JSBool
40792: jitstats_getOnTrace(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
40792: {
40792:     *vp = BOOLEAN_TO_JSVAL(JS_ON_TRACE(cx));
40792:     return true;
40792: }
40792: 
19592: static JSPropertySpec jitstats_props[] = {
19592: #define JITSTAT(x) { #x, STAT ## x ## ID, JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT },
19592: #include "jitstats.tbl"
19592: #undef JITSTAT
40792:     { "onTrace", 0, JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT, jitstats_getOnTrace, NULL },
19592:     { 0 }
19592: };
19592: 
19592: static JSBool
19592: jitstats_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
19592: {
19592:     int index = -1;
19592: 
19592:     if (JSVAL_IS_STRING(id)) {
19592:         JSString* str = JSVAL_TO_STRING(id);
19592:         if (strcmp(JS_GetStringBytes(str), "HOTLOOP") == 0) {
19592:             *vp = INT_TO_JSVAL(HOTLOOP);
19592:             return JS_TRUE;
19592:         }
19592:     }
19592: 
19592:     if (JSVAL_IS_INT(id))
19592:         index = JSVAL_TO_INT(id);
19592: 
19592:     uint64 result = 0;
19592:     switch (index) {
19623: #define JITSTAT(x) case STAT ## x ## ID: result = jitstats.x; break;
19592: #include "jitstats.tbl"
19592: #undef JITSTAT
19592:       default:
19592:         *vp = JSVAL_VOID;
19592:         return JS_TRUE;
19592:     }
19592: 
19592:     if (result < JSVAL_INT_MAX) {
33166:         *vp = INT_TO_JSVAL(jsint(result));
19592:         return JS_TRUE;
19592:     }
19592:     char retstr[64];
19606:     JS_snprintf(retstr, sizeof retstr, "%llu", result);
19592:     *vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, retstr));
19592:     return JS_TRUE;
19592: }
19592: 
19592: JSClass jitstats_class = {
19592:     "jitstats",
31452:     0,
19592:     JS_PropertyStub,       JS_PropertyStub,
19592:     jitstats_getProperty,  JS_PropertyStub,
19592:     JS_EnumerateStub,      JS_ResolveStub,
30654:     JS_ConvertStub,        NULL,
19592:     JSCLASS_NO_OPTIONAL_MEMBERS
19592: };
19592: 
19592: void
37741: InitJITStatsClass(JSContext *cx, JSObject *glob)
19592: {
19592:     JS_InitClass(cx, glob, NULL, &jitstats_class, NULL, 0, jitstats_props, NULL, NULL, NULL);
19592: }
19592: 
19623: #define AUDIT(x) (jitstats.x++)
17726: #else
17726: #define AUDIT(x) ((void)0)
21459: #endif /* JS_JIT_SPEW */
17726: 
31843: /*
31843:  * INS_CONSTPTR can be used to embed arbitrary pointers into the native code. It should not
31843:  * be used directly to embed GC thing pointers. Instead, use the INS_CONSTOBJ/FUN/STR/SPROP
31843:  * variants which ensure that the embedded pointer will be kept alive across GCs.
31843:  */
31843: 
17870: #define INS_CONST(c)          addName(lir->insImm(c), #c)
26397: #define INS_CONSTPTR(p)       addName(lir->insImmPtr(p), #p)
32746: #define INS_CONSTWORD(v)      addName(lir->insImmPtr((void *) (v)), #v)
35099: #define INS_CONSTVAL(v)       addName(insImmVal(v), #v)
31843: #define INS_CONSTOBJ(obj)     addName(insImmObj(obj), #obj)
31843: #define INS_CONSTFUN(fun)     addName(insImmFun(fun), #fun)
31843: #define INS_CONSTSTR(str)     addName(insImmStr(str), #str)
31843: #define INS_CONSTSPROP(sprop) addName(insImmSprop(sprop), #sprop)
31843: #define INS_ATOM(atom)        INS_CONSTSTR(ATOM_TO_STRING(atom))
31843: #define INS_NULL()            INS_CONSTPTR(NULL)
31521: #define INS_VOID()            INS_CONST(JSVAL_TO_SPECIAL(JSVAL_VOID))
17870: 
18056: static avmplus::AvmCore s_core = avmplus::AvmCore();
18056: static avmplus::AvmCore* core = &s_core;
17185: 
35078: static void OutOfMemoryAbort()
35078: {
35078:     JS_NOT_REACHED("out of memory");
35078:     abort();
35078: }
31475: 
21459: #ifdef JS_JIT_SPEW
30860: static void
37741: DumpPeerStability(TraceMonitor* tm, const void* ip, JSObject* globalObj, uint32 globalShape, uint32 argc);
30860: #endif
30860: 
30860: /*
30860:  * We really need a better way to configure the JIT. Shaver, where is
30860:  * my fancy JIT object?
30860:  *
30860:  * NB: this is raced on, if jstracer.cpp should ever be running MT.
30860:  * I think it's harmless tho.
30860:  */
26545: static bool did_we_check_processor_features = false;
17997: 
29883: /* ------ Debug logging control ------ */
29883: 
30860: /*
30860:  * All the logging control stuff lives in here.  It is shared between
30860:  * all threads, but I think that's OK.
30860:  */
37741: LogControl LogController;
29883: 
21459: #ifdef JS_JIT_SPEW
29883: 
30860: /*
30860:  * NB: this is raced on too, if jstracer.cpp should ever be running MT.
30860:  * Also harmless.
30860:  */
29883: static bool did_we_set_up_debug_logging = false;
29883: 
29883: static void
30860: InitJITLogController()
29883: {
29883:     char *tm, *tmf;
29883:     uint32_t bits;
29883: 
37741:     LogController.lcbits = 0;
29883: 
29883:     tm = getenv("TRACEMONKEY");
32636:     if (tm) {
32636:         fflush(NULL);
32636:         printf(
32636:             "The environment variable $TRACEMONKEY has been replaced by $TMFLAGS.\n"
32636:             "Try 'TMFLAGS=help js -j' for a list of options.\n"
32636:         );
32636:         exit(0);
32636:     }
29883: 
29883:     tmf = getenv("TMFLAGS");
29883:     if (!tmf) return;
29883: 
32636:     /* Using strstr() is really a cheap hack as far as flag decoding goes. */
32636:     if (strstr(tmf, "help")) {
32636:         fflush(NULL);
32636:         printf(
32636:             "usage: TMFLAGS=option,option,option,... where options can be:\n"
32636:             "\n"
32636:             "  help         show this message\n"
32636:             "  ------ options for jstracer & jsregexp ------\n"
32636:             "  minimal      ultra-minimalist output; try this first\n"
36379:             "  full         everything except 'treevis' and 'fragprofile'\n"
32636:             "  tracer       tracer lifetime (FIXME:better description)\n"
32636:             "  recorder     trace recording stuff (FIXME:better description)\n"
32636:             "  abort        show trace recording aborts\n"
32636:             "  stats        show trace recording stats\n"
32636:             "  regexp       show compilation & entry for regexps\n"
32636:             "  treevis      spew that tracevis/tree.py can parse\n"
32636:             "  ------ options for Nanojit ------\n"
32784:             "  fragprofile  count entries and exits for each fragment\n"
32636:             "  liveness     show LIR liveness at start of rdr pipeline\n"
32636:             "  readlir      show LIR as it enters the reader pipeline\n"
32703:             "  aftersf      show LIR after StackFilter\n"
32636:             "  assembly     show final aggregated assembly code\n"
35362:             "  regalloc     show regalloc state in 'assembly' output\n"
35362:             "  activation   show activation state in 'assembly' output\n"
32636:             "\n"
32636:         );
32636:         exit(0);
32636:         /*NOTREACHED*/
32636:     }
29883: 
29883:     bits = 0;
30860: 
29883:     /* flags for jstracer.cpp */
32636:     if (strstr(tmf, "minimal")  || strstr(tmf, "full")) bits |= LC_TMMinimal;
32636:     if (strstr(tmf, "tracer")   || strstr(tmf, "full")) bits |= LC_TMTracer;
32636:     if (strstr(tmf, "recorder") || strstr(tmf, "full")) bits |= LC_TMRecorder;
32636:     if (strstr(tmf, "abort")    || strstr(tmf, "full")) bits |= LC_TMAbort;
32636:     if (strstr(tmf, "stats")    || strstr(tmf, "full")) bits |= LC_TMStats;
32636:     if (strstr(tmf, "regexp")   || strstr(tmf, "full")) bits |= LC_TMRegexp;
31903:     if (strstr(tmf, "treevis"))                         bits |= LC_TMTreeVis;
30860: 
29883:     /* flags for nanojit */
32784:     if (strstr(tmf, "fragprofile"))                       bits |= LC_FragProfile;
32636:     if (strstr(tmf, "liveness")   || strstr(tmf, "full")) bits |= LC_Liveness;
33174:     if (strstr(tmf, "activation") || strstr(tmf, "full")) bits |= LC_Activation;
32636:     if (strstr(tmf, "readlir")    || strstr(tmf, "full")) bits |= LC_ReadLIR;
32703:     if (strstr(tmf, "aftersf")    || strstr(tmf, "full")) bits |= LC_AfterSF;
32636:     if (strstr(tmf, "regalloc")   || strstr(tmf, "full")) bits |= LC_RegAlloc;
32636:     if (strstr(tmf, "assembly")   || strstr(tmf, "full")) bits |= LC_Assembly;
29883: 
37741:     LogController.lcbits = bits;
29883:     return;
29883: 
29883: }
18260: #endif
18260: 
32784: /* ------------------ Frag-level profiling support ------------------ */
32784: 
32784: #ifdef JS_JIT_SPEW
32784: 
32784: /*
32784:  * All the allocations done by this profile data-collection and
37741:  * display machinery, are done in TraceMonitor::profAlloc.  That is
32784:  * emptied out at the end of js_FinishJIT.  It has a lifetime from
32784:  * js_InitJIT to js_FinishJIT, which exactly matches the span
32784:  * js_FragProfiling_init to js_FragProfiling_showResults.
32784:  */
32784: template<class T>
32784: static
32784: Seq<T>* reverseInPlace(Seq<T>* seq)
32784: {
32784:     Seq<T>* prev = NULL;
32784:     Seq<T>* curr = seq;
32784:     while (curr) {
32784:         Seq<T>* next = curr->tail;
32784:         curr->tail = prev;
32784:         prev = curr;
32784:         curr = next;
32784:     }
32784:     return prev;
32784: }
32784: 
32784: // The number of top blocks to show in the profile
32784: #define N_TOP_BLOCKS 50
32784: 
32784: // Contains profile info for a single guard
32784: struct GuardPI {
32784:     uint32_t guardID; // identifying number
32784:     uint32_t count;   // count.
32784: };
32784: 
32784: struct FragPI {
32784:     uint32_t count;          // entry count for this Fragment
32784:     uint32_t nStaticExits;   // statically: the number of exits
32784:     size_t nCodeBytes;       // statically: the number of insn bytes in the main fragment
32784:     size_t nExitBytes;       // statically: the number of insn bytes in the exit paths
32784:     Seq<GuardPI>* guards;    // guards, each with its own count
32784:     uint32_t largestGuardID; // that exists in .guards
32784: };
32784: 
32784: void
37741: FragProfiling_FragFinalizer(Fragment* f, TraceMonitor* tm)
32784: {
32784:     // Recover profiling data from 'f', which is logically at the end
32784:     // of its useful lifetime.
37741:     if (!(LogController.lcbits & LC_FragProfile))
32784:         return;
32784: 
32784:     NanoAssert(f);
32784:     // Valid profFragIDs start at 1
32784:     NanoAssert(f->profFragID >= 1);
32784:     // Should be called exactly once per Fragment.  This will assert if
32784:     // you issue the same FragID to more than one Fragment.
32784:     NanoAssert(!tm->profTab->containsKey(f->profFragID));
32784: 
32784:     FragPI pi = { f->profCount,
32784:                   f->nStaticExits,
32784:                   f->nCodeBytes,
32784:                   f->nExitBytes,
32784:                   NULL, 0 };
32784: 
32784:     // Begin sanity check on the guards
32784:     SeqBuilder<GuardPI> guardsBuilder(*tm->profAlloc);
32784:     GuardRecord* gr;
32784:     uint32_t nGs = 0;
32784:     uint32_t sumOfDynExits = 0;
32784:     for (gr = f->guardsForFrag; gr; gr = gr->nextInFrag) {
32784:          nGs++;
32784:          // Also copy the data into our auxiliary structure.
32784:          // f->guardsForFrag is in reverse order, and so this
32784:          // copy preserves that ordering (->add adds at end).
32784:          // Valid profGuardIDs start at 1.
32784:          NanoAssert(gr->profGuardID > 0);
32784:          sumOfDynExits += gr->profCount;
32784:          GuardPI gpi = { gr->profGuardID, gr->profCount };
32784:          guardsBuilder.add(gpi);
32784:          if (gr->profGuardID > pi.largestGuardID)
32784:              pi.largestGuardID = gr->profGuardID;
32784:     }
32784:     pi.guards = guardsBuilder.get();
32784:     // And put the guard list in forwards order
32784:     pi.guards = reverseInPlace(pi.guards);
32784: 
32784:     // Why is this so?  Because nGs is the number of guards
32784:     // at the time the LIR was generated, whereas f->nStaticExits
32784:     // is the number of them observed by the time it makes it
32784:     // through to the assembler.  It can be the case that LIR
32784:     // optimisation removes redundant guards; hence we expect
32784:     // nGs to always be the same or higher.
32784:     NanoAssert(nGs >= f->nStaticExits);
32784: 
32784:     // Also we can assert that the sum of the exit counts
32784:     // can't exceed the entry count.  It'd be nice to assert that
32784:     // they are exactly equal, but we can't because we don't know
32784:     // how many times we got to the end of the trace.
32784:     NanoAssert(f->profCount >= sumOfDynExits);
32784: 
32784:     // End sanity check on guards
32784: 
32784:     tm->profTab->put(f->profFragID, pi);
32784: }
32784: 
32784: static void
37741: FragProfiling_showResults(TraceMonitor* tm)
32784: {
32784:     uint32_t topFragID[N_TOP_BLOCKS];
32784:     FragPI   topPI[N_TOP_BLOCKS];
32784:     uint64_t totCount = 0, cumulCount;
32784:     uint32_t totSE = 0;
32784:     size_t   totCodeB = 0, totExitB = 0;
40229:     PodArrayZero(topFragID);
40229:     PodArrayZero(topPI);
32784:     FragStatsMap::Iter iter(*tm->profTab);
32784:     while (iter.next()) {
32784:         uint32_t fragID  = iter.key();
32784:         FragPI   pi      = iter.value();
32784:         uint32_t count   = pi.count;
32784:         totCount += (uint64_t)count;
32784:         /* Find the rank for this entry, in tops */
32784:         int r = N_TOP_BLOCKS-1;
32784:         while (true) {
32784:             if (r == -1)
32784:                 break;
32784:             if (topFragID[r] == 0) {
32784:                 r--;
32784:                 continue;
32784:             }
32784:             if (count > topPI[r].count) {
32784:                 r--;
32784:                 continue;
32784:             }
32784:             break;
32784:         }
32784:         r++;
40370:         NanoAssert(r >= 0 && r <= N_TOP_BLOCKS);
32784:         /* This entry should be placed at topPI[r], and entries
32784:            at higher numbered slots moved up one. */
32784:         if (r < N_TOP_BLOCKS) {
32784:             for (int s = N_TOP_BLOCKS-1; s > r; s--) {
32784:                 topFragID[s] = topFragID[s-1];
32784:                 topPI[s]     = topPI[s-1];
32784:             }
32784:             topFragID[r] = fragID;
32784:             topPI[r]     = pi;
32784:         }
32784:     }
32784: 
37741:     LogController.printf(
32784:         "\n----------------- Per-fragment execution counts ------------------\n");
37741:     LogController.printf(
33132:         "\nTotal count = %llu\n\n", (unsigned long long int)totCount);
32784: 
37741:     LogController.printf(
32784:         "           Entry counts         Entry counts       ----- Static -----\n");
37741:     LogController.printf(
32784:         "         ------Self------     ----Cumulative---   Exits  Cbytes Xbytes   FragID\n");
37741:     LogController.printf("\n");
32784: 
32784:     if (totCount == 0)
32784:         totCount = 1; /* avoid division by zero */
32784:     cumulCount = 0;
32784:     int r;
32784:     for (r = 0; r < N_TOP_BLOCKS; r++) {
32784:         if (topFragID[r] == 0)
32784:             break;
32784:         cumulCount += (uint64_t)topPI[r].count;
37741:         LogController.printf("%3d:     %5.2f%% %9u     %6.2f%% %9llu"
32784:                              "     %3d   %5u  %5u   %06u\n",
32784:                              r,
32784:                              (double)topPI[r].count * 100.0 / (double)totCount,
32784:                              topPI[r].count,
32784:                              (double)cumulCount * 100.0 / (double)totCount,
33132:                              (unsigned long long int)cumulCount,
32784:                              topPI[r].nStaticExits,
33132:                              (unsigned int)topPI[r].nCodeBytes,
33132:                              (unsigned int)topPI[r].nExitBytes,
32784:                              topFragID[r]);
32784:         totSE += (uint32_t)topPI[r].nStaticExits;
32784:         totCodeB += topPI[r].nCodeBytes;
32784:         totExitB += topPI[r].nExitBytes;
32784:     }
37741:     LogController.printf("\nTotal displayed code bytes = %u, "
32784:                             "exit bytes = %u\n"
32784:                             "Total displayed static exits = %d\n\n",
33132:                             (unsigned int)totCodeB, (unsigned int)totExitB, totSE);
32784: 
37741:     LogController.printf("Analysis by exit counts\n\n");
32784: 
32784:     for (r = 0; r < N_TOP_BLOCKS; r++) {
32784:         if (topFragID[r] == 0)
32784:             break;
37741:         LogController.printf("FragID=%06u, total count %u:\n", topFragID[r],
32784:                                 topPI[r].count);
32784:         uint32_t madeItToEnd = topPI[r].count;
32784:         uint32_t totThisFrag = topPI[r].count;
32784:         if (totThisFrag == 0)
32784:             totThisFrag = 1;
32784:         GuardPI gpi;
32784:         // visit the guards, in forward order
32784:         for (Seq<GuardPI>* guards = topPI[r].guards; guards; guards = guards->tail) {
32784:             gpi = (*guards).head;
32784:             if (gpi.count == 0)
32784:                 continue;
32784:             madeItToEnd -= gpi.count;
37741:             LogController.printf("   GuardID=%03u    %7u (%5.2f%%)\n",
32784:                                     gpi.guardID, gpi.count,
32784:                                     100.0 * (double)gpi.count / (double)totThisFrag);
32784:         }
37741:         LogController.printf("   Looped (%03u)   %7u (%5.2f%%)\n",
32784:                                 topPI[r].largestGuardID+1,
32784:                                 madeItToEnd,
32784:                                 100.0 * (double)madeItToEnd /  (double)totThisFrag);
32784:         NanoAssert(madeItToEnd <= topPI[r].count); // else unsigned underflow
37741:         LogController.printf("\n");
32784:     }
32784: 
32784:     tm->profTab = NULL;
32784: }
32784: 
32784: #endif
32784: 
32784: /* ----------------------------------------------------------------- */
32784: 
33157: #ifdef DEBUG
29893: static const char*
29894: getExitName(ExitType type)
29893: {
29893:     static const char* exitNames[] =
29893:     {
29893:     #define MAKE_EXIT_STRING(x) #x,
29893:     JS_TM_EXITCODES(MAKE_EXIT_STRING)
29893:     #undef MAKE_EXIT_STRING
29895:     NULL
29893:     };
29893: 
29900:     JS_ASSERT(type < TOTAL_EXIT_TYPES);
29893: 
29893:     return exitNames[type];
29893: }
33157: 
33157: static JSBool FASTCALL
33157: PrintOnTrace(char* format, uint32 argc, double *argv)
33157: {
33157:     union {
33157:         struct {
33157:             uint32 lo;
33157:             uint32 hi;
33157:         } i;
33157:         double   d;
33157:         char     *cstr;
33157:         JSObject *o;
33157:         JSString *s;
33157:     } u;
33157: 
33157: #define GET_ARG() JS_BEGIN_MACRO          \
33157:         if (argi >= argc) { \
33157:         fprintf(out, "[too few args for format]"); \
33157:         break;       \
33157: } \
33157:     u.d = argv[argi++]; \
33157:     JS_END_MACRO
33157: 
33157:     FILE *out = stderr;
33157: 
33157:     uint32 argi = 0;
33157:     for (char *p = format; *p; ++p) {
33157:         if (*p != '%') {
33157:             putc(*p, out);
33157:             continue;
33157:         }
33157:         char ch = *++p;
33157:         if (!ch) {
33157:             fprintf(out, "[trailing %%]");
33157:             continue;
33157:         }
33157: 
33157:         switch (ch) {
33157:         case 'a':
33157:             GET_ARG();
33162:             fprintf(out, "[%u:%u 0x%x:0x%x %f]", u.i.lo, u.i.hi, u.i.lo, u.i.hi, u.d);
33157:             break;
33157:         case 'd':
33157:             GET_ARG();
33157:             fprintf(out, "%d", u.i.lo);
33157:             break;
33157:         case 'u':
33157:             GET_ARG();
33157:             fprintf(out, "%u", u.i.lo);
33157:             break;
33157:         case 'x':
33157:             GET_ARG();
33157:             fprintf(out, "%x", u.i.lo);
33157:             break;
33157:         case 'f':
33157:             GET_ARG();
33162:             fprintf(out, "%f", u.d);
33157:             break;
33157:         case 'o':
33157:             GET_ARG();
33157:             js_DumpObject(u.o);
33157:             break;
33157:         case 's':
33157:             GET_ARG();
33157:             {
33157:                 size_t length = u.s->length();
33157:                 // protect against massive spew if u.s is a bad pointer.
33157:                 if (length > 1 << 16)
33157:                     length = 1 << 16;
33157:                 jschar *chars = u.s->chars();
33157:                 for (unsigned i = 0; i < length; ++i) {
33157:                     jschar co = chars[i];
33157:                     if (co < 128)
33157:                         putc(co, out);
33157:                     else if (co < 256)
33157:                         fprintf(out, "\\u%02x", co);
33157:                     else
33157:                         fprintf(out, "\\u%04x", co);
33157:                 }
33157:             }
33157:             break;
33157:         case 'S':
33157:             GET_ARG();
33157:             fprintf(out, "%s", u.cstr);
33157:             break;
33157:         default:
33157:             fprintf(out, "[invalid %%%c]", *p);
33157:         }
33157:     }
33157: 
33157: #undef GET_ARG
33157: 
33157:     return JS_TRUE;
33157: }
33157: 
39910: JS_DEFINE_CALLINFO_3(extern, BOOL, PrintOnTrace, CHARPTR, UINT32, DOUBLEPTR, 0, ACC_STORE_ANY)
33157: 
33157: // This version is not intended to be called directly: usually it is easier to
33157: // use one of the other overloads.
33157: void
33157: TraceRecorder::tprint(const char *format, int count, nanojit::LIns *insa[])
33157: {
33157:     size_t size = strlen(format) + 1;
34347:     char* data = (char*) traceMonitor->traceAlloc->alloc(size);
33157:     memcpy(data, format, size);
33157: 
34347:     double *args = (double*) traceMonitor->traceAlloc->alloc(count * sizeof(double));
33157:     for (int i = 0; i < count; ++i) {
33157:         JS_ASSERT(insa[i]);
40353:         lir->insStorei(insa[i], INS_CONSTPTR(args), sizeof(double) * i, ACC_OTHER);
33157:     }
33157: 
33157:     LIns* args_ins[] = { INS_CONSTPTR(args), INS_CONST(count), INS_CONSTPTR(data) };
33157:     LIns* call_ins = lir->insCall(&PrintOnTrace_ci, args_ins);
33157:     guard(false, lir->ins_eq0(call_ins), MISMATCH_EXIT);
33157: }
33157: 
33157: // Generate a 'printf'-type call from trace for debugging.
33157: void
33157: TraceRecorder::tprint(const char *format)
33157: {
33157:     LIns* insa[] = { NULL };
33157:     tprint(format, 0, insa);
33157: }
33157: 
33157: void
33157: TraceRecorder::tprint(const char *format, LIns *ins)
33157: {
33157:     LIns* insa[] = { ins };
33157:     tprint(format, 1, insa);
33157: }
33157: 
33157: void
33157: TraceRecorder::tprint(const char *format, LIns *ins1, LIns *ins2)
33157: {
33157:     LIns* insa[] = { ins1, ins2 };
33157:     tprint(format, 2, insa);
33157: }
33157: 
33157: void
33157: TraceRecorder::tprint(const char *format, LIns *ins1, LIns *ins2, LIns *ins3)
33157: {
33157:     LIns* insa[] = { ins1, ins2, ins3 };
33157:     tprint(format, 3, insa);
33157: }
33157: 
33157: void
33157: TraceRecorder::tprint(const char *format, LIns *ins1, LIns *ins2, LIns *ins3, LIns *ins4)
33157: {
33157:     LIns* insa[] = { ins1, ins2, ins3, ins4 };
33157:     tprint(format, 4, insa);
33157: }
33157: 
33157: void
33157: TraceRecorder::tprint(const char *format, LIns *ins1, LIns *ins2, LIns *ins3, LIns *ins4,
33157:                       LIns *ins5)
33157: {
33157:     LIns* insa[] = { ins1, ins2, ins3, ins4, ins5 };
33157:     tprint(format, 5, insa);
33157: }
33157: 
33157: void
33157: TraceRecorder::tprint(const char *format, LIns *ins1, LIns *ins2, LIns *ins3, LIns *ins4,
33157:                       LIns *ins5, LIns *ins6)
33157: {
33157:     LIns* insa[] = { ins1, ins2, ins3, ins4, ins5, ins6 };
33157:     tprint(format, 6, insa);
33157: }
29894: #endif
29893: 
30860: /*
30860:  * The entire VM shares one oracle. Collisions and concurrent updates are
30860:  * tolerated and worst case cause performance regressions.
30860:  */
19535: static Oracle oracle;
17981: 
17596: Tracker::Tracker()
17213: {
33550:     pagelist = NULL;
17293: }
17239: 
17596: Tracker::~Tracker()
17293: {
17293:     clear();
17293: }
17293: 
33550: inline jsuword
33177: Tracker::getTrackerPageBase(const void* v) const
33177: {
33550:     return jsuword(v) & ~TRACKER_PAGE_MASK;
33550: }
33550: 
33550: inline jsuword
33550: Tracker::getTrackerPageOffset(const void* v) const
33550: {
33550:     return (jsuword(v) & TRACKER_PAGE_MASK) >> 2;
33177: }
33177: 
33177: struct Tracker::TrackerPage*
33177: Tracker::findTrackerPage(const void* v) const
33177: {
33177:     jsuword base = getTrackerPageBase(v);
33177:     struct Tracker::TrackerPage* p = pagelist;
17293:     while (p) {
33550:         if (p->base == base)
17293:             return p;
17293:         p = p->next;
17293:     }
33550:     return NULL;
17293: }
17293: 
33177: struct Tracker::TrackerPage*
33550: Tracker::addTrackerPage(const void* v)
33550: {
33177:     jsuword base = getTrackerPageBase(v);
33550:     struct TrackerPage* p = (struct TrackerPage*) calloc(1, sizeof(*p));
17293:     p->base = base;
17293:     p->next = pagelist;
17293:     pagelist = p;
17293:     return p;
17213: }
17213: 
17596: void
17596: Tracker::clear()
17213: {
17293:     while (pagelist) {
33177:         TrackerPage* p = pagelist;
17293:         pagelist = pagelist->next;
33093:         free(p);
17259:     }
17293: }
17293: 
17773: bool
17773: Tracker::has(const void *v) const
17773: {
17811:     return get(v) != NULL;
17811: }
17811: 
17811: LIns*
17811: Tracker::get(const void* v) const
17811: {
33177:     struct Tracker::TrackerPage* p = findTrackerPage(v);
17773:     if (!p)
17811:         return NULL;
33550:     return p->map[getTrackerPageOffset(v)];
17219: }
17247: 
17596: void
17596: Tracker::set(const void* v, LIns* i)
17247: {
33177:     struct Tracker::TrackerPage* p = findTrackerPage(v);
17293:     if (!p)
33177:         p = addTrackerPage(v);
33550:     p->map[getTrackerPageOffset(v)] = i;
17293: }
17293: 
30860: static inline jsuint
30860: argSlots(JSStackFrame* fp)
28244: {
28244:     return JS_MAX(fp->argc, fp->fun->nargs);
28244: }
28244: 
30860: static inline bool
30860: isNumber(jsval v)
17464: {
17464:     return JSVAL_IS_INT(v) || JSVAL_IS_DOUBLE(v);
17464: }
17464: 
30860: static inline jsdouble
30860: asNumber(jsval v)
17464: {
17464:     JS_ASSERT(isNumber(v));
17464:     if (JSVAL_IS_DOUBLE(v))
17464:         return *JSVAL_TO_DOUBLE(v);
17464:     return (jsdouble)JSVAL_TO_INT(v);
17464: }
17464: 
30860: static inline bool
30860: isInt32(jsval v)
17479: {
17479:     if (!isNumber(v))
17479:         return false;
17479:     jsdouble d = asNumber(v);
17759:     jsint i;
33166:     return !!JSDOUBLE_IS_INT(d, i);
17479: }
17479: 
30860: static inline jsint
30860: asInt32(jsval v)
26274: {
26274:     JS_ASSERT(isNumber(v));
26274:     if (JSVAL_IS_INT(v))
26274:         return JSVAL_TO_INT(v);
26274: #ifdef DEBUG
26274:     jsint i;
26274:     JS_ASSERT(JSDOUBLE_IS_INT(*JSVAL_TO_DOUBLE(v), i));
26274: #endif
26274:     return jsint(*JSVAL_TO_DOUBLE(v));
25099: }
25099: 
29896: /* Return TT_DOUBLE for all numbers (int and double) and the tag otherwise. */
37741: static inline TraceType
30860: GetPromotedType(jsval v)
19576: {
27541:     if (JSVAL_IS_INT(v))
29896:         return TT_DOUBLE;
27541:     if (JSVAL_IS_OBJECT(v)) {
27541:         if (JSVAL_IS_NULL(v))
29896:             return TT_NULL;
40430:         if (JSVAL_TO_OBJECT(v)->isFunction())
29896:             return TT_FUNCTION;
29896:         return TT_OBJECT;
29896:     }
40307:     /* N.B. void is JSVAL_SPECIAL. */
40307:     if (JSVAL_IS_VOID(v))
40307:         return TT_VOID;
29896:     uint8_t tag = JSVAL_TAG(v);
31521:     JS_ASSERT(tag == JSVAL_DOUBLE || tag == JSVAL_STRING || tag == JSVAL_SPECIAL);
30850:     JS_STATIC_ASSERT(static_cast<jsvaltag>(TT_DOUBLE) == JSVAL_DOUBLE);
30850:     JS_STATIC_ASSERT(static_cast<jsvaltag>(TT_STRING) == JSVAL_STRING);
40307:     JS_STATIC_ASSERT(static_cast<jsvaltag>(TT_SPECIAL) == JSVAL_SPECIAL);
37741:     return TraceType(tag);
29896: }
29896: 
29896: /* Return TT_INT32 for all whole numbers that fit into signed 32-bit and the tag otherwise. */
37741: static inline TraceType
30860: getCoercedType(jsval v)
17891: {
27541:     if (isInt32(v))
29896:         return TT_INT32;
27541:     if (JSVAL_IS_OBJECT(v)) {
27541:         if (JSVAL_IS_NULL(v))
29896:             return TT_NULL;
40430:         if (JSVAL_TO_OBJECT(v)->isFunction())
29896:             return TT_FUNCTION;
29896:         return TT_OBJECT;
29896:     }
40307:     /* N.B. void is JSVAL_SPECIAL. */
40307:     if (JSVAL_IS_VOID(v))
40307:         return TT_VOID;
29896:     uint8_t tag = JSVAL_TAG(v);
31521:     JS_ASSERT(tag == JSVAL_DOUBLE || tag == JSVAL_STRING || tag == JSVAL_SPECIAL);
30850:     JS_STATIC_ASSERT(static_cast<jsvaltag>(TT_DOUBLE) == JSVAL_DOUBLE);
30850:     JS_STATIC_ASSERT(static_cast<jsvaltag>(TT_STRING) == JSVAL_STRING);
40307:     JS_STATIC_ASSERT(static_cast<jsvaltag>(TT_SPECIAL) == JSVAL_SPECIAL);
37741:     return TraceType(tag);
17891: }
17891: 
30860: /* Constant seed and accumulate step borrowed from the DJB hash. */
30860: 
30860: const uintptr_t ORACLE_MASK = ORACLE_SIZE - 1;
30860: JS_STATIC_ASSERT((ORACLE_MASK & ORACLE_SIZE) == 0);
30860: 
30860: const uintptr_t FRAGMENT_TABLE_MASK = FRAGMENT_TABLE_SIZE - 1;
30860: JS_STATIC_ASSERT((FRAGMENT_TABLE_MASK & FRAGMENT_TABLE_SIZE) == 0);
30860: 
30860: const uintptr_t HASH_SEED = 5381;
22613: 
22613: static inline void
30860: HashAccum(uintptr_t& h, uintptr_t i, uintptr_t mask)
24307: {
24307:     h = ((h << 5) + h + (mask & i)) & mask;
22613: }
22613: 
30860: static JS_REQUIRES_STACK inline int
33564: StackSlotHash(JSContext* cx, unsigned slot, const void* pc)
22613: {
24307:     uintptr_t h = HASH_SEED;
30860:     HashAccum(h, uintptr_t(cx->fp->script), ORACLE_MASK);
33564:     HashAccum(h, uintptr_t(pc), ORACLE_MASK);
30860:     HashAccum(h, uintptr_t(slot), ORACLE_MASK);
22614:     return int(h);
22614: }
22614: 
30860: static JS_REQUIRES_STACK inline int
30860: GlobalSlotHash(JSContext* cx, unsigned slot)
22613: {
24307:     uintptr_t h = HASH_SEED;
22613:     JSStackFrame* fp = cx->fp;
22613: 
22613:     while (fp->down)
22613:         fp = fp->down;
22613: 
30860:     HashAccum(h, uintptr_t(fp->script), ORACLE_MASK);
40424:     HashAccum(h, uintptr_t(OBJ_SHAPE(fp->scopeChain->getGlobal())), ORACLE_MASK);
30860:     HashAccum(h, uintptr_t(slot), ORACLE_MASK);
22614:     return int(h);
22613: }
22613: 
29354: static inline int
30860: PCHash(jsbytecode* pc)
29354: {
29354:     return int(uintptr_t(pc) & ORACLE_MASK);
29354: }
29354: 
24290: Oracle::Oracle()
24290: {
28171:     /* Grow the oracle bitsets to their (fixed) size here, once. */
31485:     _stackDontDemote.set(ORACLE_SIZE-1);
31485:     _globalDontDemote.set(ORACLE_SIZE-1);
24290:     clear();
24290: }
24290: 
17981: /* Tell the oracle that a certain global variable should not be demoted. */
23456: JS_REQUIRES_STACK void
22613: Oracle::markGlobalSlotUndemotable(JSContext* cx, unsigned slot)
22613: {
33564:     #ifdef DEBUG_dvander
33564:     printf("MGSU: %d [%08x]: %d\n", slot, GlobalSlotHash(cx, slot),
33564:            _globalDontDemote.get(GlobalSlotHash(cx, slot)));
33564:     #endif
31485:     _globalDontDemote.set(GlobalSlotHash(cx, slot));
17981: }
17981: 
17981: /* Consult with the oracle whether we shouldn't demote a certain global variable. */
23456: JS_REQUIRES_STACK bool
22613: Oracle::isGlobalSlotUndemotable(JSContext* cx, unsigned slot) const
22613: {
33564:     #ifdef DEBUG_dvander
33564:     printf("IGSU: %d [%08x]: %d\n", slot, GlobalSlotHash(cx, slot),
33564:            _globalDontDemote.get(GlobalSlotHash(cx, slot)));
33564:     #endif
30860:     return _globalDontDemote.get(GlobalSlotHash(cx, slot));
17981: }
17981: 
29354: /* Tell the oracle that a certain slot at a certain stack slot should not be demoted. */
23456: JS_REQUIRES_STACK void
33564: Oracle::markStackSlotUndemotable(JSContext* cx, unsigned slot, const void* pc)
33564: {
33564:     #ifdef DEBUG_dvander
33564:     printf("MSSU: %p:%d [%08x]: %d\n", pc, slot, StackSlotHash(cx, slot, pc),
33564:            _stackDontDemote.get(StackSlotHash(cx, slot, pc)));
33564:     #endif
33564:     _stackDontDemote.set(StackSlotHash(cx, slot, pc));
33564: }
33564: 
33564: JS_REQUIRES_STACK void
22613: Oracle::markStackSlotUndemotable(JSContext* cx, unsigned slot)
22613: {
33564:     markStackSlotUndemotable(cx, slot, cx->fp->regs->pc);
17981: }
17981: 
17981: /* Consult with the oracle whether we shouldn't demote a certain slot. */
23456: JS_REQUIRES_STACK bool
33564: Oracle::isStackSlotUndemotable(JSContext* cx, unsigned slot, const void* pc) const
33564: {
33564:     #ifdef DEBUG_dvander
33564:     printf("ISSU: %p:%d [%08x]: %d\n", pc, slot, StackSlotHash(cx, slot, pc),
33564:            _stackDontDemote.get(StackSlotHash(cx, slot, pc)));
33564:     #endif
33564:     return _stackDontDemote.get(StackSlotHash(cx, slot, pc));
33564: }
33564: 
33564: JS_REQUIRES_STACK bool
22613: Oracle::isStackSlotUndemotable(JSContext* cx, unsigned slot) const
22613: {
33564:     return isStackSlotUndemotable(cx, slot, cx->fp->regs->pc);
17981: }
17981: 
29354: /* Tell the oracle that a certain slot at a certain bytecode location should not be demoted. */
29354: void
29354: Oracle::markInstructionUndemotable(jsbytecode* pc)
29354: {
31485:     _pcDontDemote.set(PCHash(pc));
29354: }
29354: 
29354: /* Consult with the oracle whether we shouldn't demote a certain bytecode location. */
29354: bool
29354: Oracle::isInstructionUndemotable(jsbytecode* pc) const
29354: {
30860:     return _pcDontDemote.get(PCHash(pc));
29354: }
29354: 
24290: void
24290: Oracle::clearDemotability()
18273: {
22613:     _stackDontDemote.reset();
22613:     _globalDontDemote.reset();
29354:     _pcDontDemote.reset();
22613: }
22613: 
31473: JS_REQUIRES_STACK static JS_INLINE void
36361: MarkSlotUndemotable(JSContext* cx, LinkableFragment* f, unsigned slot)
36361: {
36361:     if (slot < f->nStackTypes) {
31473:         oracle.markStackSlotUndemotable(cx, slot);
31473:         return;
31473:     }
31473: 
36361:     uint16* gslots = f->globalSlots->data();
36361:     oracle.markGlobalSlotUndemotable(cx, gslots[slot - f->nStackTypes]);
31473: }
31473: 
33564: JS_REQUIRES_STACK static JS_INLINE void
36361: MarkSlotUndemotable(JSContext* cx, LinkableFragment* f, unsigned slot, const void* pc)
36361: {
36361:     if (slot < f->nStackTypes) {
33564:         oracle.markStackSlotUndemotable(cx, slot, pc);
33564:         return;
33564:     }
33564: 
36361:     uint16* gslots = f->globalSlots->data();
36361:     oracle.markGlobalSlotUndemotable(cx, gslots[slot - f->nStackTypes]);
33564: }
33564: 
33564: static JS_REQUIRES_STACK inline bool
36361: IsSlotUndemotable(JSContext* cx, LinkableFragment* f, unsigned slot, const void* ip)
36361: {
36361:     if (slot < f->nStackTypes)
33564:         return oracle.isStackSlotUndemotable(cx, slot, ip);
33564: 
36361:     uint16* gslots = f->globalSlots->data();
36361:     return oracle.isGlobalSlotUndemotable(cx, gslots[slot - f->nStackTypes]);
33564: }
33564: 
31495: static JS_REQUIRES_STACK inline bool
36361: IsSlotUndemotable(JSContext* cx, LinkableFragment* f, unsigned slot)
36361: {
36361:     return IsSlotUndemotable(cx, f, slot, cx->fp->regs->pc);
31495: }
31495: 
33563: class FrameInfoCache
33563: {
38568:     struct HashPolicy
38568:     {
38568:         typedef FrameInfo *Lookup;
38568:         static HashNumber hash(const FrameInfo* fi) {
37741:             size_t len = sizeof(FrameInfo) + fi->callerHeight * sizeof(TraceType);
38568:             HashNumber h = 0;
33563:             const unsigned char *s = (const unsigned char*)fi;
33563:             for (size_t i = 0; i < len; i++, s++)
33563:                 h = JS_ROTATE_LEFT32(h, 4) ^ *s;
33563:             return h;
33563:         }
33563: 
38568:         static bool match(const FrameInfo* fi1, const FrameInfo* fi2) {
38568:             if (memcmp(fi1, fi2, sizeof(FrameInfo)) != 0)
38568:                 return false;
38568:             return memcmp(fi1->get_typemap(), fi2->get_typemap(),
38568:                           fi1->callerHeight * sizeof(TraceType)) == 0;
38568:         }
38568:     };
38568: 
38568:     typedef HashSet<FrameInfo *, HashPolicy, SystemAllocPolicy> FrameSet;
38568: 
38568:     FrameSet set;
33563:     VMAllocator *allocator;
33563: 
33563:   public:
38568: 
38568:     FrameInfoCache(VMAllocator *allocator);
38568: 
38568:     void reset() {
38568:         set.clear();
38568:     }
38568: 
38568:     FrameInfo *memoize(FrameInfo *fi) {
38568:         FrameSet::AddPtr p = set.lookupForAdd(fi);
38568:         if (!p) {
33563:             FrameInfo* n = (FrameInfo*)
37741:                 allocator->alloc(sizeof(FrameInfo) + fi->callerHeight * sizeof(TraceType));
37741:             memcpy(n, fi, sizeof(FrameInfo) + fi->callerHeight * sizeof(TraceType));
38568:             if (!set.add(p, n))
38568:                 return NULL;
38568:         }
38568: 
38568:         return *p;
33563:     }
33563: };
33563: 
38568: FrameInfoCache::FrameInfoCache(VMAllocator *allocator)
38568:   : allocator(allocator)
38568: {
38568:     if (!set.init())
38568:         OutOfMemoryAbort();
38568: }
28105: 
28105: #define PC_HASH_COUNT 1024
28105: 
25627: static void
30860: Blacklist(jsbytecode* pc)
28105: {
29875:     AUDIT(blacklisted);
33564:     JS_ASSERT(*pc == JSOP_TRACE || *pc == JSOP_NOP || *pc == JSOP_CALL);
33564:     if (*pc == JSOP_CALL) {
33564:         JS_ASSERT(*(pc + JSOP_CALL_LENGTH) == JSOP_TRACE ||
33564:                   *(pc + JSOP_CALL_LENGTH) == JSOP_NOP);
33564:         *(pc + JSOP_CALL_LENGTH) = JSOP_NOP;
33564:     } else if (*pc == JSOP_TRACE) {
25627:         *pc = JSOP_NOP;
25627:     }
33564: }
33564: 
33564: static bool
33564: IsBlacklisted(jsbytecode* pc)
33564: {
33564:     if (*pc == JSOP_NOP)
33564:         return true;
33564:     if (*pc == JSOP_CALL)
33564:         return *(pc + JSOP_CALL_LENGTH) == JSOP_NOP;
33564:     return false;
33564: }
25627: 
25627: static void
30860: Backoff(JSContext *cx, jsbytecode* pc, Fragment* tree = NULL)
28105: {
33542:     /* N.B. This code path cannot assume the recorder is/is not alive. */
38568:     RecordAttemptMap &table = *JS_TRACE_MONITOR(cx).recordAttempts;
38568:     if (RecordAttemptMap::AddPtr p = table.lookupForAdd(pc)) {
38568:         if (p->value++ > (BL_ATTEMPTS * MAXPEERS)) {
38568:             p->value = 0;
30860:             Blacklist(pc);
25627:             return;
25627:         }
38568:     } else {
38568:         table.add(p, pc, 0);
28105:     }
28105: 
28105:     if (tree) {
25627:         tree->hits() -= BL_BACKOFF;
28105: 
28105:         /*
28105:          * In case there is no entry or no table (due to OOM) or some
28105:          * serious imbalance in the recording-attempt distribution on a
28105:          * multitree, give each tree another chance to blacklist here as
28105:          * well.
28105:          */
28105:         if (++tree->recordAttempts > BL_ATTEMPTS)
30860:             Blacklist(pc);
28105:     }
28105: }
28105: 
28105: static void
30860: ResetRecordingAttempts(JSContext *cx, jsbytecode* pc)
28105: {
38568:     RecordAttemptMap &table = *JS_TRACE_MONITOR(cx).recordAttempts;
38568:     if (RecordAttemptMap::Ptr p = table.lookup(pc))
38568:         p->value = 0;
25627: }
25627: 
24307: static inline size_t
30860: FragmentHash(const void *ip, JSObject* globalObj, uint32 globalShape, uint32 argc)
24307: {
24307:     uintptr_t h = HASH_SEED;
30860:     HashAccum(h, uintptr_t(ip), FRAGMENT_TABLE_MASK);
30860:     HashAccum(h, uintptr_t(globalObj), FRAGMENT_TABLE_MASK);
30860:     HashAccum(h, uintptr_t(globalShape), FRAGMENT_TABLE_MASK);
30860:     HashAccum(h, uintptr_t(argc), FRAGMENT_TABLE_MASK);
24307:     return size_t(h);
24307: }
24307: 
33748: static void
37741: RawLookupFirstPeer(TraceMonitor* tm, const void *ip, JSObject* globalObj,
33748:                    uint32 globalShape, uint32 argc,
35044:                    TreeFragment*& firstInBucket, TreeFragment**& prevTreeNextp)
33748: {
33748:     size_t h = FragmentHash(ip, globalObj, globalShape, argc);
35044:     TreeFragment** ppf = &tm->vmfragments[h];
33748:     firstInBucket = *ppf;
35044:     for (; TreeFragment* pf = *ppf; ppf = &pf->next) {
33748:         if (pf->globalObj == globalObj &&
33748:             pf->globalShape == globalShape &&
33748:             pf->ip == ip &&
33748:             pf->argc == argc) {
33748:             prevTreeNextp = ppf;
33748:             return;
33748:         }
33748:     }
33748:     prevTreeNextp = ppf;
33748:     return;
33748: }
33748: 
35044: static TreeFragment*
37741: LookupLoop(TraceMonitor* tm, const void *ip, JSObject* globalObj,
33748:                 uint32 globalShape, uint32 argc)
33748: {
35044:     TreeFragment *_, **prevTreeNextp;
33748:     RawLookupFirstPeer(tm, ip, globalObj, globalShape, argc, _, prevTreeNextp);
33748:     return *prevTreeNextp;
24307: }
24307: 
35044: static TreeFragment*
37741: LookupOrAddLoop(TraceMonitor* tm, const void *ip, JSObject* globalObj,
33748:                 uint32 globalShape, uint32 argc)
33748: {
35044:     TreeFragment *firstInBucket, **prevTreeNextp;
33748:     RawLookupFirstPeer(tm, ip, globalObj, globalShape, argc, firstInBucket, prevTreeNextp);
35044:     if (TreeFragment *f = *prevTreeNextp)
33748:         return f;
33748: 
32784:     verbose_only(
37741:     uint32_t profFragID = (LogController.lcbits & LC_FragProfile)
32784:                           ? (++(tm->lastFragID)) : 0;
32784:     )
36361:     TreeFragment* f = new (*tm->dataAlloc) TreeFragment(ip, tm->dataAlloc, globalObj, globalShape,
36361:                                                         argc verbose_only(, profFragID));
33748:     f->root = f;                /* f is the root of a new tree */
33748:     *prevTreeNextp = f;         /* insert f at the end of the vmfragments bucket-list */
33748:     f->next = NULL;
33748:     f->first = f;               /* initialize peer-list at f */
33748:     f->peer = NULL;
33748:     return f;
33748: }
33748: 
35044: static TreeFragment*
37741: AddNewPeerToPeerList(TraceMonitor* tm, TreeFragment* peer)
33748: {
33748:     JS_ASSERT(peer);
33748:     verbose_only(
37741:     uint32_t profFragID = (LogController.lcbits & LC_FragProfile)
33748:                           ? (++(tm->lastFragID)) : 0;
33748:     )
36361:     TreeFragment* f = new (*tm->dataAlloc) TreeFragment(peer->ip, tm->dataAlloc, peer->globalObj,
33748:                                                         peer->globalShape, peer->argc
33748:                                                         verbose_only(, profFragID));
33748:     f->root = f;                /* f is the root of a new tree */
33748:     f->first = peer->first;     /* add f to peer list */
33748:     f->peer = peer->peer;
33748:     peer->peer = f;
33748:     /* only the |first| Fragment of a peer list needs a valid |next| field */
35044:     debug_only(f->next = (TreeFragment*)0xcdcdcdcd);
24307:     return f;
24307: }
24307: 
36361: JS_REQUIRES_STACK void
36361: TreeFragment::initialize(JSContext* cx, SlotList *globalSlots)
36361: {
36361:     this->dependentTrees.clear();
36361:     this->linkedTrees.clear();
36361:     this->globalSlots = globalSlots;
36361: 
36361:     /* Capture the coerced type of each active slot in the type map. */
36361:     this->typeMap.captureTypes(cx, globalObj, *globalSlots, 0 /* callDepth */);
36361:     this->nStackTypes = this->typeMap.length() - globalSlots->length();
36361: 
36361: #ifdef DEBUG
36361:     this->treeFileName = cx->fp->script->filename;
36361:     this->treeLineNumber = js_FramePCToLineNumber(cx, cx->fp);
36361:     this->treePCOffset = FramePCOffset(cx->fp);
36361: #endif
36361:     this->script = cx->fp->script;
36361:     this->recursion = Recursion_None;
36361:     this->gcthings.clear();
36361:     this->sprops.clear();
36361:     this->unstableExits = NULL;
36361:     this->sideExits.clear();
36361: 
36361:     /* Determine the native frame layout at the entry point. */
36361:     this->nativeStackBase = (nStackTypes - (cx->fp->regs->sp - StackBase(cx->fp))) *
36361:                              sizeof(double);
36361:     this->maxNativeStackSlots = nStackTypes;
36361:     this->maxCallDepth = 0;
36361: }
36361: 
36361: UnstableExit*
36361: TreeFragment::removeUnstableExit(VMSideExit* exit)
36361: {
36361:     /* Now erase this exit from the unstable exit list. */
36361:     UnstableExit** tail = &this->unstableExits;
36361:     for (UnstableExit* uexit = this->unstableExits; uexit != NULL; uexit = uexit->next) {
36361:         if (uexit->exit == exit) {
36361:             *tail = uexit->next;
36361:             return *tail;
36361:         }
36361:         tail = &uexit->next;
36361:     }
36361:     JS_NOT_REACHED("exit not in unstable exit list");
36361:     return NULL;
36361: }
36361: 
28913: #ifdef DEBUG
28913: static void
37741: AssertTreeIsUnique(TraceMonitor* tm, TreeFragment* f)
28913: {
28913:     JS_ASSERT(f->root == f);
30860: 
28913:     /*
28913:      * Check for duplicate entry type maps.  This is always wrong and hints at
28913:      * trace explosion since we are trying to stabilize something without
28913:      * properly connecting peer edges.
28913:      */
35044:     for (TreeFragment* peer = LookupLoop(tm, f->ip, f->globalObj, f->globalShape, f->argc);
28913:          peer != NULL;
28913:          peer = peer->peer) {
28913:         if (!peer->code() || peer == f)
28913:             continue;
36361:         JS_ASSERT(!f->typeMap.matches(peer->typeMap));
28913:     }
28913: }
28913: #endif
28913: 
25937: static void
40226: AttemptCompilation(JSContext *cx, JSObject* globalObj, jsbytecode* pc, uint32 argc)
40226: {
40226:     TraceMonitor *tm = &JS_TRACE_MONITOR(cx);
40226: 
30860:     /* If we already permanently blacklisted the location, undo that. */
33564:     JS_ASSERT(*pc == JSOP_NOP || *pc == JSOP_TRACE || *pc == JSOP_CALL);
33564:     if (*pc == JSOP_NOP)
32776:         *pc = JSOP_TRACE;
30860:     ResetRecordingAttempts(cx, pc);
30860: 
30860:     /* Breathe new life into all peer fragments at the designated loop header. */
35044:     TreeFragment* f = LookupLoop(tm, pc, globalObj, OBJ_SHAPE(globalObj), argc);
26726:     if (!f) {
26726:         /*
26726:          * If the global object's shape changed, we can't easily find the
26726:          * corresponding loop header via a hash table lookup. In this
26726:          * we simply bail here and hope that the fragment has another
26726:          * outstanding compilation attempt. This case is extremely rare.
26726:          */
26726:         return;
26726:     }
25937:     JS_ASSERT(f->root == f);
25937:     f = f->first;
25937:     while (f) {
25937:         JS_ASSERT(f->root == f);
25937:         --f->recordAttempts;
25937:         f->hits() = HOTLOOP;
25937:         f = f->peer;
25937:     }
25937: }
18273: 
36402: 
30860: static bool
36402: isfop(LIns* i, LOpcode op)
36402: {
36402:     if (i->isop(op))
18773:         return true;
38567: #if NJ_SOFTFLOAT_SUPPORTED
26545:     if (nanojit::AvmCore::config.soft_float &&
26545:         i->isop(LIR_qjoin) &&
36402:         i->oprnd1()->isop(LIR_icall) &&
30860:         i->oprnd2()->isop(LIR_callh)) {
38558:         return i->oprnd1()->callInfo() == softFloatOps.opmap[op];
36402:     }
38567: #endif
36402:     return false;
36402: }
36402: 
36402: static const CallInfo *
36402: fcallinfo(LIns *i)
36402: {
38567: #if NJ_SOFTFLOAT_SUPPORTED
36402:     if (nanojit::AvmCore::config.soft_float) {
36626:         if (!i->isop(LIR_qjoin))
36402:             return NULL;
36402:         i = i->oprnd1();
36402:         return i->isop(LIR_icall) ? i->callInfo() : NULL;
36402:     }
38567: #endif
36402:     return i->isop(LIR_fcall) ? i->callInfo() : NULL;
18773: }
18773: 
30860: static LIns*
36402: fcallarg(LIns* i, int n)
36402: {
38567: #if NJ_SOFTFLOAT_SUPPORTED
36402:     if (nanojit::AvmCore::config.soft_float) {
36402:         NanoAssert(i->isop(LIR_qjoin));
36402:         return i->oprnd1()->callArgN(n);
36402:     }
38567: #endif
36402:     NanoAssert(i->isop(LIR_fcall));
36402:     return i->callArgN(n);
36402: }
36402: 
36402: static LIns*
36402: foprnd1(LIns* i)
36402: {
38567: #if NJ_SOFTFLOAT_SUPPORTED
36402:     if (nanojit::AvmCore::config.soft_float)
36402:         return fcallarg(i, 0);
38567: #endif
18773:     return i->oprnd1();
18773: }
18773: 
30860: static LIns*
36402: foprnd2(LIns* i)
36402: {
38567: #if NJ_SOFTFLOAT_SUPPORTED
36402:     if (nanojit::AvmCore::config.soft_float)
36402:         return fcallarg(i, 1);
38567: #endif
36402:     return i->oprnd2();
36402: }
36402: 
36402: static LIns*
30860: demote(LirWriter *out, LIns* i)
17451: {
17451:     if (i->isCall())
32699:         return i->callArgN(0);
36402:     if (isfop(i, LIR_i2f) || isfop(i, LIR_u2f))
36402:         return foprnd1(i);
17997:     if (i->isconst())
17997:         return i;
32640:     JS_ASSERT(i->isconstf());
28182:     double cf = i->imm64f();
17451:     int32_t ci = cf > 0x7fffffff ? uint32_t(cf) : int32_t(cf);
17451:     return out->insImm(ci);
17451: }
17451: 
30860: static bool
30860: isPromoteInt(LIns* i)
17451: {
36402:     if (isfop(i, LIR_i2f) || i->isconst())
26393:         return true;
32640:     if (!i->isconstf())
26393:         return false;
28182:     jsdouble d = i->imm64f();
26393:     return d == jsdouble(jsint(d)) && !JSDOUBLE_IS_NEGZERO(d);
17451: }
17451: 
30860: static bool
30860: isPromoteUint(LIns* i)
17451: {
36402:     if (isfop(i, LIR_u2f) || i->isconst())
26393:         return true;
32640:     if (!i->isconstf())
26393:         return false;
28182:     jsdouble d = i->imm64f();
26393:     return d == jsdouble(jsuint(d)) && !JSDOUBLE_IS_NEGZERO(d);
17451: }
17451: 
30860: static bool
30860: isPromote(LIns* i)
17451: {
17758:     return isPromoteInt(i) || isPromoteUint(i);
17451: }
17451: 
29354: /*
29354:  * Determine whether this operand is guaranteed to not overflow the specified
29354:  * integer operation.
29354:  */
30860: static bool
30860: IsOverflowSafe(LOpcode op, LIns* i)
17796: {
17796:     LIns* c;
29354:     switch (op) {
29354:       case LIR_add:
29354:       case LIR_sub:
17796:           return (i->isop(LIR_and) && ((c = i->oprnd2())->isconst()) &&
28182:                   ((c->imm32() & 0xc0000000) == 0)) ||
17796:                  (i->isop(LIR_rsh) && ((c = i->oprnd2())->isconst()) &&
28182:                   ((c->imm32() > 0)));
29354:     default:
29354:         JS_ASSERT(op == LIR_mul);
29354:     }
29354:     return (i->isop(LIR_and) && ((c = i->oprnd2())->isconst()) &&
29354:             ((c->imm32() & 0xffff0000) == 0)) ||
29354:            (i->isop(LIR_ush) && ((c = i->oprnd2())->isconst()) &&
29354:             ((c->imm32() >= 16)));
17796: }
17796: 
17451: class FuncFilter: public LirWriter
17451: {
17451: public:
21799:     FuncFilter(LirWriter* out):
21799:         LirWriter(out)
17451:     {
17451:     }
17451: 
30860:     LIns* ins2(LOpcode v, LIns* s0, LIns* s1)
17451:     {
17451:         if (s0 == s1 && v == LIR_feq) {
17451:             if (isPromote(s0)) {
17451:                 // double(int) and double(uint) cannot be nan
17451:                 return insImm(1);
17451:             }
17451:             if (s0->isop(LIR_fmul) || s0->isop(LIR_fsub) || s0->isop(LIR_fadd)) {
30860:                 LIns* lhs = s0->oprnd1();
30860:                 LIns* rhs = s0->oprnd2();
17451:                 if (isPromote(lhs) && isPromote(rhs)) {
17451:                     // add/sub/mul promoted ints can't be nan
17451:                     return insImm(1);
17451:                 }
17451:             }
39901:         } else if (isFCmpOpcode(v)) {
17451:             if (isPromoteInt(s0) && isPromoteInt(s1)) {
17451:                 // demote fcmp to cmp
40428:                 v = f64cmp_to_i32cmp(v);
17797:                 return out->ins2(v, demote(out, s0), demote(out, s1));
17451:             } else if (isPromoteUint(s0) && isPromoteUint(s1)) {
17451:                 // uint compare
40428:                 v = f64cmp_to_u32cmp(v);
17797:                 return out->ins2(v, demote(out, s0), demote(out, s1));
17451:             }
17451:         }
17797:         return out->ins2(v, s0, s1);
17451:     }
17451: };
17451: 
30248: /*
30860:  * Visit the values in the given JSStackFrame that the tracer cares about. This
30860:  * visitor function is (implicitly) the primary definition of the native stack
30860:  * area layout. There are a few other independent pieces of code that must be
30860:  * maintained to assume the same layout. They are marked like this:
30248:  *
30248:  *   Duplicate native stack layout computation: see VisitFrameSlots header comment.
30248:  */
29880: template <typename Visitor>
30860: static JS_REQUIRES_STACK bool
29882: VisitFrameSlots(Visitor &visitor, unsigned depth, JSStackFrame *fp,
29882:                 JSStackFrame *up)
29882: {
29882:     if (depth > 0 && !VisitFrameSlots(visitor, depth-1, fp->down, fp))
29880:         return false;
29880: 
31939:     if (fp->argv) {
29880:         if (depth == 0) {
29880:             visitor.setStackSlotKind("args");
29880:             if (!visitor.visitStackSlots(&fp->argv[-2], argSlots(fp) + 2, fp))
29880:                 return false;
29880:         }
30248:         visitor.setStackSlotKind("arguments");
30248:         if (!visitor.visitStackSlots(&fp->argsobj, 1, fp))
30248:             return false;
37694:         // We want to import and track |JSObject *scopeChain|, but the tracker
37694:         // requires type |jsval|. But the bits are the same, so we can import
37694:         // it with a cast and the (identity function) unboxing will be OK.
37694:         visitor.setStackSlotKind("scopeChain");
39911:         if (!visitor.visitStackSlots(&fp->scopeChainVal, 1, fp))
37694:             return false;
29880:         visitor.setStackSlotKind("var");
29880:         if (!visitor.visitStackSlots(fp->slots, fp->script->nfixed, fp))
29880:             return false;
29880:     }
29880:     visitor.setStackSlotKind("stack");
29880:     JS_ASSERT(fp->regs->sp >= StackBase(fp));
29880:     if (!visitor.visitStackSlots(StackBase(fp),
29880:                                  size_t(fp->regs->sp - StackBase(fp)),
29882:                                  fp)) {
29880:         return false;
29882:     }
29880:     if (up) {
29880:         int missing = up->fun->nargs - up->argc;
29880:         if (missing > 0) {
29880:             visitor.setStackSlotKind("missing");
29880:             if (!visitor.visitStackSlots(fp->regs->sp, size_t(missing), fp))
29880:                 return false;
29880:         }
29880:     }
29880:     return true;
29880: }
29880: 
37694: // Number of native frame slots used for 'special' values between args and vars.
37694: // Currently the two values are |arguments| (args object) and |scopeChain|.
37694: const int SPECIAL_FRAME_SLOTS = 2;
37694: 
29880: template <typename Visitor>
30860: static JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29882: VisitStackSlots(Visitor &visitor, JSContext *cx, unsigned callDepth)
29882: {
29882:     return VisitFrameSlots(visitor, callDepth, cx->fp, NULL);
29880: }
29880: 
29880: template <typename Visitor>
30860: static JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29882: VisitGlobalSlots(Visitor &visitor, JSContext *cx, JSObject *globalObj,
29882:                  unsigned ngslots, uint16 *gslots)
29882: {
29880:     for (unsigned n = 0; n < ngslots; ++n) {
29880:         unsigned slot = gslots[n];
40410:         visitor.visitGlobalSlot(&globalObj->getSlotRef(slot), n, slot);
29880:     }
29880: }
29880: 
35083: template <typename Visitor>
35083: static JS_REQUIRES_STACK JS_ALWAYS_INLINE void
36361: VisitGlobalSlots(Visitor &visitor, JSContext *cx, TreeFragment *f)
36361: {
36361:     JSObject* globalObj = f->globalObj();
36361:     SlotList& gslots = *f->globalSlots;
35083:     VisitGlobalSlots(visitor, cx, globalObj, gslots.length(), gslots.data());
35083: }
35083: 
29880: class AdjustCallerTypeVisitor;
29880: 
29880: template <typename Visitor>
30860: static JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29882: VisitGlobalSlots(Visitor &visitor, JSContext *cx, SlotList &gslots)
29882: {
40424:     VisitGlobalSlots(visitor, cx, cx->fp->scopeChain->getGlobal(),
29880:                      gslots.length(), gslots.data());
29880: }
29880: 
29880: 
29880: template <typename Visitor>
30860: static JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29882: VisitSlots(Visitor& visitor, JSContext* cx, JSObject* globalObj,
29882:            unsigned callDepth, unsigned ngslots, uint16* gslots)
29882: {
29882:     if (VisitStackSlots(visitor, cx, callDepth))
29882:         VisitGlobalSlots(visitor, cx, globalObj, ngslots, gslots);
29880: }
29880: 
29880: template <typename Visitor>
30860: static JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29882: VisitSlots(Visitor& visitor, JSContext* cx, unsigned callDepth,
29882:            unsigned ngslots, uint16* gslots)
29882: {
40424:     VisitSlots(visitor, cx, cx->fp->scopeChain->getGlobal(),
29880:                callDepth, ngslots, gslots);
29880: }
29880: 
29880: template <typename Visitor>
30860: static JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29882: VisitSlots(Visitor &visitor, JSContext *cx, JSObject *globalObj,
29882:            unsigned callDepth, const SlotList& slots)
29882: {
29882:     VisitSlots(visitor, cx, globalObj, callDepth, slots.length(),
29880:                slots.data());
29880: }
29880: 
29880: template <typename Visitor>
30860: static JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29882: VisitSlots(Visitor &visitor, JSContext *cx, unsigned callDepth,
29882:            const SlotList& slots)
29882: {
40424:     VisitSlots(visitor, cx, cx->fp->scopeChain->getGlobal(),
29880:                callDepth, slots.length(), slots.data());
29880: }
29880: 
29880: 
29880: class SlotVisitorBase {
33564: #if defined JS_JIT_SPEW
29880: protected:
29880:     char const *mStackSlotKind;
29880: public:
29882:     SlotVisitorBase() : mStackSlotKind(NULL) {}
29882:     JS_ALWAYS_INLINE const char *stackSlotKind() { return mStackSlotKind; }
29880:     JS_ALWAYS_INLINE void setStackSlotKind(char const *k) {
29880:         mStackSlotKind = k;
29880:     }
29882: #else
29882: public:
29882:     JS_ALWAYS_INLINE const char *stackSlotKind() { return NULL; }
29882:     JS_ALWAYS_INLINE void setStackSlotKind(char const *k) {}
29880: #endif
29880: };
29880: 
29882: struct CountSlotsVisitor : public SlotVisitorBase
29882: {
29880:     unsigned mCount;
29880:     bool mDone;
29880:     jsval* mStop;
29880: public:
29880:     JS_ALWAYS_INLINE CountSlotsVisitor(jsval* stop = NULL) :
29880:         mCount(0),
29880:         mDone(false),
29880:         mStop(stop)
29880:     {}
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp) {
29880:         if (mDone)
29880:             return false;
29880:         if (mStop && size_t(mStop - vp) < count) {
29880:             mCount += size_t(mStop - vp);
29880:             mDone = true;
29880:             return false;
29880:         }
29880:         mCount += count;
29880:         return true;
29880:     }
29880: 
29880:     JS_ALWAYS_INLINE unsigned count() {
29880:         return mCount;
29880:     }
29880: 
29880:     JS_ALWAYS_INLINE bool stopped() {
29880:         return mDone;
29880:     }
29880: };
17820: 
30860: /*
30860:  * Calculate the total number of native frame slots we need from this frame all
30860:  * the way back to the entry frame, including the current stack usage.
30860:  */
22652: JS_REQUIRES_STACK unsigned
30860: NativeStackSlots(JSContext *cx, unsigned callDepth)
18193: {
18193:     JSStackFrame* fp = cx->fp;
18144:     unsigned slots = 0;
29880:     unsigned depth = callDepth;
18144:     for (;;) {
30860:         /*
30860:          * Duplicate native stack layout computation: see VisitFrameSlots
30860:          * header comment.
30860:          */
18144:         unsigned operands = fp->regs->sp - StackBase(fp);
18144:         slots += operands;
31939:         if (fp->argv)
37694:             slots += fp->script->nfixed + SPECIAL_FRAME_SLOTS;
29880:         if (depth-- == 0) {
31939:             if (fp->argv)
28244:                 slots += 2/*callee,this*/ + argSlots(fp);
29880: #ifdef DEBUG
29880:             CountSlotsVisitor visitor;
29882:             VisitStackSlots(visitor, cx, callDepth);
29880:             JS_ASSERT(visitor.count() == slots && !visitor.stopped());
18144: #endif
18144:             return slots;
18144:         }
18144:         JSStackFrame* fp2 = fp;
18144:         fp = fp->down;
18144:         int missing = fp2->fun->nargs - fp2->argc;
18144:         if (missing > 0)
18144:             slots += missing;
18144:     }
30860:     JS_NOT_REACHED("NativeStackSlots");
18144: }
18144: 
29882: class CaptureTypesVisitor : public SlotVisitorBase
29882: {
29880:     JSContext* mCx;
37741:     TraceType* mTypeMap;
37741:     TraceType* mPtr;
29880: 
29880: public:
37741:     JS_ALWAYS_INLINE CaptureTypesVisitor(JSContext* cx, TraceType* typeMap) :
29880:         mCx(cx),
29880:         mTypeMap(typeMap),
29880:         mPtr(typeMap)
29880:     {}
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29880:     visitGlobalSlot(jsval *vp, unsigned n, unsigned slot) {
37741:             TraceType type = getCoercedType(*vp);
29896:             if (type == TT_INT32 &&
29880:                 oracle.isGlobalSlotUndemotable(mCx, slot))
29896:                 type = TT_DOUBLE;
29896:             JS_ASSERT(type != TT_JSVAL);
29883:             debug_only_printf(LC_TMTracer,
29883:                               "capture type global%d: %d=%c\n",
29883:                               n, type, typeChar[type]);
29880:             *mPtr++ = type;
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, int count, JSStackFrame* fp) {
29880:         for (int i = 0; i < count; ++i) {
37741:             TraceType type = getCoercedType(vp[i]);
29896:             if (type == TT_INT32 &&
29880:                 oracle.isStackSlotUndemotable(mCx, length()))
29896:                 type = TT_DOUBLE;
29896:             JS_ASSERT(type != TT_JSVAL);
29883:             debug_only_printf(LC_TMTracer,
29883:                               "capture type %s%d: %d=%c\n",
29883:                               stackSlotKind(), i, type, typeChar[type]);
29880:             *mPtr++ = type;
29880:         }
29880:         return true;
29880:     }
29880: 
29880:     JS_ALWAYS_INLINE uintptr_t length() {
29880:         return mPtr - mTypeMap;
29880:     }
29880: };
29880: 
36401: void
36401: TypeMap::set(unsigned stackSlots, unsigned ngslots,
37741:              const TraceType* stackTypeMap, const TraceType* globalTypeMap)
36401: {
36401:     setLength(ngslots + stackSlots);
37741:     memcpy(data(), stackTypeMap, stackSlots * sizeof(TraceType));
37741:     memcpy(data() + stackSlots, globalTypeMap, ngslots * sizeof(TraceType));
36401: }
36401: 
24246: /*
24246:  * Capture the type map for the selected slots of the global object and currently pending
24246:  * stack frames.
24246:  */
22652: JS_REQUIRES_STACK void
29880: TypeMap::captureTypes(JSContext* cx, JSObject* globalObj, SlotList& slots, unsigned callDepth)
29880: {
30860:     setLength(NativeStackSlots(cx, callDepth) + slots.length());
29880:     CaptureTypesVisitor visitor(cx, data());
29882:     VisitSlots(visitor, cx, globalObj, callDepth, slots);
29880:     JS_ASSERT(visitor.length() == length());
24246: }
24246: 
22652: JS_REQUIRES_STACK void
29880: TypeMap::captureMissingGlobalTypes(JSContext* cx, JSObject* globalObj, SlotList& slots, unsigned stackSlots)
24246: {
24246:     unsigned oldSlots = length() - stackSlots;
24246:     int diff = slots.length() - oldSlots;
24246:     JS_ASSERT(diff >= 0);
24246:     setLength(length() + diff);
29880:     CaptureTypesVisitor visitor(cx, data() + stackSlots + oldSlots);
29882:     VisitGlobalSlots(visitor, cx, globalObj, diff, slots.data() + oldSlots);
17986: }
17986: 
17986: /* Compare this type map to another one and see whether they match. */
17986: bool
18239: TypeMap::matches(TypeMap& other) const
18239: {
18239:     if (length() != other.length())
18239:         return false;
17987:     return !memcmp(data(), other.data(), length());
17985: }
17985: 
31495: void
37741: TypeMap::fromRaw(TraceType* other, unsigned numSlots)
31495: {
31495:     unsigned oldLength = length();
31495:     setLength(length() + numSlots);
31495:     for (unsigned i = 0; i < numSlots; i++)
31495:         get(oldLength + i) = other[i];
31495: }
31495: 
30860: /*
30860:  * Use the provided storage area to create a new type map that contains the
30860:  * partial type map with the rest of it filled up from the complete type
30860:  * map.
30860:  */
28956: static void
37741: MergeTypeMaps(TraceType** partial, unsigned* plength, TraceType* complete, unsigned clength, TraceType* mem)
28956: {
28956:     unsigned l = *plength;
28956:     JS_ASSERT(l < clength);
37741:     memcpy(mem, *partial, l * sizeof(TraceType));
37741:     memcpy(mem + l, complete + l, (clength - l) * sizeof(TraceType));
28956:     *partial = mem;
28956:     *plength = clength;
28956: }
28956: 
36397: /*
36397:  * Specializes a tree to any specifically missing globals, including any
36397:  * dependent trees.
36397:  */
36397: static JS_REQUIRES_STACK void
37741: SpecializeTreesToLateGlobals(JSContext* cx, TreeFragment* root, TraceType* globalTypeMap,
36397:                             unsigned numGlobalSlots)
36397: {
36397:     for (unsigned i = root->nGlobalTypes(); i < numGlobalSlots; i++)
36397:         root->typeMap.add(globalTypeMap[i]);
36397: 
36397:     JS_ASSERT(root->nGlobalTypes() == numGlobalSlots);
36397: 
36397:     for (unsigned i = 0; i < root->dependentTrees.length(); i++) {
36397:         TreeFragment* tree = root->dependentTrees[i];
36397:         if (tree->code() && tree->nGlobalTypes() < numGlobalSlots)
36397:             SpecializeTreesToLateGlobals(cx, tree, globalTypeMap, numGlobalSlots);
36397:     }
36397:     for (unsigned i = 0; i < root->linkedTrees.length(); i++) {
36397:         TreeFragment* tree = root->linkedTrees[i];
36397:         if (tree->code() && tree->nGlobalTypes() < numGlobalSlots)
36397:             SpecializeTreesToLateGlobals(cx, tree, globalTypeMap, numGlobalSlots);
36397:     }
36397: }
36397: 
25491: /* Specializes a tree to any missing globals, including any dependent trees. */
25509: static JS_REQUIRES_STACK void
36361: SpecializeTreesToMissingGlobals(JSContext* cx, JSObject* globalObj, TreeFragment* root)
36361: {
36361:     root->typeMap.captureMissingGlobalTypes(cx, globalObj, *root->globalSlots, root->nStackTypes);
36361:     JS_ASSERT(root->globalSlots->length() == root->typeMap.length() - root->nStackTypes);
25491: 
36397: 
36397:     SpecializeTreesToLateGlobals(cx, root, root->globalTypeMap(), root->nGlobalTypes());
30860: }
30860: 
36712: static void
35083: ResetJITImpl(JSContext* cx);
35083: 
35083: #ifdef MOZ_TRACEVIS
36712: static JS_INLINE void
35083: ResetJIT(JSContext* cx, TraceVisFlushReason r)
35083: {
37741:     LogTraceVisEvent(cx, S_RESET, r);
35083:     ResetJITImpl(cx);
35083: }
35083: #else
37741: # define ResetJIT(cx, reason) ResetJITImpl(cx)
35083: #endif
35083: 
36712: void
37741: FlushJITCache(JSContext *cx)
36712: {
36712:     ResetJIT(cx, FR_OOM);
36712: }
36712: 
18650: static void
35044: TrashTree(JSContext* cx, TreeFragment* f);
18650: 
34351: template <class T>
34351: static T&
34351: InitConst(const T &t)
34351: {
34351:     return const_cast<T &>(t);
34351: }
34351: 
22652: JS_REQUIRES_STACK
35044: TraceRecorder::TraceRecorder(JSContext* cx, VMSideExit* anchor, VMFragment* fragment,
37741:                              unsigned stackSlots, unsigned ngslots, TraceType* typeMap,
33741:                              VMSideExit* innermost, jsbytecode* outer, uint32 outerArgc,
34351:                              RecordReason recordReason)
34351:   : cx(cx),
34351:     traceMonitor(&JS_TRACE_MONITOR(cx)),
34351:     fragment(fragment),
36361:     tree(fragment->root),
34351:     recordReason(recordReason),
36361:     globalObj(tree->globalObj),
34351:     outer(outer),
34351:     outerArgc(outerArgc),
34351:     lexicalBlock(cx->fp->blockChain),
34351:     anchor(anchor),
34351:     lir(NULL),
34351:     cx_ins(NULL),
34351:     eos_ins(NULL),
34351:     eor_ins(NULL),
34351:     loopLabel(NULL),
36401:     importTypeMap(&tempAlloc()),
36377:     lirbuf(new (tempAlloc()) LirBuffer(tempAlloc())),
34351:     mark(*traceMonitor->traceAlloc),
36361:     numSideExitsBefore(tree->sideExits.length()),
34351:     tracker(),
34351:     nativeFrameTracker(),
34351:     global_dslots(NULL),
34351:     callDepth(anchor ? anchor->calldepth : 0),
34351:     atoms(FrameAtomBase(cx, cx->fp)),
34351:     cfgMerges(&tempAlloc()),
34351:     trashSelf(false),
34351:     whichTreesToTrash(&tempAlloc()),
38568:     guardedShapeTable(cx),
34351:     rval_ins(NULL),
34351:     native_rval_ins(NULL),
34351:     newobj_ins(NULL),
34351:     pendingSpecializedNative(NULL),
34351:     pendingUnboxSlot(NULL),
34351:     pendingGuardCondition(NULL),
34351:     pendingLoop(true),
34351:     generatedSpecializedNative(),
33930:     tempTypeMap(cx)
18211: {
40424:     JS_ASSERT(globalObj == cx->fp->scopeChain->getGlobal());
34351:     JS_ASSERT(cx->fp->regs->pc == (jsbytecode*)fragment->ip);
34351: 
36377:     fragment->lirbuf = lirbuf;
36377: #ifdef DEBUG
40300:     lirbuf->printer = new (tempAlloc()) LInsPrinter(tempAlloc());
36377: #endif
36377: 
34351:     /*
34351:      * Reset the fragment state we care about in case we got a recycled
34351:      * fragment.  This includes resetting any profiling data we might have
34351:      * accumulated.
34351:      */
34351:     fragment->lastIns = NULL;
34351:     fragment->setCode(NULL);
34351:     fragment->lirbuf = lirbuf;
34351:     verbose_only( fragment->profCount = 0; )
34351:     verbose_only( fragment->nStaticExits = 0; )
34351:     verbose_only( fragment->nCodeBytes = 0; )
34351:     verbose_only( fragment->nExitBytes = 0; )
34351:     verbose_only( fragment->guardNumberer = 1; )
34351:     verbose_only( fragment->guardsForFrag = NULL; )
34351:     verbose_only( fragment->loopLabel = NULL; )
34351: 
34351:     /*
34351:      * Don't change fragment->profFragID, though.  Once the identity of the
34351:      * Fragment is set up (for profiling purposes), we can't change it.
34351:      */
32779: 
38568:     if (!guardedShapeTable.init())
38568:         abort();
33560: 
29883: #ifdef JS_JIT_SPEW
29883:     debug_only_print0(LC_TMMinimal, "\n");
32784:     debug_only_printf(LC_TMMinimal, "Recording starting from %s:%u@%u (FragID=%06u)\n",
36361:                       tree->treeFileName, tree->treeLineNumber, tree->treePCOffset,
34351:                       fragment->profFragID);
29883: 
29883:     debug_only_printf(LC_TMTracer, "globalObj=%p, shape=%d\n",
29883:                       (void*)this->globalObj, OBJ_SHAPE(this->globalObj));
31937:     debug_only_printf(LC_TMTreeVis, "TREEVIS RECORD FRAG=%p ANCHOR=%p\n", (void*)fragment,
31937:                       (void*)anchor);
29883: #endif
17414: 
34351:     nanojit::LirWriter*& lir = InitConst(this->lir);
37773:     lir = new (tempAlloc()) LirBufWriter(lirbuf, nanojit::AvmCore::config);
32746: #ifdef DEBUG
40353:     ValidateWriter* validate2;
40353:     lir = validate2 =
40353:         new (tempAlloc()) ValidateWriter(lir, lirbuf->printer, "end of writer pipeline");
32746: #endif
29883:     debug_only_stmt(
37741:         if (LogController.lcbits & LC_TMRecorder) {
40300:            lir = new (tempAlloc()) VerboseWriter(tempAlloc(), lir, lirbuf->printer,
37741:                                                &LogController);
29883:         }
29883:     )
35375:     // CseFilter must be downstream of SoftFloatFilter (see bug 527754 for why).
38583:     if (avmplus::AvmCore::config.cseopt)
35375:         lir = new (tempAlloc()) CseFilter(lir, tempAlloc());
38567: #if NJ_SOFTFLOAT_SUPPORTED
26545:     if (nanojit::AvmCore::config.soft_float)
34351:         lir = new (tempAlloc()) SoftFloatFilter(lir);
38567: #endif
34351:     lir = new (tempAlloc()) ExprFilter(lir);
34351:     lir = new (tempAlloc()) FuncFilter(lir);
32746: #ifdef DEBUG
40353:     ValidateWriter* validate1;
40353:     lir = validate1 =
40353:         new (tempAlloc()) ValidateWriter(lir, lirbuf->printer, "start of writer pipeline");
32746: #endif
20893:     lir->ins0(LIR_start);
17663: 
32600:     for (int i = 0; i < NumSavedRegs; ++i)
32600:         lir->insParam(i, 1);
32600: #ifdef DEBUG
32600:     for (int i = 0; i < NumSavedRegs; ++i)
32600:         addName(lirbuf->savedRegs[i], regNames[Assembler::savedRegs[i]]);
32600: #endif
32600: 
32643:     lirbuf->state = addName(lir->insParam(0, 0), "state");
32643: 
32600:     if (fragment == fragment->root)
34351:         InitConst(loopLabel) = lir->ins0(LIR_label);
32600: 
32784:     // if profiling, drop a label, so the assembler knows to put a
32784:     // frag-entry-counter increment at this point.  If there's a
32784:     // loopLabel, use that; else we'll have to make a dummy label
32784:     // especially for this purpose.
37741:     verbose_only( if (LogController.lcbits & LC_FragProfile) {
32784:         LIns* entryLabel = NULL;
32784:         if (fragment == fragment->root) {
32784:             entryLabel = loopLabel;
32784:         } else {
32784:             entryLabel = lir->ins0(LIR_label);
32784:         }
32784:         NanoAssert(entryLabel);
32784:         NanoAssert(!fragment->loopLabel);
32784:         fragment->loopLabel = entryLabel;
32784:     })
32784: 
40353:     lirbuf->sp =
40353:         addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, sp), ACC_OTHER), "sp");
40353:     lirbuf->rp =
40353:         addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, rp), ACC_OTHER), "rp");
40353:     InitConst(cx_ins) =
40353:         addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, cx), ACC_OTHER), "cx");
40353:     InitConst(eos_ins) =
40353:         addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, eos), ACC_OTHER), "eos");
40353:     InitConst(eor_ins) =
40353:         addName(lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, eor), ACC_OTHER), "eor");
40353: 
40353: #ifdef DEBUG
40353:     // Need to set these up before any stack/rstack loads/stores occur.
40353:     validate1->setSp(lirbuf->sp);
40353:     validate2->setSp(lirbuf->sp);
40353:     validate1->setRp(lirbuf->rp);
40353:     validate2->setRp(lirbuf->rp);
40353: #endif
23918: 
24246:     /* If we came from exit, we might not have enough global types. */
36361:     if (tree->globalSlots->length() > tree->nGlobalTypes())
36361:         SpecializeTreesToMissingGlobals(cx, globalObj, tree);
17334: 
17997:     /* read into registers all values on the stack and all globals we know so far */
36361:     import(tree, lirbuf->sp, stackSlots, ngslots, callDepth, typeMap);
18284: 
35097:     /* Finish handling RECURSIVE_SLURP_FAIL_EXIT in startRecorder. */
35097:     if (anchor && anchor->exitType == RECURSIVE_SLURP_FAIL_EXIT)
33564:         return;
33564: 
22615:     if (fragment == fragment->root) {
25087:         /*
25087:          * We poll the operation callback request flag. It is updated asynchronously whenever
25087:          * the callback is to be invoked.
25087:          */
40353:         // XXX: this load is volatile.  If bug 545406 (loop-invariant code
40353:         // hoisting) is implemented this fact will need to be made explicit.
40353:         LIns* x =
40353:             lir->insLoad(LIR_ld, cx_ins, offsetof(JSContext, operationCallbackFlag), ACC_LOAD_ANY);
25087:         guard(true, lir->ins_eq0(x), snapshot(TIMEOUT_EXIT));
23455:     }
22615: 
30860:     /*
30860:      * If we are attached to a tree call guard, make sure the guard the inner
30860:      * tree exited from is what we expect it to be.
30860:      */
34351:     if (anchor && anchor->exitType == NESTED_EXIT) {
18284:         LIns* nested_ins = addName(lir->insLoad(LIR_ldp, lirbuf->state,
40353:                                                 offsetof(InterpState, outermostTreeExitGuard),
40353:                                                 ACC_OTHER), "outermostTreeExitGuard");
33741:         guard(true, lir->ins2(LIR_peq, nested_ins, INS_CONSTPTR(innermost)), NESTED_EXIT);
18284:     }
17334: }
17334: 
32779: TraceRecorder::~TraceRecorder()
17334: {
35083:     /* Should already have been adjusted by callers before calling delete. */
35083:     JS_ASSERT(traceMonitor->recorder != this);
33171: 
22609:     if (trashSelf)
30860:         TrashTree(cx, fragment->root);
22609: 
22609:     for (unsigned int i = 0; i < whichTreesToTrash.length(); i++)
30860:         TrashTree(cx, whichTreesToTrash[i]);
33167: 
33167:     /* Purge the tempAlloc used during recording. */
34351:     tempAlloc().reset();
33560: 
33560:     forgetGuardedShapes();
17319: }
17319: 
35083: inline bool
37741: TraceMonitor::outOfMemory() const
35083: {
35083:     return dataAlloc->outOfMemory() ||
35083:            tempAlloc->outOfMemory() ||
35083:            traceAlloc->outOfMemory();
35083: }
35083: 
35083: /*
35083:  * This function destroys the recorder after a successful recording, possibly
35083:  * starting a suspended outer recorder.
35083:  */
35083: AbortableRecordingStatus
35083: TraceRecorder::finishSuccessfully()
35083: {
35083:     JS_ASSERT(traceMonitor->recorder == this);
35083:     JS_ASSERT(fragment->lastIns && fragment->code());
35083: 
35083:     AUDIT(traceCompleted);
35083:     mark.commit();
35083: 
35083:     /* Grab local copies of members needed after |delete this|. */
35083:     JSContext* localcx = cx;
37741:     TraceMonitor* localtm = traceMonitor;
35083: 
35083:     localtm->recorder = NULL;
35083:     delete this;
35083: 
35083:     /* Catch OOM that occurred during recording. */
37741:     if (localtm->outOfMemory() || OverfullJITCache(localtm)) {
35083:         ResetJIT(localcx, FR_OOM);
35083:         return ARECORD_ABORTED;
35083:     }
35083:     return ARECORD_COMPLETED;
35083: }
35083: 
35083: /* This function aborts a recorder and any pending outer recorders. */
35083: JS_REQUIRES_STACK AbortableRecordingStatus
35083: TraceRecorder::finishAbort(const char* reason)
35083: {
35083:     JS_ASSERT(traceMonitor->recorder == this);
35083:     JS_ASSERT(!fragment->code());
35083: 
35083:     AUDIT(recorderAborted);
35083: #ifdef DEBUG
35083:     debug_only_printf(LC_TMAbort,
35083:                       "Abort recording of tree %s:%d@%d at %s:%d@%d: %s.\n",
36361:                       tree->treeFileName,
36361:                       tree->treeLineNumber,
36361:                       tree->treePCOffset,
35083:                       cx->fp->script->filename,
35083:                       js_FramePCToLineNumber(cx, cx->fp),
35083:                       FramePCOffset(cx->fp),
35083:                       reason);
35083: #endif
35083:     Backoff(cx, (jsbytecode*) fragment->root->ip, fragment->root);
35083: 
35083:     /*
35083:      * If this is the primary trace and we didn't succeed compiling, trash the
36361:      * tree. Otherwise, remove the VMSideExits we added while recording, which
36361:      * are about to be invalid.
35085:      *
35085:      * BIG FAT WARNING: resetting the length is only a valid strategy as long as
35085:      * there may be only one recorder active for a single TreeInfo at a time.
35085:      * Otherwise, we may be throwing away another recorder's valid side exits.
35085:      */
35085:     if (fragment->root == fragment) {
35083:         TrashTree(cx, fragment->toTreeFragment());
35085:     } else {
36361:         JS_ASSERT(numSideExitsBefore <= fragment->root->sideExits.length());
36361:         fragment->root->sideExits.setLength(numSideExitsBefore);
35085:     }
35083: 
35083:     /* Grab local copies of members needed after |delete this|. */
35083:     JSContext* localcx = cx;
37741:     TraceMonitor* localtm = traceMonitor;
35083: 
35083:     localtm->recorder = NULL;
35083:     delete this;
37741:     if (localtm->outOfMemory() || OverfullJITCache(localtm))
35083:         ResetJIT(localcx, FR_OOM);
35083:     return ARECORD_ABORTED;
33159: }
33159: 
17722: /* Add debug information to a LIR instruction as we emit it. */
17722: inline LIns*
17722: TraceRecorder::addName(LIns* ins, const char* name)
17722: {
24305: #ifdef JS_JIT_SPEW
30860:     /*
30860:      * We'll only ask for verbose Nanojit when .lcbits > 0, so there's no point
30860:      * in adding names otherwise.
30860:      */
37741:     if (LogController.lcbits > 0)
40300:         lirbuf->printer->lirNameMap->addName(ins, name);
17722: #endif
17722:     return ins;
17722: }
17722: 
31843: inline LIns*
35099: TraceRecorder::insImmVal(jsval val)
35099: {
35099:     if (JSVAL_IS_TRACEABLE(val))
36361:         tree->gcthings.addUnique(val);
35099:     return lir->insImmWord(val);
35099: }
35099: 
35099: inline LIns*
31843: TraceRecorder::insImmObj(JSObject* obj)
31843: {
36361:     tree->gcthings.addUnique(OBJECT_TO_JSVAL(obj));
31843:     return lir->insImmPtr((void*)obj);
31843: }
31843: 
31843: inline LIns*
31843: TraceRecorder::insImmFun(JSFunction* fun)
31843: {
36361:     tree->gcthings.addUnique(OBJECT_TO_JSVAL(FUN_OBJECT(fun)));
31843:     return lir->insImmPtr((void*)fun);
31843: }
31843: 
31843: inline LIns*
31843: TraceRecorder::insImmStr(JSString* str)
31843: {
36361:     tree->gcthings.addUnique(STRING_TO_JSVAL(str));
31843:     return lir->insImmPtr((void*)str);
31843: }
31843: 
31843: inline LIns*
31843: TraceRecorder::insImmSprop(JSScopeProperty* sprop)
31843: {
36361:     tree->sprops.addUnique(sprop);
31843:     return lir->insImmPtr((void*)sprop);
31843: }
31843: 
32746: inline LIns*
32746: TraceRecorder::p2i(nanojit::LIns* ins)
32746: {
32746: #ifdef NANOJIT_64BIT
37774:     return lir->ins1(LIR_q2i, ins);
32746: #else
32746:     return ins;
32746: #endif
32746: }
32746: 
36401: ptrdiff_t
36401: TraceRecorder::nativeGlobalSlot(jsval* p) const
36401: {
36401:     JS_ASSERT(isGlobal(p));
36401:     if (size_t(p - globalObj->fslots) < JS_INITIAL_NSLOTS)
36401:         return ptrdiff_t(p - globalObj->fslots);
36401:     return ptrdiff_t((p - globalObj->dslots) + JS_INITIAL_NSLOTS);
36401: }
36401: 
30860: /* Determine the offset in the native global frame for a jsval we track. */
17811: ptrdiff_t
17815: TraceRecorder::nativeGlobalOffset(jsval* p) const
17815: {
36401:     return nativeGlobalSlot(p) * sizeof(double);
17815: }
17815: 
30860: /* Determine whether a value is a global stack slot. */
17893: bool
17893: TraceRecorder::isGlobal(jsval* p) const
17893: {
17893:     return ((size_t(p - globalObj->fslots) < JS_INITIAL_NSLOTS) ||
40410:             (size_t(p - globalObj->dslots) < (globalObj->numSlots() - JS_INITIAL_NSLOTS)));
17893: }
17893: 
30248: /*
30248:  * Return the offset in the native stack for the given jsval. More formally,
30248:  * |p| must be the address of a jsval that is represented in the native stack
30248:  * area. The return value is the offset, from InterpState::stackBase, in bytes,
30860:  * where the native representation of |*p| is stored. To get the offset
36361:  * relative to InterpState::sp, subtract TreeFragment::nativeStackBase.
30248:  */
22652: JS_REQUIRES_STACK ptrdiff_t
17815: TraceRecorder::nativeStackOffset(jsval* p) const
17346: {
29880:     CountSlotsVisitor visitor(p);
29882:     VisitStackSlots(visitor, cx, callDepth);
29880:     size_t offset = visitor.count() * sizeof(double);
30860: 
30860:     /*
30860:      * If it's not in a pending frame, it must be on the stack of the current
30860:      * frame above sp but below fp->slots + script->nslots.
17923:      */
29880:     if (!visitor.stopped()) {
17923:         JS_ASSERT(size_t(p - cx->fp->slots) < cx->fp->script->nslots);
29880:         offset += size_t(p - cx->fp->regs->sp) * sizeof(double);
29880:     }
29880:     return offset;
17346: }
36401: 
36401: JS_REQUIRES_STACK ptrdiff_t
36401: TraceRecorder::nativeStackSlot(jsval* p) const
36401: {
36401:     return nativeStackOffset(p) / sizeof(double);
36401: }
36401: 
35083: /*
35083:  * Return the offset, from InterpState:sp, for the given jsval. Shorthand for:
36361:  *  -TreeFragment::nativeStackBase + nativeStackOffset(p).
35083:  */
35083: inline JS_REQUIRES_STACK ptrdiff_t
35083: TraceRecorder::nativespOffset(jsval* p) const
35083: {
36361:     return -tree->nativeStackBase + nativeStackOffset(p);
35083: }
17346: 
30860: /* Track the maximum number of native frame slots we need during execution. */
35083: inline void
17815: TraceRecorder::trackNativeStackUse(unsigned slots)
17815: {
36361:     if (slots > tree->maxNativeStackSlots)
36361:         tree->maxNativeStackSlots = slots;
17397: }
17397: 
30860: /*
30860:  * Unbox a jsval into a slot. Slots are wide enough to hold double values
30860:  * directly (instead of storing a pointer to them). We assert instead of
30860:  * type checking. The caller must ensure the types are compatible.
30860:  */
21433: static void
37741: ValueToNative(JSContext* cx, jsval v, TraceType type, double* slot)
29896: {
29896:     uint8_t tag = JSVAL_TAG(v);
18296:     switch (type) {
29896:       case TT_OBJECT:
27542:         JS_ASSERT(tag == JSVAL_OBJECT);
40430:         JS_ASSERT(!JSVAL_IS_NULL(v) && !JSVAL_TO_OBJECT(v)->isFunction());
27542:         *(JSObject**)slot = JSVAL_TO_OBJECT(v);
29883:         debug_only_printf(LC_TMTracer,
29883:                           "object<%p:%s> ", (void*)JSVAL_TO_OBJECT(v),
27542:                           JSVAL_IS_NULL(v)
27542:                           ? "null"
38497:                           : JSVAL_TO_OBJECT(v)->getClass()->name);
27542:         return;
30860: 
29896:       case TT_INT32:
17482:         jsint i;
17482:         if (JSVAL_IS_INT(v))
17482:             *(jsint*)slot = JSVAL_TO_INT(v);
29896:         else if (tag == JSVAL_DOUBLE && JSDOUBLE_IS_INT(*JSVAL_TO_DOUBLE(v), i))
17469:             *(jsint*)slot = i;
21433:         else
21433:             JS_ASSERT(JSVAL_IS_INT(v));
29883:         debug_only_printf(LC_TMTracer, "int<%d> ", *(jsint*)slot);
21433:         return;
30860: 
29896:       case TT_DOUBLE:
17482:         jsdouble d;
17482:         if (JSVAL_IS_INT(v))
17482:             d = JSVAL_TO_INT(v);
21433:         else
17482:             d = *JSVAL_TO_DOUBLE(v);
21433:         JS_ASSERT(JSVAL_IS_INT(v) || JSVAL_IS_DOUBLE(v));
17482:         *(jsdouble*)slot = d;
29883:         debug_only_printf(LC_TMTracer, "double<%g> ", d);
21433:         return;
30860: 
29896:       case TT_JSVAL:
29896:         JS_NOT_REACHED("found jsval type in an entry type map");
27541:         return;
30860: 
29896:       case TT_STRING:
27542:         JS_ASSERT(tag == JSVAL_STRING);
27542:         *(JSString**)slot = JSVAL_TO_STRING(v);
29883:         debug_only_printf(LC_TMTracer, "string<%p> ", (void*)(*(JSString**)slot));
27542:         return;
30860: 
29896:       case TT_NULL:
27542:         JS_ASSERT(tag == JSVAL_OBJECT);
27542:         *(JSObject**)slot = NULL;
29883:         debug_only_print0(LC_TMTracer, "null ");
27542:         return;
30860: 
40307:       case TT_SPECIAL:
31521:         JS_ASSERT(tag == JSVAL_SPECIAL);
31521:         *(JSBool*)slot = JSVAL_TO_SPECIAL(v);
40307:         debug_only_printf(LC_TMTracer, "special<%d> ", *(JSBool*)slot);
40307:         return;
40307: 
40307:       case TT_VOID:
40307:         JS_ASSERT(JSVAL_IS_VOID(v));
40307:         *(JSBool*)slot = JSVAL_TO_SPECIAL(JSVAL_VOID);
40307:         debug_only_print0(LC_TMTracer, "undefined ");
21433:         return;
30860: 
29896:       case TT_FUNCTION: {
27541:         JS_ASSERT(tag == JSVAL_OBJECT);
27541:         JSObject* obj = JSVAL_TO_OBJECT(v);
27541:         *(JSObject**)slot = obj;
27541: #ifdef DEBUG
27541:         JSFunction* fun = GET_FUNCTION_PRIVATE(cx, obj);
29883:         debug_only_printf(LC_TMTracer,
29883:                           "function<%p:%s> ", (void*) obj,
27541:                           fun->atom
27541:                           ? JS_GetStringBytes(ATOM_TO_STRING(fun->atom))
29883:                           : "unnamed");
27541: #endif
27541:         return;
27541:       }
36401:       default:
27542:         JS_NOT_REACHED("unexpected type");
36401:         break;
36401:     }
18296: }
17360: 
31843: void
37741: TraceMonitor::flush()
31843: {
35083:     /* flush should only be called after all recorders have been aborted. */
35083:     JS_ASSERT(!recorder);
33108:     AUDIT(cacheFlushed);
33108: 
32784:     // recover profiling data from expiring Fragments
32784:     verbose_only(
32784:         for (size_t i = 0; i < FRAGMENT_TABLE_SIZE; ++i) {
35044:             for (TreeFragment *f = vmfragments[i]; f; f = f->next) {
32784:                 JS_ASSERT(f->root == f);
35044:                 for (TreeFragment *p = f; p; p = p->peer)
37741:                     FragProfiling_FragFinalizer(p, this);
32784:             }
32784:         }
32784:     )
32784: 
32784:     verbose_only(
32784:         for (Seq<Fragment*>* f = branches; f; f = f->tail)
37741:             FragProfiling_FragFinalizer(f->head, this);
32784:     )
32784: 
33563:     frameCache->reset();
33159:     dataAlloc->reset();
33545:     traceAlloc->reset();
32768:     codeAlloc->reset();
35047:     tempAlloc->reset();
35047:     reTempAlloc->reset();
31920: 
33159:     Allocator& alloc = *dataAlloc;
31920: 
31843:     for (size_t i = 0; i < MONITOR_N_GLOBAL_STATES; ++i) {
31843:         globalStates[i].globalShape = -1;
33159:         globalStates[i].globalSlots = new (alloc) SlotList(&alloc);
31920:     }
31920: 
38583:     assembler = new (alloc) Assembler(*codeAlloc, alloc, alloc, core, &LogController, avmplus::AvmCore::config);
32784:     verbose_only( branches = NULL; )
31843: 
40229:     PodArrayZero(vmfragments);
32767:     reFragments = new (alloc) REHashMap(alloc);
32767: 
31843:     needFlush = JS_FALSE;
31843: }
31843: 
33595: static inline void
36361: MarkTree(JSTracer* trc, TreeFragment *f)
36361: {
36361:     jsval* vp = f->gcthings.data();
36361:     unsigned len = f->gcthings.length();
31843:     while (len--) {
31843:         jsval v = *vp++;
31843:         JS_SET_TRACING_NAME(trc, "jitgcthing");
38595:         js_CallGCMarker(trc, JSVAL_TO_TRACEABLE(v), JSVAL_TRACE_KIND(v));
31843:     }
36361:     JSScopeProperty** spropp = f->sprops.data();
36361:     len = f->sprops.length();
31843:     while (len--) {
31843:         JSScopeProperty* sprop = *spropp++;
31843:         sprop->trace(trc);
31843:     }
31843: }
33595: 
33595: void
37741: TraceMonitor::mark(JSTracer* trc)
33595: {
33595:     if (!trc->context->runtime->gcFlushCodeCaches) {
33595:         for (size_t i = 0; i < FRAGMENT_TABLE_SIZE; ++i) {
35044:             TreeFragment* f = vmfragments[i];
33595:             while (f) {
36361:                 if (f->code())
36361:                     MarkTree(trc, f);
35044:                 TreeFragment* peer = f->peer;
33936:                 while (peer) {
36361:                     if (peer->code())
36361:                         MarkTree(trc, peer);
35044:                     peer = peer->peer;
33936:                 }
31843:                 f = f->next;
31843:             }
31843:         }
33595:         if (recorder)
36361:             MarkTree(trc, recorder->getTree());
32777:     }
31843: }
31843: 
30860: /*
30860:  * Box a value from the native stack back into the jsval format. Integers that
30860:  * are too large to fit into a jsval are automatically boxed into
30860:  * heap-allocated doubles.
30860:  */
35078: bool
37741: NativeToValue(JSContext* cx, jsval& v, TraceType type, double* slot)
35078: {
39928:     JSBool ok;
17483:     jsint i;
17469:     jsdouble d;
17494:     switch (type) {
29896:       case TT_OBJECT:
27542:         v = OBJECT_TO_JSVAL(*(JSObject**)slot);
27542:         JS_ASSERT(v != JSVAL_ERROR_COOKIE); /* don't leak JSVAL_ERROR_COOKIE */
29883:         debug_only_printf(LC_TMTracer,
29883:                           "object<%p:%s> ", (void*)JSVAL_TO_OBJECT(v),
27542:                           JSVAL_IS_NULL(v)
27542:                           ? "null"
38497:                           : JSVAL_TO_OBJECT(v)->getClass()->name);
17393:         break;
30860: 
29896:       case TT_INT32:
17483:         i = *(jsint*)slot;
29883:         debug_only_printf(LC_TMTracer, "int<%d> ", i);
17483:       store_int:
17469:         if (INT_FITS_IN_JSVAL(i)) {
17492:             v = INT_TO_JSVAL(i);
17393:             break;
17469:         }
17469:         d = (jsdouble)i;
17483:         goto store_double;
29896:       case TT_DOUBLE:
17469:         d = *slot;
29883:         debug_only_printf(LC_TMTracer, "double<%g> ", d);
17483:         if (JSDOUBLE_IS_INT(d, i))
17483:             goto store_int;
34315:       store_double:
35078:         ok = js_NewDoubleInRootedValue(cx, d, &v);
35078:         if (!ok) {
35078:             js_ReportOutOfMemory(cx);
35078:             return false;
35078:         }
35078:         return true;
30860: 
29896:       case TT_JSVAL:
27542:         v = *(jsval*)slot;
27542:         JS_ASSERT(v != JSVAL_ERROR_COOKIE); /* don't leak JSVAL_ERROR_COOKIE */
29883:         debug_only_printf(LC_TMTracer, "box<%p> ", (void*)v);
27542:         break;
30860: 
29896:       case TT_STRING:
17492:         v = STRING_TO_JSVAL(*(JSString**)slot);
29883:         debug_only_printf(LC_TMTracer, "string<%p> ", (void*)(*(JSString**)slot));
17393:         break;
30860: 
29896:       case TT_NULL:
23075:         JS_ASSERT(*(JSObject**)slot == NULL);
23075:         v = JSVAL_NULL;
29883:         debug_only_printf(LC_TMTracer, "null<%p> ", (void*)(*(JSObject**)slot));
23075:         break;
30860: 
40307:       case TT_SPECIAL:
31521:         v = SPECIAL_TO_JSVAL(*(JSBool*)slot);
40307:         debug_only_printf(LC_TMTracer, "special<%d> ", *(JSBool*)slot);
40307:         break;
40307: 
40307:       case TT_VOID:
40307:         v = JSVAL_VOID;
40307:         debug_only_print0(LC_TMTracer, "undefined ");
27542:         break;
30860: 
29896:       case TT_FUNCTION: {
40430:         JS_ASSERT((*(JSObject**)slot)->isFunction());
27541:         v = OBJECT_TO_JSVAL(*(JSObject**)slot);
27541: #ifdef DEBUG
27541:         JSFunction* fun = GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(v));
29883:         debug_only_printf(LC_TMTracer,
29883:                           "function<%p:%s> ", (void*)JSVAL_TO_OBJECT(v),
27541:                           fun->atom
27541:                           ? JS_GetStringBytes(ATOM_TO_STRING(fun->atom))
29883:                           : "unnamed");
27541: #endif
27541:         break;
27541:       }
36401:       default:
36401:         JS_NOT_REACHED("unexpected type");
36401:         break;
17393:     }
32709:     return true;
32709: }
32709: 
29882: class BuildNativeFrameVisitor : public SlotVisitorBase
29882: {
29880:     JSContext *mCx;
37741:     TraceType *mTypeMap;
29880:     double *mGlobal;
29880:     double *mStack;
29880: public:
29880:     BuildNativeFrameVisitor(JSContext *cx,
37741:                             TraceType *typemap,
29880:                             double *global,
29880:                             double *stack) :
29880:         mCx(cx),
29880:         mTypeMap(typemap),
29880:         mGlobal(global),
29880:         mStack(stack)
29880:     {}
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29880:     visitGlobalSlot(jsval *vp, unsigned n, unsigned slot) {
29883:         debug_only_printf(LC_TMTracer, "global%d: ", n);
29880:         ValueToNative(mCx, *vp, *mTypeMap++, &mGlobal[slot]);
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, int count, JSStackFrame* fp) {
29880:         for (int i = 0; i < count; ++i) {
29883:             debug_only_printf(LC_TMTracer, "%s%d: ", stackSlotKind(), i);
29880:             ValueToNative(mCx, *vp++, *mTypeMap++, mStack++);
29880:         }
29880:         return true;
29880:     }
29880: };
29880: 
22652: static JS_REQUIRES_STACK void
29880: BuildNativeFrame(JSContext *cx, JSObject *globalObj, unsigned callDepth,
29880:                  unsigned ngslots, uint16 *gslots,
37741:                  TraceType *typeMap, double *global, double *stack)
29880: {
29880:     BuildNativeFrameVisitor visitor(cx, typeMap, global, stack);
29882:     VisitSlots(visitor, cx, globalObj, callDepth, ngslots, gslots);
29883:     debug_only_print0(LC_TMTracer, "\n");
21433: }
21433: 
29882: class FlushNativeGlobalFrameVisitor : public SlotVisitorBase
29882: {
29880:     JSContext *mCx;
37741:     TraceType *mTypeMap;
29880:     double *mGlobal;
29880: public:
29880:     FlushNativeGlobalFrameVisitor(JSContext *cx,
37741:                                   TraceType *typeMap,
29880:                                   double *global) :
29880:         mCx(cx),
29880:         mTypeMap(typeMap),
29880:         mGlobal(global)
29880:     {}
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29880:     visitGlobalSlot(jsval *vp, unsigned n, unsigned slot) {
29883:         debug_only_printf(LC_TMTracer, "global%d=", n);
35078:         JS_ASSERT(JS_THREAD_DATA(mCx)->waiveGCQuota);
37741:         if (!NativeToValue(mCx, *vp, *mTypeMap++, &mGlobal[slot]))
35078:             OutOfMemoryAbort();
29880:     }
29880: };
29880: 
29882: class FlushNativeStackFrameVisitor : public SlotVisitorBase
29882: {
29880:     JSContext *mCx;
37741:     const TraceType *mInitTypeMap;
37741:     const TraceType *mTypeMap;
29880:     double *mStack;
29880:     jsval *mStop;
33564:     unsigned mIgnoreSlots;
29880: public:
29880:     FlushNativeStackFrameVisitor(JSContext *cx,
37741:                                  const TraceType *typeMap,
29880:                                  double *stack,
33564:                                  jsval *stop,
33564:                                  unsigned ignoreSlots) :
29880:         mCx(cx),
33564:         mInitTypeMap(typeMap),
29880:         mTypeMap(typeMap),
29880:         mStack(stack),
33564:         mStop(stop),
33564:         mIgnoreSlots(ignoreSlots)
29880:     {}
29880: 
37741:     const TraceType* getTypeMap()
29880:     {
29880:         return mTypeMap;
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp) {
35078:         JS_ASSERT(JS_THREAD_DATA(mCx)->waiveGCQuota);
29880:         for (size_t i = 0; i < count; ++i) {
29880:             if (vp == mStop)
29880:                 return false;
29883:             debug_only_printf(LC_TMTracer, "%s%u=", stackSlotKind(), unsigned(i));
35078:             if (unsigned(mTypeMap - mInitTypeMap) >= mIgnoreSlots) {
37741:                 if (!NativeToValue(mCx, *vp, *mTypeMap, mStack))
35078:                     OutOfMemoryAbort();
35078:             }
33564:             vp++;
33564:             mTypeMap++;
33564:             mStack++;
29880:         }
29880:         return true;
29880:     }
29880: };
29880: 
29880: /* Box the given native frame into a JS frame. This is infallible. */
22652: static JS_REQUIRES_STACK void
35083: FlushNativeGlobalFrame(JSContext *cx, JSObject *globalObj, double *global, unsigned ngslots,
37741:                        uint16 *gslots, TraceType *typemap)
29880: {
29880:     FlushNativeGlobalFrameVisitor visitor(cx, typemap, global);
29882:     VisitGlobalSlots(visitor, cx, globalObj, ngslots, gslots);
29883:     debug_only_print0(LC_TMTracer, "\n");
17857: }
17857: 
28268: /*
31924:  * Returns the number of values on the native stack, excluding the innermost
31924:  * frame. This walks all FrameInfos on the native frame stack and sums the
31924:  * slot usage of each frame.
31924:  */
31924: static int32
31924: StackDepthFromCallStack(InterpState* state, uint32 callDepth)
31924: {
31924:     int32 nativeStackFramePos = 0;
31924: 
31924:     // Duplicate native stack layout computation: see VisitFrameSlots header comment.
31924:     for (FrameInfo** fip = state->callstackBase; fip < state->rp + callDepth; fip++)
31924:         nativeStackFramePos += (*fip)->callerHeight;
31924:     return nativeStackFramePos;
31924: }
31924: 
31924: /*
30660:  * Generic function to read upvars on trace from slots of active frames.
29021:  *     T   Traits type parameter. Must provide static functions:
29021:  *             interp_get(fp, slot)     Read the value out of an interpreter frame.
29021:  *             native_slot(argc, slot)  Return the position of the desired value in the on-trace
29021:  *                                      stack frame (with position 0 being callee).
29021:  *
30660:  *     upvarLevel  Static level of the function containing the upvar definition
29021:  *     slot        Identifies the value to get. The meaning is defined by the traits type.
29021:  *     callDepth   Call depth of current point relative to trace entry
29021:  */
29021: template<typename T>
37741: inline TraceType
30860: GetUpvarOnTrace(JSContext* cx, uint32 upvarLevel, int32 slot, uint32 callDepth, double* result)
29021: {
28268:     InterpState* state = cx->interpState;
28738:     FrameInfo** fip = state->rp + callDepth;
28738: 
28738:     /*
31924:      * First search the FrameInfo call stack for an entry containing our
31924:      * upvar, namely one with level == upvarLevel. The first FrameInfo is a
31924:      * transition from the entry frame to some callee. However, it is not
31924:      * known (from looking at the FrameInfo) whether the entry frame had a
31924:      * callee. Rather than special-case this or insert more logic into the
31924:      * loop, instead just stop before that FrameInfo (i.e. |> base| instead of
31924:      * |>= base|), and let the code after the loop handle it.
31924:      */
31924:     int32 stackOffset = StackDepthFromCallStack(state, callDepth);
31924:     while (--fip > state->callstackBase) {
28738:         FrameInfo* fi = *fip;
31924: 
31924:         /*
31924:          * The loop starts aligned to the top of the stack, so move down to the first meaningful
31924:          * callee. Then read the callee directly from the frame.
31924:          */
31924:         stackOffset -= fi->callerHeight;
31924:         JSObject* callee = *(JSObject**)(&state->stackBase[stackOffset]);
31924:         JSFunction* fun = GET_FUNCTION_PRIVATE(cx, callee);
28738:         uintN calleeLevel = fun->u.i.script->staticLevel;
28738:         if (calleeLevel == upvarLevel) {
28738:             /*
31924:              * Now find the upvar's value in the native stack. stackOffset is
31924:              * the offset of the start of the activation record corresponding
31924:              * to *fip in the native stack.
31924:              */
31924:             uint32 native_slot = T::native_slot(fi->callerArgc, slot);
31924:             *result = state->stackBase[stackOffset + native_slot];
29021:             return fi->get_typemap()[native_slot];
29021:         }
29021:     }
29021: 
29021:     // Next search the trace entry frame, which is not in the FrameInfo stack.
28911:     if (state->outermostTree->script->staticLevel == upvarLevel) {
36361:         uint32 argc = state->outermostTree->argc;
29021:         uint32 native_slot = T::native_slot(argc, slot);
29021:         *result = state->stackBase[native_slot];
29021:         return state->callstackBase[0]->get_typemap()[native_slot];
28738:     }
28738: 
28738:     /*
28738:      * If we did not find the upvar in the frames for the active traces,
28268:      * then we simply get the value from the interpreter state.
28268:      */
29021:     JS_ASSERT(upvarLevel < JS_DISPLAY_SIZE);
29021:     JSStackFrame* fp = cx->display[upvarLevel];
29021:     jsval v = T::interp_get(fp, slot);
37741:     TraceType type = getCoercedType(v);
28268:     ValueToNative(cx, v, type, result);
28268:     return type;
28268: }
28268: 
29021: // For this traits type, 'slot' is the argument index, which may be -2 for callee.
29021: struct UpvarArgTraits {
29021:     static jsval interp_get(JSStackFrame* fp, int32 slot) {
29021:         return fp->argv[slot];
29021:     }
29021: 
29021:     static uint32 native_slot(uint32 argc, int32 slot) {
29021:         return 2 /*callee,this*/ + slot;
29021:     }
29021: };
29021: 
29021: uint32 JS_FASTCALL
30860: GetUpvarArgOnTrace(JSContext* cx, uint32 upvarLevel, int32 slot, uint32 callDepth, double* result)
30860: {
30860:     return GetUpvarOnTrace<UpvarArgTraits>(cx, upvarLevel, slot, callDepth, result);
29021: }
29021: 
29021: // For this traits type, 'slot' is an index into the local slots array.
29021: struct UpvarVarTraits {
29021:     static jsval interp_get(JSStackFrame* fp, int32 slot) {
29021:         return fp->slots[slot];
29021:     }
29021: 
29021:     static uint32 native_slot(uint32 argc, int32 slot) {
37694:         return 4 /*callee,this,arguments,scopeChain*/ + argc + slot;
29021:     }
29021: };
29021: 
29021: uint32 JS_FASTCALL
30860: GetUpvarVarOnTrace(JSContext* cx, uint32 upvarLevel, int32 slot, uint32 callDepth, double* result)
30860: {
30860:     return GetUpvarOnTrace<UpvarVarTraits>(cx, upvarLevel, slot, callDepth, result);
30860: }
30860: 
30860: /*
30860:  * For this traits type, 'slot' is an index into the stack area (within slots,
30860:  * after nfixed) of a frame with no function. (On trace, the top-level frame is
30860:  * the only one that can have no function.)
29022:  */
29022: struct UpvarStackTraits {
29022:     static jsval interp_get(JSStackFrame* fp, int32 slot) {
29022:         return fp->slots[slot + fp->script->nfixed];
29022:     }
29022: 
29022:     static uint32 native_slot(uint32 argc, int32 slot) {
29022:         /*
30860:          * Locals are not imported by the tracer when the frame has no
30860:          * function, so we do not add fp->script->nfixed.
29022:          */
29022:         JS_ASSERT(argc == 0);
29022:         return slot;
29022:     }
29022: };
29022: 
29022: uint32 JS_FASTCALL
31924: GetUpvarStackOnTrace(JSContext* cx, uint32 upvarLevel, int32 slot, uint32 callDepth,
31924:                      double* result)
30860: {
30860:     return GetUpvarOnTrace<UpvarStackTraits>(cx, upvarLevel, slot, callDepth, result);
29022: }
29022: 
32593: // Parameters needed to access a value from a closure on trace.
32593: struct ClosureVarInfo
32593: {
32593:     uint32   slot;
35479: #ifdef DEBUG
32593:     uint32   callDepth;
35479: #endif
32593: };
32593: 
30660: /*
30660:  * Generic function to read upvars from Call objects of active heavyweight functions.
32593:  *     call       Callee Function object in which the upvar is accessed.
30660:  */
30647: template<typename T>
30860: inline uint32
32593: GetFromClosure(JSContext* cx, JSObject* call, const ClosureVarInfo* cv, double* result)
32593: {
30660:     JS_ASSERT(OBJ_GET_CLASS(cx, call) == &js_CallClass);
30647: 
30647:     InterpState* state = cx->interpState;
31924: 
31924: #ifdef DEBUG
37694:     FrameInfo** fip = state->rp + cv->callDepth;
33607:     int32 stackOffset = StackDepthFromCallStack(state, cv->callDepth);
31924:     while (--fip > state->callstackBase) {
30647:         FrameInfo* fi = *fip;
37694: 
37694:         /*
37694:          * The loop starts aligned to the top of the stack, so move down to the first meaningful
37694:          * callee. Then read the callee directly from the frame.
37694:          */
37694:         stackOffset -= fi->callerHeight;
31924:         JSObject* callee = *(JSObject**)(&state->stackBase[stackOffset]);
31924:         if (callee == call) {
37725:             // This is not reachable as long as the tracer guards on the identity of the callee's
37725:             // parent when making a call:
37725:             //
37725:             // - We can only reach this point if we execute JSOP_LAMBDA on trace, then call the
37725:             //   function created by the lambda, and then execute a JSOP_NAME on trace.
37725:             // - Each time we execute JSOP_LAMBDA we get a function with a different parent.
37725:             // - When we execute the call to the new function, we exit trace because the parent
37725:             //   is different.
30647:             JS_NOT_REACHED("JSOP_NAME variable found in outer trace");
30647:         }
31924:     }
31924: #endif
30647: 
30647:     /*
30647:      * Here we specifically want to check the call object of the trace entry frame.
30647:      */
32593:     uint32 slot = cv->slot;
30647:     VOUCH_DOES_NOT_REQUIRE_STACK();
30647:     if (cx->fp->callobj == call) {
30647:         slot = T::adj_slot(cx->fp, slot);
30647:         *result = state->stackBase[slot];
30647:         return state->callstackBase[0]->get_typemap()[slot];
30647:     }
30647: 
31452:     JSStackFrame* fp = (JSStackFrame*) call->getPrivate();
32593:     jsval v;
32593:     if (fp) {
32593:         v = T::slots(fp)[slot];
32593:     } else {
35479:         /*
35479:          * Get the value from the object. We know we have a Call object, and
35479:          * that our slot index is fine, so don't monkey around with calling the
35479:          * property getter (which just looks in the slot) or calling
35479:          * js_GetReservedSlot. Just get the slot directly. Note the static
35479:          * asserts in jsfun.cpp which make sure Call objects use dslots.
35479:          */
35479:         JS_ASSERT(slot < T::slot_count(call));
35479:         v = T::slots(call)[slot];
32593:     }
37741:     TraceType type = getCoercedType(v);
30647:     ValueToNative(cx, v, type, result);
30647:     return type;
30647: }
30647: 
30647: struct ArgClosureTraits
30647: {
35479:     // Adjust our slot to point to the correct slot on the native stack.
35476:     // See also UpvarArgTraits.
35475:     static inline uint32 adj_slot(JSStackFrame* fp, uint32 slot) { return 2 + slot; }
35475: 
37009:     // Generate the adj_slot computation in LIR.
37009:     static inline LIns* adj_slot_lir(LirWriter* lir, LIns* fp_ins, unsigned slot) {
37009:         return lir->insImm(2 + slot);
37009:     }
37009: 
35479:     // Get the right frame slots to use our slot index with.
35475:     // See also UpvarArgTraits.
30860:     static inline jsval* slots(JSStackFrame* fp) { return fp->argv; }
35479: 
35479:     // Get the right object slots to use our slot index with.
35479:     static inline jsval* slots(JSObject* obj) {
35479:         // We know Call objects use dslots.
35479:         return obj->dslots + slot_offset(obj);
35479:     }
35479:     // Get the offset of our object slots from the object's dslots pointer.
35479:     static inline uint32 slot_offset(JSObject* obj) {
35479:         return JSSLOT_START(&js_CallClass) +
35479:             CALL_CLASS_FIXED_RESERVED_SLOTS - JS_INITIAL_NSLOTS;
35479:     }
35479:     // Get the maximum slot index of this type that should be allowed
35479:     static inline uint16 slot_count(JSObject* obj) {
35479:         return js_GetCallObjectFunction(obj)->nargs;
35479:     }
30647: private:
30647:     ArgClosureTraits();
30647: };
30647: 
30647: uint32 JS_FASTCALL
32593: GetClosureArg(JSContext* cx, JSObject* callee, const ClosureVarInfo* cv, double* result)
32593: {
32593:     return GetFromClosure<ArgClosureTraits>(cx, callee, cv, result);
30647: }
30647: 
30647: struct VarClosureTraits
30647: {
35479:     // See documentation on ArgClosureTraits for what these functions
35479:     // should be doing.
35475:     // See also UpvarVarTraits.
37694:     static inline uint32 adj_slot(JSStackFrame* fp, uint32 slot) { return 4 + fp->argc + slot; }
35476: 
37009:     static inline LIns* adj_slot_lir(LirWriter* lir, LIns* fp_ins, unsigned slot) {
40353:         LIns *argc_ins = lir->insLoad(LIR_ld, fp_ins, offsetof(JSStackFrame, argc), ACC_OTHER);
37694:         return lir->ins2(LIR_add, lir->insImm(4 + slot), argc_ins);
37009:     }
37009: 
35476:     // See also UpvarVarTraits.
35476:     static inline jsval* slots(JSStackFrame* fp) { return fp->slots; }
35479:     static inline jsval* slots(JSObject* obj) {
35479:         // We know Call objects use dslots.
35479:         return obj->dslots + slot_offset(obj);
35479:     }
35479:     static inline uint32 slot_offset(JSObject* obj) {
35479:         return JSSLOT_START(&js_CallClass) +
35479:             CALL_CLASS_FIXED_RESERVED_SLOTS - JS_INITIAL_NSLOTS +
35479:             js_GetCallObjectFunction(obj)->nargs;
35479:     }
35479:     static inline uint16 slot_count(JSObject* obj) {
35479:         return js_GetCallObjectFunction(obj)->u.i.nvars;
35479:     }
30647: private:
30647:     VarClosureTraits();
30647: };
30647: 
30647: uint32 JS_FASTCALL
32593: GetClosureVar(JSContext* cx, JSObject* callee, const ClosureVarInfo* cv, double* result)
32593: {
32593:     return GetFromClosure<VarClosureTraits>(cx, callee, cv, result);
30647: }
30647: 
19076: /**
23446:  * Box the given native stack frame into the virtual machine stack. This
23446:  * is infallible.
19076:  *
19076:  * @param callDepth the distance between the entry frame into our trace and
19076:  *                  cx->fp when we make this call.  If this is not called as a
19076:  *                  result of a nested exit, callDepth is 0.
37741:  * @param mp an array of TraceType that indicate what the types of the things
29896:  *           on the stack are.
19076:  * @param np pointer to the native stack.  We want to copy values from here to
19076:  *           the JS stack as needed.
19076:  * @param stopFrame if non-null, this frame and everything above it should not
19076:  *                  be restored.
19076:  * @return the number of things we popped off of np.
19076:  */
22652: static JS_REQUIRES_STACK int
37741: FlushNativeStackFrame(JSContext* cx, unsigned callDepth, const TraceType* mp, double* np,
33564:                       JSStackFrame* stopFrame, unsigned ignoreSlots)
19076: {
19076:     jsval* stopAt = stopFrame ? &stopFrame->argv[-2] : NULL;
29880: 
17857:     /* Root all string and object references first (we don't need to call the GC for this). */
33564:     FlushNativeStackFrameVisitor visitor(cx, mp, np, stopAt, ignoreSlots);
29882:     VisitStackSlots(visitor, cx, callDepth);
29880: 
32774:     // Restore thisv from the now-restored argv[-1] in each pending frame.
19076:     // Keep in mind that we didn't restore frames at stopFrame and above!
19076:     // Scope to keep |fp| from leaking into the macros we're using.
19076:     {
19076:         unsigned n = callDepth+1; // +1 to make sure we restore the entry frame
19076:         JSStackFrame* fp = cx->fp;
19076:         if (stopFrame) {
19076:             for (; fp != stopFrame; fp = fp->down) {
19076:                 JS_ASSERT(n != 0);
19076:                 --n;
19076:             }
30860: 
19076:             // Skip over stopFrame itself.
19076:             JS_ASSERT(n != 0);
19076:             --n;
19076:             fp = fp->down;
19076:         }
19076:         for (; n != 0; fp = fp->down) {
19076:             --n;
31939:             if (fp->argv) {
40405:                 if (fp->argsobj && GetArgsPrivateNative(JSVAL_TO_OBJECT(fp->argsobj)))
31893:                     JSVAL_TO_OBJECT(fp->argsobj)->setPrivate(fp);
30248: 
19076:                 JS_ASSERT(JSVAL_IS_OBJECT(fp->argv[-1]));
40430:                 JS_ASSERT(fp->calleeObject()->isFunction());
31939:                 JS_ASSERT(GET_FUNCTION_PRIVATE(cx, fp->callee()) == fp->fun);
28691: 
37730:                 if (FUN_INTERPRETED(fp->fun) &&
37730:                     (fp->fun->flags & JSFUN_HEAVYWEIGHT)) {
37730:                     // Iff these fields are NULL, then |fp| was synthesized on trace exit, so
37730:                     // we need to update the frame fields.
37694:                     if (!fp->callobj)
37694:                         fp->callobj = fp->scopeChain;
37730: 
37730:                     // Iff scope chain's private is NULL, then |fp->scopeChain| was created
37730:                     // on trace for a call, so we set the private field now. (Call objects
37730:                     // that correspond to returned frames also have a NULL private, but such
37730:                     // a call object would not occur as the |scopeChain| member of a frame,
37730:                     // so we cannot be in that case here.)
37730:                     if (!fp->scopeChain->getPrivate())
37694:                         fp->scopeChain->setPrivate(fp);
28691:                 }
32774:                 fp->thisv = fp->argv[-1];
27470:                 if (fp->flags & JSFRAME_CONSTRUCTING) // constructors always compute 'this'
27470:                     fp->flags |= JSFRAME_COMPUTED_THIS;
19076:             }
19076:         }
19076:     }
29883:     debug_only_print0(LC_TMTracer, "\n");
29880:     return visitor.getTypeMap() - mp;
17361: }
17361: 
17363: /* Emit load instructions onto the trace that read the initial stack state. */
22652: JS_REQUIRES_STACK void
37741: TraceRecorder::import(LIns* base, ptrdiff_t offset, jsval* p, TraceType t,
18045:                       const char *prefix, uintN index, JSStackFrame *fp)
17319: {
17480:     LIns* ins;
40353:     AccSet accSet = base == lirbuf->sp ? ACC_STACK : ACC_OTHER;
29896:     if (t == TT_INT32) { /* demoted */
17482:         JS_ASSERT(isInt32(*p));
30860: 
30860:         /*
30860:          * Ok, we have a valid demotion attempt pending, so insert an integer
30860:          * read and promote it to double since all arithmetic operations expect
30860:          * to see doubles on entry. The first op to use this slot will emit a
30860:          * f2i cast which will cancel out the i2f we insert here.
30860:          */
40353:         ins = lir->insLoad(LIR_ld, base, offset, accSet);
17803:         ins = lir->ins1(LIR_i2f, ins);
17480:     } else {
29896:         JS_ASSERT_IF(t != TT_JSVAL, isNumber(*p) == (t == TT_DOUBLE));
29896:         if (t == TT_DOUBLE) {
40353:             ins = lir->insLoad(LIR_ldf, base, offset, accSet);
40307:         } else if (t == TT_SPECIAL) {
40353:             ins = lir->insLoad(LIR_ld, base, offset, accSet);
40307:         } else if (t == TT_VOID) {
40307:             ins = INS_VOID();
38981:         } else {
40353:             ins = lir->insLoad(LIR_ldp, base, offset, accSet);
18232:         }
17480:     }
24381:     checkForGlobalObjectReallocation();
17372:     tracker.set(p, ins);
26972: 
17372: #ifdef DEBUG
17737:     char name[64];
37694:     JS_ASSERT(strlen(prefix) < 11);
17925:     void* mark = NULL;
17925:     jsuword* localNames = NULL;
18011:     const char* funName = NULL;
17925:     if (*prefix == 'a' || *prefix == 'v') {
17925:         mark = JS_ARENA_MARK(&cx->tempPool);
28832:         if (fp->fun->hasLocalNames())
17925:             localNames = js_GetLocalNameArray(cx, fp->fun, &cx->tempPool);
18011:         funName = fp->fun->atom ? js_AtomToPrintableString(cx, fp->fun->atom) : "<anonymous>";
18011:     }
17737:     if (!strcmp(prefix, "argv")) {
18045:         if (index < fp->fun->nargs) {
17737:             JSAtom *atom = JS_LOCAL_NAME_TO_ATOM(localNames[index]);
18011:             JS_snprintf(name, sizeof name, "$%s.%s", funName, js_AtomToPrintableString(cx, atom));
18011:         } else {
18011:             JS_snprintf(name, sizeof name, "$%s.<arg%d>", funName, index);
18011:         }
17737:     } else if (!strcmp(prefix, "vars")) {
17925:         JSAtom *atom = JS_LOCAL_NAME_TO_ATOM(localNames[fp->fun->nargs + index]);
18011:         JS_snprintf(name, sizeof name, "$%s.%s", funName, js_AtomToPrintableString(cx, atom));
17737:     } else {
17379:         JS_snprintf(name, sizeof name, "$%s%d", prefix, index);
17737:     }
17925: 
17925:     if (mark)
17925:         JS_ARENA_RELEASE(&cx->tempPool, mark);
17721:     addName(ins, name);
17737: 
17587:     static const char* typestr[] = {
29896:         "object", "int", "double", "jsval", "string", "null", "boolean", "function"
17587:     };
29883:     debug_only_printf(LC_TMTracer, "import vp=%p name=%s type=%s flags=%d\n",
29883:                       (void*)p, name, typestr[t & 7], t >> 3);
17372: #endif
17317: }
17317: 
29882: class ImportBoxedStackSlotVisitor : public SlotVisitorBase
29882: {
29880:     TraceRecorder &mRecorder;
29880:     LIns *mBase;
29880:     ptrdiff_t mStackOffset;
37741:     TraceType *mTypemap;
29880:     JSStackFrame *mFp;
29880: public:
29880:     ImportBoxedStackSlotVisitor(TraceRecorder &recorder,
29880:                                 LIns *base,
29880:                                 ptrdiff_t stackOffset,
37741:                                 TraceType *typemap) :
29880:         mRecorder(recorder),
29880:         mBase(base),
29880:         mStackOffset(stackOffset),
29880:         mTypemap(typemap)
29880:     {}
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp) {
29880:         for (size_t i = 0; i < count; ++i) {
29896:             if (*mTypemap == TT_JSVAL) {
29896:                 mRecorder.import(mBase, mStackOffset, vp, TT_JSVAL,
29896:                                  "jsval", i, fp);
31902:                 LIns *vp_ins = mRecorder.unbox_jsval(*vp, mRecorder.get(vp),
29880:                                                      mRecorder.copy(mRecorder.anchor));
29880:                 mRecorder.set(vp, vp_ins);
29880:             }
29880:             vp++;
29880:             mTypemap++;
29880:             mStackOffset += sizeof(double);
29880:         }
29880:         return true;
29880:     }
29880: };
29880: 
22652: JS_REQUIRES_STACK void
36361: TraceRecorder::import(TreeFragment* tree, LIns* sp, unsigned stackSlots, unsigned ngslots,
37741:                       unsigned callDepth, TraceType* typeMap)
17997: {
30860:     /*
30860:      * If we get a partial list that doesn't have all the types (i.e. recording
30860:      * from a side exit that was recorded but we added more global slots
30860:      * later), merge the missing types from the entry type map. This is safe
30860:      * because at the loop edge we verify that we have compatible types for all
30860:      * globals (entry type and loop edge type match). While a different trace
30860:      * of the tree might have had a guard with a different type map for these
30860:      * slots we just filled in here (the guard we continue from didn't know
30860:      * about them), since we didn't take that particular guard the only way we
30860:      * could have ended up here is if that other trace had at its end a
30860:      * compatible type distribution with the entry map. Since that's exactly
30860:      * what we used to fill in the types our current side exit didn't provide,
30860:      * this is always safe to do.
30860:      */
28956: 
37741:     TraceType* globalTypeMap = typeMap + stackSlots;
36361:     unsigned length = tree->nGlobalTypes();
28956: 
28956:     /*
30860:      * This is potentially the typemap of the side exit and thus shorter than
30860:      * the tree's global type map.
28956:      */
28956:     if (ngslots < length) {
30860:         MergeTypeMaps(&globalTypeMap /* out param */, &ngslots /* out param */,
36361:                       tree->globalTypeMap(), length,
37741:                       (TraceType*)alloca(sizeof(TraceType) * length));
28956:     }
36361:     JS_ASSERT(ngslots == tree->nGlobalTypes());
29880: 
29880:     /*
30860:      * Check whether there are any values on the stack we have to unbox and do
30860:      * that first before we waste any time fetching the state from the stack.
29880:      */
33564:     if (!anchor || anchor->exitType != RECURSIVE_SLURP_FAIL_EXIT) {
36401:         ImportBoxedStackSlotVisitor boxedStackVisitor(*this, sp, -tree->nativeStackBase, typeMap);
29882:         VisitStackSlots(boxedStackVisitor, cx, callDepth);
33564:     }
29880: 
36401: 
36401:     /*
36401:      * Remember the import type map so we can lazily import later whatever
36401:      * we need.
36401:      */
36401:     importTypeMap.set(importStackSlots = stackSlots,
36401:                       importGlobalSlots = ngslots,
36401:                       typeMap, globalTypeMap);
17997: }
17997: 
25938: JS_REQUIRES_STACK bool
25938: TraceRecorder::isValidSlot(JSScope* scope, JSScopeProperty* sprop)
25938: {
25938:     uint32 setflags = (js_CodeSpec[*cx->fp->regs->pc].format & (JOF_SET | JOF_INCDEC | JOF_FOR));
25938: 
25938:     if (setflags) {
40265:         if (!sprop->hasDefaultSetter())
33542:             RETURN_VALUE("non-stub setter", false);
40265:         if (!sprop->writable())
33542:             RETURN_VALUE("writing to a read-only property", false);
25938:     }
30860: 
25938:     /* This check applies even when setflags == 0. */
40265:     if (setflags != JOF_SET && !sprop->hasDefaultGetter()) {
32658:         JS_ASSERT(!sprop->isMethod());
33542:         RETURN_VALUE("non-stub getter", false);
32658:     }
25938: 
25938:     if (!SPROP_HAS_VALID_SLOT(sprop, scope))
40265:         RETURN_VALUE("invalid-slot obj property", false);
25938: 
25938:     return true;
25938: }
25938: 
17894: /* Lazily import a global slot if we don't already have it in the tracker. */
36401: JS_REQUIRES_STACK void
36401: TraceRecorder::importGlobalSlot(unsigned slot)
36401: {
36401:     JS_ASSERT(slot == uint16(slot));
40410:     JS_ASSERT(globalObj->numSlots() <= MAX_GLOBAL_SLOTS);
40410: 
40410:     jsval* vp = &globalObj->getSlotRef(slot);
36401:     JS_ASSERT(!known(vp));
36401: 
36401:     /* Add the slot to the list of interned global slots. */
37741:     TraceType type;
39928:     int index = tree->globalSlots->offsetOf(uint16(slot));
36401:     if (index == -1) {
36401:         type = getCoercedType(*vp);
36401:         if (type == TT_INT32 && oracle.isGlobalSlotUndemotable(cx, slot))
36401:             type = TT_DOUBLE;
36401:         index = (int)tree->globalSlots->length();
39928:         tree->globalSlots->add(uint16(slot));
36401:         tree->typeMap.add(type);
36401:         SpecializeTreesToMissingGlobals(cx, globalObj, tree);
36401:         JS_ASSERT(tree->nGlobalTypes() == tree->globalSlots->length());
36401:     } else {
36401:         type = importTypeMap[importStackSlots + index];
36401:         JS_ASSERT(type != TT_IGNORE);
36401:     }
36401:     import(eos_ins, slot * sizeof(double), vp, type, "global", index, NULL);
36401: }
36401: 
36401: /* Lazily import a global slot if we don't already have it in the tracker. */
22652: JS_REQUIRES_STACK bool
17892: TraceRecorder::lazilyImportGlobalSlot(unsigned slot)
17891: {
18712:     if (slot != uint16(slot)) /* we use a table of 16-bit ints, bail out if that's not enough */
17891:         return false;
30860:     /*
30860:      * If the global object grows too large, alloca in ExecuteTree might fail,
30860:      * so abort tracing on global objects with unreasonably many slots.
27065:      */
40410:     if (globalObj->numSlots() > MAX_GLOBAL_SLOTS)
40410:         return false;
40410:     jsval* vp = &globalObj->getSlotRef(slot);
24381:     if (known(vp))
17891:         return true; /* we already have it */
36401:     importGlobalSlot(slot);
17891:     return true;
17891: }
17891: 
18197: /* Write back a value onto the stack or global frames. */
18197: LIns*
37741: TraceRecorder::writeBack(LIns* i, LIns* base, ptrdiff_t offset, bool shouldDemote)
18197: {
30860:     /*
30860:      * Sink all type casts targeting the stack into the side exit by simply storing the original
30860:      * (uncasted) value. Each guard generates the side exit map based on the types of the
30860:      * last stores to every stack location, so it's safe to not perform them on-trace.
30860:      */
37741:     if (shouldDemote && isPromoteInt(i))
37741:         i = demote(lir, i);
40353:     return lir->insStorei(i, base, offset, (base == lirbuf->sp) ? ACC_STACK : ACC_OTHER);
18197: }
18197: 
18197: /* Update the tracker, then issue a write back store. */
22652: JS_REQUIRES_STACK void
39913: TraceRecorder::set(jsval* p, LIns* i, bool demote)
18197: {
26018:     JS_ASSERT(i != NULL);
24381:     checkForGlobalObjectReallocation();
18197:     tracker.set(p, i);
30860: 
30860:     /*
30860:      * If we are writing to this location for the first time, calculate the
30860:      * offset into the native frame manually. Otherwise just look up the last
30860:      * load or store associated with the same source address (p) and use the
30860:      * same offset/base.
30860:      */
19068:     LIns* x = nativeFrameTracker.get(p);
19068:     if (!x) {
18197:         if (isGlobal(p))
34572:             x = writeBack(i, eos_ins, nativeGlobalOffset(p), demote);
18197:         else
35083:             x = writeBack(i, lirbuf->sp, nativespOffset(p), demote);
17962:         nativeFrameTracker.set(p, x);
17803:     } else {
38567: #if defined NANOJIT_64BIT
38567:         JS_ASSERT( x->isop(LIR_stqi) || x->isop(LIR_sti) || x->isop(LIR_stfi));
38567: #else
38567:         JS_ASSERT( x->isop(LIR_sti) || x->isop(LIR_stfi));
38567: #endif
34324: 
34324:         int disp;
34324:         LIns *base = x->oprnd2();
34324: #ifdef NANOJIT_ARM
34324:         if (base->isop(LIR_piadd)) {
34324:             disp = base->oprnd2()->imm32();
34324:             base = base->oprnd1();
34324:         } else
34324: #endif
34324:         disp = x->disp();
34324: 
34572:         JS_ASSERT(base == lirbuf->sp || base == eos_ins);
35083:         JS_ASSERT(disp == ((base == lirbuf->sp)
35083:                             ? nativespOffset(p)
35083:                             : nativeGlobalOffset(p)));
34324: 
34324:         writeBack(i, base, disp, demote);
34324:     }
17320: }
17320: 
22652: JS_REQUIRES_STACK LIns*
36662: TraceRecorder::attemptImport(jsval* p)
36662: {
38532:     if (LIns* i = getFromTracker(p))
36662:         return i;
36662: 
36662:     /* If the variable was not known, it could require a lazy import. */
36662:     CountSlotsVisitor countVisitor(p);
36662:     VisitStackSlots(countVisitor, cx, callDepth);
36662: 
36662:     if (countVisitor.stopped() || size_t(p - cx->fp->slots) < cx->fp->script->nslots)
36662:         return get(p);
36662: 
36662:     return NULL;
36662: }
36662: 
38532: nanojit::LIns*
38532: TraceRecorder::getFromTracker(jsval* p)
38532: {
38532:     checkForGlobalObjectReallocation();
38532:     return tracker.get(p);
38532: }
38532: 
36662: JS_REQUIRES_STACK LIns*
24381: TraceRecorder::get(jsval* p)
24381: {
38532:     LIns* x = getFromTracker(p);
36401:     if (x)
36401:         return x;
36401:     if (isGlobal(p)) {
36401:         unsigned slot = nativeGlobalSlot(p);
39928:         JS_ASSERT(tree->globalSlots->offsetOf(uint16(slot)) != -1);
36401:         importGlobalSlot(slot);
36401:     } else {
36401:         unsigned slot = nativeStackSlot(p);
37741:         TraceType type = importTypeMap[slot];
36401:         JS_ASSERT(type != TT_IGNORE);
36401:         import(lirbuf->sp, -tree->nativeStackBase + slot * sizeof(jsdouble),
36401:                p, type, "stack", slot, cx->fp);
36401:     }
32742:     JS_ASSERT(known(p));
17320:     return tracker.get(p);
17320: }
17320: 
31444: JS_REQUIRES_STACK LIns*
31444: TraceRecorder::addr(jsval* p)
31444: {
31444:     return isGlobal(p)
34572:            ? lir->ins2(LIR_piadd, eos_ins, INS_CONSTWORD(nativeGlobalOffset(p)))
32746:            : lir->ins2(LIR_piadd, lirbuf->sp,
35083:                        INS_CONSTWORD(nativespOffset(p)));
31444: }
31444: 
24381: JS_REQUIRES_STACK bool
24381: TraceRecorder::known(jsval* p)
24381: {
24381:     checkForGlobalObjectReallocation();
24381:     return tracker.has(p);
24381: }
24381: 
24381: /*
24381:  * The dslots of the global object are sometimes reallocated by the interpreter.
24381:  * This function check for that condition and re-maps the entries of the tracker
24381:  * accordingly.
24381:  */
24381: JS_REQUIRES_STACK void
24381: TraceRecorder::checkForGlobalObjectReallocation()
24381: {
24381:     if (global_dslots != globalObj->dslots) {
29883:         debug_only_print0(LC_TMTracer,
29883:                           "globalObj->dslots relocated, updating tracker\n");
24381:         jsval* src = global_dslots;
24381:         jsval* dst = globalObj->dslots;
24381:         jsuint length = globalObj->dslots[-1] - JS_INITIAL_NSLOTS;
27062:         LIns** map = (LIns**)alloca(sizeof(LIns*) * length);
24381:         for (jsuint n = 0; n < length; ++n) {
24381:             map[n] = tracker.get(src);
24381:             tracker.set(src++, NULL);
24381:         }
24381:         for (jsuint n = 0; n < length; ++n)
24381:             tracker.set(dst++, map[n]);
24381:         global_dslots = globalObj->dslots;
24381:     }
24381: }
24381: 
20416: /* Determine whether the current branch is a loop edge (taken or not taken). */
22652: static JS_REQUIRES_STACK bool
30860: IsLoopEdge(jsbytecode* pc, jsbytecode* header)
20416: {
20416:     switch (*pc) {
20416:       case JSOP_IFEQ:
20416:       case JSOP_IFNE:
20416:         return ((pc + GET_JUMP_OFFSET(pc)) == header);
20416:       case JSOP_IFEQX:
20416:       case JSOP_IFNEX:
20416:         return ((pc + GET_JUMPX_OFFSET(pc)) == header);
20416:       default:
20416:         JS_ASSERT((*pc == JSOP_AND) || (*pc == JSOP_ANDX) ||
20416:                   (*pc == JSOP_OR) || (*pc == JSOP_ORX));
20416:     }
20416:     return false;
20416: }
20416: 
29882: class AdjustCallerGlobalTypesVisitor : public SlotVisitorBase
29882: {
29880:     TraceRecorder &mRecorder;
29880:     JSContext *mCx;
29880:     nanojit::LirBuffer *mLirbuf;
29880:     nanojit::LirWriter *mLir;
37741:     TraceType *mTypeMap;
29880: public:
29880:     AdjustCallerGlobalTypesVisitor(TraceRecorder &recorder,
37741:                                    TraceType *typeMap) :
29880:         mRecorder(recorder),
29880:         mCx(mRecorder.cx),
29880:         mLirbuf(mRecorder.lirbuf),
29880:         mLir(mRecorder.lir),
29880:         mTypeMap(typeMap)
29880:     {}
29880: 
37741:     TraceType* getTypeMap()
29880:     {
29880:         return mTypeMap;
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29880:     visitGlobalSlot(jsval *vp, unsigned n, unsigned slot) {
29880:         LIns *ins = mRecorder.get(vp);
29880:         bool isPromote = isPromoteInt(ins);
29896:         if (isPromote && *mTypeMap == TT_DOUBLE) {
34572:             mLir->insStorei(mRecorder.get(vp), mRecorder.eos_ins,
40353:                             mRecorder.nativeGlobalOffset(vp), ACC_OTHER);
30860: 
30860:             /*
30860:              * Aggressively undo speculation so the inner tree will compile
30860:              * if this fails.
30860:              */
29880:             oracle.markGlobalSlotUndemotable(mCx, slot);
29880:         }
29896:         JS_ASSERT(!(!isPromote && *mTypeMap == TT_INT32));
29880:         ++mTypeMap;
29880:     }
29880: };
29880: 
29882: class AdjustCallerStackTypesVisitor : public SlotVisitorBase
29882: {
29880:     TraceRecorder &mRecorder;
29880:     JSContext *mCx;
29880:     nanojit::LirBuffer *mLirbuf;
29880:     nanojit::LirWriter *mLir;
29880:     unsigned mSlotnum;
37741:     TraceType *mTypeMap;
29880: public:
29880:     AdjustCallerStackTypesVisitor(TraceRecorder &recorder,
37741:                                   TraceType *typeMap) :
29880:         mRecorder(recorder),
29880:         mCx(mRecorder.cx),
29880:         mLirbuf(mRecorder.lirbuf),
29880:         mLir(mRecorder.lir),
29880:         mSlotnum(0),
29880:         mTypeMap(typeMap)
29880:     {}
29880: 
37741:     TraceType* getTypeMap()
29880:     {
29880:         return mTypeMap;
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp) {
29880:         for (size_t i = 0; i < count; ++i) {
29880:             LIns *ins = mRecorder.get(vp);
29880:             bool isPromote = isPromoteInt(ins);
29896:             if (isPromote && *mTypeMap == TT_DOUBLE) {
29880:                 mLir->insStorei(mRecorder.get(vp), mLirbuf->sp,
40353:                                 mRecorder.nativespOffset(vp), ACC_STACK);
30860: 
30860:                 /*
30860:                  * Aggressively undo speculation so the inner tree will compile
30860:                  * if this fails.
30860:                  */
29880:                 oracle.markStackSlotUndemotable(mCx, mSlotnum);
29880:             }
29896:             JS_ASSERT(!(!isPromote && *mTypeMap == TT_INT32));
29880:             ++vp;
29880:             ++mTypeMap;
29880:             ++mSlotnum;
29880:         }
29880:         return true;
29880:     }
29880: };
29880: 
28239: /*
30860:  * Promote slots if necessary to match the called tree's type map. This
30860:  * function is infallible and must only be called if we are certain that it is
30860:  * possible to reconcile the types for each slot in the inner and outer trees.
28239:  */
28239: JS_REQUIRES_STACK void
35044: TraceRecorder::adjustCallerTypes(TreeFragment* f)
35044: {
36361:     AdjustCallerGlobalTypesVisitor globalVisitor(*this, f->globalTypeMap());
36361:     VisitGlobalSlots(globalVisitor, cx, *tree->globalSlots);
36361: 
36361:     AdjustCallerStackTypesVisitor stackVisitor(*this, f->stackTypeMap());
29882:     VisitStackSlots(stackVisitor, cx, 0);
29880: 
18650:     JS_ASSERT(f == f->root);
18250: }
18250: 
37741: JS_REQUIRES_STACK TraceType
24381: TraceRecorder::determineSlotType(jsval* vp)
19084: {
37741:     TraceType m;
27541:     if (isNumber(*vp)) {
38532:         LIns* i = getFromTracker(vp);
36401:         if (i) {
29896:             m = isPromoteInt(i) ? TT_INT32 : TT_DOUBLE;
36401:         } else if (isGlobal(vp)) {
39928:             int offset = tree->globalSlots->offsetOf(uint16(nativeGlobalSlot(vp)));
36401:             JS_ASSERT(offset != -1);
36401:             m = importTypeMap[importStackSlots + offset];
36401:         } else {
36401:             m = importTypeMap[nativeStackSlot(vp)];
36401:         }
37009:         JS_ASSERT(m != TT_IGNORE);
27541:     } else if (JSVAL_IS_OBJECT(*vp)) {
27541:         if (JSVAL_IS_NULL(*vp))
29896:             m = TT_NULL;
40430:         else if (JSVAL_TO_OBJECT(*vp)->isFunction())
29896:             m = TT_FUNCTION;
27541:         else
29896:             m = TT_OBJECT;
40307:     } else if (JSVAL_IS_VOID(*vp)) {
40307:         /* N.B. void is JSVAL_SPECIAL. */
40307:         m = TT_VOID;
40307:     } else {
40307:         JS_ASSERT(JSVAL_IS_STRING(*vp) || JSVAL_IS_SPECIAL(*vp));
30850:         JS_STATIC_ASSERT(static_cast<jsvaltag>(TT_STRING) == JSVAL_STRING);
40307:         JS_STATIC_ASSERT(static_cast<jsvaltag>(TT_SPECIAL) == JSVAL_SPECIAL);
37741:         m = TraceType(JSVAL_TAG(*vp));
29896:     }
29896:     JS_ASSERT(m != TT_INT32 || isInt32(*vp));
19084:     return m;
19084: }
19084: 
29882: class DetermineTypesVisitor : public SlotVisitorBase
29882: {
29880:     TraceRecorder &mRecorder;
37741:     TraceType *mTypeMap;
29880: public:
29880:     DetermineTypesVisitor(TraceRecorder &recorder,
37741:                           TraceType *typeMap) :
29880:         mRecorder(recorder),
29880:         mTypeMap(typeMap)
29880:     {}
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29880:     visitGlobalSlot(jsval *vp, unsigned n, unsigned slot) {
29880:         *mTypeMap++ = mRecorder.determineSlotType(vp);
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp) {
29880:         for (size_t i = 0; i < count; ++i)
29880:             *mTypeMap++ = mRecorder.determineSlotType(vp++);
29880:         return true;
29880:     }
29880: 
37741:     TraceType* getTypeMap()
29880:     {
29880:         return mTypeMap;
29880:     }
29880: };
29880: 
31903: #if defined JS_JIT_SPEW
31903: JS_REQUIRES_STACK static void
31903: TreevisLogExit(JSContext* cx, VMSideExit* exit)
31903: {
31903:     debug_only_printf(LC_TMTreeVis, "TREEVIS ADDEXIT EXIT=%p TYPE=%s FRAG=%p PC=%p FILE=\"%s\""
31937:                       " LINE=%d OFFS=%d", (void*)exit, getExitName(exit->exitType),
31937:                       (void*)exit->from, (void*)cx->fp->regs->pc, cx->fp->script->filename,
31903:                       js_FramePCToLineNumber(cx, cx->fp), FramePCOffset(cx->fp));
31903:     debug_only_print0(LC_TMTreeVis, " STACK=\"");
31903:     for (unsigned i = 0; i < exit->numStackSlots; i++)
31903:         debug_only_printf(LC_TMTreeVis, "%c", typeChar[exit->stackTypeMap()[i]]);
31903:     debug_only_print0(LC_TMTreeVis, "\" GLOBALS=\"");
31903:     for (unsigned i = 0; i < exit->numGlobalSlots; i++)
31903:         debug_only_printf(LC_TMTreeVis, "%c", typeChar[exit->globalTypeMap()[i]]);
31903:     debug_only_print0(LC_TMTreeVis, "\"\n");
31903: }
31903: #endif
31903: 
27540: JS_REQUIRES_STACK VMSideExit*
17850: TraceRecorder::snapshot(ExitType exitType)
17850: {
17923:     JSStackFrame* fp = cx->fp;
20969:     JSFrameRegs* regs = fp->regs;
20969:     jsbytecode* pc = regs->pc;
20969: 
30860:     /*
30860:      * Check for a return-value opcode that needs to restart at the next
30860:      * instruction.
30860:      */
20969:     const JSCodeSpec& cs = js_CodeSpec[*pc];
20969: 
26972:     /*
26972:      * When calling a _FAIL native, make the snapshot's pc point to the next
30860:      * instruction after the CALL or APPLY. Even on failure, a _FAIL native
30860:      * must not be called again from the interpreter.
26972:      */
32669:     bool resumeAfter = (pendingSpecializedNative &&
32669:                         JSTN_ERRTYPE(pendingSpecializedNative) == FAIL_STATUS);
20969:     if (resumeAfter) {
30847:         JS_ASSERT(*pc == JSOP_CALL || *pc == JSOP_APPLY || *pc == JSOP_NEW ||
33564:                   *pc == JSOP_SETPROP || *pc == JSOP_SETNAME);
20969:         pc += cs.length;
20969:         regs->pc = pc;
21476:         MUST_FLOW_THROUGH("restore_pc");
20969:     }
20969: 
30860:     /*
30860:      * Generate the entry map for the (possibly advanced) pc and stash it in
30860:      * the trace.
30860:      */
30860:     unsigned stackSlots = NativeStackSlots(cx, callDepth);
30860: 
30860:     /*
30860:      * It's sufficient to track the native stack use here since all stores
30860:      * above the stack watermark defined by guards are killed.
30860:      */
17962:     trackNativeStackUse(stackSlots + 1);
20969: 
20947:     /* Capture the type map into a temporary location. */
36361:     unsigned ngslots = tree->globalSlots->length();
37741:     unsigned typemap_size = (stackSlots + ngslots) * sizeof(TraceType);
33930: 
33930:     /* Use the recorder-local temporary type map. */
37741:     TraceType* typemap = NULL;
33930:     if (tempTypeMap.resize(typemap_size))
33930:         typemap = tempTypeMap.begin(); /* crash if resize() fails. */
29880: 
29880:     /*
29880:      * Determine the type of a store by looking at the current type of the
30860:      * actual value the interpreter is using. For numbers we have to check what
30860:      * kind of store we used last (integer or double) to figure out what the
30860:      * side exit show reflect in its typemap.
29880:      */
29880:     DetermineTypesVisitor detVisitor(*this, typemap);
29882:     VisitSlots(detVisitor, cx, callDepth, ngslots,
36361:                tree->globalSlots->data());
29880:     JS_ASSERT(unsigned(detVisitor.getTypeMap() - typemap) ==
29880:               ngslots + stackSlots);
20969: 
26972:     /*
31444:      * If this snapshot is for a side exit that leaves a boxed jsval result on
31444:      * the stack, make a note of this in the typemap. Examples include the
31444:      * builtinStatus guard after calling a _FAIL builtin, a JSFastNative, or
31444:      * GetPropertyByName; and the type guard in unbox_jsval after such a call
31444:      * (also at the beginning of a trace branched from such a type guard).
31444:      */
31444:     if (pendingUnboxSlot ||
32669:         (pendingSpecializedNative && (pendingSpecializedNative->flags & JSTN_UNBOX_AFTER))) {
31444:         unsigned pos = stackSlots - 1;
31444:         if (pendingUnboxSlot == cx->fp->regs->sp - 2)
31444:             pos = stackSlots - 2;
31444:         typemap[pos] = TT_JSVAL;
31444:     }
26972: 
26972:     /* Now restore the the original pc (after which early returns are ok). */
26286:     if (resumeAfter) {
20969:         MUST_FLOW_LABEL(restore_pc);
20969:         regs->pc = pc - cs.length;
20969:     } else {
30860:         /*
30860:          * If we take a snapshot on a goto, advance to the target address. This
30860:          * avoids inner trees returning on a break goto, which the outer
30860:          * recorder then would confuse with a break in the outer tree.
30860:          */
20947:         if (*pc == JSOP_GOTO)
20947:             pc += GET_JUMP_OFFSET(pc);
20947:         else if (*pc == JSOP_GOTOX)
20947:             pc += GET_JUMPX_OFFSET(pc);
20969:     }
20969: 
26972:     /*
27540:      * Check if we already have a matching side exit; if so we can return that
27540:      * side exit instead of creating a new one.
26972:      */
36361:     VMSideExit** exits = tree->sideExits.data();
36361:     unsigned nexits = tree->sideExits.length();
20957:     if (exitType == LOOP_EXIT) {
20947:         for (unsigned n = 0; n < nexits; ++n) {
21521:             VMSideExit* e = exits[n];
25111:             if (e->pc == pc && e->imacpc == fp->imacpc &&
28996:                 ngslots == e->numGlobalSlots &&
31495:                 !memcmp(exits[n]->fullTypeMap(), typemap, typemap_size)) {
20947:                 AUDIT(mergedLoopExits);
31903: #if defined JS_JIT_SPEW
31903:                 TreevisLogExit(cx, e);
31903: #endif
27540:                 return e;
27540:             }
27540:         }
27540:     }
27540: 
27540:     /* We couldn't find a matching side exit, so create a new one. */
33161:     VMSideExit* exit = (VMSideExit*)
37741:         traceAlloc().alloc(sizeof(VMSideExit) + (stackSlots + ngslots) * sizeof(TraceType));
26972: 
26972:     /* Setup side exit structure. */
20931:     exit->from = fragment;
20931:     exit->calldepth = callDepth;
20931:     exit->numGlobalSlots = ngslots;
20931:     exit->numStackSlots = stackSlots;
31939:     exit->numStackSlotsBelowCurrentFrame = cx->fp->argv ?
31939:                                            nativeStackOffset(&cx->fp->argv[-2]) / sizeof(double) :
31939:                                            0;
20931:     exit->exitType = exitType;
22925:     exit->block = fp->blockChain;
31843:     if (fp->blockChain)
36361:         tree->gcthings.addUnique(OBJECT_TO_JSVAL(fp->blockChain));
25111:     exit->pc = pc;
25111:     exit->imacpc = fp->imacpc;
36361:     exit->sp_adj = (stackSlots * sizeof(double)) - tree->nativeStackBase;
23262:     exit->rp_adj = exit->calldepth * sizeof(FrameInfo*);
28086:     exit->nativeCalleeWord = 0;
30034:     exit->lookupFlags = js_InferFlags(cx, 0);
31495:     memcpy(exit->fullTypeMap(), typemap, typemap_size);
30435: 
31903: #if defined JS_JIT_SPEW
31903:     TreevisLogExit(cx, exit);
31903: #endif
27540:     return exit;
17381: }
17381: 
33161: JS_REQUIRES_STACK GuardRecord*
27540: TraceRecorder::createGuardRecord(VMSideExit* exit)
27540: {
40355: #ifdef JS_JIT_SPEW
40355:     // For debug builds, place the guard records in a longer lasting
40355:     // pool.  This is because the fragment profiler will look at them
40355:     // relatively late in the day, after they would have been freed,
40355:     // in some cases, had they been allocated in traceAlloc().
40355:     GuardRecord* gr = new (dataAlloc()) GuardRecord();
40355: #else
40355:     // The standard place (for production builds).
34351:     GuardRecord* gr = new (traceAlloc()) GuardRecord();
40355: #endif
27540: 
27540:     gr->exit = exit;
27540:     exit->addGuard(gr);
27540: 
33186:     // gr->profCount is calloc'd to zero
32784:     verbose_only(
32784:         gr->profGuardID = fragment->guardNumberer++;
32784:         gr->nextInFrag = fragment->guardsForFrag;
32784:         fragment->guardsForFrag = gr;
32784:     )
32784: 
33161:     return gr;
27540: }
27540: 
27540: /*
27540:  * Emit a guard for condition (cond), expecting to evaluate to boolean result
27540:  * (expected) and using the supplied side exit if the conditon doesn't hold.
27540:  */
27540: JS_REQUIRES_STACK void
27540: TraceRecorder::guard(bool expected, LIns* cond, VMSideExit* exit)
27540: {
29883:     debug_only_printf(LC_TMRecorder,
29883:                       "    About to try emitting guard code for "
29893:                       "SideExit=%p exitType=%s\n",
29894:                       (void*)exit, getExitName(exit->exitType));
28837: 
33161:     GuardRecord* guardRec = createGuardRecord(exit);
27540: 
26972:     if (exit->exitType == LOOP_EXIT)
36361:         tree->sideExits.add(exit);
27540: 
38603:     if (!cond->isCmp()) {
26265:         expected = !expected;
37748:         cond = cond->isI32() ? lir->ins_eq0(cond) : lir->ins_peq0(cond);
26265:     }
27540: 
27540:     LIns* guardIns =
27540:         lir->insGuard(expected ? LIR_xf : LIR_xt, cond, guardRec);
28837:     if (!guardIns) {
29883:         debug_only_print0(LC_TMRecorder,
29883:                           "    redundant guard, eliminated, no codegen\n");
26972:     }
27540: }
27540: 
38603: /*
38603:  * Emit a guard a 32-bit integer arithmetic operation op(d0, d1) and
38603:  * using the supplied side exit if it overflows.
38603:  */
38603: JS_REQUIRES_STACK LIns*
38603: TraceRecorder::guard_xov(LOpcode op, LIns* d0, LIns* d1, VMSideExit* exit)
38603: {
38603:     debug_only_printf(LC_TMRecorder,
38603:                       "    About to try emitting guard_xov code for "
38603:                       "SideExit=%p exitType=%s\n",
38603:                       (void*)exit, getExitName(exit->exitType));
38603: 
38603:     GuardRecord* guardRec = createGuardRecord(exit);
38603:     JS_ASSERT(exit->exitType == OVERFLOW_EXIT);
38603: 
38603:     switch (op) {
38603:       case LIR_add:
38603:         op = LIR_addxov;
38603:         break;
38603:       case LIR_sub:
38603:         op = LIR_subxov;
38603:         break;
38603:       case LIR_mul:
38603:         op = LIR_mulxov;
38603:         break;
38603:       default:
38603:         JS_NOT_REACHED("unexpected comparison op");
38603:         break;
38603:     }
38603: 
38603:     LIns* guardIns = lir->insGuardXov(op, d0, d1, guardRec);
38603:     NanoAssert(guardIns);
38603:     return guardIns;
38603: }
38603: 
27540: JS_REQUIRES_STACK VMSideExit*
27540: TraceRecorder::copy(VMSideExit* copy)
27540: {
27540:     size_t typemap_size = copy->numGlobalSlots + copy->numStackSlots;
33161:     VMSideExit* exit = (VMSideExit*)
37741:         traceAlloc().alloc(sizeof(VMSideExit) + typemap_size * sizeof(TraceType));
27540: 
27540:     /* Copy side exit structure. */
37741:     memcpy(exit, copy, sizeof(VMSideExit) + typemap_size * sizeof(TraceType));
27540:     exit->guards = NULL;
27540:     exit->from = fragment;
27540:     exit->target = NULL;
27540: 
27540:     if (exit->exitType == LOOP_EXIT)
36361:         tree->sideExits.add(exit);
31904: #if defined JS_JIT_SPEW
31903:     TreevisLogExit(cx, exit);
31904: #endif
27540:     return exit;
21083: }
21083: 
30860: /*
30860:  * Emit a guard for condition (cond), expecting to evaluate to boolean result
30860:  * (expected) and generate a side exit with type exitType to jump to if the
30860:  * condition does not hold.
30860:  */
26972: JS_REQUIRES_STACK void
17850: TraceRecorder::guard(bool expected, LIns* cond, ExitType exitType)
17323: {
26972:     guard(expected, cond, snapshot(exitType));
17336: }
17336: 
31526: /*
31526:  * Determine whether any context associated with the same thread as cx is
31526:  * executing native code.
31526:  */
31526: static inline bool
31526: ProhibitFlush(JSContext* cx)
31526: {
31526:     if (cx->interpState) // early out if the given is in native code
31526:         return true;
31526: 
31526:     JSCList *cl;
31526: 
31526: #ifdef JS_THREADSAFE
31526:     JSThread* thread = cx->thread;
31526:     for (cl = thread->contextList.next; cl != &thread->contextList; cl = cl->next)
31526:         if (CX_FROM_THREAD_LINKS(cl)->interpState)
31526:             return true;
31526: #else
31526:     JSRuntime* rt = cx->runtime;
31526:     for (cl = rt->contextList.next; cl != &rt->contextList; cl = cl->next)
31526:         if (js_ContextFromLinkField(cl)->interpState)
31526:             return true;
31526: #endif
31526:     return false;
31526: }
31526: 
36712: static void
32748: ResetJITImpl(JSContext* cx)
27493: {
27493:     if (!TRACING_ENABLED(cx))
27493:         return;
37741:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
29883:     debug_only_print0(LC_TMTracer, "Flushing cache.\n");
36712:     if (tm->recorder) {
36712:         JS_ASSERT_NOT_ON_TRACE(cx);
37741:         AbortRecording(cx, "flush cache");
36712:     }
31526:     if (ProhibitFlush(cx)) {
31920:         debug_only_print0(LC_TMTracer, "Deferring JIT flush due to deep bail.\n");
27493:         tm->needFlush = JS_TRUE;
27493:         return;
27493:     }
31843:     tm->flush();
27493: }
27493: 
18606: /* Compile the current fragment. */
33542: JS_REQUIRES_STACK AbortableRecordingStatus
35083: TraceRecorder::compile()
24307: {
29368: #ifdef MOZ_TRACEVIS
31063:     TraceVisStateObj tvso(cx, S_COMPILE);
29368: #endif
29368: 
35083:     if (traceMonitor->needFlush) {
32748:         ResetJIT(cx, FR_DEEP_BAIL);
33542:         return ARECORD_ABORTED;
27493:     }
36361:     if (tree->maxNativeStackSlots >= MAX_NATIVE_STACK_SLOTS) {
29883:         debug_only_print0(LC_TMTracer, "Blacklist: excessive stack use.\n");
40251:         Blacklist((jsbytecode*)tree->ip);
33542:         return ARECORD_STOP;
18118:     }
25099:     if (anchor && anchor->exitType != CASE_EXIT)
40251:         ++tree->branchCount;
33159:     if (outOfMemory())
33542:         return ARECORD_STOP;
31475: 
35377:     /* :TODO: windows support */
35377: #if defined DEBUG && !defined WIN32
35377:     /* Associate a filename and line number with the fragment. */
35377:     const char* filename = cx->fp->script->filename;
35377:     char* label = (char*)js_malloc((filename ? strlen(filename) : 7) + 16);
35377:     sprintf(label, "%s:%u", filename ? filename : "<stdin>",
35377:             js_FramePCToLineNumber(cx, cx->fp));
40300:     lirbuf->printer->addrNameMap->addAddrRange(fragment, sizeof(Fragment), 0, label);
35377:     js_free(label);
35377: #endif
35377: 
35083:     Assembler *assm = traceMonitor->assembler;
35083:     JS_ASSERT(assm->error() == nanojit::None);
40300:     assm->compile(fragment, tempAlloc(), /*optimize*/true verbose_only(, lirbuf->printer));
31475: 
31475:     if (assm->error() != nanojit::None) {
35083:         assm->setError(nanojit::None);
29883:         debug_only_print0(LC_TMTracer, "Blacklisted: error during compilation\n");
40251:         Blacklist((jsbytecode*)tree->ip);
33542:         return ARECORD_STOP;
22633:     }
35083: 
35083:     if (outOfMemory())
35083:         return ARECORD_STOP;
30860:     ResetRecordingAttempts(cx, (jsbytecode*)fragment->ip);
40251:     ResetRecordingAttempts(cx, (jsbytecode*)tree->ip);
25099:     if (anchor) {
25099: #ifdef NANOJIT_IA32
25099:         if (anchor->exitType == CASE_EXIT)
31475:             assm->patch(anchor, anchor->switchInfo);
25099:         else
25099: #endif
31475:             assm->patch(anchor);
25099:     }
18211:     JS_ASSERT(fragment->code());
36361:     JS_ASSERT_IF(fragment == fragment->root, fragment->root == tree);
30860: 
33542:     return ARECORD_CONTINUE;
18334: }
18334: 
31495: static void
35044: JoinPeers(Assembler* assm, VMSideExit* exit, TreeFragment* target)
31495: {
31495:     exit->target = target;
31495:     assm->patch(exit);
31495: 
31937:     debug_only_printf(LC_TMTreeVis, "TREEVIS JOIN ANCHOR=%p FRAG=%p\n", (void*)exit, (void*)target);
31903: 
31495:     if (exit->root() == target)
31495:         return;
31495: 
36361:     target->dependentTrees.addUnique(exit->root());
36361:     exit->root()->linkedTrees.addUnique(target);
31495: }
31495: 
31473: /* Results of trying to connect an arbitrary type A with arbitrary type B */
31473: enum TypeCheckResult
31473: {
31473:     TypeCheck_Okay,         /* Okay: same type */
31473:     TypeCheck_Promote,      /* Okay: Type A needs f2i() */
31473:     TypeCheck_Demote,       /* Okay: Type A needs i2f() */
31473:     TypeCheck_Undemote,     /* Bad: Slot is undemotable */
31473:     TypeCheck_Bad           /* Bad: incompatible types */
31473: };
31473: 
31473: class SlotMap : public SlotVisitorBase
31473: {
31473:   public:
31473:     struct SlotInfo
31473:     {
31920:         SlotInfo()
34332:           : vp(NULL), promoteInt(false), lastCheck(TypeCheck_Bad)
31920:         {}
34332:         SlotInfo(jsval* vp, bool promoteInt)
34332:           : vp(vp), promoteInt(promoteInt), lastCheck(TypeCheck_Bad), type(getCoercedType(*vp))
33564:         {}
37741:         SlotInfo(jsval* vp, TraceType t)
34332:           : vp(vp), promoteInt(t == TT_INT32), lastCheck(TypeCheck_Bad), type(t)
31920:         {}
34332:         jsval           *vp;
31473:         bool            promoteInt;
31473:         TypeCheckResult lastCheck;
37741:         TraceType     type;
31473:     };
31473: 
33564:     SlotMap(TraceRecorder& rec)
31920:         : mRecorder(rec),
31920:           mCx(rec.cx),
33564:           slots(NULL)
31473:     {
31473:     }
31473: 
39928:     virtual ~SlotMap()
39928:     {
39928:     }
39928: 
31473:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
31473:     visitGlobalSlot(jsval *vp, unsigned n, unsigned slot)
31473:     {
31473:         addSlot(vp);
31473:     }
31473: 
31473:     JS_ALWAYS_INLINE SlotMap::SlotInfo&
31473:     operator [](unsigned i)
31473:     {
31473:         return slots[i];
31473:     }
31473: 
31473:     JS_ALWAYS_INLINE SlotMap::SlotInfo&
31473:     get(unsigned i)
31473:     {
31473:         return slots[i];
31473:     }
31473: 
31473:     JS_ALWAYS_INLINE unsigned
31473:     length()
31473:     {
31473:         return slots.length();
31473:     }
31473: 
31473:     /**
31473:      * Possible return states:
31473:      *
31473:      * TypeConsensus_Okay:      All types are compatible. Caller must go through slot list and handle
31473:      *                          promote/demotes.
31473:      * TypeConsensus_Bad:       Types are not compatible. Individual type check results are undefined.
31473:      * TypeConsensus_Undemotes: Types would be compatible if slots were marked as undemotable
31473:      *                          before recording began. Caller can go through slot list and mark
31473:      *                          such slots as undemotable.
31473:      */
31473:     JS_REQUIRES_STACK TypeConsensus
36361:     checkTypes(LinkableFragment* f)
36361:     {
36361:         if (length() != f->typeMap.length())
31473:             return TypeConsensus_Bad;
31473: 
31473:         bool has_undemotes = false;
31473:         for (unsigned i = 0; i < length(); i++) {
36361:             TypeCheckResult result = checkType(i, f->typeMap[i]);
31473:             if (result == TypeCheck_Bad)
31473:                 return TypeConsensus_Bad;
31473:             if (result == TypeCheck_Undemote)
31473:                 has_undemotes = true;
31473:             slots[i].lastCheck = result;
31473:         }
31473:         if (has_undemotes)
31473:             return TypeConsensus_Undemotes;
31473:         return TypeConsensus_Okay;
31473:     }
31473: 
31473:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
31473:     addSlot(jsval* vp)
31473:     {
36401:         bool promoteInt = false;
36401:         if (isNumber(*vp)) {
38532:             if (LIns* i = mRecorder.getFromTracker(vp)) {
36401:                 promoteInt = isPromoteInt(i);
36401:             } else if (mRecorder.isGlobal(vp)) {
39928:                 int offset = mRecorder.tree->globalSlots->offsetOf(uint16(mRecorder.nativeGlobalSlot(vp)));
36401:                 JS_ASSERT(offset != -1);
36401:                 promoteInt = mRecorder.importTypeMap[mRecorder.importStackSlots + offset] ==
36401:                              TT_INT32;
36401:             } else {
36401:                 promoteInt = mRecorder.importTypeMap[mRecorder.nativeStackSlot(vp)] ==
36401:                              TT_INT32;
36401:             }
36401:         }
36401:         slots.add(SlotInfo(vp, promoteInt));
33564:     }
33564: 
33564:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
37741:     addSlot(TraceType t)
33564:     {
34332:         slots.add(SlotInfo(NULL, t));
34332:     }
34332: 
34332:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
37741:     addSlot(jsval *vp, TraceType t)
34332:     {
34332:         slots.add(SlotInfo(vp, t));
31473:     }
31473: 
30295:     JS_REQUIRES_STACK void
31473:     markUndemotes()
31473:     {
31473:         for (unsigned i = 0; i < length(); i++) {
31473:             if (get(i).lastCheck == TypeCheck_Undemote)
36361:                 MarkSlotUndemotable(mRecorder.cx, mRecorder.tree, i);
31473:         }
31473:     }
31473: 
31473:     JS_REQUIRES_STACK virtual void
34319:     adjustTail(TypeConsensus consensus)
34319:     {
34319:     }
34319: 
34319:     JS_REQUIRES_STACK virtual void
31473:     adjustTypes()
31473:     {
34319:         for (unsigned i = 0; i < length(); i++)
34319:             adjustType(get(i));
34319:     }
34319: 
34319:   protected:
34319:     JS_REQUIRES_STACK virtual void
34319:     adjustType(SlotInfo& info) {
31473:         JS_ASSERT(info.lastCheck != TypeCheck_Undemote && info.lastCheck != TypeCheck_Bad);
31473:         if (info.lastCheck == TypeCheck_Promote) {
33564:             JS_ASSERT(info.type == TT_INT32 || info.type == TT_DOUBLE);
34332:             mRecorder.set(info.vp, mRecorder.f2i(mRecorder.get(info.vp)));
31473:         } else if (info.lastCheck == TypeCheck_Demote) {
33564:             JS_ASSERT(info.type == TT_INT32 || info.type == TT_DOUBLE);
37748:             JS_ASSERT(mRecorder.get(info.vp)->isF64());
32700: 
32700:             /* Never demote this final i2f. */
39913:             mRecorder.set(info.vp, mRecorder.get(info.vp), false);
31473:         }
31473:     }
34319: 
31473:   private:
31473:     TypeCheckResult
37741:     checkType(unsigned i, TraceType t)
31473:     {
31473:         debug_only_printf(LC_TMTracer,
31473:                           "checkType slot %d: interp=%c typemap=%c isNum=%d promoteInt=%d\n",
31473:                           i,
33564:                           typeChar[slots[i].type],
31473:                           typeChar[t],
33564:                           slots[i].type == TT_INT32 || slots[i].type == TT_DOUBLE,
31473:                           slots[i].promoteInt);
31473:         switch (t) {
31473:           case TT_INT32:
33564:             if (slots[i].type != TT_INT32 && slots[i].type != TT_DOUBLE)
31473:                 return TypeCheck_Bad; /* Not a number? Type mismatch. */
31473:             /* This is always a type mismatch, we can't close a double to an int. */
31473:             if (!slots[i].promoteInt)
31473:                 return TypeCheck_Undemote;
31473:             /* Looks good, slot is an int32, the last instruction should be promotable. */
34332:             JS_ASSERT_IF(slots[i].vp, isInt32(*slots[i].vp) && slots[i].promoteInt);
34332:             return slots[i].vp ? TypeCheck_Promote : TypeCheck_Okay;
31473:           case TT_DOUBLE:
33564:             if (slots[i].type != TT_INT32 && slots[i].type != TT_DOUBLE)
31473:                 return TypeCheck_Bad; /* Not a number? Type mismatch. */
31473:             if (slots[i].promoteInt)
34332:                 return slots[i].vp ? TypeCheck_Demote : TypeCheck_Bad;
31473:             return TypeCheck_Okay;
31473:           default:
33564:             return slots[i].type == t ? TypeCheck_Okay : TypeCheck_Bad;
31473:         }
31473:         JS_NOT_REACHED("shouldn't fall through type check switch");
31473:     }
31473:   protected:
31473:     TraceRecorder& mRecorder;
31473:     JSContext* mCx;
31473:     Queue<SlotInfo> slots;
31473: };
31473: 
31473: class DefaultSlotMap : public SlotMap
31473: {
31473:   public:
33564:     DefaultSlotMap(TraceRecorder& tr) : SlotMap(tr)
31473:     {
31473:     }
31473:     
39928:     virtual ~DefaultSlotMap()
39928:     {
39928:     }
39928: 
31473:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
31473:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp)
31473:     {
31473:         for (size_t i = 0; i < count; i++)
31473:             addSlot(&vp[i]);
31473:         return true;
31473:     }
31473: };
31473: 
31473: JS_REQUIRES_STACK TypeConsensus
31473: TraceRecorder::selfTypeStability(SlotMap& slotMap)
31473: {
31473:     debug_only_printf(LC_TMTracer, "Checking type stability against self=%p\n", (void*)fragment);
36361:     TypeConsensus consensus = slotMap.checkTypes(tree);
31473: 
31473:     /* Best case: loop jumps back to its own header */
31473:     if (consensus == TypeConsensus_Okay)
31473:         return TypeConsensus_Okay;
31473: 
31473:     /* If the only thing keeping this loop from being stable is undemotions, then mark relevant
31473:      * slots as undemotable.
31473:      */
31473:     if (consensus == TypeConsensus_Undemotes)
31473:         slotMap.markUndemotes();
31473: 
31473:     return consensus;
31473: }
31473: 
31473: JS_REQUIRES_STACK TypeConsensus
35044: TraceRecorder::peerTypeStability(SlotMap& slotMap, const void* ip, TreeFragment** pPeer)
31473: {
31473:     /* See if there are any peers that would make this stable */
40251:     JS_ASSERT(fragment->root == tree);
40251:     TreeFragment* peer = LookupLoop(traceMonitor, ip, tree->globalObj, tree->globalShape, tree->argc);
33564: 
33564:     /* This condition is possible with recursion */
40251:     JS_ASSERT_IF(!peer, tree->ip != ip);
33564:     if (!peer)
33564:         return TypeConsensus_Bad;
31473:     bool onlyUndemotes = false;
35044:     for (; peer != NULL; peer = peer->peer) {
36361:         if (!peer->code() || peer == fragment)
31473:             continue;
31473:         debug_only_printf(LC_TMTracer, "Checking type stability against peer=%p\n", (void*)peer);
36361:         TypeConsensus consensus = slotMap.checkTypes(peer);
31473:         if (consensus == TypeConsensus_Okay) {
31473:             *pPeer = peer;
31473:             /* Return this even though there will be linkage; the trace itself is not stable.
31473:              * Caller should inspect ppeer to check for a compatible peer.
31473:              */
31473:             return TypeConsensus_Okay;
31473:         }
31473:         if (consensus == TypeConsensus_Undemotes)
31473:             onlyUndemotes = true;
31473:     }
31473: 
31473:     return onlyUndemotes ? TypeConsensus_Undemotes : TypeConsensus_Bad;
31473: }
31473: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
33564: TraceRecorder::closeLoop()
33564: {
33564:     return closeLoop(snapshot(UNSTABLE_LOOP_EXIT));
33564: }
33564: 
33564: JS_REQUIRES_STACK AbortableRecordingStatus
33564: TraceRecorder::closeLoop(VMSideExit* exit)
31473: {
31473:     DefaultSlotMap slotMap(*this);
36361:     VisitSlots(slotMap, cx, 0, *tree->globalSlots);
33564:     return closeLoop(slotMap, exit);
31473: }
31473: 
33542: /*
33542:  * Complete and compile a trace and link it to the existing tree if
33542:  * appropriate.  Returns ARECORD_ABORTED or ARECORD_STOP, depending on whether
33542:  * the recorder was deleted. Outparam is always set.
33542:  */
33542: JS_REQUIRES_STACK AbortableRecordingStatus
33564: TraceRecorder::closeLoop(SlotMap& slotMap, VMSideExit* exit)
21433: {
26557:     /*
30860:      * We should have arrived back at the loop header, and hence we don't want
32776:      * to be in an imacro here and the opcode should be either JSOP_TRACE or, in
30860:      * case this loop was blacklisted in the meantime, JSOP_NOP.
26557:      */
33564:     JS_ASSERT((*cx->fp->regs->pc == JSOP_TRACE || *cx->fp->regs->pc == JSOP_NOP ||
39939:                *cx->fp->regs->pc == JSOP_RETURN || *cx->fp->regs->pc == JSOP_STOP) &&
39939:               !cx->fp->imacpc);
26557: 
21684:     if (callDepth != 0) {
29883:         debug_only_print0(LC_TMTracer,
29883:                           "Blacklisted: stack depth mismatch, possible recursion.\n");
40251:         Blacklist((jsbytecode*)tree->ip);
22609:         trashSelf = true;
33564:         return ARECORD_STOP;
33564:     }
33564: 
33564:     JS_ASSERT_IF(exit->exitType == UNSTABLE_LOOP_EXIT,
36361:                  exit->numStackSlots == tree->nStackTypes);
33564:     JS_ASSERT_IF(exit->exitType != UNSTABLE_LOOP_EXIT, exit->exitType == RECURSIVE_UNLINKED_EXIT);
33564:     JS_ASSERT_IF(exit->exitType == RECURSIVE_UNLINKED_EXIT,
40251:                  exit->recursive_pc != tree->ip);
40221: 
40226:     JS_ASSERT(fragment->root == tree);
24491: 
35044:     TreeFragment* peer = NULL;
31473: 
33564:     TypeConsensus consensus = TypeConsensus_Bad;
33564: 
33564:     if (exit->exitType == UNSTABLE_LOOP_EXIT)
31473:         consensus = selfTypeStability(slotMap);
31473:     if (consensus != TypeConsensus_Okay) {
33564:         const void* ip = exit->exitType == RECURSIVE_UNLINKED_EXIT ?
40226:                          exit->recursive_pc : tree->ip;
33564:         TypeConsensus peerConsensus = peerTypeStability(slotMap, ip, &peer);
31473:         /* If there was a semblance of a stable peer (even if not linkable), keep the result. */
31473:         if (peerConsensus != TypeConsensus_Bad)
31473:             consensus = peerConsensus;
31473:     }
21433: 
21433: #if DEBUG
31473:     if (consensus != TypeConsensus_Okay || peer)
18606:         AUDIT(unstableLoopVariable);
21433: #endif
21433: 
31473:     JS_ASSERT(!trashSelf);
31473: 
34319:     /*
34319:      * This exit is indeed linkable to something now. Process any promote or
34319:      * demotes that are pending in the slot map.
31473:      */
31473:     if (consensus == TypeConsensus_Okay)
31473:         slotMap.adjustTypes();
31473: 
34319:     /* Give up-recursion a chance to pop the stack frame. */
34319:     slotMap.adjustTail(consensus);
34319: 
31473:     if (consensus != TypeConsensus_Okay || peer) {
30650:         fragment->lastIns = lir->insGuard(LIR_x, NULL, createGuardRecord(exit));
21433: 
31473:         /* If there is a peer, there must have been an "Okay" consensus. */
31473:         JS_ASSERT_IF(peer, consensus == TypeConsensus_Okay);
31473: 
31473:         /* Compile as a type-unstable loop, and hope for a connection later. */
21433:         if (!peer) {
21685:             /*
21685:              * If such a fragment does not exist, let's compile the loop ahead
21685:              * of time anyway.  Later, if the loop becomes type stable, we will
21685:              * connect these two fragments together.
21433:              */
29883:             debug_only_print0(LC_TMTracer,
29883:                               "Trace has unstable loop variable with no stable peer, "
29883:                               "compiling anyway.\n");
34351:             UnstableExit* uexit = new (traceAlloc()) UnstableExit;
21433:             uexit->fragment = fragment;
21433:             uexit->exit = exit;
36361:             uexit->next = tree->unstableExits;
36361:             tree->unstableExits = uexit;
21433:         } else {
21433:             JS_ASSERT(peer->code());
21433:             exit->target = peer;
29883:             debug_only_printf(LC_TMTracer,
29883:                               "Joining type-unstable trace to target fragment %p.\n",
29883:                               (void*)peer);
40251:             peer->dependentTrees.addUnique(tree);
36361:             tree->linkedTrees.addUnique(peer);
21433:         }
21433:     } else {
31903:         exit->exitType = LOOP_EXIT;
31937:         debug_only_printf(LC_TMTreeVis, "TREEVIS CHANGEEXIT EXIT=%p TYPE=%s\n", (void*)exit,
31903:                           getExitName(LOOP_EXIT));
32600: 
32600:         JS_ASSERT((fragment == fragment->root) == !!loopLabel);
32600:         if (loopLabel) {
32600:             lir->insBranch(LIR_j, NULL, loopLabel);
37774:             lir->ins1(LIR_plive, lirbuf->state);
32600:         }
32600: 
40251:         exit->target = tree;
32600:         fragment->lastIns = lir->insGuard(LIR_x, NULL, createGuardRecord(exit));
31473:     }
33542: 
35083:     CHECK_STATUS_A(compile());
31473: 
31937:     debug_only_printf(LC_TMTreeVis, "TREEVIS CLOSELOOP EXIT=%p PEER=%p\n", (void*)exit, (void*)peer);
31903: 
40226:     JS_ASSERT(LookupLoop(traceMonitor, tree->ip, tree->globalObj, tree->globalShape, tree->argc) ==
40226:               tree->first);
40226:     JS_ASSERT(tree->first);
40226: 
40226:     peer = tree->first;
31920:     joinEdgesToEntry(peer);
19588: 
31851:     debug_only_stmt(DumpPeerStability(traceMonitor, peer->ip, peer->globalObj,
31851:                                       peer->globalShape, peer->argc);)
31851: 
29883:     debug_only_print0(LC_TMTracer,
29883:                       "updating specializations on dependent and linked trees\n");
40226:     if (tree->code())
40251:         SpecializeTreesToMissingGlobals(cx, globalObj, tree);
25491: 
25627:     /*
25627:      * If this is a newly formed tree, and the outer tree has not been compiled yet, we
25627:      * should try to compile the outer tree again.
25627:      */
25937:     if (outer)
40226:         AttemptCompilation(cx, globalObj, outer, outerArgc);
29883: #ifdef JS_JIT_SPEW
29883:     debug_only_printf(LC_TMMinimal,
32784:                       "Recording completed at  %s:%u@%u via closeLoop (FragID=%06u)\n",
21685:                       cx->fp->script->filename,
21685:                       js_FramePCToLineNumber(cx, cx->fp),
32784:                       FramePCOffset(cx->fp),
32784:                       fragment->profFragID);
29883:     debug_only_print0(LC_TMMinimal, "\n");
29883: #endif
31473: 
35083:     return finishSuccessfully();
21433: }
21433: 
31495: static void
31495: FullMapFromExit(TypeMap& typeMap, VMSideExit* exit)
31495: {
31495:     typeMap.setLength(0);
31495:     typeMap.fromRaw(exit->stackTypeMap(), exit->numStackSlots);
31495:     typeMap.fromRaw(exit->globalTypeMap(), exit->numGlobalSlots);
31495:     /* Include globals that were later specialized at the root of the tree. */
36361:     if (exit->numGlobalSlots < exit->root()->nGlobalTypes()) {
36361:         typeMap.fromRaw(exit->root()->globalTypeMap() + exit->numGlobalSlots,
36361:                         exit->root()->nGlobalTypes() - exit->numGlobalSlots);
31495:     }
31495: }
31495: 
31496: static JS_REQUIRES_STACK TypeConsensus
35044: TypeMapLinkability(JSContext* cx, const TypeMap& typeMap, TreeFragment* peer)
35044: {
36361:     const TypeMap& peerMap = peer->typeMap;
31495:     unsigned minSlots = JS_MIN(typeMap.length(), peerMap.length());
31495:     TypeConsensus consensus = TypeConsensus_Okay;
31495:     for (unsigned i = 0; i < minSlots; i++) {
31495:         if (typeMap[i] == peerMap[i])
31495:             continue;
31495:         if (typeMap[i] == TT_INT32 && peerMap[i] == TT_DOUBLE &&
36361:             IsSlotUndemotable(cx, peer, i, peer->ip)) {
31495:             consensus = TypeConsensus_Undemotes;
31495:         } else {
31495:             return TypeConsensus_Bad;
31495:         }
31495:     }
31495:     return consensus;
31495: }
31495: 
31911: static JS_REQUIRES_STACK unsigned
36361: FindUndemotesInTypemaps(JSContext* cx, const TypeMap& typeMap, LinkableFragment* f,
31851:                         Queue<unsigned>& undemotes)
31851: {
31851:     undemotes.setLength(0);
36361:     unsigned minSlots = JS_MIN(typeMap.length(), f->typeMap.length());
31851:     for (unsigned i = 0; i < minSlots; i++) {
36361:         if (typeMap[i] == TT_INT32 && f->typeMap[i] == TT_DOUBLE) {
31851:             undemotes.add(i);
36361:         } else if (typeMap[i] != f->typeMap[i]) {
31851:             return 0;
31851:         }
31851:     }
31851:     for (unsigned i = 0; i < undemotes.length(); i++)
36361:         MarkSlotUndemotable(cx, f, undemotes[i]);
31851:     return undemotes.length();
31851: }
31851: 
22652: JS_REQUIRES_STACK void
35044: TraceRecorder::joinEdgesToEntry(TreeFragment* peer_root)
21433: {
32604:     if (fragment->root != fragment)
31851:         return;
31851: 
31920:     TypeMap typeMap(NULL);
31920:     Queue<unsigned> undemotes(NULL);
31851: 
35044:     for (TreeFragment* peer = peer_root; peer; peer = peer->peer) {
36361:         if (!peer->code())
21433:             continue;
36361:         UnstableExit* uexit = peer->unstableExits;
21433:         while (uexit != NULL) {
33564:             /* :TODO: these exits go somewhere else. */
33564:             if (uexit->exit->exitType == RECURSIVE_UNLINKED_EXIT) {
33564:                 uexit = uexit->next;
33564:                 continue;
33564:             }
31851:             /* Build the full typemap for this unstable exit */
31851:             FullMapFromExit(typeMap, uexit->exit);
31851:             /* Check its compatibility against this tree */
40251:             TypeConsensus consensus = TypeMapLinkability(cx, typeMap, tree);
31851:             JS_ASSERT_IF(consensus == TypeConsensus_Okay, peer != fragment);
31851:             if (consensus == TypeConsensus_Okay) {
29883:                 debug_only_printf(LC_TMTracer,
29883:                                   "Joining type-stable trace to target exit %p->%p.\n",
29883:                                   (void*)uexit->fragment, (void*)uexit->exit);
36397: 
36397:                 /*
36397:                  * See bug 531513. Before linking these trees, make sure the
36397:                  * peer's dependency graph is up to date.
36397:                  */
36397:                 TreeFragment* from = uexit->exit->root();
36397:                 if (from->nGlobalTypes() < tree->nGlobalTypes()) {
36397:                     SpecializeTreesToLateGlobals(cx, from, tree->globalTypeMap(),
36397:                                                  tree->nGlobalTypes());
36397:                 }
36397: 
31851:                 /* It's okay! Link together and remove the unstable exit. */
36397:                 JS_ASSERT(tree == fragment);
36397:                 JoinPeers(traceMonitor->assembler, uexit->exit, tree);
36361:                 uexit = peer->removeUnstableExit(uexit->exit);
31851:             } else {
31851:                 /* Check for int32->double slots that suggest trashing. */
36361:                 if (FindUndemotesInTypemaps(cx, typeMap, tree, undemotes)) {
22609:                     JS_ASSERT(peer == uexit->fragment->root);
22609:                     if (fragment == peer)
22609:                         trashSelf = true;
22609:                     else
22609:                         whichTreesToTrash.addUnique(uexit->fragment->root);
31851:                     return;
31851:                 }
21433:                 uexit = uexit->next;
21433:             }
21433:         }
21433:     }
21433: }
21433: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
31473: TraceRecorder::endLoop()
31473: {
33542:     return endLoop(snapshot(LOOP_EXIT));
31473: }
31473: 
18606: /* Emit an always-exit guard and compile the tree (used for break statements. */
33542: JS_REQUIRES_STACK AbortableRecordingStatus
31473: TraceRecorder::endLoop(VMSideExit* exit)
18606: {
40226:     JS_ASSERT(fragment->root == tree);
40226: 
21684:     if (callDepth != 0) {
29883:         debug_only_print0(LC_TMTracer, "Blacklisted: stack depth mismatch, possible recursion.\n");
40226:         Blacklist((jsbytecode*)tree->ip);
22609:         trashSelf = true;
33542:         return ARECORD_STOP;
21684:     }
21684: 
34351:     if (recordReason != Record_Branch)
33564:         RETURN_STOP_A("control flow should have been recursive");
33564: 
27540:     fragment->lastIns =
31473:         lir->insGuard(LIR_x, NULL, createGuardRecord(exit));
33542: 
35083:     CHECK_STATUS_A(compile());
21483: 
31937:     debug_only_printf(LC_TMTreeVis, "TREEVIS ENDLOOP EXIT=%p\n", (void*)exit);
31903: 
40226:     JS_ASSERT(LookupLoop(traceMonitor, tree->ip, tree->globalObj, tree->globalShape, tree->argc) ==
40226:               tree->first);
40226: 
40226:     joinEdgesToEntry(tree->first);
40226: 
40226:     debug_only_stmt(DumpPeerStability(traceMonitor, tree->ip, tree->globalObj,
40226:                                       tree->globalShape, tree->argc);)
21433: 
30860:     /*
30860:      * Note: this must always be done, in case we added new globals on trace
30860:      * and haven't yet propagated those to linked and dependent trees.
30860:      */
29883:     debug_only_print0(LC_TMTracer,
29883:                       "updating specializations on dependent and linked trees\n");
40226:     if (tree->code())
36361:         SpecializeTreesToMissingGlobals(cx, globalObj, fragment->root);
30860: 
30860:     /*
30860:      * If this is a newly formed tree, and the outer tree has not been compiled
30860:      * yet, we should try to compile the outer tree again.
25627:      */
25937:     if (outer)
40226:         AttemptCompilation(cx, globalObj, outer, outerArgc);
29883: #ifdef JS_JIT_SPEW
29883:     debug_only_printf(LC_TMMinimal,
32784:                       "Recording completed at  %s:%u@%u via endLoop (FragID=%06u)\n",
21685:                       cx->fp->script->filename,
21685:                       js_FramePCToLineNumber(cx, cx->fp),
32784:                       FramePCOffset(cx->fp),
32784:                       fragment->profFragID);
29883:     debug_only_print0(LC_TMTracer, "\n");
29883: #endif
33542: 
35083:     return finishSuccessfully();
17334: }
17334: 
18241: /* Emit code to adjust the stack to match the inner tree's stack expectations. */
22652: JS_REQUIRES_STACK void
39937: TraceRecorder::prepareTreeCall(TreeFragment* inner)
39937: {
31943:     VMSideExit* exit = snapshot(OOM_EXIT);
30860: 
30860:     /*
30860:      * The inner tree expects to be called from the current frame. If the outer
30860:      * tree (this trace) is currently inside a function inlining code
30860:      * (calldepth > 0), we have to advance the native stack pointer such that
30860:      * we match what the inner trace expects to see. We move it back when we
30860:      * come out of the inner tree call.
30860:      */
18007:     if (callDepth > 0) {
30860:         /*
30860:          * Calculate the amount we have to lift the native stack pointer by to
30860:          * compensate for any outer frames that the inner tree doesn't expect
30860:          * but the outer tree has.
30860:          */
18280:         ptrdiff_t sp_adj = nativeStackOffset(&cx->fp->argv[-2]);
30860: 
30860:         /* Calculate the amount we have to lift the call stack by. */
23262:         ptrdiff_t rp_adj = callDepth * sizeof(FrameInfo*);
30860: 
30860:         /*
30860:          * Guard that we have enough stack space for the tree we are trying to
30860:          * call on top of the new value for sp.
30860:          */
29883:         debug_only_printf(LC_TMTracer,
33132:                           "sp_adj=%lld outer=%lld inner=%lld\n",
33132:                           (long long int)sp_adj,
36361:                           (long long int)tree->nativeStackBase,
36361:                           (long long int)inner->nativeStackBase);
32746:         ptrdiff_t sp_offset =
36361:                 - tree->nativeStackBase /* rebase sp to beginning of outer tree's stack */
18184:                 + sp_adj /* adjust for stack in outer frame inner tree can't see */
36361:                 + inner->maxNativeStackSlots * sizeof(double); /* plus the inner tree's stack */
32746:         LIns* sp_top = lir->ins2(LIR_piadd, lirbuf->sp, INS_CONSTWORD(sp_offset));
32746:         guard(true, lir->ins2(LIR_plt, sp_top, eos_ins), exit);
30860: 
18133:         /* Guard that we have enough call stack space. */
36361:         ptrdiff_t rp_offset = rp_adj + inner->maxCallDepth * sizeof(FrameInfo*);
32746:         LIns* rp_top = lir->ins2(LIR_piadd, lirbuf->rp, INS_CONSTWORD(rp_offset));
32746:         guard(true, lir->ins2(LIR_plt, rp_top, eor_ins), exit);
32746: 
32746:         sp_offset =
36361:                 - tree->nativeStackBase /* rebase sp to beginning of outer tree's stack */
18184:                 + sp_adj /* adjust for stack in outer frame inner tree can't see */
36361:                 + inner->nativeStackBase; /* plus the inner tree's stack base */
32746:         /* We have enough space, so adjust sp and rp to their new level. */
39937:         lir->insStorei(lir->ins2(LIR_piadd, lirbuf->sp, INS_CONSTWORD(sp_offset)),
40353:                 lirbuf->state, offsetof(InterpState, sp), ACC_OTHER);
32746:         lir->insStorei(lir->ins2(LIR_piadd, lirbuf->rp, INS_CONSTWORD(rp_adj)),
40353:                 lirbuf->state, offsetof(InterpState, rp), ACC_OTHER);
18007:     }
31943: 
31943:     /*
31943:      * The inner tree will probably access stack slots. So tell nanojit not to
35344:      * discard or defer stack writes before emitting the call tree code.
31943:      *
31943:      * (The ExitType of this snapshot is nugatory. The exit can't be taken.)
31943:      */
33161:     GuardRecord* guardRec = createGuardRecord(exit);
31943:     lir->insGuard(LIR_xbarrier, NULL, guardRec);
18241: }
18241: 
31913: static unsigned
37741: BuildGlobalTypeMapFromInnerTree(Queue<TraceType>& typeMap, VMSideExit* inner)
31913: {
31913: #if defined DEBUG
31913:     unsigned initialSlots = typeMap.length();
31913: #endif
31913:     /* First, use the innermost exit's global typemap. */
31913:     typeMap.add(inner->globalTypeMap(), inner->numGlobalSlots);
31913: 
31913:     /* Add missing global types from the innermost exit's tree. */
36361:     TreeFragment* innerFrag = inner->root();
31913:     unsigned slots = inner->numGlobalSlots;
36361:     if (slots < innerFrag->nGlobalTypes()) {
36361:         typeMap.add(innerFrag->globalTypeMap() + slots, innerFrag->nGlobalTypes() - slots);
36361:         slots = innerFrag->nGlobalTypes();
31913:     }
31913:     JS_ASSERT(typeMap.length() - initialSlots == slots);
31913:     return slots;
31913: }
31913: 
18241: /* Record a call to an inner tree. */
22652: JS_REQUIRES_STACK void
39937: TraceRecorder::emitTreeCall(TreeFragment* inner, VMSideExit* exit)
35044: {
18007:     /* Invoke the inner tree. */
35344:     LIns* args[] = { lirbuf->state }; /* reverse order */
35344:     /* Construct a call info structure for the target tree. */
35344:     CallInfo* ci = new (traceAlloc()) CallInfo();
35344:     ci->_address = uintptr_t(inner->code());
35344:     JS_ASSERT(ci->_address);
40325:     ci->_typesig = ARGTYPE_P | ARGTYPE_P << ARGTYPE_SHIFT;
39910:     ci->_isPure = 0;
39910:     ci->_storeAccSet = ACC_STORE_ANY;
35344:     ci->_abi = ABI_FASTCALL;
35344: #ifdef DEBUG
35344:     ci->_name = "fragment";
35344: #endif
35344:     LIns* rec = lir->insCall(ci, args);
40353:     LIns* lr = lir->insLoad(LIR_ldp, rec, offsetof(GuardRecord, exit), ACC_OTHER);
35344:     LIns* nested = lir->insBranch(LIR_jt,
35344:                                   lir->ins2i(LIR_eq,
40353:                                              lir->insLoad(LIR_ld, lr,
40353:                                                           offsetof(VMSideExit, exitType),
40353:                                                           ACC_OTHER),
35344:                                              NESTED_EXIT),
35344:                                   NULL);
35344: 
35344:     /*
35344:      * If the tree exits on a regular (non-nested) guard, keep updating lastTreeExitGuard
35344:      * with that guard. If we mismatch on a tree call guard, this will contain the last
35344:      * non-nested guard we encountered, which is the innermost loop or branch guard.
35344:      */
40353:     lir->insStorei(lr, lirbuf->state, offsetof(InterpState, lastTreeExitGuard), ACC_OTHER);
35344:     LIns* done1 = lir->insBranch(LIR_j, NULL, NULL);
35344: 
35344:     /*
35344:      * The tree exited on a nested guard. This only occurs once a tree call guard mismatches
35344:      * and we unwind the tree call stack. We store the first (innermost) tree call guard in state
35344:      * and we will try to grow the outer tree the failing call was in starting at that guard.
35344:      */
35344:     nested->setTarget(lir->ins0(LIR_label));
35344:     LIns* done2 = lir->insBranch(LIR_jf,
35344:                                  lir->ins_peq0(lir->insLoad(LIR_ldp,
35344:                                                             lirbuf->state,
40353:                                                             offsetof(InterpState, lastTreeCallGuard),
40353:                                                             ACC_OTHER)),
35344:                                  NULL);
40353:     lir->insStorei(lr, lirbuf->state, offsetof(InterpState, lastTreeCallGuard), ACC_OTHER);
35344:     lir->insStorei(lir->ins2(LIR_piadd,
40353:                              lir->insLoad(LIR_ldp, lirbuf->state, offsetof(InterpState, rp),
40353:                                           ACC_OTHER),
35346:                              lir->ins_i2p(lir->ins2i(LIR_lsh,
40353:                                                      lir->insLoad(LIR_ld, lr,
40353:                                                                   offsetof(VMSideExit, calldepth),
40353:                                                                   ACC_OTHER),
35345:                                                      sizeof(void*) == 4 ? 2 : 3))),
35344:                    lirbuf->state,
40353:                    offsetof(InterpState, rpAtLastTreeCall), ACC_OTHER);
35344:     LIns* label = lir->ins0(LIR_label);
35344:     done1->setTarget(label);
35344:     done2->setTarget(label);
35344: 
35344:     /*
35344:      * Keep updating outermostTreeExit so that InterpState always contains the most recent
35344:      * side exit.
35344:      */
40353:     lir->insStorei(lr, lirbuf->state, offsetof(InterpState, outermostTreeExitGuard), ACC_OTHER);
26972: 
18116:     /* Read back all registers, in case the called tree changed any of them. */
29896: #ifdef DEBUG
37741:     TraceType* map;
29896:     size_t i;
31495:     map = exit->globalTypeMap();
29896:     for (i = 0; i < exit->numGlobalSlots; i++)
29896:         JS_ASSERT(map[i] != TT_JSVAL);
31495:     map = exit->stackTypeMap();
29896:     for (i = 0; i < exit->numStackSlots; i++)
29896:         JS_ASSERT(map[i] != TT_JSVAL);
29896: #endif
35344: 
30860:     /*
37009:      * Clear anything from the tracker that the inner tree could have written.
37009:      * This includes the current frame (which has variables that are local in
37009:      * the inner tree), the entry frame (which can be written to when upvars
37009:      * are set), and the globals.
37009:      */
37009:     clearEntryFrameSlotsFromTracker(tracker);
37009:     clearCurrentFrameSlotsFromTracker(tracker);
36401:     SlotList& gslots = *tree->globalSlots;
36401:     for (unsigned i = 0; i < gslots.length(); i++) {
36401:         unsigned slot = gslots[i];
40410:         jsval* vp = &globalObj->getSlotRef(slot);
36401:         tracker.set(vp, NULL);
36401:     }
36401: 
37009:     /* Set stack slots from the innermost frame. */
37009:     importTypeMap.setLength(NativeStackSlots(cx, callDepth));
36401: #ifdef DEBUG
37009:     for (unsigned i = importStackSlots; i < importTypeMap.length(); i++)
37009:         importTypeMap[i] = TT_IGNORE;
37009: #endif
37009:     unsigned startOfInnerFrame = importTypeMap.length() - exit->numStackSlots;
36401:     for (unsigned i = 0; i < exit->numStackSlots; i++)
36401:         importTypeMap[startOfInnerFrame + i] = exit->stackTypeMap()[i];
37009:     importStackSlots = importTypeMap.length();
37009:     JS_ASSERT(importStackSlots == NativeStackSlots(cx, callDepth));
36401: 
36401:     /*
30860:      * Bug 502604 - It is illegal to extend from the outer typemap without
30860:      * first extending from the inner. Make a new typemap here.
30246:      */
36401:     BuildGlobalTypeMapFromInnerTree(importTypeMap, exit);
36401: 
36401:     importGlobalSlots = importTypeMap.length() - importStackSlots;
36401:     JS_ASSERT(importGlobalSlots == tree->globalSlots->length());
26972: 
18159:     /* Restore sp and rp to their original values (we still have them in a register). */
18159:     if (callDepth > 0) {
40353:         lir->insStorei(lirbuf->sp, lirbuf->state, offsetof(InterpState, sp), ACC_OTHER);
40353:         lir->insStorei(lirbuf->rp, lirbuf->state, offsetof(InterpState, rp), ACC_OTHER);
18159:     }
26972: 
26972:     /*
26972:      * Guard that we come out of the inner tree along the same side exit we came out when
26972:      * we called the inner tree at recording time.
26972:      */
35344:     VMSideExit* nestedExit = snapshot(NESTED_EXIT);
35083:     JS_ASSERT(exit->exitType == LOOP_EXIT);
35344:     guard(true, lir->ins2(LIR_peq, lr, INS_CONSTPTR(exit)), nestedExit);
31937:     debug_only_printf(LC_TMTreeVis, "TREEVIS TREECALL INNER=%p EXIT=%p GUARD=%p\n", (void*)inner,
35344:                       (void*)nestedExit, (void*)exit);
30860: 
18650:     /* Register us as a dependent tree of the inner tree. */
36361:     inner->dependentTrees.addUnique(fragment->root);
36361:     tree->linkedTrees.addUnique(inner);
18334: }
18334: 
18694: /* Add a if/if-else control-flow merge point to the list of known merge points. */
22652: JS_REQUIRES_STACK void
18694: TraceRecorder::trackCfgMerges(jsbytecode* pc)
18694: {
18694:     /* If we hit the beginning of an if/if-else, then keep track of the merge point after it. */
18694:     JS_ASSERT((*pc == JSOP_IFEQ) || (*pc == JSOP_IFEQX));
18694:     jssrcnote* sn = js_GetSrcNote(cx->fp->script, pc);
18694:     if (sn != NULL) {
18694:         if (SN_TYPE(sn) == SRC_IF) {
18694:             cfgMerges.add((*pc == JSOP_IFEQ)
18694:                           ? pc + GET_JUMP_OFFSET(pc)
18694:                           : pc + GET_JUMPX_OFFSET(pc));
18694:         } else if (SN_TYPE(sn) == SRC_IF_ELSE)
18694:             cfgMerges.add(pc + js_GetSrcNoteOffset(sn, 0));
18694:     }
18694: }
18694: 
30860: /*
30860:  * Invert the direction of the guard if this is a loop edge that is not
30860:  * taken (thin loop).
30860:  */
22652: JS_REQUIRES_STACK void
26557: TraceRecorder::emitIf(jsbytecode* pc, bool cond, LIns* x)
26557: {
26557:     ExitType exitType;
40251:     if (IsLoopEdge(pc, (jsbytecode*)tree->ip)) {
26557:         exitType = LOOP_EXIT;
26557: 
26557:         /*
30860:          * If we are about to walk out of the loop, generate code for the
30860:          * inverse loop condition, pretending we recorded the case that stays
30860:          * on trace.
26557:          */
26557:         if ((*pc == JSOP_IFEQ || *pc == JSOP_IFEQX) == cond) {
26557:             JS_ASSERT(*pc == JSOP_IFNE || *pc == JSOP_IFNEX || *pc == JSOP_IFEQ || *pc == JSOP_IFEQX);
29883:             debug_only_print0(LC_TMTracer,
29883:                               "Walking out of the loop, terminating it anyway.\n");
20416:             cond = !cond;
26557:         }
26557: 
26557:         /*
30860:          * Conditional guards do not have to be emitted if the condition is
30860:          * constant. We make a note whether the loop condition is true or false
30860:          * here, so we later know whether to emit a loop edge or a loop end.
21433:          */
26557:         if (x->isconst()) {
34351:             pendingLoop = (x->imm32() == int32(cond));
26557:             return;
26557:         }
26557:     } else {
26557:         exitType = BRANCH_EXIT;
26557:     }
26557:     if (!x->isconst())
26557:         guard(cond, x, exitType);
20416: }
20416: 
18694: /* Emit code for a fused IFEQ/IFNE. */
22652: JS_REQUIRES_STACK void
18694: TraceRecorder::fuseIf(jsbytecode* pc, bool cond, LIns* x)
18694: {
26557:     if (*pc == JSOP_IFEQ || *pc == JSOP_IFNE) {
26557:         emitIf(pc, cond, x);
26557:         if (*pc == JSOP_IFEQ)
18694:             trackCfgMerges(pc);
26557:     }
26557: }
26557: 
26557: /* Check whether we have reached the end of the trace. */
33542: JS_REQUIRES_STACK AbortableRecordingStatus
26557: TraceRecorder::checkTraceEnd(jsbytecode *pc)
26557: {
40251:     if (IsLoopEdge(pc, (jsbytecode*)tree->ip)) {
30860:         /*
30860:          * If we compile a loop, the trace should have a zero stack balance at
30860:          * the loop edge. Currently we are parked on a comparison op or
30860:          * IFNE/IFEQ, so advance pc to the loop header and adjust the stack
30860:          * pointer and pretend we have reached the loop header.
26557:          */
34351:         if (pendingLoop) {
26557:             JS_ASSERT(!cx->fp->imacpc && (pc == cx->fp->regs->pc || pc == cx->fp->regs->pc + 1));
26557:             bool fused = pc != cx->fp->regs->pc;
26557:             JSFrameRegs orig = *cx->fp->regs;
26557: 
40251:             cx->fp->regs->pc = (jsbytecode*)tree->ip;
26557:             cx->fp->regs->sp -= fused ? 2 : 1;
26557: 
33755:             JSContext* localcx = cx;
33564:             AbortableRecordingStatus ars = closeLoop();
33755:             *localcx->fp->regs = orig;
33542:             return ars;
33542:         } else {
33542:             return endLoop();
33542:         }
33542:     }
33542:     return ARECORD_CONTINUE;
17966: }
17966: 
40327: RecordingStatus
40327: TraceRecorder::hasMethod(JSObject* obj, jsid id, bool& found)
40327: {
40327:     found = false;
40327:     RecordingStatus status = RECORD_CONTINUE;
21685:     if (!obj)
40327:         return status;
21685: 
21685:     JSObject* pobj;
21685:     JSProperty* prop;
31501:     int protoIndex = obj->lookupProperty(cx, id, &pobj, &prop);
40327:     if (protoIndex < 0)
40327:         return RECORD_ERROR;
40327:     if (!prop)
40327:         return status;
40327: 
40430:     if (!pobj->isNative()) {
40327:         // We can't rely on __iterator__ being present on trace just because
40327:         // it's there now, if found in a non-native object.
40327:         status = RECORD_STOP;
40327:     } else {
21685:         JSScope* scope = OBJ_SCOPE(pobj);
21685:         JSScopeProperty* sprop = (JSScopeProperty*) prop;
21685: 
40265:         if (sprop->hasDefaultGetterOrIsMethod() && SPROP_HAS_VALID_SLOT(sprop, scope)) {
21685:             jsval v = LOCKED_OBJ_GET_SLOT(pobj, sprop->slot);
21685:             if (VALUE_IS_FUNCTION(cx, v)) {
21685:                 found = true;
40327:                 if (!scope->generic() && !scope->branded() && !scope->brand(cx, sprop->slot, v))
40327:                     status = RECORD_STOP;
21685:             }
21685:         }
21685:     }
21685: 
31501:     pobj->dropProperty(cx, prop);
40327:     return status;
40327: }
40327: 
40327: JS_REQUIRES_STACK RecordingStatus
40327: TraceRecorder::hasIteratorMethod(JSObject* obj, bool& found)
21685: {
21685:     JS_ASSERT(cx->fp->regs->sp + 2 <= cx->fp->slots + cx->fp->script->nslots);
21685: 
40327:     return hasMethod(obj, ATOM_TO_JSID(cx->runtime->atomState.iteratorAtom), found);
21685: }
21685: 
33748: /*
33748:  * Check whether the shape of the global object has changed. The return value
35048:  * indicates whether the recorder is still active.  If 'false', any active
35048:  * recording has been aborted and the JIT may have been reset.
33748:  */
27493: static JS_REQUIRES_STACK bool
37741: CheckGlobalObjectShape(JSContext* cx, TraceMonitor* tm, JSObject* globalObj,
24491:                        uint32 *shape = NULL, SlotList** slots = NULL)
24491: {
27493:     if (tm->needFlush) {
32748:         ResetJIT(cx, FR_DEEP_BAIL);
27493:         return false;
27493:     }
24491: 
40410:     if (globalObj->numSlots() > MAX_GLOBAL_SLOTS) {
35048:         if (tm->recorder)
37741:             AbortRecording(cx, "too many slots in global object");
33748:         return false;
33748:     }
27889: 
24491:     uint32 globalShape = OBJ_SHAPE(globalObj);
24491: 
24491:     if (tm->recorder) {
35044:         TreeFragment* root = tm->recorder->getFragment()->root;
30860: 
24491:         /* Check the global shape matches the recorder's treeinfo's shape. */
26819:         if (globalObj != root->globalObj || globalShape != root->globalShape) {
21514:             AUDIT(globalShapeMismatchAtEntry);
29883:             debug_only_printf(LC_TMTracer,
29883:                               "Global object/shape mismatch (%p/%u vs. %p/%u), flushing cache.\n",
26823:                               (void*)globalObj, globalShape, (void*)root->globalObj,
29883:                               root->globalShape);
30860:             Backoff(cx, (jsbytecode*) root->ip);
32748:             ResetJIT(cx, FR_GLOBAL_SHAPE_MISMATCH);
24491:             return false;
24491:         }
24491:         if (shape)
24491:             *shape = globalShape;
24491:         if (slots)
36361:             *slots = root->globalSlots;
24491:         return true;
24491:     }
24491: 
24491:     /* No recorder, search for a tracked global-state (or allocate one). */
24491:     for (size_t i = 0; i < MONITOR_N_GLOBAL_STATES; ++i) {
24491:         GlobalState &state = tm->globalStates[i];
24491: 
27012:         if (state.globalShape == uint32(-1)) {
26819:             state.globalObj = globalObj;
24491:             state.globalShape = globalShape;
24491:             JS_ASSERT(state.globalSlots);
24491:             JS_ASSERT(state.globalSlots->length() == 0);
24491:         }
24491: 
26819:         if (state.globalObj == globalObj && state.globalShape == globalShape) {
24491:             if (shape)
24491:                 *shape = globalShape;
24491:             if (slots)
24491:                 *slots = state.globalSlots;
24491:             return true;
24491:         }
24491:     }
24491: 
24491:     /* No currently-tracked-global found and no room to allocate, abort. */
24491:     AUDIT(globalShapeMismatchAtEntry);
29883:     debug_only_printf(LC_TMTracer,
29883:                       "No global slotlist for global shape %u, flushing cache.\n",
29883:                       globalShape);
32748:     ResetJIT(cx, FR_GLOBALS_FULL);
24491:     return false;
21514: }
21514: 
35083: /*
35083:  * Return whether or not the recorder could be started. If 'false', the JIT has
35083:  * been reset in response to an OOM.
35083:  */
35083: bool JS_REQUIRES_STACK
35083: TraceRecorder::startRecorder(JSContext* cx, VMSideExit* anchor, VMFragment* f,
36361:                              unsigned stackSlots, unsigned ngslots,
37741:                              TraceType* typeMap, VMSideExit* expectedInnerExit,
35083:                              jsbytecode* outer, uint32 outerArgc, RecordReason recordReason)
17731: {
37741:     TraceMonitor *tm = &JS_TRACE_MONITOR(cx);
35083:     JS_ASSERT(!tm->needFlush);
35083:     JS_ASSERT_IF(cx->fp->imacpc, f->root != f);
35083: 
36361:     tm->recorder = new TraceRecorder(cx, anchor, f, stackSlots, ngslots, typeMap,
36361:                                      expectedInnerExit, outer, outerArgc, recordReason);
35083: 
37741:     if (!tm->recorder || tm->outOfMemory() || OverfullJITCache(tm)) {
35083:         ResetJIT(cx, FR_OOM);
35083:         return false;
35083:     }
35083: 
35083:     /*
35083:      * If slurping failed, there's no reason to start recording again. Emit LIR
35083:      * to capture the rest of the slots, then immediately compile and finish.
35083:      */
35083:     if (anchor && anchor->exitType == RECURSIVE_SLURP_FAIL_EXIT) {
35083:         tm->recorder->slurpDownFrames((jsbytecode*)anchor->recursive_pc - JSOP_CALL_LENGTH);
35083:         if (tm->recorder)
35083:             tm->recorder->finishAbort("Failed to slurp down frames");
35083:         return false;
35083:     }
35083: 
17731:     return true;
17731: }
17731: 
17853: static void
35044: TrashTree(JSContext* cx, TreeFragment* f)
35044: {
18650:     JS_ASSERT(f == f->root);
31937:     debug_only_printf(LC_TMTreeVis, "TREEVIS TRASH FRAG=%p\n", (void*)f);
32784: 
18211:     if (!f->code())
18211:         return;
17889:     AUDIT(treesTrashed);
29883:     debug_only_print0(LC_TMTracer, "Trashing tree info.\n");
31920:     f->setCode(NULL);
36361:     TreeFragment** data = f->dependentTrees.data();
36361:     unsigned length = f->dependentTrees.length();
18650:     for (unsigned n = 0; n < length; ++n)
30860:         TrashTree(cx, data[n]);
36361:     data = f->linkedTrees.data();
36361:     length = f->linkedTrees.length();
30458:     for (unsigned n = 0; n < length; ++n)
30860:         TrashTree(cx, data[n]);
17853: }
17853: 
19663: static int
31924: SynthesizeFrame(JSContext* cx, const FrameInfo& fi, JSObject* callee)
17923: {
22652:     VOUCH_DOES_NOT_REQUIRE_STACK();
22652: 
31924:     JSFunction* fun = GET_FUNCTION_PRIVATE(cx, callee);
17923:     JS_ASSERT(FUN_INTERPRETED(fun));
17923: 
19662:     /* Assert that we have a correct sp distance from cx->fp->slots in fi. */
22925:     JSStackFrame* fp = cx->fp;
25111:     JS_ASSERT_IF(!fi.imacpc,
30860:                  js_ReconstructStackDepth(cx, fp->script, fi.pc) ==
30860:                  uintN(fi.spdist - fp->script->nfixed));
19662: 
19662:     uintN nframeslots = JS_HOWMANY(sizeof(JSInlineFrame), sizeof(jsval));
19662:     JSScript* script = fun->u.i.script;
19662:     size_t nbytes = (nframeslots + script->nslots) * sizeof(jsval);
19662: 
19662:     /* Code duplicated from inline_call: case in js_Interpret (FIXME). */
17923:     JSArena* a = cx->stackPool.current;
17923:     void* newmark = (void*) a->avail;
28949:     uintN argc = fi.get_argc();
28887:     jsval* vp = fp->slots + fi.spdist - (2 + argc);
19662:     uintN missing = 0;
19662:     jsval* newsp;
19662: 
19662:     if (fun->nargs > argc) {
22925:         const JSFrameRegs& regs = *fp->regs;
19662: 
19662:         newsp = vp + 2 + fun->nargs;
19662:         JS_ASSERT(newsp > regs.sp);
19662:         if ((jsuword) newsp <= a->limit) {
19662:             if ((jsuword) newsp > a->avail)
19662:                 a->avail = (jsuword) newsp;
19662:             jsval* argsp = newsp;
19662:             do {
19662:                 *--argsp = JSVAL_VOID;
19662:             } while (argsp != regs.sp);
19662:             missing = 0;
19662:         } else {
19662:             missing = fun->nargs - argc;
19662:             nbytes += (2 + fun->nargs) * sizeof(jsval);
19662:         }
19662:     }
17923: 
17923:     /* Allocate the inline frame with its vars and operands. */
17923:     if (a->avail + nbytes <= a->limit) {
17923:         newsp = (jsval *) a->avail;
17923:         a->avail += nbytes;
19662:         JS_ASSERT(missing == 0);
17923:     } else {
17923:         JS_ARENA_ALLOCATE_CAST(newsp, jsval *, &cx->stackPool, nbytes);
35078:         if (!newsp)
35078:             OutOfMemoryAbort();
19662: 
19662:         /*
19662:          * Move args if the missing ones overflow arena a, then push
19662:          * undefined for the missing args.
19662:          */
19662:         if (missing) {
19662:             memcpy(newsp, vp, (2 + argc) * sizeof(jsval));
19662:             vp = newsp;
19662:             newsp = vp + 2 + argc;
19662:             do {
19662:                 *newsp++ = JSVAL_VOID;
19662:             } while (--missing != 0);
19662:         }
17923:     }
17923: 
17923:     /* Claim space for the stack frame and initialize it. */
17923:     JSInlineFrame* newifp = (JSInlineFrame *) newsp;
17923:     newsp += nframeslots;
17923: 
17923:     newifp->frame.callobj = NULL;
17923:     newifp->frame.argsobj = NULL;
17923:     newifp->frame.script = script;
17923:     newifp->frame.fun = fun;
17923: 
28949:     bool constructing = fi.is_constructing();
19577:     newifp->frame.argc = argc;
25111:     newifp->callerRegs.pc = fi.pc;
28887:     newifp->callerRegs.sp = fp->slots + fi.spdist;
25111:     fp->imacpc = fi.imacpc;
22925: 
22925: #ifdef DEBUG
22925:     if (fi.block != fp->blockChain) {
39930:         for (JSObject* obj = fi.block; obj != fp->blockChain; obj = obj->getParent())
22925:             JS_ASSERT(obj);
22925:     }
22925: #endif
22925:     fp->blockChain = fi.block;
21685: 
19981:     newifp->frame.argv = newifp->callerRegs.sp - argc;
19591:     JS_ASSERT(newifp->frame.argv);
19591: #ifdef DEBUG
19591:     // Initialize argv[-1] to a known-bogus value so we'll catch it if
19591:     // someone forgets to initialize it later.
19591:     newifp->frame.argv[-1] = JSVAL_HOLE;
19591: #endif
22925:     JS_ASSERT(newifp->frame.argv >= StackBase(fp) + 2);
17923: 
17923:     newifp->frame.rval = JSVAL_VOID;
22925:     newifp->frame.down = fp;
17923:     newifp->frame.annotation = NULL;
28664:     newifp->frame.scopeChain = NULL; // will be updated in FlushNativeStackFrame
19577:     newifp->frame.flags = constructing ? JSFRAME_CONSTRUCTING : 0;
17923:     newifp->frame.blockChain = NULL;
17923:     newifp->mark = newmark;
32774:     newifp->frame.thisv = JSVAL_NULL; // will be updated in FlushNativeStackFrame
17923: 
22925:     newifp->frame.regs = fp->regs;
17923:     newifp->frame.regs->pc = script->code;
17923:     newifp->frame.regs->sp = newsp + script->nfixed;
21685:     newifp->frame.imacpc = NULL;
17923:     newifp->frame.slots = newsp;
27012:     if (script->staticLevel < JS_DISPLAY_SIZE) {
27012:         JSStackFrame **disp = &cx->display[script->staticLevel];
18308:         newifp->frame.displaySave = *disp;
18308:         *disp = &newifp->frame;
18308:     }
17923: 
21141:     /*
22925:      * Note that fp->script is still the caller's script; set the callee
21141:      * inline frame's idea of caller version from its version.
21141:      */
22925:     newifp->callerVersion = (JSVersion) fp->script->version;
22925: 
22925:     // After this paragraph, fp and cx->fp point to the newly synthesized frame.
22925:     fp->regs = &newifp->callerRegs;
22925:     fp = cx->fp = &newifp->frame;
18226: 
21141:     /*
21141:      * If there's a call hook, invoke it to compute the hookData used by
21141:      * debuggers that cooperate with the interpreter.
21141:      */
21141:     JSInterpreterHook hook = cx->debugHooks->callHook;
21141:     if (hook) {
28691:         newifp->hookData = hook(cx, fp, JS_TRUE, 0, cx->debugHooks->callHookData);
21141:     } else {
21141:         newifp->hookData = NULL;
21141:     }
21141: 
30860:     /*
30860:      * Duplicate native stack layout computation: see VisitFrameSlots header comment.
30860:      *
30860:      * FIXME - We must count stack slots from caller's operand stack up to (but
30860:      * not including) callee's, including missing arguments. Could we shift
30860:      * everything down to the caller's fp->slots (where vars start) and avoid
30860:      * some of the complexity?
30860:      */
28887:     return (fi.spdist - fp->down->script->nfixed) +
22925:            ((fun->nargs > fp->argc) ? fun->nargs - fp->argc : 0) +
37694:            script->nfixed + SPECIAL_FRAME_SLOTS;
17923: }
17923: 
28086: static void
32726: SynthesizeSlowNativeFrame(InterpState& state, JSContext *cx, VMSideExit *exit)
28086: {
28087:     VOUCH_DOES_NOT_REQUIRE_STACK();
28087: 
28086:     void *mark;
28086:     JSInlineFrame *ifp;
28086: 
30860:     /* This allocation is infallible: ExecuteTree reserved enough stack. */
28086:     mark = JS_ARENA_MARK(&cx->stackPool);
28086:     JS_ARENA_ALLOCATE_CAST(ifp, JSInlineFrame *, &cx->stackPool, sizeof(JSInlineFrame));
35078:     if (!ifp)
35078:         OutOfMemoryAbort();
28086: 
28086:     JSStackFrame *fp = &ifp->frame;
28086:     fp->regs = NULL;
28086:     fp->imacpc = NULL;
28086:     fp->slots = NULL;
28086:     fp->callobj = NULL;
28086:     fp->argsobj = NULL;
28086:     fp->script = NULL;
32774:     fp->thisv = state.nativeVp[1];
32726:     fp->argc = state.nativeVpLen - 2;
32726:     fp->argv = state.nativeVp + 2;
34352:     fp->fun = GET_FUNCTION_PRIVATE(cx, fp->calleeObject());
28086:     fp->rval = JSVAL_VOID;
28086:     fp->down = cx->fp;
28086:     fp->annotation = NULL;
28086:     JS_ASSERT(cx->fp->scopeChain);
28086:     fp->scopeChain = cx->fp->scopeChain;
28086:     fp->blockChain = NULL;
28086:     fp->flags = exit->constructing() ? JSFRAME_CONSTRUCTING : 0;
28086:     fp->displaySave = NULL;
28086: 
28086:     ifp->mark = mark;
28086:     cx->fp = fp;
28086: }
28086: 
35083: static JS_REQUIRES_STACK bool
40226: RecordTree(JSContext* cx, TreeFragment* peer, jsbytecode* outer,
40226:            uint32 outerArgc, SlotList* globalSlots, RecordReason reason)
40226: {
40226:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
40226: 
35083:     /* Try to find an unused peer fragment, or allocate a new one. */
35083:     TreeFragment* f = peer;
35083:     while (f->code() && f->peer)
35083:         f = f->peer;
35083:     if (f->code())
35083:         f = AddNewPeerToPeerList(tm, f);
35083:     JS_ASSERT(f->root == f);
35083: 
35083:     /* save a local copy for use after JIT flush */
35083:     const void* localRootIP = f->root->ip;
35083: 
35083:     /* Make sure the global type map didn't change on us. */
40226:     if (!CheckGlobalObjectShape(cx, tm, f->globalObj)) {
35083:         Backoff(cx, (jsbytecode*) localRootIP);
35083:         return false;
35083:     }
35083: 
35083:     AUDIT(recorderStarted);
35083: 
37741:     if (tm->outOfMemory() || OverfullJITCache(tm)) {
35083:         Backoff(cx, (jsbytecode*) f->root->ip);
35083:         ResetJIT(cx, FR_OOM);
35083:         debug_only_print0(LC_TMTracer,
35083:                           "Out of memory recording new tree, flushing cache.\n");
35083:         return false;
35083:     }
35083: 
36361:     JS_ASSERT(!f->code());
36361: 
36361:     f->initialize(cx, globalSlots);
36361: 
36361: #ifdef DEBUG
36361:     AssertTreeIsUnique(tm, f);
36361: #endif
36361: #ifdef JS_JIT_SPEW
36361:     debug_only_printf(LC_TMTreeVis, "TREEVIS CREATETREE ROOT=%p PC=%p FILE=\"%s\" LINE=%d OFFS=%d",
36361:                       (void*)f, f->ip, f->treeFileName, f->treeLineNumber,
36361:                       FramePCOffset(cx->fp));
36361:     debug_only_print0(LC_TMTreeVis, " STACK=\"");
36361:     for (unsigned i = 0; i < f->nStackTypes; i++)
36361:         debug_only_printf(LC_TMTreeVis, "%c", typeChar[f->typeMap[i]]);
36361:     debug_only_print0(LC_TMTreeVis, "\" GLOBALS=\"");
36361:     for (unsigned i = 0; i < f->nGlobalTypes(); i++)
36361:         debug_only_printf(LC_TMTreeVis, "%c", typeChar[f->typeMap[f->nStackTypes + i]]);
36361:     debug_only_print0(LC_TMTreeVis, "\"\n");
36361: #endif
35083: 
30860:     /* Recording primary trace. */
36361:     return TraceRecorder::startRecorder(cx, NULL, f, f->nStackTypes,
36361:                                         f->globalSlots->length(),
36361:                                         f->typeMap.data(), NULL,
35083:                                         outer, outerArgc, reason);
23918: }
23918: 
31496: static JS_REQUIRES_STACK TypeConsensus
35044: FindLoopEdgeTarget(JSContext* cx, VMSideExit* exit, TreeFragment** peerp)
35044: {
35044:     TreeFragment* from = exit->root();
31495: 
31495:     JS_ASSERT(from->code());
31495: 
31920:     TypeMap typeMap(NULL);
31495:     FullMapFromExit(typeMap, exit);
36361:     JS_ASSERT(typeMap.length() - exit->numStackSlots == from->nGlobalTypes());
31495: 
31495:     /* Mark all double slots as undemotable */
36361:     uint16* gslots = from->globalSlots->data();
31495:     for (unsigned i = 0; i < typeMap.length(); i++) {
33564:         if (typeMap[i] == TT_DOUBLE) {
33564:             if (exit->exitType == RECURSIVE_UNLINKED_EXIT) {
33564:                 if (i < exit->numStackSlots)
33564:                     oracle.markStackSlotUndemotable(cx, i, exit->recursive_pc);
33564:                 else
33564:                     oracle.markGlobalSlotUndemotable(cx, gslots[i - exit->numStackSlots]);
33564:             }
36361:             if (i < from->nStackTypes)
33564:                 oracle.markStackSlotUndemotable(cx, i, from->ip);
33564:             else if (i >= exit->numStackSlots)
33564:                 oracle.markGlobalSlotUndemotable(cx, gslots[i - exit->numStackSlots]);
33564:         }
33564:     }
33564: 
33564:     JS_ASSERT(exit->exitType == UNSTABLE_LOOP_EXIT ||
33564:               (exit->exitType == RECURSIVE_UNLINKED_EXIT && exit->recursive_pc));
33564: 
35044:     TreeFragment* firstPeer = NULL;
33564:     if (exit->exitType == UNSTABLE_LOOP_EXIT || exit->recursive_pc == from->ip) {
35044:         firstPeer = from->first;
33564:     } else {
33748:         firstPeer = LookupLoop(&JS_TRACE_MONITOR(cx), exit->recursive_pc, from->globalObj,
33564:                                from->globalShape, from->argc);
33564:     }
33564: 
35044:     for (TreeFragment* peer = firstPeer; peer; peer = peer->peer) {
36361:         if (!peer->code())
31495:             continue;
31495:         JS_ASSERT(peer->argc == from->argc);
36361:         JS_ASSERT(exit->numStackSlots == peer->nStackTypes);
31495:         TypeConsensus consensus = TypeMapLinkability(cx, typeMap, peer);
31499:         if (consensus == TypeConsensus_Okay || consensus == TypeConsensus_Undemotes) {
31495:             *peerp = peer;
31495:             return consensus;
31495:         }
31495:     }
31495: 
31495:     return TypeConsensus_Bad;
31495: }
31495: 
30860: static JS_REQUIRES_STACK bool
30860: AttemptToStabilizeTree(JSContext* cx, JSObject* globalObj, VMSideExit* exit, jsbytecode* outer,
30860:                        uint32 outerArgc)
21433: {
37741:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
28308:     if (tm->needFlush) {
32748:         ResetJIT(cx, FR_DEEP_BAIL);
28308:         return false;
28308:     }
28308: 
35044:     TreeFragment* from = exit->root();
35044: 
35044:     TreeFragment* peer = NULL;
31495:     TypeConsensus consensus = FindLoopEdgeTarget(cx, exit, &peer);
31495:     if (consensus == TypeConsensus_Okay) {
36361:         JS_ASSERT(from->globalSlots == peer->globalSlots);
33564:         JS_ASSERT_IF(exit->exitType == UNSTABLE_LOOP_EXIT,
36361:                      from->nStackTypes == peer->nStackTypes);
36361:         JS_ASSERT(exit->numStackSlots == peer->nStackTypes);
31495:         /* Patch this exit to its peer */
31495:         JoinPeers(tm->assembler, exit, peer);
31495:         /*
31495:          * Update peer global types. The |from| fragment should already be updated because it on
31495:          * the execution path, and somehow connected to the entry trace.
31495:          */
36361:         if (peer->nGlobalTypes() < peer->globalSlots->length())
36361:             SpecializeTreesToMissingGlobals(cx, globalObj, peer);
36361:         JS_ASSERT(from->nGlobalTypes() == from->globalSlots->length());
31495:         /* This exit is no longer unstable, so remove it. */
33564:         if (exit->exitType == UNSTABLE_LOOP_EXIT)
36361:             from->removeUnstableExit(exit);
36361:         debug_only_stmt(DumpPeerStability(tm, peer->ip, globalObj, from->globalShape, from->argc);)
31495:         return false;
31495:     } else if (consensus == TypeConsensus_Undemotes) {
24295:         /* The original tree is unconnectable, so trash it. */
31495:         TrashTree(cx, peer);
24295:         return false;
24246:     }
31495: 
36361:     uint32 globalShape = from->globalShape;
36361:     SlotList *globalSlots = from->globalSlots;
36361: 
33564:     /* Don't bother recording if the exit doesn't expect this PC */
33564:     if (exit->exitType == RECURSIVE_UNLINKED_EXIT) {
33564:         if (++exit->hitcount >= MAX_RECURSIVE_UNLINK_HITS) {
33564:             Blacklist((jsbytecode*)from->ip);
33564:             TrashTree(cx, from);
33564:             return false;
33564:         }
33564:         if (exit->recursive_pc != cx->fp->regs->pc)
33564:             return false;
36361:         from = LookupLoop(tm, exit->recursive_pc, globalObj, globalShape, cx->fp->argc);
33569:         if (!from)
33569:             return false;
33564:         /* use stale TI for RecordTree - since from might not have one anymore. */
33564:     }
33564: 
33564:     JS_ASSERT(from == from->root);
33564: 
33564:     /* If this tree has been blacklisted, don't try to record a new one. */
33564:     if (*(jsbytecode*)from->ip == JSOP_NOP)
33564:         return false;
33564: 
40226:     return RecordTree(cx, from->first, outer, outerArgc, globalSlots, Record_Branch);
21433: }
21433: 
35083: static JS_REQUIRES_STACK VMFragment*
35083: CreateBranchFragment(JSContext* cx, TreeFragment* root, VMSideExit* anchor)
35083: {
37741:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
35083: 
35083:     verbose_only(
37741:     uint32_t profFragID = (LogController.lcbits & LC_FragProfile)
35083:                           ? (++(tm->lastFragID)) : 0;
35083:     )
35083: 
35083:     VMFragment* f = new (*tm->dataAlloc) VMFragment(cx->fp->regs->pc verbose_only(, profFragID));
35083: 
35083:     debug_only_printf(LC_TMTreeVis, "TREEVIS CREATEBRANCH ROOT=%p FRAG=%p PC=%p FILE=\"%s\""
35083:                       " LINE=%d ANCHOR=%p OFFS=%d\n",
35083:                       (void*)root, (void*)f, (void*)cx->fp->regs->pc, cx->fp->script->filename,
35083:                       js_FramePCToLineNumber(cx, cx->fp), (void*)anchor,
35083:                       FramePCOffset(cx->fp));
35083:     verbose_only( tm->branches = new (*tm->dataAlloc) Seq<Fragment*>(f, tm->branches); )
35083: 
35083:     f->root = root;
35083:     if (anchor)
35083:         anchor->target = f;
35083:     return f;
35083: }
35083: 
22652: static JS_REQUIRES_STACK bool
30860: AttemptToExtendTree(JSContext* cx, VMSideExit* anchor, VMSideExit* exitedFrom, jsbytecode* outer
29368: #ifdef MOZ_TRACEVIS
29368:     , TraceVisStateObj* tvso = NULL
29368: #endif
29368:     )
18620: {
37741:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
35083:     JS_ASSERT(!tm->recorder);
35083: 
28308:     if (tm->needFlush) {
32748:         ResetJIT(cx, FR_DEEP_BAIL);
29368: #ifdef MOZ_TRACEVIS
29368:         if (tvso) tvso->r = R_FAIL_EXTEND_FLUSH;
29368: #endif
28308:         return false;
28308:     }
28308: 
35044:     TreeFragment* f = anchor->root();
36361:     JS_ASSERT(f->code());
18781: 
30860:     /*
30860:      * Don't grow trees above a certain size to avoid code explosion due to
30860:      * tail duplication.
30860:      */
35044:     if (f->branchCount >= MAX_BRANCHES) {
29368: #ifdef MOZ_TRACEVIS
29368:         if (tvso) tvso->r = R_FAIL_EXTEND_MAX_BRANCHES;
29368: #endif
18781:         return false;
29368:     }
17939: 
35083:     VMFragment* c = (VMFragment*)anchor->target;
35083:     if (!c) {
35083:         c = CreateBranchFragment(cx, f, anchor);
35083:     } else {
27290:         /*
30860:          * If we are recycling a fragment, it might have a different ip so reset it
30860:          * here. This can happen when attaching a branch to a NESTED_EXIT, which
30860:          * might extend along separate paths (i.e. after the loop edge, and after a
30860:          * return statement).
27290:          */
27290:         c->ip = cx->fp->regs->pc;
35083:         JS_ASSERT(c->root == f);
35083:     }
27290: 
29883:     debug_only_printf(LC_TMTracer,
29883:                       "trying to attach another branch to the tree (hits = %d)\n", c->hits());
25627: 
25627:     int32_t& hits = c->hits();
36395:     int32_t maxHits = HOTEXIT + MAXEXIT;
36395:     if (anchor->exitType == CASE_EXIT)
36395:         maxHits *= anchor->switchInfo->count;
36395:     if (outer || (hits++ >= HOTEXIT && hits <= maxHits)) {
17939:         /* start tracing secondary trace from this point */
24246:         unsigned stackSlots;
18621:         unsigned ngslots;
37741:         TraceType* typeMap;
31920:         TypeMap fullMap(NULL);
35044:         if (!exitedFrom) {
30860:             /*
30860:              * If we are coming straight from a simple side exit, just use that
30860:              * exit's type map as starting point.
30860:              */
20931:             ngslots = anchor->numGlobalSlots;
24246:             stackSlots = anchor->numStackSlots;
31495:             typeMap = anchor->fullTypeMap();
18621:         } else {
30860:             /*
30860:              * If we side-exited on a loop exit and continue on a nesting
30860:              * guard, the nesting guard (anchor) has the type information for
30860:              * everything below the current scope, and the actual guard we
30860:              * exited from has the types for everything in the current scope
30860:              * (and whatever it inlined). We have to merge those maps here.
30860:              */
21521:             VMSideExit* e1 = anchor;
21521:             VMSideExit* e2 = exitedFrom;
31495:             fullMap.add(e1->stackTypeMap(), e1->numStackSlotsBelowCurrentFrame);
31495:             fullMap.add(e2->stackTypeMap(), e2->numStackSlots);
24246:             stackSlots = fullMap.length();
31913:             ngslots = BuildGlobalTypeMapFromInnerTree(fullMap, e2);
31913:             JS_ASSERT(ngslots >= e1->numGlobalSlots); // inner tree must have all globals
31913:             JS_ASSERT(ngslots == fullMap.length() - stackSlots);
24246:             typeMap = fullMap.data();
24246:         }
28960:         JS_ASSERT(ngslots >= anchor->numGlobalSlots);
36361:         bool rv = TraceRecorder::startRecorder(cx, anchor, c, stackSlots, ngslots, typeMap,
36361:                                                exitedFrom, outer, cx->fp->argc, Record_Branch);
29368: #ifdef MOZ_TRACEVIS
29368:         if (!rv && tvso)
29368:             tvso->r = R_FAIL_EXTEND_START;
29368: #endif
29368:         return rv;
29368:     }
29368: #ifdef MOZ_TRACEVIS
29368:     if (tvso) tvso->r = R_FAIL_EXTEND_COLD;
29368: #endif
17939:     return false;
17939: }
17939: 
22652: static JS_REQUIRES_STACK VMSideExit*
35044: ExecuteTree(JSContext* cx, TreeFragment* f, uintN& inlineCallCount,
21521:             VMSideExit** innermostNestedGuardp);
17951: 
34351: JS_REQUIRES_STACK bool
34351: TraceRecorder::recordLoopEdge(JSContext* cx, TraceRecorder* r, uintN& inlineCallCount)
17939: {
17939: #ifdef JS_THREADSAFE
40424:     if (OBJ_SCOPE(cx->fp->scopeChain->getGlobal())->title.ownercx != cx) {
37741:         AbortRecording(cx, "Global object not owned by this context");
17939:         return false; /* we stay away from shared global objects */
17939:     }
17939: #endif
26557: 
37741:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
26557: 
27493:     /* Process needFlush and deep abort requests. */
27493:     if (tm->needFlush) {
32748:         ResetJIT(cx, FR_DEEP_BAIL);
27493:         return false;
27493:     }
26557: 
34351:     JS_ASSERT(r->fragment && !r->fragment->lastIns);
35044:     TreeFragment* root = r->fragment->root;
35044:     TreeFragment* first = LookupOrAddLoop(tm, cx->fp->regs->pc, root->globalObj,
33748:                                         root->globalShape, cx->fp->argc);
21514: 
30860:     /*
30860:      * Make sure the shape of the global object still matches (this might flush
30860:      * the JIT cache).
30860:      */
40424:     JSObject* globalObj = cx->fp->scopeChain->getGlobal();
24491:     uint32 globalShape = -1;
24491:     SlotList* globalSlots = NULL;
33748:     if (!CheckGlobalObjectShape(cx, tm, globalObj, &globalShape, &globalSlots)) {
33748:         JS_ASSERT(!tm->recorder);
33748:         return false;
33748:     }
21433: 
29883:     debug_only_printf(LC_TMTracer,
29883:                       "Looking for type-compatible peer (%s:%d@%d)\n",
21433:                       cx->fp->script->filename,
21685:                       js_FramePCToLineNumber(cx, cx->fp),
29883:                       FramePCOffset(cx->fp));
21433: 
28239:     // Find a matching inner tree. If none can be found, compile one.
35044:     TreeFragment* f = r->findNestedCompatiblePeer(first);
28239:     if (!f || !f->code()) {
21433:         AUDIT(noCompatInnerTrees);
25937: 
35083:         TreeFragment* outerFragment = root;
28244:         jsbytecode* outer = (jsbytecode*) outerFragment->ip;
28244:         uint32 outerArgc = outerFragment->argc;
40226:         JS_ASSERT(cx->fp->argc == first->argc);
37741:         AbortRecording(cx, "No compatible inner tree");
25627: 
40226:         return RecordTree(cx, first, outer, outerArgc, globalSlots, Record_Branch);
33564:     }
33564: 
33564:     return r->attemptTreeCall(f, inlineCallCount) == ARECORD_CONTINUE;
33564: }
33564: 
33564: JS_REQUIRES_STACK AbortableRecordingStatus
35044: TraceRecorder::attemptTreeCall(TreeFragment* f, uintN& inlineCallCount)
33564: {
33564:     /*
33564:      * It is absolutely forbidden to have recursive loops tree call themselves
33564:      * because it could accidentally pop frames owned by the parent call, and
33564:      * there is no way to deal with this yet. We could have to set a "start of
33564:      * poppable rp stack" variable, and if that unequals "real start of rp stack",
33564:      * it would be illegal to pop frames.
33564:      * --
33564:      * In the interim, just do tree calls knowing that they won't go into
33564:      * recursive trees that can pop parent frames.
33564:      */
36361:     if (f->script == cx->fp->script) {
36361:         if (f->recursion >= Recursion_Unwinds) {
33564:             Blacklist(cx->fp->script->code);
37741:             AbortRecording(cx, "Inner tree is an unsupported type of recursion");
33564:             return ARECORD_ABORTED;
39911:         }
36361:         f->recursion = Recursion_Disallowed;
33564:     }
33564: 
33564:     adjustCallerTypes(f);
39937:     prepareTreeCall(f);
33564: 
33564: #ifdef DEBUG
33564:     unsigned oldInlineCallCount = inlineCallCount;
33564: #endif
33171: 
33599:     JSContext *localCx = cx;
33599: 
37009:     // Refresh the import type map so the tracker can reimport values after the
37009:     // call with their correct types. The inner tree must not change the type of
37009:     // any variable in a frame above the current one (i.e., upvars).
37009:     //
37009:     // Note that DetermineTypesVisitor may call determineSlotType, which may
37009:     // read from the (current, stale) import type map, but this is safe here.
37009:     // The reason is that determineSlotType will read the import type map only
37009:     // if there is not a tracker instruction for that value, which means that
37009:     // value has not been written yet, so that type map entry is up to date.
37009:     importTypeMap.setLength(NativeStackSlots(cx, callDepth));
37009:     DetermineTypesVisitor visitor(*this, importTypeMap.data());
37009:     VisitStackSlots(visitor, cx, callDepth);
37009: 
21521:     VMSideExit* innermostNestedGuard = NULL;
30860:     VMSideExit* lr = ExecuteTree(cx, f, inlineCallCount, &innermostNestedGuard);
33171: 
33171:     /* ExecuteTree can reenter the interpreter and kill |this|. */
33599:     if (!TRACE_RECORDER(localCx))
33564:         return ARECORD_ABORTED;
33171: 
33171:     if (!lr) {
37741:         AbortRecording(cx, "Couldn't call inner tree");
33564:         return ARECORD_ABORTED;
33564:     }
33564: 
40251:     TreeFragment* outerFragment = tree;
28244:     jsbytecode* outer = (jsbytecode*) outerFragment->ip;
20931:     switch (lr->exitType) {
33564:       case RECURSIVE_LOOP_EXIT:
18051:       case LOOP_EXIT:
18284:         /* If the inner tree exited on an unknown loop exit, grow the tree around it. */
18284:         if (innermostNestedGuard) {
37741:             AbortRecording(cx, "Inner tree took different side exit, abort current "
25937:                               "recording and grow nesting tree");
33599:             return AttemptToExtendTree(localCx, innermostNestedGuard, lr, outer) ?
33564:                 ARECORD_CONTINUE : ARECORD_ABORTED;
33564:         }
33564: 
33564:         JS_ASSERT(oldInlineCallCount == inlineCallCount);
30860: 
30860:         /* Emit a call to the inner tree and continue recording the outer tree trace. */
39937:         emitTreeCall(f, lr);
33564:         return ARECORD_CONTINUE;
30860: 
21433:       case UNSTABLE_LOOP_EXIT:
33564:       {
30860:         /* Abort recording so the inner loop can become type stable. */
33564:         JSObject* _globalObj = globalObj;
37741:         AbortRecording(cx, "Inner tree is trying to stabilize, abort outer recording");
33599:         return AttemptToStabilizeTree(localCx, _globalObj, lr, outer, outerFragment->argc) ?
33564:             ARECORD_CONTINUE : ARECORD_ABORTED;
33564:       }
30860: 
29354:       case OVERFLOW_EXIT:
29354:         oracle.markInstructionUndemotable(cx->fp->regs->pc);
30860:         /* FALL THROUGH */
33564:       case RECURSIVE_SLURP_FAIL_EXIT:
33564:       case RECURSIVE_SLURP_MISMATCH_EXIT:
33564:       case RECURSIVE_MISMATCH_EXIT:
33564:       case RECURSIVE_EMPTY_RP_EXIT:
18051:       case BRANCH_EXIT:
33564:       case CASE_EXIT: {
30860:           /* Abort recording the outer tree, extend the inner tree. */
37741:           AbortRecording(cx, "Inner tree is trying to grow, abort outer recording");
33599:           return AttemptToExtendTree(localCx, lr, NULL, outer) ? ARECORD_CONTINUE : ARECORD_ABORTED;
33564:       }
30860: 
35083:       case NESTED_EXIT:
35083:           JS_NOT_REACHED("NESTED_EXIT should be replaced by innermost side exit");
18051:       default:
29894:         debug_only_printf(LC_TMTracer, "exit_type=%s\n", getExitName(lr->exitType));
37741:         AbortRecording(cx, "Inner tree not suitable for calling");
33564:         return ARECORD_ABORTED;
18051:     }
17988: }
21433: 
21433: static bool
37741: IsEntryTypeCompatible(jsval* vp, TraceType* m)
21433: {
21433:     unsigned tag = JSVAL_TAG(*vp);
21433: 
29883:     debug_only_printf(LC_TMTracer, "%c/%c ", tagChar[tag], typeChar[*m]);
21433: 
21433:     switch (*m) {
29896:       case TT_OBJECT:
27542:         if (tag == JSVAL_OBJECT && !JSVAL_IS_NULL(*vp) &&
40430:             !JSVAL_TO_OBJECT(*vp)->isFunction()) {
27542:             return true;
27542:         }
29883:         debug_only_printf(LC_TMTracer, "object != tag%u ", tag);
27542:         return false;
29896:       case TT_INT32:
21433:         jsint i;
21433:         if (JSVAL_IS_INT(*vp))
21433:             return true;
29896:         if (tag == JSVAL_DOUBLE && JSDOUBLE_IS_INT(*JSVAL_TO_DOUBLE(*vp), i))
21433:             return true;
29883:         debug_only_printf(LC_TMTracer, "int != tag%u(value=%lu) ", tag, (unsigned long)*vp);
21433:         return false;
29896:       case TT_DOUBLE:
21433:         if (JSVAL_IS_INT(*vp) || tag == JSVAL_DOUBLE)
21433:             return true;
29883:         debug_only_printf(LC_TMTracer, "double != tag%u ", tag);
21433:         return false;
29896:       case TT_JSVAL:
29896:         JS_NOT_REACHED("shouldn't see jsval type in entry");
27541:         return false;
29896:       case TT_STRING:
27542:         if (tag == JSVAL_STRING)
27542:             return true;
29883:         debug_only_printf(LC_TMTracer, "string != tag%u ", tag);
27542:         return false;
29896:       case TT_NULL:
27542:         if (JSVAL_IS_NULL(*vp))
27542:             return true;
29883:         debug_only_printf(LC_TMTracer, "null != tag%u ", tag);
27542:         return false;
40307:       case TT_SPECIAL:
40307:         /* N.B. void is JSVAL_SPECIAL. */
40307:         if (JSVAL_IS_SPECIAL(*vp) && !JSVAL_IS_VOID(*vp))
21433:             return true;
29883:         debug_only_printf(LC_TMTracer, "bool != tag%u ", tag);
21433:         return false;
40307:       case TT_VOID:
40307:         if (JSVAL_IS_VOID(*vp))
40307:             return true;
40307:         debug_only_printf(LC_TMTracer, "undefined != tag%u ", tag);
40307:         return false;
27542:       default:
29896:         JS_ASSERT(*m == TT_FUNCTION);
27541:         if (tag == JSVAL_OBJECT && !JSVAL_IS_NULL(*vp) &&
40430:             JSVAL_TO_OBJECT(*vp)->isFunction()) {
27541:             return true;
27541:         }
29883:         debug_only_printf(LC_TMTracer, "fun != tag%u ", tag);
27541:         return false;
21433:     }
21433: }
21433: 
29882: class TypeCompatibilityVisitor : public SlotVisitorBase
29882: {
29880:     TraceRecorder &mRecorder;
29880:     JSContext *mCx;
37741:     TraceType *mTypeMap;
29880:     unsigned mStackSlotNum;
29880:     bool mOk;
29880: public:
29880:     TypeCompatibilityVisitor (TraceRecorder &recorder,
37741:                               TraceType *typeMap) :
29880:         mRecorder(recorder),
29880:         mCx(mRecorder.cx),
29880:         mTypeMap(typeMap),
29880:         mStackSlotNum(0),
29880:         mOk(true)
29880:     {}
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29880:     visitGlobalSlot(jsval *vp, unsigned n, unsigned slot) {
29883:         debug_only_printf(LC_TMTracer, "global%d=", n);
30860:         if (!IsEntryTypeCompatible(vp, mTypeMap)) {
29880:             mOk = false;
29896:         } else if (!isPromoteInt(mRecorder.get(vp)) && *mTypeMap == TT_INT32) {
29880:             oracle.markGlobalSlotUndemotable(mCx, slot);
29880:             mOk = false;
29896:         } else if (JSVAL_IS_INT(*vp) && *mTypeMap == TT_DOUBLE) {
29880:             oracle.markGlobalSlotUndemotable(mCx, slot);
29880:         }
29880:         mTypeMap++;
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp) {
29880:         for (size_t i = 0; i < count; ++i) {
29883:             debug_only_printf(LC_TMTracer, "%s%u=", stackSlotKind(), unsigned(i));
30860:             if (!IsEntryTypeCompatible(vp, mTypeMap)) {
29880:                 mOk = false;
29896:             } else if (!isPromoteInt(mRecorder.get(vp)) && *mTypeMap == TT_INT32) {
29880:                 oracle.markStackSlotUndemotable(mCx, mStackSlotNum);
29880:                 mOk = false;
29896:             } else if (JSVAL_IS_INT(*vp) && *mTypeMap == TT_DOUBLE) {
29880:                 oracle.markStackSlotUndemotable(mCx, mStackSlotNum);
29880:             }
29880:             vp++;
29880:             mTypeMap++;
29880:             mStackSlotNum++;
29880:         }
29880:         return true;
29880:     }
29880: 
29880:     bool isOk() {
29880:         return mOk;
29880:     }
29880: };
29880: 
35044: JS_REQUIRES_STACK TreeFragment*
35044: TraceRecorder::findNestedCompatiblePeer(TreeFragment* f)
28239: {
37741:     TraceMonitor* tm;
21433: 
21433:     tm = &JS_TRACE_MONITOR(cx);
36361:     unsigned int ngslots = tree->globalSlots->length();
36361: 
35044:     for (; f != NULL; f = f->peer) {
28239:         if (!f->code())
21433:             continue;
28239: 
29883:         debug_only_printf(LC_TMTracer, "checking nested types %p: ", (void*)f);
21433: 
36361:         if (ngslots > f->nGlobalTypes())
36361:             SpecializeTreesToMissingGlobals(cx, globalObj, f);
30860: 
30860:         /*
30860:          * Determine whether the typemap of the inner tree matches the outer
30860:          * tree's current state. If the inner tree expects an integer, but the
30860:          * outer tree doesn't guarantee an integer for that slot, we mark the
30860:          * slot undemotable and mismatch here. This will force a new tree to be
30860:          * compiled that accepts a double for the slot. If the inner tree
30860:          * expects a double, but the outer tree has an integer, we can proceed,
30860:          * but we mark the location undemotable.
28239:          */
36361:         TypeCompatibilityVisitor visitor(*this, f->typeMap.data());
36361:         VisitSlots(visitor, cx, 0, *tree->globalSlots);
29880: 
29883:         debug_only_printf(LC_TMTracer, " %s\n", visitor.isOk() ? "match" : "");
29880:         if (visitor.isOk())
21433:             return f;
21433:     }
21433: 
21433:     return NULL;
21433: }
21433: 
29882: class CheckEntryTypeVisitor : public SlotVisitorBase
29882: {
29880:     bool mOk;
37741:     TraceType *mTypeMap;
29880: public:
37741:     CheckEntryTypeVisitor(TraceType *typeMap) :
29880:         mOk(true),
29880:         mTypeMap(typeMap)
29880:     {}
29880: 
29880:     JS_ALWAYS_INLINE void checkSlot(jsval *vp, char const *name, int i) {
29883:         debug_only_printf(LC_TMTracer, "%s%d=", name, i);
29896:         JS_ASSERT(*(uint8_t*)mTypeMap != 0xCD);
30860:         mOk = IsEntryTypeCompatible(vp, mTypeMap++);
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE void
29880:     visitGlobalSlot(jsval *vp, unsigned n, unsigned slot) {
29880:         if (mOk)
29880:             checkSlot(vp, "global", n);
29880:     }
29880: 
29880:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
29880:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp) {
29880:         for (size_t i = 0; i < count; ++i) {
29880:             if (!mOk)
29880:                 break;
29882:             checkSlot(vp++, stackSlotKind(), i);
29880:         }
29880:         return mOk;
29880:     }
29880: 
29880:     bool isOk() {
29880:         return mOk;
29880:     }
29880: };
29880: 
21433: /**
21433:  * Check if types are usable for trace execution.
21433:  *
21433:  * @param cx            Context.
36361:  * @param f             Tree of peer we're testing.
21433:  * @return              True if compatible (with or without demotions), false otherwise.
21433:  */
22652: static JS_REQUIRES_STACK bool
36361: CheckEntryTypes(JSContext* cx, JSObject* globalObj, TreeFragment* f)
36361: {
36361:     unsigned int ngslots = f->globalSlots->length();
36361: 
36361:     JS_ASSERT(f->nStackTypes == NativeStackSlots(cx, 0));
36361: 
36361:     if (ngslots > f->nGlobalTypes())
36361:         SpecializeTreesToMissingGlobals(cx, globalObj, f);
36361: 
36361:     JS_ASSERT(f->typeMap.length() == NativeStackSlots(cx, 0) + ngslots);
36361:     JS_ASSERT(f->typeMap.length() == f->nStackTypes + ngslots);
36361:     JS_ASSERT(f->nGlobalTypes() == ngslots);
36361: 
36361:     CheckEntryTypeVisitor visitor(f->typeMap.data());
36361:     VisitSlots(visitor, cx, 0, *f->globalSlots);
21433: 
29883:     debug_only_print0(LC_TMTracer, "\n");
29880:     return visitor.isOk();
21433: }
21433: 
21433: /**
21433:  * Find an acceptable entry tree given a PC.
21433:  *
21433:  * @param cx            Context.
29880:  * @param globalObj     Global object.
21433:  * @param f             First peer fragment.
21433:  * @param nodemote      If true, will try to find a peer that does not require demotion.
25627:  * @out   count         Number of fragments consulted.
21433:  */
35044: static JS_REQUIRES_STACK TreeFragment*
35044: FindVMCompatiblePeer(JSContext* cx, JSObject* globalObj, TreeFragment* f, uintN& count)
25627: {
25627:     count = 0;
21433:     for (; f != NULL; f = f->peer) {
36361:         if (!f->code())
21433:             continue;
29883:         debug_only_printf(LC_TMTracer,
29883:                           "checking vm types %p (ip: %p): ", (void*)f, f->ip);
36361:         if (CheckEntryTypes(cx, globalObj, f))
21433:             return f;
25627:         ++count;
21433:     }
21433:     return NULL;
21433: }
21433: 
35083: /*
35083:  * For the native stacks and global frame, reuse the storage in |tm->storage|.
35083:  * This reuse depends on the invariant that only one trace uses |tm->storage| at
35083:  * a time. This is subtley correct in lieu of deep bail; see comment for
37741:  * |deepBailSp| in DeepBail.
35083:  */
35083: JS_ALWAYS_INLINE
37741: InterpState::InterpState(JSContext* cx, TraceMonitor* tm, TreeFragment* f,
35083:                          uintN& inlineCallCount, VMSideExit** innermostNestedGuardp)
35083:   : cx(cx),
37037:     stackBase(tm->storage->stack()),
36361:     sp(stackBase + f->nativeStackBase / sizeof(double)),
37037:     eos(tm->storage->global()),
37037:     callstackBase(tm->storage->callstack()),
35083:     sor(callstackBase),
35083:     rp(callstackBase),
35083:     eor(callstackBase + JS_MIN(MAX_CALL_STACK_ENTRIES,
35083:                                JS_MAX_INLINE_CALL_COUNT - inlineCallCount)),
35083:     lastTreeExitGuard(NULL),
35083:     lastTreeCallGuard(NULL),
35083:     rpAtLastTreeCall(NULL),
36361:     outermostTree(f),
35083:     inlineCallCountp(&inlineCallCount),
35083:     innermostNestedGuardp(innermostNestedGuardp),
35083: #ifdef EXECUTE_TREE_TIMER
35083:     startTime(rdtsc()),
35083: #endif
35083:     builtinStatus(0),
35083:     nativeVp(NULL)
35083: {
35083:     JS_ASSERT(!tm->tracecx);
35083:     tm->tracecx = cx;
35083:     prev = cx->interpState;
35083:     cx->interpState = this;
35083: 
35083:     JS_ASSERT(eos == stackBase + MAX_NATIVE_STACK_SLOTS);
35083:     JS_ASSERT(sp < eos);
35083: 
35083:     /*
35083:      * inlineCallCount has already been incremented, if being invoked from
35083:      * EnterFrame. It is okay to have a 0-frame restriction since the JIT
35083:      * might not need any frames.
35083:      */
35083:     JS_ASSERT(inlineCallCount <= JS_MAX_INLINE_CALL_COUNT);
35083: 
35083: #ifdef DEBUG
35083:     /*
35083:      * Cannot 0xCD-fill global frame since it may overwrite a bailed outer
35083:      * ExecuteTree's 0xdeadbeefdeadbeef marker.
35083:      */
37037:     memset(tm->storage->stack(), 0xCD, MAX_NATIVE_STACK_SLOTS * sizeof(double));
37037:     memset(tm->storage->callstack(), 0xCD, MAX_CALL_STACK_ENTRIES * sizeof(FrameInfo*));
35083: #endif
35083: }
35083: 
35083: JS_ALWAYS_INLINE
35083: InterpState::~InterpState()
35083: {
35083:     JS_ASSERT(!nativeVp);
35083: 
35083:     cx->interpState = prev;
35083:     JS_TRACE_MONITOR(cx).tracecx = NULL;
35083: }
35083: 
35083: /* Call |f|, return the exit taken. */
35083: static JS_ALWAYS_INLINE VMSideExit*
35083: ExecuteTrace(JSContext* cx, Fragment* f, InterpState& state)
35083: {
35083:     JS_ASSERT(!cx->bailExit);
35343:     union { NIns *code; GuardRecord* (FASTCALL *func)(InterpState*); } u;
35083:     u.code = f->code();
35083:     GuardRecord* rec;
35083: #if defined(JS_NO_FASTCALL) && defined(NANOJIT_IA32)
35083:     SIMULATE_FASTCALL(rec, state, NULL, u.func);
35083: #else
35343:     rec = u.func(&state);
35083: #endif
35083:     JS_ASSERT(!cx->bailExit);
35083:     return (VMSideExit*)rec->exit;
35083: }
35083: 
35083: /* Check whether our assumptions about the incoming scope-chain are upheld. */
35084: static JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
36361: ScopeChainCheck(JSContext* cx, TreeFragment* f)
36361: {
40424:     JS_ASSERT(f->globalObj == cx->fp->scopeChain->getGlobal());
21433: 
31467:     /*
31467:      * The JIT records and expects to execute with two scope-chain
31467:      * assumptions baked-in:
31467:      *
31467:      *   1. That the bottom of the scope chain is global, in the sense of
31467:      *      JSCLASS_IS_GLOBAL.
31467:      *
31467:      *   2. That the scope chain between fp and the global is free of
31467:      *      "unusual" native objects such as HTML forms or other funny
31467:      *      things.
31467:      *
31467:      * #2 is checked here while following the scope-chain links, via
31467:      * js_IsCacheableNonGlobalScope, which consults a whitelist of known
31467:      * class types; once a global is found, it's checked for #1. Failing
31467:      * either check causes an early return from execution.
31467:      */
31467:     JSObject* child = cx->fp->scopeChain;
39930:     while (JSObject* parent = child->getParent()) {
31467:         if (!js_IsCacheableNonGlobalScope(child)) {
31467:             debug_only_print0(LC_TMTracer,"Blacklist: non-cacheable object on scope chain.\n");
31467:             Blacklist((jsbytecode*) f->root->ip);
35083:             return false;
31467:         }
31467:         child = parent;
31467:     }
35083:     JS_ASSERT(child == f->globalObj);
35083: 
35083:     if (!(OBJ_GET_CLASS(cx, f->globalObj)->flags & JSCLASS_IS_GLOBAL)) {
31467:         debug_only_print0(LC_TMTracer, "Blacklist: non-global at root of scope chain.\n");
31467:         Blacklist((jsbytecode*) f->root->ip);
35083:         return false;
35083:     }
35083: 
35083:     /* Make sure the global object is sane. */
40410:     JS_ASSERT(f->globalObj->numSlots() <= MAX_GLOBAL_SLOTS);
36361:     JS_ASSERT(f->nGlobalTypes() == f->globalSlots->length());
36361:     JS_ASSERT_IF(f->globalSlots->length() != 0,
35083:                  OBJ_SHAPE(f->globalObj) == f->globalShape);
35083:     return true;
35083: }
35083: 
35083: static void
37741: LeaveTree(TraceMonitor *tm, InterpState&, VMSideExit* lr);
35083: 
35083: static JS_REQUIRES_STACK VMSideExit*
35083: ExecuteTree(JSContext* cx, TreeFragment* f, uintN& inlineCallCount,
35083:             VMSideExit** innermostNestedGuardp)
35083: {
35083: #ifdef MOZ_TRACEVIS
35083:     TraceVisStateObj tvso(cx, S_EXECUTE);
35083: #endif
36361:     JS_ASSERT(f->root == f && f->code());
37741:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
36361: 
36361:     if (!ScopeChainCheck(cx, f))
31467:         return NULL;
35083: 
35083:     /* Initialize trace state. */
36361:     InterpState state(cx, tm, f, inlineCallCount, innermostNestedGuardp);
37037:     double* stack = tm->storage->stack();
37037:     double* global = tm->storage->global();
35083:     JSObject* globalObj = f->globalObj;
36361:     unsigned ngslots = f->globalSlots->length();
36361:     uint16* gslots = f->globalSlots->data();
35083: 
35083:     BuildNativeFrame(cx, globalObj, 0 /* callDepth */, ngslots, gslots,
36361:                      f->typeMap.data(), global, stack);
35083: 
35083:     AUDIT(traceTriggered);
29883:     debug_only_printf(LC_TMTracer,
29883:                       "entering trace at %s:%u@%u, native stack slots: %u code: %p\n",
18260:                       cx->fp->script->filename,
21685:                       js_FramePCToLineNumber(cx, cx->fp),
21685:                       FramePCOffset(cx->fp),
36361:                       f->maxNativeStackSlots,
29883:                       f->code());
18210: 
40410:     debug_only_stmt(uint32 globalSlots = globalObj->numSlots();)
37037:     debug_only_stmt(*(uint64*)&tm->storage->global()[globalSlots] = 0xdeadbeefdeadbeefLL;)
35083: 
35083:     /* Execute trace. */
29368: #ifdef MOZ_TRACEVIS
35083:     VMSideExit* lr = (TraceVisStateObj(cx, S_NATIVE), ExecuteTrace(cx, f, state));
18723: #else
35083:     VMSideExit* lr = ExecuteTrace(cx, f, state);
35083: #endif
35083: 
37037:     JS_ASSERT(*(uint64*)&tm->storage->global()[globalSlots] == 0xdeadbeefdeadbeefLL);
35083:     JS_ASSERT_IF(lr->exitType == LOOP_EXIT, !lr->calldepth);
35083: 
35083:     /* Restore interpreter state. */
37694:     LeaveTree(tm, state, lr);
34572:     return state.innermost;
24612: }
24612: 
35078: class Guardian {
35078:     bool *flagp;
35078: public:
35078:     Guardian(bool *flagp) {
35078:         this->flagp = flagp;
35078:         JS_ASSERT(!*flagp);
35078:         *flagp = true;
35078:     }
35078: 
35078:     ~Guardian() {
35078:         JS_ASSERT(*flagp);
35078:         *flagp = false;
35078:     }
35078: };
35078: 
24612: static JS_FORCES_STACK void
37741: LeaveTree(TraceMonitor *tm, InterpState& state, VMSideExit* lr)
24612: {
24612:     VOUCH_DOES_NOT_REQUIRE_STACK();
24612: 
24612:     JSContext* cx = state.cx;
35078: 
35078:     /* Temporary waive the soft GC quota to make sure LeaveTree() doesn't fail. */
35078:     Guardian waiver(&JS_THREAD_DATA(cx)->waiveGCQuota);
35078: 
24612:     FrameInfo** callstack = state.callstackBase;
24612:     double* stack = state.stackBase;
17923: 
30860:     /*
30860:      * Except if we find that this is a nested bailout, the guard the call
30860:      * returned is the one we have to use to adjust pc and sp.
30860:      */
21521:     VMSideExit* innermost = lr;
20429: 
30860:     /*
30860:      * While executing a tree we do not update state.sp and state.rp even if
30860:      * they grow. Instead, guards tell us by how much sp and rp should be
30860:      * incremented in case of a side exit. When calling a nested tree, however,
30860:      * we actively adjust sp and rp. If we have such frames from outer trees on
30860:      * the stack, then rp will have been adjusted. Before we can process the
30860:      * stack of the frames of the tree we directly exited from, we have to
30860:      * first work our way through the outer frames and generate interpreter
30860:      * frames for them. Once the call stack (rp) is empty, we can process the
30860:      * final frames (which again are not directly visible and only the guard we
30860:      * exited on will tells us about).
30860:      */
23262:     FrameInfo** rp = (FrameInfo**)state.rp;
20931:     if (lr->exitType == NESTED_EXIT) {
21521:         VMSideExit* nested = state.lastTreeCallGuard;
20429:         if (!nested) {
30860:             /*
30860:              * If lastTreeCallGuard is not set in state, we only have a single
30860:              * level of nesting in this exit, so lr itself is the innermost and
30860:              * outermost nested guard, and hence we set nested to lr. The
30860:              * calldepth of the innermost guard is not added to state.rp, so we
30860:              * do it here manually. For a nesting depth greater than 1 the
35344:              * call tree code already added the innermost guard's calldepth
30860:              * to state.rpAtLastTreeCall.
30860:              */
20429:             nested = lr;
20429:             rp += lr->calldepth;
20429:         } else {
30860:             /*
30860:              * During unwinding state.rp gets overwritten at every step and we
30860:              * restore it here to its state at the innermost nested guard. The
30860:              * builtin already added the calldepth of that innermost guard to
30860:              * rpAtLastTreeCall.
30860:              */
23262:             rp = (FrameInfo**)state.rpAtLastTreeCall;
20429:         }
20429:         innermost = state.lastTreeExitGuard;
24612:         if (state.innermostNestedGuardp)
24612:             *state.innermostNestedGuardp = nested;
20429:         JS_ASSERT(nested);
20931:         JS_ASSERT(nested->exitType == NESTED_EXIT);
20429:         JS_ASSERT(state.lastTreeExitGuard);
20931:         JS_ASSERT(state.lastTreeExitGuard->exitType != NESTED_EXIT);
19590:     }
21433: 
27166:     int32_t bs = state.builtinStatus;
37741:     bool bailed = innermost->exitType == STATUS_EXIT && (bs & BUILTIN_BAILED);
24870:     if (bailed) {
24612:         /*
24612:          * Deep-bail case.
24612:          *
24612:          * A _FAIL native already called LeaveTree. We already reconstructed
24612:          * the interpreter stack, in pre-call state, with pc pointing to the
24612:          * CALL/APPLY op, for correctness. Then we continued in native code.
28086:          *
28086:          * First, if we just returned from a slow native, pop its stack frame.
28086:          */
28086:         if (!cx->fp->script) {
28086:             JSStackFrame *fp = cx->fp;
31961:             JS_ASSERT(FUN_SLOW_NATIVE(fp->fun));
35044:             JS_ASSERT(!fp->regs);
28086:             JS_ASSERT(fp->down->regs != &((JSInlineFrame *) fp)->callerRegs);
28086:             cx->fp = fp->down;
28086:             JS_ARENA_RELEASE(&cx->stackPool, ((JSInlineFrame *) fp)->mark);
28086:         }
28086:         JS_ASSERT(cx->fp->script);
28086: 
37741:         if (!(bs & BUILTIN_ERROR)) {
24870:             /*
31444:              * The builtin or native deep-bailed but finished successfully
31444:              * (no exception or error).
31444:              *
31444:              * After it returned, the JIT code stored the results of the
31444:              * builtin or native at the top of the native stack and then
31444:              * immediately flunked the guard on state->builtinStatus.
24612:              *
24612:              * Now LeaveTree has been called again from the tail of
30860:              * ExecuteTree. We are about to return to the interpreter. Adjust
24612:              * the top stack frame to resume on the next op.
24612:              */
31444:             JSFrameRegs* regs = cx->fp->regs;
31444:             JSOp op = (JSOp) *regs->pc;
31444:             JS_ASSERT(op == JSOP_CALL || op == JSOP_APPLY || op == JSOP_NEW ||
32557:                       op == JSOP_GETPROP || op == JSOP_GETTHISPROP || op == JSOP_GETARGPROP ||
32557:                       op == JSOP_GETLOCALPROP || op == JSOP_LENGTH ||
37688:                       op == JSOP_GETELEM || op == JSOP_CALLELEM || op == JSOP_CALLPROP ||
32658:                       op == JSOP_SETPROP || op == JSOP_SETNAME || op == JSOP_SETMETHOD ||
35477:                       op == JSOP_SETELEM || op == JSOP_INITELEM || op == JSOP_ENUMELEM ||
31830:                       op == JSOP_INSTANCEOF);
34339: 
34339:             /*
34339:              * JSOP_SETELEM can be coalesced with a JSOP_POP in the interpeter.
34339:              * Since this doesn't re-enter the recorder, the post-state snapshot
34339:              * is invalid. Fix it up here.
34339:              */
34339:             if (op == JSOP_SETELEM && JSOp(regs->pc[JSOP_SETELEM_LENGTH]) == JSOP_POP) {
34339:                 regs->sp -= js_CodeSpec[JSOP_SETELEM].nuses;
34339:                 regs->sp += js_CodeSpec[JSOP_SETELEM].ndefs;
34339:                 regs->pc += JSOP_SETELEM_LENGTH;
34339:                 op = JSOP_POP;
34339:             }
34339: 
31444:             const JSCodeSpec& cs = js_CodeSpec[op];
31444:             regs->sp -= (cs.format & JOF_INVOKE) ? GET_ARGC(regs->pc) + 2 : cs.nuses;
31444:             regs->sp += cs.ndefs;
31444:             regs->pc += cs.length;
24612:             JS_ASSERT_IF(!cx->fp->imacpc,
24612:                          cx->fp->slots + cx->fp->script->nfixed +
31444:                          js_ReconstructStackDepth(cx, cx->fp->script, regs->pc) ==
31444:                          regs->sp);
30287: 
30287:             /*
30287:              * If there's a tree call around the point that we deep exited at,
30287:              * then state.sp and state.rp were restored to their original
30287:              * values before the tree call and sp might be less than deepBailSp,
30287:              * which we sampled when we were told to deep bail.
30287:              */
30287:             JS_ASSERT(state.deepBailSp >= state.stackBase && state.sp <= state.deepBailSp);
31444: 
31444:             /*
31444:              * As explained above, the JIT code stored a result value or values
31444:              * on the native stack. Transfer them to the interpreter stack now.
31444:              * (Some opcodes, like JSOP_CALLELEM, produce two values, hence the
31444:              * loop.)
31444:              */
37741:             TraceType* typeMap = innermost->stackTypeMap();
31444:             for (int i = 1; i <= cs.ndefs; i++) {
37741:                 if (!NativeToValue(cx,
31444:                                    regs->sp[-i],
31444:                                    typeMap[innermost->numStackSlots - i],
31444:                                    (jsdouble *) state.deepBailSp
35078:                                    + innermost->sp_adj / sizeof(jsdouble) - i)) {
35078:                     OutOfMemoryAbort();
35078:                 }
31444:             }
24870:         }
24612:         return;
24612:     }
24612: 
33564:     /* Save the innermost FrameInfo for guardUpRecursion */
33564:     if (innermost->exitType == RECURSIVE_MISMATCH_EXIT) {
33564:         /* There should never be a static calldepth for a recursive mismatch. */
33564:         JS_ASSERT(innermost->calldepth == 0);
33564:         /* There must be at least one item on the rp stack. */
33564:         JS_ASSERT(callstack < rp);
33564:         /* :TODO: don't be all squirrelin' this in here */
33564:         innermost->recursive_down = *(rp - 1);
33564:     }
33564: 
33564:     /* Slurp failure should have no frames */
33564:     JS_ASSERT_IF(innermost->exitType == RECURSIVE_SLURP_FAIL_EXIT,
33564:                  innermost->calldepth == 0 && callstack == rp);
33564: 
19588:     while (callstack < rp) {
31924:         FrameInfo* fi = *callstack;
31924:         /* Peek at the callee native slot in the not-yet-synthesized down frame. */
31924:         JSObject* callee = *(JSObject**)&stack[fi->callerHeight];
31924: 
30860:         /*
30860:          * Synthesize a stack frame and write out the values in it using the
30860:          * type map pointer on the native call stack.
30860:          */
31924:         SynthesizeFrame(cx, *fi, callee);
33563:         int slots = FlushNativeStackFrame(cx, 1 /* callDepth */, (*callstack)->get_typemap(),
33564:                                           stack, cx->fp, 0);
19588: #ifdef DEBUG
19588:         JSStackFrame* fp = cx->fp;
29883:         debug_only_printf(LC_TMTracer,
33564:                           "synthesized deep frame for %s:%u@%u, slots=%d, fi=%p\n",
21685:                           fp->script->filename,
21685:                           js_FramePCToLineNumber(cx, fp),
21685:                           FramePCOffset(fp),
33564:                           slots,
33567:                           (void*)*callstack);
19588: #endif
30860:         /*
30860:          * Keep track of the additional frames we put on the interpreter stack
30860:          * and the native stack slots we consumed.
30860:          */
24612:         ++*state.inlineCallCountp;
19588:         ++callstack;
18170:         stack += slots;
18164:     }
19588: 
30860:     /*
30860:      * We already synthesized the frames around the innermost guard. Here we
30860:      * just deal with additional frames inside the tree we are bailing out
30860:      * from.
30860:      */
19588:     JS_ASSERT(rp == callstack);
20429:     unsigned calldepth = innermost->calldepth;
18226:     unsigned calldepth_slots = 0;
31924:     unsigned calleeOffset = 0;
19588:     for (unsigned n = 0; n < calldepth; ++n) {
31924:         /* Peek at the callee native slot in the not-yet-synthesized down frame. */
31924:         calleeOffset += callstack[n]->callerHeight;
31924:         JSObject* callee = *(JSObject**)&stack[calleeOffset];
31924: 
31924:         /* Reconstruct the frame. */
31924:         calldepth_slots += SynthesizeFrame(cx, *callstack[n], callee);
24612:         ++*state.inlineCallCountp;
19588: #ifdef DEBUG
19588:         JSStackFrame* fp = cx->fp;
29883:         debug_only_printf(LC_TMTracer,
29883:                           "synthesized shallow frame for %s:%u@%u\n",
21685:                           fp->script->filename, js_FramePCToLineNumber(cx, fp),
29883:                           FramePCOffset(fp));
19588: #endif
19588:     }
17923: 
30860:     /*
30860:      * Adjust sp and pc relative to the tree we exited from (not the tree we
30860:      * entered into).  These are our final values for sp and pc since
30860:      * SynthesizeFrame has already taken care of all frames in between. But
30860:      * first we recover fp->blockChain, which comes from the side exit
30860:      * struct.
30860:      */
17923:     JSStackFrame* fp = cx->fp;
18226: 
22925:     fp->blockChain = innermost->block;
22925: 
30860:     /*
30860:      * If we are not exiting from an inlined frame, the state->sp is spbase.
30860:      * Otherwise spbase is whatever slots frames around us consume.
30860:      */
25111:     fp->regs->pc = innermost->pc;
25111:     fp->imacpc = innermost->imacpc;
20931:     fp->regs->sp = StackBase(fp) + (innermost->sp_adj / sizeof(double)) - calldepth_slots;
21685:     JS_ASSERT_IF(!fp->imacpc,
21685:                  fp->slots + fp->script->nfixed +
18772:                  js_ReconstructStackDepth(cx, fp->script, fp->regs->pc) == fp->regs->sp);
17923: 
24612: #ifdef EXECUTE_TREE_TIMER
24612:     uint64 cycles = rdtsc() - state.startTime;
21459: #elif defined(JS_JIT_SPEW)
19040:     uint64 cycles = 0;
18788: #endif
18788: 
29883:     debug_only_printf(LC_TMTracer,
33132:                       "leaving trace at %s:%u@%u, op=%s, lr=%p, exitType=%s, sp=%lld, "
19588:                       "calldepth=%d, cycles=%llu\n",
21685:                       fp->script->filename,
21685:                       js_FramePCToLineNumber(cx, fp),
21685:                       FramePCOffset(fp),
21685:                       js_CodeName[fp->imacpc ? *fp->imacpc : *fp->regs->pc],
25469:                       (void*)lr,
29894:                       getExitName(lr->exitType),
33132:                       (long long int)(fp->regs->sp - StackBase(fp)),
19588:                       calldepth,
33132:                       (unsigned long long int)cycles);
17923: 
30860:     /*
30860:      * If this trace is part of a tree, later branches might have added
30860:      * additional globals for which we don't have any type information
30860:      * available in the side exit. We merge in this information from the entry
30860:      * type-map. See also the comment in the constructor of TraceRecorder
30860:      * regarding why this is always safe to do.
30860:      */
36361:     TreeFragment* outermostTree = state.outermostTree;
24612:     uint16* gslots = outermostTree->globalSlots->data();
24612:     unsigned ngslots = outermostTree->globalSlots->length();
24612:     JS_ASSERT(ngslots == outermostTree->nGlobalTypes());
37741:     TraceType* globalTypeMap;
25491: 
30860:     /* Are there enough globals? */
37694:     TypeMap& typeMap = *tm->cachedTempTypeMap;
37694:     typeMap.clear();
25491:     if (innermost->numGlobalSlots == ngslots) {
30860:         /* Yes. This is the ideal fast path. */
31495:         globalTypeMap = innermost->globalTypeMap();
25491:     } else {
30860:         /*
30860:          * No. Merge the typemap of the innermost entry and exit together. This
30860:          * should always work because it is invalid for nested trees or linked
30860:          * trees to have incompatible types. Thus, whenever a new global type
30860:          * is lazily added into a tree, all dependent and linked trees are
30860:          * immediately specialized (see bug 476653).
30860:          */
36361:         JS_ASSERT(innermost->root()->nGlobalTypes() == ngslots);
36361:         JS_ASSERT(innermost->root()->nGlobalTypes() > innermost->numGlobalSlots);
31913:         typeMap.ensure(ngslots);
31913: #ifdef DEBUG
31913:         unsigned check_ngslots =
31913: #endif
31913:         BuildGlobalTypeMapFromInnerTree(typeMap, innermost);
31913:         JS_ASSERT(check_ngslots == ngslots);
31913:         globalTypeMap = typeMap.data();
25491:     }
18200: 
30860:     /* Write back the topmost native stack frame. */
33564:     unsigned ignoreSlots = innermost->exitType == RECURSIVE_SLURP_FAIL_EXIT ?
33564:                            innermost->numStackSlots - 1 : 0;
28654: #ifdef DEBUG
28654:     int slots =
28654: #endif
28656:         FlushNativeStackFrame(cx, innermost->calldepth,
31495:                               innermost->stackTypeMap(),
33564:                               stack, NULL, ignoreSlots);
28654:     JS_ASSERT(unsigned(slots) == innermost->numStackSlots);
28654: 
28654:     if (innermost->nativeCalleeWord)
32726:         SynthesizeSlowNativeFrame(state, cx, innermost);
28654: 
30860:     /* Write back interned globals. */
34572:     JS_ASSERT(state.eos == state.stackBase + MAX_NATIVE_STACK_SLOTS);
36361:     JSObject* globalObj = outermostTree->globalObj;
35083:     FlushNativeGlobalFrame(cx, globalObj, state.eos, ngslots, gslots, globalTypeMap);
19591: #ifdef DEBUG
30860:     /* Verify that our state restoration worked. */
19591:     for (JSStackFrame* fp = cx->fp; fp; fp = fp->down) {
31939:         JS_ASSERT_IF(fp->argv, JSVAL_IS_OBJECT(fp->argv[-1]));
19591:     }
19591: #endif
23706: #ifdef JS_JIT_SPEW
23706:     if (innermost->exitType != TIMEOUT_EXIT)
17726:         AUDIT(sideExitIntoInterpreter);
23706:     else
23706:         AUDIT(timeoutIntoInterpreter);
23706: #endif
17397: 
24612:     state.innermost = innermost;
17772: }
17376: 
22652: JS_REQUIRES_STACK bool
37741: MonitorLoopEdge(JSContext* cx, uintN& inlineCallCount, RecordReason reason)
17939: {
29368: #ifdef MOZ_TRACEVIS
31063:     TraceVisStateObj tvso(cx, S_MONITOR);
29368: #endif
29368: 
37741:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
17939: 
18672:     /* Is the recorder currently active? */
17954:     if (tm->recorder) {
36380:         jsbytecode* pc = cx->fp->regs->pc;
36380:         if (pc == tm->recorder->tree->ip) {
36380:             tm->recorder->closeLoop();
36380:         } else {
34351:             if (TraceRecorder::recordLoopEdge(cx, tm->recorder, inlineCallCount))
17954:                 return true;
24493: 
24493:             /*
34351:              * recordLoopEdge will invoke an inner tree if we have a matching
30860:              * one. If we arrive here, that tree didn't run to completion and
30860:              * instead we mis-matched or the inner tree took a side exit other than
30860:              * the loop exit. We are thus no longer guaranteed to be parked on the
30860:              * same loop header js_MonitorLoopEdge was called for. In fact, this
30860:              * might not even be a loop header at all. Hence if the program counter
30860:              * no longer hovers over the inner loop header, return to the
30860:              * interpreter and do not attempt to trigger or record a new tree at
30860:              * this location.
24493:              */
36380:             if (pc != cx->fp->regs->pc) {
29368: #ifdef MOZ_TRACEVIS
29368:                 tvso.r = R_INNER_SIDE_EXIT;
29368: #endif
24493:                 return false;
17954:             }
29368:         }
36380:     }
18317:     JS_ASSERT(!tm->recorder);
17939: 
30860:     /*
30860:      * Make sure the shape of the global object still matches (this might flush
30860:      * the JIT cache).
30860:      */
40424:     JSObject* globalObj = cx->fp->scopeChain->getGlobal();
24491:     uint32 globalShape = -1;
24491:     SlotList* globalSlots = NULL;
24491: 
28105:     if (!CheckGlobalObjectShape(cx, tm, globalObj, &globalShape, &globalSlots)) {
30860:         Backoff(cx, cx->fp->regs->pc);
27493:         return false;
28105:     }
21514: 
25087:     /* Do not enter the JIT code with a pending operation callback. */
29368:     if (cx->operationCallbackFlag) {
29368: #ifdef MOZ_TRACEVIS
29368:         tvso.r = R_CALLBACK_PENDING;
29368: #endif
25087:         return false;
29368:     }
25087: 
17940:     jsbytecode* pc = cx->fp->regs->pc;
28244:     uint32 argc = cx->fp->argc;
28244: 
35044:     TreeFragment* f = LookupOrAddLoop(tm, pc, globalObj, globalShape, argc);
21433: 
30860:     /*
30860:      * If we have no code in the anchor and no peers, we definitively won't be
30860:      * able to activate any trees, so start compiling.
30860:      */
21433:     if (!f->code() && !f->peer) {
25627:     record:
29368:         if (++f->hits() < HOTLOOP) {
29368: #ifdef MOZ_TRACEVIS
29368:             tvso.r = f->hits() < 1 ? R_BACKED_OFF : R_COLD;
29368: #endif
25627:             return false;
29368:         }
30860: 
30860:         /*
30860:          * We can give RecordTree the root peer. If that peer is already taken,
30860:          * it will walk the peer list and find us a free slot or allocate a new
30860:          * tree if needed.
30860:          */
40226:         bool rv = RecordTree(cx, f->first, NULL, 0, globalSlots, reason);
29368: #ifdef MOZ_TRACEVIS
29368:         if (!rv)
29368:             tvso.r = R_FAIL_RECORD_TREE;
29368: #endif
29368:         return rv;
21433:     }
25627: 
29883:     debug_only_printf(LC_TMTracer,
29883:                       "Looking for compat peer %d@%d, from %p (ip: %p)\n",
21685:                       js_FramePCToLineNumber(cx, cx->fp),
29883:                       FramePCOffset(cx->fp), (void*)f, f->ip);
25627: 
25627:     uintN count;
35044:     TreeFragment* match = FindVMCompatiblePeer(cx, globalObj, f, count);
25627:     if (!match) {
25627:         if (count < MAXPEERS)
25627:             goto record;
30860: 
30860:         /*
30860:          * If we hit the max peers ceiling, don't try to lookup fragments all
30860:          * the time. That's expensive. This must be a rather type-unstable loop.
30860:          */
29883:         debug_only_print0(LC_TMTracer, "Blacklisted: too many peer trees.\n");
30860:         Blacklist((jsbytecode*) f->root->ip);
29368: #ifdef MOZ_TRACEVIS
29368:         tvso.r = R_MAX_PEERS;
29368: #endif
25627:         return false;
25627:     }
21433: 
33564:     /*
33564:      * Trees that only unwind recursive frames usually won't do much work, and
33564:      * most time will be spent entering and exiting ExecuteTree(). There's no
33564:      * benefit to doing this until the down-recursive side completes.
33564:      */
36361:     if (match->recursion == Recursion_Unwinds)
33564:         return false;
33564: 
21521:     VMSideExit* lr = NULL;
21521:     VMSideExit* innermostNestedGuard = NULL;
21433: 
30860:     lr = ExecuteTree(cx, match, inlineCallCount, &innermostNestedGuard);
29368:     if (!lr) {
29368: #ifdef MOZ_TRACEVIS
29368:         tvso.r = R_FAIL_EXECUTE_TREE;
29368: #endif
21433:         return false;
29368:     }
21433: 
30860:     /*
30860:      * If we exit on a branch, or on a tree call guard, try to grow the inner
30860:      * tree (in case of a branch exit), or the tree nested around the tree we
30860:      * exited from (in case of the tree call guard).
30860:      */
29368:     bool rv;
20931:     switch (lr->exitType) {
33564:       case RECURSIVE_UNLINKED_EXIT:
21433:       case UNSTABLE_LOOP_EXIT:
33564:           rv = AttemptToStabilizeTree(cx, globalObj, lr, NULL, 0);
29368: #ifdef MOZ_TRACEVIS
29368:           if (!rv)
29368:               tvso.r = R_FAIL_STABILIZE;
29368: #endif
29368:           return rv;
30860: 
29354:       case OVERFLOW_EXIT:
29354:         oracle.markInstructionUndemotable(cx->fp->regs->pc);
30860:         /* FALL THROUGH */
33564:       case RECURSIVE_SLURP_FAIL_EXIT:
33564:       case RECURSIVE_SLURP_MISMATCH_EXIT:
33564:       case RECURSIVE_EMPTY_RP_EXIT:
33564:       case RECURSIVE_MISMATCH_EXIT:
18284:       case BRANCH_EXIT:
25099:       case CASE_EXIT:
30860:         return AttemptToExtendTree(cx, lr, NULL, NULL
29368: #ifdef MOZ_TRACEVIS
29368:                                           , &tvso
29368: #endif
29368:                  );
30860: 
33564:       case RECURSIVE_LOOP_EXIT:
18284:       case LOOP_EXIT:
18284:         if (innermostNestedGuard)
30860:             return AttemptToExtendTree(cx, innermostNestedGuard, lr, NULL
29368: #ifdef MOZ_TRACEVIS
29368:                                             , &tvso
29368: #endif
29368:                    );
29368: #ifdef MOZ_TRACEVIS
29368:         tvso.r = R_NO_EXTEND_OUTER;
29368: #endif
17951:         return false;
30860: 
29368: #ifdef MOZ_TRACEVIS
29368:       case MISMATCH_EXIT:  tvso.r = R_MISMATCH_EXIT;  return false;
29368:       case OOM_EXIT:       tvso.r = R_OOM_EXIT;       return false;
29368:       case TIMEOUT_EXIT:   tvso.r = R_TIMEOUT_EXIT;   return false;
29368:       case DEEP_BAIL_EXIT: tvso.r = R_DEEP_BAIL_EXIT; return false;
29368:       case STATUS_EXIT:    tvso.r = R_STATUS_EXIT;    return false;
29368: #endif
30860: 
18284:       default:
30860:         /*
30860:          * No, this was an unusual exit (i.e. out of memory/GC), so just resume
30860:          * interpretation.
30860:          */
29368: #ifdef MOZ_TRACEVIS
29368:         tvso.r = R_OTHER_EXIT;
29368: #endif
18284:         return false;
18284:     }
17939: }
17939: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
35083: TraceRecorder::monitorRecording(JSOp op)
35083: {
37741:     TraceMonitor &localtm = JS_TRACE_MONITOR(cx);
35115:     debug_only_stmt( JSContext *localcx = cx; )
33171: 
33171:     /* Process needFlush requests now. */
33171:     if (localtm.needFlush) {
32748:         ResetJIT(cx, FR_DEEP_BAIL);
33542:         return ARECORD_ABORTED;
27493:     }
35083:     JS_ASSERT(!fragment->lastIns);
26559: 
26557:     /*
26557:      * Clear one-shot state used to communicate between record_JSOP_CALL and post-
28086:      * opcode-case-guts record hook (record_NativeCallComplete).
26557:      */
35083:     pendingSpecializedNative = NULL;
35083:     newobj_ins = NULL;
19068: 
33180:     /* Handle one-shot request from finishGetProp or INSTANCEOF to snapshot post-op state and guard. */
35083:     if (pendingGuardCondition) {
35083:         guard(true, pendingGuardCondition, STATUS_EXIT);
35083:         pendingGuardCondition = NULL;
31444:     }
31444: 
31444:     /* Handle one-shot request to unbox the result of a property get. */
35083:     if (pendingUnboxSlot) {
35083:         LIns* val_ins = get(pendingUnboxSlot);
35083:         val_ins = unbox_jsval(*pendingUnboxSlot, val_ins, snapshot(BRANCH_EXIT));
35083:         set(pendingUnboxSlot, val_ins);
35083:         pendingUnboxSlot = 0;
31444:     }
31444: 
29883:     debug_only_stmt(
37741:         if (LogController.lcbits & LC_TMRecorder) {
29883:             js_Disassemble1(cx, cx->fp->script, cx->fp->regs->pc,
29883:                             cx->fp->imacpc
29883:                                 ? 0 : cx->fp->regs->pc - cx->fp->script->code,
29883:                             !cx->fp->imacpc, stdout);
29883:         }
29883:     )
19075: 
30860:     /*
30860:      * If op is not a break or a return from a loop, continue recording and
30860:      * follow the trace. We check for imacro-calling bytecodes inside each
30860:      * switch case to resolve the if (JSOP_IS_IMACOP(x)) conditions at compile
30860:      * time.
30860:      */
26011: 
33542:     AbortableRecordingStatus status;
26563: #ifdef DEBUG
26563:     bool wasInImacro = (cx->fp->imacpc != NULL);
26563: #endif
23111:     switch (op) {
28008:       default:
33542:           status = ARECORD_ERROR;
28008:           goto stop_recording;
23111: # define OPDEF(x,val,name,token,length,nuses,ndefs,prec,format)               \
23111:       case x:                                                                 \
35083:         status = this->record_##x();                                            \
26011:         if (JSOP_IS_IMACOP(x))                                                \
23111:             goto imacro;                                                      \
23111:         break;
23111: # include "jsopcode.tbl"
23111: # undef OPDEF
23111:     }
23111: 
35083:     /* Careful, |this| may have been deleted. */
35083:     JS_ASSERT(status != ARECORD_IMACRO);
35083:     JS_ASSERT_IF(!wasInImacro, localcx->fp->imacpc == NULL);
35083: 
35083:   imacro:
35083:     /* |this| may be killed while recording. */
35083:     if (status == ARECORD_COMPLETED) {
35083:         JS_ASSERT(localtm.recorder != this);
35083:         return localtm.recorder ? ARECORD_CONTINUE : ARECORD_COMPLETED;
35083:     }
35083:     if (status == ARECORD_ABORTED) {
35083:         JS_ASSERT(!localtm.recorder);
33542:         return ARECORD_ABORTED;
35083:     }
35083: 
35083:   stop_recording:
35083:     /* Handle lazy abort / OOM. */
37741:     if (outOfMemory() || OverfullJITCache(&localtm)) {
32748:         ResetJIT(cx, FR_OOM);
33542:         return ARECORD_ABORTED;
27933:     }
35083:     if (StatusAbortsRecording(status)) {
37741:         AbortRecording(cx, js_CodeName[op]);
33542:         return ARECORD_ABORTED;
18683:     }
18683: 
35083:     return status;
35083: }
35083: 
22652: JS_REQUIRES_STACK void
37741: AbortRecording(JSContext* cx, const char* reason)
17350: {
25627: #ifdef DEBUG
35083:     JS_ASSERT(TRACE_RECORDER(cx));
35083:     TRACE_RECORDER(cx)->finishAbort(reason);
35083: #else
35083:     TRACE_RECORDER(cx)->finishAbort("[no reason]");
35083: #endif
17350: }
17350: 
36489: #if defined NANOJIT_IA32
36489: static bool
36489: CheckForSSE2()
36489: {
36489:     char *c = getenv("X86_FORCE_SSE2");
36489:     if (c)
36489:         return (!strcmp(c, "true") ||
36489:                 !strcmp(c, "1") ||
36489:                 !strcmp(c, "yes"));
36489: 
36489:     int features = 0;
36489: #if defined _MSC_VER
36489:     __asm
36489:     {
36489:         pushad
36489:         mov eax, 1
36489:         cpuid
36489:         mov features, edx
36489:         popad
36489:     }
36489: #elif defined __GNUC__
36489:     asm("xchg %%esi, %%ebx\n" /* we can't clobber ebx on gcc (PIC register) */
36489:         "mov $0x01, %%eax\n"
36489:         "cpuid\n"
36489:         "mov %%edx, %0\n"
36489:         "xchg %%esi, %%ebx\n"
36489:         : "=m" (features)
36489:         : /* We have no inputs */
36489:         : "%eax", "%esi", "%ecx", "%edx"
36489:        );
36489: #elif defined __SUNPRO_C || defined __SUNPRO_CC
36489:     asm("push %%ebx\n"
36489:         "mov $0x01, %%eax\n"
36489:         "cpuid\n"
36489:         "pop %%ebx\n"
36489:         : "=d" (features)
36489:         : /* We have no inputs */
36489:         : "%eax", "%ecx"
36489:        );
36489: #endif
36489:     return (features & (1<<26)) != 0;
36489: }
36489: #endif
36489: 
26545: #if defined(NANOJIT_ARM)
26545: 
26545: #if defined(_MSC_VER) && defined(WINCE)
26545: 
26545: // these come in from jswince.asm
28185: extern "C" int js_arm_try_armv5_op();
28185: extern "C" int js_arm_try_armv6_op();
28185: extern "C" int js_arm_try_armv7_op();
26545: extern "C" int js_arm_try_vfp_op();
26545: 
28185: static unsigned int
37741: arm_check_arch()
37741: {
28185:     unsigned int arch = 4;
28185:     __try {
28185:         js_arm_try_armv5_op();
28185:         arch = 5;
28185:         js_arm_try_armv6_op();
28185:         arch = 6;
28185:         js_arm_try_armv7_op();
28185:         arch = 7;
28185:     } __except(GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION) {
28185:     }
28185:     return arch;
28185: }
28185: 
26545: static bool
37741: arm_check_vfp()
37741: {
33060: #ifdef WINCE_WINDOWS_MOBILE
33060:     return false;
33060: #else
26545:     bool ret = false;
26545:     __try {
26545:         js_arm_try_vfp_op();
26545:         ret = true;
26545:     } __except(GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION) {
26545:         ret = false;
26545:     }
26545:     return ret;
33060: #endif
26545: }
26545: 
31723: #define HAVE_ENABLE_DISABLE_DEBUGGER_EXCEPTIONS 1
31723: 
31723: /* See "Suppressing Exception Notifications while Debugging", at
31723:  * http://msdn.microsoft.com/en-us/library/ms924252.aspx
31723:  */
31723: static void
37741: disable_debugger_exceptions()
32777: {
31723:     // 2 == TLSSLOT_KERNEL
31723:     DWORD kctrl = (DWORD) TlsGetValue(2);
31723:     // 0x12 = TLSKERN_NOFAULT | TLSKERN_NOFAULTMSG
31723:     kctrl |= 0x12;
31723:     TlsSetValue(2, (LPVOID) kctrl);
31723: }
31723: 
31723: static void
37741: enable_debugger_exceptions()
32777: {
31723:     // 2 == TLSSLOT_KERNEL
31723:     DWORD kctrl = (DWORD) TlsGetValue(2);
31723:     // 0x12 = TLSKERN_NOFAULT | TLSKERN_NOFAULTMSG
31723:     kctrl &= ~0x12;
31723:     TlsSetValue(2, (LPVOID) kctrl);
31723: }
31723: 
26545: #elif defined(__GNUC__) && defined(AVMPLUS_LINUX)
26545: 
28185: // Assume ARMv4 by default.
28185: static unsigned int arm_arch = 4;
26545: static bool arm_has_vfp = false;
26545: static bool arm_has_neon = false;
26545: static bool arm_has_iwmmxt = false;
26545: static bool arm_tests_initialized = false;
26545: 
40165: #ifdef ANDROID
40165: // android doesn't have Elf32_auxv_t defined in elf.h, but it does have /proc/self/auxv
40165: typedef struct {
40165:     uint32_t a_type;
40165:     union {
40165:        uint32_t a_val;
40165:     } a_un;
40165: } Elf32_auxv_t;
40165: #endif
40165: 
26545: static void
37741: arm_read_auxv()
37741: {
26545:     int fd;
26545:     Elf32_auxv_t aux;
26545: 
26545:     fd = open("/proc/self/auxv", O_RDONLY);
26545:     if (fd > 0) {
26545:         while (read(fd, &aux, sizeof(Elf32_auxv_t))) {
26545:             if (aux.a_type == AT_HWCAP) {
26545:                 uint32_t hwcap = aux.a_un.a_val;
26545:                 if (getenv("ARM_FORCE_HWCAP"))
26545:                     hwcap = strtoul(getenv("ARM_FORCE_HWCAP"), NULL, 0);
26545:                 // hardcode these values to avoid depending on specific versions
26545:                 // of the hwcap header, e.g. HWCAP_NEON
26545:                 arm_has_vfp = (hwcap & 64) != 0;
26545:                 arm_has_iwmmxt = (hwcap & 512) != 0;
26545:                 // this flag is only present on kernel 2.6.29
26545:                 arm_has_neon = (hwcap & 4096) != 0;
26545:             } else if (aux.a_type == AT_PLATFORM) {
26545:                 const char *plat = (const char*) aux.a_un.a_val;
26545:                 if (getenv("ARM_FORCE_PLATFORM"))
26545:                     plat = getenv("ARM_FORCE_PLATFORM");
28185:                 // The platform string has the form "v[0-9][lb]". The "l" or "b" indicate little-
28185:                 // or big-endian variants and the digit indicates the version of the platform.
28185:                 // We can only accept ARMv4 and above, but allow anything up to ARMv9 for future
28185:                 // processors. Architectures newer than ARMv7 are assumed to be
28185:                 // backwards-compatible with ARMv7.
28185:                 if ((plat[0] == 'v') &&
28185:                     (plat[1] >= '4') && (plat[1] <= '9') &&
28185:                     ((plat[2] == 'l') || (plat[2] == 'b')))
28185:                 {
28185:                     arm_arch = plat[1] - '0';
28185:                 }
28185:                 else
28185:                 {
28185:                     // For production code, ignore invalid (or unexpected) platform strings and
34359:                     // fall back to the default. For debug code, use an assertion to catch this
34359:                     // when not running in scratchbox.
34359:                     if (getenv("_SBOX_DIR") == NULL)
28185:                         JS_ASSERT(false);
26545:                 }
26545:             }
26545:         }
26545:         close (fd);
26545: 
26545:         // if we don't have 2.6.29, we have to do this hack; set
26545:         // the env var to trust HWCAP.
28185:         if (!getenv("ARM_TRUST_HWCAP") && (arm_arch >= 7))
26545:             arm_has_neon = true;
26545:     }
26545: 
26545:     arm_tests_initialized = true;
26545: }
26545: 
38525: static unsigned int
38525: arm_check_arch()
37741: {
26545:     if (!arm_tests_initialized)
26545:         arm_read_auxv();
26545: 
38525:     return arm_arch;
28185: }
28185: 
28185: static bool
38525: arm_check_vfp()
37741: {
28185:     if (!arm_tests_initialized)
28185:         arm_read_auxv();
28185: 
26545:     return arm_has_vfp;
26545: }
26545: 
26545: #else
28185: #warning Not sure how to check for architecture variant on your platform. Assuming ARMv4.
28185: static unsigned int
37741: arm_check_arch() { return 4; }
26548: static bool
37741: arm_check_vfp() { return false; }
26545: #endif
26545: 
31723: #ifndef HAVE_ENABLE_DISABLE_DEBUGGER_EXCEPTIONS
31723: static void
37741: enable_debugger_exceptions() { }
31723: static void
37741: disable_debugger_exceptions() { }
31723: #endif
31723: 
26545: #endif /* NANOJIT_ARM */
26545: 
27884: #define K *1024
27884: #define M K K
27884: #define G K M
27884: 
27884: void
37741: SetMaxCodeCacheBytes(JSContext* cx, uint32 bytes)
37741: {
37741:     TraceMonitor* tm = &JS_THREAD_DATA(cx)->traceMonitor;
33545:     JS_ASSERT(tm->codeAlloc && tm->dataAlloc && tm->traceAlloc);
27884:     if (bytes > 1 G)
27884:         bytes = 1 G;
27884:     if (bytes < 128 K)
27884:         bytes = 128 K;
27884:     tm->maxCodeCacheBytes = bytes;
27884: }
27884: 
25940: void
37741: InitJIT(TraceMonitor *tm)
18068: {
29883: #if defined JS_JIT_SPEW
32784:     tm->profAlloc = NULL;
30860:     /* Set up debug logging. */
29883:     if (!did_we_set_up_debug_logging) {
30860:         InitJITLogController();
29883:         did_we_set_up_debug_logging = true;
29883:     }
32784:     /* Set up fragprofiling, if required. */
37741:     if (LogController.lcbits & LC_FragProfile) {
32784:         tm->profAlloc = new VMAllocator();
32784:         tm->profTab = new (*tm->profAlloc) FragStatsMap(*tm->profAlloc);
32784:     }
32784:     tm->lastFragID = 0;
29883: #else
40229:     PodZero(&LogController);
29883: #endif
29883: 
26545:     if (!did_we_check_processor_features) {
18333: #if defined NANOJIT_IA32
38583:         avmplus::AvmCore::config.i386_use_cmov =
38583:             avmplus::AvmCore::config.i386_sse2 = CheckForSSE2();
38583:         avmplus::AvmCore::config.i386_fixed_esp = true;
18333: #endif
26545: #if defined NANOJIT_ARM
31723: 
37742:         disable_debugger_exceptions();
37742: 
37742:         bool            arm_vfp     = arm_check_vfp();
37742:         unsigned int    arm_arch    = arm_check_arch();
37742: 
37742:         enable_debugger_exceptions();
37038: 
37773:         avmplus::AvmCore::config.arm_vfp        = arm_vfp;
28185:         avmplus::AvmCore::config.soft_float     = !arm_vfp;
37773:         avmplus::AvmCore::config.arm_arch       = arm_arch;
28185: 
28185:         // Sanity-check the configuration detection.
28185:         //  * We don't understand architectures prior to ARMv4.
28185:         JS_ASSERT(arm_arch >= 4);
26545: #endif
26545:         did_we_check_processor_features = true;
26545:     }
26545: 
30860:     /* Set the default size for the code cache to 16MB. */
27884:     tm->maxCodeCacheBytes = 16 M;
27884: 
38568:     tm->recordAttempts = new RecordAttemptMap;
38568:     if (!tm->recordAttempts->init(PC_HASH_COUNT))
38568:         abort();
28105: 
33545:     JS_ASSERT(!tm->dataAlloc && !tm->traceAlloc && !tm->codeAlloc);
33159:     tm->dataAlloc = new VMAllocator();
33545:     tm->traceAlloc = new VMAllocator();
33167:     tm->tempAlloc = new VMAllocator();
33167:     tm->reTempAlloc = new VMAllocator();
31492:     tm->codeAlloc = new CodeAlloc();
33563:     tm->frameCache = new FrameInfoCache(tm->dataAlloc);
37037:     tm->storage = new TraceNativeStorage();
37694:     tm->cachedTempTypeMap = new TypeMap(0);
32767:     tm->flush();
32784:     verbose_only( tm->branches = NULL; )
31920: 
17884: #if !defined XP_WIN
40230:     debug_only(PodZero(&jitstats));
17884: #endif
33126: 
33126: #ifdef JS_JIT_SPEW
33126:     /* Architecture properties used by test cases. */
33126:     jitstats.archIsIA32 = 0;
33126:     jitstats.archIs64BIT = 0;
33126:     jitstats.archIsARM = 0;
33126:     jitstats.archIsSPARC = 0;
33126:     jitstats.archIsPPC = 0;
33126: #if defined NANOJIT_IA32
33126:     jitstats.archIsIA32 = 1;
33126: #endif
33126: #if defined NANOJIT_64BIT
33126:     jitstats.archIs64BIT = 1;
33126: #endif
33126: #if defined NANOJIT_ARM
33126:     jitstats.archIsARM = 1;
33126: #endif
33126: #if defined NANOJIT_SPARC
33126:     jitstats.archIsSPARC = 1;
33126: #endif
33126: #if defined NANOJIT_PPC
33126:     jitstats.archIsPPC = 1;
33126: #endif
33126: #if defined NANOJIT_X64
33126:     jitstats.archIsAMD64 = 1;
33126: #endif
33126: #endif
17726: }
17726: 
25940: void
37741: FinishJIT(TraceMonitor *tm)
18068: {
35083:     JS_ASSERT(!tm->recorder);
35083: 
21459: #ifdef JS_JIT_SPEW
29883:     if (jitstats.recorderStarted) {
34295:         char sep = ':';
34295:         debug_only_print0(LC_TMStats, "recorder");
34295: #define RECORDER_JITSTAT(_ident, _name)                             \
34295:         debug_only_printf(LC_TMStats, "%c " _name "(%llu)", sep,    \
34295:                           (unsigned long long int)jitstats._ident); \
34295:         sep = ',';
34295: #define JITSTAT(x) /* nothing */
34295: #include "jitstats.tbl"
34295: #undef JITSTAT
34295: #undef RECORDER_JITSTAT
34295:         debug_only_print0(LC_TMStats, "\n");
34295: 
34295:         sep = ':';
34295:         debug_only_print0(LC_TMStats, "monitor");
34295: #define MONITOR_JITSTAT(_ident, _name)                              \
34295:         debug_only_printf(LC_TMStats, "%c " _name "(%llu)", sep,    \
34295:                           (unsigned long long int)jitstats._ident); \
34295:         sep = ',';
34295: #define JITSTAT(x) /* nothing */
34295: #include "jitstats.tbl"
34295: #undef JITSTAT
34295: #undef MONITOR_JITSTAT
34295:         debug_only_print0(LC_TMStats, "\n");
22616:     }
17726: #endif
31920: 
38568:     delete tm->recordAttempts;
28105: 
32784: #ifdef DEBUG
32784:     // Recover profiling data from expiring Fragments, and display
32784:     // final results.
37741:     if (LogController.lcbits & LC_FragProfile) {
32784:         for (Seq<Fragment*>* f = tm->branches; f; f = f->tail) {
37741:             FragProfiling_FragFinalizer(f->head, tm);
32784:         }
32784:         for (size_t i = 0; i < FRAGMENT_TABLE_SIZE; ++i) {
35044:             for (TreeFragment *f = tm->vmfragments[i]; f; f = f->next) {
32784:                 JS_ASSERT(f->root == f);
35044:                 for (TreeFragment *p = f; p; p = p->peer)
37741:                     FragProfiling_FragFinalizer(p, tm);
32784:             }
32784:         }
32784:         REHashMap::Iter iter(*(tm->reFragments));
32784:         while (iter.next()) {
35044:             VMFragment* frag = (VMFragment*)iter.value();
37741:             FragProfiling_FragFinalizer(frag, tm);
37741:         }
37741: 
37741:         FragProfiling_showResults(tm);
32784:         delete tm->profAlloc;
32784: 
32784:     } else {
32784:         NanoAssert(!tm->profTab);
32784:         NanoAssert(!tm->profAlloc);
32784:     }
32784: #endif
32784: 
40229:     PodArrayZero(tm->vmfragments);
32767: 
33563:     if (tm->frameCache) {
33563:         delete tm->frameCache;
33563:         tm->frameCache = NULL;
33563:     }
33563: 
32767:     if (tm->codeAlloc) {
31475:         delete tm->codeAlloc;
32767:         tm->codeAlloc = NULL;
32767:     }
32767: 
33159:     if (tm->dataAlloc) {
33159:         delete tm->dataAlloc;
33159:         tm->dataAlloc = NULL;
32767:     }
33167: 
33545:     if (tm->traceAlloc) {
33545:         delete tm->traceAlloc;
33545:         tm->traceAlloc = NULL;
33545:     }
33545: 
33167:     if (tm->tempAlloc) {
33167:         delete tm->tempAlloc;
33167:         tm->tempAlloc = NULL;
33167:     }
33167: 
33167:     if (tm->reTempAlloc) {
33167:         delete tm->reTempAlloc;
33167:         tm->reTempAlloc = NULL;
33167:     }
37037: 
37037:     if (tm->storage) {
37037:         delete tm->storage;
37037:         tm->storage = NULL;
37037:     }
37694: 
37694:     delete tm->cachedTempTypeMap;
37694:     tm->cachedTempTypeMap = NULL;
17442: }
17442: 
21723: void
37741: PurgeJITOracle()
26569: {
26569:     oracle.clear();
26569: }
26569: 
31920: JS_REQUIRES_STACK void
37741: PurgeScriptFragments(JSContext* cx, JSScript* script)
31920: {
31920:     if (!TRACING_ENABLED(cx))
31920:         return;
31920:     debug_only_printf(LC_TMTracer,
31920:                       "Purging fragments for JSScript %p.\n", (void*)script);
31920: 
37741:     TraceMonitor* tm = &JS_TRACE_MONITOR(cx);
24879:     for (size_t i = 0; i < FRAGMENT_TABLE_SIZE; ++i) {
35044:         TreeFragment** fragp = &tm->vmfragments[i];
35044:         while (TreeFragment* frag = *fragp) {
28311:             if (JS_UPTRDIFF(frag->ip, script->code) < script->length) {
30860:                 /* This fragment is associated with the script. */
29883:                 debug_only_printf(LC_TMTracer,
35044:                                   "Disconnecting TreeFragment %p "
25089:                                   "with ip %p, in range [%p,%p).\n",
28311:                                   (void*)frag, frag->ip, script->code,
29883:                                   script->code + script->length);
31920: 
31920:                 JS_ASSERT(frag->root == frag);
32777:                 *fragp = frag->next;
32777:                 do {
37741:                     verbose_only( FragProfiling_FragFinalizer(frag, tm); )
32777:                     TrashTree(cx, frag);
32777:                 } while ((frag = frag->peer) != NULL);
32777:                 continue;
32777:             }
32777:             fragp = &frag->next;
32777:         }
32777:     }
32777: 
38568:     RecordAttemptMap &table = *tm->recordAttempts;
39896:     for (RecordAttemptMap::Enum e(table); !e.empty(); e.popFront()) {
38568:         if (JS_UPTRDIFF(e.front().key, script->code) < script->length)
38568:             e.removeFront();
38568:     }
24879: }
24879: 
26826: bool
37741: OverfullJITCache(TraceMonitor* tm)
26826: {
26826:     /*
31475:      * You might imagine the outOfMemory flag on the allocator is sufficient
26826:      * to model the notion of "running out of memory", but there are actually
26826:      * two separate issues involved:
26826:      *
26826:      *  1. The process truly running out of memory: malloc() or mmap()
26826:      *     failed.
26826:      *
26826:      *  2. The limit we put on the "intended size" of the tracemonkey code
26826:      *     cache, in pages, has been exceeded.
26826:      *
26826:      * Condition 1 doesn't happen very often, but we're obliged to try to
26826:      * safely shut down and signal the rest of spidermonkey when it
26826:      * does. Condition 2 happens quite regularly.
26826:      *
31475:      * Presently, the code in this file doesn't check the outOfMemory condition
26826:      * often enough, and frequently misuses the unchecked results of
26826:      * lirbuffer insertions on the asssumption that it will notice the
31475:      * outOfMemory flag "soon enough" when it returns to the monitorRecording
31475:      * function. This turns out to be a false assumption if we use outOfMemory
26826:      * to signal condition 2: we regularly provoke "passing our intended
26826:      * size" and regularly fail to notice it in time to prevent writing
26826:      * over the end of an artificially self-limited LIR buffer.
26826:      *
26826:      * To mitigate, though not completely solve, this problem, we're
26826:      * modeling the two forms of memory exhaustion *separately* for the
31475:      * time being: condition 1 is handled by the outOfMemory flag inside
26826:      * nanojit, and condition 2 is being handled independently *here*. So
31920:      * we construct our allocators to use all available memory they like,
31475:      * and only report outOfMemory to us when there is literally no OS memory
26826:      * left. Merely purging our cache when we hit our highwater mark is
26826:      * handled by the (few) callers of this function.
26826:      *
26826:      */
27884:     jsuint maxsz = tm->maxCodeCacheBytes;
33159:     VMAllocator *dataAlloc = tm->dataAlloc;
33545:     VMAllocator *traceAlloc = tm->traceAlloc;
31475:     CodeAlloc *codeAlloc = tm->codeAlloc;
32767: 
33545:     return (codeAlloc->size() + dataAlloc->size() + traceAlloc->size() > maxsz);
26826: }
26826: 
25214: JS_FORCES_STACK JS_FRIEND_API(void)
37741: DeepBail(JSContext *cx)
25214: {
25214:     JS_ASSERT(JS_ON_TRACE(cx));
25214: 
27577:     /*
27577:      * Exactly one context on the current thread is on trace. Find out which
27577:      * one. (Most callers cannot guarantee that it's cx.)
27577:      */
37741:     TraceMonitor *tm = &JS_TRACE_MONITOR(cx);
27882:     JSContext *tracecx = tm->tracecx;
27577: 
24612:     /* It's a bug if a non-FAIL_STATUS builtin gets here. */
27577:     JS_ASSERT(tracecx->bailExit);
27577: 
27882:     tm->tracecx = NULL;
29883:     debug_only_print0(LC_TMTracer, "Deep bail.\n");
37694:     LeaveTree(tm, *tracecx->interpState, tracecx->bailExit);
27577:     tracecx->bailExit = NULL;
30287: 
30287:     InterpState* state = tracecx->interpState;
37741:     state->builtinStatus |= BUILTIN_BAILED;
34572: 
34572:     /*
34572:      * Between now and the LeaveTree in ExecuteTree, |tm->storage| may be reused
34572:      * if another trace executes before the currently executing native returns.
34572:      * However, all such traces will complete by the time the currently
34572:      * executing native returns and the return value is written to the native
34572:      * stack. After that point, no traces may execute until the LeaveTree in
34572:      * ExecuteTree, hence the invariant is maintained that only one trace uses
34572:      * |tm->storage| at a time.
34572:      */
30287:     state->deepBailSp = state->sp;
22652: }
22652: 
39893: extern bool
39893: InCustomIterNextTryRegion(jsbytecode *pc)
39893: {
39893:     return nextiter_imacros.custom_iter_next <= pc &&
39893:            pc < nextiter_imacros.custom_iter_next + sizeof(nextiter_imacros.custom_iter_next);
39893: }
39893: 
22652: JS_REQUIRES_STACK jsval&
17412: TraceRecorder::argval(unsigned n) const
17412: {
17799:     JS_ASSERT(n < cx->fp->fun->nargs);
17412:     return cx->fp->argv[n];
17412: }
17412: 
22652: JS_REQUIRES_STACK jsval&
17412: TraceRecorder::varval(unsigned n) const
17412: {
18137:     JS_ASSERT(n < cx->fp->script->nslots);
17807:     return cx->fp->slots[n];
17412: }
17412: 
22652: JS_REQUIRES_STACK jsval&
17412: TraceRecorder::stackval(int n) const
17412: {
17520:     jsval* sp = cx->fp->regs->sp;
17520:     return sp[n];
17412: }
17412: 
37694: /*
37694:  * Generate LIR to compute the scope chain.
37694:  */
22652: JS_REQUIRES_STACK LIns*
37694: TraceRecorder::scopeChain()
37694: {
37694:     return cx->fp->callee()
39911:            ? get(&cx->fp->scopeChainVal)
37694:            : entryScopeChain();
37694: }
37694: 
37694: /*
37694:  * Generate LIR to compute the scope chain on entry to the trace. This is
37694:  * generally useful only for getting to the global object, because only
37694:  * the global object is guaranteed to be present.
37694:  */
37694: JS_REQUIRES_STACK LIns*
37694: TraceRecorder::entryScopeChain() const
18286: {
18286:     return lir->insLoad(LIR_ldp,
40353:                         lir->insLoad(LIR_ldp, cx_ins, offsetof(JSContext, fp), ACC_OTHER),
40353:                         offsetof(JSStackFrame, scopeChain), ACC_OTHER);
18286: }
18286: 
30248: /*
30860:  * Return the frame of a call object if that frame is part of the current
30860:  * trace. |depthp| is an optional outparam: if it is non-null, it will be
30860:  * filled in with the depth of the call object's frame relevant to cx->fp.
30248:  */
30248: JS_REQUIRES_STACK JSStackFrame*
30248: TraceRecorder::frameIfInRange(JSObject* obj, unsigned* depthp) const
30248: {
31452:     JSStackFrame* ofp = (JSStackFrame*) obj->getPrivate();
30248:     JSStackFrame* fp = cx->fp;
30248:     for (unsigned depth = 0; depth <= callDepth; ++depth) {
30248:         if (fp == ofp) {
30248:             if (depthp)
30248:                 *depthp = depth;
30248:             return ofp;
30248:         }
18286:         if (!(fp = fp->down))
30248:             break;
30248:     }
30248:     return NULL;
18286: }
18286: 
39910: JS_DEFINE_CALLINFO_4(extern, UINT32, GetClosureVar, CONTEXT, OBJECT, CVIPTR, DOUBLEPTR, 0,
39910:                      ACC_STORE_ANY)
39910: JS_DEFINE_CALLINFO_4(extern, UINT32, GetClosureArg, CONTEXT, OBJECT, CVIPTR, DOUBLEPTR, 0,
39910:                      ACC_STORE_ANY)
30647: 
30647: /*
30860:  * Search the scope chain for a property lookup operation at the current PC and
33542:  * generate LIR to access the given property. Return RECORD_CONTINUE on success,
33542:  * otherwise abort and return RECORD_STOP. There are 3 outparams:
30647:  *
30647:  *     vp           the address of the current property value
30647:  *     ins          LIR instruction representing the property value on trace
31075:  *     NameResult   describes how to look up name; see comment for NameResult in jstracer.h
31075:  */
33542: JS_REQUIRES_STACK AbortableRecordingStatus
35370: TraceRecorder::scopeChainProp(JSObject* chainHead, jsval*& vp, LIns*& ins, NameResult& nr)
35370: {
35370:     JS_ASSERT(chainHead == cx->fp->scopeChain);
35370:     JS_ASSERT(chainHead != globalObj);
18286: 
37741:     TraceMonitor &localtm = *traceMonitor;
33171: 
18286:     JSAtom* atom = atoms[GET_INDEX(cx->fp->regs->pc)];
18286:     JSObject* obj2;
18286:     JSProperty* prop;
35370:     JSObject *obj = chainHead;
39928:     JSBool ok = js_FindProperty(cx, ATOM_TO_JSID(atom), &obj, &obj2, &prop);
33171: 
33171:     /* js_FindProperty can reenter the interpreter and kill |this|. */
33171:     if (!localtm.recorder)
33542:         return ARECORD_ABORTED;
33171: 
33171:     if (!ok)
33542:         RETURN_ERROR_A("error in js_FindProperty");
33171: 
27933:     if (!prop)
33542:         RETURN_STOP_A("failed to find name in non-global scope chain");
18286: 
18286:     if (obj == globalObj) {
32593:         // Even if the property is on the global object, we must guard against
32593:         // the creation of properties that shadow the property in the middle
35370:         // of the scope chain.
35370:         LIns *head_ins;
32593:         if (cx->fp->argv) {
35370:             // Skip any Call object when inside a function. Any reference to a
35370:             // Call name the compiler resolves statically and we do not need
35370:             // to match shapes of the Call objects.
35370:             chainHead = cx->fp->calleeObject()->getParent();
35370:             head_ins = stobj_get_parent(get(&cx->fp->argv[-2]));
35370:         } else {
35370:             head_ins = scopeChain();
35370:         }
32593:         LIns *obj_ins;
35370:         CHECK_STATUS_A(traverseScopeChain(chainHead, head_ins, obj, obj_ins));
32593: 
18286:         JSScopeProperty* sprop = (JSScopeProperty*) prop;
23096: 
25938:         if (obj2 != obj) {
31501:             obj2->dropProperty(cx, prop);
33542:             RETURN_STOP_A("prototype property");
25938:         }
25938:         if (!isValidSlot(OBJ_SCOPE(obj), sprop)) {
31501:             obj2->dropProperty(cx, prop);
33542:             return ARECORD_STOP;
25938:         }
25938:         if (!lazilyImportGlobalSlot(sprop->slot)) {
31501:             obj2->dropProperty(cx, prop);
33542:             RETURN_STOP_A("lazy import of global slot failed");
25938:         }
40410:         vp = &obj->getSlotRef(sprop->slot);
30647:         ins = get(vp);
31501:         obj2->dropProperty(cx, prop);
31075:         nr.tracked = true;
33542:         return ARECORD_CONTINUE;
18286:     }
18286: 
35479:     if (obj == obj2 && OBJ_GET_CLASS(cx, obj) == &js_CallClass) {
35479:         AbortableRecordingStatus status =
35479:             InjectStatus(callProp(obj, prop, ATOM_TO_JSID(atom), vp, ins, nr));
35479:         obj->dropProperty(cx, prop);
35479:         return status;
35479:     }
32593: 
32593:     obj2->dropProperty(cx, prop);
33542:     RETURN_STOP_A("fp->scopeChain is not global or active call object");
32593: }
32593: 
32593: /*
32593:  * Generate LIR to access a property of a Call object.
32593:  */
33542: JS_REQUIRES_STACK RecordingStatus
32658: TraceRecorder::callProp(JSObject* obj, JSProperty* prop, jsid id, jsval*& vp,
32593:                         LIns*& ins, NameResult& nr)
32593: {
18286:     JSScopeProperty *sprop = (JSScopeProperty*) prop;
29359: 
32658:     JSOp op = JSOp(*cx->fp->regs->pc);
32658:     uint32 setflags = (js_CodeSpec[op].format & (JOF_SET | JOF_INCDEC | JOF_FOR));
40265:     if (setflags && !sprop->writable())
33542:         RETURN_STOP("writing to a read-only property");
29359: 
35483:     uintN slot = uint16(sprop->shortid);
18286: 
18426:     vp = NULL;
30647:     uintN upvar_slot = SPROP_INVALID_SLOT;
32593:     JSStackFrame* cfp = (JSStackFrame*) obj->getPrivate();
32593:     if (cfp) {
39894:         if (sprop->getterOp() == js_GetCallArg) {
18286:             JS_ASSERT(slot < cfp->fun->nargs);
18286:             vp = &cfp->argv[slot];
30647:             upvar_slot = slot;
32593:             nr.v = *vp;
39894:         } else if (sprop->getterOp() == js_GetCallVar ||
39894:                    sprop->getterOp() == js_GetCallVarChecked) {
18286:             JS_ASSERT(slot < cfp->script->nslots);
18286:             vp = &cfp->slots[slot];
30647:             upvar_slot = cx->fp->fun->nargs + slot;
32593:             nr.v = *vp;
32593:         } else {
33542:             RETURN_STOP("dynamic property of Call object");
31840:         }
30647: 
35483:         // Now assert that our use of sprop->shortid was in fact kosher.
38562:         JS_ASSERT(sprop->hasShortID());
35483: 
30647:         if (frameIfInRange(obj)) {
32593:             // At this point we are guaranteed to be looking at an active call oject
30647:             // whose properties are stored in the corresponding JSStackFrame.
30647:             ins = get(vp);
31075:             nr.tracked = true;
33542:             return RECORD_CONTINUE;
31449:         }
32593:     } else {
32658:         // Call objects do not yet have sprop->isMethod() properties, but they
32658:         // should. See bug 514046, for which this code is future-proof. Remove
32658:         // this comment when that bug is fixed (so, FIXME: 514046).
32593: #ifdef DEBUG
32593:         JSBool rv =
32593: #endif
32658:             js_GetPropertyHelper(cx, obj, sprop->id,
32658:                                  (op == JSOP_CALLNAME)
32658:                                  ? JSGET_NO_METHOD_BARRIER
32658:                                  : JSGET_METHOD_BARRIER,
32658:                                  &nr.v);
32593:         JS_ASSERT(rv);
32593:     }
32593: 
32593:     LIns* obj_ins;
39930:     JSObject* parent = cx->fp->calleeObject()->getParent();
32593:     LIns* parent_ins = stobj_get_parent(get(&cx->fp->argv[-2]));
32593:     CHECK_STATUS(traverseScopeChain(parent, parent_ins, obj, obj_ins));
32593: 
35479:     LIns* call_ins;
35479:     if (!cfp) {
35479:         // Because the parent guard in guardCallee ensures this Call object
35479:         // will be the same object now and on trace, and because once a Call
35479:         // object loses its frame it never regains one, on trace we will also
35479:         // have a null private in the Call object. So all we need to do is
35479:         // write the value to the Call object's slot.
35483:         int32 dslot_index = slot;
39894:         if (sprop->getterOp() == js_GetCallArg) {
35483:             JS_ASSERT(dslot_index < ArgClosureTraits::slot_count(obj));
35483:             dslot_index += ArgClosureTraits::slot_offset(obj);
39894:         } else if (sprop->getterOp() == js_GetCallVar ||
39894:                    sprop->getterOp() == js_GetCallVarChecked) {
35483:             JS_ASSERT(dslot_index < VarClosureTraits::slot_count(obj));
35483:             dslot_index += VarClosureTraits::slot_offset(obj);
35479:         } else {
35479:             RETURN_STOP("dynamic property of Call object");
35479:         }
35479: 
35483:         // Now assert that our use of sprop->shortid was in fact kosher.
38562:         JS_ASSERT(sprop->hasShortID());
35483: 
40353:         LIns* base = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, dslots), ACC_OTHER);
40353:         LIns* val_ins = lir->insLoad(LIR_ldp, base, dslot_index * sizeof(jsval), ACC_OTHER);
35483:         ins = unbox_jsval(obj->dslots[dslot_index], val_ins, snapshot(BRANCH_EXIT));
35483:     } else {
34351:         ClosureVarInfo* cv = new (traceAlloc()) ClosureVarInfo();
32593:         cv->slot = slot;
35479: #ifdef DEBUG
32593:         cv->callDepth = callDepth;
35479: #endif
32593: 
30647:         LIns* outp = lir->insAlloc(sizeof(double));
30647:         LIns* args[] = {
30647:             outp,
32593:             INS_CONSTPTR(cv),
32593:             obj_ins,
30647:             cx_ins
30647:         };
30647:         const CallInfo* ci;
39894:         if (sprop->getterOp() == js_GetCallArg) {
30860:             ci = &GetClosureArg_ci;
39894:         } else if (sprop->getterOp() == js_GetCallVar ||
39894:                    sprop->getterOp() == js_GetCallVarChecked) {
30860:             ci = &GetClosureVar_ci;
35479:         } else {
35479:             RETURN_STOP("dynamic property of Call object");
35479:         }
35479: 
35483:         // Now assert that our use of sprop->shortid was in fact kosher.
38562:         JS_ASSERT(sprop->hasShortID());
35483: 
35479:         call_ins = lir->insCall(ci, args);
35479: 
37741:         TraceType type = getCoercedType(nr.v);
30647:         guard(true,
30647:               addName(lir->ins2(LIR_eq, call_ins, lir->insImm(type)),
30647:                       "guard(type-stable name access)"),
30647:               BRANCH_EXIT);
40353:         ins = stackLoad(outp, ACC_OTHER, type);
35479:     }
31075:     nr.tracked = false;
31075:     nr.obj = obj;
32593:     nr.obj_ins = obj_ins;
31075:     nr.sprop = sprop;
33542:     return RECORD_CONTINUE;
30647: }
18286: 
22652: JS_REQUIRES_STACK LIns*
17412: TraceRecorder::arg(unsigned n)
17412: {
17412:     return get(&argval(n));
17412: }
17412: 
22652: JS_REQUIRES_STACK void
17415: TraceRecorder::arg(unsigned n, LIns* i)
17415: {
17415:     set(&argval(n), i);
17415: }
17415: 
22652: JS_REQUIRES_STACK LIns*
17412: TraceRecorder::var(unsigned n)
17412: {
17412:     return get(&varval(n));
17412: }
17412: 
22652: JS_REQUIRES_STACK void
17415: TraceRecorder::var(unsigned n, LIns* i)
17415: {
17415:     set(&varval(n), i);
17415: }
17415: 
22652: JS_REQUIRES_STACK LIns*
17412: TraceRecorder::stack(int n)
17412: {
17412:     return get(&stackval(n));
17412: }
17412: 
22652: JS_REQUIRES_STACK void
17412: TraceRecorder::stack(int n, LIns* i)
17412: {
39913:     set(&stackval(n), i);
17412: }
17412: 
23456: JS_REQUIRES_STACK LIns*
21799: TraceRecorder::alu(LOpcode v, jsdouble v0, jsdouble v1, LIns* s0, LIns* s1)
21799: {
29354:     /*
29354:      * To even consider this operation for demotion, both operands have to be
29354:      * integers and the oracle must not give us a negative hint for the
29354:      * instruction.
29354:      */
29369:     if (oracle.isInstructionUndemotable(cx->fp->regs->pc) || !isPromoteInt(s0) || !isPromoteInt(s1)) {
29354:     out:
29354:         if (v == LIR_fmod) {
29354:             LIns* args[] = { s1, s0 };
29354:             return lir->insCall(&js_dmod_ci, args);
29354:         }
29354:         LIns* result = lir->ins2(v, s0, s1);
32640:         JS_ASSERT_IF(s0->isconstf() && s1->isconstf(), result->isconstf());
29354:         return result;
29354:     }
29354: 
21799:     jsdouble r;
29354:     switch (v) {
29354:     case LIR_fadd:
21799:         r = v0 + v1;
29354:         break;
29354:     case LIR_fsub:
21799:         r = v0 - v1;
29354:         break;
29354:     case LIR_fmul:
29354:         r = v0 * v1;
29373:         if (r == 0.0)
29373:             goto out;
29354:         break;
33095: #if defined NANOJIT_IA32 || defined NANOJIT_X64
29354:     case LIR_fdiv:
29354:         if (v1 == 0)
29354:             goto out;
29354:         r = v0 / v1;
29354:         break;
29354:     case LIR_fmod:
32640:         if (v0 < 0 || v1 == 0 || (s1->isconstf() && v1 < 0))
29354:             goto out;
29354:         r = js_dmod(v0, v1);
29354:         break;
29354: #endif
29354:     default:
29354:         goto out;
29354:     }
29354: 
29354:     /*
29354:      * The result must be an integer at record time, otherwise there is no
29354:      * point in trying to demote it.
29354:      */
29354:     if (jsint(r) != r || JSDOUBLE_IS_NEGZERO(r))
29354:         goto out;
29354: 
37741:     LIns* d0 = demote(lir, s0);
37741:     LIns* d1 = demote(lir, s1);
29354: 
29354:     /*
29354:      * Speculatively emit an integer operation, betting that at runtime we
29354:      * will get integer results again.
29354:      */
29354:     VMSideExit* exit;
29354:     LIns* result;
29354:     switch (v) {
33095: #if defined NANOJIT_IA32 || defined NANOJIT_X64
29354:       case LIR_fdiv:
21799:         if (d0->isconst() && d1->isconst())
21799:             return lir->ins1(LIR_i2f, lir->insImm(jsint(r)));
29354: 
29354:         exit = snapshot(OVERFLOW_EXIT);
29354: 
32569:         /*
32569:          * If the divisor is greater than zero its always safe to execute
32569:          * the division. If not, we have to make sure we are not running
32569:          * into -2147483648 / -1, because it can raise an overflow exception.
32569:          */
32569:         if (!d1->isconst()) {
32569:             LIns* gt = lir->insBranch(LIR_jt, lir->ins2i(LIR_gt, d1, 0), NULL);
29354:             guard(false, lir->ins_eq0(d1), exit);
32569:             guard(false, lir->ins2(LIR_and,
32571:                                    lir->ins2i(LIR_eq, d0, 0x80000000),
32569:                                    lir->ins2i(LIR_eq, d1, -1)), exit);
32569:             gt->setTarget(lir->ins0(LIR_label));
32569:         } else {
32569:             if (d1->imm32() == -1)
32571:                 guard(false, lir->ins2i(LIR_eq, d0, 0x80000000), exit);
32569:         }
29354:         result = lir->ins2(v = LIR_div, d0, d1);
29354: 
38497:         /* As long as the modulus is zero, the result is an integer. */
29354:         guard(true, lir->ins_eq0(lir->ins1(LIR_mod, result)), exit);
30860: 
30860:         /* Don't lose a -0. */
30260:         guard(false, lir->ins_eq0(result), exit);
29354:         break;
30860: 
29354:       case LIR_fmod: {
29354:         if (d0->isconst() && d1->isconst())
29354:             return lir->ins1(LIR_i2f, lir->insImm(jsint(r)));
29354: 
29354:         exit = snapshot(OVERFLOW_EXIT);
29354: 
30860:         /* Make sure we don't trigger division by zero at runtime. */
29354:         if (!d1->isconst())
29354:             guard(false, lir->ins_eq0(d1), exit);
29354:         result = lir->ins1(v = LIR_mod, lir->ins2(LIR_div, d0, d1));
29354: 
30860:         /* If the result is not 0, it is always within the integer domain. */
29354:         LIns* branch = lir->insBranch(LIR_jf, lir->ins_eq0(result), NULL);
29354: 
29354:         /*
29354:          * If the result is zero, we must exit if the lhs is negative since
29354:          * the result is -0 in this case, which is not in the integer domain.
29354:          */
34335:         guard(false, lir->ins2i(LIR_lt, d0, 0), exit);
29354:         branch->setTarget(lir->ins0(LIR_label));
29354:         break;
29354:       }
29354: #endif
30860: 
29354:       default:
36392:         v = f64arith_to_i32arith(v);
38603:         JS_ASSERT(v == LIR_add || v == LIR_mul || v == LIR_sub);
38603: 
38603:         /*
38603:          * If the operands guarantee that the result will be an integer (e.g.
38603:          * z = x * y with 0 <= (x|y) <= 0xffff guarantees z <= fffe0001), we
29354:          * don't have to guard against an overflow. Otherwise we emit a guard
29354:          * that will inform the oracle and cause a non-demoted trace to be
29354:          * attached that uses floating-point math for this operation.
29354:          */
38603:         if (!IsOverflowSafe(v, d0) || !IsOverflowSafe(v, d1)) {
29373:             exit = snapshot(OVERFLOW_EXIT);
38603:             result = guard_xov(v, d0, d1, exit);
29373:             if (v == LIR_mul) // make sure we don't lose a -0
29373:                 guard(false, lir->ins_eq0(result), exit);
38603:         } else {
38603:             result = lir->ins2(v, d0, d1);
29373:         }
29354:         break;
29354:     }
29354:     JS_ASSERT_IF(d0->isconst() && d1->isconst(),
29354:                  result->isconst() && result->imm32() == jsint(r));
21799:     return lir->ins1(LIR_i2f, result);
21799: }
21799: 
21799: LIns*
40307: TraceRecorder::i2f(LIns* i)
40307: {
40307:     return lir->ins1(LIR_i2f, i);
40307: }
40307: 
40307: LIns*
21799: TraceRecorder::f2i(LIns* f)
17469: {
36402:     if (f->isconstf())
36402:         return lir->insImm(js_DoubleToECMAInt32(f->imm64f()));
36402:     if (isfop(f, LIR_i2f) || isfop(f, LIR_u2f))
36402:         return foprnd1(f);
36402:     if (isfop(f, LIR_fadd) || isfop(f, LIR_fsub)) {
36402:         LIns* lhs = foprnd1(f);
36402:         LIns* rhs = foprnd2(f);
36402:         if (isPromote(lhs) && isPromote(rhs)) {
36402:             LOpcode op = f64arith_to_i32arith(f->opcode());
36402:             return lir->ins2(op, demote(lir, lhs), demote(lir, rhs));
36402:         }
36402:     }
36402:     if (f->isCall()) {
36402:         const CallInfo* ci = f->callInfo();
36402:         if (ci == &js_UnboxDouble_ci) {
36402:             LIns* args[] = { fcallarg(f, 0) };
36402:             return lir->insCall(&js_UnboxInt32_ci, args);
36403:         }
36403:         if (ci == &js_StringToNumber_ci) {
36402:             LIns* args[] = { fcallarg(f, 1), fcallarg(f, 0) };
36402:             return lir->insCall(&js_StringToInt32_ci, args);
36403:         }
36403:         if (ci == &js_String_p_charCodeAt0_ci) {
36402:             // Use a fast path builtin for a charCodeAt that converts to an int right away.
37012:             LIns* args[] = { fcallarg(f, 0) };
36402:             return lir->insCall(&js_String_p_charCodeAt0_int_ci, args);
36403:         }
36403:         if (ci == &js_String_p_charCodeAt_ci) {
36402:             LIns* idx = fcallarg(f, 1);
36661:             if (isPromote(idx)) {
36661:                 LIns* args[] = { demote(lir, idx), fcallarg(f, 0) };
36661:                 return lir->insCall(&js_String_p_charCodeAt_int_int_ci, args);
37685:             }
36402:             LIns* args[] = { idx, fcallarg(f, 0) };
36661:             return lir->insCall(&js_String_p_charCodeAt_double_int_ci, args);
36661:         }
36402:     }
20915:     return lir->insCall(&js_DoubleToInt32_ci, &f);
17469: }
17469: 
36402: LIns*
36402: TraceRecorder::f2u(LIns* f)
36402: {
36402:     if (f->isconstf())
36402:         return lir->insImm(js_DoubleToECMAUint32(f->imm64f()));
36402:     if (isfop(f, LIR_i2f) || isfop(f, LIR_u2f))
36402:         return foprnd1(f);
36402:     return lir->insCall(&js_DoubleToUint32_ci, &f);
36402: }
36402: 
22652: JS_REQUIRES_STACK LIns*
21799: TraceRecorder::makeNumberInt32(LIns* f)
19979: {
37748:     JS_ASSERT(f->isF64());
19979:     LIns* x;
19979:     if (!isPromote(f)) {
19979:         x = f2i(f);
19979:         guard(true, lir->ins2(LIR_feq, f, lir->ins1(LIR_i2f, x)), MISMATCH_EXIT);
19979:     } else {
37741:         x = demote(lir, f);
19979:     }
19979:     return x;
19979: }
19979: 
23456: JS_REQUIRES_STACK LIns*
21685: TraceRecorder::stringify(jsval& v)
21685: {
21685:     LIns* v_ins = get(&v);
21447:     if (JSVAL_IS_STRING(v))
21447:         return v_ins;
21447: 
21447:     LIns* args[] = { v_ins, cx_ins };
21447:     const CallInfo* ci;
21447:     if (JSVAL_IS_NUMBER(v)) {
21447:         ci = &js_NumberToString_ci;
40307:     } else if (JSVAL_IS_VOID(v)) {
40307:         /* N.B. void is JSVAL_SPECIAL. */
40307:         return INS_ATOM(cx->runtime->atomState.booleanAtoms[2]);
31521:     } else if (JSVAL_IS_SPECIAL(v)) {
40307:         JS_ASSERT(JSVAL_IS_BOOLEAN(v));
40307:         ci = &js_BooleanIntToString_ci;
21447:     } else {
26036:         /*
26036:          * Callers must deal with non-primitive (non-null object) values by
26036:          * calling an imacro. We don't try to guess about which imacro, with
26036:          * what valueOf hint, here.
26036:          */
26036:         JS_ASSERT(JSVAL_IS_NULL(v));
31843:         return INS_ATOM(cx->runtime->atomState.nullAtom);
26036:     }
26036: 
21447:     v_ins = lir->insCall(ci, args);
32746:     guard(false, lir->ins_peq0(v_ins), OOM_EXIT);
21447:     return v_ins;
21447: }
21447: 
33542: JS_REQUIRES_STACK RecordingStatus
21685: TraceRecorder::call_imacro(jsbytecode* imacro)
21685: {
21685:     JSStackFrame* fp = cx->fp;
21685:     JSFrameRegs* regs = fp->regs;
21685: 
38641:     /* We cannot nest imacros. */
38641:     if (fp->imacpc)
33542:         return RECORD_STOP;
27933: 
21685:     fp->imacpc = regs->pc;
21685:     regs->pc = imacro;
21685:     atoms = COMMON_ATOMS_START(&cx->runtime->atomState);
33542:     return RECORD_IMACRO;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
20416: TraceRecorder::ifop()
17452: {
17452:     jsval& v = stackval(-1);
19604:     LIns* v_ins = get(&v);
20410:     bool cond;
20410:     LIns* x;
23075: 
26753:     if (JSVAL_IS_NULL(v)) {
26753:         cond = false;
26753:         x = lir->insImm(0);
26753:     } else if (!JSVAL_IS_PRIMITIVE(v)) {
26557:         cond = true;
26557:         x = lir->insImm(1);
31521:     } else if (JSVAL_IS_SPECIAL(v)) {
23075:         /* Test for boolean is true, negate later if we are testing for false. */
31521:         cond = JSVAL_TO_SPECIAL(v) == JS_TRUE;
20410:         x = lir->ins2i(LIR_eq, v_ins, 1);
17749:     } else if (isNumber(v)) {
17749:         jsdouble d = asNumber(v);
20411:         cond = !JSDOUBLE_IS_NaN(d) && d;
20410:         x = lir->ins2(LIR_and,
20410:                       lir->ins2(LIR_feq, v_ins, v_ins),
32640:                       lir->ins_eq0(lir->ins2(LIR_feq, v_ins, lir->insImmf(0))));
17749:     } else if (JSVAL_IS_STRING(v)) {
29366:         cond = JSVAL_TO_STRING(v)->length() != 0;
40353:         x = lir->insLoad(LIR_ldp, v_ins, offsetof(JSString, mLength), ACC_OTHER);
17452:     } else {
17927:         JS_NOT_REACHED("ifop");
33542:         return ARECORD_STOP;
20410:     }
26557: 
26557:     jsbytecode* pc = cx->fp->regs->pc;
26557:     emitIf(pc, cond, x);
26557:     return checkTraceEnd(pc);
17452: }
17452: 
25099: #ifdef NANOJIT_IA32
30860: /*
30860:  * Record LIR for a tableswitch or tableswitchx op. We record LIR only the
30860:  * "first" time we hit the op. Later, when we start traces after exiting that
30860:  * trace, we just patch.
30860:  */
33542: JS_REQUIRES_STACK AbortableRecordingStatus
25099: TraceRecorder::tableswitch()
25099: {
25099:     jsval& v = stackval(-1);
31060: 
31060:     /* No need to guard if the condition can't match any of the cases. */
25107:     if (!isNumber(v))
33542:         return ARECORD_CONTINUE;
25107: 
30860:     /* No need to guard if the condition is constant. */
25107:     LIns* v_ins = f2i(get(&v));
40387:     if (v_ins->isconst())
33542:         return ARECORD_CONTINUE;
25099: 
25099:     jsbytecode* pc = cx->fp->regs->pc;
25099:     /* Starting a new trace after exiting a trace via switch. */
26011:     if (anchor &&
26011:         (anchor->exitType == CASE_EXIT || anchor->exitType == DEFAULT_EXIT) &&
26011:         fragment->ip == pc) {
33542:         return ARECORD_CONTINUE;
26011:     }
25099: 
25099:     /* Decode jsop. */
25099:     jsint low, high;
25099:     if (*pc == JSOP_TABLESWITCH) {
25099:         pc += JUMP_OFFSET_LEN;
25099:         low = GET_JUMP_OFFSET(pc);
25099:         pc += JUMP_OFFSET_LEN;
25099:         high = GET_JUMP_OFFSET(pc);
25099:     } else {
25099:         pc += JUMPX_OFFSET_LEN;
25099:         low = GET_JUMPX_OFFSET(pc);
25099:         pc += JUMPX_OFFSET_LEN;
25099:         high = GET_JUMPX_OFFSET(pc);
25099:     }
25099: 
34322:     /* Cap maximum table-switch size for modesty. */
34322:     if ((high + 1 - low) > MAX_TABLE_SWITCH)
33542:         return InjectStatus(switchop());
25099: 
25099:     /* Generate switch LIR. */
34351:     SwitchInfo* si = new (traceAlloc()) SwitchInfo();
25099:     si->count = high + 1 - low;
25099:     si->table = 0;
25099:     si->index = (uint32) -1;
25107:     LIns* diff = lir->ins2(LIR_sub, v_ins, lir->insImm(low));
25099:     LIns* cmp = lir->ins2(LIR_ult, diff, lir->insImm(si->count));
27540:     lir->insGuard(LIR_xf, cmp, createGuardRecord(snapshot(DEFAULT_EXIT)));
40353:     lir->insStorei(diff, lir->insImmPtr(&si->index), 0, ACC_OTHER);
27540:     VMSideExit* exit = snapshot(CASE_EXIT);
27540:     exit->switchInfo = si;
31060:     LIns* guardIns = lir->insGuard(LIR_xtbl, diff, createGuardRecord(exit));
31060:     fragment->lastIns = guardIns;
35083:     CHECK_STATUS_A(compile());
35083:     return finishSuccessfully();
25099: }
25099: #endif
25099: 
31521: static JS_ALWAYS_INLINE int32_t
31521: UnboxBooleanOrUndefined(jsval v)
31521: {
31521:     /* Although this says 'special', we really only expect 3 special values: */
31521:     JS_ASSERT(v == JSVAL_TRUE || v == JSVAL_FALSE || v == JSVAL_VOID);
31521:     return JSVAL_TO_SPECIAL(v);
31521: }
31521: 
33542: JS_REQUIRES_STACK RecordingStatus
18687: TraceRecorder::switchop()
18687: {
18687:     jsval& v = stackval(-1);
19604:     LIns* v_ins = get(&v);
30860: 
30860:     /* No need to guard if the condition is constant. */
40387:     if (v_ins->isImmAny())
33542:         return RECORD_CONTINUE;
18687:     if (isNumber(v)) {
18687:         jsdouble d = asNumber(v);
18687:         guard(true,
26265:               addName(lir->ins2(LIR_feq, v_ins, lir->insImmf(d)),
18687:                       "guard(switch on numeric)"),
18687:               BRANCH_EXIT);
18687:     } else if (JSVAL_IS_STRING(v)) {
34848:         LIns* args[] = { INS_CONSTSTR(JSVAL_TO_STRING(v)), v_ins };
18687:         guard(true,
20915:               addName(lir->ins_eq0(lir->ins_eq0(lir->insCall(&js_EqualStrings_ci, args))),
18687:                       "guard(switch on string)"),
18687:               BRANCH_EXIT);
31521:     } else if (JSVAL_IS_SPECIAL(v)) {
18687:         guard(true,
31521:               addName(lir->ins2(LIR_eq, v_ins, lir->insImm(UnboxBooleanOrUndefined(v))),
18687:                       "guard(switch on boolean)"),
18687:               BRANCH_EXIT);
18687:     } else {
33542:         RETURN_STOP("switch on object or null");
33542:     }
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
17412: TraceRecorder::inc(jsval& v, jsint incr, bool pre)
17412: {
17782:     LIns* v_ins = get(&v);
27933:     CHECK_STATUS(inc(v, v_ins, incr, pre));
17782:     set(&v, v_ins);
33542:     return RECORD_CONTINUE;
17782: }
17782: 
17782: /*
30860:  * On exit, v_ins is the incremented unboxed value, and the appropriate value
30860:  * (pre- or post-increment as described by pre) is stacked.
17782:  */
33542: JS_REQUIRES_STACK RecordingStatus
31480: TraceRecorder::inc(jsval v, LIns*& v_ins, jsint incr, bool pre)
31480: {
31480:     LIns* v_after;
31480:     CHECK_STATUS(incHelper(v, v_ins, v_after, incr));
17544: 
17544:     const JSCodeSpec& cs = js_CodeSpec[*cx->fp->regs->pc];
17544:     JS_ASSERT(cs.ndefs == 1);
17782:     stack(-cs.nuses, pre ? v_after : v_ins);
17782:     v_ins = v_after;
33542:     return RECORD_CONTINUE;
27933: }
27933: 
31480: /*
31480:  * Do an increment operation without storing anything to the stack.
31480:  */
33542: JS_REQUIRES_STACK RecordingStatus
31480: TraceRecorder::incHelper(jsval v, LIns* v_ins, LIns*& v_after, jsint incr)
31480: {
31480:     if (!isNumber(v))
33542:         RETURN_STOP("can only inc numbers");
31480:     v_after = alu(LIR_fadd, asNumber(v), incr, v_ins, lir->insImmf(incr));
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17758: TraceRecorder::incProp(jsint incr, bool pre)
17758: {
17758:     jsval& l = stackval(-1);
17758:     if (JSVAL_IS_PRIMITIVE(l))
33542:         RETURN_STOP_A("incProp on primitive");
17758: 
17758:     JSObject* obj = JSVAL_TO_OBJECT(l);
17758:     LIns* obj_ins = get(&l);
17758: 
17761:     uint32 slot;
17758:     LIns* v_ins;
33542:     CHECK_STATUS_A(prop(obj, obj_ins, &slot, &v_ins, NULL));
17761: 
18666:     if (slot == SPROP_INVALID_SLOT)
33542:         RETURN_STOP_A("incProp on invalid slot");
18666: 
40410:     jsval& v = obj->getSlotRef(slot);
33542:     CHECK_STATUS_A(inc(v, v_ins, incr, pre));
17761: 
17761:     LIns* dslots_ins = NULL;
31902:     stobj_set_slot(obj_ins, slot, dslots_ins, box_jsval(v, v_ins));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
17758: TraceRecorder::incElem(jsint incr, bool pre)
17758: {
17758:     jsval& r = stackval(-1);
17758:     jsval& l = stackval(-2);
17758:     jsval* vp;
17758:     LIns* v_ins;
17782:     LIns* addr_ins;
28411: 
33129:     if (JSVAL_IS_PRIMITIVE(l) || !JSVAL_IS_INT(r) ||
40353:         !guardDenseArray(JSVAL_TO_OBJECT(l), get(&l), MISMATCH_EXIT)) {
33542:         return RECORD_STOP;
28411:     }
28411: 
28411:     CHECK_STATUS(denseArrayElement(l, r, vp, v_ins, addr_ins));
20972:     if (!addr_ins) // if we read a hole, abort
33542:         return RECORD_STOP;
27933:     CHECK_STATUS(inc(*vp, v_ins, incr, pre));
40353:     lir->insStorei(box_jsval(*vp, v_ins), addr_ins, 0, ACC_OTHER);
33542:     return RECORD_CONTINUE;
17412: }
17412: 
19576: static bool
30860: EvalCmp(LOpcode op, double l, double r)
19576: {
18017:     bool cond;
18017:     switch (op) {
19576:       case LIR_feq:
30859:         cond = (l == r);
19576:         break;
18017:       case LIR_flt:
30859:         cond = l < r;
18017:         break;
18017:       case LIR_fgt:
30859:         cond = l > r;
18017:         break;
18017:       case LIR_fle:
30859:         cond = l <= r;
18017:         break;
18017:       case LIR_fge:
30859:         cond = l >= r;
18017:         break;
18017:       default:
19576:         JS_NOT_REACHED("unexpected comparison op");
19576:         return false;
19576:     }
19576:     return cond;
19576: }
19576: 
19576: static bool
30860: EvalCmp(LOpcode op, JSString* l, JSString* r)
19576: {
19576:     if (op == LIR_feq)
33166:         return !!js_EqualStrings(l, r);
30860:     return EvalCmp(op, js_CompareStrings(l, r), 0);
19576: }
19576: 
22705: JS_REQUIRES_STACK void
23093: TraceRecorder::strictEquality(bool equal, bool cmpCase)
22705: {
22705:     jsval& r = stackval(-1);
22705:     jsval& l = stackval(-2);
22705:     LIns* l_ins = get(&l);
22705:     LIns* r_ins = get(&r);
23115:     LIns* x;
23115:     bool cond;
22705: 
37741:     TraceType ltag = GetPromotedType(l);
30860:     if (ltag != GetPromotedType(r)) {
23115:         cond = !equal;
23115:         x = lir->insImm(cond);
29896:     } else if (ltag == TT_STRING) {
22705:         LIns* args[] = { r_ins, l_ins };
22705:         x = lir->ins2i(LIR_eq, lir->insCall(&js_EqualStrings_ci, args), equal);
33166:         cond = !!js_EqualStrings(JSVAL_TO_STRING(l), JSVAL_TO_STRING(r));
22705:     } else {
32746:         LOpcode op;
32746:         if (ltag == TT_DOUBLE)
32746:             op = LIR_feq;
32746:         else if (ltag == TT_NULL || ltag == TT_OBJECT || ltag == TT_FUNCTION)
32746:             op = LIR_peq;
32746:         else
32746:             op = LIR_eq;
22705:         x = lir->ins2(op, l_ins, r_ins);
22705:         if (!equal)
22705:             x = lir->ins_eq0(x);
29896:         cond = (ltag == TT_DOUBLE)
23118:                ? asNumber(l) == asNumber(r)
23117:                : l == r;
23093:     }
23093:     cond = (cond == equal);
23093: 
23093:     if (cmpCase) {
23093:         /* Only guard if the same path may not always be taken. */
23093:         if (!x->isconst())
23093:             guard(cond, x, BRANCH_EXIT);
23093:         return;
22705:     }
22705: 
22705:     set(&l, x);
22705: }
22705: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
23093: TraceRecorder::equality(bool negate, bool tryBranchAfterCond)
19576: {
23223:     jsval& rval = stackval(-1);
23223:     jsval& lval = stackval(-2);
23223:     LIns* l_ins = get(&lval);
23223:     LIns* r_ins = get(&rval);
23223: 
23223:     return equalityHelper(lval, rval, l_ins, r_ins, negate, tryBranchAfterCond, lval);
23223: }
23223: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
23223: TraceRecorder::equalityHelper(jsval l, jsval r, LIns* l_ins, LIns* r_ins,
23223:                               bool negate, bool tryBranchAfterCond,
23223:                               jsval& rval)
23223: {
32746:     LOpcode op = LIR_eq;
19576:     bool cond;
23223:     LIns* args[] = { NULL, NULL };
23223: 
23223:     /*
23223:      * The if chain below closely mirrors that found in 11.9.3, in general
23223:      * deviating from that ordering of ifs only to account for SpiderMonkey's
23223:      * conflation of booleans and undefined and for the possibility of
23223:      * confusing objects and null.  Note carefully the spec-mandated recursion
23223:      * in the final else clause, which terminates because Number == T recurs
23223:      * only if T is Object, but that must recur again to convert Object to
23223:      * primitive, and ToPrimitive throws if the object cannot be converted to
23223:      * a primitive value (which would terminate recursion).
23223:      */
23223: 
30860:     if (GetPromotedType(l) == GetPromotedType(r)) {
40307:         if (JSVAL_IS_VOID(l) || JSVAL_IS_NULL(l)) {
40307:             cond = true;
40308:             if (JSVAL_IS_NULL(l))
40308:                 op = LIR_peq;
40307:         } else if (JSVAL_IS_OBJECT(l)) {
35473:             JSClass *clasp = OBJ_GET_CLASS(cx, JSVAL_TO_OBJECT(l));
35473:             if ((clasp->flags & JSCLASS_IS_EXTENDED) && ((JSExtendedClass*) clasp)->equality)
35473:                 RETURN_STOP_A("Can't trace extended class equality operator");
32746:             op = LIR_peq;
23223:             cond = (l == r);
40307:         } else if (JSVAL_IS_SPECIAL(l)) {
40307:             JS_ASSERT(JSVAL_IS_BOOLEAN(l) && JSVAL_IS_BOOLEAN(r));
40307:             cond = (l == r);
23223:         } else if (JSVAL_IS_STRING(l)) {
23223:             args[0] = r_ins, args[1] = l_ins;
23223:             l_ins = lir->insCall(&js_EqualStrings_ci, args);
23223:             r_ins = lir->insImm(1);
33166:             cond = !!js_EqualStrings(JSVAL_TO_STRING(l), JSVAL_TO_STRING(r));
21719:         } else {
23223:             JS_ASSERT(isNumber(l) && isNumber(r));
23223:             cond = (asNumber(l) == asNumber(r));
32746:             op = LIR_feq;
23223:         }
40307:     } else if (JSVAL_IS_NULL(l) && JSVAL_IS_VOID(r)) {
40294:         l_ins = INS_VOID();
40307:         cond = true;
40307:     } else if (JSVAL_IS_VOID(l) && JSVAL_IS_NULL(r)) {
40294:         r_ins = INS_VOID();
40307:         cond = true;
23223:     } else if (isNumber(l) && JSVAL_IS_STRING(r)) {
23223:         args[0] = r_ins, args[1] = cx_ins;
23223:         r_ins = lir->insCall(&js_StringToNumber_ci, args);
23223:         cond = (asNumber(l) == js_StringToNumber(cx, JSVAL_TO_STRING(r)));
32746:         op = LIR_feq;
23223:     } else if (JSVAL_IS_STRING(l) && isNumber(r)) {
23223:         args[0] = l_ins, args[1] = cx_ins;
20915:         l_ins = lir->insCall(&js_StringToNumber_ci, args);
23223:         cond = (js_StringToNumber(cx, JSVAL_TO_STRING(l)) == asNumber(r));
32746:         op = LIR_feq;
23223:     } else {
40307:         if (JSVAL_IS_BOOLEAN(l)) {
40307:             l_ins = i2f(l_ins);
40307:             l = INT_TO_JSVAL(l == JSVAL_TRUE);
23223:             return equalityHelper(l, r, l_ins, r_ins, negate,
23223:                                   tryBranchAfterCond, rval);
23223:         }
40307:         if (JSVAL_IS_BOOLEAN(r)) {
40307:             r_ins = i2f(r_ins);
40307:             r = INT_TO_JSVAL(r == JSVAL_TRUE);
23223:             return equalityHelper(l, r, l_ins, r_ins, negate,
23223:                                   tryBranchAfterCond, rval);
23223:         }
28175:         if ((JSVAL_IS_STRING(l) || isNumber(l)) && !JSVAL_IS_PRIMITIVE(r)) {
33542:             RETURN_IF_XML_A(r);
33542:             return InjectStatus(call_imacro(equality_imacros.any_obj));
28175:         }
28175:         if (!JSVAL_IS_PRIMITIVE(l) && (JSVAL_IS_STRING(r) || isNumber(r))) {
33542:             RETURN_IF_XML_A(l);
33542:             return InjectStatus(call_imacro(equality_imacros.obj_any));
25478:         }
23223: 
23223:         l_ins = lir->insImm(0);
23223:         r_ins = lir->insImm(1);
23223:         cond = false;
23223:     }
23223: 
23223:     /* If the operands aren't numbers, compare them as integers. */
23223:     LIns* x = lir->ins2(op, l_ins, r_ins);
22705:     if (negate) {
22705:         x = lir->ins_eq0(x);
22705:         cond = !cond;
22705:     }
22705: 
26557:     jsbytecode* pc = cx->fp->regs->pc;
26557: 
22705:     /*
26118:      * Don't guard if the same path is always taken.  If it isn't, we have to
26118:      * fuse comparisons and the following branch, because the interpreter does
26118:      * that.
22705:      */
26557:     if (tryBranchAfterCond)
26557:         fuseIf(pc + 1, cond, x);
26557: 
26557:     /*
26557:      * There is no need to write out the result of this comparison if the trace
26557:      * ends on this operation.
26557:      */
27933:     if (pc[1] == JSOP_IFNE || pc[1] == JSOP_IFEQ)
33542:         CHECK_STATUS_A(checkTraceEnd(pc + 1));
22705: 
22705:     /*
22705:      * We update the stack after the guard. This is safe since the guard bails
22705:      * out at the comparison and the interpreter will therefore re-execute the
22705:      * comparison. This way the value of the condition doesn't have to be
22705:      * calculated and saved on the stack in most cases.
22705:      */
23223:     set(&rval, x);
26557: 
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
23093: TraceRecorder::relational(LOpcode op, bool tryBranchAfterCond)
22705: {
22705:     jsval& r = stackval(-1);
22705:     jsval& l = stackval(-2);
22705:     LIns* x = NULL;
22705:     bool cond;
22705:     LIns* l_ins = get(&l);
22705:     LIns* r_ins = get(&r);
22705:     bool fp = false;
22705:     jsdouble lnum, rnum;
22705: 
22705:     /*
22705:      * 11.8.5 if either argument is an object with a function-valued valueOf
22705:      * property; if both arguments are objects with non-function-valued valueOf
22705:      * properties, abort.
22705:      */
23075:     if (!JSVAL_IS_PRIMITIVE(l)) {
33542:         RETURN_IF_XML_A(l);
28175:         if (!JSVAL_IS_PRIMITIVE(r)) {
33542:             RETURN_IF_XML_A(r);
33542:             return InjectStatus(call_imacro(binary_imacros.obj_obj));
33542:         }
33542:         return InjectStatus(call_imacro(binary_imacros.obj_any));
22705:     }
28175:     if (!JSVAL_IS_PRIMITIVE(r)) {
33542:         RETURN_IF_XML_A(r);
33542:         return InjectStatus(call_imacro(binary_imacros.any_obj));
28175:     }
22705: 
22705:     /* 11.8.5 steps 3, 16-21. */
22705:     if (JSVAL_IS_STRING(l) && JSVAL_IS_STRING(r)) {
22705:         LIns* args[] = { r_ins, l_ins };
22705:         l_ins = lir->insCall(&js_CompareStrings_ci, args);
22705:         r_ins = lir->insImm(0);
30860:         cond = EvalCmp(op, JSVAL_TO_STRING(l), JSVAL_TO_STRING(r));
22705:         goto do_comparison;
22705:     }
22705: 
22705:     /* 11.8.5 steps 4-5. */
22705:     if (!JSVAL_IS_NUMBER(l)) {
22705:         LIns* args[] = { l_ins, cx_ins };
22705:         switch (JSVAL_TAG(l)) {
31521:           case JSVAL_SPECIAL:
40307:             if (JSVAL_IS_VOID(l))
40307:                 l_ins = lir->insImmf(js_NaN);
40307:             else
40307:                 l_ins = i2f(l_ins);
22705:             break;
22705:           case JSVAL_STRING:
22705:             l_ins = lir->insCall(&js_StringToNumber_ci, args);
22705:             break;
23075:           case JSVAL_OBJECT:
23075:             if (JSVAL_IS_NULL(l)) {
29354:                 l_ins = lir->insImmf(0.0);
23075:                 break;
23075:             }
23075:             // FALL THROUGH
22705:           case JSVAL_INT:
22705:           case JSVAL_DOUBLE:
22705:           default:
22705:             JS_NOT_REACHED("JSVAL_IS_NUMBER if int/double, objects should "
22705:                            "have been handled at start of method");
33542:             RETURN_STOP_A("safety belt");
22705:         }
22705:     }
22705:     if (!JSVAL_IS_NUMBER(r)) {
22705:         LIns* args[] = { r_ins, cx_ins };
22705:         switch (JSVAL_TAG(r)) {
31521:           case JSVAL_SPECIAL:
40307:             if (JSVAL_IS_VOID(r))
40307:                 r_ins = lir->insImmf(js_NaN);
40307:             else
40307:                 r_ins = i2f(r_ins);
22705:             break;
22705:           case JSVAL_STRING:
22705:             r_ins = lir->insCall(&js_StringToNumber_ci, args);
22705:             break;
23075:           case JSVAL_OBJECT:
23075:             if (JSVAL_IS_NULL(r)) {
29354:                 r_ins = lir->insImmf(0.0);
23075:                 break;
23075:             }
23075:             // FALL THROUGH
22705:           case JSVAL_INT:
22705:           case JSVAL_DOUBLE:
22705:           default:
22705:             JS_NOT_REACHED("JSVAL_IS_NUMBER if int/double, objects should "
22705:                            "have been handled at start of method");
33542:             RETURN_STOP_A("safety belt");
22705:         }
22705:     }
22705:     {
40403:         AutoValueRooter tvr(cx, JSVAL_NULL);
40403: 
40403:         *tvr.addr() = l;
40403:         lnum = js_ValueToNumber(cx, tvr.addr());
40403:         *tvr.addr() = r;
40403:         rnum = js_ValueToNumber(cx, tvr.addr());
22705:     }
30860:     cond = EvalCmp(op, lnum, rnum);
22705:     fp = true;
22705: 
22705:     /* 11.8.5 steps 6-15. */
22705:   do_comparison:
30860:     /*
30860:      * If the result is not a number or it's not a quad, we must use an integer
30860:      * compare.
30860:      */
22651:     if (!fp) {
39901:         JS_ASSERT(isFCmpOpcode(op));
40428:         op = f64cmp_to_i32cmp(op);
22651:     }
22650:     x = lir->ins2(op, l_ins, r_ins);
22705: 
26557:     jsbytecode* pc = cx->fp->regs->pc;
26557: 
22705:     /*
26118:      * Don't guard if the same path is always taken.  If it isn't, we have to
26118:      * fuse comparisons and the following branch, because the interpreter does
26118:      * that.
22705:      */
26557:     if (tryBranchAfterCond)
26557:         fuseIf(pc + 1, cond, x);
26557: 
26557:     /*
26557:      * There is no need to write out the result of this comparison if the trace
26557:      * ends on this operation.
26557:      */
27933:     if (pc[1] == JSOP_IFNE || pc[1] == JSOP_IFEQ)
33542:         CHECK_STATUS_A(checkTraceEnd(pc + 1));
22705: 
22705:     /*
22705:      * We update the stack after the guard. This is safe since the guard bails
22705:      * out at the comparison and the interpreter will therefore re-execute the
22705:      * comparison. This way the value of the condition doesn't have to be
22705:      * calculated and saved on the stack in most cases.
22705:      */
17413:     set(&l, x);
26557: 
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
17467: TraceRecorder::unary(LOpcode op)
17467: {
17467:     jsval& v = stackval(-1);
36392:     bool intop = retTypes[op] == LTy_I32;
17467:     if (isNumber(v)) {
17467:         LIns* a = get(&v);
17467:         if (intop)
17469:             a = f2i(a);
17467:         a = lir->ins1(op, a);
17467:         if (intop)
17467:             a = lir->ins1(LIR_i2f, a);
17467:         set(&v, a);
33542:         return RECORD_CONTINUE;
33542:     }
33542:     return RECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
17467: TraceRecorder::binary(LOpcode op)
17467: {
17467:     jsval& r = stackval(-1);
17467:     jsval& l = stackval(-2);
21685: 
23075:     if (!JSVAL_IS_PRIMITIVE(l)) {
33542:         RETURN_IF_XML(l);
28175:         if (!JSVAL_IS_PRIMITIVE(r)) {
33542:             RETURN_IF_XML(r);
21685:             return call_imacro(binary_imacros.obj_obj);
28175:         }
21685:         return call_imacro(binary_imacros.obj_any);
21685:     }
28175:     if (!JSVAL_IS_PRIMITIVE(r)) {
33542:         RETURN_IF_XML(r);
21685:         return call_imacro(binary_imacros.any_obj);
28175:     }
21685: 
36392:     bool intop = retTypes[op] == LTy_I32;
17467:     LIns* a = get(&l);
17467:     LIns* b = get(&r);
21799: 
21799:     bool leftIsNumber = isNumber(l);
21799:     jsdouble lnum = leftIsNumber ? asNumber(l) : 0;
21799: 
21799:     bool rightIsNumber = isNumber(r);
21799:     jsdouble rnum = rightIsNumber ? asNumber(r) : 0;
21799: 
17910:     if (JSVAL_IS_STRING(l)) {
39901:         NanoAssert(op != LIR_fadd); // LIR_fadd/IS_STRING case handled by record_JSOP_ADD()
39901:         LIns* args[] = { a, cx_ins };
20915:         a = lir->insCall(&js_StringToNumber_ci, args);
21799:         lnum = js_StringToNumber(cx, JSVAL_TO_STRING(l));
21799:         leftIsNumber = true;
17910:     }
17910:     if (JSVAL_IS_STRING(r)) {
39901:         NanoAssert(op != LIR_fadd); // LIR_fadd/IS_STRING case handled by record_JSOP_ADD()
39901:         LIns* args[] = { b, cx_ins };
20915:         b = lir->insCall(&js_StringToNumber_ci, args);
21799:         rnum = js_StringToNumber(cx, JSVAL_TO_STRING(r));
21799:         rightIsNumber = true;
17910:     }
40307:     /* N.B. void is JSVAL_SPECIAL. */
31521:     if (JSVAL_IS_SPECIAL(l)) {
40307:         if (JSVAL_IS_VOID(l)) {
40307:             a = lir->insImmf(js_NaN);
40307:             lnum = js_NaN;
40307:         } else {
40307:             a = i2f(a);
40307:             lnum = JSVAL_TO_SPECIAL(l);
40307:         }
21799:         leftIsNumber = true;
20972:     }
31521:     if (JSVAL_IS_SPECIAL(r)) {
40307:         if (JSVAL_IS_VOID(r)) {
40307:             b = lir->insImmf(js_NaN);
40307:             rnum = js_NaN;
40307:         } else {
40307:             b = i2f(b);
40307:             rnum = JSVAL_TO_SPECIAL(r);
40307:         }
21799:         rightIsNumber = true;
21799:     }
21799:     if (leftIsNumber && rightIsNumber) {
17467:         if (intop) {
36402:             a = (op == LIR_ush) ? f2u(a) : f2i(a);
17469:             b = f2i(b);
17467:         }
21799:         a = alu(op, lnum, rnum, a, b);
17467:         if (intop)
17467:             a = lir->ins1(op == LIR_ush ? LIR_u2f : LIR_i2f, a);
17467:         set(&l, a);
33542:         return RECORD_CONTINUE;
33542:     }
33542:     return RECORD_STOP;
17467: }
17467: 
33560: #if defined DEBUG_notme && defined XP_UNIX
33560: #include <stdio.h>
33560: 
33560: static FILE* shapefp = NULL;
33560: 
33560: static void
33560: DumpShape(JSObject* obj, const char* prefix)
33560: {
33560:     JSScope* scope = OBJ_SCOPE(obj);
33560: 
33560:     if (!shapefp) {
33560:         shapefp = fopen("/tmp/shapes.dump", "w");
33560:         if (!shapefp)
33560:             return;
33560:     }
33560: 
33560:     fprintf(shapefp, "\n%s: shape %u flags %x\n", prefix, scope->shape, scope->flags);
35453:     for (JSScopeProperty* sprop = scope->lastProperty(); sprop; sprop = sprop->parent) {
33560:         if (JSID_IS_ATOM(sprop->id)) {
33560:             fprintf(shapefp, " %s", JS_GetStringBytes(JSVAL_TO_STRING(ID_TO_VALUE(sprop->id))));
33560:         } else {
33560:             JS_ASSERT(!JSID_IS_OBJECT(sprop->id));
33560:             fprintf(shapefp, " %d", JSID_TO_INT(sprop->id));
33560:         }
33560:         fprintf(shapefp, " %u %p %p %x %x %d\n",
33560:                 sprop->slot, sprop->getter, sprop->setter, sprop->attrs, sprop->flags,
33560:                 sprop->shortid);
33560:     }
33560:     fflush(shapefp);
33560: }
33560: 
32777: void
33560: TraceRecorder::dumpGuardedShapes(const char* prefix)
33560: {
38568:     for (GuardedShapeTable::Range r = guardedShapeTable.all(); !r.empty(); r.popFront())
38568:         DumpShape(r.front().value, prefix);
33560: }
33560: #endif /* DEBUG_notme && XP_UNIX */
33560: 
33560: JS_REQUIRES_STACK RecordingStatus
32777: TraceRecorder::guardShape(LIns* obj_ins, JSObject* obj, uint32 shape, const char* guardName,
40393:                           VMSideExit* exit)
32777: {
33560:     // Test (with add if missing) for a remembered guard for (obj_ins, obj).
38568:     GuardedShapeTable::AddPtr p = guardedShapeTable.lookupForAdd(obj_ins);
38568:     if (p) {
38568:         JS_ASSERT(p->value == obj);
38568:         return RECORD_CONTINUE;
38568:     } else {
38568:         if (!guardedShapeTable.add(p, obj_ins, obj))
33560:             return RECORD_ERROR;
33560:     }
33560: 
33560: #if defined DEBUG_notme && defined XP_UNIX
33560:     DumpShape(obj, "guard");
33560:     fprintf(shapefp, "for obj_ins %p\n", obj_ins);
33560: #endif
33560: 
33560:     // Finally, emit the shape guard.
40353:     LIns* shape_ins =
40393:         addName(lir->insLoad(LIR_ld, map(obj_ins), offsetof(JSScope, shape), ACC_OTHER), "shape");
32777:     guard(true,
32777:           addName(lir->ins2i(LIR_eq, shape_ins, shape), guardName),
32777:           exit);
33560:     return RECORD_CONTINUE;
33560: }
33560: 
38568: void
38568: TraceRecorder::forgetGuardedShapesForObject(JSObject* obj)
38568: {
39896:     for (GuardedShapeTable::Enum e(guardedShapeTable); !e.empty(); e.popFront()) {
38568:         if (e.front().value == obj) {
33560: #if defined DEBUG_notme && defined XP_UNIX
33560:             DumpShape(entry->obj, "forget");
33560: #endif
38568:             e.removeFront();
38568:         }
38568:     }
33560: }
33560: 
33560: void
33560: TraceRecorder::forgetGuardedShapes()
33560: {
33560: #if defined DEBUG_notme && defined XP_UNIX
33560:     dumpGuardedShapes("forget-all");
33560: #endif
38568:     guardedShapeTable.clear();
32777: }
32777: 
28353: JS_STATIC_ASSERT(offsetof(JSObjectOps, objectMap) == 0);
18026: 
30244: inline LIns*
30244: TraceRecorder::map(LIns* obj_ins)
30244: {
40353:     return addName(lir->insLoad(LIR_ldp, obj_ins, (int) offsetof(JSObject, map), ACC_OTHER), "map");
30244: }
30244: 
18026: bool
18026: TraceRecorder::map_is_native(JSObjectMap* map, LIns* map_ins, LIns*& ops_ins, size_t op_offset)
17899: {
28353:     JS_ASSERT(op_offset < sizeof(JSObjectOps));
28353:     JS_ASSERT(op_offset % sizeof(void *) == 0);
28353: 
28353: #define OP(ops) (*(void **) ((uint8 *) (ops) + op_offset))
28353:     void* ptr = OP(map->ops);
28353:     if (ptr != OP(&js_ObjectOps))
25636:         return false;
28353: #undef OP
28353: 
39910:     ops_ins = addName(lir->insLoad(LIR_ldp, map_ins, int(offsetof(JSObjectMap, ops)), ACC_READONLY),
39910:                       "ops");
39910:     LIns* n = lir->insLoad(LIR_ldp, ops_ins, op_offset, ACC_READONLY);
25636:     guard(true,
32746:           addName(lir->ins2(LIR_peq, n, INS_CONSTPTR(ptr)), "guard(native-map)"),
25636:           BRANCH_EXIT);
25636: 
25636:     return true;
17417: }
17417: 
39939: JS_REQUIRES_STACK AbortableRecordingStatus
40374: TraceRecorder::test_property_cache(JSObject* obj, LIns* obj_ins, JSObject*& obj2, PCVal& pcval)
17459: {
19093:     jsbytecode* pc = cx->fp->regs->pc;
32658:     JS_ASSERT(*pc != JSOP_INITPROP && *pc != JSOP_INITMETHOD &&
32658:               *pc != JSOP_SETNAME && *pc != JSOP_SETPROP && *pc != JSOP_SETMETHOD);
19093: 
18439:     // Mimic the interpreter's special case for dense arrays by skipping up one
18439:     // hop along the proto chain when accessing a named (not indexed) property,
18439:     // typically to find Array.prototype methods.
18026:     JSObject* aobj = obj;
39928:     if (obj->isDenseArray()) {
26754:         guardDenseArray(obj, obj_ins, BRANCH_EXIT);
39928:         aobj = obj->getProto();
32603:         obj_ins = stobj_get_proto(obj_ins);
18026:     }
18026: 
17459:     JSAtom* atom;
40362:     PropertyCacheEntry* entry;
40362:     JS_PROPERTY_CACHE(cx).test(cx, pc, aobj, obj2, entry, atom);
38504:     if (atom) {
18439:         // Miss: pre-fill the cache for the interpreter, as well as for our needs.
18439:         jsid id = ATOM_TO_JSID(atom);
17747:         JSProperty* prop;
19093:         if (JOF_OPMODE(*pc) == JOF_NAME) {
18112:             JS_ASSERT(aobj == obj);
33171: 
37741:             TraceMonitor &localtm = *traceMonitor;
27575:             entry = js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop);
27575: 
33171:             /* js_FindPropertyHelper can reenter the interpreter and kill |this|. */
33171:             if (!localtm.recorder)
33542:                 return ARECORD_ABORTED;
33171: 
27933:             if (!entry)
33542:                 RETURN_ERROR_A("error in js_FindPropertyHelper");
27933:             if (entry == JS_NO_PROP_CACHE_FILL)
33542:                 RETURN_STOP_A("cannot cache name");
17747:         } else {
37741:             TraceMonitor &localtm = *traceMonitor;
33171:             JSContext *localcx = cx;
19712:             int protoIndex = js_LookupPropertyWithFlags(cx, aobj, id,
19712:                                                         cx->resolveFlags,
19712:                                                         &obj2, &prop);
27575: 
33171:             /* js_LookupPropertyWithFlags can reenter the interpreter and kill |this|. */
33171:             if (!localtm.recorder) {
33171:                 if (prop)
33171:                     obj2->dropProperty(localcx, prop);
33542:                 return ARECORD_ABORTED;
33171:             }
33171: 
17878:             if (protoIndex < 0)
33542:                 RETURN_ERROR_A("error in js_LookupPropertyWithFlags");
17878: 
17998:             if (prop) {
40430:                 if (!obj2->isNative()) {
31501:                     obj2->dropProperty(cx, prop);
33542:                     RETURN_STOP_A("property found on non-native object");
26973:                 }
40362:                 entry = JS_PROPERTY_CACHE(cx).fill(cx, aobj, 0, protoIndex, obj2,
40327:                                                    (JSScopeProperty*) prop);
27575:                 JS_ASSERT(entry);
27575:                 if (entry == JS_NO_PROP_CACHE_FILL)
27575:                     entry = NULL;
17998:             }
33171: 
17998:         }
17998: 
17998:         if (!prop) {
17998:             // Propagate obj from js_FindPropertyHelper to record_JSOP_BINDNAME
18712:             // via our obj2 out-parameter. If we are recording JSOP_SETNAME and
18712:             // the global it's assigning does not yet exist, create it.
17998:             obj2 = obj;
19093: 
40374:             // Use a null pcval to return "no such property" to our caller.
40374:             pcval.setNull();
33542:             return ARECORD_CONTINUE;
17998:         }
17998: 
31501:         obj2->dropProperty(cx, prop);
18439:         if (!entry)
33542:             RETURN_STOP_A("failed to fill property cache");
17998:     }
17878: 
18439: #ifdef JS_THREADSAFE
18439:     // There's a potential race in any JS_THREADSAFE embedding that's nuts
18439:     // enough to share mutable objects on the scope or proto chain, but we
18439:     // don't care about such insane embeddings. Anyway, the (scope, proto)
18439:     // entry->vcap coordinates must reach obj2 from aobj at this point.
18439:     JS_ASSERT(cx->requestDepth);
18439: #endif
18439: 
40393:     return InjectStatus(guardPropertyCacheHit(obj_ins, aobj, obj2, entry, pcval));
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
30847: TraceRecorder::guardPropertyCacheHit(LIns* obj_ins,
30847:                                      JSObject* aobj,
30847:                                      JSObject* obj2,
40362:                                      PropertyCacheEntry* entry,
40374:                                      PCVal& pcval)
30847: {
32761:     VMSideExit* exit = snapshot(BRANCH_EXIT);
32761: 
40362:     uint32 vshape = entry->vshape();
38981: 
38531:     // Special case for the global object, which may be aliased to get a property value.
38531:     // To catch cross-global property accesses we must check against globalObj identity.
38531:     // But a JOF_NAME mode opcode needs no guard, as we ensure the global object's shape
38531:     // never changes, and name ops can't reach across a global object ('with' aborts).
38531:     if (aobj == globalObj) {
38531:         if (entry->adding())
38531:             RETURN_STOP("adding a property to the global object");
38531: 
38531:         JSOp op = js_GetOpcode(cx, cx->fp->script, cx->fp->regs->pc);
38531:         if (JOF_OPMODE(op) != JOF_NAME) {
38531:             guard(true,
38531:                   addName(lir->ins2(LIR_peq, obj_ins, INS_CONSTOBJ(globalObj)), "guard_global"),
38531:                   exit);
38531:         }
38531:     } else {
40393:         CHECK_STATUS(guardShape(obj_ins, aobj, entry->kshape, "guard_kshape", exit));
38531:     }
30847: 
30847:     if (entry->adding()) {
30847:         LIns *vshape_ins = addName(
30847:             lir->insLoad(LIR_ld,
40327:                          addName(lir->insLoad(LIR_ldp, cx_ins, offsetof(JSContext, runtime),
40327:                                               ACC_READONLY),
30847:                                  "runtime"),
40353:                          offsetof(JSRuntime, protoHazardShape), ACC_OTHER),
30847:             "protoHazardShape");
40327: 
30847:         guard(true,
30847:               addName(lir->ins2i(LIR_eq, vshape_ins, vshape), "guard_protoHazardShape"),
30847:               MISMATCH_EXIT);
30847:     }
18439: 
21685:     // For any hit that goes up the scope and/or proto chains, we will need to
18439:     // guard on the shape of the object containing the property.
40362:     if (entry->vcapTag() >= 1) {
19020:         JS_ASSERT(OBJ_SHAPE(obj2) == vshape);
38531:         if (obj2 == globalObj)
38531:             RETURN_STOP("hitting the global object via a prototype chain");
18439: 
20979:         LIns* obj2_ins;
40362:         if (entry->vcapTag() == 1) {
40362:             // Duplicate the special case in PropertyCache::test.
32603:             obj2_ins = addName(stobj_get_proto(obj_ins), "proto");
32761:             guard(false, lir->ins_peq0(obj2_ins), exit);
20979:         } else {
31843:             obj2_ins = INS_CONSTOBJ(obj2);
20979:         }
40393:         CHECK_STATUS(guardShape(obj2_ins, obj2, vshape, "guard_vshape", exit));
17878:     }
17747: 
18439:     pcval = entry->vword;
33542:     return RECORD_CONTINUE;
17459: }
17459: 
17429: void
31849: TraceRecorder::stobj_set_fslot(LIns *obj_ins, unsigned slot, LIns* v_ins)
31849: {
40353:     lir->insStorei(v_ins, obj_ins, offsetof(JSObject, fslots) + slot * sizeof(jsval), ACC_OTHER);
28554: }
28554: 
28554: void
31849: TraceRecorder::stobj_set_dslot(LIns *obj_ins, unsigned slot, LIns*& dslots_ins, LIns* v_ins)
22626: {
22626:     if (!dslots_ins)
40353:         dslots_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, dslots), ACC_OTHER);
40353:     lir->insStorei(v_ins, dslots_ins, slot * sizeof(jsval), ACC_OTHER);
22626: }
22626: 
22626: void
17429: TraceRecorder::stobj_set_slot(LIns* obj_ins, unsigned slot, LIns*& dslots_ins, LIns* v_ins)
17426: {
17487:     if (slot < JS_INITIAL_NSLOTS) {
31849:         stobj_set_fslot(obj_ins, slot, v_ins);
17487:     } else {
31849:         stobj_set_dslot(obj_ins, slot - JS_INITIAL_NSLOTS, dslots_ins, v_ins);
17429:     }
17426: }
17426: 
17459: LIns*
17899: TraceRecorder::stobj_get_fslot(LIns* obj_ins, unsigned slot)
17899: {
17899:     JS_ASSERT(slot < JS_INITIAL_NSLOTS);
40353:     return lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, fslots) + slot * sizeof(jsval),
40353:                         ACC_OTHER);
17899: }
17899: 
17899: LIns*
37776: TraceRecorder::stobj_get_const_fslot(LIns* obj_ins, unsigned slot)
37776: {
37776:     JS_ASSERT(slot < JS_INITIAL_NSLOTS);
39910:     return lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, fslots) + slot * sizeof(jsval),
39910:                         ACC_READONLY);
37776: }
37776: 
37776: LIns*
27012: TraceRecorder::stobj_get_dslot(LIns* obj_ins, unsigned index, LIns*& dslots_ins)
27012: {
27012:     if (!dslots_ins)
40353:         dslots_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, dslots), ACC_OTHER);
40353:     return lir->insLoad(LIR_ldp, dslots_ins, index * sizeof(jsval), ACC_OTHER);
27012: }
27012: 
27012: LIns*
26970: TraceRecorder::stobj_get_slot(LIns* obj_ins, unsigned slot, LIns*& dslots_ins)
26970: {
26970:     if (slot < JS_INITIAL_NSLOTS)
26970:         return stobj_get_fslot(obj_ins, slot);
27012:     return stobj_get_dslot(obj_ins, slot - JS_INITIAL_NSLOTS, dslots_ins);
17426: }
17426: 
31902: JS_REQUIRES_STACK LIns*
31902: TraceRecorder::box_jsval(jsval v, LIns* v_ins)
17468: {
17470:     if (isNumber(v)) {
37748:         JS_ASSERT(v_ins->isF64());
36402:         if (fcallinfo(v_ins) == &js_UnboxDouble_ci)
36402:             return fcallarg(v_ins, 0);
36402:         if (isPromoteInt(v_ins)) {
36402:             LIns* args[] = { demote(lir, v_ins), cx_ins };
36402:             return lir->insCall(&js_BoxInt32_ci, args);
36402:         }
17477:         LIns* args[] = { v_ins, cx_ins };
20915:         v_ins = lir->insCall(&js_BoxDouble_ci, args);
32747:         guard(false, lir->ins2(LIR_peq, v_ins, INS_CONSTWORD(JSVAL_ERROR_COOKIE)),
17850:               OOM_EXIT);
31902:         return v_ins;
17468:     }
17470:     switch (JSVAL_TAG(v)) {
31521:       case JSVAL_SPECIAL:
32746:         return lir->ins2(LIR_pior, lir->ins2i(LIR_pilsh, lir->ins_u2p(v_ins), JSVAL_TAGBITS),
32746:                          INS_CONSTWORD(JSVAL_SPECIAL));
18001:       case JSVAL_OBJECT:
31902:         return v_ins;
23708:       default:
23708:         JS_ASSERT(JSVAL_TAG(v) == JSVAL_STRING);
32746:         return lir->ins2(LIR_pior, v_ins, INS_CONSTWORD(JSVAL_STRING));
31902:     }
31902: }
31902: 
31902: JS_REQUIRES_STACK LIns*
31902: TraceRecorder::unbox_jsval(jsval v, LIns* v_ins, VMSideExit* exit)
17460: {
17470:     if (isNumber(v)) {
17470:         // JSVAL_IS_NUMBER(v)
17758:         guard(false,
32746:               lir->ins_eq0(lir->ins2(LIR_or,
32746:                                      p2i(lir->ins2(LIR_piand, v_ins, INS_CONSTWORD(JSVAL_INT))),
32746:                                      lir->ins2(LIR_peq,
18232:                                                lir->ins2(LIR_piand, v_ins,
32746:                                                          INS_CONSTWORD(JSVAL_TAGMASK)),
32746:                                                INS_CONSTWORD(JSVAL_DOUBLE)))),
26972:               exit);
18693:         LIns* args[] = { v_ins };
31902:         return lir->insCall(&js_UnboxDouble_ci, args);
17460:     }
17470:     switch (JSVAL_TAG(v)) {
31521:       case JSVAL_SPECIAL:
40307:         if (JSVAL_IS_VOID(v)) {
40307:             guard(true, lir->ins2(LIR_peq, v_ins, INS_CONSTWORD(JSVAL_VOID)), exit);
40307:             return INS_VOID();
40307:         }
17541:         guard(true,
32746:               lir->ins2(LIR_peq,
32746:                         lir->ins2(LIR_piand, v_ins, INS_CONSTWORD(JSVAL_TAGMASK)),
32746:                         INS_CONSTWORD(JSVAL_SPECIAL)),
26972:               exit);
40326:         JS_ASSERT(!v_ins->isconstp());
40307:         guard(false, lir->ins2(LIR_peq, v_ins, INS_CONSTWORD(JSVAL_VOID)), exit);
32746:         return p2i(lir->ins2i(LIR_pursh, v_ins, JSVAL_TAGBITS));
31902: 
17630:       case JSVAL_OBJECT:
23075:         if (JSVAL_IS_NULL(v)) {
29896:             // JSVAL_NULL maps to type TT_NULL, so insist that v_ins == 0 here.
32746:             guard(true, lir->ins_peq0(v_ins), exit);
32746:         } else {
32746:             guard(false, lir->ins_peq0(v_ins), exit);
17630:             guard(true,
32746:                   lir->ins2(LIR_peq,
28086:                             lir->ins2(LIR_piand, v_ins, INS_CONSTWORD(JSVAL_TAGMASK)),
32746:                             INS_CONSTWORD(JSVAL_OBJECT)),
23075:                   exit);
32777: 
40430:             guard(JSVAL_TO_OBJECT(v)->isFunction(),
32746:                   lir->ins2(LIR_peq,
27541:                             lir->ins2(LIR_piand,
40353:                                       lir->insLoad(LIR_ldp, v_ins, offsetof(JSObject, classword),
40353:                                                    ACC_OTHER),
28086:                                       INS_CONSTWORD(~JSSLOT_CLASS_MASK_BITS)),
27541:                             INS_CONSTPTR(&js_FunctionClass)),
27541:                   exit);
23075:         }
31902:         return v_ins;
31902: 
23710:       default:
23710:         JS_ASSERT(JSVAL_TAG(v) == JSVAL_STRING);
17870:         guard(true,
32746:               lir->ins2(LIR_peq,
32746:                         lir->ins2(LIR_piand, v_ins, INS_CONSTWORD(JSVAL_TAGMASK)),
32746:                         INS_CONSTWORD(JSVAL_STRING)),
26972:               exit);
32746:         return lir->ins2(LIR_piand, v_ins, addName(lir->insImmWord(~JSVAL_TAGMASK),
32746:                                                    "~JSVAL_TAGMASK"));
23710:     }
17470: }
17460: 
33542: JS_REQUIRES_STACK RecordingStatus
17688: TraceRecorder::getThis(LIns*& this_ins)
17688: {
28841:     /*
40424:      * JSStackFrame::getThisObject updates cx->fp->argv[-1], so sample it into 'original' first.
28841:      */
28914:     jsval original = JSVAL_NULL;
31939:     if (cx->fp->argv) {
28914:         original = cx->fp->argv[-1];
28914:         if (!JSVAL_IS_PRIMITIVE(original) &&
40353:             guardClass(JSVAL_TO_OBJECT(original), get(&cx->fp->argv[-1]), &js_WithClass,
40353:                        snapshot(MISMATCH_EXIT), ACC_OTHER)) {
33542:             RETURN_STOP("can't trace getThis on With object");
28914:         }
28914:     }
28914: 
40424:     JSObject* thisObj = cx->fp->getThisObject(cx);
28650:     if (!thisObj)
40424:         RETURN_ERROR("fp->getThisObject failed");
28650: 
30860:     /* In global code, bake in the global object as 'this' object. */
31939:     if (!cx->fp->callee()) {
27495:         JS_ASSERT(callDepth == 0);
31843:         this_ins = INS_CONSTOBJ(thisObj);
27495: 
27470:         /*
30860:          * We don't have argv[-1] in global code, so we don't update the
30860:          * tracker here.
27495:          */
33542:         return RECORD_CONTINUE;
27495:     }
27495: 
28326:     jsval& thisv = cx->fp->argv[-1];
28961:     JS_ASSERT(JSVAL_IS_OBJECT(thisv));
28326: 
27495:     /*
30860:      * Traces type-specialize between null and objects, so if we currently see
30860:      * a null value in argv[-1], this trace will only match if we see null at
30860:      * runtime as well.  Bake in the global object as 'this' object, updating
30860:      * the tracker as well. We can only detect this condition prior to calling
40424:      * JSStackFrame::getThisObject, since it updates the interpreter's copy of
30860:      * argv[-1].
27495:      */
28962:     JSClass* clasp = NULL;;
28961:     if (JSVAL_IS_NULL(original) ||
38497:         (((clasp = JSVAL_TO_OBJECT(original)->getClass()) == &js_CallClass) ||
28962:          (clasp == &js_BlockClass))) {
28962:         if (clasp)
40353:             guardClass(JSVAL_TO_OBJECT(original), get(&thisv), clasp, snapshot(BRANCH_EXIT),
40353:                        ACC_OTHER);
28326:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(thisv));
27548:         if (thisObj != globalObj)
33542:             RETURN_STOP("global object was wrapped while recording");
31843:         this_ins = INS_CONSTOBJ(thisObj);
28326:         set(&thisv, this_ins);
33542:         return RECORD_CONTINUE;
28326:     }
32796: 
28326:     this_ins = get(&thisv);
28326: 
32796:     JSObject* wrappedGlobal = globalObj->thisObject(cx);
32796:     if (!wrappedGlobal)
33542:         RETURN_ERROR("globalObj->thisObject hook threw in getThis");
32796: 
28908:     /*
30860:      * The only unwrapped object that needs to be wrapped that we can get here
30860:      * is the global object obtained throught the scope chain.
28908:      */
32796:     this_ins = lir->ins_choose(lir->ins_peq0(stobj_get_parent(this_ins)),
32796:                                INS_CONSTOBJ(wrappedGlobal),
33950:                                this_ins, avmplus::AvmCore::use_cmov());
33542:     return RECORD_CONTINUE;
17688: }
17688: 
27637: 
22652: JS_REQUIRES_STACK bool
38497: TraceRecorder::guardClass(JSObject* obj, LIns* obj_ins, JSClass* clasp, VMSideExit* exit,
39910:                           AccSet accSet)
38497: {
38497:     bool cond = obj->getClass() == clasp;
38497: 
39910:     LIns* class_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, classword), accSet);
37776:     class_ins = lir->ins2(LIR_piand, class_ins, INS_CONSTWORD(~JSSLOT_CLASS_MASK_BITS));
37776: 
37776: #ifdef JS_JIT_SPEW
37776:     char namebuf[32];
37776:     JS_snprintf(namebuf, sizeof namebuf, "guard(class is %s)", clasp->name);
37776: #else
37776:     static const char namebuf[] = "";
37776: #endif
37776:     guard(cond, addName(lir->ins2(LIR_peq, class_ins, INS_CONSTPTR(clasp)), namebuf), exit);
37776:     return cond;
37776: }
37776: 
37776: JS_REQUIRES_STACK bool
21685: TraceRecorder::guardDenseArray(JSObject* obj, LIns* obj_ins, ExitType exitType)
21685: {
40353:     return guardClass(obj, obj_ins, &js_ArrayClass, snapshot(exitType), ACC_OTHER);
17899: }
17899: 
29513: JS_REQUIRES_STACK bool
32777: TraceRecorder::guardDenseArray(JSObject* obj, LIns* obj_ins, VMSideExit* exit)
32777: {
40353:     return guardClass(obj, obj_ins, &js_ArrayClass, exit, ACC_OTHER);
32777: }
32777: 
32777: JS_REQUIRES_STACK bool
29513: TraceRecorder::guardHasPrototype(JSObject* obj, LIns* obj_ins,
29513:                                  JSObject** pobj, LIns** pobj_ins,
29513:                                  VMSideExit* exit)
29513: {
32603:     *pobj = obj->getProto();
32603:     *pobj_ins = stobj_get_proto(obj_ins);
29513: 
29513:     bool cond = *pobj == NULL;
32746:     guard(cond, addName(lir->ins_peq0(*pobj_ins), "guard(proto-not-null)"), exit);
29513:     return !cond;
29513: }
29513: 
33542: JS_REQUIRES_STACK RecordingStatus
27891: TraceRecorder::guardPrototypeHasNoIndexedProperties(JSObject* obj, LIns* obj_ins, ExitType exitType)
27891: {
27891:     /*
30860:      * Guard that no object along the prototype chain has any indexed
30860:      * properties which might become visible through holes in the array.
27891:      */
27540:     VMSideExit* exit = snapshot(exitType);
27891: 
27891:     if (js_PrototypeHasIndexedProperties(cx, obj))
33542:         return RECORD_STOP;
27891: 
32777:     while (guardHasPrototype(obj, obj_ins, &obj, &obj_ins, exit))
40393:         CHECK_STATUS(guardShape(obj_ins, obj, OBJ_SHAPE(obj), "guard(shape)", exit));
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: RecordingStatus
26274: TraceRecorder::guardNotGlobalObject(JSObject* obj, LIns* obj_ins)
26274: {
26274:     if (obj == globalObj)
33542:         RETURN_STOP("reference aliases global object");
32746:     guard(false, lir->ins2(LIR_peq, obj_ins, INS_CONSTOBJ(globalObj)), MISMATCH_EXIT);
33542:     return RECORD_CONTINUE;
19983: }
19983: 
37009: // Helper for clearXEntryFrameSlotsFromTracker.
37009: // Clear out slots of the given frame in the NativeFrameTracker. All argument slots
37009: // are cleared. |nslots| local slots are cleared.
22652: JS_REQUIRES_STACK void
37009: TraceRecorder::clearFrameSlotsFromTracker(Tracker& which, JSStackFrame* fp, unsigned nslots)
17818: {
30860:     /*
30860:      * Clear out all slots of this frame in the nativeFrameTracker. Different
30860:      * locations on the VM stack might map to different locations on the native
30860:      * stack depending on the number of arguments (i.e.) of the next call, so
30860:      * we have to make sure we map those in to the cache with the right
30860:      * offsets.
30860:      */
17811:     jsval* vp;
17811:     jsval* vpstop;
30860: 
30860:     /*
30860:      * Duplicate native stack layout computation: see VisitFrameSlots header comment.
30860:      * This doesn't do layout arithmetic, but it must clear out all the slots defined as
30860:      * imported by VisitFrameSlots.
30860:      */
31939:     if (fp->argv) {
18187:         vp = &fp->argv[-2];
28244:         vpstop = &fp->argv[argSlots(fp)];
18136:         while (vp < vpstop)
36401:             which.set(vp++, (LIns*)0);
36401:         which.set(&fp->argsobj, (LIns*)0);
37694:         which.set(&fp->scopeChain, (LIns*)0);
18136:     }
18136:     vp = &fp->slots[0];
37009:     vpstop = &fp->slots[nslots];
18136:     while (vp < vpstop)
36401:         which.set(vp++, (LIns*)0);
17818: }
17818: 
37009: JS_REQUIRES_STACK JSStackFrame*
37009: TraceRecorder::entryFrame() const
37009: {
37009:     JSStackFrame *fp = cx->fp;
37009:     for (unsigned i = 0; i < callDepth; ++i)
37009:         fp = fp->down;
37009:     return fp;
37009: }
37009: 
37009: JS_REQUIRES_STACK void
37009: TraceRecorder::clearEntryFrameSlotsFromTracker(Tracker& which)
37009: {
37009:     JSStackFrame *fp = entryFrame();
37009: 
37009:     // Clear only slots that are not also used by the next frame up.
37009:     clearFrameSlotsFromTracker(which, fp, fp->script->nfixed);
37009: }
37009: 
37009: JS_REQUIRES_STACK void
37009: TraceRecorder::clearCurrentFrameSlotsFromTracker(Tracker& which)
37009: {
37009:     // Clear out all local slots.
37009:     clearFrameSlotsFromTracker(which, cx->fp, cx->fp->script->nslots);
37009: }
37009: 
31847: /*
31847:  * If we have created an |arguments| object for the frame, we must copy the
31847:  * argument values into the object as properties in case it is used after
31847:  * this frame returns.
31847:  */
31847: JS_REQUIRES_STACK void
37694: TraceRecorder::putActivationObjects()
37694: {
37694:     bool have_args = cx->fp->argsobj && cx->fp->argc;
37694:     bool have_call = cx->fp->fun && JSFUN_HEAVYWEIGHT_TEST(cx->fp->fun->flags) && cx->fp->fun->countArgsAndVars();
37694: 
37694:     if (!have_args && !have_call)
37694:         return;
37694: 
37913:     int nargs = have_args ? argSlots(cx->fp) : cx->fp->fun->nargs;
37694: 
37694:     LIns* args_ins;
37694:     if (nargs) {
37694:         args_ins = lir->insAlloc(sizeof(jsval) * nargs);
37694:         for (int i = 0; i < nargs; ++i) {
31902:             LIns* arg_ins = box_jsval(cx->fp->argv[i], get(&cx->fp->argv[i]));
40353:             lir->insStorei(arg_ins, args_ins, i * sizeof(jsval), ACC_OTHER);
31847:         }
37694:     } else {
37694:         args_ins = INS_CONSTPTR(0);
37694:     }
37694: 
37694:     if (have_args) {
37694:         LIns* argsobj_ins = get(&cx->fp->argsobj);
31847:         LIns* args[] = { args_ins, argsobj_ins, cx_ins };
31847:         lir->insCall(&js_PutArguments_ci, args);
31847:     }
37694: 
37694:     if (have_call) {
37694:         int nslots = cx->fp->fun->countVars();
37694:         LIns* slots_ins;
37694:         if (nslots) {
37694:             slots_ins = lir->insAlloc(sizeof(jsval) * nslots);
37694:             for (int i = 0; i < nslots; ++i) {
37694:                 LIns* slot_ins = box_jsval(cx->fp->slots[i], get(&cx->fp->slots[i]));
40353:                 lir->insStorei(slot_ins, slots_ins, i * sizeof(jsval), ACC_OTHER);
37694:             }
37694:         } else {
37694:             slots_ins = INS_CONSTPTR(0);
37694:         }
37694: 
39911:         LIns* scopeChain_ins = get(&cx->fp->scopeChainVal);
37913:         LIns* args[] = { slots_ins, INS_CONST(nslots), args_ins,
37913:                          INS_CONST(cx->fp->fun->nargs), scopeChain_ins, cx_ins };
37694:         lir->insCall(&js_PutCallObjectOnTrace_ci, args);
37694:     }
31847: }
31847: 
33591: static JS_REQUIRES_STACK inline bool
33564: IsTraceableRecursion(JSContext *cx)
33564: {
33564:     JSStackFrame *fp = cx->fp;
33564:     JSStackFrame *down = cx->fp->down;
33564:     if (!down)
33564:         return false;
33564:     if (down->script != fp->script)
33564:         return false;
33564:     if (down->argc != fp->argc)
33564:         return false;
33579:     if (fp->argc != fp->fun->nargs)
33579:         return false;
33564:     if (fp->imacpc || down->imacpc)
33564:         return false;
33564:     if ((fp->flags & JSFRAME_CONSTRUCTING) || (down->flags & JSFRAME_CONSTRUCTING))
33564:         return false;
38642:     if (fp->blockChain || down->blockChain)
38642:         return false;
35110:     if (*fp->script->code != JSOP_TRACE)
35110:         return false;
33564:     return true;
33564: }
33564: 
33564: JS_REQUIRES_STACK AbortableRecordingStatus
33564: TraceRecorder::record_EnterFrame(uintN& inlineCallCount)
17818: {
19078:     JSStackFrame* fp = cx->fp;
19078: 
17852:     if (++callDepth >= MAX_CALLDEPTH)
33542:         RETURN_STOP_A("exceeded maximum call depth");
30860: 
29883:     debug_only_printf(LC_TMTracer, "EnterFrame %s, callDepth=%d\n",
18140:                       js_AtomToPrintableString(cx, cx->fp->fun->atom),
29883:                       callDepth);
29883:     debug_only_stmt(
37741:         if (LogController.lcbits & LC_TMRecorder) {
23450:             js_Disassemble(cx, cx->fp->script, JS_TRUE, stdout);
29883:             debug_only_print0(LC_TMTracer, "----\n");
29883:         }
29883:     )
30248:     LIns* void_ins = INS_VOID();
30248: 
30248:     // Duplicate native stack layout computation: see VisitFrameSlots header comment.
30248:     // This doesn't do layout arithmetic, but it must initialize in the tracker all the
30248:     // slots defined as imported by VisitFrameSlots.
18119:     jsval* vp = &fp->argv[fp->argc];
19567:     jsval* vpstop = vp + ptrdiff_t(fp->fun->nargs) - ptrdiff_t(fp->argc);
18119:     while (vp < vpstop) {
18119:         nativeFrameTracker.set(vp, (LIns*)0);
39913:         set(vp++, void_ins);
18119:     }
18119: 
18119:     vp = &fp->slots[0];
18119:     vpstop = vp + fp->script->nfixed;
18119:     while (vp < vpstop)
39913:         set(vp++, void_ins);
39913:     set(&fp->argsobj, INS_NULL());
33564: 
37694:     LIns* callee_ins = get(&cx->fp->argv[-2]);
37694:     LIns* scopeChain_ins = stobj_get_parent(callee_ins);
37694: 
37694:     if (cx->fp->fun && JSFUN_HEAVYWEIGHT_TEST(cx->fp->fun->flags)) {
37694:         // We need to make sure every part of the frame is known to the tracker
37694:         // before taking a snapshot.
39913:         set(&fp->scopeChainVal, INS_NULL());
37694: 
37694:         if (js_IsNamedLambda(cx->fp->fun))
37694:             RETURN_STOP_A("can't call named lambda heavyweight on trace");
37694: 
37694:         LIns* fun_ins = INS_CONSTPTR(cx->fp->fun);
37694: 
37694:         LIns* args[] = { scopeChain_ins, callee_ins, fun_ins, cx_ins };
37694:         LIns* call_ins = lir->insCall(&js_CreateCallObjectOnTrace_ci, args);
37694:         guard(false, lir->ins_peq0(call_ins), snapshot(OOM_EXIT));
37694: 
39911:         set(&fp->scopeChainVal, call_ins);
39911:     } else {
39913:         set(&fp->scopeChainVal, scopeChain_ins);
37694:     }
37694: 
33564:     /*
33564:      * Check for recursion. This is a special check for recursive cases that can be
33564:      * a trace-tree, just like a loop. If recursion acts weird, for example
33564:      * differing argc or existence of an imacpc, it's not something this code is
33564:      * concerned about. That should pass through below to not regress pre-recursion
33564:      * functionality.
33564:      */
36361:     if (IsTraceableRecursion(cx) && tree->script == cx->fp->script) {
36361:         if (tree->recursion == Recursion_Disallowed)
33564:             RETURN_STOP_A("recursion not allowed in this tree");
36361:         if (tree->script != cx->fp->script)
33564:             RETURN_STOP_A("recursion does not match original tree");
33564:         return InjectStatus(downRecursion());
33564:     }
33564: 
33564:     /* Try inlining one level in case this recursion doesn't go too deep. */
33564:     if (fp->script == fp->down->script &&
33564:         fp->down->down && fp->down->down->script == fp->script) {
33564:         RETURN_STOP_A("recursion started inlining");
33564:     }
33564: 
40251:     TreeFragment* first = LookupLoop(&JS_TRACE_MONITOR(cx), fp->regs->pc, tree->globalObj,
40251:                                      tree->globalShape, fp->argc);
33564:     if (!first)
33564:         return ARECORD_CONTINUE;
35044:     TreeFragment* f = findNestedCompatiblePeer(first);
33564:     if (!f) {
33564:         /*
33564:          * If there were no compatible peers, but there were peers at all, then it is probable that
33564:          * an inner recursive function is type mismatching. Start a new recorder that must be
33564:          * recursive.
33564:          */
35044:         for (f = first; f; f = f->peer) {
36361:             if (f->code() && f->recursion == Recursion_Detected) {
33564:                 /* Since this recorder is about to die, save its values. */
33564:                 if (++first->hits() <= HOTLOOP)
33564:                     return ARECORD_STOP;
33564:                 if (IsBlacklisted((jsbytecode*)f->ip))
33564:                     RETURN_STOP_A("inner recursive tree is blacklisted");
33564:                 JSContext* _cx = cx;
36361:                 SlotList* globalSlots = tree->globalSlots;
37741:                 AbortRecording(cx, "trying to compile inner recursive tree");
40226:                 JS_ASSERT(_cx->fp->argc == first->argc);
40229:                 RecordTree(_cx, first, NULL, 0, globalSlots, Record_EnterFrame);
33564:                 break;
33564:             }
33564:         }
33564:         return ARECORD_CONTINUE;
33564:     } else if (f) {
33564:         /*
33564:          * Make sure the shape of the global object still matches (this might
33564:          * flush the JIT cache).
33564:          */
40424:         JSObject* globalObj = cx->fp->scopeChain->getGlobal();
33564:         uint32 globalShape = -1;
33564:         SlotList* globalSlots = NULL;
35083:         if (!CheckGlobalObjectShape(cx, traceMonitor, globalObj, &globalShape, &globalSlots))
33564:             return ARECORD_ABORTED;
33564:         return attemptTreeCall(f, inlineCallCount);
33564:     }
33564: 
33542:    return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17818: TraceRecorder::record_LeaveFrame()
17818: {
29883:     debug_only_stmt(
18142:         if (cx->fp->fun)
29883:             debug_only_printf(LC_TMTracer,
29883:                               "LeaveFrame (back to %s), callDepth=%d\n",
18140:                               js_AtomToPrintableString(cx, cx->fp->fun->atom),
18140:                               callDepth);
18260:         );
33564: 
33564:     JS_ASSERT(js_CodeSpec[js_GetOpcode(cx, cx->fp->script,
33564:               cx->fp->regs->pc)].length == JSOP_CALL_LENGTH);
33564: 
26118:     if (callDepth-- <= 0)
33542:         RETURN_STOP_A("returned out of a loop we started tracing");
18001: 
18001:     // LeaveFrame gets called after the interpreter popped the frame and
18001:     // stored rval, so cx->fp not cx->fp->down, and -1 not 0.
24293:     atoms = FrameAtomBase(cx, cx->fp);
39913:     set(&stackval(-1), rval_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_PUSH()
17409: {
40307:     stack(0, INS_VOID());
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_POPV()
17926: {
20907:     jsval& rval = stackval(-1);
31902:     LIns *rval_ins = box_jsval(rval, get(&rval));
20907: 
20907:     // Store it in cx->fp->rval. NB: Tricky dependencies. cx->fp is the right
20907:     // frame because POPV appears only in global and eval code and we don't
20907:     // trace JSOP_EVAL or leaving the frame where tracing started.
40353:     LIns *fp_ins = lir->insLoad(LIR_ldp, cx_ins, offsetof(JSContext, fp), ACC_OTHER);
40353:     lir->insStorei(rval_ins, fp_ins, offsetof(JSStackFrame, rval), ACC_OTHER);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
21685: TraceRecorder::record_JSOP_ENTERWITH()
21685: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
21685: TraceRecorder::record_JSOP_LEAVEWITH()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_RETURN()
17409: {
33564:     /* A return from callDepth 0 terminates the current loop, except for recursion. */
26557:     if (callDepth == 0) {
36361:         if (IsTraceableRecursion(cx) && tree->recursion != Recursion_Disallowed &&
36361:             tree->script == cx->fp->script) {
33564:             return InjectStatus(upRecursion());
33564:         } else {
26557:             AUDIT(returnLoopExits);
33542:             return endLoop();
26557:         }
33564:     }
26557: 
37694:     putActivationObjects();
30248: 
26557:     /* If we inlined this function call, make the return value available to the caller code. */
18001:     jsval& rval = stackval(-1);
18661:     JSStackFrame *fp = cx->fp;
18785:     if ((cx->fp->flags & JSFRAME_CONSTRUCTING) && JSVAL_IS_PRIMITIVE(rval)) {
32774:         JS_ASSERT(fp->thisv == fp->argv[-1]);
18661:         rval_ins = get(&fp->argv[-1]);
18661:     } else {
18661:         rval_ins = get(&rval);
18001:     }
29883:     debug_only_printf(LC_TMTracer,
29883:                       "returning from %s\n",
29883:                       js_AtomToPrintableString(cx, cx->fp->fun->atom));
37009:     clearCurrentFrameSlotsFromTracker(nativeFrameTracker);
26557: 
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GOTO()
17409: {
26557:     /*
31942:      * If we hit a break or a continue to an outer loop, end the loop and
31942:      * generate an always-taken loop exit guard.  For other downward gotos
31942:      * (like if/else) continue recording.
26557:      */
26557:     jssrcnote* sn = js_GetSrcNote(cx->fp->script, cx->fp->regs->pc);
26557: 
31942:     if (sn && (SN_TYPE(sn) == SRC_BREAK || SN_TYPE(sn) == SRC_CONT2LABEL)) {
26557:         AUDIT(breakLoopExits);
33542:         return endLoop();
33542:     }
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_IFEQ()
17409: {
18694:     trackCfgMerges(cx->fp->regs->pc);
20416:     return ifop();
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_IFNE()
17409: {
20416:     return ifop();
17409: }
17926: 
32709: LIns*
36437: TraceRecorder::newArguments(LIns* callee_ins)
32709: {
31843:     LIns* global_ins = INS_CONSTOBJ(globalObj);
31823:     LIns* argc_ins = INS_CONST(cx->fp->argc);
32709:     LIns* argv_ins = cx->fp->argc
32709:                      ? lir->ins2(LIR_piadd, lirbuf->sp,
35083:                                  lir->insImmWord(nativespOffset(&cx->fp->argv[0])))
32709:                      : INS_CONSTPTR((void *) 2);
37741:     ArgsPrivateNative *apn = ArgsPrivateNative::create(traceAlloc(), cx->fp->argc);
32709:     for (uintN i = 0; i < cx->fp->argc; ++i) {
32709:         apn->typemap()[i] = determineSlotType(&cx->fp->argv[i]);
32709:     }
32709: 
32709:     LIns* args[] = { INS_CONSTPTR(apn), argv_ins, callee_ins, argc_ins, global_ins, cx_ins };
32709:     LIns* call_ins = lir->insCall(&js_Arguments_ci, args);
32746:     guard(false, lir->ins_peq0(call_ins), OOM_EXIT);
32709:     return call_ins;
32709: }
32709: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
32709: TraceRecorder::record_JSOP_ARGUMENTS()
32709: {
32709:     if (cx->fp->flags & JSFRAME_OVERRIDE_ARGS)
33542:         RETURN_STOP_A("Can't trace |arguments| if |arguments| is assigned to");
32709: 
31823:     LIns* a_ins = get(&cx->fp->argsobj);
32709:     LIns* args_ins;
36437:     LIns* callee_ins = get(&cx->fp->argv[-2]);
32709:     if (a_ins->opcode() == LIR_int) {
32709:         // |arguments| is set to 0 by EnterFrame on this trace, so call to create it.
36437:         args_ins = newArguments(callee_ins);
32709:     } else {
32709:         // Generate LIR to create arguments only if it has not already been created.
32709: 
32709:         LIns* mem_ins = lir->insAlloc(sizeof(jsval));
32709: 
32746:         LIns* br1 = lir->insBranch(LIR_jt, lir->ins_peq0(a_ins), NULL);
40353:         lir->insStorei(a_ins, mem_ins, 0, ACC_OTHER);
32709:         LIns* br2 = lir->insBranch(LIR_j, NULL, NULL);
32709: 
32709:         LIns* label1 = lir->ins0(LIR_label);
32709:         br1->setTarget(label1);
32709: 
36437:         LIns* call_ins = newArguments(callee_ins);
40353:         lir->insStorei(call_ins, mem_ins, 0, ACC_OTHER);
32709: 
32709:         LIns* label2 = lir->ins0(LIR_label);
32709:         br2->setTarget(label2);
32709: 
40353:         args_ins = lir->insLoad(LIR_ldp, mem_ins, 0, ACC_OTHER);
32709:     }
32709: 
32709:     stack(0, args_ins);
32709:     set(&cx->fp->argsobj, args_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DUP()
17409: {
17448:     stack(0, get(&stackval(-1)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DUP2()
17409: {
17448:     stack(0, get(&stackval(-2)));
17448:     stack(1, get(&stackval(-1)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
21685: TraceRecorder::record_JSOP_SWAP()
21685: {
21685:     jsval& l = stackval(-2);
21685:     jsval& r = stackval(-1);
21685:     LIns* l_ins = get(&l);
21685:     LIns* r_ins = get(&r);
21685:     set(&r, l_ins);
21685:     set(&l, r_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
23097: TraceRecorder::record_JSOP_PICK()
23097: {
23097:     jsval* sp = cx->fp->regs->sp;
23102:     jsint n = cx->fp->regs->pc[1];
23097:     JS_ASSERT(sp - (n+1) >= StackBase(cx->fp));
24381:     LIns* top = get(sp - (n+1));
23097:     for (jsint i = 0; i < n; ++i)
24381:         set(sp - (n+1) + i, get(sp - n + i));
23097:     set(&sp[-1], top);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_SETCONST()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_BITOR()
17409: {
33542:     return InjectStatus(binary(LIR_or));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_BITXOR()
17409: {
33542:     return InjectStatus(binary(LIR_xor));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_BITAND()
17409: {
33542:     return InjectStatus(binary(LIR_and));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_EQ()
17409: {
23093:     return equality(false, true);
18687: }
18687: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_NE()
17409: {
23093:     return equality(true, true);
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LT()
17409: {
23093:     return relational(LIR_flt, true);
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LE()
17409: {
23093:     return relational(LIR_fle, true);
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GT()
17409: {
23093:     return relational(LIR_fgt, true);
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GE()
17409: {
23093:     return relational(LIR_fge, true);
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LSH()
17409: {
33542:     return InjectStatus(binary(LIR_lsh));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_RSH()
17409: {
33542:     return InjectStatus(binary(LIR_rsh));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_URSH()
17409: {
33542:     return InjectStatus(binary(LIR_ush));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ADD()
17409: {
17872:     jsval& r = stackval(-1);
17872:     jsval& l = stackval(-2);
21685: 
23075:     if (!JSVAL_IS_PRIMITIVE(l)) {
33542:         RETURN_IF_XML_A(l);
28175:         if (!JSVAL_IS_PRIMITIVE(r)) {
33542:             RETURN_IF_XML_A(r);
33542:             return InjectStatus(call_imacro(add_imacros.obj_obj));
33542:         }
33542:         return InjectStatus(call_imacro(add_imacros.obj_any));
21685:     }
28175:     if (!JSVAL_IS_PRIMITIVE(r)) {
33542:         RETURN_IF_XML_A(r);
33542:         return InjectStatus(call_imacro(add_imacros.any_obj));
28175:     }
21685: 
21447:     if (JSVAL_IS_STRING(l) || JSVAL_IS_STRING(r)) {
21685:         LIns* args[] = { stringify(r), stringify(l), cx_ins };
20915:         LIns* concat = lir->insCall(&js_ConcatStrings_ci, args);
32746:         guard(false, lir->ins_peq0(concat), OOM_EXIT);
17872:         set(&l, concat);
33542:         return ARECORD_CONTINUE;
33542:     }
33542: 
33542:     return InjectStatus(binary(LIR_fadd));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_SUB()
17409: {
33542:     return InjectStatus(binary(LIR_fsub));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_MUL()
17409: {
33542:     return InjectStatus(binary(LIR_fmul));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DIV()
17409: {
33542:     return InjectStatus(binary(LIR_fdiv));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_MOD()
17409: {
33542:     return InjectStatus(binary(LIR_fmod));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_NOT()
17409: {
17436:     jsval& v = stackval(-1);
31521:     if (JSVAL_IS_SPECIAL(v)) {
19070:         set(&v, lir->ins_eq0(lir->ins2i(LIR_eq, get(&v), 1)));
33542:         return ARECORD_CONTINUE;
19070:     }
19554:     if (isNumber(v)) {
21776:         LIns* v_ins = get(&v);
32640:         set(&v, lir->ins2(LIR_or, lir->ins2(LIR_feq, v_ins, lir->insImmf(0)),
21776:                                   lir->ins_eq0(lir->ins2(LIR_feq, v_ins, v_ins))));
33542:         return ARECORD_CONTINUE;
19554:     }
23075:     if (JSVAL_TAG(v) == JSVAL_OBJECT) {
32746:         set(&v, lir->ins_peq0(get(&v)));
33542:         return ARECORD_CONTINUE;
18769:     }
20435:     JS_ASSERT(JSVAL_IS_STRING(v));
35470:     set(&v, lir->ins_peq0(lir->insLoad(LIR_ldp, get(&v),
40353:                                        offsetof(JSString, mLength), ACC_OTHER)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_BITNOT()
17409: {
33542:     return InjectStatus(unary(LIR_not));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_NEG()
17409: {
18787:     jsval& v = stackval(-1);
23106: 
28175:     if (!JSVAL_IS_PRIMITIVE(v)) {
33542:         RETURN_IF_XML_A(v);
33542:         return InjectStatus(call_imacro(unary_imacros.sign));
28175:     }
23106: 
18787:     if (isNumber(v)) {
18787:         LIns* a = get(&v);
18787: 
30860:         /*
30860:          * If we're a promoted integer, we have to watch out for 0s since -0 is
30860:          * a double. Only follow this path if we're not an integer that's 0 and
30860:          * we're not a double that's zero.
18787:          */
29354:         if (!oracle.isInstructionUndemotable(cx->fp->regs->pc) &&
29354:             isPromoteInt(a) &&
18787:             (!JSVAL_IS_INT(v) || JSVAL_TO_INT(v) != 0) &&
22610:             (!JSVAL_IS_DOUBLE(v) || !JSDOUBLE_IS_NEGZERO(*JSVAL_TO_DOUBLE(v))) &&
38603:             -asNumber(v) == (int)-asNumber(v))
38603:         {
27540:             VMSideExit* exit = snapshot(OVERFLOW_EXIT);
38603:             a = guard_xov(LIR_sub, lir->insImm(0), demote(lir, a), exit);
38603:             if (!a->isconst() && a->isop(LIR_subxov)) {
38603:                 guard(false, lir->ins2i(LIR_eq, a, 0), exit); // make sure we don't lose a -0
26117:             }
18787:             a = lir->ins1(LIR_i2f, a);
18787:         } else {
18787:             a = lir->ins1(LIR_fneg, a);
18787:         }
18787: 
18787:         set(&v, a);
33542:         return ARECORD_CONTINUE;
18787:     }
23106: 
23106:     if (JSVAL_IS_NULL(v)) {
26265:         set(&v, lir->insImmf(-0.0));
33542:         return ARECORD_CONTINUE;
23106:     }
23106: 
40307:     if (JSVAL_IS_VOID(v)) {
40307:         set(&v, lir->insImmf(js_NaN));
40307:         return ARECORD_CONTINUE;
40307:     }
40307: 
40307:     if (JSVAL_IS_STRING(v)) {
23106:         LIns* args[] = { get(&v), cx_ins };
23225:         set(&v, lir->ins1(LIR_fneg,
40307:                           lir->insCall(&js_StringToNumber_ci, args)));
40307:         return ARECORD_CONTINUE;
40307:     }
40307: 
40307:     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
40326:     set(&v, lir->ins1(LIR_fneg, i2f(get(&v))));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
23106: TraceRecorder::record_JSOP_POS()
23106: {
23225:     jsval& v = stackval(-1);
23225: 
28175:     if (!JSVAL_IS_PRIMITIVE(v)) {
33542:         RETURN_IF_XML_A(v);
33542:         return InjectStatus(call_imacro(unary_imacros.sign));
28175:     }
23106: 
23225:     if (isNumber(v))
33542:         return ARECORD_CONTINUE;
23225: 
23225:     if (JSVAL_IS_NULL(v)) {
32640:         set(&v, lir->insImmf(0));
33542:         return ARECORD_CONTINUE;
23225:     }
40307:     if (JSVAL_IS_VOID(v)) {
40307:         set(&v, lir->insImmf(js_NaN));
40307:         return ARECORD_CONTINUE;
40307:     }
40307: 
40307:     if (JSVAL_IS_STRING(v)) {
23225:         LIns* args[] = { get(&v), cx_ins };
40307:         set(&v, lir->insCall(&js_StringToNumber_ci, args));
40307:         return ARECORD_CONTINUE;
40307:     }
40307: 
40307:     JS_ASSERT(JSVAL_IS_BOOLEAN(v));
40307:     set(&v, i2f(get(&v)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
23106: TraceRecorder::record_JSOP_PRIMTOP()
23106: {
23106:     // Either this opcode does nothing or we couldn't have traced here, because
23106:     // we'd have thrown an exception -- so do nothing if we actually hit this.
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
24873: TraceRecorder::record_JSOP_OBJTOP()
24873: {
28175:     jsval& v = stackval(-1);
33542:     RETURN_IF_XML_A(v);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: RecordingStatus
32615: TraceRecorder::getClassPrototype(JSObject* ctor, LIns*& proto_ins)
22626: {
35117:     // ctor must be a function created via js_InitClass.
33542: #ifdef DEBUG
35117:     JSClass *clasp = FUN_CLASP(GET_FUNCTION_PRIVATE(cx, ctor));
35117:     JS_ASSERT(clasp);
35117: 
37741:     TraceMonitor &localtm = JS_TRACE_MONITOR(cx);
33542: #endif
33542: 
22626:     jsval pval;
31501:     if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom), &pval))
33542:         RETURN_ERROR("error getting prototype from constructor");
33542: 
35117:     // ctor.prototype is a permanent data property, so this lookup cannot have
35117:     // deep-aborted.
33542:     JS_ASSERT(localtm.recorder);
33542: 
25887: #ifdef DEBUG
25887:     JSBool ok, found;
25887:     uintN attrs;
25887:     ok = JS_GetPropertyAttributes(cx, ctor, js_class_prototype_str, &attrs, &found);
25887:     JS_ASSERT(ok);
25887:     JS_ASSERT(found);
25887:     JS_ASSERT((~attrs & (JSPROP_READONLY | JSPROP_PERMANENT)) == 0);
25887: #endif
35117: 
35117:     // Since ctor was built by js_InitClass, we can assert (rather than check)
35117:     // that pval is usable.
35117:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(pval));
35117:     JSObject *proto = JSVAL_TO_OBJECT(pval);
35117:     JS_ASSERT_IF(clasp != &js_ArrayClass, OBJ_SCOPE(proto)->emptyScope->clasp == clasp);
35117: 
35117:     proto_ins = INS_CONSTOBJ(proto);
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: RecordingStatus
32615: TraceRecorder::getClassPrototype(JSProtoKey key, LIns*& proto_ins)
32615: {
33542: #ifdef DEBUG
37741:     TraceMonitor &localtm = JS_TRACE_MONITOR(cx);
33542: #endif
33542: 
32615:     JSObject* proto;
38604:     if (!js_GetClassPrototype(cx, globalObj, key, &proto))
33542:         RETURN_ERROR("error in js_GetClassPrototype");
33542: 
35117:     // This should not have reentered.
33542:     JS_ASSERT(localtm.recorder);
33542: 
38508: #ifdef DEBUG
38508:     /* Double-check that a native proto has a matching emptyScope. */
35117:     if (key != JSProto_Array) {
40430:         JS_ASSERT(proto->isNative());
35117:         JSEmptyScope *emptyScope = OBJ_SCOPE(proto)->emptyScope;
38508:         JS_ASSERT(emptyScope);
38508:         JS_ASSERT(JSCLASS_CACHED_PROTO_KEY(emptyScope->clasp) == key);
38508:     }
38508: #endif
35117: 
31843:     proto_ins = INS_CONSTOBJ(proto);
33542:     return RECORD_CONTINUE;
27933: }
27933: 
32669: #define IGNORE_NATIVE_CALL_COMPLETE_CALLBACK ((JSSpecializedNative*)1)
28086: 
33542: RecordingStatus
28086: TraceRecorder::newString(JSObject* ctor, uint32 argc, jsval* argv, jsval* rval)
28086: {
28086:     JS_ASSERT(argc == 1);
28086: 
28175:     if (!JSVAL_IS_PRIMITIVE(argv[0])) {
33542:         RETURN_IF_XML(argv[0]);
28086:         return call_imacro(new_imacros.String);
28175:     }
28086: 
28086:     LIns* proto_ins;
32615:     CHECK_STATUS(getClassPrototype(ctor, proto_ins));
32615: 
32615:     LIns* args[] = { stringify(argv[0]), proto_ins, cx_ins };
28086:     LIns* obj_ins = lir->insCall(&js_String_tn_ci, args);
32746:     guard(false, lir->ins_peq0(obj_ins), OOM_EXIT);
28086: 
28086:     set(rval, obj_ins);
32669:     pendingSpecializedNative = IGNORE_NATIVE_CALL_COMPLETE_CALLBACK;
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: RecordingStatus
22626: TraceRecorder::newArray(JSObject* ctor, uint32 argc, jsval* argv, jsval* rval)
22626: {
28086:     LIns *proto_ins;
32615:     CHECK_STATUS(getClassPrototype(ctor, proto_ins));
22626: 
28086:     LIns *arr_ins;
35340:     if (argc == 0) {
28086:         // arr_ins = js_NewEmptyArray(cx, Array.prototype)
22626:         LIns *args[] = { proto_ins, cx_ins };
28086:         arr_ins = lir->insCall(&js_NewEmptyArray_ci, args);
32746:         guard(false, lir->ins_peq0(arr_ins), OOM_EXIT);
35340:     } else if (argc == 1 && JSVAL_IS_NUMBER(argv[0])) {
35340:         // arr_ins = js_NewEmptyArray(cx, Array.prototype, length)
35340:         LIns *args[] = { f2i(get(argv)), proto_ins, cx_ins }; // FIXME: is this 64-bit safe?
35340:         arr_ins = lir->insCall(&js_NewEmptyArrayWithLength_ci, args);
35340:         guard(false, lir->ins_peq0(arr_ins), OOM_EXIT);
22626:     } else {
33155:         // arr_ins = js_NewArrayWithSlots(cx, Array.prototype, argc)
22626:         LIns *args[] = { INS_CONST(argc), proto_ins, cx_ins };
33155:         arr_ins = lir->insCall(&js_NewArrayWithSlots_ci, args);
32746:         guard(false, lir->ins_peq0(arr_ins), OOM_EXIT);
22626: 
22626:         // arr->dslots[i] = box_jsval(vp[i]);  for i in 0..argc
22626:         LIns *dslots_ins = NULL;
33159:         for (uint32 i = 0; i < argc && !outOfMemory(); i++) {
31902:             LIns *elt_ins = box_jsval(argv[i], get(&argv[i]));
31849:             stobj_set_dslot(arr_ins, i, dslots_ins, elt_ins);
22626:         }
28554: 
28554:         if (argc > 0)
40796:             stobj_set_fslot(arr_ins, JSObject::JSSLOT_ARRAY_COUNT, INS_CONST(argc));
22626:     }
28086: 
22626:     set(rval, arr_ins);
32669:     pendingSpecializedNative = IGNORE_NATIVE_CALL_COMPLETE_CALLBACK;
33542:     return RECORD_CONTINUE;
27933: }
27933: 
30847: JS_REQUIRES_STACK void
30847: TraceRecorder::propagateFailureToBuiltinStatus(LIns* ok_ins, LIns*& status_ins)
30847: {
30847:     /*
30847:      * Check the boolean return value (ok_ins) of a native JSNative,
30847:      * JSFastNative, or JSPropertyOp hook for failure. On failure, set the
37741:      * BUILTIN_ERROR bit of cx->builtinStatus.
30847:      *
30847:      * If the return value (ok_ins) is true, status' == status. Otherwise
37741:      * status' = status | BUILTIN_ERROR. We calculate (rval&1)^1, which is 1
30847:      * if rval is JS_FALSE (error), and then shift that by 1, which is the log2
37741:      * of BUILTIN_ERROR.
30847:      */
30847:     JS_STATIC_ASSERT(((JS_TRUE & 1) ^ 1) << 1 == 0);
37741:     JS_STATIC_ASSERT(((JS_FALSE & 1) ^ 1) << 1 == BUILTIN_ERROR);
30847:     status_ins = lir->ins2(LIR_or,
30847:                            status_ins,
30847:                            lir->ins2i(LIR_lsh,
30847:                                       lir->ins2i(LIR_xor,
30847:                                                  lir->ins2i(LIR_and, ok_ins, 1),
30847:                                                  1),
30847:                                       1));
40353:     lir->insStorei(status_ins, lirbuf->state, (int) offsetof(InterpState, builtinStatus),
40353:                    ACC_OTHER);
30847: }
30847: 
30847: JS_REQUIRES_STACK void
30847: TraceRecorder::emitNativePropertyOp(JSScope* scope, JSScopeProperty* sprop, LIns* obj_ins,
30847:                                     bool setflag, LIns* boxed_ins)
30847: {
40265:     JS_ASSERT(setflag ? !sprop->hasSetterValue() : !sprop->hasGetterValue());
40265:     JS_ASSERT(setflag ? !sprop->hasDefaultSetter() : !sprop->hasDefaultGetterOrIsMethod());
30847: 
31444:     enterDeepBailCall();
30847: 
30847:     // It is unsafe to pass the address of an object slot as the out parameter,
30847:     // because the getter or setter could end up resizing the object's dslots.
30847:     // Instead, use a word of stack and root it in nativeVp.
30847:     LIns* vp_ins = lir->insAlloc(sizeof(jsval));
40353:     lir->insStorei(vp_ins, lirbuf->state, offsetof(InterpState, nativeVp), ACC_OTHER);
40353:     lir->insStorei(INS_CONST(1), lirbuf->state, offsetof(InterpState, nativeVpLen), ACC_OTHER);
30847:     if (setflag)
40353:         lir->insStorei(boxed_ins, vp_ins, 0, ACC_OTHER);
30847: 
34351:     CallInfo* ci = new (traceAlloc()) CallInfo();
39894:     ci->_address = uintptr_t(setflag ? sprop->setterOp() : sprop->getterOp());
40325:     ci->_typesig = ARGTYPE_I << (0*ARGTYPE_SHIFT) |
40325:                    ARGTYPE_P << (1*ARGTYPE_SHIFT) |
40325:                    ARGTYPE_P << (2*ARGTYPE_SHIFT) |
40325:                    ARGTYPE_P << (3*ARGTYPE_SHIFT) |
40325:                    ARGTYPE_P << (4*ARGTYPE_SHIFT);
39910:     ci->_isPure = 0;
39910:     ci->_storeAccSet = ACC_STORE_ANY;
30847:     ci->_abi = ABI_CDECL;
30847: #ifdef DEBUG
30847:     ci->_name = "JSPropertyOp";
30847: #endif
35099:     LIns* args[] = { vp_ins, INS_CONSTVAL(SPROP_USERID(sprop)), obj_ins, cx_ins };
30847:     LIns* ok_ins = lir->insCall(ci, args);
30847: 
32678:     // Cleanup. Immediately clear nativeVp before we might deep bail.
40353:     lir->insStorei(INS_NULL(), lirbuf->state, offsetof(InterpState, nativeVp), ACC_OTHER);
31444:     leaveDeepBailCall();
30847: 
30847:     // Guard that the call succeeded and builtinStatus is still 0.
30847:     // If the native op succeeds but we deep-bail here, the result value is
30847:     // lost!  Therefore this can only be used for setters of shared properties.
30847:     // In that case we ignore the result value anyway.
40353:     LIns* status_ins = lir->insLoad(LIR_ld, lirbuf->state,
40353:                                     (int) offsetof(InterpState, builtinStatus), ACC_OTHER);
30847:     propagateFailureToBuiltinStatus(ok_ins, status_ins);
30847:     guard(true, lir->ins_eq0(status_ins), STATUS_EXIT);
30847: 
30847:     // Re-load the value--but this is currently unused, so commented out.
40353:     //boxed_ins = lir->insLoad(LIR_ldp, vp_ins, 0, ACC_OTHER);
30847: }
30847: 
33542: JS_REQUIRES_STACK RecordingStatus
32678: TraceRecorder::emitNativeCall(JSSpecializedNative* sn, uintN argc, LIns* args[], bool rooted)
32669: {
33166:     bool constructing = !!(sn->flags & JSTN_CONSTRUCTOR);
32669: 
32669:     if (JSTN_ERRTYPE(sn) == FAIL_STATUS) {
26552:         // This needs to capture the pre-call state of the stack. So do not set
32669:         // pendingSpecializedNative before taking this snapshot.
32669:         JS_ASSERT(!pendingSpecializedNative);
26552: 
37741:         // Take snapshot for DeepBail and store it in cx->bailExit.
28086:         // If we are calling a slow native, add information to the side exit
28086:         // for SynthesizeSlowNativeFrame.
32761:         VMSideExit* exit = enterDeepBailCall();
28086:         JSObject* funobj = JSVAL_TO_OBJECT(stackval(0 - (2 + argc)));
31843:         if (FUN_SLOW_NATIVE(GET_FUNCTION_PRIVATE(cx, funobj))) {
28086:             exit->setNativeCallee(funobj, constructing);
36361:             tree->gcthings.addUnique(OBJECT_TO_JSVAL(funobj));
31843:         }
26552:     }
26552: 
32669:     LIns* res_ins = lir->insCall(sn->builtin, args);
32678: 
32678:     // Immediately unroot the vp as soon we return since we might deep bail next.
32678:     if (rooted)
40353:         lir->insStorei(INS_NULL(), lirbuf->state, offsetof(InterpState, nativeVp), ACC_OTHER);
32678: 
26552:     rval_ins = res_ins;
32669:     switch (JSTN_ERRTYPE(sn)) {
27059:       case FAIL_NULL:
32746:         guard(false, lir->ins_peq0(res_ins), OOM_EXIT);
27059:         break;
27059:       case FAIL_NEG:
27059:         res_ins = lir->ins1(LIR_i2f, res_ins);
32640:         guard(false, lir->ins2(LIR_flt, res_ins, lir->insImmf(0)), OOM_EXIT);
27059:         break;
27059:       case FAIL_VOID:
31521:         guard(false, lir->ins2i(LIR_eq, res_ins, JSVAL_TO_SPECIAL(JSVAL_VOID)), OOM_EXIT);
27059:         break;
27059:       case FAIL_COOKIE:
32746:         guard(false, lir->ins2(LIR_peq, res_ins, INS_CONSTWORD(JSVAL_ERROR_COOKIE)), OOM_EXIT);
27059:         break;
27059:       default:;
27059:     }
26552: 
26552:     set(&stackval(0 - (2 + argc)), res_ins);
26552: 
26552:     /*
28086:      * The return value will be processed by NativeCallComplete since
26552:      * we have to know the actual return value type for calls that return
26552:      * jsval (like Array_p_pop).
26552:      */
32669:     pendingSpecializedNative = sn;
26552: 
33542:     return RECORD_CONTINUE;
26552: }
26552: 
26552: /*
30860:  * Check whether we have a specialized implementation for this native
30860:  * invocation.
26552:  */
33542: JS_REQUIRES_STACK RecordingStatus
32669: TraceRecorder::callSpecializedNative(JSNativeTraceInfo *trcinfo, uintN argc,
32669:                                      bool constructing)
32669: {
20431:     JSStackFrame* fp = cx->fp;
20431:     jsbytecode *pc = fp->regs->pc;
21511: 
32613:     jsval& fval = stackval(0 - (2 + argc));
26552:     jsval& tval = stackval(0 - (1 + argc));
26552: 
18641:     LIns* this_ins = get(&tval);
20431: 
26676:     LIns* args[nanojit::MAXARGS];
32669:     JSSpecializedNative *sn = trcinfo->specializations;
32669:     JS_ASSERT(sn);
20431:     do {
32669:         if (((sn->flags & JSTN_CONSTRUCTOR) != 0) != constructing)
17651:             continue;
17634: 
32669:         uintN knownargc = strlen(sn->argtypes);
17870:         if (argc != knownargc)
18115:             continue;
17870: 
32669:         intN prefixc = strlen(sn->prefix);
20431:         JS_ASSERT(prefixc <= 3);
17870:         LIns** argp = &args[argc + prefixc - 1];
17870:         char argtype;
17870: 
29880: #if defined DEBUG
18172:         memset(args, 0xCD, sizeof(args));
18172: #endif
18172: 
20431:         uintN i;
20431:         for (i = prefixc; i--; ) {
32669:             argtype = sn->prefix[i];
20431:             if (argtype == 'C') {
20431:                 *argp = cx_ins;
20431:             } else if (argtype == 'T') { /* this, as an object */
23075:                 if (JSVAL_IS_PRIMITIVE(tval))
20431:                     goto next_specialization;
20431:                 *argp = this_ins;
20431:             } else if (argtype == 'S') { /* this, as a string */
23228:                 if (!JSVAL_IS_STRING(tval))
23228:                     goto next_specialization;
23226:                 *argp = this_ins;
32613:             } else if (argtype == 'f') {
32613:                 *argp = INS_CONSTOBJ(JSVAL_TO_OBJECT(fval));
32615:             } else if (argtype == 'p') {
32615:                 CHECK_STATUS(getClassPrototype(JSVAL_TO_OBJECT(fval), *argp));
32615:             } else if (argtype == 'R') {
32615:                 *argp = INS_CONSTPTR(cx->runtime);
20431:             } else if (argtype == 'P') {
24600:                 // FIXME: Set pc to imacpc when recording JSOP_CALL inside the
24600:                 //        JSOP_GETELEM imacro (bug 476559).
33564:                 if ((*pc == JSOP_CALL) &&
33564:                     fp->imacpc && *fp->imacpc == JSOP_GETELEM)
24600:                     *argp = INS_CONSTPTR(fp->imacpc);
24600:                 else
20431:                     *argp = INS_CONSTPTR(pc);
20431:             } else if (argtype == 'D') { /* this, as a number */
22634:                 if (!isNumber(tval))
20431:                     goto next_specialization;
20431:                 *argp = this_ins;
20431:             } else {
20431:                 JS_NOT_REACHED("unknown prefix arg type");
20431:             }
20431:             argp--;
20431:         }
20431: 
20431:         for (i = knownargc; i--; ) {
22634:             jsval& arg = stackval(0 - (i + 1));
22634:             *argp = get(&arg);
20431: 
32669:             argtype = sn->argtypes[i];
20431:             if (argtype == 'd' || argtype == 'i') {
20431:                 if (!isNumber(arg))
20431:                     goto next_specialization;
20431:                 if (argtype == 'i')
20431:                     *argp = f2i(*argp);
32615:             } else if (argtype == 'o') {
32615:                 if (JSVAL_IS_PRIMITIVE(arg))
32615:                     goto next_specialization;
20431:             } else if (argtype == 's') {
20431:                 if (!JSVAL_IS_STRING(arg))
20431:                     goto next_specialization;
32615:             } else if (argtype == 'r') {
32615:                 if (!VALUE_IS_REGEXP(cx, arg))
32615:                     goto next_specialization;
32615:             } else if (argtype == 'f') {
32615:                 if (!VALUE_IS_FUNCTION(cx, arg))
32615:                     goto next_specialization;
20431:             } else if (argtype == 'v') {
31902:                 *argp = box_jsval(arg, *argp);
20431:             } else {
20431:                 goto next_specialization;
20431:             }
20431:             argp--;
20431:         }
29880: #if defined DEBUG
18172:         JS_ASSERT(args[0] != (LIns *)0xcdcdcdcd);
18172: #endif
32678:         return emitNativeCall(sn, argc, args, false);
28086: 
28086: next_specialization:;
32669:     } while ((sn++)->flags & JSTN_MORE);
28086: 
33542:     return RECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
28086: TraceRecorder::callNative(uintN argc, JSOp mode)
28086: {
28086:     LIns* args[5];
28086: 
28086:     JS_ASSERT(mode == JSOP_CALL || mode == JSOP_NEW || mode == JSOP_APPLY);
28086: 
28086:     jsval* vp = &stackval(0 - (2 + argc));
28086:     JSObject* funobj = JSVAL_TO_OBJECT(vp[0]);
28086:     JSFunction* fun = GET_FUNCTION_PRIVATE(cx, funobj);
31900:     JSFastNative native = (JSFastNative)fun->u.n.native;
31900: 
31900:     switch (argc) {
31900:       case 1:
32571:         if (isNumber(vp[2]) &&
32571:             (native == js_math_ceil || native == js_math_floor || native == js_math_round)) {
31900:             LIns* a = get(&vp[2]);
31900:             if (isPromote(a)) {
31900:                 set(&vp[0], a);
32669:                 pendingSpecializedNative = IGNORE_NATIVE_CALL_COMPLETE_CALLBACK;
33542:                 return RECORD_CONTINUE;
31900:             }
31900:         }
31900:         break;
32658: 
31900:       case 2:
32571:         if (isNumber(vp[2]) && isNumber(vp[3]) &&
32571:             (native == js_math_min || native == js_math_max)) {
31900:             LIns* a = get(&vp[2]);
31900:             LIns* b = get(&vp[3]);
31900:             if (isPromote(a) && isPromote(b)) {
37741:                 a = demote(lir, a);
37741:                 b = demote(lir, b);
31900:                 set(&vp[0],
31900:                     lir->ins1(LIR_i2f,
31900:                               lir->ins_choose(lir->ins2((native == js_math_min)
31900:                                                         ? LIR_lt
31900:                                                         : LIR_gt, a, b),
33950:                                               a, b, avmplus::AvmCore::use_cmov())));
32669:                 pendingSpecializedNative = IGNORE_NATIVE_CALL_COMPLETE_CALLBACK;
33542:                 return RECORD_CONTINUE;
31900:             }
31900:         }
31900:         break;
31900:     }
28086: 
32669:     if (fun->flags & JSFUN_TRCINFO) {
32669:         JSNativeTraceInfo *trcinfo = FUN_TRCINFO(fun);
32669:         JS_ASSERT(trcinfo && (JSFastNative)fun->u.n.native == trcinfo->native);
32669: 
32669:         /* Try to call a type specialized version of the native. */
32669:         if (trcinfo->specializations) {
33542:             RecordingStatus status = callSpecializedNative(trcinfo, argc, mode == JSOP_NEW);
33542:             if (status != RECORD_STOP)
27933:                 return status;
26552:         }
32669:     }
26552: 
28326:     if (native == js_fun_apply || native == js_fun_call)
33542:         RETURN_STOP("trying to call native apply or call");
28326: 
38594:     if (fun->u.n.extra > 0)
38594:         RETURN_STOP("trying to trace slow native with fun->u.n.extra > 0");
38594: 
28086:     // Allocate the vp vector and emit code to root it.
38594:     uintN vplen = 2 + JS_MAX(argc, unsigned(FUN_MINARGS(fun)));
26552:     if (!(fun->flags & JSFUN_FAST_NATIVE))
28086:         vplen++; // slow native return value slot
28086:     LIns* invokevp_ins = lir->insAlloc(vplen * sizeof(jsval));
28086: 
28086:     // vp[0] is the callee.
40353:     lir->insStorei(INS_CONSTVAL(OBJECT_TO_JSVAL(funobj)), invokevp_ins, 0, ACC_OTHER);
28086: 
28086:     // Calculate |this|.
28086:     LIns* this_ins;
28086:     if (mode == JSOP_NEW) {
28086:         JSClass* clasp = fun->u.n.clasp;
28086:         JS_ASSERT(clasp != &js_SlowArrayClass);
28086:         if (!clasp)
28086:             clasp = &js_ObjectClass;
28086:         JS_ASSERT(((jsuword) clasp & 3) == 0);
28086: 
32615:         // Abort on |new Function|. js_NewInstance would allocate a regular-
28086:         // sized JSObject, not a Function-sized one. (The Function ctor would
28086:         // deep-bail anyway but let's not go there.)
28086:         if (clasp == &js_FunctionClass)
33542:             RETURN_STOP("new Function");
28086: 
28086:         if (clasp->getObjectOps)
33542:             RETURN_STOP("new with non-native ops");
28086: 
32615:         args[0] = INS_CONSTOBJ(funobj);
32615:         args[1] = INS_CONSTPTR(clasp);
32615:         args[2] = cx_ins;
32615:         newobj_ins = lir->insCall(&js_NewInstance_ci, args);
32746:         guard(false, lir->ins_peq0(newobj_ins), OOM_EXIT);
30860:         this_ins = newobj_ins; /* boxing an object is a no-op */
28086:     } else if (JSFUN_BOUND_METHOD_TEST(fun->flags)) {
35099:         /* |funobj| was rooted above already. */
39930:         this_ins = INS_CONSTWORD(OBJECT_TO_JSVAL(funobj->getParent()));
28086:     } else {
28086:         this_ins = get(&vp[1]);
30860: 
28326:         /*
28326:          * For fast natives, 'null' or primitives are fine as as 'this' value.
28326:          * For slow natives we have to ensure the object is substituted for the
28326:          * appropriate global object or boxed object value. JSOP_NEW allocates its
29896:          * own object so it's guaranteed to have a valid 'this' value.
28326:          */
28326:         if (!(fun->flags & JSFUN_FAST_NATIVE)) {
28086:             if (JSVAL_IS_NULL(vp[1])) {
40417:                 JSObject* thisObj = js_ComputeThis(cx, vp + 2);
28326:                 if (!thisObj)
33542:                     RETURN_ERROR("error in js_ComputeGlobalThis");
31843:                 this_ins = INS_CONSTOBJ(thisObj);
28326:             } else if (!JSVAL_IS_OBJECT(vp[1])) {
33542:                 RETURN_STOP("slow native(primitive, args)");
28086:             } else {
40353:                 if (guardClass(JSVAL_TO_OBJECT(vp[1]), this_ins, &js_WithClass,
40353:                                snapshot(MISMATCH_EXIT), ACC_READONLY))
33542:                     RETURN_STOP("can't trace slow native invocation on With object");
28326: 
32796:                 this_ins = lir->ins_choose(lir->ins_peq0(stobj_get_parent(this_ins)),
31843:                                            INS_CONSTOBJ(globalObj),
33950:                                            this_ins, avmplus::AvmCore::use_cmov());
28086:             }
28086:         }
31902:         this_ins = box_jsval(vp[1], this_ins);
28086:     }
40353:     lir->insStorei(this_ins, invokevp_ins, 1 * sizeof(jsval), ACC_OTHER);
28086: 
28086:     // Populate argv.
28086:     for (uintN n = 2; n < 2 + argc; n++) {
31902:         LIns* i = box_jsval(vp[n], get(&vp[n]));
40353:         lir->insStorei(i, invokevp_ins, n * sizeof(jsval), ACC_OTHER);
28086: 
28086:         // For a very long argument list we might run out of LIR space, so
28086:         // check inside the loop.
33159:         if (outOfMemory())
33542:             RETURN_STOP("out of memory in argument list");
28086:     }
28086: 
28086:     // Populate extra slots, including the return value slot for a slow native.
28086:     if (2 + argc < vplen) {
28086:         LIns* undef_ins = INS_CONSTWORD(JSVAL_VOID);
28086:         for (uintN n = 2 + argc; n < vplen; n++) {
40353:             lir->insStorei(undef_ins, invokevp_ins, n * sizeof(jsval), ACC_OTHER);
28086: 
33159:             if (outOfMemory())
33542:                 RETURN_STOP("out of memory in extra slots");
28086:         }
28086:     }
28086: 
28086:     // Set up arguments for the JSNative or JSFastNative.
40325:     uint32 typesig;
28086:     if (fun->flags & JSFUN_FAST_NATIVE) {
28086:         if (mode == JSOP_NEW)
33542:             RETURN_STOP("untraceable fast native constructor");
28086:         native_rval_ins = invokevp_ins;
28086:         args[0] = invokevp_ins;
28086:         args[1] = lir->insImm(argc);
28086:         args[2] = cx_ins;
40325:         typesig = ARGTYPE_I << (0*ARGTYPE_SHIFT) |
40325:                   ARGTYPE_P << (1*ARGTYPE_SHIFT) |
40325:                   ARGTYPE_I << (2*ARGTYPE_SHIFT) |
40325:                   ARGTYPE_P << (3*ARGTYPE_SHIFT);
28086:     } else {
32746:         int32_t offset = (vplen - 1) * sizeof(jsval);
32746:         native_rval_ins = lir->ins2(LIR_piadd, invokevp_ins, INS_CONSTWORD(offset));
28086:         args[0] = native_rval_ins;
32746:         args[1] = lir->ins2(LIR_piadd, invokevp_ins, INS_CONSTWORD(2 * sizeof(jsval)));
28086:         args[2] = lir->insImm(argc);
28086:         args[3] = this_ins;
28086:         args[4] = cx_ins;
40325:         typesig = ARGTYPE_I << (0*ARGTYPE_SHIFT) |
40325:                   ARGTYPE_P << (1*ARGTYPE_SHIFT) |
40325:                   ARGTYPE_P << (2*ARGTYPE_SHIFT) |
40325:                   ARGTYPE_I << (3*ARGTYPE_SHIFT) |
40325:                   ARGTYPE_P << (4*ARGTYPE_SHIFT) |
40325:                   ARGTYPE_P << (5*ARGTYPE_SHIFT);
28086:     }
28086: 
32669:     // Generate CallInfo and a JSSpecializedNative structure on the fly.
32669:     // Do not use JSTN_UNBOX_AFTER for mode JSOP_NEW because
32669:     // record_NativeCallComplete unboxes the result specially.
26552: 
34351:     CallInfo* ci = new (traceAlloc()) CallInfo();
26552:     ci->_address = uintptr_t(fun->u.n.native);
39910:     ci->_isPure = 0;
39910:     ci->_storeAccSet = ACC_STORE_ANY;
26552:     ci->_abi = ABI_CDECL;
40325:     ci->_typesig = typesig;
26552: #ifdef DEBUG
28086:     ci->_name = JS_GetFunctionName(fun);
26552:  #endif
26552: 
32669:     // Generate a JSSpecializedNative structure on the fly.
32669:     generatedSpecializedNative.builtin = ci;
32669:     generatedSpecializedNative.flags = FAIL_STATUS | ((mode == JSOP_NEW)
28241:                                                         ? JSTN_CONSTRUCTOR
28086:                                                         : JSTN_UNBOX_AFTER);
32669:     generatedSpecializedNative.prefix = NULL;
32669:     generatedSpecializedNative.argtypes = NULL;
26552: 
32726:     // We only have to ensure that the values we wrote into the stack buffer
32726:     // are rooted if we actually make it to the call, so only set nativeVp and
32726:     // nativeVpLen immediately before emitting the call code. This way we avoid
32726:     // leaving trace with a bogus nativeVp because we fall off trace while unboxing
32726:     // values into the stack buffer.
40353:     lir->insStorei(INS_CONST(vplen), lirbuf->state, offsetof(InterpState, nativeVpLen), ACC_OTHER);
40353:     lir->insStorei(invokevp_ins, lirbuf->state, offsetof(InterpState, nativeVp), ACC_OTHER);
32726: 
28086:     // argc is the original argc here. It is used to calculate where to place
28086:     // the return value.
32678:     return emitNativeCall(&generatedSpecializedNative, argc, args, true);
28086: }
28086: 
33542: JS_REQUIRES_STACK RecordingStatus
28086: TraceRecorder::functionCall(uintN argc, JSOp mode)
26552: {
26552:     jsval& fval = stackval(0 - (2 + argc));
26552:     JS_ASSERT(&fval >= StackBase(cx->fp));
26552: 
26552:     if (!VALUE_IS_FUNCTION(cx, fval))
33542:         RETURN_STOP("callee is not a function");
26552: 
26552:     jsval& tval = stackval(0 - (1 + argc));
26552: 
26552:     /*
26552:      * If callee is not constant, it's a shapeless call and we have to guard
26552:      * explicitly that we will get this callee again at runtime.
26552:      */
32746:     if (!get(&fval)->isconstp())
27933:         CHECK_STATUS(guardCallee(fval));
26552: 
26552:     /*
26552:      * Require that the callee be a function object, to avoid guarding on its
26552:      * class here. We know if the callee and this were pushed by JSOP_CALLNAME
26552:      * or JSOP_CALLPROP that callee is a *particular* function, since these hit
26552:      * the property cache and guard on the object (this) in which the callee
26552:      * was found. So it's sufficient to test here that the particular function
26552:      * is interpreted, not guard on that condition.
26552:      *
26552:      * Bytecode sequences that push shapeless callees must guard on the callee
26552:      * class being Function and the function being interpreted.
26552:      */
26552:     JSFunction* fun = GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(fval));
26552: 
26552:     if (FUN_INTERPRETED(fun)) {
28086:         if (mode == JSOP_NEW) {
32615:             LIns* args[] = { get(&fval), INS_CONSTPTR(&js_ObjectClass), cx_ins };
32615:             LIns* tv_ins = lir->insCall(&js_NewInstance_ci, args);
32746:             guard(false, lir->ins_peq0(tv_ins), OOM_EXIT);
32615:             set(&tval, tv_ins);
26552:         }
28086:         return interpretedFunctionCall(fval, fun, argc, mode == JSOP_NEW);
26552:     }
26552: 
26552:     if (FUN_SLOW_NATIVE(fun)) {
26552:         JSNative native = fun->u.n.native;
28086:         jsval* argv = &tval + 1;
26552:         if (native == js_Array)
28086:             return newArray(JSVAL_TO_OBJECT(fval), argc, argv, &fval);
28240:         if (native == js_String && argc == 1) {
28086:             if (mode == JSOP_NEW)
28086:                 return newString(JSVAL_TO_OBJECT(fval), 1, argv, &fval);
28175:             if (!JSVAL_IS_PRIMITIVE(argv[0])) {
33542:                 RETURN_IF_XML(argv[0]);
26552:                 return call_imacro(call_imacros.String);
28175:             }
28086:             set(&fval, stringify(argv[0]));
32669:             pendingSpecializedNative = IGNORE_NATIVE_CALL_COMPLETE_CALLBACK;
33542:             return RECORD_CONTINUE;
28086:         }
28086:     }
28086: 
28086:     return callNative(argc, mode);
20431: }
20431: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
20431: TraceRecorder::record_JSOP_NEW()
20431: {
27234:     uintN argc = GET_ARGC(cx->fp->regs->pc);
27234:     cx->fp->assertValidStackDepth(argc + 2);
33542:     return InjectStatus(functionCall(argc, JSOP_NEW));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_DELNAME()
18300: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_DELPROP()
18300: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_DELELEM()
18300: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_TYPEOF()
18300: {
18300:     jsval& r = stackval(-1);
18300:     LIns* type;
18300:     if (JSVAL_IS_STRING(r)) {
31843:         type = INS_ATOM(cx->runtime->atomState.typeAtoms[JSTYPE_STRING]);
18300:     } else if (isNumber(r)) {
31843:         type = INS_ATOM(cx->runtime->atomState.typeAtoms[JSTYPE_NUMBER]);
27572:     } else if (VALUE_IS_FUNCTION(cx, r)) {
31843:         type = INS_ATOM(cx->runtime->atomState.typeAtoms[JSTYPE_FUNCTION]);
18300:     } else {
18300:         LIns* args[] = { get(&r), cx_ins };
31521:         if (JSVAL_IS_SPECIAL(r)) {
18300:             // We specialize identically for boolean and undefined. We must not have a hole here.
18300:             // Pass the unboxed type here, since TypeOfBoolean knows how to handle it.
24846:             JS_ASSERT(r == JSVAL_TRUE || r == JSVAL_FALSE || r == JSVAL_VOID);
20915:             type = lir->insCall(&js_TypeOfBoolean_ci, args);
18300:         } else {
23075:             JS_ASSERT(JSVAL_TAG(r) == JSVAL_OBJECT);
20915:             type = lir->insCall(&js_TypeOfObject_ci, args);
18300:         }
18300:     }
18300:     set(&r, type);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_VOID()
18300: {
40307:     stack(-1, INS_VOID());
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_INCNAME()
18300: {
18300:     return incName(1);
18300: }
18300: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_INCPROP()
18300: {
18300:     return incProp(1);
18300: }
18300: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_INCELEM()
18300: {
33542:     return InjectStatus(incElem(1));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_DECNAME()
18300: {
18300:     return incName(-1);
18300: }
18300: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_DECPROP()
18300: {
18300:     return incProp(-1);
18300: }
18300: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_DECELEM()
18300: {
33542:     return InjectStatus(incElem(-1));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::incName(jsint incr, bool pre)
18300: {
18300:     jsval* vp;
30647:     LIns* v_ins;
31480:     LIns* v_after;
31075:     NameResult nr;
31480: 
33542:     CHECK_STATUS_A(name(vp, v_ins, nr));
32593:     jsval v = nr.tracked ? *vp : nr.v;
33542:     CHECK_STATUS_A(incHelper(v, v_ins, v_after, incr));
31480:     LIns* v_result = pre ? v_after : v_ins;
31075:     if (nr.tracked) {
31480:         set(vp, v_after);
31480:         stack(0, v_result);
33542:         return ARECORD_CONTINUE;
27933:     }
27933: 
31075:     if (OBJ_GET_CLASS(cx, nr.obj) != &js_CallClass)
33542:         RETURN_STOP_A("incName on unsupported object class");
33542: 
33542:     CHECK_STATUS_A(setCallProp(nr.obj, nr.obj_ins, nr.sprop, v_after, v));
31480:     stack(0, v_result);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_NAMEINC()
18300: {
18300:     return incName(1, false);
18300: }
18300: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_PROPINC()
18300: {
18300:     return incProp(1, false);
18300: }
18300: 
18300: // XXX consolidate with record_JSOP_GETELEM code...
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_ELEMINC()
18300: {
33542:     return InjectStatus(incElem(1, false));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_NAMEDEC()
18300: {
21805:     return incName(-1, false);
18300: }
18300: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_PROPDEC()
18300: {
18300:     return incProp(-1, false);
18300: }
18300: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_ELEMDEC()
18300: {
33542:     return InjectStatus(incElem(-1, false));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_GETPROP()
18300: {
18300:     return getProp(stackval(-1));
18300: }
18300: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_SETPROP()
18300: {
19093:     jsval& l = stackval(-2);
19093:     if (JSVAL_IS_PRIMITIVE(l))
33542:         RETURN_STOP_A("primitive this for SETPROP");
19093: 
19093:     JSObject* obj = JSVAL_TO_OBJECT(l);
19093:     if (obj->map->ops->setProperty != js_SetProperty)
33542:         RETURN_STOP_A("non-native JSObjectOps::setProperty");
33542:     return ARECORD_CONTINUE;
27933: }
27933: 
30847: /* Emit a specialized, inlined copy of js_NativeSet. */
33542: JS_REQUIRES_STACK RecordingStatus
30847: TraceRecorder::nativeSet(JSObject* obj, LIns* obj_ins, JSScopeProperty* sprop,
30847:                          jsval v, LIns* v_ins)
30847: {
30847:     JSScope* scope = OBJ_SCOPE(obj);
30847:     uint32 slot = sprop->slot;
30847: 
30847:     /*
30847:      * We do not trace assignment to properties that have both a nonstub setter
30847:      * and a slot, for several reasons.
30847:      *
30847:      * First, that would require sampling rt->propertyRemovals before and after
30847:      * (see js_NativeSet), and even more code to handle the case where the two
30847:      * samples differ. A mere guard is not enough, because you can't just bail
30847:      * off trace in the middle of a property assignment without storing the
30847:      * value and making the stack right.
30847:      *
30847:      * If obj is the global object, there are two additional problems. We would
30847:      * have to emit still more code to store the result in the object (not the
30847:      * native global frame) if the setter returned successfully after
30847:      * deep-bailing.  And we would have to cope if the run-time type of the
30847:      * setter's return value differed from the record-time type of v, in which
30847:      * case unboxing would fail and, having called a native setter, we could
30847:      * not just retry the instruction in the interpreter.
30847:      */
40265:     JS_ASSERT(sprop->hasDefaultSetter() || slot == SPROP_INVALID_SLOT);
30847: 
30847:     // Box the value to be stored, if necessary.
30847:     LIns* boxed_ins = NULL;
40265:     if (!sprop->hasDefaultSetter() || (slot != SPROP_INVALID_SLOT && obj != globalObj))
31902:         boxed_ins = box_jsval(v, v_ins);
30847: 
30847:     // Call the setter, if any.
40265:     if (!sprop->hasDefaultSetter())
30847:         emitNativePropertyOp(scope, sprop, obj_ins, true, boxed_ins);
30847: 
30847:     // Store the value, if this property has a slot.
30847:     if (slot != SPROP_INVALID_SLOT) {
30847:         JS_ASSERT(SPROP_HAS_VALID_SLOT(sprop, scope));
40265:         JS_ASSERT(sprop->hasSlot());
30847:         if (obj == globalObj) {
30847:             if (!lazilyImportGlobalSlot(slot))
33542:                 RETURN_STOP("lazy import of global slot failed");
40410:             set(&obj->getSlotRef(slot), v_ins);
30847:         } else {
30847:             LIns* dslots_ins = NULL;
30847:             stobj_set_slot(obj_ins, slot, dslots_ins, boxed_ins);
30847:         }
30847:     }
30847: 
33542:     return RECORD_CONTINUE;
30847: }
30847: 
32658: static JSBool FASTCALL
32658: MethodWriteBarrier(JSContext* cx, JSObject* obj, JSScopeProperty* sprop, JSObject* funobj)
32658: {
40403:     AutoValueRooter tvr(cx, funobj);
32658: 
32658:     return OBJ_SCOPE(obj)->methodWriteBarrier(cx, sprop, tvr.value());
32658: }
32658: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, MethodWriteBarrier, CONTEXT, OBJECT, SCOPEPROP, OBJECT,
39910:                      0, ACC_STORE_ANY)
32658: 
33542: JS_REQUIRES_STACK RecordingStatus
40362: TraceRecorder::setProp(jsval &l, PropertyCacheEntry* entry, JSScopeProperty* sprop,
30847:                        jsval &v, LIns*& v_ins)
19093: {
27932:     if (entry == JS_NO_PROP_CACHE_FILL)
33542:         RETURN_STOP("can't trace uncacheable property set");
40362:     JS_ASSERT_IF(entry->vcapTag() >= 1, !sprop->hasSlot());
40265:     if (!sprop->hasDefaultSetter() && sprop->slot != SPROP_INVALID_SLOT)
33542:         RETURN_STOP("can't trace set of property with setter and slot");
40265:     if (sprop->hasSetterValue())
33542:         RETURN_STOP("can't trace JavaScript function setter");
30847: 
31064:     // These two cases are errors and can't be traced.
40265:     if (sprop->hasGetterValue())
33542:         RETURN_STOP("can't assign to property with script getter but no setter");
40265:     if (!sprop->writable())
33542:         RETURN_STOP("can't assign to readonly property");
18300: 
19093:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(l));
18300:     JSObject* obj = JSVAL_TO_OBJECT(l);
18300:     LIns* obj_ins = get(&l);
40795: 
40795:     JS_ASSERT_IF(entry->directHit(), OBJ_SCOPE(obj)->hasProperty(sprop));
25938: 
30848:     // Fast path for CallClass. This is about 20% faster than the general case.
31062:     v_ins = get(&v);
32658:     if (OBJ_GET_CLASS(cx, obj) == &js_CallClass)
31449:         return setCallProp(obj, obj_ins, sprop, v_ins, v);
32658: 
30847:     // Find obj2. If entry->adding(), the TAG bits are all 0.
30847:     JSObject* obj2 = obj;
40362:     for (jsuword i = entry->scopeIndex(); i; i--)
39930:         obj2 = obj2->getParent();
40362:     for (jsuword j = entry->protoIndex(); j; j--)
39928:         obj2 = obj2->getProto();
40795:     JSScope *scope = OBJ_SCOPE(obj2);
30847:     JS_ASSERT_IF(entry->adding(), obj2 == obj);
30847: 
30847:     // Guard before anything else.
40374:     PCVal pcval;
40393:     CHECK_STATUS(guardPropertyCacheHit(obj_ins, obj, obj2, entry, pcval));
30847:     JS_ASSERT(scope->object == obj2);
35453:     JS_ASSERT(scope->hasProperty(sprop));
40265:     JS_ASSERT_IF(obj2 != obj, !sprop->hasSlot());
30847: 
34040:     /*
34040:      * Setting a function-valued property might need to rebrand the object, so
34040:      * we emit a call to the method write barrier. There's no need to guard on
34040:      * this, because functions have distinct trace-type from other values and
34040:      * branded-ness is implied by the shape, which we've already guarded on.
34040:      */
35224:     if (scope->brandedOrHasMethodBarrier() && VALUE_IS_FUNCTION(cx, v) && entry->directHit()) {
34040:         if (obj == globalObj)
34040:             RETURN_STOP("can't trace function-valued property set in branded global scope");
34040: 
34040:         enterDeepBailCall();
34040:         LIns* args[] = { v_ins, INS_CONSTSPROP(sprop), obj_ins, cx_ins };
34040:         LIns* ok_ins = lir->insCall(&MethodWriteBarrier_ci, args);
34040:         guard(false, lir->ins_eq0(ok_ins), OOM_EXIT);
34040:         leaveDeepBailCall();
34040:     }
34040: 
30847:     // Add a property to the object if necessary.
30847:     if (entry->adding()) {
40265:         JS_ASSERT(sprop->hasSlot());
30847:         if (obj == globalObj)
33542:             RETURN_STOP("adding a property to the global object");
28312: 
31843:         LIns* args[] = { INS_CONSTSPROP(sprop), obj_ins, cx_ins };
20915:         LIns* ok_ins = lir->insCall(&js_AddProperty_ci, args);
19171:         guard(false, lir->ins_eq0(ok_ins), OOM_EXIT);
18300:     }
18300: 
30847:     return nativeSet(obj, obj_ins, sprop, v, v_ins);
30847: }
30847: 
33542: JS_REQUIRES_STACK RecordingStatus
31449: TraceRecorder::setCallProp(JSObject *callobj, LIns *callobj_ins, JSScopeProperty *sprop,
31449:                            LIns *v_ins, jsval v)
31449: {
31449:     // Set variables in on-trace-stack call objects by updating the tracker.
31449:     JSStackFrame *fp = frameIfInRange(callobj);
31449:     if (fp) {
39894:         if (sprop->setterOp() == SetCallArg) {
38562:             JS_ASSERT(sprop->hasShortID());
35483:             uintN slot = uint16(sprop->shortid);
31449:             jsval *vp2 = &fp->argv[slot];
31449:             set(vp2, v_ins);
33542:             return RECORD_CONTINUE;
31449:         }
39894:         if (sprop->setterOp() == SetCallVar) {
38562:             JS_ASSERT(sprop->hasShortID());
35483:             uintN slot = uint16(sprop->shortid);
31449:             jsval *vp2 = &fp->slots[slot];
31449:             set(vp2, v_ins);
33542:             return RECORD_CONTINUE;
33542:         }
33542:         RETURN_STOP("can't trace special CallClass setter");
31449:     }
31449: 
35480:     if (!callobj->getPrivate()) {
35480:         // Because the parent guard in guardCallee ensures this Call object
35480:         // will be the same object now and on trace, and because once a Call
35480:         // object loses its frame it never regains one, on trace we will also
35480:         // have a null private in the Call object. So all we need to do is
35480:         // write the value to the Call object's slot.
35483:         int32 dslot_index = uint16(sprop->shortid);
39894:         if (sprop->setterOp() == SetCallArg) {
35483:             JS_ASSERT(dslot_index < ArgClosureTraits::slot_count(callobj));
35483:             dslot_index += ArgClosureTraits::slot_offset(callobj);
39894:         } else if (sprop->setterOp() == SetCallVar) {
35483:             JS_ASSERT(dslot_index < VarClosureTraits::slot_count(callobj));
35483:             dslot_index += VarClosureTraits::slot_offset(callobj);
35483:         } else {
35483:             RETURN_STOP("can't trace special CallClass setter");
35483:         }
35483: 
35483:         // Now assert that the shortid get we did above was ok. Have to do it
35483:         // after the RETURN_STOP above, since in that case we may in fact not
35483:         // have a valid shortid; but we don't use it in that case anyway.
38562:         JS_ASSERT(sprop->hasShortID());
35480: 
40353:         LIns* base = lir->insLoad(LIR_ldp, callobj_ins, offsetof(JSObject, dslots), ACC_OTHER);
40353:         lir->insStorei(box_jsval(v, v_ins), base, dslot_index * sizeof(jsval), ACC_OTHER);
35480:         return RECORD_CONTINUE;
35480:     }
35480: 
35480:     // This is the hard case: we have a JSStackFrame private, but it's not in
35480:     // range.  During trace execution we may or may not have a JSStackFrame
35480:     // anymore.  Call the standard builtins, which handle that situation.
35480: 
31449:     // Set variables in off-trace-stack call objects by calling standard builtins.
31075:     const CallInfo* ci = NULL;
39894:     if (sprop->setterOp() == SetCallArg)
31075:         ci = &js_SetCallArg_ci;
39894:     else if (sprop->setterOp() == SetCallVar)
31075:         ci = &js_SetCallVar_ci;
31075:     else
33542:         RETURN_STOP("can't trace special CallClass setter");
31075: 
37009:     // Even though the frame is out of range, later we might be called as an
37009:     // inner trace such that the target variable is defined in the outer trace
37009:     // entry frame. In that case, we must store to the native stack area for
37009:     // that frame.
37009: 
40353:     LIns *fp_ins = lir->insLoad(LIR_ldp, cx_ins, offsetof(JSContext, fp), ACC_OTHER);
40353:     LIns *fpcallobj_ins = lir->insLoad(LIR_ldp, fp_ins, offsetof(JSStackFrame, callobj),
40353:                                        ACC_OTHER);
37009:     LIns *br1 = lir->insBranch(LIR_jf, lir->ins2(LIR_peq, fpcallobj_ins, callobj_ins), NULL);
37009: 
37009:     // Case 1: storing to native stack area.
37009: 
37009:     // Compute native stack slot and address offset we are storing to.
37009:     unsigned slot = uint16(sprop->shortid);
37009:     LIns *slot_ins;
39894:     if (sprop->setterOp() == SetCallArg)
37009:         slot_ins = ArgClosureTraits::adj_slot_lir(lir, fp_ins, slot);
37009:     else
37009:         slot_ins = VarClosureTraits::adj_slot_lir(lir, fp_ins, slot);
37009:     LIns *offset_ins = lir->ins2(LIR_mul, slot_ins, INS_CONST(sizeof(double)));
37009: 
37009:     // Guard that we are not changing the type of the slot we are storing to.
37009:     LIns *callstackBase_ins = lir->insLoad(LIR_ldp, lirbuf->state,
40353:                                            offsetof(InterpState, callstackBase), ACC_OTHER);
40353:     LIns *frameInfo_ins = lir->insLoad(LIR_ldp, callstackBase_ins, 0, ACC_OTHER);
40370:     LIns *typemap_ins = lir->ins2(LIR_piadd, frameInfo_ins, INS_CONSTWORD(sizeof(FrameInfo)));
39910:     LIns *type_ins = lir->insLoad(LIR_ldzb,
40370:                                   lir->ins2(LIR_piadd, typemap_ins, lir->ins_u2p(slot_ins)), 0,
39910:                                   ACC_READONLY);
37741:     TraceType type = getCoercedType(v);
37009:     if (type == TT_INT32 && !isPromoteInt(v_ins))
37009:         type = TT_DOUBLE;
37009:     guard(true,
37009:           addName(lir->ins2(LIR_eq, type_ins, lir->insImm(type)),
37009:                   "guard(type-stable set upvar)"),
37009:           BRANCH_EXIT);
37009: 
37009:     // Store to the native stack slot.
37009:     LIns *stackBase_ins = lir->insLoad(LIR_ldp, lirbuf->state,
40353:                                        offsetof(InterpState, stackBase), ACC_OTHER);
37009:     LIns *storeValue_ins = isPromoteInt(v_ins) ? demote(lir, v_ins) : v_ins;
37009:     lir->insStorei(storeValue_ins,
40370:                    lir->ins2(LIR_piadd, stackBase_ins, lir->ins_u2p(offset_ins)), 0, ACC_STORE_ANY);
37009:     LIns *br2 = lir->insBranch(LIR_j, NULL, NULL);
37009: 
37009:     // Case 2: calling builtin.
37009:     LIns *label1 = lir->ins0(LIR_label);
37009:     br1->setTarget(label1);
31075:     LIns* args[] = {
31902:         box_jsval(v, v_ins),
37736:         INS_CONSTWORD(SPROP_USERID(sprop)),
31075:         callobj_ins,
31075:         cx_ins
31075:     };
31075:     LIns* call_ins = lir->insCall(ci, args);
31075:     guard(false, addName(lir->ins_eq0(call_ins), "guard(set upvar)"), STATUS_EXIT);
37009: 
37009:     LIns *label2 = lir->ins0(LIR_label);
37009:     br2->setTarget(label2);
37009: 
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
40362: TraceRecorder::record_SetPropHit(PropertyCacheEntry* entry, JSScopeProperty* sprop)
30847: {
30847:     jsval& r = stackval(-1);
30847:     jsval& l = stackval(-2);
30847:     LIns* v_ins;
33542:     CHECK_STATUS_A(setProp(l, entry, sprop, r, v_ins));
30847: 
30847:     jsbytecode* pc = cx->fp->regs->pc;
32658:     switch (*pc) {
32658:       case JSOP_SETPROP:
32658:       case JSOP_SETNAME:
32658:       case JSOP_SETMETHOD:
32658:         if (pc[JSOP_SETPROP_LENGTH] != JSOP_POP)
19093:             set(&l, v_ins);
32658:         break;
32658: 
32658:       default:;
32658:     }
30847: 
33542:     return ARECORD_CONTINUE;
19093: }
19093: 
32761: JS_REQUIRES_STACK VMSideExit*
31444: TraceRecorder::enterDeepBailCall()
31444: {
37741:     // Take snapshot for DeepBail and store it in cx->bailExit.
31444:     VMSideExit* exit = snapshot(DEEP_BAIL_EXIT);
40353:     lir->insStorei(INS_CONSTPTR(exit), cx_ins, offsetof(JSContext, bailExit), ACC_OTHER);
31444: 
31444:     // Tell nanojit not to discard or defer stack writes before this call.
33161:     GuardRecord* guardRec = createGuardRecord(exit);
32654:     lir->insGuard(LIR_xbarrier, NULL, guardRec);
33560: 
33560:     // Forget about guarded shapes, since deep bailers can reshape the world.
33560:     forgetGuardedShapes();
32761:     return exit;
31444: }
31444: 
31444: JS_REQUIRES_STACK void
31444: TraceRecorder::leaveDeepBailCall()
31444: {
31444:     // Keep cx->bailExit null when it's invalid.
40353:     lir->insStorei(INS_NULL(), cx_ins, offsetof(JSContext, bailExit), ACC_OTHER);
31444: }
31444: 
31444: JS_REQUIRES_STACK void
31444: TraceRecorder::finishGetProp(LIns* obj_ins, LIns* vp_ins, LIns* ok_ins, jsval* outp)
31444: {
31444:     // Store the boxed result (and this-object, if JOF_CALLOP) before the
31444:     // guard. The deep-bail case requires this. If the property get fails,
31444:     // these slots will be ignored anyway.
40353:     LIns* result_ins = lir->insLoad(LIR_ldp, vp_ins, 0, ACC_OTHER);
39913:     set(outp, result_ins);
31444:     if (js_CodeSpec[*cx->fp->regs->pc].format & JOF_CALLOP)
39913:         set(outp + 1, obj_ins);
31444: 
31444:     // We need to guard on ok_ins, but this requires a snapshot of the state
31444:     // after this op. monitorRecording will do it for us.
31444:     pendingGuardCondition = ok_ins;
31444: 
31444:     // Note there is a boxed result sitting on the stack. The caller must leave
31444:     // it there for the time being, since the return type is not yet
31444:     // known. monitorRecording will emit the code to unbox it.
31444:     pendingUnboxSlot = outp;
31444: }
31444: 
31829: static inline bool
31829: RootedStringToId(JSContext* cx, JSString** namep, jsid* idp)
31829: {
31829:     JSString* name = *namep;
31829:     if (name->isAtomized()) {
31829:         *idp = ATOM_TO_JSID((JSAtom*) STRING_TO_JSVAL(name));
31829:         return true;
31829:     }
31829: 
31829:     JSAtom* atom = js_AtomizeString(cx, name, 0);
31829:     if (!atom)
31829:         return false;
31829:     *namep = ATOM_TO_STRING(atom); /* write back to GC root */
31829:     *idp = ATOM_TO_JSID(atom);
31829:     return true;
31829: }
31829: 
31524: static JSBool FASTCALL
31524: GetPropertyByName(JSContext* cx, JSObject* obj, JSString** namep, jsval* vp)
31524: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
31524: 
31524:     jsid id;
31829:     if (!RootedStringToId(cx, namep, &id) || !obj->getProperty(cx, id, vp)) {
37741:         SetBuiltinError(cx);
32658:         return false;
31444:     }
31829:     return cx->interpState->builtinStatus == 0;
31829: }
31444: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, GetPropertyByName, CONTEXT, OBJECT, STRINGPTR, JSVALPTR,
39910:                      0, ACC_STORE_ANY)
31444: 
31829: // Convert the value in a slot to a string and store the resulting string back
31829: // in the slot (typically in order to root it).
33542: JS_REQUIRES_STACK RecordingStatus
31829: TraceRecorder::primitiveToStringInPlace(jsval* vp)
31829: {
31829:     jsval v = *vp;
31829:     JS_ASSERT(JSVAL_IS_PRIMITIVE(v));
31829: 
31829:     if (!JSVAL_IS_STRING(v)) {
31829:         // v is not a string. Turn it into one. js_ValueToString is safe
31829:         // because v is not an object.
31829:         JSString *str = js_ValueToString(cx, v);
31444:         if (!str)
33542:             RETURN_ERROR("failed to stringify element id");
31829:         v = STRING_TO_JSVAL(str);
31829:         set(vp, stringify(*vp));
31829: 
31829:         // Write the string back to the stack to save the interpreter some work
31829:         // and to ensure snapshots get the correct type for this slot.
31829:         *vp = v;
31829:     }
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
31829: TraceRecorder::getPropertyByName(LIns* obj_ins, jsval* idvalp, jsval* outp)
31829: {
31829:     CHECK_STATUS(primitiveToStringInPlace(idvalp));
31444:     enterDeepBailCall();
31444: 
31444:     // Call GetPropertyByName. The vp parameter points to stack because this is
31444:     // what the interpreter currently does. obj and id are rooted on the
31444:     // interpreter stack, but the slot at vp is not a root.
31444:     LIns* vp_ins = addName(lir->insAlloc(sizeof(jsval)), "vp");
31444:     LIns* idvalp_ins = addName(addr(idvalp), "idvalp");
31444:     LIns* args[] = {vp_ins, idvalp_ins, obj_ins, cx_ins};
31444:     LIns* ok_ins = lir->insCall(&GetPropertyByName_ci, args);
31444: 
31444:     // GetPropertyByName can assign to *idvalp, so the tracker has an incorrect
31444:     // entry for that address. Correct it. (If the value in the address is
31444:     // never used again, the usual case, Nanojit will kill this load.)
40353:     // The AccSet could be made more precise with some effort (idvalp_ins may
40353:     // equal 'sp+k'), but it's not worth it because this case is rare.
40353:     tracker.set(idvalp, lir->insLoad(LIR_ldp, idvalp_ins, 0, ACC_STACK|ACC_OTHER));
31444: 
31444:     finishGetProp(obj_ins, vp_ins, ok_ins, outp);
31444:     leaveDeepBailCall();
33542:     return RECORD_CONTINUE;
31444: }
31444: 
31444: static JSBool FASTCALL
31445: GetPropertyByIndex(JSContext* cx, JSObject* obj, int32 index, jsval* vp)
31444: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
31444: 
40403:     AutoIdRooter idr(cx);
31501:     if (!js_Int32ToId(cx, index, idr.addr()) || !obj->getProperty(cx, idr.id(), vp)) {
37741:         SetBuiltinError(cx);
24489:         return JS_FALSE;
31444:     }
31444:     return cx->interpState->builtinStatus == 0;
31444: }
39910: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, GetPropertyByIndex, CONTEXT, OBJECT, INT32, JSVALPTR, 0,
39910:                      ACC_STORE_ANY)
31444: 
33542: JS_REQUIRES_STACK RecordingStatus
31444: TraceRecorder::getPropertyByIndex(LIns* obj_ins, LIns* index_ins, jsval* outp)
31444: {
31444:     index_ins = makeNumberInt32(index_ins);
31444: 
31444:     // See note in getPropertyByName about vp.
31444:     enterDeepBailCall();
31444:     LIns* vp_ins = addName(lir->insAlloc(sizeof(jsval)), "vp");
31444:     LIns* args[] = {vp_ins, index_ins, obj_ins, cx_ins};
31444:     LIns* ok_ins = lir->insCall(&GetPropertyByIndex_ci, args);
31444:     finishGetProp(obj_ins, vp_ins, ok_ins, outp);
31444:     leaveDeepBailCall();
33542:     return RECORD_CONTINUE;
31444: }
24489: 
32557: static JSBool FASTCALL
32557: GetPropertyById(JSContext* cx, JSObject* obj, jsid id, jsval* vp)
32557: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
32557:     if (!obj->getProperty(cx, id, vp)) {
37741:         SetBuiltinError(cx);
32557:         return JS_FALSE;
32557:     }
32557:     return cx->interpState->builtinStatus == 0;
32557: }
39910: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, GetPropertyById, CONTEXT, OBJECT, JSVAL, JSVALPTR,
39910:                      0, ACC_STORE_ANY)
32557: 
33542: JS_REQUIRES_STACK RecordingStatus
32557: TraceRecorder::getPropertyById(LIns* obj_ins, jsval* outp)
32557: {
32557:     // Find the atom.
32557:     JSAtom* atom;
32557:     jsbytecode* pc = cx->fp->regs->pc;
32557:     const JSCodeSpec& cs = js_CodeSpec[*pc];
32557:     if (*pc == JSOP_LENGTH) {
32557:         atom = cx->runtime->atomState.lengthAtom;
32557:     } else if (JOF_TYPE(cs.format) == JOF_ATOM) {
32557:         atom = atoms[GET_INDEX(pc)];
32557:     } else {
32557:         JS_ASSERT(JOF_TYPE(cs.format) == JOF_SLOTATOM);
32557:         atom = atoms[GET_INDEX(pc + SLOTNO_LEN)];
32557:     }
32557: 
32557:     // Call GetPropertyById. See note in getPropertyByName about vp.
32557:     enterDeepBailCall();
32557:     jsid id = ATOM_TO_JSID(atom);
32557:     LIns* vp_ins = addName(lir->insAlloc(sizeof(jsval)), "vp");
32557:     LIns* args[] = {vp_ins, INS_CONSTWORD(id), obj_ins, cx_ins};
32557:     LIns* ok_ins = lir->insCall(&GetPropertyById_ci, args);
32557:     finishGetProp(obj_ins, vp_ins, ok_ins, outp);
32557:     leaveDeepBailCall();
33542:     return RECORD_CONTINUE;
32557: }
32557: 
32558: /* Manually inlined, specialized copy of js_NativeGet. */
32558: static JSBool FASTCALL
32558: GetPropertyWithNativeGetter(JSContext* cx, JSObject* obj, JSScopeProperty* sprop, jsval* vp)
32558: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
32558: 
32558: #ifdef DEBUG
32558:     JSProperty* prop;
32558:     JSObject* pobj;
32558:     JS_ASSERT(obj->lookupProperty(cx, sprop->id, &pobj, &prop));
32558:     JS_ASSERT(prop == (JSProperty*) sprop);
36360:     pobj->dropProperty(cx, prop);
32558: #endif
32558: 
32658:     // JSScopeProperty::get contains a special case for With objects. We can
32658:     // elide it here because With objects are, we claim, never on the operand
32658:     // stack while recording.
38497:     JS_ASSERT(obj->getClass() != &js_WithClass);
32558: 
32558:     *vp = JSVAL_VOID;
39894:     if (!sprop->getterOp()(cx, obj, SPROP_USERID(sprop), vp)) {
37741:         SetBuiltinError(cx);
32558:         return JS_FALSE;
32558:     }
32558:     return cx->interpState->builtinStatus == 0;
32558: }
32558: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, GetPropertyWithNativeGetter,
39910:                      CONTEXT, OBJECT, SCOPEPROP, JSVALPTR, 0, ACC_STORE_ANY)
32558: 
33542: JS_REQUIRES_STACK RecordingStatus
32558: TraceRecorder::getPropertyWithNativeGetter(LIns* obj_ins, JSScopeProperty* sprop, jsval* outp)
32558: {
40265:     JS_ASSERT(!sprop->hasGetterValue());
32558:     JS_ASSERT(sprop->slot == SPROP_INVALID_SLOT);
40265:     JS_ASSERT(!sprop->hasDefaultGetterOrIsMethod());
32558: 
32558:     // Call GetPropertyWithNativeGetter. See note in getPropertyByName about vp.
32558:     // FIXME - We should call the getter directly. Using a builtin function for
32558:     // now because it buys some extra asserts. See bug 508310.
32558:     enterDeepBailCall();
32558:     LIns* vp_ins = addName(lir->insAlloc(sizeof(jsval)), "vp");
32558:     LIns* args[] = {vp_ins, INS_CONSTPTR(sprop), obj_ins, cx_ins};
32558:     LIns* ok_ins = lir->insCall(&GetPropertyWithNativeGetter_ci, args);
32558:     finishGetProp(obj_ins, vp_ins, ok_ins, outp);
32558:     leaveDeepBailCall();
33542:     return RECORD_CONTINUE;
33542: }
33542: 
37765: // Typed array tracing depends on EXPANDED_LOADSTORE and F2I
37765: #if NJ_EXPANDED_LOADSTORE_SUPPORTED && NJ_F2I_SUPPORTED
37754: static bool OkToTraceTypedArrays = true;
37754: #else
37754: static bool OkToTraceTypedArrays = false;
37754: #endif
37754: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_GETELEM()
18300: {
26552:     bool call = *cx->fp->regs->pc == JSOP_CALLELEM;
26551: 
19979:     jsval& idx = stackval(-1);
19983:     jsval& lval = stackval(-2);
19983: 
19983:     LIns* obj_ins = get(&lval);
19979:     LIns* idx_ins = get(&idx);
19979: 
26274:     // Special case for array-like access of strings.
26274:     if (JSVAL_IS_STRING(lval) && isInt32(idx)) {
26551:         if (call)
33542:             RETURN_STOP_A("JSOP_CALLELEM on a string");
26274:         int i = asInt32(idx);
29366:         if (size_t(i) >= JSVAL_TO_STRING(lval)->length())
33542:             RETURN_STOP_A("Invalid string index in JSOP_GETELEM");
19979:         idx_ins = makeNumberInt32(idx_ins);
19979:         LIns* args[] = { idx_ins, obj_ins, cx_ins };
20915:         LIns* unitstr_ins = lir->insCall(&js_String_getelem_ci, args);
32746:         guard(false, lir->ins_peq0(unitstr_ins), MISMATCH_EXIT);
19983:         set(&lval, unitstr_ins);
33542:         return ARECORD_CONTINUE;
19983:     }
19983: 
19983:     if (JSVAL_IS_PRIMITIVE(lval))
33542:         RETURN_STOP_A("JSOP_GETLEM on a primitive");
33542:     RETURN_IF_XML_A(lval);
19979: 
19983:     JSObject* obj = JSVAL_TO_OBJECT(lval);
31444:     if (obj == globalObj)
33542:         RETURN_STOP_A("JSOP_GETELEM on global");
19979:     LIns* v_ins;
19979: 
26274:     /* Property access using a string name or something we have to stringify. */
26274:     if (!JSVAL_IS_INT(idx)) {
26374:         if (!JSVAL_IS_PRIMITIVE(idx))
33542:             RETURN_STOP_A("object used as index");
33542: 
33542:         return InjectStatus(getPropertyByName(obj_ins, &idx, &lval));
19979:     }
19979: 
40405:     if (obj->isArguments()) {
30248:         unsigned depth;
31460:         JSStackFrame *afp = guardArguments(obj, obj_ins, &depth);
30248:         if (afp) {
30248:             uintN int_idx = JSVAL_TO_INT(idx);
30248:             jsval* vp = &afp->argv[int_idx];
32640:             if (idx_ins->isconstf()) {
30248:                 if (int_idx >= 0 && int_idx < afp->argc)
30248:                     v_ins = get(vp);
30248:                 else
30248:                     v_ins = INS_VOID();
30248:             } else {
30248:                 // If the index is not a constant expression, we generate LIR to load the value from
30248:                 // the native stack area. The guard on js_ArgumentClass above ensures the up-to-date
30248:                 // value has been written back to the native stack area.
30248:                 idx_ins = makeNumberInt32(idx_ins);
38628:                 if (int_idx < 0 || int_idx >= afp->argc)
38628:                     RETURN_STOP_A("cannot trace arguments with out of range index");
38628: 
37693:                 guard(true,
37693:                       addName(lir->ins2(LIR_ge, idx_ins, INS_CONST(0)),
37693:                               "guard(upvar index >= 0)"),
38628:                       MISMATCH_EXIT);
37693:                 guard(true,
37693:                       addName(lir->ins2(LIR_lt, idx_ins, INS_CONST(afp->argc)),
37693:                               "guard(upvar index in range)"),
38628:                       MISMATCH_EXIT);
37693: 
37741:                 TraceType type = getCoercedType(*vp);
30248: 
30248:                 // Guard that the argument has the same type on trace as during recording.
30248:                 LIns* typemap_ins;
37694:                 if (depth == 0) {
30248:                     // In this case, we are in the same frame where the arguments object was created.
30248:                     // The entry type map is not necessarily up-to-date, so we capture a new type map
30248:                     // for this point in the code.
30860:                     unsigned stackSlots = NativeStackSlots(cx, 0 /* callDepth */);
37741:                     TraceType* typemap = new (traceAlloc()) TraceType[stackSlots];
30248:                     DetermineTypesVisitor detVisitor(*this, typemap);
30248:                     VisitStackSlots(detVisitor, cx, 0);
30248:                     typemap_ins = INS_CONSTPTR(typemap + 2 /* callee, this */);
30248:                 } else {
30248:                     // In this case, we are in a deeper frame from where the arguments object was
30248:                     // created. The type map at the point of the call out from the creation frame
30248:                     // is accurate.
30248:                     // Note: this relies on the assumption that we abort on setting an element of
30248:                     // an arguments object in any deeper frame.
40353:                     LIns* fip_ins = lir->insLoad(LIR_ldp, lirbuf->rp,
40353:                                                  (callDepth-depth)*sizeof(FrameInfo*),
40353:                                                  ACC_RSTACK);
37741:                     typemap_ins = lir->ins2(LIR_piadd, fip_ins, INS_CONSTWORD(sizeof(FrameInfo) + 2/*callee,this*/ * sizeof(TraceType)));
30248:                 }
30248: 
32746:                 LIns* typep_ins = lir->ins2(LIR_piadd, typemap_ins,
32746:                                             lir->ins_u2p(lir->ins2(LIR_mul,
32746:                                                                    idx_ins,
37741:                                                                    INS_CONST(sizeof(TraceType)))));
39910:                 LIns* type_ins = lir->insLoad(LIR_ldzb, typep_ins, 0, ACC_READONLY);
30248:                 guard(true,
30248:                       addName(lir->ins2(LIR_eq, type_ins, lir->insImm(type)),
30248:                               "guard(type-stable upvar)"),
30248:                       BRANCH_EXIT);
30248: 
30248:                 // Read the value out of the native stack area.
30248:                 guard(true, lir->ins2(LIR_ult, idx_ins, INS_CONST(afp->argc)),
30248:                       snapshot(BRANCH_EXIT));
35083:                 size_t stackOffset = nativespOffset(&afp->argv[0]);
32746:                 LIns* args_addr_ins = lir->ins2(LIR_piadd, lirbuf->sp, INS_CONSTWORD(stackOffset));
32746:                 LIns* argi_addr_ins = lir->ins2(LIR_piadd,
32746:                                                 args_addr_ins,
32746:                                                 lir->ins_u2p(lir->ins2(LIR_mul,
32746:                                                                        idx_ins,
32746:                                                                        INS_CONST(sizeof(double)))));
40353:                 // The AccSet could be more precise, but ValidateWriter
40353:                 // doesn't recognise the complex expression involving 'sp' as
40353:                 // a STACK access, and it's not worth the effort to be more
40353:                 // precise because this case is rare.
40353:                 v_ins = stackLoad(argi_addr_ins, ACC_LOAD_ANY, type);
30248:             }
30248:             JS_ASSERT(v_ins);
30248:             set(&lval, v_ins);
36559:             if (call)
36559:                 set(&idx, obj_ins);
33542:             return ARECORD_CONTINUE;
33542:         }
33542:         RETURN_STOP_A("can't reach arguments object's frame");
38497:     }
38497: 
38497:     if (obj->isDenseArray()) {
28411:         // Fast path for dense arrays accessed with a integer index.
18300:         jsval* vp;
18300:         LIns* addr_ins;
31444: 
31444:         guardDenseArray(obj, obj_ins, BRANCH_EXIT);
33542:         CHECK_STATUS_A(denseArrayElement(lval, idx, vp, v_ins, addr_ins));
19983:         set(&lval, v_ins);
26551:         if (call)
26551:             set(&idx, obj_ins);
33542:         return ARECORD_CONTINUE;
38497:     }
38497: 
38497:     if (OkToTraceTypedArrays && js_IsTypedArray(obj)) {
37754:         // Fast path for typed arrays accessed with a integer index.
37754:         jsval* vp;
37754:         LIns* addr_ins;
37754: 
40353:         guardClass(obj, obj_ins, obj->getClass(), snapshot(BRANCH_EXIT), ACC_READONLY);
37754:         CHECK_STATUS_A(typedArrayElement(lval, idx, vp, v_ins, addr_ins));
37754:         set(&lval, v_ins);
37754:         if (call)
37754:             set(&idx, obj_ins);
37754:         return ARECORD_CONTINUE;
33542:     }
33542: 
33542:     return InjectStatus(getPropertyByIndex(obj_ins, idx_ins, &lval));
31444: }
31444: 
24489: /* Functions used by JSOP_SETELEM */
24489: 
31829: static JSBool FASTCALL
31829: SetPropertyByName(JSContext* cx, JSObject* obj, JSString** namep, jsval* vp)
31829: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
31829: 
31524:     jsid id;
31829:     if (!RootedStringToId(cx, namep, &id) || !obj->setProperty(cx, id, vp)) {
37741:         SetBuiltinError(cx);
31524:         return JS_FALSE;
31829:     }
31829:     return cx->interpState->builtinStatus == 0;
31829: }
31829: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, SetPropertyByName, CONTEXT, OBJECT, STRINGPTR, JSVALPTR,
39910:                      0, ACC_STORE_ANY)
31829: 
31829: static JSBool FASTCALL
31829: InitPropertyByName(JSContext* cx, JSObject* obj, JSString** namep, jsval val)
31829: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
31829: 
31829:     jsid id;
31829:     if (!RootedStringToId(cx, namep, &id) ||
32573:         !obj->defineProperty(cx, id, val, NULL, NULL, JSPROP_ENUMERATE)) {
37741:         SetBuiltinError(cx);
31524:         return JS_FALSE;
31829:     }
31829:     return cx->interpState->builtinStatus == 0;
31829: }
31829: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, InitPropertyByName, CONTEXT, OBJECT, STRINGPTR, JSVAL,
39910:                      0, ACC_STORE_ANY)
31829: 
33542: JS_REQUIRES_STACK RecordingStatus
31829: TraceRecorder::initOrSetPropertyByName(LIns* obj_ins, jsval* idvalp, jsval* rvalp, bool init)
31829: {
31829:     CHECK_STATUS(primitiveToStringInPlace(idvalp));
31829: 
31902:     LIns* rval_ins = box_jsval(*rvalp, get(rvalp));
31829: 
31829:     enterDeepBailCall();
31829: 
31829:     LIns* ok_ins;
31829:     LIns* idvalp_ins = addName(addr(idvalp), "idvalp");
31829:     if (init) {
31829:         LIns* args[] = {rval_ins, idvalp_ins, obj_ins, cx_ins};
31829:         ok_ins = lir->insCall(&InitPropertyByName_ci, args);
31829:     } else {
31829:         // See note in getPropertyByName about vp.
31829:         LIns* vp_ins = addName(lir->insAlloc(sizeof(jsval)), "vp");
40353:         lir->insStorei(rval_ins, vp_ins, 0, ACC_OTHER);
31829:         LIns* args[] = {vp_ins, idvalp_ins, obj_ins, cx_ins};
31829:         ok_ins = lir->insCall(&SetPropertyByName_ci, args);
31829:     }
33189:     pendingGuardCondition = ok_ins;
31829: 
31829:     leaveDeepBailCall();
33542:     return RECORD_CONTINUE;
31524: }
31524: 
31517: static JSBool FASTCALL
31829: SetPropertyByIndex(JSContext* cx, JSObject* obj, int32 index, jsval* vp)
31829: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
31829: 
40403:     AutoIdRooter idr(cx);
31829:     if (!js_Int32ToId(cx, index, idr.addr()) || !obj->setProperty(cx, idr.id(), vp)) {
37741:         SetBuiltinError(cx);
31524:         return JS_FALSE;
31829:     }
31829:     return cx->interpState->builtinStatus == 0;
31829: }
39910: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, SetPropertyByIndex, CONTEXT, OBJECT, INT32, JSVALPTR, 0,
39910:                      ACC_STORE_ANY)
31829: 
31829: static JSBool FASTCALL
31829: InitPropertyByIndex(JSContext* cx, JSObject* obj, int32 index, jsval val)
31829: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
31829: 
40403:     AutoIdRooter idr(cx);
31829:     if (!js_Int32ToId(cx, index, idr.addr()) ||
32573:         !obj->defineProperty(cx, idr.id(), val, NULL, NULL, JSPROP_ENUMERATE)) {
37741:         SetBuiltinError(cx);
31524:         return JS_FALSE;
31829:     }
31829:     return cx->interpState->builtinStatus == 0;
31829: }
39910: JS_DEFINE_CALLINFO_4(static, BOOL_FAIL, InitPropertyByIndex, CONTEXT, OBJECT, INT32, JSVAL, 0,
39910:                      ACC_STORE_ANY)
31829: 
33542: JS_REQUIRES_STACK RecordingStatus
31829: TraceRecorder::initOrSetPropertyByIndex(LIns* obj_ins, LIns* index_ins, jsval* rvalp, bool init)
31829: {
31829:     index_ins = makeNumberInt32(index_ins);
31829: 
31902:     LIns* rval_ins = box_jsval(*rvalp, get(rvalp));
31829: 
31829:     enterDeepBailCall();
31829: 
31829:     LIns* ok_ins;
31829:     if (init) {
31829:         LIns* args[] = {rval_ins, index_ins, obj_ins, cx_ins};
31829:         ok_ins = lir->insCall(&InitPropertyByIndex_ci, args);
31829:     } else {
31829:         // See note in getPropertyByName about vp.
31829:         LIns* vp_ins = addName(lir->insAlloc(sizeof(jsval)), "vp");
40353:         lir->insStorei(rval_ins, vp_ins, 0, ACC_OTHER);
31829:         LIns* args[] = {vp_ins, index_ins, obj_ins, cx_ins};
31829:         ok_ins = lir->insCall(&SetPropertyByIndex_ci, args);
31829:     }
33189:     pendingGuardCondition = ok_ins;
31829: 
31829:     leaveDeepBailCall();
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
35466: TraceRecorder::setElem(int lval_spindex, int idx_spindex, int v_spindex)
35466: {
35466:     jsval& v = stackval(v_spindex);
35466:     jsval& idx = stackval(idx_spindex);
35466:     jsval& lval = stackval(lval_spindex);
18300: 
19983:     if (JSVAL_IS_PRIMITIVE(lval))
33542:         RETURN_STOP_A("left JSOP_SETELEM operand is not an object");
33542:     RETURN_IF_XML_A(lval);
19979: 
19983:     JSObject* obj = JSVAL_TO_OBJECT(lval);
19983:     LIns* obj_ins = get(&lval);
19979:     LIns* idx_ins = get(&idx);
18300:     LIns* v_ins = get(&v);
19979: 
35054:     if (JS_InstanceOf(cx, obj, &js_ArgumentsClass, NULL))
35054:         RETURN_STOP_A("can't trace setting elements of the |arguments| object");
35054: 
26274:     if (!JSVAL_IS_INT(idx)) {
27110:         if (!JSVAL_IS_PRIMITIVE(idx))
33542:             RETURN_STOP_A("non-primitive index");
33542:         CHECK_STATUS_A(initOrSetPropertyByName(obj_ins, &idx, &v,
31829:                                              *cx->fp->regs->pc == JSOP_INITELEM));
37754:     } else if (OkToTraceTypedArrays && js_IsTypedArray(obj)) {
37754:         // Fast path: assigning to element of typed array.
37754: 
37754:         // Ensure array is a typed array and is the same type as what was written
40353:         guardClass(obj, obj_ins, obj->getClass(), snapshot(BRANCH_EXIT), ACC_READONLY);
37754: 
37754:         js::TypedArray* tarray = js::TypedArray::fromJSObject(obj);
37754: 
37776:         LIns* priv_ins = stobj_get_const_fslot(obj_ins, JSSLOT_PRIVATE);
37754: 
40294:         // The index was on the stack and is therefore a LIR float; force it to
37754:         // be an integer.                              
37754:         idx_ins = makeNumberInt32(idx_ins);            
37754:                                                        
37754:         // Ensure idx >= 0 && idx < length (by using uint32)
37776:         lir->insGuard(LIR_xf,
37754:                       lir->ins2(LIR_ult,
37754:                                 idx_ins,
39910:                                 lir->insLoad(LIR_ld, priv_ins, js::TypedArray::lengthOffset(),
39910:                                              ACC_READONLY)),
37776:                       createGuardRecord(snapshot(OVERFLOW_EXIT)));
37754: 
37754:         // We're now ready to store
39910:         LIns* data_ins = lir->insLoad(LIR_ldp, priv_ins, js::TypedArray::dataOffset(),
39910:                                       ACC_READONLY);
37754:         LIns* pidx_ins = lir->ins_u2p(idx_ins);
37754:         LIns* addr_ins = 0;
37754: 
40294:         // If it's not a number, convert objects to NaN,
40294:         // null to 0, and call StringToNumber or BooleanOrUndefinedToNumber
40294:         // for those.
40294:         if (!isNumber(v)) {
40294:             if (JSVAL_IS_NULL(v)) {
40294:                 v_ins = INS_CONST(0);
40307:             } else if (JSVAL_IS_VOID(v)) {
40307:                 v_ins = lir->insImmf(js_NaN);
40307:             } else if (JSVAL_IS_STRING(v)) {
40294:                 LIns* args[] = { v_ins, cx_ins };
40307:                 v_ins = lir->insCall(&js_StringToNumber_ci, args);
40307:             } else if (JSVAL_IS_SPECIAL(v)) {
40307:                 JS_ASSERT(JSVAL_IS_BOOLEAN(v));
40307:                 v_ins = i2f(v_ins);
40294:             } else {
40294:                 v_ins = lir->insImmf(js_NaN);
40294:             }
40294:         }
40294: 
40294:         switch (tarray->type) {
40294:           case js::TypedArray::TYPE_INT8:
40294:           case js::TypedArray::TYPE_INT16:
40294:           case js::TypedArray::TYPE_INT32:
40294:             v_ins = f2i(v_ins);
40294:             break;
40294:           case js::TypedArray::TYPE_UINT8:
40294:           case js::TypedArray::TYPE_UINT16:
40294:           case js::TypedArray::TYPE_UINT32:
40294:             v_ins = f2u(v_ins);
40294:             break;
40294:           case js::TypedArray::TYPE_UINT8_CLAMPED:
40294:             if (isPromoteInt(v_ins)) {
40294:                 v_ins = demote(lir, v_ins);
40294:                 v_ins = lir->ins_choose(lir->ins2i(LIR_lt, v_ins, 0),
38515:                                         lir->insImm(0),
40294:                                         lir->ins_choose(lir->ins2i(LIR_gt, v_ins, 0xff),
38515:                                                         lir->insImm(0xff),
40294:                                                         v_ins,
38515:                                                         avmplus::AvmCore::use_cmov()),
38515:                                         avmplus::AvmCore::use_cmov());
39943:             } else {
40415:                 v_ins = lir->insCall(&js_TypedArray_uint8_clamp_double_ci, &v_ins);
39943:             }
40294:             break;
40294:           case js::TypedArray::TYPE_FLOAT32:
40294:           case js::TypedArray::TYPE_FLOAT64:
40294:             // Do nothing, this is already a float
40294:             break;
40294:           default:
40294:             JS_NOT_REACHED("Unknown typed array type in tracer");       
38515:         }
38515: 
37754:         switch (tarray->type) {
37754:           case js::TypedArray::TYPE_INT8:
40294:           case js::TypedArray::TYPE_UINT8_CLAMPED:
37754:           case js::TypedArray::TYPE_UINT8:
37754:             addr_ins = lir->ins2(LIR_piadd, data_ins, pidx_ins);
40353:             lir->insStore(LIR_stb, v_ins, addr_ins, 0, ACC_OTHER);
37754:             break;
37754:           case js::TypedArray::TYPE_INT16:
37754:           case js::TypedArray::TYPE_UINT16:
37754:             addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 1));
40353:             lir->insStore(LIR_sts, v_ins, addr_ins, 0, ACC_OTHER);
37754:             break;
37754:           case js::TypedArray::TYPE_INT32:
37754:           case js::TypedArray::TYPE_UINT32:
37754:             addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 2));
40353:             lir->insStore(LIR_sti, v_ins, addr_ins, 0, ACC_OTHER);
37754:             break;
37754:           case js::TypedArray::TYPE_FLOAT32:
37754:             addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 2));
40353:             lir->insStore(LIR_st32f, v_ins, addr_ins, 0, ACC_OTHER);
37754:             break;
38512:           case js::TypedArray::TYPE_FLOAT64:
38512:             addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 3));
40353:             lir->insStore(LIR_stfi, v_ins, addr_ins, 0, ACC_OTHER);
38927:             break;
37754:           default:
37754:             JS_NOT_REACHED("Unknown typed array type in tracer");       
37754:         }
39928:     } else if (JSVAL_TO_INT(idx) < 0 || !obj->isDenseArray()) {
33542:         CHECK_STATUS_A(initOrSetPropertyByIndex(obj_ins, idx_ins, &v,
31829:                                                 *cx->fp->regs->pc == JSOP_INITELEM));
31829:     } else {
31829:         // Fast path: assigning to element of dense array.
26274: 
26274:         // Make sure the array is actually dense.
26274:         if (!guardDenseArray(obj, obj_ins, BRANCH_EXIT))
33542:             return ARECORD_STOP;
26274: 
31829:         // The index was on the stack and is therefore a LIR float. Force it to
31829:         // be an integer.
26274:         idx_ins = makeNumberInt32(idx_ins);
26274: 
31829:         // Box the value so we can use one builtin instead of having to add one
31829:         // builtin for every storage type. Special case for integers though,
31829:         // since they are so common.
30655:         LIns* res_ins;
31919:         LIns* args[] = { NULL, idx_ins, obj_ins, cx_ins };
31919:         if (isNumber(v)) {
31919:             if (isPromoteInt(v_ins)) {
37741:                 args[0] = demote(lir, v_ins);
30655:                 res_ins = lir->insCall(&js_Array_dense_setelem_int_ci, args);
30655:             } else {
31919:                 args[0] = v_ins;
31919:                 res_ins = lir->insCall(&js_Array_dense_setelem_double_ci, args);
31919:             }
31919:         } else {
31902:             LIns* args[] = { box_jsval(v, v_ins), idx_ins, obj_ins, cx_ins };
30655:             res_ins = lir->insCall(&js_Array_dense_setelem_ci, args);
30655:         }
19993:         guard(false, lir->ins_eq0(res_ins), MISMATCH_EXIT);
31829:     }
18300: 
18300:     jsbytecode* pc = cx->fp->regs->pc;
18300:     if (*pc == JSOP_SETELEM && pc[JSOP_SETELEM_LENGTH] != JSOP_POP)
19983:         set(&lval, v_ins);
19993: 
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
35466: TraceRecorder::record_JSOP_SETELEM()
35466: {
35466:     return setElem(-3, -2, -1);
35466: }
35466: 
35466: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_CALLNAME()
18300: {
18300:     JSObject* obj = cx->fp->scopeChain;
18300:     if (obj != globalObj) {
18300:         jsval* vp;
30647:         LIns* ins;
31075:         NameResult nr;
33542:         CHECK_STATUS_A(scopeChainProp(obj, vp, ins, nr));
30647:         stack(0, ins);
31843:         stack(1, INS_CONSTOBJ(globalObj));
33542:         return ARECORD_CONTINUE;
18300:     }
18300: 
37694:     LIns* obj_ins = INS_CONSTOBJ(globalObj);
18300:     JSObject* obj2;
40374:     PCVal pcval;
25633: 
33542:     CHECK_STATUS_A(test_property_cache(obj, obj_ins, obj2, pcval));
18300: 
40374:     if (pcval.isNull() || !pcval.isObject())
33542:         RETURN_STOP_A("callee is not an object");
25633: 
40430:     JS_ASSERT(pcval.toObject()->isFunction());
40374: 
40374:     stack(0, INS_CONSTOBJ(pcval.toObject()));
18300:     stack(1, obj_ins);
33542:     return ARECORD_CONTINUE;
27933: }
27933: 
30860: JS_DEFINE_CALLINFO_5(extern, UINT32, GetUpvarArgOnTrace, CONTEXT, UINT32, INT32, UINT32,
39910:                      DOUBLEPTR, 0, ACC_STORE_ANY)
30860: JS_DEFINE_CALLINFO_5(extern, UINT32, GetUpvarVarOnTrace, CONTEXT, UINT32, INT32, UINT32,
39910:                      DOUBLEPTR, 0, ACC_STORE_ANY)
30860: JS_DEFINE_CALLINFO_5(extern, UINT32, GetUpvarStackOnTrace, CONTEXT, UINT32, INT32, UINT32,
39910:                      DOUBLEPTR, 0, ACC_STORE_ANY)
28268: 
28923: /*
30860:  * Record LIR to get the given upvar. Return the LIR instruction for the upvar
30860:  * value. NULL is returned only on a can't-happen condition with an invalid
30860:  * typemap. The value of the upvar is returned as v.
28923:  */
28923: JS_REQUIRES_STACK LIns*
28923: TraceRecorder::upvar(JSScript* script, JSUpvarArray* uva, uintN index, jsval& v)
28923: {
28275:     /*
28969:      * Try to find the upvar in the current trace's tracker. For &vr to be
28969:      * the address of the jsval found in js_GetUpvar, we must initialize
28969:      * vr directly with the result, so it is a reference to the same location.
28969:      * It does not work to assign the result to v, because v is an already
28969:      * existing reference that points to something else.
28969:      */
29021:     uint32 cookie = uva->vector[index];
29021:     jsval& vr = js_GetUpvar(cx, script->staticLevel, cookie);
28969:     v = vr;
32742: 
36662:     if (LIns* ins = attemptImport(&vr))
36662:         return ins;
28275: 
28275:     /*
30860:      * The upvar is not in the current trace, so get the upvar value exactly as
30860:      * the interpreter does and unbox.
28275:      */
29021:     uint32 level = script->staticLevel - UPVAR_FRAME_SKIP(cookie);
29021:     uint32 cookieSlot = UPVAR_FRAME_SLOT(cookie);
29021:     JSStackFrame* fp = cx->display[level];
29021:     const CallInfo* ci;
29021:     int32 slot;
40394:     if (!fp->fun || (fp->flags & JSFRAME_EVAL)) {
30860:         ci = &GetUpvarStackOnTrace_ci;
29022:         slot = cookieSlot;
29021:     } else if (cookieSlot < fp->fun->nargs) {
30860:         ci = &GetUpvarArgOnTrace_ci;
29021:         slot = cookieSlot;
29021:     } else if (cookieSlot == CALLEE_UPVAR_SLOT) {
30860:         ci = &GetUpvarArgOnTrace_ci;
29021:         slot = -2;
29021:     } else {
30860:         ci = &GetUpvarVarOnTrace_ci;
29021:         slot = cookieSlot - fp->fun->nargs;
29021:     }
29021: 
28268:     LIns* outp = lir->insAlloc(sizeof(double));
28268:     LIns* args[] = {
28268:         outp,
28738:         INS_CONST(callDepth),
29021:         INS_CONST(slot),
29021:         INS_CONST(level),
28268:         cx_ins
28268:     };
28268:     LIns* call_ins = lir->insCall(ci, args);
37741:     TraceType type = getCoercedType(v);
28268:     guard(true,
28268:           addName(lir->ins2(LIR_eq, call_ins, lir->insImm(type)),
28268:                   "guard(type-stable upvar)"),
28268:           BRANCH_EXIT);
40353:     return stackLoad(outp, ACC_OTHER, type);
30248: }
30248: 
30248: /*
30860:  * Generate LIR to load a value from the native stack. This method ensures that
30860:  * the correct LIR load operator is used.
30248:  */
40353: LIns* TraceRecorder::stackLoad(LIns* base, AccSet accSet, uint8 type)
30248: {
28268:     LOpcode loadOp;
28268:     switch (type) {
29896:       case TT_DOUBLE:
37022:         loadOp = LIR_ldf;
28268:         break;
29896:       case TT_OBJECT:
29896:       case TT_STRING:
29896:       case TT_FUNCTION:
29896:       case TT_NULL:
28268:         loadOp = LIR_ldp;
28268:         break;
29896:       case TT_INT32:
40307:       case TT_SPECIAL:
40307:       case TT_VOID:
28268:         loadOp = LIR_ld;
28268:         break;
29896:       case TT_JSVAL:
28268:       default:
29896:         JS_NOT_REACHED("found jsval type in an upvar type map entry");
28923:         return NULL;
28268:     }
28268: 
40353:     LIns* result = lir->insLoad(loadOp, base, 0, accSet);
29896:     if (type == TT_INT32)
28268:         result = lir->ins1(LIR_i2f, result);
28923:     return result;
28923: }
28923: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
28923: TraceRecorder::record_JSOP_GETUPVAR()
28923: {
28923:     uintN index = GET_UINT16(cx->fp->regs->pc);
28923:     JSScript *script = cx->fp->script;
32723:     JSUpvarArray* uva = script->upvars();
28923:     JS_ASSERT(index < uva->length);
28923: 
28923:     jsval v;
28923:     LIns* upvar_ins = upvar(script, uva, index, v);
28923:     if (!upvar_ins)
33542:         return ARECORD_STOP;
28923:     stack(0, upvar_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18308: TraceRecorder::record_JSOP_CALLUPVAR()
18308: {
33542:     CHECK_STATUS_A(record_JSOP_GETUPVAR());
31843:     stack(1, INS_NULL());
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
27012: TraceRecorder::record_JSOP_GETDSLOT()
27012: {
34352:     JSObject* callee = cx->fp->calleeObject();
28557:     LIns* callee_ins = get(&cx->fp->argv[-2]);
27012: 
27012:     unsigned index = GET_UINT16(cx->fp->regs->pc);
40353:     LIns* dslots_ins = lir->insLoad(LIR_ldp, callee_ins, offsetof(JSObject, dslots), ACC_OTHER);
40363:     LIns* v_ins = lir->insLoad(LIR_ldp, dslots_ins, index * sizeof(jsval), ACC_OTHER);
27012: 
31902:     stack(0, unbox_jsval(callee->dslots[index], v_ins, snapshot(BRANCH_EXIT)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
27012: TraceRecorder::record_JSOP_CALLDSLOT()
27012: {
33542:     CHECK_STATUS_A(record_JSOP_GETDSLOT());
31843:     stack(1, INS_NULL());
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
22634: TraceRecorder::guardCallee(jsval& callee)
21526: {
38549:     JSObject* callee_obj = JSVAL_TO_OBJECT(callee);
38549:     JS_ASSERT(callee_obj->isFunction());
38549:     JSFunction* callee_fun = (JSFunction*) callee_obj->getPrivate();
38549: 
38549:     /*
38549:      * First, guard on the callee's function (JSFunction*) identity. This is
38549:      * necessary since tracing always inlines function calls. But note that
38549:      * TR::functionCall avoids calling TR::guardCallee for constant methods
38549:      * (those hit in the property cache from JSOP_CALLPROP).
38549:      */
27540:     VMSideExit* branchExit = snapshot(BRANCH_EXIT);
22623:     LIns* callee_ins = get(&callee);
36361:     tree->gcthings.addUnique(callee);
38549: 
27540:     guard(true,
32746:           lir->ins2(LIR_peq,
30248:                     stobj_get_private(callee_ins),
38549:                     INS_CONSTPTR(callee_fun)),
27540:           branchExit);
35479: 
35479:     /*
38549:      * Second, consider guarding on the parent scope of the callee.
38549:      *
38549:      * As long as we guard on parent scope, we are guaranteed when recording
38549:      * variable accesses for a Call object having no private data that we can
38549:      * emit code that avoids checking for an active JSStackFrame for the Call
38549:      * object (which would hold fresh variable values -- the Call object's
38549:      * dslots would be stale until the stack frame is popped). This is because
38549:      * Call objects can't pick up a new stack frame in their private slot once
38549:      * they have none. TR::callProp and TR::setCallProp depend on this fact and
38549:      * document where; if this guard is removed make sure to fix those methods.
38549:      * Search for the "parent guard" comments in them.
38549:      *
38549:      * In general, a loop in an escaping function scoped by Call objects could
38549:      * be traced before the function has returned, and the trace then triggered
38549:      * after, or vice versa. The function must escape, i.e., be a "funarg", or
38549:      * else there's no need to guard callee parent at all. So once we know (by
38549:      * static analysis) that a function may escape, we cannot avoid guarding on
38549:      * either the private data of the Call object or the Call object itself, if
38549:      * we wish to optimize for the particular deactivated stack frame (null
38549:      * private data) case as noted above.
38549:      */
38549:     if (FUN_INTERPRETED(callee_fun) &&
38549:         (!FUN_NULL_CLOSURE(callee_fun) || callee_fun->u.i.nupvars != 0)) {
38549:         JSObject* parent = callee_obj->getParent();
38549: 
38549:         if (parent != globalObj) {
38549:             if (parent->getClass() != &js_CallClass)
38549:                 RETURN_STOP("closure scoped by neither the global object nor a Call object");
38549: 
22623:             guard(true,
32746:                   lir->ins2(LIR_peq,
32603:                             stobj_get_parent(callee_ins),
38549:                             INS_CONSTOBJ(parent)),
27540:                   branchExit);
38549:         }
38549:     }
33542:     return RECORD_CONTINUE;
27933: }
27933: 
31460: /*
31460:  * Prepare the given |arguments| object to be accessed on trace. If the return
31460:  * value is non-NULL, then the given |arguments| object refers to a frame on
31460:  * the current trace and is guaranteed to refer to the same frame on trace for
31460:  * all later executions.
31460:  */
31460: JS_REQUIRES_STACK JSStackFrame *
31460: TraceRecorder::guardArguments(JSObject *obj, LIns* obj_ins, unsigned *depthp)
31460: {
40405:     JS_ASSERT(obj->isArguments());
31460: 
31460:     JSStackFrame *afp = frameIfInRange(obj, depthp);
31460:     if (!afp)
31460:         return NULL;
31460: 
31460:     VMSideExit *exit = snapshot(MISMATCH_EXIT);
40353:     guardClass(obj, obj_ins, &js_ArgumentsClass, exit, ACC_READONLY);
31460: 
31460:     LIns* args_ins = get(&afp->argsobj);
32746:     LIns* cmp = lir->ins2(LIR_peq, args_ins, obj_ins);
31460:     lir->insGuard(LIR_xf, cmp, createGuardRecord(exit));
31460:     return afp;
31460: }
31460: 
33542: JS_REQUIRES_STACK RecordingStatus
19577: TraceRecorder::interpretedFunctionCall(jsval& fval, JSFunction* fun, uintN argc, bool constructing)
18300: {
34290:     /*
34290:      * The function's identity (JSFunction and therefore JSScript) is guarded,
34290:      * so we can optimize for the empty script singleton right away. No need to
34290:      * worry about crossing globals or relocating argv, even, in this case!
34290:      *
34290:      * Note that the interpreter shortcuts empty-script call and construct too,
34290:      * and does not call any TR::record_*CallComplete hook.
34290:      */
34290:     if (fun->u.i.script->isEmpty()) {
40307:         LIns* rval_ins = constructing ? stack(-1 - argc) : INS_VOID();
34290:         stack(-2 - argc, rval_ins);
34290:         return RECORD_CONTINUE;
34290:     }
34290: 
40424:     if (JSVAL_TO_OBJECT(fval)->getGlobal() != globalObj)
33542:         RETURN_STOP("JSOP_CALL or JSOP_NEW crosses global scopes");
19149: 
18300:     JSStackFrame* fp = cx->fp;
18300: 
18300:     // TODO: track the copying via the tracker...
18300:     if (argc < fun->nargs &&
18300:         jsuword(fp->regs->sp + (fun->nargs - argc)) > cx->stackPool.current->limit) {
33542:         RETURN_STOP("can't trace calls with too few args requiring argv move");
18300:     }
18300: 
19085:     // Generate a type map for the outgoing frame and stash it in the LIR
30860:     unsigned stackSlots = NativeStackSlots(cx, 0 /* callDepth */);
33161:     FrameInfo* fi = (FrameInfo*)
37741:         tempAlloc().alloc(sizeof(FrameInfo) + stackSlots * sizeof(TraceType));
37741:     TraceType* typemap = (TraceType*)(fi + 1);
29880: 
29880:     DetermineTypesVisitor detVisitor(*this, typemap);
29882:     VisitStackSlots(detVisitor, cx, 0);
19085: 
31924:     JS_ASSERT(argc < FrameInfo::CONSTRUCTING_FLAG);
31924: 
36361:     tree->gcthings.addUnique(fval);
23262:     fi->block = fp->blockChain;
31843:     if (fp->blockChain)
36361:         tree->gcthings.addUnique(OBJECT_TO_JSVAL(fp->blockChain));
25111:     fi->pc = fp->regs->pc;
25111:     fi->imacpc = fp->imacpc;
28887:     fi->spdist = fp->regs->sp - fp->slots;
39928:     fi->set_argc(uint16(argc), constructing);
35083:     fi->callerHeight = stackSlots - (2 + argc);
31924:     fi->callerArgc = fp->argc;
18300: 
36361:     if (callDepth >= tree->maxCallDepth)
36361:         tree->maxCallDepth = callDepth + 1;
18300: 
33563:     fi = traceMonitor->frameCache->memoize(fi);
33563:     if (!fi)
33563:         RETURN_STOP("out of memory");
40353:     lir->insStorei(INS_CONSTPTR(fi), lirbuf->rp, callDepth * sizeof(FrameInfo*), ACC_RSTACK);
18300: 
33564: #if defined JS_JIT_SPEW
33567:     debug_only_printf(LC_TMTracer, "iFC frameinfo=%p, stack=%d, map=", (void*)fi,
33564:                       fi->callerHeight);
33564:     for (unsigned i = 0; i < fi->callerHeight; i++)
33564:         debug_only_printf(LC_TMTracer, "%c", typeChar[fi->get_typemap()[i]]);
33564:     debug_only_print0(LC_TMTracer, "\n");
33564: #endif
33564: 
18300:     atoms = fun->u.i.script->atomMap.vector;
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18300: TraceRecorder::record_JSOP_CALL()
18300: {
27234:     uintN argc = GET_ARGC(cx->fp->regs->pc);
27234:     cx->fp->assertValidStackDepth(argc + 2);
33542:     return InjectStatus(functionCall(argc,
28086:                                      (cx->fp->imacpc && *cx->fp->imacpc == JSOP_APPLY)
28086:                                         ? JSOP_APPLY
33542:                                         : JSOP_CALL));
19582: }
19582: 
23097: static jsbytecode* apply_imacro_table[] = {
23097:     apply_imacros.apply0,
23097:     apply_imacros.apply1,
23097:     apply_imacros.apply2,
23097:     apply_imacros.apply3,
23097:     apply_imacros.apply4,
23097:     apply_imacros.apply5,
23097:     apply_imacros.apply6,
23097:     apply_imacros.apply7,
23097:     apply_imacros.apply8
23097: };
23097: 
23097: static jsbytecode* call_imacro_table[] = {
23097:     apply_imacros.call0,
23097:     apply_imacros.call1,
23097:     apply_imacros.call2,
23097:     apply_imacros.call3,
23097:     apply_imacros.call4,
23097:     apply_imacros.call5,
23097:     apply_imacros.call6,
23097:     apply_imacros.call7,
23097:     apply_imacros.call8
23097: };
23097: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
21452: TraceRecorder::record_JSOP_APPLY()
21452: {
22634:     JSStackFrame* fp = cx->fp;
22634:     jsbytecode *pc = fp->regs->pc;
22634:     uintN argc = GET_ARGC(pc);
27234:     cx->fp->assertValidStackDepth(argc + 2);
27234: 
22634:     jsval* vp = fp->regs->sp - (argc + 2);
22634:     jsuint length = 0;
22634:     JSObject* aobj = NULL;
22634:     LIns* aobj_ins = NULL;
23097: 
23097:     JS_ASSERT(!fp->imacpc);
22634: 
22634:     if (!VALUE_IS_FUNCTION(cx, vp[0]))
22634:         return record_JSOP_CALL();
33542:     RETURN_IF_XML_A(vp[0]);
22634: 
22634:     JSObject* obj = JSVAL_TO_OBJECT(vp[0]);
22634:     JSFunction* fun = GET_FUNCTION_PRIVATE(cx, obj);
22634:     if (FUN_INTERPRETED(fun))
22634:         return record_JSOP_CALL();
22634: 
22634:     bool apply = (JSFastNative)fun->u.n.native == js_fun_apply;
22634:     if (!apply && (JSFastNative)fun->u.n.native != js_fun_call)
22634:         return record_JSOP_CALL();
22634: 
22634:     /*
23097:      * We don't trace apply and call with a primitive 'this', which is the
23097:      * first positional parameter.
22634:      */
33179:     if (argc > 0 && !JSVAL_IS_OBJECT(vp[2]))
23097:         return record_JSOP_CALL();
23097: 
23097:     /*
23097:      * Guard on the identity of this, which is the function we are applying.
23097:      */
23712:     if (!VALUE_IS_FUNCTION(cx, vp[1]))
33542:         RETURN_STOP_A("callee is not a function");
33542:     CHECK_STATUS_A(guardCallee(vp[1]));
23097: 
22634:     if (apply && argc >= 2) {
23097:         if (argc != 2)
33542:             RETURN_STOP_A("apply with excess arguments");
22634:         if (JSVAL_IS_PRIMITIVE(vp[3]))
33542:             RETURN_STOP_A("arguments parameter of apply is primitive");
22634:         aobj = JSVAL_TO_OBJECT(vp[3]);
22634:         aobj_ins = get(&vp[3]);
22634: 
22634:         /*
30860:          * We trace dense arrays and arguments objects. The code we generate
30860:          * for apply uses imacros to handle a specific number of arguments.
30248:          */
39928:         if (aobj->isDenseArray()) {
40353:             guardDenseArray(aobj, aobj_ins, MISMATCH_EXIT);
40796:             length = aobj->getArrayLength();
23097:             guard(true,
23097:                   lir->ins2i(LIR_eq,
40796:                              p2i(stobj_get_fslot(aobj_ins, JSObject::JSSLOT_ARRAY_LENGTH)),
22634:                              length),
22634:                   BRANCH_EXIT);
40405:         } else if (aobj->isArguments()) {
31460:             unsigned depth;
31460:             JSStackFrame *afp = guardArguments(aobj, aobj_ins, &depth);
30248:             if (!afp)
33542:                 RETURN_STOP_A("can't reach arguments object's frame");
30248:             length = afp->argc;
30248:         } else {
33542:             RETURN_STOP_A("arguments parameter of apply is not a dense array or argments object");
30248:         }
30248: 
30248:         if (length >= JS_ARRAY_LENGTH(apply_imacro_table))
33542:             RETURN_STOP_A("too many arguments to apply");
33542: 
33542:         return InjectStatus(call_imacro(apply_imacro_table[length]));
23097:     }
23097: 
23097:     if (argc >= JS_ARRAY_LENGTH(call_imacro_table))
33542:         RETURN_STOP_A("too many arguments to call");
33542: 
33542:     return InjectStatus(call_imacro(call_imacro_table[argc]));
21452: }
21452: 
26752: static JSBool FASTCALL
32615: CatchStopIteration_tn(JSContext* cx, JSBool ok, jsval* vp)
26752: {
26752:     if (!ok && cx->throwing && js_ValueIsStopIteration(cx->exception)) {
26752:         cx->throwing = JS_FALSE;
26752:         cx->exception = JSVAL_VOID;
26752:         *vp = JSVAL_HOLE;
26752:         return JS_TRUE;
26752:     }
26752:     return ok;
26752: }
26752: 
32615: JS_DEFINE_TRCINFO_1(CatchStopIteration_tn,
39910:     (3, (static, BOOL, CatchStopIteration_tn, CONTEXT, BOOL, JSVALPTR, 0, ACC_STORE_ANY)))
26752: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
28086: TraceRecorder::record_NativeCallComplete()
28086: {
32669:     if (pendingSpecializedNative == IGNORE_NATIVE_CALL_COMPLETE_CALLBACK)
33542:         return ARECORD_CONTINUE;
28086: 
28086:     jsbytecode* pc = cx->fp->regs->pc;
28086: 
32669:     JS_ASSERT(pendingSpecializedNative);
30847:     JS_ASSERT(*pc == JSOP_CALL || *pc == JSOP_APPLY || *pc == JSOP_NEW || *pc == JSOP_SETPROP);
26552: 
26552:     jsval& v = stackval(-1);
26552:     LIns* v_ins = get(&v);
26552: 
30847:     /*
30847:      * At this point the generated code has already called the native function
30847:      * and we can no longer fail back to the original pc location (JSOP_CALL)
30847:      * because that would cause the interpreter to re-execute the native
30847:      * function, which might have side effects.
30847:      *
30847:      * Instead, the snapshot() call below sees that we are currently parked on
30847:      * a traceable native's JSOP_CALL instruction, and it will advance the pc
30847:      * to restore by the length of the current opcode.  If the native's return
30847:      * type is jsval, snapshot() will also indicate in the type map that the
30847:      * element on top of the stack is a boxed value which doesn't need to be
30847:      * boxed if the type guard generated by unbox_jsval() fails.
30847:      */
24612: 
32669:     if (JSTN_ERRTYPE(pendingSpecializedNative) == FAIL_STATUS) {
30860:         /* Keep cx->bailExit null when it's invalid. */
40353:         lir->insStorei(INS_NULL(), cx_ins, (int) offsetof(JSContext, bailExit), ACC_OTHER);
40353: 
40353:         LIns* status = lir->insLoad(LIR_ld, lirbuf->state,
40353:                                     (int) offsetof(InterpState, builtinStatus), ACC_OTHER);
32669:         if (pendingSpecializedNative == &generatedSpecializedNative) {
26552:             LIns* ok_ins = v_ins;
26552: 
26552:             /*
26752:              * Custom implementations of Iterator.next() throw a StopIteration exception.
26752:              * Catch and clear it and set the return value to JSVAL_HOLE in this case.
26752:              */
28086:             if (uintptr_t(pc - nextiter_imacros.custom_iter_next) <
26752:                 sizeof(nextiter_imacros.custom_iter_next)) {
28086:                 LIns* args[] = { native_rval_ins, ok_ins, cx_ins }; /* reverse order */
32615:                 ok_ins = lir->insCall(&CatchStopIteration_tn_ci, args);
26752:             }
26752: 
26752:             /*
26552:              * If we run a generic traceable native, the return value is in the argument
28086:              * vector for native function calls. The actual return value of the native is a JSBool
28086:              * indicating the error status.
28086:              */
40353:             v_ins = lir->insLoad(LIR_ldp, native_rval_ins, 0, ACC_OTHER);
28086:             if (*pc == JSOP_NEW) {
32746:                 LIns* x = lir->ins_peq0(lir->ins2(LIR_piand, v_ins, INS_CONSTWORD(JSVAL_TAGMASK)));
33950:                 x = lir->ins_choose(x, v_ins, INS_CONSTWORD(0), avmplus::AvmCore::use_cmov());
33950:                 v_ins = lir->ins_choose(lir->ins_peq0(x), newobj_ins, x, avmplus::AvmCore::use_cmov());
28086:             }
26552:             set(&v, v_ins);
26552: 
30847:             propagateFailureToBuiltinStatus(ok_ins, status);
30847:         }
30847:         guard(true, lir->ins_eq0(status), STATUS_EXIT);
24612:     }
24612: 
32669:     if (pendingSpecializedNative->flags & JSTN_UNBOX_AFTER) {
26972:         /*
26972:          * If we side exit on the unboxing code due to a type change, make sure that the boxed
26972:          * value is actually currently associated with that location, and that we are talking
26972:          * about the top of the stack here, which is where we expected boxed values.
26972:          */
26972:         JS_ASSERT(&v == &cx->fp->regs->sp[-1] && get(&v) == v_ins);
31902:         set(&v, unbox_jsval(v, v_ins, snapshot(BRANCH_EXIT)));
32669:     } else if (JSTN_ERRTYPE(pendingSpecializedNative) == FAIL_NEG) {
27059:         /* Already added i2f in functionCall. */
27059:         JS_ASSERT(JSVAL_IS_NUMBER(v));
24612:     } else {
20966:         /* Convert the result to double if the builtin returns int32. */
20966:         if (JSVAL_IS_NUMBER(v) &&
40325:             pendingSpecializedNative->builtin->returnType() == ARGTYPE_I) {
20966:             set(&v, lir->ins1(LIR_i2f, v_ins));
20966:         }
20405:     }
20405: 
32669:     // We'll null pendingSpecializedNative in monitorRecording, on the next op
32669:     // cycle.  There must be a next op since the stack is non-empty.
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
31075: TraceRecorder::name(jsval*& vp, LIns*& ins, NameResult& nr)
18096: {
18096:     JSObject* obj = cx->fp->scopeChain;
18096:     if (obj != globalObj)
31075:         return scopeChainProp(obj, vp, ins, nr);
18115: 
18115:     /* Can't use prop here, because we don't want unboxing from global slots. */
37694:     LIns* obj_ins = INS_CONSTOBJ(globalObj);
18096:     uint32 slot;
27897: 
27897:     JSObject* obj2;
40374:     PCVal pcval;
27897: 
27897:     /*
27897:      * Property cache ensures that we are dealing with an existing property,
27897:      * and guards the shape for us.
27897:      */
33542:     CHECK_STATUS_A(test_property_cache(obj, obj_ins, obj2, pcval));
27897: 
30860:     /* Abort if property doesn't exist (interpreter will report an error.) */
40374:     if (pcval.isNull())
33542:         RETURN_STOP_A("named property not found");
18096: 
30860:     /* Insist on obj being the directly addressed object. */
27897:     if (obj2 != obj)
33542:         RETURN_STOP_A("name() hit prototype chain");
27897: 
27897:     /* Don't trace getter or setter calls, our caller wants a direct slot. */
40374:     if (pcval.isSprop()) {
40374:         JSScopeProperty* sprop = pcval.toSprop();
27897:         if (!isValidSlot(OBJ_SCOPE(obj), sprop))
33542:             RETURN_STOP_A("name() not accessing a valid slot");
27897:         slot = sprop->slot;
27897:     } else {
40374:         if (!pcval.isSlot())
33542:             RETURN_STOP_A("PCE is not a slot");
40374:         slot = pcval.toSlot();
27897:     }
27897: 
18096:     if (!lazilyImportGlobalSlot(slot))
33542:         RETURN_STOP_A("lazy import of global slot failed");
18096: 
40410:     vp = &obj->getSlotRef(slot);
30647:     ins = get(vp);
31075:     nr.tracked = true;
33542:     return ARECORD_CONTINUE;
27933: }
27933: 
32658: static JSObject* FASTCALL
32658: MethodReadBarrier(JSContext* cx, JSObject* obj, JSScopeProperty* sprop, JSObject* funobj)
32658: {
40403:     AutoValueRooter tvr(cx, funobj);
32658: 
32658:     if (!OBJ_SCOPE(obj)->methodReadBarrier(cx, sprop, tvr.addr()))
32658:         return NULL;
32658:     JS_ASSERT(VALUE_IS_FUNCTION(cx, tvr.value()));
32658:     return JSVAL_TO_OBJECT(tvr.value());
32658: }
32658: JS_DEFINE_CALLINFO_4(static, OBJECT_FAIL, MethodReadBarrier, CONTEXT, OBJECT, SCOPEPROP, OBJECT,
39910:                      0, ACC_STORE_ANY)
32658: 
32557: /*
32557:  * Get a property. The current opcode has JOF_ATOM.
32557:  *
32557:  * There are two modes. The caller must pass nonnull pointers for either outp
32557:  * or both slotp and v_insp. In the latter case, we require a plain old
32557:  * property with a slot; if the property turns out to be anything else, abort
32557:  * tracing (rather than emit a call to a native getter or GetAnyProperty).
32557:  */
33542: JS_REQUIRES_STACK AbortableRecordingStatus
32557: TraceRecorder::prop(JSObject* obj, LIns* obj_ins, uint32 *slotp, LIns** v_insp, jsval *outp)
32557: {
40798:     /*
40798:      * Insist that obj have js_SetProperty as its set object-op. This suffices
40798:      * to prevent a rogue obj from being used on-trace (loaded via obj_ins),
40798:      * because we will guard on shape (or else global object identity) and any
40798:      * object not having the same op must have a different class, and therefore
40798:      * must differ in its shape (or not be the global object).
40798:      */
40798:     if (!obj->isDenseArray() && obj->map->ops->getProperty != js_GetProperty)
40798:         RETURN_STOP_A("non-dense-array, non-native JSObjectOps::getProperty");
40798: 
32557:     JS_ASSERT((slotp && v_insp && !outp) || (!slotp && !v_insp && outp));
32557: 
17758:     /*
17758:      * Can't specialize to assert obj != global, must guard to avoid aliasing
17758:      * stale homes of stacked global variables.
17758:      */
33542:     CHECK_STATUS_A(guardNotGlobalObject(obj, obj_ins));
17758: 
18115:     /*
18115:      * Property cache ensures that we are dealing with an existing property,
18115:      * and guards the shape for us.
18115:      */
18115:     JSObject* obj2;
40374:     PCVal pcval;
33542:     CHECK_STATUS_A(test_property_cache(obj, obj_ins, obj2, pcval));
17665: 
17998:     /* Check for non-existent property reference, which results in undefined. */
40374:     if (pcval.isNull()) {
32557:         if (slotp)
33542:             RETURN_STOP_A("property not found");
32557: 
25633:         /*
29872:          * We could specialize to guard on just JSClass.getProperty, but a mere
29872:          * class guard is simpler and slightly faster.
29872:          */
29872:         if (OBJ_GET_CLASS(cx, obj)->getProperty != JS_PropertyStub) {
33542:             RETURN_STOP_A("can't trace through access to undefined property if "
29872:                           "JSClass.getProperty hook isn't stubbed");
29872:         }
40353:         guardClass(obj, obj_ins, OBJ_GET_CLASS(cx, obj), snapshot(MISMATCH_EXIT), ACC_OTHER);
29872: 
29872:         /*
25633:          * This trace will be valid as long as neither the object nor any object
29872:          * on its prototype chain changes shape.
29874:          *
29874:          * FIXME: This loop can become a single shape guard once bug 497789 has
29874:          * been fixed.
25633:          */
27540:         VMSideExit* exit = snapshot(BRANCH_EXIT);
29513:         do {
40430:             if (obj->isNative()) {
40393:                 CHECK_STATUS_A(InjectStatus(guardShape(obj_ins, obj, OBJ_SHAPE(obj),
40393:                                                        "guard(shape)", exit)));
32777:             } else if (!guardDenseArray(obj, obj_ins, exit)) {
33542:                 RETURN_STOP_A("non-native object involved in undefined property access");
32777:             }
29513:         } while (guardHasPrototype(obj, obj_ins, &obj, &obj_ins, exit));
25633: 
40307:         set(outp, INS_VOID());
33542:         return ARECORD_CONTINUE;
17998:     }
17998: 
37685:     return propTail(obj, obj_ins, obj2, pcval, slotp, v_insp, outp);
37685: }
37685: 
37685: JS_REQUIRES_STACK AbortableRecordingStatus
40374: TraceRecorder::propTail(JSObject* obj, LIns* obj_ins, JSObject* obj2, PCVal pcval,
37685:                         uint32 *slotp, LIns** v_insp, jsval *outp)
37685: {
37685:     const JSCodeSpec& cs = js_CodeSpec[*cx->fp->regs->pc];
30847:     uint32 setflags = (cs.format & (JOF_INCDEC | JOF_FOR));
30847:     JS_ASSERT(!(cs.format & JOF_SET));
18143: 
32658:     JSScopeProperty* sprop;
32557:     uint32 slot;
32658:     bool isMethod;
32658: 
40374:     if (pcval.isSprop()) {
40374:         sprop = pcval.toSprop();
35453:         JS_ASSERT(OBJ_SCOPE(obj2)->hasProperty(sprop));
18115: 
40265:         if (setflags && !sprop->hasDefaultSetter())
33542:             RETURN_STOP_A("non-stub setter");
40265:         if (setflags && !sprop->writable())
33542:             RETURN_STOP_A("writing to a readonly property");
40265:         if (!sprop->hasDefaultGetterOrIsMethod()) {
32557:             if (slotp)
33542:                 RETURN_STOP_A("can't trace non-stub getter for this opcode");
40265:             if (sprop->hasGetterValue())
33542:                 RETURN_STOP_A("script getter");
32558:             if (sprop->slot == SPROP_INVALID_SLOT)
33542:                 return InjectStatus(getPropertyWithNativeGetter(obj_ins, sprop, outp));
33542:             return InjectStatus(getPropertyById(obj_ins, outp));
18115:         }
28909:         if (!SPROP_HAS_VALID_SLOT(sprop, OBJ_SCOPE(obj2)))
33542:             RETURN_STOP_A("no valid slot");
18115:         slot = sprop->slot;
32658:         isMethod = sprop->isMethod();
32658:         JS_ASSERT_IF(isMethod, OBJ_SCOPE(obj2)->hasMethodBarrier());
18115:     } else {
40374:         if (!pcval.isSlot())
33542:             RETURN_STOP_A("PCE is not a slot");
40374:         slot = pcval.toSlot();
32658:         sprop = NULL;
32658:         isMethod = false;
32658:     }
32658: 
32658:     /* We have a slot. Check whether it is direct or in a prototype. */
25092:     if (obj2 != obj) {
25092:         if (setflags)
33542:             RETURN_STOP_A("JOF_INCDEC|JOF_FOR opcode hit prototype chain");
25092: 
25092:         /*
37685:          * We're getting a prototype property. Two cases:
37685:          *
37685:          * 1. If obj2 is obj's immediate prototype we must walk up from obj,
37685:          * since direct and immediate-prototype cache hits key on obj's shape,
37685:          * not its identity.
37685:          *
37685:          * 2. Otherwise obj2 is higher up the prototype chain and we've keyed
37685:          * on obj's identity, and since setting __proto__ reshapes all objects
37685:          * along the old prototype chain, then provided we shape-guard obj2,
37685:          * we can "teleport" directly to obj2 by embedding it as a constant
37685:          * (this constant object instruction will be CSE'ed with the constant
37685:          * emitted by test_property_cache, whose shape is guarded).
37685:          */
37685:         obj_ins = (obj2 == obj->getProto()) ? stobj_get_proto(obj_ins) : INS_CONSTOBJ(obj2);
37685:         obj = obj2;
25092:     }
25092: 
30847:     LIns* dslots_ins = NULL;
40410:     LIns* v_ins = unbox_jsval(obj->getSlot(slot),
31902:                               stobj_get_slot(obj_ins, slot, dslots_ins),
31902:                               snapshot(BRANCH_EXIT));
26972: 
32658:     /*
32658:      * Joined function object stored as a method must be cloned when extracted
32658:      * as a property value other than a callee. Note that shapes cover method
32658:      * value as well as other property attributes and order, so this condition
32658:      * is trace-invariant.
32658:      *
32658:      * We do not impose the method read barrier if in an imacro, assuming any
32658:      * property gets it does (e.g., for 'toString' from JSOP_NEW) will not be
32658:      * leaked to the calling script.
32658:      */
32658:     if (isMethod && !cx->fp->imacpc) {
33560:         enterDeepBailCall();
32658:         LIns* args[] = { v_ins, INS_CONSTSPROP(sprop), obj_ins, cx_ins };
32658:         v_ins = lir->insCall(&MethodReadBarrier_ci, args);
33560:         leaveDeepBailCall();
32658:     }
32658: 
32557:     if (slotp) {
32557:         *slotp = slot;
32557:         *v_insp = v_ins;
32557:     }
32557:     if (outp)
39913:         set(outp, v_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK RecordingStatus
28411: TraceRecorder::denseArrayElement(jsval& oval, jsval& ival, jsval*& vp, LIns*& v_ins,
28411:                                  LIns*& addr_ins)
28411: {
28411:     JS_ASSERT(JSVAL_IS_OBJECT(oval) && JSVAL_IS_INT(ival));
19983: 
19983:     JSObject* obj = JSVAL_TO_OBJECT(oval);
19983:     LIns* obj_ins = get(&oval);
27891:     jsint idx = JSVAL_TO_INT(ival);
27891:     LIns* idx_ins = makeNumberInt32(get(&ival));
32746:     LIns* pidx_ins = lir->ins_u2p(idx_ins);
17758: 
27891:     VMSideExit* exit = snapshot(BRANCH_EXIT);
27891: 
17758:     /* check that the index is within bounds */
40353:     LIns* dslots_ins = lir->insLoad(LIR_ldp, obj_ins, offsetof(JSObject, dslots), ACC_OTHER);
27891:     jsuint capacity = js_DenseArrayCapacity(obj);
40796:     bool within = (jsuint(idx) < obj->getArrayLength() && jsuint(idx) < capacity);
27891:     if (!within) {
27891:         /* If idx < 0, stay on trace (and read value as undefined, since this is a dense array). */
27891:         LIns* br1 = NULL;
32650:         if (MAX_DSLOTS_LENGTH > MAX_DSLOTS_LENGTH32 && !idx_ins->isconst()) {
32650:             /* Only 64-bit machines support large enough arrays for this. */
32650:             JS_ASSERT(sizeof(jsval) == 8);
27891:             br1 = lir->insBranch(LIR_jt,
27891:                                  lir->ins2i(LIR_lt, idx_ins, 0),
27891:                                  NULL);
27891:         }
27891: 
27891:         /* If not idx < length, stay on trace (and read value as undefined). */
27891:         LIns* br2 = lir->insBranch(LIR_jf,
32746:                                    lir->ins2(LIR_pult,
32746:                                              pidx_ins,
40796:                                              stobj_get_fslot(obj_ins, JSObject::JSSLOT_ARRAY_LENGTH)),
27891:                                    NULL);
27891: 
27891:         /* If dslots is NULL, stay on trace (and read value as undefined). */
35057:         LIns* br3 = lir->insBranch(LIR_jt, lir->ins_peq0(dslots_ins), NULL);
27891: 
27891:         /* If not idx < capacity, stay on trace (and read value as undefined). */
27891:         LIns* br4 = lir->insBranch(LIR_jf,
32746:                                    lir->ins2(LIR_pult,
32746:                                              pidx_ins,
40353:                                              lir->insLoad(LIR_ldp, dslots_ins,
40353:                                                           -(int)sizeof(jsval), ACC_OTHER)),
27891:                                    NULL);
30650:         lir->insGuard(LIR_x, NULL, createGuardRecord(exit));
27891:         LIns* label = lir->ins0(LIR_label);
27891:         if (br1)
28182:             br1->setTarget(label);
28182:         br2->setTarget(label);
28182:         br3->setTarget(label);
28182:         br4->setTarget(label);
27891: 
27933:         CHECK_STATUS(guardPrototypeHasNoIndexedProperties(obj, obj_ins, MISMATCH_EXIT));
25883: 
20972:         // Return undefined and indicate that we didn't actually read this (addr_ins).
40294:         v_ins = INS_VOID();
20972:         addr_ins = NULL;
33542:         return RECORD_CONTINUE;
20972:     }
20404: 
27891:     /* Guard against negative index */
32650:     if (MAX_DSLOTS_LENGTH > MAX_DSLOTS_LENGTH32 && !idx_ins->isconst()) {
32650:         /* Only 64-bit machines support large enough arrays for this. */
32650:         JS_ASSERT(sizeof(jsval) == 8);
27891:         guard(false,
27891:               lir->ins2i(LIR_lt, idx_ins, 0),
27891:               exit);
27891:     }
27891: 
27891:     /* Guard array length */
27891:     guard(true,
40796:           lir->ins2(LIR_pult, pidx_ins, stobj_get_fslot(obj_ins, JSObject::JSSLOT_ARRAY_LENGTH)),
27891:           exit);
27891: 
27891:     /* dslots must not be NULL */
27891:     guard(false,
35057:           lir->ins_peq0(dslots_ins),
27891:           exit);
27891: 
27891:     /* Guard array capacity */
27891:     guard(true,
32746:           lir->ins2(LIR_pult,
32746:                     pidx_ins,
40353:                     lir->insLoad(LIR_ldp, dslots_ins, 0 - (int)sizeof(jsval), ACC_OTHER)),
27891:           exit);
27891: 
27891:     /* Load the value and guard on its type to unbox it. */
27891:     vp = &obj->dslots[jsuint(idx)];
18232:     addr_ins = lir->ins2(LIR_piadd, dslots_ins,
32746:                          lir->ins2i(LIR_pilsh, pidx_ins, (sizeof(jsval) == 4) ? 2 : 3));
40353:     v_ins = unbox_jsval(*vp, lir->insLoad(LIR_ldp, addr_ins, 0, ACC_OTHER), exit);
38981: 
40307:     if (JSVAL_IS_SPECIAL(*vp) && !JSVAL_IS_VOID(*vp)) {
27891:         /*
30860:          * If we read a hole from the array, convert it to undefined and guard
30860:          * that there are no indexed properties along the prototype chain.
27891:          */
27891:         LIns* br = lir->insBranch(LIR_jf,
31521:                                   lir->ins2i(LIR_eq, v_ins, JSVAL_TO_SPECIAL(JSVAL_HOLE)),
27891:                                   NULL);
27933:         CHECK_STATUS(guardPrototypeHasNoIndexedProperties(obj, obj_ins, MISMATCH_EXIT));
28182:         br->setTarget(lir->ins0(LIR_label));
27891: 
30860:         /* Don't let the hole value escape. Turn it into an undefined. */
27891:         v_ins = lir->ins2i(LIR_and, v_ins, ~(JSVAL_HOLE_FLAG >> JSVAL_TAGBITS));
19053:     }
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
37754: TraceRecorder::typedArrayElement(jsval& oval, jsval& ival, jsval*& vp, LIns*& v_ins,
37754:                                  LIns*& addr_ins)
37754: {
37754:     JS_ASSERT(JSVAL_IS_OBJECT(oval) && JSVAL_IS_INT(ival));
37754: 
37754:     JSObject* obj = JSVAL_TO_OBJECT(oval);
37754:     LIns* obj_ins = get(&oval);
37754:     jsint idx = JSVAL_TO_INT(ival);
37754:     LIns* idx_ins = makeNumberInt32(get(&ival));
37754:     LIns* pidx_ins = lir->ins_u2p(idx_ins);
37754: 
37754:     js::TypedArray* tarray = js::TypedArray::fromJSObject(obj);
37754:     JS_ASSERT(tarray);
37754: 
37754:     /* priv_ins will load the TypedArray* */
37776:     LIns* priv_ins = stobj_get_const_fslot(obj_ins, JSSLOT_PRIVATE);
37754: 
40294:     /* for out-of-range, do the same thing that the interpreter does, which is return undefined */
40294:     if ((jsuint) idx >= tarray->length) {
40294:         guard(false,
40294:               lir->ins2(LIR_ult,
40294:                         idx_ins,
40294:                         lir->insLoad(LIR_ld, priv_ins, js::TypedArray::lengthOffset(), ACC_READONLY)),
40294:               BRANCH_EXIT);
40294:         v_ins = INS_VOID();
40294:         return ARECORD_CONTINUE;
40294:     }
37754: 
37754:     /*
37754:      * Ensure idx < length
37754:      *
37754:      * NOTE! mLength is uint32, but it's guaranteed to fit in a jsval
37754:      * int, so we can treat it as either signed or unsigned.
37754:      * If the index happens to be negative, when it's treated as
37754:      * unsigned it'll be a very large int, and thus won't be less than
37754:      * length.
37754:      */
37754:     guard(true,
37754:           lir->ins2(LIR_ult,
37754:                     idx_ins,
39910:                     lir->insLoad(LIR_ld, priv_ins, js::TypedArray::lengthOffset(), ACC_READONLY)),
40294:           BRANCH_EXIT);
37754: 
37754:     /* We are now ready to load.  Do a different type of load
37754:      * depending on what type of thing we're loading. */
39910:     LIns* data_ins = lir->insLoad(LIR_ldp, priv_ins, js::TypedArray::dataOffset(), ACC_READONLY);
37754: 
37754:     switch (tarray->type) {
37754:       case js::TypedArray::TYPE_INT8:
37754:         addr_ins = lir->ins2(LIR_piadd, data_ins, pidx_ins);
40353:         v_ins = lir->ins1(LIR_i2f, lir->insLoad(LIR_ldsb, addr_ins, 0, ACC_OTHER));
37754:         break;
37754:       case js::TypedArray::TYPE_UINT8:
38515:       case js::TypedArray::TYPE_UINT8_CLAMPED:
37754:         addr_ins = lir->ins2(LIR_piadd, data_ins, pidx_ins);
40353:         v_ins = lir->ins1(LIR_u2f, lir->insLoad(LIR_ldzb, addr_ins, 0, ACC_OTHER));
37754:         break;
37754:       case js::TypedArray::TYPE_INT16:
37754:         addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 1));
40353:         v_ins = lir->ins1(LIR_i2f, lir->insLoad(LIR_ldss, addr_ins, 0, ACC_OTHER));
37754:         break;
37754:       case js::TypedArray::TYPE_UINT16:
37754:         addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 1));
40353:         v_ins = lir->ins1(LIR_u2f, lir->insLoad(LIR_ldzs, addr_ins, 0, ACC_OTHER));
37754:         break;
37754:       case js::TypedArray::TYPE_INT32:
37754:         addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 2));
40353:         v_ins = lir->ins1(LIR_i2f, lir->insLoad(LIR_ld, addr_ins, 0, ACC_OTHER));
37754:         break;
37754:       case js::TypedArray::TYPE_UINT32:
37754:         addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 2));
40353:         v_ins = lir->ins1(LIR_u2f, lir->insLoad(LIR_ld, addr_ins, 0, ACC_OTHER));
37754:         break;
37754:       case js::TypedArray::TYPE_FLOAT32:
37754:         addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 2));
40353:         v_ins = lir->insLoad(LIR_ld32f, addr_ins, 0, ACC_OTHER);
37754:         break;
38512:       case js::TypedArray::TYPE_FLOAT64:
38512:         addr_ins = lir->ins2(LIR_piadd, data_ins, lir->ins2i(LIR_pilsh, pidx_ins, 3));
40353:         v_ins = lir->insLoad(LIR_ldf, addr_ins, 0, ACC_OTHER);
38512:         break;
37754:       default:
37754:         JS_NOT_REACHED("Unknown typed array type in tracer");
37754:     }
37754: 
37754:     return ARECORD_CONTINUE;
37754: }
37754: 
37754: JS_REQUIRES_STACK AbortableRecordingStatus
17758: TraceRecorder::getProp(JSObject* obj, LIns* obj_ins)
17758: {
37685:     JSOp op = JSOp(*cx->fp->regs->pc);
37685:     const JSCodeSpec& cs = js_CodeSpec[op];
37685: 
17758:     JS_ASSERT(cs.ndefs == 1);
32557:     return prop(obj, obj_ins, NULL, NULL, &stackval(-cs.nuses));
27933: }
27933: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17688: TraceRecorder::getProp(jsval& v)
17665: {
17665:     if (JSVAL_IS_PRIMITIVE(v))
33542:         RETURN_STOP_A("primitive lhs");
17665: 
17688:     return getProp(JSVAL_TO_OBJECT(v), get(&v));
17665: }
17665: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_NAME()
17409: {
18096:     jsval* vp;
30647:     LIns* v_ins;
31075:     NameResult nr;
33542:     CHECK_STATUS_A(name(vp, v_ins, nr));
30647:     stack(0, v_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DOUBLE()
17409: {
17611:     jsval v = jsval(atoms[GET_INDEX(cx->fp->regs->pc)]);
26265:     stack(0, lir->insImmf(*JSVAL_TO_DOUBLE(v)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_STRING()
17409: {
17902:     JSAtom* atom = atoms[GET_INDEX(cx->fp->regs->pc)];
17902:     JS_ASSERT(ATOM_IS_STRING(atom));
31843:     stack(0, INS_ATOM(atom));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ZERO()
17409: {
32640:     stack(0, lir->insImmf(0));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ONE()
17409: {
26265:     stack(0, lir->insImmf(1));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_NULL()
17409: {
31843:     stack(0, INS_NULL());
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_THIS()
17409: {
17688:     LIns* this_ins;
33542:     CHECK_STATUS_A(getThis(this_ins));
17688:     stack(0, this_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_FALSE()
17409: {
17418:     stack(0, lir->insImm(0));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TRUE()
17409: {
17418:     stack(0, lir->insImm(1));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_OR()
17409: {
20416:     return ifop();
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_AND()
17409: {
20416:     return ifop();
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TABLESWITCH()
17409: {
25099: #ifdef NANOJIT_IA32
26557:     /* Handle tableswitches specially -- prepare a jump table if needed. */
31060:     return tableswitch();
25099: #else
33542:     return InjectStatus(switchop());
33542: #endif
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LOOKUPSWITCH()
17409: {
33542:     return InjectStatus(switchop());
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_STRICTEQ()
17409: {
23093:     strictEquality(true, false);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_STRICTNE()
17409: {
23093:     strictEquality(false, false);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_OBJECT()
17409: {
18027:     JSStackFrame* fp = cx->fp;
18027:     JSScript* script = fp->script;
18027:     unsigned index = atoms - script->atomMap.vector + GET_INDEX(fp->regs->pc);
18027: 
18027:     JSObject* obj;
32723:     obj = script->getObject(index);
31843:     stack(0, INS_CONSTOBJ(obj));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_POP()
17409: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TRAP()
17899: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GETARG()
17409: {
17412:     stack(0, arg(GET_ARGNO(cx->fp->regs->pc)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_SETARG()
17409: {
17415:     arg(GET_ARGNO(cx->fp->regs->pc), stack(-1));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_GETLOCAL()
17409: {
17807:     stack(0, var(GET_SLOTNO(cx->fp->regs->pc)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_SETLOCAL()
17409: {
17807:     var(GET_SLOTNO(cx->fp->regs->pc), stack(-1));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_UINT16()
17409: {
26265:     stack(0, lir->insImmf(GET_UINT16(cx->fp->regs->pc)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_NEWINIT()
17409: {
18036:     JSProtoKey key = JSProtoKey(GET_INT8(cx->fp->regs->pc));
27012:     LIns* proto_ins;
33542:     CHECK_STATUS_A(getClassPrototype(key, proto_ins));
32615: 
27012:     LIns* args[] = { proto_ins, cx_ins };
37035:     const CallInfo *ci = (key == JSProto_Array)
37035:                          ? &js_NewEmptyArray_ci
37035:                          : (cx->fp->regs->pc[JSOP_NEWINIT_LENGTH] != JSOP_ENDINIT)
37035:                          ? &js_NonEmptyObject_ci
37035:                          : &js_Object_tn_ci;
32615:     LIns* v_ins = lir->insCall(ci, args);
32746:     guard(false, lir->ins_peq0(v_ins), OOM_EXIT);
32615:     stack(0, v_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ENDINIT()
17409: {
24198: #ifdef DEBUG
18712:     jsval& v = stackval(-1);
18712:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
24198: #endif
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INITPROP()
17409: {
19093:     // All the action is in record_SetPropHit.
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INITELEM()
17409: {
35466:     return setElem(-3, -2, -1);
17409: }
17899: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DEFSHARP()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_USESHARP()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INCARG()
17409: {
33542:     return InjectStatus(inc(argval(GET_ARGNO(cx->fp->regs->pc)), 1));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_INCLOCAL()
17409: {
33542:     return InjectStatus(inc(varval(GET_SLOTNO(cx->fp->regs->pc)), 1));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DECARG()
17409: {
33542:     return InjectStatus(inc(argval(GET_ARGNO(cx->fp->regs->pc)), -1));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_DECLOCAL()
17409: {
33542:     return InjectStatus(inc(varval(GET_SLOTNO(cx->fp->regs->pc)), -1));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ARGINC()
17409: {
33542:     return InjectStatus(inc(argval(GET_ARGNO(cx->fp->regs->pc)), 1, false));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_LOCALINC()
17409: {
33542:     return InjectStatus(inc(varval(GET_SLOTNO(cx->fp->regs->pc)), 1, false));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ARGDEC()
17409: {
33542:     return InjectStatus(inc(argval(GET_ARGNO(cx->fp->regs->pc)), -1, false));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_LOCALDEC()
17409: {
33542:     return InjectStatus(inc(varval(GET_SLOTNO(cx->fp->regs->pc)), -1, false));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
21685: TraceRecorder::record_JSOP_IMACOP()
21685: {
21685:     JS_ASSERT(cx->fp->imacpc);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ITER()
17409: {
17958:     jsval& v = stackval(-1);
24384:     if (JSVAL_IS_PRIMITIVE(v))
33542:         RETURN_STOP_A("for-in on a primitive value");
33542:     RETURN_IF_XML_A(v);
24384: 
18136:     jsuint flags = cx->fp->regs->pc[1];
21685: 
40327:     bool found;
40327:     RecordingStatus status = hasIteratorMethod(JSVAL_TO_OBJECT(v), found);
40327:     if (status != RECORD_CONTINUE)
40327:         return InjectStatus(status);
40327:     if (found) {
21685:         if (flags == JSITER_ENUMERATE)
33542:             return InjectStatus(call_imacro(iter_imacros.for_in));
21686:         if (flags == (JSITER_ENUMERATE | JSITER_FOREACH))
33542:             return InjectStatus(call_imacro(iter_imacros.for_each));
24384:     } else {
24384:         if (flags == JSITER_ENUMERATE)
33542:             return InjectStatus(call_imacro(iter_imacros.for_in_native));
24384:         if (flags == (JSITER_ENUMERATE | JSITER_FOREACH))
33542:             return InjectStatus(call_imacro(iter_imacros.for_each_native));
33542:     }
33542:     RETURN_STOP_A("unimplemented JSITER_* flags");
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
24384: TraceRecorder::record_JSOP_NEXTITER()
24384: {
24384:     jsval& iterobj_val = stackval(-2);
24384:     if (JSVAL_IS_PRIMITIVE(iterobj_val))
33542:         RETURN_STOP_A("for-in on a primitive value");
33542:     RETURN_IF_XML_A(iterobj_val);
26752:     JSObject* iterobj = JSVAL_TO_OBJECT(iterobj_val);
38497:     JSClass* clasp = iterobj->getClass();
24310:     LIns* iterobj_ins = get(&iterobj_val);
40353:     guardClass(iterobj, iterobj_ins, clasp, snapshot(BRANCH_EXIT), ACC_OTHER);
35052:     if (clasp == &js_IteratorClass || clasp == &js_GeneratorClass)
33542:         return InjectStatus(call_imacro(nextiter_imacros.native_iter_next));
33542:     return InjectStatus(call_imacro(nextiter_imacros.custom_iter_next));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18085: TraceRecorder::record_JSOP_ENDITER()
18085: {
21441:     LIns* args[] = { stack(-2), cx_ins };
20915:     LIns* ok_ins = lir->insCall(&js_CloseIterator_ci, args);
18085:     guard(false, lir->ins_eq0(ok_ins), MISMATCH_EXIT);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18085: TraceRecorder::record_JSOP_FORNAME()
18085: {
18136:     jsval* vp;
30647:     LIns* x_ins;
31075:     NameResult nr;
33542:     CHECK_STATUS_A(name(vp, x_ins, nr));
31075:     if (!nr.tracked)
33542:         RETURN_STOP_A("forname on non-tracked value not supported");
21441:     set(vp, stack(-1));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18136: TraceRecorder::record_JSOP_FORPROP()
18136: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18136: TraceRecorder::record_JSOP_FORELEM()
18136: {
21441:     return record_JSOP_DUP();
18085: }
18085: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18085: TraceRecorder::record_JSOP_FORARG()
18085: {
21441:     return record_JSOP_SETARG();
18085: }
18085: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18085: TraceRecorder::record_JSOP_FORLOCAL()
18085: {
21441:     return record_JSOP_SETLOCAL();
17899: }
17899: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_POPN()
17409: {
33542:     return ARECORD_CONTINUE;
27933: }
27933: 
32589: /*
36362:  * Generate LIR to reach |obj2| from |obj| by traversing the scope chain. The
36362:  * generated code also ensures that any call objects found have not changed shape.
32589:  *
32589:  *      obj               starting object
32589:  *      obj_ins           LIR instruction representing obj
36362:  *      targetObj         end object for traversal
36362:  *      targetIns [out]   LIR instruction representing obj2
32589:  */
33542: JS_REQUIRES_STACK RecordingStatus
36362: TraceRecorder::traverseScopeChain(JSObject *obj, LIns *obj_ins, JSObject *targetObj,
36362:                                   LIns *&targetIns)
32589: {
32761:     VMSideExit* exit = NULL;
36362: 
36362:     /*
36362:      * Scope chains are often left "incomplete", and reified lazily when
36362:      * necessary, since doing so is expensive. When creating null and flat
36362:      * closures on trace (the only kinds supported), the global object is
36362:      * hardcoded as the parent, since reifying the scope chain on trace
36362:      * would be extremely difficult. This is because block objects need frame
36362:      * pointers, which do not exist on trace, and thus would require magic
36362:      * similar to arguments objects or reification of stack frames. Luckily,
36362:      * for null and flat closures, these blocks are unnecessary.
36362:      *
36362:      * The problem, as exposed by bug 523793, is that this means creating a
36362:      * fixed traversal on trace can be inconsistent with the shorter scope
36362:      * chain used when executing a trace. To address this, perform an initial
36362:      * sweep of the scope chain to make sure that if there is a heavyweight
36362:      * function with a call object, and there is also a block object, the
36362:      * trace is safely aborted.
36362:      *
36362:      * If there is no call object, we must have arrived at the global object,
36362:      * and can bypass the scope chain traversal completely.
36362:      */
36362:     bool foundCallObj = false;
36362:     bool foundBlockObj = false;
36362:     JSObject* searchObj = obj;
36362: 
36362:     for (;;) {
36362:         if (searchObj != globalObj) {
38497:             JSClass* cls = searchObj->getClass();
36362:             if (cls == &js_BlockClass) {
36362:                 foundBlockObj = true;
36362:             } else if (cls == &js_CallClass &&
36362:                        JSFUN_HEAVYWEIGHT_TEST(js_GetCallObjectFunction(searchObj)->flags)) {
36362:                 foundCallObj = true;
36362:             }
36362:         }
36362: 
36362:         if (searchObj == targetObj)
36362:             break;
36362: 
39930:         searchObj = searchObj->getParent();
36362:         if (!searchObj)
36362:             RETURN_STOP("cannot traverse this scope chain on trace");
36362:     }
36362: 
36362:     if (!foundCallObj) {
36362:         JS_ASSERT(targetObj == globalObj);
36362:         targetIns = INS_CONSTPTR(globalObj);
36362:         return RECORD_CONTINUE;
36362:     }
36362: 
36362:     if (foundBlockObj)
36362:         RETURN_STOP("cannot traverse this scope chain on trace");
36362: 
36362:     /* There was a call object, or should be a call object now. */
32589:     for (;;) {
32589:         if (obj != globalObj) {
32589:             if (!js_IsCacheableNonGlobalScope(obj))
33542:                 RETURN_STOP("scope chain lookup crosses non-cacheable object");
32589: 
32589:             // We must guard on the shape of all call objects for heavyweight functions
32589:             // that we traverse on the scope chain: if the shape changes, a variable with
32589:             // the same name may have been inserted in the scope chain.
38497:             if (obj->getClass() == &js_CallClass &&
32589:                 JSFUN_HEAVYWEIGHT_TEST(js_GetCallObjectFunction(obj)->flags)) {
32589:                 LIns* map_ins = map(obj_ins);
40353:                 LIns* shape_ins = addName(lir->insLoad(LIR_ld, map_ins, offsetof(JSScope, shape),
40353:                                                        ACC_OTHER),
32589:                                           "obj_shape");
32761:                 if (!exit)
32761:                     exit = snapshot(BRANCH_EXIT);
32589:                 guard(true,
32589:                       addName(lir->ins2i(LIR_eq, shape_ins, OBJ_SHAPE(obj)), "guard_shape"),
32761:                       exit);
32589:             }
32589:         }
32589: 
38497:         JS_ASSERT(obj->getClass() != &js_BlockClass);
36362: 
36362:         if (obj == targetObj)
32589:             break;
32589: 
39930:         obj = obj->getParent();
32589:         obj_ins = stobj_get_parent(obj_ins);
32589:     }
32589: 
36362:     targetIns = obj_ins;
33542:     return RECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_BINDNAME()
17409: {
27638:     JSStackFrame *fp = cx->fp;
27881:     JSObject *obj;
27638: 
32589:     if (!fp->fun) {
27881:         obj = fp->scopeChain;
27638: 
32589:         // In global code, fp->scopeChain can only contain blocks whose values
32589:         // are still on the stack.  We never use BINDNAME to refer to these.
39930:         while (obj->getClass() == &js_BlockClass) {
27638:             // The block's values are still on the stack.
32684:             JS_ASSERT(obj->getPrivate() == fp);
39930:             obj = obj->getParent();
27638:             // Blocks always have parents.
27881:             JS_ASSERT(obj);
27881:         }
32589: 
32589:         if (obj != globalObj)
33542:             RETURN_STOP_A("BINDNAME in global code resolved to non-global object");
31061: 
31061:         /*
30860:          * The trace is specialized to this global object. Furthermore, we know it
30860:          * is the sole 'global' object on the scope chain: we set globalObj to the
30860:          * scope chain element with no parent, and we reached it starting from the
30860:          * function closure or the current scopeChain, so there is nothing inner to
30860:          * it. Therefore this must be the right base object.
30860:          */
31843:         stack(0, INS_CONSTOBJ(obj));
33542:         return ARECORD_CONTINUE;
27933:     }
27933: 
32589:     // We can't trace BINDNAME in functions that contain direct calls to eval,
32589:     // as they might add bindings which previously-traced references would have
32589:     // to see.
32589:     if (JSFUN_HEAVYWEIGHT_TEST(fp->fun->flags))
33542:         RETURN_STOP_A("BINDNAME in heavyweight function.");
32589: 
32589:     // We don't have the scope chain on trace, so instead we get a start object
32589:     // that is on the scope chain and doesn't skip the target object (the one
32589:     // that contains the property).
32589:     jsval *callee = &cx->fp->argv[-2];
39930:     obj = JSVAL_TO_OBJECT(*callee)->getParent();
32589:     if (obj == globalObj) {
32589:         stack(0, INS_CONSTOBJ(obj));
33542:         return ARECORD_CONTINUE;
32589:     }
32589:     LIns *obj_ins = stobj_get_parent(get(callee));
32589: 
32589:     // Find the target object.
32589:     JSAtom *atom = atoms[GET_INDEX(cx->fp->regs->pc)];
32589:     jsid id = ATOM_TO_JSID(atom);
32589:     JSObject *obj2 = js_FindIdentifierBase(cx, fp->scopeChain, id);
38497:     if (obj2 != globalObj && obj2->getClass() != &js_CallClass)
33542:         RETURN_STOP_A("BINDNAME on non-global, non-call object");
32589: 
32589:     // Generate LIR to get to the target object from the start object.
32589:     LIns *obj2_ins;
33542:     CHECK_STATUS_A(traverseScopeChain(obj, obj_ins, obj2, obj2_ins));
32589: 
32589:     // If |obj2| is the global object, we can refer to it directly instead of walking up
32589:     // the scope chain. There may still be guards on intervening call objects.
32589:     stack(0, obj2 == globalObj ? INS_CONSTOBJ(obj2) : obj2_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_SETNAME()
17409: {
17545:     jsval& l = stackval(-2);
18085:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(l));
17519: 
17541:     /*
30848:      * Trace only cases that are global code, in lightweight functions
30848:      * scoped by the global object only, or in call objects.
17541:      */
17541:     JSObject* obj = JSVAL_TO_OBJECT(l);
30848:     if (OBJ_GET_CLASS(cx, obj) == &js_CallClass)
33542:         return ARECORD_CONTINUE;
17657:     if (obj != cx->fp->scopeChain || obj != globalObj)
33542:         RETURN_STOP_A("JSOP_SETNAME left operand is not the global object");
19093: 
19093:     // The rest of the work is in record_SetPropHit.
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_THROW()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_IN()
17409: {
18495:     jsval& rval = stackval(-1);
21784:     jsval& lval = stackval(-2);
21784: 
18495:     if (JSVAL_IS_PRIMITIVE(rval))
33542:         RETURN_STOP_A("JSOP_IN on non-object right operand");
21784:     JSObject* obj = JSVAL_TO_OBJECT(rval);
21784:     LIns* obj_ins = get(&rval);
18495: 
18495:     jsid id;
21784:     LIns* x;
18495:     if (JSVAL_IS_INT(lval)) {
18495:         id = INT_JSVAL_TO_JSID(lval);
21784:         LIns* args[] = { makeNumberInt32(get(&lval)), obj_ins, cx_ins };
21784:         x = lir->insCall(&js_HasNamedPropertyInt32_ci, args);
21784:     } else if (JSVAL_IS_STRING(lval)) {
21784:         if (!js_ValueToStringId(cx, lval, &id))
33542:             RETURN_ERROR_A("left operand of JSOP_IN didn't convert to a string-id");
21784:         LIns* args[] = { get(&lval), obj_ins, cx_ins };
21784:         x = lir->insCall(&js_HasNamedProperty_ci, args);
18495:     } else {
33542:         RETURN_STOP_A("string or integer expected");
21784:     }
21784: 
31521:     guard(false, lir->ins2i(LIR_eq, x, JSVAL_TO_SPECIAL(JSVAL_VOID)), OOM_EXIT);
21784:     x = lir->ins2i(LIR_eq, x, 1);
18495: 
37741:     TraceMonitor &localtm = *traceMonitor;
33171:     JSContext *localcx = cx;
33171: 
18495:     JSObject* obj2;
18495:     JSProperty* prop;
39928:     JSBool ok = obj->lookupProperty(cx, id, &obj2, &prop);
33171: 
33171:     /* lookupProperty can reenter the interpreter and kill |this|. */
33171:     if (!localtm.recorder) {
33171:         if (prop)
33171:             obj2->dropProperty(localcx, prop);
33542:         return ARECORD_STOP;
33171:     }
33171: 
33171:     if (!ok)
33542:         RETURN_ERROR_A("obj->lookupProperty failed in JSOP_IN");
21784:     bool cond = prop != NULL;
18495:     if (prop)
31501:         obj2->dropProperty(cx, prop);
18495: 
30860:     /*
30860:      * The interpreter fuses comparisons and the following branch, so we have
30860:      * to do that here as well.
30860:      */
18694:     fuseIf(cx->fp->regs->pc + 1, cond, x);
18495: 
30860:     /*
30860:      * We update the stack after the guard. This is safe since the guard bails
30860:      * out at the comparison and the interpreter will therefore re-execute the
30860:      * comparison. This way the value of the condition doesn't have to be
30860:      * calculated and saved on the stack in most cases.
30860:      */
18495:     set(&lval, x);
33542:     return ARECORD_CONTINUE;
27933: }
27933: 
31830: static JSBool FASTCALL
31830: HasInstance(JSContext* cx, JSObject* ctor, jsval val)
31830: {
31524:     JSBool result = JS_FALSE;
31830:     if (!ctor->map->ops->hasInstance(cx, ctor, val, &result))
37741:         SetBuiltinError(cx);
29363:     return result;
29363: }
39910: JS_DEFINE_CALLINFO_3(static, BOOL_FAIL, HasInstance, CONTEXT, OBJECT, JSVAL, 0, ACC_STORE_ANY)
29363: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INSTANCEOF()
17409: {
31830:     // If the rhs isn't an object, we are headed for a TypeError.
31830:     jsval& ctor = stackval(-1);
31830:     if (JSVAL_IS_PRIMITIVE(ctor))
33542:         RETURN_STOP_A("non-object on rhs of instanceof");
31830: 
31830:     jsval& val = stackval(-2);
31902:     LIns* val_ins = box_jsval(val, get(&val));
31830: 
31830:     enterDeepBailCall();
31830:     LIns* args[] = {val_ins, get(&ctor), cx_ins};
31830:     stack(-2, lir->insCall(&HasInstance_ci, args));
31830:     LIns* status_ins = lir->insLoad(LIR_ld,
31830:                                     lirbuf->state,
40353:                                     offsetof(InterpState, builtinStatus), ACC_OTHER);
33180:     pendingGuardCondition = lir->ins_eq0(status_ins);
31830:     leaveDeepBailCall();
31830: 
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DEBUGGER()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GOSUB()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_RETSUB()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_EXCEPTION()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LINENO()
17409: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_CONDSWITCH()
17409: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_CASE()
17409: {
23093:     strictEquality(true, true);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DEFAULT()
17409: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_EVAL()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ENUMELEM()
17409: {
35466:     /*
35466:      * To quote from jsops.cpp's JSOP_ENUMELEM case:
35466:      * Funky: the value to set is under the [obj, id] pair.
35466:      */
35466:     return setElem(-2, -1, -3);
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GETTER()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_SETTER()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DEFFUN()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
27012: TraceRecorder::record_JSOP_DEFFUN_FC()
27012: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DEFCONST()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DEFVAR()
17409: {
33542:     return ARECORD_STOP;
17409: }
17926: 
27012: jsatomid
27012: TraceRecorder::getFullIndex(ptrdiff_t pcoff)
27012: {
27012:     jsatomid index = GET_INDEX(cx->fp->regs->pc + pcoff);
27012:     index += atoms - cx->fp->script->atomMap.vector;
27012:     return index;
27012: }
27012: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
27012: TraceRecorder::record_JSOP_LAMBDA()
17409: {
17763:     JSFunction* fun;
32723:     fun = cx->fp->script->getFunction(getFullIndex());
27012: 
33139:     /*
33139:      * Emit code to clone a null closure parented by this recorder's global
33139:      * object, in order to preserve function object evaluation rules observable
33139:      * via identity and mutation. But don't clone if our result is consumed by
33139:      * JSOP_SETMETHOD or JSOP_INITMETHOD, since we optimize away the clone for
33139:      * these combinations and clone only if the "method value" escapes.
35018:      *
35018:      * See jsops.cpp, the JSOP_LAMBDA null closure case. The JSOP_SETMETHOD and
35018:      * JSOP_INITMETHOD logic governing the early ARECORD_CONTINUE returns below
35018:      * must agree with the corresponding break-from-do-while(0) logic there.
33139:      */
37694:     if (FUN_NULL_CLOSURE(fun)) {
39930:         if (FUN_OBJECT(fun)->getParent() != globalObj)
37694:             RETURN_STOP_A("Null closure function object parent must be global object");
33139:         JSOp op2 = JSOp(cx->fp->regs->pc[JSOP_LAMBDA_LENGTH]);
33139: 
35018:         if (op2 == JSOP_SETMETHOD) {
35018:             jsval lval = stackval(-1);
35018: 
35018:             if (!JSVAL_IS_PRIMITIVE(lval) &&
35018:                 OBJ_GET_CLASS(cx, JSVAL_TO_OBJECT(lval)) == &js_ObjectClass) {
35018:                 stack(0, INS_CONSTOBJ(FUN_OBJECT(fun)));
35018:                 return ARECORD_CONTINUE;
35018:             }
35018:         } else if (op2 == JSOP_INITMETHOD) {
33139:             stack(0, INS_CONSTOBJ(FUN_OBJECT(fun)));
33542:             return ARECORD_CONTINUE;
33139:         }
33139: 
27012:         LIns *proto_ins;
33542:         CHECK_STATUS_A(getClassPrototype(JSProto_Function, proto_ins));
27012: 
31843:         LIns* args[] = { INS_CONSTOBJ(globalObj), proto_ins, INS_CONSTFUN(fun), cx_ins };
27012:         LIns* x = lir->insCall(&js_NewNullClosure_ci, args);
27012:         stack(0, x);
33542:         return ARECORD_CONTINUE;
33542:     }
37694: 
38508:     LIns *proto_ins;
38508:     CHECK_STATUS_A(getClassPrototype(JSProto_Function, proto_ins));
37694:     LIns* scopeChain_ins = scopeChain();
37694:     JS_ASSERT(scopeChain_ins);
38508:     LIns* args[] = { proto_ins, scopeChain_ins, INS_CONSTPTR(fun), cx_ins };
37694:     LIns* call_ins = lir->insCall(&js_CloneFunctionObject_ci, args);
37694:     guard(false,
37694:           addName(lir->ins_peq0(call_ins), "guard(js_CloneFunctionObject)"),
37694:           OOM_EXIT);
37694:     stack(0, call_ins);
37694: 
37694:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
27012: TraceRecorder::record_JSOP_LAMBDA_FC()
27012: {
28923:     JSFunction* fun;
32723:     fun = cx->fp->script->getFunction(getFullIndex());
28923: 
39930:     if (FUN_OBJECT(fun)->getParent() != globalObj)
35065:         return ARECORD_STOP;
33607: 
28923:     LIns* args[] = {
38549:         scopeChain(),
31843:         INS_CONSTFUN(fun),
28923:         cx_ins
28923:     };
28923:     LIns* call_ins = lir->insCall(&js_AllocFlatClosure_ci, args);
28923:     guard(false,
32746:           addName(lir->ins2(LIR_peq, call_ins, INS_NULL()),
28923:                   "guard(js_AllocFlatClosure)"),
28923:           OOM_EXIT);
28923: 
31837:     if (fun->u.i.nupvars) {
32723:         JSUpvarArray *uva = fun->u.i.script->upvars();
28923:         for (uint32 i = 0, n = uva->length; i < n; i++) {
28923:             jsval v;
28923:             LIns* upvar_ins = upvar(fun->u.i.script, uva, i, v);
28923:             if (!upvar_ins)
33542:                 return ARECORD_STOP;
28923:             LIns* dslots_ins = NULL;
31902:             stobj_set_dslot(call_ins, i, dslots_ins, box_jsval(v, upvar_ins));
28923:         }
31834:     }
28923: 
32764:     stack(0, call_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
27012: TraceRecorder::record_JSOP_CALLEE()
27012: {
28557:     stack(0, get(&cx->fp->argv[-2]));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18020: TraceRecorder::record_JSOP_SETLOCALPOP()
18020: {
20394:     var(GET_SLOTNO(cx->fp->regs->pc), stack(-1));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
23075: TraceRecorder::record_JSOP_IFPRIMTOP()
23075: {
23075:     // Traces are type-specialized, including null vs. object, so we need do
23075:     // nothing here. The upstream unbox_jsval called after valueOf or toString
23075:     // from an imacro (e.g.) will fork the trace for us, allowing us to just
23075:     // follow along mindlessly :-).
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18020: TraceRecorder::record_JSOP_SETCALL()
18020: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18020: TraceRecorder::record_JSOP_TRY()
18020: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18020: TraceRecorder::record_JSOP_FINALLY()
18020: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18020: TraceRecorder::record_JSOP_NOP()
18020: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18020: TraceRecorder::record_JSOP_ARGSUB()
18020: {
19068:     JSStackFrame* fp = cx->fp;
19068:     if (!(fp->fun->flags & JSFUN_HEAVYWEIGHT)) {
19068:         uintN slot = GET_ARGNO(fp->regs->pc);
30248:         if (slot < fp->argc)
19068:             stack(0, get(&cx->fp->argv[slot]));
30248:         else
30248:             stack(0, INS_VOID());
33542:         return ARECORD_CONTINUE;
33542:     }
33542:     RETURN_STOP_A("can't trace JSOP_ARGSUB hard case");
33542: }
33542: 
37214: JS_REQUIRES_STACK LIns*
37214: TraceRecorder::guardArgsLengthNotAssigned(LIns* argsobj_ins)
37214: {
40405:     // The following implements IsOverriddenArgsLength on trace.
37214:     // The '2' bit is set if length was overridden.
37214:     LIns *len_ins = stobj_get_fslot(argsobj_ins, JSSLOT_ARGS_LENGTH);
37214:     LIns *ovr_ins = lir->ins2(LIR_piand, len_ins, INS_CONSTWORD(2));
37214:     guard(true, lir->ins_peq0(ovr_ins), snapshot(BRANCH_EXIT));
37214:     return len_ins;
37214: }
37214: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18020: TraceRecorder::record_JSOP_ARGCNT()
18020: {
33111:     if (cx->fp->fun->flags & JSFUN_HEAVYWEIGHT)
33542:         RETURN_STOP_A("can't trace heavyweight JSOP_ARGCNT");
33111: 
33111:     // argc is fixed on trace, so ideally we would simply generate LIR for
33111:     // constant argc. But the user can mutate arguments.length in the
33111:     // interpreter, so we have to check for that in the trace entry frame.
33113:     // We also have to check that arguments.length has not been mutated
33113:     // at record time, because if so we will generate incorrect constant
33113:     // LIR, which will assert in alu().
40405:     if (cx->fp->argsobj && IsOverriddenArgsLength(JSVAL_TO_OBJECT(cx->fp->argsobj)))
33542:         RETURN_STOP_A("can't trace JSOP_ARGCNT if arguments.length has been modified");
33111:     LIns *a_ins = get(&cx->fp->argsobj);
33111:     if (callDepth == 0) {
33111:         LIns *br = lir->insBranch(LIR_jt, lir->ins_peq0(a_ins), NULL);
37214:         guardArgsLengthNotAssigned(a_ins);
33111:         LIns *label = lir->ins0(LIR_label);
33111:         br->setTarget(label);
33111:     }
26265:     stack(0, lir->insImmf(cx->fp->argc));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
19970: TraceRecorder::record_DefLocalFunSetSlot(uint32 slot, JSObject* obj)
19970: {
27012:     JSFunction* fun = GET_FUNCTION_PRIVATE(cx, obj);
27012: 
39930:     if (FUN_NULL_CLOSURE(fun) && FUN_OBJECT(fun)->getParent() == globalObj) {
27012:         LIns *proto_ins;
33542:         CHECK_STATUS_A(getClassPrototype(JSProto_Function, proto_ins));
27012: 
31843:         LIns* args[] = { INS_CONSTOBJ(globalObj), proto_ins, INS_CONSTFUN(fun), cx_ins };
27012:         LIns* x = lir->insCall(&js_NewNullClosure_ci, args);
27012:         var(slot, x);
33542:         return ARECORD_CONTINUE;
33542:     }
33542: 
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18020: TraceRecorder::record_JSOP_DEFLOCALFUN()
18020: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
27012: TraceRecorder::record_JSOP_DEFLOCALFUN_FC()
27012: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GOTOX()
17409: {
26557:     return record_JSOP_GOTO();
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_IFEQX()
17409: {
17611:     return record_JSOP_IFEQ();
17611: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_IFNEX()
17409: {
17611:     return record_JSOP_IFNE();
17611: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ORX()
17409: {
17611:     return record_JSOP_OR();
17611: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ANDX()
17409: {
17611:     return record_JSOP_AND();
17611: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GOSUBX()
17409: {
17611:     return record_JSOP_GOSUB();
17611: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_CASEX()
17409: {
23093:     strictEquality(true, true);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DEFAULTX()
17409: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TABLESWITCHX()
17409: {
26557:     return record_JSOP_TABLESWITCH();
17611: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LOOKUPSWITCHX()
17409: {
33542:     return InjectStatus(switchop());
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_BACKPATCH()
17409: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_BACKPATCH_POP()
17409: {
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_THROWING()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_SETRVAL()
17409: {
17844:     // If we implement this, we need to update JSOP_STOP.
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_RETRVAL()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GETGVAR()
17409: {
17807:     jsval slotval = cx->fp->slots[GET_SLOTNO(cx->fp->regs->pc)];
17468:     if (JSVAL_IS_NULL(slotval))
33542:         return ARECORD_CONTINUE; // We will see JSOP_NAME from the interpreter's jump, so no-op here.
17545: 
17468:     uint32 slot = JSVAL_TO_INT(slotval);
17891: 
17892:     if (!lazilyImportGlobalSlot(slot))
33542:          RETURN_STOP_A("lazy import of global slot failed");
17891: 
40410:     stack(0, get(&globalObj->getSlotRef(slot)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_SETGVAR()
17409: {
17807:     jsval slotval = cx->fp->slots[GET_SLOTNO(cx->fp->regs->pc)];
17494:     if (JSVAL_IS_NULL(slotval))
33542:         return ARECORD_CONTINUE; // We will see JSOP_NAME from the interpreter's jump, so no-op here.
17545: 
17494:     uint32 slot = JSVAL_TO_INT(slotval);
17891: 
17892:     if (!lazilyImportGlobalSlot(slot))
33542:          RETURN_STOP_A("lazy import of global slot failed");
17891: 
40410:     set(&globalObj->getSlotRef(slot), stack(-1));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INCGVAR()
17409: {
17807:     jsval slotval = cx->fp->slots[GET_SLOTNO(cx->fp->regs->pc)];
17468:     if (JSVAL_IS_NULL(slotval))
27933:         // We will see JSOP_INCNAME from the interpreter's jump, so no-op here.
33542:         return ARECORD_CONTINUE;
17545: 
17468:     uint32 slot = JSVAL_TO_INT(slotval);
17891: 
17892:     if (!lazilyImportGlobalSlot(slot))
33542:          RETURN_STOP_A("lazy import of global slot failed");
33542: 
40410:     return InjectStatus(inc(globalObj->getSlotRef(slot), 1));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DECGVAR()
17409: {
17807:     jsval slotval = cx->fp->slots[GET_SLOTNO(cx->fp->regs->pc)];
17494:     if (JSVAL_IS_NULL(slotval))
27933:         // We will see JSOP_INCNAME from the interpreter's jump, so no-op here.
33542:         return ARECORD_CONTINUE;
17545: 
17494:     uint32 slot = JSVAL_TO_INT(slotval);
17891: 
17892:     if (!lazilyImportGlobalSlot(slot))
33542:          RETURN_STOP_A("lazy import of global slot failed");
33542: 
40410:     return InjectStatus(inc(globalObj->getSlotRef(slot), -1));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GVARINC()
17409: {
17807:     jsval slotval = cx->fp->slots[GET_SLOTNO(cx->fp->regs->pc)];
17494:     if (JSVAL_IS_NULL(slotval))
27933:         // We will see JSOP_INCNAME from the interpreter's jump, so no-op here.
33542:         return ARECORD_CONTINUE;
17545: 
17494:     uint32 slot = JSVAL_TO_INT(slotval);
17891: 
17892:     if (!lazilyImportGlobalSlot(slot))
33542:          RETURN_STOP_A("lazy import of global slot failed");
33542: 
40410:     return InjectStatus(inc(globalObj->getSlotRef(slot), 1, false));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GVARDEC()
17409: {
17807:     jsval slotval = cx->fp->slots[GET_SLOTNO(cx->fp->regs->pc)];
17494:     if (JSVAL_IS_NULL(slotval))
27933:         // We will see JSOP_INCNAME from the interpreter's jump, so no-op here.
33542:         return ARECORD_CONTINUE;
17545: 
17494:     uint32 slot = JSVAL_TO_INT(slotval);
17891: 
17892:     if (!lazilyImportGlobalSlot(slot))
33542:          RETURN_STOP_A("lazy import of global slot failed");
33542: 
40410:     return InjectStatus(inc(globalObj->getSlotRef(slot), -1, false));
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_REGEXP()
17409: {
38500:     JSStackFrame* fp = cx->fp;
38500:     JSScript* script = fp->script;
38500:     unsigned index = atoms - script->atomMap.vector + GET_INDEX(fp->regs->pc);
38500: 
38508:     LIns* proto_ins;
38508:     CHECK_STATUS_A(getClassPrototype(JSProto_RegExp, proto_ins));
38508: 
38500:     LIns* args[] = {
38508:         proto_ins,
38500:         INS_CONSTOBJ(script->getRegExp(index)),
38500:         cx_ins
38500:     };
38500:     LIns* regex_ins = lir->insCall(&js_CloneRegExpObject_ci, args);
38500:     guard(false, lir->ins_peq0(regex_ins), OOM_EXIT);
38500: 
38500:     stack(0, regex_ins);
38500:     return ARECORD_CONTINUE;
17409: }
17926: 
17926: // begin JS_HAS_XML_SUPPORT
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DEFXMLNS()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ANYNAME()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_QNAMEPART()
17409: {
24625:     return record_JSOP_STRING();
17409: }
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_QNAMECONST()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_QNAME()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TOATTRNAME()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TOATTRVAL()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ADDATTRNAME()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ADDATTRVAL()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_BINDXMLNAME()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_SETXMLNAME()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_XMLNAME()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DESCENDANTS()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_FILTER()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ENDFILTER()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TOXML()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TOXMLLIST()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_XMLTAGEXPR()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_XMLELTEXPR()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_XMLOBJECT()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_XMLCDATA()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_XMLCOMMENT()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_XMLPI()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GETFUNNS()
17926: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_STARTXML()
17926: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_STARTXMLEXPR()
17926: {
33542:     return ARECORD_STOP;
17926: }
17926: 
17926: // end JS_HAS_XML_SUPPORT
17926: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_CALLPROP()
17409: {
17630:     jsval& l = stackval(-1);
17870:     JSObject* obj;
17870:     LIns* obj_ins;
20427:     LIns* this_ins;
17870:     if (!JSVAL_IS_PRIMITIVE(l)) {
17870:         obj = JSVAL_TO_OBJECT(l);
17870:         obj_ins = get(&l);
20427:         this_ins = obj_ins; // |this| for subsequent call
17870:     } else {
38604:         JSProtoKey protoKey;
29883:         debug_only_stmt(const char* protoname = NULL;)
17870:         if (JSVAL_IS_STRING(l)) {
38604:             protoKey = JSProto_String;
29883:             debug_only_stmt(protoname = "String.prototype";)
17870:         } else if (JSVAL_IS_NUMBER(l)) {
38604:             protoKey = JSProto_Number;
29883:             debug_only_stmt(protoname = "Number.prototype";)
31521:         } else if (JSVAL_IS_SPECIAL(l)) {
19995:             if (l == JSVAL_VOID)
33542:                 RETURN_STOP_A("callprop on void");
31521:             guard(false, lir->ins2i(LIR_eq, get(&l), JSVAL_TO_SPECIAL(JSVAL_VOID)), MISMATCH_EXIT);
38604:             protoKey = JSProto_Boolean;
29883:             debug_only_stmt(protoname = "Boolean.prototype";)
17870:         } else {
17870:             JS_ASSERT(JSVAL_IS_NULL(l) || JSVAL_IS_VOID(l));
33542:             RETURN_STOP_A("callprop on null or void");
17870:         }
17870: 
38604:         if (!js_GetClassPrototype(cx, NULL, protoKey, &obj))
33542:             RETURN_ERROR_A("GetClassPrototype failed!");
17870: 
31843:         obj_ins = INS_CONSTOBJ(obj);
29883:         debug_only_stmt(obj_ins = addName(obj_ins, protoname);)
20427:         this_ins = get(&l); // use primitive as |this|
17870:     }
17870: 
17632:     JSObject* obj2;
40374:     PCVal pcval;
33542:     CHECK_STATUS_A(test_property_cache(obj, obj_ins, obj2, pcval));
17998: 
40374:     if (pcval.isObject()) {
40374:         if (pcval.isNull())
37685:             RETURN_STOP_A("callprop of missing method");
37685: 
40430:         JS_ASSERT(pcval.toObject()->isFunction());
17630: 
19054:         if (JSVAL_IS_PRIMITIVE(l)) {
40374:             JSFunction* fun = GET_FUNCTION_PRIVATE(cx, pcval.toObject());
19054:             if (!PRIMITIVE_THIS_TEST(fun, l))
33542:                 RETURN_STOP_A("callee does not accept primitive |this|");
19054:         }
19054: 
40374:         set(&l, INS_CONSTOBJ(pcval.toObject()));
37685:     } else {
37685:         if (JSVAL_IS_PRIMITIVE(l))
37685:             RETURN_STOP_A("callprop of primitive method");
37685: 
40374:         JS_ASSERT_IF(pcval.isSprop(), !pcval.toSprop()->isMethod());
37685: 
37685:         AbortableRecordingStatus status = propTail(obj, obj_ins, obj2, pcval, NULL, NULL, &l);
37685:         if (status != ARECORD_CONTINUE)
37685:             return status;
37685:     }
20427:     stack(0, this_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_DELDESC()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_UINT24()
17409: {
26265:     stack(0, lir->insImmf(GET_UINT24(cx->fp->regs->pc)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INDEXBASE()
17611: {
17611:     atoms += GET_INDEXBASE(cx->fp->regs->pc);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_RESETBASE()
17611: {
17611:     atoms = cx->fp->script->atomMap.vector;
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_RESETBASE0()
17611: {
17611:     atoms = cx->fp->script->atomMap.vector;
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_CALLELEM()
17409: {
26551:     return record_JSOP_GETELEM();
17409: }
17611: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_STOP()
17611: {
39939:     if (callDepth == 0 && IsTraceableRecursion(cx) &&
39939:         tree->recursion != Recursion_Disallowed &&
39939:         tree->script == cx->fp->script) {
39939:         return InjectStatus(upRecursion());
39939:     }
21685:     JSStackFrame *fp = cx->fp;
21685: 
21685:     if (fp->imacpc) {
30860:         /*
30860:          * End of imacro, so return true to the interpreter immediately. The
30860:          * interpreter's JSOP_STOP case will return from the imacro, back to
30860:          * the pc after the calling op, still in the same JSStackFrame.
30860:          */
21721:         atoms = fp->script->atomMap.vector;
33542:         return ARECORD_CONTINUE;
21685:     }
21685: 
37694:     putActivationObjects();
31847: 
18001:     /*
18001:      * We know falling off the end of a constructor returns the new object that
18001:      * was passed in via fp->argv[-1], while falling off the end of a function
18001:      * returns undefined.
18001:      *
18001:      * NB: we do not support script rval (eval, API users who want the result
18001:      * of the last expression-statement, debugger API calls).
18001:      */
18001:     if (fp->flags & JSFRAME_CONSTRUCTING) {
32774:         JS_ASSERT(fp->thisv == fp->argv[-1]);
18001:         rval_ins = get(&fp->argv[-1]);
18001:     } else {
40307:         rval_ins = INS_VOID();
18001:     }
37009:     clearCurrentFrameSlotsFromTracker(nativeFrameTracker);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GETXPROP()
17409: {
17686:     jsval& l = stackval(-1);
17686:     if (JSVAL_IS_PRIMITIVE(l))
33542:         RETURN_STOP_A("primitive-this for GETXPROP?");
17686: 
18096:     jsval* vp;
30647:     LIns* v_ins;
31075:     NameResult nr;
33542:     CHECK_STATUS_A(name(vp, v_ins, nr));
30647:     stack(-1, v_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_CALLXMLNAME()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_TYPEOFEXPR()
17409: {
18019:     return record_JSOP_TYPEOF();
17409: }
17611: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ENTERBLOCK()
17409: {
22907:     JSObject* obj;
32723:     obj = cx->fp->script->getObject(getFullIndex(0));
22907: 
40307:     LIns* void_ins = INS_VOID();
22907:     for (int i = 0, n = OBJ_BLOCK_COUNT(cx, obj); i < n; i++)
22907:         stack(i, void_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LEAVEBLOCK()
17409: {
26238:     /* We mustn't exit the lexical block we began recording in. */
38560:     if (cx->fp->blockChain == lexicalBlock)
38560:         return ARECORD_STOP;
38560:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_GENERATOR()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_YIELD()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ARRAYPUSH()
17409: {
24861:     uint32_t slot = GET_UINT16(cx->fp->regs->pc);
24861:     JS_ASSERT(cx->fp->script->nfixed <= slot);
24861:     JS_ASSERT(cx->fp->slots + slot < cx->fp->regs->sp - 1);
24861:     jsval &arrayval = cx->fp->slots[slot];
24861:     JS_ASSERT(JSVAL_IS_OBJECT(arrayval));
39928:     JS_ASSERT(JSVAL_TO_OBJECT(arrayval)->isDenseArray());
24861:     LIns *array_ins = get(&arrayval);
24861:     jsval &elt = stackval(-1);
31902:     LIns *elt_ins = box_jsval(elt, get(&elt));
24861: 
24861:     LIns *args[] = { elt_ins, array_ins, cx_ins };
24861:     LIns *ok_ins = lir->insCall(&js_ArrayCompPush_ci, args);
24861:     guard(false, lir->ins_eq0(ok_ins), OOM_EXIT);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_ENUMCONSTELEM()
17409: {
33542:     return ARECORD_STOP;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LEAVEBLOCKEXPR()
17409: {
22907:     LIns* v_ins = stack(-1);
22907:     int n = -1 - GET_UINT16(cx->fp->regs->pc);
22907:     stack(n, v_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GETTHISPROP()
17409: {
17688:     LIns* this_ins;
17758: 
33542:     CHECK_STATUS_A(getThis(this_ins));
30860: 
30860:     /*
32774:      * It's safe to just use cx->fp->thisv here because getThis() returns
33542:      * ARECORD_STOP if thisv is not available.
32774:      */
32774:     JS_ASSERT(cx->fp->flags & JSFRAME_COMPUTED_THIS);
33542:     CHECK_STATUS_A(getProp(JSVAL_TO_OBJECT(cx->fp->thisv), this_ins));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_GETARGPROP()
17409: {
17688:     return getProp(argval(GET_ARGNO(cx->fp->regs->pc)));
17409: }
17611: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_GETLOCALPROP()
17409: {
17807:     return getProp(varval(GET_SLOTNO(cx->fp->regs->pc)));
17409: }
17611: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INDEXBASE1()
17611: {
17611:     atoms += 1 << 16;
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INDEXBASE2()
17611: {
17611:     atoms += 2 << 16;
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INDEXBASE3()
17611: {
17611:     atoms += 3 << 16;
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_CALLGVAR()
17409: {
18003:     jsval slotval = cx->fp->slots[GET_SLOTNO(cx->fp->regs->pc)];
18003:     if (JSVAL_IS_NULL(slotval))
27933:         // We will see JSOP_CALLNAME from the interpreter's jump, so no-op here.
33542:         return ARECORD_CONTINUE;
18003: 
18003:     uint32 slot = JSVAL_TO_INT(slotval);
18003: 
18003:     if (!lazilyImportGlobalSlot(slot))
33542:          RETURN_STOP_A("lazy import of global slot failed");
18003: 
40410:     jsval& v = globalObj->getSlotRef(slot);
18031:     stack(0, get(&v));
31843:     stack(1, INS_NULL());
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
18005: TraceRecorder::record_JSOP_CALLLOCAL()
17409: {
18003:     uintN slot = GET_SLOTNO(cx->fp->regs->pc);
18003:     stack(0, var(slot));
31843:     stack(1, INS_NULL());
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_CALLARG()
17409: {
18003:     uintN slot = GET_ARGNO(cx->fp->regs->pc);
18003:     stack(0, arg(slot));
31843:     stack(1, INS_NULL());
33542:     return ARECORD_CONTINUE;
17409: }
17611: 
24384: /* Functions for use with JSOP_CALLBUILTIN. */
24384: 
24384: static JSBool
24384: ObjectToIterator(JSContext *cx, uintN argc, jsval *vp)
24384: {
24384:     jsval *argv = JS_ARGV(cx, vp);
24384:     JS_ASSERT(JSVAL_IS_INT(argv[0]));
24384:     JS_SET_RVAL(cx, vp, JS_THIS(cx, vp));
24384:     return js_ValueToIterator(cx, JSVAL_TO_INT(argv[0]), &JS_RVAL(cx, vp));
24384: }
24384: 
24384: static JSObject* FASTCALL
24612: ObjectToIterator_tn(JSContext* cx, jsbytecode* pc, JSObject *obj, int32 flags)
24384: {
24384:     jsval v = OBJECT_TO_JSVAL(obj);
25628:     JSBool ok = js_ValueToIterator(cx, flags, &v);
24612: 
24612:     if (!ok) {
37741:         SetBuiltinError(cx);
24384:         return NULL;
24612:     }
24384:     return JSVAL_TO_OBJECT(v);
24384: }
24384: 
24384: static JSBool
24384: CallIteratorNext(JSContext *cx, uintN argc, jsval *vp)
24384: {
24384:     return js_CallIteratorNext(cx, JS_THIS_OBJECT(cx, vp), &JS_RVAL(cx, vp));
24384: }
24384: 
24384: static jsval FASTCALL
24612: CallIteratorNext_tn(JSContext* cx, jsbytecode* pc, JSObject* iterobj)
24384: {
40403:     AutoValueRooter tvr(cx);
25628:     JSBool ok = js_CallIteratorNext(cx, iterobj, tvr.addr());
24612: 
24612:     if (!ok) {
37741:         SetBuiltinError(cx);
24384:         return JSVAL_ERROR_COOKIE;
24612:     }
25094:     return tvr.value();
24384: }
24384: 
24384: JS_DEFINE_TRCINFO_1(ObjectToIterator,
39910:     (4, (static, OBJECT_FAIL, ObjectToIterator_tn, CONTEXT, PC, THIS, INT32, 0, ACC_STORE_ANY)))
24384: JS_DEFINE_TRCINFO_1(CallIteratorNext,
39910:     (3, (static, JSVAL_FAIL,  CallIteratorNext_tn, CONTEXT, PC, THIS,        0, ACC_STORE_ANY)))
24384: 
24384: static const struct BuiltinFunctionInfo {
32669:     JSNativeTraceInfo *ti;
24384:     int nargs;
24384: } builtinFunctionInfo[JSBUILTIN_LIMIT] = {
32669:     {&ObjectToIterator_trcinfo,   1},
32669:     {&CallIteratorNext_trcinfo,   0},
24384: };
24384: 
24384: JSObject *
37741: GetBuiltinFunction(JSContext *cx, uintN index)
24384: {
24384:     JSRuntime *rt = cx->runtime;
24384:     JSObject *funobj = rt->builtinFunctions[index];
24384: 
24384:     if (!funobj) {
24384:         /* Use NULL parent and atom. Builtin functions never escape to scripts. */
25218:         JS_ASSERT(index < JS_ARRAY_LENGTH(builtinFunctionInfo));
25218:         const BuiltinFunctionInfo *bfi = &builtinFunctionInfo[index];
24384:         JSFunction *fun = js_NewFunction(cx,
24384:                                          NULL,
32669:                                          JS_DATA_TO_FUNC_PTR(JSNative, bfi->ti),
25218:                                          bfi->nargs,
32669:                                          JSFUN_FAST_NATIVE | JSFUN_TRCINFO,
24384:                                          NULL,
24384:                                          NULL);
24384:         if (fun) {
24384:             funobj = FUN_OBJECT(fun);
39928:             funobj->clearProto();
39930:             funobj->clearParent();
24384: 
24384:             JS_LOCK_GC(rt);
24384:             if (!rt->builtinFunctions[index]) /* retest now that the lock is held */
24384:                 rt->builtinFunctions[index] = funobj;
24384:             else
24384:                 funobj = rt->builtinFunctions[index];
24384:             JS_UNLOCK_GC(rt);
24384:         }
24384:     }
24384:     return funobj;
24384: }
24384: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
24384: TraceRecorder::record_JSOP_CALLBUILTIN()
24384: {
37741:     JSObject *obj = GetBuiltinFunction(cx, GET_INDEX(cx->fp->regs->pc));
24384:     if (!obj)
33542:         RETURN_ERROR_A("error in js_GetBuiltinFunction");
24384: 
24384:     stack(0, get(&stackval(-1)));
31843:     stack(-1, INS_CONSTOBJ(obj));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INT8()
17409: {
26265:     stack(0, lir->insImmf(GET_INT8(cx->fp->regs->pc)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_INT32()
17409: {
26265:     stack(0, lir->insImmf(GET_INT32(cx->fp->regs->pc)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_LENGTH()
17409: {
17715:     jsval& l = stackval(-1);
17869:     if (JSVAL_IS_PRIMITIVE(l)) {
17869:         if (!JSVAL_IS_STRING(l))
33542:             RETURN_STOP_A("non-string primitive JSOP_LENGTH unsupported");
35470:         set(&l, lir->ins1(LIR_i2f,
35470:                           p2i(lir->insLoad(LIR_ldp, get(&l),
40353:                                            offsetof(JSString, mLength), ACC_OTHER))));
33542:         return ARECORD_CONTINUE;
17869:     }
17869: 
17869:     JSObject* obj = JSVAL_TO_OBJECT(l);
26285:     LIns* obj_ins = get(&l);
30248: 
40405:     if (obj->isArguments()) {
31460:         unsigned depth;
31460:         JSStackFrame *afp = guardArguments(obj, obj_ins, &depth);
31460:         if (!afp)
33542:             RETURN_STOP_A("can't reach arguments object's frame");
31460: 
37214:         // We must both check at record time and guard at run time that
37214:         // arguments.length has not been reassigned, redefined or deleted.
40405:         if (IsOverriddenArgsLength(obj))
37214:             RETURN_STOP_A("can't trace JSOP_ARGCNT if arguments.length has been modified");
37214:         LIns* slot_ins = guardArgsLengthNotAssigned(obj_ins);
37214: 
37214:         // slot_ins is the value from the slot; right-shift by 2 bits to get
37214:         // the length (see GetArgsLength in jsfun.cpp).
37324:         LIns* v_ins = lir->ins1(LIR_i2f, lir->ins2i(LIR_rsh, p2i(slot_ins), 2));
30248:         set(&l, v_ins);
33542:         return ARECORD_CONTINUE;
30248:     }
30248: 
26285:     LIns* v_ins;
39928:     if (obj->isArray()) {
39928:         if (obj->isDenseArray()) {
26565:             if (!guardDenseArray(obj, obj_ins, BRANCH_EXIT)) {
39928:                 JS_NOT_REACHED("obj->isDenseArray() but not?!?");
33542:                 return ARECORD_STOP;
26565:             }
26285:         } else {
40353:             if (!guardClass(obj, obj_ins, &js_SlowArrayClass, snapshot(BRANCH_EXIT), ACC_OTHER))
33542:                 RETURN_STOP_A("can't trace length property access on non-array");
26285:         }
40796:         v_ins = lir->ins1(LIR_i2f, p2i(stobj_get_fslot(obj_ins, JSObject::JSSLOT_ARRAY_LENGTH)));
37765:     } else if (OkToTraceTypedArrays && js_IsTypedArray(obj)) {
37765:         // Ensure array is a typed array and is the same type as what was written
40353:         guardClass(obj, obj_ins, obj->getClass(), snapshot(BRANCH_EXIT), ACC_OTHER);
39910:         v_ins = lir->ins1(LIR_i2f, lir->insLoad(LIR_ld,
37776:                                                 stobj_get_const_fslot(obj_ins, JSSLOT_PRIVATE),
39910:                                                 js::TypedArray::lengthOffset(), ACC_READONLY));
26285:     } else {
40430:         if (!obj->isNative())
33542:             RETURN_STOP_A("can't trace length property access on non-array, non-native object");
26285:         return getProp(obj, obj_ins);
26285:     }
17715:     set(&l, v_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_NEWARRAY()
17409: {
27012:     LIns *proto_ins;
33542:     CHECK_STATUS_A(getClassPrototype(JSProto_Array, proto_ins));
23708: 
27234:     uint32 len = GET_UINT16(cx->fp->regs->pc);
27234:     cx->fp->assertValidStackDepth(len);
27234: 
27012:     LIns* args[] = { lir->insImm(len), proto_ins, cx_ins };
33155:     LIns* v_ins = lir->insCall(&js_NewArrayWithSlots_ci, args);
32746:     guard(false, lir->ins_peq0(v_ins), OOM_EXIT);
23708: 
23708:     LIns* dslots_ins = NULL;
28274:     uint32 count = 0;
23708:     for (uint32 i = 0; i < len; i++) {
25628:         jsval& v = stackval(int(i) - int(len));
28274:         if (v != JSVAL_HOLE)
28274:             count++;
31902:         LIns* elt_ins = box_jsval(v, get(&v));
31849:         stobj_set_dslot(v_ins, i, dslots_ins, elt_ins);
23708:     }
23708: 
28274:     if (count > 0)
40796:         stobj_set_fslot(v_ins, JSObject::JSSLOT_ARRAY_COUNT, INS_CONST(count));
28274: 
25628:     stack(-int(len), v_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
17926: TraceRecorder::record_JSOP_HOLE()
17409: {
31521:     stack(0, INS_CONST(JSVAL_TO_SPECIAL(JSVAL_HOLE)));
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: AbortableRecordingStatus
32776: TraceRecorder::record_JSOP_TRACE()
25627: {
33542:     return ARECORD_CONTINUE;
25627: }
25627: 
32581: static const uint32 sMaxConcatNSize = 32;
32581: 
38641: JS_REQUIRES_STACK AbortableRecordingStatus
38641: TraceRecorder::record_JSOP_OBJTOSTR()
38641: {
38641:     jsval &v = stackval(-1);
38641:     JS_ASSERT_IF(cx->fp->imacpc, JSVAL_IS_PRIMITIVE(v) &&
38641:                                  *cx->fp->imacpc == JSOP_OBJTOSTR);
38641:     if (JSVAL_IS_PRIMITIVE(v))
38641:         return ARECORD_CONTINUE;
38641:     return InjectStatus(call_imacro(objtostr_imacros.toString));
38641: }
38641: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
32581: TraceRecorder::record_JSOP_CONCATN()
32581: {
32581:     JSStackFrame *fp = cx->fp;
32581:     JSFrameRegs &regs = *fp->regs;
38641:     uint32 argc = GET_ARGC(regs.pc);
38641:     jsval *argBase = regs.sp - argc;
32581: 
32581:     /* Prevent code/alloca explosion. */
32581:     if (argc > sMaxConcatNSize)
33542:         return ARECORD_STOP;
32581: 
32581:     /* Build an array of the stringified primitives. */
32581:     int32_t bufSize = argc * sizeof(JSString *);
32581:     LIns *buf_ins = lir->insAlloc(bufSize);
32581:     int32_t d = 0;
38641:     for (jsval *vp = argBase; vp != regs.sp; ++vp, d += sizeof(void *)) {
38641:         JS_ASSERT(JSVAL_IS_PRIMITIVE(*vp));
40353:         lir->insStorei(stringify(*vp), buf_ins, d, ACC_OTHER);
38641:     }
32581: 
32581:     /* Perform concatenation using a builtin. */
32581:     LIns *args[] = { lir->insImm(argc), buf_ins, cx_ins };
38641:     LIns *result_ins = lir->insCall(&js_ConcatN_ci, args);
38641:     guard(false, lir->ins_peq0(result_ins), OOM_EXIT);
32581: 
32581:     /* Update tracker with result. */
38641:     set(argBase, result_ins);
33542:     return ARECORD_CONTINUE;
33542: }
33542: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
32729: TraceRecorder::record_JSOP_SETMETHOD()
32729: {
32729:     return record_JSOP_SETPROP();
32729: }
32729: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
32729: TraceRecorder::record_JSOP_INITMETHOD()
32729: {
32729:     return record_JSOP_INITPROP();
32729: }
32729: 
37685: JSBool FASTCALL
37685: js_Unbrand(JSContext *cx, JSObject *obj)
37685: {
37685:     return obj->unbrand(cx);
37685: }
37685: 
39910: JS_DEFINE_CALLINFO_2(extern, BOOL, js_Unbrand, CONTEXT, OBJECT, 0, ACC_STORE_ANY)
37685: 
37685: JS_REQUIRES_STACK AbortableRecordingStatus
37685: TraceRecorder::record_JSOP_UNBRAND()
37685: {
37685:     LIns* args_ins[] = { stack(-1), cx_ins };
37685:     LIns* call_ins = lir->insCall(&js_Unbrand_ci, args_ins);
37685:     guard(true, call_ins, OOM_EXIT);
37685:     return ARECORD_CONTINUE;
37685: }
37685: 
33542: JS_REQUIRES_STACK AbortableRecordingStatus
38549: TraceRecorder::record_JSOP_UNBRANDTHIS()
38549: {
38549:     LIns* this_ins;
38549:     RecordingStatus status = getThis(this_ins);
38549:     if (status != RECORD_CONTINUE)
38549:         return InjectStatus(status);
38549: 
38549:     LIns* args_ins[] = { this_ins, cx_ins };
38549:     LIns* call_ins = lir->insCall(&js_Unbrand_ci, args_ins);
38549:     guard(true, call_ins, OOM_EXIT);
38549:     return ARECORD_CONTINUE;
38549: }
38549: 
38549: JS_REQUIRES_STACK AbortableRecordingStatus
32729: TraceRecorder::record_JSOP_SHARPINIT()
32729: {
33542:     return ARECORD_STOP;
32729: }
32729: 
28952: #define DBG_STUB(OP)                                                          \
33542:     JS_REQUIRES_STACK AbortableRecordingStatus                                \
28952:     TraceRecorder::record_##OP()                                              \
28952:     {                                                                         \
33542:         RETURN_STOP_A("can't trace " #OP);                                    \
28952:     }
28952: 
28952: DBG_STUB(JSOP_GETUPVAR_DBG)
28952: DBG_STUB(JSOP_CALLUPVAR_DBG)
28952: DBG_STUB(JSOP_DEFFUN_DBGFC)
28952: DBG_STUB(JSOP_DEFLOCALFUN_DBGFC)
28952: DBG_STUB(JSOP_LAMBDA_DBGFC)
28952: 
21459: #ifdef JS_JIT_SPEW
30860: /*
30860:  * Print information about entry typemaps and unstable exits for all peers
30860:  * at a PC.
30860:  */
21433: void
37741: DumpPeerStability(TraceMonitor* tm, const void* ip, JSObject* globalObj, uint32 globalShape,
28244:                   uint32 argc)
21433: {
35044:     TreeFragment* f;
21456:     bool looped = false;
21685:     unsigned length = 0;
21433: 
33748:     for (f = LookupLoop(tm, ip, globalObj, globalShape, argc); f != NULL; f = f->peer) {
36361:         if (!f->code())
21433:             continue;
31469:         debug_only_printf(LC_TMRecorder, "Stability of fragment %p:\nENTRY STACK=", (void*)f);
21456:         if (looped)
36361:             JS_ASSERT(f->nStackTypes == length);
36361:         for (unsigned i = 0; i < f->nStackTypes; i++)
36361:             debug_only_printf(LC_TMRecorder, "%c", typeChar[f->stackTypeMap()[i]]);
31469:         debug_only_print0(LC_TMRecorder, " GLOBALS=");
36361:         for (unsigned i = 0; i < f->nGlobalTypes(); i++)
36361:             debug_only_printf(LC_TMRecorder, "%c", typeChar[f->globalTypeMap()[i]]);
31469:         debug_only_print0(LC_TMRecorder, "\n");
36361:         UnstableExit* uexit = f->unstableExits;
21433:         while (uexit != NULL) {
31469:             debug_only_print0(LC_TMRecorder, "EXIT  ");
37741:             TraceType* m = uexit->exit->fullTypeMap();
31469:             debug_only_print0(LC_TMRecorder, "STACK=");
21433:             for (unsigned i = 0; i < uexit->exit->numStackSlots; i++)
31469:                 debug_only_printf(LC_TMRecorder, "%c", typeChar[m[i]]);
31469:             debug_only_print0(LC_TMRecorder, " GLOBALS=");
31469:             for (unsigned i = 0; i < uexit->exit->numGlobalSlots; i++) {
31469:                 debug_only_printf(LC_TMRecorder, "%c",
31469:                                   typeChar[m[uexit->exit->numStackSlots + i]]);
31469:             }
31469:             debug_only_print0(LC_TMRecorder, "\n");
21433:             uexit = uexit->next;
21433:         }
36361:         length = f->nStackTypes;
21456:         looped = true;
21433:     }
21433: }
21433: #endif
21433: 
29368: #ifdef MOZ_TRACEVIS
29368: 
29368: FILE* traceVisLogFile = NULL;
31063: JSHashTable *traceVisScriptTable = NULL;
29368: 
29368: JS_FRIEND_API(bool)
38585: StartTraceVis(const char* filename = "tracevis.dat")
29368: {
29368:     if (traceVisLogFile) {
29368:         // If we're currently recording, first we must stop.
38585:         StopTraceVis();
29368:     }
29368: 
29368:     traceVisLogFile = fopen(filename, "wb");
29368:     if (!traceVisLogFile)
29368:         return false;
29368: 
29368:     return true;
29368: }
29368: 
29368: JS_FRIEND_API(JSBool)
38585: StartTraceVisNative(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
29368: {
29368:     JSBool ok;
29368: 
29368:     if (argc > 0 && JSVAL_IS_STRING(argv[0])) {
29368:         JSString *str = JSVAL_TO_STRING(argv[0]);
29368:         char *filename = js_DeflateString(cx, str->chars(), str->length());
29368:         if (!filename)
29368:             goto error;
38585:         ok = StartTraceVis(filename);
30851:         cx->free(filename);
29368:     } else {
38585:         ok = StartTraceVis();
29368:     }
29368: 
29368:     if (ok) {
29368:         fprintf(stderr, "started TraceVis recording\n");
29368:         return JS_TRUE;
29368:     }
29368: 
29368:   error:
29368:     JS_ReportError(cx, "failed to start TraceVis recording");
29368:     return JS_FALSE;
29368: }
29368: 
29368: JS_FRIEND_API(bool)
38585: StopTraceVis()
29368: {
29368:     if (!traceVisLogFile)
29368:         return false;
29368: 
29368:     fclose(traceVisLogFile); // not worth checking the result
29368:     traceVisLogFile = NULL;
29368: 
29368:     return true;
29368: }
29368: 
29368: JS_FRIEND_API(JSBool)
38585: StopTraceVisNative(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
38585: {
38585:     JSBool ok = StopTraceVis();
29368: 
29368:     if (ok)
29368:         fprintf(stderr, "stopped TraceVis recording\n");
29368:     else
29368:         JS_ReportError(cx, "TraceVis isn't running");
29368: 
29368:     return ok;
29368: }
29368: 
29368: #endif /* MOZ_TRACEVIS */
33564: 
33564: JS_REQUIRES_STACK void
37741: CaptureStackTypes(JSContext* cx, unsigned callDepth, TraceType* typeMap)
33564: {
33564:     CaptureTypesVisitor capVisitor(cx, typeMap);
33564:     VisitStackSlots(capVisitor, cx, callDepth);
33564: }
33564: 
33564: JS_REQUIRES_STACK void
37741: TraceRecorder::determineGlobalTypes(TraceType* typeMap)
33564: {
33564:     DetermineTypesVisitor detVisitor(*this, typeMap);
36361:     VisitGlobalSlots(detVisitor, cx, *tree->globalSlots);
33564: }
33564: 
33564: #include "jsrecursion.cpp"
33564: 
37741: } /* namespace js */
