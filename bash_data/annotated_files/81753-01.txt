74337: /* -*- Mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 40 -*- */
76372: /* vim: set ts=2 et sw=2 tw=80: */
74337: /* ***** BEGIN LICENSE BLOCK *****
74337:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
74337:  *
74337:  * The contents of this file are subject to the Mozilla Public License Version
74337:  * 1.1 (the "License"); you may not use this file except in compliance with
74337:  * the License. You may obtain a copy of the License at
74337:  * http://www.mozilla.org/MPL/
74337:  *
74337:  * Software distributed under the License is distributed on an "AS IS" basis,
74337:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
74337:  * for the specific language governing rights and limitations under the
74337:  * License.
74337:  *
74337:  * The Original Code is Web Workers.
74337:  *
74337:  * The Initial Developer of the Original Code is
74337:  *   The Mozilla Foundation.
74337:  * Portions created by the Initial Developer are Copyright (C) 2011
74337:  * the Initial Developer. All Rights Reserved.
74337:  *
74337:  * Contributor(s):
74337:  *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
74337:  *
74337:  * Alternatively, the contents of this file may be used under the terms of
74337:  * either the GNU General Public License Version 2 or later (the "GPL"), or
74337:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
74337:  * in which case the provisions of the GPL or the LGPL are applicable instead
74337:  * of those above. If you wish to allow use of your version of this file only
74337:  * under the terms of either the GPL or the LGPL, and not to allow others to
74337:  * use your version of this file under the terms of the MPL, indicate your
74337:  * decision by deleting the provisions above and replace them with the notice
74337:  * and other provisions required by the GPL or the LGPL. If you do not delete
74337:  * the provisions above, a recipient may use your version of this file under
74337:  * the terms of any one of the MPL, the GPL or the LGPL.
74337:  *
74337:  * ***** END LICENSE BLOCK ***** */
74337: 
80467: #include "mozilla/Util.h"
80467: 
74337: #include "RuntimeService.h"
74337: 
74337: #include "nsIDOMChromeWindow.h"
74337: #include "nsIDocument.h"
74337: #include "nsIEffectiveTLDService.h"
74337: #include "nsIObserverService.h"
76372: #include "nsIPlatformCharset.h"
74337: #include "nsIPrincipal.h"
74337: #include "nsIJSContextStack.h"
74337: #include "nsIScriptSecurityManager.h"
74337: #include "nsISupportsPriority.h"
74338: #include "nsITimer.h"
74337: #include "nsPIDOMWindow.h"
74337: 
74337: #include "mozilla/Preferences.h"
74337: #include "nsContentUtils.h"
74337: #include "nsDOMJSUtils.h"
81313: #include <Navigator.h>
74337: #include "nsNetUtil.h"
74337: #include "nsServiceManagerUtils.h"
74337: #include "nsThreadUtils.h"
74337: #include "nsXPCOM.h"
74337: #include "nsXPCOMPrivate.h"
74674: #include "xpcpublic.h"
74337: 
74337: #include "Events.h"
74337: #include "EventTarget.h"
74337: #include "Worker.h"
74337: #include "WorkerPrivate.h"
74337: 
80467: using namespace mozilla;
80467: 
74337: USING_WORKERS_NAMESPACE
74337: 
74337: using mozilla::MutexAutoLock;
74337: using mozilla::MutexAutoUnlock;
74337: using mozilla::Preferences;
74674: using namespace mozilla::xpconnect::memory;
74337: 
74337: // The size of the worker runtime heaps in bytes.
74337: #define WORKER_RUNTIME_HEAPSIZE 32 * 1024 * 1024
74337: 
76376: // The C stack size. We use the same stack size on all platforms for
76376: // consistency.
76376: #define WORKER_STACK_SIZE 256 * sizeof(size_t) * 1024
76376: 
76376: // The stack limit the JS engine will check. Half the size of the
76376: // actual C stack, to be safe.
76376: #define WORKER_CONTEXT_NATIVE_STACK_LIMIT 128 * sizeof(size_t) * 1024
74337: 
74337: // The maximum number of threads to use for workers, overridable via pref.
74337: #define MAX_WORKERS_PER_DOMAIN 10
74337: 
74337: // The default number of seconds that close handlers will be allowed to run.
74337: #define MAX_SCRIPT_RUN_TIME_SEC 10
74337: 
74338: // The number of seconds that idle threads can hang around before being killed.
74338: #define IDLE_THREAD_TIMEOUT_SEC 30
74338: 
74338: // The maximum number of threads that can be idle at one time.
74338: #define MAX_IDLE_THREADS 20
74338: 
74337: #define PREF_WORKERS_ENABLED "dom.workers.enabled"
74337: #define PREF_WORKERS_MAX_PER_DOMAIN "dom.workers.maxPerDomain"
74337: #define PREF_WORKERS_GCZEAL "dom.workers.gczeal"
74337: #define PREF_MAX_SCRIPT_RUN_TIME "dom.max_script_run_time"
74337: 
74337: PR_STATIC_ASSERT(MAX_WORKERS_PER_DOMAIN >= 1);
74337: 
74337: namespace {
74337: 
74337: const PRUint32 kNoIndex = PRUint32(-1);
74337: 
74337: const PRUint32 kRequiredJSContextOptions =
74337:   JSOPTION_DONT_REPORT_UNCAUGHT | JSOPTION_NO_SCRIPT_RVAL;
74337: 
74337: PRUint32 gMaxWorkersPerDomain = MAX_WORKERS_PER_DOMAIN;
74337: 
74337: // Does not hold an owning reference.
74337: RuntimeService* gRuntimeService = nsnull;
74337: 
74337: enum {
74337:   ID_Worker = 0,
74337:   ID_ChromeWorker,
74337:   ID_Event,
74337:   ID_MessageEvent,
74337:   ID_ErrorEvent,
74337: 
74337:   ID_COUNT
74337: };
74337: 
74337: // These are jsids for the main runtime. Only touched on the main thread.
74337: jsid gStringIDs[ID_COUNT] = { JSID_VOID };
74337: 
74337: const char* gStringChars[] = {
74337:   "Worker",
74337:   "ChromeWorker",
74337:   "WorkerEvent",
74337:   "WorkerMessageEvent",
74337:   "WorkerErrorEvent"
74337: 
74337:   // XXX Don't care about ProgressEvent since it should never leak to the main
74337:   // thread.
74337: };
74337: 
74337: PR_STATIC_ASSERT(NS_ARRAY_LENGTH(gStringChars) == ID_COUNT);
74337: 
74337: enum {
74337:   PREF_strict = 0,
74337:   PREF_werror,
74337:   PREF_relimit,
74337:   PREF_tracejit,
74337:   PREF_methodjit,
74337:   PREF_jitprofiling,
74337:   PREF_methodjit_always,
74337: 
74337: #ifdef JS_GC_ZEAL
74337:   PREF_gczeal,
74337: #endif
74337: 
74337:   PREF_COUNT
74337: };
74337: 
74337: #define JS_OPTIONS_DOT_STR "javascript.options."
74337: 
74337: const char* gPrefsToWatch[] = {
74337:   JS_OPTIONS_DOT_STR "strict",
74337:   JS_OPTIONS_DOT_STR "werror",
74337:   JS_OPTIONS_DOT_STR "relimit",
74337:   JS_OPTIONS_DOT_STR "tracejit.content",
74337:   JS_OPTIONS_DOT_STR "methodjit.content",
74337:   JS_OPTIONS_DOT_STR "jitprofiling.content",
74337:   JS_OPTIONS_DOT_STR "methodjit_always"
74337: 
74337: #ifdef JS_GC_ZEAL
74337:   , PREF_WORKERS_GCZEAL
74337: #endif
74337: };
74337: 
74337: PR_STATIC_ASSERT(NS_ARRAY_LENGTH(gPrefsToWatch) == PREF_COUNT);
74337: 
74337: int
74337: PrefCallback(const char* aPrefName, void* aClosure)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   RuntimeService* rts = static_cast<RuntimeService*>(aClosure);
74337:   NS_ASSERTION(rts, "This should never be null!");
74337: 
74337:   NS_NAMED_LITERAL_CSTRING(jsOptionStr, JS_OPTIONS_DOT_STR);
74337: 
74337:   if(StringBeginsWith(nsDependentCString(aPrefName), jsOptionStr)) {
74337:     PRUint32 newOptions = kRequiredJSContextOptions;
74337:     if (Preferences::GetBool(gPrefsToWatch[PREF_strict])) {
74337:       newOptions |= JSOPTION_STRICT;
74337:     }
74337:     if (Preferences::GetBool(gPrefsToWatch[PREF_werror])) {
74337:       newOptions |= JSOPTION_WERROR;
74337:     }
74337:     if (Preferences::GetBool(gPrefsToWatch[PREF_relimit])) {
74337:       newOptions |= JSOPTION_RELIMIT;
74337:     }
74337:     if (Preferences::GetBool(gPrefsToWatch[PREF_tracejit])) {
74337:       newOptions |= JSOPTION_JIT;
74337:     }
74337:     if (Preferences::GetBool(gPrefsToWatch[PREF_methodjit])) {
74337:       newOptions |= JSOPTION_METHODJIT;
74337:     }
74337:     if (Preferences::GetBool(gPrefsToWatch[PREF_jitprofiling])) {
74337:       newOptions |= JSOPTION_PROFILING;
74337:     }
74337:     if (Preferences::GetBool(gPrefsToWatch[PREF_methodjit_always])) {
74337:       newOptions |= JSOPTION_METHODJIT_ALWAYS;
74337:     }
74337:     RuntimeService::SetDefaultJSContextOptions(newOptions);
74337:     rts->UpdateAllWorkerJSContextOptions();
74337:   }
74337: #ifdef JS_GC_ZEAL
74337:   else if (!strcmp(aPrefName, gPrefsToWatch[PREF_gczeal])) {
74337:     PRInt32 gczeal = Preferences::GetInt(gPrefsToWatch[PREF_gczeal]);
81029:     RuntimeService::SetDefaultGCZeal(PRUint8(clamped(gczeal, 0, 3)));
74337:     rts->UpdateAllWorkerGCZeal();
74337:   }
74337: #endif
74337:   return 0;
74337: }
74337: 
74337: void
74337: ErrorReporter(JSContext* aCx, const char* aMessage, JSErrorReport* aReport)
74337: {
74337:   WorkerPrivate* worker = GetWorkerPrivateFromContext(aCx);
74337:   return worker->ReportError(aCx, aMessage, aReport);
74337: }
74337: 
74337: JSBool
74337: OperationCallback(JSContext* aCx)
74337: {
74337:   WorkerPrivate* worker = GetWorkerPrivateFromContext(aCx);
74337:   return worker->OperationCallback(aCx);
74337: }
74337: 
74337: JSContext*
74337: CreateJSContextForWorker(WorkerPrivate* aWorkerPrivate)
74337: {
74337:   aWorkerPrivate->AssertIsOnWorkerThread();
74337:   NS_ASSERTION(!aWorkerPrivate->GetJSContext(), "Already has a context!");
74337: 
74337:   JSRuntime* runtime = JS_NewRuntime(WORKER_RUNTIME_HEAPSIZE);
74337:   if (!runtime) {
74337:     NS_WARNING("Could not create new runtime!");
74337:     return nsnull;
74337:   }
74337: 
74337:   JSContext* workerCx = JS_NewContext(runtime, 0);
74337:   if (!workerCx) {
74337:     JS_DestroyRuntime(runtime);
74337:     NS_WARNING("Could not create new context!");
74337:     return nsnull;
74337:   }
74337: 
74337:   JS_SetContextPrivate(workerCx, aWorkerPrivate);
74337: 
74337:   JS_SetErrorReporter(workerCx, ErrorReporter);
74337: 
74337:   JS_SetOperationCallback(workerCx, OperationCallback);
74337: 
74337:   JS_SetNativeStackQuota(workerCx, WORKER_CONTEXT_NATIVE_STACK_LIMIT);
74337: 
74337:   NS_ASSERTION((aWorkerPrivate->GetJSContextOptions() &
74337:                 kRequiredJSContextOptions) == kRequiredJSContextOptions,
74337:                "Somehow we lost our required options!");
74337:   JS_SetOptions(workerCx, aWorkerPrivate->GetJSContextOptions());
74337: 
74337: #ifdef JS_GC_ZEAL
74337:   {
74337:     PRUint8 zeal = aWorkerPrivate->GetGCZeal();
74337:     NS_ASSERTION(zeal <= 3, "Bad zeal value!");
74337: 
74337:     PRUint32 frequency = zeal <= 2 ? JS_DEFAULT_ZEAL_FREQ : 1;
74337:     JS_SetGCZeal(workerCx, zeal, frequency, false);
74337:   }
74337: #endif
74337: 
74337:   if (aWorkerPrivate->IsChromeWorker()) {
74337:     JS_SetVersion(workerCx, JSVERSION_LATEST);
74337:   }
74337: 
74337:   return workerCx;
74337: }
74337: 
74337: class WorkerThreadRunnable : public nsRunnable
74337: {
74337:   WorkerPrivate* mWorkerPrivate;
74337: 
74337: public:
74337:   WorkerThreadRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : mWorkerPrivate(aWorkerPrivate)
74337:   {
74337:     NS_ASSERTION(mWorkerPrivate, "This should never be null!");
74337:   }
74337: 
74337:   NS_IMETHOD
74337:   Run()
74337:   {
74337:     WorkerPrivate* workerPrivate = mWorkerPrivate;
74337:     mWorkerPrivate = nsnull;
74337: 
74337:     workerPrivate->AssertIsOnWorkerThread();
74337: 
74337:     JSContext* cx = CreateJSContextForWorker(workerPrivate);
74337:     if (!cx) {
74337:       // XXX need to fire an error at parent.
74337:       NS_ERROR("Failed to create runtime and context!");
74337:       return NS_ERROR_FAILURE;
74337:     }
74337: 
75066:     {
75066:       JSAutoRequest ar(cx);
74674:       workerPrivate->DoRunLoop(cx);
75066:     }
74674: 
75066:     JSRuntime* rt = JS_GetRuntime(cx);
75066: 
74337:     // XXX Bug 666963 - CTypes can create another JSContext for use with
74337:     // closures, and then it holds that context in a reserved slot on the CType
74337:     // prototype object. We have to destroy that context before we can destroy
74337:     // the runtime, and we also have to make sure that it isn't the last context
74337:     // to be destroyed (otherwise it will assert). To accomplish this we create
74337:     // an unused dummy context, destroy our real context, and then destroy the
74337:     // dummy. Once this bug is resolved we can remove this nastiness and simply
74337:     // call JS_DestroyContextNoGC on our context.
74337:     JSContext* dummyCx = JS_NewContext(rt, 0);
74337:     if (dummyCx) {
74337:       JS_DestroyContext(cx);
74337:       JS_DestroyContext(dummyCx);
74337:     }
74337:     else {
74337:       NS_WARNING("Failed to create dummy context!");
74337:       JS_DestroyContext(cx);
74337:     }
74337: 
74337:     JS_DestroyRuntime(rt);
74337: 
74337:     workerPrivate->ScheduleDeletion(false);
74337:     return NS_OK;
74337:   }
74337: };
74337: 
74337: } /* anonymous namespace */
74337: 
74337: BEGIN_WORKERS_NAMESPACE
74337: 
74337: // Entry point for the DOM.
74337: JSBool
74337: ResolveWorkerClasses(JSContext* aCx, JSObject* aObj, jsid aId, uintN aFlags,
74337:                      JSObject** aObjp)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   // Don't care about assignments or declarations, bail now.
74337:   if (aFlags & (JSRESOLVE_ASSIGNING | JSRESOLVE_DECLARING)) {
74337:     *aObjp = nsnull;
74337:     return true;
74337:   }
74337: 
74337:   // Make sure our strings are interned.
74337:   if (JSID_IS_VOID(gStringIDs[0])) {
74337:     for (PRUint32 i = 0; i < ID_COUNT; i++) {
74337:       JSString* str = JS_InternString(aCx, gStringChars[i]);
74337:       if (!str) {
74337:         while (i) {
74337:           gStringIDs[--i] = JSID_VOID;
74337:         }
74337:         return false;
74337:       }
74337:       gStringIDs[i] = INTERNED_STRING_TO_JSID(aCx, str);
74337:     }
74337:   }
74337: 
74337:   bool isChrome = false;
74337:   bool shouldResolve = false;
74337: 
74337:   for (PRUint32 i = 0; i < ID_COUNT; i++) {
74337:     if (aId == gStringIDs[i]) {
74337:       nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
74337:       NS_ASSERTION(ssm, "This should never be null!");
74337: 
79445:       bool enabled;
74337:       if (NS_FAILED(ssm->IsCapabilityEnabled("UniversalXPConnect", &enabled))) {
74337:         NS_WARNING("IsCapabilityEnabled failed!");
80486:         isChrome = false;
74337:       }
74337: 
74337:       isChrome = !!enabled;
74337: 
74337:       // Don't resolve if this is ChromeWorker and we're not chrome. Otherwise
74337:       // always resolve.
74337:       shouldResolve = aId == gStringIDs[ID_ChromeWorker] ? isChrome : true;
74337:       break;
74337:     }
74337:   }
74337: 
74337:   if (shouldResolve) {
74337:     // Don't do anything if workers are disabled.
74337:     if (!isChrome && !Preferences::GetBool(PREF_WORKERS_ENABLED)) {
74337:       *aObjp = nsnull;
74337:       return true;
74337:     }
74337: 
74337:     JSObject* eventTarget = events::InitEventTargetClass(aCx, aObj, true);
74337:     if (!eventTarget) {
74337:       return false;
74337:     }
74337: 
74337:     JSObject* worker = worker::InitClass(aCx, aObj, eventTarget, true);
74337:     if (!worker) {
74337:       return false;
74337:     }
74337: 
74337:     if (isChrome && !chromeworker::InitClass(aCx, aObj, worker, true)) {
74337:       return false;
74337:     }
74337: 
74337:     if (!events::InitClasses(aCx, aObj, true)) {
74337:       return false;
74337:     }
74337: 
74337:     *aObjp = aObj;
74337:     return true;
74337:   }
74337: 
74337:   // Not resolved.
74337:   *aObjp = nsnull;
74337:   return true;
74337: }
74337: 
74337: void
74337: CancelWorkersForWindow(JSContext* aCx, nsPIDOMWindow* aWindow)
74337: {
74337:   AssertIsOnMainThread();
74337:   RuntimeService* runtime = RuntimeService::GetService();
74337:   if (runtime) {
74337:     runtime->CancelWorkersForWindow(aCx, aWindow);
74337:   }
74337: }
74337: 
74337: void
74337: SuspendWorkersForWindow(JSContext* aCx, nsPIDOMWindow* aWindow)
74337: {
74337:   AssertIsOnMainThread();
74337:   RuntimeService* runtime = RuntimeService::GetService();
74337:   if (runtime) {
74337:     runtime->SuspendWorkersForWindow(aCx, aWindow);
74337:   }
74337: }
74337: 
74337: void
74337: ResumeWorkersForWindow(JSContext* aCx, nsPIDOMWindow* aWindow)
74337: {
74337:   AssertIsOnMainThread();
74337:   RuntimeService* runtime = RuntimeService::GetService();
74337:   if (runtime) {
74337:     runtime->ResumeWorkersForWindow(aCx, aWindow);
74337:   }
74337: }
74337: 
74337: END_WORKERS_NAMESPACE
74337: 
74337: PRUint32 RuntimeService::sDefaultJSContextOptions = kRequiredJSContextOptions;
74337: 
74337: PRInt32 RuntimeService::sCloseHandlerTimeoutSeconds = MAX_SCRIPT_RUN_TIME_SEC;
74337: 
74337: #ifdef JS_GC_ZEAL
74337: PRUint8 RuntimeService::sDefaultGCZeal = 0;
74337: #endif
74337: 
74337: RuntimeService::RuntimeService()
74338: : mMutex("RuntimeService::mMutex"), mObserved(false),
74337:   mShuttingDown(false), mNavigatorStringsLoaded(false)
74337: {
74337:   AssertIsOnMainThread();
74337:   NS_ASSERTION(!gRuntimeService, "More than one service!");
74337: }
74337: 
74337: RuntimeService::~RuntimeService()
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   // gRuntimeService can be null if Init() fails.
74337:   NS_ASSERTION(!gRuntimeService || gRuntimeService == this,
74337:                "More than one service!");
74337: 
74337:   gRuntimeService = nsnull;
74337: }
74337: 
74337: // static
74337: RuntimeService*
74337: RuntimeService::GetOrCreateService()
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   if (!gRuntimeService) {
74337:     nsRefPtr<RuntimeService> service = new RuntimeService();
74337:     if (NS_FAILED(service->Init())) {
74337:       NS_WARNING("Failed to initialize!");
74337:       service->Cleanup();
74337:       return nsnull;
74337:     }
74337: 
74337:     // The observer service now owns us until shutdown.
74337:     gRuntimeService = service;
74337:   }
74337: 
74337:   return gRuntimeService;
74337: }
74337: 
74337: // static
74337: RuntimeService*
74337: RuntimeService::GetService()
74337: {
74337:   return gRuntimeService;
74337: }
74337: 
74337: bool
74337: RuntimeService::RegisterWorker(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337: {
74337:   aWorkerPrivate->AssertIsOnParentThread();
74337: 
74337:   WorkerPrivate* parent = aWorkerPrivate->GetParent();
74337:   if (!parent) {
74337:     AssertIsOnMainThread();
74337: 
74337:     if (mShuttingDown) {
74337:       JS_ReportError(aCx, "Cannot create worker during shutdown!");
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   WorkerDomainInfo* domainInfo;
74337:   bool queued = false;
74337:   {
74337:     const nsCString& domain = aWorkerPrivate->Domain();
74337: 
74338:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (!mDomainMap.Get(domain, &domainInfo)) {
74337:       NS_ASSERTION(!parent, "Shouldn't have a parent here!");
74337: 
74337:       domainInfo = new WorkerDomainInfo();
74337:       domainInfo->mDomain = domain;
74337: 
74337:       if (!mDomainMap.Put(domain, domainInfo)) {
74337:         delete domainInfo;
74337:         domainInfo = nsnull;
74337:       }
74337:     }
74337: 
74337:     if (domainInfo) {
74337:       queued = gMaxWorkersPerDomain &&
74337:                domainInfo->ActiveWorkerCount() >= gMaxWorkersPerDomain &&
74337:                !domain.IsEmpty();
74337: 
74337:       if (queued) {
74337:         domainInfo->mQueuedWorkers.AppendElement(aWorkerPrivate);
74337:       }
74337:       else if (parent) {
74337:         domainInfo->mChildWorkerCount++;
74337:       }
74337:       else {
74337:         domainInfo->mActiveWorkers.AppendElement(aWorkerPrivate);
74337:       }
74337:     }
74337:   }
74337: 
74337:   if (!domainInfo) {
74337:     JS_ReportOutOfMemory(aCx);
74337:     return false;
74337:   }
74337: 
74337:   // From here on out we must call UnregisterWorker if something fails!
74337:   if (parent) {
74337:     if (!parent->AddChildWorker(aCx, aWorkerPrivate)) {
74337:       UnregisterWorker(aCx, aWorkerPrivate);
74337:       return false;
74337:     }
74337:   }
74337:   else {
74337:     if (!mNavigatorStringsLoaded) {
74337:       if (NS_FAILED(NS_GetNavigatorAppName(mNavigatorStrings.mAppName)) ||
74337:           NS_FAILED(NS_GetNavigatorAppVersion(mNavigatorStrings.mAppVersion)) ||
74337:           NS_FAILED(NS_GetNavigatorPlatform(mNavigatorStrings.mPlatform)) ||
74337:           NS_FAILED(NS_GetNavigatorUserAgent(mNavigatorStrings.mUserAgent))) {
74337:         JS_ReportError(aCx, "Failed to load navigator strings!");
74337:         UnregisterWorker(aCx, aWorkerPrivate);
74337:         return false;
74337:       }
74337: 
74337:       mNavigatorStringsLoaded = true;
74337:     }
74337: 
74337:     nsPIDOMWindow* window = aWorkerPrivate->GetWindow();
74337: 
74337:     nsTArray<WorkerPrivate*>* windowArray;
74337:     if (!mWindowMap.Get(window, &windowArray)) {
74337:       NS_ASSERTION(!parent, "Shouldn't have a parent here!");
74337: 
74337:       windowArray = new nsTArray<WorkerPrivate*>(1);
74337: 
74337:       if (!mWindowMap.Put(window, windowArray)) {
74337:         delete windowArray;
74337:         UnregisterWorker(aCx, aWorkerPrivate);
74337:         JS_ReportOutOfMemory(aCx);
74337:         return false;
74337:       }
74337:     }
74337: 
74337:     NS_ASSERTION(!windowArray->Contains(aWorkerPrivate),
74337:                  "Already know about this worker!");
74337:     windowArray->AppendElement(aWorkerPrivate);
74337:   }
74337: 
74337:   if (!queued && !ScheduleWorker(aCx, aWorkerPrivate)) {
74337:     return false;
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: void
74337: RuntimeService::UnregisterWorker(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337: {
74337:   aWorkerPrivate->AssertIsOnParentThread();
74337: 
74337:   WorkerPrivate* parent = aWorkerPrivate->GetParent();
74337:   if (!parent) {
74337:     AssertIsOnMainThread();
74337:   }
74337: 
74337:   WorkerPrivate* queuedWorker = nsnull;
74337:   {
74337:     const nsCString& domain = aWorkerPrivate->Domain();
74337: 
74338:     MutexAutoLock lock(mMutex);
74337: 
74337:     WorkerDomainInfo* domainInfo;
74337:     if (!mDomainMap.Get(domain, &domainInfo)) {
74337:       NS_ERROR("Don't have an entry for this domain!");
74337:     }
74337: 
74337:     // Remove old worker from everywhere.
74337:     PRUint32 index = domainInfo->mQueuedWorkers.IndexOf(aWorkerPrivate);
74337:     if (index != kNoIndex) {
74337:       // Was queued, remove from the list.
74337:       domainInfo->mQueuedWorkers.RemoveElementAt(index);
74337:     }
74337:     else if (parent) {
74337:       NS_ASSERTION(domainInfo->mChildWorkerCount, "Must be non-zero!");
74337:       domainInfo->mChildWorkerCount--;
74337:     }
74337:     else {
74337:       NS_ASSERTION(domainInfo->mActiveWorkers.Contains(aWorkerPrivate),
74337:                    "Don't know about this worker!");
74337:       domainInfo->mActiveWorkers.RemoveElement(aWorkerPrivate);
74337:     }
74337: 
74337:     // See if there's a queued worker we can schedule.
74337:     if (domainInfo->ActiveWorkerCount() < gMaxWorkersPerDomain &&
74337:         !domainInfo->mQueuedWorkers.IsEmpty()) {
74337:       queuedWorker = domainInfo->mQueuedWorkers[0];
74337:       domainInfo->mQueuedWorkers.RemoveElementAt(0);
74337: 
74337:       if (queuedWorker->GetParent()) {
74337:         domainInfo->mChildWorkerCount++;
74337:       }
74337:       else {
74337:         domainInfo->mActiveWorkers.AppendElement(queuedWorker);
74337:       }
74337:     }
74337: 
74337:     if (!domainInfo->ActiveWorkerCount()) {
74337:       NS_ASSERTION(domainInfo->mQueuedWorkers.IsEmpty(), "Huh?!");
74337:       mDomainMap.Remove(domain);
74337:     }
74337:   }
74337: 
74337:   if (parent) {
74337:     parent->RemoveChildWorker(aCx, aWorkerPrivate);
74337:   }
74337:   else {
74337:     nsPIDOMWindow* window = aWorkerPrivate->GetWindow();
74337: 
74337:     nsTArray<WorkerPrivate*>* windowArray;
74337:     if (!mWindowMap.Get(window, &windowArray)) {
74337:       NS_ERROR("Don't have an entry for this window!");
74337:     }
74337: 
74337:     NS_ASSERTION(windowArray->Contains(aWorkerPrivate),
74337:                  "Don't know about this worker!");
74337:     windowArray->RemoveElement(aWorkerPrivate);
74337: 
74337:     if (windowArray->IsEmpty()) {
74337:       NS_ASSERTION(!queuedWorker, "How can this be?!");
74337:       mWindowMap.Remove(window);
74337:     }
74337:   }
74337: 
74337:   if (queuedWorker && !ScheduleWorker(aCx, queuedWorker)) {
74337:     UnregisterWorker(aCx, queuedWorker);
74337:   }
74337: }
74337: 
74337: bool
74337: RuntimeService::ScheduleWorker(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337: {
74337:   if (!aWorkerPrivate->Start()) {
74337:     // This is ok, means that we didn't need to make a thread for this worker.
74337:     return true;
74337:   }
74337: 
74337:   nsCOMPtr<nsIThread> thread;
74338:   {
74338:     MutexAutoLock lock(mMutex);
74338:     if (!mIdleThreadArray.IsEmpty()) {
74338:       PRUint32 index = mIdleThreadArray.Length() - 1;
74338:       mIdleThreadArray[index].mThread.swap(thread);
74338:       mIdleThreadArray.RemoveElementAt(index);
74338:     }
74338:   }
74338: 
74338:   if (!thread) {
76376:     if (NS_FAILED(NS_NewThread(getter_AddRefs(thread), nsnull,
76376:                                WORKER_STACK_SIZE))) {
74337:       UnregisterWorker(aCx, aWorkerPrivate);
74337:       JS_ReportError(aCx, "Could not create new thread!");
74337:       return false;
74337:     }
74337: 
74337:     nsCOMPtr<nsISupportsPriority> priority = do_QueryInterface(thread);
74337:     if (!priority ||
74338:         NS_FAILED(priority->SetPriority(nsISupportsPriority::PRIORITY_LOW))) {
74337:       NS_WARNING("Could not lower the new thread's priority!");
74337:     }
74338:   }
74337: 
74337: #ifdef DEBUG
74337:   aWorkerPrivate->SetThread(thread);
74337: #endif
74337: 
74337:   nsCOMPtr<nsIRunnable> runnable = new WorkerThreadRunnable(aWorkerPrivate);
74337:   if (NS_FAILED(thread->Dispatch(runnable, NS_DISPATCH_NORMAL))) {
74337:     UnregisterWorker(aCx, aWorkerPrivate);
74338:     JS_ReportError(aCx, "Could not dispatch to thread!");
74337:     return false;
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74338: // static
74338: void
74338: RuntimeService::ShutdownIdleThreads(nsITimer* aTimer, void* /* aClosure */)
74338: {
74338:   AssertIsOnMainThread();
74338: 
74338:   RuntimeService* runtime = RuntimeService::GetService();
74338:   NS_ASSERTION(runtime, "This should never be null!");
74338: 
74338:   NS_ASSERTION(aTimer == runtime->mIdleThreadTimer, "Wrong timer!");
74338: 
74338:   // Cheat a little and grab all threads that expire within one second of now.
74338:   TimeStamp now = TimeStamp::Now() + TimeDuration::FromSeconds(1);
74338: 
74338:   TimeStamp nextExpiration;
74338: 
74338:   nsAutoTArray<nsCOMPtr<nsIThread>, 20> expiredThreads;
74338:   {
74338:     MutexAutoLock lock(runtime->mMutex);
74338: 
74338:     for (PRUint32 index = 0; index < runtime->mIdleThreadArray.Length();
74338:          index++) {
74338:       IdleThreadInfo& info = runtime->mIdleThreadArray[index];
74338:       if (info.mExpirationTime > now) {
74338:         nextExpiration = info.mExpirationTime;
74338:         break;
74338:       }
74338: 
74338:       nsCOMPtr<nsIThread>* thread = expiredThreads.AppendElement();
74338:       thread->swap(info.mThread);
74338:     }
74338: 
74338:     if (!expiredThreads.IsEmpty()) {
74338:       runtime->mIdleThreadArray.RemoveElementsAt(0, expiredThreads.Length());
74338:     }
74338:   }
74338: 
74338:   NS_ASSERTION(nextExpiration.IsNull() || !expiredThreads.IsEmpty(),
74338:                "Should have a new time or there should be some threads to shut "
74338:                "down");
74338: 
74338:   for (PRUint32 index = 0; index < expiredThreads.Length(); index++) {
74338:     if (NS_FAILED(expiredThreads[index]->Shutdown())) {
74338:       NS_WARNING("Failed to shutdown thread!");
74338:     }
74338:   }
74338: 
74338:   if (!nextExpiration.IsNull()) {
74338:     TimeDuration delta = nextExpiration - TimeStamp::Now();
74338:     PRUint32 delay(delta > TimeDuration(0) ? delta.ToMilliseconds() : 0);
74338: 
74338:     // Reschedule the timer.
74338:     if (NS_FAILED(aTimer->InitWithFuncCallback(ShutdownIdleThreads, nsnull,
74338:                                                delay,
74338:                                                nsITimer::TYPE_ONE_SHOT))) {
74338:       NS_ERROR("Can't schedule timer!");
74338:     }
74338:   }
74338: }
74338: 
74337: nsresult
74337: RuntimeService::Init()
74337: {
74337:   AssertIsOnMainThread();
74337: 
74338:   mIdleThreadTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
74338:   NS_ENSURE_STATE(mIdleThreadTimer);
74338: 
79445:   bool ok = mDomainMap.Init();
74337:   NS_ENSURE_STATE(ok);
74337: 
74337:   ok = mWindowMap.Init();
74337:   NS_ENSURE_STATE(ok);
74337: 
74337:   nsresult rv;
74337:   nsCOMPtr<nsIObserverService> obs =
74337:     do_GetService(NS_OBSERVERSERVICE_CONTRACTID, &rv);
74337:   NS_ENSURE_SUCCESS(rv, rv);
74337: 
80486:   rv = obs->AddObserver(this, NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID, false);
74337:   NS_ENSURE_SUCCESS(rv, rv);
74337: 
74337:   mObserved = true;
74337: 
80467:   for (PRUint32 index = 0; index < ArrayLength(gPrefsToWatch); index++) {
74337:     if (NS_FAILED(Preferences::RegisterCallback(PrefCallback,
74337:                                                 gPrefsToWatch[index], this))) {
74337:       NS_WARNING("Failed to register pref callback?!");
74337:     }
74337:     PrefCallback(gPrefsToWatch[index], this);
74337:   }
74337: 
74337:   // We assume atomic 32bit reads/writes. If this assumption doesn't hold on
74337:   // some wacky platform then the worst that could happen is that the close
74337:   // handler will run for a slightly different amount of time.
74337:   if (NS_FAILED(Preferences::AddIntVarCache(&sCloseHandlerTimeoutSeconds,
74337:                                             PREF_MAX_SCRIPT_RUN_TIME,
74337:                                             MAX_SCRIPT_RUN_TIME_SEC))) {
74337:       NS_WARNING("Failed to register timeout cache?!");
74337:   }
74337: 
74337:   PRInt32 maxPerDomain = Preferences::GetInt(PREF_WORKERS_MAX_PER_DOMAIN,
74337:                                              MAX_WORKERS_PER_DOMAIN);
74337:   gMaxWorkersPerDomain = NS_MAX(0, maxPerDomain);
74337: 
76372:   mDetectorName = Preferences::GetLocalizedCString("intl.charset.detector");
76372: 
76372:   nsCOMPtr<nsIPlatformCharset> platformCharset =
76372:     do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &rv);
76372:   if (NS_SUCCEEDED(rv)) {
76372:     rv = platformCharset->GetCharset(kPlatformCharsetSel_PlainTextInFile,
76372:                                      mSystemCharset);
76372:   }
76372: 
74337:   return NS_OK;
74337: }
74337: 
74337: // This spins the event loop until all workers are finished and their threads
74337: // have been joined.
74337: void
74337: RuntimeService::Cleanup()
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   mShuttingDown = true;
74337: 
74338:   if (mIdleThreadTimer) {
74338:     if (NS_FAILED(mIdleThreadTimer->Cancel())) {
74338:       NS_WARNING("Failed to cancel idle timer!");
74338:     }
74338:     mIdleThreadTimer = nsnull;
74338:   }
74338: 
74337:   if (mDomainMap.IsInitialized()) {
74338:     MutexAutoLock lock(mMutex);
74337: 
74337:     nsAutoTArray<WorkerPrivate*, 100> workers;
74337:     mDomainMap.EnumerateRead(AddAllTopLevelWorkersToArray, &workers);
74337: 
74337:     if (!workers.IsEmpty()) {
74337:       nsIThread* currentThread;
74337: 
74337:       // Cancel all top-level workers.
74337:       {
74338:         MutexAutoUnlock unlock(mMutex);
74337: 
74337:         currentThread = NS_GetCurrentThread();
74337:         NS_ASSERTION(currentThread, "This should never be null!");
74337: 
74337:         AutoSafeJSContext cx;
74337: 
74337:         for (PRUint32 index = 0; index < workers.Length(); index++) {
74337:           if (!workers[index]->Kill(cx)) {
74337:             NS_WARNING("Failed to cancel worker!");
74337:           }
74337:         }
74337:       }
74337: 
74338:       // Shut down any idle threads.
74338:       if (!mIdleThreadArray.IsEmpty()) {
74338:         nsAutoTArray<nsCOMPtr<nsIThread>, 20> idleThreads;
74338: 
74338:         PRUint32 idleThreadCount = mIdleThreadArray.Length();
74338:         idleThreads.SetLength(idleThreadCount);
74338: 
74338:         for (PRUint32 index = 0; index < idleThreadCount; index++) {
74338:           NS_ASSERTION(mIdleThreadArray[index].mThread, "Null thread!");
74338:           idleThreads[index].swap(mIdleThreadArray[index].mThread);
74338:         }
74338: 
74338:         mIdleThreadArray.Clear();
74338: 
74338:         MutexAutoUnlock unlock(mMutex);
74338: 
74338:         for (PRUint32 index = 0; index < idleThreadCount; index++) {
74338:           if (NS_FAILED(idleThreads[index]->Shutdown())) {
74338:             NS_WARNING("Failed to shutdown thread!");
74338:           }
74338:         }
74338:       }
74338: 
74337:       // And make sure all their final messages have run and all their threads
74337:       // have joined.
74337:       while (mDomainMap.Count()) {
74338:         MutexAutoUnlock unlock(mMutex);
74337: 
74337:         if (NS_FAILED(NS_ProcessNextEvent(currentThread))) {
74337:           NS_WARNING("Something bad happened!");
74337:           break;
74337:         }
74337:       }
74337:     }
74337:   }
74337: 
74337:   if (mWindowMap.IsInitialized()) {
74337:     NS_ASSERTION(!mWindowMap.Count(), "All windows should have been released!");
74337:   }
74337: 
74337:   if (mObserved) {
80467:     for (PRUint32 index = 0; index < ArrayLength(gPrefsToWatch); index++) {
74337:       Preferences::UnregisterCallback(PrefCallback, gPrefsToWatch[index], this);
74337:     }
74337: 
74337:     nsCOMPtr<nsIObserverService> obs =
74337:       do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
74337:     NS_WARN_IF_FALSE(obs, "Failed to get observer service?!");
74337: 
74337:     if (obs) {
74337:       nsresult rv =
74337:         obs->RemoveObserver(this, NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID);
74337:       mObserved = !NS_SUCCEEDED(rv);
74337:     }
74337:   }
74337: }
74337: 
74337: // static
74337: PLDHashOperator
74337: RuntimeService::AddAllTopLevelWorkersToArray(const nsACString& aKey,
74337:                                              WorkerDomainInfo* aData,
74337:                                              void* aUserArg)
74337: {
74337:   nsTArray<WorkerPrivate*>* array =
74337:     static_cast<nsTArray<WorkerPrivate*>*>(aUserArg);
74337: 
74337: #ifdef DEBUG
74337:   for (PRUint32 index = 0; index < aData->mActiveWorkers.Length(); index++) {
74337:     NS_ASSERTION(!aData->mActiveWorkers[index]->GetParent(),
74337:                  "Shouldn't have a parent in this list!");
74337:   }
74337: #endif
74337: 
74337:   array->AppendElements(aData->mActiveWorkers);
74337: 
74337:   // These might not be top-level workers...
74337:   for (PRUint32 index = 0; index < aData->mQueuedWorkers.Length(); index++) {
74337:     WorkerPrivate* worker = aData->mQueuedWorkers[index];
74337:     if (!worker->GetParent()) {
74337:       array->AppendElement(worker);
74337:     }
74337:   }
74337: 
74337:   return PL_DHASH_NEXT;
74337: }
74337: 
74337: void
74337: RuntimeService::GetWorkersForWindow(nsPIDOMWindow* aWindow,
74337:                                     nsTArray<WorkerPrivate*>& aWorkers)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   nsTArray<WorkerPrivate*>* workers;
74337:   if (mWindowMap.Get(aWindow, &workers)) {
74337:     NS_ASSERTION(!workers->IsEmpty(), "Should have been removed!");
74337:     aWorkers.AppendElements(*workers);
74337:   }
74337:   else {
74337:     NS_ASSERTION(aWorkers.IsEmpty(), "Should be empty!");
74337:   }
74337: }
74337: 
74337: void
74337: RuntimeService::CancelWorkersForWindow(JSContext* aCx,
74337:                                        nsPIDOMWindow* aWindow)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   nsAutoTArray<WorkerPrivate*, 100> workers;
74337:   GetWorkersForWindow(aWindow, workers);
74337: 
74337:   if (!workers.IsEmpty()) {
74337:     AutoSafeJSContext cx(aCx);
74337:     for (PRUint32 index = 0; index < workers.Length(); index++) {
74337:       if (!workers[index]->Cancel(aCx)) {
74337:         NS_WARNING("Failed to cancel worker!");
74337:       }
74337:     }
74337:   }
74337: }
74337: 
74337: void
74337: RuntimeService::SuspendWorkersForWindow(JSContext* aCx,
74337:                                         nsPIDOMWindow* aWindow)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   nsAutoTArray<WorkerPrivate*, 100> workers;
74337:   GetWorkersForWindow(aWindow, workers);
74337: 
74337:   if (!workers.IsEmpty()) {
81753:     AutoSafeJSContext cx(aCx);
74337:     for (PRUint32 index = 0; index < workers.Length(); index++) {
74337:       if (!workers[index]->Suspend(aCx)) {
74337:         NS_WARNING("Failed to cancel worker!");
74337:       }
74337:     }
74337:   }
74337: }
74337: 
74337: void
74337: RuntimeService::ResumeWorkersForWindow(JSContext* aCx,
74337:                                        nsPIDOMWindow* aWindow)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   nsAutoTArray<WorkerPrivate*, 100> workers;
74337:   GetWorkersForWindow(aWindow, workers);
74337: 
74337:   if (!workers.IsEmpty()) {
81753:     AutoSafeJSContext cx(aCx);
74337:     for (PRUint32 index = 0; index < workers.Length(); index++) {
74337:       if (!workers[index]->Resume(aCx)) {
74337:         NS_WARNING("Failed to cancel worker!");
74337:       }
74337:     }
74337:   }
74337: }
74337: 
74337: void
74338: RuntimeService::NoteIdleThread(nsIThread* aThread)
74338: {
74338:   AssertIsOnMainThread();
74338:   NS_ASSERTION(aThread, "Null pointer!");
74338: 
74338:   static TimeDuration timeout =
74338:     TimeDuration::FromSeconds(IDLE_THREAD_TIMEOUT_SEC);
74338: 
74338:   TimeStamp expirationTime = TimeStamp::Now() + timeout;
74338: 
74338:   bool shutdown;
74338:   if (mShuttingDown) {
74338:     shutdown = true;
74338:   }
74338:   else {
74338:     MutexAutoLock lock(mMutex);
74338: 
74338:     if (mIdleThreadArray.Length() < MAX_IDLE_THREADS) {
74338:       IdleThreadInfo* info = mIdleThreadArray.AppendElement();
74338:       info->mThread = aThread;
74338:       info->mExpirationTime = expirationTime;
74338:       shutdown = false;
74338:     }
74338:     else {
74338:       shutdown = true;
74338:     }
74338:   }
74338: 
74338:   // Too many idle threads, just shut this one down.
74338:   if (shutdown) {
74338:     if (NS_FAILED(aThread->Shutdown())) {
74338:       NS_WARNING("Failed to shutdown thread!");
74338:     }
74338:     return;
74338:   }
74338: 
74338:   // Schedule timer.
74338:   if (NS_FAILED(mIdleThreadTimer->
74338:                   InitWithFuncCallback(ShutdownIdleThreads, nsnull,
74338:                                        IDLE_THREAD_TIMEOUT_SEC * 1000,
74338:                                        nsITimer::TYPE_ONE_SHOT))) {
74338:     NS_ERROR("Can't schedule timer!");
74338:   }
74338: }
74338: 
74338: void
74337: RuntimeService::UpdateAllWorkerJSContextOptions()
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   nsAutoTArray<WorkerPrivate*, 100> workers;
74337:   {
74338:     MutexAutoLock lock(mMutex);
74337: 
74337:     mDomainMap.EnumerateRead(AddAllTopLevelWorkersToArray, &workers);
74337:   }
74337: 
74337:   if (!workers.IsEmpty()) {
74337:     AutoSafeJSContext cx;
74337:     for (PRUint32 index = 0; index < workers.Length(); index++) {
74337:       workers[index]->UpdateJSContextOptions(cx, GetDefaultJSContextOptions());
74337:     }
74337:   }
74337: }
74337: 
74337: #ifdef JS_GC_ZEAL
74337: void
74337: RuntimeService::UpdateAllWorkerGCZeal()
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   nsAutoTArray<WorkerPrivate*, 100> workers;
74337:   {
74338:     MutexAutoLock lock(mMutex);
74337: 
74337:     mDomainMap.EnumerateRead(AddAllTopLevelWorkersToArray, &workers);
74337:   }
74337: 
74337:   if (!workers.IsEmpty()) {
74337:     AutoSafeJSContext cx;
74337:     for (PRUint32 index = 0; index < workers.Length(); index++) {
74337:       workers[index]->UpdateGCZeal(cx, GetDefaultGCZeal());
74337:     }
74337:   }
74337: }
74337: #endif
74337: 
74337: // nsISupports
74337: NS_IMPL_ISUPPORTS1(RuntimeService, nsIObserver)
74337: 
74337: // nsIObserver
74337: NS_IMETHODIMP
74337: RuntimeService::Observe(nsISupports* aSubject, const char* aTopic,
74337:                         const PRUnichar* aData)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   if (!strcmp(aTopic, NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID)) {
74337:     Cleanup();
74337:     return NS_OK;
74337:   }
74337: 
74337:   NS_NOTREACHED("Unknown observer topic!");
74337:   return NS_OK;
74337: }
74337: 
74337: RuntimeService::AutoSafeJSContext::AutoSafeJSContext(JSContext* aCx)
74337: : mContext(aCx ? aCx : GetSafeContext())
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   if (mContext) {
74337:     nsIThreadJSContextStack* stack = nsContentUtils::ThreadJSContextStack();
74337:     NS_ASSERTION(stack, "This should never be null!");
74337: 
74337:     if (NS_FAILED(stack->Push(mContext))) {
74337:       NS_ERROR("Couldn't push safe JSContext!");
74337:       mContext = nsnull;
74337:       return;
74337:     }
74337: 
74337:     JS_BeginRequest(mContext);
74337:   }
74337: }
74337: 
74337: RuntimeService::AutoSafeJSContext::~AutoSafeJSContext()
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   if (mContext) {
74337:     JS_ReportPendingException(mContext);
74337: 
74337:     JS_EndRequest(mContext);
74337: 
74337:     nsIThreadJSContextStack* stack = nsContentUtils::ThreadJSContextStack();
74337:     NS_ASSERTION(stack, "This should never be null!");
74337: 
74337:     JSContext* cx;
74337:     if (NS_FAILED(stack->Pop(&cx))) {
74337:       NS_ERROR("Failed to pop safe context!");
74337:     }
74337:     if (cx != mContext) {
74337:       NS_ERROR("Mismatched context!");
74337:     }
74337:   }
74337: }
74337: 
74337: // static
74337: JSContext*
74337: RuntimeService::AutoSafeJSContext::GetSafeContext()
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   nsIThreadJSContextStack* stack = nsContentUtils::ThreadJSContextStack();
74337:   NS_ASSERTION(stack, "This should never be null!");
74337: 
74337:   JSContext* cx;
74337:   if (NS_FAILED(stack->GetSafeJSContext(&cx))) {
74337:     NS_ERROR("Couldn't get safe JSContext!");
74337:     return nsnull;
74337:   }
74337: 
74337:   NS_ASSERTION(!JS_IsExceptionPending(cx), "Already has an exception?!");
74337:   return cx;
74337: }
