    1: /* -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Michael Lowe <michael.lowe@bigfoot.com>
    1:  *   Darin Fisher <darin@meer.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAppShell.h"
    1: #include "nsToolkit.h"
    1: #include "nsThreadUtils.h"
33519: #include "WinTaskbar.h"
36467: #include "nsString.h"
36467: 
36467: // For skidmark code
36467: #include <windows.h> 
36467: #include <tlhelp32.h> 
    1: 
23335: #ifdef WINCE
23335: BOOL WaitMessage(VOID)
23335: {
23335:   BOOL retval = TRUE;
23335:   
23335:   HANDLE hThread = GetCurrentThread();
23335:   DWORD waitRes = MsgWaitForMultipleObjectsEx(1, &hThread, INFINITE, QS_ALLEVENTS, 0);
23335:   if((DWORD)-1 == waitRes)
23335:   {
23335:     retval = FALSE;
23335:   }
23335:   
23335:   return retval;
23335: }
23335: #endif
23335: 
    1: static UINT sMsgId;
    1: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486: static UINT sTaskbarButtonCreatedMsg;
33486: 
33486: /* static */
33486: UINT nsAppShell::GetTaskbarButtonCreatedMessage() {
33486: 	return sTaskbarButtonCreatedMsg;
33486: }
33486: #endif
33486: 
    1: //-------------------------------------------------------------------------
    1: 
    1: static BOOL PeekKeyAndIMEMessage(LPMSG msg, HWND hwnd)
    1: {
    1:   MSG msg1, msg2, *lpMsg;
    1:   BOOL b1, b2;
    1:   b1 = ::PeekMessageW(&msg1, NULL, WM_KEYFIRST, WM_IME_KEYLAST, PM_NOREMOVE);
    1:   b2 = ::PeekMessageW(&msg2, NULL, WM_IME_SETCONTEXT, WM_IME_KEYUP, PM_NOREMOVE);
    1:   if (b1 || b2) {
    1:     if (b1 && b2) {
    1:       if (msg1.time < msg2.time)
    1:         lpMsg = &msg1;
    1:       else
    1:         lpMsg = &msg2;
    1:     } else if (b1)
    1:       lpMsg = &msg1;
    1:     else
    1:       lpMsg = &msg2;
    1:     return ::PeekMessageW(msg, hwnd, lpMsg->message, lpMsg->message, PM_REMOVE);
    1:   }
    1: 
    1:   return false;
    1: }
    1: 
    1: /*static*/ LRESULT CALLBACK
    1: nsAppShell::EventWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    1: {
    1:   if (uMsg == sMsgId) {
 3233:     nsAppShell *as = reinterpret_cast<nsAppShell *>(lParam);
    1:     as->NativeEventCallback();
    1:     NS_RELEASE(as);
    1:     return TRUE;
    1:   }
    1:   return DefWindowProc(hwnd, uMsg, wParam, lParam);
    1: }
    1: 
    1: nsAppShell::~nsAppShell()
    1: {
    1:   if (mEventWnd) {
    1:     // DestroyWindow doesn't do anything when called from a non UI thread.
    1:     // Since mEventWnd was created on the UI thread, it must be destroyed on
    1:     // the UI thread.
    1:     SendMessage(mEventWnd, WM_CLOSE, 0, 0);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsAppShell::Init()
    1: {
    1:   if (!sMsgId)
18534:     sMsgId = RegisterWindowMessageW(L"nsAppShell:EventID");
    1: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486:   sTaskbarButtonCreatedMsg = ::RegisterWindowMessageW(L"TaskbarButtonCreated");
33486:   NS_ASSERTION(sTaskbarButtonCreatedMsg, "Could not register taskbar button creation message");
33519: 
33519:   // Global app registration id for Win7 and up. See
33519:   // WinTaskbar.cpp for details.
33519:   mozilla::widget::WinTaskbar::SetAppUserModelID();
33486: #endif
33486: 
18534:   WNDCLASSW wc;
    1:   HINSTANCE module = GetModuleHandle(NULL);
    1: 
18534:   const PRUnichar *const kWindowClass = L"nsAppShell:EventWindowClass";
18534:   if (!GetClassInfoW(module, kWindowClass, &wc)) {
    1:     wc.style         = 0;
    1:     wc.lpfnWndProc   = EventWindowProc;
    1:     wc.cbClsExtra    = 0;
    1:     wc.cbWndExtra    = 0;
    1:     wc.hInstance     = module;
    1:     wc.hIcon         = NULL;
    1:     wc.hCursor       = NULL;
    1:     wc.hbrBackground = (HBRUSH) NULL;
18534:     wc.lpszMenuName  = (LPCWSTR) NULL;
    1:     wc.lpszClassName = kWindowClass;
18534:     RegisterClassW(&wc);
    1:   }
    1: 
18534:   mEventWnd = CreateWindowW(kWindowClass, L"nsAppShell:EventWindow",
    1:                            0, 0, 0, 10, 10, NULL, NULL, module, NULL);
    1:   NS_ENSURE_STATE(mEventWnd);
    1: 
    1:   return nsBaseAppShell::Init();
    1: }
    1: 
36467: 
36467: /**
36467:  * This is some temporary code to keep track of where in memory dlls are
36467:  * loaded. This is useful in case someone calls into a dll that has been
36467:  * unloaded. This code lets us see which dll used to be loaded at the given
36467:  * called address.
36467:  */
36467: #if defined(_MSC_VER) && defined(_M_IX86)
36467: 
36467: #define LOADEDMODULEINFO_STRSIZE 23
36467: #define NUM_LOADEDMODULEINFO 250
36467: 
36467: struct LoadedModuleInfo {
36467:   void* mStartAddr;
36467:   void* mEndAddr;
36467:   char mName[LOADEDMODULEINFO_STRSIZE + 1];
36467: };
36467: 
36467: static LoadedModuleInfo* sLoadedModules = 0;
36467: 
36467: static void
36467: CollectNewLoadedModules()
36467: {
36467:   HANDLE hModuleSnap = INVALID_HANDLE_VALUE;
36471:   MODULEENTRY32W module;
36467: 
36467:   // Take a snapshot of all modules in our process.
36467:   hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, 0);
36467:   if (hModuleSnap == INVALID_HANDLE_VALUE)
36467:     return;
36467: 
36467:   // Set the size of the structure before using it.
36471:   module.dwSize = sizeof(MODULEENTRY32W);
36467: 
36467:   // Now walk the module list of the process,
36467:   // and display information about each module
36471:   PRBool done = !Module32FirstW(hModuleSnap, &module);
36467:   while (!done) {
36467:     NS_LossyConvertUTF16toASCII moduleName(module.szModule);
36467:     PRBool found = PR_FALSE;
36467:     PRUint32 i;
36467:     for (i = 0; i < NUM_LOADEDMODULEINFO &&
36467:                 sLoadedModules[i].mStartAddr; ++i) {
36467:       if (sLoadedModules[i].mStartAddr == module.modBaseAddr &&
36467:           !strcmp(moduleName.get(),
36467:                   sLoadedModules[i].mName)) {
36467:         found = PR_TRUE;
36467:         break;
36467:       }
36467:     }
36467: 
36467:     if (!found && i < NUM_LOADEDMODULEINFO) {
36467:       sLoadedModules[i].mStartAddr = module.modBaseAddr;
36467:       sLoadedModules[i].mEndAddr = module.modBaseAddr + module.modBaseSize;
36467:       strncpy(sLoadedModules[i].mName, moduleName.get(),
36467:               LOADEDMODULEINFO_STRSIZE);
36467:       sLoadedModules[i].mName[LOADEDMODULEINFO_STRSIZE] = 0;
36467:     }
36467: 
36471:     done = !Module32NextW(hModuleSnap, &module);
36467:   }
36467: 
36467:   PRUint32 i;
36467:   for (i = 0; i < NUM_LOADEDMODULEINFO &&
36467:               sLoadedModules[i].mStartAddr; ++i) {}
36467: 
36467:   CloseHandle(hModuleSnap);
36467: }
36467: 
36467: NS_IMETHODIMP
36467: nsAppShell::Run(void)
36467: {
36467:   LoadedModuleInfo modules[NUM_LOADEDMODULEINFO];
36467:   memset(modules, 0, sizeof(modules));
36467:   sLoadedModules = modules;
36467: 
36467:   return nsBaseAppShell::Run();
36467: }
36467: 
36467: #endif
36467: 
    1: void
    1: nsAppShell::ScheduleNativeEventCallback()
    1: {
    1:   // post a message to the native event queue...
    1:   NS_ADDREF_THIS();
 3233:   ::PostMessage(mEventWnd, sMsgId, 0, reinterpret_cast<LPARAM>(this));
    1: }
    1: 
    1: PRBool
    1: nsAppShell::ProcessNextNativeEvent(PRBool mayWait)
    1: {
36467: #if defined(_MSC_VER) && defined(_M_IX86)
36467:   if (sXPCOMHasLoadedNewDLLs && sLoadedModules) {
36467:     sXPCOMHasLoadedNewDLLs = PR_FALSE;
36467:     CollectNewLoadedModules();
36467:   }
36467: #endif
36467: 
    1:   PRBool gotMessage = PR_FALSE;
    1: 
    1:   do {
    1:     MSG msg;
 3617:     // Give priority to system messages (in particular keyboard, mouse, timer,
 3617:     // and paint messages).
    1:     if (PeekKeyAndIMEMessage(&msg, NULL) ||
    1:         ::PeekMessageW(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE) || 
    1:         ::PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE)) {
    1:       gotMessage = PR_TRUE;
    1:       if (msg.message == WM_QUIT) {
16538:         ::PostQuitMessage(msg.wParam);
    1:         Exit();
    1:       } else {
    1:         ::TranslateMessage(&msg);
    1:         ::DispatchMessageW(&msg);
    1:       }
    1:     } else if (mayWait) {
    1:       // Block and wait for any posted application message
    1:       ::WaitMessage();
    1:     }
    1:   } while (!gotMessage && mayWait);
    1: 
    1:   return gotMessage;
    1: }
