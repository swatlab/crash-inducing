   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Pierre Phaneuf <pp@ludusdesign.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: #include "nsTableOuterFrame.h"
   1: #include "nsTableFrame.h"
   1: #include "nsStyleContext.h"
   1: #include "nsStyleConsts.h"
   1: #include "nsPresContext.h"
   1: #include "nsIRenderingContext.h"
   1: #include "nsCSSRendering.h"
   1: #include "nsIContent.h"
   1: #include "prinrval.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsHTMLParts.h"
   1: #include "nsIPresShell.h"
   1: #ifdef ACCESSIBILITY
   1: #include "nsIAccessibilityService.h"
   1: #endif
   1: #include "nsIServiceManager.h"
   1: #include "nsIDOMNode.h"
   1: #include "nsDisplayList.h"
   1: #include "nsLayoutUtils.h"
   1: 
   1: /* ----------- nsTableCaptionFrame ---------- */
   1: 
   1: #define NS_TABLE_FRAME_CAPTION_LIST_INDEX 0
   1: #define NO_SIDE 100
   1: 
   1: // caption frame
   1: nsTableCaptionFrame::nsTableCaptionFrame(nsStyleContext* aContext):
   1:   nsBlockFrame(aContext)
   1: {
   1:   // shrink wrap 
   1:   SetFlags(NS_BLOCK_SPACE_MGR);
   1: }
   1: 
   1: nsTableCaptionFrame::~nsTableCaptionFrame()
   1: {
   1: }
   1: 
   1: nsIAtom*
   1: nsTableCaptionFrame::GetType() const
   1: {
   1:   return nsGkAtoms::tableCaptionFrame;
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsTableOuterFrame::GetBaseline() const
   1: {
   1:   nsIFrame* kid = mFrames.FirstChild();
   1:   if (!kid) {
   1:     NS_NOTREACHED("no inner table");
   1:     return nsHTMLContainerFrame::GetBaseline();
   1:   }
   1: 
   1:   return kid->GetBaseline() + kid->GetPosition().y;
   1: }
   1: 
   1: inline PRBool IsSideCaption(nsIFrame* aCaptionFrame)
   1: {
   1:   PRUint8 captionSide = aCaptionFrame->GetStyleTableBorder()->mCaptionSide;
   1:   return captionSide == NS_SIDE_LEFT || captionSide == NS_SIDE_RIGHT;
   1: }
   1: 
   1: /* virtual */ nsSize
   1: nsTableCaptionFrame::ComputeAutoSize(nsIRenderingContext *aRenderingContext,
   1:                                      nsSize aCBSize, nscoord aAvailableWidth,
   1:                                      nsSize aMargin, nsSize aBorder,
   1:                                      nsSize aPadding, PRBool aShrinkWrap)
   1: {
   1:   nsSize result = nsBlockFrame::ComputeAutoSize(aRenderingContext, aCBSize,
   1:                     aAvailableWidth, aMargin, aBorder, aPadding, aShrinkWrap);
   1:   if (IsSideCaption(this)) {
   1:     result.width = GetMinWidth(aRenderingContext);
   1:   }
   1:   return result;
   1: }
   1: 
 706: NS_IMETHODIMP 
 706: nsTableCaptionFrame::GetParentStyleContextFrame(nsPresContext* aPresContext,
 706:                                                 nsIFrame**      aProviderFrame,
 706:                                                 PRBool*         aIsChild)
 706: {
1270:   NS_PRECONDITION(mContent->GetParent(),
1270:                   "How could we not have a parent here?");
1270:     
 706:   // The caption's style context parent is the inner frame, unless
 706:   // it's anonymous.
 706:   nsIFrame* outerFrame = GetParent();
 706:   if (outerFrame && outerFrame->GetType() == nsGkAtoms::tableOuterFrame) {
 706:     nsIFrame* innerFrame = outerFrame->GetFirstChild(nsnull);
 706:     if (innerFrame) {
 706:       *aProviderFrame =
 706:         nsFrame::CorrectStyleParentFrame(innerFrame,
 706:                                          GetStyleContext()->GetPseudoType());
 706:       *aIsChild = PR_FALSE;
 706:       return NS_OK;
 706:     }
 706:   }
 706: 
 706:   NS_NOTREACHED("Where is our inner table frame?");
 706:   return nsBlockFrame::GetParentStyleContextFrame(aPresContext, aProviderFrame,
 706:                                                   aIsChild);
 706: }
 706: 
3151: #ifdef ACCESSIBILITY
3151: NS_IMETHODIMP nsTableCaptionFrame::GetAccessible(nsIAccessible** aAccessible)
3151: {
3151:   *aAccessible = nsnull;
3151:   if (!GetRect().IsEmpty()) {
3151:     nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
3151:     if (accService) {
3151:       return accService->CreateHTMLCaptionAccessible(NS_STATIC_CAST(nsIFrame*, this), aAccessible);
3151:     }
3151:   }
3151: 
3151:   return NS_ERROR_FAILURE;
3151: }
3151: #endif
3151: 
   1: #ifdef NS_DEBUG
   1: NS_IMETHODIMP
   1: nsTableCaptionFrame::GetFrameName(nsAString& aResult) const
   1: {
   1:   return MakeFrameName(NS_LITERAL_STRING("Caption"), aResult);
   1: }
   1: #endif
   1: 
   1: nsIFrame* 
   1: NS_NewTableCaptionFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsTableCaptionFrame(aContext);
   1: }
   1: 
   1: /* ----------- nsTableOuterFrame ---------- */
   1: 
   1: NS_IMPL_ADDREF_INHERITED(nsTableOuterFrame, nsHTMLContainerFrame)
   1: NS_IMPL_RELEASE_INHERITED(nsTableOuterFrame, nsHTMLContainerFrame)
   1: 
   1: nsTableOuterFrame::nsTableOuterFrame(nsStyleContext* aContext):
   1:   nsHTMLContainerFrame(aContext)
   1: {
   1: }
   1: 
   1: nsTableOuterFrame::~nsTableOuterFrame()
   1: {
   1: }
   1: 
3114: NS_IMETHODIMP
3114: nsTableOuterFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
   1: {
3114:   NS_PRECONDITION(aInstancePtr, "null out param");
   1: 
3114:   if (aIID.Equals(NS_GET_IID(nsITableLayout))) {
3114:     *aInstancePtr = NS_STATIC_CAST(nsITableLayout*, this);
   1:     return NS_OK;
   1:   }
   1: 
   1:   return nsHTMLContainerFrame::QueryInterface(aIID, aInstancePtr);
   1: }
   1: 
   1: #ifdef ACCESSIBILITY
   1: NS_IMETHODIMP nsTableOuterFrame::GetAccessible(nsIAccessible** aAccessible)
   1: {
   1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
   1: 
   1:   if (accService) {
   1:     return accService->CreateHTMLTableAccessible(NS_STATIC_CAST(nsIFrame*, this), aAccessible);
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: #endif
   1: 
   1: /* virtual */ PRBool
   1: nsTableOuterFrame::IsContainingBlock() const
   1: {
   1:   return PR_FALSE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTableOuterFrame::Init(
   1:                    nsIContent*           aContent,
   1:                    nsIFrame*             aParent,
   1:                    nsIFrame*             aPrevInFlow)
   1: {
   1:   nsresult rv = nsHTMLContainerFrame::Init(aContent, aParent, aPrevInFlow);
   1:   
   1:   // record that children that are ignorable whitespace should be excluded 
   1:   mState |= NS_FRAME_EXCLUDE_IGNORABLE_WHITESPACE;
   1: 
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsTableOuterFrame::Destroy()
   1: {
   1:   mCaptionFrames.DestroyFrames();
   1:   nsHTMLContainerFrame::Destroy();
   1: }
   1: 
   1: nsIFrame*
   1: nsTableOuterFrame::GetFirstChild(nsIAtom* aListName) const
   1: {
   1:   if (nsGkAtoms::captionList == aListName) {
   1:     return mCaptionFrames.FirstChild();
   1:   }
   1:   if (!aListName) {
   1:     return mFrames.FirstChild();
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: nsIAtom*
   1: nsTableOuterFrame::GetAdditionalChildListName(PRInt32 aIndex) const
   1: {
   1:   if (aIndex == NS_TABLE_FRAME_CAPTION_LIST_INDEX) {
   1:     return nsGkAtoms::captionList;
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsTableOuterFrame::SetInitialChildList(nsIAtom*        aListName,
   1:                                        nsIFrame*       aChildList)
   1: {
   1:   if (nsGkAtoms::captionList == aListName) {
   1:     // the frame constructor already checked for table-caption display type
   1:     mCaptionFrames.SetFrames(aChildList);
   1:     mCaptionFrame  = mCaptionFrames.FirstChild();
   1:   }
   1:   else {
   1:     NS_ASSERTION(!aListName, "wrong childlist");
   1:     NS_ASSERTION(mFrames.IsEmpty(), "Frame leak!");
   1:     mFrames.SetFrames(aChildList);
   1:     mInnerTableFrame = nsnull;
   1:     if (aChildList) {
   1:       if (nsGkAtoms::tableFrame == aChildList->GetType()) {
   1:         mInnerTableFrame = (nsTableFrame*)aChildList;
   1:       }
   1:       else {
   1:         NS_ERROR("expected a table frame");
   1:         return NS_ERROR_INVALID_ARG;
   1:       }
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTableOuterFrame::AppendFrames(nsIAtom*        aListName,
   1:                                 nsIFrame*       aFrameList)
   1: {
   1:   nsresult rv;
   1: 
   1:   // We only have two child frames: the inner table and a caption frame.
   1:   // The inner frame is provided when we're initialized, and it cannot change
   1:   if (nsGkAtoms::captionList == aListName) {
   1:     NS_ASSERTION(!aFrameList ||
   1:                  aFrameList->GetType() == nsGkAtoms::tableCaptionFrame,
   1:                  "appending non-caption frame to captionList");
   1:     mCaptionFrames.AppendFrames(this, aFrameList);
   1:     mCaptionFrame = mCaptionFrames.FirstChild();
   1:     rv = NS_OK;
   1: 
   1:     // Reflow the new caption frame. It's already marked dirty, so
   1:     // just tell the pres shell.
 238:     PresContext()->PresShell()->
1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
1158:                        NS_FRAME_HAS_DIRTY_CHILDREN);
   1:   }
   1:   else {
   1:     NS_PRECONDITION(PR_FALSE, "unexpected child list");
   1:     rv = NS_ERROR_UNEXPECTED;
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTableOuterFrame::InsertFrames(nsIAtom*        aListName,
   1:                                 nsIFrame*       aPrevFrame,
   1:                                 nsIFrame*       aFrameList)
   1: {
   1:   if (nsGkAtoms::captionList == aListName) {
   1:     NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
   1:                  "inserting after sibling frame with different parent");
   1:     NS_ASSERTION(!aFrameList ||
   1:                  aFrameList->GetType() == nsGkAtoms::tableCaptionFrame,
   1:                  "inserting non-caption frame into captionList");
   1:     mCaptionFrames.InsertFrames(nsnull, aPrevFrame, aFrameList);
   1:     mCaptionFrame = mCaptionFrames.FirstChild();
   1:     return NS_OK;
   1:   }
   1:   else {
   1:     NS_PRECONDITION(!aPrevFrame, "invalid previous frame");
   1:     return AppendFrames(aListName, aFrameList);
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTableOuterFrame::RemoveFrame(nsIAtom*        aListName,
   1:                                nsIFrame*       aOldFrame)
   1: {
   1:   // We only have two child frames: the inner table and one caption frame.
   1:   // The inner frame can't be removed so this should be the caption
   1:   NS_PRECONDITION(nsGkAtoms::captionList == aListName, "can't remove inner frame");
   1: 
   1:   PRUint8 captionSide = GetCaptionSide();
   1: 
   1:   if (NS_SIDE_LEFT == captionSide || NS_SIDE_RIGHT == captionSide) {
   1:     // The old caption width had an effect on the inner table width so
   1:     // we're going to need to reflow it. Mark it dirty
   1:     mInnerTableFrame->AddStateBits(NS_FRAME_IS_DIRTY);
   1:   }
   1: 
   1:   // Remove the frame and destroy it
   1:   mCaptionFrames.DestroyFrame(aOldFrame);
   1:   mCaptionFrame = mCaptionFrames.FirstChild();
   1:   
 238:   PresContext()->PresShell()->
1158:     FrameNeedsReflow(this, nsIPresShell::eTreeChange,
1158:                      NS_FRAME_HAS_DIRTY_CHILDREN); // also means child removed
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_METHOD 
   1: nsTableOuterFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                                     const nsRect&           aDirtyRect,
   1:                                     const nsDisplayListSet& aLists)
   1: {
   1:   // No border, background or outline are painted because they all belong
   1:   // to the inner table.
   1:   if (!IsVisibleInSelection(aBuilder))
   1:     return NS_OK;
   1: 
   1:   // If there's no caption, take a short cut to avoid having to create
   1:   // the special display list set and then sort it.
   1:   if (!mCaptionFrame)
   1:     return BuildDisplayListForInnerTable(aBuilder, aDirtyRect, aLists);
   1:     
   1:   nsDisplayListCollection set;
   1:   nsresult rv = BuildDisplayListForInnerTable(aBuilder, aDirtyRect, set);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   nsDisplayListSet captionSet(set, set.BlockBorderBackgrounds());
   1:   rv = BuildDisplayListForChild(aBuilder, mCaptionFrame, aDirtyRect, captionSet);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   // Now we have to sort everything by content order, since the caption
   1:   // may be somewhere inside the table
   1:   set.SortAllByContentOrder(aBuilder, GetContent());
   1:   set.MoveTo(aLists);
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTableOuterFrame::BuildDisplayListForInnerTable(nsDisplayListBuilder*   aBuilder,
   1:                                                  const nsRect&           aDirtyRect,
   1:                                                  const nsDisplayListSet& aLists)
   1: {
   1:   // Just paint the regular children, but the children's background is our
   1:   // true background (there should only be one, the real table)
   1:   nsIFrame* kid = mFrames.FirstChild();
   1:   // The children should be in content order
   1:   while (kid) {
   1:     nsresult rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     kid = kid->GetNextSibling();
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTableOuterFrame::SetSelected(nsPresContext* aPresContext,
   1:                                              nsIDOMRange *aRange,
   1:                                              PRBool aSelected,
   1:                                              nsSpread aSpread)
   1: {
   1:   nsresult result = nsFrame::SetSelected(aPresContext, aRange,aSelected, aSpread);
   1:   if (NS_SUCCEEDED(result) && mInnerTableFrame)
   1:     return mInnerTableFrame->SetSelected(aPresContext, aRange,aSelected, aSpread);
   1:   return result;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsTableOuterFrame::GetParentStyleContextFrame(nsPresContext* aPresContext,
   1:                                               nsIFrame**      aProviderFrame,
   1:                                               PRBool*         aIsChild)
   1: {
   1:   // The table outer frame and the (inner) table frame split the style
   1:   // data by giving the table frame the style context associated with
   1:   // the table content node and creating a style context for the outer
   1:   // frame that is a *child* of the table frame's style context,
   1:   // matching the ::-moz-table-outer pseudo-element.  html.css has a
   1:   // rule that causes that pseudo-element (and thus the outer table)
   1:   // to inherit *some* style properties from the table frame.  The
   1:   // children of the table inherit directly from the inner table, and
   1:   // the outer table's style context is a leaf.
   1: 
   1:   if (!mInnerTableFrame) {
   1:     *aProviderFrame = this;
   1:     *aIsChild = PR_FALSE;
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   *aProviderFrame = mInnerTableFrame;
   1:   *aIsChild = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: // INCREMENTAL REFLOW HELPER FUNCTIONS 
   1: 
   1: void
   1: nsTableOuterFrame::InitChildReflowState(nsPresContext&    aPresContext,                     
   1:                                         nsHTMLReflowState& aReflowState)
   1:                                     
   1: {
   1:   nsMargin collapseBorder;
   1:   nsMargin collapsePadding(0,0,0,0);
   1:   nsMargin* pCollapseBorder  = nsnull;
   1:   nsMargin* pCollapsePadding = nsnull;
   1:   if ((aReflowState.frame == mInnerTableFrame) && (mInnerTableFrame->IsBorderCollapse())) {
   1:     collapseBorder  = mInnerTableFrame->GetIncludedOuterBCBorder();
   1:     pCollapseBorder = &collapseBorder;
   1:     pCollapsePadding = &collapsePadding;
   1:   }
   1:   aReflowState.Init(&aPresContext, -1, -1, pCollapseBorder, pCollapsePadding);
   1: }
   1: 
   1: // get the margin and padding data. nsHTMLReflowState doesn't handle the
   1: // case of auto margins
   1: void
   1: nsTableOuterFrame::GetMargin(nsPresContext*           aPresContext,
   1:                              const nsHTMLReflowState& aOuterRS,
   1:                              nsIFrame*                aChildFrame,
   1:                              nscoord                  aAvailWidth,
   1:                              nsMargin&                aMargin)
   1: {
   1:   // construct a reflow state to compute margin and padding. Auto margins
   1:   // will not be computed at this time.
   1: 
   1:   // create and init the child reflow state
   1:   // XXX We really shouldn't construct a reflow state to do this.
   1:   nsHTMLReflowState childRS(aPresContext, aOuterRS, aChildFrame,
   1:                             nsSize(aAvailWidth, aOuterRS.availableHeight),
   1:                             -1, -1, PR_FALSE);
   1:   InitChildReflowState(*aPresContext, childRS);
   1: 
   1:   aMargin = childRS.mComputedMargin;
   1: }
   1: 
   1: static
   1: nscoord CalcAutoMargin(nscoord aAutoMargin,
   1:                        nscoord aOppositeMargin,
   1:                        nscoord aContainBlockSize,
   1:                        nscoord aFrameSize)
   1: {
   1:   nscoord margin;
   1:   if (NS_AUTOMARGIN == aOppositeMargin) 
   1:     margin = (aContainBlockSize - aFrameSize) / 2;
   1:   else {
   1:     margin = aContainBlockSize - aFrameSize - aOppositeMargin;
   1:   }
   1:   return PR_MAX(0, margin);
   1: }
   1: 
   1: static nsSize
   1: GetContainingBlockSize(const nsHTMLReflowState& aOuterRS)
   1: {
   1:   nsSize size(0,0);
   1:   const nsHTMLReflowState* containRS =
   1:     aOuterRS.mCBReflowState;
   1: 
   1:   if (containRS) {
   1:     size.width = containRS->ComputedWidth();
   1:     if (NS_UNCONSTRAINEDSIZE == size.width) {
   1:       size.width = 0;
   1:     }
   1:     size.height = containRS->mComputedHeight;
   1:     if (NS_UNCONSTRAINEDSIZE == size.height) {
   1:       size.height = 0;
   1:     }
   1:   }
   1:   return size;
   1: }
   1: 
   1: void
   1: nsTableOuterFrame::InvalidateDamage(PRUint8         aCaptionSide,
   1:                                     const nsSize&   aOuterSize,
   1:                                     PRBool          aInnerChanged,
   1:                                     PRBool          aCaptionChanged,
   1:                                     nsRect*         aOldOverflowArea)
   1: {
   1:   if (!aInnerChanged && !aCaptionChanged) return;
   1: 
   1:   nsRect damage;
   1:   if (aInnerChanged && aCaptionChanged) {
   1:     damage = nsRect(0, 0, aOuterSize.width, aOuterSize.height);
   1:     if (aOldOverflowArea) {
   1:       damage.UnionRect(damage, *aOldOverflowArea);
   1:     }
   1:     nsRect* overflowArea = GetOverflowAreaProperty();
   1:     if (overflowArea) {
   1:       damage.UnionRect(damage, *overflowArea);
   1:     }
   1:   }
   1:   else {
   1:     nsRect captionRect(0,0,0,0);
   1:     nsRect innerRect = mInnerTableFrame->GetRect();
   1:     if (mCaptionFrame) {
   1:       captionRect = mCaptionFrame->GetRect();
   1:     }
   1:     
   1:     damage.x = 0;
   1:     damage.width  = aOuterSize.width;
   1:     switch(aCaptionSide) {
   1:     case NS_SIDE_BOTTOM:
   1:       if (aCaptionChanged) {
   1:         damage.y = innerRect.y;
   1:         damage.height = aOuterSize.height - damage.y;
   1:       }
   1:       else { // aInnerChanged 
   1:         damage.y = 0;
   1:         damage.height = captionRect.y;
   1:       }
   1:       break;
   1:     case NS_SIDE_LEFT:
   1:       if (aCaptionChanged) {
   1:         damage.width = innerRect.x;
   1:         damage.y = 0;
   1:         damage.height = captionRect.YMost();
   1:       }
   1:       else { // aInnerChanged
   1:         damage.x = captionRect.XMost();
   1:         damage.width = innerRect.XMost() - damage.x;
   1:         damage.y = 0;
   1:         damage.height = innerRect.YMost();
   1:       }
   1:       break;
   1:     case NS_SIDE_RIGHT:
   1:      if (aCaptionChanged) {
   1:         damage.x = innerRect.XMost();
   1:         damage.width -= damage.x;
   1:         damage.y = 0;
   1:         damage.height = captionRect.YMost();
   1:       }
   1:      else { // aInnerChanged
   1:         damage.width -= captionRect.width;
   1:         damage.y = 0;
   1:         damage.height = innerRect.YMost();
   1:       }
   1:       break;
   1:     default: // NS_SIDE_TOP
   1:       if (aCaptionChanged) {
   1:         damage.y = 0;
   1:         damage.height = innerRect.y;
   1:       }
   1:       else { // aInnerChanged
   1:         damage.y = captionRect.y;
   1:         damage.height = aOuterSize.height - damage.y;
   1:       }
   1:       break;
   1:     }
   1:      
   1:     nsIFrame* kidFrame = aCaptionChanged ? mCaptionFrame : mInnerTableFrame;
   1:     ConsiderChildOverflow(damage, kidFrame);
   1:     if (aOldOverflowArea) {
   1:       damage.UnionRect(damage, *aOldOverflowArea);
   1:     }
   1:   }
   1:   Invalidate(damage);
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsTableOuterFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
   1: {
   1:   nscoord width = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
   1:                     mInnerTableFrame, nsLayoutUtils::MIN_WIDTH);
   1:   DISPLAY_MIN_WIDTH(this, width);
   1:   if (mCaptionFrame) {
   1:     nscoord capWidth =
   1:       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mCaptionFrame,
   1:                                            nsLayoutUtils::MIN_WIDTH);
   1:     switch(GetCaptionSide()) {
   1:     case NS_SIDE_LEFT:
   1:     case NS_SIDE_RIGHT:
   1:       width += capWidth;
   1:       break;
   1:     default:
   1:       if (capWidth > width) {
   1:         width = capWidth;
   1:       }
   1:     }
   1:   }
   1:   return width;
   1: }
   1: 
   1: /* virtual */ nscoord
   1: nsTableOuterFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
   1: {
   1:   nscoord maxWidth;
   1:   DISPLAY_PREF_WIDTH(this, maxWidth);
   1: 
   1:   maxWidth = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
   1:                mInnerTableFrame, nsLayoutUtils::PREF_WIDTH);
   1:   if (mCaptionFrame) {
   1:     PRUint8 captionSide = GetCaptionSide();
   1:     switch(captionSide) {
   1:     case NS_SIDE_LEFT:
   1:     case NS_SIDE_RIGHT:
   1:       {
   1:         nscoord capMin =
   1:           nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mCaptionFrame,
   1:                                                nsLayoutUtils::MIN_WIDTH);
   1:         maxWidth += capMin;
   1:       }
   1:       break;
   1:     case NS_SIDE_TOP:
   1:     case NS_SIDE_BOTTOM:
   1:     default:  // no caption 
   1:       {
   1:         nscoord capPref =
   1:           nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mCaptionFrame,
   1:                                                nsLayoutUtils::PREF_WIDTH);
   1:         maxWidth = PR_MAX(maxWidth, capPref);
   1:       }
   1:     }
   1:   }
   1:   return maxWidth;
   1: }
   1: 
   1: /* virtual */ nsSize
   1: nsTableOuterFrame::ComputeAutoSize(nsIRenderingContext *aRenderingContext,
   1:                                    nsSize aCBSize, nscoord aAvailableWidth,
   1:                                    nsSize aMargin, nsSize aBorder,
   1:                                    nsSize aPadding, PRBool aShrinkWrap)
   1: {
   1:   if (!aShrinkWrap)
   1:     return nsHTMLContainerFrame::ComputeAutoSize(aRenderingContext, aCBSize,
   1:                aAvailableWidth, aMargin, aBorder, aPadding, aShrinkWrap);
   1: 
   1:   // When we're shrink-wrapping, our auto size needs to wrap around the
   1:   // actual size of the table, which (if it is specified as a percent)
   1:   // could be something that is not reflected in our GetMinWidth and
   1:   // GetPrefWidth.  See bug 349457 for an example.
   1: 
   1:   // The outer table's children do not use it as a containing block.
   1:   nsCSSOffsetState innerOffsets(mInnerTableFrame, aRenderingContext,
   1:                                 aCBSize.width);
   1:   nsSize tableSize = mInnerTableFrame->ComputeSize(aRenderingContext, aCBSize,
   1:                        aAvailableWidth,
   1:                        nsSize(innerOffsets.mComputedMargin.LeftRight(),
   1:                               innerOffsets.mComputedMargin.TopBottom()),
   1:                        nsSize(innerOffsets.mComputedBorderPadding.LeftRight() -
   1:                                 innerOffsets.mComputedPadding.LeftRight(),
   1:                               innerOffsets.mComputedBorderPadding.TopBottom() -
   1:                                 innerOffsets.mComputedPadding.TopBottom()),
   1:                        nsSize(innerOffsets.mComputedPadding.LeftRight(),
   1:                               innerOffsets.mComputedPadding.TopBottom()),
   1:                        aShrinkWrap);
   1:   nscoord width = tableSize.width + innerOffsets.mComputedMargin.LeftRight() +
   1:                   innerOffsets.mComputedBorderPadding.LeftRight();
   1: 
   1:   if (mCaptionFrame) {
   1:     nsCSSOffsetState capOffsets(mCaptionFrame, aRenderingContext,
   1:                                 aCBSize.width);
   1:     nsSize capSize = mCaptionFrame->ComputeSize(aRenderingContext, aCBSize,
   1:                        aAvailableWidth,
   1:                        nsSize(capOffsets.mComputedMargin.LeftRight(),
   1:                               capOffsets.mComputedMargin.TopBottom()),
   1:                        nsSize(capOffsets.mComputedBorderPadding.LeftRight() -
   1:                                 capOffsets.mComputedPadding.LeftRight(),
   1:                               capOffsets.mComputedBorderPadding.TopBottom() -
   1:                                 capOffsets.mComputedPadding.TopBottom()),
   1:                        nsSize(capOffsets.mComputedPadding.LeftRight(),
   1:                               capOffsets.mComputedPadding.TopBottom()),
   1:                        aShrinkWrap);
   1:     PRUint8 captionSide = GetCaptionSide();
   1:     nscoord capWidth = capSize.width + capOffsets.mComputedMargin.LeftRight() +
   1:                        capOffsets.mComputedBorderPadding.LeftRight();
   1:     if (captionSide == NS_SIDE_LEFT || captionSide == NS_SIDE_RIGHT) {
   1:       width += capWidth;
   1:     } else {
   1:       if (capWidth > width)
   1:         width = capWidth;
   1:     }
   1:   }
   1: 
   1:   return nsSize(width, NS_UNCONSTRAINEDSIZE);
   1: }
   1: 
   1: PRUint8
   1: nsTableOuterFrame::GetCaptionSide()
   1: {
   1:   if (mCaptionFrame) {
   1:     return mCaptionFrame->GetStyleTableBorder()->mCaptionSide;
   1:   }
   1:   else {
   1:     return NO_SIDE; // no caption
   1:   }
   1: }
   1: 
   1: PRUint8
   1: nsTableOuterFrame::GetCaptionVerticalAlign()
   1: {
   1:   const nsStyleCoord& va = mCaptionFrame->GetStyleTextReset()->mVerticalAlign;
   1:   return (va.GetUnit() == eStyleUnit_Enumerated)
   1:            ? va.GetIntValue()
   1:            : NS_STYLE_VERTICAL_ALIGN_TOP;
   1: }
   1: 
   1: void
   1: nsTableOuterFrame::SetDesiredSize(PRUint8         aCaptionSide,
   1:                                   const nsMargin& aInnerMargin,
   1:                                   const nsMargin& aCaptionMargin,
   1:                                   nscoord&        aWidth,
   1:                                   nscoord&        aHeight)
   1: {
   1:   aWidth = aHeight = 0;
   1: 
   1:   nsRect innerRect = mInnerTableFrame->GetRect();
   1:   nscoord innerWidth = innerRect.width;
   1: 
   1:   nsRect captionRect(0,0,0,0);
   1:   nscoord captionWidth = 0;
   1:   if (mCaptionFrame) {
   1:     captionRect = mCaptionFrame->GetRect();
   1:     captionWidth = captionRect.width;
   1:   }
   1:   switch(aCaptionSide) {
   1:     case NS_SIDE_LEFT:
   1:       aWidth = PR_MAX(aInnerMargin.left, aCaptionMargin.left + captionWidth + aCaptionMargin.right) +
   1:                innerWidth + aInnerMargin.right;
   1:       break;
   1:     case NS_SIDE_RIGHT:
   1:       aWidth = PR_MAX(aInnerMargin.right, aCaptionMargin.left + captionWidth + aCaptionMargin.right) +
   1:                innerWidth + aInnerMargin.left;
   1:       break;
   1:     default:
   1:       aWidth = aInnerMargin.left + innerWidth + aInnerMargin.right;
   1:       aWidth = PR_MAX(aWidth, captionRect.XMost() + aCaptionMargin.right);
   1:   }
   1:   aHeight = innerRect.YMost() + aInnerMargin.bottom;
   1:   aHeight = PR_MAX(aHeight, captionRect.YMost() + aCaptionMargin.bottom);
   1: 
   1: }
   1: 
   1: // XXX This is now unused, but it probably should be used!
   1: void
   1: nsTableOuterFrame::BalanceLeftRightCaption(PRUint8         aCaptionSide,
   1:                                            const nsMargin& aInnerMargin,
   1:                                            const nsMargin& aCaptionMargin,
   1:                                            nscoord&        aInnerWidth, 
   1:                                            nscoord&        aCaptionWidth)
   1: {
   1:   
   1:   /* balance the caption and inner table widths to ensure space for percent widths
   1:   *  Percent widths for captions or the inner table frame can determine how much of the
   1:   *  available width is used and how the available width is distributed between those frames
   1:   *  The inner table frame has already a quite sophisticated treatment of percentage widths 
   1:   *  (see BasicTableLayoutStrategy.cpp). So it acts as master in the below computations.
   1:   *  There are four possible scenarios 
   1:   *  a) None of the frames have a percentage width - then the aInnerWidth and aCaptionwidth will not change
   1:   *  b) Only the inner frame has a percentage width - this is handled in BasicTableLayoutStrategy.cpp, 
   1:   *     both widths will not change
   1:   *  c) Only the caption has a percentage width - then the overall width (ow) will be different depending on
   1:   *     the caption side. For the left side
   1:   *     ow = aCaptionMargin.left + aCaptionWidth + aCaptionMargin.right + aInnerwidth + aInnerMargin.right
   1:   *     aCaptionWidth = capPercent * ow
   1:   *     solving this equation for aCaptionWidth gives:
   1:   *     aCaptionWidth = capPercent/(1-capPercent) * 
   1:   *                      (aCaptionMargin.left + aCaptionMargin.right + aInnerwidth + aInnerMargin.right)
   1:   *     this result will cause problems for capPercent >= 1, in these cases the algorithm will now bail out
   1:   *     a similar expression can be found for the right case
   1:   *  d) both frames have percent widths in this case the caption width will be the inner width multiplied 
   1:   *     by the weight capPercent/innerPercent
   1:   */
   1:     
   1: 
   1:   float capPercent   = -1.0;
   1:   float innerPercent = -1.0;
   1:   const nsStylePosition* position = mCaptionFrame->GetStylePosition();
   1:   if (eStyleUnit_Percent == position->mWidth.GetUnit()) {
   1:     capPercent = position->mWidth.GetPercentValue();
   1:     if (capPercent >= 1.0)
   1:       return;
   1:   }
   1: 
   1:   position = mInnerTableFrame->GetStylePosition();
   1:   if (eStyleUnit_Percent == position->mWidth.GetUnit()) {
   1:     innerPercent = position->mWidth.GetPercentValue();
   1:     if (innerPercent >= 1.0)
   1:       return;
   1:   }
   1: 
   1:   if ((capPercent <= 0.0) && (innerPercent <= 0.0))
   1:     return;
   1: 
   1:   
   1:   if (innerPercent <= 0.0) {
   1:     if (NS_SIDE_LEFT == aCaptionSide) 
   1:       aCaptionWidth= (nscoord) ((capPercent / (1.0 - capPercent)) * (aCaptionMargin.left + aCaptionMargin.right + 
   1:                                                           aInnerWidth + aInnerMargin.right));
   1:     else
   1:       aCaptionWidth= (nscoord) ((capPercent / (1.0 - capPercent)) * (aCaptionMargin.left + aCaptionMargin.right + 
   1:                                                           aInnerWidth + aInnerMargin.left)); 
   1:   } 
   1:   else {
   1:     aCaptionWidth = (nscoord) ((capPercent / innerPercent) * aInnerWidth);
   1:   }
   1: }
   1: 
   1: nsresult 
   1: nsTableOuterFrame::GetCaptionOrigin(PRUint32         aCaptionSide,
   1:                                     const nsSize&    aContainBlockSize,
   1:                                     const nsSize&    aInnerSize, 
   1:                                     const nsMargin&  aInnerMargin,
   1:                                     const nsSize&    aCaptionSize,
   1:                                     nsMargin&        aCaptionMargin,
   1:                                     nsPoint&         aOrigin)
   1: {
   1:   aOrigin.x = aOrigin.y = 0;
   1:   if ((NS_UNCONSTRAINEDSIZE == aInnerSize.width) || (NS_UNCONSTRAINEDSIZE == aInnerSize.height) ||  
   1:       (NS_UNCONSTRAINEDSIZE == aCaptionSize.width) || (NS_UNCONSTRAINEDSIZE == aCaptionSize.height)) {
   1:     return NS_OK;
   1:   }
   1:   if (!mCaptionFrame) return NS_OK;
   1: 
   1:   switch(aCaptionSide) {
   1:   case NS_SIDE_BOTTOM: {
   1:     if (NS_AUTOMARGIN == aCaptionMargin.left) {
   1:       aCaptionMargin.left = CalcAutoMargin(aCaptionMargin.left, aCaptionMargin.right,
   1:                                            aContainBlockSize.width, aCaptionSize.width);
   1:     }
   1:     aOrigin.x = aCaptionMargin.left;
   1:     if (NS_AUTOMARGIN == aCaptionMargin.top) {
   1:       aCaptionMargin.top = 0;
   1:     }
   1:     nsCollapsingMargin marg;
   1:     marg.Include(aCaptionMargin.top);
   1:     marg.Include(aInnerMargin.bottom);
   1:     nscoord collapseMargin = marg.get();
   1:     if (NS_AUTOMARGIN == aCaptionMargin.bottom) {
   1:       nscoord height = aInnerSize.height + collapseMargin + aCaptionSize.height;
   1:       aCaptionMargin.bottom = CalcAutoMargin(aCaptionMargin.bottom, aInnerMargin.top,
   1:                                              aContainBlockSize.height, height);
   1:     }
   1:     aOrigin.y = aInnerMargin.top + aInnerSize.height + collapseMargin;
   1:   } break;
   1:   case NS_SIDE_LEFT: {
   1:     if (NS_AUTOMARGIN == aCaptionMargin.left) {
   1:       if (NS_AUTOMARGIN != aInnerMargin.left) {
   1:         aCaptionMargin.left = CalcAutoMargin(aCaptionMargin.left, aCaptionMargin.right,
   1:                                              aInnerMargin.left, aCaptionSize.width);
   1:       } 
   1:       else {
   1:         // zero for now
   1:         aCaptionMargin.left = 0;
   1:       } 
   1:     }
   1:     aOrigin.x = aCaptionMargin.left;
   1:     aOrigin.y = aInnerMargin.top;
   1:     switch(GetCaptionVerticalAlign()) {
   1:       case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
   1:         aOrigin.y = PR_MAX(0, aInnerMargin.top + ((aInnerSize.height - aCaptionSize.height) / 2));
   1:         break;
   1:       case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
   1:         aOrigin.y = PR_MAX(0, aInnerMargin.top + aInnerSize.height - aCaptionSize.height);
   1:         break;
   1:       default:
   1:         break;
   1:     }
   1:   } break;
   1:   case NS_SIDE_RIGHT: {
   1:     if (NS_AUTOMARGIN == aCaptionMargin.left) {
   1:       if (NS_AUTOMARGIN != aInnerMargin.right) {
   1:         aCaptionMargin.left = CalcAutoMargin(aCaptionMargin.left, aCaptionMargin.right,
   1:                                              aInnerMargin.right, aCaptionSize.width);
   1:       }
   1:       else {
   1:        // zero for now
   1:        aCaptionMargin.left = 0;
   1:       } 
   1:     }
   1:     aOrigin.x = aInnerMargin.left + aInnerSize.width + aCaptionMargin.left;
   1:     aOrigin.y = aInnerMargin.top;
   1:     switch(GetCaptionVerticalAlign()) {
   1:       case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
   1:         aOrigin.y += PR_MAX(0, (aInnerSize.height - aCaptionSize.height) / 2);
   1:         break;
   1:       case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
   1:         aOrigin.y += PR_MAX(0, aInnerSize.height - aCaptionSize.height);
   1:         break;
   1:       default:
   1:         break;
   1:     }
   1:   } break;
   1:   default: { // top
   1:     if (NS_AUTOMARGIN == aCaptionMargin.left) {
   1:       aCaptionMargin.left = CalcAutoMargin(aCaptionMargin.left, aCaptionMargin.right,
   1:                                            aContainBlockSize.width, aCaptionSize.width);
   1:     }
   1:     aOrigin.x = aCaptionMargin.left;
   1:     if (NS_AUTOMARGIN == aCaptionMargin.bottom) {
   1:       aCaptionMargin.bottom = 0;
   1:     }
   1:     if (NS_AUTOMARGIN == aCaptionMargin.top) {
   1:       nsCollapsingMargin marg;
   1:       marg.Include(aCaptionMargin.bottom);
   1:       marg.Include(aInnerMargin.top);
   1:       nscoord collapseMargin = marg.get();
   1:       nscoord height = aCaptionSize.height + collapseMargin + aInnerSize.height;
   1:       aCaptionMargin.top = CalcAutoMargin(aCaptionMargin.top, aInnerMargin.bottom,
   1:                                           aContainBlockSize.height, height);
   1:     }
   1:     aOrigin.y = aCaptionMargin.top;
   1:   } break;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult 
   1: nsTableOuterFrame::GetInnerOrigin(PRUint32         aCaptionSide,
   1:                                   const nsSize&    aContainBlockSize,
   1:                                   const nsSize&    aCaptionSize, 
   1:                                   const nsMargin&  aCaptionMargin,
   1:                                   const nsSize&    aInnerSize,
   1:                                   nsMargin&        aInnerMargin,
   1:                                   nsPoint&         aOrigin)
   1: {
   1:   aOrigin.x = aOrigin.y = 0;
   1:   if ((NS_UNCONSTRAINEDSIZE == aInnerSize.width) || (NS_UNCONSTRAINEDSIZE == aInnerSize.height) ||  
   1:       (NS_UNCONSTRAINEDSIZE == aCaptionSize.width) || (NS_UNCONSTRAINEDSIZE == aCaptionSize.height)) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   nscoord minCapWidth = aCaptionSize.width;
   1:   if (NS_AUTOMARGIN != aCaptionMargin.left)
   1:     minCapWidth += aCaptionMargin.left;
   1:   if (NS_AUTOMARGIN != aCaptionMargin.right)
   1:     minCapWidth += aCaptionMargin.right;
   1: 
   1:   switch(aCaptionSide) {
   1:   case NS_SIDE_BOTTOM: {
   1:     if (NS_AUTOMARGIN == aInnerMargin.left) {
   1:       aInnerMargin.left = CalcAutoMargin(aInnerMargin.left, aInnerMargin.right,
   1:                                          aContainBlockSize.width, aInnerSize.width);
   1:     }
   1:     aOrigin.x = aInnerMargin.left;
   1:     if (NS_AUTOMARGIN == aInnerMargin.bottom) {
   1:       aInnerMargin.bottom = 0;
   1:     }
   1:     if (NS_AUTOMARGIN == aInnerMargin.top) {
   1:       nsCollapsingMargin marg;
   1:       marg.Include(aInnerMargin.bottom);
   1:       marg.Include(aCaptionMargin.top);
   1:       nscoord collapseMargin = marg.get();
   1:       nscoord height = aInnerSize.height + collapseMargin + aCaptionSize.height;
   1:       aInnerMargin.top = CalcAutoMargin(aInnerMargin.top, aCaptionMargin.bottom,
   1:                                         aContainBlockSize.height, height);
   1:     }
   1:     aOrigin.y = aInnerMargin.top;
   1:   } break;
   1:   case NS_SIDE_LEFT: {
   1:     
   1:     if (NS_AUTOMARGIN == aInnerMargin.left) {
   1:       aInnerMargin.left = CalcAutoMargin(aInnerMargin.left, aInnerMargin.right,
   1:                                          aContainBlockSize.width, aInnerSize.width);
   1:       
   1:     }
   1:     if (aInnerMargin.left < minCapWidth) {
   1:       // shift the inner table to get some place for the caption
   1:       aInnerMargin.right += aInnerMargin.left - minCapWidth;
   1:       aInnerMargin.right  = PR_MAX(0, aInnerMargin.right);
   1:       aInnerMargin.left   = minCapWidth;
   1:     }
   1:     aOrigin.x = aInnerMargin.left;
   1:     if (NS_AUTOMARGIN == aInnerMargin.top) {
   1:       aInnerMargin.top = 0;
   1:     }
   1:     aOrigin.y = aInnerMargin.top;
   1:     switch(GetCaptionVerticalAlign()) {
   1:       case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
   1:         aOrigin.y = PR_MAX(aInnerMargin.top, (aCaptionSize.height - aInnerSize.height) / 2);
   1:         break;
   1:       case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
   1:         aOrigin.y = PR_MAX(aInnerMargin.top, aCaptionSize.height - aInnerSize.height);
   1:         break;
   1:       default:
   1:         break;
   1:     }
   1:   } break;
   1:   case NS_SIDE_RIGHT: {
   1:     if (NS_AUTOMARGIN == aInnerMargin.right) {
   1:       aInnerMargin.right = CalcAutoMargin(aInnerMargin.left, aInnerMargin.right,
   1:                                           aContainBlockSize.width, aInnerSize.width);
   1:       if (aInnerMargin.right < minCapWidth) {
   1:         // shift the inner table to get some place for the caption
   1:         aInnerMargin.left -= aInnerMargin.right - minCapWidth;
   1:         aInnerMargin.left  = PR_MAX(0, aInnerMargin.left);
   1:         aInnerMargin.right = minCapWidth;
   1:       }
   1:     }
   1:     aOrigin.x = aInnerMargin.left;
   1:     if (NS_AUTOMARGIN == aInnerMargin.top) {
   1:       aInnerMargin.top = 0;
   1:     }
   1:     aOrigin.y = aInnerMargin.top;
   1:     switch(GetCaptionVerticalAlign()) {
   1:       case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
   1:         aOrigin.y = PR_MAX(aInnerMargin.top, (aCaptionSize.height - aInnerSize.height) / 2);
   1:         break;
   1:       case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
   1:         aOrigin.y = PR_MAX(aInnerMargin.top, aCaptionSize.height - aInnerSize.height);
   1:         break;
   1:       default:
   1:         break;
   1:     }
   1:   } break;
   1:   default: { // top
   1:     if (NS_AUTOMARGIN == aInnerMargin.left) {
   1:       aInnerMargin.left = CalcAutoMargin(aInnerMargin.left, aInnerMargin.right,
   1:                                          aContainBlockSize.width, aInnerSize.width);
   1:     }
   1:     aOrigin.x = aInnerMargin.left;
   1:     if (NS_AUTOMARGIN == aInnerMargin.top) {
   1:       aInnerMargin.top = 0;
   1:     }
   1:     nsCollapsingMargin marg;
   1:     marg.Include(aCaptionMargin.bottom);
   1:     marg.Include(aInnerMargin.top);
   1:     nscoord collapseMargin = marg.get();
   1:     if (NS_AUTOMARGIN == aInnerMargin.bottom) {
   1:       nscoord height = aCaptionSize.height + collapseMargin + aInnerSize.height;
   1:       aInnerMargin.bottom = CalcAutoMargin(aCaptionMargin.bottom, aInnerMargin.top,
   1:                                            aContainBlockSize.height, height);
   1:     }
   1:     aOrigin.y = aCaptionMargin.top + aCaptionSize.height + collapseMargin;
   1:   } break;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: // helper method for determining if this is a nested table or not
   1: PRBool 
   1: nsTableOuterFrame::IsNested(const nsHTMLReflowState& aReflowState) const
   1: {
   1:   // Walk up the reflow state chain until we find a cell or the root
   1:   const nsHTMLReflowState* rs = aReflowState.parentReflowState;
   1:   while (rs) {
   1:     if (nsGkAtoms::tableFrame == rs->frame->GetType()) {
   1:       return PR_TRUE;
   1:     }
   1:     rs = rs->parentReflowState;
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: nsresult
   1: nsTableOuterFrame::OuterReflowChild(nsPresContext*             aPresContext,
   1:                                     nsIFrame*                  aChildFrame,
   1:                                     const nsHTMLReflowState&   aOuterRS,
   1:                                     void*                      aChildRSSpace,
   1:                                     nsHTMLReflowMetrics&       aMetrics,
   1:                                     nscoord                    aAvailWidth, 
   1:                                     nsSize&                    aDesiredSize,
   1:                                     nsMargin&                  aMargin,
   1:                                     nsReflowStatus&            aStatus)
   1: { 
   1:   aMargin = nsMargin(0,0,0,0);
   1: 
   1:   // work around pixel rounding errors, round down to ensure we don't exceed the avail height in
   1:   nscoord availHeight = aOuterRS.availableHeight;
   1:   if (NS_UNCONSTRAINEDSIZE != availHeight) {
   1:     nsMargin margin;
   1:     GetMargin(aPresContext, aOuterRS, aChildFrame, aOuterRS.availableWidth,
   1:               margin);
   1:     
   1:     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != margin.top, "No unconstrainedsize arithmetic, please");
   1:     availHeight -= margin.top;
   1:     
   1:     NS_ASSERTION(NS_UNCONSTRAINEDSIZE != margin.bottom, "No unconstrainedsize arithmetic, please");
   1:     availHeight -= margin.bottom;
   1:   }
   1:   nsSize availSize(aAvailWidth, availHeight);
   1:   // create and init the child reflow state, using placement new on
   1:   // stack space allocated by the caller, so that the caller can destroy
   1:   // it
   1:   nsHTMLReflowState &childRS = * new (aChildRSSpace)
   1:     nsHTMLReflowState(aPresContext, aOuterRS, aChildFrame, availSize,
   1:                       -1, -1, PR_FALSE);
   1:   InitChildReflowState(*aPresContext, childRS);
   1: 
   1:   // see if we need to reset top of page due to a caption
   1:   if (mCaptionFrame) {
   1:     PRUint8 captionSide = GetCaptionSide();
   1:     if (((NS_SIDE_BOTTOM == captionSide) && (mCaptionFrame == aChildFrame)) || 
   1:         ((NS_SIDE_TOP == captionSide) && (mInnerTableFrame == aChildFrame))) {
   1:       childRS.mFlags.mIsTopOfPage = PR_FALSE;
   1:     }
   1:     if ((mCaptionFrame == aChildFrame) && (NS_SIDE_LEFT  != captionSide) 
   1:                                        && (NS_SIDE_RIGHT != captionSide)) {
   1:       aAvailWidth = aOuterRS.availableWidth;
   1:     }
   1:   }
   1: 
   1:   // use the current position as a best guess for placement
   1:   nsPoint childPt = aChildFrame->GetPosition();
   1:   nsresult rv = ReflowChild(aChildFrame, aPresContext, aMetrics, childRS,
   1:                             childPt.x, childPt.y, NS_FRAME_NO_MOVE_FRAME, aStatus);
   1:   if (NS_FAILED(rv)) return rv;
   1:   
   1:   aMargin = childRS.mComputedMargin;
   1: 
   1:   aDesiredSize.width  = aMetrics.width;
   1:   aDesiredSize.height = aMetrics.height;
   1: 
   1:   return rv;
   1: }
   1: 
   1: void 
   1: nsTableOuterFrame::UpdateReflowMetrics(PRUint8              aCaptionSide,
   1:                                        nsHTMLReflowMetrics& aMet,
   1:                                        const nsMargin&      aInnerMargin,
   1:                                        const nsMargin&      aCaptionMargin)
   1: {
   1:   SetDesiredSize(aCaptionSide, aInnerMargin, aCaptionMargin,
   1:                  aMet.width, aMet.height);
   1: 
   1:   aMet.mOverflowArea = nsRect(0, 0, aMet.width, aMet.height);
   1:   ConsiderChildOverflow(aMet.mOverflowArea, mInnerTableFrame);
   1:   if (mCaptionFrame) {
   1:     ConsiderChildOverflow(aMet.mOverflowArea, mCaptionFrame);
   1:   }
   1:   FinishAndStoreOverflow(&aMet);
   1: }
   1: 
   1: NS_METHOD nsTableOuterFrame::Reflow(nsPresContext*           aPresContext,
   1:                                     nsHTMLReflowMetrics&     aDesiredSize,
   1:                                     const nsHTMLReflowState& aOuterRS,
   1:                                     nsReflowStatus&          aStatus)
   1: {
   1:   DO_GLOBAL_REFLOW_COUNT("nsTableOuterFrame");
   1:   DISPLAY_REFLOW(aPresContext, this, aOuterRS, aDesiredSize, aStatus);
   1: 
   1:   // We desperately need an inner table frame,
   1:   // if this fails fix the frame constructor
   1:   if (mFrames.IsEmpty() || !mInnerTableFrame) {
   1:     NS_ERROR("incomplete children");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   nsresult rv = NS_OK;
   1:   PRUint8 captionSide = GetCaptionSide();
   1: 
   1:   // Initialize out parameters
   1:   aDesiredSize.width = aDesiredSize.height = 0;
   1:   aStatus = NS_FRAME_COMPLETE;
   1: 
   1:   PRBool reflowAllKids = aOuterRS.ShouldReflowAllKids();
   1: 
   1:   if (captionSide == NS_SIDE_LEFT || captionSide == NS_SIDE_RIGHT)
   1:     reflowAllKids = PR_TRUE;
   1: 
   1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
   1:     // Set up our kids.  They're already present, on an overflow list, 
   1:     // or there are none so we'll create them now
   1:     MoveOverflowToChildList(aPresContext);
   1:   }
   1: 
1158:   PRBool reflowCaption =
1158:     mCaptionFrame && (reflowAllKids || NS_SUBTREE_DIRTY(mCaptionFrame));
1158:   PRBool reflowInner = reflowAllKids || NS_SUBTREE_DIRTY(mInnerTableFrame);
   1: 
   1:   // First reflow the caption.  nsHTMLReflowState takes care of making
   1:   // side captions small.
   1:   nsHTMLReflowMetrics captionMet;
   1:   nsSize captionSize;
   1:   nsMargin captionMargin;
   1:   // Use longs to get more-aligned space.
   1:   #define LONGS_IN_HTMLRS \
   1:     ((sizeof(nsHTMLReflowState) + sizeof(long) - 1) / sizeof(long))
   1:   long captionRSSpace[LONGS_IN_HTMLRS];
   1:   if (reflowCaption) {
   1:     nsReflowStatus capStatus; // don't let the caption cause incomplete
   1:     rv = OuterReflowChild(aPresContext, mCaptionFrame, aOuterRS,
   1:                           captionRSSpace, captionMet,
   1:                           aOuterRS.ComputedWidth(), captionSize,
   1:                           captionMargin, capStatus);
   1:     if (NS_FAILED(rv)) return rv;
   1:   } else if (mCaptionFrame) {
   1:     captionSize = mCaptionFrame->GetSize();
   1:     GetMargin(aPresContext, aOuterRS, mCaptionFrame, aOuterRS.ComputedWidth(),
   1:               captionMargin);
   1:   } else {
   1:     captionSize.SizeTo(0,0);
   1:     captionMargin.SizeTo(0,0,0,0);
   1:   }
   1: 
   1:   nscoord innerAvailWidth = aOuterRS.ComputedWidth();
   1:   if (captionSide == NS_SIDE_LEFT || captionSide == NS_SIDE_RIGHT)
   1:     // If side is left/right then we know we have a caption and we
   1:     // reflowed it.
   1:     innerAvailWidth -= captionMet.width + captionMargin.LeftRight();
   1: 
   1:   // Then, now that we know how much to reduce the width of the inner
   1:   // table to account for side captions, reflow the inner table.
   1:   nsHTMLReflowMetrics innerMet;
   1:   nsSize innerSize;
   1:   nsMargin innerMargin;
   1:   long innerRSSpace[LONGS_IN_HTMLRS];
   1:   if (reflowInner) {
   1:     rv = OuterReflowChild(aPresContext, mInnerTableFrame, aOuterRS,
   1:                           innerRSSpace, innerMet, innerAvailWidth,
   1:                           innerSize, innerMargin, aStatus);
   1:     if (NS_FAILED(rv)) return rv;
   1:   } else {
   1:     innerSize = mInnerTableFrame->GetSize();
   1:     GetMargin(aPresContext, aOuterRS, mInnerTableFrame,
   1:               aOuterRS.ComputedWidth(), innerMargin);
   1:   }
   1: 
   1:   nsSize   containSize = GetContainingBlockSize(aOuterRS);
   1: 
   1:   // Now that we've reflowed both we can place them.
   1:   // XXXldb Most of the input variables here are now uninitialized!
   1: 
   1:   // XXX Need to recompute inner table's auto margins for the case of side
   1:   // captions.  (Caption's are broken too, but that should be fixed earlier.)
   1: 
   1:   if (mCaptionFrame) {
   1:     nsPoint captionOrigin;
   1:     GetCaptionOrigin(captionSide, containSize, innerSize, 
   1:                      innerMargin, captionSize, captionMargin, captionOrigin);
   1:     if (reflowCaption) {
   1:       nsHTMLReflowState *captionRS =
   1:         NS_STATIC_CAST(nsHTMLReflowState*, (void*)captionRSSpace);
   1:       FinishReflowChild(mCaptionFrame, aPresContext, captionRS, captionMet,
   1:                         captionOrigin.x, captionOrigin.y, 0);
   1:       captionRS->~nsHTMLReflowState();
   1:     } else {
   1:       mCaptionFrame->SetPosition(captionOrigin);
   1:       nsTableFrame::RePositionViews(mCaptionFrame);
   1:     }
   1:   }
   1:   // XXX If the height is constrained then we need to check whether
   1:   // everything still fits...
   1: 
   1:   nsPoint innerOrigin;
   1:   GetInnerOrigin(captionSide, containSize, captionSize, 
   1:                  captionMargin, innerSize, innerMargin, innerOrigin);
   1:   if (reflowInner) {
   1:     nsHTMLReflowState *innerRS =
   1:       NS_STATIC_CAST(nsHTMLReflowState*, (void*) innerRSSpace);
   1:     FinishReflowChild(mInnerTableFrame, aPresContext, innerRS, innerMet,
   1:                       innerOrigin.x, innerOrigin.y, 0);
   1:     innerRS->~nsHTMLReflowState();
   1:   } else {
   1:     mInnerTableFrame->SetPosition(innerOrigin);
   1:     nsTableFrame::RePositionViews(mInnerTableFrame);
   1:   }
   1: 
   1:   UpdateReflowMetrics(captionSide, aDesiredSize, innerMargin, captionMargin);
   1:   
   1:   // Return our desired rect
   1: 
   1:   NS_FRAME_SET_TRUNCATION(aStatus, aOuterRS, aDesiredSize);
   1:   return rv;
   1: }
   1: 
   1: #ifdef NS_DEBUG
   1: NS_METHOD nsTableOuterFrame::VerifyTree() const
   1: {
   1:   return NS_OK;
   1: }
   1: #endif
   1: 
   1: /**
   1:  * Remove and delete aChild's next-in-flow(s). Updates the sibling and flow
   1:  * pointers.
   1:  *
   1:  * Updates the child count and content offsets of all containers that are
   1:  * affected
   1:  *
   1:  * Overloaded here because nsContainerFrame makes assumptions about pseudo-frames
   1:  * that are not true for tables.
   1:  *
   1:  * @param   aChild child this child's next-in-flow
   1:  * @return  PR_TRUE if successful and PR_FALSE otherwise
   1:  */
   1: void nsTableOuterFrame::DeleteChildsNextInFlow(nsPresContext* aPresContext, 
   1:                                                nsIFrame*       aChild)
   1: {
   1:   if (!aChild) return;
   1:   NS_PRECONDITION(mFrames.ContainsFrame(aChild), "bad geometric parent");
   1: 
   1:   nsIFrame* nextInFlow = aChild->GetNextInFlow();
   1:   if (!nextInFlow) {
   1:     NS_ASSERTION(PR_FALSE, "null next-in-flow");
   1:     return;
   1:   }
   1: 
   1:   nsTableOuterFrame* parent = NS_STATIC_CAST(nsTableOuterFrame*,
   1:                                              nextInFlow->GetParent());
   1:   if (!parent) {
   1:     NS_ASSERTION(PR_FALSE, "null parent");
   1:     return;
   1:   }
   1:   // If the next-in-flow has a next-in-flow then delete it too (and
   1:   // delete it first).
   1:   nsIFrame* nextNextInFlow = nextInFlow->GetNextInFlow();
   1:   if (nextNextInFlow) {
   1:     parent->DeleteChildsNextInFlow(aPresContext, nextInFlow);
   1:   }
   1: 
   1:   // Disconnect the next-in-flow from the flow list
   1:   nsSplittableFrame::BreakFromPrevFlow(nextInFlow);
   1: 
   1:   // Take the next-in-flow out of the parent's child list
   1:   if (parent->mFrames.FirstChild() == nextInFlow) {
   1:     parent->mFrames.SetFrames(nextInFlow->GetNextSibling());
   1:   } else {
   1:     // Because the next-in-flow is not the first child of the parent
   1:     // we know that it shares a parent with aChild. Therefore, we need
   1:     // to capture the next-in-flow's next sibling (in case the
   1:     // next-in-flow is the last next-in-flow for aChild AND the
   1:     // next-in-flow is not the last child in parent)
   1:     NS_ASSERTION(aChild->GetNextSibling() == nextInFlow, "unexpected sibling");
   1: 
   1:     aChild->SetNextSibling(nextInFlow->GetNextSibling());
   1:   }
   1: 
   1:   // Delete the next-in-flow frame and adjust its parent's child count
   1:   nextInFlow->Destroy();
   1: 
   1:   NS_POSTCONDITION(!aChild->GetNextInFlow(), "non null next-in-flow");
   1: }
   1: 
   1: nsIAtom*
   1: nsTableOuterFrame::GetType() const
   1: {
   1:   return nsGkAtoms::tableOuterFrame;
   1: }
   1: 
   1: /* ----- global methods ----- */
   1: 
   1: /*------------------ nsITableLayout methods ------------------------------*/
   1: NS_IMETHODIMP 
   1: nsTableOuterFrame::GetCellDataAt(PRInt32 aRowIndex, PRInt32 aColIndex, 
   1:                                  nsIDOMElement* &aCell,   //out params
   1:                                  PRInt32& aStartRowIndex, PRInt32& aStartColIndex, 
   1:                                  PRInt32& aRowSpan, PRInt32& aColSpan,
   1:                                  PRInt32& aActualRowSpan, PRInt32& aActualColSpan,
   1:                                  PRBool& aIsSelected)
   1: {
   1:   if (!mInnerTableFrame) { return NS_ERROR_NOT_INITIALIZED; }
   1:   nsITableLayout *inner;
   1:   if (NS_SUCCEEDED(CallQueryInterface(mInnerTableFrame, &inner))) {
   1:     return (inner->GetCellDataAt(aRowIndex, aColIndex, aCell,
   1:                                  aStartRowIndex, aStartColIndex, 
   1:                                  aRowSpan, aColSpan, aActualRowSpan, aActualColSpan, 
   1:                                  aIsSelected));
   1:   }
   1:   return NS_ERROR_NULL_POINTER;
   1: }
   1: 
   1: NS_IMETHODIMP nsTableOuterFrame::GetTableSize(PRInt32& aRowCount, PRInt32& aColCount)
   1: {
   1:   if (!mInnerTableFrame) { return NS_ERROR_NOT_INITIALIZED; }
   1:   nsITableLayout *inner;
   1:   if (NS_SUCCEEDED(CallQueryInterface(mInnerTableFrame, &inner))) {
   1:     return (inner->GetTableSize(aRowCount, aColCount));
   1:   }
   1:   return NS_ERROR_NULL_POINTER;
   1: }
   1: 
   1: /*---------------- end of nsITableLayout implementation ------------------*/
   1: 
   1: 
   1: nsIFrame*
   1: NS_NewTableOuterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsTableOuterFrame(aContext);
   1: }
   1: 
   1: #ifdef DEBUG
   1: NS_IMETHODIMP
   1: nsTableOuterFrame::GetFrameName(nsAString& aResult) const
   1: {
   1:   return MakeFrameName(NS_LITERAL_STRING("TableOuter"), aResult);
   1: }
   1: #endif
   1: 
