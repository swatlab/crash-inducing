    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Jerry.Kirk@Nexwarecorp.com
    1:  *   Chris Seawood <cls@seawood.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * This module is supposed to abstract signal handling away from the other
    1:  * platforms that do not support it.
    1:  */
    1: 
36487: #include "nsSigHandlers.h"
36487: 
36487: #ifdef XP_UNIX
36487: 
    1: #include <signal.h>
    1: #include <stdio.h>
 1781: #include <string.h>
    1: #include "prthread.h"
    1: #include "plstr.h"
    1: #include "prenv.h"
 1781: #include "nsDebug.h"
    1: 
    1: #if defined(LINUX)
    1: #include <sys/time.h>
    1: #include <sys/resource.h>
    1: #include <unistd.h>
    1: #include <stdlib.h> // atoi
36487: #include <ucontext.h>
    1: #endif
    1: 
    1: #if defined(SOLARIS)
    1: #include <sys/resource.h>
    1: #endif
    1: 
    1: #ifdef XP_BEOS
    1: #include <be/app/Application.h>
    1: #include <string.h>
    1: #include "nsCOMPtr.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIAppStartup.h"
    1: #include "nsXPFEComponentsCID.h"
    1: #endif
    1: 
    1: #ifdef MOZ_WIDGET_PHOTON
    1: #include <photon/PhProto.h>
    1: #endif
    1: 
    1: static char _progname[1024] = "huh?";
    1: static unsigned int _gdb_sleep_duration = 300;
    1: 
    1: #if defined(LINUX) && defined(DEBUG) && \
    1:       (defined(__i386) || defined(__x86_64) || defined(PPC))
    1: #define CRAWL_STACK_ON_SIGSEGV
    1: #endif
    1: 
    1: #ifdef MOZ_WIDGET_PHOTON
    1: void abnormal_exit_handler(int signum)
    1: {
    1:   /* Free any shared memory that has been allocated */
    1:   PgShmemCleanup();
    1: 
    1: #if defined(DEBUG)
    1:   if (    (signum == SIGSEGV)
    1:        || (signum == SIGILL)
    1:        || (signum == SIGABRT)
    1:        || (signum == SIGFPE)
    1:      )
    1:   {
    1:     printf("prog = %s\npid = %d\nsignal = %s\n", 
    1:            _progname, getpid(), strsignal(signum));
    1: 
    1:     printf("Sleeping for %d seconds.\n",_gdb_sleep_duration);
    1:     printf("Type 'gdb %s %d' to attach your debugger to this thread.\n",
    1:            _progname, getpid());
    1: 
    1:     sleep(_gdb_sleep_duration);
    1: 
    1:     printf("Done sleeping...\n");
    1:   }
    1: #endif
    1: 
    1:   _exit(1);
    1: }
    1: #elif defined(CRAWL_STACK_ON_SIGSEGV)
    1: 
    1: #include <unistd.h>
    1: #include "nsISupportsUtils.h"
 4487: #include "nsStackWalk.h"
 4487: 
 4487: extern "C" {
 4487: 
20261: static void PrintStackFrame(void *aPC, void *aClosure)
 4487: {
 4488:   char buf[1024];
 4488:   nsCodeAddressDetails details;
 4488: 
 4488:   NS_DescribeCodeAddress(aPC, &details);
 4488:   NS_FormatCodeAddressDetails(aPC, &details, buf, sizeof(buf));
34013:   fputs(buf, stdout);
 4487: }
 4487: 
 4487: }
    1: 
    1: void
    1: ah_crap_handler(int signum)
    1: {
    1:   printf("\nProgram %s (pid = %d) received signal %d.\n",
    1:          _progname,
    1:          getpid(),
    1:          signum);
    1: 
    1:   printf("Stack:\n");
 4487:   NS_StackWalk(PrintStackFrame, 2, nsnull);
    1: 
    1:   printf("Sleeping for %d seconds.\n",_gdb_sleep_duration);
    1:   printf("Type 'gdb %s %d' to attach your debugger to this thread.\n",
    1:          _progname,
    1:          getpid());
    1: 
    1:   sleep(_gdb_sleep_duration);
    1: 
    1:   printf("Done sleeping...\n");
25537: 
25537:   _exit(signum);
    1: }
    1: #endif // CRAWL_STACK_ON_SIGSEGV
    1: 
    1: #ifdef XP_BEOS
    1: void beos_signal_handler(int signum) {
    1: #ifdef DEBUG
    1: 	fprintf(stderr, "beos_signal_handler: %d\n", signum);
    1: #endif
    1: 	nsresult rv;
    1: 	nsCOMPtr<nsIAppStartup> appStartup(do_GetService(NS_APPSTARTUP_CONTRACTID, &rv));
    1: 	if (NS_FAILED(rv)) {
    1: 		// Failed to get the appstartup service so shutdown the hard way
    1: #ifdef DEBUG
    1: 		fprintf(stderr, "beos_signal_handler: appShell->do_GetService() failed\n");
    1: #endif
    1: 		exit(13);
    1: 	}
    1: 
    1: 	// Exit the appshell so that the app can shutdown normally
    1: 	appStartup->Quit(nsIAppStartup::eAttemptQuit);
    1: }
    1: #endif
    1: 
 2299: #ifdef MOZ_WIDGET_GTK2
 2299: // Need this include for version test below.
 2299: #include <glib.h>
 2299: #endif
 2299: 
 1784: #if defined(MOZ_WIDGET_GTK2) && (GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 6))
 1777: 
 1777: static GLogFunc orig_log_func = NULL;
 1777: 
 1777: extern "C" {
 1777: static void
 1777: my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
 1777:                  const gchar *message, gpointer user_data);
 1777: }
 1777: 
 1777: /* static */ void
 1777: my_glib_log_func(const gchar *log_domain, GLogLevelFlags log_level,
 1777:                  const gchar *message, gpointer user_data)
 1777: {
 9978:   if (log_level & (G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL | G_LOG_FLAG_RECURSION)) {
 9978:     NS_DebugBreak(NS_DEBUG_ASSERTION, message, "glib assertion", __FILE__, __LINE__);
 9978:   } else if (log_level & (G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)) {
 9978:     NS_DebugBreak(NS_DEBUG_WARNING, message, "glib warning", __FILE__, __LINE__);
 9978:   }
 9978: 
 1777:   orig_log_func(log_domain, log_level, message, NULL);
 1777: }
 1777: 
 1777: #endif
 1777: 
36487: static void fpehandler(int signum, siginfo_t *si, void *context)
36487: {
36487: #ifdef XP_MACOSX
36487:   ucontext_t *uc = (ucontext_t *)context;
36487: 
36487: #if defined(__i386__) || defined(__amd64__)
36487:   _STRUCT_FP_CONTROL *ctrl = &uc->uc_mcontext->__fs.__fpu_fcw;
36487:   ctrl->__invalid = ctrl->__denorm = ctrl->__zdiv = ctrl->__ovrfl = ctrl->__undfl = ctrl->__precis = 1;
36487: 
36487:   _STRUCT_FP_STATUS *status = &uc->uc_mcontext->__fs.__fpu_fsw;
36487:   status->__invalid = status->__denorm = status->__zdiv = status->__ovrfl = status->__undfl =
36487:     status->__precis = status->__stkflt = status->__errsumm = 0;
36487: 
36487:   __uint32_t *mxcsr = &uc->uc_mcontext->__fs.__fpu_mxcsr;
36487:   *mxcsr |= SSE_EXCEPTION_MASK; /* disable all SSE exceptions */
36487:   *mxcsr &= ~SSE_STATUS_FLAGS; /* clear all pending SSE exceptions */
36487: #endif
36487: #endif
36487: #ifdef LINUX
36487:   ucontext_t *uc = (ucontext_t *)context;
36487: 
36487: #if defined(__i386__)
36487:   /*
36487:    * It seems that we have no access to mxcsr on Linux. libc
36487:    * seems to be translating cw/sw to mxcsr.
36487:    */
36487:   unsigned long int *cw = &uc->uc_mcontext.fpregs->cw;
36487:   *cw |= FPU_EXCEPTION_MASK;
36487: 
36487:   unsigned long int *sw = &uc->uc_mcontext.fpregs->sw;
36487:   *sw &= ~FPU_STATUS_FLAGS;
36487: #endif
36487: #if defined(__amd64__)
36494:   __uint16_t *cw = &uc->uc_mcontext.fpregs->cwd;
36492:   *cw |= FPU_EXCEPTION_MASK;
36487: 
36494:   __uint16_t *sw = &uc->uc_mcontext.fpregs->swd;
36492:   *sw &= ~FPU_STATUS_FLAGS;
36487: 
36492:   __uint32_t *mxcsr = &uc->uc_mcontext.fpregs->mxcsr;
36487:   *mxcsr |= SSE_EXCEPTION_MASK; /* disable all SSE exceptions */
36487:   *mxcsr &= ~SSE_STATUS_FLAGS; /* clear all pending SSE exceptions */
36487: #endif
36487: #endif
36487: }
36487: 
36487: void InstallSignalHandlers(const char *ProgramName)
    1: {
    1:   PL_strncpy(_progname,ProgramName, (sizeof(_progname)-1) );
    1: 
    1:   const char *gdbSleep = PR_GetEnv("MOZ_GDB_SLEEP");
    1:   if (gdbSleep && *gdbSleep)
    1:   {
    1:     unsigned int s;
    1:     if (1 == sscanf(gdbSleep, "%u", &s)) {
    1:       _gdb_sleep_duration = s;
    1:     }
    1:   }
    1: 
    1: #if defined(MOZ_WIDGET_PHOTON)
    1:  /* Neutrino need this to free shared memory in case of a crash */
    1:   signal(SIGTERM, abnormal_exit_handler);
    1:   signal(SIGQUIT, abnormal_exit_handler);
    1:   signal(SIGINT,  abnormal_exit_handler);
    1:   signal(SIGHUP,  abnormal_exit_handler);
    1:   signal(SIGSEGV, abnormal_exit_handler);
    1:   signal(SIGILL,  abnormal_exit_handler);
    1:   signal(SIGABRT, abnormal_exit_handler);
    1: 
    1: #elif defined(CRAWL_STACK_ON_SIGSEGV)
    1:   signal(SIGSEGV, ah_crap_handler);
    1:   signal(SIGILL, ah_crap_handler);
    1:   signal(SIGABRT, ah_crap_handler);
    1: #endif // CRAWL_STACK_ON_SIGSEGV
    1: 
36487:   /* Install a handler for floating point exceptions and disable them if they occur. */
36487:   struct sigaction sa, osa;
36487:   sa.sa_flags = SA_ONSTACK | SA_RESTART | SA_SIGINFO;
36487:   sa.sa_sigaction = fpehandler;
36487:   sigaction(SIGFPE, &sa, &osa);
36487: 
    1: #if defined(DEBUG) && defined(LINUX)
    1:   const char *memLimit = PR_GetEnv("MOZ_MEM_LIMIT");
    1:   if (memLimit && *memLimit)
    1:   {
    1:     long m = atoi(memLimit);
    1:     m *= (1024*1024);
    1:     struct rlimit r;
    1:     r.rlim_cur = m;
    1:     r.rlim_max = m;
    1:     setrlimit(RLIMIT_AS, &r);
    1:   }
    1: #endif
    1: 
    1: #if defined(SOLARIS)
    1: #define NOFILES 512
    1: 
    1:     // Boost Solaris file descriptors
    1:     {
    1: 	struct rlimit rl;
    1: 	
    1: 	if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
    1: 
    1: 	    if (rl.rlim_cur < NOFILES) {
    1: 		rl.rlim_cur = NOFILES;
    1: 
    1: 		if (setrlimit(RLIMIT_NOFILE, &rl) < 0) {
    1: 		    perror("setrlimit(RLIMIT_NOFILE)");
    1: 		    fprintf(stderr, "Cannot exceed hard limit for open files");
    1: 		}
    1: #if defined(DEBUG)
    1: 	    	if (getrlimit(RLIMIT_NOFILE, &rl) == 0)
    1: 		    printf("File descriptors set to %d\n", rl.rlim_cur);
    1: #endif //DEBUG
    1: 	    }
    1:     }
    1: #endif //SOLARIS
    1: 
    1: #ifdef XP_BEOS
    1: 	signal(SIGTERM, beos_signal_handler);
    1: #endif
 1777: 
 1784: #if defined(MOZ_WIDGET_GTK2) && (GLIB_MAJOR_VERSION > 2 || (GLIB_MAJOR_VERSION == 2 && GLIB_MINOR_VERSION >= 6))
 1777:   const char *assertString = PR_GetEnv("XPCOM_DEBUG_BREAK");
 1777:   if (assertString &&
 1777:       (!strcmp(assertString, "suspend") ||
 1777:        !strcmp(assertString, "stack") ||
 1777:        !strcmp(assertString, "abort") ||
 1777:        !strcmp(assertString, "trap") ||
 1777:        !strcmp(assertString, "break"))) {
 1777:     // Override the default glib logging function so we get stacks for it too.
 1777:     orig_log_func = g_log_set_default_handler(my_glib_log_func, NULL);
    1:   }
 1777: #endif
 1777: }
36487: 
36487: #elif XP_WIN
36487: 
36487: #include <windows.h>
36487: 
36487: #ifdef _M_IX86
36487: /*
36487:  * WinNT.h prior to SDK7 does not expose the structure of the ExtendedRegisters for ia86.
36487:  * We known that MxCsr is at offset 0x18 and is a DWORD.
36487:  */
36487: #define MXCSR(ctx) (*(DWORD *)(((BYTE *)(ctx)->ExtendedRegisters) + 0x18))
36487: #endif
36487: 
36487: #ifdef _M_X64
36487: #define MXCSR(ctx) (ctx)->MxCsr
36487: #endif
36487: 
36560: #if defined(_M_IA32) || defined(_M_X64)
36487: 
36487: #define X87CW(ctx) (ctx)->FloatSave.ControlWord
36487: #define X87SW(ctx) (ctx)->FloatSave.StatusWord
36487: 
36487: /*
36487:  * SSE traps raise these exception codes, which are defined in internal NT headers
36487:  * but not winbase.h
36487:  */
36487: #define STATUS_FLOAT_MULTIPLE_FAULTS 0xC00002B4
36487: #define STATUS_FLOAT_MULTIPLE_TRAPS  0xC00002B5
36487: 
36487: LONG __stdcall FpeHandler(PEXCEPTION_POINTERS pe)
36487: {
36487:   PEXCEPTION_RECORD e = (PEXCEPTION_RECORD)pe->ExceptionRecord;
36487:   CONTEXT *c = (CONTEXT*)pe->ContextRecord;
36487: 
36487:   switch (e->ExceptionCode) {
36487:     case STATUS_FLOAT_DENORMAL_OPERAND:
36487:     case STATUS_FLOAT_DIVIDE_BY_ZERO:
36487:     case STATUS_FLOAT_INEXACT_RESULT:
36487:     case STATUS_FLOAT_INVALID_OPERATION:
36487:     case STATUS_FLOAT_OVERFLOW:
36487:     case STATUS_FLOAT_STACK_CHECK:
36487:     case STATUS_FLOAT_UNDERFLOW:
36487:     case STATUS_FLOAT_MULTIPLE_FAULTS:
36487:     case STATUS_FLOAT_MULTIPLE_TRAPS:
36487:       X87CW(c) |= FPU_EXCEPTION_MASK; /* disable all FPU exceptions */
36487:       X86SW(c) &= ~FPU_STATUS_FLAGS;  /* clear all pending FPU exceptions */
36487: #ifdef _M_IA32
36487:       if (c->ContextFlags & CONTEXT_EXTENDED_REGISTERS) {
36487: #endif
36487:         MXCSR(c) |= SSE_EXCEPTION_MASK; /* disable all SSE exceptions */
36487:         MXCSR(c) &= ~SSE_STATUS_FLAGS;  /* clear all pending SSE exceptions */
36487: #ifdef _M_IA32
36487:       }
36487: #endif
36487:       return EXCEPTION_CONTINUE_EXECUTION;
36487:   }
36487:   return EXCEPTION_CONTINUE_SEARCH;
36487: }
36487: 
36487: void InstallSignalHandlers(const char *ProgramName)
36487: {
36487:   SetUnhandledExceptionFilter(FpeHandler);
36487: }
36487: 
36487: #else
36487: 
36487: void InstallSignalHandlers(const char *ProgramName)
36487: {
36487: }
36487: 
36487: #endif
36487: 
36487: #else
36487: #error No signal handling implementation for this platform.
36487: #endif
