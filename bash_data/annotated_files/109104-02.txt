 73753: /* -*- Mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 40 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 73753: 
 73753: #include "Worker.h"
 73753: 
 97422: #include "mozilla/dom/DOMJSClass.h"
 97422: #include "mozilla/dom/BindingUtils.h"
 73753: 
 73753: #include "EventTarget.h"
 73753: #include "RuntimeService.h"
 73753: #include "WorkerPrivate.h"
 73753: 
 73753: #include "WorkerInlines.h"
 73753: 
 73753: #define PROPERTY_FLAGS \
 90546:   (JSPROP_ENUMERATE | JSPROP_SHARED)
 73753: 
 73753: #define FUNCTION_FLAGS \
 73753:   JSPROP_ENUMERATE
 73753: 
 73753: USING_WORKERS_NAMESPACE
 73753: 
 97422: using namespace mozilla::dom;
 97819: using mozilla::ErrorResult;
 94512: 
109104: // These are temporary until these classes are moved to be codegenerated.
109104: bool
109104: WorkerResolveProperty(JSContext* cx, JSObject* wrapper, jsid id, bool set,
109104:                       JSPropertyDescriptor* desc)
109104: {
109104:   return true;
109104: }
109104: bool
109104: WorkerEnumerateProperties(JS::AutoIdVector& props)
109104: {
109104:   return true;
109104: }
109104: NativePropertyHooks mozilla::dom::workers::sNativePropertyHooks =
109104:   { WorkerResolveProperty, WorkerEnumerateProperties, NULL };
109104: 
109104: 
 73753: namespace {
 73753: 
 73753: class Worker
 73753: {
 94512:   static DOMJSClass sClass;
 73753:   static JSPropertySpec sProperties[];
 73753:   static JSFunctionSpec sFunctions[];
 73753: 
 73753:   enum
 73753:   {
 73753:     STRING_onerror = 0,
 73753:     STRING_onmessage,
 73753: 
 73753:     STRING_COUNT
 73753:   };
 73753: 
 73753:   static const char* const sEventStrings[STRING_COUNT];
 73753: 
 73753: protected:
 73753:   enum {
 73753:     // The constructor function holds a WorkerPrivate* in its first reserved
 73753:     // slot.
 73753:     CONSTRUCTOR_SLOT_PARENT = 0
 73753:   };
 73753: 
 73753: public:
 73753:   static JSClass*
 73753:   Class()
 73753:   {
 94512:     return sClass.ToJSClass();
 73753:   }
 73753: 
 73753:   static JSObject*
 73753:   InitClass(JSContext* aCx, JSObject* aObj, JSObject* aParentProto,
 73753:             bool aMainRuntime)
 73753:   {
 94512:     JSObject* proto =
 94512:       js::InitClassWithReserved(aCx, aObj, aParentProto, Class(), Construct, 0,
 94512:                                 sProperties, sFunctions, NULL, NULL);
 73753:     if (!proto) {
 73753:       return NULL;
 73753:     }
 73753: 
 73753:     if (!aMainRuntime) {
 73753:       WorkerPrivate* parent = GetWorkerPrivateFromContext(aCx);
 73753:       parent->AssertIsOnWorkerThread();
 73753: 
 73753:       JSObject* constructor = JS_GetConstructor(aCx, proto);
 83265:       if (!constructor)
 73753:         return NULL;
 83265:       js::SetFunctionNativeReserved(constructor, CONSTRUCTOR_SLOT_PARENT,
 83265:                                     PRIVATE_TO_JSVAL(parent));
 73753:     }
 73753: 
 73753:     return proto;
 73753:   }
 73753: 
 73753:   static WorkerPrivate*
 73753:   GetInstancePrivate(JSContext* aCx, JSObject* aObj, const char* aFunctionName);
 73753: 
 83422: protected:
 73753:   static JSBool
 91237:   ConstructInternal(JSContext* aCx, unsigned aArgc, jsval* aVp,
 94512:                     bool aIsChromeWorker, JSClass* aClass)
 73753:   {
 73753:     if (!aArgc) {
 73753:       JS_ReportError(aCx, "Constructor requires at least one argument!");
 73753:       return false;
 73753:     }
 73753: 
 73753:     JSString* scriptURL = JS_ValueToString(aCx, JS_ARGV(aCx, aVp)[0]);
 73753:     if (!scriptURL) {
 73753:       return false;
 73753:     }
 73753: 
 83265:     jsval priv = js::GetFunctionNativeReserved(JSVAL_TO_OBJECT(JS_CALLEE(aCx, aVp)),
 83265:                                                CONSTRUCTOR_SLOT_PARENT);
 73753: 
 73753:     RuntimeService* runtimeService;
 73753:     WorkerPrivate* parent;
 73753: 
 73753:     if (JSVAL_IS_VOID(priv)) {
 73753:       runtimeService = RuntimeService::GetOrCreateService();
 73753:       if (!runtimeService) {
 73753:         JS_ReportError(aCx, "Failed to create runtime service!");
 73753:         return false;
 73753:       }
 73753:       parent = NULL;
 73753:     }
 73753:     else {
 73753:       runtimeService = RuntimeService::GetService();
 73753:       parent = static_cast<WorkerPrivate*>(JSVAL_TO_PRIVATE(priv));
 73753:       parent->AssertIsOnWorkerThread();
 73753:     }
 73753: 
106838:     JSObject* obj = JS_NewObject(aCx, aClass, nullptr, nullptr);
 73753:     if (!obj) {
 73753:       return false;
 73753:     }
 73753: 
 94512:     nsRefPtr<WorkerPrivate> worker =
 94512:       WorkerPrivate::Create(aCx, obj, parent, scriptURL, aIsChromeWorker);
 73753:     if (!worker) {
 73753:       return false;
 73753:     }
 73753: 
 73753:     // Worker now owned by the JS object.
 94512:     NS_ADDREF(worker.get());
 94512:     js::SetReservedSlot(obj, DOM_OBJECT_SLOT, PRIVATE_TO_JSVAL(worker));
 73753: 
 73753:     if (!runtimeService->RegisterWorker(aCx, worker)) {
 73753:       return false;
 73753:     }
 73753: 
 94512:     // Worker now also owned by its thread.
 94512:     NS_ADDREF(worker.get());
 94512: 
 73753:     JS_SET_RVAL(aCx, aVp, OBJECT_TO_JSVAL(obj));
 73753:     return true;
 73753:   }
 73753: 
 73753: private:
 73753:   // No instance of this class should ever be created so these are explicitly
 73753:   // left without an implementation to prevent linking in case someone tries to
 73753:   // make one.
 73753:   Worker();
 73753:   ~Worker();
 73753: 
 73753:   static JSBool
106862:   GetEventListener(JSContext* aCx, JSHandleObject aObj, JSHandleId aIdval, JSMutableHandleValue aVp)
 73753:   {
 73753:     JS_ASSERT(JSID_IS_INT(aIdval));
 73753:     JS_ASSERT(JSID_TO_INT(aIdval) >= 0 && JSID_TO_INT(aIdval) < STRING_COUNT);
 73753: 
 73753:     const char* name = sEventStrings[JSID_TO_INT(aIdval)];
 73753:     WorkerPrivate* worker = GetInstancePrivate(aCx, aObj, name);
 73753:     if (!worker) {
 79840:       return !JS_IsExceptionPending(aCx);
 73753:     }
 73753: 
 94512:     NS_ConvertASCIItoUTF16 nameStr(name + 2);
 97819:     ErrorResult rv;
 94512:     JSObject* listener = worker->GetEventListener(nameStr, rv);
 94512: 
 97819:     if (rv.Failed()) {
 94512:       JS_ReportError(aCx, "Failed to get listener!");
 94512:     }
 94512: 
106862:     aVp.set(listener ? OBJECT_TO_JSVAL(listener) : JSVAL_NULL);
 94512:     return true;
 73753:   }
 73753: 
 73753:   static JSBool
 98960:   SetEventListener(JSContext* aCx, JSHandleObject aObj, JSHandleId aIdval, JSBool aStrict,
106862:                    JSMutableHandleValue aVp)
 73753:   {
 73753:     JS_ASSERT(JSID_IS_INT(aIdval));
 73753:     JS_ASSERT(JSID_TO_INT(aIdval) >= 0 && JSID_TO_INT(aIdval) < STRING_COUNT);
 73753: 
 73753:     const char* name = sEventStrings[JSID_TO_INT(aIdval)];
 73753:     WorkerPrivate* worker = GetInstancePrivate(aCx, aObj, name);
 73753:     if (!worker) {
 79840:       return !JS_IsExceptionPending(aCx);
 73753:     }
 73753: 
 94512:     JSObject* listener;
106862:     if (!JS_ValueToObject(aCx, aVp, &listener)) {
 94512:       return false;
 94512:     }
 94512: 
 94512:     NS_ConvertASCIItoUTF16 nameStr(name + 2);
 97819:     ErrorResult rv;
 94512:     worker->SetEventListener(nameStr, listener, rv);
 94512: 
 97819:     if (rv.Failed()) {
 94512:       JS_ReportError(aCx, "Failed to set listener!");
 94512:       return false;
 94512:     }
 94512: 
 94512:     return true;
 73753:   }
 73753: 
 73753:   static JSBool
 91237:   Construct(JSContext* aCx, unsigned aArgc, jsval* aVp)
 73753:   {
 94512:     return ConstructInternal(aCx, aArgc, aVp, false, Class());
 73753:   }
 73753: 
 73753:   static void
 94738:   Finalize(JSFreeOp* aFop, JSObject* aObj)
 73753:   {
 94512:     JS_ASSERT(JS_GetClass(aObj) == Class());
101296:     WorkerPrivate* worker = UnwrapDOMObject<WorkerPrivate>(aObj);
 73753:     if (worker) {
 99121:       worker->_finalize(aFop);
 73753:     }
 73753:   }
 73753: 
 73753:   static void
 73753:   Trace(JSTracer* aTrc, JSObject* aObj)
 73753:   {
 94512:     JS_ASSERT(JS_GetClass(aObj) == Class());
101296:     WorkerPrivate* worker = UnwrapDOMObject<WorkerPrivate>(aObj);
 73753:     if (worker) {
 99121:       worker->_trace(aTrc);
 73753:     }
 73753:   }
 73753: 
 73753:   static JSBool
 91237:   Terminate(JSContext* aCx, unsigned aArgc, jsval* aVp)
 73753:   {
 73753:     JSObject* obj = JS_THIS_OBJECT(aCx, aVp);
 83114:     if (!obj) {
 83114:       return false;
 83114:     }
 73753: 
 73753:     const char*& name = sFunctions[0].name;
 73753:     WorkerPrivate* worker = GetInstancePrivate(aCx, obj, name);
 73753:     if (!worker) {
 79840:       return !JS_IsExceptionPending(aCx);
 73753:     }
 73753: 
 73753:     return worker->Terminate(aCx);
 73753:   }
 73753: 
 73753:   static JSBool
 91237:   PostMessage(JSContext* aCx, unsigned aArgc, jsval* aVp)
 73753:   {
 73753:     JSObject* obj = JS_THIS_OBJECT(aCx, aVp);
 83114:     if (!obj) {
 83114:       return false;
 83114:     }
 73753: 
 73753:     const char*& name = sFunctions[1].name;
 73753:     WorkerPrivate* worker = GetInstancePrivate(aCx, obj, name);
 73753:     if (!worker) {
 79840:       return !JS_IsExceptionPending(aCx);
 73753:     }
 73753: 
 73753:     jsval message;
 73753:     if (!JS_ConvertArguments(aCx, aArgc, JS_ARGV(aCx, aVp), "v", &message)) {
 73753:       return false;
 73753:     }
 73753: 
 73753:     return worker->PostMessage(aCx, message);
 73753:   }
 73753: };
 73753: 
 94512: MOZ_STATIC_ASSERT(prototypes::MaxProtoChainLength == 3,
 94512:                   "The MaxProtoChainLength must match our manual DOMJSClasses");
 94512: 
109104: // When this DOMJSClass is removed and it's the last consumer of
109104: // sNativePropertyHooks then sNativePropertyHooks should be removed too.
 94512: DOMJSClass Worker::sClass = {
 94512:   {
 73753:     "Worker",
 94512:     JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1) |
 94512:     JSCLASS_IMPLEMENTS_BARRIERS,
 73753:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 90546:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, Finalize,
 94512:     NULL, NULL, NULL, NULL, Trace
 94512:   },
 94512:   { prototypes::id::EventTarget_workers, prototypes::id::_ID_Count,
 94512:     prototypes::id::_ID_Count },
109104:   -1, false, &sNativePropertyHooks
 73753: };
 73753: 
 73753: JSPropertySpec Worker::sProperties[] = {
 73753:   { sEventStrings[STRING_onerror], STRING_onerror, PROPERTY_FLAGS,
107783:     JSOP_WRAPPER(GetEventListener), JSOP_WRAPPER(SetEventListener) },
 73753:   { sEventStrings[STRING_onmessage], STRING_onmessage, PROPERTY_FLAGS,
107783:     JSOP_WRAPPER(GetEventListener), JSOP_WRAPPER(SetEventListener) },
107783:   { 0, 0, 0, JSOP_NULLWRAPPER, JSOP_NULLWRAPPER }
 73753: };
 73753: 
 73753: JSFunctionSpec Worker::sFunctions[] = {
 73753:   JS_FN("terminate", Terminate, 0, FUNCTION_FLAGS),
 73753:   JS_FN("postMessage", PostMessage, 1, FUNCTION_FLAGS),
 73753:   JS_FS_END
 73753: };
 73753: 
 73753: const char* const Worker::sEventStrings[STRING_COUNT] = {
 73753:   "onerror",
 73753:   "onmessage"
 73753: };
 73753: 
 73753: class ChromeWorker : public Worker
 73753: {
 94512:   static DOMJSClass sClass;
 73753: 
 73753: public:
 73753:   static JSClass*
 73753:   Class()
 73753:   {
 94512:     return sClass.ToJSClass();
 73753:   }
 73753: 
 73753:   static JSObject*
 73753:   InitClass(JSContext* aCx, JSObject* aObj, JSObject* aParentProto,
 73753:             bool aMainRuntime)
 73753:   {
 94512:     JSObject* proto =
 94512:       js::InitClassWithReserved(aCx, aObj, aParentProto, Class(), Construct, 0,
 94512:                                 NULL, NULL, NULL, NULL);
 73753:     if (!proto) {
 73753:       return NULL;
 73753:     }
 73753: 
 73753:     if (!aMainRuntime) {
 73753:       WorkerPrivate* parent = GetWorkerPrivateFromContext(aCx);
 73753:       parent->AssertIsOnWorkerThread();
 73753: 
 73753:       JSObject* constructor = JS_GetConstructor(aCx, proto);
 83265:       if (!constructor)
 73753:         return NULL;
 83265:       js::SetFunctionNativeReserved(constructor, CONSTRUCTOR_SLOT_PARENT,
 83265:                                     PRIVATE_TO_JSVAL(parent));
 73753:     }
 73753: 
 73753:     return proto;
 73753:   }
 73753: 
 73753: private:
 73753:   // No instance of this class should ever be created so these are explicitly
 73753:   // left without an implementation to prevent linking in case someone tries to
 73753:   // make one.
 73753:   ChromeWorker();
 73753:   ~ChromeWorker();
 73753: 
 73753:   static WorkerPrivate*
 73753:   GetInstancePrivate(JSContext* aCx, JSObject* aObj, const char* aFunctionName)
 73753:   {
 73753:     if (aObj) {
 89430:       JSClass* classPtr = JS_GetClass(aObj);
 94512:       if (classPtr == Class()) {
101296:         return UnwrapDOMObject<WorkerPrivate>(aObj);
 73753:       }
 73753:     }
 73753: 
 73753:     return Worker::GetInstancePrivate(aCx, aObj, aFunctionName);
 73753:   }
 73753: 
 73753:   static JSBool
 91237:   Construct(JSContext* aCx, unsigned aArgc, jsval* aVp)
 73753:   {
 94512:     return ConstructInternal(aCx, aArgc, aVp, true, Class());
 73753:   }
 73753: 
 73753:   static void
 94738:   Finalize(JSFreeOp* aFop, JSObject* aObj)
 73753:   {
 94512:     JS_ASSERT(JS_GetClass(aObj) == Class());
101296:     WorkerPrivate* worker = UnwrapDOMObject<WorkerPrivate>(aObj);
 73753:     if (worker) {
 99121:       worker->_finalize(aFop);
 73753:     }
 73753:   }
 73753: 
 73753:   static void
 73753:   Trace(JSTracer* aTrc, JSObject* aObj)
 73753:   {
 94512:     JS_ASSERT(JS_GetClass(aObj) == Class());
101296:     WorkerPrivate* worker = UnwrapDOMObject<WorkerPrivate>(aObj);
 73753:     if (worker) {
 99121:       worker->_trace(aTrc);
 73753:     }
 73753:   }
 73753: };
 73753: 
 94512: MOZ_STATIC_ASSERT(prototypes::MaxProtoChainLength == 3,
 94512:                   "The MaxProtoChainLength must match our manual DOMJSClasses");
 94512: 
109104: // When this DOMJSClass is removed and it's the last consumer of
109104: // sNativePropertyHooks then sNativePropertyHooks should be removed too.
 94512: DOMJSClass ChromeWorker::sClass = {
 94512:   { "ChromeWorker",
 94512:     JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1) |
 94512:     JSCLASS_IMPLEMENTS_BARRIERS,
 73753:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 90546:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, Finalize,
 94512:     NULL, NULL, NULL, NULL, Trace,
 94512:   },
 94512:   { prototypes::id::EventTarget_workers, prototypes::id::_ID_Count,
 94512:     prototypes::id::_ID_Count },
109104:   -1, false, &sNativePropertyHooks
 73753: };
 73753: 
 73753: WorkerPrivate*
 73753: Worker::GetInstancePrivate(JSContext* aCx, JSObject* aObj,
 73753:                            const char* aFunctionName)
 73753: {
 89430:   JSClass* classPtr = JS_GetClass(aObj);
 94512:   if (classPtr == Class() || classPtr == ChromeWorker::Class()) {
101296:     return UnwrapDOMObject<WorkerPrivate>(aObj);
 73753:   }
 73753: 
 73753:   JS_ReportErrorNumber(aCx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 94512:                        Class()->name, aFunctionName, classPtr->name);
 73753:   return NULL;
 73753: }
 73753: 
 73753: } // anonymous namespace
 73753: 
 73753: BEGIN_WORKERS_NAMESPACE
 73753: 
 73753: namespace worker {
 73753: 
 73753: JSObject*
 73753: InitClass(JSContext* aCx, JSObject* aGlobal, JSObject* aProto,
 73753:           bool aMainRuntime)
 73753: {
 73753:   return Worker::InitClass(aCx, aGlobal, aProto, aMainRuntime);
 73753: }
 73753: 
 73753: } // namespace worker
 73753: 
 83422: WorkerCrossThreadDispatcher*
 83422: GetWorkerCrossThreadDispatcher(JSContext* aCx, jsval aWorker)
 83422: {
 83422:   if (JSVAL_IS_PRIMITIVE(aWorker)) {
 83422:     return NULL;
 83422:   }
 83422: 
 83422:   WorkerPrivate* w =
 83422:       Worker::GetInstancePrivate(aCx, JSVAL_TO_OBJECT(aWorker),
 83422:                                  "GetWorkerCrossThreadDispatcher");
 83422:   if (!w) {
 83422:     return NULL;
 83422:   }
 83422:   return w->GetCrossThreadDispatcher();
 83422: }
 83422: 
 83422: 
 73753: namespace chromeworker {
 73753: 
 73753: bool
 73753: InitClass(JSContext* aCx, JSObject* aGlobal, JSObject* aProto,
 73753:           bool aMainRuntime)
 73753: {
 73753:   return !!ChromeWorker::InitClass(aCx, aGlobal, aProto, aMainRuntime);
 73753: }
 73753: 
 73753: } // namespace chromeworker
 73753: 
 87617: bool
 87617: ClassIsWorker(JSClass* aClass)
 87617: {
 87617:   return Worker::Class() == aClass || ChromeWorker::Class() == aClass;
 87617: }
 87617: 
 73753: END_WORKERS_NAMESPACE
