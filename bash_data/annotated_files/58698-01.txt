29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
50491:  * vim: set sw=4 ts=8 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS regular expressions, after Perl.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
50491: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jscntxt.h"
    1: #include "jsgc.h"
47587: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsregexp.h"
    1: #include "jsstr.h"
30451: #include "jsvector.h"
30451: 
50491: #include "jsobjinlines.h"
50491: #include "jsregexpinlines.h"
50491: 
21497: #ifdef JS_TRACER
21491: #include "jstracer.h"
21491: using namespace avmplus;
21491: using namespace nanojit;
21497: #endif
21491: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
53858: /*
53858:  * RegExpStatics allocates memory -- in order to keep the statics stored
53858:  * per-global and not leak, we create a js::Class to wrap the C++ instance and
53858:  * provide an appropriate finalizer. We store an instance of that js::Class in
53858:  * a global reserved slot.
53858:  */
47587: 
53858: static void
53858: resc_finalize(JSContext *cx, JSObject *obj)
50491: {
53858:     RegExpStatics *res = static_cast<RegExpStatics *>(obj->getPrivate());
53858:     cx->destroy<RegExpStatics>(res);
50491: }
50491: 
53858: static void
53858: resc_trace(JSTracer *trc, JSObject *obj)
53858: {
53858:     void *pdata = obj->getPrivate();
53858:     JS_ASSERT(pdata);
53858:     RegExpStatics *res = static_cast<RegExpStatics *>(pdata);
53858:     res->mark(trc);
50491: }
50491: 
53858: Class js::regexp_statics_class = {
53858:     "RegExpStatics", 
53858:     JSCLASS_HAS_PRIVATE | JSCLASS_MARK_IS_TRACE,
53858:     PropertyStub,   /* addProperty */
53858:     PropertyStub,   /* delProperty */
53858:     PropertyStub,   /* getProperty */
53858:     PropertyStub,   /* setProperty */
53858:     EnumerateStub,
53858:     ResolveStub,
53858:     ConvertStub,
53858:     resc_finalize,
53858:     NULL,           /* reserved0   */
53858:     NULL,           /* checkAccess */
53858:     NULL,           /* call        */
53858:     NULL,           /* construct   */
53858:     NULL,           /* xdrObject   */
53858:     NULL,           /* hasInstance */
53858:     JS_CLASS_TRACE(resc_trace)
47587: };
50491: 
50491: /*
50491:  * Lock obj and replace its regexp internals with |newRegExp|.
50491:  * Decref the replaced regexp internals.
50491:  */
50491: static void
50491: SwapObjectRegExp(JSContext *cx, JSObject *obj, RegExp &newRegExp)
50491: {
56567:     RegExp *oldRegExp = RegExp::extractFrom(obj);
50491:     obj->setPrivate(&newRegExp);
50491:     obj->zeroRegExpLastIndex();
50491:     if (oldRegExp)
50491:         oldRegExp->decref(cx);
50491: }
50491: 
50491: JSObject * JS_FASTCALL
50491: js_CloneRegExpObject(JSContext *cx, JSObject *obj, JSObject *proto)
50491: {
50491:     JS_ASSERT(obj->getClass() == &js_RegExpClass);
50491:     JS_ASSERT(proto);
50491:     JS_ASSERT(proto->getClass() == &js_RegExpClass);
50491:     JSObject *clone = NewNativeClassInstance(cx, &js_RegExpClass, proto, proto->getParent());
50491:     if (!clone)
50491:         return NULL;
53858:     RegExpStatics *res = cx->regExpStatics();
50491:     RegExp *re = RegExp::extractFrom(obj);
50491:     {
50491:         uint32 origFlags = re->getFlags();
53858:         uint32 staticsFlags = res->getFlags();
50491:         if ((origFlags & staticsFlags) != staticsFlags) {
50491:             /*
50491:              * This regex is lacking flags from the statics, so we must recompile with the new
50491:              * flags instead of increffing.
50491:              */
50491:             re = RegExp::create(cx, re->getSource(), origFlags | staticsFlags);
50491:         } else {
50491:             re->incref(cx);
50491:         }
50491:     }
50491:     clone->setPrivate(re);
50491:     clone->zeroRegExpLastIndex();
50491:     return clone;
50491: }
50491: 
50491: #ifdef JS_TRACER
50491: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_CloneRegExpObject, CONTEXT, OBJECT, OBJECT, 0,
50491:                      ACCSET_STORE_ANY)
47587: #endif
47587: 
50491: JSBool
50491: js_ObjectIsRegExp(JSObject *obj)
47584: {
50491:     return obj->isRegExp();
47587: }
47587: 
50491: /*
50491:  * js::RegExp
50491:  */
50491: 
50491: void
50491: RegExp::handleYarrError(JSContext *cx, int error)
47587: {
50491:     /* Hack: duplicated from yarr/yarr/RegexParser.h */
50491:     enum ErrorCode {
50491:         NoError,
50491:         PatternTooLarge,
50491:         QuantifierOutOfOrder,
50491:         QuantifierWithoutAtom,
50491:         MissingParentheses,
50491:         ParenthesesUnmatched,
50491:         ParenthesesTypeInvalid,     /* "(?" with bad next char or end of pattern. */
50491:         CharacterClassUnmatched,
50491:         CharacterClassOutOfOrder,
50491:         QuantifierTooLarge,
50491:         EscapeUnterminated
50491:     };
50491:     switch (error) {
50491:       case NoError:
50491:         JS_NOT_REACHED("Precondition violation: an error must have occurred.");
50491:         return;
50491: #define COMPILE_EMSG(__code, __msg) \
50491:       case __code: \
50491:         JS_ReportErrorFlagsAndNumberUC(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL, __msg); \
50491:         return
50491:       COMPILE_EMSG(PatternTooLarge, JSMSG_REGEXP_TOO_COMPLEX);
50491:       COMPILE_EMSG(QuantifierOutOfOrder, JSMSG_BAD_QUANTIFIER);
50491:       COMPILE_EMSG(QuantifierWithoutAtom, JSMSG_BAD_QUANTIFIER);
50491:       COMPILE_EMSG(MissingParentheses, JSMSG_MISSING_PAREN);
50491:       COMPILE_EMSG(ParenthesesUnmatched, JSMSG_UNMATCHED_RIGHT_PAREN);
50491:       COMPILE_EMSG(ParenthesesTypeInvalid, JSMSG_BAD_QUANTIFIER);
50491:       COMPILE_EMSG(CharacterClassUnmatched, JSMSG_BAD_CLASS_RANGE);
50491:       COMPILE_EMSG(CharacterClassOutOfOrder, JSMSG_BAD_CLASS_RANGE);
50491:       COMPILE_EMSG(EscapeUnterminated, JSMSG_TRAILING_SLASH);
50491:       COMPILE_EMSG(QuantifierTooLarge, JSMSG_BAD_QUANTIFIER);
50491: #undef COMPILE_EMSG
50491:       default:
50491:         JS_NOT_REACHED("Precondition violation: unknown Yarr error code.");
47587:     }
47587: }
47587: 
50491: void
50491: RegExp::handlePCREError(JSContext *cx, int error)
47587: {
50491: #define REPORT(__msg) \
50491:     JS_ReportErrorFlagsAndNumberUC(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL, __msg); \
50491:     return
50491:     switch (error) {
50491:       case 0: JS_NOT_REACHED("Precondition violation: an error must have occurred.");
50491:       case 1: REPORT(JSMSG_TRAILING_SLASH);
50491:       case 2: REPORT(JSMSG_TRAILING_SLASH);
50491:       case 3: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
50491:       case 4: REPORT(JSMSG_BAD_QUANTIFIER);
50491:       case 5: REPORT(JSMSG_BAD_QUANTIFIER);
50491:       case 6: REPORT(JSMSG_BAD_CLASS_RANGE);
50491:       case 7: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
50491:       case 8: REPORT(JSMSG_BAD_CLASS_RANGE);
50491:       case 9: REPORT(JSMSG_BAD_QUANTIFIER);
50491:       case 10: REPORT(JSMSG_UNMATCHED_RIGHT_PAREN);
50491:       case 11: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
50491:       case 12: REPORT(JSMSG_UNMATCHED_RIGHT_PAREN);
50491:       case 13: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
50491:       case 14: REPORT(JSMSG_MISSING_PAREN);
50491:       case 15: REPORT(JSMSG_BAD_BACKREF);
50491:       case 16: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
50491:       case 17: REPORT(JSMSG_REGEXP_TOO_COMPLEX);
50491:       default:
50491:         JS_NOT_REACHED("Precondition violation: unknown PCRE error code.");
47587:     }
50491: #undef REPORT
47587: }
47587: 
47587: bool
50491: RegExp::parseFlags(JSContext *cx, JSString *flagStr, uint32 &flagsOut)
47587: {
50491:     const jschar *s;
50491:     size_t n;
50491:     flagStr->getCharsAndLength(s, n);
50491:     flagsOut = 0;
50491:     for (size_t i = 0; i < n; i++) {
50491: #define HANDLE_FLAG(__name)                                             \
50491:         JS_BEGIN_MACRO                                                  \
50491:             if (flagsOut & (__name))                                    \
50491:                 goto bad_flag;                                          \
50491:             flagsOut |= (__name);                                       \
50491:         JS_END_MACRO
50491:         switch (s[i]) {
50491:           case 'i': HANDLE_FLAG(JSREG_FOLD); break;
50491:           case 'g': HANDLE_FLAG(JSREG_GLOB); break;
50491:           case 'm': HANDLE_FLAG(JSREG_MULTILINE); break;
50491:           case 'y': HANDLE_FLAG(JSREG_STICKY); break;
50491:           default:
50491:           bad_flag:
47587:           {
50491:             char charBuf[2];
50491:             charBuf[0] = char(s[i]);
50491:             charBuf[1] = '\0';
50491:             JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
50491:                                          JSMSG_BAD_REGEXP_FLAG, charBuf);
47587:             return false;
47587:           }
47587:         }
50491: #undef HANDLE_FLAG
50491:     }
47587:     return true;
47587: }
47587: 
50491: RegExp *
50491: RegExp::createFlagged(JSContext *cx, JSString *str, JSString *opt)
47587: {
50491:     if (!opt)
50491:         return create(cx, str, 0);
50491:     uint32 flags = 0;
50491:     if (!parseFlags(cx, opt, flags))
47587:         return false;
50491:     return create(cx, str, flags);
47587: }
47587: 
47587: /*
50491:  * RegExp instance properties.
47587:  */
43218: #define DEFINE_GETTER(name, code)                                              \
43218:     static JSBool                                                              \
48470:     name(JSContext *cx, JSObject *obj, jsid id, Value *vp)                     \
43218:     {                                                                          \
43218:         while (obj->getClass() != &js_RegExpClass) {                           \
43218:             obj = obj->getProto();                                             \
43218:             if (!obj)                                                          \
43218:                 return true;                                                   \
43218:         }                                                                      \
50491:         RegExp *re = RegExp::extractFrom(obj);                                 \
43218:         code;                                                                  \
43218:         return true;                                                           \
43218:     }
43218: 
43218: /* lastIndex is stored in the object, re = re silences the compiler warning. */
43218: DEFINE_GETTER(lastIndex_getter,  re = re; *vp = obj->getRegExpLastIndex())
50491: DEFINE_GETTER(source_getter,     *vp = StringValue(re->getSource()))
50491: DEFINE_GETTER(global_getter,     *vp = BooleanValue(re->global()))
50491: DEFINE_GETTER(ignoreCase_getter, *vp = BooleanValue(re->ignoreCase()))
50491: DEFINE_GETTER(multiline_getter,  *vp = BooleanValue(re->multiline()))
50491: DEFINE_GETTER(sticky_getter,     *vp = BooleanValue(re->sticky()))
43218: 
    1: static JSBool
48470: lastIndex_setter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
40826:     while (obj->getClass() != &js_RegExpClass) {
39928:         obj = obj->getProto();
15692:         if (!obj)
43218:             return true;
43218:     }
48544:     obj->setRegExpLastIndex(*vp);
48470:     return true;
    1: }
    1: 
47436: static const struct LazyProp {
47436:     const char *name;
47436:     uint16 atomOffset;
48470:     PropertyOp getter;
47569: } lazyRegExpProps[] = {
47436:     { js_source_str,     ATOM_OFFSET(source),     source_getter },
47436:     { js_global_str,     ATOM_OFFSET(global),     global_getter },
47436:     { js_ignoreCase_str, ATOM_OFFSET(ignoreCase), ignoreCase_getter },
47436:     { js_multiline_str,  ATOM_OFFSET(multiline),  multiline_getter },
47436:     { js_sticky_str,     ATOM_OFFSET(sticky),     sticky_getter }
30353: };
30353: 
47569: static JSBool
50491: regexp_resolve(JSContext *cx, JSObject *obj, jsid id, uint32 flags, JSObject **objp)
47569: {
47569:     JS_ASSERT(obj->isRegExp());
47569: 
47569:     if (!JSID_IS_ATOM(id))
47569:         return JS_TRUE;
47569: 
47569:     if (id == ATOM_TO_JSID(cx->runtime->atomState.lastIndexAtom)) {
48470:         if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(),
47569:                                      lastIndex_getter, lastIndex_setter,
50491:                                      JSPROP_PERMANENT | JSPROP_SHARED,
50491:                                      0, 0, NULL)) {
50491:             return false;
47569:         }
47569:         *objp = obj;
50491:         return true;
47569:     }
47569: 
47569:     for (size_t i = 0; i < JS_ARRAY_LENGTH(lazyRegExpProps); i++) {
47569:         const LazyProp &lazy = lazyRegExpProps[i];
47436:         JSAtom *atom = OFFSET_TO_ATOM(cx->runtime, lazy.atomOffset);
47436:         if (id == ATOM_TO_JSID(atom)) {
48470:             if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(),
47436:                                          lazy.getter, NULL,
47436:                                          JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_READONLY,
47436:                                          0, 0, NULL)) {
50491:                 return false;
47436:             }
47436:             *objp = obj;
50491:             return true;
47436:         }
47436:     }
47436: 
50491:     return true;
47436: }
47436: 
    1: /*
50491:  * RegExp static properties.
50491:  *
    1:  * RegExp class static properties and their Perl counterparts:
    1:  *
    1:  *  RegExp.input                $_
    1:  *  RegExp.multiline            $*
    1:  *  RegExp.lastMatch            $&
    1:  *  RegExp.lastParen            $+
    1:  *  RegExp.leftContext          $`
    1:  *  RegExp.rightContext         $'
    1:  */
    1: 
43218: #define DEFINE_STATIC_GETTER(name, code)                                        \
43218:     static JSBool                                                               \
48470:     name(JSContext *cx, JSObject *obj, jsid id, jsval *vp)                      \
43218:     {                                                                           \
53858:         RegExpStatics *res = cx->regExpStatics();                               \
43218:         code;                                                                   \
43218:     }
43218: 
57789: DEFINE_STATIC_GETTER(static_input_getter,        return res->createPendingInput(cx, Valueify(vp)))
53858: DEFINE_STATIC_GETTER(static_multiline_getter,    *vp = BOOLEAN_TO_JSVAL(res->multiline());
50491:                                                  return true)
53858: DEFINE_STATIC_GETTER(static_lastMatch_getter,    return res->createLastMatch(cx, Valueify(vp)))
53858: DEFINE_STATIC_GETTER(static_lastParen_getter,    return res->createLastParen(cx, Valueify(vp)))
53858: DEFINE_STATIC_GETTER(static_leftContext_getter,  return res->createLeftContext(cx, Valueify(vp)))
53858: DEFINE_STATIC_GETTER(static_rightContext_getter, return res->createRightContext(cx, Valueify(vp)))
47587: 
58698: DEFINE_STATIC_GETTER(static_paren1_getter,       return res->createParen(cx, 1, Valueify(vp)))
58698: DEFINE_STATIC_GETTER(static_paren2_getter,       return res->createParen(cx, 2, Valueify(vp)))
58698: DEFINE_STATIC_GETTER(static_paren3_getter,       return res->createParen(cx, 3, Valueify(vp)))
58698: DEFINE_STATIC_GETTER(static_paren4_getter,       return res->createParen(cx, 4, Valueify(vp)))
58698: DEFINE_STATIC_GETTER(static_paren5_getter,       return res->createParen(cx, 5, Valueify(vp)))
58698: DEFINE_STATIC_GETTER(static_paren6_getter,       return res->createParen(cx, 6, Valueify(vp)))
58698: DEFINE_STATIC_GETTER(static_paren7_getter,       return res->createParen(cx, 7, Valueify(vp)))
58698: DEFINE_STATIC_GETTER(static_paren8_getter,       return res->createParen(cx, 8, Valueify(vp)))
58698: DEFINE_STATIC_GETTER(static_paren9_getter,       return res->createParen(cx, 9, Valueify(vp)))
43218: 
43218: #define DEFINE_STATIC_SETTER(name, code)                                        \
43218:     static JSBool                                                               \
48470:     name(JSContext *cx, JSObject *obj, jsid id, jsval *vp)                      \
43218:     {                                                                           \
53858:         RegExpStatics *res = cx->regExpStatics();                               \
43218:         code;                                                                   \
43218:         return true;                                                            \
43218:     }
43218: 
43218: DEFINE_STATIC_SETTER(static_input_setter,
43218:                      if (!JSVAL_IS_STRING(*vp) && !JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp))
43218:                          return false;
57789:                      res->setPendingInput(JSVAL_TO_STRING(*vp)))
43218: DEFINE_STATIC_SETTER(static_multiline_setter,
43218:                      if (!JSVAL_IS_BOOLEAN(*vp) && !JS_ConvertValue(cx, *vp, JSTYPE_BOOLEAN, vp))
43218:                          return false;
53858:                      res->setMultiline(!!JSVAL_TO_BOOLEAN(*vp)))
43218: 
47436: const uint8 REGEXP_STATIC_PROP_ATTRS    = JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE;
47436: const uint8 RO_REGEXP_STATIC_PROP_ATTRS = REGEXP_STATIC_PROP_ATTRS | JSPROP_READONLY;
    1: 
    1: static JSPropertySpec regexp_static_props[] = {
47436:     {"input",        0, REGEXP_STATIC_PROP_ATTRS,    static_input_getter, static_input_setter},
43218:     {"multiline",    0, REGEXP_STATIC_PROP_ATTRS,    static_multiline_getter,
43218:                                                      static_multiline_setter},
43218:     {"lastMatch",    0, RO_REGEXP_STATIC_PROP_ATTRS, static_lastMatch_getter,    NULL},
43218:     {"lastParen",    0, RO_REGEXP_STATIC_PROP_ATTRS, static_lastParen_getter,    NULL},
43218:     {"leftContext",  0, RO_REGEXP_STATIC_PROP_ATTRS, static_leftContext_getter,  NULL},
43218:     {"rightContext", 0, RO_REGEXP_STATIC_PROP_ATTRS, static_rightContext_getter, NULL},
43218:     {"$1",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren1_getter,       NULL},
43218:     {"$2",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren2_getter,       NULL},
43218:     {"$3",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren3_getter,       NULL},
43218:     {"$4",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren4_getter,       NULL},
43218:     {"$5",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren5_getter,       NULL},
43218:     {"$6",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren6_getter,       NULL},
43218:     {"$7",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren7_getter,       NULL},
43218:     {"$8",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren8_getter,       NULL},
43218:     {"$9",           0, RO_REGEXP_STATIC_PROP_ATTRS, static_paren9_getter,       NULL},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: static void
    1: regexp_finalize(JSContext *cx, JSObject *obj)
    1: {
50491:     RegExp *re = RegExp::extractFrom(obj);
    1:     if (!re)
    1:         return;
50491:     re->decref(cx);
    1: }
    1: 
    1: /* Forward static prototype. */
    1: static JSBool
50491: regexp_exec_sub(JSContext *cx, JSObject *obj, uintN argc, Value *argv, JSBool test, Value *rval);
    1: 
    1: static JSBool
53557: regexp_call(JSContext *cx, uintN argc, Value *vp)
    1: {
53557:     return regexp_exec_sub(cx, &JS_CALLEE(cx, vp).toObject(), argc, JS_ARGV(cx, vp), false, vp);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: #include "jsxdrapi.h"
    1: 
28093: JSBool
28093: js_XDRRegExpObject(JSXDRState *xdr, JSObject **objp)
    1: {
50491:     JSString *source = 0;
50491:     uint32 flagsword = 0;
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
50491:         JS_ASSERT(objp);
50491:         RegExp *re = RegExp::extractFrom(*objp);
    1:         if (!re)
50491:             return false;
50491:         source = re->getSource();
50491:         flagsword = re->getFlags();
47587:     }
50491:     if (!JS_XDRString(xdr, &source) || !JS_XDRUint32(xdr, &flagsword))
50491:         return false;
    1:     if (xdr->mode == JSXDR_DECODE) {
50491:         JSObject *obj = NewBuiltinClassInstance(xdr->cx, &js_RegExpClass);
    1:         if (!obj)
50491:             return false;
39930:         obj->clearParent();
39928:         obj->clearProto();
50491:         RegExp *re = RegExp::create(xdr->cx, source, flagsword);
    1:         if (!re)
50491:             return false;
31452:         obj->setPrivate(re);
40901:         obj->zeroRegExpLastIndex();
    1:         *objp = obj;
    1:     }
50491:     return true;
    1: }
    1: 
    1: #else  /* !JS_HAS_XDR */
    1: 
28093: #define js_XDRRegExpObject NULL
    1: 
    1: #endif /* !JS_HAS_XDR */
    1: 
  583: static void
  583: regexp_trace(JSTracer *trc, JSObject *obj)
    1: {
50491:     RegExp *re = RegExp::extractFrom(obj);
50491:     if (re && re->getSource())
54707:         MarkString(trc, re->getSource(), "source");
    1: }
    1: 
50491: static JSBool
50491: regexp_enumerate(JSContext *cx, JSObject *obj)
50491: {
50491:     JS_ASSERT(obj->isRegExp());
50491: 
50491:     jsval v;
50491:     if (!JS_LookupPropertyById(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.lastIndexAtom), &v))
50491:         return false;
50491: 
50491:     for (size_t i = 0; i < JS_ARRAY_LENGTH(lazyRegExpProps); i++) {
50491:         const LazyProp &lazy = lazyRegExpProps[i];
50491:         jsid id = ATOM_TO_JSID(OFFSET_TO_ATOM(cx->runtime, lazy.atomOffset));
50491:         if (!JS_LookupPropertyById(cx, obj, id, &v))
50491:             return false;
50491:     }
50491: 
50491:     return true;
50491: }
50491: 
50491: js::Class js_RegExpClass = {
    1:     js_RegExp_str,
47436:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::REGEXP_CLASS_RESERVED_SLOTS) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_RegExp),
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     regexp_enumerate,
48622:     reinterpret_cast<JSResolveOp>(regexp_resolve),
48622:     ConvertStub,
48622:     regexp_finalize,
48622:     NULL,           /* reserved0 */
48622:     NULL,           /* checkAccess */
48622:     regexp_call,
48622:     NULL,           /* construct */
48622:     js_XDRRegExpObject,
48622:     NULL,           /* hasInstance */
48622:     JS_CLASS_TRACE(regexp_trace)
    1: };
    1: 
50491: /*
50491:  * RegExp instance methods.
50491:  */
    1: 
    1: JSBool
48470: js_regexp_toString(JSContext *cx, JSObject *obj, Value *vp)
    1: {
50491:     static const jschar empty_regexp_ucstr[] = {'(', '?', ':', ')', 0};
48470:     if (!InstanceOf(cx, obj, &js_RegExpClass, vp + 2))
50491:         return false;
50491:     RegExp *re = RegExp::extractFrom(obj);
    1:     if (!re) {
50491:         *vp = StringValue(cx->runtime->emptyString);
50491:         return true;
    1:     }
    1: 
50491:     const jschar *source;
50491:     size_t length;
50491:     re->getSource()->getCharsAndLength(source, length);
    1:     if (length == 0) {
    1:         source = empty_regexp_ucstr;
 8336:         length = JS_ARRAY_LENGTH(empty_regexp_ucstr) - 1;
    1:     }
    1:     length += 2;
50491:     uint32 nflags = re->flagCount();
50491:     jschar *chars = (jschar*) cx->malloc((length + nflags + 1) * sizeof(jschar));
    1:     if (!chars) {
50491:         return false;
    1:     }
    1: 
    1:     chars[0] = '/';
    1:     js_strncpy(&chars[1], source, length - 2);
    1:     chars[length - 1] = '/';
    1:     if (nflags) {
50491:         if (re->global())
    1:             chars[length++] = 'g';
50491:         if (re->ignoreCase())
    1:             chars[length++] = 'i';
50491:         if (re->multiline())
    1:             chars[length++] = 'm';
50491:         if (re->sticky())
    1:             chars[length++] = 'y';
    1:     }
    1:     chars[length] = 0;
    1: 
50491:     JSString *str = js_NewString(cx, chars, length);
    1:     if (!str) {
30851:         cx->free(chars);
50491:         return false;
    1:     }
50491:     *vp = StringValue(str);
50491:     return true;
    1: }
    1: 
    1: static JSBool
48470: regexp_toString(JSContext *cx, uintN argc, Value *vp)
 4127: {
50491:     JSObject *obj = JS_THIS_OBJECT(cx, Jsvalify(vp));
11809:     return obj && js_regexp_toString(cx, obj, vp);
 4127: }
 4127: 
50491: /*
50491:  * Return:
50491:  * - The original if no escaping need be performed.
50491:  * - A new string if escaping need be performed.
50491:  * - NULL on error.
50491:  */
50491: static JSString *
50491: EscapeNakedForwardSlashes(JSContext *cx, JSString *unescaped)
50491: {
50491:     const jschar *oldChars;
50491:     size_t oldLen;
50491:     unescaped->getCharsAndLength(oldChars, oldLen);
50491:     js::Vector<jschar, 128> newChars(cx);
50491:     for (const jschar *it = oldChars; it < oldChars + oldLen; ++it) {
50491:         if (*it == '/' && (it == oldChars || it[-1] != '\\')) {
50491:             if (!newChars.length()) {
50491:                 if (!newChars.reserve(oldLen + 1))
50491:                     return NULL;
50491:                 newChars.append(oldChars, size_t(it - oldChars));
50491:             }
50491:             newChars.append('\\');
50491:         }
50491: 
50491:         if (newChars.length())
50491:             newChars.append(*it);
50491:     }
50491: 
50491:     if (newChars.length()) {
50491:         size_t len = newChars.length();
50491:         jschar *chars = newChars.extractRawBuffer();
50491:         if (!chars)
50491:             return NULL;
50491:         JSString *escaped = js_NewString(cx, chars, len);
50491:         if (!escaped)
50491:             cx->free(chars);
50491:         return escaped;
50491:     }
50491:     return unescaped;
50491: }
50491: 
53858: static bool
50491: regexp_compile_sub_tail(JSContext *cx, JSObject *obj, Value *rval, JSString *str, uint32 flags = 0)
50491: {
53858:     flags |= cx->regExpStatics()->getFlags();
50491:     RegExp *re = RegExp::create(cx, str, flags);
50491:     if (!re)
50491:         return false;
50491:     SwapObjectRegExp(cx, obj, *re);
50491:     *rval = ObjectValue(*obj);
50491:     return true;
50491: }
50491: 
47587: static JSBool
50491: regexp_compile_sub(JSContext *cx, JSObject *obj, uintN argc, Value *argv, Value *rval)
47584: {
50491:     if (!InstanceOf(cx, obj, &js_RegExpClass, argv))
50491:         return false;
53858: 
50491:     if (argc == 0)
50491:         return regexp_compile_sub_tail(cx, obj, rval, cx->runtime->emptyString);
47587: 
50491:     Value sourceValue = argv[0];
50491:     if (sourceValue.isObject() && sourceValue.toObject().getClass() == &js_RegExpClass) {
    1:         /*
    1:          * If we get passed in a RegExp object we construct a new
    1:          * RegExp that is a duplicate of it by re-compiling the
    1:          * original source code. ECMA requires that it be an error
    1:          * here if the flags are specified. (We must use the flags
    1:          * from the original RegExp also).
    1:          */
50491:         JSObject &sourceObj = sourceValue.toObject();
50491:         if (argc >= 2 && !argv[1].isUndefined()) {
50491:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NEWREGEXP_FLAGGED);
50491:             return false;
47587:         }
50491:         RegExp *clone;
50491:         {
50491:             RegExp *re = RegExp::extractFrom(&sourceObj);
50491:             if (!re)
50491:                 return false;
50491:             clone = RegExp::clone(cx, *re);
47587:         }
50491:         if (!clone)
50491:             return false;
50491:         SwapObjectRegExp(cx, obj, *clone);
50491:         *rval = ObjectValue(*obj);
50491:         return true;
47587:     }
47587: 
50491:     /* Coerce to string and compile. */
50491:     JSString *sourceStr = js_ValueToString(cx, sourceValue);
50491:     if (!sourceStr)
50491:         return false;
50491:     argv[0] = StringValue(sourceStr);
50491:     uint32 flags = 0;
50491:     if (argc > 1 && !argv[1].isUndefined()) {
50491:         JSString *flagStr = js_ValueToString(cx, argv[1]);
50491:         if (!flagStr)
50491:             return false;
50491:         argv[1] = StringValue(flagStr);
50491:         if (!RegExp::parseFlags(cx, flagStr, flags))
50491:             return false;
47587:     }
47587: 
50491:     JSString *escapedSourceStr = EscapeNakedForwardSlashes(cx, sourceStr);
50491:     if (!escapedSourceStr)
50491:         return false;
50491:     argv[0] = StringValue(escapedSourceStr);
53858: 
50491:     return regexp_compile_sub_tail(cx, obj, rval, escapedSourceStr, flags);
    1: }
    1: 
    1: static JSBool
48470: regexp_compile(JSContext *cx, uintN argc, Value *vp)
 4127: {
50491:     JSObject *obj = JS_THIS_OBJECT(cx, Jsvalify(vp));
11809:     return obj && regexp_compile_sub(cx, obj, argc, vp + 2, vp);
 4127: }
 4127: 
 4127: static JSBool
50491: regexp_exec_sub(JSContext *cx, JSObject *obj, uintN argc, Value *argv, JSBool test, Value *rval)
    1: {
50491:     bool ok = InstanceOf(cx, obj, &js_RegExpClass, argv);
    1:     if (!ok)
    1:         return JS_FALSE;
56567: 
50491:     RegExp *re = RegExp::extractFrom(obj);
56567:     if (!re)
    1:         return JS_TRUE;
    1: 
    1:     /* NB: we must reach out: after this paragraph, in order to drop re. */
50491:     re->incref(cx);
50491:     jsdouble lastIndex;
50491:     if (re->global() || re->sticky()) {
50491:         const Value v = obj->getRegExpLastIndex();
48554:         if (v.isInt32()) {
48554:             lastIndex = v.toInt32();
40901:         } else {
48554:             if (v.isDouble())
48554:                 lastIndex = v.toDouble();
48554:             else if (!ValueToNumber(cx, v, &lastIndex))
48544:                 return JS_FALSE;
48554:             lastIndex = js_DoubleToInteger(lastIndex);
40901:         }
40901:     } else {
40901:         lastIndex = 0;
40901:     }
    1: 
    1:     /* Now that obj is unlocked, it's safe to (potentially) grab the GC lock. */
53858:     RegExpStatics *res = cx->regExpStatics();
50491:     JSString *str;
50491:     if (argc) {
    1:         str = js_ValueToString(cx, argv[0]);
    1:         if (!str) {
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
50491:         argv[0] = StringValue(str);
50491:     } else {
50491:         /* Need to grab input from statics. */
57789:         str = res->getPendingInput();
50491:         if (!str) {
57812:             JSAutoByteString sourceBytes(cx, re->getSource());
57812:             if (!!sourceBytes) {
57812:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_INPUT,
57812:                                      sourceBytes.ptr(),
50491:                                      re->global() ? "g" : "",
50491:                                      re->ignoreCase() ? "i" : "",
50491:                                      re->multiline() ? "m" : "",
50491:                                      re->sticky() ? "y" : "");
50491:             }
50491:             ok = false;
50491:             goto out;
50491:         }
    1:     }
    1: 
29366:     if (lastIndex < 0 || str->length() < lastIndex) {
40901:         obj->zeroRegExpLastIndex();
50491:         *rval = NullValue();
    1:     } else {
50491:         size_t lastIndexInt = (size_t) lastIndex;
53858:         ok = re->execute(cx, res, str, &lastIndexInt, !!test, rval);
50491:         if (ok && (re->global() || (!rval->isNull() && re->sticky()))) {
48470:             if (rval->isNull())
40901:                 obj->zeroRegExpLastIndex();
31934:             else
50491:                 obj->setRegExpLastIndex(lastIndexInt);
    1:         }
    1:     }
    1: 
    1:   out:
50491:     re->decref(cx);
    1:     return ok;
    1: }
    1: 
53558: JSBool
53558: js_regexp_exec(JSContext *cx, uintN argc, Value *vp)
    1: {
50491:     return regexp_exec_sub(cx, JS_THIS_OBJECT(cx, Jsvalify(vp)), argc, vp + 2, JS_FALSE, vp);
    1: }
    1: 
53558: JSBool
53558: js_regexp_test(JSContext *cx, uintN argc, Value *vp)
    1: {
50491:     if (!regexp_exec_sub(cx, JS_THIS_OBJECT(cx, Jsvalify(vp)), argc, vp + 2, JS_TRUE, vp))
50491:         return false;
48470:     if (!vp->isTrue())
48470:         vp->setBoolean(false);
50491:     return true;
    1: }
    1: 
    1: static JSFunctionSpec regexp_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,  regexp_toString,    0,0),
    1: #endif
16519:     JS_FN(js_toString_str,  regexp_toString,    0,0),
16519:     JS_FN("compile",        regexp_compile,     2,0),
53558:     JS_FN("exec",           js_regexp_exec,     1,0),
53558:     JS_FN("test",           js_regexp_test,     1,0),
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSBool
53557: regexp_construct(JSContext *cx, uintN argc, Value *vp)
    1: {
53586:     Value *argv = JS_ARGV(cx, vp);
53587:     if (!IsConstructing(vp)) {
    1:         /*
    1:          * If first arg is regexp and no flags are given, just return the arg.
 4127:          * (regexp_compile_sub detects the regexp + flags case and throws a
53586:          * TypeError.)  See 15.10.3.1.
    1:          */
53586:         if (argc >= 1 && argv[0].isObject() && argv[0].toObject().isRegExp() &&
53586:             (argc == 1 || argv[1].isUndefined()))
53586:         {
53557:             *vp = argv[0];
50491:             return true;
    1:         }
53586:     }
    1: 
    1:     /* Otherwise, replace obj with a new RegExp object. */
53557:     JSObject *obj = NewBuiltinClassInstance(cx, &js_RegExpClass);
    1:     if (!obj)
50491:         return false;
    1: 
53557:     return regexp_compile_sub(cx, obj, argc, argv, vp);
    1: }
    1: 
53858: /* Similar to regexp_compile_sub_tail. */
53858: static bool
53858: InitRegExpClassCompile(JSContext *cx, JSObject *obj)
53858: {
53858:     RegExp *re = RegExp::create(cx, cx->runtime->emptyString, 0);
53858:     if (!re)
53858:         return false;
53858:     SwapObjectRegExp(cx, obj, *re);
53858:     return true;
53858: }
53858: 
    1: JSObject *
    1: js_InitRegExpClass(JSContext *cx, JSObject *obj)
    1: {
58297:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_RegExpClass, regexp_construct, 2,
47436:                                    NULL, regexp_methods, regexp_static_props, NULL);
25897:     if (!proto)
25897:         return NULL;
25897: 
25897:     JSObject *ctor = JS_GetConstructor(cx, proto);
25897:     if (!ctor)
25897:         return NULL;
25897: 
25897:     /* Give RegExp.prototype private data so it matches the empty string. */
    1:     if (!JS_AliasProperty(cx, ctor, "input",        "$_") ||
    1:         !JS_AliasProperty(cx, ctor, "multiline",    "$*") ||
    1:         !JS_AliasProperty(cx, ctor, "lastMatch",    "$&") ||
    1:         !JS_AliasProperty(cx, ctor, "lastParen",    "$+") ||
    1:         !JS_AliasProperty(cx, ctor, "leftContext",  "$`") ||
25897:         !JS_AliasProperty(cx, ctor, "rightContext", "$'") ||
53858:         !InitRegExpClassCompile(cx, proto)) {
25897:         return NULL;
25897:     }
25897: 
    1:     return proto;
    1: }
