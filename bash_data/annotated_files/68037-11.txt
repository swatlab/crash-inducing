31673: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
31673: /* ***** BEGIN LICENSE BLOCK *****
31673:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
31673:  *
31673:  * The contents of this file are subject to the Mozilla Public License Version
31673:  * 1.1 (the "License"); you may not use this file except in compliance with
31673:  * the License. You may obtain a copy of the License at
31673:  * http://www.mozilla.org/MPL/
31673:  *
31673:  * Software distributed under the License is distributed on an "AS IS" basis,
31673:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
31673:  * for the specific language governing rights and limitations under the
31673:  * License.
31673:  *
31673:  * The Original Code is mozilla.org code.
31673:  *
31673:  * The Initial Developer of the Original Code is
63247:  * Mozilla Foundation.
31673:  * Portions created by the Initial Developer are Copyright (C) 2009
31673:  * the Initial Developer. All Rights Reserved.
31673:  *
31673:  * Contributor(s):
31673:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
31673:  *
31673:  * Alternatively, the contents of this file may be used under the terms of
31673:  * either of the GNU General Public License Version 2 or later (the "GPL"),
31673:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
31673:  * in which case the provisions of the GPL or the LGPL are applicable instead
31673:  * of those above. If you wish to allow use of your version of this file only
31673:  * under the terms of either the GPL or the LGPL, and not to allow others to
31673:  * use your version of this file under the terms of the MPL, indicate your
31673:  * decision by deleting the provisions above and replace them with the notice
31673:  * and other provisions required by the GPL or the LGPL. If you do not delete
31673:  * the provisions above, a recipient may use your version of this file under
31673:  * the terms of any one of the MPL, the GPL or the LGPL.
31673:  *
31673:  * ***** END LICENSE BLOCK ***** */
31673: 
32381: #include "nsXULTreeGridAccessibleWrap.h"
31673: 
41384: #include "nsAccCache.h"
41384: #include "nsAccessibilityService.h"
41384: #include "nsAccUtils.h"
57413: #include "nsDocAccessible.h"
41384: #include "nsEventShell.h"
67790: #include "States.h"
41384: 
31673: #include "nsITreeSelection.h"
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridAccessible
31673: ////////////////////////////////////////////////////////////////////////////////
31673: 
31673: nsXULTreeGridAccessible::
43504:   nsXULTreeGridAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsXULTreeAccessible(aContent, aShell)
31673: {
31673: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridAccessible: nsISupports implementation
31673: 
31673: NS_IMPL_ISUPPORTS_INHERITED1(nsXULTreeGridAccessible,
31673:                              nsXULTreeAccessible,
31673:                              nsIAccessibleTable)
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridAccessible: nsIAccessibleTable implementation
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::GetCaption(nsIAccessible **aCaption)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aCaption);
31673:   *aCaption = nsnull;
31673: 
31673:   return IsDefunct() ? NS_ERROR_FAILURE : NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::GetSummary(nsAString &aSummary)
31673: {
31673:   aSummary.Truncate();
31673:   return IsDefunct() ? NS_ERROR_FAILURE : NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
35523: nsXULTreeGridAccessible::GetColumnCount(PRInt32 *aColumnCount)
31673: {
35523:   NS_ENSURE_ARG_POINTER(aColumnCount);
35523:   *aColumnCount = 0;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
35523:   *aColumnCount = nsCoreUtils::GetSensibleColumnCount(mTree);
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetRowCount(PRInt32 *arowCount)
31673: {
32381:   NS_ENSURE_ARG_POINTER(arowCount);
32381:   *arowCount = nsnull;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
32381:   return mTreeView->GetRowCount(arowCount);
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetSelectedCellCount(PRUint32* aCount)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aCount);
31673:   *aCount = 0;
31673: 
32381:   PRUint32 selectedrowCount = 0;
32381:   nsresult rv = GetSelectedRowCount(&selectedrowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   *aCount = selectedrowCount * columnCount;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetSelectedColumnCount(PRUint32* aCount)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aCount);
31673:   *aCount = 0;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   // If all the row has been selected, then all the columns are selected,
31673:   // because we can't select a column alone.
31673: 
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   PRInt32 selectedrowCount = 0;
32381:   rv = GetSelectionCount(&selectedrowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   if (rowCount == selectedrowCount) {
32381:     PRInt32 columnCount = 0;
32381:     rv = GetColumnCount(&columnCount);
31673:     NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:     *aCount = columnCount;
31673:   }
31673: 
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetSelectedRowCount(PRUint32* aCount)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aCount);
31673:   *aCount = 0;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
32381:   PRInt32 selectedrowCount = 0;
32381:   nsresult rv = GetSelectionCount(&selectedrowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   *aCount = selectedrowCount;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetSelectedCells(nsIArray **aCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aCells);
32381:   *aCells = nsnull;
32381: 
32381:   nsCOMPtr<nsIMutableArray> selCells = do_CreateInstance(NS_ARRAY_CONTRACTID);
32381:   NS_ENSURE_TRUE(selCells, NS_ERROR_FAILURE);
32381: 
32381:   PRInt32 selectedrowCount = 0;
32381:   nsresult rv = GetSelectionCount(&selectedrowCount);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   nsCOMPtr<nsITreeSelection> selection;
32381:   rv = mTreeView->GetSelection(getter_AddRefs(selection));
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRInt32 rowCount = 0;
32381:   rv = GetRowCount(&rowCount);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   PRBool isSelected;
32381:   for (PRInt32 rowIdx = 0; rowIdx < rowCount; rowIdx++) {
32381:     selection->IsSelected(rowIdx, &isSelected);
32381:     if (isSelected) {
32381:       for (PRInt32 colIdx = 0; colIdx < columnCount; colIdx++) {
32381:         nsCOMPtr<nsIAccessible> cell;
32381:         GetCellAt(rowIdx, colIdx, getter_AddRefs(cell));
32381:         selCells->AppendElement(cell, PR_FALSE);
32381:       }
32381:     }
32381:   }
32381: 
32381:   NS_ADDREF(*aCells = selCells);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetSelectedCellIndices(PRUint32 *aCellsCount,
31673:                                                 PRInt32 **aCells)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aCellsCount);
31673:   *aCellsCount = 0;
31673:   NS_ENSURE_ARG_POINTER(aCells);
31673:   *aCells = nsnull;
31673: 
32381:   PRInt32 selectedrowCount = 0;
32381:   nsresult rv = GetSelectionCount(&selectedrowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   PRInt32 selectedCellCount = selectedrowCount * columnCount;
31673:   PRInt32* outArray = static_cast<PRInt32*>(
32381:     nsMemory::Alloc(selectedCellCount * sizeof(PRInt32)));
31673:   NS_ENSURE_TRUE(outArray, NS_ERROR_OUT_OF_MEMORY);
31673: 
31673:   nsCOMPtr<nsITreeSelection> selection;
31673:   rv = mTreeView->GetSelection(getter_AddRefs(selection));
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   PRInt32 rowCount = 0;
32381:   rv = GetRowCount(&rowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
31673:   PRBool isSelected;
32381:   for (PRInt32 rowIdx = 0, arrayIdx = 0; rowIdx < rowCount; rowIdx++) {
31673:     selection->IsSelected(rowIdx, &isSelected);
31673:     if (isSelected) {
32381:       for (PRInt32 colIdx = 0; colIdx < columnCount; colIdx++)
32381:         outArray[arrayIdx++] = rowIdx * columnCount + colIdx;
31673:     }
31673:   }
31673: 
32381:   *aCellsCount = selectedCellCount;
31673:   *aCells = outArray;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetSelectedColumnIndices(PRUint32 *acolumnCount,
31673:                                                   PRInt32 **aColumns)
31673: {
32381:   NS_ENSURE_ARG_POINTER(acolumnCount);
32381:   *acolumnCount = 0;
31673:   NS_ENSURE_ARG_POINTER(aColumns);
31673:   *aColumns = nsnull;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   // If all the row has been selected, then all the columns are selected.
31673:   // Because we can't select a column alone.
31673: 
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   PRInt32 selectedrowCount = 0;
32381:   rv = GetSelectionCount(&selectedrowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   if (rowCount != selectedrowCount)
31673:     return NS_OK;
31673: 
32381:   PRInt32 columnCount = 0;
32381:   rv = GetColumnCount(&columnCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
31673:   PRInt32* outArray = static_cast<PRInt32*>(
32381:     nsMemory::Alloc(columnCount * sizeof(PRInt32)));
31673:   NS_ENSURE_TRUE(outArray, NS_ERROR_OUT_OF_MEMORY);
31673: 
32381:   for (PRInt32 colIdx = 0; colIdx < columnCount; colIdx++)
31673:     outArray[colIdx] = colIdx;
31673: 
32381:   *acolumnCount = columnCount;
31673:   *aColumns = outArray;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetSelectedRowIndices(PRUint32 *arowCount,
32381:                                                PRInt32 **aRows)
31673: {
32381:   NS_ENSURE_ARG_POINTER(arowCount);
32381:   *arowCount = 0;
31673:   NS_ENSURE_ARG_POINTER(aRows);
31673:   *aRows = nsnull;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
32381:   PRInt32 selectedrowCount = 0;
32381:   nsresult rv = GetSelectionCount(&selectedrowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
31673:   PRInt32* outArray = static_cast<PRInt32*>(
32381:     nsMemory::Alloc(selectedrowCount * sizeof(PRInt32)));
31673:   NS_ENSURE_TRUE(outArray, NS_ERROR_OUT_OF_MEMORY);
31673: 
31673:   nsCOMPtr<nsITreeSelection> selection;
31673:   rv = mTreeView->GetSelection(getter_AddRefs(selection));
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   PRInt32 rowCount = 0;
32381:   rv = GetRowCount(&rowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
31673:   PRBool isSelected;
32381:   for (PRInt32 rowIdx = 0, arrayIdx = 0; rowIdx < rowCount; rowIdx++) {
31673:     selection->IsSelected(rowIdx, &isSelected);
31673:     if (isSelected)
31673:       outArray[arrayIdx++] = rowIdx;
31673:   }
31673: 
32381:   *arowCount = selectedrowCount;
31673:   *aRows = outArray;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetCellAt(PRInt32 aRowIndex, PRInt32 aColumnIndex,
31673:                                    nsIAccessible **aCell)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aCell);
31673:   *aCell = nsnull;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
39191:   nsAccessible *rowAccessible = GetTreeItemAccessible(aRowIndex);
31673:   if (!rowAccessible)
31673:     return NS_ERROR_INVALID_ARG;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column =
31673:   nsCoreUtils::GetSensibleColumnAt(mTree, aColumnIndex);
31673:   if (!column)
31673:     return NS_ERROR_INVALID_ARG;
31673: 
42124:   nsRefPtr<nsXULTreeItemAccessibleBase> rowAcc = do_QueryObject(rowAccessible);
31673: 
39191:   NS_IF_ADDREF(*aCell = rowAcc->GetCellAccessible(column));
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetCellIndexAt(PRInt32 aRowIndex, PRInt32 aColumnIndex,
31673:                                         PRInt32 *aCellIndex)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aCellIndex);
31673:   *aCellIndex = -1;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
32381:   PRInt32 columnCount = 0;
32381:   nsresult rv = GetColumnCount(&columnCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   *aCellIndex = aRowIndex * columnCount + aColumnIndex;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetColumnIndexAt(PRInt32 aCellIndex,
31673:                                           PRInt32 *aColumnIndex)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aColumnIndex);
31673:   *aColumnIndex = -1;
31673: 
32381:   PRInt32 columnCount = 0;
32381:   nsresult rv = GetColumnCount(&columnCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   *aColumnIndex = aCellIndex % columnCount;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
32381: nsXULTreeGridAccessible::GetRowIndexAt(PRInt32 aCellIndex, PRInt32 *aRowIndex)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aRowIndex);
31673:   *aRowIndex = -1;
31673: 
32381:   PRInt32 columnCount;
32381:   nsresult rv = GetColumnCount(&columnCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   *aRowIndex = aCellIndex / columnCount;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
47173: nsXULTreeGridAccessible::GetRowAndColumnIndicesAt(PRInt32 aCellIndex,
47173:                                                   PRInt32* aRowIndex,
47173:                                                   PRInt32* aColumnIndex)
47173: {
47173:   NS_ENSURE_ARG_POINTER(aRowIndex);
47173:   *aRowIndex = -1;
47173:   NS_ENSURE_ARG_POINTER(aColumnIndex);
47173:   *aColumnIndex = -1;
47173: 
47173:   if (IsDefunct())
47173:     return NS_ERROR_FAILURE;
47173: 
47173:   PRInt32 columnCount = 0;
47173:   nsresult rv = GetColumnCount(&columnCount);
47173:   NS_ENSURE_SUCCESS(rv, rv);
47173: 
47173:   *aColumnIndex = aCellIndex % columnCount;
47173:   *aRowIndex = aCellIndex / columnCount;
47173:   return NS_OK;
47173: }
47173: 
47173: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::GetColumnExtentAt(PRInt32 aRowIndex,
31673:                                            PRInt32 aColumnIndex,
31673:                                            PRInt32 *aExtentCount)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aExtentCount);
31673:   *aExtentCount = 1;
31673: 
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::GetRowExtentAt(PRInt32 aRowIndex, PRInt32 aColumnIndex,
31673:                                         PRInt32 *aExtentCount)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aExtentCount);
31673:   *aExtentCount = 1;
31673: 
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::GetColumnDescription(PRInt32 aColumnIndex,
31673:                                               nsAString& aDescription)
31673: {
31673:   aDescription.Truncate();
31673: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsCOMPtr<nsIAccessible> treeColumns;
32381:   nsAccessible::GetFirstChild(getter_AddRefs(treeColumns));
32381:   if (treeColumns) {
32381:     nsCOMPtr<nsIAccessible> treeColumnItem;
32381:     treeColumns->GetChildAt(aColumnIndex, getter_AddRefs(treeColumnItem));
32381:     if (treeColumnItem)
32381:       return treeColumnItem->GetName(aDescription);
32381:   }
32381: 
32381:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::GetRowDescription(PRInt32 aRowIndex,
31673:                                            nsAString& aDescription)
31673: {
31673:   aDescription.Truncate();
32381:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::IsColumnSelected(PRInt32 aColumnIndex,
31673:                                           PRBool *aIsSelected)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aIsSelected);
31673:   *aIsSelected = PR_FALSE;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   // If all the row has been selected, then all the columns are selected.
31673:   // Because we can't select a column alone.
31673:   
32381:   PRInt32 rowCount = 0;
32381:   nsresult rv = GetRowCount(&rowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   PRInt32 selectedrowCount = 0;
32381:   rv = GetSelectionCount(&selectedrowCount);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
32381:   *aIsSelected = rowCount == selectedrowCount;
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::IsRowSelected(PRInt32 aRowIndex, PRBool *aIsSelected)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aIsSelected);
31673:   *aIsSelected = PR_FALSE;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   nsCOMPtr<nsITreeSelection> selection;
31673:   nsresult rv = mTreeView->GetSelection(getter_AddRefs(selection));
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673:   
31673:   return selection->IsSelected(aRowIndex, aIsSelected);
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::IsCellSelected(PRInt32 aRowIndex, PRInt32 aColumnIndex,
31673:                                         PRBool *aIsSelected)
31673: {
31673:   return IsRowSelected(aRowIndex, aIsSelected);
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::SelectRow(PRInt32 aRowIndex)
31673: {
31673:   nsCOMPtr<nsITreeSelection> selection;
31673:   mTreeView->GetSelection(getter_AddRefs(selection));
31673:   NS_ENSURE_STATE(selection);
31673: 
31673:   return selection->Select(aRowIndex);
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::SelectColumn(PRInt32 aColumnIndex)
31673: {
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::UnselectRow(PRInt32 aRowIndex)
31673: {
31673:   nsCOMPtr<nsITreeSelection> selection;
31673:   mTreeView->GetSelection(getter_AddRefs(selection));
31673:   NS_ENSURE_STATE(selection);
31673: 
31673:   return selection->ClearRange(aRowIndex, aRowIndex);
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::UnselectColumn(PRInt32 aColumnIndex)
31673: {
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridAccessible::IsProbablyForLayout(PRBool *aIsProbablyForLayout)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aIsProbablyForLayout);
31673:   *aIsProbablyForLayout = PR_FALSE;
31673: 
31673:   return NS_OK;
31673: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridAccessible: nsAccessible implementation
31673: 
52027: PRUint32
52027: nsXULTreeGridAccessible::NativeRole()
31673: {
31673:   nsCOMPtr<nsITreeColumns> treeColumns;
31673:   mTree->GetColumns(getter_AddRefs(treeColumns));
52027:   if (!treeColumns) {
52027:     NS_ERROR("No treecolumns object for tree!");
52027:     return nsIAccessibleRole::ROLE_NOTHING;
52027:   }
31673: 
31673:   nsCOMPtr<nsITreeColumn> primaryColumn;
31673:   treeColumns->GetPrimaryColumn(getter_AddRefs(primaryColumn));
31673: 
52027:   return primaryColumn ?
50861:     static_cast<PRUint32>(nsIAccessibleRole::ROLE_TREE_TABLE) :
50861:     static_cast<PRUint32>(nsIAccessibleRole::ROLE_TABLE);
31673: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridAccessible: nsXULTreeAccessible implementation
31673: 
39191: already_AddRefed<nsAccessible>
39191: nsXULTreeGridAccessible::CreateTreeItemAccessible(PRInt32 aRow)
31673: {
39191:   nsRefPtr<nsAccessible> accessible =
43504:     new nsXULTreeGridRowAccessible(mContent, mWeakShell, this, mTree,
39191:                                    mTreeView, aRow);
39191: 
39191:   return accessible.forget();
31673: }
31673: 
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridRowAccessible
31673: ////////////////////////////////////////////////////////////////////////////////
31673: 
31673: nsXULTreeGridRowAccessible::
43504:   nsXULTreeGridRowAccessible(nsIContent *aContent, nsIWeakReference *aShell,
36989:                              nsAccessible *aTreeAcc, nsITreeBoxObject* aTree,
31673:                              nsITreeView *aTreeView, PRInt32 aRow) :
43504:   nsXULTreeItemAccessibleBase(aContent, aShell, aTreeAcc, aTree, aTreeView, aRow)
31673: {
39191:   mAccessibleCache.Init(kDefaultTreeCacheSize);
31673: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridRowAccessible: nsISupports and cycle collection implementation
31673: 
31673: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULTreeGridRowAccessible)
31673: 
31673: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXULTreeGridRowAccessible,
31673:                                                   nsAccessible)
39191: CycleCollectorTraverseCache(tmp->mAccessibleCache, &cb);
31673: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
31673: 
31673: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXULTreeGridRowAccessible,
31673:                                                 nsAccessible)
39191: ClearCache(tmp->mAccessibleCache);
31673: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
31673: 
31673: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXULTreeGridRowAccessible)
31673: NS_INTERFACE_MAP_STATIC_AMBIGUOUS(nsXULTreeGridRowAccessible)
31673: NS_INTERFACE_MAP_END_INHERITING(nsXULTreeItemAccessibleBase)
31673: 
31673: NS_IMPL_ADDREF_INHERITED(nsXULTreeGridRowAccessible,
31673:                          nsXULTreeItemAccessibleBase)
31673: NS_IMPL_RELEASE_INHERITED(nsXULTreeGridRowAccessible,
31673:                           nsXULTreeItemAccessibleBase)
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridRowAccessible: nsAccessNode implementation
31673: 
43538: void
31673: nsXULTreeGridRowAccessible::Shutdown()
31673: {
39191:   ClearCache(mAccessibleCache);
43538:   nsXULTreeItemAccessibleBase::Shutdown();
31673: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridRowAccessible: nsAccessible implementation
31673: 
52027: PRUint32
52027: nsXULTreeGridRowAccessible::NativeRole()
31673: {
52027:   return nsIAccessibleRole::ROLE_ROW;
31673: }
31673: 
64131: nsAccessible*
31673: nsXULTreeGridRowAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,
64131:                                             EWhichChildAtPoint aWhichChild)
31673: {
31673:   nsIFrame *frame = GetFrame();
31673:   if (!frame)
64131:     return nsnull;
31673: 
31673:   nsPresContext *presContext = frame->PresContext();
31673:   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
31673: 
31673:   nsIFrame *rootFrame = presShell->GetRootFrame();
64131:   NS_ENSURE_TRUE(rootFrame, nsnull);
31673: 
31673:   nsIntRect rootRect = rootFrame->GetScreenRectExternal();
31673: 
31673:   PRInt32 clientX = presContext->DevPixelsToIntCSSPixels(aX - rootRect.x);
31673:   PRInt32 clientY = presContext->DevPixelsToIntCSSPixels(aY - rootRect.y);
31673: 
31673:   PRInt32 row = -1;
31673:   nsCOMPtr<nsITreeColumn> column;
31673:   nsCAutoString childEltUnused;
31673:   mTree->GetCellAt(clientX, clientY, &row, getter_AddRefs(column),
31673:                    childEltUnused);
31673: 
31673:   // Return if we failed to find tree cell in the row for the given point.
31673:   if (row != mRow || !column)
64131:     return nsnull;
31673: 
64131:   return GetCellAccessible(column);
31673: }
31673: 
36989: nsAccessible*
35523: nsXULTreeGridRowAccessible::GetChildAt(PRUint32 aIndex)
35523: {
35523:   if (IsDefunct())
35523:     return nsnull;
35523: 
35523:   nsCOMPtr<nsITreeColumn> column =
35523:     nsCoreUtils::GetSensibleColumnAt(mTree, aIndex);
35523:   if (!column)
35523:     return nsnull;
35523: 
39191:   return GetCellAccessible(column);
35523: }
35523: 
35523: PRInt32
35523: nsXULTreeGridRowAccessible::GetChildCount()
35523: {
35523:   if (IsDefunct())
35523:     return -1;
35523: 
35523:   return nsCoreUtils::GetSensibleColumnCount(mTree);
35523: }
35523: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridRowAccessible: nsXULTreeItemAccessibleBase implementation
31673: 
39191: nsAccessible*
39191: nsXULTreeGridRowAccessible::GetCellAccessible(nsITreeColumn* aColumn)
31673: {
31673:   NS_PRECONDITION(aColumn, "No tree column!");
31673: 
31673:   void* key = static_cast<void*>(aColumn);
57413:   nsAccessible* cachedCell = mAccessibleCache.GetWeak(key);
57413:   if (cachedCell)
57413:     return cachedCell;
31673: 
57413:   nsRefPtr<nsAccessible> cell =
43504:     new nsXULTreeGridCellAccessibleWrap(mContent, mWeakShell, this, mTree,
31673:                                         mTreeView, mRow, aColumn);
57413:   if (cell) {
57413:     if (mAccessibleCache.Put(key, cell)) {
57413:       if (GetDocAccessible()->BindToDocument(cell, nsnull))
57413:         return cell;
31673: 
57413:       mAccessibleCache.Remove(key);
57413:     }
31673:   }
31673: 
39191:   return nsnull;
39191: }
39191: 
31673: void
31673: nsXULTreeGridRowAccessible::RowInvalidated(PRInt32 aStartColIdx,
31673:                                            PRInt32 aEndColIdx)
31673: {
31673:   nsCOMPtr<nsITreeColumns> treeColumns;
31673:   mTree->GetColumns(getter_AddRefs(treeColumns));
31673:   if (!treeColumns)
31673:     return;
31673: 
31673:   for (PRInt32 colIdx = aStartColIdx; colIdx <= aEndColIdx; ++colIdx) {
31673:     nsCOMPtr<nsITreeColumn> column;
31673:     treeColumns->GetColumnAt(colIdx, getter_AddRefs(column));
31673:     if (column && !nsCoreUtils::IsColumnHidden(column)) {
39191:       nsAccessible *cellAccessible = GetCellAccessible(column);
31673:       if (cellAccessible) {
42124:         nsRefPtr<nsXULTreeGridCellAccessible> cellAcc = do_QueryObject(cellAccessible);
31673: 
31673:         cellAcc->CellInvalidated();
31673:       }
31673:     }
31673:   }
31673: }
31673: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsXULTreeGridRowAccessible: nsAccessible protected implementation
35523: 
35523: void
35523: nsXULTreeGridRowAccessible::CacheChildren()
35523: {
35523: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridCellAccessible
31673: ////////////////////////////////////////////////////////////////////////////////
31673: 
31673: nsXULTreeGridCellAccessible::
43504: nsXULTreeGridCellAccessible(nsIContent *aContent, nsIWeakReference *aShell,
31673:                             nsXULTreeGridRowAccessible *aRowAcc,
31673:                             nsITreeBoxObject *aTree, nsITreeView *aTreeView,
31673:                             PRInt32 aRow, nsITreeColumn* aColumn) :
43504:   nsLeafAccessible(aContent, aShell), mTree(aTree),
31673:   mTreeView(aTreeView), mRow(aRow), mColumn(aColumn)
31673: {
31673:   mParent = aRowAcc;
31673: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridCellAccessible: nsISupports implementation
31673: 
32381: NS_IMPL_ISUPPORTS_INHERITED2(nsXULTreeGridCellAccessible,
31673:                              nsLeafAccessible,
32381:                              nsIAccessibleTableCell,
31673:                              nsXULTreeGridCellAccessible)
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridCellAccessible: nsIAccessible implementation
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridCellAccessible::GetFocusedChild(nsIAccessible **aFocusedChild) 
31673: {
31673:   NS_ENSURE_ARG_POINTER(aFocusedChild);
31673:   *aFocusedChild = nsnull;
31673: 
31673:   return IsDefunct() ? NS_ERROR_FAILURE : NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridCellAccessible::GetName(nsAString& aName)
31673: {
31673:   aName.Truncate();
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   mTreeView->GetCellText(mRow, mColumn, aName);
31673: 
31673:   // If there is still no name try the cell value:
31673:   // This is for graphical cells. We need tree/table view implementors to implement
31673:   // FooView::GetCellValue to return a meaningful string for cases where there is
31673:   // something shown in the cell (non-text) such as a star icon; in which case
31673:   // GetCellValue for that cell would return "starred" or "flagged" for example.
31673:   if (aName.IsEmpty())
31673:     mTreeView->GetCellValue(mRow, mColumn, aName);
31673: 
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridCellAccessible::GetBounds(PRInt32 *aX, PRInt32 *aY,
31673:                                        PRInt32 *aWidth, PRInt32 *aHeight)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aX);
31673:   *aX = 0;
31673:   NS_ENSURE_ARG_POINTER(aY);
31673:   *aY = 0;
31673:   NS_ENSURE_ARG_POINTER(aWidth);
31673:   *aWidth = 0;
31673:   NS_ENSURE_ARG_POINTER(aHeight);
31673:   *aHeight = 0;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   // Get bounds for tree cell and add x and y of treechildren element to
31673:   // x and y of the cell.
31673:   nsCOMPtr<nsIBoxObject> boxObj = nsCoreUtils::GetTreeBodyBoxObject(mTree);
31673:   NS_ENSURE_STATE(boxObj);
31673: 
31673:   PRInt32 x = 0, y = 0, width = 0, height = 0;
31673:   nsresult rv = mTree->GetCoordsForCellItem(mRow, mColumn,
31673:                                             NS_LITERAL_CSTRING("cell"),
31673:                                             &x, &y, &width, &height);
31673:   NS_ENSURE_SUCCESS(rv, rv);
31673: 
31673:   PRInt32 tcX = 0, tcY = 0;
31673:   boxObj->GetScreenX(&tcX);
31673:   boxObj->GetScreenY(&tcY);
31673:   x += tcX;
31673:   y += tcY;
31673: 
31673:   nsPresContext *presContext = GetPresContext();
31673:   *aX = presContext->CSSPixelsToDevPixels(x);
31673:   *aY = presContext->CSSPixelsToDevPixels(y);
31673:   *aWidth = presContext->CSSPixelsToDevPixels(width);
31673:   *aHeight = presContext->CSSPixelsToDevPixels(height);
31673: 
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridCellAccessible::GetNumActions(PRUint8 *aActionsCount)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aActionsCount);
31673:   *aActionsCount = 0;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   PRBool isCycler = PR_FALSE;
31673:   mColumn->GetCycler(&isCycler);
31673:   if (isCycler) {
31673:     *aActionsCount = 1;
31673:     return NS_OK;
31673:   }
31673: 
31673:   PRInt16 type;
31673:   mColumn->GetType(&type);
31673:   if (type == nsITreeColumn::TYPE_CHECKBOX && IsEditable())
31673:     *aActionsCount = 1;
31673: 
31673:   return NS_OK;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridCellAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
31673: {
31673:   aName.Truncate();
31673: 
31673:   if (aIndex != eAction_Click)
31673:     return NS_ERROR_INVALID_ARG;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   PRBool isCycler = PR_FALSE;
31673:   mColumn->GetCycler(&isCycler);
31673:   if (isCycler) {
31673:     aName.AssignLiteral("cycle");
31673:     return NS_OK;
31673:   }
31673: 
31673:   PRInt16 type;
31673:   mColumn->GetType(&type);
31673:   if (type == nsITreeColumn::TYPE_CHECKBOX && IsEditable()) {
31673:     nsAutoString value;
31673:     mTreeView->GetCellValue(mRow, mColumn, value);
31673:     if (value.EqualsLiteral("true"))
31673:       aName.AssignLiteral("uncheck");
31673:     else
31673:       aName.AssignLiteral("check");
31673:     
31673:     return NS_OK;
31673:   }
31673: 
31673:   return NS_ERROR_INVALID_ARG;
31673: }
31673: 
31673: NS_IMETHODIMP
31673: nsXULTreeGridCellAccessible::DoAction(PRUint8 aIndex)
31673: {
31673:   if (aIndex != eAction_Click)
31673:     return NS_ERROR_INVALID_ARG;
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   PRBool isCycler = PR_FALSE;
31673:   mColumn->GetCycler(&isCycler);
37481:   if (isCycler) {
37481:     DoCommand();
37481:     return NS_OK;
37481:   }
31673: 
31673:   PRInt16 type;
31673:   mColumn->GetType(&type);
37481:   if (type == nsITreeColumn::TYPE_CHECKBOX && IsEditable()) {
37481:     DoCommand();
37481:     return NS_OK;
37481:   }
31673: 
31673:   return NS_ERROR_INVALID_ARG;
31673: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
32381: // nsXULTreeGridCellAccessible: nsIAccessibleTableCell implementation
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridCellAccessible::GetTable(nsIAccessibleTable **aTable)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aTable);
32381:   *aTable = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_OK;
32381: 
36989:   CallQueryInterface(mParent->GetParent(), aTable);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridCellAccessible::GetColumnIndex(PRInt32 *aColumnIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aColumnIndex);
32381:   *aColumnIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   *aColumnIndex = GetColumnIndex();
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridCellAccessible::GetRowIndex(PRInt32 *aRowIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aRowIndex);
32381:   *aRowIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   *aRowIndex = mRow;
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridCellAccessible::GetColumnExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 1;
32381: 
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridCellAccessible::GetRowExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 1;
32381: 
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridCellAccessible::GetColumnHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsresult rv = NS_OK;
32381:   nsCOMPtr<nsIMutableArray> headerCells =
32381:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   nsCOMPtr<nsIDOMElement> columnElm;
32381:   mColumn->GetElement(getter_AddRefs(columnElm));
32381: 
43504:   nsCOMPtr<nsIContent> columnContent(do_QueryInterface(columnElm));
42795:   nsAccessible *headerCell =
43504:     GetAccService()->GetAccessibleInWeakShell(columnContent, mWeakShell);
32381: 
32381:   if (headerCell)
42795:     headerCells->AppendElement(static_cast<nsIAccessible*>(headerCell),
41227:                                PR_FALSE);
32381: 
32381:   NS_ADDREF(*aHeaderCells = headerCells);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridCellAccessible::GetRowHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsresult rv = NS_OK;
32381:   nsCOMPtr<nsIMutableArray> headerCells =
32381:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   NS_ADDREF(*aHeaderCells = headerCells);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsXULTreeGridCellAccessible::IsSelected(PRBool *aIsSelected)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aIsSelected);
32381:   *aIsSelected = PR_FALSE;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsCOMPtr<nsITreeSelection> selection;
32381:   nsresult rv = mTreeView->GetSelection(getter_AddRefs(selection));
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
32381:   return selection->IsSelected(mRow, aIsSelected);
32381: }
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridCellAccessible: nsAccessNode implementation
31673: 
31673: PRBool
31673: nsXULTreeGridCellAccessible::IsDefunct()
31673: {
31673:   return nsLeafAccessible::IsDefunct() || !mParent || !mTree || !mTreeView ||
31673:     !mColumn;
31673: }
31673: 
43538: PRBool
31673: nsXULTreeGridCellAccessible::Init()
31673: {
43538:   if (!nsLeafAccessible::Init())
43538:     return PR_FALSE;
31673: 
31673:   PRInt16 type;
31673:   mColumn->GetType(&type);
31673:   if (type == nsITreeColumn::TYPE_CHECKBOX)
31673:     mTreeView->GetCellValue(mRow, mColumn, mCachedTextEquiv);
31673:   else
31673:     mTreeView->GetCellText(mRow, mColumn, mCachedTextEquiv);
31673: 
43538:   return PR_TRUE;
31673: }
31673: 
56292: bool
56292: nsXULTreeGridCellAccessible::IsPrimaryForNode() const
56292: {
56292:   return false;
56292: }
56292: 
31673: ////////////////////////////////////////////////////////////////////////////////
35523: // nsXULTreeGridCellAccessible: nsAccessible public implementation
31673: 
31673: nsresult
31673: nsXULTreeGridCellAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
31673: {
31673:   NS_ENSURE_ARG_POINTER(aAttributes);
31673: 
31673:   if (IsDefunct())
31673:     return NS_ERROR_FAILURE;
31673: 
31673:   // "table-cell-index" attribute
31673:   nsCOMPtr<nsIAccessible> accessible;
31673:   mParent->GetParent(getter_AddRefs(accessible));
31673:   nsCOMPtr<nsIAccessibleTable> tableAccessible = do_QueryInterface(accessible);
31673: 
32853:   // XXX - temp fix for crash bug 516047
32853:   if (!tableAccessible)
32853:     return NS_ERROR_FAILURE;
32853:     
31673:   PRInt32 colIdx = GetColumnIndex();
31673: 
31673:   PRInt32 cellIdx = -1;
32381:   tableAccessible->GetCellIndexAt(mRow, colIdx, &cellIdx);
31673: 
31673:   nsAutoString stringIdx;
31673:   stringIdx.AppendInt(cellIdx);
31673:   nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::tableCellIndex,
31673:                          stringIdx);
31673: 
31673:   // "cycles" attribute
31673:   PRBool isCycler = PR_FALSE;
31673:   nsresult rv = mColumn->GetCycler(&isCycler);
31673:   if (NS_SUCCEEDED(rv) && isCycler)
31673:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::cycles,
31673:                            NS_LITERAL_STRING("true"));
31673: 
31673:   return NS_OK;
31673: }
31673: 
52027: PRUint32
52027: nsXULTreeGridCellAccessible::NativeRole()
31673: {
52027:   return nsIAccessibleRole::ROLE_GRID_CELL;
31673: }
31673: 
67790: PRUint64
67790: nsXULTreeGridCellAccessible::NativeState()
31673: {
68037: 
68037:   if (IsDefunct())
68037:     return states::DEFUNCT;
68037: 
31673:   // selectable/selected state
67790:   PRUint64 states = states::SELECTABLE;
31673: 
31673:   nsCOMPtr<nsITreeSelection> selection;
31673:   mTreeView->GetSelection(getter_AddRefs(selection));
31673:   if (selection) {
31673:     PRBool isSelected = PR_FALSE;
31673:     selection->IsSelected(mRow, &isSelected);
31673:     if (isSelected)
67790:       states |= states::SELECTED;
31673:   }
31673: 
31673:   // checked state
31673:   PRInt16 type;
31673:   mColumn->GetType(&type);
31673:   if (type == nsITreeColumn::TYPE_CHECKBOX) {
67790:     states |= states::CHECKABLE;
31673:     nsAutoString checked;
31673:     mTreeView->GetCellValue(mRow, mColumn, checked);
31673:     if (checked.EqualsIgnoreCase("true"))
67790:       states |= states::CHECKED;
31673:   }
31673: 
67790:   return states;
31673: }
31673: 
61639: PRInt32
61639: nsXULTreeGridCellAccessible::GetIndexInParent() const
61639: {
61639:   return GetColumnIndex();
61639: }
61639: 
31673: ////////////////////////////////////////////////////////////////////////////////
31673: // nsXULTreeGridCellAccessible: public implementation
31673: 
31673: PRInt32
31673: nsXULTreeGridCellAccessible::GetColumnIndex() const
31673: {
31673:   PRInt32 index = 0;
31673:   nsCOMPtr<nsITreeColumn> column = mColumn;
31673:   while (column = nsCoreUtils::GetPreviousSensibleColumn(column))
31673:     index++;
31673: 
31673:   return index;
31673: }
31673: 
31673: void
31673: nsXULTreeGridCellAccessible::CellInvalidated()
31673: {
31673:   nsAutoString textEquiv;
31673: 
31673:   PRInt16 type;
31673:   mColumn->GetType(&type);
31673:   if (type == nsITreeColumn::TYPE_CHECKBOX) {
31673:     mTreeView->GetCellValue(mRow, mColumn, textEquiv);
31673:     if (mCachedTextEquiv != textEquiv) {
31673:       PRBool isEnabled = textEquiv.EqualsLiteral("true");
51377:       nsRefPtr<AccEvent> accEvent =
67790:         new AccStateChangeEvent(this, states::CHECKED, isEnabled);
37282:       nsEventShell::FireEvent(accEvent);
31673: 
31673:       mCachedTextEquiv = textEquiv;
31673:     }
31673: 
31673:     return;
31673:   }
31673: 
31673:   mTreeView->GetCellText(mRow, mColumn, textEquiv);
31673:   if (mCachedTextEquiv != textEquiv) {
37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_NAME_CHANGE, this);
31673:     mCachedTextEquiv = textEquiv;
31673:   }
31673: }
31673: 
31673: ////////////////////////////////////////////////////////////////////////////////
35523: // nsXULTreeGridCellAccessible: nsAccessible protected implementation
35523: 
39191: nsAccessible*
35523: nsXULTreeGridCellAccessible::GetSiblingAtOffset(PRInt32 aOffset,
35523:                                                 nsresult* aError)
35523: {
35523:   if (IsDefunct()) {
35523:     if (aError)
35523:       *aError = NS_ERROR_FAILURE;
35523: 
35523:     return nsnull;
35523:   }
35523: 
35523:   if (aError)
35523:     *aError = NS_OK; // fail peacefully
35523: 
35523:   nsCOMPtr<nsITreeColumn> columnAtOffset(mColumn), column;
35523:   if (aOffset < 0) {
35523:     for (PRInt32 index = aOffset; index < 0 && columnAtOffset; index++) {
35523:       column = nsCoreUtils::GetPreviousSensibleColumn(columnAtOffset);
35523:       column.swap(columnAtOffset);
35523:     }
35523:   } else {
35523:     for (PRInt32 index = aOffset; index > 0 && columnAtOffset; index--) {
35523:       column = nsCoreUtils::GetNextSensibleColumn(columnAtOffset);
35523:       column.swap(columnAtOffset);
35523:     }
35523:   }
35523: 
35523:   if (!columnAtOffset)
35523:     return nsnull;
35523: 
42124:   nsRefPtr<nsXULTreeItemAccessibleBase> rowAcc = do_QueryObject(mParent);
35523: 
39191:   return rowAcc->GetCellAccessible(columnAtOffset);
35523: }
31673: 
31673: void
31673: nsXULTreeGridCellAccessible::DispatchClickEvent(nsIContent *aContent,
31673:                                                 PRUint32 aActionIndex)
31673: {
31673:   if (IsDefunct())
31673:     return;
31673: 
31673:   nsCoreUtils::DispatchClickEvent(mTree, mRow, mColumn);
31673: }
31673: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsXULTreeGridCellAccessible: protected implementation
35523: 
31673: PRBool
31673: nsXULTreeGridCellAccessible::IsEditable() const
31673: {
31673:   // XXX: logic corresponds to tree.xml, it's preferable to have interface
31673:   // method to check it.
31673:   PRBool isEditable = PR_FALSE;
31673:   nsresult rv = mTreeView->IsEditable(mRow, mColumn, &isEditable);
31673:   if (NS_FAILED(rv) || !isEditable)
31673:     return PR_FALSE;
31673: 
31673:   nsCOMPtr<nsIDOMElement> columnElm;
31673:   mColumn->GetElement(getter_AddRefs(columnElm));
31673:   if (!columnElm)
31673:     return PR_FALSE;
31673: 
31673:   nsCOMPtr<nsIContent> columnContent(do_QueryInterface(columnElm));
31673:   if (!columnContent->AttrValueIs(kNameSpaceID_None,
31673:                                   nsAccessibilityAtoms::editable,
31673:                                   nsAccessibilityAtoms::_true,
31673:                                   eCaseMatters))
31673:     return PR_FALSE;
31673: 
43504:   return mContent->AttrValueIs(kNameSpaceID_None,
31673:                                nsAccessibilityAtoms::editable,
43504:                                nsAccessibilityAtoms::_true, eCaseMatters);
31673: }
