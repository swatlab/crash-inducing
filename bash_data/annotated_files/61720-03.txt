    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
 3113:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsLayoutUtils.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsIFormControlFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsIContent.h"
41068: #include "nsIDOMDocument.h"
41068: #include "nsIDOMHTMLDocument.h"
41320: #include "nsIDOMHTMLElement.h"
    1: #include "nsFrameList.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIAtom.h"
    1: #include "nsCSSPseudoElements.h"
12349: #include "nsCSSAnonBoxes.h"
    1: #include "nsIView.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsDisplayList.h"
    1: #include "nsRegion.h"
    1: #include "nsFrameManager.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsBidiPresUtils.h"
    1: #include "imgIContainer.h"
    1: #include "gfxRect.h"
 1442: #include "gfxContext.h"
 4032: #include "gfxFont.h"
    1: #include "nsIInterfaceRequestorUtils.h"
 1345: #include "nsCSSRendering.h"
 4032: #include "nsContentUtils.h"
16601: #include "nsThemeConstants.h"
16228: #include "nsPIDOMWindow.h"
16228: #include "nsIBaseWindow.h"
16228: #include "nsIDocShell.h"
16228: #include "nsIDocShellTreeItem.h"
16228: #include "nsIWidget.h"
19214: #include "gfxMatrix.h"
19214: #include "gfxTypes.h"
19962: #include "gfxUserFontSet.h"
24551: #include "nsTArray.h"
42402: #include "nsHTMLCanvasElement.h"
29572: #include "nsICanvasRenderingContextInternal.h"
29572: #include "gfxPlatform.h"
33027: #include "nsClientRect.h"
29959: #ifdef MOZ_MEDIA
29572: #include "nsHTMLVideoElement.h"
29959: #endif
29572: #include "imgIRequest.h"
29572: #include "imgIContainer.h"
29572: #include "nsIImageLoadingContent.h"
32132: #include "nsCOMPtr.h"
37081: #include "nsListControlFrame.h"
39499: #include "ImageLayers.h"
41930: #include "mozilla/dom/Element.h"
47739: #include "nsCanvasFrame.h"
50420: #include "gfxDrawable.h"
50420: #include "gfxUtils.h"
60450: #include "nsDataHashtable.h"
    1: 
12349: #ifdef MOZ_SVG
12349: #include "nsSVGUtils.h"
19125: #include "nsSVGIntegrationUtils.h"
    1: #include "nsSVGForeignObjectFrame.h"
    1: #include "nsSVGOuterSVGFrame.h"
    1: #endif
    1: 
39629: #ifdef MOZ_XUL
39629: #include "nsXULPopupManager.h"
39629: #endif
39629: 
39499: using namespace mozilla::layers;
41634: using namespace mozilla::dom;
49566: namespace css = mozilla::css;
39499: 
55416: #ifdef DEBUG
55416: // TODO: remove, see bug 598468.
55416: bool nsLayoutUtils::gPreventAssertInCompareTreePosition = false;
55416: #endif // DEBUG
55416: 
55321: typedef gfxPattern::GraphicsFilter GraphicsFilter;
60444: typedef FrameMetrics::ViewID ViewID;
55321: 
60450: static ViewID sScrollIdCounter = FrameMetrics::START_SCROLL_ID;
60450: 
60450: typedef nsDataHashtable<nsUint64HashKey, nsIContent*> ContentMap;
60450: static ContentMap* sContentMap = NULL;
60450: static ContentMap& GetContentMap() {
60450:   if (!sContentMap) {
60450:     sContentMap = new ContentMap();
60450:     nsresult rv = sContentMap->Init();
60450:     NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "Could not initialize map.");
60450:   }
60450:   return *sContentMap;
60450: }
60450: 
60450: static void DestroyViewID(void* aObject, nsIAtom* aPropertyName,
60450:                           void* aPropertyValue, void* aData)
60450: {
60450:   ViewID* id = static_cast<ViewID*>(aPropertyValue);
60450:   GetContentMap().Remove(*id);
60450:   delete id;
60450: }
60450: 
60450: ViewID
60450: nsLayoutUtils::FindIDFor(nsIContent* aContent)
60450: {
60450:   ViewID scrollId;
60450: 
60450:   void* scrollIdProperty = aContent->GetProperty(nsGkAtoms::RemoteId);
60450:   if (scrollIdProperty) {
60450:     scrollId = *static_cast<ViewID*>(scrollIdProperty);
60450:   } else {
60450:     scrollId = sScrollIdCounter++;
60450:     aContent->SetProperty(nsGkAtoms::RemoteId, new ViewID(scrollId),
60450:                           DestroyViewID);
60450:     GetContentMap().Put(scrollId, aContent);
60450:   }
60450: 
60450:   return scrollId;
60450: }
60450: 
60450: nsIContent*
60450: nsLayoutUtils::FindContentFor(ViewID aId)
60450: {
60450:   NS_ABORT_IF_FALSE(aId != FrameMetrics::NULL_SCROLL_ID &&
60450:                     aId != FrameMetrics::ROOT_SCROLL_ID,
60450:                     "Cannot find a content element in map for null or root IDs.");
60450:   nsIContent* content;
60450:   bool exists = GetContentMap().Get(aId, &content);
60450: 
60450:   if (exists) {
60450:     return content;
60450:   } else {
60450:     return nsnull;
60450:   }
60450: }
60450: 
    1: /**
    1:  * A namespace class for static layout utilities.
    1:  */
    1: 
10780: nsIFrame*
10780: nsLayoutUtils::GetLastContinuationWithChild(nsIFrame* aFrame)
10780: {
10780:   NS_PRECONDITION(aFrame, "NULL frame pointer");
10780:   aFrame = aFrame->GetLastContinuation();
10780:   while (!aFrame->GetFirstChild(nsnull) &&
10780:          aFrame->GetPrevContinuation()) {
10780:     aFrame = aFrame->GetPrevContinuation();
10780:   }
10780:   return aFrame;
10780: }
10780: 
    1: /**
    1:  * GetFirstChildFrame returns the first "real" child frame of a
    1:  * given frame.  It will descend down into pseudo-frames (unless the
    1:  * pseudo-frame is the :before generated frame).
    1:  * @param aFrame the frame
    1:  * @param aFrame the frame's content node
    1:  */
    1: static nsIFrame*
    1: GetFirstChildFrame(nsIFrame*       aFrame,
    1:                    nsIContent*     aContent)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
    1:   // Get the first child frame
    1:   nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1: 
    1:   // If the child frame is a pseudo-frame, then return its first child.
    1:   // Note that the frame we create for the generated content is also a
    1:   // pseudo-frame and so don't drill down in that case
    1:   if (childFrame &&
    1:       childFrame->IsPseudoFrame(aContent) &&
    1:       !childFrame->IsGeneratedContentFrame()) {
    1:     return GetFirstChildFrame(childFrame, aContent);
    1:   }
    1: 
    1:   return childFrame;
    1: }
    1: 
    1: /**
    1:  * GetLastChildFrame returns the last "real" child frame of a
    1:  * given frame.  It will descend down into pseudo-frames (unless the
    1:  * pseudo-frame is the :after generated frame).
    1:  * @param aFrame the frame
    1:  * @param aFrame the frame's content node
    1:  */
    1: static nsIFrame*
    1: GetLastChildFrame(nsIFrame*       aFrame,
    1:                   nsIContent*     aContent)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
10780:   // Get the last continuation frame that's a parent
10780:   nsIFrame* lastParentContinuation = nsLayoutUtils::GetLastContinuationWithChild(aFrame);
    1: 
32843:   nsIFrame* lastChildFrame = lastParentContinuation->GetLastChild(nsnull);
32843:   if (lastChildFrame) {
    1:     // Get the frame's first continuation. This matters in case the frame has
    1:     // been continued across multiple lines or split by BiDi resolution.
    1:     lastChildFrame = lastChildFrame->GetFirstContinuation();
    1: 
    1:     // If the last child frame is a pseudo-frame, then return its last child.
    1:     // Note that the frame we create for the generated content is also a
    1:     // pseudo-frame and so don't drill down in that case
    1:     if (lastChildFrame &&
    1:         lastChildFrame->IsPseudoFrame(aContent) &&
    1:         !lastChildFrame->IsGeneratedContentFrame()) {
    1:       return GetLastChildFrame(lastChildFrame, aContent);
    1:     }
    1: 
    1:     return lastChildFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: //static
36646: nsIAtom*
36646: nsLayoutUtils::GetChildListNameFor(nsIFrame* aChildFrame)
36646: {
36646:   nsIAtom*      listName;
36646: 
36646:   if (aChildFrame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
36646:     nsIFrame* pif = aChildFrame->GetPrevInFlow();
36646:     if (pif->GetParent() == aChildFrame->GetParent()) {
36646:       listName = nsGkAtoms::excessOverflowContainersList;
36646:     }
36646:     else {
36646:       listName = nsGkAtoms::overflowContainersList;
36646:     }
36646:   }
36646:   // See if the frame is moved out of the flow
36646:   else if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
36646:     // Look at the style information to tell
36646:     const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
36646: 
36646:     if (NS_STYLE_POSITION_ABSOLUTE == disp->mPosition) {
36646:       listName = nsGkAtoms::absoluteList;
36646:     } else if (NS_STYLE_POSITION_FIXED == disp->mPosition) {
36646:       if (nsLayoutUtils::IsReallyFixedPos(aChildFrame)) {
36646:         listName = nsGkAtoms::fixedList;
36646:       } else {
36646:         listName = nsGkAtoms::absoluteList;
36646:       }
36646: #ifdef MOZ_XUL
36646:     } else if (NS_STYLE_DISPLAY_POPUP == disp->mDisplay) {
36646:       // Out-of-flows that are DISPLAY_POPUP must be kids of the root popup set
36646: #ifdef DEBUG
36646:       nsIFrame* parent = aChildFrame->GetParent();
36646:       NS_ASSERTION(parent && parent->GetType() == nsGkAtoms::popupSetFrame,
36646:                    "Unexpected parent");
36646: #endif // DEBUG
36646: 
36646:       // XXX FIXME: Bug 350740
36646:       // Return here, because the postcondition for this function actually
36646:       // fails for this case, since the popups are not in a "real" frame list
36646:       // in the popup set.
36646:       return nsGkAtoms::popupList;
36646: #endif // MOZ_XUL
36646:     } else {
36646:       NS_ASSERTION(aChildFrame->GetStyleDisplay()->IsFloating(),
36646:                    "not a floated frame");
36646:       listName = nsGkAtoms::floatList;
36646:     }
36646: 
36646:   } else {
36646:     nsIAtom* childType = aChildFrame->GetType();
36646:     if (nsGkAtoms::menuPopupFrame == childType) {
36646:       nsIFrame* parent = aChildFrame->GetParent();
36646:       nsIFrame* firstPopup = (parent)
36646:                              ? parent->GetFirstChild(nsGkAtoms::popupList)
36646:                              : nsnull;
36646:       NS_ASSERTION(!firstPopup || !firstPopup->GetNextSibling(),
36646:                    "We assume popupList only has one child, but it has more.");
46316:       listName = firstPopup == aChildFrame ? nsGkAtoms::popupList : nsnull;
36646:     } else if (nsGkAtoms::tableColGroupFrame == childType) {
36646:       listName = nsGkAtoms::colGroupList;
36646:     } else if (nsGkAtoms::tableCaptionFrame == aChildFrame->GetType()) {
36646:       listName = nsGkAtoms::captionList;
36646:     } else {
36646:       listName = nsnull;
36646:     }
36646:   }
36646: 
36646: #ifdef NS_DEBUG
36646:   // Verify that the frame is actually in that child list or in the
36646:   // corresponding overflow list.
36646:   nsIFrame* parent = aChildFrame->GetParent();
36646:   PRBool found = parent->GetChildList(listName).ContainsFrame(aChildFrame);
36646:   if (!found) {
36646:     if (!(aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
36646:       found = parent->GetChildList(nsGkAtoms::overflowList)
36646:                 .ContainsFrame(aChildFrame);
36646:     }
36646:     else if (aChildFrame->GetStyleDisplay()->IsFloating()) {
36646:       found = parent->GetChildList(nsGkAtoms::overflowOutOfFlowList)
36646:                 .ContainsFrame(aChildFrame);
36646:     }
36646:     // else it's positioned and should have been on the 'listName' child list.
36646:     NS_POSTCONDITION(found, "not in child list");
36646:   }
36646: #endif
36646: 
36646:   return listName;
36646: }
36646: 
36646: // static
    1: nsIFrame*
    1: nsLayoutUtils::GetBeforeFrame(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1:   NS_ASSERTION(!aFrame->GetPrevContinuation(),
    1:                "aFrame must be first continuation");
    1: 
    1:   nsIFrame* firstFrame = GetFirstChildFrame(aFrame, aFrame->GetContent());
    1: 
    1:   if (firstFrame && IsGeneratedContentFor(nsnull, firstFrame,
    1:                                           nsCSSPseudoElements::before)) {
    1:     return firstFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: nsIFrame*
    1: nsLayoutUtils::GetAfterFrame(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
    1:   nsIFrame* lastFrame = GetLastChildFrame(aFrame, aFrame->GetContent());
    1: 
    1:   if (lastFrame && IsGeneratedContentFor(nsnull, lastFrame,
    1:                                          nsCSSPseudoElements::after)) {
    1:     return lastFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: nsIFrame*
 3113: nsLayoutUtils::GetClosestFrameOfType(nsIFrame* aFrame, nsIAtom* aFrameType)
    1: {
    1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
 3113:     if (frame->GetType() == aFrameType) {
    1:       return frame;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
35300: // static
35300: nsIFrame*
35300: nsLayoutUtils::GetStyleFrame(nsIFrame* aFrame)
35300: {
35300:   if (aFrame->GetType() == nsGkAtoms::tableOuterFrame) {
35300:     nsIFrame* inner = aFrame->GetFirstChild(nsnull);
35300:     NS_ASSERTION(inner, "Outer table must have an inner");
35300:     return inner;
35300:   }
35300: 
35300:   return aFrame;
35300: }
35300: 
    1: nsIFrame*
    1: nsLayoutUtils::GetFloatFromPlaceholder(nsIFrame* aFrame) {
34911:   NS_ASSERTION(nsGkAtoms::placeholderFrame == aFrame->GetType(),
34911:                "Must have a placeholder here");
34912:   if (aFrame->GetStateBits() & PLACEHOLDER_FOR_FLOAT) {
    1:     nsIFrame *outOfFlowFrame =
    1:       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
34912:     NS_ASSERTION(outOfFlowFrame->GetStyleDisplay()->IsFloating(),
34912:                  "How did that happen?");
    1:     return outOfFlowFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsLayoutUtils::IsGeneratedContentFor(nsIContent* aContent,
    1:                                      nsIFrame* aFrame,
    1:                                      nsIAtom* aPseudoElement)
    1: {
    1:   NS_PRECONDITION(aFrame, "Must have a frame");
    1:   NS_PRECONDITION(aPseudoElement, "Must have a pseudo name");
    1: 
    1:   if (!aFrame->IsGeneratedContentFrame()) {
    1:     return PR_FALSE;
    1:   }
16976:   nsIFrame* parent = aFrame->GetParent();
16976:   NS_ASSERTION(parent, "Generated content can't be root frame");
16976:   if (parent->IsGeneratedContentFrame()) {
16976:     // Not the root of the generated content
    1:     return PR_FALSE;
    1:   }
    1: 
16976:   if (aContent && parent->GetContent() != aContent) {
16976:     return PR_FALSE;
16976:   }
16976: 
16976:   return (aFrame->GetContent()->Tag() == nsGkAtoms::mozgeneratedcontentbefore) ==
16976:     (aPseudoElement == nsCSSPseudoElements::before);
    1: }
    1: 
    1: // static
    1: nsIFrame*
18884: nsLayoutUtils::GetCrossDocParentFrame(const nsIFrame* aFrame,
18884:                                       nsPoint* aExtraOffset)
    1: {
    1:   nsIFrame* p = aFrame->GetParent();
    1:   if (p)
    1:     return p;
    1: 
    1:   nsIView* v = aFrame->GetView();
    1:   if (!v)
    1:     return nsnull;
    1:   v = v->GetParent(); // anonymous inner view
    1:   if (!v)
    1:     return nsnull;
18884:   if (aExtraOffset) {
18884:     *aExtraOffset += v->GetPosition();
18884:   }
    1:   v = v->GetParent(); // subdocumentframe's view
    1:   if (!v)
    1:     return nsnull;
 3233:   return static_cast<nsIFrame*>(v->GetClientData());
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsLayoutUtils::IsProperAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
    1:                                              nsIFrame* aCommonAncestor)
    1: {
    1:   if (aFrame == aCommonAncestor)
    1:     return PR_FALSE;
    1: 
    1:   nsIFrame* parentFrame = GetCrossDocParentFrame(aFrame);
    1: 
    1:   while (parentFrame != aCommonAncestor) {
    1:     if (parentFrame == aAncestorFrame)
    1:       return PR_TRUE;
    1: 
    1:     parentFrame = GetCrossDocParentFrame(parentFrame);
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: PRBool
30518: nsLayoutUtils::IsAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
30518:                                        nsIFrame* aCommonAncestor)
30518: {
30518:   if (aFrame == aAncestorFrame)
30518:     return PR_TRUE;
30518:   return IsProperAncestorFrameCrossDoc(aAncestorFrame, aFrame, aCommonAncestor);
30518: }
30518: 
30518: // static
30518: PRBool
    1: nsLayoutUtils::IsProperAncestorFrame(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
    1:                                      nsIFrame* aCommonAncestor)
    1: {
    1:   if (aFrame == aCommonAncestor) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsIFrame* parentFrame = aFrame->GetParent();
    1: 
    1:   while (parentFrame != aCommonAncestor) {
    1:     if (parentFrame == aAncestorFrame) {
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     parentFrame = parentFrame->GetParent();
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: PRInt32
    1: nsLayoutUtils::DoCompareTreePosition(nsIContent* aContent1,
    1:                                      nsIContent* aContent2,
    1:                                      PRInt32 aIf1Ancestor,
    1:                                      PRInt32 aIf2Ancestor,
32864:                                      const nsIContent* aCommonAncestor)
    1: {
    1:   NS_PRECONDITION(aContent1, "aContent1 must not be null");
    1:   NS_PRECONDITION(aContent2, "aContent2 must not be null");
    1: 
 7820:   nsAutoTArray<nsINode*, 32> content1Ancestors;
    1:   nsINode* c1;
    1:   for (c1 = aContent1; c1 && c1 != aCommonAncestor; c1 = c1->GetNodeParent()) {
    1:     content1Ancestors.AppendElement(c1);
    1:   }
    1:   if (!c1 && aCommonAncestor) {
    1:     // So, it turns out aCommonAncestor was not an ancestor of c1. Oops.
    1:     // Never mind. We can continue as if aCommonAncestor was null.
    1:     aCommonAncestor = nsnull;
    1:   }
    1: 
 7820:   nsAutoTArray<nsINode*, 32> content2Ancestors;
    1:   nsINode* c2;
    1:   for (c2 = aContent2; c2 && c2 != aCommonAncestor; c2 = c2->GetNodeParent()) {
    1:     content2Ancestors.AppendElement(c2);
    1:   }
    1:   if (!c2 && aCommonAncestor) {
    1:     // So, it turns out aCommonAncestor was not an ancestor of c2.
    1:     // We need to retry with no common ancestor hint.
    1:     return DoCompareTreePosition(aContent1, aContent2,
    1:                                  aIf1Ancestor, aIf2Ancestor, nsnull);
    1:   }
    1: 
 7820:   int last1 = content1Ancestors.Length() - 1;
 7820:   int last2 = content2Ancestors.Length() - 1;
    1:   nsINode* content1Ancestor = nsnull;
    1:   nsINode* content2Ancestor = nsnull;
    1:   while (last1 >= 0 && last2 >= 0
 7820:          && ((content1Ancestor = content1Ancestors.ElementAt(last1)) ==
 7820:              (content2Ancestor = content2Ancestors.ElementAt(last2)))) {
    1:     last1--;
    1:     last2--;
    1:   }
    1: 
    1:   if (last1 < 0) {
    1:     if (last2 < 0) {
    1:       NS_ASSERTION(aContent1 == aContent2, "internal error?");
    1:       return 0;
    1:     }
    1:     // aContent1 is an ancestor of aContent2
    1:     return aIf1Ancestor;
    1:   }
    1: 
    1:   if (last2 < 0) {
    1:     // aContent2 is an ancestor of aContent1
    1:     return aIf2Ancestor;
    1:   }
    1: 
    1:   // content1Ancestor != content2Ancestor, so they must be siblings with the same parent
    1:   nsINode* parent = content1Ancestor->GetNodeParent();
55416: #ifdef DEBUG
55416:   // TODO: remove the uglyness, see bug 598468.
55416:   NS_ASSERTION(gPreventAssertInCompareTreePosition || parent,
55416:                "no common ancestor at all???");
55416: #endif // DEBUG
    1:   if (!parent) { // different documents??
    1:     return 0;
    1:   }
    1: 
    1:   PRInt32 index1 = parent->IndexOf(content1Ancestor);
    1:   PRInt32 index2 = parent->IndexOf(content2Ancestor);
    1:   if (index1 < 0 || index2 < 0) {
    1:     // one of them must be anonymous; we can't determine the order
    1:     return 0;
    1:   }
    1: 
    1:   return index1 - index2;
    1: }
    1: 
    1: static nsIFrame* FillAncestors(nsIFrame* aFrame,
    1:                                nsIFrame* aStopAtAncestor, nsFrameManager* aFrameManager,
    1:                                nsTArray<nsIFrame*>* aAncestors)
    1: {
    1:   while (aFrame && aFrame != aStopAtAncestor) {
    1:     aAncestors->AppendElement(aFrame);
    1:     aFrame = nsLayoutUtils::GetParentOrPlaceholderFor(aFrameManager, aFrame);
    1:   }
    1:   return aFrame;
    1: }
    1: 
    1: // Return true if aFrame1 is after aFrame2
    1: static PRBool IsFrameAfter(nsIFrame* aFrame1, nsIFrame* aFrame2)
    1: {
    1:   nsIFrame* f = aFrame2;
    1:   do {
    1:     f = f->GetNextSibling();
    1:     if (f == aFrame1)
    1:       return PR_TRUE;
    1:   } while (f);
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: PRInt32
    1: nsLayoutUtils::DoCompareTreePosition(nsIFrame* aFrame1,
    1:                                      nsIFrame* aFrame2,
    1:                                      PRInt32 aIf1Ancestor,
    1:                                      PRInt32 aIf2Ancestor,
    1:                                      nsIFrame* aCommonAncestor)
    1: {
    1:   NS_PRECONDITION(aFrame1, "aFrame1 must not be null");
    1:   NS_PRECONDITION(aFrame2, "aFrame2 must not be null");
    1: 
  238:   nsPresContext* presContext = aFrame1->PresContext();
  238:   if (presContext != aFrame2->PresContext()) {
    1:     NS_ERROR("no common ancestor at all, different documents");
    1:     return 0;
    1:   }
    1:   nsFrameManager* frameManager = presContext->PresShell()->FrameManager();
    1: 
    1:   nsAutoTArray<nsIFrame*,20> frame1Ancestors;
    1:   if (!FillAncestors(aFrame1, aCommonAncestor, frameManager, &frame1Ancestors)) {
    1:     // We reached the root of the frame tree ... if aCommonAncestor was set,
    1:     // it is wrong
    1:     aCommonAncestor = nsnull;
    1:   }
    1: 
    1:   nsAutoTArray<nsIFrame*,20> frame2Ancestors;
    1:   if (!FillAncestors(aFrame2, aCommonAncestor, frameManager, &frame2Ancestors) &&
    1:       aCommonAncestor) {
    1:     // We reached the root of the frame tree ... aCommonAncestor was wrong.
    1:     // Try again with no hint.
    1:     return DoCompareTreePosition(aFrame1, aFrame2,
    1:                                  aIf1Ancestor, aIf2Ancestor, nsnull);
    1:   }
    1: 
    1:   PRInt32 last1 = PRInt32(frame1Ancestors.Length()) - 1;
    1:   PRInt32 last2 = PRInt32(frame2Ancestors.Length()) - 1;
    1:   while (last1 >= 0 && last2 >= 0 &&
    1:          frame1Ancestors[last1] == frame2Ancestors[last2]) {
    1:     last1--;
    1:     last2--;
    1:   }
    1: 
    1:   if (last1 < 0) {
    1:     if (last2 < 0) {
    1:       NS_ASSERTION(aFrame1 == aFrame2, "internal error?");
    1:       return 0;
    1:     }
    1:     // aFrame1 is an ancestor of aFrame2
    1:     return aIf1Ancestor;
    1:   }
    1: 
    1:   if (last2 < 0) {
    1:     // aFrame2 is an ancestor of aFrame1
    1:     return aIf2Ancestor;
    1:   }
    1: 
    1:   nsIFrame* ancestor1 = frame1Ancestors[last1];
    1:   nsIFrame* ancestor2 = frame2Ancestors[last2];
    1:   // Now we should be able to walk sibling chains to find which one is first
    1:   if (IsFrameAfter(ancestor2, ancestor1))
    1:     return -1;
    1:   if (IsFrameAfter(ancestor1, ancestor2))
    1:     return 1;
    1:   NS_WARNING("Frames were in different child lists???");
    1:   return 0;
    1: }
    1: 
    1: // static
    1: nsIFrame* nsLayoutUtils::GetLastSibling(nsIFrame* aFrame) {
    1:   if (!aFrame) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIFrame* next;
    1:   while ((next = aFrame->GetNextSibling()) != nsnull) {
    1:     aFrame = next;
    1:   }
    1:   return aFrame;
    1: }
    1: 
    1: // static
    1: nsIView*
    1: nsLayoutUtils::FindSiblingViewFor(nsIView* aParentView, nsIFrame* aFrame) {
 3233:   nsIFrame* parentViewFrame = static_cast<nsIFrame*>(aParentView->GetClientData());
    1:   nsIContent* parentViewContent = parentViewFrame ? parentViewFrame->GetContent() : nsnull;
    1:   for (nsIView* insertBefore = aParentView->GetFirstChild(); insertBefore;
    1:        insertBefore = insertBefore->GetNextSibling()) {
 3233:     nsIFrame* f = static_cast<nsIFrame*>(insertBefore->GetClientData());
    1:     if (!f) {
    1:       // this view could be some anonymous view attached to a meaningful parent
    1:       for (nsIView* searchView = insertBefore->GetParent(); searchView;
    1:            searchView = searchView->GetParent()) {
 3233:         f = static_cast<nsIFrame*>(searchView->GetClientData());
    1:         if (f) {
    1:           break;
    1:         }
    1:       }
    1:       NS_ASSERTION(f, "Can't find a frame anywhere!");
    1:     }
    1:     if (!f || !aFrame->GetContent() || !f->GetContent() ||
    1:         CompareTreePosition(aFrame->GetContent(), f->GetContent(), parentViewContent) > 0) {
    1:       // aFrame's content is after f's content (or we just don't know),
    1:       // so put our view before f's view
    1:       return insertBefore;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: //static
    1: nsIScrollableFrame*
    1: nsLayoutUtils::GetScrollableFrameFor(nsIFrame *aScrolledFrame)
    1: {
    1:   nsIFrame *frame = aScrolledFrame->GetParent();
    1:   if (!frame) {
    1:     return nsnull;
    1:   }
23554:   nsIScrollableFrame *sf = do_QueryFrame(frame);
    1:   return sf;
    1: }
    1: 
47736: nsIFrame*
47736: nsLayoutUtils::GetActiveScrolledRootFor(nsIFrame* aFrame,
49156:                                         nsIFrame* aStopAtAncestor)
47736: {
47742:   nsIFrame* f = aFrame;
47742:   while (f != aStopAtAncestor) {
50412:     if (IsPopup(f))
50412:       break;
49156:     nsIFrame* parent = GetCrossDocParentFrame(f);
47742:     if (!parent)
47742:       break;
47742:     nsIScrollableFrame* sf = do_QueryFrame(parent);
47742:     if (sf && sf->IsScrollingActive() && sf->GetScrolledFrame() == f)
47742:       break;
47742:     f = parent;
47742:   }
47742:   return f;
47736: }
47736: 
    1: // static
    1: nsIScrollableFrame*
37057: nsLayoutUtils::GetNearestScrollableFrameForDirection(nsIFrame* aFrame,
37057:                                                      Direction aDirection)
    1: {
37057:   NS_ASSERTION(aFrame, "GetNearestScrollableFrameForDirection expects a non-null frame");
37057:   for (nsIFrame* f = aFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
37057:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(f);
37057:     if (scrollableFrame) {
37057:       nsPresContext::ScrollbarStyles ss = scrollableFrame->GetScrollbarStyles();
37292:       PRUint32 scrollbarVisibility = scrollableFrame->GetScrollbarVisibility();
37057:       nsRect scrollRange = scrollableFrame->GetScrollRange();
37057:       // Require visible scrollbars or something to scroll to in
37057:       // the given direction.
37057:       if (aDirection == eVertical ?
37057:           (ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN &&
37292:            ((scrollbarVisibility & nsIScrollableFrame::VERTICAL) ||
37292:             scrollRange.height > 0)) :
37057:           (ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN &&
37292:            ((scrollbarVisibility & nsIScrollableFrame::HORIZONTAL) ||
37292:             scrollRange.width > 0)))
37057:         return scrollableFrame;
37057:     }
37057:   }
37057:   return nsnull;
    1: }
    1: 
    1: // static
37057: nsIScrollableFrame*
37057: nsLayoutUtils::GetNearestScrollableFrame(nsIFrame* aFrame)
    1: {
37057:   NS_ASSERTION(aFrame, "GetNearestScrollableFrame expects a non-null frame");
37057:   for (nsIFrame* f = aFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
37057:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(f);
37057:     if (scrollableFrame) {
37057:       nsPresContext::ScrollbarStyles ss = scrollableFrame->GetScrollbarStyles();
37057:       if (ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN ||
37057:           ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN)
37057:         return scrollableFrame;
37057:     }
37057:   }
37057:   return nsnull;
    1: }
    1: 
48947: //static
48947: PRBool
48947: nsLayoutUtils::HasPseudoStyle(nsIContent* aContent,
48947:                               nsStyleContext* aStyleContext,
48947:                               nsCSSPseudoElements::Type aPseudoElement,
48947:                               nsPresContext* aPresContext)
48947: {
48947:   NS_PRECONDITION(aPresContext, "Must have a prescontext");
48947: 
48947:   nsRefPtr<nsStyleContext> pseudoContext;
48947:   if (aContent) {
48947:     pseudoContext = aPresContext->StyleSet()->
48947:       ProbePseudoElementStyle(aContent->AsElement(), aPseudoElement,
48947:                               aStyleContext);
48947:   }
48947:   return pseudoContext != nsnull;
48947: }
48947: 
    1: nsPoint
    1: nsLayoutUtils::GetDOMEventCoordinatesRelativeTo(nsIDOMEvent* aDOMEvent, nsIFrame* aFrame)
    1: {
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aDOMEvent));
    1:   NS_ASSERTION(privateEvent, "bad implementation");
    1:   if (!privateEvent)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
20234:   nsEvent *event = privateEvent->GetInternalNSEvent();
20234:   if (!event)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1:   return GetEventCoordinatesRelativeTo(event, aFrame);
    1: }
    1: 
    1: nsPoint
 2817: nsLayoutUtils::GetEventCoordinatesRelativeTo(const nsEvent* aEvent, nsIFrame* aFrame)
    1: {
    1:   if (!aEvent || (aEvent->eventStructType != NS_MOUSE_EVENT &&
18445:                   aEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
23284:                   aEvent->eventStructType != NS_DRAG_EVENT &&
28352:                   aEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT &&
31443:                   aEvent->eventStructType != NS_GESTURENOTIFY_EVENT &&
48711:                   aEvent->eventStructType != NS_MOZTOUCH_EVENT &&
28352:                   aEvent->eventStructType != NS_QUERY_CONTENT_EVENT))
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
 3233:   const nsGUIEvent* GUIEvent = static_cast<const nsGUIEvent*>(aEvent);
    1:   if (!GUIEvent->widget)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
19214:   /* If we walk up the frame tree and discover that any of the frames are
19214:    * transformed, we need to do extra work to convert from the global
19214:    * space to the local space.
19214:    */
    1:   nsIFrame* rootFrame = aFrame;
19214:   PRBool transformFound = PR_FALSE;
19214: 
    1:   for (nsIFrame* f = aFrame; f; f = GetCrossDocParentFrame(f)) {
19214:     if (f->IsTransformed())
19214:       transformFound = PR_TRUE;
19214: 
    1:     rootFrame = f;
    1:   }
    1: 
    1:   nsIView* rootView = rootFrame->GetView();
    1:   if (!rootView)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
  238:   nsPoint widgetToView = TranslateWidgetToView(rootFrame->PresContext(),
    1:                                GUIEvent->widget, GUIEvent->refPoint,
    1:                                rootView);
    1: 
    1:   if (widgetToView == nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE))
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
47902:   // Convert from root document app units to app units of the document aFrame
47902:   // is in.
47902:   PRInt32 rootAPD = rootFrame->PresContext()->AppUnitsPerDevPixel();
47902:   PRInt32 localAPD = aFrame->PresContext()->AppUnitsPerDevPixel();
47902:   widgetToView = widgetToView.ConvertAppUnits(rootAPD, localAPD);
47902: 
19214:   /* If we encountered a transform, we can't do simple arithmetic to figure
19214:    * out how to convert back to aFrame's coordinates and must use the CTM.
19214:    */
19214:   if (transformFound)
19214:     return InvertTransformsToRoot(aFrame, widgetToView);
19214: 
19214:   /* Otherwise, all coordinate systems are translations of one another,
19214:    * so we can just subtract out the different.
19214:    */
47902:   return widgetToView - aFrame->GetOffsetToCrossDoc(rootFrame);
    1: }
    1: 
39629: nsIFrame*
48255: nsLayoutUtils::GetPopupFrameForEventCoordinates(nsPresContext* aPresContext,
48255:                                                 const nsEvent* aEvent)
39629: {
39629: #ifdef MOZ_XUL
39629:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
39629:   if (!pm) {
39629:     return nsnull;
39629:   }
39629:   nsTArray<nsIFrame*> popups = pm->GetVisiblePopups();
39629:   PRUint32 i;
39629:   // Search from top to bottom
39629:   for (i = 0; i < popups.Length(); i++) {
39629:     nsIFrame* popup = popups[i];
48255:     if (popup->PresContext()->GetRootPresContext() == aPresContext &&
55040:         popup->GetScrollableOverflowRect().Contains(
39629:           GetEventCoordinatesRelativeTo(aEvent, popup))) {
39629:       return popup;
39629:     }
39629:   }
39629: #endif
39629:   return nsnull;
39629: }
39629: 
19214: gfxMatrix
19214: nsLayoutUtils::ChangeMatrixBasis(const gfxPoint &aOrigin,
19214:                                  const gfxMatrix &aMatrix)
19214: {
19214:   /* These are translation matrices from world-to-origin of relative frame and
19214:    * vice-versa.  Although I could use the gfxMatrix::Translate function to
19214:    * accomplish this, I'm hoping to reduce the overall number of matrix
19214:    * operations by hardcoding as many of the matrices as possible.
19214:    */
19214:   gfxMatrix worldToOrigin(1.0, 0.0, 0.0, 1.0, -aOrigin.x, -aOrigin.y);
19214:   gfxMatrix originToWorld(1.0, 0.0, 0.0, 1.0,  aOrigin.x,  aOrigin.y);
19214: 
19214:   /* Multiply all three to get the transform! */
19214:   gfxMatrix result(worldToOrigin);
19214:   result.Multiply(aMatrix);
19214:   result.Multiply(originToWorld);
19214:   return result;
19214: }
19214: 
19214: /**
19214:  * Given a gfxFloat, constrains its value to be between nscoord_MIN and nscoord_MAX.
19214:  *
19214:  * @param aVal The value to constrain (in/out)
19214:  */
19214: static void ConstrainToCoordValues(gfxFloat &aVal)
19214: {
19214:   if (aVal <= nscoord_MIN)
19214:     aVal = nscoord_MIN;
19214:   else if (aVal >= nscoord_MAX)
19214:     aVal = nscoord_MAX;
19214: }
19214: 
19214: nsRect
19214: nsLayoutUtils::RoundGfxRectToAppRect(const gfxRect &aRect, float aFactor)
19214: {
19214:   /* Get a new gfxRect whose units are app units by scaling by the specified factor. */
19214:   gfxRect scaledRect(aRect.pos.x * aFactor, aRect.pos.y * aFactor,
19214:                      aRect.size.width * aFactor,
19214:                      aRect.size.height * aFactor);
19214: 
19214:   /* Round outward. */
19214:   scaledRect.RoundOut();
19214: 
19214:   /* We now need to constrain our results to the max and min values for coords. */
19214:   ConstrainToCoordValues(scaledRect.pos.x);
19214:   ConstrainToCoordValues(scaledRect.pos.y);
19214:   ConstrainToCoordValues(scaledRect.size.width);
19214:   ConstrainToCoordValues(scaledRect.size.height);
19214: 
19214:   /* Now typecast everything back.  This is guaranteed to be safe. */
19214:   return nsRect(nscoord(scaledRect.pos.x), nscoord(scaledRect.pos.y),
19214:                 nscoord(scaledRect.size.width), nscoord(scaledRect.size.height));
19214: }
19214: 
59779: 
59779: nsRegion
59779: nsLayoutUtils::RoundedRectIntersectRect(const nsRect& aRoundedRect,
59779:                                         const nscoord aRadii[8],
59779:                                         const nsRect& aContainedRect)
59779: {
59779:   // rectFullHeight and rectFullWidth together will approximately contain
59779:   // the total area of the frame minus the rounded corners.
59779:   nsRect rectFullHeight = aRoundedRect;
59779:   nscoord xDiff = NS_MAX(aRadii[NS_CORNER_TOP_LEFT_X], aRadii[NS_CORNER_BOTTOM_LEFT_X]);
59779:   rectFullHeight.x += xDiff;
59779:   rectFullHeight.width -= NS_MAX(aRadii[NS_CORNER_TOP_RIGHT_X],
59779:                                  aRadii[NS_CORNER_BOTTOM_RIGHT_X]) + xDiff;
59779:   nsRect r1;
59779:   r1.IntersectRect(rectFullHeight, aContainedRect);
59779: 
59779:   nsRect rectFullWidth = aRoundedRect;
59779:   nscoord yDiff = NS_MAX(aRadii[NS_CORNER_TOP_LEFT_Y], aRadii[NS_CORNER_TOP_RIGHT_Y]);
59779:   rectFullWidth.y += yDiff;
59779:   rectFullWidth.height -= NS_MAX(aRadii[NS_CORNER_BOTTOM_LEFT_Y],
59779:                                  aRadii[NS_CORNER_BOTTOM_RIGHT_Y]) + yDiff;
59779:   nsRect r2;
59779:   r2.IntersectRect(rectFullWidth, aContainedRect);
59779: 
59779:   nsRegion result;
59779:   result.Or(r1, r2);
59779:   return result;
59779: }
59779: 
19214: nsRect
19214: nsLayoutUtils::MatrixTransformRect(const nsRect &aBounds,
19214:                                    const gfxMatrix &aMatrix, float aFactor)
19214: {
19214:   gfxRect image = aMatrix.TransformBounds(gfxRect(NSAppUnitsToFloatPixels(aBounds.x, aFactor),
19214:                                                   NSAppUnitsToFloatPixels(aBounds.y, aFactor),
19214:                                                   NSAppUnitsToFloatPixels(aBounds.width, aFactor),
19214:                                                   NSAppUnitsToFloatPixels(aBounds.height, aFactor)));
19214: 
19214:   return RoundGfxRectToAppRect(image, aFactor);
19214: }
19214: 
19214: nsPoint
19214: nsLayoutUtils::MatrixTransformPoint(const nsPoint &aPoint,
19214:                                     const gfxMatrix &aMatrix, float aFactor)
19214: {
19214:   gfxPoint image = aMatrix.Transform(gfxPoint(NSAppUnitsToFloatPixels(aPoint.x, aFactor),
19214:                                               NSAppUnitsToFloatPixels(aPoint.y, aFactor)));
19214:   return nsPoint(NSFloatPixelsToAppUnits(float(image.x), aFactor),
19214:                  NSFloatPixelsToAppUnits(float(image.y), aFactor));
19214: }
19214: 
19214: /**
19214:  * Returns the CTM at the specified frame.
19214:  *
19214:  * @param aFrame The frame at which we should calculate the CTM.
19214:  * @return The CTM at the specified frame.
19214:  */
19214: static gfxMatrix GetCTMAt(nsIFrame *aFrame)
19214: {
19214:   gfxMatrix ctm;
19214: 
19214:   /* Starting at the specified frame, we'll use the GetTransformMatrix
19214:    * function of the frame, which gives us a matrix from this frame up
19214:    * to some other ancestor frame.  Once this function returns null,
19214:    * we've hit the top of the frame tree and can stop.  We get the CTM
19214:    * by simply accumulating all of these matrices together.
19214:    */
19214:   while (aFrame)
19214:     ctm *= aFrame->GetTransformMatrix(&aFrame);
19214:   return ctm;
19214: }
19214: 
19214: nsPoint
19214: nsLayoutUtils::InvertTransformsToRoot(nsIFrame *aFrame,
19214:                                       const nsPoint &aPoint)
19214: {
19214:   NS_PRECONDITION(aFrame, "Why are you inverting transforms when there is no frame?");
19214: 
19214:   /* To invert everything to the root, we'll get the CTM, invert it, and use it to transform
19214:    * the point.
19214:    */
19214:   gfxMatrix ctm = GetCTMAt(aFrame);
19214: 
19214:   /* If the ctm is singular, hand back (0, 0) as a sentinel. */
19214:   if (ctm.IsSingular())
19214:     return nsPoint(0, 0);
19214: 
19214:   /* Otherwise, invert the CTM and use it to transform the point. */
19214:   return MatrixTransformPoint(aPoint, ctm.Invert(), aFrame->PresContext()->AppUnitsPerDevPixel());
19214: }
19214: 
23738: static nsIntPoint GetWidgetOffset(nsIWidget* aWidget, nsIWidget*& aRootWidget) {
23738:   nsIntPoint offset(0, 0);
 3778:   nsIWidget* parent = aWidget->GetParent();
 3778:   while (parent) {
23738:     nsIntRect bounds;
 3778:     aWidget->GetBounds(bounds);
 3778:     offset += bounds.TopLeft();
 3778:     aWidget = parent;
 3778:     parent = aWidget->GetParent();
 3778:   }
 3778:   aRootWidget = aWidget;
 3778:   return offset;
 3778: }
 3778: 
    1: nsPoint
    1: nsLayoutUtils::TranslateWidgetToView(nsPresContext* aPresContext,
    1:                                      nsIWidget* aWidget, nsIntPoint aPt,
    1:                                      nsIView* aView)
    1: {
 3778:   nsPoint viewOffset;
 3778:   nsIWidget* viewWidget = aView->GetNearestWidget(&viewOffset);
50858:   if (!viewWidget) {
50858:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
50858:   }
 3778: 
 3778:   nsIWidget* fromRoot;
23738:   nsIntPoint fromOffset = GetWidgetOffset(aWidget, fromRoot);
 3778:   nsIWidget* toRoot;
23738:   nsIntPoint toOffset = GetWidgetOffset(viewWidget, toRoot);
 3778: 
 3778:   nsIntPoint widgetPoint;
 3778:   if (fromRoot == toRoot) {
 3778:     widgetPoint = aPt + fromOffset - toOffset;
 3778:   } else {
25183:     nsIntPoint screenPoint = aWidget->WidgetToScreenOffset();
25183:     widgetPoint = aPt + screenPoint - viewWidget->WidgetToScreenOffset();
 3778:   }
 3778: 
 3778:   nsPoint widgetAppUnits(aPresContext->DevPixelsToAppUnits(widgetPoint.x),
 3778:                          aPresContext->DevPixelsToAppUnits(widgetPoint.y));
 3778:   return widgetAppUnits - viewOffset;
    1: }
    1: 
    1: // Combine aNewBreakType with aOrigBreakType, but limit the break types
    1: // to NS_STYLE_CLEAR_LEFT, RIGHT, LEFT_AND_RIGHT.
    1: PRUint8
    1: nsLayoutUtils::CombineBreakType(PRUint8 aOrigBreakType,
    1:                                 PRUint8 aNewBreakType)
    1: {
    1:   PRUint8 breakType = aOrigBreakType;
    1:   switch(breakType) {
    1:   case NS_STYLE_CLEAR_LEFT:
    1:     if ((NS_STYLE_CLEAR_RIGHT          == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = NS_STYLE_CLEAR_LEFT_AND_RIGHT;
    1:     }
    1:     break;
    1:   case NS_STYLE_CLEAR_RIGHT:
    1:     if ((NS_STYLE_CLEAR_LEFT           == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = NS_STYLE_CLEAR_LEFT_AND_RIGHT;
    1:     }
    1:     break;
    1:   case NS_STYLE_CLEAR_NONE:
    1:     if ((NS_STYLE_CLEAR_LEFT           == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_RIGHT          == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = aNewBreakType;
    1:     }
    1:   }
    1:   return breakType;
    1: }
    1: 
    1: #ifdef DEBUG
    1: #include <stdio.h>
    1: 
58581: static PRBool gDumpPaintList = getenv("MOZ_DUMP_PAINT_LIST") != 0;
    1: static PRBool gDumpEventList = PR_FALSE;
    1: #endif
    1: 
60444: nsresult
60444: nsLayoutUtils::GetRemoteContentIds(nsIFrame* aFrame,
60444:                                    const nsRect& aTarget,
60444:                                    nsTArray<ViewID> &aOutIDs,
60444:                                    PRBool aIgnoreRootScrollFrame)
60444: {
60444:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::EVENT_DELIVERY,
60444:                                PR_FALSE);
60444:   nsDisplayList list;
60444: 
60444:   if (aIgnoreRootScrollFrame) {
60444:     nsIFrame* rootScrollFrame =
60444:       aFrame->PresContext()->PresShell()->GetRootScrollFrame();
60444:     if (rootScrollFrame) {
60444:       builder.SetIgnoreScrollFrame(rootScrollFrame);
60444:     }
60444:   }
60444: 
60444:   builder.EnterPresShell(aFrame, aTarget);
60444: 
60444:   nsresult rv =
60444:     aFrame->BuildDisplayListForStackingContext(&builder, aTarget, &list);
60444: 
60444:   builder.LeavePresShell(aFrame, aTarget);
60444:   NS_ENSURE_SUCCESS(rv, rv);
60444: 
60444:   nsTArray<nsIFrame*> outFrames;
60444:   nsDisplayItem::HitTestState hitTestState(&aOutIDs);
60444:   list.HitTest(&builder, aTarget, &hitTestState, &outFrames);
60444:   list.DeleteAll();
60444: 
60444:   return NS_OK;
60444: }
60444: 
    1: nsIFrame*
 5440: nsLayoutUtils::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt,
20863:                                 PRBool aShouldIgnoreSuppression,
22095:                                 PRBool aIgnoreRootScrollFrame)
    1: {
40569:   nsresult rv;
40569:   nsTArray<nsIFrame*> outFrames;
40569:   rv = GetFramesForArea(aFrame, nsRect(aPt, nsSize(1, 1)), outFrames,
40569:                         aShouldIgnoreSuppression, aIgnoreRootScrollFrame);
40569:   NS_ENSURE_SUCCESS(rv, nsnull);
40569:   return outFrames.Length() ? outFrames.ElementAt(0) : nsnull;
40569: }
40569: 
40569: nsresult
40569: nsLayoutUtils::GetFramesForArea(nsIFrame* aFrame, const nsRect& aRect,
40569:                                 nsTArray<nsIFrame*> &aOutFrames,
40569:                                 PRBool aShouldIgnoreSuppression,
40569:                                 PRBool aIgnoreRootScrollFrame)
40569: {
57094:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::EVENT_DELIVERY,
57094: 		                       PR_FALSE);
    1:   nsDisplayList list;
40569:   nsRect target(aRect);
40569: 
40569:   if (aShouldIgnoreSuppression) {
 5440:     builder.IgnorePaintSuppression();
40569:   }
20863: 
22095:   if (aIgnoreRootScrollFrame) {
20863:     nsIFrame* rootScrollFrame =
20863:       aFrame->PresContext()->PresShell()->GetRootScrollFrame();
20863:     if (rootScrollFrame) {
20863:       builder.SetIgnoreScrollFrame(rootScrollFrame);
20863:     }
20863:   }
20863: 
    1:   builder.EnterPresShell(aFrame, target);
    1: 
    1:   nsresult rv =
    1:     aFrame->BuildDisplayListForStackingContext(&builder, target, &list);
    1: 
    1:   builder.LeavePresShell(aFrame, target);
40569:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifdef DEBUG
    1:   if (gDumpEventList) {
40569:     fprintf(stderr, "Event handling --- (%d,%d):\n", aRect.x, aRect.y);
31709:     nsFrame::PrintDisplayList(&builder, list);
    1:   }
    1: #endif
    1: 
 9799:   nsDisplayItem::HitTestState hitTestState;
40569:   list.HitTest(&builder, target, &hitTestState, &aOutFrames);
    1:   list.DeleteAll();
40569:   return NS_OK;
    1: }
    1: 
    1: /**
14043:  * Remove all leaf display items that are not for descendants of
14043:  * aBuilder->GetReferenceFrame() from aList, and move all nsDisplayClip
14043:  * wrappers to their correct locations.
14043:  * @param aExtraPage the page we constructed aList for
14043:  * @param aY the Y-coordinate where aPage would be positioned relative
14043:  * to the main page (aBuilder->GetReferenceFrame()), considering only
14043:  * the content and ignoring page margins and dead space
14043:  * @param aList the list that is modified in-place
14043:  */
14043: static void
14043: PruneDisplayListForExtraPage(nsDisplayListBuilder* aBuilder,
14043:         nsIFrame* aExtraPage, nscoord aY, nsDisplayList* aList)
14043: {
14043:   nsDisplayList newList;
14043:   // The page which we're really constructing a display list for
14043:   nsIFrame* mainPage = aBuilder->ReferenceFrame();
14043: 
14043:   while (PR_TRUE) {
14043:     nsDisplayItem* i = aList->RemoveBottom();
14043:     if (!i)
14043:       break;
14043:     nsDisplayList* subList = i->GetList();
14043:     if (subList) {
14043:       PruneDisplayListForExtraPage(aBuilder, aExtraPage, aY, subList);
52292:       nsDisplayItem::Type type = i->GetType();
52292:       if (type == nsDisplayItem::TYPE_CLIP ||
52292:           type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
14043:         // This might clip an element which should appear on the first
14043:         // page, and that element might be visible if this uses a 'clip'
14043:         // property with a negative top.
14043:         // The clip area needs to be moved because the frame geometry doesn't
14043:         // put page content frames for adjacent pages vertically adjacent,
14043:         // there are page margins and dead space between them in print
14043:         // preview, and in printing all pages are at (0,0)...
14043:         // XXX we have no way to test this right now that I know of;
14043:         // the 'clip' property requires an abs-pos element and we never
14043:         // paint abs-pos elements that start after the main page
14043:         // (bug 426909).
14043:         nsDisplayClip* clip = static_cast<nsDisplayClip*>(i);
14043:         clip->SetClipRect(clip->GetClipRect() + nsPoint(0, aY) -
14043:                 aExtraPage->GetOffsetTo(mainPage));
14043:       }
14043:       newList.AppendToTop(i);
14043:     } else {
14043:       nsIFrame* f = i->GetUnderlyingFrame();
14043:       if (f && nsLayoutUtils::IsProperAncestorFrameCrossDoc(mainPage, f)) {
14043:         // This one is in the page we care about, keep it
14043:         newList.AppendToTop(i);
14043:       } else {
14043:         // We're throwing this away so call its destructor now. The memory
14043:         // is owned by aBuilder which destroys all items at once.
23827:         i->~nsDisplayItem();
14043:       }
14043:     }
14043:   }
14043:   aList->AppendToTop(&newList);
14043: }
14043: 
14043: static nsresult
14043: BuildDisplayListForExtraPage(nsDisplayListBuilder* aBuilder,
14043:         nsIFrame* aPage, nscoord aY, nsDisplayList* aList)
14043: {
14043:   nsDisplayList list;
14043:   // Pass an empty dirty rect since we're only interested in finding
14043:   // placeholders whose out-of-flows are in the page
14043:   // aBuilder->GetReferenceFrame(), and the paths to those placeholders
14043:   // have already been marked as NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO.
14043:   // Note that we should still do a prune step since we don't want to
14043:   // rely on dirty-rect checking for correctness.
14043:   nsresult rv = aPage->BuildDisplayListForStackingContext(aBuilder, nsRect(), &list);
14043:   if (NS_FAILED(rv))
14043:     return rv;
14043:   PruneDisplayListForExtraPage(aBuilder, aPage, aY, &list);
14043:   aList->AppendToTop(&list);
14043:   return NS_OK;
14043: }
14043: 
14043: static nsIFrame*
14043: GetNextPage(nsIFrame* aPageContentFrame)
14043: {
14043:   // XXX ugh
14043:   nsIFrame* pageFrame = aPageContentFrame->GetParent();
14043:   NS_ASSERTION(pageFrame->GetType() == nsGkAtoms::pageFrame,
14043:                "pageContentFrame has unexpected parent");
14043:   nsIFrame* nextPageFrame = pageFrame->GetNextSibling();
14043:   if (!nextPageFrame)
14043:     return nsnull;
14043:   NS_ASSERTION(nextPageFrame->GetType() == nsGkAtoms::pageFrame,
14043:                "pageFrame's sibling is not a page frame...");
14043:   nsIFrame* f = nextPageFrame->GetFirstChild(nsnull);
14043:   NS_ASSERTION(f, "pageFrame has no page content frame!");
14043:   NS_ASSERTION(f->GetType() == nsGkAtoms::pageContentFrame,
14043:                "pageFrame's child is not page content!");
14043:   return f;
14043: }
14043: 
    1: nsresult
    1: nsLayoutUtils::PaintFrame(nsIRenderingContext* aRenderingContext, nsIFrame* aFrame,
30541:                           const nsRegion& aDirtyRegion, nscolor aBackstop,
30541:                           PRUint32 aFlags)
    1: {
49168:   if (aFlags & PAINT_WIDGET_LAYERS) {
49168:     nsIView* view = aFrame->GetView();
51184:     if (!(view && view->GetWidget() && GetDisplayRootFrame(aFrame) == aFrame)) {
51184:       aFlags &= ~PAINT_WIDGET_LAYERS;
51184:       NS_ASSERTION(aRenderingContext, "need a rendering context");
51184:     }
51184:   }
49168: 
47738:   nsPresContext* presContext = aFrame->PresContext();
47739:   nsIPresShell* presShell = presContext->PresShell();
47738: 
54080:   PRBool ignoreViewportScrolling = presShell->IgnoringViewportScrolling();
47738:   nsRegion visibleRegion;
54080:   if (aFlags & PAINT_WIDGET_LAYERS) {
47738:     // This layer tree will be reused, so we'll need to calculate it
54080:     // for the whole "visible" area of the window
54080:     // 
54080:     // |ignoreViewportScrolling| and |usingDisplayPort| are persistent
54080:     // document-rendering state.  We rely on PresShell to flush
54080:     // retained layers as needed when that persistent state changes.
54080:     if (!presShell->UsingDisplayPort()) {
55040:       visibleRegion = aFrame->GetVisualOverflowRectRelativeToSelf();
47738:     } else {
54080:       visibleRegion = presShell->GetDisplayPort();
54080:     }
54080:   } else {
47738:     visibleRegion = aDirtyRegion;
47738:   }
47738: 
51011:   // If we're going to display something different from what we'd normally
51011:   // paint in a window then we will flush out any retained layer trees before
51011:   // *and after* we draw.
54080:   PRBool willFlushRetainedLayers = (aFlags & PAINT_HIDE_CARET) != 0;
51011: 
57094:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::PAINTING,
57094: 		                       !(aFlags & PAINT_HIDE_CARET));
    1:   nsDisplayList list;
30541:   if (aFlags & PAINT_IN_TRANSFORM) {
30541:     builder.SetInTransform(PR_TRUE);
30541:   }
32424:   if (aFlags & PAINT_SYNC_DECODE_IMAGES) {
32424:     builder.SetSyncDecodeImages(PR_TRUE);
32424:   }
55826:   if (aFlags & PAINT_WIDGET_LAYERS || aFlags & PAINT_TO_WINDOW) {
42240:     builder.SetPaintingToWindow(PR_TRUE);
42240:   }
51851:   if (aFlags & PAINT_IGNORE_SUPPRESSION) {
51851:     builder.IgnorePaintSuppression();
47739:   }
60027:   if (aRenderingContext &&
60027:       aRenderingContext->ThebesContext()->GetFlags() & gfxContext::FLAG_DISABLE_SNAPPING) {
60027:     builder.SetSnappingEnabled(PR_FALSE);
60027:   }
47739:   nsRect canvasArea(nsPoint(0, 0), aFrame->GetSize());
54080:   if (ignoreViewportScrolling) {
47739:     NS_ASSERTION(!aFrame->GetParent(), "must have root frame");
47739:     nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
47739:     if (rootScrollFrame) {
47739:       nsIScrollableFrame* rootScrollableFrame =
47739:         presShell->GetRootScrollFrameAsScrollable();
54079:       if (aFlags & PAINT_DOCUMENT_RELATIVE) {
47739:         // Make visibleRegion and aRenderingContext relative to the
47739:         // scrolled frame instead of the root frame.
47739:         nsPoint pos = rootScrollableFrame->GetScrollPosition();
47739:         visibleRegion.MoveBy(-pos);
54080:         if (aRenderingContext) {
47739:           aRenderingContext->Translate(pos.x, pos.y);
54079:         }
54080:       }
47739:       builder.SetIgnoreScrollFrame(rootScrollFrame);
47739: 
47739:       nsCanvasFrame* canvasFrame =
47739:         do_QueryFrame(rootScrollableFrame->GetScrolledFrame());
47739:       if (canvasFrame) {
47739:         // Use UnionRect here to ensure that areas where the scrollbars
47739:         // were are still filled with the background color.
47739:         canvasArea.UnionRect(canvasArea,
47739:           canvasFrame->CanvasArea() + builder.ToReferenceFrame(canvasFrame));
47739:       }
47739:     }
47739:   }
29987:   nsresult rv;
29987: 
47738:   nsRect dirtyRect = visibleRegion.GetBounds();
    1:   builder.EnterPresShell(aFrame, dirtyRect);
    1: 
29987:   rv = aFrame->BuildDisplayListForStackingContext(&builder, dirtyRect, &list);
14043: 
50424:   const PRBool paintAllContinuations = aFlags & PAINT_ALL_CONTINUATIONS;
50424:   NS_ASSERTION(!paintAllContinuations || !aFrame->GetPrevContinuation(),
50424:                "If painting all continuations, the frame must be "
50424:                "first-continuation");
50424: 
49168:   nsIAtom* frameType = aFrame->GetType();
50424:   if (NS_SUCCEEDED(rv) && !paintAllContinuations &&
50424:       frameType == nsGkAtoms::pageContentFrame) {
49168:     NS_ASSERTION(!(aFlags & PAINT_WIDGET_LAYERS),
49168:       "shouldn't be painting with widget layers for page content frames");
14043:     // We may need to paint out-of-flow frames whose placeholders are
14043:     // on other pages. Add those pages to our display list. Note that
14043:     // out-of-flow frames can't be placed after their placeholders so
14043:     // we don't have to process earlier pages. The display lists for
14043:     // these extra pages are pruned so that only display items for the
14043:     // page we currently care about (which we would have reached by
14043:     // following placeholders to their out-of-flows) end up on the list.
14043:     nsIFrame* page = aFrame;
14043:     nscoord y = aFrame->GetSize().height;
14043:     while ((page = GetNextPage(page)) != nsnull) {
14043:       rv = BuildDisplayListForExtraPage(&builder, page, y, &list);
14043:       if (NS_FAILED(rv))
14043:         break;
14043:       y += page->GetSize().height;
14043:     }
14043:   }
    1: 
50424:   if (paintAllContinuations) {
50424:     nsIFrame* currentFrame = aFrame;
50424:     while (NS_SUCCEEDED(rv) &&
50424:            (currentFrame = currentFrame->GetNextContinuation()) != nsnull) {
50424:       nsRect frameDirty = dirtyRect - builder.ToReferenceFrame(currentFrame);
50424:       rv = currentFrame->BuildDisplayListForStackingContext(&builder,
50424:                                                             frameDirty, &list);
50424:     }
50424:   }
50424: 
30869:   // For the viewport frame in print preview/page layout we want to paint
30869:   // the grey background behind the page, not the canvas color.
30869:   if (frameType == nsGkAtoms::viewportFrame && 
49166:       nsLayoutUtils::NeedsPrintPreviewBackground(presContext)) {
30869:     nsRect bounds = nsRect(builder.ToReferenceFrame(aFrame),
30869:                            aFrame->GetSize());
49166:     rv = presShell->AddPrintPreviewBackgroundItem(builder, list, aFrame, bounds);
30869:   } else if (frameType != nsGkAtoms::pageFrame) {
29987:     // For printing, this function is first called on an nsPageFrame, which
29987:     // creates a display list with a PageContent item. The PageContent item's
29987:     // paint function calls this function on the nsPageFrame's child which is
29987:     // an nsPageContentFrame. We only want to add the canvas background color
29987:     // item once, for the nsPageContentFrame.
30869: 
47741:     // Add the canvas background color to the bottom of the list. This
47741:     // happens after we've built the list so that AddCanvasBackgroundColorItem
47741:     // can monkey with the contents if necessary.
47739:     rv = presShell->AddCanvasBackgroundColorItem(
47739:            builder, list, aFrame, canvasArea, aBackstop);
49168: 
49168:     // If the passed in backstop color makes us draw something different from
49168:     // normal, we need to flush layers.
54080:     if ((aFlags & PAINT_WIDGET_LAYERS) && !willFlushRetainedLayers) {
49168:       nsIView* view = aFrame->GetView();
49168:       if (view) {
49168:         nscolor backstop = presShell->ComputeBackstopColor(view);
49168:         // The PresShell's canvas background color doesn't get updated until
49168:         // EnterPresShell, so this check has to be done after that.
49168:         nscolor canvasColor = presShell->GetCanvasBackground();
49168:         if (NS_ComposeColors(aBackstop, canvasColor) !=
49168:             NS_ComposeColors(backstop, canvasColor)) {
54080:           willFlushRetainedLayers = PR_TRUE;
49168:         }
49168:       }
49168:     }
29987:   }
29987: 
    1:   builder.LeavePresShell(aFrame, dirtyRect);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
51851:   if (builder.GetHadToIgnorePaintSuppression()) {
54080:     willFlushRetainedLayers = PR_TRUE;
51851:   }
51851: 
    1: #ifdef DEBUG
    1:   if (gDumpPaintList) {
    1:     fprintf(stderr, "Painting --- before optimization (dirty %d,%d,%d,%d):\n",
    1:             dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
31709:     nsFrame::PrintDisplayList(&builder, list);
    1:   }
    1: #endif
    1: 
51633:   list.ComputeVisibilityForRoot(&builder, &visibleRegion);
    1: 
38805:   PRUint32 flags = nsDisplayList::PAINT_DEFAULT;
38805:   if (aFlags & PAINT_WIDGET_LAYERS) {
38805:     flags |= nsDisplayList::PAINT_USE_WIDGET_LAYERS;
59778: 
47148:     nsIWidget *widget = aFrame->GetNearestWidget();
54080:     if (willFlushRetainedLayers) {
54080:       // The caller wanted to paint from retained layers, but set up
54080:       // the paint in such a way that we can't use them.  We're going
54080:       // to display something different from what we'd normally paint
54080:       // in a window, so make sure we flush out any retained layer
54080:       // trees before *and after* we draw.  Callers should be fixed to
54080:       // not do this.
54080:       NS_WARNING("Flushing retained layers!");
47739:       flags |= nsDisplayList::PAINT_FLUSH_LAYERS;
54079:     } else if (widget && !(aFlags & PAINT_DOCUMENT_RELATIVE)) {
61413:       nsIWidget_MOZILLA_2_0_BRANCH* widget2 =
61413:         static_cast<nsIWidget_MOZILLA_2_0_BRANCH*>(widget);
59778:       PRInt32 pixelRatio = presContext->AppUnitsPerDevPixel();
59778:       nsIntRegion visibleWindowRegion(visibleRegion.ToOutsidePixels(pixelRatio));
59778:       builder.SetFinalTransparentRegion(visibleRegion);
61413:       widget2->UpdateTransparentRegion(visibleWindowRegion);
60643: 
60643:       // If we're finished building display list items for painting of the outermost
60643:       // pres shell, notify the widget about any toolbars we've encountered.
60643:       widget2->UpdateThemeGeometries(builder.GetThemeGeometries());
38805:     }
47739:   }
60857:   if (aFlags & PAINT_EXISTING_TRANSACTION) {
60857:     flags |= nsDisplayList::PAINT_EXISTING_TRANSACTION;
60857:   }
47738: 
42246:   list.PaintRoot(&builder, aRenderingContext, flags);
47738: 
47738: #ifdef DEBUG
47738:   if (gDumpPaintList) {
59820:     fprintf(stderr, "Painting --- after optimization:\n");
59820:     nsFrame::PrintDisplayList(&builder, list);
59820: 
47738:     fprintf(stderr, "Painting --- retained layer tree:\n");
47738:     builder.LayerBuilder()->DumpRetainedLayerTree();
47738:   }
47738: #endif
47738: 
    1:   // Flush the list so we don't trigger the IsEmpty-on-destruction assertion
    1:   list.DeleteAll();
    1:   return NS_OK;
    1: }
    1: 
    1: PRInt32
    1: nsLayoutUtils::GetZIndex(nsIFrame* aFrame) {
    1:   if (!aFrame->GetStyleDisplay()->IsPositioned())
    1:     return 0;
    1: 
    1:   const nsStylePosition* position =
    1:     aFrame->GetStylePosition();
    1:   if (position->mZIndex.GetUnit() == eStyleUnit_Integer)
    1:     return position->mZIndex.GetIntValue();
    1: 
    1:   // sort the auto and 0 elements together
    1:   return 0;
    1: }
    1: 
    1: /**
    1:  * Uses a binary search for find where the cursor falls in the line of text
    1:  * It also keeps track of the part of the string that has already been measured
    1:  * so it doesn't have to keep measuring the same text over and over
    1:  *
    1:  * @param "aBaseWidth" contains the width in twips of the portion
    1:  * of the text that has already been measured, and aBaseInx contains
    1:  * the index of the text that has already been measured.
    1:  *
    1:  * @param aTextWidth returns the (in twips) the length of the text that falls
    1:  * before the cursor aIndex contains the index of the text where the cursor falls
    1:  */
    1: PRBool
    1: nsLayoutUtils::BinarySearchForPosition(nsIRenderingContext* aRendContext,
    1:                         const PRUnichar* aText,
    1:                         PRInt32    aBaseWidth,
    1:                         PRInt32    aBaseInx,
    1:                         PRInt32    aStartInx,
    1:                         PRInt32    aEndInx,
    1:                         PRInt32    aCursorPos,
    1:                         PRInt32&   aIndex,
    1:                         PRInt32&   aTextWidth)
    1: {
    1:   PRInt32 range = aEndInx - aStartInx;
    1:   if ((range == 1) || (range == 2 && NS_IS_HIGH_SURROGATE(aText[aStartInx]))) {
    1:     aIndex   = aStartInx + aBaseInx;
    1:     aRendContext->GetWidth(aText, aIndex, aTextWidth);
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   PRInt32 inx = aStartInx + (range / 2);
    1: 
    1:   // Make sure we don't leave a dangling low surrogate
    1:   if (NS_IS_HIGH_SURROGATE(aText[inx-1]))
    1:     inx++;
    1: 
    1:   PRInt32 textWidth = 0;
    1:   aRendContext->GetWidth(aText, inx, textWidth);
    1: 
    1:   PRInt32 fullWidth = aBaseWidth + textWidth;
    1:   if (fullWidth == aCursorPos) {
    1:     aTextWidth = textWidth;
    1:     aIndex = inx;
    1:     return PR_TRUE;
    1:   } else if (aCursorPos < fullWidth) {
    1:     aTextWidth = aBaseWidth;
    1:     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, aStartInx, inx, aCursorPos, aIndex, aTextWidth)) {
    1:       return PR_TRUE;
    1:     }
    1:   } else {
    1:     aTextWidth = fullWidth;
    1:     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, inx, aEndInx, aCursorPos, aIndex, aTextWidth)) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
12349: static void
19125: AddBoxesForFrame(nsIFrame* aFrame,
19125:                  nsLayoutUtils::BoxCallback* aCallback)
    1: {
34387:   nsIAtom* pseudoType = aFrame->GetStyleContext()->GetPseudo();
    1: 
12349:   if (pseudoType == nsCSSAnonBoxes::tableOuter) {
19125:     AddBoxesForFrame(aFrame->GetFirstChild(nsnull), aCallback);
12349:     nsIFrame* kid = aFrame->GetFirstChild(nsGkAtoms::captionList);
12349:     if (kid) {
19125:       AddBoxesForFrame(kid, aCallback);
12349:     }
12349:   } else if (pseudoType == nsCSSAnonBoxes::mozAnonymousBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozAnonymousPositionedBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozMathMLAnonymousBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozXULAnonymousBlock) {
12349:     for (nsIFrame* kid = aFrame->GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {
19125:       AddBoxesForFrame(kid, aCallback);
12349:     }
12349:   } else {
19125:     aCallback->AddBox(aFrame);
19125:   }
19125: }
19125: 
19125: void
19125: nsLayoutUtils::GetAllInFlowBoxes(nsIFrame* aFrame, BoxCallback* aCallback)
19125: {
19125:   while (aFrame) {
19125:     AddBoxesForFrame(aFrame, aCallback);
19125:     aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
19125:   }
19125: }
19125: 
19125: struct BoxToBorderRect : public nsLayoutUtils::BoxCallback {
19125:   nsIFrame*                    mRelativeTo;
19125:   nsLayoutUtils::RectCallback* mCallback;
19125: 
19125:   BoxToBorderRect(nsIFrame* aRelativeTo, nsLayoutUtils::RectCallback* aCallback)
27977:     : mRelativeTo(aRelativeTo), mCallback(aCallback) {}
19125: 
19125:   virtual void AddBox(nsIFrame* aFrame) {
12349: #ifdef MOZ_SVG
12349:     nsRect r;
12349:     nsIFrame* outer = nsSVGUtils::GetOuterSVGFrameAndCoveredRegion(aFrame, &r);
12349:     if (outer) {
19125:       mCallback->AddRect(r + outer->GetOffsetTo(mRelativeTo));
12349:     } else
12349: #endif
19125:       mCallback->AddRect(nsRect(aFrame->GetOffsetTo(mRelativeTo), aFrame->GetSize()));
12349:   }
19125: };
    1: 
12349: void
12349: nsLayoutUtils::GetAllInFlowRects(nsIFrame* aFrame, nsIFrame* aRelativeTo,
12349:                                  RectCallback* aCallback)
12349: {
19125:   BoxToBorderRect converter(aRelativeTo, aCallback);
19125:   GetAllInFlowBoxes(aFrame, &converter);
    1: }
    1: 
33027: nsLayoutUtils::RectAccumulator::RectAccumulator() : mSeenFirstRect(PR_FALSE) {}
33027: 
33027: void nsLayoutUtils::RectAccumulator::AddRect(const nsRect& aRect) {
12349:   mResultRect.UnionRect(mResultRect, aRect);
12349:   if (!mSeenFirstRect) {
12349:     mSeenFirstRect = PR_TRUE;
12349:     mFirstRect = aRect;
12349:   }
12349: }
33027: 
33027: nsLayoutUtils::RectListBuilder::RectListBuilder(nsClientRectList* aList)
33027:   : mRectList(aList), mRV(NS_OK) {}
33027: 
33027: void nsLayoutUtils::RectListBuilder::AddRect(const nsRect& aRect) {
33027:   nsRefPtr<nsClientRect> rect = new nsClientRect();
33027:   if (!rect) {
33027:     mRV = NS_ERROR_OUT_OF_MEMORY;
33027:     return;
33027:   }
33027: 
33027:   rect->SetLayoutRect(aRect);
33027:   mRectList->Append(rect);
33027: }
33027: 
33027: nsIFrame* nsLayoutUtils::GetContainingBlockForClientRect(nsIFrame* aFrame)
33027: {
33027:   // get the nearest enclosing SVG foreign object frame or the root frame
33027:   while (aFrame->GetParent() &&
33027:          !aFrame->IsFrameOfType(nsIFrame::eSVGForeignObject)) {
33027:     aFrame = aFrame->GetParent();
33027:   }
33027: 
33027:   return aFrame;
33027: }
12349: 
12349: nsRect
12349: nsLayoutUtils::GetAllInFlowRectsUnion(nsIFrame* aFrame, nsIFrame* aRelativeTo) {
12349:   RectAccumulator accumulator;
12349:   GetAllInFlowRects(aFrame, aRelativeTo, &accumulator);
12349:   return accumulator.mResultRect.IsEmpty() ? accumulator.mFirstRect
12349:           : accumulator.mResultRect;
    1: }
    1: 
15339: nsRect
15339: nsLayoutUtils::GetTextShadowRectsUnion(const nsRect& aTextAndDecorationsRect,
59781:                                        nsIFrame* aFrame,
59781:                                        PRUint32 aFlags)
15339: {
15339:   const nsStyleText* textStyle = aFrame->GetStyleText();
15699:   if (!textStyle->mTextShadow)
15339:     return aTextAndDecorationsRect;
15339: 
15339:   nsRect resultRect = aTextAndDecorationsRect;
52476:   PRInt32 A2D = aFrame->PresContext()->AppUnitsPerDevPixel();
15699:   for (PRUint32 i = 0; i < textStyle->mTextShadow->Length(); ++i) {
59781:     nsCSSShadowItem* shadow = textStyle->mTextShadow->ShadowAt(i);
59781:     nsMargin blur = nsContextBoxBlur::GetBlurRadiusMargin(shadow->mRadius, A2D);
59781:     if ((aFlags & EXCLUDE_BLUR_SHADOWS) && blur != nsMargin(0, 0, 0, 0))
59781:       continue;
59781: 
15339:     nsRect tmpRect(aTextAndDecorationsRect);
15339: 
19207:     tmpRect.MoveBy(nsPoint(shadow->mXOffset, shadow->mYOffset));
59781:     tmpRect.Inflate(blur);
15339: 
15339:     resultRect.UnionRect(resultRect, tmpRect);
15339:   }
15339:   return resultRect;
15339: }
15339: 
    1: nsresult
56866: nsLayoutUtils::GetFontMetricsForFrame(const nsIFrame* aFrame,
    1:                                       nsIFontMetrics** aFontMetrics)
    1: {
 4355:   return nsLayoutUtils::GetFontMetricsForStyleContext(aFrame->GetStyleContext(),
 4355:                                                       aFontMetrics);
 4355: }
 4355: 
 4355: nsresult
 4355: nsLayoutUtils::GetFontMetricsForStyleContext(nsStyleContext* aStyleContext,
 4355:                                              nsIFontMetrics** aFontMetrics)
 4355: {
19962:   // pass the user font set object into the device context to pass along to CreateFontGroup
19962:   gfxUserFontSet* fs = aStyleContext->PresContext()->GetUserFontSet();
19962: 
19962:   return aStyleContext->PresContext()->DeviceContext()->GetMetricsFor(
19962:                   aStyleContext->GetStyleFont()->mFont,
38492:                   aStyleContext->GetStyleVisibility()->mLanguage,
22335:                   fs, *aFontMetrics);
    1: }
    1: 
    1: nsIFrame*
    1: nsLayoutUtils::FindChildContainingDescendant(nsIFrame* aParent, nsIFrame* aDescendantFrame)
    1: {
    1:   nsIFrame* result = aDescendantFrame;
    1: 
    1:   while (result) {
    1:     nsIFrame* parent = result->GetParent();
    1:     if (parent == aParent) {
    1:       break;
    1:     }
    1: 
    1:     // The frame is not an immediate child of aParent so walk up another level
    1:     result = parent;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsBlockFrame*
 9572: nsLayoutUtils::GetAsBlock(nsIFrame* aFrame)
 9572: {
23554:   nsBlockFrame* block = do_QueryFrame(aFrame);
 9572:   return block;
 9572: }
 9572: 
 9572: nsBlockFrame*
    1: nsLayoutUtils::FindNearestBlockAncestor(nsIFrame* aFrame)
    1: {
    1:   nsIFrame* nextAncestor;
    1:   for (nextAncestor = aFrame->GetParent(); nextAncestor;
    1:        nextAncestor = nextAncestor->GetParent()) {
 9572:     nsBlockFrame* block = GetAsBlock(nextAncestor);
 9572:     if (block)
    1:       return block;
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: nsIFrame*
21943: nsLayoutUtils::GetNonGeneratedAncestor(nsIFrame* aFrame)
21943: {
21943:   if (!(aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT))
21943:     return aFrame;
21943: 
21943:   nsFrameManager* frameManager = aFrame->PresContext()->FrameManager();
21943:   nsIFrame* f = aFrame;
21943:   do {
21943:     f = GetParentOrPlaceholderFor(frameManager, f);
21943:   } while (f->GetStateBits() & NS_FRAME_GENERATED_CONTENT);
21943:   return f;
21943: }
21943: 
21943: nsIFrame*
    1: nsLayoutUtils::GetParentOrPlaceholderFor(nsFrameManager* aFrameManager,
    1:                                          nsIFrame* aFrame)
    1: {
 6521:   if ((aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
32108:       && !aFrame->GetPrevInFlow()) {
    1:     return aFrameManager->GetPlaceholderFrameFor(aFrame);
 6521:   }
    1:   return aFrame->GetParent();
    1: }
    1: 
    1: nsIFrame*
   94: nsLayoutUtils::GetNextContinuationOrSpecialSibling(nsIFrame *aFrame)
   94: {
   94:   nsIFrame *result = aFrame->GetNextContinuation();
   94:   if (result)
   94:     return result;
   94: 
   94:   if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0) {
   94:     // We only store the "special sibling" annotation with the first
27338:     // frame in the continuation chain. Walk back to find that frame now.
27338:     aFrame = aFrame->GetFirstContinuation();
   94: 
39965:     void* value = aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling());
 3233:     return static_cast<nsIFrame*>(value);
   94:   }
   94: 
   94:   return nsnull;
   94: }
   94: 
19125: nsIFrame*
19125: nsLayoutUtils::GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame)
19125: {
19125:   nsIFrame *result = aFrame->GetFirstContinuation();
19125:   if (result->GetStateBits() & NS_FRAME_IS_SPECIAL) {
19125:     while (PR_TRUE) {
19125:       nsIFrame *f = static_cast<nsIFrame*>
39965:         (result->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
19125:       if (!f)
19125:         break;
19125:       result = f;
19125:     }
19125:   }
19125: 
19125:   return result;
19125: }
19125: 
    1: PRBool
    1: nsLayoutUtils::IsViewportScrollbarFrame(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
    1:     return PR_FALSE;
    1: 
    1:   nsIFrame* rootScrollFrame =
  238:     aFrame->PresContext()->PresShell()->GetRootScrollFrame();
    1:   if (!rootScrollFrame)
    1:     return PR_FALSE;
    1: 
23554:   nsIScrollableFrame* rootScrollableFrame = do_QueryFrame(rootScrollFrame);
    1:   NS_ASSERTION(rootScrollableFrame, "The root scorollable frame is null");
    1: 
    1:   if (!IsProperAncestorFrame(rootScrollFrame, aFrame))
    1:     return PR_FALSE;
    1: 
    1:   nsIFrame* rootScrolledFrame = rootScrollableFrame->GetScrolledFrame();
    1:   return !(rootScrolledFrame == aFrame ||
    1:            IsProperAncestorFrame(rootScrolledFrame, aFrame));
    1: }
    1: 
    1: static nscoord AddPercents(nsLayoutUtils::IntrinsicWidthType aType,
    1:                            nscoord aCurrent, float aPercent)
    1: {
    1:   nscoord result = aCurrent;
    1:   if (aPercent > 0.0f && aType == nsLayoutUtils::PREF_WIDTH) {
    1:     // XXX Should we also consider percentages for min widths, up to a
    1:     // limit?
    1:     if (aPercent >= 1.0f)
    1:       result = nscoord_MAX;
    1:     else
    1:       result = NSToCoordRound(float(result) / (1.0f - aPercent));
    1:   }
    1:   return result;
    1: }
    1: 
51406: // Use only for widths/heights (or their min/max), since it clamps
51406: // negative calc() results to 0.
16031: static PRBool GetAbsoluteCoord(const nsStyleCoord& aStyle, nscoord& aResult)
16031: {
49566:   if (aStyle.IsCalcUnit()) {
49566:     if (aStyle.CalcHasPercent()) {
49566:       return PR_FALSE;
49566:     }
49566:     // If it has no percents, we can pass 0 for the percentage basis.
49566:     aResult = nsRuleNode::ComputeComputedCalc(aStyle, 0);
51406:     if (aResult < 0)
51406:       aResult = 0;
49566:     return PR_TRUE;
49566:   }
49566: 
16031:   if (eStyleUnit_Coord != aStyle.GetUnit())
16031:     return PR_FALSE;
16031: 
16031:   aResult = aStyle.GetCoordValue();
51406:   NS_ASSERTION(aResult >= 0, "negative widths not allowed");
16031:   return PR_TRUE;
16031: }
16031: 
 2301: static PRBool
 2301: GetPercentHeight(const nsStyleCoord& aStyle,
 2301:                  nsIFrame* aFrame,
 2301:                  nscoord& aResult)
 2301: {
 2301:   if (eStyleUnit_Percent != aStyle.GetUnit())
 2301:     return PR_FALSE;
 2301: 
 2301:   nsIFrame *f;
 2301:   for (f = aFrame->GetParent(); f && !f->IsContainingBlock();
 2301:        f = f->GetParent())
 2301:     ;
 2301:   if (!f) {
 2301:     NS_NOTREACHED("top of frame tree not a containing block");
 2301:     return PR_FALSE;
 2301:   }
 2301: 
 2301:   const nsStylePosition *pos = f->GetStylePosition();
 2301:   nscoord h;
16031:   if (!GetAbsoluteCoord(pos->mHeight, h) &&
16031:       !GetPercentHeight(pos->mHeight, f, h)) {
 2301:     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto ||
51406:                  pos->mHeight.HasPercent(),
 2301:                  "unknown height unit");
48945:     nsIAtom* fType = f->GetType();
48945:     if (fType != nsGkAtoms::viewportFrame && fType != nsGkAtoms::canvasFrame &&
48945:         fType != nsGkAtoms::pageContentFrame) {
 2301:       // There's no basis for the percentage height, so it acts like auto.
 2301:       // Should we consider a max-height < min-height pair a basis for
 2301:       // percentage heights?  The spec is somewhat unclear, and not doing
 2301:       // so is simpler and avoids troubling discontinuities in behavior,
 2301:       // so I'll choose not to. -LDB
 2301:       return PR_FALSE;
 2301:     }
 2301: 
48945:     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto,
48945:                  "Unexpected height unit for viewport or canvas or page-content");
48945:     // For the viewport, canvas, and page-content kids, the percentage
48945:     // basis is just the parent height.
48945:     h = f->GetSize().height;
48945:     if (h == NS_UNCONSTRAINEDSIZE) {
48945:       // We don't have a percentage basis after all
48945:       return PR_FALSE;
48945:     }
48945:   }
48945: 
 2301:   nscoord maxh;
16031:   if (GetAbsoluteCoord(pos->mMaxHeight, maxh) ||
16031:       GetPercentHeight(pos->mMaxHeight, f, maxh)) {
 2301:     if (maxh < h)
 2301:       h = maxh;
 2301:   } else {
 2301:     NS_ASSERTION(pos->mMaxHeight.GetUnit() == eStyleUnit_None ||
51406:                  pos->mMaxHeight.HasPercent(),
 2301:                  "unknown max-height unit");
 2301:   }
 2301: 
 2301:   nscoord minh;
16031:   if (GetAbsoluteCoord(pos->mMinHeight, minh) ||
16031:       GetPercentHeight(pos->mMinHeight, f, minh)) {
 2301:     if (minh > h)
 2301:       h = minh;
 2301:   } else {
51406:     NS_ASSERTION(pos->mMinHeight.HasPercent(),
 2301:                  "unknown min-height unit");
 2301:   }
 2301: 
 2301:   aResult = NSToCoordRound(aStyle.GetPercentValue() * h);
 2301:   return PR_TRUE;
 2301: }
 2301: 
 8046: // Handles only -moz-max-content and -moz-min-content, and
 8046: // -moz-fit-content for min-width and max-width, since the others
 8046: // (-moz-fit-content for width, and -moz-available) have no effect on
 1068: // intrinsic widths.
 1068: enum eWidthProperty { PROP_WIDTH, PROP_MAX_WIDTH, PROP_MIN_WIDTH };
 1068: static PRBool
 1068: GetIntrinsicCoord(const nsStyleCoord& aStyle,
 1068:                   nsIRenderingContext* aRenderingContext,
 1068:                   nsIFrame* aFrame,
 1068:                   eWidthProperty aProperty,
 1068:                   nscoord& aResult)
 1068: {
 1068:   NS_PRECONDITION(aProperty == PROP_WIDTH || aProperty == PROP_MAX_WIDTH ||
 1068:                   aProperty == PROP_MIN_WIDTH, "unexpected property");
 1068:   if (aStyle.GetUnit() != eStyleUnit_Enumerated)
 1068:     return PR_FALSE;
 1068:   PRInt32 val = aStyle.GetIntValue();
 8046:   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_MIN_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_FIT_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_AVAILABLE,
 1068:                "unexpected enumerated value for width property");
 8046:   if (val == NS_STYLE_WIDTH_AVAILABLE)
 1068:     return PR_FALSE;
 8046:   if (val == NS_STYLE_WIDTH_FIT_CONTENT) {
 1068:     if (aProperty == PROP_WIDTH)
 1068:       return PR_FALSE; // handle like 'width: auto'
 1068:     if (aProperty == PROP_MAX_WIDTH)
 8046:       // constrain large 'width' values down to -moz-max-content
 8046:       val = NS_STYLE_WIDTH_MAX_CONTENT;
 1068:     else
 8046:       // constrain small 'width' or 'max-width' values up to -moz-min-content
 8046:       val = NS_STYLE_WIDTH_MIN_CONTENT;
 1068:   }
 1068: 
 8046:   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_MIN_CONTENT,
 1068:                "should have reduced everything remaining to one of these");
 8046:   if (val == NS_STYLE_WIDTH_MAX_CONTENT)
 1068:     aResult = aFrame->GetPrefWidth(aRenderingContext);
 1068:   else
 1068:     aResult = aFrame->GetMinWidth(aRenderingContext);
 1068:   return PR_TRUE;
 1068: }
 1068: 
    1: #undef  DEBUG_INTRINSIC_WIDTH
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1: static PRInt32 gNoiseIndent = 0;
    1: #endif
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::IntrinsicForContainer(nsIRenderingContext *aRenderingContext,
    1:                                      nsIFrame *aFrame,
    1:                                      IntrinsicWidthType aType)
    1: {
    1:   NS_PRECONDITION(aFrame, "null frame");
    1:   NS_PRECONDITION(aType == MIN_WIDTH || aType == PREF_WIDTH, "bad type");
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:   nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:   printf(" %s intrinsic width for container:\n",
    1:          aType == MIN_WIDTH ? "min" : "pref");
    1: #endif
    1: 
    1:   nsIFrame::IntrinsicWidthOffsetData offsets =
    1:     aFrame->IntrinsicWidthOffsets(aRenderingContext);
    1: 
    1:   const nsStylePosition *stylePos = aFrame->GetStylePosition();
 1068:   PRUint8 boxSizing = stylePos->mBoxSizing;
    1:   const nsStyleCoord &styleWidth = stylePos->mWidth;
    1:   const nsStyleCoord &styleMinWidth = stylePos->mMinWidth;
    1:   const nsStyleCoord &styleMaxWidth = stylePos->mMaxWidth;
    1: 
    1:   // We build up two values starting with the content box, and then
    1:   // adding padding, border and margin.  The result is normally
    1:   // |result|.  Then, when we handle 'width', 'min-width', and
    1:   // 'max-width', we use the results we've been building in |min| as a
    1:   // minimum, overriding 'min-width'.  This ensures two things:
    1:   //   * that we don't let a value of 'box-sizing' specifying a width
    1:   //     smaller than the padding/border inside the box-sizing box give
    1:   //     a content width less than zero
    1:   //   * that we prevent tables from becoming smaller than their
    1:   //     intrinsic minimum width
    1:   nscoord result = 0, min = 0;
    1: 
51407:   nscoord maxw;
51407:   PRBool haveFixedMaxWidth = GetAbsoluteCoord(styleMaxWidth, maxw);
51407:   nscoord minw;
51407:   PRBool haveFixedMinWidth = GetAbsoluteCoord(styleMinWidth, minw);
51407: 
    1:   // If we have a specified width (or a specified 'min-width' greater
    1:   // than the specified 'max-width', which works out to the same thing),
    1:   // don't even bother getting the frame's intrinsic width.
 1068:   if (styleWidth.GetUnit() == eStyleUnit_Enumerated &&
 8046:       (styleWidth.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:        styleWidth.GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT)) {
 8046:     // -moz-fit-content and -moz-available enumerated widths compute intrinsic
 1068:     // widths just like auto.
 8046:     // For -moz-max-content and -moz-min-content, we handle them like
 1068:     // specified widths, but ignore -moz-box-sizing.
 1068:     boxSizing = NS_STYLE_BOX_SIZING_CONTENT;
 1068:   } else if (styleWidth.GetUnit() != eStyleUnit_Coord &&
51407:              !(haveFixedMinWidth && haveFixedMaxWidth && maxw <= minw)) {
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:     ++gNoiseIndent;
    1: #endif
    1:     if (aType == MIN_WIDTH)
    1:       result = aFrame->GetMinWidth(aRenderingContext);
    1:     else
    1:       result = aFrame->GetPrefWidth(aRenderingContext);
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:     --gNoiseIndent;
    1:     nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:     static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:     printf(" %s intrinsic width from frame is %d.\n",
    1:            aType == MIN_WIDTH ? "min" : "pref", result);
    1: #endif
 2301: 
 2301:     // Handle elements with an intrinsic ratio (or size) and a specified
 2301:     // height, min-height, or max-height.
 2301:     const nsStyleCoord &styleHeight = stylePos->mHeight;
 2301:     const nsStyleCoord &styleMinHeight = stylePos->mMinHeight;
 2301:     const nsStyleCoord &styleMaxHeight = stylePos->mMaxHeight;
 2301:     if (styleHeight.GetUnit() != eStyleUnit_Auto ||
 2301:         !(styleMinHeight.GetUnit() == eStyleUnit_Coord &&
 2301:           styleMinHeight.GetCoordValue() == 0) ||
 2301:         styleMaxHeight.GetUnit() != eStyleUnit_None) {
 2301: 
 2301:       nsSize ratio = aFrame->GetIntrinsicRatio();
 2301: 
 2301:       if (ratio.height != 0) {
 2301: 
 2301:         nscoord h;
16031:         if (GetAbsoluteCoord(styleHeight, h) ||
16031:             GetPercentHeight(styleHeight, aFrame, h)) {
 2301:           result =
 2301:             NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:         }
 2301: 
16031:         if (GetAbsoluteCoord(styleMaxHeight, h) ||
16031:             GetPercentHeight(styleMaxHeight, aFrame, h)) {
 2301:           h = NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:           if (h < result)
 2301:             result = h;
 2301:         }
 2301: 
16031:         if (GetAbsoluteCoord(styleMinHeight, h) ||
16031:             GetPercentHeight(styleMinHeight, aFrame, h)) {
 2301:           h = NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:           if (h > result)
 2301:             result = h;
 2301:         }
 2301:       }
 2301:     }
    1:   }
    1: 
    1:   if (aFrame->GetType() == nsGkAtoms::tableFrame) {
    1:     // Tables can't shrink smaller than their intrinsic minimum width,
    1:     // no matter what.
    1:     min = aFrame->GetMinWidth(aRenderingContext);
    1:   }
    1: 
    1:   // We also need to track what has been added on outside of the box
    1:   // (controlled by 'box-sizing') where 'width', 'min-width' and
    1:   // 'max-width' are applied.  We have to account for these properties
    1:   // after getting all the offsets (margin, border, padding) because
    1:   // percentages do not operate linearly.
    1:   // Doing this is ok because although percentages aren't handled
    1:   // linearly, they are handled monotonically.
    1:   nscoord coordOutsideWidth = offsets.hPadding;
    1:   float pctOutsideWidth = offsets.hPctPadding;
    1: 
    1:   float pctTotal = 0.0f;
    1: 
    1:   if (boxSizing == NS_STYLE_BOX_SIZING_PADDING) {
    1:     min += coordOutsideWidth;
 6254:     result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:     pctTotal += pctOutsideWidth;
    1: 
    1:     coordOutsideWidth = 0;
    1:     pctOutsideWidth = 0.0f;
    1:   }
    1: 
    1:   coordOutsideWidth += offsets.hBorder;
    1: 
    1:   if (boxSizing == NS_STYLE_BOX_SIZING_BORDER) {
    1:     min += coordOutsideWidth;
 6254:     result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:     pctTotal += pctOutsideWidth;
    1: 
    1:     coordOutsideWidth = 0;
    1:     pctOutsideWidth = 0.0f;
    1:   }
    1: 
    1:   coordOutsideWidth += offsets.hMargin;
    1:   pctOutsideWidth += offsets.hPctMargin;
    1: 
    1:   min += coordOutsideWidth;
 6254:   result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:   pctTotal += pctOutsideWidth;
    1: 
    1:   nscoord w;
16031:   if (GetAbsoluteCoord(styleWidth, w) ||
 1068:       GetIntrinsicCoord(styleWidth, aRenderingContext, aFrame,
 1068:                         PROP_WIDTH, w)) {
    1:     result = AddPercents(aType, w + coordOutsideWidth, pctOutsideWidth);
    1:   }
49566:   else if (aType == MIN_WIDTH &&
49566:            // The only cases of coord-percent-calc() units that
49566:            // GetAbsoluteCoord didn't handle are percent and calc()s
49566:            // containing percent.
49566:            styleWidth.IsCoordPercentCalcUnit() &&
    1:            aFrame->IsFrameOfType(nsIFrame::eReplaced)) {
    1:     // A percentage width on replaced elements means they can shrink to 0.
    1:     result = 0; // let |min| handle padding/border/margin
    1:   }
    1:   else {
49566:     // NOTE: We could really do a lot better for percents and for some
49566:     // cases of calc() containing percent (certainly including any where
49566:     // the coefficient on the percent is positive and there are no max()
49566:     // expressions).  However, doing better for percents wouldn't be
49566:     // backwards compatible.
    1:     result = AddPercents(aType, result, pctTotal);
    1:   }
    1: 
51407:   if (haveFixedMaxWidth ||
 1068:       GetIntrinsicCoord(styleMaxWidth, aRenderingContext, aFrame,
 1068:                         PROP_MAX_WIDTH, maxw)) {
    1:     maxw = AddPercents(aType, maxw + coordOutsideWidth, pctOutsideWidth);
    1:     if (result > maxw)
    1:       result = maxw;
    1:   }
    1: 
51407:   if (haveFixedMinWidth ||
 1068:       GetIntrinsicCoord(styleMinWidth, aRenderingContext, aFrame,
 1068:                         PROP_MIN_WIDTH, minw)) {
    1:     minw = AddPercents(aType, minw + coordOutsideWidth, pctOutsideWidth);
    1:     if (result < minw)
    1:       result = minw;
    1:   }
    1: 
    1:   min = AddPercents(aType, min, pctTotal);
    1:   if (result < min)
    1:     result = min;
    1: 
    1:   const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
    1:   if (aFrame->IsThemed(disp)) {
23738:     nsIntSize size(0, 0);
    1:     PRBool canOverride = PR_TRUE;
  238:     nsPresContext *presContext = aFrame->PresContext();
    1:     presContext->GetTheme()->
    1:       GetMinimumWidgetSize(aRenderingContext, aFrame, disp->mAppearance,
    1:                            &size, &canOverride);
    1: 
    1:     nscoord themeWidth = presContext->DevPixelsToAppUnits(size.width);
    1: 
    1:     // GMWS() returns a border-box width
    1:     themeWidth += offsets.hMargin;
    1:     themeWidth = AddPercents(aType, themeWidth, offsets.hPctMargin);
    1: 
    1:     if (themeWidth > result || !canOverride)
    1:       result = themeWidth;
    1:   }
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:   nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:   printf(" %s intrinsic width for container is %d twips.\n",
    1:          aType == MIN_WIDTH ? "min" : "pref", result);
    1: #endif
    1: 
    1:   return result;
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::ComputeWidthDependentValue(
    1:                  nscoord              aContainingBlockWidth,
    1:                  const nsStyleCoord&  aCoord)
    1: {
46369:   NS_WARN_IF_FALSE(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
46369:                    "have unconstrained width; this should only result from "
46369:                    "very large sizes, not attempts at intrinsic width "
46369:                    "calculation");
    1: 
51403:   if (aCoord.IsCoordPercentCalcUnit()) {
51403:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockWidth);
    1:   }
 1363:   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
 1068:                aCoord.GetUnit() == eStyleUnit_Auto,
 1068:                "unexpected width value");
    1:   return 0;
    1: }
    1: 
    1: /* static */ nscoord
 1068: nsLayoutUtils::ComputeWidthValue(
 1068:                  nsIRenderingContext* aRenderingContext,
 1068:                  nsIFrame*            aFrame,
 1068:                  nscoord              aContainingBlockWidth,
 1068:                  nscoord              aContentEdgeToBoxSizing,
 1068:                  nscoord              aBoxSizingToMarginEdge,
 1068:                  const nsStyleCoord&  aCoord)
 1068: {
 1068:   NS_PRECONDITION(aFrame, "non-null frame expected");
 1068:   NS_PRECONDITION(aRenderingContext, "non-null rendering context expected");
34267:   NS_WARN_IF_FALSE(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
34267:                    "have unconstrained width; this should only result from "
34267:                    "very large sizes, not attempts at intrinsic width "
34267:                    "calculation");
 1068:   NS_PRECONDITION(aContainingBlockWidth >= 0,
 1068:                   "width less than zero");
 1068: 
 1068:   nscoord result;
49566:   if (aCoord.IsCoordPercentCalcUnit()) {
49566:     result = nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockWidth);
49566:     // The result of a calc() expression might be less than 0; we
49566:     // should clamp at runtime (below).  (Percentages and coords that
49566:     // are less than 0 have already been dropped by the parser.)
 1068:     result -= aContentEdgeToBoxSizing;
 1068:   } else if (eStyleUnit_Enumerated == aCoord.GetUnit()) {
 1068:     PRInt32 val = aCoord.GetIntValue();
 1068:     switch (val) {
 8046:       case NS_STYLE_WIDTH_MAX_CONTENT:
 1068:         result = aFrame->GetPrefWidth(aRenderingContext);
 1068:         NS_ASSERTION(result >= 0, "width less than zero");
 1068:         break;
 8046:       case NS_STYLE_WIDTH_MIN_CONTENT:
 1068:         result = aFrame->GetMinWidth(aRenderingContext);
 1068:         NS_ASSERTION(result >= 0, "width less than zero");
 1068:         break;
 8046:       case NS_STYLE_WIDTH_FIT_CONTENT:
 1068:         {
 1068:           nscoord pref = aFrame->GetPrefWidth(aRenderingContext),
 1068:                    min = aFrame->GetMinWidth(aRenderingContext),
 1068:                   fill = aContainingBlockWidth -
 1068:                          (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
32531:           result = NS_MAX(min, NS_MIN(pref, fill));
 1068:           NS_ASSERTION(result >= 0, "width less than zero");
 1068:         }
 1068:         break;
 8046:       case NS_STYLE_WIDTH_AVAILABLE:
 1068:         result = aContainingBlockWidth -
 1068:                  (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
 1068:     }
 1068:   } else {
 1068:     NS_NOTREACHED("unexpected width value");
 1068:     result = 0;
 1068:   }
 1068:   if (result < 0)
 1068:     result = 0;
 1068:   return result;
 1068: }
 1068: 
 1068: 
 1068: /* static */ nscoord
    1: nsLayoutUtils::ComputeHeightDependentValue(
    1:                  nscoord              aContainingBlockHeight,
    1:                  const nsStyleCoord&  aCoord)
    1: {
    1:   // XXXldb Some callers explicitly check aContainingBlockHeight
51403:   // against NS_AUTOHEIGHT *and* unit against eStyleUnit_Percent or
51403:   // calc()s containing percents before calling this function.
51403:   // However, it would be much more likely to catch problems without
51403:   // the unit conditions.
    1:   // XXXldb Many callers pass a non-'auto' containing block height when
    1:   // according to CSS2.1 they should be passing 'auto'.
51403:   NS_PRECONDITION(NS_AUTOHEIGHT != aContainingBlockHeight ||
51404:                   !aCoord.HasPercent(),
51403:                   "unexpected containing block height");
51403: 
51403:   if (aCoord.IsCoordPercentCalcUnit()) {
51403:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockHeight);
51403:   }
51403: 
 1363:   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
 1068:                aCoord.GetUnit() == eStyleUnit_Auto,
 1068:                "unexpected height value");
    1:   return 0;
    1: }
    1: 
    1: #define MULDIV(a,b,c) (nscoord(PRInt64(a) * PRInt64(b) / PRInt64(c)))
    1: 
    1: /* static */ nsSize
    1: nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
 8142:                    nsIRenderingContext* aRenderingContext, nsIFrame* aFrame,
 8147:                    const nsIFrame::IntrinsicSize& aIntrinsicSize,
 8142:                    nsSize aIntrinsicRatio, nsSize aCBSize,
 1068:                    nsSize aMargin, nsSize aBorder, nsSize aPadding)
    1: {
    1:   const nsStylePosition *stylePos = aFrame->GetStylePosition();
    1:   // Handle intrinsic sizes and their interaction with
    1:   // {min-,max-,}{width,height} according to the rules in
    1:   // http://www.w3.org/TR/CSS21/visudet.html#min-max-widths
    1: 
    1:   // Note: throughout the following section of the function, I avoid
    1:   // a * (b / c) because of its reduced accuracy relative to a * b / c
    1:   // or (a * b) / c (which are equivalent).
    1: 
 1068:   const PRBool isAutoWidth = stylePos->mWidth.GetUnit() == eStyleUnit_Auto;
 1068:   const PRBool isAutoHeight = IsAutoHeight(stylePos->mHeight, aCBSize.height);
    1: 
    1:   nsSize boxSizingAdjust(0,0);
    1:   switch (stylePos->mBoxSizing) {
    1:     case NS_STYLE_BOX_SIZING_BORDER:
    1:       boxSizingAdjust += aBorder;
    1:       // fall through
    1:     case NS_STYLE_BOX_SIZING_PADDING:
    1:       boxSizingAdjust += aPadding;
    1:   }
 1068:   nscoord boxSizingToMarginEdgeWidth =
 1068:     aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width;
    1: 
    1:   nscoord width, minWidth, maxWidth, height, minHeight, maxHeight;
    1: 
    1:   if (!isAutoWidth) {
 1068:     width = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:               aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:               boxSizingToMarginEdgeWidth, stylePos->mWidth);
 1068:     NS_ASSERTION(width >= 0, "negative result from ComputeWidthValue");
    1:   }
    1: 
 1363:   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_None) {
 1068:     maxWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:                  aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:                  boxSizingToMarginEdgeWidth, stylePos->mMaxWidth);
 1068:     NS_ASSERTION(maxWidth >= 0, "negative result from ComputeWidthValue");
    1:   } else {
    1:     maxWidth = nscoord_MAX;
    1:   }
    1: 
 1068:   minWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:                aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:                boxSizingToMarginEdgeWidth, stylePos->mMinWidth);
 1068:   NS_ASSERTION(minWidth >= 0, "negative result from ComputeWidthValue");
    1: 
    1:   if (!isAutoHeight) {
16031:     height = nsLayoutUtils::
51406:       ComputeHeightValue(aCBSize.height, stylePos->mHeight) -
    1:       boxSizingAdjust.height;
    1:     if (height < 0)
    1:       height = 0;
    1:   }
    1: 
    1:   if (!IsAutoHeight(stylePos->mMaxHeight, aCBSize.height)) {
16031:     maxHeight = nsLayoutUtils::
51406:       ComputeHeightValue(aCBSize.height, stylePos->mMaxHeight) -
    1:       boxSizingAdjust.height;
    1:     if (maxHeight < 0)
    1:       maxHeight = 0;
    1:   } else {
    1:     maxHeight = nscoord_MAX;
    1:   }
    1: 
    1:   if (!IsAutoHeight(stylePos->mMinHeight, aCBSize.height)) {
16031:     minHeight = nsLayoutUtils::
51406:       ComputeHeightValue(aCBSize.height, stylePos->mMinHeight) -
    1:       boxSizingAdjust.height;
    1:     if (minHeight < 0)
    1:       minHeight = 0;
    1:   } else {
    1:     minHeight = 0;
    1:   }
    1: 
 8142:   // Resolve percentage intrinsic width/height as necessary:
 8142: 
 8142:   NS_ASSERTION(aCBSize.width != NS_UNCONSTRAINEDSIZE,
 8142:                "Our containing block must not have unconstrained width!");
 8142: 
 8142:   PRBool hasIntrinsicWidth, hasIntrinsicHeight;
 8142:   nscoord intrinsicWidth, intrinsicHeight;
 8142: 
 8142:   if (aIntrinsicSize.width.GetUnit() == eStyleUnit_Coord ||
 8142:       aIntrinsicSize.width.GetUnit() == eStyleUnit_Percent) {
 8142:     hasIntrinsicWidth = PR_TRUE;
 8142:     intrinsicWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 8142:                            aFrame, aCBSize.width, 0, boxSizingAdjust.width +
 8142:                            boxSizingToMarginEdgeWidth, aIntrinsicSize.width);
 8142:   } else {
 8142:     hasIntrinsicWidth = PR_FALSE;
 8142:     intrinsicWidth = 0;
 8142:   }
 8142: 
 8142:   if (aIntrinsicSize.height.GetUnit() == eStyleUnit_Coord ||
 8142:       (aIntrinsicSize.height.GetUnit() == eStyleUnit_Percent &&
 8142:        aCBSize.height != NS_AUTOHEIGHT)) {
 8142:     hasIntrinsicHeight = PR_TRUE;
16031:     intrinsicHeight = nsLayoutUtils::
16031:       ComputeHeightDependentValue(aCBSize.height, aIntrinsicSize.height);
 8142:     if (intrinsicHeight < 0)
 8142:       intrinsicHeight = 0;
 8142:   } else {
 8142:     hasIntrinsicHeight = PR_FALSE;
 8142:     intrinsicHeight = 0;
 8142:   }
 8142: 
 8142:   NS_ASSERTION(aIntrinsicRatio.width >= 0 && aIntrinsicRatio.height >= 0,
 8142:                "Intrinsic ratio has a negative component!");
 8142: 
 8142:   // Now calculate the used values for width and height:
 8142: 
    1:   if (isAutoWidth) {
    1:     if (isAutoHeight) {
    1: 
    1:       // 'auto' width, 'auto' height
 8142: 
 8142:       // Get tentative values - CSS 2.1 sections 10.3.2 and 10.6.2:
 8142: 
 8142:       nscoord tentWidth, tentHeight;
 8142: 
 8142:       if (hasIntrinsicWidth) {
 8142:         tentWidth = intrinsicWidth;
 8142:       } else if (hasIntrinsicHeight && aIntrinsicRatio.height > 0) {
 8142:         tentWidth = MULDIV(intrinsicHeight, aIntrinsicRatio.width, aIntrinsicRatio.height);
 8142:       } else if (aIntrinsicRatio.width > 0) {
 8142:         tentWidth = aCBSize.width - boxSizingToMarginEdgeWidth; // XXX scrollbar?
 8142:         if (tentWidth < 0) tentWidth = 0;
 8142:       } else {
 8142:         tentWidth = nsPresContext::CSSPixelsToAppUnits(300);
 8142:       }
 8142: 
 8142:       if (hasIntrinsicHeight) {
 8142:         tentHeight = intrinsicHeight;
 8142:       } else if (aIntrinsicRatio.width > 0) {
 8142:         tentHeight = MULDIV(tentWidth, aIntrinsicRatio.height, aIntrinsicRatio.width);
 8142:       } else {
 8142:         tentHeight = nsPresContext::CSSPixelsToAppUnits(150);
 8142:       }
 8142: 
 8142:       // Now apply min/max-width/height - CSS 2.1 sections 10.4 and 10.7:
 8142: 
    1:       if (minWidth > maxWidth)
    1:         maxWidth = minWidth;
    1:       if (minHeight > maxHeight)
    1:         maxHeight = minHeight;
    1: 
    1:       nscoord heightAtMaxWidth, heightAtMinWidth,
    1:               widthAtMaxHeight, widthAtMinHeight;
 8142: 
 8142:       if (tentWidth > 0) {
 8142:         heightAtMaxWidth = MULDIV(maxWidth, tentHeight, tentWidth);
    1:         if (heightAtMaxWidth < minHeight)
    1:           heightAtMaxWidth = minHeight;
 8142:         heightAtMinWidth = MULDIV(minWidth, tentHeight, tentWidth);
    1:         if (heightAtMinWidth > maxHeight)
    1:           heightAtMinWidth = maxHeight;
    1:       } else {
 8142:         heightAtMaxWidth = tentHeight;
 8142:         heightAtMinWidth = tentHeight;
    1:       }
    1: 
 8142:       if (tentHeight > 0) {
 8142:         widthAtMaxHeight = MULDIV(maxHeight, tentWidth, tentHeight);
    1:         if (widthAtMaxHeight < minWidth)
    1:           widthAtMaxHeight = minWidth;
 8142:         widthAtMinHeight = MULDIV(minHeight, tentWidth, tentHeight);
    1:         if (widthAtMinHeight > maxWidth)
    1:           widthAtMinHeight = maxWidth;
    1:       } else {
 8142:         widthAtMaxHeight = tentWidth;
 8142:         widthAtMinHeight = tentWidth;
    1:       }
    1: 
 8142:       // The table at http://www.w3.org/TR/CSS21/visudet.html#min-max-widths :
 8142: 
 8142:       if (tentWidth > maxWidth) {
 8142:         if (tentHeight > maxHeight) {
 8142:           if (PRInt64(maxWidth) * PRInt64(tentHeight) <=
 8142:               PRInt64(maxHeight) * PRInt64(tentWidth)) {
    1:             width = maxWidth;
    1:             height = heightAtMaxWidth;
    1:           } else {
 8142:             width = widthAtMaxHeight;
    1:             height = maxHeight;
    1:           }
    1:         } else {
 8142:           // This also covers "(w > max-width) and (h < min-height)" since in
 8142:           // that case (max-width/w < 1), and with (h < min-height):
 8142:           //   max(max-width * h/w, min-height) == min-height
    1:           width = maxWidth;
    1:           height = heightAtMaxWidth;
    1:         }
 8142:       } else if (tentWidth < minWidth) {
 8142:         if (tentHeight < minHeight) {
 8142:           if (PRInt64(minWidth) * PRInt64(tentHeight) <=
 8142:               PRInt64(minHeight) * PRInt64(tentWidth)) {
 8142:             width = widthAtMinHeight;
    1:             height = minHeight;
    1:           } else {
    1:             width = minWidth;
    1:             height = heightAtMinWidth;
    1:           }
    1:         } else {
 8142:           // This also covers "(w < min-width) and (h > max-height)" since in
 8142:           // that case (min-width/w > 1), and with (h > max-height):
 8142:           //   min(min-width * h/w, max-height) == max-height
    1:           width = minWidth;
    1:           height = heightAtMinWidth;
    1:         }
    1:       } else {
 8142:         if (tentHeight > maxHeight) {
 8142:           width = widthAtMaxHeight;
    1:           height = maxHeight;
 8142:         } else if (tentHeight < minHeight) {
 8142:           width = widthAtMinHeight;
    1:           height = minHeight;
    1:         } else {
 8142:           width = tentWidth;
 8142:           height = tentHeight;
    1:         }
    1:       }
    1: 
    1:     } else {
    1: 
    1:       // 'auto' width, non-'auto' height
    1:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
 8142:       if (aIntrinsicRatio.height > 0) {
 8142:         width = MULDIV(height, aIntrinsicRatio.width, aIntrinsicRatio.height);
 8142:       } else if (hasIntrinsicWidth) {
 8142:         width = intrinsicWidth;
    1:       } else {
 8142:         width = nsPresContext::CSSPixelsToAppUnits(300);
    1:       }
    1:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
    1: 
    1:     }
    1:   } else {
    1:     if (isAutoHeight) {
    1: 
    1:       // non-'auto' width, 'auto' height
    1:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
 8142:       if (aIntrinsicRatio.width > 0) {
 8142:         height = MULDIV(width, aIntrinsicRatio.height, aIntrinsicRatio.width);
 8142:       } else if (hasIntrinsicHeight) {
 8142:         height = intrinsicHeight;
    1:       } else {
 8142:         height = nsPresContext::CSSPixelsToAppUnits(150);
    1:       }
    1:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
    1: 
    1:     } else {
    1: 
    1:       // non-'auto' width, non-'auto' height
 8142:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
    1:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
    1: 
    1:     }
    1:   }
    1: 
    1:   return nsSize(width, height);
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::MinWidthFromInline(nsIFrame* aFrame,
    1:                                   nsIRenderingContext* aRenderingContext)
    1: {
    1:   nsIFrame::InlineMinWidthData data;
    1:   DISPLAY_MIN_WIDTH(aFrame, data.prevLines);
    1:   aFrame->AddInlineMinWidth(aRenderingContext, &data);
 2668:   data.ForceBreak(aRenderingContext);
    1:   return data.prevLines;
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::PrefWidthFromInline(nsIFrame* aFrame,
    1:                                    nsIRenderingContext* aRenderingContext)
    1: {
    1:   nsIFrame::InlinePrefWidthData data;
    1:   DISPLAY_PREF_WIDTH(aFrame, data.prevLines);
    1:   aFrame->AddInlinePrefWidth(aRenderingContext, &data);
 2668:   data.ForceBreak(aRenderingContext);
    1:   return data.prevLines;
    1: }
    1: 
    1: void
    1: nsLayoutUtils::DrawString(const nsIFrame*      aFrame,
    1:                           nsIRenderingContext* aContext,
    1:                           const PRUnichar*     aString,
    1:                           PRInt32              aLength,
24995:                           nsPoint              aPoint,
24995:                           PRUint8              aDirection)
    1: {
    1: #ifdef IBMBIDI
    1:   nsresult rv = NS_ERROR_FAILURE;
  238:   nsPresContext* presContext = aFrame->PresContext();
    1:   if (presContext->BidiEnabled()) {
    1:     nsBidiPresUtils* bidiUtils = presContext->GetBidiUtils();
    1: 
    1:     if (bidiUtils) {
24995:       if (aDirection == NS_STYLE_DIRECTION_INHERIT) {
24995:         aDirection = aFrame->GetStyleVisibility()->mDirection;
24995:       }
    1:       nsBidiDirection direction =
24995:         (NS_STYLE_DIRECTION_RTL == aDirection) ?
    1:         NSBIDI_RTL : NSBIDI_LTR;
    1:       rv = bidiUtils->RenderText(aString, aLength, direction,
60677:                                  presContext, *aContext, *aContext,
    1:                                  aPoint.x, aPoint.y);
    1:     }
    1:   }
    1:   if (NS_FAILED(rv))
    1: #endif // IBMBIDI
    1:   {
    1:     aContext->SetTextRunRTL(PR_FALSE);
    1:     aContext->DrawString(aString, aLength, aPoint.x, aPoint.y);
    1:   }
    1: }
    1: 
    1: nscoord
    1: nsLayoutUtils::GetStringWidth(const nsIFrame*      aFrame,
    1:                               nsIRenderingContext* aContext,
    1:                               const PRUnichar*     aString,
    1:                               PRInt32              aLength)
    1: {
    1: #ifdef IBMBIDI
  238:   nsPresContext* presContext = aFrame->PresContext();
    1:   if (presContext->BidiEnabled()) {
    1:     nsBidiPresUtils* bidiUtils = presContext->GetBidiUtils();
    1: 
    1:     if (bidiUtils) {
    1:       const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
    1:       nsBidiDirection direction =
    1:         (NS_STYLE_DIRECTION_RTL == vis->mDirection) ?
    1:         NSBIDI_RTL : NSBIDI_LTR;
    1:       return bidiUtils->MeasureTextWidth(aString, aLength,
    1:                                          direction, presContext, *aContext);
    1:     }
    1:   }
    1: #endif // IBMBIDI
    1:   aContext->SetTextRunRTL(PR_FALSE);
    1:   nscoord width;
    1:   aContext->GetWidth(aString, aLength, width);
    1:   return width;
    1: }
    1: 
28519: /* static */ nscoord
28519: nsLayoutUtils::GetCenteredFontBaseline(nsIFontMetrics* aFontMetrics,
28519:                                        nscoord         aLineHeight)
28519: {
28519:   nscoord fontAscent, fontHeight;
28519:   aFontMetrics->GetMaxAscent(fontAscent);
28519:   aFontMetrics->GetHeight(fontHeight);
28519: 
28519:   nscoord leading = aLineHeight - fontHeight;
28519:   return fontAscent + leading/2;
28519: }
28519: 
28519: 
    1: /* static */ PRBool
    1: nsLayoutUtils::GetFirstLineBaseline(const nsIFrame* aFrame, nscoord* aResult)
    1: {
27100:   LinePosition position;
27100:   if (!GetFirstLinePosition(aFrame, &position))
27100:     return PR_FALSE;
27100:   *aResult = position.mBaseline;
27100:   return PR_TRUE;
27100: }
27100: 
27100: /* static */ PRBool
27100: nsLayoutUtils::GetFirstLinePosition(const nsIFrame* aFrame,
27100:                                     LinePosition* aResult)
27100: {
15909:   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
15909:   if (!block) {
    1:     // For the first-line baseline we also have to check for a table, and if
    1:     // so, use the baseline of its first row.
    1:     nsIAtom* fType = aFrame->GetType();
    1:     if (fType == nsGkAtoms::tableOuterFrame) {
27100:       aResult->mTop = 0;
27100:       aResult->mBaseline = aFrame->GetBaseline();
27100:       // This is what we want for the list bullet caller; not sure if
27100:       // other future callers will want the same.
27100:       aResult->mBottom = aFrame->GetSize().height;
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     // For first-line baselines, we have to consider scroll frames.
    1:     if (fType == nsGkAtoms::scrollFrame) {
23554:       nsIScrollableFrame *sFrame = do_QueryFrame(const_cast<nsIFrame*>(aFrame));
23554:       if (!sFrame) {
    1:         NS_NOTREACHED("not scroll frame");
    1:       }
27100:       LinePosition kidPosition;
27100:       if (GetFirstLinePosition(sFrame->GetScrolledFrame(), &kidPosition)) {
    1:         // Consider only the border and padding that contributes to the
    1:         // kid's position, not the scrolling, so we get the initial
    1:         // position.
27100:         *aResult = kidPosition + aFrame->GetUsedBorderAndPadding().top;
    1:         return PR_TRUE;
    1:       }
    1:       return PR_FALSE;
    1:     }
    1: 
48894:     if (fType == nsGkAtoms::fieldSetFrame) {
48894:       LinePosition kidPosition;
48894:       nsIFrame* kid = aFrame->GetFirstChild(nsnull);
48894:       // kid might be a legend frame here, but that's ok.
48894:       if (GetFirstLinePosition(kid, &kidPosition)) {
48894:         *aResult = kidPosition + kid->GetPosition().y;
48894:         return PR_TRUE;
48894:       }
48894:       return PR_FALSE;
48894:     }
48894: 
    1:     // No baseline.
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   for (nsBlockFrame::const_line_iterator line = block->begin_lines(),
    1:                                      line_end = block->end_lines();
    1:        line != line_end; ++line) {
    1:     if (line->IsBlock()) {
    1:       nsIFrame *kid = line->mFirstChild;
27100:       LinePosition kidPosition;
27100:       if (GetFirstLinePosition(kid, &kidPosition)) {
27100:         *aResult = kidPosition + kid->GetPosition().y;
    1:         return PR_TRUE;
    1:       }
    1:     } else {
    1:       // XXX Is this the right test?  We have some bogus empty lines
    1:       // floating around, but IsEmpty is perhaps too weak.
    1:       if (line->GetHeight() != 0 || !line->IsEmpty()) {
27100:         nscoord top = line->mBounds.y;
27100:         aResult->mTop = top;
27100:         aResult->mBaseline = top + line->GetAscent();
27100:         aResult->mBottom = top + line->GetHeight();
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: /* static */ PRBool
    1: nsLayoutUtils::GetLastLineBaseline(const nsIFrame* aFrame, nscoord* aResult)
    1: {
15909:   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
15909:   if (!block)
    1:     // No baseline.  (We intentionally don't descend into scroll frames.)
    1:     return PR_FALSE;
    1: 
    1:   for (nsBlockFrame::const_reverse_line_iterator line = block->rbegin_lines(),
    1:                                              line_end = block->rend_lines();
    1:        line != line_end; ++line) {
    1:     if (line->IsBlock()) {
    1:       nsIFrame *kid = line->mFirstChild;
    1:       nscoord kidBaseline;
    1:       if (GetLastLineBaseline(kid, &kidBaseline)) {
    1:         *aResult = kidBaseline + kid->GetPosition().y;
    1:         return PR_TRUE;
    1:       } else if (kid->GetType() == nsGkAtoms::scrollFrame) {
    1:         // Use the bottom of the scroll frame.
    1:         // XXX CSS2.1 really doesn't say what to do here.
    1:         *aResult = kid->GetRect().YMost();
    1:         return PR_TRUE;
    1:       }
    1:     } else {
    1:       // XXX Is this the right test?  We have some bogus empty lines
    1:       // floating around, but IsEmpty is perhaps too weak.
    1:       if (line->GetHeight() != 0 || !line->IsEmpty()) {
    1:         *aResult = line->mBounds.y + line->GetAscent();
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
14460: static nscoord
14460: CalculateBlockContentBottom(nsBlockFrame* aFrame)
14460: {
14460:   NS_PRECONDITION(aFrame, "null ptr");
14460: 
14460:   nscoord contentBottom = 0;
14460: 
14460:   for (nsBlockFrame::line_iterator line = aFrame->begin_lines(),
14460:                                    line_end = aFrame->end_lines();
14460:        line != line_end; ++line) {
14460:     if (line->IsBlock()) {
14460:       nsIFrame* child = line->mFirstChild;
14460:       nscoord offset = child->GetRect().y - child->GetRelativeOffset().y;
31760:       contentBottom = NS_MAX(contentBottom,
14460:                         nsLayoutUtils::CalculateContentBottom(child) + offset);
14460:     }
14460:     else {
31760:       contentBottom = NS_MAX(contentBottom, line->mBounds.YMost());
14460:     }
14460:   }
14460:   return contentBottom;
14460: }
14460: 
14460: /* static */ nscoord
14460: nsLayoutUtils::CalculateContentBottom(nsIFrame* aFrame)
14460: {
14460:   NS_PRECONDITION(aFrame, "null ptr");
14460: 
14460:   nscoord contentBottom = aFrame->GetRect().height;
14460: 
55040:   // We want scrollable overflow rather than visual because this
55040:   // calculation is intended to affect layout.
55040:   if (aFrame->GetScrollableOverflowRect().height > contentBottom) {
14460:     nsBlockFrame* blockFrame = GetAsBlock(aFrame);
14460:     nsIAtom* childList = nsnull;
14460:     PRIntn nextListID = 0;
14460:     do {
14460:       if (childList == nsnull && blockFrame) {
31760:         contentBottom = NS_MAX(contentBottom, CalculateBlockContentBottom(blockFrame));
14460:       }
14460:       else if (childList != nsGkAtoms::overflowList &&
14460:                childList != nsGkAtoms::excessOverflowContainersList &&
14460:                childList != nsGkAtoms::overflowOutOfFlowList)
14460:       {
14460:         for (nsIFrame* child = aFrame->GetFirstChild(childList);
14460:             child; child = child->GetNextSibling())
14460:         {
14460:           nscoord offset = child->GetRect().y - child->GetRelativeOffset().y;
31760:           contentBottom = NS_MAX(contentBottom,
14460:                                  CalculateContentBottom(child) + offset);
14460:         }
14460:       }
14460: 
14460:       childList = aFrame->GetAdditionalChildListName(nextListID);
14460:       nextListID++;
14460:     } while (childList);
14460:   }
14460: 
14460:   return contentBottom;
14460: }
14460: 
    1: /* static */ nsIFrame*
    1: nsLayoutUtils::GetClosestLayer(nsIFrame* aFrame)
    1: {
    1:   nsIFrame* layer;
    1:   for (layer = aFrame; layer; layer = layer->GetParent()) {
    1:     if (layer->GetStyleDisplay()->IsPositioned() ||
    1:         (layer->GetParent() &&
    1:           layer->GetParent()->GetType() == nsGkAtoms::scrollFrame))
    1:       break;
    1:   }
    1:   if (layer)
    1:     return layer;
  238:   return aFrame->PresContext()->PresShell()->FrameManager()->GetRootFrame();
    1: }
    1: 
55321: GraphicsFilter
27185: nsLayoutUtils::GetGraphicsFilterForFrame(nsIFrame* aForFrame)
26926: {
43454: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
55321:   GraphicsFilter defaultFilter = gfxPattern::FILTER_NEAREST;
43454: #else
55321:   GraphicsFilter defaultFilter = gfxPattern::FILTER_GOOD;
43454: #endif
26926: #ifdef MOZ_SVG
27185:   nsIFrame *frame = nsCSSRendering::IsCanvasFrame(aForFrame) ?
35300:     nsCSSRendering::FindBackgroundStyleFrame(aForFrame) : aForFrame;
27185: 
27185:   switch (frame->GetStyleSVG()->mImageRendering) {
26926:   case NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED:
26926:     return gfxPattern::FILTER_FAST;
26926:   case NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY:
26926:     return gfxPattern::FILTER_BEST;
26926:   case NS_STYLE_IMAGE_RENDERING_CRISPEDGES:
26926:     return gfxPattern::FILTER_NEAREST;
26926:   default:
43454:     return defaultFilter;
26926:   }
26926: #else
43454:   return defaultFilter;
26926: #endif
26926: }
26926: 
21752: /**
21752:  * Given an image being drawn into an appunit coordinate system, and
21752:  * a point in that coordinate system, map the point back into image
21752:  * pixel space.
21752:  * @param aSize the size of the image, in pixels
21752:  * @param aDest the rectangle that the image is being mapped into
21752:  * @param aPt a point in the same coordinate system as the rectangle
21752:  */
21323: static gfxPoint
22196: MapToFloatImagePixels(const gfxSize& aSize,
22196:                       const gfxRect& aDest, const gfxPoint& aPt)
21323: {
22196:   return gfxPoint(((aPt.x - aDest.pos.x)*aSize.width)/aDest.size.width,
22196:                   ((aPt.y - aDest.pos.y)*aSize.height)/aDest.size.height);
21323: }
21323: 
21752: /**
21752:  * Given an image being drawn into an pixel-based coordinate system, and
21752:  * a point in image space, map the point into the pixel-based coordinate
21752:  * system.
21752:  * @param aSize the size of the image, in pixels
21752:  * @param aDest the rectangle that the image is being mapped into
21752:  * @param aPt a point in image space
21752:  */
21752: static gfxPoint
22196: MapToFloatUserPixels(const gfxSize& aSize,
21752:                      const gfxRect& aDest, const gfxPoint& aPt)
21752: {
21752:   return gfxPoint(aPt.x*aDest.size.width/aSize.width + aDest.pos.x,
21752:                   aPt.y*aDest.size.height/aSize.height + aDest.pos.y);
21752: }
21752: 
52135: /* static */ gfxRect
52135: nsLayoutUtils::RectToGfxRect(const nsRect& aRect, PRInt32 aAppUnitsPerDevPixel)
46989: {
46989:   return gfxRect(gfxFloat(aRect.x) / aAppUnitsPerDevPixel,
46989:                  gfxFloat(aRect.y) / aAppUnitsPerDevPixel,
46989:                  gfxFloat(aRect.width) / aAppUnitsPerDevPixel,
46989:                  gfxFloat(aRect.height) / aAppUnitsPerDevPixel);
46989: }
46989: 
46989: struct SnappedImageDrawingParameters {
46989:   // A transform from either device space or user space (depending on mResetCTM)
46989:   // to image space
46989:   gfxMatrix mUserSpaceToImageSpace;
46989:   // A device-space, pixel-aligned rectangle to fill
46989:   gfxRect mFillRect;
46989:   // A pixel rectangle in tiled image space outside of which gfx should not
46989:   // sample (using EXTEND_PAD as necessary)
46989:   nsIntRect mSubimage;
46989:   // Whether there's anything to draw at all
46989:   PRPackedBool mShouldDraw;
46989:   // PR_TRUE iff the CTM of the rendering context needs to be reset to the
46989:   // identity matrix before drawing
46989:   PRPackedBool mResetCTM;
46989: 
46989:   SnappedImageDrawingParameters()
46989:    : mShouldDraw(PR_FALSE)
46989:    , mResetCTM(PR_FALSE)
46989:   {}
46989: 
46989:   SnappedImageDrawingParameters(const gfxMatrix& aUserSpaceToImageSpace,
46989:                                 const gfxRect&   aFillRect,
46989:                                 const nsIntRect& aSubimage,
46989:                                 PRBool           aResetCTM)
46989:    : mUserSpaceToImageSpace(aUserSpaceToImageSpace)
46989:    , mFillRect(aFillRect)
46989:    , mSubimage(aSubimage)
46989:    , mShouldDraw(PR_TRUE)
46989:    , mResetCTM(aResetCTM)
46989:   {}
46989: };
46989: 
46989: /**
46989:  * Given a set of input parameters, compute certain output parameters
46989:  * for drawing an image with the image snapping algorithm.
46989:  * See https://wiki.mozilla.org/Gecko:Image_Snapping_and_Rendering
46989:  *
46989:  *  @see nsLayoutUtils::DrawImage() for the descriptions of input parameters
46989:  */
46989: static SnappedImageDrawingParameters
46989: ComputeSnappedImageDrawingParameters(gfxContext*     aCtx,
46989:                                      PRInt32         aAppUnitsPerDevPixel,
46989:                                      const nsRect    aDest,
46989:                                      const nsRect    aFill,
46989:                                      const nsPoint   aAnchor,
46989:                                      const nsRect    aDirty,
46989:                                      const nsIntSize aImageSize)
46989: 
46989: {
46989:   if (aDest.IsEmpty() || aFill.IsEmpty())
46989:     return SnappedImageDrawingParameters();
46989: 
52135:   gfxRect devPixelDest =
52135:     nsLayoutUtils::RectToGfxRect(aDest, aAppUnitsPerDevPixel);
52135:   gfxRect devPixelFill =
52135:     nsLayoutUtils::RectToGfxRect(aFill, aAppUnitsPerDevPixel);
52135:   gfxRect devPixelDirty =
52135:     nsLayoutUtils::RectToGfxRect(aDirty, aAppUnitsPerDevPixel);
46989: 
46989:   PRBool ignoreScale = PR_FALSE;
46989: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
46989:   ignoreScale = PR_TRUE;
46989: #endif
46989:   gfxRect fill = devPixelFill;
46989:   PRBool didSnap = aCtx->UserToDevicePixelSnapped(fill, ignoreScale);
46989: 
46989:   gfxSize imageSize(aImageSize.width, aImageSize.height);
46989: 
46989:   // Compute the set of pixels that would be sampled by an ideal rendering
46989:   gfxPoint subimageTopLeft =
46989:     MapToFloatImagePixels(imageSize, devPixelDest, devPixelFill.TopLeft());
46989:   gfxPoint subimageBottomRight =
46989:     MapToFloatImagePixels(imageSize, devPixelDest, devPixelFill.BottomRight());
46989:   nsIntRect intSubimage;
46989:   intSubimage.MoveTo(NSToIntFloor(subimageTopLeft.x),
46989:                      NSToIntFloor(subimageTopLeft.y));
46989:   intSubimage.SizeTo(NSToIntCeil(subimageBottomRight.x) - intSubimage.x,
46989:                      NSToIntCeil(subimageBottomRight.y) - intSubimage.y);
46989: 
46989:   // Compute the anchor point and compute final fill rect.
46989:   // This code assumes that pixel-based devices have one pixel per
46989:   // device unit!
46989:   gfxPoint anchorPoint(gfxFloat(aAnchor.x)/aAppUnitsPerDevPixel,
46989:                        gfxFloat(aAnchor.y)/aAppUnitsPerDevPixel);
46989:   gfxPoint imageSpaceAnchorPoint =
46989:     MapToFloatImagePixels(imageSize, devPixelDest, anchorPoint);
46989:   gfxMatrix currentMatrix = aCtx->CurrentMatrix();
46989: 
46989:   if (didSnap) {
46989:     NS_ASSERTION(!currentMatrix.HasNonAxisAlignedTransform(),
46989:                  "How did we snap, then?");
46989:     imageSpaceAnchorPoint.Round();
46989:     anchorPoint = imageSpaceAnchorPoint;
46989:     anchorPoint = MapToFloatUserPixels(imageSize, devPixelDest, anchorPoint);
46989:     anchorPoint = currentMatrix.Transform(anchorPoint);
46989:     anchorPoint.Round();
46989: 
46989:     // This form of Transform is safe to call since non-axis-aligned
46989:     // transforms wouldn't be snapped.
46989:     devPixelDirty = currentMatrix.Transform(devPixelDirty);
46989:   }
46989: 
46989:   gfxFloat scaleX = imageSize.width*aAppUnitsPerDevPixel/aDest.width;
46989:   gfxFloat scaleY = imageSize.height*aAppUnitsPerDevPixel/aDest.height;
46989:   if (didSnap) {
46989:     // We'll reset aCTX to the identity matrix before drawing, so we need to
46989:     // adjust our scales to match.
46989:     scaleX /= currentMatrix.xx;
46989:     scaleY /= currentMatrix.yy;
46989:   }
46989:   gfxFloat translateX = imageSpaceAnchorPoint.x - anchorPoint.x*scaleX;
46989:   gfxFloat translateY = imageSpaceAnchorPoint.y - anchorPoint.y*scaleY;
46989:   gfxMatrix transform(scaleX, 0, 0, scaleY, translateX, translateY);
46989: 
46989:   gfxRect finalFillRect = fill;
46989:   // If the user-space-to-image-space transform is not a straight
46989:   // translation by integers, then filtering will occur, and
46989:   // restricting the fill rect to the dirty rect would change the values
46989:   // computed for edge pixels, which we can't allow.
46989:   // Also, if didSnap is false then rounding out 'devPixelDirty' might not
46989:   // produce pixel-aligned coordinates, which would also break the values
46989:   // computed for edge pixels.
46989:   if (didSnap && !transform.HasNonIntegerTranslation()) {
46989:     devPixelDirty.RoundOut();
46989:     finalFillRect = fill.Intersect(devPixelDirty);
46989:   }
46989:   if (finalFillRect.IsEmpty())
46989:     return SnappedImageDrawingParameters();
46989: 
46989:   return SnappedImageDrawingParameters(transform, finalFillRect, intSubimage,
46989:                                        didSnap);
46989: }
46989: 
46989: 
24452: static nsresult
24452: DrawImageInternal(nsIRenderingContext* aRenderingContext,
30479:                   imgIContainer*       aImage,
55321:                   GraphicsFilter       aGraphicsFilter,
21323:                   const nsRect&        aDest,
21323:                   const nsRect&        aFill,
21323:                   const nsPoint&       aAnchor,
24452:                   const nsRect&        aDirty,
32424:                   const nsIntSize&     aImageSize,
32424:                   PRUint32             aImageFlags)
    1: {
21323:   nsCOMPtr<nsIDeviceContext> dc;
21323:   aRenderingContext->GetDeviceContext(*getter_AddRefs(dc));
46989:   PRInt32 appUnitsPerDevPixel = dc->AppUnitsPerDevPixel();
21323:   gfxContext* ctx = aRenderingContext->ThebesContext();
21323: 
46989:   SnappedImageDrawingParameters drawingParams =
46989:     ComputeSnappedImageDrawingParameters(ctx, appUnitsPerDevPixel, aDest, aFill,
46989:                                          aAnchor, aDirty, aImageSize);
46989: 
46989:   if (!drawingParams.mShouldDraw)
46989:     return NS_OK;
46989: 
22177:   gfxContextMatrixAutoSaveRestore saveMatrix(ctx);
46989:   if (drawingParams.mResetCTM) {
21323:     ctx->IdentityMatrix();
    1:   }
21323: 
46989:   aImage->Draw(ctx, aGraphicsFilter, drawingParams.mUserSpaceToImageSpace,
52215:                drawingParams.mFillRect, drawingParams.mSubimage, aImageSize,
52215:                aImageFlags);
24452:   return NS_OK;
24452: }
24452: 
50420: /* static */ void
50420: nsLayoutUtils::DrawPixelSnapped(nsIRenderingContext* aRenderingContext,
50420:                                 gfxDrawable*         aDrawable,
55321:                                 GraphicsFilter       aFilter,
50420:                                 const nsRect&        aDest,
50420:                                 const nsRect&        aFill,
50420:                                 const nsPoint&       aAnchor,
50420:                                 const nsRect&        aDirty)
50420: {
50420:   nsCOMPtr<nsIDeviceContext> dc;
50420:   aRenderingContext->GetDeviceContext(*getter_AddRefs(dc));
50420:   PRInt32 appUnitsPerDevPixel = dc->AppUnitsPerDevPixel();
50420:   gfxContext* ctx = aRenderingContext->ThebesContext();
50420:   gfxIntSize drawableSize = aDrawable->Size();
50420:   nsIntSize imageSize(drawableSize.width, drawableSize.height);
50420: 
50420:   SnappedImageDrawingParameters drawingParams =
50420:     ComputeSnappedImageDrawingParameters(ctx, appUnitsPerDevPixel, aDest, aFill,
50420:                                          aAnchor, aDirty, imageSize);
50420: 
50420:   if (!drawingParams.mShouldDraw)
50420:     return;
50420: 
50420:   gfxContextMatrixAutoSaveRestore saveMatrix(ctx);
50420:   if (drawingParams.mResetCTM) {
50420:     ctx->IdentityMatrix();
50420:   }
50420: 
50420:   gfxRect sourceRect =
50420:     drawingParams.mUserSpaceToImageSpace.Transform(drawingParams.mFillRect);
50420:   gfxRect imageRect(0, 0, imageSize.width, imageSize.height);
50420:   gfxRect subimage(drawingParams.mSubimage.x, drawingParams.mSubimage.y,
50420:                    drawingParams.mSubimage.width, drawingParams.mSubimage.height);
50420: 
50420:   NS_ASSERTION(!sourceRect.Intersect(subimage).IsEmpty(),
50420:                "We must be allowed to sample *some* source pixels!");
50420: 
50420:   gfxUtils::DrawPixelSnapped(ctx, aDrawable,
50420:                              drawingParams.mUserSpaceToImageSpace, subimage,
50420:                              sourceRect, imageRect, drawingParams.mFillRect,
50420:                              gfxASurface::ImageFormatARGB32, aFilter);
50420: }
50420: 
30759: /* static */ nsresult
30759: nsLayoutUtils::DrawSingleUnscaledImage(nsIRenderingContext* aRenderingContext,
30479:                                        imgIContainer*       aImage,
55322:                                        GraphicsFilter       aGraphicsFilter,
24452:                                        const nsPoint&       aDest,
55322:                                        const nsRect*        aDirty,
32424:                                        PRUint32             aImageFlags,
30759:                                        const nsRect*        aSourceArea)
24452: {
30759:   nsIntSize imageSize;
30759:   aImage->GetWidth(&imageSize.width);
30759:   aImage->GetHeight(&imageSize.height);
30759:   NS_ENSURE_TRUE(imageSize.width > 0 && imageSize.height > 0, NS_ERROR_FAILURE);
24452: 
24452:   nscoord appUnitsPerCSSPixel = nsIDeviceContext::AppUnitsPerCSSPixel();
30759:   nsSize size(imageSize.width*appUnitsPerCSSPixel,
30759:               imageSize.height*appUnitsPerCSSPixel);
24452: 
24452:   nsRect source;
24452:   if (aSourceArea) {
24452:     source = *aSourceArea;
24452:   } else {
24452:     source.SizeTo(size);
24452:   }
24452: 
24452:   nsRect dest(aDest - source.TopLeft(), size);
24452:   nsRect fill(aDest, source.Size());
24452:   // Ensure that only a single image tile is drawn. If aSourceArea extends
24452:   // outside the image bounds, we want to honor the aSourceArea-to-aDest
24452:   // translation but we don't want to actually tile the image.
24452:   fill.IntersectRect(fill, dest);
55322:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
55322:                            dest, fill, aDest, aDirty ? *aDirty : dest,
55322:                            imageSize, aImageFlags);
30759: }
30759: 
30759: /* static */ nsresult
30759: nsLayoutUtils::DrawSingleImage(nsIRenderingContext* aRenderingContext,
30479:                                imgIContainer*       aImage,
55321:                                GraphicsFilter       aGraphicsFilter,
24452:                                const nsRect&        aDest,
24452:                                const nsRect&        aDirty,
32424:                                PRUint32             aImageFlags,
30759:                                const nsRect*        aSourceArea)
24452: {
30759:   nsIntSize imageSize;
52215:   if (aImage->GetType() == imgIContainer::TYPE_VECTOR) {
52215:     imageSize.width  = nsPresContext::AppUnitsToIntCSSPixels(aDest.width);
52215:     imageSize.height = nsPresContext::AppUnitsToIntCSSPixels(aDest.height);
52215:   } else {
30759:     aImage->GetWidth(&imageSize.width);
30759:     aImage->GetHeight(&imageSize.height);
52215:   }
30759:   NS_ENSURE_TRUE(imageSize.width > 0 && imageSize.height > 0, NS_ERROR_FAILURE);
24452: 
24452:   nsRect source;
24452:   if (aSourceArea) {
24452:     source = *aSourceArea;
24452:   } else {
24452:     nscoord appUnitsPerCSSPixel = nsIDeviceContext::AppUnitsPerCSSPixel();
30759:     source.SizeTo(imageSize.width*appUnitsPerCSSPixel,
30759:                   imageSize.height*appUnitsPerCSSPixel);
30759:   }
30759: 
30759:   nsRect dest = nsLayoutUtils::GetWholeImageDestination(imageSize, source,
24452:                                                         aDest);
24452:   // Ensure that only a single image tile is drawn. If aSourceArea extends
24452:   // outside the image bounds, we want to honor the aSourceArea-to-aDest
24452:   // transform but we don't want to actually tile the image.
24452:   nsRect fill;
24452:   fill.IntersectRect(aDest, dest);
26926:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter, dest, fill,
32424:                            fill.TopLeft(), aDirty, imageSize, aImageFlags);
30759: }
24452: 
52215: /* static */ void
52215: nsLayoutUtils::ComputeSizeForDrawing(imgIContainer *aImage,
52215:                                      nsIntSize&     aImageSize, /*outparam*/
52215:                                      PRBool&        aGotWidth,  /*outparam*/
52215:                                      PRBool&        aGotHeight  /*outparam*/)
52215: {
52215:   aGotWidth  = NS_SUCCEEDED(aImage->GetWidth(&aImageSize.width));
52215:   aGotHeight = NS_SUCCEEDED(aImage->GetHeight(&aImageSize.height));
52215: 
52215:   if ((aGotWidth && aGotHeight) ||    // Trivial success!
52215:       (!aGotWidth && !aGotHeight)) {  // Trivial failure!
52215:     return;
52215:   }
52215: 
52215:   // If we get here, we succeeded at querying *either* the width *or* the
52215:   // height, but not both.
52215:   NS_ASSERTION(aImage->GetType() == imgIContainer::TYPE_VECTOR,
52215:                "GetWidth and GetHeight should only fail for vector images");
52215: 
52215:   nsIFrame* rootFrame = aImage->GetRootLayoutFrame();
52215:   NS_ASSERTION(rootFrame,
52215:                "We should have a VectorImage, which should have a rootFrame");
52215: 
52215:   // This falls back on failure, if we somehow end up without a rootFrame.
52215:   nsSize ratio = rootFrame ? rootFrame->GetIntrinsicRatio() : nsSize(0,0);
52215:   if (!aGotWidth) { // Have height, missing width
52215:     if (ratio.height != 0) { // don't divide by zero
52215:       aImageSize.width = NSToCoordRound(aImageSize.height *
52215:                                         float(ratio.width) /
52215:                                         float(ratio.height));
52215:       aGotWidth = PR_TRUE;
52215:     }
52215:   } else { // Have width, missing height
52215:     if (ratio.width != 0) { // don't divide by zero
52215:       aImageSize.height = NSToCoordRound(aImageSize.width *
52215:                                          float(ratio.height) /
52215:                                          float(ratio.width));
52215:       aGotHeight = PR_TRUE;
52215:     }
52215:   }
52215: }
52215: 
52215: 
24452: /* static */ nsresult
24452: nsLayoutUtils::DrawImage(nsIRenderingContext* aRenderingContext,
24452:                          imgIContainer*       aImage,
55321:                          GraphicsFilter       aGraphicsFilter,
24452:                          const nsRect&        aDest,
24452:                          const nsRect&        aFill,
24452:                          const nsPoint&       aAnchor,
32424:                          const nsRect&        aDirty,
32424:                          PRUint32             aImageFlags)
24452: {
24452:   nsIntSize imageSize;
52215:   PRBool gotHeight, gotWidth;
52215:   ComputeSizeForDrawing(aImage, imageSize, gotWidth, gotHeight);
52215: 
52215:   // fallback size based on aFill.
52215:   if (!gotWidth) {
52215:     imageSize.width = nsPresContext::AppUnitsToIntCSSPixels(aFill.width);
52215:   }
52215:   if (!gotHeight) {
52215:     imageSize.height = nsPresContext::AppUnitsToIntCSSPixels(aFill.height);
52215:   }
24452: 
26926:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
24452:                            aDest, aFill, aAnchor, aDirty,
32424:                            imageSize, aImageFlags);
    1: }
    1: 
21323: /* static */ nsRect
21323: nsLayoutUtils::GetWholeImageDestination(const nsIntSize& aWholeImageSize,
21323:                                         const nsRect& aImageSourceArea,
21323:                                         const nsRect& aDestArea)
21323: {
21323:   double scaleX = double(aDestArea.width)/aImageSourceArea.width;
21323:   double scaleY = double(aDestArea.height)/aImageSourceArea.height;
21323:   nscoord destOffsetX = NSToCoordRound(aImageSourceArea.x*scaleX);
21323:   nscoord destOffsetY = NSToCoordRound(aImageSourceArea.y*scaleY);
21323:   nscoord appUnitsPerCSSPixel = nsIDeviceContext::AppUnitsPerCSSPixel();
21323:   nscoord wholeSizeX = NSToCoordRound(aWholeImageSize.width*appUnitsPerCSSPixel*scaleX);
21323:   nscoord wholeSizeY = NSToCoordRound(aWholeImageSize.height*appUnitsPerCSSPixel*scaleY);
21323:   return nsRect(aDestArea.TopLeft() - nsPoint(destOffsetX, destOffsetY),
21323:                 nsSize(wholeSizeX, wholeSizeY));
    1: }
 1105: 
 1105: void
 1105: nsLayoutUtils::SetFontFromStyle(nsIRenderingContext* aRC, nsStyleContext* aSC)
 1105: {
 1105:   const nsStyleFont* font = aSC->GetStyleFont();
 1105:   const nsStyleVisibility* visibility = aSC->GetStyleVisibility();
 1105: 
38492:   aRC->SetFont(font->mFont, visibility->mLanguage,
22335:                aSC->PresContext()->GetUserFontSet());
 1105: }
 1105: 
 1345: static PRBool NonZeroStyleCoord(const nsStyleCoord& aCoord)
 1345: {
52281:   if (aCoord.IsCoordPercentCalcUnit()) {
52281:     // Since negative results are clamped to 0, check > 0.
52281:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, nscoord_MAX) > 0 ||
52281:            nsRuleNode::ComputeCoordPercentCalc(aCoord, 0) > 0;
52281:   }
52281: 
 1345:   return PR_TRUE;
 1345: }
 1345: 
 1345: /* static */ PRBool
20039: nsLayoutUtils::HasNonZeroCorner(const nsStyleCorners& aCorners)
 1345: {
20039:   NS_FOR_CSS_HALF_CORNERS(corner) {
20039:     if (NonZeroStyleCoord(aCorners.Get(corner)))
20039:       return PR_TRUE;
20039:   }
20039:   return PR_FALSE;
 1345: }
 1345: 
28109: // aCorner is a "full corner" value, i.e. NS_CORNER_TOP_LEFT etc
41419: static PRBool IsCornerAdjacentToSide(PRUint8 aCorner, mozilla::css::Side aSide)
28109: {
41419:   PR_STATIC_ASSERT((int)NS_SIDE_TOP == NS_CORNER_TOP_LEFT);
41419:   PR_STATIC_ASSERT((int)NS_SIDE_RIGHT == NS_CORNER_TOP_RIGHT);
41419:   PR_STATIC_ASSERT((int)NS_SIDE_BOTTOM == NS_CORNER_BOTTOM_RIGHT);
41419:   PR_STATIC_ASSERT((int)NS_SIDE_LEFT == NS_CORNER_BOTTOM_LEFT);
41419:   PR_STATIC_ASSERT((int)NS_SIDE_TOP == ((NS_CORNER_TOP_RIGHT - 1)&3));
41419:   PR_STATIC_ASSERT((int)NS_SIDE_RIGHT == ((NS_CORNER_BOTTOM_RIGHT - 1)&3));
41419:   PR_STATIC_ASSERT((int)NS_SIDE_BOTTOM == ((NS_CORNER_BOTTOM_LEFT - 1)&3));
41419:   PR_STATIC_ASSERT((int)NS_SIDE_LEFT == ((NS_CORNER_TOP_LEFT - 1)&3));
28109: 
28109:   return aSide == aCorner || aSide == ((aCorner - 1)&3);
28109: }
28109: 
28109: /* static */ PRBool
28109: nsLayoutUtils::HasNonZeroCornerOnSide(const nsStyleCorners& aCorners,
41419:                                       mozilla::css::Side aSide)
28109: {
28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_LEFT_X/2 == NS_CORNER_TOP_LEFT);
28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_LEFT_Y/2 == NS_CORNER_TOP_LEFT);
28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_RIGHT_X/2 == NS_CORNER_TOP_RIGHT);
28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_RIGHT_Y/2 == NS_CORNER_TOP_RIGHT);
28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_RIGHT_X/2 == NS_CORNER_BOTTOM_RIGHT);
28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_RIGHT_Y/2 == NS_CORNER_BOTTOM_RIGHT);
28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_LEFT_X/2 == NS_CORNER_BOTTOM_LEFT);
28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_LEFT_Y/2 == NS_CORNER_BOTTOM_LEFT);
28109: 
28109:   NS_FOR_CSS_HALF_CORNERS(corner) {
28109:     // corner is a "half corner" value, so dividing by two gives us a
28109:     // "full corner" value.
28109:     if (NonZeroStyleCoord(aCorners.Get(corner)) &&
28109:         IsCornerAdjacentToSide(corner/2, aSide))
28109:       return PR_TRUE;
28109:   }
28109:   return PR_FALSE;
28109: }
28109: 
16601: /* static */ nsTransparencyMode
31535: nsLayoutUtils::GetFrameTransparency(nsIFrame* aBackgroundFrame,
31535:                                     nsIFrame* aCSSRootFrame) {
31535:   if (aCSSRootFrame->GetStyleContext()->GetStyleDisplay()->mOpacity < 1.0f)
16601:     return eTransparencyTransparent;
 1345: 
31535:   if (HasNonZeroCorner(aCSSRootFrame->GetStyleContext()->GetStyleBorder()->mBorderRadius))
16601:     return eTransparencyTransparent;
 1345: 
56101:   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_GLASS)
56101:     return eTransparencyGlass;
56101: 
56101:   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS)
56101:     return eTransparencyBorderlessGlass;
56101: 
43487:   nsITheme::Transparency transparency;
31535:   if (aCSSRootFrame->IsThemed(&transparency))
43487:     return transparency == nsITheme::eTransparent
43487:          ? eTransparencyTransparent
43487:          : eTransparencyOpaque;
 1345: 
24645:   // We need an uninitialized window to be treated as opaque because
24645:   // doing otherwise breaks window display effects on some platforms,
24645:   // specifically Vista. (bug 450322)
31535:   if (aBackgroundFrame->GetType() == nsGkAtoms::viewportFrame &&
31535:       !aBackgroundFrame->GetFirstChild(nsnull)) {
24645:     return eTransparencyOpaque;
24645:   }
24645: 
40177:   nsStyleContext* bgSC;
31535:   if (!nsCSSRendering::FindBackground(aBackgroundFrame->PresContext(),
40177:                                       aBackgroundFrame, &bgSC)) {
16601:     return eTransparencyTransparent;
31535:   }
40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
25276:   if (NS_GET_A(bg->mBackgroundColor) < 255 ||
25276:       // bottom layer's clip is used for the color
25276:       bg->BottomLayer().mClip != NS_STYLE_BG_CLIP_BORDER)
16601:     return eTransparencyTransparent;
16601:   return eTransparencyOpaque;
 1345: }
 4032: 
37081: /* static */ PRBool
37081: nsLayoutUtils::IsPopup(nsIFrame* aFrame)
37081: {
37081:   nsIAtom* frameType = aFrame->GetType();
37081: 
37081:   // We're a popup if we're the list control frame dropdown for a combobox.
37081:   if (frameType == nsGkAtoms::listControlFrame) {
37081:     nsListControlFrame* listControlFrame = static_cast<nsListControlFrame*>(aFrame);
37081: 
37081:     if (listControlFrame) {
37081:       return listControlFrame->IsInDropDownMode();
37081:     }
37081:   }
37081: 
37081:   // ... or if we're a XUL menupopup frame.
37081:   return (frameType == nsGkAtoms::menuPopupFrame);
37081: }
37081: 
37081: /* static */ nsIFrame*
37081: nsLayoutUtils::GetDisplayRootFrame(nsIFrame* aFrame)
37081: {
37081:   nsIFrame* f = aFrame;
37081:   for (;;) {
37081:     if (IsPopup(f))
37081:       return f;
37081:     nsIFrame* parent = GetCrossDocParentFrame(f);
37081:     if (!parent)
37081:       return f;
37081:     f = parent;
37081:   }
37081: }
37081: 
 4032: static PRBool
 4032: IsNonzeroCoord(const nsStyleCoord& aCoord)
 4032: {
 4032:   if (eStyleUnit_Coord == aCoord.GetUnit())
 4032:     return aCoord.GetCoordValue() != 0;
 4032:   return PR_FALSE;
 4032: }
 4032: 
 4032: /* static */ PRUint32
 4032: nsLayoutUtils::GetTextRunFlagsForStyle(nsStyleContext* aStyleContext,
 4032:                                        const nsStyleText* aStyleText,
 4032:                                        const nsStyleFont* aStyleFont)
 4032: {
 4032:   PRUint32 result = 0;
 4032:   if (IsNonzeroCoord(aStyleText->mLetterSpacing)) {
 4032:     result |= gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES;
 4032:   }
 4032: #ifdef MOZ_SVG
 4032:   switch (aStyleContext->GetStyleSVG()->mTextRendering) {
 4032:   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
 4032:     result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032:     break;
 4032:   case NS_STYLE_TEXT_RENDERING_AUTO:
 4032:     if (aStyleFont->mFont.size <
 4032:         aStyleContext->PresContext()->GetAutoQualityMinFontSize()) {
 4032:       result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032:     }
 4032:     break;
 4032:   default:
 4032:     break;
 4032:   }
 4032: #endif
 4032:   return result;
 4032: }
11384: 
11384: /* static */ void
11384: nsLayoutUtils::GetRectDifferenceStrips(const nsRect& aR1, const nsRect& aR2,
11384:                                        nsRect* aHStrip, nsRect* aVStrip) {
11384:   NS_ASSERTION(aR1.TopLeft() == aR2.TopLeft(),
11384:                "expected rects at the same position");
32531:   nsRect unionRect(aR1.x, aR1.y, NS_MAX(aR1.width, aR2.width),
32531:                    NS_MAX(aR1.height, aR2.height));
32531:   nscoord VStripStart = NS_MIN(aR1.width, aR2.width);
32531:   nscoord HStripStart = NS_MIN(aR1.height, aR2.height);
11384:   *aVStrip = unionRect;
11384:   aVStrip->x += VStripStart;
11384:   aVStrip->width -= VStripStart;
11384:   *aHStrip = unionRect;
11384:   aHStrip->y += HStripStart;
11384:   aHStrip->height -= HStripStart;
11384: }
11384: 
16228: nsIDeviceContext*
16228: nsLayoutUtils::GetDeviceContextForScreenInfo(nsIDocShell* aDocShell)
16228: {
16228:   nsCOMPtr<nsIDocShell> docShell = aDocShell;
16228:   while (docShell) {
16228:     // Now make sure our size is up to date.  That will mean that the device
16228:     // context does the right thing on multi-monitor systems when we return it to
16228:     // the caller.  It will also make sure that our prescontext has been created,
16228:     // if we're supposed to have one.
16228:     nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(docShell);
16228:     if (!win) {
16228:       // No reason to go on
16228:       return nsnull;
16228:     }
16228: 
16228:     win->EnsureSizeUpToDate();
16228: 
32132:     nsRefPtr<nsPresContext> presContext;
32132:     docShell->GetPresContext(getter_AddRefs(presContext));
32132:     if (presContext) {
32132:       nsIDeviceContext* context = presContext->DeviceContext();
32132:       if (context) {
32132:         return context;
32132:       }
16228:     }
16228: 
16228:     nsCOMPtr<nsIDocShellTreeItem> curItem = do_QueryInterface(docShell);
16228:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
16228:     curItem->GetParent(getter_AddRefs(parentItem));
16228:     docShell = do_QueryInterface(parentItem);
16228:   }
16228: 
16228:   return nsnull;
16228: }
16228: 
21903: /* static */ PRBool
21903: nsLayoutUtils::IsReallyFixedPos(nsIFrame* aFrame)
21903: {
21903:   NS_PRECONDITION(aFrame->GetParent(),
21903:                   "IsReallyFixedPos called on frame not in tree");
21903:   NS_PRECONDITION(aFrame->GetStyleDisplay()->mPosition ==
21903:                     NS_STYLE_POSITION_FIXED,
21903:                   "IsReallyFixedPos called on non-'position:fixed' frame");
21903: 
23170:   nsIAtom *parentType = aFrame->GetParent()->GetType();
23170:   return parentType == nsGkAtoms::viewportFrame ||
23170:          parentType == nsGkAtoms::pageContentFrame;
21903: }
21903: 
29572: nsLayoutUtils::SurfaceFromElementResult
29572: nsLayoutUtils::SurfaceFromElement(nsIDOMElement *aElement,
29572:                                   PRUint32 aSurfaceFlags)
29572: {
29572:   SurfaceFromElementResult result;
29572:   nsresult rv;
29572: 
29572:   nsCOMPtr<nsINode> node = do_QueryInterface(aElement);
29572: 
29572:   PRBool forceCopy = (aSurfaceFlags & SFE_WANT_NEW_SURFACE) != 0;
29572:   PRBool wantImageSurface = (aSurfaceFlags & SFE_WANT_IMAGE_SURFACE) != 0;
29572: 
60418:   if (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA) {
60418:     forceCopy = PR_TRUE;
60418:     wantImageSurface = PR_TRUE;
60418:   }
60418: 
29572:   // If it's a <canvas>, we may be able to just grab its internal surface
42402:   nsCOMPtr<nsIDOMHTMLCanvasElement> domCanvas = do_QueryInterface(aElement);
42402:   if (node && domCanvas) {
42402:     nsHTMLCanvasElement *canvas = static_cast<nsHTMLCanvasElement*>(domCanvas.get());
42402:     nsIntSize nssize = canvas->GetSize();
42402:     gfxIntSize size(nssize.width, nssize.height);
29572: 
29572:     nsRefPtr<gfxASurface> surf;
29572: 
29572:     if (!forceCopy && canvas->CountContexts() == 1) {
29572:       nsICanvasRenderingContextInternal *srcCanvas = canvas->GetContextAtIndex(0);
29572:       rv = srcCanvas->GetThebesSurface(getter_AddRefs(surf));
29572: 
29572:       if (NS_FAILED(rv))
29572:         surf = nsnull;
29572:     }
29572: 
29572:     if (surf && wantImageSurface && surf->GetType() != gfxASurface::SurfaceTypeImage)
29572:       surf = nsnull;
29572: 
29572:     if (!surf) {
29572:       if (wantImageSurface) {
42402:         surf = new gfxImageSurface(size, gfxASurface::ImageFormatARGB32);
29572:       } else {
54253:         surf = gfxPlatform::GetPlatform()->CreateOffscreenSurface(size, gfxASurface::CONTENT_COLOR_ALPHA);
29572:       }
29572: 
29572:       nsRefPtr<gfxContext> ctx = new gfxContext(surf);
42402:       // XXX shouldn't use the external interface, but maybe we can layerify this
42402:       rv = (static_cast<nsICanvasElementExternal*>(canvas))->RenderContextsExternal(ctx, gfxPattern::FILTER_NEAREST);
29572:       if (NS_FAILED(rv))
29572:         return result;
29572:     }
29572: 
60418:     if (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA) {
60418:       // we can modify this surface since we force a copy above when
60418:       // when NO_PREMULTIPLY_ALPHA is set
60418:       gfxUtils::UnpremultiplyImageSurface(static_cast<gfxImageSurface*>(surf.get()));
60418:     }
60418: 
29572:     nsCOMPtr<nsIPrincipal> principal = node->NodePrincipal();
29572: 
29572:     result.mSurface = surf;
42402:     result.mSize = size;
29572:     result.mPrincipal = node->NodePrincipal();
29572:     result.mIsWriteOnly = canvas->IsWriteOnly();
29572: 
29572:     return result;
29572:   }
29572: 
29572: #ifdef MOZ_MEDIA
29572:   // Maybe it's <video>?
29572:   nsCOMPtr<nsIDOMHTMLVideoElement> ve = do_QueryInterface(aElement);
29572:   if (node && ve) {
29572:     nsHTMLVideoElement *video = static_cast<nsHTMLVideoElement*>(ve.get());
29572: 
43798:     unsigned short readyState;
43798:     if (NS_SUCCEEDED(ve->GetReadyState(&readyState)) &&
43798:         (readyState == nsIDOMHTMLMediaElement::HAVE_NOTHING ||
43798:          readyState == nsIDOMHTMLMediaElement::HAVE_METADATA)) {
43798:       result.mIsStillLoading = PR_TRUE;
43798:       return result;
43798:     }
43798: 
29572:     // If it doesn't have a principal, just bail
29572:     nsCOMPtr<nsIPrincipal> principal = video->GetCurrentPrincipal();
29572:     if (!principal)
29572:       return result;
29572: 
39499:     ImageContainer *container = video->GetImageContainer();
39499:     if (!container)
29572:       return result;
29572: 
39499:     gfxIntSize size;
39499:     nsRefPtr<gfxASurface> surf = container->GetCurrentAsSurface(&size);
39499:     if (!surf)
39499:       return result;
39499: 
39499:     if (wantImageSurface && surf->GetType() != gfxASurface::SurfaceTypeImage) {
39499:       nsRefPtr<gfxImageSurface> imgSurf =
39499:         new gfxImageSurface(size, gfxASurface::ImageFormatARGB32);
39499:       if (!imgSurf)
39499:         return result;
39499: 
39499:       nsRefPtr<gfxContext> ctx = new gfxContext(imgSurf);
39499:       if (!ctx)
39499:         return result;
29572:       ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
39499:       ctx->DrawSurface(surf, size);
39499:       surf = imgSurf;
39499:     }
29572: 
29572:     result.mSurface = surf;
39499:     result.mSize = size;
29572:     result.mPrincipal = principal;
29572:     result.mIsWriteOnly = PR_FALSE;
29572: 
29572:     return result;
29572:   }
29572: #endif
29572: 
29572:   // Finally, check if it's a normal image
29572:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(aElement);
29572: 
29572:   if (!imageLoader)
29572:     return result;
29572: 
61720:   // Push a null JSContext on the stack so that code that runs within
61720:   // the below code doesn't think it's being called by JS. See bug
61720:   // 604262.
61720:   nsCxPusher pusher;
61720:   pusher.PushNull();
61720: 
29572:   nsCOMPtr<imgIRequest> imgRequest;
29572:   rv = imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
29572:                                getter_AddRefs(imgRequest));
29572:   if (NS_FAILED(rv) || !imgRequest)
29572:     return result;
29572: 
29572:   PRUint32 status;
29572:   imgRequest->GetImageStatus(&status);
43798:   if ((status & imgIRequest::STATUS_LOAD_COMPLETE) == 0) {
43798:     // Spec says to use GetComplete, but that only works on
43798:     // nsIDOMHTMLImageElement, and we support all sorts of other stuff
43798:     // here.  Do this for now pending spec clarification.
43798:     result.mIsStillLoading = (status & imgIRequest::STATUS_ERROR) == 0;
29572:     return result;
43798:   }
29572: 
29572:   // In case of data: URIs, we want to ignore principals;
29572:   // they should have the originating content's principal,
29572:   // but that's broken at the moment in imgLib.
29572:   nsCOMPtr<nsIURI> uri;
29572:   rv = imgRequest->GetURI(getter_AddRefs(uri));
29572:   if (NS_FAILED(rv))
29572:     return result;
29572: 
29572:   PRBool isDataURI = PR_FALSE;
29572:   rv = uri->SchemeIs("data", &isDataURI);
29572:   if (NS_FAILED(rv))
29572:     return result;
29572: 
29572:   // Data URIs are always OK; set the principal
29572:   // to null to indicate that.
29572:   nsCOMPtr<nsIPrincipal> principal;
29572:   if (!isDataURI) {
29572:     rv = imgRequest->GetImagePrincipal(getter_AddRefs(principal));
29572:     if (NS_FAILED(rv) || !principal)
29572:       return result;
29572:   }
29572: 
30479:   nsCOMPtr<imgIContainer> imgContainer;
29572:   rv = imgRequest->GetImage(getter_AddRefs(imgContainer));
29572:   if (NS_FAILED(rv) || !imgContainer)
29572:     return result;
29572: 
32424:   PRUint32 whichFrame = (aSurfaceFlags & SFE_WANT_FIRST_FRAME)
32424:                         ? (PRUint32) imgIContainer::FRAME_FIRST
32424:                         : (PRUint32) imgIContainer::FRAME_CURRENT;
60418:   PRUint32 frameFlags = imgIContainer::FLAG_SYNC_DECODE;
60418:   if (aSurfaceFlags & SFE_NO_COLORSPACE_CONVERSION)
60418:     frameFlags |= imgIContainer::FLAG_DECODE_NO_COLORSPACE_CONVERSION;
60418:   if (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA)
60418:     frameFlags |= imgIContainer::FLAG_DECODE_NO_PREMULTIPLY_ALPHA;
30479:   nsRefPtr<gfxASurface> framesurf;
32424:   rv = imgContainer->GetFrame(whichFrame,
60418:                               frameFlags,
32424:                               getter_AddRefs(framesurf));
29572:   if (NS_FAILED(rv))
29572:     return result;
29572: 
29572:   PRInt32 imgWidth, imgHeight;
30479:   rv = imgContainer->GetWidth(&imgWidth);
30479:   rv |= imgContainer->GetHeight(&imgHeight);
29572:   if (NS_FAILED(rv))
29572:     return result;
29572: 
30479:   if (wantImageSurface && framesurf->GetType() != gfxASurface::SurfaceTypeImage) {
29572:     forceCopy = PR_TRUE;
29572:   }
29572: 
30479:   nsRefPtr<gfxASurface> gfxsurf = framesurf;
30479:   if (forceCopy) {
29572:     if (wantImageSurface) {
29572:       gfxsurf = new gfxImageSurface (gfxIntSize(imgWidth, imgHeight), gfxASurface::ImageFormatARGB32);
29572:     } else {
29572:       gfxsurf = gfxPlatform::GetPlatform()->CreateOffscreenSurface(gfxIntSize(imgWidth, imgHeight),
54253:                                                                    gfxASurface::CONTENT_COLOR_ALPHA);
29572:     }
29572: 
29572:     nsRefPtr<gfxContext> ctx = new gfxContext(gfxsurf);
29572: 
29572:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
30479:     ctx->SetSource(framesurf);
29572:     ctx->Paint();
29572:   }
29572: 
29572:   result.mSurface = gfxsurf;
29572:   result.mSize = gfxIntSize(imgWidth, imgHeight);
29572:   result.mPrincipal = principal;
55364: 
55364:   // SVG images could have <foreignObject> and/or <image> elements that load
55364:   // content from another domain.  For safety, they make the canvas write-only.
55364:   // XXXdholbert We could probably be more permissive here if we check that our
55364:   // helper SVG document has no elements that could load remote content.
55364:   result.mIsWriteOnly = (imgContainer->GetType() == imgIContainer::TYPE_VECTOR);
29572: 
29572:   return result;
29572: }
29572: 
41068: /* static */
41068: nsIContent*
41068: nsLayoutUtils::GetEditableRootContentByContentEditable(nsIDocument* aDocument)
41068: {
41068:   // If the document is in designMode we should return NULL.
41068:   if (!aDocument || aDocument->HasFlag(NODE_IS_EDITABLE)) {
41068:     return nsnull;
41068:   }
41068: 
41068:   // contenteditable only works with HTML document.
41068:   // Note: Use nsIDOMHTMLDocument rather than nsIHTMLDocument for getting the
41068:   //       body node because nsIDOMHTMLDocument::GetBody() does something
41068:   //       additional work for some cases and nsEditor uses them.
41068:   nsCOMPtr<nsIDOMHTMLDocument> domHTMLDoc = do_QueryInterface(aDocument);
41068:   if (!domHTMLDoc) {
41068:     return nsnull;
41068:   }
41068: 
41634:   Element* rootElement = aDocument->GetRootElement();
41634:   if (rootElement && rootElement->IsEditable()) {
41634:     return rootElement;
41068:   }
41068: 
41068:   // If there are no editable root element, check its <body> element.
41068:   // Note that the body element could be <frameset> element.
41068:   nsCOMPtr<nsIDOMHTMLElement> body;
41068:   nsresult rv = domHTMLDoc->GetBody(getter_AddRefs(body));
41068:   nsCOMPtr<nsIContent> content = do_QueryInterface(body);
41068:   if (NS_SUCCEEDED(rv) && content && content->IsEditable()) {
41068:     return content;
41068:   }
41068:   return nsnull;
41068: }
41068: 
60338: #ifdef DEBUG
60338: /* static */ void
60338: nsLayoutUtils::AssertNoDuplicateContinuations(nsIFrame* aContainer,
60338:                                               const nsFrameList& aFrameList)
60338: {
60338:   for (nsIFrame* f = aFrameList.FirstChild(); f ; f = f->GetNextSibling()) {
60338:     // Check only later continuations of f; we deal with checking the
60338:     // earlier continuations when we hit those earlier continuations in
60338:     // the frame list.
60338:     for (nsIFrame *c = f; (c = c->GetNextInFlow());) {
60338:       NS_ASSERTION(c->GetParent() != aContainer ||
60338:                    !aFrameList.ContainsFrame(c),
60338:                    "Two continuations of the same frame in the same "
60338:                    "frame list");
60338:     }
60338:   }
60338: }
60341: 
60341: // Is one of aFrame's ancestors a letter frame?
60341: static bool
60341: IsInLetterFrame(nsIFrame *aFrame)
60341: {
60341:   for (nsIFrame *f = aFrame->GetParent(); f; f = f->GetParent()) {
60341:     if (f->GetType() == nsGkAtoms::letterFrame) {
60341:       return true;
60341:     }
60341:   }
60341:   return false;
60341: }
60341: 
60341: /* static */ void
60341: nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(nsIFrame *aSubtreeRoot)
60341: {
60341:   NS_ASSERTION(aSubtreeRoot->GetPrevInFlow(),
60341:                "frame tree not empty, but caller reported complete status");
60341: 
60341:   // Also assert that text frames map no text.
60341:   PRInt32 start, end;
60341:   nsresult rv = aSubtreeRoot->GetOffsets(start, end);
60341:   NS_ASSERTION(NS_SUCCEEDED(rv), "GetOffsets failed");
60341:   // In some cases involving :first-letter, we'll partially unlink a
60341:   // continuation in the middle of a continuation chain from its
60341:   // previous and next continuations before destroying it, presumably so
60341:   // that we don't also destroy the later continuations.  Once we've
60341:   // done this, GetOffsets returns incorrect values.
60341:   // For examples, see list of tests in
60341:   // https://bugzilla.mozilla.org/show_bug.cgi?id=619021#c29
60341:   NS_ASSERTION(start == end || IsInLetterFrame(aSubtreeRoot),
60341:                "frame tree not empty, but caller reported complete status");
60341: 
60341:   PRInt32 listIndex = 0;
60341:   nsIAtom* childList = nsnull;
60341:   do {
60341:     for (nsIFrame* child = aSubtreeRoot->GetFirstChild(childList); child;
60341:          child = child->GetNextSibling()) {
60341:       nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(child);
60341:     }
60341:     childList = aSubtreeRoot->GetAdditionalChildListName(listIndex++);
60341:   } while (childList);
60341: }
60338: #endif
60338: 
60450: /* static */
60450: void
60450: nsLayoutUtils::Shutdown()
60450: {
60450:   if (sContentMap) {
60450:     delete sContentMap;
60450:     sContentMap = NULL;
60450:   }
60450: }
60450: 
14319: nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
14319:                                      const nsAString& aValue)
14319:   : mContent(aContent),
14319:     mAttrName(aAttrName),
14319:     mValue(aValue)
14319: {
14319:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
14319: }
14319: 
41743: nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
41743:                                      PRInt32 aValue)
41743:   : mContent(aContent),
41743:     mAttrName(aAttrName)
41743: {
41743:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
41743:   mValue.AppendInt(aValue);
41743: }
41743: 
14319: NS_IMETHODIMP
14319: nsSetAttrRunnable::Run()
14319: {
14319:   return mContent->SetAttr(kNameSpaceID_None, mAttrName, mValue, PR_TRUE);
14319: }
14319: 
14319: nsUnsetAttrRunnable::nsUnsetAttrRunnable(nsIContent* aContent,
14319:                                          nsIAtom* aAttrName)
14319:   : mContent(aContent),
14319:     mAttrName(aAttrName)
14319: {
14319:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
14319: }
14319: 
14319: NS_IMETHODIMP
14319: nsUnsetAttrRunnable::Run()
14319: {
14319:   return mContent->UnsetAttr(kNameSpaceID_None, mAttrName, PR_TRUE);
14319: }
23933: 
23933: nsReflowFrameRunnable::nsReflowFrameRunnable(nsIFrame* aFrame,
23933:                           nsIPresShell::IntrinsicDirty aIntrinsicDirty,
23933:                           nsFrameState aBitToAdd)
23933:   : mWeakFrame(aFrame),
23933:     mIntrinsicDirty(aIntrinsicDirty),
23933:     mBitToAdd(aBitToAdd)
23933: {
23933: }
23933: 
23933: NS_IMETHODIMP
23933: nsReflowFrameRunnable::Run()
23933: {
23933:   if (mWeakFrame.IsAlive()) {
23933:     mWeakFrame->PresContext()->PresShell()->
23933:       FrameNeedsReflow(mWeakFrame, mIntrinsicDirty, mBitToAdd);
23933:   }
23933:   return NS_OK;
23933: }
