35890: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
35746:  * vim: sw=4 ts=4 et :
35746:  * ***** BEGIN LICENSE BLOCK *****
35746:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35746:  *
35746:  * The contents of this file are subject to the Mozilla Public License Version
35746:  * 1.1 (the "License"); you may not use this file except in compliance with
35746:  * the License. You may obtain a copy of the License at
35746:  * http://www.mozilla.org/MPL/
35746:  *
35746:  * Software distributed under the License is distributed on an "AS IS" basis,
35746:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35746:  * for the specific language governing rights and limitations under the
35746:  * License.
35746:  *
35746:  * The Original Code is Mozilla Plugin App.
35746:  *
35746:  * The Initial Developer of the Original Code is
35746:  *   Chris Jones <jones.chris.g@gmail.com>
35746:  * Portions created by the Initial Developer are Copyright (C) 2009
35746:  * the Initial Developer. All Rights Reserved.
35746:  *
35746:  * Contributor(s):
35746:  *
35746:  * Alternatively, the contents of this file may be used under the terms of
35746:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35746:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35746:  * in which case the provisions of the GPL or the LGPL are applicable instead
35746:  * of those above. If you wish to allow use of your version of this file only
35746:  * under the terms of either the GPL or the LGPL, and not to allow others to
35746:  * use your version of this file under the terms of the MPL, indicate your
35746:  * decision by deleting the provisions above and replace them with the notice
35746:  * and other provisions required by the GPL or the LGPL. If you do not delete
35746:  * the provisions above, a recipient may use your version of this file under
35746:  * the terms of any one of the MPL, the GPL or the LGPL.
35746:  *
35746:  * ***** END LICENSE BLOCK ***** */
35746: 
35746: #ifndef DOM_PLUGINS_PLUGINMESSAGEUTILS_H
35746: #define DOM_PLUGINS_PLUGINMESSAGEUTILS_H
35746: 
35746: #include "IPC/IPCMessageUtils.h"
37884: #include "base/message_loop.h"
35746: 
39265: #include "mozilla/ipc/RPCChannel.h"
39265: 
35746: #include "npapi.h"
35835: #include "npruntime.h"
36033: #include "npfunctions.h"
35835: #include "nsAutoPtr.h"
35835: #include "nsStringGlue.h"
37311: #include "nsTArray.h"
35971: #include "nsThreadUtils.h"
37099: #include "prlog.h"
38669: #include "nsHashKeys.h"
35835: 
35835: namespace mozilla {
35900: 
35900: // XXX might want to move these to nscore.h or something, they can be
35900: // generally useful
35900: struct void_t { };
35900: struct null_t { };
35900: 
35835: namespace ipc {
35835: 
35835: typedef intptr_t NPRemoteIdentifier;
35835: 
35835: } /* namespace ipc */
35890: 
35890: namespace plugins {
35890: 
37311: enum ScriptableObjectType
37311: {
37311:   LocalObject,
37311:   Proxy
37311: };
37311: 
39265: mozilla::ipc::RPCChannel::RacyRPCPolicy
39265: MediateRace(const mozilla::ipc::RPCChannel::Message& parent,
39265:             const mozilla::ipc::RPCChannel::Message& child);
39265: 
37099: extern PRLogModuleInfo* gPluginLog;
37099: 
37099: #if defined(_MSC_VER)
37099: #define FULLFUNCTION __FUNCSIG__
37099: #elif (__GNUC__ >= 4)
37099: #define FULLFUNCTION __PRETTY_FUNCTION__
37099: #else
37099: #define FULLFUNCTION __FUNCTION__
37099: #endif
37099: 
37099: #define PLUGIN_LOG_DEBUG(args) PR_LOG(gPluginLog, PR_LOG_DEBUG, args)
37099: #define PLUGIN_LOG_DEBUG_FUNCTION PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION))
37099: #define PLUGIN_LOG_DEBUG_METHOD PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s [%p]", FULLFUNCTION, (void*) this))
37099: 
35890: /**
35890:  * This is NPByteRange without the linked list.
35890:  */
35890: struct IPCByteRange
35890: {
35890:   int32_t offset;
35890:   uint32_t length;
35890: };  
35890: 
35890: typedef std::vector<IPCByteRange> IPCByteRanges;
35890: 
35890: typedef nsCString Buffer;
35890: 
35957: struct NPRemoteWindow
35957: {
35957:   unsigned long window;
35957:   int32_t x;
35957:   int32_t y;
35957:   uint32_t width;
35957:   uint32_t height;
35957:   NPRect clipRect;
35957:   NPWindowType type;
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:   VisualID visualID;
35957:   Colormap colormap;
35957: #endif /* XP_UNIX */
36124: #if defined(XP_WIN)
36124:   base::SharedMemoryHandle surfaceHandle;
36124: #endif
35957: };
35957: 
37308: #ifdef XP_WIN
37308: typedef HWND NativeWindowHandle;
37308: #elif defined(MOZ_X11)
37308: typedef XID NativeWindowHandle;
37308: #else
37308: #error Need NativeWindowHandle for this platform
37308: #endif
37308: 
35951: // XXX maybe not the best place for these. better one?
35951: 
35951: #define VARSTR(v_)  case v_: return #v_
35951: inline const char* const
35951: NPPVariableToString(NPPVariable aVar)
35951: {
35951:     switch (aVar) {
35951:         VARSTR(NPPVpluginNameString);
35951:         VARSTR(NPPVpluginDescriptionString);
35951:         VARSTR(NPPVpluginWindowBool);
35951:         VARSTR(NPPVpluginTransparentBool);
35951:         VARSTR(NPPVjavaClass);
35951:         VARSTR(NPPVpluginWindowSize);
35951:         VARSTR(NPPVpluginTimerInterval);
35951: 
35951:         VARSTR(NPPVpluginScriptableInstance);
35951:         VARSTR(NPPVpluginScriptableIID);
35951: 
35951:         VARSTR(NPPVjavascriptPushCallerBool);
35951: 
35951:         VARSTR(NPPVpluginKeepLibraryInMemory);
35951:         VARSTR(NPPVpluginNeedsXEmbed);
35951: 
35951:         VARSTR(NPPVpluginScriptableNPObject);
35951: 
35951:         VARSTR(NPPVformValue);
35951:   
35951:         VARSTR(NPPVpluginUrlRequestsDisplayedBool);
35951:   
35951:         VARSTR(NPPVpluginWantsAllNetworkStreams);
35951: 
35951: #ifdef XP_MACOSX
35951:         VARSTR(NPPVpluginDrawingModel);
35951:         VARSTR(NPPVpluginEventModel);
35951: #endif
35951: 
35951:     default: return "???";
35951:     }
35951: }
35951: 
35951: inline const char*
35951: NPNVariableToString(NPNVariable aVar)
35951: {
35951:     switch(aVar) {
35951:         VARSTR(NPNVxDisplay);
35951:         VARSTR(NPNVxtAppContext);
35951:         VARSTR(NPNVnetscapeWindow);
35951:         VARSTR(NPNVjavascriptEnabledBool);
35951:         VARSTR(NPNVasdEnabledBool);
35951:         VARSTR(NPNVisOfflineBool);
35951: 
35951:         VARSTR(NPNVserviceManager);
35951:         VARSTR(NPNVDOMElement);
35951:         VARSTR(NPNVDOMWindow);
35951:         VARSTR(NPNVToolkit);
35951:         VARSTR(NPNVSupportsXEmbedBool);
35951: 
35951:         VARSTR(NPNVWindowNPObject);
35951: 
35951:         VARSTR(NPNVPluginElementNPObject);
35951: 
35951:         VARSTR(NPNVSupportsWindowless);
35951: 
35951:         VARSTR(NPNVprivateModeBool);
35951: 
35951:     default: return "???";
35951:     }
35951: }
35951: #undef VARSTR
35951: 
35951: 
35971: inline void AssertPluginThread()
35971: {
37884:   NS_ASSERTION(MessageLoopForUI::current(),
37884:                "should be on the plugin's main thread!");
35971: }
35971: 
36033: void DeferNPObjectLastRelease(const NPNetscapeFuncs* f, NPObject* o);
36033: void DeferNPVariantLastRelease(const NPNetscapeFuncs* f, NPVariant* v);
35971: 
35940: // in NPAPI, char* == NULL is sometimes meaningful.  the following is
35940: // helper code for dealing with nullable nsCString's
36112: inline nsCString
35940: NullableString(const char* aString)
35940: {
35940:     if (!aString) {
35940:         nsCString str;
35940:         str.SetIsVoid(PR_TRUE);
35940:         return str;
35940:     }
35940:     return nsCString(aString);
35940: }
35940: 
36112: inline const char*
36112: NullableStringGet(const nsCString& str)
36112: {
36112:   if (str.IsVoid())
36112:     return NULL;
35940: 
36112:   return str.get();
36112: }
35940: 
38669: struct DeletingObjectEntry : public nsPtrHashKey<NPObject>
38669: {
38669:   DeletingObjectEntry(const NPObject* key)
38669:     : nsPtrHashKey<NPObject>(key)
38669:     , mDeleted(false)
38669:   { }
38669: 
38669:   bool mDeleted;
38669: };
38669: 
36112: } /* namespace plugins */
36112: 
36112: } /* namespace mozilla */
35940: 
35746: namespace IPC {
35746: 
35746: template <>
35746: struct ParamTraits<NPRect>
35746: {
35746:   typedef NPRect paramType;
35746: 
35746:   static void Write(Message* aMsg, const paramType& aParam)
35746:   {
35746:     WriteParam(aMsg, aParam.top);
35746:     WriteParam(aMsg, aParam.left);
35746:     WriteParam(aMsg, aParam.bottom);
35746:     WriteParam(aMsg, aParam.right);
35746:   }
35746: 
35746:   static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
35746:   {
35746:     uint16_t top, left, bottom, right;
35746:     if (ReadParam(aMsg, aIter, &top) &&
35746:         ReadParam(aMsg, aIter, &left) &&
35746:         ReadParam(aMsg, aIter, &bottom) &&
35746:         ReadParam(aMsg, aIter, &right)) {
35746:       aResult->top = top;
35746:       aResult->left = left;
35746:       aResult->bottom = bottom;
35746:       aResult->right = right;
35746:       return true;
35746:     }
35746:     return false;
35746:   }
35746: 
35746:   static void Log(const paramType& aParam, std::wstring* aLog)
35746:   {
35746:     aLog->append(StringPrintf(L"[%u, %u, %u, %u]", aParam.top, aParam.left,
35746:                               aParam.bottom, aParam.right));
35746:   }
35746: };
35746: 
35746: template <>
35746: struct ParamTraits<NPWindowType>
35746: {
35746:   typedef NPWindowType paramType;
35746: 
35746:   static void Write(Message* aMsg, const paramType& aParam)
35746:   {
35746:     aMsg->WriteInt16(int16(aParam));
35746:   }
35746: 
35746:   static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
35746:   {
35746:     int16 result;
35746:     if (aMsg->ReadInt16(aIter, &result)) {
35746:       *aResult = paramType(result);
35746:       return true;
35746:     }
35746:     return false;
35746:   }
35746: 
35746:   static void Log(const paramType& aParam, std::wstring* aLog)
35746:   {
35746:     aLog->append(StringPrintf(L"%d", int16(aParam)));
35746:   }
35746: };
35746: 
35746: template <>
35957: struct ParamTraits<mozilla::plugins::NPRemoteWindow>
35746: {
35957:   typedef mozilla::plugins::NPRemoteWindow paramType;
35746: 
35746:   static void Write(Message* aMsg, const paramType& aParam)
35746:   {
35957:     aMsg->WriteULong(aParam.window);
35746:     WriteParam(aMsg, aParam.x);
35746:     WriteParam(aMsg, aParam.y);
35746:     WriteParam(aMsg, aParam.width);
35746:     WriteParam(aMsg, aParam.height);
35746:     WriteParam(aMsg, aParam.clipRect);
35746:     WriteParam(aMsg, aParam.type);
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     aMsg->WriteULong(aParam.visualID);
35957:     aMsg->WriteULong(aParam.colormap);
35957: #endif
36124: #if defined(XP_WIN)
36124:     WriteParam(aMsg, aParam.surfaceHandle);
36124: #endif
35746:   }
35746: 
35746:   static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
35746:   {
35746:     unsigned long window;
35746:     int32_t x, y;
35746:     uint32_t width, height;
35955:     NPRect clipRect;
35746:     NPWindowType type;
35955:     if (!(aMsg->ReadULong(aIter, &window) &&
35746:           ReadParam(aMsg, aIter, &x) &&
35746:           ReadParam(aMsg, aIter, &y) &&
35746:           ReadParam(aMsg, aIter, &width) &&
35746:           ReadParam(aMsg, aIter, &height) &&
35955:           ReadParam(aMsg, aIter, &clipRect) &&
35955:           ReadParam(aMsg, aIter, &type)))
35955:       return false;
35955: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     unsigned long visualID;
35957:     unsigned long colormap;
35957:     if (!(aMsg->ReadULong(aIter, &visualID) &&
35957:           aMsg->ReadULong(aIter, &colormap)))
35957:       return false;
35957: #endif
35957: 
36124: #if defined(XP_WIN)
36124:     base::SharedMemoryHandle surfaceHandle;
36124:     if (!ReadParam(aMsg, aIter, &surfaceHandle))
36124:       return false;
36124: #endif
36124: 
35957:     aResult->window = window;
35746:     aResult->x = x;
35746:     aResult->y = y;
35746:     aResult->width = width;
35746:     aResult->height = height;
35955:     aResult->clipRect = clipRect;
35957:     aResult->type = type;
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     aResult->visualID = visualID;
35957:     aResult->colormap = colormap;
35746: #endif
36124: #if defined(XP_WIN)
36124:     aResult->surfaceHandle = surfaceHandle;
36124: #endif
35746:     return true;
35746:   }
35746: 
35746:   static void Log(const paramType& aParam, std::wstring* aLog)
35746:   {
35746:     aLog->append(StringPrintf(L"[%u, %d, %d, %u, %u, %d",
35746:                               (unsigned long)aParam.window,
35746:                               aParam.x, aParam.y, aParam.width,
35746:                               aParam.height, (long)aParam.type));
35746:   }
35746: };
35746: 
35835: template <>
35835: struct ParamTraits<NPString>
35835: {
35835:   typedef NPString paramType;
35835: 
35835:   static void Write(Message* aMsg, const paramType& aParam)
35835:   {
35835:     WriteParam(aMsg, aParam.UTF8Length);
35835:     aMsg->WriteBytes(aParam.UTF8Characters,
35835:                      aParam.UTF8Length * sizeof(NPUTF8));
35835:   }
35835: 
35835:   static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
35835:   {
35835:     if (ReadParam(aMsg, aIter, &aResult->UTF8Length)) {
35835:       int byteCount = aResult->UTF8Length * sizeof(NPUTF8);
35835:       if (!byteCount) {
35835:         aResult->UTF8Characters = "\0";
35835:         return true;
35835:       }
35835: 
35835:       const char* messageBuffer = nsnull;
35835:       nsAutoArrayPtr<char> newBuffer(new char[byteCount]);
35835:       if (newBuffer && aMsg->ReadBytes(aIter, &messageBuffer, byteCount )) {
35835:         memcpy((void*)messageBuffer, newBuffer.get(), byteCount);
35835:         aResult->UTF8Characters = newBuffer.forget();
35835:         return true;
35835:       }
35835:     }
35835:     return false;
35835:   }
35835: 
35835:   static void Log(const paramType& aParam, std::wstring* aLog)
35835:   {
35835:     aLog->append(StringPrintf(L"%s", aParam.UTF8Characters));
35835:   }
35835: };
35835: 
35835: template <>
35835: struct ParamTraits<NPVariant>
35835: {
35835:   typedef NPVariant paramType;
35835: 
35835:   static void Write(Message* aMsg, const paramType& aParam)
35835:   {
35835:     if (NPVARIANT_IS_VOID(aParam)) {
35835:       aMsg->WriteInt(0);
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_NULL(aParam)) {
35835:       aMsg->WriteInt(1);
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_BOOLEAN(aParam)) {
35835:       aMsg->WriteInt(2);
35835:       WriteParam(aMsg, NPVARIANT_TO_BOOLEAN(aParam));
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_INT32(aParam)) {
35835:       aMsg->WriteInt(3);
35835:       WriteParam(aMsg, NPVARIANT_TO_INT32(aParam));
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_DOUBLE(aParam)) {
35835:       aMsg->WriteInt(4);
35835:       WriteParam(aMsg, NPVARIANT_TO_DOUBLE(aParam));
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_STRING(aParam)) {
35835:       aMsg->WriteInt(5);
35835:       WriteParam(aMsg, NPVARIANT_TO_STRING(aParam));
35835:       return;
35835:     }
35835: 
35835:     NS_ERROR("Unsupported type!");
35835:   }
35835: 
35835:   static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
35835:   {
35835:     int type;
35835:     if (!aMsg->ReadInt(aIter, &type)) {
35835:       return false;
35835:     }
35835: 
35835:     switch (type) {
35835:       case 0:
35835:         VOID_TO_NPVARIANT(*aResult);
35835:         return true;
35835: 
35835:       case 1:
35835:         NULL_TO_NPVARIANT(*aResult);
35835:         return true;
35835: 
35835:       case 2: {
35835:         bool value;
35835:         if (ReadParam(aMsg, aIter, &value)) {
35835:           BOOLEAN_TO_NPVARIANT(value, *aResult);
35835:           return true;
35835:         }
35835:       } break;
35835: 
35835:       case 3: {
35835:         int32 value;
35835:         if (ReadParam(aMsg, aIter, &value)) {
35835:           INT32_TO_NPVARIANT(value, *aResult);
35835:           return true;
35835:         }
35835:       } break;
35835: 
35835:       case 4: {
35835:         double value;
35835:         if (ReadParam(aMsg, aIter, &value)) {
35835:           DOUBLE_TO_NPVARIANT(value, *aResult);
35835:           return true;
35835:         }
35835:       } break;
35835: 
35835:       case 5: {
35835:         NPString value;
35835:         if (ReadParam(aMsg, aIter, &value)) {
35835:           STRINGN_TO_NPVARIANT(value.UTF8Characters, value.UTF8Length,
35835:                                *aResult);
35835:           return true;
35835:         }
35835:       } break;
35835: 
35835:       default:
35835:         NS_ERROR("Unsupported type!");
35835:     }
35835: 
35835:     return false;
35835:   }
35835: 
35835:   static void Log(const paramType& aParam, std::wstring* aLog)
35835:   {
35835:     if (NPVARIANT_IS_VOID(aParam)) {
35835:       aLog->append(L"[void]");
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_NULL(aParam)) {
35835:       aLog->append(L"[null]");
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_BOOLEAN(aParam)) {
35835:       LogParam(NPVARIANT_TO_BOOLEAN(aParam), aLog);
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_INT32(aParam)) {
35835:       LogParam(NPVARIANT_TO_INT32(aParam), aLog);
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_DOUBLE(aParam)) {
35835:       LogParam(NPVARIANT_TO_DOUBLE(aParam), aLog);
35835:       return;
35835:     }
35835: 
35835:     if (NPVARIANT_IS_STRING(aParam)) {
35835:       LogParam(NPVARIANT_TO_STRING(aParam), aLog);
35835:       return;
35835:     }
35835: 
35835:     NS_ERROR("Unsupported type!");
35835:   }
35835: };
35835: 
35890: template<>
35900: struct ParamTraits<mozilla::void_t>
35900: {
35900:   typedef mozilla::void_t paramType;
35900:   static void Write(Message* aMsg, const paramType& aParam) { }
35900:   static bool
35900:   Read(const Message* aMsg, void** aIter, paramType* aResult)
35900:   {
35900:     *aResult = paramType();
35900:     return true;
35900:   }
35900: };
35900: 
35900: template<>
35900: struct ParamTraits<mozilla::null_t>
35900: {
35900:   typedef mozilla::null_t paramType;
35900:   static void Write(Message* aMsg, const paramType& aParam) { }
35900:   static bool
35900:   Read(const Message* aMsg, void** aIter, paramType* aResult)
35900:   {
35900:     *aResult = paramType();
35900:     return true;
35900:   }
35900: };
35900: 
35900: template <>
35890: struct ParamTraits<mozilla::plugins::IPCByteRange>
35890: {
35890:   typedef mozilla::plugins::IPCByteRange paramType;
35890: 
35890:   static void Write(Message* aMsg, const paramType& aParam)
35890:   {
35890:     WriteParam(aMsg, aParam.offset);
35890:     WriteParam(aMsg, aParam.length);
35890:   }
35890: 
35890:   static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
35890:   {
35890:     paramType p;
35890:     if (ReadParam(aMsg, aIter, &p.offset) &&
35890:         ReadParam(aMsg, aIter, &p.length)) {
35890:       *aResult = p;
35890:       return true;
35890:     }
35890:     return false;
35890:   }
35890: };
35890: 
36125: template <>
36125: struct ParamTraits<NPNVariable>
36125: {
36125:   typedef NPNVariable paramType;
36125: 
36125:   static void Write(Message* aMsg, const paramType& aParam)
36125:   {
36125:     WriteParam(aMsg, int(aParam));
36125:   }
36125: 
36125:   static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
36125:   {
36125:     int intval;
36125:     if (ReadParam(aMsg, aIter, &intval)) {
36125:       *aResult = paramType(intval);
36125:       return true;
36125:     }
36125:     return false;
36125:   }
36125: };
35933: 
37332: template<>
37332: struct ParamTraits<NPNURLVariable>
37332: {
37332:   typedef NPNURLVariable paramType;
37332: 
37332:   static void Write(Message* aMsg, const paramType& aParam)
37332:   {
37332:     WriteParam(aMsg, int(aParam));
37332:   }
37332: 
37332:   static bool Read(const Message* aMsg, void** aIter, paramType* aResult)
37332:   {
37332:     int intval;
37332:     if (ReadParam(aMsg, aIter, &intval)) {
37332:       switch (intval) {
37332:       case NPNURLVCookie:
37332:       case NPNURLVProxy:
37332:         *aResult = paramType(intval);
37332:         return true;
37332:       }
37332:     }
37332:     return false;
37332:   }
37332: };
37332: 
35746: } /* namespace IPC */
35746: 
35933: 
35933: // Serializing NPEvents is completely platform-specific and can be rather
35933: // intricate depending on the platform.  So for readability we split it
35933: // into separate files and have the only macro crud live here.
35933: // 
35933: // NB: these guards are based on those where struct NPEvent is defined
35933: // in npapi.h.  They should be kept in sync.
35933: #if defined(XP_MACOSX)
35933: #  include "mozilla/plugins/NPEventOSX.h"
35933: #elif defined(XP_WIN)
35933: #  include "mozilla/plugins/NPEventWindows.h"
35933: #elif defined(XP_OS2)
35933: #  error Sorry, OS/2 is not supported
35933: #elif defined(XP_UNIX) && defined(MOZ_X11)
35933: #  include "mozilla/plugins/NPEventX11.h"
35933: #else
35933: #  error Unsupported platform
35933: #endif
35933: 
35746: #endif /* DOM_PLUGINS_PLUGINMESSAGEUTILS_H */
