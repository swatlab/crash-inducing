31383: /* ***** BEGIN LICENSE BLOCK *****
31383:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
31383:  *
31383:  * The contents of this file are subject to the Mozilla Public License Version
31383:  * 1.1 (the "License"); you may not use this file except in compliance with
31383:  * the License. You may obtain a copy of the License at
31383:  * http://www.mozilla.org/MPL/
31383:  *
31383:  * Software distributed under the License is distributed on an "AS IS" basis,
31383:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
31383:  * for the specific language governing rights and limitations under the
31383:  * License.
31383:  *
31383:  * The Original Code is mozilla.org code.
31383:  *
31383:  * The Initial Developer of the Original Code is
31383:  * Sylvain Pasche <sylvain.pasche@gmail.com>
31383:  * Portions created by the Initial Developer are Copyright (C) 2009
31383:  * the Initial Developer. All Rights Reserved.
31383:  *
31383:  * Contributor(s):
31383:  *
31383:  * Alternatively, the contents of this file may be used under the terms of
31383:  * either the GNU General Public License Version 2 or later (the "GPL"), or
31383:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
31383:  * in which case the provisions of the GPL or the LGPL are applicable instead
31383:  * of those above. If you wish to allow use of your version of this file only
31383:  * under the terms of either the GPL or the LGPL, and not to allow others to
31383:  * use your version of this file under the terms of the MPL, indicate your
31383:  * decision by deleting the provisions above and replace them with the notice
31383:  * and other provisions required by the GPL or the LGPL. If you do not delete
31383:  * the provisions above, a recipient may use your version of this file under
31383:  * the terms of any one of the MPL, the GPL or the LGPL.
31383:  *
31383:  * ***** END LICENSE BLOCK ***** */
31383: 
31383: /*
31383:  * Implementation of nsIDOMDOMTokenList specified by HTML5.
31383:  */
31383: 
31383: #include "nsDOMTokenList.h"
31383: 
31383: #include "nsAttrValue.h"
31383: #include "nsContentUtils.h"
31383: #include "nsDOMError.h"
31383: #include "nsGenericElement.h"
31383: #include "nsHashSets.h"
31383: 
31383: 
31383: nsDOMTokenList::nsDOMTokenList(nsGenericElement *aElement, nsIAtom* aAttrAtom)
31383:   : mElement(aElement),
31383:     mAttrAtom(aAttrAtom)
31383: {
31383:   // We don't add a reference to our element. If it goes away,
31383:   // we'll be told to drop our reference
31383: }
31383: 
31383: nsDOMTokenList::~nsDOMTokenList() { }
31383: 
40490: DOMCI_DATA(DOMTokenList, nsDOMTokenList)
40490: 
31383: NS_INTERFACE_TABLE_HEAD(nsDOMTokenList)
31383:   NS_INTERFACE_TABLE1(nsDOMTokenList,
31383:                       nsIDOMDOMTokenList)
31383:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DOMTokenList)
31383: NS_INTERFACE_MAP_END
31383: 
31383: NS_IMPL_ADDREF(nsDOMTokenList)
31383: NS_IMPL_RELEASE(nsDOMTokenList)
31383: 
31383: void
31383: nsDOMTokenList::DropReference()
31383: {
31383:   mElement = nsnull;
31383: }
31383: 
31383: NS_IMETHODIMP
31383: nsDOMTokenList::GetLength(PRUint32 *aLength)
31383: {
31383:   const nsAttrValue* attr = GetParsedAttr();
31383:   if (!attr) {
31383:     *aLength = 0;
31383:     return NS_OK;
31383:   }
31383: 
31383:   *aLength = attr->GetAtomCount();
31383: 
31383:   return NS_OK;
31383: }
31383: 
31383: NS_IMETHODIMP
31383: nsDOMTokenList::Item(PRUint32 aIndex, nsAString& aResult)
31383: {
31383:   const nsAttrValue* attr = GetParsedAttr();
31383: 
31383:   if (!attr || aIndex >= static_cast<PRUint32>(attr->GetAtomCount())) {
31383:     SetDOMStringToNull(aResult);
31383:     return NS_OK;
31383:   }
31383:   attr->AtomAt(aIndex)->ToString(aResult);
31383: 
31383:   return NS_OK;
31383: }
31383: 
31383: nsresult
31383: nsDOMTokenList::CheckToken(const nsAString& aStr)
31383: {
31383:   if (aStr.IsEmpty()) {
31383:     return NS_ERROR_DOM_SYNTAX_ERR;
31383:   }
31383: 
31383:   nsAString::const_iterator iter, end;
31383:   aStr.BeginReading(iter);
31383:   aStr.EndReading(end);
31383: 
31383:   while (iter != end) {
31383:     if (nsContentUtils::IsHTMLWhitespace(*iter))
31383:       return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
31383:     ++iter;
31383:   }
31383: 
31383:   return NS_OK;
31383: }
31383: 
31383: PRBool
31383: nsDOMTokenList::ContainsInternal(const nsAttrValue* aAttr,
31383:                                  const nsAString& aToken)
31383: {
31383:   NS_ABORT_IF_FALSE(aAttr, "Need an attribute");
31383: 
31383:   nsCOMPtr<nsIAtom> atom = do_GetAtom(aToken);
31383:   return aAttr->Contains(atom, eCaseMatters);
31383: }
31383: 
31383: NS_IMETHODIMP
31383: nsDOMTokenList::Contains(const nsAString& aToken, PRBool* aResult)
31383: {
31383:   nsresult rv = CheckToken(aToken);
31383:   NS_ENSURE_SUCCESS(rv, rv);
31383: 
31383:   const nsAttrValue* attr = GetParsedAttr();
31383:   if (!attr) {
31383:     *aResult = PR_FALSE;
31383:     return NS_OK;
31383:   }
31383: 
31383:   *aResult = ContainsInternal(attr, aToken);
31383: 
31383:   return NS_OK;
31383: }
31383: 
31383: void
31383: nsDOMTokenList::AddInternal(const nsAttrValue* aAttr,
31383:                             const nsAString& aToken)
31383: {
40789:   if (!mElement) {
40789:     return;
40789:   }
40789: 
31383:   nsAutoString resultStr;
31383: 
31383:   if (aAttr) {
31383:     aAttr->ToString(resultStr);
31383:   }
31383: 
31383:   if (!resultStr.IsEmpty() &&
31383:       !nsContentUtils::IsHTMLWhitespace(
31383:           resultStr.CharAt(resultStr.Length() - 1))) {
31383:     resultStr.Append(NS_LITERAL_STRING(" ") + aToken);
31383:   } else {
31383:     resultStr.Append(aToken);
31383:   }
31383:   mElement->SetAttr(kNameSpaceID_None, mAttrAtom, resultStr, PR_TRUE);
31383: }
31383: 
31383: NS_IMETHODIMP
31383: nsDOMTokenList::Add(const nsAString& aToken)
31383: {
31383:   nsresult rv = CheckToken(aToken);
31383:   NS_ENSURE_SUCCESS(rv, rv);
31383: 
31383:   const nsAttrValue* attr = GetParsedAttr();
31383: 
31383:   if (attr && ContainsInternal(attr, aToken)) {
31383:     return NS_OK;
31383:   }
31383: 
31383:   AddInternal(attr, aToken);
31383: 
31383:   return NS_OK;
31383: }
31383: 
31383: void
31383: nsDOMTokenList::RemoveInternal(const nsAttrValue* aAttr,
31383:                                const nsAString& aToken)
31383: {
31383:   NS_ABORT_IF_FALSE(aAttr, "Need an attribute");
31383: 
31383:   nsAutoString input;
31383:   aAttr->ToString(input);
31383: 
31383:   nsAString::const_iterator copyStart, tokenStart, iter, end;
31383:   input.BeginReading(iter);
31383:   input.EndReading(end);
31383:   copyStart = iter;
31383: 
31383:   nsAutoString output;
31383:   PRBool lastTokenRemoved = PR_FALSE;
31383: 
31383:   while (iter != end) {
31383:     // skip whitespace.
31383:     while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
31383:       ++iter;
31383:     }
31383: 
31383:     if (iter == end) {
31383:       // At this point we're sure the last seen token (if any) wasn't to be
31383:       // removed. So the trailing spaces will need to be kept.
31383:       NS_ABORT_IF_FALSE(!lastTokenRemoved, "How did this happen?");
31383: 
31383:       output.Append(Substring(copyStart, end));
31383:       break;
31383:     }
31383: 
31383:     tokenStart = iter;
31383:     do {
31383:       ++iter;
31383:     } while (iter != end && !nsContentUtils::IsHTMLWhitespace(*iter));
31383: 
31383:     if (Substring(tokenStart, iter).Equals(aToken)) {
31383: 
31383:       // Skip whitespace after the token, it will be collapsed.
31383:       while (iter != end && nsContentUtils::IsHTMLWhitespace(*iter)) {
31383:         ++iter;
31383:       }
31383:       copyStart = iter;
31383:       lastTokenRemoved = PR_TRUE;
31383: 
31383:     } else {
31383: 
31383:       if (lastTokenRemoved && !output.IsEmpty()) {
31383:         NS_ABORT_IF_FALSE(!nsContentUtils::IsHTMLWhitespace(
31383:           output.CharAt(output.Length() - 1)), "Invalid last output token");
31383:         output.Append(PRUnichar(' '));
31383:       }
31383:       lastTokenRemoved = PR_FALSE;
31383:       output.Append(Substring(copyStart, iter));
31383:       copyStart = iter;
31383:     }
31383:   }
31383: 
31383:   mElement->SetAttr(kNameSpaceID_None, mAttrAtom, output, PR_TRUE);
31383: }
31383: 
31383: NS_IMETHODIMP
31383: nsDOMTokenList::Remove(const nsAString& aToken)
31383: {
31383:   nsresult rv = CheckToken(aToken);
31383:   NS_ENSURE_SUCCESS(rv, rv);
31383: 
31383:   const nsAttrValue* attr = GetParsedAttr();
31383:   if (!attr) {
31383:     return NS_OK;
31383:   }
31383: 
31383:   if (!ContainsInternal(attr, aToken)) {
31383:     return NS_OK;
31383:   }
31383: 
31383:   RemoveInternal(attr, aToken);
31383: 
31383:   return NS_OK;
31383: }
31383: 
31383: NS_IMETHODIMP
31383: nsDOMTokenList::Toggle(const nsAString& aToken, PRBool* aResult)
31383: {
31383:   nsresult rv = CheckToken(aToken);
31383:   NS_ENSURE_SUCCESS(rv, rv);
31383: 
31383:   const nsAttrValue* attr = GetParsedAttr();
31383: 
31383:   if (attr && ContainsInternal(attr, aToken)) {
31383:     RemoveInternal(attr, aToken);
31383:     *aResult = PR_FALSE;
31383:   } else {
31383:     AddInternal(attr, aToken);
31383:     *aResult = PR_TRUE;
31383:   }
31383: 
31383:   return NS_OK;
31383: }
31383: 
31383: NS_IMETHODIMP
31383: nsDOMTokenList::ToString(nsAString& aResult)
31383: {
31383:   if (!mElement) {
31383:     aResult.Truncate();
31383:     return NS_OK;
31383:   }
31383: 
31383:   mElement->GetAttr(kNameSpaceID_None, mAttrAtom, aResult);
31383: 
31383:   return NS_OK;
31383: }
