 75402: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98921:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
 75402:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 75397: 
 76244: #include "vm/Debugger.h"
 75397: #include "jsapi.h"
 75397: #include "jscntxt.h"
 84160: #include "jsnum.h"
 75397: #include "jsobj.h"
 75398: #include "jswrapper.h"
 77434: #include "jsarrayinlines.h"
 91956: #include "jsgcinlines.h"
120240: #include "jsinterpinlines.h"
 75398: #include "jsobjinlines.h"
 75504: #include "jsopcodeinlines.h"
118854: #include "jscompartment.h"
 80506: 
 80507: #include "frontend/BytecodeCompiler.h"
 80964: #include "frontend/BytecodeEmitter.h"
 97569: #include "gc/Marking.h"
 75506: #include "methodjit/Retcon.h"
 91956: #include "js/Vector.h"
 80506: 
 75418: #include "vm/Stack-inl.h"
 75397: 
 75397: using namespace js;
121250: 
105835: using js::frontend::IsIdentifier;
121250: using mozilla::Maybe;
 75397: 
 75466: 
 76236: /*** Forward declarations ************************************************************************/
 75413: 
 75513: extern Class DebuggerFrame_class;
 75413: 
 75413: enum {
 75417:     JSSLOT_DEBUGFRAME_OWNER,
 75418:     JSSLOT_DEBUGFRAME_ARGUMENTS,
 77171:     JSSLOT_DEBUGFRAME_ONSTEP_HANDLER,
 91435:     JSSLOT_DEBUGFRAME_ONPOP_HANDLER,
 75417:     JSSLOT_DEBUGFRAME_COUNT
 75413: };
 75413: 
 75513: extern Class DebuggerArguments_class;
 75464: 
 75464: enum {
 75464:     JSSLOT_DEBUGARGUMENTS_FRAME,
 75464:     JSSLOT_DEBUGARGUMENTS_COUNT
 75464: };
 75464: 
 84307: extern Class DebuggerEnv_class;
 84307: 
 84307: enum {
 84307:     JSSLOT_DEBUGENV_OWNER,
124078:     JSSLOT_DEBUGENV_GC_GRAY_LINK,
 84307:     JSSLOT_DEBUGENV_COUNT
 84307: };
 84307: 
 75513: extern Class DebuggerObject_class;
 75418: 
 75418: enum {
 75418:     JSSLOT_DEBUGOBJECT_OWNER,
124078:     JSSLOT_DEBUGOBJECT_GC_GRAY_LINK,
 75418:     JSSLOT_DEBUGOBJECT_COUNT
 75418: };
 75418: 
 75513: extern Class DebuggerScript_class;
 75492: 
 75492: enum {
 75492:     JSSLOT_DEBUGSCRIPT_OWNER,
124078:     JSSLOT_DEBUGSCRIPT_GC_GRAY_LINK,
 75492:     JSSLOT_DEBUGSCRIPT_COUNT
 75492: };
 75492: 
 75466: 
 76236: /*** Utils ***************************************************************************************/
 75413: 
 75398: bool
 91237: ReportMoreArgsNeeded(JSContext *cx, const char *name, unsigned required)
 75397: {
 75446:     JS_ASSERT(required > 0);
 75446:     JS_ASSERT(required <= 10);
 75399:     char s[2];
 75446:     s[0] = '0' + (required - 1);
 75399:     s[1] = '\0';
 75398:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
111508:                          name, s, required == 2 ? "" : "s");
 75397:     return false;
 75397: }
 75397: 
 75398: #define REQUIRE_ARGC(name, n)                                                 \
 75398:     JS_BEGIN_MACRO                                                            \
 75472:         if (argc < (n))                                                       \
 75398:             return ReportMoreArgsNeeded(cx, name, n);                         \
 75398:     JS_END_MACRO
 75398: 
 75398: bool
 75402: ReportObjectRequired(JSContext *cx)
 75397: {
 75398:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
 75398:     return false;
 75397: }
 75397: 
 84307: bool
 84307: ValueToIdentifier(JSContext *cx, const Value &v, jsid *idp)
 84307: {
 84307:     jsid id;
 84307:     if (!ValueToId(cx, v, &id))
 84307:         return false;
 84307:     if (!JSID_IS_ATOM(id) || !IsIdentifier(JSID_TO_ATOM(id))) {
108174:         RootedValue val(cx, v);
 84307:         js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_UNEXPECTED_TYPE,
108174:                                  JSDVG_SEARCH_STACK, val, NullPtr(), "not an identifier", NULL);
 84307:         return false;
 84307:     }
 84307:     *idp = id;
 84307:     return true;
 84307: }
 84307: 
 91432: /*
 91432:  * A range of all the Debugger.Frame objects for a particular StackFrame.
 91432:  *
 91432:  * FIXME This checks only current debuggers, so it relies on a hack in
 91432:  * Debugger::removeDebuggeeGlobal to make sure only current debuggers have Frame
 91432:  * objects with .live === true.
 91432:  */
101773: class Debugger::FrameRange
101773: {
 91432:     StackFrame *fp;
 91432: 
 91432:     /* The debuggers in |fp|'s compartment, or NULL if there are none. */
 91432:     GlobalObject::DebuggerVector *debuggers;
 91432: 
 91432:     /*
 91432:      * The index of the front Debugger.Frame's debugger in debuggers.
 91432:      * nextDebugger < debuggerCount if and only if the range is not empty.
 91432:      */
 91432:     size_t debuggerCount, nextDebugger;
 91432: 
 91432:     /*
 91432:      * If the range is not empty, this is front Debugger.Frame's entry in its
 91432:      * debugger's frame table.
 91432:      */
 91432:     FrameMap::Ptr entry;
 91432: 
 91432:   public:
 91432:     /*
 91432:      * Return a range containing all Debugger.Frame instances referring to |fp|.
 91432:      * |global| is |fp|'s global object; if NULL or omitted, we compute it
 91432:      * ourselves from |fp|.
 91432:      *
 91432:      * We keep an index into the compartment's debugger list, and a
 91432:      * FrameMap::Ptr into the current debugger's frame map. Thus, if the set of
 91432:      * debuggers in |fp|'s compartment changes, this range becomes invalid.
 91432:      * Similarly, if stack frames are added to or removed from frontDebugger(),
 91432:      * then the range's front is invalid until popFront is called.
 91432:      */
101773:     FrameRange(StackFrame *fp, GlobalObject *global = NULL)
101773:       : fp(fp)
101773:     {
 91432:         nextDebugger = 0;
 91432: 
 91432:         /* Find our global, if we were not given one. */
 91432:         if (!global)
 96793:             global = &fp->global();
 91432: 
 91432:         /* The frame and global must match. */
 96793:         JS_ASSERT(&fp->global() == global);
 91432: 
 91432:         /* Find the list of debuggers we'll iterate over. There may be none. */
 91432:         debuggers = global->getDebuggers();
 91432:         if (debuggers) {
 91432:             debuggerCount = debuggers->length();
 91432:             findNext();
 91432:         } else {
 91432:             debuggerCount = 0;
 91432:         }
 91432:     }
 91432: 
 91432:     bool empty() const {
 91432:         return nextDebugger >= debuggerCount;
 91432:     }
 91432: 
 91432:     JSObject *frontFrame() const {
 91432:         JS_ASSERT(!empty());
 91432:         return entry->value;
 91432:     }
 91432: 
 91432:     Debugger *frontDebugger() const {
 91432:         JS_ASSERT(!empty());
 91432:         return (*debuggers)[nextDebugger];
 91432:     }
 91432: 
 91432:     /*
 91432:      * Delete the front frame from its Debugger's frame map. After this call,
 91432:      * the range's front is invalid until popFront is called.
 91432:      */
 91432:     void removeFrontFrame() const {
 91432:         JS_ASSERT(!empty());
 91432:         frontDebugger()->frames.remove(entry);
 91432:     }
 91432: 
 91432:     void popFront() {
 91432:         JS_ASSERT(!empty());
 91432:         nextDebugger++;
 91432:         findNext();
 91432:     }
 91432: 
 91432:   private:
 91432:     /*
 91432:      * Either make this range refer to the first appropriate Debugger.Frame at
 91432:      * or after nextDebugger, or make it empty.
 91432:      */
 91432:     void findNext() {
 91432:         while (!empty()) {
 91432:             Debugger *dbg = (*debuggers)[nextDebugger];
 91432:             entry = dbg->frames.lookup(fp);
 91432:             if (entry)
 91432:                 break;
 91432:             nextDebugger++;
 91432:         }
 91432:     }
 91432: };
 91432: 
 75466: 
 76236: /*** Breakpoints *********************************************************************************/
 75506: 
 75506: BreakpointSite::BreakpointSite(JSScript *script, jsbytecode *pc)
104376:   : script(script), pc(pc), enabledCount(0),
 75506:     trapHandler(NULL), trapClosure(UndefinedValue())
 75506: {
 84195:     JS_ASSERT(!script->hasBreakpointsAt(pc));
 75506:     JS_INIT_CLIST(&breakpoints);
 75506: }
 75506: 
 94740: void
 94740: BreakpointSite::recompile(FreeOp *fop)
 75506: {
 75506: #ifdef JS_METHODJIT
106782:     if (script->hasMJITInfo()) {
 94740:         mjit::Recompiler::clearStackReferences(fop, script);
 94740:         mjit::ReleaseScriptCode(fop, script);
 75506:     }
 75506: #endif
 94740: }
 94740: 
 94740: void
 94740: BreakpointSite::inc(FreeOp *fop)
 75506: {
 94740:     if (enabledCount == 0 && !trapHandler)
 94740:         recompile(fop);
 75506:     enabledCount++;
 75506: }
 75506: 
 75506: void
 94740: BreakpointSite::dec(FreeOp *fop)
 75506: {
 75506:     JS_ASSERT(enabledCount > 0);
 75506:     enabledCount--;
 84195:     if (enabledCount == 0 && !trapHandler)
 94740:         recompile(fop);
 94740: }
 94740: 
 94740: void
 94740: BreakpointSite::setTrap(FreeOp *fop, JSTrapHandler handler, const Value &closure)
 75506: {
 94740:     if (enabledCount == 0)
 94740:         recompile(fop);
 75506:     trapHandler = handler;
 75506:     trapClosure = closure;
 75506: }
 75506: 
 75506: void
 94740: BreakpointSite::clearTrap(FreeOp *fop, JSTrapHandler *handlerp, Value *closurep)
 75506: {
 75506:     if (handlerp)
 75506:         *handlerp = trapHandler;
 75506:     if (closurep)
 75506:         *closurep = trapClosure;
 75506: 
 75506:     trapHandler = NULL;
 82129:     trapClosure = UndefinedValue();
 75506:     if (enabledCount == 0) {
103783:         if (!fop->runtime()->isHeapBusy()) {
 77891:             /* If the GC is running then the script is being destroyed. */
 94740:             recompile(fop);
 94740:         }
 94740:         destroyIfEmpty(fop);
 75506:     }
 75506: }
 75506: 
 75506: void
 94740: BreakpointSite::destroyIfEmpty(FreeOp *fop)
 75506: {
 84195:     if (JS_CLIST_IS_EMPTY(&breakpoints) && !trapHandler)
 94740:         script->destroyBreakpointSite(fop, pc);
 75506: }
 75506: 
 75506: Breakpoint *
 75506: BreakpointSite::firstBreakpoint() const
 75506: {
 75506:     if (JS_CLIST_IS_EMPTY(&breakpoints))
 75506:         return NULL;
 75506:     return Breakpoint::fromSiteLinks(JS_NEXT_LINK(&breakpoints));
 75506: }
 75506: 
 75506: bool
 75506: BreakpointSite::hasBreakpoint(Breakpoint *bp)
 75506: {
 75506:     for (Breakpoint *p = firstBreakpoint(); p; p = p->nextInSite())
 75506:         if (p == bp)
 75506:             return true;
 75506:     return false;
 75506: }
 75506: 
 75513: Breakpoint::Breakpoint(Debugger *debugger, BreakpointSite *site, JSObject *handler)
 75506:     : debugger(debugger), site(site), handler(handler)
 75506: {
 75506:     JS_APPEND_LINK(&debuggerLinks, &debugger->breakpoints);
 75506:     JS_APPEND_LINK(&siteLinks, &site->breakpoints);
 75506: }
 75506: 
 75506: Breakpoint *
 75506: Breakpoint::fromDebuggerLinks(JSCList *links)
 75506: {
 75506:     return (Breakpoint *) ((unsigned char *) links - offsetof(Breakpoint, debuggerLinks));
 75506: }
 75506: 
 75506: Breakpoint *
 75506: Breakpoint::fromSiteLinks(JSCList *links)
 75506: {
 75506:     return (Breakpoint *) ((unsigned char *) links - offsetof(Breakpoint, siteLinks));
 75506: }
 75506: 
 75506: void
 94740: Breakpoint::destroy(FreeOp *fop)
 75506: {
 75506:     if (debugger->enabled)
 94740:         site->dec(fop);
 75506:     JS_REMOVE_LINK(&debuggerLinks);
 75506:     JS_REMOVE_LINK(&siteLinks);
 94740:     site->destroyIfEmpty(fop);
 94740:     fop->delete_(this);
 75506: }
 75506: 
 75506: Breakpoint *
 75506: Breakpoint::nextInDebugger()
 75506: {
 75506:     JSCList *link = JS_NEXT_LINK(&debuggerLinks);
 75506:     return (link == &debugger->breakpoints) ? NULL : fromDebuggerLinks(link);
 75506: }
 75506: 
 75506: Breakpoint *
 75506: Breakpoint::nextInSite()
 75506: {
 75506:     JSCList *link = JS_NEXT_LINK(&siteLinks);
 75506:     return (link == &site->breakpoints) ? NULL : fromSiteLinks(link);
 75506: }
 75506: 
 76236: /*** Debugger hook dispatch **********************************************************************/
 75402: 
 76226: Debugger::Debugger(JSContext *cx, JSObject *dbg)
 76226:   : object(dbg), uncaughtExceptionHook(NULL), enabled(true),
 84307:     frames(cx), scripts(cx), objects(cx), environments(cx)
 75402: {
 76226:     assertSameCompartment(cx, dbg);
 76226: 
124575:     cx->runtime->debuggerList.insertBack(this);
 75506:     JS_INIT_CLIST(&breakpoints);
118853:     JS_INIT_CLIST(&onNewGlobalObjectWatchersLink);
 75451: }
 75451: 
 75513: Debugger::~Debugger()
 75451: {
 75489:     JS_ASSERT(debuggees.empty());
 75452: 
 76236:     /* This always happens in the GC thread, so no locking is required. */
103783:     JS_ASSERT(object->compartment()->rt->isHeapBusy());
118853: 
118853:     /*
118853:      * Since the inactive state for this link is a singleton cycle, it's always
118853:      * safe to apply JS_REMOVE_LINK to it, regardless of whether we're in the list or not.
118853:      */
118853:     JS_REMOVE_LINK(&onNewGlobalObjectWatchersLink);
 75402: }
 75402: 
 75413: bool
 75513: Debugger::init(JSContext *cx)
 75413: {
 84307:     bool ok = debuggees.init() &&
 84307:               frames.init() &&
 84307:               scripts.init() &&
 75492:               objects.init() &&
 84307:               environments.init();
 75452:     if (!ok)
 75452:         js_ReportOutOfMemory(cx);
 75452:     return ok;
 75413: }
 75413: 
 91237: JS_STATIC_ASSERT(unsigned(JSSLOT_DEBUGFRAME_OWNER) == unsigned(JSSLOT_DEBUGSCRIPT_OWNER));
 91237: JS_STATIC_ASSERT(unsigned(JSSLOT_DEBUGFRAME_OWNER) == unsigned(JSSLOT_DEBUGOBJECT_OWNER));
 91237: JS_STATIC_ASSERT(unsigned(JSSLOT_DEBUGFRAME_OWNER) == unsigned(JSSLOT_DEBUGENV_OWNER));
 75425: 
 75513: Debugger *
 75513: Debugger::fromChildJSObject(JSObject *obj)
 75425: {
 77817:     JS_ASSERT(obj->getClass() == &DebuggerFrame_class ||
 84307:               obj->getClass() == &DebuggerScript_class ||
 77817:               obj->getClass() == &DebuggerObject_class ||
 84307:               obj->getClass() == &DebuggerEnv_class);
 75425:     JSObject *dbgobj = &obj->getReservedSlot(JSSLOT_DEBUGOBJECT_OWNER).toObject();
 75425:     return fromJSObject(dbgobj);
 75425: }
 75425: 
 75413: bool
 75513: Debugger::getScriptFrame(JSContext *cx, StackFrame *fp, Value *vp)
 75413: {
 75413:     FrameMap::AddPtr p = frames.lookupForAdd(fp);
 75413:     if (!p) {
 76236:         /* Create and populate the Debugger.Frame object. */
 75413:         JSObject *proto = &object->getReservedSlot(JSSLOT_DEBUG_FRAME_PROTO).toObject();
 75513:         JSObject *frameobj =
 83275:             NewObjectWithGivenProto(cx, &DebuggerFrame_class, proto, NULL);
 83231:         if (!frameobj)
 75413:             return false;
 75413:         frameobj->setPrivate(fp);
 75417:         frameobj->setReservedSlot(JSSLOT_DEBUGFRAME_OWNER, ObjectValue(*object));
 75418: 
 75413:         if (!frames.add(p, fp, frameobj)) {
 75413:             js_ReportOutOfMemory(cx);
 75413:             return false;
 75413:         }
 75413:     }
 75413:     vp->setObject(*p->value);
 75413:     return true;
 75413: }
 75413: 
 76234: JSObject *
 76234: Debugger::getHook(Hook hook) const
 76234: {
 76234:     JS_ASSERT(hook >= 0 && hook < HookCount);
 76234:     const Value &v = object->getReservedSlot(JSSLOT_DEBUG_HOOK_START + hook);
 76234:     return v.isUndefined() ? NULL : &v.toObject();
 76234: }
 76234: 
 76234: bool
 89658: Debugger::hasAnyLiveHooks() const
 76234: {
 77171:     if (!enabled)
 77171:         return false;
 77171: 
 77171:     if (getHook(OnDebuggerStatement) ||
 76234:         getHook(OnExceptionUnwind) ||
 76234:         getHook(OnNewScript) ||
 77171:         getHook(OnEnterFrame))
 77173:     {
 77171:         return true;
 77173:     }
 77173: 
 77173:     /* If any breakpoints are in live scripts, return true. */
 77173:     for (Breakpoint *bp = firstBreakpoint(); bp; bp = bp->nextInDebugger()) {
 99246:         if (IsScriptMarked(&bp->site->script))
 77171:             return true;
 77173:     }
 77171: 
 77171:     for (FrameMap::Range r = frames.all(); !r.empty(); r.popFront()) {
 91435:         JSObject *frameObj = r.front().value;
 91435:         if (!frameObj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER).isUndefined() ||
 91435:             !frameObj->getReservedSlot(JSSLOT_DEBUGFRAME_ONPOP_HANDLER).isUndefined())
 77171:             return true;
 77171:     }
 77171: 
 77171:     return false;
 76234: }
 76234: 
 84070: JSTrapStatus
 84070: Debugger::slowPathOnEnterFrame(JSContext *cx, Value *vp)
 75523: {
 76236:     /* Build the list of recipients. */
 75523:     AutoValueVector triggered(cx);
 99421:     Rooted<GlobalObject*> global(cx, &cx->fp()->global());
 75523:     if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
 75523:         for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++) {
 75523:             Debugger *dbg = *p;
 75523:             JS_ASSERT(dbg->observesFrame(cx->fp()));
 75523:             if (dbg->observesEnterFrame() && !triggered.append(ObjectValue(*dbg->toJSObject())))
 84070:                 return JSTRAP_ERROR;
 75523:         }
 75523:     }
 75523: 
 76236:     /* Deliver the event, checking again as in dispatchHook. */
 75523:     for (Value *p = triggered.begin(); p != triggered.end(); p++) {
 75523:         Debugger *dbg = Debugger::fromJSObject(&p->toObject());
 84070:         if (dbg->debuggees.has(global) && dbg->observesEnterFrame()) {
 84070:             JSTrapStatus status = dbg->fireEnterFrame(cx, vp);
 84070:             if (status != JSTRAP_CONTINUE)
 84070:                 return status;
 84070:         }
 84070:     }
 84070: 
 84070:     return JSTRAP_CONTINUE;
 75523: }
 75523: 
 91435: /*
 91435:  * Handle leaving a frame with debuggers watching. |frameOk| indicates whether
 91435:  * the frame is exiting normally or abruptly. Set |cx|'s exception and/or
 91435:  * |cx->fp()|'s return value, and return a new success value.
 91435:  */
 91435: bool
 91435: Debugger::slowPathOnLeaveFrame(JSContext *cx, bool frameOk)
 75413: {
 75415:     StackFrame *fp = cx->fp();
 99421:     Rooted<GlobalObject*> global(cx, &fp->global());
 91435: 
 91435:     /* Save the frame's completion value. */
 91435:     JSTrapStatus status;
 99421:     RootedValue value(cx);
 97353:     Debugger::resultToCompletion(cx, frameOk, fp->returnValue(), &status, value.address());
 91435: 
 91435:     /* Build a list of the recipients. */
 91435:     AutoObjectVector frames(cx);
101773:     for (FrameRange r(fp, global); !r.empty(); r.popFront()) {
 91435:         if (!frames.append(r.frontFrame())) {
 91435:             cx->clearPendingException();
 91435:             return false;
 91435:         }
 91435:     }
 91435: 
 91435:     /* For each Debugger.Frame, fire its onPop handler, if any. */
 91435:     for (JSObject **p = frames.begin(); p != frames.end(); p++) {
 99421:         RootedObject frameobj(cx, *p);
 91435:         Debugger *dbg = Debugger::fromChildJSObject(frameobj);
 91435: 
 91435:         if (dbg->enabled &&
 91435:             !frameobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONPOP_HANDLER).isUndefined()) {
 99421:             RootedValue handler(cx, frameobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONPOP_HANDLER));
 91435: 
109257:             Maybe<AutoCompartment> ac;
109257:             ac.construct(cx, dbg->object);
 91435: 
 91435:             Value completion;
 91435:             if (!dbg->newCompletionValue(cx, status, value, &completion)) {
 91435:                 status = dbg->handleUncaughtException(ac, NULL, false);
 91435:                 break;
 91435:             }
 91435: 
 91435:             /* Call the onPop handler. */
 91435:             Value rval;
 91435:             bool hookOk = Invoke(cx, ObjectValue(*frameobj), handler, 1, &completion, &rval);
 91435:             Value nextValue;
 91435:             JSTrapStatus nextStatus = dbg->parseResumptionValue(ac, hookOk, rval, &nextValue);
 91435: 
 91435:             /*
 91435:              * At this point, we are back in the debuggee compartment, and any error has
 91435:              * been wrapped up as a completion value.
 91435:              */
 91435:             JS_ASSERT(cx->compartment == global->compartment());
 91435:             JS_ASSERT(!cx->isExceptionPending());
 91435: 
 91435:             /* JSTRAP_CONTINUE means "make no change". */
 91435:             if (nextStatus != JSTRAP_CONTINUE) {
 91435:                 status = nextStatus;
 91435:                 value = nextValue;
 91435:             }
 91435:         }
 91435:     }
 91435: 
 91435:     /*
 91435:      * Clean up all Debugger.Frame instances. Use a fresh FrameRange, as one
 91435:      * debugger's onPop handler could have caused another debugger to create its
 91435:      * own Debugger.Frame instance.
 91435:      */
101773:     for (FrameRange r(fp, global); !r.empty(); r.popFront()) {
119065:         RootedObject frameobj(cx, r.frontFrame());
 91435:         Debugger *dbg = r.frontDebugger();
 91435:         JS_ASSERT(dbg == Debugger::fromChildJSObject(frameobj));
 91432: 
 75413:         frameobj->setPrivate(NULL);
 77171: 
 77171:         /* If this frame had an onStep handler, adjust the script's count. */
 77171:         if (!frameobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER).isUndefined() &&
 91435:             !fp->script()->changeStepModeCount(cx, -1))
 91432:         {
 91435:             status = JSTRAP_ERROR;
 91435:             /* Don't exit the loop; we must mark all frames as dead. */
 91435:         }
 91435: 
 91435:         dbg->frames.remove(fp);
 75413:     }
 75506: 
 76236:     /*
 76236:      * If this is an eval frame, then from the debugger's perspective the
 76236:      * script is about to be destroyed. Remove any breakpoints in it.
 76236:      */
 75506:     if (fp->isEvalFrame()) {
119065:         RootedScript script(cx, fp->script());
 94959:         script->clearBreakpointsIn(cx->runtime->defaultFreeOp(), NULL, NULL);
 75506:     }
 91435: 
 91435:     /* Establish (status, value) as our resumption value. */
 91435:     switch (status) {
 91435:       case JSTRAP_RETURN:
 91435:         fp->setReturnValue(value);
 91435:         return true;
 91435: 
 91435:       case JSTRAP_THROW:
 91435:         cx->setPendingException(value);
 91435:         return false;
 91435: 
 91435:       case JSTRAP_ERROR:
 91435:         JS_ASSERT(!cx->isExceptionPending());
 91435:         return false;
 91435: 
 91435:       default:
 91435:         JS_NOT_REACHED("bad final trap status");
 91435:     }
 75452: }
 75413: 
 75418: bool
 97353: Debugger::wrapEnvironment(JSContext *cx, Handle<Env*> env, Value *rval)
 84307: {
 84307:     if (!env) {
 84307:         rval->setNull();
 84307:         return true;
 84307:     }
 84307: 
 98921:     /*
 98921:      * DebuggerEnv should only wrap a debug scope chain obtained (transitively)
 98921:      * from GetDebugScopeFor(Frame|Function).
 98921:      */
 98921:     JS_ASSERT(!env->isScope());
 98921: 
 84307:     JSObject *envobj;
 84307:     ObjectWeakMap::AddPtr p = environments.lookupForAdd(env);
 84307:     if (p) {
 84307:         envobj = p->value;
 84307:     } else {
 84307:         /* Create a new Debugger.Environment for env. */
 84307:         JSObject *proto = &object->getReservedSlot(JSSLOT_DEBUG_ENV_PROTO).toObject();
 84307:         envobj = NewObjectWithGivenProto(cx, &DebuggerEnv_class, proto, NULL);
 84307:         if (!envobj)
 84307:             return false;
109329:         envobj->setPrivateGCThing(env);
 84307:         envobj->setReservedSlot(JSSLOT_DEBUGENV_OWNER, ObjectValue(*object));
103637:         if (!environments.relookupOrAdd(p, env, envobj)) {
 84307:             js_ReportOutOfMemory(cx);
 84307:             return false;
 84307:         }
101637: 
101637:         CrossCompartmentKey key(CrossCompartmentKey::DebuggerEnvironment, object, env);
124656:         if (!object->compartment()->putWrapper(key, ObjectValue(*envobj))) {
101637:             environments.remove(env);
101637:             js_ReportOutOfMemory(cx);
101637:             return false;
101637:         }
 84307:     }
 84307:     rval->setObject(*envobj);
 84307:     return true;
 84307: }
 84307: 
 84307: bool
 75513: Debugger::wrapDebuggeeValue(JSContext *cx, Value *vp)
 75418: {
 82129:     assertSameCompartment(cx, object.get());
 75418: 
 75495:     if (vp->isObject()) {
 99421:         RootedObject obj(cx, &vp->toObject());
 75418: 
 82129:         ObjectWeakMap::AddPtr p = objects.lookupForAdd(obj);
 75418:         if (p) {
 75418:             vp->setObject(*p->value);
 75418:         } else {
 76236:             /* Create a new Debugger.Object for obj. */
 75428:             JSObject *proto = &object->getReservedSlot(JSSLOT_DEBUG_OBJECT_PROTO).toObject();
 75513:             JSObject *dobj =
 83275:                 NewObjectWithGivenProto(cx, &DebuggerObject_class, proto, NULL);
 83231:             if (!dobj)
 75418:                 return false;
109329:             dobj->setPrivateGCThing(obj);
 75418:             dobj->setReservedSlot(JSSLOT_DEBUGOBJECT_OWNER, ObjectValue(*object));
 75495:             if (!objects.relookupOrAdd(p, obj, dobj)) {
 75418:                 js_ReportOutOfMemory(cx);
 75418:                 return false;
 75418:             }
109329:             HashTableWriteBarrierPost(cx->compartment, &objects, obj);
101637: 
101637:             if (obj->compartment() != object->compartment()) {
101637:                 CrossCompartmentKey key(CrossCompartmentKey::DebuggerObject, object, obj);
124656:                 if (!object->compartment()->putWrapper(key, ObjectValue(*dobj))) {
101637:                     objects.remove(obj);
101637:                     js_ReportOutOfMemory(cx);
101637:                     return false;
101637:                 }
101637:             }
101637: 
 75418:             vp->setObject(*dobj);
 75418:         }
 75495:     } else if (!cx->compartment->wrap(cx, vp)) {
 75495:         vp->setUndefined();
 75495:         return false;
 75418:     }
 75495: 
 75418:     return true;
 75418: }
 75418: 
 75418: bool
 75513: Debugger::unwrapDebuggeeValue(JSContext *cx, Value *vp)
 75418: {
 82129:     assertSameCompartment(cx, object.get(), *vp);
 75418:     if (vp->isObject()) {
 75418:         JSObject *dobj = &vp->toObject();
 77817:         if (dobj->getClass() != &DebuggerObject_class) {
 75418:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_EXPECTED_TYPE,
 77817:                                  "Debugger", "Debugger.Object", dobj->getClass()->name);
 75418:             return false;
 75418:         }
 75456: 
 75456:         Value owner = dobj->getReservedSlot(JSSLOT_DEBUGOBJECT_OWNER);
102322:         if (owner.isUndefined() || &owner.toObject() != object) {
 75456:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
102322:                                  owner.isUndefined()
 75456:                                  ? JSMSG_DEBUG_OBJECT_PROTO
 75456:                                  : JSMSG_DEBUG_OBJECT_WRONG_OWNER);
 75456:             return false;
 75456:         }
 75456: 
 75495:         vp->setObject(*(JSObject *) dobj->getPrivate());
 75418:     }
 75418:     return true;
 75418: }
 75418: 
 75402: JSTrapStatus
109257: Debugger::handleUncaughtException(Maybe<AutoCompartment> &ac, Value *vp, bool callHook)
 75402: {
109257:     JSContext *cx = ac.ref().context();
 75404:     if (cx->isExceptionPending()) {
 75404:         if (callHook && uncaughtExceptionHook) {
 75404:             Value fval = ObjectValue(*uncaughtExceptionHook);
 75404:             Value exc = cx->getPendingException();
 75404:             Value rv;
 75404:             cx->clearPendingException();
 76829:             if (Invoke(cx, ObjectValue(*object), fval, 1, &exc, &rv))
 75518:                 return vp ? parseResumptionValue(ac, true, rv, vp, false) : JSTRAP_CONTINUE;
 75404:         }
 75404: 
 75404:         if (cx->isExceptionPending()) {
 75402:             JS_ReportPendingException(cx);
 75404:             cx->clearPendingException();
 75404:         }
 75404:     }
109257:     ac.destroy();
 75402:     return JSTRAP_ERROR;
 75402: }
 75402: 
 91434: void
 91434: Debugger::resultToCompletion(JSContext *cx, bool ok, const Value &rv,
 91434:                              JSTrapStatus *status, Value *value)
 91434: {
 91434:     JS_ASSERT_IF(ok, !cx->isExceptionPending());
 91434: 
 91434:     if (ok) {
 91434:         *status = JSTRAP_RETURN;
 91434:         *value = rv;
 91434:     } else if (cx->isExceptionPending()) {
 91434:         *status = JSTRAP_THROW;
 91434:         *value = cx->getPendingException();
 91434:         cx->clearPendingException();
 91434:     } else {
 91434:         *status = JSTRAP_ERROR;
 91434:         value->setUndefined();
 91434:     }
 91434: }
 91434: 
 75427: bool
 99364: Debugger::newCompletionValue(JSContext *cx, JSTrapStatus status, Value value_, Value *result)
 75427: {
 91434:     /*
 91434:      * We must be in the debugger's compartment, since that's where we want
 91434:      * to construct the completion value.
 91434:      */
 91434:     assertSameCompartment(cx, object.get());
 91434: 
 99421:     RootedId key(cx);
 99421:     RootedValue value(cx, value_);
 91434: 
 91434:     switch (status) {
 91434:       case JSTRAP_RETURN:
114201:         key = NameToId(cx->names().return_);
 91434:         break;
 91434: 
 91434:       case JSTRAP_THROW:
114201:         key = NameToId(cx->names().throw_);
 91434:         break;
 91434: 
 91434:       case JSTRAP_ERROR:
 91434:         result->setNull();
 75427:         return true;
 91434: 
 91434:       default:
 91434:         JS_NOT_REACHED("bad status passed to Debugger::newCompletionValue");
 91434:     }
 91434: 
 91434:     /* Common tail for JSTRAP_RETURN and JSTRAP_THROW. */
 99421:     RootedObject obj(cx, NewBuiltinClassInstance(cx, &ObjectClass));
 75427:     if (!obj ||
 99364:         !wrapDebuggeeValue(cx, value.address()) ||
 91434:         !DefineNativeProperty(cx, obj, key, value, JS_PropertyStub, JS_StrictPropertyStub,
 75443:                               JSPROP_ENUMERATE, 0, 0))
 75427:     {
 75427:         return false;
 75427:     }
 91434: 
 91434:     result->setObject(*obj);
 75427:     return true;
 75427: }
 75427: 
 91434: bool
109257: Debugger::receiveCompletionValue(Maybe<AutoCompartment> &ac, bool ok, Value val, Value *vp)
 91434: {
109257:     JSContext *cx = ac.ref().context();
 91434: 
 91434:     JSTrapStatus status;
 91434:     Value value;
 91434:     resultToCompletion(cx, ok, val, &status, &value);
109257:     ac.destroy();
 91434:     return newCompletionValue(cx, status, value, vp);
 91434: }
 91434: 
 75402: JSTrapStatus
109257: Debugger::parseResumptionValue(Maybe<AutoCompartment> &ac, bool ok, const Value &rv, Value *vp,
 75404:                                bool callHook)
 75402: {
 75402:     vp->setUndefined();
 75402:     if (!ok)
 75404:         return handleUncaughtException(ac, vp, callHook);
 75450:     if (rv.isUndefined()) {
109257:         ac.destroy();
 75402:         return JSTRAP_CONTINUE;
 75450:     }
 75450:     if (rv.isNull()) {
109257:         ac.destroy();
 75402:         return JSTRAP_ERROR;
 75450:     }
 75402: 
 76236:     /* Check that rv is {return: val} or {throw: val}. */
109257:     JSContext *cx = ac.ref().context();
102586:     Rooted<JSObject*> obj(cx);
103639:     Shape *shape;
114201:     jsid returnId = NameToId(cx->names().return_);
114201:     jsid throwId = NameToId(cx->names().throw_);
 75461:     bool okResumption = rv.isObject();
 75461:     if (okResumption) {
 75461:         obj = &rv.toObject();
 75461:         okResumption = obj->isObject();
 75461:     }
 75461:     if (okResumption) {
 75461:         shape = obj->lastProperty();
 75461:         okResumption = shape->previous() &&
 75461:              !shape->previous()->previous() &&
 83221:              (shape->propid() == returnId || shape->propid() == throwId) &&
 75461:              shape->isDataDescriptor();
 75461:     }
 75461:     if (!okResumption) {
 75402:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_BAD_RESUMPTION);
 75404:         return handleUncaughtException(ac, vp, callHook);
 75402:     }
 75402: 
 75427:     if (!js_NativeGet(cx, obj, obj, shape, 0, vp) || !unwrapDebuggeeValue(cx, vp))
 75404:         return handleUncaughtException(ac, vp, callHook);
 75402: 
109257:     ac.destroy();
 75427:     if (!cx->compartment->wrap(cx, vp)) {
 75427:         vp->setUndefined();
 75402:         return JSTRAP_ERROR;
 75402:     }
 83221:     return shape->propid() == returnId ? JSTRAP_RETURN : JSTRAP_THROW;
 75402: }
 75402: 
 75402: bool
 95355: CallMethodIfPresent(JSContext *cx, HandleObject obj, const char *name, int argc, Value *argv,
 75402:                     Value *rval)
 75402: {
 75402:     rval->setUndefined();
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
102586:     if (!atom)
102586:         return false;
102586: 
102586:     Rooted<jsid> id(cx, AtomToId(atom));
106862:     RootedValue fval(cx);
102586:     return GetMethod(cx, obj, id, 0, &fval) &&
102586:            (!js_IsCallable(fval) || Invoke(cx, ObjectValue(*obj), fval, argc, argv, rval));
 75402: }
 75402: 
 76226: JSTrapStatus
 76226: Debugger::fireDebuggerStatement(JSContext *cx, Value *vp)
 75439: {
 99421:     RootedObject hook(cx, getHook(OnDebuggerStatement));
 76226:     JS_ASSERT(hook);
 76226:     JS_ASSERT(hook->isCallable());
 76226: 
109257:     Maybe<AutoCompartment> ac;
109257:     ac.construct(cx, object);
 75402: 
 75413:     Value argv[1];
109257:     if (!getScriptFrame(cx, cx->fp(), argv))
 75450:         return handleUncaughtException(ac, vp, false);
 75413: 
 75402:     Value rv;
 76829:     bool ok = Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 1, argv, &rv);
 75402:     return parseResumptionValue(ac, ok, rv, vp);
 75402: }
 75402: 
 76226: JSTrapStatus
 76226: Debugger::fireExceptionUnwind(JSContext *cx, Value *vp)
 75439: {
 99421:     RootedObject hook(cx, getHook(OnExceptionUnwind));
 76226:     JS_ASSERT(hook);
 76226:     JS_ASSERT(hook->isCallable());
 76226: 
 99421:     RootedValue exc(cx, cx->getPendingException());
 75439:     cx->clearPendingException();
 76226: 
109257:     Maybe<AutoCompartment> ac;
109257:     ac.construct(cx, object);
 75439: 
 75439:     Value argv[2];
 97353:     AutoValueArray avr(cx, argv, 2);
 97353: 
 75439:     argv[1] = exc;
109257:     if (!getScriptFrame(cx, cx->fp(), &argv[0]) || !wrapDebuggeeValue(cx, &argv[1]))
 75450:         return handleUncaughtException(ac, vp, false);
 75439: 
 75439:     Value rv;
 76829:     bool ok = Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 2, argv, &rv);
 75439:     JSTrapStatus st = parseResumptionValue(ac, ok, rv, vp);
 75439:     if (st == JSTRAP_CONTINUE)
 75450:         cx->setPendingException(exc);
 75439:     return st;
 75439: }
 75439: 
 84070: JSTrapStatus
 84070: Debugger::fireEnterFrame(JSContext *cx, Value *vp)
 75523: {
 99421:     RootedObject hook(cx, getHook(OnEnterFrame));
 76226:     JS_ASSERT(hook);
 76226:     JS_ASSERT(hook->isCallable());
 76226: 
 75523:     StackFrame *fp = cx->fp();
109257:     Maybe<AutoCompartment> ac;
109257:     ac.construct(cx, object);
 75523: 
 75523:     Value argv[1];
 84070:     if (!getScriptFrame(cx, fp, &argv[0]))
 84070:         return handleUncaughtException(ac, vp, false);
 84070: 
 75523:     Value rv;
 84070:     bool ok = Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 1, argv, &rv);
 84070:     return parseResumptionValue(ac, ok, rv, vp);
 75523: }
 75523: 
 75523: void
101203: Debugger::fireNewScript(JSContext *cx, HandleScript script)
 75518: {
 99421:     RootedObject hook(cx, getHook(OnNewScript));
 76226:     JS_ASSERT(hook);
 76226:     JS_ASSERT(hook->isCallable());
 76226: 
109257:     Maybe<AutoCompartment> ac;
109257:     ac.construct(cx, object);
 75518: 
 80803:     JSObject *dsobj = wrapScript(cx, script);
 75518:     if (!dsobj) {
 75518:         handleUncaughtException(ac, NULL, false);
 75518:         return;
 75518:     }
 75518: 
 75518:     Value argv[1];
 75518:     argv[0].setObject(*dsobj);
 75518:     Value rv;
 76829:     if (!Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 1, argv, &rv))
 75518:         handleUncaughtException(ac, NULL, true);
 75518: }
 75518: 
 75439: JSTrapStatus
 84066: Debugger::dispatchHook(JSContext *cx, Value *vp, Hook which)
 75402: {
 76226:     JS_ASSERT(which == OnDebuggerStatement || which == OnExceptionUnwind);
 76226: 
 76236:     /*
 76236:      * Determine which debuggers will receive this event, and in what order.
 76236:      * Make a copy of the list, since the original is mutable and we will be
 76236:      * calling into arbitrary JS.
 76236:      *
 76236:      * Note: In the general case, 'triggered' contains references to objects in
 76236:      * different compartments--every compartment *except* this one.
 76236:      */
 75402:     AutoValueVector triggered(cx);
 99421:     Rooted<GlobalObject*> global(cx, &cx->fp()->global());
 75513:     if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
 75513:         for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++) {
 75513:             Debugger *dbg = *p;
 76234:             if (dbg->enabled && dbg->getHook(which)) {
 75402:                 if (!triggered.append(ObjectValue(*dbg->toJSObject())))
 75402:                     return JSTRAP_ERROR;
 75402:             }
 75402:         }
 75452:     }
 75402: 
 76236:     /*
 76236:      * Deliver the event to each debugger, checking again to make sure it
 76236:      * should still be delivered.
 76236:      */
 75402:     for (Value *p = triggered.begin(); p != triggered.end(); p++) {
 75513:         Debugger *dbg = Debugger::fromJSObject(&p->toObject());
 76234:         if (dbg->debuggees.has(global) && dbg->enabled && dbg->getHook(which)) {
 76226:             JSTrapStatus st = (which == OnDebuggerStatement)
 76226:                               ? dbg->fireDebuggerStatement(cx, vp)
 76226:                               : dbg->fireExceptionUnwind(cx, vp);
 75402:             if (st != JSTRAP_CONTINUE)
 75402:                 return st;
 75402:         }
 75402:     }
 75402:     return JSTRAP_CONTINUE;
 75402: }
 75402: 
 75518: static bool
 75518: AddNewScriptRecipients(GlobalObject::DebuggerVector *src, AutoValueVector *dest)
 75518: {
 75518:     bool wasEmpty = dest->length() == 0;
 75518:     for (Debugger **p = src->begin(); p != src->end(); p++) {
 75518:         Debugger *dbg = *p;
 75518:         Value v = ObjectValue(*dbg->toJSObject());
 75518:         if (dbg->observesNewScript() &&
 75518:             (wasEmpty || Find(dest->begin(), dest->end(), v) == dest->end()) &&
 75518:             !dest->append(v))
 75518:         {
 75518:             return false;
 75518:         }
 75518:     }
 75518:     return true;
 75518: }
 75518: 
 75518: void
119065: Debugger::slowPathOnNewScript(JSContext *cx, HandleScript script, GlobalObject *compileAndGoGlobal_)
119065: {
 99421:     Rooted<GlobalObject*> compileAndGoGlobal(cx, compileAndGoGlobal_);
 97353: 
 79905:     JS_ASSERT(script->compileAndGo == !!compileAndGoGlobal);
 79905: 
 76236:     /*
 76236:      * Build the list of recipients. For compile-and-go scripts, this is the
 76236:      * same as the generic Debugger::dispatchHook code, but non-compile-and-go
 76236:      * scripts are not tied to particular globals. We deliver them to every
 76236:      * debugger observing any global in the script's compartment.
 76236:      */
 75518:     AutoValueVector triggered(cx);
 75518:     if (script->compileAndGo) {
 79905:         if (GlobalObject::DebuggerVector *debuggers = compileAndGoGlobal->getDebuggers()) {
 75518:             if (!AddNewScriptRecipients(debuggers, &triggered))
 75518:                 return;
 75518:         }
 75518:     } else {
 77659:         GlobalObjectSet &debuggees = script->compartment()->getDebuggees();
 75518:         for (GlobalObjectSet::Range r = debuggees.all(); !r.empty(); r.popFront()) {
 75518:             if (!AddNewScriptRecipients(r.front()->getDebuggers(), &triggered))
 75518:                 return;
 75518:         }
 75518:     }
 75518: 
 76236:     /*
 76236:      * Deliver the event to each debugger, checking again as in
 76236:      * Debugger::dispatchHook.
 76236:      */
 75518:     for (Value *p = triggered.begin(); p != triggered.end(); p++) {
 75518:         Debugger *dbg = Debugger::fromJSObject(&p->toObject());
 79905:         if ((!compileAndGoGlobal || dbg->debuggees.has(compileAndGoGlobal)) &&
 79905:             dbg->enabled && dbg->getHook(OnNewScript)) {
 80803:             dbg->fireNewScript(cx, script);
 79905:         }
 75518:     }
 75518: }
 75518: 
 75506: JSTrapStatus
 75513: Debugger::onTrap(JSContext *cx, Value *vp)
 75506: {
 75506:     StackFrame *fp = cx->fp();
119065:     RootedScript script(cx, fp->script());
 99421:     Rooted<GlobalObject*> scriptGlobal(cx, &fp->global());
 75506:     jsbytecode *pc = cx->regs().pc;
 84195:     BreakpointSite *site = script->getBreakpointSite(pc);
 84195:     JSOp op = JSOp(*pc);
 75506: 
 76236:     /* Build list of breakpoint handlers. */
 75506:     Vector<Breakpoint *> triggered(cx);
 75506:     for (Breakpoint *bp = site->firstBreakpoint(); bp; bp = bp->nextInSite()) {
 75506:         if (!triggered.append(bp))
 75506:             return JSTRAP_ERROR;
 75506:     }
 75506: 
 75506:     for (Breakpoint **p = triggered.begin(); p != triggered.end(); p++) {
 75506:         Breakpoint *bp = *p;
 75506: 
 76236:         /* Handlers can clear breakpoints. Check that bp still exists. */
 75506:         if (!site || !site->hasBreakpoint(bp))
 75506:             continue;
 75506: 
 97693: 
 97693:         /*
 97693:          * There are two reasons we have to check whether dbg is enabled and
 97693:          * debugging scriptGlobal.
 97693:          *
 97693:          * One is just that one breakpoint handler can disable other Debuggers
 97693:          * or remove debuggees.
 97693:          *
 97693:          * The other has to do with non-compile-and-go scripts, which have no
 97693:          * specific global--until they are executed. Only now do we know which
 97693:          * global the script is running against.
 97693:          */
 75513:         Debugger *dbg = bp->debugger;
 75506:         if (dbg->enabled && dbg->debuggees.lookup(scriptGlobal)) {
109257:             Maybe<AutoCompartment> ac;
109257:             ac.construct(cx, dbg->object);
 75506: 
 75506:             Value argv[1];
104205:             AutoValueArray ava(cx, argv, 1);
 75506:             if (!dbg->getScriptFrame(cx, fp, &argv[0]))
 75506:                 return dbg->handleUncaughtException(ac, vp, false);
 75506:             Value rv;
102586:             Rooted<JSObject*> handler(cx, bp->handler);
102586:             bool ok = CallMethodIfPresent(cx, handler, "hit", 1, argv, &rv);
 75506:             JSTrapStatus st = dbg->parseResumptionValue(ac, ok, rv, vp, true);
 75506:             if (st != JSTRAP_CONTINUE)
 75506:                 return st;
 75506: 
 76236:             /* Calling JS code invalidates site. Reload it. */
 84195:             site = script->getBreakpointSite(pc);
 75506:         }
 75506:     }
 75506: 
 75506:     if (site && site->trapHandler) {
119065:         RootedScript fpscript(cx, fp->script());
119065:         JSTrapStatus st = site->trapHandler(cx, fpscript, pc, vp, site->trapClosure);
 75506:         if (st != JSTRAP_CONTINUE)
 75506:             return st;
 75506:     }
 75506: 
 76236:     /* By convention, return the true op to the interpreter in vp. */
 75506:     vp->setInt32(op);
 75506:     return JSTRAP_CONTINUE;
 75506: }
 75506: 
 77171: JSTrapStatus
 77171: Debugger::onSingleStep(JSContext *cx, Value *vp)
 77171: {
 77171:     StackFrame *fp = cx->fp();
 77171: 
 77171:     /*
 77171:      * We may be stepping over a JSOP_EXCEPTION, that pushes the context's
 77171:      * pending exception for a 'catch' clause to handle. Don't let the
 77171:      * onStep handlers mess with that (other than by returning a resumption
 77171:      * value).
 77171:      */
 99421:     RootedValue exception(cx, UndefinedValue());
 77171:     bool exceptionPending = cx->isExceptionPending();
 77171:     if (exceptionPending) {
 77171:         exception = cx->getPendingException();
 77171:         cx->clearPendingException();
 77171:     }
 77171: 
 77171:     /*
 77171:      * Build list of Debugger.Frame instances referring to this frame with
 77171:      * onStep handlers.
 77171:      */
 77171:     AutoObjectVector frames(cx);
101773:     for (FrameRange r(fp); !r.empty(); r.popFront()) {
 91432:         JSObject *frame = r.frontFrame();
 77171:         if (!frame->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER).isUndefined() &&
 77171:             !frames.append(frame))
 91432:         {
 77171:             return JSTRAP_ERROR;
 77171:         }
 77171:     }
 77171: 
 77171: #ifdef DEBUG
 77171:     /*
 77171:      * Validate the single-step count on this frame's script, to ensure that
 77171:      * we're not receiving traps we didn't ask for. Even when frames is
 77171:      * non-empty (and thus we know this trap was requested), do the check
 77171:      * anyway, to make sure the count has the correct non-zero value.
 77171:      *
 77171:      * The converse --- ensuring that we do receive traps when we should --- can
 77171:      * be done with unit tests.
 77171:      */
 77171:     {
119065:         AutoAssertNoGC nogc;
 84755:         uint32_t stepperCount = 0;
121004:         JSScript *trappingScript = fp->script().get(nogc);
 96793:         GlobalObject *global = &fp->global();
 77171:         if (GlobalObject::DebuggerVector *debuggers = global->getDebuggers()) {
 77171:             for (Debugger **p = debuggers->begin(); p != debuggers->end(); p++) {
 77171:                 Debugger *dbg = *p;
 77171:                 for (FrameMap::Range r = dbg->frames.all(); !r.empty(); r.popFront()) {
 77171:                     StackFrame *frame = r.front().key;
 77171:                     JSObject *frameobj = r.front().value;
109256:                     if (frame->script() == trappingScript &&
 77171:                         !frameobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER).isUndefined())
 77171:                     {
 77171:                         stepperCount++;
 77171:                     }
 77171:                 }
 77171:             }
 77171:         }
 77171:         if (trappingScript->compileAndGo)
 77171:             JS_ASSERT(stepperCount == trappingScript->stepModeCount());
 77171:         else
 77171:             JS_ASSERT(stepperCount <= trappingScript->stepModeCount());
 77171:     }
 77171: #endif
 77171: 
104051:     /* Preserve the debuggee's iterValue while handlers run. */
104051:     class PreserveIterValue {
104051:         JSContext *cx;
104051:         RootedValue savedIterValue;
104051: 
104051:       public:
104051:         PreserveIterValue(JSContext *cx) : cx(cx), savedIterValue(cx, cx->iterValue) {
104051:             cx->iterValue.setMagic(JS_NO_ITER_VALUE);
104051:         }
104051:         ~PreserveIterValue() {
104051:             cx->iterValue = savedIterValue;
104051:         }
104051:     };
104051:     PreserveIterValue piv(cx);
104051: 
 77171:     /* Call all the onStep handlers we found. */
 77171:     for (JSObject **p = frames.begin(); p != frames.end(); p++) {
 77171:         JSObject *frame = *p;
 77171:         Debugger *dbg = Debugger::fromChildJSObject(frame);
109257: 
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, dbg->object);
109257: 
 77171:         const Value &handler = frame->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER);
 77171:         Value rval;
 77171:         bool ok = Invoke(cx, ObjectValue(*frame), handler, 0, NULL, &rval);
 77171:         JSTrapStatus st = dbg->parseResumptionValue(ac, ok, rval, vp);
 77171:         if (st != JSTRAP_CONTINUE)
 77171:             return st;
 77171:     }
 77171: 
 77171:     vp->setUndefined();
 77171:     if (exceptionPending)
 77171:         cx->setPendingException(exception);
 77171:     return JSTRAP_CONTINUE;
 77171: }
 77171: 
118853: JSTrapStatus
118853: Debugger::fireNewGlobalObject(JSContext *cx, Handle<GlobalObject *> global, Value *vp)
118853: {
118853:     RootedObject hook(cx, getHook(OnNewGlobalObject));
118853:     JS_ASSERT(hook);
118853:     JS_ASSERT(hook->isCallable());
118853: 
118853:     Maybe<AutoCompartment> ac;
118853:     ac.construct(cx, object);
118853: 
118853:     Value argv[1];
118853:     argv[0].setObject(*global);
118853:     if (!wrapDebuggeeValue(cx, &argv[0]))
118853:         return handleUncaughtException(ac, NULL, false);
118853: 
118853:     Value rv;
118853:     bool ok = Invoke(cx, ObjectValue(*object), ObjectValue(*hook), 1, argv, &rv);
118853:     return parseResumptionValue(ac, ok, rv, vp);
118853: }
118853: 
118853: bool
118853: Debugger::slowPathOnNewGlobalObject(JSContext *cx, Handle<GlobalObject *> global)
118853: {
118853:     JS_ASSERT(!JS_CLIST_IS_EMPTY(&cx->runtime->onNewGlobalObjectWatchers));
118853: 
118853:     /*
118853:      * Make a copy of the runtime's onNewGlobalObjectWatchers before running the
118853:      * handlers. Since one Debugger's handler can disable another's, the list
118853:      * can be mutated while we're walking it.
118853:      */
118853:     AutoObjectVector watchers(cx);
118853:     for (JSCList *link = JS_LIST_HEAD(&cx->runtime->onNewGlobalObjectWatchers);
118853:          link != &cx->runtime->onNewGlobalObjectWatchers;
118853:          link = JS_NEXT_LINK(link)) {
118853:         Debugger *dbg = fromOnNewGlobalObjectWatchersLink(link);
118853:         JS_ASSERT(dbg->observesNewGlobalObject());
118853:         if (!watchers.append(dbg->object))
118853:             return false;
118853:     }
118853: 
118853:     JSTrapStatus status = JSTRAP_CONTINUE;
118853:     RootedValue value(cx);
118853: 
118853:     for (size_t i = 0; i < watchers.length(); i++) {
118853:         Debugger *dbg = fromJSObject(watchers[i]);
118853: 
118853:         // One Debugger's onNewGlobalObject handler can disable another's, so we
118853:         // must test this in the loop.
118853:         if (dbg->observesNewGlobalObject()) {
118853:             status = dbg->fireNewGlobalObject(cx, global, &value.get());
118853:             if (status != JSTRAP_CONTINUE && status != JSTRAP_RETURN)
118853:                 break;
118853:         }
118853:     }
118853: 
118853:     switch (status) {
118853:       case JSTRAP_CONTINUE:
118853:       case JSTRAP_RETURN: // Treat return like continue, ignoring the value.
118853:         return true;
118853: 
118853:       case JSTRAP_ERROR:
118853:         JS_ASSERT(!cx->isExceptionPending());
118853:         return false;
118853: 
118853:       case JSTRAP_THROW:
118853:         cx->setPendingException(value);
118853:         return false;
118853: 
118853:       default:
118853:         JS_NOT_REACHED("bad status from Debugger::fireNewGlobalObject");
118853:     }
118853: }
118853: 
 75466: 
 76236: /*** Debugger JSObjects **************************************************************************/
 75402: 
124078: JS_STATIC_ASSERT(unsigned(JSSLOT_DEBUGENV_GC_GRAY_LINK) ==
124078:                  unsigned(JSSLOT_DEBUGOBJECT_GC_GRAY_LINK));
124078: JS_STATIC_ASSERT(unsigned(JSSLOT_DEBUGENV_GC_GRAY_LINK) ==
124078:                  unsigned(JSSLOT_DEBUGSCRIPT_GC_GRAY_LINK));
124078: 
124086: /* static */ unsigned
124078: Debugger::gcGrayLinkSlot()
124078: {
124078:     return JSSLOT_DEBUGOBJECT_GC_GRAY_LINK;
124078: }
124078: 
124086: /* static */ bool
124086: Debugger::isDebugWrapper(RawObject o)
124086: {
124086:     Class *c = o->getClass();
124086:     return c == &DebuggerObject_class ||
124086:            c == &DebuggerEnv_class ||
124086:            c == &DebuggerScript_class;
124086: }
124086: 
 75495: void
 82129: Debugger::markKeysInCompartment(JSTracer *tracer)
 75510: {
 76261:     /*
 76261:      * WeakMap::Range is deliberately private, to discourage C++ code from
 76261:      * enumerating WeakMap keys. However in this case we need access, so we
 76261:      * make a base-class reference. Range is public in HashMap.
 76261:      */
124079:     objects.markKeys(tracer);
124079:     environments.markKeys(tracer);
124079:     scripts.markKeys(tracer);
 75510: }
 75510: 
 76236: /*
 76236:  * Ordinarily, WeakMap keys and values are marked because at some point it was
 76236:  * discovered that the WeakMap was live; that is, some object containing the
 76236:  * WeakMap was marked during mark phase.
 76236:  *
 94620:  * However, during compartment GC, we have to do something about
 94620:  * cross-compartment WeakMaps in non-GC'd compartments. If their keys and values
 94620:  * might need to be marked, we have to do it manually.
 76236:  *
 94620:  * Each Debugger object keeps three cross-compartment WeakMaps: objects, script,
 94620:  * and environments. They have the nice property that all their values are in
 94620:  * the same compartment as the Debugger object, so we only need to mark the
 94620:  * keys. We must simply mark all keys that are in a compartment being GC'd.
 76236:  *
 76236:  * We must scan all Debugger objects regardless of whether they *currently*
 94620:  * have any debuggees in a compartment being GC'd, because the WeakMap
 76236:  * entries persist even when debuggees are removed.
 76236:  *
 76236:  * This happens during the initial mark phase, not iterative marking, because
 76236:  * all the edges being reported here are strong references.
 76236:  */
 75510: void
 75513: Debugger::markCrossCompartmentDebuggerObjectReferents(JSTracer *tracer)
 75495: {
 82129:     JSRuntime *rt = tracer->runtime;
 75495: 
 76236:     /*
 76236:      * Mark all objects in comp that are referents of Debugger.Objects in other
 76236:      * compartments.
 76236:      */
124575:     for (Debugger *dbg = rt->debuggerList.getFirst(); dbg; dbg = dbg->getNext()) {
 94620:         if (!dbg->object->compartment()->isCollecting())
 82129:             dbg->markKeysInCompartment(tracer);
 75495:     }
 75495: }
 75495: 
 76236: /*
 76236:  * This method has two tasks:
 76236:  *   1. Mark Debugger objects that are unreachable except for debugger hooks that
 76236:  *      may yet be called.
 76236:  *   2. Mark breakpoint handlers.
 76236:  *
 76256:  * This happens during the iterative part of the GC mark phase. This method
 76256:  * returns true if it has to mark anything; GC calls it repeatedly until it
 76256:  * returns false.
 76236:  */
 75402: bool
 78102: Debugger::markAllIteratively(GCMarker *trc)
 75402: {
 75452:     bool markedAny = false;
 75452: 
 76236:     /*
 77173:      * Find all Debugger objects in danger of GC. This code is a little
 76236:      * convoluted since the easiest way to find them is via their debuggees.
 76236:      */
 89658:     JSRuntime *rt = trc->runtime;
 94620:     for (CompartmentsIter c(rt); !c.done(); c.next()) {
 99246:         GlobalObjectSet &debuggees = c->getDebuggees();
 99246:         for (GlobalObjectSet::Enum e(debuggees); !e.empty(); e.popFront()) {
 99246:             GlobalObject *global = e.front();
 99246:             if (!IsObjectMarked(&global))
 89249:                 continue;
109329:             else if (global != e.front())
 99246:                 e.rekeyFront(global);
 75452: 
 76236:             /*
 76236:              * Every debuggee has at least one debugger, so in this case
 76236:              * getDebuggers can't return NULL.
 76236:              */
 75513:             const GlobalObject::DebuggerVector *debuggers = global->getDebuggers();
 75487:             JS_ASSERT(debuggers);
 87810:             for (Debugger * const *p = debuggers->begin(); p != debuggers->end(); p++) {
 75513:                 Debugger *dbg = *p;
 75402: 
 76236:                 /*
 76236:                  * dbg is a Debugger with at least one debuggee. Check three things:
124077:                  *   - dbg is actually in a compartment that is being marked
 76236:                  *   - it isn't already marked
 76236:                  *   - it actually has hooks that might be called
 76236:                  */
 90409:                 HeapPtrObject &dbgobj = dbg->toJSObjectRef();
124077:                 if (!dbgobj->compartment()->isGCMarking())
 77173:                     continue;
 77173: 
 99246:                 bool dbgMarked = IsObjectMarked(&dbgobj);
 89658:                 if (!dbgMarked && dbg->hasAnyLiveHooks()) {
 76236:                     /*
 76236:                      * obj could be reachable only via its live, enabled
 76236:                      * debugger hooks, which may yet be called.
 76236:                      */
 90409:                     MarkObject(trc, &dbgobj, "enabled Debugger");
 75402:                     markedAny = true;
 77173:                     dbgMarked = true;
 77173:                 }
 77173: 
 77173:                 if (dbgMarked) {
 77173:                     /* Search for breakpoints to mark. */
 77173:                     for (Breakpoint *bp = dbg->firstBreakpoint(); bp; bp = bp->nextInDebugger()) {
 99246:                         if (IsScriptMarked(&bp->site->script)) {
 77173:                             /*
 77173:                              * The debugger and the script are both live.
 77173:                              * Therefore the breakpoint handler is live.
 77173:                              */
 99246:                             if (!IsObjectMarked(&bp->getHandlerRef())) {
 90409:                                 MarkObject(trc, &bp->getHandlerRef(), "breakpoint handler");
 77173:                                 markedAny = true;
 77173:                             }
 77173:                         }
 77173:                     }
 75402:                 }
 75402:             }
 75418:         }
 75402:     }
 75402:     return markedAny;
 75402: }
 75402: 
 75402: void
115876: Debugger::traceObject(JSTracer *trc, RawObject obj)
 75402: {
 75513:     if (Debugger *dbg = Debugger::fromJSObject(obj))
 75486:         dbg->trace(trc);
 75486: }
 75486: 
 75486: void
 75513: Debugger::trace(JSTracer *trc)
 75486: {
 75486:     if (uncaughtExceptionHook)
 90409:         MarkObject(trc, &uncaughtExceptionHook, "hooks");
 75413: 
 76236:     /*
 77171:      * Mark Debugger.Frame objects. These are all reachable from JS, because the
 77171:      * corresponding StackFrames are still on the stack.
 77171:      *
 77171:      * (Once we support generator frames properly, we will need
 77171:      * weakly-referenced Debugger.Frame objects as well, for suspended generator
 77171:      * frames.)
 76236:      */
 75487:     for (FrameMap::Range r = frames.all(); !r.empty(); r.popFront()) {
109329:         RelocatablePtrObject &frameobj = r.front().value;
 75449:         JS_ASSERT(frameobj->getPrivate());
 90409:         MarkObject(trc, &frameobj, "live Debugger.Frame");
 75413:     }
 75486: 
 84307:     /* Trace the weak map from JSScript instances to Debugger.Script objects. */
 84307:     scripts.trace(trc);
 84307: 
 76236:     /* Trace the referent -> Debugger.Object weak map. */
 75486:     objects.trace(trc);
 75492: 
 84307:     /* Trace the referent -> Debugger.Environment weak map. */
 84307:     environments.trace(trc);
 75413: }
 75413: 
 75413: void
 94738: Debugger::sweepAll(FreeOp *fop)
 75413: {
 94738:     JSRuntime *rt = fop->runtime();
 76256: 
124575:     for (Debugger *dbg = rt->debuggerList.getFirst(); dbg; dbg = dbg->getNext()) {
124075:         if (IsObjectAboutToBeFinalized(&dbg->object)) {
 76236:             /*
 94620:              * dbg is being GC'd. Detach it from its debuggees. The debuggee
 94620:              * might be GC'd too. Since detaching requires access to both
 94620:              * objects, this must be done before finalize time.
 76236:              */
 75470:             for (GlobalObjectSet::Enum e(dbg->debuggees); !e.empty(); e.popFront())
 94740:                 dbg->removeDebuggeeGlobal(fop, e.front(), NULL, &e);
 75470:         }
 75402:     }
 75452: 
 75505:     for (JSCompartment **c = rt->compartments.begin(); c != rt->compartments.end(); c++) {
 76236:         /* For each debuggee being GC'd, detach it from all its debuggers. */
 75505:         GlobalObjectSet &debuggees = (*c)->getDebuggees();
 75505:         for (GlobalObjectSet::Enum e(debuggees); !e.empty(); e.popFront()) {
 75505:             GlobalObject *global = e.front();
124075:             if (IsObjectAboutToBeFinalized(&global))
 94740:                 detachAllDebuggersFromGlobal(fop, global, &e);
109329:             else if (global != e.front())
 99246:                 e.rekeyFront(global);
 75505:         }
 75505:     }
 75452: }
 75452: 
 75452: void
 94740: Debugger::detachAllDebuggersFromGlobal(FreeOp *fop, GlobalObject *global,
 75513:                                        GlobalObjectSet::Enum *compartmentEnum)
 75453: {
 75513:     const GlobalObject::DebuggerVector *debuggers = global->getDebuggers();
 75453:     JS_ASSERT(!debuggers->empty());
 75453:     while (!debuggers->empty())
 94740:         debuggers->back()->removeDebuggeeGlobal(fop, global, compartmentEnum, NULL);
 75453: }
 75453: 
124079: /* static */ void
124079: Debugger::findCompartmentEdges(JSCompartment *comp, js::gc::ComponentFinder &finder)
124079: {
124079:     /*
124079:      * For debugger cross compartment wrappers, add edges in the opposite
124079:      * direction to those already added by JSCompartment::findOutgoingEdges.
124079:      * This ensure that debuggers and their debuggees are finalized in the same
124079:      * group.
124079:      */
124575:     for (Debugger *dbg = comp->rt->debuggerList.getFirst(); dbg; dbg = dbg->getNext()) {
124084:         JSCompartment *w = dbg->object->compartment();
124084:         if (w == comp || !w->isGCMarking())
124084:             continue;
124084:         if (dbg->scripts.hasKeyInCompartment(comp) ||
124084:             dbg->objects.hasKeyInCompartment(comp) ||
124084:             dbg->environments.hasKeyInCompartment(comp)) {
124084:             finder.addEdgeTo(w);
124084:         }
124079:     }
124079: }
124079: 
 75453: void
115877: Debugger::finalize(FreeOp *fop, RawObject obj)
 75402: {
 76256:     Debugger *dbg = fromJSObject(obj);
 75489:     if (!dbg)
 75489:         return;
 94620:     JS_ASSERT(dbg->debuggees.empty());
 94738:     fop->delete_(dbg);
 75402: }
 75412: 
 75513: Class Debugger::jsclass = {
 90410:     "Debugger",
 90410:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS |
 90410:     JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUG_COUNT),
 78614:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 78614:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, Debugger::finalize,
 75402:     NULL,                 /* checkAccess */
 75402:     NULL,                 /* call        */
 75402:     NULL,                 /* construct   */
 75402:     NULL,                 /* hasInstance */
 75513:     Debugger::traceObject
 75397: };
 75397: 
 76263: Debugger *
 76264: Debugger::fromThisValue(JSContext *cx, const CallArgs &args, const char *fnname)
 76263: {
 76264:     if (!args.thisv().isObject()) {
 76263:         ReportObjectRequired(cx);
 76263:         return NULL;
 76263:     }
 76264:     JSObject *thisobj = &args.thisv().toObject();
 76263:     if (thisobj->getClass() != &Debugger::jsclass) {
 76263:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 76263:                              "Debugger", fnname, thisobj->getClass()->name);
 76263:         return NULL;
 76263:     }
 76263: 
 76263:     /*
 76263:      * Forbid Debugger.prototype, which is of the Debugger JSClass but isn't
 76263:      * really a Debugger object. The prototype object is distinguished by
 76263:      * having a NULL private value.
 76263:      */
 76263:     Debugger *dbg = fromJSObject(thisobj);
 76263:     if (!dbg) {
 76263:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 76263:                              "Debugger", fnname, "prototype object");
 76263:     }
 76263:     return dbg;
 76263: }
 76263: 
 76264: #define THIS_DEBUGGER(cx, argc, vp, fnname, args, dbg)                       \
 76264:     CallArgs args = CallArgsFromVp(argc, vp);                                \
 76264:     Debugger *dbg = Debugger::fromThisValue(cx, args, fnname);               \
 76263:     if (!dbg)                                                                \
 76263:         return false
 76263: 
 75402: JSBool
 91237: Debugger::getEnabled(JSContext *cx, unsigned argc, Value *vp)
 76231: {
 76264:     THIS_DEBUGGER(cx, argc, vp, "get enabled", args, dbg);
 76264:     args.rval().setBoolean(dbg->enabled);
 76231:     return true;
 76231: }
 76231: 
 76231: JSBool
 91237: Debugger::setEnabled(JSContext *cx, unsigned argc, Value *vp)
 76231: {
 76231:     REQUIRE_ARGC("Debugger.set enabled", 1);
 76264:     THIS_DEBUGGER(cx, argc, vp, "set enabled", args, dbg);
106378:     bool enabled = ToBoolean(args[0]);
 76231: 
 76231:     if (enabled != dbg->enabled) {
 76231:         for (Breakpoint *bp = dbg->firstBreakpoint(); bp; bp = bp->nextInDebugger()) {
 94740:             if (enabled)
 94740:                 bp->site->inc(cx->runtime->defaultFreeOp());
 94740:             else
 94740:                 bp->site->dec(cx->runtime->defaultFreeOp());
 76231:         }
118853: 
118853:         /*
118853:          * Add or remove ourselves from the runtime's list of Debuggers
118853:          * that care about new globals.
118853:          */
118853:         if (dbg->getHook(OnNewGlobalObject)) {
118853:             if (enabled) {
118853:                 /* If we were not enabled, the link should be a singleton list. */
118853:                 JS_ASSERT(JS_CLIST_IS_EMPTY(&dbg->onNewGlobalObjectWatchersLink));
118853:                 JS_APPEND_LINK(&dbg->onNewGlobalObjectWatchersLink,
118853:                                &cx->runtime->onNewGlobalObjectWatchers);
118853:             } else {
118853:                 /* If we were enabled, the link should be inserted in the list. */
118853:                 JS_ASSERT(!JS_CLIST_IS_EMPTY(&dbg->onNewGlobalObjectWatchersLink));
118853:                 JS_REMOVE_AND_INIT_LINK(&dbg->onNewGlobalObjectWatchersLink);
118853:             }
118853:         }
 76231:     }
 76231: 
 76231:     dbg->enabled = enabled;
 76264:     args.rval().setUndefined();
 76231:     return true;
 76231: }
 76231: 
 76231: JSBool
 91237: Debugger::getHookImpl(JSContext *cx, unsigned argc, Value *vp, Hook which)
 75402: {
 76234:     JS_ASSERT(which >= 0 && which < HookCount);
 76264:     THIS_DEBUGGER(cx, argc, vp, "getHook", args, dbg);
106862:     args.rval().set(dbg->object->getReservedSlot(JSSLOT_DEBUG_HOOK_START + which));
 75402:     return true;
 75402: }
 75402: 
 75402: JSBool
 91237: Debugger::setHookImpl(JSContext *cx, unsigned argc, Value *vp, Hook which)
 75402: {
 76234:     JS_ASSERT(which >= 0 && which < HookCount);
 76226:     REQUIRE_ARGC("Debugger.setHook", 1);
 76264:     THIS_DEBUGGER(cx, argc, vp, "setHook", args, dbg);
103274:     if (args[0].isObject()) {
103274:         if (!args[0].toObject().isCallable())
103274:             return ReportIsNotFunction(cx, &args[0]);
103274:     } else if (!args[0].isUndefined()) {
 76234:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_CALLABLE_OR_UNDEFINED);
 76234:         return false;
 76234:     }
103274:     dbg->object->setReservedSlot(JSSLOT_DEBUG_HOOK_START + which, args[0]);
 76264:     args.rval().setUndefined();
 75402:     return true;
 75402: }
 75402: 
 75402: JSBool
 91237: Debugger::getOnDebuggerStatement(JSContext *cx, unsigned argc, Value *vp)
 76230: {
 76234:     return getHookImpl(cx, argc, vp, OnDebuggerStatement);
 76230: }
 76230: 
 76230: JSBool
 91237: Debugger::setOnDebuggerStatement(JSContext *cx, unsigned argc, Value *vp)
 76230: {
 76234:     return setHookImpl(cx, argc, vp, OnDebuggerStatement);
 76230: }
 76230: 
 76230: JSBool
 91237: Debugger::getOnExceptionUnwind(JSContext *cx, unsigned argc, Value *vp)
 76230: {
 76234:     return getHookImpl(cx, argc, vp, OnExceptionUnwind);
 76230: }
 76230: 
 76230: JSBool
 91237: Debugger::setOnExceptionUnwind(JSContext *cx, unsigned argc, Value *vp)
 76230: {
 76234:     return setHookImpl(cx, argc, vp, OnExceptionUnwind);
 76230: }
 76230: 
 76230: JSBool
 91237: Debugger::getOnNewScript(JSContext *cx, unsigned argc, Value *vp)
 76230: {
 76234:     return getHookImpl(cx, argc, vp, OnNewScript);
 76230: }
 76230: 
 76230: JSBool
 91237: Debugger::setOnNewScript(JSContext *cx, unsigned argc, Value *vp)
 76230: {
 76234:     return setHookImpl(cx, argc, vp, OnNewScript);
 76230: }
 76230: 
 76230: JSBool
 91237: Debugger::getOnEnterFrame(JSContext *cx, unsigned argc, Value *vp)
 76230: {
 76234:     return getHookImpl(cx, argc, vp, OnEnterFrame);
 76230: }
 76230: 
 76230: JSBool
 91237: Debugger::setOnEnterFrame(JSContext *cx, unsigned argc, Value *vp)
 76230: {
 76234:     return setHookImpl(cx, argc, vp, OnEnterFrame);
 76230: }
 76230: 
 76230: JSBool
118853: Debugger::getOnNewGlobalObject(JSContext *cx, unsigned argc, Value *vp)
118853: {
118853:     return getHookImpl(cx, argc, vp, OnNewGlobalObject);
118853: }
118853: 
118853: JSBool
118853: Debugger::setOnNewGlobalObject(JSContext *cx, unsigned argc, Value *vp)
118853: {
118853:     THIS_DEBUGGER(cx, argc, vp, "setOnNewGlobalObject", args, dbg);
118853:     JSObject *oldHook = dbg->getHook(OnNewGlobalObject);
118853: 
118853:     if (!setHookImpl(cx, argc, vp, OnNewGlobalObject))
118853:         return false;
118853: 
118853:     /*
118853:      * Add or remove ourselves from the runtime's list of Debuggers that
118853:      * care about new globals.
118853:      */
118853:     if (dbg->enabled) {
118853:         JSObject *newHook = dbg->getHook(OnNewGlobalObject);
118853:         if (!oldHook && newHook) {
118853:             /* If we didn't have a hook, the link should be a singleton list. */
118853:             JS_ASSERT(JS_CLIST_IS_EMPTY(&dbg->onNewGlobalObjectWatchersLink));
118853:             JS_APPEND_LINK(&dbg->onNewGlobalObjectWatchersLink,
118853:                            &cx->runtime->onNewGlobalObjectWatchers);
118853:         } else if (oldHook && !newHook) {
118853:             /* If we did have a hook, the link should be inserted in the list. */
118853:             JS_ASSERT(!JS_CLIST_IS_EMPTY(&dbg->onNewGlobalObjectWatchersLink));
118853:             JS_REMOVE_AND_INIT_LINK(&dbg->onNewGlobalObjectWatchersLink);
118853:         }
118853:     }
118853: 
118853:     return true;
118853: }
118853: 
118853: JSBool
 91237: Debugger::getUncaughtExceptionHook(JSContext *cx, unsigned argc, Value *vp)
 75404: {
 76264:     THIS_DEBUGGER(cx, argc, vp, "get uncaughtExceptionHook", args, dbg);
 76264:     args.rval().setObjectOrNull(dbg->uncaughtExceptionHook);
 75404:     return true;
 75404: }
 75404: 
 75404: JSBool
 91237: Debugger::setUncaughtExceptionHook(JSContext *cx, unsigned argc, Value *vp)
 75404: {
 75513:     REQUIRE_ARGC("Debugger.set uncaughtExceptionHook", 1);
 76264:     THIS_DEBUGGER(cx, argc, vp, "set uncaughtExceptionHook", args, dbg);
 76264:     if (!args[0].isNull() && (!args[0].isObject() || !args[0].toObject().isCallable())) {
 75405:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_ASSIGN_FUNCTION_OR_NULL,
 75405:                              "uncaughtExceptionHook");
 75405:         return false;
 75405:     }
 75405: 
 76264:     dbg->uncaughtExceptionHook = args[0].toObjectOrNull();
 76264:     args.rval().setUndefined();
 75404:     return true;
 75404: }
 75404: 
118851: GlobalObject *
 76264: Debugger::unwrapDebuggeeArgument(JSContext *cx, const Value &v)
 75456: {
118851:     if (!v.isObject()) {
118851:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
118851:                              "argument", "not a global object");
118851:         return NULL;
118851:     }
118851: 
118851:     RootedObject obj(cx, &v.toObject());
118851: 
118851:     /* If it's a Debugger.Object belonging to this debugger, dereference that. */
 77817:     if (obj->getClass() == &DebuggerObject_class) {
 76264:         Value rv = v;
 76264:         if (!unwrapDebuggeeValue(cx, &rv))
 75456:             return NULL;
118851:         obj = &rv.toObject();
118851:     }
118851: 
118851:     /* If we have a cross-compartment wrapper, dereference as far as is secure. */
121899:     obj = UnwrapObjectChecked(obj);
121899:     if (!obj) {
121899:         JS_ReportError(cx, "Permission denied to access object");
118851:         return NULL;
121899:     }
118851: 
118851:     /* If that produced an outer window, innerize it. */
118851:     obj = GetInnerObject(cx, obj);
118851:     if (!obj)
118851:         return NULL;
118851: 
118851:     /* If that didn't produce a global object, it's an error. */
118851:     if (!obj->isGlobal()) {
118851:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
118851:                              "argument", "not a global object");
118851:         return NULL;
118851:     }
118851: 
118851:     return &obj->asGlobal();
 75456: }
 75456: 
 75456: JSBool
 91237: Debugger::addDebuggee(JSContext *cx, unsigned argc, Value *vp)
 75456: {
 75513:     REQUIRE_ARGC("Debugger.addDebuggee", 1);
 76264:     THIS_DEBUGGER(cx, argc, vp, "addDebuggee", args, dbg);
118851:     Rooted<GlobalObject*> global(cx, dbg->unwrapDebuggeeArgument(cx, args[0]));
118851:     if (!global)
118851:         return false;
118851: 
 76253:     if (!dbg->addDebuggeeGlobal(cx, global))
 75456:         return false;
 75456: 
118851:     Value v = ObjectValue(*global);
 75456:     if (!dbg->wrapDebuggeeValue(cx, &v))
 75456:         return false;
106862:     args.rval().set(v);
 75456:     return true;
 75456: }
 75456: 
 75456: JSBool
 91237: Debugger::removeDebuggee(JSContext *cx, unsigned argc, Value *vp)
 75456: {
 75513:     REQUIRE_ARGC("Debugger.removeDebuggee", 1);
 76264:     THIS_DEBUGGER(cx, argc, vp, "removeDebuggee", args, dbg);
118851:     GlobalObject *global = dbg->unwrapDebuggeeArgument(cx, args[0]);
118851:     if (!global)
118851:         return false;
 75497:     if (dbg->debuggees.has(global))
 94740:         dbg->removeDebuggeeGlobal(cx->runtime->defaultFreeOp(), global, NULL, NULL);
 76264:     args.rval().setUndefined();
 75456:     return true;
 75456: }
 75456: 
 75456: JSBool
120760: Debugger::removeAllDebuggees(JSContext *cx, unsigned argc, Value *vp)
120760: {
120760:     THIS_DEBUGGER(cx, argc, vp, "removeAllDebuggees", args, dbg);
120760:     for (GlobalObjectSet::Enum e(dbg->debuggees); !e.empty(); e.popFront())
120760:         dbg->removeDebuggeeGlobal(cx->runtime->defaultFreeOp(), e.front(), NULL, &e);
120760:     args.rval().setUndefined();
120760:     return true;
120760: }
120760: 
120760: JSBool
 91237: Debugger::hasDebuggee(JSContext *cx, unsigned argc, Value *vp)
 75456: {
 75513:     REQUIRE_ARGC("Debugger.hasDebuggee", 1);
 76264:     THIS_DEBUGGER(cx, argc, vp, "hasDebuggee", args, dbg);
118851:     GlobalObject *global = dbg->unwrapDebuggeeArgument(cx, args[0]);
118851:     if (!global)
118851:         return false;
118851:     args.rval().setBoolean(!!dbg->debuggees.lookup(global));
 75456:     return true;
 75456: }
 75456: 
 75456: JSBool
 91237: Debugger::getDebuggees(JSContext *cx, unsigned argc, Value *vp)
 75456: {
 76264:     THIS_DEBUGGER(cx, argc, vp, "getDebuggees", args, dbg);
106505:     RootedObject arrobj(cx, NewDenseAllocatedArray(cx, dbg->debuggees.count()));
 75456:     if (!arrobj)
 75456:         return false;
 77434:     arrobj->ensureDenseArrayInitializedLength(cx, 0, dbg->debuggees.count());
 91237:     unsigned i = 0;
 75456:     for (GlobalObjectSet::Enum e(dbg->debuggees); !e.empty(); e.popFront()) {
 75456:         Value v = ObjectValue(*e.front());
 75456:         if (!dbg->wrapDebuggeeValue(cx, &v))
 75456:             return false;
 75456:         arrobj->setDenseArrayElement(i++, v);
 75456:     }
 76264:     args.rval().setObject(*arrobj);
 75456:     return true;
 75456: }
 75456: 
 75404: JSBool
 91237: Debugger::getNewestFrame(JSContext *cx, unsigned argc, Value *vp)
 75441: {
 76264:     THIS_DEBUGGER(cx, argc, vp, "getNewestFrame", args, dbg);
 75484: 
 76236:     /*
 76236:      * cx->fp() would return the topmost frame in the current context.
 76236:      * Since there may be multiple contexts, use AllFramesIter instead.
 76236:      */
 75485:     for (AllFramesIter i(cx->stack.space()); !i.done(); ++i) {
118567:         /*
118567:          * Debug-mode currently disables Ion compilation in the compartment of
118567:          * the debuggee.
118567:          */
118567:         if (i.isIon())
118567:             continue;
118567:         if (dbg->observesFrame(i.interpFrame()))
118567:             return dbg->getScriptFrame(cx, i.interpFrame(), vp);
 75484:     }
 76264:     args.rval().setNull();
 75441:     return true;
 75441: }
 75441: 
 75441: JSBool
 91237: Debugger::clearAllBreakpoints(JSContext *cx, unsigned argc, Value *vp)
 75506: {
 76264:     THIS_DEBUGGER(cx, argc, vp, "clearAllBreakpoints", args, dbg);
 75506:     for (GlobalObjectSet::Range r = dbg->debuggees.all(); !r.empty(); r.popFront())
 94959:         r.front()->compartment()->clearBreakpointsIn(cx->runtime->defaultFreeOp(), dbg, NULL);
 75506:     return true;
 75506: }
 75506: 
 75506: JSBool
 91237: Debugger::construct(JSContext *cx, unsigned argc, Value *vp)
 75398: {
 76264:     CallArgs args = CallArgsFromVp(argc, vp);
 76264: 
 76236:     /* Check that the arguments, if any, are cross-compartment wrappers. */
 91237:     for (unsigned i = 0; i < argc; i++) {
 76264:         const Value &arg = args[i];
 75398:         if (!arg.isObject())
 75402:             return ReportObjectRequired(cx);
 75398:         JSObject *argobj = &arg.toObject();
 79734:         if (!IsCrossCompartmentWrapper(argobj)) {
 75513:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CCW_REQUIRED, "Debugger");
 75398:             return false;
 75398:         }
 75456:     }
 75412: 
 76236:     /* Get Debugger.prototype. */
106862:     RootedValue v(cx);
108951:     RootedObject callee(cx, &args.callee());
114207:     if (!JSObject::getProperty(cx, callee, callee, cx->names().classPrototype, &v))
 75398:         return false;
 99421:     RootedObject proto(cx, &v.toObject());
 75513:     JS_ASSERT(proto->getClass() == &Debugger::jsclass);
 75398: 
 76236:     /*
 76236:      * Make the new Debugger object. Each one has a reference to
 76236:      * Debugger.{Frame,Object,Script}.prototype in reserved slots. The rest of
 76236:      * the reserved slots are for hooks; they default to undefined.
 76236:      */
 99421:     RootedObject obj(cx, NewObjectWithGivenProto(cx, &Debugger::jsclass, proto, NULL));
 83231:     if (!obj)
 75398:         return false;
 91237:     for (unsigned slot = JSSLOT_DEBUG_PROTO_START; slot < JSSLOT_DEBUG_PROTO_STOP; slot++)
 75418:         obj->setReservedSlot(slot, proto->getReservedSlot(slot));
 75418: 
103637:     Debugger *dbg = cx->new_<Debugger>(cx, obj.get());
 75402:     if (!dbg)
 75402:         return false;
 75451:     obj->setPrivate(dbg);
 75456:     if (!dbg->init(cx)) {
110933:         js_delete(dbg);
 75402:         return false;
 75402:     }
 75456: 
 76236:     /* Add the initial debuggees, if any. */
 91237:     for (unsigned i = 0; i < argc; i++) {
 99421:         Rooted<GlobalObject*> debuggee(cx, &GetProxyPrivate(&args[i].toObject()).toObject().global());
 75456:         if (!dbg->addDebuggeeGlobal(cx, debuggee))
 75456:             return false;
 75456:     }
 75456: 
 76264:     args.rval().setObject(*obj);
 75398:     return true;
 75398: }
 75398: 
 75453: bool
 97353: Debugger::addDebuggeeGlobal(JSContext *cx, Handle<GlobalObject*> global)
 75453: {
 76253:     if (debuggees.has(global))
 76253:         return true;
 76253: 
 76248:     JSCompartment *debuggeeCompartment = global->compartment();
 75457: 
 76236:     /*
 76248:      * Check for cycles. If global's compartment is reachable from this
 76248:      * Debugger object's compartment by following debuggee-to-debugger links,
 76248:      * then adding global would create a cycle. (Typically nobody is debugging
 76248:      * the debugger, in which case we zip through this code without looping.)
 76236:      */
 75456:     Vector<JSCompartment *> visited(cx);
 75456:     if (!visited.append(object->compartment()))
 75456:         return false;
 75456:     for (size_t i = 0; i < visited.length(); i++) {
 75456:         JSCompartment *c = visited[i];
 75489:         if (c == debuggeeCompartment) {
 75456:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_LOOP);
 75456:             return false;
 75456:         }
 75456: 
 76236:         /*
 76236:          * Find all compartments containing debuggers debugging global objects
 76236:          * in c. Add those compartments to visited.
 76236:          */
 75456:         for (GlobalObjectSet::Range r = c->getDebuggees().all(); !r.empty(); r.popFront()) {
 75513:             GlobalObject::DebuggerVector *v = r.front()->getDebuggers();
 75513:             for (Debugger **p = v->begin(); p != v->end(); p++) {
 75456:                 JSCompartment *next = (*p)->object->compartment();
 76227:                 if (Find(visited, next) == visited.end() && !visited.append(next))
 75456:                     return false;
 75456:             }
 75456:         }
 75456:     }
 75456: 
 76236:     /* Refuse to enable debug mode for a compartment that has running scripts. */
 91250:     if (!debuggeeCompartment->debugMode() && debuggeeCompartment->hasScriptsOnStack()) {
 75497:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_IDLE);
 75494:         return false;
 75494:     }
 75494: 
 76236:     /*
 76236:      * Each debugger-debuggee relation must be stored in up to three places.
 76236:      * JSCompartment::addDebuggee enables debug mode if needed.
 76236:      */
 76248:     AutoCompartment ac(cx, global);
 97353:     GlobalObject::DebuggerVector *v = GlobalObject::getOrCreateDebuggers(cx, global);
 75489:     if (!v || !v->append(this)) {
 75489:         js_ReportOutOfMemory(cx);
 76248:     } else {
 76248:         if (!debuggees.put(global)) {
 75489:             js_ReportOutOfMemory(cx);
 76248:         } else {
 76248:             if (global->getDebuggers()->length() > 1)
 75453:                 return true;
 76248:             if (debuggeeCompartment->addDebuggee(cx, global))
 76248:                 return true;
 75453: 
 76236:             /* Maintain consistency on error. */
 76248:             debuggees.remove(global);
 76248:         }
 75453:         JS_ASSERT(v->back() == this);
 75453:         v->popBack();
 76248:     }
 75453:     return false;
 75453: }
 75453: 
 75453: void
 94740: Debugger::removeDebuggeeGlobal(FreeOp *fop, GlobalObject *global,
 75489:                                GlobalObjectSet::Enum *compartmentEnum,
 75453:                                GlobalObjectSet::Enum *debugEnum)
 75453: {
 76236:     /*
 76236:      * Each debuggee is in two HashSets: one for its compartment and one for
 76236:      * its debugger (this). The caller might be enumerating either set; if so,
 76236:      * use HashSet::Enum::removeFront rather than HashSet::remove below, to
 76236:      * avoid invalidating the live enumerator.
 76236:      */
 75453:     JS_ASSERT(global->compartment()->getDebuggees().has(global));
 75453:     JS_ASSERT_IF(compartmentEnum, compartmentEnum->front() == global);
 75453:     JS_ASSERT(debuggees.has(global));
 75453:     JS_ASSERT_IF(debugEnum, debugEnum->front() == global);
 75453: 
 76236:     /*
 76236:      * FIXME Debugger::slowPathOnLeaveFrame needs to kill all Debugger.Frame
 76236:      * objects referring to a particular js::StackFrame. This is hard if
 76236:      * Debugger objects that are no longer debugging the relevant global might
 84066:      * have live Frame objects. So we take the easy way out and kill them here.
 84066:      * This is a bug, since it's observable and contrary to the spec. One
 76236:      * possible fix would be to put such objects into a compartment-wide bag
 76236:      * which slowPathOnLeaveFrame would have to examine.
 76236:      */
 75453:     for (FrameMap::Enum e(frames); !e.empty(); e.popFront()) {
 84066:         StackFrame *fp = e.front().key;
 96793:         if (&fp->global() == global) {
 75453:             e.front().value->setPrivate(NULL);
 75453:             e.removeFront();
 75453:         }
 75453:     }
 75453: 
 75513:     GlobalObject::DebuggerVector *v = global->getDebuggers();
 75513:     Debugger **p;
 75453:     for (p = v->begin(); p != v->end(); p++) {
 75453:         if (*p == this)
 75453:             break;
 75453:     }
 75453:     JS_ASSERT(p != v->end());
 75453: 
 76236:     /*
 76236:      * The relation must be removed from up to three places: *v and debuggees
 76236:      * for sure, and possibly the compartment's debuggee set.
 76236:      */
 75453:     v->erase(p);
 75453:     if (debugEnum)
 75453:         debugEnum->removeFront();
 75453:     else
 75453:         debuggees.remove(global);
108174: 
108174:     /*
108174:      * The debuggee needs to be removed from the compartment last, as this can
108174:      * trigger GCs if the compartment's debug mode is being changed, and the
108174:      * global cannot be rooted on the stack without a cx.
108174:      */
108174:     if (v->empty())
108174:         global->compartment()->removeDebuggee(fop, global, compartmentEnum);
 75453: }
 75453: 
 94880: /*
 94880:  * A class for parsing 'findScripts' query arguments and searching for
 94880:  * scripts that match the criteria they represent.
 94880:  */
 94880: class Debugger::ScriptQuery {
 94880:   public:
 94880:     /* Construct a ScriptQuery to use matching scripts for |dbg|. */
 94880:     ScriptQuery(JSContext *cx, Debugger *dbg):
119435:         cx(cx), debugger(dbg), compartments(cx), url(cx), innermostForCompartment(cx) {}
 94880: 
 94880:     /*
 94880:      * Initialize this ScriptQuery. Raise an error and return false if we
 94880:      * haven't enough memory.
 94880:      */
 94880:     bool init() {
119435:         if (!compartments.init() ||
119435:             !innermostForCompartment.init())
 94880:         {
 94880:             js_ReportOutOfMemory(cx);
 94880:             return false;
 94880:         }
 94880: 
 94880:         return true;
 94880:     }
 94880: 
 94880:     /*
 94880:      * Parse the query object |query|, and prepare to match only the scripts
 94880:      * it specifies.
 94880:      */
104205:     bool parseQuery(HandleObject query) {
 94880:         /*
 94880:          * Check for a 'global' property, which limits the results to those
 94880:          * scripts scoped to a particular global object.
 94880:          */
106862:         RootedValue global(cx);
114207:         if (!JSObject::getProperty(cx, query, query, cx->names().global, &global))
 94880:             return false;
 94880:         if (global.isUndefined()) {
 94880:             matchAllDebuggeeGlobals();
 94880:         } else {
118851:             GlobalObject *globalObject = debugger->unwrapDebuggeeArgument(cx, global);
118851:             if (!globalObject)
118851:                 return false;
 94880: 
 94880:             /*
 94880:              * If the given global isn't a debuggee, just leave the set of
 94880:              * acceptable globals empty; we'll return no scripts.
 94880:              */
 94880:             if (debugger->debuggees.has(globalObject)) {
 94880:                 if (!matchSingleGlobal(globalObject))
 94880:                     return false;
 94880:             }
 94880:         }
 94880: 
 94880:         /* Check for a 'url' property. */
114207:         if (!JSObject::getProperty(cx, query, query, cx->names().url, &url))
 94880:             return false;
 94880:         if (!url.isUndefined() && !url.isString()) {
 94880:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
 94880:                                  "query object's 'url' property", "neither undefined nor a string");
 94880:             return false;
 94880:         }
 94880: 
 94880:         /* Check for a 'line' property. */
106862:         RootedValue lineProperty(cx);
114207:         if (!JSObject::getProperty(cx, query, query, cx->names().line, &lineProperty))
 94880:             return false;
 94880:         if (lineProperty.isUndefined()) {
 94880:             hasLine = false;
 94880:         } else if (lineProperty.isNumber()) {
 94880:             if (url.isUndefined()) {
 94880:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_QUERY_LINE_WITHOUT_URL);
 94880:                 return false;
 94880:             }
 94880:             double doubleLine = lineProperty.toNumber();
 94880:             if (doubleLine <= 0 || (unsigned int) doubleLine != doubleLine) {
 94880:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_BAD_LINE);
 94880:                 return false;
 94880:             }
 94880:             hasLine = true;
 94880:             line = doubleLine;
 94880:         } else {
 94880:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
 94880:                                  "query object's 'line' property",
 94880:                                  "neither undefined nor an integer");
 94880:             return false;
 94880:         }
 94880: 
 94880:         /* Check for an 'innermost' property. */
114207:         PropertyName *innermostName = cx->names().innermost;
106862:         RootedValue innermostProperty(cx);
108951:         if (!JSObject::getProperty(cx, query, query, innermostName, &innermostProperty))
 94880:             return false;
106378:         innermost = ToBoolean(innermostProperty);
 94880:         if (innermost) {
 94880:             /* Technically, we need only check hasLine, but this is clearer. */
 94880:             if (url.isUndefined() || !hasLine) {
 94880:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 94880:                                      JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL);
 94880:                 return false;
 94880:             }
 94880:         }
 94880: 
 94880:         return true;
 94880:     }
 94880: 
 94880:     /* Set up this ScriptQuery appropriately for a missing query argument. */
 94880:     bool omittedQuery() {
 94880:         url.setUndefined();
 94880:         hasLine = false;
 94880:         innermost = false;
 94880:         return matchAllDebuggeeGlobals();
 94880:     }
 94880: 
 94880:     /*
 94880:      * Search all relevant compartments and the stack for scripts matching
 94880:      * this query, and append the matching scripts to |vector|.
 94880:      */
 94880:     bool findScripts(AutoScriptVector *vector) {
119065:         AutoAssertNoGC nogc;
119065: 
 94880:         if (!prepareQuery())
 94880:             return false;
 94880: 
 94880:         /* Search each compartment for debuggee scripts. */
 94880:         for (CompartmentSet::Range r = compartments.all(); !r.empty(); r.popFront()) {
 94880:             for (gc::CellIter i(r.front(), gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
119065:                 RawScript script = i.get<JSScript>();
119435:                 if (!consider(script, vector))
 94880:                     return false;
 94880:             }
 94880:         }
 94880: 
 94880:         /*
 94880:          * For most queries, we just accumulate results in 'vector' as we find
 94880:          * them. But if this is an 'innermost' query, then we've accumulated the
119435:          * results in the 'innermostForCompartment' map. In that case, we now need to
 94880:          * walk that map and populate 'vector'.
 94880:          */
 94880:         if (innermost) {
119435:             for (CompartmentToScriptMap::Range r = innermostForCompartment.all();
119435:                  !r.empty();
119435:                  r.popFront()) {
 94880:                 if (!vector->append(r.front().value)) {
 94880:                     js_ReportOutOfMemory(cx);
 94880:                     return false;
 94880:                 }
 94880:             }
 94880:         }
 94880: 
 94880:         return true;
 94880:     }
 94880: 
 94880:   private:
 94880:     /* The context in which we should do our work. */
 94880:     JSContext *cx;
 94880: 
 94880:     /* The debugger for which we conduct queries. */
 94880:     Debugger *debugger;
 94880: 
 94880:     typedef HashSet<JSCompartment *, DefaultHasher<JSCompartment *>, RuntimeAllocPolicy>
 94880:         CompartmentSet;
 94880: 
119435:     /* A script must be in one of these compartments to match the query. */
 94880:     CompartmentSet compartments;
 94880: 
 94880:     /* If this is a string, matching scripts have urls equal to it. */
106862:     RootedValue url;
 94880: 
 94880:     /* url as a C string. */
 94880:     JSAutoByteString urlCString;
 94880: 
 94880:     /* True if the query contained a 'line' property. */
 94880:     bool hasLine;
 94880: 
 94880:     /* The line matching scripts must cover. */
 94880:     unsigned int line;
 94880: 
 94880:     /* True if the query has an 'innermost' property whose value is true. */
 94880:     bool innermost;
 94880: 
119435:     typedef HashMap<JSCompartment *, JSScript *, DefaultHasher<JSCompartment *>, RuntimeAllocPolicy>
119435:         CompartmentToScriptMap;
 94880: 
 94880:     /*
119435:      * For 'innermost' queries, a map from compartments to the innermost script
119435:      * we've seen so far in that compartment. (Template instantiation code size
 94880:      * explosion ho!)
 94880:      */
119435:     CompartmentToScriptMap innermostForCompartment;
 94880: 
 94880:     /* Arrange for this ScriptQuery to match only scripts that run in |global|. */
 94880:     bool matchSingleGlobal(GlobalObject *global) {
119435:         JS_ASSERT(compartments.count() == 0);
119435:         if (!compartments.put(global->compartment())) {
 94880:             js_ReportOutOfMemory(cx);
 94880:             return false;
 94880:         }
 94880:         return true;
 94880:     }
 94880: 
 94880:     /*
 94880:      * Arrange for this ScriptQuery to match all scripts running in debuggee
 94880:      * globals.
 94880:      */
 94880:     bool matchAllDebuggeeGlobals() {
119435:         JS_ASSERT(compartments.count() == 0);
119435:         /* Build our compartment set from the debugger's set of debuggee globals. */
 94880:         for (GlobalObjectSet::Range r = debugger->debuggees.all(); !r.empty(); r.popFront()) {
119435:             if (!compartments.put(r.front()->compartment())) {
 94880:                 js_ReportOutOfMemory(cx);
 94880:                 return false;
 94880:             }
 94880:         }
 94880:         return true;
 94880:     }
 94880: 
 94880:     /*
 94880:      * Given that parseQuery or omittedQuery has been called, prepare to
 94880:      * match scripts. Set urlCString as appropriate.
 94880:      */
 94880:     bool prepareQuery() {
 94880:         /* Compute urlCString, if a url was given. */
 94880:         if (url.isString()) {
 94880:             if (!urlCString.encode(cx, url.toString()))
 94880:                 return false;
 94880:         }
 94880: 
 94880:         return true;
 94880:     }
 94880: 
 94880:     /*
119435:      * If |script| matches this query, append it to |vector| or place it in
119435:      * |innermostForCompartment|, as appropriate. Return true if no error
119435:      * occurs, false if an error occurs.
 94880:      */
119435:     bool consider(JSScript *script, AutoScriptVector *vector) {
119435:         JSCompartment *compartment = script->compartment();
119435:         if (!compartments.has(compartment))
 94880:             return true;
 94880:         if (urlCString.ptr()) {
 94880:             if (!script->filename || strcmp(script->filename, urlCString.ptr()) != 0)
 94880:                 return true;
 94880:         }
 94880:         if (hasLine) {
 94880:             if (line < script->lineno || script->lineno + js_GetScriptLineExtent(script) < line)
 94880:                 return true;
 94880:         }
 94880:         if (innermost) {
 94880:             /*
 94880:              * For 'innermost' queries, we don't place scripts in |vector| right
 94880:              * away; we may later find another script that is nested inside this
 94880:              * one. Instead, we record the innermost script we've found so far
119435:              * for each compartment in innermostForCompartment, and only
119435:              * populate |vector| at the bottom of findScripts, when we've
119435:              * traversed all the scripts.
 94880:              *
 94880:              * So: check this script against the innermost one we've found so
119435:              * far (if any), as recorded in innermostForCompartment, and replace
119435:              * that if it's better.
 94880:              */
119435:             CompartmentToScriptMap::AddPtr p = innermostForCompartment.lookupForAdd(compartment);
 94880:             if (p) {
 94880:                 /* Is our newly found script deeper than the last one we found? */
 94880:                 JSScript *incumbent = p->value;
 94880:                 if (script->staticLevel > incumbent->staticLevel)
 94880:                     p->value = script;
 94880:             } else {
 94880:                 /*
 94880:                  * This is the first matching script we've encountered for this
119435:                  * compartment, so it is thus the innermost such script.
 94880:                  */
119435:                 if (!innermostForCompartment.add(p, compartment, script)) {
 94880:                     js_ReportOutOfMemory(cx);
 94880:                     return false;
 94880:                 }
 94880:             }
 94880:         } else {
 94880:             /* Record this matching script in the results vector. */
 94880:             if (!vector->append(script)) {
 94880:                 js_ReportOutOfMemory(cx);
 94880:                 return false;
 94880:             }
 94880:         }
 94880: 
 94880:         return true;
 94880:     }
 94880: };
 91956: 
 91956: JSBool
 91956: Debugger::findScripts(JSContext *cx, unsigned argc, Value *vp)
 91956: {
 91956:     THIS_DEBUGGER(cx, argc, vp, "findScripts", args, dbg);
 91956: 
 94880:     ScriptQuery query(cx, dbg);
 94880:     if (!query.init())
 91956:         return false;
 94880: 
 94880:     if (argc >= 1) {
104205:         RootedObject queryObject(cx, NonNullObject(cx, args[0]));
 94880:         if (!queryObject || !query.parseQuery(queryObject))
 91956:             return false;
 94880:     } else {
 94880:         if (!query.omittedQuery())
 94880:             return false;
 91956:     }
 91956: 
 91956:     /*
 91956:      * Accumulate the scripts in an AutoScriptVector, instead of creating
 91956:      * the JS array as we go, because we mustn't allocate JS objects or GC
 91956:      * while we use the CellIter.
 91956:      */
 91956:     AutoScriptVector scripts(cx);
 91956: 
 94880:     if (!query.findScripts(&scripts))
 91956:         return false;
 91956: 
106505:     RootedObject result(cx, NewDenseAllocatedArray(cx, scripts.length()));
 91956:     if (!result)
 91956:         return false;
 91956: 
 91956:     result->ensureDenseArrayInitializedLength(cx, 0, scripts.length());
 91956: 
 91956:     for (size_t i = 0; i < scripts.length(); i++) {
102586:         JSObject *scriptObject =
102586:             dbg->wrapScript(cx, Handle<JSScript*>::fromMarkedLocation(&scripts[i]));
 91956:         if (!scriptObject)
 91956:             return false;
 91956:         result->setDenseArrayElement(i, ObjectValue(*scriptObject));
 91956:     }
 91956: 
 91956:     args.rval().setObject(*result);
 91956:     return true;
 91956: }
 91956: 
118854: JSBool
118854: Debugger::findAllGlobals(JSContext *cx, unsigned argc, Value *vp)
118854: {
118854:     THIS_DEBUGGER(cx, argc, vp, "findAllGlobals", args, dbg);
118854: 
118854:     RootedObject result(cx, NewDenseEmptyArray(cx));
118854:     if (!result)
118854:         return false;
118854: 
118854:     for (CompartmentsIter c(cx->runtime); !c.done(); c.next()) {
121539:         c->scheduledForDestruction = false;
121539: 
118854:         GlobalObject *global = c->maybeGlobal();
118854:         if (global) {
124728:             /*
124728:              * We pulled |global| out of nowhere, so it's possible that it was
124728:              * marked gray by XPConnect. Since we're now exposing it to JS code,
124728:              * we need to mark it black.
124728:              */
124728:             ExposeGCThingToActiveJS(global, JSTRACE_OBJECT);
124728: 
118854:             Value globalValue(ObjectValue(*global));
118854:             if (!dbg->wrapDebuggeeValue(cx, &globalValue))
118854:                 return false;
118854:             if (!js_NewbornArrayPush(cx, result, globalValue))
118854:                 return false;
118854:         }
118854:     }
118854: 
118854:     args.rval().setObject(*result);
118854:     return true;
118854: }
118854: 
 75513: JSPropertySpec Debugger::properties[] = {
 75513:     JS_PSGS("enabled", Debugger::getEnabled, Debugger::setEnabled, 0),
 76230:     JS_PSGS("onDebuggerStatement", Debugger::getOnDebuggerStatement,
 76230:             Debugger::setOnDebuggerStatement, 0),
 76236:     JS_PSGS("onExceptionUnwind", Debugger::getOnExceptionUnwind,
 76236:             Debugger::setOnExceptionUnwind, 0),
 76230:     JS_PSGS("onNewScript", Debugger::getOnNewScript, Debugger::setOnNewScript, 0),
 76230:     JS_PSGS("onEnterFrame", Debugger::getOnEnterFrame, Debugger::setOnEnterFrame, 0),
118853:     JS_PSGS("onNewGlobalObject", Debugger::getOnNewGlobalObject, Debugger::setOnNewGlobalObject, 0),
 75513:     JS_PSGS("uncaughtExceptionHook", Debugger::getUncaughtExceptionHook,
 75513:             Debugger::setUncaughtExceptionHook, 0),
 75402:     JS_PS_END
 75402: };
 75402: 
 75513: JSFunctionSpec Debugger::methods[] = {
 75513:     JS_FN("addDebuggee", Debugger::addDebuggee, 1, 0),
 75513:     JS_FN("removeDebuggee", Debugger::removeDebuggee, 1, 0),
120760:     JS_FN("removeAllDebuggees", Debugger::removeAllDebuggees, 0, 0),
 75513:     JS_FN("hasDebuggee", Debugger::hasDebuggee, 1, 0),
 75513:     JS_FN("getDebuggees", Debugger::getDebuggees, 0, 0),
 75515:     JS_FN("getNewestFrame", Debugger::getNewestFrame, 0, 0),
 75513:     JS_FN("clearAllBreakpoints", Debugger::clearAllBreakpoints, 1, 0),
 91956:     JS_FN("findScripts", Debugger::findScripts, 1, 0),
118854:     JS_FN("findAllGlobals", Debugger::findAllGlobals, 0, 0),
 75441:     JS_FS_END
 75441: };
 75441: 
 75466: 
 76236: /*** Debugger.Script *****************************************************************************/
 76236: 
 75506: static inline JSScript *
 75506: GetScriptReferent(JSObject *obj)
 75506: {
 75513:     JS_ASSERT(obj->getClass() == &DebuggerScript_class);
 80803:     return static_cast<JSScript *>(obj->getPrivate());
 75506: }
 75506: 
 91557: static inline void
 91557: SetScriptReferent(JSObject *obj, JSScript *script)
 91557: {
 91557:     JS_ASSERT(obj->getClass() == &DebuggerScript_class);
109329:     obj->setPrivateGCThing(script);
 91557: }
 91557: 
 75496: static void
115876: DebuggerScript_trace(JSTracer *trc, RawObject obj)
 75496: {
 82129:     /* This comes from a private pointer, so no barrier needed. */
 91557:     if (JSScript *script = GetScriptReferent(obj)) {
124078:         MarkCrossCompartmentScriptUnbarriered(trc, obj, &script, "Debugger.Script referent");
 92726:         obj->setPrivateUnbarriered(script);
 91557:     }
 75496: }
 75496: 
 75513: Class DebuggerScript_class = {
 90410:     "Script",
 90410:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS |
 90410:     JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGSCRIPT_COUNT),
 78614:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 78614:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, NULL,
 75496:     NULL,                 /* checkAccess */
 75496:     NULL,                 /* call        */
 75496:     NULL,                 /* construct   */
 75496:     NULL,                 /* hasInstance */
 75513:     DebuggerScript_trace
 75496: };
 75492: 
 75492: JSObject *
101203: Debugger::newDebuggerScript(JSContext *cx, HandleScript script)
 75492: {
 82129:     assertSameCompartment(cx, object.get());
 75518: 
 75492:     JSObject *proto = &object->getReservedSlot(JSSLOT_DEBUG_SCRIPT_PROTO).toObject();
 75492:     JS_ASSERT(proto);
 83275:     JSObject *scriptobj = NewObjectWithGivenProto(cx, &DebuggerScript_class, proto, NULL);
 83231:     if (!scriptobj)
 80699:         return NULL;
 82129:     scriptobj->setReservedSlot(JSSLOT_DEBUGSCRIPT_OWNER, ObjectValue(*object));
109329:     scriptobj->setPrivateGCThing(script);
 75492: 
 75492:     return scriptobj;
 75492: }
 75492: 
 75492: JSObject *
101203: Debugger::wrapScript(JSContext *cx, HandleScript script)
 75492: {
 82129:     assertSameCompartment(cx, object.get());
 77659:     JS_ASSERT(cx->compartment != script->compartment());
 82129:     ScriptWeakMap::AddPtr p = scripts.lookupForAdd(script);
 75492:     if (!p) {
 80803:         JSObject *scriptobj = newDebuggerScript(cx, script);
101637:         if (!scriptobj)
101637:             return NULL;
 76236: 
 76236:         /* The allocation may have caused a GC, which can remove table entries. */
101637:         if (!scripts.relookupOrAdd(p, script, scriptobj)) {
101637:             js_ReportOutOfMemory(cx);
 75492:             return NULL;
 75492:         }
 75492: 
101637:         CrossCompartmentKey key(CrossCompartmentKey::DebuggerScript, object, script);
124656:         if (!object->compartment()->putWrapper(key, ObjectValue(*scriptobj))) {
101637:             scripts.remove(script);
101637:             js_ReportOutOfMemory(cx);
101637:             return NULL;
101637:         }
101637:     }
101637: 
 75492:     JS_ASSERT(GetScriptReferent(p->value) == script);
 75492:     return p->value;
 75492: }
 75492: 
 75492: static JSObject *
 79905: DebuggerScript_check(JSContext *cx, const Value &v, const char *clsname, const char *fnname)
 75492: {
 75506:     if (!v.isObject()) {
 75492:         ReportObjectRequired(cx);
 75492:         return NULL;
 75492:     }
 75506:     JSObject *thisobj = &v.toObject();
 77817:     if (thisobj->getClass() != &DebuggerScript_class) {
 75492:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 75506:                              clsname, fnname, thisobj->getClass()->name);
 75492:         return NULL;
 75492:     }
 75492: 
 76236:     /*
 76236:      * Check for Debugger.Script.prototype, which is of class DebuggerScript_class
 80803:      * but whose script is null.
 76236:      */
 80803:     if (!GetScriptReferent(thisobj)) {
 79905:         JS_ASSERT(!GetScriptReferent(thisobj));
 75492:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 75506:                              clsname, fnname, "prototype object");
 75492:         return NULL;
 75492:     }
 75492: 
 75492:     return thisobj;
 75492: }
 75492: 
 75506: static JSObject *
 79905: DebuggerScript_checkThis(JSContext *cx, const CallArgs &args, const char *fnname)
 75506: {
 79905:     return DebuggerScript_check(cx, args.thisv(), "Debugger.Script", fnname);
 79905: }
 79905: 
 79905: #define THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, fnname, args, obj, script)            \
 76265:     CallArgs args = CallArgsFromVp(argc, vp);                                       \
 99421:     RootedObject obj(cx, DebuggerScript_checkThis(cx, args, fnname));               \
 75492:     if (!obj)                                                                       \
 75492:         return false;                                                               \
 99421:     Rooted<JSScript*> script(cx, GetScriptReferent(obj))
 75492: 
 75522: static JSBool
 91237: DebuggerScript_getUrl(JSContext *cx, unsigned argc, Value *vp)
 75522: {
 95383:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "(get url)", args, obj, script);
 75522: 
 99823:     if (script->filename) {
 75522:         JSString *str = js_NewStringCopyZ(cx, script->filename);
 75522:         if (!str)
 75522:             return false;
 76265:         args.rval().setString(str);
 99823:     } else {
 99823:         args.rval().setNull();
 99823:     }
 75522:     return true;
 75522: }
 75522: 
 75522: static JSBool
 91237: DebuggerScript_getStartLine(JSContext *cx, unsigned argc, Value *vp)
 75522: {
 95383:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "(get startLine)", args, obj, script);
 76265:     args.rval().setNumber(script->lineno);
 75522:     return true;
 75522: }
 75522: 
 75522: static JSBool
 91237: DebuggerScript_getLineCount(JSContext *cx, unsigned argc, Value *vp)
 75522: {
 95383:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "(get lineCount)", args, obj, script);
 75522: 
 91237:     unsigned maxLine = js_GetScriptLineExtent(script);
 90955:     args.rval().setNumber(double(maxLine));
 75522:     return true;
 75522: }
 75492: 
 75492: static JSBool
 95383: DebuggerScript_getStaticLevel(JSContext *cx, unsigned argc, Value *vp)
 95383: {
 95383:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "(get staticLevel)", args, obj, script);
 95383:     args.rval().setNumber(uint32_t(script->staticLevel));
 95383:     return true;
 95383: }
 95383: 
 95383: static JSBool
108586: DebuggerScript_getSourceMapUrl(JSContext *cx, unsigned argc, Value *vp)
108586: {
108586:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "(get sourceMapURL)", args, obj, script);
108586: 
108586:     ScriptSource *source = script->scriptSource();
108586:     JS_ASSERT(source);
108586: 
108586:     if (source->hasSourceMap()) {
108586:         JSString *str = JS_NewUCStringCopyZ(cx, source->sourceMap());
108586:         if (!str)
108586:             return false;
108586:         args.rval().setString(str);
108586:     } else {
108586:         args.rval().setNull();
108586:     }
108586: 
108586:     return true;
108586: }
108586: 
108586: static JSBool
 91237: DebuggerScript_getChildScripts(JSContext *cx, unsigned argc, Value *vp)
 75512: {
 79905:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "getChildScripts", args, obj, script);
 75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
 75512: 
 99421:     RootedObject result(cx, NewDenseEmptyArray(cx));
 75512:     if (!result)
 75512:         return false;
 97361:     if (script->hasObjects()) {
 76236:         /*
 76236:          * script->savedCallerFun indicates that this is a direct eval script
 76236:          * and the calling function is stored as script->objects()->vector[0].
 76236:          * It is not really a child script of this script, so skip it.
 76236:          */
 97362:         ObjectArray *objects = script->objects();
119065:         RootedFunction fun(cx);
119065:         RootedScript funScript(cx);
119065:         RootedObject obj(cx), s(cx);
 84755:         for (uint32_t i = script->savedCallerFun ? 1 : 0; i < objects->length; i++) {
119065:             obj = objects->vector[i];
 75512:             if (obj->isFunction()) {
119065:                 fun = static_cast<JSFunction *>(obj.get());
123827:                 funScript = fun->nonLazyScript();
119065:                 s = dbg->wrapScript(cx, funScript);
 75512:                 if (!s || !js_NewbornArrayPush(cx, result, ObjectValue(*s)))
 75512:                     return false;
 75512:             }
 75512:         }
 75512:     }
 76265:     args.rval().setObject(*result);
 75512:     return true;
 75512: }
 75512: 
 75501: static bool
 75501: ScriptOffset(JSContext *cx, JSScript *script, const Value &v, size_t *offsetp)
 75501: {
 75501:     double d;
 75501:     size_t off;
 75501: 
 75501:     bool ok = v.isNumber();
 75501:     if (ok) {
 75501:         d = v.toNumber();
 75501:         off = size_t(d);
 75501:     }
 75501:     if (!ok || off != d || !IsValidBytecodeOffset(cx, script, off)) {
 75501:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_BAD_OFFSET);
 75501:         return false;
 75501:     }
 75501:     *offsetp = off;
 75501:     return true;
 75501: }
 75501: 
 75501: static JSBool
 91237: DebuggerScript_getOffsetLine(JSContext *cx, unsigned argc, Value *vp)
 75501: {
 75513:     REQUIRE_ARGC("Debugger.Script.getOffsetLine", 1);
 79905:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "getOffsetLine", args, obj, script);
 75501:     size_t offset;
 76265:     if (!ScriptOffset(cx, script, args[0], &offset))
 75501:         return false;
 91237:     unsigned lineno = JS_PCToLineNumber(cx, script, script->code + offset);
 76265:     args.rval().setNumber(lineno);
 75501:     return true;
 75501: }
 75501: 
 75504: class BytecodeRangeWithLineNumbers : private BytecodeRange
 75504: {
 75504:   public:
 75504:     using BytecodeRange::empty;
 75504:     using BytecodeRange::frontPC;
 75504:     using BytecodeRange::frontOpcode;
 75504:     using BytecodeRange::frontOffset;
 75504: 
104205:     BytecodeRangeWithLineNumbers(JSContext *cx, JSScript *script)
106783:       : BytecodeRange(script), lineno(script->lineno), sn(script->notes()), snpc(script->code), skip(cx, thisForCtor())
 76236:     {
 75504:         if (!SN_IS_TERMINATOR(sn))
 75504:             snpc += SN_DELTA(sn);
 75504:         updateLine();
 98921:         while (frontPC() != script->main())
 98921:             popFront();
 75504:     }
 75504: 
 75504:     void popFront() {
 75504:         BytecodeRange::popFront();
 75504:         if (!empty())
 75504:             updateLine();
 75504:     }
 75504: 
 75504:     size_t frontLineNumber() const { return lineno; }
 75504: 
 75504:   private:
106783:     BytecodeRangeWithLineNumbers *thisForCtor() { return this; }
106783: 
 75504:     void updateLine() {
 76236:         /*
 76236:          * Determine the current line number by reading all source notes up to
 76236:          * and including the current offset.
 76236:          */
 75504:         while (!SN_IS_TERMINATOR(sn) && snpc <= frontPC()) {
 80631:             SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
 75504:             if (type == SRC_SETLINE)
 75504:                 lineno = size_t(js_GetSrcNoteOffset(sn, 0));
 75504:             else if (type == SRC_NEWLINE)
 75504:                 lineno++;
 75504: 
 75504:             sn = SN_NEXT(sn);
 75504:             snpc += SN_DELTA(sn);
 75504:         }
 75504:     }
 75504: 
 75504:     size_t lineno;
 75504:     jssrcnote *sn;
 75504:     jsbytecode *snpc;
104205: 
104205:     SkipRoot skip;
 75504: };
 75504: 
 75504: static const size_t NoEdges = -1;
 75504: static const size_t MultipleEdges = -2;
 75504: 
 75504: /*
 75504:  * FlowGraphSummary::populate(cx, script) computes a summary of script's
 75513:  * control flow graph used by DebuggerScript_{getAllOffsets,getLineOffsets}.
 75504:  *
 75504:  * jumpData[offset] is:
 75504:  *   - NoEdges if offset isn't the offset of an instruction, or if the
 75504:  *     instruction is apparently unreachable;
 75504:  *   - MultipleEdges if you can arrive at that instruction from
 75504:  *     instructions on multiple different lines OR it's the first
 75504:  *     instruction of the script;
 75504:  *   - otherwise, the (unique) line number of all instructions that can
 75504:  *     precede the instruction at offset.
 75504:  *
 75504:  * The generated graph does not contain edges for JSOP_RETSUB, which appears at
 75504:  * the end of finally blocks. The algorithm that uses this information works
 75504:  * anyway, because in non-exception cases, JSOP_RETSUB always returns to a
 75504:  * !FlowsIntoNext instruction (JSOP_GOTO/GOTOX or JSOP_RETRVAL) which generates
 75504:  * an edge if needed.
 75504:  */
 75504: class FlowGraphSummary : public Vector<size_t> {
 75504:   public:
 75504:     typedef Vector<size_t> Base;
 75504:     FlowGraphSummary(JSContext *cx) : Base(cx) {}
 75504: 
 75504:     void addEdge(size_t sourceLine, size_t targetOffset) {
 75504:         FlowGraphSummary &self = *this;
 75504:         if (self[targetOffset] == NoEdges)
 75504:             self[targetOffset] = sourceLine;
 75504:         else if (self[targetOffset] != sourceLine)
 75504:             self[targetOffset] = MultipleEdges;
 75504:     }
 75504: 
 75504:     void addEdgeFromAnywhere(size_t targetOffset) {
 75504:         (*this)[targetOffset] = MultipleEdges;
 75504:     }
 75504: 
 75504:     bool populate(JSContext *cx, JSScript *script) {
 75504:         if (!growBy(script->length))
 75504:             return false;
 75504:         FlowGraphSummary &self = *this;
 98921:         unsigned mainOffset = script->main() - script->code;
 98921:         self[mainOffset] = MultipleEdges;
 98921:         for (size_t i = mainOffset + 1; i < script->length; i++)
 75504:             self[i] = NoEdges;
 75504: 
 75504:         size_t prevLine = script->lineno;
 75504:         JSOp prevOp = JSOP_NOP;
104205:         for (BytecodeRangeWithLineNumbers r(cx, script); !r.empty(); r.popFront()) {
 75504:             size_t lineno = r.frontLineNumber();
 75504:             JSOp op = r.frontOpcode();
 75504: 
 75504:             if (FlowsIntoNext(prevOp))
 75504:                 addEdge(prevLine, r.frontOffset());
 75504: 
 75504:             if (js_CodeSpec[op].type() == JOF_JUMP) {
 75504:                 addEdge(lineno, r.frontOffset() + GET_JUMP_OFFSET(r.frontPC()));
 86877:             } else if (op == JSOP_TABLESWITCH || op == JSOP_LOOKUPSWITCH) {
 75504:                 jsbytecode *pc = r.frontPC();
 75504:                 size_t offset = r.frontOffset();
 86877:                 ptrdiff_t step = JUMP_OFFSET_LEN;
 86877:                 size_t defaultOffset = offset + GET_JUMP_OFFSET(pc);
 75504:                 pc += step;
 75504:                 addEdge(lineno, defaultOffset);
 75504: 
 91450:                 int ncases;
 86877:                 if (op == JSOP_TABLESWITCH) {
 91450:                     int32_t low = GET_JUMP_OFFSET(pc);
 75504:                     pc += JUMP_OFFSET_LEN;
 75504:                     ncases = GET_JUMP_OFFSET(pc) - low + 1;
 75504:                     pc += JUMP_OFFSET_LEN;
 75504:                 } else {
 91450:                     ncases = GET_UINT16(pc);
 75504:                     pc += UINT16_LEN;
 75504:                     JS_ASSERT(ncases > 0);
 75504:                 }
 75504: 
 91450:                 for (int i = 0; i < ncases; i++) {
 86877:                     if (op == JSOP_LOOKUPSWITCH)
 90965:                         pc += UINT32_INDEX_LEN;
 86877:                     size_t target = offset + GET_JUMP_OFFSET(pc);
 75504:                     addEdge(lineno, target);
 75504:                     pc += step;
 75504:                 }
 75504:             }
 75504: 
 75504:             prevOp = op;
 75504:             prevLine = lineno;
 75504:         }
 75504: 
 75504:         return true;
 75504:     }
 75504: };
 75504: 
 75504: static JSBool
 91237: DebuggerScript_getAllOffsets(JSContext *cx, unsigned argc, Value *vp)
 75504: {
 79905:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "getAllOffsets", args, obj, script);
 75504: 
 76236:     /*
 76236:      * First pass: determine which offsets in this script are jump targets and
 76236:      * which line numbers jump to them.
 76236:      */
 75504:     FlowGraphSummary flowData(cx);
 75504:     if (!flowData.populate(cx, script))
 75504:         return false;
 75504: 
 76236:     /* Second pass: build the result array. */
104205:     RootedObject result(cx, NewDenseEmptyArray(cx));
 75504:     if (!result)
 75504:         return false;
104205:     for (BytecodeRangeWithLineNumbers r(cx, script); !r.empty(); r.popFront()) {
 75504:         size_t offset = r.frontOffset();
 75504:         size_t lineno = r.frontLineNumber();
 75504: 
 76236:         /* Make a note, if the current instruction is an entry point for the current line. */
 75504:         if (flowData[offset] != NoEdges && flowData[offset] != lineno) {
 76236:             /* Get the offsets array for this line. */
 99421:             RootedObject offsets(cx);
 75504:             Value offsetsv;
 75504:             if (!result->arrayGetOwnDataElement(cx, lineno, &offsetsv))
 75504:                 return false;
 75504: 
 75504:             if (offsetsv.isObject()) {
 75504:                 offsets = &offsetsv.toObject();
 75504:             } else {
 75504:                 JS_ASSERT(offsetsv.isMagic(JS_ARRAY_HOLE));
 75504: 
 76236:                 /*
 76236:                  * Create an empty offsets array for this line.
 76236:                  * Store it in the result array.
 76236:                  */
 99421:                 RootedId id(cx);
 75504:                 offsets = NewDenseEmptyArray(cx);
 75504:                 if (!offsets ||
106862:                     !ValueToId(cx, NumberValue(lineno), id.address()))
 75504:                 {
 75504:                     return false;
 75504:                 }
106862: 
106862:                 RootedValue value(cx, ObjectValue(*offsets));
108951:                 if (!JSObject::defineGeneric(cx, result, id, value))
106862:                     return false;
 75504:             }
 75504: 
 76236:             /* Append the current offset to the offsets array. */
 75510:             if (!js_NewbornArrayPush(cx, offsets, NumberValue(offset)))
 75504:                 return false;
 75504:         }
 75504:     }
 75504: 
 76265:     args.rval().setObject(*result);
 75504:     return true;
 75504: }
 75504: 
 75504: static JSBool
 91237: DebuggerScript_getLineOffsets(JSContext *cx, unsigned argc, Value *vp)
 75504: {
 79905:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "getLineOffsets", args, obj, script);
 75513:     REQUIRE_ARGC("Debugger.Script.getLineOffsets", 1);
 75504: 
 76236:     /* Parse lineno argument. */
 75504:     size_t lineno;
 75504:     bool ok = false;
 76265:     if (args[0].isNumber()) {
 90955:         double d = args[0].toNumber();
 75504:         lineno = size_t(d);
 75504:         ok = (lineno == d);
 75504:     }
 75504:     if (!ok) {
 75504:         JS_ReportErrorNumber(cx,  js_GetErrorMessage, NULL, JSMSG_DEBUG_BAD_LINE);
 75504:         return false;
 75504:     }
 75504: 
 76236:     /*
 76236:      * First pass: determine which offsets in this script are jump targets and
 76236:      * which line numbers jump to them.
 76236:      */
 75504:     FlowGraphSummary flowData(cx);
 75504:     if (!flowData.populate(cx, script))
 75504:         return false;
 75504: 
 76236:     /* Second pass: build the result array. */
 99421:     RootedObject result(cx, NewDenseEmptyArray(cx));
 75504:     if (!result)
 75504:         return false;
104205:     for (BytecodeRangeWithLineNumbers r(cx, script); !r.empty(); r.popFront()) {
 75504:         size_t offset = r.frontOffset();
 75504: 
 76236:         /* If the op at offset is an entry point, append offset to result. */
 75504:         if (r.frontLineNumber() == lineno &&
 75504:             flowData[offset] != NoEdges &&
 75504:             flowData[offset] != lineno)
 75504:         {
 75510:             if (!js_NewbornArrayPush(cx, result, NumberValue(offset)))
 75504:                 return false;
 75504:         }
 75504:     }
 75504: 
 76265:     args.rval().setObject(*result);
 75504:     return true;
 75504: }
 75504: 
 97693: bool
 97693: Debugger::observesScript(JSScript *script) const
 97693: {
 97693:     if (!enabled)
 97693:         return false;
104376:     return observesGlobal(&script->global());
 97693: }
 97693: 
 76229: static JSBool
 91237: DebuggerScript_setBreakpoint(JSContext *cx, unsigned argc, Value *vp)
 75506: {
 75513:     REQUIRE_ARGC("Debugger.Script.setBreakpoint", 2);
 79905:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "setBreakpoint", args, obj, script);
 75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
 75506: 
 97693:     if (!dbg->observesScript(script)) {
 75506:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_DEBUGGING);
 75506:         return false;
 75506:     }
 75506: 
 75506:     size_t offset;
 76265:     if (!ScriptOffset(cx, script, args[0], &offset))
 75506:         return false;
 75506: 
 76265:     JSObject *handler = NonNullObject(cx, args[1]);
 75506:     if (!handler)
 75506:         return false;
 75506: 
 75506:     jsbytecode *pc = script->code + offset;
104376:     BreakpointSite *site = script->getOrCreateBreakpointSite(cx, pc);
 76270:     if (!site)
 76270:         return false;
 94740:     site->inc(cx->runtime->defaultFreeOp());
 76248:     if (cx->runtime->new_<Breakpoint>(dbg, site, handler)) {
 76265:         args.rval().setUndefined();
 75506:         return true;
 76248:     }
 94740:     site->dec(cx->runtime->defaultFreeOp());
 94740:     site->destroyIfEmpty(cx->runtime->defaultFreeOp());
 75506:     return false;
 75506: }
 75506: 
 76229: static JSBool
 91237: DebuggerScript_getBreakpoints(JSContext *cx, unsigned argc, Value *vp)
 75506: {
 79905:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "getBreakpoints", args, obj, script);
 75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
 75506: 
 75506:     jsbytecode *pc;
 75506:     if (argc > 0) {
 75506:         size_t offset;
 76265:         if (!ScriptOffset(cx, script, args[0], &offset))
 75506:             return false;
 75506:         pc = script->code + offset;
 75506:     } else {
 75506:         pc = NULL;
 75506:     }
 75506: 
 99421:     RootedObject arr(cx, NewDenseEmptyArray(cx));
 75506:     if (!arr)
 75506:         return false;
 84195: 
 84195:     for (unsigned i = 0; i < script->length; i++) {
 84195:         BreakpointSite *site = script->getBreakpointSite(script->code + i);
 84195:         if (site && (!pc || site->pc == pc)) {
 75506:             for (Breakpoint *bp = site->firstBreakpoint(); bp; bp = bp->nextInSite()) {
 75506:                 if (bp->debugger == dbg &&
 75510:                     !js_NewbornArrayPush(cx, arr, ObjectValue(*bp->getHandler())))
 75506:                 {
 75506:                     return false;
 75506:                 }
 75506:             }
 75506:         }
 75506:     }
 76265:     args.rval().setObject(*arr);
 75506:     return true;
 75506: }
 75506: 
 76229: static JSBool
 91237: DebuggerScript_clearBreakpoint(JSContext *cx, unsigned argc, Value *vp)
 75506: {
 75513:     REQUIRE_ARGC("Debugger.Script.clearBreakpoint", 1);
 79905:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "clearBreakpoint", args, obj, script);
 75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
 75506: 
 76265:     JSObject *handler = NonNullObject(cx, args[0]);
 75506:     if (!handler)
 75506:         return false;
 75506: 
 94959:     script->clearBreakpointsIn(cx->runtime->defaultFreeOp(), dbg, handler);
 76265:     args.rval().setUndefined();
 75506:     return true;
 75506: }
 75506: 
 76229: static JSBool
 91237: DebuggerScript_clearAllBreakpoints(JSContext *cx, unsigned argc, Value *vp)
 75506: {
 79905:     THIS_DEBUGSCRIPT_SCRIPT(cx, argc, vp, "clearAllBreakpoints", args, obj, script);
 75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);
 94959:     script->clearBreakpointsIn(cx->runtime->defaultFreeOp(), dbg, NULL);
 76265:     args.rval().setUndefined();
 75506:     return true;
 75506: }
 75506: 
 75492: static JSBool
 91237: DebuggerScript_construct(JSContext *cx, unsigned argc, Value *vp)
 75492: {
 75513:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR, "Debugger.Script");
 75492:     return false;
 75492: }
 75492: 
 75513: static JSPropertySpec DebuggerScript_properties[] = {
 75522:     JS_PSG("url", DebuggerScript_getUrl, 0),
 75522:     JS_PSG("startLine", DebuggerScript_getStartLine, 0),
 75522:     JS_PSG("lineCount", DebuggerScript_getLineCount, 0),
 95383:     JS_PSG("staticLevel", DebuggerScript_getStaticLevel, 0),
108586:     JS_PSG("sourceMapURL", DebuggerScript_getSourceMapUrl, 0),
 75492:     JS_PS_END
 75492: };
 75492: 
 75513: static JSFunctionSpec DebuggerScript_methods[] = {
 75513:     JS_FN("getChildScripts", DebuggerScript_getChildScripts, 0, 0),
 75513:     JS_FN("getAllOffsets", DebuggerScript_getAllOffsets, 0, 0),
 75513:     JS_FN("getLineOffsets", DebuggerScript_getLineOffsets, 1, 0),
 75513:     JS_FN("getOffsetLine", DebuggerScript_getOffsetLine, 0, 0),
 75513:     JS_FN("setBreakpoint", DebuggerScript_setBreakpoint, 2, 0),
 75513:     JS_FN("getBreakpoints", DebuggerScript_getBreakpoints, 1, 0),
 75513:     JS_FN("clearBreakpoint", DebuggerScript_clearBreakpoint, 1, 0),
 75513:     JS_FN("clearAllBreakpoints", DebuggerScript_clearAllBreakpoints, 0, 0),
 75492:     JS_FS_END
 75492: };
 75492: 
 75492: 
 76236: /*** Debugger.Frame ******************************************************************************/
 75413: 
 75513: Class DebuggerFrame_class = {
 75417:     "Frame", JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGFRAME_COUNT),
 78614:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 78614:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub
 75413: };
 75413: 
 75419: static JSObject *
 76266: CheckThisFrame(JSContext *cx, const CallArgs &args, const char *fnname, bool checkLive)
 75414: {
 76266:     if (!args.thisv().isObject()) {
 75414:         ReportObjectRequired(cx);
 75414:         return NULL;
 75414:     }
 76266:     JSObject *thisobj = &args.thisv().toObject();
 75513:     if (thisobj->getClass() != &DebuggerFrame_class) {
 75414:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 75513:                              "Debugger.Frame", fnname, thisobj->getClass()->name);
 75414:         return NULL;
 75414:     }
 75414: 
 76236:     /*
 76236:      * Forbid Debugger.Frame.prototype, which is of class DebuggerFrame_class
 76236:      * but isn't really a working Debugger.Frame object. The prototype object
 76236:      * is distinguished by having a NULL private value. Also, forbid popped
 76236:      * frames.
 76236:      */
 75414:     if (!thisobj->getPrivate()) {
 75417:         if (thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_OWNER).isUndefined()) {
 75414:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 75513:                                  "Debugger.Frame", fnname, "prototype object");
 75414:             return NULL;
 75414:         }
 75414:         if (checkLive) {
 75492:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_LIVE,
 98922:                                  "Debugger.Frame");
 75414:             return NULL;
 75414:         }
 75414:     }
 75414:     return thisobj;
 75414: }
 75414: 
 76266: #define THIS_FRAME(cx, argc, vp, fnname, args, thisobj, fp)                  \
 76266:     CallArgs args = CallArgsFromVp(argc, vp);                                \
 99421:     RootedObject thisobj(cx, CheckThisFrame(cx, args, fnname, true));        \
 75413:     if (!thisobj)                                                            \
 75413:         return false;                                                        \
 75472:     StackFrame *fp = (StackFrame *) thisobj->getPrivate();                   \
 98783:     JS_ASSERT(cx->stack.space().containsSlow(fp))
 75413: 
 84307: #define THIS_FRAME_OWNER(cx, argc, vp, fnname, args, thisobj, fp, dbg)       \
 84307:     THIS_FRAME(cx, argc, vp, fnname, args, thisobj, fp);                     \
 84307:     Debugger *dbg = Debugger::fromChildJSObject(thisobj)
 84307: 
 75419: static JSBool
 91237: DebuggerFrame_getType(JSContext *cx, unsigned argc, Value *vp)
 75413: {
 76266:     THIS_FRAME(cx, argc, vp, "get type", args, thisobj, fp);
 75413: 
 76236:     /*
 76236:      * Indirect eval frames are both isGlobalFrame() and isEvalFrame(), so the
 76236:      * order of checks here is significant.
 76236:      */
 76266:     args.rval().setString(fp->isEvalFrame()
114207:                           ? cx->names().eval
 75413:                           : fp->isGlobalFrame()
114207:                           ? cx->names().global
114207:                           : cx->names().call);
 75413:     return true;
 75413: }
 75413: 
 84307: static JSBool
 91237: DebuggerFrame_getEnvironment(JSContext *cx, unsigned argc, Value *vp)
 84307: {
 84307:     THIS_FRAME_OWNER(cx, argc, vp, "get environment", args, thisobj, fp, dbg);
 84307: 
 99421:     Rooted<Env*> env(cx);
 84307:     {
 96793:         AutoCompartment ac(cx, fp->scopeChain());
 98921:         env = GetDebugScopeForFrame(cx, fp);
 84307:         if (!env)
 84307:             return false;
 84307:     }
 84307: 
106862:     return dbg->wrapEnvironment(cx, env, args.rval().address());
 84307: }
 84307: 
 75420: static JSBool
 91237: DebuggerFrame_getCallee(JSContext *cx, unsigned argc, Value *vp)
 75420: {
 76266:     THIS_FRAME(cx, argc, vp, "get callee", args, thisobj, fp);
 76266:     Value calleev = (fp->isFunctionFrame() && !fp->isEvalFrame()) ? fp->calleev() : NullValue();
 76266:     if (!Debugger::fromChildJSObject(thisobj)->wrapDebuggeeValue(cx, &calleev))
 76266:         return false;
106862:     args.rval().set(calleev);
 76266:     return true;
 75420: }
 75420: 
 75420: static JSBool
 91237: DebuggerFrame_getGenerator(JSContext *cx, unsigned argc, Value *vp)
 75413: {
 76266:     THIS_FRAME(cx, argc, vp, "get generator", args, thisobj, fp);
 76266:     args.rval().setBoolean(fp->isGeneratorFrame());
 75413:     return true;
 75413: }
 75413: 
 75419: static JSBool
 91237: DebuggerFrame_getConstructing(JSContext *cx, unsigned argc, Value *vp)
 75445: {
 76266:     THIS_FRAME(cx, argc, vp, "get constructing", args, thisobj, fp);
 76266:     args.rval().setBoolean(fp->isFunctionFrame() && fp->isConstructing());
 75445:     return true;
 75445: }
 75445: 
 75445: static JSBool
 91237: DebuggerFrame_getThis(JSContext *cx, unsigned argc, Value *vp)
 75418: {
 76266:     THIS_FRAME(cx, argc, vp, "get this", args, thisobj, fp);
 76266:     Value thisv;
 75419:     {
 96793:         AutoCompartment ac(cx, fp->scopeChain());
 75419:         if (!ComputeThis(cx, fp))
 75419:             return false;
 76266:         thisv = fp->thisValue();
 76266:     }
 76266:     if (!Debugger::fromChildJSObject(thisobj)->wrapDebuggeeValue(cx, &thisv))
 76266:         return false;
106862:     args.rval().set(thisv);
 76266:     return true;
 75425: }
 75425: 
 75425: static JSBool
 91237: DebuggerFrame_getOlder(JSContext *cx, unsigned argc, Value *vp)
 75425: {
 76266:     THIS_FRAME(cx, argc, vp, "get this", args, thisobj, thisfp);
 75513:     Debugger *dbg = Debugger::fromChildJSObject(thisobj);
 75425:     for (StackFrame *fp = thisfp->prev(); fp; fp = fp->prev()) {
 89335:         if (dbg->observesFrame(fp))
 75444:             return dbg->getScriptFrame(cx, fp, vp);
 75425:     }
 76266:     args.rval().setNull();
 75425:     return true;
 75418: }
 75418: 
 75513: Class DebuggerArguments_class = {
 75464:     "Arguments", JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGARGUMENTS_COUNT),
 78614:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 78614:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub
 75464: };
 75464: 
 76236: /* The getter used for each element of frame.arguments. See DebuggerFrame_getArguments. */
 76229: static JSBool
 91237: DebuggerArguments_getArg(JSContext *cx, unsigned argc, Value *vp)
 75464: {
119065:     AssertCanGC();
 76266:     CallArgs args = CallArgsFromVp(argc, vp);
 84755:     int32_t i = args.callee().toFunction()->getExtendedSlot(0).toInt32();
 75464: 
 76236:     /* Check that the this value is an Arguments object. */
 76266:     if (!args.thisv().isObject()) {
 75464:         ReportObjectRequired(cx);
 75464:         return false;
 75464:     }
119065:     RootedObject argsobj(cx, &args.thisv().toObject());
 75513:     if (argsobj->getClass() != &DebuggerArguments_class) {
 75464:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 75464:                              "Arguments", "getArgument", argsobj->getClass()->name);
 75464:         return false;
 75464:     }
 75464: 
 76236:     /*
 76236:      * Put the Debugger.Frame into the this-value slot, then use THIS_FRAME
 76236:      * to check that it is still live and get the fp.
 76236:      */
108174:     args.setThis(argsobj->getReservedSlot(JSSLOT_DEBUGARGUMENTS_FRAME));
 76266:     THIS_FRAME(cx, argc, vp, "get argument", ca2, thisobj, fp);
 75464: 
 76236:     /*
 76236:      * Since getters can be extracted and applied to other objects,
 76236:      * there is no guarantee this object has an ith argument.
 76236:      */
 75464:     JS_ASSERT(i >= 0);
119065:     RootedValue arg(cx);
119065:     RootedScript script(cx);
101075:     if (unsigned(i) < fp->numActualArgs()) {
119065:         script = fp->script();
108509:         if (unsigned(i) < fp->numFormalArgs() && script->formalIsAliased(i)) {
108509:             for (AliasedFormalIter fi(script); ; fi++) {
108509:                 if (fi.frameIndex() == unsigned(i)) {
108509:                     arg = fp->callObj().aliasedVar(fi);
108509:                     break;
108509:                 }
108509:             }
108509:         } else if (script->argsObjAliasesFormals() && fp->hasArgsObj()) {
101075:             arg = fp->argsObj().arg(i);
108509:         } else {
102445:             arg = fp->unaliasedActual(i, DONT_CHECK_ALIASING);
108509:         }
101075:     } else {
 76266:         arg.setUndefined();
101075:     }
 76266: 
119065:     if (!Debugger::fromChildJSObject(thisobj)->wrapDebuggeeValue(cx, arg.address()))
 76266:         return false;
106862:     args.rval().set(arg);
 76266:     return true;
 75464: }
 75464: 
 76229: static JSBool
 91237: DebuggerFrame_getArguments(JSContext *cx, unsigned argc, Value *vp)
 75418: {
 76266:     THIS_FRAME(cx, argc, vp, "get arguments", args, thisobj, fp);
 75464:     Value argumentsv = thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_ARGUMENTS);
 75464:     if (!argumentsv.isUndefined()) {
 75464:         JS_ASSERT(argumentsv.isObjectOrNull());
106862:         args.rval().set(argumentsv);
 75464:         return true;
 75464:     }
 75464: 
 99421:     RootedObject argsobj(cx);
 75464:     if (fp->hasArgs()) {
 76236:         /* Create an arguments object. */
 99421:         Rooted<GlobalObject*> global(cx);
 86483:         global = &args.callee().global();
 89843:         JSObject *proto = global->getOrCreateArrayPrototype(cx);
 89843:         if (!proto)
 75464:             return false;
 83275:         argsobj = NewObjectWithGivenProto(cx, &DebuggerArguments_class, proto, global);
 89826:         if (!argsobj)
 75464:             return false;
 89826:         SetReservedSlot(argsobj, JSSLOT_DEBUGARGUMENTS_FRAME, ObjectValue(*thisobj));
 75464: 
 75464:         JS_ASSERT(fp->numActualArgs() <= 0x7fffffff);
102586:         unsigned fargc = fp->numActualArgs();
106862:         RootedValue fargcVal(cx, Int32Value(fargc));
114207:         if (!DefineNativeProperty(cx, argsobj, cx->names().length,
106862:                                   fargcVal, NULL, NULL,
 75464:                                   JSPROP_PERMANENT | JSPROP_READONLY, 0, 0))
 75464:         {
 75464:             return false;
 75464:         }
 75464: 
102586:         Rooted<jsid> id(cx);
106862:         RootedValue undefinedValue(cx, UndefinedValue());
102586:         for (unsigned i = 0; i < fargc; i++) {
 99421:             RootedFunction getobj(cx);
121256:             getobj = js_NewFunction(cx, NullPtr(), DebuggerArguments_getArg, 0,
121256:                                     JSFunction::NATIVE_FUN, global, NullPtr(),
121256:                                     JSFunction::ExtendedFinalizeKind);
102586:             if (!getobj)
102586:                 return false;
102586:             id = INT_TO_JSID(i);
 75464:             if (!getobj ||
106862:                 !DefineNativeProperty(cx, argsobj, id, undefinedValue,
103637:                                       JS_DATA_TO_FUNC_PTR(PropertyOp, getobj.get()), NULL,
 75464:                                       JSPROP_ENUMERATE | JSPROP_SHARED | JSPROP_GETTER, 0, 0))
 75464:             {
 75464:                 return false;
 75464:             }
 83301:             getobj->setExtendedSlot(0, Int32Value(i));
 75464:         }
 75464:     } else {
 75464:         argsobj = NULL;
 75464:     }
106862:     args.rval().setObjectOrNull(argsobj);
 76266:     thisobj->setReservedSlot(JSSLOT_DEBUGFRAME_ARGUMENTS, args.rval());
 75418:     return true;
 75418: }
 75418: 
 75419: static JSBool
 91237: DebuggerFrame_getScript(JSContext *cx, unsigned argc, Value *vp)
 75492: {
 76266:     THIS_FRAME(cx, argc, vp, "get script", args, thisobj, fp);
 75513:     Debugger *debug = Debugger::fromChildJSObject(thisobj);
 75492: 
119065:     RootedObject scriptObject(cx);
 75492:     if (fp->isFunctionFrame() && !fp->isEvalFrame()) {
 98921:         JSFunction &callee = fp->callee();
 98921:         if (callee.isInterpreted()) {
123827:             RootedScript script(cx, callee.nonLazyScript());
102586:             scriptObject = debug->wrapScript(cx, script);
 75492:             if (!scriptObject)
 75492:                 return false;
 75492:         }
109256:     } else {
 76236:         /*
 79905:          * We got eval, JS_Evaluate*, or JS_ExecuteScript non-function script
 79905:          * frames.
 76236:          */
119065:         RootedScript script(cx, fp->script());
102586:         scriptObject = debug->wrapScript(cx, script);
 75492:         if (!scriptObject)
 75492:             return false;
 75492:     }
 76266:     args.rval().setObjectOrNull(scriptObject);
 75492:     return true;
 75492: }
 75492: 
 75492: static JSBool
 91237: DebuggerFrame_getOffset(JSContext *cx, unsigned argc, Value *vp)
 75500: {
 76266:     THIS_FRAME(cx, argc, vp, "get offset", args, thisobj, fp);
119065:     AutoAssertNoGC nogc;
121004:     RawScript script = fp->script().get(nogc);
 75500:     jsbytecode *pc = fp->pcQuadratic(cx);
 75500:     JS_ASSERT(script->code <= pc);
 75500:     JS_ASSERT(pc < script->code + script->length);
 75500:     size_t offset = pc - script->code;
 76266:     args.rval().setNumber(double(offset));
 75500:     return true;
 75500: }
 75500: 
 75500: static JSBool
 91237: DebuggerFrame_getLive(JSContext *cx, unsigned argc, Value *vp)
 75414: {
 76266:     CallArgs args = CallArgsFromVp(argc, vp);
 76266:     JSObject *thisobj = CheckThisFrame(cx, args, "get live", false);
 75414:     if (!thisobj)
 75414:         return false;
 75415:     StackFrame *fp = (StackFrame *) thisobj->getPrivate();
 76266:     args.rval().setBoolean(!!fp);
 75414:     return true;
 75414: }
 75414: 
 77171: static bool
 77171: IsValidHook(const Value &v)
 77171: {
 77171:     return v.isUndefined() || (v.isObject() && v.toObject().isCallable());
 77171: }
 77171: 
 77171: static JSBool
 91237: DebuggerFrame_getOnStep(JSContext *cx, unsigned argc, Value *vp)
 77171: {
 77171:     THIS_FRAME(cx, argc, vp, "get onStep", args, thisobj, fp);
 77171:     (void) fp;  // Silence GCC warning
 77171:     Value handler = thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER);
 77171:     JS_ASSERT(IsValidHook(handler));
106862:     args.rval().set(handler);
 77171:     return true;
 77171: }
 77171: 
 77171: static JSBool
 91237: DebuggerFrame_setOnStep(JSContext *cx, unsigned argc, Value *vp)
 77171: {
 77171:     REQUIRE_ARGC("Debugger.Frame.set onStep", 1);
 77171:     THIS_FRAME(cx, argc, vp, "set onStep", args, thisobj, fp);
 77171:     if (!IsValidHook(args[0])) {
 77171:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_CALLABLE_OR_UNDEFINED);
 77171:         return false;
 77171:     }
 77171: 
 77171:     Value prior = thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER);
 77171:     int delta = !args[0].isUndefined() - !prior.isUndefined();
 77171:     if (delta != 0) {
 77171:         /* Try to adjust this frame's script single-step mode count. */
 96793:         AutoCompartment ac(cx, fp->scopeChain());
 77171:         if (!fp->script()->changeStepModeCount(cx, delta))
 77171:             return false;
 77171:     }
 77171: 
 77171:     /* Now that the step mode switch has succeeded, we can install the handler. */
 77171:     thisobj->setReservedSlot(JSSLOT_DEBUGFRAME_ONSTEP_HANDLER, args[0]);
 77171:     args.rval().setUndefined();
 77171:     return true;
 77171: }
 77171: 
 91435: static JSBool
 91435: DebuggerFrame_getOnPop(JSContext *cx, unsigned argc, Value *vp)
 91435: {
 91435:     THIS_FRAME(cx, argc, vp, "get onPop", args, thisobj, fp);
 91435:     (void) fp;  // Silence GCC warning
 91435:     Value handler = thisobj->getReservedSlot(JSSLOT_DEBUGFRAME_ONPOP_HANDLER);
 91435:     JS_ASSERT(IsValidHook(handler));
106862:     args.rval().set(handler);
 91435:     return true;
 91435: }
 91435: 
 91435: static JSBool
 91435: DebuggerFrame_setOnPop(JSContext *cx, unsigned argc, Value *vp)
 91435: {
 91435:     REQUIRE_ARGC("Debugger.Frame.set onPop", 1);
 91435:     THIS_FRAME(cx, argc, vp, "set onPop", args, thisobj, fp);
110698:     (void) fp;  // Silence GCC warning
 91435:     if (!IsValidHook(args[0])) {
 91435:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_CALLABLE_OR_UNDEFINED);
 91435:         return false;
 91435:     }
 91435: 
 91435:     thisobj->setReservedSlot(JSSLOT_DEBUGFRAME_ONPOP_HANDLER, args[0]);
 91435:     args.rval().setUndefined();
 91435:     return true;
 91435: }
 91435: 
118426: /*
118426:  * Evaluate |chars[0..length-1]| in the environment |env|, treating that
118426:  * source as appearing starting at |lineno| in |filename|. Store the return
118426:  * value in |*rval|. Use |thisv| as the 'this' value.
118426:  *
118426:  * If |fp| is non-NULL, evaluate as for a direct eval in that frame; |env|
118426:  * must be either |fp|'s DebugScopeObject, or some extension of that
118426:  * environment; either way, |fp|'s scope is where newly declared variables
118426:  * go. In this case, |fp| must have a computed 'this' value, equal to |thisv|.
118426:  */
 75472: JSBool
118426: js::EvaluateInEnv(JSContext *cx, Handle<Env*> env, HandleValue thisv, StackFrame *fp,
118470:                   StableCharPtr chars, unsigned length, const char *filename, unsigned lineno,
118426:                   Value *rval)
 75472: {
 84307:     assertSameCompartment(cx, env, fp);
118426:     JS_ASSERT_IF(fp, thisv.get() == fp->thisValue());
 84307: 
118470:     JS_ASSERT(!IsPoisonedPtr(chars.get()));
 97353: 
 75472:     /*
 75472:      * NB: This function breaks the assumption that the compiler can see all
101616:      * calls and properly compute a static level. In practice, any non-zero
101616:      * static level will suffice.
 75472:      */
106508:     CompileOptions options(cx);
111508:     options.setPrincipals(env->compartment()->principals)
106508:            .setCompileAndGo(true)
106508:            .setNoScriptRval(false)
106508:            .setFileAndLine(filename, lineno);
107154:     RootedScript script(cx, frontend::CompileScript(cx, env, fp, options, chars, length,
111508:                                                     /* source = */ NULL,
111508:                                                     /* staticLevel = */ fp ? 1 : 0));
 75472:     if (!script)
 75472:         return false;
 75472: 
101075:     script->isActiveEval = true;
111508:     return ExecuteKernel(cx, script, *env, thisv, EXECUTE_DEBUG, fp, rval);
 75472: }
 75472: 
 75419: static JSBool
111507: DebuggerGenericEval(JSContext *cx, const char *fullMethodName,
111507:                     const Value &code, Value *bindings, Value *vp,
111507:                     Debugger *dbg, HandleObject scope, StackFrame *fp)
 75433: {
111507:     /* Either we're specifying the frame, or a global. */
111507:     JS_ASSERT_IF(fp, !scope);
111507:     JS_ASSERT_IF(!fp, scope && scope->isGlobal());
 75433: 
 76236:     /* Check the first argument, the eval code string. */
111507:     if (!code.isString()) {
 75433:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_EXPECTED_TYPE,
111507:                              fullMethodName, "string", InformalValueTypeName(code));
 75433:         return false;
 75433:     }
114424:     Rooted<JSStableString *> stable(cx, code.toString()->ensureStable(cx));
114424:     if (!stable)
 75433:         return false;
 75472: 
 76236:     /*
 76236:      * Gather keys and values of bindings, if any. This must be done in the
 76236:      * debugger compartment, since that is where any exceptions must be
 76236:      * thrown.
 76236:      */
 75472:     AutoIdVector keys(cx);
 75472:     AutoValueVector values(cx);
111507:     if (bindings) {
111507:         RootedObject bindingsobj(cx, NonNullObject(cx, *bindings));
 75472:         if (!bindingsobj ||
 75472:             !GetPropertyNames(cx, bindingsobj, JSITER_OWNONLY, &keys) ||
 75472:             !values.growBy(keys.length()))
 75472:         {
 75472:             return false;
 75472:         }
 75472:         for (size_t i = 0; i < keys.length(); i++) {
106862:             HandleId keyp = HandleId::fromMarkedLocation(&keys[i]);
106862:             MutableHandleValue valp = MutableHandleValue::fromMarkedLocation(&values[i]);
108951:             if (!JSObject::getGeneric(cx, bindingsobj, bindingsobj, keyp, valp) ||
106862:                 !dbg->unwrapDebuggeeValue(cx, valp.address()))
 75472:             {
 75472:                 return false;
 75472:             }
 75472:         }
 75472:     }
 75433: 
109257:     Maybe<AutoCompartment> ac;
111508:     if (fp)
109257:         ac.construct(cx, fp->scopeChain());
111508:     else
111508:         ac.construct(cx, scope);
111508: 
118426:     RootedValue thisv(cx);
118426:     Rooted<Env *> env(cx);
118426:     if (fp) {
118426:         /* ExecuteInEnv requires 'fp' to have a computed 'this" value. */
118426:         if (!ComputeThis(cx, fp))
118426:             return false;
118426:         thisv = fp->thisValue();
118426:         env = GetDebugScopeForFrame(cx, fp);
 84307:         if (!env)
 75472:             return false;
118426:     } else {
118426:         thisv = ObjectValue(*scope);
118426:         env = scope;
118426:     }
 75472: 
 84307:     /* If evalWithBindings, create the inner environment. */
111507:     if (bindings) {
 84307:         /* TODO - This should probably be a Call object, like ES5 strict eval. */
 84307:         env = NewObjectWithGivenProto(cx, &ObjectClass, NULL, env);
 84307:         if (!env)
 75472:             return false;
 99421:         RootedId id(cx);
 75472:         for (size_t i = 0; i < keys.length(); i++) {
 98960:             id = keys[i];
106862:             MutableHandleValue val = MutableHandleValue::fromMarkedLocation(&values[i]);
106862:             if (!cx->compartment->wrap(cx, val.address()) ||
106862:                 !DefineNativeProperty(cx, env, id, val, NULL, NULL, 0, 0, 0))
 75472:             {
 75472:                 return false;
 75472:             }
 75472:         }
 75472:     }
 75472: 
 76236:     /* Run the code and produce the completion value. */
 75433:     Value rval;
114424:     JS::Anchor<JSString *> anchor(stable);
118426:     bool ok = EvaluateInEnv(cx, env, thisv, fp, stable->chars(), stable->length(),
 75472:                             "debugger eval code", 1, &rval);
 91434:     return dbg->receiveCompletionValue(ac, ok, rval, vp);
 75433: }
 75433: 
 75433: static JSBool
 91237: DebuggerFrame_eval(JSContext *cx, unsigned argc, Value *vp)
 75472: {
111507:     THIS_FRAME(cx, argc, vp, "eval", args, thisobj, fp);
111507:     REQUIRE_ARGC("Debugger.Frame.prototype.eval", 1);
111507:     Debugger *dbg = Debugger::fromChildJSObject(thisobj);
111507:     return DebuggerGenericEval(cx, "Debugger.Frame.prototype.eval",
111507:                                args[0], NULL, vp, dbg, NullPtr(), fp);
 75472: }
 75472: 
 75472: static JSBool
 91237: DebuggerFrame_evalWithBindings(JSContext *cx, unsigned argc, Value *vp)
 75472: {
111507:     THIS_FRAME(cx, argc, vp, "evalWithBindings", args, thisobj, fp);
111507:     REQUIRE_ARGC("Debugger.Frame.prototype.evalWithBindings", 2);
111507:     Debugger *dbg = Debugger::fromChildJSObject(thisobj);
111507:     return DebuggerGenericEval(cx, "Debugger.Frame.prototype.evalWithBindings",
111507:                                args[0], &args[1], vp, dbg, NullPtr(), fp);
 75472: }
 75472: 
 75472: static JSBool
 91237: DebuggerFrame_construct(JSContext *cx, unsigned argc, Value *vp)
 75413: {
 75513:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR, "Debugger.Frame");
 75413:     return false;
 75413: }
 75413: 
 75513: static JSPropertySpec DebuggerFrame_properties[] = {
 75513:     JS_PSG("arguments", DebuggerFrame_getArguments, 0),
 75513:     JS_PSG("callee", DebuggerFrame_getCallee, 0),
 75513:     JS_PSG("constructing", DebuggerFrame_getConstructing, 0),
 84307:     JS_PSG("environment", DebuggerFrame_getEnvironment, 0),
 75513:     JS_PSG("generator", DebuggerFrame_getGenerator, 0),
 75513:     JS_PSG("live", DebuggerFrame_getLive, 0),
 75513:     JS_PSG("offset", DebuggerFrame_getOffset, 0),
 75513:     JS_PSG("older", DebuggerFrame_getOlder, 0),
 75513:     JS_PSG("script", DebuggerFrame_getScript, 0),
 75513:     JS_PSG("this", DebuggerFrame_getThis, 0),
 75513:     JS_PSG("type", DebuggerFrame_getType, 0),
 77171:     JS_PSGS("onStep", DebuggerFrame_getOnStep, DebuggerFrame_setOnStep, 0),
 91435:     JS_PSGS("onPop", DebuggerFrame_getOnPop, DebuggerFrame_setOnPop, 0),
 75413:     JS_PS_END
 75413: };
 75413: 
 75513: static JSFunctionSpec DebuggerFrame_methods[] = {
 75513:     JS_FN("eval", DebuggerFrame_eval, 1, 0),
 75513:     JS_FN("evalWithBindings", DebuggerFrame_evalWithBindings, 1, 0),
 75433:     JS_FS_END
 75433: };
 75433: 
 75466: 
 76236: /*** Debugger.Object *****************************************************************************/
 75418: 
 75495: static void
115876: DebuggerObject_trace(JSTracer *trc, RawObject obj)
 75495: {
 82129:     /*
 82129:      * There is a barrier on private pointers, so the Unbarriered marking
 82129:      * is okay.
 82129:      */
 91557:     if (JSObject *referent = (JSObject *) obj->getPrivate()) {
124078:         MarkCrossCompartmentObjectUnbarriered(trc, obj, &referent, "Debugger.Object referent");
 91849:         obj->setPrivateUnbarriered(referent);
 91557:     }
 75495: }
 75495: 
 75513: Class DebuggerObject_class = {
 90410:     "Object",
 90410:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS |
 90410:     JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGOBJECT_COUNT),
 78614:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 78614:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, NULL,
 75495:     NULL,                 /* checkAccess */
 75495:     NULL,                 /* call        */
 75495:     NULL,                 /* construct   */
 75495:     NULL,                 /* hasInstance */
 75513:     DebuggerObject_trace
 75418: };
 75418: 
 75419: static JSObject *
 76267: DebuggerObject_checkThis(JSContext *cx, const CallArgs &args, const char *fnname)
 75419: {
119065:     AssertCanGC();
 76267:     if (!args.thisv().isObject()) {
 75419:         ReportObjectRequired(cx);
 75419:         return NULL;
 75419:     }
 76267:     JSObject *thisobj = &args.thisv().toObject();
 77817:     if (thisobj->getClass() != &DebuggerObject_class) {
 75419:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 75513:                              "Debugger.Object", fnname, thisobj->getClass()->name);
 75419:         return NULL;
 75419:     }
 75419: 
 76236:     /*
 76236:      * Forbid Debugger.Object.prototype, which is of class DebuggerObject_class
 76236:      * but isn't a real working Debugger.Object. The prototype object is
 76236:      * distinguished by having no referent.
 76236:      */
 75495:     if (!thisobj->getPrivate()) {
 75419:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 75513:                              "Debugger.Object", fnname, "prototype object");
 75419:         return NULL;
 75419:     }
 75419:     return thisobj;
 75419: }
 75419: 
 76267: #define THIS_DEBUGOBJECT_REFERENT(cx, argc, vp, fnname, args, obj)            \
 76267:     CallArgs args = CallArgsFromVp(argc, vp);                                 \
 99421:     RootedObject obj(cx, DebuggerObject_checkThis(cx, args, fnname));         \
 75451:     if (!obj)                                                                 \
 75419:         return false;                                                         \
 75495:     obj = (JSObject *) obj->getPrivate();                                     \
 75495:     JS_ASSERT(obj)
 75419: 
 76267: #define THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, fnname, args, dbg, obj) \
 76267:     CallArgs args = CallArgsFromVp(argc, vp);                                 \
 99421:     RootedObject obj(cx, DebuggerObject_checkThis(cx, args, fnname));         \
 75488:     if (!obj)                                                                 \
 75488:         return false;                                                         \
 75513:     Debugger *dbg = Debugger::fromChildJSObject(obj);                         \
 75495:     obj = (JSObject *) obj->getPrivate();                                     \
 75495:     JS_ASSERT(obj)
 75488: 
 75419: static JSBool
 91237: DebuggerObject_construct(JSContext *cx, unsigned argc, Value *vp)
 75418: {
119065:     AssertCanGC();
 75513:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR, "Debugger.Object");
 75418:     return false;
 75418: }
 75418: 
 75419: static JSBool
 91237: DebuggerObject_getProto(JSContext *cx, unsigned argc, Value *vp)
 75432: {
119065:     AssertCanGC();
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get proto", args, dbg, refobj);
115021:     RootedObject proto(cx);
115021:     {
115021:         AutoCompartment ac(cx, refobj);
115021:         if (!JSObject::getProto(cx, refobj, &proto))
115021:             return false;
115021:     }
115021:     Value protov = ObjectOrNullValue(proto);
 76267:     if (!dbg->wrapDebuggeeValue(cx, &protov))
 76267:         return false;
106862:     args.rval().set(protov);
 76267:     return true;
 75432: }
 75432: 
 75432: static JSBool
 91237: DebuggerObject_getClass(JSContext *cx, unsigned argc, Value *vp)
 75419: {
119065:     AssertCanGC();
 76267:     THIS_DEBUGOBJECT_REFERENT(cx, argc, vp, "get class", args, refobj);
 77817:     const char *s = refobj->getClass()->name;
107982:     JSAtom *str = Atomize(cx, s, strlen(s));
 75419:     if (!str)
 75419:         return false;
 76267:     args.rval().setString(str);
 75419:     return true;
 75419: }
 75419: 
 75420: static JSBool
 91237: DebuggerObject_getCallable(JSContext *cx, unsigned argc, Value *vp)
 75438: {
 76267:     THIS_DEBUGOBJECT_REFERENT(cx, argc, vp, "get callable", args, refobj);
 76267:     args.rval().setBoolean(refobj->isCallable());
 75438:     return true;
 75438: }
 75438: 
 75438: static JSBool
 91237: DebuggerObject_getName(JSContext *cx, unsigned argc, Value *vp)
 75420: {
119065:     AssertCanGC();
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get name", args, dbg, obj);
 75460:     if (!obj->isFunction()) {
 76267:         args.rval().setUndefined();
 75460:         return true;
 75460:     }
 75460: 
109108:     JSString *name = obj->toFunction()->atom();
 75460:     if (!name) {
 76267:         args.rval().setUndefined();
 75460:         return true;
 75460:     }
 75460: 
 76267:     Value namev = StringValue(name);
 76267:     if (!dbg->wrapDebuggeeValue(cx, &namev))
 76267:         return false;
106862:     args.rval().set(namev);
 76267:     return true;
 75421: }
 75460: 
 75460: static JSBool
109110: DebuggerObject_getDisplayName(JSContext *cx, unsigned argc, Value *vp)
109110: {
119065:     AssertCanGC();
109110:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get display name", args, dbg, obj);
109110:     if (!obj->isFunction()) {
109110:         args.rval().setUndefined();
109110:         return true;
109110:     }
109110: 
109110:     JSString *name = obj->toFunction()->displayAtom();
109110:     if (!name) {
109110:         args.rval().setUndefined();
109110:         return true;
109110:     }
109110: 
109110:     Value namev = StringValue(name);
109110:     if (!dbg->wrapDebuggeeValue(cx, &namev))
109110:         return false;
109110:     args.rval().set(namev);
109110:     return true;
109110: }
109110: 
109110: static JSBool
 91237: DebuggerObject_getParameterNames(JSContext *cx, unsigned argc, Value *vp)
 75460: {
119065:     AssertCanGC();
 76267:     THIS_DEBUGOBJECT_REFERENT(cx, argc, vp, "get parameterNames", args, obj);
 75460:     if (!obj->isFunction()) {
 76267:         args.rval().setUndefined();
 75460:         return true;
 75428:     }
 75460: 
 99421:     RootedFunction fun(cx, obj->toFunction());
106505:     JSObject *result = NewDenseAllocatedArray(cx, fun->nargs);
 75460:     if (!result)
 75460:         return false;
 77434:     result->ensureDenseArrayInitializedLength(cx, 0, fun->nargs);
 75460: 
 75460:     if (fun->isInterpreted()) {
123827:         JS_ASSERT(fun->nargs == fun->nonLazyScript()->bindings.numArgs());
 75460: 
 75460:         if (fun->nargs > 0) {
108509:             BindingVector bindings(cx);
123827:             RootedScript script(cx, fun->nonLazyScript());
115706:             if (!FillBindingVector(script, &bindings))
 75460:                 return false;
 75460:             for (size_t i = 0; i < fun->nargs; i++) {
108505:                 Value v;
108509:                 if (bindings[i].name()->length() == 0)
108505:                     v = UndefinedValue();
108505:                 else
108509:                     v = StringValue(bindings[i].name());
108505:                 result->setDenseArrayElement(i, v);
 75460:             }
 75460:         }
 75460:     } else {
 75460:         for (size_t i = 0; i < fun->nargs; i++)
 76246:             result->setDenseArrayElement(i, UndefinedValue());
 75460:     }
 75460: 
 76267:     args.rval().setObject(*result);
 75421:     return true;
 75421: }
 75421: 
 75492: static JSBool
 91237: DebuggerObject_getScript(JSContext *cx, unsigned argc, Value *vp)
 75492: {
119065:     AssertCanGC();
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get script", args, dbg, obj);
 76267: 
 84307:     if (!obj->isFunction()) {
 76267:         args.rval().setUndefined();
 75492:         return true;
 84307:     }
 75492: 
119065:     RootedFunction fun(cx, obj->toFunction());
 84307:     if (!fun->isInterpreted()) {
 84307:         args.rval().setUndefined();
 75492:         return true;
 84307:     }
 75492: 
123827:     RootedScript script(cx, fun->nonLazyScript());
119065:     RootedObject scriptObject(cx, dbg->wrapScript(cx, script));
 75492:     if (!scriptObject)
 75492:         return false;
 75492: 
 76267:     args.rval().setObject(*scriptObject);
 75492:     return true;
 75492: }
 75492: 
 76214: static JSBool
 91237: DebuggerObject_getEnvironment(JSContext *cx, unsigned argc, Value *vp)
 84307: {
119065:     AssertCanGC();
 84307:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get environment", args, dbg, obj);
 84307: 
 84307:     /* Don't bother switching compartments just to check obj's type and get its env. */
 84307:     if (!obj->isFunction() || !obj->toFunction()->isInterpreted()) {
 84307:         args.rval().setUndefined();
 84307:         return true;
 84307:     }
 84307: 
 99421:     Rooted<Env*> env(cx);
 98921:     {
 98921:         AutoCompartment ac(cx, obj);
 98921:         env = GetDebugScopeForFunction(cx, obj->toFunction());
 98921:         if (!env)
 98921:             return false;
 98921:     }
 98921: 
106862:     return dbg->wrapEnvironment(cx, env, args.rval().address());
 84307: }
 84307: 
 84307: static JSBool
118847: DebuggerObject_getGlobal(JSContext *cx, unsigned argc, Value *vp)
118847: {
118847:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "get global", args, dbg, obj);
118847: 
118847:     Value v = ObjectValue(obj->global());
118847:     if (!dbg->wrapDebuggeeValue(cx, &v))
118847:         return false;
118847:     args.rval().set(v);
118847:     return true;
118847: }
118847: 
118847: static JSBool
 91237: DebuggerObject_getOwnPropertyDescriptor(JSContext *cx, unsigned argc, Value *vp)
 76214: {
119065:     AssertCanGC();
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "getOwnPropertyDescriptor", args, dbg, obj);
 76214: 
 99421:     RootedId id(cx);
 95355:     if (!ValueToId(cx, argc >= 1 ? args[0] : UndefinedValue(), id.address()))
 76214:         return false;
 76214: 
 76236:     /* Bug: This can cause the debuggee to run! */
 76214:     AutoPropertyDescriptorRooter desc(cx);
 76214:     {
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, obj);
109257:         if (!cx->compartment->wrapId(cx, id.address()))
 76214:             return false;
 76214: 
 76810:         ErrorCopier ec(ac, dbg->toJSObject());
 76214:         if (!GetOwnPropertyDescriptor(cx, obj, id, &desc))
 76214:             return false;
 76214:     }
 76214: 
 76214:     if (desc.obj) {
 76236:         /* Rewrap the debuggee values in desc for the debugger. */
 76214:         if (!dbg->wrapDebuggeeValue(cx, &desc.value))
 76214:             return false;
 76214:         if (desc.attrs & JSPROP_GETTER) {
 76214:             Value get = ObjectOrNullValue(CastAsObject(desc.getter));
 76214:             if (!dbg->wrapDebuggeeValue(cx, &get))
 76214:                 return false;
 76214:             desc.getter = CastAsPropertyOp(get.toObjectOrNull());
 76214:         }
 76214:         if (desc.attrs & JSPROP_SETTER) {
 76214:             Value set = ObjectOrNullValue(CastAsObject(desc.setter));
 76214:             if (!dbg->wrapDebuggeeValue(cx, &set))
 76214:                 return false;
 76214:             desc.setter = CastAsStrictPropertyOp(set.toObjectOrNull());
 76214:         }
 76214:     }
 76214: 
106862:     return NewPropertyDescriptorObject(cx, &desc, args.rval().address());
 76214: }
 76214: 
 76215: static JSBool
 91237: DebuggerObject_getOwnPropertyNames(JSContext *cx, unsigned argc, Value *vp)
 76215: {
119065:     AssertCanGC();
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "getOwnPropertyNames", args, dbg, obj);
 76215: 
 76215:     AutoIdVector keys(cx);
 76215:     {
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, obj);
 76810:         ErrorCopier ec(ac, dbg->toJSObject());
 76215:         if (!GetPropertyNames(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &keys))
 76215:             return false;
 76215:     }
 76215: 
 76215:     AutoValueVector vals(cx);
 76215:     if (!vals.resize(keys.length()))
 76215:         return false;
 76215: 
 76215:     for (size_t i = 0, len = keys.length(); i < len; i++) {
 76215:          jsid id = keys[i];
 76215:          if (JSID_IS_INT(id)) {
102228:              JSString *str = Int32ToString(cx, JSID_TO_INT(id));
 76215:              if (!str)
 76215:                  return false;
 76215:              vals[i].setString(str);
 76215:          } else if (JSID_IS_ATOM(id)) {
 76215:              vals[i].setString(JSID_TO_STRING(id));
 76215:              if (!cx->compartment->wrap(cx, &vals[i]))
 76215:                  return false;
 76215:          } else {
 76215:              vals[i].setObject(*JSID_TO_OBJECT(id));
 76215:              if (!dbg->wrapDebuggeeValue(cx, &vals[i]))
 76215:                  return false;
 76215:          }
 76215:     }
 76215: 
 76215:     JSObject *aobj = NewDenseCopiedArray(cx, vals.length(), vals.begin());
 76215:     if (!aobj)
 76215:         return false;
 76267:     args.rval().setObject(*aobj);
 76215:     return true;
 76215: }
 76215: 
 76223: static JSBool
 91237: DebuggerObject_defineProperty(JSContext *cx, unsigned argc, Value *vp)
 76223: {
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "defineProperty", args, dbg, obj);
 76251:     REQUIRE_ARGC("Debugger.Object.defineProperty", 2);
 76223: 
 99421:     RootedId id(cx);
 95355:     if (!ValueToId(cx, args[0], id.address()))
 97047:         return false;
 76223: 
 76267:     const Value &descval = args[1];
 76223:     AutoPropDescArrayRooter descs(cx);
 97047:     if (!descs.reserve(3)) // desc, unwrappedDesc, rewrappedDesc
 97047:         return false;
 76223:     PropDesc *desc = descs.append();
 76223:     if (!desc || !desc->initialize(cx, descval, false))
 76223:         return false;
 97047:     desc->clearPd();
 97047: 
 97047:     PropDesc *unwrappedDesc = descs.append();
 97047:     if (!unwrappedDesc || !desc->unwrapDebuggerObjectsInto(cx, dbg, obj, unwrappedDesc))
 76223:         return false;
 76223: 
 76223:     {
 97047:         PropDesc *rewrappedDesc = descs.append();
 97047:         if (!rewrappedDesc)
 97047:             return false;
 99421:         RootedId wrappedId(cx);
 97047: 
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, obj);
109257:         if (!unwrappedDesc->wrapInto(cx, obj, id, wrappedId.address(), rewrappedDesc))
 76223:             return false;
 76224: 
 76224:         ErrorCopier ec(ac, dbg->toJSObject());
 76224:         bool dummy;
 97047:         if (!DefineProperty(cx, obj, wrappedId, *rewrappedDesc, true, &dummy))
 76223:             return false;
 76223:     }
 76223: 
 76267:     args.rval().setUndefined();
 76223:     return true;
 76223: }
 76214: 
 76224: static JSBool
 91237: DebuggerObject_defineProperties(JSContext *cx, unsigned argc, Value *vp)
 76224: {
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "defineProperties", args, dbg, obj);
 76224:     REQUIRE_ARGC("Debugger.Object.defineProperties", 1);
108174: 
108174:     RootedValue arg(cx, args[0]);
108174:     RootedObject props(cx, ToObject(cx, arg));
 76224:     if (!props)
 76224:         return false;
 76224: 
 76224:     AutoIdVector ids(cx);
 76224:     AutoPropDescArrayRooter descs(cx);
 76224:     if (!ReadPropertyDescriptors(cx, props, false, &ids, &descs))
 76224:         return false;
 76224:     size_t n = ids.length();
 76224: 
 97047:     AutoPropDescArrayRooter unwrappedDescs(cx);
 76224:     for (size_t i = 0; i < n; i++) {
 97047:         if (!unwrappedDescs.append())
 76224:             return false;
 97047:         if (!descs[i].unwrapDebuggerObjectsInto(cx, dbg, obj, &unwrappedDescs[i]))
 97047:             return false;
 76224:     }
 76224: 
 76224:     {
 97047:         AutoIdVector rewrappedIds(cx);
 97047:         AutoPropDescArrayRooter rewrappedDescs(cx);
 97047: 
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, obj);
 76224:         for (size_t i = 0; i < n; i++) {
 97047:             if (!rewrappedIds.append(jsid()) || !rewrappedDescs.append())
 97047:                 return false;
 97047:             if (!unwrappedDescs[i].wrapInto(cx, obj, ids[i], &rewrappedIds[i], &rewrappedDescs[i]))
 76224:                 return false;
 76224:         }
 76224: 
 76224:         ErrorCopier ec(ac, dbg->toJSObject());
 76224:         for (size_t i = 0; i < n; i++) {
 76224:             bool dummy;
102586:             if (!DefineProperty(cx, obj, Handle<jsid>::fromMarkedLocation(&rewrappedIds[i]),
102586:                                 rewrappedDescs[i], true, &dummy))
102586:             {
 76224:                 return false;
 76224:             }
 76224:         }
102586:     }
 76224: 
 76267:     args.rval().setUndefined();
 76224:     return true;
 76224: }
 76224: 
 76236: /*
 76236:  * This does a non-strict delete, as a matter of API design. The case where the
 76236:  * property is non-configurable isn't necessarily exceptional here.
 76236:  */
 76225: static JSBool
 91237: DebuggerObject_deleteProperty(JSContext *cx, unsigned argc, Value *vp)
 76225: {
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "deleteProperty", args, dbg, obj);
 86790:     Value nameArg = argc > 0 ? args[0] : UndefinedValue();
 86790: 
109257:     Maybe<AutoCompartment> ac;
109257:     ac.construct(cx, obj);
109257:     if (!cx->compartment->wrap(cx, &nameArg))
 76225:         return false;
 76225: 
 76225:     ErrorCopier ec(ac, dbg->toJSObject());
108951:     return JSObject::deleteByValue(cx, obj, nameArg, args.rval(), false);
 76225: }
 76224: 
 76228: enum SealHelperOp { Seal, Freeze, PreventExtensions };
 76228: 
 76228: static JSBool
 91237: DebuggerObject_sealHelper(JSContext *cx, unsigned argc, Value *vp, SealHelperOp op, const char *name)
 76228: {
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, name, args, dbg, obj);
 76228: 
109257:     Maybe<AutoCompartment> ac;
109257:     ac.construct(cx, obj);
 76228:     ErrorCopier ec(ac, dbg->toJSObject());
 76228:     bool ok;
 76228:     if (op == Seal) {
108951:         ok = JSObject::seal(cx, obj);
 76228:     } else if (op == Freeze) {
108951:         ok = JSObject::freeze(cx, obj);
 76228:     } else {
 76228:         JS_ASSERT(op == PreventExtensions);
 76269:         if (!obj->isExtensible()) {
 76269:             args.rval().setUndefined();
 76228:             return true;
 76269:         }
 97157:         ok = obj->preventExtensions(cx);
 76228:     }
 76228:     if (!ok)
 76228:         return false;
 76267:     args.rval().setUndefined();
 76267:     return true;
 76228: }
 76228: 
 76228: static JSBool
 91237: DebuggerObject_seal(JSContext *cx, unsigned argc, Value *vp)
 76228: {
 76228:     return DebuggerObject_sealHelper(cx, argc, vp, Seal, "seal");
 76228: }
 76228: 
 76228: static JSBool
 91237: DebuggerObject_freeze(JSContext *cx, unsigned argc, Value *vp)
 76228: {
 76228:     return DebuggerObject_sealHelper(cx, argc, vp, Freeze, "freeze");
 76228: }
 76228: 
 76228: static JSBool
 91237: DebuggerObject_preventExtensions(JSContext *cx, unsigned argc, Value *vp)
 76228: {
 76228:     return DebuggerObject_sealHelper(cx, argc, vp, PreventExtensions, "preventExtensions");
 76228: }
 76228: 
 76228: static JSBool
 91237: DebuggerObject_isSealedHelper(JSContext *cx, unsigned argc, Value *vp, SealHelperOp op,
 76228:                               const char *name)
 76228: {
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, name, args, dbg, obj);
 76228: 
109257:     Maybe<AutoCompartment> ac;
109257:     ac.construct(cx, obj);
 76228:     ErrorCopier ec(ac, dbg->toJSObject());
 76228:     bool r;
 76228:     if (op == Seal) {
104384:         if (!JSObject::isSealed(cx, obj, &r))
 76228:             return false;
 76228:     } else if (op == Freeze) {
104384:         if (!JSObject::isFrozen(cx, obj, &r))
 76228:             return false;
 76228:     } else {
 76228:         r = obj->isExtensible();
 76228:     }
 76267:     args.rval().setBoolean(r);
 76228:     return true;
 76228: }
 76228: 
 76228: static JSBool
 91237: DebuggerObject_isSealed(JSContext *cx, unsigned argc, Value *vp)
 76228: {
 76228:     return DebuggerObject_isSealedHelper(cx, argc, vp, Seal, "isSealed");
 76228: }
 76228: 
 76228: static JSBool
 91237: DebuggerObject_isFrozen(JSContext *cx, unsigned argc, Value *vp)
 76228: {
 76228:     return DebuggerObject_isSealedHelper(cx, argc, vp, Freeze, "isFrozen");
 76228: }
 76228: 
 76228: static JSBool
 91237: DebuggerObject_isExtensible(JSContext *cx, unsigned argc, Value *vp)
 76228: {
 76228:     return DebuggerObject_isSealedHelper(cx, argc, vp, PreventExtensions, "isExtensible");
 76228: }
 76228: 
 75467: enum ApplyOrCallMode { ApplyMode, CallMode };
 75467: 
 75427: static JSBool
 91237: ApplyOrCall(JSContext *cx, unsigned argc, Value *vp, ApplyOrCallMode mode)
 75427: {
 76267:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "apply", args, dbg, obj);
 75427: 
 76236:     /*
 76236:      * Any JS exceptions thrown must be in the debugger compartment, so do
 76236:      * sanity checks and fallible conversions before entering the debuggee.
 76236:      */
 75467:     Value calleev = ObjectValue(*obj);
 75427:     if (!obj->isCallable()) {
 75428:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 75513:                              "Debugger.Object", "apply", obj->getClass()->name);
 75427:         return false;
 75427:     }
 75427: 
 76236:     /*
 76236:      * Unwrap Debugger.Objects. This happens in the debugger's compartment since
 76236:      * that is where any exceptions must be reported.
 76236:      */
 76267:     Value thisv = argc > 0 ? args[0] : UndefinedValue();
 75467:     if (!dbg->unwrapDebuggeeValue(cx, &thisv))
 75467:         return false;
 91237:     unsigned callArgc = 0;
 75467:     Value *callArgv = NULL;
 75427:     AutoValueVector argv(cx);
 75467:     if (mode == ApplyMode) {
 76267:         if (argc >= 2 && !args[1].isNullOrUndefined()) {
 76267:             if (!args[1].isObject()) {
 75513:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_APPLY_ARGS,
 75513:                                      js_apply_str);
 75427:                 return false;
 75427:             }
 99421:             RootedObject argsobj(cx, &args[1].toObject());
108951:             if (!GetLengthProperty(cx, argsobj, &callArgc))
 75427:                 return false;
107276:             callArgc = unsigned(Min(callArgc, StackSpace::ARGS_LENGTH_MAX));
 75467:             if (!argv.growBy(callArgc) || !GetElements(cx, argsobj, callArgc, argv.begin()))
 75427:                 return false;
 75467:             callArgv = argv.begin();
 75467:         }
 75467:     } else {
107276:         callArgc = argc > 0 ? unsigned(Min(argc - 1, StackSpace::ARGS_LENGTH_MAX)) : 0;
 79387:         callArgv = args.array() + 1;
 75467:     }
 91237:     for (unsigned i = 0; i < callArgc; i++) {
 75467:         if (!dbg->unwrapDebuggeeValue(cx, &callArgv[i]))
 75427:             return false;
 75427:     }
 75427: 
 76236:     /*
 76236:      * Enter the debuggee compartment and rewrap all input value for that compartment.
 76236:      * (Rewrapping always takes place in the destination compartment.)
 76236:      */
109257:     Maybe<AutoCompartment> ac;
109257:     ac.construct(cx, obj);
109257:     if (!cx->compartment->wrap(cx, &calleev) || !cx->compartment->wrap(cx, &thisv))
 75427:         return false;
 91237:     for (unsigned i = 0; i < callArgc; i++) {
 75467:         if (!cx->compartment->wrap(cx, &callArgv[i]))
 75427:             return false;
 75427:     }
 75427: 
 76236:     /*
 91434:      * Call the function. Use receiveCompletionValue to return to the debugger
 76267:      * compartment and populate args.rval().
 76236:      */
 75427:     Value rval;
 76829:     bool ok = Invoke(cx, thisv, calleev, callArgc, callArgv, &rval);
106862:     return dbg->receiveCompletionValue(ac, ok, rval, args.rval().address());
 75427: }
 75427: 
 75467: static JSBool
 91237: DebuggerObject_apply(JSContext *cx, unsigned argc, Value *vp)
 75467: {
 75467:     return ApplyOrCall(cx, argc, vp, ApplyMode);
 75467: }
 75467: 
 75467: static JSBool
 91237: DebuggerObject_call(JSContext *cx, unsigned argc, Value *vp)
 75467: {
 75467:     return ApplyOrCall(cx, argc, vp, CallMode);
 75467: }
 75467: 
 94844: static JSBool
 94844: DebuggerObject_makeDebuggeeValue(JSContext *cx, unsigned argc, Value *vp)
 94844: {
 94844:     REQUIRE_ARGC("Debugger.Object.prototype.makeDebuggeeValue", 1);
 94844:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "makeDebuggeeValue", args, dbg, referent);
 94844: 
 94844:     /* Non-objects are already debuggee values. */
 94844:     if (args[0].isObject()) {
 94844:         // Enter this Debugger.Object's referent's compartment, and wrap the
 94844:         // argument as appropriate for references from there.
 94844:         {
 94844:             AutoCompartment ac(cx, referent);
109257:             if (!cx->compartment->wrap(cx, &args[0]))
 94844:                 return false;
 94844:         }
 94844: 
 94844:         // Back in the debugger's compartment, produce a new Debugger.Object
 94844:         // instance referring to the wrapped argument.
 94844:         if (!dbg->wrapDebuggeeValue(cx, &args[0]))
 94844:             return false;
 94844:     }
 94844: 
106862:     args.rval().set(args[0]);
 94844:     return true;
 94844: }
 94844: 
111508: static bool
111508: RequireGlobalObject(JSContext *cx, HandleValue dbgobj, HandleObject obj)
111508: {
111508:     if (!obj->isGlobal()) {
118849:         /* Help the poor programmer by pointing out wrappers around globals. */
118849:         if (obj->isWrapper()) {
118849:             JSObject *unwrapped = js::UnwrapObject(obj);
118849:             if (unwrapped->isGlobal()) {
118849:                 js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_DEBUG_WRAPPER_IN_WAY,
118849:                                          JSDVG_SEARCH_STACK, dbgobj, NullPtr(),
118849:                                          "a global object", NULL);
118849:                 return false;
118849:             }
118849:         }
118849: 
111508:         js_ReportValueErrorFlags(cx, JSREPORT_ERROR, JSMSG_DEBUG_BAD_REFERENT,
111508:                                  JSDVG_SEARCH_STACK, dbgobj, NullPtr(),
111508:                                  "a global object", NULL);
111508:         return false;
111508:     }
111508: 
111508:     return true;
111508: }
111508: 
111508: static JSBool
111508: DebuggerObject_evalInGlobal(JSContext *cx, unsigned argc, Value *vp)
111508: {
111508:     REQUIRE_ARGC("Debugger.Object.prototype.evalInGlobal", 1);
111508:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "evalInGlobal", args, dbg, referent);
111508:     if (!RequireGlobalObject(cx, args.thisv(), referent))
111508:         return false;
111508: 
111508:     return DebuggerGenericEval(cx, "Debugger.Object.prototype.evalInGlobal",
111508:                                args[0], NULL, vp, dbg, referent, NULL);
111508: }
111508: 
111508: static JSBool
111508: DebuggerObject_evalInGlobalWithBindings(JSContext *cx, unsigned argc, Value *vp)
111508: {
111508:     REQUIRE_ARGC("Debugger.Object.prototype.evalInGlobalWithBindings", 2);
111508:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "evalInGlobalWithBindings", args, dbg, referent);
111508:     if (!RequireGlobalObject(cx, args.thisv(), referent))
111508:         return false;
111508: 
111508:     return DebuggerGenericEval(cx, "Debugger.Object.prototype.evalInGlobalWithBindings",
111508:                                args[0], &args[1], vp, dbg, referent, NULL);
111508: }
111508: 
118848: static JSBool
118848: DebuggerObject_unwrap(JSContext *cx, unsigned argc, Value *vp)
118848: {
118848:     THIS_DEBUGOBJECT_OWNER_REFERENT(cx, argc, vp, "unwrap", args, dbg, referent);
121899:     JSObject *unwrapped = UnwrapOneChecked(referent);
118848:     if (!unwrapped) {
118848:         vp->setNull();
118848:         return true;
118848:     }
118848: 
118848:     *vp = ObjectValue(*unwrapped);
118848:     if (!dbg->wrapDebuggeeValue(cx, vp))
118848:         return false;
118848:     return true;
118848: }
118848: 
 75513: static JSPropertySpec DebuggerObject_properties[] = {
 75513:     JS_PSG("proto", DebuggerObject_getProto, 0),
 75513:     JS_PSG("class", DebuggerObject_getClass, 0),
 75513:     JS_PSG("callable", DebuggerObject_getCallable, 0),
 75513:     JS_PSG("name", DebuggerObject_getName, 0),
109110:     JS_PSG("displayName", DebuggerObject_getDisplayName, 0),
 75513:     JS_PSG("parameterNames", DebuggerObject_getParameterNames, 0),
 75513:     JS_PSG("script", DebuggerObject_getScript, 0),
 84307:     JS_PSG("environment", DebuggerObject_getEnvironment, 0),
118847:     JS_PSG("global", DebuggerObject_getGlobal, 0),
 75421:     JS_PS_END
 75421: };
 75421: 
 75513: static JSFunctionSpec DebuggerObject_methods[] = {
 76214:     JS_FN("getOwnPropertyDescriptor", DebuggerObject_getOwnPropertyDescriptor, 1, 0),
 76215:     JS_FN("getOwnPropertyNames", DebuggerObject_getOwnPropertyNames, 0, 0),
 76223:     JS_FN("defineProperty", DebuggerObject_defineProperty, 2, 0),
 76224:     JS_FN("defineProperties", DebuggerObject_defineProperties, 1, 0),
 76225:     JS_FN("deleteProperty", DebuggerObject_deleteProperty, 1, 0),
 76228:     JS_FN("seal", DebuggerObject_seal, 0, 0),
 76228:     JS_FN("freeze", DebuggerObject_freeze, 0, 0),
 76228:     JS_FN("preventExtensions", DebuggerObject_preventExtensions, 0, 0),
 76228:     JS_FN("isSealed", DebuggerObject_isSealed, 0, 0),
 76228:     JS_FN("isFrozen", DebuggerObject_isFrozen, 0, 0),
 76228:     JS_FN("isExtensible", DebuggerObject_isExtensible, 0, 0),
 75513:     JS_FN("apply", DebuggerObject_apply, 0, 0),
 75513:     JS_FN("call", DebuggerObject_call, 0, 0),
 94844:     JS_FN("makeDebuggeeValue", DebuggerObject_makeDebuggeeValue, 1, 0),
111508:     JS_FN("evalInGlobal", DebuggerObject_evalInGlobal, 1, 0),
111508:     JS_FN("evalInGlobalWithBindings", DebuggerObject_evalInGlobalWithBindings, 2, 0),
118848:     JS_FN("unwrap", DebuggerObject_unwrap, 0, 0),
 75427:     JS_FS_END
 75427: };
 75427: 
 75466: 
 84307: /*** Debugger.Environment ************************************************************************/
 84307: 
 84307: static void
115876: DebuggerEnv_trace(JSTracer *trc, RawObject obj)
 84307: {
 84307:     /*
 84307:      * There is a barrier on private pointers, so the Unbarriered marking
 84307:      * is okay.
 84307:      */
 91557:     if (Env *referent = (JSObject *) obj->getPrivate()) {
124078:         MarkCrossCompartmentObjectUnbarriered(trc, obj, &referent, "Debugger.Environment referent");
 91849:         obj->setPrivateUnbarriered(referent);
 91557:     }
 84307: }
 84307: 
 84307: Class DebuggerEnv_class = {
 90410:     "Environment",
 90410:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS |
 90410:     JSCLASS_HAS_RESERVED_SLOTS(JSSLOT_DEBUGENV_COUNT),
 84307:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 84307:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, NULL,
 84307:     NULL,                 /* checkAccess */
 84307:     NULL,                 /* call        */
 84307:     NULL,                 /* construct   */
 84307:     NULL,                 /* hasInstance */
 84307:     DebuggerEnv_trace
 84307: };
 84307: 
 84307: static JSObject *
 84307: DebuggerEnv_checkThis(JSContext *cx, const CallArgs &args, const char *fnname)
 84307: {
 84307:     if (!args.thisv().isObject()) {
 84307:         ReportObjectRequired(cx);
 84307:         return NULL;
 84307:     }
 84307:     JSObject *thisobj = &args.thisv().toObject();
 84307:     if (thisobj->getClass() != &DebuggerEnv_class) {
 84307:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 84307:                              "Debugger.Environment", fnname, thisobj->getClass()->name);
 84307:         return NULL;
 84307:     }
 84307: 
 84307:     /*
 84307:      * Forbid Debugger.Environment.prototype, which is of class DebuggerEnv_class
 84307:      * but isn't a real working Debugger.Environment. The prototype object is
 84307:      * distinguished by having no referent.
 84307:      */
 84307:     if (!thisobj->getPrivate()) {
 84307:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
 84307:                              "Debugger.Environment", fnname, "prototype object");
 84307:         return NULL;
 84307:     }
 84307:     return thisobj;
 84307: }
 84307: 
 84307: #define THIS_DEBUGENV(cx, argc, vp, fnname, args, envobj, env)                \
 84307:     CallArgs args = CallArgsFromVp(argc, vp);                                 \
 84307:     JSObject *envobj = DebuggerEnv_checkThis(cx, args, fnname);               \
 84307:     if (!envobj)                                                              \
 84307:         return false;                                                         \
 99421:     Rooted<Env*> env(cx, static_cast<Env *>(envobj->getPrivate()));           \
 98921:     JS_ASSERT(env);                                                           \
 98921:     JS_ASSERT(!env->isScope())
 84307: 
 84307: #define THIS_DEBUGENV_OWNER(cx, argc, vp, fnname, args, envobj, env, dbg)     \
 84307:     THIS_DEBUGENV(cx, argc, vp, fnname, args, envobj, env);                   \
 84307:     Debugger *dbg = Debugger::fromChildJSObject(envobj)
 84307: 
 84307: static JSBool
 91237: DebuggerEnv_construct(JSContext *cx, unsigned argc, Value *vp)
 84307: {
 84307:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NO_CONSTRUCTOR, "Debugger.Environment");
 84307:     return false;
 84307: }
 84307: 
 98921: static bool
 98921: IsDeclarative(Env *env)
 98921: {
 98921:     return env->isDebugScope() && env->asDebugScope().isForDeclarative();
 98921: }
 98921: 
 98921: static bool
 98921: IsWith(Env *env)
 98921: {
 98921:     return env->isDebugScope() && env->asDebugScope().scope().isWith();
 98921: }
 98921: 
 84307: static JSBool
 91237: DebuggerEnv_getType(JSContext *cx, unsigned argc, Value *vp)
 84307: {
 84307:     THIS_DEBUGENV(cx, argc, vp, "get type", args, envobj, env);
 84307: 
 84307:     /* Don't bother switching compartments just to check env's class. */
 84307:     const char *s;
 98921:     if (IsDeclarative(env))
 84307:         s = "declarative";
 98921:     else if (IsWith(env))
 98649:         s = "with";
 84307:     else
 84307:         s = "object";
 84307: 
120463:     JSAtom *str = Atomize(cx, s, strlen(s), InternAtom);
 84307:     if (!str)
 84307:         return false;
 84307:     args.rval().setString(str);
 84307:     return true;
 84307: }
 84307: 
 84307: static JSBool
 91237: DebuggerEnv_getParent(JSContext *cx, unsigned argc, Value *vp)
 84307: {
 84307:     THIS_DEBUGENV_OWNER(cx, argc, vp, "get parent", args, envobj, env, dbg);
 84307: 
 84307:     /* Don't bother switching compartments just to get env's parent. */
 99421:     Rooted<Env*> parent(cx, env->enclosingScope());
106862:     return dbg->wrapEnvironment(cx, parent, args.rval().address());
 84307: }
 84307: 
 84307: static JSBool
 91237: DebuggerEnv_getObject(JSContext *cx, unsigned argc, Value *vp)
 84307: {
 84307:     THIS_DEBUGENV_OWNER(cx, argc, vp, "get type", args, envobj, env, dbg);
 84307: 
 84307:     /*
 84307:      * Don't bother switching compartments just to check env's class and
 84307:      * possibly get its proto.
 84307:      */
 98921:     if (IsDeclarative(env)) {
 84307:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NO_SCOPE_OBJECT);
 84307:         return false;
 84307:     }
 98921: 
 99931:     JSObject *obj;
 99931:     if (IsWith(env)) {
 99931:         obj = &env->asDebugScope().scope().asWith().object();
 99931:     } else {
 99931:         obj = env;
 99931:         JS_ASSERT(!obj->isDebugScope());
 99931:     }
 84307: 
 84307:     Value rval = ObjectValue(*obj);
 84307:     if (!dbg->wrapDebuggeeValue(cx, &rval))
 84307:         return false;
106862:     args.rval().set(rval);
 84307:     return true;
 84307: }
 84307: 
 84307: static JSBool
 99932: DebuggerEnv_getCallee(JSContext *cx, unsigned argc, Value *vp)
 99932: {
 99932:     THIS_DEBUGENV_OWNER(cx, argc, vp, "get callee", args, envobj, env, dbg);
 99932: 
 99932:     args.rval().setNull();
 99932: 
 99932:     if (!env->isDebugScope())
 99932:         return true;
 99932: 
 99932:     JSObject &scope = env->asDebugScope().scope();
 99932:     if (!scope.isCall())
 99932:         return true;
 99932: 
103492:     CallObject &callobj = scope.asCall();
103492:     if (callobj.isForEval())
 99932:         return true;
 99932: 
106862:     args.rval().setObject(callobj.callee());
106862:     if (!dbg->wrapDebuggeeValue(cx, args.rval().address()))
 99932:         return false;
 99932:     return true;
 99932: }
 99932: 
 99932: static JSBool
 91237: DebuggerEnv_names(JSContext *cx, unsigned argc, Value *vp)
 84307: {
 94943:     THIS_DEBUGENV_OWNER(cx, argc, vp, "names", args, envobj, env, dbg);
 84307: 
 84307:     AutoIdVector keys(cx);
 84307:     {
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, env);
 84307:         ErrorCopier ec(ac, dbg->toJSObject());
 84307:         if (!GetPropertyNames(cx, env, JSITER_HIDDEN, &keys))
 84307:             return false;
 84307:     }
 84307: 
 99421:     RootedObject arr(cx, NewDenseEmptyArray(cx));
 84307:     if (!arr)
 84307:         return false;
 84307:     for (size_t i = 0, len = keys.length(); i < len; i++) {
 84307:          jsid id = keys[i];
 84307:          if (JSID_IS_ATOM(id) && IsIdentifier(JSID_TO_ATOM(id))) {
 84307:              if (!cx->compartment->wrapId(cx, &id))
 84307:                  return false;
 84307:              if (!js_NewbornArrayPush(cx, arr, StringValue(JSID_TO_STRING(id))))
 84307:                  return false;
 84307:          }
 84307:     }
 84307:     args.rval().setObject(*arr);
 84307:     return true;
 84307: }
 84307: 
 84307: static JSBool
 91237: DebuggerEnv_find(JSContext *cx, unsigned argc, Value *vp)
 84307: {
 84307:     REQUIRE_ARGC("Debugger.Environment.find", 1);
 94943:     THIS_DEBUGENV_OWNER(cx, argc, vp, "find", args, envobj, env, dbg);
 84307: 
 99421:     RootedId id(cx);
 98960:     if (!ValueToIdentifier(cx, args[0], id.address()))
 84307:         return false;
 84307: 
 84307:     {
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, env);
109257:         if (!cx->compartment->wrapId(cx, id.address()))
 84307:             return false;
 84307: 
 84307:         /* This can trigger resolve hooks. */
 84307:         ErrorCopier ec(ac, dbg->toJSObject());
103716:         RootedShape prop(cx);
103636:         RootedObject pobj(cx);
 86483:         for (; env && !prop; env = env->enclosingScope()) {
108951:             if (!JSObject::lookupGeneric(cx, env, id, &pobj, &prop))
 84307:                 return false;
 84307:             if (prop)
 84307:                 break;
 84307:         }
 84307:     }
 84307: 
106862:     return dbg->wrapEnvironment(cx, env, args.rval().address());
 84307: }
 84307: 
 94943: static JSBool
 94943: DebuggerEnv_getVariable(JSContext *cx, unsigned argc, Value *vp)
 94943: {
 94943:     REQUIRE_ARGC("Debugger.Environment.getVariable", 1);
 94943:     THIS_DEBUGENV_OWNER(cx, argc, vp, "getVariable", args, envobj, env, dbg);
 94943: 
 99421:     RootedId id(cx);
 98960:     if (!ValueToIdentifier(cx, args[0], id.address()))
 94943:         return false;
 94943: 
101203:     RootedValue v(cx);
 94943:     {
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, env);
109257:         if (!cx->compartment->wrapId(cx, id.address()))
 94943:             return false;
 94943: 
 94943:         /* This can trigger getters. */
 94943:         ErrorCopier ec(ac, dbg->toJSObject());
108951:         if (!JSObject::getGeneric(cx, env, env, id, &v))
 94943:             return false;
 94943:     }
 94943: 
101203:     if (!dbg->wrapDebuggeeValue(cx, v.address()))
 94943:         return false;
106862:     args.rval().set(v);
 94943:     return true;
 94943: }
 94943: 
 94943: static JSBool
 94943: DebuggerEnv_setVariable(JSContext *cx, unsigned argc, Value *vp)
 94943: {
 94943:     REQUIRE_ARGC("Debugger.Environment.setVariable", 2);
 94943:     THIS_DEBUGENV_OWNER(cx, argc, vp, "setVariable", args, envobj, env, dbg);
 94943: 
 99421:     RootedId id(cx);
 98960:     if (!ValueToIdentifier(cx, args[0], id.address()))
 94943:         return false;
 94943: 
 99421:     RootedValue v(cx, args[1]);
 97353:     if (!dbg->unwrapDebuggeeValue(cx, v.address()))
 94943:         return false;
 94943: 
 94943:     {
109257:         Maybe<AutoCompartment> ac;
109257:         ac.construct(cx, env);
109257:         if (!cx->compartment->wrapId(cx, id.address()) || !cx->compartment->wrap(cx, v.address()))
 94943:             return false;
 94943: 
 94943:         /* This can trigger setters. */
 94943:         ErrorCopier ec(ac, dbg->toJSObject());
 94943: 
 94943:         /* Make sure the environment actually has the specified binding. */
 94943:         bool has;
108951:         if (!JSObject::hasProperty(cx, env, id, &has))
 94943:             return false;
 94943:         if (!has) {
 94943:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_VARIABLE_NOT_FOUND);
 94943:             return false;
 94943:         }
 94943: 
 94943:         /* Just set the property. */
108951:         if (!JSObject::setGeneric(cx, env, env, id, &v, true))
 94943:             return false;
 94943:     }
 94943: 
 94943:     args.rval().setUndefined();
 94943:     return true;
 94943: }
 94943: 
 84307: static JSPropertySpec DebuggerEnv_properties[] = {
 84307:     JS_PSG("type", DebuggerEnv_getType, 0),
 84307:     JS_PSG("object", DebuggerEnv_getObject, 0),
 84307:     JS_PSG("parent", DebuggerEnv_getParent, 0),
 99932:     JS_PSG("callee", DebuggerEnv_getCallee, 0),
 84307:     JS_PS_END
 84307: };
 84307: 
 84307: static JSFunctionSpec DebuggerEnv_methods[] = {
 84307:     JS_FN("names", DebuggerEnv_names, 0, 0),
 84307:     JS_FN("find", DebuggerEnv_find, 1, 0),
 94943:     JS_FN("getVariable", DebuggerEnv_getVariable, 1, 0),
 94943:     JS_FN("setVariable", DebuggerEnv_setVariable, 2, 0),
 84307:     JS_FS_END
 84307: };
 84307: 
 84307: 
 84307: 
 76236: /*** Glue ****************************************************************************************/
 75402: 
 75397: extern JS_PUBLIC_API(JSBool)
 99364: JS_DefineDebuggerObject(JSContext *cx, JSObject *obj_)
 75397: {
 99421:     RootedObject obj(cx, obj_);
 99421: 
 99421:     RootedObject
 86437:         objProto(cx),
 86437:         debugCtor(cx),
 86437:         debugProto(cx),
 86437:         frameProto(cx),
 86437:         scriptProto(cx),
102322:         objectProto(cx),
102322:         envProto(cx);
 86437: 
 89843:     objProto = obj->asGlobal().getOrCreateObjectPrototype(cx);
 89843:     if (!objProto)
 75413:         return false;
 75397: 
 86437: 
 99364:     debugProto = js_InitClass(cx, obj,
 86437:                               objProto, &Debugger::jsclass, Debugger::construct,
 75513:                               1, Debugger::properties, Debugger::methods, NULL, NULL,
 86437:                               debugCtor.address());
 83231:     if (!debugProto)
 75413:         return false;
 75413: 
 86437:     frameProto = js_InitClass(cx, debugCtor, objProto, &DebuggerFrame_class,
 75513:                               DebuggerFrame_construct, 0,
 75513:                               DebuggerFrame_properties, DebuggerFrame_methods,
 75514:                               NULL, NULL);
 75413:     if (!frameProto)
 75413:         return false;
 75418: 
 86437:     scriptProto = js_InitClass(cx, debugCtor, objProto, &DebuggerScript_class,
 75513:                                DebuggerScript_construct, 0,
 75513:                                DebuggerScript_properties, DebuggerScript_methods,
 75514:                                NULL, NULL);
 75514:     if (!scriptProto)
 75492:         return false;
 75492: 
 86437:     objectProto = js_InitClass(cx, debugCtor, objProto, &DebuggerObject_class,
 75513:                                DebuggerObject_construct, 0,
 75513:                                DebuggerObject_properties, DebuggerObject_methods,
 75513:                                NULL, NULL);
 75418:     if (!objectProto)
 75418:         return false;
 75418: 
102322:     envProto = js_InitClass(cx, debugCtor, objProto, &DebuggerEnv_class,
 84307:                                       DebuggerEnv_construct, 0,
 84307:                                       DebuggerEnv_properties, DebuggerEnv_methods,
 84307:                                       NULL, NULL);
 84307:     if (!envProto)
 84307:         return false;
 84307: 
 76234:     debugProto->setReservedSlot(Debugger::JSSLOT_DEBUG_FRAME_PROTO, ObjectValue(*frameProto));
 76234:     debugProto->setReservedSlot(Debugger::JSSLOT_DEBUG_OBJECT_PROTO, ObjectValue(*objectProto));
 76234:     debugProto->setReservedSlot(Debugger::JSSLOT_DEBUG_SCRIPT_PROTO, ObjectValue(*scriptProto));
 84307:     debugProto->setReservedSlot(Debugger::JSSLOT_DEBUG_ENV_PROTO, ObjectValue(*envProto));
 75413:     return true;
 75397: }
