    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brendan Eich (brendan@mozilla.org)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIAtom.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMEventGroup.h"
 1418: #include "nsIDOMEventListener.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMKeyEvent.h"
    1: #include "nsIDOMMouseEvent.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsXBLPrototypeHandler.h"
    1: #include "nsIDOMNSEvent.h"
14328: #include "nsGUIEvent.h"
  541: #include "nsContentUtils.h"
14328: #include "nsUnicharUtils.h"
    1: 
    1: nsXBLEventHandler::nsXBLEventHandler(nsXBLPrototypeHandler* aHandler)
    1:   : mProtoHandler(aHandler)
    1: {
    1: }
    1: 
    1: nsXBLEventHandler::~nsXBLEventHandler()
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsXBLEventHandler, nsIDOMEventListener)
    1: 
    1: NS_IMETHODIMP
    1: nsXBLEventHandler::HandleEvent(nsIDOMEvent* aEvent)
    1: {
    1:   if (!mProtoHandler)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRUint8 phase = mProtoHandler->GetPhase();
    1:   if (phase == NS_PHASE_TARGET) {
    1:     PRUint16 eventPhase;
    1:     aEvent->GetEventPhase(&eventPhase);
    1:     if (eventPhase != nsIDOMEvent::AT_TARGET)
    1:       return NS_OK;
    1:   }
    1: 
    1:   if (!EventMatched(aEvent))
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDOMEventTarget> target;
    1:   aEvent->GetCurrentTarget(getter_AddRefs(target));
 1418:   nsCOMPtr<nsPIDOMEventTarget> piTarget = do_QueryInterface(target);
    1: 
 1418:   mProtoHandler->ExecuteHandler(piTarget, aEvent);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsXBLMouseEventHandler::nsXBLMouseEventHandler(nsXBLPrototypeHandler* aHandler)
    1:   : nsXBLEventHandler(aHandler)
    1: {
    1: }
    1: 
    1: nsXBLMouseEventHandler::~nsXBLMouseEventHandler()
    1: {
    1: }
    1: 
    1: PRBool
    1: nsXBLMouseEventHandler::EventMatched(nsIDOMEvent* aEvent)
    1: {
    1:   nsCOMPtr<nsIDOMMouseEvent> mouse(do_QueryInterface(aEvent));
22955:   return mouse && mProtoHandler->MouseEventMatched(mouse);
    1: }
    1: 
    1: nsXBLKeyEventHandler::nsXBLKeyEventHandler(nsIAtom* aEventType, PRUint8 aPhase,
    1:                                            PRUint8 aType)
    1:   : mEventType(aEventType),
    1:     mPhase(aPhase),
  541:     mType(aType),
  541:     mIsBoundToChrome(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsXBLKeyEventHandler::~nsXBLKeyEventHandler()
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsXBLKeyEventHandler, nsIDOMEventListener)
    1: 
14328: PRBool
14328: nsXBLKeyEventHandler::ExecuteMatchedHandlers(nsIDOMKeyEvent* aKeyEvent,
14328:                                              PRUint32 aCharCode,
14328:                                              PRBool aIgnoreShiftKey)
14328: {
14328:   nsCOMPtr<nsIDOMNSEvent> domNSEvent = do_QueryInterface(aKeyEvent);
14328:   PRBool trustedEvent = PR_FALSE;
14328:   if (domNSEvent)
14328:     domNSEvent->GetIsTrusted(&trustedEvent);
14328: 
14328:   nsCOMPtr<nsIDOMEventTarget> target;
14328:   aKeyEvent->GetCurrentTarget(getter_AddRefs(target));
14328:   nsCOMPtr<nsPIDOMEventTarget> piTarget = do_QueryInterface(target);
14328: 
14328:   PRBool executed = PR_FALSE;
14328:   for (PRUint32 i = 0; i < mProtoHandlers.Count(); ++i) {
14328:     nsXBLPrototypeHandler* handler = static_cast<nsXBLPrototypeHandler*>
14328:                                                 (mProtoHandlers[i]);
14328:     PRBool hasAllowUntrustedAttr = handler->HasAllowUntrustedAttr();
14328:     if ((trustedEvent ||
14328:         (hasAllowUntrustedAttr && handler->AllowUntrustedEvents()) ||
14328:         (!hasAllowUntrustedAttr && !mIsBoundToChrome)) &&
14328:         handler->KeyEventMatched(aKeyEvent, aCharCode, aIgnoreShiftKey)) {
14328:       handler->ExecuteHandler(piTarget, aKeyEvent);
14328:       executed = PR_TRUE;
14328:     }
14328:   }
14328:   return executed;
14328: }
14328: 
    1: NS_IMETHODIMP
    1: nsXBLKeyEventHandler::HandleEvent(nsIDOMEvent* aEvent)
    1: {
    1:   PRUint32 count = mProtoHandlers.Count();
    1:   if (count == 0)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (mPhase == NS_PHASE_TARGET) {
    1:     PRUint16 eventPhase;
    1:     aEvent->GetEventPhase(&eventPhase);
    1:     if (eventPhase != nsIDOMEvent::AT_TARGET)
    1:       return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMKeyEvent> key(do_QueryInterface(aEvent));
19283:   if (!key)
19283:     return NS_OK;
    1: 
14328:   nsAutoTArray<nsShortcutCandidate, 10> accessKeys;
19283:   nsContentUtils::GetAccelKeyCandidates(key, accessKeys);
14328: 
14328:   if (accessKeys.IsEmpty()) {
14328:     ExecuteMatchedHandlers(key, 0, PR_FALSE);
14328:     return NS_OK;
    1:   }
    1: 
14328:   for (PRUint32 i = 0; i < accessKeys.Length(); ++i) {
14328:     if (ExecuteMatchedHandlers(key, accessKeys[i].mCharCode,
14328:                                accessKeys[i].mIgnoreShift))
14328:       return NS_OK;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////////////
    1: 
    1: nsresult
    1: NS_NewXBLEventHandler(nsXBLPrototypeHandler* aHandler,
    1:                       nsIAtom* aEventType,
    1:                       nsXBLEventHandler** aResult)
    1: {
    1:   if (aEventType == nsGkAtoms::mousedown ||
    1:       aEventType == nsGkAtoms::mouseup ||
    1:       aEventType == nsGkAtoms::click ||
    1:       aEventType == nsGkAtoms::dblclick ||
    1:       aEventType == nsGkAtoms::mouseover ||
    1:       aEventType == nsGkAtoms::mouseout ||
    1:       aEventType == nsGkAtoms::mousemove ||
    1:       aEventType == nsGkAtoms::contextmenu ||
    1:       aEventType == nsGkAtoms::dragenter ||
    1:       aEventType == nsGkAtoms::dragover ||
    1:       aEventType == nsGkAtoms::dragdrop ||
    1:       aEventType == nsGkAtoms::dragexit ||
    1:       aEventType == nsGkAtoms::draggesture) {
    1:     *aResult = new nsXBLMouseEventHandler(aHandler);
    1:   }
    1:   else {
    1:     *aResult = new nsXBLEventHandler(aHandler);
    1:   }
    1: 
    1:   if (!*aResult)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: NS_NewXBLKeyEventHandler(nsIAtom* aEventType, PRUint8 aPhase, PRUint8 aType,
    1:                          nsXBLKeyEventHandler** aResult)
    1: {
    1:   *aResult = new nsXBLKeyEventHandler(aEventType, aPhase, aType);
    1: 
    1:   if (!*aResult)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*aResult);
    1: 
    1:   return NS_OK;
    1: }
