    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsWindow_h__
    1: #define nsWindow_h__
    1: 
    1: 
    1: 
    1: #include "nsISupports.h"
    1: 
    1: #include "nsWidget.h"
    1: 
    1: #include "nsString.h"
    1: 
    1: #include <Pt.h>
    1: 
    1: class nsFont;
    1: class nsIAppShell;
    1: 
    1: #define NSRGB_2_COLOREF(color)				RGB(NS_GET_R(color),NS_GET_G(color),NS_GET_B(color))
    1: 
    1: /**
    1:  * Native Photon window wrapper. 
    1:  */
    1: 
    1: class nsWindow : public nsWidget
    1: {
    1: 
    1: public:
    1:   // nsIWidget interface
    1: 
    1:   nsWindow();
    1:   virtual ~nsWindow();
    1: 
    1:   NS_IMETHOD           WidgetToScreen(const nsRect &aOldRect, nsRect &aNewRect);
    1: 
    1:   NS_IMETHOD           PreCreateWidget(nsWidgetInitData *aWidgetInitData);
    1: 
    1:   virtual void*        GetNativeData(PRUint32 aDataType);
    1: 
    1:   NS_IMETHOD           Scroll(PRInt32 aDx, PRInt32 aDy, nsRect *aClipRect);
    1:   NS_IMETHOD           ScrollWidgets(PRInt32 aDx, PRInt32 aDy);
    1:   inline NS_IMETHOD    ScrollRect(nsRect &aSrcRect, PRInt32 aDx, PRInt32 aDy)
    1: 		{
    1: 		NS_WARNING("nsWindow::ScrollRect Not Implemented\n");
    1: 		return NS_OK;
    1: 		}
    1: 
    1:   NS_IMETHOD           SetTitle(const nsAString& aTitle);
    1:  
    1:   NS_IMETHOD           Move(PRInt32 aX, PRInt32 aY);
    1: 
    1:   NS_IMETHOD           Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint);
    1:   NS_IMETHOD           Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: 		{
    1: 		Move(aX,aY);
    1: 		Resize(aWidth,aHeight,aRepaint);
    1: 		return NS_OK;
    1: 		}
    1: 
    1:   NS_IMETHOD           CaptureRollupEvents(nsIRollupListener * aListener,
    1:                                            PRBool aDoCapture,
    1:                                            PRBool aConsumeRollupEvent);
    1: 
    1: 	NS_IMETHOD SetFocus(PRBool aRaise);
    1: 
    1:   inline NS_IMETHOD    GetAttention(PRInt32 aCycleCount)
    1: 		{
    1: 		if( mWidget ) PtWindowToFront( mWidget );
    1: 		return NS_OK;
    1: 		}
    1: 
    1:   virtual PRBool       IsChild() const;
    1: 
    1: 
    1:   // Utility methods
    1:   inline PRBool         OnKey(nsKeyEvent &aEvent)
    1: 		{
    1: 		if( mEventCallback ) return DispatchWindowEvent(&aEvent);
    1: 		return PR_FALSE;
    1: 		}
    1: 
    1:   inline NS_IMETHOD			GetClientBounds( nsRect &aRect )
    1: 		{
    1: 		aRect.x = 0;
    1: 		aRect.y = 0;
    1: 		aRect.width = mBounds.width;
    1: 		aRect.height = mBounds.height;
    1: 		return NS_OK;
    1: 		}
    1: 
    1:   NS_IMETHOD            SetModal(PRBool aModal);
    1: 	NS_IMETHOD            MakeFullScreen(PRBool aFullScreen);
    1: 
    1:  // Native draw function... like doPaint()
    1:  static void            RawDrawFunc( PtWidget_t *pWidget, PhTile_t *damage );
    1: 
    1:  inline nsIRegion              *GetRegion();
    1: 
    1: private:
    1:   // this is the "native" destroy code that will destroy any
    1:   // native windows / widgets for this logical widget
    1:   virtual void          DestroyNative(void);
    1:   void                  DestroyNativeChildren(void);
    1: 
    1:   static int            MenuRegionCallback(PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo);  
    1: 
    1:   NS_IMETHOD            CreateNative(PtWidget_t *parentWidget);
    1: 
    1:   static int            ResizeHandler( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo );
    1: 	static int            EvInfo( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo );
    1:   static int            WindowWMHandler( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo );
    1:   static int            MenuRegionDestroyed( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo );
    1: 
    1:   inline NS_IMETHOD     ModalEventFilter(PRBool aRealEvent, void *aEvent, PRBool *aForWindow)
    1: 		{
    1: 		*aForWindow = PR_TRUE;
    1: 		return NS_OK;
    1: 		}
    1: 
    1: private:
    1:   PtWidget_t *mClientWidget, *mLastMenu;
    1:   PRBool mIsTooSmall;
27505:   PRBool mIsDestroying;
    1: 	static nsIRollupListener *gRollupListener;
    1: 	static nsIWidget *gRollupWidget;
    1: };
    1: 
    1: //
    1: // A child window is a window with different style
    1: //
    1: class ChildWindow : public nsWindow {
    1:   public:
    1:     ChildWindow()
    1: 			{
    1: 			mBorderStyle     = eBorderStyle_none;
    1: 			mWindowType      = eWindowType_child;
    1: 			}
    1:     ~ChildWindow() { }
    1: 	inline PRBool IsChild() const { return PR_TRUE; }
    1: };
    1: 
    1: #endif // Window_h__
