43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
43113: /* vim:set et cin ts=4 sw=4 sts=4: */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is Mozilla.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Darin Fisher <darin@netscape.com> (original author)
43113:  *   Christian Biesinger <cbiesinger@web.de>
46790:  *   Daniel Witte <dwitte@mozilla.com>
46909:  *   Jason Duell <jduell.mcbugs@gmail.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #ifndef nsHttpChannel_h__
43113: #define nsHttpChannel_h__
43113: 
46790: #include "HttpBaseChannel.h"
46790: 
43113: #include "nsHttpTransaction.h"
43113: #include "nsInputStreamPump.h"
43113: #include "nsThreadUtils.h"
48304: #include "nsTArray.h"
43113: 
43113: #include "nsIHttpEventSink.h"
43113: #include "nsICachingChannel.h"
43113: #include "nsICacheEntryDescriptor.h"
43113: #include "nsICacheListener.h"
43113: #include "nsIApplicationCacheChannel.h"
43113: #include "nsIEncodedChannel.h"
43113: #include "nsIStringEnumerator.h"
43113: #include "nsIPrompt.h"
43113: #include "nsIResumableChannel.h"
43113: #include "nsIProtocolProxyCallback.h"
43113: #include "nsICancelable.h"
43832: #include "nsIHttpAuthenticableChannel.h"
43113: #include "nsITraceableChannel.h"
43832: #include "nsIHttpChannelAuthProvider.h"
48304: #include "nsIAsyncVerifyRedirectCallback.h"
43113: 
43113: class nsAHttpConnection;
51363: class AutoRedirectVetoNotifier;
46790: 
46790: using namespace mozilla::net;
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel
43113: //-----------------------------------------------------------------------------
43113: 
46790: class nsHttpChannel : public HttpBaseChannel
43113:                     , public nsIStreamListener
43113:                     , public nsICachingChannel
43113:                     , public nsICacheListener
43113:                     , public nsIEncodedChannel
43113:                     , public nsITransportEventSink
43113:                     , public nsIProtocolProxyCallback
43832:                     , public nsIHttpAuthenticableChannel
43113:                     , public nsITraceableChannel
43113:                     , public nsIApplicationCacheChannel
48304:                     , public nsIAsyncVerifyRedirectCallback
52140:                     , public nsIHttpChannelParentInternal
43113: {
43113: public:
43113:     NS_DECL_ISUPPORTS_INHERITED
43113:     NS_DECL_NSIREQUESTOBSERVER
43113:     NS_DECL_NSISTREAMLISTENER
46915:     NS_DECL_NSICACHEINFOCHANNEL
43113:     NS_DECL_NSICACHINGCHANNEL
43113:     NS_DECL_NSICACHELISTENER
43113:     NS_DECL_NSIENCODEDCHANNEL
43113:     NS_DECL_NSITRANSPORTEVENTSINK
43113:     NS_DECL_NSIPROTOCOLPROXYCALLBACK
43113:     NS_DECL_NSIPROXIEDCHANNEL
43113:     NS_DECL_NSITRACEABLECHANNEL
43113:     NS_DECL_NSIAPPLICATIONCACHECONTAINER
43113:     NS_DECL_NSIAPPLICATIONCACHECHANNEL
48304:     NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
52140:     NS_DECL_NSIHTTPCHANNELPARENTINTERNAL
43832: 
43832:     // nsIHttpAuthenticableChannel. We can't use
43832:     // NS_DECL_NSIHTTPAUTHENTICABLECHANNEL because it duplicates cancel() and
43832:     // others.
43832:     NS_IMETHOD GetIsSSL(PRBool *aIsSSL);
43832:     NS_IMETHOD GetProxyMethodIsConnect(PRBool *aProxyMethodIsConnect);
43832:     NS_IMETHOD GetServerResponseHeader(nsACString & aServerResponseHeader);
43832:     NS_IMETHOD GetProxyChallenges(nsACString & aChallenges);
43832:     NS_IMETHOD GetWWWChallenges(nsACString & aChallenges);
43832:     NS_IMETHOD SetProxyCredentials(const nsACString & aCredentials);
43832:     NS_IMETHOD SetWWWCredentials(const nsACString & aCredentials);
43832:     NS_IMETHOD OnAuthAvailable();
43832:     NS_IMETHOD OnAuthCancelled(PRBool userCancel);
46909:     // Functions we implement from nsIHttpAuthenticableChannel but are
46909:     // declared in HttpBaseChannel must be implemented in this class. We
46909:     // just call the HttpBaseChannel:: impls.
46909:     NS_IMETHOD GetLoadFlags(nsLoadFlags *aLoadFlags);
46909:     NS_IMETHOD GetURI(nsIURI **aURI);
46909:     NS_IMETHOD GetNotificationCallbacks(nsIInterfaceRequestor **aCallbacks);
46909:     NS_IMETHOD GetLoadGroup(nsILoadGroup **aLoadGroup);
46909:     NS_IMETHOD GetRequestMethod(nsACString& aMethod);
43113: 
43113:     nsHttpChannel();
43113:     virtual ~nsHttpChannel();
43113: 
46909:     virtual nsresult Init(nsIURI *aURI, PRUint8 aCaps, nsProxyInfo *aProxyInfo);
43113: 
46790:     // Methods HttpBaseChannel didn't implement for us or that we override.
46790:     //
46790:     // nsIRequest
46790:     NS_IMETHOD Cancel(nsresult status);
46790:     NS_IMETHOD Suspend();
46790:     NS_IMETHOD Resume();
46790:     // nsIChannel
46790:     NS_IMETHOD GetSecurityInfo(nsISupports **aSecurityInfo);
46790:     NS_IMETHOD AsyncOpen(nsIStreamListener *listener, nsISupports *aContext);
46790:     // nsIHttpChannelInternal
46790:     NS_IMETHOD SetupFallbackChannel(const char *aFallbackKey);
46793:     // nsISupportsPriority
46793:     NS_IMETHOD SetPriority(PRInt32 value);
49379:     // nsIResumableChannel
49379:     NS_IMETHOD ResumeAt(PRUint64 startPos, const nsACString& entityID);
43173: 
46790: public: /* internal necko use only */ 
43113:     typedef void (nsHttpChannel:: *nsAsyncCallback)(void);
46755:     nsHttpResponseHead * GetResponseHead() const { return mResponseHead; }
46887:     void InternalSetUploadStream(nsIInputStream *uploadStream) 
46887:       { mUploadStream = uploadStream; }
46887:     void SetUploadStreamHasHeaders(PRBool hasHeaders) 
46887:       { mUploadStreamHasHeaders = hasHeaders; }
46791: 
46791:     nsresult SetReferrerInternal(nsIURI *referrer) {
46791:         nsCAutoString spec;
46791:         nsresult rv = referrer->GetAsciiSpec(spec);
46791:         if (NS_FAILED(rv)) return rv;
46791:         mReferrer = referrer;
46791:         mRequestHead.SetHeader(nsHttp::Referer, spec);
46791:         return NS_OK;
46791:     }
43113: 
43113: private:
48304:     typedef nsresult (nsHttpChannel::*nsContinueRedirectionFunc)(nsresult result);
48304: 
43113:     // AsyncCall may be used to call a member function asynchronously.
43113:     // retval isn't refcounted and is set only when event was successfully
43113:     // posted, the event is returned for the purpose of cancelling when needed
43113:     nsresult AsyncCall(nsAsyncCallback funcPtr,
43113:                        nsRunnableMethod<nsHttpChannel> **retval = nsnull);
43113: 
43113:     PRBool   RequestIsConditional();
43113:     nsresult Connect(PRBool firstTime = PR_TRUE);
43113:     nsresult AsyncAbort(nsresult status);
43113:     // Send OnStartRequest/OnStopRequest to our listener, if any.
43113:     void     HandleAsyncNotifyListener();
43113:     void     DoNotifyListener();
43113:     nsresult SetupTransaction();
43113:     nsresult ApplyContentConversions();
43113:     nsresult CallOnStartRequest();
43113:     nsresult ProcessResponse();
48304:     nsresult ContinueProcessResponse(nsresult);
43113:     nsresult ProcessNormal();
48304:     nsresult ContinueProcessNormal(nsresult);
43113:     nsresult ProcessNotModified();
48304:     nsresult AsyncProcessRedirection(PRUint32 httpStatus);
48304:     nsresult ContinueProcessRedirection(nsresult);
48304:     nsresult ContinueProcessRedirectionAfterFallback(nsresult);
43113:     PRBool   ShouldSSLProxyResponseContinue(PRUint32 httpStatus);
43113:     nsresult ProcessFailedSSLConnect(PRUint32 httpStatus);
48304:     nsresult ProcessFallback(PRBool *waitingForRedirectCallback);
48304:     nsresult ContinueProcessFallback(nsresult);
43113:     PRBool   ResponseWouldVary();
43113: 
48304:     nsresult ContinueOnStartRequest1(nsresult);
48304:     nsresult ContinueOnStartRequest2(nsresult);
48304:     nsresult ContinueOnStartRequest3(nsresult);
48304: 
43113:     // redirection specific methods
43113:     void     HandleAsyncRedirect();
48304:     nsresult ContinueHandleAsyncRedirect(nsresult);
43113:     void     HandleAsyncNotModified();
43113:     void     HandleAsyncFallback();
48304:     nsresult ContinueHandleAsyncFallback(nsresult);
43113:     nsresult PromptTempRedirect();
49375:     virtual nsresult SetupReplacementChannel(nsIURI *, nsIChannel *, PRBool preserveMethod);
43113: 
43113:     // proxy specific methods
43113:     nsresult ProxyFailover();
48304:     nsresult AsyncDoReplaceWithProxy(nsIProxyInfo *);
48304:     nsresult ContinueDoReplaceWithProxy(nsresult);
43113:     void HandleAsyncReplaceWithProxy();
48304:     nsresult ContinueHandleAsyncReplaceWithProxy(nsresult);
43113:     nsresult ResolveProxy();
43113: 
43113:     // cache specific methods
53987:     nsresult OpenCacheEntry();
53987:     nsresult OnOfflineCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
53987:                                           nsCacheAccessMode aAccess,
53987:                                           nsresult aResult,
53987:                                           PRBool aSync);
53987:     nsresult OpenNormalCacheEntry(PRBool aSync);
53987:     nsresult OnNormalCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
53987:                                          nsCacheAccessMode aAccess,
53987:                                          nsresult aResult,
53987:                                          PRBool aSync);
43113:     nsresult OpenOfflineCacheEntryForWriting();
43113:     nsresult GenerateCacheKey(PRUint32 postID, nsACString &key);
43113:     nsresult UpdateExpirationTime();
43113:     nsresult CheckCache();
43113:     nsresult ShouldUpdateOfflineCacheEntry(PRBool *shouldCacheForOfflineUse);
43113:     nsresult ReadFromCache();
43113:     void     CloseCacheEntry(PRBool doomOnFailure);
43113:     void     CloseOfflineCacheEntry();
43113:     nsresult InitCacheEntry();
43113:     nsresult InitOfflineCacheEntry();
43113:     nsresult AddCacheEntryHeaders(nsICacheEntryDescriptor *entry);
43113:     nsresult StoreAuthorizationMetaData(nsICacheEntryDescriptor *entry);
43113:     nsresult FinalizeCacheEntry();
43113:     nsresult InstallCacheListener(PRUint32 offset = 0);
43113:     nsresult InstallOfflineCacheListener();
43113:     void     MaybeInvalidateCacheEntryForSubsequentGet();
43113:     nsCacheStoragePolicy DetermineStoragePolicy();
53987:     nsresult DetermineCacheAccess(nsCacheAccessMode *_retval);
43113:     void     AsyncOnExamineCachedResponse();
43113: 
43113:     // Handle the bogus Content-Encoding Apache sometimes sends
43113:     void ClearBogusContentEncodingIfNeeded();
43113: 
43113:     // byte range request specific methods
43113:     nsresult SetupByteRangeRequest(PRUint32 partialLen);
43113:     nsresult ProcessPartialContent();
43113:     nsresult OnDoneReadingPartialCacheEntry(PRBool *streamDone);
43113: 
43113:     nsresult DoAuthRetry(nsAHttpConnection *);
43113:     PRBool   MustValidateBasedOnQueryUrl();
43113: 
51363:     void     HandleAsyncRedirectChannelToHttps();
51363:     nsresult AsyncRedirectChannelToHttps();
51363:     nsresult ContinueAsyncRedirectChannelToHttps(nsresult rv);
51363: 
51363:     /**
51363:      * A function that takes care of reading STS headers and enforcing STS 
51363:      * load rules.  After a secure channel is erected, STS requires the channel
51363:      * to be trusted or any STS header data on the channel is ignored.
51363:      * This is called from ProcessResponse.
51363:      */
51363:     nsresult ProcessSTSHeader();
51363: 
43113: private:
43113:     nsCOMPtr<nsISupports>             mSecurityInfo;
43113:     nsCOMPtr<nsICancelable>           mProxyRequest;
43113: 
46790:     nsRefPtr<nsInputStreamPump>       mTransactionPump;
46790:     nsRefPtr<nsHttpTransaction>       mTransaction;
43113: 
43113:     PRUint64                          mLogicalOffset;
43113: 
43113:     // cache specific data
43113:     nsCOMPtr<nsICacheEntryDescriptor> mCacheEntry;
43113:     nsRefPtr<nsInputStreamPump>       mCachePump;
46790:     nsAutoPtr<nsHttpResponseHead>     mCachedResponseHead;
43113:     nsCacheAccessMode                 mCacheAccess;
43113:     PRUint32                          mPostID;
43113:     PRUint32                          mRequestTime;
43113: 
53987:     typedef nsresult (nsHttpChannel:: *nsOnCacheEntryAvailableCallback)(
53987:         nsICacheEntryDescriptor *, nsCacheAccessMode, nsresult, PRBool);
53987:     nsOnCacheEntryAvailableCallback   mOnCacheEntryAvailableCallback;
53987:     PRBool                            mAsyncCacheOpen;
53987: 
43113:     nsCOMPtr<nsICacheEntryDescriptor> mOfflineCacheEntry;
43113:     nsCacheAccessMode                 mOfflineCacheAccess;
43113:     nsCString                         mOfflineCacheClientID;
43113: 
43113:     // auth specific data
43832:     nsCOMPtr<nsIHttpChannelAuthProvider> mAuthProvider;
43113: 
43113:     // Function pointer that can be set to indicate that we got suspended while
43113:     // waiting on an AsyncCall.  When we get resumed we should AsyncCall this
43113:     // function.
43113:     nsAsyncCallback                   mPendingAsyncCallOnResume;
43113: 
43113:     // Proxy info to replace with
43113:     nsCOMPtr<nsIProxyInfo>            mTargetProxyInfo;
43113: 
43113:     // Suspend counter.  This is used if someone tries to suspend/resume us
43113:     // before we have either a cache pump or a transaction pump.
43113:     PRUint32                          mSuspendCount;
43113: 
43113:     // If the channel is associated with a cache, and the URI matched
43113:     // a fallback namespace, this will hold the key for the fallback
43113:     // cache entry.
43113:     nsCString                         mFallbackKey;
43113: 
51363:     friend class AutoRedirectVetoNotifier;
48304:     nsCOMPtr<nsIURI>                  mRedirectURI;
48304:     nsCOMPtr<nsIChannel>              mRedirectChannel;
48304:     PRUint32                          mRedirectType;
48304: 
43113:     // state flags
43113:     PRUint32                          mApplyConversion          : 1;
43113:     PRUint32                          mCachedContentIsValid     : 1;
43113:     PRUint32                          mCachedContentIsPartial   : 1;
43113:     PRUint32                          mTransactionReplaced      : 1;
43113:     PRUint32                          mAuthRetryPending         : 1;
43113:     PRUint32                          mResuming                 : 1;
43113:     PRUint32                          mInitedCacheEntry         : 1;
43113:     PRUint32                          mCacheForOfflineUse       : 1;
43113:     // True if mCacheForOfflineUse was set because we were caching
43113:     // opportunistically.
43113:     PRUint32                          mCachingOpportunistically : 1;
43113:     // True if we are loading a fallback cache entry from the
43113:     // application cache.
43113:     PRUint32                          mFallbackChannel          : 1;
43113:     PRUint32                          mTracingEnabled           : 1;
43113:     // True if consumer added its own If-None-Match or If-Modified-Since
43113:     // headers. In such a case we must not override them in the cache code
43113:     // and also we want to pass possible 304 code response through.
43113:     PRUint32                          mCustomConditionalRequest : 1;
48304:     PRUint32                          mFallingBack              : 1;
48304:     PRUint32                          mWaitingForRedirectCallback : 1;
46836:     // True iff this channel is servicing a remote HttpChannelChild
46836:     PRUint32                          mRemoteChannel : 1;
48724:     // True if mRequestTime has been set. In such a case it is safe to update
48724:     // the cache entry's expiration time. Otherwise, it is not(see bug 567360).
48724:     PRUint32                          mRequestTimeInitialized : 1;
43113: 
43113:     class nsContentEncodings : public nsIUTF8StringEnumerator
43113:     {
43113:     public:
43113:         NS_DECL_ISUPPORTS
43113:         NS_DECL_NSIUTF8STRINGENUMERATOR
43113: 
43113:         nsContentEncodings(nsIHttpChannel* aChannel, const char* aEncodingHeader);
43113:         virtual ~nsContentEncodings();
43113:         
43113:     private:
43113:         nsresult PrepareForNext(void);
43113:         
43113:         // We do not own the buffer.  The channel owns it.
43113:         const char* mEncodingHeader;
43113:         const char* mCurStart;  // points to start of current header
43113:         const char* mCurEnd;  // points to end of current header
43113:         
43113:         // Hold a ref to our channel so that it can't go away and take the
43113:         // header with it.
43113:         nsCOMPtr<nsIHttpChannel> mChannel;
43113:         
43113:         PRPackedBool mReady;
43113:     };
48304: 
48304:     nsTArray<nsContinueRedirectionFunc> mRedirectFuncStack;
48304: 
48304:     nsresult WaitForRedirectCallback();
48304:     void PushRedirectAsyncFunc(nsContinueRedirectionFunc func);
48304:     void PopRedirectAsyncFunc(nsContinueRedirectionFunc func);
43113: };
43113: 
43113: #endif // nsHttpChannel_h__
