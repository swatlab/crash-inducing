 28675: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 28675:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 28675: 
 28675: #include "nsClientAuthRemember.h"
 28675: 
 28675: #include "nsIX509Cert.h"
 28675: #include "nsCRT.h"
 28675: #include "nsNetUtil.h"
 28675: #include "nsIObserverService.h"
 28675: #include "nsNetUtil.h"
 28675: #include "nsISupportsPrimitives.h"
 28675: #include "nsPromiseFlatString.h"
 81085: #include "nsThreadUtils.h"
 28675: #include "nsStringBuffer.h"
 28675: #include "nspr.h"
 28675: #include "pk11pub.h"
 28675: #include "certdb.h"
 28675: #include "sechash.h"
 28675: 
 28675: #include "nsNSSCleaner.h"
 64576: 
 64576: using namespace mozilla;
 64576: 
 28675: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
 28675: 
 28675: NS_IMPL_THREADSAFE_ISUPPORTS2(nsClientAuthRememberService, 
 28675:                               nsIObserver,
 28675:                               nsISupportsWeakReference)
 28675: 
 28675: nsClientAuthRememberService::nsClientAuthRememberService()
 64576:   : monitor("nsClientAuthRememberService.monitor")
 28675: {
 28675: }
 28675: 
 28675: nsClientAuthRememberService::~nsClientAuthRememberService()
 28675: {
 28675:   RemoveAllFromMemory();
 28675: }
 28675: 
 28675: nsresult
 28675: nsClientAuthRememberService::Init()
 28675: {
 81085:   if (!NS_IsMainThread()) {
 81085:     NS_ERROR("nsClientAuthRememberService::Init called off the main thread");
 81085:     return NS_ERROR_NOT_SAME_THREAD;
 81085:   }
 81085: 
 98908:   mSettingsTable.Init();
 28675: 
 81085:   nsCOMPtr<nsIObserverService> observerService =
 81085:       mozilla::services::GetObserverService();
 81085:   if (observerService) {
 81085:     observerService->AddObserver(this, "profile-before-change", true);
 28675:   }
 28675: 
 28675:   return NS_OK;
 28675: }
 28675: 
 28675: NS_IMETHODIMP
 28675: nsClientAuthRememberService::Observe(nsISupports     *aSubject,
 28675:                                const char      *aTopic,
 28675:                                const PRUnichar *aData)
 28675: {
 28675:   // check the topic
 28675:   if (!nsCRT::strcmp(aTopic, "profile-before-change")) {
 28675:     // The profile is about to change,
 28675:     // or is going away because the application is shutting down.
 28675: 
 69142:     ReentrantMonitorAutoEnter lock(monitor);
 28675:     RemoveAllFromMemory();
 28675:   }
 28675: 
 28675:   return NS_OK;
 28675: }
 28675: 
 28675: void nsClientAuthRememberService::ClearRememberedDecisions()
 28675: {
 69142:   ReentrantMonitorAutoEnter lock(monitor);
 28675:   RemoveAllFromMemory();
 28675: }
 28675: 
 28675: void
 28675: nsClientAuthRememberService::RemoveAllFromMemory()
 28675: {
 28675:   mSettingsTable.Clear();
 28675: }
 28675: 
 28675: static nsresult
 28675: GetCertFingerprintByOidTag(CERTCertificate* nsscert,
 28675:                            SECOidTag aOidTag, 
 28675:                            nsCString &fp)
 28675: {
 28675:   unsigned int hash_len = HASH_ResultLenByOidTag(aOidTag);
119832:   nsRefPtr<nsStringBuffer> fingerprint = nsStringBuffer::Alloc(hash_len);
 28675:   if (!fingerprint)
 28675:     return NS_ERROR_OUT_OF_MEMORY;
 28675: 
 28675:   PK11_HashBuf(aOidTag, (unsigned char*)fingerprint->Data(), 
 28675:                nsscert->derCert.data, nsscert->derCert.len);
 28675: 
 28675:   SECItem fpItem;
 28675:   fpItem.data = (unsigned char*)fingerprint->Data();
 28675:   fpItem.len = hash_len;
 28675: 
 28675:   fp.Adopt(CERT_Hexify(&fpItem, 1));
 28675:   return NS_OK;
 28675: }
 28675: 
 28675: nsresult
 28675: nsClientAuthRememberService::RememberDecision(const nsACString & aHostName, 
 28675:                                               CERTCertificate *aServerCert, CERTCertificate *aClientCert)
 28675: {
119832:   // aClientCert == NULL means: remember that user does not want to use a cert
 28675:   NS_ENSURE_ARG_POINTER(aServerCert);
 28675:   if (aHostName.IsEmpty())
 28675:     return NS_ERROR_INVALID_ARG;
 28675: 
110974:   nsAutoCString fpStr;
 28675:   nsresult rv = GetCertFingerprintByOidTag(aServerCert, SEC_OID_SHA256, fpStr);
 28675:   if (NS_FAILED(rv))
 28675:     return rv;
 28675: 
 28675:   {
 69142:     ReentrantMonitorAutoEnter lock(monitor);
 28675:     if (aClientCert) {
 28675:       nsNSSCertificate pipCert(aClientCert);
119832:       char *dbkey = NULL;
 28675:       rv = pipCert.GetDbKey(&dbkey);
 28675:       if (NS_SUCCEEDED(rv) && dbkey) {
 28675:         AddEntryToList(aHostName, fpStr, 
 28675:                        nsDependentCString(dbkey));
 28675:       }
 28675:       if (dbkey) {
 28675:         PORT_Free(dbkey);
 28675:       }
 28675:     }
 28675:     else {
 28675:       nsCString empty;
 28675:       AddEntryToList(aHostName, fpStr, empty);
 28675:     }
 28675:   }
 28675: 
 28675:   return NS_OK;
 28675: }
 28675: 
 28675: nsresult
 28675: nsClientAuthRememberService::HasRememberedDecision(const nsACString & aHostName, 
 28675:                                                    CERTCertificate *aCert, 
 28675:                                                    nsACString & aCertDBKey,
 79445:                                                    bool *_retval)
 28675: {
 28675:   if (aHostName.IsEmpty())
 28675:     return NS_ERROR_INVALID_ARG;
 28675: 
 28675:   NS_ENSURE_ARG_POINTER(aCert);
 28675:   NS_ENSURE_ARG_POINTER(_retval);
 80486:   *_retval = false;
 28675: 
 28675:   nsresult rv;
110974:   nsAutoCString fpStr;
 28675:   rv = GetCertFingerprintByOidTag(aCert, SEC_OID_SHA256, fpStr);
 28675:   if (NS_FAILED(rv))
 28675:     return rv;
 28675: 
110974:   nsAutoCString hostCert;
 28675:   GetHostWithCert(aHostName, fpStr, hostCert);
 28675:   nsClientAuthRemember settings;
 28675: 
 28675:   {
 69142:     ReentrantMonitorAutoEnter lock(monitor);
 28675:     nsClientAuthRememberEntry *entry = mSettingsTable.GetEntry(hostCert.get());
 28675:     if (!entry)
 28675:       return NS_OK;
 28675:     settings = entry->mSettings; // copy
 28675:   }
 28675: 
 28675:   aCertDBKey = settings.mDBKey;
 80486:   *_retval = true;
 28675:   return NS_OK;
 28675: }
 28675: 
 28675: nsresult
 28675: nsClientAuthRememberService::AddEntryToList(const nsACString &aHostName, 
 28675:                                       const nsACString &fingerprint,
 28675:                                       const nsACString &db_key)
 28675: 
 28675: {
110974:   nsAutoCString hostCert;
 28675:   GetHostWithCert(aHostName, fingerprint, hostCert);
 28675: 
 28675:   {
 69142:     ReentrantMonitorAutoEnter lock(monitor);
 28675:     nsClientAuthRememberEntry *entry = mSettingsTable.PutEntry(hostCert.get());
 28675: 
 28675:     if (!entry) {
 28675:       NS_ERROR("can't insert a null entry!");
 28675:       return NS_ERROR_OUT_OF_MEMORY;
 28675:     }
 28675: 
 28675:     entry->mHostWithCert = hostCert;
 28675: 
 28675:     nsClientAuthRemember &settings = entry->mSettings;
 28675:     settings.mAsciiHost = aHostName;
 28675:     settings.mFingerprint = fingerprint;
 28675:     settings.mDBKey = db_key;
 28675:   }
 28675: 
 28675:   return NS_OK;
 28675: }
 28675: 
 28675: void
 28675: nsClientAuthRememberService::GetHostWithCert(const nsACString & aHostName, 
 28675:                                              const nsACString & fingerprint, 
 28675:                                              nsACString& _retval)
 28675: {
110974:   nsAutoCString hostCert(aHostName);
 28675:   hostCert.AppendLiteral(":");
 28675:   hostCert.Append(fingerprint);
 28675:   
 28675:   _retval.Assign(hostCert);
 28675: }
