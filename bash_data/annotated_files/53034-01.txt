52558: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52558:  * vim: set ts=4 sw=4 et tw=99:
52558:  *
52558:  * ***** BEGIN LICENSE BLOCK *****
52558:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52558:  *
52558:  * The contents of this file are subject to the Mozilla Public License Version
52558:  * 1.1 (the "License"); you may not use this file except in compliance with
52558:  * the License. You may obtain a copy of the License at
52558:  * http://www.mozilla.org/MPL/
52558:  *
52558:  * Software distributed under the License is distributed on an "AS IS" basis,
52558:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52558:  * for the specific language governing rights and limitations under the
52558:  * License.
52558:  *
52558:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52558:  * May 28, 2008.
52558:  *
52558:  * The Initial Developer of the Original Code is
52558:  *   Brendan Eich <brendan@mozilla.org>
52558:  *
52558:  * Contributor(s):
52558:  *   David Anderson <danderson@mozilla.com>
52558:  *   David Mandelin <dmandelin@mozilla.com>
52558:  *
52558:  * Alternatively, the contents of this file may be used under the terms of
52558:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52558:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52558:  * in which case the provisions of the GPL or the LGPL are applicable instead
52558:  * of those above. If you wish to allow use of your version of this file only
52558:  * under the terms of either the GPL or the LGPL, and not to allow others to
52558:  * use your version of this file under the terms of the MPL, indicate your
52558:  * decision by deleting the provisions above and replace them with the notice
52558:  * and other provisions required by the GPL or the LGPL. If you do not delete
52558:  * the provisions above, a recipient may use your version of this file under
52558:  * the terms of any one of the MPL, the GPL or the LGPL.
52558:  *
52558:  * ***** END LICENSE BLOCK ***** */
52558: #include "MethodJIT.h"
52651: #include "jsnum.h"
52686: #include "jsbool.h"
52737: #include "jsiter.h"
52558: #include "Compiler.h"
52611: #include "StubCalls.h"
52826: #include "MonoIC.h"
52611: #include "assembler/jit/ExecutableAllocator.h"
52826: #include "assembler/assembler/LinkBuffer.h"
52618: #include "FrameState-inl.h"
52668: #include "jsscriptinlines.h"
52560: 
52560: #include "jsautooplen.h"
52558: 
52558: using namespace js;
52558: using namespace js::mjit;
52558: 
52558: #if defined(JS_METHODJIT_SPEW)
52558: static const char *OpcodeNames[] = {
52558: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) #name,
52558: # include "jsopcode.tbl"
52558: # undef OPDEF
52558: };
52558: #endif
52558: 
52560: // This probably does not belong here; adding here for now as a quick build fix.
52560: #if ENABLE_ASSEMBLER && WTF_CPU_X86 && !WTF_PLATFORM_MAC
52560: JSC::MacroAssemblerX86Common::SSE2CheckState JSC::MacroAssemblerX86Common::s_sse2CheckState =
52560: NotCheckedSSE2; 
52560: #endif 
52560: 
52847: #ifdef JS_CPU_X86
52847: static const JSC::MacroAssembler::RegisterID JSReturnReg_Type = JSC::X86Registers::ecx;
52847: static const JSC::MacroAssembler::RegisterID JSReturnReg_Data = JSC::X86Registers::edx;
53030: #elif defined(JS_CPU_ARM)
53030: static const JSC::MacroAssembler::RegisterID JSReturnReg_Type = JSC::ARMRegisters::r2;
53030: static const JSC::MacroAssembler::RegisterID JSReturnReg_Data = JSC::ARMRegisters::r1;
52847: #endif
52847: 
52560: mjit::Compiler::Compiler(JSContext *cx, JSScript *script, JSFunction *fun, JSObject *scopeChain)
52606:   : cx(cx), script(script), scopeChain(scopeChain), globalObj(scopeChain->getGlobal()), fun(fun),
52617:     analysis(cx, script), jumpMap(NULL), frame(cx, script, masm),
52880:     branchPatches(ContextAllocPolicy(cx)), mics(ContextAllocPolicy(cx)),
52880:     pics(ContextAllocPolicy(cx)), stubcc(cx, *this, frame, script)
52558: {
53026: #ifdef DEBUG
53026:     masm.setSpewPath(false);
53026: #endif
52558: }
52558: 
52558: #define CHECK_STATUS(expr)              \
52558:     JS_BEGIN_MACRO                      \
52558:         CompileStatus status_ = (expr); \
52558:         if (status_ != Compile_Okay)    \
52558:             return status_;             \
52558:     JS_END_MACRO
52558: 
52558: CompileStatus
52558: mjit::Compiler::Compile()
52558: {
52558:     JS_ASSERT(!script->ncode);
52558: 
52558:     JaegerSpew(JSpew_Scripts, "compiling script (file \"%s\") (line \"%d\") (length \"%d\")\n",
52558:                            script->filename, script->lineno, script->length);
52558: 
52558:     /* Perform bytecode analysis. */
52558:     if (!analysis.analyze()) {
52558:         if (analysis.OOM())
52558:             return Compile_Error;
52558:         JaegerSpew(JSpew_Abort, "couldn't analyze bytecode; probably switchX or OOM\n");
52558:         return Compile_Abort;
52558:     }
52558: 
52560:     uint32 nargs = fun ? fun->nargs : 0;
52617:     if (!frame.init(nargs) || !stubcc.init(nargs))
52560:         return Compile_Abort;
52560: 
52558:     jumpMap = (Label *)cx->malloc(sizeof(Label) * script->length);
52558:     if (!jumpMap)
52558:         return Compile_Error;
52558: #ifdef DEBUG
52558:     for (uint32 i = 0; i < script->length; i++)
52558:         jumpMap[i] = Label();
52558: #endif
52558: 
52813: #if 0 /* def JS_TRACER */
52558:     if (script->tracePoints) {
52558:         script->trees = (TraceTreeCache*)cx->malloc(script->tracePoints * sizeof(TraceTreeCache));
52558:         if (!script->trees)
52558:             return Compile_Abort;
52558:         memset(script->trees, 0, script->tracePoints * sizeof(TraceTreeCache));
52558:     }
52558: #endif
52558: 
52654: #ifdef JS_METHODJIT_SPEW
52558:     Profiler prof;
52558:     prof.start();
52654: #endif
52558: 
52558:     CHECK_STATUS(generatePrologue());
52558:     CHECK_STATUS(generateMethod());
52558:     CHECK_STATUS(generateEpilogue());
52558:     CHECK_STATUS(finishThisUp());
52558: 
52558: #ifdef JS_METHODJIT_SPEW
52558:     prof.stop();
52558:     JaegerSpew(JSpew_Prof, "compilation took %d us\n", prof.time_us());
52558: #endif
52558: 
52558:     JaegerSpew(JSpew_Scripts, "successfully compiled (code \"%p\") (size \"%ld\")\n",
52617:                (void*)script->ncode, masm.size() + stubcc.size());
52558: 
52560:     return Compile_Okay;
52558: }
52558: 
52558: #undef CHECK_STATUS
52558: 
52558: mjit::Compiler::~Compiler()
52558: {
52558:     cx->free(jumpMap);
52558: }
52558: 
52558: CompileStatus
52611: mjit::TryCompile(JSContext *cx, JSScript *script, JSFunction *fun, JSObject *scopeChain)
52611: {
52611:     Compiler cc(cx, script, fun, scopeChain);
52611: 
52611:     JS_ASSERT(!script->ncode);
52668:     JS_ASSERT(!script->isEmpty());
52611: 
52611:     CompileStatus status = cc.Compile();
52611:     if (status != Compile_Okay)
52611:         script->ncode = JS_UNJITTABLE_METHOD;
52611: 
52611:     return status;
52611: }
52611: 
52611: CompileStatus
52558: mjit::Compiler::generatePrologue()
52558: {
52873:     invokeLabel = masm.label();
52873:     restoreFrameRegs();
52873: 
52873:     /*
52873:      * If there is no function, then this can only be called via JaegerShot(),
52873:      * which expects an existing frame to be initialized like the interpreter.
52873:      */
52872:     if (fun) {
52873:         Jump j = masm.jump();
52873:         invokeLabel = masm.label();
52873:         restoreFrameRegs();
52873: 
52873:         /* Set locals to undefined. */
52873:         for (uint32 i = 0; i < script->nslots; i++) {
52873:             Address local(JSFrameReg, sizeof(JSStackFrame) + i * sizeof(Value));
52873:             masm.storeValue(UndefinedTag(), local);
52872:         }
52872: 
52873:         /* Create the call object. */
52873:         if (fun->isHeavyweight()) {
52873:             prepareStubCall();
52873:             stubCall(stubs::GetCallObject, Uses(0), Defs(0));
52873:         }
52873: 
52873:         j.linkTo(masm.label(), &masm);
52873:     }
52872: 
52558: #ifdef JS_CPU_ARM
52558:     /*
52558:      * Unlike x86/x64, the return address is not pushed on the stack. To
52558:      * compensate, we store the LR back into the stack on entry. This means
52558:      * it's really done twice when called via the trampoline, but it's only
52558:      * one instruction so probably not a big deal.
52558:      *
52558:      * The trampoline version goes through a veneer to make sure we can enter
52558:      * scripts at any arbitrary point - i.e. we can't rely on this being here,
52558:      * except for inline calls.
52558:      */
53030:     masm.storePtr(JSC::ARMRegisters::lr, FrameAddress(offsetof(VMFrame, scriptedReturn)));
52558: #endif
52558: 
52558:     return Compile_Okay;
52558: }
52558: 
52611: CompileStatus
52611: mjit::Compiler::generateEpilogue()
52611: {
52611:     return Compile_Okay;
52611: }
52611: 
52611: CompileStatus
52611: mjit::Compiler::finishThisUp()
52611: {
52611:     for (size_t i = 0; i < branchPatches.length(); i++) {
52611:         Label label = labelOf(branchPatches[i].pc);
52611:         branchPatches[i].jump.linkTo(label, &masm);
52611:     }
52611: 
52611:     JSC::ExecutablePool *execPool = getExecPool(masm.size() + stubcc.size());
52611:     if (!execPool)
52611:         return Compile_Abort;
52611: 
52611:     uint8 *result = (uint8 *)execPool->alloc(masm.size() + stubcc.size());
52611:     JSC::ExecutableAllocator::makeWritable(result, masm.size() + stubcc.size());
52611:     memcpy(result, masm.buffer(), masm.size());
52611:     memcpy(result + masm.size(), stubcc.buffer(), stubcc.size());
52611: 
52661:     /* Build the pc -> ncode mapping. */
52880:     void **nmap = (void **)cx->calloc(sizeof(void *) * (script->length + 1));
52661:     if (!nmap) {
52661:         execPool->release();
52661:         return Compile_Error;
52661:     }
52661: 
52873:     *nmap++ = result;
52669:     script->nmap = nmap;
52669: 
52661:     for (size_t i = 0; i < script->length; i++) {
52661:         Label L = jumpMap[i];
52678:         if (analysis[i].safePoint) {
52661:             JS_ASSERT(L.isValid());
52661:             nmap[i] = (uint8 *)(result + masm.distanceOf(L));
52661:         }
52661:     }
52661: 
52826:     if (mics.length()) {
52826:         script->mics = (ic::MICInfo *)cx->calloc(sizeof(ic::MICInfo) * mics.length());
52826:         if (!script->mics) {
52826:             execPool->release();
52826:             return Compile_Error;
52826:         }
52826:     }
52826: 
52826:     JSC::LinkBuffer fullCode(result, masm.size() + stubcc.size());
52826:     JSC::LinkBuffer stubCode(result + masm.size(), stubcc.size());
52826:     for (size_t i = 0; i < mics.length(); i++) {
52826:         script->mics[i].entry = fullCode.locationOf(mics[i].entry);
52826:         script->mics[i].load = fullCode.locationOf(mics[i].load);
52826:         script->mics[i].shape = fullCode.locationOf(mics[i].shapeVal);
52826:         script->mics[i].stubCall = stubCode.locationOf(mics[i].call);
52826:         script->mics[i].stubEntry = stubCode.locationOf(mics[i].stubEntry);
52831:         script->mics[i].type = mics[i].type;
52831:         script->mics[i].typeConst = mics[i].typeConst;
52831:         script->mics[i].dataConst = mics[i].dataConst;
52831:         script->mics[i].dataWrite = mics[i].dataWrite;
52826:     }
52826: 
52880:     if (pics.length()) {
52880:         uint8 *cursor = (uint8 *)cx->calloc(sizeof(ic::PICInfo) * pics.length() + sizeof(uint32));
52880:         if (!cursor) {
52880:             execPool->release();
52880:             return Compile_Error;
52880:         }
52880:         *(uint32*)cursor = pics.length();
52880:         cursor += sizeof(uint32);
52880:         script->pics = (ic::PICInfo *)cursor;
52880:     }
52880: 
52880:     for (size_t i = 0; i < pics.length(); i++) {
52880:         script->pics[i].kind = pics[i].kind;
52880:         script->pics[i].fastPathStart = fullCode.locationOf(pics[i].hotPathBegin);
52880:         script->pics[i].storeBack = fullCode.locationOf(pics[i].storeBack);
52880:         script->pics[i].slowPathStart = stubCode.locationOf(pics[i].slowPathStart);
52880:         script->pics[i].callReturn = uint8((uint8*)stubCode.locationOf(pics[i].callReturn).executableAddress() -
52880:                                            (uint8*)script->pics[i].slowPathStart.executableAddress());
52880:         script->pics[i].shapeReg = pics[i].shapeReg;
52880:         script->pics[i].objReg = pics[i].objReg;
52892:         script->pics[i].atom = pics[i].atom;
52880:         script->pics[i].shapeGuard = masm.distanceOf(pics[i].shapeGuard) -
52880:                                      masm.distanceOf(pics[i].hotPathBegin);
52887: 
52887:         if (pics[i].kind == ic::PICInfo::SET) {
52887:             script->pics[i].u.vr = pics[i].vr;
52887:         } else {
52887:             script->pics[i].u.get.typeReg = pics[i].typeReg;
52887:             script->pics[i].u.get.shapeRegHasBaseShape = true;
52884:             if (pics[i].hasTypeCheck) {
52884:                 int32 distance = stubcc.masm.distanceOf(pics[i].typeCheck) -
52884:                                  stubcc.masm.distanceOf(pics[i].slowPathStart);
52884:                 JS_ASSERT(-int32(uint8(-distance)) == distance);
52887:                 script->pics[i].u.get.typeCheckOffset = uint8(-distance);
52887:             }
52887:             script->pics[i].u.get.hasTypeCheck = pics[i].hasTypeCheck;
52887:             script->pics[i].u.get.objRemat = pics[i].objRemat.offset;
52884:         }
52880:         new (&script->pics[i].execPools) ic::PICInfo::ExecPoolVector(SystemAllocPolicy());
52880:     }
52880: 
52613:     /* Link fast and slow paths together. */
52613:     stubcc.fixCrossJumps(result, masm.size(), masm.size() + stubcc.size());
52613: 
52613:     /* Patch all outgoing calls. */
52611:     masm.finalize(result);
52611:     stubcc.finalize(result + masm.size());
52611: 
52611:     JSC::ExecutableAllocator::makeExecutable(result, masm.size() + stubcc.size());
52611:     JSC::ExecutableAllocator::cacheFlush(result, masm.size() + stubcc.size());
52611: 
52873:     script->ncode = (uint8 *)(result + masm.distanceOf(invokeLabel));
52611: #ifdef DEBUG
52611:     script->jitLength = masm.size() + stubcc.size();
52611: #endif
52611:     script->execPool = execPool;
52611: 
52611:     return Compile_Okay;
52611: }
52611: 
52776: #ifdef DEBUG
52776: #define SPEW_OPCODE()                                                         \
52776:     JS_BEGIN_MACRO                                                            \
52776:         if (IsJaegerSpewChannelActive(JSpew_JSOps)) {                         \
52776:             JaegerSpew(JSpew_JSOps, "    %2d ", frame.stackDepth());          \
52776:             js_Disassemble1(cx, script, PC, PC - script->code,                \
52776:                             JS_TRUE, stdout);                                 \
52776:         }                                                                     \
52776:     JS_END_MACRO;
52776: #else
52776: #define SPEW_OPCODE()
52776: #endif /* DEBUG */
52776: 
52560: #define BEGIN_CASE(name)        case name:
52560: #define END_CASE(name)                      \
52560:     JS_BEGIN_MACRO                          \
52560:         PC += name##_LENGTH;                \
52560:     JS_END_MACRO;                           \
52560:     break;
52560: 
52558: CompileStatus
52558: mjit::Compiler::generateMethod()
52558: {
52558:     PC = script->code;
52558: 
52558:     for (;;) {
52558:         JSOp op = JSOp(*PC);
52558: 
52558:         OpcodeStatus &opinfo = analysis[PC];
52678:         if (opinfo.nincoming)
52678:             frame.forgetEverything(opinfo.stackDepth);
52558:         opinfo.safePoint = true;
52599:         jumpMap[uint32(PC - script->code)] = masm.label();
52558: 
52558:         if (!opinfo.visited) {
52558:             if (op == JSOP_STOP)
52558:                 break;
52558:             if (js_CodeSpec[op].length != -1)
52558:                 PC += js_CodeSpec[op].length;
52558:             else
52558:                 PC += js_GetVariableBytecodeLength(PC);
52558:             continue;
52558:         }
52558: 
52776:         SPEW_OPCODE();
52599:         JS_ASSERT(frame.stackDepth() == opinfo.stackDepth);
52599: 
52560:     /**********************
52560:      * BEGIN COMPILER OPS *
52560:      **********************/ 
52560: 
52558:         switch (op) {
52647:           BEGIN_CASE(JSOP_NOP)
52647:           END_CASE(JSOP_NOP)
52647: 
52769:           BEGIN_CASE(JSOP_PUSH)
52769:             frame.push(UndefinedTag());
52769:           END_CASE(JSOP_PUSH)
52769: 
52662:           BEGIN_CASE(JSOP_POPV)
52806:           BEGIN_CASE(JSOP_SETRVAL)
52662:           {
52662:             FrameEntry *fe = frame.peek(-1);
52829:             frame.storeTo(fe, Address(JSFrameReg, offsetof(JSStackFrame, rval)), true);
52662:             frame.pop();
52662:           }
52662:           END_CASE(JSOP_POPV)
52662: 
52650:           BEGIN_CASE(JSOP_RETURN)
52650:           {
52650:             /* Safe point! */
52650:             FrameEntry *fe = frame.peek(-1);
52829:             frame.storeTo(fe, Address(JSFrameReg, offsetof(JSStackFrame, rval)), true);
52727:             frame.pop();
52650:             emitReturn();
52650:           }
52650:           END_CASE(JSOP_RETURN)
52650: 
52599:           BEGIN_CASE(JSOP_GOTO)
52599:           {
52617:             /* :XXX: this isn't really necessary if we follow the branch. */
52617:             frame.forgetEverything();
52599:             Jump j = masm.jump();
52599:             jumpInScript(j, PC + GET_JUMP_OFFSET(PC));
52599:           }
52599:           END_CASE(JSOP_GOTO)
52599: 
52686:           BEGIN_CASE(JSOP_IFEQ)
52686:           BEGIN_CASE(JSOP_IFNE)
52686:           {
52686:             FrameEntry *top = frame.peek(-1);
52686:             Jump j;
52686:             if (top->isConstant()) {
52686:                 const Value &v = top->getValue();
52686:                 JSBool b = js_ValueToBoolean(v);
52686:                 if (op == JSOP_IFEQ)
52686:                     b = !b;
52686:                 frame.pop();
52686:                 frame.forgetEverything();
52686:                 if (b) {
52686:                     j = masm.jump();
52686:                     jumpInScript(j, PC + GET_JUMP_OFFSET(PC));
52686:                 }
52686:             } else {
52686:                 frame.forgetEverything();
52686:                 masm.fixScriptStack(frame.frameDepth());
52686:                 masm.setupVMFrame();
53012: #if defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)
53012:                 masm.push(Registers::ArgReg0);
53012: #endif
52686:                 masm.call(JS_FUNC_TO_DATA_PTR(void *, stubs::ValueToBoolean));
53012: #if defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)
53012:                 masm.pop();
53012: #endif
52686:                 Assembler::Condition cond = (op == JSOP_IFEQ)
52686:                                             ? Assembler::Zero
52686:                                             : Assembler::NonZero;
52737:                 j = masm.branchTest32(cond, Registers::ReturnReg, Registers::ReturnReg);
52686:                 frame.pop();
52686:                 jumpInScript(j, PC + GET_JUMP_OFFSET(PC));
52686:             }
52686:           }
52737:           END_CASE(JSOP_IFNE)
52737: 
52778:           BEGIN_CASE(JSOP_ARGUMENTS)
52778:             prepareStubCall();
52778:             stubCall(stubs::Arguments, Uses(0), Defs(1));
52778:             frame.pushSynced();
52778:           END_CASE(JSOP_ARGUMENTS)
52778: 
52737:           BEGIN_CASE(JSOP_FORLOCAL)
52737:             iterNext();
52973:             frame.storeLocal(GET_SLOTNO(PC), true);
52737:             frame.pop();
52737:           END_CASE(JSOP_FORLOCAL)
52686: 
52714:           BEGIN_CASE(JSOP_DUP)
52714:             frame.dup();
52714:           END_CASE(JSOP_DUP)
52714: 
52715:           BEGIN_CASE(JSOP_DUP2)
52715:             frame.dup2();
52715:           END_CASE(JSOP_DUP2)
52715: 
52721:           BEGIN_CASE(JSOP_BITOR)
52718:           BEGIN_CASE(JSOP_BITXOR)
52685:           BEGIN_CASE(JSOP_BITAND)
52685:             jsop_bitop(op);
52685:           END_CASE(JSOP_BITAND)
52685: 
52651:           BEGIN_CASE(JSOP_LT)
52651:           BEGIN_CASE(JSOP_LE)
52651:           BEGIN_CASE(JSOP_GT)
52651:           BEGIN_CASE(JSOP_GE)
52679:           BEGIN_CASE(JSOP_EQ)
52679:           BEGIN_CASE(JSOP_NE)
52651:           {
52652:             /* Detect fusions. */
52652:             jsbytecode *next = &PC[JSOP_GE_LENGTH];
52652:             JSOp fused = JSOp(*next);
52652:             if ((fused != JSOP_IFEQ && fused != JSOP_IFNE) || analysis[next].nincoming)
52651:                 fused = JSOP_NOP;
52652: 
52652:             /* Get jump target, if any. */
52652:             jsbytecode *target = NULL;
52652:             if (fused != JSOP_NOP)
52652:                 target = next + GET_JUMP_OFFSET(next);
52651: 
52652:             BoolStub stub = NULL;
52652:             switch (op) {
52652:               case JSOP_LT:
52652:                 stub = stubs::LessThan;
52652:                 break;
52652:               case JSOP_LE:
52652:                 stub = stubs::LessEqual;
52652:                 break;
52652:               case JSOP_GT:
52652:                 stub = stubs::GreaterThan;
52652:                 break;
52652:               case JSOP_GE:
52652:                 stub = stubs::GreaterEqual;
52652:                 break;
52679:               case JSOP_EQ:
52679:                 stub = stubs::Equal;
52679:                 break;
52679:               case JSOP_NE:
52679:                 stub = stubs::NotEqual;
52679:                 break;
52652:               default:
52652:                 JS_NOT_REACHED("WAT");
52652:                 break;
52652:             }
52653: 
52653:             FrameEntry *rhs = frame.peek(-1);
52653:             FrameEntry *lhs = frame.peek(-2);
52653: 
52653:             /* Check for easy cases that the parser does not constant fold. */
52653:             if (lhs->isConstant() && rhs->isConstant()) {
52653:                 /* Primitives can be trivially constant folded. */
52653:                 const Value &lv = lhs->getValue();
52653:                 const Value &rv = rhs->getValue();
52653: 
52653:                 if (lv.isPrimitive() && rv.isPrimitive()) {
52653:                     bool result = compareTwoValues(cx, op, lv, rv);
52653: 
52652:                     frame.pop();
52652:                     frame.pop();
52652: 
52652:                     if (!target) {
52653:                         frame.push(Value(BooleanTag(result)));
52652:                     } else {
52653:                         if (fused == JSOP_IFEQ)
52653:                             result = !result;
52653: 
52653:                         /* Branch is never taken, don't bother doing anything. */
52653:                         if (result) {
52652:                             frame.forgetEverything();
52653:                             Jump j = masm.jump();
52652:                             jumpInScript(j, target);
52652:                         }
52652:                     }
52652:                 } else {
52653:                     emitStubCmpOp(stub, target, fused);
52653:                 }
52653:             } else {
52651:                 /* Anything else should go through the fast path generator. */
52653:                 jsop_relational(op, stub, target, fused);
52651:             }
52651: 
52651:             /* Advance PC manually. */
52679:             JS_STATIC_ASSERT(JSOP_LT_LENGTH == JSOP_GE_LENGTH);
52679:             JS_STATIC_ASSERT(JSOP_LE_LENGTH == JSOP_GE_LENGTH);
52679:             JS_STATIC_ASSERT(JSOP_GT_LENGTH == JSOP_GE_LENGTH);
52679:             JS_STATIC_ASSERT(JSOP_EQ_LENGTH == JSOP_GE_LENGTH);
52679:             JS_STATIC_ASSERT(JSOP_NE_LENGTH == JSOP_GE_LENGTH);
52679: 
52651:             PC += JSOP_GE_LENGTH;
52776:             if (fused != JSOP_NOP) {
52776:                 SPEW_OPCODE();
52651:                 PC += JSOP_IFNE_LENGTH;
52776:             }
52651:             break;
52651:           }
52651:           END_CASE(JSOP_GE)
52651: 
52685:           BEGIN_CASE(JSOP_LSH)
52685:           BEGIN_CASE(JSOP_RSH)
52617:             jsop_bitop(op);
52685:           END_CASE(JSOP_RSH)
52560: 
52725:           BEGIN_CASE(JSOP_URSH)
52725:             prepareStubCall();
52725:             stubCall(stubs::Ursh, Uses(2), Defs(1));
52725:             frame.popn(2);
52725:             frame.pushSynced();
52725:           END_CASE(JSOP_URSH)
52725: 
52692:           BEGIN_CASE(JSOP_ADD)
52692:             jsop_binary(op, stubs::Add);
52692:           END_CASE(JSOP_ADD)
52692: 
52692:           BEGIN_CASE(JSOP_SUB)
52692:             jsop_binary(op, stubs::Sub);
52692:           END_CASE(JSOP_SUB)
52692: 
52692:           BEGIN_CASE(JSOP_MUL)
52692:             jsop_binary(op, stubs::Mul);
52692:           END_CASE(JSOP_MUL)
52692: 
52692:           BEGIN_CASE(JSOP_DIV)
52692:             jsop_binary(op, stubs::Div);
52692:           END_CASE(JSOP_DIV)
52692: 
52692:           BEGIN_CASE(JSOP_MOD)
52692:             jsop_binary(op, stubs::Mod);
52692:           END_CASE(JSOP_MOD)
52692: 
52734:           BEGIN_CASE(JSOP_NOT)
52734:             jsop_not();
52734:           END_CASE(JSOP_NOT)
52734: 
52724:           BEGIN_CASE(JSOP_BITNOT)
52724:           {
52724:             FrameEntry *top = frame.peek(-1);
52724:             if (top->isConstant() && top->getValue().isPrimitive()) {
52724:                 int32_t i;
52724:                 ValueToECMAInt32(cx, top->getValue(), &i);
52724:                 i = ~i;
52724:                 frame.pop();
52724:                 frame.push(Int32Tag(i));
52724:             } else {
52724:                 jsop_bitnot();
52724:             }
52724:           }
52724:           END_CASE(JSOP_BITNOT)
52724: 
52713:           BEGIN_CASE(JSOP_NEG)
52713:           {
52713:             FrameEntry *top = frame.peek(-1);
52713:             if (top->isConstant() && top->getValue().isPrimitive()) {
52713:                 double d;
52713:                 ValueToNumber(cx, top->getValue(), &d);
52713:                 d = -d;
52713:                 frame.pop();
52713:                 frame.push(DoubleTag(d));
52713:             } else {
52713:                 jsop_neg();
52713:             }
52713:           }
52713:           END_CASE(JSOP_NEG)
52713: 
52738:           BEGIN_CASE(JSOP_TYPEOF)
52784:           BEGIN_CASE(JSOP_TYPEOFEXPR)
52738:             jsop_typeof();
52738:           END_CASE(JSOP_TYPEOF)
52738: 
52676:           BEGIN_CASE(JSOP_VOID)
52676:             frame.pop();
52676:             frame.push(UndefinedTag());
52676:           END_CASE(JSOP_VOID)
52676: 
52732:           BEGIN_CASE(JSOP_INCNAME)
52732:             jsop_nameinc(op, stubs::IncName, fullAtomIndex(PC));
52732:           END_CASE(JSOP_INCNAME)
52732: 
52825:           BEGIN_CASE(JSOP_INCGNAME)
52825:             jsop_nameinc(op, stubs::IncGlobalName, fullAtomIndex(PC));
52825:           END_CASE(JSOP_INCGNAME)
52825: 
52746:           BEGIN_CASE(JSOP_INCPROP)
52746:             jsop_propinc(op, stubs::IncProp, fullAtomIndex(PC));
52916:             break;
52746:           END_CASE(JSOP_INCPROP)
52746: 
52815:           BEGIN_CASE(JSOP_INCELEM)
52815:             jsop_eleminc(op, stubs::IncElem);
52815:           END_CASE(JSOP_INCELEM)
52815: 
52732:           BEGIN_CASE(JSOP_DECNAME)
52732:             jsop_nameinc(op, stubs::DecName, fullAtomIndex(PC));
52732:           END_CASE(JSOP_DECNAME)
52732: 
52825:           BEGIN_CASE(JSOP_DECGNAME)
52825:             jsop_nameinc(op, stubs::DecGlobalName, fullAtomIndex(PC));
52825:           END_CASE(JSOP_DECGNAME)
52825: 
52746:           BEGIN_CASE(JSOP_DECPROP)
52746:             jsop_propinc(op, stubs::DecProp, fullAtomIndex(PC));
52916:             break;
52746:           END_CASE(JSOP_DECPROP)
52746: 
52815:           BEGIN_CASE(JSOP_DECELEM)
52815:             jsop_eleminc(op, stubs::DecElem);
52815:           END_CASE(JSOP_DECELEM)
52815: 
52825:           BEGIN_CASE(JSOP_GNAMEINC)
52825:             jsop_nameinc(op, stubs::GlobalNameInc, fullAtomIndex(PC));
52825:           END_CASE(JSOP_GNAMEINC)
52732: 
52746:           BEGIN_CASE(JSOP_PROPINC)
52746:             jsop_propinc(op, stubs::PropInc, fullAtomIndex(PC));
52916:             break;
52746:           END_CASE(JSOP_PROPINC)
52746: 
52815:           BEGIN_CASE(JSOP_ELEMINC)
52815:             jsop_eleminc(op, stubs::ElemInc);
52815:           END_CASE(JSOP_ELEMINC)
52815: 
52732:           BEGIN_CASE(JSOP_NAMEDEC)
52732:             jsop_nameinc(op, stubs::NameDec, fullAtomIndex(PC));
52732:           END_CASE(JSOP_NAMEDEC)
52732: 
52825:           BEGIN_CASE(JSOP_GNAMEDEC)
52825:             jsop_nameinc(op, stubs::GlobalNameDec, fullAtomIndex(PC));
52825:           END_CASE(JSOP_GNAMEDEC)
52825: 
52746:           BEGIN_CASE(JSOP_PROPDEC)
52746:             jsop_propinc(op, stubs::PropDec, fullAtomIndex(PC));
52916:             break;
52746:           END_CASE(JSOP_PROPDEC)
52746: 
52815:           BEGIN_CASE(JSOP_ELEMDEC)
52815:             jsop_eleminc(op, stubs::ElemDec);
52815:           END_CASE(JSOP_ELEMDEC)
52815: 
52741:           BEGIN_CASE(JSOP_GETTHISPROP)
52741:             /* Push thisv onto stack. */
52741:             jsop_this();
52892:             jsop_getprop(script->getAtom(fullAtomIndex(PC)));
52741:           END_CASE(JSOP_GETTHISPROP);
52741: 
52741:           BEGIN_CASE(JSOP_GETARGPROP)
52741:             /* Push arg onto stack. */
52741:             jsop_getarg(GET_SLOTNO(PC));
52892:             jsop_getprop(script->getAtom(fullAtomIndex(&PC[ARGNO_LEN])));
52741:           END_CASE(JSOP_GETARGPROP)
52741: 
52741:           BEGIN_CASE(JSOP_GETLOCALPROP)
52741:             frame.pushLocal(GET_SLOTNO(PC));
52892:             jsop_getprop(script->getAtom(fullAtomIndex(&PC[SLOTNO_LEN])));
52741:           END_CASE(JSOP_GETLOCALPROP)
52741: 
52741:           BEGIN_CASE(JSOP_GETPROP)
52770:           BEGIN_CASE(JSOP_GETXPROP)
52892:             jsop_getprop(script->getAtom(fullAtomIndex(PC)));
52741:           END_CASE(JSOP_GETPROP)
52741: 
52762:           BEGIN_CASE(JSOP_LENGTH)
52884:             jsop_length();
52762:           END_CASE(JSOP_LENGTH)
52762: 
52693:           BEGIN_CASE(JSOP_GETELEM)
52843:             jsop_getelem();
52693:           END_CASE(JSOP_GETELEM)
52693: 
52693:           BEGIN_CASE(JSOP_SETELEM)
52838:             jsop_setelem();
52693:           END_CASE(JSOP_SETELEM);
52693: 
52644:           BEGIN_CASE(JSOP_CALLNAME)
52644:             prepareStubCall();
52644:             masm.move(Imm32(fullAtomIndex(PC)), Registers::ArgReg1);
52644:             stubCall(stubs::CallName, Uses(0), Defs(2));
52644:             frame.pushSynced();
52771:             frame.pushSynced();
52644:           END_CASE(JSOP_CALLNAME)
52644: 
52645:           BEGIN_CASE(JSOP_CALL)
52767:           BEGIN_CASE(JSOP_EVAL)
52767:           BEGIN_CASE(JSOP_APPLY)
52645:           {
52648:             JaegerSpew(JSpew_Insns, " --- SCRIPTED CALL --- \n");
52850:             inlineCallHelper(GET_ARGC(PC), false);
52648:             JaegerSpew(JSpew_Insns, " --- END SCRIPTED CALL --- \n");
52645:           }
52645:           END_CASE(JSOP_CALL)
52645: 
52615:           BEGIN_CASE(JSOP_NAME)
52615:             prepareStubCall();
52615:             stubCall(stubs::Name, Uses(0), Defs(1));
52617:             frame.pushSynced();
52615:           END_CASE(JSOP_NAME)
52615: 
52605:           BEGIN_CASE(JSOP_DOUBLE)
52605:           {
52605:             uint32 index = fullAtomIndex(PC);
52684:             double d = script->getConst(index).asDouble();
52605:             frame.push(Value(DoubleTag(d)));
52605:           }
52605:           END_CASE(JSOP_DOUBLE)
52605: 
52653:           BEGIN_CASE(JSOP_STRING)
52653:           {
52653:             JSAtom *atom = script->getAtom(fullAtomIndex(PC));
52653:             JSString *str = ATOM_TO_STRING(atom);
52653:             frame.push(Value(StringTag(str)));
52653:           }
52653:           END_CASE(JSOP_STRING)
52653: 
52560:           BEGIN_CASE(JSOP_ZERO)
52617:             frame.push(Valueify(JSVAL_ZERO));
52560:           END_CASE(JSOP_ZERO)
52560: 
52560:           BEGIN_CASE(JSOP_ONE)
52617:             frame.push(Valueify(JSVAL_ONE));
52560:           END_CASE(JSOP_ONE)
52560: 
52675:           BEGIN_CASE(JSOP_NULL)
52675:             frame.push(NullTag());
52675:           END_CASE(JSOP_NULL)
52675: 
52704:           BEGIN_CASE(JSOP_THIS)
52741:             jsop_this();
52704:           END_CASE(JSOP_THIS)
52704: 
52666:           BEGIN_CASE(JSOP_FALSE)
52666:             frame.push(Value(BooleanTag(false)));
52666:           END_CASE(JSOP_FALSE)
52666: 
52665:           BEGIN_CASE(JSOP_TRUE)
52665:             frame.push(Value(BooleanTag(true)));
52665:           END_CASE(JSOP_TRUE)
52665: 
52733:           BEGIN_CASE(JSOP_OR)
52733:           BEGIN_CASE(JSOP_AND)
52733:           {
52733:             JS_STATIC_ASSERT(JSOP_OR_LENGTH == JSOP_AND_LENGTH);
52733:             jsbytecode *target = PC + GET_JUMP_OFFSET(PC);
52733: 
52733:             /* :FIXME: Can we do better and only spill on the taken path? */
52733:             frame.forgetEverything();
52733:             masm.fixScriptStack(frame.frameDepth());
52733:             masm.setupVMFrame();
53012: #if defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)
53012:             masm.push(Registers::ArgReg0);
53012: #endif
52733:             masm.call(JS_FUNC_TO_DATA_PTR(void *, stubs::ValueToBoolean));
53012: #if defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)
53012:             masm.pop();
53012: #endif
52733:             Assembler::Condition cond = (op == JSOP_OR)
52737:                                         ? Assembler::NonZero
52737:                                         : Assembler::Zero;
52733:             Jump j = masm.branchTest32(cond, Registers::ReturnReg, Registers::ReturnReg);
52733:             jumpInScript(j, target);
52733:             frame.pop();
52733:           }
52733:           END_CASE(JSOP_AND)
52733: 
52794:           BEGIN_CASE(JSOP_TABLESWITCH)
52794:             frame.forgetEverything();
52794:             masm.move(ImmPtr(PC), Registers::ArgReg1);
52794:             stubCall(stubs::TableSwitch, Uses(1), Defs(0));
52794:             masm.jump(Registers::ReturnReg);
52794:             PC += js_GetVariableBytecodeLength(PC);
52794:             break;
52794:           END_CASE(JSOP_TABLESWITCH)
52794: 
52793:           BEGIN_CASE(JSOP_LOOKUPSWITCH)
52793:             frame.forgetEverything();
52793:             masm.move(ImmPtr(PC), Registers::ArgReg1);
52793:             stubCall(stubs::LookupSwitch, Uses(1), Defs(0));
52793:             masm.jump(Registers::ReturnReg);
52793:             PC += js_GetVariableBytecodeLength(PC);
52793:             break;
52793:           END_CASE(JSOP_LOOKUPSWITCH)
52793: 
52739:           BEGIN_CASE(JSOP_STRICTEQ)
52855:             jsop_stricteq(op);
52739:           END_CASE(JSOP_STRICTEQ)
52739: 
52739:           BEGIN_CASE(JSOP_STRICTNE)
52855:             jsop_stricteq(op);
52739:           END_CASE(JSOP_STRICTNE)
52739: 
52736:           BEGIN_CASE(JSOP_ITER)
52736:           {
52736:             prepareStubCall();
52736:             masm.move(Imm32(PC[1]), Registers::ArgReg1);
52736:             stubCall(stubs::Iter, Uses(1), Defs(1));
52736:             frame.pop();
52736:             frame.pushSynced();
52736:           }
52736:           END_CASE(JSOP_ITER)
52736: 
52737:           BEGIN_CASE(JSOP_MOREITER)
52737:             /* This MUST be fused with IFNE or IFNEX. */
52737:             iterMore();
52737:             break;
52737:           END_CASE(JSOP_MOREITER)
52737: 
52737:           BEGIN_CASE(JSOP_ENDITER)
52737:             prepareStubCall();
52737:             stubCall(stubs::EndIter, Uses(1), Defs(0));
52737:             frame.pop();
52737:           END_CASE(JSOP_ENDITER)
52737: 
52575:           BEGIN_CASE(JSOP_POP)
52575:             frame.pop();
52575:           END_CASE(JSOP_POP)
52575: 
52697:           BEGIN_CASE(JSOP_NEW)
52697:           {
52697:             JaegerSpew(JSpew_Insns, " --- NEW OPERATOR --- \n");
52850:             inlineCallHelper(GET_ARGC(PC), true);
52697:             JaegerSpew(JSpew_Insns, " --- END NEW OPERATOR --- \n");
52697:           }
52697:           END_CASE(JSOP_NEW)
52697: 
52656:           BEGIN_CASE(JSOP_GETARG)
52678:           BEGIN_CASE(JSOP_CALLARG)
52656:           {
52741:             jsop_getarg(GET_SLOTNO(PC));
52678:             if (op == JSOP_CALLARG)
52678:                 frame.push(NullTag());
52656:           }
52656:           END_CASE(JSOP_GETARG)
52656: 
52825:           BEGIN_CASE(JSOP_BINDGNAME)
52826:             jsop_bindgname();
52825:           END_CASE(JSOP_BINDGNAME)
52825: 
52728:           BEGIN_CASE(JSOP_SETARG)
52728:           {
52728:             uint32 slot = GET_SLOTNO(PC);
52728:             FrameEntry *top = frame.peek(-1);
52728: 
52728:             bool popped = PC[JSOP_SETARG_LENGTH] == JSOP_POP;
52728: 
52728:             RegisterID reg = frame.allocReg();
52829:             masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, argv)), reg);
52728:             Address address = Address(reg, slot * sizeof(Value));
52728:             frame.storeTo(top, address, popped);
52728:             frame.freeReg(reg);
52728:           }
52728:           END_CASE(JSOP_SETARG)
52728: 
52670:           BEGIN_CASE(JSOP_GETLOCAL)
52670:           {
52670:             uint32 slot = GET_SLOTNO(PC);
52670:             frame.pushLocal(slot);
52670:           }
52670:           END_CASE(JSOP_GETLOCAL)
52670: 
52670:           BEGIN_CASE(JSOP_SETLOCAL)
52786:           BEGIN_CASE(JSOP_SETLOCALPOP)
52691:             frame.storeLocal(GET_SLOTNO(PC));
52786:             if (op == JSOP_SETLOCALPOP)
52786:                 frame.pop();
52670:           END_CASE(JSOP_SETLOCAL)
52670: 
52575:           BEGIN_CASE(JSOP_UINT16)
52575:             frame.push(Value(Int32Tag((int32_t) GET_UINT16(PC))));
52575:           END_CASE(JSOP_UINT16)
52575: 
52719:           BEGIN_CASE(JSOP_NEWINIT)
52719:           {
52719:             jsint i = GET_INT8(PC);
52719:             JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
52719: 
52719:             prepareStubCall();
52719:             if (i == JSProto_Array) {
52719:                 stubCall(stubs::NewInitArray, Uses(0), Defs(1));
52719:             } else {
52719:                 JSOp next = JSOp(PC[JSOP_NEWINIT_LENGTH]);
52719:                 masm.move(Imm32(next == JSOP_ENDINIT ? 1 : 0), Registers::ArgReg1);
52719:                 stubCall(stubs::NewInitObject, Uses(0), Defs(1));
52719:             }
52719:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52719:           }
52719:           END_CASE(JSOP_NEWINIT)
52719: 
52719:           BEGIN_CASE(JSOP_ENDINIT)
52898:           {
52898:             FrameEntry *fe = frame.peek(-1);
52898:             RegisterID traversalReg = frame.allocReg();
52898:             JS_ASSERT(!fe->isConstant());
52898:             RegisterID objReg = frame.tempRegForData(fe);
52898:             masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), traversalReg);
52898:             masm.storePtr(objReg,
52898:                           Address(traversalReg,
52898:                                   offsetof(JSContext,
52898:                                            weakRoots.finalizableNewborns[FINALIZE_OBJECT])));
52898:             frame.freeReg(traversalReg);
52898:           }
52719:           END_CASE(JSOP_ENDINIT)
52719: 
52735:           BEGIN_CASE(JSOP_INITPROP)
52735:           {
52735:             JSAtom *atom = script->getAtom(fullAtomIndex(PC));
52735:             prepareStubCall();
52735:             masm.move(ImmPtr(atom), Registers::ArgReg1);
52735:             stubCall(stubs::InitProp, Uses(1), Defs(0));
52735:             frame.pop();
52735:           }
52735:           END_CASE(JSOP_INITPROP)
52735: 
52723:           BEGIN_CASE(JSOP_INITELEM)
52723:           {
52723:             JSOp next = JSOp(PC[JSOP_INITELEM_LENGTH]);
52723:             prepareStubCall();
52723:             masm.move(Imm32(next == JSOP_ENDINIT ? 1 : 0), Registers::ArgReg1);
52723:             stubCall(stubs::InitElem, Uses(2), Defs(0));
52723:             frame.popn(2);
52723:           }
52723:           END_CASE(JSOP_INITELEM)
52723: 
52804:           BEGIN_CASE(JSOP_INCARG)
52804:           BEGIN_CASE(JSOP_DECARG)
52804:           BEGIN_CASE(JSOP_ARGINC)
52804:           BEGIN_CASE(JSOP_ARGDEC)
52804:           {
52804:             jsbytecode *next = &PC[JSOP_ARGINC_LENGTH];
52804:             bool popped = false;
52804:             if (JSOp(*next) == JSOP_POP && !analysis[next].nincoming)
52804:                 popped = true;
52804:             jsop_arginc(op, GET_SLOTNO(PC), popped);
52804:             PC += JSOP_ARGINC_LENGTH;
52804:             if (popped)
52804:                 PC += JSOP_POP_LENGTH;
52804:             break;
52804:           }
52804:           END_CASE(JSOP_ARGDEC)
52804: 
52773:           BEGIN_CASE(JSOP_FORNAME)
52773:             prepareStubCall();
52773:             masm.move(ImmPtr(script->getAtom(fullAtomIndex(PC))), Registers::ArgReg1);
52773:             stubCall(stubs::ForName, Uses(0), Defs(0));
52773:           END_CASE(JSOP_FORNAME)
52773: 
52808:           BEGIN_CASE(JSOP_INCLOCAL)
52808:           BEGIN_CASE(JSOP_DECLOCAL)
52808:           BEGIN_CASE(JSOP_LOCALINC)
52808:           BEGIN_CASE(JSOP_LOCALDEC)
52808:           {
52808:             jsbytecode *next = &PC[JSOP_LOCALINC_LENGTH];
52808:             bool popped = false;
52808:             if (JSOp(*next) == JSOP_POP && !analysis[next].nincoming)
52808:                 popped = true;
52808:             /* These manually advance the PC. */
52808:             jsop_localinc(op, GET_SLOTNO(PC), popped);
52808:             PC += JSOP_LOCALINC_LENGTH;
52808:             if (popped)
52808:                 PC += JSOP_POP_LENGTH;
52808:             break;
52808:           }
52808:           END_CASE(JSOP_LOCALDEC)
52808: 
52560:           BEGIN_CASE(JSOP_BINDNAME)
52560:             jsop_bindname(fullAtomIndex(PC));
52560:           END_CASE(JSOP_BINDNAME)
52560: 
52886:           BEGIN_CASE(JSOP_SETPROP)
52892:             jsop_setprop(script->getAtom(fullAtomIndex(PC)));
52886:           END_CASE(JSOP_SETPROP)
52886: 
52611:           BEGIN_CASE(JSOP_SETNAME)
52747:           BEGIN_CASE(JSOP_SETMETHOD)
52974:             jsop_setprop(script->getAtom(fullAtomIndex(PC)));
52611:           END_CASE(JSOP_SETNAME)
52611: 
52772:           BEGIN_CASE(JSOP_THROW)
52772:             prepareStubCall();
52772:             stubCall(stubs::Throw, Uses(1), Defs(0));
52772:             frame.pop();
52772:           END_CASE(JSOP_THROW)
52772: 
52780:           BEGIN_CASE(JSOP_INSTANCEOF)
52894:             jsop_instanceof();
52780:           END_CASE(JSOP_INSTANCEOF)
52780: 
52786:           BEGIN_CASE(JSOP_EXCEPTION)
52786:           {
52787:             JS_STATIC_ASSERT(sizeof(cx->throwing) == 4);
52786:             RegisterID reg = frame.allocReg();
52786:             masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), reg);
52786:             masm.store32(Imm32(JS_FALSE), Address(reg, offsetof(JSContext, throwing)));
52786: 
52786:             Address excn(reg, offsetof(JSContext, exception));
52786:             frame.freeReg(reg);
52786:             frame.push(excn);
52786:           }
52786:           END_CASE(JSOP_EXCEPTION)
52786: 
52768:           BEGIN_CASE(JSOP_LINENO)
52768:           END_CASE(JSOP_LINENO)
52768: 
52647:           BEGIN_CASE(JSOP_DEFFUN)
52785:             prepareStubCall();
52647:             masm.move(Imm32(fullAtomIndex(PC)), Registers::ArgReg1);
52647:             stubCall(stubs::DefFun, Uses(0), Defs(0));
52647:           END_CASE(JSOP_DEFFUN)
52647: 
52730:           BEGIN_CASE(JSOP_LAMBDA)
52730:           {
52730:             JSFunction *fun = script->getFunction(fullAtomIndex(PC));
52730:             prepareStubCall();
52730:             masm.move(ImmPtr(fun), Registers::ArgReg1);
52730:             stubCall(stubs::Lambda, Uses(0), Defs(1));
52730:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52730:           }
52730:           END_CASE(JSOP_LAMBDA)
52730: 
52774:           BEGIN_CASE(JSOP_TRY)
52774:           END_CASE(JSOP_TRY)
52774: 
52716:           BEGIN_CASE(JSOP_GETDSLOT)
52716:           BEGIN_CASE(JSOP_CALLDSLOT)
52716:           {
52716:             // :FIXME: x64
52716:             RegisterID reg = frame.allocReg();
52829:             masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, argv)), reg);
52716:             masm.loadData32(Address(reg, int32(sizeof(Value)) * -2), reg);
52716:             masm.loadPtr(Address(reg, offsetof(JSObject, dslots)), reg);
52716:             frame.freeReg(reg);
52716:             frame.push(Address(reg, GET_UINT16(PC) * sizeof(Value)));
52716:             if (op == JSOP_CALLDSLOT)
52716:                 frame.push(NullTag());
52716:           }
52716:           END_CASE(JSOP_CALLDSLOT)
52716: 
52781:           BEGIN_CASE(JSOP_ARGCNT)
52781:             prepareStubCall();
52781:             stubCall(stubs::ArgCnt, Uses(0), Defs(1));
52781:             frame.pushSynced();
52781:           END_CASE(JSOP_ARGCNT)
52781: 
52727:           BEGIN_CASE(JSOP_DEFLOCALFUN)
52727:           {
52727:             uint32 slot = GET_SLOTNO(PC);
52727:             JSFunction *fun = script->getFunction(fullAtomIndex(&PC[SLOTNO_LEN]));
52727:             prepareStubCall();
52727:             masm.move(ImmPtr(fun), Registers::ArgReg1);
52727:             stubCall(stubs::DefLocalFun, Uses(0), Defs(0));
52727:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52727:             frame.storeLocal(slot);
52727:             frame.pop();
52727:           }
52727:           END_CASE(JSOP_DEFLOCALFUN)
52727: 
52806:           BEGIN_CASE(JSOP_RETRVAL)
52806:             emitReturn();
52806:           END_CASE(JSOP_RETRVAL)
52806: 
52825:           BEGIN_CASE(JSOP_GETGNAME)
52825:           BEGIN_CASE(JSOP_CALLGNAME)
52826:             jsop_getgname(fullAtomIndex(PC));
52825:             if (op == JSOP_CALLGNAME)
52825:                 frame.push(NullTag());
52825:           END_CASE(JSOP_GETGNAME)
52825: 
52825:           BEGIN_CASE(JSOP_SETGNAME)
52831:             jsop_setgname(fullAtomIndex(PC));
52825:           END_CASE(JSOP_SETGNAME)
52825: 
52729:           BEGIN_CASE(JSOP_REGEXP)
52729:           {
52729:             JSObject *regex = script->getRegExp(fullAtomIndex(PC));
52729:             prepareStubCall();
52729:             masm.move(ImmPtr(regex), Registers::ArgReg1);
52729:             stubCall(stubs::RegExp, Uses(0), Defs(1));
52729:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52729:           }
52729:           END_CASE(JSOP_REGEXP)
52729: 
52761:           BEGIN_CASE(JSOP_CALLPROP)
52903:             if (!jsop_callprop(script->getAtom(fullAtomIndex(PC))))
52903:                 return Compile_Error;
52761:           END_CASE(JSOP_CALLPROP)
52761: 
52726:           BEGIN_CASE(JSOP_GETUPVAR)
52726:           BEGIN_CASE(JSOP_CALLUPVAR)
52726:           {
52726:             uint32 index = GET_UINT16(PC);
52726:             JSUpvarArray *uva = script->upvars();
52726:             JS_ASSERT(index < uva->length);
52726: 
52726:             prepareStubCall();
52726:             masm.move(Imm32(uva->vector[index]), Registers::ArgReg1);
52726:             stubCall(stubs::GetUpvar, Uses(0), Defs(1));
52726:             frame.pushSynced();
52726:             if (op == JSOP_CALLUPVAR)
52726:                 frame.push(NullTag());
52726:           }
52726:           END_CASE(JSOP_CALLUPVAR)
52726: 
52575:           BEGIN_CASE(JSOP_UINT24)
52575:             frame.push(Value(Int32Tag((int32_t) GET_UINT24(PC))));
52575:           END_CASE(JSOP_UINT24)
52575: 
52771:           BEGIN_CASE(JSOP_CALLELEM)
52771:             prepareStubCall();
52771:             stubCall(stubs::CallElem, Uses(2), Defs(2));
52771:             frame.popn(2);
52771:             frame.pushSynced();
52771:             frame.pushSynced();
52771:           END_CASE(JSOP_CALLELEM)
52771: 
52560:           BEGIN_CASE(JSOP_STOP)
52560:             /* Safe point! */
52560:             emitReturn();
52560:             goto done;
52560:           END_CASE(JSOP_STOP)
52560: 
52785:           BEGIN_CASE(JSOP_ENTERBLOCK)
52785:           {
52785:             // If this is an exception entry point, then jsl_InternalThrow has set
52785:             // VMFrame::fp to the correct fp for the entry point. We need to copy
52785:             // that value here to FpReg so that FpReg also has the correct sp.
52785:             // Otherwise, we would simply be using a stale FpReg value.
52785:             if (analysis[PC].exceptionEntry)
52785:                 restoreFrameRegs();
52785: 
52785:             /* For now, don't bother doing anything for this opcode. */
52785:             JSObject *obj = script->getObject(fullAtomIndex(PC));
52785:             frame.forgetEverything();
52785:             masm.move(ImmPtr(obj), Registers::ArgReg1);
52785:             uint32 n = js_GetEnterBlockStackDefs(cx, script, PC);
52785:             stubCall(stubs::EnterBlock, Uses(0), Defs(n));
52785:             frame.enterBlock(n);
52785:           }
52785:           END_CASE(JSOP_ENTERBLOCK)
52785: 
52785:           BEGIN_CASE(JSOP_LEAVEBLOCK)
52785:           {
52785:             uint32 n = js_GetVariableStackUses(op, PC);
52785:             prepareStubCall();
52785:             stubCall(stubs::LeaveBlock, Uses(n), Defs(0));
52785:             frame.leaveBlock(n);
52785:           }
52785:           END_CASE(JSOP_LEAVEBLOCK)
52785: 
52742:           BEGIN_CASE(JSOP_CALLLOCAL)
52742:             frame.pushLocal(GET_SLOTNO(PC));
52742:             frame.push(NullTag());
52742:           END_CASE(JSOP_CALLLOCAL)
52742: 
52575:           BEGIN_CASE(JSOP_INT8)
52575:             frame.push(Value(Int32Tag(GET_INT8(PC))));
52575:           END_CASE(JSOP_INT8)
52575: 
52575:           BEGIN_CASE(JSOP_INT32)
52575:             frame.push(Value(Int32Tag(GET_INT32(PC))));
52575:           END_CASE(JSOP_INT32)
52575: 
52703:           BEGIN_CASE(JSOP_NEWARRAY)
52703:           {
52703:             prepareStubCall();
52703:             uint32 len = GET_UINT16(PC);
52703:             masm.move(Imm32(len), Registers::ArgReg1);
52703:             stubCall(stubs::NewArray, Uses(len), Defs(1));
52703:             frame.popn(len);
52703:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52703:           }
52703:           END_CASE(JSOP_NEWARRAY)
52703: 
52775:           BEGIN_CASE(JSOP_LAMBDA_FC)
52775:           {
52775:             JSFunction *fun = script->getFunction(fullAtomIndex(PC));
52775:             prepareStubCall();
52775:             masm.move(ImmPtr(fun), Registers::ArgReg1);
52775:             stubCall(stubs::FlatLambda, Uses(0), Defs(1));
52775:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52775:           }
52775:           END_CASE(JSOP_LAMBDA_FC)
52775: 
52617:           BEGIN_CASE(JSOP_TRACE)
52753:           {
52753:             if (analysis[PC].nincoming > 0) {
52753:                 RegisterID cxreg = frame.allocReg();
52753:                 masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), cxreg);
52753:                 Address flag(cxreg, offsetof(JSContext, interruptFlags));
52753:                 Jump jump = masm.branchTest32(Assembler::NonZero, flag);
52753:                 frame.freeReg(cxreg);
52753:                 stubcc.linkExit(jump);
52753:                 stubcc.leave();
52753:                 stubcc.call(stubs::Interrupt);
52753:                 stubcc.rejoin(0);
52753:             }
52753:           }
52617:           END_CASE(JSOP_TRACE)
52617: 
52740:           BEGIN_CASE(JSOP_CONCATN)
52740:           {
52740:             uint32 argc = GET_ARGC(PC);
52740:             prepareStubCall();
52740:             masm.move(Imm32(argc), Registers::ArgReg1);
52740:             stubCall(stubs::ConcatN, Uses(argc), Defs(1));
52740:             frame.popn(argc);
52740:             frame.takeReg(Registers::ReturnReg);
53025:             frame.pushTypedPayload(JSVAL_TYPE_STRING, Registers::ReturnReg);
52740:           }
52740:           END_CASE(JSOP_CONCATN)
52740: 
52783:           BEGIN_CASE(JSOP_INITMETHOD)
52783:           {
52783:             JSAtom *atom = script->getAtom(fullAtomIndex(PC));
52783:             prepareStubCall();
52783:             masm.move(ImmPtr(atom), Registers::ArgReg1);
52783:             stubCall(stubs::InitMethod, Uses(1), Defs(0));
52783:             frame.pop();
52783:           }
52783:           END_CASE(JSOP_INITMETHOD)
52783: 
52874:           BEGIN_CASE(JSOP_UNBRAND)
52874:             jsop_unbrand();
52874:           END_CASE(JSOP_UNBRAND)
52874: 
52874:           BEGIN_CASE(JSOP_UNBRANDTHIS)
52874:             jsop_this();
52874:             jsop_unbrand();
52875:             frame.pop();
52874:           END_CASE(JSOP_UNBRANDTHIS)
52874: 
52717:           BEGIN_CASE(JSOP_OBJTOSTR)
52717:             jsop_objtostr();
52717:           END_CASE(JSOP_OBJTOSTR)
52717: 
52560:           BEGIN_CASE(JSOP_GETGLOBAL)
52779:           BEGIN_CASE(JSOP_CALLGLOBAL)
52560:             jsop_getglobal(GET_SLOTNO(PC));
52779:             if (op == JSOP_CALLGLOBAL)
52779:                 frame.push(NullTag());
52560:           END_CASE(JSOP_GETGLOBAL)
52560: 
52560:           BEGIN_CASE(JSOP_SETGLOBAL)
52560:             jsop_setglobal(GET_SLOTNO(PC));
52560:           END_CASE(JSOP_SETGLOBAL)
52560: 
52623:           BEGIN_CASE(JSOP_INCGLOBAL)
52623:           BEGIN_CASE(JSOP_DECGLOBAL)
52623:           BEGIN_CASE(JSOP_GLOBALINC)
52623:           BEGIN_CASE(JSOP_GLOBALDEC)
52623:             /* Advances PC automatically. */
52623:             jsop_globalinc(op, GET_SLOTNO(PC));
52623:             break;
52623:           END_CASE(JSOP_GLOBALINC)
52623: 
52878:           BEGIN_CASE(JSOP_DEFUPVAR)
52878:             frame.addEscaping(GET_SLOTNO(PC));
52878:           END_CASE(JSOP_DEFUPVAR)
52878: 
52558:           default:
52558:            /* Sorry, this opcode isn't implemented yet. */
52558: #ifdef JS_METHODJIT_SPEW
52825:             JaegerSpew(JSpew_Abort, "opcode %s not handled yet (%s line %d)\n", OpcodeNames[op],
52825:                        script->filename, js_PCToLineNumber(cx, script, PC));
52558: #endif
52558:             return Compile_Abort;
52558:         }
52560: 
52560:     /**********************
52560:      *  END COMPILER OPS  *
52560:      **********************/ 
52578: 
52618: #ifdef DEBUG
52578:         frame.assertValidRegisterState();
52618: #endif
52558:     }
52558: 
52560:   done:
52558:     return Compile_Okay;
52558: }
52558: 
52560: #undef END_CASE
52560: #undef BEGIN_CASE
52560: 
52653: JSC::MacroAssembler::Label
52599: mjit::Compiler::labelOf(jsbytecode *pc)
52599: {
52599:     uint32 offs = uint32(pc - script->code);
52599:     JS_ASSERT(jumpMap[offs].isValid());
52599:     return jumpMap[offs];
52599: }
52599: 
52606: JSC::ExecutablePool *
52606: mjit::Compiler::getExecPool(size_t size)
52606: {
52606:     ThreadData *jaegerData = &JS_METHODJIT_DATA(cx);
52606:     return jaegerData->execPool->poolForSize(size);
52606: }
52606: 
52560: uint32
52560: mjit::Compiler::fullAtomIndex(jsbytecode *pc)
52560: {
52560:     return GET_SLOTNO(pc);
52560: 
52560:     /* If we ever enable INDEXBASE garbage, use this below. */
52560: #if 0
52560:     return GET_SLOTNO(pc) + (atoms - script->atomMap.vector);
52560: #endif
52560: }
52560: 
52653: bool
52653: mjit::Compiler::knownJump(jsbytecode *pc)
52653: {
52653:     return pc < PC;
52653: }
52653: 
52599: void
52599: mjit::Compiler::jumpInScript(Jump j, jsbytecode *pc)
52599: {
52599:     JS_ASSERT(pc >= script->code && uint32(pc - script->code) < script->length);
52599: 
52599:     /* :TODO: OOM failure possible here. */
52599: 
52599:     if (pc < PC)
52599:         j.linkTo(jumpMap[uint32(pc - script->code)], &masm);
52599:     else
52599:         branchPatches.append(BranchPatch(j, pc));
52599: }
52599: 
52560: void
52560: mjit::Compiler::jsop_setglobal(uint32 index)
52560: {
52560:     JS_ASSERT(globalObj);
52560:     uint32 slot = script->getGlobalSlot(index);
52560: 
52560:     FrameEntry *fe = frame.peek(-1);
52560:     bool popped = PC[JSOP_SETGLOBAL_LENGTH] == JSOP_POP;
52560: 
52560:     RegisterID reg = frame.allocReg();
52622:     Address address = masm.objSlotRef(globalObj, reg, slot);
52622:     frame.storeTo(fe, address, popped);
52560:     frame.freeReg(reg);
52560: }
52560: 
52560: void
52560: mjit::Compiler::jsop_getglobal(uint32 index)
52560: {
52560:     JS_ASSERT(globalObj);
52560:     uint32 slot = script->getGlobalSlot(index);
52560: 
52560:     RegisterID reg = frame.allocReg();
52622:     Address address = masm.objSlotRef(globalObj, reg, slot);
52560:     frame.freeReg(reg);
52622:     frame.push(address);
52560: }
52560: 
52560: void
52560: mjit::Compiler::emitReturn()
52560: {
52847:     RegisterID t0 = frame.allocReg();
52847: 
52847:     /*
52847:      * if (!f.inlineCallCount)
52847:      *     return;
52847:      */
52847:     Jump noInlineCalls = masm.branchPtr(Assembler::Equal,
52847:                                         FrameAddress(offsetof(VMFrame, inlineCallCount)),
52847:                                         ImmPtr(0));
52847:     stubcc.linkExit(noInlineCalls);
52847: #if defined(JS_CPU_ARM)
53030:     stubcc.masm.loadPtr(FrameAddress(offsetof(VMFrame, scriptedReturn)), JSC::ARMRegisters::lr);
52847: #endif
52847:     stubcc.masm.ret();
52847: 
52847:     /* Restore display. */
52847:     if (script->staticLevel < JS_DISPLAY_SIZE) {
52847:         RegisterID t1 = frame.allocReg();
52847:         masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), t0);
52847:         masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, displaySave)), t1);
52847:         masm.storePtr(t1, Address(t0,
52847:                                   offsetof(JSContext, display) +
52847:                                   script->staticLevel * sizeof(JSStackFrame*)));
52847:         frame.freeReg(t1);
52847:     }
52847: 
52847:     JS_ASSERT_IF(!fun, JSOp(*PC) == JSOP_STOP);
52847: 
52847:     /*
52847:      * If there's a function object, deal with the fact that it can escape.
52847:      * Note that after we've placed the call object, all tracked state can
52847:      * be thrown away. This will happen anyway because the next live opcode
52847:      * (if any) must have an incoming edge.
52847:      *
52847:      * However, it's an optimization to throw it away early - the tracker
52847:      * won't be spilled on further exits or join points.
52847:      */
52847:     if (fun) {
52847:         if (fun->isHeavyweight()) {
52847:             /* There will always be a call object. */
52847:             prepareStubCall();
52847:             stubCall(stubs::PutCallObject, Uses(0), Defs(0));
52847:             frame.throwaway();
52847:         } else {
52847:             /* if (callobj) ... */
52847:             Jump callObj = masm.branchPtr(Assembler::NotEqual,
52847:                                           Address(JSFrameReg, offsetof(JSStackFrame, callobj)),
52847:                                           ImmPtr(0));
52847:             stubcc.linkExit(callObj);
52847: 
52847:             frame.throwaway();
52847: 
52847:             stubcc.leave();
52847:             stubcc.call(stubs::PutCallObject);
52847:             Jump j = stubcc.masm.jump();
52847: 
52847:             /* if (arguments) ... */
53023:             Jump argsObj = masm.testObject(Assembler::Equal,
53023:                                            Address(JSFrameReg, offsetof(JSStackFrame, argsval)));
52847:             stubcc.linkExit(argsObj);
52847:             stubcc.call(stubs::PutArgsObject);
52847:             stubcc.rejoin(0);
52847:             stubcc.crossJump(j, masm.label());
52847:         }
52847:     }
52847: 
52847:     /*
52847:      * r = fp->down
52847:      * a1 = f.cx
52847:      * f.fp = r
52847:      * cx->fp = r
52847:      */
52847:     masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, down)), Registers::ReturnReg);
52847:     masm.loadPtr(FrameAddress(offsetof(VMFrame, cx)), Registers::ArgReg1);
52847:     masm.storePtr(Registers::ReturnReg, FrameAddress(offsetof(VMFrame, fp)));
52847:     masm.storePtr(Registers::ReturnReg, Address(Registers::ArgReg1, offsetof(JSContext, fp)));
52847:     masm.subPtr(ImmIntPtr(1), FrameAddress(offsetof(VMFrame, inlineCallCount)));
52847: 
52847:     JS_STATIC_ASSERT(Registers::ReturnReg != JSReturnReg_Data);
52847:     JS_STATIC_ASSERT(Registers::ReturnReg != JSReturnReg_Type);
52847: 
52847:     Address rval(JSFrameReg, offsetof(JSStackFrame, rval));
52847:     masm.load32(masm.payloadOf(rval), JSReturnReg_Data);
52847:     masm.load32(masm.tagOf(rval), JSReturnReg_Type);
52847:     masm.move(Registers::ReturnReg, JSFrameReg);
52847:     masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, ncode)), Registers::ReturnReg);
52847: #ifdef DEBUG
52847:     masm.storePtr(ImmPtr(JSStackFrame::sInvalidPC),
52847:                   Address(JSFrameReg, offsetof(JSStackFrame, savedPC)));
52847: #endif
52847: 
52560: #if defined(JS_CPU_ARM)
53030:     masm.loadPtr(FrameAddress(offsetof(VMFrame, scriptedReturn)), JSC::ARMRegisters::lr);
52560: #endif
52847: 
52560:     masm.ret();
52560: }
52560: 
52611: void
52611: mjit::Compiler::prepareStubCall()
52611: {
52613:     JaegerSpew(JSpew_Insns, " ---- STUB CALL, SYNCING FRAME ---- \n");
52617:     frame.syncAndKill(Registers::TempRegs);
52611:     JaegerSpew(JSpew_Insns, " ---- FRAME SYNCING DONE ---- \n");
52611: }
52611: 
52611: JSC::MacroAssembler::Call
52611: mjit::Compiler::stubCall(void *ptr, Uses uses, Defs defs)
52611: {
52611:     JaegerSpew(JSpew_Insns, " ---- CALLING STUB ---- \n");
52611:     Call cl = masm.stubCall(ptr, PC, frame.stackDepth() + script->nfixed);
52613:     JaegerSpew(JSpew_Insns, " ---- END STUB CALL ---- \n");
52611:     return cl;
52611: }
52611: 
52645: void
52850: mjit::Compiler::inlineCallHelper(uint32 argc, bool callingNew)
52645: {
52850:     FrameEntry *fe = frame.peek(-int(argc + 2));
52850:     bool typeKnown = fe->isTypeKnown();
52850: 
53025:     if (typeKnown && fe->getKnownType() != JSVAL_TYPE_OBJECT) {
53034:         prepareStubCall();
52872:         VoidPtrStubUInt32 stub = callingNew ? stubs::SlowNew : stubs::SlowCall;
52847:         masm.move(Imm32(argc), Registers::ArgReg1);
52645:         masm.stubCall(stub, PC, frame.stackDepth() + script->nfixed);
52850:         frame.popn(argc + 2);
52850:         frame.pushSynced();
52850:         return;
52850:     }
52850: 
52850:     bool hasTypeReg;
52850:     RegisterID type = Registers::ReturnReg;
52850:     RegisterID data = frame.tempRegForData(fe);
52850:     frame.pinReg(data);
52850: 
52850:     Address addr = frame.addressOf(fe);
52850: 
52850:     if (!typeKnown) {
52850:         if (frame.shouldAvoidTypeRemat(fe)) {
52850:             hasTypeReg = false;
52850:         } else {
52850:             type = frame.tempRegForType(fe);
52850:             hasTypeReg = true;
52850:             frame.pinReg(type);
52850:         }
52850:     }
52850: 
52850:     /*
52850:      * We rely on the fact that syncAndKill() is not allowed to touch the
52850:      * registers we've preserved.
52850:      */
52878:     frame.syncForCall(argc + 2);
52850: 
52872:     Label invoke;
52850:     if (!typeKnown) {
52850:         Jump j;
52850:         if (!hasTypeReg)
53023:             j = masm.testObject(Assembler::NotEqual, frame.addressOf(fe));
52850:         else
53023:             j = masm.testObject(Assembler::NotEqual, type);
52872:         invoke = stubcc.masm.label();
52850:         stubcc.linkExit(j);
53023:         j = masm.testFunction(Assembler::NotEqual, data);
53023:         stubcc.linkExit(j);
52850:         stubcc.leave();
52850:         stubcc.masm.move(Imm32(argc), Registers::ArgReg1);
52850:         stubcc.call(callingNew ? stubs::SlowNew : stubs::SlowCall);
52850:     }
52850: 
52850:     /* Get function private pointer. */
52850:     Address funPrivate(data, offsetof(JSObject, fslots) +
52850:                              JSSLOT_PRIVATE * sizeof(Value));
52850:     masm.loadData32(funPrivate, data);
52850: 
52850:     frame.takeReg(data);
52850:     RegisterID t0 = frame.allocReg();
52850:     RegisterID t1 = frame.allocReg();
52872: 
52872:     /* Test if the function is interpreted, and if not, take a slow path. */
52872:     {
52850:         masm.load16(Address(data, offsetof(JSFunction, flags)), t0);
52850:         masm.move(t0, t1);
52850:         masm.and32(Imm32(JSFUN_KINDMASK), t1);
52850:         Jump notInterp = masm.branch32(Assembler::Below, t1, Imm32(JSFUN_INTERPRETED));
52872: 
52872:         if (!typeKnown) {
52872:             /* Re-use the existing stub, if possible. */
52872:             stubcc.linkExitDirect(notInterp, invoke);
52872:         } else {
52872:             /* Create a new slow path. */
52872:             invoke = stubcc.masm.label();
52850:             stubcc.linkExit(notInterp);
52872:             stubcc.leave();
52872:             stubcc.masm.move(Imm32(argc), Registers::ArgReg1);
52872:             stubcc.call(callingNew ? stubs::SlowNew : stubs::SlowCall);
52872:         }
52872:     }
52872: 
52872:     /* Test if it's not got compiled code. */
52872:     Address scriptAddr(data, offsetof(JSFunction, u) + offsetof(JSFunction::U::Scripted, script));
52872:     masm.loadPtr(scriptAddr, data);
52872:     Jump notCompiled = masm.branchPtr(Assembler::BelowOrEqual,
52872:                                       Address(data, offsetof(JSScript, ncode)),
52872:                                       ImmIntPtr(1));
52872:     {
52872:         stubcc.linkExitDirect(notCompiled, invoke);
52872:     }
52850: 
52850:     frame.freeReg(t0);
52850:     frame.freeReg(t1);
52850:     frame.freeReg(data);
52850: 
52850:     /* Scripted call. */
52850:     masm.move(Imm32(argc), Registers::ArgReg1);
52850:     masm.stubCall(callingNew ? stubs::New : stubs::Call,
52850:                   PC, frame.stackDepth() + script->nfixed);
52645: 
52872:     Jump invokeCallDone;
52872:     {
52645:         /*
52645:          * Stub call returns a pointer to JIT'd code, or NULL.
52645:          *
52645:          * If the function could not be JIT'd, it was already invoked using
52645:          * js_Interpret() or js_Invoke(). In that case, the stack frame has
52872:          * already been popped. We don't have to do any extra work.
52645:          */
52872:         Jump j = stubcc.masm.branchTestPtr(Assembler::NonZero, Registers::ReturnReg, Registers::ReturnReg);
52872:         stubcc.crossJump(j, masm.label());
52872:         if (callingNew)
52872:             invokeCallDone = stubcc.masm.jump();
52872:     }
52872: 
52872:     /* Fast-path: return address contains scripted call. */
52847: 
52645: #ifndef JS_CPU_ARM
52645:     /*
52645:      * Since ARM does not push return addresses on the stack, we rely on the
52645:      * scripted entry to store back the LR safely. Upon return we then write
52645:      * back the LR to the VMFrame instead of pushing.
52645:      */
52645:     masm.addPtr(Imm32(sizeof(void*)), Registers::StackPointer);
52645: #endif
52645:     masm.call(Registers::ReturnReg);
52645: 
52872:     /*
52872:      * The scripted call returns a register triplet, containing the jsval and
52872:      * the current f.scriptedReturn.
52872:      */
52645: #ifdef JS_CPU_ARM
52645:     masm.storePtr(Registers::ReturnReg, FrameAddress(offsetof(VMFrame, scriptedReturn)));
52645: #else
52645:     masm.push(Registers::ReturnReg);
52645: #endif
52645: 
52872:     /*
52872:      * Functions invoked with |new| can return, for some reason, primitive
52872:      * values. Just deal with this here.
52872:      */
52850:     if (callingNew) {
52954:         Jump primitive = masm.testPrimitive(Assembler::Equal, JSReturnReg_Type);
52850:         stubcc.linkExit(primitive);
52850:         FrameEntry *fe = frame.peek(-int(argc + 1));
52850:         Address thisv(frame.addressOf(fe));
52850:         stubcc.masm.loadTypeTag(thisv, JSReturnReg_Type);
52850:         stubcc.masm.loadData32(thisv, JSReturnReg_Data);
52850:         Jump primFix = stubcc.masm.jump();
52850:         stubcc.crossJump(primFix, masm.label());
52872:         invokeCallDone.linkTo(stubcc.masm.label(), &stubcc.masm);
52850:     }
52850: 
52850:     frame.popn(argc + 2);
52850:     frame.takeReg(JSReturnReg_Type);
52850:     frame.takeReg(JSReturnReg_Data);
52850:     frame.pushRegs(JSReturnReg_Type, JSReturnReg_Data);
52850: 
52847:     stubcc.rejoin(0);
52645: }
52645: 
52645: void
52645: mjit::Compiler::restoreFrameRegs()
52645: {
52829:     masm.loadPtr(FrameAddress(offsetof(VMFrame, fp)), JSFrameReg);
52645: }
52645: 
52651: bool
52651: mjit::Compiler::compareTwoValues(JSContext *cx, JSOp op, const Value &lhs, const Value &rhs)
52651: {
52651:     JS_ASSERT(lhs.isPrimitive());
52651:     JS_ASSERT(rhs.isPrimitive());
52651: 
52651:     if (lhs.isString() && rhs.isString()) {
52651:         int cmp = js_CompareStrings(lhs.asString(), rhs.asString());
52651:         switch (op) {
52651:           case JSOP_LT:
52651:             return cmp < 0;
52651:           case JSOP_LE:
52651:             return cmp <= 0;
52651:           case JSOP_GT:
52651:             return cmp > 0;
52651:           case JSOP_GE:
52651:             return cmp >= 0;
52679:           case JSOP_EQ:
52679:             return cmp == 0;
52679:           case JSOP_NE:
52679:             return cmp != 0;
52651:           default:
52651:             JS_NOT_REACHED("NYI");
52651:         }
52651:     } else {
52651:         double ld, rd;
52651:         
52651:         /* These should be infallible w/ primitives. */
52651:         ValueToNumber(cx, lhs, &ld);
52651:         ValueToNumber(cx, rhs, &rd);
52651:         switch(op) {
52651:           case JSOP_LT:
52651:             return ld < rd;
52651:           case JSOP_LE:
52651:             return ld <= rd;
52651:           case JSOP_GT:
52651:             return ld > rd;
52651:           case JSOP_GE:
52651:             return ld >= rd;
52679:           case JSOP_EQ: /* fall through */
52679:           case JSOP_NE:
52679:             /* Special case null/undefined/void comparisons. */
52679:             if (lhs.isNullOrUndefined()) {
52679:                 if (rhs.isNullOrUndefined())
52679:                     return op == JSOP_EQ;
52679:                 return op == JSOP_NE;
52679:             }
52679:             if (rhs.isNullOrUndefined())
52679:                 return op == JSOP_NE;
52679: 
52679:             /* Normal return. */
52679:             return (op == JSOP_EQ) ? (ld == rd) : (ld != rd);
52651:           default:
52651:             JS_NOT_REACHED("NYI");
52651:         }
52651:     }
52651: 
52651:     JS_NOT_REACHED("NYI");
52651:     return false;
52651: }
52651: 
52653: void
52653: mjit::Compiler::emitStubCmpOp(BoolStub stub, jsbytecode *target, JSOp fused)
52653: {
52653:     prepareStubCall();
52653:     stubCall(stub, Uses(2), Defs(0));
52653:     frame.pop();
52653:     frame.pop();
52653: 
52653:     if (!target) {
52653:         frame.takeReg(Registers::ReturnReg);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, Registers::ReturnReg);
52653:     } else {
52679:         JS_ASSERT(fused == JSOP_IFEQ || fused == JSOP_IFNE);
52679: 
52653:         frame.forgetEverything();
52653:         Assembler::Condition cond = (fused == JSOP_IFEQ)
52653:                                     ? Assembler::Zero
52653:                                     : Assembler::NonZero;
52653:         Jump j = masm.branchTest32(cond, Registers::ReturnReg,
52653:                                    Registers::ReturnReg);
52653:         jumpInScript(j, target);
52653:     }
52653: }
52653: 
52692: void
52892: mjit::Compiler::jsop_setprop_slow(JSAtom *atom)
52886: {
52886:     prepareStubCall();
52886:     masm.move(ImmPtr(atom), Registers::ArgReg1);
52886:     stubCall(stubs::SetName, Uses(2), Defs(1));
52886:     JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
52886:     frame.shimmy(1);
52886: }
52886: 
52886: void
52743: mjit::Compiler::jsop_getprop_slow()
52743: {
52743:     prepareStubCall();
52743:     stubCall(stubs::GetProp, Uses(1), Defs(1));
52743:     frame.pop();
52743:     frame.pushSynced();
52743: }
52743: 
52903: bool
52896: mjit::Compiler::jsop_callprop_slow(JSAtom *atom)
52896: {
52896:     prepareStubCall();
52896:     masm.move(ImmPtr(atom), Registers::ArgReg1);
52896:     stubCall(stubs::CallProp, Uses(1), Defs(2));
52896:     frame.pop();
52896:     frame.pushSynced();
52896:     frame.pushSynced();
52903:     return true;
52896: }
52896: 
52896: void
52884: mjit::Compiler::jsop_length()
52884: {
52884:     FrameEntry *top = frame.peek(-1);
52884: 
53025:     if (top->isTypeKnown() && top->getKnownType() == JSVAL_TYPE_STRING) {
52884:         if (top->isConstant()) {
52884:             JSString *str = top->getValue().asString();
52884:             Value v;
52885:             v.setNumber(uint32(str->length()));
52884:             frame.pop();
52884:             frame.push(v);
52884:         } else {
52884:             RegisterID str = frame.ownRegForData(top);
52884:             masm.loadPtr(Address(str, offsetof(JSString, mLength)), str);
52884:             frame.pop();
53025:             frame.pushTypedPayload(JSVAL_TYPE_INT32, str);
52884:         }
52884:         return;
52884:     }
52884: 
52884: #if ENABLE_PIC
52892:     jsop_getprop(cx->runtime->atomState.lengthAtom);
52884: #else
52884:     prepareStubCall();
52884:     stubCall(stubs::Length, Uses(1), Defs(1));
52884:     frame.pop();
52884:     frame.pushSynced();
52884: #endif
52884: }
52884: 
52880: #if ENABLE_PIC
52880: void
52894: mjit::Compiler::jsop_getprop(JSAtom *atom, bool doTypeCheck)
52880: {
52880:     FrameEntry *top = frame.peek(-1);
52880: 
52884:     /* If the incoming type will never PIC, take slow path. */
53025:     if (top->isTypeKnown() && top->getKnownType() != JSVAL_TYPE_OBJECT) {
52892:         JS_ASSERT_IF(atom == cx->runtime->atomState.lengthAtom,
53025:                      top->getKnownType() != JSVAL_TYPE_STRING);
52880:         jsop_getprop_slow();
52880:         return;
52880:     }
52880: 
52884:     /*
52884:      * These two must be loaded first. The objReg because the string path
52884:      * wants to read it, and the shapeReg because it could cause a spill that
52884:      * the string path wouldn't sink back.
52884:      */
52884:     RegisterID objReg = Registers::ReturnReg;
52884:     RegisterID shapeReg = Registers::ReturnReg;
52892:     if (atom == cx->runtime->atomState.lengthAtom) {
52884:         objReg = frame.copyDataIntoReg(top);
52884:         shapeReg = frame.allocReg();
52884:     }
52884: 
52880:     PICGenInfo pic(ic::PICInfo::GET);
52880: 
52880:     /* Guard that the type is an object. */
52884:     Jump typeCheck;
52894:     if (doTypeCheck && !top->isTypeKnown()) {
52880:         RegisterID reg = frame.tempRegForType(top);
52884:         pic.typeReg = reg;
52884: 
52884:         /* Start the hot path where it's easy to patch it. */
52884:         pic.hotPathBegin = masm.label();
53023:         Jump j = masm.testObject(Assembler::NotEqual, reg);
52884: 
52884:         pic.typeCheck = stubcc.masm.label();
52880:         stubcc.linkExit(j);
52880:         stubcc.leave();
52884:         typeCheck = stubcc.masm.jump();
52884:         pic.hasTypeCheck = true;
52884:     } else {
52884:         pic.hotPathBegin = masm.label();
52884:         pic.hasTypeCheck = false;
52884:         pic.typeReg = Registers::ReturnReg;
52880:     }
52880: 
52892:     if (atom != cx->runtime->atomState.lengthAtom) {
52884:         objReg = frame.copyDataIntoReg(top);
52884:         shapeReg = frame.allocReg();
52884:     }
52884: 
52880:     pic.shapeReg = shapeReg;
52892:     pic.atom = atom;
52880:     pic.objRemat = frame.dataRematInfo(top);
52880: 
52880:     /* Guard on shape. */
52880:     masm.loadPtr(Address(objReg, offsetof(JSObject, map)), shapeReg);
52880:     masm.load32(Address(shapeReg, offsetof(JSObjectMap, shape)), shapeReg);
52880:     pic.shapeGuard = masm.label();
52880:     Jump j = masm.branch32(Assembler::NotEqual, shapeReg,
52880:                            Imm32(int32(JSObjectMap::INVALID_SHAPE)));
52880:     pic.slowPathStart = stubcc.masm.label();
52880:     stubcc.linkExit(j);
52880: 
52880:     stubcc.leave();
52884:     if (pic.hasTypeCheck)
52884:         typeCheck.linkTo(stubcc.masm.label(), &stubcc.masm);
52880:     stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
52880:     pic.callReturn = stubcc.call(ic::GetProp);
52880: 
52880:     /* Load dslots. */
52880:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52880: 
52880:     /* Copy the slot value to the expression stack. */
52880:     Address slot(objReg, 1 << 24);
52880:     frame.pop();
52880:     masm.loadTypeTag(slot, shapeReg);
52880:     masm.loadData32(slot, objReg);
52880:     pic.objReg = objReg;
52880:     frame.pushRegs(shapeReg, objReg);
52880:     pic.storeBack = masm.label();
52880: 
52880:     stubcc.rejoin(1);
52880: 
52880:     pics.append(pic);
52880: }
52880: 
52903: bool
52906: mjit::Compiler::jsop_callprop_generic(JSAtom *atom)
52906: {
52906:     FrameEntry *top = frame.peek(-1);
52906: 
52906:     /*
52906:      * These two must be loaded first. The objReg because the string path
52906:      * wants to read it, and the shapeReg because it could cause a spill that
52906:      * the string path wouldn't sink back.
52906:      */
52906:     RegisterID objReg = frame.copyDataIntoReg(top);
52906:     RegisterID shapeReg = frame.allocReg();
52906: 
52906:     PICGenInfo pic(ic::PICInfo::CALL);
52906: 
52906:     /* Guard that the type is an object. */
52906:     pic.typeReg = frame.copyTypeIntoReg(top);
52906: 
52906:     /* Start the hot path where it's easy to patch it. */
52906:     pic.hotPathBegin = masm.label();
52906: 
52906:     /*
52906:      * Guard that the value is an object. This part needs some extra gunk
52906:      * because the leave() after the shape guard will emit a jump from this
52906:      * path to the final call. We need a label in between that jump, which
52906:      * will be the target of patched jumps in the PIC.
52906:      */
53023:     Jump typeCheck = masm.testObject(Assembler::NotEqual, pic.typeReg);
52906:     stubcc.linkExit(typeCheck);
52906:     stubcc.leave();
52906:     Jump typeCheckDone = stubcc.masm.jump();
52906: 
52906:     pic.typeCheck = stubcc.masm.label();
52906:     pic.hasTypeCheck = true;
52906:     pic.objReg = objReg;
52906:     pic.shapeReg = shapeReg;
52906:     pic.atom = atom;
52906:     pic.objRemat = frame.dataRematInfo(top);
52906: 
52906:     /*
52906:      * Store the type and object back. Don't bother keeping them in registers,
52906:      * since a sync will be needed for the upcoming call.
52906:      */
52906:     uint32 thisvSlot = frame.frameDepth();
52906:     Address thisv = Address(JSFrameReg, sizeof(JSStackFrame) + thisvSlot * sizeof(Value));
52906:     masm.storeTypeTag(pic.typeReg, thisv);
52906:     masm.storeData32(pic.objReg, thisv);
52906:     frame.freeReg(pic.typeReg);
52906: 
52906:     /* Guard on shape. */
52906:     masm.loadPtr(Address(objReg, offsetof(JSObject, map)), shapeReg);
52906:     masm.load32(Address(shapeReg, offsetof(JSObjectMap, shape)), shapeReg);
52906:     pic.shapeGuard = masm.label();
52906:     Jump j = masm.branch32(Assembler::NotEqual, shapeReg,
52906:                            Imm32(int32(JSObjectMap::INVALID_SHAPE)));
52906:     pic.slowPathStart = stubcc.masm.label();
52906:     stubcc.linkExit(j);
52906: 
52906:     /* Slow path. */
52906:     stubcc.leave();
52906:     typeCheckDone.linkTo(stubcc.masm.label(), &stubcc.masm);
52906:     stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
52906:     pic.callReturn = stubcc.call(ic::CallProp);
52906: 
52906:     /* Adjust the frame. None of this will generate code. */
52906:     frame.pop();
52906:     frame.pushRegs(shapeReg, objReg);
52906:     frame.pushSynced();
52906: 
52906:     /* Load dslots. */
52906:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52906: 
52906:     /* Copy the slot value to the expression stack. */
52906:     Address slot(objReg, 1 << 24);
52906:     masm.loadTypeTag(slot, shapeReg);
52906:     masm.loadData32(slot, objReg);
52906:     pic.storeBack = masm.label();
52906: 
52906:     stubcc.rejoin(1);
52906: 
52906:     pics.append(pic);
52906: 
52906:     return true;
52906: }
52906: 
52906: bool
52903: mjit::Compiler::jsop_callprop_str(JSAtom *atom)
52903: {
52903:     if (!script->compileAndGo) {
52903:         jsop_callprop_slow(atom);
52903:         return true; 
52903:     }
52903: 
52903:     /* Bake in String.prototype. Is this safe? */
52903:     JSObject *obj;
52903:     if (!js_GetClassPrototype(cx, NULL, JSProto_String, &obj))
52903:         return false;
52903: 
52903:     /* Force into a register because getprop won't expect a constant. */
52903:     RegisterID reg = frame.allocReg();
52903:     masm.move(ImmPtr(obj), reg);
53025:     frame.pushTypedPayload(JSVAL_TYPE_OBJECT, reg);
52903: 
52903:     /* Get the property. */
52903:     jsop_getprop(atom);
52903: 
52903:     /* Perform a swap. */
52903:     frame.dup2();
52903:     frame.shift(-3);
52903:     frame.shift(-1);
52903: 
52903:     /* 4) Test if the function can take a primitive. */
52903:     FrameEntry *funFe = frame.peek(-2);
52903:     JS_ASSERT(!funFe->isTypeKnown());
52903: 
52903:     RegisterID temp = frame.allocReg();
53023:     RegisterID funReg = frame.copyDataIntoReg(funFe);
53023:     Jump notFun1 = frame.testObject(Assembler::NotEqual, funFe);
53023:     Jump notFun2 = masm.testFunction(Assembler::NotEqual, funReg);
53023: 
53023:     Address fslot(funReg, offsetof(JSObject, fslots) + JSSLOT_PRIVATE * sizeof(Value));
52903:     masm.loadData32(fslot, temp);
52903:     masm.load16(Address(temp, offsetof(JSFunction, flags)), temp);
52903:     masm.and32(Imm32(JSFUN_THISP_STRING), temp);
52903:     Jump noPrim = masm.branchTest32(Assembler::Zero, temp, temp);
52903:     {
52903:         stubcc.linkExit(noPrim);
52903:         stubcc.leave();
52903:         stubcc.call(stubs::WrapPrimitiveThis);
52903:     }
52903: 
53023:     frame.freeReg(funReg);
52903:     frame.freeReg(temp);
53023:     notFun2.linkTo(masm.label(), &masm);
53023:     notFun1.linkTo(masm.label(), &masm);
52903:     
52903:     stubcc.rejoin(1);
52903: 
52903:     return true;
52903: }
52903: 
52903: bool
52896: mjit::Compiler::jsop_callprop_obj(JSAtom *atom)
52896: {
52896:     FrameEntry *top = frame.peek(-1);
52896: 
52896:     PICGenInfo pic(ic::PICInfo::CALL);
52896: 
52896:     JS_ASSERT(top->isTypeKnown());
53025:     JS_ASSERT(top->getKnownType() == JSVAL_TYPE_OBJECT);
52896: 
52896:     pic.hotPathBegin = masm.label();
52896:     pic.hasTypeCheck = false;
52896:     pic.typeReg = Registers::ReturnReg;
52896: 
52896:     RegisterID objReg = frame.copyDataIntoReg(top);
52896:     RegisterID shapeReg = frame.allocReg();
52896: 
52896:     pic.shapeReg = shapeReg;
52896:     pic.atom = atom;
52896:     pic.objRemat = frame.dataRematInfo(top);
52896: 
52896:     /* Guard on shape. */
52896:     masm.loadPtr(Address(objReg, offsetof(JSObject, map)), shapeReg);
52896:     masm.load32(Address(shapeReg, offsetof(JSObjectMap, shape)), shapeReg);
52896:     pic.shapeGuard = masm.label();
52896:     Jump j = masm.branch32(Assembler::NotEqual, shapeReg,
52896:                            Imm32(int32(JSObjectMap::INVALID_SHAPE)));
52896:     pic.slowPathStart = stubcc.masm.label();
52896:     stubcc.linkExit(j);
52896: 
52896:     stubcc.leave();
52896:     stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
52896:     pic.callReturn = stubcc.call(ic::CallProp);
52896: 
52896:     /* Load dslots. */
52896:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52896: 
52896:     /* Copy the slot value to the expression stack. */
52896:     Address slot(objReg, 1 << 24);
52896:     masm.loadTypeTag(slot, shapeReg);
52896:     masm.loadData32(slot, objReg);
52896:     pic.objReg = objReg;
52896:     pic.storeBack = masm.label();
52896: 
52896:     /*
52896:      * 1) Dup the |this| object.
52896:      * 2) Push the property value onto the stack.
52896:      * 3) Move the value below the dup'd |this|, uncopying it. This could
52896:      * generate code, thus the storeBack label being prior. This is safe
52896:      * as a stack transition, because JSOP_CALLPROP has JOF_TMPSLOT. It is
52896:      * also safe for correctness, because if we know the LHS is an object, it
52896:      * is the resulting vp[1].
52896:      */
52896:     frame.dup();
52896:     frame.pushRegs(shapeReg, objReg);
52896:     frame.shift(-2);
52896: 
52896:     stubcc.rejoin(1);
52896: 
52896:     pics.append(pic);
52903: 
52903:     return true;
52896: }
52896: 
52903: bool
52896: mjit::Compiler::jsop_callprop(JSAtom *atom)
52896: {
52896:     FrameEntry *top = frame.peek(-1);
52896: 
52896:     /* If the incoming type will never PIC, take slow path. */
53025:     if (top->isTypeKnown() && top->getKnownType() != JSVAL_TYPE_OBJECT) {
53025:         if (top->getKnownType() == JSVAL_TYPE_STRING)
52903:             return jsop_callprop_str(atom);
52903:         return jsop_callprop_slow(atom);
52896:     }
52896: 
52896:     if (top->isTypeKnown())
52903:         return jsop_callprop_obj(atom);
52906:     return jsop_callprop_generic(atom);
52896: }
52896: 
52896: void
52892: mjit::Compiler::jsop_setprop(JSAtom *atom)
52886: {
52887:     FrameEntry *lhs = frame.peek(-2);
52887:     FrameEntry *rhs = frame.peek(-1);
52887: 
52887:     /* If the incoming type will never PIC, take slow path. */
53025:     if (lhs->isTypeKnown() && lhs->getKnownType() != JSVAL_TYPE_OBJECT) {
52892:         jsop_setprop_slow(atom);
52887:         return;
52887:     }
52887: 
52887:     PICGenInfo pic(ic::PICInfo::SET);
52892:     pic.atom = atom;
52887: 
52887:     /* Guard that the type is an object. */
52887:     Jump typeCheck;
52887:     if (!lhs->isTypeKnown()) {
52887:         RegisterID reg = frame.tempRegForType(lhs);
52887:         pic.typeReg = reg;
52887: 
52887:         /* Start the hot path where it's easy to patch it. */
52887:         pic.hotPathBegin = masm.label();
53025:         Jump j = masm.testObject(Assembler::NotEqual, reg);
52887: 
52887:         pic.typeCheck = stubcc.masm.label();
52887:         stubcc.linkExit(j);
52887:         stubcc.leave();
52892:         stubcc.masm.move(ImmPtr(atom), Registers::ArgReg1);
52887:         stubcc.call(stubs::SetName);
52887:         typeCheck = stubcc.masm.jump();
52887:         pic.hasTypeCheck = true;
52887:     } else {
52887:         pic.hotPathBegin = masm.label();
52887:         pic.hasTypeCheck = false;
52887:         pic.typeReg = Registers::ReturnReg;
52887:     }
52887: 
52887:     /* Get the object into a mutable register. */
52887:     RegisterID objReg = frame.copyDataIntoReg(lhs);
52887:     pic.objReg = objReg;
52887: 
52887:     /* Get info about the RHS and pin it. */
52887:     ValueRemat vr;
52887:     if (rhs->isConstant()) {
52887:         vr.isConstant = true;
52887:         vr.u.v = Jsvalify(rhs->getValue());
52887:     } else {
52887:         vr.isConstant = false;
52887:         vr.u.s.isTypeKnown = rhs->isTypeKnown();
52887:         if (vr.u.s.isTypeKnown) {
53025:             vr.u.s.type.tag = rhs->getKnownTag();
52887:         } else {
52887:             vr.u.s.type.reg = frame.tempRegForType(rhs);
52887:             frame.pinReg(vr.u.s.type.reg);
52887:         }
52887:         vr.u.s.data = frame.tempRegForData(rhs);
52887:         frame.pinReg(vr.u.s.data);
52887:     }
52887:     pic.vr = vr;
52887: 
52887:     RegisterID shapeReg = frame.allocReg();
52887:     pic.shapeReg = shapeReg;
52887:     pic.objRemat = frame.dataRematInfo(lhs);
52887: 
52887:     if (!vr.isConstant) {
52887:         if (!vr.u.s.isTypeKnown)
52887:             frame.unpinReg(vr.u.s.type.reg);
52887:         frame.unpinReg(vr.u.s.data);
52887:     }
52887: 
52887:     /* Guard on shape. */
52887:     masm.loadPtr(Address(objReg, offsetof(JSObject, map)), shapeReg);
52887:     masm.load32(Address(shapeReg, offsetof(JSObjectMap, shape)), shapeReg);
52887:     pic.shapeGuard = masm.label();
52887:     Jump j = masm.branch32(Assembler::NotEqual, shapeReg,
52887:                            Imm32(int32(JSObjectMap::INVALID_SHAPE)));
52887: 
52887:     /* Slow path. */
52887:     {
52887:         pic.slowPathStart = stubcc.masm.label();
52887:         stubcc.linkExit(j);
52887: 
52887:         stubcc.leave();
52887:         stubcc.masm.move(Imm32(pics.length()), Registers::ArgReg1);
52887:         pic.callReturn = stubcc.call(ic::SetProp);
52887:     }
52887: 
52887:     /* Load dslots. */
52887:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52887: 
52887:     /* Store RHS into object slot. */
52887:     Address slot(objReg, 1 << 24);
52887:     if (vr.isConstant) {
52887:         masm.storeValue(Valueify(vr.u.v), slot);
52887:     } else {
52887:         if (vr.u.s.isTypeKnown)
52954:             masm.storeTypeTag(ImmTag(vr.u.s.type.tag), slot);
52887:         else
52887:             masm.storeTypeTag(vr.u.s.type.reg, slot);
52887:         masm.storeData32(vr.u.s.data, slot);
52887:     }
52887:     frame.freeReg(objReg);
52887:     frame.freeReg(shapeReg);
52887:     pic.storeBack = masm.label();
52887: 
52887:     /* "Pop under", taking out object (LHS) and leaving RHS. */
52887:     frame.shimmy(1);
52887: 
52887:     /* Finish slow path. */
52887:     {
52887:         if (pic.hasTypeCheck)
52887:             typeCheck.linkTo(stubcc.masm.label(), &stubcc.masm);
52887:         stubcc.rejoin(1);
52887:     }
52887: 
52887:     pics.append(pic);
52886: }
52886: 
52884: #else /* ENABLE_PIC */
52880: 
52880: void
52894: mjit::Compiler::jsop_getprop(JSAtom *atom, bool typecheck)
52880: {
52892:     jsop_getprop_slow();
52886: }
52886: 
52886: void
52896: mjit::Compiler::jsop_callprop(JSAtom *atom)
52896: {
52896:     jsop_callprop_slow(atom);
52896: }
52896: 
52896: void
52892: mjit::Compiler::jsop_setprop(JSAtom *atom)
52886: {
52892:     jsop_setprop_slow(atom);
52880: }
52880: #endif
52880: 
52743: void
52741: mjit::Compiler::jsop_getarg(uint32 index)
52741: {
52741:     RegisterID reg = frame.allocReg();
52829:     masm.loadPtr(Address(JSFrameReg, offsetof(JSStackFrame, argv)), reg);
52741:     frame.freeReg(reg);
52741:     frame.push(Address(reg, index * sizeof(Value)));
52741: }
52741: 
52741: void
52741: mjit::Compiler::jsop_this()
52741: {
53023:     Address thisvAddr(JSFrameReg, offsetof(JSStackFrame, thisv));
53023:     if (0 && !script->strictModeCode) {
53023:         Jump null = masm.testNull(Assembler::Equal, thisvAddr);
53023:         stubcc.linkExit(null);
53023:         stubcc.leave();
53023:         stubcc.call(stubs::ComputeThis);
53023:         stubcc.rejoin(0);
53023: 
53023:         RegisterID reg = frame.allocReg();
53023:         masm.loadData32(thisvAddr, reg);
53025:         frame.pushTypedPayload(JSVAL_TYPE_OBJECT, reg);
53023:     } else {
53023:         frame.push(thisvAddr);
53023:         Jump null = frame.testNull(Assembler::Equal, frame.peek(-1));
53004:         stubcc.linkExit(null);
52854:         stubcc.leave();
52854:         stubcc.call(stubs::This);
53004:         stubcc.rejoin(1);
52741:     }
53023: }
52741: 
52741: void
52732: mjit::Compiler::jsop_nameinc(JSOp op, VoidStubAtom stub, uint32 index)
52732: {
52732:     JSAtom *atom = script->getAtom(index);
52732:     prepareStubCall();
52732:     masm.move(ImmPtr(atom), Registers::ArgReg1);
52732:     stubCall(stub, Uses(0), Defs(1));
52732:     frame.pushSynced();
52732: }
52732: 
52746: void
52746: mjit::Compiler::jsop_propinc(JSOp op, VoidStubAtom stub, uint32 index)
52746: {
52746:     JSAtom *atom = script->getAtom(index);
52916:     jsbytecode *next = &PC[JSOP_PROPINC_LENGTH];
52916:     bool pop = (JSOp(*next) == JSOP_POP) && !analysis[next].nincoming;
52916:     int amt = (op == JSOP_PROPINC || op == JSOP_INCPROP) ? -1 : 1;
52916: 
52916: #if ENABLE_PIC
52916:     if (pop || (op == JSOP_INCPROP || op == JSOP_DECPROP)) {
52916:         /* These cases are easy, the original value is not observed. */
52916: 
52916:         frame.dup();
52916:         // OBJ OBJ
52916: 
52916:         jsop_getprop(atom);
52916:         // OBJ V
52916: 
52916:         frame.push(Int32Tag(amt));
52916:         // OBJ V 1
52916: 
52916:         /* Use sub since it calls ValueToNumber instead of string concat. */
52916:         jsop_binary(JSOP_SUB, stubs::Sub);
52916:         // OBJ V+1
52916: 
52916:         jsop_setprop(atom);
52916:         // V+1
52916: 
52916:         if (pop)
52916:             frame.pop();
52916:     } else {
52916:         /* The pre-value is observed, making this more tricky. */
52916: 
52916:         frame.dup();
52916:         // OBJ OBJ 
52916: 
52916:         jsop_getprop(atom);
52916:         // OBJ V
52916: 
52916:         jsop_pos();
52916:         // OBJ N
52916: 
52916:         frame.dup();
52916:         // OBJ N N
52916: 
52916:         frame.push(Int32Tag(-amt));
52916:         // OBJ N N 1
52916: 
52916:         jsop_binary(JSOP_ADD, stubs::Add);
52916:         // OBJ N N+1
52916: 
52916:         frame.dupAt(-3);
52916:         // OBJ N N+1 OBJ
52916: 
52916:         frame.dupAt(-2);
52916:         // OBJ N N+1 OBJ N+1
52916: 
52916:         jsop_setprop(atom);
52916:         // OBJ N N+1 N+1
52916: 
52916:         frame.popn(2);
52916:         // OBJ N
52916: 
52916:         frame.shimmy(1);
52916:         // N
52916:     }
52916: #else
52746:     prepareStubCall();
52746:     masm.move(ImmPtr(atom), Registers::ArgReg1);
52746:     stubCall(stub, Uses(1), Defs(1));
52746:     frame.pop();
52746:     frame.pushSynced();
52916: #endif
52916: 
52916:     PC += JSOP_PROPINC_LENGTH;
52916:     if (pop)
52916:         PC += JSOP_POP_LENGTH;
52746: }
52746: 
52737: /*
52737:  * This big nasty function emits a fast-path for native iterators, producing
52737:  * a temporary value on the stack for FORLOCAL,ARG,GLOBAL,etc ops to use.
52737:  */
52737: void
52737: mjit::Compiler::iterNext()
52737: {
52737:     FrameEntry *fe = frame.peek(-1);
52737:     RegisterID reg = frame.tempRegForData(fe);
52737: 
52737:     /* Is it worth trying to pin this longer? Prolly not. */
52737:     frame.pinReg(reg);
52737:     RegisterID T1 = frame.allocReg();
52737:     frame.unpinReg(reg);
52737: 
52737:     /* Test clasp */
52737:     masm.loadPtr(Address(reg, offsetof(JSObject, clasp)), T1);
52737:     Jump notFast = masm.branchPtr(Assembler::NotEqual, T1, ImmPtr(&js_IteratorClass.base));
52737:     stubcc.linkExit(notFast);
52737: 
52737:     /* Get private from iter obj. :FIXME: X64 */
52737:     Address privSlot(reg, offsetof(JSObject, fslots) + sizeof(Value) * JSSLOT_PRIVATE);
52737:     masm.loadData32(privSlot, T1);
52737: 
52737:     RegisterID T3 = frame.allocReg();
52973:     RegisterID T4 = frame.allocReg();
52737: 
52737:     /* Test if for-each. */
52737:     masm.load32(Address(T1, offsetof(NativeIterator, flags)), T3);
52737:     masm.and32(Imm32(JSITER_FOREACH), T3);
52973:     notFast = masm.branchTest32(Assembler::NonZero, T3, T3);
52737:     stubcc.linkExit(notFast);
52973: 
52973:     RegisterID T2 = frame.allocReg();
52973: 
52973:     /* Get cursor. */
52973:     masm.loadPtr(Address(T1, offsetof(NativeIterator, props_cursor)), T2);
52973: 
52973:     /* Test if the jsid is a string. */
52973:     masm.loadPtr(T2, T3);
52973:     masm.move(T3, T4);
52973:     masm.andPtr(Imm32(JSID_TYPE_MASK), T4);
52973:     notFast = masm.branchTestPtr(Assembler::NonZero, T4, T4);
52973:     stubcc.linkExit(notFast);
52737: 
52737:     /* It's safe to increase the cursor now. */
52973:     masm.addPtr(Imm32(sizeof(jsid)), T2, T4);
52973:     masm.storePtr(T4, Address(T1, offsetof(NativeIterator, props_cursor)));
52973: 
52973:     frame.freeReg(T4);
52737:     frame.freeReg(T1);
52973:     frame.freeReg(T2);
52737: 
52737:     stubcc.leave();
52737:     stubcc.call(stubs::IterNext);
52737: 
53025:     frame.pushUntypedPayload(JSVAL_TYPE_STRING, T3);
52737: 
52737:     /* Join with the stub call. */
52737:     stubcc.rejoin(1);
52737: }
52737: 
52737: void
52737: mjit::Compiler::iterMore()
52737: {
52737:     FrameEntry *fe= frame.peek(-1);
52737:     RegisterID reg = frame.tempRegForData(fe);
52737: 
52737:     frame.pinReg(reg);
52737:     RegisterID T1 = frame.allocReg();
52737:     frame.unpinReg(reg);
52737: 
52737:     /* Test clasp */
52737:     masm.loadPtr(Address(reg, offsetof(JSObject, clasp)), T1);
52737:     Jump notFast = masm.branchPtr(Assembler::NotEqual, T1, ImmPtr(&js_IteratorClass.base));
52737:     stubcc.linkExit(notFast);
52737: 
52737:     /* Get private from iter obj. :FIXME: X64 */
52737:     Address privSlot(reg, offsetof(JSObject, fslots) + sizeof(Value) * JSSLOT_PRIVATE);
52737:     masm.loadData32(privSlot, T1);
52737: 
52737:     /* Get props_cursor, test */
52737:     RegisterID T2 = frame.allocReg();
52737:     frame.forgetEverything();
52737:     masm.loadPtr(Address(T1, offsetof(NativeIterator, props_cursor)), T2);
52737:     masm.loadPtr(Address(T1, offsetof(NativeIterator, props_end)), T1);
52737:     Jump j = masm.branchPtr(Assembler::LessThan, T2, T1);
52737: 
52737:     jsbytecode *target = &PC[JSOP_MOREITER_LENGTH];
52737:     JSOp next = JSOp(*target);
52737:     JS_ASSERT(next == JSOP_IFNE || next == JSOP_IFNEX);
52737: 
52737:     target += (next == JSOP_IFNE)
52737:               ? GET_JUMP_OFFSET(target)
52737:               : GET_JUMPX_OFFSET(target);
52737:     jumpInScript(j, target);
52737: 
52737:     stubcc.leave();
52737:     stubcc.call(stubs::IterMore);
52737:     j = stubcc.masm.branchTest32(Assembler::NonZero, Registers::ReturnReg, Registers::ReturnReg);
52737:     stubcc.jumpInScript(j, target);
52737: 
52737:     PC += JSOP_MOREITER_LENGTH;
52737:     PC += js_CodeSpec[next].length;
52737: 
52737:     stubcc.rejoin(0);
52737: }
52737: 
52815: void
52815: mjit::Compiler::jsop_eleminc(JSOp op, VoidStub stub)
52815: {
52815:     prepareStubCall();
52815:     stubCall(stub, Uses(2), Defs(1));
52815:     frame.popn(2);
52815:     frame.pushSynced();
52815: }
52815: 
52826: void
52826: mjit::Compiler::jsop_getgname_slow(uint32 index)
52826: {
52826:     prepareStubCall();
52826:     stubCall(stubs::GetGlobalName, Uses(0), Defs(1));
52826:     frame.pushSynced();
52826: }
52826: 
52826: void
52826: mjit::Compiler::jsop_bindgname()
52826: {
52826:     if (script->compileAndGo && globalObj) {
53023:         frame.push(ObjectTag(*globalObj));
52826:         return;
52826:     }
52826: 
52826:     /* :TODO: this is slower than it needs to be. */
52826:     prepareStubCall();
52826:     stubCall(stubs::BindGlobalName, Uses(0), Defs(1));
52826:     frame.takeReg(Registers::ReturnReg);
53025:     frame.pushTypedPayload(JSVAL_TYPE_OBJECT, Registers::ReturnReg);
52826: }
52826: 
52826: void
52826: mjit::Compiler::jsop_getgname(uint32 index)
52826: {
52826: #if ENABLE_MIC
52826:     jsop_bindgname();
52826: 
52826:     FrameEntry *fe = frame.peek(-1);
53025:     JS_ASSERT(fe->isTypeKnown() && fe->getKnownType() == JSVAL_TYPE_OBJECT);
52826: 
52826:     MICGenInfo mic;
52826:     RegisterID objReg;
52826:     Jump shapeGuard;
52826: 
52831:     mic.type = ic::MICInfo::GET;
52826:     mic.entry = masm.label();
52826:     if (fe->isConstant()) {
52826:         JSObject *obj = &fe->getValue().asObject();
52826:         frame.pop();
52826:         JS_ASSERT(obj->isNative());
52826: 
52826:         JSObjectMap *map = obj->map;
52826:         objReg = frame.allocReg();
52826: 
52826:         masm.load32FromImm(&map->shape, objReg);
52826:         shapeGuard = masm.branchPtrWithPatch(Assembler::NotEqual, objReg, mic.shapeVal);
52826:         masm.move(ImmPtr(obj), objReg);
52826:     } else {
52826:         objReg = frame.ownRegForData(fe);
52826:         frame.pop();
52826:         RegisterID reg = frame.allocReg();
52826: 
52826:         masm.loadPtr(Address(objReg, offsetof(JSObject, map)), reg);
52826:         masm.load32(Address(reg, offsetof(JSObjectMap, shape)), reg);
52826:         shapeGuard = masm.branchPtrWithPatch(Assembler::NotEqual, reg, mic.shapeVal);
52826:         frame.freeReg(reg);
52826:     }
52826:     stubcc.linkExit(shapeGuard);
52826: 
52826:     stubcc.leave();
52826:     stubcc.masm.move(Imm32(mics.length()), Registers::ArgReg1);
52826:     mic.stubEntry = stubcc.masm.label();
52826:     mic.call = stubcc.call(ic::GetGlobalName);
52826: 
52826:     /* Garbage value. */
52826:     uint32 slot = 1 << 24;
52826: 
52826:     /*
52826:      * Ensure at least one register is available.
52826:      * This is necessary so the implicit push below does not change the
52826:      * expected instruction ordering. :FIXME: this is stupid
52826:      */
52826:     frame.freeReg(frame.allocReg());
52826: 
52826:     mic.load = masm.label();
52826:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52826:     Address address(objReg, slot);
52826:     frame.freeReg(objReg);
52826:     frame.push(address);
52826: 
52826:     stubcc.rejoin(1);
52826: 
52826:     mics.append(mic);
52826: #else
52826:     jsop_getgname_slow(index);
52826: #endif
52826: }
52826: 
52831: void
52831: mjit::Compiler::jsop_setgname_slow(uint32 index)
52831: {
52831:     JSAtom *atom = script->getAtom(index);
52831:     prepareStubCall();
52831:     masm.move(ImmPtr(atom), Registers::ArgReg1);
52831:     stubCall(stubs::SetGlobalName, Uses(2), Defs(1));
52831:     frame.popn(2);
52831:     frame.pushSynced();
52831: }
52831: 
52831: void
52831: mjit::Compiler::jsop_setgname(uint32 index)
52831: {
52831: #if ENABLE_MIC
52831:     FrameEntry *objFe = frame.peek(-2);
53025:     JS_ASSERT_IF(objFe->isTypeKnown(), objFe->getKnownType() == JSVAL_TYPE_OBJECT);
52831: 
52831:     MICGenInfo mic;
52831:     RegisterID objReg;
52831:     Jump shapeGuard;
52831: 
52831:     mic.type = ic::MICInfo::SET;
52831:     mic.entry = masm.label();
52831:     if (objFe->isConstant()) {
52831:         JSObject *obj = &objFe->getValue().asObject();
52831:         JS_ASSERT(obj->isNative());
52831: 
52831:         JSObjectMap *map = obj->map;
52831:         objReg = frame.allocReg();
52831: 
52831:         masm.load32FromImm(&map->shape, objReg);
52831:         shapeGuard = masm.branchPtrWithPatch(Assembler::NotEqual, objReg, mic.shapeVal);
52831:         masm.move(ImmPtr(obj), objReg);
52831:     } else {
52831:         objReg = frame.tempRegForData(objFe);
52831:         frame.pinReg(objReg);
52831:         RegisterID reg = frame.allocReg();
52831: 
52831:         masm.loadPtr(Address(objReg, offsetof(JSObject, map)), reg);
52831:         masm.load32(Address(reg, offsetof(JSObjectMap, shape)), reg);
52831:         shapeGuard = masm.branchPtrWithPatch(Assembler::NotEqual, reg, mic.shapeVal);
52831:         frame.freeReg(reg);
52831:     }
52831:     stubcc.linkExit(shapeGuard);
52831: 
52831:     stubcc.leave();
52831:     stubcc.masm.move(Imm32(mics.length()), Registers::ArgReg1);
52831:     mic.stubEntry = stubcc.masm.label();
52831:     mic.call = stubcc.call(ic::SetGlobalName);
52831: 
52831:     /* Garbage value. */
52831:     uint32 slot = 1 << 24;
52831: 
52831:     /* Get both type and reg into registers. */
52831:     FrameEntry *fe = frame.peek(-1);
52831: 
52831:     Value v;
52831:     RegisterID typeReg = Registers::ReturnReg;
52831:     RegisterID dataReg = Registers::ReturnReg;
53025:     JSValueType typeTag = JSVAL_TYPE_INT32;
52831: 
52831:     mic.typeConst = fe->isTypeKnown();
52831:     mic.dataConst = fe->isConstant();
52831:     mic.dataWrite = !mic.dataConst || !fe->getValue().isUndefined();
52831: 
52831:     if (!mic.dataConst) {
52831:         dataReg = frame.ownRegForData(fe);
52831:         if (!mic.typeConst)
52831:             typeReg = frame.ownRegForType(fe);
52831:         else
53025:             typeTag = fe->getKnownType();
52831:     } else {
52831:         v = fe->getValue();
52831:     }
52831: 
52831:     mic.load = masm.label();
52831:     masm.loadPtr(Address(objReg, offsetof(JSObject, dslots)), objReg);
52831:     Address address(objReg, slot);
52831: 
52831:     if (mic.dataConst) {
52831:         masm.storeValue(v, address);
52831:     } else {
52831:         if (mic.typeConst)
53025:             masm.storeTypeTag(ImmType(typeTag), address);
52831:         else
52831:             masm.storeTypeTag(typeReg, address);
52831:         masm.storeData32(dataReg, address);
52831:     }
52831: 
52831:     if (objFe->isConstant())
52831:         frame.freeReg(objReg);
52831:     frame.popn(2);
52831:     if (mic.dataConst) {
52831:         frame.push(v);
52831:     } else {
52831:         if (mic.typeConst)
52831:             frame.pushTypedPayload(typeTag, dataReg);
52831:         else
52831:             frame.pushRegs(typeReg, dataReg);
52831:     }
52831: 
52831:     stubcc.rejoin(1);
52831: 
52831:     mics.append(mic);
52831: #else
52831:     jsop_setgname_slow(index);
52831: #endif
52831: }
52831: 
52838: void
52838: mjit::Compiler::jsop_setelem_slow()
52838: {
52838:     prepareStubCall();
52838:     stubCall(stubs::SetElem, Uses(3), Defs(1));
52838:     frame.popn(3);
52838:     frame.pushSynced();
52838: }
52838: 
52843: void
52843: mjit::Compiler::jsop_getelem_slow()
52843: {
52843:     prepareStubCall();
52843:     stubCall(stubs::GetElem, Uses(2), Defs(1));
52843:     frame.popn(2);
52843:     frame.pushSynced();
52843: }
52843: 
52874: void
52874: mjit::Compiler::jsop_unbrand()
52874: {
52874:     prepareStubCall();
52874:     stubCall(stubs::Unbrand, Uses(0), Defs(0));
52874: }
52874: 
52894: void
52894: mjit::Compiler::jsop_instanceof()
52894: {
52894:     FrameEntry *rhs = frame.peek(-1);
52894: 
52894:     /*
52894:      * Optimize only function objects, as these will have js_FunctionClass and
52894:      * thus have fun_instanceOf, which we're inlining.
52894:      */
52894: 
53025:     if (rhs->isTypeKnown() && rhs->getKnownType() != JSVAL_TYPE_OBJECT) {
52894:         prepareStubCall();
52894:         stubCall(stubs::InstanceOf, Uses(2), Defs(1));
52894:         frame.popn(2);
52894:         frame.takeReg(Registers::ReturnReg);
53025:         frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, Registers::ReturnReg);
52894:         return;
52894:     }
52894: 
52911:     Jump firstSlow;
52911:     bool typeKnown = rhs->isTypeKnown();
52911:     if (!typeKnown) {
53023:         Jump j = frame.testObject(Assembler::NotEqual, rhs);
53023:         stubcc.linkExit(j);
53023:         RegisterID reg = frame.tempRegForData(rhs);
53023:         j = masm.testFunction(Assembler::NotEqual, reg);
52894:         stubcc.linkExit(j);
52894:         stubcc.leave();
52894:         stubcc.call(stubs::InstanceOf);
52911:         firstSlow = stubcc.masm.jump();
52911:     }
52911: 
52911:     /* This is sadly necessary because the error case needs the object. */
52894:     frame.dup();
52894: 
52894:     jsop_getprop(cx->runtime->atomState.classPrototypeAtom, false);
52894: 
52911:     /* Primitive prototypes are invalid. */
52911:     rhs = frame.peek(-1);
52911:     Jump j = frame.testPrimitive(Assembler::Equal, rhs);
52911:     stubcc.linkExit(j);
52911: 
52911:     /* Allocate registers up front, because of branchiness. */
52911:     FrameEntry *lhs = frame.peek(-3);
52911:     RegisterID obj = frame.copyDataIntoReg(lhs);
52911:     RegisterID proto = frame.copyDataIntoReg(rhs);
52911:     RegisterID temp = frame.allocReg();
52911: 
52911:     Jump isFalse = frame.testPrimitive(Assembler::Equal, lhs);
52911: 
52911:     /* Quick test to avoid wrapped objects. */
52911:     masm.loadPtr(Address(obj, offsetof(JSObject, clasp)), temp);
52911:     masm.load32(Address(temp, offsetof(JSClass, flags)), temp);
52911:     masm.and32(Imm32(JSCLASS_IS_EXTENDED), temp);
52911:     j = masm.branchTest32(Assembler::NonZero, temp, temp);
52911:     stubcc.linkExit(j);
52911: 
52911:     Address protoAddr(obj, offsetof(JSObject, fslots) + JSSLOT_PROTO * sizeof(Value));
52911:     Label loop = masm.label();
52911: 
52911:     /* Walk prototype chain, break out on NULL or hit. */
52911:     masm.loadData32(protoAddr, obj);
52911:     Jump isFalse2 = masm.branchTestPtr(Assembler::Zero, obj, obj);
52911:     Jump isTrue = masm.branchPtr(Assembler::NotEqual, obj, proto);
52911:     isTrue.linkTo(loop, &masm);
52911:     masm.move(Imm32(1), temp);
52911:     isTrue = masm.jump();
52911: 
52911:     isFalse.linkTo(masm.label(), &masm);
52911:     isFalse2.linkTo(masm.label(), &masm);
52911:     masm.move(Imm32(0), temp);
52911:     isTrue.linkTo(masm.label(), &masm);
52911: 
52911:     frame.freeReg(proto);
52911:     frame.freeReg(obj);
52911: 
52911:     stubcc.leave();
52911:     stubcc.call(stubs::FastInstanceOf);
52911: 
52894:     frame.popn(3);
53025:     frame.pushTypedPayload(JSVAL_TYPE_BOOLEAN, temp);
52911: 
52911:     firstSlow.linkTo(stubcc.masm.label(), &stubcc.masm);
52894:     stubcc.rejoin(1);
52894: }
52894: 
