32607: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
32607:  *
32607:  * ***** BEGIN LICENSE BLOCK *****
32607:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32607:  *
32607:  * The contents of this file are subject to the Mozilla Public License Version
32607:  * 1.1 (the "License"); you may not use this file except in compliance with
32607:  * the License. You may obtain a copy of the License at
32607:  * http://www.mozilla.org/MPL/
32607:  *
32607:  * Software distributed under the License is distributed on an "AS IS" basis,
32607:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32607:  * for the specific language governing rights and limitations under the
32607:  * License.
32607:  *
32607:  * The Original Code is Mozilla Communicator client code, released
32607:  * March 31, 1998.
32607:  *
32607:  * The Initial Developer of the Original Code is
32607:  * Netscape Communications Corporation.
32607:  * Portions created by the Initial Developer are Copyright (C) 1998
32607:  * the Initial Developer. All Rights Reserved.
32607:  *
32607:  * Contributor(s):
32607:  *
32607:  * Alternatively, the contents of this file may be used under the terms of
32607:  * either of the GNU General Public License Version 2 or later (the "GPL"),
32607:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32607:  * in which case the provisions of the GPL or the LGPL are applicable instead
32607:  * of those above. If you wish to allow use of your version of this file only
32607:  * under the terms of either the GPL or the LGPL, and not to allow others to
32607:  * use your version of this file under the terms of the MPL, indicate your
32607:  * decision by deleting the provisions above and replace them with the notice
32607:  * and other provisions required by the GPL or the LGPL. If you do not delete
32607:  * the provisions above, a recipient may use your version of this file under
32607:  * the terms of any one of the MPL, the GPL or the LGPL.
32607:  *
32607:  * ***** END LICENSE BLOCK ***** */
32607: 
34349: #ifndef jsstrinlines_h___
34349: #define jsstrinlines_h___
32607: 
32607: #include "jsstr.h"
32607: 
32608: inline JSString *
32674: JSString::unitString(jschar c)
32608: {
32607:     JS_ASSERT(c < UNIT_STRING_LIMIT);
54716:     return const_cast<JSString *>(&unitStringTable[c]);
32607: }
32607: 
32608: inline JSString *
32608: JSString::getUnitString(JSContext *cx, JSString *str, size_t index)
32608: {
32607:     JS_ASSERT(index < str->length());
32607:     jschar c = str->chars()[index];
32674:     if (c < UNIT_STRING_LIMIT)
32674:         return unitString(c);
32607:     return js_NewDependentString(cx, str, index, 1);
32607: }
32607: 
32686: inline JSString *
48610: JSString::length2String(jschar c1, jschar c2)
48610: {
48610:     JS_ASSERT(fitsInSmallChar(c1));
48610:     JS_ASSERT(fitsInSmallChar(c2));
54716:     return const_cast<JSString *>
54716:            (&length2StringTable[(((size_t)toSmallChar[c1]) << 6) + toSmallChar[c2]]);
48610: }
48610: 
48610: inline JSString *
32686: JSString::intString(jsint i)
32686: {
32686:     jsuint u = jsuint(i);
32686:     JS_ASSERT(u < INT_STRING_LIMIT);
54716:     return const_cast<JSString *>(JSString::intStringTable[u]);
32686: }
32607: 
54707: inline void
54707: JSString::finalize(JSContext *cx, unsigned thingKind) {
54707:     if (JS_LIKELY(thingKind == js::gc::FINALIZE_STRING)) {
54707:         JS_ASSERT(!JSString::isStatic(this));
54707:         JS_RUNTIME_UNMETER(cx->runtime, liveStrings);
54707:         if (isDependent()) {
54707:             JS_ASSERT(dependentBase());
54707:             JS_RUNTIME_UNMETER(cx->runtime, liveDependentStrings);
54707:         } else if (isFlat()) {
54707:             /*
54707:              * flatChars for stillborn string is null, but cx->free checks
54707:              * for a null pointer on its own.
54707:              */
54707:             cx->free(flatChars());
54707:         } else if (isTopNode()) {
54707:             cx->free(topNodeBuffer());
54707:         }
54707:     } else {
54707:         unsigned type = thingKind - js::gc::FINALIZE_EXTERNAL_STRING0;
54707:         JS_ASSERT(type < JS_ARRAY_LENGTH(str_finalizers));
54707:         JS_ASSERT(!isStatic(this));
54707:         JS_ASSERT(isFlat());
54707:         JS_RUNTIME_UNMETER(cx->runtime, liveStrings);
54707: 
54707:         /* A stillborn string has null chars. */
54707:         jschar *chars = flatChars();
54707:         if (!chars)
54707:             return;
54707:         JSStringFinalizeOp finalizer = str_finalizers[type];
54707:         if (finalizer)
54707:             finalizer(cx, this);
54707:     }
54707: }
54707: 
54707: inline void
54707: JSShortString::finalize(JSContext *cx, unsigned thingKind)
54707: {
54707:     JS_ASSERT(js::gc::FINALIZE_SHORT_STRING == thingKind);
54707:     JS_ASSERT(!JSString::isStatic(header()));
54707:     JS_ASSERT(header()->isFlat());
54707:     JS_RUNTIME_UNMETER(cx->runtime, liveStrings);
54707: }
54707: 
48536: inline
51460: JSRopeBuilder::JSRopeBuilder(JSContext *cx)
51460:   : cx(cx), mStr(cx->runtime->emptyString) {}
48536: 
56388: inline void
56388: JSString::checkCompartment(JSContext *cx, int addr)
56388: {
56388:     if (isRope() && asCell()->compartment() != cx->compartment)
56388:         JS_CRASH(addr);
56388: }
56388: 
34349: #endif /* jsstrinlines_h___ */
