35778: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35778:  * vim: sw=4 ts=4 et :
35778:  */
35778: /* ***** BEGIN LICENSE BLOCK *****
35778:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35778:  *
35778:  * The contents of this file are subject to the Mozilla Public License Version
35778:  * 1.1 (the "License"); you may not use this file except in compliance with
35778:  * the License. You may obtain a copy of the License at
35778:  * http://www.mozilla.org/MPL/
35778:  *
35778:  * Software distributed under the License is distributed on an "AS IS" basis,
35778:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35778:  * for the specific language governing rights and limitations under the
35778:  * License.
35778:  *
35778:  * The Original Code is Mozilla Plugin App.
35778:  *
35778:  * The Initial Developer of the Original Code is
35778:  *   Chris Jones <jones.chris.g@gmail.com>
35778:  * Portions created by the Initial Developer are Copyright (C) 2009
35778:  * the Initial Developer. All Rights Reserved.
35778:  *
35778:  * Contributor(s):
35778:  *
35778:  * Alternatively, the contents of this file may be used under the terms of
35778:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35778:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35778:  * in which case the provisions of the GPL or the LGPL are applicable instead
35778:  * of those above. If you wish to allow use of your version of this file only
35778:  * under the terms of either the GPL or the LGPL, and not to allow others to
35778:  * use your version of this file under the terms of the MPL, indicate your
35778:  * decision by deleting the provisions above and replace them with the notice
35778:  * and other provisions required by the GPL or the LGPL. If you do not delete
35778:  * the provisions above, a recipient may use your version of this file under
35778:  * the terms of any one of the MPL, the GPL or the LGPL.
35778:  *
35778:  * ***** END LICENSE BLOCK ***** */
35778: 
35778: #include "mozilla/ipc/SyncChannel.h"
35778: 
35778: #include "nsDebug.h"
36081: #include "nsTraceRefcnt.h"
35778: 
35778: using mozilla::MutexAutoLock;
35778: 
35778: template<>
35778: struct RunnableMethodTraits<mozilla::ipc::SyncChannel>
35778: {
35778:     static void RetainCallee(mozilla::ipc::SyncChannel* obj) { }
35778:     static void ReleaseCallee(mozilla::ipc::SyncChannel* obj) { }
35778: };
35778: 
35778: namespace mozilla {
35778: namespace ipc {
35778: 
38106: const int32 SyncChannel::kNoTimeout = PR_INT32_MIN;
38106: 
36078: SyncChannel::SyncChannel(SyncListener* aListener)
36078:   : AsyncChannel(aListener),
36078:     mPendingReply(0),
37473:     mProcessingSyncMessage(false),
38106:     mNextSeqno(0),
38106:     mTimeoutMs(kNoTimeout)
36078: {
36078:   MOZ_COUNT_CTOR(SyncChannel);
36078: }
36078: 
36078: SyncChannel::~SyncChannel()
36078: {
36078:     MOZ_COUNT_DTOR(SyncChannel);
36078: }
36078: 
36093: // static
36093: bool SyncChannel::sIsPumpingMessages = false;
36093: 
35778: bool
38106: SyncChannel::EventOccurred()
38106: {
38106:     AssertWorkerThread();
38106:     mMutex.AssertCurrentThreadOwns();
38106:     NS_ABORT_IF_FALSE(AwaitingSyncReply(), "not in wait loop");
38106: 
38106:     return (!Connected() || 0 != mRecvd.type());
38106: }
38106: 
38106: bool
35778: SyncChannel::Send(Message* msg, Message* reply)
35778: {
35971:     AssertWorkerThread();
36140:     mMutex.AssertNotCurrentThreadOwns();
35859:     NS_ABORT_IF_FALSE(!ProcessingSyncMessage(),
35859:                       "violation of sync handler invariant");
35940:     NS_ABORT_IF_FALSE(msg->is_sync(), "can only Send() sync messages here");
35940: 
37473:     msg->set_seqno(NextSeqno());
37473: 
35974:     MutexAutoLock lock(mMutex);
35974: 
36015:     if (!Connected()) {
36015:         ReportConnectionError("SyncChannel");
35940:         return false;
36015:     }
35778: 
35778:     mPendingReply = msg->type() + 1;
37473:     int32 msgSeqno = msg->seqno();
35977:     mIOLoop->PostTask(
35977:         FROM_HERE,
35977:         NewRunnableMethod(this, &SyncChannel::OnSend, msg));
35778: 
38106:     while (1) {
38106:         bool maybeTimedOut = !SyncChannel::WaitForNotify();
38106: 
38106:         if (EventOccurred())
38106:             break;
38106: 
38110:         if (maybeTimedOut && !ShouldContinueFromTimeout())
38106:             return false;
38106:     }
35778: 
36015:     if (!Connected()) {
36015:         ReportConnectionError("SyncChannel");
35940:         return false;
36015:     }
35940: 
35859:     // we just received a synchronous message from the other side.
35859:     // If it's not the reply we were awaiting, there's a serious
35859:     // error: either a mistimed/malformed message or a sync in-message
35859:     // that raced with our sync out-message.
35859:     // (NB: IPDL prevents the latter from occuring in actor code)
35859: 
35859:     // FIXME/cjones: real error handling
35912:     NS_ABORT_IF_FALSE(mRecvd.is_sync() && mRecvd.is_reply() &&
37473:                       (mRecvd.is_reply_error() ||
37473:                        (mPendingReply == mRecvd.type() &&
37473:                         msgSeqno == mRecvd.seqno())),
35859:                       "unexpected sync message");
35859: 
35778:     mPendingReply = 0;
35778:     *reply = mRecvd;
37387:     mRecvd = Message();
35778: 
35778:     return true;
35778: }
35778: 
35778: void
35778: SyncChannel::OnDispatchMessage(const Message& msg)
35778: {
35971:     AssertWorkerThread();
35859:     NS_ABORT_IF_FALSE(msg.is_sync(), "only sync messages here");
35899:     NS_ABORT_IF_FALSE(!msg.is_reply(), "wasn't awaiting reply");
35778: 
35922:     Message* reply = 0;
35859: 
35859:     mProcessingSyncMessage = true;
35859:     Result rv =
35859:         static_cast<SyncListener*>(mListener)->OnMessageReceived(msg, reply);
35859:     mProcessingSyncMessage = false;
35859: 
36015:     if (!MaybeHandleError(rv, "SyncChannel")) {
35778:         // FIXME/cjones: error handling; OnError()?
35912:         delete reply;
35912:         reply = new Message();
35912:         reply->set_sync();
35912:         reply->set_reply();
35912:         reply->set_reply_error();
35778:     }
35912: 
37473:     reply->set_seqno(msg.seqno());
37473: 
38124:     {
38124:         MutexAutoLock lock(mMutex);
38124:         if (ChannelConnected == mChannelState)
35977:             mIOLoop->PostTask(
35977:                 FROM_HERE,
35977:                 NewRunnableMethod(this, &SyncChannel::OnSend, reply));
35778:     }
38124: }
35778: 
35778: //
35778: // The methods below run in the context of the IO thread, and can proxy
35778: // back to the methods above
35778: //
35778: 
35778: void
35778: SyncChannel::OnMessageReceived(const Message& msg)
35778: {
35971:     AssertIOThread();
35859:     if (!msg.is_sync()) {
35859:         return AsyncChannel::OnMessageReceived(msg);
35859:     }
35778: 
35859:     MutexAutoLock lock(mMutex);
35859: 
35859:     if (!AwaitingSyncReply()) {
35778:         // wake up the worker, there's work to do
35778:         mWorkerLoop->PostTask(
35778:             FROM_HERE,
35778:             NewRunnableMethod(this, &SyncChannel::OnDispatchMessage, msg));
35778:     }
35778:     else {
35859:         // let the worker know a new sync message has arrived
35778:         mRecvd = msg;
35977:         NotifyWorkerThread();
35778:     }
35778: }
35778: 
35778: void
35940: SyncChannel::OnChannelError()
35940: {
35971:     AssertIOThread();
36140: 
38316:     MutexAutoLock lock(mMutex);
36140: 
38316:     // NB: this can race with the `Goodbye' event being processed by
38316:     // the worker thread
38316:     if (ChannelClosing != mChannelState)
38316:         mChannelState = ChannelError;
38316: 
36140:     if (AwaitingSyncReply())
35977:         NotifyWorkerThread();
38316: 
38316:     AsyncChannel::OnChannelError();
35940: }
35940: 
35977: //
35977: // Synchronization between worker and IO threads
35977: //
35977: 
38106: namespace {
38106: 
38106: bool
38106: IsTimeoutExpired(PRIntervalTime aStart, PRIntervalTime aTimeout)
38106: {
38106:     return (aTimeout != PR_INTERVAL_NO_TIMEOUT) &&
38106:         (aTimeout <= (PR_IntervalNow() - aStart));
38106: }
38106: 
38106: } // namespace <anon>
38106: 
38106: bool
38106: SyncChannel::ShouldContinueFromTimeout()
38106: {
38106:     AssertWorkerThread();
38106:     mMutex.AssertCurrentThreadOwns();
38106: 
38107:     bool cont;
38107:     {
38107:         MutexAutoUnlock unlock(mMutex);
38107:         cont = static_cast<SyncListener*>(mListener)->OnReplyTimeout();
38107:     }
38106: 
38106:     if (!cont) {
38106:         // NB: there's a sublety here.  If parents were allowed to
38106:         // send sync messages to children, then it would be possible
38106:         // for this synchronous close-on-timeout to race with async
38106:         // |OnMessageReceived| tasks arriving from the child, posted
38106:         // to the worker thread's event loop.  This would complicate
38106:         // cleanup of the *Channel.  But since IPDL forbids this (and
38106:         // since it doesn't support children timing out on parents),
38106:         // the parent can only block on RPC messages to the child, and
38106:         // in that case arriving async messages are enqueued to the
38106:         // RPC channel's special queue.  They're then ignored because
38106:         // the channel state changes to ChannelTimeout
38106:         // (i.e. !Connected).
38106:         SynchronouslyClose();
38106:         mChannelState = ChannelTimeout;
38106:     }
38106:         
38106:     return cont;
38106: }
38106: 
36093: // Windows versions of the following two functions live in
36093: // WindowsMessageLoop.cpp.
36056: 
36093: #ifndef OS_WIN
36056: 
38106: bool
35977: SyncChannel::WaitForNotify()
35778: {
38106:     PRIntervalTime timeout = (kNoTimeout == mTimeoutMs) ?
38106:                              PR_INTERVAL_NO_TIMEOUT :
38106:                              PR_MillisecondsToInterval(mTimeoutMs);
38106:     // XXX could optimize away this syscall for "no timeout" case if desired
38106:     PRIntervalTime waitStart = PR_IntervalNow();
38106: 
38106:     mCvar.Wait(timeout);
38106: 
38106:     // if the timeout didn't expire, we know we received an event.
38106:     // The converse is not true.
38106:     return !IsTimeoutExpired(waitStart, timeout);
35977: }
35977: 
35977: void
35977: SyncChannel::NotifyWorkerThread()
35977: {
35977:     mCvar.Notify();
35778: }
35778: 
36093: #endif  // ifndef OS_WIN
36056: 
35778: 
35778: } // namespace ipc
35778: } // namespace mozilla
