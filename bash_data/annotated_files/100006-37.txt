 77659: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 52557:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef jsscript_h___
     1: #define jsscript_h___
     1: /*
     1:  * JS script descriptor.
     1:  */
     1: #include "jsatom.h"
     1: #include "jsprvtd.h"
 25215: #include "jsdbgapi.h"
 53391: #include "jsclist.h"
 77343: #include "jsinfer.h"
 89372: #include "jsopcode.h"
 86437: #include "jsscope.h"
     1: 
 82129: #include "gc/Barrier.h"
 82129: 
     1: /*
 17215:  * Type of try note associated with each catch or finally block, and also with
 17215:  * for-in loops.
  1825:  */
  1825: typedef enum JSTryNoteKind {
 20420:     JSTRY_CATCH,
 20420:     JSTRY_FINALLY,
 20420:     JSTRY_ITER
  1825: } JSTryNoteKind;
  1825: 
  1825: /*
  1825:  * Exception handling record.
     1:  */
     1: struct JSTryNote {
 84755:     uint8_t         kind;       /* one of JSTryNoteKind */
 84755:     uint8_t         padding;    /* explicit padding on uint16_t boundary */
 84755:     uint16_t        stackDepth; /* stack depth upon exception handler entry */
 84755:     uint32_t        start;      /* start of the try statement or for-in loop
  3025:                                    relative to script->main */
 84755:     uint32_t        length;     /* length of the try statement or for-in loop */
     1: };
     1: 
 97362: namespace js {
 97362: 
 97362: struct ConstArray {
 97362:     js::HeapValue   *vector;    /* array of indexed constant values */
 97362:     uint32_t        length;
 97362: };
 97362: 
 97362: struct ObjectArray {
 97362:     js::HeapPtrObject *vector;  /* array of indexed objects */
 97362:     uint32_t        length;     /* count of indexed objects */
 97362: };
 97362: 
 97362: struct TryNoteArray {
  3235:     JSTryNote       *vector;    /* array of indexed try notes */
 84755:     uint32_t        length;     /* count of indexed try notes */
 97362: };
 52555: 
 94572: struct ClosedSlotArray {
 94572:     uint32_t        *vector;    /* array of closed slots */
 94572:     uint32_t        length;     /* count of closed slots */
 94572: };
 94572: 
 59987: struct Shape;
 59968: 
 93245: enum BindingKind { NONE, ARGUMENT, VARIABLE, CONSTANT };
 59968: 
 97297: struct BindingName {
 97297:     JSAtom *maybeAtom;
 97297:     BindingKind kind;
 97297: };
 97297: 
 97297: typedef Vector<BindingName, 32> BindingNames;
 97297: 
 59968: /*
 93245:  * Formal parameters and local variables are stored in a shape tree
 59968:  * path encapsulated within this class.  This class represents bindings for
 59968:  * both function and top-level scripts (the latter is needed to track names in
 59968:  * strict mode eval code, to give such code its own lexical environment).
 59968:  */
 93245: class Bindings
 93245: {
 82129:     HeapPtr<Shape> lastBinding;
 84755:     uint16_t nargs;
 84755:     uint16_t nvars;
 89745:     bool     hasDup_:1;     // true if there are duplicate argument names
 59968: 
 89745:     inline Shape *initialShape(JSContext *cx) const;
 59968:   public:
 82129:     inline Bindings(JSContext *cx);
 59968: 
 59968:     /*
 59968:      * Transfers ownership of bindings data from bindings into this fresh
 59968:      * Bindings instance. Once such a transfer occurs, the old bindings must
 59968:      * not be used again.
 59968:      */
 59968:     inline void transfer(JSContext *cx, Bindings *bindings);
 59968: 
 59968:     /*
 59968:      * Clones bindings data from bindings, which must be immutable, into this
 59968:      * fresh Bindings instance. A Bindings instance may be cloned multiple
 59968:      * times.
 59968:      */
 59968:     inline void clone(JSContext *cx, Bindings *bindings);
 59968: 
 95100:     uint16_t numArgs() const { return nargs; }
 95100:     uint16_t numVars() const { return nvars; }
 95100:     unsigned count() const { return nargs + nvars; }
 59968: 
 95101:     /*
 95101:      * These functions map between argument/var indices [0, nargs/nvars) and
 95101:      * and Bindings indices [0, nargs + nvars).
 95101:      */
100006:     bool bindingIsArg(uint16_t i) const { return i < nargs; }
100006:     bool bindingIsLocal(uint16_t i) const { return i >= nargs; }
100006:     uint16_t argToBinding(uint16_t i) { JS_ASSERT(i < nargs); return i; }
100006:     uint16_t localToBinding(uint16_t i) { return i + nargs; }
100006:     uint16_t bindingToArg(uint16_t i) { JS_ASSERT(bindingIsArg(i)); return i; }
100006:     uint16_t bindingToLocal(uint16_t i) { JS_ASSERT(bindingIsLocal(i)); return i - nargs; }
 95101: 
 77343:     /* Ensure these bindings have a shape lineage. */
 77343:     inline bool ensureShape(JSContext *cx);
 77343: 
 89745:     /* Return the shape lineage generated for these bindings. */
 86437:     inline Shape *lastShape() const;
 59968: 
 89745:     /*
 89745:      * Return the shape to use to create a call object for these bindings.
 89745:      * The result is guaranteed not to have duplicate property names.
 89745:      */
 89745:     Shape *callObjectShape(JSContext *cx) const;
 89745: 
 83221:     /* See Scope::extensibleParents */
 83221:     inline bool extensibleParents();
 83221:     bool setExtensibleParents(JSContext *cx);
 83221: 
 83245:     bool setParent(JSContext *cx, JSObject *obj);
 83245: 
 59974:     enum {
 93245:         /* A script may have no more than this many arguments or variables. */
 59974:         BINDING_COUNT_LIMIT = 0xFFFF
 59974:     };
 59974: 
 59968:     /*
 59968:      * Add a local binding for the given name, of the given type, for the code
 59968:      * being compiled.  If fun is non-null, this binding set is being created
 59968:      * for that function, so adjust corresponding metadata in that function
 59968:      * while adding.  Otherwise this set must correspond to a top-level script.
 59968:      *
 59968:      * A binding may be added twice with different kinds; the last one for a
 59968:      * given name prevails.  (We preserve both bindings for the decompiler,
 59968:      * which must deal with such cases.)  Pass null for name when indicating a
 59968:      * destructuring argument.  Return true on success.
 59968:      *
 59968:      * The parser builds shape paths for functions, usable by Call objects at
 60254:      * runtime, by calling an "add" method. All ARGUMENT bindings must be added
 93245:      * before before any VARIABLE or CONSTANT bindings.
 59968:      */
 95355:     bool add(JSContext *cx, HandleAtom name, BindingKind kind);
 59968: 
 59968:     /* Convenience specializations. */
 95355:     bool addVariable(JSContext *cx, HandleAtom name) {
 59968:         return add(cx, name, VARIABLE);
 59968:     }
 95355:     bool addConstant(JSContext *cx, HandleAtom name) {
 59968:         return add(cx, name, CONSTANT);
 59968:     }
 95355:     bool addArgument(JSContext *cx, HandleAtom name, uint16_t *slotp) {
 59968:         JS_ASSERT(name != NULL); /* not destructuring */
 59968:         *slotp = nargs;
 59968:         return add(cx, name, ARGUMENT);
 59968:     }
 84755:     bool addDestructuring(JSContext *cx, uint16_t *slotp) {
 59968:         *slotp = nargs;
 99421:         return add(cx, RootedAtom(cx), ARGUMENT);
 59968:     }
 59968: 
 89745:     void noteDup() { hasDup_ = true; }
 89745:     bool hasDup() const { return hasDup_; }
 89745: 
 59968:     /*
 59968:      * Look up an argument or variable name, returning its kind when found or
 59968:      * NONE when no such name exists. When indexp is not null and the name
 59968:      * exists, *indexp will receive the index of the corresponding argument or
 59968:      * variable.
 59968:      */
 91237:     BindingKind lookup(JSContext *cx, JSAtom *name, unsigned *indexp) const;
 59968: 
 59968:     /* Convenience method to check for any binding for a name. */
 59992:     bool hasBinding(JSContext *cx, JSAtom *name) const {
 59992:         return lookup(cx, name, NULL) != NONE;
 59968:     }
 59968: 
 59968:     /*
 73058:      * This method returns the local variable, argument, etc. names used by a
 95101:      * script.  This function must be called only when count() > 0.
 59968:      *
 73058:      * The elements of the vector with index less than nargs correspond to the
 73058:      * the names of arguments. An index >= nargs addresses a var binding.
 73058:      * The name at an element will be null when the element is for an argument
 59968:      * corresponding to a destructuring pattern.
 59968:      */
 97297:     bool getLocalNameArray(JSContext *cx, BindingNames *namesp);
 59968: 
 59968:     /*
 59968:      * Protect stored bindings from mutation.  Subsequent attempts to add
 59968:      * bindings will copy the existing bindings before adding to them, allowing
 59968:      * the original bindings to be safely shared.
 59968:      */
 59968:     void makeImmutable();
 59968: 
 59968:     /*
 59968:      * These methods provide direct access to the shape path normally
 59968:      * encapsulated by js::Bindings. These methods may be used to make a
 59968:      * Shape::Range for iterating over the relevant shapes from youngest to
 59968:      * oldest (i.e., last or right-most to first or left-most in source order).
 59968:      *
 59968:      * Sometimes iteration order must be from oldest to youngest, however. For
 73058:      * such cases, use js::Bindings::getLocalNameArray.
 59968:      */
 59968:     const js::Shape *lastArgument() const;
 59968:     const js::Shape *lastVariable() const;
 59968: 
 59968:     void trace(JSTracer *trc);
 86437: 
 99364:     class AutoRooter : private AutoGCRooter
 99364:     {
 99364:       public:
 99364:         explicit AutoRooter(JSContext *cx, Bindings *bindings_
 99364:                             JS_GUARD_OBJECT_NOTIFIER_PARAM)
 99364:           : AutoGCRooter(cx, BINDINGS), bindings(bindings_), skip(cx, bindings_)
 99364:         {
 99364:             JS_GUARD_OBJECT_NOTIFIER_INIT;
 99364:         }
 99364: 
 99364:         friend void AutoGCRooter::trace(JSTracer *trc);
 99364:         void trace(JSTracer *trc);
 99364: 
 99364:       private:
 99364:         Bindings *bindings;
 99364:         SkipRoot skip;
 99364:         JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 86437:     };
 59968: };
 59968: 
 52555: } /* namespace js */
 52555: 
  3235: #define JS_OBJECT_ARRAY_SIZE(length)                                          \
 97362:     (offsetof(ObjectArray, vector) + sizeof(JSObject *) * (length))
  3235: 
 52557: #ifdef JS_METHODJIT
 52557: namespace JSC {
 52557:     class ExecutablePool;
 52557: }
 55503: 
 94809: namespace js {
 94809: namespace mjit {
 94809:     struct JITScript;
 94809:     class CallCompiler;
 94809: }
 94809: }
 55503: 
 77343: #endif
 53498: 
 82134: namespace js {
 52557: 
 82134: namespace analyze { class ScriptAnalysis; }
 82134: 
 94574: class ScriptCounts
 82134: {
 82134:     friend struct ::JSScript;
 94574:     friend struct ScriptAndCounts;
 94574:     /*
 94574:      * This points to a single block that holds an array of PCCounts followed
 94574:      * by an array of doubles.  Each element in the PCCounts array has a
 94574:      * pointer into the array of doubles.
 94574:      */
 94574:     PCCounts *pcCountsVector;
 71699: 
 71699:  public:
 95113:     ScriptCounts() : pcCountsVector(NULL) { }
 71699: 
 94959:     inline void destroy(FreeOp *fop);
 84803: 
 95113:     void set(js::ScriptCounts counts) {
 95113:         pcCountsVector = counts.pcCountsVector;
 71699:     }
 82134: };
 71699: 
 95113: typedef HashMap<JSScript *,
 95113:                 ScriptCounts,
 95113:                 DefaultHasher<JSScript *>,
 95113:                 SystemAllocPolicy> ScriptCountsMap;
 95113: 
 95139: typedef HashMap<JSScript *,
 95139:                 jschar *,
 95139:                 DefaultHasher<JSScript *>,
 95139:                 SystemAllocPolicy> SourceMapMap;
 95139: 
 84195: class DebugScript
 84195: {
 84195:     friend struct ::JSScript;
 84195: 
 84195:     /*
 84195:      * When non-zero, compile script in single-step mode. The top bit is set and
 84195:      * cleared by setStepMode, as used by JSD. The lower bits are a count,
 84195:      * adjusted by changeStepModeCount, used by the Debugger object. Only
 84195:      * when the bit is clear and the count is zero may we compile the script
 84195:      * without single-step support.
 84195:      */
 84755:     uint32_t        stepMode;
 84195: 
 84195:     /* Number of breakpoint sites at opcodes in the script. */
 84755:     uint32_t        numSites;
 84195: 
 84195:     /*
 84195:      * Array with all breakpoints installed at opcodes in the script, indexed
 84195:      * by the offset of the opcode into the script.
 84195:      */
 84195:     BreakpointSite  *breakpoints[1];
 84195: };
 84195: 
 95151: typedef HashMap<JSScript *,
 95151:                 DebugScript *,
 95151:                 DefaultHasher<JSScript *>,
 95151:                 SystemAllocPolicy> DebugScriptMap;
 95151: 
 82134: } /* namespace js */
 71699: 
 93250: struct JSScript : public js::gc::Cell
 93250: {
 94571:   private:
 94571:     static const uint32_t stepFlagMask = 0x80000000U;
 94571:     static const uint32_t stepCountMask = 0x7fffffffU;
 94571: 
 94809:   public:
 95024: #ifdef JS_METHODJIT
 94809:     // This type wraps JITScript.  It has three possible states.
 94809:     // - "Empty": no compilation has been attempted and there is no JITScript.
 94809:     // - "Unjittable": compilation failed and there is no JITScript.
 94809:     // - "Valid": compilation succeeded and there is a JITScript.
 94809:     class JITScriptHandle
 94809:     {
 94809:         // CallCompiler must be a friend because it generates code that uses
 94809:         // UNJITTABLE.
 94809:         friend class js::mjit::CallCompiler;
 54840: 
 94809:         // The exact representation:
 94809:         // - NULL means "empty".
 94809:         // - UNJITTABLE means "unjittable".
 94809:         // - Any other value means "valid".
 94809:         // UNJITTABLE = 1 so that we can check that a JITScript is valid
 94809:         // with a single |> 1| test.  It's defined outside the class because
 94809:         // non-integral static const fields can't be defined in the class.
 94809:         static const js::mjit::JITScript *UNJITTABLE;   // = (JITScript *)1;
 94809:         js::mjit::JITScript *value;
 94809: 
 94809:       public:
 94809:         JITScriptHandle()       { value = NULL; }
 94809: 
 94809:         bool isEmpty()          { return value == NULL; }
 94809:         bool isUnjittable()     { return value == UNJITTABLE; }
 94809:         bool isValid()          { return value  > UNJITTABLE; }
 94809: 
 94809:         js::mjit::JITScript *getValid() {
 94809:             JS_ASSERT(isValid());
 94809:             return value;
 94809:         }
 94809: 
 94809:         void setEmpty()         { value = NULL; }
 94809:         void setUnjittable()    { value = const_cast<js::mjit::JITScript *>(UNJITTABLE); }
 94809:         void setValid(js::mjit::JITScript *jit) {
 94809:             value = jit;
 94809:             JS_ASSERT(isValid());
 94809:         }
 94809: 
 94809:         static void staticAsserts();
 94809:     };
 99476: 
 99476:     // All the possible JITScripts that can simultaneously exist for a script.
 99476:     struct JITScriptSet
 99476:     {
 99476:         JITScriptHandle jitHandleNormal;          // JIT info for normal scripts
 99476:         JITScriptHandle jitHandleNormalBarriered; // barriered JIT info for normal scripts
 99476:         JITScriptHandle jitHandleCtor;            // JIT info for constructors
 99476:         JITScriptHandle jitHandleCtorBarriered;   // barriered JIT info for constructors
 99476: 
 99476:         static size_t jitHandleOffset(bool constructing, bool barriers) {
 99476:             return constructing
 99476:                 ? (barriers
 99476:                    ? offsetof(JITScriptSet, jitHandleCtorBarriered)
 99476:                    : offsetof(JITScriptSet, jitHandleCtor))
 99476:                 : (barriers
 99476:                    ? offsetof(JITScriptSet, jitHandleNormalBarriered)
 99476:                    : offsetof(JITScriptSet, jitHandleNormal));
 99476:         }
 99476:     };
 99476: 
 95024: #endif  // JS_METHODJIT
 94809: 
 94809:     //
 94809:     // We order fields according to their size in order to avoid wasting space
 94809:     // for alignment.
 94809:     //
 94809: 
 94809:     // Larger-than-word-sized fields.
 54840: 
 94571:   public:
 94571:     js::Bindings    bindings;   /* names of top-level variables in this script
 94571:                                    (and arguments if this is a function script) */
 94571: 
 94809:     // Word-sized fields.
 94571: 
 94571:   public:
     1:     jsbytecode      *code;      /* bytecodes and their immediate operands */
 94572:     uint8_t         *data;      /* pointer to variable-length data array (see
 94572:                                    comment above NewScript() for details) */
 77659: 
 94571:     const char      *filename;  /* source filename or null */
 94934:     js::HeapPtrAtom *atoms;     /* maps immediate index to literal struct */
 94571: 
 94571:     JSPrincipals    *principals;/* principals for this script */
 94571:     JSPrincipals    *originPrincipals; /* see jsapi.h 'originPrincipals' comment */
 94571: 
 94571:     /*
 94571:      * A global object for the script.
 94571:      * - All scripts returned by JSAPI functions (JS_CompileScript,
 94571:      *   JS_CompileUTF8File, etc.) have a non-null globalObject.
 94571:      * - A function script has a globalObject if the function comes from a
 94571:      *   compile-and-go script.
 94571:      * - Temporary scripts created by obj_eval, JS_EvaluateScript, and
 94571:      *   similar functions never have the globalObject field set; for such
 94571:      *   scripts the global should be extracted from the JS frame that
 94571:      *   execute scripts.
 94571:      */
 94571:     js::HeapPtr<js::GlobalObject, JSScript*> globalObject;
 94571: 
 94571:     /* Persistent type information retained across GCs. */
 94571:     js::types::TypeScript *types;
 94571: 
 99476:   private:
 94571: #ifdef JS_METHODJIT
 99476:     JITScriptSet *jitInfo;
 94571: #endif
 94571: 
 94571:     js::HeapPtrFunction function_;
 94571: 
 94809:     // 32-bit fields.
 94571: 
 94571:   public:
 84755:     uint32_t        length;     /* length of code vector */
 94571: 
 94571:     uint32_t        lineno;     /* base line number of script */
 94571: 
 94571:     uint32_t        mainOffset; /* offset of main entry point from code, after
 94571:                                    predef'ing prolog */
 94571: 
 94571:     uint32_t        natoms;     /* length of atoms array */
 94571: 
 97829:   private:
 97829:     uint32_t        useCount;   /* Number of times the script has been called
 97829:                                  * or has had backedges taken. Reset if the
 97829:                                  * script's JIT code is forcibly discarded. */
 97829: 
 99476: #if JS_BITS_PER_WORD == 32
 99161:     uint32_t        pad32;
 99161: #endif
 99161: 
 94571: #ifdef DEBUG
 94809:     // Unique identifier within the compartment for this script, used for
 94809:     // printing analysis information.
 94571:     uint32_t        id_;
 94571:   private:
 95139:     uint32_t        idpad;
 94571: #endif
 94571: 
 94809:     // 16-bit fields.
 94571: 
 61450:   private:
 84755:     uint16_t        version;    /* JS version under which script was compiled */
 61450: 
 61450:   public:
 84755:     uint16_t        nfixed;     /* number of slots besides stack operands in
 16072:                                    slot array */
 94571: 
 94571:     uint16_t        nTypeSets;  /* number of type sets used in this script for
 94571:                                    dynamic type monitoring */
 94571: 
 94571:     uint16_t        nslots;     /* vars plus maximum stack depth */
 94571:     uint16_t        staticLevel;/* static level for display maintenance */
 94571: 
 95100:   private:
100006:     uint16_t        argsSlot_;  /* slot holding 'arguments' (if argumentsHasLocalBindings) */
 95100: 
 94809:     // 8-bit fields.
 94571: 
 97840:   public:
 97839:     // The kinds of the optional arrays.
 97839:     enum ArrayKind {
 97839:         CONSTS,
 97839:         OBJECTS,
 97839:         REGEXPS,
 97839:         TRYNOTES,
 97839:         CLOSED_ARGS,
 97839:         CLOSED_VARS,
 97839:         LIMIT
 97839:     };
 97840: 
 97840:     typedef uint8_t ArrayBitsT;
 97840: 
 97840:   private:
 97840:     // The bits in this field indicate the presence/non-presence of several
 97840:     // optional arrays in |data|.  See the comments above NewScript() for
 97840:     // details.
 97840:     ArrayBitsT      hasArrayBits;
 77659: 
 94809:     // 1-bit fields.
 59221: 
 94571:   public:
 33750:     bool            noScriptRval:1; /* no need for result value of last
 33750:                                        expression statement */
 75519:     bool            savedCallerFun:1; /* can call getCallerFunction() */
 35113:     bool            strictModeCode:1; /* code is in strict mode */
 98464:     bool            compileAndGo:1;   /* see Parser::compileAndGo */
 98687:     bool            bindingsAccessedDynamically:1; /* see ContextFlags' field of the same name */
 48589:     bool            warnedAboutTwoArgumentEval:1; /* have warned about use of
 48589:                                                      obsolete eval(s, o) in
 48589:                                                      this script */
 77343:     bool            warnedAboutUndefinedProp:1; /* have warned about uses of
 77343:                                                    undefined properties in this
 77343:                                                    script */
 59962:     bool            hasSingletons:1;  /* script has singleton objects */
 77884:     bool            isOuterFunction:1; /* function is heavyweight, with inner functions */
 77884:     bool            isInnerFunction:1; /* function is directly nested in a heavyweight
 77884:                                         * outer function */
 77343:     bool            isActiveEval:1;   /* script came from eval(), and is still active */
 77343:     bool            isCachedEval:1;   /* script came from eval(), and is in eval cache */
 77361:     bool            uninlineable:1;   /* script is considered uninlineable by analysis */
 77884:     bool            reentrantOuterFunction:1; /* outer function marked reentrant */
 77885:     bool            typesPurged:1;    /* TypeScript has been purged at some point */
 53391: #ifdef JS_METHODJIT
 53391:     bool            debugMode:1;      /* script was compiled in debug mode */
 77343:     bool            failedBoundsCheck:1; /* script has had hoisted bounds checks fail */
 53391: #endif
 77659:     bool            callDestroyHook:1;/* need to call destroy hook */
 95100:     bool            isGenerator:1;    /* is a generator */
 95113:     bool            hasScriptCounts:1;/* script has an entry in
 95113:                                          JSCompartment::scriptCountsMap */
 95139:     bool            hasSourceMap:1;   /* script has an entry in
 95139:                                          JSCompartment::sourceMapMap */
 95151:     bool            hasDebugScript:1; /* script has an entry in
 95151:                                          JSCompartment::debugScriptMap */
 33750: 
 93250:   private:
 95100:     /* See comments below. */
 95100:     bool            argsHasLocalBinding_:1;
 95100:     bool            needsArgsAnalysis_:1;
 93250:     bool            needsArgsObj_:1;
 94571: 
 94809:     //
 94809:     // End of fields.  Start methods.
 94809:     //
 94571: 
 94571:     /*
 94571:      * Two successively less primitive ways to make a new JSScript.  The first
 94571:      * does *not* call a non-null cx->runtime->newScriptHook -- only the second,
 94571:      * NewScriptFromEmitter, calls this optional debugger hook.
 94571:      *
 94571:      * The NewScript function can't know whether the script it creates belongs
 94571:      * to a function, or is top-level or eval code, but the debugger wants access
 94571:      * to the newly made script's function, if any -- so callers of NewScript
 94571:      * are responsible for notifying the debugger after successfully creating any
 94571:      * kind (function or other) of new JSScript.
 94571:      */
 93250:   public:
 94571:     static JSScript *NewScript(JSContext *cx, uint32_t length, uint32_t nsrcnotes, uint32_t natoms,
 94571:                                uint32_t nobjects, uint32_t nregexps,
 98173:                                uint32_t ntrynotes, uint32_t nconsts,
 94571:                                uint16_t nClosedArgs, uint16_t nClosedVars, uint32_t nTypeSets,
 94571:                                JSVersion version);
 94571:     static JSScript *NewScriptFromEmitter(JSContext *cx, js::BytecodeEmitter *bce);
 94571: 
 97298:     void setVersion(JSVersion v) { version = v; }
 97298: 
 98687:     /* See ContextFlags::funArgumentsHasLocalBinding comment. */
 95100:     bool argumentsHasLocalBinding() const { return argsHasLocalBinding_; }
 95100:     jsbytecode *argumentsBytecode() const { JS_ASSERT(code[0] == JSOP_ARGUMENTS); return code; }
100006:     unsigned argumentsLocalSlot() const { JS_ASSERT(argsHasLocalBinding_); return argsSlot_; }
100006:     void setArgumentsHasLocalBinding(uint16_t slot);
 95100: 
 95100:     /*
 95100:      * As an optimization, even when argsHasLocalBinding, the function prologue
 95100:      * may not need to create an arguments object. This is determined by
 95100:      * needsArgsObj which is set by ScriptAnalysis::analyzeSSA before running
 95100:      * the script the first time. When !needsArgsObj, the prologue may simply
 95100:      * write MagicValue(JS_OPTIMIZED_ARGUMENTS) to 'arguments's slot and any
 95100:      * uses of 'arguments' will be guaranteed to handle this magic value.
 95100:      * So avoid spurious arguments object creation, we maintain the invariant
 95100:      * that needsArgsObj is only called after the script has been analyzed.
 95100:      */
 95100:     bool analyzedArgsUsage() const { return !needsArgsAnalysis_; }
 93250:     bool needsArgsObj() const { JS_ASSERT(analyzedArgsUsage()); return needsArgsObj_; }
 93250:     void setNeedsArgsObj(bool needsArgsObj);
 97353:     static bool applySpeculationFailed(JSContext *cx, JSScript *script);
 93250: 
 98892:     /*
 98892:      * Arguments access (via JSOP_*ARG* opcodes) must access the canonical
 98892:      * location for the argument. If an arguments object exists AND this is a
 98892:      * non-strict function (where 'arguments' aliases formals), then all access
 98892:      * must go through the arguments object. Otherwise, the local slot is the
 98892:      * canonical location for the arguments. Note: if a formal is aliased
 98892:      * through the scope chain, then script->argLivesInCallObject and
 98892:      * JSOP_*ARG* opcodes won't be emitted at all.
 98892:      */
 98892:     bool argsObjAliasesFormals() const {
 98892:         return needsArgsObj() && !strictModeCode;
 98892:     }
 98892: 
 77659:     /* Hash table chaining for JSCompartment::evalCache. */
 82129:     JSScript *&evalHashLink() { return *globalObject.unsafeGetUnioned(); }
 76732: 
 83283:     /*
 83283:      * Original compiled function for the script, if it has a function.
 83283:      * NULL for global and eval scripts.
 83283:      */
 83256:     JSFunction *function() const { return function_; }
 84726:     void setFunction(JSFunction *fun);
 83256: 
 77343: #ifdef DEBUG
 80026:     unsigned id();
 77343: #else
 77343:     unsigned id() { return 0; }
 77343: #endif
 77343: 
 77884:     /* Ensure the script has a TypeScript. */
 83256:     inline bool ensureHasTypes(JSContext *cx);
 77884: 
 77884:     /*
 77884:      * Ensure the script has scope and bytecode analysis information.
 77884:      * Performed when the script first runs, or first runs after a TypeScript
 83256:      * GC purge. If scope is NULL then the script must already have types with
 83256:      * scope information.
 77884:      */
 83256:     inline bool ensureRanAnalysis(JSContext *cx, JSObject *scope);
 77884: 
 77884:     /* Ensure the script has type inference analysis information. */
 77343:     inline bool ensureRanInference(JSContext *cx);
 77343: 
 77391:     inline bool hasAnalysis();
 77884:     inline void clearAnalysis();
 77391:     inline js::analyze::ScriptAnalysis *analysis();
 77343: 
 77884:     /*
 77884:      * Associates this script with a specific function, constructing a new type
 77884:      * object for the function if necessary.
 77884:      */
 77884:     bool typeSetFunction(JSContext *cx, JSFunction *fun, bool singleton = false);
 77884: 
 77884:     inline bool hasGlobal() const;
 77884:     inline bool hasClearedGlobal() const;
 77884: 
 77884:     inline js::GlobalObject *global() const;
 77884:     inline js::types::TypeScriptNesting *nesting() const;
 77884: 
 77884:     inline void clearNesting();
 77659: 
 80803:     /* Return creation time global or null. */
 80803:     js::GlobalObject *getGlobalObjectOrNull() const {
 98566:         return (isCachedEval || isActiveEval) ? NULL : globalObject.get();
 80803:     }
 80803: 
 77391:   private:
 83256:     bool makeTypes(JSContext *cx);
 77391:     bool makeAnalysis(JSContext *cx);
 77391: 
 52557: #ifdef JS_METHODJIT
 94809:   private:
 94809:     // CallCompiler must be a friend because it generates code that directly
 94809:     // accesses jitHandleNormal/jitHandleCtor, via jitHandleOffset().
 94809:     friend class js::mjit::CallCompiler;
 94809: 
 99476:   public:
 99476:     bool hasJITInfo() {
 99476:         return jitInfo != NULL;
 55503:     }
 55503: 
 99476:     static size_t offsetOfJITInfo() { return offsetof(JSScript, jitInfo); }
 99476: 
 99476:     inline bool ensureHasJITInfo(JSContext *cx);
 99476:     inline void destroyJITInfo(js::FreeOp *fop);
 94809: 
 98147:     JITScriptHandle *jitHandle(bool constructing, bool barriers) {
 99476:         JS_ASSERT(jitInfo);
 98147:         return constructing
 99476:                ? (barriers ? &jitInfo->jitHandleCtorBarriered : &jitInfo->jitHandleCtor)
 99476:                : (barriers ? &jitInfo->jitHandleNormalBarriered : &jitInfo->jitHandleNormal);
 98147:     }
 98147: 
 98147:     js::mjit::JITScript *getJIT(bool constructing, bool barriers) {
 99476:         if (!jitInfo)
 99476:             return NULL;
 98147:         JITScriptHandle *jith = jitHandle(constructing, barriers);
 94809:         return jith->isValid() ? jith->getValid() : NULL;
 94809:     }
 94809: 
 94809:     static void ReleaseCode(js::FreeOp *fop, JITScriptHandle *jith);
 94809: 
 55687:     // These methods are implemented in MethodJIT.h.
 55687:     inline void **nativeMap(bool constructing);
 55687:     inline void *nativeCodeForPC(bool constructing, jsbytecode *pc);
 55503: 
 97829:     uint32_t getUseCount() const  { return useCount; }
 97829:     uint32_t incUseCount() { return ++useCount; }
 97829:     uint32_t *addressOfUseCount() { return &useCount; }
 77659:     void resetUseCount() { useCount = 0; }
 62574: 
 88300:     /*
 88300:      * Size of the JITScript and all sections.  If |mallocSizeOf| is NULL, the
 88300:      * size is computed analytically.  (This method is implemented in
 88300:      * MethodJIT.cpp.)
 88300:      */
 88145:     size_t sizeOfJitScripts(JSMallocSizeOfFun mallocSizeOf);
 53119: #endif
 32723: 
 94809:   public:
 95139:     bool initScriptCounts(JSContext *cx);
 95113:     js::PCCounts getPCCounts(jsbytecode *pc);
 95113:     js::ScriptCounts releaseScriptCounts();
 94740:     void destroyScriptCounts(js::FreeOp *fop);
 82134: 
 95139:     bool setSourceMap(JSContext *cx, jschar *sourceMap);
 95139:     jschar *getSourceMap();
 95139:     jschar *releaseSourceMap();
 95139:     void destroySourceMap(js::FreeOp *fop);
 95139: 
 77659:     jsbytecode *main() {
 77659:         return code + mainOffset;
 77659:     }
 77659: 
 78016:     /*
 88145:      * computedSizeOfData() is the in-use size of all the data sections.
 88145:      * sizeOfData() is the size of the block allocated to hold all the data sections
 78016:      * (which can be larger than the in-use size).
 78016:      */
 88145:     size_t computedSizeOfData();
 88145:     size_t sizeOfData(JSMallocSizeOfFun mallocSizeOf);
 88145: 
 84755:     uint32_t numNotes();  /* Number of srcnote slots in the srcnotes section */
 72071: 
 32723:     /* Script notes are allocated right after the code. */
 32723:     jssrcnote *notes() { return (jssrcnote *)(code + length); }
 32723: 
 97839:     bool hasArray(ArrayKind kind)           { return (hasArrayBits & (1 << kind)); }
 97839:     void setHasArray(ArrayKind kind)        { hasArrayBits |= (1 << kind); }
 97839:     void cloneHasArray(JSScript *script)    { hasArrayBits = script->hasArrayBits; }
 59221: 
 97839:     bool hasConsts()        { return hasArray(CONSTS);      }
 97839:     bool hasObjects()       { return hasArray(OBJECTS);     }
 97839:     bool hasRegexps()       { return hasArray(REGEXPS);     }
 97839:     bool hasTrynotes()      { return hasArray(TRYNOTES);    }
 97839:     bool hasClosedArgs()    { return hasArray(CLOSED_ARGS); }
 97839:     bool hasClosedVars()    { return hasArray(CLOSED_VARS); }
 97839: 
 97839:     #define OFF(fooOff, hasFoo, t)   (fooOff() + (hasFoo() ? sizeof(t) : 0))
 97839: 
 97839:     size_t constsOffset()     { return 0; }
 97839:     size_t objectsOffset()    { return OFF(constsOffset,     hasConsts,     js::ConstArray);      }
 97839:     size_t regexpsOffset()    { return OFF(objectsOffset,    hasObjects,    js::ObjectArray);     }
 97839:     size_t trynotesOffset()   { return OFF(regexpsOffset,    hasRegexps,    js::ObjectArray);     }
 98173:     size_t closedArgsOffset() { return OFF(trynotesOffset,   hasTrynotes,   js::TryNoteArray);    }
 97839:     size_t closedVarsOffset() { return OFF(closedArgsOffset, hasClosedArgs, js::ClosedSlotArray); }
 97361: 
 97362:     js::ConstArray *consts() {
 97361:         JS_ASSERT(hasConsts());
 97839:         return reinterpret_cast<js::ConstArray *>(data + constsOffset());
 94572:     }
 94572: 
 97362:     js::ObjectArray *objects() {
 97361:         JS_ASSERT(hasObjects());
 97839:         return reinterpret_cast<js::ObjectArray *>(data + objectsOffset());
 32723:     }
 32723: 
 97362:     js::ObjectArray *regexps() {
 97361:         JS_ASSERT(hasRegexps());
 97839:         return reinterpret_cast<js::ObjectArray *>(data + regexpsOffset());
 32723:     }
 32723: 
 97362:     js::TryNoteArray *trynotes() {
 97361:         JS_ASSERT(hasTrynotes());
 97839:         return reinterpret_cast<js::TryNoteArray *>(data + trynotesOffset());
 32723:     }
 32723: 
 94572:     js::ClosedSlotArray *closedArgs() {
 97361:         JS_ASSERT(hasClosedArgs());
 97839:         return reinterpret_cast<js::ClosedSlotArray *>(data + closedArgsOffset());
 94572:     }
 94572: 
 94572:     js::ClosedSlotArray *closedVars() {
 97361:         JS_ASSERT(hasClosedVars());
 97839:         return reinterpret_cast<js::ClosedSlotArray *>(data + closedVarsOffset());
 94572:     }
 94572: 
 95023:     uint32_t numClosedArgs() {
 97361:         return hasClosedArgs() ? closedArgs()->length : 0;
 94572:     }
 94572: 
 95023:     uint32_t numClosedVars() {
 97361:         return hasClosedVars() ? closedVars()->length : 0;
 48470:     }
 48470: 
 94934:     js::HeapPtrAtom &getAtom(size_t index) const {
 77659:         JS_ASSERT(index < natoms);
 77659:         return atoms[index];
 32723:     }
 32723: 
 86542:     js::PropertyName *getName(size_t index) {
 86542:         return getAtom(index)->asPropertyName();
 86542:     }
 86542: 
 32723:     JSObject *getObject(size_t index) {
 97362:         js::ObjectArray *arr = objects();
 32723:         JS_ASSERT(index < arr->length);
 32723:         return arr->vector[index];
 32723:     }
 32723: 
 53848:     JSVersion getVersion() const {
 53848:         return JSVersion(version);
 53848:     }
 53848: 
 32736:     inline JSFunction *getFunction(size_t index);
 75519:     inline JSFunction *getCallerFunction();
 32723: 
 32723:     inline JSObject *getRegExp(size_t index);
 34290: 
 48470:     const js::Value &getConst(size_t index) {
 97362:         js::ConstArray *arr = consts();
 48470:         JS_ASSERT(index < arr->length);
 48470:         return arr->vector[index];
 48470:     }
 48470: 
 34290:     /*
 34290:      * The isEmpty method tells whether this script has code that computes any
 34290:      * result (not return value, result AKA normal completion value) other than
 59220:      * JSVAL_VOID, or any other effects.
 34290:      */
 34290:     inline bool isEmpty() const;
 34290: 
 84755:     uint32_t getClosedArg(uint32_t index) {
 94572:         js::ClosedSlotArray *arr = closedArgs();
 94572:         JS_ASSERT(index < arr->length);
 94572:         return arr->vector[index];
 54840:     }
 54840: 
 84755:     uint32_t getClosedVar(uint32_t index) {
 94572:         js::ClosedSlotArray *arr = closedVars();
 94572:         JS_ASSERT(index < arr->length);
 94572:         return arr->vector[index];
 54840:     }
 54840: 
 95099: 
100006: #ifdef DEBUG
 95099:     bool varIsAliased(unsigned varSlot);
 98892:     bool formalIsAliased(unsigned argSlot);
 98892:     bool formalLivesInArgumentsObject(unsigned argSlot);
 98892:     bool formalLivesInCallObject(unsigned argSlot);
100006: #endif
 77169:   private:
 77169:     /*
 94740:      * Recompile with or without single-stepping support, as directed
 77169:      * by stepModeEnabled().
 77169:      */
 94740:     void recompileForStepMode(js::FreeOp *fop);
 77169: 
 77169:     /* Attempt to change this->stepMode to |newValue|. */
 84755:     bool tryNewStepMode(JSContext *cx, uint32_t newValue);
 77169: 
 95151:     bool ensureHasDebugScript(JSContext *cx);
 95151:     js::DebugScript *debugScript();
 95151:     js::DebugScript *releaseDebugScript();
 95151:     void destroyDebugScript(js::FreeOp *fop);
 84195: 
 77169:   public:
 84195:     bool hasBreakpointsAt(jsbytecode *pc) { return !!getBreakpointSite(pc); }
 95151:     bool hasAnyBreakpointsOrStepMode() { return hasDebugScript; }
 84195: 
 84195:     js::BreakpointSite *getBreakpointSite(jsbytecode *pc)
 84195:     {
 84195:         JS_ASSERT(size_t(pc - code) < length);
 95151:         return hasDebugScript ? debugScript()->breakpoints[pc - code] : NULL;
 84195:     }
 84195: 
 84195:     js::BreakpointSite *getOrCreateBreakpointSite(JSContext *cx, jsbytecode *pc,
 84195:                                                   js::GlobalObject *scriptGlobal);
 84195: 
 94740:     void destroyBreakpointSite(js::FreeOp *fop, jsbytecode *pc);
 84195: 
 94959:     void clearBreakpointsIn(js::FreeOp *fop, js::Debugger *dbg, JSObject *handler);
 94740:     void clearTraps(js::FreeOp *fop);
 84195: 
 84195:     void markTrapClosures(JSTracer *trc);
 84195: 
 77169:     /*
 77169:      * Set or clear the single-step flag. If the flag is set or the count
 77169:      * (adjusted by changeStepModeCount) is non-zero, then the script is in
 77169:      * single-step mode. (JSD uses an on/off-style interface; Debugger uses a
 77169:      * count-style interface.)
 77169:      */
 77169:     bool setStepModeFlag(JSContext *cx, bool step);
 77169: 
 77169:     /*
 77169:      * Increment or decrement the single-step count. If the count is non-zero or
 77169:      * the flag (set by setStepModeFlag) is set, then the script is in
 77169:      * single-step mode. (JSD uses an on/off-style interface; Debugger uses a
 77169:      * count-style interface.)
 77169:      */
 77169:     bool changeStepModeCount(JSContext *cx, int delta);
 77169: 
 95151:     bool stepModeEnabled() { return hasDebugScript && !!debugScript()->stepMode; }
 77169: 
 77169: #ifdef DEBUG
 95151:     uint32_t stepModeCount() { return hasDebugScript ? (debugScript()->stepMode & stepCountMask) : 0; }
 77169: #endif
 77659: 
 94738:     void finalize(js::FreeOp *fop);
 82129: 
 82129:     static inline void writeBarrierPre(JSScript *script);
 82129:     static inline void writeBarrierPost(JSScript *script, void *addr);
 86437: 
 86437:     static inline js::ThingRootKind rootKind() { return js::THING_ROOT_SCRIPT; }
 90856: 
 90856:     static JSPrincipals *normalizeOriginPrincipals(JSPrincipals *principals,
 90856:                                                    JSPrincipals *originPrincipals) {
 90856:         return originPrincipals ? originPrincipals : principals;
 90856:     }
 91557: 
 91557:     void markChildren(JSTracer *trc);
     1: };
     1: 
 97840: JS_STATIC_ASSERT(sizeof(JSScript::ArrayBitsT) * 8 >= JSScript::LIMIT);
 97840: 
 95151: /* If this fails, add/remove padding within JSScript. */
 77659: JS_STATIC_ASSERT(sizeof(JSScript) % js::gc::Cell::CellSize == 0);
 77659: 
100006: static JS_INLINE unsigned
100006: StackDepth(JSScript *script)
100006: {
100006:     return script->nslots - script->nfixed;
100006: }
100006: 
     1: /*
 80966:  * New-script-hook calling is factored from NewScriptFromEmitter so that it
 90546:  * and callers of XDRScript can share this code.  In the case of callers
 90546:  * of XDRScript, the hook should be invoked only after successful decode
     1:  * of any owning function (the fun parameter) or script object (null fun).
     1:  */
 13702: extern JS_FRIEND_API(void)
 13702: js_CallNewScriptHook(JSContext *cx, JSScript *script, JSFunction *fun);
     1: 
 94740: namespace js {
 94740: 
 62571: extern void
 94740: CallDestroyScriptHook(FreeOp *fop, JSScript *script);
     1: 
 94202: extern const char *
 94202: SaveScriptFilename(JSContext *cx, const char *filename);
 94202: 
 97463: struct ScriptFilenameEntry
 97463: {
 97463:     bool marked;
 97463:     char filename[1];
 97463: 
 97463:     static ScriptFilenameEntry *fromFilename(const char *filename) {
 97463:         return (ScriptFilenameEntry *)(filename - offsetof(ScriptFilenameEntry, filename));
 97463:     }
 97463: };
 97463: 
 97463: struct ScriptFilenameHasher
 97463: {
 97463:     typedef const char *Lookup;
 97463:     static HashNumber hash(const char *l) { return JS_HashString(l); }
 97463:     static bool match(const ScriptFilenameEntry *e, const char *l) {
 97463:         return strcmp(e->filename, l) == 0;
 97463:     }
 97463: };
 97463: 
 97463: typedef HashSet<ScriptFilenameEntry *,
 97463:                 ScriptFilenameHasher,
 97463:                 SystemAllocPolicy> ScriptFilenameTable;
 97463: 
 97463: inline void
 97463: MarkScriptFilename(JSRuntime *rt, const char *filename);
 93970: 
 93970: extern void
 97463: SweepScriptFilenames(JSRuntime *rt);
 93970: 
 93970: extern void
 97463: FreeScriptFilenames(JSRuntime *rt);
 93970: 
 94574: struct ScriptAndCounts
 84803: {
 84803:     JSScript *script;
 94574:     ScriptCounts scriptCounts;
 84803: 
 94574:     PCCounts &getPCCounts(jsbytecode *pc) const {
 84803:         JS_ASSERT(unsigned(pc - script->code) < script->length);
 94574:         return scriptCounts.pcCountsVector[pc - script->code];
 84803:     }
 84803: };
 84803: 
 77659: } /* namespace js */
     1: 
     1: /*
     1:  * To perturb as little code as possible, we introduce a js_GetSrcNote lookup
     1:  * cache without adding an explicit cx parameter.  Thus js_GetSrcNote becomes
     1:  * a macro that uses cx from its calls' lexical environments.
     1:  */
     1: #define js_GetSrcNote(script,pc) js_GetSrcNoteCached(cx, script, pc)
     1: 
     1: extern jssrcnote *
     1: js_GetSrcNoteCached(JSContext *cx, JSScript *script, jsbytecode *pc);
     1: 
     1: extern jsbytecode *
 91237: js_LineNumberToPC(JSScript *script, unsigned lineno);
     1: 
 91237: extern JS_FRIEND_API(unsigned)
     1: js_GetScriptLineExtent(JSScript *script);
     1: 
 68894: namespace js {
 68894: 
 91237: extern unsigned
 91316: PCToLineNumber(JSScript *script, jsbytecode *pc);
 91316: 
 91316: extern unsigned
 91316: PCToLineNumber(unsigned startLine, jssrcnote *notes, jsbytecode *code, jsbytecode *pc);
 91316: 
 91316: extern unsigned
 71363: CurrentLine(JSContext *cx);
 71363: 
 68894: /*
 68894:  * This function returns the file and line number of the script currently
 68894:  * executing on cx. If there is no current script executing on cx (e.g., a
 68894:  * native called directly through JSAPI (e.g., by setTimeout)), NULL and 0 are
 68894:  * returned as the file and line. Additionally, this function avoids the full
 68894:  * linear scan to compute line number when the caller guarnatees that the
 68894:  * script compilation occurs at a JSOP_EVAL.
 68894:  */
 68894: 
 68894: enum LineOption {
 68894:     CALLED_FROM_JSOP_EVAL,
 68894:     NOT_CALLED_FROM_JSOP_EVAL
 68894: };
 68894: 
 84691: inline void
 91237: CurrentScriptFileLineOrigin(JSContext *cx, unsigned *linenop, LineOption = NOT_CALLED_FROM_JSOP_EVAL);
 68894: 
 55633: extern JSScript *
 90546: CloneScript(JSContext *cx, JSScript *script);
 55633: 
 94006: /*
 94006:  * NB: after a successful XDR_DECODE, XDRScript callers must do any required
 94006:  * subsequent set-up of owning function or script object and then call
 94006:  * js_CallNewScriptHook.
 94006:  */
 94006: template<XDRMode mode>
 94006: bool
 94006: XDRScript(XDRState<mode> *xdr, JSScript **scriptp, JSScript *parentScript);
 94006: 
 94006: } /* namespace js */
     1: 
     1: #endif /* jsscript_h___ */
