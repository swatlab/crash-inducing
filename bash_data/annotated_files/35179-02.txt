    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* vim:set ts=4 sw=4 sts=4 ci et: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Benjamin Smedberg <benjamin@smedbergs.us>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
28510: #include "mozilla/XPCOM.h"
28510: 
    1: #include "nsXPCOMPrivate.h"
    1: #include "nsXPCOMCIDInternal.h"
28510: 
    1: #include "nsStaticComponents.h"
    1: #include "prlink.h"
28510: 
    1: #include "nsObserverList.h"
    1: #include "nsObserverService.h"
    1: #include "nsProperties.h"
    1: #include "nsPersistentProperties.h"
    1: #include "nsScriptableInputStream.h"
    1: #include "nsBinaryStream.h"
    1: #include "nsStorageStream.h"
    1: #include "nsPipe.h"
    1: 
    1: #include "nsMemoryImpl.h"
    1: #include "nsDebugImpl.h"
    1: #include "nsTraceRefcntImpl.h"
    1: #include "nsErrorService.h"
    1: #include "nsByteBuffer.h"
    1: 
    1: #include "nsSupportsArray.h"
    1: #include "nsArray.h"
    1: #include "nsINIParserImpl.h"
    1: #include "nsSupportsPrimitives.h"
    1: #include "nsConsoleService.h"
    1: #include "nsExceptionService.h"
    1: 
    1: #include "nsComponentManager.h"
    1: #include "nsCategoryManagerUtils.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsGenericFactory.h"
    1: 
    1: #include "nsThreadManager.h"
    1: #include "nsThreadPool.h"
    1: 
29281: #ifdef DEBUG
29281: #include "BlockingResourceBase.h"
29281: #endif // ifdef DEBUG
29281: 
    1: #include "nsIProxyObjectManager.h"
    1: #include "nsProxyEventPrivate.h"  // access to the impl of nsProxyObjectManager for the generic factory registration.
    1: 
    1: #include "xptinfo.h"
    1: #include "nsIInterfaceInfoManager.h"
    1: #include "xptiprivate.h"
    1: 
    1: #include "nsTimerImpl.h"
    1: #include "TimerThread.h"
    1: 
    1: #include "nsThread.h"
    1: #include "nsProcess.h"
    1: #include "nsEnvironment.h"
    1: #include "nsVersionComparatorImpl.h"
    1: 
    1: #include "nsILocalFile.h"
    1: #include "nsLocalFile.h"
    1: #if defined(XP_UNIX) || defined(XP_OS2)
    1: #include "nsNativeCharsetUtils.h"
    1: #endif
    1: #include "nsDirectoryService.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsCategoryManager.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsMultiplexInputStream.h"
    1: 
    1: #include "nsStringStream.h"
    1: extern NS_METHOD nsStringInputStreamConstructor(nsISupports *, REFNSIID, void **);
    1: NS_DECL_CLASSINFO(nsStringInputStream)
    1: 
    1: #include "nsFastLoadService.h"
    1: 
    1: #include "nsAtomService.h"
    1: #include "nsAtomTable.h"
    1: #include "nsTraceRefcnt.h"
    1: #include "nsTimelineService.h"
    1: 
    1: #include "nsHashPropertyBag.h"
    1: 
    1: #include "nsUnicharInputStream.h"
    1: #include "nsVariant.h"
    1: 
    1: #include "nsUUIDGenerator.h"
    1: 
28080: #include "nsIOUtil.h"
28080: 
    1: #include "nsRecyclingAllocator.h"
    1: 
    1: #include "SpecialSystemDirectory.h"
    1: 
20187: #if defined(XP_WIN)
    1: #include "nsWindowsRegKey.h"
    1: #endif
    1: 
    1: #ifdef XP_MACOSX
    1: #include "nsMacUtilsImpl.h"
    1: #endif
    1: 
    1: #include "nsSystemInfo.h"
12636: #include "nsMemoryReporterManager.h"
    1: 
    1: #include <locale.h>
    1: 
26941: using mozilla::TimeStamp;
26941: 
    1: // Registry Factory creation function defined in nsRegistry.cpp
    1: // We hook into this function locally to create and register the registry
    1: // Since noone outside xpcom needs to know about this and nsRegistry.cpp
    1: // does not have a local include file, we are putting this definition
    1: // here rather than in nsIRegistry.h
    1: extern nsresult NS_RegistryGetFactory(nsIFactory** aFactory);
    1: extern nsresult NS_CategoryManagerGetFactory( nsIFactory** );
    1: 
    1: #ifdef DEBUG
    1: extern void _FreeAutoLockStatics();
    1: #endif
    1: 
    1: static NS_DEFINE_CID(kComponentManagerCID, NS_COMPONENTMANAGER_CID);
    1: static NS_DEFINE_CID(kMemoryCID, NS_MEMORY_CID);
    1: static NS_DEFINE_CID(kINIParserFactoryCID, NS_INIPARSERFACTORY_CID);
    1: static NS_DEFINE_CID(kSimpleUnicharStreamFactoryCID, NS_SIMPLE_UNICHAR_STREAM_FACTORY_CID);
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsProcess)
    1: 
    1: #define NS_ENVIRONMENT_CLASSNAME "Environment Service"
    1: 
    1: // ds/nsISupportsPrimitives
    1: #define NS_SUPPORTS_ID_CLASSNAME "Supports ID"
    1: #define NS_SUPPORTS_CSTRING_CLASSNAME "Supports String"
    1: #define NS_SUPPORTS_STRING_CLASSNAME "Supports WString"
    1: #define NS_SUPPORTS_PRBOOL_CLASSNAME "Supports PRBool"
    1: #define NS_SUPPORTS_PRUINT8_CLASSNAME "Supports PRUint8"
    1: #define NS_SUPPORTS_PRUINT16_CLASSNAME "Supports PRUint16"
    1: #define NS_SUPPORTS_PRUINT32_CLASSNAME "Supports PRUint32"
    1: #define NS_SUPPORTS_PRUINT64_CLASSNAME "Supports PRUint64"
    1: #define NS_SUPPORTS_PRTIME_CLASSNAME "Supports PRTime"
    1: #define NS_SUPPORTS_CHAR_CLASSNAME "Supports Char"
    1: #define NS_SUPPORTS_PRINT16_CLASSNAME "Supports PRInt16"
    1: #define NS_SUPPORTS_PRINT32_CLASSNAME "Supports PRInt32"
    1: #define NS_SUPPORTS_PRINT64_CLASSNAME "Supports PRInt64"
    1: #define NS_SUPPORTS_FLOAT_CLASSNAME "Supports float"
    1: #define NS_SUPPORTS_DOUBLE_CLASSNAME "Supports double"
    1: #define NS_SUPPORTS_VOID_CLASSNAME "Supports void"
    1: #define NS_SUPPORTS_INTERFACE_POINTER_CLASSNAME "Supports interface pointer"
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsIDImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsStringImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsCStringImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRBoolImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRUint8Impl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRUint16Impl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRUint32Impl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRUint64Impl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRTimeImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsCharImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRInt16Impl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRInt32Impl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsPRInt64Impl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsFloatImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsDoubleImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsVoidImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsSupportsInterfacePointerImpl)
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsConsoleService, Init)
    1: NS_DECL_CLASSINFO(nsConsoleService)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsAtomService)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsExceptionService)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsTimerImpl)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsBinaryOutputStream)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsBinaryInputStream)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsStorageStream)
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsVersionComparatorImpl)
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsVariant)
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsRecyclingAllocatorImpl)
    1: 
    1: #ifdef MOZ_TIMELINE
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsTimelineService)
    1: #endif
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsHashPropertyBag, Init)
    1: 
    1: NS_GENERIC_AGGREGATED_CONSTRUCTOR_INIT(nsProperties, Init)
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsUUIDGenerator, Init)
    1: 
    1: #ifdef XP_MACOSX
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsMacUtilsImpl)
    1: #endif
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsSystemInfo, Init)
    1: 
33420: NS_GENERIC_FACTORY_CONSTRUCTOR_INIT(nsMemoryReporterManager, Init)
12636: 
28080: NS_GENERIC_FACTORY_CONSTRUCTOR(nsIOUtil)
28080: 
    1: static NS_METHOD
    1: nsThreadManagerGetSingleton(nsISupports* outer,
    1:                             const nsIID& aIID,
    1:                             void* *aInstancePtr)
    1: {
    1:     NS_ASSERTION(aInstancePtr, "null outptr");
    1:     NS_ENSURE_TRUE(!outer, NS_ERROR_NO_AGGREGATION);
    1: 
    1:     return nsThreadManager::get()->QueryInterface(aIID, aInstancePtr);
    1: }
    1: NS_DECL_CLASSINFO(nsThreadManager)
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsThreadPool)
    1: NS_DECL_CLASSINFO(nsThreadPool)
    1: 
    1: static NS_METHOD
    1: nsXPTIInterfaceInfoManagerGetSingleton(nsISupports* outer,
    1:                                        const nsIID& aIID,
    1:                                        void* *aInstancePtr)
    1: {
    1:     NS_ASSERTION(aInstancePtr, "null outptr");
    1:     NS_ENSURE_TRUE(!outer, NS_ERROR_NO_AGGREGATION);
    1: 
    1:     nsCOMPtr<nsIInterfaceInfoManager> iim
    1:         (xptiInterfaceInfoManager::GetInterfaceInfoManagerNoAddRef());
    1:     if (!iim)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return iim->QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
    1: 
20261: static nsresult
    1: RegisterGenericFactory(nsIComponentRegistrar* registrar,
    1:                        const nsModuleComponentInfo *info)
    1: {
    1:     nsresult rv;
    1:     nsIGenericFactory* fact;
    1:     rv = NS_NewGenericFactory(&fact, info);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = registrar->RegisterFactory(info->mCID, 
    1:                                     info->mDescription,
    1:                                     info->mContractID, 
    1:                                     fact);
    1:     NS_RELEASE(fact);
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsComponentManagerImpl* nsComponentManagerImpl::gComponentManager = NULL;
    1: PRBool gXPCOMShuttingDown = PR_FALSE;
    1: 
    1: // For each class that wishes to support nsIClassInfo, add a line like this
    1: // NS_DECL_CLASSINFO(nsMyClass)
    1: 
    1: #define COMPONENT(NAME, Ctor)                                                  \
    1:  { NS_##NAME##_CLASSNAME, NS_##NAME##_CID, NS_##NAME##_CONTRACTID, Ctor }
    1: 
    1: #define COMPONENT_CI(NAME, Ctor, Class)                                        \
    1:  { NS_##NAME##_CLASSNAME, NS_##NAME##_CID, NS_##NAME##_CONTRACTID, Ctor,       \
    1:    NULL, NULL, NULL, NS_CI_INTERFACE_GETTER_NAME(Class), NULL,                 \
    1:    &NS_CLASSINFO_NAME(Class) }
    1: 
    1: #define COMPONENT_CI_FLAGS(NAME, Ctor, Class, Flags)                           \
    1:  { NS_##NAME##_CLASSNAME, NS_##NAME##_CID, NS_##NAME##_CONTRACTID, Ctor,       \
    1:    NULL, NULL, NULL, NS_CI_INTERFACE_GETTER_NAME(Class), NULL,                 \
    1:    &NS_CLASSINFO_NAME(Class), Flags }
    1: 
    1: static const nsModuleComponentInfo components[] = {
    1:     COMPONENT(MEMORY, nsMemoryImpl::Create),
    1:     COMPONENT(DEBUG,  nsDebugImpl::Create),
    1: #define NS_ERRORSERVICE_CLASSNAME NS_ERRORSERVICE_NAME
    1:     COMPONENT(ERRORSERVICE, nsErrorService::Create),
    1: 
    1:     COMPONENT(BYTEBUFFER, ByteBufferImpl::Create),
11159:     COMPONENT(SCRIPTABLEINPUTSTREAM, nsScriptableInputStream::Create),
    1:     COMPONENT(BINARYINPUTSTREAM, nsBinaryInputStreamConstructor),
    1:     COMPONENT(BINARYOUTPUTSTREAM, nsBinaryOutputStreamConstructor),
    1:     COMPONENT(STORAGESTREAM, nsStorageStreamConstructor),
    1:     COMPONENT(VERSIONCOMPARATOR, nsVersionComparatorImplConstructor),
    1:     COMPONENT(PIPE, nsPipeConstructor),
    1: 
    1: #define NS_PROPERTIES_CLASSNAME  "Properties"
    1:     COMPONENT(PROPERTIES, nsPropertiesConstructor),
    1: 
    1: #define NS_PERSISTENTPROPERTIES_CID NS_IPERSISTENTPROPERTIES_CID /* sigh */
    1:     COMPONENT(PERSISTENTPROPERTIES, nsPersistentProperties::Create),
    1: 
    1:     COMPONENT(SUPPORTSARRAY, nsSupportsArray::Create),
    1:     COMPONENT(ARRAY, nsArrayConstructor),
    1:     COMPONENT_CI_FLAGS(CONSOLESERVICE, nsConsoleServiceConstructor,
    1:                        nsConsoleService,
    1:                        nsIClassInfo::THREADSAFE | nsIClassInfo::SINGLETON),
    1:     COMPONENT(EXCEPTIONSERVICE, nsExceptionServiceConstructor),
    1:     COMPONENT(ATOMSERVICE, nsAtomServiceConstructor),
    1: #ifdef MOZ_TIMELINE
    1:     COMPONENT(TIMELINESERVICE, nsTimelineServiceConstructor),
    1: #endif
    1:     COMPONENT(OBSERVERSERVICE, nsObserverService::Create),
    1:     COMPONENT(GENERICFACTORY, nsGenericFactory::Create),
    1: 
    1: #define NS_XPCOMPROXY_CID NS_PROXYEVENT_MANAGER_CID
    1:     COMPONENT(XPCOMPROXY, nsProxyObjectManager::Create),
    1: 
    1:     COMPONENT(TIMER, nsTimerImplConstructor),
    1: 
    1: #define COMPONENT_SUPPORTS(TYPE, Type)                                         \
    1:   COMPONENT(SUPPORTS_##TYPE, nsSupports##Type##ImplConstructor)
    1: 
    1:     COMPONENT_SUPPORTS(ID, ID),
    1:     COMPONENT_SUPPORTS(STRING, String),
    1:     COMPONENT_SUPPORTS(CSTRING, CString),
    1:     COMPONENT_SUPPORTS(PRBOOL, PRBool),
    1:     COMPONENT_SUPPORTS(PRUINT8, PRUint8),
    1:     COMPONENT_SUPPORTS(PRUINT16, PRUint16),
    1:     COMPONENT_SUPPORTS(PRUINT32, PRUint32),
    1:     COMPONENT_SUPPORTS(PRUINT64, PRUint64),
    1:     COMPONENT_SUPPORTS(PRTIME, PRTime),
    1:     COMPONENT_SUPPORTS(CHAR, Char),
    1:     COMPONENT_SUPPORTS(PRINT16, PRInt16),
    1:     COMPONENT_SUPPORTS(PRINT32, PRInt32),
    1:     COMPONENT_SUPPORTS(PRINT64, PRInt64),
    1:     COMPONENT_SUPPORTS(FLOAT, Float),
    1:     COMPONENT_SUPPORTS(DOUBLE, Double),
    1:     COMPONENT_SUPPORTS(VOID, Void),
    1:     COMPONENT_SUPPORTS(INTERFACE_POINTER, InterfacePointer),
    1: 
    1: #undef COMPONENT_SUPPORTS
    1: #define NS_LOCAL_FILE_CLASSNAME "Local File Specification"
    1:     COMPONENT(LOCAL_FILE, nsLocalFile::nsLocalFileConstructor),
    1: #define NS_DIRECTORY_SERVICE_CLASSNAME  "nsIFile Directory Service"
    1:     COMPONENT(DIRECTORY_SERVICE, nsDirectoryService::Create),
    1:     COMPONENT(PROCESS, nsProcessConstructor),
    1:     COMPONENT(ENVIRONMENT, nsEnvironment::Create),
    1: 
    1:     COMPONENT_CI_FLAGS(THREADMANAGER, nsThreadManagerGetSingleton,
    1:                        nsThreadManager,
    1:                        nsIClassInfo::THREADSAFE | nsIClassInfo::SINGLETON),
    1:     COMPONENT_CI_FLAGS(THREADPOOL, nsThreadPoolConstructor,
    1:                        nsThreadPool, nsIClassInfo::THREADSAFE),
    1: 
    1:     COMPONENT_CI_FLAGS(STRINGINPUTSTREAM, nsStringInputStreamConstructor,
    1:                        nsStringInputStream, nsIClassInfo::THREADSAFE),
    1:     COMPONENT(MULTIPLEXINPUTSTREAM, nsMultiplexInputStreamConstructor),
    1: 
    1: #ifndef MOZ_NO_FAST_LOAD
    1:     COMPONENT(FASTLOADSERVICE, nsFastLoadService::Create),
    1: #endif
    1: 
    1:     COMPONENT(VARIANT, nsVariantConstructor),
    1:     COMPONENT(INTERFACEINFOMANAGER_SERVICE, nsXPTIInterfaceInfoManagerGetSingleton),
    1: 
    1:     COMPONENT(RECYCLINGALLOCATOR, nsRecyclingAllocatorImplConstructor),
    1: 
    1: #define NS_HASH_PROPERTY_BAG_CLASSNAME "Hashtable Property Bag"
    1:     COMPONENT(HASH_PROPERTY_BAG, nsHashPropertyBagConstructor),
    1: 
    1:     COMPONENT(UUID_GENERATOR, nsUUIDGeneratorConstructor),
    1: 
20187: #if defined(XP_WIN)
    1:     COMPONENT(WINDOWSREGKEY, nsWindowsRegKeyConstructor),
    1: #endif
    1: 
    1: #ifdef XP_MACOSX
    1:     COMPONENT(MACUTILSIMPL, nsMacUtilsImplConstructor),
    1: #endif
    1: 
    1:     COMPONENT(SYSTEMINFO, nsSystemInfoConstructor),
12636: #define NS_MEMORY_REPORTER_MANAGER_CLASSNAME "Memory Reporter Manager"
12636:     COMPONENT(MEMORY_REPORTER_MANAGER, nsMemoryReporterManagerConstructor),
28080:     COMPONENT(IOUTIL, nsIOUtilConstructor),
    1: };
    1: 
    1: #undef COMPONENT
    1: 
    1: const int components_length = sizeof(components) / sizeof(components[0]);
    1: 
    1: // gDebug will be freed during shutdown.
    1: static nsIDebug* gDebug = nsnull;
    1: 
    1: EXPORT_XPCOM_API(nsresult)
    1: NS_GetDebug(nsIDebug** result)
    1: {
    1:     return nsDebugImpl::Create(nsnull, 
    1:                                NS_GET_IID(nsIDebug), 
    1:                                (void**) result);
    1: }
    1: 
    1: EXPORT_XPCOM_API(nsresult)
    1: NS_GetTraceRefcnt(nsITraceRefcnt** result)
    1: {
    1:     return nsTraceRefcntImpl::Create(nsnull, 
    1:                                      NS_GET_IID(nsITraceRefcnt), 
    1:                                      (void**) result);
    1: }
    1: 
    1: EXPORT_XPCOM_API(nsresult)
    1: NS_InitXPCOM(nsIServiceManager* *result,
    1:                              nsIFile* binDirectory)
    1: {
    1:     return NS_InitXPCOM3(result, binDirectory, nsnull, nsnull, 0);
    1: }
    1: 
    1: EXPORT_XPCOM_API(nsresult)
    1: NS_InitXPCOM2(nsIServiceManager* *result,
    1:                               nsIFile* binDirectory,
    1:                               nsIDirectoryServiceProvider* appFileLocationProvider)
    1: {
    1:     return NS_InitXPCOM3(result, binDirectory, appFileLocationProvider, nsnull, 0);
    1: }
    1: 
    1: EXPORT_XPCOM_API(nsresult)
    1: NS_InitXPCOM3(nsIServiceManager* *result,
    1:                               nsIFile* binDirectory,
    1:                               nsIDirectoryServiceProvider* appFileLocationProvider,
    1:                               nsStaticModuleInfo const *staticComponents,
    1:                               PRUint32 componentCount)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1: #ifdef MOZ_ENABLE_LIBXUL
    1:     if (!staticComponents) {
    1:         staticComponents = kPStaticModules;
    1:         componentCount = kStaticModuleCount;
    1:     }
    1: #endif
    1: 
    1:      // We are not shutting down
    1:     gXPCOMShuttingDown = PR_FALSE;
    1: 
    1:     NS_LogInit();
    1: 
26941:     // Set up TimeStamp
26941:     rv = TimeStamp::Startup();
26941:     NS_ENSURE_SUCCESS(rv, rv);
26941: 
    1:     // Establish the main thread here.
    1:     rv = nsThreadManager::get()->Init();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Set up the timer globals/timer thread
    1:     rv = nsTimerImpl::Startup();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifndef WINCE
    1:     // If the locale hasn't already been setup by our embedder,
    1:     // get us out of the "C" locale and into the system 
    1:     if (strcmp(setlocale(LC_ALL, NULL), "C") == 0)
    1:         setlocale(LC_ALL, "");
    1: #endif
    1: 
    1: #if defined(XP_UNIX) || defined(XP_OS2)
    1:     NS_StartupNativeCharsetUtils();
    1: #endif
    1:     NS_StartupLocalFile();
    1: 
    1:     StartupSpecialSystemDirectory();
    1: 
    1:     rv = nsDirectoryService::RealInit();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCOMPtr<nsIFile> xpcomLib;
    1:             
    1:     PRBool value;
    1:     if (binDirectory)
    1:     {
    1:         rv = binDirectory->IsDirectory(&value);
    1: 
    1:         if (NS_SUCCEEDED(rv) && value) {
    1:             nsDirectoryService::gService->Set(NS_XPCOM_INIT_CURRENT_PROCESS_DIR, binDirectory);
    1:             binDirectory->Clone(getter_AddRefs(xpcomLib));
    1:         }
    1:     }
    1:     else {
    1:         nsDirectoryService::gService->Get(NS_XPCOM_CURRENT_PROCESS_DIR, 
    1:                                           NS_GET_IID(nsIFile), 
    1:                                           getter_AddRefs(xpcomLib));
    1:     }
    1: 
    1:     if (xpcomLib) {
    1:         xpcomLib->AppendNative(nsDependentCString(XPCOM_DLL));
    1:         nsDirectoryService::gService->Set(NS_XPCOM_LIBRARY_FILE, xpcomLib);
    1:     }
    1:     
    1:     if (appFileLocationProvider) {
    1:         rv = nsDirectoryService::gService->RegisterProvider(appFileLocationProvider);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     NS_ASSERTION(nsComponentManagerImpl::gComponentManager == NULL, "CompMgr not null at init");
    1: 
    1:     // Create the Component/Service Manager
    1:     nsComponentManagerImpl *compMgr = new nsComponentManagerImpl();
    1:     if (compMgr == NULL)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(compMgr);
    1:     
    1:     rv = compMgr->Init(staticComponents, componentCount);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         NS_RELEASE(compMgr);
    1:         return rv;
    1:     }
    1: 
    1:     nsComponentManagerImpl::gComponentManager = compMgr;
    1: 
    1:     if (result) {
    1:         nsIServiceManager *serviceManager =
 3233:             static_cast<nsIServiceManager*>(compMgr);
    1: 
    1:         NS_ADDREF(*result = serviceManager);
    1:     }
    1: 
    1:     nsCOMPtr<nsIMemory> memory;
    1:     NS_GetMemoryManager(getter_AddRefs(memory));
    1:     rv = compMgr->RegisterService(kMemoryCID, memory);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
 3233:     rv = compMgr->RegisterService(kComponentManagerCID, static_cast<nsIComponentManager*>(compMgr));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
  142:     rv = nsCycleCollector_startup();
  142:     if (NS_FAILED(rv)) return rv;
  142: 
    1:     // 2. Register the global services with the component manager so that
    1:     //    clients can create new objects.
    1: 
    1:     // Category Manager
    1:     {
    1:       nsCOMPtr<nsIFactory> categoryManagerFactory;
    1:       if ( NS_FAILED(rv = NS_CategoryManagerGetFactory(getter_AddRefs(categoryManagerFactory))) )
    1:         return rv;
    1: 
    1:       NS_DEFINE_CID(kCategoryManagerCID, NS_CATEGORYMANAGER_CID);
    1: 
    1:       rv = compMgr->RegisterFactory(kCategoryManagerCID,
    1:                                     NS_CATEGORYMANAGER_CLASSNAME,
    1:                                     NS_CATEGORYMANAGER_CONTRACTID,
    1:                                     categoryManagerFactory,
    1:                                     PR_TRUE);
    1:       if ( NS_FAILED(rv) ) return rv;
    1:     }
    1: 
    1:     nsCOMPtr<nsIComponentRegistrar> registrar = do_QueryInterface(
 3233:         static_cast<nsIComponentManager*>(compMgr), &rv);
    1:     if (registrar) {
    1:         for (int i = 0; i < components_length; i++)
    1:             RegisterGenericFactory(registrar, &components[i]);
    1: 
    1:         nsCOMPtr<nsIFactory> iniParserFactory(new nsINIParserFactory());
    1:         if (iniParserFactory)
    1:             registrar->RegisterFactory(kINIParserFactoryCID, 
    1:                                        "nsINIParserFactory",
    1:                                        NS_INIPARSERFACTORY_CONTRACTID, 
    1:                                        iniParserFactory);
    1: 
    1:         registrar->
    1:           RegisterFactory(kSimpleUnicharStreamFactoryCID,
    1:                           "nsSimpleUnicharStreamFactory",
    1:                           NS_SIMPLE_UNICHAR_STREAM_FACTORY_CONTRACTID,
    1:                           nsSimpleUnicharStreamFactory::GetInstance());
    1:     }
    1: 
    1:     // Pay the cost at startup time of starting this singleton.
    1:     nsIInterfaceInfoManager* iim =
    1:         xptiInterfaceInfoManager::GetInterfaceInfoManagerNoAddRef();
    1: 
33900:     // "Re-register the world" if compreg.dat doesn't exist
33900:     rv = nsComponentManagerImpl::gComponentManager->ReadPersistentRegistry();
33900:     if (NS_FAILED(rv)) {
    1:         // If the component registry is out of date, malformed, or incomplete,
    1:         // autoregister the default component directories.
    1:         (void) iim->AutoRegisterInterfaces();
    1:         nsComponentManagerImpl::gComponentManager->AutoRegister(nsnull);
    1:     }
    1: 
    1:     // After autoreg, but before we actually instantiate any components,
    1:     // add any services listed in the "xpcom-directory-providers" category
    1:     // to the directory service.
    1:     nsDirectoryService::gService->RegisterCategoryProviders();
    1: 
    1:     // Notify observers of xpcom autoregistration start
12777:     NS_CreateServicesFromCategory(NS_XPCOM_STARTUP_CATEGORY, 
    1:                                   nsnull,
    1:                                   NS_XPCOM_STARTUP_OBSERVER_ID);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: //
    1: // NS_ShutdownXPCOM()
    1: //
    1: // The shutdown sequence for xpcom would be
    1: //
    1: // - Notify "xpcom-shutdown" for modules to release primary (root) references
    1: // - Shutdown XPCOM timers
    1: // - Notify "xpcom-shutdown-threads" for thread joins
    1: // - Shutdown the event queues
    1: // - Release the Global Service Manager
    1: //   - Release all service instances held by the global service manager
    1: //   - Release the Global Service Manager itself
    1: // - Release the Component Manager
    1: //   - Release all factories cached by the Component Manager
    1: //   - Notify module loaders to shut down
    1: //   - Unload Libraries
    1: //   - Release Contractid Cache held by Component Manager
    1: //   - Release dll abstraction held by Component Manager
    1: //   - Release the Registry held by Component Manager
    1: //   - Finally, release the component manager itself
    1: //
    1: EXPORT_XPCOM_API(nsresult)
    1: NS_ShutdownXPCOM(nsIServiceManager* servMgr)
    1: {
29281:     return mozilla::ShutdownXPCOM(servMgr);
29281: }
29281: 
29281: namespace mozilla {
29281: 
29281: nsresult
29281: ShutdownXPCOM(nsIServiceManager* servMgr)
29281: {
    1:     NS_ENSURE_STATE(NS_IsMainThread());
    1: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsISimpleEnumerator> moduleLoaders;
    1: 
    1:     // Notify observers of xpcom shutting down
    1:     {
    1:         // Block it so that the COMPtr will get deleted before we hit
    1:         // servicemanager shutdown
    1: 
    1:         nsCOMPtr<nsIThread> thread = do_GetCurrentThread();
    1:         NS_ENSURE_STATE(thread);
    1: 
    1:         nsRefPtr<nsObserverService> observerService;
    1:         CallGetService("@mozilla.org/observer-service;1",
    1:                        (nsObserverService**) getter_AddRefs(observerService));
    1: 
    1:         if (observerService)
    1:         {
35179:             (void) observerService->
35179:                 NotifyObservers(nsnull, NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID,
35179:                                 nsnull);
35179: 
    1:             nsCOMPtr<nsIServiceManager> mgr;
    1:             rv = NS_GetServiceManager(getter_AddRefs(mgr));
    1:             if (NS_SUCCEEDED(rv))
    1:             {
    1:                 (void) observerService->
    1:                     NotifyObservers(mgr, NS_XPCOM_SHUTDOWN_OBSERVER_ID,
    1:                                     nsnull);
    1:             }
    1:         }
    1: 
    1:         NS_ProcessPendingEvents(thread);
    1: 
    1:         if (observerService)
    1:             (void) observerService->
    1:                 NotifyObservers(nsnull, NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID,
    1:                                 nsnull);
    1: 
    1:         NS_ProcessPendingEvents(thread);
    1: 
    1:         // Shutdown the timer thread and all timers that might still be alive before
    1:         // shutting down the component manager
    1:         nsTimerImpl::Shutdown();
    1: 
    1:         NS_ProcessPendingEvents(thread);
    1: 
    1:         // Shutdown all remaining threads.  This method does not return until
    1:         // all threads created using the thread manager (with the exception of
    1:         // the main thread) have exited.
    1:         nsThreadManager::get()->Shutdown();
    1: 
    1:         NS_ProcessPendingEvents(thread);
    1: 
    1:         // We save the "xpcom-shutdown-loaders" observers to notify after
    1:         // the observerservice is gone.
    1:         if (observerService) {
    1:             observerService->
    1:                 EnumerateObservers(NS_XPCOM_SHUTDOWN_LOADERS_OBSERVER_ID,
    1:                                    getter_AddRefs(moduleLoaders));
    1: 
    1:             observerService->Shutdown();
    1:         }
    1:     }
    1: 
    1:     // XPCOM is officially in shutdown mode NOW
    1:     // Set this only after the observers have been notified as this
    1:     // will cause servicemanager to become inaccessible.
    1:     gXPCOMShuttingDown = PR_TRUE;
    1: 
    1: #ifdef DEBUG_dougt
    1:     fprintf(stderr, "* * * * XPCOM shutdown. Access will be denied * * * * \n");
    1: #endif
    1:     // We may have AddRef'd for the caller of NS_InitXPCOM, so release it
    1:     // here again:
    1:     NS_IF_RELEASE(servMgr);
    1: 
    1:     // Shutdown global servicemanager
    1:     if (nsComponentManagerImpl::gComponentManager) {
    1:         nsComponentManagerImpl::gComponentManager->FreeServices();
    1:     }
    1: 
    1:     nsProxyObjectManager::Shutdown();
    1: 
    1:     // Release the directory service
    1:     NS_IF_RELEASE(nsDirectoryService::gService);
    1: 
    1:     nsCycleCollector_shutdown();
    1: 
    1:     if (moduleLoaders) {
    1:         PRBool more;
    1:         nsCOMPtr<nsISupports> el;
    1:         while (NS_SUCCEEDED(moduleLoaders->HasMoreElements(&more)) &&
    1:                more) {
    1:             moduleLoaders->GetNext(getter_AddRefs(el));
    1: 
    1:             // Don't worry about weak-reference observers here: there is
    1:             // no reason for weak-ref observers to register for
    1:             // xpcom-shutdown-loaders
    1: 
    1:             nsCOMPtr<nsIObserver> obs(do_QueryInterface(el));
    1:             if (obs)
    1:                 (void) obs->Observe(nsnull,
    1:                                     NS_XPCOM_SHUTDOWN_LOADERS_OBSERVER_ID,
    1:                                     nsnull);
    1:         }
    1: 
    1:         moduleLoaders = nsnull;
    1:     }
    1: 
    1:     // Shutdown nsLocalFile string conversion
    1:     NS_ShutdownLocalFile();
    1: #ifdef XP_UNIX
    1:     NS_ShutdownNativeCharsetUtils();
    1: #endif
    1: 
    1:     // Shutdown xpcom. This will release all loaders and cause others holding
    1:     // a refcount to the component manager to release it.
    1:     if (nsComponentManagerImpl::gComponentManager) {
    1:         rv = (nsComponentManagerImpl::gComponentManager)->Shutdown();
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Component Manager shutdown failed.");
    1:     } else
    1:         NS_WARNING("Component Manager was never created ...");
    1: 
    1:     // Release our own singletons
    1:     // Do this _after_ shutting down the component manager, because the
    1:     // JS component loader will use XPConnect to call nsIModule::canUnload,
    1:     // and that will spin up the InterfaceInfoManager again -- bad mojo
    1:     xptiInterfaceInfoManager::FreeInterfaceInfoManager();
    1: 
    1:     // Finally, release the component manager last because it unloads the
    1:     // libraries:
    1:     if (nsComponentManagerImpl::gComponentManager) {
    1:       nsrefcnt cnt;
    1:       NS_RELEASE2(nsComponentManagerImpl::gComponentManager, cnt);
    1:       NS_ASSERTION(cnt == 0, "Component Manager being held past XPCOM shutdown.");
    1:     }
    1:     nsComponentManagerImpl::gComponentManager = nsnull;
    1: 
    1: #ifdef DEBUG
29281:     // FIXME BUG 456272: this should disappear
    1:     _FreeAutoLockStatics();
    1: #endif
    1: 
    1:     ShutdownSpecialSystemDirectory();
    1: 
    1:     NS_PurgeAtomTable();
    1: 
    1:     NS_IF_RELEASE(gDebug);
    1: 
26941:     TimeStamp::Shutdown();
26941: 
29281: #ifdef DEBUG
29281:     /* FIXME bug 491977: This is only going to operate on the
29281:      * BlockingResourceBase which is compiled into
29281:      * libxul/libxpcom_core.so. Anyone using external linkage will
29281:      * have their own copy of BlockingResourceBase statics which will
29281:      * not be freed by this method.
29281:      *
29281:      * It sounds like what we really want is to be able to register a
29281:      * callback function to call at XPCOM shutdown.  Note that with
29281:      * this solution, however, we need to guarantee that
29281:      * BlockingResourceBase::Shutdown() runs after all other shutdown
29281:      * functions.
29281:      */
29281:     BlockingResourceBase::Shutdown();
29281: #endif
29281:     
    1:     NS_LogTerm();
    1: 
    1:     return NS_OK;
    1: }
29281: 
29281: } // namespace mozilla
