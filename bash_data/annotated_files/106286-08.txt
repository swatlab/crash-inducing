     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
104487: #include "mozilla/Assertions.h"         // for MOZ_ASSERT, etc
106286: #include "mozilla/Selection.h"          // for Selection
104487: #include "nsAString.h"                  // for nsAString_internal::Length
104487: #include "nsAutoPtr.h"                  // for nsRefPtr, getter_AddRefs, etc
104487: #include "nsCycleCollectionParticipant.h"
104487: #include "nsDebug.h"                    // for NS_ENSURE_TRUE, etc
104487: #include "nsEditor.h"                   // for nsEditor
104487: #include "nsEditorUtils.h"              // for nsEditorUtils
104487: #include "nsError.h"                    // for NS_OK, etc
104487: #include "nsIDOMCharacterData.h"        // for nsIDOMCharacterData
104487: #include "nsIDOMNode.h"                 // for nsIDOMNode
104487: #include "nsIDOMRange.h"                // for nsIDOMRange, etc
104487: #include "nsISelection.h"               // for nsISelection
104487: #include "nsISupportsImpl.h"            // for nsRange::Release
104487: #include "nsRange.h"                    // for nsRange
     1: #include "nsSelectionState.h"
     1: 
106286: using namespace mozilla;
     1: 
     1: /***************************************************************************
     1:  * class for recording selection info.  stores selection as collection of
     1:  * { {startnode, startoffset} , {endnode, endoffset} } tuples.  Can't store
     1:  * ranges since dom gravity will possibly change the ranges.
     1:  */
     1: nsSelectionState::nsSelectionState() : mArray(){}
     1: 
     1: nsSelectionState::~nsSelectionState() 
     1: {
     1:   MakeEmpty();
     1: }
     1: 
 28154: void
 28154: nsSelectionState::DoTraverse(nsCycleCollectionTraversalCallback &cb)
 28154: {
 28154:   for (PRUint32 i = 0, iEnd = mArray.Length(); i < iEnd; ++i)
 28154:   {
104447:     nsRangeStore* item = mArray[i];
 28154:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
 28154:                                        "selection state mArray[i].startNode");
104447:     cb.NoteXPCOMChild(item->startNode);
 28154:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
 28154:                                        "selection state mArray[i].endNode");
104447:     cb.NoteXPCOMChild(item->endNode);
 28154:   }
 28154: }
 28154: 
106286: void
106286: nsSelectionState::SaveSelection(Selection* aSel)
     1: {
106286:   MOZ_ASSERT(aSel);
106286:   PRInt32 arrayCount = mArray.Length();
106286:   PRInt32 rangeCount = aSel->GetRangeCount();
     1: 
 29263:   // if we need more items in the array, new them
106286:   if (arrayCount < rangeCount) {
106286:     for (PRInt32 i = arrayCount; i < rangeCount; i++) {
 29263:       mArray.AppendElement();
104447:       mArray[i] = new nsRangeStore();
 29263:     }
106286:   } else if (arrayCount > rangeCount) {
 29263:     // else if we have too many, delete them
106286:     for (PRInt32 i = arrayCount - 1; i >= rangeCount; i--) {
 29263:       mArray.RemoveElementAt(i);
 29263:     }
 29263:   }
     1: 
     1:   // now store the selection ranges
106286:   for (PRInt32 i = 0; i < rangeCount; i++) {
106286:     mArray[i]->StoreRange(aSel->GetRangeAt(i));
     1:   }
     1: }
     1: 
     1: nsresult  
     1: nsSelectionState::RestoreSelection(nsISelection *aSel)
     1: {
 43806:   NS_ENSURE_TRUE(aSel, NS_ERROR_NULL_POINTER);
     1:   nsresult res;
 27986:   PRUint32 i, arrayCount = mArray.Length();
     1: 
     1:   // clear out selection
     1:   aSel->RemoveAllRanges();
     1:   
     1:   // set the selection ranges anew
     1:   for (i=0; i<arrayCount; i++)
     1:   {
 86939:     nsRefPtr<nsRange> range;
104447:     mArray[i]->GetRange(getter_AddRefs(range));
 43806:     NS_ENSURE_TRUE(range, NS_ERROR_UNEXPECTED);
     1:    
     1:     res = aSel->AddRange(range);
     1:     if(NS_FAILED(res)) return res;
     1: 
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
     1: nsSelectionState::IsCollapsed()
     1: {
 80486:   if (1 != mArray.Length()) return false;
 86939:   nsRefPtr<nsRange> range;
104447:   mArray[0]->GetRange(getter_AddRefs(range));
 80486:   NS_ENSURE_TRUE(range, false);
 79445:   bool bIsCollapsed = false;
     1:   range->GetCollapsed(&bIsCollapsed);
     1:   return bIsCollapsed;
     1: }
     1: 
 79445: bool
     1: nsSelectionState::IsEqual(nsSelectionState *aSelState)
     1: {
 80486:   NS_ENSURE_TRUE(aSelState, false);
 27986:   PRUint32 i, myCount = mArray.Length(), itsCount = aSelState->mArray.Length();
 80486:   if (myCount != itsCount) return false;
 80486:   if (myCount < 1) return false;
     1: 
     1:   for (i=0; i<myCount; i++)
     1:   {
 86939:     nsRefPtr<nsRange> myRange, itsRange;
104447:     mArray[i]->GetRange(getter_AddRefs(myRange));
104447:     aSelState->mArray[i]->GetRange(getter_AddRefs(itsRange));
 80486:     NS_ENSURE_TRUE(myRange && itsRange, false);
     1:   
     1:     PRInt16 compResult;
 51222:     nsresult rv;
 51222:     rv = myRange->CompareBoundaryPoints(nsIDOMRange::START_TO_START, itsRange, &compResult);
 80486:     if (NS_FAILED(rv) || compResult) return false;
 51222:     rv = myRange->CompareBoundaryPoints(nsIDOMRange::END_TO_END, itsRange, &compResult);
 80486:     if (NS_FAILED(rv) || compResult) return false;
     1:   }
     1:   // if we got here, they are equal
 80486:   return true;
     1: }
     1: 
     1: void     
     1: nsSelectionState::MakeEmpty()
     1: {
     1:   // free any items in the array
     1:   mArray.Clear();
     1: }
     1: 
 79445: bool     
     1: nsSelectionState::IsEmpty()
     1: {
 27986:   return mArray.IsEmpty();
     1: }
     1: 
     1: /***************************************************************************
     1:  * nsRangeUpdater:  class for updating nsIDOMRanges in response to editor actions.
     1:  */
     1: 
 80486: nsRangeUpdater::nsRangeUpdater() : mArray(), mLock(false) {}
     1: 
     1: nsRangeUpdater::~nsRangeUpdater()
     1: {
     1:   // nothing to do, we don't own the items in our array.
     1: }
     1:   
     1: void 
     1: nsRangeUpdater::RegisterRangeItem(nsRangeStore *aRangeItem)
     1: {
     1:   if (!aRangeItem) return;
 27986:   if (mArray.Contains(aRangeItem))
     1:   {
     1:     NS_ERROR("tried to register an already registered range");
     1:     return;  // don't register it again.  It would get doubly adjusted.
     1:   }
     1:   mArray.AppendElement(aRangeItem);
     1: }
     1: 
     1: void 
     1: nsRangeUpdater::DropRangeItem(nsRangeStore *aRangeItem)
     1: {
     1:   if (!aRangeItem) return;
     1:   mArray.RemoveElement(aRangeItem);
     1: }
     1: 
     1: nsresult 
     1: nsRangeUpdater::RegisterSelectionState(nsSelectionState &aSelState)
     1: {
 27986:   PRUint32 i, theCount = aSelState.mArray.Length();
     1:   if (theCount < 1) return NS_ERROR_FAILURE;
     1: 
     1:   for (i=0; i<theCount; i++)
     1:   {
104447:     RegisterRangeItem(aSelState.mArray[i]);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult 
     1: nsRangeUpdater::DropSelectionState(nsSelectionState &aSelState)
     1: {
 27986:   PRUint32 i, theCount = aSelState.mArray.Length();
     1:   if (theCount < 1) return NS_ERROR_FAILURE;
     1: 
     1:   for (i=0; i<theCount; i++)
     1:   {
104447:     DropRangeItem(aSelState.mArray[i]);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // gravity methods:
     1: 
     1: nsresult
     1: nsRangeUpdater::SelAdjCreateNode(nsIDOMNode *aParent, PRInt32 aPosition)
     1: {
     1:   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
 43806:   NS_ENSURE_TRUE(aParent, NS_ERROR_NULL_POINTER);
 27986:   PRUint32 i, count = mArray.Length();
 46408:   if (!count) {
 46408:     return NS_OK;
 46408:   }
     1: 
     1:   nsRangeStore *item;
     1:   
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
 43806:     NS_ENSURE_TRUE(item, NS_ERROR_NULL_POINTER);
     1:     
     1:     if ((item->startNode.get() == aParent) && (item->startOffset > aPosition))
     1:       item->startOffset++;
     1:     if ((item->endNode.get() == aParent) && (item->endOffset > aPosition))
     1:       item->endOffset++;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsRangeUpdater::SelAdjInsertNode(nsIDOMNode *aParent, PRInt32 aPosition)
     1: {
     1:   return SelAdjCreateNode(aParent, aPosition);
     1: }
     1: 
103678: void
     1: nsRangeUpdater::SelAdjDeleteNode(nsIDOMNode *aNode)
     1: {
103678:   if (mLock) {
103678:     // lock set by Will/DidReplaceParent, etc...
103678:     return;
103678:   }
103678:   MOZ_ASSERT(aNode);
 27986:   PRUint32 i, count = mArray.Length();
 47313:   if (!count) {
103678:     return;
 47313:   }
     1: 
     1:   PRInt32 offset = 0;
103950:   nsCOMPtr<nsIDOMNode> parent = nsEditor::GetNodeLocation(aNode, &offset);
     1:   
     1:   // check for range endpoints that are after aNode and in the same parent
     1:   nsRangeStore *item;
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
103678:     MOZ_ASSERT(item);
     1:     
     1:     if ((item->startNode.get() == parent) && (item->startOffset > offset))
     1:       item->startOffset--;
     1:     if ((item->endNode.get() == parent) && (item->endOffset > offset))
     1:       item->endOffset--;
     1:       
     1:     // check for range endpoints that are in aNode
     1:     if (item->startNode == aNode)
     1:     {
     1:       item->startNode   = parent;
     1:       item->startOffset = offset;
     1:     }
     1:     if (item->endNode == aNode)
     1:     {
     1:       item->endNode   = parent;
     1:       item->endOffset = offset;
     1:     }
     1: 
     1:     // check for range endpoints that are in descendants of aNode
     1:     nsCOMPtr<nsIDOMNode> oldStart;
     1:     if (nsEditorUtils::IsDescendantOf(item->startNode, aNode))
     1:     {
     1:       oldStart = item->startNode;  // save for efficiency hack below.
     1:       item->startNode   = parent;
     1:       item->startOffset = offset;
     1:     }
     1: 
     1:     // avoid having to call IsDescendantOf() for common case of range startnode == range endnode.
     1:     if ((item->endNode == oldStart) || nsEditorUtils::IsDescendantOf(item->endNode, aNode))
     1:     {
     1:       item->endNode   = parent;
     1:       item->endOffset = offset;
     1:     }
     1:   }
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::SelAdjSplitNode(nsIDOMNode *aOldRightNode, PRInt32 aOffset, nsIDOMNode *aNewLeftNode)
     1: {
     1:   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
 43806:   NS_ENSURE_TRUE(aOldRightNode && aNewLeftNode, NS_ERROR_NULL_POINTER);
 27986:   PRUint32 i, count = mArray.Length();
 47313:   if (!count) {
 47313:     return NS_OK;
 47313:   }
     1: 
     1:   PRInt32 offset;
103950:   nsCOMPtr<nsIDOMNode> parent = nsEditor::GetNodeLocation(aOldRightNode, &offset);
     1:   
     1:   // first part is same as inserting aNewLeftnode
103678:   nsresult result = SelAdjInsertNode(parent,offset-1);
 43805:   NS_ENSURE_SUCCESS(result, result);
     1: 
     1:   // next step is to check for range enpoints inside aOldRightNode
     1:   nsRangeStore *item;
     1:   
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
 43806:     NS_ENSURE_TRUE(item, NS_ERROR_NULL_POINTER);
     1:     
     1:     if (item->startNode.get() == aOldRightNode)
     1:     {
     1:       if (item->startOffset > aOffset)
     1:       {
     1:         item->startOffset -= aOffset;
     1:       }
     1:       else
     1:       {
     1:         item->startNode = aNewLeftNode;
     1:       }
     1:     }
     1:     if (item->endNode.get() == aOldRightNode)
     1:     {
     1:       if (item->endOffset > aOffset)
     1:       {
     1:         item->endOffset -= aOffset;
     1:       }
     1:       else
     1:       {
     1:         item->endNode = aNewLeftNode;
     1:       }
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::SelAdjJoinNodes(nsIDOMNode *aLeftNode, 
     1:                                   nsIDOMNode *aRightNode, 
     1:                                   nsIDOMNode *aParent, 
     1:                                   PRInt32 aOffset,
     1:                                   PRInt32 aOldLeftNodeLength)
     1: {
     1:   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
 43806:   NS_ENSURE_TRUE(aLeftNode && aRightNode && aParent, NS_ERROR_NULL_POINTER);
 27986:   PRUint32 i, count = mArray.Length();
 47313:   if (!count) {
 47313:     return NS_OK;
 47313:   }
     1: 
     1:   nsRangeStore *item;
     1: 
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
 43806:     NS_ENSURE_TRUE(item, NS_ERROR_NULL_POINTER);
     1:     
     1:     if (item->startNode.get() == aParent)
     1:     {
     1:       // adjust start point in aParent
     1:       if (item->startOffset > aOffset)
     1:       {
     1:         item->startOffset--;
     1:       }
     1:       else if (item->startOffset == aOffset)
     1:       {
     1:         // join keeps right hand node
     1:         item->startNode = aRightNode;
     1:         item->startOffset = aOldLeftNodeLength;
     1:       }
     1:     }
     1:     else if (item->startNode.get() == aRightNode)
     1:     {
     1:       // adjust start point in aRightNode
     1:       item->startOffset += aOldLeftNodeLength;
     1:     }
     1:     else if (item->startNode.get() == aLeftNode)
     1:     {
     1:       // adjust start point in aLeftNode
     1:       item->startNode = aRightNode;
     1:     }
     1: 
     1:     if (item->endNode.get() == aParent)
     1:     {
     1:       // adjust end point in aParent
     1:       if (item->endOffset > aOffset)
     1:       {
     1:         item->endOffset--;
     1:       }
     1:       else if (item->endOffset == aOffset)
     1:       {
     1:         // join keeps right hand node
     1:         item->endNode = aRightNode;
     1:         item->endOffset = aOldLeftNodeLength;
     1:       }
     1:     }
     1:     else if (item->endNode.get() == aRightNode)
     1:     {
     1:       // adjust end point in aRightNode
     1:        item->endOffset += aOldLeftNodeLength;
     1:     }
     1:     else if (item->endNode.get() == aLeftNode)
     1:     {
     1:       // adjust end point in aLeftNode
     1:       item->endNode = aRightNode;
     1:     }
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::SelAdjInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, const nsAString &aString)
     1: {
     1:   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
     1: 
 27986:   PRUint32 count = mArray.Length();
 47313:   if (!count) {
 47313:     return NS_OK;
 47313:   }
     1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aTextNode));
 43806:   NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER);
     1:   
 27986:   PRUint32 len=aString.Length(), i;
     1:   nsRangeStore *item;
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
 43806:     NS_ENSURE_TRUE(item, NS_ERROR_NULL_POINTER);
     1:     
     1:     if ((item->startNode.get() == node) && (item->startOffset > aOffset))
     1:       item->startOffset += len;
     1:     if ((item->endNode.get() == node) && (item->endOffset > aOffset))
     1:       item->endOffset += len;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::SelAdjDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, PRInt32 aLength)
     1: {
     1:   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
     1: 
 27986:   PRUint32 i, count = mArray.Length();
 47313:   if (!count) {
 47313:     return NS_OK;
 47313:   }
     1:   nsRangeStore *item;
     1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aTextNode));
 43806:   NS_ENSURE_TRUE(node, NS_ERROR_NULL_POINTER);
     1:   
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
 43806:     NS_ENSURE_TRUE(item, NS_ERROR_NULL_POINTER);
     1:     
     1:     if ((item->startNode.get() == node) && (item->startOffset > aOffset))
     1:     {
     1:       item->startOffset -= aLength;
     1:       if (item->startOffset < 0) item->startOffset = 0;
     1:     }
     1:     if ((item->endNode.get() == node) && (item->endOffset > aOffset))
     1:     {
     1:       item->endOffset -= aLength;
     1:       if (item->endOffset < 0) item->endOffset = 0;
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::WillReplaceContainer()
     1: {
     1:   if (mLock) return NS_ERROR_UNEXPECTED;  
 80486:   mLock = true;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::DidReplaceContainer(nsIDOMNode *aOriginalNode, nsIDOMNode *aNewNode)
     1: {
 43806:   NS_ENSURE_TRUE(mLock, NS_ERROR_UNEXPECTED);  
 80486:   mLock = false;
     1: 
 43806:   NS_ENSURE_TRUE(aOriginalNode && aNewNode, NS_ERROR_NULL_POINTER);
 27986:   PRUint32 i, count = mArray.Length();
 47313:   if (!count) {
 47313:     return NS_OK;
 47313:   }
     1: 
     1:   nsRangeStore *item;
     1:   
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
 43806:     NS_ENSURE_TRUE(item, NS_ERROR_NULL_POINTER);
     1:     
     1:     if (item->startNode.get() == aOriginalNode)
     1:       item->startNode = aNewNode;
     1:     if (item->endNode.get() == aOriginalNode)
     1:       item->endNode = aNewNode;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::WillRemoveContainer()
     1: {
     1:   if (mLock) return NS_ERROR_UNEXPECTED;  
 80486:   mLock = true;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::DidRemoveContainer(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aOffset, PRUint32 aNodeOrigLen)
     1: {
 43806:   NS_ENSURE_TRUE(mLock, NS_ERROR_UNEXPECTED);  
 80486:   mLock = false;
     1: 
 43806:   NS_ENSURE_TRUE(aNode && aParent, NS_ERROR_NULL_POINTER);
 27986:   PRUint32 i, count = mArray.Length();
 47313:   if (!count) {
 47313:     return NS_OK;
 47313:   }
     1: 
     1:   nsRangeStore *item;
     1:   
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
 43806:     NS_ENSURE_TRUE(item, NS_ERROR_NULL_POINTER);
     1:     
     1:     if (item->startNode.get() == aNode)
     1:     {
     1:       item->startNode = aParent;
     1:       item->startOffset += aOffset;
     1:     }
     1:     else if ((item->startNode.get() == aParent) && (item->startOffset > aOffset))
     1:       item->startOffset += (PRInt32)aNodeOrigLen-1;
     1:       
     1:     if (item->endNode.get() == aNode)
     1:     {
     1:       item->endNode = aParent;
     1:       item->endOffset += aOffset;
     1:     }
     1:     else if ((item->endNode.get() == aParent) && (item->endOffset > aOffset))
     1:       item->endOffset += (PRInt32)aNodeOrigLen-1;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::WillInsertContainer()
     1: {
     1:   if (mLock) return NS_ERROR_UNEXPECTED;  
 80486:   mLock = true;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::DidInsertContainer()
     1: {
 43806:   NS_ENSURE_TRUE(mLock, NS_ERROR_UNEXPECTED);  
 80486:   mLock = false;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::WillMoveNode()
     1: {
     1:   if (mLock) return NS_ERROR_UNEXPECTED;  
 80486:   mLock = true;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsRangeUpdater::DidMoveNode(nsIDOMNode *aOldParent, PRInt32 aOldOffset, nsIDOMNode *aNewParent, PRInt32 aNewOffset)
     1: {
 43806:   NS_ENSURE_TRUE(mLock, NS_ERROR_UNEXPECTED);  
 80486:   mLock = false;
     1: 
 43806:   NS_ENSURE_TRUE(aOldParent && aNewParent, NS_ERROR_NULL_POINTER);
 27986:   PRUint32 i, count = mArray.Length();
 47313:   if (!count) {
 47313:     return NS_OK;
 47313:   }
     1: 
     1:   nsRangeStore *item;
     1:   
     1:   for (i=0; i<count; i++)
     1:   {
 27986:     item = mArray[i];
 43806:     NS_ENSURE_TRUE(item, NS_ERROR_NULL_POINTER);
     1:     
     1:     // like a delete in aOldParent
     1:     if ((item->startNode.get() == aOldParent) && (item->startOffset > aOldOffset))
     1:       item->startOffset--;
     1:     if ((item->endNode.get() == aOldParent) && (item->endOffset > aOldOffset))
     1:       item->endOffset--;
     1:       
     1:     // and like an insert in aNewParent
     1:     if ((item->startNode.get() == aNewParent) && (item->startOffset > aNewOffset))
     1:       item->startOffset++;
     1:     if ((item->endNode.get() == aNewParent) && (item->endOffset > aNewOffset))
     1:       item->endOffset++;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: 
     1: /***************************************************************************
     1:  * helper class for nsSelectionState.  nsRangeStore stores range endpoints.
     1:  */
     1: 
     1:   // DEBUG: PRInt32 nsRangeStore::n = 0;
     1: 
     1: nsRangeStore::nsRangeStore() 
     1: { 
     1:   // DEBUG: n++;  printf("range store alloc count=%d\n", n); 
     1: }
     1: nsRangeStore::~nsRangeStore()
     1: {
     1:   // DEBUG: n--;  printf("range store alloc count=%d\n", n); 
     1: }
     1: 
     1: nsresult nsRangeStore::StoreRange(nsIDOMRange *aRange)
     1: {
 43806:   NS_ENSURE_TRUE(aRange, NS_ERROR_NULL_POINTER);
     1:   aRange->GetStartContainer(getter_AddRefs(startNode));
     1:   aRange->GetEndContainer(getter_AddRefs(endNode));
     1:   aRange->GetStartOffset(&startOffset);
     1:   aRange->GetEndOffset(&endOffset);
     1:   return NS_OK;
     1: }
     1: 
 86939: nsresult nsRangeStore::GetRange(nsRange** outRange)
     1: {
 87303:   return nsRange::CreateRange(startNode, startOffset, endNode, endOffset,
 87303:                               outRange);
     1: }
