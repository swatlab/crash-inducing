33964: /* vim: se cin sw=2 ts=2 et filetype=javascript :
33489:  * ***** BEGIN LICENSE BLOCK *****
33489:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33489:  *
33489:  * The contents of this file are subject to the Mozilla Public License Version
33489:  * 1.1 (the "License"); you may not use this file except in compliance with
33489:  * the License. You may obtain a copy of the License at
33489:  * http://www.mozilla.org/MPL/
33489:  *
33489:  * Software distributed under the License is distributed on an "AS IS" basis,
33489:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33489:  * for the specific language governing rights and limitations under the
33489:  * License.
33489:  *
33489:  * The Original Code is Mozilla code.
33489:  *
33489:  * The Initial Developer of the Original Code is
33489:  * Mozilla Corporation.
33489:  * Portions created by the Initial Developer are Copyright (C) 2009
33489:  * the Initial Developer. All Rights Reserved.
33489:  *
33489:  * Contributor(s):
33489:  *    Rob Arnold <robarnold@cmu.edu> (original author)
33489:  *
33489:  * Alternatively, the contents of this file may be used under the terms of
33489:  * either the GNU General Public License Version 2 or later (the "GPL"), or
33489:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33489:  * in which case the provisions of the GPL or the LGPL are applicable instead
33489:  * of those above. If you wish to allow use of your version of this file only
33489:  * under the terms of either the GPL or the LGPL, and not to allow others to
33489:  * use your version of this file under the terms of the MPL, indicate your
33489:  * decision by deleting the provisions above and replace them with the notice
33489:  * and other provisions required by the GPL or the LGPL. If you do not delete
33489:  * the provisions above, a recipient may use your version of this file under
33489:  * the terms of any one of the MPL, the GPL or the LGPL.
33489:  *
33489:  * ***** END LICENSE BLOCK ***** */
33489: /*
33489:  * This module implements the front end behavior for AeroPeek. Starting in
33489:  * Windows Vista, the taskbar began showing live thumbnail previews of windows
33489:  * when the user hovered over the window icon in the taskbar. Starting with
33489:  * Windows 7, the taskbar allows an application to expose its tabbed interface
33489:  * in the taskbar by showing thumbnail previews rather than the default window
33489:  * preview. Additionally, when a user hovers over a thumbnail (tab or window),
33489:  * they are shown a live preview of the window (or tab + its containing window).
33489:  *
33489:  * In Windows 7, a title, icon, close button and optional toolbar are shown for
33489:  * each preview. This feature does not make use of the toolbar. For window
33489:  * previews, the title is the window title and the icon the window icon. For
33489:  * tab previews, the title is the page title and the page's favicon. In both
33489:  * cases, the close button "does the right thing."
33489:  *
33489:  * The primary objects behind this feature are nsITaskbarTabPreview and
33489:  * nsITaskbarPreviewController. Each preview has a controller. The controller
33489:  * responds to the user's interactions on the taskbar and provides the required
33489:  * data to the preview for determining the size of the tab and thumbnail. The
33489:  * PreviewController class implements this interface. The preview will request
33489:  * the controller to provide a thumbnail or preview when the user interacts with
33489:  * the taskbar. To reduce the overhead of drawing the tab area, the controller
33489:  * implementation caches the tab's contents in a <canvas> element. If no
33489:  * previews or thumbnails have been requested for some time, the controller will
33489:  * discard its cached tab contents.
33489:  *
33489:  * Screen real estate is limited so when there are too many thumbnails to fit
33489:  * on the screen, the taskbar stops displaying thumbnails and instead displays
33489:  * just the title, icon and close button in a similar fashion to previous
33489:  * versions of the taskbar. If there are still too many previews to fit on the 
33489:  * screen, the taskbar resorts to a scroll up and scroll down button pair to let
33489:  * the user scroll through the list of tabs. Since this is undoubtedly
33489:  * inconvenient for users with many tabs, the AeroPeek objects turns off all of
33489:  * the tab previews. This tells the taskbar to revert to one preview per window.
33489:  * If the number of tabs falls below this magic threshold, the preview-per-tab
33489:  * behavior returns. There is no reliable way to determine when the scroll
33489:  * buttons appear on the taskbar, so a magic pref-controlled number determines
33489:  * when this threshold has been crossed.
33489:  */
33489: var EXPORTED_SYMBOLS = ["AeroPeek"];
33489: 
33489: const Cc = Components.classes;
33489: const Ci = Components.interfaces;
33489: const Cu = Components.utils;
33489: 
33489: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
33489: Cu.import("resource://gre/modules/NetUtil.jsm");
33489: 
33489: // Pref to enable/disable preview-per-tab
33513: const TOGGLE_PREF_NAME = "browser.taskbar.previews.enable";
33489: // Pref to determine the magic auto-disable threshold
33513: const DISABLE_THRESHOLD_PREF_NAME = "browser.taskbar.previews.max";
33489: // Pref to control the time in seconds that tab contents live in the cache
33513: const CACHE_EXPIRATION_TIME_PREF_NAME = "browser.taskbar.previews.cachetime";
33489: 
33489: const WINTASKBAR_CONTRACTID = "@mozilla.org/windows-taskbar;1";
33489: 
33489: ////////////////////////////////////////////////////////////////////////////////
33489: //// Various utility properties
33489: XPCOMUtils.defineLazyServiceGetter(this, "ioSvc",
33489:                                    "@mozilla.org/network/io-service;1",
33489:                                    "nsIIOService");
33489: XPCOMUtils.defineLazyServiceGetter(this, "imgTools",
33489:                                    "@mozilla.org/image/tools;1",
33489:                                    "imgITools");
33489: XPCOMUtils.defineLazyServiceGetter(this, "faviconSvc",
33489:                                    "@mozilla.org/browser/favicon-service;1",
33489:                                    "nsIFaviconService");
33489: 
33489: // nsIURI -> imgIContainer
33964: function _imageFromURI(uri, callback) {
33489:   let channel = ioSvc.newChannelFromURI(uri);
33964:   NetUtil.asyncFetch(channel, function(inputStream, resultCode) {
33964:     if (!Components.isSuccessCode(resultCode))
33964:       return;
33964:     try {
33489:       let out_img = { value: null };
33489:       imgTools.decodeImageData(inputStream, channel.contentType, out_img);
33964:       callback(out_img.value);
33489:     } catch (e) {
33964:       // We failed, so use the default favicon (only if this wasn't the default
33964:       // favicon).
33964:       let defaultURI = faviconSvc.defaultFavicon;
33964:       if (!defaultURI.equals(uri))
33964:         _imageFromURI(defaultURI, callback);
33489:     }
33964:   });
33489: }
33489: 
33489: // string? -> imgIContainer
33964: function getFaviconAsImage(iconurl, callback) {
33964:   if (iconurl)
33964:     _imageFromURI(NetUtil.newURI(iconurl), callback);
33964:   else
33964:     _imageFromURI(faviconSvc.defaultFavicon, callback);
33489: }
33489: 
33489: ////////////////////////////////////////////////////////////////////////////////
33489: //// PreviewController
33489: 
33489: /*
33489:  * This class manages the behavior of the preview.
33489:  *
33489:  * To give greater performance when drawing, the dirty areas of the content
33489:  * window are tracked and drawn on demand into a canvas of the same size.
33489:  * This provides a great increase in responsiveness when drawing a preview
33489:  * for unchanged (or even only slightly changed) tabs.
33489:  *
33489:  * @param win
33489:  *        The TabWindow (see below) that owns the preview that this controls
33489:  * @param tab
33489:  *        The <tab> that this preview is associated with
33489:  */
33489: function PreviewController(win, tab) {
33489:   this.win = win;
33489:   this.tab = tab;
33489:   this.linkedBrowser = tab.linkedBrowser;
33489: 
33489:   this.linkedBrowser.addEventListener("MozAfterPaint", this, false);
33489:   this.linkedBrowser.addEventListener("DOMTitleChanged", this, false);
33489:   // pageshow is needed for when a tab is dragged across windows.
33489:   this.linkedBrowser.addEventListener("pageshow", this, false);
33489: 
33489:   // Cannot perform the lookup during construction. See TabWindow.newTab 
33489:   XPCOMUtils.defineLazyGetter(this, "preview", function () this.win.previewFromTab(this.tab));
33489: 
33489:   XPCOMUtils.defineLazyGetter(this, "canvasPreview", function ()
33489:     this.win.win.document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"));
33489: 
33489:   XPCOMUtils.defineLazyGetter(this, "dirtyRegion",
33489:     function () {
33489:       let dirtyRegion = Cc["@mozilla.org/gfx/region;1"]
33489:                        .createInstance(Ci.nsIScriptableRegion);
33489:       dirtyRegion.init();
33489:       return dirtyRegion;
33489:     });
33489: }
33489: 
33489: PreviewController.prototype = {
33489:   QueryInterface: XPCOMUtils.generateQI([Ci.nsITaskbarPreviewController,
33489:                                          Ci.nsIDOMEventListener]),
33489:   destroy: function () {
33489:     this.linkedBrowser.removeEventListener("pageshow", this, false);
33489:     this.linkedBrowser.removeEventListener("DOMTitleChanged", this, false);
33489:     this.linkedBrowser.removeEventListener("MozAfterPaint", this, false);
33489:   },
33489:   get wrappedJSObject() {
33489:     return this;
33489:   },
33489: 
33489:   get dirtyRects() {
33489:     let rectstream = this.dirtyRegion.getRects();
33489:     if (!rectstream)
33489:       return [];
33489:     let rects = [];
33489:     for (let i = 0; i < rectstream.length; i+= 4) {
33489:       let r = {x:      rectstream[i],
33489:                y:      rectstream[i+1],
33489:                width:  rectstream[i+2],
33489:                height: rectstream[i+3]};
33489:       rects.push(r);
33489:     }
33489:     return rects;
33489:   },
33489: 
33489:   // Resizes the canvasPreview to 0x0, essentially freeing its memory.
33489:   // updateCanvasPreview() will detect the size mismatch as a resize event
33489:   // the next time it is called.
33489:   resetCanvasPreview: function () {
33489:     this.canvasPreview.width = 0;
33489:     this.canvasPreview.height = 0;
33489:   },
33489: 
33489:   // Updates the controller's canvas with the parts of the <browser> that need
33489:   // to be redrawn.
33489:   updateCanvasPreview: function () {
33489:     let win = this.linkedBrowser.contentWindow;
33489:     let bx = this.linkedBrowser.boxObject;
33489:     // Check for resize
33489:     if (bx.width != this.canvasPreview.width ||
33489:         bx.height != this.canvasPreview.height) {
33489:       // Invalidate the entire area and repaint
33489:       this.onTabPaint({left:0, top:0, width:bx.width, height:bx.height});
33489:       this.canvasPreview.width = bx.width;
33489:       this.canvasPreview.height = bx.height;
33489:     }
33489: 
33489:     // Draw dirty regions
33489:     let ctx = this.canvasPreview.getContext("2d");
33489:     let flags = this.canvasPreviewFlags;
33489:     // width/height are occasionally bogus and too large for drawWindow
33489:     // so we clip to the canvas region
33489:     this.dirtyRegion.intersectRect(0, 0, bx.width, bx.height);
33673:     this.dirtyRects.forEach(function (r) {
33489:       let x = r.x;
33489:       let y = r.y;
33489:       let width = r.width;
33489:       let height = r.height;
33489:       ctx.save();
33489:       ctx.translate(x, y);
33489:       ctx.drawWindow(win, x, y, width, height, "white", flags);
33489:       ctx.restore();
33673:     });
33489:     this.dirtyRegion.setToRect(0,0,0,0);
33489: 
33489:     // If we're updating the canvas, then we're in the middle of a peek so
33489:     // don't discard the cache of previews.
33489:     AeroPeek.resetCacheTimer();
33489:   },
33489: 
33489:   onTabPaint: function (rect) {
33489:     // Ignore spurious dirty rects
33489:     if (!rect.width || !rect.height)
33489:       return;
33489: 
33489:     let r = { x: Math.floor(rect.left),
33489:               y: Math.floor(rect.top),
33489:               width: Math.ceil(rect.width),
33489:               height: Math.ceil(rect.height)
33489:             };
33489:     this.dirtyRegion.unionRect(r.x, r.y, r.width, r.height);
33489:   },
33489: 
39174:   updateTitleAndTooltip: function () {
39174:     let title = this.win.tabbrowser.getWindowTitleForBrowser(this.linkedBrowser);
39174:     this.preview.title = title;
39174:     this.preview.tooltip = title;
39174:   },
39174: 
33489:   //////////////////////////////////////////////////////////////////////////////
33489:   //// nsITaskbarPreviewController 
33489: 
33489:   get width() {
33489:     return this.win.width;
33489:   },
33489: 
33489:   get height() {
33489:     return this.win.height;
33489:   },
33489: 
33489:   get thumbnailAspectRatio() {
33489:     let boxObject = this.tab.linkedBrowser.boxObject;
33489:     // Avoid returning 0
33489:     let tabWidth = boxObject.width || 1;
33489:     // Avoid divide by 0
33489:     let tabHeight = boxObject.height || 1;
33489:     return tabWidth / tabHeight;
33489:   },
33489: 
33489:   drawPreview: function (ctx) {
33489:     let self = this;
33489:     this.win.tabbrowser.previewTab(this.tab, function () self.previewTabCallback(ctx));
33489: 
39175:     // We must avoid having the frame drawn around the window. See bug 520807
39175:     return false;
33489:   },
33489: 
33489:   previewTabCallback: function (ctx) {
33489:     let width = this.win.width;
33489:     let height = this.win.height;
33489:     // Draw our toplevel window
33489:     ctx.drawWindow(this.win.win, 0, 0, width, height, "transparent");
33489: 
33489:     // Compositor, where art thou?
33489:     // Draw the tab content on top of the toplevel window
33489:     this.updateCanvasPreview();
33489: 
33489:     let boxObject = this.linkedBrowser.boxObject;
33489:     ctx.translate(boxObject.x, boxObject.y);
33489:     ctx.drawImage(this.canvasPreview, 0, 0);
33489:   },
33489: 
33489:   drawThumbnail: function (ctx, width, height) {
33489:     this.updateCanvasPreview();
33489: 
33489:     let scale = width/this.linkedBrowser.boxObject.width;
33489:     ctx.scale(scale, scale);
33489:     ctx.drawImage(this.canvasPreview, 0, 0);
33489: 
33489:     // Don't draw a frame around the thumbnail
33489:     return false;
33489:   },
33489: 
33489:   onClose: function () {
33489:     this.win.tabbrowser.removeTab(this.tab);
33489:   },
33489: 
33489:   onActivate: function () {
33489:     this.win.tabbrowser.selectedTab = this.tab;
33489: 
33489:     // Accept activation - this will restore the browser window
33489:     // if it's minimized
33489:     return true;
33489:   },
33489: 
33489:   //// nsIDOMEventListener
33489:   handleEvent: function (evt) {
33489:     switch (evt.type) {
33489:       case "MozAfterPaint":
33489:         if (evt.originalTarget === this.linkedBrowser.contentWindow) {
33489:           let clientRects = evt.clientRects;
33489:           let length = clientRects.length;
33489:           for (let i = 0; i < length; i++) {
33489:             let r = clientRects.item(i);
33489:             this.onTabPaint(r);
33489:           }
33489:         }
33489:         let preview = this.preview;
33489:         if (preview.visible)
33489:           preview.invalidate();
33489:         break;
33489:       case "pageshow":
33489:       case "DOMTitleChanged":
33489:         // The tab's label is sometimes empty when dragging tabs between windows
33489:         // so we force the tab title to be updated (see bug 520579)
33489:         this.win.tabbrowser.setTabTitle(this.tab);
39174:         this.updateTitleAndTooltip();
33489:         break;
33489:     }
33489:   }
33489: };
33489: 
33489: XPCOMUtils.defineLazyGetter(PreviewController.prototype, "canvasPreviewFlags",
33489:   function () { let canvasInterface = Ci.nsIDOMCanvasRenderingContext2D;
33489:                 return canvasInterface.DRAWWINDOW_DRAW_VIEW
33489:                      | canvasInterface.DRAWWINDOW_DRAW_CARET
33489:                      | canvasInterface.DRAWWINDOW_DO_NOT_FLUSH;
33489: });
33489: 
33489: ////////////////////////////////////////////////////////////////////////////////
33489: //// TabWindow
33489: 
33489: /*
33489:  * This class monitors a browser window for changes to its tabs
33489:  *
33489:  * @param win
33489:  *        The nsIDOMWindow browser window 
33489:  */
33489: function TabWindow(win) {
33489:   this.win = win;
33489:   this.tabbrowser = win.gBrowser;
33489: 
33489:   this.previews = [];
33489: 
33673:   for (let i = 0; i < this.events.length; i++)
33673:     this.tabbrowser.tabContainer.addEventListener(this.events[i], this, false);
33489:   this.tabbrowser.addTabsProgressListener(this);
33489: 
39653: 
33489:   AeroPeek.windows.push(this);
33489:   let tabs = this.tabbrowser.mTabs;
33489:   for (let i = 0; i < tabs.length; i++)
33489:     this.newTab(tabs[i]);
33489: 
33489:   this.updateTabOrdering();
33489:   AeroPeek.checkPreviewCount();
33489: }
33489: 
33489: TabWindow.prototype = {
33489:   _enabled: false,
33489:   events: ["TabOpen", "TabClose", "TabSelect", "TabMove"],
33489: 
33489:   destroy: function () {
33621:     this._destroying = true;
33621: 
33489:     let tabs = this.tabbrowser.mTabs;
33489: 
33673:     for (let i = 0; i < this.events.length; i++)
33673:       this.tabbrowser.tabContainer.removeEventListener(this.events[i], this, false);
33511: 
33489:     for (let i = 0; i < tabs.length; i++)
33621:       this.removeTab(tabs[i]);
33489: 
33511:     let idx = AeroPeek.windows.indexOf(this.win.gTaskbarTabGroup);
33489:     AeroPeek.windows.splice(idx, 1);
33489:     AeroPeek.checkPreviewCount();
33489:   },
33489: 
33489:   get width () {
33489:     return this.win.innerWidth;
33489:   },
33489:   get height () {
33489:     return this.win.innerHeight;
33489:   },
33489: 
33489:   // Invoked when the given tab is added to this window
33489:   newTab: function (tab) {
33489:     let controller = new PreviewController(this, tab);
39179:     let docShell = this.win
39179:                   .QueryInterface(Ci.nsIInterfaceRequestor)
39179:                   .getInterface(Ci.nsIWebNavigation)
39179:                   .QueryInterface(Ci.nsIDocShell);
39179:     let preview = AeroPeek.taskbar.createTaskbarTabPreview(docShell, controller);
33489:     preview.visible = AeroPeek.enabled;
33489:     preview.active = this.tabbrowser.selectedTab == tab;
33489:     // Grab the default favicon
33964:     getFaviconAsImage(null, function (img) {
33964:       // It is possible that we've already gotten the real favicon, so make sure
33964:       // we have not set one before setting this default one.
33964:       if (!preview.icon)
33964:         preview.icon = img;
33964:     });
33489: 
33964:     // It's OK to add the preview now while the favicon still loads.
33489:     this.previews.splice(tab._tPos, 0, preview);
33489:     AeroPeek.addPreview(preview);
39174:     // updateTitleAndTooltip relies on having controller.preview which is lazily resolved.
39174:     // Now that we've updated this.previews, it will resolve successfully.
39174:     controller.updateTitleAndTooltip();
33489:   },
33489: 
33489:   // Invoked when the given tab is closed
33621:   removeTab: function (tab) {
33489:     let preview = this.previewFromTab(tab);
33489:     preview.active = false;
33489:     preview.visible = false;
33489:     preview.move(null);
33489:     preview.controller.wrappedJSObject.destroy();
33489: 
33511:     // We don't want to splice from the array if the tabs aren't being removed
33511:     // from the tab bar as well (as is the case when the window closes).
33621:     if (!this._destroying)
33489:       this.previews.splice(tab._tPos, 1);
33489:     AeroPeek.removePreview(preview);
33489:   },
33489: 
33489:   get enabled () {
33489:     return this._enabled;
33489:   },
33489: 
33489:   set enabled (enable) {
33489:     this._enabled = enable;
33489:     // Because making a tab visible requires that the tab it is next to be
33489:     // visible, it is far simpler to unset the 'next' tab and recreate them all
33489:     // at once.
33673:     this.previews.forEach(function (preview) {
33489:       preview.move(null);
33489:       preview.visible = enable;
33673:     });
33489:     this.updateTabOrdering();
33489:   },
33489: 
33489:   previewFromTab: function (tab) {
33489:     return this.previews[tab._tPos];
33489:   },
33489: 
33489:   updateTabOrdering: function () {
37982:     // Since the internal taskbar array has not yet been updated we must force
37982:     // on it the sorting order of our local array.  To do so we must walk
37982:     // the local array backwards, otherwise we would send move requests in the
37982:     // wrong order.  See bug 522610 for details.
37982:     for (let i = this.previews.length - 1; i >= 0; i--) {
33489:       let p = this.previews[i];
33489:       let next = i == this.previews.length - 1 ? null : this.previews[i+1];
33489:       p.move(next);
33489:     }
33489:   },
33489: 
33489:   //// nsIDOMEventListener
33489:   handleEvent: function (evt) {
33489:     let tab = evt.originalTarget;
33489:     switch (evt.type) {
33489:       case "TabOpen":
33489:         this.newTab(tab);
33489:         this.updateTabOrdering();
33489:         break;
33489:       case "TabClose":
33489:         this.removeTab(tab);
33489:         this.updateTabOrdering();
33489:         break;
33489:       case "TabSelect":
33489:         this.previewFromTab(tab).active = true;
33489:         break;
33489:       case "TabMove":
33489:         let oldPos = evt.detail;
33489:         let newPos = tab._tPos;
33489:         let preview = this.previews[oldPos];
33489:         this.previews.splice(oldPos, 1);
33489:         this.previews.splice(newPos, 0, preview);
33489:         this.updateTabOrdering();
33489:         break;
33489:     }
33489:   },
33489: 
33489:   //// Browser progress listener
33489:   onLocationChange: function () {
33489:   },
33489:   onProgressChange: function () {
33489:   },
33489:   onSecurityChange: function () {
33489:   },
33489:   onStateChange: function () {
33489:   },
33489:   onStatusChange: function () {
33489:   },
36203:   onLinkIconAvailable: function (aBrowser, aIconURL) {
33964:     let self = this;
36203:     getFaviconAsImage(aIconURL, function (img) {
33964:       let index = self.tabbrowser.browsers.indexOf(aBrowser);
33964:       // Only add it if we've found the index.  The tab could have closed!
33964:       if (index != -1)
33964:         self.previews[index].icon = img;
33964:     });
33489:   }
33489: }
33489: 
33489: ////////////////////////////////////////////////////////////////////////////////
33489: //// AeroPeek
33489: 
33489: /*
33489:  * This object acts as global storage and external interface for this feature.
33489:  * It maintains the values of the prefs.
33489:  */
33489: var AeroPeek = {
33489:   available: false,
33489:   // Does the pref say we're enabled?
33489:   _prefenabled: true,
33489: 
33489:   _enabled: true,
33489: 
33489:   // nsITaskbarTabPreview array
33489:   previews: [],
33489: 
33489:   // TabWindow array
33489:   windows: [],
33489: 
33489:   // nsIWinTaskbar service
33489:   taskbar: null,
33489: 
33489:   // Maximum number of previews
33489:   maxpreviews: 20,
33489: 
33489:   // Length of time in seconds that previews are cached
33489:   cacheLifespan: 20,
33489: 
33489:   initialize: function () {
33489:     if (!(WINTASKBAR_CONTRACTID in Cc))
33489:       return;
33489:     this.taskbar = Cc[WINTASKBAR_CONTRACTID].getService(Ci.nsIWinTaskbar);
33489:     this.available = this.taskbar.available;
33489:     if (!this.available)
33489:       return;
33489: 
33489:     this.prefs.addObserver(TOGGLE_PREF_NAME, this, false);
33489:     this.prefs.addObserver(DISABLE_THRESHOLD_PREF_NAME, this, false);
33489:     this.prefs.addObserver(CACHE_EXPIRATION_TIME_PREF_NAME, this, false);
33489: 
33489:     this.cacheLifespan = this.prefs.getIntPref(CACHE_EXPIRATION_TIME_PREF_NAME);
33489: 
33489:     this.maxpreviews = this.prefs.getIntPref(DISABLE_THRESHOLD_PREF_NAME);
33489: 
33489:     this.enabled = this._prefenabled = this.prefs.getBoolPref(TOGGLE_PREF_NAME);
33489:   },
33489: 
33489:   get enabled() {
33489:     return this._enabled;
33489:   },
33489: 
33489:   set enabled(enable) {
33673:     if (this._enabled == enable)
33673:       return;
33673: 
33489:     this._enabled = enable;
33489: 
33673:     this.windows.forEach(function (win) {
33489:       win.enabled = enable;
33673:     });
33489:   },
33489: 
33489:   addPreview: function (preview) {
33489:     this.previews.push(preview);
33489:     this.checkPreviewCount();
33489:   },
33489: 
33489:   removePreview: function (preview) {
33489:     let idx = this.previews.indexOf(preview);
33489:     this.previews.splice(idx, 1);
33489:     this.checkPreviewCount();
33489:   },
33489: 
33489:   checkPreviewCount: function () {
33489:     if (this.previews.length > this.maxpreviews)
33489:       this.enabled = false;
33489:     else
33489:       this.enabled = this._prefenabled;
33489:   },
33489: 
33489:   onOpenWindow: function (win) {
33489:     // This occurs when the taskbar service is not available (xp, vista)
33489:     if (!this.available)
33489:       return;
33489: 
33489:     win.gTaskbarTabGroup = new TabWindow(win);
33489:   },
33489: 
33489:   onCloseWindow: function (win) {
33489:     // This occurs when the taskbar service is not available (xp, vista)
33489:     if (!this.available)
33489:       return;
33489: 
33489:     win.gTaskbarTabGroup.destroy();
39653:     win.gTaskbarTabGroup = null;
33489:   },
33489: 
33489:   resetCacheTimer: function () {
33489:     this.cacheTimer.cancel();
33489:     this.cacheTimer.init(this, 1000*this.cacheLifespan, Ci.nsITimer.TYPE_ONE_SHOT);
33489:   },
33489: 
33489:   //// nsIObserver
33489:   observe: function (aSubject, aTopic, aData) {
33489:     switch (aTopic) {
33489:       case "nsPref:changed":
33621:         if (aData == CACHE_EXPIRATION_TIME_PREF_NAME)
33489:           break;
33621: 
33489:         if (aData == TOGGLE_PREF_NAME)
33489:           this._prefenabled = this.prefs.getBoolPref(TOGGLE_PREF_NAME);
33489:         else if (aData == DISABLE_THRESHOLD_PREF_NAME)
33489:           this.maxpreviews = this.prefs.getIntPref(DISABLE_THRESHOLD_PREF_NAME);
33489:         // Might need to enable/disable ourselves
33489:         this.checkPreviewCount();
33489:         break;
33489:       case "timer-callback":
33673:         this.previews.forEach(function (preview) {
33489:           let controller = preview.controller.wrappedJSObject;
33489:           controller.resetCanvasPreview();
33673:         });
33489:         break;
33489:     }
33489:   }
33489: };
33489: 
33489: XPCOMUtils.defineLazyGetter(AeroPeek, "cacheTimer", function ()
33489:   Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer)
33489: );
33489: 
33489: XPCOMUtils.defineLazyServiceGetter(AeroPeek, "prefs",
33489:                                    "@mozilla.org/preferences-service;1",
33489:                                    "nsIPrefBranch2");
33489: 
33489: AeroPeek.initialize();
