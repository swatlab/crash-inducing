42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2010
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Vladimir Vukicevic <vladimir@pobox.com>
42611:  *   Bas Schouten <bschouten@mozilla.com>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
42611: #include "CanvasLayerD3D9.h"
42611: 
42611: #include "gfxImageSurface.h"
42611: #include "gfxWindowsSurface.h"
52175: #include "gfxWindowsPlatform.h"
42611: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
42611: CanvasLayerD3D9::~CanvasLayerD3D9()
42611: {
53784:   if (mD3DManager->deviceManager()) {
53784:     mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
53784:   }
42611: }
42611: 
42611: void
42611: CanvasLayerD3D9::Initialize(const Data& aData)
42611: {
42611:   NS_ASSERTION(mSurface == nsnull, "BasicCanvasLayer::Initialize called twice!");
42611: 
42611:   if (aData.mSurface) {
42611:     mSurface = aData.mSurface;
42611:     NS_ASSERTION(aData.mGLContext == nsnull,
42611:                  "CanvasLayer can't have both surface and GLContext");
42611:     mNeedsYFlip = PR_FALSE;
51316:     mDataIsPremultiplied = PR_TRUE;
42611:   } else if (aData.mGLContext) {
47909:     NS_ASSERTION(aData.mGLContext->IsOffscreen(), "canvas gl context isn't offscreen");
42611:     mGLContext = aData.mGLContext;
47909:     mCanvasFramebuffer = mGLContext->GetOffscreenFBO();
51316:     mDataIsPremultiplied = aData.mGLBufferIsPremultiplied;
42611:     mNeedsYFlip = PR_TRUE;
42611:   } else {
42611:     NS_ERROR("CanvasLayer created without mSurface or mGLContext?");
42611:   }
42611: 
42611:   mBounds.SetRect(0, 0, aData.mSize.width, aData.mSize.height);
42611: 
52175:   if (mSurface && mSurface->GetType() == gfxASurface::SurfaceTypeD2D) {
52175:     void *data = mSurface->GetData(&gKeyD3D9Texture);
52175:     if (data) {
52175:       mTexture = static_cast<IDirect3DTexture9*>(data);
52175:       mIsInteropTexture = true;
52175:       return;
52175:     }
52175:   }
52175: 
52175:   mIsInteropTexture = false;
52175: 
53785:   CreateTexture();
49317: }
42611: 
42611: void
42611: CanvasLayerD3D9::Updated(const nsIntRect& aRect)
42611: {
42611:   if (!mTexture) {
53785:     CreateTexture();
42611:     NS_WARNING("CanvasLayerD3D9::Updated called but no texture present!");
42611:     return;
42611:   }
42611: 
52175: #ifdef CAIRO_HAS_D2D_SURFACE
52175:   if (mIsInteropTexture) {
52175:     mSurface->Flush();
52175:     cairo_d2d_finish_device(gfxWindowsPlatform::GetPlatform()->GetD2DDevice());
52175:     return;
52175:   }
52175: #endif
52175: 
42611:   if (mGLContext) {
42611:     // WebGL reads entire surface.
42611:     D3DLOCKED_RECT r;
53786:     HRESULT hr = mTexture->LockRect(0, &r, NULL, 0);
53786: 
53786:     if (FAILED(hr)) {
53786:       NS_WARNING("Failed to lock CanvasLayer texture.");
53786:       return;
53786:     }
42611: 
42611:     PRUint8 *destination;
42611:     if (r.Pitch != mBounds.width * 4) {
42611:       destination = new PRUint8[mBounds.width * mBounds.height * 4];
42611:     } else {
42611:       destination = (PRUint8*)r.pBits;
42611:     }
42611: 
42611:     // We have to flush to ensure that any buffered GL operations are
42611:     // in the framebuffer before we read.
42611:     mGLContext->fFlush();
42611: 
47909:     PRUint32 currentFramebuffer = 0;
47909: 
47909:     mGLContext->fGetIntegerv(LOCAL_GL_FRAMEBUFFER_BINDING, (GLint*)&currentFramebuffer);
47909: 
47909:     // Make sure that we read pixels from the correct framebuffer, regardless
47909:     // of what's currently bound.
47909:     if (currentFramebuffer != mCanvasFramebuffer)
47909:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mCanvasFramebuffer);
47909: 
42611:     // For simplicity, we read the entire framebuffer for now -- in
42611:     // the future we should use aRect, though with WebGL we don't
42611:     // have an easy way to generate one.
49076:     nsRefPtr<gfxImageSurface> tmpSurface =
49076:       new gfxImageSurface(destination,
49076:                           gfxIntSize(mBounds.width, mBounds.height),
49076:                           mBounds.width * 4,
49076:                           gfxASurface::ImageFormatARGB32);
49076:     mGLContext->ReadPixelsIntoImageSurface(0, 0,
49076:                                            mBounds.width, mBounds.height,
49076:                                            tmpSurface);
49076:     tmpSurface = nsnull;
42611: 
47909:     // Put back the previous framebuffer binding.
47909:     if (currentFramebuffer != mCanvasFramebuffer)
47909:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, currentFramebuffer);
47909: 
42611:     if (r.Pitch != mBounds.width * 4) {
42611:       for (int y = 0; y < mBounds.height; y++) {
42611:         memcpy((PRUint8*)r.pBits + r.Pitch * y,
42611:                destination + mBounds.width * 4 * y,
42611:                mBounds.width * 4);
42611:       }
42611:       delete [] destination;
42611:     }
42611:     mTexture->UnlockRect(0);
42611:   } else if (mSurface) {
42611:     RECT r;
42611:     r.left = aRect.x;
42611:     r.top = aRect.y;
42611:     r.right = aRect.XMost();
42611:     r.bottom = aRect.YMost();
42611: 
42611:     D3DLOCKED_RECT lockedRect;
53786:     HRESULT hr = mTexture->LockRect(0, &lockedRect, &r, 0);
53786: 
53786:     if (FAILED(hr)) {
53786:       NS_WARNING("Failed to lock CanvasLayer texture.");
53786:       return;
53786:     }
42611: 
42611:     PRUint8 *startBits;
42611:     PRUint32 sourceStride;
42611: 
42611:     nsRefPtr<gfxImageSurface> sourceSurface;
42611: 
42611:     if (mSurface->GetType() == gfxASurface::SurfaceTypeWin32) {
42611:       sourceSurface = static_cast<gfxWindowsSurface*>(mSurface.get())->GetImageSurface();
42611:       startBits = sourceSurface->Data() + sourceSurface->Stride() * aRect.y +
42611:                   aRect.x * 4;
42611:       sourceStride = sourceSurface->Stride();
42611:     } else if (mSurface->GetType() == gfxASurface::SurfaceTypeImage) {
51315:       sourceSurface = static_cast<gfxImageSurface*>(mSurface.get());
42611:       if (sourceSurface->Format() != gfxASurface::ImageFormatARGB32 &&
42611:           sourceSurface->Format() != gfxASurface::ImageFormatRGB24)
42611:       {
42611:         mTexture->UnlockRect(0);
42611:         return;
42611:       }
42611:       startBits = sourceSurface->Data() + sourceSurface->Stride() * aRect.y +
42611:                   aRect.x * 4;
42611:       sourceStride = sourceSurface->Stride();
42611:     } else {
42611:       sourceSurface = new gfxImageSurface(gfxIntSize(aRect.width, aRect.height),
42611:                                           gfxASurface::ImageFormatARGB32);
42611:       nsRefPtr<gfxContext> ctx = new gfxContext(sourceSurface);
42611:       ctx->Translate(gfxPoint(-aRect.x, -aRect.y));
42611:       ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
51315:       ctx->SetSource(mSurface);
42611:       ctx->Paint();
42611:       startBits = sourceSurface->Data();
42611:       sourceStride = sourceSurface->Stride();
42611:     }
42611: 
42611:     for (int y = 0; y < aRect.height; y++) {
42611:       memcpy((PRUint8*)lockedRect.pBits + lockedRect.Pitch * y,
42611:              startBits + sourceStride * y,
42611:              aRect.width * 4);
42611:     }
42611: 
42611:     mTexture->UnlockRect(0);
42611:   }
42611: }
42611: 
42611: Layer*
42611: CanvasLayerD3D9::GetLayer()
42611: {
42611:   return this;
42611: }
42611: 
42611: void
42611: CanvasLayerD3D9::RenderLayer()
42611: {
53785:   if (!mTexture) {
53785:     Updated(mBounds);
53785:   }
53785: 
42611:   float quadTransform[4][4];
42611:   /*
42611:    * Matrix to transform the <0.0,0.0>, <1.0,1.0> quad to the correct position
42611:    * and size. To get pixel perfect mapping we offset the quad half a pixel
42611:    * to the top-left. We also flip the Y axis here, note we can only do this
42611:    * because we are in CULL_NONE mode!
42611:    *
42611:    * See: http://msdn.microsoft.com/en-us/library/bb219690%28VS.85%29.aspx
42611:    */
42611:   memset(&quadTransform, 0, sizeof(quadTransform));
42611:   quadTransform[0][0] = (float)mBounds.width;
42611:   if (mNeedsYFlip) {
42611:     quadTransform[1][1] = (float)-mBounds.height;
51853:     quadTransform[3][1] = (float)mBounds.height;
42611:   } else {
42611:     quadTransform[1][1] = (float)mBounds.height;
51853:     quadTransform[3][1] = 0.0f;
42611:   }
42611:   quadTransform[2][2] = 1.0f;
51853:   quadTransform[3][0] = 0.0f;
42611:   quadTransform[3][3] = 1.0f;
42611: 
42611:   device()->SetVertexShaderConstantF(0, &quadTransform[0][0], 4);
42611: 
42611:   device()->SetVertexShaderConstantF(4, &mTransform._11, 4);
42611: 
42611:   float opacity[4];
42611:   /*
42611:    * We always upload a 4 component float, but the shader will use only the
42611:    * first component since it's declared as a 'float'.
42611:    */
42611:   opacity[0] = GetOpacity();
42611:   device()->SetPixelShaderConstantF(0, opacity, 1);
42611: 
51963:   mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER);
42611: 
51316:   if (!mDataIsPremultiplied) {
42611:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
51314:     device()->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, TRUE);
42611:   }
42611:   device()->SetTexture(0, mTexture);
42611:   device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
51316:   if (!mDataIsPremultiplied) {
42611:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
51314:     device()->SetRenderState(D3DRS_SEPARATEALPHABLENDENABLE, FALSE);
42611:   }
42611: }
42611: 
53784: void
53784: CanvasLayerD3D9::CleanResources()
53784: {
53784:   if (mD3DManager->deviceManager()->HasDynamicTextures()) {
53784:     // In this case we have a texture in POOL_DEFAULT
53784:     mTexture = nsnull;
53784:   }
53784: }
53784: 
53785: void
53785: CanvasLayerD3D9::CreateTexture()
53785: {
53785:   if (mD3DManager->deviceManager()->HasDynamicTextures()) {
53785:     device()->CreateTexture(mBounds.width, mBounds.height, 1, D3DUSAGE_DYNAMIC,
53785:                             D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT,
53785:                             getter_AddRefs(mTexture), NULL);    
53785:   } else {
53785:     // D3DPOOL_MANAGED is fine here since we require Dynamic Textures for D3D9Ex
53785:     // devices.
53785:     device()->CreateTexture(mBounds.width, mBounds.height, 1, 0,
53785:                             D3DFMT_A8R8G8B8, D3DPOOL_MANAGED,
53785:                             getter_AddRefs(mTexture), NULL);
53785:   }
53785: }
53785: 
42611: } /* namespace layers */
47909: } /* namespace mozilla */
