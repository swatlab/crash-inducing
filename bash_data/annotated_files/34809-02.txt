    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
    1:  *   Chris Saari <saari@netscape.com>
 7009:  *   Federico Mena-Quintero <federico@novell.com>
32424:  *   Bobby Holley <bobbyholley@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /** @file
    1:  * This file declares the imgContainer class, which
    1:  * handles static and animated image containers.
    1:  *
    1:  * @author  Stuart Parmenter <pavlov@netscape.com>
    1:  * @author  Chris Saari <saari@netscape.com>
    1:  * @author  Arron Mogge <paper@animecity.nu>
    1:  * @author  Andrew Smith <asmith15@learn.senecac.on.ca>
    1:  */
    1: 
    1: #ifndef __imgContainer_h__
    1: #define __imgContainer_h__
    1: 
    1: #include "nsCOMArray.h"
    1: #include "nsCOMPtr.h"
    1: #include "imgIContainer.h"
32424: #include "imgIDecoder.h"
    1: #include "nsIProperties.h"
    1: #include "nsITimer.h"
    1: #include "nsWeakReference.h"
 7009: #include "nsTArray.h"
30479: #include "imgFrame.h"
32424: #include "nsThreadUtils.h"
    1: 
    1: #define NS_IMGCONTAINER_CID \
30479: { /* c76ff2c1-9bf6-418a-b143-3340c00112f7 */         \
30479:      0x376ff2c1,                                     \
30479:      0x9bf6,                                         \
30479:      0x418a,                                         \
30479:     {0xb1, 0x43, 0x33, 0x40, 0xc0, 0x01, 0x12, 0xf7} \
    1: }
    1: 
    1: /**
    1:  * Handles static and animated image containers.
    1:  *
    1:  *
    1:  * @par A Quick Walk Through
    1:  * The decoder initializes this class and calls AppendFrame() to add a frame.
    1:  * Once imgContainer detects more than one frame, it starts the animation
    1:  * with StartAnimation().
    1:  *
    1:  * @par
    1:  * StartAnimation() checks if animating is allowed, and creates a timer.  The
    1:  * timer calls Notify when the specified frame delay time is up.
    1:  *
    1:  * @par
    1:  * Notify() moves on to the next frame, sets up the new timer delay, destroys
    1:  * the old frame, and forces a redraw via observer->FrameChanged().
    1:  *
    1:  * @par
    1:  * Each frame can have a different method of removing itself. These are
    1:  * listed as imgIContainer::cDispose... constants.  Notify() calls 
    1:  * DoComposite() to handle any special frame destruction.
    1:  *
    1:  * @par
    1:  * The basic path through DoComposite() is:
    1:  * 1) Calculate Area that needs updating, which is at least the area of
    1:  *    aNextFrame.
    1:  * 2) Dispose of previous frame.
    1:  * 3) Draw new image onto compositingFrame.
    1:  * See comments in DoComposite() for more information and optimizations.
    1:  *
    1:  * @par
    1:  * The rest of the imgContainer specific functions are used by DoComposite to
    1:  * destroy the old frame and build the new one.
    1:  *
    1:  * @note
    1:  * <li> "Mask", "Alpha", and "Alpha Level" are interchangable phrases in
 6633:  * respects to imgContainer.
    1:  *
    1:  * @par
    1:  * <li> GIFs never have more than a 1 bit alpha.
    1:  * <li> APNGs may have a full alpha channel.
    1:  *
    1:  * @par
    1:  * <li> Background color specified in GIF is ignored by web browsers.
    1:  *
    1:  * @par
    1:  * <li> If Frame 3 wants to dispose by restoring previous, what it wants is to
    1:  * restore the composition up to and including Frame 2, as well as Frame 2s
    1:  * disposal.  So, in the middle of DoComposite when composing Frame 3, right
    1:  * after destroying Frame 2's area, we copy compositingFrame to
    1:  * prevCompositingFrame.  When DoComposite gets called to do Frame 4, we
    1:  * copy prevCompositingFrame back, and then draw Frame 4 on top.
    1:  *
    1:  * @par
    1:  * The mAnim structure has members only needed for animated images, so
    1:  * it's not allocated until the second frame is added.
    1:  *
    1:  * @note
    1:  * mAnimationMode, mLoopCount and mObserver are not in the mAnim structure
    1:  * because the first two have public setters and the observer we only get
    1:  * in Init().
    1:  */
32424: class imgDecodeWorker;
    1: class imgContainer : public imgIContainer, 
    1:                      public nsITimerCallback,
32424:                      public nsIProperties,
32424:                      public nsSupportsWeakReference
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_IMGICONTAINER
    1:   NS_DECL_NSITIMERCALLBACK
 2663:   NS_DECL_NSIPROPERTIES
    1: 
    1:   imgContainer();
    1:   virtual ~imgContainer();
    1: 
32424:   static NS_METHOD WriteToContainer(nsIInputStream* in, void* closure,
32424:                                     const char* fromRawSegment,
32424:                                     PRUint32 toOffset, PRUint32 count,
32424:                                     PRUint32 *writeCount);
32424: 
    1: private:
    1:   struct Anim
    1:   {
    1:     //! Area of the first frame that needs to be redrawn on subsequent loops.
    1:     nsIntRect                  firstFrameRefreshArea;
    1:     // Note this doesn't hold a proper value until frame 2 finished decoding.
32424:     PRUint32                   currentDecodingFrameIndex; // 0 to numFrames-1
32424:     PRUint32                   currentAnimationFrameIndex; // 0 to numFrames-1
    1:     //! Track the last composited frame for Optimizations (See DoComposite code)
    1:     PRInt32                    lastCompositedFrameIndex;
    1:     //! Whether we can assume there will be no more frames
    1:     //! (and thus loop the animation)
    1:     PRBool                     doneDecoding;
    1:     //! Are we currently animating the image?
    1:     PRBool                     animating;
    1:     /** For managing blending of frames
    1:      *
    1:      * Some animations will use the compositingFrame to composite images
    1:      * and just hand this back to the caller when it is time to draw the frame.
    1:      * NOTE: When clearing compositingFrame, remember to set
    1:      *       lastCompositedFrameIndex to -1.  Code assume that if
    1:      *       lastCompositedFrameIndex >= 0 then compositingFrame exists.
    1:      */
30479:     nsAutoPtr<imgFrame>        compositingFrame;
    1:     /** the previous composited frame, for DISPOSE_RESTORE_PREVIOUS
    1:      *
    1:      * The Previous Frame (all frames composited up to the current) needs to be
    1:      * stored in cases where the image specifies it wants the last frame back
    1:      * when it's done with the current frame.
    1:      */
30479:     nsAutoPtr<imgFrame>        compositingPrevFrame;
    1:     //! Timer to animate multiframed images
    1:     nsCOMPtr<nsITimer>         timer;
    1:     
    1:     Anim() :
    1:       firstFrameRefreshArea(),
    1:       currentDecodingFrameIndex(0),
    1:       currentAnimationFrameIndex(0),
    1:       lastCompositedFrameIndex(-1),
    1:       doneDecoding(PR_FALSE),
    1:       animating(PR_FALSE)
    1:     {
    1:       ;
    1:     }
    1:     ~Anim()
    1:     {
    1:       if (timer)
    1:         timer->Cancel();
    1:     }
    1:   };
    1: 
30479:   imgFrame* GetImgFrame(PRUint32 framenum);
34809:   imgFrame* GetDrawableImgFrame(PRUint32 framenum);
30479:   imgFrame* GetCurrentImgFrame();
34809:   imgFrame* GetCurrentDrawableImgFrame();
32424:   PRUint32 GetCurrentImgFrameIndex() const;
    1:   
32424:   inline Anim* ensureAnimExists()
32424:   {
32424:     if (!mAnim) {
32424: 
32424:       // Create the animation context
    1:       mAnim = new Anim();
32424: 
32515:       // We don't support discarding animated images (See bug 414259).
32515:       // Lock the image and throw away the key.
32515:       // 
32515:       // Note that this is inefficient, since we could get rid of the source
32515:       // data too. However, doing this is actually hard, because we're probably
32515:       // calling ensureAnimExists mid-decode, and thus we're decoding out of
32515:       // the source buffer. Since we're going to fix this anyway later, and
32515:       // since we didn't kill the source data in the old world either, locking
32515:       // is acceptable for the moment.
32515:       LockImage();
32424:     }
    1:     return mAnim;
    1:   }
    1:   
    1:   /** Function for doing the frame compositing of animations
    1:    *
    1:    * @param aFrameToUse Set by DoComposite
    1:    *                   (aNextFrame, compositingFrame, or compositingPrevFrame)
    1:    * @param aDirtyRect  Area that the display will need to update
    1:    * @param aPrevFrame  Last Frame seen/processed
    1:    * @param aNextFrame  Frame we need to incorperate/display
    1:    * @param aNextFrameIndex Position of aNextFrame in mFrames list
    1:    */
30479:   nsresult DoComposite(imgFrame** aFrameToUse, nsIntRect* aDirtyRect,
30479:                        imgFrame* aPrevFrame,
30479:                        imgFrame* aNextFrame,
    1:                        PRInt32 aNextFrameIndex);
    1:   
 2200:   /** Clears an area of <aFrame> with transparent black.
    1:    *
    1:    * @param aFrame Target Frame
    1:    *
 2200:    * @note Does also clears the transparancy mask
    1:    */
30479:   static void ClearFrame(imgFrame* aFrame);
 2200:   
    1:   //! @overload
30479:   static void ClearFrame(imgFrame* aFrame, nsIntRect &aRect);
    1:   
30479:   //! Copy one frames's image and mask into another
30479:   static PRBool CopyFrameImage(imgFrame *aSrcFrame,
30479:                                imgFrame *aDstFrame);
    1:   
30479:   /** Draws one frames's image to into another,
 5275:    * at the position specified by aRect
 5275:    *
 5275:    * @param aSrcFrame  Frame providing the source image
 5275:    * @param aDstFrame  Frame where the image is drawn into
 5275:    * @param aRect      The position and size to draw the image
 5275:    */
30479:   static nsresult DrawFrameTo(imgFrame *aSrcFrame,
30479:                               imgFrame *aDstFrame,
 5275:                               nsIntRect& aRect);
 5275: 
30479:   nsresult InternalAddFrameHelper(PRUint32 framenum, imgFrame *frame,
30479:                                   PRUint8 **imageData, PRUint32 *imageLength,
30479:                                   PRUint32 **paletteData, PRUint32 *paletteLength);
30479:   nsresult InternalAddFrame(PRUint32 framenum, PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight,
30479:                             gfxASurface::gfxImageFormat aFormat, PRUint8 aPaletteDepth,
30479:                             PRUint8 **imageData, PRUint32 *imageLength,
30479:                             PRUint32 **paletteData, PRUint32 *paletteLength);
30479: 
30479: private: // data
30479: 
    1:   nsIntSize                  mSize;
32424:   PRBool                     mHasSize;
    1:   
30479:   //! All the frames of the image
32424:   // IMPORTANT: if you use mFrames in a method, call EnsureImageIsDecoded() first 
32424:   // to ensure that the frames actually exist (they may have been discarded to save
32424:   // memory, or we may be decoding on draw).
30479:   nsTArray<imgFrame *>       mFrames;
    1:   
    1:   nsCOMPtr<nsIProperties>    mProperties;
    1: 
32424:   // IMPORTANT: if you use mAnim in a method, call EnsureImageIsDecoded() first to ensure
32424:   // that the frames actually exist (they may have been discarded to save memory, or
32424:   // we maybe decoding on draw).
    1:   imgContainer::Anim*        mAnim;
    1:   
    1:   //! See imgIContainer for mode constants
    1:   PRUint16                   mAnimationMode;
    1:   
    1:   //! # loops remaining before animation stops (-1 no stop)
    1:   PRInt32                    mLoopCount;
    1:   
32424:   //! imgIDecoderObserver
    1:   nsWeakPtr                  mObserver;
 7009: 
32424:   // Decoding on draw?
32424:   PRBool                     mDecodeOnDraw;
32424: 
32424:   // Multipart?
32424:   PRBool                     mMultipart;
32424: 
32424:   // Have we been initalized?
32424:   PRBool                     mInitialized;
32424: 
32424:   // Discard members
 7009:   PRBool                     mDiscardable;
32424:   PRUint32                   mLockCount;
 7009:   nsCOMPtr<nsITimer>         mDiscardTimer;
 7009: 
32424:   // Source data members
32424:   nsTArray<char>             mSourceData;
32424:   PRBool                     mHasSourceData;
32424:   nsCString                  mSourceDataMimeType;
32424: 
32424:   // Do we have the frames in decoded form?
32424:   PRBool                     mDecoded;
33531:   PRBool                     mHasBeenDecoded;
32424: 
32424:   friend class imgDecodeWorker;
32424: 
32424:   // Decoder and friends
32424:   nsCOMPtr<imgIDecoder>          mDecoder;
32424:   nsRefPtr<imgDecodeWorker>      mWorker;
32424:   PRUint32                       mBytesDecoded;
32424:   PRUint32                       mDecoderFlags;
32424:   PRBool                         mWorkerPending;
32424:   PRBool                         mInDecoder;
32424: 
32424:   // Error handling
32424:   PRBool                         mError;
32424: 
32424:   // Discard code
32424:   nsresult ResetDiscardTimer();
 7009:   static void sDiscardTimerCallback(nsITimer *aTimer, void *aClosure);
32424: 
32424:   // Decoding
32424:   nsresult WantDecodedFrames();
32424:   nsresult SyncDecode();
32424:   nsresult InitDecoder(PRUint32 dFlags);
32424:   nsresult WriteToDecoder(const char *aBuffer, PRUint32 aCount);
32424:   nsresult DecodeSomeData(PRUint32 aMaxBytes);
32424:   PRBool   IsDecodeFinished();
32424: 
32424:   // Decoder shutdown
32424:   enum eShutdownIntent {
32424:     eShutdownIntent_Done        = 0,
32424:     eShutdownIntent_Interrupted = 1,
32424:     eShutdownIntent_Error       = 2,
32424:     eShutdownIntent_AllCount    = 3
32424:   };
32424:   nsresult ShutdownDecoder(eShutdownIntent aIntent);
32424: 
32424:   // Helpers
32424:   void DoError();
32424:   PRBool CanDiscard();
32424:   PRBool StoringSourceData();
32424: 
    1: };
    1: 
32424: // Decoding Helper Class
32424: //
32424: // We use this class to mimic the interactivity benefits of threading
32424: // in a single-threaded event loop. We want to progressively decode
32424: // and keep a responsive UI while we're at it, so we have a runnable
32424: // class that does a bit of decoding, and then "yields" by dispatching
32424: // itself to the end of the event queue.
32424: class imgDecodeWorker : public nsRunnable
32424: {
32424:   public:
32424:     imgDecodeWorker(imgIContainer* aContainer) {
32424:       mContainer = do_GetWeakReference(aContainer);
32424:     }
32424:     NS_IMETHOD Run();
32424:     NS_METHOD  Dispatch();
32424: 
32424:   private:
32424:     nsWeakPtr mContainer;
32424: };
32424: 
32424: // Asynchronous Decode Requestor
32424: //
32424: // We use this class when someone calls requestDecode() from within a decode
32424: // notification. Since requestDecode() involves modifying the decoder's state
32424: // (for example, possibly shutting down a header-only decode and starting a
32424: // full decode), we don't want to do this from inside a decoder.
32424: class imgDecodeRequestor : public nsRunnable
32424: {
32424:   public:
32424:     imgDecodeRequestor(imgIContainer *aContainer) {
32424:       mContainer = do_GetWeakReference(aContainer);
32424:     }
32424:     NS_IMETHOD Run() {
32424:       nsCOMPtr<imgIContainer> con = do_QueryReferent(mContainer);
32424:       if (con)
32424:         con->RequestDecode();
32424:       return NS_OK;
32424:     }
32424: 
32424:   private:
32424:     nsWeakPtr mContainer;
32424: };
32424: 
32424: 
32424: 
    1: #endif /* __imgContainer_h__ */
