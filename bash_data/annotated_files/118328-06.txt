  3889: // Copyright (c) 2007, Google Inc.
  3889: // All rights reserved.
  3889: //
  3889: // Redistribution and use in source and binary forms, with or without
  3889: // modification, are permitted provided that the following conditions are
  3889: // met:
  3889: //
  3889: //     * Redistributions of source code must retain the above copyright
  3889: // notice, this list of conditions and the following disclaimer.
  3889: //     * Redistributions in binary form must reproduce the above
  3889: // copyright notice, this list of conditions and the following disclaimer
  3889: // in the documentation and/or other materials provided with the
  3889: // distribution.
  3889: //     * Neither the name of Google Inc. nor the names of its
  3889: // contributors may be used to endorse or promote products derived from
  3889: // this software without specific prior written permission.
  3889: //
  3889: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  3889: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  3889: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  3889: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  3889: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  3889: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  3889: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  3889: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  3889: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  3889: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  3889: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  3889: 
 59426: #include "client/mac/handler/dynamic_images.h"
 59426: 
  7079: extern "C" { // needed to compile on Leopard
  3889:   #include <mach-o/nlist.h>
  3889:   #include <stdlib.h>
  3889:   #include <stdio.h>
  7079: }
  7079: 
 50677: #include <assert.h>
114869: #include <AvailabilityMacros.h>
 22509: #include <dlfcn.h>
114869: #include <mach/task_info.h>
 59426: #include <sys/sysctl.h>
114869: #include <TargetConditionals.h>
 59426: 
  3889: #include <algorithm>
 59426: #include <string>
 59426: #include <vector>
  3889: 
114869: #include "breakpad_nlist_64.h"
114869: 
114869: #if !TARGET_OS_IPHONE
114869: #include <CoreServices/CoreServices.h>
114869: 
114869: #ifndef MAC_OS_X_VERSION_10_6
114869: #define MAC_OS_X_VERSION_10_6 1060
114869: #endif
114869: 
114869: #if MAC_OS_X_VERSION_MAX_ALLOWED < MAC_OS_X_VERSION_10_6
114869: 
114869: // Fallback declarations for TASK_DYLD_INFO and friends, introduced in
114869: // <mach/task_info.h> in the Mac OS X 10.6 SDK.
114869: #define TASK_DYLD_INFO 17
114869: struct task_dyld_info {
114869:   mach_vm_address_t all_image_info_addr;
114869:   mach_vm_size_t all_image_info_size;
114869: };
114869: typedef struct task_dyld_info task_dyld_info_data_t;
114869: typedef struct task_dyld_info *task_dyld_info_t;
114869: #define TASK_DYLD_INFO_COUNT (sizeof(task_dyld_info_data_t) / sizeof(natural_t))
114869: 
114869: #endif
114869: 
114869: #endif  // !TARGET_OS_IPHONE
114869: 
  3889: namespace google_breakpad {
  3889: 
 59426: using std::string;
 59426: using std::vector;
 59426: 
  3889: //==============================================================================
  7079: // Returns the size of the memory region containing |address| and the
  7079: // number of bytes from |address| to the end of the region.
  7079: // We potentially, will extend the size of the original
  7079: // region by the size of the following region if it's contiguous with the
  7079: // first in order to handle cases when we're reading strings and they
  7079: // straddle two vm regions.
  7079: //
 22509: static mach_vm_size_t GetMemoryRegionSize(task_port_t target_task,
 59426:                                           const uint64_t address,
 22509:                                           mach_vm_size_t *size_to_end) {
 22509:   mach_vm_address_t region_base = (mach_vm_address_t)address;
 22509:   mach_vm_size_t region_size;
  7079:   natural_t nesting_level = 0;
 22509:   vm_region_submap_info_64 submap_info;
 22509:   mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;
  7079: 
  7079:   // Get information about the vm region containing |address|
 22509:   vm_region_recurse_info_t region_info;
 22509:   region_info = reinterpret_cast<vm_region_recurse_info_t>(&submap_info);
 22509: 
  7079:   kern_return_t result =
 22509:     mach_vm_region_recurse(target_task,
  7079:                            &region_base,
  7079:                            &region_size,
  7079:                            &nesting_level,
 22509:                            region_info,
  7079:                            &info_count);
  7079: 
  7079:   if (result == KERN_SUCCESS) {
  7079:     // Get distance from |address| to the end of this region
 22509:     *size_to_end = region_base + region_size -(mach_vm_address_t)address;
  7079: 
  7079:     // If we want to handle strings as long as 4096 characters we may need
  7079:     // to check if there's a vm region immediately following the first one.
  7079:     // If so, we need to extend |*size_to_end| to go all the way to the end
  7079:     // of the second region.
  7079:     if (*size_to_end < 4096) {
  7079:       // Second region starts where the first one ends
 22509:       mach_vm_address_t region_base2 =
 22509:         (mach_vm_address_t)(region_base + region_size);
 22509:       mach_vm_size_t region_size2;
  7079: 
  7079:       // Get information about the following vm region
  7079:       result =
 22509:         mach_vm_region_recurse(target_task,
  7079:                                &region_base2,
  7079:                                &region_size2,
  7079:                                &nesting_level,
 22509:                                region_info,
  7079:                                &info_count);
  7079: 
  7079:       // Extend region_size to go all the way to the end of the 2nd region
  7079:       if (result == KERN_SUCCESS
  7079:           && region_base2 == region_base + region_size) {
  7079:         region_size += region_size2;
  7079:       }
  7079:     }
  7079: 
 22509:     *size_to_end = region_base + region_size -(mach_vm_address_t)address;
  7079:   } else {
  7079:     region_size = 0;
  7079:     *size_to_end = 0;
  7079:   }
  7079: 
  7079:   return region_size;
  7079: }
  7079: 
  7079: #define kMaxStringLength 8192
  7079: //==============================================================================
  7079: // Reads a NULL-terminated string from another task.
  7079: //
  7079: // Warning!  This will not read any strings longer than kMaxStringLength-1
  7079: //
 59426: static string ReadTaskString(task_port_t target_task,
 59426:                              const uint64_t address) {
  7079:   // The problem is we don't know how much to read until we know how long
  7079:   // the string is. And we don't know how long the string is, until we've read
  7079:   // the memory!  So, we'll try to read kMaxStringLength bytes
  7079:   // (or as many bytes as we can until we reach the end of the vm region).
 22509:   mach_vm_size_t size_to_end;
  7079:   GetMemoryRegionSize(target_task, address, &size_to_end);
  7079: 
  7079:   if (size_to_end > 0) {
 22509:     mach_vm_size_t size_to_read =
  7079:       size_to_end > kMaxStringLength ? kMaxStringLength : size_to_end;
  7079: 
 59426:     vector<uint8_t> bytes;
 59426:     if (ReadTaskMemory(target_task, address, (size_t)size_to_read, bytes) !=
 59426:         KERN_SUCCESS)
 59426:       return string();
 59426: 
 59426:     return string(reinterpret_cast<const char*>(&bytes[0]));
  7079:   }
  7079: 
 59426:   return string();
  7079: }
  7079: 
  7079: //==============================================================================
 59426: // Reads an address range from another task. The bytes read will be returned
 59426: // in bytes, which will be resized as necessary.
 59426: kern_return_t ReadTaskMemory(task_port_t target_task,
 59426:                              const uint64_t address,
 22509:                              size_t length,
 59426:                              vector<uint8_t> &bytes) {
 22509:   int systemPageSize = getpagesize();
 22509: 
 22509:   // use the negative of the page size for the mask to find the page address
 59426:   mach_vm_address_t page_address = address & (-systemPageSize);
 22509: 
 22509:   mach_vm_address_t last_page_address =
 59426:       (address + length + (systemPageSize - 1)) & (-systemPageSize);
 22509: 
 22509:   mach_vm_size_t page_size = last_page_address - page_address;
  3889:   uint8_t* local_start;
  3889:   uint32_t local_length;
  3889: 
 59426:   kern_return_t r = mach_vm_read(target_task,
  3889:                                  page_address,
  3889:                                  page_size,
  3889:                                  reinterpret_cast<vm_offset_t*>(&local_start),
  3889:                                  &local_length);
  3889: 
 59426:   if (r != KERN_SUCCESS)
 59426:     return r;
 22509: 
 59426:   bytes.resize(length);
 59426:   memcpy(&bytes[0],
 22509:          &local_start[(mach_vm_address_t)address - page_address],
 22509:          length);
 22509:   mach_vm_deallocate(mach_task_self(), (uintptr_t)local_start, local_length);
 59426:   return KERN_SUCCESS;
  3889: }
  3889: 
  3889: #pragma mark -
  3889: 
  3889: //==============================================================================
 59426: // Traits structs for specializing function templates to handle
 59426: // 32-bit/64-bit Mach-O files.
 59426: struct MachO32 {
 59426:   typedef mach_header mach_header_type;
 59426:   typedef segment_command mach_segment_command_type;
 59426:   typedef dyld_image_info32 dyld_image_info;
 59426:   typedef dyld_all_image_infos32 dyld_all_image_infos;
 59426:   typedef struct nlist nlist_type;
 59426:   static const uint32_t magic = MH_MAGIC;
 59426:   static const uint32_t segment_load_command = LC_SEGMENT;
 59426: };
 59426: 
 59426: struct MachO64 {
 59426:   typedef mach_header_64 mach_header_type;
 59426:   typedef segment_command_64 mach_segment_command_type;
 59426:   typedef dyld_image_info64 dyld_image_info;
 59426:   typedef dyld_all_image_infos64 dyld_all_image_infos;
 59426:   typedef struct nlist_64 nlist_type;
 59426:   static const uint32_t magic = MH_MAGIC_64;
 59426:   static const uint32_t segment_load_command = LC_SEGMENT_64;
 59426: };
 59426: 
 59426: template<typename MachBits>
 59426: bool FindTextSection(DynamicImage& image) {
 59426:   typedef typename MachBits::mach_header_type mach_header_type;
 59426:   typedef typename MachBits::mach_segment_command_type
 59426:       mach_segment_command_type;
 59426:   
 59426:   const mach_header_type* header =
 59426:       reinterpret_cast<const mach_header_type*>(&image.header_[0]);
 59426: 
 59426:   if(header->magic != MachBits::magic) {
 59426:     return false;
 59426:   }
 59426: 
 59426:   const struct load_command *cmd =
 59426:       reinterpret_cast<const struct load_command *>(header + 1);
 59426: 
 59426:   bool found_text_section = false;
 59426:   bool found_dylib_id_command = false;
 59426:   for (unsigned int i = 0; cmd && (i < header->ncmds); ++i) {
 59426:     if (!found_text_section) {
 59426:       if (cmd->cmd == MachBits::segment_load_command) {
 59426:         const mach_segment_command_type *seg =
 59426:             reinterpret_cast<const mach_segment_command_type *>(cmd);
 59426: 
 59426:         if (!strcmp(seg->segname, "__TEXT")) {
114869:           image.vmaddr_ = static_cast<mach_vm_address_t>(seg->vmaddr);
114869:           image.vmsize_ = static_cast<mach_vm_size_t>(seg->vmsize);
 59426:           image.slide_ = 0;
 59426: 
 59426:           if (seg->fileoff == 0 && seg->filesize != 0) {
 59426:             image.slide_ =
 59426:                 (uintptr_t)image.GetLoadAddress() - (uintptr_t)seg->vmaddr;
 59426:           }
 59426:           found_text_section = true;
 59426:         }
 59426:       }
 59426:     }
 59426: 
 59426:     if (!found_dylib_id_command) {
 59426:       if (cmd->cmd == LC_ID_DYLIB) {
 59426:         const struct dylib_command *dc =
 59426:             reinterpret_cast<const struct dylib_command *>(cmd);
 59426: 
 59426:         image.version_ = dc->dylib.current_version;
 59426:         found_dylib_id_command = true;
 59426:       }
 59426:     }
 59426: 
 59426:     if (found_dylib_id_command && found_text_section) {
 59426:       return true;
 59426:     }
 59426: 
 59426:     cmd = reinterpret_cast<const struct load_command *>
 59426:         (reinterpret_cast<const char *>(cmd) + cmd->cmdsize);
 59426:   }
 59426: 
 59426:   return false;
 59426: }
 59426: 
 59426: //==============================================================================
  3889: // Initializes vmaddr_, vmsize_, and slide_
 22509: void DynamicImage::CalculateMemoryAndVersionInfo() {
 22509:   // unless we can process the header, ensure that calls to
 22509:   // IsValid() will return false
 22509:   vmaddr_ = 0;
 22509:   vmsize_ = 0;
 22509:   slide_ = 0;
 22509:   version_ = 0;
 22509: 
 59426:   // The function template above does all the real work.
 59426:   if (Is64Bit())
 59426:     FindTextSection<MachO64>(*this);
 59426:   else
 59426:     FindTextSection<MachO32>(*this);
 22509: }
 22509: 
 59426: //==============================================================================
 59426: // The helper function template abstracts the 32/64-bit differences.
 59426: template<typename MachBits>
 59426: uint32_t GetFileTypeFromHeader(DynamicImage& image) {
 59426:   typedef typename MachBits::mach_header_type mach_header_type;
 22509: 
 59426:   const mach_header_type* header =
 59426:       reinterpret_cast<const mach_header_type*>(&image.header_[0]);
 59426:   return header->filetype;
 22509: }
 22509: 
 59426: uint32_t DynamicImage::GetFileType() {
 59426:   if (Is64Bit())
 59426:     return GetFileTypeFromHeader<MachO64>(*this);
  3889: 
 59426:   return GetFileTypeFromHeader<MachO32>(*this);
  3897: }
  3897: 
  3889: #pragma mark -
  3889: 
  3889: //==============================================================================
  3889: // Loads information about dynamically loaded code in the given task.
  3889: DynamicImages::DynamicImages(mach_port_t task)
 59426:     : task_(task),
 59426:       cpu_type_(DetermineTaskCPUType(task)),
 59426:       image_list_() {
  3889:   ReadImageInfoForTask();
  3889: }
  3889: 
 59426: template<typename MachBits>
 59426: static uint64_t LookupSymbol(const char* symbol_name,
 59426:                              const char* filename,
 59426:                              cpu_type_t cpu_type) {
 59426:   typedef typename MachBits::nlist_type nlist_type;
 59426: 
 59426:   nlist_type symbol_info[8] = {};
 59426:   const char *symbolNames[2] = { symbol_name, "\0" };
 59426:   nlist_type &list = symbol_info[0];
 59426:   int invalidEntriesCount = breakpad_nlist(filename,
 59426:                                            &list,
 59426:                                            symbolNames,
 59426:                                            cpu_type);
 59426: 
 59426:   if(invalidEntriesCount != 0) {
 59426:     return 0;
 59426:   }
 59426: 
 59426:   assert(list.n_value);
 59426:   return list.n_value;
 59426: }
 59426: 
114869: #if TARGET_OS_IPHONE
114869: static bool HasTaskDyldInfo() {
114869:   return true;
114869: }
114869: #else
114869: static SInt32 GetOSVersionInternal() {
114869:   SInt32 os_version = 0;
114869:   Gestalt(gestaltSystemVersion, &os_version);
114869:   return os_version;
114869: }
114869: 
114869: static SInt32 GetOSVersion() {
114869:   static SInt32 os_version = GetOSVersionInternal();
114869:   return os_version;
114869: }
114869: 
114869: static bool HasTaskDyldInfo() {
114869: #if MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6
114869:   return true;
114869: #else
114869:   return GetOSVersion() >= 0x1060;
114869: #endif
114869: }
114869: #endif  // TARGET_OS_IPHONE
114869: 
 59426: uint64_t DynamicImages::GetDyldAllImageInfosPointer() {
114869:   if (HasTaskDyldInfo()) {
114869:     task_dyld_info_data_t task_dyld_info;
114869:     mach_msg_type_number_t count = TASK_DYLD_INFO_COUNT;
114869:     if (task_info(task_, TASK_DYLD_INFO, (task_info_t)&task_dyld_info,
114869:                   &count) != KERN_SUCCESS) {
114869:       return 0;
114869:     }
114869: 
114869:     return (uint64_t)task_dyld_info.all_image_info_addr;
114869:   } else {
 22509:     const char *imageSymbolName = "_dyld_all_image_infos";
 22509:     const char *dyldPath = "/usr/lib/dyld";
  3889: 
 59426:     if (Is64Bit())
 59426:       return LookupSymbol<MachO64>(imageSymbolName, dyldPath, cpu_type_);
 59426:     return LookupSymbol<MachO32>(imageSymbolName, dyldPath, cpu_type_);
 22509:   }
114869: }
 50677: 
 22509: //==============================================================================
 22509: // This code was written using dyld_debug.c (from Darwin) as a guide.
 22509: 
 59426: template<typename MachBits>
 59426: void ReadImageInfo(DynamicImages& images,
 59426:                    uint64_t image_list_address) {
 59426:   typedef typename MachBits::dyld_image_info dyld_image_info;
 59426:   typedef typename MachBits::dyld_all_image_infos dyld_all_image_infos;
 59426:   typedef typename MachBits::mach_header_type mach_header_type;
 59426: 
  3889:   // Read the structure inside of dyld that contains information about
  3889:   // loaded images.  We're reading from the desired task's address space.
  3889: 
  3889:   // Here we make the assumption that dyld loaded at the same address in
  3889:   // the crashed process vs. this one.  This is an assumption made in
  3889:   // "dyld_debug.c" and is said to be nearly always valid.
 59426:   vector<uint8_t> dyld_all_info_bytes;
 59426:   if (ReadTaskMemory(images.task_,
 59426:                      image_list_address,
 59426:                      sizeof(dyld_all_image_infos),
 59426:                      dyld_all_info_bytes) != KERN_SUCCESS)
 59426:     return;
  3889: 
 59426:   dyld_all_image_infos *dyldInfo =
 59426:     reinterpret_cast<dyld_all_image_infos*>(&dyld_all_info_bytes[0]);
 59426: 
  3889:   // number of loaded images
  3889:   int count = dyldInfo->infoArrayCount;
  3889: 
  3889:   // Read an array of dyld_image_info structures each containing
  3889:   // information about a loaded image.
 59426:   vector<uint8_t> dyld_info_array_bytes;
 59426:     if (ReadTaskMemory(images.task_,
  3889:                        dyldInfo->infoArray,
 59426:                        count * sizeof(dyld_image_info),
 59426:                        dyld_info_array_bytes) != KERN_SUCCESS)
 59426:       return;
  3889: 
 59426:     dyld_image_info *infoArray =
 59426:         reinterpret_cast<dyld_image_info*>(&dyld_info_array_bytes[0]);
 59426:     images.image_list_.reserve(count);
  3889: 
  3889:     for (int i = 0; i < count; ++i) {
  3889:       dyld_image_info &info = infoArray[i];
  3889: 
  3889:       // First read just the mach_header from the image in the task.
 59426:       vector<uint8_t> mach_header_bytes;
 59426:       if (ReadTaskMemory(images.task_,
 22509:                          info.load_address_,
 59426:                          sizeof(mach_header_type),
 59426:                          mach_header_bytes) != KERN_SUCCESS)
 59426:         continue;  // bail on this dynamic image
  3889: 
 59426:       mach_header_type *header =
 59426:           reinterpret_cast<mach_header_type*>(&mach_header_bytes[0]);
  3889: 
 59426:       // Now determine the total amount necessary to read the header
 59426:       // plus all of the load commands.
 50677:       size_t header_size =
 59426:           sizeof(mach_header_type) + header->sizeofcmds;
 22509: 
 59426:       if (ReadTaskMemory(images.task_,
 59426:                          info.load_address_,
 59426:                          header_size,
 59426:                          mach_header_bytes) != KERN_SUCCESS)
 59426:         continue;
  3889: 
  3889:       // Read the file name from the task's memory space.
 59426:       string file_path;
  3889:       if (info.file_path_) {
  7079:         // Although we're reading kMaxStringLength bytes, it's copied in the
  3889:         // the DynamicImage constructor below with the correct string length,
  3889:         // so it's not really wasting memory.
 59426:         file_path = ReadTaskString(images.task_, info.file_path_);
  3889:       }
  3889: 
  3889:       // Create an object representing this image and add it to our list.
 22509:       DynamicImage *new_image;
 59426:       new_image = new DynamicImage(&mach_header_bytes[0],
  3889:                                    header_size,
 59426:                                    info.load_address_,
  3889:                                    file_path,
114869:                                    static_cast<uintptr_t>(info.file_mod_date_),
 59426:                                    images.task_,
 59426:                                    images.cpu_type_);
  3889: 
  3889:       if (new_image->IsValid()) {
 59426:         images.image_list_.push_back(DynamicImageRef(new_image));
  3889:       } else {
  3889:         delete new_image;
  3889:       }
  3889:     }
  3889: 
  3889:     // sorts based on loading address
 59426:     sort(images.image_list_.begin(), images.image_list_.end());
 22509:     // remove duplicates - this happens in certain strange cases
 22509:     // You can see it in DashboardClient when Google Gadgets plugin
 22509:     // is installed.  Apple's crash reporter log and gdb "info shared"
 22509:     // both show the same library multiple times at the same address
 22509: 
 59426:     vector<DynamicImageRef>::iterator it = unique(images.image_list_.begin(),
 59426:                                                   images.image_list_.end());
 59426:     images.image_list_.erase(it, images.image_list_.end());
  3889: }
 59426: 
 59426: void DynamicImages::ReadImageInfoForTask() {
 59426:   uint64_t imageList = GetDyldAllImageInfosPointer();
 59426: 
 59426:   if (imageList) {
 59426:     if (Is64Bit())
 59426:       ReadImageInfo<MachO64>(*this, imageList);
 59426:     else
 59426:       ReadImageInfo<MachO32>(*this, imageList);
  3889:   }
  3889: }
  3889: 
  3889: //==============================================================================
  3889: DynamicImage  *DynamicImages::GetExecutableImage() {
  3889:   int executable_index = GetExecutableImageIndex();
  3889: 
  3889:   if (executable_index >= 0) {
  3889:     return GetImage(executable_index);
  3889:   }
  3889: 
  3889:   return NULL;
  3889: }
  3889: 
  3889: //==============================================================================
  3889: // returns -1 if failure to find executable
  3889: int DynamicImages::GetExecutableImageIndex() {
  3889:   int image_count = GetImageCount();
  3889: 
  3889:   for (int i = 0; i < image_count; ++i) {
  3889:     DynamicImage  *image = GetImage(i);
 59426:     if (image->GetFileType() == MH_EXECUTE) {
  3889:       return i;
  3889:     }
  3889:   }
  3889: 
  3889:   return -1;
  3889: }
  3889: 
 59426: //==============================================================================
 59426: // static
 59426: cpu_type_t DynamicImages::DetermineTaskCPUType(task_t task) {
 59426:   if (task == mach_task_self())
 59426:     return GetNativeCPUType();
 59426: 
 59426:   int mib[CTL_MAXNAME];
 59426:   size_t mibLen = CTL_MAXNAME;
 59426:   int err = sysctlnametomib("sysctl.proc_cputype", mib, &mibLen);
 59426:   if (err == 0) {
 59426:     assert(mibLen < CTL_MAXNAME);
 59426:     pid_for_task(task, &mib[mibLen]);
 59426:     mibLen += 1;
 59426: 
 59426:     cpu_type_t cpu_type;
 59426:     size_t cpuTypeSize = sizeof(cpu_type);
 59426:     sysctl(mib, mibLen, &cpu_type, &cpuTypeSize, 0, 0);
 59426:     return cpu_type;
 59426:   }
 59426: 
 59426:   return GetNativeCPUType();
 59426: }
 59426: 
  3889: }  // namespace google_breakpad
