  3869: // Copyright (c) 2006, Google Inc.
  3869: // All rights reserved.
  3869: //
  3869: // Redistribution and use in source and binary forms, with or without
  3869: // modification, are permitted provided that the following conditions are
  3869: // met:
  3869: //
  3869: //     * Redistributions of source code must retain the above copyright
  3869: // notice, this list of conditions and the following disclaimer.
  3869: //     * Redistributions in binary form must reproduce the above
  3869: // copyright notice, this list of conditions and the following disclaimer
  3869: // in the documentation and/or other materials provided with the
  3869: // distribution.
  3869: //     * Neither the name of Google Inc. nor the names of its
  3869: // contributors may be used to endorse or promote products derived from
  3869: // this software without specific prior written permission.
  3869: //
  3869: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  3869: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  3869: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  3869: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  3869: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  3869: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  3869: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  3869: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  3869: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  3869: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  3869: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  3869: 
  3869: // macho_id.cc: Functions to gather identifying information from a macho file
  3869: //
  3869: // See macho_id.h for documentation
  3869: //
  3869: // Author: Dan Waylonis
  3869: 
  7079: extern "C" {  // necessary for Leopard
  3869:   #include <fcntl.h>
  3869:   #include <mach-o/loader.h>
  3869:   #include <mach-o/swap.h>
  3869:   #include <stdio.h>
  3869:   #include <stdlib.h>
  3869:   #include <string.h>
  3869:   #include <sys/time.h>
  3869:   #include <sys/types.h>
  3869:   #include <unistd.h>
  7079: }
  3869: 
  3869: #include "common/mac/macho_id.h"
  3869: #include "common/mac/macho_walker.h"
  3889: #include "common/mac/macho_utilities.h"
  3869: 
  3869: namespace MacFileUtilities {
  3869: 
 82975: using google_breakpad::MD5Init;
 82975: using google_breakpad::MD5Update;
 82975: using google_breakpad::MD5Final;
 82975: 
 50677: MachoID::MachoID(const char *path)
114869:    : memory_(0),
114869:      memory_size_(0),
 50677:      crc_(0), 
 50677:      md5_context_(), 
 50677:      update_function_(NULL) {
  3869:   strlcpy(path_, path, sizeof(path_));
114869: }
114869: 
114869: MachoID::MachoID(const char *path, void *memory, size_t size)
114869:    : memory_(memory),
114869:      memory_size_(size),
114869:      crc_(0), 
114869:      md5_context_(), 
114869:      update_function_(NULL) {
114869:   strlcpy(path_, path, sizeof(path_));
  3869: }
  3869: 
  3869: MachoID::~MachoID() {
  3869: }
  3869: 
  3869: // The CRC info is from http://en.wikipedia.org/wiki/Adler-32
  3869: // With optimizations from http://www.zlib.net/
  3869: 
  3869: // The largest prime smaller than 65536
  3869: #define MOD_ADLER 65521
  3869: // MAX_BLOCK is the largest n such that 255n(n+1)/2 + (n+1)(MAX_BLOCK-1) <= 2^32-1
  3869: #define MAX_BLOCK 5552
  3869: 
  3869: void MachoID::UpdateCRC(unsigned char *bytes, size_t size) {
  3869: // Unrolled loops for summing
  3869: #define DO1(buf,i)  {sum1 += (buf)[i]; sum2 += sum1;}
  3869: #define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
  3869: #define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
  3869: #define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
  3869: #define DO16(buf)   DO8(buf,0); DO8(buf,8);
  3869:   // Split up the crc
  3869:   uint32_t sum1 = crc_ & 0xFFFF;
  3869:   uint32_t sum2 = (crc_ >> 16) & 0xFFFF;
  3869: 
  3869:   // Do large blocks
  3869:   while (size >= MAX_BLOCK) {
  3869:     size -= MAX_BLOCK;
  3869:     int block_count = MAX_BLOCK / 16;
  3869:     do {
  3869:       DO16(bytes);
  3869:       bytes += 16;
  3869:     } while (--block_count);
  3869:     sum1 %= MOD_ADLER;
  3869:     sum2 %= MOD_ADLER;
  3869:   }
  3869: 
  3869:   // Do remaining bytes
  3869:   if (size) {
  3869:     while (size >= 16) {
  3869:       size -= 16;
  3869:       DO16(bytes);
  3869:       bytes += 16;
  3869:     }
  3869:     while (size--) {
  3869:       sum1 += *bytes++;
  3869:       sum2 += sum1;
  3869:     }
  3869:     sum1 %= MOD_ADLER;
  3869:     sum2 %= MOD_ADLER;
  3869:     crc_ = (sum2 << 16) | sum1;
  3869:   }
  3869: }
  3869: 
  3869: void MachoID::UpdateMD5(unsigned char *bytes, size_t size) {
 57961:   MD5Update(&md5_context_, bytes, size);
  3869: }
  3869: 
 50677: void MachoID::Update(MachoWalker *walker, off_t offset, size_t size) {
  3869:   if (!update_function_ || !size)
  3869:     return;
  3869: 
  3869:   // Read up to 4k bytes at a time
  3869:   unsigned char buffer[4096];
  3869:   size_t buffer_size;
  3869:   off_t file_offset = offset;
  3869:   while (size > 0) {
  3869:     if (size > sizeof(buffer)) {
  3869:       buffer_size = sizeof(buffer);
  3869:       size -= buffer_size;
  3869:     } else {
  3869:       buffer_size = size;
  3869:       size = 0;
  3869:     }
  3869: 
  3869:     if (!walker->ReadBytes(buffer, buffer_size, file_offset))
  3869:       return;
  3869: 
  3869:     (this->*update_function_)(buffer, buffer_size);
  3869:     file_offset += buffer_size;
  3869:   }
  3869: }
  3869: 
118328: bool MachoID::UUIDCommand(cpu_type_t cpu_type,
118328:                           cpu_subtype_t cpu_subtype,
118328:                           unsigned char bytes[16]) {
  3889:   struct breakpad_uuid_command uuid_cmd;
  3869:   uuid_cmd.cmd = 0;
118328:   if (!WalkHeader(cpu_type, cpu_subtype, UUIDWalkerCB, &uuid_cmd))
  3869:     return false;
  3869: 
  3869:   // If we found the command, we'll have initialized the uuid_command
  3869:   // structure
  3869:   if (uuid_cmd.cmd == LC_UUID) {
  3869:     memcpy(bytes, uuid_cmd.uuid, sizeof(uuid_cmd.uuid));
  3869:     return true;
  3869:   }
  3869: 
  3869:   return false;
  3869: }
  3869: 
118328: bool MachoID::IDCommand(cpu_type_t cpu_type,
118328:                         cpu_subtype_t cpu_subtype,
118328:                         unsigned char identifier[16]) {
  3869:   struct dylib_command dylib_cmd;
  3869:   dylib_cmd.cmd = 0;
118328:   if (!WalkHeader(cpu_type, cpu_subtype, IDWalkerCB, &dylib_cmd))
  3869:     return false;
  3869: 
  3869:   // If we found the command, we'll have initialized the dylib_command
  3869:   // structure
  3869:   if (dylib_cmd.cmd == LC_ID_DYLIB) {
114869:     // Take the hashed filename, version, and compatability version bytes
  3869:     // to form the first 12 bytes, pad the rest with zeros
  3869: 
  3869:     // create a crude hash of the filename to generate the first 4 bytes
  3869:     identifier[0] = 0;
  3869:     identifier[1] = 0;
  3869:     identifier[2] = 0;
  3869:     identifier[3] = 0;
  3869: 
 50677:     for (int j = 0, i = (int)strlen(path_)-1; i>=0 && path_[i]!='/'; ++j, --i) {
  3869:       identifier[j%4] += path_[i];
  3869:     }
  3869: 
  3869:     identifier[4] = (dylib_cmd.dylib.current_version >> 24) & 0xFF;
  3869:     identifier[5] = (dylib_cmd.dylib.current_version >> 16) & 0xFF;
  3869:     identifier[6] = (dylib_cmd.dylib.current_version >> 8) & 0xFF;
  3869:     identifier[7] = dylib_cmd.dylib.current_version & 0xFF;
  3869:     identifier[8] = (dylib_cmd.dylib.compatibility_version >> 24) & 0xFF;
  3869:     identifier[9] = (dylib_cmd.dylib.compatibility_version >> 16) & 0xFF;
  3869:     identifier[10] = (dylib_cmd.dylib.compatibility_version >> 8) & 0xFF;
  3869:     identifier[11] = dylib_cmd.dylib.compatibility_version & 0xFF;
  3869:     identifier[12] = (cpu_type >> 24) & 0xFF;
  3869:     identifier[13] = (cpu_type >> 16) & 0xFF;
  3869:     identifier[14] = (cpu_type >> 8) & 0xFF;
  3869:     identifier[15] = cpu_type & 0xFF;
  3869: 
  3869:     return true;
  3869:   }
  3869: 
  3869:   return false;
  3869: }
  3869: 
118328: uint32_t MachoID::Adler32(cpu_type_t cpu_type, cpu_subtype_t cpu_subtype) {
  3869:   update_function_ = &MachoID::UpdateCRC;
  3869:   crc_ = 0;
  3869: 
118328:   if (!WalkHeader(cpu_type, cpu_subtype, WalkerCB, this))
  3869:     return 0;
  3869: 
  3869:   return crc_;
  3869: }
  3869: 
118328: bool MachoID::MD5(cpu_type_t cpu_type, cpu_subtype_t cpu_subtype, unsigned char identifier[16]) {
  3869:   update_function_ = &MachoID::UpdateMD5;
  3869: 
 57961:   MD5Init(&md5_context_);
114869: 
118328:   if (!WalkHeader(cpu_type, cpu_subtype, WalkerCB, this))
  3869:     return false;
  3869: 
 57961:   MD5Final(identifier, &md5_context_);
  3869:   return true;
  3869: }
  3869: 
118328: bool MachoID::WalkHeader(cpu_type_t cpu_type,
118328:                          cpu_subtype_t cpu_subtype,
114869:                          MachoWalker::LoadCommandCallback callback,
114869:                          void *context) {
114869:   if (memory_) {
114869:     MachoWalker walker(memory_, memory_size_, callback, context);
118328:     return walker.WalkHeader(cpu_type, cpu_subtype);
114869:   } else {
114869:     MachoWalker walker(path_, callback, context);
118328:     return walker.WalkHeader(cpu_type, cpu_subtype);
114869:   }
114869: }
114869: 
  3869: // static
  3869: bool MachoID::WalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
  3869:                        bool swap, void *context) {
  3869:   MachoID *macho_id = (MachoID *)context;
  3869: 
  3869:   if (cmd->cmd == LC_SEGMENT) {
  3869:     struct segment_command seg;
  3869: 
  3869:     if (!walker->ReadBytes(&seg, sizeof(seg), offset))
  3869:       return false;
  3869: 
  3869:     if (swap)
  3869:       swap_segment_command(&seg, NXHostByteOrder());
  3869: 
  3869:     struct mach_header_64 header;
  3869:     off_t header_offset;
  3869:     
  3869:     if (!walker->CurrentHeader(&header, &header_offset))
  3869:       return false;
  3869:         
  3869:     // Process segments that have sections:
  3869:     // (e.g., __TEXT, __DATA, __IMPORT, __OBJC)
  3869:     offset += sizeof(struct segment_command);
  3869:     struct section sec;
  3869:     for (unsigned long i = 0; i < seg.nsects; ++i) {
  3869:       if (!walker->ReadBytes(&sec, sizeof(sec), offset))
  3869:         return false;
  3869: 
  3869:       if (swap)
  3869:         swap_section(&sec, 1, NXHostByteOrder());
  3869: 
  3910:       // sections of type S_ZEROFILL are "virtual" and contain no data
  3910:       // in the file itself
  3910:       if ((sec.flags & SECTION_TYPE) != S_ZEROFILL && sec.offset != 0)
  3869:         macho_id->Update(walker, header_offset + sec.offset, sec.size);
  3910: 
  3869:       offset += sizeof(struct section);
  3869:     }
  3869:   } else if (cmd->cmd == LC_SEGMENT_64) {
  3869:     struct segment_command_64 seg64;
  3869: 
  3869:     if (!walker->ReadBytes(&seg64, sizeof(seg64), offset))
  3869:       return false;
  3869: 
  3869:     if (swap)
  3889:       breakpad_swap_segment_command_64(&seg64, NXHostByteOrder());
  3869: 
  3869:     struct mach_header_64 header;
  3869:     off_t header_offset;
  3869:     
  3869:     if (!walker->CurrentHeader(&header, &header_offset))
  3869:       return false;
  3869:     
  3869:     // Process segments that have sections:
  3869:     // (e.g., __TEXT, __DATA, __IMPORT, __OBJC)
  3869:     offset += sizeof(struct segment_command_64);
  3869:     struct section_64 sec64;
  3869:     for (unsigned long i = 0; i < seg64.nsects; ++i) {
  3869:       if (!walker->ReadBytes(&sec64, sizeof(sec64), offset))
  3869:         return false;
  3869: 
  3869:       if (swap)
  3889:         breakpad_swap_section_64(&sec64, 1, NXHostByteOrder());
  3869: 
  3910:       // sections of type S_ZEROFILL are "virtual" and contain no data
  3910:       // in the file itself
  3910:       if ((sec64.flags & SECTION_TYPE) != S_ZEROFILL && sec64.offset != 0)
 50677:         macho_id->Update(walker, 
 50677:                          header_offset + sec64.offset, 
 50677:                          (size_t)sec64.size);
  3910: 
  3869:       offset += sizeof(struct section_64);
  3869:     }
  3869:   }
  3869: 
  3869:   // Continue processing
  3869:   return true;
  3869: }
  3869: 
  3869: // static
  3869: bool MachoID::UUIDWalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
  3869:                            bool swap, void *context) {
  3869:   if (cmd->cmd == LC_UUID) {
  3889:     struct breakpad_uuid_command *uuid_cmd =
  3889:       (struct breakpad_uuid_command *)context;
  3869: 
  3889:     if (!walker->ReadBytes(uuid_cmd, sizeof(struct breakpad_uuid_command),
  3889:                            offset))
  3869:       return false;
  3869: 
  3869:     if (swap)
  3889:       breakpad_swap_uuid_command(uuid_cmd, NXHostByteOrder());
  3869: 
  3869:     return false;
  3869:   }
  3869: 
  3869:   // Continue processing
  3869:   return true;
  3869: }
  3869: 
  3869: // static
  3869: bool MachoID::IDWalkerCB(MachoWalker *walker, load_command *cmd, off_t offset,
  3869:                          bool swap, void *context) {
  3869:   if (cmd->cmd == LC_ID_DYLIB) {
  3869:     struct dylib_command *dylib_cmd = (struct dylib_command *)context;
  3869: 
  3869:     if (!walker->ReadBytes(dylib_cmd, sizeof(struct dylib_command), offset))
  3869:       return false;
  3869: 
  3869:     if (swap)
  3869:       swap_dylib_command(dylib_cmd, NXHostByteOrder());
  3869: 
  3869:     return false;
  3869:   }
  3869: 
  3869:   // Continue processing
  3869:   return true;
  3869: }
  3869: 
  3869: }  // namespace MacFileUtilities
