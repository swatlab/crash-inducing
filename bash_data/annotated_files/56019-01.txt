47525: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
47525:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
47525:  *
47525:  * ***** BEGIN LICENSE BLOCK *****
47525:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47525:  *
47525:  * The contents of this file are subject to the Mozilla Public License Version
47525:  * 1.1 (the "License"); you may not use this file except in compliance with
47525:  * the License. You may obtain a copy of the License at
47525:  * http://www.mozilla.org/MPL/
47525:  *
47525:  * Software distributed under the License is distributed on an "AS IS" basis,
47525:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47525:  * for the specific language governing rights and limitations under the
47525:  * License.
47525:  *
47525:  * The Original Code is mozilla.org code, released
47525:  * June 24, 2010.
47525:  *
47525:  * The Initial Developer of the Original Code is
47525:  *    The Mozilla Foundation
47525:  *
47525:  * Contributor(s):
47525:  *    Andreas Gal <gal@mozilla.com>
47525:  *
47525:  * Alternatively, the contents of this file may be used under the terms of
47525:  * either of the GNU General Public License Version 2 or later (the "GPL"),
47525:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47525:  * in which case the provisions of the GPL or the LGPL are applicable instead
47525:  * of those above. If you wish to allow use of your version of this file only
47525:  * under the terms of either the GPL or the LGPL, and not to allow others to
47525:  * use your version of this file under the terms of the MPL, indicate your
47525:  * decision by deleting the provisions above and replace them with the notice
47525:  * and other provisions required by the GPL or the LGPL. If you do not delete
47525:  * the provisions above, a recipient may use your version of this file under
47525:  * the terms of any one of the MPL, the GPL or the LGPL.
47525:  *
47525:  * ***** END LICENSE BLOCK ***** */
47525: 
47574: #include "AccessCheck.h"
47574: 
47574: #include "nsJSPrincipals.h"
47574: #include "nsIDOMWindow.h"
47574: #include "nsIDOMWindowCollection.h"
55581: #include "nsContentUtils.h"
47525: 
47525: #include "XPCWrapper.h"
55581: #include "XrayWrapper.h"
55644: #include "FilteringWrapper.h"
55644: #include "WrapperFactory.h"
47525: 
47525: namespace xpc {
47525: 
47574: static nsIPrincipal *
47525: GetCompartmentPrincipal(JSCompartment *compartment)
47525: {
55615:     return compartment->principals ? static_cast<nsJSPrincipals *>(compartment->principals)->nsIPrincipalPtr : 0;
47525: }
47525: 
47525: bool
47574: AccessCheck::isSameOrigin(JSCompartment *a, JSCompartment *b)
47574: {
55745:     nsIPrincipal *aprin = GetCompartmentPrincipal(a);
55745:     nsIPrincipal *bprin = GetCompartmentPrincipal(b);
55745: 
55745:     // If either a or b doesn't have principals, we don't have enough
55745:     // information to tell. Seeing as how this is Gecko, we are default-unsafe
55745:     // in this case.
55745:     if (!aprin || !bprin)
55745:         return true;
55745: 
47574:     PRBool cond;
55745:     return NS_SUCCEEDED(aprin->Equals(bprin, &cond)) && cond;
47574: }
47574: 
47574: bool
55629: AccessCheck::isLocationObjectSameOrigin(JSContext *cx, JSObject *wrapper)
55617: {
55629:     JSObject *obj = wrapper->unwrap()->getParent();
55617:     if (!obj->getClass()->ext.innerObject) {
55617:         obj = obj->unwrap();
55617:         JS_ASSERT(obj->getClass()->ext.innerObject);
55617:     }
55617:     OBJ_TO_INNER_OBJECT(cx, obj);
55629:     return obj && isSameOrigin(wrapper->compartment(), obj->compartment());
55617: }
55617: 
55617: bool
47574: AccessCheck::isChrome(JSCompartment *compartment)
47574: {
47574:     nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
47574:     if (!ssm) {
47574:         return false;
47574:     }
47574: 
47574:     PRBool privileged;
47574:     nsIPrincipal *principal = GetCompartmentPrincipal(compartment);
47574:     return NS_SUCCEEDED(ssm->IsSystemPrincipal(principal, &privileged)) && privileged;
47574: }
47574: 
55604: nsIPrincipal *
55604: AccessCheck::getPrincipal(JSCompartment *compartment)
55604: {
55604:     return GetCompartmentPrincipal(compartment);
55604: }
55604: 
47574: #define NAME(ch, str, cases) case ch: if (!strcmp(name, str)) switch (prop[0]) { cases }; break;
47574: #define PROP(ch, actions) case ch: { actions }; break;
47574: #define RW(str) if (!strcmp(prop, str)) return true;
47574: #define R(str) if (!set && !strcmp(prop, str)) return true;
47574: #define W(str) if (set && !strcmp(prop, str)) return true;
47574: 
47574: // Hardcoded policy for cross origin property access. This was culled from the
47574: // preferences file (all.js). We don't want users to overwrite highly sensitive
47574: // security policies.
47574: static bool
47574: IsPermitted(const char *name, const char* prop, bool set)
47574: {
47574:     switch(name[0]) {
47574:         NAME('D', "DOMException",
47574:              PROP('c', RW("code"))
47574:              PROP('m', RW("message"))
47574:              PROP('n', RW("name"))
55581:              PROP('r', RW("result"))
55581:              PROP('t', R("toString")))
55614:         NAME('E', "Error",
55614:              PROP('m', R("message")))
47574:         NAME('H', "History",
47574:              PROP('b', R("back"))
47574:              PROP('f', R("forward"))
47574:              PROP('g', R("go")))
55581:         NAME('L', "Location",
55581:              PROP('h', W("hash") W("href"))
55581:              PROP('r', R("replace")))
47574:         NAME('N', "Navigator",
47574:              PROP('p', RW("preference")))
47574:         NAME('W', "Window",
47574:              PROP('b', R("blur"))
47574:              PROP('c', R("close") R("closed"))
47574:              PROP('f', R("focus") R("frames"))
47574:              PROP('h', R("history"))
47574:              PROP('l', RW("location") R("length"))
47574:              PROP('o', R("opener"))
47574:              PROP('p', R("parent") R("postMessage"))
47574:              PROP('s', R("self"))
47574:              PROP('t', R("top"))
47574:              PROP('w', R("window")))
47574:     }
47574:     return false;
47574: }
47574: 
47574: #undef NAME
47574: #undef RW
47574: #undef R
47574: #undef W
47574: 
47574: static bool
55581: IsFrameId(JSContext *cx, JSObject *obj, jsid id)
47574: {
55581:     XPCWrappedNative *wn = XPCWrappedNative::GetWrappedNativeOfJSObject(cx, obj);
55581:     if (!wn) {
55581:         return false;
55581:     }
47574: 
47574:     nsCOMPtr<nsIDOMWindow> domwin(do_QueryWrappedNative(wn));
47574:     if (!domwin) {
47574:         return false;
47574:     }
47574: 
47574:     nsCOMPtr<nsIDOMWindowCollection> col;
47574:     domwin->GetFrames(getter_AddRefs(col));
47574:     if (!col) {
47574:         return false;
47574:     }
47574: 
47574:     if (JSID_IS_INT(id)) {
47574:         col->Item(JSID_TO_INT(id), getter_AddRefs(domwin));
47574:     } else if (JSID_IS_ATOM(id)) {
47574:         nsAutoString str(reinterpret_cast<PRUnichar *>
47574:                          (JS_GetStringChars(ATOM_TO_STRING(JSID_TO_ATOM(id)))));
47574:         col->NamedItem(str, getter_AddRefs(domwin));
47574:     } else {
47574:         return false;
47574:     }
47574: 
47574:     return domwin != nsnull;
47574: }
47574: 
47574: static bool
47574: IsWindow(const char *name)
47574: {
47574:     return name[0] == 'W' && !strcmp(name, "Window");
47574: }
47574: 
56019: static nsIPrincipal *
56019: GetPrincipal(JSObject *obj)
56019: {
56019:     NS_ASSERTION(!IS_SLIM_WRAPPER(obj), "global object is a slim wrapper?");
56019:     if (!IS_WN_WRAPPER(obj)) {
56019:         NS_ASSERTION(!(~obj->getClass()->flags &
56019:                        (JSCLASS_PRIVATE_IS_NSISUPPORTS | JSCLASS_HAS_PRIVATE)),
56019:                      "bad object");
56019:         nsCOMPtr<nsIScriptObjectPrincipal> objPrin =
56019:             do_QueryInterface((nsISupports*)xpc_GetJSPrivate(obj));
56019:         NS_ASSERTION(objPrin, "global isn't nsIScriptObjectPrincipal?");
56019:         return objPrin->GetPrincipal();
56019:     }
56019: 
56019:     nsIXPConnect *xpc = nsXPConnect::GetRuntimeInstance()->GetXPConnect();
56019:     return xpc->GetPrincipal(obj, PR_TRUE);
56019: }
56019: 
47574: bool
55587: AccessCheck::isCrossOriginAccessPermitted(JSContext *cx, JSObject *wrapper, jsid id,
55587:                                           JSWrapper::Action act)
47574: {
55581:     if (!XPCWrapper::GetSecurityManager())
55581:         return true;
55581: 
55587:     if (act == JSWrapper::CALL)
55587:         return true;
55587: 
47574:     JSObject *obj = JSWrapper::wrappedObject(wrapper);
47574: 
55581:     const char *name;
55581:     js::Class *clasp = obj->getClass();
55602:     NS_ASSERTION(Jsvalify(clasp) != &XrayUtils::HolderClass, "shouldn't have a holder here");
55581:     if (clasp->ext.innerObject)
55581:         name = "Window";
55581:     else
55581:         name = clasp->name;
47574: 
47574:     if (JSID_IS_ATOM(id)) {
47574:         JSString *str = ATOM_TO_STRING(JSID_TO_ATOM(id));
47574:         const char *prop = JS_GetStringBytes(str);
55587:         if (IsPermitted(name, prop, act == JSWrapper::SET))
47574:             return true;
47574:     }
47574: 
55581:     if (IsWindow(name) && IsFrameId(cx, obj, id))
47574:         return true;
47574: 
55648:     JSObject *scope = nsnull;
55648:     JSStackFrame *fp = nsnull;
55648:     JS_FrameIterator(cx, &fp);
55648:     if (fp) {
55648:         while (fp->isDummyFrame()) {
55648:             if (!JS_FrameIterator(cx, &fp))
55648:                 break;
55648:         }
55648: 
55648:         if (fp)
55648:             scope = &fp->scopeChain();
55648:     }
55648: 
55648:     if (!scope)
55648:         scope = JS_GetScopeChain(cx);
55648: 
55648:     nsIPrincipal *subject;
55651:     nsIPrincipal *object;
55648: 
55648:     {
55648:         JSAutoEnterCompartment ac;
55648: 
55648:         if (!ac.enter(cx, scope))
55648:             return false;
55648: 
56019:         subject = GetPrincipal(JS_GetGlobalForObject(cx, scope));
55648:     }
55648: 
55651:     {
55651:         JSAutoEnterCompartment ac;
55651: 
55651:         if (!ac.enter(cx, obj))
55651:             return false;
55651: 
56019:         object = GetPrincipal(JS_GetGlobalForObject(cx, obj));
55651:     }
55648: 
55648:     PRBool subsumes;
55651:     if (NS_SUCCEEDED(subject->Subsumes(object, &subsumes)) && subsumes)
55648:         return true;
55648: 
55587:     return (act == JSWrapper::SET)
55581:            ? nsContentUtils::IsCallerTrustedForWrite()
55581:            : nsContentUtils::IsCallerTrustedForRead();
47574: }
47574: 
47574: bool
47574: AccessCheck::isSystemOnlyAccessPermitted(JSContext *cx)
47525: {
47525:     nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
47525:     if (!ssm) {
47525:         return true;
47525:     }
47525: 
47574:     JSStackFrame *fp;
47574:     nsIPrincipal *principal = ssm->GetCxSubjectPrincipalAndFrame(cx, &fp);
47574:     if (!principal) {
47574:         return false;
47574:     }
47574: 
47574:     if (!fp) {
47574:         if (!JS_FrameIterator(cx, &fp)) {
47574:             // No code at all is running. So we must be arriving here as the result
47574:             // of C++ code asking us to do something. Allow access.
47525:             return true;
47525:         }
47574: 
47574:         // Some code is running, we can't make the assumption, as above, but we
47574:         // can't use a native frame, so clear fp.
47574:         fp = NULL;
53840:     } else if (!JS_IsScriptFrame(cx, fp)) {
47574:         fp = NULL;
47574:     }
47574: 
47574:     PRBool privileged;
47574:     if (NS_SUCCEEDED(ssm->IsSystemPrincipal(principal, &privileged)) &&
47574:         privileged) {
47525:         return true;
47525:     }
47574: 
47574:     // Allow any code loaded from chrome://global/ to touch us, even if it was
47574:     // cloned into a less privileged context.
47574:     static const char prefix[] = "chrome://global/";
47574:     const char *filename;
47574:     if (fp &&
53840:         (filename = JS_GetFrameScript(cx, fp)->filename) &&
47574:         !strncmp(filename, prefix, NS_ARRAY_LENGTH(prefix) - 1)) {
47574:         return true;
47574:     }
47574: 
47574:     return NS_SUCCEEDED(ssm->IsCapabilityEnabled("UniversalXPConnect", &privileged)) && privileged;
47574: }
47574: 
47574: bool
47574: AccessCheck::needsSystemOnlyWrapper(JSObject *obj)
47574: {
55576:     if (!IS_WN_WRAPPER(obj))
55576:         return false;
55576: 
47574:     XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(obj->getPrivate());
47574:     return wn->NeedsSOW();
47525: }
47525: 
55644: bool
55644: AccessCheck::isScriptAccessOnly(JSContext *cx, JSObject *wrapper)
55644: {
55644:     JS_ASSERT(wrapper->isWrapper());
55644: 
55644:     uintN flags;
55644:     JSObject *obj = wrapper->unwrap(&flags);
55644: 
55644:     // If the wrapper indicates script-only access, we are done.
55644:     if (flags & WrapperFactory::SCRIPT_ACCESS_ONLY_FLAG) {
55700:         if (flags & WrapperFactory::SOW_FLAG)
55700:             return !isSystemOnlyAccessPermitted(cx);
55700: 
55703:         if (flags & WrapperFactory::PARTIALLY_TRANSPARENT)
55703:             return !XrayUtils::IsTransparent(cx, wrapper);
55703: 
55644:         nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
55644:         if (!ssm)
55644:             return true;
55644: 
55644:         // Bypass script-only status if UniversalXPConnect is enabled.
55644:         PRBool privileged;
55644:         return !NS_SUCCEEDED(ssm->IsCapabilityEnabled("UniversalXPConnect", &privileged)) ||
55644:                !privileged;
55644:     }
55644: 
55644:     // In addition, chrome objects can explicitly opt-in by setting .scriptOnly to true.
55644:     if (wrapper->getProxyHandler() == &FilteringWrapper<JSCrossCompartmentWrapper,
55644:         CrossOriginAccessiblePropertiesOnly>::singleton) {
55644:         jsid scriptOnlyId = GetRTIdByIndex(cx, XPCJSRuntime::IDX_SCRIPTONLY);
55644:         jsval scriptOnly;
55644:         if (JS_LookupPropertyById(cx, obj, scriptOnlyId, &scriptOnly) &&
55644:             scriptOnly == JSVAL_TRUE)
55644:             return true; // script-only
55644:     }
55644: 
55644:     // Allow non-script access to same-origin location objects and any other
55644:     // objects.
55644:     return WrapperFactory::IsLocationObject(obj) && !isLocationObjectSameOrigin(cx, wrapper);
55644: }
55644: 
47525: void
47525: AccessCheck::deny(JSContext *cx, jsid id)
47525: {
48470:     if (id == JSID_VOID) {
47525:         JS_ReportError(cx, "Permission denied to access object");
47525:     } else {
48470:         jsval idval;
48470:         if (!JS_IdToValue(cx, id, &idval))
48470:             return;
48470:         JSString *str = JS_ValueToString(cx, idval);
48470:         if (!str)
48470:             return;
55581:         JS_ReportError(cx, "Permission denied to access property '%hs'", JS_GetStringChars(str));
47525:     }
47525: }
47525: 
47574: typedef enum { READ = (1<<0), WRITE = (1<<1), NO_ACCESS = 0 } Access;
47574: 
47525: bool
55587: ExposedPropertiesOnly::check(JSContext *cx, JSObject *wrapper, jsid id, JSWrapper::Action act,
55587:                              Permission &perm)
47525: {
47574:     JSObject *holder = JSWrapper::wrappedObject(wrapper);
47574: 
47574:     perm = DenyAccess;
47574: 
47574:     jsid exposedPropsId = GetRTIdByIndex(cx, XPCJSRuntime::IDX_EXPOSEDPROPS);
47574: 
47574:     JSBool found = JS_FALSE;
55601:     JSAutoEnterCompartment ac;
55601:     if (!ac.enter(cx, holder) || !JS_HasPropertyById(cx, holder, exposedPropsId, &found))
47574:         return false;
47574:     if (!found) {
47574:         perm = PermitObjectAccess;
47574:         return true; // Allow
47565:     }
47574: 
48470:     if (id == JSID_VOID) {
47574:         // This will force the caller to call us back for individual property accesses.
47574:         perm = PermitPropertyAccess;
47525:         return true;
47525:     }
47525: 
47574:     jsval exposedProps;
47574:     if (!JS_LookupPropertyById(cx, holder, exposedPropsId, &exposedProps))
47574:         return false;
47574: 
47574:     if (JSVAL_IS_VOID(exposedProps) || JSVAL_IS_NULL(exposedProps)) {
47574:         return true; // Deny
47525:     }
47574: 
47574:     if (!JSVAL_IS_OBJECT(exposedProps)) {
47574:         JS_ReportError(cx, "__exposedProps__ must be undefined, null, or an Object");
47574:         return false;
47574:     }
47574: 
47574:     JSObject *hallpass = JSVAL_TO_OBJECT(exposedProps);
47574: 
47574:     Access access = NO_ACCESS;
47574: 
55660:     JSPropertyDescriptor desc;
55660:     if (!JS_GetPropertyDescriptorById(cx, hallpass, id, JSRESOLVE_QUALIFIED, &desc)) {
47574:         return false; // Error
47574:     }
55660:     if (desc.obj == NULL || !(desc.attrs & JSPROP_ENUMERATE)) {
55660:         return true; // Deny
55660:     }
47574: 
55660:     if (!JSVAL_IS_STRING(desc.value)) {
47574:         JS_ReportError(cx, "property must be a string");
47574:         return false;
47574:     }
47574: 
55660:     JSString *str = JSVAL_TO_STRING(desc.value);
47574:     const jschar *chars = JS_GetStringChars(str);
47574:     size_t length = JS_GetStringLength(str);
47574:     for (size_t i = 0; i < length; ++i) {
47574:         switch (chars[i]) {
47574:         case 'r':
47574:             if (access & READ) {
47574:                 JS_ReportError(cx, "duplicate 'readable' property flag");
47574:                 return false;
47574:             }
47574:             access = Access(access | READ);
47574:             break;
47574: 
47574:         case 'w':
47574:             if (access & WRITE) {
47574:                 JS_ReportError(cx, "duplicate 'writable' property flag");
47574:                 return false;
47574:             }
47574:             access = Access(access | WRITE);
47574:             break;
47574: 
47574:         default:
47574:             JS_ReportError(cx, "properties can only be readable or read and writable");
47574:             return false;
47574:         }
47574:     }
47574: 
47574:     if (access == NO_ACCESS) {
47574:         JS_ReportError(cx, "specified properties must have a permission bit set");
47574:         return false;
47574:     }
47574: 
55587:     if ((act == JSWrapper::SET && !(access & WRITE)) ||
55587:         (act != JSWrapper::SET && !(access & READ))) {
47574:         return true; // Deny
47574:     }
47574: 
47574:     perm = PermitPropertyAccess;
47574:     return true; // Allow
47525: }
47525: 
47525: }
