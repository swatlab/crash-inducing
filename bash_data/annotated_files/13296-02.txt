    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Veditz <dveditz@netscape.com>
    1:  *   Samir Gehani <sgehani@netscape.com>
    1:  *   Mitch Stoltz <mstoltz@netscape.com>
    1:  *   Jeroen Dobbelaere <jeroen.dobbelaere@acunia.com>
    1:  *   Jeff Walden <jwalden+code@mit.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * This module implements a simple archive extractor for the PKZIP format.
    1:  *
    1:  * The underlying nsZipArchive is NOT thread-safe. Do not pass references
    1:  * or pointers to it across thread boundaries.
    1:  */
    1: 
    1: 
    1: #ifndef STANDALONE
    1: 
    1: #include "nsWildCard.h"
    1: #include "nscore.h"
    1: #include "prmem.h"
    1: #include "prio.h"
    1: #include "plstr.h"
    1: #include "prlog.h"
    1: #define ZFILE_CREATE    PR_WRONLY | PR_CREATE_FILE
    1: #define READTYPE  PRInt32
    1: #include "zlib.h"
    1: #include "nsISupportsUtils.h"
    1: #include "nsRecyclingAllocator.h"
    1: 
    1: /**
    1:  * Globals
    1:  *
    1:  * Global allocator used with zlib. Destroyed in module shutdown.
    1:  */
    1: #define NBUCKETS 6
    1: #define BY4ALLOC_ITEMS 320
    1: nsRecyclingAllocator *gZlibAllocator = NULL;
    1: 
    1: // For placement new used for arena allocations of zip file list
    1: #include NEW_H
    1: #define ZIP_ARENABLOCKSIZE (1*1024)
    1: 
    1: #else /* STANDALONE */
    1: 
    1: #ifdef XP_WIN
    1: #include "windows.h"
    1: #endif
    1: 
    1: #undef MOZILLA_CLIENT       // undoes prtypes damage in zlib.h
    1: #define ZFILE_CREATE  "wb"
    1: #define READTYPE  PRUint32
    1: #include "zlib.h"
    1: #undef PR_PUBLIC_API
    1: #include "zipstub.h"
    1: 
    1: #ifdef XP_MAC
    1: #include <string.h>
    1: #include <stdlib.h>
    1: 
    1: char * strdup(const char *src);
    1: char * strdup(const char *src)
    1: {
    1:     long len = strlen(src);
    1:     char *dup = (char *)malloc(len+1 * sizeof(char));
    1:     memcpy(dup, src, len+1);
    1:     return dup;
    1: }
    1: #endif
    1: 
    1: #endif /* STANDALONE */
    1: 
    1: #ifdef XP_UNIX
    1:     #include <sys/types.h>
    1:     #include <sys/stat.h>
    1:     #include <limits.h>
    1:     #include <unistd.h>
    1: #elif defined(XP_WIN) || defined(XP_OS2)
    1:     #include <io.h>
    1: #elif defined(XP_BEOS)
    1:     #include <unistd.h>
    1: #endif
    1: 
    1: #ifndef XP_UNIX /* we need some constants defined in limits.h and unistd.h */
    1: #  ifndef S_IFMT
    1: #    define S_IFMT 0170000
    1: #  endif
    1: #  ifndef S_IFLNK
    1: #    define S_IFLNK  0120000
    1: #  endif
    1: #  ifndef PATH_MAX
    1: #    define PATH_MAX 1024
    1: #  endif
    1: #endif  /* XP_UNIX */
    1: 
    1: #include "zipfile.h"
    1: #include "zipstruct.h"
    1: #include "nsZipArchive.h"
    1: 
    1: static PRUint16 xtoint(unsigned char *ii);
    1: static PRUint32 xtolong(unsigned char *ll);
    1: static PRUint16 ExtractMode(unsigned char *ll);
    1: static PRUint32 HashName(const char* aName);
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
    1: static PRBool IsSymlink(unsigned char *ll);
    1: static nsresult ResolveSymlink(const char *path);
    1: #endif
    1: 
    1: /*---------------------------------------------
    1:  * C API wrapper for nsZipArchive
    1:  *--------------------------------------------*/
    1: 
    1: #ifdef STANDALONE
    1: 
    1: /**
    1:  * ZIP_OpenArchive
    1:  *
    1:  * opens the named zip/jar archive and returns a handle that
    1:  * represents the archive in other ZIP_ calls.
    1:  *
    1:  * @param   zipname   archive filename
    1:  * @param   hZip      receives handle if archive opened OK
    1:  * @return  status code
    1:  */
    1: PR_PUBLIC_API(PRInt32) ZIP_OpenArchive(const char * zipname, void** hZip)
    1: {
    1:   PRInt32 status;
    1: 
    1:   /*--- error check args ---*/
    1:   if (hZip == 0)
    1:     return ZIP_ERR_PARAM;
    1: 
    1:   /*--- NULL output to prevent use by bozos who don't check errors ---*/
    1:   *hZip = 0;
    1: 
    1:   /*--- create and open the archive ---*/
    1:   nsZipArchive* zip = new nsZipArchive();
    1:   if (zip == 0)
    1:     return ZIP_ERR_MEMORY;
    1: 
    1:   PRFileDesc * fd = PR_Open(zipname, PR_RDONLY, 0400);
    1:   if (!fd) {
    1:     delete zip;
    1:     return ZIP_ERR_DISK;
    1:   }
    1: 
    1:   status = zip->OpenArchive(fd);
    1:   if (status == ZIP_OK)
 3233:     *hZip = static_cast<void*>(zip);
    1:   else {
    1:     delete zip;
    1:     PR_Close(fd);
    1:   }
    1: 
    1:   return status;
    1: }
    1: 
    1: 
    1: 
    1: /**
    1:  * ZIP_TestArchive
    1:  *
    1:  * Tests the integrity of this open zip archive by extracting each
    1:  * item to memory and performing a CRC check.
    1:  *
    1:  * @param   hZip      handle obtained from ZIP_OpenArchive
    1:  * @return  status code (success indicated by ZIP_OK)
    1:  */
    1: PR_PUBLIC_API(PRInt32) ZIP_TestArchive(void *hZip)
    1: {
    1:   /*--- error check args ---*/
    1:   if (hZip == 0)
    1:     return ZIP_ERR_PARAM;
    1: 
 3233:   nsZipArchive* zip = static_cast<nsZipArchive*>(hZip);
    1:   if (zip->kMagic != ZIP_MAGIC)
    1:     return ZIP_ERR_PARAM;   /* whatever it is isn't one of ours! */
    1: 
    1:   /*--- test the archive ---*/
    1:   return zip->Test(NULL);
    1: }
    1: 
    1: 
    1: /**
    1:  * ZIP_CloseArchive
    1:  *
    1:  * closes zip archive and frees memory
    1:  * @param   hZip  handle obtained from ZIP_OpenArchive
    1:  * @return  status code
    1:  */
    1: PR_PUBLIC_API(PRInt32) ZIP_CloseArchive(void** hZip)
    1: {
    1:   /*--- error check args ---*/
    1:   if (hZip == 0 || *hZip == 0)
    1:     return ZIP_ERR_PARAM;
    1: 
 3233:   nsZipArchive* zip = static_cast<nsZipArchive*>(*hZip);
    1:   if (zip->kMagic != ZIP_MAGIC)
    1:     return ZIP_ERR_PARAM;   /* whatever it is isn't one of ours! */
    1: 
    1:   /*--- close the archive ---*/
    1:   *hZip = 0;
    1:   delete zip;
    1: 
    1:   return ZIP_OK;
    1: }
    1: 
    1: 
    1: 
    1: /**
    1:  * ZIP_ExtractFile
    1:  *
    1:  * extracts named file from an opened archive
    1:  *
    1:  * @param   hZip      handle obtained from ZIP_OpenArchive
    1:  * @param   filename  name of file in archive
    1:  * @param   outname   filename to extract to
    1:  */
    1: PR_PUBLIC_API(PRInt32) ZIP_ExtractFile(void* hZip, const char * filename, const char * outname)
    1: {
    1:   /*--- error check args ---*/
    1:   if (hZip == 0)
    1:     return ZIP_ERR_PARAM;
    1: 
 3233:   nsZipArchive* zip = static_cast<nsZipArchive*>(hZip);
    1:   if (zip->kMagic != ZIP_MAGIC)
    1:     return ZIP_ERR_PARAM;   /* whatever it is isn't one of ours! */
    1: 
    1:   //-- Find item in archive
    1:   nsZipItem* item = zip->GetItem(filename);
    1:   if (!item)
    1:     return ZIP_ERR_FNF;
    1: 
    1:   // Can't extract a directory
    1:   if (item->isDirectory)
    1:     return ZIP_ERR_PARAM;
    1: 
    1:   // delete any existing file so that we overwrite the file permissions         
    1:   PR_Delete(outname);
    1:                                                                     
    1:   PRFileDesc* fOut = PR_Open(outname, ZFILE_CREATE, item->mode);
    1:   if (!fOut)
    1:     return ZIP_ERR_DISK;
    1: 
    1: #if defined(XP_UNIX) && defined(STANDALONE)
    1:   // When STANDALONE is defined, PR_Open ignores its 3d argument.
    1:   mode_t msk = umask(0);
    1:   umask(msk);
    1:   chmod(outname, (item->mode | S_IRUSR) & ~msk);
    1: #endif
    1: 
    1:   // ExtractFile also closes the fOut handle and resolves the symlink if needed
    1:   return zip->ExtractFile(item, outname, fOut);
    1: }
    1: 
    1: 
    1: 
    1: /**
    1:  * ZIP_FindInit
    1:  *
    1:  * Initializes an enumeration of files in the archive
    1:  *
    1:  * @param   hZip      handle obtained from ZIP_OpenArchive
    1:  * @param   pattern   regexp to match files in archive, the usual shell expressions.
    1:  *                    NULL pattern also matches all files, faster than "*"
    1:  */
    1: PR_PUBLIC_API(void*) ZIP_FindInit(void* hZip, const char * pattern)
    1: {
    1:   /*--- error check args ---*/
    1:   if (hZip == 0)
    1:     return 0;
    1: 
 3233:   nsZipArchive* zip = static_cast<nsZipArchive*>(hZip);
    1:   if (zip->kMagic != ZIP_MAGIC)
    1:     return 0;   /* whatever it is isn't one of ours! */
    1: 
    1:   /*--- initialize the pattern search ---*/
    1:   nsZipFind* find;
    1:   PRInt32 rv = zip->FindInit(pattern, &find);
    1:   if (rv != ZIP_OK)
    1:       find = NULL;
    1: 
    1:   return find;
    1: }
    1: 
    1: 
    1: 
    1: /**
    1:  * ZIP_FindNext
    1:  *
    1:  * Puts the next name in the passed buffer. Returns ZIP_ERR_SMALLBUF when
    1:  * the name is too large for the buffer, and ZIP_ERR_FNF when there are no
    1:  * more files that match the pattern
    1:  *
    1:  * @param   hFind     handle obtained from ZIP_FindInit
    1:  * @param   outbuf    buffer to receive next filename
    1:  * @param   bufsize   size of allocated buffer
    1:  */
    1: PR_PUBLIC_API(PRInt32) ZIP_FindNext(void* hFind, char * outbuf, PRUint16 bufsize)
    1: {
    1:   PRInt32 status;
    1: 
    1:   /*--- error check args ---*/
    1:   if (hFind == 0)
    1:     return ZIP_ERR_PARAM;
    1: 
 3233:   nsZipFind* find = static_cast<nsZipFind*>(hFind);
    1:   if (find->kMagic != ZIPFIND_MAGIC)
    1:     return ZIP_ERR_PARAM;   /* whatever it is isn't one of ours! */
    1: 
    1:   /*--- return next filename file ---*/
    1:   const char* itemName;
    1:   status = find->FindNext(&itemName);
    1:   if (status == ZIP_OK)
    1:   {
    1:     PRUint16 namelen = (PRUint16)PL_strlen(itemName);
    1: 
    1:     if (bufsize > namelen)
    1:     {
    1:         PL_strcpy(outbuf, itemName);
    1:     }
    1:     else
    1:         status = ZIP_ERR_SMALLBUF;
    1:   }
    1: 
    1:   return status;
    1: }
    1: 
    1: 
    1: 
    1: /**
    1:  * ZIP_FindFree
    1:  *
    1:  * Releases allocated memory associated with the find token
    1:  *
    1:  * @param   hFind     handle obtained from ZIP_FindInit
    1:  */
    1: PR_PUBLIC_API(PRInt32) ZIP_FindFree(void* hFind)
    1: {
    1:   /*--- error check args ---*/
    1:   if (hFind == 0)
    1:     return ZIP_ERR_PARAM;
    1: 
 3233:   nsZipFind* find = static_cast<nsZipFind*>(hFind);
    1:   if (find->kMagic != ZIPFIND_MAGIC)
    1:     return ZIP_ERR_PARAM;   /* whatever it is isn't one of ours! */
    1: 
    1:   /* free the find structure */
    1:   delete find;
    1:   return ZIP_OK;
    1: }
    1: 
    1: #if defined XP_WIN
    1: void ProcessWindowsMessages()
    1: {
    1:   MSG msg;
    1: 
    1:   while(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    1:   {
    1:     TranslateMessage(&msg);
    1:     DispatchMessage(&msg);
    1:   }
    1: }
    1: #endif /* XP_WIN */
    1: 
    1: #else /* STANDALONE */
    1: 
    1: //***********************************************************
    1: // Allocators for use with zlib
    1: //
    1: // These are allocators that are performance tuned for
    1: // use with zlib. Our use of zlib for every file we read from
    1: // the jar file when running navigator, we do these allocation.
    1: // alloc 24
    1: // alloc 64
    1: // alloc 11520
    1: // alloc 32768
    1: // alloc 1216 [304x4] max
    1: // alloc 76   [19x4]
    1: // free  76   [19x4]
    1: // alloc 1152 [288x4]
    1: // free  1152 [288x4]
    1: // free  1216 [304x4]
    1: // alloc 28
    1: // free  28
    1: // free  32768
    1: // free  11520
    1: // free  64
    1: // free  24
    1: //
    1: // The pool will allocate these as:
    1: //
    1: //          32,768
    1: //          11,520
    1: //           1,280 [320x4] - shared by first x4 alloc, 28
    1: //           1,280 [320x4] - shared by second and third x4 alloc
    1: //              64
    1: //              24
    1: //          ------
    1: //          46,936
    1: //
    1: // And almost all of the file reads happen serially. Hence this
    1: // allocator tries to keep one set of memory needed for one file around
    1: // and reused the same blocks for other file reads.
    1: //
    1: // The interesting question is when should be free this ?
    1: // - memory pressure should be one.
    1: // - after startup of navigator
    1: // - after startup of mail
    1: // In general, this allocator should be enabled before
    1: // we startup and disabled after we startup if memory is a concern.
    1: //***********************************************************
    1: 
    1: PR_STATIC_CALLBACK(void *)
    1: zlibAlloc(void *opaque, uInt items, uInt size)
    1: {
    1:   nsRecyclingAllocator *zallocator = (nsRecyclingAllocator *)opaque;
    1:   if (zallocator) {
    1:     // Bump up x4 allocations
    1:     PRUint32 realitems = items;
    1:     if (size == 4 && items < BY4ALLOC_ITEMS)
    1:       realitems = BY4ALLOC_ITEMS;
    1:      return zallocator->Calloc(realitems, size);
    1:   }
    1:   else
    1:     return calloc(items, size);
    1: }
    1: 
    1: PR_STATIC_CALLBACK(void)
    1: zlibFree(void *opaque, void *ptr)
    1: {
    1:   nsRecyclingAllocator *zallocator = (nsRecyclingAllocator *)opaque;
    1:   if (zallocator)
    1:     zallocator->Free(ptr);
    1:   else
    1:     free(ptr);
    1:   return;
    1: }
    1: #endif /* STANDALONE */
    1: 
    1: nsresult gZlibInit(z_stream *zs)
    1: {
    1:   memset(zs, 0, sizeof(z_stream));
    1: #ifndef STANDALONE
    1:   //-- ensure we have our zlib allocator for better performance
    1:   if (!gZlibAllocator) {
    1:     gZlibAllocator = new nsRecyclingAllocator(NBUCKETS, NS_DEFAULT_RECYCLE_TIMEOUT, "libjar");
    1:   }
    1:   if (gZlibAllocator) {
    1:     zs->zalloc = zlibAlloc;
    1:     zs->zfree = zlibFree;
    1:     zs->opaque = gZlibAllocator;
    1:   }
    1: #endif /* STANDALONE */
    1:   int zerr = inflateInit2(zs, -MAX_WBITS);
    1:   if (zerr != Z_OK) return ZIP_ERR_MEMORY;
    1: 
    1:   return ZIP_OK;
    1: }
    1: 
    1: //***********************************************************
    1: //      nsZipArchive  --  public methods
    1: //***********************************************************
    1: 
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::OpenArchive
    1: //---------------------------------------------
    1: nsresult nsZipArchive::OpenArchive(PRFileDesc * fd)
    1: {
    1:   if (!fd)
    1:     return ZIP_ERR_PARAM;
    1: 
    1: #ifndef STANDALONE
    1:   // Initialize our arena
    1:   PL_INIT_ARENA_POOL(&mArena, "ZipArena", ZIP_ARENABLOCKSIZE);
    1: #endif
    1: 
    1:   //-- Keep the filedescriptor for further reading...
    1:   mFd = fd;
    1: 
    1:   //-- get table of contents for archive
    1:   return BuildFileList();
    1: }
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::Test
    1: //---------------------------------------------
    1: nsresult nsZipArchive::Test(const char *aEntryName)
    1: {
    1:   nsZipItem* currItem;
    1: 
    1:   if (aEntryName) // only test specified item
    1:   {
    1:     currItem = GetItem(aEntryName);
    1:     if (!currItem)
    1:       return ZIP_ERR_FNF;
    1:     //-- don't test (synthetic) directory items
    1:     if (currItem->isDirectory)
    1:       return ZIP_OK;
    1:     return ExtractFile(currItem, 0, 0);
    1:   }
    1: 
    1:   // test all items in archive
    1:   for (int i = 0; i < ZIP_TABSIZE; i++) {
    1:     for (currItem = mFiles[i]; currItem; currItem = currItem->next) {
    1:       //-- don't test (synthetic) directory items
    1:       if (currItem->isDirectory)
    1:         continue;
    1:       nsresult rv = ExtractFile(currItem, 0, 0);
    1:       if (rv != ZIP_OK)
    1:         return rv;
    1: #if defined STANDALONE && defined XP_WIN
    1:       ProcessWindowsMessages();
    1: #endif
    1:     }
    1:   }
    1: 
    1:   return ZIP_OK;
    1: }
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::CloseArchive
    1: //---------------------------------------------
    1: nsresult nsZipArchive::CloseArchive()
    1: {
    1: #ifndef STANDALONE
    1:   if (mFd) {
    1:     PL_FinishArenaPool(&mArena);
    1:   }
    1: 
    1:   // CAUTION:
    1:   // We don't need to delete each of the nsZipItem as the memory for
    1:   // the zip item and the filename it holds are both allocated from the Arena.
    1:   // Hence, destroying the Arena is like destroying all the memory
    1:   // for all the nsZipItem in one shot. But if the ~nsZipItem is doing
    1:   // anything more than cleaning up memory, we should start calling it.
    1:   // Let us also cleanup the mFiles table for re-use on the next 'open' call
    1:   for (int i = 0; i < ZIP_TABSIZE; i++) {
    1:     mFiles[i] = 0;
    1:   }
    1: #else
    1:   // delete nsZipItems in table
    1:   nsZipItem* pItem;
    1:   for (int i = 0; i < ZIP_TABSIZE; ++i)
    1:   {
    1:     pItem = mFiles[i];
    1:     while (pItem != 0)
    1:     {
    1:       mFiles[i] = pItem->next;
    1:       free(pItem);
    1:       pItem = mFiles[i];
    1:     }
    1:     mFiles[i] = 0;              // make sure we don't double-delete
    1:   }
    1: #endif
    1:   
    1:   if (mFd) {
    1:     PR_Close(mFd);
    1:     mFd = 0;
    1:   }
    1:   mBuiltSynthetics = PR_FALSE;
    1:   return ZIP_OK;
    1: }
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::GetItem
    1: //---------------------------------------------
    1: nsZipItem*  nsZipArchive::GetItem(const char * aEntryName)
    1: {
    1:   if (aEntryName) {
    1:     //-- If the request is for a directory, make sure that synthetic entries 
    1:     //-- are created for the directories without their own entry.
    1:     if (!mBuiltSynthetics) {
    1:         PRUint32 len = strlen(aEntryName);
    1:         if ((len > 0) && (aEntryName[len-1] == '/')) {
    1:             if (BuildSynthetics() != ZIP_OK)
    1:                 return 0;
    1:         }
    1:     }
    1: 
    1:     nsZipItem* item = mFiles[ HashName(aEntryName) ];
    1:     while (item) {
    1:       if (!strcmp(aEntryName, item->name))
    1:         return item; //-- found it
    1:       item = item->next;
    1:     }
    1:   }
    1:   return 0;
    1: }
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::ExtractFile
    1: // This extracts the item to the filehandle provided.
    1: // If 'aFd' is null, it only tests the extraction.
    1: // On extraction error(s) it removes the file.
    1: // When needed, it also resolves the symlink.
    1: //---------------------------------------------
    1: nsresult nsZipArchive::ExtractFile(nsZipItem *item, const char *outname,
    1:                                    PRFileDesc* aFd)
    1: {
    1:   if (!item)
    1:     return ZIP_ERR_PARAM;
    1:   if (!mFd)
    1:     return ZIP_ERR_GENERAL;
    1: 
    1:   // Directory extraction is handled in nsJAR::Extract,
    1:   // so the item to be extracted should never be a directory
    1:   PR_ASSERT(!item->isDirectory);
    1: 
    1:   //-- move to the start of file's data
    1:   if (SeekToItem(item, mFd) != ZIP_OK)
    1:     return ZIP_ERR_CORRUPT;
    1: 
    1:   nsresult rv;
    1: 
    1:   //-- extract the file using the appropriate method
    1:   switch(item->compression)
    1:   {
    1:     case STORED:
    1:       rv = CopyItemToDisk(item->size, item->crc32, aFd);
    1:       break;
    1: 
    1:     case DEFLATED:
    1:       rv = InflateItem(item, aFd);
    1:       break;
    1: 
    1:     default:
    1:       //-- unsupported compression type
    1:       rv = ZIP_ERR_UNSUPPORTED;
    1:   }
    1: 
    1:   //-- delete the file on errors, or resolve symlink if needed
    1:   if (aFd) {
    1:     PR_Close(aFd);
    1:     if (rv != ZIP_OK)
    1:       PR_Delete(outname);
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
    1:     else if (item->isSymlink)
    1:       rv = ResolveSymlink(outname);
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::FindInit
    1: //---------------------------------------------
    1: PRInt32
    1: nsZipArchive::FindInit(const char * aPattern, nsZipFind **aFind)
    1: {
    1:   if (!aFind)
    1:     return ZIP_ERR_PARAM;
    1: 
    1:   // null out param in case an error happens
    1:   *aFind = NULL;
    1: 
    1:   PRBool  regExp = PR_FALSE;
    1:   char*   pattern = 0;
    1: 
    1:   // Create synthetic directory entries on demand
    1:   nsresult rv = BuildSynthetics();
    1:   if (rv != ZIP_OK)
    1:     return rv;
    1: 
    1:   // validate the pattern
    1:   if (aPattern)
    1:   {
    1:     switch (NS_WildCardValid((char*)aPattern))
    1:     {
    1:       case INVALID_SXP:
    1:         return ZIP_ERR_PARAM;
    1: 
    1:       case NON_SXP:
    1:         regExp = PR_FALSE;
    1:         break;
    1: 
    1:       case VALID_SXP:
    1:         regExp = PR_TRUE;
    1:         break;
    1: 
    1:       default:
    1:         // undocumented return value from RegExpValid!
    1:         PR_ASSERT(PR_FALSE);
    1:         return ZIP_ERR_PARAM;
    1:     }
    1: 
    1:     pattern = PL_strdup(aPattern);
    1:     if (!pattern)
    1:       return ZIP_ERR_MEMORY;
    1:   }
    1: 
    1:   *aFind = new nsZipFind(this, pattern, regExp);
    1:   if (!*aFind) {
    1:     PR_FREEIF(pattern);
    1:     return ZIP_ERR_MEMORY;
    1:   }
    1: 
    1:   return ZIP_OK;
    1: }
    1: 
    1: 
    1: 
    1: //---------------------------------------------
    1: // nsZipFind::FindNext
    1: //---------------------------------------------
    1: nsresult nsZipFind::FindNext(const char ** aResult)
    1: {
    1:   if (!mArchive || !aResult)
    1:     return ZIP_ERR_PARAM;
    1: 
    1:   *aResult = 0;
    1: 
    1:   // we start from last match, look for next
    1:   while (mSlot < ZIP_TABSIZE)
    1:   {
    1:     // move to next in current chain, or move to new slot
    1:     mItem = mItem ? mItem->next : mArchive->mFiles[mSlot];
    1: 
    1:     PRBool found = PR_FALSE;
    1:     if (!mItem)
    1:       ++mSlot;                          // no more in this chain, move to next slot
    1:     else if (!mPattern)
    1:       found = PR_TRUE;            // always match
    1:     else if (mRegExp)
    1:       found = (NS_WildCardMatch(mItem->name, mPattern, PR_FALSE) == MATCH);
    1:     else
    1: #if defined(STANDALONE) && defined(XP_MAC)
    1:       // simulate <regexp>* matches
    1:       found = (strncmp(mItem->name, mPattern, strlen(mPattern)) == 0);
    1: #else
    1:       found = (PL_strcmp(mItem->name, mPattern) == 0);
    1: #endif
    1: 
    1:     if (found) {
    1:       *aResult = mItem->name;
    1:       return ZIP_OK;
    1:     }
    1:   }
    1: 
    1:   return ZIP_ERR_FNF;
    1: }
    1: 
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
    1: //---------------------------------------------
    1: // ResolveSymlink
    1: //---------------------------------------------
    1: static nsresult ResolveSymlink(const char *path)
    1: {
    1:   PRFileDesc * fIn = PR_Open(path, PR_RDONLY, 0000);
    1:   if (!fIn)
    1:     return ZIP_ERR_DISK;
    1: 
    1:   char buf[PATH_MAX+1];
    1:   PRInt32 length = PR_Read(fIn, (void*)buf, PATH_MAX);
    1:   PR_Close(fIn);
    1: 
    1:   if ( (length <= 0)
    1:     || ((buf[length] = 0, PR_Delete(path)) != 0)
    1:     || (symlink(buf, path) != 0))
    1:   {
    1:      return ZIP_ERR_DISK;
    1:   }
    1:   return ZIP_OK;
    1: }
    1: #endif
    1: 
    1: //***********************************************************
    1: //      nsZipArchive  --  private implementation
    1: //***********************************************************
    1: 
    1: #define BR_BUF_SIZE 1024 /* backward read buffer size */
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::CreateZipItem
    1: //---------------------------------------------
    1: nsZipItem* nsZipArchive::CreateZipItem(PRUint16 namelen)
    1: {
    1:   // sizeof(nsZipItem) includes space for name's null byte
    1: #ifndef STANDALONE
    1:   // Arena allocate the nsZipItem
    1:   void *mem;
    1:   PL_ARENA_ALLOCATE(mem, &mArena, sizeof(nsZipItem)+namelen);
    1:   return (nsZipItem*)mem;
    1: #else
    1:   return (nsZipItem*)malloc(sizeof(nsZipItem)+namelen);
    1: #endif
    1: }
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::BuildFileList
    1: //---------------------------------------------
    1: nsresult nsZipArchive::BuildFileList()
    1: {
    1:   PRUint8   buf[4*BR_BUF_SIZE];
    1: 
    1:   //-----------------------------------------------------------------------
    1:   // locate the central directory via the End record
    1:   //-----------------------------------------------------------------------
    1: 
    1:   //-- get archive size using end pos
    1:   PRInt32  pos = PR_Seek(mFd, 0, PR_SEEK_END);
    1: #ifndef STANDALONE
    1:   if (pos <= 0)
    1: #else
    1:   if (pos || ((pos = ftell(mFd)) <= 0))
    1: #endif
    1:     return ZIP_ERR_CORRUPT;
    1: 
    1:   PRBool bEndsigFound = PR_FALSE;
    1:   while (!bEndsigFound)
    1:   {
    1:     //-- read backwards in 1K-sized chunks (unless file is less than 1K)
    1:     PRInt32  bufsize = pos > BR_BUF_SIZE ? BR_BUF_SIZE : pos;
    1:     pos -= bufsize;
    1: 
    1:     if (!ZIP_Seek(mFd, pos, PR_SEEK_SET))
    1:       return ZIP_ERR_CORRUPT;
    1: 
    1:     if (PR_Read(mFd, buf, bufsize) != (READTYPE)bufsize)
    1:       return ZIP_ERR_CORRUPT;
    1: 
    1:     //-- scan for ENDSIG
    1:     PRUint8 *endp = buf + bufsize;
    1:     for (endp -= ZIPEND_SIZE; endp >= buf; endp--)
    1:     {
    1:       if (xtolong(endp) == ENDSIG)
    1:       { 
    1:         //-- Seek to start of central directory
    1:         PRInt32 central = xtolong(((ZipEnd *) endp)->offset_central_dir);
    1:         if (!ZIP_Seek(mFd, central, PR_SEEK_SET))
    1:           return ZIP_ERR_CORRUPT;
    1: 
    1:         bEndsigFound = PR_TRUE;
    1:         break;
    1:       }
    1:     }
    1: 
    1:     if (bEndsigFound)
    1:       break;
    1: 
    1:     if (pos <= 0)
    1:       //-- We're at the beginning of the file, and still no sign
    1:       //-- of the end signature.  File must be corrupted!
    1:       return ZIP_ERR_CORRUPT;
    1: 
    1:     //-- backward read must overlap ZipEnd length
    1:     pos += ZIPEND_SIZE;
    1: 
    1:   } /* while looking for end signature */
    1: 
    1: 
    1:   //-------------------------------------------------------
    1:   // read the central directory headers
    1:   //-------------------------------------------------------
    1:   PRInt32 byteCount = PR_Read(mFd, &buf, sizeof(buf));
    1:   pos = 0;
    1:   PRUint32 sig = xtolong(buf);
    1:   while (sig == CENTRALSIG) {
    1:     //-- make sure we've read enough
    1:     if (byteCount - pos < ZIPCENTRAL_SIZE)
    1:       return ZIP_ERR_CORRUPT;
    1: 
    1:     //-------------------------------------------------------
    1:     // read the fixed-size data
    1:     //-------------------------------------------------------
    1:     ZipCentral* central = (ZipCentral*)(buf+pos);
    1: 
    1:     PRUint16 namelen = xtoint(central->filename_len);
    1:     PRUint16 extralen = xtoint(central->extrafield_len);
    1:     PRUint16 commentlen = xtoint(central->commentfield_len);
    1: 
13296:     //-- sanity check variable sizes and refuse to deal with
13296:     //-- anything too big: it's likely a corrupt archive
13296:     if (namelen > BR_BUF_SIZE || extralen > BR_BUF_SIZE || commentlen > 2*BR_BUF_SIZE)
13296:       return ZIP_ERR_CORRUPT;
13296: 
    1:     nsZipItem* item = CreateZipItem(namelen);
    1:     if (!item)
    1:       return ZIP_ERR_MEMORY;
    1: 
    1:     item->headerOffset  = xtolong(central->localhdr_offset);
    1:     item->dataOffset    = 0;
    1:     item->size          = xtolong(central->size);
    1:     item->realsize      = xtolong(central->orglen);
    1:     item->crc32         = xtolong(central->crc32);
    1:     item->time          = xtoint(central->time);
    1:     item->date          = xtoint(central->date);
    1:     item->isSynthetic   = PR_FALSE;
    1:     item->hasDataOffset = PR_FALSE;
13296: 
13296:     PRUint16 compression = xtoint(central->method);
13296:     item->compression   = (compression < UNSUPPORTED) ? (PRUint8)compression
13296:                                                       : UNSUPPORTED;
    1: 
    1:     item->mode = ExtractMode(central->external_attributes);
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
    1:     // Check if item is a symlink
    1:     item->isSymlink = IsSymlink(central->external_attributes);
    1: #endif
    1: 
    1:     pos += ZIPCENTRAL_SIZE;
    1: 
    1:     //-------------------------------------------------------
    1:     // Make sure that remainder of this record (name, comments, extra)
    1:     // and the next ZipCentral is all in the buffer
    1:     //-------------------------------------------------------
    1:     PRInt32 leftover = byteCount - pos;
    1:     if (leftover < (namelen + extralen + commentlen + ZIPCENTRAL_SIZE)) {
    1:       //-- not enough data left to process at top of loop.
    1:       //-- move leftover and read more
    1:       memcpy(buf, buf+pos, leftover);
    1:       byteCount = leftover + PR_Read(mFd, buf+leftover, sizeof(buf)-leftover);
    1:       pos = 0;
13296: 
13296:       if (byteCount < (namelen + extralen + commentlen + sizeof(sig))) {
13296:         // truncated file
13296:         return ZIP_ERR_CORRUPT;
13296:       }
    1:     }
    1: 
    1:     //-------------------------------------------------------
    1:     // get the item name
    1:     //-------------------------------------------------------
    1:     memcpy(item->name, buf+pos, namelen);
    1:     item->name[namelen] = 0;
    1: 
    1:     //-- an item whose name ends with '/' is a directory
    1:     item->isDirectory = ('/' == item->name[namelen - 1]);
    1: 
    1:     //-- add item to file table
    1:     //-- note that an explicit entry for a directory will override
    1:     //-- a fake entry created for that directory (as in the case
    1:     //-- of processing foo/bar.txt and then foo/) -- this will
    1:     //-- preserve an explicit directory's metadata at the cost of
    1:     //-- an extra nsZipItem (and that only happens if we process a
    1:     //-- file inside that directory before processing the directory
    1:     //-- entry itself)
    1:     PRUint32 hash = HashName(item->name);
    1:     item->next = mFiles[hash];
    1:     mFiles[hash] = item;
    1: 
    1:     //-------------------------------------------------------
    1:     // set up to process the next item at the top of loop
    1:     //-------------------------------------------------------
    1:     pos += namelen + extralen + commentlen;
    1:     sig = xtolong(buf+pos);
    1:   } /* while reading central directory records */
    1: 
    1:   if (sig != ENDSIG)
    1:     return ZIP_ERR_CORRUPT;
    1: 
    1:   return ZIP_OK;
    1: }
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::BuildSynthetics
    1: //---------------------------------------------
    1: nsresult nsZipArchive::BuildSynthetics()
    1: {
    1:   if (mBuiltSynthetics)
    1:     return ZIP_OK;
    1:   mBuiltSynthetics = PR_TRUE;
    1: 
    1:   // Create synthetic entries for any missing directories.
    1:   // Do this when all ziptable has scanned to prevent double entries.
    1:   for (int i = 0; i < ZIP_TABSIZE; ++i)
    1:   {
    1:     for (nsZipItem* item = mFiles[i]; item != 0; item = item->next)
    1:     {
    1:       if (item->isSynthetic)
    1:         continue;
    1:     
    1:       //-- add entries for directories in the current item's path
    1:       //-- go from end to beginning, because then we can stop trying
    1:       //-- to create diritems if we find that the diritem we want to
    1:       //-- create already exists
    1:       //-- start just before the last char so as to not add the item
    1:       //-- twice if it's a directory
    1:       PRUint16 namelen = strlen(item->name);
    1:       for (char* p = item->name + namelen - 2; p >= item->name; p--)
    1:       {
    1:         if ('/' != *p)
    1:           continue;
    1: 
    1:         // See whether we need to create any more implicit directories,
    1:         // because if we don't we can avoid a lot of work.
    1:         // We can even avoid (de)allocating space for a bogus dirname with
    1:         // a little trickery -- save the char at item->name[dirnamelen],
    1:         // set it to 0, compare the strings, and restore the saved
    1:         // char when done
    1:         const PRUint32 dirnamelen = p + 1 - item->name;
    1:         const char savedChar = item->name[dirnamelen];
    1:         item->name[dirnamelen] = 0;
    1: 
    1:         // Is the directory in the file table?
    1:         PRUint32 hash = HashName(item->name);
    1:         PRBool found = PR_FALSE;
    1:         for (nsZipItem* zi = mFiles[hash]; zi != NULL; zi = zi->next)
    1:         {
    1:           if (0 == strcmp(item->name, zi->name))
    1:           {
    1:             // we've already added this dir and all its parents
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:         }
    1: 
    1:         // restore the char immediately
    1:         item->name[dirnamelen] = savedChar;
    1: 
    1:         // if the directory was found, break out of the directory
    1:         // creation loop now that we know all implicit directories
    1:         // are there -- otherwise, start creating the zip item
    1:         if (found)
    1:           break;
    1: 
    1:         nsZipItem* diritem = CreateZipItem(dirnamelen);
    1:         if (!diritem)
    1:           return ZIP_ERR_MEMORY;
    1: 
    1:         memcpy(diritem->name, item->name, dirnamelen);
    1:         diritem->name[dirnamelen] = 0;
    1: 
    1:         diritem->isDirectory = PR_TRUE;
    1:         diritem->isSynthetic = PR_TRUE;
    1:         diritem->compression = STORED;
    1:         diritem->size = diritem->realsize = 0;
    1:         diritem->crc32 = 0;
    1:         diritem->mode = 0755;
    1: 
    1:         // Set an obviously wrong last-modified date/time, because
    1:         // finding something more accurate like the most recent
    1:         // last-modified date/time of the dir's contents is a lot
    1:         // of effort.  The date/time corresponds to 1980-01-01 00:00.
    1:         diritem->time = 0;
    1:         diritem->date = 1 + (1 << 5) + (0 << 9);
    1: 
    1:         // add diritem to the file table
    1:         diritem->next = mFiles[hash];
    1:         mFiles[hash] = diritem;
    1:       } /* end processing of dirs in item's name */
    1:     }
    1:   }
    1:   return ZIP_OK;
    1: }
    1: 
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::SeekToItem
    1: //---------------------------------------------
    1: nsresult  nsZipArchive::SeekToItem(nsZipItem* aItem, PRFileDesc* aFd)
    1: {
    1:   PR_ASSERT (aItem);
    1: 
    1:   //-- the first time an item is used we need to calculate its offset
    1:   if (!aItem->hasDataOffset)
    1:   {
    1:     //-- read local header to get variable length values and calculate
    1:     //-- the real data offset
    1:     //--
    1:     //-- NOTE: extralen is different in central header and local header
    1:     //--       for archives created using the Unix "zip" utility. To set
    1:     //--       the offset accurately we need the _local_ extralen.
    1:     if (!ZIP_Seek(aFd, aItem->headerOffset, PR_SEEK_SET))
    1:       return ZIP_ERR_CORRUPT;
    1: 
    1:     ZipLocal   Local;
    1:     if ((PR_Read(aFd, (char*)&Local, ZIPLOCAL_SIZE) != (READTYPE) ZIPLOCAL_SIZE) || 
    1:         (xtolong(Local.signature) != LOCALSIG))
    1:     {
    1:       //-- read error or local header not found
    1:       return ZIP_ERR_CORRUPT;
    1:     }
    1: 
    1:     aItem->dataOffset = aItem->headerOffset +
    1:                         ZIPLOCAL_SIZE +
    1:                         xtoint(Local.filename_len) +
    1:                         xtoint(Local.extrafield_len);
    1:     aItem->hasDataOffset = PR_TRUE;
    1:   }
    1: 
    1:   //-- move to start of file in archive
    1:   if (!ZIP_Seek(aFd, aItem->dataOffset, PR_SEEK_SET))
    1:     return  ZIP_ERR_CORRUPT;
    1: 
    1:   return ZIP_OK;
    1: }
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::CopyItemToDisk
    1: //---------------------------------------------
    1: nsresult
    1: nsZipArchive::CopyItemToDisk(PRUint32 itemSize, PRUint32 itemCrc, PRFileDesc* outFD)
    1: /*
    1:  * This function copies an archive item to disk, to the
    1:  * file specified by outFD. If outFD is zero, the extracted data is
    1:  * not written, only checked for CRC, so this is in effect same as 'Test'.
    1:  */
    1: {
    1:   PRUint32    chunk, pos, crc;
    1:   char buf[ZIP_BUFLEN];
    1: 
    1:   //-- initialize crc
    1:   crc = crc32(0L, Z_NULL, 0);
    1: 
    1:   //-- copy chunks until file is done
    1:   for (pos = 0; pos < itemSize; pos += chunk)
    1:   {
    1:     chunk = (itemSize - pos < ZIP_BUFLEN) ? (itemSize - pos) : ZIP_BUFLEN;
    1:     
    1:     if (PR_Read(mFd, buf, chunk) != (READTYPE)chunk)
    1:     {
    1:       //-- unexpected end of data in archive
    1:       return ZIP_ERR_CORRUPT;
    1:     }
    1: 
    1:     //-- incrementally update crc32
    1:     crc = crc32(crc, (const unsigned char*)buf, chunk);
    1: 
    1:     if (outFD && PR_Write(outFD, buf, chunk) < (READTYPE)chunk)
    1:     {
    1:       //-- Couldn't write all the data (disk full?)
    1:       return ZIP_ERR_DISK;
    1:     }
    1:   }
    1: 
    1:   //-- verify crc32
    1:   if (crc != itemCrc)
    1:       return ZIP_ERR_CORRUPT;
    1: 
    1:   return ZIP_OK;
    1: }
    1: 
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::InflateItem
    1: //---------------------------------------------
    1: nsresult nsZipArchive::InflateItem(const nsZipItem* aItem, PRFileDesc* outFD)
    1: /*
    1:  * This function inflates an archive item to disk, to the
    1:  * file specified by outFD. If outFD is zero, the extracted data is
    1:  * not written, only checked for CRC, so this is in effect same as 'Test'.
    1:  */
    1: {
    1:   PR_ASSERT(aItem);
    1: 
    1:   //-- allocate deflation buffers
    1:   Bytef inbuf[ZIP_BUFLEN];
    1:   Bytef outbuf[ZIP_BUFLEN];
    1: 
    1:   //-- set up the inflate
    1:   z_stream    zs;
    1:   nsresult status = gZlibInit(&zs);
    1:   if (status != ZIP_OK)
    1:     return ZIP_ERR_GENERAL;
    1: 
    1:   //-- inflate loop
    1:   zs.next_out = outbuf;
    1:   zs.avail_out = ZIP_BUFLEN;
    1: 
    1:   PRUint32  size = aItem->size;
    1:   PRUint32  outpos = 0;
    1:   PRUint32  crc = crc32(0L, Z_NULL, 0);
    1:   int       zerr = Z_OK;
    1:   while (zerr == Z_OK)
    1:   {
    1:     PRBool      bRead = PR_FALSE;
    1:     PRBool      bWrote= PR_FALSE;
    1: 
    1:     if (zs.avail_in == 0 && zs.total_in < size)
    1:     {
    1:       //-- no data to inflate yet still more in file:
    1:       //-- read another chunk of compressed data
    1:       PRUint32 chunk = (size-zs.total_in < ZIP_BUFLEN) ? size-zs.total_in : ZIP_BUFLEN;
    1: 
    1:       if (PR_Read(mFd, inbuf, chunk) != (READTYPE)chunk)
    1:       {
    1:         //-- unexpected end of data
    1:         status = ZIP_ERR_CORRUPT;
    1:         break;
    1:       }
    1: 
    1:       zs.next_in  = inbuf;
    1:       zs.avail_in = chunk;
    1:       bRead       = PR_TRUE;
    1:     }
    1: 
    1:     if (zs.avail_out == 0)
    1:     {
    1:       //-- write inflated buffer to disk and make space
    1:       if (outFD && PR_Write(outFD, outbuf, ZIP_BUFLEN) < ZIP_BUFLEN)
    1:       {
    1:         //-- Couldn't write all the data (disk full?)
    1:         status = ZIP_ERR_DISK;
    1:         break;
    1:       }
    1: 
    1:       outpos = zs.total_out;
    1:       zs.next_out  = outbuf;
    1:       zs.avail_out = ZIP_BUFLEN;
    1:       bWrote       = PR_TRUE;
    1:     }
    1: 
    1:     if(bRead || bWrote)
    1:     {
    1:       Bytef* old_next_out = zs.next_out;
    1: 
    1:       zerr = inflate(&zs, Z_PARTIAL_FLUSH);
    1: 
    1:       //-- incrementally update crc32
    1:       crc = crc32(crc, (const unsigned char*)old_next_out, zs.next_out - old_next_out);
    1:     }
    1:     else
    1:       zerr = Z_STREAM_END;
    1: 
    1: #if defined STANDALONE && defined XP_WIN
    1:     ProcessWindowsMessages();
    1: #endif
    1:   } // while
    1: 
    1:   //-- verify crc32
    1:   if ((status == ZIP_OK) && (crc != aItem->crc32))
    1:   {
    1:       status = ZIP_ERR_CORRUPT;
    1:       goto cleanup;
    1:   }
    1: 
    1:   //-- write last inflated bit to disk
    1:   if (zerr == Z_STREAM_END && outpos < zs.total_out)
    1:   {
    1:     PRUint32 chunk = zs.total_out - outpos;
    1:     if (outFD && PR_Write(outFD, outbuf, chunk) < (READTYPE)chunk)
    1:       status = ZIP_ERR_DISK;
    1:   }
    1: 
    1:   //-- convert zlib error to return value
    1:   if (status == ZIP_OK && zerr != Z_OK && zerr != Z_STREAM_END)
    1:   {
    1:     status = (zerr == Z_MEM_ERROR) ? ZIP_ERR_MEMORY : ZIP_ERR_CORRUPT;
    1:   }
    1: 
    1:   //-- if found no errors make sure we've converted the whole thing
    1:   PR_ASSERT(status != ZIP_OK || zs.total_in == aItem->size);
    1:   PR_ASSERT(status != ZIP_OK || zs.total_out == aItem->realsize);
    1: 
    1: cleanup:
    1:   //-- free zlib internal state
    1:   inflateEnd(&zs);
    1: 
    1:   return status;
    1: }
    1: 
    1: //------------------------------------------
    1: // nsZipArchive constructor and destructor
    1: //------------------------------------------
    1: 
    1: nsZipArchive::nsZipArchive() :
    1: #ifdef STANDALONE
    1:     kMagic(ZIP_MAGIC),
    1: #endif
    1:     mFd(0),
    1:     mBuiltSynthetics(PR_FALSE)
    1: {
    1:   MOZ_COUNT_CTOR(nsZipArchive);
    1: 
    1:   // initialize the table to NULL
    1:   memset(mFiles, 0, sizeof mFiles);
    1: }
    1: 
    1: nsZipArchive::~nsZipArchive()
    1: {
    1:   CloseArchive();
    1: 
    1:   MOZ_COUNT_DTOR(nsZipArchive);
    1: }
    1: 
    1: 
    1: //------------------------------------------
    1: // nsZipFind constructor and destructor
    1: //------------------------------------------
    1: 
    1: nsZipFind::nsZipFind(nsZipArchive* aZip, char* aPattern, PRBool aRegExp) : 
    1: #ifdef STANDALONE
    1:   kMagic(ZIPFIND_MAGIC),
    1: #endif
    1:   mArchive(aZip),
    1:   mPattern(aPattern),
    1:   mItem(0),
    1:   mSlot(0),
    1:   mRegExp(aRegExp)
    1: {
    1:   MOZ_COUNT_CTOR(nsZipFind);
    1: }
    1: 
    1: nsZipFind::~nsZipFind()
    1: {
    1:   PR_FREEIF(mPattern);
    1: 
    1:   MOZ_COUNT_DTOR(nsZipFind);
    1: }
    1: 
    1: //------------------------------------------
    1: // helper functions
    1: //------------------------------------------
    1: 
    1: /* 
    1:  * HashName 
    1:  *
    1:  * returns a hash key for the entry name 
    1:  */
    1: static PRUint32 HashName(const char* aName)
    1: {
    1:   PR_ASSERT(aName != 0);
    1: 
    1:   PRUint32 val = 0;
    1:   for (PRUint8* c = (PRUint8*)aName; *c != 0; c++) {
    1:     val = val*37 + *c;
    1:   }
    1: 
    1:   return (val % ZIP_TABSIZE);
    1: }
    1: 
    1: /*
    1:  *  x t o i n t
    1:  *
    1:  *  Converts a two byte ugly endianed integer
    1:  *  to our platform's integer.
    1:  */
    1: static PRUint16 xtoint (unsigned char *ii)
    1: {
    1:   return (PRUint16) ((ii [0]) | (ii [1] << 8));
    1: }
    1: 
    1: /*
    1:  *  x t o l o n g
    1:  *
    1:  *  Converts a four byte ugly endianed integer
    1:  *  to our platform's integer.
    1:  */
    1: static PRUint32 xtolong (unsigned char *ll)
    1: {
    1:   return (PRUint32)( (ll [0] <<  0) |
    1:                      (ll [1] <<  8) |
    1:                      (ll [2] << 16) |
    1:                      (ll [3] << 24) );
    1: }
    1: 
    1: /*
    1:  * ExtractMode
    1:  *
    1:  * Extracts bits 17-24 from a 32-bit unsigned long
    1:  * representation of the external attributes field.
    1:  * Subsequently it tacks on the implicit user-read
    1:  * bit.
    1:  */
    1: static PRUint16 ExtractMode(unsigned char *ll)
    1: {
    1:     return ((PRUint16)(ll[2])) | 0x0100;
    1: }
    1: 
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
    1: /*
    1:  *
    1:  *  Return true if the attributes are for a symbolic link
    1:  *
    1:  */
    1: 
    1: static PRBool IsSymlink(unsigned char *ll)
    1: {
    1:   return ((xtoint(ll+2) & S_IFMT) == S_IFLNK);
    1: }
    1: #endif
    1: 
