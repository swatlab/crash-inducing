30885: # ***** BEGIN LICENSE BLOCK *****
30885: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
30885: #
30885: # The contents of this file are subject to the Mozilla Public License Version
30885: # 1.1 (the "License"); you may not use this file except in compliance with
30885: # the License. You may obtain a copy of the License at
30885: # http://www.mozilla.org/MPL/
30885: #
30885: # Software distributed under the License is distributed on an "AS IS" basis,
30885: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
30885: # for the specific language governing rights and limitations under the
30885: # License.
30885: #
30885: # The Original Code is mozilla.org code.
30885: #
30885: # The Initial Developer of the Original Code is 
30885: # Makoto Kato <m_kato@ga2.so-net.ne.jp>.
30885: # Portions created by the Initial Developer are Copyright (C) 2004
30885: # the Initial Developer. All Rights Reserved.
30885: #
30885: # Contributor(s):
30885: #
30885: # Alternatively, the contents of this file may be used under the terms of
30885: # either the GNU General Public License Version 2 or later (the "GPL"), or
30885: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
30885: # in which case the provisions of the GPL or the LGPL are applicable instead
30885: # of those above. If you wish to allow use of your version of this file only
30885: # under the terms of either the GPL or the LGPL, and not to allow others to
30885: # use your version of this file under the terms of the MPL, indicate your
30885: # decision by deleting the provisions above and replace them with the notice
30885: # and other provisions required by the GPL or the LGPL. If you do not delete
30885: # the provisions above, a recipient may use your version of this file under
30885: # the terms of any one of the MPL, the GPL or the LGPL.
30885: #
30885: # ***** END LICENSE BLOCK *****
30885: 
59510: .extern invoke_copy_to_stack
30885: 
30885: 
30885: .text
59510: .intel_syntax noprefix
30885: 
30885: #
30885: #_XPTC__InvokebyIndex(nsISupports* that, PRUint32 methodIndex,
30885: #                    PRUint32 paramCount, nsXPTCVariant* params)
30885: #
30885: 
59510: .globl XPTC__InvokebyIndex
59510: .def XPTC__InvokebyIndex
30885:    .scl 3
30885:    .type 46
30885: .endef
59510: XPTC__InvokebyIndex:
30885: 
30885:    # store register parameters
30885: 
30885:     mov     qword ptr [rsp+32], r9        # params
30885:     mov     dword ptr [rsp+24], r8d       # paramCount
30885:     mov     dword ptr [rsp+16], edx       # methodIndex
30885:     mov     qword ptr [rsp+8], rcx        # that
30885: 
61630:     push    rbp
61630:     # .PUSHREG rbp
30885:     mov     rbp, rsp            # store current RSP to RBP
30885:     # .SETFRAME rbp, 0
30885:     # .ENDPROLOG
30885: 
30885:     sub     rsp, 32
30885: 
30885:     # maybe we don't have any parameters to copy
30885: 
30885:     test    r8d, r8d
30885:     jz      noparams
30885: 
30885:     #
61630:     # Build stack for stdcall
61630:     #
61630: 
61630:     # 1st parameter is space for parameters
30885: 
30885:     mov     eax, r8d
61630:     or      eax, 1
30885:     shl     rax, 3              # *= 8
30885:     sub     rsp, rax
30885:     mov     rcx, rsp
30885: 
30885:     # 2nd parameter is parameter count
30885: 
30885:     mov     edx, r8d
30885: 
30885:     # 3rd parameter is params
30885: 
30885:     mov     r8, r9
30885: 
61630:     sub     rsp, 40
59510:     call    invoke_copy_to_stack # rcx = d
30885:                                  # edx = paramCount
30885:                                  # r8  = s
30885:     add     rsp, 32
30885: 
61630:     # Current stack is the following.
30885:     #
61630:     #  0h: [space (for this)]
61630:     #  8h: [1st parameter]
61630:     # 10h: [2nd parameter]
61630:     # 18h: [3rd parameter]
61630:     # 20h: [4th parameter]
61630:     # ...
30885:     #
61630:     # On Win64 ABI, the first 4 parameters are passed using registers,
61630:     # and others are on stack. 
30885: 
61630:     # 1st, 2nd and 3rd arguments are passed via registers
30885: 
61630:     mov     rdx, qword ptr [rsp+8] # 1st parameter
61630:     movsd   xmm1, qword ptr [rsp+8] # for double
30885: 
61630:     mov     r8, qword ptr [rsp+16] # 2nd parameter
61630:     movsd   xmm2, qword ptr [rsp+16] # for double
30885: 
61630:     mov     r9, qword ptr [rsp+24] # 3rd parameter
61630:     movsd   xmm3, qword ptr [rsp+24] # for double
30885: 
61630:     # rcx register is this
61630: 
61630:     mov     rcx, qword ptr [rbp+8+8] # that
30885: 
30885: noparams:
30885: 
30885:     # calculate call address
30885: 
30885:     mov     r11, qword ptr [rcx]
61630:     mov     eax, dword ptr [rbp+16+8] # methodIndex
30885: 
30885:     call    qword ptr [r11+rax*8]      # stdcall, i.e. callee cleans up stack.
30885: 
30885:     mov     rsp, rbp
61630:     pop     rbp
30885: 
30885:     ret
30885: 
30885: 
