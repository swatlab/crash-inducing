42593: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
42593:  * ***** BEGIN LICENSE BLOCK *****
42593:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42593:  *
42593:  * The contents of this file are subject to the Mozilla Public License Version
42593:  * 1.1 (the "License"); you may not use this file except in compliance with
42593:  * the License. You may obtain a copy of the License at
42593:  * http://www.mozilla.org/MPL/
42593:  *
42593:  * Software distributed under the License is distributed on an "AS IS" basis,
42593:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42593:  * for the specific language governing rights and limitations under the
42593:  * License.
42593:  *
42593:  * The Original Code is Mozilla Corporation code.
42593:  *
42593:  * The Initial Developer of the Original Code is Mozilla Foundation.
42593:  * Portions created by the Initial Developer are Copyright (C) 2010
42593:  * the Initial Developer. All Rights Reserved.
42593:  *
42593:  * Contributor(s):
42593:  *   Robert O'Callahan <robert@ocallahan.org>
42593:  *
42593:  * Alternatively, the contents of this file may be used under the terms of
42593:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42593:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42593:  * in which case the provisions of the GPL or the LGPL are applicable instead
42593:  * of those above. If you wish to allow use of your version of this file only
42593:  * under the terms of either the GPL or the LGPL, and not to allow others to
42593:  * use your version of this file under the terms of the MPL, indicate your
42593:  * decision by deleting the provisions above and replace them with the notice
42593:  * and other provisions required by the GPL or the LGPL. If you do not delete
42593:  * the provisions above, a recipient may use your version of this file under
42593:  * the terms of any one of the MPL, the GPL or the LGPL.
42593:  *
42593:  * ***** END LICENSE BLOCK ***** */
42593: 
42593: #include "FrameLayerBuilder.h"
42593: 
42593: #include "nsDisplayList.h"
42593: #include "nsPresContext.h"
42593: #include "nsLayoutUtils.h"
47736: #include "Layers.h"
47751: #include "BasicLayers.h"
47736: 
47736: #ifdef DEBUG
47736: #include <stdio.h>
47736: #endif
42593: 
42593: using namespace mozilla::layers;
42593: 
42593: namespace mozilla {
42593: 
42593: namespace {
42593: 
42593: /**
47736:  * This is the userdata we associate with a layer manager.
42593:  */
47736: class LayerManagerData {
42593: public:
47736:   LayerManagerData() :
47736:     mInvalidateAllThebesContent(PR_FALSE),
47736:     mInvalidateAllLayers(PR_FALSE)
42593:   {
47736:     mFramesWithLayers.Init();
42593:   }
42593: 
47736:   /**
47736:    * Tracks which frames have layers associated with them.
47736:    */
47736:   nsTHashtable<nsPtrHashKey<nsIFrame> > mFramesWithLayers;
47736:   PRPackedBool mInvalidateAllThebesContent;
47736:   PRPackedBool mInvalidateAllLayers;
42593: };
42593: 
47736: static void DestroyRegion(void* aPropertyValue)
42593: {
47736:   delete static_cast<nsRegion*>(aPropertyValue);
42593: }
42593: 
47736: /**
47736:  * This property represents a region that should be invalidated in every
47736:  * ThebesLayer child whose parent ContainerLayer is associated with the
47736:  * frame. This is an nsRegion*; the coordinates of the region are
47736:  * relative to the top-left of the border-box of the frame the property
47736:  * is attached to (which is the frame for the ContainerLayer).
47736:  * 
47736:  * We add to this region in InvalidateThebesLayerContents. The region
47736:  * is propagated to ContainerState in BuildContainerLayerFor, and then
47736:  * the region(s) are actually invalidated in CreateOrRecycleThebesLayer.
47736:  */
47736: NS_DECLARE_FRAME_PROPERTY(ThebesLayerInvalidRegionProperty, DestroyRegion)
47736: 
47736: /**
47736:  * This is a helper object used to build up the layer children for
47736:  * a ContainerLayer.
47736:  */
47736: class ContainerState {
47736: public:
47736:   ContainerState(nsDisplayListBuilder* aBuilder,
47736:                  LayerManager* aManager,
47736:                  nsIFrame* aContainerFrame,
47736:                  ContainerLayer* aContainerLayer) :
47736:     mBuilder(aBuilder), mManager(aManager),
47736:     mContainerFrame(aContainerFrame), mContainerLayer(aContainerLayer),
47745:     mNextFreeRecycledThebesLayer(0), mNextFreeRecycledColorLayer(0),
47736:     mInvalidateAllThebesContent(PR_FALSE)
47736:   {
47745:     CollectOldLayers();
47736:   }
47736: 
47736:   void SetInvalidThebesContent(const nsIntRegion& aRegion)
47736:   {
47736:     mInvalidThebesContent = aRegion;
47736:   }
47736:   void SetInvalidateAllThebesContent()
47736:   {
47736:     mInvalidateAllThebesContent = PR_TRUE;
47736:   }
47736:   /**
47736:    * This is the method that actually walks a display list and builds
47736:    * the child layers. We invoke it recursively to process clipped sublists.
47736:    * @param aClipRect the clip rect to apply to the list items, or null
47736:    * if no clipping is required
47736:    */
47736:   void ProcessDisplayItems(const nsDisplayList& aList,
47736:                            const nsRect* aClipRect);
47736:   /**
47736:    * This finalizes all the open ThebesLayers by popping every element off
47736:    * mThebesLayerDataStack, then sets the children of the container layer
47736:    * to be all the layers in mNewChildLayers in that order and removes any
47736:    * layers as children of the container that aren't in mNewChildLayers.
47736:    */
47736:   void Finish();
47736: 
47736: protected:
47736:   /**
47736:    * We keep a stack of these to represent the ThebesLayers that are
47736:    * currently available to have display items added to.
47736:    * We use a stack here because as much as possible we want to
47736:    * assign display items to existing ThebesLayers, and to the lowest
47736:    * ThebesLayer in z-order. This reduces the number of layers and
47736:    * makes it more likely a display item will be rendered to an opaque
47736:    * layer, giving us the best chance of getting subpixel AA.
47736:    */
47736:   class ThebesLayerData {
47736:   public:
47745:     ThebesLayerData() :
47745:       mActiveScrolledRoot(nsnull), mLayer(nsnull),
47745:       mIsSolidColorInVisibleRegion(PR_FALSE) {}
47736:     /**
47736:      * Record that an item has been added to the ThebesLayer, so we
47736:      * need to update our regions.
47772:      * @param aVisibleRect the area of the item that's visible
48689:      * @param aDrawRect the area of the item that would be drawn if it
48689:      * was completely visible
47772:      * @param aOpaqueRect if non-null, the area of the item that's opaque.
47772:      * We pass in a separate opaque rect because the opaque rect can be
47772:      * bigger than the visible rect, and we want to have the biggest
47772:      * opaque rect that we can.
47772:      * @param aSolidColor if non-null, the visible area of the item is
47772:      * a constant color given by *aSolidColor
47736:      */
47772:     void Accumulate(const nsIntRect& aVisibleRect,
48689:                     const nsIntRect& aDrawRect,
47772:                     const nsIntRect* aOpaqueRect,
47745:                     nscolor* aSolidColor);
47736:     nsIFrame* GetActiveScrolledRoot() { return mActiveScrolledRoot; }
47736: 
47736:     /**
47736:      * The region of visible content in the layer, relative to the
47736:      * container layer (which is at the snapped top-left of the display
47736:      * list reference frame).
47736:      */
47736:     nsIntRegion  mVisibleRegion;
47736:     /**
47736:      * The region of visible content above the layer and below the
47736:      * next ThebesLayerData currently in the stack, if any. Note that not
47736:      * all ThebesLayers for the container are in the ThebesLayerData stack.
47736:      * Same coordinate system as mVisibleRegion.
47736:      */
47736:     nsIntRegion  mVisibleAboveRegion;
47736:     /**
48689:      * The region containing the bounds of all display items in the layer,
48689:      * regardless of visbility.
48689:      * Same coordinate system as mVisibleRegion.
48689:      */
48689:     nsIntRegion  mDrawRegion;
48689:     /**
48689:      * The region containing the bounds of all display items (regardless
48689:      * of visibility) in the layer and below the next ThebesLayerData
48689:      * currently in the stack, if any.
48689:      * Note that not all ThebesLayers for the container are in the
48689:      * ThebesLayerData stack.
48689:      * Same coordinate system as mVisibleRegion.
48689:      */
48689:     nsIntRegion  mDrawAboveRegion;
48689:     /**
47736:      * The region of visible content in the layer that is opaque.
47736:      * Same coordinate system as mVisibleRegion.
47736:      */
47736:     nsIntRegion  mOpaqueRegion;
47736:     /**
47736:      * The "active scrolled root" for all content in the layer. Must
47736:      * be non-null; all content in a ThebesLayer must have the same
47736:      * active scrolled root.
47736:      */
47736:     nsIFrame*    mActiveScrolledRoot;
47736:     ThebesLayer* mLayer;
47745:     /**
47745:      * If mIsSolidColorInVisibleRegion is true, this is the color of the visible
47745:      * region.
47745:      */
47745:     nscolor      mSolidColor;
47745:     /**
47745:      * True if every pixel in mVisibleRegion will have color mSolidColor.
47745:      */
47745:     PRPackedBool mIsSolidColorInVisibleRegion;
42593:   };
42593: 
42593:   /**
47736:    * Grab the next recyclable ThebesLayer, or create one if there are no
47736:    * more recyclable ThebesLayers. Does any necessary invalidation of
47736:    * a recycled ThebesLayer, and sets up the transform on the ThebesLayer
47745:    * to account for scrolling.
42593:    */
47736:   already_AddRefed<ThebesLayer> CreateOrRecycleThebesLayer(nsIFrame* aActiveScrolledRoot);
47736:   /**
47745:    * Grab the next recyclable ColorLayer, or create one if there are no
47745:    * more recyclable ColorLayers.
47745:    */
47745:   already_AddRefed<ColorLayer> CreateOrRecycleColorLayer();
47745:   /**
47745:    * Grabs all ThebesLayers and ColorLayers from the ContainerLayer and makes them
47736:    * available for recycling.
47736:    */
47745:   void CollectOldLayers();
47736:   /**
47751:    * If aItem used to belong to a ThebesLayer, invalidates the area of
47751:    * aItem in that layer. If aNewLayer is a ThebesLayer, invalidates the area of
47751:    * aItem in that layer.
47751:    */
47751:   void InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer);
47751:   /**
47736:    * Indicate that we are done adding items to the ThebesLayer at the top of
47736:    * mThebesLayerDataStack. Set the final visible region and opaque-content
47736:    * flag, and pop it off the stack.
47736:    */
47736:   void PopThebesLayerData();
47736:   /**
47736:    * Find the ThebesLayer to which we should assign the next display item.
48689:    * We scan the ThebesLayerData stack to find the topmost ThebesLayer
48689:    * that is compatible with the display item (i.e., has the same
48689:    * active scrolled root), and that has no content from other layers above
48689:    * it and intersecting the aVisibleRect.
47736:    * Returns the layer, and also updates the ThebesLayerData. Will
48689:    * push a new ThebesLayerData onto the stack if no suitable existing
48689:    * layer is found. If we choose a ThebesLayer that's already on the
48689:    * ThebesLayerData stack, later elements on the stack will be popped off.
47736:    * @param aVisibleRect the area of the next display item that's visible
47736:    * @param aActiveScrolledRoot the active scrolled root for the next
47736:    * display item
47772:    * @param aOpaqueRect if non-null, a region of the display item that is opaque
47745:    * @param aSolidColor if non-null, indicates that every pixel in aVisibleRect
47745:    * will be painted with aSolidColor by the item
47736:    */
47736:   already_AddRefed<ThebesLayer> FindThebesLayerFor(const nsIntRect& aVisibleRect,
48689:                                                    const nsIntRect& aDrawRect,
47736:                                                    nsIFrame* aActiveScrolledRoot,
47772:                                                    const nsIntRect* aOpaqueRect,
47745:                                                    nscolor* aSolidColor);
47736:   ThebesLayerData* GetTopThebesLayerData()
47736:   {
47736:     return mThebesLayerDataStack.IsEmpty() ? nsnull
47736:         : mThebesLayerDataStack[mThebesLayerDataStack.Length() - 1].get();
47736:   }
42593: 
47736:   nsDisplayListBuilder*            mBuilder;
47736:   LayerManager*                    mManager;
47736:   nsIFrame*                        mContainerFrame;
47736:   ContainerLayer*                  mContainerLayer;
47736:   /**
47736:    * The region of ThebesLayers that should be invalidated every time
47736:    * we recycle one.
47736:    */
47736:   nsIntRegion                      mInvalidThebesContent;
47736:   nsAutoTArray<nsAutoPtr<ThebesLayerData>,1>  mThebesLayerDataStack;
47736:   /**
47736:    * We collect the list of children in here. During ProcessDisplayItems,
47736:    * the layers in this array either have mContainerLayer as their parent,
47736:    * or no parent.
47736:    */
47736:   nsAutoTArray<nsRefPtr<Layer>,1>  mNewChildLayers;
47736:   nsTArray<nsRefPtr<ThebesLayer> > mRecycledThebesLayers;
47745:   nsTArray<nsRefPtr<ColorLayer> >  mRecycledColorLayers;
47736:   PRUint32                         mNextFreeRecycledThebesLayer;
47745:   PRUint32                         mNextFreeRecycledColorLayer;
47736:   PRPackedBool                     mInvalidateAllThebesContent;
42593: };
42593: 
42593: /**
47736:  * The address of gThebesDisplayItemLayerUserData is used as the user
47736:  * data pointer for ThebesLayers created by FrameLayerBuilder.
47736:  * It identifies ThebesLayers used to draw non-layer content, which are
47736:  * therefore eligible for recycling. We want display items to be able to
47736:  * create their own dedicated ThebesLayers in BuildLayer, if necessary,
47736:  * and we wouldn't want to accidentally recycle those.
42593:  */
47736: static PRUint8 gThebesDisplayItemLayerUserData;
47745: /**
47745:  * The address of gColorLayerUserData is used as the user
47745:  * data pointer for ColorLayers
47745:  */
47745: static PRUint8 gColorLayerUserData;
42593: 
47736: } // anonymous namespace
47736: 
47736: PRBool
47736: FrameLayerBuilder::DisplayItemDataEntry::HasContainerLayer()
42593: {
47736:   for (PRUint32 i = 0; i < mData.Length(); ++i) {
47736:     if (mData[i].mLayer->GetType() == Layer::TYPE_CONTAINER)
47736:       return PR_TRUE;
47736:   }
47736:   return PR_FALSE;
42593: }
42593: 
47736: /* static */ void
47736: FrameLayerBuilder::InternalDestroyDisplayItemData(nsIFrame* aFrame,
47736:                                                   void* aPropertyValue,
47736:                                                   PRBool aRemoveFromFramesWithLayers)
47736: {
47736:   nsRefPtr<LayerManager> managerRef;
47736:   nsTArray<DisplayItemData>* array =
47736:     reinterpret_cast<nsTArray<DisplayItemData>*>(&aPropertyValue);
47736:   NS_ASSERTION(!array->IsEmpty(), "Empty arrays should not be stored");
47736: 
47736:   if (aRemoveFromFramesWithLayers) {
47736:     LayerManager* manager = array->ElementAt(0).mLayer->Manager();
47736:     LayerManagerData* data = static_cast<LayerManagerData*>
47736:       (manager->GetUserData());
47736:     NS_ASSERTION(data, "Frame with layer should have been recorded");
47736:     data->mFramesWithLayers.RemoveEntry(aFrame);
47736:     if (data->mFramesWithLayers.Count() == 0) {
47736:       delete data;
47736:       manager->SetUserData(nsnull);
47736:       // Consume the reference we added when we set the user data
47736:       // in DidEndTransaction. But don't actually release until we've
47736:       // released all the layers in the DisplayItemData array below!
47736:       managerRef = manager;
47736:       NS_RELEASE(manager);
42593:     }
42593:   }
42593: 
47736:   array->~nsTArray<DisplayItemData>();
42593: }
42593: 
47736: /* static */ void
47736: FrameLayerBuilder::DestroyDisplayItemData(nsIFrame* aFrame,
47736:                                           void* aPropertyValue)
47736: {
47736:   InternalDestroyDisplayItemData(aFrame, aPropertyValue, PR_TRUE);
47736: }
47736: 
47736: void
47771: FrameLayerBuilder::WillBeginRetainedLayerTransaction(LayerManager* aManager)
47736: {
47736:   mRetainingManager = aManager;
47736:   LayerManagerData* data = static_cast<LayerManagerData*>
47736:     (aManager->GetUserData());
47736:   if (data) {
47736:     mInvalidateAllThebesContent = data->mInvalidateAllThebesContent;
47736:     mInvalidateAllLayers = data->mInvalidateAllLayers;
47736:   }
42593: }
42593: 
42593: /**
47736:  * A helper function to remove the mThebesLayerItems entries for every
47736:  * layer in aLayer's subtree.
42593:  */
47736: void
47736: FrameLayerBuilder::RemoveThebesItemsForLayerSubtree(Layer* aLayer)
42593: {
47736:   ThebesLayer* thebes = aLayer->AsThebesLayer();
47736:   if (thebes) {
47736:     mThebesLayerItems.RemoveEntry(thebes);
47736:     return;
42593:   }
42593: 
47736:   for (Layer* child = aLayer->GetFirstChild(); child;
47736:        child = child->GetNextSibling()) {
47736:     RemoveThebesItemsForLayerSubtree(child);
47736:   }
47736: }
47736: 
47736: void
47736: FrameLayerBuilder::DidEndTransaction(LayerManager* aManager)
42593: {
47736:   if (aManager != mRetainingManager) {
47736:     Layer* root = aManager->GetRoot();
47736:     if (root) {
47736:       RemoveThebesItemsForLayerSubtree(root);
42593:     }
47771:   }
42593: }
47736: 
47771: void
47771: FrameLayerBuilder::WillEndTransaction(LayerManager* aManager)
47771: {
47771:   if (aManager != mRetainingManager)
47771:     return;
47771: 
47771:   // We need to save the data we'll need to support retaining. We do this
47771:   // before we paint so that invalidation triggered by painting will
47771:   // be able to update the ThebesLayerInvalidRegionProperty values
47771:   // correctly and the NS_FRAME_HAS_CONTAINER_LAYER bits will be set
47771:   // correctly.
47736:   LayerManagerData* data = static_cast<LayerManagerData*>
47736:     (mRetainingManager->GetUserData());
47736:   if (data) {
47736:     // Update all the frames that used to have layers.
47736:     data->mFramesWithLayers.EnumerateEntries(UpdateDisplayItemDataForFrame, this);
47736:   } else {
47736:     data = new LayerManagerData();
47736:     mRetainingManager->SetUserData(data);
47736:     // Addref mRetainingManager. We'll release it when 'data' is
47736:     // removed.
47736:     NS_ADDREF(mRetainingManager);
47736:   }
47736:   // Now go through all the frames that didn't have any retained
47736:   // display items before, and record those retained display items.
47736:   // This also empties mNewDisplayItemData.
47736:   mNewDisplayItemData.EnumerateEntries(StoreNewDisplayItemData, data);
47736:   data->mInvalidateAllThebesContent = PR_FALSE;
47736:   data->mInvalidateAllLayers = PR_FALSE;
47736: 
47736:   NS_ASSERTION(data->mFramesWithLayers.Count() > 0,
47736:                "Some frame must have a layer!");
47736: }
47736: 
47736: /* static */ PLDHashOperator
47736: FrameLayerBuilder::UpdateDisplayItemDataForFrame(nsPtrHashKey<nsIFrame>* aEntry,
47736:                                                  void* aUserArg)
47736: {
47736:   FrameLayerBuilder* builder = static_cast<FrameLayerBuilder*>(aUserArg);
47736:   nsIFrame* f = aEntry->GetKey();
47736:   FrameProperties props = f->Properties();
47736:   DisplayItemDataEntry* newDisplayItems =
47736:     builder->mNewDisplayItemData.GetEntry(f);
47736:   if (!newDisplayItems) {
47736:     // This frame was visible, but isn't anymore.
47736:     PRBool found;
47736:     void* prop = props.Remove(DisplayItemDataProperty(), &found);
47736:     NS_ASSERTION(found, "How can the frame property be missing?");
47736:     // Pass PR_FALSE to not remove from mFramesWithLayers, we'll remove it
47736:     // by returning PL_DHASH_REMOVE below.
47736:     // Note that DestroyDisplayItemData would delete the user data
47736:     // for the retained layer manager if it removed the last entry from
47736:     // mFramesWithLayers, but we won't. That's OK because our caller
47736:     // is DidEndTransaction, which would recreate the user data
47736:     // anyway.
47736:     InternalDestroyDisplayItemData(f, prop, PR_FALSE);
47736:     props.Delete(ThebesLayerInvalidRegionProperty());
47736:     f->RemoveStateBits(NS_FRAME_HAS_CONTAINER_LAYER);
47736:     return PL_DHASH_REMOVE;
47736:   }
47736: 
47736:   if (!newDisplayItems->HasContainerLayer()) {
47736:     props.Delete(ThebesLayerInvalidRegionProperty());
47736:     f->RemoveStateBits(NS_FRAME_HAS_CONTAINER_LAYER);
47736:   } else {
47736:     NS_ASSERTION(f->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER,
47736:                  "This bit should have been set by BuildContainerLayerFor");
47736:   }
47736: 
47736:   // Reset the invalid region now so we can start collecting new dirty
47736:   // areas.
47736:   nsRegion* invalidRegion = static_cast<nsRegion*>
47736:     (props.Get(ThebesLayerInvalidRegionProperty()));
47736:   if (invalidRegion) {
47736:     invalidRegion->SetEmpty();
47736:   }
47736: 
47736:   // We need to remove and re-add the DisplayItemDataProperty in
47736:   // case the nsTArray changes the value of its mHdr.
47736:   void* propValue = props.Remove(DisplayItemDataProperty());
47736:   NS_ASSERTION(propValue, "mFramesWithLayers out of sync");
47736:   PR_STATIC_ASSERT(sizeof(nsTArray<DisplayItemData>) == sizeof(void*));
47736:   nsTArray<DisplayItemData>* array =
47736:     reinterpret_cast<nsTArray<DisplayItemData>*>(&propValue);
47736:   // Steal the list of display item layers
47736:   array->SwapElements(newDisplayItems->mData);
47736:   props.Set(DisplayItemDataProperty(), propValue);
47736:   // Don't need to process this frame again
47736:   builder->mNewDisplayItemData.RawRemoveEntry(newDisplayItems);
47736:   return PL_DHASH_NEXT;
47736: }
47736: 
47736: /* static */ PLDHashOperator
47736: FrameLayerBuilder::StoreNewDisplayItemData(DisplayItemDataEntry* aEntry,
47736:                                            void* aUserArg)
47736: {
47736:   LayerManagerData* data = static_cast<LayerManagerData*>(aUserArg);
47736:   nsIFrame* f = aEntry->GetKey();
47736:   // Remember that this frame has display items in retained layers
47736:   NS_ASSERTION(!data->mFramesWithLayers.GetEntry(f),
47736:                "We shouldn't get here if we're already in mFramesWithLayers");
47736:   data->mFramesWithLayers.PutEntry(f);
47736:   NS_ASSERTION(!f->Properties().Get(DisplayItemDataProperty()),
47736:                "mFramesWithLayers out of sync");
47736: 
47736:   void* propValue;
47736:   nsTArray<DisplayItemData>* array =
47736:     new (&propValue) nsTArray<DisplayItemData>();
47736:   // Steal the list of display item layers
47736:   array->SwapElements(aEntry->mData);
47736:   // Save it
47736:   f->Properties().Set(DisplayItemDataProperty(), propValue);
47736: 
47736:   return PL_DHASH_REMOVE;
47736: }
47736: 
47736: Layer*
47736: FrameLayerBuilder::GetOldLayerFor(nsIFrame* aFrame, PRUint32 aDisplayItemKey)
47736: {
47736:   // If we need to build a new layer tree, then just refuse to recycle
47736:   // anything.
47736:   if (!mRetainingManager || mInvalidateAllLayers)
47736:     return nsnull;
47736: 
47736:   void* propValue = aFrame->Properties().Get(DisplayItemDataProperty());
47736:   if (!propValue)
47736:     return nsnull;
47736: 
47736:   nsTArray<DisplayItemData>* array =
47736:     (reinterpret_cast<nsTArray<DisplayItemData>*>(&propValue));
47736:   for (PRUint32 i = 0; i < array->Length(); ++i) {
47736:     if (array->ElementAt(i).mDisplayItemKey == aDisplayItemKey) {
47736:       Layer* layer = array->ElementAt(i).mLayer;
47736:       if (layer->Manager() == mRetainingManager)
47736:         return layer;
47736:     }
47736:   }
47736:   return nsnull;
42593: }
42593: 
42593: /**
47736:  * Invalidate aRegion in aLayer. aLayer is in the coordinate system
47736:  * *after* aLayer's transform has been applied, so we need to
47736:  * apply the inverse of that transform before calling InvalidateRegion.
47736:  * Currently we assume that the transform is just an integer translation,
47736:  * since that's all we need for scrolling.
42593:  */
47736: static void
47736: InvalidatePostTransformRegion(ThebesLayer* aLayer, const nsIntRegion& aRegion)
42593: {
47736:   gfxMatrix transform;
47736:   if (aLayer->GetTransform().Is2D(&transform)) {
47736:     NS_ASSERTION(!transform.HasNonIntegerTranslation(),
47736:                  "Matrix not just an integer translation?");
47736:     // Convert the region from the coordinates of the container layer
47736:     // (relative to the snapped top-left of the display list reference frame)
47736:     // to the ThebesLayer's own coordinates
47736:     nsIntRegion rgn = aRegion;
47736:     rgn.MoveBy(-nsIntPoint(PRInt32(transform.x0), PRInt32(transform.y0)));
47736:     aLayer->InvalidateRegion(rgn);
42593:   } else {
47736:     NS_ERROR("Only 2D transformations currently supported");
42593:   }
42593: }
42593: 
47745: already_AddRefed<ColorLayer>
47745: ContainerState::CreateOrRecycleColorLayer()
47745: {
47745:   nsRefPtr<ColorLayer> layer;
47745:   if (mNextFreeRecycledColorLayer < mRecycledColorLayers.Length()) {
47745:     // Recycle a layer
47745:     layer = mRecycledColorLayers[mNextFreeRecycledColorLayer];
47745:     ++mNextFreeRecycledColorLayer;
47745:     // Clear clip rect so we don't accidentally stay clipped. We will
47745:     // reapply any necessary clipping.
47745:     layer->SetClipRect(nsnull);
47745:   } else {
47745:     // Create a new layer
47745:     layer = mManager->CreateColorLayer();
47745:     if (!layer)
47745:       return nsnull;
47745:     // Mark this layer as being used for Thebes-painting display items
47745:     layer->SetUserData(&gColorLayerUserData);
47745:   }
47745:   return layer.forget();
47745: }
47745: 
47736: already_AddRefed<ThebesLayer>
47736: ContainerState::CreateOrRecycleThebesLayer(nsIFrame* aActiveScrolledRoot)
47736: {
47736:   // We need a new thebes layer
47736:   nsRefPtr<ThebesLayer> layer;
47745:   if (mNextFreeRecycledThebesLayer < mRecycledThebesLayers.Length()) {
47736:     // Recycle a layer
47736:     layer = mRecycledThebesLayers[mNextFreeRecycledThebesLayer];
47736:     ++mNextFreeRecycledThebesLayer;
47745:     // Clear clip rect so we don't accidentally stay clipped. We will
47745:     // reapply any necessary clipping.
47745:     layer->SetClipRect(nsnull);
47736: 
47736:     // This gets called on recycled ThebesLayers that are going to be in the
47736:     // final layer tree, so it's a convenient time to invalidate the
47736:     // content that changed where we don't know what ThebesLayer it belonged
47736:     // to, or if we need to invalidate the entire layer, we can do that.
47736:     // This needs to be done before we update the ThebesLayer to its new
47736:     // transform. See nsGfxScrollFrame::InvalidateInternal, where
47736:     // we ensure that mInvalidThebesContent is updated according to the
47736:     // scroll position as of the most recent paint.
47736:     if (mInvalidateAllThebesContent) {
47736:       nsIntRect invalidate = layer->GetValidRegion().GetBounds();
47736:       layer->InvalidateRegion(invalidate);
47736:     } else {
47736:       InvalidatePostTransformRegion(layer, mInvalidThebesContent);
42593:     }
47736:     // We do not need to Invalidate these areas in the widget because we
47736:     // assume the caller of InvalidateThebesLayerContents or
47736:     // InvalidateAllThebesLayerContents has ensured
47736:     // the area is invalidated in the widget.
47736:   } else {
47736:     // Create a new thebes layer
47736:     layer = mManager->CreateThebesLayer();
47736:     if (!layer)
47736:       return nsnull;
47736:     // Mark this layer as being used for Thebes-painting display items
47736:     layer->SetUserData(&gThebesDisplayItemLayerUserData);
42593:   }
42593: 
47736:   // Set up transform so that 0,0 in the Thebes layer corresponds to the
47736:   // (pixel-snapped) top-left of the aActiveScrolledRoot.
47736:   nsPoint offset = mBuilder->ToReferenceFrame(aActiveScrolledRoot);
47736:   nsIntPoint pixOffset = offset.ToNearestPixels(
47736:       aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel());
47736:   gfxMatrix matrix;
47736:   matrix.Translate(gfxPoint(pixOffset.x, pixOffset.y));
47736:   layer->SetTransform(gfx3DMatrix::From2D(matrix));
47736: 
47736:   return layer.forget();
42593: }
42593: 
47736: /**
47736:  * Returns the appunits per dev pixel for the item's frame. The item must
47736:  * have a frame because only nsDisplayClip items don't have a frame,
47736:  * and those items are flattened away by ProcessDisplayItems.
47736:  */
47736: static PRUint32
47736: AppUnitsPerDevPixel(nsDisplayItem* aItem)
47736: {
47736:   return aItem->GetUnderlyingFrame()->PresContext()->AppUnitsPerDevPixel();
42593: }
42593: 
47736: /**
47736:  * Set the visible rect of aLayer. aLayer is in the coordinate system
47736:  * *after* aLayer's transform has been applied, so we need to
47736:  * apply the inverse of that transform before calling SetVisibleRegion.
47736:  */
47736: static void
47736: SetVisibleRectForLayer(Layer* aLayer, const nsIntRect& aRect)
47736: {
42593:   gfxMatrix transform;
47736:   if (aLayer->GetTransform().Is2D(&transform)) {
42593:     // if 'transform' is not invertible, then nothing will be displayed
42593:     // for the layer, so it doesn't really matter what we do here
42593:     transform.Invert();
42593:     gfxRect layerVisible = transform.TransformBounds(
47736:         gfxRect(aRect.x, aRect.y, aRect.width, aRect.height));
42593:     layerVisible.RoundOut();
47736:     nsIntRect visibleRect;
42593:     if (NS_FAILED(nsLayoutUtils::GfxRectToIntRect(layerVisible, &visibleRect))) {
48693:       visibleRect = nsIntRect(0, 0, 0, 0);
48693:       NS_WARNING("Visible rect transformed out of bounds");
42593:     }
47736:     aLayer->SetVisibleRegion(visibleRect);
42593:   } else {
42593:     NS_ERROR("Only 2D transformations currently supported");
42593:   }
42593: }
42593: 
47736: void
47736: ContainerState::PopThebesLayerData()
47736: {
47736:   NS_ASSERTION(!mThebesLayerDataStack.IsEmpty(), "Can't pop");
47736: 
47736:   PRInt32 lastIndex = mThebesLayerDataStack.Length() - 1;
47736:   ThebesLayerData* data = mThebesLayerDataStack[lastIndex];
47736: 
47736:   if (lastIndex > 0) {
47736:     // Since we're going to pop off the last ThebesLayerData, the
47736:     // mVisibleAboveRegion of the second-to-last item will need to include
47736:     // the regions of the last item.
47736:     ThebesLayerData* nextData = mThebesLayerDataStack[lastIndex - 1];
47736:     nextData->mVisibleAboveRegion.Or(nextData->mVisibleAboveRegion,
47736:                                      data->mVisibleAboveRegion);
47736:     nextData->mVisibleAboveRegion.Or(nextData->mVisibleAboveRegion,
47736:                                      data->mVisibleRegion);
48689:     nextData->mDrawAboveRegion.Or(nextData->mDrawAboveRegion,
48689:                                      data->mDrawAboveRegion);
48689:     nextData->mDrawAboveRegion.Or(nextData->mDrawAboveRegion,
48689:                                      data->mDrawRegion);
47736:   }
47736: 
47745:   Layer* layer;
47745:   if (data->mIsSolidColorInVisibleRegion) {
47745:     nsRefPtr<ColorLayer> colorLayer = CreateOrRecycleColorLayer();
47745:     colorLayer->SetColor(data->mSolidColor);
47745: 
47745:     NS_ASSERTION(!mNewChildLayers.Contains(colorLayer), "Layer already in list???");
47745:     nsTArray_base::index_type index = mNewChildLayers.IndexOf(data->mLayer);
47745:     NS_ASSERTION(index != nsTArray_base::NoIndex, "Thebes layer not found?");
47745:     mNewChildLayers.InsertElementAt(index + 1, colorLayer);
47745: 
47745:     // Copy transform and clip rect
47745:     colorLayer->SetTransform(data->mLayer->GetTransform());
47745:     // Clip colorLayer to its visible region, since ColorLayers are
47745:     // allowed to paint outside the visible region. Here we rely on the
47745:     // fact that uniform display items fill rectangles; obviously the
47745:     // area to fill must contain the visible region, and because it's
47745:     // a rectangle, it must therefore contain the visible region's GetBounds.
47745:     // Note that the visible region is already clipped appropriately.
47745:     nsIntRect visibleRect = data->mVisibleRegion.GetBounds();
47745:     colorLayer->SetClipRect(&visibleRect);
47745: 
47745:     // Hide the ThebesLayer. We leave it in the layer tree so that we
47745:     // can find and recycle it later.
47745:     data->mLayer->IntersectClipRect(nsIntRect());
47745:     data->mLayer->SetVisibleRegion(nsIntRegion());
47745: 
47745:     layer = colorLayer;
47745:   } else {
47745:     layer = data->mLayer;
47745:   }
47745: 
47736:   gfxMatrix transform;
47745:   if (layer->GetTransform().Is2D(&transform)) {
47736:     NS_ASSERTION(!transform.HasNonIntegerTranslation(),
47736:                  "Matrix not just an integer translation?");
47736:     // Convert from relative to the container to relative to the
47736:     // ThebesLayer itself.
47736:     nsIntRegion rgn = data->mVisibleRegion;
47736:     rgn.MoveBy(-nsIntPoint(PRInt32(transform.x0), PRInt32(transform.y0)));
47745:     layer->SetVisibleRegion(rgn);
47736:   } else {
47736:     NS_ERROR("Only 2D transformations currently supported");
47736:   }
47736: 
47736:   nsIntRegion transparentRegion;
47736:   transparentRegion.Sub(data->mVisibleRegion, data->mOpaqueRegion);
47745:   layer->SetIsOpaqueContent(transparentRegion.IsEmpty());
47736: 
47736:   mThebesLayerDataStack.RemoveElementAt(lastIndex);
47736: }
47736: 
47736: void
48689: ContainerState::ThebesLayerData::Accumulate(const nsIntRect& aVisibleRect,
48689:                                             const nsIntRect& aDrawRect,
47772:                                             const nsIntRect* aOpaqueRect,
47745:                                             nscolor* aSolidColor)
47736: {
47745:   if (aSolidColor) {
47745:     if (mVisibleRegion.IsEmpty()) {
47745:       // This color is all we have
47745:       mSolidColor = *aSolidColor;
47745:       mIsSolidColorInVisibleRegion = PR_TRUE;
47745:     } else if (mIsSolidColorInVisibleRegion &&
48689:                mVisibleRegion.IsEqual(nsIntRegion(aVisibleRect))) {
47745:       // we can just blend the colors together
47745:       mSolidColor = NS_ComposeColors(mSolidColor, *aSolidColor);
47745:     } else {
47745:       mIsSolidColorInVisibleRegion = PR_FALSE;
47745:     }
47745:   } else {
47745:     mIsSolidColorInVisibleRegion = PR_FALSE;
47745:   }
47745: 
48689:   mVisibleRegion.Or(mVisibleRegion, aVisibleRect);
47736:   mVisibleRegion.SimplifyOutward(4);
48689:   mDrawRegion.Or(mDrawRegion, aDrawRect);
48689:   mDrawRegion.SimplifyOutward(4);
47772:   if (aOpaqueRect) {
47772:     // We don't use SimplifyInward here since it's not defined exactly
47772:     // what it will discard. For our purposes the most important case
47772:     // is a large opaque background at the bottom of z-order (e.g.,
47772:     // a canvas background), so we need to make sure that the first rect
47772:     // we see doesn't get discarded.
47772:     nsIntRegion tmp;
47772:     tmp.Or(mOpaqueRegion, *aOpaqueRect);
47772:     if (tmp.GetNumRects() <= 4) {
47772:       mOpaqueRegion = tmp;
47772:     }
47736:   }
47736: }
47736: 
47736: already_AddRefed<ThebesLayer>
47736: ContainerState::FindThebesLayerFor(const nsIntRect& aVisibleRect,
48689:                                    const nsIntRect& aDrawRect,
47736:                                    nsIFrame* aActiveScrolledRoot,
47772:                                    const nsIntRect* aOpaqueRect,
47745:                                    nscolor* aSolidColor)
47736: {
47736:   PRInt32 i;
47736:   PRInt32 lowestUsableLayerWithScrolledRoot = -1;
47736:   PRInt32 topmostLayerWithScrolledRoot = -1;
47736:   for (i = mThebesLayerDataStack.Length() - 1; i >= 0; --i) {
47736:     ThebesLayerData* data = mThebesLayerDataStack[i];
48689:     if (data->mDrawAboveRegion.Intersects(aVisibleRect)) {
47736:       ++i;
47736:       break;
47736:     }
47736:     if (data->mActiveScrolledRoot == aActiveScrolledRoot) {
47736:       lowestUsableLayerWithScrolledRoot = i;
47736:       if (topmostLayerWithScrolledRoot < 0) {
47736:         topmostLayerWithScrolledRoot = i;
47736:       }
47736:     }
48689:     if (data->mDrawRegion.Intersects(aVisibleRect))
47736:       break;
47736:   }
47736:   if (topmostLayerWithScrolledRoot < 0) {
47736:     --i;
47736:     for (; i >= 0; --i) {
47736:       ThebesLayerData* data = mThebesLayerDataStack[i];
47736:       if (data->mActiveScrolledRoot == aActiveScrolledRoot) {
47736:         topmostLayerWithScrolledRoot = i;
47736:         break;
47736:       }
47736:     }
47736:   }
47736: 
47736:   if (topmostLayerWithScrolledRoot >= 0) {
47736:     while (PRUint32(topmostLayerWithScrolledRoot + 1) < mThebesLayerDataStack.Length()) {
47736:       PopThebesLayerData();
47736:     }
47736:   }
47736: 
47736:   nsRefPtr<ThebesLayer> layer;
47736:   ThebesLayerData* thebesLayerData = nsnull;
47736:   if (lowestUsableLayerWithScrolledRoot < 0) {
47736:     layer = CreateOrRecycleThebesLayer(aActiveScrolledRoot);
47745: 
47745:     NS_ASSERTION(!mNewChildLayers.Contains(layer), "Layer already in list???");
47745:     mNewChildLayers.AppendElement(layer);
47745: 
47736:     thebesLayerData = new ThebesLayerData();
47736:     mThebesLayerDataStack.AppendElement(thebesLayerData);
47736:     thebesLayerData->mLayer = layer;
47736:     thebesLayerData->mActiveScrolledRoot = aActiveScrolledRoot;
47736:   } else {
47736:     thebesLayerData = mThebesLayerDataStack[lowestUsableLayerWithScrolledRoot];
47736:     layer = thebesLayerData->mLayer;
47736:   }
47736: 
48689:   thebesLayerData->Accumulate(aVisibleRect, aDrawRect, aOpaqueRect, aSolidColor);
47736:   return layer.forget();
47736: }
47736: 
48765: static already_AddRefed<BasicLayerManager>
48765: BuildTempManagerForInactiveLayer(nsDisplayListBuilder* aBuilder,
48765:                                  nsDisplayItem* aItem)
48765: {
48765:   // This item has an inactive layer. We will render it to a ThebesLayer
48765:   // using a temporary BasicLayerManager. Set up the layer
48765:   // manager now so that if we need to modify the retained layer
48765:   // tree during this process, those modifications will happen
48765:   // during the construction phase for the retained layer tree.
48765:   nsRefPtr<BasicLayerManager> tempManager = new BasicLayerManager();
48765:   tempManager->BeginTransaction();
48765:   nsRefPtr<Layer> layer = aItem->BuildLayer(aBuilder, tempManager);
48765:   if (!layer) {
48765:     tempManager->EndTransaction(nsnull, nsnull);
48765:     return nsnull;
48765:   }
48765:   PRInt32 appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
48765:   nsIntRect itemVisibleRect =
48765:     aItem->GetVisibleRect().ToNearestPixels(appUnitsPerDevPixel);
48765:   SetVisibleRectForLayer(layer, itemVisibleRect);
48765: 
48765:   tempManager->SetRoot(layer);
48765:   // No painting should occur yet, since there is no target context.
48765:   tempManager->EndTransaction(nsnull, nsnull);
48765:   return tempManager.forget();
48765: }
48765: 
47736: /*
47736:  * Iterate through the non-clip items in aList and its descendants.
47736:  * For each item we compute the effective clip rect. Each item is assigned
47736:  * to a layer. We invalidate the areas in ThebesLayers where an item
47736:  * has moved from one ThebesLayer to another. Also,
47736:  * aState->mInvalidThebesContent is invalidated in every ThebesLayer.
47736:  * We set the clip rect for items that generated their own layer.
47736:  * (ThebesLayers don't need a clip rect on the layer, we clip the items
47736:  * individually when we draw them.)
47736:  * We set the visible rect for all layers, although the actual setting
47736:  * of visible rects for some ThebesLayers is deferred until the calling
47736:  * of ContainerState::Finish.
47736:  */
47736: void
47736: ContainerState::ProcessDisplayItems(const nsDisplayList& aList,
47736:                                     const nsRect* aClipRect)
47736: {
47736:   for (nsDisplayItem* item = aList.GetBottom(); item; item = item->GetAbove()) {
47736:     if (item->GetType() == nsDisplayItem::TYPE_CLIP) {
47736:       nsDisplayClip* clipItem = static_cast<nsDisplayClip*>(item);
47736:       nsRect clip = clipItem->GetClipRect();
47736:       if (aClipRect) {
47736:         clip.IntersectRect(clip, *aClipRect);
47736:       }
47736:       ProcessDisplayItems(*clipItem->GetList(), &clip);
47736:       continue;
47736:     }
47736: 
47736:     PRInt32 appUnitsPerDevPixel = AppUnitsPerDevPixel(item);
47736:     nsIntRect itemVisibleRect =
47736:       item->GetVisibleRect().ToNearestPixels(appUnitsPerDevPixel);
48689:     nsRect itemContent = item->GetBounds(mBuilder);
48689:     if (aClipRect) {
48689:       itemContent.IntersectRect(*aClipRect, itemContent);
48689:     }
48689:     nsIntRect itemDrawRect = itemContent.ToNearestPixels(appUnitsPerDevPixel);
47751:     nsDisplayItem::LayerState layerState =
47751:       item->GetLayerState(mBuilder, mManager);
47751: 
47751:     // Assign the item to a layer
47751:     if (layerState == LAYER_ACTIVE) {
47763:       // If the item would have its own layer but is invisible, just hide it.
47763:       // Note that items without their own layers can't be skipped this
47763:       // way, since their ThebesLayer may decide it wants to draw them
47763:       // into its buffer even if they're currently covered.
47763:       if (itemVisibleRect.IsEmpty()) {
47763:         InvalidateForLayerChange(item, nsnull);
47763:         continue;
47763:       }
47763: 
47751:       // Just use its layer.
47736:       nsRefPtr<Layer> ownLayer = item->BuildLayer(mBuilder, mManager);
47751:       if (!ownLayer) {
47751:         InvalidateForLayerChange(item, ownLayer);
47751:         continue;
47751:       }
47751: 
47751:       // Update that layer's clip and visible rects.
47736:       NS_ASSERTION(ownLayer->Manager() == mManager, "Wrong manager");
47736:       NS_ASSERTION(ownLayer->GetUserData() != &gThebesDisplayItemLayerUserData,
47736:                    "We shouldn't have a FrameLayerBuilder-managed layer here!");
47736:       // It has its own layer. Update that layer's clip and visible rects.
47736:       if (aClipRect) {
47736:         ownLayer->IntersectClipRect(
47736:             aClipRect->ToNearestPixels(appUnitsPerDevPixel));
47736:       }
47736:       ThebesLayerData* data = GetTopThebesLayerData();
47736:       if (data) {
47736:         data->mVisibleAboveRegion.Or(data->mVisibleAboveRegion, itemVisibleRect);
48689:         // Add the entire bounds rect to the mDrawAboveRegion.
48689:         // The visible region may be excluding opaque content above the
48689:         // item, and we need to ensure that that content is not placed
48689:         // in a ThebesLayer below the item!
48689:         data->mDrawAboveRegion.Or(data->mDrawAboveRegion, itemDrawRect);
47736:       }
47736:       SetVisibleRectForLayer(ownLayer, itemVisibleRect);
47736:       ContainerLayer* oldContainer = ownLayer->GetParent();
47736:       if (oldContainer && oldContainer != mContainerLayer) {
47736:         oldContainer->RemoveChild(ownLayer);
47736:       }
47736:       NS_ASSERTION(!mNewChildLayers.Contains(ownLayer),
47736:                    "Layer already in list???");
47751: 
47751:       InvalidateForLayerChange(item, ownLayer);
47751: 
47736:       mNewChildLayers.AppendElement(ownLayer);
47736:       mBuilder->LayerBuilder()->AddLayerDisplayItem(ownLayer, item);
47736:     } else {
48765:       nsRefPtr<BasicLayerManager> tempLayerManager;
48765:       if (layerState == LAYER_INACTIVE) {
48765:         tempLayerManager = BuildTempManagerForInactiveLayer(mBuilder, item);
48765:         if (!tempLayerManager)
48765:           continue;
48765:       }
48765: 
47736:       nsIFrame* f = item->GetUnderlyingFrame();
47736:       nsPoint offsetToActiveScrolledRoot;
47736:       nsIFrame* activeScrolledRoot =
47736:         nsLayoutUtils::GetActiveScrolledRootFor(f, mBuilder->ReferenceFrame(),
47736:                                                 &offsetToActiveScrolledRoot);
47901:       NS_ASSERTION(offsetToActiveScrolledRoot == f->GetOffsetToCrossDoc(activeScrolledRoot),
47736:                    "Wrong offset");
47754:       if (item->IsFixedAndCoveringViewport(mBuilder)) {
47754:         // Make its active scrolled root be the active scrolled root of
47754:         // the enclosing viewport, since it shouldn't be scrolled by scrolled
47754:         // frames in its document. InvalidateFixedBackgroundFramesFromList in
47754:         // nsGfxScrollFrame will not repaint this item when scrolling occurs.
47754:         nsIFrame* viewportFrame =
47754:           nsLayoutUtils::GetClosestFrameOfType(f, nsGkAtoms::viewportFrame);
47754:         NS_ASSERTION(viewportFrame, "no viewport???");
47754:         activeScrolledRoot =
47754:           nsLayoutUtils::GetActiveScrolledRootFor(viewportFrame, mBuilder->ReferenceFrame(),
47754:                                                   &offsetToActiveScrolledRoot);
47754:       }
47736: 
47745:       nscolor uniformColor;
47745:       PRBool isUniform = item->IsUniform(mBuilder, &uniformColor);
47772:       PRBool isOpaque = item->IsOpaque(mBuilder);
47772:       nsIntRect opaqueRect;
47772:       if (isOpaque) {
47772:         opaqueRect = item->GetBounds(mBuilder).ToNearestPixels(appUnitsPerDevPixel);
47772:       }
47736:       nsRefPtr<ThebesLayer> thebesLayer =
48689:         FindThebesLayerFor(itemVisibleRect, itemDrawRect, activeScrolledRoot,
47772:                            isOpaque ? &opaqueRect : nsnull,
47745:                            isUniform ? &uniformColor : nsnull);
47736: 
47751:       InvalidateForLayerChange(item, thebesLayer);
47751: 
47751:       mBuilder->LayerBuilder()->
48765:         AddThebesDisplayItem(thebesLayer, item, aClipRect, mContainerFrame,
48765:                              layerState, tempLayerManager);
47751:     }
47751:   }
47751: }
47751: 
47751: void
47751: ContainerState::InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer)
47751: {
47751:   nsIFrame* f = aItem->GetUnderlyingFrame();
47736:   NS_ASSERTION(f, "Display items that render using Thebes must have a frame");
47751:   PRUint32 key = aItem->GetPerFrameKey();
47736:   NS_ASSERTION(key, "Display items that render using Thebes must have a key");
47736:   Layer* oldLayer = mBuilder->LayerBuilder()->GetOldLayerFor(f, key);
47751:   if (!oldLayer) {
47751:     // Nothing to do here, this item didn't have a layer before
47751:     return;
47751:   }
47751:   if (aNewLayer != oldLayer) {
47736:     // The item has changed layers.
47736:     // Invalidate the bounds in the old layer and new layer.
47736:     // The bounds might have changed, but we assume that any difference
47736:     // in the bounds will have been invalidated for all Thebes layers
47736:     // in the container via regular frame invalidation.
47751:     nsRect bounds = aItem->GetBounds(mBuilder);
47751:     PRInt32 appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
47736:     nsIntRect r = bounds.ToOutsidePixels(appUnitsPerDevPixel);
47736: 
47751:     ThebesLayer* t = oldLayer->AsThebesLayer();
47751:     if (t) {
47751:       InvalidatePostTransformRegion(t, r);
47751:     }
47751:     if (aNewLayer) {
47751:       ThebesLayer* newLayer = aNewLayer->AsThebesLayer();
47751:       if (newLayer) {
47751:         InvalidatePostTransformRegion(newLayer, r);
47751:       }
47736:     }
47736: 
47771:     mContainerFrame->InvalidateWithFlags(
47771:         bounds - mBuilder->ToReferenceFrame(mContainerFrame),
47771:         nsIFrame::INVALIDATE_NO_THEBES_LAYERS |
47771:         nsIFrame::INVALIDATE_EXCLUDE_CURRENT_PAINT);
47736:   }
47736: }
47736: 
47736: void
47736: FrameLayerBuilder::AddThebesDisplayItem(ThebesLayer* aLayer,
47736:                                         nsDisplayItem* aItem,
47736:                                         const nsRect* aClipRect,
47751:                                         nsIFrame* aContainerLayerFrame,
48765:                                         LayerState aLayerState,
48765:                                         LayerManager* aTempManager)
47736: {
47736:   AddLayerDisplayItem(aLayer, aItem);
47736: 
47736:   ThebesLayerItemsEntry* entry = mThebesLayerItems.PutEntry(aLayer);
47736:   if (entry) {
47736:     entry->mContainerLayerFrame = aContainerLayerFrame;
47736:     NS_ASSERTION(aItem->GetUnderlyingFrame(), "Must have frame");
47751:     ClippedDisplayItem* cdi =
47736:       entry->mItems.AppendElement(ClippedDisplayItem(aItem, aClipRect));
48765:     cdi->mTempLayerManager = aTempManager;
47736:   }
47736: }
47736: 
47736: void
47736: FrameLayerBuilder::AddLayerDisplayItem(Layer* aLayer,
47736:                                        nsDisplayItem* aItem)
47736: {
47736:   if (aLayer->Manager() != mRetainingManager)
47736:     return;
47736: 
47736:   nsIFrame* f = aItem->GetUnderlyingFrame();
47736:   DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(f);
47736:   if (entry) {
47736:     entry->mData.AppendElement(DisplayItemData(aLayer, aItem->GetPerFrameKey()));
47736:   }
47736: }
47736: 
47736: void
47745: ContainerState::CollectOldLayers()
47736: {
47736:   for (Layer* layer = mContainerLayer->GetFirstChild(); layer;
47736:        layer = layer->GetNextSibling()) {
47745:     void* data = layer->GetUserData();
47745:     if (data == &gColorLayerUserData) {
47745:       mRecycledColorLayers.AppendElement(static_cast<ColorLayer*>(layer));
47745:     } else if (data == &gThebesDisplayItemLayerUserData) {
47745:       NS_ASSERTION(layer->AsThebesLayer(), "Wrong layer type");
47745:       mRecycledThebesLayers.AppendElement(static_cast<ThebesLayer*>(layer));
47736:     }
47736:   }
47736: }
47736: 
47736: void
47736: ContainerState::Finish()
47736: {
47736:   while (!mThebesLayerDataStack.IsEmpty()) {
47736:     PopThebesLayerData();
47736:   }
47736: 
47736:   for (PRUint32 i = 0; i <= mNewChildLayers.Length(); ++i) {
47736:     // An invariant of this loop is that the layers in mNewChildLayers
47736:     // with index < i are the first i child layers of mContainerLayer.
47736:     Layer* layer;
47736:     if (i < mNewChildLayers.Length()) {
47736:       layer = mNewChildLayers[i];
47736:       if (!layer->GetParent()) {
47736:         // This is not currently a child of the container, so just add it
47736:         // now.
48243:         Layer* prevChild = i == 0 ? nsnull : mNewChildLayers[i - 1].get();
47736:         mContainerLayer->InsertAfter(layer, prevChild);
47736:         continue;
47736:       }
47736:       NS_ASSERTION(layer->GetParent() == mContainerLayer,
47736:                    "Layer shouldn't be the child of some other container");
47736:     } else {
47736:       layer = nsnull;
47736:     }
47736: 
47736:     // If layer is non-null, then it's already a child of the container,
47736:     // so scan forward until we find it, removing the other layers we
47736:     // don't want here.
47736:     // If it's null, scan forward until we've removed all the leftover
47736:     // children.
47736:     Layer* nextOldChild = i == 0 ? mContainerLayer->GetFirstChild() :
47736:       mNewChildLayers[i - 1]->GetNextSibling();
47736:     while (nextOldChild != layer) {
47736:       Layer* tmp = nextOldChild;
47736:       nextOldChild = nextOldChild->GetNextSibling();
47736:       mContainerLayer->RemoveChild(tmp);
47736:     }
47736:     // If non-null, 'layer' is now in the right place in the list, so we
47736:     // can just move on to the next one.
47736:   }
47736: }
42593: 
42593: already_AddRefed<Layer>
47736: FrameLayerBuilder::BuildContainerLayerFor(nsDisplayListBuilder* aBuilder,
42593:                                           LayerManager* aManager,
47736:                                           nsIFrame* aContainerFrame,
47736:                                           nsDisplayItem* aContainerItem,
42593:                                           const nsDisplayList& aChildren)
42593: {
47736:   FrameProperties props = aContainerFrame->Properties();
47736:   PRUint32 containerDisplayItemKey =
47736:     aContainerItem ? aContainerItem->GetPerFrameKey() : 0;
47736:   NS_ASSERTION(aContainerFrame, "Container display items here should have a frame");
47736:   NS_ASSERTION(!aContainerItem ||
47736:                aContainerItem->GetUnderlyingFrame() == aContainerFrame,
47736:                "Container display item must match given frame");
47736: 
47736:   nsRefPtr<ContainerLayer> containerLayer;
47736:   if (aManager == mRetainingManager) {
47736:     Layer* oldLayer = GetOldLayerFor(aContainerFrame, containerDisplayItemKey);
47736:     if (oldLayer) {
47736:       NS_ASSERTION(oldLayer->Manager() == aManager, "Wrong manager");
47751:       if (oldLayer->GetUserData() == &gThebesDisplayItemLayerUserData) {
47751:         // The old layer for this item is actually our ThebesLayer
47751:         // because we rendered its layer into that ThebesLayer. So we
47751:         // don't actually have a retained container layer.
47751:       } else {
47736:         NS_ASSERTION(oldLayer->GetType() == Layer::TYPE_CONTAINER,
47736:                      "Wrong layer type");
47736:         containerLayer = static_cast<ContainerLayer*>(oldLayer);
47751:         // Clear clip rect; the caller will set it if necessary.
47736:         containerLayer->SetClipRect(nsnull);
47736:       }
47736:     }
47751:   }
47736:   if (!containerLayer) {
47736:     // No suitable existing layer was found.
47736:     containerLayer = aManager->CreateContainerLayer();
47736:     if (!containerLayer)
42593:       return nsnull;
47736:   }
42593: 
47736:   ContainerState state(aBuilder, aManager, aContainerFrame, containerLayer);
42593: 
47736:   if (aManager == mRetainingManager) {
47736:     DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(aContainerFrame);
47736:     if (entry) {
47736:       entry->mData.AppendElement(
47736:           DisplayItemData(containerLayer, containerDisplayItemKey));
42593:     }
47736: 
47736:     if (mInvalidateAllThebesContent) {
47736:       state.SetInvalidateAllThebesContent();
47736:     }
47736: 
47736:     nsRegion* invalidThebesContent(static_cast<nsRegion*>
47736:       (props.Get(ThebesLayerInvalidRegionProperty())));
47736:     if (invalidThebesContent) {
47736:       nsPoint offset = aBuilder->ToReferenceFrame(aContainerFrame);
47736:       invalidThebesContent->MoveBy(offset);
47736:       state.SetInvalidThebesContent(invalidThebesContent->
47736:         ToOutsidePixels(aContainerFrame->PresContext()->AppUnitsPerDevPixel()));
47736:       invalidThebesContent->MoveBy(-offset);
47736:     } else {
47736:       // Set up region to collect invalidation data
47736:       props.Set(ThebesLayerInvalidRegionProperty(), new nsRegion());
47736:     }
47736:     aContainerFrame->AddStateBits(NS_FRAME_HAS_CONTAINER_LAYER);
47736:   }
47736: 
47736:   state.ProcessDisplayItems(aChildren, nsnull);
47736:   state.Finish();
47736: 
47736:   containerLayer->SetIsOpaqueContent(aChildren.IsOpaque());
47736:   nsRefPtr<Layer> layer = containerLayer.forget();
42593:   return layer.forget();
42593: }
42593: 
47731: Layer*
47731: FrameLayerBuilder::GetLeafLayerFor(nsDisplayListBuilder* aBuilder,
47731:                                    LayerManager* aManager,
47731:                                    nsDisplayItem* aItem)
47731: {
47736:   if (aManager != mRetainingManager)
47731:     return nsnull;
47736: 
47736:   nsIFrame* f = aItem->GetUnderlyingFrame();
47736:   NS_ASSERTION(f, "Can only call GetLeafLayerFor on items that have a frame");
47736:   Layer* layer = GetOldLayerFor(f, aItem->GetPerFrameKey());
47736:   if (!layer)
47736:     return nsnull;
47736:   if (layer->GetUserData() == &gThebesDisplayItemLayerUserData) {
47736:     // This layer was created to render Thebes-rendered content for this
47736:     // display item. The display item should not use it for its own
47736:     // layer rendering.
47736:     return nsnull;
47736:   }
47736:   // Clear clip rect; the caller is responsible for setting it.
47736:   layer->SetClipRect(nsnull);
47736:   return layer;
47731: }
47731: 
47731: /* static */ void
47731: FrameLayerBuilder::InvalidateThebesLayerContents(nsIFrame* aFrame,
47731:                                                  const nsRect& aRect)
47731: {
47736:   nsRegion* invalidThebesContent = static_cast<nsRegion*>
47736:     (aFrame->Properties().Get(ThebesLayerInvalidRegionProperty()));
47736:   if (!invalidThebesContent)
47736:     return;
47736:   invalidThebesContent->Or(*invalidThebesContent, aRect);
47736:   invalidThebesContent->SimplifyOutward(20);
47736: }
47736: 
47736: /* static */ void
47736: FrameLayerBuilder::InvalidateAllThebesLayerContents(LayerManager* aManager)
47736: {
47736:   LayerManagerData* data = static_cast<LayerManagerData*>
47736:     (aManager->GetUserData());
47736:   if (data) {
47736:     data->mInvalidateAllThebesContent = PR_TRUE;
47736:   }
47736: }
47736: 
47736: /* static */ void
47736: FrameLayerBuilder::InvalidateAllLayers(LayerManager* aManager)
47736: {
47736:   LayerManagerData* data = static_cast<LayerManagerData*>
47736:     (aManager->GetUserData());
47736:   if (data) {
47736:     data->mInvalidateAllLayers = PR_TRUE;
47736:   }
47731: }
47731: 
47740: /* static */
47740: PRBool
47740: FrameLayerBuilder::HasDedicatedLayer(nsIFrame* aFrame, PRUint32 aDisplayItemKey)
47740: {
47740:   void* propValue = aFrame->Properties().Get(DisplayItemDataProperty());
47740:   if (!propValue)
47740:     return PR_FALSE;
47740: 
47740:   nsTArray<DisplayItemData>* array =
47740:     (reinterpret_cast<nsTArray<DisplayItemData>*>(&propValue));
47740:   for (PRUint32 i = 0; i < array->Length(); ++i) {
47740:     if (array->ElementAt(i).mDisplayItemKey == aDisplayItemKey) {
47740:       void* layerUserData = array->ElementAt(i).mLayer->GetUserData();
47740:       if (layerUserData != &gColorLayerUserData &&
47740:           layerUserData != &gThebesDisplayItemLayerUserData)
47740:         return PR_TRUE;
47740:     }
47740:   }
47740:   return PR_FALSE;
47740: }
47740: 
42593: /* static */ void
42593: FrameLayerBuilder::DrawThebesLayer(ThebesLayer* aLayer,
42593:                                    gfxContext* aContext,
42593:                                    const nsIntRegion& aRegionToDraw,
47108:                                    const nsIntRegion& aRegionToInvalidate,
42593:                                    void* aCallbackData)
42593: {
47736:   nsDisplayListBuilder* builder = static_cast<nsDisplayListBuilder*>
47736:     (aCallbackData);
47766:   nsTArray<ClippedDisplayItem> items;
47766:   nsIFrame* containerLayerFrame;
47766:   {
47736:     ThebesLayerItemsEntry* entry =
47736:       builder->LayerBuilder()->mThebesLayerItems.GetEntry(aLayer);
47736:     NS_ASSERTION(entry, "We shouldn't be drawing into a layer with no items!");
47766:     items.SwapElements(entry->mItems);
47766:     containerLayerFrame = entry->mContainerLayerFrame;
47766:     // Later after this point, due to calls to DidEndTransaction
47766:     // for temporary layer managers, mThebesLayerItems can change,
47766:     // so 'entry' could become invalid.
47766:   }
47108: 
47736:   gfxMatrix transform;
47736:   if (!aLayer->GetTransform().Is2D(&transform)) {
47736:     NS_ERROR("non-2D transform in our Thebes layer!");
47736:     return;
47736:   }
47736:   NS_ASSERTION(!transform.HasNonIntegerTranslation(),
47736:                "Matrix not just an integer translation?");
47736:   // make the origin of the context coincide with the origin of the
47736:   // ThebesLayer
47736:   gfxContextMatrixAutoSaveRestore saveMatrix(aContext); 
47736:   aContext->Translate(-gfxPoint(transform.x0, transform.y0));
47736:   nsIntPoint offset(PRInt32(transform.x0), PRInt32(transform.y0));
42593: 
47766:   nsPresContext* presContext = containerLayerFrame->PresContext();
47736:   nscoord appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
47736:   nsRect r = (aRegionToInvalidate.GetBounds() + offset).
47736:     ToAppUnits(appUnitsPerDevPixel);
47771:   containerLayerFrame->InvalidateWithFlags(r,
47771:       nsIFrame::INVALIDATE_NO_THEBES_LAYERS |
47771:       nsIFrame::INVALIDATE_EXCLUDE_CURRENT_PAINT);
42593: 
42593:   // Our list may contain content with different prescontexts at
42593:   // different zoom levels. 'rc' contains the nsIRenderingContext
42593:   // used for the previous display item, and lastPresContext is the
42593:   // prescontext for that item. We also cache the clip state for that
42593:   // item.
47736:   // XXX maybe we should stop that from being true by forcing content with
47736:   // different zoom levels into different layers?
42593:   nsRefPtr<nsIRenderingContext> rc;
42593:   nsPresContext* lastPresContext = nsnull;
47736:   nsRect currentClip;
42593:   PRBool setClipRect = PR_FALSE;
47736: 
47736:   PRUint32 i;
47736:   // Update visible regions. We need perform visibility analysis again
47736:   // because we may be asked to draw into part of a ThebesLayer that
47736:   // isn't actually visible in the window (e.g., because a ThebesLayer
47736:   // expanded its visible region to a rectangle internally), in which
47736:   // case the mVisibleRect stored in the display item may be wrong.
47736:   nsRegion visible = aRegionToDraw.ToAppUnits(appUnitsPerDevPixel);
47736:   visible.MoveBy(NSIntPixelsToAppUnits(offset.x, appUnitsPerDevPixel),
47736:                  NSIntPixelsToAppUnits(offset.y, appUnitsPerDevPixel));
47736: 
47766:   for (i = items.Length(); i > 0; --i) {
47766:     ClippedDisplayItem* cdi = &items[i - 1];
47736: 
47736:     presContext = cdi->mItem->GetUnderlyingFrame()->PresContext();
47736:     if (presContext->AppUnitsPerDevPixel() != appUnitsPerDevPixel) {
47736:       // Some kind of zooming detected, just redraw the entire item
47736:       nsRegion tmp(cdi->mItem->GetBounds(builder));
47736:       cdi->mItem->RecomputeVisibility(builder, &tmp);
47736:       continue;
47736:     }
47736: 
47736:     if (!cdi->mHasClipRect || cdi->mClipRect.Contains(visible.GetBounds())) {
47736:       cdi->mItem->RecomputeVisibility(builder, &visible);
47736:       continue;
47736:     }
47736: 
47736:     // Do a little dance to account for the fact that we're clipping
47736:     // to cdi->mClipRect
47736:     nsRegion clipped;
47736:     clipped.And(visible, cdi->mClipRect);
47736:     nsRegion finalClipped = clipped;
47736:     cdi->mItem->RecomputeVisibility(builder, &finalClipped);
47736:     nsRegion removed;
47736:     removed.Sub(clipped, finalClipped);
47736:     nsRegion newVisible;
47736:     newVisible.Sub(visible, removed);
47736:     // Don't let the visible region get too complex.
47736:     if (newVisible.GetNumRects() <= 15) {
47736:       visible = newVisible;
47736:     }
47736:   }
47736: 
47766:   for (i = 0; i < items.Length(); ++i) {
47766:     ClippedDisplayItem* cdi = &items[i];
47736: 
47736:     if (cdi->mItem->GetVisibleRect().IsEmpty())
47736:       continue;
47736: 
47736:     presContext = cdi->mItem->GetUnderlyingFrame()->PresContext();
42593:     // If the new desired clip state is different from the current state,
42593:     // update the clip.
47736:     if (setClipRect != cdi->mHasClipRect ||
47736:         (cdi->mHasClipRect && cdi->mClipRect != currentClip)) {
42593:       if (setClipRect) {
42593:         aContext->Restore();
42593:       }
47736:       setClipRect = cdi->mHasClipRect;
42593:       if (setClipRect) {
47736:         currentClip = cdi->mClipRect;
42593:         aContext->Save();
42593:         aContext->NewPath();
47736:         gfxRect clip(currentClip.x, currentClip.y, currentClip.width, currentClip.height);
47736:         clip.ScaleInverse(presContext->AppUnitsPerDevPixel());
47736:         aContext->Rectangle(clip, PR_TRUE);
42593:         aContext->Clip();
42593:       }
42593:     }
47736: 
47751:     if (cdi->mTempLayerManager) {
47751:       // This item has an inactive layer. Render it to the ThebesLayer
47751:       // using the temporary BasicLayerManager.
47751:       cdi->mTempLayerManager->BeginTransactionWithTarget(aContext);
47751:       cdi->mTempLayerManager->EndTransaction(DrawThebesLayer, builder);
47751:     } else {
42593:       if (presContext != lastPresContext) {
42593:         // Create a new rendering context with the right
42593:         // appunits-per-dev-pixel.
42593:         nsresult rv =
42593:           presContext->DeviceContext()->CreateRenderingContextInstance(*getter_AddRefs(rc));
42593:         if (NS_FAILED(rv))
42593:           break;
42593:         rc->Init(presContext->DeviceContext(), aContext);
42593:         lastPresContext = presContext;
42593:       }
47736:       cdi->mItem->Paint(builder, rc);
42593:     }
47751:   }
47736: 
42593:   if (setClipRect) {
42593:     aContext->Restore();
42593:   }
42593: }
42593: 
47736: #ifdef DEBUG
47736: void
47736: FrameLayerBuilder::DumpRetainedLayerTree()
47736: {
47736:   if (mRetainingManager) {
48025:     mRetainingManager->Dump(stderr);
47736:   }
47736: }
47736: #endif
47736: 
42593: } // namespace mozilla
