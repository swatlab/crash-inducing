75402: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
75402:  * vim: set ts=8 sw=4 et tw=99 ft=cpp:
75402:  *
75402:  * ***** BEGIN LICENSE BLOCK *****
75402:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
75402:  *
75402:  * The contents of this file are subject to the Mozilla Public License Version
75402:  * 1.1 (the "License"); you may not use this file except in compliance with
75402:  * the License. You may obtain a copy of the License at
75402:  * http://www.mozilla.org/MPL/
75402:  *
75402:  * Software distributed under the License is distributed on an "AS IS" basis,
75402:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
75402:  * for the specific language governing rights and limitations under the
75402:  * License.
75402:  *
75513:  * The Original Code is SpiderMonkey Debugger object.
75402:  *
75402:  * The Initial Developer of the Original Code is
75402:  * Mozilla Foundation.
75402:  * Portions created by the Initial Developer are Copyright (C) 1998-1999
75402:  * the Initial Developer. All Rights Reserved.
75402:  *
75402:  * Contributors:
75402:  *   Jim Blandy <jimb@mozilla.com>
75402:  *   Jason Orendorff <jorendorff@mozilla.com>
75402:  *
75402:  * Alternatively, the contents of this file may be used under the terms of
75402:  * either of the GNU General Public License Version 2 or later (the "GPL"),
75402:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
75402:  * in which case the provisions of the GPL or the LGPL are applicable instead
75402:  * of those above. If you wish to allow use of your version of this file only
75402:  * under the terms of either the GPL or the LGPL, and not to allow others to
75402:  * use your version of this file under the terms of the MPL, indicate your
75402:  * decision by deleting the provisions above and replace them with the notice
75402:  * and other provisions required by the GPL or the LGPL. If you do not delete
75402:  * the provisions above, a recipient may use your version of this file under
75402:  * the terms of any one of the MPL, the GPL or the LGPL.
75402:  *
75402:  * ***** END LICENSE BLOCK ***** */
75402: 
76244: #ifndef Debugger_h__
76244: #define Debugger_h__
75402: 
75402: #include "jsapi.h"
75506: #include "jsclist.h"
76212: #include "jscntxt.h"
75406: #include "jscompartment.h"
75402: #include "jsgc.h"
75413: #include "jshashtable.h"
75486: #include "jsweakmap.h"
75402: #include "jswrapper.h"
75402: #include "jsvalue.h"
75452: #include "vm/GlobalObject.h"
75402: 
75402: namespace js {
75402: 
75513: class Debugger {
75506:     friend class js::Breakpoint;
75513:     friend JSBool (::JS_DefineDebuggerObject)(JSContext *cx, JSObject *obj);
75402: 
75518:   public:
75518:     enum NewScriptKind { NewNonHeldScript, NewHeldScript };
75518: 
76226:     enum Hook {
76226:         OnDebuggerStatement,
76226:         OnExceptionUnwind,
76226:         OnNewScript,
76226:         OnEnterFrame,
76226:         HookCount
76226:     };
76226: 
76234:     enum {
76234:         JSSLOT_DEBUG_PROTO_START,
76234:         JSSLOT_DEBUG_FRAME_PROTO = JSSLOT_DEBUG_PROTO_START,
76234:         JSSLOT_DEBUG_OBJECT_PROTO,
76234:         JSSLOT_DEBUG_SCRIPT_PROTO,
76234:         JSSLOT_DEBUG_PROTO_STOP,
76234:         JSSLOT_DEBUG_HOOK_START = JSSLOT_DEBUG_PROTO_STOP,
76234:         JSSLOT_DEBUG_HOOK_STOP = JSSLOT_DEBUG_HOOK_START + HookCount,
76234:         JSSLOT_DEBUG_COUNT = JSSLOT_DEBUG_HOOK_STOP
76234:     };
75402: 
76234:   private:
76236:     JSCList link;                       /* See JSRuntime::debuggerList. */
76236:     JSObject *object;                   /* The Debugger object. Strong reference. */
76236:     GlobalObjectSet debuggees;          /* Debuggee globals. Cross-compartment weak references. */
76236:     JSObject *uncaughtExceptionHook;    /* Strong reference. */
76234:     bool enabled;
76236:     JSCList breakpoints;                /* cyclic list of all js::Breakpoints in this debugger */
75506: 
76236:     /*
76259:      * Map from stack frames that are currently on the stack to Debugger.Frame
76259:      * instances.
76259:      *
76259:      * The keys are always live stack frames. We drop them from this map as
76259:      * soon as they leave the stack (see slowPathOnLeaveFrame) and in
76259:      * removeDebuggee.
76259:      *
76259:      * We don't trace the keys of this map (the frames are on the stack and
76259:      * thus necessarily live), but we do trace the values. It's like a WeakMap
76259:      * that way, but since stack frames are not gc-things, the implementation
76259:      * has to be different.
76236:      */
76212:     typedef HashMap<StackFrame *, JSObject *, DefaultHasher<StackFrame *>, RuntimeAllocPolicy>
75413:         FrameMap;
75413:     FrameMap frames;
75413: 
76236:     /* The map from debuggee objects to their Debugger.Object instances. */
75495:     typedef WeakMap<JSObject *, JSObject *, DefaultHasher<JSObject *>, CrossCompartmentMarkPolicy>
75486:         ObjectWeakMap;
75486:     ObjectWeakMap objects;
75418: 
76236:     /*
76244:      * An ephemeral map from script-holding objects to Debugger.Script
76236:      * instances.
76236:      */
75496:     typedef WeakMap<JSObject *, JSObject *, DefaultHasher<JSObject *>, CrossCompartmentMarkPolicy>
75492:         ScriptWeakMap;
75492: 
76236:     /*
76236:      * Map of Debugger.Script instances for garbage-collected JSScripts. For
76236:      * function scripts, the key is the compiler-created, internal JSFunction;
76236:      * for scripts returned by JSAPI functions, the key is the "Script"-class
76236:      * JSObject.
76236:      */
75492:     ScriptWeakMap heldScripts;
75492: 
76236:     /*
76236:      * An ordinary (non-ephemeral) map from JSScripts to Debugger.Script
76236:      * instances, for non-held scripts that are explicitly freed.
76236:      */
76212:     typedef HashMap<JSScript *, JSObject *, DefaultHasher<JSScript *>, RuntimeAllocPolicy>
75492:         ScriptMap;
75492: 
76236:     /*
76236:      * Map from non-held JSScripts to their Debugger.Script objects. Non-held
76236:      * scripts are scripts created for eval or JS_Evaluate* calls that are
76236:      * explicitly destroyed when the call returns. Debugger.Script objects are
76236:      * not strong references to such JSScripts; the Debugger.Script becomes
76236:      * "dead" when the eval call returns.
76236:      */
75517:     ScriptMap nonHeldScripts;
75492: 
75455:     bool addDebuggeeGlobal(JSContext *cx, GlobalObject *obj);
75489:     void removeDebuggeeGlobal(JSContext *cx, GlobalObject *global,
75489:                               GlobalObjectSet::Enum *compartmentEnum,
75453:                               GlobalObjectSet::Enum *debugEnum);
75453: 
76236:     /*
76236:      * Cope with an error or exception in a debugger hook.
76236:      *
76248:      * If callHook is true, then call the uncaughtExceptionHook, if any. If, in
76248:      * addition, vp is non-null, then parse the value returned by
76236:      * uncaughtExceptionHook as a resumption value.
76236:      *
76236:      * If there is no uncaughtExceptionHook, or if it fails, report and clear
76236:      * the pending exception on ac.context and return JSTRAP_ERROR.
76236:      *
76236:      * This always calls ac.leave(); ac is a parameter because this method must
76236:      * do some things in the debugger compartment and some things in the
76236:      * debuggee compartment.
76236:      */
75404:     JSTrapStatus handleUncaughtException(AutoCompartment &ac, Value *vp, bool callHook);
76259: 
76259:     /*
76259:      * Handle the result of a hook that is expected to return a resumption
76259:      * value <https://wiki.mozilla.org/Debugger#Resumption_Values>. This is called
76259:      * when we return from a debugging hook to debuggee code. The interpreter wants
76259:      * a (JSTrapStatus, Value) pair telling it how to proceed.
76259:      *
76259:      * Precondition: ac is entered. We are in the debugger compartment.
76259:      *
76259:      * Postcondition: This called ac.leave(). See handleUncaughtException.
76259:      *
76259:      * If ok is false, the hook failed. If an exception is pending in
76259:      * ac.context(), return handleUncaughtException(ac, vp, callhook).
76259:      * Otherwise just return JSTRAP_ERROR.
76259:      *
76259:      * If ok is true, there must be no exception pending in ac.context(). rv may be:
76259:      *     undefined - Return JSTRAP_CONTINUE to continue execution normally.
76259:      *     {return: value} or {throw: value} - Call unwrapDebuggeeValue to
76259:      *         unwrap value. Store the result in *vp and return JSTRAP_RETURN
76259:      *         or JSTRAP_THROW. The interpreter will force the current frame to
76259:      *         return or throw an exception.
76259:      *     null - Return JSTRAP_ERROR to terminate the debuggee with an
76259:      *         uncatchable error.
76259:      *     anything else - Make a new TypeError the pending exception and
76259:      *         return handleUncaughtException(ac, vp, callHook).
76259:      */
75404:     JSTrapStatus parseResumptionValue(AutoCompartment &ac, bool ok, const Value &rv, Value *vp,
75404:                                       bool callHook = true);
76259: 
76264:     JSObject *unwrapDebuggeeArgument(JSContext *cx, const Value &v);
75402: 
75486:     static void traceObject(JSTracer *trc, JSObject *obj);
75486:     void trace(JSTracer *trc);
75402:     static void finalize(JSContext *cx, JSObject *obj);
76248:     static void markKeysInCompartment(JSTracer *tracer, const ObjectWeakMap &map);
75402: 
75402:     static Class jsclass;
76226: 
76264:     static Debugger *fromThisValue(JSContext *cx, const CallArgs &ca, const char *fnname);
75403:     static JSBool getEnabled(JSContext *cx, uintN argc, Value *vp);
75403:     static JSBool setEnabled(JSContext *cx, uintN argc, Value *vp);
76234:     static JSBool getHookImpl(JSContext *cx, uintN argc, Value *vp, Hook which);
76234:     static JSBool setHookImpl(JSContext *cx, uintN argc, Value *vp, Hook which);
76230:     static JSBool getOnDebuggerStatement(JSContext *cx, uintN argc, Value *vp);
76230:     static JSBool setOnDebuggerStatement(JSContext *cx, uintN argc, Value *vp);
76230:     static JSBool getOnExceptionUnwind(JSContext *cx, uintN argc, Value *vp);
76230:     static JSBool setOnExceptionUnwind(JSContext *cx, uintN argc, Value *vp);
76230:     static JSBool getOnNewScript(JSContext *cx, uintN argc, Value *vp);
76230:     static JSBool setOnNewScript(JSContext *cx, uintN argc, Value *vp);
76230:     static JSBool getOnEnterFrame(JSContext *cx, uintN argc, Value *vp);
76230:     static JSBool setOnEnterFrame(JSContext *cx, uintN argc, Value *vp);
75404:     static JSBool getUncaughtExceptionHook(JSContext *cx, uintN argc, Value *vp);
75404:     static JSBool setUncaughtExceptionHook(JSContext *cx, uintN argc, Value *vp);
75456:     static JSBool addDebuggee(JSContext *cx, uintN argc, Value *vp);
75456:     static JSBool removeDebuggee(JSContext *cx, uintN argc, Value *vp);
75456:     static JSBool hasDebuggee(JSContext *cx, uintN argc, Value *vp);
75456:     static JSBool getDebuggees(JSContext *cx, uintN argc, Value *vp);
75515:     static JSBool getNewestFrame(JSContext *cx, uintN argc, Value *vp);
75506:     static JSBool clearAllBreakpoints(JSContext *cx, uintN argc, Value *vp);
75402:     static JSBool construct(JSContext *cx, uintN argc, Value *vp);
75402:     static JSPropertySpec properties[];
75441:     static JSFunctionSpec methods[];
75402: 
76234:     JSObject *getHook(Hook hook) const;
77173:     bool hasAnyLiveHooks(JSContext *cx) const;
75406: 
75523:     static void slowPathOnEnterFrame(JSContext *cx);
75523:     static void slowPathOnLeaveFrame(JSContext *cx);
75518:     static void slowPathOnNewScript(JSContext *cx, JSScript *script, JSObject *obj,
75518:                                     NewScriptKind kind);
75492:     static void slowPathOnDestroyScript(JSScript *script);
75413: 
76226:     static JSTrapStatus dispatchHook(JSContext *cx, js::Value *vp, Hook which);
75439: 
76226:     JSTrapStatus fireDebuggerStatement(JSContext *cx, Value *vp);
76226:     JSTrapStatus fireExceptionUnwind(JSContext *cx, Value *vp);
76226:     void fireEnterFrame(JSContext *cx);
75523: 
76236:     /*
76236:      * Allocate and initialize a Debugger.Script instance whose referent is |script| and
76236:      * whose holder is |obj|. If |obj| is NULL, this creates a Debugger.Script whose holder
76236:      * is null, for non-held scripts.
76236:      */
75513:     JSObject *newDebuggerScript(JSContext *cx, JSScript *script, JSObject *obj);
75492: 
76236:     /* Helper function for wrapFunctionScript and wrapJSAPIscript. */
75492:     JSObject *wrapHeldScript(JSContext *cx, JSScript *script, JSObject *obj);
75492: 
76236:     /*
76236:      * Receive a "new script" event from the engine. A new script was compiled
76259:      * or deserialized. If kind is NewHeldScript, obj must be the holder
76259:      * object. Otherwise, kind must be NewNonHeldScript, script must be an eval
76259:      * or JS_Evaluate* script, and we must have
76259:      *     obj->getGlobal() == scopeObj->getGlobal()
76259:      * where scopeObj is the scope in which the new script will be executed.
76236:      */
76226:     void fireNewScript(JSContext *cx, JSScript *script, JSObject *obj, NewScriptKind kind);
75518: 
76236:     /* Remove script from our table of non-held scripts. */
75517:     void destroyNonHeldScript(JSScript *script);
75492: 
75513:     static inline Debugger *fromLinks(JSCList *links);
75506:     inline Breakpoint *firstBreakpoint() const;
75506: 
75402:   public:
76226:     Debugger(JSContext *cx, JSObject *dbg);
75513:     ~Debugger();
75451: 
75452:     bool init(JSContext *cx);
75413:     inline JSObject *toJSObject() const;
75513:     static inline Debugger *fromJSObject(JSObject *obj);
75513:     static Debugger *fromChildJSObject(JSObject *obj);
75402: 
75425:     /*********************************** Methods for interaction with the GC. */
75425: 
76236:     /*
76236:      * A Debugger object is live if:
76236:      *   * the Debugger JSObject is live (Debugger::trace handles this case); OR
76236:      *   * it is in the middle of dispatching an event (the event dispatching
76236:      *     code roots it in this case); OR
76236:      *   * it is enabled, and it is debugging at least one live compartment,
76236:      *     and at least one of the following is true:
76236:      *       - it has a debugger hook installed
76236:      *       - it has a breakpoint set on a live script
76236:      *       - it has a watchpoint set on a live object.
76236:      *
77173:      * Debugger::markAllIteratively handles the last case. If it finds any
77173:      * Debugger objects that are definitely live but not yet marked, it marks
77173:      * them and returns true. If not, it returns false.
76236:      */
75513:     static void markCrossCompartmentDebuggerObjectReferents(JSTracer *tracer);
76255:     static bool markAllIteratively(GCMarker *trc, JSGCInvocationKind gckind);
75489:     static void sweepAll(JSContext *cx);
75489:     static void detachAllDebuggersFromGlobal(JSContext *cx, GlobalObject *global,
75453:                                              GlobalObjectSet::Enum *compartmentEnum);
75406: 
75523:     static inline void onEnterFrame(JSContext *cx);
75523:     static inline void onLeaveFrame(JSContext *cx);
75406:     static inline JSTrapStatus onDebuggerStatement(JSContext *cx, js::Value *vp);
76226:     static inline JSTrapStatus onExceptionUnwind(JSContext *cx, js::Value *vp);
75518:     static inline void onNewScript(JSContext *cx, JSScript *script, JSObject *obj,
75518:                                    NewScriptKind kind);
75492:     static inline void onDestroyScript(JSScript *script);
75506:     static JSTrapStatus onTrap(JSContext *cx, Value *vp);
77171:     static JSTrapStatus onSingleStep(JSContext *cx, Value *vp);
75419: 
76244:     /************************************* Functions for use by Debugger.cpp. */
75425: 
75523:     inline bool observesEnterFrame() const;
75518:     inline bool observesNewScript() const;
75444:     inline bool observesScope(JSObject *obj) const;
75444:     inline bool observesFrame(StackFrame *fp) const;
75444: 
76236:     /*
76248:      * Like cx->compartment->wrap(cx, vp), but for the debugger compartment.
76236:      *
76248:      * Preconditions: *vp is a value from a debuggee compartment; cx is in the
76248:      * debugger's compartment.
76248:      *
76248:      * If *vp is an object, this produces a (new or existing) Debugger.Object
76248:      * wrapper for it. Otherwise this is the same as JSCompartment::wrap.
76236:      */
75419:     bool wrapDebuggeeValue(JSContext *cx, Value *vp);
75419: 
76236:     /*
76248:      * Unwrap a Debug.Object, without rewrapping it for any particular debuggee
76248:      * compartment.
76236:      *
76248:      * Preconditions: cx is in the debugger compartment. *vp is a value in that
76248:      * compartment. (*vp should be a "debuggee value", meaning it is the
76248:      * debugger's reflection of a value in the debuggee.)
76236:      *
76236:      * If *vp is a Debugger.Object, store the referent in *vp. Otherwise, if *vp
76236:      * is an object, throw a TypeError, because it is not a debuggee
76236:      * value. Otherwise *vp is a primitive, so leave it alone.
76236:      *
76248:      * When passing values from the debuggee to the debugger:
76248:      *     enter debugger compartment;
76248:      *     call wrapDebuggeeValue;  // compartment- and debugger-wrapping
76248:      *
76248:      * When passing values from the debugger to the debuggee:
76248:      *     call unwrapDebuggeeValue;  // debugger-unwrapping
76248:      *     enter debuggee compartment;
76248:      *     call cx->compartment->wrap;  // compartment-rewrapping
76248:      *
76248:      * (Extreme nerd sidebar: Unwrapping happens in two steps because there are
76248:      * two different kinds of symmetry at work: regardless of which direction
76248:      * we're going, we want any exceptions to be created and thrown in the
76248:      * debugger compartment--mirror symmetry. But compartment wrapping always
76248:      * happens in the target compartment--rotational symmetry.)
76236:      */
75419:     bool unwrapDebuggeeValue(JSContext *cx, Value *vp);
75419: 
76236:     /* Store the Debugger.Frame object for the frame fp in *vp. */
75425:     bool getScriptFrame(JSContext *cx, StackFrame *fp, Value *vp);
75427: 
76236:     /*
76236:      * Precondition: we are in the debuggee compartment (ac is entered) and ok
76236:      * is true if the operation in the debuggee compartment succeeded, false on
76236:      * error or exception.
76236:      *
76248:      * Postcondition: we are in the debugger compartment, having called
76248:      * ac.leave() even if an error occurred.
76236:      *
76236:      * On success, a completion value is in vp and ac.context does not have a
76236:      * pending exception. (This ordinarily returns true even if the ok argument
76236:      * is false.)
76236:      */
75427:     bool newCompletionValue(AutoCompartment &ac, bool ok, Value val, Value *vp);
75452: 
76236:     /*
76236:      * Return the Debugger.Script object for |fun|'s script, or create a new
76236:      * one if needed.  The context |cx| must be in the debugger compartment;
76236:      * |fun| must be a cross-compartment wrapper referring to the JSFunction in
76236:      * a debuggee compartment.
76236:      */
75492:     JSObject *wrapFunctionScript(JSContext *cx, JSFunction *fun);
75492: 
76236:     /*
76236:      * Return the Debugger.Script object for the Script object |obj|'s
76236:      * JSScript, or create a new one if needed. The context |cx| must be in the
76236:      * debugger compartment; |obj| must be a cross-compartment wrapper
76236:      * referring to a script object in a debuggee compartment.
76236:      */
75492:     JSObject *wrapJSAPIScript(JSContext *cx, JSObject *scriptObj);
75492: 
76236:     /*
76236:      * Return the Debugger.Script object for the non-held script |script|, or
76236:      * create a new one if needed. The context |cx| must be in the debugger
76236:      * compartment; |script| must be a script in a debuggee compartment.
76236:      */
75517:     JSObject *wrapNonHeldScript(JSContext *cx, JSScript *script);
75492: 
75452:   private:
76236:     /* Prohibit copying. */
75513:     Debugger(const Debugger &);
75513:     Debugger & operator=(const Debugger &);
75406: };
75406: 
75506: class BreakpointSite {
75506:     friend class js::Breakpoint;
75506:     friend class ::JSCompartment;
75513:     friend class js::Debugger;
75506: 
75506:   public:
75506:     JSScript * const script;
75506:     jsbytecode * const pc;
75506:     const JSOp realOpcode;
75506: 
75506:   private:
76236:     /*
76236:      * The holder object for script, if known, else NULL.  This is NULL for
76236:      * non-held scripts and for JSD1 traps. It is always non-null for JSD2
76236:      * breakpoints in held scripts.
76236:      */
75506:     JSObject *scriptObject;
75506: 
76236:     JSCList breakpoints;  /* cyclic list of all js::Breakpoints at this instruction */
76236:     size_t enabledCount;  /* number of breakpoints in the list that are enabled */
76236:     JSTrapHandler trapHandler;  /* jsdbgapi trap state */
75506:     Value trapClosure;
75506: 
75506:     bool recompile(JSContext *cx, bool forTrap);
75506: 
75506:   public:
75506:     BreakpointSite(JSScript *script, jsbytecode *pc);
75506:     Breakpoint *firstBreakpoint() const;
75506:     bool hasBreakpoint(Breakpoint *bp);
76243:     bool hasTrap() const { return !!trapHandler; }
77173:     JSObject *getScriptObject() const { return scriptObject; }
75506: 
75506:     bool inc(JSContext *cx);
75506:     void dec(JSContext *cx);
75506:     bool setTrap(JSContext *cx, JSTrapHandler handler, const Value &closure);
75506:     void clearTrap(JSContext *cx, BreakpointSiteMap::Enum *e = NULL,
75506:                    JSTrapHandler *handlerp = NULL, Value *closurep = NULL);
75506:     void destroyIfEmpty(JSRuntime *rt, BreakpointSiteMap::Enum *e);
75506: };
75506: 
77173: /*
77173:  * Each Breakpoint is a member of two linked lists: its debugger's list and its
77173:  * site's list.
77173:  *
77173:  * GC rules:
77173:  *   - script is live, breakpoint exists, and debugger is enabled
77173:  *      ==> debugger is live
77173:  *   - script is live, breakpoint exists, and debugger is live
77173:  *      ==> retain the breakpoint and the handler object is live
77173:  *
77173:  * Debugger::markAllIteratively implements these two rules. It uses
77173:  * Debugger::hasAnyLiveHooks to check for rule 1.
77173:  *
77173:  * Nothing else causes a breakpoint to be retained, so if its script or
77173:  * debugger is collected, the breakpoint is destroyed during GC sweep phase,
77173:  * even if the debugger compartment isn't being GC'd. This is implemented in
77173:  * JSCompartment::sweepBreakpoints.
77173:  */
75506: class Breakpoint {
75506:     friend class ::JSCompartment;
75513:     friend class js::Debugger;
75506: 
75506:   public:
75513:     Debugger * const debugger;
75506:     BreakpointSite * const site;
75506:   private:
75506:     JSObject *handler;
75506:     JSCList debuggerLinks;
75506:     JSCList siteLinks;
75506: 
75506:   public:
75506:     static Breakpoint *fromDebuggerLinks(JSCList *links);
75506:     static Breakpoint *fromSiteLinks(JSCList *links);
75513:     Breakpoint(Debugger *debugger, BreakpointSite *site, JSObject *handler);
75506:     void destroy(JSContext *cx, BreakpointSiteMap::Enum *e = NULL);
75506:     Breakpoint *nextInDebugger();
75506:     Breakpoint *nextInSite();
75506:     JSObject *getHandler() const { return handler; }
75506: };
75506: 
75518: Debugger *
75518: Debugger::fromLinks(JSCList *links)
75510: {
75510:     unsigned char *p = reinterpret_cast<unsigned char *>(links);
75513:     return reinterpret_cast<Debugger *>(p - offsetof(Debugger, link));
75510: }
75510: 
75506: Breakpoint *
75513: Debugger::firstBreakpoint() const
75506: {
75506:     if (JS_CLIST_IS_EMPTY(&breakpoints))
75506:         return NULL;
75506:     return Breakpoint::fromDebuggerLinks(JS_NEXT_LINK(&breakpoints));
75506: }
75506: 
75406: JSObject *
75513: Debugger::toJSObject() const
75406: {
75402:     JS_ASSERT(object);
75402:     return object;
75402: }
75402: 
75513: Debugger *
75513: Debugger::fromJSObject(JSObject *obj)
75406: {
75402:     JS_ASSERT(obj->getClass() == &jsclass);
75513:     return (Debugger *) obj->getPrivate();
75402: }
75402: 
75518: bool
75523: Debugger::observesEnterFrame() const
75523: {
76234:     return enabled && getHook(OnEnterFrame);
75523: }
75523: 
75523: bool
75518: Debugger::observesNewScript() const
75518: {
76234:     return enabled && getHook(OnNewScript);
75518: }
75518: 
75518: bool
75518: Debugger::observesScope(JSObject *obj) const
75518: {
75518:     return debuggees.has(obj->getGlobal());
75518: }
75518: 
75518: bool
75518: Debugger::observesFrame(StackFrame *fp) const
75518: {
75518:     return observesScope(&fp->scopeChain());
75518: }
75518: 
75413: void
75523: Debugger::onEnterFrame(JSContext *cx)
75523: {
75523:     if (!cx->compartment->getDebuggees().empty())
75523:         slowPathOnEnterFrame(cx);
75523: }
75523: 
75523: void
75523: Debugger::onLeaveFrame(JSContext *cx)
75413: {
75506:     if (!cx->compartment->getDebuggees().empty() || !cx->compartment->breakpointSites.empty())
75523:         slowPathOnLeaveFrame(cx);
75413: }
75413: 
75406: JSTrapStatus
75513: Debugger::onDebuggerStatement(JSContext *cx, js::Value *vp)
75406: {
75452:     return cx->compartment->getDebuggees().empty()
75406:            ? JSTRAP_CONTINUE
76226:            : dispatchHook(cx, vp, OnDebuggerStatement);
75439: }
75439: 
75439: JSTrapStatus
76226: Debugger::onExceptionUnwind(JSContext *cx, js::Value *vp)
75439: {
75452:     return cx->compartment->getDebuggees().empty()
75439:            ? JSTRAP_CONTINUE
76226:            : dispatchHook(cx, vp, OnExceptionUnwind);
75406: }
75402: 
75492: void
75518: Debugger::onNewScript(JSContext *cx, JSScript *script, JSObject *obj, NewScriptKind kind)
75518: {
75520:     JS_ASSERT_IF(kind == NewHeldScript || script->compileAndGo, obj);
76766:     if (!script->compartment->getDebuggees().empty())
75518:         slowPathOnNewScript(cx, script, obj, kind);
75518: }
75518: 
75518: void
75513: Debugger::onDestroyScript(JSScript *script)
75492: {
76766:     if (!script->compartment->getDebuggees().empty())
75492:         slowPathOnDestroyScript(script);
75492: }
75492: 
75472: extern JSBool
75472: EvaluateInScope(JSContext *cx, JSObject *scobj, StackFrame *fp, const jschar *chars,
75472:                 uintN length, const char *filename, uintN lineno, Value *rval);
75472: 
75402: }
75402: 
76244: #endif /* Debugger_h__ */
