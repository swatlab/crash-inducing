    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Radha Kulkarni <radha@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: // Local Includes 
    1: #include "nsSHistory.h"
    1: 
    1: // Helper Classes
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
72449: #include "mozilla/Preferences.h"
    1: 
    1: // Interfaces Needed
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellLoadInfo.h"
    1: #include "nsISHContainer.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeNode.h"
    1: #include "nsIDocShellLoadInfo.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIURI.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsICacheService.h"
    1: #include "nsIObserverService.h"
    1: #include "prclist.h"
41540: #include "mozilla/Services.h"
50721: #include "nsTArray.h"
50721: #include "nsCOMArray.h"
52044: #include "nsDocShell.h"
    1: 
    1: // For calculating max history entries and max cachable contentviewers
    1: #include "nspr.h"
    1: #include <math.h>  // for log()
    1: 
72449: using namespace mozilla;
72449: 
    1: #define PREF_SHISTORY_SIZE "browser.sessionhistory.max_entries"
    1: #define PREF_SHISTORY_MAX_TOTAL_VIEWERS "browser.sessionhistory.max_total_viewers"
80309: #define PREF_SHISTORY_OPTIMIZE_EVICTION "browser.sessionhistory.optimize_eviction"
    1: 
72449: static const char* kObservedPrefs[] = {
72449:   PREF_SHISTORY_SIZE,
72449:   PREF_SHISTORY_MAX_TOTAL_VIEWERS,
80309:   PREF_SHISTORY_OPTIMIZE_EVICTION,
72449:   nsnull
72449: };
72449: 
    1: static PRInt32  gHistoryMaxSize = 50;
    1: // Max viewers allowed per SHistory objects
    1: static const PRInt32  gHistoryMaxViewers = 3;
    1: // List of all SHistory objects, used for content viewer cache eviction
    1: static PRCList gSHistoryList;
    1: // Max viewers allowed total, across all SHistory objects - negative default
    1: // means we will calculate how many viewers to cache based on total memory
    1: PRInt32 nsSHistory::sHistoryMaxTotalViewers = -1;
    1: 
80309: // Whether we should optimize the search for which entry to evict,
80309: // by evicting older entries first. See entryLastTouched in
80309: // nsSHistory::EvictGlobalContentViewer().
80309: // NB: After 4.0, we should remove this option and the corresponding
80309: //     pref - optimization should always be used
80309: static PRBool gOptimizeEviction = PR_FALSE;
60876: // A counter that is used to be able to know the order in which
60876: // entries were touched, so that we can evict older entries first.
60876: static PRUint32 gTouchCounter = 0;
60876: 
    1: enum HistCmd{
    1:   HIST_CMD_BACK,
    1:   HIST_CMD_FORWARD,
    1:   HIST_CMD_GOTOINDEX,
    1:   HIST_CMD_RELOAD
    1: } ;
    1: 
    1: //*****************************************************************************
    1: //***      nsSHistoryObserver
    1: //*****************************************************************************
    1: 
    1: class nsSHistoryObserver : public nsIObserver
    1: {
    1: 
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIOBSERVER
    1: 
    1:   nsSHistoryObserver() {}
    1: 
    1: protected:
    1:   ~nsSHistoryObserver() {}
    1: };
    1: 
72449: static nsSHistoryObserver* gObserver = nsnull;
72449: 
    1: NS_IMPL_ISUPPORTS1(nsSHistoryObserver, nsIObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsSHistoryObserver::Observe(nsISupports *aSubject, const char *aTopic,
    1:                             const PRUnichar *aData)
    1: {
    1:   if (!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
72449:     nsSHistory::UpdatePrefs();
80309:     nsSHistory::EvictGlobalContentViewer();
    1:   } else if (!strcmp(aTopic, NS_CACHESERVICE_EMPTYCACHE_TOPIC_ID) ||
    1:              !strcmp(aTopic, "memory-pressure")) {
80309:     nsSHistory::EvictAllContentViewersGlobally();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: //***    nsSHistory: Object Management
    1: //*****************************************************************************
    1: 
    1: nsSHistory::nsSHistory() : mListRoot(nsnull), mIndex(-1), mLength(0), mRequestedIndex(-1)
    1: {
    1:   // Add this new SHistory object to the list
    1:   PR_APPEND_LINK(this, &gSHistoryList);
    1: }
    1: 
    1: 
    1: nsSHistory::~nsSHistory()
    1: {
    1:   // Remove this SHistory object from the list
    1:   PR_REMOVE_LINK(this);
    1: }
    1: 
    1: //*****************************************************************************
    1: //    nsSHistory: nsISupports
    1: //*****************************************************************************
    1: 
    1: NS_IMPL_ADDREF(nsSHistory)
    1: NS_IMPL_RELEASE(nsSHistory)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsSHistory)
    1:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsISHistory)
    1:    NS_INTERFACE_MAP_ENTRY(nsISHistory)
    1:    NS_INTERFACE_MAP_ENTRY(nsIWebNavigation)
    1:    NS_INTERFACE_MAP_ENTRY(nsISHistoryInternal)
    1: NS_INTERFACE_MAP_END
    1: 
    1: //*****************************************************************************
    1: //    nsSHistory: nsISHistory
    1: //*****************************************************************************
    1: 
    1: // static
    1: PRUint32
    1: nsSHistory::CalcMaxTotalViewers()
    1: {
    1:   // Calculate an estimate of how many ContentViewers we should cache based
    1:   // on RAM.  This assumes that the average ContentViewer is 4MB (conservative)
    1:   // and caps the max at 8 ContentViewers
    1:   //
    1:   // TODO: Should we split the cache memory betw. ContentViewer caching and
    1:   // nsCacheService?
    1:   //
    1:   // RAM      ContentViewers
    1:   // -----------------------
    1:   // 32   Mb       0
    1:   // 64   Mb       1
    1:   // 128  Mb       2
    1:   // 256  Mb       3
    1:   // 512  Mb       5
    1:   // 1024 Mb       8
    1:   // 2048 Mb       8
    1:   // 4096 Mb       8
    1:   PRUint64 bytes = PR_GetPhysicalMemorySize();
    1: 
    1:   if (LL_IS_ZERO(bytes))
    1:     return 0;
    1: 
    1:   // Conversion from unsigned int64 to double doesn't work on all platforms.
    1:   // We need to truncate the value at LL_MAXINT to make sure we don't
    1:   // overflow.
    1:   if (LL_CMP(bytes, >, LL_MAXINT))
    1:     bytes = LL_MAXINT;
    1: 
    1:   PRUint64 kbytes;
    1:   LL_SHR(kbytes, bytes, 10);
    1: 
    1:   double kBytesD;
    1:   LL_L2D(kBytesD, (PRInt64) kbytes);
    1: 
    1:   // This is essentially the same calculation as for nsCacheService,
    1:   // except that we divide the final memory calculation by 4, since
    1:   // we assume each ContentViewer takes on average 4MB
    1:   PRUint32 viewers = 0;
    1:   double x = log(kBytesD)/log(2.0) - 14;
    1:   if (x > 0) {
    1:     viewers    = (PRUint32)(x * x - x + 2.001); // add .001 for rounding
    1:     viewers   /= 4;
    1:   }
    1: 
    1:   // Cap it off at 8 max
    1:   if (viewers > 8) {
    1:     viewers = 8;
    1:   }
    1:   return viewers;
    1: }
    1: 
    1: // static
41722: void
72449: nsSHistory::UpdatePrefs()
41722: {
72449:   Preferences::GetInt(PREF_SHISTORY_SIZE, &gHistoryMaxSize);
72449:   Preferences::GetInt(PREF_SHISTORY_MAX_TOTAL_VIEWERS,
41722:                       &sHistoryMaxTotalViewers);
80309:   Preferences::GetBool(PREF_SHISTORY_OPTIMIZE_EVICTION, &gOptimizeEviction);
41722:   // If the pref is negative, that means we calculate how many viewers
41722:   // we think we should cache, based on total memory
41722:   if (sHistoryMaxTotalViewers < 0) {
41722:     sHistoryMaxTotalViewers = CalcMaxTotalViewers();
41722:   }
41722: }
41722: 
41722: // static
    1: nsresult
    1: nsSHistory::Startup()
    1: {
72449:   UpdatePrefs();
12138: 
    1:   // The goal of this is to unbreak users who have inadvertently set their
12138:   // session history size to less than the default value.
72449:   PRInt32 defaultHistoryMaxSize =
72449:     Preferences::GetDefaultInt(PREF_SHISTORY_SIZE, 50);
12138:   if (gHistoryMaxSize < defaultHistoryMaxSize) {
12138:     gHistoryMaxSize = defaultHistoryMaxSize;
    1:   }
    1:   
    1:   // Allow the user to override the max total number of cached viewers,
    1:   // but keep the per SHistory cached viewer limit constant
72449:   if (!gObserver) {
72449:     gObserver = new nsSHistoryObserver();
72449:     NS_ADDREF(gObserver);
72449:     Preferences::AddStrongObservers(gObserver, kObservedPrefs);
    1: 
    1:     nsCOMPtr<nsIObserverService> obsSvc =
41540:       mozilla::services::GetObserverService();
    1:     if (obsSvc) {
    1:       // Observe empty-cache notifications so tahat clearing the disk/memory
    1:       // cache will also evict all content viewers.
72449:       obsSvc->AddObserver(gObserver,
    1:                           NS_CACHESERVICE_EMPTYCACHE_TOPIC_ID, PR_FALSE);
    1: 
    1:       // Same for memory-pressure notifications
72449:       obsSvc->AddObserver(gObserver, "memory-pressure", PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   // Initialize the global list of all SHistory objects
    1:   PR_INIT_CLIST(&gSHistoryList);
    1:   return NS_OK;
    1: }
    1: 
72449: // static
72449: void
72449: nsSHistory::Shutdown()
72449: {
72449:   if (gObserver) {
72449:     Preferences::RemoveObservers(gObserver, kObservedPrefs);
72449:     nsCOMPtr<nsIObserverService> obsSvc =
72449:       mozilla::services::GetObserverService();
72449:     if (obsSvc) {
72449:       obsSvc->RemoveObserver(gObserver, NS_CACHESERVICE_EMPTYCACHE_TOPIC_ID);
72449:       obsSvc->RemoveObserver(gObserver, "memory-pressure");
72449:     }
72449:     NS_RELEASE(gObserver);
72449:   }
72449: }
72449: 
    1: /* Add an entry to the History list at mIndex and 
    1:  * increment the index to point to the new entry
    1:  */
    1: NS_IMETHODIMP
79445: nsSHistory::AddEntry(nsISHEntry * aSHEntry, bool aPersist)
    1: {
    1:   NS_ENSURE_ARG(aSHEntry);
    1: 
    1:   nsCOMPtr<nsISHTransaction> currentTxn;
    1: 
    1:   if(mListRoot)
    1:     GetTransactionAtIndex(mIndex, getter_AddRefs(currentTxn));
    1: 
79445:   bool currentPersist = true;
    1:   if(currentTxn)
    1:     currentTxn->GetPersist(&currentPersist);
    1: 
    1:   if(!currentPersist)
    1:   {
    1:     NS_ENSURE_SUCCESS(currentTxn->SetSHEntry(aSHEntry),NS_ERROR_FAILURE);
    1:     currentTxn->SetPersist(aPersist);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsISHTransaction> txn(do_CreateInstance(NS_SHTRANSACTION_CONTRACTID));
    1:   NS_ENSURE_TRUE(txn, NS_ERROR_FAILURE);
    1: 
    1:   // Notify any listener about the new addition
    1:   if (mListener) {
    1:     nsCOMPtr<nsISHistoryListener> listener(do_QueryReferent(mListener));
    1:     if (listener) {
    1:       nsCOMPtr<nsIURI> uri;
    1:       nsCOMPtr<nsIHistoryEntry> hEntry(do_QueryInterface(aSHEntry));
    1:       if (hEntry) {
    1:         PRInt32 currentIndex = mIndex;
    1:         hEntry->GetURI(getter_AddRefs(uri));
    1:         listener->OnHistoryNewEntry(uri);
    1: 
    1:         // If a listener has changed mIndex, we need to get currentTxn again,
    1:         // otherwise we'll be left at an inconsistent state (see bug 320742)
    1:         if (currentIndex != mIndex)
    1:           GetTransactionAtIndex(mIndex, getter_AddRefs(currentTxn));
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Set the ShEntry and parent for the transaction. setting the 
    1:   // parent will properly set the parent child relationship
    1:   txn->SetPersist(aPersist);
    1:   NS_ENSURE_SUCCESS(txn->Create(aSHEntry, currentTxn), NS_ERROR_FAILURE);
    1:    
    1:   // A little tricky math here...  Basically when adding an object regardless of
    1:   // what the length was before, it should always be set back to the current and
    1:   // lop off the forward.
    1:   mLength = (++mIndex + 1);
    1: 
    1:   // If this is the very first transaction, initialize the list
    1:   if(!mListRoot)
    1:     mListRoot = txn;
    1: 
    1:   // Purge History list if it is too long
    1:   if ((gHistoryMaxSize >= 0) && (mLength > gHistoryMaxSize))
    1:     PurgeHistory(mLength-gHistoryMaxSize);
    1:   
50721:   RemoveDynEntries(mIndex - 1, mIndex);
    1:   return NS_OK;
    1: }
    1: 
    1: /* Get size of the history list */
    1: NS_IMETHODIMP
    1: nsSHistory::GetCount(PRInt32 * aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1:   *aResult = mLength;
    1:   return NS_OK;
    1: }
    1: 
    1: /* Get index of the history list */
    1: NS_IMETHODIMP
    1: nsSHistory::GetIndex(PRInt32 * aResult)
    1: {
    1:   NS_PRECONDITION(aResult, "null out param?");
    1:   *aResult = mIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: /* Get the requestedIndex */
    1: NS_IMETHODIMP
    1: nsSHistory::GetRequestedIndex(PRInt32 * aResult)
    1: {
    1:   NS_PRECONDITION(aResult, "null out param?");
    1:   *aResult = mRequestedIndex;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsSHistory::GetEntryAtIndex(PRInt32 aIndex, bool aModifyIndex, nsISHEntry** aResult)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsISHTransaction> txn;
    1: 
    1:   /* GetTransactionAtIndex ensures aResult is valid and validates aIndex */
    1:   rv = GetTransactionAtIndex(aIndex, getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(rv) && txn) {
    1:     //Get the Entry from the transaction
    1:     rv = txn->GetSHEntry(aResult);
    1:     if (NS_SUCCEEDED(rv) && (*aResult)) {
    1:       // Set mIndex to the requested index, if asked to do so..
    1:       if (aModifyIndex) {
    1:         mIndex = aIndex;
    1:       }
    1:     } //entry
    1:   }  //Transaction
    1:   return rv;
    1: }
    1: 
    1: 
    1: /* Get the entry at a given index */
    1: NS_IMETHODIMP
79445: nsSHistory::GetEntryAtIndex(PRInt32 aIndex, bool aModifyIndex, nsIHistoryEntry** aResult)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsISHEntry> shEntry;
    1:   rv = GetEntryAtIndex(aIndex, aModifyIndex, getter_AddRefs(shEntry));
    1:   if (NS_SUCCEEDED(rv) && shEntry) 
    1:     rv = CallQueryInterface(shEntry, aResult);
    1:  
    1:   return rv;
    1: }
    1: 
    1: /* Get the transaction at a given index */
    1: NS_IMETHODIMP
    1: nsSHistory::GetTransactionAtIndex(PRInt32 aIndex, nsISHTransaction ** aResult)
    1: {
    1:   nsresult rv;
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   if ((mLength <= 0) || (aIndex < 0) || (aIndex >= mLength))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!mListRoot) 
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (aIndex == 0)
    1:   {
    1:     *aResult = mListRoot;
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1:   } 
    1:   PRInt32   cnt=0;
    1:   nsCOMPtr<nsISHTransaction>  tempPtr;
    1: 
    1:   rv = GetRootTransaction(getter_AddRefs(tempPtr));
    1:   if (NS_FAILED(rv) || !tempPtr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   while(1) {
    1:     nsCOMPtr<nsISHTransaction> ptr;
    1:     rv = tempPtr->GetNext(getter_AddRefs(ptr));
    1:     if (NS_SUCCEEDED(rv) && ptr) {
    1:       cnt++;
    1:       if (cnt == aIndex) {
    1:         *aResult = ptr;
    1:         NS_ADDREF(*aResult);
    1:         break;
    1:       }
    1:       else {
    1:         tempPtr = ptr;
    1:         continue;
    1:       }
    1:     }  //NS_SUCCEEDED
    1:     else 
    1:       return NS_ERROR_FAILURE;
    1:   }  // while 
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef DEBUG
    1: nsresult
    1: nsSHistory::PrintHistory()
    1: {
    1: 
    1:   nsCOMPtr<nsISHTransaction>   txn;
    1:   PRInt32 index = 0;
    1:   nsresult rv;
    1: 
    1:   if (!mListRoot) 
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   txn = mListRoot;
    1:     
    1:   while (1) {
    1:     if (!txn)
    1:       break;
    1:     nsCOMPtr<nsISHEntry>  entry;
    1:     rv = txn->GetSHEntry(getter_AddRefs(entry));
    1:     if (NS_FAILED(rv) && !entry)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsILayoutHistoryState> layoutHistoryState;
    1:     nsCOMPtr<nsIURI>  uri;
    1:     nsXPIDLString title;
    1: 
    1:     entry->GetLayoutHistoryState(getter_AddRefs(layoutHistoryState));
    1:     nsCOMPtr<nsIHistoryEntry> hEntry(do_QueryInterface(entry));
    1:     if (hEntry) {
    1:       hEntry->GetURI(getter_AddRefs(uri));
    1:       hEntry->GetTitle(getter_Copies(title));              
    1:     }
    1: 
    1: #if 0
    1:     nsCAutoString url;
    1:     if (uri)
    1:      uri->GetSpec(url);
    1: 
    1:     printf("**** SH Transaction #%d, Entry = %x\n", index, entry.get());
37802:     printf("\t\t URL = %s\n", url.get());
37802: 
    1:     printf("\t\t Title = %s\n", NS_LossyConvertUTF16toASCII(title).get());
37802:     printf("\t\t layout History Data = %x\n", layoutHistoryState.get());
    1: #endif
    1: 
    1:     nsCOMPtr<nsISHTransaction> next;
    1:     rv = txn->GetNext(getter_AddRefs(next));
    1:     if (NS_SUCCEEDED(rv) && next) {
    1:       txn = next;
    1:       index++;
    1:       continue;
    1:     }
    1:     else
    1:       break;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GetRootTransaction(nsISHTransaction ** aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1:   *aResult=mListRoot;
    1:   NS_IF_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: /* Get the max size of the history list */
    1: NS_IMETHODIMP
    1: nsSHistory::GetMaxLength(PRInt32 * aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1:   *aResult = gHistoryMaxSize;
    1:   return NS_OK;
    1: }
    1: 
    1: /* Set the max size of the history list */
    1: NS_IMETHODIMP
    1: nsSHistory::SetMaxLength(PRInt32 aMaxSize)
    1: {
    1:   if (aMaxSize < 0)
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:   gHistoryMaxSize = aMaxSize;
    1:   if (mLength > aMaxSize)
    1:     PurgeHistory(mLength-aMaxSize);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::PurgeHistory(PRInt32 aEntries)
    1: {
    1:   if (mLength <= 0 || aEntries <= 0)
    1:     return NS_ERROR_FAILURE;
    1: 
38012:   aEntries = NS_MIN(aEntries, mLength);
    1:   
79445:   bool purgeHistory = true;
    1:   // Notify the listener about the history purge
    1:   if (mListener) {
    1:     nsCOMPtr<nsISHistoryListener> listener(do_QueryReferent(mListener));
    1:     if (listener) {
    1:       listener->OnHistoryPurge(aEntries, &purgeHistory);
    1:     } 
    1:   }
    1: 
    1:   if (!purgeHistory) {
    1:     // Listener asked us not to purge
    1:     return NS_SUCCESS_LOSS_OF_INSIGNIFICANT_DATA;
    1:   }
    1: 
    1:   PRInt32 cnt = 0;
    1:   while (cnt < aEntries) {
    1:     nsCOMPtr<nsISHTransaction> nextTxn;
58253:     if (mListRoot) {
    1:       mListRoot->GetNext(getter_AddRefs(nextTxn));
58253:       mListRoot->SetNext(nsnull);
58253:     }
    1:     mListRoot = nextTxn;
58253:     if (mListRoot) {
58253:       mListRoot->SetPrev(nsnull);
58253:     }
    1:     cnt++;        
    1:   }
    1:   mLength -= cnt;
    1:   mIndex -= cnt;
    1: 
    1:   // Now if we were not at the end of the history, mIndex could have
    1:   // become far too negative.  If so, just set it to -1.
    1:   if (mIndex < -1) {
    1:     mIndex = -1;
    1:   }
    1: 
19870:   if (mRootDocShell)
19870:     mRootDocShell->HistoryPurged(cnt);
19870: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::AddSHistoryListener(nsISHistoryListener * aListener)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aListener);
    1: 
    1:   // Check if the listener supports Weak Reference. This is a must.
    1:   // This listener functionality is used by embedders and we want to 
    1:   // have the right ownership with who ever listens to SHistory
    1:   nsWeakPtr listener = do_GetWeakReference(aListener);
    1:   if (!listener) return NS_ERROR_FAILURE;
    1:   mListener = listener;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::RemoveSHistoryListener(nsISHistoryListener * aListener)
    1: {
    1:   // Make sure the listener that wants to be removed is the
    1:   // one we have in store. 
    1:   nsWeakPtr listener = do_GetWeakReference(aListener);  
    1:   if (listener == mListener) {
    1:     mListener = nsnull;
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: /* Replace an entry in the History list at a particular index.
    1:  * Do not update index or count.
    1:  */
    1: NS_IMETHODIMP
    1: nsSHistory::ReplaceEntry(PRInt32 aIndex, nsISHEntry * aReplaceEntry)
    1: {
    1:   NS_ENSURE_ARG(aReplaceEntry);
    1:   nsresult rv;
    1:   nsCOMPtr<nsISHTransaction> currentTxn;
    1: 
    1:   if (!mListRoot) // Session History is not initialised.
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   rv = GetTransactionAtIndex(aIndex, getter_AddRefs(currentTxn));
    1: 
    1:   if(currentTxn)
    1:   {
    1:     // Set the replacement entry in the transaction
    1:     rv = currentTxn->SetSHEntry(aReplaceEntry);
    1:     rv = currentTxn->SetPersist(PR_TRUE);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: /* Get a handle to the Session history listener */
    1: NS_IMETHODIMP
    1: nsSHistory::GetListener(nsISHistoryListener ** aListener)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aListener);
    1:   if (mListener) 
    1:     CallQueryReferent(mListener.get(),  aListener);
    1:   // Don't addref aListener. It is a weak pointer.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
80309: nsSHistory::EvictContentViewers(PRInt32 aPreviousIndex, PRInt32 aIndex)
    1: {
19870:   // Check our per SHistory object limit in the currently navigated SHistory
80309:   EvictWindowContentViewers(aPreviousIndex, aIndex);
    1:   // Check our total limit across all SHistory objects
80309:   EvictGlobalContentViewer();
    1:   return NS_OK;
    1: }
    1: 
23620: NS_IMETHODIMP
23620: nsSHistory::EvictAllContentViewers()
23620: {
23620:   // XXXbz we don't actually do a good job of evicting things as we should, so
23620:   // we might have viewers quite far from mIndex.  So just evict everything.
80309:   EvictContentViewersInRange(0, mLength);
23620:   return NS_OK;
23620: }
23620: 
23620: 
23620: 
    1: //*****************************************************************************
    1: //    nsSHistory: nsIWebNavigation
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
79445: nsSHistory::GetCanGoBack(bool * aCanGoBack)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCanGoBack);
    1:   *aCanGoBack = PR_FALSE;
    1: 
    1:   PRInt32 index = -1;
    1:   NS_ENSURE_SUCCESS(GetIndex(&index), NS_ERROR_FAILURE);
    1:   if(index > 0)
    1:      *aCanGoBack = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsSHistory::GetCanGoForward(bool * aCanGoForward)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCanGoForward);
    1:   *aCanGoForward = PR_FALSE;
    1: 
    1:   PRInt32 index = -1;
    1:   PRInt32 count = -1;
    1: 
    1:   NS_ENSURE_SUCCESS(GetIndex(&index), NS_ERROR_FAILURE);
    1:   NS_ENSURE_SUCCESS(GetCount(&count), NS_ERROR_FAILURE);
    1: 
    1:   if((index >= 0) && (index < (count - 1)))
    1:     *aCanGoForward = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GoBack()
    1: {
79445:   bool canGoBack = false;
    1: 
    1:   GetCanGoBack(&canGoBack);
    1:   if (!canGoBack)  // Can't go back
    1:     return NS_ERROR_UNEXPECTED;
    1:   return LoadEntry(mIndex-1, nsIDocShellLoadInfo::loadHistory, HIST_CMD_BACK);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GoForward()
    1: {
79445:   bool canGoForward = false;
    1: 
    1:   GetCanGoForward(&canGoForward);
    1:   if (!canGoForward)  // Can't go forward
    1:     return NS_ERROR_UNEXPECTED;
    1:   return LoadEntry(mIndex+1, nsIDocShellLoadInfo::loadHistory, HIST_CMD_FORWARD);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::Reload(PRUint32 aReloadFlags)
    1: {
    1:   nsresult rv;
    1:   nsDocShellInfoLoadType loadType;
    1:   if (aReloadFlags & nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY && 
    1:       aReloadFlags & nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE)
    1:   {
    1:     loadType = nsIDocShellLoadInfo::loadReloadBypassProxyAndCache;
    1:   }
    1:   else if (aReloadFlags & nsIWebNavigation::LOAD_FLAGS_BYPASS_PROXY)
    1:   {
    1:     loadType = nsIDocShellLoadInfo::loadReloadBypassProxy;
    1:   }
    1:   else if (aReloadFlags & nsIWebNavigation::LOAD_FLAGS_BYPASS_CACHE)
    1:   {
    1:     loadType = nsIDocShellLoadInfo::loadReloadBypassCache;
    1:   }
    1:   else if (aReloadFlags & nsIWebNavigation::LOAD_FLAGS_CHARSET_CHANGE)
    1:   {
    1:     loadType = nsIDocShellLoadInfo::loadReloadCharsetChange;
    1:   }
    1:   else
    1:   {
    1:     loadType = nsIDocShellLoadInfo::loadReloadNormal;
    1:   }
    1:   
    1:   // Notify listeners
79445:   bool canNavigate = true;
    1:   if (mListener) {
    1:     nsCOMPtr<nsISHistoryListener> listener(do_QueryReferent(mListener));
    1:     // We are reloading. Send Reload notifications. 
    1:     // nsDocShellLoadFlagType is not public, where as nsIWebNavigation
    1:     // is public. So send the reload notifications with the
    1:     // nsIWebNavigation flags. 
    1:     if (listener) {
    1:       nsCOMPtr<nsIURI> currentURI;
    1:       rv = GetCurrentURI(getter_AddRefs(currentURI));
    1:       listener->OnHistoryReload(currentURI, aReloadFlags, &canNavigate);
    1:     }
    1:   }
    1:   if (!canNavigate)
    1:     return NS_OK;
    1: 
    1:   return LoadEntry(mIndex, loadType, HIST_CMD_RELOAD);
    1: }
    1: 
59694: NS_IMETHODIMP
59694: nsSHistory::ReloadCurrentEntry()
59694: {
59694:   // Notify listeners
79445:   bool canNavigate = true;
59694:   if (mListener) {
59694:     nsCOMPtr<nsISHistoryListener> listener(do_QueryReferent(mListener));
59694:     if (listener) {
59694:       nsCOMPtr<nsIURI> currentURI;
59694:       GetCurrentURI(getter_AddRefs(currentURI));
59694:       listener->OnHistoryGotoIndex(mIndex, currentURI, &canNavigate);
59694:     }
59694:   }
59694:   if (!canNavigate)
59694:     return NS_OK;
59694: 
59694:   return LoadEntry(mIndex, nsIDocShellLoadInfo::loadHistory, HIST_CMD_RELOAD);
59694: }
59694: 
    1: void
80309: nsSHistory::EvictWindowContentViewers(PRInt32 aFromIndex, PRInt32 aToIndex)
    1: {
80309:   // To enforce the per SHistory object limit on cached content viewers, we
80309:   // need to release all of the content viewers that are no longer in the
80309:   // "window" that now ends/begins at aToIndex.  Existing content viewers
80309:   // should be in the window from
80309:   // aFromIndex - gHistoryMaxViewers to aFromIndex + gHistoryMaxViewers
80309:   //
80309:   // We make the assumption that entries outside this range have no viewers so
80309:   // that we don't have to walk the whole entire session history checking for
80309:   // content viewers.
74985: 
80309:   // This can happen on the first load of a page in a particular window
80309:   if (aFromIndex < 0 || aToIndex < 0) {
    1:     return;
    1:   }
80309:   NS_ASSERTION(aFromIndex < mLength, "aFromIndex is out of range");
80309:   NS_ASSERTION(aToIndex < mLength, "aToIndex is out of range");
80309:   if (aFromIndex >= mLength || aToIndex >= mLength) {
12713:     return;
12713:   }
    1: 
80309:   // These indices give the range of SHEntries whose content viewers will be
80309:   // evicted
80309:   PRInt32 startIndex, endIndex;
80309:   if (aToIndex > aFromIndex) { // going forward
80309:     endIndex = aToIndex - gHistoryMaxViewers;
80309:     if (endIndex <= 0) {
80309:       return;
80309:     }
80309:     startIndex = NS_MAX(0, aFromIndex - gHistoryMaxViewers);
80309:   } else { // going backward
80309:     startIndex = aToIndex + gHistoryMaxViewers + 1;
80309:     if (startIndex >= mLength) {
80309:       return;
80309:     }
80309:     endIndex = NS_MIN(mLength, aFromIndex + gHistoryMaxViewers + 1);
    1:   }
    1: 
80309: #ifdef DEBUG
80309:   nsCOMPtr<nsISHTransaction> trans;
 8115:   GetTransactionAtIndex(0, getter_AddRefs(trans));
80309: 
80309:   // Walk the full session history and check that entries outside the window
80309:   // around aFromIndex have no content viewers
80309:   for (PRInt32 i = 0; trans && i < mLength; ++i) {
80309:     if (i < aFromIndex - gHistoryMaxViewers || 
80309:         i > aFromIndex + gHistoryMaxViewers) {
80309:       nsCOMPtr<nsISHEntry> entry;
80309:       trans->GetSHEntry(getter_AddRefs(entry));
80309:       nsCOMPtr<nsIContentViewer> viewer;
80309:       nsCOMPtr<nsISHEntry> ownerEntry;
80309:       entry->GetAnyContentViewer(getter_AddRefs(ownerEntry),
80309:                                  getter_AddRefs(viewer));
80309:       NS_WARN_IF_FALSE(!viewer,
80309:                        "ContentViewer exists outside gHistoryMaxViewer range");
 8115:     }
 8115: 
 8115:     nsISHTransaction *temp = trans;
 8115:     temp->GetNext(getter_AddRefs(trans));
 8115:   }
80309: #endif
80309: 
80309:   EvictContentViewersInRange(startIndex, endIndex);
 6187: }
 6187: 
80309: void
80309: nsSHistory::EvictContentViewersInRange(PRInt32 aStart, PRInt32 aEnd)
80309: {
80309:   nsCOMPtr<nsISHTransaction> trans;
80309:   GetTransactionAtIndex(aStart, getter_AddRefs(trans));
74985: 
80309:   for (PRInt32 i = aStart; trans && i < aEnd; ++i) {
80309:     nsCOMPtr<nsISHEntry> entry;
80309:     trans->GetSHEntry(getter_AddRefs(entry));
80309:     nsCOMPtr<nsIContentViewer> viewer;
80309:     nsCOMPtr<nsISHEntry> ownerEntry;
80309:     entry->GetAnyContentViewer(getter_AddRefs(ownerEntry),
80309:                                getter_AddRefs(viewer));
80309:     if (viewer) {
80309:       NS_ASSERTION(ownerEntry,
80309:                    "ContentViewer exists but its SHEntry is null");
80309: #ifdef DEBUG_PAGE_CACHE
80309:       nsCOMPtr<nsIURI> uri;
80309:       ownerEntry->GetURI(getter_AddRefs(uri));
80309:       nsCAutoString spec;
80309:       if (uri)
80309:         uri->GetSpec(spec);
74985: 
80309:       printf("per SHistory limit: evicting content viewer: %s\n", spec.get());
80309: #endif
74985: 
80309:       // Drop the presentation state before destroying the viewer, so that
80309:       // document teardown is able to correctly persist the state.
80309:       ownerEntry->SetContentViewer(nsnull);
80309:       ownerEntry->SyncPresentationState();
80309:       viewer->Destroy();
74985:     }
74985: 
80309:     nsISHTransaction *temp = trans;
80309:     temp->GetNext(getter_AddRefs(trans));
74985:   }
74985: }
74985: 
74985: // static
74725: void
80309: nsSHistory::EvictGlobalContentViewer()
74725: {
80309:   // true until the total number of content viewers is <= total max
80309:   // The usual case is that we only need to evict one content viewer.
80309:   // However, if somebody resets the pref value, we might occasionally
80309:   // need to evict more than one.
80309:   PRBool shouldTryEviction = PR_TRUE;
80309:   while (shouldTryEviction) {
80309:     // Walk through our list of SHistory objects, looking for content
80309:     // viewers in the possible active window of all of the SHEntry objects.
80309:     // Keep track of the SHEntry object that has a ContentViewer and is
80309:     // farthest from the current focus in any SHistory object.  The
80309:     // ContentViewer associated with that SHEntry will be evicted
80309:     PRInt32 distanceFromFocus = 0;
80309:     PRUint32 candidateLastTouched = 0;
80309:     nsCOMPtr<nsISHEntry> evictFromSHE;
80309:     nsCOMPtr<nsIContentViewer> evictViewer;
80309:     PRInt32 totalContentViewers = 0;
80309:     nsSHistory* shist = static_cast<nsSHistory*>
80309:                                    (PR_LIST_HEAD(&gSHistoryList));
74985:     while (shist != &gSHistoryList) {
80309:       // Calculate the window of SHEntries that could possibly have a content
80309:       // viewer.  There could be up to gHistoryMaxViewers content viewers,
80309:       // but we don't know whether they are before or after the mIndex position
80309:       // in the SHEntry list.  Just check both sides, to be safe.
74985:       PRInt32 startIndex = NS_MAX(0, shist->mIndex - gHistoryMaxViewers);
74985:       PRInt32 endIndex = NS_MIN(shist->mLength - 1,
74985:                                 shist->mIndex + gHistoryMaxViewers);
74725:       nsCOMPtr<nsISHTransaction> trans;
74985:       shist->GetTransactionAtIndex(startIndex, getter_AddRefs(trans));
74716: 
80309:       for (PRInt32 i = startIndex; trans && i <= endIndex; ++i) {
80309:         nsCOMPtr<nsISHEntry> entry;
80309:         trans->GetSHEntry(getter_AddRefs(entry));
80309:         nsCOMPtr<nsIContentViewer> viewer;
80309:         nsCOMPtr<nsISHEntry> ownerEntry;
80309:         entry->GetAnyContentViewer(getter_AddRefs(ownerEntry),
80309:                                    getter_AddRefs(viewer));
80309: 
80309:         PRUint32 entryLastTouched = 0;
80309:         if (gOptimizeEviction) {
80309:           nsCOMPtr<nsISHEntryInternal> entryInternal = do_QueryInterface(entry);
80309:           if (entryInternal) {
80309:             // Find when this entry was last activated
80309:             entryInternal->GetLastTouched(&entryLastTouched);
74985:           }
74985:         }
74716: 
80309: #ifdef DEBUG_PAGE_CACHE
80309:         nsCOMPtr<nsIURI> uri;
80309:         if (ownerEntry) {
80309:           ownerEntry->GetURI(getter_AddRefs(uri));
80309:         } else {
80309:           entry->GetURI(getter_AddRefs(uri));
74985:         }
80309:         nsCAutoString spec;
80309:         if (uri) {
80309:           uri->GetSpec(spec);
80309:           printf("Considering for eviction: %s\n", spec.get());
74716:         }
80309: #endif
74716:         
80309:         // This SHEntry has a ContentViewer, so check how far away it is from
80309:         // the currently used SHEntry within this SHistory object
80309:         if (viewer) {
80309:           PRInt32 distance = NS_ABS(shist->mIndex - i);
80309:           
80309: #ifdef DEBUG_PAGE_CACHE
80309:           printf("Has a cached content viewer: %s\n", spec.get());
80309:           printf("mIndex: %d i: %d\n", shist->mIndex, i);
80309: #endif
80309:           totalContentViewers++;
80309: 
80309:           // If this entry is further away from focus than any previously found
80309:           // or at the same distance but it is longer time since it was activated
80309:           // then take this entry as the new candiate for eviction
80309:           if (distance > distanceFromFocus || (distance == distanceFromFocus && candidateLastTouched > entryLastTouched)) {
80309: 
80309: #ifdef DEBUG_PAGE_CACHE
80309:             printf("Choosing as new eviction candidate: %s\n", spec.get());
80309: #endif
80309:             candidateLastTouched = entryLastTouched;
80309:             distanceFromFocus = distance;
80309:             evictFromSHE = ownerEntry;
80309:             evictViewer = viewer;
80309:           }
80309:         }
74725:         nsISHTransaction* temp = trans;
74725:         temp->GetNext(getter_AddRefs(trans));
74716:       }
 3233:       shist = static_cast<nsSHistory*>(PR_NEXT_LINK(shist));
    1:     }
    1: 
80309: #ifdef DEBUG_PAGE_CACHE
80309:     printf("Distance from focus: %d\n", distanceFromFocus);
80309:     printf("Total max viewers: %d\n", sHistoryMaxTotalViewers);
80309:     printf("Total number of viewers: %d\n", totalContentViewers);
80309: #endif
80309: 
80309:     if (totalContentViewers > sHistoryMaxTotalViewers && evictViewer) {
80309: #ifdef DEBUG_PAGE_CACHE
80309:       nsCOMPtr<nsIURI> uri;
80309:       evictFromSHE->GetURI(getter_AddRefs(uri));
80309:       nsCAutoString spec;
80309:       if (uri) {
80309:         uri->GetSpec(spec);
80309:         printf("Evicting content viewer: %s\n", spec.get());
80309:       }
80309: #endif
80309: 
80309:       // Drop the presentation state before destroying the viewer, so that
80309:       // document teardown is able to correctly persist the state.
80309:       evictFromSHE->SetContentViewer(nsnull);
80309:       evictFromSHE->SyncPresentationState();
80309:       evictViewer->Destroy();
80309: 
80309:       // If we only needed to evict one content viewer, then we are done.
80309:       // Otherwise, continue evicting until we reach the max total limit.
80309:       if (totalContentViewers - sHistoryMaxTotalViewers == 1) {
80309:         shouldTryEviction = PR_FALSE;
80309:       }
80309:     } else {
80309:       // couldn't find a content viewer to evict, so we are done
80309:       shouldTryEviction = PR_FALSE;
80309:     }
80309:   }  // while shouldTryEviction
74985: }
74725: 
80309: NS_IMETHODIMP
80309: nsSHistory::EvictExpiredContentViewerForEntry(nsISHEntry *aEntry)
 6187: {
38012:   PRInt32 startIndex = NS_MAX(0, mIndex - gHistoryMaxViewers);
38012:   PRInt32 endIndex = NS_MIN(mLength - 1,
 6187:                             mIndex + gHistoryMaxViewers);
 6187:   nsCOMPtr<nsISHTransaction> trans;
 6187:   GetTransactionAtIndex(startIndex, getter_AddRefs(trans));
 6187: 
 6187:   PRInt32 i;
72313:   for (i = startIndex; trans && i <= endIndex; ++i) {
 6187:     nsCOMPtr<nsISHEntry> entry;
 6187:     trans->GetSHEntry(getter_AddRefs(entry));
80309:     if (entry == aEntry)
 6187:       break;
 6187: 
 6187:     nsISHTransaction *temp = trans;
 6187:     temp->GetNext(getter_AddRefs(trans));
 6187:   }
 6187:   if (i > endIndex)
 6187:     return NS_OK;
 6187:   
80309:   NS_ASSERTION(i != mIndex, "How did the current session entry expire?");
80309:   if (i == mIndex)
 6187:     return NS_OK;
80309:   
80309:   // We evict content viewers for the expired entry and any other entries that
80309:   // we would have to go through the expired entry to get to (i.e. the entries
80309:   // that have the expired entry between them and the current entry). Those
80309:   // other entries should have timed out already, actually, but this is just
80309:   // to be on the safe side.
80309:   if (i < mIndex) {
80309:     EvictContentViewersInRange(startIndex, i + 1);
80309:   } else {
80309:     EvictContentViewersInRange(i, endIndex + 1);
74985:   }
74725:   
 6187:   return NS_OK;
 6187: }
 6187: 
    1: // Evicts all content viewers in all history objects.  This is very
    1: // inefficient, because it requires a linear search through all SHistory
    1: // objects for each viewer to be evicted.  However, this method is called
    1: // infrequently -- only when the disk or memory cache is cleared.
    1: 
    1: //static
    1: void
80309: nsSHistory::EvictAllContentViewersGlobally()
    1: {
    1:   PRInt32 maxViewers = sHistoryMaxTotalViewers;
    1:   sHistoryMaxTotalViewers = 0;
80309:   EvictGlobalContentViewer();
    1:   sHistoryMaxTotalViewers = maxViewers;
    1: }
    1: 
50721: void GetDynamicChildren(nsISHContainer* aContainer,
50721:                         nsTArray<PRUint64>& aDocshellIDs,
79445:                         bool aOnlyTopLevelDynamic)
50721: {
50721:   PRInt32 count = 0;
50721:   aContainer->GetChildCount(&count);
50721:   for (PRInt32 i = 0; i < count; ++i) {
50721:     nsCOMPtr<nsISHEntry> child;
50721:     aContainer->GetChildAt(i, getter_AddRefs(child));
50721:     if (child) {
79445:       bool dynAdded = false;
50721:       child->IsDynamicallyAdded(&dynAdded);
50721:       if (dynAdded) {
50721:         PRUint64 docshellID = 0;
50721:         child->GetDocshellID(&docshellID);
50721:         aDocshellIDs.AppendElement(docshellID);
50721:       }
50721:       if (!dynAdded || !aOnlyTopLevelDynamic) {
50721:         nsCOMPtr<nsISHContainer> childAsContainer = do_QueryInterface(child);
50721:         if (childAsContainer) {
50721:           GetDynamicChildren(childAsContainer, aDocshellIDs,
50721:                              aOnlyTopLevelDynamic);
50721:         }
50721:       }
50721:     }
50721:   }
50721: }
50721: 
79445: bool
50721: RemoveFromSessionHistoryContainer(nsISHContainer* aContainer,
50721:                                   nsTArray<PRUint64>& aDocshellIDs)
50721: {
50721:   nsCOMPtr<nsISHEntry> root = do_QueryInterface(aContainer);
50721:   NS_ENSURE_TRUE(root, PR_FALSE);
50721: 
79445:   bool didRemove = false;
50721:   PRInt32 childCount = 0;
50721:   aContainer->GetChildCount(&childCount);
50721:   for (PRInt32 i = childCount - 1; i >= 0; --i) {
50721:     nsCOMPtr<nsISHEntry> child;
50721:     aContainer->GetChildAt(i, getter_AddRefs(child));
50721:     if (child) {
50721:       PRUint64 docshelldID = 0;
50721:       child->GetDocshellID(&docshelldID);
50721:       if (aDocshellIDs.Contains(docshelldID)) {
50721:         didRemove = PR_TRUE;
50721:         aContainer->RemoveChild(child);
50721:       } else {
50721:         nsCOMPtr<nsISHContainer> container = do_QueryInterface(child);
50721:         if (container) {
79445:           bool childRemoved =
50721:             RemoveFromSessionHistoryContainer(container, aDocshellIDs);
50721:           if (childRemoved) {
50721:             didRemove = PR_TRUE;
50721:           }
50721:         }
50721:       }
50721:     }
50721:   }
50721:   return didRemove;
50721: }
50721: 
79445: bool RemoveChildEntries(nsISHistory* aHistory, PRInt32 aIndex,
50721:                           nsTArray<PRUint64>& aEntryIDs)
50721: {
50721:   nsCOMPtr<nsIHistoryEntry> rootHE;
50721:   aHistory->GetEntryAtIndex(aIndex, PR_FALSE, getter_AddRefs(rootHE));
50721:   nsCOMPtr<nsISHContainer> root = do_QueryInterface(rootHE);
50721:   return root ? RemoveFromSessionHistoryContainer(root, aEntryIDs) : PR_FALSE;
50721: }
50721: 
79445: bool IsSameTree(nsISHEntry* aEntry1, nsISHEntry* aEntry2)
52044: {
52044:   if (!aEntry1 && !aEntry2) {
52044:     return PR_TRUE;
52044:   }
52044:   if ((!aEntry1 && aEntry2) || (aEntry1 && !aEntry2)) {
52044:     return PR_FALSE;
52044:   }
52044:   PRUint32 id1, id2;
52044:   aEntry1->GetID(&id1);
52044:   aEntry2->GetID(&id2);
52044:   if (id1 != id2) {
52044:     return PR_FALSE;
52044:   }
52044: 
52044:   nsCOMPtr<nsISHContainer> container1 = do_QueryInterface(aEntry1);
52044:   nsCOMPtr<nsISHContainer> container2 = do_QueryInterface(aEntry2);
52044:   PRInt32 count1, count2;
52044:   container1->GetChildCount(&count1);
52044:   container2->GetChildCount(&count2);
52044:   // We allow null entries in the end of the child list.
71173:   PRInt32 count = NS_MAX(count1, count2);
52044:   for (PRInt32 i = 0; i < count; ++i) {
52044:     nsCOMPtr<nsISHEntry> child1, child2;
52044:     container1->GetChildAt(i, getter_AddRefs(child1));
52044:     container2->GetChildAt(i, getter_AddRefs(child2));
52044:     if (!IsSameTree(child1, child2)) {
52044:       return PR_FALSE;
52044:     }
52044:   }
52044:   
52044:   return PR_TRUE;
52044: }
52044: 
79445: bool
79445: nsSHistory::RemoveDuplicate(PRInt32 aIndex, bool aKeepNext)
52044: {
57503:   NS_ASSERTION(aIndex >= 0, "aIndex must be >= 0!");
77111:   NS_ASSERTION(aIndex != 0 || aKeepNext,
77111:                "If we're removing index 0 we must be keeping the next");
57503:   NS_ASSERTION(aIndex != mIndex, "Shouldn't remove mIndex!");
57503:   PRInt32 compareIndex = aKeepNext ? aIndex + 1 : aIndex - 1;
52044:   nsCOMPtr<nsIHistoryEntry> rootHE1, rootHE2;
52044:   GetEntryAtIndex(aIndex, PR_FALSE, getter_AddRefs(rootHE1));
57503:   GetEntryAtIndex(compareIndex, PR_FALSE, getter_AddRefs(rootHE2));
52044:   nsCOMPtr<nsISHEntry> root1 = do_QueryInterface(rootHE1);
52044:   nsCOMPtr<nsISHEntry> root2 = do_QueryInterface(rootHE2);
52044:   if (IsSameTree(root1, root2)) {
57503:     nsCOMPtr<nsISHTransaction> txToRemove, txToKeep, txNext, txPrev;
52044:     GetTransactionAtIndex(aIndex, getter_AddRefs(txToRemove));
57503:     GetTransactionAtIndex(compareIndex, getter_AddRefs(txToKeep));
52044:     NS_ENSURE_TRUE(txToRemove, PR_FALSE);
52044:     NS_ENSURE_TRUE(txToKeep, PR_FALSE);
52044:     txToRemove->GetNext(getter_AddRefs(txNext));
57503:     txToRemove->GetPrev(getter_AddRefs(txPrev));
52044:     txToRemove->SetNext(nsnull);
52044:     txToRemove->SetPrev(nsnull);
57503:     if (aKeepNext) {
57503:       if (txPrev) {
57503:         txPrev->SetNext(txToKeep);
57503:       } else {
57503:         txToKeep->SetPrev(nsnull);
57503:       }
57503:     } else {
52044:       txToKeep->SetNext(txNext);
57503:     }
57503: 
57503:     if (aIndex == 0 && aKeepNext) {
57503:       NS_ASSERTION(txToRemove == mListRoot,
57503:                    "Transaction at index 0 should be mListRoot!");
57503:       // We're removing the very first session history transaction!
57503:       mListRoot = txToKeep;
57503:     }
57894:     if (mRootDocShell) {
52044:       static_cast<nsDocShell*>(mRootDocShell)->HistoryTransactionRemoved(aIndex);
57894:     }
77111: 
77111:     // Adjust our indices to reflect the removed transaction
57503:     if (mIndex > aIndex) {
52044:       mIndex = mIndex - 1;
52044:     }
77111: 
77111:     // NB: If the transaction we are removing is the transaction currently
77111:     // being navigated to (mRequestedIndex) then we adjust the index
77111:     // only if we're not keeping the next entry (because if we are keeping
77111:     // the next entry (because the current is a duplicate of the next), then
77111:     // that entry slides into the spot that we're currently pointing to.
77111:     // We don't do this adjustment for mIndex because mIndex cannot equal
77111:     // aIndex.
77111: 
77111:     // NB: We don't need to guard on mRequestedIndex being nonzero here,
77111:     // because either they're strictly greater than aIndex which is at least
77111:     // zero, or they are equal to aIndex in which case aKeepNext must be true
77111:     // if aIndex is zero.
77111:     if (mRequestedIndex > aIndex || (mRequestedIndex == aIndex && !aKeepNext)) {
74685:       mRequestedIndex = mRequestedIndex - 1;
74685:     }
52044:     --mLength;
52044:     return PR_TRUE;
52044:   }
52044:   return PR_FALSE;
52044: }
52044: 
50721: NS_IMETHODIMP_(void)
50721: nsSHistory::RemoveEntries(nsTArray<PRUint64>& aIDs, PRInt32 aStartIndex)
50721: {
50721:   PRInt32 index = aStartIndex;
50721:   while(index >= 0 && RemoveChildEntries(this, --index, aIDs));
57503:   PRInt32 minIndex = index;
50721:   index = aStartIndex;
50721:   while(index >= 0 && RemoveChildEntries(this, index++, aIDs));
52044:   
52044:   // We need to remove duplicate nsSHEntry trees.
79445:   bool didRemove = false;
57503:   while (index > minIndex) {
57503:     if (index != mIndex) {
57503:       didRemove = RemoveDuplicate(index, index < mIndex) || didRemove;
57503:     }
57503:     --index;
52044:   }
52044:   if (didRemove && mRootDocShell) {
52044:     nsRefPtr<nsIRunnable> ev =
52044:       NS_NewRunnableMethod(static_cast<nsDocShell*>(mRootDocShell),
52044:                            &nsDocShell::FireDummyOnLocationChange);
52044:     NS_DispatchToCurrentThread(ev);
52044:   }
50721: }
50721: 
50721: void
50721: nsSHistory::RemoveDynEntries(PRInt32 aOldIndex, PRInt32 aNewIndex)
50721: {
50721:   // Search for the entries which are in the current index,
50721:   // but not in the new one.
50721:   nsCOMPtr<nsISHEntry> originalSH;
50721:   GetEntryAtIndex(aOldIndex, PR_FALSE, getter_AddRefs(originalSH));
50721:   nsCOMPtr<nsISHContainer> originalContainer = do_QueryInterface(originalSH);
50721:   nsAutoTArray<PRUint64, 16> toBeRemovedEntries;
50721:   if (originalContainer) {
50721:     nsTArray<PRUint64> originalDynDocShellIDs;
50721:     GetDynamicChildren(originalContainer, originalDynDocShellIDs, PR_TRUE);
50721:     if (originalDynDocShellIDs.Length()) {
50721:       nsCOMPtr<nsISHEntry> currentSH;
50721:       GetEntryAtIndex(aNewIndex, PR_FALSE, getter_AddRefs(currentSH));
50721:       nsCOMPtr<nsISHContainer> newContainer = do_QueryInterface(currentSH);
50721:       if (newContainer) {
50721:         nsTArray<PRUint64> newDynDocShellIDs;
50721:         GetDynamicChildren(newContainer, newDynDocShellIDs, PR_FALSE);
50721:         for (PRUint32 i = 0; i < originalDynDocShellIDs.Length(); ++i) {
50721:           if (!newDynDocShellIDs.Contains(originalDynDocShellIDs[i])) {
50721:             toBeRemovedEntries.AppendElement(originalDynDocShellIDs[i]);
50721:           }
50721:         }
50721:       }
50721:     }
50721:   }
50721:   if (toBeRemovedEntries.Length()) {
50721:     RemoveEntries(toBeRemovedEntries, aOldIndex);
50721:   }
50721: }
50721: 
    1: NS_IMETHODIMP
    1: nsSHistory::UpdateIndex()
    1: {
    1:   // Update the actual index with the right value. 
    1:   if (mIndex != mRequestedIndex && mRequestedIndex != -1) {
50721:     RemoveDynEntries(mIndex, mRequestedIndex);
    1:     mIndex = mRequestedIndex;
    1:   }
    1: 
14294:   mRequestedIndex = -1;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::Stop(PRUint32 aStopFlags)
    1: {
    1:   //Not implemented
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GetDocument(nsIDOMDocument** aDocument)
    1: {
    1:   // Not implemented
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GetCurrentURI(nsIURI** aResultURI)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResultURI);
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIHistoryEntry> currentEntry;
    1:   rv = GetEntryAtIndex(mIndex, PR_FALSE, getter_AddRefs(currentEntry));
    1:   if (NS_FAILED(rv) && !currentEntry) return rv;
    1:   rv = currentEntry->GetURI(aResultURI);
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GetReferringURI(nsIURI** aURI)
    1: {
    1:   *aURI = nsnull;
    1:   // Not implemented
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::SetSessionHistory(nsISHistory* aSessionHistory)
    1: {
    1:   // Not implemented
    1:   return NS_OK;
    1: }
    1: 
    1: 	
    1: NS_IMETHODIMP
    1: nsSHistory::GetSessionHistory(nsISHistory** aSessionHistory)
    1: {
    1:   // Not implemented
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::LoadURI(const PRUnichar* aURI,
    1:                     PRUint32 aLoadFlags,
    1:                     nsIURI* aReferringURI,
    1:                     nsIInputStream* aPostStream,
    1:                     nsIInputStream* aExtraHeaderStream)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GotoIndex(PRInt32 aIndex)
    1: {
    1:   return LoadEntry(aIndex, nsIDocShellLoadInfo::loadHistory, HIST_CMD_GOTOINDEX);
    1: }
    1: 
50721: nsresult
50721: nsSHistory::LoadNextPossibleEntry(PRInt32 aNewIndex, long aLoadType, PRUint32 aHistCmd)
50721: {
50721:   mRequestedIndex = -1;
50721:   if (aNewIndex < mIndex) {
50721:     return LoadEntry(aNewIndex - 1, aLoadType, aHistCmd);
50721:   }
50721:   if (aNewIndex > mIndex) {
50721:     return LoadEntry(aNewIndex + 1, aLoadType, aHistCmd);
50721:   }
50721:   return NS_ERROR_FAILURE;
50721: }
50721: 
    1: NS_IMETHODIMP
    1: nsSHistory::LoadEntry(PRInt32 aIndex, long aLoadType, PRUint32 aHistCmd)
    1: {
    1:   nsCOMPtr<nsIDocShell> docShell;
    1:   // Keep note of requested history index in mRequestedIndex.
    1:   mRequestedIndex = aIndex;
    1: 
    1:   nsCOMPtr<nsISHEntry> prevEntry;
    1:   GetEntryAtIndex(mIndex, PR_FALSE, getter_AddRefs(prevEntry));
    1: 
    1:   nsCOMPtr<nsISHEntry> nextEntry;
    1:   GetEntryAtIndex(mRequestedIndex, PR_FALSE, getter_AddRefs(nextEntry));
    1:   nsCOMPtr<nsIHistoryEntry> nHEntry(do_QueryInterface(nextEntry));
    1:   if (!nextEntry || !prevEntry || !nHEntry) {
    1:     mRequestedIndex = -1;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
60876:   // Remember that this entry is getting loaded at this point in the sequence
60876:   nsCOMPtr<nsISHEntryInternal> entryInternal = do_QueryInterface(nextEntry);
60876: 
60876:   if (entryInternal) {
60876:     entryInternal->SetLastTouched(++gTouchCounter);
60876:   }
60876: 
    1:   // Send appropriate listener notifications
79445:   bool canNavigate = true;
    1:   // Get the uri for the entry we are about to visit
    1:   nsCOMPtr<nsIURI> nextURI;
    1:   nHEntry->GetURI(getter_AddRefs(nextURI));
    1: 
    1:   if(mListener) {
    1:     nsCOMPtr<nsISHistoryListener> listener(do_QueryReferent(mListener));
    1:     if (listener) {
    1:       if (aHistCmd == HIST_CMD_BACK) {
    1:         // We are going back one entry. Send GoBack notifications
    1:         listener->OnHistoryGoBack(nextURI, &canNavigate);
    1:       }
    1:       else if (aHistCmd == HIST_CMD_FORWARD) {
    1:         // We are going forward. Send GoForward notification
    1:         listener->OnHistoryGoForward(nextURI, &canNavigate);
    1:       }
    1:       else if (aHistCmd == HIST_CMD_GOTOINDEX) {
    1:         // We are going somewhere else. This is not reload either
    1:         listener->OnHistoryGotoIndex(aIndex, nextURI, &canNavigate);
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (!canNavigate) {
    1:     // If the listener asked us not to proceed with 
    1:     // the operation, simply return.    
73618:     mRequestedIndex = -1;
    1:     return NS_OK;  // XXX Maybe I can return some other error code?
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> nexturi;
    1:   PRInt32 pCount=0, nCount=0;
    1:   nsCOMPtr<nsISHContainer> prevAsContainer(do_QueryInterface(prevEntry));
    1:   nsCOMPtr<nsISHContainer> nextAsContainer(do_QueryInterface(nextEntry));
    1:   if (prevAsContainer && nextAsContainer) {
    1:     prevAsContainer->GetChildCount(&pCount);
    1:     nextAsContainer->GetChildCount(&nCount);
    1:   }
    1:   
    1:   nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
    1:   if (mRequestedIndex == mIndex) {
    1:     // Possibly a reload case 
    1:     docShell = mRootDocShell;
    1:   }
    1:   else {
    1:     // Going back or forward.
    1:     if ((pCount > 0) && (nCount > 0)) {
    1:       /* THis is a subframe navigation. Go find 
    1:        * the docshell in which load should happen
    1:        */
79445:       bool frameFound = false;
    1:       nsresult rv = CompareFrames(prevEntry, nextEntry, mRootDocShell, aLoadType, &frameFound);
    1:       if (!frameFound) {
50721:         // We did not successfully find the subframe in which
50721:         // the new url was to be loaded. Go further in the history.
50721:         return LoadNextPossibleEntry(aIndex, aLoadType, aHistCmd);
    1:       }
    1:       return rv;
    1:     }   // (pCount >0)
50721:     else {
50721:       // Loading top level page.
50721:       PRUint32 prevID = 0;
50721:       PRUint32 nextID = 0;
50721:       prevEntry->GetID(&prevID);
50721:       nextEntry->GetID(&nextID);
50721:       if (prevID == nextID) {
50721:         // Try harder to find something new to load.
50721:         // This may happen for example if some page removed iframes dynamically.
50721:         return LoadNextPossibleEntry(aIndex, aLoadType, aHistCmd);
50721:       }
    1:       docShell = mRootDocShell;
    1:     }
50721:   }
    1: 
    1:   if (!docShell) {
    1:     // we did not successfully go to the proper index.
    1:     // return error.
    1:     mRequestedIndex = -1;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Start the load on the appropriate docshell
19870:   return InitiateLoad(nextEntry, docShell, aLoadType);
    1: }
    1: 
    1: nsresult
79445: nsSHistory::CompareFrames(nsISHEntry * aPrevEntry, nsISHEntry * aNextEntry, nsIDocShell * aParent, long aLoadType, bool * aIsFrameFound)
    1: {
    1:   if (!aPrevEntry || !aNextEntry || !aParent)
50721:     return NS_ERROR_FAILURE;
50721: 
50721:   // We should be comparing only entries which were created for the
50721:   // same docshell. This is here to just prevent anything strange happening.
50721:   // This check could be possibly an assertion.
50721:   PRUint64 prevdID, nextdID;
50721:   aPrevEntry->GetDocshellID(&prevdID);
50721:   aNextEntry->GetDocshellID(&nextdID);
50721:   NS_ENSURE_STATE(prevdID == nextdID);
    1: 
    1:   nsresult result = NS_OK;
    1:   PRUint32 prevID, nextID;
    1: 
    1:   aPrevEntry->GetID(&prevID);
    1:   aNextEntry->GetID(&nextID);
    1:  
    1:   // Check the IDs to verify if the pages are different.
    1:   if (prevID != nextID) {
    1:     if (aIsFrameFound)
    1:       *aIsFrameFound = PR_TRUE;
    1:     // Set the Subframe flag of the entry to indicate that
    1:     // it is subframe navigation        
    1:     aNextEntry->SetIsSubFrame(PR_TRUE);
    1:     InitiateLoad(aNextEntry, aParent, aLoadType);
    1:     return NS_OK;
    1:   }
    1: 
    1:   /* The root entries are the same, so compare any child frames */
    1:   PRInt32 pcnt=0, ncnt=0, dsCount=0;
    1:   nsCOMPtr<nsISHContainer>  prevContainer(do_QueryInterface(aPrevEntry));
    1:   nsCOMPtr<nsISHContainer>  nextContainer(do_QueryInterface(aNextEntry));
    1:   nsCOMPtr<nsIDocShellTreeNode> dsTreeNode(do_QueryInterface(aParent));
    1: 
    1:   if (!dsTreeNode)
    1:     return NS_ERROR_FAILURE;
    1:   if (!prevContainer || !nextContainer)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   prevContainer->GetChildCount(&pcnt);
    1:   nextContainer->GetChildCount(&ncnt);
    1:   dsTreeNode->GetChildCount(&dsCount);
    1: 
50721:   // Create an array for child docshells.
50721:   nsCOMArray<nsIDocShell> docshells;
50721:   for (PRInt32 i = 0; i < dsCount; ++i) {
50721:     nsCOMPtr<nsIDocShellTreeItem> treeItem;
50721:     dsTreeNode->GetChildAt(i, getter_AddRefs(treeItem));
50721:     nsCOMPtr<nsIDocShell> shell = do_QueryInterface(treeItem);
50721:     if (shell) {
50721:       docshells.AppendObject(shell);
50721:     }
50721:   }
    1: 
50721:   // Search for something to load next.
50721:   for (PRInt32 i = 0; i < ncnt; ++i) {
50721:     // First get an entry which may cause a new page to be loaded.
50721:     nsCOMPtr<nsISHEntry> nChild;
50721:     nextContainer->GetChildAt(i, getter_AddRefs(nChild));
50721:     if (!nChild) {
50721:       continue;
50721:     }
50721:     PRUint64 docshellID = 0;
50721:     nChild->GetDocshellID(&docshellID);
    1: 
50721:     // Then find the associated docshell.
50721:     nsIDocShell* dsChild = nsnull;
50721:     PRInt32 count = docshells.Count();
50721:     for (PRInt32 j = 0; j < count; ++j) {
50721:       PRUint64 shellID = 0;
50721:       nsIDocShell* shell = docshells[j];
50721:       shell->GetHistoryID(&shellID);
50721:       if (shellID == docshellID) {
50721:         dsChild = shell;
50721:         break;
50721:       }
50721:     }
50721:     if (!dsChild) {
50721:       continue;
50721:     }
    1: 
50721:     // Then look at the previous entries to see if there was
50721:     // an entry for the docshell.
50721:     nsCOMPtr<nsISHEntry> pChild;
50721:     for (PRInt32 k = 0; k < pcnt; ++k) {
50721:       nsCOMPtr<nsISHEntry> child;
50721:       prevContainer->GetChildAt(k, getter_AddRefs(child));
50721:       if (child) {
50721:         PRUint64 dID = 0;
50721:         child->GetDocshellID(&dID);
50721:         if (dID == docshellID) {
50721:           pChild = child;
50721:           break;
50721:         }
50721:       }
50721:     }
    1: 
50721:     // Finally recursively call this method.
50721:     // This will either load a new page to shell or some subshell or
50721:     // do nothing.
    1:     CompareFrames(pChild, nChild, dsChild, aLoadType, aIsFrameFound);
    1:   }     
    1:   return result;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsSHistory::InitiateLoad(nsISHEntry * aFrameEntry, nsIDocShell * aFrameDS, long aLoadType)
    1: {
57894:   NS_ENSURE_STATE(aFrameDS && aFrameEntry);
57894: 
    1:   nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
    1: 
    1:   /* Set the loadType in the SHEntry too to  what was passed on.
    1:    * This will be passed on to child subframes later in nsDocShell,
    1:    * so that proper loadType is maintained through out a frameset
    1:    */
    1:   aFrameEntry->SetLoadType(aLoadType);    
    1:   aFrameDS->CreateLoadInfo (getter_AddRefs(loadInfo));
    1: 
    1:   loadInfo->SetLoadType(aLoadType);
    1:   loadInfo->SetSHEntry(aFrameEntry);
    1: 
    1:   nsCOMPtr<nsIURI> nextURI;
    1:   nsCOMPtr<nsIHistoryEntry> hEntry(do_QueryInterface(aFrameEntry));
    1:   hEntry->GetURI(getter_AddRefs(nextURI));
    1:   // Time   to initiate a document load
    1:   return aFrameDS->LoadURI(nextURI, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, PR_FALSE);
    1: 
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::SetRootDocShell(nsIDocShell * aDocShell)
    1: {
    1:   mRootDocShell = aDocShell;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GetRootDocShell(nsIDocShell ** aDocShell)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDocShell);
    1: 
    1:   *aDocShell = mRootDocShell;
    1:   //Not refcounted. May this method should not be available for public
    1:   // NS_IF_ADDREF(*aDocShell);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsSHistory::GetSHistoryEnumerator(nsISimpleEnumerator** aEnumerator)
    1: {
    1:   nsresult status = NS_OK;
    1: 
    1:   NS_ENSURE_ARG_POINTER(aEnumerator);
    1:   nsSHEnumerator * iterator = new nsSHEnumerator(this);
    1:   if (iterator && NS_FAILED(status = CallQueryInterface(iterator, aEnumerator)))
    1:     delete iterator;
    1:   return status;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: //***    nsSHEnumerator: Object Management
    1: //*****************************************************************************
    1: 
    1: nsSHEnumerator::nsSHEnumerator(nsSHistory * aSHistory):mIndex(-1)
    1: {
    1:   mSHistory = aSHistory;
    1: }
    1: 
    1: nsSHEnumerator::~nsSHEnumerator()
    1: {
    1:   mSHistory = nsnull;
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsSHEnumerator, nsISimpleEnumerator)
    1: 
    1: NS_IMETHODIMP
79445: nsSHEnumerator::HasMoreElements(bool * aReturn)
    1: {
    1:   PRInt32 cnt;
    1:   *aReturn = PR_FALSE;
    1:   mSHistory->GetCount(&cnt);
    1:   if (mIndex >= -1 && mIndex < (cnt-1) ) { 
    1:     *aReturn = PR_TRUE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsSHEnumerator::GetNext(nsISupports **aItem)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aItem);
    1:   PRInt32 cnt= 0;
    1: 
    1:   nsresult  result = NS_ERROR_FAILURE;
    1:   mSHistory->GetCount(&cnt);
    1:   if (mIndex < (cnt-1)) {
    1:     mIndex++;
    1:     nsCOMPtr<nsIHistoryEntry> hEntry;
    1:     result = mSHistory->GetEntryAtIndex(mIndex, PR_FALSE, getter_AddRefs(hEntry));
    1:     if (hEntry)
    1:       result = CallQueryInterface(hEntry, aItem);
    1:   }
    1:   return result;
    1: }
