113445: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
113445:  * vim: set ts=4 sw=4 et tw=99:
111655:  *
113445:  * This Source Code Form is subject to the terms of the Mozilla Public
113445:  * License, v. 2.0. If a copy of the MPL was not distributed with this
113445:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
111655: 
126025: #include "mozilla/DebugOnly.h"
126025: 
111670: #include "IonAnalysis.h"
111665: #include "IonBuilder.h"
125350: #include "Lowering.h"
111656: #include "MIRGraph.h"
111655: #include "Ion.h"
111673: #include "IonAnalysis.h"
111736: #include "IonSpewer.h"
112153: #include "frontend/BytecodeEmitter.h"
113395: 
111655: #include "jsscriptinlines.h"
113395: #include "jstypedarrayinlines.h"
121812: #include "ExecutionModeInlines.h"
111655: 
111677: #ifdef JS_THREADSAFE
111677: # include "prthread.h"
111677: #endif
111677: 
111655: using namespace js;
111655: using namespace js::ion;
111655: 
121250: using mozilla::DebugOnly;
121250: 
113485: IonBuilder::IonBuilder(JSContext *cx, TempAllocator *temp, MIRGraph *graph,
124795:                        TypeOracle *oracle, CompileInfo *info, size_t inliningDepth, uint32_t loopDepth)
113485:   : MIRGenerator(cx->compartment, temp, graph, info),
124269:     backgroundCodegen_(NULL),
113582:     recompileInfo(cx->compartment->types.compiledInfo),
113485:     cx(cx),
112709:     loopDepth_(loopDepth),
112206:     callerResumePoint_(NULL),
112753:     callerBuilder_(NULL),
112206:     oracle(oracle),
113383:     inliningDepth(inliningDepth),
115105:     failedBoundsCheck_(info->script()->failedBoundsCheck),
120777:     failedShapeGuard_(info->script()->failedShapeGuard),
126255:     lazyArguments_(NULL),
126255:     callee_(NULL)
111655: {
115105:     script_.init(info->script());
113485:     pc = info->startPC();
113485: }
113485: 
113485: void
113485: IonBuilder::clearForBackEnd()
113485: {
113485:     cx = NULL;
113485:     oracle = NULL;
111655: }
111655: 
112477: bool
112477: IonBuilder::abort(const char *message, ...)
112477: {
113436:     // Don't call PCToLineNumber in release builds.
113436: #ifdef DEBUG
112477:     va_list ap;
112477:     va_start(ap, message);
112477:     abortFmt(message, ap);
112477:     va_end(ap);
125568:     IonSpew(IonSpew_Abort, "aborted @ %s:%d", script()->filename, PCToLineNumber(script(), pc));
113436: #endif
112477:     return false;
112477: }
112477: 
113436: void
113436: IonBuilder::spew(const char *message)
113436: {
113436:     // Don't call PCToLineNumber in release builds.
113436: #ifdef DEBUG
125568:     IonSpew(IonSpew_MIR, "%s @ %s:%d", message, script()->filename, PCToLineNumber(script(), pc));
113436: #endif
113436: }
113436: 
124795: static inline int32_t
111655: GetJumpOffset(jsbytecode *pc)
111655: {
112425:     JS_ASSERT(js_CodeSpec[JSOp(*pc)].type() == JOF_JUMP);
112410:     return GET_JUMP_OFFSET(pc);
111655: }
111655: 
111665: IonBuilder::CFGState
111665: IonBuilder::CFGState::If(jsbytecode *join, MBasicBlock *ifFalse)
111658: {
111658:     CFGState state;
111658:     state.state = IF_TRUE;
111658:     state.stopAt = join;
111658:     state.branch.ifFalse = ifFalse;
111658:     return state;
111658: }
111658: 
111665: IonBuilder::CFGState
111665: IonBuilder::CFGState::IfElse(jsbytecode *trueEnd, jsbytecode *falseEnd, MBasicBlock *ifFalse)
111658: {
111658:     CFGState state;
111658:     // If the end of the false path is the same as the start of the
111658:     // false path, then the "else" block is empty and we can devolve
111658:     // this to the IF_TRUE case. We handle this here because there is
111658:     // still an extra GOTO on the true path and we want stopAt to point
111658:     // there, whereas the IF_TRUE case does not have the GOTO.
111658:     state.state = (falseEnd == ifFalse->pc())
111658:                   ? IF_TRUE_EMPTY_ELSE
111658:                   : IF_ELSE_TRUE;
111658:     state.stopAt = trueEnd;
111658:     state.branch.falseEnd = falseEnd;
111658:     state.branch.ifFalse = ifFalse;
111658:     return state;
111658: }
111658: 
112205: IonBuilder::CFGState
112205: IonBuilder::CFGState::AndOr(jsbytecode *join, MBasicBlock *joinStart)
112205: {
112205:     CFGState state;
112205:     state.state = AND_OR;
112205:     state.stopAt = join;
112205:     state.branch.ifFalse = joinStart;
112205:     return state;
112205: }
112205: 
113028: IonBuilder::CFGState
113028: IonBuilder::CFGState::TableSwitch(jsbytecode *exitpc, MTableSwitch *ins)
113028: {
113028:     CFGState state;
113028:     state.state = TABLE_SWITCH;
113028:     state.stopAt = exitpc;
113028:     state.tableswitch.exitpc = exitpc;
113028:     state.tableswitch.breaks = NULL;
113028:     state.tableswitch.ins = ins;
113028:     state.tableswitch.currentBlock = 0;
113028:     return state;
113028: }
113028: 
113028: IonBuilder::CFGState
113028: IonBuilder::CFGState::LookupSwitch(jsbytecode *exitpc)
113028: {
113028:     CFGState state;
113028:     state.state = LOOKUP_SWITCH;
113028:     state.stopAt = exitpc;
113028:     state.lookupswitch.exitpc = exitpc;
113028:     state.lookupswitch.breaks = NULL;
113028:     state.lookupswitch.bodies =
113028:         (FixedList<MBasicBlock *> *)GetIonContext()->temp->allocate(sizeof(FixedList<MBasicBlock *>));
113028:     state.lookupswitch.currentBlock = 0;
113028:     return state;
113028: }
113028: 
112662: JSFunction *
124795: IonBuilder::getSingleCallTarget(uint32_t argc, jsbytecode *pc)
112662: {
119065:     AutoAssertNoGC nogc;
119065: 
125006:     types::StackTypeSet *calleeTypes = oracle->getCallTarget(script(), argc, pc);
113021:     if (!calleeTypes)
113021:         return NULL;
113021: 
119065:     RawObject obj = calleeTypes->getSingleton();
112920:     if (!obj || !obj->isFunction())
112662:         return NULL;
113021: 
112662:     return obj->toFunction();
112662: }
112662: 
113375: uint32_t
124795: IonBuilder::getPolyCallTargets(uint32_t argc, jsbytecode *pc,
113370:                                AutoObjectVector &targets, uint32_t maxTargets)
113370: {
125568:     types::TypeSet *calleeTypes = oracle->getCallTarget(script(), argc, pc);
113370:     if (!calleeTypes)
113370:         return 0;
113370: 
113373:     if (calleeTypes->baseFlags() != 0)
113373:         return 0;
113373: 
113370:     unsigned objCount = calleeTypes->getObjectCount();
113370: 
113370:     if (objCount == 0 || objCount > maxTargets)
113370:         return 0;
113370: 
113370:     for(unsigned i = 0; i < objCount; i++) {
113370:         JSObject *obj = calleeTypes->getSingleObject(i);
113370:         if (!obj || !obj->isFunction())
113370:             return 0;
113370:         targets.append(obj);
113370:     }
113370: 
113375:     return (uint32_t) objCount;
113370: }
113370: 
112206: bool
112874: IonBuilder::canInlineTarget(JSFunction *target)
112206: {
119065:     AssertCanGC();
119065: 
112874:     if (!target->isInterpreted()) {
112206:         IonSpew(IonSpew_Inlining, "Cannot inline due to non-interpreted");
112874:         return false;
112874:     }
112874: 
125568:     if (target->getParent() != &script()->global()) {
112206:         IonSpew(IonSpew_Inlining, "Cannot inline due to scope mismatch");
112874:         return false;
112874:     }
112874: 
123827:     RootedScript inlineScript(cx, target->nonLazyScript());
121812:     ExecutionMode executionMode = info().executionMode();
121812:     if (!CanIonCompile(inlineScript, executionMode)) {
112932:         IonSpew(IonSpew_Inlining, "Cannot inline due to disable Ion compilation");
112932:         return false;
112932:     }
112932: 
112753:     // Allow inlining of recursive calls, but only one level deep.
112753:     IonBuilder *builder = callerBuilder_;
112753:     while (builder) {
115105:         if (builder->script() == inlineScript) {
112753:             IonSpew(IonSpew_Inlining, "Not inlining recursive call");
112874:             return false;
112753:         }
112753:         builder = builder->callerBuilder_;
112753:     }
112753: 
112928:     bool canInline = oracle->canEnterInlinedFunction(target);
112206: 
112206:     if (!canInline) {
125568:         IonSpew(IonSpew_Inlining, "Cannot inline due to oracle veto %d", script()->lineno);
112874:         return false;
112206:     }
112206: 
112206:     IonSpew(IonSpew_Inlining, "Inlining good to go!");
112206:     return true;
112206: }
112206: 
111662: void
111665: IonBuilder::popCfgStack()
111658: {
111662:     if (cfgStack_.back().isLoop())
111662:         loops_.popBack();
111662:     cfgStack_.popBack();
111662: }
111662: 
111662: bool
111665: IonBuilder::pushLoop(CFGState::State initial, jsbytecode *stopAt, MBasicBlock *entry,
111668:                      jsbytecode *bodyStart, jsbytecode *bodyEnd, jsbytecode *exitpc,
111668:                      jsbytecode *continuepc)
111662: {
111668:     if (!continuepc)
111668:         continuepc = entry->pc();
111668: 
111929:     ControlFlowInfo loop(cfgStack_.length(), continuepc);
111662:     if (!loops_.append(loop))
111662:         return false;
111662: 
111658:     CFGState state;
111662:     state.state = initial;
111662:     state.stopAt = stopAt;
111662:     state.loop.bodyStart = bodyStart;
111662:     state.loop.bodyEnd = bodyEnd;
111662:     state.loop.exitpc = exitpc;
111658:     state.loop.entry = entry;
111662:     state.loop.successor = NULL;
111663:     state.loop.breaks = NULL;
111663:     state.loop.continues = NULL;
111662:     return cfgStack_.append(state);
111658: }
111658: 
111655: bool
111706: IonBuilder::build()
111655: {
111655:     current = newBlock(pc);
111655:     if (!current)
111655:         return false;
111655: 
113567:     IonSpew(IonSpew_Scripts, "Analyzing script %s:%d (%p) (usecount=%d) (maxloopcount=%d)",
125568:             script()->filename, script()->lineno, (void *)script(), (int)script()->getUseCount(),
125568:             (int)script()->getMaxLoopCount());
125568: 
125568:     if (!graph().addScript(script()))
114366:         return false;
114366: 
112425:     if (!initParameters())
112425:         return false;
111655: 
111655:     // Initialize local variables.
124795:     for (uint32_t i = 0; i < info().nlocals(); i++) {
111677:         MConstant *undef = MConstant::New(UndefinedValue());
111683:         current->add(undef);
112139:         current->initSlot(info().localSlot(i), undef);
111655:     }
111655: 
113175:     // Initialize something for the scope chain. We can bail out before the
113175:     // start instruction, but the snapshot is encoded *at* the start
113175:     // instruction, which means generating any code that could load into
113175:     // registers is illegal.
113175:     {
113175:         MInstruction *scope = MConstant::New(UndefinedValue());
113175:         current->add(scope);
113175:         current->initSlot(info().scopeChainSlot(), scope);
113175:     }
113175: 
113175:     // Emit the start instruction, so we can begin real instructions.
113175:     current->makeStart(MStart::New(MStart::StartType_Default));
113587:     if (instrumentedProfiling())
125568:         current->add(MFunctionBoundary::New(script(), MFunctionBoundary::Enter));
113175: 
113175:     // Parameters have been checked to correspond to the typeset, now we unbox
113175:     // what we can in an infallible manner.
113175:     rewriteParameters();
113175: 
113175:     // It's safe to start emitting actual IR, so now build the scope chain.
113175:     if (!initScopeChain())
113175:         return false;
113175: 
112292:     // Guard against over-recursion.
112292:     MCheckOverRecursed *check = new MCheckOverRecursed;
112292:     current->add(check);
112292:     check->setResumePoint(current->entryResumePoint());
112292: 
112874:     // Prevent |this| from being DCE'd: necessary for constructors.
112874:     if (info().fun())
112874:         current->getSlot(info().thisSlot())->setGuard();
112874: 
112108:     // The type analysis phase attempts to insert unbox operations near
112108:     // definitions of values. It also attempts to replace uses in resume points
112108:     // with the narrower, unboxed variants. However, we must prevent this
112108:     // replacement from happening on values in the entry snapshot. Otherwise we
112108:     // could get this:
112108:     //
112108:     //       v0 = MParameter(0)
112108:     //       v1 = MParameter(1)
112108:     //       --   ResumePoint(v2, v3)
112108:     //       v2 = Unbox(v0, INT32)
112108:     //       v3 = Unbox(v1, INT32)
112108:     //
112108:     // So we attach the initial resume point to each parameter, which the type
112108:     // analysis explicitly checks (this is the same mechanism used for
112108:     // effectful operations).
124795:     for (uint32_t i = 0; i < CountArgSlots(info().fun()); i++) {
112108:         MInstruction *ins = current->getEntrySlot(i)->toInstruction();
112108:         if (ins->type() == MIRType_Value)
112108:             ins->setResumePoint(current->entryResumePoint());
111949:     }
111949: 
113175:     // Recompile to inline calls if this function is hot.
113175:     insertRecompileCheck();
113175: 
125568:     if (script()->argumentsHasVarBinding()) {
113411:         lazyArguments_ = MConstant::New(MagicValue(JS_OPTIMIZED_ARGUMENTS));
113411:         current->add(lazyArguments_);
113411:     }
113411: 
112709:     if (!traverseBytecode())
112709:         return false;
112709: 
113129:     if (!processIterators())
113129:         return false;
113129: 
112709:     JS_ASSERT(loopDepth_ == 0);
112709:     return true;
112206: }
112206: 
112206: bool
113129: IonBuilder::processIterators()
113129: {
113129:     // Find phis that must directly hold an iterator live.
113129:     Vector<MPhi *, 0, SystemAllocPolicy> worklist;
113129:     for (size_t i = 0; i < iterators_.length(); i++) {
113129:         MInstruction *ins = iterators_[i];
113129:         for (MUseDefIterator iter(ins); iter; iter++) {
113129:             if (iter.def()->isPhi()) {
113129:                 if (!worklist.append(iter.def()->toPhi()))
113129:                     return false;
113129:             }
113129:         }
113129:     }
113129: 
113129:     // Propagate the iterator and live status of phis to all other connected
113129:     // phis.
113129:     while (!worklist.empty()) {
113129:         MPhi *phi = worklist.popCopy();
113129:         phi->setIterator();
125403:         phi->setFoldedUnchecked();
113129: 
113129:         for (MUseDefIterator iter(phi); iter; iter++) {
113129:             if (iter.def()->isPhi()) {
113129:                 MPhi *other = iter.def()->toPhi();
113129:                 if (!other->isIterator() && !worklist.append(other))
113129:                     return false;
113129:             }
113129:         }
113129:     }
113129: 
113129:     return true;
113129: }
113129: 
113129: bool
112753: IonBuilder::buildInline(IonBuilder *callerBuilder, MResumePoint *callerResumePoint,
113431:                         MDefinition *thisDefn, MDefinitionVector &argv)
112206: {
113447:     IonSpew(IonSpew_Scripts, "Inlining script %s:%d (%p)",
125568:             script()->filename, script()->lineno, (void *)script());
125568: 
125568:     if (!graph().addScript(script()))
114366:         return false;
114366: 
113354:     callerBuilder_ = callerBuilder;
113354:     callerResumePoint_ = callerResumePoint;
113354: 
113383:     if (callerBuilder->failedBoundsCheck_)
113383:         failedBoundsCheck_ = true;
113383: 
120777:     if (callerBuilder->failedShapeGuard_)
120777:         failedShapeGuard_ = true;
120777: 
113354:     // Generate single entrance block.
112206:     current = newBlock(pc);
112206:     if (!current)
111655:         return false;
111655: 
113354:     current->setCallerResumePoint(callerResumePoint);
113354: 
113354:     // Connect the entrance block to the last block in the caller's graph.
113370:     MBasicBlock *predecessor = callerBuilder->current;
113370:     JS_ASSERT(predecessor == callerResumePoint->block());
113587: 
113587:     // All further instructions generated in from this scope should be
113587:     // considered as part of the function that we're inlining. We also need to
113587:     // keep track of the inlining depth because all scripts inlined on the same
113587:     // level contiguously have only one Inline_Exit node.
113587:     if (instrumentedProfiling())
125568:         predecessor->add(MFunctionBoundary::New(script(),
113587:                                                 MFunctionBoundary::Inline_Enter,
113587:                                                 inliningDepth));
113587: 
112206:     predecessor->end(MGoto::New(current));
112206:     if (!current->addPredecessorWithoutPhis(predecessor))
112206:         return false;
113354: 
113354:     // Explicitly pass Undefined for missing arguments.
113196:     const size_t numActualArgs = argv.length() - 1;
112374:     const size_t nargs = info().nargs();
113354: 
113196:     if (numActualArgs < nargs) {
113354:         const size_t missing = nargs - numActualArgs;
113354: 
113354:         for (size_t i = 0; i < missing; i++) {
112374:             MConstant *undef = MConstant::New(UndefinedValue());
112374:             current->add(undef);
112711:             if (!argv.append(undef))
112374:                 return false;
112374:         }
112374:     }
112206: 
113354:     // The Oracle ensures that the inlined script does not use the scope chain.
125568:     JS_ASSERT(!script()->analysis()->usesScopeChain());
112406:     MInstruction *scope = MConstant::New(UndefinedValue());
112406:     current->add(scope);
112406:     current->initSlot(info().scopeChainSlot(), scope);
112406: 
112206:     current->initSlot(info().thisSlot(), thisDefn);
112206: 
112374:     IonSpew(IonSpew_Inlining, "Initializing %u arg slots", nargs);
112206: 
112206:     // Initialize argument references.
112711:     MDefinitionVector::Range args = argv.all();
112711:     args.popFront();
112711:     JS_ASSERT(args.remain() >= nargs);
112374:     for (size_t i = 0; i < nargs; ++i) {
112711:         MDefinition *arg = args.popCopyFront();
112206:         current->initSlot(info().argSlot(i), arg);
112206:     }
112206: 
112206:     IonSpew(IonSpew_Inlining, "Initializing %u local slots", info().nlocals());
112206: 
112206:     // Initialize local variables.
124795:     for (uint32_t i = 0; i < info().nlocals(); i++) {
112206:         MConstant *undef = MConstant::New(UndefinedValue());
112206:         current->add(undef);
112206:         current->initSlot(info().localSlot(i), undef);
112206:     }
112206: 
112206:     IonSpew(IonSpew_Inlining, "Inline entry block MResumePoint %p, %u operands",
112206:             (void *) current->entryResumePoint(), current->entryResumePoint()->numOperands());
112206: 
113354:     // +2 for the scope chain and |this|.
112406:     JS_ASSERT(current->entryResumePoint()->numOperands() == nargs + info().nlocals() + 2);
112206: 
112206:     return traverseBytecode();
111655: }
111655: 
112108: // Apply Type Inference information to parameters early on, unboxing them if
112108: // they have a definitive type. The actual guards will be emitted by the code
112108: // generator, explicitly, as part of the function prologue.
112108: void
112108: IonBuilder::rewriteParameters()
112108: {
112401:     JS_ASSERT(info().scopeChainSlot() == 0);
124795:     static const uint32_t START_SLOT = 1;
124795: 
124795:     for (uint32_t i = START_SLOT; i < CountArgSlots(info().fun()); i++) {
112108:         MParameter *param = current->getSlot(i)->toParameter();
124001: 
124001:         // Find the original (not cloned) type set for the MParameter, as we
124001:         // will be adding constraints to it.
124001:         types::StackTypeSet *types;
124001:         if (param->index() == MParameter::THIS_SLOT)
125568:             types = oracle->thisTypeSet(script());
124001:         else
125568:             types = oracle->parameterTypeSet(script(), param->index());
112108:         if (!types)
112108:             continue;
112108: 
113609:         JSValueType definiteType = types->getKnownTypeTag();
112108:         if (definiteType == JSVAL_TYPE_UNKNOWN)
112108:             continue;
112108: 
112108:         MInstruction *actual = NULL;
112108:         switch (definiteType) {
112108:           case JSVAL_TYPE_UNDEFINED:
125403:             param->setFoldedUnchecked();
112108:             actual = MConstant::New(UndefinedValue());
112108:             break;
112108: 
112108:           case JSVAL_TYPE_NULL:
125403:             param->setFoldedUnchecked();
112108:             actual = MConstant::New(NullValue());
112108:             break;
112108: 
112108:           default:
112118:             actual = MUnbox::New(param, MIRTypeFromValueType(definiteType), MUnbox::Infallible);
112108:             break;
112108:         }
112108: 
112108:         // Careful! We leave the original MParameter in the entry resume point. The
112108:         // arguments still need to be checked unless proven otherwise at the call
112108:         // site, and these checks can bailout. We can end up:
112108:         //   v0 = Parameter(0)
112108:         //   v1 = Unbox(v0, INT32)
112108:         //   --   ResumePoint(v0)
112108:         //
112108:         // As usual, it would be invalid for v1 to be captured in the initial
112108:         // resume point, rather than v0.
112372:         current->add(actual);
112108:         current->rewriteSlot(i, actual);
112108:     }
112108: }
112108: 
112425: bool
112108: IonBuilder::initParameters()
112108: {
113175:     if (!info().fun())
113175:         return true;
113175: 
113175:     MParameter *param = MParameter::New(MParameter::THIS_SLOT,
125568:                                         cloneTypeSet(oracle->thisTypeSet(script())));
113175:     current->add(param);
113175:     current->initSlot(info().thisSlot(), param);
113175: 
124795:     for (uint32_t i = 0; i < info().nargs(); i++) {
125568:         param = MParameter::New(i, cloneTypeSet(oracle->parameterTypeSet(script(), i)));
113175:         current->add(param);
113175:         current->initSlot(info().argSlot(i), param);
113175:     }
113175: 
113175:     return true;
113175: }
113175: 
113175: bool
113175: IonBuilder::initScopeChain()
113175: {
113175:     MInstruction *scope = NULL;
113175: 
126255:     // Add callee, it will be removed if it is not used by neither the scope
126255:     // chain nor the function body.
126255:     JSFunction *fun = info().fun();
126255:     if (fun) {
126255:         JS_ASSERT(!callee_);
126255:         callee_ = MCallee::New();
126255:         current->add(callee_);
126255:     }
126255: 
113175:     // If the script doesn't use the scopechain, then it's already initialized
113175:     // from earlier.
125568:     if (!script()->analysis()->usesScopeChain())
113175:         return true;
113175: 
112401:     // The scope chain is only tracked in scripts that have NAME opcodes which
112401:     // will try to access the scope. For other scripts, the scope instructions
112401:     // will be held live by resume points and code will still be generated for
112401:     // them, so just use a constant undefined value.
125568:     if (!script()->compileAndGo)
113175:         return abort("non-CNG global scripts are not supported");
113175: 
126255:     if (fun) {
126255:         scope = MFunctionEnvironment::New(callee_);
113175:         current->add(scope);
113175: 
125292:         // This reproduce what is done in CallObject::createForFunction
113175:         if (fun->isHeavyweight()) {
125292:             if (fun->isNamedLambda()) {
126255:                 scope = createDeclEnvObject(callee_, scope);
125292:                 if (!scope)
125292:                     return false;
125292:             }
113175: 
126255:             scope = createCallObject(callee_, scope);
113175:             if (!scope)
113175:                 return false;
113175:         }
112401:     } else {
125568:         scope = MConstant::New(ObjectValue(script()->global()));
112401:         current->add(scope);
113175:     }
113175: 
113175:     current->setScopeChain(scope);
112425:     return true;
112108: }
112108: 
111655: // We try to build a control-flow graph in the order that it would be built as
111655: // if traversing the AST. This leads to a nice ordering and lets us build SSA
111655: // in one pass, since the bytecode is structured.
111655: //
111655: // We traverse the bytecode iteratively, maintaining a current basic block.
111655: // Each basic block has a mapping of local slots to instructions, as well as a
111655: // stack depth. As we encounter instructions we mutate this mapping in the
111655: // current block.
111655: //
111655: // Things get interesting when we encounter a control structure. This can be
111655: // either an IFEQ, downward GOTO, or a decompiler hint stashed away in source
111655: // notes. Once we encounter such an opcode, we recover the structure of the
111655: // control flow (its branches and bounds), and push it on a stack.
111655: //
111655: // As we continue traversing the bytecode, we look for points that would
111655: // terminate the topmost control flow path pushed on the stack. These are:
111655: //  (1) The bounds of the current structure (end of a loop or join/edge of a
111655: //      branch).
111655: //  (2) A "return", "break", or "continue" statement.
111655: //
111655: // For (1), we expect that there is a current block in the progress of being
111655: // built, and we complete the necessary edges in the CFG. For (2), we expect
111655: // that there is no active block.
111655: //
111655: // For normal diamond join points, we construct Phi nodes as we add
111655: // predecessors. For loops, care must be taken to propagate Phi nodes back
111655: // through uses in the loop body.
111655: bool
111665: IonBuilder::traverseBytecode()
111655: {
111655:     for (;;) {
112139:         JS_ASSERT(pc < info().limitPC());
111655: 
111664:         for (;;) {
111683:             if (!temp().ensureBallast())
111683:                 return false;
111683: 
111655:             // Check if we've hit an expected join point or edge in the bytecode.
111659:             // Leaving one control structure could place us at the edge of another,
111659:             // thus |while| instead of |if| so we don't skip any opcodes.
111664:             if (!cfgStack_.empty() && cfgStack_.back().stopAt == pc) {
111655:                 ControlStatus status = processCfgStack();
111655:                 if (status == ControlStatus_Error)
111655:                     return false;
111655:                 if (!current)
111655:                     return true;
111664:                 continue;
111655:             }
111655: 
111655:             // Some opcodes need to be handled early because they affect control
111655:             // flow, terminating the current basic block and/or instructing the
111655:             // traversal algorithm to continue from a new pc.
111655:             //
111655:             //   (1) If the opcode does not affect control flow, then the opcode
111655:             //       is inspected and transformed to IR. This is the process_opcode
111655:             //       label.
111655:             //   (2) A loop could be detected via a forward GOTO. In this case,
111655:             //       we don't want to process the GOTO, but the following
111655:             //       instruction.
111655:             //   (3) A RETURN, STOP, BREAK, or CONTINUE may require processing the
111655:             //       CFG stack to terminate open branches.
111660:             //
111660:             // Similar to above, snooping control flow could land us at another
111660:             // control flow point, so we iterate until it's time to inspect a real
111660:             // opcode.
111660:             ControlStatus status;
111664:             if ((status = snoopControlFlow(JSOp(*pc))) == ControlStatus_None)
111664:                 break;
111655:             if (status == ControlStatus_Error)
111655:                 return false;
111655:             if (!current)
111655:                 return true;
111660:         }
111655: 
112049:         // Nothing in inspectOpcode() is allowed to advance the pc.
111655:         JSOp op = JSOp(*pc);
111655:         if (!inspectOpcode(op))
111655:             return false;
111655: 
111655:         pc += js_CodeSpec[op].length;
112455: #ifdef TRACK_SNAPSHOTS
112455:         current->updateTrackedPc(pc);
112455: #endif
111655:     }
111655: 
111655:     return true;
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::snoopControlFlow(JSOp op)
111655: {
111655:     switch (op) {
111664:       case JSOP_NOP:
112139:         return maybeLoop(op, info().getNote(cx, pc));
111664: 
111664:       case JSOP_POP:
112139:         return maybeLoop(op, info().getNote(cx, pc));
111664: 
111655:       case JSOP_RETURN:
111655:       case JSOP_STOP:
111655:         return processReturn(op);
111655: 
112478:       case JSOP_THROW:
112478:         return processThrow();
112478: 
111655:       case JSOP_GOTO:
111655:       {
112139:         jssrcnote *sn = info().getNote(cx, pc);
111655:         switch (sn ? SN_TYPE(sn) : SRC_NULL) {
111655:           case SRC_BREAK:
111655:           case SRC_BREAK2LABEL:
111663:             return processBreak(op, sn);
111655: 
111655:           case SRC_CONTINUE:
111655:           case SRC_CONT2LABEL:
111663:             return processContinue(op, sn);
111655: 
111929:           case SRC_SWITCHBREAK:
111929:             return processSwitchBreak(op, sn);
111929: 
111655:           case SRC_WHILE:
112663:           case SRC_FOR_IN:
111655:             // while (cond) { }
112663:             return whileOrForInLoop(op, sn);
111655: 
111655:           default:
111655:             // Hard assert for now - make an error later.
111655:             JS_NOT_REACHED("unknown goto case");
111655:             break;
111655:         }
111655:         break;
111655:       }
111655: 
111929:       case JSOP_TABLESWITCH:
112139:         return tableSwitch(op, info().getNote(cx, pc));
111929: 
113028:       case JSOP_LOOKUPSWITCH:
113028:         return lookupSwitch(op, info().getNote(cx, pc));
113028: 
111655:       case JSOP_IFNE:
111655:         // We should never reach an IFNE, it's a stopAt point, which will
111655:         // trigger closing the loop.
111655:         JS_NOT_REACHED("we should never reach an ifne!");
111655:         return ControlStatus_Error;
111655: 
111655:       default:
111655:         break;
111655:     }
111655:     return ControlStatus_None;
111655: }
111655: 
111658: bool
111665: IonBuilder::inspectOpcode(JSOp op)
111655: {
119065:     AssertCanGC();
119065: 
112178:     // Don't compile fat opcodes, run the decomposed version instead.
112178:     if (js_CodeSpec[op].format & JOF_DECOMPOSE)
112178:         return true;
112178: 
111658:     switch (op) {
112479:       case JSOP_LOOPENTRY:
113508:         insertRecompileCheck();
112479:         return true;
112479: 
111668:       case JSOP_NOP:
111668:         return true;
111668: 
112708:       case JSOP_LABEL:
112708:         return true;
112708: 
112293:       case JSOP_UNDEFINED:
111658:         return pushConstant(UndefinedValue());
111658: 
111658:       case JSOP_IFEQ:
111658:         return jsop_ifeq(JSOP_IFEQ);
111658: 
124883:       case JSOP_CONDSWITCH:
124883:         return jsop_condswitch();
124883: 
111977:       case JSOP_BITNOT:
112016:         return jsop_bitnot();
111977: 
111658:       case JSOP_BITAND:
111780:       case JSOP_BITOR:
111780:       case JSOP_BITXOR:
112026:       case JSOP_LSH:
112026:       case JSOP_RSH:
112026:       case JSOP_URSH:
111800:         return jsop_bitop(op);
111658: 
111700:       case JSOP_ADD:
112068:       case JSOP_SUB:
112011:       case JSOP_MUL:
112072:       case JSOP_DIV:
112345:       case JSOP_MOD:
111700:         return jsop_binary(op);
111700: 
112291:       case JSOP_POS:
112291:         return jsop_pos();
112291: 
112012:       case JSOP_NEG:
112012:         return jsop_neg();
112012: 
112205:       case JSOP_AND:
112205:       case JSOP_OR:
112205:         return jsop_andor(op);
112205: 
112716:       case JSOP_DEFVAR:
112716:       case JSOP_DEFCONST:
112841:         return jsop_defvar(GET_UINT32_INDEX(pc));
112716: 
112210:       case JSOP_EQ:
112210:       case JSOP_NE:
112210:       case JSOP_STRICTEQ:
112210:       case JSOP_STRICTNE:
111996:       case JSOP_LT:
111996:       case JSOP_LE:
111996:       case JSOP_GT:
111996:       case JSOP_GE:
111996:         return jsop_compare(op);
111996: 
111658:       case JSOP_DOUBLE:
112139:         return pushConstant(info().getConst(pc));
111658: 
111658:       case JSOP_STRING:
112139:         return pushConstant(StringValue(info().getAtom(pc)));
111658: 
111658:       case JSOP_ZERO:
111658:         return pushConstant(Int32Value(0));
111658: 
111658:       case JSOP_ONE:
111658:         return pushConstant(Int32Value(1));
111658: 
111658:       case JSOP_NULL:
111658:         return pushConstant(NullValue());
111658: 
111987:       case JSOP_VOID:
111987:         current->pop();
111987:         return pushConstant(UndefinedValue());
111987: 
112957:       case JSOP_HOLE:
112957:         return pushConstant(MagicValue(JS_ARRAY_HOLE));
112957: 
111658:       case JSOP_FALSE:
111658:         return pushConstant(BooleanValue(false));
111658: 
111658:       case JSOP_TRUE:
111658:         return pushConstant(BooleanValue(true));
111658: 
113198:       case JSOP_ARGUMENTS:
113199:         return jsop_arguments();
113198: 
112064:       case JSOP_NOTEARG:
112064:         return jsop_notearg();
112064: 
112412:       case JSOP_GETARG:
112064:       case JSOP_CALLARG:
111658:         current->pushArg(GET_SLOTNO(pc));
111658:         return true;
111658: 
111991:       case JSOP_SETARG:
113200:         // To handle this case, we should spill the arguments to the space where
113200:         // actual arguments are stored. The tricky part is that if we add a MIR
113200:         // to wrap the spilling action, we don't want the spilling to be
113200:         // captured by the GETARG and by the resume point, only by
113200:         // MGetArgument.
113200:         if (info().hasArguments())
113200:             return abort("NYI: arguments & setarg.");
111991:         current->setArg(GET_SLOTNO(pc));
111991:         return true;
111991: 
111658:       case JSOP_GETLOCAL:
112421:       case JSOP_CALLLOCAL:
111658:         current->pushLocal(GET_SLOTNO(pc));
111658:         return true;
111658: 
111658:       case JSOP_SETLOCAL:
112108:         current->setLocal(GET_SLOTNO(pc));
112108:         return true;
111658: 
111664:       case JSOP_POP:
111664:         current->pop();
124557: 
124557:         // POP opcodes frequently appear where values are killed, e.g. after
124557:         // SET* opcodes. Place a resume point afterwards to avoid capturing
124557:         // the dead value in later snapshots, except in places where that
124557:         // resume point is obviously unnecessary.
124557:         if (pc[JSOP_POP_LENGTH] == JSOP_POP)
111664:             return true;
124557:         return maybeInsertResume();
111664: 
112976:       case JSOP_NEWINIT:
113095:       {
112977:         if (GET_UINT8(pc) == JSProto_Array)
112977:             return jsop_newarray(0);
113132:         RootedObject baseObj(cx, NULL);
113095:         return jsop_newobject(baseObj);
113095:       }
112976: 
112247:       case JSOP_NEWARRAY:
112247:         return jsop_newarray(GET_UINT24(pc));
112247: 
112764:       case JSOP_NEWOBJECT:
113095:       {
113132:         RootedObject baseObj(cx, info().getObject(pc));
113095:         return jsop_newobject(baseObj);
113095:       }
112764: 
126000:       case JSOP_INITELEM_ARRAY:
126000:         return jsop_initelem_array();
112734: 
112765:       case JSOP_INITPROP:
113095:       {
113132:         RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
113095:         return jsop_initprop(name);
113095:       }
112765: 
112247:       case JSOP_ENDINIT:
112247:         return true;
112247: 
112920:       case JSOP_FUNCALL:
112920:         return jsop_funcall(GET_ARGC(pc));
112920: 
113388:       case JSOP_FUNAPPLY:
113388:         return jsop_funapply(GET_ARGC(pc));
113388: 
112064:       case JSOP_CALL:
112920:       case JSOP_NEW:
112920:         return jsop_call(GET_ARGC(pc), (JSOp)*pc == JSOP_NEW);
112064: 
111658:       case JSOP_INT8:
111658:         return pushConstant(Int32Value(GET_INT8(pc)));
111658: 
111887:       case JSOP_UINT16:
111887:         return pushConstant(Int32Value(GET_UINT16(pc)));
111887: 
112118:       case JSOP_GETGNAME:
112410:       case JSOP_CALLGNAME:
113095:       {
113132:         RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
113095:         return jsop_getgname(name);
113095:       }
112118: 
112193:       case JSOP_BINDGNAME:
125568:         return pushConstant(ObjectValue(script()->global()));
112193: 
112193:       case JSOP_SETGNAME:
113095:       {
113132:         RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
113095:         return jsop_setgname(name);
113095:       }
112193: 
112401:       case JSOP_NAME:
112715:       case JSOP_CALLNAME:
113095:       {
113132:         RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
113095:         return jsop_getname(name);
113095:       }
112401: 
126026:       case JSOP_GETINTRINSIC:
122024:       case JSOP_CALLINTRINSIC:
122024:       {
122024:         RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
126026:         return jsop_intrinsic(name);
122024:       }
122024: 
112766:       case JSOP_BINDNAME:
112766:         return jsop_bindname(info().getName(pc));
112766: 
112229:       case JSOP_DUP:
112229:         current->pushSlot(current->stackDepth() - 1);
112229:         return true;
112229: 
112229:       case JSOP_DUP2:
112229:         return jsop_dup2();
112229: 
112413:       case JSOP_SWAP:
112413:         current->swapAt(-1);
112413:         return true;
112413: 
112413:       case JSOP_PICK:
112413:         current->pick(-GET_INT8(pc));
112413:         return true;
112413: 
113176:       case JSOP_GETALIASEDVAR:
113176:       case JSOP_CALLALIASEDVAR:
113176:         return jsop_getaliasedvar(ScopeCoordinate(pc));
113176: 
113176:       case JSOP_SETALIASEDVAR:
113176:         return jsop_setaliasedvar(ScopeCoordinate(pc));
113176: 
111953:       case JSOP_UINT24:
111953:         return pushConstant(Int32Value(GET_UINT24(pc)));
111953: 
111953:       case JSOP_INT32:
111953:         return pushConstant(Int32Value(GET_INT32(pc)));
111953: 
112249:       case JSOP_LOOPHEAD:
112397:         // JSOP_LOOPHEAD is handled when processing the loop header.
112397:         JS_NOT_REACHED("JSOP_LOOPHEAD outside loop");
111658:         return true;
111658: 
112231:       case JSOP_GETELEM:
112836:       case JSOP_CALLELEM:
112231:         return jsop_getelem();
112231: 
112231:       case JSOP_SETELEM:
112231:         return jsop_setelem();
112231: 
112309:       case JSOP_LENGTH:
112309:         return jsop_length();
112309: 
112696:       case JSOP_NOT:
112696:         return jsop_not();
112696: 
112372:       case JSOP_THIS:
112372:         return jsop_this();
112372: 
125292:       case JSOP_CALLEE:
126255:         JS_ASSERT(callee_);
126255:         current->push(callee_);
126255:         return true;
125292: 
112289:       case JSOP_GETPROP:
112414:       case JSOP_CALLPROP:
113095:       {
113132:         RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
113095:         return jsop_getprop(name);
113095:       }
112289: 
112445:       case JSOP_SETPROP:
112445:       case JSOP_SETNAME:
113095:       {
113132:         RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
113095:         return jsop_setprop(name);
113095:       }
112445: 
112834:       case JSOP_DELPROP:
114101:       {
114101:         RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
114101:         return jsop_delprop(name);
114101:       }
112834: 
112541:       case JSOP_REGEXP:
112541:         return jsop_regexp(info().getRegExp(pc));
112541: 
112543:       case JSOP_OBJECT:
112543:         return jsop_object(info().getObject(pc));
112543: 
112684:       case JSOP_TYPEOF:
112798:       case JSOP_TYPEOFEXPR:
112684:         return jsop_typeof();
112684: 
112705:       case JSOP_TOID:
112705:         return jsop_toid();
112705: 
112691:       case JSOP_LAMBDA:
112691:         return jsop_lambda(info().getFunction(pc));
112691: 
112663:       case JSOP_ITER:
112663:         return jsop_iter(GET_INT8(pc));
112663: 
112663:       case JSOP_ITERNEXT:
113496:         return jsop_iternext();
112663: 
112663:       case JSOP_MOREITER:
112663:         return jsop_itermore();
112663: 
112663:       case JSOP_ENDITER:
112663:         return jsop_iterend();
112663: 
119236:       case JSOP_IN:
119236:         return jsop_in();
119236: 
113170:       case JSOP_INSTANCEOF:
113170:         return jsop_instanceof();
113170: 
111658:       default:
111861: #ifdef DEBUG
112139:         return abort("Unsupported opcode: %s (line %d)", js_CodeName[op], info().lineno(cx, pc));
111861: #else
112139:         return abort("Unsupported opcode: %d (line %d)", op, info().lineno(cx, pc));
111861: #endif
111658:     }
111655: }
111655: 
111655: // Given that the current control flow structure has ended forcefully,
111655: // via a return, break, or continue (rather than joining), propagate the
111655: // termination up. For example, a return nested 5 loops deep may terminate
111655: // every outer loop at once, if there are no intervening conditionals:
111655: //
111655: // for (...) {
111655: //   for (...) {
111655: //     return x;
111655: //   }
111655: // }
111655: //
111655: // If |current| is NULL when this function returns, then there is no more
111655: // control flow to be processed.
111665: IonBuilder::ControlStatus
111665: IonBuilder::processControlEnd()
111655: {
111655:     JS_ASSERT(!current);
111655: 
111655:     if (cfgStack_.empty()) {
111655:         // If there is no more control flow to process, then this is the
111655:         // last return in the function.
111655:         return ControlStatus_Ended;
111655:     }
111655: 
111655:     return processCfgStack();
111655: }
111655: 
111655: // Processes the top of the CFG stack. This is used from two places:
111655: // (1) processControlEnd(), whereby a break, continue, or return may interrupt
111655: //     an in-progress CFG structure before reaching its actual termination
111655: //     point in the bytecode.
111655: // (2) traverseBytecode(), whereby we reach the last instruction in a CFG
111655: //     structure.
111665: IonBuilder::ControlStatus
111665: IonBuilder::processCfgStack()
111655: {
111655:     ControlStatus status = processCfgEntry(cfgStack_.back());
111655: 
111655:     // If this terminated a CFG structure, act like processControlEnd() and
111655:     // keep propagating upward.
111655:     while (status == ControlStatus_Ended) {
111662:         popCfgStack();
111655:         if (cfgStack_.empty())
111655:             return status;
111655:         status = processCfgEntry(cfgStack_.back());
111655:     }
111655: 
111655:     // If some join took place, the current structure is finished.
111655:     if (status == ControlStatus_Joined)
111662:         popCfgStack();
111655: 
111655:     return status;
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processCfgEntry(CFGState &state)
111655: {
111655:     switch (state.state) {
111655:       case CFGState::IF_TRUE:
111655:       case CFGState::IF_TRUE_EMPTY_ELSE:
111655:         return processIfEnd(state);
111655: 
111655:       case CFGState::IF_ELSE_TRUE:
111655:         return processIfElseTrueEnd(state);
111655: 
111655:       case CFGState::IF_ELSE_FALSE:
111655:         return processIfElseFalseEnd(state);
111655: 
111774:       case CFGState::DO_WHILE_LOOP_BODY:
111774:         return processDoWhileBodyEnd(state);
111774: 
111774:       case CFGState::DO_WHILE_LOOP_COND:
111774:         return processDoWhileCondEnd(state);
111655: 
111658:       case CFGState::WHILE_LOOP_COND:
111658:         return processWhileCondEnd(state);
111658: 
111658:       case CFGState::WHILE_LOOP_BODY:
111658:         return processWhileBodyEnd(state);
111658: 
111664:       case CFGState::FOR_LOOP_COND:
111664:         return processForCondEnd(state);
111664: 
111664:       case CFGState::FOR_LOOP_BODY:
111664:         return processForBodyEnd(state);
111664: 
111664:       case CFGState::FOR_LOOP_UPDATE:
111664:         return processForUpdateEnd(state);
111664: 
111929:       case CFGState::TABLE_SWITCH:
111929:         return processNextTableSwitchCase(state);
111929: 
113028:       case CFGState::LOOKUP_SWITCH:
113028:         return processNextLookupSwitchCase(state);
113028: 
124883:       case CFGState::COND_SWITCH_CASE:
124883:         return processCondSwitchCase(state);
124883: 
124883:       case CFGState::COND_SWITCH_BODY:
124883:         return processCondSwitchBody(state);
124883: 
112205:       case CFGState::AND_OR:
112205:         return processAndOrEnd(state);
112205: 
111655:       default:
111655:         JS_NOT_REACHED("unknown cfgstate");
111655:     }
111655:     return ControlStatus_Error;
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processIfEnd(CFGState &state)
111655: {
111668:     if (current) {
111655:         // Here, the false block is the join point. Create an edge from the
111655:         // current block to the false block. Note that a RETURN opcode
111655:         // could have already ended the block.
111683:         current->end(MGoto::New(state.branch.ifFalse));
111655: 
111704:         if (!state.branch.ifFalse->addPredecessor(current))
111655:             return ControlStatus_Error;
111668:     }
111655: 
111655:     current = state.branch.ifFalse;
113485:     graph().moveBlockToEnd(current);
111682:     pc = current->pc();
111655:     return ControlStatus_Joined;
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processIfElseTrueEnd(CFGState &state)
111655: {
111655:     // We've reached the end of the true branch of an if-else. Don't
111655:     // create an edge yet, just transition to parsing the false branch.
111655:     state.state = CFGState::IF_ELSE_FALSE;
111655:     state.branch.ifTrue = current;
111655:     state.stopAt = state.branch.falseEnd;
111655:     pc = state.branch.ifFalse->pc();
111655:     current = state.branch.ifFalse;
113485:     graph().moveBlockToEnd(current);
111655:     return ControlStatus_Jumped;
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processIfElseFalseEnd(CFGState &state)
111655: {
111655:     // Update the state to have the latest block from the false path.
111655:     state.branch.ifFalse = current;
111655: 
111655:     // To create the join node, we need an incoming edge that has not been
111655:     // terminated yet.
111655:     MBasicBlock *pred = state.branch.ifTrue
111655:                         ? state.branch.ifTrue
111655:                         : state.branch.ifFalse;
111655:     MBasicBlock *other = (pred == state.branch.ifTrue) ? state.branch.ifFalse : state.branch.ifTrue;
111655: 
111655:     if (!pred)
111655:         return ControlStatus_Ended;
111655: 
111655:     // Create a new block to represent the join.
112034:     MBasicBlock *join = newBlock(pred, state.branch.falseEnd);
111655:     if (!join)
111655:         return ControlStatus_Error;
111655: 
111655:     // Create edges from the true and false blocks as needed.
111683:     pred->end(MGoto::New(join));
111683: 
111655:     if (other) {
111683:         other->end(MGoto::New(join));
111655:         if (!join->addPredecessor(other))
111655:             return ControlStatus_Error;
111655:     }
111655: 
111894:     // Ignore unreachable remainder of false block if existent.
111655:     current = join;
112034:     pc = current->pc();
111655:     return ControlStatus_Joined;
111655: }
111655: 
112030: IonBuilder::ControlStatus
112030: IonBuilder::processBrokenLoop(CFGState &state)
111663: {
112030:     JS_ASSERT(!current);
111663: 
112709:     JS_ASSERT(loopDepth_);
112709:     loopDepth_--;
112709: 
112709:     // A broken loop is not a real loop (it has no header or backedge), so
112709:     // reset the loop depth.
113485:     for (MBasicBlockIterator i(graph().begin(state.loop.entry)); i != graph().end(); i++) {
112709:         if (i->loopDepth() > loopDepth_)
112709:             i->setLoopDepth(i->loopDepth() - 1);
112709:     }
112709: 
112030:     // If the loop started with a condition (while/for) then even if the
112030:     // structure never actually loops, the condition itself can still fail and
112030:     // thus we must resume at the successor, if one exists.
112030:     current = state.loop.successor;
112870:     if (current) {
112870:         JS_ASSERT(current->loopDepth() == loopDepth_);
113485:         graph().moveBlockToEnd(current);
112870:     }
112030: 
112030:     // Join the breaks together and continue parsing.
111664:     if (state.loop.breaks) {
112030:         MBasicBlock *block = createBreakCatchBlock(state.loop.breaks, state.loop.exitpc);
112030:         if (!block)
112030:             return ControlStatus_Error;
112030: 
112030:         if (current) {
112030:             current->end(MGoto::New(block));
112030:             if (!block->addPredecessor(current))
111929:                 return ControlStatus_Error;
111663:         }
111663: 
112030:         current = block;
111663:     }
111663: 
112030:     // If the loop is not gated on a condition, and has only returns, we'll
112030:     // reach this case. For example:
112030:     // do { ... return; } while ();
112030:     if (!current)
112030:         return ControlStatus_Ended;
112030: 
112030:     // Otherwise, the loop is gated on a condition and/or has breaks so keep
112030:     // parsing at the successor.
112030:     pc = current->pc();
112030:     return ControlStatus_Joined;
111663: }
111663: 
112030: IonBuilder::ControlStatus
112030: IonBuilder::finishLoop(CFGState &state, MBasicBlock *successor)
112030: {
112030:     JS_ASSERT(current);
112030: 
112709:     JS_ASSERT(loopDepth_);
112709:     loopDepth_--;
112709:     JS_ASSERT_IF(successor, successor->loopDepth() == loopDepth_);
112709: 
112030:     // Compute phis in the loop header and propagate them throughout the loop,
112030:     // including the successor.
112030:     if (!state.loop.entry->setBackedge(current))
112030:         return ControlStatus_Error;
112870:     if (successor) {
113485:         graph().moveBlockToEnd(successor);
112030:         successor->inheritPhis(state.loop.entry);
112870:     }
112030: 
112030:     if (state.loop.breaks) {
112030:         // Propagate phis placed in the header to individual break exit points.
112030:         DeferredEdge *edge = state.loop.breaks;
112030:         while (edge) {
112030:             edge->block->inheritPhis(state.loop.entry);
112030:             edge = edge->next;
112030:         }
112030: 
112030:         // Create a catch block to join all break exits.
112030:         MBasicBlock *block = createBreakCatchBlock(state.loop.breaks, state.loop.exitpc);
112030:         if (!block)
112030:             return ControlStatus_Error;
112030: 
112074:         if (successor) {
112074:             // Finally, create an unconditional edge from the successor to the
112074:             // catch block.
112030:             successor->end(MGoto::New(block));
112030:             if (!block->addPredecessor(successor))
112030:                 return ControlStatus_Error;
112074:         }
112030:         successor = block;
112030:     }
112030: 
112030:     current = successor;
112051: 
112051:     // An infinite loop (for (;;) { }) will not have a successor.
112051:     if (!current)
112051:         return ControlStatus_Ended;
112051: 
112030:     pc = current->pc();
112030:     return ControlStatus_Joined;
111663: }
111663: 
111665: IonBuilder::ControlStatus
111774: IonBuilder::processDoWhileBodyEnd(CFGState &state)
111655: {
111664:     if (!processDeferredContinues(state))
111664:         return ControlStatus_Error;
111682: 
112030:     // No current means control flow cannot reach the condition, so this will
112030:     // never loop.
111876:     if (!current)
112030:         return processBrokenLoop(state);
111876: 
111774:     MBasicBlock *header = newBlock(current, state.loop.updatepc);
111774:     if (!header)
111774:         return ControlStatus_Error;
111774:     current->end(MGoto::New(header));
111774: 
111774:     state.state = CFGState::DO_WHILE_LOOP_COND;
111774:     state.stopAt = state.loop.updateEnd;
111774:     pc = state.loop.updatepc;
111774:     current = header;
111774:     return ControlStatus_Jumped;
111774: }
111774: 
111774: IonBuilder::ControlStatus
111774: IonBuilder::processDoWhileCondEnd(CFGState &state)
111774: {
112410:     JS_ASSERT(JSOp(*pc) == JSOP_IFNE);
111774: 
112030:     // We're guaranteed a |current|, it's impossible to break or return from
112030:     // inside the conditional expression.
112030:     JS_ASSERT(current);
111682: 
112030:     // Pop the last value, and create the successor block.
112030:     MDefinition *vins = current->pop();
112709:     MBasicBlock *successor = newBlock(current, GetNextPc(pc), loopDepth_ - 1);
112030:     if (!successor)
111655:         return ControlStatus_Error;
111655: 
112030:     // Create the test instruction and end the current block.
112030:     MTest *test = MTest::New(vins, state.loop.entry, successor);
112030:     current->end(test);
112030:     return finishLoop(state, successor);
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processWhileCondEnd(CFGState &state)
111655: {
112410:     JS_ASSERT(JSOp(*pc) == JSOP_IFNE);
111658: 
111658:     // Balance the stack past the IFNE.
111795:     MDefinition *ins = current->pop();
111658: 
111658:     // Create the body and successor blocks.
111662:     MBasicBlock *body = newBlock(current, state.loop.bodyStart);
112709:     state.loop.successor = newBlock(current, state.loop.exitpc, loopDepth_ - 1);
111683:     if (!body || !state.loop.successor)
111683:         return ControlStatus_Error;
111683: 
111677:     MTest *test = MTest::New(ins, body, state.loop.successor);
111683:     current->end(test);
111658: 
111658:     state.state = CFGState::WHILE_LOOP_BODY;
111662:     state.stopAt = state.loop.bodyEnd;
111662:     pc = state.loop.bodyStart;
111658:     current = body;
111658:     return ControlStatus_Jumped;
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processWhileBodyEnd(CFGState &state)
111655: {
111664:     if (!processDeferredContinues(state))
111664:         return ControlStatus_Error;
111664: 
111664:     if (!current)
112030:         return processBrokenLoop(state);
111664: 
112030:     current->end(MGoto::New(state.loop.entry));
112030:     return finishLoop(state, state.loop.successor);
111664: }
111664: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processForCondEnd(CFGState &state)
111664: {
112410:     JS_ASSERT(JSOp(*pc) == JSOP_IFNE);
111664: 
111664:     // Balance the stack past the IFNE.
111795:     MDefinition *ins = current->pop();
111664: 
111664:     // Create the body and successor blocks.
111664:     MBasicBlock *body = newBlock(current, state.loop.bodyStart);
112709:     state.loop.successor = newBlock(current, state.loop.exitpc, loopDepth_ - 1);
111683:     if (!body || !state.loop.successor)
111683:         return ControlStatus_Error;
111683: 
111677:     MTest *test = MTest::New(ins, body, state.loop.successor);
111683:     current->end(test);
111664: 
111664:     state.state = CFGState::FOR_LOOP_BODY;
111664:     state.stopAt = state.loop.bodyEnd;
111664:     pc = state.loop.bodyStart;
111664:     current = body;
111664:     return ControlStatus_Jumped;
111664: }
111664: 
112030: IonBuilder::ControlStatus
112030: IonBuilder::processForBodyEnd(CFGState &state)
112030: {
112030:     if (!processDeferredContinues(state))
112030:         return ControlStatus_Error;
112030: 
112030:     // If there is no updatepc, just go right to processing what would be the
112030:     // end of the update clause. Otherwise, |current| might be NULL; if this is
112030:     // the case, the udpate is unreachable anyway.
112030:     if (!state.loop.updatepc || !current)
112030:         return processForUpdateEnd(state);
112030: 
112030:     pc = state.loop.updatepc;
112030: 
112030:     state.state = CFGState::FOR_LOOP_UPDATE;
112030:     state.stopAt = state.loop.updateEnd;
112030:     return ControlStatus_Jumped;
112030: }
112030: 
112030: IonBuilder::ControlStatus
112030: IonBuilder::processForUpdateEnd(CFGState &state)
112030: {
112030:     // If there is no current, we couldn't reach the loop edge and there was no
112030:     // update clause.
112030:     if (!current)
112030:         return processBrokenLoop(state);
112030: 
112030:     current->end(MGoto::New(state.loop.entry));
112030:     return finishLoop(state, state.loop.successor);
112030: }
112030: 
111664: bool
111665: IonBuilder::processDeferredContinues(CFGState &state)
111664: {
111664:     // If there are any continues for this loop, and there is an update block,
111664:     // then we need to create a new basic block to house the update.
111664:     if (state.loop.continues) {
111742:         DeferredEdge *edge = state.loop.continues;
111742: 
112769:         MBasicBlock *update = newBlock(edge->block, loops_.back().continuepc);
111683:         if (!update)
111683:             return false;
111683: 
111664:         if (current) {
111683:             current->end(MGoto::New(update));
111664:             if (!update->addPredecessor(current))
111664:                 return ControlStatus_Error;
111664:         }
111664: 
111742:         // No need to use addPredecessor for first edge,
111742:         // because it is already predecessor.
111742:         edge->block->end(MGoto::New(update));
111742:         edge = edge->next;
111742: 
111742:         // Remaining edges
111664:         while (edge) {
111683:             edge->block->end(MGoto::New(update));
111664:             if (!update->addPredecessor(edge->block))
111664:                 return ControlStatus_Error;
111664:             edge = edge->next;
111664:         }
111664:         state.loop.continues = NULL;
111664: 
111664:         current = update;
111664:     }
111664: 
111664:     return true;
111664: }
111664: 
111929: MBasicBlock *
111929: IonBuilder::createBreakCatchBlock(DeferredEdge *edge, jsbytecode *pc)
111929: {
111929:     // Create block, using the first break statement as predecessor
111929:     MBasicBlock *successor = newBlock(edge->block, pc);
111929:     if (!successor)
111929:         return NULL;
111929: 
111929:     // No need to use addPredecessor for first edge,
111929:     // because it is already predecessor.
111929:     edge->block->end(MGoto::New(successor));
111929:     edge = edge->next;
111929: 
111929:     // Finish up remaining breaks.
111929:     while (edge) {
111929:         edge->block->end(MGoto::New(successor));
111929:         if (!successor->addPredecessor(edge->block))
111929:             return NULL;
111929:         edge = edge->next;
111929:     }
111929: 
111929:     return successor;
111929: }
111929: 
111665: IonBuilder::ControlStatus
111929: IonBuilder::processNextTableSwitchCase(CFGState &state)
111929: {
111929:     JS_ASSERT(state.state == CFGState::TABLE_SWITCH);
111929: 
112843:     state.tableswitch.currentBlock++;
111929: 
111929:     // Test if there are still unprocessed successors (cases/default)
112843:     if (state.tableswitch.currentBlock >= state.tableswitch.ins->numBlocks())
124883:         return processSwitchEnd(state.tableswitch.breaks, state.tableswitch.exitpc);
111929: 
111929:     // Get the next successor
112843:     MBasicBlock *successor = state.tableswitch.ins->getBlock(state.tableswitch.currentBlock);
111929: 
111929:     // Add current block as predecessor if available.
111929:     // This means the previous case didn't have a break statement.
111929:     // So flow will continue in this block.
111929:     if (current) {
111929:         current->end(MGoto::New(successor));
111929:         successor->addPredecessor(current);
112870: 
112870:         // Insert successor after the current block, to maintain RPO.
113485:         graph().moveBlockToEnd(successor);
111929:     }
111929: 
111929:     // If this is the last successor the block should stop at the end of the tableswitch
111929:     // Else it should stop at the start of the next successor
112843:     if (state.tableswitch.currentBlock+1 < state.tableswitch.ins->numBlocks())
112843:         state.stopAt = state.tableswitch.ins->getBlock(state.tableswitch.currentBlock+1)->pc();
111929:     else
111929:         state.stopAt = state.tableswitch.exitpc;
111929: 
111929:     current = successor;
111929:     pc = current->pc();
111929:     return ControlStatus_Jumped;
111929: }
111929: 
111929: IonBuilder::ControlStatus
113028: IonBuilder::processNextLookupSwitchCase(CFGState &state)
113028: {
113028:     JS_ASSERT(state.state == CFGState::LOOKUP_SWITCH);
113028: 
113028:     size_t curBlock = state.lookupswitch.currentBlock;
113028:     IonSpew(IonSpew_MIR, "processNextLookupSwitchCase curBlock=%d", curBlock);
113028: 
113028:     state.lookupswitch.currentBlock = ++curBlock;
113028: 
113028:     // Test if there are still unprocessed successors (cases/default)
113028:     if (curBlock >= state.lookupswitch.bodies->length())
124883:         return processSwitchEnd(state.lookupswitch.breaks, state.lookupswitch.exitpc);
113028: 
113028:     // Get the next successor
113028:     MBasicBlock *successor = (*state.lookupswitch.bodies)[curBlock];
113028: 
113028:     // Add current block as predecessor if available.
113028:     // This means the previous case didn't have a break statement.
113028:     // So flow will continue in this block.
113028:     if (current) {
113028:         current->end(MGoto::New(successor));
113028:         successor->addPredecessor(current);
113028:     }
113028: 
113044:     // Move next body block to end to maintain RPO.
113485:     graph().moveBlockToEnd(successor);
113044: 
113028:     // If this is the last successor the block should stop at the end of the lookupswitch
113028:     // Else it should stop at the start of the next successor
113028:     if (curBlock + 1 < state.lookupswitch.bodies->length())
113028:         state.stopAt = (*state.lookupswitch.bodies)[curBlock + 1]->pc();
113028:     else
113028:         state.stopAt = state.lookupswitch.exitpc;
113028: 
113028:     current = successor;
113028:     pc = current->pc();
113028:     return ControlStatus_Jumped;
113028: }
113028: 
113028: IonBuilder::ControlStatus
112205: IonBuilder::processAndOrEnd(CFGState &state)
112205: {
112205:     // We just processed the RHS of an && or || expression.
112205:     // Now jump to the join point (the false block).
112205:     current->end(MGoto::New(state.branch.ifFalse));
112205: 
112205:     if (!state.branch.ifFalse->addPredecessor(current))
112205:         return ControlStatus_Error;
112205: 
112205:     current = state.branch.ifFalse;
113485:     graph().moveBlockToEnd(current);
112205:     pc = current->pc();
112205:     return ControlStatus_Joined;
112205: }
112205: 
112205: IonBuilder::ControlStatus
111665: IonBuilder::processBreak(JSOp op, jssrcnote *sn)
111662: {
112410:     JS_ASSERT(op == JSOP_GOTO);
111662: 
111663:     // Find the target loop.
111663:     CFGState *found = NULL;
111663:     jsbytecode *target = pc + GetJumpOffset(pc);
111663:     for (size_t i = loops_.length() - 1; i < loops_.length(); i--) {
111663:         CFGState &cfg = cfgStack_[loops_[i].cfgEntry];
111663:         if (cfg.loop.exitpc == target) {
111663:             found = &cfg;
111663:             break;
111663:         }
111663:     }
111662: 
112048:     if (!found) {
112048:         // Sometimes, we can't determine the structure of a labeled break. For
112048:         // example:
112048:         //
112048:         // 0:    label: {
112048:         // 1:        for (;;) {
112048:         // 2:            break label;
112048:         // 3:        }
112048:         // 4:        stuff;
112048:         // 5:    }
112048:         //
112048:         // In this case, the successor of the block is 4, but the target of the
112048:         // single-level break is actually 5. To recognize this case we'd need
112048:         // to know about the label structure at 0,5 ahead of time - and lacking
112048:         // those source notes for now, we just abort instead.
112048:         abort("could not find the target of a break");
112048:         return ControlStatus_Error;
112048:     }
112048: 
111663:     // There must always be a valid target loop structure. If not, there's
111663:     // probably an off-by-something error in which pc we track.
111663:     CFGState &state = *found;
111662: 
111683:     state.loop.breaks = new DeferredEdge(current, state.loop.breaks);
111662: 
111662:     current = NULL;
111662:     pc += js_CodeSpec[op].length;
111662:     return processControlEnd();
111662: }
111662: 
112795: static inline jsbytecode *
112795: EffectiveContinue(jsbytecode *pc)
112795: {
112795:     if (JSOp(*pc) == JSOP_GOTO)
112795:         return pc + GetJumpOffset(pc);
112795:     return pc;
112795: }
112795: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processContinue(JSOp op, jssrcnote *sn)
111661: {
112410:     JS_ASSERT(op == JSOP_GOTO);
111661: 
111663:     // Find the target loop.
111663:     CFGState *found = NULL;
111663:     jsbytecode *target = pc + GetJumpOffset(pc);
111663:     for (size_t i = loops_.length() - 1; i < loops_.length(); i--) {
112795:         if (loops_[i].continuepc == target ||
112795:             EffectiveContinue(loops_[i].continuepc) == target)
112795:         {
111668:             found = &cfgStack_[loops_[i].cfgEntry];
111663:             break;
111663:         }
111663:     }
111661: 
111663:     // There must always be a valid target loop structure. If not, there's
111663:     // probably an off-by-something error in which pc we track.
111663:     JS_ASSERT(found);
111663:     CFGState &state = *found;
111661: 
111683:     state.loop.continues = new DeferredEdge(current, state.loop.continues);
111661: 
111661:     current = NULL;
111662:     pc += js_CodeSpec[op].length;
111661:     return processControlEnd();
111655: }
111655: 
111665: IonBuilder::ControlStatus
111929: IonBuilder::processSwitchBreak(JSOp op, jssrcnote *sn)
111929: {
112410:     JS_ASSERT(op == JSOP_GOTO);
111929: 
111929:     // Find the target switch.
111929:     CFGState *found = NULL;
111929:     jsbytecode *target = pc + GetJumpOffset(pc);
111929:     for (size_t i = switches_.length() - 1; i < switches_.length(); i--) {
111929:         if (switches_[i].continuepc == target) {
111929:             found = &cfgStack_[switches_[i].cfgEntry];
111929:             break;
111929:         }
111929:     }
111929: 
111929:     // There must always be a valid target loop structure. If not, there's
111929:     // probably an off-by-something error in which pc we track.
111929:     JS_ASSERT(found);
111929:     CFGState &state = *found;
111929: 
124883:     DeferredEdge **breaks = NULL;
124883:     switch (state.state) {
124883:       case CFGState::TABLE_SWITCH:
124883:         breaks = &state.tableswitch.breaks;
124883:         break;
124883:       case CFGState::LOOKUP_SWITCH:
124883:         breaks = &state.lookupswitch.breaks;
124883:         break;
124883:       case CFGState::COND_SWITCH_BODY:
124883:         breaks = &state.condswitch.breaks;
124883:         break;
124883:       default:
124883:         JS_NOT_REACHED("Unexpected switch state.");
124883:         return ControlStatus_Error;
124883:     }
124883: 
124883:     *breaks = new DeferredEdge(current, *breaks);
111929: 
111929:     current = NULL;
111929:     pc += js_CodeSpec[op].length;
111929:     return processControlEnd();
111929: }
111929: 
111929: IonBuilder::ControlStatus
124883: IonBuilder::processSwitchEnd(DeferredEdge *breaks, jsbytecode *exitpc)
124883: {
124883:     // No break statements, no current.
124883:     // This means that control flow is cut-off from this point
124883:     // (e.g. all cases have return statements).
124883:     if (!breaks && !current)
124883:         return ControlStatus_Ended;
124883: 
124883:     // Create successor block.
124883:     // If there are breaks, create block with breaks as predecessor
124883:     // Else create a block with current as predecessor
124883:     MBasicBlock *successor = NULL;
124883:     if (breaks)
124883:         successor = createBreakCatchBlock(breaks, exitpc);
124883:     else
124883:         successor = newBlock(current, exitpc);
124883: 
124883:     if (!successor)
124883:         return ControlStatus_Ended;
124883: 
124883:     // If there is current, the current block flows into this one.
124883:     // So current is also a predecessor to this block
124883:     if (current) {
124883:         current->end(MGoto::New(successor));
124883:         if (breaks)
124883:             successor->addPredecessor(current);
124883:     }
124883: 
124883:     pc = exitpc;
124883:     current = successor;
124883:     return ControlStatus_Joined;
124883: }
124883: 
124883: IonBuilder::ControlStatus
111665: IonBuilder::maybeLoop(JSOp op, jssrcnote *sn)
111655: {
111655:     // This function looks at the opcode and source note and tries to
111655:     // determine the structure of the loop. For some opcodes, like
111655:     // POP/NOP which are not explicitly control flow, this source note is
111655:     // optional. For opcodes with control flow, like GOTO, an unrecognized
111655:     // or not-present source note is a compilation failure.
111655:     switch (op) {
111655:       case JSOP_POP:
111655:         // for (init; ; update?) ...
111664:         if (sn && SN_TYPE(sn) == SRC_FOR) {
111664:             current->pop();
111655:             return forLoop(op, sn);
111664:         }
111655:         break;
111655: 
111655:       case JSOP_NOP:
111655:         if (sn) {
111655:             // do { } while (cond)
111655:             if (SN_TYPE(sn) == SRC_WHILE)
111655:                 return doWhileLoop(op, sn);
111718:             // Build a mapping such that given a basic block, whose successor
111718:             // has a phi
111655: 
111655:             // for (; ; update?)
111655:             if (SN_TYPE(sn) == SRC_FOR)
111655:                 return forLoop(op, sn);
111655:         }
111655:         break;
111655: 
111655:       default:
111655:         JS_NOT_REACHED("unexpected opcode");
111664:         return ControlStatus_Error;
111655:     }
111655: 
111664:     return ControlStatus_None;
111655: }
111655: 
111655: void
112397: IonBuilder::assertValidLoopHeadOp(jsbytecode *pc)
111655: {
111655: #ifdef DEBUG
112397:     JS_ASSERT(JSOp(*pc) == JSOP_LOOPHEAD);
112397: 
112449:     // Make sure this is the next opcode after the loop header,
112449:     // unless the for loop is unconditional.
112397:     CFGState &state = cfgStack_.back();
112449:     JS_ASSERT_IF((JSOp)*(state.loop.entry->pc()) == JSOP_GOTO,
112449:         GetNextPc(state.loop.entry->pc()) == pc);
112397: 
112397:     // do-while loops have a source note.
112139:     jssrcnote *sn = info().getNote(cx, pc);
112397:     if (sn) {
111655:         jsbytecode *ifne = pc + js_GetSrcNoteOffset(sn, 0);
111655: 
111655:         jsbytecode *expected_ifne;
111655:         switch (state.state) {
111774:           case CFGState::DO_WHILE_LOOP_BODY:
112397:             expected_ifne = state.loop.updateEnd;
111655:             break;
111655: 
111655:           default:
112397:             JS_NOT_REACHED("JSOP_LOOPHEAD unexpected source note");
111655:             return;
111655:         }
111655: 
112249:         // Make sure this loop goes to the same ifne as the loop header's
111655:         // source notes or GOTO.
111655:         JS_ASSERT(ifne == expected_ifne);
112397:     } else {
112397:         JS_ASSERT(state.state != CFGState::DO_WHILE_LOOP_BODY);
112397:     }
111655: #endif
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::doWhileLoop(JSOp op, jssrcnote *sn)
111655: {
111774:     // do { } while() loops have the following structure:
111774:     //    NOP         ; SRC_WHILE (offset to COND)
112397:     //    LOOPHEAD    ; SRC_WHILE (offset to IFNE)
112504:     //    LOOPENTRY
111774:     //    ...         ; body
111774:     //    ...
111774:     //    COND        ; start of condition
111774:     //    ...
112397:     //    IFNE ->     ; goes to LOOPHEAD
111774:     int condition_offset = js_GetSrcNoteOffset(sn, 0);
111774:     jsbytecode *conditionpc = pc + condition_offset;
111774: 
112139:     jssrcnote *sn2 = info().getNote(cx, pc+1);
111774:     int offset = js_GetSrcNoteOffset(sn2, 0);
111774:     jsbytecode *ifne = pc + offset + 1;
111655:     JS_ASSERT(ifne > pc);
111655: 
112249:     // Verify that the IFNE goes back to a loophead op.
112512:     jsbytecode *loopHead = GetNextPc(pc);
112512:     JS_ASSERT(JSOp(*loopHead) == JSOP_LOOPHEAD);
112512:     JS_ASSERT(loopHead == ifne + GetJumpOffset(ifne));
112512: 
112512:     jsbytecode *loopEntry = GetNextPc(loopHead);
112504:     if (info().hasOsrAt(loopEntry)) {
113130:         MBasicBlock *preheader = newOsrPreheader(current, loopEntry);
112219:         if (!preheader)
112219:             return ControlStatus_Error;
112219:         current->end(MGoto::New(preheader));
112219:         current = preheader;
112219:     }
112219: 
111879:     MBasicBlock *header = newPendingLoopHeader(current, pc);
111683:     if (!header)
111664:         return ControlStatus_Error;
111683:     current->end(MGoto::New(header));
111655: 
111662:     jsbytecode *bodyStart = GetNextPc(GetNextPc(pc));
111774:     jsbytecode *bodyEnd = conditionpc;
111662:     jsbytecode *exitpc = GetNextPc(ifne);
114404:     if (!pushLoop(CFGState::DO_WHILE_LOOP_BODY, conditionpc, header,
114404:                   bodyStart, bodyEnd, exitpc, conditionpc))
114404:     {
111664:         return ControlStatus_Error;
114404:     }
111655: 
111774:     CFGState &state = cfgStack_.back();
111774:     state.loop.updatepc = conditionpc;
111774:     state.loop.updateEnd = ifne;
111774: 
112397:     current = header;
112397:     if (!jsop_loophead(GetNextPc(pc)))
112397:         return ControlStatus_Error;
112397: 
111743:     pc = bodyStart;
111664:     return ControlStatus_Jumped;
111655: }
111655: 
111665: IonBuilder::ControlStatus
112663: IonBuilder::whileOrForInLoop(JSOp op, jssrcnote *sn)
111658: {
111658:     // while (cond) { } loops have the following structure:
111658:     //    GOTO cond   ; SRC_WHILE (offset to IFNE)
112397:     //    LOOPHEAD
111658:     //    ...
111658:     //  cond:
112504:     //    LOOPENTRY
111658:     //    ...
112397:     //    IFNE        ; goes to LOOPHEAD
112663:     // for (x in y) { } loops are similar; the cond will be a MOREITER.
112663:     size_t which = (SN_TYPE(sn) == SRC_FOR_IN) ? 1 : 0;
112663:     int ifneOffset = js_GetSrcNoteOffset(sn, which);
111658:     jsbytecode *ifne = pc + ifneOffset;
111658:     JS_ASSERT(ifne > pc);
111658: 
112249:     // Verify that the IFNE goes back to a loophead op.
113130:     JS_ASSERT(JSOp(*GetNextPc(pc)) == JSOP_LOOPHEAD);
113130:     JS_ASSERT(GetNextPc(pc) == ifne + GetJumpOffset(ifne));
111658: 
112504:     jsbytecode *loopEntry = pc + GetJumpOffset(pc);
112504:     if (info().hasOsrAt(loopEntry)) {
113130:         MBasicBlock *preheader = newOsrPreheader(current, loopEntry);
112219:         if (!preheader)
112219:             return ControlStatus_Error;
112219:         current->end(MGoto::New(preheader));
112219:         current = preheader;
112219:     }
112219: 
111879:     MBasicBlock *header = newPendingLoopHeader(current, pc);
111683:     if (!header)
111664:         return ControlStatus_Error;
111683:     current->end(MGoto::New(header));
111658: 
112249:     // Skip past the JSOP_LOOPHEAD for the body start.
111658:     jsbytecode *bodyStart = GetNextPc(GetNextPc(pc));
111658:     jsbytecode *bodyEnd = pc + GetJumpOffset(pc);
111662:     jsbytecode *exitpc = GetNextPc(ifne);
111662:     if (!pushLoop(CFGState::WHILE_LOOP_COND, ifne, header, bodyStart, bodyEnd, exitpc))
111664:         return ControlStatus_Error;
111658: 
111658:     // Parse the condition first.
112397:     current = header;
112397:     if (!jsop_loophead(GetNextPc(pc)))
112397:         return ControlStatus_Error;
112397: 
111658:     pc = bodyEnd;
111664:     return ControlStatus_Jumped;
111664: }
111664: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::forLoop(JSOp op, jssrcnote *sn)
111664: {
111664:     // Skip the NOP or POP.
111664:     JS_ASSERT(op == JSOP_POP || op == JSOP_NOP);
111664:     pc = GetNextPc(pc);
111664: 
111664:     jsbytecode *condpc = pc + js_GetSrcNoteOffset(sn, 0);
111664:     jsbytecode *updatepc = pc + js_GetSrcNoteOffset(sn, 1);
111664:     jsbytecode *ifne = pc + js_GetSrcNoteOffset(sn, 2);
111664:     jsbytecode *exitpc = GetNextPc(ifne);
111664: 
111664:     // for loops have the following structures:
111664:     //
111664:     //   NOP or POP
112826:     //   [GOTO cond | NOP]
112397:     //   LOOPHEAD
111664:     // body:
111664:     //    ; [body]
111664:     // [increment:]
111664:     //    ; [increment]
111664:     // [cond:]
112504:     //   LOOPENTRY
111664:     //   GOTO body
111664:     //
111664:     // If there is a condition (condpc != ifne), this acts similar to a while
111664:     // loop otherwise, it acts like a do-while loop.
111664:     jsbytecode *bodyStart = pc;
111664:     jsbytecode *bodyEnd = updatepc;
112504:     jsbytecode *loopEntry = condpc;
111664:     if (condpc != ifne) {
112410:         JS_ASSERT(JSOp(*bodyStart) == JSOP_GOTO);
111664:         JS_ASSERT(bodyStart + GetJumpOffset(bodyStart) == condpc);
111664:         bodyStart = GetNextPc(bodyStart);
112504:     } else {
112826:         // No loop condition, such as for(j = 0; ; j++)
112903:         if (op != JSOP_NOP) {
112903:             // If the loop starts with POP, we have to skip a NOP.
112826:             JS_ASSERT(JSOp(*bodyStart) == JSOP_NOP);
112826:             bodyStart = GetNextPc(bodyStart);
112903:         }
112504:         loopEntry = GetNextPc(bodyStart);
111664:     }
112397:     jsbytecode *loopHead = bodyStart;
112249:     JS_ASSERT(JSOp(*bodyStart) == JSOP_LOOPHEAD);
111664:     JS_ASSERT(ifne + GetJumpOffset(ifne) == bodyStart);
111664:     bodyStart = GetNextPc(bodyStart);
111664: 
112504:     if (info().hasOsrAt(loopEntry)) {
113130:         MBasicBlock *preheader = newOsrPreheader(current, loopEntry);
112219:         if (!preheader)
112219:             return ControlStatus_Error;
112219:         current->end(MGoto::New(preheader));
112219:         current = preheader;
112219:     }
112219: 
111879:     MBasicBlock *header = newPendingLoopHeader(current, pc);
111683:     if (!header)
111664:         return ControlStatus_Error;
111683:     current->end(MGoto::New(header));
111664: 
111664:     // If there is no condition, we immediately parse the body. Otherwise, we
111664:     // parse the condition.
111664:     jsbytecode *stopAt;
111664:     CFGState::State initial;
111664:     if (condpc != ifne) {
111664:         pc = condpc;
111664:         stopAt = ifne;
111664:         initial = CFGState::FOR_LOOP_COND;
111664:     } else {
111664:         pc = bodyStart;
111664:         stopAt = bodyEnd;
111664:         initial = CFGState::FOR_LOOP_BODY;
111664:     }
111664: 
111950:     if (!pushLoop(initial, stopAt, header, bodyStart, bodyEnd, exitpc, updatepc))
111664:         return ControlStatus_Error;
111664: 
111664:     CFGState &state = cfgStack_.back();
111664:     state.loop.condpc = (condpc != ifne) ? condpc : NULL;
111664:     state.loop.updatepc = (updatepc != condpc) ? updatepc : NULL;
111664:     if (state.loop.updatepc)
111664:         state.loop.updateEnd = condpc;
111664: 
111664:     current = header;
112397:     if (!jsop_loophead(loopHead))
112397:         return ControlStatus_Error;
112397: 
111664:     return ControlStatus_Jumped;
111658: }
111658: 
112127: int
112127: IonBuilder::CmpSuccessors(const void *a, const void *b)
112127: {
112127:     const MBasicBlock *a0 = * (MBasicBlock * const *)a;
112127:     const MBasicBlock *b0 = * (MBasicBlock * const *)b;
112127:     if (a0->pc() == b0->pc())
112127:         return 0;
112127: 
112127:     return (a0->pc() > b0->pc()) ? 1 : -1;
112127: }
112127: 
111929: IonBuilder::ControlStatus
111929: IonBuilder::tableSwitch(JSOp op, jssrcnote *sn)
111929: {
111929:     // TableSwitch op contains the following data
111929:     // (length between data is JUMP_OFFSET_LEN)
111929:     //
111929:     // 0: Offset of default case
111929:     // 1: Lowest number in tableswitch
111929:     // 2: Highest number in tableswitch
112127:     // 3: Offset of case low
112127:     // 4: Offset of case low+1
111929:     // .: ...
112127:     // .: Offset of case high
111929: 
111929:     JS_ASSERT(op == JSOP_TABLESWITCH);
111929: 
111929:     // Pop input.
111929:     MDefinition *ins = current->pop();
111929: 
111929:     // Get the default and exit pc
111929:     jsbytecode *exitpc = pc + js_GetSrcNoteOffset(sn, 0);
111929:     jsbytecode *defaultpc = pc + GET_JUMP_OFFSET(pc);
111929: 
111929:     JS_ASSERT(defaultpc > pc && defaultpc <= exitpc);
111929: 
111929:     // Get the low and high from the tableswitch
111929:     jsbytecode *pc2 = pc;
111929:     pc2 += JUMP_OFFSET_LEN;
112809:     int low = GET_JUMP_OFFSET(pc2);
111929:     pc2 += JUMP_OFFSET_LEN;
112809:     int high = GET_JUMP_OFFSET(pc2);
111929:     pc2 += JUMP_OFFSET_LEN;
111929: 
111929:     // Create MIR instruction
111929:     MTableSwitch *tableswitch = MTableSwitch::New(ins, low, high);
111929: 
111929:     // Create default case
111929:     MBasicBlock *defaultcase = newBlock(current, defaultpc);
111929:     if (!defaultcase)
111929:         return ControlStatus_Error;
112127:     tableswitch->addDefault(defaultcase);
112843:     tableswitch->addBlock(defaultcase);
111929: 
111929:     // Create cases
112209:     jsbytecode *casepc = NULL;
112809:     for (int i = 0; i < high-low+1; i++) {
111929:         casepc = pc + GET_JUMP_OFFSET(pc2);
111929: 
112029:         JS_ASSERT(casepc >= pc && casepc <= exitpc);
111929: 
112843:         MBasicBlock *caseblock = newBlock(current, casepc);
112843:         if (!caseblock)
112843:             return ControlStatus_Error;
112843: 
112029:         // If the casepc equals the current pc, it is not a written case,
112029:         // but a filled gap. That way we can use a tableswitch instead of
112029:         // lookupswitch, even if not all numbers are consecutive.
112843:         // In that case this block goes to the default case
112029:         if (casepc == pc) {
112843:             caseblock->end(MGoto::New(defaultcase));
112843:             defaultcase->addPredecessor(caseblock);
112843:         }
112843: 
111929:         tableswitch->addCase(caseblock);
112843: 
112843:         // If this is an actual case (not filled gap),
112843:         // add this block to the list that still needs to get processed
112843:         if (casepc != pc)
112843:             tableswitch->addBlock(caseblock);
111929: 
111929:         pc2 += JUMP_OFFSET_LEN;
111929:     }
111929: 
112870:     // Move defaultcase to the end, to maintain RPO.
113485:     graph().moveBlockToEnd(defaultcase);
112870: 
124795:     JS_ASSERT(tableswitch->numCases() == (uint32_t)(high - low + 1));
111929:     JS_ASSERT(tableswitch->numSuccessors() > 0);
111929: 
112843:     // Sort the list of blocks that still needs to get processed by pc
112843:     qsort(tableswitch->blocks(), tableswitch->numBlocks(),
112127:           sizeof(MBasicBlock*), CmpSuccessors);
112127: 
111929:     // Create info
111929:     ControlFlowInfo switchinfo(cfgStack_.length(), exitpc);
111929:     if (!switches_.append(switchinfo))
111929:         return ControlStatus_Error;
111929: 
111929:     // Use a state to retrieve some information
113028:     CFGState state = CFGState::TableSwitch(exitpc, tableswitch);
111929: 
111929:     // Save the MIR instruction as last instruction of this block.
111929:     current->end(tableswitch);
111929: 
111929:     // If there is only one successor the block should stop at the end of the switch
111929:     // Else it should stop at the start of the next successor
113028:     if (tableswitch->numBlocks() > 1)
112843:         state.stopAt = tableswitch->getBlock(1)->pc();
112843:     current = tableswitch->getBlock(0);
111929: 
111929:     if (!cfgStack_.append(state))
111929:         return ControlStatus_Error;
111929: 
111929:     pc = current->pc();
111929:     return ControlStatus_Jumped;
111929: }
111929: 
113028: IonBuilder::ControlStatus
113028: IonBuilder::lookupSwitch(JSOp op, jssrcnote *sn)
113028: {
113028:     // LookupSwitch op looks as follows:
113028:     // DEFAULT  : JUMP_OFFSET           # jump offset (exitpc if no default block)
113028:     // NCASES   : UINT16                # number of cases
113028:     // CONST_1  : UINT32_INDEX          # case 1 constant index
113028:     // OFFSET_1 : JUMP_OFFSET           # case 1 offset
113028:     // ...
113028:     // CONST_N  : UINT32_INDEX          # case N constant index
113028:     // OFFSET_N : JUMP_OFFSET           # case N offset
113028: 
113028:     // A sketch of some of the design decisions on this code.
113028:     //
113028:     // 1. The bodies of case expressions may be shared, e.g.:
113028:     //   case FOO:
113028:     //   case BAR:
113028:     //     /* code */
113028:     //   case BAZ:
113028:     //     /* code */
113028:     //  In this cases we want to build a single codeblock for the conditionals (e.g. for FOO and BAR).
113028:     //
113028:     // 2. The ending MTest can only be added to a conditional block once the next conditional
113028:     //    block has been created, and ending MTest on the final conditional block can only be
113028:     //    added after the default body block has been created.
113028:     //
113028:     //    For the above two reasons, the loop keeps track of the previous iteration's major
113028:     //    components (cond block, body block, cmp instruction, body start pc, whether the
113028:     //    previous case had a shared body, etc.) and uses them in the next iteration.
113028:     //
113028:     // 3. The default body block may be shared with the body of a 'case'.  This is tested for
113028:     //    within the iteration loop in IonBuilder::lookupSwitch.  Also, the default body block
113028:     //    may not occur at the end of the switch statements, and instead may occur in between.
113028:     //
113028:     //    For this reason, the default body may be created within the loop (when a regular body
113028:     //    block is created, because the default body IS the regular body), or it will be created
113028:     //    after the loop.  It must then still be inserted into the right location into the list
113028:     //    of body blocks to process, which is done later in lookupSwitch.
113028: 
113028:     JS_ASSERT(op == JSOP_LOOKUPSWITCH);
113028: 
113028:     // Pop input.
113028:     MDefinition *ins = current->pop();
113028: 
113028:     // Get the default and exit pc
113028:     jsbytecode *exitpc = pc + js_GetSrcNoteOffset(sn, 0);
113028:     jsbytecode *defaultpc = pc + GET_JUMP_OFFSET(pc);
113028: 
113028:     JS_ASSERT(defaultpc > pc && defaultpc <= exitpc);
113028: 
113028:     // Get ncases, which will be >= 1, since a zero-case switch
113028:     // will get byte-compiled into a TABLESWITCH.
113028:     jsbytecode *pc2 = pc;
113028:     pc2 += JUMP_OFFSET_LEN;
113028:     unsigned int ncases = GET_UINT16(pc2);
113028:     pc2 += UINT16_LEN;
113028:     JS_ASSERT(ncases >= 1);
113028: 
113028:     // Vector of body blocks.
113028:     Vector<MBasicBlock*, 0, IonAllocPolicy> bodyBlocks;
113028: 
113028:     MBasicBlock *defaultBody = NULL;
113028:     unsigned int defaultIdx = UINT_MAX;
113028:     bool defaultShared = false;
113028: 
113028:     MBasicBlock *prevCond = NULL;
113028:     MCompare *prevCmpIns = NULL;
113028:     MBasicBlock *prevBody = NULL;
113028:     bool prevShared = false;
113028:     jsbytecode *prevpc = NULL;
113028:     for (unsigned int i = 0; i < ncases; i++) {
125568:         Value rval = script()->getConst(GET_UINT32_INDEX(pc2));
113028:         pc2 += UINT32_INDEX_LEN;
113028:         jsbytecode *casepc = pc + GET_JUMP_OFFSET(pc2);
113028:         pc2 += JUMP_OFFSET_LEN;
113028:         JS_ASSERT(casepc > pc && casepc <= exitpc);
113028:         JS_ASSERT_IF(i > 0, prevpc <= casepc);
113028: 
113028:         // Create case block
113028:         MBasicBlock *cond = newBlock(((i == 0) ? current : prevCond), casepc);
113028:         if (!cond)
113028:             return ControlStatus_Error;
113028: 
113028:         MConstant *rvalIns = MConstant::New(rval);
113028:         cond->add(rvalIns);
113028: 
113028:         MCompare *cmpIns = MCompare::New(ins, rvalIns, JSOP_STRICTEQ);
113028:         cond->add(cmpIns);
113028:         if (cmpIns->isEffectful() && !resumeAfter(cmpIns))
113028:             return ControlStatus_Error;
113028: 
113028:         // Create or pull forward body block
113028:         MBasicBlock *body;
113028:         if (prevpc == casepc) {
113028:             body = prevBody;
113028:         } else {
113028:             body = newBlock(cond, casepc);
113028:             if (!body)
113028:                 return ControlStatus_Error;
113028:             bodyBlocks.append(body);
113028:         }
113028: 
113028:         // Check for default body
113028:         if (defaultpc <= casepc && defaultIdx == UINT_MAX) {
113028:             defaultIdx = bodyBlocks.length() - 1;
113028:             if (defaultpc == casepc) {
113028:                 defaultBody = body;
113028:                 defaultShared = true;
113028:             }
113028:         }
113028: 
113028:         // Go back and fill in the MTest for the previous case block, or add the MGoto
113028:         // to the current block
113028:         if (i == 0) {
113028:             // prevCond is definitely NULL, end 'current' with MGoto to this case.
113028:             current->end(MGoto::New(cond));
113028:         } else {
113028:             // End previous conditional block with an MTest.
126213:             MTest *test = MTest::New(prevCmpIns, prevBody, cond);
126213:             prevCond->end(test);
113028: 
113028:             // If the previous cond shared its body with a prior cond, then
113028:             // add the previous cond as a predecessor to its body (since it's
113028:             // now finished).
113028:             if (prevShared)
113028:                 prevBody->addPredecessor(prevCond);
113028:         }
113028: 
113028:         // Save the current cond block, compare ins, and body block for next iteration
113028:         prevCond = cond;
113028:         prevCmpIns = cmpIns;
113028:         prevBody = body;
113028:         prevShared = (prevpc == casepc);
113028:         prevpc = casepc;
113028:     }
113028: 
113028:     // Create a new default body block if one was not already created.
113028:     if (!defaultBody) {
113028:         JS_ASSERT(!defaultShared);
113028:         defaultBody = newBlock(prevCond, defaultpc);
113028:         if (!defaultBody)
113028:             return ControlStatus_Error;
113028: 
113028:         if (defaultIdx >= bodyBlocks.length())
113028:             bodyBlocks.append(defaultBody);
113028:         else
113028:             bodyBlocks.insert(&bodyBlocks[defaultIdx], defaultBody);
113028:     }
113028: 
113028:     // Add edge from last conditional block to the default block
113028:     if (defaultBody == prevBody) {
113028:         // Last conditional block goes to default body on both comparison
113028:         // success and comparison failure.
113028:         prevCond->end(MGoto::New(defaultBody));
113028:     } else {
113028:         // Last conditional block has body that is distinct from
113028:         // the default block.
126213:         MTest *test = MTest::New(prevCmpIns, prevBody, defaultBody);
126213:         prevCond->end(test);
113028: 
113028:         // Add the cond as a predecessor as a default, but only if
113028:         // the default is shared with another block, because otherwise
113028:         // the default block would have been constructed with the final
113028:         // cond as its predecessor anyway.
113028:         if (defaultShared)
113028:             defaultBody->addPredecessor(prevCond);
113028:     }
113028: 
113028:     // If the last cond shared its body with a prior cond, then
113028:     // it needs to be explicitly added as a predecessor now that it's finished.
113028:     if (prevShared)
113028:         prevBody->addPredecessor(prevCond);
113028: 
113028:     // Create CFGState
113028:     CFGState state = CFGState::LookupSwitch(exitpc);
124739:     if (!state.lookupswitch.bodies || !state.lookupswitch.bodies->init(bodyBlocks.length()))
113028:         return ControlStatus_Error;
113028: 
113028:     // Fill bodies in CFGState using bodies in bodyBlocks, move them to
113028:     // end in order in order to maintain RPO
113028:     for (size_t i = 0; i < bodyBlocks.length(); i++) {
113028:         (*state.lookupswitch.bodies)[i] = bodyBlocks[i];
113028:     }
113485:     graph().moveBlockToEnd(bodyBlocks[0]);
113028: 
113028:     // Create control flow info
113028:     ControlFlowInfo switchinfo(cfgStack_.length(), exitpc);
113028:     if (!switches_.append(switchinfo))
113028:         return ControlStatus_Error;
113028: 
113028:     // If there is more than one block, next stopAt is at beginning of second block.
113028:     if (state.lookupswitch.bodies->length() > 1)
113028:         state.stopAt = (*state.lookupswitch.bodies)[1]->pc();
113028:     if (!cfgStack_.append(state))
113028:         return ControlStatus_Error;
113028: 
113028:     current = (*state.lookupswitch.bodies)[0];
113028:     pc = current->pc();
113028:     return ControlStatus_Jumped;
113028: }
113028: 
112205: bool
124883: IonBuilder::jsop_condswitch()
124883: {
124883:     // CondSwitch op looks as follows:
124883:     //   condswitch [length +exit_pc; first case offset +next-case ]
124883:     //   {
124883:     //     {
124883:     //       ... any code ...
124883:     //       case (+jump) [pcdelta offset +next-case]
124883:     //     }+
124883:     //     default (+jump)
124883:     //     ... jump targets ...
124883:     //   }
124883:     //
124883:     // The default case is always emitted even if there is no default case in
124883:     // the source.  The last case statement pcdelta source note might have a 0
124883:     // offset on the last case (not all the time).
124883:     //
124883:     // A conditional evaluate the condition of each case and compare it to the
124883:     // switch value with a strict equality.  Cases conditions are iterated
124883:     // linearly until one is matching. If one case succeeds, the flow jumps into
124883:     // the corresponding body block.  The body block might alias others and
124883:     // might continue in the next body block if the body is not terminated with
124883:     // a break.
124883:     //
124883:     // Algorithm:
124883:     //  1/ Loop over the case chain to reach the default target
124883:     //   & Estimate the number of uniq bodies.
124883:     //  2/ Generate code for all cases (see processCondSwitchCase).
124883:     //  3/ Generate code for all bodies (see processCondSwitchBody).
124883: 
124883:     JS_ASSERT(JSOp(*pc) == JSOP_CONDSWITCH);
124883:     jssrcnote *sn = info().getNote(cx, pc);
124883: 
124883:     // Get the exit pc
124883:     jsbytecode *exitpc = pc + js_GetSrcNoteOffset(sn, 0);
124883:     jsbytecode *firstCase = pc + js_GetSrcNoteOffset(sn, 1);
124883: 
124883:     // Iterate all cases in the conditional switch.
124883:     // - Stop at the default case. (always emitted after the last case)
124883:     // - Estimate the number of uniq bodies. This estimation might be off by 1
124883:     //   if the default body alias a case body.
124883:     jsbytecode *curCase = firstCase;
124883:     jsbytecode *lastTarget = GetJumpOffset(curCase) + curCase;
124883:     size_t nbBodies = 2; // default target and the first body.
124883: 
124883:     JS_ASSERT(pc < curCase && curCase <= exitpc);
124883:     while (JSOp(*curCase) == JSOP_CASE) {
124883:         // Fetch the next case.
124883:         jssrcnote *caseSn = info().getNote(cx, curCase);
124883:         JS_ASSERT(caseSn && SN_TYPE(caseSn) == SRC_PCDELTA);
124883:         ptrdiff_t off = js_GetSrcNoteOffset(caseSn, 0);
124883:         curCase = off ? curCase + off : GetNextPc(curCase);
124883:         JS_ASSERT(pc < curCase && curCase <= exitpc);
124883: 
124883:         // Count non-aliased cases.
124883:         jsbytecode *curTarget = GetJumpOffset(curCase) + curCase;
124883:         if (lastTarget < curTarget)
124883:             nbBodies++;
124883:         lastTarget = curTarget;
124883:     }
124883: 
124883:     // The current case now be the default case which jump to the body of the
124883:     // default case, which might be behind the last target.
124883:     JS_ASSERT(JSOp(*curCase) == JSOP_DEFAULT);
124883:     jsbytecode *defaultTarget = GetJumpOffset(curCase) + curCase;
124883:     JS_ASSERT(curCase < defaultTarget && defaultTarget <= exitpc);
124883: 
124883:     // Allocate the current graph state.
124883:     CFGState state = CFGState::CondSwitch(exitpc, defaultTarget);
124883:     if (!state.condswitch.bodies || !state.condswitch.bodies->init(nbBodies))
124883:         return ControlStatus_Error;
124883: 
124883:     // We loop on case conditions with processCondSwitchCase.
124883:     JS_ASSERT(JSOp(*firstCase) == JSOP_CASE);
124883:     state.stopAt = firstCase;
124883:     state.state = CFGState::COND_SWITCH_CASE;
124883: 
124883:     return cfgStack_.append(state);
124883: }
124883: 
124883: IonBuilder::CFGState
124883: IonBuilder::CFGState::CondSwitch(jsbytecode *exitpc, jsbytecode *defaultTarget)
124883: {
124883:     CFGState state;
124883:     state.state = COND_SWITCH_CASE;
124883:     state.stopAt = NULL;
124883:     state.condswitch.bodies = (FixedList<MBasicBlock *> *)GetIonContext()->temp->allocate(
124883:         sizeof(FixedList<MBasicBlock *>));
124883:     state.condswitch.currentIdx = 0;
124883:     state.condswitch.defaultTarget = defaultTarget;
124883:     state.condswitch.defaultIdx = uint32_t(-1);
124883:     state.condswitch.exitpc = exitpc;
124883:     state.condswitch.breaks = NULL;
124883:     return state;
124883: }
124883: 
124883: IonBuilder::ControlStatus
124883: IonBuilder::processCondSwitchCase(CFGState &state)
124883: {
124883:     JS_ASSERT(state.state == CFGState::COND_SWITCH_CASE);
124883:     JS_ASSERT(!state.condswitch.breaks);
124883:     JS_ASSERT(current);
124883:     JS_ASSERT(JSOp(*pc) == JSOP_CASE);
124883:     FixedList<MBasicBlock *> &bodies = *state.condswitch.bodies;
124883:     jsbytecode *defaultTarget = state.condswitch.defaultTarget;
124883:     uint32_t &currentIdx = state.condswitch.currentIdx;
124883:     jsbytecode *lastTarget = currentIdx ? bodies[currentIdx - 1]->pc() : NULL;
124883: 
124883:     // Fetch the following case in which we will continue.
124883:     jssrcnote *sn = info().getNote(cx, pc);
124883:     ptrdiff_t off = js_GetSrcNoteOffset(sn, 0);
124883:     jsbytecode *casePc = off ? pc + off : GetNextPc(pc);
124883:     bool caseIsDefault = JSOp(*casePc) == JSOP_DEFAULT;
124883:     JS_ASSERT(JSOp(*casePc) == JSOP_CASE || caseIsDefault);
124883: 
124883:     // Allocate the block of the matching case.
124883:     bool bodyIsNew = false;
124883:     MBasicBlock *bodyBlock = NULL;
124883:     jsbytecode *bodyTarget = pc + GetJumpOffset(pc);
124883:     if (lastTarget < bodyTarget) {
124883:         // If the default body is in the middle or aliasing the current target.
124883:         if (lastTarget < defaultTarget && defaultTarget <= bodyTarget) {
124883:             JS_ASSERT(state.condswitch.defaultIdx == uint32_t(-1));
124883:             state.condswitch.defaultIdx = currentIdx;
124883:             bodies[currentIdx] = NULL;
124883:             // If the default body does not alias any and it would be allocated
124883:             // later and stored in the defaultIdx location.
124883:             if (defaultTarget < bodyTarget)
124883:                 currentIdx++;
124883:         }
124883: 
124883:         bodyIsNew = true;
124883:         // Pop switch and case operands.
124883:         bodyBlock = newBlockPopN(current, bodyTarget, 2);
124883:         bodies[currentIdx++] = bodyBlock;
124883:     } else {
124883:         // This body alias the previous one.
124883:         JS_ASSERT(lastTarget == bodyTarget);
124883:         JS_ASSERT(currentIdx > 0);
124883:         bodyBlock = bodies[currentIdx - 1];
124883:     }
124883: 
124883:     if (!bodyBlock)
124883:         return ControlStatus_Error;
124883: 
124883:     lastTarget = bodyTarget;
124883: 
124883:     // Allocate the block of the non-matching case.  This can either be a normal
124883:     // case or the default case.
124883:     bool caseIsNew = false;
124883:     MBasicBlock *caseBlock = NULL;
124883:     if (!caseIsDefault) {
124883:         caseIsNew = true;
124883:         // Pop the case operand.
124883:         caseBlock = newBlockPopN(current, GetNextPc(pc), 1);
124883:     } else {
124883:         // The non-matching case is the default case, which jump directly to its
124883:         // body. Skip the creation of a default case block and directly create
124883:         // the default body if it does not alias any previous body.
124883: 
124883:         if (state.condswitch.defaultIdx == uint32_t(-1)) {
124883:             // The default target is the last target.
124883:             JS_ASSERT(lastTarget < defaultTarget);
124883:             state.condswitch.defaultIdx = currentIdx++;
124883:             caseIsNew = true;
124883:         } else if (bodies[state.condswitch.defaultIdx] == NULL) {
124883:             // The default target is in the middle and it does not alias any
124883:             // case target.
124883:             JS_ASSERT(defaultTarget < lastTarget);
124883:             caseIsNew = true;
124883:         } else {
124883:             // The default target is in the middle and it alias a case target.
124883:             JS_ASSERT(defaultTarget <= lastTarget);
124883:             caseBlock = bodies[state.condswitch.defaultIdx];
124883:         }
124883: 
124883:         // Allocate and register the default body.
124883:         if (caseIsNew) {
124883:             // Pop the case & switch operands.
124883:             caseBlock = newBlockPopN(current, defaultTarget, 2);
124883:             bodies[state.condswitch.defaultIdx] = caseBlock;
124883:         }
124883:     }
124883: 
124883:     if (!caseBlock)
124883:         return ControlStatus_Error;
124883: 
124883:     // Terminate the last case condition block by emitting the code
124883:     // corresponding to JSOP_CASE bytecode.
124883:     if (bodyBlock != caseBlock) {
124883:         MDefinition *caseOperand = current->pop();
124883:         MDefinition *switchOperand = current->peek(-1);
124883:         MCompare *cmpResult = MCompare::New(switchOperand, caseOperand, JSOP_STRICTEQ);
124883:         JS_ASSERT(!cmpResult->isEffectful());
124883:         current->add(cmpResult);
124883:         current->end(MTest::New(cmpResult, bodyBlock, caseBlock));
124883: 
124883:         // Add last case as predecessor of the body if the body is aliasing
124883:         // the previous case body.
124883:         if (!bodyIsNew && !bodyBlock->addPredecessorPopN(current, 1))
124883:             return ControlStatus_Error;
124883: 
124883:         // Add last case as predecessor of the non-matching case if the
124883:         // non-matching case is an aliased default case. We need to pop the
124883:         // switch operand as we skip the default case block and use the default
124883:         // body block directly.
124883:         JS_ASSERT_IF(!caseIsNew, caseIsDefault);
124883:         if (!caseIsNew && !caseBlock->addPredecessorPopN(current, 1))
124883:             return ControlStatus_Error;
124883:     } else {
124883:         // The default case alias the last case body.
124883:         JS_ASSERT(caseIsDefault);
124883:         current->pop(); // Case operand
124883:         current->pop(); // Switch operand
124883:         current->end(MGoto::New(bodyBlock));
124883:         if (!bodyIsNew && !bodyBlock->addPredecessor(current))
124883:             return ControlStatus_Error;
124883:     }
124883: 
124883:     if (caseIsDefault) {
124883:         // The last case condition is finished.  Loop in processCondSwitchBody,
124883:         // with potential stops in processSwitchBreak.  Check that the bodies
124883:         // fixed list is over-estimate by at most 1, and shrink the size such as
124883:         // length can be used as an upper bound while iterating bodies.
124883:         JS_ASSERT(currentIdx == bodies.length() || currentIdx + 1 == bodies.length());
124883:         bodies.shrink(bodies.length() - currentIdx);
124883: 
124883:         // Handle break statements in processSwitchBreak while processing
124883:         // bodies.
124883:         ControlFlowInfo breakInfo(cfgStack_.length() - 1, state.condswitch.exitpc);
124883:         if (!switches_.append(breakInfo))
124883:             return ControlStatus_Error;
124883: 
124883:         // Jump into the first body.
124883:         currentIdx = 0;
124883:         current = NULL;
124883:         state.state = CFGState::COND_SWITCH_BODY;
124883:         return processCondSwitchBody(state);
124883:     }
124883: 
124883:     // Continue until the case condition.
124883:     current = caseBlock;
124883:     pc = current->pc();
124883:     state.stopAt = casePc;
124883:     return ControlStatus_Jumped;
124883: }
124883: 
124883: IonBuilder::ControlStatus
124883: IonBuilder::processCondSwitchBody(CFGState &state)
124883: {
124883:     JS_ASSERT(state.state == CFGState::COND_SWITCH_BODY);
124883:     JS_ASSERT(pc <= state.condswitch.exitpc);
124883:     FixedList<MBasicBlock *> &bodies = *state.condswitch.bodies;
124883:     uint32_t &currentIdx = state.condswitch.currentIdx;
124883: 
124883:     JS_ASSERT(currentIdx <= bodies.length());
124883:     if (currentIdx == bodies.length()) {
124883:         JS_ASSERT_IF(current, pc == state.condswitch.exitpc);
124883:         return processSwitchEnd(state.condswitch.breaks, state.condswitch.exitpc);
124883:     }
124883: 
124883:     // Get the next body
124883:     MBasicBlock *nextBody = bodies[currentIdx++];
124883:     JS_ASSERT_IF(current, pc == nextBody->pc());
124883: 
124883:     // Fix the reverse post-order iteration.
124883:     graph().moveBlockToEnd(nextBody);
124883: 
124883:     // The last body continue into the new one.
124883:     if (current) {
124883:         current->end(MGoto::New(nextBody));
124883:         nextBody->addPredecessor(current);
124883:     }
124883: 
124883:     // Continue in the next body.
124883:     current = nextBody;
124883:     pc = current->pc();
124883: 
124883:     if (currentIdx < bodies.length())
124883:         state.stopAt = bodies[currentIdx]->pc();
124883:     else
124883:         state.stopAt = state.condswitch.exitpc;
124883:     return ControlStatus_Jumped;
124883: }
124883: 
124883: bool
112205: IonBuilder::jsop_andor(JSOp op)
112205: {
126213:     JS_ASSERT(op == JSOP_AND || op == JSOP_OR);
126213: 
112205:     jsbytecode *rhsStart = pc + js_CodeSpec[op].length;
112205:     jsbytecode *joinStart = pc + GetJumpOffset(pc);
112205:     JS_ASSERT(joinStart > pc);
112205: 
112205:     // We have to leave the LHS on the stack.
112205:     MDefinition *lhs = current->peek(-1);
112205: 
112205:     MBasicBlock *evalRhs = newBlock(current, rhsStart);
112205:     MBasicBlock *join = newBlock(current, joinStart);
112205:     if (!evalRhs || !join)
112205:         return false;
112205: 
126213:     MTest *test = (op == JSOP_AND)
126213:                   ? MTest::New(lhs, evalRhs, join)
126213:                   : MTest::New(lhs, join, evalRhs);
126213:     TypeOracle::UnaryTypes types = oracle->unaryTypes(script(), pc);
126213:     test->infer(types, cx);
126213:     current->end(test);
112205: 
112205:     if (!cfgStack_.append(CFGState::AndOr(joinStart, join)))
112205:         return false;
112205: 
112205:     current = evalRhs;
112205:     return true;
112205: }
111929: 
111658: bool
112229: IonBuilder::jsop_dup2()
112229: {
124795:     uint32_t lhsSlot = current->stackDepth() - 2;
124795:     uint32_t rhsSlot = current->stackDepth() - 1;
112229:     current->pushSlot(lhsSlot);
112229:     current->pushSlot(rhsSlot);
112229:     return true;
112229: }
112229: 
112229: bool
112397: IonBuilder::jsop_loophead(jsbytecode *pc)
112397: {
112397:     assertValidLoopHeadOp(pc);
113116: 
113116:     current->add(MInterruptCheck::New());
113116: 
112397:     return true;
112397: }
112397: 
112397: bool
111665: IonBuilder::jsop_ifeq(JSOp op)
111655: {
111655:     // IFEQ always has a forward offset.
111655:     jsbytecode *trueStart = pc + js_CodeSpec[op].length;
111655:     jsbytecode *falseStart = pc + GetJumpOffset(pc);
111655:     JS_ASSERT(falseStart > pc);
111655: 
111655:     // We only handle cases that emit source notes.
112139:     jssrcnote *sn = info().getNote(cx, pc);
112410:     if (!sn)
112410:         return abort("expected sourcenote");
111655: 
111795:     MDefinition *ins = current->pop();
111655: 
111655:     // Create true and false branches.
111655:     MBasicBlock *ifTrue = newBlock(current, trueStart);
111655:     MBasicBlock *ifFalse = newBlock(current, falseStart);
111683:     if (!ifTrue || !ifFalse)
111655:         return false;
111655: 
126213:     MTest *test = MTest::New(ins, ifTrue, ifFalse);
126213:     current->end(test);
111683: 
111655:     // The bytecode for if/ternary gets emitted either like this:
111655:     //
111655:     //    IFEQ X  ; src note (IF_ELSE, COND) points to the GOTO
111655:     //    ...
111655:     //    GOTO Z
111655:     // X: ...     ; else/else if
111655:     //    ...
111655:     // Z:         ; join
111655:     //
111655:     // Or like this:
111655:     //
111655:     //    IFEQ X  ; src note (IF) has no offset
111655:     //    ...
111655:     // Z: ...     ; join
111655:     //
111655:     // We want to parse the bytecode as if we were parsing the AST, so for the
111655:     // IF_ELSE/COND cases, we use the source note and follow the GOTO. For the
111655:     // IF case, the IFEQ offset is the join point.
111655:     switch (SN_TYPE(sn)) {
111655:       case SRC_IF:
111655:         if (!cfgStack_.append(CFGState::If(falseStart, ifFalse)))
111655:             return false;
111655:         break;
111655: 
111655:       case SRC_IF_ELSE:
111655:       case SRC_COND:
111655:       {
111655:         // Infer the join point from the JSOP_GOTO[X] sitting here, then
111655:         // assert as we much we can that this is the right GOTO.
111655:         jsbytecode *trueEnd = pc + js_GetSrcNoteOffset(sn, 0);
111655:         JS_ASSERT(trueEnd > pc);
111655:         JS_ASSERT(trueEnd < falseStart);
112410:         JS_ASSERT(JSOp(*trueEnd) == JSOP_GOTO);
112139:         JS_ASSERT(!info().getNote(cx, trueEnd));
111655: 
111655:         jsbytecode *falseEnd = trueEnd + GetJumpOffset(trueEnd);
111655:         JS_ASSERT(falseEnd > trueEnd);
111655:         JS_ASSERT(falseEnd >= falseStart);
111655: 
111655:         if (!cfgStack_.append(CFGState::IfElse(trueEnd, falseEnd, ifFalse)))
111655:             return false;
111655:         break;
111655:       }
111655: 
111655:       default:
111655:         JS_NOT_REACHED("unexpected source note type");
111655:         break;
111655:     }
111655: 
111655:     // Switch to parsing the true branch. Note that no PC update is needed,
111655:     // it's the next instruction.
111655:     current = ifTrue;
111655: 
111655:     return true;
111655: }
111655: 
111665: IonBuilder::ControlStatus
111665: IonBuilder::processReturn(JSOp op)
111655: {
111795:     MDefinition *def;
111655:     switch (op) {
111655:       case JSOP_RETURN:
111795:         def = current->pop();
111655:         break;
111655: 
111655:       case JSOP_STOP:
111795:       {
111795:         MInstruction *ins = MConstant::New(UndefinedValue());
111683:         current->add(ins);
111795:         def = ins;
111655:         break;
111795:       }
111655: 
111655:       default:
111795:         def = NULL;
111655:         JS_NOT_REACHED("unknown return op");
111655:         break;
111655:     }
111655: 
113449:     if (instrumentedProfiling())
125568:         current->add(MFunctionBoundary::New(script(), MFunctionBoundary::Exit));
111795:     MReturn *ret = MReturn::New(def);
111683:     current->end(ret);
111655: 
112206:     if (!graph().addExit(current))
112206:         return ControlStatus_Error;
112206: 
111655:     // Make sure no one tries to use this block now.
111655:     current = NULL;
111655:     return processControlEnd();
111655: }
111655: 
112478: IonBuilder::ControlStatus
112478: IonBuilder::processThrow()
112478: {
112478:     MDefinition *def = current->pop();
112478: 
112478:     MThrow *ins = MThrow::New(def);
112478:     current->end(ins);
112478: 
112478:     if (!graph().addExit(current))
112478:         return ControlStatus_Error;
112478: 
112478:     // Make sure no one tries to use this block now.
112478:     current = NULL;
112478:     return processControlEnd();
112478: }
112478: 
111655: bool
111665: IonBuilder::pushConstant(const Value &v)
111661: {
111677:     MConstant *ins = MConstant::New(v);
111683:     current->add(ins);
111661:     current->push(ins);
111661:     return true;
111661: }
111661: 
111661: bool
112016: IonBuilder::jsop_bitnot()
111977: {
111977:     MDefinition *input = current->pop();
111977:     MBitNot *ins = MBitNot::New(input);
111977: 
111977:     current->add(ins);
125568:     ins->infer(oracle->unaryTypes(script(), pc));
111977: 
111977:     current->push(ins);
112682:     if (ins->isEffectful() && !resumeAfter(ins))
112682:         return false;
111977:     return true;
111977: }
111977: bool
111800: IonBuilder::jsop_bitop(JSOp op)
111655: {
111679:     // Pop inputs.
111795:     MDefinition *right = current->pop();
111795:     MDefinition *left = current->pop();
111655: 
111803:     MBinaryBitwiseInstruction *ins;
111655:     switch (op) {
111655:       case JSOP_BITAND:
111677:         ins = MBitAnd::New(left, right);
111655:         break;
111655: 
111780:       case JSOP_BITOR:
111780:         ins = MBitOr::New(left, right);
111780:         break;
111780: 
111780:       case JSOP_BITXOR:
111798:         ins = MBitXor::New(left, right);
111780:         break;
111780: 
112026:       case JSOP_LSH:
112026:         ins = MLsh::New(left, right);
112026:         break;
112026: 
112026:       case JSOP_RSH:
112026:         ins = MRsh::New(left, right);
112026:         break;
112026: 
112026:       case JSOP_URSH:
112026:         ins = MUrsh::New(left, right);
112026:         break;
112026: 
111800:       default:
111800:         JS_NOT_REACHED("unexpected bitop");
111800:         return false;
111800:     }
111800: 
111800:     current->add(ins);
126213:     TypeOracle::BinaryTypes types = oracle->binaryTypes(script(), pc);
126213:     ins->infer(types);
111802: 
111800:     current->push(ins);
112749:     if (ins->isEffectful() && !resumeAfter(ins))
112749:         return false;
112749: 
111800:     return true;
111800: }
111800: 
111800: bool
112471: IonBuilder::jsop_binary(JSOp op, MDefinition *left, MDefinition *right)
112429: {
125568:     TypeOracle::Binary b = oracle->binaryOp(script(), pc);
112471: 
112471:     if (op == JSOP_ADD && b.rval == MIRType_String &&
112471:         (b.lhs == MIRType_String || b.lhs == MIRType_Int32) &&
112471:         (b.rhs == MIRType_String || b.rhs == MIRType_Int32))
112429:     {
112429:         MConcat *ins = MConcat::New(left, right);
112429:         current->add(ins);
112429:         current->push(ins);
124557:         return maybeInsertResume();
112429:     }
112429: 
111800:     MBinaryArithInstruction *ins;
111800:     switch (op) {
111700:       case JSOP_ADD:
112471:         ins = MAdd::New(left, right);
112471:         break;
111700: 
112068:       case JSOP_SUB:
112068:         ins = MSub::New(left, right);
112068:         break;
112068: 
112011:       case JSOP_MUL:
112011:         ins = MMul::New(left, right);
112011:         break;
112011: 
112072:       case JSOP_DIV:
112072:         ins = MDiv::New(left, right);
112072:         break;
112072: 
112345:       case JSOP_MOD:
112345:         ins = MMod::New(left, right);
112345:         break;
112345: 
111655:       default:
111655:         JS_NOT_REACHED("unexpected binary opcode");
111655:         return false;
111655:     }
111655: 
125568:     TypeOracle::BinaryTypes types = oracle->binaryTypes(script(), pc);
111683:     current->add(ins);
126213:     ins->infer(types, cx);
111655:     current->push(ins);
112471: 
112471:     if (ins->isEffectful())
112471:         return resumeAfter(ins);
124557:     return maybeInsertResume();
111655: }
111655: 
111983: bool
112088: IonBuilder::jsop_binary(JSOp op)
112088: {
112088:     MDefinition *right = current->pop();
112088:     MDefinition *left = current->pop();
112088: 
112088:     return jsop_binary(op, left, right);
112088: }
112088: 
112088: bool
112291: IonBuilder::jsop_pos()
112291: {
125568:     TypeOracle::Unary types = oracle->unaryOp(script(), pc);
113090:     if (IsNumberType(types.ival)) {
113090:         // Already int32 or double.
113213:         JS_ASSERT(IsNumberType(types.rval));
113090:         return true;
113090:     }
113090: 
113090:     // Compile +x as x * 1.
112291:     MDefinition *value = current->pop();
113090:     MConstant *one = MConstant::New(Int32Value(1));
113090:     current->add(one);
113090: 
113090:     return jsop_binary(JSOP_MUL, value, one);
112291: }
112291: 
112291: bool
112012: IonBuilder::jsop_neg()
112012: {
112088:     // Since JSOP_NEG does not use a slot, we cannot push the MConstant.
112088:     // The MConstant is therefore passed to JSOP_MUL without slot traffic.
112088:     MConstant *negator = MConstant::New(Int32Value(-1));
112088:     current->add(negator);
112012: 
112088:     MDefinition *right = current->pop();
112088: 
112088:     if (!jsop_binary(JSOP_MUL, negator, right))
112012:         return false;
112064:     return true;
112064: }
112012: 
112064: bool
112064: IonBuilder::jsop_notearg()
112064: {
112064:     // JSOP_NOTEARG notes that the value in current->pop() has just
112064:     // been pushed onto the stack for use in calling a function.
112064:     MDefinition *def = current->pop();
112064:     MPassArg *arg = MPassArg::New(def);
112064: 
112064:     current->add(arg);
112064:     current->push(arg);
112064:     return true;
112064: }
112064: 
113369: class AutoAccumulateExits
113369: {
113369:     MIRGraph &graph_;
113369:     MIRGraphExits *prev_;
113369: 
113369:   public:
113369:     AutoAccumulateExits(MIRGraph &graph, MIRGraphExits &exits) : graph_(graph) {
113369:         prev_ = graph_.exitAccumulator();
113369:         graph_.setExitAccumulator(&exits);
113369:     }
113369:     ~AutoAccumulateExits() {
113369:         graph_.setExitAccumulator(prev_);
113369:     }
113369: };
113369: 
113388: 
112064: bool
124795: IonBuilder::jsop_call_inline(HandleFunction callee, uint32_t argc, bool constructing,
113431:                              MConstant *constFun, MBasicBlock *bottom,
113431:                              Vector<MDefinition *, 8, IonAllocPolicy> &retvalDefns)
112206: {
119065:     AssertCanGC();
119065: 
126182:     int calleePos = -((int) argc + 2);
126182:     current->peek(calleePos)->setFoldedUnchecked();
126182: 
113482:     // Rewrite the stack position containing the function with the constant
113482:     // function definition, before we take the inlineResumePoint
126182:     current->rewriteAtDepth(calleePos, constFun);
113482: 
113431:     // This resume point collects outer variables only.  It is used to recover
113431:     // the stack state before the current bytecode.
113431:     MResumePoint *inlineResumePoint =
113431:         MResumePoint::New(current, pc, callerResumePoint_, MResumePoint::Outer);
113431:     if (!inlineResumePoint)
113431:         return false;
113431: 
113431:     // We do not inline JSOP_FUNCALL for now.
113431:     JS_ASSERT(argc == GET_ARGC(inlineResumePoint->pc()));
113431: 
113431:     // Gather up  the arguments and |this| to the inline function.
113431:     // Note that we leave the callee on the simulated stack for the
113431:     // duration of the call.
113431:     MDefinitionVector argv;
113431:     if (!argv.resizeUninitialized(argc + 1))
113431:         return false;
124795:     for (int32_t i = argc; i >= 0; i--)
113431:         argv[i] = current->pop();
113431: 
126423:     LifoAlloc *alloc = GetIonContext()->temp->lifoAlloc();
123827:     RootedScript calleeScript(cx, callee->nonLazyScript());
126423:     CompileInfo *info = alloc->new_<CompileInfo>(calleeScript.get(), callee,
121812:                                                  (jsbytecode *)NULL, constructing,
121812:                                                  SequentialExecution);
113369:     if (!info)
112206:         return false;
112206: 
113369:     MIRGraphExits saveExits;
113369:     AutoAccumulateExits aae(graph(), saveExits);
113369: 
113369:     TypeInferenceOracle oracle;
119065:     if (!oracle.init(cx, calleeScript))
112206:         return false;
112259: 
113485:     IonBuilder inlineBuilder(cx, &temp(), &graph(), &oracle,
113485:                              info, inliningDepth + 1, loopDepth_);
112900: 
113354:     // Create |this| on the caller-side for inlined constructors.
113354:     MDefinition *thisDefn = NULL;
113354:     if (constructing) {
113354:         thisDefn = createThis(callee, constFun);
113354:         if (!thisDefn)
113354:             return false;
113354:     } else {
113354:         thisDefn = argv[0];
113354:     }
112206: 
112206:     // Build the graph.
113431:     if (!inlineBuilder.buildInline(this, inlineResumePoint, thisDefn, argv))
112206:         return false;
112206: 
112753:     MIRGraphExits &exits = *inlineBuilder.graph().exitAccumulator();
112206: 
113354:     // Replace all MReturns with MGotos, and remember the MDefinition that
113354:     // would have been returned.
112206:     for (MBasicBlock **it = exits.begin(), **end = exits.end(); it != end; ++it) {
112206:         MBasicBlock *exitBlock = *it;
113354: 
113354:         MDefinition *rval = exitBlock->lastIns()->toReturn()->getOperand(0);
113354:         exitBlock->discardLastIns();
113354: 
113354:         // Inlined constructors return |this| unless overridden by another Object.
113354:         if (constructing) {
113354:             if (rval->type() == MIRType_Value) {
113354:                 MReturnFromCtor *filter = MReturnFromCtor::New(rval, thisDefn);
113486:                 exitBlock->add(filter);
113354:                 rval = filter;
113354:             } else if (rval->type() != MIRType_Object) {
113354:                 rval = thisDefn;
113354:             }
113354:         }
113354: 
113354:         if (!retvalDefns.append(rval))
112206:             return false;
112206: 
112206:         MGoto *replacement = MGoto::New(bottom);
112206:         exitBlock->end(replacement);
112206:         if (!bottom->addPredecessorWithoutPhis(exitBlock))
112206:             return false;
112206:     }
112206:     JS_ASSERT(!retvalDefns.empty());
112206:     return true;
112206: }
112206: 
112206: bool
124795: IonBuilder::makeInliningDecision(AutoObjectVector &targets, uint32_t argc)
112206: {
119065:     AssertCanGC();
119065: 
113370:     if (inliningDepth >= js_IonOptions.maxInlineDepth)
112874:         return false;
112206: 
113217:     // For "small" functions, we should be more aggressive about inlining.
113217:     // This is based on the following intuition:
113217:     //  1. The call overhead for a small function will likely be a much
113217:     //     higher proportion of the runtime of the function than for larger
113217:     //     functions.
113217:     //  2. The cost of inlining (in terms of size expansion of the SSA graph),
113217:     //     and size expansion of the ultimately generated code, will be
113217:     //     less significant.
115478:     //  3. Do not inline functions which are not called as frequently as their
115478:     //     callers.
115478: 
125568:     uint32_t callerUses = script()->getUseCount();
113217: 
113370:     uint32_t totalSize = 0;
113370:     uint32_t checkUses = js_IonOptions.usesBeforeInlining;
113370:     bool allFunctionsAreSmall = true;
119065:     RootedFunction target(cx);
125568:     RootedScript targetScript(cx);
113370:     for (size_t i = 0; i < targets.length(); i++) {
119065:         target = targets[i]->toFunction();
113370:         if (!target->isInterpreted())
113370:             return false;
113370: 
125568:         targetScript = target->nonLazyScript();
125568:         uint32_t calleeUses = targetScript->getUseCount();
118361: 
118361:         if (target->nargs < argc) {
118361:             IonSpew(IonSpew_Inlining, "Not inlining, overflow of arguments.");
118361:             return false;
118361:         }
118361: 
125568:         totalSize += targetScript->length;
113370:         if (totalSize > js_IonOptions.inlineMaxTotalBytecodeLength)
113370:             return false;
113370: 
125568:         if (targetScript->length > js_IonOptions.smallFunctionMaxBytecodeLength)
113370:             allFunctionsAreSmall = false;
115478: 
115478:         if (calleeUses * js_IonOptions.inlineUseCountRatio < callerUses) {
115478:             IonSpew(IonSpew_Inlining, "Not inlining, callee is not hot");
115478:             return false;
115478:         }
113370:     }
113370:     if (allFunctionsAreSmall)
113217:         checkUses = js_IonOptions.smallFunctionUsesBeforeInlining;
113217: 
125568:     if (script()->getUseCount() < checkUses) {
112397:         IonSpew(IonSpew_Inlining, "Not inlining, caller is not hot");
112874:         return false;
112397:     }
112397: 
125568:     RootedScript scriptRoot(cx, script());
125568:     if (!oracle->canInlineCall(scriptRoot, pc)) {
112720:         IonSpew(IonSpew_Inlining, "Cannot inline due to uninlineable call site");
112874:         return false;
112874:     }
112874: 
113370:     for (size_t i = 0; i < targets.length(); i++) {
113370:         if (!canInlineTarget(targets[i]->toFunction())) {
112874:             IonSpew(IonSpew_Inlining, "Decided not to inline");
112874:             return false;
112874:         }
113370:     }
112874: 
112720:     return true;
112720: }
112720: 
113482: static bool
113482: ValidateInlineableGetPropertyCache(MGetPropertyCache *getPropCache, MDefinition *thisDefn,
113482:                                    size_t maxUseCount)
113482: {
113482:     JS_ASSERT(getPropCache->object()->type() == MIRType_Object);
113482: 
113482:     if (getPropCache->useCount() > maxUseCount)
113482:         return false;
113482: 
113482:     // Ensure that the input to the GetPropertyCache is the thisDefn for this function.
113482:     if (getPropCache->object() != thisDefn)
113482:         return false;
113482: 
113482:     InlinePropertyTable *propTable = getPropCache->inlinePropertyTable();
113482:     if (!propTable || propTable->numEntries() == 0)
113482:         return false;
113482: 
113482:     return true;
113482: }
113482: 
113482: MGetPropertyCache *
113482: IonBuilder::checkInlineableGetPropertyCache(uint32_t argc)
113482: {
113482:     // Stack state:
113482:     // ..., Func, This, Arg1, ..., ArgC
113482:     // Note: PassArgs have already been eliminated.
113482: 
113482:     JS_ASSERT(current->stackDepth() >= argc + 2);
113482: 
113482:     // Ensure that This is object-typed.
113482:     int thisDefnDepth = -((int) argc + 1);
113482:     MDefinition *thisDefn = current->peek(thisDefnDepth);
113482:     if (thisDefn->type() != MIRType_Object)
113482:         return NULL;
113482: 
113482:     // Ensure that Func is defined by a GetPropertyCache that is then TypeBarriered and then
113482:     // infallibly Unboxed to an object.
113482:     int funcDefnDepth = -((int) argc + 2);
113482:     MDefinition *funcDefn = current->peek(funcDefnDepth);
113482:     if (funcDefn->type() != MIRType_Object)
113482:         return NULL;
113482: 
113482:     // If it's a constant, then ignore it since there's nothing to optimize: any potential
113482:     // GetProp that led to the funcDefn has already been optimized away.
113482:     if (funcDefn->isConstant())
113482:         return NULL;
113482: 
113482:     // Match patterns:
113482:     // 1. MGetPropertyCache
113482:     // 2. MUnbox[MIRType_Object, Infallible] <- MTypeBarrier <- MGetPropertyCache
113482: 
113482:     // If it's a GetPropertyCache, return it immediately, but make sure its not used anywhere
113482:     // else (because otherwise we wouldn't be able to move it).
113482:     if (funcDefn->isGetPropertyCache()) {
113482:         MGetPropertyCache *getPropCache = funcDefn->toGetPropertyCache();
113482:         if (!ValidateInlineableGetPropertyCache(getPropCache, thisDefn, 0))
113482:             return NULL;
113482: 
113482:         return getPropCache;
113482:     }
113482: 
113482:     // Check for MUnbox[MIRType_Object, Infallible] <- MTypeBarrier <- MGetPropertyCache
113482:     if (!funcDefn->isUnbox() || funcDefn->toUnbox()->useCount() > 0)
113482:         return NULL;
113482: 
113482:     MUnbox *unbox = current->peek(funcDefnDepth)->toUnbox();
113482:     if (unbox->mode() != MUnbox::Infallible || !unbox->input()->isTypeBarrier())
113482:         return NULL;
113482: 
113482:     MTypeBarrier *typeBarrier = unbox->input()->toTypeBarrier();
113482:     if (typeBarrier->useCount() != 1 || !typeBarrier->input()->isGetPropertyCache())
113482:         return NULL;
113482: 
113482:     MGetPropertyCache *getPropCache = typeBarrier->input()->toGetPropertyCache();
113482:     JS_ASSERT(getPropCache->object()->type() == MIRType_Object);
113482: 
113482:     if (!ValidateInlineableGetPropertyCache(getPropCache, thisDefn, 1))
113482:         return NULL;
113482: 
113482:     return getPropCache;
113482: }
113482: 
113482: MPolyInlineDispatch *
113482: IonBuilder::makePolyInlineDispatch(JSContext *cx, AutoObjectVector &targets, int argc,
113482:                                    MGetPropertyCache *getPropCache,
113609:                                    types::StackTypeSet *types, types::StackTypeSet *barrier,
113482:                                    MBasicBlock *bottom,
113482:                                    Vector<MDefinition *, 8, IonAllocPolicy> &retvalDefns)
113482: {
113482:     int funcDefnDepth = -((int) argc + 2);
113482:     MDefinition *funcDefn = current->peek(funcDefnDepth);
113482: 
113482:     // If we're not optimizing away a GetPropertyCache, then this is pretty simple.
113482:     if (!getPropCache)
113482:         return MPolyInlineDispatch::New(funcDefn);
113482: 
113482:     InlinePropertyTable *inlinePropTable = getPropCache->inlinePropertyTable();
113482: 
113482:     // Take a resumepoint at this point so we can capture the state of the stack
113482:     // immediately prior to the call operation.
113482:     MResumePoint *preCallResumePoint = MResumePoint::New(current, pc, callerResumePoint_,
113482:                                                          MResumePoint::ResumeAt);
113482:     if (!preCallResumePoint)
113482:         return NULL;
113620:     DebugOnly<size_t> preCallFuncDefnIdx = preCallResumePoint->numOperands() - (((size_t) argc) + 2);
113482:     JS_ASSERT(preCallResumePoint->getOperand(preCallFuncDefnIdx) == funcDefn);
113482: 
113482:     MDefinition *targetObject = getPropCache->object();
113482: 
113482:     // If we got here, then we know the following:
113482:     //      1. The input to the CALL is a GetPropertyCache, or a GetPropertyCache
113482:     //         followed by a TypeBarrier followed by an Unbox.
113482:     //      2. The GetPropertyCache has inlineable cases by guarding on the Object's type
113482:     //      3. The GetPropertyCache (and sequence of definitions) leading to the function
113482:     //         definition is not used by anyone else.
113482:     //      4. Notably, this means that no resume points as of yet capture the GetPropertyCache,
113482:     //         which implies that everything from the GetPropertyCache up to the call is
113482:     //         repeatable.
113482: 
113482:     // If we are optimizing away a getPropCache, we replace the funcDefn
113482:     // with a constant undefined on the stack.
113482:     MConstant *undef = MConstant::New(UndefinedValue());
113482:     current->add(undef);
113482:     current->rewriteAtDepth(funcDefnDepth, undef);
113482: 
113482:     // Now construct a fallbackPrepBlock that prepares the stack state for fallback.
113482:     // Namely it pops off all the arguments and the callee.
113482:     MBasicBlock *fallbackPrepBlock = newBlock(current, pc);
113482:     if (!fallbackPrepBlock)
113482:         return NULL;
113482: 
113482:     for (int i = argc + 1; i >= 0; i--)
113482:         (void) fallbackPrepBlock->pop();
113482: 
113482:     // Generate a fallback block that'll do the call, but the PC for this fallback block
113482:     // is the PC for the GetPropCache.
113482:     JS_ASSERT(inlinePropTable->pc() != NULL);
113482:     JS_ASSERT(inlinePropTable->priorResumePoint() != NULL);
113482:     MBasicBlock *fallbackBlock = newBlock(fallbackPrepBlock, inlinePropTable->pc(),
113482:                                           inlinePropTable->priorResumePoint());
113482:     if (!fallbackBlock)
113482:         return NULL;
113482: 
113482:     fallbackPrepBlock->end(MGoto::New(fallbackBlock));
113482: 
113482:     // The fallbackBlock inherits the state of the stack right before the getprop, which
113482:     // means we have to pop off the target of the getprop before performing it.
113482:     DebugOnly<MDefinition *> checkTargetObject = fallbackBlock->pop();
113482:     JS_ASSERT(checkTargetObject == targetObject);
113482: 
113482:     // Remove the instructions leading to the function definition from the current
113482:     // block and add them to the fallback block.  Also, discard the old instructions.
113482:     if (funcDefn->isGetPropertyCache()) {
113482:         JS_ASSERT(funcDefn->toGetPropertyCache() == getPropCache);
113482:         fallbackBlock->addFromElsewhere(getPropCache);
113482:         fallbackBlock->push(getPropCache);
113482:     } else {
113482:         JS_ASSERT(funcDefn->isUnbox());
113482:         MUnbox *unbox = funcDefn->toUnbox();
113482:         JS_ASSERT(unbox->input()->isTypeBarrier());
113482:         JS_ASSERT(unbox->type() == MIRType_Object);
113482:         JS_ASSERT(unbox->mode() == MUnbox::Infallible);
113482: 
113482:         MTypeBarrier *typeBarrier = unbox->input()->toTypeBarrier();
113482:         JS_ASSERT(typeBarrier->input()->isGetPropertyCache());
113482:         JS_ASSERT(typeBarrier->input()->toGetPropertyCache() == getPropCache);
113482: 
113482:         fallbackBlock->addFromElsewhere(getPropCache);
113482:         fallbackBlock->addFromElsewhere(typeBarrier);
113482:         fallbackBlock->addFromElsewhere(unbox);
113482:         fallbackBlock->push(unbox);
113482:     }
113482: 
113482:     // Finally create a fallbackEnd block to do the actual call.  The fallbackEnd block will
113482:     // have the |pc| restored to the current PC.
113482:     MBasicBlock *fallbackEndBlock = newBlock(fallbackBlock, pc, preCallResumePoint);
113482:     if (!fallbackEndBlock)
113482:         return NULL;
113482:     fallbackBlock->end(MGoto::New(fallbackEndBlock));
113482: 
113482:     // Create Call
113482:     MCall *call = MCall::New(NULL, argc + 1, argc, false);
113482:     if (!call)
113482:         return NULL;
113482: 
113482:     // Set up the MPrepCall
113482:     MPrepareCall *prepCall = new MPrepareCall;
113482:     fallbackEndBlock->add(prepCall);
113482: 
113482:     // Grab the arguments for the call directly from the current block's stack.
124795:     for (int32_t i = 0; i <= argc; i++) {
124795:         int32_t argno = argc - i;
113482:         MDefinition *argDefn = fallbackEndBlock->pop();
113482:         JS_ASSERT(!argDefn->isPassArg());
113482:         MPassArg *passArg = MPassArg::New(argDefn);
113482:         fallbackEndBlock->add(passArg);
113482:         call->addArg(argno, passArg);
113482:     }
113482: 
113482:     // Insert an MPrepareCall before the first argument.
113482:     call->initPrepareCall(prepCall);
113482: 
113482:     // Add the callee function definition to the call.
113482:     call->initFunction(fallbackEndBlock->pop());
113482: 
113482:     fallbackEndBlock->add(call);
113482:     fallbackEndBlock->push(call);
113482:     if (!resumeAfter(call))
113482:         return NULL;
113482: 
113482:     MBasicBlock *top = current;
113482:     current = fallbackEndBlock;
113482:     if (!pushTypeBarrier(call, types, barrier))
113482:         return NULL;
113482:     current = top;
113482: 
113482:     // Create a new MPolyInlineDispatch containing the getprop and the fallback block
113482:     return MPolyInlineDispatch::New(targetObject, inlinePropTable,
113482:                                     fallbackPrepBlock, fallbackBlock,
113482:                                     fallbackEndBlock);
113482: }
113482: 
112874: bool
124795: IonBuilder::inlineScriptedCall(AutoObjectVector &targets, uint32_t argc, bool constructing,
113609:                                types::StackTypeSet *types, types::StackTypeSet *barrier)
112206: {
113369: #ifdef DEBUG
124795:     uint32_t origStackDepth = current->stackDepth();
113369: #endif
113369: 
113482:     IonSpew(IonSpew_Inlining, "Inlining %d targets", (int) targets.length());
113370:     JS_ASSERT(targets.length() > 0);
112874: 
113369:     // |top| jumps into the callee subgraph -- save it for later use.
113369:     MBasicBlock *top = current;
113369: 
113431:     // Unwrap all the MPassArgs and replace them with their inputs, and discard the
113431:     // MPassArgs.
124795:     for (int32_t i = argc; i >= 0; i--) {
113431:         // Unwrap each MPassArg, replacing it with its contents.
113431:         int argSlotDepth = -((int) i + 1);
113431:         MPassArg *passArg = top->peek(argSlotDepth)->toPassArg();
113431:         MBasicBlock *block = passArg->block();
113431:         MDefinition *wrapped = passArg->getArgument();
126182:         wrapped->setFoldedUnchecked();
113431:         passArg->replaceAllUsesWith(wrapped);
113431:         top->rewriteAtDepth(argSlotDepth, wrapped);
113431:         block->discard(passArg);
113370:     }
113369: 
113482:     // Check if the input is a GetPropertyCache that can be eliminated via guards on
113482:     // the |this| object's typeguards.
113482:     MGetPropertyCache *getPropCache = NULL;
113482:     if (!constructing) {
113482:         getPropCache = checkInlineableGetPropertyCache(argc);
113482:         if(getPropCache) {
113482:             InlinePropertyTable *inlinePropTable = getPropCache->inlinePropertyTable();
113482:             // checkInlineableGetPropertyCache should have verified this.
113482:             JS_ASSERT(inlinePropTable != NULL);
113482: 
113482:             int numCases = inlinePropTable->numEntries();
113482:             IonSpew(IonSpew_Inlining, "Got inlineable property cache with %d cases", numCases);
113482: 
113482:             inlinePropTable->trimToTargets(targets);
113482: 
113482:             // Trim the cases based on those that match the targets at this call site.
113482:             IonSpew(IonSpew_Inlining, "%d inlineable cases left after trimming to %d targets",
113482:                                         (int) inlinePropTable->numEntries(),
113482:                                         (int) targets.length());
113482: 
113482:             if (inlinePropTable->numEntries() == 0)
113482:                 getPropCache = NULL;
113482:         }
113482:     }
113482: 
113369:     // Create a |bottom| block for all the callee subgraph exits to jump to.
113369:     JS_ASSERT(types::IsInlinableCall(pc));
113369:     jsbytecode *postCall = GetNextPc(pc);
113369:     MBasicBlock *bottom = newBlock(NULL, postCall);
114404:     if (!bottom)
114404:         return false;
113369:     bottom->setCallerResumePoint(callerResumePoint_);
113369: 
113369:     Vector<MDefinition *, 8, IonAllocPolicy> retvalDefns;
113369: 
113369:     // Do the inline build. Return value definitions are stored in retvalDefns.
113482:     // The monomorphic inlining only occurs if we're not handling a getPropCache guard
113482:     // optimization.  The reasoning for this is as follows:
113482:     //      If there was a single object type leading to a single inlineable function, then
113482:     //      the getprop would have been optimized away to a constant load anyway.
113482:     //
113482:     //      If there were more than one object types where we could narrow the generated
113482:     //      function to a single one, then we still want to guard on typeobject and save the
113482:     //      cost of the GetPropCache.
113482:     if (getPropCache == NULL && targets.length() == 1) {
113431:         JSFunction *func = targets[0]->toFunction();
113431:         MConstant *constFun = MConstant::New(ObjectValue(*func));
113431:         current->add(constFun);
113431: 
113370:         // Monomorphic case is simple - no guards.
113431:         RootedFunction target(cx, func);
113431:         if (!jsop_call_inline(target, argc, constructing, constFun, bottom, retvalDefns))
113370:             return false;
113587: 
113587:         // The Inline_Enter node is handled by buildInline, we're responsible
113587:         // for the Inline_Exit node (mostly for the case below)
113587:         if (instrumentedProfiling())
113587:             bottom->add(MFunctionBoundary::New(NULL, MFunctionBoundary::Inline_Exit));
113587: 
113370:     } else {
113431:         // In the polymorphic case, we end the current block with a MPolyInlineDispatch instruction.
113431: 
113482:         // Create a PolyInlineDispatch instruction for this call site
113482:         MPolyInlineDispatch *disp = makePolyInlineDispatch(cx, targets, argc, getPropCache,
113482:                                                            types, barrier, bottom, retvalDefns);
113482:         if (!disp)
113482:             return false;
113370:         for (size_t i = 0; i < targets.length(); i++) {
113482:             // Create an MConstant for the function
113431:             JSFunction *func = targets[i]->toFunction();
113431:             RootedFunction target(cx, func);
113431:             MConstant *constFun = MConstant::New(ObjectValue(*func));
113431: 
113482:             // Create new entry block for the inlined callee graph.
113482:             MBasicBlock *entryBlock = newBlock(current, pc);
113431:             if (!entryBlock)
113431:                 return false;
113431: 
113431:             // Add case to PolyInlineDispatch
113431:             entryBlock->add(constFun);
113431:             disp->addCallee(constFun, entryBlock);
113431:         }
113431:         top->end(disp);
113431: 
113587:         // If profiling is enabled, then we need a clear-cut boundary of all of
113587:         // the inlined functions which is distinct from the fallback path where
113587:         // no inline functions are entered. In the case that there's a fallback
113587:         // path and a set of inline functions, we create a new block as a join
113587:         // point for all of the inline paths which will then go to the real end
113587:         // block: 'bottom'. This 'inlineBottom' block is never different from
113587:         // 'bottom' except for this one case where profiling is turned on.
113587:         MBasicBlock *inlineBottom = bottom;
113587:         if (instrumentedProfiling() && disp->inlinePropertyTable()) {
113587:             inlineBottom = newBlock(NULL, pc);
113587:             if (inlineBottom == NULL)
113587:                 return false;
113587:         }
113587: 
113431:         for (size_t i = 0; i < disp->numCallees(); i++) {
113370:             // Do the inline function build.
113431:             MConstant *constFun = disp->getFunctionConstant(i);
113431:             RootedFunction target(cx, constFun->value().toObject().toFunction());
113431:             MBasicBlock *block = disp->getSuccessor(i);
113485:             graph().moveBlockToEnd(block);
113431:             current = block;
113431: 
113587:             if (!jsop_call_inline(target, argc, constructing, constFun, inlineBottom, retvalDefns))
113587:                 return false;
113587:         }
113587: 
113587:         // Regardless of whether inlineBottom != bottom, demarcate these exits
113587:         // with an Inline_Exit instruction signifying that the inlined functions
113587:         // on this level have all ceased running.
113587:         if (instrumentedProfiling())
113587:             inlineBottom->add(MFunctionBoundary::New(NULL, MFunctionBoundary::Inline_Exit));
113587: 
113587:         // In the case where we had to create a new block, all of the returns of
113587:         // the inline functions need to be merged together with a phi node. This
113587:         // phi node resident in the 'inlineBottom' block is then an input to the
113587:         // phi node for this entire call sequence in the 'bottom' block.
113587:         if (inlineBottom != bottom) {
113587:             graph().moveBlockToEnd(inlineBottom);
113587:             inlineBottom->inheritSlots(top);
113587:             if (!inlineBottom->initEntrySlots())
113587:                 return false;
113587: 
113587:             // Only need to phi returns together if there's more than one
113587:             if (retvalDefns.length() > 1) {
113587:                 // This is the same depth as the phi node of the 'bottom' block
113587:                 // after all of the 'pops' happen (see pop() sequence below)
113587:                 MPhi *phi = MPhi::New(inlineBottom->stackDepth() - argc - 2);
113587:                 inlineBottom->addPhi(phi);
113587: 
114404:                 MDefinition **it = retvalDefns.begin(), **end = retvalDefns.end();
114404:                 for (; it != end; ++it) {
113587:                     if (!phi->addInput(*it))
113587:                         return false;
113587:                 }
113587:                 // retvalDefns should become a singleton vector of 'phi'
113587:                 retvalDefns.clear();
113587:                 if (!retvalDefns.append(phi))
113587:                     return false;
113587:             }
113587: 
113587:             inlineBottom->end(MGoto::New(bottom));
113587:             if (!bottom->addPredecessorWithoutPhis(inlineBottom))
113369:                 return false;
113370:         }
113482: 
113482:         // If inline property table is set on the dispatch instruction, then there is
113482:         // a fallback case to consider.  Move the fallback blocks to the end of the graph
113482:         // and link them to the bottom block.
113482:         if (disp->inlinePropertyTable()) {
113485:             graph().moveBlockToEnd(disp->fallbackPrepBlock());
113485:             graph().moveBlockToEnd(disp->fallbackMidBlock());
113485:             graph().moveBlockToEnd(disp->fallbackEndBlock());
113482: 
113482:             // Link the end fallback block to bottom.
113482:             MBasicBlock *fallbackEndBlock = disp->fallbackEndBlock();
113482:             MDefinition *fallbackResult = fallbackEndBlock->pop();
113482:             if(!retvalDefns.append(fallbackResult))
113482:                 return false;
113482:             fallbackEndBlock->end(MGoto::New(bottom));
113482:             if (!bottom->addPredecessorWithoutPhis(fallbackEndBlock))
113482:                 return false;
113482:         }
113370:     }
113370: 
113485:     graph().moveBlockToEnd(bottom);
113369: 
113433:     bottom->inheritSlots(top);
113369: 
113431:     // If we were doing a polymorphic inline, then the discardCallArgs
113482:     // happened in sub-frames, not the top frame.  Need to get rid of
113482:     // those in the bottom.
113482:     if (getPropCache || targets.length() > 1) {
113431:         for (uint32_t i = 0; i < argc + 1; i++)
113433:             bottom->pop();
113431:     }
113431: 
113369:     // Pop the callee and push the return value.
113433:     bottom->pop();
113369: 
113369:     MDefinition *retvalDefn;
113369:     if (retvalDefns.length() > 1) {
113369:         // Need to create a phi to merge the returns together.
113369:         MPhi *phi = MPhi::New(bottom->stackDepth());
113369:         bottom->addPhi(phi);
113369: 
113369:         for (MDefinition **it = retvalDefns.begin(), **end = retvalDefns.end(); it != end; ++it) {
113369:             if (!phi->addInput(*it))
113369:                 return false;
113369:         }
113369:         retvalDefn = phi;
113369:     } else {
113369:         retvalDefn = retvalDefns.back();
113369:     }
113369: 
113369:     bottom->push(retvalDefn);
113482: 
113482:     // Initialize entry slots now that the stack has been fixed up.
113433:     if (!bottom->initEntrySlots())
113433:         return false;
113369: 
113482:     // If this inlining was a polymorphic one, then create a new bottom block
113482:     // to continue from.  This is because the resumePoint above would have captured
113482:     // an incorrect stack state (with all the arguments pushed).  That's ok because
113482:     // the Phi that is the first instruction on the bottom node can't bail out, but
113482:     // it's not ok if some subsequent instruction bails.
113482: 
113482:     if (getPropCache || targets.length() > 1) {
113482:         MBasicBlock *bottom2 = newBlock(bottom, postCall);
113482:         if (!bottom2)
113482:             return false;
113482: 
113482:         bottom->end(MGoto::New(bottom2));
113482:         current = bottom2;
113482:     } else {
113482:         current = bottom;
113482:     }
113482: 
113369:     // Check the depth change:
113369:     //  -argc for popped args
113369:     //  -2 for callee/this
113369:     //  +1 for retval
113482:     JS_ASSERT(current->stackDepth() == origStackDepth - argc - 1);
113482: 
113369:     return true;
112206: }
112206: 
113175: MInstruction *
125292: IonBuilder::createDeclEnvObject(MDefinition *callee, MDefinition *scope)
125292: {
125292:     // Create a template CallObject that we'll use to generate inline object
125292:     // creation.
125292: 
125292:     RootedScript script(cx, script_);
125292:     RootedFunction fun(cx, info().fun());
125292:     RootedObject templateObj(cx, DeclEnvObject::createTemplateObject(cx, fun));
125292:     if (!templateObj)
125292:         return NULL;
125292: 
125292:     // Add dummy values on the slot of the template object such as we do not try
125292:     // mark uninitialized values.
125292:     templateObj->setFixedSlot(DeclEnvObject::enclosingScopeSlot(), MagicValue(JS_GENERIC_MAGIC));
125292:     templateObj->setFixedSlot(DeclEnvObject::lambdaSlot(), MagicValue(JS_GENERIC_MAGIC));
125292: 
125292:     // One field is added to the function to handle its name.  This cannot be a
125292:     // dynamic slot because there is still plenty of room on the DeclEnv object.
125292:     JS_ASSERT(!templateObj->hasDynamicSlots());
125292: 
125292:     // Allocate the actual object. It is important that no intervening
125292:     // instructions could potentially bailout, thus leaking the dynamic slots
125292:     // pointer.
125292:     MInstruction *declEnvObj = MNewDeclEnvObject::New(templateObj);
125292:     current->add(declEnvObj);
125292: 
125292:     // Initialize the object's reserved slots.
125292:     current->add(MStoreFixedSlot::New(declEnvObj, DeclEnvObject::enclosingScopeSlot(), scope));
125292:     current->add(MStoreFixedSlot::New(declEnvObj, DeclEnvObject::lambdaSlot(), callee));
125292: 
125292:     return declEnvObj;
125292: }
125292: 
125292: MInstruction *
113175: IonBuilder::createCallObject(MDefinition *callee, MDefinition *scope)
113175: {
113233:     // Create a template CallObject that we'll use to generate inline object
113233:     // creation.
113614: 
125568:     RootedScript scriptRoot(cx, script());
125568:     RootedObject templateObj(cx, CallObject::createTemplateObject(cx, scriptRoot));
113614:     if (!templateObj)
113175:         return NULL;
113233: 
113233:     // If the CallObject needs dynamic slots, allocate those now.
113233:     MInstruction *slots;
113233:     if (templateObj->hasDynamicSlots()) {
113614:         size_t nslots = JSObject::dynamicSlotsCount(templateObj->numFixedSlots(),
113614:                                                     templateObj->slotSpan());
113233:         slots = MNewSlots::New(nslots);
113233:     } else {
113233:         slots = MConstant::New(NullValue());
113233:     }
113233:     current->add(slots);
113233: 
113233:     // Allocate the actual object. It is important that no intervening
113233:     // instructions could potentially bailout, thus leaking the dynamic slots
113233:     // pointer.
113233:     MInstruction *callObj = MNewCallObject::New(templateObj, slots);
113175:     current->add(callObj);
113175: 
113233:     // Initialize the object's reserved slots.
125292:     current->add(MStoreFixedSlot::New(callObj, CallObject::enclosingScopeSlot(), scope));
125119:     current->add(MStoreFixedSlot::New(callObj, CallObject::calleeSlot(), callee));
113233: 
113233:     // Initialize argument slots.
125568:     for (AliasedFormalIter i(script()); i; i++) {
113560:         unsigned slot = i.scopeSlot();
113560:         unsigned formal = i.frameIndex();
113560:         MDefinition *param = current->getSlot(info().argSlot(formal));
114808:         if (slot >= templateObj->numFixedSlots())
113614:             current->add(MStoreSlot::New(slots, slot - templateObj->numFixedSlots(), param));
113560:         else
113560:             current->add(MStoreFixedSlot::New(callObj, slot, param));
113175:     }
113175: 
113175:     return callObj;
113175: }
113175: 
112874: MDefinition *
112874: IonBuilder::createThisNative()
112874: {
112874:     // Native constructors build the new Object themselves.
112874:     MConstant *magic = MConstant::New(MagicValue(JS_IS_CONSTRUCTING));
112874:     current->add(magic);
112874:     return magic;
112874: }
112874: 
112874: MDefinition *
112874: IonBuilder::createThisScripted(MDefinition *callee)
112874: {
112874:     // Get callee.prototype.
124555:     //
112874:     // This instruction MUST be idempotent: since it does not correspond to an
124555:     // explicit operation in the bytecode, we cannot use resumeAfter().
124555:     // Getters may not override |prototype| fetching, so this operation is indeed idempotent.
124555:     // - First try an idempotent property cache.
124555:     // - Upon failing idempotent property cache, we can't use a non-idempotent cache,
124555:     //   therefore we fallback to CallGetProperty
124555:     //
124555:     // Note: both CallGetProperty and GetPropertyCache can trigger a GC,
124555:     //       and thus invalidation.
124555:     MInstruction *getProto;
124555:     if (!invalidatedIdempotentCache()) {
124555:         MGetPropertyCache *getPropCache = MGetPropertyCache::New(callee, cx->names().classPrototype);
124555:         getPropCache->setIdempotent();
124555:         getProto = getPropCache;
124555:     } else {
124555:         MCallGetProperty *callGetProp = MCallGetProperty::New(callee, cx->names().classPrototype);
124555:         callGetProp->setIdempotent();
124555:         getProto = callGetProp;
124555:     }
112874:     current->add(getProto);
112874: 
124555:     // Create this from prototype
125487:     MCreateThis *createThis = MCreateThis::New(callee, getProto);
112874:     current->add(createThis);
112874: 
112874:     return createThis;
112874: }
112874: 
112874: JSObject *
112874: IonBuilder::getSingletonPrototype(JSFunction *target)
112874: {
112874:     if (!target->hasSingletonType())
112874:         return NULL;
112874:     if (target->getType(cx)->unknownProperties())
112874:         return NULL;
112874: 
114207:     jsid protoid = NameToId(cx->names().classPrototype);
113609:     types::HeapTypeSet *protoTypes = target->getType(cx)->getProperty(cx, protoid, false);
113021:     if (!protoTypes)
113021:         return NULL;
112874: 
113609:     return protoTypes->getSingleton(cx);
112874: }
112874: 
112874: MDefinition *
112984: IonBuilder::createThisScriptedSingleton(HandleFunction target, HandleObject proto, MDefinition *callee)
112874: {
112874:     // Generate an inline path to create a new |this| object with
112874:     // the given singleton prototype.
112874:     types::TypeObject *type = proto->getNewType(cx, target);
112874:     if (!type)
112874:         return NULL;
125006:     if (!types::TypeScript::ThisTypes(target->nonLazyScript())->hasType(types::Type::ObjectType(type)))
112874:         return NULL;
112874: 
113132:     RootedObject templateObject(cx, js_CreateThisForFunctionWithProto(cx, target, proto));
112874:     if (!templateObject)
112874:         return NULL;
112874: 
112874:     // Trigger recompilation if the templateObject changes.
112874:     if (templateObject->type()->newScript)
113609:         types::HeapTypeSet::WatchObjectStateChange(cx, templateObject->type());
112874: 
125487:     MCreateThisWithTemplate *createThis = MCreateThisWithTemplate::New(templateObject);
112874:     current->add(createThis);
112874: 
112874:     return createThis;
112874: }
112874: 
112874: MDefinition *
112984: IonBuilder::createThis(HandleFunction target, MDefinition *callee)
112874: {
125488:     // Create this for unknown target
125488:     if (!target)
125488:         return createThisScripted(callee);
125488: 
125488:     // Create this for native function
112874:     if (target->isNative()) {
112874:         if (!target->isNativeConstructor())
112874:             return NULL;
112874:         return createThisNative();
112874:     }
112874: 
125488:     // Create this with known prototype.
113132:     RootedObject proto(cx, getSingletonPrototype(target));
124309: 
124309:     // Try baking in the prototype.
125488:     if (proto) {
125488:         MDefinition *createThis = createThisScriptedSingleton(target, proto, callee);
125488:         if (createThis)
125488:             return createThis;
125488:     }
125488: 
125488:     MDefinition *createThis = createThisScripted(callee);
124309:     if (!createThis)
125488:         return NULL;
125488: 
125488:     // The native function case is already handled upfront.
125488:     // Here we can safely remove the native check for MCreateThis.
125488:     JS_ASSERT(createThis->isCreateThis());
125488:     createThis->toCreateThis()->removeNativeCheck();
124309: 
124140:     return createThis;
124140: }
112874: 
112206: bool
124795: IonBuilder::jsop_funcall(uint32_t argc)
112920: {
112920:     // Stack for JSOP_FUNCALL:
112920:     // 1:      MPassArg(arg0)
112920:     // ...
112920:     // argc:   MPassArg(argN)
112920:     // argc+1: MPassArg(JSFunction *), the 'f' in |f.call()|, in |this| position.
112920:     // argc+2: The native 'call' function.
112920: 
112920:     // If |Function.prototype.call| may be overridden, don't optimize callsite.
113132:     RootedFunction native(cx, getSingleCallTarget(argc, pc));
113200:     if (!native || !native->isNative() || native->native() != &js_fun_call)
112920:         return makeCall(native, argc, false);
112920: 
112920:     // Extract call target.
125568:     types::StackTypeSet *funTypes = oracle->getCallArg(script(), argc, 0, pc);
113609:     RootedObject funobj(cx, (funTypes) ? funTypes->getSingleton() : NULL);
113132:     RootedFunction target(cx, (funobj && funobj->isFunction()) ? funobj->toFunction() : NULL);
112920: 
112920:     // Unwrap the (JSFunction *) parameter.
112920:     int funcDepth = -((int)argc + 1);
112920:     MPassArg *passFunc = current->peek(funcDepth)->toPassArg();
112920:     current->rewriteAtDepth(funcDepth, passFunc->getArgument());
112920: 
112920:     // Remove the MPassArg(JSFunction *).
112920:     passFunc->replaceAllUsesWith(passFunc->getArgument());
112920:     passFunc->block()->discard(passFunc);
112920: 
112920:     // Shimmy the slots down to remove the native 'call' function.
112920:     current->shimmySlots(funcDepth - 1);
112920: 
112920:     // If no |this| argument was provided, explicitly pass Undefined.
112920:     // Pushing is safe here, since one stack slot has been removed.
112920:     if (argc == 0) {
112920:         MConstant *undef = MConstant::New(UndefinedValue());
112920:         current->add(undef);
112920:         MPassArg *pass = MPassArg::New(undef);
112920:         current->add(pass);
112920:         current->push(pass);
112920:     } else {
112920:         // |this| becomes implicit in the call.
112920:         argc -= 1; 
112920:     }
112920: 
112920:     // Call without inlining.
112920:     return makeCall(target, argc, false);
112920: }
112920: 
112920: bool
124795: IonBuilder::jsop_funapply(uint32_t argc)
113388: {
113620:     RootedFunction native(cx, getSingleCallTarget(argc, pc));
113620:     if (argc != 2)
113620:         return makeCall(native, argc, false);
113620: 
113609:     // Disable compilation if the second argument to |apply| cannot be guaranteed
113609:     // to be either definitely |arguments| or definitely not |arguments|.
125568:     types::StackTypeSet *argObjTypes = oracle->getCallArg(script(), argc, 2, pc);
113609:     LazyArgumentsType isArgObj = oracle->isArgumentObject(argObjTypes);
113609:     if (isArgObj == MaybeArguments)
113609:         return abort("fun.apply with MaybeArguments");
113609: 
113609:     // Fallback to regular call if arg 2 is not definitely |arguments|.
113609:     if (isArgObj != DefinitelyArguments)
113609:         return makeCall(native, argc, false);
113609: 
113609:     if (!native ||
113609:         !native->isNative() ||
113620:         native->native() != js_fun_apply)
113620:     {
113620:         return abort("fun.apply speculation failed");
113609:     }
113609: 
113388:     // Stack for JSOP_FUNAPPLY:
113388:     // 1:      MPassArg(Vp)
113388:     // 2:      MPassArg(This)
113388:     // argc+1: MPassArg(JSFunction *), the 'f' in |f.call()|, in |this| position.
113388:     // argc+2: The native 'apply' function.
113388: 
113388:     // Extract call target.
125568:     types::StackTypeSet *funTypes = oracle->getCallArg(script(), argc, 0, pc);
113609:     RootedObject funobj(cx, (funTypes) ? funTypes->getSingleton() : NULL);
113388:     RootedFunction target(cx, (funobj && funobj->isFunction()) ? funobj->toFunction() : NULL);
113388: 
113388:     // Vp
113388:     MPassArg *passVp = current->pop()->toPassArg();
113388:     passVp->replaceAllUsesWith(passVp->getArgument());
113388:     passVp->block()->discard(passVp);
113388: 
113388:     // This
113388:     MPassArg *passThis = current->pop()->toPassArg();
113388:     MDefinition *argThis = passThis->getArgument();
113388:     passThis->replaceAllUsesWith(argThis);
113388:     passThis->block()->discard(passThis);
113388: 
113388:     // Unwrap the (JSFunction *) parameter.
113388:     MPassArg *passFunc = current->pop()->toPassArg();
113388:     MDefinition *argFunc = passFunc->getArgument();
113388:     passFunc->replaceAllUsesWith(argFunc);
113388:     passFunc->block()->discard(passFunc);
113388: 
113388:     // Pop apply function.
113388:     current->pop();
113388: 
113411:     MArgumentsLength *numArgs = MArgumentsLength::New();
113388:     current->add(numArgs);
113388: 
113388:     MApplyArgs *apply = MApplyArgs::New(target, argFunc, numArgs, argThis);
113388:     current->add(apply);
113388:     current->push(apply);
113388:     if (!resumeAfter(apply))
113388:         return false;
113388: 
113609:     types::StackTypeSet *barrier;
125568:     types::StackTypeSet *types = oracle->returnTypeSet(script(), pc, &barrier);
113388:     return pushTypeBarrier(apply, types, barrier);
113388: }
113388: 
113388: bool
124795: IonBuilder::jsop_call(uint32_t argc, bool constructing)
113849: {
119065:     AssertCanGC();
119065: 
113849:     // Acquire known call target if existent.
113849:     AutoObjectVector targets(cx);
113849:     uint32_t numTargets = getPolyCallTargets(argc, pc, targets, 4);
113849:     types::StackTypeSet *barrier;
125568:     types::StackTypeSet *types = oracle->returnTypeSet(script(), pc, &barrier);
113849: 
112874:     // Attempt to inline native and scripted functions.
113370:     if (inliningEnabled()) {
113370:         // Inline a single native call if possible.
113370:         if (numTargets == 1 && targets[0]->toFunction()->isNative()) {
113370:             RootedFunction target(cx, targets[0]->toFunction());
113334:             switch (inlineNativeCall(target->native(), argc, constructing)) {
113036:               case InliningStatus_Inlined:
112206:                 return true;
113036:               case InliningStatus_Error:
113036:                 return false;
113036:               case InliningStatus_NotInlined:
113036:                 break;
113036:             }
113036:         }
113036: 
118361:         if (numTargets > 0 && makeInliningDecision(targets, argc))
113482:             return inlineScriptedCall(targets, argc, constructing, types, barrier);
113370:     }
113370: 
113982:     RootedFunction target(cx, NULL);
116030:     if (numTargets == 1)
115449:         target = targets[0]->toFunction();
115449: 
113327:     return makeCallBarrier(target, argc, constructing, types, barrier);
112920: }
112920: 
113849: MCall *
124795: IonBuilder::makeCallHelper(HandleFunction target, uint32_t argc, bool constructing)
112920: {
112920:     // This function may be called with mutated stack.
112920:     // Querying TI for popped types is invalid.
112920: 
124795:     uint32_t targetArgs = argc;
112662: 
112662:     // Collect number of missing arguments provided that the target is
112874:     // scripted. Native functions are passed an explicit 'argc' parameter.
112662:     if (target && !target->isNative())
124795:         targetArgs = Max<uint32_t>(target->nargs, argc);
112662: 
113053:     MCall *call = MCall::New(target, targetArgs + 1, argc, constructing);
112662:     if (!call)
113849:         return NULL;
112064: 
112662:     // Explicitly pad any missing arguments with |undefined|.
112662:     // This permits skipping the argumentsRectifier.
112662:     for (int i = targetArgs; i > (int)argc; i--) {
112662:         JS_ASSERT_IF(target, !target->isNative());
112662:         MConstant *undef = MConstant::New(UndefinedValue());
112662:         current->add(undef);
112662:         MPassArg *pass = MPassArg::New(undef);
112662:         current->add(pass);
112662:         call->addArg(i, pass);
112662:     }
112662: 
112662:     // Add explicit arguments.
112064:     // Bytecode order: Function, This, Arg0, Arg1, ..., ArgN, Call.
124795:     for (int32_t i = argc; i > 0; i--)
112662:         call->addArg(i, current->pop()->toPassArg());
112662: 
112874:     // Place an MPrepareCall before the first passed argument, before we
112874:     // potentially perform rearrangement.
112874:     MPrepareCall *start = new MPrepareCall;
112874:     MPassArg *firstArg = current->peek(-1)->toPassArg();
112874:     firstArg->block()->insertBefore(firstArg, start);
112874:     call->initPrepareCall(start);
112874: 
112874:     MPassArg *thisArg = current->pop()->toPassArg();
112874: 
125488:     // Inline the constructor on the caller-side.
125488:     if (constructing) {
112874:         MDefinition *callee = current->peek(-1);
112874:         MDefinition *create = createThis(target, callee);
113849:         if (!create) {
113849:             abort("Failure inlining constructor for call.");
113849:             return NULL;
113849:         }
112874: 
112874:         MPassArg *newThis = MPassArg::New(create);
112874: 
112874:         thisArg->block()->discard(thisArg);
112874:         current->add(newThis);
112874:         thisArg = newThis;
112662:     }
112662: 
112662:     // Pass |this| and function.
112874:     call->addArg(0, thisArg);
113516: 
113516:     MDefinition *fun = current->pop();
113516:     if (fun->isDOMFunction())
113516:         call->setDOMFunction();
113516:     call->initFunction(fun);
112064: 
112662:     current->add(call);
113849:     return call;
113849: }
113849: 
113849: bool
124795: IonBuilder::makeCallBarrier(HandleFunction target, uint32_t argc,
113849:                             bool constructing,
113849:                             types::StackTypeSet *types,
113849:                             types::StackTypeSet *barrier)
113849: {
113849:     MCall *call = makeCallHelper(target, argc, constructing);
113849:     if (!call)
113849:         return false;
113849: 
112662:     current->push(call);
112662:     if (!resumeAfter(call))
112064:         return false;
112120: 
113327:     return pushTypeBarrier(call, types, barrier);
113327: }
113327: 
113327: bool
124795: IonBuilder::makeCall(HandleFunction target, uint32_t argc, bool constructing)
113327: {
113609:     types::StackTypeSet *barrier;
125568:     types::StackTypeSet *types = oracle->returnTypeSet(script(), pc, &barrier);
113327:     return makeCallBarrier(target, argc, constructing, types, barrier);
112012: }
112012: 
112012: bool
111996: IonBuilder::jsop_compare(JSOp op)
111996: {
111996:     MDefinition *right = current->pop();
111996:     MDefinition *left = current->pop();
111996: 
111996:     MCompare *ins = MCompare::New(left, right, op);
111996:     current->add(ins);
112494:     current->push(ins);
111996: 
125568:     TypeOracle::BinaryTypes b = oracle->binaryTypes(script(), pc);
126213:     ins->infer(b, cx);
111996: 
112494:     if (ins->isEffectful() && !resumeAfter(ins))
112494:         return false;
111996:     return true;
111996: }
111996: 
113485: JSObject *
124795: IonBuilder::getNewArrayTemplateObject(uint32_t count)
113485: {
113574:     RootedObject templateObject(cx, NewDenseUnallocatedArray(cx, count));
113485:     if (!templateObject)
113485:         return NULL;
113485: 
125568:     RootedScript scriptRoot(cx, script());
125568:     if (types::UseNewTypeForInitializer(cx, scriptRoot, pc, JSProto_Array)) {
113574:         if (!JSObject::setSingletonType(cx, templateObject))
113485:             return NULL;
113485:     } else {
125568:         types::TypeObject *type = types::TypeScript::InitObject(cx, scriptRoot, pc, JSProto_Array);
113485:         if (!type)
113485:             return NULL;
113485:         templateObject->setType(type);
113485:     }
113485: 
113485:     return templateObject;
113485: }
113485: 
112247: bool
124795: IonBuilder::jsop_newarray(uint32_t count)
112247: {
125568:     JS_ASSERT(script()->compileAndGo);
112247: 
113485:     JSObject *templateObject = getNewArrayTemplateObject(count);
113485:     if (!templateObject)
113485:         return false;
113485: 
113529:     MNewArray *ins = new MNewArray(count, templateObject, MNewArray::NewArray_Allocating);
113485: 
113485:     current->add(ins);
113485:     current->push(ins);
113485: 
113485:     return true;
113485: }
113485: 
113485: bool
113485: IonBuilder::jsop_newobject(HandleObject baseObj)
113485: {
113485:     // Don't bake in the TypeObject for non-CNG scripts.
125568:     JS_ASSERT(script()->compileAndGo);
113485: 
113574:     RootedObject templateObject(cx);
113485: 
113485:     if (baseObj) {
113485:         templateObject = CopyInitializerObject(cx, baseObj);
113485:     } else {
113485:         gc::AllocKind kind = GuessObjectGCKind(0);
113485:         templateObject = NewBuiltinClassInstance(cx, &ObjectClass, kind);
113485:     }
113485: 
113485:     if (!templateObject)
113485:         return false;
113485: 
125568:     RootedScript scriptRoot(cx, script());
125568:     if (types::UseNewTypeForInitializer(cx, scriptRoot, pc, JSProto_Object)) {
113574:         if (!JSObject::setSingletonType(cx, templateObject))
113485:             return false;
113485:     } else {
125568:         types::TypeObject *type = types::TypeScript::InitObject(cx, scriptRoot, pc, JSProto_Object);
112247:         if (!type)
112247:             return false;
113485:         templateObject->setType(type);
113485:     }
113485: 
113485:     MNewObject *ins = MNewObject::New(templateObject);
112764: 
112764:     current->add(ins);
112764:     current->push(ins);
112764: 
112764:     return resumeAfter(ins);
112764: }
112764: 
112764: bool
126000: IonBuilder::jsop_initelem_array()
112734: {
112734:     MDefinition *value = current->pop();
112734:     MDefinition *obj = current->peek(-1);
112734: 
126000:     MConstant *id = MConstant::New(Int32Value(GET_UINT24(pc)));
126000:     current->add(id);
126000: 
112734:     // Get the elements vector.
112734:     MElements *elements = MElements::New(obj);
112734:     current->add(elements);
112734: 
112734:     // Store the value.
112734:     MStoreElement *store = MStoreElement::New(elements, id, value);
112734:     current->add(store);
112734: 
112734:     // Update the length.
112734:     MSetInitializedLength *initLength = MSetInitializedLength::New(elements, id);
112734:     current->add(initLength);
112734: 
112734:     if (!resumeAfter(initLength))
112734:         return false;
112734: 
112734:    return true;
112734: }
112734: 
113512: static bool
113512: CanEffectlesslyCallLookupGenericOnObject(JSObject *obj)
113512: {
113513:     while (obj) {
113513:         if (!obj->isNative())
113512:             return false;
113513:         if (obj->getClass()->ops.lookupProperty)
113512:             return false;
113513:         obj = obj->getProto();
113512:     }
113512:     return true;
113512: }
113512: 
112765: bool
113095: IonBuilder::jsop_initprop(HandlePropertyName name)
112765: {
112765:     MDefinition *value = current->pop();
112765:     MDefinition *obj = current->peek(-1);
112765: 
113485:     RootedObject templateObject(cx, obj->toNewObject()->templateObject());
112765: 
125568:     if (!oracle->propertyWriteCanSpecialize(script(), pc)) {
112765:         // This should only happen for a few names like __proto__.
112765:         return abort("INITPROP Monitored initprop");
112765:     }
112765: 
113512:     if (!CanEffectlesslyCallLookupGenericOnObject(templateObject))
113512:         return abort("INITPROP template object is special");
113512: 
113485:     RootedObject holder(cx);
113485:     RootedShape shape(cx);
113485:     RootedId id(cx, NameToId(name));
113485:     bool res = LookupPropertyWithFlags(cx, templateObject, id,
113485:                                        JSRESOLVE_QUALIFIED, &holder, &shape);
113485:     if (!res)
113485:         return false;
113485: 
113485:     if (!shape || holder != templateObject) {
113485:         // JSOP_NEWINIT becomes an MNewObject without preconfigured properties.
113095:         MInitProp *init = MInitProp::New(obj, name, value);
112976:         current->add(init);
112976:         return resumeAfter(init);
112976:     }
112976: 
113423:     bool needsBarrier = true;
125568:     TypeOracle::BinaryTypes b = oracle->binaryTypes(script(), pc);
113423:     if (b.lhsTypes &&
113423:         ((jsid)id == types::MakeTypeId(cx, id)) &&
113423:         !b.lhsTypes->propertyNeedsBarrier(cx, id))
113423:     {
113423:         needsBarrier = false;
113423:     }
113423: 
113485:     if (templateObject->isFixedSlot(shape->slot())) {
113175:         MStoreFixedSlot *store = MStoreFixedSlot::New(obj, shape->slot(), value);
113423:         if (needsBarrier)
113423:             store->setNeedsBarrier();
113423: 
112765:         current->add(store);
112765:         return resumeAfter(store);
112765:     }
112765: 
112765:     MSlots *slots = MSlots::New(obj);
112765:     current->add(slots);
112765: 
124795:     uint32_t slot = templateObject->dynamicSlotIndex(shape->slot());
114404:     MStoreSlot *store = MStoreSlot::New(slots, slot, value);
113423:     if (needsBarrier)
113423:         store->setNeedsBarrier();
113423: 
112765:     current->add(store);
112765:     return resumeAfter(store);
112765: }
112765: 
111655: MBasicBlock *
124795: IonBuilder::addBlock(MBasicBlock *block, uint32_t loopDepth)
112321: {
112321:     if (!block)
112321:         return NULL;
112321:     graph().addBlock(block);
112709:     block->setLoopDepth(loopDepth);
112321:     return block;
112321: }
112321: 
112321: MBasicBlock *
111665: IonBuilder::newBlock(MBasicBlock *predecessor, jsbytecode *pc)
111655: {
112142:     MBasicBlock *block = MBasicBlock::New(graph(), info(), predecessor, pc, MBasicBlock::NORMAL);
112709:     return addBlock(block, loopDepth_);
112709: }
112709: 
112709: MBasicBlock *
113482: IonBuilder::newBlock(MBasicBlock *predecessor, jsbytecode *pc, MResumePoint *priorResumePoint)
113482: {
113482:     MBasicBlock *block = MBasicBlock::NewWithResumePoint(graph(), info(), predecessor, pc,
113482:                                                          priorResumePoint);
113482:     return addBlock(block, loopDepth_);
113482: }
113482: 
113482: MBasicBlock *
124883: IonBuilder::newBlockPopN(MBasicBlock *predecessor, jsbytecode *pc, uint32_t popped)
124883: {
124883:     MBasicBlock *block = MBasicBlock::NewPopN(graph(), info(), predecessor, pc, MBasicBlock::NORMAL, popped);
124883:     return addBlock(block, loopDepth_);
124883: }
124883: 
124883: MBasicBlock *
112870: IonBuilder::newBlockAfter(MBasicBlock *at, MBasicBlock *predecessor, jsbytecode *pc)
112870: {
112870:     MBasicBlock *block = MBasicBlock::New(graph(), info(), predecessor, pc, MBasicBlock::NORMAL);
113104:     if (!block)
113104:         return NULL;
113485:     graph().insertBlockAfter(at, block);
112870:     return block;
112870: }
112870: 
112870: MBasicBlock *
124795: IonBuilder::newBlock(MBasicBlock *predecessor, jsbytecode *pc, uint32_t loopDepth)
112709: {
112709:     MBasicBlock *block = MBasicBlock::New(graph(), info(), predecessor, pc, MBasicBlock::NORMAL);
112709:     return addBlock(block, loopDepth);
111655: }
111655: 
111655: MBasicBlock *
113130: IonBuilder::newOsrPreheader(MBasicBlock *predecessor, jsbytecode *loopEntry)
112219: {
112512:     JS_ASSERT((JSOp)*loopEntry == JSOP_LOOPENTRY);
112512:     JS_ASSERT(loopEntry == info().osrPc());
112219: 
112219:     // Create two blocks: one for the OSR entry with no predecessors, one for
112870:     // the preheader, which has the OSR entry block as a predecessor. The
112870:     // OSR block is always the second block (with id 1).
113485:     MBasicBlock *osrBlock  = newBlockAfter(*graph().begin(), loopEntry);
112512:     MBasicBlock *preheader = newBlock(predecessor, loopEntry);
113104:     if (!osrBlock || !preheader)
113104:         return NULL;
112219: 
112219:     MOsrEntry *entry = MOsrEntry::New();
112219:     osrBlock->add(entry);
112219: 
112401:     // Initialize |scopeChain|.
112401:     {
124795:         uint32_t slot = info().scopeChainSlot();
112401: 
112401:         MOsrScopeChain *scopev = MOsrScopeChain::New(entry);
112401:         osrBlock->add(scopev);
112401:         osrBlock->initSlot(slot, scopev);
112401:     }
112401: 
112425:     if (info().fun()) {
112219:         // Initialize |this| parameter.
124795:         uint32_t slot = info().thisSlot();
112219:         ptrdiff_t offset = StackFrame::offsetOfThis(info().fun());
112219: 
112219:         MOsrValue *thisv = MOsrValue::New(entry, offset);
112219:         osrBlock->add(thisv);
112219:         osrBlock->initSlot(slot, thisv);
112219: 
112219:         // Initialize arguments.
124795:         for (uint32_t i = 0; i < info().nargs(); i++) {
124795:             uint32_t slot = info().argSlot(i);
112219:             ptrdiff_t offset = StackFrame::offsetOfFormalArg(info().fun(), i);
112219: 
112219:             MOsrValue *osrv = MOsrValue::New(entry, offset);
112219:             osrBlock->add(osrv);
112219:             osrBlock->initSlot(slot, osrv);
112219:         }
112425:     }
112219: 
112219:     // Initialize locals.
124795:     for (uint32_t i = 0; i < info().nlocals(); i++) {
124795:         uint32_t slot = info().localSlot(i);
112219:         ptrdiff_t offset = StackFrame::offsetOfFixed(i);
112219: 
112219:         MOsrValue *osrv = MOsrValue::New(entry, offset);
112219:         osrBlock->add(osrv);
112219:         osrBlock->initSlot(slot, osrv);
112219:     }
112219: 
112219:     // Initialize stack.
124795:     uint32_t numSlots = preheader->stackDepth() - CountArgSlots(info().fun()) - info().nlocals();
124795:     for (uint32_t i = 0; i < numSlots; i++) {
124795:         uint32_t slot = info().stackSlot(i);
112219:         ptrdiff_t offset = StackFrame::offsetOfFixed(info().nlocals() + i);
112219: 
112219:         MOsrValue *osrv = MOsrValue::New(entry, offset);
112219:         osrBlock->add(osrv);
112219:         osrBlock->initSlot(slot, osrv);
112219:     }
112219: 
112219:     // Create an MStart to hold the first valid MResumePoint.
112219:     MStart *start = MStart::New(MStart::StartType_Osr);
112219:     osrBlock->add(start);
112219:     graph().setOsrStart(start);
112219: 
112219:     // MOsrValue instructions are infallible, so the first MResumePoint must
112219:     // occur after they execute, at the point of the MStart.
112512:     if (!resumeAt(start, loopEntry))
112219:         return NULL;
112219: 
112219:     // Link the same MResumePoint from the MStart to each MOsrValue.
112219:     // This causes logic in ShouldSpecializeInput() to not replace Uses with
112219:     // Unboxes in the MResumePiont, so that the MStart always sees Values.
112219:     osrBlock->linkOsrValues(start);
112219: 
112403:     // Clone types of the other predecessor of the pre-header to the osr block,
112403:     // such as pre-header phi's won't discard specialized type of the
112403:     // predecessor.
112403:     JS_ASSERT(predecessor->stackDepth() == osrBlock->stackDepth());
112405:     JS_ASSERT(info().scopeChainSlot() == 0);
113175:     JS_ASSERT(osrBlock->scopeChain()->type() == MIRType_Object);
112500: 
112500:     Vector<MIRType> slotTypes(cx);
112500:     if (!slotTypes.growByUninitialized(osrBlock->stackDepth()))
112500:         return NULL;
112500: 
112500:     // Fill slotTypes with the types of the predecessor block.
124795:     for (uint32_t i = 0; i < osrBlock->stackDepth(); i++)
113130:         slotTypes[i] = MIRType_Value;
112500: 
112500:     // Update slotTypes for slots that may have a different type at this join point.
113130:     if (!oracle->getOsrTypes(loopEntry, slotTypes))
113130:         return NULL;
112500: 
124795:     for (uint32_t i = 1; i < osrBlock->stackDepth(); i++) {
112874:         // Unbox the MOsrValue if it is known to be unboxable.
113631:         switch (slotTypes[i]) {
113631:           case MIRType_Boolean:
113631:           case MIRType_Int32:
113631:           case MIRType_Double:
113631:           case MIRType_String:
113631:           case MIRType_Object:
113411:           {
112403:             MDefinition *def = osrBlock->getSlot(i);
112405:             JS_ASSERT(def->type() == MIRType_Value);
113411: 
113130:             MInstruction *actual = MUnbox::New(def, slotTypes[i], MUnbox::Infallible);
112403:             osrBlock->add(actual);
112403:             osrBlock->rewriteSlot(i, actual);
113631:             break;
113631:           }
113631: 
113631:           case MIRType_Null:
113631:           {
113631:             MConstant *c = MConstant::New(NullValue());
113631:             osrBlock->add(c);
113631:             osrBlock->rewriteSlot(i, c);
113631:             break;
113631:           }
113631: 
113631:           case MIRType_Undefined:
113631:           {
113631:             MConstant *c = MConstant::New(UndefinedValue());
113631:             osrBlock->add(c);
113631:             osrBlock->rewriteSlot(i, c);
113631:             break;
113631:           }
113631: 
113631:           case MIRType_Magic:
113411:             JS_ASSERT(lazyArguments_);
113411:             osrBlock->rewriteSlot(i, lazyArguments_);
113631:             break;
113631: 
113631:           default:
113631:             break;
112403:         }
112403:     }
112403: 
112219:     // Finish the osrBlock.
112219:     osrBlock->end(MGoto::New(preheader));
112219:     preheader->addPredecessor(osrBlock);
112219:     graph().setOsrBlock(osrBlock);
112219: 
112874:     // Wrap |this| with a guaranteed use, to prevent instruction elimination.
112874:     // Prevent |this| from being DCE'd: necessary for constructors.
112874:     if (info().fun())
112874:         preheader->getSlot(info().thisSlot())->setGuard();
112874: 
112219:     return preheader;
112219: }
112219: 
112219: MBasicBlock *
111879: IonBuilder::newPendingLoopHeader(MBasicBlock *predecessor, jsbytecode *pc)
111655: {
112709:     loopDepth_++;
112142:     MBasicBlock *block = MBasicBlock::NewPendingLoopHeader(graph(), info(), predecessor, pc);
112709:     return addBlock(block, loopDepth_);
111655: }
111655: 
112049: // A resume point is a mapping of stack slots to MDefinitions. It is used to
111711: // capture the environment such that if a guard fails, and IonMonkey needs
111711: // to exit back to the interpreter, the interpreter state can be
111711: // reconstructed.
111711: //
112681: // We capture stack state at critical points:
111711: //   * (1) At the beginning of every basic block.
112302: //   * (2) After every effectful operation.
111711: //
111711: // As long as these two properties are maintained, instructions can
111711: // be moved, hoisted, or, eliminated without problems, and ops without side
112049: // effects do not need to worry about capturing state at precisely the
111711: // right point in time.
111711: //
112049: // Effectful instructions, of course, need to capture state after completion,
111711: // where the interpreter will not attempt to repeat the operation. For this,
112681: // ResumeAfter must be used. The state is attached directly to the effectful
112049: // instruction to ensure that no intermediate instructions could be injected
112049: // in between by a future analysis pass.
111711: //
111711: // During LIR construction, if an instruction can bail back to the interpreter,
112049: // we create an LSnapshot, which uses the last known resume point to request
111711: // register/stack assignments for every live value.
111711: bool
112681: IonBuilder::resume(MInstruction *ins, jsbytecode *pc, MResumePoint::Mode mode)
111797: {
124557:     JS_ASSERT(ins->isEffectful() || !ins->isMovable());
112681: 
112681:     MResumePoint *resumePoint = MResumePoint::New(ins->block(), pc, callerResumePoint_, mode);
112681:     if (!resumePoint)
112681:         return false;
112681:     ins->setResumePoint(resumePoint);
124518:     resumePoint->setInstruction(ins);
112681:     return true;
111797: }
111797: 
111797: bool
112049: IonBuilder::resumeAt(MInstruction *ins, jsbytecode *pc)
111679: {
112681:     return resume(ins, pc, MResumePoint::ResumeAt);
112681: }
112681: 
112681: bool
112681: IonBuilder::resumeAfter(MInstruction *ins)
112681: {
112681:     return resume(ins, pc, MResumePoint::ResumeAfter);
111679: }
111679: 
124557: bool
124557: IonBuilder::maybeInsertResume()
124557: {
124557:     // Create a resume point at the current position, without an existing
124557:     // effectful instruction. This resume point is not necessary for correct
124557:     // behavior (see above), but is added to avoid holding any values from the
124557:     // previous resume point which are now dead. This shortens the live ranges
124557:     // of such values and improves register allocation.
124557:     //
124557:     // This optimization is not performed outside of loop bodies, where good
124557:     // register allocation is not as critical, in order to avoid creating
124557:     // excessive resume points.
124557: 
124557:     if (loopDepth_ == 0)
124557:         return true;
124557: 
124557:     MNop *ins = MNop::New();
124557:     current->add(ins);
124557: 
124557:     return resumeAfter(ins);
124557: }
124557: 
112397: void
112397: IonBuilder::insertRecompileCheck()
112397: {
112397:     if (!inliningEnabled())
112397:         return;
112397: 
113217:     if (inliningDepth > 0)
113217:         return;
113217: 
112397:     // Don't recompile if we are already inlining.
125568:     if (script()->getUseCount() >= js_IonOptions.usesBeforeInlining)
112397:         return;
112397: 
112397:     // Don't recompile if the oracle cannot provide inlining information
112397:     // or if the script has no calls.
112397:     if (!oracle->canInlineCalls())
112397:         return;
112397: 
125568:     uint32_t minUses = UsesBeforeIonRecompile(script(), pc);
113508:     MRecompileCheck *check = MRecompileCheck::New(minUses);
112397:     current->add(check);
112397: }
112397: 
112118: static inline bool
113574: TestSingletonProperty(JSContext *cx, HandleObject obj, HandleId id, bool *isKnownConstant)
112118: {
112118:     // We would like to completely no-op property/global accesses which can
112467:     // produce only a particular JSObject. When indicating the access result is
112467:     // definitely an object, type inference does not account for the
112467:     // possibility that the property is entirely missing from the input object
112467:     // and its prototypes (if this happens, a semantic trigger would be hit and
112467:     // the pushed types updated, even if there is no type barrier).
112118:     //
112118:     // If the access definitely goes through obj, either directly or on the
112118:     // prototype chain, then if obj has a defined property now, and the
112467:     // property has a default or method shape, then the property is not missing
112467:     // and the only way it can become missing in the future is if it is deleted.
112467:     // Deletion causes type properties to be explicitly marked with undefined.
112467: 
112119:     *isKnownConstant = false;
112118: 
113512:     if (!CanEffectlesslyCallLookupGenericOnObject(obj))
112118:         return true;
112118: 
113402:     RootedObject holder(cx);
113402:     RootedShape shape(cx);
113574:     if (!JSObject::lookupGeneric(cx, obj, id, &holder, &shape))
112118:         return false;
113402:     if (!shape)
112118:         return true;
112118: 
113120:     if (!shape->hasDefaultGetter())
113120:         return true;
112118:     if (!shape->hasSlot())
112118:         return true;
112249:     if (holder->getSlot(shape->slot()).isUndefined())
112118:         return true;
112118: 
112119:     *isKnownConstant = true;
112118:     return true;
112118: }
112118: 
112467: static inline bool
113609: TestSingletonPropertyTypes(JSContext *cx, types::StackTypeSet *types,
113095:                            HandleObject globalObj, HandleId id,
119481:                            bool *isKnownConstant, bool *testObject,
119481:                            bool *testString)
112467: {
112467:     // As for TestSingletonProperty, but the input is any value in a type set
112467:     // rather than a specific object. If testObject is set then the constant
112467:     // result can only be used after ensuring the input is an object.
112467: 
112467:     *isKnownConstant = false;
112467:     *testObject = false;
119481:     *testString = false;
112467: 
112467:     if (!types || types->unknownObject())
112467:         return true;
112467: 
113609:     RootedObject singleton(cx, types->getSingleton());
112467:     if (singleton)
112467:         return TestSingletonProperty(cx, singleton, id, isKnownConstant);
112467: 
112467:     if (!globalObj)
112467:         return true;
112467: 
112467:     JSProtoKey key;
113609:     JSValueType type = types->getKnownTypeTag();
112467:     switch (type) {
112467:       case JSVAL_TYPE_STRING:
112467:         key = JSProto_String;
112467:         break;
112467: 
112467:       case JSVAL_TYPE_INT32:
112467:       case JSVAL_TYPE_DOUBLE:
112467:         key = JSProto_Number;
112467:         break;
112467: 
112467:       case JSVAL_TYPE_BOOLEAN:
112467:         key = JSProto_Boolean;
112467:         break;
112467: 
112467:       case JSVAL_TYPE_OBJECT:
113516:       case JSVAL_TYPE_UNKNOWN: {
119481:         if (types->hasType(types::Type::StringType())) {
119481:             // Do not optimize if the object is either a String or an Object.
119481:             if (types->maybeObject())
119481:                 return true;
119481:             key = JSProto_String;
119481:             *testString = true;
119481:             break;
119481:         }
119481: 
112467:         // For property accesses which may be on many objects, we just need to
112467:         // find a prototype common to all the objects; if that prototype
113516:         // has the singleton property, the access will not be on a missing property.
113516:         bool thoughtConstant = true;
113516:         for (unsigned i = 0; i < types->getObjectCount(); i++) {
113516:             types::TypeObject *object = types->getTypeObject(i);
113516:             if (!object) {
113516:                 // Try to get it through the singleton.
113516:                 JSObject *curObj = types->getSingleObject(i);
113516:                 // As per the comment in jsinfer.h, there can be holes in
113516:                 // TypeSets, so just skip over them.
113516:                 if (!curObj)
113516:                     continue;
113516:                 object = curObj->getType(cx);
113516:             }
113516: 
113516:             if (object->proto) {
113516:                 // Test this type.
113574:                 RootedObject proto(cx, object->proto);
113574:                 if (!TestSingletonProperty(cx, proto, id, &thoughtConstant))
112467:                     return false;
113516:                 // Short circuit
113516:                 if (!thoughtConstant)
113516:                     break;
113516:             } else {
113516:                 // Can't be on the prototype chain with no prototypes...
113516:                 thoughtConstant = false;
113516:                 break;
113516:             }
113516:         }
113516:         if (thoughtConstant) {
112467:             // If this is not a known object, a test will be needed.
112467:             *testObject = (type != JSVAL_TYPE_OBJECT);
112467:         }
113516:         *isKnownConstant = thoughtConstant;
112467:         return true;
112467:       }
112467:       default:
112467:         return true;
112467:     }
112467: 
113402:     RootedObject proto(cx);
113609:     if (!js_GetClassPrototype(cx, key, &proto, NULL))
112467:         return false;
112467: 
112467:     return TestSingletonProperty(cx, proto, id, isKnownConstant);
112467: }
112467: 
112121: // Given an actual and observed type set, annotates the IR as much as possible:
112121: // (1) If no type information is provided, the value on the top of the stack is
112121: //     left in place.
112121: // (2) If a single type definitely exists, and no type barrier is in place,
112121: //     then an infallible unbox instruction replaces the value on the top of
112121: //     the stack.
112121: // (3) If a type barrier is in place, but has an unknown type set, leave the
112121: //     value at the top of the stack.
112121: // (4) If a type barrier is in place, and has a single type, an unbox
112121: //     instruction replaces the top of the stack.
112121: // (5) Lastly, a type barrier instruction replaces the top of the stack.
112118: bool
113609: IonBuilder::pushTypeBarrier(MInstruction *ins, types::StackTypeSet *actual,
113609:                             types::StackTypeSet *observed)
112118: {
125828:     AutoAssertNoGC nogc;
125828: 
112302:     // If the instruction has no side effects, we'll resume the entire operation.
112121:     // The actual type barrier will occur in the interpreter. If the
112302:     // instruction is effectful, even if it has a singleton type, there
112302:     // must be a resume point capturing the original def, and resuming
112121:     // to that point will explicitly monitor the new type.
112118: 
112121:     if (!actual) {
112121:         JS_ASSERT(!observed);
112118:         return true;
112121:     }
112121: 
112121:     if (!observed) {
113609:         JSValueType type = actual->getKnownTypeTag();
112121:         MInstruction *replace = NULL;
112121:         switch (type) {
112121:           case JSVAL_TYPE_UNDEFINED:
125403:             ins->setFoldedUnchecked();
112121:             replace = MConstant::New(UndefinedValue());
112121:             break;
112121:           case JSVAL_TYPE_NULL:
125403:             ins->setFoldedUnchecked();
112121:             replace = MConstant::New(NullValue());
112121:             break;
112121:           case JSVAL_TYPE_UNKNOWN:
112121:             break;
112184:           default: {
112184:             MIRType replaceType = MIRTypeFromValueType(type);
112184:             if (ins->type() == MIRType_Value)
112184:                 replace = MUnbox::New(ins, replaceType, MUnbox::Infallible);
112184:             else
112184:                 JS_ASSERT(ins->type() == replaceType);
112121:             break;
112121:           }
112184:         }
112121:         if (replace) {
112121:             current->pop();
112121:             current->add(replace);
112121:             current->push(replace);
112121:         }
112121:         return true;
112121:     }
112121: 
112121:     if (observed->unknown())
112121:         return true;
112121: 
112121:     current->pop();
112118: 
112118:     MInstruction *barrier;
113609:     JSValueType type = observed->getKnownTypeTag();
112121: 
113156:     // An unbox instruction isn't enough to capture JSVAL_TYPE_OBJECT. Use a type
113156:     // barrier followed by an infallible unbox.
113156:     bool isObject = false;
113156:     if (type == JSVAL_TYPE_OBJECT && !observed->hasType(types::Type::AnyObjectType())) {
112121:         type = JSVAL_TYPE_UNKNOWN;
113156:         isObject = true;
113156:     }
112121: 
112256:     switch (type) {
112256:       case JSVAL_TYPE_UNKNOWN:
112256:       case JSVAL_TYPE_UNDEFINED:
112256:       case JSVAL_TYPE_NULL:
124001:         barrier = MTypeBarrier::New(ins, cloneTypeSet(observed));
112118:         current->add(barrier);
112118: 
112118:         if (type == JSVAL_TYPE_UNDEFINED)
112118:             return pushConstant(UndefinedValue());
112118:         if (type == JSVAL_TYPE_NULL)
112118:             return pushConstant(NullValue());
113156:         if (isObject) {
113156:             barrier = MUnbox::New(barrier, MIRType_Object, MUnbox::Infallible);
113156:             current->add(barrier);
113156:         }
112256:         break;
112256:       default:
112844:         MUnbox::Mode mode = ins->isEffectful() ? MUnbox::TypeBarrier : MUnbox::TypeGuard;
112118:         barrier = MUnbox::New(ins, MIRTypeFromValueType(type), mode);
112118:         current->add(barrier);
112118:     }
112118:     current->push(barrier);
112118:     return true;
112118: }
112118: 
112743: // Test the type of values returned by a VM call. This is an optimized version
112743: // of calling TypeScript::Monitor inside such stubs.
112743: void
116269: IonBuilder::monitorResult(MInstruction *ins, types::TypeSet *barrier, types::TypeSet *types)
116269: {
116269:     // MonitorTypes is redundant if we will also add a type barrier.
116269:     if (barrier)
116269:         return;
116269: 
112743:     if (!types || types->unknown())
112743:         return;
112743: 
124001:     MInstruction *monitor = MMonitorTypes::New(ins, cloneTypeSet(types));
112743:     current->add(monitor);
112743: }
112743: 
112118: bool
113095: IonBuilder::jsop_getgname(HandlePropertyName name)
112118: {
112118:     // Optimize undefined, NaN, and Infinity.
114207:     if (name == cx->names().undefined)
112118:         return pushConstant(UndefinedValue());
114207:     if (name == cx->names().NaN)
112118:         return pushConstant(cx->runtime->NaNValue);
114207:     if (name == cx->names().Infinity)
112118:         return pushConstant(cx->runtime->positiveInfinityValue);
112118: 
125568:     RootedObject globalObj(cx, &script()->global());
112118:     JS_ASSERT(globalObj->isNative());
112118: 
113132:     RootedId id(cx, NameToId(name));
113095: 
112118:     // For the fastest path, the property must be found, and it must be found
112118:     // as a normal data property on exactly the global object.
125828:     RootedShape shape(cx, globalObj->nativeLookup(cx, id));
112926:     if (!shape || !shape->hasDefaultGetter() || !shape->hasSlot())
113095:         return jsop_getname(name);
112446: 
125568:     types::HeapTypeSet *propertyTypes = oracle->globalPropertyTypeSet(script(), pc, id);
112446:     if (propertyTypes && propertyTypes->isOwnProperty(cx, globalObj->getType(cx), true)) {
112446:         // The property has been reconfigured as non-configurable, non-enumerable
112446:         // or non-writable.
113095:         return jsop_getname(name);
112446:     }
112118: 
112118:     // If the property is permanent, a shape guard isn't necessary.
112118:     JSValueType knownType = JSVAL_TYPE_UNKNOWN;
112118: 
125568:     RootedScript scriptRoot(cx, script());
125568:     types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
112118:     if (types) {
113609:         JSObject *singleton = types->getSingleton();
113609: 
113609:         knownType = types->getKnownTypeTag();
112118:         if (!barrier) {
112118:             if (singleton) {
112118:                 // Try to inline a known constant value.
112119:                 bool isKnownConstant;
112119:                 if (!TestSingletonProperty(cx, globalObj, id, &isKnownConstant))
112118:                     return false;
112119:                 if (isKnownConstant)
112118:                     return pushConstant(ObjectValue(*singleton));
112118:             }
112118:             if (knownType == JSVAL_TYPE_UNDEFINED)
112118:                 return pushConstant(UndefinedValue());
112118:             if (knownType == JSVAL_TYPE_NULL)
112118:                 return pushConstant(NullValue());
112118:         }
112118:     }
112118: 
112118:     MInstruction *global = MConstant::New(ObjectValue(*globalObj));
112118:     current->add(global);
112118: 
112230:     // If we have a property typeset, the isOwnProperty call will trigger recompilation if
112230:     // the property is deleted or reconfigured.
120777:     if (!propertyTypes && shape->configurable())
120777:         global = addShapeGuard(global, globalObj->lastProperty(), Bailout_ShapeGuard);
112118: 
112249:     JS_ASSERT(shape->slot() >= globalObj->numFixedSlots());
112118: 
112118:     MSlots *slots = MSlots::New(global);
112118:     current->add(slots);
112249:     MLoadSlot *load = MLoadSlot::New(slots, shape->slot() - globalObj->numFixedSlots());
112118:     current->add(load);
112118: 
112118:     // Slot loads can be typed, if they have a single, known, definitive type.
112120:     if (knownType != JSVAL_TYPE_UNKNOWN && !barrier)
112118:         load->setResultType(MIRTypeFromValueType(knownType));
112120: 
112118:     current->push(load);
112120:     return pushTypeBarrier(load, types, barrier);
112118: }
112118: 
112193: bool
113095: IonBuilder::jsop_setgname(HandlePropertyName name)
112193: {
125568:     RootedObject globalObj(cx, &script()->global());
113132:     RootedId id(cx, NameToId(name));
112193: 
113124:     JS_ASSERT(globalObj->isNative());
113124: 
112193:     bool canSpecialize;
125568:     types::HeapTypeSet *propertyTypes = oracle->globalPropertyWrite(script(), pc, id, &canSpecialize);
112193: 
112193:     // This should only happen for a few names like __proto__.
113124:     if (!canSpecialize || globalObj->watched())
113095:         return jsop_setprop(name);
112193: 
112193:     // For the fastest path, the property must be found, and it must be found
112193:     // as a normal data property on exactly the global object.
125828:     RootedShape shape(cx, globalObj->nativeLookup(cx, id));
112926:     if (!shape || !shape->hasDefaultSetter() || !shape->writable() || !shape->hasSlot())
113095:         return jsop_setprop(name);
112446: 
112446:     if (propertyTypes && propertyTypes->isOwnProperty(cx, globalObj->getType(cx), true)) {
112446:         // The property has been reconfigured as non-configurable, non-enumerable
112446:         // or non-writable.
113095:         return jsop_setprop(name);
112446:     }
112193: 
112193:     MInstruction *global = MConstant::New(ObjectValue(*globalObj));
112193:     current->add(global);
112193: 
112193:     // If we have a property type set, the isOwnProperty call will trigger recompilation
112193:     // if the property is deleted or reconfigured. Without TI, we always need a shape guard
112193:     // to guard against the property being reconfigured as non-writable.
120777:     if (!propertyTypes)
120777:         global = addShapeGuard(global, globalObj->lastProperty(), Bailout_ShapeGuard);
112193: 
112249:     JS_ASSERT(shape->slot() >= globalObj->numFixedSlots());
112193: 
112193:     MSlots *slots = MSlots::New(global);
112193:     current->add(slots);
112193: 
112193:     MDefinition *value = current->pop();
112249:     MStoreSlot *store = MStoreSlot::New(slots, shape->slot() - globalObj->numFixedSlots(), value);
112193:     current->add(store);
112193: 
112199:     // Determine whether write barrier is required.
113147:     if (!propertyTypes || propertyTypes->needsBarrier(cx))
113423:         store->setNeedsBarrier();
112199: 
112193:     // Pop the global object pushed by bindgname.
112194:     DebugOnly<MDefinition *> pushedGlobal = current->pop();
112193:     JS_ASSERT(&pushedGlobal->toConstant()->value().toObject() == globalObj);
112193: 
112193:     // If the property has a known type, we may be able to optimize typed stores by not
112193:     // storing the type tag. This only works if the property does not have its initial
112193:     // |undefined| value; if |undefined| is assigned at a later point, it will be added
112193:     // to the type set.
112249:     if (propertyTypes && !globalObj->getSlot(shape->slot()).isUndefined()) {
112193:         JSValueType knownType = propertyTypes->getKnownTypeTag(cx);
112193:         if (knownType != JSVAL_TYPE_UNKNOWN)
112193:             store->setSlotType(MIRTypeFromValueType(knownType));
112193:     }
112193: 
113010:     JS_ASSERT_IF(store->needsBarrier(), store->slotType() != MIRType_None);
113010: 
112193:     current->push(value);
113091:     return resumeAfter(store);
112193: }
112231: 
112231: bool
113095: IonBuilder::jsop_getname(HandlePropertyName name)
112401: {
112446:     MDefinition *object;
112446:     if (js_CodeSpec[*pc].format & JOF_GNAME) {
125568:         MInstruction *global = MConstant::New(ObjectValue(script()->global()));
112446:         current->add(global);
112446:         object = global;
112446:     } else {
113175:         current->push(current->scopeChain());
112446:         object = current->pop();
112446:     }
112401: 
113177:     MGetNameCache *ins;
113177:     if (JSOp(*GetNextPc(pc)) == JSOP_TYPEOF)
113177:         ins = MGetNameCache::New(object, name, MGetNameCache::NAMETYPEOF);
112401:     else
113177:         ins = MGetNameCache::New(object, name, MGetNameCache::NAME);
112401: 
112401:     current->add(ins);
112401:     current->push(ins);
112401: 
112401:     if (!resumeAfter(ins))
112401:         return false;
112401: 
125568:     RootedScript scriptRoot(cx, script());
125568:     types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
112743: 
116269:     monitorResult(ins, barrier, types);
112401:     return pushTypeBarrier(ins, types, barrier);
112401: }
112401: 
112401: bool
126026: IonBuilder::jsop_intrinsic(HandlePropertyName name)
122024: {
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
122024:     JSValueType type = types->getKnownTypeTag();
122024: 
122024:     // If we haven't executed this opcode yet, we need to get the intrinsic
122024:     // value and monitor the result.
122024:     if (type == JSVAL_TYPE_UNKNOWN) {
122024:         MCallGetIntrinsicValue *ins = MCallGetIntrinsicValue::New(name);
122024: 
122024:         current->add(ins);
122024:         current->push(ins);
122024: 
122024:         if (!resumeAfter(ins))
122024:             return false;
122024: 
125568:         RootedScript scriptRoot(cx, script());
125568:         types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
122024:         monitorResult(ins, barrier, types);
122024:         return pushTypeBarrier(ins, types, barrier);
122024:     }
122024: 
122024:     // Bake in the intrinsic. Make sure that TI agrees with us on the type.
122024:     RootedValue vp(cx, UndefinedValue());
122024:     if (!cx->global()->getIntrinsicValue(cx, name, &vp))
122024:         return false;
122024: 
122024:     JS_ASSERT(types->hasType(types::GetValueType(cx, vp)));
122024: 
122024:     MConstant *ins = MConstant::New(vp);
122024:     current->add(ins);
122024:     current->push(ins);
122024: 
122024:     return true;
122024: }
122024: 
122024: bool
112766: IonBuilder::jsop_bindname(PropertyName *name)
112766: {
125568:     JS_ASSERT(script()->analysis()->usesScopeChain());
112766: 
113175:     MDefinition *scopeChain = current->scopeChain();
125568:     MBindNameCache *ins = MBindNameCache::New(scopeChain, name, script(), pc);
112766: 
112766:     current->add(ins);
112766:     current->push(ins);
112766: 
112766:     return resumeAfter(ins);
112766: }
112766: 
112766: bool
112231: IonBuilder::jsop_getelem()
112231: {
125568:     if (oracle->elementReadIsDenseArray(script(), pc))
112231:         return jsop_getelem_dense();
112231: 
112904:     int arrayType = TypedArray::TYPE_MAX;
125568:     if (oracle->elementReadIsTypedArray(script(), pc, &arrayType))
112904:         return jsop_getelem_typed(arrayType);
112904: 
125568:     if (oracle->elementReadIsString(script(), pc))
113164:         return jsop_getelem_string();
113164: 
125568:     LazyArgumentsType isArguments = oracle->elementReadMagicArguments(script(), pc);
113215:     if (isArguments == MaybeArguments)
113215:         return abort("Type is not definitely lazy arguments.");
113215:     if (isArguments == DefinitelyArguments)
113198:         return jsop_arguments_getelem();
113198: 
112486:     MDefinition *rhs = current->pop();
112486:     MDefinition *lhs = current->pop();
112486: 
112859:     MInstruction *ins;
112859: 
112859:     // TI does not account for GETELEM with string indexes, so we have to monitor
112859:     // the result of MGetElementCache if it's expected to access string properties.
112859:     // If the result of MGetElementCache is not monitored, we won't generate any
112859:     // getprop stubs.
112859:     bool mustMonitorResult = false;
112859:     bool cacheable = false;
112859: 
125568:     oracle->elementReadGeneric(script(), pc, &cacheable, &mustMonitorResult);
112859: 
112859:     if (cacheable)
112859:         ins = MGetElementCache::New(lhs, rhs, mustMonitorResult);
112859:     else
112859:         ins = MCallGetElement::New(lhs, rhs);
112859: 
112486:     current->add(ins);
112486:     current->push(ins);
112486: 
112486:     if (!resumeAfter(ins))
112486:         return false;
112486: 
125568:     RootedScript scriptRoot(cx, script());
125568:     types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
112743: 
112859:     if (mustMonitorResult)
116269:         monitorResult(ins, barrier, types);
112486:     return pushTypeBarrier(ins, types, barrier);
112231: }
112231: 
112231: bool
112231: IonBuilder::jsop_getelem_dense()
112231: {
112351:     if (oracle->arrayPrototypeHasIndexedProperty())
112231:         return abort("GETELEM Array proto has indexed properties");
112231: 
125568:     RootedScript scriptRoot(cx, script());
125568:     types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
125568:     bool needsHoleCheck = !oracle->elementReadIsPacked(script(), pc);
112508:     bool maybeUndefined = types->hasType(types::Type::UndefinedType());
112231: 
112231:     MDefinition *id = current->pop();
112231:     MDefinition *obj = current->pop();
112231: 
112231:     JSValueType knownType = JSVAL_TYPE_UNKNOWN;
125350:     if (!barrier) {
113609:         knownType = types->getKnownTypeTag();
112231: 
112547:         // Null and undefined have no payload so they can't be specialized.
112547:         // Since folding null/undefined while building SSA is not safe (see the
112547:         // comment in IsPhiObservable), we just add an untyped load instruction
112547:         // and rely on pushTypeBarrier and DCE to replace it with a null/undefined
112547:         // constant.
112547:         if (knownType == JSVAL_TYPE_UNDEFINED || knownType == JSVAL_TYPE_NULL)
112547:             knownType = JSVAL_TYPE_UNKNOWN;
125350: 
125350:         // Different architectures may want typed element reads which require
125350:         // hole checks to be done as either value or typed reads.
125350:         if (needsHoleCheck && !LIRGenerator::allowTypedElementHoleCheck())
125350:             knownType = JSVAL_TYPE_UNKNOWN;
112231:     }
112231: 
112231:     // Ensure id is an integer.
112231:     MInstruction *idInt32 = MToInt32::New(id);
112231:     current->add(idInt32);
112231:     id = idInt32;
112231: 
112258:     // Get the elements vector.
112258:     MElements *elements = MElements::New(obj);
112258:     current->add(elements);
112258: 
112258:     MInitializedLength *initLength = MInitializedLength::New(elements);
112231:     current->add(initLength);
112231: 
112508:     MInstruction *load;
112508: 
112508:     if (!maybeUndefined) {
112508:         // This load should not return undefined, so likely we're reading
112508:         // in-bounds elements, and the array is packed or its holes are not
112508:         // read. This is the best case: we can separate the bounds check for
112508:         // hoisting.
113380:         id = addBoundsCheck(id, initLength);
112231: 
112508:         load = MLoadElement::New(elements, id, needsHoleCheck);
112231:         current->add(load);
112508:     } else {
112508:         // This load may return undefined, so assume that we *can* read holes,
112508:         // or that we can read out-of-bounds accesses. In this case, the bounds
112508:         // check is part of the opcode.
112508:         load = MLoadElementHole::New(elements, id, initLength, needsHoleCheck);
112508:         current->add(load);
112508: 
112508:         // If maybeUndefined was true, the typeset must have undefined, and
112508:         // then either additional types or a barrier. This means we should
112508:         // never have a typed version of LoadElementHole.
112508:         JS_ASSERT(knownType == JSVAL_TYPE_UNKNOWN);
112508:     }
112231: 
112231:     if (knownType != JSVAL_TYPE_UNKNOWN)
112231:         load->setResultType(MIRTypeFromValueType(knownType));
112231: 
112231:     current->push(load);
112231:     return pushTypeBarrier(load, types, barrier);
112231: }
112231: 
113395: static MInstruction *
113395: GetTypedArrayLength(MDefinition *obj)
113395: {
113395:     if (obj->isConstant()) {
113395:         JSObject *array = &obj->toConstant()->value().toObject();
113395:         int32_t length = (int32_t) TypedArray::length(array);
125403:         obj->setFoldedUnchecked();
113395:         return MConstant::New(Int32Value(length));
113395:     }
113395:     return MTypedArrayLength::New(obj);
113395: }
113395: 
113395: static MInstruction *
113395: GetTypedArrayElements(MDefinition *obj)
113395: {
113395:     if (obj->isConstant()) {
113395:         JSObject *array = &obj->toConstant()->value().toObject();
113395:         void *data = TypedArray::viewData(array);
125403:         obj->setFoldedUnchecked();
113395:         return MConstantElements::New(data);
113395:     }
113395:     return MTypedArrayElements::New(obj);
113395: }
113395: 
112231: bool
112904: IonBuilder::jsop_getelem_typed(int arrayType)
112904: {
125568:     RootedScript scriptRoot(cx, script());
125568:     types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
112904: 
112904:     MDefinition *id = current->pop();
112904:     MDefinition *obj = current->pop();
112904: 
112904:     bool maybeUndefined = types->hasType(types::Type::UndefinedType());
112904: 
112904:     // Reading from an Uint32Array will result in a double for values
112904:     // that don't fit in an int32. We have to bailout if this happens
112904:     // and the instruction is not known to return a double.
112904:     bool allowDouble = types->hasType(types::Type::DoubleType());
112904: 
112904:     // Ensure id is an integer.
112904:     MInstruction *idInt32 = MToInt32::New(id);
112904:     current->add(idInt32);
112904:     id = idInt32;
112904: 
112904:     if (!maybeUndefined) {
112904:         // Assume the index is in range, so that we can hoist the length,
112904:         // elements vector and bounds check.
112904: 
112904:         // If we are reading in-bounds elements, we can use knowledge about
112904:         // the array type to determine the result type. This may be more
112904:         // precise than the known pushed type.
112904:         MIRType knownType;
112904:         switch (arrayType) {
112904:           case TypedArray::TYPE_INT8:
112904:           case TypedArray::TYPE_UINT8:
112904:           case TypedArray::TYPE_UINT8_CLAMPED:
112904:           case TypedArray::TYPE_INT16:
112904:           case TypedArray::TYPE_UINT16:
112904:           case TypedArray::TYPE_INT32:
112904:             knownType = MIRType_Int32;
112904:             break;
112904:           case TypedArray::TYPE_UINT32:
112904:             knownType = allowDouble ? MIRType_Double : MIRType_Int32;
112904:             break;
112904:           case TypedArray::TYPE_FLOAT32:
112904:           case TypedArray::TYPE_FLOAT64:
112904:             knownType = MIRType_Double;
112904:             break;
112904:           default:
112904:             JS_NOT_REACHED("Unknown typed array type");
112904:             return false;
112904:         }
112904: 
112904:         // Get the length.
113395:         MInstruction *length = GetTypedArrayLength(obj);
112904:         current->add(length);
112904: 
112904:         // Bounds check.
113380:         id = addBoundsCheck(id, length);
112904: 
112904:         // Get the elements vector.
113395:         MInstruction *elements = GetTypedArrayElements(obj);
112904:         current->add(elements);
112904: 
112904:         // Load the element.
112904:         MLoadTypedArrayElement *load = MLoadTypedArrayElement::New(elements, id, arrayType);
112904:         current->add(load);
112904:         current->push(load);
112904: 
112904:         load->setResultType(knownType);
112904: 
112904:         // Note: we can ignore the type barrier here, we know the type must
112904:         // be valid and unbarriered.
112904:         JS_ASSERT_IF(knownType == MIRType_Int32, types->hasType(types::Type::Int32Type()));
112904:         JS_ASSERT_IF(knownType == MIRType_Double, types->hasType(types::Type::DoubleType()));
112904:         return true;
112904:     } else {
112904:         // Assume we will read out-of-bound values. In this case the
112904:         // bounds check will be part of the instruction, and the instruction
112904:         // will always return a Value.
114404:         MLoadTypedArrayElementHole *load =
114404:             MLoadTypedArrayElementHole::New(obj, id, arrayType, allowDouble);
112904:         current->add(load);
112904:         current->push(load);
112904: 
112904:         return resumeAfter(load) && pushTypeBarrier(load, types, barrier);
112904:     }
112904: }
112904: 
112904: bool
113164: IonBuilder::jsop_getelem_string()
113164: {
113164:     MDefinition *id = current->pop();
113164:     MDefinition *str = current->pop();
113164: 
113164:     MInstruction *idInt32 = MToInt32::New(id);
113164:     current->add(idInt32);
113164:     id = idInt32;
113164: 
113164:     MStringLength *length = MStringLength::New(str);
113164:     current->add(length);
113164: 
119479:     // This will cause an invalidation of this script once the 'undefined' type
119479:     // is monitored by the interpreter.
125568:     JS_ASSERT(oracle->propertyRead(script(), pc)->getKnownTypeTag() == JSVAL_TYPE_STRING);
113380:     id = addBoundsCheck(id, length);
113164: 
113164:     MCharCodeAt *charCode = MCharCodeAt::New(str, id);
113164:     current->add(charCode);
113164: 
113164:     MFromCharCode *result = MFromCharCode::New(charCode);
113164:     current->add(result);
113164:     current->push(result);
113164:     return true;
113164: }
113164: 
113164: bool
112231: IonBuilder::jsop_setelem()
112231: {
125568:     if (oracle->propertyWriteCanSpecialize(script(), pc)) {
125883:         RootedScript scriptRoot(cx, script());
125883:         if (oracle->elementWriteIsDenseArray(scriptRoot, pc))
112231:             return jsop_setelem_dense();
112936: 
112936:         int arrayType = TypedArray::TYPE_MAX;
125568:         if (oracle->elementWriteIsTypedArray(script(), pc, &arrayType))
112936:             return jsop_setelem_typed(arrayType);
112487:     }
112487: 
125568:     LazyArgumentsType isArguments = oracle->elementWriteMagicArguments(script(), pc);
113215:     if (isArguments == MaybeArguments)
113215:         return abort("Type is not definitely lazy arguments.");
113215:     if (isArguments == DefinitelyArguments)
113198:         return jsop_arguments_setelem();
113198: 
112487:     MDefinition *value = current->pop();
112487:     MDefinition *index = current->pop();
112487:     MDefinition *object = current->pop();
112487: 
112487:     MInstruction *ins = MCallSetElement::New(object, index, value);
112487:     current->add(ins);
112487:     current->push(value);
112487: 
112487:     return resumeAfter(ins);
112231: }
112231: 
112231: bool
112231: IonBuilder::jsop_setelem_dense()
112231: {
112351:     if (oracle->arrayPrototypeHasIndexedProperty())
112231:         return abort("SETELEM Array proto has indexed properties");
112231: 
125568:     MIRType elementType = oracle->elementWrite(script(), pc);
125568:     bool packed = oracle->elementWriteIsPacked(script(), pc);
112231: 
112231:     MDefinition *value = current->pop();
112231:     MDefinition *id = current->pop();
112231:     MDefinition *obj = current->pop();
112231: 
112231:     // Ensure id is an integer.
112231:     MInstruction *idInt32 = MToInt32::New(id);
112231:     current->add(idInt32);
112231:     id = idInt32;
112231: 
112258:     // Get the elements vector.
112258:     MElements *elements = MElements::New(obj);
112258:     current->add(elements);
112258: 
112524:     // Use MStoreElementHole if this SETELEM has written to out-of-bounds
112524:     // indexes in the past. Otherwise, use MStoreElement so that we can hoist
112524:     // the initialized length and bounds check.
112524:     MStoreElementCommon *store;
125568:     if (oracle->setElementHasWrittenHoles(script(), pc)) {
112524:         MStoreElementHole *ins = MStoreElementHole::New(obj, elements, id, value);
112524:         store = ins;
112524: 
112524:         current->add(ins);
112524:         current->push(value);
112524: 
112524:         if (!resumeAfter(ins))
112524:             return false;
112524:     } else {
112258:         MInitializedLength *initLength = MInitializedLength::New(elements);
112231:         current->add(initLength);
112231: 
113380:         id = addBoundsCheck(id, initLength);
112231: 
112524:         MStoreElement *ins = MStoreElement::New(elements, id, value);
112524:         store = ins;
112524: 
112524:         current->add(ins);
112231:         current->push(value);
112231: 
112524:         if (!resumeAfter(ins))
112524:             return false;
112524:     }
112524: 
112236:     // Determine whether a write barrier is required.
125568:     if (oracle->elementWriteNeedsBarrier(script(), pc))
113423:         store->setNeedsBarrier();
112236: 
112231:     if (elementType != MIRType_None && packed)
112258:         store->setElementType(elementType);
112231: 
112524:     return true;
112231: }
112289: 
112289: bool
112936: IonBuilder::jsop_setelem_typed(int arrayType)
112936: {
112936:     MDefinition *value = current->pop();
112936:     MDefinition *id = current->pop();
112936:     MDefinition *obj = current->pop();
112936: 
112936:     // Ensure id is an integer.
112936:     MInstruction *idInt32 = MToInt32::New(id);
112936:     current->add(idInt32);
112936:     id = idInt32;
112936: 
112936:     // Get the length.
113395:     MInstruction *length = GetTypedArrayLength(obj);
112936:     current->add(length);
112936: 
112936:     // Bounds check.
113380:     id = addBoundsCheck(id, length);
112936: 
112936:     // Get the elements vector.
113395:     MInstruction *elements = GetTypedArrayElements(obj);
112936:     current->add(elements);
112936: 
112936:     // Clamp value to [0, 255] for Uint8ClampedArray.
112936:     MDefinition *unclampedValue = value;
112936:     if (arrayType == TypedArray::TYPE_UINT8_CLAMPED) {
112936:         value = MClampToUint8::New(value);
112936:         current->add(value->toInstruction());
112936:     }
112936: 
112936:     // Store the value.
112936:     MStoreTypedArrayElement *store = MStoreTypedArrayElement::New(elements, id, value, arrayType);
112936:     current->add(store);
112936: 
112936:     current->push(unclampedValue);
112936:     return resumeAfter(store);
112936: }
112936: 
112936: bool
112309: IonBuilder::jsop_length()
112309: {
112309:     if (jsop_length_fastPath())
112309:         return true;
113095: 
113132:     RootedPropertyName name(cx, info().getAtom(pc)->asPropertyName());
113095:     return jsop_getprop(name);
112309: }
112309: 
112309: bool
112309: IonBuilder::jsop_length_fastPath()
112309: {
125568:     TypeOracle::UnaryTypes sig = oracle->unaryTypes(script(), pc);
112309:     if (!sig.inTypes || !sig.outTypes)
112309:         return false;
112309: 
113609:     if (sig.outTypes->getKnownTypeTag() != JSVAL_TYPE_INT32)
112309:         return false;
112309: 
113609:     switch (sig.inTypes->getKnownTypeTag()) {
112309:       case JSVAL_TYPE_STRING: {
112309:         MDefinition *obj = current->pop();
112714:         MStringLength *ins = MStringLength::New(obj);
112309:         current->add(ins);
112309:         current->push(ins);
112309:         return true;
112309:       }
112309: 
112309:       case JSVAL_TYPE_OBJECT: {
112867:         if (!sig.inTypes->hasObjectFlags(cx, types::OBJECT_FLAG_NON_DENSE_ARRAY)) {
112309:             MDefinition *obj = current->pop();
112309:             MElements *elements = MElements::New(obj);
112309:             current->add(elements);
112309: 
112309:             // Read length.
112309:             MArrayLength *length = new MArrayLength(elements);
112309:             current->add(length);
112309:             current->push(length);
112309:             return true;
112309:         }
112309: 
112867:         if (!sig.inTypes->hasObjectFlags(cx, types::OBJECT_FLAG_NON_TYPED_ARRAY)) {
112867:             MDefinition *obj = current->pop();
113395:             MInstruction *length = GetTypedArrayLength(obj);
112867:             current->add(length);
112867:             current->push(length);
112867:             return true;
112867:         }
112867: 
112867:         return false;
112867:       }
112867: 
112309:       default:
112309:         break;
112309:     }
112309: 
112309:     return false;
112309: }
112309: 
113198: bool
113199: IonBuilder::jsop_arguments()
113199: {
113411:     JS_ASSERT(lazyArguments_);
113411:     current->push(lazyArguments_);
113199:     return true;
113199: }
113199: 
113199: bool
113198: IonBuilder::jsop_arguments_length()
113198: {
113411:     // Type Inference has guaranteed this is an optimized arguments object.
125403:     MDefinition *args = current->pop();
125403:     args->setFoldedUnchecked();
113411: 
113411:     MInstruction *ins = MArgumentsLength::New();
113199:     current->add(ins);
113199:     current->push(ins);
113199:     return true;
113198: }
113198: 
113198: bool
113198: IonBuilder::jsop_arguments_getelem()
113198: {
125568:     RootedScript scriptRoot(cx, script());
125568:     types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
113200: 
113198:     MDefinition *idx = current->pop();
113411: 
113411:     // Type Inference has guaranteed this is an optimized arguments object.
125403:     MDefinition *args = current->pop();
125403:     args->setFoldedUnchecked();
113200: 
113200:     // To ensure that we are not looking above the number of actual arguments.
113411:     MArgumentsLength *length = MArgumentsLength::New();
113200:     current->add(length);
113200: 
113200:     // Ensure idx is an integer.
113380:     MInstruction *index = MToInt32::New(idx);
113200:     current->add(index);
113200: 
113200:     // Bailouts if we read more than the number of actual arguments.
113380:     index = addBoundsCheck(index, length);
113200: 
113200:     // Load the argument from the actual arguments.
113200:     MGetArgument *load = MGetArgument::New(index);
113200:     current->add(load);
113200:     current->push(load);
113200: 
113200:     return pushTypeBarrier(load, types, barrier);
113198: }
113198: 
113198: bool
113198: IonBuilder::jsop_arguments_setelem()
113198: {
113198:     return abort("NYI arguments[]=");
113198: }
113198: 
113609: inline types::HeapTypeSet *
113609: GetDefiniteSlot(JSContext *cx, types::StackTypeSet *types, JSAtom *atom)
112467: {
112467:     if (!types || types->unknownObject() || types->getObjectCount() != 1)
112735:         return NULL;
112467: 
112467:     types::TypeObject *type = types->getTypeObject(0);
112467:     if (!type || type->unknownProperties())
112735:         return NULL;
112467: 
113030:     jsid id = AtomToId(atom);
112467:     if (id != types::MakeTypeId(cx, id))
112735:         return NULL;
112467: 
113609:     types::HeapTypeSet *propertyTypes = type->getProperty(cx, id, false);
112467:     if (!propertyTypes ||
113609:         !propertyTypes->definiteProperty() ||
112467:         propertyTypes->isOwnProperty(cx, type, true))
112467:     {
112735:         return NULL;
112467:     }
112467: 
112726:     return propertyTypes;
112467: }
112467: 
112309: bool
112696: IonBuilder::jsop_not()
112696: {
112696:     MDefinition *value = current->pop();
112696: 
112696:     MNot *ins = new MNot(value);
112696:     current->add(ins);
112696:     current->push(ins);
126213:     TypeOracle::UnaryTypes types = oracle->unaryTypes(script(), pc);
126213:     ins->infer(types, cx);
112696:     return true;
112696: }
112696: 
113327: 
113327: inline bool
113609: IonBuilder::TestCommonPropFunc(JSContext *cx, types::StackTypeSet *types, HandleId id,
124266:                                JSFunction **funcp, bool isGetter, bool *isDOM,
124266:                                MDefinition **guardOut)
113327: {
113327:     JSObject *found = NULL;
113327:     JSObject *foundProto = NULL;
113327: 
113327:     *funcp = NULL;
113515:     *isDOM = false;
113515: 
113515:     bool thinkDOM = true;
113327: 
113327:     // No sense looking if we don't know what's going on.
113327:     if (!types || types->unknownObject())
113327:         return true;
113327: 
113327:     // Iterate down all the types to see if they all have the same getter or
113327:     // setter.
113327:     for (unsigned i = 0; i < types->getObjectCount(); i++) {
113574:         RootedObject curObj(cx, types->getSingleObject(i));
113327: 
113327:         // Non-Singleton type
113327:         if (!curObj) {
113327:             types::TypeObject *typeObj = types->getTypeObject(i);
113327: 
113327:             if (!typeObj)
113327:                 continue;
113327: 
113327:             if (typeObj->unknownProperties())
113327:                 return true;
113327: 
113327:             // If the type has an own property, we can't be sure we don't shadow
113327:             // the chain.
113327:             jsid typeId = types::MakeTypeId(cx, id);
113609:             types::HeapTypeSet *propSet = typeObj->getProperty(cx, typeId, false);
113327:             if (!propSet)
113327:                 return false;
115081:             if (propSet->ownProperty(false))
113327:                 return true;
113327: 
113515:             // Check the DOM status of the instance type
113515:             thinkDOM = thinkDOM && !typeObj->hasAnyFlags(types::OBJECT_FLAG_NON_DOM);
113515: 
113327:             // Otherwise try using the prototype.
113327:             curObj = typeObj->proto;
113488:         } else {
113565:             // We can't optimize setters on watched singleton objects. A getter
113565:             // on an own property can be protected with the prototype
113565:             // shapeguard, though.
113488:             if (!isGetter && curObj->watched())
113488:                 return true;
113515: 
113515:             // Check the DOM-ness of the singleton.
113515:             types::TypeObject *objType = curObj->getType(cx);
113515:             thinkDOM = thinkDOM && !objType->hasAnyFlags(types::OBJECT_FLAG_NON_DOM);
113327:         }
113327: 
113327:         // Turns out that we need to check for a property lookup op, else we
113327:         // will end up calling it mid-compilation.
113512:         if (!CanEffectlesslyCallLookupGenericOnObject(curObj))
113327:             return true;
113327: 
113402:         RootedObject proto(cx);
113402:         RootedShape shape(cx);
113574:         if (!JSObject::lookupGeneric(cx, curObj, id, &proto, &shape))
113327:             return false;
113402: 
113402:         if (!shape)
113327:             return true;
113327: 
113327:         // We want to optimize specialized getters/setters. The defaults will
113327:         // hit the slot optimization.
113327:         if (isGetter) {
113327:             if (shape->hasDefaultGetter() || !shape->hasGetterValue())
113327:                 return true;
113327:         } else {
113327:             if (shape->hasDefaultSetter() || !shape->hasSetterValue())
113327:                 return true;
113327:         }
113327: 
113327:         JSObject * curFound = isGetter ? shape->getterObject():
113327:                                          shape->setterObject();
113327: 
113327:         // Save the first seen, or verify uniqueness.
113399:         if (!found) {
113399:             if (!curFound->isFunction())
113399:                 return true;
113327:             found = curFound;
113399:         } else if (found != curFound) {
113327:             return true;
113399:         }
113327: 
113327:         // We only support cases with a single prototype shared. This is
113327:         // overwhelmingly more likely than having multiple different prototype
113327:         // chains with the same custom property function.
113347:         if (!foundProto)
113327:             foundProto = proto;
113347:         else if (foundProto != proto)
113327:             return true;
113408: 
115080:         // Check here to make sure that everyone has Type Objects with known
113408:         // properties between them and the proto we found the accessor on. We
113408:         // need those to add freezes safely. NOTE: We do not do this above, as
113408:         // we may be able to freeze all the types up to where we found the
113408:         // property, even if there are unknown types higher in the prototype
113408:         // chain.
113408:         while (curObj != foundProto) {
115080:             types::TypeObject *typeObj = curObj->getType(cx);
115080: 
115080:             if (typeObj->unknownProperties())
113408:                 return true;
113427: 
115080:             // Check here to make sure that nobody on the prototype chain is
115080:             // marked as having the property as an "own property". This can
115080:             // happen in cases of |delete| having been used, or cases with
115080:             // watched objects. If TI ever decides to be more accurate about
115080:             // |delete| handling, this should go back to curObj->watched().
115080: 
115080:             // Even though we are not directly accessing the properties on the whole
115080:             // prototype chain, we need to fault in the sets anyway, as we need
115080:             // to freeze on them.
115080:             jsid typeId = types::MakeTypeId(cx, id);
115080:             types::HeapTypeSet *propSet = typeObj->getProperty(cx, typeId, false);
115080:             if (!propSet)
115080:                 return false;
115081:             if (propSet->ownProperty(false))
113427:                 return true;
113427: 
113408:             curObj = curObj->getProto();
113408:         }
113327:     }
113327: 
113327:     // No need to add a freeze if we didn't find anything
113399:     if (!found)
113327:         return true;
113327: 
113347:     JS_ASSERT(foundProto);
113327: 
113408:     // Add a shape guard on the prototype we found the property on. The rest of
113408:     // the prototype chain is guarded by TI freezes. Note that a shape guard is
113408:     // good enough here, even in the proxy case, because we have ensured there
113408:     // are no lookup hooks for this property.
113327:     MInstruction *wrapper = MConstant::New(ObjectValue(*foundProto));
113327:     current->add(wrapper);
120777:     wrapper = addShapeGuard(wrapper, foundProto->lastProperty(), Bailout_ShapeGuard);
113327: 
124266:     // Pass the guard back so it can be an operand.
124266:     if (isGetter) {
124266:         JS_ASSERT(wrapper->isGuardShape());
124266:         *guardOut = wrapper;
124266:     }
124266: 
113327:     // Now we have to freeze all the property typesets to ensure there isn't a
113327:     // lower shadowing getter or setter installed in the future.
113327:     types::TypeObject *curType;
113327:     for (unsigned i = 0; i < types->getObjectCount(); i++) {
113327:         curType = types->getTypeObject(i);
113408:         JSObject *obj = NULL;
113327:         if (!curType) {
113408:             obj = types->getSingleObject(i);
113327:             if (!obj)
113327:                 continue;
113327: 
113327:             curType = obj->getType(cx);
113327:         }
113327: 
113515:         // Freeze the types as being DOM objects if they are
113515:         if (thinkDOM) {
113515:             // Asking the question adds the freeze
113609:             DebugOnly<bool> wasntDOM =
113609:                 types::HeapTypeSet::HasObjectFlags(cx, curType, types::OBJECT_FLAG_NON_DOM);
113515:             JS_ASSERT(!wasntDOM);
113515:         }
113515: 
113408:         // If we found a Singleton object's own-property, there's nothing to
113408:         // freeze.
113408:         if (obj != foundProto) {
113327:             // Walk the prototype chain. Everyone has to have the property, since we
113327:             // just checked, so propSet cannot be NULL.
113327:             jsid typeId = types::MakeTypeId(cx, id);
113408:             while (true) {
113609:                 types::HeapTypeSet *propSet = curType->getProperty(cx, typeId, false);
115080:                 // This assert is now assured, since we have faulted them in
115080:                 // above.
113327:                 JS_ASSERT(propSet);
113515:                 // Asking, freeze by asking.
113515:                 DebugOnly<bool> isOwn = propSet->isOwnProperty(cx, curType, false);
113408:                 JS_ASSERT(!isOwn);
113408:                 // Don't mark the proto. It will be held down by the shape
113408:                 // guard. This allows us tp use properties found on prototypes
113408:                 // with properties unknown to TI.
113408:                 if (curType->proto == foundProto)
113408:                     break;
113327:                 curType = curType->proto->getType(cx);
113408:             }
113327:         }
113327:     }
113327: 
113399:     *funcp = found->toFunction();
113515:     *isDOM = thinkDOM;
113515: 
113515:     return true;
113515: }
113515: 
113515: static bool
125845: TestShouldDOMCall(JSContext *cx, types::TypeSet *inTypes, HandleFunction func,
125845:                   JSJitInfo::OpType opType)
113515: {
113515:     if (!func->isNative() || !func->jitInfo())
113515:         return false;
113515:     // If all the DOM objects flowing through are legal with this
113515:     // property, we can bake in a call to the bottom half of the DOM
113515:     // accessor
113515:     DOMInstanceClassMatchesProto instanceChecker =
113515:         GetDOMCallbacks(cx->runtime)->instanceClassMatchesProto;
113515: 
113515:     const JSJitInfo *jinfo = func->jitInfo();
125845:     if (jinfo->type != opType)
125845:         return false;
113515: 
113515:     for (unsigned i = 0; i < inTypes->getObjectCount(); i++) {
113515:         types::TypeObject *curType = inTypes->getTypeObject(i);
113515: 
113515:         if (!curType) {
113515:             JSObject *curObj = inTypes->getSingleObject(i);
113515: 
113515:             if (!curObj)
113515:                 continue;
113515: 
113515:             curType = curObj->getType(cx);
113515:         }
113515: 
113515:         JSObject *typeProto = curType->proto;
113515:         RootedObject proto(cx, typeProto);
113515:         if (!instanceChecker(proto, jinfo->protoID, jinfo->depth))
113515:             return false;
113515:     }
113399: 
113327:     return true;
113327: }
113327: 
113516: static bool
113516: TestAreKnownDOMTypes(JSContext *cx, types::TypeSet *inTypes)
113516: {
113516:     if (inTypes->unknown())
113516:         return false;
113516: 
113516:     // First iterate to make sure they all are DOM objects, then freeze all of
113516:     // them as such if they are.
113516:     for (unsigned i = 0; i < inTypes->getObjectCount(); i++) {
113516:         types::TypeObject *curType = inTypes->getTypeObject(i);
113516: 
113516:         if (!curType) {
113516:             JSObject *curObj = inTypes->getSingleObject(i);
113516: 
113516:             // Skip holes in TypeSets.
113516:             if (!curObj)
113516:                 continue;
113516: 
113516:             curType = curObj->getType(cx);
113516:         }
113516: 
113516:         if (curType->unknownProperties())
113516:             return false;
113516: 
113516:         // Unlike TypeSet::HasObjectFlags, TypeObject::hasAnyFlags doesn't add a
113516:         // freeze.
113516:         if (curType->hasAnyFlags(types::OBJECT_FLAG_NON_DOM))
113516:             return false;
113516:     }
113516: 
113516:     // If we didn't check anything, no reason to say yes.
113516:     if (inTypes->getObjectCount() > 0)
113516:         return true;
113516: 
113516:     return false;
113516: }
113516: 
113516: static void
113609: FreezeDOMTypes(JSContext *cx, types::StackTypeSet *inTypes)
113516: {
113516:     for (unsigned i = 0; i < inTypes->getObjectCount(); i++) {
113516:         types::TypeObject *curType = inTypes->getTypeObject(i);
113516: 
113516:         if (!curType) {
113516:             JSObject *curObj = inTypes->getSingleObject(i);
113516: 
113516:             // Skip holes in TypeSets.
113516:             if (!curObj)
113516:                 continue;
113516: 
113516:             curType = curObj->getType(cx);
113516:         }
113516: 
113516:         // Add freeze by asking the question.
113609:         DebugOnly<bool> wasntDOM =
113609:             types::HeapTypeSet::HasObjectFlags(cx, curType, types::OBJECT_FLAG_NON_DOM);
113516:         JS_ASSERT(!wasntDOM);
113516:     }
113516: }
113516: 
113482: bool
113482: IonBuilder::annotateGetPropertyCache(JSContext *cx, MDefinition *obj, MGetPropertyCache *getPropCache,
113609:                                     types::StackTypeSet *objTypes, types::StackTypeSet *pushedTypes)
113482: {
113482:     RootedId id(cx, NameToId(getPropCache->name()));
113534:     if ((jsid)id != types::MakeTypeId(cx, id))
113534:         return true;
113482: 
113482:     // Ensure every pushed value is a singleton.
113482:     if (pushedTypes->unknownObject() || pushedTypes->baseFlags() != 0)
113482:         return true;
113482: 
113482:     for (unsigned i = 0; i < pushedTypes->getObjectCount(); i++) {
113482:         if (pushedTypes->getTypeObject(i) != NULL)
113482:             return true;
113482:     }
113482: 
113482:     // Object's typeset should be a proper object
113482:     if (objTypes->baseFlags() || objTypes->unknownObject())
113482:         return true;
113482: 
113482:     unsigned int objCount = objTypes->getObjectCount();
113482:     if (objCount == 0)
113482:         return true;
113482: 
113482:     InlinePropertyTable *inlinePropTable = getPropCache->initInlinePropertyTable(pc);
113482:     if (!inlinePropTable)
113482:         return false;
113482: 
113482:     // Ensure that the relevant property typeset for each type object is
113482:     // is a single-object typeset containing a JSFunction
113482:     for (unsigned int i = 0; i < objCount; i++) {
113482:         types::TypeObject *typeObj = objTypes->getTypeObject(i);
113482:         if (!typeObj || typeObj->unknownProperties() || !typeObj->proto)
113482:             continue;
113482: 
113609:         types::HeapTypeSet *ownTypes = typeObj->getProperty(cx, id, false);
113482:         if (!ownTypes)
113482:             continue;
113482: 
113482:         if (ownTypes->isOwnProperty(cx, typeObj, false))
113482:             continue;
113482: 
113482:         bool knownConstant = false;
113482:         Rooted<JSObject*> proto(cx, typeObj->proto);
113482:         if (!TestSingletonProperty(cx, proto, id, &knownConstant))
113482:             return false;
113482: 
113654:         if (!knownConstant || proto->getType(cx)->unknownProperties())
113482:             continue;
113482: 
113654:         types::HeapTypeSet *protoTypes = proto->getType(cx)->getProperty(cx, id, false);
113482:         if (!protoTypes)
113482:             continue;
113482: 
113609:         JSObject *obj = protoTypes->getSingleton(cx);
113482:         if (!obj || !obj->isFunction())
113482:             continue;
113482: 
113482:         // Don't add cases corresponding to non-observed pushes
113482:         if (!pushedTypes->hasType(types::Type::ObjectType(obj)))
113482:             continue;
113482: 
113482:         if (!inlinePropTable->addEntry(typeObj, obj->toFunction()))
113482:             return false;
113482:     }
113482: 
113482:     if (inlinePropTable->numEntries() == 0) {
113482:         getPropCache->clearInlinePropertyTable();
113482:         return true;
113482:     }
113482: 
113482: #ifdef DEBUG
113482:     if (inlinePropTable->numEntries() > 0)
113482:         IonSpew(IonSpew_Inlining, "Annotated GetPropertyCache with %d/%d inline cases",
113482:                                     (int) inlinePropTable->numEntries(), (int) objCount);
113482: #endif
113482: 
113482:     // If we successfully annotated the GetPropertyCache and there are inline cases,
113482:     // then keep a resume point of the state right before this instruction for use
113482:     // later when we have to bail out to this point in the fallback case of a
113482:     // PolyInlineDispatch.
113482:     if (inlinePropTable->numEntries() > 0) {
113482:         // Push the object back onto the stack temporarily to capture the resume point.
113482:         current->push(obj);
113482:         MResumePoint *resumePoint = MResumePoint::New(current, pc, callerResumePoint_,
113482:                                                       MResumePoint::ResumeAt);
113482:         if (!resumePoint)
113482:             return false;
113482:         inlinePropTable->setPriorResumePoint(resumePoint);
113482:         current->pop();
113482:     }
113482:     return true;
113482: }
113482: 
113386: // Returns true if an idempotent cache has ever invalidated this script
113386: // or an outer script.
113386: bool
113386: IonBuilder::invalidatedIdempotentCache()
113386: {
113386:     IonBuilder *builder = this;
113386:     do {
115105:         if (builder->script()->invalidatedIdempotentCache)
113386:             return true;
113386:         builder = builder->callerBuilder_;
113386:     } while (builder);
113386: 
113386:     return false;
113386: }
113386: 
112696: bool
125828: IonBuilder::loadSlot(MDefinition *obj, HandleShape shape, MIRType rvalType)
113436: {
113436:     JS_ASSERT(shape->hasDefaultGetter());
113436:     JS_ASSERT(shape->hasSlot());
113436: 
125568:     RootedScript scriptRoot(cx, script());
125568:     types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
113436: 
113436:     if (shape->slot() < shape->numFixedSlots()) {
113436:         MLoadFixedSlot *load = MLoadFixedSlot::New(obj, shape->slot());
113436:         current->add(load);
113436:         current->push(load);
113436: 
113436:         load->setResultType(rvalType);
113436:         return pushTypeBarrier(load, types, barrier);
113436:     }
113436: 
113436:     MSlots *slots = MSlots::New(obj);
113436:     current->add(slots);
113436: 
113436:     MLoadSlot *load = MLoadSlot::New(slots, shape->slot() - shape->numFixedSlots());
113436:     current->add(load);
113436:     current->push(load);
113436: 
113436:     load->setResultType(rvalType);
113436:     return pushTypeBarrier(load, types, barrier);
113436: }
113436: 
113436: bool
125828: IonBuilder::storeSlot(MDefinition *obj, UnrootedShape shape, MDefinition *value, bool needsBarrier)
113436: {
113436:     JS_ASSERT(shape->hasDefaultSetter());
113436:     JS_ASSERT(shape->writable());
113436:     JS_ASSERT(shape->hasSlot());
113436: 
113436:     if (shape->slot() < shape->numFixedSlots()) {
113436:         MStoreFixedSlot *store = MStoreFixedSlot::New(obj, shape->slot(), value);
113436:         current->add(store);
113436:         current->push(value);
113436:         if (needsBarrier)
113436:             store->setNeedsBarrier();
113436:         return resumeAfter(store);
113436:     }
113436: 
113436:     MSlots *slots = MSlots::New(obj);
113436:     current->add(slots);
113436: 
113436:     MStoreSlot *store = MStoreSlot::New(slots, shape->slot() - shape->numFixedSlots(), value);
113436:     current->add(store);
113436:     current->push(value);
113436:     if (needsBarrier)
113436:         store->setNeedsBarrier();
113436:     return resumeAfter(store);
113436: }
113436: 
113436: bool
113095: IonBuilder::jsop_getprop(HandlePropertyName name)
112289: {
119120:     RootedId id(cx, NameToId(name));
119120: 
125568:     RootedScript scriptRoot(cx, script());
125568:     types::StackTypeSet *barrier = oracle->propertyReadBarrier(scriptRoot, pc);
125568:     types::StackTypeSet *types = oracle->propertyRead(script(), pc);
125568:     TypeOracle::Unary unary = oracle->unaryOp(script(), pc);
125568:     TypeOracle::UnaryTypes uTypes = oracle->unaryTypes(script(), pc);
119120: 
119120:     bool emitted = false;
119120: 
119120:     // Try to optimize arguments.length.
119120:     if (!getPropTryArgumentsLength(&emitted) || emitted)
119120:         return emitted;
119120: 
119120:     // Try to hardcode known constants.
119120:     if (!getPropTryConstant(&emitted, id, barrier, types, uTypes) || emitted)
119120:         return emitted;
119120: 
119120:     // Try to emit loads from definite slots.
119120:     if (!getPropTryDefiniteSlot(&emitted, name, barrier, types, unary, uTypes) || emitted)
119120:         return emitted;
119120: 
119120:     // Try to inline a common property getter, or make a call.
119120:     if (!getPropTryCommonGetter(&emitted, id, barrier, types, uTypes) || emitted)
119120:         return emitted;
119120: 
119120:     // Try to emit a monomorphic cache based on data in JM caches.
119120:     if (!getPropTryMonomorphic(&emitted, id, barrier, unary, uTypes) || emitted)
119120:         return emitted;
119120: 
119120:     // Try to emit a polymorphic cache.
119120:     if (!getPropTryPolymorphic(&emitted, name, id, barrier, types, unary, uTypes) || emitted)
119120:         return emitted;
119120: 
119120:     // Emit a call.
119120:     MDefinition *obj = current->pop();
119120:     MCallGetProperty *call = MCallGetProperty::New(obj, name);
119120:     current->add(call);
119120:     current->push(call);
119120:     if (!resumeAfter(call))
119120:         return false;
119120: 
119120:     monitorResult(call, barrier, types);
119120:     return pushTypeBarrier(call, types, barrier);
119120: }
119120: 
119120: bool
119120: IonBuilder::getPropTryArgumentsLength(bool *emitted)
119120: {
119120:     JS_ASSERT(*emitted == false);
125568:     LazyArgumentsType isArguments = oracle->propertyReadMagicArguments(script(), pc);
119120: 
119114:     if (isArguments == MaybeArguments)
119114:         return abort("Type is not definitely lazy arguments.");
119120:     if (isArguments != DefinitelyArguments)
119120:         return true;
119120:     if (JSOp(*pc) != JSOP_LENGTH)
119120:         return true;
119120: 
119120:     *emitted = true;
119114:     return jsop_arguments_length();
119120: }
119120: 
119120: bool
119120: IonBuilder::getPropTryConstant(bool *emitted, HandleId id, types::StackTypeSet *barrier,
119120:                                types::StackTypeSet *types, TypeOracle::UnaryTypes unaryTypes)
119120: {
119120:     JS_ASSERT(*emitted == false);
119120:     JSObject *singleton = types ? types->getSingleton() : NULL;
119120:     if (!singleton || barrier)
119120:         return true;
119120: 
125568:     RootedObject global(cx, &script()->global());
119120: 
119481:     bool isConstant, testObject, testString;
119481:     if (!TestSingletonPropertyTypes(cx, unaryTypes.inTypes, global, id,
119481:                                     &isConstant, &testObject, &testString))
119120:         return false;
119120: 
119120:     if (!isConstant)
119120:         return true;
119114: 
119091:     MDefinition *obj = current->pop();
119120: 
119120:     // Property access is a known constant -- safe to emit.
119481:     JS_ASSERT(!testString || !testObject);
119120:     if (testObject)
119120:         current->add(MGuardObject::New(obj));
119481:     else if (testString)
119481:         current->add(MGuardString::New(obj));
125403:     else
125403:         obj->setFoldedUnchecked();
119120: 
113516:     MConstant *known = MConstant::New(ObjectValue(*singleton));
113516:     if (singleton->isFunction()) {
113516:         RootedFunction singletonFunc(cx, singleton->toFunction());
113516:         if (TestAreKnownDOMTypes(cx, unaryTypes.inTypes) &&
125845:             TestShouldDOMCall(cx, unaryTypes.inTypes, singletonFunc, JSJitInfo::Method))
113516:         {
113516:             FreezeDOMTypes(cx, unaryTypes.inTypes);
113516:             known->setDOMFunction();
113516:         }
113516:     }
119120: 
119120:     current->add(known);
119120:     current->push(known);
119120: 
119120:     *emitted = true;
113516:     return true;
112467: }
119120: 
119120: bool
119120: IonBuilder::getPropTryDefiniteSlot(bool *emitted, HandlePropertyName name,
119120:                                    types::StackTypeSet *barrier, types::StackTypeSet *types,
119120:                                    TypeOracle::Unary unary, TypeOracle::UnaryTypes unaryTypes)
119120: {
119120:     JS_ASSERT(*emitted == false);
119120:     types::TypeSet *propTypes = GetDefiniteSlot(cx, unaryTypes.inTypes, name);
119120:     if (!propTypes)
119120:         return true;
119120: 
119120:     MDefinition *obj = current->pop();
113146:     MDefinition *useObj = obj;
113146:     if (unaryTypes.inTypes && unaryTypes.inTypes->baseFlags()) {
113146:         MGuardObject *guard = MGuardObject::New(obj);
113146:         current->add(guard);
113146:         useObj = guard;
113146:     }
119120: 
113146:     MLoadFixedSlot *fixed = MLoadFixedSlot::New(useObj, propTypes->definiteSlot());
112467:     if (!barrier)
112467:         fixed->setResultType(unary.rval);
112467: 
112467:     current->add(fixed);
112467:     current->push(fixed);
112467: 
119120:     if (!pushTypeBarrier(fixed, types, barrier))
119120:         return false;
119120: 
119120:     *emitted = true;
119120:     return true;
119120: }
119120: 
119120: bool
119120: IonBuilder::getPropTryCommonGetter(bool *emitted, HandleId id, types::StackTypeSet *barrier,
119120:                                    types::StackTypeSet *types, TypeOracle::UnaryTypes unaryTypes)
119120: {
119120:     JS_ASSERT(*emitted == false);
113327:     JSFunction *commonGetter;
113515:     bool isDOM;
124266:     MDefinition *guard;
124266: 
124266:     if (!TestCommonPropFunc(cx, unaryTypes.inTypes, id, &commonGetter, true,
124266:                             &isDOM, &guard))
124266:     {
113327:         return false;
124266:     }
119120:     if (!commonGetter)
119120:         return true;
119120: 
119120:     MDefinition *obj = current->pop();
113515:     RootedFunction getter(cx, commonGetter);
119120: 
125845:     if (isDOM && TestShouldDOMCall(cx, unaryTypes.inTypes, getter, JSJitInfo::Getter)) {
113515:         const JSJitInfo *jitinfo = getter->jitInfo();
124266:         MGetDOMProperty *get = MGetDOMProperty::New(jitinfo, obj, guard);
113515:         current->add(get);
113515:         current->push(get);
113515: 
124266:         if (get->isEffectful() && !resumeAfter(get))
113515:             return false;
119120:         if (!pushTypeBarrier(get, types, barrier))
119120:             return false;
119120: 
119120:         *emitted = true;
119120:         return true;
119120:     }
119120: 
113327:     // Spoof stack to expected state for call.
113327:     pushConstant(ObjectValue(*commonGetter));
113327: 
113327:     MPassArg *wrapper = MPassArg::New(obj);
119120:     current->add(wrapper);
119114:     current->push(wrapper);
119120: 
119120:     if (!makeCallBarrier(getter, 0, false, types, barrier))
119120:         return false;
119120: 
119120:     *emitted = true;
119120:     return true;
119120: }
119120: 
119120: bool
119120: IonBuilder::getPropTryMonomorphic(bool *emitted, HandleId id, types::StackTypeSet *barrier,
119120:                                   TypeOracle::Unary unary, TypeOracle::UnaryTypes unaryTypes)
119120: {
125828:     AssertCanGC();
119120:     JS_ASSERT(*emitted == false);
125568:     bool accessGetter = oracle->propertyReadAccessGetter(script(), pc);
119120: 
119120:     if (unary.ival != MIRType_Object)
119120:         return true;
119120: 
125828:     RootedShape objShape(cx, mjit::GetPICSingleShape(cx, script(), pc, info().constructing()));
119120:     if (!objShape || objShape->inDictionary()) {
119120:         spew("GETPROP not monomorphic");
119120:         return true;
119120:     }
119120: 
119120:     MDefinition *obj = current->pop();
119120: 
119120:     // The JM IC was monomorphic, so we inline the property access as long as
119120:     // the shape is not in dictionary made. We cannot be sure that the shape is
119120:     // still a lastProperty, and calling Shape::search() on dictionary mode
119120:     // shapes that aren't lastProperty is invalid.
120777:     obj = addShapeGuard(obj, objShape, Bailout_CachedShapeGuard);
119120: 
119120:     spew("Inlining monomorphic GETPROP");
125828:     RootedShape shape(cx, objShape->search(cx, id));
119120:     JS_ASSERT(shape);
119120: 
116190:     MIRType rvalType = unary.rval;
116190:     if (barrier || IsNullOrUndefined(unary.rval) || accessGetter)
116190:         rvalType = MIRType_Value;
116190: 
119120:     if (!loadSlot(obj, shape, rvalType))
119120:         return false;
119120: 
119120:     *emitted = true;
119120:     return true;
119120: }
119120: 
119120: bool
119120: IonBuilder::getPropTryPolymorphic(bool *emitted, HandlePropertyName name, HandleId id,
119120:                                   types::StackTypeSet *barrier, types::StackTypeSet *types,
119120:                                   TypeOracle::Unary unary, TypeOracle::UnaryTypes unaryTypes)
119120: {
119120:     JS_ASSERT(*emitted == false);
125568:     bool accessGetter = oracle->propertyReadAccessGetter(script(), pc);
119120: 
119120:     // The input value must either be an object, or we should have strong suspicions
119120:     // that it can be safely unboxed to an object.
119120:     if (unary.ival != MIRType_Object && !unaryTypes.inTypes->objectOrSentinel())
119120:         return true;
119120: 
119120:     MIRType rvalType = unary.rval;
119120:     if (barrier || IsNullOrUndefined(unary.rval) || accessGetter)
119120:         rvalType = MIRType_Value;
119120: 
119120:     MDefinition *obj = current->pop();
113095:     MGetPropertyCache *load = MGetPropertyCache::New(obj, name);
113436:     load->setResultType(rvalType);
113386: 
113386:     // Try to mark the cache as idempotent. We only do this if JM is enabled
113386:     // (its ICs are used to mark property reads as likely non-idempotent) or
113386:     // if we are compiling eagerly (to improve test coverage).
119120:     if (unary.ival == MIRType_Object &&
119120:         (cx->methodJitEnabled || js_IonOptions.eagerCompilation) &&
113386:         !invalidatedIdempotentCache())
113386:     {
125568:         RootedScript scriptRoot(cx, script());
125568:         if (oracle->propertyReadIdempotent(scriptRoot, pc, id))
113386:             load->setIdempotent();
113386:     }
113386: 
113482:     if (JSOp(*pc) == JSOP_CALLPROP) {
113482:         if (!annotateGetPropertyCache(cx, obj, load, unaryTypes.inTypes, types))
113482:             return false;
113482:     }
116062: 
119120:     // If the cache is known to access getters, then enable generation of getter stubs.
116190:     if (accessGetter)
116062:         load->setAllowGetters();
116190: 
119120:     current->add(load);
119120:     current->push(load);
119120: 
119120:     if (load->isEffectful() && !resumeAfter(load))
119120:         return false;
119120: 
119114:     if (accessGetter)
119120:         monitorResult(load, barrier, types);
119120: 
119120:     if (!pushTypeBarrier(load, types, barrier))
119091:         return false;
119091: 
119120:     *emitted = true;
119120:     return true;
112289: }
112372: 
112372: bool
113095: IonBuilder::jsop_setprop(HandlePropertyName name)
112445: {
112445:     MDefinition *value = current->pop();
112445:     MDefinition *obj = current->pop();
112445: 
125568:     bool monitored = !oracle->propertyWriteCanSpecialize(script(), pc);
125568: 
125568:     TypeOracle::BinaryTypes binaryTypes = oracle->binaryTypes(script(), pc);
112467: 
112467:     if (!monitored) {
113609:         if (types::HeapTypeSet *propTypes = GetDefiniteSlot(cx, binaryTypes.lhsTypes, name)) {
113175:             MStoreFixedSlot *fixed = MStoreFixedSlot::New(obj, propTypes->definiteSlot(), value);
112467:             current->add(fixed);
112467:             current->push(value);
113147:             if (propTypes->needsBarrier(cx))
112726:                 fixed->setNeedsBarrier();
112467:             return resumeAfter(fixed);
112467:         }
112467:     }
112467: 
113327:     RootedId id(cx, NameToId(name));
113609:     types::StackTypeSet *types = binaryTypes.lhsTypes;
113327: 
113327:     JSFunction *commonSetter;
113515:     bool isDOM;
124266:     if (!TestCommonPropFunc(cx, types, id, &commonSetter, false, &isDOM, NULL))
113327:         return false;
113327:     if (!monitored && commonSetter) {
113515:         RootedFunction setter(cx, commonSetter);
125845:         if (isDOM && TestShouldDOMCall(cx, types, setter, JSJitInfo::Setter)) {
113515:             MSetDOMProperty *set = MSetDOMProperty::New(setter->jitInfo()->op, obj, value);
113515:             if (!set)
113515:                 return false;
113515: 
113515:             current->add(set);
113515:             current->push(value);
113515: 
113515:             return resumeAfter(set);
113515:         }
113515: 
113327:         // Dummy up the stack, as in getprop
113515:         pushConstant(ObjectValue(*setter));
113327: 
113327:         MPassArg *wrapper = MPassArg::New(obj);
113327:         current->push(wrapper);
113327:         current->add(wrapper);
113327: 
113327:         MPassArg *arg = MPassArg::New(value);
113327:         current->push(arg);
113327:         current->add(arg);
113327: 
113849:         // Call the setter. Note that we have to push the original value, not
113849:         // the setter's return value.
113849:         MCall *call = makeCallHelper(setter, 1, false);
113849:         if (!call)
113849:             return false;
113849: 
113849:         current->push(value);
113849:         return resumeAfter(call);
113327:     }
113327: 
125568:     oracle->binaryOp(script(), pc);
112675: 
112675:     MSetPropertyInstruction *ins;
112726:     if (monitored) {
125664:         ins = MCallSetProperty::New(obj, value, name, script()->strict);
112726:     } else {
125828:         UnrootedShape objShape;
125568:         if ((objShape = mjit::GetPICSingleShape(cx, script(), pc, info().constructing())) &&
113550:             !objShape->inDictionary())
113550:         {
113550:             // The JM IC was monomorphic, so we inline the property access as
113550:             // long as the shape is not in dictionary mode. We cannot be sure
113550:             // that the shape is still a lastProperty, and calling Shape::search
113550:             // on dictionary mode shapes that aren't lastProperty is invalid.
120777:             obj = addShapeGuard(obj, objShape, Bailout_CachedShapeGuard);
113436: 
125828:             UnrootedShape shape = DropUnrooted(objShape)->search(cx, NameToId(name));
113436:             JS_ASSERT(shape);
113436: 
113436:             spew("Inlining monomorphic SETPROP");
113436: 
113436:             jsid typeId = types::MakeTypeId(cx, id);
125568:             bool needsBarrier = oracle->propertyWriteNeedsBarrier(script(), pc, typeId);
113436: 
125828:             return storeSlot(obj, DropUnrooted(shape), value, needsBarrier);
113436:         }
113436: 
113436:         spew("SETPROP not monomorphic");
113436: 
125664:         ins = MSetPropertyCache::New(obj, value, name, script()->strict);
113095: 
113147:         if (!binaryTypes.lhsTypes || binaryTypes.lhsTypes->propertyNeedsBarrier(cx, id))
112726:             ins->setNeedsBarrier();
112726:     }
112726: 
112445:     current->add(ins);
112445:     current->push(value);
112445: 
112445:     return resumeAfter(ins);
112445: }
112445: 
112445: bool
114101: IonBuilder::jsop_delprop(HandlePropertyName name)
112834: {
112834:     MDefinition *obj = current->pop();
112834: 
114101:     MInstruction *ins = MDeleteProperty::New(obj, name);
112834: 
112834:     current->add(ins);
112834:     current->push(ins);
112834: 
112834:     return resumeAfter(ins);
112834: }
112834: 
112834: bool
112541: IonBuilder::jsop_regexp(RegExpObject *reobj)
112541: {
125568:     JSObject *prototype = script()->global().getOrCreateRegExpPrototype(cx);
113485:     if (!prototype)
113485:         return false;
113485: 
113485:     MRegExp *ins = MRegExp::New(reobj, prototype, MRegExp::MustClone);
112541:     current->add(ins);
112541:     current->push(ins);
112541: 
112541:     return true;
112541: }
112541: 
112541: bool
112543: IonBuilder::jsop_object(JSObject *obj)
112543: {
112543:     MConstant *ins = MConstant::New(ObjectValue(*obj));
112543:     current->add(ins);
112543:     current->push(ins);
112543: 
112543:     return true;
112543: }
112543: 
112543: bool
112691: IonBuilder::jsop_lambda(JSFunction *fun)
112691: {
125568:     JS_ASSERT(script()->analysis()->usesScopeChain());
113175:     MLambda *ins = MLambda::New(current->scopeChain(), fun);
112691:     current->add(ins);
112691:     current->push(ins);
112691: 
112691:     return resumeAfter(ins);
112691: }
112691: 
112691: bool
124795: IonBuilder::jsop_defvar(uint32_t index)
112716: {
112716:     JS_ASSERT(JSOp(*pc) == JSOP_DEFVAR || JSOp(*pc) == JSOP_DEFCONST);
112716: 
125568:     PropertyName *name = script()->getName(index);
112716: 
112716:     // Bake in attrs.
113124:     unsigned attrs = JSPROP_ENUMERATE | JSPROP_PERMANENT;
112716:     if (JSOp(*pc) == JSOP_DEFCONST)
112716:         attrs |= JSPROP_READONLY;
112716: 
112716:     // Pass the ScopeChain.
125568:     JS_ASSERT(script()->analysis()->usesScopeChain());
112716: 
112716:     // Bake the name pointer into the MDefVar.
113175:     MDefVar *defvar = MDefVar::New(name, attrs, current->scopeChain());
112716:     current->add(defvar);
112716: 
112716:     return resumeAfter(defvar);
112716: }
112716: 
112716: bool
112372: IonBuilder::jsop_this()
112372: {
112372:     if (!info().fun())
112372:         return abort("JSOP_THIS outside of a JSFunction.");
112772: 
125664:     if (script()->strict) {
112772:         current->pushSlot(info().thisSlot());
112772:         return true;
112772:     }
112511: 
125568:     types::StackTypeSet *types = oracle->thisTypeSet(script());
113609:     if (types && types->getKnownTypeTag() == JSVAL_TYPE_OBJECT) {
112511:         // This is safe, because if the entry type of |this| is an object, it
112511:         // will necessarily be an object throughout the entire function. OSR
112511:         // can introduce a phi, but this phi will be specialized.
112372:         current->pushSlot(info().thisSlot());
112372:         return true;
112372:     }
112511: 
112511:     return abort("JSOP_THIS hard case not yet handled");
112511: }
112511: 
112663: bool
112684: IonBuilder::jsop_typeof()
112684: {
125568:     TypeOracle::Unary unary = oracle->unaryOp(script(), pc);
112684: 
112684:     MDefinition *input = current->pop();
112684:     MTypeOf *ins = MTypeOf::New(input, unary.ival);
112684: 
112684:     current->add(ins);
112684:     current->push(ins);
112684: 
112684:     if (ins->isEffectful() && !resumeAfter(ins))
112684:         return false;
112684:     return true;
112684: }
112684: 
112684: bool
112705: IonBuilder::jsop_toid()
112705: {
112705:     // No-op if the index is an integer.
125568:     TypeOracle::Unary unary = oracle->unaryOp(script(), pc);
112705:     if (unary.ival == MIRType_Int32)
112705:         return true;
112705: 
112705:     MDefinition *index = current->pop();
112705:     MToId *ins = MToId::New(current->peek(-1), index);
112705: 
112705:     current->add(ins);
112705:     current->push(ins);
112705: 
112705:     return resumeAfter(ins);
112705: }
112705: 
112705: bool
124795: IonBuilder::jsop_iter(uint8_t flags)
112663: {
112663:     MDefinition *obj = current->pop();
112663:     MInstruction *ins = MIteratorStart::New(obj, flags);
112663: 
113129:     if (!iterators_.append(ins))
113129:         return false;
113129: 
112663:     current->add(ins);
112663:     current->push(ins);
112663: 
112663:     return resumeAfter(ins);
112663: }
112663: 
112663: bool
113496: IonBuilder::jsop_iternext()
113496: {
113496:     MDefinition *iter = current->peek(-1);
112663:     MInstruction *ins = MIteratorNext::New(iter);
112663: 
112663:     current->add(ins);
112663:     current->push(ins);
112663: 
112663:     return resumeAfter(ins);
112663: }
112663: 
112663: bool
112663: IonBuilder::jsop_itermore()
112663: {
112663:     MDefinition *iter = current->peek(-1);
112663:     MInstruction *ins = MIteratorMore::New(iter);
112663: 
112663:     current->add(ins);
112663:     current->push(ins);
112663: 
112663:     return resumeAfter(ins);
112663: }
112663: 
112663: bool
112663: IonBuilder::jsop_iterend()
112663: {
112663:     MDefinition *iter = current->pop();
112663:     MInstruction *ins = MIteratorEnd::New(iter);
112663: 
112663:     current->add(ins);
112663: 
112663:     return resumeAfter(ins);
112663: }
113170: 
113176: MDefinition *
113176: IonBuilder::walkScopeChain(unsigned hops)
113176: {
113176:     MDefinition *scope = current->getSlot(info().scopeChainSlot());
113176: 
113176:     for (unsigned i = 0; i < hops; i++) {
113176:         MInstruction *ins = MEnclosingScope::New(scope);
113176:         current->add(ins);
113176:         scope = ins;
113176:     }
113176: 
113176:     return scope;
113176: }
113176: 
113176: bool
113176: IonBuilder::jsop_getaliasedvar(ScopeCoordinate sc)
113176: {
113609:     types::StackTypeSet *barrier;
125568:     types::StackTypeSet *actual = oracle->aliasedVarBarrier(script(), pc, &barrier);
113176: 
113176:     MDefinition *obj = walkScopeChain(sc.hops);
113415: 
125568:     RootedShape shape(cx, ScopeCoordinateToStaticScope(script(), pc).scopeShape());
113176: 
113176:     MInstruction *load;
113415:     if (shape->numFixedSlots() <= sc.slot) {
113176:         MInstruction *slots = MSlots::New(obj);
113176:         current->add(slots);
113176: 
113415:         load = MLoadSlot::New(slots, sc.slot - shape->numFixedSlots());
113176:     } else {
113415:         load = MLoadFixedSlot::New(obj, sc.slot);
113415:     }
113415: 
113415:     if (!barrier) {
113609:         JSValueType type = actual->getKnownTypeTag();
113415:         if (type != JSVAL_TYPE_UNKNOWN &&
113415:             type != JSVAL_TYPE_UNDEFINED &&
113415:             type != JSVAL_TYPE_NULL)
113415:         {
113415:             load->setResultType(MIRTypeFromValueType(type));
113415:         }
113415:     }
113415: 
113176:     current->add(load);
113176:     current->push(load);
113176: 
113415:     return pushTypeBarrier(load, actual, barrier);
113176: }
113176: 
113176: bool
113176: IonBuilder::jsop_setaliasedvar(ScopeCoordinate sc)
113176: {
113176:     MDefinition *rval = current->peek(-1);
113176:     MDefinition *obj = walkScopeChain(sc.hops);
113415: 
125568:     RootedShape shape(cx, ScopeCoordinateToStaticScope(script(), pc).scopeShape());
113176: 
113176:     MInstruction *store;
113415:     if (shape->numFixedSlots() <= sc.slot) {
113176:         MInstruction *slots = MSlots::New(obj);
113176:         current->add(slots);
113415: 
113415:         store = MStoreSlot::NewBarriered(slots, sc.slot - shape->numFixedSlots(), rval);
113176:     } else {
113415:         store = MStoreFixedSlot::NewBarriered(obj, sc.slot, rval);
113176:     }
113176: 
113176:     current->add(store);
113176:     return resumeAfter(store);
113176: }
113176: 
119236: bool
119236: IonBuilder::jsop_in()
119236: {
125883:     RootedScript scriptRoot(cx, script());
125883:     if (oracle->inObjectIsDenseArray(scriptRoot, pc))
122291:         return jsop_in_dense();
122291: 
119236:     MDefinition *obj = current->pop();
119236:     MDefinition *id = current->pop();
119236:     MIn *ins = new MIn(id, obj);
119236: 
119236:     current->add(ins);
119236:     current->push(ins);
119236: 
119236:     return resumeAfter(ins);
119236: }
113176: 
113170: bool
122291: IonBuilder::jsop_in_dense()
122291: {
122291:     if (oracle->arrayPrototypeHasIndexedProperty())
122291:         return abort("JSOP_IN Array proto has indexed properties");
122291: 
125568:     bool needsHoleCheck = !oracle->inArrayIsPacked(script(), pc);
122291: 
122291:     MDefinition *obj = current->pop();
122291:     MDefinition *id = current->pop();
122291: 
122291:     // Ensure id is an integer.
122291:     MInstruction *idInt32 = MToInt32::New(id);
122291:     current->add(idInt32);
122291:     id = idInt32;
122291: 
122291:     // Get the elements vector.
122291:     MElements *elements = MElements::New(obj);
122291:     current->add(elements);
122291: 
122291:     MInitializedLength *initLength = MInitializedLength::New(elements);
122291:     current->add(initLength);
122291: 
122291:     // Check if id < initLength and elem[id] not a hole.
122291:     MInArray *ins = MInArray::New(elements, id, initLength, needsHoleCheck);
122291: 
122291:     current->add(ins);
122291:     current->push(ins);
122291: 
122291:     return true;
122291: }
122291: 
122291: bool
113170: IonBuilder::jsop_instanceof()
113170: {
123958:     MDefinition *rhs = current->pop();
113170:     MDefinition *obj = current->pop();
123958: 
125568:     TypeOracle::BinaryTypes types = oracle->binaryTypes(script(), pc);
123958: 
123958:     // If this is an 'x instanceof function' operation and we can determine the
123958:     // exact function and prototype object being tested for, use a typed path.
123958:     do {
123958:         RawObject rhsObject = types.rhsTypes ? types.rhsTypes->getSingleton() : NULL;
123958:         if (!rhsObject || !rhsObject->isFunction() || rhsObject->isBoundFunction())
123958:             break;
123958: 
123958:         types::TypeObject *rhsType = rhsObject->getType(cx);
123958:         if (!rhsType || rhsType->unknownProperties())
123958:             break;
123958: 
123958:         types::HeapTypeSet *protoTypes =
123958:             rhsType->getProperty(cx, NameToId(cx->names().classPrototype), false);
123958:         RawObject protoObject = protoTypes ? protoTypes->getSingleton(cx) : NULL;
123958:         if (!protoObject)
123958:             break;
123958: 
124034:         MInstanceOf *ins = new MInstanceOf(obj, protoObject);
123958: 
123958:         current->add(ins);
123958:         current->push(ins);
123958: 
123958:         return resumeAfter(ins);
123958:     } while (false);
123958: 
124034:     MCallInstanceOf *ins = new MCallInstanceOf(obj, rhs);
113170: 
113170:     current->add(ins);
113170:     current->push(ins);
113170: 
113170:     return resumeAfter(ins);
113170: }
113170: 
113380: MInstruction *
113380: IonBuilder::addBoundsCheck(MDefinition *index, MDefinition *length)
113380: {
113380:     MInstruction *check = MBoundsCheck::New(index, length);
113380:     current->add(check);
113380: 
113383:     // If a bounds check failed in the past, don't optimize bounds checks.
113383:     if (failedBoundsCheck_)
113383:         check->setNotMovable();
113383: 
113380:     return check;
113380: }
120777: 
120777: MInstruction *
125828: IonBuilder::addShapeGuard(MDefinition *obj, const UnrootedShape shape, BailoutKind bailoutKind)
120777: {
120777:     MGuardShape *guard = MGuardShape::New(obj, shape, bailoutKind);
120777:     current->add(guard);
120777: 
120777:     // If a shape guard failed in the past, don't optimize shape guard.
120777:     if (failedShapeGuard_)
120777:         guard->setNotMovable();
120777: 
120777:     return guard;
120777: }
124001: 
124001: const types::TypeSet *
124001: IonBuilder::cloneTypeSet(const types::TypeSet *types)
124001: {
124001:     if (!js_IonOptions.parallelCompilation)
124001:         return types;
124001: 
124001:     // Clone a type set so that it can be stored into the MIR and accessed
124001:     // during off thread compilation. This is necessary because main thread
124001:     // updates to type sets can race with reads in the compiler backend, and
124001:     // after bug 804676 this code can be removed.
124001:     return types->clone(GetIonContext()->temp->lifoAlloc());
124001: }
