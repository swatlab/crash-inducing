    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* vim:set ts=4 sw=4 sts=4 et cin: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Darin Fisher <darin@netscape.com> (original author)
    1:  *   Gagan Saksena <gagan@netscape.com>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Christopher Blizzard <blizzard@mozilla.org>
    1:  *   Adrian Havill <havill@redhat.com>
    1:  *   Gervase Markham <gerv@gerv.net>
    1:  *   Bradley Baetz <bbaetz@netscape.com>
    1:  *   Benjamin Smedberg <bsmedberg@covad.net>
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsHttp.h"
    1: #include "nsHttpHandler.h"
    1: #include "nsHttpChannel.h"
    1: #include "nsHttpConnection.h"
    1: #include "nsHttpResponseHead.h"
    1: #include "nsHttpTransaction.h"
    1: #include "nsHttpAuthCache.h"
    1: #include "nsStandardURL.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIURL.h"
    1: #include "nsIStandardURL.h"
    1: #include "nsICacheService.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsCategoryManagerUtils.h"
    1: #include "nsICacheService.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch2.h"
    1: #include "nsIPrefLocalizedString.h"
    1: #include "nsISocketProviderService.h"
    1: #include "nsISocketProvider.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsNetCID.h"
    1: #include "nsAutoLock.h"
    1: #include "prprf.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsQuickSort.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIOService.h"
    1: 
 3041: #include "nsIXULAppInfo.h"
 3041: 
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
    1: #include <sys/utsname.h>
    1: #endif
    1: 
    1: #if defined(XP_WIN)
    1: #include <windows.h>
    1: #endif
    1: 
 7245: #if defined(XP_MACOSX)
 7245: #include <Carbon/Carbon.h>
 7245: #endif
 7245: 
    1: #if defined(XP_OS2)
    1: #define INCL_DOSMISC
    1: #include <os2.h>
    1: #endif
    1: 
    1: #ifdef DEBUG
    1: // defined by the socket transport service while active
    1: extern PRThread *gSocketThread;
    1: #endif
    1: 
    1: static NS_DEFINE_CID(kIOServiceCID, NS_IOSERVICE_CID);
    1: static NS_DEFINE_CID(kStreamConverterServiceCID, NS_STREAMCONVERTERSERVICE_CID);
    1: static NS_DEFINE_CID(kCookieServiceCID, NS_COOKIESERVICE_CID);
    1: static NS_DEFINE_CID(kCacheServiceCID, NS_CACHESERVICE_CID);
    1: static NS_DEFINE_CID(kSocketProviderServiceCID, NS_SOCKETPROVIDERSERVICE_CID);
    1: 
    1: #define UA_PREF_PREFIX          "general.useragent."
    1: #define UA_APPNAME              "Mozilla"
    1: #define UA_APPVERSION           "5.0"
    1: #define UA_APPSECURITY_FALLBACK "N"
    1: 
    1: #define HTTP_PREF_PREFIX        "network.http."
    1: #define INTL_ACCEPT_LANGUAGES   "intl.accept_languages"
    1: #define INTL_ACCEPT_CHARSET     "intl.charset.default"
    1: #define NETWORK_ENABLEIDN       "network.enableIDN"
    1: #define BROWSER_PREF_PREFIX     "browser.cache."
    1: 
    1: #define UA_PREF(_pref) UA_PREF_PREFIX _pref
    1: #define HTTP_PREF(_pref) HTTP_PREF_PREFIX _pref
    1: #define BROWSER_PREF(_pref) BROWSER_PREF_PREFIX _pref
    1: 
34655: #define NS_HTTP_PROTOCOL_FLAGS (URI_STD | ALLOWS_PROXY | ALLOWS_PROXY_HTTP | URI_LOADABLE_BY_ANYONE)
34655: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: static nsresult
    1: NewURI(const nsACString &aSpec,
    1:        const char *aCharset,
    1:        nsIURI *aBaseURI,
    1:        PRInt32 aDefaultPort,
    1:        nsIURI **aURI)
    1: {
    1:     nsStandardURL *url = new nsStandardURL();
    1:     if (!url)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(url);
    1: 
    1:     nsresult rv = url->Init(nsIStandardURL::URLTYPE_AUTHORITY,
    1:                             aDefaultPort, aSpec, aCharset, aBaseURI);
    1:     if (NS_FAILED(rv)) {
    1:         NS_RELEASE(url);
    1:         return rv;
    1:     }
    1: 
    1:     *aURI = url; // no QI needed
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpHandler <public>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsHttpHandler *gHttpHandler = nsnull;
    1: 
    1: nsHttpHandler::nsHttpHandler()
17156:     : mConnMgr(nsnull)
17156:     , mHttpVersion(NS_HTTP_VERSION_1_1)
    1:     , mProxyHttpVersion(NS_HTTP_VERSION_1_1)
    1:     , mCapabilities(NS_HTTP_ALLOW_KEEPALIVE)
    1:     , mProxyCapabilities(NS_HTTP_ALLOW_KEEPALIVE)
    1:     , mReferrerLevel(0xff) // by default we always send a referrer
    1:     , mIdleTimeout(10)
    1:     , mMaxRequestAttempts(10)
    1:     , mMaxRequestDelay(10)
    1:     , mMaxConnections(24)
    1:     , mMaxConnectionsPerServer(8)
    1:     , mMaxPersistentConnectionsPerServer(2)
    1:     , mMaxPersistentConnectionsPerProxy(4)
    1:     , mMaxPipelinedRequests(2)
    1:     , mRedirectionLimit(10)
    1:     , mPhishyUserPassLength(1)
11296:     , mPipeliningOverSSL(PR_FALSE)
    1:     , mLastUniqueID(NowInSeconds())
    1:     , mSessionStartTime(0)
 3041:     , mProduct("Gecko")
    1:     , mUserAgentIsDirty(PR_TRUE)
    1:     , mUseCache(PR_TRUE)
25455:     , mPromptTempRedirect(PR_TRUE)
    1:     , mSendSecureXSiteReferrer(PR_TRUE)
    1:     , mEnablePersistentHttpsCaching(PR_FALSE)
    1: {
    1: #if defined(PR_LOGGING)
    1:     gHttpLog = PR_NewLogModule("nsHttp");
    1: #endif
    1: 
    1:     LOG(("Creating nsHttpHandler [this=%x].\n", this));
    1: 
    1:     NS_ASSERTION(!gHttpHandler, "HTTP handler already created!");
    1:     gHttpHandler = this;
    1: }
    1: 
    1: nsHttpHandler::~nsHttpHandler()
    1: {
    1:     // We do not deal with the timer cancellation in the destructor since
    1:     // it is taken care of in xpcom shutdown event in the Observe method.
    1: 
    1:     LOG(("Deleting nsHttpHandler [this=%x]\n", this));
    1: 
    1:     // make sure the connection manager is shutdown
    1:     if (mConnMgr) {
    1:         mConnMgr->Shutdown();
17156:         NS_RELEASE(mConnMgr);
    1:     }
    1: 
    1:     nsHttp::DestroyAtomTable();
    1: 
    1:     gHttpHandler = nsnull;
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::Init()
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("nsHttpHandler::Init\n"));
    1: 
    1:     rv = nsHttp::CreateAtomTable();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
29642:     mIOService = do_GetService(NS_IOSERVICE_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv)) {
    1:         NS_WARNING("unable to continue without io service");
    1:         return rv;
    1:     }
    1: 
    1:     InitUserAgentComponents();
    1: 
    1:     // monitor some preference changes
    1:     nsCOMPtr<nsIPrefBranch2> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:     if (prefBranch) {
    1:         prefBranch->AddObserver(HTTP_PREF_PREFIX, this, PR_TRUE);
    1:         prefBranch->AddObserver(UA_PREF_PREFIX, this, PR_TRUE);
    1:         prefBranch->AddObserver(INTL_ACCEPT_LANGUAGES, this, PR_TRUE); 
    1:         prefBranch->AddObserver(INTL_ACCEPT_CHARSET, this, PR_TRUE);
    1:         prefBranch->AddObserver(NETWORK_ENABLEIDN, this, PR_TRUE);
    1:         prefBranch->AddObserver(BROWSER_PREF("disk_cache_ssl"), this, PR_TRUE);
    1: 
    1:         PrefsChanged(prefBranch, nsnull);
    1:     }
    1: 
    1:     mMisc.AssignLiteral("rv:" MOZILLA_VERSION);
    1: 
    1: #if DEBUG
    1:     // dump user agent prefs
    1:     LOG(("> app-name = %s\n", mAppName.get()));
    1:     LOG(("> app-version = %s\n", mAppVersion.get()));
    1:     LOG(("> platform = %s\n", mPlatform.get()));
    1:     LOG(("> oscpu = %s\n", mOscpu.get()));
34166:     LOG(("> device = %s\n", mDeviceType.get()));
    1:     LOG(("> security = %s\n", mSecurity.get()));
    1:     LOG(("> language = %s\n", mLanguage.get()));
    1:     LOG(("> misc = %s\n", mMisc.get()));
    1:     LOG(("> vendor = %s\n", mVendor.get()));
    1:     LOG(("> vendor-sub = %s\n", mVendorSub.get()));
    1:     LOG(("> vendor-comment = %s\n", mVendorComment.get()));
    1:     LOG(("> extra = %s\n", mExtraUA.get()));
    1:     LOG(("> product = %s\n", mProduct.get()));
    1:     LOG(("> product-sub = %s\n", mProductSub.get()));
    1:     LOG(("> product-comment = %s\n", mProductComment.get()));
    1:     LOG(("> user-agent = %s\n", UserAgent().get()));
    1: #endif
    1: 
    1:     mSessionStartTime = NowInSeconds();
    1: 
    1:     rv = mAuthCache.Init();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = InitConnectionMgr();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
 3041:     nsCOMPtr<nsIXULAppInfo> appInfo =
 3041:         do_GetService("@mozilla.org/xre/app-info;1");
 3041:     if (appInfo)
 3041:         appInfo->GetPlatformBuildID(mProductSub);
19921:     if (mProductSub.Length() > 8)
19921:         mProductSub.SetLength(8);
 3041: 
    1:     // Startup the http category
    1:     // Bring alive the objects in the http-protocol-startup category
    1:     NS_CreateServicesFromCategory(NS_HTTP_STARTUP_CATEGORY,
 3233:                                   static_cast<nsISupports*>(static_cast<void*>(this)),
    1:                                   NS_HTTP_STARTUP_TOPIC);    
    1:     
    1:     mObserverService = do_GetService("@mozilla.org/observer-service;1");
    1:     if (mObserverService) {
    1:         mObserverService->AddObserver(this, "profile-change-net-teardown", PR_TRUE);
    1:         mObserverService->AddObserver(this, "profile-change-net-restore", PR_TRUE);
    1:         mObserverService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, PR_TRUE);
25401:         mObserverService->AddObserver(this, "net:clear-active-logins", PR_TRUE);
    1:     }
    1:  
    1:     StartPruneDeadConnectionsTimer();
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::InitConnectionMgr()
    1: {
17156:     nsresult rv;
17156: 
17139:     if (!mConnMgr) {
17156:         mConnMgr = new nsHttpConnectionMgr();
17156:         if (!mConnMgr)
17156:             return NS_ERROR_OUT_OF_MEMORY;
17156:         NS_ADDREF(mConnMgr);
17156:     }
    1: 
17156:     rv = mConnMgr->Init(mMaxConnections,
    1:                         mMaxConnectionsPerServer,
    1:                         mMaxConnectionsPerServer,
    1:                         mMaxPersistentConnectionsPerServer,
    1:                         mMaxPersistentConnectionsPerProxy,
    1:                         mMaxRequestDelay,
    1:                         mMaxPipelinedRequests);
17156:     return rv;
    1: }
    1: 
    1: void
    1: nsHttpHandler::StartPruneDeadConnectionsTimer()
    1: {
    1:     LOG(("nsHttpHandler::StartPruneDeadConnectionsTimer\n"));
    1: 
    1:     mTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     NS_ASSERTION(mTimer, "no timer");
    1:     // failure to create a timer is not a fatal error, but idle connections
    1:     // will not be cleaned up until we try to use them.
    1:     if (mTimer)
    1:         mTimer->Init(this, 15*1000, // every 15 seconds
    1:                      nsITimer::TYPE_REPEATING_SLACK);
    1: }
    1: 
    1: void
    1: nsHttpHandler::StopPruneDeadConnectionsTimer()
    1: {
    1:     LOG(("nsHttpHandler::StopPruneDeadConnectionsTimer\n"));
    1: 
    1:     if (mTimer) {
    1:         mTimer->Cancel();
    1:         mTimer = 0;
    1:     }
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::AddStandardRequestHeaders(nsHttpHeaderArray *request,
    1:                                          PRUint8 caps,
    1:                                          PRBool useProxy)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Add the "User-Agent" header
    1:     rv = request->SetHeader(nsHttp::User_Agent, UserAgent());
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // MIME based content negotiation lives!
    1:     // Add the "Accept" header
    1:     rv = request->SetHeader(nsHttp::Accept, mAccept);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Add the "Accept-Language" header
    1:     if (!mAcceptLanguages.IsEmpty()) {
    1:         // Add the "Accept-Language" header
    1:         rv = request->SetHeader(nsHttp::Accept_Language, mAcceptLanguages);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     // Add the "Accept-Encoding" header
    1:     rv = request->SetHeader(nsHttp::Accept_Encoding, mAcceptEncodings);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Add the "Accept-Charset" header
    1:     rv = request->SetHeader(nsHttp::Accept_Charset, mAcceptCharsets);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // RFC2616 section 19.6.2 states that the "Connection: keep-alive"
    1:     // and "Keep-alive" request headers should not be sent by HTTP/1.1
    1:     // user-agents.  Otherwise, problems with proxy servers (especially
    1:     // transparent proxies) can result.
    1:     //
    1:     // However, we need to send something so that we can use keepalive
    1:     // with HTTP/1.0 servers/proxies. We use "Proxy-Connection:" when 
    1:     // we're talking to an http proxy, and "Connection:" otherwise
    1:     
    1:     NS_NAMED_LITERAL_CSTRING(close, "close");
    1:     NS_NAMED_LITERAL_CSTRING(keepAlive, "keep-alive");
    1: 
    1:     const nsACString *connectionType = &close;
    1:     if (caps & NS_HTTP_ALLOW_KEEPALIVE) {
    1:         rv = request->SetHeader(nsHttp::Keep_Alive, nsPrintfCString("%u", mIdleTimeout));
    1:         if (NS_FAILED(rv)) return rv;
    1:         connectionType = &keepAlive;
    1:     } else if (useProxy) {
    1:         // Bug 92006
    1:         request->SetHeader(nsHttp::Connection, close);
    1:     }
    1: 
    1:     const nsHttpAtom &header = useProxy ? nsHttp::Proxy_Connection
    1:                                         : nsHttp::Connection;
    1:     return request->SetHeader(header, *connectionType);
    1: }
    1: 
    1: PRBool
    1: nsHttpHandler::IsAcceptableEncoding(const char *enc)
    1: {
    1:     if (!enc)
    1:         return PR_FALSE;
    1: 
    1:     // HTTP 1.1 allows servers to send x-gzip and x-compress instead
    1:     // of gzip and compress, for example.  So, we'll always strip off
    1:     // an "x-" prefix before matching the encoding to one we claim
    1:     // to accept.
    1:     if (!PL_strncasecmp(enc, "x-", 2))
    1:         enc += 2;
    1:     
    1:     return nsHttp::FindToken(mAcceptEncodings.get(), enc, HTTP_LWS ",") != nsnull;
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::GetCacheSession(nsCacheStoragePolicy storagePolicy,
    1:                                nsICacheSession **result)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Skip cache if disabled in preferences
    1:     if (!mUseCache)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
 6922:     // We want to get the pointer to the cache service each time we're called,
 6922:     // because it's possible for some add-ons (such as Google Gears) to swap
 6922:     // in new cache services on the fly, and we want to pick them up as
 6922:     // appropriate.
 6922:     nsCOMPtr<nsICacheService> serv = do_GetService(NS_CACHESERVICE_CONTRACTID,
 6922:                                                    &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
 6922:     const char *sessionName = "HTTP";
 6922:     switch (storagePolicy) {
 6922:     case nsICache::STORE_IN_MEMORY:
 6922:         sessionName = "HTTP-memory-only";
 6922:         break;
 6922:     case nsICache::STORE_OFFLINE:
 6922:         sessionName = "HTTP-offline";
 6922:         break;
 6922:     default:
 6922:         break;
 6922:     }
 6922: 
 6922:     nsCOMPtr<nsICacheSession> cacheSession;
 6922:     rv = serv->CreateSession(sessionName,
 6922:                              storagePolicy,
    1:                              nsICache::STREAM_BASED,
 6922:                              getter_AddRefs(cacheSession));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
 6922:     rv = cacheSession->SetDoomEntriesIfExpired(PR_FALSE);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
 6922:     NS_ADDREF(*result = cacheSession);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::GetStreamConverterService(nsIStreamConverterService **result)
    1: {
    1:     if (!mStreamConvSvc) {
    1:         nsresult rv;
29642:         mStreamConvSvc = do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID, &rv);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     *result = mStreamConvSvc;
    1:     NS_ADDREF(*result);
    1:     return NS_OK;
    1: }
    1: 
    1: nsICookieService *
    1: nsHttpHandler::GetCookieService()
    1: {
    1:     if (!mCookieService)
29642:         mCookieService = do_GetService(NS_COOKIESERVICE_CONTRACTID);
    1:     return mCookieService;
    1: }
    1: 
    1: nsresult 
    1: nsHttpHandler::GetIOService(nsIIOService** result)
    1: {
    1:     NS_ADDREF(*result = mIOService);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: void
    1: nsHttpHandler::NotifyObservers(nsIHttpChannel *chan, const char *event)
    1: {
    1:     LOG(("nsHttpHandler::NotifyObservers [chan=%x event=\"%s\"]\n", chan, event));
    1:     if (mObserverService)
    1:         mObserverService->NotifyObservers(chan, event, nsnull);
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::OnChannelRedirect(nsIChannel* oldChan, nsIChannel* newChan,
    1:                                  PRUint32 flags)
    1: {
    1:     // First, the global observer
    1:     NS_ASSERTION(gIOService, "Must have an IO service at this point");
    1:     nsresult rv = gIOService->OnChannelRedirect(oldChan, newChan, flags);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Now, the per-channel observers
    1:     nsCOMPtr<nsIChannelEventSink> sink;
    1:     NS_QueryNotificationCallbacks(oldChan, sink);
    1:     if (sink)
    1:         rv = sink->OnChannelRedirect(oldChan, newChan, flags);
    1: 
    1:     return rv;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpHandler <private>
    1: //-----------------------------------------------------------------------------
    1: 
    1: const nsAFlatCString &
    1: nsHttpHandler::UserAgent()
    1: {
    1:     if (mUserAgentOverride) {
    1:         LOG(("using general.useragent.override : %s\n", mUserAgentOverride.get()));
    1:         return mUserAgentOverride;
    1:     }
    1: 
    1:     if (mUserAgentIsDirty) {
    1:         BuildUserAgent();
    1:         mUserAgentIsDirty = PR_FALSE;
    1:     }
    1: 
    1:     return mUserAgent;
    1: }
    1: 
    1: void
    1: nsHttpHandler::BuildUserAgent()
    1: {
    1:     LOG(("nsHttpHandler::BuildUserAgent\n"));
    1: 
    1:     NS_ASSERTION(!mAppName.IsEmpty() &&
    1:                  !mAppVersion.IsEmpty() &&
    1:                  !mPlatform.IsEmpty() &&
    1:                  !mSecurity.IsEmpty() &&
    1:                  !mOscpu.IsEmpty(),
    1:                  "HTTP cannot send practical requests without this much");
    1: 
    1:     // preallocate to worst-case size, which should always be better
    1:     // than if we didn't preallocate at all.
    1:     mUserAgent.SetCapacity(mAppName.Length() + 
    1:                            mAppVersion.Length() + 
    1:                            mPlatform.Length() + 
    1:                            mSecurity.Length() +
    1:                            mOscpu.Length() +
34166:                            mDeviceType.Length() +
    1:                            mLanguage.Length() +
    1:                            mMisc.Length() +
    1:                            mProduct.Length() +
    1:                            mProductSub.Length() +
    1:                            mProductComment.Length() +
    1:                            mVendor.Length() +
    1:                            mVendorSub.Length() +
    1:                            mVendorComment.Length() +
    1:                            mExtraUA.Length() +
    1:                            22);
    1: 
    1:     // Application portion
    1:     mUserAgent.Assign(mAppName);
    1:     mUserAgent += '/';
    1:     mUserAgent += mAppVersion;
    1:     mUserAgent += ' ';
    1: 
    1:     // Application comment
    1:     mUserAgent += '(';
    1:     mUserAgent += mPlatform;
    1:     mUserAgent.AppendLiteral("; ");
    1:     mUserAgent += mSecurity;
    1:     mUserAgent.AppendLiteral("; ");
    1:     mUserAgent += mOscpu;
    1:     if (!mLanguage.IsEmpty()) {
    1:         mUserAgent.AppendLiteral("; ");
    1:         mUserAgent += mLanguage;
    1:     }
    1:     if (!mMisc.IsEmpty()) {
    1:         mUserAgent.AppendLiteral("; ");
    1:         mUserAgent += mMisc;
    1:     }
    1:     mUserAgent += ')';
    1: 
    1:     // Product portion
    1:     if (!mProduct.IsEmpty()) {
    1:         mUserAgent += ' ';
    1:         mUserAgent += mProduct;
    1:         if (!mProductSub.IsEmpty()) {
    1:             mUserAgent += '/';
    1:             mUserAgent += mProductSub;
    1:         }
    1:         if (!mProductComment.IsEmpty()) {
    1:             mUserAgent.AppendLiteral(" (");
    1:             mUserAgent += mProductComment;
    1:             mUserAgent += ')';
    1:         }
    1:     }
    1: 
    1:     // Vendor portion
    1:     if (!mVendor.IsEmpty()) {
    1:         mUserAgent += ' ';
    1:         mUserAgent += mVendor;
    1:         if (!mVendorSub.IsEmpty()) {
    1:             mUserAgent += '/';
    1:             mUserAgent += mVendorSub;
    1:         }
    1:         if (!mVendorComment.IsEmpty()) {
    1:             mUserAgent.AppendLiteral(" (");
    1:             mUserAgent += mVendorComment;
    1:             mUserAgent += ')';
    1:         }
    1:     }
    1: 
    1:     if (!mExtraUA.IsEmpty())
    1:         mUserAgent += mExtraUA;
    1: }
    1: 
    1: void
    1: nsHttpHandler::InitUserAgentComponents()
    1: {
    1: 
    1:       // Gather platform.
    1:     mPlatform.AssignLiteral(
    1: #if defined(MOZ_WIDGET_PHOTON)
    1:     "Photon"
    1: #elif defined(XP_OS2)
    1:     "OS/2"
    1: #elif defined(XP_WIN)
    1:     "Windows"
    1: #elif defined(XP_MACOSX)
    1:     "Macintosh"
    1: #elif defined(XP_BEOS)
    1:     "BeOS"
31686: #elif defined(MOZ_X11)
31686:     "X11"
31686: #else
    1:     "?"
    1: #endif
    1:     );
    1: 
    1:     // Gather OS/CPU.
    1: #if defined(XP_OS2)
    1:     ULONG os2ver = 0;
    1:     DosQuerySysInfo(QSV_VERSION_MINOR, QSV_VERSION_MINOR,
    1:                     &os2ver, sizeof(os2ver));
    1:     if (os2ver == 11)
    1:         mOscpu.AssignLiteral("2.11");
    1:     else if (os2ver == 30)
    1:         mOscpu.AssignLiteral("Warp 3");
    1:     else if (os2ver == 40)
    1:         mOscpu.AssignLiteral("Warp 4");
    1:     else if (os2ver == 45)
    1:         mOscpu.AssignLiteral("Warp 4.5");
    1: 
31686: #elif defined(WINCE) || defined(XP_WIN)
    1:     OSVERSIONINFO info = { sizeof(OSVERSIONINFO) };
    1:     if (GetVersionEx(&info)) {
31686:         char *buf = PR_smprintf(
31686: #if defined(WINCE)
31686:                                 "WindowsCE %ld.%ld",
31686: #else
31686:                                 "Windows NT %ld.%ld",
31686: #endif
    1:                                 info.dwMajorVersion,
    1:                                 info.dwMinorVersion);
    1:         if (buf) {
    1:             mOscpu = buf;
    1:             PR_smprintf_free(buf);
    1:         }
    1:     }
 7245: #elif defined (XP_MACOSX)
 7245: #if defined(__ppc__)
 8718:     mOscpu.AssignLiteral("PPC Mac OS X");
27620: #elif defined(__i386__) || defined(__x86_64__)
    1:     mOscpu.AssignLiteral("Intel Mac OS X");
 7245: #endif
27620:     SInt32 majorVersion, minorVersion;
 7245:     if ((::Gestalt(gestaltSystemVersionMajor, &majorVersion) == noErr) &&
 7245:         (::Gestalt(gestaltSystemVersionMinor, &minorVersion) == noErr)) {
27620:         mOscpu += nsPrintfCString(" %d.%d", majorVersion, minorVersion);
 7245:     }
    1: #elif defined (XP_UNIX) || defined (XP_BEOS)
    1:     struct utsname name;
    1:     
    1:     int ret = uname(&name);
    1:     if (ret >= 0) {
    1:         nsCAutoString buf;
    1:         buf =  (char*)name.sysname;
    1: 
    1:         if (strcmp(name.machine, "x86_64") == 0 &&
    1:             sizeof(void *) == sizeof(PRInt32)) {
    1:             // We're running 32-bit code on x86_64. Make this browser
    1:             // look like it's running on i686 hardware, but append "
    1:             // (x86_64)" to the end of the oscpu identifier to be able
    1:             // to differentiate this from someone running 64-bit code
    1:             // on x86_64..
    1: 
    1:             buf += " i686 (x86_64)";
    1:         } else {
    1:             buf += ' ';
    1: 
    1: #ifdef AIX
    1:             // AIX uname returns machine specific info in the uname.machine
    1:             // field and does not return the cpu type like other platforms.
    1:             // We use the AIX version and release numbers instead.
    1:             buf += (char*)name.version;
    1:             buf += '.';
    1:             buf += (char*)name.release;
    1: #else
    1:             buf += (char*)name.machine;
    1: #endif
    1:         }
    1: 
    1:         mOscpu.Assign(buf);
    1:     }
    1: #endif
    1: 
34166:     nsCOMPtr<nsIPropertyBag2> infoService = do_GetService("@mozilla.org/system-info;1");
34166:     NS_ASSERTION(infoService, "Could not find a system info service");
34166: 
34166:     nsCString deviceType;
34166:     nsresult rv = infoService->GetPropertyAsACString(NS_LITERAL_STRING("device"), deviceType);
34166:     if (NS_SUCCEEDED(rv))
34166:         mDeviceType = deviceType;
34166: 
    1:     mUserAgentIsDirty = PR_TRUE;
    1: }
    1: 
    1: static int StringCompare(const void* s1, const void* s2, void*)
    1: {
 3233:     return nsCRT::strcmp(*static_cast<const char *const *>(s1),
 3233:                          *static_cast<const char *const *>(s2));
    1: }
    1: 
    1: void
    1: nsHttpHandler::PrefsChanged(nsIPrefBranch *prefs, const char *pref)
    1: {
    1:     nsresult rv = NS_OK;
    1:     PRInt32 val;
    1: 
    1:     LOG(("nsHttpHandler::PrefsChanged [pref=%s]\n", pref));
    1: 
    1: #define PREF_CHANGED(p) ((pref == nsnull) || !PL_strcmp(pref, p))
    1: #define MULTI_PREF_CHANGED(p) \
    1:   ((pref == nsnull) || !PL_strncmp(pref, p, sizeof(p) - 1))
    1: 
    1:     //
    1:     // UA components
    1:     //
    1: 
    1:     // Gather application values.
    1:     if (PREF_CHANGED(UA_PREF("appName"))) {
    1:         prefs->GetCharPref(UA_PREF("appName"),
    1:             getter_Copies(mAppName));
    1:         if (mAppName.IsEmpty())
    1:             mAppName.AssignLiteral(UA_APPNAME);
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1:     if (PREF_CHANGED(UA_PREF("appVersion"))) {
    1:         prefs->GetCharPref(UA_PREF("appVersion"),
    1:             getter_Copies(mAppVersion));
    1:         if (mAppVersion.IsEmpty())
    1:             mAppVersion.AssignLiteral(UA_APPVERSION);
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1: 
    1:     // Gather vendor values.
    1:     if (PREF_CHANGED(UA_PREF("vendor"))) {
    1:         prefs->GetCharPref(UA_PREF("vendor"),
    1:             getter_Copies(mVendor));
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1:     if (PREF_CHANGED(UA_PREF("vendorSub"))) {
    1:         prefs->GetCharPref(UA_PREF("vendorSub"),
    1:             getter_Copies(mVendorSub));
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1:     if (PREF_CHANGED(UA_PREF("vendorComment"))) {
    1:         prefs->GetCharPref(UA_PREF("vendorComment"),
    1:             getter_Copies(mVendorComment));
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1: 
    1:     if (MULTI_PREF_CHANGED(UA_PREF("extra."))) {
    1:         mExtraUA.Truncate();
    1: 
    1:         // Unfortunately, we can't do this using the pref branch.
    1:         nsCOMPtr<nsIPrefService> service =
    1:             do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:         nsCOMPtr<nsIPrefBranch> branch;
    1:         service->GetBranch(UA_PREF("extra."), getter_AddRefs(branch));
    1:         if (branch) {
    1:             PRUint32 extraCount;
    1:             char **extraItems;
    1:             rv = branch->GetChildList("", &extraCount, &extraItems);
    1:             if (NS_SUCCEEDED(rv) && extraItems) {
    1:                 NS_QuickSort(extraItems, extraCount, sizeof(extraItems[0]),
    1:                              StringCompare, nsnull);
    1:                 for (char **item = extraItems,
    1:                       **item_end = extraItems + extraCount;
    1:                      item < item_end; ++item) {
    1:                     nsXPIDLCString valStr;
    1:                     branch->GetCharPref(*item, getter_Copies(valStr));
    1:                     if (!valStr.IsEmpty())
    1:                         mExtraUA += NS_LITERAL_CSTRING(" ") + valStr;
    1:                 }
    1:                 NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(extraCount, extraItems);
    1:             }
    1:         }
    1: 
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1: 
    1:     // Gather product values.
    1:     if (PREF_CHANGED(UA_PREF("productComment"))) {
    1:         prefs->GetCharPref(UA_PREF("productComment"),
    1:             getter_Copies(mProductComment));
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1: 
    1:     // Get Security level supported
    1:     if (PREF_CHANGED(UA_PREF("security"))) {
    1:         prefs->GetCharPref(UA_PREF("security"), getter_Copies(mSecurity));
    1:         if (!mSecurity)
    1:             mSecurity.AssignLiteral(UA_APPSECURITY_FALLBACK);
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1: 
    1:     // Gather locale.
    1:     if (PREF_CHANGED(UA_PREF("locale"))) {
    1:         nsCOMPtr<nsIPrefLocalizedString> pls;
    1:         prefs->GetComplexValue(UA_PREF("locale"),
    1:                                NS_GET_IID(nsIPrefLocalizedString),
    1:                                getter_AddRefs(pls));
    1:         if (pls) {
    1:             nsXPIDLString uval;
    1:             pls->ToString(getter_Copies(uval));
    1:             if (uval)
    1:                 CopyUTF16toUTF8(uval, mLanguage);
    1:         }
    1:         else {
    1:             nsXPIDLCString cval;
    1:             rv = prefs->GetCharPref(UA_PREF("locale"), getter_Copies(cval));
    1:             if (cval)
    1:                 mLanguage.Assign(cval);
    1:         }
    1: 
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1: 
    1:     // general.useragent.override
    1:     if (PREF_CHANGED(UA_PREF("override"))) {
    1:         prefs->GetCharPref(UA_PREF("override"),
    1:                             getter_Copies(mUserAgentOverride));
    1:         mUserAgentIsDirty = PR_TRUE;
    1:     }
    1: 
    1:     //
    1:     // HTTP options
    1:     //
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("keep-alive.timeout"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("keep-alive.timeout"), &val);
    1:         if (NS_SUCCEEDED(rv))
    1:             mIdleTimeout = (PRUint16) CLAMP(val, 1, 0xffff);
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("request.max-attempts"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("request.max-attempts"), &val);
    1:         if (NS_SUCCEEDED(rv))
    1:             mMaxRequestAttempts = (PRUint16) CLAMP(val, 1, 0xffff);
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("request.max-start-delay"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("request.max-start-delay"), &val);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             mMaxRequestDelay = (PRUint16) CLAMP(val, 0, 0xffff);
    1:             if (mConnMgr)
    1:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_REQUEST_DELAY,
    1:                                       mMaxRequestDelay);
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("max-connections"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("max-connections"), &val);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             mMaxConnections = (PRUint16) CLAMP(val, 1, 0xffff);
    1:             if (mConnMgr)
    1:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS,
    1:                                       mMaxConnections);
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("max-connections-per-server"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("max-connections-per-server"), &val);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             mMaxConnectionsPerServer = (PRUint8) CLAMP(val, 1, 0xff);
    1:             if (mConnMgr) {
    1:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS_PER_HOST,
    1:                                       mMaxConnectionsPerServer);
    1:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS_PER_PROXY,
    1:                                       mMaxConnectionsPerServer);
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("max-persistent-connections-per-server"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("max-persistent-connections-per-server"), &val);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             mMaxPersistentConnectionsPerServer = (PRUint8) CLAMP(val, 1, 0xff);
    1:             if (mConnMgr)
    1:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PERSISTENT_CONNECTIONS_PER_HOST,
    1:                                       mMaxPersistentConnectionsPerServer);
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("max-persistent-connections-per-proxy"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("max-persistent-connections-per-proxy"), &val);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             mMaxPersistentConnectionsPerProxy = (PRUint8) CLAMP(val, 1, 0xff);
    1:             if (mConnMgr)
    1:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PERSISTENT_CONNECTIONS_PER_PROXY,
    1:                                       mMaxPersistentConnectionsPerProxy);
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("sendRefererHeader"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("sendRefererHeader"), &val);
    1:         if (NS_SUCCEEDED(rv))
    1:             mReferrerLevel = (PRUint8) CLAMP(val, 0, 0xff);
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("redirection-limit"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("redirection-limit"), &val);
    1:         if (NS_SUCCEEDED(rv))
    1:             mRedirectionLimit = (PRUint8) CLAMP(val, 0, 0xff);
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("version"))) {
    1:         nsXPIDLCString httpVersion;
    1:         prefs->GetCharPref(HTTP_PREF("version"), getter_Copies(httpVersion));
    1:         if (httpVersion) {
    1:             if (!PL_strcmp(httpVersion, "1.1"))
    1:                 mHttpVersion = NS_HTTP_VERSION_1_1;
    1:             else if (!PL_strcmp(httpVersion, "0.9"))
    1:                 mHttpVersion = NS_HTTP_VERSION_0_9;
    1:             else
    1:                 mHttpVersion = NS_HTTP_VERSION_1_0;
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("proxy.version"))) {
    1:         nsXPIDLCString httpVersion;
    1:         prefs->GetCharPref(HTTP_PREF("proxy.version"), getter_Copies(httpVersion));
    1:         if (httpVersion) {
    1:             if (!PL_strcmp(httpVersion, "1.1"))
    1:                 mProxyHttpVersion = NS_HTTP_VERSION_1_1;
    1:             else
    1:                 mProxyHttpVersion = NS_HTTP_VERSION_1_0;
    1:             // it does not make sense to issue a HTTP/0.9 request to a proxy server
    1:         }
    1:     }
    1: 
    1:     PRBool cVar = PR_FALSE;
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("keep-alive"))) {
    1:         rv = prefs->GetBoolPref(HTTP_PREF("keep-alive"), &cVar);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             if (cVar)
    1:                 mCapabilities |= NS_HTTP_ALLOW_KEEPALIVE;
    1:             else
    1:                 mCapabilities &= ~NS_HTTP_ALLOW_KEEPALIVE;
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("proxy.keep-alive"))) {
    1:         rv = prefs->GetBoolPref(HTTP_PREF("proxy.keep-alive"), &cVar);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             if (cVar)
    1:                 mProxyCapabilities |= NS_HTTP_ALLOW_KEEPALIVE;
    1:             else
    1:                 mProxyCapabilities &= ~NS_HTTP_ALLOW_KEEPALIVE;
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("pipelining"))) {
    1:         rv = prefs->GetBoolPref(HTTP_PREF("pipelining"), &cVar);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             if (cVar)
    1:                 mCapabilities |=  NS_HTTP_ALLOW_PIPELINING;
    1:             else
    1:                 mCapabilities &= ~NS_HTTP_ALLOW_PIPELINING;
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("pipelining.maxrequests"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("pipelining.maxrequests"), &val);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             mMaxPipelinedRequests = CLAMP(val, 1, NS_HTTP_MAX_PIPELINED_REQUESTS);
    1:             if (mConnMgr)
    1:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PIPELINED_REQUESTS,
    1:                                       mMaxPipelinedRequests);
    1:         }
    1:     }
    1: 
11296:     if (PREF_CHANGED(HTTP_PREF("pipelining.ssl"))) {
11296:         rv = prefs->GetBoolPref(HTTP_PREF("pipelining.ssl"), &cVar);
11296:         if (NS_SUCCEEDED(rv))
11296:             mPipeliningOverSSL = cVar;
11296:     }
11296: 
    1:     if (PREF_CHANGED(HTTP_PREF("proxy.pipelining"))) {
    1:         rv = prefs->GetBoolPref(HTTP_PREF("proxy.pipelining"), &cVar);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             if (cVar)
    1:                 mProxyCapabilities |=  NS_HTTP_ALLOW_PIPELINING;
    1:             else
    1:                 mProxyCapabilities &= ~NS_HTTP_ALLOW_PIPELINING;
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("sendSecureXSiteReferrer"))) {
    1:         rv = prefs->GetBoolPref(HTTP_PREF("sendSecureXSiteReferrer"), &cVar);
    1:         if (NS_SUCCEEDED(rv))
    1:             mSendSecureXSiteReferrer = cVar;
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("accept.default"))) {
    1:         nsXPIDLCString accept;
    1:         rv = prefs->GetCharPref(HTTP_PREF("accept.default"),
    1:                                   getter_Copies(accept));
    1:         if (NS_SUCCEEDED(rv))
    1:             SetAccept(accept);
    1:     }
    1:     
    1:     if (PREF_CHANGED(HTTP_PREF("accept-encoding"))) {
    1:         nsXPIDLCString acceptEncodings;
    1:         rv = prefs->GetCharPref(HTTP_PREF("accept-encoding"),
    1:                                   getter_Copies(acceptEncodings));
    1:         if (NS_SUCCEEDED(rv))
    1:             SetAcceptEncodings(acceptEncodings);
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("use-cache"))) {
    1:         rv = prefs->GetBoolPref(HTTP_PREF("use-cache"), &cVar);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             mUseCache = cVar;
    1:         }
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("default-socket-type"))) {
    1:         nsXPIDLCString sval;
    1:         rv = prefs->GetCharPref(HTTP_PREF("default-socket-type"),
    1:                                 getter_Copies(sval));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             if (sval.IsEmpty())
    1:                 mDefaultSocketType.Adopt(0);
    1:             else {
    1:                 // verify that this socket type is actually valid
    1:                 nsCOMPtr<nsISocketProviderService> sps(
29642:                         do_GetService(NS_SOCKETPROVIDERSERVICE_CONTRACTID));
17022:                 if (sps) {
    1:                     nsCOMPtr<nsISocketProvider> sp;
    1:                     rv = sps->GetSocketProvider(sval, getter_AddRefs(sp));
    1:                     if (NS_SUCCEEDED(rv)) {
    1:                         // OK, this looks like a valid socket provider.
    1:                         mDefaultSocketType.Assign(sval);
    1:                     }
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
25455:     if (PREF_CHANGED(HTTP_PREF("prompt-temp-redirect"))) {
25455:         rv = prefs->GetBoolPref(HTTP_PREF("prompt-temp-redirect"), &cVar);
25455:         if (NS_SUCCEEDED(rv)) {
25455:             mPromptTempRedirect = cVar;
25455:         }
25455:     }
25455: 
    1:     // enable Persistent caching for HTTPS - bug#205921    
    1:     if (PREF_CHANGED(BROWSER_PREF("disk_cache_ssl"))) {
    1:         cVar = PR_FALSE;
    1:         rv = prefs->GetBoolPref(BROWSER_PREF("disk_cache_ssl"), &cVar);
    1:         if (NS_SUCCEEDED(rv))
    1:             mEnablePersistentHttpsCaching = cVar;
    1:     }
    1: 
    1:     if (PREF_CHANGED(HTTP_PREF("phishy-userpass-length"))) {
    1:         rv = prefs->GetIntPref(HTTP_PREF("phishy-userpass-length"), &val);
    1:         if (NS_SUCCEEDED(rv))
    1:             mPhishyUserPassLength = (PRUint8) CLAMP(val, 0, 0xff);
    1:     }
    1: 
    1:     //
    1:     // INTL options
    1:     //
    1: 
    1:     if (PREF_CHANGED(INTL_ACCEPT_LANGUAGES)) {
    1:         nsCOMPtr<nsIPrefLocalizedString> pls;
    1:         prefs->GetComplexValue(INTL_ACCEPT_LANGUAGES,
    1:                                 NS_GET_IID(nsIPrefLocalizedString),
    1:                                 getter_AddRefs(pls));
    1:         if (pls) {
    1:             nsXPIDLString uval;
    1:             pls->ToString(getter_Copies(uval));
    1:             if (uval)
    1:                 SetAcceptLanguages(NS_ConvertUTF16toUTF8(uval).get());
    1:         } 
    1:     }
    1: 
    1:     if (PREF_CHANGED(INTL_ACCEPT_CHARSET)) {
    1:         nsCOMPtr<nsIPrefLocalizedString> pls;
    1:         prefs->GetComplexValue(INTL_ACCEPT_CHARSET,
    1:                                 NS_GET_IID(nsIPrefLocalizedString),
    1:                                 getter_AddRefs(pls));
    1:         if (pls) {
    1:             nsXPIDLString uval;
    1:             pls->ToString(getter_Copies(uval));
    1:             if (uval)
    1:                 SetAcceptCharsets(NS_ConvertUTF16toUTF8(uval).get());
    1:         } 
    1:     }
    1: 
    1:     //
    1:     // IDN options
    1:     //
    1: 
    1:     if (PREF_CHANGED(NETWORK_ENABLEIDN)) {
    1:         PRBool enableIDN = PR_FALSE;
    1:         prefs->GetBoolPref(NETWORK_ENABLEIDN, &enableIDN);
    1:         // No locking is required here since this method runs in the main
    1:         // UI thread, and so do all the methods in nsHttpChannel.cpp
    1:         // (mIDNConverter is used by nsHttpChannel)
    1:         if (enableIDN && !mIDNConverter) {
17022:             mIDNConverter = do_GetService(NS_IDNSERVICE_CONTRACTID);
17022:             NS_ASSERTION(mIDNConverter, "idnSDK not installed");
    1:         }
    1:         else if (!enableIDN && mIDNConverter)
    1:             mIDNConverter = nsnull;
    1:     }
    1: 
    1: #undef PREF_CHANGED
    1: #undef MULTI_PREF_CHANGED
    1: }
    1: 
    1: /**
    1:  *  Allocates a C string into that contains a ISO 639 language list
    1:  *  notated with HTTP "q" values for output with a HTTP Accept-Language
    1:  *  header. Previous q values will be stripped because the order of
    1:  *  the langs imply the q value. The q values are calculated by dividing
    1:  *  1.0 amongst the number of languages present.
    1:  *
    1:  *  Ex: passing: "en, ja"
    1:  *      returns: "en,ja;q=0.5"
    1:  *
    1:  *      passing: "en, ja, fr_CA"
    1:  *      returns: "en,ja;q=0.7,fr_CA;q=0.3"
    1:  */
    1: static nsresult
    1: PrepareAcceptLanguages(const char *i_AcceptLanguages, nsACString &o_AcceptLanguages)
    1: {
    1:     if (!i_AcceptLanguages)
    1:         return NS_OK;
    1: 
    1:     PRUint32 n, size, wrote;
    1:     double q, dec;
    1:     char *p, *p2, *token, *q_Accept, *o_Accept;
    1:     const char *comma;
    1:     PRInt32 available;
    1: 
    1:     o_Accept = nsCRT::strdup(i_AcceptLanguages);
    1:     if (!o_Accept)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     for (p = o_Accept, n = size = 0; '\0' != *p; p++) {
    1:         if (*p == ',') n++;
    1:             size++;
    1:     }
    1: 
    1:     available = size + ++n * 11 + 1;
    1:     q_Accept = new char[available];
    1:     if (!q_Accept) {
    1:         nsCRT::free(o_Accept);
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     *q_Accept = '\0';
    1:     q = 1.0;
    1:     dec = q / (double) n;
    1:     n = 0;
    1:     p2 = q_Accept;
    1:     for (token = nsCRT::strtok(o_Accept, ",", &p);
    1:          token != (char *) 0;
    1:          token = nsCRT::strtok(p, ",", &p))
    1:     {
    1:         token = net_FindCharNotInSet(token, HTTP_LWS);
    1:         char* trim;
    1:         trim = net_FindCharInSet(token, ";" HTTP_LWS);
    1:         if (trim != (char*)0)  // remove "; q=..." if present
    1:             *trim = '\0';
    1: 
    1:         if (*token != '\0') {
    1:             comma = n++ != 0 ? "," : ""; // delimiter if not first item
    1:             PRUint32 u = QVAL_TO_UINT(q);
    1:             if (u < 10)
    1:                 wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
    1:             else
    1:                 wrote = PR_snprintf(p2, available, "%s%s", comma, token);
    1:             q -= dec;
    1:             p2 += wrote;
    1:             available -= wrote;
    1:             NS_ASSERTION(available > 0, "allocated string not long enough");
    1:         }
    1:     }
    1:     nsCRT::free(o_Accept);
    1: 
    1:     o_AcceptLanguages.Assign((const char *) q_Accept);
    1:     delete [] q_Accept;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::SetAcceptLanguages(const char *aAcceptLanguages) 
    1: {
    1:     nsCAutoString buf;
    1:     nsresult rv = PrepareAcceptLanguages(aAcceptLanguages, buf);
    1:     if (NS_SUCCEEDED(rv))
    1:         mAcceptLanguages.Assign(buf);
    1:     return rv;
    1: }
    1: 
    1: /**
    1:  *  Allocates a C string into that contains a character set/encoding list
    1:  *  notated with HTTP "q" values for output with a HTTP Accept-Charset
    1:  *  header. If the UTF-8 character set is not present, it will be added.
    1:  *  If a wildcard catch-all is not present, it will be added. If more than
    1:  *  one charset is set (as of 2001-02-07, only one is used), they will be
    1:  *  comma delimited and with q values set for each charset in decending order.
    1:  *
    1:  *  Ex: passing: "euc-jp"
    1:  *      returns: "euc-jp,utf-8;q=0.6,*;q=0.6"
    1:  *
    1:  *      passing: "UTF-8"
    1:  *      returns: "UTF-8, *"
    1:  */
    1: static nsresult
    1: PrepareAcceptCharsets(const char *i_AcceptCharset, nsACString &o_AcceptCharset)
    1: {
    1:     PRUint32 n, size, wrote, u;
    1:     PRInt32 available;
    1:     double q, dec;
    1:     char *p, *p2, *token, *q_Accept, *o_Accept;
    1:     const char *acceptable, *comma;
    1:     PRBool add_utf = PR_FALSE;
    1:     PRBool add_asterisk = PR_FALSE;
    1: 
    1:     if (!i_AcceptCharset)
    1:         acceptable = "";
    1:     else
    1:         acceptable = i_AcceptCharset;
    1:     o_Accept = nsCRT::strdup(acceptable);
    1:     if (nsnull == o_Accept)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     for (p = o_Accept, n = size = 0; '\0' != *p; p++) {
    1:         if (*p == ',') n++;
    1:             size++;
    1:     }
    1: 
    1:     // only add "utf-8" and "*" to the list if they aren't
    1:     // already specified.
    1: 
    1:     if (PL_strcasestr(acceptable, "utf-8") == NULL) {
    1:         n++;
    1:         add_utf = PR_TRUE;
    1:     }
33049:     if (PL_strchr(acceptable, '*') == NULL) {
    1:         n++;
    1:         add_asterisk = PR_TRUE;
    1:     }
    1: 
    1:     available = size + ++n * 11 + 1;
    1:     q_Accept = new char[available];
    1:     if ((char *) 0 == q_Accept)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     *q_Accept = '\0';
    1:     q = 1.0;
    1:     dec = q / (double) n;
    1:     n = 0;
    1:     p2 = q_Accept;
    1:     for (token = nsCRT::strtok(o_Accept, ",", &p);
    1:          token != (char *) 0;
    1:          token = nsCRT::strtok(p, ",", &p)) {
    1:         token = net_FindCharNotInSet(token, HTTP_LWS);
    1:         char* trim;
    1:         trim = net_FindCharInSet(token, ";" HTTP_LWS);
    1:         if (trim != (char*)0)  // remove "; q=..." if present
    1:             *trim = '\0';
    1: 
    1:         if (*token != '\0') {
    1:             comma = n++ != 0 ? "," : ""; // delimiter if not first item
    1:             u = QVAL_TO_UINT(q);
    1:             if (u < 10)
    1:                 wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
    1:             else
    1:                 wrote = PR_snprintf(p2, available, "%s%s", comma, token);
    1:             q -= dec;
    1:             p2 += wrote;
    1:             available -= wrote;
    1:             NS_ASSERTION(available > 0, "allocated string not long enough");
    1:         }
    1:     }
    1:     if (add_utf) {
    1:         comma = n++ != 0 ? "," : ""; // delimiter if not first item
    1:         u = QVAL_TO_UINT(q);
    1:         if (u < 10)
    1:             wrote = PR_snprintf(p2, available, "%sutf-8;q=0.%u", comma, u);
    1:         else
    1:             wrote = PR_snprintf(p2, available, "%sutf-8", comma);
    1:         q -= dec;
    1:         p2 += wrote;
    1:         available -= wrote;
    1:         NS_ASSERTION(available > 0, "allocated string not long enough");
    1:     }
    1:     if (add_asterisk) {
    1:         comma = n++ != 0 ? "," : ""; // delimiter if not first item
    1: 
    1:         // keep q of "*" equal to the lowest q value
    1:         // in the event of a tie between the q of "*" and a non-wildcard
    1:         // the non-wildcard always receives preference.
    1: 
    1:         q += dec;
    1:         u = QVAL_TO_UINT(q);
    1:         if (u < 10)
    1:             wrote = PR_snprintf(p2, available, "%s*;q=0.%u", comma, u);
    1:         else
    1:             wrote = PR_snprintf(p2, available, "%s*", comma);
    1:         available -= wrote;
    1:         p2 += wrote;
    1:         NS_ASSERTION(available > 0, "allocated string not long enough");
    1:     }
    1:     nsCRT::free(o_Accept);
    1: 
    1:     // change alloc from C++ new/delete to nsCRT::strdup's way
    1:     o_AcceptCharset.Assign(q_Accept);
    1: #if defined DEBUG_havill
    1:     printf("Accept-Charset: %s\n", q_Accept);
    1: #endif
    1:     delete [] q_Accept;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::SetAcceptCharsets(const char *aAcceptCharsets) 
    1: {
    1:     nsCString buf;
    1:     nsresult rv = PrepareAcceptCharsets(aAcceptCharsets, buf);
    1:     if (NS_SUCCEEDED(rv))
    1:         mAcceptCharsets.Assign(buf);
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::SetAccept(const char *aAccept) 
    1: {
    1:     mAccept = aAccept;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpHandler::SetAcceptEncodings(const char *aAcceptEncodings) 
    1: {
    1:     mAcceptEncodings = aAcceptEncodings;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpHandler::nsISupports
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS5(nsHttpHandler,
    1:                               nsIHttpProtocolHandler,
    1:                               nsIProxiedProtocolHandler,
    1:                               nsIProtocolHandler,
    1:                               nsIObserver,
    1:                               nsISupportsWeakReference)
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpHandler::nsIProtocolHandler
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetScheme(nsACString &aScheme)
    1: {
    1:     aScheme.AssignLiteral("http");
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetDefaultPort(PRInt32 *result)
    1: {
    1:     *result = NS_HTTP_DEFAULT_PORT;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetProtocolFlags(PRUint32 *result)
    1: {
34655:     *result = NS_HTTP_PROTOCOL_FLAGS;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::NewURI(const nsACString &aSpec,
    1:                       const char *aCharset,
    1:                       nsIURI *aBaseURI,
    1:                       nsIURI **aURI)
    1: {
    1:     LOG(("nsHttpHandler::NewURI\n"));
    1:     return ::NewURI(aSpec, aCharset, aBaseURI, NS_HTTP_DEFAULT_PORT, aURI);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::NewChannel(nsIURI *uri, nsIChannel **result)
    1: {
    1:     LOG(("nsHttpHandler::NewChannel\n"));
    1: 
    1:     NS_ENSURE_ARG_POINTER(uri);
    1:     NS_ENSURE_ARG_POINTER(result);
    1: 
    1:     PRBool isHttp = PR_FALSE, isHttps = PR_FALSE;
    1: 
    1:     // Verify that we have been given a valid scheme
    1:     nsresult rv = uri->SchemeIs("http", &isHttp);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (!isHttp) {
    1:         rv = uri->SchemeIs("https", &isHttps);
    1:         if (NS_FAILED(rv)) return rv;
    1:         if (!isHttps) {
    1:             NS_WARNING("Invalid URI scheme");
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1:     }
    1:     
    1:     return NewProxiedChannel(uri, nsnull, result);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHttpHandler::AllowPort(PRInt32 port, const char *scheme, PRBool *_retval)
    1: {
    1:     // don't override anything.  
    1:     *_retval = PR_FALSE;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpHandler::nsIProxiedProtocolHandler
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::NewProxiedChannel(nsIURI *uri,
    1:                                  nsIProxyInfo* givenProxyInfo,
    1:                                  nsIChannel **result)
    1: {
    1:     nsHttpChannel *httpChannel = nsnull;
    1: 
    1:     LOG(("nsHttpHandler::NewProxiedChannel [proxyInfo=%p]\n",
    1:         givenProxyInfo));
    1:     
    1:     nsCOMPtr<nsProxyInfo> proxyInfo;
    1:     if (givenProxyInfo) {
    1:         proxyInfo = do_QueryInterface(givenProxyInfo);
    1:         NS_ENSURE_ARG(proxyInfo);
    1:     }
    1: 
    1:     PRBool https;
    1:     nsresult rv = uri->SchemeIs("https", &https);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     NS_NEWXPCOM(httpChannel, nsHttpChannel);
    1:     if (!httpChannel)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(httpChannel);
    1: 
    1:     // select proxy caps if using a non-transparent proxy.  SSL tunneling
    1:     // should not use proxy settings.
    1:     PRInt8 caps;
    1:     if (proxyInfo && !nsCRT::strcmp(proxyInfo->Type(), "http") && !https)
    1:         caps = mProxyCapabilities;
    1:     else
    1:         caps = mCapabilities;
    1: 
    1:     if (https) {
11296:         // enable pipelining over SSL if requested
11296:         if (mPipeliningOverSSL)
11296:             caps |= NS_HTTP_ALLOW_PIPELINING;
11296: 
    1:         // HACK: make sure PSM gets initialized on the main thread.
    1:         nsCOMPtr<nsISocketProviderService> spserv =
29642:                 do_GetService(NS_SOCKETPROVIDERSERVICE_CONTRACTID);
    1:         if (spserv) {
    1:             nsCOMPtr<nsISocketProvider> provider;
    1:             spserv->GetSocketProvider("ssl", getter_AddRefs(provider));
    1:         }
    1:     }
    1: 
    1:     rv = httpChannel->Init(uri, caps, proxyInfo);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:         NS_RELEASE(httpChannel);
    1:         return rv;
    1:     }
    1: 
    1:     *result = httpChannel;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpHandler::nsIHttpProtocolHandler
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetUserAgent(nsACString &value)
    1: {
    1:     value = UserAgent();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetAppName(nsACString &value)
    1: {
    1:     value = mAppName;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetAppVersion(nsACString &value)
    1: {
    1:     value = mAppVersion;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetVendor(nsACString &value)
    1: {
    1:     value = mVendor;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpHandler::SetVendor(const nsACString &value)
    1: {
    1:     mVendor = value;
    1:     mUserAgentIsDirty = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetVendorSub(nsACString &value)
    1: {
    1:     value = mVendorSub;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpHandler::SetVendorSub(const nsACString &value)
    1: {
    1:     mVendorSub = value;
    1:     mUserAgentIsDirty = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetVendorComment(nsACString &value)
    1: {
    1:     value = mVendorComment;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpHandler::SetVendorComment(const nsACString &value)
    1: {
    1:     mVendorComment = value;
    1:     mUserAgentIsDirty = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetProduct(nsACString &value)
    1: {
    1:     value = mProduct;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpHandler::SetProduct(const nsACString &value)
    1: {
    1:     mProduct = value;
    1:     mUserAgentIsDirty = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetProductSub(nsACString &value)
    1: {
    1:     value = mProductSub;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpHandler::SetProductSub(const nsACString &value)
    1: {
    1:     mProductSub = value;
    1:     mUserAgentIsDirty = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetProductComment(nsACString &value)
    1: {
    1:     value = mProductComment;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpHandler::SetProductComment(const nsACString &value)
    1: {
    1:     mProductComment = value;
    1:     mUserAgentIsDirty = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetPlatform(nsACString &value)
    1: {
    1:     value = mPlatform;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetOscpu(nsACString &value)
    1: {
    1:     value = mOscpu;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
34166: nsHttpHandler::GetDeviceType(nsACString &value)
34166: {
34166:     value = mDeviceType;
34166:     return NS_OK;
34166: }
34166: 
34166: NS_IMETHODIMP
    1: nsHttpHandler::GetLanguage(nsACString &value)
    1: {
    1:     value = mLanguage;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpHandler::SetLanguage(const nsACString &value)
    1: {
    1:     mLanguage = value;
    1:     mUserAgentIsDirty = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::GetMisc(nsACString &value)
    1: {
    1:     value = mMisc;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpHandler::SetMisc(const nsACString &value)
    1: {
    1:     mMisc = value;
    1:     mUserAgentIsDirty = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpHandler::nsIObserver
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpHandler::Observe(nsISupports *subject,
    1:                        const char *topic,
    1:                        const PRUnichar *data)
    1: {
    1:     LOG(("nsHttpHandler::Observe [topic=\"%s\"]\n", topic));
    1: 
    1:     if (strcmp(topic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) == 0) {
    1:         nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(subject);
    1:         if (prefBranch)
    1:             PrefsChanged(prefBranch, NS_ConvertUTF16toUTF8(data).get());
    1:     }
    1:     else if (strcmp(topic, "profile-change-net-teardown")    == 0 ||
    1:              strcmp(topic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)    == 0) {
    1: 
17156:         // kill off the "prune dead connections" timer
17156:         StopPruneDeadConnectionsTimer();
17156: 
    1:         // clear cache of all authentication credentials.
    1:         mAuthCache.ClearAll();
    1: 
17156:         // ensure connection manager is shutdown
17156:         if (mConnMgr)
17156:             mConnMgr->Shutdown();
17156: 
    1:         // need to reset the session start time since cache validation may
    1:         // depend on this value.
    1:         mSessionStartTime = NowInSeconds();
    1:     }
17156:     else if (strcmp(topic, "profile-change-net-restore") == 0) {
    1:         // initialize connection manager
    1:         InitConnectionMgr();
    1: 
    1:         // restart the "prune dead connections" timer
    1:         StartPruneDeadConnectionsTimer();
    1:     }
    1:     else if (strcmp(topic, "timer-callback") == 0) {
    1:         // prune dead connections
    1: #ifdef DEBUG
    1:         nsCOMPtr<nsITimer> timer = do_QueryInterface(subject);
    1:         NS_ASSERTION(timer == mTimer, "unexpected timer-callback");
    1: #endif
    1:         if (mConnMgr)
    1:             mConnMgr->PruneDeadConnections();
    1:     }
25401:     else if (strcmp(topic, "net:clear-active-logins") == 0) {
25401:         mAuthCache.ClearAll();
25401:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpsHandler implementation
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS4(nsHttpsHandler,
    1:                               nsIHttpProtocolHandler,
    1:                               nsIProxiedProtocolHandler,
    1:                               nsIProtocolHandler,
    1:                               nsISupportsWeakReference)
    1: 
    1: nsresult
    1: nsHttpsHandler::Init()
    1: {
    1:     nsCOMPtr<nsIProtocolHandler> httpHandler(
    1:             do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http"));
    1:     NS_ASSERTION(httpHandler.get() != nsnull, "no http handler?");
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpsHandler::GetScheme(nsACString &aScheme)
    1: {
    1:     aScheme.AssignLiteral("https");
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpsHandler::GetDefaultPort(PRInt32 *aPort)
    1: {
    1:     *aPort = NS_HTTPS_DEFAULT_PORT;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpsHandler::GetProtocolFlags(PRUint32 *aProtocolFlags)
    1: {
34655:     *aProtocolFlags = NS_HTTP_PROTOCOL_FLAGS;
34655:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpsHandler::NewURI(const nsACString &aSpec,
    1:                        const char *aOriginCharset,
    1:                        nsIURI *aBaseURI,
    1:                        nsIURI **_retval)
    1: {
    1:     return ::NewURI(aSpec, aOriginCharset, aBaseURI, NS_HTTPS_DEFAULT_PORT, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpsHandler::NewChannel(nsIURI *aURI, nsIChannel **_retval)
    1: {
34655:     NS_ABORT_IF_FALSE(gHttpHandler, "Should have a HTTP handler by now.");
34655:     if (!gHttpHandler)
34655:       return NS_ERROR_UNEXPECTED;
    1:     return gHttpHandler->NewChannel(aURI, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpsHandler::AllowPort(PRInt32 aPort, const char *aScheme, PRBool *_retval)
    1: {
    1:     // don't override anything.  
    1:     *_retval = PR_FALSE;
    1:     return NS_OK;
    1: }
