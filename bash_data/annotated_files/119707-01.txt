  3942: /* -*- mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  3942: 
  3942: #include "nsOfflineCacheUpdate.h"
  3942: 
  3942: #include "nsCPrefetchService.h"
  3942: #include "nsCURILoader.h"
 21312: #include "nsIApplicationCacheContainer.h"
 21311: #include "nsIApplicationCacheChannel.h"
 18430: #include "nsIApplicationCacheService.h"
  3942: #include "nsICache.h"
  3942: #include "nsICacheService.h"
  3942: #include "nsICacheSession.h"
  3942: #include "nsICachingChannel.h"
 21367: #include "nsIContent.h"
 41930: #include "mozilla/dom/Element.h"
 18488: #include "nsIDocumentLoader.h"
 21367: #include "nsIDOMElement.h"
  3942: #include "nsIDOMWindow.h"
 10340: #include "nsIDOMOfflineResourceList.h"
 21367: #include "nsIDocument.h"
  3942: #include "nsIObserverService.h"
 18430: #include "nsIURL.h"
  3942: #include "nsIWebProgress.h"
 10900: #include "nsICryptoHash.h"
 10900: #include "nsICacheEntryDescriptor.h"
 20651: #include "nsIPermissionManager.h"
 20651: #include "nsIPrincipal.h"
  3942: #include "nsNetCID.h"
  3942: #include "nsNetUtil.h"
  3942: #include "nsServiceManagerUtils.h"
  3942: #include "nsStreamUtils.h"
  3947: #include "nsThreadUtils.h"
 24397: #include "nsProxyRelease.h"
  3942: #include "prlog.h"
 48889: #include "nsIAsyncVerifyRedirectCallback.h"
 72898: #include "mozilla/Preferences.h"
101833: #include "mozilla/Attributes.h"
  3942: 
 56264: #include "nsXULAppAPI.h"
 56264: 
 72898: using namespace mozilla;
 72898: 
108991: static const uint32_t kRescheduleLimit = 3;
 94502: // Max number of retries for every entry of pinned app.
108991: static const uint32_t kPinnedEntryRetriesLimit = 3;
100211: // Maximum number of parallel items loads
108991: static const uint32_t kParallelLoadLimit = 15;
 21365: 
100212: // Quota for offline apps when preloading
108991: static const int32_t  kCustomProfileQuota = 512000;
100212: 
  3942: #if defined(PR_LOGGING)
  3942: //
  3942: // To enable logging (see prlog.h for full details):
  3942: //
  3942: //    set NSPR_LOG_MODULES=nsOfflineCacheUpdate:5
  3942: //    set NSPR_LOG_FILE=offlineupdate.log
  3942: //
  3942: // this enables PR_LOG_ALWAYS level information and places all output in
  3942: // the file offlineupdate.log
  3942: //
 56242: extern PRLogModuleInfo *gOfflineCacheUpdateLog;
  3942: #endif
  3942: #define LOG(args) PR_LOG(gOfflineCacheUpdateLog, 4, args)
  3942: #define LOG_ENABLED() PR_LOG_TEST(gOfflineCacheUpdateLog, 4)
  3942: 
  3942: class AutoFreeArray {
  3942: public:
108991:     AutoFreeArray(uint32_t count, char **values)
  3942:         : mCount(count), mValues(values) {};
  3942:     ~AutoFreeArray() { NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(mCount, mValues); }
  3942: private:
108991:     uint32_t mCount;
  3942:     char **mValues;
  3942: };
  3942: 
 19925: static nsresult
 19925: DropReferenceFromURL(nsIURI * aURI)
 19925: {
 70215:     // XXXdholbert If this SetRef fails, callers of this method probably
 70215:     // want to call aURI->CloneIgnoringRef() and use the result of that.
 70215:     return aURI->SetRef(EmptyCString());
 19925: }
 19925: 
  3942: //-----------------------------------------------------------------------------
 21365: // nsManifestCheck
 21365: //-----------------------------------------------------------------------------
 21365: 
101833: class nsManifestCheck MOZ_FINAL : public nsIStreamListener
 21365:                                 , public nsIChannelEventSink
 21365:                                 , public nsIInterfaceRequestor
 21365: {
 21365: public:
 21365:     nsManifestCheck(nsOfflineCacheUpdate *aUpdate,
 21365:                     nsIURI *aURI,
 21365:                     nsIURI *aReferrerURI)
 21365:         : mUpdate(aUpdate)
 21365:         , mURI(aURI)
 21365:         , mReferrerURI(aReferrerURI)
 21365:         {}
 21365: 
 21365:     NS_DECL_ISUPPORTS
 21365:     NS_DECL_NSIREQUESTOBSERVER
 21365:     NS_DECL_NSISTREAMLISTENER
 21365:     NS_DECL_NSICHANNELEVENTSINK
 21365:     NS_DECL_NSIINTERFACEREQUESTOR
 21365: 
 21365:     nsresult Begin();
 21365: 
 21365: private:
 21365: 
 21365:     static NS_METHOD ReadManifest(nsIInputStream *aInputStream,
 21365:                                   void *aClosure,
 21365:                                   const char *aFromSegment,
108991:                                   uint32_t aOffset,
108991:                                   uint32_t aCount,
108991:                                   uint32_t *aBytesConsumed);
 21365: 
 21365:     nsRefPtr<nsOfflineCacheUpdate> mUpdate;
 21365:     nsCOMPtr<nsIURI> mURI;
 21365:     nsCOMPtr<nsIURI> mReferrerURI;
 21365:     nsCOMPtr<nsICryptoHash> mManifestHash;
 21365:     nsCOMPtr<nsIChannel> mChannel;
 21365: };
 21365: 
 21365: //-----------------------------------------------------------------------------
 21365: // nsManifestCheck::nsISupports
 21365: //-----------------------------------------------------------------------------
 21365: NS_IMPL_ISUPPORTS4(nsManifestCheck,
 21365:                    nsIRequestObserver,
 21365:                    nsIStreamListener,
 21365:                    nsIChannelEventSink,
 21365:                    nsIInterfaceRequestor)
 21365: 
 21365: //-----------------------------------------------------------------------------
 21365: // nsManifestCheck <public>
 21365: //-----------------------------------------------------------------------------
 21365: 
 21365: nsresult
 21365: nsManifestCheck::Begin()
 21365: {
 21365:     nsresult rv;
 21365:     mManifestHash = do_CreateInstance("@mozilla.org/security/hash;1", &rv);
 21365:     NS_ENSURE_SUCCESS(rv, rv);
 21365: 
 21365:     rv = mManifestHash->Init(nsICryptoHash::MD5);
 21365:     NS_ENSURE_SUCCESS(rv, rv);
 21365: 
 21365:     rv = NS_NewChannel(getter_AddRefs(mChannel),
 21365:                        mURI,
106838:                        nullptr, nullptr, nullptr,
 21365:                        nsIRequest::LOAD_BYPASS_CACHE);
 21365:     NS_ENSURE_SUCCESS(rv, rv);
 21365: 
 21365:     // configure HTTP specific stuff
 21365:     nsCOMPtr<nsIHttpChannel> httpChannel =
 21365:         do_QueryInterface(mChannel);
 21365:     if (httpChannel) {
 21365:         httpChannel->SetReferrer(mReferrerURI);
 21365:         httpChannel->SetRequestHeader(NS_LITERAL_CSTRING("X-Moz"),
 21365:                                       NS_LITERAL_CSTRING("offline-resource"),
 80486:                                       false);
 21365:     }
 21365: 
106838:     rv = mChannel->AsyncOpen(this, nullptr);
 21365:     NS_ENSURE_SUCCESS(rv, rv);
 21365: 
 21365:     return NS_OK;
 21365: }
 21365: 
 21365: //-----------------------------------------------------------------------------
 21365: // nsManifestCheck <public>
 21365: //-----------------------------------------------------------------------------
 21365: 
 21365: /* static */
 21365: NS_METHOD
 21365: nsManifestCheck::ReadManifest(nsIInputStream *aInputStream,
 21365:                               void *aClosure,
 21365:                               const char *aFromSegment,
108991:                               uint32_t aOffset,
108991:                               uint32_t aCount,
108991:                               uint32_t *aBytesConsumed)
 21365: {
 21365:     nsManifestCheck *manifestCheck =
 21365:         static_cast<nsManifestCheck*>(aClosure);
 21365: 
 21365:     nsresult rv;
 21365:     *aBytesConsumed = aCount;
 21365: 
 21365:     rv = manifestCheck->mManifestHash->Update(
108991:         reinterpret_cast<const uint8_t *>(aFromSegment), aCount);
 21365:     NS_ENSURE_SUCCESS(rv, rv);
 21365: 
 21365:     return NS_OK;
 21365: }
 21365: 
 21365: //-----------------------------------------------------------------------------
 21365: // nsManifestCheck::nsIStreamListener
 21365: //-----------------------------------------------------------------------------
 21365: 
 21365: NS_IMETHODIMP
 21365: nsManifestCheck::OnStartRequest(nsIRequest *aRequest,
 21365:                                 nsISupports *aContext)
 21365: {
 21365:     return NS_OK;
 21365: }
 21365: 
 21365: NS_IMETHODIMP
 21365: nsManifestCheck::OnDataAvailable(nsIRequest *aRequest,
 21365:                                  nsISupports *aContext,
 21365:                                  nsIInputStream *aStream,
111234:                                  uint64_t aOffset,
108991:                                  uint32_t aCount)
 21365: {
108991:     uint32_t bytesRead;
 21365:     aStream->ReadSegments(ReadManifest, this, aCount, &bytesRead);
 21365:     return NS_OK;
 21365: }
 21365: 
 21365: NS_IMETHODIMP
 21365: nsManifestCheck::OnStopRequest(nsIRequest *aRequest,
 21365:                                nsISupports *aContext,
 21365:                                nsresult aStatus)
 21365: {
110974:     nsAutoCString manifestHash;
 21365:     if (NS_SUCCEEDED(aStatus)) {
 80486:         mManifestHash->Finish(true, manifestHash);
 21365:     }
 21365: 
 21365:     mUpdate->ManifestCheckCompleted(aStatus, manifestHash);
 21365: 
 21365:     return NS_OK;
 21365: }
 21365: 
 21365: //-----------------------------------------------------------------------------
 21365: // nsManifestCheck::nsIInterfaceRequestor
 21365: //-----------------------------------------------------------------------------
 21365: 
 21365: NS_IMETHODIMP
 21365: nsManifestCheck::GetInterface(const nsIID &aIID, void **aResult)
 21365: {
 21365:     if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
 21365:         NS_ADDREF_THIS();
 21365:         *aResult = static_cast<nsIChannelEventSink *>(this);
 21365:         return NS_OK;
 21365:     }
 21365: 
 21365:     return NS_ERROR_NO_INTERFACE;
 21365: }
 21365: 
 21365: //-----------------------------------------------------------------------------
 21365: // nsManifestCheck::nsIChannelEventSink
 21365: //-----------------------------------------------------------------------------
 21365: 
 21365: NS_IMETHODIMP
 48889: nsManifestCheck::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
 21365:                                         nsIChannel *aNewChannel,
108991:                                         uint32_t aFlags,
 48889:                                         nsIAsyncVerifyRedirectCallback *callback)
 21365: {
 21365:     // Redirects should cause the load (and therefore the update) to fail.
 48889:     if (aFlags & nsIChannelEventSink::REDIRECT_INTERNAL) {
 48889:         callback->OnRedirectVerifyCallback(NS_OK);
 21365:         return NS_OK;
 48889:     }
 21365:     aOldChannel->Cancel(NS_ERROR_ABORT);
 21365:     return NS_ERROR_ABORT;
 21365: }
 21365: 
 21365: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdateItem::nsISupports
  3942: //-----------------------------------------------------------------------------
  3942: 
  3947: NS_IMPL_ISUPPORTS6(nsOfflineCacheUpdateItem,
  3942:                    nsIDOMLoadStatus,
  3942:                    nsIRequestObserver,
  3942:                    nsIStreamListener,
  3947:                    nsIRunnable,
  3942:                    nsIInterfaceRequestor,
  3942:                    nsIChannelEventSink)
  3942: 
  3942: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdateItem <public>
  3942: //-----------------------------------------------------------------------------
  3942: 
100211: nsOfflineCacheUpdateItem::nsOfflineCacheUpdateItem(nsIURI *aURI,
  3942:                                                    nsIURI *aReferrerURI,
100212:                                                    nsIApplicationCache *aApplicationCache,
 18430:                                                    nsIApplicationCache *aPreviousApplicationCache,
108991:                                                    uint32_t type)
  3942:     : mURI(aURI)
  3942:     , mReferrerURI(aReferrerURI)
100212:     , mApplicationCache(aApplicationCache)
 18430:     , mPreviousApplicationCache(aPreviousApplicationCache)
 18430:     , mItemType(type)
106838:     , mChannel(nullptr)
  3942:     , mState(nsIDOMLoadStatus::UNINITIALIZED)
  3942:     , mBytesRead(0)
  3942: {
  3942: }
  3942: 
  3942: nsOfflineCacheUpdateItem::~nsOfflineCacheUpdateItem()
  3942: {
  3942: }
  3942: 
  3942: nsresult
100211: nsOfflineCacheUpdateItem::OpenChannel(nsOfflineCacheUpdate *aUpdate)
  3942: {
 18430: #if defined(PR_LOGGING)
 18430:     if (LOG_ENABLED()) {
110974:         nsAutoCString spec;
 18430:         mURI->GetSpec(spec);
 18430:         LOG(("%p: Opening channel for %s", this, spec.get()));
 18430:     }
 18430: #endif
 18430: 
 18430:     nsresult rv = nsOfflineCacheUpdate::GetCacheKey(mURI, mCacheKey);
 18430:     NS_ENSURE_SUCCESS(rv, rv);
 18430: 
 18430:     rv = NS_NewChannel(getter_AddRefs(mChannel),
  3942:                        mURI,
106838:                        nullptr, nullptr, this,
  3942:                        nsIRequest::LOAD_BACKGROUND |
 10900:                        nsICachingChannel::LOAD_ONLY_IF_MODIFIED |
 10900:                        nsICachingChannel::LOAD_CHECK_OFFLINE_CACHE);
  3942:     NS_ENSURE_SUCCESS(rv, rv);
  3942: 
 21311:     nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
 18430:         do_QueryInterface(mChannel, &rv);
 18430: 
 21311:     // Support for nsIApplicationCacheChannel is required.
 18430:     NS_ENSURE_SUCCESS(rv, rv);
 18430: 
 18430:     // Use the existing application cache as the cache to check.
 21311:     rv = appCacheChannel->SetApplicationCache(mPreviousApplicationCache);
 18430:     NS_ENSURE_SUCCESS(rv, rv);
 18430: 
104271:     // Set the new application cache as the targer for write.
104271:     rv = appCacheChannel->SetApplicationCacheForWrite(mApplicationCache);
104271:     NS_ENSURE_SUCCESS(rv, rv);
104271: 
  3942:     // configure HTTP specific stuff
  3942:     nsCOMPtr<nsIHttpChannel> httpChannel =
  3942:         do_QueryInterface(mChannel);
  3942:     if (httpChannel) {
  3942:         httpChannel->SetReferrer(mReferrerURI);
  3942:         httpChannel->SetRequestHeader(NS_LITERAL_CSTRING("X-Moz"),
  3942:                                       NS_LITERAL_CSTRING("offline-resource"),
 80486:                                       false);
  3942:     }
  3942: 
106838:     rv = mChannel->AsyncOpen(this, nullptr);
  3942:     NS_ENSURE_SUCCESS(rv, rv);
  3942: 
100211:     mUpdate = aUpdate;
100211: 
  3942:     mState = nsIDOMLoadStatus::REQUESTED;
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: nsresult
  3942: nsOfflineCacheUpdateItem::Cancel()
  3942: {
  3942:     if (mChannel) {
  3942:         mChannel->Cancel(NS_ERROR_ABORT);
106838:         mChannel = nullptr;
  3942:     }
  3942: 
  3942:     mState = nsIDOMLoadStatus::UNINITIALIZED;
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdateItem::nsIStreamListener
  3942: //-----------------------------------------------------------------------------
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdateItem::OnStartRequest(nsIRequest *aRequest,
  3942:                                          nsISupports *aContext)
  3942: {
  3942:     mState = nsIDOMLoadStatus::RECEIVING;
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdateItem::OnDataAvailable(nsIRequest *aRequest,
  3942:                                           nsISupports *aContext,
  3942:                                           nsIInputStream *aStream,
111234:                                           uint64_t aOffset,
108991:                                           uint32_t aCount)
  3942: {
108991:     uint32_t bytesRead = 0;
106838:     aStream->ReadSegments(NS_DiscardSegment, nullptr, aCount, &bytesRead);
  3942:     mBytesRead += bytesRead;
111234:     LOG(("loaded %u bytes into offline cache [offset=%llu]\n",
  3942:          bytesRead, aOffset));
 99119: 
 99119:     mUpdate->OnByteProgress(bytesRead);
 99119: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdateItem::OnStopRequest(nsIRequest *aRequest,
  3942:                                         nsISupports *aContext,
  3942:                                         nsresult aStatus)
  3942: {
  3942:     LOG(("done fetching offline item [status=%x]\n", aStatus));
  3942: 
  3942:     if (mBytesRead == 0 && aStatus == NS_OK) {
  3942:         // we didn't need to read (because LOAD_ONLY_IF_MODIFIED was
  3942:         // specified), but the object should report loadedSize as if it
  3942:         // did.
  3942:         mChannel->GetContentLength(&mBytesRead);
 99119:         mUpdate->OnByteProgress(mBytesRead);
  3942:     }
  3942: 
  3947:     // We need to notify the update that the load is complete, but we
  3947:     // want to give the channel a chance to close the cache entries.
  3947:     NS_DispatchToCurrentThread(this);
  3947: 
  3947:     return NS_OK;
  3947: }
  3947: 
  3947: 
  3947: //-----------------------------------------------------------------------------
  3947: // nsOfflineCacheUpdateItem::nsIRunnable
  3947: //-----------------------------------------------------------------------------
  3947: NS_IMETHODIMP
  3947: nsOfflineCacheUpdateItem::Run()
  3947: {
100211:     // Set mState to LOADED here rather than in OnStopRequest to prevent
100211:     // race condition when checking state of all mItems in ProcessNextURI().
100211:     // If state would have been set in OnStopRequest we could mistakenly
100211:     // take this item as already finished and finish the update process too
100211:     // early when ProcessNextURI() would get called between OnStopRequest()
100211:     // and Run() of this item.  Finish() would then have been called twice.
100211:     mState = nsIDOMLoadStatus::LOADED;
100211: 
100211:     nsRefPtr<nsOfflineCacheUpdate> update;
100211:     update.swap(mUpdate);
100211:     update->LoadCompleted(this);
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdateItem::nsIInterfaceRequestor
  3942: //-----------------------------------------------------------------------------
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdateItem::GetInterface(const nsIID &aIID, void **aResult)
  3942: {
  3942:     if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
  3942:         NS_ADDREF_THIS();
  3942:         *aResult = static_cast<nsIChannelEventSink *>(this);
  3942:         return NS_OK;
  3942:     }
  3942: 
  3942:     return NS_ERROR_NO_INTERFACE;
  3942: }
  3942: 
  3942: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdateItem::nsIChannelEventSink
  3942: //-----------------------------------------------------------------------------
  3942: 
  3942: NS_IMETHODIMP
 48889: nsOfflineCacheUpdateItem::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
  3942:                                                  nsIChannel *aNewChannel,
108991:                                                  uint32_t aFlags,
 48889:                                                  nsIAsyncVerifyRedirectCallback *cb)
  3942: {
 25596:     if (!(aFlags & nsIChannelEventSink::REDIRECT_INTERNAL)) {
 25596:         // Don't allow redirect in case of non-internal redirect and cancel
 25596:         // the channel to clean the cache entry.
 25596:         aOldChannel->Cancel(NS_ERROR_ABORT);
 25596:         return NS_ERROR_ABORT;
 25596:     }
 25596: 
  3942:     nsCOMPtr<nsIURI> newURI;
  3942:     nsresult rv = aNewChannel->GetURI(getter_AddRefs(newURI));
  3942:     if (NS_FAILED(rv))
  3942:         return rv;
  3942: 
104271:     nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
 25596:         do_QueryInterface(aNewChannel);
104271:     if (appCacheChannel) {
104271:         rv = appCacheChannel->SetApplicationCacheForWrite(mApplicationCache);
100212:         NS_ENSURE_SUCCESS(rv, rv);
  3947:     }
  3947: 
110974:     nsAutoCString oldScheme;
 10340:     mURI->GetScheme(oldScheme);
  3942: 
 79445:     bool match;
 10340:     if (NS_FAILED(newURI->SchemeIs(oldScheme.get(), &match)) || !match) {
 10340:         LOG(("rejected: redirected to a different scheme\n"));
  3942:         return NS_ERROR_ABORT;
  3942:     }
  3942: 
  3942:     // HTTP request headers are not automatically forwarded to the new channel.
  3942:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aNewChannel);
  3942:     NS_ENSURE_STATE(httpChannel);
  3942: 
  3942:     httpChannel->SetRequestHeader(NS_LITERAL_CSTRING("X-Moz"),
  3942:                                   NS_LITERAL_CSTRING("offline-resource"),
 80486:                                   false);
  3942: 
  3942:     mChannel = aNewChannel;
  3942: 
 48889:     cb->OnRedirectVerifyCallback(NS_OK);
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdateItem::nsIDOMLoadStatus
  3942: //-----------------------------------------------------------------------------
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdateItem::GetSource(nsIDOMNode **aSource)
  3942: {
106838:     *aSource = nullptr;
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdateItem::GetUri(nsAString &aURI)
  3942: {
110974:     nsAutoCString spec;
  3942:     nsresult rv = mURI->GetSpec(spec);
  3942:     NS_ENSURE_SUCCESS(rv, rv);
  3942: 
  3942:     CopyUTF8toUTF16(spec, aURI);
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
108991: nsOfflineCacheUpdateItem::GetTotalSize(int32_t *aTotalSize)
  3942: {
  3942:     if (mChannel) {
119704:       int64_t size64;
119704:       nsresult rv = mChannel->GetContentLength(&size64);
119704:       NS_ENSURE_SUCCESS(rv, rv);
119704:       *aTotalSize = int32_t(size64); // XXX - loses precision
119704:       return NS_OK;
  3942:     }
  3942: 
  3942:     *aTotalSize = -1;
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
108991: nsOfflineCacheUpdateItem::GetLoadedSize(int32_t *aLoadedSize)
  3942: {
119704:     *aLoadedSize = int32_t(mBytesRead); // XXX - loses precision
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
108991: nsOfflineCacheUpdateItem::GetReadyState(uint16_t *aReadyState)
  3942: {
  3942:     *aReadyState = mState;
  3942:     return NS_OK;
  3942: }
  3942: 
 25596: nsresult
 79445: nsOfflineCacheUpdateItem::GetRequestSucceeded(bool * succeeded)
 25596: {
 80486:     *succeeded = false;
 25596: 
 25596:     if (!mChannel)
 25596:         return NS_OK;
 25596: 
 25596:     nsresult rv;
 25596:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(mChannel, &rv);
 25596:     NS_ENSURE_SUCCESS(rv, rv);
 25596: 
 79445:     bool reqSucceeded;
 25596:     rv = httpChannel->GetRequestSucceeded(&reqSucceeded);
 25596:     if (NS_ERROR_NOT_AVAILABLE == rv)
 25596:         return NS_OK;
 25596:     NS_ENSURE_SUCCESS(rv, rv);
 25596: 
 25596:     if (!reqSucceeded) {
 25596:         LOG(("Request failed"));
 25596:         return NS_OK;
 25596:     }
 25596: 
 25596:     nsresult channelStatus;
 25596:     rv = httpChannel->GetStatus(&channelStatus);
 25596:     NS_ENSURE_SUCCESS(rv, rv);
 25596: 
 25596:     if (NS_FAILED(channelStatus)) {
 25596:         LOG(("Channel status=0x%08x", channelStatus));
 25596:         return NS_OK;
 25596:     }
 25596: 
 80486:     *succeeded = true;
 25596:     return NS_OK;
 25596: }
 25596: 
100211: bool
100211: nsOfflineCacheUpdateItem::IsScheduled()
100211: {
100211:     return mState == nsIDOMLoadStatus::UNINITIALIZED;
100211: }
100211: 
100211: bool
100211: nsOfflineCacheUpdateItem::IsInProgress()
100211: {
100211:     return mState == nsIDOMLoadStatus::REQUESTED ||
100211:            mState == nsIDOMLoadStatus::RECEIVING;
100211: }
100211: 
100211: bool
100211: nsOfflineCacheUpdateItem::IsCompleted()
100211: {
100211:     return mState == nsIDOMLoadStatus::LOADED;
100211: }
100211: 
  3942: NS_IMETHODIMP
108991: nsOfflineCacheUpdateItem::GetStatus(uint16_t *aStatus)
  3942: {
  3942:     if (!mChannel) {
  3942:         *aStatus = 0;
  3942:         return NS_OK;
  3942:     }
  3942: 
  3942:     nsresult rv;
  3942:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(mChannel, &rv);
  3942:     NS_ENSURE_SUCCESS(rv, rv);
  3942: 
108991:     uint32_t httpStatus;
  3942:     rv = httpChannel->GetResponseStatus(&httpStatus);
  3942:     if (rv == NS_ERROR_NOT_AVAILABLE) {
  3942:         *aStatus = 0;
  3942:         return NS_OK;
  3942:     }
  3942: 
  3942:     NS_ENSURE_SUCCESS(rv, rv);
108991:     *aStatus = uint16_t(httpStatus);
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: //-----------------------------------------------------------------------------
 10340: // nsOfflineManifestItem
 10340: //-----------------------------------------------------------------------------
 10340: 
 10340: //-----------------------------------------------------------------------------
 10340: // nsOfflineManifestItem <public>
 10340: //-----------------------------------------------------------------------------
 10340: 
100211: nsOfflineManifestItem::nsOfflineManifestItem(nsIURI *aURI,
 10340:                                              nsIURI *aReferrerURI,
100212:                                              nsIApplicationCache *aApplicationCache,
104271:                                              nsIApplicationCache *aPreviousApplicationCache)
100211:     : nsOfflineCacheUpdateItem(aURI, aReferrerURI,
104271:                                aApplicationCache, aPreviousApplicationCache,
 18430:                                nsIApplicationCache::ITEM_MANIFEST)
 10340:     , mParserState(PARSE_INIT)
 80486:     , mNeedsUpdate(true)
 80486:     , mManifestHashInitialized(false)
 10340: {
 19925:     ReadStrictFileOriginPolicyPref();
 10340: }
 10340: 
 10340: nsOfflineManifestItem::~nsOfflineManifestItem()
 10340: {
 10340: }
 10340: 
 10340: //-----------------------------------------------------------------------------
 10340: // nsOfflineManifestItem <private>
 10340: //-----------------------------------------------------------------------------
 10340: 
 10340: /* static */
 10340: NS_METHOD
 10340: nsOfflineManifestItem::ReadManifest(nsIInputStream *aInputStream,
 10340:                                     void *aClosure,
 10340:                                     const char *aFromSegment,
108991:                                     uint32_t aOffset,
108991:                                     uint32_t aCount,
108991:                                     uint32_t *aBytesConsumed)
 10340: {
 10340:     nsOfflineManifestItem *manifest =
 10340:         static_cast<nsOfflineManifestItem*>(aClosure);
 10340: 
 10900:     nsresult rv;
 10900: 
 10340:     *aBytesConsumed = aCount;
 10340: 
 10340:     if (manifest->mParserState == PARSE_ERROR) {
 10340:         // parse already failed, ignore this
 10340:         return NS_OK;
 10340:     }
 10340: 
 10900:     if (!manifest->mManifestHashInitialized) {
 10900:         // Avoid re-creation of crypto hash when it fails from some reason the first time
 80486:         manifest->mManifestHashInitialized = true;
 10900: 
 10900:         manifest->mManifestHash = do_CreateInstance("@mozilla.org/security/hash;1", &rv);
 10900:         if (NS_SUCCEEDED(rv)) {
 10900:             rv = manifest->mManifestHash->Init(nsICryptoHash::MD5);
 10900:             if (NS_FAILED(rv)) {
106838:                 manifest->mManifestHash = nullptr;
 10900:                 LOG(("Could not initialize manifest hash for byte-to-byte check, rv=%08x", rv));
 10900:             }
 10900:         }
 10900:     }
 10900: 
 10900:     if (manifest->mManifestHash) {
108991:         rv = manifest->mManifestHash->Update(reinterpret_cast<const uint8_t *>(aFromSegment), aCount);
 10900:         if (NS_FAILED(rv)) {
106838:             manifest->mManifestHash = nullptr;
 10900:             LOG(("Could not update manifest hash, rv=%08x", rv));
 10900:         }
 10900:     }
 10900: 
 10340:     manifest->mReadBuf.Append(aFromSegment, aCount);
 10340: 
 10340:     nsCString::const_iterator begin, iter, end;
 10340:     manifest->mReadBuf.BeginReading(begin);
 10340:     manifest->mReadBuf.EndReading(end);
 10340: 
 10340:     for (iter = begin; iter != end; iter++) {
 10340:         if (*iter == '\r' || *iter == '\n') {
 10340:             nsresult rv = manifest->HandleManifestLine(begin, iter);
 10340: 
 10340:             if (NS_FAILED(rv)) {
 10340:                 LOG(("HandleManifestLine failed with 0x%08x", rv));
100211:                 *aBytesConsumed = 0; // Avoid assertion failure in stream tee
 10340:                 return NS_ERROR_ABORT;
 10340:             }
 10340: 
 10340:             begin = iter;
 10340:             begin++;
 10340:         }
 10340:     }
 10340: 
 10340:     // any leftovers are saved for next time
 10340:     manifest->mReadBuf = Substring(begin, end);
 10340: 
 10340:     return NS_OK;
 10340: }
 10340: 
 10340: nsresult
108991: nsOfflineManifestItem::AddNamespace(uint32_t namespaceType,
 19925:                                     const nsCString &namespaceSpec,
 19925:                                     const nsCString &data)
 19925: 
 19925: {
 19925:     nsresult rv;
 19925:     if (!mNamespaces) {
 19925:         mNamespaces = do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
 19925:         NS_ENSURE_SUCCESS(rv, rv);
 19925:     }
 19925: 
 19925:     nsCOMPtr<nsIApplicationCacheNamespace> ns =
 19925:         do_CreateInstance(NS_APPLICATIONCACHENAMESPACE_CONTRACTID, &rv);
 19925:     NS_ENSURE_SUCCESS(rv, rv);
 19925: 
 20985:     rv = ns->Init(namespaceType, namespaceSpec, data);
 19925:     NS_ENSURE_SUCCESS(rv, rv);
 19925: 
 80486:     rv = mNamespaces->AppendElement(ns, false);
 19925:     NS_ENSURE_SUCCESS(rv, rv);
 19925: 
 19925:     return NS_OK;
 19925: }
 19925: 
 19925: nsresult
 10340: nsOfflineManifestItem::HandleManifestLine(const nsCString::const_iterator &aBegin,
 10340:                                           const nsCString::const_iterator &aEnd)
 10340: {
 10340:     nsCString::const_iterator begin = aBegin;
 10340:     nsCString::const_iterator end = aEnd;
 10340: 
 10340:     // all lines ignore trailing spaces and tabs
 10340:     nsCString::const_iterator last = end;
 10340:     --last;
 10340:     while (end != begin && (*last == ' ' || *last == '\t')) {
 10340:         --end;
 10340:         --last;
 10340:     }
 10340: 
 10340:     if (mParserState == PARSE_INIT) {
 10340:         // Allow a UTF-8 BOM
 10340:         if (begin != end && static_cast<unsigned char>(*begin) == 0xef) {
 10340:             if (++begin == end || static_cast<unsigned char>(*begin) != 0xbb ||
 10340:                 ++begin == end || static_cast<unsigned char>(*begin) != 0xbf) {
 10340:                 mParserState = PARSE_ERROR;
 10340:                 return NS_OK;
 10340:             }
 10340:             ++begin;
 10340:         }
 10340: 
 10340:         const nsCSubstring &magic = Substring(begin, end);
 10340: 
 10340:         if (!magic.EqualsLiteral("CACHE MANIFEST")) {
 10340:             mParserState = PARSE_ERROR;
 10340:             return NS_OK;
 10340:         }
 10340: 
 10340:         mParserState = PARSE_CACHE_ENTRIES;
 10340:         return NS_OK;
 10340:     }
 10340: 
 10340:     // lines other than the first ignore leading spaces and tabs
 10340:     while (begin != end && (*begin == ' ' || *begin == '\t'))
 10340:         begin++;
 10340: 
 10340:     // ignore blank lines and comments
 10340:     if (begin == end || *begin == '#')
 10340:         return NS_OK;
 10340: 
 10340:     const nsCSubstring &line = Substring(begin, end);
 10340: 
 10340:     if (line.EqualsLiteral("CACHE:")) {
 10340:         mParserState = PARSE_CACHE_ENTRIES;
 10340:         return NS_OK;
 10340:     }
 10340: 
 10340:     if (line.EqualsLiteral("FALLBACK:")) {
 10340:         mParserState = PARSE_FALLBACK_ENTRIES;
 10340:         return NS_OK;
 10340:     }
 10340: 
 10340:     if (line.EqualsLiteral("NETWORK:")) {
 19925:         mParserState = PARSE_BYPASS_ENTRIES;
 10340:         return NS_OK;
 10340:     }
 10340: 
104573:     // Every other section type we don't know must be silently ignored.
104573:     nsCString::const_iterator lastChar = end;
104573:     if (*(--lastChar) == ':') {
104573:         mParserState = PARSE_UNKNOWN_SECTION;
104573:         return NS_OK;
104573:     }
104573: 
 10340:     nsresult rv;
 10340: 
 10340:     switch(mParserState) {
 10340:     case PARSE_INIT:
 10340:     case PARSE_ERROR: {
 10340:         // this should have been dealt with earlier
 10340:         return NS_ERROR_FAILURE;
 10340:     }
 18488: 
104573:     case PARSE_UNKNOWN_SECTION: {
104573:         // just jump over
104573:         return NS_OK;
104573:     }
104573: 
 10340:     case PARSE_CACHE_ENTRIES: {
 10340:         nsCOMPtr<nsIURI> uri;
106838:         rv = NS_NewURI(getter_AddRefs(uri), line, nullptr, mURI);
 10340:         if (NS_FAILED(rv))
 10340:             break;
 19925:         if (NS_FAILED(DropReferenceFromURL(uri)))
 19925:             break;
 10340: 
110974:         nsAutoCString scheme;
 10340:         uri->GetScheme(scheme);
 10340: 
 10340:         // Manifest URIs must have the same scheme as the manifest.
 79445:         bool match;
 10340:         if (NS_FAILED(mURI->SchemeIs(scheme.get(), &match)) || !match)
 10340:             break;
 10340: 
 10340:         mExplicitURIs.AppendObject(uri);
 10340:         break;
 10340:     }
 19925: 
 19925:     case PARSE_FALLBACK_ENTRIES: {
108991:         int32_t separator = line.FindChar(' ');
 19925:         if (separator == kNotFound) {
 19925:             separator = line.FindChar('\t');
 19925:             if (separator == kNotFound)
 19925:                 break;
 19925:         }
 19925: 
 19925:         nsCString namespaceSpec(Substring(line, 0, separator));
 19925:         nsCString fallbackSpec(Substring(line, separator + 1));
 19925:         namespaceSpec.CompressWhitespace();
 19925:         fallbackSpec.CompressWhitespace();
 19925: 
 19925:         nsCOMPtr<nsIURI> namespaceURI;
106838:         rv = NS_NewURI(getter_AddRefs(namespaceURI), namespaceSpec, nullptr, mURI);
 19925:         if (NS_FAILED(rv))
 19925:             break;
 19925:         if (NS_FAILED(DropReferenceFromURL(namespaceURI)))
 19925:             break;
 19925:         rv = namespaceURI->GetAsciiSpec(namespaceSpec);
 19925:         if (NS_FAILED(rv))
 19925:             break;
 19925: 
 19925: 
 19925:         nsCOMPtr<nsIURI> fallbackURI;
106838:         rv = NS_NewURI(getter_AddRefs(fallbackURI), fallbackSpec, nullptr, mURI);
 19925:         if (NS_FAILED(rv))
 19925:             break;
 19925:         if (NS_FAILED(DropReferenceFromURL(fallbackURI)))
 19925:             break;
 19925:         rv = fallbackURI->GetAsciiSpec(fallbackSpec);
 19925:         if (NS_FAILED(rv))
 19925:             break;
 19925: 
 19925:         // Manifest and namespace must be same origin
 19925:         if (!NS_SecurityCompareURIs(mURI, namespaceURI,
 19925:                                     mStrictFileOriginPolicy))
 19925:             break;
 19925: 
 19925:         // Fallback and namespace must be same origin
 19925:         if (!NS_SecurityCompareURIs(namespaceURI, fallbackURI,
 19925:                                     mStrictFileOriginPolicy))
 19925:             break;
 19925: 
 19925:         mFallbackURIs.AppendObject(fallbackURI);
 19925: 
 21314:         AddNamespace(nsIApplicationCacheNamespace::NAMESPACE_FALLBACK,
 19925:                      namespaceSpec, fallbackSpec);
 19925:         break;
 19925:     }
 19925: 
 19925:     case PARSE_BYPASS_ENTRIES: {
 58228:         if (line[0] == '*' && (line.Length() == 1 || line[1] == ' ' || line[1] == '\t'))
 58228:         {
 58228:           // '*' indicates to make the online whitelist wildcard flag open,
 58228:           // i.e. do allow load of resources not present in the offline cache
 58228:           // or not conforming any namespace.
 58228:           // We achive that simply by adding an 'empty' - i.e. universal
 58228:           // namespace of BYPASS type into the cache.
 58228:           AddNamespace(nsIApplicationCacheNamespace::NAMESPACE_BYPASS,
 58228:                        EmptyCString(), EmptyCString());
 58228:           break;
 58228:         }
 58228: 
 19925:         nsCOMPtr<nsIURI> bypassURI;
106838:         rv = NS_NewURI(getter_AddRefs(bypassURI), line, nullptr, mURI);
 19925:         if (NS_FAILED(rv))
 19925:             break;
 19925: 
110974:         nsAutoCString scheme;
 19925:         bypassURI->GetScheme(scheme);
 79445:         bool equals;
 19925:         if (NS_FAILED(mURI->SchemeIs(scheme.get(), &equals)) || !equals)
 19925:             break;
 19925:         if (NS_FAILED(DropReferenceFromURL(bypassURI)))
 19925:             break;
 19925:         nsCString spec;
 19925:         if (NS_FAILED(bypassURI->GetAsciiSpec(spec)))
 19925:             break;
 19925: 
 19925:         AddNamespace(nsIApplicationCacheNamespace::NAMESPACE_BYPASS,
 19925:                      spec, EmptyCString());
 10340:         break;
 10340:     }
 10340:     }
 10340: 
 10340:     return NS_OK;
 10340: }
 10340: 
 10900: nsresult
 10900: nsOfflineManifestItem::GetOldManifestContentHash(nsIRequest *aRequest)
 10900: {
 10900:     nsresult rv;
 10900: 
 10900:     nsCOMPtr<nsICachingChannel> cachingChannel = do_QueryInterface(aRequest, &rv);
 10900:     NS_ENSURE_SUCCESS(rv, rv);
 10900: 
 10900:     // load the main cache token that is actually the old offline cache token and
 10900:     // read previous manifest content hash value
 10900:     nsCOMPtr<nsISupports> cacheToken;
 10900:     cachingChannel->GetCacheToken(getter_AddRefs(cacheToken));
 10900:     if (cacheToken) {
 10900:         nsCOMPtr<nsICacheEntryDescriptor> cacheDescriptor(do_QueryInterface(cacheToken, &rv));
 10900:         NS_ENSURE_SUCCESS(rv, rv);
 10900: 
 10900:         rv = cacheDescriptor->GetMetaDataElement("offline-manifest-hash", getter_Copies(mOldManifestHashValue));
 10900:         if (NS_FAILED(rv))
 10900:             mOldManifestHashValue.Truncate();
 10900:     }
 10900: 
 10900:     return NS_OK;
 10900: }
 10900: 
 10900: nsresult
 10900: nsOfflineManifestItem::CheckNewManifestContentHash(nsIRequest *aRequest)
 10900: {
 10900:     nsresult rv;
 10900: 
 10900:     if (!mManifestHash) {
 10900:         // Nothing to compare against...
 10900:         return NS_OK;
 10900:     }
 10900: 
 10900:     nsCString newManifestHashValue;
 80486:     rv = mManifestHash->Finish(true, mManifestHashValue);
106838:     mManifestHash = nullptr;
 10900: 
 10900:     if (NS_FAILED(rv)) {
 10900:         LOG(("Could not finish manifest hash, rv=%08x", rv));
 10900:         // This is not critical error
 10900:         return NS_OK;
 10900:     }
 10900: 
 10900:     if (!ParseSucceeded()) {
 10900:         // Parsing failed, the hash is not valid
 10900:         return NS_OK;
 10900:     }
 10900: 
 21365:     if (mOldManifestHashValue == mManifestHashValue) {
 10900:         LOG(("Update not needed, downloaded manifest content is byte-for-byte identical"));
 80486:         mNeedsUpdate = false;
 10900:     }
 10900: 
 10900:     // Store the manifest content hash value to the new
 10900:     // offline cache token
 10900:     nsCOMPtr<nsICachingChannel> cachingChannel = do_QueryInterface(aRequest, &rv);
 10900:     NS_ENSURE_SUCCESS(rv, rv);
 10900: 
 10900:     nsCOMPtr<nsISupports> cacheToken;
 10900:     cachingChannel->GetOfflineCacheToken(getter_AddRefs(cacheToken));
 10900:     if (cacheToken) {
 10900:         nsCOMPtr<nsICacheEntryDescriptor> cacheDescriptor(do_QueryInterface(cacheToken, &rv));
 10900:         NS_ENSURE_SUCCESS(rv, rv);
 10900: 
 21365:         rv = cacheDescriptor->SetMetaDataElement("offline-manifest-hash", mManifestHashValue.get());
 10900:         NS_ENSURE_SUCCESS(rv, rv);
 10900:     }
 10900: 
 10900:     return NS_OK;
 10900: }
 10900: 
 19925: void
 19925: nsOfflineManifestItem::ReadStrictFileOriginPolicyPref()
 19925: {
 19925:     mStrictFileOriginPolicy =
 79445:         Preferences::GetBool("security.fileuri.strict_origin_policy", true);
 19925: }
 19925: 
 10340: NS_IMETHODIMP
 10340: nsOfflineManifestItem::OnStartRequest(nsIRequest *aRequest,
 10340:                                       nsISupports *aContext)
 10340: {
 10340:     nsresult rv;
 10340: 
 10340:     nsCOMPtr<nsIHttpChannel> channel = do_QueryInterface(aRequest, &rv);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 79445:     bool succeeded;
 10340:     rv = channel->GetRequestSucceeded(&succeeded);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 10340:     if (!succeeded) {
 10340:         LOG(("HTTP request failed"));
 10340:         mParserState = PARSE_ERROR;
 10340:         return NS_ERROR_ABORT;
 10340:     }
 10340: 
110974:     nsAutoCString contentType;
 89844:     rv = channel->GetContentType(contentType);
 89844:     NS_ENSURE_SUCCESS(rv, rv);
 89844: 
 89844:     if (!contentType.EqualsLiteral("text/cache-manifest")) {
 89844:         LOG(("Rejected cache manifest with Content-Type %s (expecting text/cache-manifest)",
 89844:              contentType.get()));
 89844:         mParserState = PARSE_ERROR;
 89844:         return NS_ERROR_ABORT;
 89844:     }
 89844: 
 10900:     rv = GetOldManifestContentHash(aRequest);
 10900:     NS_ENSURE_SUCCESS(rv, rv);
 10900: 
 10340:     return nsOfflineCacheUpdateItem::OnStartRequest(aRequest, aContext);
 10340: }
 10340: 
 10340: NS_IMETHODIMP
 10340: nsOfflineManifestItem::OnDataAvailable(nsIRequest *aRequest,
 10340:                                        nsISupports *aContext,
 10340:                                        nsIInputStream *aStream,
111234:                                        uint64_t aOffset,
108991:                                        uint32_t aCount)
 10340: {
108991:     uint32_t bytesRead = 0;
 10340:     aStream->ReadSegments(ReadManifest, this, aCount, &bytesRead);
 10340:     mBytesRead += bytesRead;
 10340: 
 10340:     if (mParserState == PARSE_ERROR) {
 10340:         LOG(("OnDataAvailable is canceling the request due a parse error\n"));
 10340:         return NS_ERROR_ABORT;
 10340:     }
 10340: 
 10340:     LOG(("loaded %u bytes into offline cache [offset=%u]\n",
 10340:          bytesRead, aOffset));
 10340: 
 10340:     // All the parent method does is read and discard, don't bother
 10340:     // chaining up.
 10340: 
 10340:     return NS_OK;
 10340: }
 10340: 
 10340: NS_IMETHODIMP
 10340: nsOfflineManifestItem::OnStopRequest(nsIRequest *aRequest,
 10340:                                      nsISupports *aContext,
 10340:                                      nsresult aStatus)
 10340: {
 10340:     // handle any leftover manifest data
 10340:     nsCString::const_iterator begin, end;
 10340:     mReadBuf.BeginReading(begin);
 10340:     mReadBuf.EndReading(end);
 10340:     nsresult rv = HandleManifestLine(begin, end);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 10340:     if (mBytesRead == 0) {
 10340:         // we didn't need to read (because LOAD_ONLY_IF_MODIFIED was
 10340:         // specified.)
 80486:         mNeedsUpdate = false;
 10900:     } else {
 10900:         rv = CheckNewManifestContentHash(aRequest);
 10900:         NS_ENSURE_SUCCESS(rv, rv);
 10340:     }
 10340: 
 10340:     return nsOfflineCacheUpdateItem::OnStopRequest(aRequest, aContext, aStatus);
 10340: }
 10340: 
 10340: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdate::nsISupports
  3942: //-----------------------------------------------------------------------------
  3942: 
100211: NS_IMPL_ISUPPORTS3(nsOfflineCacheUpdate,
 56242:                    nsIOfflineCacheUpdateObserver,
100211:                    nsIOfflineCacheUpdate,
100211:                    nsIRunnable)
  3942: 
  3942: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdate <public>
  3942: //-----------------------------------------------------------------------------
  3942: 
  3942: nsOfflineCacheUpdate::nsOfflineCacheUpdate()
  3942:     : mState(STATE_UNINITIALIZED)
106838:     , mOwner(nullptr)
 80486:     , mAddedItems(false)
 80486:     , mPartialUpdate(false)
 80486:     , mSucceeded(true)
 80486:     , mObsolete(false)
100211:     , mItemsInProgress(0)
 21365:     , mRescheduleCount(0)
 94502:     , mPinnedEntryRetriesCount(0)
 94502:     , mPinned(false)
  3942: {
  3942: }
  3942: 
  3942: nsOfflineCacheUpdate::~nsOfflineCacheUpdate()
  3942: {
  3942:     LOG(("nsOfflineCacheUpdate::~nsOfflineCacheUpdate [%p]", this));
  3942: }
  3942: 
 18430: /* static */
 18430: nsresult
 18430: nsOfflineCacheUpdate::GetCacheKey(nsIURI *aURI, nsACString &aKey)
 18430: {
 18430:     aKey.Truncate();
 18430: 
 18430:     nsCOMPtr<nsIURI> newURI;
 70215:     nsresult rv = aURI->CloneIgnoringRef(getter_AddRefs(newURI));
 18430:     NS_ENSURE_SUCCESS(rv, rv);
 18430: 
 18430:     rv = newURI->GetAsciiSpec(aKey);
 18430:     NS_ENSURE_SUCCESS(rv, rv);
 18430: 
 18430:     return NS_OK;
 18430: }
 18430: 
  3942: nsresult
 18488: nsOfflineCacheUpdate::Init(nsIURI *aManifestURI,
 56242:                            nsIURI *aDocumentURI,
100212:                            nsIDOMDocument *aDocument,
114905:                            nsIFile *aCustomProfileDir,
114905:                            nsILoadContext *aLoadContext)
  3942: {
  3942:     nsresult rv;
  3942: 
  3942:     // Make sure the service has been initialized
  7705:     nsOfflineCacheUpdateService* service =
  7705:         nsOfflineCacheUpdateService::EnsureService();
  7705:     if (!service)
  3942:         return NS_ERROR_FAILURE;
  3942: 
 18488:     LOG(("nsOfflineCacheUpdate::Init [%p]", this));
  3942: 
 80486:     mPartialUpdate = false;
 10340: 
 10340:     // Only http and https applications are supported.
 79445:     bool match;
 10340:     rv = aManifestURI->SchemeIs("http", &match);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 10340:     if (!match) {
 10340:         rv = aManifestURI->SchemeIs("https", &match);
 10340:         NS_ENSURE_SUCCESS(rv, rv);
 10340:         if (!match)
 10340:             return NS_ERROR_ABORT;
 10340:     }
 10340: 
 10340:     mManifestURI = aManifestURI;
 10340: 
 10564:     rv = mManifestURI->GetAsciiHost(mUpdateDomain);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
114905:     nsCOMPtr<nsIApplicationCacheService> cacheService =
114905:         do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID, &rv);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 10340:     mDocumentURI = aDocumentURI;
  3942: 
114905:     if (aCustomProfileDir) {
114905:         rv = GetCacheKey(aManifestURI, mGroupID);
  3942:         NS_ENSURE_SUCCESS(rv, rv);
  3942: 
100212:         // Create only a new offline application cache in the custom profile
100212:         // This is a preload of a new cache.
100212: 
100212:         // XXX Custom updates don't support "updating" of an existing cache
100212:         // in the custom profile at the moment.  This support can be, though,
100212:         // simply added as well when needed.
106838:         mPreviousApplicationCache = nullptr;
100212: 
114905:         rv = cacheService->CreateCustomApplicationCache(mGroupID,
100212:                                                         aCustomProfileDir,
100212:                                                         kCustomProfileQuota,
100212:                                                         getter_AddRefs(mApplicationCache));
100212:         NS_ENSURE_SUCCESS(rv, rv);
100212: 
100212:         mCustomProfileDir = aCustomProfileDir;
100212:     }
100212:     else {
114905:         rv = cacheService->BuildGroupID(aManifestURI,
114905:                                         aLoadContext,
114905:                                         mGroupID);
114905:         NS_ENSURE_SUCCESS(rv, rv);
114905: 
114905:         rv = cacheService->GetActiveCache(mGroupID,
 18430:                                           getter_AddRefs(mPreviousApplicationCache));
  3942:         NS_ENSURE_SUCCESS(rv, rv);
  3942: 
114905:         rv = cacheService->CreateApplicationCache(mGroupID,
 18430:                                                   getter_AddRefs(mApplicationCache));
 10340:         NS_ENSURE_SUCCESS(rv, rv);
100212:     }
  3942: 
 94502:     rv = nsOfflineCacheUpdateService::OfflineAppPinnedForURI(aDocumentURI,
 94502:                                                              NULL,
 94502:                                                              &mPinned);
 94502:     NS_ENSURE_SUCCESS(rv, rv);
 94502: 
114905:     mLoadContext = aLoadContext;
114905: 
  3942:     mState = STATE_INITIALIZED;
 18488:     return NS_OK;
 18488: }
  3942: 
 18488: nsresult
 18488: nsOfflineCacheUpdate::InitPartial(nsIURI *aManifestURI,
 18488:                                   const nsACString& clientID,
 18488:                                   nsIURI *aDocumentURI)
 18488: {
 18488:     nsresult rv;
 18488: 
 18488:     // Make sure the service has been initialized
 18488:     nsOfflineCacheUpdateService* service =
 18488:         nsOfflineCacheUpdateService::EnsureService();
 18488:     if (!service)
 18488:         return NS_ERROR_FAILURE;
 18488: 
 18488:     LOG(("nsOfflineCacheUpdate::InitPartial [%p]", this));
 18488: 
 80486:     mPartialUpdate = true;
 18488:     mDocumentURI = aDocumentURI;
 18488: 
 18488:     mManifestURI = aManifestURI;
 18488:     rv = mManifestURI->GetAsciiHost(mUpdateDomain);
 18488:     NS_ENSURE_SUCCESS(rv, rv);
 18488: 
 18488:     nsCOMPtr<nsIApplicationCacheService> cacheService =
 18488:         do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID, &rv);
 18488:     NS_ENSURE_SUCCESS(rv, rv);
 18488: 
104271:     rv = cacheService->GetApplicationCache(clientID,
 18488:                                            getter_AddRefs(mApplicationCache));
 18488:     NS_ENSURE_SUCCESS(rv, rv);
 18488: 
 18488:     if (!mApplicationCache) {
110974:         nsAutoCString manifestSpec;
 18488:         rv = GetCacheKey(mManifestURI, manifestSpec);
 18488:         NS_ENSURE_SUCCESS(rv, rv);
 18488: 
 18488:         rv = cacheService->CreateApplicationCache
 18488:             (manifestSpec, getter_AddRefs(mApplicationCache));
 18488:         NS_ENSURE_SUCCESS(rv, rv);
 18488:     }
 18488: 
114905:     rv = mApplicationCache->GetManifestURI(getter_AddRefs(mManifestURI));
114905:     NS_ENSURE_SUCCESS(rv, rv);
114905: 
110974:     nsAutoCString groupID;
 18488:     rv = mApplicationCache->GetGroupID(groupID);
 18488:     NS_ENSURE_SUCCESS(rv, rv);
 18488: 
 94502:     rv = nsOfflineCacheUpdateService::OfflineAppPinnedForURI(aDocumentURI,
 94502:                                                              NULL,
 94502:                                                              &mPinned);
 94502:     NS_ENSURE_SUCCESS(rv, rv);
 94502: 
 18488:     mState = STATE_INITIALIZED;
  3942:     return NS_OK;
  3942: }
  3942: 
 10340: nsresult
 79445: nsOfflineCacheUpdate::HandleManifest(bool *aDoUpdate)
 10340: {
 10340:     // Be pessimistic
 80486:     *aDoUpdate = false;
 10340: 
 79445:     bool succeeded;
 25596:     nsresult rv = mManifestItem->GetRequestSucceeded(&succeeded);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 25596:     if (!succeeded || !mManifestItem->ParseSucceeded()) {
 10340:         return NS_ERROR_FAILURE;
 10340:     }
 10340: 
 10340:     if (!mManifestItem->NeedsUpdate()) {
 10340:         return NS_OK;
 10340:     }
 10340: 
 10340:     // Add items requested by the manifest.
 10340:     const nsCOMArray<nsIURI> &manifestURIs = mManifestItem->GetExplicitURIs();
108991:     for (int32_t i = 0; i < manifestURIs.Count(); i++) {
 18430:         rv = AddURI(manifestURIs[i], nsIApplicationCache::ITEM_EXPLICIT);
 10340:         NS_ENSURE_SUCCESS(rv, rv);
 10340:     }
 10340: 
 19925:     const nsCOMArray<nsIURI> &fallbackURIs = mManifestItem->GetFallbackURIs();
108991:     for (int32_t i = 0; i < fallbackURIs.Count(); i++) {
 19925:         rv = AddURI(fallbackURIs[i], nsIApplicationCache::ITEM_FALLBACK);
 19925:         NS_ENSURE_SUCCESS(rv, rv);
 19925:     }
 19925: 
 10340:     // The document that requested the manifest is implicitly included
 10340:     // as part of that manifest update.
 18430:     rv = AddURI(mDocumentURI, nsIApplicationCache::ITEM_IMPLICIT);
 18430:     NS_ENSURE_SUCCESS(rv, rv);
 18430: 
 18430:     // Add items previously cached implicitly
 18430:     rv = AddExistingItems(nsIApplicationCache::ITEM_IMPLICIT);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 10340:     // Add items requested by the script API
 18430:     rv = AddExistingItems(nsIApplicationCache::ITEM_DYNAMIC);
 10340:     NS_ENSURE_SUCCESS(rv, rv);
 10340: 
 19925:     // Add opportunistically cached items conforming current opportunistic
 19925:     // namespace list
 19925:     rv = AddExistingItems(nsIApplicationCache::ITEM_OPPORTUNISTIC,
 19925:                           &mManifestItem->GetOpportunisticNamespaces());
 19925:     NS_ENSURE_SUCCESS(rv, rv);
 19925: 
 80486:     *aDoUpdate = true;
 10340: 
 10340:     return NS_OK;
 10340: }
 10340: 
  3942: void
100211: nsOfflineCacheUpdate::LoadCompleted(nsOfflineCacheUpdateItem *aItem)
  3942: {
  3942:     nsresult rv;
  3942: 
100211:     LOG(("nsOfflineCacheUpdate::LoadCompleted [%p]", this));
100211: 
100211:     if (mState == STATE_FINISHED) {
100211:         LOG(("  after completion, ignoring"));
100211:         return;
100211:     }
100211: 
 27297:     // Keep the object alive through a Finish() call.
 27297:     nsCOMPtr<nsIOfflineCacheUpdate> kungFuDeathGrip(this);
 27297: 
 10340:     if (mState == STATE_CANCELLED) {
 10340:         Finish();
 10340:         return;
 10340:     }
 10340: 
 10340:     if (mState == STATE_CHECKING) {
 10340:         // Manifest load finished.
 10340: 
 10340:         NS_ASSERTION(mManifestItem,
 10340:                      "Must have a manifest item in STATE_CHECKING.");
100211:         NS_ASSERTION(mManifestItem == aItem,
100211:                      "Unexpected aItem in nsOfflineCacheUpdate::LoadCompleted");
 10340: 
 21313:         // A 404 or 410 is interpreted as an intentional removal of
 21313:         // the manifest file, rather than a transient server error.
 21313:         // Obsolete this cache group if one of these is returned.
108991:         uint16_t status;
 21313:         rv = mManifestItem->GetStatus(&status);
 21313:         if (status == 404 || status == 410) {
 80486:             mSucceeded = false;
 94502:             if (mPreviousApplicationCache) {
 94502:                 if (mPinned) {
 94502:                     // Do not obsolete a pinned application.
 94502:                     NotifyState(nsIOfflineCacheUpdateObserver::STATE_NOUPDATE);
 94502:                 } else {
 94502:                     NotifyState(nsIOfflineCacheUpdateObserver::STATE_OBSOLETE);
 80486:                     mObsolete = true;
 94502:                 }
 24810:             } else {
 56242:                 NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 94502:                 mObsolete = true;
 24810:             }
 21313:             Finish();
 21313:             return;
 21313:         }
 21313: 
 79445:         bool doUpdate;
 10340:         if (NS_FAILED(HandleManifest(&doUpdate))) {
 80486:             mSucceeded = false;
 56242:             NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 10340:             Finish();
 10340:             return;
 10340:         }
 10340: 
 10340:         if (!doUpdate) {
 80486:             mSucceeded = false;
 25377: 
 56242:             AssociateDocuments(mPreviousApplicationCache);
 25377: 
 25377:             ScheduleImplicit();
 25377: 
 25377:             // If we didn't need an implicit update, we can
 25377:             // send noupdate and end the update now.
 25377:             if (!mImplicitUpdate) {
 56242:                 NotifyState(nsIOfflineCacheUpdateObserver::STATE_NOUPDATE);
 10340:                 Finish();
 25377:             }
 10340:             return;
 10340:         }
 10340: 
 18430:         rv = mApplicationCache->MarkEntry(mManifestItem->mCacheKey,
 18430:                                           mManifestItem->mItemType);
 18430:         if (NS_FAILED(rv)) {
 80486:             mSucceeded = false;
 56242:             NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 18430:             Finish();
 18430:             return;
 18430:         }
 18430: 
 10340:         mState = STATE_DOWNLOADING;
 56242:         NotifyState(nsIOfflineCacheUpdateObserver::STATE_DOWNLOADING);
 10340: 
 10340:         // Start fetching resources.
 10340:         ProcessNextURI();
 10340: 
 10340:         return;
 10340:     }
 10340: 
 10340:     // Normal load finished.
100211:     if (mItemsInProgress) // Just to be safe here!
100211:       --mItemsInProgress;
  3942: 
 79445:     bool succeeded;
100211:     rv = aItem->GetRequestSucceeded(&succeeded);
 25596: 
100211:     if (mPinned && NS_SUCCEEDED(rv) && succeeded) {
108991:         uint32_t dummy_cache_type;
100211:         rv = mApplicationCache->GetTypes(aItem->mCacheKey, &dummy_cache_type);
 94502:         bool item_doomed = NS_FAILED(rv); // can not find it? -> doomed
 94502: 
 94502:         if (item_doomed &&
 94502:             mPinnedEntryRetriesCount < kPinnedEntryRetriesLimit &&
100211:             (aItem->mItemType & (nsIApplicationCache::ITEM_EXPLICIT |
 94502:                                  nsIApplicationCache::ITEM_FALLBACK))) {
 94551:             rv = EvictOneNonPinned();
 94551:             if (NS_FAILED(rv)) {
 94551:                 mSucceeded = false;
 94551:                 NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 94551:                 Finish();
 94551:                 return;
 94502:             }
 94502: 
100211:             // This reverts the item state to UNINITIALIZED that makes it to
100211:             // be scheduled for download again.
100211:             rv = aItem->Cancel();
 94551:             if (NS_FAILED(rv)) {
 94551:                 mSucceeded = false;
 94551:                 NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 94551:                 Finish();
 94551:                 return;
 94551:             }
 94551: 
 94551:             mPinnedEntryRetriesCount++;
100211: 
100211:             // Retry this item.
 94551:             ProcessNextURI();
 94551:             return;
 94502:         }
 94502:     }
 94502: 
100211:     // According to parallelism this may imply more pinned retries count,
100211:     // but that is not critical, since at one moment the algoritm will
100211:     // stop anyway.  Also, this code may soon be completely removed
100211:     // after we have a separate storage for pinned apps.
 94502:     mPinnedEntryRetriesCount = 0;
 94502: 
 25596:     // Check for failures.  3XX, 4XX and 5XX errors on items explicitly
 20650:     // listed in the manifest will cause the update to fail.
 25596:     if (NS_FAILED(rv) || !succeeded) {
100211:         if (aItem->mItemType &
 20650:             (nsIApplicationCache::ITEM_EXPLICIT |
 20650:              nsIApplicationCache::ITEM_FALLBACK)) {
 80486:             mSucceeded = false;
  3947:         }
 20650:     } else {
100211:         rv = mApplicationCache->MarkEntry(aItem->mCacheKey, aItem->mItemType);
 18430:         if (NS_FAILED(rv)) {
 80486:             mSucceeded = false;
 20650:         }
 20650:     }
 20650: 
 20650:     if (!mSucceeded) {
 56242:         NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 18430:         Finish();
 18430:         return;
 18430:     }
 18430: 
110983:     NotifyState(nsIOfflineCacheUpdateObserver::STATE_ITEMCOMPLETED);
  3942: 
  3942:     ProcessNextURI();
  3942: }
  3942: 
 21365: void
 21365: nsOfflineCacheUpdate::ManifestCheckCompleted(nsresult aStatus,
 21365:                                              const nsCString &aManifestHash)
 21365: {
 27297:     // Keep the object alive through a Finish() call.
 27297:     nsCOMPtr<nsIOfflineCacheUpdate> kungFuDeathGrip(this);
 27297: 
 21365:     if (NS_SUCCEEDED(aStatus)) {
110974:         nsAutoCString firstManifestHash;
 21365:         mManifestItem->GetManifestHash(firstManifestHash);
 21365:         if (aManifestHash != firstManifestHash) {
 56242:             LOG(("Manifest has changed during cache items download [%p]", this));
 21365:             aStatus = NS_ERROR_FAILURE;
 21365:         }
 21365:     }
 21365: 
 21365:     if (NS_FAILED(aStatus)) {
 80486:         mSucceeded = false;
 56242:         NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 21365:     }
 21365: 
 56242:     if (NS_FAILED(aStatus) && mRescheduleCount < kRescheduleLimit) {
 56242:         // Do the final stuff but prevent notification of STATE_FINISHED.
 56242:         // That would disconnect listeners that are responsible for document
 56242:         // association after a successful update. Forwarding notifications
 56242:         // from a new update through this dead update to them is absolutely
 56242:         // correct.
 56242:         FinishNoNotify();
 21365: 
 21365:         nsRefPtr<nsOfflineCacheUpdate> newUpdate =
 21365:             new nsOfflineCacheUpdate();
 56242:         // Leave aDocument argument null. Only glues and children keep
 56242:         // document instances.
114905:         newUpdate->Init(mManifestURI, mDocumentURI, nullptr,
114905:                         mCustomProfileDir, mLoadContext);
 21365: 
 56242:         // In a rare case the manifest will not be modified on the next refetch
 56242:         // transfer all master document URIs to the new update to ensure that
 56242:         // all documents refering it will be properly cached.
108991:         for (int32_t i = 0; i < mDocumentURIs.Count(); i++) {
 56242:             newUpdate->StickDocument(mDocumentURIs[i]);
 21365:         }
 21365: 
 21365:         newUpdate->mRescheduleCount = mRescheduleCount + 1;
 80486:         newUpdate->AddObserver(this, false);
 21365:         newUpdate->Schedule();
 21365:     }
 56242:     else {
 56242:         Finish();
 56242:     }
 21365: }
 21365: 
  3942: nsresult
  3942: nsOfflineCacheUpdate::Begin()
  3942: {
  3942:     LOG(("nsOfflineCacheUpdate::Begin [%p]", this));
  3942: 
 27297:     // Keep the object alive through a ProcessNextURI()/Finish() call.
 27297:     nsCOMPtr<nsIOfflineCacheUpdate> kungFuDeathGrip(this);
 27297: 
100211:     mItemsInProgress = 0;
 10340: 
 10340:     if (mPartialUpdate) {
 10340:         mState = STATE_DOWNLOADING;
 56242:         NotifyState(nsIOfflineCacheUpdateObserver::STATE_DOWNLOADING);
 10340:         ProcessNextURI();
 10340:         return NS_OK;
  3942:     }
  3942: 
 10340:     // Start checking the manifest.
 10340:     nsCOMPtr<nsIURI> uri;
  3942: 
100211:     mManifestItem = new nsOfflineManifestItem(mManifestURI,
 18430:                                               mDocumentURI,
100212:                                               mApplicationCache,
104271:                                               mPreviousApplicationCache);
 10340:     if (!mManifestItem) {
 10340:         return NS_ERROR_OUT_OF_MEMORY;
 10340:     }
 10340: 
 10340:     mState = STATE_CHECKING;
 99119:     mByteProgress = 0;
 56242:     NotifyState(nsIOfflineCacheUpdateObserver::STATE_CHECKING);
 10340: 
100211:     nsresult rv = mManifestItem->OpenChannel(this);
 10340:     if (NS_FAILED(rv)) {
100211:         LoadCompleted(mManifestItem);
 10340:     }
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: nsresult
  3942: nsOfflineCacheUpdate::Cancel()
  3942: {
  3942:     LOG(("nsOfflineCacheUpdate::Cancel [%p]", this));
  3942: 
  3942:     mState = STATE_CANCELLED;
 80486:     mSucceeded = false;
  3942: 
100211:     // Cancel all running downloads
108991:     for (uint32_t i = 0; i < mItems.Length(); ++i) {
100211:         nsOfflineCacheUpdateItem * item = mItems[i];
100211: 
100211:         if (item->IsInProgress())
100211:             item->Cancel();
  3942:     }
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdate <private>
  3942: //-----------------------------------------------------------------------------
  3942: 
  3942: nsresult
108991: nsOfflineCacheUpdate::AddExistingItems(uint32_t aType,
 19925:                                        nsTArray<nsCString>* namespaceFilter)
  3942: {
 18430:     if (!mPreviousApplicationCache) {
 18430:         return NS_OK;
 18430:     }
 18430: 
 19925:     if (namespaceFilter && namespaceFilter->Length() == 0) {
 19925:         // Don't bother to walk entries when there are no namespaces
 19925:         // defined.
 19925:         return NS_OK;
 19925:     }
 19925: 
108991:     uint32_t count = 0;
106838:     char **keys = nullptr;
 18430:     nsresult rv = mPreviousApplicationCache->GatherEntries(aType,
  3942:                                                            &count, &keys);
  3942:     NS_ENSURE_SUCCESS(rv, rv);
  3942: 
  3942:     AutoFreeArray autoFree(count, keys);
  3942: 
108991:     for (uint32_t i = 0; i < count; i++) {
 19925:         if (namespaceFilter) {
 79445:             bool found = false;
108991:             for (uint32_t j = 0; j < namespaceFilter->Length() && !found; j++) {
 19925:                 found = StringBeginsWith(nsDependentCString(keys[i]),
 19925:                                          namespaceFilter->ElementAt(j));
 19925:             }
 19925: 
 19925:             if (!found)
 19925:                 continue;
 19925:         }
 19925: 
  3942:         nsCOMPtr<nsIURI> uri;
  3942:         if (NS_SUCCEEDED(NS_NewURI(getter_AddRefs(uri), keys[i]))) {
 18430:             rv = AddURI(uri, aType);
 18430:             NS_ENSURE_SUCCESS(rv, rv);
  3942:         }
  3942:     }
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: nsresult
  3942: nsOfflineCacheUpdate::ProcessNextURI()
  3942: {
 27297:     // Keep the object alive through a Finish() call.
 27297:     nsCOMPtr<nsIOfflineCacheUpdate> kungFuDeathGrip(this);
 27297: 
100211:     LOG(("nsOfflineCacheUpdate::ProcessNextURI [%p, inprogress=%d, numItems=%d]",
100211:          this, mItemsInProgress, mItems.Length()));
  3942: 
 10340:     NS_ASSERTION(mState == STATE_DOWNLOADING,
 10340:                  "ProcessNextURI should only be called from the DOWNLOADING state");
 10340: 
119707:     if (mState != STATE_DOWNLOADING) {
119707:         LOG(("  should only be called from the DOWNLOADING state, ignoring"));
119707:         return NS_ERROR_UNEXPECTED;
119707:     }
119707: 
106838:     nsOfflineCacheUpdateItem * runItem = nullptr;
108991:     uint32_t completedItems = 0;
108991:     for (uint32_t i = 0; i < mItems.Length(); ++i) {
100211:         nsOfflineCacheUpdateItem * item = mItems[i];
100211: 
100211:         if (item->IsScheduled()) {
100211:             runItem = item;
100211:             break;
100211:         }
100211: 
100211:         if (item->IsCompleted())
100211:             ++completedItems;
100211:     }
100211: 
100211:     if (completedItems == mItems.Length()) {
100211:         LOG(("nsOfflineCacheUpdate::ProcessNextURI [%p]: all items loaded", this));
100211: 
 21365:         if (mPartialUpdate) {
  3942:             return Finish();
 21365:         } else {
 21365:             // Verify that the manifest wasn't changed during the
 21365:             // update, to prevent capturing a cache while the server
 21365:             // is being updated.  The check will call
 21365:             // ManifestCheckCompleted() when it's done.
 21365:             nsRefPtr<nsManifestCheck> manifestCheck =
 21365:                 new nsManifestCheck(this, mManifestURI, mDocumentURI);
 21365:             if (NS_FAILED(manifestCheck->Begin())) {
 80486:                 mSucceeded = false;
 56242:                 NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 21365:                 return Finish();
 21365:             }
 21365: 
 21365:             return NS_OK;
 21365:         }
  3942:     }
  3942: 
100211:     if (!runItem) {
100211:         LOG(("nsOfflineCacheUpdate::ProcessNextURI [%p]:"
100211:              " No more items to include in parallel load", this));
100211:         return NS_OK;
100211:     }
100211: 
  3942: #if defined(PR_LOGGING)
  3942:     if (LOG_ENABLED()) {
110974:         nsAutoCString spec;
100211:         runItem->mURI->GetSpec(spec);
  3942:         LOG(("%p: Opening channel for %s", this, spec.get()));
  3942:     }
  3942: #endif
  3942: 
100211:     ++mItemsInProgress;
 56242:     NotifyState(nsIOfflineCacheUpdateObserver::STATE_ITEMSTARTED);
 10340: 
100211:     nsresult rv = runItem->OpenChannel(this);
  3942:     if (NS_FAILED(rv)) {
100211:         LoadCompleted(runItem);
  3942:         return rv;
  3942:     }
  3942: 
100211:     if (mItemsInProgress >= kParallelLoadLimit) {
100211:         LOG(("nsOfflineCacheUpdate::ProcessNextURI [%p]:"
100211:              " At parallel load limit", this));
  3942:         return NS_OK;
  3942:     }
  3942: 
100211:     // This calls this method again via a post triggering
100211:     // a parallel item load
100211:     return NS_DispatchToCurrentThread(this);
100211: }
100211: 
110983: void
 10340: nsOfflineCacheUpdate::GatherObservers(nsCOMArray<nsIOfflineCacheUpdateObserver> &aObservers)
  3942: {
108991:     for (int32_t i = 0; i < mWeakObservers.Count(); i++) {
  3942:         nsCOMPtr<nsIOfflineCacheUpdateObserver> observer =
  3942:             do_QueryReferent(mWeakObservers[i]);
  3942:         if (observer)
 10340:             aObservers.AppendObject(observer);
  3942:         else
  3942:             mWeakObservers.RemoveObjectAt(i--);
  3942:     }
  3942: 
108991:     for (int32_t i = 0; i < mObservers.Count(); i++) {
 10340:         aObservers.AppendObject(mObservers[i]);
  3942:     }
 10340: }
 10340: 
110983: void
108991: nsOfflineCacheUpdate::NotifyState(uint32_t state)
 10340: {
 56242:     LOG(("nsOfflineCacheUpdate::NotifyState [%p, %d]", this, state));
 18430: 
 10340:     nsCOMArray<nsIOfflineCacheUpdateObserver> observers;
110983:     GatherObservers(observers);
 10340: 
108991:     for (int32_t i = 0; i < observers.Count(); i++) {
 56242:         observers[i]->UpdateStateChanged(this, state);
 10340:     }
 10340: }
 10340: 
110983: void
 56242: nsOfflineCacheUpdate::AssociateDocuments(nsIApplicationCache* cache)
 10340: {
 10340:     nsCOMArray<nsIOfflineCacheUpdateObserver> observers;
110983:     GatherObservers(observers);
 10340: 
108991:     for (int32_t i = 0; i < observers.Count(); i++) {
 56242:         observers[i]->ApplicationCacheAvailable(cache);
  3942:     }
  3942: }
  3942: 
 21367: void
 56242: nsOfflineCacheUpdate::StickDocument(nsIURI *aDocumentURI)
 21367: {
 56242:     if (!aDocumentURI)
 21367:       return;
 21367: 
 56242:     mDocumentURIs.AppendObject(aDocumentURI);
 21367: }
 21367: 
 25377: void
 25377: nsOfflineCacheUpdate::SetOwner(nsOfflineCacheUpdateOwner *aOwner)
 25377: {
 25377:     NS_ASSERTION(!mOwner, "Tried to set cache update owner twice.");
 25377:     mOwner = aOwner;
 25377: }
 25377: 
114905: bool
114905: nsOfflineCacheUpdate::IsForGroupID(const nsCSubstring &groupID)
114905: {
114905:     return mGroupID == groupID;
114905: }
114905: 
 25377: nsresult
 25377: nsOfflineCacheUpdate::UpdateFinished(nsOfflineCacheUpdate *aUpdate)
 25377: {
 27297:     // Keep the object alive through a Finish() call.
 27297:     nsCOMPtr<nsIOfflineCacheUpdate> kungFuDeathGrip(this);
 27297: 
106838:     mImplicitUpdate = nullptr;
 25377: 
 56242:     NotifyState(nsIOfflineCacheUpdateObserver::STATE_NOUPDATE);
 25377:     Finish();
 25377: 
 25377:     return NS_OK;
 25377: }
 25377: 
 99119: void
108991: nsOfflineCacheUpdate::OnByteProgress(uint64_t byteIncrement)
 99119: {
 99119:     mByteProgress += byteIncrement;
 99119:     NotifyState(nsIOfflineCacheUpdateObserver::STATE_ITEMPROGRESS);
 99119: }
 99119: 
 21367: nsresult
 21367: nsOfflineCacheUpdate::ScheduleImplicit()
 21367: {
 56242:     if (mDocumentURIs.Count() == 0)
 21367:         return NS_OK;
 21367: 
 21367:     nsresult rv;
 21367: 
 21367:     nsRefPtr<nsOfflineCacheUpdate> update = new nsOfflineCacheUpdate();
 21367:     NS_ENSURE_TRUE(update, NS_ERROR_OUT_OF_MEMORY);
 21367: 
110974:     nsAutoCString clientID;
 21367:     if (mPreviousApplicationCache) {
 21367:         rv = mPreviousApplicationCache->GetClientID(clientID);
 21367:         NS_ENSURE_SUCCESS(rv, rv);
 21367:     }
104271:     else if (mApplicationCache) {
104271:         rv = mApplicationCache->GetClientID(clientID);
104271:         NS_ENSURE_SUCCESS(rv, rv);
104271:     }
 21367:     else {
104271:         NS_ERROR("Offline cache update not having set mApplicationCache?");
 21367:     }
 21367: 
 21367:     rv = update->InitPartial(mManifestURI, clientID, mDocumentURI);
 21367:     NS_ENSURE_SUCCESS(rv, rv);
 21367: 
108991:     for (int32_t i = 0; i < mDocumentURIs.Count(); i++) {
 56242:         rv = update->AddURI(mDocumentURIs[i],
 56242:               nsIApplicationCache::ITEM_IMPLICIT);
 21367:         NS_ENSURE_SUCCESS(rv, rv);
 21367:     }
 21367: 
 25377:     update->SetOwner(this);
 25377:     rv = update->Begin();
 21367:     NS_ENSURE_SUCCESS(rv, rv);
 21367: 
 25377:     mImplicitUpdate = update;
 25377: 
 21367:     return NS_OK;
 21367: }
 21367: 
  3942: nsresult
 56242: nsOfflineCacheUpdate::FinishNoNotify()
  3942: {
  3942:     LOG(("nsOfflineCacheUpdate::Finish [%p]", this));
  3942: 
  3942:     mState = STATE_FINISHED;
  3942: 
  3947:     if (!mPartialUpdate) {
  3947:         if (mSucceeded) {
 19925:             nsIArray *namespaces = mManifestItem->GetNamespaces();
 19925:             nsresult rv = mApplicationCache->AddNamespaces(namespaces);
 19925:             if (NS_FAILED(rv)) {
 56242:                 NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 80486:                 mSucceeded = false;
 19925:             }
 19925: 
 19925:             rv = mApplicationCache->Activate();
 10340:             if (NS_FAILED(rv)) {
 56242:                 NotifyState(nsIOfflineCacheUpdateObserver::STATE_ERROR);
 80486:                 mSucceeded = false;
  3947:             }
 21312: 
 56242:             AssociateDocuments(mApplicationCache);
 10340:         }
  3947: 
 21313:         if (mObsolete) {
 21313:             nsCOMPtr<nsIApplicationCacheService> appCacheService =
 21313:                 do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
 21313:             if (appCacheService) {
110974:                 nsAutoCString groupID;
 21313:                 mApplicationCache->GetGroupID(groupID);
 21313:                 appCacheService->DeactivateGroup(groupID);
 21313:              }
 21313:         }
 21313: 
  3947:         if (!mSucceeded) {
  3947:             // Update was not merged, mark all the loads as failures
108991:             for (uint32_t i = 0; i < mItems.Length(); i++) {
  3947:                 mItems[i]->Cancel();
  3947:             }
 18430: 
 18430:             mApplicationCache->Discard();
  3947:         }
  3947:     }
  3947: 
 25377:     nsresult rv = NS_OK;
 25377: 
 25377:     if (mOwner) {
 25377:         rv = mOwner->UpdateFinished(this);
106838:         mOwner = nullptr;
 25377:     }
 25377: 
 25377:     return rv;
  3942: }
  3942: 
 56242: nsresult
 56242: nsOfflineCacheUpdate::Finish()
 56242: {
 56242:     nsresult rv = FinishNoNotify();
 56242: 
 56242:     NotifyState(nsIOfflineCacheUpdateObserver::STATE_FINISHED);
 56242: 
 56242:     return rv;
 56242: }
 56242: 
 94502: static nsresult
 94502: EvictOneOfCacheGroups(nsIApplicationCacheService *cacheService,
108991:                       uint32_t count, const char * const *groups)
 94502: {
 94502:     nsresult rv;
 94502:     unsigned int i;
 94502: 
 94502:     for (i = 0; i < count; i++) {
 94502:         nsCOMPtr<nsIURI> uri;
 94502:         rv = NS_NewURI(getter_AddRefs(uri), groups[i]);
 94502:         NS_ENSURE_SUCCESS(rv, rv);
 94502: 
 94502:         nsDependentCString group_name(groups[i]);
 94502:         nsCOMPtr<nsIApplicationCache> cache;
 94502:         rv = cacheService->GetActiveCache(group_name, getter_AddRefs(cache));
 94502:         // Maybe someone in another thread or process have deleted it.
 94502:         if (NS_FAILED(rv) || !cache)
 94502:             continue;
 94502: 
 94502:         bool pinned;
 94502:         rv = nsOfflineCacheUpdateService::OfflineAppPinnedForURI(uri,
 94502:                                                                  NULL,
 94502:                                                                  &pinned);
 94502:         NS_ENSURE_SUCCESS(rv, rv);
 94502: 
 94502:         if (!pinned) {
 94551:             rv = cache->Discard();
 94502:             return NS_OK;
 94502:         }
 94502:     }
 94502: 
 94502:     return NS_ERROR_FILE_NOT_FOUND;
 94502: }
 94502: 
 94502: nsresult
 94551: nsOfflineCacheUpdate::EvictOneNonPinned()
 94502: {
 94502:     nsresult rv;
 94502: 
 94502:     nsCOMPtr<nsIApplicationCacheService> cacheService =
 94502:         do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID, &rv);
 94502:     NS_ENSURE_SUCCESS(rv, rv);
 94502: 
108991:     uint32_t count;
 94502:     char **groups;
 94502:     rv = cacheService->GetGroupsTimeOrdered(&count, &groups);
 94502:     NS_ENSURE_SUCCESS(rv, rv);
 94502: 
 94551:     rv = EvictOneOfCacheGroups(cacheService, count, groups);
 94502: 
 94502:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(count, groups);
 94502:     return rv;
 94502: }
 94502: 
  3942: //-----------------------------------------------------------------------------
  3942: // nsOfflineCacheUpdate::nsIOfflineCacheUpdate
  3942: //-----------------------------------------------------------------------------
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdate::GetUpdateDomain(nsACString &aUpdateDomain)
  3942: {
  3942:     NS_ENSURE_TRUE(mState >= STATE_INITIALIZED, NS_ERROR_NOT_INITIALIZED);
  3942: 
  3942:     aUpdateDomain = mUpdateDomain;
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
108991: nsOfflineCacheUpdate::GetStatus(uint16_t *aStatus)
  3942: {
 10340:     switch (mState) {
 10340:     case STATE_CHECKING :
 15074:         *aStatus = nsIDOMOfflineResourceList::CHECKING;
 15074:         return NS_OK;
 10340:     case STATE_DOWNLOADING :
 15074:         *aStatus = nsIDOMOfflineResourceList::DOWNLOADING;
 15074:         return NS_OK;
 10340:     default :
 15074:         *aStatus = nsIDOMOfflineResourceList::IDLE;
 15074:         return NS_OK;
 10340:     }
  3942: 
 10340:     return NS_ERROR_FAILURE;
 10340: }
 10340: 
 10340: NS_IMETHODIMP
 79445: nsOfflineCacheUpdate::GetPartial(bool *aPartial)
 10340: {
 10340:     *aPartial = mPartialUpdate;
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
 10340: nsOfflineCacheUpdate::GetManifestURI(nsIURI **aManifestURI)
  3942: {
  3942:     NS_ENSURE_TRUE(mState >= STATE_INITIALIZED, NS_ERROR_NOT_INITIALIZED);
  3942: 
 10340:     NS_IF_ADDREF(*aManifestURI = mManifestURI);
 10340:     return NS_OK;
 10340: }
 10340: 
 10340: NS_IMETHODIMP
 79445: nsOfflineCacheUpdate::GetSucceeded(bool *aSucceeded)
 10340: {
 10340:     NS_ENSURE_TRUE(mState == STATE_FINISHED, NS_ERROR_NOT_AVAILABLE);
 10340: 
 10340:     *aSucceeded = mSucceeded;
 10340: 
 10340:     return NS_OK;
 10340: }
 10340: 
 18430: NS_IMETHODIMP
 79445: nsOfflineCacheUpdate::GetIsUpgrade(bool *aIsUpgrade)
 18430: {
 18430:     NS_ENSURE_TRUE(mState >= STATE_INITIALIZED, NS_ERROR_NOT_INITIALIZED);
 18430: 
106838:     *aIsUpgrade = (mPreviousApplicationCache != nullptr);
 18430: 
 18430:     return NS_OK;
 18430: }
 18430: 
 10340: nsresult
108991: nsOfflineCacheUpdate::AddURI(nsIURI *aURI, uint32_t aType)
 10340: {
 10340:     NS_ENSURE_TRUE(mState >= STATE_INITIALIZED, NS_ERROR_NOT_INITIALIZED);
 10340: 
 10340:     if (mState >= STATE_DOWNLOADING)
  3942:         return NS_ERROR_NOT_AVAILABLE;
  3942: 
 18430:     // Resource URIs must have the same scheme as the manifest.
110974:     nsAutoCString scheme;
 10340:     aURI->GetScheme(scheme);
 10340: 
 79445:     bool match;
 10340:     if (NS_FAILED(mManifestURI->SchemeIs(scheme.get(), &match)) || !match)
 10340:         return NS_ERROR_FAILURE;
  3942: 
 10340:     // Don't fetch the same URI twice.
108991:     for (uint32_t i = 0; i < mItems.Length(); i++) {
 79445:         bool equals;
 10340:         if (NS_SUCCEEDED(mItems[i]->mURI->Equals(aURI, &equals)) && equals) {
 18430:             // retain both types.
 18430:             mItems[i]->mItemType |= aType;
 10340:             return NS_OK;
 10340:         }
 10340:     }
 10340: 
  3942:     nsRefPtr<nsOfflineCacheUpdateItem> item =
100212:         new nsOfflineCacheUpdateItem(aURI, 
100212:                                      mDocumentURI,
100212:                                      mApplicationCache,
100212:                                      mPreviousApplicationCache, 
 18430:                                      aType);
  3942:     if (!item) return NS_ERROR_OUT_OF_MEMORY;
  3942: 
  3942:     mItems.AppendElement(item);
 80486:     mAddedItems = true;
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
 10340: nsOfflineCacheUpdate::AddDynamicURI(nsIURI *aURI)
 10340: {
 56242:     if (GeckoProcessType_Default != XRE_GetProcessType())
 56242:         return NS_ERROR_NOT_IMPLEMENTED;
 56242: 
 18430:     // If this is a partial update and the resource is already in the
 18430:     // cache, we should only mark the entry, not fetch it again.
 18430:     if (mPartialUpdate) {
110974:         nsAutoCString key;
 18430:         GetCacheKey(aURI, key);
 18430: 
108991:         uint32_t types;
 18430:         nsresult rv = mApplicationCache->GetTypes(key, &types);
 18430:         if (NS_SUCCEEDED(rv)) {
 18430:             if (!(types & nsIApplicationCache::ITEM_DYNAMIC)) {
 18430:                 mApplicationCache->MarkEntry
 18430:                     (key, nsIApplicationCache::ITEM_DYNAMIC);
 18430:             }
 18430:             return NS_OK;
 18430:         }
 18430:     }
 18430: 
 18430:     return AddURI(aURI, nsIApplicationCache::ITEM_DYNAMIC);
 10340: }
 10340: 
 10340: NS_IMETHODIMP
  3942: nsOfflineCacheUpdate::AddObserver(nsIOfflineCacheUpdateObserver *aObserver,
 79445:                                   bool aHoldWeak)
  3942: {
 56242:     LOG(("nsOfflineCacheUpdate::AddObserver [%p] to update [%p]", aObserver, this));
  3942: 
  3942:     NS_ENSURE_TRUE(mState >= STATE_INITIALIZED, NS_ERROR_NOT_INITIALIZED);
  3942: 
  3942:     if (aHoldWeak) {
  3942:         nsCOMPtr<nsIWeakReference> weakRef = do_GetWeakReference(aObserver);
  3942:         mWeakObservers.AppendObject(weakRef);
  3942:     } else {
  3942:         mObservers.AppendObject(aObserver);
  3942:     }
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdate::RemoveObserver(nsIOfflineCacheUpdateObserver *aObserver)
  3942: {
 56242:     LOG(("nsOfflineCacheUpdate::RemoveObserver [%p] from update [%p]", aObserver, this));
  3942: 
  3942:     NS_ENSURE_TRUE(mState >= STATE_INITIALIZED, NS_ERROR_NOT_INITIALIZED);
  3942: 
108991:     for (int32_t i = 0; i < mWeakObservers.Count(); i++) {
  3942:         nsCOMPtr<nsIOfflineCacheUpdateObserver> observer =
  3942:             do_QueryReferent(mWeakObservers[i]);
  3942:         if (observer == aObserver) {
  3942:             mWeakObservers.RemoveObjectAt(i);
  3942:             return NS_OK;
  3942:         }
  3942:     }
  3942: 
108991:     for (int32_t i = 0; i < mObservers.Count(); i++) {
  3942:         if (mObservers[i] == aObserver) {
  3942:             mObservers.RemoveObjectAt(i);
  3942:             return NS_OK;
  3942:         }
  3942:     }
  3942: 
  3942:     return NS_OK;
  3942: }
  3942: 
 99119: NS_IMETHODIMP
108991: nsOfflineCacheUpdate::GetByteProgress(uint64_t * _result)
 99119: {
 99119:     NS_ENSURE_ARG(_result);
 99119: 
 99119:     *_result = mByteProgress;
 99119:     return NS_OK;
 99119: }
  3942: 
  3942: NS_IMETHODIMP
  3942: nsOfflineCacheUpdate::Schedule()
  3942: {
  3942:     LOG(("nsOfflineCacheUpdate::Schedule [%p]", this));
  3942: 
  3942:     nsOfflineCacheUpdateService* service =
  7705:         nsOfflineCacheUpdateService::EnsureService();
  3942: 
  3942:     if (!service) {
  3942:         return NS_ERROR_FAILURE;
  3942:     }
  3942: 
 56242:     return service->ScheduleUpdate(this);
 25742: }
 25742: 
 25742: NS_IMETHODIMP
 56242: nsOfflineCacheUpdate::UpdateStateChanged(nsIOfflineCacheUpdate *aUpdate,
108991:                                          uint32_t aState)
 25742: {
 56242:     if (aState == nsIOfflineCacheUpdateObserver::STATE_FINISHED) {
 56242:         // Take the mSucceeded flag from the underlying update, we will be
 56242:         // queried for it soon. mSucceeded of this update is false (manifest
 56242:         // check failed) but the subsequent re-fetch update might succeed
 79445:         bool succeeded;
 56242:         aUpdate->GetSucceeded(&succeeded);
 56242:         mSucceeded = succeeded;
 25742:     }
 25742: 
110983:     NotifyState(aState);
 56242:     if (aState == nsIOfflineCacheUpdateObserver::STATE_FINISHED)
 56242:         aUpdate->RemoveObserver(this);
 25742: 
110983:     return NS_OK;
 25742: }
 25742: 
 25742: NS_IMETHODIMP
 56242: nsOfflineCacheUpdate::ApplicationCacheAvailable(nsIApplicationCache *applicationCache)
 25742: {
110983:     AssociateDocuments(applicationCache);
110983:     return NS_OK;
 25742: }
100211: 
100211: //-----------------------------------------------------------------------------
100211: // nsOfflineCacheUpdate::nsIRunable
100211: //-----------------------------------------------------------------------------
100211: 
100211: NS_IMETHODIMP
100211: nsOfflineCacheUpdate::Run()
100211: {
100211:     ProcessNextURI();
100211:     return NS_OK;
100211: }
