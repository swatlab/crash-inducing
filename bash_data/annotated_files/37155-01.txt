15272: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
15272: /* ***** BEGIN LICENSE BLOCK *****
15272:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
15272:  *
15272:  * The contents of this file are subject to the Mozilla Public License Version
15272:  * 1.1 (the "License"); you may not use this file except in compliance with
15272:  * the License. You may obtain a copy of the License at
15272:  * http://www.mozilla.org/MPL/
15272:  *
15272:  * Software distributed under the License is distributed on an "AS IS" basis,
15272:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
15272:  * for the specific language governing rights and limitations under the
15272:  * License.
15272:  *
15272:  * The Original Code is the Netscape Portable Runtime (NSPR).
15272:  *
15272:  * The Initial Developer of the Original Code is
15272:  * Netscape Communications Corporation.
15272:  * Portions created by the Initial Developer are Copyright (C) 1998-2000
15272:  * the Initial Developer. All Rights Reserved.
15272:  *
15272:  * Contributor(s):
15272:  *
15272:  * Alternatively, the contents of this file may be used under the terms of
15272:  * either the GNU General Public License Version 2 or later (the "GPL"), or
15272:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
15272:  * in which case the provisions of the GPL or the LGPL are applicable instead
15272:  * of those above. If you wish to allow use of your version of this file only
15272:  * under the terms of either the GPL or the LGPL, and not to allow others to
15272:  * use your version of this file under the terms of the MPL, indicate your
15272:  * decision by deleting the provisions above and replace them with the notice
15272:  * and other provisions required by the GPL or the LGPL. If you do not delete
15272:  * the provisions above, a recipient may use your version of this file under
15272:  * the terms of any one of the MPL, the GPL or the LGPL.
15272:  *
15272:  * ***** END LICENSE BLOCK ***** */
15272: 
26462: /*
26462:  * This file is based on the third-party code dtoa.c.  We minimize our
26462:  * modifications to third-party code to make it easy to merge new versions.
26462:  * The author of dtoa.c was not willing to add the parentheses suggested by
26462:  * GCC, so we suppress these warnings.
26462:  */
26462: #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2)
26462: #pragma GCC diagnostic ignored "-Wparentheses"
26462: #endif
26462: 
15272: #include "primpl.h"
15272: 
15272: #define MULTIPLE_THREADS
15272: #define ACQUIRE_DTOA_LOCK(n)	PR_Lock(dtoa_lock[n])
15272: #define FREE_DTOA_LOCK(n)	PR_Unlock(dtoa_lock[n])
15272: 
15272: static PRLock *dtoa_lock[2];
15272: 
15272: void _PR_InitDtoa(void)
15272: {
15272:     dtoa_lock[0] = PR_NewLock();
15272:     dtoa_lock[1] = PR_NewLock();
15272: }
15272: 
15272: void _PR_CleanupDtoa(void)
15272: {
15272:     PR_DestroyLock(dtoa_lock[0]);
15272:     dtoa_lock[0] = NULL;
15272:     PR_DestroyLock(dtoa_lock[1]);
15272:     dtoa_lock[1] = NULL;
15272: 
15272:     /* FIXME: deal with freelist and p5s. */
15272: }
15272: 
15272: #if !defined(__ARM_EABI__) \
15272:     && (defined(__arm) || defined(__arm__) || defined(__arm26__) \
15272:     || defined(__arm32__))
15272: #define IEEE_ARM
15272: #elif defined(IS_LITTLE_ENDIAN)
15272: #define IEEE_8087
15272: #else
15272: #define IEEE_MC68k
15272: #endif
15272: 
15272: #define Long PRInt32
15272: #define ULong PRUint32
15272: #define NO_LONG_LONG
15272: 
15272: /****************************************************************
15272:  *
15272:  * The author of this software is David M. Gay.
15272:  *
15272:  * Copyright (c) 1991, 2000, 2001 by Lucent Technologies.
15272:  *
15272:  * Permission to use, copy, modify, and distribute this software for any
15272:  * purpose without fee is hereby granted, provided that this entire notice
15272:  * is included in all copies of any software which is or includes a copy
15272:  * or modification of this software and in all copies of the supporting
15272:  * documentation for such software.
15272:  *
15272:  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
15272:  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR LUCENT MAKES ANY
15272:  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
15272:  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
15272:  *
15272:  ***************************************************************/
15272: 
15272: /* Please send bug reports to David M. Gay (dmg at acm dot org,
15272:  * with " at " changed at "@" and " dot " changed to ".").	*/
15272: 
15272: /* On a machine with IEEE extended-precision registers, it is
15272:  * necessary to specify double-precision (53-bit) rounding precision
15272:  * before invoking strtod or dtoa.  If the machine uses (the equivalent
15272:  * of) Intel 80x87 arithmetic, the call
15272:  *	_control87(PC_53, MCW_PC);
15272:  * does this with many compilers.  Whether this or another call is
15272:  * appropriate depends on the compiler; for this to work, it may be
15272:  * necessary to #include "float.h" or another system-dependent header
15272:  * file.
15272:  */
15272: 
15272: /* strtod for IEEE-, VAX-, and IBM-arithmetic machines.
15272:  *
15272:  * This strtod returns a nearest machine number to the input decimal
15272:  * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are
15272:  * broken by the IEEE round-even rule.  Otherwise ties are broken by
15272:  * biased rounding (add half and chop).
15272:  *
15272:  * Inspired loosely by William D. Clinger's paper "How to Read Floating
15272:  * Point Numbers Accurately" [Proc. ACM SIGPLAN '90, pp. 92-101].
15272:  *
15272:  * Modifications:
15272:  *
15272:  *	1. We only require IEEE, IBM, or VAX double-precision
15272:  *		arithmetic (not IEEE double-extended).
15272:  *	2. We get by with floating-point arithmetic in a case that
15272:  *		Clinger missed -- when we're computing d * 10^n
15272:  *		for a small integer d and the integer n is not too
15272:  *		much larger than 22 (the maximum integer k for which
15272:  *		we can represent 10^k exactly), we may be able to
15272:  *		compute (d*10^k) * 10^(e-k) with just one roundoff.
15272:  *	3. Rather than a bit-at-a-time adjustment of the binary
15272:  *		result in the hard case, we use floating-point
15272:  *		arithmetic to determine the adjustment to within
15272:  *		one bit; only in really hard cases do we need to
15272:  *		compute a second residual.
15272:  *	4. Because of 3., we don't need a large table of powers of 10
15272:  *		for ten-to-e (just some small tables, e.g. of 10^k
15272:  *		for 0 <= k <= 22).
15272:  */
15272: 
15272: /*
15272:  * #define IEEE_8087 for IEEE-arithmetic machines where the least
15272:  *	significant byte has the lowest address.
15272:  * #define IEEE_MC68k for IEEE-arithmetic machines where the most
15272:  *	significant byte has the lowest address.
15272:  * #define IEEE_ARM for IEEE-arithmetic machines where the two words
15272:  *	in a double are stored in big endian order but the two shorts
15272:  *	in a word are still stored in little endian order.
15272:  * #define Long int on machines with 32-bit ints and 64-bit longs.
15272:  * #define IBM for IBM mainframe-style floating-point arithmetic.
15272:  * #define VAX for VAX-style floating-point arithmetic (D_floating).
15272:  * #define No_leftright to omit left-right logic in fast floating-point
15272:  *	computation of dtoa.
15272:  * #define Honor_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3
15272:  *	and strtod and dtoa should round accordingly.
15272:  * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3
15272:  *	and Honor_FLT_ROUNDS is not #defined.
15272:  * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines
15272:  *	that use extended-precision instructions to compute rounded
15272:  *	products and quotients) with IBM.
15272:  * #define ROUND_BIASED for IEEE-format with biased rounding.
15272:  * #define Inaccurate_Divide for IEEE-format with correctly rounded
15272:  *	products but inaccurate quotients, e.g., for Intel i860.
15272:  * #define NO_LONG_LONG on machines that do not have a "long long"
15272:  *	integer type (of >= 64 bits).  On such machines, you can
15272:  *	#define Just_16 to store 16 bits per 32-bit Long when doing
15272:  *	high-precision integer arithmetic.  Whether this speeds things
15272:  *	up or slows things down depends on the machine and the number
15272:  *	being converted.  If long long is available and the name is
15272:  *	something other than "long long", #define Llong to be the name,
15272:  *	and if "unsigned Llong" does not work as an unsigned version of
15272:  *	Llong, #define #ULLong to be the corresponding unsigned type.
15272:  * #define KR_headers for old-style C function headers.
15272:  * #define Bad_float_h if your system lacks a float.h or if it does not
15272:  *	define some or all of DBL_DIG, DBL_MAX_10_EXP, DBL_MAX_EXP,
15272:  *	FLT_RADIX, FLT_ROUNDS, and DBL_MAX.
15272:  * #define MALLOC your_malloc, where your_malloc(n) acts like malloc(n)
15272:  *	if memory is available and otherwise does something you deem
15272:  *	appropriate.  If MALLOC is undefined, malloc will be invoked
32928:  *	directly -- and assumed always to succeed.  Similarly, if you
32928:  *	want something other than the system's free() to be called to
32928:  *	recycle memory acquired from MALLOC, #define FREE to be the
32928:  *	name of the alternate routine.  (FREE or free is only called in
32928:  *	pathological cases, e.g., in a dtoa call after a dtoa return in
32928:  *	mode 3 with thousands of digits requested.)
15272:  * #define Omit_Private_Memory to omit logic (added Jan. 1998) for making
15272:  *	memory allocations from a private pool of memory when possible.
15272:  *	When used, the private pool is PRIVATE_MEM bytes long:  2304 bytes,
15272:  *	unless #defined to be a different length.  This default length
15272:  *	suffices to get rid of MALLOC calls except for unusual cases,
15272:  *	such as decimal-to-binary conversion of a very long string of
15272:  *	digits.  The longest string dtoa can return is about 751 bytes
15272:  *	long.  For conversions by strtod of strings of 800 digits and
15272:  *	all dtoa conversions in single-threaded executions with 8-byte
15272:  *	pointers, PRIVATE_MEM >= 7400 appears to suffice; with 4-byte
15272:  *	pointers, PRIVATE_MEM >= 7112 appears adequate.
15272:  * #define INFNAN_CHECK on IEEE systems to cause strtod to check for
15272:  *	Infinity and NaN (case insensitively).  On some systems (e.g.,
15272:  *	some HP systems), it may be necessary to #define NAN_WORD0
15272:  *	appropriately -- to the most significant word of a quiet NaN.
15272:  *	(On HP Series 700/800 machines, -DNAN_WORD0=0x7ff40000 works.)
15272:  *	When INFNAN_CHECK is #defined and No_Hex_NaN is not #defined,
15272:  *	strtod also accepts (case insensitively) strings of the form
15272:  *	NaN(x), where x is a string of hexadecimal digits and spaces;
15272:  *	if there is only one string of hexadecimal digits, it is taken
15272:  *	for the 52 fraction bits of the resulting NaN; if there are two
15272:  *	or more strings of hex digits, the first is for the high 20 bits,
15272:  *	the second and subsequent for the low 32 bits, with intervening
15272:  *	white space ignored; but if this results in none of the 52
15272:  *	fraction bits being on (an IEEE Infinity symbol), then NAN_WORD0
15272:  *	and NAN_WORD1 are used instead.
15272:  * #define MULTIPLE_THREADS if the system offers preemptively scheduled
15272:  *	multiple threads.  In this case, you must provide (or suitably
15272:  *	#define) two locks, acquired by ACQUIRE_DTOA_LOCK(n) and freed
15272:  *	by FREE_DTOA_LOCK(n) for n = 0 or 1.  (The second lock, accessed
15272:  *	in pow5mult, ensures lazy evaluation of only one copy of high
15272:  *	powers of 5; omitting this lock would introduce a small
15272:  *	probability of wasting memory, but would otherwise be harmless.)
15272:  *	You must also invoke freedtoa(s) to free the value s returned by
15272:  *	dtoa.  You may do so whether or not MULTIPLE_THREADS is #defined.
15272:  * #define NO_IEEE_Scale to disable new (Feb. 1997) logic in strtod that
15272:  *	avoids underflows on inputs whose result does not underflow.
15272:  *	If you #define NO_IEEE_Scale on a machine that uses IEEE-format
15272:  *	floating-point numbers and flushes underflows to zero rather
15272:  *	than implementing gradual underflow, then you must also #define
15272:  *	Sudden_Underflow.
15272:  * #define USE_LOCALE to use the current locale's decimal_point value.
15272:  * #define SET_INEXACT if IEEE arithmetic is being used and extra
15272:  *	computation should be done to set the inexact flag when the
15272:  *	result is inexact and avoid setting inexact when the result
15272:  *	is exact.  In this case, dtoa.c must be compiled in
15272:  *	an environment, perhaps provided by #include "dtoa.c" in a
15272:  *	suitable wrapper, that defines two functions,
15272:  *		int get_inexact(void);
15272:  *		void clear_inexact(void);
15272:  *	such that get_inexact() returns a nonzero value if the
15272:  *	inexact bit is already set, and clear_inexact() sets the
15272:  *	inexact bit to 0.  When SET_INEXACT is #defined, strtod
15272:  *	also does extra computations to set the underflow and overflow
15272:  *	flags when appropriate (i.e., when the result is tiny and
15272:  *	inexact or when it is a numeric value rounded to +-infinity).
15272:  * #define NO_ERRNO if strtod should not assign errno = ERANGE when
15272:  *	the result overflows to +-Infinity or underflows to 0.
15272:  */
15272: 
15272: #ifndef Long
15272: #define Long long
15272: #endif
15272: #ifndef ULong
15272: typedef unsigned Long ULong;
15272: #endif
15272: 
15272: #ifdef DEBUG
15272: #include "stdio.h"
15272: #define Bug(x) {fprintf(stderr, "%s\n", x); exit(1);}
15272: #endif
15272: 
15272: #include "stdlib.h"
15272: #include "string.h"
15272: 
15272: #ifdef USE_LOCALE
15272: #include "locale.h"
15272: #endif
15272: 
15272: #ifdef MALLOC
15272: #ifdef KR_headers
15272: extern char *MALLOC();
15272: #else
15272: extern void *MALLOC(size_t);
15272: #endif
15272: #else
15272: #define MALLOC malloc
15272: #endif
15272: 
15272: #ifndef Omit_Private_Memory
15272: #ifndef PRIVATE_MEM
15272: #define PRIVATE_MEM 2304
15272: #endif
15272: #define PRIVATE_mem ((PRIVATE_MEM+sizeof(double)-1)/sizeof(double))
15272: static double private_mem[PRIVATE_mem], *pmem_next = private_mem;
15272: #endif
15272: 
15272: #undef IEEE_Arith
15272: #undef Avoid_Underflow
15272: #ifdef IEEE_MC68k
15272: #define IEEE_Arith
15272: #endif
15272: #ifdef IEEE_8087
15272: #define IEEE_Arith
15272: #endif
15272: #ifdef IEEE_ARM
15272: #define IEEE_Arith
15272: #endif
15272: 
15272: #include "errno.h"
15272: 
15272: #ifdef Bad_float_h
15272: 
15272: #ifdef IEEE_Arith
15272: #define DBL_DIG 15
15272: #define DBL_MAX_10_EXP 308
15272: #define DBL_MAX_EXP 1024
15272: #define FLT_RADIX 2
15272: #endif /*IEEE_Arith*/
15272: 
15272: #ifdef IBM
15272: #define DBL_DIG 16
15272: #define DBL_MAX_10_EXP 75
15272: #define DBL_MAX_EXP 63
15272: #define FLT_RADIX 16
15272: #define DBL_MAX 7.2370055773322621e+75
15272: #endif
15272: 
15272: #ifdef VAX
15272: #define DBL_DIG 16
15272: #define DBL_MAX_10_EXP 38
15272: #define DBL_MAX_EXP 127
15272: #define FLT_RADIX 2
15272: #define DBL_MAX 1.7014118346046923e+38
15272: #endif
15272: 
15272: #ifndef LONG_MAX
15272: #define LONG_MAX 2147483647
15272: #endif
15272: 
15272: #else /* ifndef Bad_float_h */
15272: #include "float.h"
15272: /*
15272:  * MacOS 10.2 defines the macro FLT_ROUNDS to an internal function
15272:  * which does not exist on 10.1.  We can safely #define it to 1 here
15272:  * to allow 10.2 builds to run on 10.1, since we can't use fesetround()
15272:  * (which does not exist on 10.1 either).
15272:  */
15272: #if defined(XP_MACOSX) && (!defined(MAC_OS_X_VERSION_10_2) || \
15272:     MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_2)
15272: #undef FLT_ROUNDS
15272: #define FLT_ROUNDS 1
15272: #endif /* DT < 10.2 */
15272: #endif /* Bad_float_h */
15272: 
15272: #ifndef __MATH_H__
15272: #include "math.h"
15272: #endif
15272: 
15272: #ifdef __cplusplus
15272: extern "C" {
15272: #endif
15272: 
15272: #ifndef CONST
15272: #ifdef KR_headers
15272: #define CONST /* blank */
15272: #else
15272: #define CONST const
15272: #endif
15272: #endif
15272: 
15272: #if defined(IEEE_8087) + defined(IEEE_MC68k) + defined(IEEE_ARM) + defined(VAX) + defined(IBM) != 1
15272: Exactly one of IEEE_8087, IEEE_MC68k, IEEE_ARM, VAX, or IBM should be defined.
15272: #endif
15272: 
15272: typedef union { double d; ULong L[2]; } U;
15272: 
26462: #define dval(x) (x).d
15272: #ifdef IEEE_8087
26462: #define word0(x) (x).L[1]
26462: #define word1(x) (x).L[0]
15272: #else
26462: #define word0(x) (x).L[0]
26462: #define word1(x) (x).L[1]
15272: #endif
15272: 
15272: /* The following definition of Storeinc is appropriate for MIPS processors.
15272:  * An alternative that might be better on some machines is
15272:  * #define Storeinc(a,b,c) (*a++ = b << 16 | c & 0xffff)
15272:  */
15272: #if defined(IEEE_8087) + defined(IEEE_ARM) + defined(VAX)
15272: #define Storeinc(a,b,c) (((unsigned short *)a)[1] = (unsigned short)b, \
15272: ((unsigned short *)a)[0] = (unsigned short)c, a++)
15272: #else
15272: #define Storeinc(a,b,c) (((unsigned short *)a)[0] = (unsigned short)b, \
15272: ((unsigned short *)a)[1] = (unsigned short)c, a++)
15272: #endif
15272: 
15272: /* #define P DBL_MANT_DIG */
15272: /* Ten_pmax = floor(P*log(2)/log(5)) */
15272: /* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */
15272: /* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
15272: /* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
15272: 
15272: #ifdef IEEE_Arith
15272: #define Exp_shift  20
15272: #define Exp_shift1 20
15272: #define Exp_msk1    0x100000
15272: #define Exp_msk11   0x100000
15272: #define Exp_mask  0x7ff00000
15272: #define P 53
15272: #define Bias 1023
15272: #define Emin (-1022)
15272: #define Exp_1  0x3ff00000
15272: #define Exp_11 0x3ff00000
15272: #define Ebits 11
15272: #define Frac_mask  0xfffff
15272: #define Frac_mask1 0xfffff
15272: #define Ten_pmax 22
15272: #define Bletch 0x10
15272: #define Bndry_mask  0xfffff
15272: #define Bndry_mask1 0xfffff
15272: #define LSB 1
15272: #define Sign_bit 0x80000000
15272: #define Log2P 1
15272: #define Tiny0 0
15272: #define Tiny1 1
15272: #define Quick_max 14
15272: #define Int_max 14
15272: #ifndef NO_IEEE_Scale
15272: #define Avoid_Underflow
15272: #ifdef Flush_Denorm	/* debugging option */
15272: #undef Sudden_Underflow
15272: #endif
15272: #endif
15272: 
15272: #ifndef Flt_Rounds
15272: #ifdef FLT_ROUNDS
15272: #define Flt_Rounds FLT_ROUNDS
15272: #else
15272: #define Flt_Rounds 1
15272: #endif
15272: #endif /*Flt_Rounds*/
15272: 
15272: #ifdef Honor_FLT_ROUNDS
15272: #define Rounding rounding
15272: #undef Check_FLT_ROUNDS
15272: #define Check_FLT_ROUNDS
15272: #else
15272: #define Rounding Flt_Rounds
15272: #endif
15272: 
15272: #else /* ifndef IEEE_Arith */
15272: #undef Check_FLT_ROUNDS
15272: #undef Honor_FLT_ROUNDS
15272: #undef SET_INEXACT
15272: #undef  Sudden_Underflow
15272: #define Sudden_Underflow
15272: #ifdef IBM
15272: #undef Flt_Rounds
15272: #define Flt_Rounds 0
15272: #define Exp_shift  24
15272: #define Exp_shift1 24
15272: #define Exp_msk1   0x1000000
15272: #define Exp_msk11  0x1000000
15272: #define Exp_mask  0x7f000000
15272: #define P 14
15272: #define Bias 65
15272: #define Exp_1  0x41000000
15272: #define Exp_11 0x41000000
15272: #define Ebits 8	/* exponent has 7 bits, but 8 is the right value in b2d */
15272: #define Frac_mask  0xffffff
15272: #define Frac_mask1 0xffffff
15272: #define Bletch 4
15272: #define Ten_pmax 22
15272: #define Bndry_mask  0xefffff
15272: #define Bndry_mask1 0xffffff
15272: #define LSB 1
15272: #define Sign_bit 0x80000000
15272: #define Log2P 4
15272: #define Tiny0 0x100000
15272: #define Tiny1 0
15272: #define Quick_max 14
15272: #define Int_max 15
15272: #else /* VAX */
15272: #undef Flt_Rounds
15272: #define Flt_Rounds 1
15272: #define Exp_shift  23
15272: #define Exp_shift1 7
15272: #define Exp_msk1    0x80
15272: #define Exp_msk11   0x800000
15272: #define Exp_mask  0x7f80
15272: #define P 56
15272: #define Bias 129
15272: #define Exp_1  0x40800000
15272: #define Exp_11 0x4080
15272: #define Ebits 8
15272: #define Frac_mask  0x7fffff
15272: #define Frac_mask1 0xffff007f
15272: #define Ten_pmax 24
15272: #define Bletch 2
15272: #define Bndry_mask  0xffff007f
15272: #define Bndry_mask1 0xffff007f
15272: #define LSB 0x10000
15272: #define Sign_bit 0x8000
15272: #define Log2P 1
15272: #define Tiny0 0x80
15272: #define Tiny1 0
15272: #define Quick_max 15
15272: #define Int_max 15
15272: #endif /* IBM, VAX */
15272: #endif /* IEEE_Arith */
15272: 
15272: #ifndef IEEE_Arith
15272: #define ROUND_BIASED
15272: #endif
15272: 
15272: #ifdef RND_PRODQUOT
15272: #define rounded_product(a,b) a = rnd_prod(a, b)
15272: #define rounded_quotient(a,b) a = rnd_quot(a, b)
15272: #ifdef KR_headers
15272: extern double rnd_prod(), rnd_quot();
15272: #else
15272: extern double rnd_prod(double, double), rnd_quot(double, double);
15272: #endif
15272: #else
15272: #define rounded_product(a,b) a *= b
15272: #define rounded_quotient(a,b) a /= b
15272: #endif
15272: 
15272: #define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))
15272: #define Big1 0xffffffff
15272: 
15272: #ifndef Pack_32
15272: #define Pack_32
15272: #endif
15272: 
15272: #ifdef KR_headers
15272: #define FFFFFFFF ((((unsigned long)0xffff)<<16)|(unsigned long)0xffff)
15272: #else
15272: #define FFFFFFFF 0xffffffffUL
15272: #endif
15272: 
15272: #ifdef NO_LONG_LONG
15272: #undef ULLong
15272: #ifdef Just_16
15272: #undef Pack_32
15272: /* When Pack_32 is not defined, we store 16 bits per 32-bit Long.
15272:  * This makes some inner loops simpler and sometimes saves work
15272:  * during multiplications, but it often seems to make things slightly
15272:  * slower.  Hence the default is now to store 32 bits per Long.
15272:  */
15272: #endif
15272: #else	/* long long available */
15272: #ifndef Llong
15272: #define Llong long long
15272: #endif
15272: #ifndef ULLong
15272: #define ULLong unsigned Llong
15272: #endif
15272: #endif /* NO_LONG_LONG */
15272: 
15272: #ifndef MULTIPLE_THREADS
15272: #define ACQUIRE_DTOA_LOCK(n)	/*nothing*/
15272: #define FREE_DTOA_LOCK(n)	/*nothing*/
15272: #endif
15272: 
32928: #define Kmax 7
15272: 
15272:  struct
15272: Bigint {
15272: 	struct Bigint *next;
15272: 	int k, maxwds, sign, wds;
15272: 	ULong x[1];
15272: 	};
15272: 
15272:  typedef struct Bigint Bigint;
15272: 
15272:  static Bigint *freelist[Kmax+1];
15272: 
15272:  static Bigint *
15272: Balloc
15272: #ifdef KR_headers
15272: 	(k) int k;
15272: #else
15272: 	(int k)
15272: #endif
15272: {
15272: 	int x;
15272: 	Bigint *rv;
15272: #ifndef Omit_Private_Memory
15272: 	unsigned int len;
15272: #endif
15272: 
15272: 	ACQUIRE_DTOA_LOCK(0);
32928: 	/* The k > Kmax case does not need ACQUIRE_DTOA_LOCK(0), */
32928: 	/* but this case seems very unlikely. */
32928: 	if (k <= Kmax && (rv = freelist[k]))
15272: 		freelist[k] = rv->next;
15272: 	else {
15272: 		x = 1 << k;
15272: #ifdef Omit_Private_Memory
15272: 		rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
15272: #else
15272: 		len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
15272: 			/sizeof(double);
32928: 		if (k <= Kmax && pmem_next - private_mem + len <= PRIVATE_mem) {
15272: 			rv = (Bigint*)pmem_next;
15272: 			pmem_next += len;
15272: 			}
15272: 		else
15272: 			rv = (Bigint*)MALLOC(len*sizeof(double));
15272: #endif
15272: 		rv->k = k;
15272: 		rv->maxwds = x;
15272: 		}
15272: 	FREE_DTOA_LOCK(0);
15272: 	rv->sign = rv->wds = 0;
15272: 	return rv;
15272: 	}
15272: 
15272:  static void
15272: Bfree
15272: #ifdef KR_headers
15272: 	(v) Bigint *v;
15272: #else
15272: 	(Bigint *v)
15272: #endif
15272: {
15272: 	if (v) {
32928: 		if (v->k > Kmax)
32928: #ifdef FREE
32928: 			FREE((void*)v);
32928: #else
32928: 			free((void*)v);
32928: #endif
32928: 		else {
15272: 			ACQUIRE_DTOA_LOCK(0);
15272: 			v->next = freelist[v->k];
15272: 			freelist[v->k] = v;
15272: 			FREE_DTOA_LOCK(0);
15272: 			}
15272: 		}
32928: 	}
15272: 
15272: #define Bcopy(x,y) memcpy((char *)&x->sign, (char *)&y->sign, \
15272: y->wds*sizeof(Long) + 2*sizeof(int))
15272: 
15272:  static Bigint *
15272: multadd
15272: #ifdef KR_headers
15272: 	(b, m, a) Bigint *b; int m, a;
15272: #else
15272: 	(Bigint *b, int m, int a)	/* multiply by m and add a */
15272: #endif
15272: {
15272: 	int i, wds;
15272: #ifdef ULLong
15272: 	ULong *x;
15272: 	ULLong carry, y;
15272: #else
15272: 	ULong carry, *x, y;
15272: #ifdef Pack_32
15272: 	ULong xi, z;
15272: #endif
15272: #endif
15272: 	Bigint *b1;
15272: 
15272: 	wds = b->wds;
15272: 	x = b->x;
15272: 	i = 0;
15272: 	carry = a;
15272: 	do {
15272: #ifdef ULLong
15272: 		y = *x * (ULLong)m + carry;
15272: 		carry = y >> 32;
15272: 		*x++ = y & FFFFFFFF;
15272: #else
15272: #ifdef Pack_32
15272: 		xi = *x;
15272: 		y = (xi & 0xffff) * m + carry;
15272: 		z = (xi >> 16) * m + (y >> 16);
15272: 		carry = z >> 16;
15272: 		*x++ = (z << 16) + (y & 0xffff);
15272: #else
15272: 		y = *x * m + carry;
15272: 		carry = y >> 16;
15272: 		*x++ = y & 0xffff;
15272: #endif
15272: #endif
15272: 		}
15272: 		while(++i < wds);
15272: 	if (carry) {
15272: 		if (wds >= b->maxwds) {
15272: 			b1 = Balloc(b->k+1);
15272: 			Bcopy(b1, b);
15272: 			Bfree(b);
15272: 			b = b1;
15272: 			}
15272: 		b->x[wds++] = carry;
15272: 		b->wds = wds;
15272: 		}
15272: 	return b;
15272: 	}
15272: 
15272:  static Bigint *
15272: s2b
15272: #ifdef KR_headers
15272: 	(s, nd0, nd, y9) CONST char *s; int nd0, nd; ULong y9;
15272: #else
15272: 	(CONST char *s, int nd0, int nd, ULong y9)
15272: #endif
15272: {
15272: 	Bigint *b;
15272: 	int i, k;
15272: 	Long x, y;
15272: 
15272: 	x = (nd + 8) / 9;
15272: 	for(k = 0, y = 1; x > y; y <<= 1, k++) ;
15272: #ifdef Pack_32
15272: 	b = Balloc(k);
15272: 	b->x[0] = y9;
15272: 	b->wds = 1;
15272: #else
15272: 	b = Balloc(k+1);
15272: 	b->x[0] = y9 & 0xffff;
15272: 	b->wds = (b->x[1] = y9 >> 16) ? 2 : 1;
15272: #endif
15272: 
15272: 	i = 9;
15272: 	if (9 < nd0) {
15272: 		s += 9;
15272: 		do b = multadd(b, 10, *s++ - '0');
15272: 			while(++i < nd0);
15272: 		s++;
15272: 		}
15272: 	else
15272: 		s += 10;
15272: 	for(; i < nd; i++)
15272: 		b = multadd(b, 10, *s++ - '0');
15272: 	return b;
15272: 	}
15272: 
15272:  static int
15272: hi0bits
15272: #ifdef KR_headers
15272: 	(x) register ULong x;
15272: #else
15272: 	(register ULong x)
15272: #endif
15272: {
15272: 	register int k = 0;
15272: 
15272: 	if (!(x & 0xffff0000)) {
15272: 		k = 16;
15272: 		x <<= 16;
15272: 		}
15272: 	if (!(x & 0xff000000)) {
15272: 		k += 8;
15272: 		x <<= 8;
15272: 		}
15272: 	if (!(x & 0xf0000000)) {
15272: 		k += 4;
15272: 		x <<= 4;
15272: 		}
15272: 	if (!(x & 0xc0000000)) {
15272: 		k += 2;
15272: 		x <<= 2;
15272: 		}
15272: 	if (!(x & 0x80000000)) {
15272: 		k++;
15272: 		if (!(x & 0x40000000))
15272: 			return 32;
15272: 		}
15272: 	return k;
15272: 	}
15272: 
15272:  static int
15272: lo0bits
15272: #ifdef KR_headers
15272: 	(y) ULong *y;
15272: #else
15272: 	(ULong *y)
15272: #endif
15272: {
15272: 	register int k;
15272: 	register ULong x = *y;
15272: 
15272: 	if (x & 7) {
15272: 		if (x & 1)
15272: 			return 0;
15272: 		if (x & 2) {
15272: 			*y = x >> 1;
15272: 			return 1;
15272: 			}
15272: 		*y = x >> 2;
15272: 		return 2;
15272: 		}
15272: 	k = 0;
15272: 	if (!(x & 0xffff)) {
15272: 		k = 16;
15272: 		x >>= 16;
15272: 		}
15272: 	if (!(x & 0xff)) {
15272: 		k += 8;
15272: 		x >>= 8;
15272: 		}
15272: 	if (!(x & 0xf)) {
15272: 		k += 4;
15272: 		x >>= 4;
15272: 		}
15272: 	if (!(x & 0x3)) {
15272: 		k += 2;
15272: 		x >>= 2;
15272: 		}
15272: 	if (!(x & 1)) {
15272: 		k++;
15272: 		x >>= 1;
15272: 		if (!x)
15272: 			return 32;
15272: 		}
15272: 	*y = x;
15272: 	return k;
15272: 	}
15272: 
15272:  static Bigint *
15272: i2b
15272: #ifdef KR_headers
15272: 	(i) int i;
15272: #else
15272: 	(int i)
15272: #endif
15272: {
15272: 	Bigint *b;
15272: 
15272: 	b = Balloc(1);
15272: 	b->x[0] = i;
15272: 	b->wds = 1;
15272: 	return b;
15272: 	}
15272: 
15272:  static Bigint *
15272: mult
15272: #ifdef KR_headers
15272: 	(a, b) Bigint *a, *b;
15272: #else
15272: 	(Bigint *a, Bigint *b)
15272: #endif
15272: {
15272: 	Bigint *c;
15272: 	int k, wa, wb, wc;
15272: 	ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
15272: 	ULong y;
15272: #ifdef ULLong
15272: 	ULLong carry, z;
15272: #else
15272: 	ULong carry, z;
15272: #ifdef Pack_32
15272: 	ULong z2;
15272: #endif
15272: #endif
15272: 
15272: 	if (a->wds < b->wds) {
15272: 		c = a;
15272: 		a = b;
15272: 		b = c;
15272: 		}
15272: 	k = a->k;
15272: 	wa = a->wds;
15272: 	wb = b->wds;
15272: 	wc = wa + wb;
15272: 	if (wc > a->maxwds)
15272: 		k++;
15272: 	c = Balloc(k);
15272: 	for(x = c->x, xa = x + wc; x < xa; x++)
15272: 		*x = 0;
15272: 	xa = a->x;
15272: 	xae = xa + wa;
15272: 	xb = b->x;
15272: 	xbe = xb + wb;
15272: 	xc0 = c->x;
15272: #ifdef ULLong
15272: 	for(; xb < xbe; xc0++) {
15272: 		if (y = *xb++) {
15272: 			x = xa;
15272: 			xc = xc0;
15272: 			carry = 0;
15272: 			do {
15272: 				z = *x++ * (ULLong)y + *xc + carry;
15272: 				carry = z >> 32;
15272: 				*xc++ = z & FFFFFFFF;
15272: 				}
15272: 				while(x < xae);
15272: 			*xc = carry;
15272: 			}
15272: 		}
15272: #else
15272: #ifdef Pack_32
15272: 	for(; xb < xbe; xb++, xc0++) {
15272: 		if (y = *xb & 0xffff) {
15272: 			x = xa;
15272: 			xc = xc0;
15272: 			carry = 0;
15272: 			do {
15272: 				z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
15272: 				carry = z >> 16;
15272: 				z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
15272: 				carry = z2 >> 16;
15272: 				Storeinc(xc, z2, z);
15272: 				}
15272: 				while(x < xae);
15272: 			*xc = carry;
15272: 			}
15272: 		if (y = *xb >> 16) {
15272: 			x = xa;
15272: 			xc = xc0;
15272: 			carry = 0;
15272: 			z2 = *xc;
15272: 			do {
15272: 				z = (*x & 0xffff) * y + (*xc >> 16) + carry;
15272: 				carry = z >> 16;
15272: 				Storeinc(xc, z, z2);
15272: 				z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
15272: 				carry = z2 >> 16;
15272: 				}
15272: 				while(x < xae);
15272: 			*xc = z2;
15272: 			}
15272: 		}
15272: #else
15272: 	for(; xb < xbe; xc0++) {
15272: 		if (y = *xb++) {
15272: 			x = xa;
15272: 			xc = xc0;
15272: 			carry = 0;
15272: 			do {
15272: 				z = *x++ * y + *xc + carry;
15272: 				carry = z >> 16;
15272: 				*xc++ = z & 0xffff;
15272: 				}
15272: 				while(x < xae);
15272: 			*xc = carry;
15272: 			}
15272: 		}
15272: #endif
15272: #endif
15272: 	for(xc0 = c->x, xc = xc0 + wc; wc > 0 && !*--xc; --wc) ;
15272: 	c->wds = wc;
15272: 	return c;
15272: 	}
15272: 
15272:  static Bigint *p5s;
15272: 
15272:  static Bigint *
15272: pow5mult
15272: #ifdef KR_headers
15272: 	(b, k) Bigint *b; int k;
15272: #else
15272: 	(Bigint *b, int k)
15272: #endif
15272: {
15272: 	Bigint *b1, *p5, *p51;
15272: 	int i;
15272: 	static int p05[3] = { 5, 25, 125 };
15272: 
15272: 	if (i = k & 3)
15272: 		b = multadd(b, p05[i-1], 0);
15272: 
15272: 	if (!(k >>= 2))
15272: 		return b;
15272: 	if (!(p5 = p5s)) {
15272: 		/* first time */
15272: #ifdef MULTIPLE_THREADS
15272: 		ACQUIRE_DTOA_LOCK(1);
15272: 		if (!(p5 = p5s)) {
15272: 			p5 = p5s = i2b(625);
15272: 			p5->next = 0;
15272: 			}
15272: 		FREE_DTOA_LOCK(1);
15272: #else
15272: 		p5 = p5s = i2b(625);
15272: 		p5->next = 0;
15272: #endif
15272: 		}
15272: 	for(;;) {
15272: 		if (k & 1) {
15272: 			b1 = mult(b, p5);
15272: 			Bfree(b);
15272: 			b = b1;
15272: 			}
15272: 		if (!(k >>= 1))
15272: 			break;
15272: 		if (!(p51 = p5->next)) {
15272: #ifdef MULTIPLE_THREADS
15272: 			ACQUIRE_DTOA_LOCK(1);
15272: 			if (!(p51 = p5->next)) {
15272: 				p51 = p5->next = mult(p5,p5);
15272: 				p51->next = 0;
15272: 				}
15272: 			FREE_DTOA_LOCK(1);
15272: #else
15272: 			p51 = p5->next = mult(p5,p5);
15272: 			p51->next = 0;
15272: #endif
15272: 			}
15272: 		p5 = p51;
15272: 		}
15272: 	return b;
15272: 	}
15272: 
15272:  static Bigint *
15272: lshift
15272: #ifdef KR_headers
15272: 	(b, k) Bigint *b; int k;
15272: #else
15272: 	(Bigint *b, int k)
15272: #endif
15272: {
15272: 	int i, k1, n, n1;
15272: 	Bigint *b1;
15272: 	ULong *x, *x1, *xe, z;
15272: 
15272: #ifdef Pack_32
15272: 	n = k >> 5;
15272: #else
15272: 	n = k >> 4;
15272: #endif
15272: 	k1 = b->k;
15272: 	n1 = n + b->wds + 1;
15272: 	for(i = b->maxwds; n1 > i; i <<= 1)
15272: 		k1++;
15272: 	b1 = Balloc(k1);
15272: 	x1 = b1->x;
15272: 	for(i = 0; i < n; i++)
15272: 		*x1++ = 0;
15272: 	x = b->x;
15272: 	xe = x + b->wds;
15272: #ifdef Pack_32
15272: 	if (k &= 0x1f) {
15272: 		k1 = 32 - k;
15272: 		z = 0;
15272: 		do {
15272: 			*x1++ = *x << k | z;
15272: 			z = *x++ >> k1;
15272: 			}
15272: 			while(x < xe);
15272: 		if (*x1 = z)
15272: 			++n1;
15272: 		}
15272: #else
15272: 	if (k &= 0xf) {
15272: 		k1 = 16 - k;
15272: 		z = 0;
15272: 		do {
15272: 			*x1++ = *x << k  & 0xffff | z;
15272: 			z = *x++ >> k1;
15272: 			}
15272: 			while(x < xe);
15272: 		if (*x1 = z)
15272: 			++n1;
15272: 		}
15272: #endif
15272: 	else do
15272: 		*x1++ = *x++;
15272: 		while(x < xe);
15272: 	b1->wds = n1 - 1;
15272: 	Bfree(b);
15272: 	return b1;
15272: 	}
15272: 
15272:  static int
15272: cmp
15272: #ifdef KR_headers
15272: 	(a, b) Bigint *a, *b;
15272: #else
15272: 	(Bigint *a, Bigint *b)
15272: #endif
15272: {
15272: 	ULong *xa, *xa0, *xb, *xb0;
15272: 	int i, j;
15272: 
15272: 	i = a->wds;
15272: 	j = b->wds;
15272: #ifdef DEBUG
15272: 	if (i > 1 && !a->x[i-1])
15272: 		Bug("cmp called with a->x[a->wds-1] == 0");
15272: 	if (j > 1 && !b->x[j-1])
15272: 		Bug("cmp called with b->x[b->wds-1] == 0");
15272: #endif
15272: 	if (i -= j)
15272: 		return i;
15272: 	xa0 = a->x;
15272: 	xa = xa0 + j;
15272: 	xb0 = b->x;
15272: 	xb = xb0 + j;
15272: 	for(;;) {
15272: 		if (*--xa != *--xb)
15272: 			return *xa < *xb ? -1 : 1;
15272: 		if (xa <= xa0)
15272: 			break;
15272: 		}
15272: 	return 0;
15272: 	}
15272: 
15272:  static Bigint *
15272: diff
15272: #ifdef KR_headers
15272: 	(a, b) Bigint *a, *b;
15272: #else
15272: 	(Bigint *a, Bigint *b)
15272: #endif
15272: {
15272: 	Bigint *c;
15272: 	int i, wa, wb;
15272: 	ULong *xa, *xae, *xb, *xbe, *xc;
15272: #ifdef ULLong
15272: 	ULLong borrow, y;
15272: #else
15272: 	ULong borrow, y;
15272: #ifdef Pack_32
15272: 	ULong z;
15272: #endif
15272: #endif
15272: 
15272: 	i = cmp(a,b);
15272: 	if (!i) {
15272: 		c = Balloc(0);
15272: 		c->wds = 1;
15272: 		c->x[0] = 0;
15272: 		return c;
15272: 		}
15272: 	if (i < 0) {
15272: 		c = a;
15272: 		a = b;
15272: 		b = c;
15272: 		i = 1;
15272: 		}
15272: 	else
15272: 		i = 0;
15272: 	c = Balloc(a->k);
15272: 	c->sign = i;
15272: 	wa = a->wds;
15272: 	xa = a->x;
15272: 	xae = xa + wa;
15272: 	wb = b->wds;
15272: 	xb = b->x;
15272: 	xbe = xb + wb;
15272: 	xc = c->x;
15272: 	borrow = 0;
15272: #ifdef ULLong
15272: 	do {
15272: 		y = (ULLong)*xa++ - *xb++ - borrow;
15272: 		borrow = y >> 32 & (ULong)1;
15272: 		*xc++ = y & FFFFFFFF;
15272: 		}
15272: 		while(xb < xbe);
15272: 	while(xa < xae) {
15272: 		y = *xa++ - borrow;
15272: 		borrow = y >> 32 & (ULong)1;
15272: 		*xc++ = y & FFFFFFFF;
15272: 		}
15272: #else
15272: #ifdef Pack_32
15272: 	do {
15272: 		y = (*xa & 0xffff) - (*xb & 0xffff) - borrow;
15272: 		borrow = (y & 0x10000) >> 16;
15272: 		z = (*xa++ >> 16) - (*xb++ >> 16) - borrow;
15272: 		borrow = (z & 0x10000) >> 16;
15272: 		Storeinc(xc, z, y);
15272: 		}
15272: 		while(xb < xbe);
15272: 	while(xa < xae) {
15272: 		y = (*xa & 0xffff) - borrow;
15272: 		borrow = (y & 0x10000) >> 16;
15272: 		z = (*xa++ >> 16) - borrow;
15272: 		borrow = (z & 0x10000) >> 16;
15272: 		Storeinc(xc, z, y);
15272: 		}
15272: #else
15272: 	do {
15272: 		y = *xa++ - *xb++ - borrow;
15272: 		borrow = (y & 0x10000) >> 16;
15272: 		*xc++ = y & 0xffff;
15272: 		}
15272: 		while(xb < xbe);
15272: 	while(xa < xae) {
15272: 		y = *xa++ - borrow;
15272: 		borrow = (y & 0x10000) >> 16;
15272: 		*xc++ = y & 0xffff;
15272: 		}
15272: #endif
15272: #endif
15272: 	while(!*--xc)
15272: 		wa--;
15272: 	c->wds = wa;
15272: 	return c;
15272: 	}
15272: 
15272:  static double
15272: ulp
15272: #ifdef KR_headers
26462: 	(dx) double dx;
15272: #else
26462: 	(double dx)
15272: #endif
15272: {
15272: 	register Long L;
26462: 	U x, a;
15272: 
26462: 	dval(x) = dx;
15272: 	L = (word0(x) & Exp_mask) - (P-1)*Exp_msk1;
15272: #ifndef Avoid_Underflow
15272: #ifndef Sudden_Underflow
15272: 	if (L > 0) {
15272: #endif
15272: #endif
15272: #ifdef IBM
15272: 		L |= Exp_msk1 >> 4;
15272: #endif
15272: 		word0(a) = L;
15272: 		word1(a) = 0;
15272: #ifndef Avoid_Underflow
15272: #ifndef Sudden_Underflow
15272: 		}
15272: 	else {
15272: 		L = -L >> Exp_shift;
15272: 		if (L < Exp_shift) {
15272: 			word0(a) = 0x80000 >> L;
15272: 			word1(a) = 0;
15272: 			}
15272: 		else {
15272: 			word0(a) = 0;
15272: 			L -= Exp_shift;
15272: 			word1(a) = L >= 31 ? 1 : 1 << 31 - L;
15272: 			}
15272: 		}
15272: #endif
15272: #endif
15272: 	return dval(a);
15272: 	}
15272: 
15272:  static double
15272: b2d
15272: #ifdef KR_headers
15272: 	(a, e) Bigint *a; int *e;
15272: #else
15272: 	(Bigint *a, int *e)
15272: #endif
15272: {
15272: 	ULong *xa, *xa0, w, y, z;
15272: 	int k;
26462: 	U d;
15272: #ifdef VAX
15272: 	ULong d0, d1;
15272: #else
15272: #define d0 word0(d)
15272: #define d1 word1(d)
15272: #endif
15272: 
15272: 	xa0 = a->x;
15272: 	xa = xa0 + a->wds;
15272: 	y = *--xa;
15272: #ifdef DEBUG
15272: 	if (!y) Bug("zero y in b2d");
15272: #endif
15272: 	k = hi0bits(y);
15272: 	*e = 32 - k;
15272: #ifdef Pack_32
15272: 	if (k < Ebits) {
15272: 		d0 = Exp_1 | y >> Ebits - k;
15272: 		w = xa > xa0 ? *--xa : 0;
15272: 		d1 = y << (32-Ebits) + k | w >> Ebits - k;
15272: 		goto ret_d;
15272: 		}
15272: 	z = xa > xa0 ? *--xa : 0;
15272: 	if (k -= Ebits) {
15272: 		d0 = Exp_1 | y << k | z >> 32 - k;
15272: 		y = xa > xa0 ? *--xa : 0;
15272: 		d1 = z << k | y >> 32 - k;
15272: 		}
15272: 	else {
15272: 		d0 = Exp_1 | y;
15272: 		d1 = z;
15272: 		}
15272: #else
15272: 	if (k < Ebits + 16) {
15272: 		z = xa > xa0 ? *--xa : 0;
15272: 		d0 = Exp_1 | y << k - Ebits | z >> Ebits + 16 - k;
15272: 		w = xa > xa0 ? *--xa : 0;
15272: 		y = xa > xa0 ? *--xa : 0;
15272: 		d1 = z << k + 16 - Ebits | w << k - Ebits | y >> 16 + Ebits - k;
15272: 		goto ret_d;
15272: 		}
15272: 	z = xa > xa0 ? *--xa : 0;
15272: 	w = xa > xa0 ? *--xa : 0;
15272: 	k -= Ebits + 16;
15272: 	d0 = Exp_1 | y << k + 16 | z << k | w >> 16 - k;
15272: 	y = xa > xa0 ? *--xa : 0;
15272: 	d1 = w << k + 16 | y << k;
15272: #endif
15272:  ret_d:
15272: #ifdef VAX
15272: 	word0(d) = d0 >> 16 | d0 << 16;
15272: 	word1(d) = d1 >> 16 | d1 << 16;
15272: #else
15272: #undef d0
15272: #undef d1
15272: #endif
15272: 	return dval(d);
15272: 	}
15272: 
15272:  static Bigint *
15272: d2b
15272: #ifdef KR_headers
26462: 	(dd, e, bits) double dd; int *e, *bits;
15272: #else
26462: 	(double dd, int *e, int *bits)
15272: #endif
15272: {
26462: 	U d;
15272: 	Bigint *b;
15272: 	int de, k;
15272: 	ULong *x, y, z;
15272: #ifndef Sudden_Underflow
15272: 	int i;
15272: #endif
15272: #ifdef VAX
15272: 	ULong d0, d1;
26462: #endif
26462: 
26462: 	dval(d) = dd;
26462: #ifdef VAX
15272: 	d0 = word0(d) >> 16 | word0(d) << 16;
15272: 	d1 = word1(d) >> 16 | word1(d) << 16;
15272: #else
15272: #define d0 word0(d)
15272: #define d1 word1(d)
15272: #endif
15272: 
15272: #ifdef Pack_32
15272: 	b = Balloc(1);
15272: #else
15272: 	b = Balloc(2);
15272: #endif
15272: 	x = b->x;
15272: 
15272: 	z = d0 & Frac_mask;
15272: 	d0 &= 0x7fffffff;	/* clear sign bit, which we ignore */
15272: #ifdef Sudden_Underflow
15272: 	de = (int)(d0 >> Exp_shift);
15272: #ifndef IBM
15272: 	z |= Exp_msk11;
15272: #endif
15272: #else
15272: 	if (de = (int)(d0 >> Exp_shift))
15272: 		z |= Exp_msk1;
15272: #endif
15272: #ifdef Pack_32
15272: 	if (y = d1) {
15272: 		if (k = lo0bits(&y)) {
15272: 			x[0] = y | z << 32 - k;
15272: 			z >>= k;
15272: 			}
15272: 		else
15272: 			x[0] = y;
15272: #ifndef Sudden_Underflow
15272: 		i =
15272: #endif
15272: 		    b->wds = (x[1] = z) ? 2 : 1;
15272: 		}
15272: 	else {
15272: 		k = lo0bits(&z);
15272: 		x[0] = z;
15272: #ifndef Sudden_Underflow
15272: 		i =
15272: #endif
15272: 		    b->wds = 1;
15272: 		k += 32;
15272: 		}
15272: #else
15272: 	if (y = d1) {
15272: 		if (k = lo0bits(&y))
15272: 			if (k >= 16) {
15272: 				x[0] = y | z << 32 - k & 0xffff;
15272: 				x[1] = z >> k - 16 & 0xffff;
15272: 				x[2] = z >> k;
15272: 				i = 2;
15272: 				}
15272: 			else {
15272: 				x[0] = y & 0xffff;
15272: 				x[1] = y >> 16 | z << 16 - k & 0xffff;
15272: 				x[2] = z >> k & 0xffff;
15272: 				x[3] = z >> k+16;
15272: 				i = 3;
15272: 				}
15272: 		else {
15272: 			x[0] = y & 0xffff;
15272: 			x[1] = y >> 16;
15272: 			x[2] = z & 0xffff;
15272: 			x[3] = z >> 16;
15272: 			i = 3;
15272: 			}
15272: 		}
15272: 	else {
15272: #ifdef DEBUG
15272: 		if (!z)
15272: 			Bug("Zero passed to d2b");
15272: #endif
15272: 		k = lo0bits(&z);
15272: 		if (k >= 16) {
15272: 			x[0] = z;
15272: 			i = 0;
15272: 			}
15272: 		else {
15272: 			x[0] = z & 0xffff;
15272: 			x[1] = z >> 16;
15272: 			i = 1;
15272: 			}
15272: 		k += 32;
15272: 		}
15272: 	while(!x[i])
15272: 		--i;
15272: 	b->wds = i + 1;
15272: #endif
15272: #ifndef Sudden_Underflow
15272: 	if (de) {
15272: #endif
15272: #ifdef IBM
15272: 		*e = (de - Bias - (P-1) << 2) + k;
15272: 		*bits = 4*P + 8 - k - hi0bits(word0(d) & Frac_mask);
15272: #else
15272: 		*e = de - Bias - (P-1) + k;
15272: 		*bits = P - k;
15272: #endif
15272: #ifndef Sudden_Underflow
15272: 		}
15272: 	else {
15272: 		*e = de - Bias - (P-1) + 1 + k;
15272: #ifdef Pack_32
15272: 		*bits = 32*i - hi0bits(x[i-1]);
15272: #else
15272: 		*bits = (i+2)*16 - hi0bits(x[i]);
15272: #endif
15272: 		}
15272: #endif
15272: 	return b;
15272: 	}
15272: #undef d0
15272: #undef d1
15272: 
15272:  static double
15272: ratio
15272: #ifdef KR_headers
15272: 	(a, b) Bigint *a, *b;
15272: #else
15272: 	(Bigint *a, Bigint *b)
15272: #endif
15272: {
26462: 	U da, db;
15272: 	int k, ka, kb;
15272: 
15272: 	dval(da) = b2d(a, &ka);
15272: 	dval(db) = b2d(b, &kb);
15272: #ifdef Pack_32
15272: 	k = ka - kb + 32*(a->wds - b->wds);
15272: #else
15272: 	k = ka - kb + 16*(a->wds - b->wds);
15272: #endif
15272: #ifdef IBM
15272: 	if (k > 0) {
15272: 		word0(da) += (k >> 2)*Exp_msk1;
15272: 		if (k &= 3)
15272: 			dval(da) *= 1 << k;
15272: 		}
15272: 	else {
15272: 		k = -k;
15272: 		word0(db) += (k >> 2)*Exp_msk1;
15272: 		if (k &= 3)
15272: 			dval(db) *= 1 << k;
15272: 		}
15272: #else
15272: 	if (k > 0)
15272: 		word0(da) += k*Exp_msk1;
15272: 	else {
15272: 		k = -k;
15272: 		word0(db) += k*Exp_msk1;
15272: 		}
15272: #endif
15272: 	return dval(da) / dval(db);
15272: 	}
15272: 
15272:  static CONST double
15272: tens[] = {
15272: 		1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
15272: 		1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
15272: 		1e20, 1e21, 1e22
15272: #ifdef VAX
15272: 		, 1e23, 1e24
15272: #endif
15272: 		};
15272: 
15272:  static CONST double
15272: #ifdef IEEE_Arith
15272: bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };
15272: static CONST double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128,
15272: #ifdef Avoid_Underflow
15272: 		9007199254740992.*9007199254740992.e-256
15272: 		/* = 2^106 * 1e-53 */
15272: #else
15272: 		1e-256
15272: #endif
15272: 		};
15272: /* The factor of 2^53 in tinytens[4] helps us avoid setting the underflow */
15272: /* flag unnecessarily.  It leads to a song and dance at the end of strtod. */
15272: #define Scale_Bit 0x10
15272: #define n_bigtens 5
15272: #else
15272: #ifdef IBM
15272: bigtens[] = { 1e16, 1e32, 1e64 };
15272: static CONST double tinytens[] = { 1e-16, 1e-32, 1e-64 };
15272: #define n_bigtens 3
15272: #else
15272: bigtens[] = { 1e16, 1e32 };
15272: static CONST double tinytens[] = { 1e-16, 1e-32 };
15272: #define n_bigtens 2
15272: #endif
15272: #endif
15272: 
15272: #ifndef IEEE_Arith
15272: #undef INFNAN_CHECK
15272: #endif
15272: 
15272: #ifdef INFNAN_CHECK
15272: 
15272: #ifndef NAN_WORD0
15272: #define NAN_WORD0 0x7ff80000
15272: #endif
15272: 
15272: #ifndef NAN_WORD1
15272: #define NAN_WORD1 0
15272: #endif
15272: 
15272:  static int
15272: match
15272: #ifdef KR_headers
15272: 	(sp, t) char **sp, *t;
15272: #else
15272: 	(CONST char **sp, char *t)
15272: #endif
15272: {
15272: 	int c, d;
15272: 	CONST char *s = *sp;
15272: 
15272: 	while(d = *t++) {
15272: 		if ((c = *++s) >= 'A' && c <= 'Z')
15272: 			c += 'a' - 'A';
15272: 		if (c != d)
15272: 			return 0;
15272: 		}
15272: 	*sp = s + 1;
15272: 	return 1;
15272: 	}
15272: 
15272: #ifndef No_Hex_NaN
15272:  static void
15272: hexnan
15272: #ifdef KR_headers
15272: 	(rvp, sp) double *rvp; CONST char **sp;
15272: #else
15272: 	(double *rvp, CONST char **sp)
15272: #endif
15272: {
15272: 	ULong c, x[2];
15272: 	CONST char *s;
15272: 	int havedig, udx0, xshift;
15272: 
15272: 	x[0] = x[1] = 0;
15272: 	havedig = xshift = 0;
15272: 	udx0 = 1;
15272: 	s = *sp;
15272: 	while(c = *(CONST unsigned char*)++s) {
15272: 		if (c >= '0' && c <= '9')
15272: 			c -= '0';
15272: 		else if (c >= 'a' && c <= 'f')
15272: 			c += 10 - 'a';
15272: 		else if (c >= 'A' && c <= 'F')
15272: 			c += 10 - 'A';
15272: 		else if (c <= ' ') {
15272: 			if (udx0 && havedig) {
15272: 				udx0 = 0;
15272: 				xshift = 1;
15272: 				}
15272: 			continue;
15272: 			}
15272: 		else if (/*(*/ c == ')' && havedig) {
15272: 			*sp = s + 1;
15272: 			break;
15272: 			}
15272: 		else
15272: 			return;	/* invalid form: don't change *sp */
15272: 		havedig = 1;
15272: 		if (xshift) {
15272: 			xshift = 0;
15272: 			x[0] = x[1];
15272: 			x[1] = 0;
15272: 			}
15272: 		if (udx0)
15272: 			x[0] = (x[0] << 4) | (x[1] >> 28);
15272: 		x[1] = (x[1] << 4) | c;
15272: 		}
15272: 	if ((x[0] &= 0xfffff) || x[1]) {
15272: 		word0(*rvp) = Exp_mask | x[0];
15272: 		word1(*rvp) = x[1];
15272: 		}
15272: 	}
15272: #endif /*No_Hex_NaN*/
15272: #endif /* INFNAN_CHECK */
15272: 
15272:  PR_IMPLEMENT(double)
15272: PR_strtod
15272: #ifdef KR_headers
15272: 	(s00, se) CONST char *s00; char **se;
15272: #else
15272: 	(CONST char *s00, char **se)
15272: #endif
15272: {
15272: #ifdef Avoid_Underflow
15272: 	int scale;
15272: #endif
15272: 	int bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, dsign,
15272: 		 e, e1, esign, i, j, k, nd, nd0, nf, nz, nz0, sign;
15272: 	CONST char *s, *s0, *s1;
26462: 	double aadj, aadj1, adj;
26462: 	U aadj2, rv, rv0;
15272: 	Long L;
15272: 	ULong y, z;
15272: 	Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
15272: #ifdef SET_INEXACT
15272: 	int inexact, oldinexact;
15272: #endif
15272: #ifdef Honor_FLT_ROUNDS
15272: 	int rounding;
15272: #endif
15272: #ifdef USE_LOCALE
15272: 	CONST char *s2;
15272: #endif
15272: 
15272: 	if (!_pr_initialized) _PR_ImplicitInitialization();
15272: 
15272: 	sign = nz0 = nz = 0;
15272: 	dval(rv) = 0.;
15272: 	for(s = s00;;s++) switch(*s) {
15272: 		case '-':
15272: 			sign = 1;
15272: 			/* no break */
15272: 		case '+':
15272: 			if (*++s)
15272: 				goto break2;
15272: 			/* no break */
15272: 		case 0:
15272: 			goto ret0;
15272: 		case '\t':
15272: 		case '\n':
15272: 		case '\v':
15272: 		case '\f':
15272: 		case '\r':
15272: 		case ' ':
15272: 			continue;
15272: 		default:
15272: 			goto break2;
15272: 		}
15272:  break2:
15272: 	if (*s == '0') {
15272: 		nz0 = 1;
15272: 		while(*++s == '0') ;
15272: 		if (!*s)
15272: 			goto ret;
15272: 		}
15272: 	s0 = s;
15272: 	y = z = 0;
15272: 	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
15272: 		if (nd < 9)
15272: 			y = 10*y + c - '0';
15272: 		else if (nd < 16)
15272: 			z = 10*z + c - '0';
15272: 	nd0 = nd;
15272: #ifdef USE_LOCALE
15272: 	s1 = localeconv()->decimal_point;
15272: 	if (c == *s1) {
15272: 		c = '.';
15272: 		if (*++s1) {
15272: 			s2 = s;
15272: 			for(;;) {
15272: 				if (*++s2 != *s1) {
15272: 					c = 0;
15272: 					break;
15272: 					}
15272: 				if (!*++s1) {
15272: 					s = s2;
15272: 					break;
15272: 					}
15272: 				}
15272: 			}
15272: 		}
15272: #endif
15272: 	if (c == '.') {
15272: 		c = *++s;
15272: 		if (!nd) {
15272: 			for(; c == '0'; c = *++s)
15272: 				nz++;
15272: 			if (c > '0' && c <= '9') {
15272: 				s0 = s;
15272: 				nf += nz;
15272: 				nz = 0;
15272: 				goto have_dig;
15272: 				}
15272: 			goto dig_done;
15272: 			}
15272: 		for(; c >= '0' && c <= '9'; c = *++s) {
15272:  have_dig:
15272: 			nz++;
15272: 			if (c -= '0') {
15272: 				nf += nz;
15272: 				for(i = 1; i < nz; i++)
15272: 					if (nd++ < 9)
15272: 						y *= 10;
15272: 					else if (nd <= DBL_DIG + 1)
15272: 						z *= 10;
15272: 				if (nd++ < 9)
15272: 					y = 10*y + c;
15272: 				else if (nd <= DBL_DIG + 1)
15272: 					z = 10*z + c;
15272: 				nz = 0;
15272: 				}
15272: 			}
15272: 		}
15272:  dig_done:
35031: 	if (nd > 64 * 1024)
35031: 		goto ret0;
15272: 	e = 0;
15272: 	if (c == 'e' || c == 'E') {
15272: 		if (!nd && !nz && !nz0) {
15272: 			goto ret0;
15272: 			}
15272: 		s00 = s;
15272: 		esign = 0;
15272: 		switch(c = *++s) {
15272: 			case '-':
15272: 				esign = 1;
15272: 			case '+':
15272: 				c = *++s;
15272: 			}
15272: 		if (c >= '0' && c <= '9') {
15272: 			while(c == '0')
15272: 				c = *++s;
15272: 			if (c > '0' && c <= '9') {
15272: 				L = c - '0';
15272: 				s1 = s;
15272: 				while((c = *++s) >= '0' && c <= '9')
15272: 					L = 10*L + c - '0';
15272: 				if (s - s1 > 8 || L > 19999)
15272: 					/* Avoid confusion from exponents
15272: 					 * so large that e might overflow.
15272: 					 */
15272: 					e = 19999; /* safe for 16 bit ints */
15272: 				else
15272: 					e = (int)L;
15272: 				if (esign)
15272: 					e = -e;
15272: 				}
15272: 			else
15272: 				e = 0;
15272: 			}
15272: 		else
15272: 			s = s00;
15272: 		}
15272: 	if (!nd) {
15272: 		if (!nz && !nz0) {
15272: #ifdef INFNAN_CHECK
15272: 			/* Check for Nan and Infinity */
15272: 			switch(c) {
15272: 			  case 'i':
15272: 			  case 'I':
15272: 				if (match(&s,"nf")) {
15272: 					--s;
15272: 					if (!match(&s,"inity"))
15272: 						++s;
15272: 					word0(rv) = 0x7ff00000;
15272: 					word1(rv) = 0;
15272: 					goto ret;
15272: 					}
15272: 				break;
15272: 			  case 'n':
15272: 			  case 'N':
15272: 				if (match(&s, "an")) {
15272: 					word0(rv) = NAN_WORD0;
15272: 					word1(rv) = NAN_WORD1;
15272: #ifndef No_Hex_NaN
15272: 					if (*s == '(') /*)*/
15272: 						hexnan(&rv, &s);
15272: #endif
15272: 					goto ret;
15272: 					}
15272: 			  }
15272: #endif /* INFNAN_CHECK */
15272:  ret0:
15272: 			s = s00;
15272: 			sign = 0;
15272: 			}
15272: 		goto ret;
15272: 		}
15272: 	e1 = e -= nf;
15272: 
15272: 	/* Now we have nd0 digits, starting at s0, followed by a
15272: 	 * decimal point, followed by nd-nd0 digits.  The number we're
15272: 	 * after is the integer represented by those digits times
15272: 	 * 10**e */
15272: 
15272: 	if (!nd0)
15272: 		nd0 = nd;
15272: 	k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;
15272: 	dval(rv) = y;
15272: 	if (k > 9) {
15272: #ifdef SET_INEXACT
15272: 		if (k > DBL_DIG)
15272: 			oldinexact = get_inexact();
15272: #endif
15272: 		dval(rv) = tens[k - 9] * dval(rv) + z;
15272: 		}
15272: 	bd0 = 0;
15272: 	if (nd <= DBL_DIG
15272: #ifndef RND_PRODQUOT
15272: #ifndef Honor_FLT_ROUNDS
15272: 		&& Flt_Rounds == 1
15272: #endif
15272: #endif
15272: 			) {
15272: 		if (!e)
15272: 			goto ret;
15272: 		if (e > 0) {
15272: 			if (e <= Ten_pmax) {
15272: #ifdef VAX
15272: 				goto vax_ovfl_check;
15272: #else
15272: #ifdef Honor_FLT_ROUNDS
15272: 				/* round correctly FLT_ROUNDS = 2 or 3 */
15272: 				if (sign) {
15272: 					rv = -rv;
15272: 					sign = 0;
15272: 					}
15272: #endif
15272: 				/* rv = */ rounded_product(dval(rv), tens[e]);
15272: 				goto ret;
15272: #endif
15272: 				}
15272: 			i = DBL_DIG - nd;
15272: 			if (e <= Ten_pmax + i) {
15272: 				/* A fancier test would sometimes let us do
15272: 				 * this for larger i values.
15272: 				 */
15272: #ifdef Honor_FLT_ROUNDS
15272: 				/* round correctly FLT_ROUNDS = 2 or 3 */
15272: 				if (sign) {
15272: 					rv = -rv;
15272: 					sign = 0;
15272: 					}
15272: #endif
15272: 				e -= i;
15272: 				dval(rv) *= tens[i];
15272: #ifdef VAX
15272: 				/* VAX exponent range is so narrow we must
15272: 				 * worry about overflow here...
15272: 				 */
15272:  vax_ovfl_check:
15272: 				word0(rv) -= P*Exp_msk1;
15272: 				/* rv = */ rounded_product(dval(rv), tens[e]);
15272: 				if ((word0(rv) & Exp_mask)
15272: 				 > Exp_msk1*(DBL_MAX_EXP+Bias-1-P))
15272: 					goto ovfl;
15272: 				word0(rv) += P*Exp_msk1;
15272: #else
15272: 				/* rv = */ rounded_product(dval(rv), tens[e]);
15272: #endif
15272: 				goto ret;
15272: 				}
15272: 			}
15272: #ifndef Inaccurate_Divide
15272: 		else if (e >= -Ten_pmax) {
15272: #ifdef Honor_FLT_ROUNDS
15272: 			/* round correctly FLT_ROUNDS = 2 or 3 */
15272: 			if (sign) {
15272: 				rv = -rv;
15272: 				sign = 0;
15272: 				}
15272: #endif
15272: 			/* rv = */ rounded_quotient(dval(rv), tens[-e]);
15272: 			goto ret;
15272: 			}
15272: #endif
15272: 		}
15272: 	e1 += nd - k;
15272: 
15272: #ifdef IEEE_Arith
15272: #ifdef SET_INEXACT
15272: 	inexact = 1;
15272: 	if (k <= DBL_DIG)
15272: 		oldinexact = get_inexact();
15272: #endif
15272: #ifdef Avoid_Underflow
15272: 	scale = 0;
15272: #endif
15272: #ifdef Honor_FLT_ROUNDS
15272: 	if ((rounding = Flt_Rounds) >= 2) {
15272: 		if (sign)
15272: 			rounding = rounding == 2 ? 0 : 2;
15272: 		else
15272: 			if (rounding != 2)
15272: 				rounding = 0;
15272: 		}
15272: #endif
15272: #endif /*IEEE_Arith*/
15272: 
15272: 	/* Get starting approximation = rv * 10**e1 */
15272: 
15272: 	if (e1 > 0) {
15272: 		if (i = e1 & 15)
15272: 			dval(rv) *= tens[i];
15272: 		if (e1 &= ~15) {
15272: 			if (e1 > DBL_MAX_10_EXP) {
15272:  ovfl:
15272: #ifndef NO_ERRNO
15272: 				PR_SetError(PR_RANGE_ERROR, 0);
15272: #endif
15272: 				/* Can't trust HUGE_VAL */
15272: #ifdef IEEE_Arith
15272: #ifdef Honor_FLT_ROUNDS
15272: 				switch(rounding) {
15272: 				  case 0: /* toward 0 */
15272: 				  case 3: /* toward -infinity */
15272: 					word0(rv) = Big0;
15272: 					word1(rv) = Big1;
15272: 					break;
15272: 				  default:
15272: 					word0(rv) = Exp_mask;
15272: 					word1(rv) = 0;
15272: 				  }
15272: #else /*Honor_FLT_ROUNDS*/
15272: 				word0(rv) = Exp_mask;
15272: 				word1(rv) = 0;
15272: #endif /*Honor_FLT_ROUNDS*/
15272: #ifdef SET_INEXACT
15272: 				/* set overflow bit */
15272: 				dval(rv0) = 1e300;
15272: 				dval(rv0) *= dval(rv0);
15272: #endif
15272: #else /*IEEE_Arith*/
15272: 				word0(rv) = Big0;
15272: 				word1(rv) = Big1;
15272: #endif /*IEEE_Arith*/
15272: 				if (bd0)
15272: 					goto retfree;
15272: 				goto ret;
15272: 				}
15272: 			e1 >>= 4;
15272: 			for(j = 0; e1 > 1; j++, e1 >>= 1)
15272: 				if (e1 & 1)
15272: 					dval(rv) *= bigtens[j];
15272: 		/* The last multiplication could overflow. */
15272: 			word0(rv) -= P*Exp_msk1;
15272: 			dval(rv) *= bigtens[j];
15272: 			if ((z = word0(rv) & Exp_mask)
15272: 			 > Exp_msk1*(DBL_MAX_EXP+Bias-P))
15272: 				goto ovfl;
15272: 			if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {
15272: 				/* set to largest number */
15272: 				/* (Can't trust DBL_MAX) */
15272: 				word0(rv) = Big0;
15272: 				word1(rv) = Big1;
15272: 				}
15272: 			else
15272: 				word0(rv) += P*Exp_msk1;
15272: 			}
15272: 		}
15272: 	else if (e1 < 0) {
15272: 		e1 = -e1;
15272: 		if (i = e1 & 15)
15272: 			dval(rv) /= tens[i];
15272: 		if (e1 >>= 4) {
15272: 			if (e1 >= 1 << n_bigtens)
15272: 				goto undfl;
15272: #ifdef Avoid_Underflow
15272: 			if (e1 & Scale_Bit)
15272: 				scale = 2*P;
15272: 			for(j = 0; e1 > 0; j++, e1 >>= 1)
15272: 				if (e1 & 1)
15272: 					dval(rv) *= tinytens[j];
15272: 			if (scale && (j = 2*P + 1 - ((word0(rv) & Exp_mask)
15272: 						>> Exp_shift)) > 0) {
15272: 				/* scaled rv is denormal; zap j low bits */
15272: 				if (j >= 32) {
15272: 					word1(rv) = 0;
15272: 					if (j >= 53)
15272: 					 word0(rv) = (P+2)*Exp_msk1;
15272: 					else
15272: 					 word0(rv) &= 0xffffffff << j-32;
15272: 					}
15272: 				else
15272: 					word1(rv) &= 0xffffffff << j;
15272: 				}
15272: #else
15272: 			for(j = 0; e1 > 1; j++, e1 >>= 1)
15272: 				if (e1 & 1)
15272: 					dval(rv) *= tinytens[j];
15272: 			/* The last multiplication could underflow. */
15272: 			dval(rv0) = dval(rv);
15272: 			dval(rv) *= tinytens[j];
15272: 			if (!dval(rv)) {
15272: 				dval(rv) = 2.*dval(rv0);
15272: 				dval(rv) *= tinytens[j];
15272: #endif
15272: 				if (!dval(rv)) {
15272:  undfl:
15272: 					dval(rv) = 0.;
15272: #ifndef NO_ERRNO
15272: 					PR_SetError(PR_RANGE_ERROR, 0);
15272: #endif
15272: 					if (bd0)
15272: 						goto retfree;
15272: 					goto ret;
15272: 					}
15272: #ifndef Avoid_Underflow
15272: 				word0(rv) = Tiny0;
15272: 				word1(rv) = Tiny1;
15272: 				/* The refinement below will clean
15272: 				 * this approximation up.
15272: 				 */
15272: 				}
15272: #endif
15272: 			}
15272: 		}
15272: 
15272: 	/* Now the hard part -- adjusting rv to the correct value.*/
15272: 
15272: 	/* Put digits into bd: true value = bd * 10^e */
15272: 
15272: 	bd0 = s2b(s0, nd0, nd, y);
15272: 
15272: 	for(;;) {
15272: 		bd = Balloc(bd0->k);
15272: 		Bcopy(bd, bd0);
15272: 		bb = d2b(dval(rv), &bbe, &bbbits);	/* rv = bb * 2^bbe */
15272: 		bs = i2b(1);
15272: 
15272: 		if (e >= 0) {
15272: 			bb2 = bb5 = 0;
15272: 			bd2 = bd5 = e;
15272: 			}
15272: 		else {
15272: 			bb2 = bb5 = -e;
15272: 			bd2 = bd5 = 0;
15272: 			}
15272: 		if (bbe >= 0)
15272: 			bb2 += bbe;
15272: 		else
15272: 			bd2 -= bbe;
15272: 		bs2 = bb2;
15272: #ifdef Honor_FLT_ROUNDS
15272: 		if (rounding != 1)
15272: 			bs2++;
15272: #endif
15272: #ifdef Avoid_Underflow
15272: 		j = bbe - scale;
15272: 		i = j + bbbits - 1;	/* logb(rv) */
15272: 		if (i < Emin)	/* denormal */
15272: 			j += P - Emin;
15272: 		else
15272: 			j = P + 1 - bbbits;
15272: #else /*Avoid_Underflow*/
15272: #ifdef Sudden_Underflow
15272: #ifdef IBM
15272: 		j = 1 + 4*P - 3 - bbbits + ((bbe + bbbits - 1) & 3);
15272: #else
15272: 		j = P + 1 - bbbits;
15272: #endif
15272: #else /*Sudden_Underflow*/
15272: 		j = bbe;
15272: 		i = j + bbbits - 1;	/* logb(rv) */
15272: 		if (i < Emin)	/* denormal */
15272: 			j += P - Emin;
15272: 		else
15272: 			j = P + 1 - bbbits;
15272: #endif /*Sudden_Underflow*/
15272: #endif /*Avoid_Underflow*/
15272: 		bb2 += j;
15272: 		bd2 += j;
15272: #ifdef Avoid_Underflow
15272: 		bd2 += scale;
15272: #endif
15272: 		i = bb2 < bd2 ? bb2 : bd2;
15272: 		if (i > bs2)
15272: 			i = bs2;
15272: 		if (i > 0) {
15272: 			bb2 -= i;
15272: 			bd2 -= i;
15272: 			bs2 -= i;
15272: 			}
15272: 		if (bb5 > 0) {
15272: 			bs = pow5mult(bs, bb5);
15272: 			bb1 = mult(bs, bb);
15272: 			Bfree(bb);
15272: 			bb = bb1;
15272: 			}
15272: 		if (bb2 > 0)
15272: 			bb = lshift(bb, bb2);
15272: 		if (bd5 > 0)
15272: 			bd = pow5mult(bd, bd5);
15272: 		if (bd2 > 0)
15272: 			bd = lshift(bd, bd2);
15272: 		if (bs2 > 0)
15272: 			bs = lshift(bs, bs2);
15272: 		delta = diff(bb, bd);
15272: 		dsign = delta->sign;
15272: 		delta->sign = 0;
15272: 		i = cmp(delta, bs);
15272: #ifdef Honor_FLT_ROUNDS
15272: 		if (rounding != 1) {
15272: 			if (i < 0) {
15272: 				/* Error is less than an ulp */
15272: 				if (!delta->x[0] && delta->wds <= 1) {
15272: 					/* exact */
15272: #ifdef SET_INEXACT
15272: 					inexact = 0;
15272: #endif
15272: 					break;
15272: 					}
15272: 				if (rounding) {
15272: 					if (dsign) {
15272: 						adj = 1.;
15272: 						goto apply_adj;
15272: 						}
15272: 					}
15272: 				else if (!dsign) {
15272: 					adj = -1.;
15272: 					if (!word1(rv)
15272: 					 && !(word0(rv) & Frac_mask)) {
15272: 						y = word0(rv) & Exp_mask;
15272: #ifdef Avoid_Underflow
15272: 						if (!scale || y > 2*P*Exp_msk1)
15272: #else
15272: 						if (y)
15272: #endif
15272: 						  {
15272: 						  delta = lshift(delta,Log2P);
15272: 						  if (cmp(delta, bs) <= 0)
15272: 							adj = -0.5;
15272: 						  }
15272: 						}
15272:  apply_adj:
15272: #ifdef Avoid_Underflow
15272: 					if (scale && (y = word0(rv) & Exp_mask)
15272: 						<= 2*P*Exp_msk1)
15272: 					  word0(adj) += (2*P+1)*Exp_msk1 - y;
15272: #else
15272: #ifdef Sudden_Underflow
15272: 					if ((word0(rv) & Exp_mask) <=
15272: 							P*Exp_msk1) {
15272: 						word0(rv) += P*Exp_msk1;
15272: 						dval(rv) += adj*ulp(dval(rv));
15272: 						word0(rv) -= P*Exp_msk1;
15272: 						}
15272: 					else
15272: #endif /*Sudden_Underflow*/
15272: #endif /*Avoid_Underflow*/
15272: 					dval(rv) += adj*ulp(dval(rv));
15272: 					}
15272: 				break;
15272: 				}
15272: 			adj = ratio(delta, bs);
15272: 			if (adj < 1.)
15272: 				adj = 1.;
15272: 			if (adj <= 0x7ffffffe) {
15272: 				/* adj = rounding ? ceil(adj) : floor(adj); */
15272: 				y = adj;
15272: 				if (y != adj) {
15272: 					if (!((rounding>>1) ^ dsign))
15272: 						y++;
15272: 					adj = y;
15272: 					}
15272: 				}
15272: #ifdef Avoid_Underflow
15272: 			if (scale && (y = word0(rv) & Exp_mask) <= 2*P*Exp_msk1)
15272: 				word0(adj) += (2*P+1)*Exp_msk1 - y;
15272: #else
15272: #ifdef Sudden_Underflow
15272: 			if ((word0(rv) & Exp_mask) <= P*Exp_msk1) {
15272: 				word0(rv) += P*Exp_msk1;
15272: 				adj *= ulp(dval(rv));
15272: 				if (dsign)
15272: 					dval(rv) += adj;
15272: 				else
15272: 					dval(rv) -= adj;
15272: 				word0(rv) -= P*Exp_msk1;
15272: 				goto cont;
15272: 				}
15272: #endif /*Sudden_Underflow*/
15272: #endif /*Avoid_Underflow*/
15272: 			adj *= ulp(dval(rv));
15272: 			if (dsign)
15272: 				dval(rv) += adj;
15272: 			else
15272: 				dval(rv) -= adj;
15272: 			goto cont;
15272: 			}
15272: #endif /*Honor_FLT_ROUNDS*/
15272: 
15272: 		if (i < 0) {
15272: 			/* Error is less than half an ulp -- check for
15272: 			 * special case of mantissa a power of two.
15272: 			 */
15272: 			if (dsign || word1(rv) || word0(rv) & Bndry_mask
15272: #ifdef IEEE_Arith
15272: #ifdef Avoid_Underflow
15272: 			 || (word0(rv) & Exp_mask) <= (2*P+1)*Exp_msk1
15272: #else
15272: 			 || (word0(rv) & Exp_mask) <= Exp_msk1
15272: #endif
15272: #endif
15272: 				) {
15272: #ifdef SET_INEXACT
15272: 				if (!delta->x[0] && delta->wds <= 1)
15272: 					inexact = 0;
15272: #endif
15272: 				break;
15272: 				}
15272: 			if (!delta->x[0] && delta->wds <= 1) {
15272: 				/* exact result */
15272: #ifdef SET_INEXACT
15272: 				inexact = 0;
15272: #endif
15272: 				break;
15272: 				}
15272: 			delta = lshift(delta,Log2P);
15272: 			if (cmp(delta, bs) > 0)
15272: 				goto drop_down;
15272: 			break;
15272: 			}
15272: 		if (i == 0) {
15272: 			/* exactly half-way between */
15272: 			if (dsign) {
15272: 				if ((word0(rv) & Bndry_mask1) == Bndry_mask1
15272: 				 &&  word1(rv) == (
15272: #ifdef Avoid_Underflow
15272: 			(scale && (y = word0(rv) & Exp_mask) <= 2*P*Exp_msk1)
15272: 		? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
15272: #endif
15272: 						   0xffffffff)) {
15272: 					/*boundary case -- increment exponent*/
15272: 					word0(rv) = (word0(rv) & Exp_mask)
15272: 						+ Exp_msk1
15272: #ifdef IBM
15272: 						| Exp_msk1 >> 4
15272: #endif
15272: 						;
15272: 					word1(rv) = 0;
15272: #ifdef Avoid_Underflow
15272: 					dsign = 0;
15272: #endif
15272: 					break;
15272: 					}
15272: 				}
15272: 			else if (!(word0(rv) & Bndry_mask) && !word1(rv)) {
15272:  drop_down:
15272: 				/* boundary case -- decrement exponent */
15272: #ifdef Sudden_Underflow /*{{*/
15272: 				L = word0(rv) & Exp_mask;
15272: #ifdef IBM
15272: 				if (L <  Exp_msk1)
15272: #else
15272: #ifdef Avoid_Underflow
15272: 				if (L <= (scale ? (2*P+1)*Exp_msk1 : Exp_msk1))
15272: #else
15272: 				if (L <= Exp_msk1)
15272: #endif /*Avoid_Underflow*/
15272: #endif /*IBM*/
15272: 					goto undfl;
15272: 				L -= Exp_msk1;
15272: #else /*Sudden_Underflow}{*/
15272: #ifdef Avoid_Underflow
15272: 				if (scale) {
15272: 					L = word0(rv) & Exp_mask;
15272: 					if (L <= (2*P+1)*Exp_msk1) {
15272: 						if (L > (P+2)*Exp_msk1)
15272: 							/* round even ==> */
15272: 							/* accept rv */
15272: 							break;
15272: 						/* rv = smallest denormal */
15272: 						goto undfl;
15272: 						}
15272: 					}
15272: #endif /*Avoid_Underflow*/
15272: 				L = (word0(rv) & Exp_mask) - Exp_msk1;
15272: #endif /*Sudden_Underflow}}*/
15272: 				word0(rv) = L | Bndry_mask1;
15272: 				word1(rv) = 0xffffffff;
15272: #ifdef IBM
15272: 				goto cont;
15272: #else
15272: 				break;
15272: #endif
15272: 				}
15272: #ifndef ROUND_BIASED
15272: 			if (!(word1(rv) & LSB))
15272: 				break;
15272: #endif
15272: 			if (dsign)
15272: 				dval(rv) += ulp(dval(rv));
15272: #ifndef ROUND_BIASED
15272: 			else {
15272: 				dval(rv) -= ulp(dval(rv));
15272: #ifndef Sudden_Underflow
15272: 				if (!dval(rv))
15272: 					goto undfl;
15272: #endif
15272: 				}
15272: #ifdef Avoid_Underflow
15272: 			dsign = 1 - dsign;
15272: #endif
15272: #endif
15272: 			break;
15272: 			}
15272: 		if ((aadj = ratio(delta, bs)) <= 2.) {
15272: 			if (dsign)
15272: 				aadj = aadj1 = 1.;
15272: 			else if (word1(rv) || word0(rv) & Bndry_mask) {
15272: #ifndef Sudden_Underflow
15272: 				if (word1(rv) == Tiny1 && !word0(rv))
15272: 					goto undfl;
15272: #endif
15272: 				aadj = 1.;
15272: 				aadj1 = -1.;
15272: 				}
15272: 			else {
15272: 				/* special case -- power of FLT_RADIX to be */
15272: 				/* rounded down... */
15272: 
15272: 				if (aadj < 2./FLT_RADIX)
15272: 					aadj = 1./FLT_RADIX;
15272: 				else
15272: 					aadj *= 0.5;
15272: 				aadj1 = -aadj;
15272: 				}
15272: 			}
15272: 		else {
15272: 			aadj *= 0.5;
15272: 			aadj1 = dsign ? aadj : -aadj;
15272: #ifdef Check_FLT_ROUNDS
15272: 			switch(Rounding) {
15272: 				case 2: /* towards +infinity */
15272: 					aadj1 -= 0.5;
15272: 					break;
15272: 				case 0: /* towards 0 */
15272: 				case 3: /* towards -infinity */
15272: 					aadj1 += 0.5;
15272: 				}
15272: #else
15272: 			if (Flt_Rounds == 0)
15272: 				aadj1 += 0.5;
15272: #endif /*Check_FLT_ROUNDS*/
15272: 			}
15272: 		y = word0(rv) & Exp_mask;
15272: 
15272: 		/* Check for overflow */
15272: 
15272: 		if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {
15272: 			dval(rv0) = dval(rv);
15272: 			word0(rv) -= P*Exp_msk1;
15272: 			adj = aadj1 * ulp(dval(rv));
15272: 			dval(rv) += adj;
15272: 			if ((word0(rv) & Exp_mask) >=
15272: 					Exp_msk1*(DBL_MAX_EXP+Bias-P)) {
15272: 				if (word0(rv0) == Big0 && word1(rv0) == Big1)
15272: 					goto ovfl;
15272: 				word0(rv) = Big0;
15272: 				word1(rv) = Big1;
15272: 				goto cont;
15272: 				}
15272: 			else
15272: 				word0(rv) += P*Exp_msk1;
15272: 			}
15272: 		else {
15272: #ifdef Avoid_Underflow
15272: 			if (scale && y <= 2*P*Exp_msk1) {
15272: 				if (aadj <= 0x7fffffff) {
15272: 					if ((z = aadj) <= 0)
15272: 						z = 1;
15272: 					aadj = z;
15272: 					aadj1 = dsign ? aadj : -aadj;
15272: 					}
26462: 				dval(aadj2) = aadj1;
26462: 				word0(aadj2) += (2*P+1)*Exp_msk1 - y;
26462: 				aadj1 = dval(aadj2);
15272: 				}
15272: 			adj = aadj1 * ulp(dval(rv));
15272: 			dval(rv) += adj;
15272: #else
15272: #ifdef Sudden_Underflow
15272: 			if ((word0(rv) & Exp_mask) <= P*Exp_msk1) {
15272: 				dval(rv0) = dval(rv);
15272: 				word0(rv) += P*Exp_msk1;
15272: 				adj = aadj1 * ulp(dval(rv));
15272: 				dval(rv) += adj;
15272: #ifdef IBM
15272: 				if ((word0(rv) & Exp_mask) <  P*Exp_msk1)
15272: #else
15272: 				if ((word0(rv) & Exp_mask) <= P*Exp_msk1)
15272: #endif
15272: 					{
15272: 					if (word0(rv0) == Tiny0
15272: 					 && word1(rv0) == Tiny1)
15272: 						goto undfl;
15272: 					word0(rv) = Tiny0;
15272: 					word1(rv) = Tiny1;
15272: 					goto cont;
15272: 					}
15272: 				else
15272: 					word0(rv) -= P*Exp_msk1;
15272: 				}
15272: 			else {
15272: 				adj = aadj1 * ulp(dval(rv));
15272: 				dval(rv) += adj;
15272: 				}
15272: #else /*Sudden_Underflow*/
15272: 			/* Compute adj so that the IEEE rounding rules will
15272: 			 * correctly round rv + adj in some half-way cases.
15272: 			 * If rv * ulp(rv) is denormalized (i.e.,
15272: 			 * y <= (P-1)*Exp_msk1), we must adjust aadj to avoid
15272: 			 * trouble from bits lost to denormalization;
15272: 			 * example: 1.2e-307 .
15272: 			 */
15272: 			if (y <= (P-1)*Exp_msk1 && aadj > 1.) {
15272: 				aadj1 = (double)(int)(aadj + 0.5);
15272: 				if (!dsign)
15272: 					aadj1 = -aadj1;
15272: 				}
15272: 			adj = aadj1 * ulp(dval(rv));
15272: 			dval(rv) += adj;
15272: #endif /*Sudden_Underflow*/
15272: #endif /*Avoid_Underflow*/
15272: 			}
15272: 		z = word0(rv) & Exp_mask;
15272: #ifndef SET_INEXACT
15272: #ifdef Avoid_Underflow
15272: 		if (!scale)
15272: #endif
15272: 		if (y == z) {
15272: 			/* Can we stop now? */
15272: 			L = (Long)aadj;
15272: 			aadj -= L;
15272: 			/* The tolerances below are conservative. */
15272: 			if (dsign || word1(rv) || word0(rv) & Bndry_mask) {
15272: 				if (aadj < .4999999 || aadj > .5000001)
15272: 					break;
15272: 				}
15272: 			else if (aadj < .4999999/FLT_RADIX)
15272: 				break;
15272: 			}
15272: #endif
15272:  cont:
15272: 		Bfree(bb);
15272: 		Bfree(bd);
15272: 		Bfree(bs);
15272: 		Bfree(delta);
15272: 		}
15272: #ifdef SET_INEXACT
15272: 	if (inexact) {
15272: 		if (!oldinexact) {
15272: 			word0(rv0) = Exp_1 + (70 << Exp_shift);
15272: 			word1(rv0) = 0;
15272: 			dval(rv0) += 1.;
15272: 			}
15272: 		}
15272: 	else if (!oldinexact)
15272: 		clear_inexact();
15272: #endif
15272: #ifdef Avoid_Underflow
15272: 	if (scale) {
15272: 		word0(rv0) = Exp_1 - 2*P*Exp_msk1;
15272: 		word1(rv0) = 0;
15272: 		dval(rv) *= dval(rv0);
15272: #ifndef NO_ERRNO
15272: 		/* try to avoid the bug of testing an 8087 register value */
15272: 		if (word0(rv) == 0 && word1(rv) == 0)
15272: 			PR_SetError(PR_RANGE_ERROR, 0);
15272: #endif
15272: 		}
15272: #endif /* Avoid_Underflow */
15272: #ifdef SET_INEXACT
15272: 	if (inexact && !(word0(rv) & Exp_mask)) {
15272: 		/* set underflow bit */
15272: 		dval(rv0) = 1e-300;
15272: 		dval(rv0) *= dval(rv0);
15272: 		}
15272: #endif
15272:  retfree:
15272: 	Bfree(bb);
15272: 	Bfree(bd);
15272: 	Bfree(bs);
15272: 	Bfree(bd0);
15272: 	Bfree(delta);
15272:  ret:
15272: 	if (se)
15272: 		*se = (char *)s;
15272: 	return sign ? -dval(rv) : dval(rv);
15272: 	}
15272: 
15272:  static int
15272: quorem
15272: #ifdef KR_headers
15272: 	(b, S) Bigint *b, *S;
15272: #else
15272: 	(Bigint *b, Bigint *S)
15272: #endif
15272: {
15272: 	int n;
15272: 	ULong *bx, *bxe, q, *sx, *sxe;
15272: #ifdef ULLong
15272: 	ULLong borrow, carry, y, ys;
15272: #else
15272: 	ULong borrow, carry, y, ys;
15272: #ifdef Pack_32
15272: 	ULong si, z, zs;
15272: #endif
15272: #endif
15272: 
15272: 	n = S->wds;
15272: #ifdef DEBUG
15272: 	/*debug*/ if (b->wds > n)
15272: 	/*debug*/	Bug("oversize b in quorem");
15272: #endif
15272: 	if (b->wds < n)
15272: 		return 0;
15272: 	sx = S->x;
15272: 	sxe = sx + --n;
15272: 	bx = b->x;
15272: 	bxe = bx + n;
15272: 	q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
15272: #ifdef DEBUG
15272: 	/*debug*/ if (q > 9)
15272: 	/*debug*/	Bug("oversized quotient in quorem");
15272: #endif
15272: 	if (q) {
15272: 		borrow = 0;
15272: 		carry = 0;
15272: 		do {
15272: #ifdef ULLong
15272: 			ys = *sx++ * (ULLong)q + carry;
15272: 			carry = ys >> 32;
15272: 			y = *bx - (ys & FFFFFFFF) - borrow;
15272: 			borrow = y >> 32 & (ULong)1;
15272: 			*bx++ = y & FFFFFFFF;
15272: #else
15272: #ifdef Pack_32
15272: 			si = *sx++;
15272: 			ys = (si & 0xffff) * q + carry;
15272: 			zs = (si >> 16) * q + (ys >> 16);
15272: 			carry = zs >> 16;
15272: 			y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
15272: 			borrow = (y & 0x10000) >> 16;
15272: 			z = (*bx >> 16) - (zs & 0xffff) - borrow;
15272: 			borrow = (z & 0x10000) >> 16;
15272: 			Storeinc(bx, z, y);
15272: #else
15272: 			ys = *sx++ * q + carry;
15272: 			carry = ys >> 16;
15272: 			y = *bx - (ys & 0xffff) - borrow;
15272: 			borrow = (y & 0x10000) >> 16;
15272: 			*bx++ = y & 0xffff;
15272: #endif
15272: #endif
15272: 			}
15272: 			while(sx <= sxe);
15272: 		if (!*bxe) {
15272: 			bx = b->x;
15272: 			while(--bxe > bx && !*bxe)
15272: 				--n;
15272: 			b->wds = n;
15272: 			}
15272: 		}
15272: 	if (cmp(b, S) >= 0) {
15272: 		q++;
15272: 		borrow = 0;
15272: 		carry = 0;
15272: 		bx = b->x;
15272: 		sx = S->x;
15272: 		do {
15272: #ifdef ULLong
15272: 			ys = *sx++ + carry;
15272: 			carry = ys >> 32;
15272: 			y = *bx - (ys & FFFFFFFF) - borrow;
15272: 			borrow = y >> 32 & (ULong)1;
15272: 			*bx++ = y & FFFFFFFF;
15272: #else
15272: #ifdef Pack_32
15272: 			si = *sx++;
15272: 			ys = (si & 0xffff) + carry;
15272: 			zs = (si >> 16) + (ys >> 16);
15272: 			carry = zs >> 16;
15272: 			y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
15272: 			borrow = (y & 0x10000) >> 16;
15272: 			z = (*bx >> 16) - (zs & 0xffff) - borrow;
15272: 			borrow = (z & 0x10000) >> 16;
15272: 			Storeinc(bx, z, y);
15272: #else
15272: 			ys = *sx++ + carry;
15272: 			carry = ys >> 16;
15272: 			y = *bx - (ys & 0xffff) - borrow;
15272: 			borrow = (y & 0x10000) >> 16;
15272: 			*bx++ = y & 0xffff;
15272: #endif
15272: #endif
15272: 			}
15272: 			while(sx <= sxe);
15272: 		bx = b->x;
15272: 		bxe = bx + n;
15272: 		if (!*bxe) {
15272: 			while(--bxe > bx && !*bxe)
15272: 				--n;
15272: 			b->wds = n;
15272: 			}
15272: 		}
15272: 	return q;
15272: 	}
15272: 
15272: #ifndef MULTIPLE_THREADS
15272:  static char *dtoa_result;
15272: #endif
15272: 
15272:  static char *
15272: #ifdef KR_headers
15272: rv_alloc(i) int i;
15272: #else
15272: rv_alloc(int i)
15272: #endif
15272: {
15272: 	int j, k, *r;
15272: 
15272: 	j = sizeof(ULong);
15272: 	for(k = 0;
15272: 		sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= i;
15272: 		j <<= 1)
15272: 			k++;
15272: 	r = (int*)Balloc(k);
15272: 	*r = k;
15272: 	return
15272: #ifndef MULTIPLE_THREADS
15272: 	dtoa_result =
15272: #endif
15272: 		(char *)(r+1);
15272: 	}
15272: 
15272:  static char *
15272: #ifdef KR_headers
15272: nrv_alloc(s, rve, n) char *s, **rve; int n;
15272: #else
15272: nrv_alloc(char *s, char **rve, int n)
15272: #endif
15272: {
15272: 	char *rv, *t;
15272: 
15272: 	t = rv = rv_alloc(n);
15272: 	while(*t = *s++) t++;
15272: 	if (rve)
15272: 		*rve = t;
15272: 	return rv;
15272: 	}
15272: 
15272: /* freedtoa(s) must be used to free values s returned by dtoa
15272:  * when MULTIPLE_THREADS is #defined.  It should be used in all cases,
15272:  * but for consistency with earlier versions of dtoa, it is optional
15272:  * when MULTIPLE_THREADS is not defined.
15272:  */
15272: 
37155:  static void
15272: #ifdef KR_headers
15272: freedtoa(s) char *s;
15272: #else
15272: freedtoa(char *s)
15272: #endif
15272: {
15272: 	Bigint *b = (Bigint *)((int *)s - 1);
15272: 	b->maxwds = 1 << (b->k = *(int*)b);
15272: 	Bfree(b);
15272: #ifndef MULTIPLE_THREADS
15272: 	if (s == dtoa_result)
15272: 		dtoa_result = 0;
15272: #endif
15272: 	}
15272: 
15272: /* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.
15272:  *
15272:  * Inspired by "How to Print Floating-Point Numbers Accurately" by
15272:  * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 112-126].
15272:  *
15272:  * Modifications:
15272:  *	1. Rather than iterating, we use a simple numeric overestimate
15272:  *	   to determine k = floor(log10(d)).  We scale relevant
15272:  *	   quantities using O(log2(k)) rather than O(k) multiplications.
15272:  *	2. For some modes > 2 (corresponding to ecvt and fcvt), we don't
15272:  *	   try to generate digits strictly left to right.  Instead, we
15272:  *	   compute with fewer bits and propagate the carry if necessary
15272:  *	   when rounding the final digit up.  This is often faster.
15272:  *	3. Under the assumption that input will be rounded nearest,
15272:  *	   mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.
15272:  *	   That is, we allow equality in stopping tests when the
15272:  *	   round-nearest rule will give the same floating-point value
15272:  *	   as would satisfaction of the stopping test with strict
15272:  *	   inequality.
15272:  *	4. We remove common factors of powers of 2 from relevant
15272:  *	   quantities.
15272:  *	5. When converting floating-point integers less than 1e16,
15272:  *	   we use floating-point arithmetic rather than resorting
15272:  *	   to multiple-precision integers.
15272:  *	6. When asked to produce fewer than 15 digits, we first try
15272:  *	   to get by with floating-point arithmetic; we resort to
15272:  *	   multiple-precision integer arithmetic only if we cannot
15272:  *	   guarantee that the floating-point calculation has given
15272:  *	   the correctly rounded result.  For k requested digits and
15272:  *	   "uniformly" distributed input, the probability is
15272:  *	   something like 10^(k-15) that we must resort to the Long
15272:  *	   calculation.
15272:  */
15272: 
15272:  static char *
15272: dtoa
15272: #ifdef KR_headers
26462: 	(dd, mode, ndigits, decpt, sign, rve)
26462: 	double dd; int mode, ndigits, *decpt, *sign; char **rve;
15272: #else
26462: 	(double dd, int mode, int ndigits, int *decpt, int *sign, char **rve)
15272: #endif
15272: {
15272:  /*	Arguments ndigits, decpt, sign are similar to those
15272: 	of ecvt and fcvt; trailing zeros are suppressed from
15272: 	the returned string.  If not null, *rve is set to point
15272: 	to the end of the return value.  If d is +-Infinity or NaN,
15272: 	then *decpt is set to 9999.
15272: 
15272: 	mode:
15272: 		0 ==> shortest string that yields d when read in
15272: 			and rounded to nearest.
15272: 		1 ==> like 0, but with Steele & White stopping rule;
15272: 			e.g. with IEEE P754 arithmetic , mode 0 gives
15272: 			1e23 whereas mode 1 gives 9.999999999999999e22.
15272: 		2 ==> max(1,ndigits) significant digits.  This gives a
15272: 			return value similar to that of ecvt, except
15272: 			that trailing zeros are suppressed.
15272: 		3 ==> through ndigits past the decimal point.  This
15272: 			gives a return value similar to that from fcvt,
15272: 			except that trailing zeros are suppressed, and
15272: 			ndigits can be negative.
15272: 		4,5 ==> similar to 2 and 3, respectively, but (in
15272: 			round-nearest mode) with the tests of mode 0 to
15272: 			possibly return a shorter string that rounds to d.
15272: 			With IEEE arithmetic and compilation with
15272: 			-DHonor_FLT_ROUNDS, modes 4 and 5 behave the same
15272: 			as modes 2 and 3 when FLT_ROUNDS != 1.
15272: 		6-9 ==> Debugging modes similar to mode - 4:  don't try
15272: 			fast floating-point estimate (if applicable).
15272: 
15272: 		Values of mode other than 0-9 are treated as mode 0.
15272: 
15272: 		Sufficient space is allocated to the return value
15272: 		to hold the suppressed trailing zeros.
15272: 	*/
15272: 
15272: 	int bbits, b2, b5, be, dig, i, ieps, ilim, ilim0, ilim1,
15272: 		j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,
15272: 		spec_case, try_quick;
15272: 	Long L;
15272: #ifndef Sudden_Underflow
15272: 	int denorm;
15272: 	ULong x;
15272: #endif
15272: 	Bigint *b, *b1, *delta, *mlo, *mhi, *S;
26462: 	U d, d2, eps;
26462: 	double ds;
15272: 	char *s, *s0;
15272: #ifdef Honor_FLT_ROUNDS
15272: 	int rounding;
15272: #endif
15272: #ifdef SET_INEXACT
15272: 	int inexact, oldinexact;
15272: #endif
15272: 
15272: #ifndef MULTIPLE_THREADS
15272: 	if (dtoa_result) {
15272: 		freedtoa(dtoa_result);
15272: 		dtoa_result = 0;
15272: 		}
15272: #endif
15272: 
26462: 	dval(d) = dd;
15272: 	if (word0(d) & Sign_bit) {
15272: 		/* set sign for everything, including 0's and NaNs */
15272: 		*sign = 1;
15272: 		word0(d) &= ~Sign_bit;	/* clear sign bit */
15272: 		}
15272: 	else
15272: 		*sign = 0;
15272: 
15272: #if defined(IEEE_Arith) + defined(VAX)
15272: #ifdef IEEE_Arith
15272: 	if ((word0(d) & Exp_mask) == Exp_mask)
15272: #else
15272: 	if (word0(d)  == 0x8000)
15272: #endif
15272: 		{
15272: 		/* Infinity or NaN */
15272: 		*decpt = 9999;
15272: #ifdef IEEE_Arith
15272: 		if (!word1(d) && !(word0(d) & 0xfffff))
15272: 			return nrv_alloc("Infinity", rve, 8);
15272: #endif
15272: 		return nrv_alloc("NaN", rve, 3);
15272: 		}
15272: #endif
15272: #ifdef IBM
15272: 	dval(d) += 0; /* normalize */
15272: #endif
15272: 	if (!dval(d)) {
15272: 		*decpt = 1;
15272: 		return nrv_alloc("0", rve, 1);
15272: 		}
15272: 
15272: #ifdef SET_INEXACT
15272: 	try_quick = oldinexact = get_inexact();
15272: 	inexact = 1;
15272: #endif
15272: #ifdef Honor_FLT_ROUNDS
15272: 	if ((rounding = Flt_Rounds) >= 2) {
15272: 		if (*sign)
15272: 			rounding = rounding == 2 ? 0 : 2;
15272: 		else
15272: 			if (rounding != 2)
15272: 				rounding = 0;
15272: 		}
15272: #endif
15272: 
15272: 	b = d2b(dval(d), &be, &bbits);
15272: #ifdef Sudden_Underflow
15272: 	i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1));
15272: #else
15272: 	if (i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1))) {
15272: #endif
15272: 		dval(d2) = dval(d);
15272: 		word0(d2) &= Frac_mask1;
15272: 		word0(d2) |= Exp_11;
15272: #ifdef IBM
15272: 		if (j = 11 - hi0bits(word0(d2) & Frac_mask))
15272: 			dval(d2) /= 1 << j;
15272: #endif
15272: 
15272: 		/* log(x)	~=~ log(1.5) + (x-1.5)/1.5
15272: 		 * log10(x)	 =  log(x) / log(10)
15272: 		 *		~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
15272: 		 * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)
15272: 		 *
15272: 		 * This suggests computing an approximation k to log10(d) by
15272: 		 *
15272: 		 * k = (i - Bias)*0.301029995663981
15272: 		 *	+ ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );
15272: 		 *
15272: 		 * We want k to be too large rather than too small.
15272: 		 * The error in the first-order Taylor series approximation
15272: 		 * is in our favor, so we just round up the constant enough
15272: 		 * to compensate for any error in the multiplication of
15272: 		 * (i - Bias) by 0.301029995663981; since |i - Bias| <= 1077,
15272: 		 * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,
15272: 		 * adding 1e-13 to the constant term more than suffices.
15272: 		 * Hence we adjust the constant term to 0.1760912590558.
15272: 		 * (We could get a more accurate k by invoking log10,
15272: 		 *  but this is probably not worthwhile.)
15272: 		 */
15272: 
15272: 		i -= Bias;
15272: #ifdef IBM
15272: 		i <<= 2;
15272: 		i += j;
15272: #endif
15272: #ifndef Sudden_Underflow
15272: 		denorm = 0;
15272: 		}
15272: 	else {
15272: 		/* d is denormalized */
15272: 
15272: 		i = bbits + be + (Bias + (P-1) - 1);
15272: 		x = i > 32  ? word0(d) << 64 - i | word1(d) >> i - 32
15272: 			    : word1(d) << 32 - i;
15272: 		dval(d2) = x;
15272: 		word0(d2) -= 31*Exp_msk1; /* adjust exponent */
15272: 		i -= (Bias + (P-1) - 1) + 1;
15272: 		denorm = 1;
15272: 		}
15272: #endif
15272: 	ds = (dval(d2)-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;
15272: 	k = (int)ds;
15272: 	if (ds < 0. && ds != k)
15272: 		k--;	/* want k = floor(ds) */
15272: 	k_check = 1;
15272: 	if (k >= 0 && k <= Ten_pmax) {
15272: 		if (dval(d) < tens[k])
15272: 			k--;
15272: 		k_check = 0;
15272: 		}
15272: 	j = bbits - i - 1;
15272: 	if (j >= 0) {
15272: 		b2 = 0;
15272: 		s2 = j;
15272: 		}
15272: 	else {
15272: 		b2 = -j;
15272: 		s2 = 0;
15272: 		}
15272: 	if (k >= 0) {
15272: 		b5 = 0;
15272: 		s5 = k;
15272: 		s2 += k;
15272: 		}
15272: 	else {
15272: 		b2 -= k;
15272: 		b5 = -k;
15272: 		s5 = 0;
15272: 		}
15272: 	if (mode < 0 || mode > 9)
15272: 		mode = 0;
15272: 
15272: #ifndef SET_INEXACT
15272: #ifdef Check_FLT_ROUNDS
15272: 	try_quick = Rounding == 1;
15272: #else
15272: 	try_quick = 1;
15272: #endif
15272: #endif /*SET_INEXACT*/
15272: 
15272: 	if (mode > 5) {
15272: 		mode -= 4;
15272: 		try_quick = 0;
15272: 		}
15272: 	leftright = 1;
15272: 	switch(mode) {
15272: 		case 0:
15272: 		case 1:
15272: 			ilim = ilim1 = -1;
15272: 			i = 18;
15272: 			ndigits = 0;
15272: 			break;
15272: 		case 2:
15272: 			leftright = 0;
15272: 			/* no break */
15272: 		case 4:
15272: 			if (ndigits <= 0)
15272: 				ndigits = 1;
15272: 			ilim = ilim1 = i = ndigits;
15272: 			break;
15272: 		case 3:
15272: 			leftright = 0;
15272: 			/* no break */
15272: 		case 5:
15272: 			i = ndigits + k + 1;
15272: 			ilim = i;
15272: 			ilim1 = i - 1;
15272: 			if (i <= 0)
15272: 				i = 1;
15272: 		}
15272: 	s = s0 = rv_alloc(i);
15272: 
15272: #ifdef Honor_FLT_ROUNDS
15272: 	if (mode > 1 && rounding != 1)
15272: 		leftright = 0;
15272: #endif
15272: 
15272: 	if (ilim >= 0 && ilim <= Quick_max && try_quick) {
15272: 
15272: 		/* Try to get by with floating-point arithmetic. */
15272: 
15272: 		i = 0;
15272: 		dval(d2) = dval(d);
15272: 		k0 = k;
15272: 		ilim0 = ilim;
15272: 		ieps = 2; /* conservative */
15272: 		if (k > 0) {
15272: 			ds = tens[k&0xf];
15272: 			j = k >> 4;
15272: 			if (j & Bletch) {
15272: 				/* prevent overflows */
15272: 				j &= Bletch - 1;
15272: 				dval(d) /= bigtens[n_bigtens-1];
15272: 				ieps++;
15272: 				}
15272: 			for(; j; j >>= 1, i++)
15272: 				if (j & 1) {
15272: 					ieps++;
15272: 					ds *= bigtens[i];
15272: 					}
15272: 			dval(d) /= ds;
15272: 			}
15272: 		else if (j1 = -k) {
15272: 			dval(d) *= tens[j1 & 0xf];
15272: 			for(j = j1 >> 4; j; j >>= 1, i++)
15272: 				if (j & 1) {
15272: 					ieps++;
15272: 					dval(d) *= bigtens[i];
15272: 					}
15272: 			}
15272: 		if (k_check && dval(d) < 1. && ilim > 0) {
15272: 			if (ilim1 <= 0)
15272: 				goto fast_failed;
15272: 			ilim = ilim1;
15272: 			k--;
15272: 			dval(d) *= 10.;
15272: 			ieps++;
15272: 			}
15272: 		dval(eps) = ieps*dval(d) + 7.;
15272: 		word0(eps) -= (P-1)*Exp_msk1;
15272: 		if (ilim == 0) {
15272: 			S = mhi = 0;
15272: 			dval(d) -= 5.;
15272: 			if (dval(d) > dval(eps))
15272: 				goto one_digit;
15272: 			if (dval(d) < -dval(eps))
15272: 				goto no_digits;
15272: 			goto fast_failed;
15272: 			}
15272: #ifndef No_leftright
15272: 		if (leftright) {
15272: 			/* Use Steele & White method of only
15272: 			 * generating digits needed.
15272: 			 */
15272: 			dval(eps) = 0.5/tens[ilim-1] - dval(eps);
15272: 			for(i = 0;;) {
15272: 				L = dval(d);
15272: 				dval(d) -= L;
15272: 				*s++ = '0' + (int)L;
15272: 				if (dval(d) < dval(eps))
15272: 					goto ret1;
15272: 				if (1. - dval(d) < dval(eps))
15272: 					goto bump_up;
15272: 				if (++i >= ilim)
15272: 					break;
15272: 				dval(eps) *= 10.;
15272: 				dval(d) *= 10.;
15272: 				}
15272: 			}
15272: 		else {
15272: #endif
15272: 			/* Generate ilim digits, then fix them up. */
15272: 			dval(eps) *= tens[ilim-1];
15272: 			for(i = 1;; i++, dval(d) *= 10.) {
15272: 				L = (Long)(dval(d));
15272: 				if (!(dval(d) -= L))
15272: 					ilim = i;
15272: 				*s++ = '0' + (int)L;
15272: 				if (i == ilim) {
15272: 					if (dval(d) > 0.5 + dval(eps))
15272: 						goto bump_up;
15272: 					else if (dval(d) < 0.5 - dval(eps)) {
15272: 						while(*--s == '0');
15272: 						s++;
15272: 						goto ret1;
15272: 						}
15272: 					break;
15272: 					}
15272: 				}
15272: #ifndef No_leftright
15272: 			}
15272: #endif
15272:  fast_failed:
15272: 		s = s0;
15272: 		dval(d) = dval(d2);
15272: 		k = k0;
15272: 		ilim = ilim0;
15272: 		}
15272: 
15272: 	/* Do we have a "small" integer? */
15272: 
15272: 	if (be >= 0 && k <= Int_max) {
15272: 		/* Yes. */
15272: 		ds = tens[k];
15272: 		if (ndigits < 0 && ilim <= 0) {
15272: 			S = mhi = 0;
15272: 			if (ilim < 0 || dval(d) <= 5*ds)
15272: 				goto no_digits;
15272: 			goto one_digit;
15272: 			}
15272: 		for(i = 1; i <= k+1; i++, dval(d) *= 10.) {
15272: 			L = (Long)(dval(d) / ds);
15272: 			dval(d) -= L*ds;
15272: #ifdef Check_FLT_ROUNDS
15272: 			/* If FLT_ROUNDS == 2, L will usually be high by 1 */
15272: 			if (dval(d) < 0) {
15272: 				L--;
15272: 				dval(d) += ds;
15272: 				}
15272: #endif
15272: 			*s++ = '0' + (int)L;
15272: 			if (!dval(d)) {
15272: #ifdef SET_INEXACT
15272: 				inexact = 0;
15272: #endif
15272: 				break;
15272: 				}
15272: 			if (i == ilim) {
15272: #ifdef Honor_FLT_ROUNDS
15272: 				if (mode > 1)
15272: 				switch(rounding) {
15272: 				  case 0: goto ret1;
15272: 				  case 2: goto bump_up;
15272: 				  }
15272: #endif
15272: 				dval(d) += dval(d);
15272: 				if (dval(d) > ds || dval(d) == ds && L & 1) {
15272:  bump_up:
15272: 					while(*--s == '9')
15272: 						if (s == s0) {
15272: 							k++;
15272: 							*s = '0';
15272: 							break;
15272: 							}
15272: 					++*s++;
15272: 					}
15272: 				break;
15272: 				}
15272: 			}
15272: 		goto ret1;
15272: 		}
15272: 
15272: 	m2 = b2;
15272: 	m5 = b5;
15272: 	mhi = mlo = 0;
15272: 	if (leftright) {
15272: 		i =
15272: #ifndef Sudden_Underflow
15272: 			denorm ? be + (Bias + (P-1) - 1 + 1) :
15272: #endif
15272: #ifdef IBM
15272: 			1 + 4*P - 3 - bbits + ((bbits + be - 1) & 3);
15272: #else
15272: 			1 + P - bbits;
15272: #endif
15272: 		b2 += i;
15272: 		s2 += i;
15272: 		mhi = i2b(1);
15272: 		}
15272: 	if (m2 > 0 && s2 > 0) {
15272: 		i = m2 < s2 ? m2 : s2;
15272: 		b2 -= i;
15272: 		m2 -= i;
15272: 		s2 -= i;
15272: 		}
15272: 	if (b5 > 0) {
15272: 		if (leftright) {
15272: 			if (m5 > 0) {
15272: 				mhi = pow5mult(mhi, m5);
15272: 				b1 = mult(mhi, b);
15272: 				Bfree(b);
15272: 				b = b1;
15272: 				}
15272: 			if (j = b5 - m5)
15272: 				b = pow5mult(b, j);
15272: 			}
15272: 		else
15272: 			b = pow5mult(b, b5);
15272: 		}
15272: 	S = i2b(1);
15272: 	if (s5 > 0)
15272: 		S = pow5mult(S, s5);
15272: 
15272: 	/* Check for special case that d is a normalized power of 2. */
15272: 
15272: 	spec_case = 0;
15272: 	if ((mode < 2 || leftright)
15272: #ifdef Honor_FLT_ROUNDS
15272: 			&& rounding == 1
15272: #endif
15272: 				) {
15272: 		if (!word1(d) && !(word0(d) & Bndry_mask)
15272: #ifndef Sudden_Underflow
15272: 		 && word0(d) & (Exp_mask & ~Exp_msk1)
15272: #endif
15272: 				) {
15272: 			/* The special case */
15272: 			b2 += Log2P;
15272: 			s2 += Log2P;
15272: 			spec_case = 1;
15272: 			}
15272: 		}
15272: 
15272: 	/* Arrange for convenient computation of quotients:
15272: 	 * shift left if necessary so divisor has 4 leading 0 bits.
15272: 	 *
15272: 	 * Perhaps we should just compute leading 28 bits of S once
15272: 	 * and for all and pass them and a shift to quorem, so it
15272: 	 * can do shifts and ors to compute the numerator for q.
15272: 	 */
15272: #ifdef Pack_32
15272: 	if (i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f)
15272: 		i = 32 - i;
15272: #else
15272: 	if (i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0xf)
15272: 		i = 16 - i;
15272: #endif
15272: 	if (i > 4) {
15272: 		i -= 4;
15272: 		b2 += i;
15272: 		m2 += i;
15272: 		s2 += i;
15272: 		}
15272: 	else if (i < 4) {
15272: 		i += 28;
15272: 		b2 += i;
15272: 		m2 += i;
15272: 		s2 += i;
15272: 		}
15272: 	if (b2 > 0)
15272: 		b = lshift(b, b2);
15272: 	if (s2 > 0)
15272: 		S = lshift(S, s2);
15272: 	if (k_check) {
15272: 		if (cmp(b,S) < 0) {
15272: 			k--;
15272: 			b = multadd(b, 10, 0);	/* we botched the k estimate */
15272: 			if (leftright)
15272: 				mhi = multadd(mhi, 10, 0);
15272: 			ilim = ilim1;
15272: 			}
15272: 		}
15272: 	if (ilim <= 0 && (mode == 3 || mode == 5)) {
15272: 		if (ilim < 0 || cmp(b,S = multadd(S,5,0)) <= 0) {
15272: 			/* no digits, fcvt style */
15272:  no_digits:
15272: 			k = -1 - ndigits;
15272: 			goto ret;
15272: 			}
15272:  one_digit:
15272: 		*s++ = '1';
15272: 		k++;
15272: 		goto ret;
15272: 		}
15272: 	if (leftright) {
15272: 		if (m2 > 0)
15272: 			mhi = lshift(mhi, m2);
15272: 
15272: 		/* Compute mlo -- check for special case
15272: 		 * that d is a normalized power of 2.
15272: 		 */
15272: 
15272: 		mlo = mhi;
15272: 		if (spec_case) {
15272: 			mhi = Balloc(mhi->k);
15272: 			Bcopy(mhi, mlo);
15272: 			mhi = lshift(mhi, Log2P);
15272: 			}
15272: 
15272: 		for(i = 1;;i++) {
15272: 			dig = quorem(b,S) + '0';
15272: 			/* Do we yet have the shortest decimal string
15272: 			 * that will round to d?
15272: 			 */
15272: 			j = cmp(b, mlo);
15272: 			delta = diff(S, mhi);
15272: 			j1 = delta->sign ? 1 : cmp(b, delta);
15272: 			Bfree(delta);
15272: #ifndef ROUND_BIASED
15272: 			if (j1 == 0 && mode != 1 && !(word1(d) & 1)
15272: #ifdef Honor_FLT_ROUNDS
15272: 				&& rounding >= 1
15272: #endif
15272: 								   ) {
15272: 				if (dig == '9')
15272: 					goto round_9_up;
15272: 				if (j > 0)
15272: 					dig++;
15272: #ifdef SET_INEXACT
15272: 				else if (!b->x[0] && b->wds <= 1)
15272: 					inexact = 0;
15272: #endif
15272: 				*s++ = dig;
15272: 				goto ret;
15272: 				}
15272: #endif
15272: 			if (j < 0 || j == 0 && mode != 1
15272: #ifndef ROUND_BIASED
15272: 							&& !(word1(d) & 1)
15272: #endif
15272: 					) {
15272: 				if (!b->x[0] && b->wds <= 1) {
15272: #ifdef SET_INEXACT
15272: 					inexact = 0;
15272: #endif
15272: 					goto accept_dig;
15272: 					}
15272: #ifdef Honor_FLT_ROUNDS
15272: 				if (mode > 1)
15272: 				 switch(rounding) {
15272: 				  case 0: goto accept_dig;
15272: 				  case 2: goto keep_dig;
15272: 				  }
15272: #endif /*Honor_FLT_ROUNDS*/
15272: 				if (j1 > 0) {
15272: 					b = lshift(b, 1);
15272: 					j1 = cmp(b, S);
15272: 					if ((j1 > 0 || j1 == 0 && dig & 1)
15272: 					&& dig++ == '9')
15272: 						goto round_9_up;
15272: 					}
15272:  accept_dig:
15272: 				*s++ = dig;
15272: 				goto ret;
15272: 				}
15272: 			if (j1 > 0) {
15272: #ifdef Honor_FLT_ROUNDS
15272: 				if (!rounding)
15272: 					goto accept_dig;
15272: #endif
15272: 				if (dig == '9') { /* possible if i == 1 */
15272:  round_9_up:
15272: 					*s++ = '9';
15272: 					goto roundoff;
15272: 					}
15272: 				*s++ = dig + 1;
15272: 				goto ret;
15272: 				}
15272: #ifdef Honor_FLT_ROUNDS
15272:  keep_dig:
15272: #endif
15272: 			*s++ = dig;
15272: 			if (i == ilim)
15272: 				break;
15272: 			b = multadd(b, 10, 0);
15272: 			if (mlo == mhi)
15272: 				mlo = mhi = multadd(mhi, 10, 0);
15272: 			else {
15272: 				mlo = multadd(mlo, 10, 0);
15272: 				mhi = multadd(mhi, 10, 0);
15272: 				}
15272: 			}
15272: 		}
15272: 	else
15272: 		for(i = 1;; i++) {
15272: 			*s++ = dig = quorem(b,S) + '0';
15272: 			if (!b->x[0] && b->wds <= 1) {
15272: #ifdef SET_INEXACT
15272: 				inexact = 0;
15272: #endif
15272: 				goto ret;
15272: 				}
15272: 			if (i >= ilim)
15272: 				break;
15272: 			b = multadd(b, 10, 0);
15272: 			}
15272: 
15272: 	/* Round off last digit */
15272: 
15272: #ifdef Honor_FLT_ROUNDS
15272: 	switch(rounding) {
15272: 	  case 0: goto trimzeros;
15272: 	  case 2: goto roundoff;
15272: 	  }
15272: #endif
15272: 	b = lshift(b, 1);
15272: 	j = cmp(b, S);
15272: 	if (j > 0 || j == 0 && dig & 1) {
15272:  roundoff:
15272: 		while(*--s == '9')
15272: 			if (s == s0) {
15272: 				k++;
15272: 				*s++ = '1';
15272: 				goto ret;
15272: 				}
15272: 		++*s++;
15272: 		}
15272: 	else {
26462: #ifdef Honor_FLT_ROUNDS
15272:  trimzeros:
26462: #endif
15272: 		while(*--s == '0');
15272: 		s++;
15272: 		}
15272:  ret:
15272: 	Bfree(S);
15272: 	if (mhi) {
15272: 		if (mlo && mlo != mhi)
15272: 			Bfree(mlo);
15272: 		Bfree(mhi);
15272: 		}
15272:  ret1:
15272: #ifdef SET_INEXACT
15272: 	if (inexact) {
15272: 		if (!oldinexact) {
15272: 			word0(d) = Exp_1 + (70 << Exp_shift);
15272: 			word1(d) = 0;
15272: 			dval(d) += 1.;
15272: 			}
15272: 		}
15272: 	else if (!oldinexact)
15272: 		clear_inexact();
15272: #endif
15272: 	Bfree(b);
15272: 	*s = 0;
15272: 	*decpt = k + 1;
15272: 	if (rve)
15272: 		*rve = s;
15272: 	return s0;
15272: 	}
15272: #ifdef __cplusplus
15272: }
15272: #endif
15272: 
15272: PR_IMPLEMENT(PRStatus)
15272: PR_dtoa(PRFloat64 d, PRIntn mode, PRIntn ndigits,
15272: 	PRIntn *decpt, PRIntn *sign, char **rve, char *buf, PRSize bufsize)
15272: {
15272:     char *result;
15272:     PRSize resultlen;
15272:     PRStatus rv = PR_FAILURE;
15272: 
15272:     if (!_pr_initialized) _PR_ImplicitInitialization();
15272: 
15272:     if (mode < 0 || mode > 3) {
15272:         PR_SetError(PR_INVALID_ARGUMENT_ERROR, 0);
15272:         return rv;
15272:     }
15272:     result = dtoa(d, mode, ndigits, decpt, sign, rve);
15272:     if (!result) {
15272:         PR_SetError(PR_OUT_OF_MEMORY_ERROR, 0);
15272:         return rv;
15272:     }
15272:     resultlen = strlen(result)+1;
15272:     if (bufsize < resultlen) {
15272:         PR_SetError(PR_BUFFER_OVERFLOW_ERROR, 0);
15272:     } else {
15272:         memcpy(buf, result, resultlen);
15272:         if (rve) {
15272:             *rve = buf + (*rve - result);
15272:         }
15272:         rv = PR_SUCCESS;
15272:     }
15272:     freedtoa(result);
15272:     return rv;  
15272: }
15272: 
15272: /*
15272: ** conversion routines for floating point
15272: ** prcsn - number of digits of precision to generate floating
15272: ** point value.
15272: ** This should be reparameterized so that you can send in a
15272: **   prcn for the positive and negative ranges.  For now, 
15272: **   conform to the ECMA JavaScript spec which says numbers
15272: **   less than 1e-6 are in scientific notation.
15272: ** Also, the ECMA spec says that there should always be a
15272: **   '+' or '-' after the 'e' in scientific notation
15272: */
15272: PR_IMPLEMENT(void)
26462: PR_cnvtf(char *buf, int bufsz, int prcsn, double dfval)
15272: {
15272:     PRIntn decpt, sign, numdigits;
15272:     char *num, *nump;
15272:     char *bufp = buf;
15272:     char *endnum;
26462:     U fval;
15272: 
26462:     dval(fval) = dfval;
15272:     /* If anything fails, we store an empty string in 'buf' */
15272:     num = (char*)PR_MALLOC(bufsz);
15272:     if (num == NULL) {
15272:         buf[0] = '\0';
15272:         return;
15272:     }
15272:     /* XXX Why use mode 1? */
15272:     if (PR_dtoa(dval(fval),1,prcsn,&decpt,&sign,&endnum,num,bufsz)
15272:             == PR_FAILURE) {
15272:         buf[0] = '\0';
15272:         goto done;
15272:     }
15272:     numdigits = endnum - num;
15272:     nump = num;
15272: 
15272:     if (sign &&
15272:         !(word0(fval) == Sign_bit && word1(fval) == 0) &&
15272:         !((word0(fval) & Exp_mask) == Exp_mask &&
15272:           (word1(fval) || (word0(fval) & 0xfffff)))) {
15272:         *bufp++ = '-';
15272:     }
15272: 
15272:     if (decpt == 9999) {
15272:         while ((*bufp++ = *nump++) != 0) {} /* nothing to execute */
15272:         goto done;
15272:     }
15272: 
15272:     if (decpt > (prcsn+1) || decpt < -(prcsn-1) || decpt < -5) {
15272:         *bufp++ = *nump++;
15272:         if (numdigits != 1) {
15272:             *bufp++ = '.';
15272:         }
15272: 
15272:         while (*nump != '\0') {
15272:             *bufp++ = *nump++;
15272:         }
15272:         *bufp++ = 'e';
15272:         PR_snprintf(bufp, bufsz - (bufp - buf), "%+d", decpt-1);
15272:     } else if (decpt >= 0) {
15272:         if (decpt == 0) {
15272:             *bufp++ = '0';
15272:         } else {
15272:             while (decpt--) {
15272:                 if (*nump != '\0') {
15272:                     *bufp++ = *nump++;
15272:                 } else {
15272:                     *bufp++ = '0';
15272:                 }
15272:             }
15272:         }
15272:         if (*nump != '\0') {
15272:             *bufp++ = '.';
15272:             while (*nump != '\0') {
15272:                 *bufp++ = *nump++;
15272:             }
15272:         }
15272:         *bufp++ = '\0';
15272:     } else if (decpt < 0) {
15272:         *bufp++ = '0';
15272:         *bufp++ = '.';
15272:         while (decpt++) {
15272:             *bufp++ = '0';
15272:         }
15272: 
15272:         while (*nump != '\0') {
15272:             *bufp++ = *nump++;
15272:         }
15272:         *bufp++ = '\0';
15272:     }
15272: done:
15272:     PR_DELETE(num);
15272: }
