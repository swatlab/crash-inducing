    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
 8980:  * rendering object for CSS display:block, inline-block, and list-item
 8980:  * boxes, also used for various anonymous boxes
    1:  */
    1: 
    1: #ifndef nsBlockFrame_h___
    1: #define nsBlockFrame_h___
    1: 
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsAbsoluteContainingBlock.h"
    1: #include "nsLineBox.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsStyleSet.h"
28638: #include "nsFloatManager.h"
    1: 
    1: enum LineReflowStatus {
    1:   // The line was completely reflowed and fit in available width, and we should
    1:   // try to pull up content from the next line if possible.
    1:   LINE_REFLOW_OK,
    1:   // The line was completely reflowed and fit in available width, but we should
    1:   // not try to pull up content from the next line.
    1:   LINE_REFLOW_STOP,
    1:   // We need to reflow the line again at its current vertical position. The
    1:   // new reflow should not try to pull up any frames from the next line.
    1:   LINE_REFLOW_REDO_NO_PULL,
28638:   // We need to reflow the line again using the floats from its height
28638:   // this reflow, since its height made it hit floats that were not
28638:   // adjacent to its top.
28638:   LINE_REFLOW_REDO_MORE_FLOATS,
    1:   // We need to reflow the line again at a lower vertical postion where there
    1:   // may be more horizontal space due to different float configuration.
    1:   LINE_REFLOW_REDO_NEXT_BAND,
    1:   // The line did not fit in the available vertical space. Try pushing it to
    1:   // the next page or column if it's not the first line on the current page/column.
    1:   LINE_REFLOW_TRUNCATED
    1: };
    1: 
    1: class nsBlockReflowState;
 5145: class nsBlockInFlowLineIterator;
    1: class nsBulletFrame;
    1: class nsLineBox;
    1: class nsFirstLineFrame;
    1: class nsIntervalSet;
    1: /**
    1:  * Child list name indices
    1:  * @see #GetAdditionalChildListName()
    1:  */
48990: #define NS_BLOCK_LIST_COUNT  (NS_CONTAINER_LIST_COUNT_INCL_OC + 5)
    1: 
    1: /**
    1:  * Some invariants:
    1:  * -- The overflow out-of-flows list contains the out-of-
    1:  * flow frames whose placeholders are in the overflow list.
    1:  * -- A given piece of content has at most one placeholder
    1:  * frame in a block's normal child list.
48990:  * -- While a block is being reflowed, and from then until
48990:  * its next-in-flow is reflowed it may have a
49010:  * PushedFloatProperty frame property that points to
48990:  * an nsFrameList. This list contains continuations for
32108:  * floats whose prev-in-flow is in the block's regular float
48994:  * list and first-in-flows of floats that did not fit, but
48994:  * whose placeholders are in the block or one of its
48994:  * prev-in-flows.
    1:  * -- In all these frame lists, if there are two frames for
    1:  * the same content appearing in the list, then the frames
    1:  * appear with the prev-in-flow before the next-in-flow.
    1:  * -- While reflowing a block, its overflow line list
    1:  * will usually be empty but in some cases will have lines
    1:  * (while we reflow the block at its shrink-wrap width).
    1:  * In this case any new overflowing content must be
    1:  * prepended to the overflow lines.
    1:  */
    1: 
    1: // see nsHTMLParts.h for the public block state bits
 6829: 
 6829: /**
 6829:  * Something in the block has changed that requires Bidi resolution to be
 6829:  * performed on the block. This flag must be either set on all blocks in a 
 6829:  * continuation chain or none of them.
 6829:  */
43376: #define NS_BLOCK_NEEDS_BIDI_RESOLUTION      NS_FRAME_STATE_BIT(20)
49010: #define NS_BLOCK_HAS_PUSHED_FLOATS          NS_FRAME_STATE_BIT(21)
43376: #define NS_BLOCK_HAS_LINE_CURSOR            NS_FRAME_STATE_BIT(24)
43376: #define NS_BLOCK_HAS_OVERFLOW_LINES         NS_FRAME_STATE_BIT(25)
43376: #define NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS  NS_FRAME_STATE_BIT(26)
    1: 
    1: // Set on any block that has descendant frames in the normal
    1: // flow with 'clear' set to something other than 'none'
    1: // (including <BR CLEAR="..."> frames)
43376: #define NS_BLOCK_HAS_CLEAR_CHILDREN         NS_FRAME_STATE_BIT(27)
    1: 
    1: #define nsBlockFrameSuper nsHTMLContainerFrame
    1: 
    1: /*
    1:  * Base class for block and inline frames.
    1:  * The block frame has an additional named child list:
    1:  * - "Absolute-list" which contains the absolutely positioned frames
    1:  *
    1:  * @see nsGkAtoms::absoluteList
    1:  */ 
    1: class nsBlockFrame : public nsBlockFrameSuper
    1: {
    1: public:
32423:   NS_DECL_QUERYFRAME_TARGET(nsBlockFrame)
32423:   NS_DECL_FRAMEARENA_HELPERS
23554: 
    1:   typedef nsLineList::iterator                  line_iterator;
    1:   typedef nsLineList::const_iterator            const_line_iterator;
    1:   typedef nsLineList::reverse_iterator          reverse_line_iterator;
    1:   typedef nsLineList::const_reverse_iterator    const_reverse_line_iterator;
    1: 
    1:   line_iterator begin_lines() { return mLines.begin(); }
    1:   line_iterator end_lines() { return mLines.end(); }
    1:   const_line_iterator begin_lines() const { return mLines.begin(); }
    1:   const_line_iterator end_lines() const { return mLines.end(); }
    1:   reverse_line_iterator rbegin_lines() { return mLines.rbegin(); }
    1:   reverse_line_iterator rend_lines() { return mLines.rend(); }
    1:   const_reverse_line_iterator rbegin_lines() const { return mLines.rbegin(); }
    1:   const_reverse_line_iterator rend_lines() const { return mLines.rend(); }
53721:   line_iterator line(nsLineBox* aList) { return mLines.begin(aList); }
53721:   reverse_line_iterator rline(nsLineBox* aList) { return mLines.rbegin(aList); }
    1: 
    1:   friend nsIFrame* NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
    1: 
48990:   // This is a child list too, but we let nsBlockReflowState get to it
48990:   // directly too.
49010:   NS_DECLARE_FRAME_PROPERTY(PushedFloatProperty,
48990:                             nsContainerFrame::DestroyFrameList)
39965: 
23554:   // nsQueryFrame
23554:   NS_DECL_QUERYFRAME
    1: 
    1:   // nsIFrame
    1:   NS_IMETHOD Init(nsIContent*      aContent,
    1:                   nsIFrame*        aParent,
    1:                   nsIFrame*        aPrevInFlow);
    1:   NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
30790:                                  nsFrameList&    aChildList);
    1:   NS_IMETHOD  AppendFrames(nsIAtom*        aListName,
30941:                            nsFrameList&    aFrameList);
    1:   NS_IMETHOD  InsertFrames(nsIAtom*        aListName,
    1:                            nsIFrame*       aPrevFrame,
30941:                            nsFrameList&    aFrameList);
    1:   NS_IMETHOD  RemoveFrame(nsIAtom*        aListName,
    1:                           nsIFrame*       aOldFrame);
30783:   virtual nsFrameList GetChildList(nsIAtom* aListName) const;
    1:   virtual nscoord GetBaseline() const;
    1:   virtual nsIAtom* GetAdditionalChildListName(PRInt32 aIndex) const;
36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
    1:   virtual nsSplittableType GetSplittableType() const;
    1:   virtual PRBool IsContainingBlock() const;
    1:   virtual PRBool IsFloatContainingBlock() const;
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1:   virtual void InvalidateInternal(const nsRect& aDamageRect,
    1:                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
19380:                                   PRUint32 aFlags);
    1:   virtual nsIAtom* GetType() const;
 4006:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
 4006:   {
 4006:     return nsContainerFrame::IsFrameOfType(aFlags &
10895:              ~(nsIFrame::eCanContainOverflowContainers |
10895:                nsIFrame::eBlockFrame));
 4006:   }
 4006: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD List(FILE* out, PRInt32 aIndent) const;
    1:   NS_IMETHOD_(nsFrameState) GetDebugStateBits() const;
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
    1: #endif
    1: 
    1: #ifdef ACCESSIBILITY
46338:   virtual already_AddRefed<nsAccessible> CreateAccessible();
    1: #endif
    1: 
    1:   // line cursor methods to speed up searching for the line(s)
    1:   // containing a point. The basic idea is that we set the cursor
    1:   // property if the lines' combinedArea.ys and combinedArea.yMosts
    1:   // are non-decreasing (considering only non-empty combinedAreas;
    1:   // empty combinedAreas never participate in event handling or
    1:   // painting), and the block has sufficient number of lines. The
    1:   // cursor property points to a "recently used" line. If we get a
    1:   // series of requests that work on lines
    1:   // "near" the cursor, then we can find those nearby lines quickly by
    1:   // starting our search at the cursor.
    1: 
    1:   // Clear out line cursor because we're disturbing the lines (i.e., Reflow)
    1:   void ClearLineCursor();
    1:   // Get the first line that might contain y-coord 'y', or nsnull if you must search
    1:   // all lines. If nonnull is returned then we guarantee that the lines'
    1:   // combinedArea.ys and combinedArea.yMosts are non-decreasing.
    1:   // The actual line returned might not contain 'y', but if not, it is guaranteed
    1:   // to be before any line which does contain 'y'.
    1:   nsLineBox* GetFirstLineContaining(nscoord y);
    1:   // Set the line cursor to our first line. Only call this if you
    1:   // guarantee that the lines' combinedArea.ys and combinedArea.yMosts
    1:   // are non-decreasing.
    1:   void SetupLineCursor();
    1: 
    1:   virtual void ChildIsDirty(nsIFrame* aChild);
    1:   virtual PRBool IsVisibleInSelection(nsISelection* aSelection);
    1: 
    1:   virtual PRBool IsEmpty();
    1:   virtual PRBool CachedIsEmpty();
    1:   virtual PRBool IsSelfEmpty();
    1: 
32392:   // Given that we have a bullet, does it actually draw something, i.e.,
32392:   // do we have either a 'list-style-type' or 'list-style-image' that is
32392:   // not 'none'?
32392:   PRBool BulletIsEmpty() const;
32392: 
    1:   virtual void MarkIntrinsicWidthsDirty();
    1:   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
    1:   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
    1: 
 6862:   virtual nsRect ComputeTightBounds(gfxContext* aContext) const;
 6862:   
    1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1: 
    1:   NS_IMETHOD AttributeChanged(PRInt32         aNameSpaceID,
    1:                               nsIAtom*        aAttribute,
    1:                               PRInt32         aModType);
    1: 
 4006:   virtual nsresult StealFrame(nsPresContext* aPresContext,
 4006:                               nsIFrame*      aChild,
32108:                               PRBool         aForceNormal = PR_FALSE);
 4006: 
    1:   virtual void DeleteNextInFlowChild(nsPresContext* aPresContext,
22195:                                      nsIFrame*      aNextInFlow,
22195:                                      PRBool         aDeletingEmptyFrames);
    1: 
    1:   /**
    1:    * Determines whether the collapsed margin carried out of the last
    1:    * line includes the margin-top of a line with clearance (in which
    1:    * case we must avoid collapsing that margin with our bottom margin)
    1:    */
    1:   PRBool CheckForCollapsedBottomMarginFromClearanceLine();
    1: 
    1:   static nsresult GetCurrentLine(nsBlockReflowState *aState, nsLineBox **aOutCurrentLine);
    1: 
    1:   static PRBool BlockIsMarginRoot(nsIFrame* aBlock);
23305:   static PRBool BlockNeedsFloatManager(nsIFrame* aBlock);
10895: 
10895:   /**
10895:    * Returns whether aFrame is a block frame that will wrap its contents
10895:    * around floats intruding on it from the outside.  (aFrame need not
10895:    * be a block frame, but if it's not, the result will be false.)
10895:    */
10895:   static PRBool BlockCanIntersectFloats(nsIFrame* aFrame);
10895: 
10895:   /**
10895:    * Returns the width that needs to be cleared past floats for blocks
14910:    * that cannot intersect floats.  aState must already have
14910:    * GetAvailableSpace called on it for the vertical position that we
14910:    * care about (which need not be its current mY)
10895:    */
14324:   struct ReplacedElementWidthToClear {
14324:     nscoord marginLeft, borderBoxWidth, marginRight;
14324:     nscoord MarginBoxWidth() const
14324:       { return marginLeft + borderBoxWidth + marginRight; }
14324:   };
14324:   static ReplacedElementWidthToClear
27103:     WidthToClearPastFloats(nsBlockReflowState& aState,
27103:                            const nsRect& aFloatAvailableSpace,
27103:                            nsIFrame* aFrame);
10895: 
 7046:   /**
32108:    * Creates a contination for aFloat and adds it to the list of overflow floats.
32108:    * Also updates aState.mReflowStatus to include the float's incompleteness.
32108:    * Must only be called while this block frame is in reflow.
32108:    * aFloatStatus must be the float's true, unmodified reflow status.
32108:    * 
32108:    */
32108:   nsresult SplitFloat(nsBlockReflowState& aState,
32108:                       nsIFrame*           aFloat,
32108:                       nsReflowStatus      aFloatStatus);
32108: 
32108:   /**
 7046:    * Walks up the frame tree, starting with aCandidate, and returns the first
 7046:    * block frame that it encounters.
 7046:    */
 7046:   static nsBlockFrame* GetNearestAncestorBlock(nsIFrame* aCandidate);
    1:   
    1: protected:
    1:   nsBlockFrame(nsStyleContext* aContext)
    1:     : nsHTMLContainerFrame(aContext)
    1:     , mMinWidth(NS_INTRINSIC_WIDTH_UNKNOWN)
    1:     , mPrefWidth(NS_INTRINSIC_WIDTH_UNKNOWN)
 4205:     , mAbsoluteContainer(nsGkAtoms::absoluteList)
    1:   {
    1: #ifdef DEBUG
    1:   InitDebugFlags();
    1: #endif
    1:   }
    1:   virtual ~nsBlockFrame();
    1: 
  551: #ifdef DEBUG
    1:   already_AddRefed<nsStyleContext> GetFirstLetterStyle(nsPresContext* aPresContext)
    1:   {
    1:     return aPresContext->StyleSet()->
41641:       ProbePseudoElementStyle(mContent->AsElement(),
35554:                               nsCSSPseudoElements::ePseudo_firstLetter,
35554:                               mStyleContext);
    1:   }
  551: #endif
    1: 
    1:   /*
    1:    * Overides member function of nsHTMLContainerFrame. Needed to handle the 
    1:    * lines in a nsBlockFrame properly.
    1:    */
15339:   virtual void PaintTextDecorationLine(gfxContext* aCtx,
12989:                                        const nsPoint& aPt,
    1:                                        nsLineBox* aLine,
    1:                                        nscolor aColor,
12989:                                        gfxFloat aOffset,
12989:                                        gfxFloat aAscent,
12989:                                        gfxFloat aSize,
 4302:                                        const PRUint8 aDecoration);
    1: 
32863:   virtual void AdjustForTextIndent(const nsLineBox* aLine,
32863:                                    nscoord& start,
32863:                                    nscoord& width);
32863: 
    1:   void TryAllLines(nsLineList::iterator* aIterator,
 6709:                    nsLineList::iterator* aStartIterator,
    1:                    nsLineList::iterator* aEndIterator,
    1:                    PRBool* aInOverflowLines);
    1: 
    1:   void SetFlags(PRUint32 aFlags) {
    1:     mState &= ~NS_BLOCK_FLAGS_MASK;
    1:     mState |= aFlags;
    1:   }
    1: 
    1:   PRBool HaveOutsideBullet() const {
    1: #if defined(DEBUG) && !defined(DEBUG_rods)
    1:     if(mState & NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET) {
    1:       NS_ASSERTION(mBullet,"NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET flag set and no mBullet");
    1:     }
    1: #endif
    1:     return 0 != (mState & NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET);
    1:   }
    1: 
    1:   /** move the frames contained by aLine by aDY
    1:     * if aLine is a block, its child floats are added to the state manager
    1:     */
    1:   void SlideLine(nsBlockReflowState& aState,
    1:                  nsLineBox* aLine, nscoord aDY);
    1: 
    1:   virtual PRIntn GetSkipSides() const;
    1: 
    1:   virtual void ComputeFinalSize(const nsHTMLReflowState& aReflowState,
    1:                                 nsBlockReflowState&      aState,
23155:                                 nsHTMLReflowMetrics&     aMetrics,
23155:                                 nscoord*                 aBottomEdgeOfChildren);
    1: 
    1:   void ComputeCombinedArea(const nsHTMLReflowState& aReflowState,
23155:                            nsHTMLReflowMetrics&     aMetrics,
23155:                            nscoord                  aBottomEdgeOfChildren);
    1: 
    1:   /** add the frames in aFrameList to this block after aPrevSibling
    1:     * this block thinks in terms of lines, but the frame construction code
    1:     * knows nothing about lines at all. So we need to find the line that
    1:     * contains aPrevSibling and add aFrameList after aPrevSibling on that line.
    1:     * new lines are created as necessary to handle block data in aFrameList.
33276:     * This function will clear aFrameList.
    1:     */
33276:   virtual nsresult AddFrames(nsFrameList& aFrameList, nsIFrame* aPrevSibling);
    1: 
    1: #ifdef IBMBIDI
    1:   /**
 1920:    * Perform Bidi resolution on this frame
 1920:    */
 1920:   nsresult ResolveBidi();
 1920: 
 1920:   /**
    1:    * Test whether the frame is a form control in a visual Bidi page.
    1:    * This is necessary for backwards-compatibility, because most visual
    1:    * pages use logical order for form controls so that they will
    1:    * display correctly on native widgets in OSs with Bidi support
    1:    * @param aPresContext the pres context
    1:    * @return whether the frame is a BIDI form control
    1:    */
    1:   PRBool IsVisualFormControl(nsPresContext* aPresContext);
    1: #endif
    1: 
    1: public:
22195:   /**
22195:    * Does all the real work for removing aDeletedFrame
22195:    * -- finds the line containing aDeletedFrame
22195:    * -- removes all aDeletedFrame next-in-flows (or all continuations,
22195:    * if REMOVE_FIXED_CONTINUATIONS is given)
22195:    * -- marks lines dirty as needed
22195:    * -- marks textruns dirty (unless FRAMES_ARE_EMPTY is given, in which
22195:    * case textruns do not need to be dirtied)
32106:    * -- destroys all removed frames
    1:    */
22195:   enum {
22195:     REMOVE_FIXED_CONTINUATIONS = 0x02,
22195:     FRAMES_ARE_EMPTY           = 0x04
22195:   };
22195:   nsresult DoRemoveFrame(nsIFrame* aDeletedFrame, PRUint32 aFlags);
  686: 
  686:   void ReparentFloats(nsIFrame* aFirstFrame,
  686:                       nsBlockFrame* aOldParent, PRBool aFromOverflow,
  686:                       PRBool aReparentSiblings);
  686: 
32108:   /** Load all of aFrame's floats into the float manager iff aFrame is not a
32108:    *  block formatting context. Handles all necessary float manager translations;
32108:    *  assumes float manager is in aFrame's parent's coord system.
32108:    *  Safe to call on non-blocks (does nothing).
32108:    */
32108:   static void RecoverFloatsFor(nsIFrame*       aFrame,
32108:                                nsFloatManager& aFloatManager);
32108: 
    1: protected:
    1: 
    1:   /** grab overflow lines from this block's prevInFlow, and make them
    1:     * part of this block's mLines list.
    1:     * @return PR_TRUE if any lines were drained.
    1:     */
    1:   PRBool DrainOverflowLines(nsBlockReflowState& aState);
    1: 
49010:   /** grab pushed floats from this block's prevInFlow, and splice
32108:     * them into this block's mFloats list.
32108:     */
49010:   void DrainPushedFloats(nsBlockReflowState& aState);
32108: 
32108:   /** Load all our floats into the float manager (without reflowing them).
32108:    *  Assumes float manager is in our own coordinate system.
32108:    */
32108:   void RecoverFloats(nsFloatManager& aFloatManager);
32108: 
49010:   /** Reflow pushed floats
32108:    */
49010:   nsresult ReflowPushedFloats(nsBlockReflowState& aState,
32108:                                     nsRect&             aBounds,
32108:                                     nsReflowStatus&     aStatus);
32108: 
32109:   /** Find any trailing BR clear from the last line of the block (or its PIFs)
32109:    */
32109:   PRUint8 FindTrailingClear();
32109: 
    1:   /**
    1:     * Remove a float from our float list and also the float cache
    1:     * for the line its placeholder is on.
    1:     */
    1:   line_iterator RemoveFloat(nsIFrame* aFloat);
    1: 
32843:   void CollectFloats(nsIFrame* aFrame, nsFrameList& aList,
  686:                      PRBool aFromOverflow, PRBool aCollectFromSiblings);
    1:   // Remove a float, abs, rel positioned frame from the appropriate block's list
    1:   static void DoRemoveOutOfFlowFrame(nsIFrame* aFrame);
    1: 
    1:   /** set up the conditions necessary for an resize reflow
    1:     * the primary task is to mark the minimumly sufficient lines dirty. 
    1:     */
    1:   nsresult PrepareResizeReflow(nsBlockReflowState& aState);
    1: 
    1:   /** reflow all lines that have been marked dirty */
    1:   nsresult ReflowDirtyLines(nsBlockReflowState& aState);
    1: 
27993:   /** Mark a given line dirty due to reflow being interrupted on or before it */
27993:   void MarkLineDirtyForInterrupt(nsLineBox* aLine);
27993: 
    1:   //----------------------------------------
    1:   // Methods for line reflow
    1:   /**
    1:    * Reflow a line.  
    1:    * @param aState           the current reflow state
    1:    * @param aLine            the line to reflow.  can contain a single block frame
    1:    *                         or contain 1 or more inline frames.
    1:    * @param aKeepReflowGoing [OUT] indicates whether the caller should continue to reflow more lines
    1:    */
    1:   nsresult ReflowLine(nsBlockReflowState& aState,
    1:                       line_iterator aLine,
    1:                       PRBool* aKeepReflowGoing);
    1: 
28638:   // Return false if it needs another reflow because of reduced space
28638:   // between floats that are next to it (but not next to its top), and
28638:   // return true otherwise.
28638:   PRBool PlaceLine(nsBlockReflowState& aState,
    1:                    nsLineLayout&       aLineLayout,
    1:                    line_iterator       aLine,
28638:                    nsFloatManager::SavedState* aFloatStateBeforeLine,
28638:                    nsRect&             aFloatAvailableSpace, /* in-out */
29265:                    nscoord&            aAvailableSpaceHeight, /* in-out */
    1:                    PRBool*             aKeepReflowGoing);
    1: 
    1:   /**
    1:    * Mark |aLine| dirty, and, if necessary because of possible
 7719:    * pull-up, mark the previous line dirty as well. Also invalidates textruns
 7719:    * on those lines because the text in the lines might have changed due to
 7719:    * addition/removal of frames.
20345:    * @param aLine the line to mark dirty
20345:    * @param aLineList the line list containing that line, null means the line
20345:    *        is in 'mLines' of this frame.
    1:    */
20345:   nsresult MarkLineDirty(line_iterator aLine,
20345:                          const nsLineList* aLineList = nsnull);
    1: 
    1:   // XXX where to go
    1:   PRBool ShouldJustifyLine(nsBlockReflowState& aState,
    1:                            line_iterator aLine);
    1: 
    1:   void DeleteLine(nsBlockReflowState& aState,
    1:                   nsLineList::iterator aLine,
    1:                   nsLineList::iterator aLineEnd);
    1: 
    1:   //----------------------------------------
    1:   // Methods for individual frame reflow
    1: 
    1:   PRBool ShouldApplyTopMargin(nsBlockReflowState& aState,
    1:                               nsLineBox* aLine);
    1: 
    1:   nsresult ReflowBlockFrame(nsBlockReflowState& aState,
    1:                             line_iterator aLine,
    1:                             PRBool* aKeepGoing);
    1: 
    1:   nsresult ReflowInlineFrames(nsBlockReflowState& aState,
    1:                               line_iterator aLine,
    1:                               PRBool* aKeepLineGoing);
    1: 
    1:   nsresult DoReflowInlineFrames(nsBlockReflowState& aState,
    1:                                 nsLineLayout& aLineLayout,
    1:                                 line_iterator aLine,
28638:                                 nsFlowAreaRect& aFloatAvailableSpace,
29265:                                 nscoord& aAvailableSpaceHeight,
28638:                                 nsFloatManager::SavedState*
28638:                                   aFloatStateBeforeLine,
    1:                                 PRBool* aKeepReflowGoing,
    1:                                 LineReflowStatus* aLineReflowStatus,
    1:                                 PRBool aAllowPullUp);
    1: 
    1:   nsresult ReflowInlineFrame(nsBlockReflowState& aState,
    1:                              nsLineLayout& aLineLayout,
    1:                              line_iterator aLine,
    1:                              nsIFrame* aFrame,
    1:                              LineReflowStatus* aLineReflowStatus);
    1: 
15299:   // Compute the available width for a float. 
27101:   nsRect AdjustFloatAvailableSpace(nsBlockReflowState& aState,
27101:                                    const nsRect&       aFloatAvailableSpace,
15299:                                    nsIFrame*           aFloatFrame);
15299:   // Computes the border-box width of the float
15299:   nscoord ComputeFloatWidth(nsBlockReflowState& aState,
27101:                             const nsRect&       aFloatAvailableSpace,
32107:                             nsIFrame*           aFloat);
    1:   // An incomplete aReflowStatus indicates the float should be split
    1:   // but only if the available height is constrained.
48980:   // aAdjustedAvailableSpace is the result of calling
48980:   // nsBlockFrame::AdjustFloatAvailableSpace.
    1:   nsresult ReflowFloat(nsBlockReflowState& aState,
48980:                        const nsRect&       aAdjustedAvailableSpace,
32107:                        nsIFrame*           aFloat,
 2480:                        nsMargin&           aFloatMargin,
48981:                        // Whether the float's position
48981:                        // (aAdjustedAvailableSpace) has been pushed down
48981:                        // due to the presence of other floats.
48981:                        PRBool              aFloatPushedDown,
    1:                        nsReflowStatus&     aReflowStatus);
    1: 
    1:   //----------------------------------------
    1:   // Methods for pushing/pulling lines/frames
    1: 
32841:   /**
32841:    * Create a next-in-flow, if necessary, for aFrame. If a new frame is
32841:    * created, place it in aLine if aLine is not null.
32841:    * @param aState the block reflow state
32841:    * @param aLine where to put a new frame
32841:    * @param aFrame the frame
32841:    * @param aMadeNewFrame PR_TRUE if a new frame was created, PR_FALSE if not
32841:    * @return NS_OK if a next-in-flow already exists or is successfully created
32841:    */
    1:   virtual nsresult CreateContinuationFor(nsBlockReflowState& aState,
    1:                                          nsLineBox*          aLine,
    1:                                          nsIFrame*           aFrame,
    1:                                          PRBool&             aMadeNewFrame);
    1: 
48996:   // Push aLine, which cannot be placed on this page/column but should
48996:   // fit on a future one.  Set aKeepReflowGoing to false.
48996:   void PushTruncatedLine(nsBlockReflowState& aState,
    1:                          line_iterator       aLine,
    1:                          PRBool&             aKeepReflowGoing);
    1: 
    1:   nsresult SplitLine(nsBlockReflowState& aState,
    1:                      nsLineLayout& aLineLayout,
    1:                      line_iterator aLine,
    1:                      nsIFrame* aFrame,
    1:                      LineReflowStatus* aLineReflowStatus);
    1: 
36987:   /**
36987:    * Pull a frame from the next available location (one of our lines or
36987:    * one of our next-in-flows lines).
36987:    * @return the pulled frame or nsnull
36987:    */
36987:   nsIFrame* PullFrame(nsBlockReflowState& aState,
36987:                       line_iterator       aLine);
    1: 
36987:   /**
36987:    * Try to pull a frame out of a line pointed at by aFromLine.
36987:    *
36987:    * Note: pulling a frame from a line that is a place-holder frame
36987:    * doesn't automatically remove the corresponding float from the
36987:    * line's float array. This happens indirectly: either the line gets
36987:    * emptied (and destroyed) or the line gets reflowed (because we mark
36987:    * it dirty) and the code at the top of ReflowLine empties the
36987:    * array. So eventually, it will be removed, just not right away.
36987:    *
36987:    * @return the pulled frame or nsnull
36987:    */
36987:   nsIFrame* PullFrameFrom(nsBlockReflowState&  aState,
    1:                           nsLineBox*           aLine,
    1:                           nsBlockFrame*        aFromContainer,
    1:                           PRBool               aFromOverflowLine,
36987:                           nsLineList::iterator aFromLine);
    1: 
    1:   void PushLines(nsBlockReflowState& aState,
    1:                  nsLineList::iterator aLineBefore);
    1: 
    1:   void PropagateFloatDamage(nsBlockReflowState& aState,
    1:                             nsLineBox* aLine,
    1:                             nscoord aDeltaY);
    1: 
    1:   void CheckFloats(nsBlockReflowState& aState);
    1: 
    1:   //----------------------------------------
    1:   // List handling kludge
    1: 
 1158:   // If this returns PR_TRUE, the block it's called on should get the
 1158:   // NS_FRAME_HAS_DIRTY_CHILDREN bit set on it by the caller; either directly
 1158:   // if it's already in reflow, or via calling FrameNeedsReflow() to schedule a
 1158:   // reflow.
 1158:   PRBool RenumberLists(nsPresContext* aPresContext);
    1: 
12165:   static PRBool RenumberListsInBlock(nsPresContext* aPresContext,
12165:                                      nsBlockFrame* aBlockFrame,
    1:                                      PRInt32* aOrdinal,
    1:                                      PRInt32 aDepth);
    1: 
12165:   static PRBool RenumberListsFor(nsPresContext* aPresContext, nsIFrame* aKid, PRInt32* aOrdinal, PRInt32 aDepth);
    1: 
    1:   static PRBool FrameStartsCounterScope(nsIFrame* aFrame);
    1: 
    1:   void ReflowBullet(nsBlockReflowState& aState,
11520:                     nsHTMLReflowMetrics& aMetrics,
11520:                     nscoord aLineTop);
    1: 
    1:   //----------------------------------------
    1: 
21112:   virtual nsILineIterator* GetLineIterator();
21112: 
    1: public:
    1:   nsLineList* GetOverflowLines() const;
    1: protected:
    1:   nsLineList* RemoveOverflowLines();
    1:   nsresult SetOverflowLines(nsLineList* aOverflowLines);
    1: 
    1:   /**
    1:    * This class is useful for efficiently modifying the out of flow
    1:    * overflow list. It gives the client direct writable access to
    1:    * the frame list temporarily but ensures that property is only
    1:    * written back if absolutely necessary.
    1:    */
    1:   struct nsAutoOOFFrameList {
    1:     nsFrameList mList;
    1: 
32843:     nsAutoOOFFrameList(nsBlockFrame* aBlock)
33010:       : mPropValue(aBlock->GetOverflowOutOfFlows())
33010:       , mBlock(aBlock) {
33010:       if (mPropValue) {
33010:         mList = *mPropValue;
33010:       }
33010:     }
    1:     ~nsAutoOOFFrameList() {
33010:       mBlock->SetOverflowOutOfFlows(mList, mPropValue);
    1:     }
    1:   protected:
33010:     nsFrameList* const mPropValue;
32843:     nsBlockFrame* const mBlock;
    1:   };
    1:   friend struct nsAutoOOFFrameList;
    1: 
33010:   nsFrameList* GetOverflowOutOfFlows() const;
33010:   void SetOverflowOutOfFlows(const nsFrameList& aList, nsFrameList* aPropValue);
    1: 
49010:   // Get the pushed floats list
49010:   nsFrameList* GetPushedFloats() const;
49010:   // Get the pushed floats list, or if there is not currently one,
48990:   // make a new empty one.
49010:   nsFrameList* EnsurePushedFloats();
49010:   // Remove and return the pushed floats list.
49010:   nsFrameList* RemovePushedFloats();
48990: 
    1: #ifdef NS_DEBUG
    1:   void VerifyLines(PRBool aFinalCheckOK);
    1:   void VerifyOverflowSituation();
    1:   PRInt32 GetDepth() const;
    1: #endif
    1: 
    1:   nscoord mMinWidth, mPrefWidth;
    1: 
    1:   nsLineList mLines;
    1: 
    1:   // List of all floats in this block
    1:   nsFrameList mFloats;
    1: 
    1:   // XXX_fix_me: subclass one more time!
    1:   // For list-item frames, this is the bullet frame.
    1:   nsBulletFrame* mBullet;
    1: 
    1:   friend class nsBlockReflowState;
 5145:   friend class nsBlockInFlowLineIterator;
    1: 
    1: private:
    1:   nsAbsoluteContainingBlock mAbsoluteContainer;
    1: 
    1: 
    1: #ifdef DEBUG
    1: public:
    1:   static PRBool gLamePaintMetrics;
    1:   static PRBool gLameReflowMetrics;
    1:   static PRBool gNoisy;
    1:   static PRBool gNoisyDamageRepair;
    1:   static PRBool gNoisyIntrinsic;
    1:   static PRBool gNoisyReflow;
    1:   static PRBool gReallyNoisyReflow;
23305:   static PRBool gNoisyFloatManager;
    1:   static PRBool gVerifyLines;
    1:   static PRBool gDisableResizeOpt;
    1: 
    1:   static PRInt32 gNoiseIndent;
    1: 
    1:   static const char* kReflowCommandType[];
    1: 
    1: protected:
    1:   static void InitDebugFlags();
    1: #endif
    1: };
    1: 
    1: #ifdef DEBUG
    1: class AutoNoisyIndenter {
    1: public:
    1:   AutoNoisyIndenter(PRBool aDoIndent) : mIndented(aDoIndent) {
    1:     if (mIndented) {
    1:       nsBlockFrame::gNoiseIndent++;
    1:     }
    1:   }
    1:   ~AutoNoisyIndenter() {
    1:     if (mIndented) {
    1:       nsBlockFrame::gNoiseIndent--;
    1:     }
    1:   }
    1: private:
    1:   PRBool mIndented;
    1: };
    1: #endif
    1: 
 5145: /**
 5145:  * Iterates over all lines in the prev-in-flows/next-in-flows of this block.
 5145:  */
 5145: class nsBlockInFlowLineIterator {
 5145: public:
 5145:   typedef nsBlockFrame::line_iterator line_iterator;
10962:   nsBlockInFlowLineIterator(nsBlockFrame* aFrame, line_iterator aLine, PRBool aInOverflow);
12355:   /**
12355:    * Set up the iterator to point to the first line found starting from
12355:    * aFrame. Sets aFoundValidLine to false if there is no such line.
54260:    * After aFoundValidLine has returned false, don't call any methods on this
54260:    * object again.
12355:    */
12165:   nsBlockInFlowLineIterator(nsBlockFrame* aFrame, PRBool* aFoundValidLine);
12355:   /**
12355:    * Set up the iterator to point to the line that contains aFindFrame (either
12355:    * directly or indirectly).  If aFrame is out of flow, or contained in an
12355:    * out-of-flow, finds the line containing the out-of-flow's placeholder. If
54260:    * the frame is not found, sets aFoundValidLine to false. After
54260:    * aFoundValidLine has returned false, don't call any methods on this
54260:    * object again.
12355:    */
12355:   nsBlockInFlowLineIterator(nsBlockFrame* aFrame, nsIFrame* aFindFrame,
12355:                             PRBool* aFoundValidLine);
 5145: 
 5145:   line_iterator GetLine() { return mLine; }
10962:   PRBool IsLastLineInList();
 5145:   nsBlockFrame* GetContainer() { return mFrame; }
 5145:   PRBool GetInOverflow() { return mInOverflowLines != nsnull; }
14246: 
20345:   /**
20345:    * Returns the current line list we're iterating, null means
20345:    * we're iterating |mLines| of the container.
20345:    */
20345:   nsLineList* GetLineList() { return mInOverflowLines; }
14246: 
14246:   /**
14246:    * Returns the end-iterator of whatever line list we're in.
14246:    */
14246:   line_iterator End();
14246: 
 5145:   /**
 5145:    * Returns false if there are no more lines. After this has returned false,
 5145:    * don't call any methods on this object again.
 5145:    */
 5145:   PRBool Next();
 5145:   /**
 5145:    * Returns false if there are no more lines. After this has returned false,
 5145:    * don't call any methods on this object again.
 5145:    */
 5145:   PRBool Prev();
 5145: 
 5145: private:
 5145:   nsBlockFrame* mFrame;
 5145:   line_iterator mLine;
 5145:   nsLineList*   mInOverflowLines;
12165: 
12165:   /**
12165:    * Moves iterator to next valid line reachable from the current block.
12165:    * Returns false if there are no valid lines.
12165:    */
12165:   PRBool FindValidLine();
 5145: };
 5145: 
    1: #endif /* nsBlockFrame_h___ */
