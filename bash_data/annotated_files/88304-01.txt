29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
25100:  * vim: set ts=8 sw=4 et tw=79:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS object implementation.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
80468: 
80468: #include "mozilla/Util.h"
80468: 
    1: #include "jstypes.h"
55477: #include "jsutil.h"
55477: #include "jshash.h"
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jsinterp.h"
43281: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
67934: #include "jsonparser.h"
    1: #include "jsopcode.h"
73746: #include "jsprobes.h"
42733: #include "jsproxy.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
25215: #include "jsdbgapi.h"
51457: #include "json.h"
74472: #include "jswatchpoint.h"
58714: #include "jswrapper.h"
    1: 
87812: #include "builtin/MapObject.h"
80507: #include "frontend/BytecodeCompiler.h"
80964: #include "frontend/BytecodeEmitter.h"
80506: #include "frontend/Parser.h"
86104: #include "js/MemoryMetrics.h"
80506: 
77343: #include "jsarrayinlines.h"
53840: #include "jsinterpinlines.h"
84052: #include "jsobjinlines.h"
34349: #include "jsscopeinlines.h"
34349: #include "jsscriptinlines.h"
84052: #include "jsstrinlines.h"
34349: 
80701: #include "vm/BooleanObject-inl.h"
78915: #include "vm/NumberObject-inl.h"
69242: #include "vm/StringObject-inl.h"
69242: 
    1: #if JS_HAS_GENERATORS
    1: #include "jsiter.h"
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_XDR
    1: #include "jsxdrapi.h"
    1: #endif
    1: 
30283: #include "jsatominlines.h"
35117: #include "jsobjinlines.h"
32737: #include "jsscriptinlines.h"
30283: 
15453: #include "jsautooplen.h"
15453: 
80468: using namespace mozilla;
37741: using namespace js;
54707: using namespace js::gc;
77343: using namespace js::types;
37741: 
84755: JS_STATIC_ASSERT(int32_t((JSObject::NELEMENTS_LIMIT - 1) * sizeof(Value)) == int64_t((JSObject::NELEMENTS_LIMIT - 1) * sizeof(Value)));
84338: 
77817: Class js::ObjectClass = {
    1:     js_Object_str,
53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
78614:     JS_PropertyStub,         /* addProperty */
78614:     JS_PropertyStub,         /* delProperty */
78614:     JS_PropertyStub,         /* getProperty */
78614:     JS_StrictPropertyStub,   /* setProperty */
78614:     JS_EnumerateStub,
78614:     JS_ResolveStub,
78614:     JS_ConvertStub
    1: };
    1: 
48622: JS_FRIEND_API(JSObject *)
79734: JS_ObjectToInnerObject(JSContext *cx, JSObject *obj)
79734: {
79734:     if (!obj) {
79734:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INACTIVE);
79734:         return NULL;
79734:     }
79734:     OBJ_TO_INNER_OBJECT(cx, obj);
79734:     return obj;
79734: }
79734: 
79734: JS_FRIEND_API(JSObject *)
79734: JS_ObjectToOuterObject(JSContext *cx, JSObject *obj)
48622: {
48622:     OBJ_TO_OUTER_OBJECT(cx, obj);
48622:     return obj;
48622: }
48622: 
    1: #if JS_HAS_OBJ_PROTO_PROP
    1: 
    1: static JSBool
48470: obj_getProto(JSContext *cx, JSObject *obj, jsid id, Value *vp);
    1: 
    1: static JSBool
62395: obj_setProto(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp);
    1: 
78466: JSPropertySpec object_props[] = {
78614:     {js_proto_str, 0, JSPROP_PERMANENT|JSPROP_SHARED, obj_getProto, obj_setProto},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: static JSBool
48470: obj_getProto(JSContext *cx, JSObject *obj, jsid id, Value *vp)
41968: {
47455:     /* Let CheckAccess get the slot's value, based on the access mode. */
    1:     uintN attrs;
41968:     id = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
50518:     return CheckAccess(cx, obj, id, JSACC_PROTO, vp, &attrs);
    1: }
    1: 
74914: size_t sSetProtoCalled = 0;
74914: 
    1: static JSBool
62395: obj_setProto(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
48470: {
74914:     if (!cx->runningWithTrustedPrincipals())
74914:         ++sSetProtoCalled;
74914: 
54563:     /* ECMAScript 5 8.6.2 forbids changing [[Prototype]] if not [[Extensible]]. */
54563:     if (!obj->isExtensible()) {
54587:         obj->reportNotExtensible(cx);
54563:         return false;
54563:     }
54563: 
48470:     if (!vp->isObjectOrNull())
87850:         return JS_TRUE;
41968: 
48470:     JSObject *pobj = vp->toObjectOrNull();
87850:     if (pobj) {
87850:         /*
87850:          * Innerize pobj here to avoid sticking unwanted properties on the
87850:          * outer object. This ensures that any with statements only grant
87850:          * access to the inner object.
87850:          */
87850:         OBJ_TO_INNER_OBJECT(cx, pobj);
87850:         if (!pobj)
87850:             return JS_FALSE;
87850:     }
87850: 
41968:     uintN attrs;
41968:     id = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
50518:     if (!CheckAccess(cx, obj, id, JSAccessMode(JSACC_PROTO|JSACC_WRITE), vp, &attrs))
87850:         return JS_FALSE;
87850: 
87850:     return SetProto(cx, obj, pobj, JS_TRUE);
    1: }
    1: 
    1: #else  /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: #define object_props NULL
    1: 
    1: #endif /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
18907: static JSHashNumber
    1: js_hash_object(const void *key)
    1: {
48470:     return JSHashNumber(uintptr_t(key) >> JS_GCTHING_ALIGN);
    1: }
    1: 
    1: static JSHashEntry *
    1: MarkSharpObjects(JSContext *cx, JSObject *obj, JSIdArray **idap)
    1: {
88138:     JS_CHECK_RECURSION(cx, return NULL);
88138: 
    1:     JSIdArray *ida;
88138: 
88138:     JSSharpObjectMap *map = &cx->sharpObjectMap;
23915:     JS_ASSERT(map->depth >= 1);
88138:     JSHashTable *table = map->table;
88138:     JSHashNumber hash = js_hash_object(obj);
88138:     JSHashEntry **hep = JS_HashTableRawLookup(table, hash, obj);
88138:     JSHashEntry *he = *hep;
    1:     if (!he) {
88138:         jsatomid sharpid = 0;
40292:         he = JS_HashTableRawAdd(table, hep, hash, obj, (void *) sharpid);
    1:         if (!he) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1: 
    1:         ida = JS_Enumerate(cx, obj);
    1:         if (!ida)
    1:             return NULL;
    1: 
88138:         bool ok = true;
88138:         for (jsint i = 0, length = ida->length; i < length; i++) {
88138:             jsid id = ida->vector[i];
88138:             JSObject *obj2;
88138:             JSProperty *prop;
80442:             ok = obj->lookupGeneric(cx, id, &obj2, &prop);
    1:             if (!ok)
    1:                 break;
    1:             if (!prop)
    1:                 continue;
42834:             bool hasGetter, hasSetter;
48470:             AutoValueRooter v(cx);
48470:             AutoValueRooter setter(cx);
43202:             if (obj2->isNative()) {
52503:                 const Shape *shape = (Shape *) prop;
52503:                 hasGetter = shape->hasGetterValue();
52503:                 hasSetter = shape->hasSetterValue();
42834:                 if (hasGetter)
52503:                     v.set(shape->getterValue());
42834:                 if (hasSetter)
52503:                     setter.set(shape->setterValue());
42834:             } else {
42834:                 hasGetter = hasSetter = false;
42834:             }
42834:             if (hasSetter) {
    1:                 /* Mark the getter, then set val to setter. */
48470:                 if (hasGetter && v.value().isObject()) {
48470:                     ok = !!MarkSharpObjects(cx, &v.value().toObject(), NULL);
    1:                     if (!ok)
    1:                         break;
42834:                 }
42834:                 v.set(setter.value());
42834:             } else if (!hasGetter) {
78675:                 ok = obj->getGeneric(cx, id, v.addr());
42834:                 if (!ok)
42834:                     break;
42834:             }
88138:             if (v.value().isObject() && !MarkSharpObjects(cx, &v.value().toObject(), NULL)) {
88138:                 ok = false;
    1:                 break;
    1:             }
    1:         }
    1:         if (!ok || !idap)
    1:             JS_DestroyIdArray(cx, ida);
    1:         if (!ok)
    1:             return NULL;
    1:     } else {
88138:         jsatomid sharpid = uintptr_t(he->value);
    1:         if (sharpid == 0) {
    1:             sharpid = ++map->sharpgen << SHARP_ID_SHIFT;
40292:             he->value = (void *) sharpid;
    1:         }
    1:         ida = NULL;
    1:     }
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: }
    1: 
    1: JSHashEntry *
88138: js_EnterSharpObject(JSContext *cx, JSObject *obj, JSIdArray **idap, bool *alreadySeen)
88138: {
25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
    1:         return NULL;
    1: 
88138:     *alreadySeen = false;
88138: 
88138:     JSSharpObjectMap *map = &cx->sharpObjectMap;
88138:     JSHashTable *table = map->table;
    1:     if (!table) {
    1:         table = JS_NewHashTable(8, js_hash_object, JS_CompareValues,
    1:                                 JS_CompareValues, NULL, NULL);
    1:         if (!table) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:         map->table = table;
    1:         JS_KEEP_ATOMS(cx->runtime);
    1:     }
    1: 
88138:     JSHashEntry *he;
88138:     jsatomid sharpid;
88138:     JSIdArray *ida = NULL;
88138: 
    1:     /* From this point the control must flow either through out: or bad:. */
    1:     if (map->depth == 0) {
23915:         /*
23915:          * Although MarkSharpObjects tries to avoid invoking getters,
23915:          * it ends up doing so anyway under some circumstances; for
23915:          * example, if a wrapped object has getters, the wrapper will
23915:          * prevent MarkSharpObjects from recognizing them as such.
23915:          * This could lead to js_LeaveSharpObject being called while
23915:          * MarkSharpObjects is still working.
23915:          *
23915:          * Increment map->depth while we call MarkSharpObjects, to
23915:          * ensure that such a call doesn't free the hash table we're
23915:          * still using.
23915:          */
23915:         ++map->depth;
    1:         he = MarkSharpObjects(cx, obj, &ida);
23915:         --map->depth;
    1:         if (!he)
    1:             goto bad;
40292:         JS_ASSERT((uintptr_t(he->value) & SHARP_BIT) == 0);
    1:         if (!idap) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             ida = NULL;
    1:         }
    1:     } else {
88138:         JSHashNumber hash = js_hash_object(obj);
88138:         JSHashEntry **hep = JS_HashTableRawLookup(table, hash, obj);
    1:         he = *hep;
    1: 
    1:         /*
    1:          * It's possible that the value of a property has changed from the
    1:          * first time the object's properties are traversed (when the property
    1:          * ids are entered into the hash table) to the second (when they are
31501:          * converted to strings), i.e., the JSObject::getProperty() call is not
    1:          * idempotent.
    1:          */
    1:         if (!he) {
    1:             he = JS_HashTableRawAdd(table, hep, hash, obj, NULL);
    1:             if (!he) {
    1:                 JS_ReportOutOfMemory(cx);
    1:                 goto bad;
    1:             }
    1:             sharpid = 0;
    1:             goto out;
    1:         }
    1:     }
    1: 
40292:     sharpid = uintptr_t(he->value);
88138:     if (sharpid != 0)
88138:         *alreadySeen = true;
    1: 
    1: out:
    1:     JS_ASSERT(he);
    1:     if ((sharpid & SHARP_BIT) == 0) {
    1:         if (idap && !ida) {
    1:             ida = JS_Enumerate(cx, obj);
88138:             if (!ida)
    1:                 goto bad;
    1:         }
    1:         map->depth++;
    1:     }
    1: 
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: 
    1: bad:
    1:     /* Clean up the sharpObjectMap table on outermost error. */
    1:     if (map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: void
    1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap)
    1: {
88138:     JSSharpObjectMap *map = &cx->sharpObjectMap;
    1:     JS_ASSERT(map->depth > 0);
    1:     if (--map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     if (idap) {
88138:         if (JSIdArray *ida = *idap) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             *idap = NULL;
    1:         }
    1:     }
    1: }
    1: 
18907: static intN
    1: gc_sharp_table_entry_marker(JSHashEntry *he, intN i, void *arg)
    1: {
82129:     MarkRoot((JSTracer *)arg, (JSObject *)he->key, "sharp table entry");
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
  583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map)
    1: {
    1:     JS_ASSERT(map->depth > 0);
    1:     JS_ASSERT(map->table);
    1: 
    1:     /*
    1:      * During recursive calls to MarkSharpObjects a non-native object or
    1:      * object with a custom getProperty method can potentially return an
    1:      * unrooted value or even cut from the object graph an argument of one of
    1:      * MarkSharpObjects recursive invocations. So we must protect map->table
    1:      * entries against GC.
    1:      *
    1:      * We can not simply use JSTempValueRooter to mark the obj argument of
    1:      * MarkSharpObjects during recursion as we have to protect *all* entries
    1:      * in JSSharpObjectMap including those that contains otherwise unreachable
    1:      * objects just allocated through custom getProperty. Otherwise newer
    1:      * allocations can re-use the address of an object stored in the hashtable
    1:      * confusing js_EnterSharpObject. So to address the problem we simply
    1:      * mark all objects from map->table.
    1:      *
    1:      * An alternative "proper" solution is to use JSTempValueRooter in
    1:      * MarkSharpObjects with code to remove during finalization entries
    1:      * with otherwise unreachable objects. But this is way too complex
    1:      * to justify spending efforts.
    1:      */
  583:     JS_HashTableEnumerateEntries(map->table, gc_sharp_table_entry_marker, trc);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
 4127: static JSBool
48470: obj_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSBool ok;
88138:     jschar *ochars, *vsharp;
    1:     const jschar *idstrchars, *vchars;
    1:     size_t nchars, idstrlength, gsoplength, vlength, vsharplength, curlen;
16069:     const char *comma;
48470:     Value *val;
    1:     JSString *gsop[2];
59890:     JSString *valstr, *str;
59890:     JSLinearString *idstr;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
48470:     Value localroot[4];
48470:     PodArrayZero(localroot);
80468:     AutoArrayRooter tvr(cx, ArrayLength(localroot), localroot);
    1: 
    1:     /* If outermost, we need parentheses to be an expression, not a block. */
88138:     bool outermost = (cx->sharpObjectMap.depth == 0);
61734: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
88138:     jschar *chars;
88138:     JSIdArray *ida;
88138:     bool alreadySeen = false;
88138:     JSHashEntry *he = js_EnterSharpObject(cx, obj, &ida, &alreadySeen);
82308:     if (!he)
82308:         return false;
82308: 
69323:     if (!ida) {
    1:         /*
88138:          * We've already seen obj, so don't serialize it again (particularly as
88138:          * we might recur in the process): just serialize an empty object.
    1:          */
88138:         JS_ASSERT(alreadySeen);
88138:         JSString *str = js_NewStringCopyZ(cx, "{}");
88138:         if (!str)
88138:             return false;
88138:         vp->setString(str);
88138:         return true;
    1:     }
69323:     JS_ASSERT(!IS_SHARP(he));
    1:     ok = JS_TRUE;
    1: 
88138:     if (alreadySeen)
88138:         MAKE_SHARP(he);
88138: 
    1:     /* If outermost, allocate 4 + 1 for "({})" and the terminator. */
64560:     chars = (jschar *) cx->malloc_(((outermost ? 4 : 2) + 1) * sizeof(jschar));
    1:     nchars = 0;
    1:     if (!chars)
    1:         goto error;
    1:     if (outermost)
    1:         chars[nchars++] = '(';
    1: 
    1:     chars[nchars++] = '{';
    1: 
    1:     comma = NULL;
    1: 
    1:     /*
    1:      * We have four local roots for cooked and raw value GC safety.  Hoist the
 6917:      * "localroot + 2" out of the loop using the val local, which refers to
 6917:      * the raw (unconverted, "uncooked") values.
    1:      */
 6917:     val = localroot + 2;
    1: 
40855:     for (jsint i = 0, length = ida->length; i < length; i++) {
 4127:         /* Get strings for id and value and GC-root them via vp. */
40855:         jsid id = ida->vector[i];
40855: 
88138:         JSObject *obj2;
88138:         JSProperty *prop;
80442:         ok = obj->lookupGeneric(cx, id, &obj2, &prop);
    1:         if (!ok)
    1:             goto error;
  969: 
  969:         /*
48470:          * Convert id to a value and then to a string.  Decide early whether we
  969:          * prefer get/set or old getter/setter syntax.
  969:          */
84160:         JSString *s = ToString(cx, IdToValue(id));
59890:         if (!s || !(idstr = s->ensureLinear(cx))) {
  969:             ok = JS_FALSE;
  969:             goto error;
  969:         }
48470:         vp->setString(idstr);                           /* local root */
40855: 
40855:         jsint valcnt = 0;
    1:         if (prop) {
43183:             bool doGet = true;
43202:             if (obj2->isNative()) {
52503:                 const Shape *shape = (Shape *) prop;
52503:                 unsigned attrs = shape->attributes();
    1:                 if (attrs & JSPROP_GETTER) {
43183:                     doGet = false;
52503:                     val[valcnt] = shape->getterValue();
64345:                     gsop[valcnt] = cx->runtime->atomState.getAtom;
 1677:                     valcnt++;
    1:                 }
    1:                 if (attrs & JSPROP_SETTER) {
43183:                     doGet = false;
52503:                     val[valcnt] = shape->setterValue();
64345:                     gsop[valcnt] = cx->runtime->atomState.setAtom;
    1:                     valcnt++;
 1677:                 }
43183:             }
43183:             if (doGet) {
    1:                 valcnt = 1;
    1:                 gsop[0] = NULL;
78675:                 ok = obj->getGeneric(cx, id, &val[0]);
    1:                 if (!ok)
    1:                     goto error;
43183:             }
43183:         }
    1: 
    1:         /*
40855:          * If id is a string that's not an identifier, or if it's a negative
40855:          * integer, then it must be quoted.
    1:          */
80633:         bool idIsLexicalIdentifier = IsIdentifier(idstr);
 4529:         if (JSID_IS_ATOM(id)
  969:             ? !idIsLexicalIdentifier
 4529:             : (!JSID_IS_INT(id) || JSID_TO_INT(id) < 0)) {
59890:             s = js_QuoteString(cx, idstr, jschar('\''));
59890:             if (!s || !(idstr = s->ensureLinear(cx))) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
48470:             vp->setString(idstr);                       /* local root */
    1:         }
59890:         idstrlength = idstr->length();
59890:         idstrchars = idstr->getChars(cx);
59890:         if (!idstrchars) {
59890:             ok = JS_FALSE;
59890:             goto error;
59890:         }
    1: 
40855:         for (jsint j = 0; j < valcnt; j++) {
40855:             /*
40855:              * Censor an accessor descriptor getter or setter part if it's
40855:              * undefined.
40855:              */
48470:             if (gsop[j] && val[j].isUndefined())
40855:                 continue;
40855: 
    1:             /* Convert val[j] to its canonical source form. */
    1:             valstr = js_ValueToSource(cx, val[j]);
    1:             if (!valstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
48470:             localroot[j].setString(valstr);             /* local root */
59890:             vchars = valstr->getChars(cx);
59890:             if (!vchars) {
59890:                 ok = JS_FALSE;
59890:                 goto error;
59890:             }
59890:             vlength = valstr->length();
    1: 
40855:             /*
40855:              * If val[j] is a non-sharp object, and we're not serializing an
40855:              * accessor (ECMA syntax can't accommodate sharpened accessors),
40855:              * consider sharpening it.
40855:              */
    1:             vsharp = NULL;
    1:             vsharplength = 0;
    1: 
 2149:             /*
 2149:              * Remove '(function ' from the beginning of valstr and ')' from the
 2149:              * end so that we can put "get" in front of the function definition.
 2149:              */
48470:             if (gsop[j] && IsFunctionObject(val[j])) {
 2149:                 const jschar *start = vchars;
 2149:                 const jschar *end = vchars + vlength;
 2149: 
84755:                 uint8_t parenChomp = 0;
 2149:                 if (vchars[0] == '(') {
 2149:                     vchars++;
 2149:                     parenChomp = 1;
 2149:                 }
 2149: 
 2149:                 /* Try to jump "function" keyword. */
 2149:                 if (vchars)
 2149:                     vchars = js_strchr_limit(vchars, ' ', end);
 2149: 
40855:                 /*
40855:                  * Jump over the function's name: it can't be encoded as part
40855:                  * of an ECMA getter or setter.
40855:                  */
40855:                 if (vchars)
40855:                     vchars = js_strchr_limit(vchars, '(', end);
40855: 
 2149:                 if (vchars) {
 2149:                     if (*vchars == ' ')
 2149:                         vchars++;
 2149:                     vlength = end - vchars - parenChomp;
 2149:                 } else {
 2149:                     gsop[j] = NULL;
 2149:                     vchars = start;
 2149:                 }
 2149:             }
 2149: 
    1: #define SAFE_ADD(n)                                                          \
    1:     JS_BEGIN_MACRO                                                           \
    1:         size_t n_ = (n);                                                     \
    1:         curlen += n_;                                                        \
    1:         if (curlen < n_)                                                     \
    1:             goto overflow;                                                   \
    1:     JS_END_MACRO
    1: 
    1:             curlen = nchars;
    1:             if (comma)
    1:                 SAFE_ADD(2);
    1:             SAFE_ADD(idstrlength + 1);
    1:             if (gsop[j])
29366:                 SAFE_ADD(gsop[j]->length() + 1);
    1:             SAFE_ADD(vsharplength);
    1:             SAFE_ADD(vlength);
    1:             /* Account for the trailing null. */
    1:             SAFE_ADD((outermost ? 2 : 1) + 1);
    1: #undef SAFE_ADD
    1: 
40855:             if (curlen > size_t(-1) / sizeof(jschar))
    1:                 goto overflow;
    1: 
    1:             /* Allocate 1 + 1 at end for closing brace and terminating 0. */
64560:             chars = (jschar *) cx->realloc_((ochars = chars), curlen * sizeof(jschar));
    1:             if (!chars) {
59890:                 chars = ochars;
59890:                 goto overflow;
    1:             }
    1: 
    1:             if (comma) {
    1:                 chars[nchars++] = comma[0];
    1:                 chars[nchars++] = comma[1];
    1:             }
    1:             comma = ", ";
    1: 
    1:             if (gsop[j]) {
29366:                 gsoplength = gsop[j]->length();
59890:                 const jschar *gsopchars = gsop[j]->getChars(cx);
59890:                 if (!gsopchars)
59890:                     goto overflow;
59890:                 js_strncpy(&chars[nchars], gsopchars, gsoplength);
    1:                 nchars += gsoplength;
    1:                 chars[nchars++] = ' ';
    1:             }
    1:             js_strncpy(&chars[nchars], idstrchars, idstrlength);
    1:             nchars += idstrlength;
  969:             /* Extraneous space after id here will be extracted later */
    1:             chars[nchars++] = gsop[j] ? ' ' : ':';
 1490: 
    1:             if (vsharplength) {
    1:                 js_strncpy(&chars[nchars], vsharp, vsharplength);
    1:                 nchars += vsharplength;
    1:             }
    1:             js_strncpy(&chars[nchars], vchars, vlength);
    1:             nchars += vlength;
    1: 
    1:             if (vsharp)
64560:                 cx->free_(vsharp);
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '}';
    1:     if (outermost)
    1:         chars[nchars++] = ')';
    1:     chars[nchars] = 0;
    1: 
    1:   error:
    1:     js_LeaveSharpObject(cx, &ida);
    1: 
    1:     if (!ok) {
    1:         if (chars)
64560:             Foreground::free_(chars);
82308:         return false;
    1:     }
    1: 
    1:     if (!chars) {
    1:         JS_ReportOutOfMemory(cx);
82308:         return false;
    1:     }
88138: 
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
64560:         cx->free_(chars);
82308:         return false;
    1:     }
48470:     vp->setString(str);
82308:     return true;
    1: 
    1:   overflow:
64560:     cx->free_(vsharp);
64560:     cx->free_(chars);
    1:     chars = NULL;
    1:     goto error;
    1: }
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
47498: namespace js {
47498: 
47498: JSString *
47498: obj_toStringHelper(JSContext *cx, JSObject *obj)
47498: {
47498:     if (obj->isProxy())
79386:         return Proxy::obj_toString(cx, obj);
47498: 
84052:     StringBuffer sb(cx);
84052:     const char *className = obj->getClass()->name;
84052:     if (!sb.append("[object ") || !sb.appendInflated(className, strlen(className)) || 
84052:         !sb.append("]"))
84052:     {
47498:         return NULL;
84052:     }
84052:     return sb.finishString();
47498: }
47498: 
68911: JSObject *
68911: NonNullObject(JSContext *cx, const Value &v)
68911: {
68911:     if (v.isPrimitive()) {
68911:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
68911:         return NULL;
68911:     }
68911:     return &v.toObject();
68911: }
68911: 
75433: const char *
75433: InformalValueTypeName(const Value &v)
75433: {
76241:     if (v.isObject())
76241:         return v.toObject().getClass()->name;
76241:     if (v.isString())
76241:         return "string";
76241:     if (v.isNumber())
76241:         return "number";
76241:     if (v.isBoolean())
76241:         return "boolean";
76241:     if (v.isNull())
76241:         return "null";
76241:     if (v.isUndefined())
76241:         return "undefined";
76241:     return "value";
76241: }
76241: 
76241: } /* namespace js */
47498: 
55714: /* ES5 15.2.4.2.  Note steps 1 and 2 are errata. */
47498: static JSBool
48470: obj_toString(JSContext *cx, uintN argc, Value *vp)
48470: {
55714:     Value &thisv = vp[1];
55714: 
61734:     /* Step 1. */
55714:     if (thisv.isUndefined()) {
64345:         vp->setString(cx->runtime->atomState.objectUndefinedAtom);
55714:         return true;
55714:     }
55714: 
61734:     /* Step 2. */
55714:     if (thisv.isNull()) {
64345:         vp->setString(cx->runtime->atomState.objectNullAtom);
55714:         return true;
55714:     }
55714: 
61734:     /* Step 3. */
61734:     JSObject *obj = ToObject(cx, &thisv);
61734:     if (!obj)
47498:         return false;
47498: 
61734:     /* Steps 4-5. */
61734:     JSString *str = js::obj_toStringHelper(cx, obj);
47498:     if (!str)
47498:         return false;
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: 
69828: /* ES5 15.2.4.3. */
    1: static JSBool
48470: obj_toLocaleString(JSContext *cx, uintN argc, Value *vp)
48470: {
69828:     JS_CHECK_RECURSION(cx, return false);
69828: 
69828:     /* Step 1. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
69828:     /* Steps 2-4. */
69828:     return obj->callMethod(cx, ATOM_TO_JSID(cx->runtime->atomState.toStringAtom), 0, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: obj_valueOf(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     vp->setObject(*obj);
61734:     return true;
    1: }
    1: 
68932: /* We should be able to assert this for *any* fp->scopeChain(). */
68894: static void
68932: AssertInnerizedScopeChain(JSContext *cx, JSObject &scopeobj)
68894: {
68894: #ifdef DEBUG
86483:     for (JSObject *o = &scopeobj; o; o = o->enclosingScope()) {
68894:         if (JSObjectOp op = o->getClass()->ext.innerObject)
68932:             JS_ASSERT(op(cx, o) == o);
68894:     }
68894: #endif
12690: }
12690: 
24375: #ifndef EVAL_CACHE_CHAIN_LIMIT
24375: # define EVAL_CACHE_CHAIN_LIMIT 4
24375: #endif
24375: 
24375: static inline JSScript **
59890: EvalCacheHash(JSContext *cx, JSLinearString *str)
59890: {
59890:     const jschar *s = str->chars();
59890:     size_t n = str->length();
59890: 
24375:     if (n > 100)
24375:         n = 100;
84755:     uint32_t h;
24375:     for (h = 0; n; s++, n--)
24375:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
24375: 
24375:     h *= JS_GOLDEN_RATIO;
24375:     h >>= 32 - JS_EVAL_CACHE_SHIFT;
77659:     return &cx->compartment->evalCache[h];
24375: }
24375: 
55553: static JS_ALWAYS_INLINE JSScript *
69223: EvalCacheLookup(JSContext *cx, JSLinearString *str, StackFrame *caller, uintN staticLevel,
68893:                 JSPrincipals *principals, JSObject &scopeobj, JSScript **bucket)
55553: {
55553:     /*
55553:      * Cache local eval scripts indexed by source qualified by scope.
55553:      *
55553:      * An eval cache entry should never be considered a hit unless its
55553:      * strictness matches that of the new eval code. The existing code takes
55553:      * care of this, because hits are qualified by the function from which
59939:      * eval was called, whose strictness doesn't change. (We don't cache evals
59939:      * in eval code, so the calling function corresponds to the calling script,
59939:      * and its strictness never varies.) Scripts produced by calls to eval from
59939:      * global code aren't cached.
59939:      *
59939:      * FIXME bug 620141: Qualify hits by calling script rather than function.
59939:      * Then we wouldn't need the unintuitive !isEvalFrame() hack in EvalKernel
59939:      * to avoid caching nested evals in functions (thus potentially mismatching
59939:      * on strict mode), and we could cache evals in global code if desired.
55553:      */
55553:     uintN count = 0;
55553:     JSScript **scriptp = bucket;
55553: 
55553:     JSVersion version = cx->findVersion();
55553:     JSScript *script;
55553:     while ((script = *scriptp) != NULL) {
55553:         if (script->savedCallerFun &&
55553:             script->staticLevel == staticLevel &&
61450:             script->getVersion() == version &&
59962:             !script->hasSingletons &&
55553:             (script->principals == principals ||
74005:              (principals && script->principals &&
73723:               principals->subsume(principals, script->principals) &&
55553:               script->principals->subsume(script->principals, principals)))) {
55553:             /*
55553:              * Get the prior (cache-filling) eval's saved caller function.
80991:              * See frontend::CompileScript.
55553:              */
75519:             JSFunction *fun = script->getCallerFunction();
55553: 
55553:             if (fun == caller->fun()) {
55553:                 /*
80634:                  * Get the source string passed for safekeeping in the atom map
80991:                  * by the prior eval to frontend::CompileScript.
55553:                  */
77659:                 JSAtom *src = script->atoms[0];
59890: 
59890:                 if (src == str || EqualStrings(src, str)) {
55553:                     /*
83244:                      * Source matches. Make sure there are no inner objects
83244:                      * which might use the wrong parent and/or call scope by
83244:                      * reusing the previous eval's script. Skip the script's
83244:                      * first object, which entrains the eval's scope.
83244:                      */
83244:                     JS_ASSERT(script->objects()->length >= 1);
83244:                     if (script->objects()->length == 1 &&
83244:                         !JSScript::isValidOffset(script->regexpsOffset)) {
55553:                         JS_ASSERT(staticLevel == script->staticLevel);
82129:                         *scriptp = script->evalHashLink();
82129:                         script->evalHashLink() = NULL;
55553:                         return script;
55553:                     }
55553:                 }
55553:             }
55553:         }
55553: 
55553:         if (++count == EVAL_CACHE_CHAIN_LIMIT)
55553:             return NULL;
82129:         scriptp = &script->evalHashLink();
55553:     }
55553:     return NULL;
55553: }
55553: 
56775: /*
68894:  * There are two things we want to do with each script executed in EvalKernel:
68894:  *  1. notify jsdbgapi about script creation/destruction
68894:  *  2. add the script to the eval cache when EvalKernel is finished
68894:  *
68894:  * NB: Although the eval cache keeps a script alive wrt to the JS engine, from
68894:  * a jsdbgapi user's perspective, we want each eval() to create and destroy a
68894:  * script. This hides implementation details and means we don't have to deal
68894:  * with calls to JS_GetScriptObject for scripts in the eval cache (currently,
82129:  * script->object aliases script->evalHashLink()).
56775:  */
68894: class EvalScriptGuard
68894: {
68894:     JSContext *cx_;
68894:     JSLinearString *str_;
68894:     JSScript **bucket_;
68894:     JSScript *script_;
68894: 
68894:   public:
68894:     EvalScriptGuard(JSContext *cx, JSLinearString *str)
68894:       : cx_(cx),
68894:         str_(str),
68894:         script_(NULL) {
68894:         bucket_ = EvalCacheHash(cx, str);
68894:     }
68894: 
68894:     ~EvalScriptGuard() {
68894:         if (script_) {
68894:             js_CallDestroyScriptHook(cx_, script_);
77343:             script_->isActiveEval = false;
77343:             script_->isCachedEval = true;
82129:             script_->evalHashLink() = *bucket_;
68894:             *bucket_ = script_;
68894:         }
68894:     }
68894: 
69223:     void lookupInEvalCache(StackFrame *caller, uintN staticLevel,
68894:                            JSPrincipals *principals, JSObject &scopeobj) {
68894:         if (JSScript *found = EvalCacheLookup(cx_, str_, caller, staticLevel,
68894:                                               principals, scopeobj, bucket_)) {
68894:             js_CallNewScriptHook(cx_, found, NULL);
68894:             script_ = found;
77343:             script_->isCachedEval = false;
77343:             script_->isActiveEval = true;
68894:         }
68894:     }
68894: 
68894:     void setNewScript(JSScript *script) {
80966:         /* NewScriptFromEmitter has already called js_CallNewScriptHook. */
68894:         JS_ASSERT(!script_ && script);
68894:         script_ = script;
77343:         script_->isActiveEval = true;
68894:     }
68894: 
68894:     bool foundScript() {
68894:         return !!script_;
68894:     }
68894: 
68894:     JSScript *script() const {
68894:         JS_ASSERT(script_);
68894:         return script_;
68894:     }
68894: };
68894: 
71695: /* Define subset of ExecuteType so that casting performs the injection. */
71695: enum EvalType { DIRECT_EVAL = EXECUTE_DIRECT_EVAL, INDIRECT_EVAL = EXECUTE_INDIRECT_EVAL };
71695: 
68894: /*
68894:  * Common code implementing direct and indirect eval.
68894:  *
68894:  * Evaluate call.argv[2], if it is a string, in the context of the given calling
68894:  * frame, with the provided scope chain, with the semantics of either a direct
68894:  * or indirect eval (see ES5 10.4.2).  If this is an indirect eval, scopeobj
68894:  * must be a global object.
68894:  *
68894:  * On success, store the completion value in call.rval and return true.
68894:  */
68894: static bool
79387: EvalKernel(JSContext *cx, const CallArgs &args, EvalType evalType, StackFrame *caller,
68893:            JSObject &scopeobj)
56775: {
68894:     JS_ASSERT((evalType == INDIRECT_EVAL) == (caller == NULL));
68932:     AssertInnerizedScopeChain(cx, scopeobj);
55549: 
86483:     if (!scopeobj.global().isRuntimeCodeGenEnabled(cx)) {
82739:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CSP_BLOCKED_EVAL);
55553:         return false;
39061:     }
39061: 
56775:     /* ES5 15.1.2.1 step 1. */
79387:     if (args.length() < 1) {
79387:         args.rval().setUndefined();
56775:         return true;
56775:     }
79387:     if (!args[0].isString()) {
79387:         args.rval() = args[0];
56775:         return true;
56775:     }
79387:     JSString *str = args[0].toString();
56775: 
56775:     /* ES5 15.1.2.1 steps 2-8. */
56775: 
56775:     /*
56775:      * Per ES5, indirect eval runs in the global scope. (eval is specified this
56775:      * way so that the compiler can make assumptions about what bindings may or
56775:      * may not exist in the current frame if it doesn't see 'eval'.)
56775:      */
56775:     uintN staticLevel;
71695:     Value thisv;
56775:     if (evalType == DIRECT_EVAL) {
56775:         staticLevel = caller->script()->staticLevel + 1;
56775: 
71695:         /*
71695:          * Direct calls to eval are supposed to see the caller's |this|. If we
71695:          * haven't wrapped that yet, do so now, before we make a copy of it for
71695:          * the eval code to use.
71695:          */
71695:         if (!ComputeThis(cx, caller))
71695:             return false;
71695:         thisv = caller->thisValue();
71695: 
56775: #ifdef DEBUG
71363:         jsbytecode *callerPC = caller->pcQuadratic(cx);
84195:         JS_ASSERT(callerPC && JSOp(*callerPC) == JSOP_EVAL);
56775: #endif
56775:     } else {
86483:         JS_ASSERT(args.callee().global() == scopeobj);
56775:         staticLevel = 0;
71695: 
71695:         /* Use the global as 'this', modulo outerization. */
71695:         JSObject *thisobj = scopeobj.thisObject(cx);
71695:         if (!thisobj)
71695:             return false;
71695:         thisv = ObjectValue(*thisobj);
68894:     }
55532: 
59890:     JSLinearString *linearStr = str->ensureLinear(cx);
59890:     if (!linearStr)
59890:         return false;
59890:     const jschar *chars = linearStr->chars();
59890:     size_t length = linearStr->length();
51457: 
51457:     /*
84494:      * If the eval string starts with '(' or '[' and ends with ')' or ']', it may be JSON.
51457:      * Try the JSON parser first because it's much faster.  If the eval string
51457:      * isn't JSON, JSON parsing will probably fail quickly, so little time
51457:      * will be lost.
70299:      *
70299:      * Don't use the JSON parser if the caller is strict mode code, because in
70299:      * strict mode object literals must not have repeated properties, and the
70299:      * JSON parser cheerfully (and correctly) accepts them.  If you're parsing
70299:      * JSON with eval and using strict mode, you deserve to be slow.
51457:      */
70299:     if (length > 2 &&
84494:         ((chars[0] == '[' && chars[length - 1] == ']') ||
84494:         (chars[0] == '(' && chars[length - 1] == ')')) &&
70299:          (!caller || !caller->script()->strictModeCode))
70299:     {
71691:         /*
71691:          * Remarkably, JavaScript syntax is not a superset of JSON syntax:
71691:          * strings in JavaScript cannot contain the Unicode line and paragraph
71691:          * terminator characters U+2028 and U+2029, but strings in JSON can.
71691:          * Rather than force the JSON parser to handle this quirk when used by
71691:          * eval, we simply don't use the JSON parser when either character
71691:          * appears in the provided string.  See bug 657367.
71691:          */
71691:         for (const jschar *cp = &chars[1], *end = &chars[length - 2]; ; cp++) {
71691:             if (*cp == 0x2028 || *cp == 0x2029)
71691:                 break;
71691: 
71691:             if (cp == end) {
84494:                 bool isArray = (chars[0] == '[');
84494:                 JSONParser parser(cx, isArray ? chars : chars + 1, isArray ? length : length - 2,
71691:                                   JSONParser::StrictJSON, JSONParser::NoError);
68894:                 Value tmp;
68894:                 if (!parser.parse(&tmp))
68894:                     return false;
71691:                 if (tmp.isUndefined())
71691:                     break;
79387:                 args.rval() = tmp;
67934:                 return true;
68894:             }
55553:         }
71691:     }
55553: 
68894:     EvalScriptGuard esg(cx, linearStr);
68894: 
79387:     JSPrincipals *principals = PrincipalsForCompiledCode(args, cx);
68894: 
68894:     if (evalType == DIRECT_EVAL && caller->isNonEvalFunctionFrame())
68894:         esg.lookupInEvalCache(caller, staticLevel, principals, scopeobj);
68894: 
68894:     if (!esg.foundScript()) {
68894:         uintN lineno;
84691:         const char *filename;
84691:         JSPrincipals *originPrincipals;
84691:         CurrentScriptFileLineOrigin(cx, &filename, &lineno, &originPrincipals,
84691:                                     evalType == DIRECT_EVAL ? CALLED_FROM_JSOP_EVAL
68894:                                                             : NOT_CALLED_FROM_JSOP_EVAL);
84755:         uint32_t tcflags = TCF_COMPILE_N_GO | TCF_COMPILE_FOR_EVAL;
84691:         JSScript *compiled = frontend::CompileScript(cx, &scopeobj, caller,
84691:                                                      principals, originPrincipals,
80634:                                                      tcflags, chars, length, filename,
80634:                                                      lineno, cx->findVersion(), linearStr,
80634:                                                      staticLevel);
68894:         if (!compiled)
68894:             return false;
68894: 
68894:         esg.setNewScript(compiled);
68894:     }
68894: 
76829:     return ExecuteKernel(cx, esg.script(), scopeobj, thisv, ExecuteType(evalType),
79387:                          NULL /* evalInFrame */, &args.rval());
68894: }
24375: 
33281: /*
68894:  * We once supported a second argument to eval to use as the scope chain
68894:  * when evaluating the code string.  Warn when such uses are seen so that
68894:  * authors will know that support for eval(s, o) has been removed.
62571:  */
68894: static inline bool
79387: WarnOnTooManyArgs(JSContext *cx, const CallArgs &args)
79387: {
79387:     if (args.length() > 1) {
77343:         if (JSScript *script = cx->stack.currentScript()) {
77343:             if (!script->warnedAboutTwoArgumentEval) {
68894:                 static const char TWO_ARGUMENT_WARNING[] =
68894:                     "Support for eval(code, scopeObject) has been removed. "
68894:                     "Use |with (scopeObject) eval(code);| instead.";
68894:                 if (!JS_ReportWarning(cx, TWO_ARGUMENT_WARNING))
68894:                     return false;
77343:                 script->warnedAboutTwoArgumentEval = true;
68894:             }
68894:         } else {
62571:             /*
68894:              * In the case of an indirect call without a caller frame, avoid a
68894:              * potential warning-flood by doing nothing.
33281:              */
68894:         }
68894:     }
68894: 
68894:     return true;
68894: }
55482: 
78466: namespace js {
78466: 
    1: /*
68894:  * ES5 15.1.2.1.
68894:  *
68894:  * NB: This method handles only indirect eval.
    1:  */
78466: JSBool
68894: eval(JSContext *cx, uintN argc, Value *vp)
68894: {
79387:     CallArgs args = CallArgsFromVp(argc, vp);
79387:     return WarnOnTooManyArgs(cx, args) &&
86483:            EvalKernel(cx, args, INDIRECT_EVAL, NULL, args.callee().global());
68894: }
68894: 
68894: bool
79387: DirectEval(JSContext *cx, const CallArgs &args)
68894: {
68894:     /* Direct eval can assume it was called from an interpreted frame. */
69223:     StackFrame *caller = cx->fp();
68894:     JS_ASSERT(caller->isScriptFrame());
79387:     JS_ASSERT(IsBuiltinEvalForScope(&caller->scopeChain(), args.calleev()));
84195:     JS_ASSERT(JSOp(*cx->regs().pc) == JSOP_EVAL);
68894: 
83234:     AutoFunctionCallProbe callProbe(cx, args.callee().toFunction(), caller->script());
68894: 
86077:     JSObject *scopeChain = GetScopeChain(cx, caller);
86077:     if (!scopeChain)
86077:         return false;
86077: 
86077:     if (!WarnOnTooManyArgs(cx, args))
86077:         return false;
86077: 
86077:     return EvalKernel(cx, args, DIRECT_EVAL, caller, *scopeChain);
    1: }
    1: 
64210: bool
64228: IsBuiltinEvalForScope(JSObject *scopeChain, const Value &v)
64228: {
86483:     return scopeChain->global().getOriginalEval() == v;
64228: }
64228: 
64228: bool
64228: IsAnyBuiltinEval(JSFunction *fun)
56556: {
56556:     return fun->maybeNative() == eval;
56556: }
56556: 
68894: JSPrincipals *
79387: PrincipalsForCompiledCode(const CallReceiver &call, JSContext *cx)
68894: {
83234:     JS_ASSERT(IsAnyBuiltinEval(call.callee().toFunction()) ||
83234:               IsBuiltinFunctionConstructor(call.callee().toFunction()));
68894: 
68894:     /*
68894:      * To compute the principals of the compiled eval/Function code, we simply
68894:      * use the callee's principals. To see why the caller's principals are
68894:      * ignored, consider first that, in the capability-model we assume, the
68894:      * high-privileged eval/Function should never have escaped to the
68894:      * low-privileged caller. (For the Mozilla embedding, this is brute-enforced
68894:      * by explicit filtering by wrappers.) Thus, the caller's privileges should
68894:      * subsume the callee's.
68894:      *
68894:      * In the converse situation, where the callee has lower privileges than the
68894:      * caller, we might initially guess that the caller would want to retain
68894:      * their higher privileges in the generated code. However, since the
68894:      * compiled code will be run with the callee's scope chain, this would make
68894:      * fp->script()->compartment() != fp->compartment().
68894:      */
68894: 
71362:     return call.callee().principals(cx);
68894: }
68894: 
68894: }  /* namespace js */
56556: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: 
    1: static JSBool
48470: obj_watch_handler(JSContext *cx, JSObject *obj, jsid id, jsval old,
48470:                   jsval *nvp, void *closure)
    1: {
64302:     JSObject *callable = (JSObject *) closure;
68894:     if (JSPrincipals *watcher = callable->principals(cx)) {
77343:         if (JSObject *scopeChain = cx->stack.currentScriptedScopeChain()) {
77343:             if (JSPrincipals *subject = scopeChain->principals(cx)) {
68894:                 if (!watcher->subsume(watcher, subject)) {
    1:                     /* Silently don't call the watch handler. */
68894:                     return JS_TRUE;
68894:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Avoid recursion on (obj, id) already being watched on cx. */
64302:     AutoResolving resolving(cx, obj, id, AutoResolving::WATCH);
64302:     if (resolving.alreadyStarted())
64302:         return true;
64302: 
78614:     Value argv[] = { IdToValue(id), old, *nvp };
80468:     return Invoke(cx, ObjectValue(*obj), ObjectOrNullValue(callable), ArrayLength(argv), argv, nvp);
    1: }
    1: 
    1: static JSBool
48470: obj_watch(JSContext *cx, uintN argc, Value *vp)
48470: {
16519:     if (argc <= 1) {
48470:         js_ReportMissingArg(cx, *vp, 1);
50518:         return JS_FALSE;
16519:     }
16519: 
48470:     JSObject *callable = js_ValueToCallableObject(cx, &vp[3], 0);
    1:     if (!callable)
50518:         return JS_FALSE;
    1: 
48470:     jsid propid;
48470:     if (!ValueToId(cx, vp[2], &propid))
50518:         return JS_FALSE;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
48470:     Value tmp;
48470:     uintN attrs;
61734:     if (!CheckAccess(cx, obj, propid, JSACC_WATCH, &tmp, &attrs))
50518:         return JS_FALSE;
40878: 
48470:     vp->setUndefined();
40878: 
    1:     if (attrs & JSPROP_READONLY)
50518:         return JS_TRUE;
43287:     if (obj->isDenseArray() && !obj->makeDenseArraySlow(cx))
50518:         return JS_FALSE;
48470:     return JS_SetWatchPoint(cx, obj, propid, obj_watch_handler, callable);
    1: }
    1: 
    1: static JSBool
48470: obj_unwatch(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
11809:     if (!obj)
61734:         return false;
48470:     vp->setUndefined();
48470:     jsid id;
48470:     if (argc != 0) {
48470:         if (!ValueToId(cx, vp[2], &id))
48470:             return JS_FALSE;
48470:     } else {
48470:         id = JSID_VOID;
48470:     }
48470:     return JS_ClearWatchPoint(cx, obj, id, NULL, NULL);
    1: }
    1: 
    1: #endif /* JS_HAS_OBJ_WATCHPOINT */
    1: 
    1: /*
    1:  * Prototype and property query methods, to complement the 'in' and
    1:  * 'instanceof' operators.
    1:  */
    1: 
    1: /* Proposed ECMA 15.2.4.5. */
20408: static JSBool
48470: obj_hasOwnProperty(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
80442:     return js_HasOwnPropertyHelper(cx, obj->getOps()->lookupGeneric, argc, vp);
    1: }
    1: 
    1: JSBool
80442: js_HasOwnPropertyHelper(JSContext *cx, LookupGenericOp lookup, uintN argc,
48470:                         Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
    1:         return JS_FALSE;
32721: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
36991:     JSObject *obj2;
36991:     JSProperty *prop;
42733:     if (obj->isProxy()) {
42733:         bool has;
79386:         if (!Proxy::hasOwn(cx, obj, id, &has))
42733:             return false;
48470:         vp->setBoolean(has);
42733:         return true;
42733:     }
42733:     if (!js_HasOwnProperty(cx, lookup, obj, id, &obj2, &prop))
36991:         return JS_FALSE;
56568:     vp->setBoolean(!!prop);
32721:     return JS_TRUE;
18062: }
18062: 
18062: JSBool
80442: js_HasOwnProperty(JSContext *cx, LookupGenericOp lookup, JSObject *obj, jsid id,
36991:                   JSObject **objp, JSProperty **propp)
36991: {
43285:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING);
48622:     if (!(lookup ? lookup : js_LookupProperty)(cx, obj, id, objp, propp))
40327:         return false;
36991:     if (!*propp)
40327:         return true;
36991: 
36991:     if (*objp == obj)
40327:         return true;
36991: 
48622:     JSObject *outer = NULL;
48622:     if (JSObjectOp op = (*objp)->getClass()->ext.outerObject) {
48622:         outer = op(cx, *objp);
 4780:         if (!outer)
40327:             return false;
40327:     }
40327: 
72069:     if (outer != *objp)
36991:         *propp = NULL;
40327:     return true;
    1: }
    1: 
61734: /* ES5 15.2.4.6. */
    1: static JSBool
48470: obj_isPrototypeOf(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     /* Step 1. */
61734:     if (argc < 1 || !vp[2].isObject()) {
61734:         vp->setBoolean(false);
61734:         return true;
61734:     }
61734: 
61734:     /* Step 2. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
40880:     if (!obj)
61734:         return false;
61734: 
61734:     /* Step 3. */
61734:     vp->setBoolean(js_IsDelegate(cx, obj, vp[2]));
61734:     return true;
61734: }
61734: 
61734: /* ES5 15.2.4.7. */
20408: static JSBool
48470: obj_propertyIsEnumerable(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     /* Step 1. */
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
61734:         return false;
61734: 
61734:     /* Step 2. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     /* Steps 3-5. */
61734:     return js_PropertyIsEnumerable(cx, obj, id, vp);
18062: }
18062: 
18062: JSBool
48470: js_PropertyIsEnumerable(JSContext *cx, JSObject *obj, jsid id, Value *vp)
18062: {
18062:     JSObject *pobj;
    1:     JSProperty *prop;
80442:     if (!obj->lookupGeneric(cx, id, &pobj, &prop))
72089:         return false;
    1: 
    1:     if (!prop) {
48470:         vp->setBoolean(false);
72089:         return true;
    1:     }
    1: 
    1:     /*
72089:      * ECMA spec botch: return false unless hasOwnProperty. Leaving "own" out
72089:      * of propertyIsEnumerable's name was a mistake.
    1:      */
72089:     if (pobj != obj) {
48470:         vp->setBoolean(false);
43290:         return true;
43290:     }
72089: 
72089:     uintN attrs;
80622:     if (!pobj->getGenericAttributes(cx, id, &attrs))
72089:         return false;
72089: 
48470:     vp->setBoolean((attrs & JSPROP_ENUMERATE) != 0);
43290:     return true;
    1: }
    1: 
40855: #if OLD_GETTER_SETTER_METHODS
40855: 
40855: const char js_defineGetter_str[] = "__defineGetter__";
40855: const char js_defineSetter_str[] = "__defineSetter__";
40855: const char js_lookupGetter_str[] = "__lookupGetter__";
40855: const char js_lookupSetter_str[] = "__lookupSetter__";
40855: 
86885: enum DefineType { Getter, Setter };
86885: 
86885: template<DefineType Type>
86885: static bool
86885: DefineAccessor(JSContext *cx, uintN argc, Value *vp)
86885: {
86885:     CallArgs args = CallArgsFromVp(argc, vp);
86885:     if (!BoxNonStrictThis(cx, args))
86885:         return false;
86885: 
86885:     if (args.length() < 2 || !js_IsCallable(args[1])) {
86885:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
86885:                              JSMSG_BAD_GETTER_OR_SETTER,
86885:                              Type == Getter ? js_getter_str : js_setter_str);
86885:         return false;
86885:     }
86885: 
86885:     jsid id;
86885:     if (!ValueToId(cx, args[0], &id))
86885:         return false;
86885: 
86885:     JSObject *descObj = NewBuiltinClassInstance(cx, &ObjectClass);
86885:     if (!descObj)
86885:         return false;
86885: 
86885:     JSAtomState &state = cx->runtime->atomState;
86885:     /* enumerable: true */
86885:     if (!descObj->defineProperty(cx, state.enumerableAtom, BooleanValue(true)))
86885:         return false;
86885: 
86885:     /* configurable: true */
86885:     if (!descObj->defineProperty(cx, state.configurableAtom, BooleanValue(true)))
86885:         return false;
86885: 
86885:     /* enumerable: true */
86885:     PropertyName *acc = (Type == Getter) ? state.getAtom : state.setAtom;
86885:     if (!descObj->defineProperty(cx, acc, args[1]))
86885:         return false;
86885: 
86885:     JSBool dummy;
86885:     if (!js_DefineOwnProperty(cx, &args.thisv().toObject(), id, ObjectValue(*descObj), &dummy))
86885:         return false;
86885:     args.rval().setUndefined();
86885:     return true;
86885: }
86885: 
24145: JS_FRIEND_API(JSBool)
79734: js::obj_defineGetter(JSContext *cx, uintN argc, Value *vp)
48470: {
86885:     return DefineAccessor<Getter>(cx, argc, vp);
    1: }
    1: 
24145: JS_FRIEND_API(JSBool)
79734: js::obj_defineSetter(JSContext *cx, uintN argc, Value *vp)
48470: {
86885:     return DefineAccessor<Setter>(cx, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: obj_lookupGetter(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
48470:         return JS_FALSE;
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
48470:     JSObject *pobj;
    1:     JSProperty *prop;
80442:     if (!obj->lookupGeneric(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
48470:     vp->setUndefined();
    1:     if (prop) {
40430:         if (pobj->isNative()) {
52503:             Shape *shape = (Shape *) prop;
52503:             if (shape->hasGetterValue())
52503:                 *vp = shape->getterValue();
43290:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: obj_lookupSetter(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
48470:         return JS_FALSE;
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
48470:     JSObject *pobj;
    1:     JSProperty *prop;
80442:     if (!obj->lookupGeneric(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
48470:     vp->setUndefined();
    1:     if (prop) {
40430:         if (pobj->isNative()) {
52503:             Shape *shape = (Shape *) prop;
52503:             if (shape->hasSetterValue())
52503:                 *vp = shape->setterValue();
43290:         }
    1:     }
    1:     return JS_TRUE;
    1: }
40855: #endif /* OLD_GETTER_SETTER_METHODS */
    1: 
16380: JSBool
48470: obj_getPrototypeOf(JSContext *cx, uintN argc, Value *vp)
48470: {
16519:     if (argc == 0) {
48470:         js_ReportMissingArg(cx, *vp, 0);
16519:         return JS_FALSE;
16519:     }
16519: 
48470:     if (vp[2].isPrimitive()) {
50457:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, vp[2], NULL);
31844:         if (!bytes)
16380:             return JS_FALSE;
31844:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
31844:                              JSMSG_UNEXPECTED_TYPE, bytes, "not an object");
31844:         JS_free(cx, bytes);
31844:         return JS_FALSE;
31844:     }
31844: 
48470:     JSObject *obj = &vp[2].toObject();
48470:     uintN attrs;
50518:     return CheckAccess(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.protoAtom),
16380:                        JSACC_PROTO, vp, &attrs);
16380: }
16380: 
76213: namespace js {
76213: 
76213: bool
76213: NewPropertyDescriptorObject(JSContext *cx, const PropertyDescriptor *desc, Value *vp)
76213: {
76213:     if (!desc->obj) {
76213:         vp->setUndefined();
76213:         return true;
76213:     }
76223: 
42733:     /* We have our own property, so start creating the descriptor. */
76223:     PropDesc d;
76223:     d.initFromPropertyDescriptor(*desc);
76223:     if (!d.makeObject(cx))
76223:         return false;
76223:     *vp = d.pd;
76223:     return true;
76223: }
76223: 
76223: void
76223: PropDesc::initFromPropertyDescriptor(const PropertyDescriptor &desc)
76223: {
76223:     pd.setUndefined();
84755:     attrs = uint8_t(desc.attrs);
84680:     JS_ASSERT_IF(attrs & JSPROP_READONLY, !(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
76223:     if (desc.attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
76223:         hasGet = true;
76223:         get = ((desc.attrs & JSPROP_GETTER) && desc.getter)
76223:               ? CastAsObjectJsval(desc.getter)
76222:               : UndefinedValue();
76223:         hasSet = true;
76223:         set = ((desc.attrs & JSPROP_SETTER) && desc.setter)
76223:               ? CastAsObjectJsval(desc.setter)
76222:               : UndefinedValue();
76223:         hasValue = false;
76223:         value.setUndefined();
76223:         hasWritable = false;
76223:     } else {
76223:         hasGet = false;
76223:         get.setUndefined();
76223:         hasSet = false;
76223:         set.setUndefined();
76223:         hasValue = true;
76223:         value = desc.value;
76223:         hasWritable = true;
76223:     }
76223:     hasEnumerable = true;
76223:     hasConfigurable = true;
76223: }
76223: 
76223: bool
76223: PropDesc::makeObject(JSContext *cx)
76223: {
77817:     JSObject *obj = NewBuiltinClassInstance(cx, &ObjectClass);
76213:     if (!obj)
76213:         return false;
42733: 
42733:     const JSAtomState &atomState = cx->runtime->atomState;
76223:     if ((hasConfigurable &&
80624:          !obj->defineProperty(cx, atomState.configurableAtom,
80624:                               BooleanValue((attrs & JSPROP_PERMANENT) == 0))) ||
76223:         (hasEnumerable &&
80624:          !obj->defineProperty(cx, atomState.enumerableAtom,
80624:                               BooleanValue((attrs & JSPROP_ENUMERATE) != 0))) ||
76223:         (hasGet &&
80624:          !obj->defineProperty(cx, atomState.getAtom, get)) ||
76223:         (hasSet &&
80624:          !obj->defineProperty(cx, atomState.setAtom, set)) ||
76223:         (hasValue &&
80624:          !obj->defineProperty(cx, atomState.valueAtom, value)) ||
76223:         (hasWritable &&
80624:          !obj->defineProperty(cx, atomState.writableAtom,
80624:                               BooleanValue((attrs & JSPROP_READONLY) == 0))))
76223:     {
76223:         return false;
76223:     }
76223: 
76223:     pd.setObject(*obj);
76213:     return true;
76213: }
76213: 
76213: bool
76213: GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, PropertyDescriptor *desc)
40356: {
56606:     if (obj->isProxy())
79386:         return Proxy::getOwnPropertyDescriptor(cx, obj, id, false, desc);
42733: 
36991:     JSObject *pobj;
36991:     JSProperty *prop;
80442:     if (!js_HasOwnProperty(cx, obj->getOps()->lookupGeneric, obj, id, &pobj, &prop))
40356:         return false;
36991:     if (!prop) {
76213:         desc->obj = NULL;
40356:         return true;
32721:     }
32721: 
43290:     bool doGet = true;
43290:     if (pobj->isNative()) {
52503:         Shape *shape = (Shape *) prop;
76213:         desc->attrs = shape->attributes();
76213:         if (desc->attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
43290:             doGet = false;
76213:             if (desc->attrs & JSPROP_GETTER)
76222:                 desc->getter = CastAsPropertyOp(shape->getterObject());
76213:             if (desc->attrs & JSPROP_SETTER)
76222:                 desc->setter = CastAsStrictPropertyOp(shape->setterObject());
35098:         }
54713:     } else {
80622:         if (!pobj->getGenericAttributes(cx, id, &desc->attrs))
76213:             return false;
76213:     }
76213: 
78675:     if (doGet && !obj->getGeneric(cx, id, &desc->value))
76213:         return false;
76213: 
76213:     desc->obj = obj;
76213:     return true;
76213: }
76213: 
76213: bool
76213: GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, Value *vp)
76213: {
76213:     AutoPropertyDescriptorRooter desc(cx);
76213:     return GetOwnPropertyDescriptor(cx, obj, id, &desc) &&
76213:            NewPropertyDescriptorObject(cx, &desc, vp);
76213: }
76213: 
32721: }
32721: 
47569: static bool
48470: GetFirstArgumentAsObject(JSContext *cx, uintN argc, Value *vp, const char *method, JSObject **objp)
47569: {
47569:     if (argc == 0) {
47569:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
47569:                              method, "0", "s");
47569:         return false;
47569:     }
47569: 
48470:     const Value &v = vp[2];
54564:     if (!v.isObject()) {
48470:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
47569:         if (!bytes)
47569:             return false;
47569:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
47569:                              bytes, "not an object");
47569:         JS_free(cx, bytes);
47569:         return false;
47569:     }
47569: 
48470:     *objp = &v.toObject();
47569:     return true;
47569: }
47569: 
33155: static JSBool
48470: obj_getOwnPropertyDescriptor(JSContext *cx, uintN argc, Value *vp)
40356: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.getOwnPropertyDescriptor", &obj))
47569:         return JS_FALSE;
40388:     AutoIdRooter nameidr(cx);
48470:     if (!ValueToId(cx, argc >= 2 ? vp[3] : UndefinedValue(), nameidr.addr()))
40356:         return JS_FALSE;
76213:     return GetOwnPropertyDescriptor(cx, obj, nameidr.id(), vp);
40356: }
40356: 
40356: static JSBool
48470: obj_keys(JSContext *cx, uintN argc, Value *vp)
33155: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.keys", &obj))
57759:         return false;
42733: 
48470:     AutoIdVector props(cx);
54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY, &props))
57759:         return false;
33155: 
48470:     AutoValueVector vals(cx);
57759:     if (!vals.reserve(props.length()))
57759:         return false;
48463:     for (size_t i = 0, len = props.length(); i < len; i++) {
48470:         jsid id = props[i];
48470:         if (JSID_IS_STRING(id)) {
86726:             vals.infallibleAppend(StringValue(JSID_TO_STRING(id)));
57759:         } else if (JSID_IS_INT(id)) {
48470:             JSString *str = js_IntToString(cx, JSID_TO_INT(id));
48470:             if (!str)
57759:                 return false;
64229:             vals.infallibleAppend(StringValue(str));
57759:         } else {
57759:             JS_ASSERT(JSID_IS_OBJECT(id));
48470:         }
48463:     }
48463: 
48463:     JS_ASSERT(props.length() <= UINT32_MAX);
86726:     JSObject *aobj = NewDenseCopiedArray(cx, uint32_t(vals.length()), vals.begin());
33155:     if (!aobj)
57759:         return false;
48470:     vp->setObject(*aobj);
33155: 
57759:     return true;
33155: }
33155: 
54713: static bool
54713: HasProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp, bool *foundp)
54713: {
54713:     if (!obj->hasProperty(cx, id, foundp, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING))
54713:         return false;
54713:     if (!*foundp) {
48470:         vp->setUndefined();
54713:         return true;
54713:     }
54713: 
54713:     /*
54713:      * We must go through the method read barrier in case id is 'get' or 'set'.
54713:      * There is no obvious way to defer cloning a joined function object whose
54713:      * identity will be used by DefinePropertyOnObject, e.g., or reflected via
76213:      * js::GetOwnPropertyDescriptor, as the getter or setter callable object.
54713:      */
78675:     return !!obj->getGeneric(cx, id, vp);
48470: }
48470: 
48470: PropDesc::PropDesc()
48470:   : pd(UndefinedValue()),
48470:     value(UndefinedValue()),
48470:     get(UndefinedValue()),
48470:     set(UndefinedValue()),
36991:     attrs(0),
36991:     hasGet(false),
36991:     hasSet(false),
36991:     hasValue(false),
36991:     hasWritable(false),
36991:     hasEnumerable(false),
36991:     hasConfigurable(false)
36991: {
36991: }
36991: 
36991: bool
76223: PropDesc::initialize(JSContext *cx, const Value &origval, bool checkAccessors)
48470: {
48470:     Value v = origval;
36991: 
36991:     /* 8.10.5 step 1 */
48470:     if (v.isPrimitive()) {
37010:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
36991:         return false;
36991:     }
48470:     JSObject *desc = &v.toObject();
36991: 
42733:     /* Make a copy of the descriptor. We might need it later. */
42733:     pd = v;
42733: 
36991:     /* Start with the proper defaults. */
36991:     attrs = JSPROP_PERMANENT | JSPROP_READONLY;
36991: 
54713:     bool found;
36991: 
36991:     /* 8.10.5 step 3 */
60142: #ifdef __GNUC__ /* quell GCC overwarning */
60142:     found = false;
60142: #endif
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.enumerableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasEnumerable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs |= JSPROP_ENUMERATE;
36991:     }
36991: 
36991:     /* 8.10.5 step 4 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.configurableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasConfigurable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs &= ~JSPROP_PERMANENT;
36991:     }
36991: 
36991:     /* 8.10.5 step 5 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.valueAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasValue = true;
36991:         value = v;
36991:     }
36991: 
36991:     /* 8.10.6 step 6 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.writableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasWritable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs &= ~JSPROP_READONLY;
36991:     }
36991: 
36991:     /* 8.10.7 step 7 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.getAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasGet = true;
36991:         get = v;
36991:         attrs |= JSPROP_GETTER | JSPROP_SHARED;
84680:         attrs &= ~JSPROP_READONLY;
76223:         if (checkAccessors && !checkGetter(cx))
76223:             return false;
36991:     }
36991: 
36991:     /* 8.10.7 step 8 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.setAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasSet = true;
36991:         set = v;
36991:         attrs |= JSPROP_SETTER | JSPROP_SHARED;
84680:         attrs &= ~JSPROP_READONLY;
76223:         if (checkAccessors && !checkSetter(cx))
76223:             return false;
36991:     }
36991: 
36991:     /* 8.10.7 step 9 */
36991:     if ((hasGet || hasSet) && (hasValue || hasWritable)) {
36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INVALID_DESCRIPTOR);
36991:         return false;
36991:     }
36991: 
84680:     JS_ASSERT_IF(attrs & JSPROP_READONLY, !(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
84680: 
36991:     return true;
36991: }
36991: 
36991: static JSBool
36991: Reject(JSContext *cx, uintN errorNumber, bool throwError, jsid id, bool *rval)
36991: {
36991:     if (throwError) {
36991:         jsid idstr;
48470:         if (!js_ValueToStringId(cx, IdToValue(id), &idstr))
36991:            return JS_FALSE;
57812:         JSAutoByteString bytes(cx, JSID_TO_STRING(idstr));
57812:         if (!bytes)
57812:             return JS_FALSE;
57812:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber, bytes.ptr());
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     *rval = false;
36991:     return JS_TRUE;
36991: }
36991: 
36991: static JSBool
54587: Reject(JSContext *cx, JSObject *obj, uintN errorNumber, bool throwError, bool *rval)
36991: {
36991:     if (throwError) {
54587:         if (js_ErrorFormatString[errorNumber].argCount == 1) {
54587:             js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,
54587:                                      JSDVG_IGNORE_STACK, ObjectValue(*obj),
54587:                                      NULL, NULL, NULL);
54587:         } else {
54587:             JS_ASSERT(js_ErrorFormatString[errorNumber].argCount == 0);
36991:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber);
54587:         }
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     *rval = false;
36991:     return JS_TRUE;
36991: }
36991: 
36991: static JSBool
64250: DefinePropertyOnObject(JSContext *cx, JSObject *obj, const jsid &id, const PropDesc &desc,
36991:                        bool throwError, bool *rval)
36991: {
36991:     /* 8.12.9 step 1. */
36991:     JSProperty *current;
36991:     JSObject *obj2;
80442:     JS_ASSERT(!obj->getOps()->lookupGeneric);
64250:     if (!js_HasOwnProperty(cx, NULL, obj, id, &obj2, &current))
36991:         return JS_FALSE;
36991: 
48622:     JS_ASSERT(!obj->getOps()->defineProperty);
36991: 
36991:     /* 8.12.9 steps 2-4. */
36991:     if (!current) {
54563:         if (!obj->isExtensible())
54587:             return Reject(cx, obj, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
36991: 
36991:         *rval = true;
36991: 
36991:         if (desc.isGenericDescriptor() || desc.isDataDescriptor()) {
48622:             JS_ASSERT(!obj->getOps()->defineProperty);
64250:             return js_DefineProperty(cx, obj, id, &desc.value,
78614:                                      JS_PropertyStub, JS_StrictPropertyStub, desc.attrs);
36991:         }
36991: 
36991:         JS_ASSERT(desc.isAccessorDescriptor());
36991: 
50518:         /*
50518:          * Getters and setters are just like watchpoints from an access
50518:          * control point of view.
50518:          */
48470:         Value dummy;
36991:         uintN dummyAttrs;
64250:         if (!CheckAccess(cx, obj, id, JSACC_WATCH, &dummy, &dummyAttrs))
36991:             return JS_FALSE;
36991: 
48470:         Value tmp = UndefinedValue();
64250:         return js_DefineProperty(cx, obj, id, &tmp,
41860:                                  desc.getter(), desc.setter(), desc.attrs);
36991:     }
36991: 
36991:     /* 8.12.9 steps 5-6 (note 5 is merely a special case of 6). */
48470:     Value v = UndefinedValue();
36991: 
72089:     JS_ASSERT(obj == obj2);
36991: 
52503:     const Shape *shape = reinterpret_cast<Shape *>(current);
36991:     do {
36991:         if (desc.isAccessorDescriptor()) {
52503:             if (!shape->isAccessorDescriptor())
36991:                 break;
36991: 
59890:             if (desc.hasGet) {
88099:                 bool same;
59890:                 if (!SameValue(cx, desc.getterValue(), shape->getterOrUndefined(), &same))
88099:                     return false;
59890:                 if (!same)
36991:                     break;
36991:             }
36991: 
59890:             if (desc.hasSet) {
88099:                 bool same;
59890:                 if (!SameValue(cx, desc.setterValue(), shape->setterOrUndefined(), &same))
88099:                     return false;
59890:                 if (!same)
36991:                     break;
36991:             }
36991:         } else {
36991:             /*
36991:              * Determine the current value of the property once, if the current
36991:              * value might actually need to be used or preserved later.  NB: we
36991:              * guard on whether the current property is a data descriptor to
36991:              * avoid calling a getter; we won't need the value if it's not a
36991:              * data descriptor.
36991:              */
52503:             if (shape->isDataDescriptor()) {
36991:                 /*
61685:                  * We must rule out a non-configurable js::PropertyOp-guarded
61685:                  * property becoming a writable unguarded data property, since
61685:                  * such a property can have its value changed to one the getter
61685:                  * and setter preclude.
36991:                  *
61685:                  * A desc lacking writable but with value is a data descriptor
61685:                  * and we must reject it as if it had writable: true if current
61685:                  * is writable.
36991:                  */
52503:                 if (!shape->configurable() &&
61685:                     (!shape->hasDefaultGetter() || !shape->hasDefaultSetter()) &&
61685:                     desc.isDataDescriptor() &&
61685:                     (desc.hasWritable ? desc.writable() : shape->writable()))
61685:                 {
64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
36991:                 }
36991: 
61685:                 if (!js_NativeGet(cx, obj, obj2, shape, JSGET_NO_METHOD_BARRIER, &v))
36991:                     return JS_FALSE;
36991:             }
36991: 
36991:             if (desc.isDataDescriptor()) {
52503:                 if (!shape->isDataDescriptor())
36991:                     break;
36991: 
88099:                 bool same;
59890:                 if (desc.hasValue) {
59890:                     if (!SameValue(cx, desc.value, v, &same))
88099:                         return false;
61689:                     if (!same) {
61689:                         /*
61689:                          * Insist that a non-configurable js::PropertyOp data
61689:                          * property is frozen at exactly the last-got value.
61689:                          *
61689:                          * Duplicate the first part of the big conjunction that
61689:                          * we tested above, rather than add a local bool flag.
61689:                          * Likewise, don't try to keep shape->writable() in a
61689:                          * flag we veto from true to false for non-configurable
61689:                          * PropertyOp-based data properties and test before the
61689:                          * SameValue check later on in order to re-use that "if
61689:                          * (!SameValue) Reject" logic.
61689:                          *
61689:                          * This function is large and complex enough that it
61689:                          * seems best to repeat a small bit of code and return
61689:                          * Reject(...) ASAP, instead of being clever.
61689:                          */
61689:                         if (!shape->configurable() &&
61689:                             (!shape->hasDefaultGetter() || !shape->hasDefaultSetter()))
61689:                         {
64250:                             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
61689:                         }
36991:                         break;
59890:                     }
61689:                 }
52503:                 if (desc.hasWritable && desc.writable() != shape->writable())
36991:                     break;
36991:             } else {
36991:                 /* The only fields in desc will be handled below. */
36991:                 JS_ASSERT(desc.isGenericDescriptor());
36991:             }
36991:         }
36991: 
52503:         if (desc.hasConfigurable && desc.configurable() != shape->configurable())
36991:             break;
52503:         if (desc.hasEnumerable && desc.enumerable() != shape->enumerable())
36991:             break;
36991: 
36991:         /* The conditions imposed by step 5 or step 6 apply. */
36991:         *rval = true;
36991:         return JS_TRUE;
36991:     } while (0);
36991: 
36991:     /* 8.12.9 step 7. */
52503:     if (!shape->configurable()) {
36991:         /*
36991:          * Since [[Configurable]] defaults to false, we don't need to check
36991:          * whether it was specified.  We can't do likewise for [[Enumerable]]
36991:          * because its putative value is used in a comparison -- a comparison
36991:          * whose result must always be false per spec if the [[Enumerable]]
36991:          * field is not present.  Perfectly pellucid logic, eh?
36991:          */
36991:         JS_ASSERT_IF(!desc.hasConfigurable, !desc.configurable());
36991:         if (desc.configurable() ||
52503:             (desc.hasEnumerable && desc.enumerable() != shape->enumerable())) {
64250:             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
36991:         }
36991:     }
36991: 
55492:     bool callDelProperty = false;
55492: 
36991:     if (desc.isGenericDescriptor()) {
36991:         /* 8.12.9 step 8, no validation required */
52503:     } else if (desc.isDataDescriptor() != shape->isDataDescriptor()) {
36991:         /* 8.12.9 step 9. */
54587:         if (!shape->configurable())
64250:             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
41860:     } else if (desc.isDataDescriptor()) {
36991:         /* 8.12.9 step 10. */
52503:         JS_ASSERT(shape->isDataDescriptor());
52503:         if (!shape->configurable() && !shape->writable()) {
59890:             if (desc.hasWritable && desc.writable())
64250:                 return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
59890:             if (desc.hasValue) {
88099:                 bool same;
59890:                 if (!SameValue(cx, desc.value, v, &same))
88099:                     return false;
59890:                 if (!same)
64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
36991:             }
36991:         }
55492: 
55492:         callDelProperty = !shape->hasDefaultGetter() || !shape->hasDefaultSetter();
36991:     } else {
36991:         /* 8.12.9 step 11. */
52503:         JS_ASSERT(desc.isAccessorDescriptor() && shape->isAccessorDescriptor());
52503:         if (!shape->configurable()) {
59890:             if (desc.hasSet) {
88099:                 bool same;
59890:                 if (!SameValue(cx, desc.setterValue(), shape->setterOrUndefined(), &same))
88099:                     return false;
59890:                 if (!same)
64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
59890:             }
59890: 
59890:             if (desc.hasGet) {
88099:                 bool same;
59890:                 if (!SameValue(cx, desc.getterValue(), shape->getterOrUndefined(), &same))
88099:                     return false;
59890:                 if (!same)
64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
36991:             }
36991:         }
36991:     }
36991: 
36991:     /* 8.12.9 step 12. */
36991:     uintN attrs;
62395:     PropertyOp getter;
62395:     StrictPropertyOp setter;
36991:     if (desc.isGenericDescriptor()) {
36991:         uintN changed = 0;
36991:         if (desc.hasConfigurable)
36991:             changed |= JSPROP_PERMANENT;
36991:         if (desc.hasEnumerable)
36991:             changed |= JSPROP_ENUMERATE;
36991: 
52503:         attrs = (shape->attributes() & ~changed) | (desc.attrs & changed);
52503:         if (shape->isMethod()) {
42784:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
78614:             getter = JS_PropertyStub;
78614:             setter = JS_StrictPropertyStub;
42784:         } else {
52503:             getter = shape->getter();
52503:             setter = shape->setter();
42784:         }
36991:     } else if (desc.isDataDescriptor()) {
36991:         uintN unchanged = 0;
36991:         if (!desc.hasConfigurable)
36991:             unchanged |= JSPROP_PERMANENT;
36991:         if (!desc.hasEnumerable)
36991:             unchanged |= JSPROP_ENUMERATE;
84819:         /* Watch out for accessor -> data transformations here. */
84819:         if (!desc.hasWritable && shape->isDataDescriptor())
36991:             unchanged |= JSPROP_READONLY;
36991: 
36991:         if (desc.hasValue)
36991:             v = desc.value;
52503:         attrs = (desc.attrs & ~unchanged) | (shape->attributes() & unchanged);
78614:         getter = JS_PropertyStub;
78614:         setter = JS_StrictPropertyStub;
36991:     } else {
36991:         JS_ASSERT(desc.isAccessorDescriptor());
36991: 
50518:         /*
50518:          * Getters and setters are just like watchpoints from an access
50518:          * control point of view.
50518:          */
48470:         Value dummy;
64250:         if (!CheckAccess(cx, obj2, id, JSACC_WATCH, &dummy, &attrs))
36991:              return JS_FALSE;
36991: 
52503:         JS_ASSERT_IF(shape->isMethod(), !(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
48498: 
36991:         /* 8.12.9 step 12. */
36991:         uintN changed = 0;
36991:         if (desc.hasConfigurable)
36991:             changed |= JSPROP_PERMANENT;
36991:         if (desc.hasEnumerable)
36991:             changed |= JSPROP_ENUMERATE;
36991:         if (desc.hasGet)
84680:             changed |= JSPROP_GETTER | JSPROP_SHARED | JSPROP_READONLY;
36991:         if (desc.hasSet)
84680:             changed |= JSPROP_SETTER | JSPROP_SHARED | JSPROP_READONLY;
36991: 
52503:         attrs = (desc.attrs & changed) | (shape->attributes() & ~changed);
41860:         if (desc.hasGet) {
41860:             getter = desc.getter();
41860:         } else {
52503:             getter = (shape->isMethod() || (shape->hasDefaultGetter() && !shape->hasGetterValue()))
78614:                      ? JS_PropertyStub
52503:                      : shape->getter();
41860:         }
41860:         if (desc.hasSet) {
41860:             setter = desc.setter();
41860:         } else {
52503:             setter = (shape->hasDefaultSetter() && !shape->hasSetterValue())
78614:                      ? JS_StrictPropertyStub
52503:                      : shape->setter();
41860:         }
36991:     }
36991: 
36991:     *rval = true;
55492: 
55492:     /*
55492:      * Since "data" properties implemented using native C functions may rely on
55492:      * side effects during setting, we must make them aware that they have been
55492:      * "assigned"; deleting the property before redefining it does the trick.
55492:      * See bug 539766, where we ran into problems when we redefined
55492:      * arguments.length without making the property aware that its value had
55492:      * been changed (which would have happened if we had deleted it before
55492:      * redefining it or we had invoked its setter to change its value).
55492:      */
55492:     if (callDelProperty) {
61707:         Value dummy = UndefinedValue();
64250:         if (!CallJSPropertyOp(cx, obj2->getClass()->delProperty, obj2, id, &dummy))
64250:             return false;
64250:     }
64250: 
64250:     return js_DefineProperty(cx, obj, id, &v, getter, setter, attrs);
36991: }
36991: 
36991: static JSBool
64250: DefinePropertyOnArray(JSContext *cx, JSObject *obj, const jsid &id, const PropDesc &desc,
36991:                       bool throwError, bool *rval)
36991: {
36991:     /*
36991:      * We probably should optimize dense array property definitions where
36991:      * the descriptor describes a traditional array property (enumerable,
36991:      * configurable, writable, numeric index or length without altering its
36991:      * attributes).  Such definitions are probably unlikely, so we don't bother
36991:      * for now.
36991:      */
43287:     if (obj->isDenseArray() && !obj->makeDenseArraySlow(cx))
36991:         return JS_FALSE;
36991: 
40796:     jsuint oldLen = obj->getArrayLength();
36991: 
64250:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
36991:         /*
36991:          * Our optimization of storage of the length property of arrays makes
36991:          * it very difficult to properly implement defining the property.  For
36991:          * now simply throw an exception (NB: not merely Reject) on any attempt
36991:          * to define the "length" property, rather than attempting to implement
36991:          * some difficult-for-authors-to-grasp subset of that functionality.
36991:          */
54587:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_DEFINE_ARRAY_LENGTH);
36991:         return JS_FALSE;
36991:     }
36991: 
84755:     uint32_t index;
64250:     if (js_IdIsIndex(id, &index)) {
36991:         /*
36991:         // Disabled until we support defining "length":
36991:         if (index >= oldLen && lengthPropertyNotWritable())
54587:             return ThrowTypeError(cx, JSMSG_CANT_APPEND_TO_ARRAY);
36991:          */
64250:         if (!DefinePropertyOnObject(cx, obj, id, desc, false, rval))
36991:             return JS_FALSE;
36991:         if (!*rval)
54587:             return Reject(cx, obj, JSMSG_CANT_DEFINE_ARRAY_INDEX, throwError, rval);
36991: 
36991:         if (index >= oldLen) {
36991:             JS_ASSERT(index != UINT32_MAX);
77343:             obj->setArrayLength(cx, index + 1);
36991:         }
36991: 
36991:         *rval = true;
36991:         return JS_TRUE;
36991:     }
36991: 
64250:     return DefinePropertyOnObject(cx, obj, id, desc, throwError, rval);
36991: }
36991: 
76223: namespace js {
76223: 
76223: bool
64250: DefineProperty(JSContext *cx, JSObject *obj, const jsid &id, const PropDesc &desc, bool throwError,
36991:                bool *rval)
36991: {
39928:     if (obj->isArray())
64250:         return DefinePropertyOnArray(cx, obj, id, desc, throwError, rval);
36991: 
80442:     if (obj->getOps()->lookupGeneric) {
42733:         if (obj->isProxy())
79386:             return Proxy::defineProperty(cx, obj, id, desc.pd);
54587:         return Reject(cx, obj, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
42733:     }
36991: 
64250:     return DefinePropertyOnObject(cx, obj, id, desc, throwError, rval);
36991: }
36991: 
76240: } /* namespace js */
76223: 
40356: JSBool
64250: js_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id, const Value &descriptor, JSBool *bp)
48470: {
48470:     AutoPropDescArrayRooter descs(cx);
48470:     PropDesc *desc = descs.append();
64250:     if (!desc || !desc->initialize(cx, descriptor))
40356:         return false;
40356: 
40356:     bool rval;
64250:     if (!DefineProperty(cx, obj, id, *desc, true, &rval))
40356:         return false;
40356:     *bp = !!rval;
40356:     return true;
40356: }
40356: 
36991: /* ES5 15.2.3.6: Object.defineProperty(O, P, Attributes) */
36991: static JSBool
48470: obj_defineProperty(JSContext *cx, uintN argc, Value *vp)
36991: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.defineProperty", &obj))
76223:         return false;
76223: 
76223:     jsid id;
76223:     if (!ValueToId(cx, argc >= 2 ? vp[3] : UndefinedValue(), &id))
36991:         return JS_FALSE;
76223: 
76223:     const Value descval = argc >= 3 ? vp[4] : UndefinedValue();
76223: 
76223:     JSBool junk;
76223:     if (!js_DefineOwnProperty(cx, obj, id, descval, &junk))
76223:         return false;
76223: 
48470:     vp->setObject(*obj);
76223:     return true;
73086: }
73086: 
76224: namespace js {
76224: 
76224: bool
76224: ReadPropertyDescriptors(JSContext *cx, JSObject *props, bool checkAccessors,
76224:                         AutoIdVector *ids, AutoPropDescArrayRooter *descs)
76224: {
76224:     if (!GetPropertyNames(cx, props, JSITER_OWNONLY, ids))
76224:         return false;
76224: 
76224:     for (size_t i = 0, len = ids->length(); i < len; i++) {
76224:         jsid id = (*ids)[i];
76224:         PropDesc* desc = descs->append();
76224:         Value v;
78675:         if (!desc || !props->getGeneric(cx, id, &v) || !desc->initialize(cx, v, checkAccessors))
76224:             return false;
76224:     }
76224:     return true;
76224: }
76224: 
76224: } /* namespace js */
36991: 
42733: static bool
42733: DefineProperties(JSContext *cx, JSObject *obj, JSObject *props)
42733: {
64250:     AutoIdVector ids(cx);
48470:     AutoPropDescArrayRooter descs(cx);
76224:     if (!ReadPropertyDescriptors(cx, props, true, &ids, &descs))
76224:         return false;
42733: 
36991:     bool dummy;
76224:     for (size_t i = 0, len = ids.length(); i < len; i++) {
64250:         if (!DefineProperty(cx, obj, ids[i], descs[i], true, &dummy))
42733:             return false;
42733:     }
42733: 
42733:     return true;
42733: }
42733: 
42733: extern JSBool
42733: js_PopulateObject(JSContext *cx, JSObject *newborn, JSObject *props)
42733: {
42733:     return DefineProperties(cx, newborn, props);
42733: }
42733: 
42733: /* ES5 15.2.3.7: Object.defineProperties(O, Properties) */
42733: static JSBool
48470: obj_defineProperties(JSContext *cx, uintN argc, Value *vp)
42733: {
64250:     /* Steps 1 and 7. */
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.defineProperties", &obj))
47569:         return false;
48470:     vp->setObject(*obj);
47569: 
64250:     /* Step 2. */
42733:     if (argc < 2) {
42733:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
42733:                              "Object.defineProperties", "0", "s");
42733:         return false;
42733:     }
64250:     JSObject *props = ToObject(cx, &vp[3]);
42733:     if (!props)
42733:         return false;
64250: 
64250:     /* Steps 3-6. */
42733:     return DefineProperties(cx, obj, props);
36991: }
36991: 
37000: /* ES5 15.2.3.5: Object.create(O [, Properties]) */
37000: static JSBool
48470: obj_create(JSContext *cx, uintN argc, Value *vp)
37000: {
37000:     if (argc == 0) {
37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
37000:                              "Object.create", "0", "s");
37000:         return JS_FALSE;
37000:     }
37000: 
48470:     const Value &v = vp[2];
48470:     if (!v.isObjectOrNull()) {
48470:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
37000:         if (!bytes)
37000:             return JS_FALSE;
37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
37000:                              bytes, "not an object or null");
37000:         JS_free(cx, bytes);
37000:         return JS_FALSE;
37000:     }
37000: 
73086:     JSObject *proto = v.toObjectOrNull();
73086:     if (proto && proto->isXML()) {
72561:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_XML_PROTO_FORBIDDEN);
72561:         return false;
72561:     }
72561: 
37000:     /*
47497:      * Use the callee's global as the parent of the new object to avoid dynamic
47497:      * scoping (i.e., using the caller's global).
37000:      */
86483:     JSObject *obj = NewObjectWithGivenProto(cx, &ObjectClass, proto, &vp->toObject().global());
37000:     if (!obj)
37000:         return JS_FALSE;
48470:     vp->setObject(*obj); /* Root and prepare for eventual return. */
37000: 
77343:     /* Don't track types or array-ness for objects created here. */
77353:     MarkTypeObjectUnknownProperties(cx, obj->type());
77343: 
37000:     /* 15.2.3.5 step 4. */
48470:     if (argc > 1 && !vp[3].isUndefined()) {
48470:         if (vp[3].isPrimitive()) {
37010:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
37000:             return JS_FALSE;
37000:         }
37000: 
64250:         if (!DefineProperties(cx, obj, &vp[3].toObject()))
37000:             return JS_FALSE;
37000:     }
37000: 
37000:     /* 5. Return obj. */
37000:     return JS_TRUE;
37000: }
37000: 
47569: static JSBool
48470: obj_getOwnPropertyNames(JSContext *cx, uintN argc, Value *vp)
47569: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.getOwnPropertyNames", &obj))
47569:         return false;
47569: 
48470:     AutoIdVector keys(cx);
54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &keys))
47569:         return false;
47569: 
48470:     AutoValueVector vals(cx);
48470:     if (!vals.resize(keys.length()))
48470:         return false;
48470: 
48470:     for (size_t i = 0, len = keys.length(); i < len; i++) {
48470:          jsid id = keys[i];
48470:          if (JSID_IS_INT(id)) {
84160:              JSString *str = js_IntToString(cx, JSID_TO_INT(id));
47569:              if (!str)
47569:                  return false;
48470:              vals[i].setString(str);
48470:          } else if (JSID_IS_ATOM(id)) {
48470:              vals[i].setString(JSID_TO_STRING(id));
48470:          } else {
48470:              vals[i].setObject(*JSID_TO_OBJECT(id));
48470:          }
48470:     }
48470: 
59234:     JSObject *aobj = NewDenseCopiedArray(cx, vals.length(), vals.begin());
47569:     if (!aobj)
47569:         return false;
47569: 
48470:     vp->setObject(*aobj);
47569:     return true;
47569: }
47569: 
54563: static JSBool
54563: obj_isExtensible(JSContext *cx, uintN argc, Value *vp)
54563: {
54563:     JSObject *obj;
54563:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.isExtensible", &obj))
54563:         return false;
54563: 
54563:     vp->setBoolean(obj->isExtensible());
54563:     return true;
54563: }
54563: 
54563: static JSBool
54563: obj_preventExtensions(JSContext *cx, uintN argc, Value *vp)
54563: {
54563:     JSObject *obj;
54563:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.preventExtensions", &obj))
54563:         return false;
54563: 
54563:     vp->setObject(*obj);
57813:     if (!obj->isExtensible())
57813:         return true;
54563: 
54563:     AutoIdVector props(cx);
54563:     return obj->preventExtensions(cx, &props);
54563: }
54563: 
86736: /* static */ inline uintN
86736: JSObject::getSealedOrFrozenAttributes(uintN attrs, ImmutabilityType it)
86736: {
86736:     /* Make all attributes permanent; if freezing, make data attributes read-only. */
86736:     if (it == FREEZE && !(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
86736:         return JSPROP_PERMANENT | JSPROP_READONLY;
86736:     return JSPROP_PERMANENT;
86736: }
86736: 
54563: bool
57813: JSObject::sealOrFreeze(JSContext *cx, ImmutabilityType it)
54563: {
54563:     assertSameCompartment(cx, this);
57813:     JS_ASSERT(it == SEAL || it == FREEZE);
54563: 
86437:     RootedVarObject self(cx, this);
86437: 
54563:     AutoIdVector props(cx);
54563:     if (isExtensible()) {
54563:         if (!preventExtensions(cx, &props))
54563:             return false;
54563:     } else {
54563:         if (!GetPropertyNames(cx, this, JSITER_HIDDEN | JSITER_OWNONLY, &props))
54563:             return false;
54563:     }
54563: 
54563:     /* preventExtensions must slowify dense arrays, so we can assign to holes without checks. */
86437:     JS_ASSERT(!self->isDenseArray());
54563: 
86736:     if (isNative() && !inDictionaryMode()) {
86736:         /*
86736:          * Seal/freeze non-dictionary objects by constructing a new shape
86736:          * hierarchy mirroring the original one, which can be shared if many
86736:          * objects with the same structure are sealed/frozen. If we use the
86736:          * generic path below then any non-empty object will be converted to
86736:          * dictionary mode.
86736:          */
86736:         Shape *last = EmptyShape::getInitialShape(cx, self->getClass(),
86736:                                                   self->getProto(),
86736:                                                   self->getParent(),
86736:                                                   self->getAllocKind(),
86736:                                                   self->lastProperty()->getObjectFlags());
86736:         if (!last)
86736:             return false;
86736: 
86736:         /* Get an in order list of the shapes in this object. */
86736:         AutoShapeVector shapes(cx);
86736:         for (Shape::Range r = self->lastProperty()->all(); !r.empty(); r.popFront()) {
86736:             if (!shapes.append(&r.front()))
86736:                 return false;
86736:         }
86736:         Reverse(shapes.begin(), shapes.end());
86736: 
86736:         for (size_t i = 0; i < shapes.length(); i++) {
86736:             StackShape child(shapes[i]);
86736:             child.attrs |= getSealedOrFrozenAttributes(child.attrs, it);
86736: 
86736:             if (!JSID_IS_EMPTY(child.propid))
86736:                 MarkTypePropertyConfigured(cx, self, child.propid);
86736: 
86736:             last = JS_PROPERTY_TREE(cx).getChild(cx, last, self->numFixedSlots(), child);
86736:             if (!last)
86736:                 return NULL;
86736:         }
86736: 
86736:         JS_ASSERT(self->lastProperty()->slotSpan() == last->slotSpan());
86736:         JS_ALWAYS_TRUE(setLastProperty(cx, last));
86736:     } else {
86736:         for (size_t i = 0; i < props.length(); i++) {
54563:             jsid id = props[i];
54563: 
54563:             uintN attrs;
86437:             if (!self->getGenericAttributes(cx, id, &attrs))
54563:                 return false;
54563: 
86736:             uintN new_attrs = getSealedOrFrozenAttributes(attrs, it);
54563: 
54563:             /* If we already have the attributes we need, skip the setAttributes call. */
54563:             if ((attrs | new_attrs) == attrs)
54563:                 continue;
54563: 
54563:             attrs |= new_attrs;
86437:             if (!self->setGenericAttributes(cx, id, &attrs))
54563:                 return false;
54563:         }
86736:     }
54563: 
54563:     return true;
54563: }
32721: 
76228: bool
76228: JSObject::isSealedOrFrozen(JSContext *cx, ImmutabilityType it, bool *resultp)
76228: {
76228:     if (isExtensible()) {
76228:         *resultp = false;
76228:         return true;
76228:     }
76228: 
76228:     AutoIdVector props(cx);
76228:     if (!GetPropertyNames(cx, this, JSITER_HIDDEN | JSITER_OWNONLY, &props))
76228:         return false;
76228: 
76228:     for (size_t i = 0, len = props.length(); i < len; i++) {
76228:         jsid id = props[i];
76228: 
76228:         uintN attrs;
80622:         if (!getGenericAttributes(cx, id, &attrs))
76228:             return false;
76228: 
76228:         /*
76228:          * If the property is configurable, this object is neither sealed nor
76228:          * frozen. If the property is a writable data property, this object is
76228:          * not frozen.
76228:          */
76228:         if (!(attrs & JSPROP_PERMANENT) ||
76228:             (it == FREEZE && !(attrs & (JSPROP_READONLY | JSPROP_GETTER | JSPROP_SETTER))))
76228:         {
76228:             *resultp = false;
76228:             return true;
76228:         }
76228:     }
76228: 
76228:     /* All properties checked out. This object is sealed/frozen. */
76228:     *resultp = true;
76228:     return true;
76228: }
76228: 
54564: static JSBool
54564: obj_freeze(JSContext *cx, uintN argc, Value *vp)
54564: {
54564:     JSObject *obj;
54564:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.freeze", &obj))
54564:         return false;
54564: 
54564:     vp->setObject(*obj);
54564: 
54564:     return obj->freeze(cx);
54564: }
54564: 
54564: static JSBool
54564: obj_isFrozen(JSContext *cx, uintN argc, Value *vp)
54564: {
54564:     JSObject *obj;
54564:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.preventExtensions", &obj))
54564:         return false;
54564: 
76228:     bool frozen;
76228:     if (!obj->isFrozen(cx, &frozen))
76228:         return false;
76228:     vp->setBoolean(frozen);
54565:     return true;
54565: }
54565: 
54565: static JSBool
54565: obj_seal(JSContext *cx, uintN argc, Value *vp)
54565: {
54565:     JSObject *obj;
54565:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.seal", &obj))
54565:         return false;
54565: 
54565:     vp->setObject(*obj);
54565: 
54565:     return obj->seal(cx);
54565: }
54565: 
54565: static JSBool
54565: obj_isSealed(JSContext *cx, uintN argc, Value *vp)
54565: {
54565:     JSObject *obj;
54565:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.isSealed", &obj))
54565:         return false;
54565: 
76228:     bool sealed;
76228:     if (!obj->isSealed(cx, &sealed))
76228:         return false;
76228:     vp->setBoolean(sealed);
54564:     return true;
54564: }
54564: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: const char js_watch_str[] = "watch";
    1: const char js_unwatch_str[] = "unwatch";
    1: #endif
    1: const char js_hasOwnProperty_str[] = "hasOwnProperty";
    1: const char js_isPrototypeOf_str[] = "isPrototypeOf";
    1: const char js_propertyIsEnumerable_str[] = "propertyIsEnumerable";
    1: 
78466: JSFunctionSpec object_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,             obj_toSource,                0,0),
    1: #endif
59941:     JS_FN(js_toString_str,             obj_toString,                0,0),
16519:     JS_FN(js_toLocaleString_str,       obj_toLocaleString,          0,0),
41856:     JS_FN(js_valueOf_str,              obj_valueOf,                 0,0),
    1: #if JS_HAS_OBJ_WATCHPOINT
16519:     JS_FN(js_watch_str,                obj_watch,                   2,0),
16519:     JS_FN(js_unwatch_str,              obj_unwatch,                 1,0),
    1: #endif
41856:     JS_FN(js_hasOwnProperty_str,       obj_hasOwnProperty,          1,0),
16519:     JS_FN(js_isPrototypeOf_str,        obj_isPrototypeOf,           1,0),
41856:     JS_FN(js_propertyIsEnumerable_str, obj_propertyIsEnumerable,    1,0),
40855: #if OLD_GETTER_SETTER_METHODS
79734:     JS_FN(js_defineGetter_str,         js::obj_defineGetter,        2,0),
79734:     JS_FN(js_defineSetter_str,         js::obj_defineSetter,        2,0),
16519:     JS_FN(js_lookupGetter_str,         obj_lookupGetter,            1,0),
16519:     JS_FN(js_lookupSetter_str,         obj_lookupSetter,            1,0),
    1: #endif
 4127:     JS_FS_END
    1: };
    1: 
78466: JSFunctionSpec object_static_methods[] = {
16519:     JS_FN("getPrototypeOf",            obj_getPrototypeOf,          1,0),
32721:     JS_FN("getOwnPropertyDescriptor",  obj_getOwnPropertyDescriptor,2,0),
33155:     JS_FN("keys",                      obj_keys,                    1,0),
36991:     JS_FN("defineProperty",            obj_defineProperty,          3,0),
36991:     JS_FN("defineProperties",          obj_defineProperties,        2,0),
37000:     JS_FN("create",                    obj_create,                  2,0),
47569:     JS_FN("getOwnPropertyNames",       obj_getOwnPropertyNames,     1,0),
54563:     JS_FN("isExtensible",              obj_isExtensible,            1,0),
54563:     JS_FN("preventExtensions",         obj_preventExtensions,       1,0),
54564:     JS_FN("freeze",                    obj_freeze,                  1,0),
54564:     JS_FN("isFrozen",                  obj_isFrozen,                1,0),
54565:     JS_FN("seal",                      obj_seal,                    1,0),
54565:     JS_FN("isSealed",                  obj_isSealed,                1,0),
16380:     JS_FS_END
16380: };
16380: 
30439: JSBool
50489: js_Object(JSContext *cx, uintN argc, Value *vp)
50489: {
50489:     JSObject *obj;
30439:     if (argc == 0) {
30439:         /* Trigger logic below to construct a blank object. */
30439:         obj = NULL;
30439:     } else {
30439:         /* If argv[0] is null or undefined, obj comes back null. */
50489:         if (!js_ValueToObjectOrNull(cx, vp[2], &obj))
30439:             return JS_FALSE;
30439:     }
30439:     if (!obj) {
50489:         /* Make an object whether this was called with 'new' or not. */
50489:         JS_ASSERT(!argc || vp[2].isNull() || vp[2].isUndefined());
77817:         gc::AllocKind kind = NewObjectGCKind(cx, &ObjectClass);
77817:         obj = NewBuiltinClassInstance(cx, &ObjectClass, kind);
30439:         if (!obj)
30439:             return JS_FALSE;
77343:         TypeObject *type = GetTypeCallerInitObject(cx, JSProto_Object);
77392:         if (!type)
77343:             return JS_FALSE;
77392:         obj->setType(type);
30439:     }
50489:     vp->setObject(*obj);
30439:     return JS_TRUE;
30439: }
30439: 
83276: static inline JSObject *
83276: NewObject(JSContext *cx, Class *clasp, types::TypeObject *type, JSObject *parent,
83276:           gc::AllocKind kind)
83276: {
83276:     JS_ASSERT(clasp != &ArrayClass);
83276:     JS_ASSERT_IF(clasp == &FunctionClass,
83276:                  kind == JSFunction::FinalizeKind || kind == JSFunction::ExtendedFinalizeKind);
83276: 
86437:     RootTypeObject typeRoot(cx, &type);
86437: 
86437:     RootedVarShape shape(cx);
86437:     shape = EmptyShape::getInitialShape(cx, clasp, type->proto, parent, kind);
83276:     if (!shape)
83276:         return NULL;
83276: 
83301:     HeapValue *slots;
83314:     if (!PreallocateObjectDynamicSlots(cx, shape, &slots))
83276:         return NULL;
83276: 
86437:     JSObject *obj = JSObject::create(cx, kind, shape, typeRoot, slots);
83276:     if (!obj)
83276:         return NULL;
83276: 
83276:     Probes::createObject(cx, obj);
83276:     return obj;
83276: }
83276: 
80993: JSObject *
83275: js::NewObjectWithGivenProto(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
83275:                             gc::AllocKind kind)
83275: {
83276:     if (CanBeFinalizedInBackground(kind, clasp))
83276:         kind = GetBackgroundAllocKind(kind);
83276: 
83313:     NewObjectCache &cache = cx->compartment->newObjectCache;
83313: 
83313:     NewObjectCache::EntryIndex entry = -1;
83276:     if (proto && (!parent || parent == proto->getParent()) && !proto->isGlobal()) {
83313:         if (cache.lookupProto(clasp, proto, kind, &entry))
83313:             return cache.newObjectFromHit(cx, entry);
83276:     }
83276: 
86437:     RootObject protoRoot(cx, &proto);
86437:     RootObject parentRoot(cx, &parent);
86437: 
83275:     types::TypeObject *type = proto ? proto->getNewType(cx) : cx->compartment->getEmptyType(cx);
83275:     if (!type)
83275:         return NULL;
83275: 
83276:     /*
83276:      * Default parent to the parent of the prototype, which was set from
83276:      * the parent of the prototype's constructor.
83276:      */
83276:     if (!parent && proto)
83276:         parent = proto->getParent();
83276: 
83276:     JSObject *obj = NewObject(cx, clasp, type, parent, kind);
83276:     if (!obj)
83276:         return NULL;
83276: 
83313:     if (entry != -1 && !obj->hasDynamicSlots())
83313:         cache.fillProto(entry, clasp, proto, kind, obj);
83276: 
83276:     return obj;
83276: }
83276: 
83276: JSObject *
83276: js::NewObjectWithClassProto(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
83276:                             gc::AllocKind kind)
83276: {
83276:     if (proto)
83276:         return NewObjectWithGivenProto(cx, clasp, proto, parent, kind);
83275: 
83275:     if (CanBeFinalizedInBackground(kind, clasp))
83275:         kind = GetBackgroundAllocKind(kind);
83275: 
83276:     if (!parent)
83276:         parent = GetCurrentGlobal(cx);
83276: 
83306:     /*
83306:      * Use the object cache, except for classes without a cached proto key.
83306:      * On these objects, FindProto will do a dynamic property lookup to get
83306:      * global[className].prototype, where changes to either the className or
83306:      * prototype property would render the cached lookup incorrect. For classes
83306:      * with a proto key, the prototype created during class initialization is
83306:      * stored in an immutable slot on the global (except for ClearScope, which
83306:      * will flush the new object cache).
83306:      */
83306:     JSProtoKey protoKey = GetClassProtoKey(clasp);
83306: 
83313:     NewObjectCache &cache = cx->compartment->newObjectCache;
83313: 
83313:     NewObjectCache::EntryIndex entry = -1;
83306:     if (parent->isGlobal() && protoKey != JSProto_Null) {
86483:         if (cache.lookupGlobal(clasp, &parent->asGlobal(), kind, &entry))
83313:             return cache.newObjectFromHit(cx, entry);
83276:     }
83276: 
86437:     RootObject parentRoot(cx, &parent);
86437: 
86437:     if (!FindProto(cx, clasp, parentRoot, &proto))
83275:         return NULL;
83275: 
83276:     types::TypeObject *type = proto->getNewType(cx);
83276:     if (!type)
83275:         return NULL;
83275: 
83276:     JSObject *obj = NewObject(cx, clasp, type, parent, kind);
83275:     if (!obj)
83275:         return NULL;
83275: 
83313:     if (entry != -1 && !obj->hasDynamicSlots())
86483:         cache.fillGlobal(entry, clasp, &parent->asGlobal(), kind, obj);
83276: 
83275:     return obj;
83275: }
83275: 
83275: JSObject *
83275: js::NewObjectWithType(JSContext *cx, types::TypeObject *type, JSObject *parent, gc::AllocKind kind)
83275: {
83275:     JS_ASSERT(type->proto->hasNewType(type));
83276:     JS_ASSERT(parent);
83275: 
83275:     if (CanBeFinalizedInBackground(kind, &ObjectClass))
83275:         kind = GetBackgroundAllocKind(kind);
83275: 
83313:     NewObjectCache &cache = cx->compartment->newObjectCache;
83313: 
83313:     NewObjectCache::EntryIndex entry = -1;
83276:     if (parent == type->proto->getParent()) {
83313:         if (cache.lookupType(&ObjectClass, type, kind, &entry))
83313:             return cache.newObjectFromHit(cx, entry);
83276:     }
83276: 
83276:     JSObject *obj = NewObject(cx, &ObjectClass, type, parent, kind);
83275:     if (!obj)
83275:         return NULL;
83275: 
83313:     if (entry != -1 && !obj->hasDynamicSlots())
83313:         cache.fillType(entry, &ObjectClass, type, kind, obj);
83276: 
83275:     return obj;
83275: }
83275: 
53557: JSObject *
77343: js::NewReshapedObject(JSContext *cx, TypeObject *type, JSObject *parent,
77775:                       gc::AllocKind kind, const Shape *shape)
77343: {
77343:     JSObject *res = NewObjectWithType(cx, type, parent, kind);
77343:     if (!res)
77343:         return NULL;
77343: 
83221:     if (shape->isEmptyShape())
77343:         return res;
77343: 
77343:     /* Get all the ids in the object, in order. */
77343:     js::AutoIdVector ids(cx);
83221:     for (unsigned i = 0; i <= shape->slot(); i++) {
77343:         if (!ids.append(JSID_VOID))
77343:             return NULL;
77343:     }
77343:     const js::Shape *nshape = shape;
83221:     while (!nshape->isEmptyShape()) {
83221:         ids[nshape->slot()] = nshape->propid();
77343:         nshape = nshape->previous();
77343:     }
77343: 
77343:     /* Construct the new shape. */
77343:     for (unsigned i = 0; i < ids.length(); i++) {
77343:         if (!DefineNativeProperty(cx, res, ids[i], js::UndefinedValue(), NULL, NULL,
77343:                                   JSPROP_ENUMERATE, 0, 0, DNP_SKIP_TYPE)) {
77343:             return NULL;
77343:         }
77343:     }
77343:     JS_ASSERT(!res->inDictionaryMode());
77343: 
77343:     return res;
77343: }
77343: 
77343: JSObject*
55503: js_CreateThis(JSContext *cx, JSObject *callee)
53557: {
53557:     Class *clasp = callee->getClass();
53557: 
77817:     Class *newclasp = &ObjectClass;
77817:     if (clasp == &FunctionClass) {
83234:         JSFunction *fun = callee->toFunction();
53557:         if (fun->isNative() && fun->u.n.clasp)
53557:             newclasp = fun->u.n.clasp;
53557:     }
53557: 
53557:     Value protov;
78675:     if (!callee->getProperty(cx, cx->runtime->atomState.classPrototypeAtom, &protov))
53557:         return NULL;
53557: 
53557:     JSObject *proto = protov.isObjectOrNull() ? protov.toObjectOrNull() : NULL;
53557:     JSObject *parent = callee->getParent();
77775:     gc::AllocKind kind = NewObjectGCKind(cx, newclasp);
83275:     return NewObjectWithClassProto(cx, newclasp, proto, parent, kind);
53557: }
53557: 
77343: static inline JSObject *
77343: CreateThisForFunctionWithType(JSContext *cx, types::TypeObject *type, JSObject *parent)
77343: {
77343:     if (type->newScript) {
77343:         /*
77343:          * Make an object with the type's associated finalize kind and shape,
77343:          * which reflects any properties that will definitely be added to the
77343:          * object before it is read from.
77343:          */
77775:         gc::AllocKind kind = type->newScript->allocKind;
77343:         JSObject *res = NewObjectWithType(cx, type, parent, kind);
77343:         if (res)
83301:             JS_ALWAYS_TRUE(res->setLastProperty(cx, (Shape *) type->newScript->shape.get()));
77343:         return res;
77343:     }
77343: 
77817:     gc::AllocKind kind = NewObjectGCKind(cx, &ObjectClass);
77343:     return NewObjectWithType(cx, type, parent, kind);
77343: }
77343: 
55503: JSObject *
55503: js_CreateThisForFunctionWithProto(JSContext *cx, JSObject *callee, JSObject *proto)
55503: {
77361:     JSObject *res;
77361: 
77343:     if (proto) {
83234:         types::TypeObject *type = proto->getNewType(cx, callee->toFunction());
77343:         if (!type)
77343:             return NULL;
77361:         res = CreateThisForFunctionWithType(cx, type, callee->getParent());
77361:     } else {
77817:         gc::AllocKind kind = NewObjectGCKind(cx, &ObjectClass);
83275:         res = NewObjectWithClassProto(cx, &ObjectClass, proto, callee->getParent(), kind);
77361:     }
77361: 
77361:     if (res && cx->typeInferenceEnabled())
83234:         TypeScript::SetThis(cx, callee->toFunction()->script(), types::Type::ObjectType(res));
77361: 
77361:     return res;
55503: }
55503: 
55503: JSObject *
77343: js_CreateThisForFunction(JSContext *cx, JSObject *callee, bool newType)
55503: {
55503:     Value protov;
78675:     if (!callee->getProperty(cx, cx->runtime->atomState.classPrototypeAtom, &protov))
55503:         return NULL;
77343:     JSObject *proto;
77343:     if (protov.isObject())
77343:         proto = &protov.toObject();
77343:     else
77343:         proto = NULL;
77343:     JSObject *obj = js_CreateThisForFunctionWithProto(cx, callee, proto);
77343: 
77343:     if (obj && newType) {
77343:         /*
77353:          * Reshape the object and give it a (lazily instantiated) singleton
77353:          * type before passing it as the 'this' value for the call.
77353:          */
77353:         obj->clear(cx);
77353:         if (!obj->setSingletonType(cx))
77353:             return NULL;
77353: 
83234:         JSScript *calleeScript = callee->toFunction()->script();
77391:         TypeScript::SetThis(cx, calleeScript, types::Type::ObjectType(obj));
77343:     }
77343: 
77343:     return obj;
55503: }
55503: 
    1: /*
23435:  * Given pc pointing after a property accessing bytecode, return true if the
23435:  * access is "object-detecting" in the sense used by web scripts, e.g., when
23435:  * checking whether document.all is defined.
23435:  */
86484: JSBool
23435: Detecting(JSContext *cx, jsbytecode *pc)
23435: {
25474:     jsbytecode *endpc;
23435:     JSOp op;
23435:     JSAtom *atom;
23435: 
77343:     JSScript *script = cx->stack.currentScript();
25474:     endpc = script->code + script->length;
25215:     for (;; pc += js_CodeSpec[op].length) {
82642:         JS_ASSERT(script->code <= pc && pc < endpc);
25474: 
23435:         /* General case: a branch or equality op follows the access. */
84195:         op = JSOp(*pc);
23435:         if (js_CodeSpec[op].format & JOF_DETECTING)
23435:             return JS_TRUE;
23435: 
23435:         switch (op) {
23435:           case JSOP_NULL:
23435:             /*
23435:              * Special case #1: handle (document.all == null).  Don't sweat
23435:              * about JS1.2's revision of the equality operators here.
23435:              */
25474:             if (++pc < endpc) {
84195:                 op = JSOp(*pc);
84950:                 return op == JSOP_EQ || op == JSOP_NE;
25474:             }
25474:             return JS_FALSE;
23435: 
52825:           case JSOP_GETGNAME:
23435:           case JSOP_NAME:
23435:             /*
23435:              * Special case #2: handle (document.all == undefined).  Don't
23435:              * worry about someone redefining undefined, which was added by
23435:              * Edition 3, so is read/write for backward compatibility.
23435:              */
23435:             GET_ATOM_FROM_BYTECODE(script, pc, 0, atom);
25474:             if (atom == cx->runtime->atomState.typeAtoms[JSTYPE_VOID] &&
25474:                 (pc += js_CodeSpec[op].length) < endpc) {
84195:                 op = JSOp(*pc);
23435:                 return op == JSOP_EQ || op == JSOP_NE ||
23435:                        op == JSOP_STRICTEQ || op == JSOP_STRICTNE;
23435:             }
23435:             return JS_FALSE;
23435: 
23435:           default:
23435:             /*
23435:              * At this point, anything but an extended atom index prefix means
23435:              * we're not detecting.
23435:              */
23435:             if (!(js_CodeSpec[op].format & JOF_INDEXBASE))
23435:                 return JS_FALSE;
23435:             break;
23435:         }
23435:     }
23435: }
23435: 
23435: /*
23435:  * Infer lookup flags from the currently executing bytecode. This does
23435:  * not attempt to infer JSRESOLVE_WITH, because the current bytecode
23435:  * does not indicate whether we are in a with statement. Return defaultFlags
23435:  * if a currently executing bytecode cannot be determined.
23435:  */
30034: uintN
30034: js_InferFlags(JSContext *cx, uintN defaultFlags)
23435: {
23435:     const JSCodeSpec *cs;
84755:     uint32_t format;
23435:     uintN flags = 0;
23435: 
77343:     jsbytecode *pc;
77343:     JSScript *script = cx->stack.currentScript(&pc);
77343:     if (!script || !pc)
23435:         return defaultFlags;
77343: 
84195:     cs = &js_CodeSpec[*pc];
23435:     format = cs->format;
23435:     if (JOF_MODE(format) != JOF_NAME)
23435:         flags |= JSRESOLVE_QUALIFIED;
83221:     if (format & JOF_SET) {
23435:         flags |= JSRESOLVE_ASSIGNING;
32680:     } else if (cs->length >= 0) {
23435:         pc += cs->length;
51446:         if (pc < script->code + script->length && Detecting(cx, pc))
23435:             flags |= JSRESOLVE_DETECTING;
23435:     }
23435:     if (format & JOF_DECLARING)
23435:         flags |= JSRESOLVE_DECLARING;
23435:     return flags;
23435: }
23435: 
74472: JSBool
74472: JSObject::nonNativeSetProperty(JSContext *cx, jsid id, js::Value *vp, JSBool strict)
74472: {
74472:     if (JS_UNLIKELY(watched())) {
74472:         id = js_CheckForStringIndex(id);
74472:         WatchpointMap *wpmap = cx->compartment->watchpointMap;
74472:         if (wpmap && !wpmap->triggerWatchpoint(cx, this, id, vp))
74472:             return false;
74472:     }
80625:     return getOps()->setGeneric(cx, this, id, vp, strict);
74472: }
74472: 
78346: JSBool
84755: JSObject::nonNativeSetElement(JSContext *cx, uint32_t index, js::Value *vp, JSBool strict)
78346: {
78346:     if (JS_UNLIKELY(watched())) {
78346:         jsid id;
78346:         if (!IndexToId(cx, index, &id))
78346:             return false;
78346:         JS_ASSERT(id == js_CheckForStringIndex(id));
78346:         WatchpointMap *wpmap = cx->compartment->watchpointMap;
78346:         if (wpmap && !wpmap->triggerWatchpoint(cx, this, id, vp))
78346:             return false;
78346:     }
78346:     return getOps()->setElement(cx, this, index, vp, strict);
78346: }
78346: 
86790: bool
86790: JSObject::deleteByValue(JSContext *cx, const Value &property, Value *rval, bool strict)
86790: {
86790:     uint32_t index;
86790:     if (IsDefinitelyIndex(property, &index))
86790:         return deleteElement(cx, index, rval, strict);
86790: 
86790:     Value propval = property;
86790:     SpecialId sid;
86790:     if (ValueIsSpecial(this, &propval, &sid, cx))
86790:         return deleteSpecial(cx, sid, rval, strict);
86790: 
86790:     JSAtom *name;
86790:     if (!js_ValueToAtom(cx, propval, &name))
86790:         return false;
86790: 
86790:     if (name->isIndex(&index))
86790:         return deleteElement(cx, index, rval, false);
86790: 
86790:     return deleteProperty(cx, name->asPropertyName(), rval, false);
86790: }
86790: 
79734: JS_FRIEND_API(bool)
79734: JS_CopyPropertiesFrom(JSContext *cx, JSObject *target, JSObject *obj)
58714: {
58714:     // If we're not native, then we cannot copy properties.
79734:     JS_ASSERT(target->isNative() == obj->isNative());
79734:     if (!target->isNative())
58714:         return true;
58714: 
62363:     AutoShapeVector shapes(cx);
58714:     for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
58714:         if (!shapes.append(&r.front()))
58714:             return false;
58714:     }
58714: 
58714:     size_t n = shapes.length();
58714:     while (n > 0) {
58714:         const Shape *shape = shapes[--n];
58714:         uintN attrs = shape->attributes();
58714:         PropertyOp getter = shape->getter();
58714:         if ((attrs & JSPROP_GETTER) && !cx->compartment->wrap(cx, &getter))
58714:             return false;
62395:         StrictPropertyOp setter = shape->setter();
58714:         if ((attrs & JSPROP_SETTER) && !cx->compartment->wrap(cx, &setter))
58714:             return false;
83221:         Value v = shape->hasSlot() ? obj->getSlot(shape->slot()) : UndefinedValue();
58714:         if (!cx->compartment->wrap(cx, &v))
58714:             return false;
83263:         if (!target->defineGeneric(cx, shape->propid(), v, getter, setter, attrs))
58714:             return false;
58714:     }
58714:     return true;
58714: }
58714: 
58714: static bool
58714: CopySlots(JSContext *cx, JSObject *from, JSObject *to)
58714: {
58714:     JS_ASSERT(!from->isNative() && !to->isNative());
83231:     JS_ASSERT(from->getClass() == to->getClass());
58714: 
58714:     size_t n = 0;
74459:     if (from->isWrapper() &&
79386:         (Wrapper::wrapperHandler(from)->flags() & Wrapper::CROSS_COMPARTMENT)) {
74457:         to->setSlot(0, from->getSlot(0));
74457:         to->setSlot(1, from->getSlot(1));
58714:         n = 2;
58714:     }
58714: 
83231:     size_t span = JSCLASS_RESERVED_SLOTS(from->getClass());
83231:     for (; n < span; ++n) {
74457:         Value v = from->getSlot(n);
58714:         if (!cx->compartment->wrap(cx, &v))
58714:             return false;
74457:         to->setSlot(n, v);
58714:     }
58714:     return true;
58714: }
58714: 
79734: JS_FRIEND_API(JSObject *)
79734: JS_CloneObject(JSContext *cx, JSObject *obj, JSObject *proto, JSObject *parent)
58714: {
58714:     /*
58714:      * We can only clone native objects and proxies. Dense arrays are slowified if
58714:      * we try to clone them.
58714:      */
79734:     if (!obj->isNative()) {
79734:         if (obj->isDenseArray()) {
79734:             if (!obj->makeDenseArraySlow(cx))
58714:                 return NULL;
79734:         } else if (!obj->isProxy()) {
58714:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
58714:                                  JSMSG_CANT_CLONE_OBJECT);
58714:             return NULL;
58714:         }
58714:     }
83275:     JSObject *clone = NewObjectWithGivenProto(cx, obj->getClass(), proto, parent, obj->getAllocKind());
58714:     if (!clone)
58714:         return NULL;
79734:     if (obj->isNative()) {
79734:         if (clone->isFunction() && (obj->compartment() != clone->compartment())) {
58714:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
58714:                                  JSMSG_CANT_CLONE_OBJECT);
58714:             return NULL;
58714:         }
58714: 
83233:         if (obj->hasPrivate())
79734:             clone->setPrivate(obj->getPrivate());
58714:     } else {
79734:         JS_ASSERT(obj->isProxy());
79734:         if (!CopySlots(cx, obj, clone))
58714:             return NULL;
58714:     }
74458: 
58714:     return clone;
58714: }
58714: 
77343: struct JSObject::TradeGutsReserved {
77343:     JSContext *cx;
77343:     Vector<Value> avals;
77343:     Vector<Value> bvals;
83236:     int newafixed;
83236:     int newbfixed;
83247:     Shape *newashape;
83247:     Shape *newbshape;
82129:     HeapValue *newaslots;
82129:     HeapValue *newbslots;
77343: 
77343:     TradeGutsReserved(JSContext *cx)
83233:         : cx(cx), avals(cx), bvals(cx),
83233:           newafixed(0), newbfixed(0),
83247:           newashape(NULL), newbshape(NULL),
83233:           newaslots(NULL), newbslots(NULL)
77343:     {}
77343: 
77343:     ~TradeGutsReserved()
77343:     {
77343:         if (newaslots)
77343:             cx->free_(newaslots);
77343:         if (newbslots)
77343:             cx->free_(newbslots);
77343:     }
77343: };
77343: 
77343: bool
77343: JSObject::ReserveForTradeGuts(JSContext *cx, JSObject *a, JSObject *b,
77343:                               TradeGutsReserved &reserved)
77343: {
77343:     /*
77343:      * When performing multiple swaps between objects which may have different
77343:      * numbers of fixed slots, we reserve all space ahead of time so that the
77343:      * swaps can be performed infallibly.
77343:      */
77343: 
88142:     if (a->sizeOfThis() == b->sizeOfThis())
77343:         return true;
77343: 
83221:     /*
83221:      * If either object is native, it needs a new shape to preserve the
83221:      * invariant that objects with the same shape have the same number of
83247:      * inline slots. The fixed slots will be updated in place during TradeGuts.
83247:      * Non-native objects need to be reshaped according to the new count.
83247:      */
83247:     if (a->isNative()) {
83247:         if (!a->generateOwnShape(cx))
83247:             return false;
83247:     } else {
83316:         reserved.newbshape = EmptyShape::getInitialShape(cx, a->getClass(),
83297:                                                          a->getProto(), a->getParent(),
83247:                                                          b->getAllocKind());
83247:         if (!reserved.newbshape)
83247:             return false;
83247:     }
83247:     if (b->isNative()) {
83247:         if (!b->generateOwnShape(cx))
83247:             return false;
83247:     } else {
83316:         reserved.newashape = EmptyShape::getInitialShape(cx, b->getClass(),
83297:                                                          b->getProto(), b->getParent(),
83247:                                                          a->getAllocKind());
83247:         if (!reserved.newashape)
83247:             return false;
83247:     }
83221: 
77343:     /* The avals/bvals vectors hold all original values from the objects. */
77343: 
83231:     if (!reserved.avals.reserve(a->slotSpan()))
83231:         return false;
83231:     if (!reserved.bvals.reserve(b->slotSpan()))
83231:         return false;
83231: 
83231:     JS_ASSERT(a->elements == emptyObjectElements);
83231:     JS_ASSERT(b->elements == emptyObjectElements);
79734: 
79734:     /*
83233:      * The newafixed/newbfixed hold the number of fixed slots in the objects
83233:      * after the swap. Adjust these counts according to whether the objects
83233:      * use their last fixed slot for storing private data.
83233:      */
83233: 
83233:     reserved.newafixed = a->numFixedSlots();
83233:     reserved.newbfixed = b->numFixedSlots();
83233: 
83233:     if (a->hasPrivate()) {
83233:         reserved.newafixed++;
83233:         reserved.newbfixed--;
83233:     }
83233:     if (b->hasPrivate()) {
83233:         reserved.newbfixed++;
83233:         reserved.newafixed--;
83233:     }
83233: 
83236:     JS_ASSERT(reserved.newafixed >= 0);
83236:     JS_ASSERT(reserved.newbfixed >= 0);
77343: 
77343:     /*
77343:      * The newaslots/newbslots arrays hold any dynamic slots for the objects
77343:      * if they do not have enough fixed slots to accomodate the slots in the
77343:      * other object.
77343:      */
77343: 
83233:     unsigned adynamic = dynamicSlotsCount(reserved.newafixed, b->slotSpan());
83233:     unsigned bdynamic = dynamicSlotsCount(reserved.newbfixed, a->slotSpan());
83231: 
83231:     if (adynamic) {
83301:         reserved.newaslots = (HeapValue *) cx->malloc_(sizeof(HeapValue) * adynamic);
77343:         if (!reserved.newaslots)
77343:             return false;
83231:         Debug_SetValueRangeToCrashOnTouch(reserved.newaslots, adynamic);
83231:     }
83231:     if (bdynamic) {
83301:         reserved.newbslots = (HeapValue *) cx->malloc_(sizeof(HeapValue) * bdynamic);
77343:         if (!reserved.newbslots)
77343:             return false;
83231:         Debug_SetValueRangeToCrashOnTouch(reserved.newbslots, bdynamic);
77343:     }
77343: 
77343:     return true;
77343: }
77343: 
77343: void
77343: JSObject::TradeGuts(JSContext *cx, JSObject *a, JSObject *b, TradeGutsReserved &reserved)
58714: {
58714:     JS_ASSERT(a->compartment() == b->compartment());
58714:     JS_ASSERT(a->isFunction() == b->isFunction());
58714: 
77343:     /* Don't try to swap a JSFunction for a plain function JSObject. */
88142:     JS_ASSERT_IF(a->isFunction(), a->sizeOfThis() == b->sizeOfThis());
77343: 
60168:     /*
60168:      * Regexp guts are more complicated -- we would need to migrate the
60168:      * refcounted JIT code blob for them across compartments instead of just
60168:      * swapping guts.
60168:      */
60168:     JS_ASSERT(!a->isRegExp() && !b->isRegExp());
60168: 
77343:     /*
77427:      * Callers should not try to swap dense arrays or ArrayBuffer objects,
77427:      * these use a different slot representation from other objects.
77343:      */
77343:     JS_ASSERT(!a->isDenseArray() && !b->isDenseArray());
77427:     JS_ASSERT(!a->isArrayBuffer() && !b->isArrayBuffer());
58714: 
82129: #ifdef JSGC_INCREMENTAL
82129:     /*
82129:      * We need a write barrier here. If |a| was marked and |b| was not, then
82129:      * after the swap, |b|'s guts would never be marked. The write barrier
82129:      * solves this.
82129:      */
82129:     JSCompartment *comp = a->compartment();
82129:     if (comp->needsBarrier()) {
82129:         MarkChildren(comp->barrierTracer(), a);
82129:         MarkChildren(comp->barrierTracer(), b);
82129:     }
82129: #endif
82129: 
58714:     /* Trade the guts of the objects. */
88142:     const size_t size = a->sizeOfThis();
88142:     if (size == b->sizeOfThis()) {
58714:         /*
58714:          * If the objects are the same size, then we make no assumptions about
58714:          * whether they have dynamically allocated slots and instead just copy
58714:          * them over wholesale.
58714:          */
58714:         char tmp[tl::Max<sizeof(JSFunction), sizeof(JSObject_Slots16)>::result];
58714:         JS_ASSERT(size <= sizeof(tmp));
58714: 
87623:         js_memcpy(tmp, a, size);
87623:         js_memcpy(a, b, size);
87623:         js_memcpy(b, tmp, size);
58714:     } else {
58714:         /*
77343:          * If the objects are of differing sizes, use the space we reserved
77343:          * earlier to save the slots from each object and then copy them into
77343:          * the new layout for the other object.
58714:          */
77343: 
83231:         unsigned acap = a->slotSpan();
83231:         unsigned bcap = b->slotSpan();
77343: 
77343:         for (size_t i = 0; i < acap; i++)
77343:             reserved.avals.infallibleAppend(a->getSlot(i));
77343: 
77343:         for (size_t i = 0; i < bcap; i++)
77343:             reserved.bvals.infallibleAppend(b->getSlot(i));
77343: 
77343:         /* Done with the dynamic slots. */
83231:         if (a->hasDynamicSlots())
77343:             cx->free_(a->slots);
83231:         if (b->hasDynamicSlots())
77343:             cx->free_(b->slots);
77343: 
83233:         void *apriv = a->hasPrivate() ? a->getPrivate() : NULL;
83233:         void *bpriv = b->hasPrivate() ? b->getPrivate() : NULL;
77343: 
82129:         char tmp[sizeof(JSObject)];
87623:         js_memcpy(&tmp, a, sizeof tmp);
87623:         js_memcpy(a, b, sizeof tmp);
87623:         js_memcpy(b, &tmp, sizeof tmp);
77343: 
83247:         if (a->isNative())
83247:             a->shape_->setNumFixedSlots(reserved.newafixed);
83247:         else
83247:             a->shape_ = reserved.newashape;
83247: 
77343:         a->slots = reserved.newaslots;
86295:         a->initSlotRange(0, reserved.bvals.begin(), bcap);
83233:         if (a->hasPrivate())
83233:             a->setPrivate(bpriv);
83233: 
83247:         if (b->isNative())
83247:             b->shape_->setNumFixedSlots(reserved.newbfixed);
83247:         else
83247:             b->shape_ = reserved.newbshape;
83247: 
77343:         b->slots = reserved.newbslots;
86295:         b->initSlotRange(0, reserved.avals.begin(), acap);
83233:         if (b->hasPrivate())
83233:             b->setPrivate(apriv);
77343: 
77343:         /* Make sure the destructor for reserved doesn't free the slots. */
77343:         reserved.newaslots = NULL;
77343:         reserved.newbslots = NULL;
58714:     }
58714: }
58714: 
42733: /*
42733:  * Use this method with extreme caution. It trades the guts of two objects and updates
42733:  * scope ownership. This operation is not thread-safe, just as fast array to slow array
42733:  * transitions are inherently not thread-safe. Don't perform a swap operation on objects
42733:  * shared across threads or, or bad things will happen. You have been warned.
42733:  */
55746: bool
55746: JSObject::swap(JSContext *cx, JSObject *other)
42733: {
58714:     if (this->compartment() == other->compartment()) {
77343:         TradeGutsReserved reserved(cx);
77343:         if (!ReserveForTradeGuts(cx, this, other, reserved))
77343:             return false;
77343:         TradeGuts(cx, this, other, reserved);
58714:         return true;
58714:     }
58714: 
58714:     JSObject *thisClone;
58714:     JSObject *otherClone;
58714:     {
58714:         AutoCompartment ac(cx, other);
58714:         if (!ac.enter())
58714:             return false;
79734:         thisClone = JS_CloneObject(cx, this, other->getProto(), other->getParent());
79734:         if (!thisClone || !JS_CopyPropertiesFrom(cx, thisClone, this))
58714:             return false;
58714:     }
58714:     {
58714:         AutoCompartment ac(cx, this);
58714:         if (!ac.enter())
58714:             return false;
79734:         otherClone = JS_CloneObject(cx, other, other->getProto(), other->getParent());
79734:         if (!otherClone || !JS_CopyPropertiesFrom(cx, otherClone, other))
58714:             return false;
58714:     }
77343: 
77343:     TradeGutsReserved reservedThis(cx);
77343:     TradeGutsReserved reservedOther(cx);
77343: 
77343:     if (!ReserveForTradeGuts(cx, this, otherClone, reservedThis) ||
77343:         !ReserveForTradeGuts(cx, other, thisClone, reservedOther)) {
77343:         return false;
77343:     }
77343: 
77343:     TradeGuts(cx, this, otherClone, reservedThis);
77343:     TradeGuts(cx, other, thisClone, reservedOther);
55746: 
55746:     return true;
42733: }
42733: 
42772: static bool
42772: DefineStandardSlot(JSContext *cx, JSObject *obj, JSProtoKey key, JSAtom *atom,
84755:                    const Value &v, uint32_t attrs, bool &named)
42772: {
42772:     jsid id = ATOM_TO_JSID(atom);
42772: 
42772:     if (key != JSProto_Null) {
42772:         /*
42772:          * Initializing an actual standard class on a global object. If the
42772:          * property is not yet present, force it into a new one bound to a
42772:          * reserved slot. Otherwise, go through the normal property path.
42772:          */
60566:         JS_ASSERT(obj->isGlobal());
42772:         JS_ASSERT(obj->isNative());
42772: 
78194:         const Shape *shape = obj->nativeLookup(cx, id);
52503:         if (!shape) {
84755:             uint32_t slot = 2 * JSProto_LIMIT + key;
56567:             if (!js_SetReservedSlot(cx, obj, slot, v))
42772:                 return false;
78614:             if (!obj->addProperty(cx, id, JS_PropertyStub, JS_StrictPropertyStub, slot, attrs, 0, 0))
42772:                 return false;
77353:             AddTypePropertyId(cx, obj, id, v);
42772: 
42772:             named = true;
42772:             return true;
42772:         }
42772:     }
42772: 
80624:     named = obj->defineGeneric(cx, id, v, JS_PropertyStub, JS_StrictPropertyStub, attrs);
42772:     return named;
42772: }
42772: 
61705: namespace js {
61705: 
77343: static bool
77343: SetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject *cobj, JSObject *proto)
77343: {
77343:     JS_ASSERT(!obj->getParent());
77343:     if (!obj->isGlobal())
77343:         return true;
77343: 
77343:     return js_SetReservedSlot(cx, obj, key, ObjectOrNullValue(cobj)) &&
77343:            js_SetReservedSlot(cx, obj, JSProto_LIMIT + key, ObjectOrNullValue(proto));
77343: }
77343: 
77343: static void
77343: ClearClassObject(JSContext *cx, JSObject *obj, JSProtoKey key)
77343: {
77343:     JS_ASSERT(!obj->getParent());
77343:     if (!obj->isGlobal())
77343:         return;
77343: 
77343:     obj->setSlot(key, UndefinedValue());
77343:     obj->setSlot(JSProto_LIMIT + key, UndefinedValue());
77343: }
77343: 
25897: JSObject *
86437: DefineConstructorAndPrototype(JSContext *cx, HandleObject obj, JSProtoKey key, HandleAtom atom,
61705:                               JSObject *protoProto, Class *clasp,
61705:                               Native constructor, uintN nargs,
25897:                               JSPropertySpec *ps, JSFunctionSpec *fs,
75413:                               JSPropertySpec *static_ps, JSFunctionSpec *static_fs,
83262:                               JSObject **ctorp, AllocKind ctorKind)
25897: {
47497:     /*
47497:      * Create a prototype object for this class.
47497:      *
47497:      * FIXME: lazy standard (built-in) class initialization and even older
47497:      * eager boostrapping code rely on all of these properties:
47497:      *
47497:      * 1. NewObject attempting to compute a default prototype object when
47497:      *    passed null for proto; and
47497:      *
47497:      * 2. NewObject tolerating no default prototype (null proto slot value)
47497:      *    due to this js_InitClass call coming from js_InitFunctionClass on an
47497:      *    otherwise-uninitialized global.
47497:      *
47497:      * 3. NewObject allocating a JSFunction-sized GC-thing when clasp is
77817:      *    &FunctionClass, not a JSObject-sized (smaller) GC-thing.
47497:      *
47497:      * The JS_NewObjectForGivenProto and JS_NewObject APIs also allow clasp to
77817:      * be &FunctionClass (we could break compatibility easily). But fixing
47497:      * (3) is not enough without addressing the bootstrapping dependency on (1)
47497:      * and (2).
47497:      */
73996: 
73996:     /*
73996:      * Create the prototype object.  (GlobalObject::createBlankPrototype isn't
73996:      * used because it parents the prototype object to the global and because
73996:      * it uses WithProto::Given.  FIXME: Undo dependencies on this parentage
73996:      * [which already needs to happen for bug 638316], figure out nicer
73996:      * semantics for null-protoProto, and use createBlankPrototype.)
73996:      */
86437:     RootedVarObject proto(cx);
86437:     proto = NewObjectWithClassProto(cx, clasp, protoProto, obj);
73904:     if (!proto)
73904:         return NULL;
73904: 
77353:     if (!proto->setSingletonType(cx))
77343:         return NULL;
77343: 
77817:     if (clasp == &ArrayClass && !proto->makeDenseArraySlow(cx))
77343:         return NULL;
77343: 
25897:     /* After this point, control must exit via label bad or out. */
86437:     RootedVarObject ctor(cx);
61705:     bool named = false;
77343:     bool cached = false;
25897:     if (!constructor) {
25897:         /*
25897:          * Lacking a constructor, name the prototype (e.g., Math) unless this
25897:          * class (a) is anonymous, i.e. for internal use only; (b) the class
25897:          * of obj (the global object) is has a reserved slot indexed by key;
25897:          * and (c) key is not the null key.
25897:          */
60566:         if (!(clasp->flags & JSCLASS_IS_ANONYMOUS) || !obj->isGlobal() || key == JSProto_Null) {
84755:             uint32_t attrs = (clasp->flags & JSCLASS_IS_ANONYMOUS)
25897:                            ? JSPROP_READONLY | JSPROP_PERMANENT
42772:                            : 0;
48470:             if (!DefineStandardSlot(cx, obj, key, atom, ObjectValue(*proto), attrs, named))
25897:                 goto bad;
25897:         }
25897: 
25897:         ctor = proto;
25897:     } else {
73789:         /*
73789:          * Create the constructor, not using GlobalObject::createConstructor
73789:          * because the constructor currently must have |obj| as its parent.
73789:          * (FIXME: remove this dependency on the exact identity of the parent,
73789:          * perhaps as part of bug 638316.)
73789:          */
86437:         RootedVarFunction fun(cx);
86437:         fun = js_NewFunction(cx, NULL, constructor, nargs, JSFUN_CONSTRUCTOR, obj, atom,
83262:                              ctorKind);
25897:         if (!fun)
25897:             goto bad;
76812:         fun->setConstructorClass(clasp);
25897: 
77343:         /*
77343:          * Set the class object early for standard class constructors. Type
77343:          * inference may need to access these, and js_GetClassPrototype will
77343:          * fail if it tries to do a reentrant reconstruction of the class.
77343:          */
82391:         if (key != JSProto_Null) {
77343:             if (!SetClassObject(cx, obj, key, fun, proto))
77343:                 goto bad;
77343:             cached = true;
77343:         }
77343: 
48470:         AutoValueRooter tvr2(cx, ObjectValue(*fun));
42772:         if (!DefineStandardSlot(cx, obj, key, atom, tvr2.value(), 0, named))
42772:             goto bad;
42772: 
25897:         /*
25897:          * Optionally construct the prototype object, before the class has
25897:          * been fully initialized.  Allow the ctor to replace proto with a
25897:          * different object, as is done for operator new -- and as at least
25897:          * XML support requires.
25897:          */
76812:         ctor = fun;
73788:         if (!LinkConstructorAndPrototype(cx, ctor, proto))
25897:             goto bad;
25897: 
25897:         /* Bootstrap Function.prototype (see also JS_InitStandardClasses). */
77353:         if (ctor->getClass() == clasp && !ctor->splicePrototype(cx, proto))
77353:             goto bad;
25897:     }
25897: 
73790:     if (!DefinePropertiesAndBrand(cx, proto, ps, fs) ||
73790:         (ctor != proto && !DefinePropertiesAndBrand(cx, ctor, static_ps, static_fs)))
73790:     {
25897:         goto bad;
25897:     }
25897: 
56574:     if (clasp->flags & (JSCLASS_FREEZE_PROTO|JSCLASS_FREEZE_CTOR)) {
56576:         JS_ASSERT_IF(ctor == proto, !(clasp->flags & JSCLASS_FREEZE_CTOR));
56574:         if (proto && (clasp->flags & JSCLASS_FREEZE_PROTO) && !proto->freeze(cx))
56574:             goto bad;
56574:         if (ctor && (clasp->flags & JSCLASS_FREEZE_CTOR) && !ctor->freeze(cx))
56574:             goto bad;
56574:     }
56574: 
25897:     /* If this is a standard class, cache its prototype. */
77343:     if (!cached && key != JSProto_Null && !SetClassObject(cx, obj, key, ctor, proto))
25897:         goto bad;
25897: 
75413:     if (ctorp)
75413:         *ctorp = ctor;
25897:     return proto;
25897: 
25897: bad:
48470:     if (named) {
48470:         Value rval;
86790:         obj->deleteByValue(cx, StringValue(atom), &rval, false);
48470:     }
77343:     if (cached)
77343:         ClearClassObject(cx, obj, key);
48470:     return NULL;
25897: }
25897: 
69232: /*
69232:  * Lazy standard classes need a way to indicate if they have been initialized.
69232:  * Otherwise, when we delete them, we might accidentally recreate them via a
69232:  * lazy initialization. We use the presence of a ctor or proto in the
69232:  * globalObject's slot to indicate that they've been constructed, but this only
69232:  * works for classes which have a proto and ctor. Classes which don't have one
69232:  * can call MarkStandardClassInitializedNoProto(), and we can always check
69232:  * whether a class is initialized by calling IsStandardClassResolved().
69232:  */
69232: bool
69232: IsStandardClassResolved(JSObject *obj, js::Class *clasp)
69232: {
69232:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
69232: 
69232:     /* If the constructor is undefined, then it hasn't been initialized. */
69237:     return (obj->getReservedSlot(key) != UndefinedValue());
69232: }
69232: 
69232: void
69232: MarkStandardClassInitializedNoProto(JSObject *obj, js::Class *clasp)
69232: {
69232:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
69232: 
69232:     /*
69232:      * We use True so that it's obvious what we're doing (instead of, say,
69232:      * Null, which might be miscontrued as an error in setting Undefined).
69232:      */
69237:     if (obj->getReservedSlot(key) == UndefinedValue())
69232:         obj->setSlot(key, BooleanValue(true));
69232: }
69232: 
61705: }
61705: 
61705: JSObject *
86437: js_InitClass(JSContext *cx, HandleObject obj, JSObject *protoProto,
61705:              Class *clasp, Native constructor, uintN nargs,
61705:              JSPropertySpec *ps, JSFunctionSpec *fs,
75413:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs,
83262:              JSObject **ctorp, AllocKind ctorKind)
61705: {
86437:     RootObject rootProto(cx, &protoProto);
86437: 
86437:     RootedVarAtom atom(cx);
86437:     atom = js_Atomize(cx, clasp->name, strlen(clasp->name));
61705:     if (!atom)
61705:         return NULL;
61705: 
61705:     /*
61705:      * All instances of the class will inherit properties from the prototype
61705:      * object we are about to create (in DefineConstructorAndPrototype), which
61705:      * in turn will inherit from protoProto.
61705:      *
61705:      * When initializing a standard class (other than Object), if protoProto is
61705:      * null, default to the Object prototype object. The engine's internal uses
61705:      * of js_InitClass depend on this nicety. Note that in
61705:      * js_InitFunctionAndObjectClasses, we specially hack the resolving table
61705:      * and then depend on js_GetClassPrototype here leaving protoProto NULL and
61705:      * returning true.
61705:      */
61705:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
61705:     if (key != JSProto_Null &&
61705:         !protoProto &&
61705:         !js_GetClassPrototype(cx, obj, JSProto_Object, &protoProto)) {
61705:         return NULL;
61705:     }
61705: 
61705:     return DefineConstructorAndPrototype(cx, obj, key, atom, protoProto, clasp, constructor, nargs,
83262:                                          ps, fs, static_ps, static_fs, ctorp, ctorKind);
77343: }
77343: 
77343: void
86295: JSObject::getSlotRange(size_t start, size_t length,
86295:                        HeapValue **fixedStart, HeapValue **fixedEnd,
86295:                        HeapValue **slotsStart, HeapValue **slotsEnd)
86295: {
83231:     JS_ASSERT(!isDenseArray());
83281:     JS_ASSERT(slotInRange(start + length, SENTINEL_ALLOWED));
86295: 
77343:     size_t fixed = numFixedSlots();
77343:     if (start < fixed) {
77343:         if (start + length < fixed) {
86295:             *fixedStart = &fixedSlots()[start];
86295:             *fixedEnd = &fixedSlots()[start + length];
86295:             *slotsStart = *slotsEnd = NULL;
77343:         } else {
77343:             size_t localCopy = fixed - start;
86295:             *fixedStart = &fixedSlots()[start];
86295:             *fixedEnd = &fixedSlots()[start + localCopy];
86295:             *slotsStart = &slots[0];
86295:             *slotsEnd = &slots[length - localCopy];
77343:         }
77343:     } else {
86295:         *fixedStart = *fixedEnd = NULL;
86295:         *slotsStart = &slots[start - fixed];
86295:         *slotsEnd = &slots[start - fixed + length];
86295:     }
86295: }
86295: 
86295: void
86295: JSObject::initSlotRange(size_t start, const Value *vector, size_t length)
86295: {
86295:     JSCompartment *comp = compartment();
86295:     HeapValue *fixedStart, *fixedEnd, *slotsStart, *slotsEnd;
86295:     getSlotRange(start, length, &fixedStart, &fixedEnd, &slotsStart, &slotsEnd);
86295:     for (HeapValue *vp = fixedStart; vp != fixedEnd; vp++)
86295:         vp->init(comp, *vector++);
86295:     for (HeapValue *vp = slotsStart; vp != slotsEnd; vp++)
86295:         vp->init(comp, *vector++);
86295: }
86295: 
86295: void
86295: JSObject::copySlotRange(size_t start, const Value *vector, size_t length)
86295: {
86295:     JSCompartment *comp = compartment();
86295:     HeapValue *fixedStart, *fixedEnd, *slotsStart, *slotsEnd;
86295:     getSlotRange(start, length, &fixedStart, &fixedEnd, &slotsStart, &slotsEnd);
86295:     for (HeapValue *vp = fixedStart; vp != fixedEnd; vp++)
86295:         vp->set(comp, *vector++);
86295:     for (HeapValue *vp = slotsStart; vp != slotsEnd; vp++)
86295:         vp->set(comp, *vector++);
77343: }
83231: 
83231: inline void
83231: JSObject::invalidateSlotRange(size_t start, size_t length)
83231: {
83231: #ifdef DEBUG
83231:     JS_ASSERT(!isDenseArray());
83231: 
83231:     size_t fixed = numFixedSlots();
83304: 
83304:     /* No bounds checks, allocated space has been updated but not the shape. */
83231:     if (start < fixed) {
83231:         if (start + length < fixed) {
83231:             Debug_SetValueRangeToCrashOnTouch(fixedSlots() + start, length);
83231:         } else {
83231:             size_t localClear = fixed - start;
83231:             Debug_SetValueRangeToCrashOnTouch(fixedSlots() + start, localClear);
83231:             Debug_SetValueRangeToCrashOnTouch(slots, length - localClear);
83231:         }
83231:     } else {
83231:         Debug_SetValueRangeToCrashOnTouch(slots + start - fixed, length);
83231:     }
83231: #endif /* DEBUG */
83231: }
83231: 
83304: inline bool
83304: JSObject::updateSlotsForSpan(JSContext *cx, size_t oldSpan, size_t newSpan)
83231: {
83231:     JS_ASSERT(oldSpan != newSpan);
83231: 
83304:     size_t oldCount = dynamicSlotsCount(numFixedSlots(), oldSpan);
83304:     size_t newCount = dynamicSlotsCount(numFixedSlots(), newSpan);
83304: 
83304:     if (oldSpan < newSpan) {
83304:         if (oldCount < newCount && !growSlots(cx, oldCount, newCount))
83304:             return false;
83304: 
83304:         if (newSpan == oldSpan + 1)
83301:             initSlotUnchecked(oldSpan, UndefinedValue());
83304:         else
83301:             initializeSlotRange(oldSpan, newSpan - oldSpan);
83301:     } else {
83304:         /* Trigger write barriers on the old slots before reallocating. */
83301:         prepareSlotRangeForOverwrite(newSpan, oldSpan);
83231:         invalidateSlotRange(newSpan, oldSpan - newSpan);
83304: 
83304:         if (oldCount > newCount)
83304:             shrinkSlots(cx, oldCount, newCount);
83304:     }
83304: 
83304:     return true;
77343: }
77343: 
40858: bool
83231: JSObject::setLastProperty(JSContext *cx, const js::Shape *shape)
83231: {
83231:     JS_ASSERT(!inDictionaryMode());
83231:     JS_ASSERT(!shape->inDictionary());
83231:     JS_ASSERT(shape->compartment() == compartment());
83247:     JS_ASSERT(shape->numFixedSlots() == numFixedSlots());
83231: 
83231:     size_t oldSpan = lastProperty()->slotSpan();
83231:     size_t newSpan = shape->slotSpan();
83231: 
83231:     if (oldSpan == newSpan) {
83231:         shape_ = const_cast<js::Shape *>(shape);
83231:         return true;
83231:     }
83231: 
83304:     if (!updateSlotsForSpan(cx, oldSpan, newSpan))
83231:         return false;
83231: 
83231:     shape_ = const_cast<js::Shape *>(shape);
83231:     return true;
83231: }
83231: 
83231: bool
84755: JSObject::setSlotSpan(JSContext *cx, uint32_t span)
83231: {
83231:     JS_ASSERT(inDictionaryMode());
83231:     js::BaseShape *base = lastProperty()->base();
83231: 
83231:     size_t oldSpan = base->slotSpan();
83231: 
83231:     if (oldSpan == span)
83231:         return true;
83231: 
83304:     if (!updateSlotsForSpan(cx, oldSpan, span))
83231:         return false;
83231: 
83231:     base->setSlotSpan(span);
83231:     return true;
83231: }
83231: 
88304: #if defined(_MSC_VER) && _MSC_VER >= 1500
88304: /* Work around a compiler bug in MSVC9 and above, where inlining this function
88304:    causes stack pointer offsets to go awry and spp to refer to something higher
88304:    up the stack. */
88304: MOZ_NEVER_INLINE
88304: #endif
88304: const js::Shape *
88304: JSObject::nativeLookup(JSContext *cx, jsid id)
88304: {
88304:     JS_ASSERT(isNative());
88304:     js::Shape **spp;
88304:     return js::Shape::search(cx, lastProperty(), id, &spp);
88304: }
88304: 
83231: bool
84755: JSObject::growSlots(JSContext *cx, uint32_t oldCount, uint32_t newCount)
83231: {
83231:     JS_ASSERT(newCount > oldCount);
83231:     JS_ASSERT(newCount >= SLOT_CAPACITY_MIN);
83275:     JS_ASSERT(!isDenseArray());
83231: 
80561:     /*
80561:      * Slots are only allocated for call objects when new properties are
80561:      * added to them, which can only happen while the call is still on the
80561:      * stack (and an eval, DEFFUN, etc. happens). We thus do not need to
80561:      * worry about updating any active outer function args/vars.
80561:      */
83275:     JS_ASSERT_IF(isCall(), asCall().maybeStackFrame() != NULL);
83231: 
83247:     /*
83247:      * Slot capacities are determined by the span of allocated objects. Due to
83247:      * the limited number of bits to store shape slots, object growth is
83247:      * throttled well before the slot capacity can overflow.
83247:      */
83247:     JS_ASSERT(newCount < NELEMENTS_LIMIT);
83231: 
88142:     size_t oldSize = Probes::objectResizeActive() ? computedSizeOfIncludingThis() : 0;
83231:     size_t newSize = oldSize + (newCount - oldCount) * sizeof(Value);
55746: 
77343:     /*
77343:      * If we are allocating slots for an object whose type is always created
77343:      * by calling 'new' on a particular script, bump the GC kind for that
77343:      * type to give these objects a larger number of fixed slots when future
77343:      * objects are constructed.
77343:      */
83267:     if (!hasLazyType() && !oldCount && type()->newScript) {
77775:         gc::AllocKind kind = type()->newScript->allocKind;
77343:         unsigned newScriptSlots = gc::GetGCKindSlots(kind);
77775:         if (newScriptSlots == numFixedSlots() && gc::TryIncrementAllocKind(&kind)) {
77392:             JSObject *obj = NewReshapedObject(cx, type(), getParent(), kind,
77392:                                               type()->newScript->shape);
77343:             if (!obj)
77343:                 return false;
77343: 
77775:             type()->newScript->allocKind = kind;
77353:             type()->newScript->shape = obj->lastProperty();
77414:             type()->markStateChange(cx);
77343:         }
77343:     }
55746: 
83231:     if (!oldCount) {
83301:         slots = (HeapValue *) cx->malloc_(newCount * sizeof(HeapValue));
83231:         if (!slots)
83231:             return false;
83231:         Debug_SetValueRangeToCrashOnTouch(slots, newCount);
83231:         if (Probes::objectResizeActive())
83231:             Probes::resizeObject(cx, this, oldSize, newSize);
30454:         return true;
30454:     }
30454: 
83301:     HeapValue *newslots = (HeapValue*) cx->realloc_(slots, oldCount * sizeof(HeapValue),
83301:                                                     newCount * sizeof(HeapValue));
83281:     if (!newslots)
83231:         return false;  /* Leave slots at its old size. */
83231: 
83281:     bool changed = slots != newslots;
83281:     slots = newslots;
83231: 
83231:     Debug_SetValueRangeToCrashOnTouch(slots + oldCount, newCount - oldCount);
83231: 
83231:     /* Changes in the slots of global objects can trigger recompilation. */
83231:     if (changed && isGlobal())
83231:         types::MarkObjectStateChange(cx, this);
83231: 
83231:     if (Probes::objectResizeActive())
83231:         Probes::resizeObject(cx, this, oldSize, newSize);
80993: 
80993:     return true;
80993: }
80993: 
83231: void
84755: JSObject::shrinkSlots(JSContext *cx, uint32_t oldCount, uint32_t newCount)
83231: {
83231:     JS_ASSERT(newCount < oldCount);
83231:     JS_ASSERT(!isDenseArray());
83231: 
83231:     /*
83231:      * Refuse to shrink slots for call objects. This only happens in a very
83231:      * obscure situation (deleting names introduced by a direct 'eval') and
83231:      * allowing the slots pointer to change may require updating pointers in
83231:      * the function's active args/vars information.
83231:      */
83231:     if (isCall())
83231:         return;
83231: 
88142:     size_t oldSize = Probes::objectResizeActive() ? computedSizeOfIncludingThis() : 0;
83231:     size_t newSize = oldSize - (oldCount - newCount) * sizeof(Value);
83231: 
83231:     if (newCount == 0) {
83231:         cx->free_(slots);
83231:         slots = NULL;
83231:         if (Probes::objectResizeActive())
83231:             Probes::resizeObject(cx, this, oldSize, newSize);
83231:         return;
83231:     }
83231: 
83231:     JS_ASSERT(newCount >= SLOT_CAPACITY_MIN);
83231: 
83301:     HeapValue *newslots = (HeapValue*) cx->realloc_(slots, newCount * sizeof(HeapValue));
83281:     if (!newslots)
83231:         return;  /* Leave slots at its old size. */
83231: 
83281:     bool changed = slots != newslots;
83281:     slots = newslots;
83231: 
83231:     /* Watch for changes in global object slots, as for growSlots. */
83231:     if (changed && isGlobal())
83231:         types::MarkObjectStateChange(cx, this);
83231: 
83231:     if (Probes::objectResizeActive())
83231:         Probes::resizeObject(cx, this, oldSize, newSize);
83231: }
83231: 
30454: bool
83231: JSObject::growElements(JSContext *cx, uintN newcap)
83231: {
83231:     JS_ASSERT(isDenseArray());
83231: 
83231:     /*
83231:      * When an object with CAPACITY_DOUBLING_MAX or fewer elements needs to
55746:      * grow, double its capacity, to add N elements in amortized O(N) time.
55746:      *
55746:      * Above this limit, grow by 12.5% each time. Speed is still amortized
55746:      * O(N), with a higher constant factor, and we waste less space.
    1:      */
55746:     static const size_t CAPACITY_DOUBLING_MAX = 1024 * 1024;
55746:     static const size_t CAPACITY_CHUNK = CAPACITY_DOUBLING_MAX / sizeof(Value);
55746: 
84755:     uint32_t oldcap = getDenseArrayCapacity();
83231:     JS_ASSERT(oldcap <= newcap);
83231: 
88142:     size_t oldSize = Probes::objectResizeActive() ? computedSizeOfIncludingThis() : 0;
77354: 
84755:     uint32_t nextsize = (oldcap <= CAPACITY_DOUBLING_MAX)
55746:                       ? oldcap * 2
55746:                       : oldcap + (oldcap >> 3);
55746: 
84755:     uint32_t actualCapacity = JS_MAX(newcap, nextsize);
55746:     if (actualCapacity >= CAPACITY_CHUNK)
55746:         actualCapacity = JS_ROUNDUP(actualCapacity, CAPACITY_CHUNK);
55746:     else if (actualCapacity < SLOT_CAPACITY_MIN)
55746:         actualCapacity = SLOT_CAPACITY_MIN;
52503: 
84755:     /* Don't let nelements get close to wrapping around uint32_t. */
83247:     if (actualCapacity >= NELEMENTS_LIMIT || actualCapacity < oldcap || actualCapacity < newcap) {
52503:         JS_ReportOutOfMemory(cx);
52503:         return false;
52503:     }
30454: 
84755:     uint32_t initlen = getDenseArrayInitializedLength();
84755:     uint32_t newAllocated = actualCapacity + ObjectElements::VALUES_PER_HEADER;
83281: 
83281:     ObjectElements *newheader;
83231:     if (hasDynamicElements()) {
84755:         uint32_t oldAllocated = oldcap + ObjectElements::VALUES_PER_HEADER;
83281:         newheader = (ObjectElements *)
83281:             cx->realloc_(getElementsHeader(), oldAllocated * sizeof(Value),
83281:                          newAllocated * sizeof(Value));
83281:         if (!newheader)
83231:             return false;  /* Leave elements as its old size. */
77343:     } else {
83281:         newheader = (ObjectElements *) cx->malloc_(newAllocated * sizeof(Value));
83281:         if (!newheader)
83231:             return false;  /* Ditto. */
87623:         js_memcpy(newheader, getElementsHeader(),
83281:                   (ObjectElements::VALUES_PER_HEADER + initlen) * sizeof(Value));
83281:     }
83281: 
83281:     newheader->capacity = actualCapacity;
83281:     elements = newheader->elements();
83231: 
83231:     Debug_SetValueRangeToCrashOnTouch(elements + initlen, actualCapacity - initlen);
83231: 
83231:     if (Probes::objectResizeActive())
88142:         Probes::resizeObject(cx, this, oldSize, computedSizeOfIncludingThis());
73746: 
30454:     return true;
30454: }
30454: 
30454: void
83231: JSObject::shrinkElements(JSContext *cx, uintN newcap)
83231: {
83231:     JS_ASSERT(isDenseArray());
83231: 
84755:     uint32_t oldcap = getDenseArrayCapacity();
83231:     JS_ASSERT(newcap <= oldcap);
83231: 
88142:     size_t oldSize = Probes::objectResizeActive() ? computedSizeOfIncludingThis() : 0;
83231: 
83231:     /* Don't shrink elements below the minimum capacity. */
83231:     if (oldcap <= SLOT_CAPACITY_MIN || !hasDynamicElements())
77884:         return;
77884: 
83231:     newcap = Max(newcap, SLOT_CAPACITY_MIN);
83231: 
84755:     uint32_t newAllocated = newcap + ObjectElements::VALUES_PER_HEADER;
83281: 
83281:     ObjectElements *newheader = (ObjectElements *)
83281:         cx->realloc_(getElementsHeader(), newAllocated * sizeof(Value));
83281:     if (!newheader)
83231:         return;  /* Leave elements at its old size. */
83231: 
83281:     newheader->capacity = newcap;
83281:     elements = newheader->elements();
83231: 
83231:     if (Probes::objectResizeActive())
88142:         Probes::resizeObject(cx, this, oldSize, computedSizeOfIncludingThis());
    1: }
    1: 
83231: #ifdef DEBUG
30732: bool
83281: JSObject::slotInRange(uintN slot, SentinelAllowed sentinel) const
83231: {
83231:     size_t capacity = numFixedSlots() + numDynamicSlots();
83281:     if (sentinel == SENTINEL_ALLOWED)
83231:         return slot <= capacity;
83231:     return slot < capacity;
83231: }
83231: #endif /* DEBUG */
30732: 
18907: static JSObject *
    1: js_InitNullClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JS_ASSERT(0);
    1:     return NULL;
    1: }
    1: 
    1: #define JS_PROTO(name,code,init) extern JSObject *init(JSContext *, JSObject *);
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: 
    1: static JSObjectOp lazy_prototype_init[JSProto_LIMIT] = {
    1: #define JS_PROTO(name,code,init) init,
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: };
    1: 
47465: namespace js {
47465: 
47465: bool
47465: SetProto(JSContext *cx, JSObject *obj, JSObject *proto, bool checkForCycles)
47465: {
47465:     JS_ASSERT_IF(!checkForCycles, obj != proto);
54563:     JS_ASSERT(obj->isExtensible());
47465: 
72561:     if (proto && proto->isXML()) {
72561:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_XML_PROTO_FORBIDDEN);
72561:         return false;
72561:     }
72561: 
47465:     /*
83221:      * Regenerate shapes for all of the scopes along the old prototype chain,
84343:      * in case any entries were filled by looking up through obj. Stop when a
83334:      * non-native object is found, prototype lookups will not be cached across
83334:      * these.
84343:      *
84343:      * How this shape change is done is very delicate; the change can be made
84343:      * either by marking the object's prototype as uncacheable (such that the
84343:      * property cache and JIT'ed ICs cannot assume the shape determines the
84343:      * prototype) or by just generating a new shape for the object. Choosing
84343:      * the former is bad if the object is on the prototype chain of other
84343:      * objects, as the uncacheable prototype can inhibit iterator caches on
84343:      * those objects and slow down prototype accesses. Choosing the latter is
84343:      * bad if there are many similar objects to this one which will have their
84343:      * prototype mutated, as the generateOwnShape forces the object into
84343:      * dictionary mode and similar property lineages will be repeatedly cloned.
84343:      *
84343:      * :XXX: bug 707717 make this code less brittle.
47465:      */
47465:     JSObject *oldproto = obj;
47465:     while (oldproto && oldproto->isNative()) {
84343:         if (oldproto->hasSingletonType()) {
84343:             if (!oldproto->generateOwnShape(cx))
84343:                 return false;
84343:         } else {
83334:             if (!oldproto->setUncacheableProto(cx))
83221:                 return false;
84343:         }
56567:         oldproto = oldproto->getProto();
47465:     }
47465: 
70316:     if (checkForCycles) {
70316:         for (JSObject *obj2 = proto; obj2; obj2 = obj2->getProto()) {
70316:             if (obj2 == obj) {
70316:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CYCLIC_VALUE,
70316:                                      js_proto_str);
70316:                 return false;
70316:             }
70316:         }
70316:     }
77343: 
77353:     if (obj->hasSingletonType()) {
77353:         /*
77353:          * Just splice the prototype, but mark the properties as unknown for
77353:          * consistent behavior.
77353:          */
77353:         if (!obj->splicePrototype(cx, proto))
77353:             return false;
77353:         MarkTypeObjectUnknownProperties(cx, obj->type());
77353:         return true;
77353:     }
77353: 
83286:     if (proto && !proto->setNewTypeUnknown(cx))
83286:         return false;
83286: 
77353:     TypeObject *type = proto
83286:         ? proto->getNewType(cx, NULL)
83230:         : cx->compartment->getEmptyType(cx);
77353:     if (!type)
77353:         return false;
77353: 
77353:     /*
77353:      * Setting __proto__ on an object that has escaped and may be referenced by
77353:      * other heap objects can only be done if the properties of both objects
77353:      * are unknown. Type sets containing this object will contain the original
77353:      * type but not the new type of the object, so we need to go and scan the
77353:      * entire compartment for type sets which have these objects and mark them
77353:      * as containing generic objects.
77353:      */
77353:     MarkTypeObjectUnknownProperties(cx, obj->type(), true);
77353:     MarkTypeObjectUnknownProperties(cx, type, true);
77353: 
77343:     obj->setType(type);
47465:     return true;
47465: }
47465: 
43258: }
43258: 
    1: JSBool
    1: js_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp)
    1: {
86437:     RootObject objRoot(cx, &obj);
86437: 
86483:     obj = &obj->global();
60566:     if (!obj->isGlobal()) {
    1:         *objp = NULL;
64302:         return true;
64302:     }
64302: 
69237:     Value v = obj->getReservedSlot(key);
48470:     if (v.isObject()) {
48470:         *objp = &v.toObject();
64302:         return true;
64302:     }
64302: 
64302:     AutoResolving resolving(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]));
64302:     if (resolving.alreadyStarted()) {
64302:         /* Already caching id in obj -- suppress recursion. */
    1:         *objp = NULL;
64302:         return true;
64302:     }
64302: 
64302:     JSObject *cobj = NULL;
64302:     if (JSObjectOp init = lazy_prototype_init[key]) {
64302:         if (!init(cx, obj))
64302:             return false;
69237:         v = obj->getReservedSlot(key);
48470:         if (v.isObject())
48470:             cobj = &v.toObject();
    1:     }
64302: 
    1:     *objp = cobj;
64302:     return true;
    1: }
    1: 
    1: JSBool
38604: js_FindClassObject(JSContext *cx, JSObject *start, JSProtoKey protoKey,
48470:                    Value *vp, Class *clasp)
    1: {
86437:     JSObject *cobj, *pobj;
38604:     jsid id;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
86437:     RootedVarObject obj(cx);
86437: 
22652:     if (start) {
86483:         obj = &start->global();
86437:         OBJ_TO_INNER_OBJECT(cx, *obj.address());
    1:     } else {
84293:         obj = GetGlobalForScopeChain(cx);
84293:     }
    1:     if (!obj)
69855:         return false;
    1: 
38604:     if (protoKey != JSProto_Null) {
69237:         JS_ASSERT(JSProto_Null < protoKey);
69237:         JS_ASSERT(protoKey < JSProto_LIMIT);
38604:         if (!js_GetClassObject(cx, obj, protoKey, &cobj))
69855:             return false;
    1:         if (cobj) {
48470:             vp->setObject(*cobj);
    1:             return JS_TRUE;
    1:         }
38604:         id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[protoKey]);
38604:     } else {
70270:         JSAtom *atom = js_Atomize(cx, clasp->name, strlen(clasp->name));
38604:         if (!atom)
38604:             return false;
38604:         id = ATOM_TO_JSID(atom);
    1:     }
    1: 
40430:     JS_ASSERT(obj->isNative());
69855:     if (!LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_CLASSNAME, &pobj, &prop))
69855:         return false;
48470:     Value v = UndefinedValue();
43290:     if (prop && pobj->isNative()) {
52503:         shape = (Shape *) prop;
86009:         if (shape->hasSlot()) {
83221:             v = pobj->nativeGetSlot(shape->slot());
48470:             if (v.isPrimitive())
48470:                 v.setUndefined();
 8893:         }
 8893:     }
 8893:     *vp = v;
69855:     return true;
    1: }
    1: 
52503: bool
84755: JSObject::allocSlot(JSContext *cx, uint32_t *slotp)
84755: {
84755:     uint32_t slot = slotSpan();
74457:     JS_ASSERT(slot >= JSSLOT_FREE(getClass()));
53650: 
53650:     /*
83221:      * If this object is in dictionary mode, try to pull a free slot from the
83221:      * property table's slot-number freelist.
83221:      */
83221:     if (inDictionaryMode()) {
83231:         PropertyTable &table = lastProperty()->table();
84755:         uint32_t last = table.freelist;
53546:         if (last != SHAPE_INVALID_SLOT) {
53650: #ifdef DEBUG
53650:             JS_ASSERT(last < slot);
84755:             uint32_t next = getSlot(last).toPrivateUint32();
53650:             JS_ASSERT_IF(next != SHAPE_INVALID_SLOT, next < slot);
53650: #endif
53650: 
53546:             *slotp = last;
53546: 
74457:             const Value &vref = getSlot(last);
83229:             table.freelist = vref.toPrivateUint32();
74457:             setSlot(last, UndefinedValue());
53546:             return true;
53546:         }
53546:     }
53546: 
83247:     if (slot >= SHAPE_MAXIMUM_SLOT) {
83247:         js_ReportOutOfMemory(cx);
83247:         return false;
83247:     }
83247: 
53650:     *slotp = slot;
83221: 
83231:     if (inDictionaryMode() && !setSlotSpan(cx, slot + 1))
83231:         return false;
83221: 
52503:     return true;
    1: }
    1: 
83221: void
84755: JSObject::freeSlot(JSContext *cx, uint32_t slot)
52503: {
83227:     JS_ASSERT(slot < slotSpan());
79734: 
83221:     if (inDictionaryMode()) {
84755:         uint32_t &last = lastProperty()->table().freelist;
53546: 
53650:         /* Can't afford to check the whole freelist, but let's check the head. */
83227:         JS_ASSERT_IF(last != SHAPE_INVALID_SLOT, last < slotSpan() && last != slot);
79734: 
79734:         /*
83221:          * Place all freed slots other than reserved slots (bug 595230) on the
83221:          * dictionary's free list.
83221:          */
83221:         if (JSSLOT_FREE(getClass()) <= slot) {
53652:             JS_ASSERT_IF(last != SHAPE_INVALID_SLOT, last < slotSpan());
74457:             setSlot(slot, PrivateUint32Value(last));
53546:             last = slot;
83221:             return;
53546:         }
53546:     }
74457:     setSlot(slot, UndefinedValue());
83221: }
83221: 
83221: static bool
11377: PurgeProtoChain(JSContext *cx, JSObject *obj, jsid id)
    1: {
52503:     const Shape *shape;
11377: 
86437:     RootObject objRoot(cx, &obj);
86437:     RootId idRoot(cx, &id);
86437: 
11377:     while (obj) {
40430:         if (!obj->isNative()) {
39928:             obj = obj->getProto();
11377:             continue;
11377:         }
78194:         shape = obj->nativeLookup(cx, id);
52503:         if (shape) {
83221:             if (!obj->shadowingShapeChange(cx, *shape))
83221:                 return false;
79734: 
52503:             obj->shadowingShapeChange(cx, *shape);
83221:             return true;
11377:         }
32603:         obj = obj->getProto();
11377:     }
83221: 
83221:     return true;
83221: }
83221: 
83221: bool
25936: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id)
    1: {
86437:     RootObject objRoot(cx, &obj);
86437:     RootId idRoot(cx, &id);
86437: 
32603:     JS_ASSERT(obj->isDelegate());
32603:     PurgeProtoChain(cx, obj->getProto(), id);
28397: 
28397:     /*
28397:      * We must purge the scope chain only for Call objects as they are the only
28397:      * kind of cacheable non-global object that can gain properties after outer
28397:      * properties with the same names have been cached or traced. Call objects
28397:      * may gain such properties via eval introducing new vars; see bug 490364.
28397:      */
52503:     if (obj->isCall()) {
86483:         while ((obj = obj->enclosingScope()) != NULL) {
83221:             if (!PurgeProtoChain(cx, obj, id))
83221:                 return false;
83221:         }
83221:     }
83221: 
83221:     return true;
81417: }
81417: 
83297: Shape *
    1: js_AddNativeProperty(JSContext *cx, JSObject *obj, jsid id,
84755:                      PropertyOp getter, StrictPropertyOp setter, uint32_t slot,
    1:                      uintN attrs, uintN flags, intN shortid)
    1: {
52503:     JS_ASSERT(!(flags & Shape::METHOD));
32658: 
75041:     /* Convert string indices to integers if appropriate. */
75041:     id = js_CheckForStringIndex(id);
75041: 
11377:     /*
11377:      * Purge the property cache of now-shadowed id in obj's scope chain. Do
11377:      * this optimistically (assuming no failure below) before locking obj, so
11377:      * we can lock the shadowed scope.
11377:      */
83221:     if (!js_PurgeScopeChain(cx, obj, id))
56567:         return NULL;
56567: 
56567:     return obj->putProperty(cx, id, getter, setter, slot, attrs, flags, shortid);
52503: }
52503: 
83297: Shape *
    1: js_ChangeNativePropertyAttrs(JSContext *cx, JSObject *obj,
83297:                              Shape *shape, uintN attrs, uintN mask,
62395:                              PropertyOp getter, StrictPropertyOp setter)
    1: {
62790:     /*
62790:      * Check for freezing an object with shape-memoized methods here, on a
83221:      * shape-by-shape basis.
62790:      */
62790:     if ((attrs & JSPROP_READONLY) && shape->isMethod()) {
83221:         Value v = ObjectValue(*obj->nativeGetMethod(shape));
62790: 
62790:         shape = obj->methodReadBarrier(cx, *shape, &v);
62790:         if (!shape)
62790:             return NULL;
62790:     }
62790: 
56567:     return obj->changeProperty(cx, shape, attrs, mask, getter, setter);
    1: }
    1: 
    1: JSBool
48470: js_DefineProperty(JSContext *cx, JSObject *obj, jsid id, const Value *value,
62395:                   PropertyOp getter, StrictPropertyOp setter, uintN attrs)
48470: {
69855:     return !!DefineNativeProperty(cx, obj, id, *value, getter, setter, attrs, 0, 0);
    1: }
    1: 
78345: JSBool
84755: js_DefineElement(JSContext *cx, JSObject *obj, uint32_t index, const Value *value,
78345:                  PropertyOp getter, StrictPropertyOp setter, uintN attrs)
78345: {
78345:     jsid id;
78345:     if (!IndexToId(cx, index, &id))
78345:         return false;
78345:     return !!DefineNativeProperty(cx, obj, id, *value, getter, setter, attrs, 0, 0);
78345: }
78345: 
    1: /*
    1:  * Backward compatibility requires allowing addProperty hooks to mutate the
53650:  * nominal initial value of a slotful property, while GC safety wants that
    1:  * value to be stored before the call-out through the hook.  Optimize to do
    1:  * both while saving cycles for classes that stub their addProperty hook.
    1:  */
32658: static inline bool
52503: CallAddPropertyHook(JSContext *cx, Class *clasp, JSObject *obj, const Shape *shape, Value *vp)
48470: {
78614:     if (clasp->addProperty != JS_PropertyStub) {
48470:         Value nominal = *vp;
32658: 
83221:         if (!CallJSPropertyOp(cx, clasp->addProperty, obj, shape->propid(), vp))
32658:             return false;
32658:         if (*vp != nominal) {
86009:             if (shape->hasSlot())
77343:                 obj->nativeSetSlotWithType(cx, shape, *vp);
32658:         }
32658:     }
32658:     return true;
32658: }
    1: 
69855: namespace js {
69855: 
69855: const Shape *
86437: DefineNativeProperty(JSContext *cx, JSObject *obj, jsid id, const Value &value_,
62395:                      PropertyOp getter, StrictPropertyOp setter, uintN attrs,
69855:                      uintN flags, intN shortid, uintN defineHow /* = 0 */)
69855: {
77343:     JS_ASSERT((defineHow & ~(DNP_CACHE_RESULT | DNP_DONT_PURGE |
77343:                              DNP_SET_METHOD | DNP_SKIP_TYPE)) == 0);
27492: 
86437:     RootObject objRoot(cx, &obj);
86437:     RootId idRoot(cx, &id);
86437: 
86437:     /*
86437:      * Make a local copy of value, in case a method barrier needs to update the
86437:      * value to define, and just so addProperty can mutate its inout parameter.
86437:      */
86437:     RootedVarValue value(cx);
86437:     value = value_;
86437: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
    1: 
    1:     /*
    1:      * If defining a getter or setter, we must check for its counterpart and
    1:      * update the attributes and property ops.  A getter or setter is really
    1:      * only half of a property.
    1:      */
83297:     Shape *shape = NULL;
    1:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
    1:         JSObject *pobj;
    1:         JSProperty *prop;
    1: 
77343:         /* Type information for getter/setter properties is unknown. */
77353:         AddTypePropertyId(cx, obj, id, types::Type::UnknownType());
77353:         MarkTypePropertyConfigured(cx, obj, id);
77343: 
    1:         /*
69855:          * If we are defining a getter whose setter was already defined, or
69855:          * vice versa, finish the job via obj->changeProperty, and refresh the
69855:          * property cache line for (obj, id) to map shape.
    1:          */
    1:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
69855:             return NULL;
69855:         if (prop && pobj == obj) {
83297:             shape = (Shape *) prop;
69855:             if (shape->isAccessorDescriptor()) {
52503:                 shape = obj->changeProperty(cx, shape, attrs,
33152:                                             JSPROP_GETTER | JSPROP_SETTER,
    1:                                             (attrs & JSPROP_GETTER)
    1:                                             ? getter
52503:                                             : shape->getter(),
    1:                                             (attrs & JSPROP_SETTER)
    1:                                             ? setter
52503:                                             : shape->setter());
52503:                 if (!shape)
69855:                     return NULL;
69855:             } else {
52503:                 shape = NULL;
    1:             }
    1:         }
69855:     }
    1: 
11377:     /*
28397:      * Purge the property cache of any properties named by id that are about
28397:      * to be shadowed in obj's scope chain unless it is known a priori that it
28397:      * is not possible. We do this before locking obj to avoid nesting locks.
28312:      */
83221:     if (!(defineHow & DNP_DONT_PURGE)) {
83221:         if (!js_PurgeScopeChain(cx, obj, id))
83221:             return NULL;
83221:     }
11377: 
    1:     /* Use the object's class getter and setter by default. */
62034:     Class *clasp = obj->getClass();
69855:     if (!(defineHow & DNP_SET_METHOD)) {
41860:         if (!getter && !(attrs & JSPROP_GETTER))
    1:             getter = clasp->getProperty;
41860:         if (!setter && !(attrs & JSPROP_SETTER))
    1:             setter = clasp->setProperty;
32658:     }
    1: 
78614:     if (((defineHow & DNP_SET_METHOD) || getter == JS_PropertyStub) &&
77343:         !(defineHow & DNP_SKIP_TYPE)) {
77343:         /*
77343:          * Type information for normal native properties should reflect the
77343:          * initial value of the property.
77343:          */
77353:         AddTypePropertyId(cx, obj, id, value);
77343:         if (attrs & JSPROP_READONLY)
77353:             MarkTypePropertyConfigured(cx, obj, id);
77343:     }
77343: 
52503:     if (!shape) {
18750:         /* Add a new property, or replace an existing one of the same id. */
69855:         if (defineHow & DNP_SET_METHOD) {
77817:             JS_ASSERT(clasp == &ObjectClass);
48470:             JS_ASSERT(IsFunctionObject(value));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658:             JS_ASSERT(!getter && !setter);
32658: 
86437:             JSObject *funobj = &value.raw().toObject();
83234:             if (!funobj->toFunction()->isClonedMethod())
52503:                 flags |= Shape::METHOD;
32658:         }
32658: 
78194:         if (const Shape *existingShape = obj->nativeLookup(cx, id)) {
62790:             if (existingShape->isMethod() &&
86437:                 ObjectValue(*obj->nativeGetMethod(existingShape)) == value)
62790:             {
62790:                 /*
62790:                  * Redefining an existing shape-memoized method object without
62790:                  * changing the property's value, perhaps to change attributes.
62790:                  * Clone now via the method read barrier.
83221:                  */
86437:                 if (!obj->methodReadBarrier(cx, *existingShape, value.address()))
69855:                     return NULL;
62790:             }
62034:         }
62034: 
52503:         shape = obj->putProperty(cx, id, getter, setter, SHAPE_INVALID_SLOT,
35334:                                  attrs, flags, shortid);
52503:         if (!shape)
69855:             return NULL;
14646:     }
    1: 
62790:     /* Store valueCopy before calling addProperty, in case the latter GC's. */
86009:     if (shape->hasSlot())
86437:         obj->nativeSetSlot(shape->slot(), value);
    1: 
86437:     if (!CallAddPropertyHook(cx, clasp, obj, shape, value.address())) {
52503:         obj->removeProperty(cx, id);
69855:         return NULL;
69855:     }
69855: 
69855:     return shape;
69855: }
69855: 
69855: } /* namespace js */
10217: 
    1: /*
64217:  * Call obj's resolve hook.
43260:  *
43260:  * cx, start, id, and flags are the parameters initially passed to the ongoing
43260:  * lookup; objp and propp are its out parameters. obj is an object along
43260:  * start's prototype chain.
43260:  *
43260:  * There are four possible outcomes:
43260:  *
64217:  *   - On failure, report an error or exception and return false.
43260:  *
64217:  *   - If we are already resolving a property of *curobjp, set *recursedp = true,
64217:  *     and return true.
43260:  *
43260:  *   - If the resolve hook finds or defines the sought property, set *objp and
64217:  *     *propp appropriately, set *recursedp = false, and return true.
43260:  *
43260:  *   - Otherwise no property was resolved. Set *propp = NULL and *recursedp = false
43260:  *     and return true.
43260:  */
43260: static JSBool
86437: CallResolveOp(JSContext *cx, JSObject *start, HandleObject obj, HandleId id, uintN flags,
43260:               JSObject **objp, JSProperty **propp, bool *recursedp)
43260: {
48470:     Class *clasp = obj->getClass();
43260:     JSResolveOp resolve = clasp->resolve;
43260: 
43260:     /*
43260:      * Avoid recursion on (obj, id) already being resolved on cx.
43260:      *
    1:      * Once we have successfully added an entry for (obj, key) to
    1:      * cx->resolvingTable, control must go through cleanup: before
    1:      * returning.  But note that JS_DHASH_ADD may find an existing
    1:      * entry, in which case we bail to suppress runaway recursion.
    1:      */
64302:     AutoResolving resolving(cx, obj, id);
64302:     if (resolving.alreadyStarted()) {
    1:         /* Already resolving id in obj -- suppress recursion. */
43260:         *recursedp = true;
43260:         return true;
43260:     }
43260:     *recursedp = false;
43260: 
    1:     *propp = NULL;
    1: 
    1:     if (clasp->flags & JSCLASS_NEW_RESOLVE) {
64217:         JSNewResolveOp newresolve = reinterpret_cast<JSNewResolveOp>(resolve);
69855:         if (flags == RESOLVE_INFER)
52503:             flags = js_InferFlags(cx, 0);
86437: 
86437:         RootedVarObject obj2(cx);
86437:         obj2 = (clasp->flags & JSCLASS_NEW_RESOLVE_GETS_START) ? start : NULL;
86437:         if (!newresolve(cx, obj, id, flags, obj2.address()))
64302:             return false;
    1: 
64217:         /*
64217:          * We trust the new style resolve hook to set obj2 to NULL when
64217:          * the id cannot be resolved. But, when obj2 is not null, we do
64217:          * not assume that id must exist and do full nativeLookup for
64217:          * compatibility.
64217:          */
64217:         if (!obj2)
64302:             return true;
64217: 
40430:         if (!obj2->isNative()) {
    1:             /* Whoops, newresolve handed back a foreign obj2. */
    1:             JS_ASSERT(obj2 != obj);
80442:             return obj2->lookupGeneric(cx, id, objp, propp);
64217:         }
64217:         obj = obj2;
    1:     } else {
64302:         if (!resolve(cx, obj, id))
64302:             return false;
64217:     }
64217: 
64217:     if (!obj->nativeEmpty()) {
78194:         if (const Shape *shape = obj->nativeLookup(cx, id)) {
43260:             *objp = obj;
52503:             *propp = (JSProperty *) shape;
43260:         }
64217:     }
64217: 
64302:     return true;
43260: }
43260: 
69855: static JS_ALWAYS_INLINE bool
69855: LookupPropertyWithFlagsInline(JSContext *cx, JSObject *obj, jsid id, uintN flags,
43260:                               JSObject **objp, JSProperty **propp)
43260: {
56740:     /* We should not get string indices which aren't already integers here. */
56740:     JS_ASSERT(id == js_CheckForStringIndex(id));
43260: 
86437:     RootObject objRoot(cx, &obj);
86437:     RootId idRoot(cx, &id);
86437: 
43260:     /* Search scopes starting with obj and following the prototype link. */
43260:     JSObject *start = obj;
72559:     while (true) {
78194:         const Shape *shape = obj->nativeLookup(cx, id);
52503:         if (shape) {
30645:             *objp = obj;
52503:             *propp = (JSProperty *) shape;
69855:             return true;
    1:         }
    1: 
43260:         /* Try obj's class resolve hook if id was not found in obj's scope. */
69855:         if (obj->getClass()->resolve != JS_ResolveStub) {
43260:             bool recursed;
86437:             if (!CallResolveOp(cx, start, objRoot, idRoot, flags, objp, propp, &recursed))
69855:                 return false;
43260:             if (recursed)
43260:                 break;
43260:             if (*propp) {
69855:                 /*
69855:                  * For stats we do not recalculate protoIndex even if it was
69855:                  * resolved on some other object.
69855:                  */
69855:                 return true;
43260:             }
43260:         }
43260: 
43260:         JSObject *proto = obj->getProto();
    1:         if (!proto)
    1:             break;
40430:         if (!proto->isNative()) {
80442:             if (!proto->lookupGeneric(cx, id, objp, propp))
69855:                 return false;
60172: #ifdef DEBUG
60172:             /*
60172:              * Non-native objects must have either non-native lookup results,
60172:              * or else native results from the non-native's prototype chain.
60172:              *
69223:              * See StackFrame::getValidCalleeObject, where we depend on this
60172:              * fact to force a prototype-delegated joined method accessed via
60172:              * arguments.callee through the delegating |this| object's method
60172:              * read barrier.
60172:              */
60172:             if (*propp && (*objp)->isNative()) {
60172:                 while ((proto = proto->getProto()) != *objp)
60172:                     JS_ASSERT(proto);
60172:             }
60172: #endif
69855:             return true;
10217:         }
30645: 
    1:         obj = proto;
    1:     }
    1: 
    1:     *objp = NULL;
    1:     *propp = NULL;
69855:     return true;
10217: }
10217: 
56740: JS_FRIEND_API(JSBool)
56740: js_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
56740:                   JSProperty **propp)
56740: {
56740:     /* Convert string indices to integers if appropriate. */
56740:     id = js_CheckForStringIndex(id);
56740: 
69855:     return LookupPropertyWithFlagsInline(cx, obj, id, cx->resolveFlags, objp, propp);
69855: }
69855: 
78330: JS_FRIEND_API(JSBool)
84755: js_LookupElement(JSContext *cx, JSObject *obj, uint32_t index, JSObject **objp, JSProperty **propp)
78330: {
78330:     jsid id;
78330:     if (!IndexToId(cx, index, &id))
78330:         return false;
78330: 
78330:     return LookupPropertyWithFlagsInline(cx, obj, id, cx->resolveFlags, objp, propp);
78330: }
78330: 
69855: bool
86542: js::LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
55535:                             JSObject **objp, JSProperty **propp)
55535: {
56740:     /* Convert string indices to integers if appropriate. */
56740:     id = js_CheckForStringIndex(id);
56740: 
69855:     return LookupPropertyWithFlagsInline(cx, obj, id, flags, objp, propp);
69855: }
69855: 
86855: bool
87657: js::FindPropertyHelper(JSContext *cx, PropertyName *name, bool cacheResult, JSObject *scopeChain,
27575:                        JSObject **objp, JSObject **pobjp, JSProperty **propp)
    1: {
86542:     jsid id = ATOM_TO_JSID(name);
87657:     JSObject *obj, *parent, *pobj;
69855:     int scopeIndex;
    1:     JSProperty *prop;
27575: 
27539:     /* Scan entries on the scope chain that we can cache across. */
27539:     obj = scopeChain;
86483:     parent = obj->enclosingScope();
27539:     for (scopeIndex = 0;
27539:          parent
63085:          ? IsCacheableNonGlobalScope(obj)
48622:          : !obj->getOps()->lookupProperty;
27539:          ++scopeIndex) {
69855:         if (!LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags, &pobj, &prop))
86855:             return false;
27539: 
27539:         if (prop) {
27539: #ifdef DEBUG
27539:             if (parent) {
40430:                 JS_ASSERT(pobj->isNative());
77817:                 JS_ASSERT(pobj->getClass() == obj->getClass());
77817:                 if (obj->isBlock()) {
27539:                     /*
69855:                      * A block instance on the scope chain is immutable and
69855:                      * shares its shape with the compile-time prototype. Thus
69855:                      * we cannot find any property on the prototype.
27539:                      */
53650:                     JS_ASSERT(pobj->isClonedBlock());
11377:                 } else {
27539:                     /* Call and DeclEnvClass objects have no prototypes. */
39928:                     JS_ASSERT(!obj->getProto());
69855:                 }
69855:                 JS_ASSERT(pobj == obj);
42726:             } else {
42726:                 JS_ASSERT(obj->isNative());
27539:             }
27539: #endif
86855: 
42726:             /*
42726:              * We must check if pobj is native as a global object can have
42726:              * non-native prototype.
42726:              */
42726:             if (cacheResult && pobj->isNative()) {
86855:                 JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, pobj,
52503:                                            (Shape *) prop);
27539:             }
86855: 
27539:             goto out;
27539:         }
27539: 
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             goto out;
27539:         }
27539:         obj = parent;
86483:         parent = obj->enclosingScope();
27539:     }
27539: 
27539:     for (;;) {
80442:         if (!obj->lookupGeneric(cx, id, &pobj, &prop))
86855:             return false;
86855:         if (prop)
27539:             goto out;
27539: 
27539:         /*
27539:          * We conservatively assume that a resolve hook could mutate the scope
80442:          * chain during JSObject::lookupGeneric. So we read parent here again.
27539:          */
86483:         parent = obj->enclosingScope();
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             break;
27539:         }
27539:         obj = parent;
27539:     }
27539: 
27539:   out:
27539:     JS_ASSERT(!!pobj == !!prop);
    1:     *objp = obj;
    1:     *pobjp = pobj;
    1:     *propp = prop;
86855:     return true;
    1: }
    1: 
57125: /*
57125:  * On return, if |*pobjp| is a native object, then |*propp| is a |Shape *|.
57125:  * Otherwise, its type and meaning depends on the host object's implementation.
57125:  */
86542: bool
87657: js::FindProperty(JSContext *cx, PropertyName *name, JSObject *scopeChain,
77343:                  JSObject **objp, JSObject **pobjp, JSProperty **propp)
77343: {
87657:     return !!FindPropertyHelper(cx, name, false, scopeChain, objp, pobjp, propp);
    1: }
    1: 
27319: JSObject *
86542: js::FindIdentifierBase(JSContext *cx, JSObject *scopeChain, PropertyName *name)
    1: {
27237:     /*
27237:      * This function should not be called for a global object or from the
27237:      * trace and should have a valid cache entry for native scopeChain.
27237:      */
86483:     JS_ASSERT(scopeChain->enclosingScope() != NULL);
27237: 
27319:     JSObject *obj = scopeChain;
27319: 
27237:     /*
27319:      * Loop over cacheable objects on the scope chain until we find a
27319:      * property. We also stop when we reach the global object skipping any
27319:      * farther checks or lookups. For details see the JSOP_BINDNAME case of
27319:      * js_Interpret.
41775:      *
63085:      * The test order here matters because IsCacheableNonGlobalScope
41775:      * must not be passed a global object (i.e. one with null parent).
27237:      */
41775:     for (int scopeIndex = 0;
83239:          obj->isGlobal() || IsCacheableNonGlobalScope(obj);
41775:          scopeIndex++) {
27237:         JSObject *pobj;
27236:         JSProperty *prop;
86542:         if (!LookupPropertyWithFlags(cx, obj, name, cx->resolveFlags, &pobj, &prop))
27237:             return NULL;
27237:         if (prop) {
42726:             if (!pobj->isNative()) {
83239:                 JS_ASSERT(obj->isGlobal());
42726:                 return obj;
42726:             }
86483:             JS_ASSERT_IF(obj->isScope(), pobj->getClass() == obj->getClass());
69855:             JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, pobj, (Shape *) prop);
27237:             return obj;
27237:         }
27237: 
86483:         JSObject *parent = obj->enclosingScope();
41775:         if (!parent)
27237:             return obj;
41775:         obj = parent;
27237:     }
27319: 
27319:     /* Loop until we find a property or reach the global object. */
27237:     do {
27237:         JSObject *pobj;
27237:         JSProperty *prop;
86542:         if (!obj->lookupProperty(cx, name, &pobj, &prop))
    1:             return NULL;
56567:         if (prop)
27237:             break;
27319: 
27319:         /*
27319:          * We conservatively assume that a resolve hook could mutate the scope
80442:          * chain during JSObject::lookupGeneric. So we must check if parent is
31501:          * not null here even if it wasn't before the lookup.
27319:          */
86483:         JSObject *parent = obj->enclosingScope();
27319:         if (!parent)
27319:             break;
27237:         obj = parent;
83257:     } while (!obj->isGlobal());
    1:     return obj;
    1: }
    1: 
55535: static JS_ALWAYS_INLINE JSBool
57739: js_NativeGetInline(JSContext *cx, JSObject *receiver, JSObject *obj, JSObject *pobj,
57739:                    const Shape *shape, uintN getHow, Value *vp)
    1: {
40430:     JS_ASSERT(pobj->isNative());
52503: 
83221:     if (shape->hasSlot()) {
83221:         *vp = pobj->nativeGetSlot(shape->slot());
55746:         JS_ASSERT(!vp->isMagic());
78457:         JS_ASSERT_IF(!pobj->hasSingletonType() && shape->hasDefaultGetterOrIsMethod(),
83221:                      js::types::TypeHasProperty(cx, pobj->type(), shape->propid(), *vp));
55746:     } else {
48470:         vp->setUndefined();
55746:     }
52503:     if (shape->hasDefaultGetter())
32658:         return true;
32658: 
83221:     if (JS_UNLIKELY(shape->isMethod()) && (getHow & JSGET_NO_METHOD_BARRIER))
32658:         return true;
27490: 
78454:     jsbytecode *pc;
78454:     JSScript *script = cx->stack.currentScript(&pc);
82642:     if (script && script->hasAnalysis()) {
78454:         analyze::Bytecode *code = script->analysis()->maybeCode(pc);
78454:         if (code)
78454:             code->accessGetter = true;
78454:     }
78454: 
57739:     if (!shape->get(cx, receiver, obj, pobj, vp))
32658:         return false;
52503: 
83221:     /* Update slotful shapes according to the value produced by the getter. */
83221:     if (shape->hasSlot() && pobj->nativeContains(cx, *shape)) {
83221:         /* Method shapes were removed by methodReadBarrier under shape->get(). */
83221:         JS_ASSERT(!shape->isMethod());
83221:         pobj->nativeSetSlot(shape->slot(), *vp);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
    1: JSBool
55535: js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj, const Shape *shape, uintN getHow,
55535:              Value *vp)
55535: {
57739:     return js_NativeGetInline(cx, obj, obj, pobj, shape, getHow, vp);
55535: }
55535: 
55535: JSBool
62395: js_NativeSet(JSContext *cx, JSObject *obj, const Shape *shape, bool added, bool strict, Value *vp)
    1: {
83221:     AddTypePropertyId(cx, obj, shape->propid(), *vp);
27490: 
40430:     JS_ASSERT(obj->isNative());
52503: 
83221:     if (shape->hasSlot()) {
84755:         uint32_t slot = shape->slot();
27490: 
83221:         /* If shape has a stub setter, just store *vp. */
52503:         if (shape->hasDefaultSetter()) {
62034:             if (!added) {
83221:                 if (shape->isMethod() && !obj->methodShapeChange(cx, *shape))
32658:                     return false;
62034:             }
56567:             obj->nativeSetSlot(slot, *vp);
32658:             return true;
32658:         }
27490:     } else {
    1:         /*
    1:          * Allow API consumers to create shared properties with stub setters.
36491:          * Such properties effectively function as data descriptors which are
36491:          * not writable, so attempting to set such a property should do nothing
36491:          * or throw if we're in strict mode.
    1:          */
52503:         if (!shape->hasGetterValue() && shape->hasDefaultSetter())
36491:             return js_ReportGetterOnlyAssignment(cx);
    1:     }
27490: 
84755:     int32_t sample = cx->runtime->propertyRemovals;
62395:     if (!shape->set(cx, obj, strict, vp))
32658:         return false;
60552: 
83221:     /*
83221:      * Update any slot for the shape with the value produced by the setter,
83221:      * unless the setter deleted the shape.
83221:      */
83221:     if (shape->hasSlot() &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
78194:          obj->nativeContains(cx, *shape))) {
83221:         obj->setSlot(shape->slot(), *vp);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
74260: static JS_ALWAYS_INLINE JSBool
74260: js_GetPropertyHelperInline(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id,
84755:                            uint32_t getHow, Value *vp)
    1: {
87822:     JSObject *aobj, *obj2;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
87822:     aobj = js_GetProtoIfDenseArray(obj);
69855:     /* This call site is hot -- use the always-inlined variant of LookupPropertyWithFlags(). */
87822:     if (!LookupPropertyWithFlagsInline(cx, aobj, id, cx->resolveFlags, &obj2, &prop))
69855:         return false;
54172: 
    1:     if (!prop) {
48470:         vp->setUndefined();
48470: 
52503:         if (!CallJSPropertyOp(cx, obj->getClass()->getProperty, obj, id, vp))
    1:             return JS_FALSE;
    1: 
77343:         /* Record non-undefined values produced by the class getter hook. */
77343:         if (!vp->isUndefined())
77353:             AddTypePropertyId(cx, obj, id, *vp);
77343: 
    1:         /*
    1:          * Give a strict warning if foo.bar is evaluated by a script for an
    1:          * object foo with no property named 'bar'.
    1:          */
24598:         jsbytecode *pc;
48470:         if (vp->isUndefined() && ((pc = js_GetCurrentBytecodePC(cx)) != NULL)) {
84346:             JSOp op = (JSOp) *pc;
84346: 
    1:             if (op == JSOP_GETXPROP) {
84346:                 /* Undefined property during a name lookup, report an error. */
84346:                 JSAutoByteString printable;
84346:                 if (js_ValueToPrintable(cx, IdToValue(id), &printable))
84346:                     js_ReportIsNotDefined(cx, printable.ptr());
84346:                 return false;
84346:             }
84346: 
61450:             if (!cx->hasStrictOption() ||
77343:                 cx->stack.currentScript()->warnedAboutUndefinedProp ||
82642:                 (op != JSOP_GETPROP && op != JSOP_GETELEM)) {
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             /*
    1:              * XXX do not warn about missing __iterator__ as the function
    1:              * may be called from JS_GetMethodById. See bug 355145.
    1:              */
48470:             if (JSID_IS_ATOM(id, cx->runtime->atomState.iteratorAtom))
    1:                 return JS_TRUE;
    1: 
25213:             /* Do not warn about tests like (obj[prop] == undefined). */
69855:             if (cx->resolveFlags == RESOLVE_INFER) {
    1:                 pc += js_CodeSpec[op].length;
    1:                 if (Detecting(cx, pc))
    1:                     return JS_TRUE;
25213:             } else if (cx->resolveFlags & JSRESOLVE_DETECTING) {
25213:                 return JS_TRUE;
25213:             }
    1: 
84346:             uintN flags = JSREPORT_WARNING | JSREPORT_STRICT;
77343:             cx->stack.currentScript()->warnedAboutUndefinedProp = true;
    1: 
    1:             /* Ok, bad undefined property reference: whine about it. */
    1:             if (!js_ReportValueErrorFlags(cx, flags, JSMSG_UNDEFINED_PROP,
48470:                                           JSDVG_IGNORE_STACK, IdToValue(id),
84346:                                           NULL, NULL, NULL))
84346:             {
84346:                 return false;
    1:             }
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
56817:     if (!obj2->isNative()) {
56817:         return obj2->isProxy()
79386:                ? Proxy::get(cx, obj2, receiver, id, vp)
78675:                : obj2->getGeneric(cx, id, vp);
56817:     }
    1: 
52503:     shape = (Shape *) prop;
27490: 
82645:     if (getHow & JSGET_CACHE_RESULT)
87822:         JS_PROPERTY_CACHE(cx).fill(cx, aobj, 0, obj2, shape);
52503: 
55535:     /* This call site is hot -- use the always-inlined variant of js_NativeGet(). */
57739:     if (!js_NativeGetInline(cx, receiver, obj, obj2, shape, getHow, vp))
27932:         return JS_FALSE;
27932: 
27490:     return JS_TRUE;
    1: }
    1: 
86542: bool
86542: js::GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uint32_t getHow, Value *vp)
86542: {
86542:     return !!js_GetPropertyHelperInline(cx, obj, obj, id, getHow, vp);
56757: }
56757: 
56757: JSBool
56817: js_GetProperty(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp)
    1: {
55535:     /* This call site is hot -- use the always-inlined variant of js_GetPropertyHelper(). */
56817:     return js_GetPropertyHelperInline(cx, obj, receiver, id, JSGET_METHOD_BARRIER, vp);
11377: }
11377: 
11377: JSBool
84755: js_GetElement(JSContext *cx, JSObject *obj, JSObject *receiver, uint32_t index, Value *vp)
78341: {
78341:     jsid id;
78341:     if (!IndexToId(cx, index, &id))
78341:         return false;
78341: 
78341:     /* This call site is hot -- use the always-inlined variant of js_GetPropertyHelper(). */
78341:     return js_GetPropertyHelperInline(cx, obj, receiver, id, JSGET_METHOD_BARRIER, vp);
78341: }
78341: 
78341: JSBool
57734: js::GetPropertyDefault(JSContext *cx, JSObject *obj, jsid id, const Value &def, Value *vp)
56211: {
56211:     JSProperty *prop;
56211:     JSObject *obj2;
69855:     if (!LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop))
56211:         return false;
56211: 
56211:     if (!prop) {
56211:         *vp = def;
56211:         return true;
56211:     }
56211: 
56211:     return js_GetProperty(cx, obj2, id, vp);
56211: }
56211: 
56211: JSBool
48470: js_GetMethod(JSContext *cx, JSObject *obj, jsid id, uintN getHow, Value *vp)
26187: {
29913:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
29913: 
78675:     GenericIdOp op = obj->getOps()->getGeneric;
48622:     if (!op) {
48622: #if JS_HAS_XML_SUPPORT
48622:         JS_ASSERT(!obj->isXML());
48622: #endif
86542:         return GetPropertyHelper(cx, obj, id, getHow, vp);
32658:     }
26187: #if JS_HAS_XML_SUPPORT
42693:     if (obj->isXML())
26187:         return js_GetXMLMethod(cx, obj, id, vp);
26187: #endif
56817:     return op(cx, obj, obj, id, vp);
26187: }
26187: 
35308: JS_FRIEND_API(bool)
79734: js::CheckUndeclaredVarAssignment(JSContext *cx, JSString *propname)
27372: {
77398:     StackFrame *const fp = js_GetTopStackFrame(cx, FRAME_EXPAND_ALL);
35308:     if (!fp)
35308:         return true;
35308: 
35308:     /* If neither cx nor the code is strict, then no check is needed. */
53840:     if (!(fp->isScriptFrame() && fp->script()->strictModeCode) &&
61450:         !cx->hasStrictOption()) {
35308:         return true;
35308:     }
35308: 
57812:     JSAutoByteString bytes(cx, propname);
57812:     return !!bytes &&
35308:            JS_ReportErrorFlagsAndNumber(cx,
35308:                                         (JSREPORT_WARNING | JSREPORT_STRICT
35308:                                          | JSREPORT_STRICT_MODE_ERROR),
27372:                                         js_GetErrorMessage, NULL,
57812:                                         JSMSG_UNDECLARED_VAR, bytes.ptr());
27372: }
27372: 
54587: bool
54587: JSObject::reportReadOnly(JSContext *cx, jsid id, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_READ_ONLY,
48470:                                     JSDVG_IGNORE_STACK, IdToValue(id), NULL,
40832:                                     NULL, NULL);
40832: }
40832: 
54587: bool
54587: JSObject::reportNotConfigurable(JSContext *cx, jsid id, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_CANT_DELETE,
54169:                                     JSDVG_IGNORE_STACK, IdToValue(id), NULL,
54169:                                     NULL, NULL);
54169: }
54169: 
54587: bool
54587: JSObject::reportNotExtensible(JSContext *cx, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_OBJECT_NOT_EXTENSIBLE,
54587:                                     JSDVG_IGNORE_STACK, ObjectValue(*this),
54587:                                     NULL, NULL, NULL);
40832: }
40832: 
67921: bool
67921: JSObject::callMethod(JSContext *cx, jsid id, uintN argc, Value *argv, Value *vp)
67921: {
67921:     Value fval;
67921:     return js_GetMethod(cx, this, id, JSGET_NO_METHOD_BARRIER, &fval) &&
76829:            Invoke(cx, ObjectValue(*this), fval, argc, argv, vp);
67921: }
67921: 
77343: static bool
77343: CloneFunctionForSetMethod(JSContext *cx, Value *vp)
77343: {
83234:     JSFunction *fun = vp->toObject().toFunction();
83234: 
83234:     /* Clone the fun unless it already has been. */
83234:     if (!fun->isClonedMethod()) {
83234:         fun = CloneFunctionObject(cx, fun);
83234:         if (!fun)
83234:             return false;
83234:         vp->setObject(*fun);
77343:     }
77343:     return true;
77343: }
77343: 
27932: JSBool
56760: js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN defineHow,
54169:                      Value *vp, JSBool strict)
11377: {
    1:     JSObject *pobj;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1:     uintN attrs, flags;
    1:     intN shortid;
48470:     Class *clasp;
62395:     PropertyOp getter;
62395:     StrictPropertyOp setter;
27930:     bool added;
    1: 
69855:     JS_ASSERT((defineHow & ~(DNP_CACHE_RESULT | DNP_SET_METHOD | DNP_UNQUALIFIED)) == 0);
28398: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
74472:     if (JS_UNLIKELY(obj->watched())) {
74472:         /* Fire watchpoints, if any. */
74472:         WatchpointMap *wpmap = cx->compartment->watchpointMap;
74472:         if (wpmap && !wpmap->triggerWatchpoint(cx, obj, id, vp))
74472:             return false;
74472: 
74472:         /* A watchpoint handler may set *vp to a non-function value. */
74472:         defineHow &= ~DNP_SET_METHOD;
74472:     }
74472: 
69855:     if (!LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags, &pobj, &prop))
69855:         return false;
27237:     if (prop) {
56817:         if (!pobj->isNative()) {
56817:             if (pobj->isProxy()) {
56817:                 AutoPropertyDescriptorRooter pd(cx);
79386:                 if (!Proxy::getPropertyDescriptor(cx, pobj, id, true, &pd))
56817:                     return false;
56817: 
63289:                 if ((pd.attrs & (JSPROP_SHARED | JSPROP_SHADOWABLE)) == JSPROP_SHARED) {
63289:                     return !pd.setter ||
63289:                            CallSetter(cx, obj, id, pd.setter, pd.attrs, pd.shortid, strict, vp);
63289:                 }
56817: 
56817:                 if (pd.attrs & JSPROP_READONLY) {
56817:                     if (strict)
56817:                         return obj->reportReadOnly(cx, id);
61450:                     if (cx->hasStrictOption())
56817:                         return obj->reportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
56817:                     return true;
56817:                 }
56817:             }
56817: 
    1:             prop = NULL;
56817:         }
27237:     } else {
27237:         /* We should never add properties to lexical blocks.  */
53650:         JS_ASSERT(!obj->isBlock());
27237: 
83254:         if (obj->isGlobal() &&
69855:             (defineHow & DNP_UNQUALIFIED) &&
79734:             !js::CheckUndeclaredVarAssignment(cx, JSID_TO_STRING(id))) {
41774:             return JS_FALSE;
41774:         }
27237:     }
52503:     shape = (Shape *) prop;
    1: 
    1:     /*
52503:      * Now either shape is null, meaning id was not found in obj or one of its
52503:      * prototypes; or shape is non-null, meaning id was found directly in pobj.
    1:      */
    1:     attrs = JSPROP_ENUMERATE;
    1:     flags = 0;
    1:     shortid = 0;
40826:     clasp = obj->getClass();
    1:     getter = clasp->getProperty;
    1:     setter = clasp->setProperty;
    1: 
52503:     if (shape) {
40832:         /* ES5 8.12.4 [[Put]] step 2. */
52503:         if (shape->isAccessorDescriptor()) {
60780:             if (shape->hasDefaultSetter())
40832:                 return js_ReportGetterOnlyAssignment(cx);
40832:         } else {
52503:             JS_ASSERT(shape->isDataDescriptor());
52503: 
52503:             if (!shape->writable()) {
54169:                 /* Error in strict mode code, warn with strict option, otherwise do nothing. */
54169:                 if (strict)
54587:                     return obj->reportReadOnly(cx, id);
61450:                 if (cx->hasStrictOption())
54587:                     return obj->reportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
27932:                 return JS_TRUE;
    1:             }
40832:         }
    1: 
52503:         attrs = shape->attributes();
56760:         if (pobj != obj) {
    1:             /*
    1:              * We found id in a prototype object: prepare to share or shadow.
    1:              */
59898:             if (!shape->shadowable()) {
77343:                 if (defineHow & DNP_SET_METHOD) {
77343:                     JS_ASSERT(!shape->isMethod());
77343:                     if (!CloneFunctionForSetMethod(cx, vp))
77343:                         return false;
77343:                 }
77343: 
69855:                 if (defineHow & DNP_CACHE_RESULT)
69855:                     JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, pobj, shape);
52503: 
52503:                 if (shape->hasDefaultSetter() && !shape->hasGetterValue())
27932:                     return JS_TRUE;
27932: 
62395:                 return shape->set(cx, obj, strict, vp);
    1:             }
    1: 
    1:             /*
59898:              * Preserve attrs except JSPROP_SHARED, getter, and setter when
59898:              * shadowing any property that has no slot (is shared). We must
59898:              * clear the shared attribute for the shadowing shape so that the
59898:              * property in obj that it defines has a slot to retain the value
59898:              * being set, in case the setter simply cannot operate on instances
59898:              * of obj's class by storing the value in some class-specific
59898:              * location.
59898:              *
59898:              * A subset of slotless shared properties is the set of properties
59898:              * with shortids, which must be preserved too. An old API requires
59898:              * that the property's getter and setter receive the shortid, not
59898:              * id, when they are called on the shadowing property that we are
52503:              * about to create in obj.
    1:              */
59898:             if (!shape->hasSlot()) {
69855:                 defineHow &= ~DNP_SET_METHOD;
52503:                 if (shape->hasShortID()) {
52503:                     flags = Shape::HAS_SHORTID;
83221:                     shortid = shape->shortid();
59898:                 }
59898:                 attrs &= ~JSPROP_SHARED;
52503:                 getter = shape->getter();
52503:                 setter = shape->setter();
59898:             } else {
59898:                 /* Restore attrs to the ECMA default for new properties. */
59898:                 attrs = JSPROP_ENUMERATE;
    1:             }
    1: 
    1:             /*
    1:              * Forget we found the proto-property now that we've copied any
    1:              * needed member values.
    1:              */
52503:             shape = NULL;
52503:         }
53577: 
69855:         if (shape && (defineHow & DNP_SET_METHOD)) {
59009:             /*
59009:              * JSOP_SETMETHOD is assigning to an existing own property. If it
59009:              * is an identical method property, do nothing. Otherwise downgrade
59009:              * to ordinary assignment. Either way, do not fill the property
59009:              * cache, as the interpreter has no fast path for these unusual
59009:              * cases.
59009:              */
83261:             if (shape->isMethod()) {
83261:                 if (obj->nativeGetMethod(shape) == &vp->toObject())
83221:                     return true;
60797:                 shape = obj->methodShapeChange(cx, *shape);
60797:                 if (!shape)
59009:                     return false;
83261:             }
77343:             if (!CloneFunctionForSetMethod(cx, vp))
77343:                 return false;
83221:             return js_NativeSet(cx, obj, shape, false, strict, vp);
53577:         }
    1:     }
    1: 
27930:     added = false;
52503:     if (!shape) {
54563:         if (!obj->isExtensible()) {
54563:             /* Error in strict mode code, warn with strict option, otherwise do nothing. */
54563:             if (strict)
54587:                 return obj->reportNotExtensible(cx);
61450:             if (cx->hasStrictOption())
54587:                 return obj->reportNotExtensible(cx, JSREPORT_STRICT | JSREPORT_WARNING);
54563:             return JS_TRUE;
54563:         }
54563: 
11377:         /*
11377:          * Purge the property cache of now-shadowed id in obj's scope chain.
11377:          * Do this early, before locking obj to avoid nesting locks.
11377:          */
83221:         if (!js_PurgeScopeChain(cx, obj, id))
27932:             return JS_FALSE;
32658: 
32658:         /*
32658:          * Check for Object class here to avoid defining a method on a class
32658:          * with magic resolve, addProperty, getProperty, etc. hooks.
32658:          */
69855:         if ((defineHow & DNP_SET_METHOD) && obj->canHaveMethodBarrier()) {
48470:             JS_ASSERT(IsFunctionObject(*vp));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658: 
48470:             JSObject *funobj = &vp->toObject();
83234:             if (!funobj->toFunction()->isClonedMethod())
52503:                 flags |= Shape::METHOD;
32658:         }
32658: 
52503:         shape = obj->putProperty(cx, id, getter, setter, SHAPE_INVALID_SLOT,
35334:                                  attrs, flags, shortid);
56567:         if (!shape)
27932:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Initialize the new property value (passed to setter) to undefined.
    1:          * Note that we store before calling addProperty, to match the order
69855:          * in DefineNativeProperty.
    1:          */
86009:         if (shape->hasSlot())
83221:             obj->nativeSetSlot(shape->slot(), UndefinedValue());
    1: 
    1:         /* XXXbe called with obj locked */
52503:         if (!CallAddPropertyHook(cx, clasp, obj, shape, vp)) {
52503:             obj->removeProperty(cx, id);
32658:             return JS_FALSE;
32658:         }
27930:         added = true;
    1:     }
    1: 
83221:     if ((defineHow & DNP_CACHE_RESULT) && !added)
83221:         JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, obj, shape);
60780: 
62395:     return js_NativeSet(cx, obj, shape, added, strict, vp);
    1: }
    1: 
    1: JSBool
84755: js_SetElementHelper(JSContext *cx, JSObject *obj, uint32_t index, uintN defineHow,
78346:                     Value *vp, JSBool strict)
78346: {
78346:     jsid id;
78346:     if (!IndexToId(cx, index, &id))
78346:         return false;
78346:     return js_SetPropertyHelper(cx, obj, id, defineHow, vp, strict);
78346: }
78346: 
78346: JSBool
43290: js_GetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
43290: {
43290:     JSProperty *prop;
    1:     if (!js_LookupProperty(cx, obj, id, &obj, &prop))
43290:         return false;
    1:     if (!prop) {
    1:         *attrsp = 0;
43290:         return true;
43290:     }
43290:     if (!obj->isNative())
80622:         return obj->getGenericAttributes(cx, id, attrsp);
43290: 
52503:     const Shape *shape = (Shape *)prop;
52503:     *attrsp = shape->attributes();
43290:     return true;
    1: }
    1: 
    1: JSBool
84755: js_GetElementAttributes(JSContext *cx, JSObject *obj, uint32_t index, uintN *attrsp)
78342: {
78342:     JSProperty *prop;
78342:     if (!js_LookupElement(cx, obj, index, &obj, &prop))
78342:         return false;
78342:     if (!prop) {
78342:         *attrsp = 0;
78342:         return true;
78342:     }
78342:     if (!obj->isNative())
78342:         return obj->getElementAttributes(cx, index, attrsp);
78342: 
78342:     const Shape *shape = (Shape *)prop;
78342:     *attrsp = shape->attributes();
78342:     return true;
78342: }
78342: 
78342: JSBool
52503: js_SetNativeAttributes(JSContext *cx, JSObject *obj, Shape *shape, uintN attrs)
43290: {
43290:     JS_ASSERT(obj->isNative());
56567:     return !!js_ChangeNativePropertyAttrs(cx, obj, shape, attrs, 0,
52503:                                           shape->getter(), shape->setter());
43290: }
43290: 
43290: JSBool
43290: js_SetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
43290: {
43290:     JSProperty *prop;
    1:     if (!js_LookupProperty(cx, obj, id, &obj, &prop))
43290:         return false;
    1:     if (!prop)
43290:         return true;
43290:     return obj->isNative()
52503:            ? js_SetNativeAttributes(cx, obj, (Shape *) prop, *attrsp)
80622:            : obj->setGenericAttributes(cx, id, attrsp);
    1: }
    1: 
    1: JSBool
84755: js_SetElementAttributes(JSContext *cx, JSObject *obj, uint32_t index, uintN *attrsp)
78343: {
78343:     JSProperty *prop;
78343:     if (!js_LookupElement(cx, obj, index, &obj, &prop))
78343:         return false;
78343:     if (!prop)
78343:         return true;
78343:     return obj->isNative()
78343:            ? js_SetNativeAttributes(cx, obj, (Shape *) prop, *attrsp)
78343:            : obj->setElementAttributes(cx, index, attrsp);
78343: }
78343: 
78343: JSBool
86790: js_DeleteGeneric(JSContext *cx, JSObject *obj, jsid id, Value *rval, JSBool strict)
    1: {
    1:     JSObject *proto;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
48470:     rval->setBoolean(true);
    1: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
    1:     if (!js_LookupProperty(cx, obj, id, &proto, &prop))
54169:         return false;
    1:     if (!prop || proto != obj) {
    1:         /*
72089:          * If no property, or the property comes from a prototype, call the
72089:          * class's delProperty hook, passing rval as the result parameter.
    1:          */
52503:         return CallJSPropertyOp(cx, obj->getClass()->delProperty, obj, id, rval);
52503:     }
52503: 
52503:     shape = (Shape *)prop;
52503:     if (!shape->configurable()) {
54169:         if (strict)
54587:             return obj->reportNotConfigurable(cx, id);
48470:         rval->setBoolean(false);
54169:         return true;
    1:     }
    1: 
86009:     if (shape->hasSlot()) {
83221:         const Value &v = obj->nativeGetSlot(shape->slot());
71353:         GCPoke(cx, v);
48676: 
48676:         /*
48676:          * Delete is rare enough that we can take the hit of checking for an
48676:          * active cloned method function object that must be homed to a callee
48676:          * slot on the active stack frame before this delete completes, in case
48676:          * someone saved the clone and checks it against foo.caller for a foo
48676:          * called from the active method.
48676:          *
48676:          * We do not check suspended frames. They can't be reached via caller,
48676:          * so the only way they could have the method's joined function object
48676:          * as callee is through an API abusage. We break any such edge case.
48676:          */
83234:         JSFunction *fun;
83234:         if (IsFunctionObject(v, &fun) && fun->isClonedMethod()) {
69223:             for (StackFrame *fp = cx->maybefp(); fp; fp = fp->prev()) {
53840:                 if (fp->isFunctionFrame() &&
83255:                     fp->fun()->script() == fun->script() &&
60172:                     fp->thisValue().isObject())
60172:                 {
60172:                     JSObject *tmp = &fp->thisValue().toObject();
60172:                     do {
60172:                         if (tmp == obj) {
83234:                             fp->overwriteCallee(*fun);
60172:                             break;
60172:                         }
60172:                     } while ((tmp = tmp->getProto()) != NULL);
48676:                 }
48676:             }
48676:         }
48676:     }
    1: 
86009:     if (!CallJSPropertyOp(cx, obj->getClass()->delProperty, obj, shape->getUserId(), rval))
86009:         return false;
86009:     if (rval->isFalse())
86009:         return true;
86009: 
56567:     return obj->removeProperty(cx, id) && js_SuppressDeletedProperty(cx, obj, id);
    1: }
    1: 
78344: JSBool
86790: js_DeleteProperty(JSContext *cx, JSObject *obj, PropertyName *name, Value *rval, JSBool strict)
86790: {
86790:     return js_DeleteGeneric(cx, obj, ATOM_TO_JSID(name), rval, strict);
86790: }
86790: 
86790: JSBool
84755: js_DeleteElement(JSContext *cx, JSObject *obj, uint32_t index, Value *rval, JSBool strict)
78344: {
78344:     jsid id;
78344:     if (!IndexToId(cx, index, &id))
78344:         return false;
86790:     return js_DeleteGeneric(cx, obj, id, rval, strict);
86790: }
86790: 
86790: JSBool
86790: js_DeleteSpecial(JSContext *cx, JSObject *obj, SpecialId sid, Value *rval, JSBool strict)
86790: {
86790:     return js_DeleteGeneric(cx, obj, SPECIALID_TO_JSID(sid), rval, strict);
78344: }
78344: 
47607: namespace js {
47607: 
72053: bool
78194: HasDataProperty(JSContext *cx, JSObject *obj, jsid methodid, Value *vp)
78194: {
78194:     if (const Shape *shape = obj->nativeLookup(cx, methodid)) {
83289:         if (shape->hasDefaultGetterOrIsMethod() && shape->hasSlot()) {
83221:             *vp = obj->nativeGetSlot(shape->slot());
72053:             return true;
72053:         }
72053:     }
72053: 
72053:     return false;
57686: }
57686: 
72054: /*
72054:  * Gets |obj[id]|.  If that value's not callable, returns true and stores a
72054:  * non-primitive value in *vp.  If it's callable, calls it with no arguments
72054:  * and |obj| as |this|, returning the result in *vp.
72054:  *
72054:  * This is a mini-abstraction for ES5 8.12.8 [[DefaultValue]], either steps 1-2
72054:  * or steps 3-4.
72054:  */
72054: static bool
72054: MaybeCallMethod(JSContext *cx, JSObject *obj, jsid id, Value *vp)
72054: {
72054:     if (!js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, vp))
72054:         return false;
72054:     if (!js_IsCallable(*vp)) {
72054:         *vp = ObjectValue(*obj);
72054:         return true;
72054:     }
76829:     return Invoke(cx, ObjectValue(*obj), *vp, 0, NULL, vp);
72054: }
72054: 
72054: JSBool
55737: DefaultValue(JSContext *cx, JSObject *obj, JSType hint, Value *vp)
55737: {
72054:     JS_ASSERT(hint == JSTYPE_NUMBER || hint == JSTYPE_STRING || hint == JSTYPE_VOID);
72054:     JS_ASSERT(!obj->isXML());
72054: 
72054:     Class *clasp = obj->getClass();
55737:     if (hint == JSTYPE_STRING) {
55737:         /* Optimize (new String(...)).toString(). */
77817:         if (clasp == &StringClass &&
56216:             ClassMethodIsNative(cx, obj,
77817:                                  &StringClass,
55737:                                  ATOM_TO_JSID(cx->runtime->atomState.toStringAtom),
55737:                                  js_str_toString)) {
40901:             *vp = obj->getPrimitiveThis();
55737:             return true;
55737:         }
55737: 
72054:         if (!MaybeCallMethod(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.toStringAtom), vp))
72054:             return false;
72054:         if (vp->isPrimitive())
67921:             return true;
72054: 
72054:         if (!MaybeCallMethod(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom), vp))
72054:             return false;
72054:         if (vp->isPrimitive())
72054:             return true;
48470:     } else {
55737:         /* Optimize (new String(...)).valueOf(). */
77817:         if ((clasp == &StringClass &&
77817:              ClassMethodIsNative(cx, obj, &StringClass,
55737:                                  ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom),
56216:                                  js_str_toString)) ||
77817:             (clasp == &NumberClass &&
77817:              ClassMethodIsNative(cx, obj, &NumberClass,
56216:                                  ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom),
56216:                                  js_num_valueOf))) {
55737:             *vp = obj->getPrimitiveThis();
55737:             return true;
55737:         }
55737: 
72054:         if (!MaybeCallMethod(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom), vp))
72054:             return false;
72054:         if (vp->isPrimitive())
67921:             return true;
72054: 
72054:         if (!MaybeCallMethod(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.toStringAtom), vp))
72054:             return false;
72054:         if (vp->isPrimitive())
72054:             return true;
72054:     }
72054: 
    1:     /* Avoid recursive death when decompiling in js_ReportValueError. */
48470:     JSString *str;
    1:     if (hint == JSTYPE_STRING) {
72054:         str = JS_InternString(cx, clasp->name);
    1:         if (!str)
55737:             return false;
    1:     } else {
    1:         str = NULL;
    1:     }
72054: 
72054:     js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO, JSDVG_SEARCH_STACK, ObjectValue(*obj), str,
72054:                          (hint == JSTYPE_VOID) ? "primitive type" : JS_TYPE_STR(hint));
72054:     return false;
    1: }
    1: 
47607: } /* namespace js */
47607: 
48622: JS_FRIEND_API(JSBool)
79734: JS_EnumerateState(JSContext *cx, JSObject *obj, JSIterateOp enum_op, Value *statep, jsid *idp)
42641: {
42641:     /* If the class has a custom JSCLASS_NEW_ENUMERATE hook, call it. */
48470:     Class *clasp = obj->getClass();
33128:     JSEnumerateOp enumerate = clasp->enumerate;
11835:     if (clasp->flags & JSCLASS_NEW_ENUMERATE) {
11835:         JS_ASSERT(enumerate != JS_EnumerateStub);
78614:         return ((JSNewEnumerateOp) enumerate)(cx, obj, enum_op, statep, idp);
11835:     }
    1: 
    1:     if (!enumerate(cx, obj))
33128:         return false;
15677: 
42641:     /* Tell InitNativeIterator to treat us like a native object. */
47569:     JS_ASSERT(enum_op == JSENUMERATE_INIT || enum_op == JSENUMERATE_INIT_ALL);
48470:     statep->setMagic(JS_NATIVE_ENUMERATE);
33128:     return true;
    1: }
    1: 
47455: namespace js {
47455: 
    1: JSBool
47455: CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
48470:             Value *vp, uintN *attrsp)
    1: {
    1:     JSBool writing;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
48470:     Class *clasp;
52503:     const Shape *shape;
18870:     JSSecurityCallbacks *callbacks;
78614:     JSCheckAccessOp check;
    1: 
77817:     while (JS_UNLIKELY(obj->isWith()))
47455:         obj = obj->getProto();
47455: 
    1:     writing = (mode & JSACC_WRITE) != 0;
    1:     switch (mode & JSACC_TYPEMASK) {
    1:       case JSACC_PROTO:
    1:         pobj = obj;
    1:         if (!writing)
48470:             vp->setObjectOrNull(obj->getProto());
    1:         *attrsp = JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       case JSACC_PARENT:
    1:         JS_ASSERT(!writing);
    1:         pobj = obj;
48470:         vp->setObject(*obj->getParent());
    1:         *attrsp = JSPROP_READONLY | JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       default:
80442:         if (!obj->lookupGeneric(cx, id, &pobj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             if (!writing)
48470:                 vp->setUndefined();
    1:             *attrsp = 0;
11842:             pobj = obj;
11842:             break;
11842:         }
11842: 
40430:         if (!pobj->isNative()) {
16403:             if (!writing) {
48470:                     vp->setUndefined();
16403:                 *attrsp = 0;
16403:             }
11842:             break;
11961:         }
    1: 
52503:         shape = (Shape *)prop;
52503:         *attrsp = shape->attributes();
    1:         if (!writing) {
83221:             if (shape->hasSlot())
83221:                 *vp = pobj->nativeGetSlot(shape->slot());
48470:             else
48470:                 vp->setUndefined();
    1:         }
    1:     }
    1: 
84680:     JS_ASSERT_IF(*attrsp & JSPROP_READONLY, !(*attrsp & (JSPROP_GETTER | JSPROP_SETTER)));
84680: 
    1:     /*
    1:      * If obj's class has a stub (null) checkAccess hook, use the per-runtime
    1:      * checkObjectAccess callback, if configured.
    1:      *
    1:      * We don't want to require all classes to supply a checkAccess hook; we
    1:      * need that hook only for certain classes used when precompiling scripts
    1:      * and functions ("brutal sharing").  But for general safety of built-in
41968:      * magic properties like __proto__, we route all access checks, even for
41968:      * classes that stub out checkAccess, through the global checkObjectAccess
41968:      * hook.  This covers precompilation-based sharing and (possibly
41968:      * unintended) runtime sharing across trust boundaries.
    1:      */
40826:     clasp = pobj->getClass();
    1:     check = clasp->checkAccess;
18870:     if (!check) {
18870:         callbacks = JS_GetSecurityCallbacks(cx);
78614:         check = callbacks ? callbacks->checkObjectAccess : NULL;
48470:     }
48470:     return !check || check(cx, pobj, id, mode, vp);
    1: }
    1: 
47455: }
47455: 
38633: JSType
38633: js_TypeOf(JSContext *cx, JSObject *obj)
38633: {
64209:     return obj->isCallable() ? JSTYPE_FUNCTION : JSTYPE_OBJECT;
38633: }
38633: 
48470: bool
48470: js_IsDelegate(JSContext *cx, JSObject *obj, const Value &v)
48470: {
48470:     if (v.isPrimitive())
48470:         return false;
56565:     JSObject *obj2 = &v.toObject();
39928:     while ((obj2 = obj2->getProto()) != NULL) {
48470:         if (obj2 == obj)
48470:             return true;
48470:     }
48470:     return false;
    1: }
    1: 
47497: bool
52503: js::FindClassPrototype(JSContext *cx, JSObject *scopeobj, JSProtoKey protoKey,
52503:                        JSObject **protop, Class *clasp)
48470: {
48470:     Value v;
52503:     if (!js_FindClassObject(cx, scopeobj, protoKey, &v, clasp))
47497:         return false;
47497: 
48470:     if (IsFunctionObject(v)) {
48470:         JSObject *ctor = &v.toObject();
78675:         if (!ctor->getProperty(cx, cx->runtime->atomState.classPrototypeAtom, &v))
47497:             return false;
47497:     }
47497: 
48470:     *protop = v.isObject() ? &v.toObject() : NULL;
47497:     return true;
47497: }
47497: 
47497: /*
47497:  * The first part of this function has been hand-expanded and optimized into
47497:  * NewBuiltinClassInstance in jsobjinlines.h.
47497:  */
    1: JSBool
52503: js_GetClassPrototype(JSContext *cx, JSObject *scopeobj, JSProtoKey protoKey,
48470:                      JSObject **protop, Class *clasp)
38604: {
38604:     JS_ASSERT(JSProto_Null <= protoKey);
38604:     JS_ASSERT(protoKey < JSProto_LIMIT);
38604: 
38604:     if (protoKey != JSProto_Null) {
80803:         GlobalObject *global;
80803:         if (scopeobj) {
86483:             global = &scopeobj->global();
80803:         } else {
80803:             global = GetCurrentGlobal(cx);
80803:             if (!global) {
62953:                 *protop = NULL;
62953:                 return true;
62953:             }
62953:         }
80803:         const Value &v = global->getReservedSlot(JSProto_LIMIT + protoKey);
48470:         if (v.isObject()) {
48470:             *protop = &v.toObject();
38604:             return true;
38604:         }
38604:     }
38604: 
52503:     return FindClassPrototype(cx, scopeobj, protoKey, protop, clasp);
    1: }
    1: 
61734: JSObject *
61734: PrimitiveToObject(JSContext *cx, const Value &v)
61734: {
69242:     if (v.isString())
69242:         return StringObject::create(cx, v.toString());
78915:     if (v.isNumber())
78915:         return NumberObject::create(cx, v.toNumber());
78915: 
78915:     JS_ASSERT(v.isBoolean());
80701:     return BooleanObject::create(cx, v.toBoolean());
61734: }
61734: 
61734: JSBool
61734: js_PrimitiveToObject(JSContext *cx, Value *vp)
61734: {
61734:     JSObject *obj = PrimitiveToObject(cx, *vp);
61734:     if (!obj)
61734:         return false;
61734: 
48470:     vp->setObject(*obj);
61734:     return true;
 2383: }
 2383: 
 2383: JSBool
48470: js_ValueToObjectOrNull(JSContext *cx, const Value &v, JSObject **objp)
    1: {
    1:     JSObject *obj;
    1: 
48470:     if (v.isObjectOrNull()) {
48470:         obj = v.toObjectOrNull();
48470:     } else if (v.isUndefined()) {
    1:         obj = NULL;
    1:     } else {
61734:         obj = PrimitiveToObject(cx, v);
61734:         if (!obj)
61734:             return false;
    1:     }
    1:     *objp = obj;
61734:     return true;
61734: }
61734: 
61734: namespace js {
61734: 
61734: /* Callers must handle the already-object case . */
61734: JSObject *
61734: ToObjectSlow(JSContext *cx, Value *vp)
61734: {
61734:     JS_ASSERT(!vp->isMagic());
61734:     JS_ASSERT(!vp->isObject());
61734: 
61734:     if (vp->isNullOrUndefined()) {
61734:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_CONVERT_TO,
61734:                             vp->isNull() ? "null" : "undefined", "object");
61734:         return NULL;
61734:     }
61734: 
61734:     JSObject *obj = PrimitiveToObject(cx, *vp);
61734:     if (obj)
61734:         vp->setObject(*obj);
61734:     return obj;
61734: }
61734: 
    1: }
    1: 
    1: JSObject *
48470: js_ValueToNonNullObject(JSContext *cx, const Value &v)
    1: {
    1:     JSObject *obj;
    1: 
48470:     if (!js_ValueToObjectOrNull(cx, v, &obj))
    1:         return NULL;
 7897:     if (!obj)
 7897:         js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, v, NULL);
    1:     return obj;
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: JSBool
    1: js_XDRObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSAtom *atom;
48470:     Class *clasp;
84755:     uint32_t classId, classDef;
    1:     JSProtoKey protoKey;
    1:     JSObject *proto;
    1: 
    1:     cx = xdr->cx;
    1:     atom = NULL;
    1:     if (xdr->mode == JSXDR_ENCODE) {
40826:         clasp = (*objp)->getClass();
    1:         classId = JS_XDRFindClassIdByName(xdr, clasp->name);
    1:         classDef = !classId;
    1:         if (classDef) {
48470:             if (!JS_XDRRegisterClass(xdr, Jsvalify(clasp), &classId))
    1:                 return JS_FALSE;
    1:             protoKey = JSCLASS_CACHED_PROTO_KEY(clasp);
    1:             if (protoKey != JSProto_Null) {
    1:                 classDef |= (protoKey << 1);
    1:             } else {
70270:                 atom = js_Atomize(cx, clasp->name, strlen(clasp->name));
    1:                 if (!atom)
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     } else {
    1:         clasp = NULL;           /* quell GCC overwarning */
    1:         classDef = 0;
    1:     }
    1: 
    1:     /*
    1:      * XDR a flag word, which could be 0 for a class use, in which case no
    1:      * name follows, only the id in xdr's class registry; 1 for a class def,
    1:      * in which case the flag word is followed by the class name transferred
    1:      * from or to atom; or a value greater than 1, an odd number that when
    1:      * divided by two yields the JSProtoKey for class.  In the last case, as
    1:      * in the 0 classDef case, no name is transferred via atom.
    1:      */
    1:     if (!JS_XDRUint32(xdr, &classDef))
    1:         return JS_FALSE;
48480:     if (classDef == 1 && !js_XDRAtom(xdr, &atom))
    1:         return JS_FALSE;
    1: 
    1:     if (!JS_XDRUint32(xdr, &classId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         if (classDef) {
    1:             /* NB: we know that JSProto_Null is 0 here, for backward compat. */
 3164:             protoKey = (JSProtoKey) (classDef >> 1);
38604:             if (!js_GetClassPrototype(cx, NULL, protoKey, &proto, clasp))
    1:                 return JS_FALSE;
40826:             clasp = proto->getClass();
48470:             if (!JS_XDRRegisterClass(xdr, Jsvalify(clasp), &classId))
    1:                 return JS_FALSE;
    1:         } else {
48470:             clasp = Valueify(JS_XDRFindClassById(xdr, classId));
    1:             if (!clasp) {
    1:                 char numBuf[12];
    1:                 JS_snprintf(numBuf, sizeof numBuf, "%ld", (long)classId);
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_CANT_FIND_CLASS, numBuf);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (!clasp->xdrObject) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_XDR_CLASS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->xdrObject(xdr, objp);
    1: }
    1: 
    1: #endif /* JS_HAS_XDR */
    1: 
  583: #ifdef DEBUG
11835: void
11835: js_PrintObjectSlotName(JSTracer *trc, char *buf, size_t bufsize)
  583: {
32684:     JS_ASSERT(trc->debugPrinter == js_PrintObjectSlotName);
32684: 
32684:     JSObject *obj = (JSObject *)trc->debugPrintArg;
84755:     uint32_t slot = uint32_t(trc->debugPrintIndex);
32684: 
52503:     const Shape *shape;
40430:     if (obj->isNative()) {
52503:         shape = obj->lastProperty();
86009:         while (shape && (!shape->hasSlot() || shape->slot() != slot))
52503:             shape = shape->previous();
11835:     } else {
52503:         shape = NULL;
52503:     }
52503: 
52503:     if (!shape) {
32684:         const char *slotname = NULL;
60566:         if (obj->isGlobal()) {
  583: #define JS_PROTO(name,code,init)                                              \
55746:     if ((code) == slot) { slotname = js_##name##_str; goto found; }
  583: #include "jsproto.tbl"
  583: #undef JS_PROTO
  583:         }
  583:       found:
  583:         if (slotname)
  583:             JS_snprintf(buf, bufsize, "CLASS_OBJECT(%s)", slotname);
  583:         else
  583:             JS_snprintf(buf, bufsize, "**UNKNOWN SLOT %ld**", (long)slot);
  583:     } else {
83221:         jsid propid = shape->propid();
69637:         if (JSID_IS_INT(propid)) {
69637:             JS_snprintf(buf, bufsize, "%ld", (long)JSID_TO_INT(propid));
69637:         } else if (JSID_IS_ATOM(propid)) {
69637:             PutEscapedString(buf, bufsize, JSID_TO_ATOM(propid), 0);
  583:         } else {
  583:             JS_snprintf(buf, bufsize, "**FINALIZED ATOM KEY**");
  583:         }
  583:     }
  583: }
  583: #endif
  583: 
68903: static const Shape *
68903: LastConfigurableShape(JSObject *obj)
68903: {
68903:     for (Shape::Range r(obj->lastProperty()->all()); !r.empty(); r.popFront()) {
68903:         const Shape *shape = &r.front();
68903:         if (shape->configurable())
68903:             return shape;
68903:     }
68903:     return NULL;
68903: }
68903: 
68903: bool
48622: js_ClearNative(JSContext *cx, JSObject *obj)
    1: {
68903:     /* Remove all configurable properties from obj. */
68903:     while (const Shape *shape = LastConfigurableShape(obj)) {
83221:         if (!obj->removeProperty(cx, shape->propid()))
68903:             return false;
68903:     }
68903: 
68903:     /* Set all remaining writable plain data properties to undefined. */
68903:     for (Shape::Range r(obj->lastProperty()->all()); !r.empty(); r.popFront()) {
68903:         const Shape *shape = &r.front();
68903:         if (shape->isDataDescriptor() &&
68903:             shape->writable() &&
68903:             shape->hasDefaultSetter() &&
86009:             shape->hasSlot()) {
86009:             obj->nativeSetSlot(shape->slot(), UndefinedValue());
68903:         }
68903:     }
68903:     return true;
    1: }
    1: 
32603: bool
84755: js_GetReservedSlot(JSContext *cx, JSObject *obj, uint32_t slot, Value *vp)
32603: {
40430:     if (!obj->isNative()) {
48470:         vp->setUndefined();
32603:         return true;
32603:     }
32603: 
83231:     JS_ASSERT(slot < JSSLOT_FREE(obj->getClass()));
48470:     *vp = obj->getSlot(slot);
32603:     return true;
32603: }
32603: 
32603: bool
84755: js_SetReservedSlot(JSContext *cx, JSObject *obj, uint32_t slot, const Value &v)
    1: {
40430:     if (!obj->isNative())
32603:         return true;
32603: 
83259:     JS_ASSERT(slot < JSSLOT_FREE(obj->getClass()));
40410:     obj->setSlot(slot, v);
71353:     GCPoke(cx, NullValue());
32603:     return true;
    1: }
    1: 
83275: static ObjectElements emptyObjectHeader(0, 0);
83301: HeapValue *js::emptyObjectElements =
86976:     (HeapValue *) (uintptr_t(&emptyObjectHeader) + sizeof(ObjectElements));
40424: 
36491: JSBool
27641: js_ReportGetterOnlyAssignment(JSContext *cx)
27641: {
36491:     return JS_ReportErrorFlagsAndNumber(cx,
36491:                                         JSREPORT_WARNING | JSREPORT_STRICT |
36491:                                         JSREPORT_STRICT_MODE_ERROR,
36491:                                         js_GetErrorMessage, NULL,
36491:                                         JSMSG_GETTER_ONLY);
27641: }
27641: 
27641: JS_FRIEND_API(JSBool)
62395: js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
27641: {
36491:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_GETTER_ONLY);
27641:     return JS_FALSE;
27641: }
27641: 
79389: void
79389: js::ReportIncompatibleMethod(JSContext *cx, CallReceiver call, Class *clasp)
79389: {
79389:     Value &thisv = call.thisv();
79389: 
79389: #ifdef DEBUG
79389:     if (thisv.isObject()) {
87812:         JS_ASSERT(thisv.toObject().getClass() != clasp ||
87812:                   !thisv.toObject().getProto() ||
87812:                   thisv.toObject().getProto()->getClass() != clasp);
79389:     } else if (thisv.isString()) {
79389:         JS_ASSERT(clasp != &StringClass);
79389:     } else if (thisv.isNumber()) {
79389:         JS_ASSERT(clasp != &NumberClass);
79389:     } else if (thisv.isBoolean()) {
79389:         JS_ASSERT(clasp != &BooleanClass);
79389:     } else {
79389:         JS_ASSERT(thisv.isUndefined() || thisv.isNull());
79389:     }
79389: #endif
79389: 
79389:     if (JSFunction *fun = js_ValueToFunction(cx, &call.calleev(), 0)) {
79389:         JSAutoByteString funNameBytes;
79389:         if (const char *funName = GetFunctionNameBytes(cx, fun, &funNameBytes)) {
79389:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
79389:                                  clasp->name, funName, InformalValueTypeName(thisv));
79389:         }
79389:     }
79389: }
79389: 
79389: bool
79779: js::HandleNonGenericMethodClassMismatch(JSContext *cx, CallArgs args, Native native, Class *clasp)
79389: {
79389:     if (args.thisv().isObject()) {
79389:         JSObject &thisObj = args.thisv().toObject();
79779:         if (thisObj.isProxy())
79389:             return Proxy::nativeCall(cx, &thisObj, clasp, native, args);
79389:     }
79389: 
79389:     ReportIncompatibleMethod(cx, args, clasp);
79389:     return false;
79389: }
79389: 
24294: #ifdef DEBUG
19714: 
19714: /*
19714:  * Routines to print out values during debugging.  These are FRIEND_API to help
19714:  * the debugger find them and to support temporarily hacking js_Dump* calls
19714:  * into other code.
19714:  */
19714: 
19714: void
19714: dumpChars(const jschar *s, size_t n)
19714: {
19714:     size_t i;
19714: 
19714:     if (n == (size_t) -1) {
19714:         while (s[++n]) ;
19714:     }
19714: 
    1:     fputc('"', stderr);
19714:     for (i = 0; i < n; i++) {
19714:         if (s[i] == '\n')
19714:             fprintf(stderr, "\\n");
19714:         else if (s[i] == '\t')
19714:             fprintf(stderr, "\\t");
19714:         else if (s[i] >= 32 && s[i] < 127)
19714:             fputc(s[i], stderr);
19714:         else if (s[i] <= 255)
19714:             fprintf(stderr, "\\x%02x", (unsigned int) s[i]);
19714:         else
19714:             fprintf(stderr, "\\u%04x", (unsigned int) s[i]);
19714:     }
19714:     fputc('"', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpChars(const jschar *s, size_t n)
19714: {
19714:     fprintf(stderr, "jschar * (%p) = ", (void *) s);
19714:     dumpChars(s, n);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: void
19714: dumpString(JSString *str)
19714: {
59890:     if (const jschar *chars = str->getChars(NULL))
59890:         dumpChars(chars, str->length());
59890:     else
59890:         fprintf(stderr, "(oom in dumpString)");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpString(JSString *str)
19714: {
59890:     if (const jschar *chars = str->getChars(NULL)) {
19714:         fprintf(stderr, "JSString* (%p) = jschar * (%p) = ",
59890:                 (void *) str, (void *) chars);
19714:         dumpString(str);
59890:     } else {
59890:         fprintf(stderr, "(oom in JS_DumpString)");
59890:     }
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: JS_FRIEND_API(void)
19714: js_DumpAtom(JSAtom *atom)
19714: {
19714:     fprintf(stderr, "JSAtom* (%p) = ", (void *) atom);
64345:     js_DumpString(atom);
19714: }
19714: 
19714: void
48470: dumpValue(const Value &v)
48470: {
48470:     if (v.isNull())
19714:         fprintf(stderr, "null");
48470:     else if (v.isUndefined())
19714:         fprintf(stderr, "undefined");
48470:     else if (v.isInt32())
48470:         fprintf(stderr, "%d", v.toInt32());
48470:     else if (v.isDouble())
48470:         fprintf(stderr, "%g", v.toDouble());
48470:     else if (v.isString())
48470:         dumpString(v.toString());
48470:     else if (v.isObject() && v.toObject().isFunction()) {
83234:         JSFunction *fun = v.toObject().toFunction();
57721:         if (fun->atom) {
57721:             fputs("<function ", stderr);
64345:             FileEscapedString(stderr, fun->atom, 0);
57721:         } else {
57721:             fputs("<unnamed function", stderr);
57721:         }
59062:         if (fun->isInterpreted()) {
59062:             JSScript *script = fun->script();
59062:             fprintf(stderr, " (%s:%u)",
59062:                     script->filename ? script->filename : "", script->lineno);
59062:         }
83234:         fprintf(stderr, " at %p>", (void *) fun);
48470:     } else if (v.isObject()) {
48470:         JSObject *obj = &v.toObject();
48470:         Class *clasp = obj->getClass();
19714:         fprintf(stderr, "<%s%s at %p>",
47480:                 clasp->name,
77817:                 (clasp == &ObjectClass) ? "" : " object",
25218:                 (void *) obj);
48470:     } else if (v.isBoolean()) {
48470:         if (v.toBoolean())
19714:             fprintf(stderr, "true");
48470:         else
19714:             fprintf(stderr, "false");
48470:     } else if (v.isMagic()) {
48470:         fprintf(stderr, "<invalid");
48470: #ifdef DEBUG
48470:         switch (v.whyMagic()) {
48470:           case JS_ARRAY_HOLE:        fprintf(stderr, " array hole");         break;
48470:           case JS_ARGS_HOLE:         fprintf(stderr, " args hole");          break;
48470:           case JS_NATIVE_ENUMERATE:  fprintf(stderr, " native enumeration"); break;
48470:           case JS_NO_ITER_VALUE:     fprintf(stderr, " no iter value");      break;
48470:           case JS_GENERATOR_CLOSING: fprintf(stderr, " generator closing");  break;
48470:           default:                   fprintf(stderr, " ?!");                 break;
48470:         }
48470: #endif
48470:         fprintf(stderr, ">");
19714:     } else {
48470:         fprintf(stderr, "unexpected value");
19714:     }
19714: }
19714: 
19714: JS_FRIEND_API(void)
48470: js_DumpValue(const Value &val)
48470: {
19714:     dumpValue(val);
19714:     fputc('\n', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpId(jsid id)
19714: {
48470:     fprintf(stderr, "jsid %p = ", (void *) JSID_BITS(id));
48470:     dumpValue(IdToValue(id));
19714:     fputc('\n', stderr);
19714: }
19714: 
20208: static void
62931: DumpProperty(JSObject *obj, const Shape &shape)
52503: {
83221:     jsid id = shape.propid();
84755:     uint8_t attrs = shape.attributes();
19714: 
62931:     fprintf(stderr, "    ((Shape *) %p) ", (void *) &shape);
19714:     if (attrs & JSPROP_ENUMERATE) fprintf(stderr, "enumerate ");
19714:     if (attrs & JSPROP_READONLY) fprintf(stderr, "readonly ");
19714:     if (attrs & JSPROP_PERMANENT) fprintf(stderr, "permanent ");
19714:     if (attrs & JSPROP_SHARED) fprintf(stderr, "shared ");
83221:     if (shape.isMethod()) fprintf(stderr, "method ");
62931: 
62931:     if (shape.hasGetterValue())
62931:         fprintf(stderr, "getterValue=%p ", (void *) shape.getterObject());
62931:     else if (!shape.hasDefaultGetter())
62936:         fprintf(stderr, "getterOp=%p ", JS_FUNC_TO_DATA_PTR(void *, shape.getterOp()));
62931: 
62931:     if (shape.hasSetterValue())
62931:         fprintf(stderr, "setterValue=%p ", (void *) shape.setterObject());
62931:     else if (!shape.hasDefaultSetter())
62936:         fprintf(stderr, "setterOp=%p ", JS_FUNC_TO_DATA_PTR(void *, shape.setterOp()));
59009: 
19714:     if (JSID_IS_ATOM(id))
48470:         dumpString(JSID_TO_STRING(id));
19714:     else if (JSID_IS_INT(id))
19714:         fprintf(stderr, "%d", (int) JSID_TO_INT(id));
19714:     else
48470:         fprintf(stderr, "unknown jsid %p", (void *) JSID_BITS(id));
83221: 
84755:     uint32_t slot = shape.hasSlot() ? shape.maybeSlot() : SHAPE_INVALID_SLOT;
83221:     fprintf(stderr, ": slot %d", slot);
86009:     if (shape.hasSlot()) {
62931:         fprintf(stderr, " = ");
83221:         dumpValue(obj->getSlot(slot));
83221:     } else if (slot != SHAPE_INVALID_SLOT) {
62931:         fprintf(stderr, " (INVALID!)");
62931:     }
19714:     fprintf(stderr, "\n");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpObject(JSObject *obj)
19714: {
13437:     fprintf(stderr, "object %p\n", (void *) obj);
55747:     Class *clasp = obj->getClass();
    1:     fprintf(stderr, "class %p %s\n", (void *)clasp, clasp->name);
19714: 
52503:     fprintf(stderr, "flags:");
83248:     if (obj->isDelegate()) fprintf(stderr, " delegate");
83248:     if (obj->isSystem()) fprintf(stderr, " system");
83248:     if (!obj->isExtensible()) fprintf(stderr, " not_extensible");
83248:     if (obj->isIndexed()) fprintf(stderr, " indexed");
79734: 
53569:     if (obj->isNative()) {
83249:         if (obj->inDictionaryMode())
52503:             fprintf(stderr, " inDictionaryMode");
83249:         if (obj->hasPropertyTable())
52503:             fprintf(stderr, " hasPropertyTable");
83249:     }
52503:     fprintf(stderr, "\n");
52503: 
37003:     if (obj->isDenseArray()) {
77343:         unsigned slots = obj->getDenseArrayInitializedLength();
19714:         fprintf(stderr, "elements\n");
55748:         for (unsigned i = 0; i < slots; i++) {
19714:             fprintf(stderr, " %3d: ", i);
41782:             dumpValue(obj->getDenseArrayElement(i));
19714:             fprintf(stderr, "\n");
19714:             fflush(stderr);
19714:         }
13437:         return;
13437:     }
13437: 
31452:     fprintf(stderr, "proto ");
48470:     dumpValue(ObjectOrNullValue(obj->getProto()));
31452:     fputc('\n', stderr);
31452: 
31452:     fprintf(stderr, "parent ");
48470:     dumpValue(ObjectOrNullValue(obj->getParent()));
31452:     fputc('\n', stderr);
31452: 
55746:     if (clasp->flags & JSCLASS_HAS_PRIVATE)
31452:         fprintf(stderr, "private %p\n", obj->getPrivate());
31452: 
62931:     if (!obj->isNative())
62931:         fprintf(stderr, "not native\n");
62931: 
55748:     unsigned reservedEnd = JSCLASS_RESERVED_SLOTS(clasp);
55748:     unsigned slots = obj->slotSpan();
62931:     unsigned stop = obj->isNative() ? reservedEnd : slots;
62931:     if (stop > 0)
62931:         fprintf(stderr, obj->isNative() ? "reserved slots:\n" : "slots:\n");
62931:     for (unsigned i = 0; i < stop; i++) {
19714:         fprintf(stderr, " %3d ", i);
31452:         if (i < reservedEnd)
19714:             fprintf(stderr, "(reserved) ");
19714:         fprintf(stderr, "= ");
40410:         dumpValue(obj->getSlot(i));
19714:         fputc('\n', stderr);
19714:     }
62931: 
62931:     if (obj->isNative()) {
62931:         fprintf(stderr, "properties:\n");
62931:         Vector<const Shape *, 8, SystemAllocPolicy> props;
62931:         for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront())
62931:             props.append(&r.front());
62931:         for (size_t i = props.length(); i-- != 0;)
62931:             DumpProperty(obj, *props[i]);
62931:     }
19714:     fputc('\n', stderr);
    1: }
    1: 
28665: static void
28665: MaybeDumpObject(const char *name, JSObject *obj)
28665: {
28665:     if (obj) {
28665:         fprintf(stderr, "  %s: ", name);
48470:         dumpValue(ObjectValue(*obj));
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
32774: static void
48470: MaybeDumpValue(const char *name, const Value &v)
48470: {
48470:     if (!v.isNull()) {
32774:         fprintf(stderr, "  %s: ", name);
32774:         dumpValue(v);
32774:         fputc('\n', stderr);
32774:     }
32774: }
32774: 
28665: JS_FRIEND_API(void)
69223: js_DumpStackFrame(JSContext *cx, StackFrame *start)
42717: {
42717:     /* This should only called during live debugging. */
76890:     FrameRegsIter i(cx, StackIter::GO_THROUGH_SAVED);
76890:     if (!start) {
76890:         if (i.done()) {
76890:             fprintf(stderr, "no stack for cx = %p\n", (void*) cx);
76890:             return;
76890:         }
76890:     } else {
42717:         while (!i.done() && i.fp() != start)
42717:             ++i;
42717: 
42717:         if (i.done()) {
76890:             fprintf(stderr, "fp = %p not found in cx = %p\n",
76890:                     (void *)start, (void *)cx);
42717:             return;
42717:         }
76890:     }
42717: 
42717:     for (; !i.done(); ++i) {
69223:         StackFrame *const fp = i.fp();
69223: 
69223:         fprintf(stderr, "StackFrame at %p\n", (void *) fp);
53840:         if (fp->isFunctionFrame()) {
53840:             fprintf(stderr, "callee fun: ");
53840:             dumpValue(ObjectValue(fp->callee()));
42717:         } else {
28665:             fprintf(stderr, "global frame, no callee");
42717:         }
28665:         fputc('\n', stderr);
28665: 
53840:         if (fp->isScriptFrame()) {
51056:             fprintf(stderr, "file %s line %u\n",
53840:                     fp->script()->filename, (unsigned) fp->script()->lineno);
51056:         }
28665: 
42717:         if (jsbytecode *pc = i.pc()) {
53840:             if (!fp->isScriptFrame()) {
42717:                 fprintf(stderr, "*** pc && !script, skipping frame\n\n");
28665:                 continue;
28665:             }
28665:             fprintf(stderr, "  pc = %p\n", pc);
28665:             fprintf(stderr, "  current op: %s\n", js_CodeName[*pc]);
28665:         }
48470:         Value *sp = i.sp();
42714:         fprintf(stderr, "  slots: %p\n", (void *) fp->slots());
42714:         fprintf(stderr, "  sp:    %p = slots + %u\n", (void *) sp, (unsigned) (sp - fp->slots()));
42714:         if (sp - fp->slots() < 10000) { // sanity
48470:             for (Value *p = fp->slots(); p < sp; p++) {
28665:                 fprintf(stderr, "    %p: ", (void *) p);
28665:                 dumpValue(*p);
28665:                 fputc('\n', stderr);
28665:             }
28665:         }
64364:         if (fp->hasArgs()) {
53840:             fprintf(stderr, "  actuals: %p (%u) ", (void *) fp->actualArgs(), (unsigned) fp->numActualArgs());
53840:             fprintf(stderr, "  formals: %p (%u)\n", (void *) fp->formalArgs(), (unsigned) fp->numFormalArgs());
53840:         }
64364:         if (fp->hasCallObj()) {
64364:             fprintf(stderr, "  has call obj: ");
64364:             dumpValue(ObjectValue(fp->callObj()));
64364:             fprintf(stderr, "\n");
64364:         }
50510:         MaybeDumpObject("argsobj", fp->maybeArgsObj());
86077:         MaybeDumpObject("blockChain", fp->maybeBlockChain());
55608:         if (!fp->isDummyFrame()) {
53840:             MaybeDumpValue("this", fp->thisValue());
28665:             fprintf(stderr, "  rval: ");
53840:             dumpValue(fp->returnValue());
55608:         } else {
55608:             fprintf(stderr, "dummy frame");
55608:         }
28665:         fputc('\n', stderr);
28665: 
28665:         fprintf(stderr, "  flags:");
53840:         if (fp->isConstructing())
28665:             fprintf(stderr, " constructing");
53840:         if (fp->hasOverriddenArgs())
53840:             fprintf(stderr, " overridden_args");
53840:         if (fp->isDebuggerFrame())
28665:             fprintf(stderr, " debugger");
53840:         if (fp->isEvalFrame())
28665:             fprintf(stderr, " eval");
53840:         if (fp->isYielding())
28665:             fprintf(stderr, " yielding");
53840:         if (fp->isGeneratorFrame())
28665:             fprintf(stderr, " generator");
28665:         fputc('\n', stderr);
28665: 
53840:         fprintf(stderr, "  scopeChain: (JSObject *) %p\n", (void *) &fp->scopeChain());
28665: 
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
53013: #endif /* DEBUG */
53013: 
