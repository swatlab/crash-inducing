     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 95352: #include "Accessible-inl.h"
 39503: 
 39503: #include "nsIXBLAccessible.h"
 39503: 
106800: #include "AccCollector.h"
 47172: #include "AccGroupInfo.h"
 43888: #include "AccIterator.h"
 41384: #include "nsAccUtils.h"
 51377: #include "nsAccEvent.h"
 75194: #include "nsAccessibleRelation.h"
 41384: #include "nsAccessibilityService.h"
 39503: #include "nsAccTreeWalker.h"
 75194: #include "nsIAccessibleRelation.h"
 90500: #include "nsEventShell.h"
 41384: #include "nsTextEquivUtils.h"
 75194: #include "Relation.h"
 87094: #include "Role.h"
 97643: #include "RootAccessible.h"
 67790: #include "States.h"
 90500: #include "StyleInfo.h"
  4451: 
 99308: #include "nsContentUtils.h"
  4451: #include "nsIDOMElement.h"
  4451: #include "nsIDOMDocument.h"
  4451: #include "nsIDOMNodeFilter.h"
 81041: #include "nsIDOMHTMLElement.h"
  4451: #include "nsIDOMTreeWalker.h"
  4451: #include "nsIDOMXULButtonElement.h"
  4451: #include "nsIDOMXULDocument.h"
  4451: #include "nsIDOMXULElement.h"
  4451: #include "nsIDOMXULLabelElement.h"
  4451: #include "nsIDOMXULSelectCntrlEl.h"
  4451: #include "nsIDOMXULSelectCntrlItemEl.h"
  4451: #include "nsPIDOMWindow.h"
  4451: 
  4451: #include "nsIDocument.h"
  4451: #include "nsIContent.h"
  4451: #include "nsIForm.h"
  4451: #include "nsIFormControl.h"
  4451: 
113953: #include "nsDeckFrame.h"
 71071: #include "nsLayoutUtils.h"
     1: #include "nsIPresShell.h"
 98236: #include "nsIStringBundle.h"
     1: #include "nsPresContext.h"
     1: #include "nsIFrame.h"
 37073: #include "nsIView.h"
  4451: #include "nsIDocShellTreeItem.h"
 12642: #include "nsIScrollableFrame.h"
 29018: #include "nsFocusManager.h"
  4451: 
     1: #include "nsXPIDLString.h"
     1: #include "nsUnicharUtils.h"
  6279: #include "nsReadableUtils.h"
     1: #include "prdtoa.h"
     1: #include "nsIAtom.h"
     1: #include "nsIURI.h"
 24822: #include "nsArrayUtils.h"
     1: #include "nsIMutableArray.h"
   511: #include "nsIObserverService.h"
  4451: #include "nsIServiceManager.h"
  7830: #include "nsWhitespaceTokenizer.h"
 13012: #include "nsAttrName.h"
 13757: #include "nsNetUtil.h"
 68780: #include "nsEventStates.h"
     1: 
102909: #ifdef DEBUG
     1: #include "nsIDOMCharacterData.h"
     1: #endif
     1: 
 50861: #include "mozilla/unused.h"
 71199: #include "mozilla/Preferences.h"
 74131: #include "mozilla/dom/Element.h"
 71199: 
 71199: using namespace mozilla;
 74618: using namespace mozilla::a11y;
 50861: 
     1: 
 16428: ////////////////////////////////////////////////////////////////////////////////
 99648: // Accessible. nsISupports
 99648: 
 99648: NS_IMPL_CYCLE_COLLECTION_CLASS(Accessible)
 99648: 
 99648: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(Accessible, nsAccessNode)
 36989:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mParent");
 36989:   cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mParent.get()));
 36989: 
108991:   uint32_t i, length = tmp->mChildren.Length();
 36989:   for (i = 0; i < length; ++i) {
 36989:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
 36989:     cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mChildren[i].get()));
 36989:   }
 16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 16428: 
 99648: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(Accessible, nsAccessNode)
 16428:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParent)
 36989:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mChildren)
 16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 16428: 
 99648: NS_IMPL_ADDREF_INHERITED(Accessible, nsAccessNode)
 99648: NS_IMPL_RELEASE_INHERITED(Accessible, nsAccessNode)
 99648: 
 99648: nsresult
 99648: Accessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
     1: {
     1:   // Custom-built QueryInterface() knows when we support nsIAccessibleSelectable
  8937:   // based on role attribute and aria-multiselectable
106838:   *aInstancePtr = nullptr;
     1: 
 16428:   if (aIID.Equals(NS_GET_IID(nsXPCOMCycleCollectionParticipant))) {
102293:     *aInstancePtr = NS_CYCLE_COLLECTION_PARTICIPANT(Accessible);
 16428:     return NS_OK;
 16428:   }
 16428: 
     1:   if (aIID.Equals(NS_GET_IID(nsIAccessible))) {
  3233:     *aInstancePtr = static_cast<nsIAccessible*>(this);
     1:     NS_ADDREF_THIS();
     1:     return NS_OK;
     1:   }
     1: 
 99648:   if (aIID.Equals(NS_GET_IID(Accessible))) {
 99648:     *aInstancePtr = static_cast<Accessible*>(this);
 20246:     NS_ADDREF_THIS();
 20246:     return NS_OK;
 20246:   }
 20246: 
     1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleSelectable))) {
 51865:     if (IsSelect()) {
  3233:       *aInstancePtr = static_cast<nsIAccessibleSelectable*>(this);
     1:       NS_ADDREF_THIS();
  4648:       return NS_OK;
     1:     }
 51865:     return NS_ERROR_NO_INTERFACE;
     1:   }
     1: 
     1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleValue))) {
116121:     if (HasNumericValue()) {
  3233:       *aInstancePtr = static_cast<nsIAccessibleValue*>(this);
     1:       NS_ADDREF_THIS();
  4648:       return NS_OK;
     1:     }
     1:   }
     1: 
     1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperLink))) {
 72484:     if (IsLink()) {
  3233:       *aInstancePtr = static_cast<nsIAccessibleHyperLink*>(this);
     1:       NS_ADDREF_THIS();
     1:       return NS_OK;
     1:     }
     1:     return NS_ERROR_NO_INTERFACE;
     1:   }
     1: 
  4470:   return nsAccessNodeWrap::QueryInterface(aIID, aInstancePtr);
     1: }
     1: 
 99648: Accessible::Accessible(nsIContent* aContent, DocAccessible* aDoc) :
 89799:   nsAccessNodeWrap(aContent, aDoc),
106838:   mParent(nullptr), mIndexInParent(-1), mFlags(eChildrenUninitialized),
106838:   mIndexOfEmbeddedChild(-1), mRoleMapEntry(nullptr)
     1: {
     1: #ifdef NS_DEBUG_X
     1:    {
     1:      nsCOMPtr<nsIPresShell> shell(do_QueryReferent(aShell));
   732:      printf(">>> %p Created Acc - DOM: %p  PS: %p", 
  3233:             (void*)static_cast<nsIAccessible*>(this), (void*)aNode,
   732:             (void*)shell.get());
   732:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
   732:     if (content) {
 69361:       printf(" Con: %s@%p",
 69361:              NS_ConvertUTF16toUTF8(content->NodeInfo()->QualifiedName()).get(),
 69361:              (void *)content.get());
   732:       nsAutoString buf;
 97369:       Name(buf);
   732:       printf(" Name:[%s]", NS_ConvertUTF16toUTF8(buf).get());
     1:      }
     1:      printf("\n");
     1:    }
     1: #endif
     1: }
     1: 
     1: //-----------------------------------------------------
     1: // destruction
     1: //-----------------------------------------------------
 99648: Accessible::~Accessible()
     1: {
     1: }
     1: 
 29320: void
104105: Accessible::Init()
104105: {
104105: }
104105: 
 20246: NS_IMETHODIMP
 99648: Accessible::GetDocument(nsIAccessibleDocument** aDocument)
 89598: {
 89598:   NS_ENSURE_ARG_POINTER(aDocument);
 89598: 
 89800:   NS_IF_ADDREF(*aDocument = Document());
 89598:   return NS_OK;
 89598: }
 89598: 
 89598: NS_IMETHODIMP
 99648: Accessible::GetDOMNode(nsIDOMNode** aDOMNode)
 89598: {
 89598:   NS_ENSURE_ARG_POINTER(aDOMNode);
106838:   *aDOMNode = nullptr;
 89598: 
 89598:   nsINode *node = GetNode();
 89598:   if (node)
 89598:     CallQueryInterface(node, aDOMNode);
 89598: 
 89598:   return NS_OK;
 89598: }
 89598: 
 89598: NS_IMETHODIMP
 99648: Accessible::GetRootDocument(nsIAccessibleDocument** aRootDocument)
 89598: {
 89598:   NS_ENSURE_ARG_POINTER(aRootDocument);
 89598: 
 97643:   NS_IF_ADDREF(*aRootDocument = RootAccessible());
 89598:   return NS_OK;
 89598: }
 89598: 
 89598: NS_IMETHODIMP
 99648: Accessible::GetLanguage(nsAString& aLanguage)
 89598: {
 89598:   Language(aLanguage);
 89598:   return NS_OK;
 89598: }
 89598: 
 89598: NS_IMETHODIMP
 99648: Accessible::GetName(nsAString& aName)
     1: {
     1:   aName.Truncate();
 20246: 
 20246:   if (IsDefunct())
 20246:     return NS_ERROR_FAILURE;
 20246: 
 97369:   nsAutoString name;
 97369:   Name(name);
 97369:   aName.Assign(name);
 97369: 
 97369:   return NS_OK;
 97369: }
 97369: 
 97369: ENameValueFlag
 99648: Accessible::Name(nsString& aName)
 97369: {
 97369:   aName.Truncate();
 97369: 
118792:   if (!HasOwnContent())
118792:     return eNameOK;
118792: 
118792:   ARIAName(aName);
 20246:   if (!aName.IsEmpty())
 97369:     return eNameOK;
 20246: 
 43504:   nsCOMPtr<nsIXBLAccessible> xblAccessible(do_QueryInterface(mContent));
 28315:   if (xblAccessible) {
 29559:     xblAccessible->GetAccessibleName(aName);
 28315:     if (!aName.IsEmpty())
 97369:       return eNameOK;
 28315:   }
 28315: 
118863:   ENameValueFlag nameFlag = NativeName(aName);
 22205:   if (!aName.IsEmpty())
119159:     return nameFlag;
 22205: 
 22205:   // In the end get the name from tooltip.
 97369:   if (mContent->IsHTML()) {
 97369:     if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::title, aName)) {
 97369:       aName.CompressWhitespace();
 97369:       return eNameFromTooltip;
 97369:     }
 97369:   } else if (mContent->IsXUL()) {
 97369:     if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::tooltiptext, aName)) {
 97369:       aName.CompressWhitespace();
 97369:       return eNameFromTooltip;
 97369:     }
 25591:   }
 25591: 
118863:   if (nameFlag != eNoNameOnPurpose)
 80486:     aName.SetIsVoid(true);
 22205: 
119159:   return nameFlag;
     1: }
     1: 
 69342: NS_IMETHODIMP
 99648: Accessible::GetDescription(nsAString& aDescription)
     1: {
 27711:   if (IsDefunct())
 27711:     return NS_ERROR_FAILURE;
 27711: 
 69342:   nsAutoString desc;
 69342:   Description(desc);
 69342:   aDescription.Assign(desc);
 69342: 
 69342:   return NS_OK;
 69342: }
 69342: 
 69342: void
 99648: Accessible::Description(nsString& aDescription)
 69342: {
     1:   // There are 4 conditions that make an accessible have no accDescription:
     1:   // 1. it's a text node; or
     1:   // 2. It has no DHTML describedby property
     1:   // 3. it doesn't have an accName; or
     1:   // 4. its title attribute already equals to its accName nsAutoString name; 
 43504: 
118792:   if (!HasOwnContent() || mContent->IsNodeOfType(nsINode::eTEXT))
 69342:     return;
 69342: 
 69342:   nsTextEquivUtils::
 78350:     GetTextEquivFromIDRefs(this, nsGkAtoms::aria_describedby,
 69342:                            aDescription);
 69342: 
 69342:   if (aDescription.IsEmpty()) {
 79445:     bool isXUL = mContent->IsXUL();
     1:     if (isXUL) {
     1:       // Try XUL <description control="[id]">description text</description>
 89800:       XULDescriptionIterator iter(Document(), mContent);
106838:       Accessible* descr = nullptr;
 69342:       while ((descr = iter.Next()))
 69342:         nsTextEquivUtils::AppendTextEquivFromContent(this, descr->GetContent(),
 69342:                                                      &aDescription);
 69342:       }
 69342: 
 69342:       if (aDescription.IsEmpty()) {
 78350:         nsIAtom *descAtom = isXUL ? nsGkAtoms::tooltiptext :
 78350:                                     nsGkAtoms::title;
 69342:         if (mContent->GetAttr(kNameSpaceID_None, descAtom, aDescription)) {
     1:           nsAutoString name;
 97369:           Name(name);
 69342:           if (name.IsEmpty() || aDescription == name)
     1:             // Don't use tooltip for a description if this object
     1:             // has no name or the tooltip is the same as the name
 69342:             aDescription.Truncate();
 69342:         }
 69342:       }
 69342:     }
 69342:     aDescription.CompressWhitespace();
     1: }
     1: 
  5414: NS_IMETHODIMP
101616: Accessible::GetAccessKey(nsAString& aAccessKey)
     1: {
  5414:   aAccessKey.Truncate();
  5414: 
 43504:   if (IsDefunct())
     1:     return NS_ERROR_FAILURE;
  5414: 
 74014:   AccessKey().ToString(aAccessKey);
 74014:   return NS_OK;
 74014: }
 74014: 
 74014: KeyBinding
 99648: Accessible::AccessKey() const
 74014: {
118792:   if (!HasOwnContent())
118792:     return KeyBinding();
118792: 
108991:   uint32_t key = nsCoreUtils::GetAccessKeyFor(mContent);
 43504:   if (!key && mContent->IsElement()) {
106838:     Accessible* label = nullptr;
 57932: 
 57932:     // Copy access key from label node.
 57932:     if (mContent->IsHTML()) {
 57932:       // Unless it is labeled via an ancestor <label>, in which case that would
 57932:       // be redundant.
 89800:       HTMLLabelIterator iter(Document(), this,
 57932:                              HTMLLabelIterator::eSkipAncestorLabel);
 57932:       label = iter.Next();
 57932: 
 57932:     } else if (mContent->IsXUL()) {
 89800:       XULLabelIterator iter(Document(), mContent);
 57932:       label = iter.Next();
 57932:     }
 57932: 
 57932:     if (label)
 57932:       key = nsCoreUtils::GetAccessKeyFor(label->GetContent());
  5414:   }
  5414: 
  5414:   if (!key)
 74014:     return KeyBinding();
 74014: 
 74014:   // Get modifier mask. Use ui.key.generalAccessKey (unless it is -1).
 74014:   switch (Preferences::GetInt("ui.key.generalAccessKey", -1)) {
 74014:   case -1:
 74014:     break;
 74014:   case nsIDOMKeyEvent::DOM_VK_SHIFT:
 74014:     return KeyBinding(key, KeyBinding::kShift);
 74014:   case nsIDOMKeyEvent::DOM_VK_CONTROL:
 74014:     return KeyBinding(key, KeyBinding::kControl);
 74014:   case nsIDOMKeyEvent::DOM_VK_ALT:
 74014:     return KeyBinding(key, KeyBinding::kAlt);
 74014:   case nsIDOMKeyEvent::DOM_VK_META:
 74014:     return KeyBinding(key, KeyBinding::kMeta);
 74014:   default:
 74014:     return KeyBinding();
 74014:   }
 74014: 
 74014:   // Determine the access modifier used in this context.
 74014:   nsIDocument* document = mContent->GetCurrentDoc();
 74014:   if (!document)
 74014:     return KeyBinding();
 74014:   nsCOMPtr<nsISupports> container = document->GetContainer();
 74014:   if (!container)
 74014:     return KeyBinding();
 74014:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
 74014:   if (!treeItem)
 74014:     return KeyBinding();
 74014: 
 74014:   nsresult rv = NS_ERROR_FAILURE;
108991:   int32_t itemType = 0, modifierMask = 0;
 74014:   treeItem->GetItemType(&itemType);
 74014:   switch (itemType) {
 74014:     case nsIDocShellTreeItem::typeChrome:
 74014:       rv = Preferences::GetInt("ui.key.chromeAccess", &modifierMask);
 74014:       break;
 74014:     case nsIDocShellTreeItem::typeContent:
 74014:       rv = Preferences::GetInt("ui.key.contentAccess", &modifierMask);
 74014:       break;
 74014:   }
 74014: 
 74014:   return NS_SUCCEEDED(rv) ? KeyBinding(key, modifierMask) : KeyBinding();
 74014: }
 74014: 
 74014: KeyBinding
 99648: Accessible::KeyboardShortcut() const
 74014: {
 74014:   return KeyBinding();
     1: }
     1: 
 29320: NS_IMETHODIMP
 99648: Accessible::GetParent(nsIAccessible** aParent)
 29320: {
 35523:   NS_ENSURE_ARG_POINTER(aParent);
 74545:   if (IsDefunct())
 74545:     return NS_ERROR_FAILURE;
 74545: 
 74545:   NS_IF_ADDREF(*aParent = Parent());
 35523:   return *aParent ? NS_OK : NS_ERROR_FAILURE;
 35523: }
 35523: 
 35523:   /* readonly attribute nsIAccessible nextSibling; */
 35523: NS_IMETHODIMP
 99648: Accessible::GetNextSibling(nsIAccessible** aNextSibling)
 35523: {
 35523:   NS_ENSURE_ARG_POINTER(aNextSibling);
106838:   *aNextSibling = nullptr;
 71380: 
 71380:   if (IsDefunct())
 71380:     return NS_ERROR_FAILURE;
 35523: 
 35523:   nsresult rv = NS_OK;
 35523:   NS_IF_ADDREF(*aNextSibling = GetSiblingAtOffset(1, &rv));
 35523:   return rv;
 35523: }
 35523: 
 35523:   /* readonly attribute nsIAccessible previousSibling; */
 35523: NS_IMETHODIMP
 99648: Accessible::GetPreviousSibling(nsIAccessible ** aPreviousSibling)
 35523: {
 35523:   NS_ENSURE_ARG_POINTER(aPreviousSibling);
106838:   *aPreviousSibling = nullptr;
 71380: 
 71380:   if (IsDefunct())
 71380:     return NS_ERROR_FAILURE;
 35523: 
 35523:   nsresult rv = NS_OK;
 35523:   NS_IF_ADDREF(*aPreviousSibling = GetSiblingAtOffset(-1, &rv));
 35523:   return rv;
 35523: }
 35523: 
 35523:   /* readonly attribute nsIAccessible firstChild; */
 35523: NS_IMETHODIMP
 99648: Accessible::GetFirstChild(nsIAccessible** aFirstChild)
 35523: {
 35523:   NS_ENSURE_ARG_POINTER(aFirstChild);
106838:   *aFirstChild = nullptr;
 35523: 
 67626:   if (IsDefunct())
 67626:     return NS_ERROR_FAILURE;
 67626: 
 99463:   NS_IF_ADDREF(*aFirstChild = FirstChild());
 35136:   return NS_OK;
 35136: }
 35136: 
 35523:   /* readonly attribute nsIAccessible lastChild; */
 35523: NS_IMETHODIMP
 99648: Accessible::GetLastChild(nsIAccessible** aLastChild)
 35136: {
 35523:   NS_ENSURE_ARG_POINTER(aLastChild);
106838:   *aLastChild = nullptr;
 35523: 
 67626:   if (IsDefunct())
 67626:     return NS_ERROR_FAILURE;
 67626: 
 99463:   NS_IF_ADDREF(*aLastChild = LastChild());
 35523:   return NS_OK;
 35523: }
 35523: 
 35523: NS_IMETHODIMP
108991: Accessible::GetChildAt(int32_t aChildIndex, nsIAccessible** aChild)
 35136: {
 35523:   NS_ENSURE_ARG_POINTER(aChild);
106838:   *aChild = nullptr;
 35523: 
 67626:   if (IsDefunct())
 67626:     return NS_ERROR_FAILURE;
 67626: 
 35523:   // If child index is negative, then return last child.
 35523:   // XXX: do we really need this?
 35523:   if (aChildIndex < 0)
 99463:     aChildIndex = ChildCount() - 1;
 35523: 
 99648:   Accessible* child = GetChildAt(aChildIndex);
 35523:   if (!child)
 35523:     return NS_ERROR_INVALID_ARG;
 35523: 
 35523:   NS_ADDREF(*aChild = child);
 35523:   return NS_OK;
 35523: }
 35523: 
 35523: // readonly attribute nsIArray children;
 35523: NS_IMETHODIMP
 99648: Accessible::GetChildren(nsIArray** aOutChildren)
 35133: {
 35523:   NS_ENSURE_ARG_POINTER(aOutChildren);
106838:   *aOutChildren = nullptr;
 35523: 
 67626:   if (IsDefunct())
 67626:     return NS_ERROR_FAILURE;
 67626: 
 35523:   nsresult rv = NS_OK;
 35523:   nsCOMPtr<nsIMutableArray> children =
 35523:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
 35523:   NS_ENSURE_SUCCESS(rv, rv);
 35523: 
108991:   uint32_t childCount = ChildCount();
108991:   for (uint32_t childIdx = 0; childIdx < childCount; childIdx++) {
 35523:     nsIAccessible* child = GetChildAt(childIdx);
 80486:     children->AppendElement(child, false);
     1:   }
     1: 
     1:   NS_ADDREF(*aOutChildren = children);
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
 99648: Accessible::CanHaveAnonChildren()
     1: {
 80486:   return true;
     1: }
     1: 
     1: /* readonly attribute long childCount; */
 35523: NS_IMETHODIMP
108991: Accessible::GetChildCount(int32_t* aChildCount)
     1: {
 35523:   NS_ENSURE_ARG_POINTER(aChildCount);
 35523: 
 67626:   if (IsDefunct())
 67626:     return NS_ERROR_FAILURE;
 67626: 
 99463:   *aChildCount = ChildCount();
 99463:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute long indexInParent; */
 35523: NS_IMETHODIMP
108991: Accessible::GetIndexInParent(int32_t* aIndexInParent)
     1: {
 35523:   NS_ENSURE_ARG_POINTER(aIndexInParent);
 35523: 
 72476:   *aIndexInParent = IndexInParent();
 35523:   return *aIndexInParent != -1 ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
 88363: void 
 99648: Accessible::TranslateString(const nsString& aKey, nsAString& aStringOut)
     1: {
 98236:   nsCOMPtr<nsIStringBundleService> stringBundleService =
 98236:     services::GetStringBundleService();
 98236:   if (!stringBundleService)
 98236:     return;
 98236: 
 98236:   nsCOMPtr<nsIStringBundle> stringBundle;
 98236:   stringBundleService->CreateBundle(
 98236:     "chrome://global-platform/locale/accessible.properties", 
 98236:     getter_AddRefs(stringBundle));
 98236:   if (!stringBundle)
 98236:     return;
 98236: 
     1:   nsXPIDLString xsValue;
 98236:   nsresult rv = stringBundle->GetStringFromName(aKey.get(), getter_Copies(xsValue));
 98236:   if (NS_SUCCEEDED(rv))
     1:     aStringOut.Assign(xsValue);
     1: }
     1: 
108991: uint64_t
 99648: Accessible::VisibilityState()
     1: {
 86931:   nsIFrame* frame = GetFrame();
 87943:   if (!frame)
113953:     return states::INVISIBLE;
113953: 
113953:   // Walk the parent frame chain to see if there's invisible parent or the frame
113953:   // is in background tab.
113953:   if (!frame->GetStyleVisibility()->IsVisible())
113953:     return states::INVISIBLE;
113953: 
113953:   nsIFrame* curFrame = frame;
115110:   nsPoint framePos(0, 0);
113953:   do {
113953:     nsIView* view = curFrame->GetView();
113953:     if (view && view->GetVisibility() == nsViewVisibility_kHide)
113953:       return states::INVISIBLE;
113953: 
113953:     // Offscreen state for background tab content.
113953:     nsIFrame* parentFrame = curFrame->GetParent();
113953:     nsDeckFrame* deckFrame = do_QueryFrame(parentFrame);
113953:     if (deckFrame && deckFrame->GetSelectedBox() != curFrame)
113953:       return states::OFFSCREEN;
113953: 
115110:     // If contained by scrollable frame then check that at least 12 pixels
115110:     // around the object is visible, otherwise the object is offscreen.
115110:     framePos += curFrame->GetPosition();
115110:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(parentFrame);
115110:     if (scrollableFrame) {
115110:       nsRect scrollPortRect = scrollableFrame->GetScrollPortRect();
115110:       nsRect frameRect(framePos, frame->GetSize());
115110:       if (!scrollPortRect.Contains(frameRect)) {
115110:         const nscoord kMinPixels = nsPresContext::CSSPixelsToAppUnits(12);
115110:         scrollPortRect.Deflate(kMinPixels, kMinPixels);
115110:         if (!scrollPortRect.Intersects(frameRect))
115110:           return states::OFFSCREEN;
115110:       }
115110:     }
115110: 
113953:     if (!parentFrame) {
113953:       parentFrame = nsLayoutUtils::GetCrossDocParentFrame(curFrame);
113953:       if (parentFrame && !parentFrame->GetStyleVisibility()->IsVisible())
113953:         return states::INVISIBLE;
113953:     }
113953: 
113953:     curFrame = parentFrame;
113953:   } while (curFrame);
 86931: 
     1:   // Zero area rects can occur in the first frame of a multi-frame text flow,
 86931:   // in which case the rendered text is not empty and the frame should not be
 86931:   // marked invisible.
 86931:   // XXX Can we just remove this check? Why do we need to mark empty
 86931:   // text invisible?
 86931:   if (frame->GetType() == nsGkAtoms::textFrame &&
 86931:       !(frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
 86931:       frame->GetRect().IsEmpty()) {
  9480:     nsAutoString renderedText;
106838:     frame->GetRenderedText(&renderedText, nullptr, nullptr, 0, 1);
 86931:     if (renderedText.IsEmpty())
113953:       return states::INVISIBLE;
  9480:   }
 86931: 
113953:   return 0;
   733: }
   733: 
108991: uint64_t
 99648: Accessible::NativeState()
     1: {
108991:   uint64_t state = 0;
 74867: 
101769:   if (!IsInDocument())
 74867:     state |= states::STALE;
 74867: 
118792:   if (HasOwnContent() && mContent->IsElement()) {
 71116:     nsEventStates elementState = mContent->AsElement()->State();
 71116: 
 71116:     if (elementState.HasState(NS_EVENT_STATE_INVALID))
 67790:       state |= states::INVALID;
 55426: 
 71116:     if (elementState.HasState(NS_EVENT_STATE_REQUIRED))
 67790:       state |= states::REQUIRED;
 55425: 
100246:     state |= NativeInteractiveState();
 79384:     if (FocusMgr()->IsFocused(this))
 67790:       state |= states::FOCUSED;
 67790:   }
 67790: 
 86931:   // Gather states::INVISIBLE and states::OFFSCREEN flags for this object.
 86931:   state |= VisibilityState();
     1: 
  5707:   nsIFrame *frame = GetFrame();
106246:   if (frame) {
106246:     if (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 67790:       state |= states::FLOATING;
  5707: 
106246:     // XXX we should look at layout for non XUL box frames, but need to decide
106246:     // how that interacts with ARIA.
118792:     if (HasOwnContent() && mContent->IsXUL() && frame->IsBoxFrame()) {
106003:       const nsStyleXUL* xulStyle = frame->GetStyleXUL();
106003:       if (xulStyle && frame->IsBoxFrame()) {
106003:         // In XUL all boxes are either vertical or horizontal
106003:         if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL)
106003:           state |= states::VERTICAL;
106003:         else
106003:           state |= states::HORIZONTAL;
106003:       }
106003:     }
106246:   }
106246: 
106246:   // Check if a XUL element has the popup attribute (an attached popup menu).
118792:   if (HasOwnContent() && mContent->IsXUL() &&
118792:       mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::popup))
106246:     state |= states::HASPOPUP;
106003: 
 98724:   // Bypass the link states specialization for non links.
 98724:   if (!mRoleMapEntry || mRoleMapEntry->roleRule == kUseNativeRole ||
 98724:       mRoleMapEntry->role == roles::LINK)
 98724:     state |= NativeLinkState();
 67790: 
 67790:   return state;
     1: }
     1: 
108991: uint64_t
100246: Accessible::NativeInteractiveState() const
100246: {
100246:   if (!mContent->IsElement())
100246:     return 0;
100246: 
100246:   if (NativelyUnavailable())
100246:     return states::UNAVAILABLE;
100246: 
100246:   nsIFrame* frame = GetFrame();
100246:   if (frame && frame->IsFocusable())
100246:     return states::FOCUSABLE;
100246: 
100246:   return 0;
100246: }
100246: 
108991: uint64_t
 99648: Accessible::NativeLinkState() const
 98724: {
 98724:   // Expose linked state for simple xlink.
 98724:   return nsCoreUtils::IsXLink(mContent) ? states::LINKED : 0;
 98724: }
 98724: 
100246: bool
100246: Accessible::NativelyUnavailable() const
100246: {
100246:   if (mContent->IsHTML())
100246:     return mContent->AsElement()->State().HasState(NS_EVENT_STATE_DISABLED);
100246: 
100246:   return mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
100246:                                nsGkAtoms::_true, eCaseMatters);
100246: }
100246: 
     1:   /* readonly attribute boolean focusedChild; */
 43504: NS_IMETHODIMP
 99648: Accessible::GetFocusedChild(nsIAccessible** aChild)
     1: {
 74619:   NS_ENSURE_ARG_POINTER(aChild);
106838:   *aChild = nullptr;
 74619: 
 74619:   if (IsDefunct())
 74619:     return NS_ERROR_FAILURE;
 74619: 
 74619:   NS_IF_ADDREF(*aChild = FocusedChild());
     1:   return NS_OK;
     1: }
     1: 
 99648: Accessible*
 99648: Accessible::FocusedChild()
 74619: {
 99648:   Accessible* focus = FocusMgr()->FocusedAccessible();
 79384:   if (focus && (focus == this || focus->Parent() == this))
 79384:     return focus;
 79384: 
106838:   return nullptr;
 74619: }
 74619: 
 99648: Accessible*
108991: Accessible::ChildAtPoint(int32_t aX, int32_t aY,
 64131:                          EWhichChildAtPoint aWhichChild)
     1: {
  6068:   // If we can't find the point in a child, we will return the fallback answer:
106838:   // we return |this| if the point is within it, otherwise nullptr.
108991:   int32_t x = 0, y = 0, width = 0, height = 0;
 28197:   nsresult rv = GetBounds(&x, &y, &width, &height);
106838:   NS_ENSURE_SUCCESS(rv, nullptr);
106838: 
106838:   Accessible* fallbackAnswer = nullptr;
 28197:   if (aX >= x && aX < x + width && aY >= y && aY < y + height)
  6068:     fallbackAnswer = this;
 28197: 
 64131:   if (nsAccUtils::MustPrune(this))  // Do not dig any further
 64131:     return fallbackAnswer;
  6068: 
  5680:   // Search an accessible at the given point starting from accessible document
  5680:   // because containing block (see CSS2) for out of flow element (for example,
  5680:   // absolutely positioned element) may be different from its DOM parent and
  5680:   // therefore accessible for containing block may be different from accessible
  5680:   // for DOM parent but GetFrameForPoint() should be called for containing block
  5680:   // to get an out of flow element.
 99568:   DocAccessible* accDocument = Document();
106838:   NS_ENSURE_TRUE(accDocument, nullptr);
  5680: 
 39601:   nsIFrame *frame = accDocument->GetFrame();
106838:   NS_ENSURE_TRUE(frame, nullptr);
  5680: 
  5680:   nsPresContext *presContext = frame->PresContext();
  5680: 
 90771:   nsRect screenRect = frame->GetScreenRectInAppUnits();
 90771:   nsPoint offset(presContext->DevPixelsToAppUnits(aX) - screenRect.x,
 90771:                  presContext->DevPixelsToAppUnits(aY) - screenRect.y);
  5680: 
109366:   nsIFrame *foundFrame = nsLayoutUtils::GetFrameForPoint(frame, offset);
 28197: 
106838:   nsIContent* content = nullptr;
 64131:   if (!foundFrame || !(content = foundFrame->GetContent()))
 64131:     return fallbackAnswer;
  5680: 
 46469:   // Get accessible for the node with the point or the first accessible in
 46469:   // the DOM parent chain.
 99568:   DocAccessible* contentDocAcc = GetAccService()->
 90545:     GetDocAccessible(content->OwnerDoc());
 90886: 
 90942:   // contentDocAcc in some circumstances can be NULL. See bug 729861
 90942:   NS_ASSERTION(contentDocAcc, "could not get the document accessible");
 90942:   if (!contentDocAcc)
 90942:     return fallbackAnswer;
 90886: 
 99648:   Accessible* accessible = contentDocAcc->GetAccessibleOrContainer(content);
 64131:   if (!accessible)
 64131:     return fallbackAnswer;
  6068: 
102869:   // Hurray! We have an accessible for the frame that layout gave us.
 28197:   // Since DOM node of obtained accessible may be out of flow then we should
 28197:   // ensure obtained accessible is a child of this accessible.
 99648:   Accessible* child = accessible;
102869:   while (child != this) {
 99648:     Accessible* parent = child->Parent();
 28197:     if (!parent) {
 28197:       // Reached the top of the hierarchy. These bounds were inside an
 28197:       // accessible that is not a descendant of this one.
 64131:       return fallbackAnswer;
 64131:     }
 64131: 
102869:     // If we landed on a legitimate child of |this|, and we want the direct
102869:     // child, return it here.
102869:     if (parent == this && aWhichChild == eDirectChild)
102869:         return child;
 64131: 
 64131:     child = parent;
 64131:   }
 64131: 
102869:   // Manually walk through accessible children and see if the are within this
102869:   // point. Skip offscreen or invisible accessibles. This takes care of cases
102869:   // where layout won't walk into things for us, such as image map areas and
102869:   // sub documents (XXX: subdocuments should be handled by methods of
102869:   // OuterDocAccessibles).
108991:   uint32_t childCount = accessible->ChildCount();
108991:   for (uint32_t childIdx = 0; childIdx < childCount; childIdx++) {
102869:     Accessible* child = accessible->GetChildAt(childIdx);
102869: 
108991:     int32_t childX, childY, childWidth, childHeight;
102869:     child->GetBounds(&childX, &childY, &childWidth, &childHeight);
102869:     if (aX >= childX && aX < childX + childWidth &&
102869:         aY >= childY && aY < childY + childHeight &&
102869:         (child->State() & states::INVISIBLE) == 0) {
102869: 
102869:       if (aWhichChild == eDeepestChild)
102869:         return child->ChildAtPoint(aX, aY, eDeepestChild);
102869: 
102869:       return child;
102869:     }
102869:   }
102869: 
102869:   return accessible;
 19323: }
 19323: 
 19323: // nsIAccessible getChildAtPoint(in long x, in long y)
 19323: NS_IMETHODIMP
108991: Accessible::GetChildAtPoint(int32_t aX, int32_t aY,
 19323:                             nsIAccessible** aAccessible)
 19323: {
 28197:   NS_ENSURE_ARG_POINTER(aAccessible);
106838:   *aAccessible = nullptr;
 28197: 
 28197:   if (IsDefunct())
 28197:     return NS_ERROR_FAILURE;
 28197: 
 72477:   NS_IF_ADDREF(*aAccessible = ChildAtPoint(aX, aY, eDirectChild));
 64131:   return NS_OK;
 28197: }
 28197: 
 28197: // nsIAccessible getDeepestChildAtPoint(in long x, in long y)
 28197: NS_IMETHODIMP
108991: Accessible::GetDeepestChildAtPoint(int32_t aX, int32_t aY,
 28197:                                    nsIAccessible** aAccessible)
 28197: {
 28197:   NS_ENSURE_ARG_POINTER(aAccessible);
106838:   *aAccessible = nullptr;
 28197: 
 28197:   if (IsDefunct())
 28197:     return NS_ERROR_FAILURE;
 28197: 
 72477:   NS_IF_ADDREF(*aAccessible = ChildAtPoint(aX, aY, eDeepestChild));
 64131:   return NS_OK;
     1: }
     1: 
 99648: void
 99648: Accessible::GetBoundsRect(nsRect& aTotalBounds, nsIFrame** aBoundingFrame)
     1: {
101616:   nsIFrame* frame = GetFrame();
101616:   if (frame) {
101616:     *aBoundingFrame = nsLayoutUtils::GetContainingBlockForClientRect(frame);
101616:     aTotalBounds = nsLayoutUtils::
101616:       GetAllInFlowRectsUnion(frame, *aBoundingFrame,
101616:                              nsLayoutUtils::RECTS_ACCOUNT_FOR_TRANSFORMS);
101615:   }
101615: }
101615: 
     1: /* void getBounds (out long x, out long y, out long width, out long height); */
 55772: NS_IMETHODIMP
108991: Accessible::GetBounds(int32_t* aX, int32_t* aY,
108991:                       int32_t* aWidth, int32_t* aHeight)
     1: {
 55772:   NS_ENSURE_ARG_POINTER(aX);
 55772:   *aX = 0;
 55772:   NS_ENSURE_ARG_POINTER(aY);
 55772:   *aY = 0;
 55772:   NS_ENSURE_ARG_POINTER(aWidth);
 55772:   *aWidth = 0;
 55772:   NS_ENSURE_ARG_POINTER(aHeight);
 55772:   *aHeight = 0;
 55772: 
 55772:   if (IsDefunct())
 55772:     return NS_ERROR_FAILURE;
 55772: 
 55772:   // This routine will get the entire rectangle for all the frames in this node.
     1:   // -------------------------------------------------------------------------
     1:   //      Primary Frame for node
     1:   //  Another frame, same node                <- Example
     1:   //  Another frame, same node
     1: 
     1:   nsRect unionRectTwips;
106838:   nsIFrame* boundingFrame = nullptr;
 55772:   GetBoundsRect(unionRectTwips, &boundingFrame);   // Unions up all primary frames for this node and all siblings after it
 55772:   NS_ENSURE_STATE(boundingFrame);
 55772: 
118792:   nsPresContext* presContext = mDoc->PresContext();
 55772:   *aX = presContext->AppUnitsToDevPixels(unionRectTwips.x);
 55772:   *aY = presContext->AppUnitsToDevPixels(unionRectTwips.y);
 55772:   *aWidth = presContext->AppUnitsToDevPixels(unionRectTwips.width);
 55772:   *aHeight = presContext->AppUnitsToDevPixels(unionRectTwips.height);
     1: 
     1:   // We have the union of the rectangle, now we need to put it in absolute screen coords
 90636:   nsIntRect orgRectPixels = boundingFrame->GetScreenRectInAppUnits().
 90636:     ToNearestPixels(presContext->AppUnitsPerDevPixel());
 55772:   *aX += orgRectPixels.x;
 55772:   *aY += orgRectPixels.y;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 99648: NS_IMETHODIMP
 99648: Accessible::SetSelected(bool aSelect)
     1: {
 43504:   if (IsDefunct())
     1:     return NS_ERROR_FAILURE;
     1: 
118792:   if (!HasOwnContent())
118792:     return NS_OK;
118792: 
 99648:   Accessible* select = nsAccUtils::GetSelectableContainer(this, State());
 93302:   if (select) {
 93302:     if (select->State() & states::MULTISELECTABLE) {
  6279:       if (mRoleMapEntry) {
     1:         if (aSelect) {
 43504:           return mContent->SetAttr(kNameSpaceID_None,
 78350:                                    nsGkAtoms::aria_selected,
 80486:                                    NS_LITERAL_STRING("true"), true);
  6279:         }
 43504:         return mContent->UnsetAttr(kNameSpaceID_None,
 80486:                                    nsGkAtoms::aria_selected, true);
 43504:       }
 43504: 
 43504:       return NS_OK;
     1:     }
     1: 
 93302:     return aSelect ? TakeFocus() : NS_ERROR_FAILURE;
 93302:   }
 93302: 
 93302:   return NS_OK;
 93302: }
 93302: 
 99648: NS_IMETHODIMP
 99648: Accessible::TakeSelection()
     1: {
 43504:   if (IsDefunct())
     1:     return NS_ERROR_FAILURE;
     1: 
 99648:   Accessible* select = nsAccUtils::GetSelectableContainer(this, State());
 93302:   if (select) {
 93302:     if (select->State() & states::MULTISELECTABLE)
 93302:       select->ClearSelection();
 80486:     return SetSelected(true);
     1:   }
     1: 
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
 14605: NS_IMETHODIMP
 99648: Accessible::TakeFocus()
     1: {
 14605:   if (IsDefunct())
 14605:     return NS_ERROR_FAILURE;
 14605: 
 14605:   nsIFrame *frame = GetFrame();
 14605:   NS_ENSURE_STATE(frame);
 14605: 
 43504:   nsIContent* focusContent = mContent;
 43504: 
 84259:   // If the accessible focus is managed by container widget then focus the
 84259:   // widget and set the accessible as its current item.
 14605:   if (!frame->IsFocusable()) {
 99648:     Accessible* widget = ContainerWidget();
 84259:     if (widget && widget->AreItemsOperable()) {
 84259:       nsIContent* widgetElm = widget->GetContent();
 84259:       nsIFrame* widgetFrame = widgetElm->GetPrimaryFrame();
 84259:       if (widgetFrame && widgetFrame->IsFocusable()) {
 84259:         focusContent = widgetElm;
 84259:         widget->SetCurrentItem(this);
 14605:       }
 14605:     }
 14605:   }
 14605: 
 43504:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(focusContent));
 89948:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm)
 29018:     fm->SetFocus(element, 0);
 29018: 
     1:   return NS_OK;
     1: }
     1: 
119159: ENameValueFlag
118863: Accessible::GetHTMLName(nsString& aLabel)
     1: {
106838:   Accessible* labelAcc = nullptr;
 89800:   HTMLLabelIterator iter(Document(), this);
 57932:   while ((labelAcc = iter.Next())) {
118863:     nsTextEquivUtils::AppendTextEquivFromContent(this, labelAcc->GetContent(),
118863:                                                  &aLabel);
118863:     aLabel.CompressWhitespace();
 57932:   }
 57932: 
119159:   if (!aLabel.IsEmpty())
119159:     return eNameOK;
119159: 
118863:   nsTextEquivUtils::GetNameFromSubtree(this, aLabel);
119159:   return aLabel.IsEmpty() ? eNameOK : eNameFromSubtree;
     1: }
     1: 
     1: /**
     1:   * 3 main cases for XUL Controls to be labeled
     1:   *   1 - control contains label="foo"
     1:   *   2 - control has, as a child, a label element
     1:   *        - label has either value="foo" or children
     1:   *   3 - non-child label contains control="controlID"
     1:   *        - label has either value="foo" or children
     1:   * Once a label is found, the search is discontinued, so a control
     1:   *  that has a label child as well as having a label external to
     1:   *  the control that uses the control="controlID" syntax will use
     1:   *  the child label for its Name.
     1:   */
119159: ENameValueFlag
118863: Accessible::GetXULName(nsString& aName)
     1: {
 20246:   // CASE #1 (via label attribute) -- great majority of the cases
118863:   nsCOMPtr<nsIDOMXULLabeledControlElement> labeledEl =
118863:     do_QueryInterface(mContent);
     1:   if (labeledEl) {
118863:     labeledEl->GetLabel(aName);
118863:   } else {
118863:     nsCOMPtr<nsIDOMXULSelectControlItemElement> itemEl =
118863:       do_QueryInterface(mContent);
     1:     if (itemEl) {
118863:       itemEl->GetLabel(aName);
118863:     } else {
118863:       nsCOMPtr<nsIDOMXULSelectControlElement> select =
118863:         do_QueryInterface(mContent);
     1:       // Use label if this is not a select control element which 
     1:       // uses label attribute to indicate which option is selected
     1:       if (!select) {
 43504:         nsCOMPtr<nsIDOMXULElement> xulEl(do_QueryInterface(mContent));
118863:         if (xulEl)
118863:           xulEl->GetAttribute(NS_LITERAL_STRING("label"), aName);
     1:       }
     1:     }
     1:   }
     1: 
     1:   // CASES #2 and #3 ------ label as a child or <label control="id" ... > </label>
118863:   if (aName.IsEmpty()) {
106838:     Accessible* labelAcc = nullptr;
 89800:     XULLabelIterator iter(Document(), mContent);
 57932:     while ((labelAcc = iter.Next())) {
 57932:       nsCOMPtr<nsIDOMXULLabelElement> xulLabel =
 57932:         do_QueryInterface(labelAcc->GetContent());
     1:       // Check if label's value attribute is used
118863:       if (xulLabel && NS_SUCCEEDED(xulLabel->GetValue(aName)) && aName.IsEmpty()) {
     1:         // If no value attribute, a non-empty label must contain
 20072:         // children that define its text -- possibly using HTML
 57932:         nsTextEquivUtils::
118863:           AppendTextEquivFromContent(this, labelAcc->GetContent(), &aName);
 57932:       }
     1:     }
     1:   }
     1: 
118863:   aName.CompressWhitespace();
118863:   if (!aName.IsEmpty())
119159:     return eNameOK;
     1: 
     1:   // Can get text from title of <toolbaritem> if we're a child of a <toolbaritem>
 43504:   nsIContent *bindingParent = mContent->GetBindingParent();
     1:   nsIContent *parent = bindingParent? bindingParent->GetParent() :
 43504:                                       mContent->GetParent();
     1:   while (parent) {
 78350:     if (parent->Tag() == nsGkAtoms::toolbaritem &&
118863:         parent->GetAttr(kNameSpaceID_None, nsGkAtoms::title, aName)) {
118863:       aName.CompressWhitespace();
119159:       return eNameOK;
     1:     }
     1:     parent = parent->GetParent();
     1:   }
     1: 
118863:   nsTextEquivUtils::GetNameFromSubtree(this, aName);
119159:   return aName.IsEmpty() ? eNameOK : eNameFromSubtree;
     1: }
     1: 
 29320: nsresult
 99648: Accessible::HandleAccEvent(AccEvent* aEvent)
   511: {
   763:   NS_ENSURE_ARG_POINTER(aEvent);
   763: 
   511:   nsCOMPtr<nsIObserverService> obsService =
 41540:     mozilla::services::GetObserverService();
   511:   NS_ENSURE_TRUE(obsService, NS_ERROR_FAILURE);
   511: 
 51377:   nsCOMPtr<nsISimpleEnumerator> observers;
 51377:   obsService->EnumerateObservers(NS_ACCESSIBLE_EVENT_TOPIC,
 51377:                                  getter_AddRefs(observers));
 51377: 
 51377:   NS_ENSURE_STATE(observers);
 51377: 
 79445:   bool hasObservers = false;
 51377:   observers->HasMoreElements(&hasObservers);
 51377:   if (hasObservers) {
 51377:     nsRefPtr<nsAccEvent> evnt(aEvent->CreateXPCOMObject());
106838:     return obsService->NotifyObservers(evnt, NS_ACCESSIBLE_EVENT_TOPIC, nullptr);
 51377:   }
 51377: 
 51377:   return NS_OK;
     1: }
     1: 
 25822: NS_IMETHODIMP
108991: Accessible::GetRole(uint32_t *aRole)
     1: {
  4850:   NS_ENSURE_ARG_POINTER(aRole);
  4850:   *aRole = nsIAccessibleRole::ROLE_NOTHING;
  4850: 
 29085:   if (IsDefunct())
 29085:     return NS_ERROR_FAILURE;
 29085: 
 52053:   *aRole = Role();
 52027:   return NS_OK;
     1: }
     1: 
   401: NS_IMETHODIMP
 99648: Accessible::GetAttributes(nsIPersistentProperties** aAttributes)
     1: {
119399:   NS_ENSURE_ARG_POINTER(aAttributes);
119399:   *aAttributes = nullptr;
  8937: 
 15511:   if (IsDefunct())
 15511:     return NS_ERROR_FAILURE;
 15511: 
119399:   nsCOMPtr<nsIPersistentProperties> attributes = Attributes();
119399:   attributes.swap(*aAttributes);
119399: 
119399:   return NS_OK;
 13094: }
  4516: 
119399: already_AddRefed<nsIPersistentProperties>
119399: Accessible::Attributes()
119399: {
119399:   nsCOMPtr<nsIPersistentProperties> attributes = NativeAttributes();
119399:   if (!HasOwnContent() || !mContent->IsElement())
119399:     return attributes.forget();
119399: 
119399:   // 'xml-roles' attribute coming from ARIA.
119399:   nsAutoString xmlRoles, unused;
119399:   if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::role, xmlRoles)) {
119399:     attributes->SetStringProperty(NS_LITERAL_CSTRING("xml-roles"),
119399:                                   xmlRoles, unused);
  6844:   }
  6844: 
 25174:   // Expose object attributes from ARIA attributes.
108140:   aria::AttrIterator attribIter(mContent);
108140:   nsAutoString name, value;
119399:   while(attribIter.Next(name, value))
119399:     attributes->SetStringProperty(NS_ConvertUTF16toUTF8(name), value, unused);
 13012: 
 25174:   // If there is no aria-live attribute then expose default value of 'live'
 25174:   // object attribute used for ARIA role of this accessible.
 25174:   if (mRoleMapEntry) {
 25174:     nsAutoString live;
 78350:     nsAccUtils::GetAccAttr(attributes, nsGkAtoms::live, live);
 25174:     if (live.IsEmpty()) {
 32053:       if (nsAccUtils::GetLiveAttrValue(mRoleMapEntry->liveAttRule, live))
 78350:         nsAccUtils::SetAccAttr(attributes, nsGkAtoms::live, live);
 25174:     }
 25174:   }
 25174: 
119399:   return attributes.forget();
     1: }
     1: 
119399: already_AddRefed<nsIPersistentProperties>
119399: Accessible::NativeAttributes()
   401: {
119399:   nsCOMPtr<nsIPersistentProperties> attributes =
119399:     do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
119399: 
119399:   nsAutoString unused;
119399: 
119399:   // We support values, so expose the string value as well, via the valuetext
119399:   // object attribute. We test for the value interface because we don't want
119399:   // to expose traditional Value() information such as URL's on links and
119399:   // documents, or text in an input.
119399:   if (HasNumericValue()) {
119399:     nsAutoString valuetext;
119399:     GetValue(valuetext);
119399:     attributes->SetStringProperty(NS_LITERAL_CSTRING("valuetext"), valuetext,
119399:                                   unused);
119399:   }
119399: 
119399:   // Expose checkable object attribute if the accessible has checkable state
119399:   if (State() & states::CHECKABLE) {
119399:     nsAccUtils::SetAccAttr(attributes, nsGkAtoms::checkable,
119399:                            NS_LITERAL_STRING("true"));
119399:   }
119399: 
119399:   // Expose 'explicit-name' attribute.
120175:   nsAutoString name;
120175:   if (Name(name) != eNameFromSubtree && !name.IsVoid()) {
119399:     attributes->SetStringProperty(NS_LITERAL_CSTRING("explicit-name"),
119399:                                   NS_LITERAL_STRING("true"), unused);
119399:   }
119399: 
119399:   // Group attributes (level/setsize/posinset)
119399:   GroupPos groupPos = GroupPosition();
119399:   nsAccUtils::SetAccGroupAttrs(attributes, groupPos.level,
119399:                                groupPos.setSize, groupPos.posInSet);
119399: 
119399:   // If the accessible doesn't have own content (such as list item bullet or
119399:   // xul tree item) then don't calculate content based attributes.
118792:   if (!HasOwnContent())
119399:     return attributes.forget();
119399: 
119399:   nsEventShell::GetEventAttributes(GetNode(), attributes);
119399: 
119399:   // Get container-foo computed live region properties based on the closest
119399:   // container with the live region attribute. Inner nodes override outer nodes
119399:   // within the same document. The inner nodes can be used to override live
119399:   // region behavior on more general outer nodes. However, nodes in outer
119399:   // documents override nodes in inner documents: outer doc author may want to
119399:   // override properties on a widget they used in an iframe.
 43504:   nsIContent* startContent = mContent;
 94027:   while (startContent) {
 13094:     nsIDocument* doc = startContent->GetDocument();
119399:     if (!doc)
119399:       break;
119399: 
119399:     nsAccUtils::SetLiveContainerAttributes(attributes, startContent,
119399:                                            nsCoreUtils::GetRoleContent(doc));
 21169: 
 13094:     // Allow ARIA live region markup from outer documents to override
 13094:     nsCOMPtr<nsISupports> container = doc->GetContainer(); 
 21169:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
 21169:       do_QueryInterface(container);
 13351:     if (!docShellTreeItem)
 13351:       break;
 21169: 
 21169:     nsCOMPtr<nsIDocShellTreeItem> sameTypeParent;
 21169:     docShellTreeItem->GetSameTypeParent(getter_AddRefs(sameTypeParent));
 13094:     if (!sameTypeParent || sameTypeParent == docShellTreeItem)
 13094:       break;
 21169: 
 13094:     nsIDocument* parentDoc = doc->GetParentDocument();
 13408:     if (!parentDoc)
 13408:       break;
 21169: 
 13094:     startContent = parentDoc->FindContentForSubDocument(doc);
 13094:   }
 13094: 
 90500:   if (!mContent->IsElement())
119399:     return attributes.forget();
119399: 
119399:   nsAutoString id;
119399:   if (nsCoreUtils::GetID(mContent, id))
119399:     attributes->SetStringProperty(NS_LITERAL_CSTRING("id"), id, unused);
119399: 
119399:   // Expose class because it may have useful microformat information.
119399:   nsAutoString _class;
119399:   if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::_class, _class))
119399:     nsAccUtils::SetAccAttr(attributes, nsGkAtoms::_class, _class);
 90500: 
 94027:   // Expose tag.
 94027:   nsAutoString tagName;
 94027:   mContent->NodeInfo()->GetName(tagName);
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::tag, tagName);
119399: 
119399:   // Expose draggable object attribute.
 81041:   nsCOMPtr<nsIDOMHTMLElement> htmlElement = do_QueryInterface(mContent);
 29397:   if (htmlElement) {
 79445:     bool draggable = false;
 29397:     htmlElement->GetDraggable(&draggable);
 29397:     if (draggable) {
119399:       nsAccUtils::SetAccAttr(attributes, nsGkAtoms::draggable,
 29397:                              NS_LITERAL_STRING("true"));
 29397:     }
 29397:   }
 29397: 
 91914:   // Don't calculate CSS-based object attributes when no frame (i.e.
 94028:   // the accessible is unattached from the tree).
 94027:   if (!mContent->GetPrimaryFrame())
119399:     return attributes.forget();
 91914: 
 91914:   // CSS style based object attributes.
 91914:   nsAutoString value;
 91914:   StyleInfo styleInfo(mContent->AsElement(), mDoc->PresShell());
 91914: 
 91914:   // Expose 'display' attribute.
 91914:   styleInfo.Display(value);
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::display, value);
 91914: 
 91914:   // Expose 'text-align' attribute.
 91914:   styleInfo.TextAlign(value);
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::textAlign, value);
 91914: 
 91914:   // Expose 'text-indent' attribute.
 91914:   styleInfo.TextIndent(value);
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::textIndent, value);
 91914: 
 91914:   // Expose 'margin-left' attribute.
 91914:   styleInfo.MarginLeft(value);
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::marginLeft, value);
 91914: 
 91914:   // Expose 'margin-right' attribute.
 91914:   styleInfo.MarginRight(value);
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::marginRight, value);
 91914: 
 91914:   // Expose 'margin-top' attribute.
 91914:   styleInfo.MarginTop(value);
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::marginTop, value);
 91914: 
 91914:   // Expose 'margin-bottom' attribute.
 91914:   styleInfo.MarginBottom(value);
119399:   nsAccUtils::SetAccAttr(attributes, nsGkAtoms::marginBottom, value);
119399: 
119399:   return attributes.forget();
   401: }
   401: 
 99732: GroupPos
 99732: Accessible::GroupPosition()
 99732: {
 99732:   GroupPos groupPos;
120504:   if (!HasOwnContent())
120504:     return groupPos;
 99732: 
 99732:   // Get group position from ARIA attributes.
 99732:   nsCoreUtils::GetUIntAttr(mContent, nsGkAtoms::aria_level, &groupPos.level);
 99732:   nsCoreUtils::GetUIntAttr(mContent, nsGkAtoms::aria_setsize, &groupPos.setSize);
 99732:   nsCoreUtils::GetUIntAttr(mContent, nsGkAtoms::aria_posinset, &groupPos.posInSet);
 99732: 
 99732:   // If ARIA is missed and the accessible is visible then calculate group
 99732:   // position from hierarchy.
 99732:   if (State() & states::INVISIBLE)
 99732:     return groupPos;
 99732: 
 99732:   // Calculate group level if ARIA is missed.
 99732:   if (groupPos.level == 0) {
108991:     int32_t level = GetLevelInternal();
 99732:     if (level != 0)
 99732:       groupPos.level = level;
 99732:   }
 99732: 
 99732:   // Calculate position in group and group size if ARIA is missed.
 99732:   if (groupPos.posInSet == 0 || groupPos.setSize == 0) {
108991:     int32_t posInSet = 0, setSize = 0;
 99732:     GetPositionAndSizeInternal(&posInSet, &setSize);
 99732:     if (posInSet != 0 && setSize != 0) {
 99732:       if (groupPos.posInSet == 0)
 99732:         groupPos.posInSet = posInSet;
 99732: 
 99732:       if (groupPos.setSize == 0)
 99732:         groupPos.setSize = setSize;
 99732:     }
 99732:   }
 99732: 
 99732:   return groupPos;
 99732: }
 99732: 
   144: NS_IMETHODIMP
108991: Accessible::GroupPosition(int32_t* aGroupLevel,
108991:                           int32_t* aSimilarItemsInGroup,
108991:                           int32_t* aPositionInGroup)
   144: {
   144:   NS_ENSURE_ARG_POINTER(aGroupLevel);
 36879:   *aGroupLevel = 0;
 36879: 
   144:   NS_ENSURE_ARG_POINTER(aSimilarItemsInGroup);
 36879:   *aSimilarItemsInGroup = 0;
 36879: 
   144:   NS_ENSURE_ARG_POINTER(aPositionInGroup);
   144:   *aPositionInGroup = 0;
   144: 
 36879:   if (IsDefunct())
   757:     return NS_ERROR_FAILURE;
 36879: 
 99732:   GroupPos groupPos = GroupPosition();
 99732: 
 99732:   *aGroupLevel = groupPos.level;
 99732:   *aSimilarItemsInGroup = groupPos.setSize;
 99732:   *aPositionInGroup = groupPos.posInSet;
   144: 
   144:   return NS_OK;
   144: }
   144: 
   262: NS_IMETHODIMP
108991: Accessible::GetState(uint32_t* aState, uint32_t* aExtraState)
     1: {
   262:   NS_ENSURE_ARG_POINTER(aState);
   262: 
 67790:   nsAccUtils::To32States(State(), aState, aExtraState);
 67790:   return NS_OK;
 67790: }
 67790: 
108991: uint64_t
 99648: Accessible::State()
 67790: {
 67973:   if (IsDefunct())
 67973:     return states::DEFUNCT;
 67973: 
108991:   uint64_t state = NativeState();
 70455:   // Apply ARIA states to be sure accessible states will be overridden.
 67790:   ApplyARIAState(&state);
  4381: 
 87879:   // If this is an ARIA item of the selectable widget and if it's focused and
 87879:   // not marked unselected explicitly (i.e. aria-selected="false") then expose
 87879:   // it as selected to make ARIA widget authors life easier.
 87879:   if (mRoleMapEntry && !(state & states::SELECTED) &&
 70455:       !mContent->AttrValueIs(kNameSpaceID_None,
 78350:                              nsGkAtoms::aria_selected,
 78350:                              nsGkAtoms::_false, eCaseMatters)) {
 87879:     // Special case for tabs: focused tab or focus inside related tab panel
 87879:     // implies selected state.
 87879:     if (mRoleMapEntry->role == roles::PAGETAB) {
 67790:       if (state & states::FOCUSED) {
 67790:         state |= states::SELECTED;
  6596:       } else {
 70455:         // If focus is in a child of the tab panel surely the tab is selected!
 75194:         Relation rel = RelationByType(nsIAccessibleRelation::RELATION_LABEL_FOR);
106838:         Accessible* relTarget = nullptr;
 75194:         while ((relTarget = rel.Next())) {
 87094:           if (relTarget->Role() == roles::PROPERTYPAGE &&
 79384:               FocusMgr()->IsFocusWithin(relTarget))
 67790:             state |= states::SELECTED;
 67790:         }
 67790:       }
 87879:     } else if (state & states::FOCUSED) {
 99648:       Accessible* container = nsAccUtils::GetSelectableContainer(this, state);
 87879:       if (container &&
 87879:           !nsAccUtils::HasDefinedARIAToken(container->GetContent(),
 87879:                                            nsGkAtoms::aria_multiselectable)) {
 87879:         state |= states::SELECTED;
 87879:       }
 87879:     }
 67790:   }
 67790: 
108991:   const uint32_t kExpandCollapseStates = states::COLLAPSED | states::EXPANDED;
 67790:   if ((state & kExpandCollapseStates) == kExpandCollapseStates) {
 20128:     // Cannot be both expanded and collapsed -- this happens in ARIA expanded
 20128:     // combobox because of limitation of nsARIAMap.
 20128:     // XXX: Perhaps we will be able to make this less hacky if we support
 20128:     // extended states in nsARIAMap, e.g. derive COLLAPSED from
 20128:     // EXPANDABLE && !EXPANDED.
 67790:     state &= ~states::COLLAPSED;
 67790:   }
 67790: 
 67790:   if (!(state & states::UNAVAILABLE)) {
 67790:     state |= states::ENABLED | states::SENSITIVE;
 84145: 
 84145:     // If the object is a current item of container widget then mark it as
 84145:     // ACTIVE. This allows screen reader virtual buffer modes to know which
 84145:     // descendant is the current one that would get focus if the user navigates
 84145:     // to the container widget.
 99648:     Accessible* widget = ContainerWidget();
 84145:     if (widget && widget->CurrentItem() == this)
 84145:       state |= states::ACTIVE;
 67790:   }
 67790: 
 67790:   if ((state & states::COLLAPSED) || (state & states::EXPANDED))
 67790:     state |= states::EXPANDABLE;
  6172: 
  6172:   // For some reasons DOM node may have not a frame. We tract such accessibles
  6172:   // as invisible.
  5424:   nsIFrame *frame = GetFrame();
  6172:   if (!frame)
 67790:     return state;
  6172: 
  5424:   const nsStyleDisplay* display = frame->GetStyleDisplay();
  5424:   if (display && display->mOpacity == 1.0f &&
 67790:       !(state & states::INVISIBLE)) {
 67790:     state |= states::OPAQUE1;
  5424:   }
  5424: 
 67790:   return state;
 67790: }
 67790: 
 67790: void
108991: Accessible::ApplyARIAState(uint64_t* aState) const
   262: {
 94828:   if (!mContent->IsElement())
 94828:     return;
 94828: 
 94828:   dom::Element* element = mContent->AsElement();
 94828: 
     1:   // Test for universal states first
104204:   *aState |= aria::UniversalStatesFor(element);
   262: 
 15374:   if (mRoleMapEntry) {
 32104: 
 32104:     // We only force the readonly bit off if we have a real mapping for the aria
 32104:     // role. This preserves the ability for screen readers to use readonly
 32104:     // (primarily on the document) as the hint for creating a virtual buffer.
 87094:     if (mRoleMapEntry->role != roles::NOTHING)
 67790:       *aState &= ~states::READONLY;
 13715: 
 43504:     if (mContent->HasAttr(kNameSpaceID_None, mContent->GetIDAttributeName())) {
 13716:       // If has a role & ID and aria-activedescendant on the container, assume focusable
 43504:       nsIContent *ancestorContent = mContent;
106838:       while ((ancestorContent = ancestorContent->GetParent()) != nullptr) {
 78350:         if (ancestorContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_activedescendant)) {
 13716:             // ancestor has activedescendant property, this content could be active
 67790:           *aState |= states::FOCUSABLE;
 13716:           break;
 13716:         }
 13716:       }
 13716:     }
 15374:   }
 15374: 
 67790:   if (*aState & states::FOCUSABLE) {
 15374:     // Special case: aria-disabled propagates from ancestors down to any focusable descendant
 43504:     nsIContent *ancestorContent = mContent;
106838:     while ((ancestorContent = ancestorContent->GetParent()) != nullptr) {
 78350:       if (ancestorContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::aria_disabled,
 78350:                                        nsGkAtoms::_true, eCaseMatters)) {
 15374:           // ancestor has aria-disabled property, this is disabled
 67790:         *aState |= states::UNAVAILABLE;
 15374:         break;
 15374:       }
 15374:     }    
 15374:   }
 15374: 
 15374:   if (!mRoleMapEntry)
 67790:     return;
 13716: 
 13715:   *aState |= mRoleMapEntry->state;
 94828: 
 94828:   if (aria::MapToState(mRoleMapEntry->attributeMap1, element, aState) &&
 94828:       aria::MapToState(mRoleMapEntry->attributeMap2, element, aState))
 94828:     aria::MapToState(mRoleMapEntry->attributeMap3, element, aState);
 94828: }
     1: 
 13757: NS_IMETHODIMP
 99648: Accessible::GetValue(nsAString& aValue)
     1: {
 13757:   if (IsDefunct())
 13757:     return NS_ERROR_FAILURE;
 13757: 
 94983:   nsAutoString value;
 94983:   Value(value);
 94983:   aValue.Assign(value);
 94983: 
 94983:   return NS_OK;
 94983: }
 94983: 
 94983: void
 99648: Accessible::Value(nsString& aValue)
 94983: {
     1:   if (mRoleMapEntry) {
 94983:     if (mRoleMapEntry->valueRule == eNoValue)
 94983:       return;
 13757: 
 11394:     // aria-valuenow is a number, and aria-valuetext is the optional text equivalent
 11394:     // For the string value, we will try the optional text equivalent first
 43504:     if (!mContent->GetAttr(kNameSpaceID_None,
 78350:                            nsGkAtoms::aria_valuetext, aValue)) {
 78350:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::aria_valuenow,
 43504:                         aValue);
     1:     }
     1:   }
 13757: 
 13757:   if (!aValue.IsEmpty())
 94983:     return;
 13757: 
 20072:   // Check if it's a simple xlink.
 99308:   if (nsCoreUtils::IsXLink(mContent))
 99308:     nsContentUtils::GetLinkLocation(mContent->AsElement(), aValue);
     1: }
     1: 
  4274: // nsIAccessibleValue
  4274: NS_IMETHODIMP
 99648: Accessible::GetMaximumValue(double *aMaximumValue)
     1: {
 78350:   return GetAttrValue(nsGkAtoms::aria_valuemax, aMaximumValue);
  4274: }
  4274: 
  4274: NS_IMETHODIMP
 99648: Accessible::GetMinimumValue(double *aMinimumValue)
  4274: {
 78350:   return GetAttrValue(nsGkAtoms::aria_valuemin, aMinimumValue);
  4274: }
  4274: 
  4274: NS_IMETHODIMP
 99648: Accessible::GetMinimumIncrement(double *aMinIncrement)
  4274: {
  4274:   NS_ENSURE_ARG_POINTER(aMinIncrement);
  4274:   *aMinIncrement = 0;
  4274: 
  4274:   // No mimimum increment in dynamic content spec right now
  4274:   return NS_OK_NO_ARIA_VALUE;
  4274: }
  4274: 
  4274: NS_IMETHODIMP
 99648: Accessible::GetCurrentValue(double *aValue)
  4274: {
 78350:   return GetAttrValue(nsGkAtoms::aria_valuenow, aValue);
  4274: }
  4274: 
  4274: NS_IMETHODIMP
 99648: Accessible::SetCurrentValue(double aValue)
  4274: {
 43504:   if (IsDefunct())
 43504:     return NS_ERROR_FAILURE;
  4274: 
  4274:   if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
  4274:     return NS_OK_NO_ARIA_VALUE;
  4274: 
108991:   const uint32_t kValueCannotChange = states::READONLY | states::UNAVAILABLE;
 67790: 
 67790:   if (State() & kValueCannotChange)
     1:     return NS_ERROR_FAILURE;
  4274: 
  4274:   double minValue = 0;
  4274:   if (NS_SUCCEEDED(GetMinimumValue(&minValue)) && aValue < minValue)
     1:     return NS_ERROR_INVALID_ARG;
  4274: 
  4274:   double maxValue = 0;
  4274:   if (NS_SUCCEEDED(GetMaximumValue(&maxValue)) && aValue > maxValue)
     1:     return NS_ERROR_INVALID_ARG;
  4274: 
     1:   nsAutoString newValue;
     1:   newValue.AppendFloat(aValue);
 43504:   return mContent->SetAttr(kNameSpaceID_None,
 80486:                            nsGkAtoms::aria_valuenow, newValue, true);
  6279: }
     1: 
     1: /* void setName (in DOMString name); */
 99648: NS_IMETHODIMP
 99648: Accessible::SetName(const nsAString& aName)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: NS_IMETHODIMP
101616: Accessible::GetKeyboardShortcut(nsAString& aKeyBinding)
     1: {
     1:   aKeyBinding.Truncate();
 74014:   if (IsDefunct())
 74014:     return NS_ERROR_FAILURE;
 74014: 
 74014:   KeyboardShortcut().ToString(aKeyBinding);
     1:   return NS_OK;
     1: }
     1: 
 87094: role
 99648: Accessible::ARIATransformRole(role aRole)
 52053: {
 52053:   // XXX: these unfortunate exceptions don't fit into the ARIA table. This is
 52053:   // where the accessible role depends on both the role and ARIA state.
 94423:   if (aRole == roles::PUSHBUTTON) {
 78350:     if (nsAccUtils::HasDefinedARIAToken(mContent, nsGkAtoms::aria_pressed)) {
 52053:       // For simplicity, any existing pressed attribute except "" or "undefined"
 52053:       // indicates a toggle.
 87094:       return roles::TOGGLE_BUTTON;
 52053:     }
 52053: 
 52053:     if (mContent->AttrValueIs(kNameSpaceID_None,
 78350:                               nsGkAtoms::aria_haspopup,
 78350:                               nsGkAtoms::_true,
 52053:                               eCaseMatters)) {
 52053:       // For button with aria-haspopup="true".
 87094:       return roles::BUTTONMENU;
 52053:     }
 52053: 
 94423:   } else if (aRole == roles::LISTBOX) {
 52053:     // A listbox inside of a combobox needs a special role because of ATK
 52053:     // mapping to menu.
 87094:     if (mParent && mParent->Role() == roles::COMBOBOX) {
 87094:       return roles::COMBOBOX_LIST;
 52053: 
 75194:       Relation rel = RelationByType(nsIAccessibleRelation::RELATION_NODE_CHILD_OF);
106838:       Accessible* targetAcc = nullptr;
 75194:       while ((targetAcc = rel.Next()))
 87094:         if (targetAcc->Role() == roles::COMBOBOX)
 87094:           return roles::COMBOBOX_LIST;
 52053:     }
 52053: 
 94423:   } else if (aRole == roles::OPTION) {
 87094:     if (mParent && mParent->Role() == roles::COMBOBOX_LIST)
 87094:       return roles::COMBOBOX_OPTION;
 52053:   }
 52053: 
 94423:   return aRole;
 52053: }
 52053: 
 87094: role
 99648: Accessible::NativeRole()
     1: {
 87094:   return nsCoreUtils::IsXLink(mContent) ? roles::LINK : roles::NOTHING;
     1: }
     1: 
108991: // readonly attribute uint8_t actionCount
 13129: NS_IMETHODIMP
108991: Accessible::GetActionCount(uint8_t* aActionCount)
     1: {
 74781:   NS_ENSURE_ARG_POINTER(aActionCount);
 74781:   *aActionCount = 0;
 13129:   if (IsDefunct())
 13129:     return NS_ERROR_FAILURE;
 13129: 
 74781:   *aActionCount = ActionCount();
 15309:   return NS_OK;
 74781: }
 74781: 
108991: uint8_t
 99648: Accessible::ActionCount()
 74781: {
100246:   return GetActionRule() == eNoAction ? 0 : 1;
 13757: }
 13757: 
108991: /* DOMString getAccActionName (in uint8_t index); */
 13129: NS_IMETHODIMP
108991: Accessible::GetActionName(uint8_t aIndex, nsAString& aName)
     1: {
 13129:   aName.Truncate();
 13129: 
 13129:   if (aIndex != 0)
 13129:     return NS_ERROR_INVALID_ARG;
 13129: 
 13129:   if (IsDefunct())
     1:     return NS_ERROR_FAILURE;
 13129: 
108991:   uint32_t actionRule = GetActionRule();
 20140: 
 20140:  switch (actionRule) {
 20140:    case eActivateAction:
 20140:      aName.AssignLiteral("activate");
 20140:      return NS_OK;
 20140: 
 20140:    case eClickAction:
 20140:      aName.AssignLiteral("click");
 20140:      return NS_OK;
 20140: 
 89285:    case ePressAction:
 89285:      aName.AssignLiteral("press");
 89285:      return NS_OK;
 89285: 
 20140:    case eCheckUncheckAction:
100246:    {
108991:      uint64_t state = State();
100246:      if (state & states::CHECKED)
 25968:        aName.AssignLiteral("uncheck");
100246:      else if (state & states::MIXED)
 25871:        aName.AssignLiteral("cycle");
 20140:      else
 20140:        aName.AssignLiteral("check");
 20140:      return NS_OK;
100246:    }
 20140: 
 20140:    case eJumpAction:
 13757:      aName.AssignLiteral("jump");
 13757:      return NS_OK;
 20140: 
 20140:    case eOpenCloseAction:
100246:      if (State() & states::COLLAPSED)
 20140:        aName.AssignLiteral("open");
 20140:      else
 20140:        aName.AssignLiteral("close");
 13129:      return NS_OK;
 20140: 
 20140:    case eSelectAction:
 20140:      aName.AssignLiteral("select");
 20140:      return NS_OK;
 20140: 
 20140:    case eSwitchAction:
 20140:      aName.AssignLiteral("switch");
 20140:      return NS_OK;
 27511: 
 27511:    case eSortAction:
 27511:      aName.AssignLiteral("sort");
 27511:      return NS_OK;
 27511: 
 27511:    case eExpandAction:
100246:      if (State() & states::COLLAPSED)
 27511:        aName.AssignLiteral("expand");
 27511:      else
 27511:        aName.AssignLiteral("collapse");
 27511:      return NS_OK;
 13129:   }
 13129: 
 13129:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
108991: // AString getActionDescription(in uint8_t index)
 13129: NS_IMETHODIMP
108991: Accessible::GetActionDescription(uint8_t aIndex, nsAString& aDescription)
     1: {
     1:   // default to localized action name.
     1:   nsAutoString name;
     1:   nsresult rv = GetActionName(aIndex, name);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 88363:   TranslateString(name, aDescription);
 88363:   return NS_OK;
     1: }
     1: 
108991: // void doAction(in uint8_t index)
 13129: NS_IMETHODIMP
108991: Accessible::DoAction(uint8_t aIndex)
     1: {
 13129:   if (aIndex != 0)
 13129:     return NS_ERROR_INVALID_ARG;
 13129: 
 13129:   if (IsDefunct())
     1:     return NS_ERROR_FAILURE;
 13129: 
100246:   if (GetActionRule() != eNoAction) {
 37481:     DoCommand();
 37481:     return NS_OK;
 20140:   }
 13129: 
 13129:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
     1: /* DOMString getHelp (); */
 99648: NS_IMETHODIMP Accessible::GetHelp(nsAString& _retval)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
 75194: nsIContent*
 99648: Accessible::GetAtomicRegion() const
  6066: {
 43504:   nsIContent *loopContent = mContent;
  6066:   nsAutoString atomic;
 78350:   while (loopContent && !loopContent->GetAttr(kNameSpaceID_None, nsGkAtoms::aria_atomic, atomic))
  6066:     loopContent = loopContent->GetParent();
 75194: 
106838:   return atomic.EqualsLiteral("true") ? loopContent : nullptr;
  6066: }
     1: 
 24822: // nsIAccessible getRelationByType()
 24822: NS_IMETHODIMP
108991: Accessible::GetRelationByType(uint32_t aType,
 24822:                                 nsIAccessibleRelation** aRelation)
     1: {
 24822:   NS_ENSURE_ARG_POINTER(aRelation);
106838:   *aRelation = nullptr;
 24822:   if (IsDefunct())
 24822:     return NS_ERROR_FAILURE;
 24822: 
 75194:   Relation rel = RelationByType(aType);
 75194:   NS_ADDREF(*aRelation = new nsAccessibleRelation(aType, &rel));
 75194:   return *aRelation ? NS_OK : NS_ERROR_FAILURE;
 75194: }
 75194: 
 75194: Relation
108991: Accessible::RelationByType(uint32_t aType)
 75194: {
120504:   if (!HasOwnContent())
120504:     return Relation();
120504: 
 24822:   // Relationships are defined on the same content node that the role would be
 24822:   // defined on.
 75194:   switch (aType) {
 75194:     case nsIAccessibleRelation::RELATION_LABEL_FOR: {
 89800:       Relation rel(new RelatedAccIterator(Document(), mContent,
 78350:                                           nsGkAtoms::aria_labelledby));
 78350:       if (mContent->Tag() == nsGkAtoms::label)
 93856:         rel.AppendIter(new IDRefsIterator(mDoc, mContent, mContent->IsHTML() ?
 78350:                                           nsGkAtoms::_for :
 78350:                                           nsGkAtoms::control));
 75194: 
 75194:       return rel;
 75194:     }
 75194:     case nsIAccessibleRelation::RELATION_LABELLED_BY: {
 93856:       Relation rel(new IDRefsIterator(mDoc, mContent,
 78350:                                       nsGkAtoms::aria_labelledby));
 57932:       if (mContent->IsHTML()) {
 89800:         rel.AppendIter(new HTMLLabelIterator(Document(), this));
 75194:       } else if (mContent->IsXUL()) {
 89800:         rel.AppendIter(new XULLabelIterator(Document(), mContent));
 75194:       }
 75194: 
 75194:       return rel;
 75194:     }
 75194:     case nsIAccessibleRelation::RELATION_DESCRIBED_BY: {
 93856:       Relation rel(new IDRefsIterator(mDoc, mContent,
 78350:                                       nsGkAtoms::aria_describedby));
 75194:       if (mContent->IsXUL())
 89800:         rel.AppendIter(new XULDescriptionIterator(Document(), mContent));
 75194: 
 75194:       return rel;
 75194:     }
 75194:     case nsIAccessibleRelation::RELATION_DESCRIPTION_FOR: {
 89800:       Relation rel(new RelatedAccIterator(Document(), mContent,
 78350:                                           nsGkAtoms::aria_describedby));
 75194: 
     1:       // This affectively adds an optional control attribute to xul:description,
     1:       // which only affects accessibility, by allowing the description to be
     1:       // tied to a control.
 78350:       if (mContent->Tag() == nsGkAtoms::description &&
 75194:           mContent->IsXUL())
 93856:         rel.AppendIter(new IDRefsIterator(mDoc, mContent,
 78350:                                           nsGkAtoms::control));
 75194: 
 75194:       return rel;
 75194:     }
 75194:     case nsIAccessibleRelation::RELATION_NODE_CHILD_OF: {
 89800:       Relation rel(new RelatedAccIterator(Document(), mContent,
 78350:                                           nsGkAtoms::aria_owns));
 24822:       
 34028:       // This is an ARIA tree or treegrid that doesn't use owns, so we need to
 34028:       // get the parent the hard way.
 87094:       if (mRoleMapEntry && (mRoleMapEntry->role == roles::OUTLINEITEM || 
 87094:                             mRoleMapEntry->role == roles::ROW)) {
 47172:         AccGroupInfo* groupInfo = GetGroupInfo();
 47172:         if (!groupInfo)
 75194:           return rel;
 75194: 
 75194:         rel.AppendTarget(groupInfo->ConceptualParent());
 24822:       }
 24822: 
 30527:       // If accessible is in its own Window, or is the root of a document,
 30527:       // then we should provide NODE_CHILD_OF relation so that MSAA clients
 30527:       // can easily get to true parent instead of getting to oleacc's
 30527:       // ROLE_WINDOW accessible which will prevent us from going up further
 30527:       // (because it is system generated and has no idea about the hierarchy
 30527:       // above it).
 12642:       nsIFrame *frame = GetFrame();
 12642:       if (frame) {
 12642:         nsIView *view = frame->GetViewExternal();
 12642:         if (view) {
 23554:           nsIScrollableFrame *scrollFrame = do_QueryFrame(frame);
 74545:           if (scrollFrame || view->GetWidget() || !frame->GetParent())
 75194:             rel.AppendTarget(Parent());
 75194:         }
 75194:       }
 75194: 
 75194:       return rel;
 75194:     }
  1628:     case nsIAccessibleRelation::RELATION_CONTROLLED_BY:
 89800:       return Relation(new RelatedAccIterator(Document(), mContent,
 78350:                                              nsGkAtoms::aria_controls));
 75194:     case nsIAccessibleRelation::RELATION_CONTROLLER_FOR: {
 93856:       Relation rel(new IDRefsIterator(mDoc, mContent,
 78350:                                       nsGkAtoms::aria_controls));
 89800:       rel.AppendIter(new HTMLOutputIterator(Document(), mContent));
 75194:       return rel;
 75194:     }
  1628:     case nsIAccessibleRelation::RELATION_FLOWS_TO:
 93856:       return Relation(new IDRefsIterator(mDoc, mContent,
 78350:                                          nsGkAtoms::aria_flowto));
  1628:     case nsIAccessibleRelation::RELATION_FLOWS_FROM:
 89800:       return Relation(new RelatedAccIterator(Document(), mContent,
 78350:                                              nsGkAtoms::aria_flowto));
 75194:     case nsIAccessibleRelation::RELATION_DEFAULT_BUTTON: {
 43504:       if (mContent->IsHTML()) {
  4451:         // HTML form controls implements nsIFormControl interface.
 43504:         nsCOMPtr<nsIFormControl> control(do_QueryInterface(mContent));
  4451:         if (control) {
 47802:           nsCOMPtr<nsIForm> form(do_QueryInterface(control->GetFormElement()));
 24822:           if (form) {
 24822:             nsCOMPtr<nsIContent> formContent =
 24822:               do_QueryInterface(form->GetDefaultSubmitElement());
 97941:             return Relation(mDoc, formContent);
 75194:           }
 75194:         }
 75194:       } else {
     1:         // In XUL, use first <button default="true" .../> in the document
 43504:         nsCOMPtr<nsIDOMXULDocument> xulDoc =
 80526:           do_QueryInterface(mContent->OwnerDoc());
     1:         nsCOMPtr<nsIDOMXULButtonElement> buttonEl;
     1:         if (xulDoc) {
     1:           nsCOMPtr<nsIDOMNodeList> possibleDefaultButtons;
     1:           xulDoc->GetElementsByAttribute(NS_LITERAL_STRING("default"),
     1:                                          NS_LITERAL_STRING("true"),
     1:                                          getter_AddRefs(possibleDefaultButtons));
     1:           if (possibleDefaultButtons) {
108991:             uint32_t length;
     1:             possibleDefaultButtons->GetLength(&length);
     1:             nsCOMPtr<nsIDOMNode> possibleButton;
     1:             // Check for button in list of default="true" elements
108991:             for (uint32_t count = 0; count < length && !buttonEl; count ++) {
     1:               possibleDefaultButtons->Item(count, getter_AddRefs(possibleButton));
     1:               buttonEl = do_QueryInterface(possibleButton);
     1:             }
     1:           }
     1:           if (!buttonEl) { // Check for anonymous accept button in <dialog>
 99618:             dom::Element* rootElm = mContent->OwnerDoc()->GetRootElement();
 99618:             if (rootElm) {
 99618:               nsIContent* possibleButtonEl = rootElm->OwnerDoc()->
 99618:                 GetAnonymousElementByAttribute(rootElm, nsGkAtoms::_default,
 99618:                                                NS_LITERAL_STRING("true"));
     1:               buttonEl = do_QueryInterface(possibleButtonEl);
     1:             }
     1:           }
 24822:           nsCOMPtr<nsIContent> relatedContent(do_QueryInterface(buttonEl));
 97941:           return Relation(mDoc, relatedContent);
 75194:         }
 75194:       }
 75194:       return Relation();
 75194:     }
  4516:     case nsIAccessibleRelation::RELATION_MEMBER_OF:
 97941:       return Relation(mDoc, GetAtomicRegion());
 28489:     case nsIAccessibleRelation::RELATION_SUBWINDOW_OF:
 28489:     case nsIAccessibleRelation::RELATION_EMBEDS:
 28489:     case nsIAccessibleRelation::RELATION_EMBEDDED_BY:
 28489:     case nsIAccessibleRelation::RELATION_POPUP_FOR:
 28489:     case nsIAccessibleRelation::RELATION_PARENT_WINDOW_OF:
     1:     default:
 75194:     return Relation();
 24822:   }
     1: }
     1: 
  1628: NS_IMETHODIMP
 99648: Accessible::GetRelations(nsIArray **aRelations)
  1628: {
  1628:   NS_ENSURE_ARG_POINTER(aRelations);
106838:   *aRelations = nullptr;
 75194: 
 75194:   if (IsDefunct())
 75194:     return NS_ERROR_FAILURE;
  1628: 
  1628:   nsCOMPtr<nsIMutableArray> relations = do_CreateInstance(NS_ARRAY_CONTRACTID);
  1628:   NS_ENSURE_TRUE(relations, NS_ERROR_OUT_OF_MEMORY);
  1628: 
108991:   for (uint32_t relType = nsIAccessibleRelation::RELATION_FIRST;
  5475:        relType < nsIAccessibleRelation::RELATION_LAST;
  5475:        ++relType) {
 24822: 
 24822:     nsCOMPtr<nsIAccessibleRelation> relation;
 24822:     nsresult rv = GetRelationByType(relType, getter_AddRefs(relation));
 24822: 
 75194:     if (NS_SUCCEEDED(rv) && relation) {
108991:       uint32_t targets = 0;
 75194:       relation->GetTargetsCount(&targets);
 75194:       if (targets)
 80486:         relations->AppendElement(relation, false);
  1628:     }
 75194:   }
  1628: 
  1628:   NS_ADDREF(*aRelations = relations);
  1628:   return NS_OK;
  1628: }
  1628: 
     1: /* void extendSelection (); */
 99648: NS_IMETHODIMP Accessible::ExtendSelection()
     1: {
     1:   // XXX Should be implemented, but not high priority
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* [noscript] void getNativeInterface(out voidPtr aOutAccessible); */
 99648: NS_IMETHODIMP Accessible::GetNativeInterface(void **aOutAccessible)
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
 37481: void
108991: Accessible::DoCommand(nsIContent *aContent, uint32_t aActionIndex)
 31673: {
 43504:   nsIContent* content = aContent ? aContent : mContent.get();
 43504:   NS_DISPATCH_RUNNABLEMETHOD_ARG2(DispatchClickEvent, this, content,
 43504:                                   aActionIndex);
 31673: }
 31673: 
 31673: void
108991: Accessible::DispatchClickEvent(nsIContent *aContent, uint32_t aActionIndex)
 31673: {
 31673:   if (IsDefunct())
     1:     return;
 16427: 
 89799:   nsIPresShell* presShell = mDoc->PresShell();
 16427: 
 16427:   // Scroll into view.
 93554:   presShell->ScrollContentIntoView(aContent,
 93554:                                    nsIPresShell::ScrollAxis(),
 93554:                                    nsIPresShell::ScrollAxis(),
 56647:                                    nsIPresShell::SCROLL_OVERFLOW_HIDDEN);
 16427: 
 16427:   // Fire mouse down and mouse up events.
 79445:   bool res = nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, presShell,
 31673:                                                aContent);
 16427:   if (!res)
 16427:     return;
 16427: 
 31673:   nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_UP, presShell, aContent);
     1: }
     1: 
 89598: NS_IMETHODIMP
108991: Accessible::ScrollTo(uint32_t aHow)
 89598: {
 98119:   if (IsDefunct())
 98119:     return NS_ERROR_FAILURE;
 98119: 
 95103:   nsCoreUtils::ScrollTo(mDoc->PresShell(), mContent, aHow);
 89598:   return NS_OK;
 89598: }
 89598: 
 89598: NS_IMETHODIMP
108991: Accessible::ScrollToPoint(uint32_t aCoordinateType, int32_t aX, int32_t aY)
 89598: {
 89598:   nsIFrame *frame = GetFrame();
 89598:   if (!frame)
 89598:     return NS_ERROR_FAILURE;
 89598: 
 89598:   nsIntPoint coords;
 89598:   nsresult rv = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordinateType,
 89598:                                                   this, &coords);
 89598:   NS_ENSURE_SUCCESS(rv, rv);
 89598: 
 89598:   nsIFrame *parentFrame = frame;
 89598:   while ((parentFrame = parentFrame->GetParent()))
 89598:     nsCoreUtils::ScrollFrameToPoint(parentFrame, frame, coords);
 89598: 
 89598:   return NS_OK;
 89598: }
 89598: 
     1: // nsIAccessibleSelectable
 99648: NS_IMETHODIMP
 99648: Accessible::GetSelectedChildren(nsIArray** aSelectedAccessibles)
     1: {
 51865:   NS_ENSURE_ARG_POINTER(aSelectedAccessibles);
106838:   *aSelectedAccessibles = nullptr;
     1: 
 51865:   if (IsDefunct() || !IsSelect())
 51865:     return NS_ERROR_FAILURE;
 51865: 
 51865:   nsCOMPtr<nsIArray> items = SelectedItems();
 51865:   if (items) {
108991:     uint32_t length = 0;
 51865:     items->GetLength(&length);
 51865:     if (length)
 51865:       items.swap(*aSelectedAccessibles);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // return the nth selected descendant nsIAccessible object
 99648: NS_IMETHODIMP
108991: Accessible::RefSelection(int32_t aIndex, nsIAccessible** aSelected)
     1: {
 42494:   NS_ENSURE_ARG_POINTER(aSelected);
106838:   *aSelected = nullptr;
 42494: 
 51865:   if (IsDefunct() || !IsSelect())
 51865:     return NS_ERROR_FAILURE;
 51865: 
     1:   if (aIndex < 0) {
 42494:     return NS_ERROR_INVALID_ARG;
 42494:   }
 42494: 
 51865:   *aSelected = GetSelectedItem(aIndex);
 51865:   if (*aSelected) {
 51865:     NS_ADDREF(*aSelected);
 51865:     return NS_OK;
 51865:   }
 51865: 
 42494:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
 99648: NS_IMETHODIMP
108991: Accessible::GetSelectionCount(int32_t* aSelectionCount)
     1: {
 42494:   NS_ENSURE_ARG_POINTER(aSelectionCount);
     1:   *aSelectionCount = 0;
 42494: 
 51865:   if (IsDefunct() || !IsSelect())
 51865:     return NS_ERROR_FAILURE;
 51865: 
 51865:   *aSelectionCount = SelectedItemCount();
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP Accessible::AddChildToSelection(int32_t aIndex)
     1: {
 51865:   if (IsDefunct() || !IsSelect())
 51865:     return NS_ERROR_FAILURE;
 51865: 
 51865:   return aIndex >= 0 && AddItemToSelection(aIndex) ?
 51865:     NS_OK : NS_ERROR_INVALID_ARG;
     1: }
     1: 
108991: NS_IMETHODIMP Accessible::RemoveChildFromSelection(int32_t aIndex)
     1: {
 51865:   if (IsDefunct() || !IsSelect())
 51865:     return NS_ERROR_FAILURE;
 51865: 
 51865:   return aIndex >=0 && RemoveItemFromSelection(aIndex) ?
 51865:     NS_OK : NS_ERROR_INVALID_ARG;
     1: }
     1: 
108991: NS_IMETHODIMP Accessible::IsChildSelected(int32_t aIndex, bool *aIsSelected)
     1: {
 51865:   NS_ENSURE_ARG_POINTER(aIsSelected);
 80486:   *aIsSelected = false;
 51865: 
 51865:   if (IsDefunct() || !IsSelect())
 51865:     return NS_ERROR_FAILURE;
 51865: 
     1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
     1: 
 51865:   *aIsSelected = IsItemSelected(aIndex);
     1:   return NS_OK;
     1: }
     1: 
 42494: NS_IMETHODIMP
 99648: Accessible::ClearSelection()
     1: {
 51865:   if (IsDefunct() || !IsSelect())
 51865:     return NS_ERROR_FAILURE;
 51865: 
 51865:   UnselectAll();
     1:   return NS_OK;
     1: }
     1: 
 51865: NS_IMETHODIMP
 99648: Accessible::SelectAllSelection(bool* aIsMultiSelect)
     1: {
 51865:   NS_ENSURE_ARG_POINTER(aIsMultiSelect);
 80486:   *aIsMultiSelect = false;
 51865: 
 51865:   if (IsDefunct() || !IsSelect())
 51865:     return NS_ERROR_FAILURE;
 51865: 
 51865:   *aIsMultiSelect = SelectAll();
     1:   return NS_OK;
     1: }
     1: 
     1: // nsIAccessibleHyperLink
     1: // Because of new-atk design, any embedded object in text can implement
     1: // nsIAccessibleHyperLink, which helps determine where it is located
     1: // within containing text
     1: 
 14223: // readonly attribute long nsIAccessibleHyperLink::anchorCount
 13749: NS_IMETHODIMP
108991: Accessible::GetAnchorCount(int32_t *aAnchorCount)
     1: {
 14223:   NS_ENSURE_ARG_POINTER(aAnchorCount);
 51810:   *aAnchorCount = 0;
 51810: 
 51810:   if (IsDefunct())
 51810:     return NS_ERROR_FAILURE;
 51810: 
 51810:   *aAnchorCount = AnchorCount();
     1:   return NS_OK;
     1: }
     1: 
 13749: // readonly attribute long nsIAccessibleHyperLink::startIndex
 13749: NS_IMETHODIMP
108991: Accessible::GetStartIndex(int32_t *aStartIndex)
     1: {
 13749:   NS_ENSURE_ARG_POINTER(aStartIndex);
     1:   *aStartIndex = 0;
 42376: 
 42376:   if (IsDefunct())
 42376:     return NS_ERROR_FAILURE;
 42376: 
 51810:   *aStartIndex = StartOffset();
 51810:   return NS_OK;
     1: }
     1: 
 13749: // readonly attribute long nsIAccessibleHyperLink::endIndex
 13749: NS_IMETHODIMP
108991: Accessible::GetEndIndex(int32_t *aEndIndex)
     1: {
 13749:   NS_ENSURE_ARG_POINTER(aEndIndex);
     1:   *aEndIndex = 0;
 42376: 
 42376:   if (IsDefunct())
 42376:     return NS_ERROR_FAILURE;
 42376: 
 51810:   *aEndIndex = EndOffset();
 51810:   return NS_OK;
     1: }
     1: 
 13749: NS_IMETHODIMP
108991: Accessible::GetURI(int32_t aIndex, nsIURI **aURI)
     1: {
 13749:   NS_ENSURE_ARG_POINTER(aURI);
 51810: 
 51810:   if (IsDefunct())
 51810:     return NS_ERROR_FAILURE;
 51810: 
108991:   if (aIndex < 0 || aIndex >= static_cast<int32_t>(AnchorCount()))
 13757:     return NS_ERROR_INVALID_ARG;
 13757: 
 72954:   nsRefPtr<nsIURI>(AnchorURIAt(aIndex)).forget(aURI);
 13757:   return NS_OK;
 13757: }
 13757: 
     1: 
 13749: NS_IMETHODIMP
108991: Accessible::GetAnchor(int32_t aIndex, nsIAccessible** aAccessible)
     1: {
 13730:   NS_ENSURE_ARG_POINTER(aAccessible);
106838:   *aAccessible = nullptr;
 13730: 
 51810:   if (IsDefunct())
 51810:     return NS_ERROR_FAILURE;
 51810: 
108991:   if (aIndex < 0 || aIndex >= static_cast<int32_t>(AnchorCount()))
 13730:     return NS_ERROR_INVALID_ARG;
 13730: 
 72483:   NS_IF_ADDREF(*aAccessible = AnchorAt(aIndex));
     1:   return NS_OK;
     1: }
     1: 
 13749: // readonly attribute boolean nsIAccessibleHyperLink::valid
 13749: NS_IMETHODIMP
 99648: Accessible::GetValid(bool *aValid)
     1: {
 13749:   NS_ENSURE_ARG_POINTER(aValid);
 80486:   *aValid = false;
 51810: 
 51810:   if (IsDefunct())
 51810:     return NS_ERROR_FAILURE;
 51810: 
 72481:   *aValid = IsLinkValid();
     1:   return NS_OK;
     1: }
     1: 
 13749: // readonly attribute boolean nsIAccessibleHyperLink::selected
 13749: NS_IMETHODIMP
 99648: Accessible::GetSelected(bool *aSelected)
     1: {
 13749:   NS_ENSURE_ARG_POINTER(aSelected);
 80486:   *aSelected = false;
 51810: 
 51810:   if (IsDefunct())
 51810:     return NS_ERROR_FAILURE;
 51810: 
 72480:   *aSelected = IsLinkSelected();
     1:   return NS_OK;
 51810: 
     1: }
     1: 
 61682: void
108991: Accessible::AppendTextTo(nsAString& aText, uint32_t aStartOffset,
108991:                          uint32_t aLength)
   460: {
 43441:   // Return text representation of non-text accessible within hypertext
 43441:   // accessible. Text accessible overrides this method to return enclosed text.
 61682:   if (aStartOffset != 0 || aLength == 0)
 61682:     return;
 43441: 
 43441:   nsIFrame *frame = GetFrame();
 61682:   if (!frame)
 61682:     return;
 43441: 
 99697:   NS_ASSERTION(mParent,
 99697:                "Called on accessible unbound from tree. Result can be wrong.");
 99697: 
 78350:   if (frame->GetType() == nsGkAtoms::brFrame) {
 43441:     aText += kForcedNewLineChar;
 99697:   } else if (mParent && nsAccUtils::MustPrune(mParent)) {
 61842:     // Expose the embedded object accessible as imaginary embedded object
 61842:     // character if its parent hypertext accessible doesn't expose children to
 61842:     // AT.
 43441:     aText += kImaginaryEmbeddedObjectChar;
 43441:   } else {
 43441:     aText += kEmbeddedObjectChar;
 43441:   }
     1: }
     1: 
 20246: ////////////////////////////////////////////////////////////////////////////////
 43538: // nsAccessNode public methods
 43538: 
 43538: void
 99648: Accessible::Shutdown()
 43538: {
 94274:   // Mark the accessible as defunct, invalidate the child count and pointers to 
 94274:   // other accessibles, also make sure none of its children point to this parent
 94274:   mFlags |= eIsDefunct;
 94274: 
 43538:   InvalidateChildren();
 56292:   if (mParent)
 56292:     mParent->RemoveChild(this);
 43538: 
 43538:   nsAccessNodeWrap::Shutdown();
 43538: }
 43538: 
118792: // Accessible protected
118792: void
119159: Accessible::ARIAName(nsString& aName)
 20246: {
 49044:   // aria-labelledby now takes precedence over aria-label
 25175:   nsresult rv = nsTextEquivUtils::
119159:     GetTextEquivFromIDRefs(this, nsGkAtoms::aria_labelledby, aName);
 25175:   if (NS_SUCCEEDED(rv)) {
119159:     aName.CompressWhitespace();
 25175:   }
 20246: 
119159:   if (aName.IsEmpty() &&
119159:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::aria_label, aName)) {
119159:     aName.CompressWhitespace();
 49044:   }
 20246: }
 20246: 
118863: // Accessible protected
118863: ENameValueFlag
118863: Accessible::NativeName(nsString& aName)
 20246: {
 43504:   if (mContent->IsHTML())
119159:     return GetHTMLName(aName);
119159: 
119159:   if (mContent->IsXUL())
119159:     return GetXULName(aName);
118863: 
118863:   return eNameOK;
 20246: }
 20246: 
 99648: // Accessible protected
 35523: void
108991: Accessible::BindToParent(Accessible* aParent, uint32_t aIndexInParent)
 35523: {
 35523:   NS_PRECONDITION(aParent, "This method isn't used to set null parent!");
 35523: 
 56292:   if (mParent) {
 56292:     if (mParent != aParent) {
 56292:       NS_ERROR("Adopting child!");
 64129:       mParent->RemoveChild(this);
 56292:     } else {
 56292:       NS_ERROR("Binding to the same parent!");
 56292:       return;
 56292:     }
 35523:   }
 35523: 
 35523:   mParent = aParent;
 47105:   mIndexInParent = aIndexInParent;
 35523: }
 35523: 
118863: // Accessible protected
 35523: void
 99648: Accessible::UnbindFromParent()
 47803: {
106838:   mParent = nullptr;
 47803:   mIndexInParent = -1;
 50622:   mIndexOfEmbeddedChild = -1;
106838:   mGroupInfo = nullptr;
 47803: }
 47803: 
118863: ////////////////////////////////////////////////////////////////////////////////
118863: // Accessible public methods
118863: 
 47803: void
 99648: Accessible::InvalidateChildren()
 35523: {
108991:   int32_t childCount = mChildren.Length();
108991:   for (int32_t childIdx = 0; childIdx < childCount; childIdx++) {
 99648:     Accessible* child = mChildren.ElementAt(childIdx);
 47105:     child->UnbindFromParent();
 35523:   }
 35523: 
106838:   mEmbeddedObjCollector = nullptr;
 35523:   mChildren.Clear();
 61466:   SetChildrenFlag(eChildrenUninitialized);
 35523: }
 35523: 
 79445: bool
 99648: Accessible::AppendChild(Accessible* aChild)
 47105: {
 57147:   if (!aChild)
 80486:     return false;
 57147: 
 47105:   if (!mChildren.AppendElement(aChild))
 80486:     return false;
 47105: 
 54948:   if (!nsAccUtils::IsEmbeddedObject(aChild))
 61466:     SetChildrenFlag(eMixedChildren);
 50622: 
 47105:   aChild->BindToParent(this, mChildren.Length() - 1);
 80486:   return true;
 47105: }
 47105: 
 79445: bool
108991: Accessible::InsertChildAt(uint32_t aIndex, Accessible* aChild)
 47105: {
 57147:   if (!aChild)
 80486:     return false;
 57147: 
 47105:   if (!mChildren.InsertElementAt(aIndex, aChild))
 80486:     return false;
 47105: 
108991:   for (uint32_t idx = aIndex + 1; idx < mChildren.Length(); idx++) {
 57147:     NS_ASSERTION(mChildren[idx]->mIndexInParent == idx - 1, "Accessible child index doesn't match");
 57147:     mChildren[idx]->mIndexInParent = idx;
 57147:   }
 47105: 
 50622:   if (nsAccUtils::IsText(aChild))
 61466:     SetChildrenFlag(eMixedChildren);
 50622: 
106838:   mEmbeddedObjCollector = nullptr;
 50622: 
 47105:   aChild->BindToParent(this, aIndex);
 80486:   return true;
 47105: }
 47105: 
 79445: bool
 99648: Accessible::RemoveChild(Accessible* aChild)
 47105: {
 57147:   if (!aChild)
 80486:     return false;
 57147: 
 67790:   if (aChild->mParent != this || aChild->mIndexInParent == -1)
 80486:     return false;
 47105: 
108991:   uint32_t index = static_cast<uint32_t>(aChild->mIndexInParent);
 57147:   if (index >= mChildren.Length() || mChildren[index] != aChild) {
 56426:     NS_ERROR("Child is bound to parent but parent hasn't this child at its index!");
 56426:     aChild->UnbindFromParent();
 80486:     return false;
 56426:   }
 56426: 
108991:   for (uint32_t idx = index + 1; idx < mChildren.Length(); idx++) {
 57147:     NS_ASSERTION(mChildren[idx]->mIndexInParent == idx, "Accessible child index doesn't match");
 57147:     mChildren[idx]->mIndexInParent = idx - 1;
 57147:   }
 57147: 
 57147:   aChild->UnbindFromParent();
 57147:   mChildren.RemoveElementAt(index);
106838:   mEmbeddedObjCollector = nullptr;
 50622: 
 80486:   return true;
 47105: }
 47105: 
 99648: Accessible*
108991: Accessible::GetChildAt(uint32_t aIndex)
 35523: {
106838:   Accessible* child = mChildren.SafeElementAt(aIndex, nullptr);
 35523:   if (!child)
106838:     return nullptr;
 35523: 
 35523: #ifdef DEBUG
 99648:   Accessible* realParent = child->mParent;
 35523:   NS_ASSERTION(!realParent || realParent == this,
 35523:                "Two accessibles have the same first child accessible!");
 35523: #endif
 35523: 
 35523:   return child;
 35523: }
 35523: 
108991: uint32_t
 99648: Accessible::ChildCount() const
 35523: {
 67626:   return mChildren.Length();
 35523: }
 35523: 
108991: int32_t
 99648: Accessible::GetIndexOf(Accessible* aChild)
 35523: {
 72476:   return (aChild->mParent != this) ? -1 : aChild->IndexInParent();
 35523: }
 35523: 
108991: int32_t
 99648: Accessible::IndexInParent() const
 35523: {
 47105:   return mIndexInParent;
 36989: }
 36989: 
108991: uint32_t
 99648: Accessible::EmbeddedChildCount()
 50622: {
 61466:   if (IsChildrenFlag(eMixedChildren)) {
 50622:     if (!mEmbeddedObjCollector)
 50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
 99463:     return mEmbeddedObjCollector->Count();
 99463:   }
 99463: 
 99463:   return ChildCount();
 50622: }
 50622: 
 99648: Accessible*
108991: Accessible::GetEmbeddedChildAt(uint32_t aIndex)
 50622: {
 61466:   if (IsChildrenFlag(eMixedChildren)) {
 50622:     if (!mEmbeddedObjCollector)
 50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
 50622:     return mEmbeddedObjCollector ?
106838:       mEmbeddedObjCollector->GetAccessibleAt(aIndex) : nullptr;
 50622:   }
 50622: 
 50622:   return GetChildAt(aIndex);
 50622: }
 50622: 
108991: int32_t
 99648: Accessible::GetIndexOfEmbeddedChild(Accessible* aChild)
 50622: {
 61466:   if (IsChildrenFlag(eMixedChildren)) {
 50622:     if (!mEmbeddedObjCollector)
 50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
 50622:     return mEmbeddedObjCollector ?
 50622:       mEmbeddedObjCollector->GetIndexAt(aChild) : -1;
 50622:   }
 50622: 
 50622:   return GetIndexOf(aChild);
 50622: }
 50622: 
 20246: ////////////////////////////////////////////////////////////////////////////////
 51810: // HyperLinkAccessible methods
 51810: 
 51810: bool
 99648: Accessible::IsLink()
 51810: {
 51810:   // Every embedded accessible within hypertext accessible implements
 51810:   // hyperlink interface.
 61468:   return mParent && mParent->IsHyperText() && nsAccUtils::IsEmbeddedObject(this);
 51810: }
 51810: 
108991: uint32_t
 99648: Accessible::StartOffset()
 51810: {
 72484:   NS_PRECONDITION(IsLink(), "StartOffset is called not on hyper link!");
 51810: 
106838:   HyperTextAccessible* hyperText = mParent ? mParent->AsHyperText() : nullptr;
 51810:   return hyperText ? hyperText->GetChildOffset(this) : 0;
 51810: }
 51810: 
108991: uint32_t
 99648: Accessible::EndOffset()
 51810: {
 72484:   NS_PRECONDITION(IsLink(), "EndOffset is called on not hyper link!");
 51810: 
106838:   HyperTextAccessible* hyperText = mParent ? mParent->AsHyperText() : nullptr;
 51810:   return hyperText ? (hyperText->GetChildOffset(this) + 1) : 0;
 51810: }
 51810: 
 79384: bool
 99648: Accessible::IsLinkSelected()
 79384: {
 79384:   NS_PRECONDITION(IsLink(),
 79384:                   "IsLinkSelected() called on something that is not a hyper link!");
 79384:   return FocusMgr()->IsFocused(this);
 79384: }
 79384: 
108991: uint32_t
 99648: Accessible::AnchorCount()
 51810: {
 72484:   NS_PRECONDITION(IsLink(), "AnchorCount is called on not hyper link!");
 51810:   return 1;
 51810: }
 51810: 
 99648: Accessible*
108991: Accessible::AnchorAt(uint32_t aAnchorIndex)
 51810: {
 72484:   NS_PRECONDITION(IsLink(), "GetAnchor is called on not hyper link!");
106838:   return aAnchorIndex == 0 ? this : nullptr;
 51810: }
 51810: 
 51810: already_AddRefed<nsIURI>
108991: Accessible::AnchorURIAt(uint32_t aAnchorIndex)
 51810: {
 72484:   NS_PRECONDITION(IsLink(), "AnchorURIAt is called on not hyper link!");
 51810: 
 51810:   if (aAnchorIndex != 0)
106838:     return nullptr;
 51810: 
 51810:   // Check if it's a simple xlink.
 51810:   if (nsCoreUtils::IsXLink(mContent)) {
 51810:     nsAutoString href;
 78350:     mContent->GetAttr(kNameSpaceID_XLink, nsGkAtoms::href, href);
 51810: 
 51810:     nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
 80526:     nsCOMPtr<nsIDocument> document = mContent->OwnerDoc();
106838:     nsIURI* anchorURI = nullptr;
 51810:     NS_NewURI(&anchorURI, href,
106838:               document ? document->GetDocumentCharacterSet().get() : nullptr,
 51810:               baseURI);
 51810:     return anchorURI;
 51810:   }
 51810: 
106838:   return nullptr;
 51810: }
 51810: 
 51865: 
 51865: ////////////////////////////////////////////////////////////////////////////////
 51865: // SelectAccessible
 51865: 
 51865: bool
 99648: Accessible::IsSelect()
 51865: {
 51865:   // If we have an ARIA role attribute present and the role allows multi
 51865:   // selectable state, then we need to support SelectAccessible interface. If
 51865:   // either attribute (role or multiselectable) change, then we'll destroy this
 51865:   // accessible so that we can follow COM identity rules.
 51865: 
 51865:   return mRoleMapEntry &&
 94828:     (mRoleMapEntry->attributeMap1 == aria::eARIAMultiSelectable ||
 94828:      mRoleMapEntry->attributeMap2 == aria::eARIAMultiSelectable ||
 94828:      mRoleMapEntry->attributeMap3 == aria::eARIAMultiSelectable);
 51865: }
 51865: 
 51865: already_AddRefed<nsIArray>
 99648: Accessible::SelectedItems()
 51865: {
 51865:   nsCOMPtr<nsIMutableArray> selectedItems = do_CreateInstance(NS_ARRAY_CONTRACTID);
 51865:   if (!selectedItems)
106838:     return nullptr;
 51865: 
110522:   AccIterator iter(this, filters::GetSelected);
106838:   nsIAccessible* selected = nullptr;
 75194:   while ((selected = iter.Next()))
 80486:     selectedItems->AppendElement(selected, false);
 51865: 
106838:   nsIMutableArray* items = nullptr;
 51865:   selectedItems.forget(&items);
 51865:   return items;
 51865: }
 51865: 
108991: uint32_t
 99648: Accessible::SelectedItemCount()
 51865: {
108991:   uint32_t count = 0;
110522:   AccIterator iter(this, filters::GetSelected);
106838:   Accessible* selected = nullptr;
 75194:   while ((selected = iter.Next()))
 51865:     ++count;
 51865: 
 51865:   return count;
 51865: }
 51865: 
 99648: Accessible*
108991: Accessible::GetSelectedItem(uint32_t aIndex)
 51865: {
110522:   AccIterator iter(this, filters::GetSelected);
106838:   Accessible* selected = nullptr;
 51865: 
108991:   uint32_t index = 0;
 75194:   while ((selected = iter.Next()) && index < aIndex)
 51865:     index++;
 51865: 
 51865:   return selected;
 51865: }
 51865: 
 51865: bool
108991: Accessible::IsItemSelected(uint32_t aIndex)
 51865: {
108991:   uint32_t index = 0;
110522:   AccIterator iter(this, filters::GetSelectable);
106838:   Accessible* selected = nullptr;
 75194:   while ((selected = iter.Next()) && index < aIndex)
 51865:     index++;
 51865: 
 51865:   return selected &&
 67790:     selected->State() & states::SELECTED;
 51865: }
 51865: 
 51865: bool
108991: Accessible::AddItemToSelection(uint32_t aIndex)
 51865: {
108991:   uint32_t index = 0;
110522:   AccIterator iter(this, filters::GetSelectable);
106838:   Accessible* selected = nullptr;
 75194:   while ((selected = iter.Next()) && index < aIndex)
 51865:     index++;
 51865: 
 51865:   if (selected)
 80486:     selected->SetSelected(true);
 51865: 
 51865:   return static_cast<bool>(selected);
 51865: }
 51865: 
 51865: bool
108991: Accessible::RemoveItemFromSelection(uint32_t aIndex)
 51865: {
108991:   uint32_t index = 0;
110522:   AccIterator iter(this, filters::GetSelectable);
106838:   Accessible* selected = nullptr;
 75194:   while ((selected = iter.Next()) && index < aIndex)
 51865:     index++;
 51865: 
 51865:   if (selected)
 80486:     selected->SetSelected(false);
 51865: 
 51865:   return static_cast<bool>(selected);
 51865: }
 51865: 
 51865: bool
 99648: Accessible::SelectAll()
 51865: {
 51865:   bool success = false;
106838:   Accessible* selectable = nullptr;
 51865: 
110522:   AccIterator iter(this, filters::GetSelectable);
 75194:   while((selectable = iter.Next())) {
 51865:     success = true;
 80486:     selectable->SetSelected(true);
 51865:   }
 51865:   return success;
 51865: }
 51865: 
 51865: bool
 99648: Accessible::UnselectAll()
 51865: {
 51865:   bool success = false;
106838:   Accessible* selected = nullptr;
 51865: 
110522:   AccIterator iter(this, filters::GetSelected);
 75194:   while ((selected = iter.Next())) {
 51865:     success = true;
 80486:     selected->SetSelected(false);
 51865:   }
 51865:   return success;
 51865: }
 51865: 
 79384: ////////////////////////////////////////////////////////////////////////////////
 79384: // Widgets
 79384: 
 79384: bool
 99648: Accessible::IsWidget() const
 79384: {
 79384:   return false;
 79384: }
 79384: 
 79384: bool
 99648: Accessible::IsActiveWidget() const
 79384: {
111153:   if (FocusMgr()->HasDOMFocus(mContent))
111153:     return true;
111153: 
111153:   // If text entry of combobox widget has a focus then the combobox widget is
111153:   // active.
111153:   if (mRoleMapEntry && mRoleMapEntry->Is(nsGkAtoms::combobox)) {
111335:     uint32_t childCount = ChildCount();
111335:     for (uint32_t idx = 0; idx < childCount; idx++) {
111153:       Accessible* child = mChildren.ElementAt(idx);
111153:       if (child->Role() == roles::ENTRY)
111153:         return FocusMgr()->HasDOMFocus(child->GetContent());
111153:     }
111153:   }
111153: 
111153:   return false;
 79384: }
 79384: 
 79384: bool
 99648: Accessible::AreItemsOperable() const
 79384: {
120504:   return HasOwnContent() &&
120504:     mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_activedescendant);
 79384: }
 79384: 
 99648: Accessible*
 99648: Accessible::CurrentItem()
 79384: {
 79384:   // Check for aria-activedescendant, which changes which element has focus.
 79384:   // For activedescendant, the ARIA spec does not require that the user agent
 79384:   // checks whether pointed node is actually a DOM descendant of the element
 79384:   // with the aria-activedescendant attribute.
 79384:   nsAutoString id;
120504:   if (HasOwnContent() &&
120504:       mContent->GetAttr(kNameSpaceID_None,
 79384:                         nsGkAtoms::aria_activedescendant, id)) {
 80526:     nsIDocument* DOMDoc = mContent->OwnerDoc();
 79384:     dom::Element* activeDescendantElm = DOMDoc->GetElementById(id);
 79384:     if (activeDescendantElm) {
 99568:       DocAccessible* document = Document();
 79384:       if (document)
 79384:         return document->GetAccessible(activeDescendantElm);
 79384:     }
 79384:   }
106838:   return nullptr;
 79384: }
 79384: 
 84259: void
 99648: Accessible::SetCurrentItem(Accessible* aItem)
 84259: {
 84259:   nsIAtom* id = aItem->GetContent()->GetID();
 84259:   if (id) {
 84259:     nsAutoString idStr;
 84259:     id->ToString(idStr);
 84259:     mContent->SetAttr(kNameSpaceID_None,
 84259:                       nsGkAtoms::aria_activedescendant, idStr, true);
 84259:   }
 84259: }
 84259: 
 99648: Accessible*
 99648: Accessible::ContainerWidget() const
 79384: {
 87821:   if (HasARIARole() && mContent->HasID()) {
 99648:     for (Accessible* parent = Parent(); parent; parent = parent->Parent()) {
 79384:       nsIContent* parentContent = parent->GetContent();
 79384:       if (parentContent &&
 79384:         parentContent->HasAttr(kNameSpaceID_None,
 79384:                                nsGkAtoms::aria_activedescendant)) {
 79384:         return parent;
 79384:       }
 84145: 
 84145:       // Don't cross DOM document boundaries.
 84145:       if (parent->IsDocumentNode())
 84145:         break;
 84145:     }
 79384:   }
106838:   return nullptr;
 79384: }
 51865: 
 51810: ////////////////////////////////////////////////////////////////////////////////
 99648: // Accessible protected methods
 35523: 
 35523: void
 99648: Accessible::CacheChildren()
 35523: {
 99568:   DocAccessible* doc = Document();
114160:   NS_ENSURE_TRUE_VOID(doc);
 89799: 
 89801:   nsAccTreeWalker walker(doc, mContent, CanHaveAnonChildren());
 38358: 
106838:   Accessible* child = nullptr;
 64506:   while ((child = walker.NextChild()) && AppendChild(child));
 35523: }
 35523: 
 35523: void
 99648: Accessible::TestChildCache(Accessible* aCachedChild) const
 35523: {
 38000: #ifdef DEBUG
108991:   int32_t childCount = mChildren.Length();
 35523:   if (childCount == 0) {
 61466:     NS_ASSERTION(IsChildrenFlag(eChildrenUninitialized),
 50622:                  "No children but initialized!");
 35523:     return;
 35523:   }
 35523: 
106838:   Accessible* child = nullptr;
108991:   for (int32_t childIdx = 0; childIdx < childCount; childIdx++) {
 39144:     child = mChildren[childIdx];
 35523:     if (child == aCachedChild)
 35523:       break;
 35523:   }
 35523: 
 35523:   NS_ASSERTION(child == aCachedChild,
 35523:                "[TestChildCache] cached accessible wasn't found. Wrong accessible tree!");  
 35523: #endif
 35523: }
 35523: 
 99648: // Accessible public
 61463: bool
 99648: Accessible::EnsureChildren()
 35523: {
 35523:   if (IsDefunct()) {
 61466:     SetChildrenFlag(eChildrenUninitialized);
 61463:     return true;
 35523:   }
 35523: 
 61466:   if (!IsChildrenFlag(eChildrenUninitialized))
 61463:     return false;
 35523: 
 50622:   // State is embedded children until text leaf accessible is appended.
 61466:   SetChildrenFlag(eEmbeddedChildren); // Prevent reentry
 57890: 
 35523:   CacheChildren();
 61463:   return false;
 35523: }
 35523: 
 99648: Accessible*
108991: Accessible::GetSiblingAtOffset(int32_t aOffset, nsresult* aError) const
 35523: {
 71380:   if (!mParent || mIndexInParent == -1) {
 35523:     if (aError)
 35523:       *aError = NS_ERROR_UNEXPECTED;
 35523: 
106838:     return nullptr;
 35523:   }
 35523: 
 99463:   if (aError &&
108991:       mIndexInParent + aOffset >= static_cast<int32_t>(mParent->ChildCount())) {
 35523:     *aError = NS_OK; // fail peacefully
106838:     return nullptr;
 35523:   }
 71380: 
 99648:   Accessible* child = mParent->GetChildAt(mIndexInParent + aOffset);
 35523:   if (aError && !child)
 35523:     *aError = NS_ERROR_UNEXPECTED;
 35523: 
 35523:   return child;
 35523: }
 20246: 
 99648: Accessible* 
 99648: Accessible::GetFirstAvailableAccessible(nsINode *aStartNode) const
     1: {
 99648:   Accessible* accessible = mDoc->GetAccessible(aStartNode);
 34455:   if (accessible)
 42795:     return accessible;
 34455: 
 80526:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aStartNode->OwnerDoc());
106838:   NS_ENSURE_TRUE(domDoc, nullptr);
 64000: 
 64000:   nsCOMPtr<nsIDOMNode> currentNode = do_QueryInterface(aStartNode);
 69899:   nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(GetNode());
 64000:   nsCOMPtr<nsIDOMTreeWalker> walker;
 69899:   domDoc->CreateTreeWalker(rootNode,
 64000:                            nsIDOMNodeFilter::SHOW_ELEMENT | nsIDOMNodeFilter::SHOW_TEXT,
106838:                            nullptr, false, getter_AddRefs(walker));
106838:   NS_ENSURE_TRUE(walker, nullptr);
 64000: 
 64000:   walker->SetCurrentNode(currentNode);
 64000:   while (true) {
 64000:     walker->NextNode(getter_AddRefs(currentNode));
 64000:     if (!currentNode)
106838:       return nullptr;
 64000: 
 64000:     nsCOMPtr<nsINode> node(do_QueryInterface(currentNode));
 99648:     Accessible* accessible = mDoc->GetAccessible(node);
 64000:     if (accessible)
 64000:       return accessible;
 64000:   }
 64000: 
106838:   return nullptr;
     1: }
     1: 
  4274: nsresult
 99648: Accessible::GetAttrValue(nsIAtom *aProperty, double *aValue)
  4274: {
  4274:   NS_ENSURE_ARG_POINTER(aValue);
  4274:   *aValue = 0;
  4274: 
 28024:   if (IsDefunct())
  4274:     return NS_ERROR_FAILURE;  // Node already shut down
  4274: 
  4274:  if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
  4274:     return NS_OK_NO_ARIA_VALUE;
  4274: 
 28024:   nsAutoString attrValue;
 43504:   mContent->GetAttr(kNameSpaceID_None, aProperty, attrValue);
 28024: 
 28024:   // Return zero value if there is no attribute or its value is empty.
 28024:   if (attrValue.IsEmpty())
 28024:     return NS_OK;
 28024: 
106878:   nsresult error = NS_OK;
 63877:   double value = attrValue.ToDouble(&error);
 28024:   if (NS_SUCCEEDED(error))
 28024:     *aValue = value;
 28024: 
 28024:   return NS_OK;
  4274: }
  4274: 
108991: uint32_t
100246: Accessible::GetActionRule()
 20140: {
120698:   if (!HasOwnContent() || (InteractiveState() & states::UNAVAILABLE))
 20140:     return eNoAction;
 20140: 
 20140:   // Check if it's simple xlink.
 43504:   if (nsCoreUtils::IsXLink(mContent))
 20140:     return eJumpAction;
 20140: 
 31782:   // Return "click" action on elements that have an attached popup menu.
 43504:   if (mContent->IsXUL())
 78350:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::popup))
 31782:       return eClickAction;
 31782: 
 20140:   // Has registered 'click' event handler.
 79445:   bool isOnclick = nsCoreUtils::HasClickListener(mContent);
 20140: 
 20140:   if (isOnclick)
 20140:     return eClickAction;
 20140:   
 20140:   // Get an action based on ARIA role.
 27511:   if (mRoleMapEntry &&
 27511:       mRoleMapEntry->actionRule != eNoAction)
 20140:     return mRoleMapEntry->actionRule;
 20140: 
 27511:   // Get an action based on ARIA attribute.
 43504:   if (nsAccUtils::HasDefinedARIAToken(mContent,
 78350:                                       nsGkAtoms::aria_expanded))
 27511:     return eExpandAction;
 27511: 
 20140:   return eNoAction;
 20140: }
 23326: 
 47172: AccGroupInfo*
 99648: Accessible::GetGroupInfo()
 47172: {
 47172:   if (mGroupInfo)
 47172:     return mGroupInfo;
 47172: 
 47172:   mGroupInfo = AccGroupInfo::CreateGroupInfo(this);
 47172:   return mGroupInfo;
 47172: }
 47172: 
 36879: void
108991: Accessible::GetPositionAndSizeInternal(int32_t *aPosInSet, int32_t *aSetSize)
 23326: {
 47172:   AccGroupInfo* groupInfo = GetGroupInfo();
 47172:   if (groupInfo) {
 47172:     *aPosInSet = groupInfo->PosInSet();
 47172:     *aSetSize = groupInfo->SetSize();
 47172:   }
 36879: }
 36879: 
108991: int32_t
 99648: Accessible::GetLevelInternal()
 36879: {
108991:   int32_t level = nsAccUtils::GetDefaultLevel(this);
 37109: 
 74545:   if (!IsBoundToParent())
 74545:     return level;
 74545: 
 87094:   roles::Role role = Role();
 87094:   if (role == roles::OUTLINEITEM) {
 23326:     // Always expose 'level' attribute for 'outlineitem' accessible. The number
 23326:     // of nested 'grouping' accessibles containing 'outlineitem' accessible is
 23326:     // its level.
 37109:     level = 1;
 37109: 
 99648:     Accessible* parent = this;
 74545:     while ((parent = parent->Parent())) {
 87094:       roles::Role parentRole = parent->Role();
 87094: 
 87094:       if (parentRole == roles::OUTLINE)
 23326:         break;
 87094:       if (parentRole == roles::GROUPING)
 36879:         ++ level;
 23326: 
 23326:     }
 36879: 
 87094:   } else if (role == roles::LISTITEM) {
 23326:     // Expose 'level' attribute on nested lists. We assume nested list is a last
 23326:     // child of listitem of parent list. We don't handle the case when nested
 23326:     // lists have more complex structure, for example when there are accessibles
 23326:     // between parent listitem and nested list.
 23326: 
 23326:     // Calculate 'level' attribute based on number of parent listitems.
 37109:     level = 0;
 99648:     Accessible* parent = this;
 74545:     while ((parent = parent->Parent())) {
 87094:       roles::Role parentRole = parent->Role();
 87094: 
 87094:       if (parentRole == roles::LISTITEM)
 36879:         ++ level;
 87094:       else if (parentRole != roles::LIST)
 23326:         break;
 23326: 
 23326:     }
 23326: 
 36879:     if (level == 0) {
 23326:       // If this listitem is on top of nested lists then expose 'level'
 23326:       // attribute.
 74545:       parent = Parent();
108991:       uint32_t siblingCount = parent->ChildCount();
108991:       for (uint32_t siblingIdx = 0; siblingIdx < siblingCount; siblingIdx++) {
 99648:         Accessible* sibling = parent->GetChildAt(siblingIdx);
 99648: 
 99648:         Accessible* siblingChild = sibling->LastChild();
 87094:         if (siblingChild && siblingChild->Role() == roles::LIST)
 74545:           return 1;
 23326:       }
 36879:     } else {
 36879:       ++ level; // level is 1-index based
 36879:     }
 37109:   }
 36879: 
 36879:   return level;
 36879: }
 74014: 
 74014: 
 74014: ////////////////////////////////////////////////////////////////////////////////
 74014: // KeyBinding class
 74014: 
 74014: void
 74014: KeyBinding::ToPlatformFormat(nsAString& aValue) const
 74014: {
 74014:   nsCOMPtr<nsIStringBundle> keyStringBundle;
 74014:   nsCOMPtr<nsIStringBundleService> stringBundleService =
 74014:       mozilla::services::GetStringBundleService();
 74014:   if (stringBundleService)
 98236:     stringBundleService->CreateBundle(
 98236:       "chrome://global-platform/locale/platformKeys.properties",
 74014:       getter_AddRefs(keyStringBundle));
 74014: 
 74014:   if (!keyStringBundle)
 74014:     return;
 74014: 
 74014:   nsAutoString separator;
 74014:   keyStringBundle->GetStringFromName(NS_LITERAL_STRING("MODIFIER_SEPARATOR").get(),
 74014:                                      getter_Copies(separator));
 74014: 
 74014:   nsAutoString modifierName;
 74014:   if (mModifierMask & kControl) {
 74014:     keyStringBundle->GetStringFromName(NS_LITERAL_STRING("VK_CONTROL").get(),
 74014:                                        getter_Copies(modifierName));
 74014: 
 74014:     aValue.Append(modifierName);
 74014:     aValue.Append(separator);
 74014:   }
 74014: 
 74014:   if (mModifierMask & kAlt) {
 74014:     keyStringBundle->GetStringFromName(NS_LITERAL_STRING("VK_ALT").get(),
 74014:                                        getter_Copies(modifierName));
 74014: 
 74014:     aValue.Append(modifierName);
 74014:     aValue.Append(separator);
 74014:   }
 74014: 
 74014:   if (mModifierMask & kShift) {
 74014:     keyStringBundle->GetStringFromName(NS_LITERAL_STRING("VK_SHIFT").get(),
 74014:                                        getter_Copies(modifierName));
 74014: 
 74014:     aValue.Append(modifierName);
 74014:     aValue.Append(separator);
 74014:   }
 74014: 
 74014:   if (mModifierMask & kMeta) {
 74014:     keyStringBundle->GetStringFromName(NS_LITERAL_STRING("VK_META").get(),
 74014:                                        getter_Copies(modifierName));
 74014: 
 74014:     aValue.Append(modifierName);
 74014:     aValue.Append(separator);
 74014:   }
 74014: 
 74014:   aValue.Append(mKey);
 74014: }
 74014: 
 74014: void
 74014: KeyBinding::ToAtkFormat(nsAString& aValue) const
 74014: {
 74014:   nsAutoString modifierName;
 74014:   if (mModifierMask & kControl)
 74014:     aValue.Append(NS_LITERAL_STRING("<Control>"));
 74014: 
 74014:   if (mModifierMask & kAlt)
 74014:     aValue.Append(NS_LITERAL_STRING("<Alt>"));
 74014: 
 74014:   if (mModifierMask & kShift)
 74014:     aValue.Append(NS_LITERAL_STRING("<Shift>"));
 74014: 
 74014:   if (mModifierMask & kMeta)
 74014:       aValue.Append(NS_LITERAL_STRING("<Meta>"));
 74014: 
 74014:   aValue.Append(mKey);
 74014: }
108140: 
