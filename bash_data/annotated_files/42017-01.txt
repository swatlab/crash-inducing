37311: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
37311:  * vim: sw=2 ts=2 et :
35835:  * ***** BEGIN LICENSE BLOCK *****
35835:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35835:  *
35835:  * The contents of this file are subject to the Mozilla Public License Version
35835:  * 1.1 (the "License"); you may not use this file except in compliance with
35835:  * the License. You may obtain a copy of the License at
35835:  * http://www.mozilla.org/MPL/
35835:  *
35835:  * Software distributed under the License is distributed on an "AS IS" basis,
35835:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35835:  * for the specific language governing rights and limitations under the
35835:  * License.
35835:  *
35835:  * The Original Code is Mozilla Plugin App.
35835:  *
35835:  * The Initial Developer of the Original Code is
35835:  *   Ben Turner <bent.mozilla@gmail.com>
35835:  * Portions created by the Initial Developer are Copyright (C) 2009
35835:  * the Initial Developer. All Rights Reserved.
35835:  *
35835:  * Contributor(s):
35835:  *
35835:  * Alternatively, the contents of this file may be used under the terms of
35835:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35835:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35835:  * in which case the provisions of the GPL or the LGPL are applicable instead
35835:  * of those above. If you wish to allow use of your version of this file only
35835:  * under the terms of either the GPL or the LGPL, and not to allow others to
35835:  * use your version of this file under the terms of the MPL, indicate your
35835:  * decision by deleting the provisions above and replace them with the notice
35835:  * and other provisions required by the GPL or the LGPL. If you do not delete
35835:  * the provisions above, a recipient may use your version of this file under
35835:  * the terms of any one of the MPL, the GPL or the LGPL.
35835:  *
35835:  * ***** END LICENSE BLOCK ***** */
35835: 
35945: #include "PluginScriptableObjectParent.h"
37311: #include "PluginScriptableObjectUtils.h"
35945: 
41382: #include "mozilla/unused.h"
41382: 
35945: using namespace mozilla::plugins;
35945: 
35945: namespace {
35945: 
35965: inline void
35965: ReleaseVariant(NPVariant& aVariant,
35965:                PluginInstanceParent* aInstance)
35965: {
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(aInstance);
35965:   if (npn) {
35965:     npn->releasevariantvalue(&aVariant);
35965:   }
35965: }
35965: 
39742: inline PPluginIdentifierParent*
39742: GetIdentifier(PluginInstanceParent* aInstance,
35965:               NPIdentifier aIdentifier)
35965: {
36010:   PluginModuleParent* module = aInstance->Module();
35965:   if (!module) {
35965:     NS_WARNING("Huh?!");
35965:     return false;
35965:   }
35965: 
39742:   return module->GetIdentifierForNPIdentifier(aIdentifier);
35965: }
35965: 
39742: inline PPluginIdentifierParent*
39742: GetIdentifier(NPObject* aObject,
35945:               NPIdentifier aIdentifier)
35945: {
35945:   PluginInstanceParent* instance = GetInstance(aObject);
35945:   if (!instance) {
35945:     NS_WARNING("Huh?!");
35945:     return false;
35945:   }
35945: 
39742:   return GetIdentifier(instance, aIdentifier);
35945: }
35945: 
35965: } // anonymous namespace
35965: 
35965: // static
35945: NPObject*
35965: PluginScriptableObjectParent::ScriptableAllocate(NPP aInstance,
35945:                                                  NPClass* aClass)
35945: {
37311:   if (aClass != GetClass()) {
37311:     NS_ERROR("Huh?! Wrong class!");
35945:     return nsnull;
35945:   }
35945: 
36143:   return new ParentNPObject();
35945: }
35945: 
35965: // static
35945: void
35965: PluginScriptableObjectParent::ScriptableInvalidate(NPObject* aObject)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35965:     // This can happen more than once, and is just fine.
35945:     return;
35945:   }
35945: 
37311:   object->invalidated = true;
36143: 
37311:   // |object->parent| may be null already if the instance has gone away.
37311:   if (object->parent && !object->parent->CallInvalidate()) {
37311:     NS_ERROR("Failed to send message!");
35965:   }
35945: }
35945: 
35965: // static
35945: void
35965: PluginScriptableObjectParent::ScriptableDeallocate(NPObject* aObject)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   PluginScriptableObjectParent* actor = object->parent;
37311:   if (actor) {
37311:     NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
37311:     actor->DropNPObject();
37311:   }
35945: 
36143:   delete object;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableHasMethod(NPObject* aObject,
35945:                                                   NPIdentifier aName)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return false;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35945:     NS_WARNING("Calling method on an invalidated object!");
35945:     return false;
35945:   }
35945: 
39742:   PPluginIdentifierParent* identifier = GetIdentifier(aObject, aName);
39742:   if (!identifier) {
35945:     return false;
35945:   }
35945: 
37311:   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
37311:   if (!actor) {
37311:     return false;
37311:   }
37311: 
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35945: 
35945:   bool result;
39742:   if (!actor->CallHasMethod(identifier, &result)) {
35945:     NS_WARNING("Failed to send message!");
35945:     return false;
35945:   }
35945: 
35945:   return result;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableInvoke(NPObject* aObject,
35945:                                                NPIdentifier aName,
35945:                                                const NPVariant* aArgs,
35945:                                                uint32_t aArgCount,
35945:                                                NPVariant* aResult)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return false;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35945:     NS_WARNING("Calling method on an invalidated object!");
35945:     return false;
35945:   }
35945: 
39742:   PPluginIdentifierParent* identifier = GetIdentifier(aObject, aName);
39742:   if (!identifier) {
35945:     return false;
35945:   }
35945: 
37311:   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
37311:   if (!actor) {
35945:     return false;
35945:   }
35945: 
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
37311: 
37311:   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
37311:   if (!args.IsOk()) {
37311:     NS_ERROR("Failed to convert arguments!");
35945:     return false;
35945:   }
35945: 
35965:   Variant remoteResult;
35945:   bool success;
39742:   if (!actor->CallInvoke(identifier, args, &remoteResult,
35945:                          &success)) {
35945:     NS_WARNING("Failed to send message!");
35945:     return false;
35945:   }
35945: 
35945:   if (!success) {
35945:     return false;
35945:   }
35945: 
35965:   if (!ConvertToVariant(remoteResult, *aResult, actor->GetInstance())) {
35945:     NS_WARNING("Failed to convert result!");
35945:     return false;
35945:   }
35945:   return true;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableInvokeDefault(NPObject* aObject,
35945:                                                       const NPVariant* aArgs,
35945:                                                       uint32_t aArgCount,
35945:                                                       NPVariant* aResult)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return false;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35945:     NS_WARNING("Calling method on an invalidated object!");
35945:     return false;
35945:   }
35945: 
37311:   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
37311:   if (!actor) {
35945:     return false;
35945:   }
35945: 
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
37311: 
37311:   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
37311:   if (!args.IsOk()) {
37311:     NS_ERROR("Failed to convert arguments!");
35945:     return false;
35945:   }
35945: 
35965:   Variant remoteResult;
35945:   bool success;
35945:   if (!actor->CallInvokeDefault(args, &remoteResult, &success)) {
35945:     NS_WARNING("Failed to send message!");
35945:     return false;
35945:   }
35945: 
35945:   if (!success) {
35945:     return false;
35945:   }
35945: 
35965:   if (!ConvertToVariant(remoteResult, *aResult, actor->GetInstance())) {
35945:     NS_WARNING("Failed to convert result!");
35945:     return false;
35945:   }
35945:   return true;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableHasProperty(NPObject* aObject,
35945:                                                     NPIdentifier aName)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return false;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35945:     NS_WARNING("Calling method on an invalidated object!");
35945:     return false;
35945:   }
35945: 
39742:   PPluginIdentifierParent* identifier = GetIdentifier(aObject, aName);
39742:   if (!identifier) {
35945:     return false;
35945:   }
35945: 
37311:   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
37311:   if (!actor) {
37311:     return false;
37311:   }
37311: 
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35945: 
35945:   bool result;
39742:   if (!actor->CallHasProperty(identifier, &result)) {
35945:     NS_WARNING("Failed to send message!");
35945:     return false;
35945:   }
35945: 
35945:   return result;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableGetProperty(NPObject* aObject,
35945:                                                     NPIdentifier aName,
35945:                                                     NPVariant* aResult)
35945: {
40566:   // See GetPropertyHelper below.
40566:   NS_NOTREACHED("Shouldn't ever call this directly!");
35945:   return false;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableSetProperty(NPObject* aObject,
35945:                                                     NPIdentifier aName,
35945:                                                     const NPVariant* aValue)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return false;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35945:     NS_WARNING("Calling method on an invalidated object!");
35945:     return false;
35945:   }
35945: 
39742:   PPluginIdentifierParent* identifier = GetIdentifier(aObject, aName);
39742:   if (!identifier) {
35945:     return false;
35945:   }
35945: 
37311:   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
37311:   if (!actor) {
37311:     return false;
37311:   }
35945: 
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
37311: 
37311:   ProtectedVariant value(*aValue, actor->GetInstance());
37311:   if (!value.IsOk()) {
35945:     NS_WARNING("Failed to convert variant!");
35945:     return false;
35945:   }
35945: 
35945:   bool success;
39742:   if (!actor->CallSetProperty(identifier, value, &success)) {
35945:     NS_WARNING("Failed to send message!");
35945:     return false;
35945:   }
35945: 
35945:   return success;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableRemoveProperty(NPObject* aObject,
35945:                                                        NPIdentifier aName)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return false;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35945:     NS_WARNING("Calling method on an invalidated object!");
35945:     return false;
35945:   }
35945: 
39742:   PPluginIdentifierParent* identifier = GetIdentifier(aObject, aName);
39742:   if (!identifier) {
35945:     return false;
35945:   }
35945: 
37311:   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
37311:   if (!actor) {
37311:     return false;
37311:   }
37311: 
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35945: 
35945:   bool success;
39742:   if (!actor->CallRemoveProperty(identifier, &success)) {
35945:     NS_WARNING("Failed to send message!");
35945:     return false;
35945:   }
35945: 
35945:   return success;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableEnumerate(NPObject* aObject,
35945:                                                   NPIdentifier** aIdentifiers,
35945:                                                   uint32_t* aCount)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return false;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35945:     NS_WARNING("Calling method on an invalidated object!");
35945:     return false;
35945:   }
35945: 
37311:   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
37311:   if (!actor) {
37311:     return false;
37311:   }
37311: 
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35945: 
35945:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(aObject);
35945:   if (!npn) {
35945:     NS_ERROR("No netscape funcs!");
35945:     return false;
35945:   }
35945: 
39742:   nsAutoTArray<PPluginIdentifierParent*, 10> identifiers;
35945:   bool success;
35945:   if (!actor->CallEnumerate(&identifiers, &success)) {
35945:     NS_WARNING("Failed to send message!");
35945:     return false;
35945:   }
35945: 
35945:   if (!success) {
35945:     return false;
35945:   }
35945: 
35945:   *aCount = identifiers.Length();
35945:   if (!*aCount) {
35945:     *aIdentifiers = nsnull;
35945:     return true;
35945:   }
35945: 
35945:   *aIdentifiers = (NPIdentifier*)npn->memalloc(*aCount * sizeof(NPIdentifier));
35945:   if (!*aIdentifiers) {
35945:     NS_ERROR("Out of memory!");
35945:     return false;
35945:   }
35945: 
35945:   for (PRUint32 index = 0; index < *aCount; index++) {
39742:     PluginIdentifierParent* id =
39742:       static_cast<PluginIdentifierParent*>(identifiers[index]);
42017:     (*aIdentifiers)[index] = id->ToNPIdentifier();
35945:   }
35945:   return true;
35945: }
35945: 
35965: // static
35945: bool
35965: PluginScriptableObjectParent::ScriptableConstruct(NPObject* aObject,
35945:                                                   const NPVariant* aArgs,
35945:                                                   uint32_t aArgCount,
35945:                                                   NPVariant* aResult)
35945: {
37311:   if (aObject->_class != GetClass()) {
35965:     NS_ERROR("Don't know what kind of object this is!");
35945:     return false;
35945:   }
35945: 
35945:   ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
37311:   if (object->invalidated) {
35945:     NS_WARNING("Calling method on an invalidated object!");
35945:     return false;
35945:   }
35945: 
37311:   ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
37311:   if (!actor) {
35945:     return false;
35945:   }
35945: 
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
37311: 
37311:   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
37311:   if (!args.IsOk()) {
37311:     NS_ERROR("Failed to convert arguments!");
35945:     return false;
35945:   }
35945: 
35965:   Variant remoteResult;
35945:   bool success;
35945:   if (!actor->CallConstruct(args, &remoteResult, &success)) {
35945:     NS_WARNING("Failed to send message!");
35945:     return false;
35945:   }
35945: 
35945:   if (!success) {
35945:     return false;
35945:   }
35945: 
35965:   if (!ConvertToVariant(remoteResult, *aResult, actor->GetInstance())) {
35945:     NS_WARNING("Failed to convert result!");
35945:     return false;
35945:   }
35945:   return true;
35945: }
35945: 
35965: const NPClass PluginScriptableObjectParent::sNPClass = {
35945:   NP_CLASS_STRUCT_VERSION,
35965:   PluginScriptableObjectParent::ScriptableAllocate,
35965:   PluginScriptableObjectParent::ScriptableDeallocate,
35965:   PluginScriptableObjectParent::ScriptableInvalidate,
35965:   PluginScriptableObjectParent::ScriptableHasMethod,
35965:   PluginScriptableObjectParent::ScriptableInvoke,
35965:   PluginScriptableObjectParent::ScriptableInvokeDefault,
35965:   PluginScriptableObjectParent::ScriptableHasProperty,
35965:   PluginScriptableObjectParent::ScriptableGetProperty,
35965:   PluginScriptableObjectParent::ScriptableSetProperty,
35965:   PluginScriptableObjectParent::ScriptableRemoveProperty,
35965:   PluginScriptableObjectParent::ScriptableEnumerate,
35965:   PluginScriptableObjectParent::ScriptableConstruct
35945: };
35835: 
37311: PluginScriptableObjectParent::PluginScriptableObjectParent(
37311:                                                      ScriptableObjectType aType)
35945: : mInstance(nsnull),
37311:   mObject(nsnull),
37311:   mProtectCount(0),
37311:   mType(aType)
35835: {
35835: }
35835: 
35893: PluginScriptableObjectParent::~PluginScriptableObjectParent()
35835: {
35965:   if (mObject) {
37311:     if (mObject->_class == GetClass()) {
37311:       NS_ASSERTION(mType == Proxy, "Wrong type!");
37311:       static_cast<ParentNPObject*>(mObject)->parent = nsnull;
35945:     }
35965:     else {
37311:       NS_ASSERTION(mType == LocalObject, "Wrong type!");
37311:       GetInstance()->GetNPNIface()->releaseobject(mObject);
35965:     }
35965:   }
35965: }
35945: 
35945: void
37311: PluginScriptableObjectParent::InitializeProxy()
35945: {
37311:   NS_ASSERTION(mType == Proxy, "Bad type!");
37311:   NS_ASSERTION(!mObject, "Calling Initialize more than once!");
37311: 
37311:   mInstance = static_cast<PluginInstanceParent*>(Manager());
37311:   NS_ASSERTION(mInstance, "Null manager?!");
37311: 
37311:   NPObject* object = CreateProxyObject();
37311:   NS_ASSERTION(object, "Failed to create object!");
37311: 
37311:   if (!mInstance->RegisterNPObjectForActor(object, this)) {
37311:     NS_ERROR("Out of memory?");
37311:   }
37311: 
37311:   mObject = object;
37311: }
37311: 
37311: void
37311: PluginScriptableObjectParent::InitializeLocal(NPObject* aObject)
37311: {
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35945:   NS_ASSERTION(!(mInstance && mObject), "Calling Initialize more than once!");
35965: 
37311:   mInstance = static_cast<PluginInstanceParent*>(Manager());
37311:   NS_ASSERTION(mInstance, "Null manager?!");
35965: 
37311:   mInstance->GetNPNIface()->retainobject(aObject);
37311: 
37311:   NS_ASSERTION(!mProtectCount, "Should be zero!");
37311:   mProtectCount++;
37311: 
37311:   if (!mInstance->RegisterNPObjectForActor(aObject, this)) {
37311:     NS_ERROR("Out of memory?");
37311:   }
37311: 
37311:   mObject = aObject;
37311: }
37311: 
37311: NPObject*
37311: PluginScriptableObjectParent::CreateProxyObject()
37311: {
37311:   NS_ASSERTION(mInstance, "Must have an instance!");
37311:   NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
37311: 
37311:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(mInstance);
37311: 
37311:   NPObject* npobject = npn->createobject(mInstance->GetNPP(),
37311:                                          const_cast<NPClass*>(GetClass()));
37311:   NS_ASSERTION(npobject, "Failed to create object?!");
37311:   NS_ASSERTION(npobject->_class == GetClass(), "Wrong kind of object!");
37311:   NS_ASSERTION(npobject->referenceCount == 1, "Some kind of live object!");
37311: 
37311:   ParentNPObject* object = static_cast<ParentNPObject*>(npobject);
37311:   NS_ASSERTION(!object->invalidated, "Bad object!");
35965:   NS_ASSERTION(!object->parent, "Bad object!");
35965: 
35965:   // We don't want to have the actor own this object but rather let the object
35965:   // own this actor. Set the reference count to 0 here so that when the object
35965:   // dies we will send the destructor message to the child.
35965:   object->referenceCount = 0;
37311:   NS_LOG_RELEASE(object, 0, "BrowserNPObject");
35945: 
37311:   object->parent = const_cast<PluginScriptableObjectParent*>(this);
37311:   return object;
35965: }
35945: 
35965: bool
37311: PluginScriptableObjectParent::ResurrectProxyObject()
35965: {
37311:   NS_ASSERTION(mInstance, "Must have an instance already!");
37311:   NS_ASSERTION(!mObject, "Should not have an object already!");
37311:   NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
37311: 
37311:   InitializeProxy();
37311:   NS_ASSERTION(mObject, "Initialize failed!");
37311: 
38994:   if (!SendProtect()) {
37311:     NS_WARNING("Failed to send message!");
37311:     return false;
35965:   }
37311: 
37311:   return true;
37311: }
37311: 
37311: NPObject*
37311: PluginScriptableObjectParent::GetObject(bool aCanResurrect)
37311: {
37311:   if (!mObject && aCanResurrect && !ResurrectProxyObject()) {
37311:     NS_ERROR("Null object!");
37311:     return nsnull;
37311:   }
37311:   return mObject;
37311: }
37311: 
37311: void
37311: PluginScriptableObjectParent::Protect()
37311: {
37311:   NS_ASSERTION(mObject, "No object!");
37311:   NS_ASSERTION(mProtectCount >= 0, "Negative protect count?!");
37311: 
37311:   if (mType == LocalObject) {
37311:     ++mProtectCount;
37311:   }
37311: }
37311: 
37311: void
37311: PluginScriptableObjectParent::Unprotect()
37311: {
37311:   NS_ASSERTION(mObject, "No object!");
37311:   NS_ASSERTION(mProtectCount >= 0, "Negative protect count?!");
37311: 
37311:   if (mType == LocalObject) {
37311:     if (--mProtectCount == 0) {
41382:       unused << PluginScriptableObjectParent::Send__delete__(this);
37311:     }
37311:   }
37311: }
37311: 
37311: void
37311: PluginScriptableObjectParent::DropNPObject()
37311: {
37311:   NS_ASSERTION(mObject, "Invalidated object!");
37311:   NS_ASSERTION(mObject->_class == GetClass(), "Wrong type of object!");
37311:   NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
37311: 
37311:   // We think we're about to be deleted, but we could be racing with the other
37311:   // process.
37311:   PluginInstanceParent* instance = GetInstance();
37311:   NS_ASSERTION(instance, "Must have an instance!");
37311: 
37311:   instance->UnregisterNPObject(mObject);
37307:   mObject = nsnull;
37311: 
41382:   unused << SendUnprotect();
37302: }
37302: 
35965: bool
39742: PluginScriptableObjectParent::AnswerHasMethod(PPluginIdentifierParent* aId,
35965:                                               bool* aHasMethod)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerHasMethod with an invalidated object!");
35965:     *aHasMethod = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35965:     *aHasMethod = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_ERROR("No netscape funcs?!");
35965:     *aHasMethod = false;
35965:     return true;
35965:   }
35965: 
39742:   PluginIdentifierParent* id = static_cast<PluginIdentifierParent*>(aId);
39742:   *aHasMethod = npn->hasmethod(instance->GetNPP(), mObject, id->ToNPIdentifier());
35965:   return true;
35965: }
35965: 
35965: bool
39742: PluginScriptableObjectParent::AnswerInvoke(PPluginIdentifierParent* aId,
35965:                                            const nsTArray<Variant>& aArgs,
35965:                                            Variant* aResult,
35965:                                            bool* aSuccess)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerInvoke with an invalidated object!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_ERROR("No netscape funcs?!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   nsAutoTArray<NPVariant, 10> convertedArgs;
35965:   PRUint32 argCount = aArgs.Length();
35965: 
35965:   if (!convertedArgs.SetLength(argCount)) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
35965:       // Don't leak things we've already converted!
35965:       while (index-- > 0) {
35965:         ReleaseVariant(convertedArgs[index], instance);
35965:       }
35969:       *aResult = void_t();
35965:       *aSuccess = false;
35965:       return true;
35965:     }
35965:   }
35965: 
39742:   PluginIdentifierParent* id = static_cast<PluginIdentifierParent*>(aId);
35965:   NPVariant result;
39742:   bool success = npn->invoke(instance->GetNPP(), mObject, id->ToNPIdentifier(),
35965:                              convertedArgs.Elements(), argCount, &result);
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     ReleaseVariant(convertedArgs[index], instance);
35965:   }
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   Variant convertedResult;
35965:   success = ConvertToRemoteVariant(result, convertedResult, GetInstance());
35965: 
37311:   DeferNPVariantLastRelease(npn, &result);
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35969:   *aResult = convertedResult;
35965:   *aSuccess = true;
35965:   return true;
35965: }
35965: 
35965: bool
35965: PluginScriptableObjectParent::AnswerInvokeDefault(const nsTArray<Variant>& aArgs,
35965:                                                   Variant* aResult,
35965:                                                   bool* aSuccess)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerInvoke with an invalidated object!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_ERROR("No netscape funcs?!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   nsAutoTArray<NPVariant, 10> convertedArgs;
35965:   PRUint32 argCount = aArgs.Length();
35965: 
35965:   if (!convertedArgs.SetLength(argCount)) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
35965:       // Don't leak things we've already converted!
35965:       while (index-- > 0) {
35965:         ReleaseVariant(convertedArgs[index], instance);
35965:       }
35969:       *aResult = void_t();
35965:       *aSuccess = false;
35965:       return true;
35965:     }
35965:   }
35965: 
35965:   NPVariant result;
35965:   bool success = npn->invokeDefault(instance->GetNPP(), mObject,
35965:                                     convertedArgs.Elements(), argCount,
35965:                                     &result);
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     ReleaseVariant(convertedArgs[index], instance);
35965:   }
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   Variant convertedResult;
35965:   success = ConvertToRemoteVariant(result, convertedResult, GetInstance());
35965: 
37311:   DeferNPVariantLastRelease(npn, &result);
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35969:   *aResult = convertedResult;
35965:   *aSuccess = true;
35965:   return true;
35965: }
35965: 
35965: bool
39742: PluginScriptableObjectParent::AnswerHasProperty(PPluginIdentifierParent* aId,
35965:                                                 bool* aHasProperty)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerHasProperty with an invalidated object!");
35965:     *aHasProperty = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35965:     *aHasProperty = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_ERROR("No netscape funcs?!");
35965:     *aHasProperty = false;
35965:     return true;
35965:   }
35965: 
39742:   PluginIdentifierParent* id = static_cast<PluginIdentifierParent*>(aId);
35965:   *aHasProperty = npn->hasproperty(instance->GetNPP(), mObject,
39742:                                    id->ToNPIdentifier());
35965:   return true;
35965: }
35965: 
35965: bool
40566: PluginScriptableObjectParent::AnswerGetParentProperty(
40566:                                                    PPluginIdentifierParent* aId,
35965:                                                    Variant* aResult,
35965:                                                    bool* aSuccess)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerGetProperty with an invalidated object!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_ERROR("No netscape funcs?!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
39742:   PluginIdentifierParent* id = static_cast<PluginIdentifierParent*>(aId);
35965:   NPVariant result;
39742:   if (!npn->getproperty(instance->GetNPP(), mObject, id->ToNPIdentifier(),
35965:                         &result)) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   Variant converted;
35965:   if ((*aSuccess = ConvertToRemoteVariant(result, converted, instance))) {
37311:     DeferNPVariantLastRelease(npn, &result);
35965:     *aResult = converted;
35965:   }
35970:   else {
35970:     *aResult = void_t();
35970:   }
35970: 
35965:   return true;
35965: }
35965: 
35965: bool
39742: PluginScriptableObjectParent::AnswerSetProperty(PPluginIdentifierParent* aId,
35965:                                                 const Variant& aValue,
35965:                                                 bool* aSuccess)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerSetProperty with an invalidated object!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_ERROR("No netscape funcs?!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NPVariant converted;
35965:   if (!ConvertToVariant(aValue, converted, instance)) {
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
39742:   PluginIdentifierParent* id = static_cast<PluginIdentifierParent*>(aId);
35965:   if ((*aSuccess = npn->setproperty(instance->GetNPP(), mObject,
39742:                                     id->ToNPIdentifier(), &converted))) {
35965:     ReleaseVariant(converted, instance);
35965:   }
35965:   return true;
35965: }
35965: 
35965: bool
39742: PluginScriptableObjectParent::AnswerRemoveProperty(PPluginIdentifierParent* aId,
35965:                                                    bool* aSuccess)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerRemoveProperty with an invalidated object!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_ERROR("No netscape funcs?!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
39742:   PluginIdentifierParent* id = static_cast<PluginIdentifierParent*>(aId);
35965:   *aSuccess = npn->removeproperty(instance->GetNPP(), mObject,
39742:                                   id->ToNPIdentifier());
35965:   return true;
35965: }
35965: 
35965: bool
39742: PluginScriptableObjectParent::AnswerEnumerate(nsTArray<PPluginIdentifierParent*>* aProperties,
35965:                                               bool* aSuccess)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerEnumerate with an invalidated object!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_WARNING("No netscape funcs?!");
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NPIdentifier* ids;
35965:   uint32_t idCount;
35965:   if (!npn->enumerate(instance->GetNPP(), mObject, &ids, &idCount)) {
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   if (!aProperties->SetCapacity(idCount)) {
35965:     npn->memfree(ids);
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   for (uint32_t index = 0; index < idCount; index++) {
39742:     aProperties->AppendElement(GetIdentifier(instance, ids[index]));
35965:   }
35965: 
35965:   npn->memfree(ids);
35965:   *aSuccess = true;
35965:   return true;
35965: }
35965: 
35965: bool
35965: PluginScriptableObjectParent::AnswerConstruct(const nsTArray<Variant>& aArgs,
35965:                                               Variant* aResult,
35965:                                               bool* aSuccess)
35965: {
35965:   if (!mObject) {
35965:     NS_WARNING("Calling AnswerConstruct with an invalidated object!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35965:   PluginInstanceParent* instance = GetInstance();
35965:   if (!instance) {
35965:     NS_ERROR("No instance?!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35965:   if (!npn) {
35965:     NS_ERROR("No netscape funcs?!");
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   nsAutoTArray<NPVariant, 10> convertedArgs;
35965:   PRUint32 argCount = aArgs.Length();
35965: 
35965:   if (!convertedArgs.SetLength(argCount)) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
35965:       // Don't leak things we've already converted!
35965:       while (index-- > 0) {
35965:         ReleaseVariant(convertedArgs[index], instance);
35965:       }
35969:       *aResult = void_t();
35965:       *aSuccess = false;
35965:       return true;
35965:     }
35965:   }
35965: 
35965:   NPVariant result;
35965:   bool success = npn->construct(instance->GetNPP(), mObject,
35965:                                 convertedArgs.Elements(), argCount, &result);
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     ReleaseVariant(convertedArgs[index], instance);
35965:   }
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   Variant convertedResult;
35965:   success = ConvertToRemoteVariant(result, convertedResult, instance);
35965: 
37311:   DeferNPVariantLastRelease(npn, &result);
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35965:     *aSuccess = false;
35965:     return true;
35965:   }
35965: 
35965:   *aSuccess = true;
35965:   *aResult = convertedResult;
35965:   return true;
35965: }
35983: 
35983: bool
38994: PluginScriptableObjectParent::RecvProtect()
37311: {
37311:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
37311: 
37311:   Protect();
37311:   return true;
37311: }
37311: 
37311: bool
38994: PluginScriptableObjectParent::RecvUnprotect()
37311: {
37311:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
37311: 
37311:   Unprotect();
37311:   return true;
37311: }
37311: 
37311: bool
35983: PluginScriptableObjectParent::AnswerNPN_Evaluate(const nsCString& aScript,
35983:                                                  Variant* aResult,
35983:                                                  bool* aSuccess)
35983: {
35983:   PluginInstanceParent* instance = GetInstance();
35983:   if (!instance) {
35983:     NS_ERROR("No instance?!");
35983:     *aResult = void_t();
35983:     *aSuccess = false;
35983:     return true;
35983:   }
35983: 
35983:   const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
35983:   if (!npn) {
35983:     NS_ERROR("No netscape funcs?!");
35983:     *aResult = void_t();
35983:     *aSuccess = false;
35983:     return true;
35983:   }
35983: 
35983:   NPString script = { aScript.get(), aScript.Length() };
35983: 
35983:   NPVariant result;
35983:   bool success = npn->evaluate(instance->GetNPP(), mObject, &script, &result);
35983:   if (!success) {
35983:     *aResult = void_t();
35983:     *aSuccess = false;
35983:     return true;
35983:   }
35983: 
35983:   Variant convertedResult;
35983:   success = ConvertToRemoteVariant(result, convertedResult, instance);
35983: 
37311:   DeferNPVariantLastRelease(npn, &result);
35983: 
35983:   if (!success) {
35983:     *aResult = void_t();
35983:     *aSuccess = false;
35983:     return true;
35983:   }
35983: 
35983:   *aSuccess = true;
35983:   *aResult = convertedResult;
35983:   return true;
35983: }
40566: 
40566: JSBool
40566: PluginScriptableObjectParent::GetPropertyHelper(NPIdentifier aName,
40566:                                                 PRBool* aHasProperty,
40566:                                                 PRBool* aHasMethod,
40566:                                                 NPVariant* aResult)
40566: {
40566:   NS_ASSERTION(Type() == Proxy, "Bad type!");
40566: 
40566:   ParentNPObject* object = static_cast<ParentNPObject*>(mObject);
40566:   if (object->invalidated) {
40566:     NS_WARNING("Calling method on an invalidated object!");
40566:     return JS_FALSE;
40566:   }
40566: 
40566:   PPluginIdentifierParent* identifier = GetIdentifier(GetInstance(), aName);
40566:   if (!identifier) {
40566:     return JS_FALSE;
40566:   }
40566: 
40566:   bool hasProperty, hasMethod, success;
40566:   Variant result;
40566:   if (!CallGetChildProperty(identifier, &hasProperty, &hasMethod, &result,
40566:                             &success)) {
40566:     return JS_FALSE;
40566:   }
40566: 
40566:   if (!success) {
40566:     return JS_FALSE;
40566:   }
40566: 
40566:   if (!ConvertToVariant(result, *aResult, GetInstance())) {
40566:     NS_WARNING("Failed to convert result!");
40566:     return JS_FALSE;
40566:   }
40566: 
40566:   *aHasProperty = hasProperty;
40566:   *aHasMethod = hasMethod;
40566:   return JS_TRUE;
40566: }
