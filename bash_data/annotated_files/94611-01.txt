54855: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
54855:  *
54855:  * ***** BEGIN LICENSE BLOCK *****
54855:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54855:  *
54855:  * The contents of this file are subject to the Mozilla Public License Version
54855:  * 1.1 (the "License"); you may not use this file except in compliance with
54855:  * the License. You may obtain a copy of the License at
54855:  * http://www.mozilla.org/MPL/
54855:  *
54855:  * Software distributed under the License is distributed on an "AS IS" basis,
54855:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54855:  * for the specific language governing rights and limitations under the
54855:  * License.
54855:  *
57755:  * The Original Code is the Mozilla SpiderMonkey JaegerMonkey implementation
54855:  *
54855:  * The Initial Developer of the Original Code is
57755:  *   Mozilla Foundation
57755:  * Portions created by the Initial Developer are Copyright (C) 2002-2010
54855:  * the Initial Developer. All Rights Reserved.
54855:  *
54855:  * Contributor(s):
54855:  *
54855:  * Alternatively, the contents of this file may be used under the terms of
54855:  * either of the GNU General Public License Version 2 or later (the "GPL"),
54855:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54855:  * in which case the provisions of the GPL or the LGPL are applicable instead
54855:  * of those above. If you wish to allow use of your version of this file only
54855:  * under the terms of either the GPL or the LGPL, and not to allow others to
54855:  * use your version of this file under the terms of the MPL, indicate your
54855:  * decision by deleting the provisions above and replace them with the notice
54855:  * and other provisions required by the GPL or the LGPL. If you do not delete
54855:  * the provisions above, a recipient may use your version of this file under
54855:  * the terms of any one of the MPL, the GPL or the LGPL.
54855:  *
54855:  * ***** END LICENSE BLOCK ***** */
54855: 
54855: #include "jsautooplen.h"
54855: 
84803: #include "frontend/BytecodeEmitter.h"
84803: 
57755: namespace js {
57755: 
87171: static inline PropertyName *
87171: GetNameFromBytecode(JSContext *cx, jsbytecode *pc, JSOp op, const JSCodeSpec &cs)
87171: {
87171:     if (op == JSOP_LENGTH)
87171:         return cx->runtime->atomState.lengthAtom;
87171: 
87171:     // The method JIT's implementation of instanceof contains an internal lookup
87171:     // of the prototype property.
87171:     if (op == JSOP_INSTANCEOF)
87171:         return cx->runtime->atomState.classPrototypeAtom;
87171: 
94611:     JSScript *script = cx->stack.currentScriptWithDiagnostics();
87171:     PropertyName *name;
87975:     GET_NAME_FROM_BYTECODE(script, pc, 0, name);
87171:     return name;
87171: }
87171: 
75501: class BytecodeRange {
75501:   public:
84195:     BytecodeRange(JSScript *script)
84195:       : script(script), pc(script->code), end(pc + script->length) {}
75501:     bool empty() const { return pc == end; }
75501:     jsbytecode *frontPC() const { return pc; }
84195:     JSOp frontOpcode() const { return JSOp(*pc); }
75501:     size_t frontOffset() const { return pc - script->code; }
84195:     void popFront() { pc += GetBytecodeLength(pc); }
75501: 
75501:   private:
75501:     JSScript *script;
75501:     jsbytecode *pc, *end;
75501: };
75501: 
84803: class SrcNoteLineScanner
84803: {
84803:     /* offset of the current JSOp in the bytecode */
84803:     ptrdiff_t offset;
84803: 
84803:     /* next src note to process */
84803:     jssrcnote *sn;
84803: 
84803:     /* line number of the current JSOp */
84803:     uint32_t lineno;
84803: 
84803:     /*
84803:      * Is the current op the first one after a line change directive? Note that
84803:      * multiple ops may be "first" if a line directive is used to return to a
84803:      * previous line (eg, with a for loop increment expression.)
84803:      */
84803:     bool lineHeader;
84803: 
84803: public:
84803:     SrcNoteLineScanner(jssrcnote *sn, uint32_t lineno)
84803:         : offset(0), sn(sn), lineno(lineno)
84803:     {
57755:     }
84803: 
84803:     /*
84803:      * This is called repeatedly with always-advancing relpc values. The src
84803:      * notes are tuples of <PC offset from prev src note, type, args>. Scan
84803:      * through, updating the lineno, until the next src note is for a later
84803:      * bytecode.
84803:      *
84803:      * When looking at the desired PC offset ('relpc'), the op is first in that
84803:      * line iff there is a SRC_SETLINE or SRC_NEWLINE src note for that exact
84803:      * bytecode.
84803:      *
84803:      * Note that a single bytecode may have multiple line-modifying notes (even
84803:      * though only one should ever be needed.)
84803:      */
84803:     void advanceTo(ptrdiff_t relpc) {
84803:         // Must always advance! If the same or an earlier PC is erroneously
84803:         // passed in, we will already be past the relevant src notes
84803:         JS_ASSERT_IF(offset > 0, relpc > offset);
84803: 
84803:         // Next src note should be for after the current offset
84803:         JS_ASSERT_IF(offset > 0, SN_IS_TERMINATOR(sn) || SN_DELTA(sn) > 0);
84803: 
84803:         // The first PC requested is always considered to be a line header
84803:         lineHeader = (offset == 0);
84803: 
84803:         if (SN_IS_TERMINATOR(sn))
84803:             return;
84803: 
84803:         ptrdiff_t nextOffset;
84803:         while ((nextOffset = offset + SN_DELTA(sn)) <= relpc && !SN_IS_TERMINATOR(sn)) {
84803:             offset = nextOffset;
84803:             SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
84803:             if (type == SRC_SETLINE || type == SRC_NEWLINE) {
84803:                 if (type == SRC_SETLINE)
84803:                     lineno = js_GetSrcNoteOffset(sn, 0);
84803:                 else
84803:                     lineno++;
84803: 
84803:                 if (offset == relpc)
84803:                     lineHeader = true;
84803:             }
84803: 
84803:             sn = SN_NEXT(sn);
84803:         }
84803:     }
84803: 
84803:     bool isLineHeader() const {
84803:         return lineHeader;
84803:     }
84803: 
84803:     uint32_t getLine() const { return lineno; }
84803: };
84803: 
84803: }
