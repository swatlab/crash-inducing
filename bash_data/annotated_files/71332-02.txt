31494: /* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 4 -*- */
31494: /* vi: set ts=4 sw=4 expandtab: (add to ~/.vimrc: set modeline modelines=5) */
31494: /* ***** BEGIN LICENSE BLOCK *****
31494:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
31494:  *
31494:  * The contents of this file are subject to the Mozilla Public License Version
31494:  * 1.1 (the "License"); you may not use this file except in compliance with
31494:  * the License. You may obtain a copy of the License at
31494:  * http://www.mozilla.org/MPL/
31494:  *
31494:  * Software distributed under the License is distributed on an "AS IS" basis,
31494:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
31494:  * for the specific language governing rights and limitations under the
31494:  * License.
31494:  *
31494:  * The Original Code is [Open Source Virtual Machine].
31494:  *
31494:  * The Initial Developer of the Original Code is
31494:  * Adobe System Incorporated.
31494:  * Portions created by the Initial Developer are Copyright (C) 2004-2007
31494:  * the Initial Developer. All Rights Reserved.
31494:  *
31494:  * Contributor(s):
31494:  *   Adobe AS3 Team
31494:  *
31494:  * Alternatively, the contents of this file may be used under the terms of
31494:  * either the GNU General Public License Version 2 or later (the "GPL"), or
31494:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
31494:  * in which case the provisions of the GPL or the LGPL are applicable instead
31494:  * of those above. If you wish to allow use of your version of this file only
31494:  * under the terms of either the GPL or the LGPL, and not to allow others to
31494:  * use your version of this file under the terms of the MPL, indicate your
31494:  * decision by deleting the provisions above and replace them with the notice
31494:  * and other provisions required by the GPL or the LGPL. If you do not delete
31494:  * the provisions above, a recipient may use your version of this file under
31494:  * the terms of any one of the MPL, the GPL or the LGPL.
31494:  *
31494:  * ***** END LICENSE BLOCK ***** */
31494: 
31494: #ifndef __nanojit_Containers__
31494: #define __nanojit_Containers__
31494: 
31494: namespace nanojit
31494: {
31494:     /** simple linear bit array, memory taken from Allocator
31494:      *  warning: when bit array grows, old memory is wasted since it
31494:      *  was allocated from Allocator.  pre-size the bitmap when possible
31494:      *  by passing nbits to the constructor. */
31494:     class BitSet {
31494:         Allocator &allocator;
31494:         int cap;
31494:         int64_t *bits;
31494:         static const int64_t ONE = 1;
31494:         static const int SHIFT = 6;
31494: 
71330:         inline int bitnum2word(int i) const {
31494:             return i >> 6;
31494:         }
71330:         inline int64_t bitnum2mask(int i) const {
31494:             return ONE << (i & 63);
31494:         }
31494: 
31494:         /** keep doubling array to fit at least w words */
31494:         void grow(int w);
31494: 
31494:     public:
31494:         BitSet(Allocator& allocator, int nbits=128);
31494: 
31494:         /** clear all bits */
31494:         void reset();
31494: 
71332:         /** allocates new bits and clears them;  any old bits are lost and will
71332:          * be freed according to their allocator's policy. */
71332:         void resetAndAlloc();
71332: 
31494:         /** perform a bitwise or with BitSet other, return true if
31494:          *  this bitset was modified */
31494:         bool setFrom(BitSet& other);
31494: 
31494:         /** return bit i as a bool */
71330:         bool get(int i) const {
31494:             NanoAssert(i >= 0);
31494:             int w = bitnum2word(i);
31494:             if (w < cap)
31494:                 return (bits[w] & bitnum2mask(i)) != 0;
31494:             return false;
31494:         }
31494: 
31494:         /** set bit i */
31494:         void set(int i) {
31494:             NanoAssert(i >= 0);
31494:             int w = bitnum2word(i);
31494:             if (w >= cap)
31494:                 grow(w);
68918:             NanoAssert(w < cap);
31494:             bits[w] |= bitnum2mask(i);
31494:         }
31494: 
31494:         /** clear bit i */
31494:         void clear(int i) {
31494:             NanoAssert(i >= 0);
31494:             int w = bitnum2word(i);
31494:             if (w < cap)
31494:                 bits[w] &= ~bitnum2mask(i);
31494:         }
31494:     };
31494: 
31494:     /** Seq is a single node in a linked list */
31494:     template<class T> class Seq {
31494:     public:
31494:         Seq(T head, Seq<T>* tail=NULL) : head(head), tail(tail) {}
31494:         T       head;
31494:         Seq<T>* tail;
31494:     };
31494: 
31494:     /** SeqBuilder is used to create a linked list of Seq<T> by inserting
31494:      *  nodes either at the beginning, with insert(), or at the end, with
31494:      *  add().  Once built, the actual list can be retained while this
31494:      *  SeqBuilder can be discarded.  */
31494:     template<class T> class SeqBuilder {
31494:     public:
31494:         SeqBuilder(Allocator& allocator)
31494:             : allocator(allocator)
31494:             , items(NULL)
31494:             , last(NULL)
31494:         { }
31494: 
31494:         /** add item to beginning of list */
31494:         void insert(T item) {
31494:             Seq<T>* e = new (allocator) Seq<T>(item, items);
31494:             if (last == NULL)
31494:                 last = e;
31494:             items = e;
31494:         }
31494: 
31494:         /** add item to end of list */
31494:         void add(T item) {
31494:             Seq<T>* e = new (allocator) Seq<T>(item);
31494:             if (last == NULL)
31494:                 items = e;
31494:             else
31494:                 last->tail = e;
31494:             last = e;
31494:         }
31494: 
31494:         /** return first item in sequence */
31494:         Seq<T>* get() const {
31494:             return items;
31494:         }
31494: 
31494:         /** self explanitory */
31494:         bool isEmpty() const {
31494:             return items == NULL;
31494:         }
31494: 
31494:         /** de-reference all items */
31494:         void clear() {
31494:             items = last = NULL;
31494:         }
31494: 
31494:     private:
31494:         Allocator& allocator;
31494:         Seq<T>* items;
31494:         Seq<T>* last;
31494:     };
31494: 
31917: #ifdef NANOJIT_64BIT
31917:     static inline size_t murmurhash(const void *key, size_t len) {
31917:         const uint64_t m = 0xc6a4a7935bd1e995;
31917:         const int r = 47;
32580:         uint64_t h = 0;
31917: 
31917:         const uint64_t *data = (const uint64_t*)key;
31917:         const uint64_t *end = data + (len/8);
31917: 
31917:         while(data != end)
31917:             {
31917:                 uint64_t k = *data++;
31917: 
31917:                 k *= m;
31917:                 k ^= k >> r;
31917:                 k *= m;
31917: 
31917:                 h ^= k;
31917:                 h *= m;
31917:             }
31917: 
31917:         const unsigned char *data2 = (const unsigned char*)data;
31917: 
31917:         switch(len & 7) {
31917:         case 7: h ^= uint64_t(data2[6]) << 48;
31917:         case 6: h ^= uint64_t(data2[5]) << 40;
31917:         case 5: h ^= uint64_t(data2[4]) << 32;
31917:         case 4: h ^= uint64_t(data2[3]) << 24;
31917:         case 3: h ^= uint64_t(data2[2]) << 16;
31917:         case 2: h ^= uint64_t(data2[1]) << 8;
31917:         case 1: h ^= uint64_t(data2[0]);
31917:             h *= m;
31917:         };
31917: 
31917:         h ^= h >> r;
31917:         h *= m;
31917:         h ^= h >> r;
31917: 
31917:         return (size_t)h;
31917:     }
31917: #else
31917:     static inline size_t murmurhash(const void * key, size_t len) {
31917:         const uint32_t m = 0x5bd1e995;
31917:         const int r = 24;
31917:         uint32_t h = 0;
31917: 
31917:         const unsigned char * data = (const unsigned char *)key;
31917:         while(len >= 4) {
33994:             uint32_t k = *(size_t *)(void*)data;
31917: 
31917:             k *= m;
31917:             k ^= k >> r;
31917:             k *= m;
31917: 
31917:             h *= m;
31917:             h ^= k;
31917: 
31917:             data += 4;
31917:             len -= 4;
31917:         }
31917: 
31917:         switch(len) {
31917:         case 3: h ^= data[2] << 16;
31917:         case 2: h ^= data[1] << 8;
31917:         case 1: h ^= data[0];
31917:             h *= m;
31917:         };
31917: 
31917:         h ^= h >> 13;
31917:         h *= m;
31917:         h ^= h >> 15;
31917: 
31917:         return (size_t)h;
31917:     }
31917: #endif
31917: 
31917:     template<class K> struct DefaultHash {
31917:         static size_t hash(const K &k) {
42758:             // (const void*) cast is required by ARM RVCT 2.2
42758:             return murmurhash((const void*) &k, sizeof(K));
31917:         }
31917:     };
31917: 
31917:     template<class K> struct DefaultHash<K*> {
31917:         static size_t hash(K* k) {
31917:             uintptr_t h = (uintptr_t) k;
31917:             // move the low 3 bits higher up since they're often 0
31917:             h = (h>>3) ^ (h<<((sizeof(uintptr_t) * 8) - 3));
31917:             return (size_t) h;
31917:         }
31917:     };
31917: 
31494:     /** Bucket hashtable with a fixed # of buckets (never rehash)
31494:      *  Intended for use when a reasonable # of buckets can be estimated ahead of time.
55494:      *  Note that operator== is used to compare keys.
31917:      */
31917:     template<class K, class T, class H=DefaultHash<K> > class HashMap {
31494:         Allocator& allocator;
31917:         size_t nbuckets;
31494:         class Node {
31494:         public:
31494:             K key;
31494:             T value;
31494:             Node(K k, T v) : key(k), value(v) { }
31494:         };
31494:         Seq<Node>** buckets;
31494: 
31494:         /** return the node containing K, and the bucket index, or NULL if not found */
31917:         Node* find(K k, size_t &i) {
31917:             i = H::hash(k) % nbuckets;
31494:             for (Seq<Node>* p = buckets[i]; p != NULL; p = p->tail) {
31494:                 if (p->head.key == k)
31494:                     return &p->head;
31494:             }
31494:             return NULL;
31494:         }
31494:     public:
31917:         HashMap(Allocator& a, size_t nbuckets = 16)
31494:             : allocator(a)
31494:             , nbuckets(nbuckets)
31494:             , buckets(new (a) Seq<Node>*[nbuckets])
31494:         {
33114:             NanoAssert(nbuckets > 0);
31494:             clear();
31494:         }
31494: 
31494:         /** clear all buckets.  Since we allocate all memory from Allocator,
31494:          *  nothing needs to be freed. */
31494:         void clear() {
31494:             VMPI_memset(buckets, 0, sizeof(Seq<Node>*) * nbuckets);
31494:         }
31494: 
31494:         /** add (k,v) to the map.  If k is already in the map, replace the value */
31917:         void put(const K& k, const T& v) {
31917:             size_t i;
31494:             Node* n = find(k, i);
31494:             if (n) {
31494:                 n->value = v;
31494:                 return;
31494:             }
31494:             buckets[i] = new (allocator) Seq<Node>(Node(k,v), buckets[i]);
31494:         }
31494: 
31494:         /** return v for element k, or T(0) if k is not present */
31917:         T get(const K& k) {
31917:             size_t i;
31494:             Node* n = find(k, i);
31494:             return n ? n->value : 0;
31494:         }
31494: 
31494:         /** returns true if k is in the map. */
31917:         bool containsKey(const K& k) {
31917:             size_t i;
31494:             return find(k, i) != 0;
31494:         }
31494: 
31494:         /** remove k from the map, if it is present.  if not, remove()
31494:          *  silently returns */
31917:         void remove(const K& k) {
31930:             size_t i = H::hash(k) % nbuckets;
31494:             Seq<Node>** prev = &buckets[i];
31494:             for (Seq<Node>* p = buckets[i]; p != NULL; p = p->tail) {
31494:                 if (p->head.key == k) {
31494:                     (*prev) = p->tail;
31494:                     return;
31494:                 }
31494:                 prev = &p->tail;
31494:             }
31494:         }
31494: 
31494:         /** Iter is an iterator for HashMap, intended to be instantiated on
31494:          *  the stack.  Iteration order is undefined.  Mutating the hashmap
31494:          *  while iteration is in progress gives undefined results.  All iteration
31494:          *  state is in class Iter, so multiple iterations can be in progress
31494:          *  at the same time.  for example:
31494:          *
31494:          *  HashMap<K,T>::Iter iter(map);
31494:          *  while (iter.next()) {
31494:          *     K *k = iter.key();
31494:          *     T *t = iter.value();
31494:          *  }
31494:          */
31494:         class Iter {
31494:             friend class HashMap;
31917:             const HashMap<K,T,H> &map;
31494:             int bucket;
31494:             const Seq<Node>* current;
31494: 
31494:         public:
33939:             Iter(HashMap<K,T,H>& map) : map(map), bucket((int)map.nbuckets-1), current(NULL)
31494:             { }
31494: 
31494:             /** return true if more (k,v) remain to be visited */
31494:             bool next() {
31494:                 if (current)
31494:                     current = current->tail;
31494:                 while (bucket >= 0 && !current)
31494:                     current = map.buckets[bucket--];
31494:                 return current != NULL;
31494:             }
31494: 
31494:             /** return the current key */
31917:             const K& key() const {
31494:                 NanoAssert(current != NULL);
31494:                 return current->head.key;
31494:             }
31494: 
31494:             /** return the current value */
31917:             const T& value() const {
31494:                 NanoAssert(current != NULL);
31494:                 return current->head.value;
31494:             }
31494:         };
31494: 
31494:         /** return true if the hashmap has no elements */
31494:         bool isEmpty() {
31494:             Iter iter(*this);
31494:             return !iter.next();
31494:         }
31494:     };
31494: 
31494:     /**
31494:      * Simple binary tree.  No balancing is performed under the assumption
31494:      * that the only users of this structure are not performance critical.
31494:      */
31494:     template<class K, class T> class TreeMap {
31494:         Allocator& alloc;
31494:         class Node {
31494:         public:
31494:             Node* left;
31494:             Node* right;
31494:             K key;
31494:             T value;
31494:             Node(K k, T v) : left(NULL), right(NULL), key(k), value(v)
31494:             { }
31494:         };
31494:         Node* root;
31494: 
31494:         /**
31494:          * helper method to recursively insert (k,v) below Node n or a child
31494:          * of n so that the binary search tree remains well formed.
31494:          */
31494:         void insert(Node* &n, K k, T v) {
31494:             if (!n)
31494:                 n = new (alloc) Node(k, v);
31494:             else if (k == n->key)
31494:                 n->value = v;
31494:             else if (k < n->key)
31494:                 insert(n->left, k, v);
31494:             else
31494:                 insert(n->right, k, v);
31494:         }
31494: 
31494:         /**
31494:          * search for key k below Node n and return n if found, or the
31494:          * closest parent n where k should be inserted.
31494:          */
31494:         Node* find(Node* n, K k) {
31494:             if (!n)
31494:                 return NULL;
31494:             if (k == n->key)
31494:                 return n;
31494:             if (k < n->key)
31494:                 return find(n->left, k);
31494:             if (n->right)
31494:                 return find(n->right, k);
31494:             return n;
31494:         }
31494: 
31494:     public:
31494:         TreeMap(Allocator& alloc) : alloc(alloc), root(NULL)
31494:         { }
31494: 
31494:         /** set k = v in the map.  if k already exists, replace its value */
31494:         void put(K k, T v) {
31494:             insert(root, k, v);
31494:         }
31494: 
31494:         /** return the closest key that is <= k, or NULL if k
31494:             is smaller than every key in the Map. */
31494:         K findNear(K k) {
31494:             Node* n = find(root, k);
31494:             return n ? n->key : 0;
31494:         }
31494: 
31494:         /** returns the value for k or NULL */
31494:         T get(K k) {
31494:             Node* n = find(root, k);
31494:             return (n && n->key == k) ? n->value : 0;
31494:         }
31494: 
31494:         /** returns true iff k is in the Map. */
31494:         bool containsKey(K k) {
31494:             Node* n = find(root, k);
31494:             return n && n->key == k;
31494:         }
31494: 
31494:         /** make the tree empty.  trivial since we dont manage elements */
31494:         void clear() {
31494:             root = NULL;
31494:         }
31494:     };
31494: }
31494: #endif // __nanojit_Containers__
