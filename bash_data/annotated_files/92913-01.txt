64861: // -*- Mode: js2; tab-width: 2; indent-tabs-mode: nil; js2-basic-offset: 2; js2-skip-preprocessor-directives: t; -*-
64861: /*
64705:  * ***** BEGIN LICENSE BLOCK *****
64692:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
64692:  *
64692:  * The contents of this file are subject to the Mozilla Public License Version
64692:  * 1.1 (the "License"); you may not use this file except in compliance with
64692:  * the License. You may obtain a copy of the License at
64692:  * http://www.mozilla.org/MPL/
64692:  *
64692:  * Software distributed under the License is distributed on an "AS IS" basis,
64692:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
64692:  * for the specific language governing rights and limitations under the
64692:  * License.
64692:  *
64692:  * The Original Code is Mozilla Mobile Browser.
64692:  *
64692:  * The Initial Developer of the Original Code is
64692:  * Mozilla Corporation.
83624:  * Portions created by the Initial Developer are Copyright (C) 2011
64692:  * the Initial Developer. All Rights Reserved.
64692:  *
64692:  * Contributor(s):
64692:  *
64692:  * Alternatively, the contents of this file may be used under the terms of
64692:  * either the GNU General Public License Version 2 or later (the "GPL"), or
64692:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
64692:  * in which case the provisions of the GPL or the LGPL are applicable instead
64692:  * of those above. If you wish to allow use of your version of this file only
64692:  * under the terms of either the GPL or the LGPL, and not to allow others to
64692:  * use your version of this file under the terms of the MPL, indicate your
64692:  * decision by deleting the provisions above and replace them with the notice
64692:  * and other provisions required by the GPL or the LGPL. If you do not delete
64692:  * the provisions above, a recipient may use your version of this file under
64692:  * the terms of any one of the MPL, the GPL or the LGPL.
64692:  *
64692:  * ***** END LICENSE BLOCK ***** */
83763: "use strict";
64692: 
65122: let Cc = Components.classes;
65122: let Ci = Components.interfaces;
65122: let Cu = Components.utils;
67010: let Cr = Components.results;
64692: 
83485: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
83485: Cu.import("resource://gre/modules/Services.jsm")
83922: Cu.import("resource://gre/modules/AddonManager.jsm");
83485: 
86233: XPCOMUtils.defineLazyGetter(this, "PluralForm", function() {
86233:   Cu.import("resource://gre/modules/PluralForm.jsm");
86233:   return PluralForm;
86233: });
86233: 
84302: XPCOMUtils.defineLazyServiceGetter(this, "Haptic",
84302:   "@mozilla.org/widget/hapticfeedback;1", "nsIHapticFeedback");
84302: 
83992: XPCOMUtils.defineLazyServiceGetter(this, "DOMUtils",
83992:   "@mozilla.org/inspector/dom-utils;1", "inIDOMUtils");
84302: 
83992: const kStateActive = 0x00000001; // :active pseudoclass for elements
83624: 
86782: const kXLinkNamespace = "http://www.w3.org/1999/xlink";
86782: 
83566: // TODO: Take into account ppi in these units?
83566: 
83549: // The ratio of velocity that is retained every ms.
83549: const kPanDeceleration = 0.999;
83549: 
83549: // The number of ms to consider events over for a swipe gesture.
83566: const kSwipeLength = 500;
83566: 
83566: // The number of pixels to move before we consider a drag to be more than
83566: // just a click with jitter.
83566: const kDragThreshold = 10;
83566: 
83566: // The number of pixels to move to break out of axis-lock
83566: const kLockBreakThreshold = 100;
83549: 
83549: // Minimum speed to move during kinetic panning. 0.015 pixels/ms is roughly
83549: // equivalent to a pixel every 4 frames at 60fps.
83549: const kMinKineticSpeed = 0.015;
83549: 
83566: // Maximum kinetic panning speed. 9 pixels/ms is equivalent to 150 pixels per
83549: // frame at 60fps.
83566: const kMaxKineticSpeed = 9;
83549: 
83549: // The maximum magnitude of disparity allowed between axes acceleration. If
83549: // it's larger than this, lock the slow-moving axis.
83549: const kAxisLockRatio = 5;
83549: 
83777: // The element tag names that are considered to receive input. Mouse-down
83777: // events directed to one of these are allowed to go through.
83777: const kElementsReceivingInput = {
83777:     applet: true,
83777:     audio: true,
83777:     button: true,
83777:     embed: true,
83777:     input: true,
83777:     map: true,
83777:     select: true,
83777:     textarea: true,
83777:     video: true
83777: };
83777: 
92831: // How many pixels on each side to buffer.
92831: const kBufferAmount = 300;
92831: 
92831: // Whether we're using GL layers.
92831: const kUsingGLLayers = true;
92831: 
83485: function dump(a) {
83503:   Cc["@mozilla.org/consoleservice;1"].getService(Ci.nsIConsoleService).logStringMessage(a);
64692: }
64692: 
83900: function getBridge() {
83900:   return Cc["@mozilla.org/android/bridge;1"].getService(Ci.nsIAndroidBridge);
83900: }
83900: 
83515: function sendMessageToJava(aMessage) {
83900:   return getBridge().handleGeckoMessage(JSON.stringify(aMessage));
66240: }
66240: 
80838: #ifdef MOZ_CRASHREPORTER
80838: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
66242: XPCOMUtils.defineLazyServiceGetter(this, "CrashReporter",
66242:   "@mozilla.org/xre/app-info;1", "nsICrashReporter");
66242: #endif
66242: 
85027: XPCOMUtils.defineLazyGetter(this, "ContentAreaUtils", function() {
85027:   let ContentAreaUtils = {};
85027:   Services.scriptloader.loadSubScript("chrome://global/content/contentAreaUtils.js", ContentAreaUtils);
85027:   return ContentAreaUtils;
85027: });
85027: 
83580: function resolveGeckoURI(aURI) {
83580:   if (aURI.indexOf("chrome://") == 0) {
83580:     let registry = Cc['@mozilla.org/chrome/chrome-registry;1'].getService(Ci["nsIChromeRegistry"]);
83580:     return registry.convertChromeURL(Services.io.newURI(aURI, null, null)).spec;
83580:   } else if (aURI.indexOf("resource://") == 0) {
83580:     let handler = Services.io.getProtocolHandler("resource").QueryInterface(Ci.nsIResProtocolHandler);
83580:     return handler.resolveURI(Services.io.newURI(aURI, null, null));
83580:   }
83580:   return aURI;
66745: }
67358: 
83627: /**
83627:  * Cache of commonly used string bundles.
83627:  */
83627: var Strings = {};
83627: [
83627:   ["brand",      "chrome://branding/locale/brand.properties"],
87960:   ["browser",    "chrome://browser/locale/browser.properties"],
90127:   ["charset",    "chrome://global/locale/charsetTitles.properties"]
83627: ].forEach(function (aStringBundle) {
83627:   let [name, bundle] = aStringBundle;
83627:   XPCOMUtils.defineLazyGetter(Strings, name, function() {
83627:     return Services.strings.createBundle(bundle);
83627:   });
83627: });
66643: 
86564: var MetadataProvider = {
86564:   getDrawMetadata: function getDrawMetadata() {
86564:     return BrowserApp.getDrawMetadata();
86564:   },
86564: 
86564:   paintingSuppressed: function paintingSuppressed() {
86799:     // Get the current tab. Don't suppress painting if there are no tabs yet.
86799:     let tab = BrowserApp.selectedTab;
86799:     if (!tab)
86564:       return false;
86799: 
86799:     // If the viewport metadata has not yet been updated (and therefore the browser size has not
86799:     // been changed accordingly), do not draw yet. We'll get an unsightly flash on page transitions
86799:     // otherwise, because we receive a paint event after the new document is shown but before the
86799:     // correct browser size for the new document has been set.
86799:     //
86799:     // This whole situation exists because the docshell and the browser element are unaware of the
86799:     // existence of <meta viewport>. Therefore they dispatch paint events without knowledge of the
86799:     // invariant that the page must not be drawn until the browser size has been appropriately set.
86799:     // It would be easier if the docshell were made aware of the existence of <meta viewport> so
86799:     // that this logic could be removed.
86799: 
86799:     let viewportDocumentId = tab.documentIdForCurrentViewport;
86799:     let contentDocumentId = ViewportHandler.getIdForDocument(tab.browser.contentDocument);
86799:     if (viewportDocumentId != null && viewportDocumentId != contentDocumentId)
86799:       return true;
86799: 
86799:     // Suppress painting if the current presentation shell is suppressing painting.
86799:     let cwu = tab.browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
86564:                                        .getInterface(Ci.nsIDOMWindowUtils);
86564:     return cwu.paintingSuppressed;
86564:   }
86564: };
86564: 
83514: var BrowserApp = {
64956:   _tabs: [],
65008:   _selectedTab: null,
65097: 
83514:   deck: null,
77160: 
66067:   startup: function startup() {
83514:     window.QueryInterface(Ci.nsIDOMChromeWindow).browserDOMWindow = new nsBrowserAccess();
83514:     dump("zerdatime " + Date.now() + " - browser chrome startup finished.");
64956: 
83514:     this.deck = document.getElementById("browsers");
83514:     BrowserEventHandler.init();
83966:     ViewportHandler.init();
66265: 
86564:     getBridge().setDrawMetadataProvider(MetadataProvider);
83900: 
83584:     Services.obs.addObserver(this, "Tab:Add", false);
83584:     Services.obs.addObserver(this, "Tab:Load", false);
88067:     Services.obs.addObserver(this, "Tab:Selected", false);
88066:     Services.obs.addObserver(this, "Tab:Closed", false);
87329:     Services.obs.addObserver(this, "Tab:Screenshot", false);
83677:     Services.obs.addObserver(this, "Session:Back", false);
83677:     Services.obs.addObserver(this, "Session:Forward", false);
83677:     Services.obs.addObserver(this, "Session:Reload", false);
83864:     Services.obs.addObserver(this, "Session:Stop", false);
83605:     Services.obs.addObserver(this, "SaveAs:PDF", false);
83776:     Services.obs.addObserver(this, "Browser:Quit", false);
83611:     Services.obs.addObserver(this, "Preferences:Get", false);
83611:     Services.obs.addObserver(this, "Preferences:Set", false);
83628:     Services.obs.addObserver(this, "ScrollTo:FocusedInput", false);
83655:     Services.obs.addObserver(this, "Sanitize:ClearAll", false);
83777:     Services.obs.addObserver(this, "PanZoom:PanZoom", false);
83760:     Services.obs.addObserver(this, "FullScreen:Exit", false);
83900:     Services.obs.addObserver(this, "Viewport:Change", false);
84211:     Services.obs.addObserver(this, "SearchEngines:Get", false);
89805:     Services.obs.addObserver(this, "Passwords:Init", false);
66512: 
90096:     Services.obs.addObserver(this, "sessionstore-state-purge-complete", false);
90096: 
83828:     function showFullScreenWarning() {
83828:       NativeWindow.toast.show(Strings.browser.GetStringFromName("alertFullScreenToast"), "short");
83828:     }
83828: 
83760:     window.addEventListener("fullscreen", function() {
83760:       sendMessageToJava({
83760:         gecko: {
83760:           type: window.fullScreen ? "ToggleChrome:Show" : "ToggleChrome:Hide"
83760:         }
83760:       });
88311:     }, false);
88311: 
88311:     window.addEventListener("mozfullscreenchange", function() {
88311:       sendMessageToJava({
88311:         gecko: {
88311:           type: document.mozFullScreen ? "DOMFullScreen:Start" : "DOMFullScreen:Stop"
88311:         }
88311:       });
88311: 
88311:       if (document.mozFullScreen)
83828:         showFullScreenWarning();
83760:     }, false);
83760: 
83828:     // When a restricted key is pressed in DOM full-screen mode, we should display
83828:     // the "Press ESC to exit" warning message.
83828:     window.addEventListener("MozShowFullScreenWarning", showFullScreenWarning, true);
83828: 
83603:     NativeWindow.init();
83633:     Downloads.init();
84564:     FormAssistant.init();
83786:     OfflineApps.init();
83833:     IndexedDB.init();
83922:     XPInstallObserver.init();
83993:     ConsoleAPI.init();
84521:     ClipboardHelper.init();
84883:     PermissionsHelper.init();
87960:     CharacterEncoding.init();
67237: 
83633:     // Init LoginManager
83633:     Cc["@mozilla.org/login-manager;1"].getService(Ci.nsILoginManager);
84564:     // Init FormHistory
84564:     Cc["@mozilla.org/satchel/form-history;1"].getService(Ci.nsIFormHistory2);
66512: 
86562:     let url = "about:home";
88471:     let forceRestore = false;
87063:     if ("arguments" in window) {
87063:       if (window.arguments[0])
86881:         url = window.arguments[0];
87063:       if (window.arguments[1])
88471:         forceRestore = window.arguments[1];
87827:       if (window.arguments[2])
87827:         gScreenWidth = window.arguments[2];
87827:       if (window.arguments[3])
87827:         gScreenHeight = window.arguments[3];
87063:     }
66685: 
83485:     // XXX maybe we don't do this if the launch was kicked off from external
83501:     Services.io.offline = false;
66265: 
73563:     // Broadcast a UIReady message so add-ons know we are finished with startup
65886:     let event = document.createEvent("Events");
65886:     event.initEvent("UIReady", true, false);
65886:     window.dispatchEvent(event);
64845: 
85984:     // restore the previous session
85984:     let ss = Cc["@mozilla.org/browser/sessionstore;1"].getService(Ci.nsISessionStore);
88471:     if (forceRestore || ss.shouldRestore()) {
86562:       // A restored tab should not be active if we are loading a URL
86562:       let restoreToFront = false;
86562: 
89271:       sendMessageToJava({
89271:         gecko: {
89271:           type: "Session:RestoreBegin"
89271:         }
89271:       });
89271: 
86562:       // Open any commandline URLs, except the homepage
86562:       if (url && url != "about:home") {
86562:         this.addTab(url);
86562:       } else {
86562:         // Let the session make a restored tab active
86562:         restoreToFront = true;
88471:       }
86562: 
86562:       // Be ready to handle any restore failures by making sure we have a valid tab opened
86562:       let restoreCleanup = {
86562:         observe: function(aSubject, aTopic, aData) {
86562:           Services.obs.removeObserver(restoreCleanup, "sessionstore-windows-restored");
88471:           if (aData == "fail") {
89282:             BrowserApp.addTab("about:home", {
89282:               showProgress: false,
89282:               selected: restoreToFront
89282:             });
86562:           }
89271: 
89271:           sendMessageToJava({
89271:             gecko: {
89271:               type: "Session:RestoreEnd"
89271:             }
89271:           });
88471:         }
86562:       };
86562:       Services.obs.addObserver(restoreCleanup, "sessionstore-windows-restored", false);
86562: 
86562:       // Start the restore
88471:       ss.restoreLastSession(restoreToFront, forceRestore);
86562:     } else {
88628:       this.addTab(url, { showProgress: url != "about:home" });
86971: 
86971:       // show telemetry door hanger if we aren't restoring a session
86971:       this._showTelemetryPrompt();
86562:     }
85984: 
83614:     // notify java that gecko has loaded
83614:     sendMessageToJava({
83614:       gecko: {
83614:         type: "Gecko:Ready"
72022:       }
83614:     });
89419: 
89419:     // after gecko has loaded, set the checkerboarding pref once at startup (for testing only)
89419:     sendMessageToJava({
89419:       gecko: {
89419:         "type": "Checkerboard:Toggle",
89419:         "value": Services.prefs.getBoolPref("gfx.show_checkerboard_pattern")
89419:       }
89419:     });
86971:   },
86971: 
86971:   _showTelemetryPrompt: function _showTelemetryPrompt() {
89889:     const PREF_TELEMETRY_PROMPTED = "toolkit.telemetry.prompted";
89889:     const PREF_TELEMETRY_ENABLED = "toolkit.telemetry.enabled";
89889:     const PREF_TELEMETRY_REJECTED = "toolkit.telemetry.rejected";
89889: 
89889:     // This is used to reprompt users when privacy message changes
89889:     const TELEMETRY_PROMPT_REV = 2;
89889: 
89889:     let telemetryPrompted = null;
83791:     try {
89889:       telemetryPrompted = Services.prefs.getIntPref(PREF_TELEMETRY_PROMPTED);
86971:     } catch (e) { /* Optional */ }
89889: 
89889:     // If the user has seen the latest telemetry prompt, do not prompt again
89889:     // else clear old prefs and reprompt
89889:     if (telemetryPrompted === TELEMETRY_PROMPT_REV)
86971:       return;
86971: 
89889:     Services.prefs.clearUserPref(PREF_TELEMETRY_PROMPTED);
89889:     Services.prefs.clearUserPref(PREF_TELEMETRY_ENABLED);
89889:   
83791:     let buttons = [
83791:       {
83791:         label: Strings.browser.GetStringFromName("telemetry.optin.yes"),
83791:         callback: function () {
89889:           Services.prefs.setIntPref(PREF_TELEMETRY_PROMPTED, TELEMETRY_PROMPT_REV);
89889:           Services.prefs.setBoolPref(PREF_TELEMETRY_ENABLED, true);
83791:         }
83791:       },
83791:       {
83791:         label: Strings.browser.GetStringFromName("telemetry.optin.no"),
83791:         callback: function () {
89889:           Services.prefs.setIntPref(PREF_TELEMETRY_PROMPTED, TELEMETRY_PROMPT_REV);
89889:           Services.prefs.setBoolPref(PREF_TELEMETRY_REJECTED, true);
83791:         }
83791:       }
83791:     ];
89889: 
83791:     let brandShortName = Strings.brand.GetStringFromName("brandShortName");
83791:     let message = Strings.browser.formatStringFromName("telemetry.optin.message", [brandShortName], 1);
83791:     NativeWindow.doorhanger.show(message, "telemetry-optin", buttons);
66067:   },
66067: 
66067:   shutdown: function shutdown() {
83603:     NativeWindow.uninit();
84564:     FormAssistant.uninit();
83786:     OfflineApps.uninit();
83833:     IndexedDB.uninit();
83966:     ViewportHandler.uninit();
83922:     XPInstallObserver.uninit();
83993:     ConsoleAPI.uninit();
87960:     CharacterEncoding.uninit();
64956:   },
64956: 
66067:   get tabs() {
66067:     return this._tabs;
66067:   },
66067: 
83514:   get selectedTab() {
83514:     return this._selectedTab;
83514:   },
83514: 
83514:   set selectedTab(aTab) {
89157:     if (this._selectedTab)
89157:       this._selectedTab.setActive(false);
89157: 
83514:     this._selectedTab = aTab;
83514:     if (!aTab)
83514:       return;
83514: 
89157:     aTab.setActive(true);
84003:     aTab.updateViewport(false);
83934:     this.deck.selectedPanel = aTab.vbox;
83514:   },
83514: 
83514:   get selectedBrowser() {
83514:     if (this._selectedTab)
83514:       return this._selectedTab.browser;
83514:     return null;
83514:   },
83514: 
83541:   getTabForId: function getTabForId(aId) {
83541:     let tabs = this._tabs;
83541:     for (let i=0; i < tabs.length; i++) {
83541:        if (tabs[i].id == aId)
83541:          return tabs[i];
83541:     }
83541:     return null;
83541:   },
83541: 
66271:   getTabForBrowser: function getTabForBrowser(aBrowser) {
66271:     let tabs = this._tabs;
66271:     for (let i = 0; i < tabs.length; i++) {
66271:       if (tabs[i].browser == aBrowser)
66271:         return tabs[i];
66271:     }
66271:     return null;
66271:   },
66271: 
83514:   getBrowserForWindow: function getBrowserForWindow(aWindow) {
83514:     let tabs = this._tabs;
83514:     for (let i = 0; i < tabs.length; i++) {
83514:       if (tabs[i].browser.contentWindow == aWindow)
83514:         return tabs[i].browser;
67495:     }
67495:     return null;
67495:   },
67495: 
83514:   getBrowserForDocument: function getBrowserForDocument(aDocument) {
83514:     let tabs = this._tabs;
83514:     for (let i = 0; i < tabs.length; i++) {
83514:       if (tabs[i].browser.contentDocument == aDocument)
83514:         return tabs[i].browser;
64956:     }
64956:     return null;
64956:   },
64956: 
84791:   loadURI: function loadURI(aURI, aBrowser, aParams) {
84791:     aBrowser = aBrowser || this.selectedBrowser;
84791:     if (!aBrowser)
80300:       return;
80300: 
84937:     aParams = aParams || {};
84937: 
84791:     let flags = "flags" in aParams ? aParams.flags : Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
80300:     let postData = ("postData" in aParams && aParams.postData) ? aParams.postData.value : null;
80300:     let referrerURI = "referrerURI" in aParams ? aParams.referrerURI : null;
80300:     let charset = "charset" in aParams ? aParams.charset : null;
84791: 
87744:     if ("showProgress" in aParams) {
87744:       let tab = this.getTabForBrowser(aBrowser);
87744:       if (tab)
87744:         tab.showProgress = aParams.showProgress;
87744:     }
87744: 
84791:     try {
84791:       aBrowser.loadURIWithFlags(aURI, flags, referrerURI, charset, postData);
84791:     } catch(e) {
84791:       let tab = this.getTabForBrowser(aBrowser);
84791:       if (tab) {
84791:         let message = {
84791:           gecko: {
84791:             type: "Content:LoadError",
84791:             tabID: tab.id,
84791:             uri: aBrowser.currentURI.spec,
84791:             title: aBrowser.contentTitle
84791:           }
84791:         };
84791:         sendMessageToJava(message);
84791:         dump("Handled load error: " + e)
84791:       }
84791:     }
80300:   },
80300: 
83762:   addTab: function addTab(aURI, aParams) {
88628:     aParams = aParams || {};
88628: 
83762:     let newTab = new Tab(aURI, aParams);
64956:     this._tabs.push(newTab);
88628: 
89157:     let selected = "selected" in aParams ? aParams.selected : true;
89157:     if (selected)
89157:       this.selectedTab = newTab;
84019: 
85984:     let evt = document.createEvent("UIEvents");
85984:     evt.initUIEvent("TabOpen", true, false, window, null);
85984:     newTab.browser.dispatchEvent(evt);
85984: 
64956:     return newTab;
64956:   },
64956: 
88066:   // Use this method to close a tab from JS. This method sends a message
88066:   // to Java to close the tab in the Java UI (we'll get a Tab:Closed message
88066:   // back from Java when that happens).
87856:   closeTab: function closeTab(aTab) {
88066:     if (!aTab) {
88066:       Cu.reportError("Error trying to close tab (tab doesn't exist)");
88066:       return;
88066:     }
88066: 
88066:     let message = {
88066:       gecko: {
88066:         type: "Tab:Close",
88066:         tabID: aTab.id
88066:       }
88066:     };
88066:     sendMessageToJava(message);
88066:   },
88066: 
88066:   // Calling this will update the state in BrowserApp after a tab has been
88066:   // closed in the Java UI.
88066:   _handleTabClosed: function _handleTabClosed(aTab) {
83514:     if (aTab == this.selectedTab)
83514:       this.selectedTab = null;
64956: 
85984:     let evt = document.createEvent("UIEvents");
85984:     evt.initUIEvent("TabClose", true, false, window, null);
85984:     aTab.browser.dispatchEvent(evt);
85984: 
83514:     aTab.destroy();
83514:     this._tabs.splice(this._tabs.indexOf(aTab), 1);
67453:   },
67453: 
88257:   screenshotQueue: null,
88257: 
87329:   screenshotTab: function screenshotTab(aData) {
88257:       if (this.screenshotQueue == null) {
88257:           this.screenShotQueue = [];
88257:           this.doScreenshotTab(aData);
88257:       } else {
88257:           this.screenshotQueue.push(aData);
88257:       }
88257:   },
88257: 
88257:   doNextScreenshot: function() {
88257:       if (this.screenshotQueue == null || this.screenshotQueue.length == 0) {
88257:           this.screenshotQueue = null;
88257:           return;
88257:       }
88257:       let data = this.screenshotQueue.pop();
88257:       if (data == null) {
88257:           this.screenshotQueue = null;
88257:           return;
88257:       }
88257:       this.doScreenshotTab(data);
88257:   },
88257: 
88257:   doScreenshotTab: function doScreenshotTab(aData) {
87329:       let json = JSON.parse(aData);
87329:       let tab = this.getTabForId(parseInt(json.tabID));
88306:       tab.screenshot(json.source, json.destination);
87329:   },
87329: 
88067:   // Use this method to select a tab from JS. This method sends a message
88067:   // to Java to select the tab in the Java UI (we'll get a Tab:Selected message
88067:   // back from Java when that happens).
83584:   selectTab: function selectTab(aTab) {
88067:     if (!aTab) {
88067:       Cu.reportError("Error trying to select tab (tab doesn't exist)");
88067:       return;
88067:     }
88067: 
88067:     let message = {
88067:       gecko: {
88067:         type: "Tab:Select",
88067:         tabID: aTab.id
88067:       }
88067:     };
88067:     sendMessageToJava(message);
88067:   },
88067: 
88067:   // This method updates the state in BrowserApp after a tab has been selected
88067:   // in the Java UI.
88067:   _handleTabSelected: function _handleTabSelected(aTab) {
83584:     this.selectedTab = aTab;
67453: 
85984:     let evt = document.createEvent("UIEvents");
85984:     evt.initUIEvent("TabSelect", true, false, window, null);
85984:     aTab.browser.dispatchEvent(evt);
88244: 
88244:     let message = {
88244:       gecko: {
88244:         type: "Tab:Selected:Done",
88244:         tabID: aTab.id
88244:       }
88244:     };
88244:     sendMessageToJava(message);
64742:   },
64742: 
83857:   quit: function quit() {
86972:     // Figure out if there's at least one other browser window around.
86972:     let lastBrowser = true;
86972:     let e = Services.wm.getEnumerator("navigator:browser");
86972:     while (e.hasMoreElements() && lastBrowser) {
86972:       let win = e.getNext();
86972:       if (win != window)
86972:         lastBrowser = false;
86972:     }
86972: 
86972:     if (lastBrowser) {
86972:       // Let everyone know we are closing the last browser window
86972:       let closingCanceled = Cc["@mozilla.org/supports-PRBool;1"].createInstance(Ci.nsISupportsPRBool);
86972:       Services.obs.notifyObservers(closingCanceled, "browser-lastwindow-close-requested", null);
86972:       if (closingCanceled.data)
86972:         return;
86972: 
86972:       Services.obs.notifyObservers(null, "browser-lastwindow-close-granted", null);
86972:     }
86972: 
83857:     window.QueryInterface(Ci.nsIDOMChromeWindow).minimize();
83857:     window.close();
83857:   },
83857: 
83605:   saveAsPDF: function saveAsPDF(aBrowser) {
83605:     // Create the final destination file location
88072:     let fileName = ContentAreaUtils.getDefaultFileName(aBrowser.contentTitle, aBrowser.currentURI, null, null);
83605:     fileName = fileName.trim() + ".pdf";
83605: 
83605:     let dm = Cc["@mozilla.org/download-manager;1"].getService(Ci.nsIDownloadManager);
83605:     let downloadsDir = dm.defaultDownloadsDirectory;
83605: 
83605:     let file = downloadsDir.clone();
83605:     file.append(fileName);
83763:     file.createUnique(file.NORMAL_FILE_TYPE, parseInt("666", 8));
83605: 
83605:     let printSettings = Cc["@mozilla.org/gfx/printsettings-service;1"].getService(Ci.nsIPrintSettingsService).newPrintSettings;
83605:     printSettings.printSilent = true;
83605:     printSettings.showPrintProgress = false;
83605:     printSettings.printBGImages = true;
83605:     printSettings.printBGColors = true;
83605:     printSettings.printToFile = true;
83605:     printSettings.toFileName = file.path;
83605:     printSettings.printFrameType = Ci.nsIPrintSettings.kFramesAsIs;
83605:     printSettings.outputFormat = Ci.nsIPrintSettings.kOutputFormatPDF;
83605: 
83605:     //XXX we probably need a preference here, the header can be useful
83605:     printSettings.footerStrCenter = "";
83605:     printSettings.footerStrLeft   = "";
83605:     printSettings.footerStrRight  = "";
83605:     printSettings.headerStrCenter = "";
83605:     printSettings.headerStrLeft   = "";
83605:     printSettings.headerStrRight  = "";
83605: 
87180:     // Create a valid mimeInfo for the PDF
87180:     let ms = Cc["@mozilla.org/mime;1"].getService(Ci.nsIMIMEService);
87180:     let mimeInfo = ms.getFromTypeAndExtension("application/pdf", "pdf");
87180: 
87636:     let webBrowserPrint = aBrowser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor)
87636:                                                 .getInterface(Ci.nsIWebBrowserPrint);
83605: 
83930:     let cancelable = {
83930:       cancel: function (aReason) {
83930:         webBrowserPrint.cancel();
83930:       }
83930:     }
83930:     let download = dm.addDownload(Ci.nsIDownloadManager.DOWNLOAD_TYPE_DOWNLOAD,
83930:                                   aBrowser.currentURI,
87180:                                   Services.io.newFileURI(file), "", mimeInfo,
83930:                                   Date.now() * 1000, null, cancelable);
83605: 
83930:     webBrowserPrint.print(printSettings, download);
83605:   },
83605: 
83611:   getPreferences: function getPreferences(aPrefNames) {
83611:     try {
83611:       let json = JSON.parse(aPrefNames);
83611:       let prefs = [];
83611: 
83611:       for each (let prefName in json) {
83611:         let pref = {
83618:           name: prefName
83611:         };
83611: 
84514:         // The plugin pref is actually two separate prefs, so
84514:         // we need to handle it differently
84514:         if (prefName == "plugin.enable") {
84514:           // Use a string type for java's ListPreference
84514:           pref.type = "string";
84514:           pref.value = PluginHelper.getPluginPreference();
84514:           prefs.push(pref);
84514:           continue;
86025:         } else if (prefName == MasterPassword.pref) {
86025:           // Master password is not a "real" pref
86025:           pref.type = "bool";
86025:           pref.value = MasterPassword.enabled;
86025:           prefs.push(pref);
86025:           continue;
84514:         }
84514: 
83612:         try {
83611:           switch (Services.prefs.getPrefType(prefName)) {
83611:             case Ci.nsIPrefBranch.PREF_BOOL:
83611:               pref.type = "bool";
83611:               pref.value = Services.prefs.getBoolPref(prefName);
64692:               break;
83611:             case Ci.nsIPrefBranch.PREF_INT:
83611:               pref.type = "int";
83611:               pref.value = Services.prefs.getIntPref(prefName);
83611:               break;
83612:             case Ci.nsIPrefBranch.PREF_STRING:
64692:             default:
83611:               pref.type = "string";
87959:               pref.value = Services.prefs.getComplexValue(prefName, Ci.nsIPrefLocalizedString).data;
64692:               break;
64692:           }
83612:         } catch (e) {
83612:             // preference does not exist; do not send it
83612:             continue;
83612:         }
83612: 
83612:         // some preferences use integers or strings instead of booleans for
83612:         // indicating enabled/disabled. since the java ui uses the type to
83612:         // determine which ui elements to show, we need to normalize these
83612:         // preferences to be actual booleans.
83612:         switch (prefName) {
83612:           case "network.cookie.cookieBehavior":
83612:             pref.type = "bool";
83612:             pref.value = pref.value == 0;
83612:             break;
84672:           case "font.size.inflation.minTwips":
84672:             pref.type = "string";
84672:             pref.value = pref.value.toString();
84672:             break;
83612:         }
83611: 
83611:         prefs.push(pref);
83611:       }
83611: 
83611:       sendMessageToJava({
83611:         gecko: {
83611:           type: "Preferences:Data",
83611:           preferences: prefs
83611:         }
83611:       });
83611:     } catch (e) {}
64692:   },
64692: 
83611:   setPreferences: function setPreferences(aPref) {
83611:     let json = JSON.parse(aPref);
83611: 
84514:     // The plugin pref is actually two separate prefs, so
84514:     // we need to handle it differently
84514:     if (json.name == "plugin.enable") {
84514:       PluginHelper.setPluginPreference(json.value);
84514:       return;
86025:     } else if(json.name == MasterPassword.pref) {
86025:       if (MasterPassword.enabled)
86025:         MasterPassword.removePassword(json.value);
86025:       else
86025:         MasterPassword.setPassword(json.value);
84514:     }
84514: 
83612:     // when sending to java, we normalized special preferences that use
83612:     // integers and strings to represent booleans.  here, we convert them back
83612:     // to their actual types so we can store them.
83612:     switch (json.name) {
83612:       case "network.cookie.cookieBehavior":
83612:         json.type = "int";
83612:         json.value = (json.value ? 0 : 2);
83612:         break;
84672:       case "font.size.inflation.minTwips":
84672:         json.type = "int";
84672:         json.value = parseInt(json.value);
84672:         break;
83612:     }
83612: 
83611:     if (json.type == "bool")
83611:       Services.prefs.setBoolPref(json.name, json.value);
83611:     else if (json.type == "int")
83611:       Services.prefs.setIntPref(json.name, json.value);
83612:     else {
83612:       let pref = Cc["@mozilla.org/pref-localizedstring;1"].createInstance(Ci.nsIPrefLocalizedString);
83612:       pref.data = json.value;
83612:       Services.prefs.setComplexValue(json.name, Ci.nsISupportsString, pref);
83612:     }
64692:   },
64692: 
84211:   getSearchEngines: function() {
88609:     let engineData = Services.search.getVisibleEngines({});
84211:     let searchEngines = engineData.map(function (engine) {
84211:       return {
84211:         name: engine.name,
84211:         iconURI: engine.iconURI.spec
84211:       };
84211:     });
84211: 
84211:     sendMessageToJava({
84211:       gecko: {
84211:         type: "SearchEngines:Data",
84211:         searchEngines: searchEngines
84211:       }
84211:     });
84211:   },
84211: 
89270:   getSearchOrURI: function getSearchOrURI(aParams) {
84211:     let uri;
85042:     if (aParams.engine) {
89270:       let engine = Services.search.getEngineByName(aParams.engine);
84489:       if (engine)
85042:         uri = engine.getSubmission(aParams.url).uri;
84489:     }
85042:     return uri ? uri.spec : aParams.url;
84211:   },
84211: 
83628:   scrollToFocusedInput: function(aBrowser) {
83628:     let doc = aBrowser.contentDocument;
83628:     if (!doc)
83628:       return;
83628:     let focused = doc.activeElement;
84032:     if ((focused instanceof HTMLInputElement && focused.mozIsTextField(false)) || (focused instanceof HTMLTextAreaElement)) {
86386:       let tab = BrowserApp.getTabForBrowser(aBrowser);
86386:       let win = aBrowser.contentWindow;
86386: 
86386:       // tell gecko to scroll the field into view. this will scroll any nested scrollable elements
86386:       // as well as the browser's content window, and modify the scrollX and scrollY on the content window.
88315:       focused.scrollIntoView(false);
86386: 
86386:       // update userScrollPos so that we don't send a duplicate viewport update by triggering
86386:       // our scroll listener
86386:       tab.userScrollPos.x = win.scrollX;
86386:       tab.userScrollPos.y = win.scrollY;
86386: 
86386:       // note that:
86386:       // 1. because of the way we do zooming using a CSS transform, gecko does not take into
86386:       // account the effect of the zoom on the viewport size.
86386:       // 2. if the input element is near the bottom/right of the page (less than one viewport
86386:       // height/width away from the bottom/right), the scrollIntoView call will make gecko scroll to the
86386:       // bottom/right of the page in an attempt to align the input field with the top of the viewport.
86386:       // however, since gecko doesn't know about the zoom, what it thinks is the "bottom/right of
86386:       // the page" isn't actually the bottom/right of the page at the current zoom level, and we 
86386:       // need to adjust this further.
86386:       // 3. we can't actually adjust this by changing the window scroll position, as gecko already thinks
86386:       // we're at the bottom/right, so instead we do it by changing the viewportExcess on the tab and
86386:       // moving the browser element.
86386: 
86386:       let visibleContentWidth = tab._viewport.width / tab._viewport.zoom;
86386:       let visibleContentHeight = tab._viewport.height / tab._viewport.zoom;
86386:       // get the rect that the focused element occupies relative to what gecko thinks the viewport is,
86386:       // and adjust it by viewportExcess to so that it is relative to what the user sees as the viewport.
86386:       let focusedRect = focused.getBoundingClientRect();
86386:       focusedRect = {
86386:         left: focusedRect.left - tab.viewportExcess.x,
86386:         right: focusedRect.right - tab.viewportExcess.x,
86386:         top: focusedRect.top - tab.viewportExcess.y,
86386:         bottom: focusedRect.bottom - tab.viewportExcess.y
86386:       };
86386:       if (focusedRect.right >= visibleContentWidth && focusedRect.left > 0) {
86386:         // the element is too far off the right side, so we need to scroll to the right more
86386:         tab.viewportExcess.x += Math.min(focusedRect.left, focusedRect.right - visibleContentWidth);
86386:       } else if (focusedRect.left < 0) {
86386:         // the element is too far off the left side, so we need to scroll to the left more
86386:         tab.viewportExcess.x += focusedRect.left;
86386:       }
86386:       if (focusedRect.bottom >= visibleContentHeight && focusedRect.top > 0) {
86386:         // the element is too far down, so we need to scroll down more
86386:         tab.viewportExcess.y += Math.min(focusedRect.top, focusedRect.bottom - visibleContentHeight);
86386:       } else if (focusedRect.top < 0) {
86386:         // the element is too far up, so we need to scroll up more
86386:         tab.viewportExcess.y += focusedRect.top;
92841:       }
86386:       // finally, let java know where we ended up
86386:       tab.sendViewportUpdate();
84032:     }
83628:   },
83628: 
83900:   getDrawMetadata: function getDrawMetadata() {
88097:     let viewport = this.selectedTab.viewport;
88097: 
88097:     // Sample the background color of the page and pass it along. (This is used to draw the
88097:     // checkerboard.)
88097:     try {
88097:       let browser = this.selectedBrowser;
88097:       if (browser) {
88097:         let { contentDocument, contentWindow } = browser;
88097:         let computedStyle = contentWindow.getComputedStyle(contentDocument.body);
88097:         viewport.backgroundColor = computedStyle.backgroundColor;
88097:       }
88097:     } catch (e) {
88097:       // Ignore. Catching and ignoring exceptions here ensures that Talos succeeds.
88097:     }
88097: 
88097:     return JSON.stringify(viewport);
83900:   },
83900: 
83514:   observe: function(aSubject, aTopic, aData) {
83514:     let browser = this.selectedBrowser;
83514:     if (!browser)
83514:       return;
80300: 
83677:     if (aTopic == "Session:Back") {
83514:       browser.goBack();
83677:     } else if (aTopic == "Session:Forward") {
83675:       browser.goForward();
83677:     } else if (aTopic == "Session:Reload") {
83514:       browser.reload();
83864:     } else if (aTopic == "Session:Stop") {
83864:       browser.stop();
84791:     } else if (aTopic == "Tab:Add" || aTopic == "Tab:Load") {
85042:       let data = JSON.parse(aData);
85042: 
84791:       // Pass LOAD_FLAGS_DISALLOW_INHERIT_OWNER to prevent any loads from
84791:       // inheriting the currently loaded document's principal.
84791:       let params = {
84791:         selected: true,
85042:         parentId: ("parentId" in data) ? data.parentId : -1,
84791:         flags: Ci.nsIWebNavigation.LOAD_FLAGS_DISALLOW_INHERIT_OWNER
88133:              | Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
84791:       };
84791: 
89270:       let url = this.getSearchOrURI(data);
87744: 
87744:       // Don't show progress throbber for about:home
87744:       if (url == "about:home")
87744:         params.showProgress = false;
87744: 
84791:       if (aTopic == "Tab:Add")
84791:         this.addTab(url, params);
84791:       else
84791:         this.loadURI(url, browser, params);
88067:     } else if (aTopic == "Tab:Selected") {
88067:       this._handleTabSelected(this.getTabForId(parseInt(aData)));
88066:     } else if (aTopic == "Tab:Closed") {
88066:       this._handleTabClosed(this.getTabForId(parseInt(aData)));
87329:     } else if (aTopic == "Tab:Screenshot") {
87329:       this.screenshotTab(aData);
88257:     } else if (aTopic == "Tab:Screenshot:Cancel") {
88257:       this.screenshotQueue = null;
83857:     } else if (aTopic == "Browser:Quit") {
83857:       this.quit();
83624:     } else if (aTopic == "SaveAs:PDF") {
83605:       this.saveAsPDF(browser);
83624:     } else if (aTopic == "Preferences:Get") {
83611:       this.getPreferences(aData);
83624:     } else if (aTopic == "Preferences:Set") {
83611:       this.setPreferences(aData);
83628:     } else if (aTopic == "ScrollTo:FocusedInput") {
83628:       this.scrollToFocusedInput(browser);
83655:     } else if (aTopic == "Sanitize:ClearAll") {
83655:       Sanitizer.sanitize();
83760:     } else if (aTopic == "FullScreen:Exit") {
83760:       browser.contentDocument.mozCancelFullScreen();
83900:     } else if (aTopic == "Viewport:Change") {
83934:       this.selectedTab.viewport = JSON.parse(aData);
83966:       ViewportHandler.onResize();
84211:     } else if (aTopic == "SearchEngines:Get") {
84211:       this.getSearchEngines();
89805:     } else if (aTopic == "Passwords:Init") {
89805:       var storage = Components.classes["@mozilla.org/login-manager/storage/mozStorage;1"].  
89805:         getService(Components.interfaces.nsILoginManagerStorage);
89805:       storage.init();
89805: 
89805:       sendMessageToJava({gecko: { type: "Passwords:Init:Return" }});
90096:     } else if (aTopic == "sessionstore-state-purge-complete") {
90096:       sendMessageToJava({ gecko: { type: "Session:StatePurged" }});
83514:     }
83966:   },
83966: 
83966:   get defaultBrowserWidth() {
83966:     delete this.defaultBrowserWidth;
83966:     let width = Services.prefs.getIntPref("browser.viewport.desktopWidth");
83966:     return this.defaultBrowserWidth = width;
80024:   }
83966: };
80300: 
83603: var NativeWindow = {
83603:   init: function() {
83603:     Services.obs.addObserver(this, "Menu:Clicked", false);
83626:     Services.obs.addObserver(this, "Doorhanger:Reply", false);
83710:     this.contextmenus.init();
83603:   },
83603: 
83603:   uninit: function() {
83603:     Services.obs.removeObserver(this, "Menu:Clicked");
83626:     Services.obs.removeObserver(this, "Doorhanger:Reply");
83710:     this.contextmenus.uninit();
83603:   },
83603: 
83618:   toast: {
83618:     show: function(aMessage, aDuration) {
83618:       sendMessageToJava({
83618:         gecko: {
83618:           type: "Toast:Show",
83618:           message: aMessage,
83618:           duration: aDuration
83618:         }
83618:       });
83618:     }
83618:   },
83618: 
83603:   menu: {
83603:     _callbacks: [],
83603:     _menuId: 0,
83603:     add: function(aName, aIcon, aCallback) {
83618:       sendMessageToJava({
83618:         gecko: {
83618:           type: "Menu:Add",
83618:           name: aName,
83618:           icon: aIcon,
83618:           id: this._menuId
83618:         }
83618:       });
83603:       this._callbacks[this._menuId] = aCallback;
83603:       this._menuId++;
83603:       return this._menuId - 1;
83603:     },
83603: 
83603:     remove: function(aId) {
83603:       sendMessageToJava({ gecko: {type: "Menu:Remove", id: aId }});
83603:     }
83603:   },
83603: 
83626:   doorhanger: {
83697:     _callbacks: {},
83626:     _callbacksId: 0,
83626:     _promptId: 0,
83792: 
83793:   /**
83793:    * @param aOptions
83793:    *        An options JavaScript object holding additional properties for the
83793:    *        notification. The following properties are currently supported:
83793:    *        persistence: An integer. The notification will not automatically
83827:    *                     dismiss for this many page loads. If persistence is set
83827:    *                     to -1, the doorhanger will never automatically dismiss.
83793:    *        timeout:     A time in milliseconds. The notification will not
83793:    *                     automatically dismiss before this time.
83793:    */
83793:     show: function(aMessage, aValue, aButtons, aTabID, aOptions) {
83626:       aButtons.forEach((function(aButton) {
83626:         this._callbacks[this._callbacksId] = { cb: aButton.callback, prompt: this._promptId };
83626:         aButton.callback = this._callbacksId;
83626:         this._callbacksId++;
83626:       }).bind(this));
83626: 
83626:       this._promptId++;
83626:       let json = {
83626:         gecko: {
83626:           type: "Doorhanger:Add",
83626:           message: aMessage,
83792:           value: aValue,
83626:           buttons: aButtons,
83792:           // use the current tab if none is provided
83793:           tabID: aTabID || BrowserApp.selectedTab.id,
83793:           options: aOptions || {}
83626:         }
83626:       };
83626:       sendMessageToJava(json);
83834:     },
83834: 
83834:     hide: function(aValue, aTabID) {
83834:       sendMessageToJava({
83834:         type: "Doorhanger:Remove",
83834:         value: aValue,
83834:         tabID: aTabID
83834:       });
83626:     }
83626:   },
83626: 
83603:   observe: function(aSubject, aTopic, aData) {
83626:     if (aTopic == "Menu:Clicked") {
83603:       if (this.menu._callbacks[aData])
83603:         this.menu._callbacks[aData]();
83626:     } else if (aTopic == "Doorhanger:Reply") {
83714:       let reply_id = aData;
83714:       if (this.doorhanger._callbacks[reply_id]) {
83714:         let prompt = this.doorhanger._callbacks[reply_id].prompt;
83714:         this.doorhanger._callbacks[reply_id].cb();
83714:         for (let id in this.doorhanger._callbacks) {
83714:           if (this.doorhanger._callbacks[id].prompt == prompt) {
83714:             delete this.doorhanger._callbacks[id];
83697:           }
83626:         }
83626:       }
83626:     }
83710:   },
83710:   contextmenus: {
83710:     items: {}, //  a list of context menu items that we may show
83710:     _contextId: 0, // id to assign to new context menu items if they are added
83710: 
83710:     init: function() {
85027:       this.imageContext = this.SelectorContext("img");
85027: 
83710:       Services.obs.addObserver(this, "Gesture:LongPress", false);
83710: 
83710:       // TODO: These should eventually move into more appropriate classes
83710:       this.add(Strings.browser.GetStringFromName("contextmenu.openInNewTab"),
86782:                this.linkOpenableContext,
83710:                function(aTarget) {
83710:                  let url = NativeWindow.contextmenus._getLinkURL(aTarget);
85042:                  BrowserApp.addTab(url, { selected: false, parentId: BrowserApp.selectedTab.id });
86233: 
86233:                  let newtabStrings = Strings.browser.GetStringFromName("newtabpopup.opened");
86233:                  let label = PluralForm.get(1, newtabStrings).replace("#1", 1);
86233:                  NativeWindow.toast.show(label, "short");
83710:                });
83710: 
83760:       this.add(Strings.browser.GetStringFromName("contextmenu.fullScreen"),
83794:                this.SelectorContext("video:not(:-moz-full-screen)"),
83760:                function(aTarget) {
83760:                  aTarget.mozRequestFullScreen();
83760:                });
85027: 
85027:       this.add(Strings.browser.GetStringFromName("contextmenu.saveImage"),
85027:                this.imageContext,
85027:                function(aTarget) {
85027:                  let imageCache = Cc["@mozilla.org/image/cache;1"].getService(Ci.imgICache);
85027:                  let props = imageCache.findEntryProperties(aTarget.currentURI, aTarget.ownerDocument.characterSet);
85027:                  var contentDisposition = "";
85027:                  var type = "";
85027:                  try {
85027:                     String(props.get("content-disposition", Ci.nsISupportsCString));
85027:                     String(props.get("type", Ci.nsISupportsCString));
85027:                  } catch(ex) { }
85027:                  var browser = BrowserApp.getBrowserForDocument(aTarget.ownerDocument);
85027:                  ContentAreaUtils.internalSave(aTarget.currentURI.spec, null, null, contentDisposition, type, false, "SaveImageTitle", null, browser.documentURI, true, null);
85027:                });
83710:     },
83710: 
83710:     uninit: function() {
83710:       Services.obs.removeObserver(this, "Gesture:LongPress");
83710:     },
83710: 
83710:     add: function(aName, aSelector, aCallback) {
83710:       if (!aName)
83710:         throw "Menu items must have a name";
83710: 
83710:       let item = {
83710:         name: aName,
83710:         context: aSelector,
83710:         callback: aCallback,
83710:         matches: function(aElt) {
83710:           return this.context.matches(aElt);
83710:         },
83710:         getValue: function() {
83710:           return {
83710:             label: this.name,
83710:             id: this.id
83710:           }
83710:         }
83710:       };
83710:       item.id = this._contextId++;
83710:       this.items[item.id] = item;
83710:       return item.id;
83710:     },
83710: 
83710:     remove: function(aId) {
89217:       delete this.items[aId];
83710:     },
83710: 
83710:     SelectorContext: function(aSelector) {
83710:       return {
83710:         matches: function(aElt) {
83710:           if (aElt.mozMatchesSelector)
83710:             return aElt.mozMatchesSelector(aSelector);
83710:           return false;
83710:         }
83710:       }
83710:     },
83710: 
86782:     linkOpenableContext: {
86782:       matches: function linkOpenableContextMatches(aElement) {
86782:         if (aElement.nodeType == Ci.nsIDOMNode.ELEMENT_NODE &&
86782:             ((aElement instanceof Ci.nsIDOMHTMLAnchorElement && aElement.href) ||
86782:             (aElement instanceof Ci.nsIDOMHTMLAreaElement && aElement.href) ||
86782:             aElement instanceof Ci.nsIDOMHTMLLinkElement ||
86782:             aElement.getAttributeNS(kXLinkNamespace, "type") == "simple")) {
86782:           let uri;
86782:           try {
86782:             let url = NativeWindow.contextmenus._getLinkURL(aElement);
86782:             uri = Services.io.newURI(url, null, null);
86782:           } catch (e) {
86782:             return false;
86782:           }
86782: 
86782:           let scheme = uri.scheme;
86782:           if (!scheme)
86782:             return false;
86782: 
86782:           let dontOpen = /^(mailto|javascript|news|snews)$/;
86782:           return (scheme && !dontOpen.test(scheme));
86782:         }
86782:         return false;
86782:       }
86782:     },
86782: 
87138:     textContext: {
87138:       matches: function textContext(aElement) {
87138:         return ((aElement instanceof Ci.nsIDOMHTMLInputElement && aElement.mozIsTextField(false))
87138:                 || aElement instanceof Ci.nsIDOMHTMLTextAreaElement);
87138:       }
87138:     },
87138: 
83710:     _sendToContent: function(aX, aY) {
83710:       // initially we look for nearby clickable elements. If we don't find one we fall back to using whatever this click was on
83710:       let rootElement = ElementTouchHelper.elementFromPoint(BrowserApp.selectedBrowser.contentWindow, aX, aY);
83710:       if (!rootElement)
83710:         rootElement = ElementTouchHelper.anyElementFromPoint(BrowserApp.selectedBrowser.contentWindow, aX, aY)
83710: 
83710:       this.menuitems = null;
83710:       let element = rootElement;
83710:       if (!element)
83710:         return;
83710: 
83710:       while (element) {
83710:         for each (let item in this.items) {
83710:           // since we'll have to spin through this for each element, check that
83710:           // it is not already in the list
83710:           if ((!this.menuitems || !this.menuitems[item.id]) && item.matches(element)) {
83710:             if (!this.menuitems)
83710:               this.menuitems = {};
83710:             this.menuitems[item.id] = item;
83710:           }
83710:         }
83710: 
86782:         if (this.linkOpenableContext.matches(element) || this.textContext.matches(element))
83710:           break;
83710:         element = element.parentNode;
83710:       }
83710: 
83710:       // only send the contextmenu event to content if we are planning to show a context menu (i.e. not on every long tap)
83710:       if (this.menuitems) {
83710:         BrowserEventHandler.blockClick = true;
83710:         let event = rootElement.ownerDocument.createEvent("MouseEvent");
83710:         event.initMouseEvent("contextmenu", true, true, content,
83710:                              0, aX, aY, aX, aY, false, false, false, false,
83710:                              0, null);
83710:         rootElement.ownerDocument.defaultView.addEventListener("contextmenu", this, false);
83710:         rootElement.dispatchEvent(event);
83710:       }
83710:     },
83710: 
83710:     _show: function(aEvent) {
86519:       if (aEvent.defaultPrevented)
83710:         return;
83710: 
83710:       let popupNode = aEvent.originalTarget;
83710:       let title = "";
83710:       if ((popupNode instanceof Ci.nsIDOMHTMLAnchorElement && popupNode.href) ||
83710:               (popupNode instanceof Ci.nsIDOMHTMLAreaElement && popupNode.href)) {
83710:         title = this._getLinkURL(popupNode);
83710:       } else if (popupNode instanceof Ci.nsIImageLoadingContent && popupNode.currentURI) {
83710:         title = popupNode.currentURI.spec;
83710:       } else if (popupNode instanceof Ci.nsIDOMHTMLMediaElement) {
83720:         title = (popupNode.currentSrc || popupNode.src);
83710:       }
83710: 
83710:       // convert this.menuitems object to an array for sending to native code
83710:       let itemArray = [];
83710:       for each (let item in this.menuitems) {
83710:         itemArray.push(item.getValue());
83710:       }
83710: 
83710:       let msg = {
83710:         gecko: {
83710:           type: "Prompt:Show",
83710:           title: title,
83710:           listitems: itemArray
83710:         }
83710:       };
83710:       let data = JSON.parse(sendMessageToJava(msg));
83710:       let selectedId = itemArray[data.button].id;
83710:       let selectedItem = this.menuitems[selectedId];
83710: 
83710:       if (selectedItem && selectedItem.callback) {
83710:         while (popupNode) {
83710:           if (selectedItem.matches(popupNode)) {
83710:             selectedItem.callback.call(selectedItem, popupNode);
83710:             break;
83710:           }
83710:           popupNode = popupNode.parentNode;
83710:         }
83710:       }
83710:       this.menuitems = null;
83710:     },
83710: 
83710:     handleEvent: function(aEvent) {
83710:       aEvent.target.ownerDocument.defaultView.removeEventListener("contextmenu", this, false);
83710:       this._show(aEvent);
83710:     },
83710: 
83710:     observe: function(aSubject, aTopic, aData) {
83992:       BrowserEventHandler._cancelTapHighlight();
83710:       let data = JSON.parse(aData);
83710:       // content gets first crack at cancelling context menus
83710:       this._sendToContent(data.x, data.y);
83710:     },
83710: 
83710:     // XXX - These are stolen from Util.js, we should remove them if we bring it back
83710:     makeURLAbsolute: function makeURLAbsolute(base, url) {
83710:       // Note:  makeURI() will throw if url is not a valid URI
83710:       return this.makeURI(url, null, this.makeURI(base)).spec;
83710:     },
83710: 
83710:     makeURI: function makeURI(aURL, aOriginCharset, aBaseURI) {
83710:       return Services.io.newURI(aURL, aOriginCharset, aBaseURI);
83710:     },
83710: 
83710:     _getLinkURL: function ch_getLinkURL(aLink) {
83710:       let href = aLink.href;
83710:       if (href)
83710:         return href;
83710: 
83710:       href = aLink.getAttributeNS(kXLinkNamespace, "href");
83710:       if (!href || !href.match(/\S/)) {
83710:         // Without this we try to save as the current doc,
83710:         // for example, HTML case also throws if empty
83710:         throw "Empty href";
83710:       }
83710: 
86782:       return this.makeURLAbsolute(aLink.baseURI, href);
83710:     }
83603:   }
83603: };
83603: 
80300: 
83503: function nsBrowserAccess() {
80024: }
80300: 
83485: nsBrowserAccess.prototype = {
85032:   QueryInterface: XPCOMUtils.generateQI([Ci.nsIBrowserDOMWindow]),
85032: 
85032:   _getBrowser: function _getBrowser(aURI, aOpener, aWhere, aContext) {
85032:     let isExternal = (aContext == Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
85032:     if (isExternal && aURI && aURI.schemeIs("chrome"))
85032:       return null;
85032: 
85032:     let loadflags = isExternal ?
85032:                       Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL :
85032:                       Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
85032:     if (aWhere == Ci.nsIBrowserDOMWindow.OPEN_DEFAULTWINDOW) {
85032:       switch (aContext) {
85032:         case Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL:
85032:           aWhere = Services.prefs.getIntPref("browser.link.open_external");
85032:           break;
85032:         default: // OPEN_NEW or an illegal value
85032:           aWhere = Services.prefs.getIntPref("browser.link.open_newwindow");
85032:       }
85032:     }
85032: 
90144:     Services.io.offline = false;
90144: 
90144:     let referrer;
90144:     if (aOpener) {
90144:       try {
90144:         let location = aOpener.location;
90144:         referrer = Services.io.newURI(location, null, null);
90144:       } catch(e) { }
90144:     }
90144: 
85042:     let newTab = (aWhere == Ci.nsIBrowserDOMWindow.OPEN_NEWWINDOW || aWhere == Ci.nsIBrowserDOMWindow.OPEN_NEWTAB);
85042: 
90144:     if (newTab) {
85042:       let parentId = -1;
90144:       if (!isExternal) {
89906:         let parent = BrowserApp.getTabForBrowser(BrowserApp.getBrowserForWindow(aOpener.top));
85042:         if (parent)
85042:           parentId = parent.id;
85042:       }
85042: 
90144:       // BrowserApp.addTab calls loadURIWithFlags with the appropriate params
90144:       let tab = BrowserApp.addTab(aURI ? aURI.spec : "about:blank", { flags: loadflags,
90144:                                                                       referrerURI: referrer,
90144:                                                                       external: isExternal,
90144:                                                                       parentId: parentId,
90144:                                                                       selected: true });
90144:       return tab.browser;
90144:     }
90144: 
90144:     // OPEN_CURRENTWINDOW and illegal values
90144:     let browser = BrowserApp.selectedBrowser;
90144:     if (aURI && browser)
85032:       browser.loadURIWithFlags(aURI.spec, loadflags, referrer, null, null);
85032: 
85032:     return browser;
85032:   },
85032: 
84851:   openURI: function browser_openURI(aURI, aOpener, aWhere, aContext) {
85032:     let browser = this._getBrowser(aURI, aOpener, aWhere, aContext);
86407:     return browser ? browser.contentWindow : null;
84812:   },
84812: 
83485:   openURIInFrame: function browser_openURIInFrame(aURI, aOpener, aWhere, aContext) {
85032:     let browser = this._getBrowser(aURI, aOpener, aWhere, aContext);
85032:     return browser ? browser.QueryInterface(Ci.nsIFrameLoaderOwner) : null;
80300:   },
80300: 
83485:   isTabContentWindow: function(aWindow) {
83514:     return BrowserApp.getBrowserForWindow(aWindow) != null;
85032:   }
83485: };
83485: 
83543: 
83543: let gTabIDFactory = 0;
83543: 
83965: // track the last known screen size so that new tabs
83965: // get created with the right size rather than being 1x1
83965: let gScreenWidth = 1;
83965: let gScreenHeight = 1;
83965: 
83762: function Tab(aURL, aParams) {
83514:   this.browser = null;
83934:   this.vbox = null;
83543:   this.id = 0;
87744:   this.showProgress = true;
83762:   this.create(aURL, aParams);
83965:   this._viewport = { x: 0, y: 0, width: gScreenWidth, height: gScreenHeight, offsetX: 0, offsetY: 0,
85034:                      pageWidth: gScreenWidth, pageHeight: gScreenHeight, zoom: 1.0 };
83935:   this.viewportExcess = { x: 0, y: 0 };
86799:   this.documentIdForCurrentViewport = null;
84041:   this.userScrollPos = { x: 0, y: 0 };
89412:   this._pluginCount = 0;
84386:   this._pluginOverlayShowing = false;
80300: }
80300: 
83514: Tab.prototype = {
83762:   create: function(aURL, aParams) {
83514:     if (this.browser)
83514:       return;
80300: 
88628:     aParams = aParams || {};
84937: 
83934:     this.vbox = document.createElement("vbox");
83934:     this.vbox.align = "start";
83934:     BrowserApp.deck.appendChild(this.vbox);
83934: 
83514:     this.browser = document.createElement("browser");
89157:     this.browser.setAttribute("type", "content-targetable");
83966:     this.setBrowserSize(980, 480);
92831:     this.browser.style.width = gScreenWidth + "px";
92831:     this.browser.style.height = gScreenHeight + "px";
83934:     this.vbox.appendChild(this.browser);
83820: 
84937:     this.browser.stop();
84937: 
92831:     let frameLoader = this.browser.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader;
92831:     if (kUsingGLLayers) {
92831:         frameLoader.renderMode = Ci.nsIFrameLoader.RENDER_MODE_ASYNC_SCROLL;
92911:         frameLoader.clampScrollPosition = false;
92831:     } else {
83934:         // Turn off clipping so we can buffer areas outside of the browser element.
83820:         frameLoader.clipSubdocument = false;
92831:     }
83820: 
83543:     this.id = ++gTabIDFactory;
84937: 
83541:     let message = {
83541:       gecko: {
83584:         type: "Tab:Added",
83543:         tabID: this.id,
83762:         uri: aURL,
85042:         parentId: ("parentId" in aParams) ? aParams.parentId : -1,
85042:         external: ("external" in aParams) ? aParams.external : false,
85984:         selected: ("selected" in aParams) ? aParams.selected : true,
89154:         title: aParams.title || "",
89154:         delayLoad: aParams.delayLoad || false
83541:       }
83541:     };
83703:     sendMessageToJava(message);
83541: 
83703:     let flags = Ci.nsIWebProgress.NOTIFY_STATE_ALL |
83712:                 Ci.nsIWebProgress.NOTIFY_LOCATION |
83712:                 Ci.nsIWebProgress.NOTIFY_SECURITY;
83703:     this.browser.addProgressListener(this, flags);
83703:     this.browser.sessionHistory.addSHistoryListener(this);
84791: 
84042:     this.browser.addEventListener("DOMContentLoaded", this, true);
84042:     this.browser.addEventListener("DOMLinkAdded", this, true);
84042:     this.browser.addEventListener("DOMTitleChanged", this, true);
86406:     this.browser.addEventListener("DOMWindowClose", this, true);
84041:     this.browser.addEventListener("scroll", this, true);
84386:     this.browser.addEventListener("PluginClickToPlay", this, true);
84386:     this.browser.addEventListener("pagehide", this, true);
86799:     this.browser.addEventListener("pageshow", this, true);
84791: 
86799:     Services.obs.addObserver(this, "document-shown", false);
84791: 
85984:     if (!aParams.delayLoad) {
84791:       let flags = "flags" in aParams ? aParams.flags : Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
84791:       let postData = ("postData" in aParams && aParams.postData) ? aParams.postData.value : null;
84791:       let referrerURI = "referrerURI" in aParams ? aParams.referrerURI : null;
84791:       let charset = "charset" in aParams ? aParams.charset : null;
84791: 
87744:       // This determines whether or not we show the progress throbber in the urlbar
87744:       this.showProgress = "showProgress" in aParams ? aParams.showProgress : true;
87744: 
84791:       try {
84791:         this.browser.loadURIWithFlags(aURL, flags, referrerURI, charset, postData);
84791:       } catch(e) {
84791:         let message = {
84791:           gecko: {
84791:             type: "Content:LoadError",
84791:             tabID: this.id,
84791:             uri: this.browser.currentURI.spec,
84791:             title: this.browser.contentTitle
84791:           }
84791:         };
84791:         sendMessageToJava(message);
84791:         dump("Handled load error: " + e)
84791:       }
85984:     }
80300:   },
80300: 
83514:   destroy: function() {
83514:     if (!this.browser)
80300:       return;
80300: 
83514:     this.browser.removeProgressListener(this);
84042:     this.browser.removeEventListener("DOMContentLoaded", this, true);
84042:     this.browser.removeEventListener("DOMLinkAdded", this, true);
84042:     this.browser.removeEventListener("DOMTitleChanged", this, true);
86406:     this.browser.removeEventListener("DOMWindowClose", this, true);
84041:     this.browser.removeEventListener("scroll", this, true);
84386:     this.browser.removeEventListener("PluginClickToPlay", this, true);
84386:     this.browser.removeEventListener("pagehide", this, true);
86799:     this.browser.removeEventListener("pageshow", this, true);
85989: 
89269:     Services.obs.removeObserver(this, "document-shown");
89269: 
85989:     // Make sure the previously selected panel remains selected. The selected panel of a deck is
85989:     // not stable when panels are removed.
85989:     let selectedPanel = BrowserApp.deck.selectedPanel;
83934:     BrowserApp.deck.removeChild(this.vbox);
85989:     BrowserApp.deck.selectedPanel = selectedPanel;
85989: 
83514:     this.browser = null;
83934:     this.vbox = null;
86799:     this.documentIdForCurrentViewport = null;
80300:   },
80300: 
89157:   // This should be called to update the browser when the tab gets selected/unselected
89157:   setActive: function setActive(aActive) {
83514:     if (!this.browser)
80300:       return;
80300: 
80300:     if (aActive) {
83514:       this.browser.setAttribute("type", "content-primary");
83571:       this.browser.focus();
89157:       this.browser.docShellIsActive = true;
80300:     } else {
89157:       this.browser.setAttribute("type", "content-targetable");
89157:       this.browser.docShellIsActive = false;
89157:     }
80300:   },
80300: 
83934:   set viewport(aViewport) {
83935:     // Transform coordinates based on zoom
83935:     aViewport.x /= aViewport.zoom;
83935:     aViewport.y /= aViewport.zoom;
83934: 
83934:     // Set scroll position
84041:     let win = this.browser.contentWindow;
84041:     win.scrollTo(aViewport.x, aViewport.y);
84041:     this.userScrollPos.x = win.scrollX;
84041:     this.userScrollPos.y = win.scrollY;
83934: 
83966:     this._viewport.width = gScreenWidth = aViewport.width;
83966:     this._viewport.height = gScreenHeight = aViewport.height;
92815:     dump("### gScreenWidth = " + gScreenWidth + "\n");
88628: 
92877:     let zoom = aViewport.zoom;
92877:     let cwu = window.top.QueryInterface(Ci.nsIInterfaceRequestor)
92877:                          .getInterface(Ci.nsIDOMWindowUtils);
83934: 
92911:     if (aViewport.offsetX != this._viewport.offsetX) {
83934:       this._viewport.offsetX = aViewport.offsetX;
92911:     }
92911:     if (aViewport.offsetY != this._viewport.offsetY) {
83934:       this._viewport.offsetY = aViewport.offsetY;
88628:     }
92877:     if (Math.abs(zoom - this._viewport.zoom) >= 1e-6) {
92877:       this._viewport.zoom = zoom;
92877:       cwu.setResolution(zoom, zoom);
92877:     }
92877: 
92877:     cwu.setDisplayPortForElement(-kBufferAmount / zoom, -kBufferAmount / zoom,
92877:                                  (gScreenWidth + kBufferAmount * 2) / zoom,
92877:                                  (gScreenHeight + kBufferAmount * 2) / zoom,
92877:                                  this.browser.contentDocument.documentElement);
86386:   },
86386: 
88306:   screenshot: function(aSrc, aDst) {
92804:       // FIXME: Reenable
92804:       //if (!this.browser || !this.browser.contentWindow)
87329:         return;
88420: 
89901:       getBridge().takeScreenshot(this.browser.contentWindow, 0, 0, aSrc.width, aSrc.height, aDst.width, aDst.height, this.id);
88257:       Services.tm.mainThread.dispatch(function() {
88257: 	  BrowserApp.doNextScreenshot()
88257:       }, Ci.nsIThread.DISPATCH_NORMAL);
87329:   },
87329: 
83934:   get viewport() {
83934:     // Update the viewport to current dimensions
84499:     this._viewport.x = (this.browser.contentWindow.scrollX +
84499:                         this.viewportExcess.x) || 0;
84499:     this._viewport.y = (this.browser.contentWindow.scrollY +
84499:                         this.viewportExcess.y) || 0;
83934: 
84352:     // Transform coordinates based on zoom
84352:     this._viewport.x = Math.round(this._viewport.x * this._viewport.zoom);
84352:     this._viewport.y = Math.round(this._viewport.y * this._viewport.zoom);
84352: 
83958:     let doc = this.browser.contentDocument;
86230:     if (doc != null) {
84352:       let pageWidth = this._viewport.width, pageHeight = this._viewport.height;
88307:       if (doc instanceof SVGDocument) {
88307:         let rect = doc.rootElement.getBoundingClientRect();
88307:         // we need to add rect.left and rect.top twice so that the SVG is drawn
88307:         // centered on the page; if we add it only once then the SVG will be
88307:         // on the bottom-right of the page and if we don't add it at all then
88307:         // we end up with a cropped SVG (see bug 712065)
88307:         pageWidth = Math.ceil(rect.left + rect.width + rect.left);
88307:         pageHeight = Math.ceil(rect.top + rect.height + rect.top);
88307:       } else {
83990:         let body = doc.body || { scrollWidth: pageWidth, scrollHeight: pageHeight };
83990:         let html = doc.documentElement || { scrollWidth: pageWidth, scrollHeight: pageHeight };
83990:         pageWidth = Math.max(body.scrollWidth, html.scrollWidth);
83990:         pageHeight = Math.max(body.scrollHeight, html.scrollHeight);
88307:       }
84352: 
84352:       /* Transform the page width and height based on the zoom factor. */
87229:       pageWidth *= this._viewport.zoom;
87229:       pageHeight *= this._viewport.zoom;
86230: 
86230:       /*
86230:        * Avoid sending page sizes of less than screen size before we hit DOMContentLoaded, because
86230:        * this causes the page size to jump around wildly during page load. After the page is loaded,
86230:        * send updates regardless of page size; we'll zoom to fit the content as needed.
86230:        */
86230:       if (doc.readyState === 'complete' || (pageWidth >= gScreenWidth && pageHeight >= gScreenHeight)) {
86230:         this._viewport.pageWidth = pageWidth;
86230:         this._viewport.pageHeight = pageHeight;
86230:       }
84352:     }
83935: 
83934:     return this._viewport;
83934:   },
83934: 
87876:   updateViewport: function(aReset, aZoomLevel) {
92815:     dump("### JS side updateViewport " + aReset + " zoom " + aZoomLevel + "\n");
92815: 
87876:     if (!aZoomLevel)
87876:       aZoomLevel = this.getDefaultZoomLevel();
87876: 
83964:     let win = this.browser.contentWindow;
87876:     let zoom = (aReset ? aZoomLevel : this._viewport.zoom);
84499:     let xpos = ((aReset && win) ? win.scrollX * zoom : this._viewport.x);
84499:     let ypos = ((aReset && win) ? win.scrollY * zoom : this._viewport.y);
84215: 
83964:     this.viewportExcess = { x: 0, y: 0 };
83964:     this.viewport = { x: xpos, y: ypos,
83964:                       offsetX: 0, offsetY: 0,
83964:                       width: this._viewport.width, height: this._viewport.height,
85034:                       pageWidth: gScreenWidth, pageHeight: gScreenHeight,
83964:                       zoom: zoom };
84003:     this.sendViewportUpdate();
84003:   },
84003: 
84003:   sendViewportUpdate: function() {
84436:     if (BrowserApp.selectedTab != this)
84436:       return;
83964:     sendMessageToJava({
83964:       gecko: {
86565:         type: "Viewport:UpdateAndDraw"
83964:       }
83964:     });
83964:   },
83964: 
84041:   handleEvent: function(aEvent) {
84041:     switch (aEvent.type) {
84042:       case "DOMContentLoaded": {
84042:         let target = aEvent.originalTarget;
84042: 
84042:         // ignore on frames
84042:         if (target.defaultView != this.browser.contentWindow)
84042:           return;
84042: 
84042:         sendMessageToJava({
84042:           gecko: {
84042:             type: "DOMContentLoaded",
84042:             tabID: this.id,
84042:             windowID: 0,
84042:             uri: this.browser.currentURI.spec,
84042:             title: this.browser.contentTitle
84042:           }
84042:         });
84042: 
84042:         // Attach a listener to watch for "click" events bubbling up from error
84042:         // pages and other similar page. This lets us fix bugs like 401575 which
84042:         // require error page UI to do privileged things, without letting error
84042:         // pages have any privilege themselves.
84042:         if (/^about:/.test(target.documentURI)) {
84042:           this.browser.addEventListener("click", ErrorPageEventHandler, false);
84042:           this.browser.addEventListener("pagehide", function listener() {
84042:             this.browser.removeEventListener("click", ErrorPageEventHandler, false);
84042:             this.browser.removeEventListener("pagehide", listener, true);
84261:           }.bind(this), true);
84042:         }
84042: 
89412:         // Show a plugin doorhanger if there are plugins on the page but no
89412:         // clickable overlays showing (this doesn't work on pages loaded after
89412:         // back/forward navigation - see bug 719875)
89412:         if (this._pluginCount && !this._pluginOverlayShowing)
84386:           PluginHelper.showDoorHanger(this);
84386: 
84042:         break;
84042:       }
84042: 
84042:       case "DOMLinkAdded": {
84042:         let target = aEvent.originalTarget;
84042:         if (!target.href || target.disabled)
84042:           return;
84042: 
84042:         // ignore on frames
84261:         if (target.ownerDocument.defaultView != this.browser.contentWindow)
84042:           return;
84042: 
84262:         // sanitize the rel string
84262:         let list = [];
84262:         if (target.rel) {
84262:           list = target.rel.toLowerCase().split(/\s+/);
84262:           let hash = {};
84262:           list.forEach(function(value) { hash[value] = true; });
84262:           list = [];
84262:           for (let rel in hash)
84262:             list.push("[" + rel + "]");
84262:         }
84262: 
84042:         let json = {
84042:           type: "DOMLinkAdded",
84042:           tabID: this.id,
84042:           href: resolveGeckoURI(target.href),
84042:           charset: target.ownerDocument.characterSet,
84042:           title: target.title,
84262:           rel: list.join(" ")
84042:         };
84042: 
84042:         // rel=icon can also have a sizes attribute
84042:         if (target.hasAttribute("sizes"))
84042:           json.sizes = target.getAttribute("sizes");
84042: 
84042:         sendMessageToJava({ gecko: json });
84042:         break;
84042:       }
84042: 
84042:       case "DOMTitleChanged": {
84042:         if (!aEvent.isTrusted)
84042:           return;
84042: 
84042:         // ignore on frames
84042:         if (aEvent.target.defaultView != this.browser.contentWindow)
84042:           return;
84042: 
84042:         sendMessageToJava({
84042:           gecko: {
84042:             type: "DOMTitleChanged",
84042:             tabID: this.id,
89294:             title: aEvent.target.title.substring(0, 255)
84042:           }
84042:         });
84042:         break;
84042:       }
84042: 
86406:       case "DOMWindowClose": {
86406:         if (!aEvent.isTrusted)
86406:           return;
86406: 
86406:         // Find the relevant tab, and close it from Java
86406:         if (this.browser.contentWindow == aEvent.target) {
86406:           aEvent.preventDefault();
86406: 
86406:           sendMessageToJava({
86406:             gecko: {
86406:               type: "DOMWindowClose",
86406:               tabID: this.id
86406:             }
86406:           });
86406:         }
86406:         break;
86406:       }
86406: 
84041:       case "scroll": {
84041:         let win = this.browser.contentWindow;
84041:         if (this.userScrollPos.x != win.scrollX || this.userScrollPos.y != win.scrollY) {
84041:           sendMessageToJava({
84041:             gecko: {
84041:               type: "Viewport:UpdateLater"
84041:             }
84041:           });
84041:         }
84041:         break;
84041:       }
84386: 
84386:       case "PluginClickToPlay": {
89412:         // Keep track of the number of plugins to know whether or not to show
89412:         // the hidden plugins doorhanger
89412:         this._pluginCount++;
89412: 
84386:         let plugin = aEvent.target;
84386:         let overlay = plugin.ownerDocument.getAnonymousElementByAttribute(plugin, "class", "mainBox");
84386:         if (!overlay)
84386:           return;
84386: 
84386:         // If the overlay is too small, hide the overlay and act like this
84386:         // is a hidden plugin object
84386:         if (PluginHelper.isTooSmall(plugin, overlay)) {
84386:           overlay.style.visibility = "hidden";
84386:           return;
84386:         }
84386: 
89412:         // Add click to play listener to the overlay
89412:         overlay.addEventListener("click", (function(event) {
84386:           // Play all the plugin objects when the user clicks on one
86786:           PluginHelper.playAllPlugins(this, event);
86786:         }).bind(this), true);
86786: 
84386:         this._pluginOverlayShowing = true;
84386:         break;
84386:       }
84386: 
84386:       case "pagehide": {
85968:         // Check to make sure it's top-level pagehide
85968:         if (aEvent.target.defaultView == this.browser.contentWindow) {
84386:           // Reset plugin state when we leave the page
89412:           this._pluginCount = 0;
84386:           this._pluginOverlayShowing = false;
85968:         }
84386:         break;
84386:       }
84041:     }
84041:   },
84041: 
83485:   onStateChange: function(aWebProgress, aRequest, aStateFlags, aStatus) {
89721:     let contentWin = aWebProgress.DOMWindow;
89721:     if (contentWin != contentWin.top)
89721:         return;
89721: 
86026:     if (aStateFlags & Ci.nsIWebProgressListener.STATE_IS_NETWORK) {
86026:       // Filter optimization: Only really send NETWORK state changes to Java listener
83541:       let browser = BrowserApp.getBrowserForWindow(aWebProgress.DOMWindow);
83541:       let uri = "";
83541:       if (browser)
83541:         uri = browser.currentURI.spec;
83541: 
89721:       // Check to see if we restoring the content from a previous presentation (session)
89721:       // since there should be no real network activity
89721:       let restoring = aStateFlags & Ci.nsIWebProgressListener.STATE_RESTORING;
89721:       let showProgress = restoring ? false : this.showProgress;
89721: 
83485:       let message = {
83503:         gecko: {
83712:           type: "Content:StateChange",
83543:           tabID: this.id,
83541:           uri: uri,
87744:           state: aStateFlags,
89721:           showProgress: showProgress
80300:         }
80300:       };
83515:       sendMessageToJava(message);
87744: 
87744:       // Reset showProgress after state change
87744:       this.showProgress = true;
83589:     }
80024:   },
80300: 
83964:   onLocationChange: function(aWebProgress, aRequest, aLocationURI, aFlags) {
83616:     let contentWin = aWebProgress.DOMWindow;
83616:     if (contentWin != contentWin.top)
83616:         return;
83616: 
83616:     let browser = BrowserApp.getBrowserForWindow(contentWin);
83485:     let uri = browser.currentURI.spec;
84580:     let documentURI = "";
84580:     let contentType = "";
84580:     if (browser.contentDocument) {
84580:       documentURI = browser.contentDocument.documentURIObject.spec;
84580:       contentType = browser.contentDocument.contentType;
84580:     }
80024: 
83485:     let message = {
83503:       gecko: {
83712:         type: "Content:LocationChange",
83543:         tabID: this.id,
84523:         uri: uri,
84523:         documentURI: documentURI,
84523:         contentType: contentType
80300:       }
80300:     };
80300: 
83515:     sendMessageToJava(message);
83964: 
83964:     if ((aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT) == 0) {
84003:       this.updateViewport(true);
84003:     } else {
84003:       this.sendViewportUpdate();
83964:     }
80300:   },
80300: 
83712:   onSecurityChange: function(aWebProgress, aRequest, aState) {
83712:     let mode = "unknown";
83712:     if (aState & Ci.nsIWebProgressListener.STATE_IDENTITY_EV_TOPLEVEL)
83712:       mode = "identified";
83712:     else if (aState & Ci.nsIWebProgressListener.STATE_SECURE_HIGH)
83712:       mode = "verified";
83712:     else if (aState & Ci.nsIWebProgressListener.STATE_IS_BROKEN)
83712:       mode = "mixed";
83712:     else
83712:       mode = "unknown";
83712: 
83712:     let message = {
83712:       gecko: {
83712:         type: "Content:SecurityChange",
83712:         tabID: this.id,
83712:         mode: mode
83712:       }
83712:     };
83712: 
83712:      sendMessageToJava(message);
80300:   },
80300: 
83485:   onProgressChange: function(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress) {
83485:   },
83589: 
83503:   onStatusChange: function(aBrowser, aWebProgress, aRequest, aStatus, aMessage) {
83503:   },
83485: 
83674:   _sendHistoryEvent: function(aMessage, aIndex, aUri) {
83674:     let message = {
83674:       gecko: {
83674:         type: "SessionHistory:" + aMessage,
83674:         tabID: this.id,
83674:       }
83674:     };
83674:     if (aIndex != -1) {
83674:       message.gecko.index = aIndex;
83674:     }
83674:     if (aUri != null) {
83674:       message.gecko.uri = aUri;
83674:     }
83674:     sendMessageToJava(message);
83674:   },
83674: 
83674:   OnHistoryNewEntry: function(aUri) {
83674:     this._sendHistoryEvent("New", -1, aUri.spec);
83674:   },
83674: 
83674:   OnHistoryGoBack: function(aUri) {
83674:     this._sendHistoryEvent("Back", -1, null);
83674:     return true;
83674:   },
83674: 
83674:   OnHistoryGoForward: function(aUri) {
83674:     this._sendHistoryEvent("Forward", -1, null);
83674:     return true;
83674:   },
83674: 
83674:   OnHistoryReload: function(aUri, aFlags) {
83674:     // we don't do anything with this, so don't propagate it
83674:     // for now anyway
83674:     return true;
83674:   },
83674: 
83674:   OnHistoryGotoIndex: function(aIndex, aUri) {
83674:     this._sendHistoryEvent("Goto", aIndex, null);
83674:     return true;
83674:   },
83674: 
83674:   OnHistoryPurge: function(aNumEntries) {
83674:     this._sendHistoryEvent("Purge", -1, null);
83674:     return true;
83674:   },
83674: 
83966:   get metadata() {
86798:     return ViewportHandler.getMetadataForDocument(this.browser.contentDocument);
83966:   },
83966: 
83966:   /** Update viewport when the metadata changes. */
83966:   updateViewportMetadata: function updateViewportMetadata(aMetadata) {
83966:     if (aMetadata && aMetadata.autoScale) {
83966:       let scaleRatio = aMetadata.scaleRatio = ViewportHandler.getScaleRatio();
83966: 
83966:       if ("defaultZoom" in aMetadata && aMetadata.defaultZoom > 0)
83966:         aMetadata.defaultZoom *= scaleRatio;
83966:       if ("minZoom" in aMetadata && aMetadata.minZoom > 0)
83966:         aMetadata.minZoom *= scaleRatio;
83966:       if ("maxZoom" in aMetadata && aMetadata.maxZoom > 0)
83966:         aMetadata.maxZoom *= scaleRatio;
83966:     }
86798:     ViewportHandler.setMetadataForDocument(this.browser.contentDocument, aMetadata);
83966:     this.updateViewportSize();
83966:   },
83966: 
83966:   /** Update viewport when the metadata or the window size changes. */
83966:   updateViewportSize: function updateViewportSize() {
83966:     let browser = this.browser;
83966:     if (!browser)
83966:       return;
83966: 
84025:     let screenW = this._viewport.width;
84025:     let screenH = this._viewport.height;
83966:     let viewportW, viewportH;
83966: 
83966:     let metadata = this.metadata;
83966:     if (metadata.autoSize) {
83966:       if ("scaleRatio" in metadata) {
83966:         viewportW = screenW / metadata.scaleRatio;
83966:         viewportH = screenH / metadata.scaleRatio;
83966:       } else {
83966:         viewportW = screenW;
83966:         viewportH = screenH;
83966:       }
83966:     } else {
83966:       viewportW = metadata.width;
83966:       viewportH = metadata.height;
83966: 
83966:       // If (scale * width) < device-width, increase the width (bug 561413).
83966:       let maxInitialZoom = metadata.defaultZoom || metadata.maxZoom;
83966:       if (maxInitialZoom && viewportW)
83966:         viewportW = Math.max(viewportW, screenW / maxInitialZoom);
83966: 
83966:       let validW = viewportW > 0;
83966:       let validH = viewportH > 0;
83966: 
83966:       if (!validW)
83966:         viewportW = validH ? (viewportH * (screenW / screenH)) : BrowserApp.defaultBrowserWidth;
83966:       if (!validH)
83966:         viewportH = viewportW * (screenH / screenW);
83966:     }
83966: 
83966:     // Make sure the viewport height is not shorter than the window when
83966:     // the page is zoomed out to show its full width.
83966:     let minScale = this.getPageZoomLevel(screenW);
83966:     viewportH = Math.max(viewportH, screenH / minScale);
83966: 
92905:     let oldBrowserWidth = this.browserWidth;
83966:     this.setBrowserSize(viewportW, viewportH);
87876: 
87876:     // Avoid having the scroll position jump around after device rotation.
87876:     let win = this.browser.contentWindow;
87876:     this.userScrollPos.x = win.scrollX;
87876:     this.userScrollPos.y = win.scrollY;
87876: 
87876:     // If the browser width changes, we change the zoom proportionally. This ensures sensible
87876:     // behavior when rotating the device on pages with automatically-resizing viewports.
87876: 
92905:     if (viewportW == oldBrowserWidth)
87876:       return;
87876: 
87876:     let viewport = this.viewport;
87876:     let newZoom = oldBrowserWidth * viewport.zoom / viewportW;
87876:     this.updateViewport(true, newZoom);
83966:   },
83966: 
83967:   getDefaultZoomLevel: function getDefaultZoomLevel() {
83967:     let md = this.metadata;
83967:     if ("defaultZoom" in md && md.defaultZoom)
83967:       return md.defaultZoom;
83967: 
92815:     dump("### getDefaultZoomLevel gScreenWidth=" + gScreenWidth);
92905:     return gScreenWidth / this.browserWidth;
83967:   },
83967: 
83966:   getPageZoomLevel: function getPageZoomLevel() {
83994:     // This may get called during a Viewport:Change message while the document
83994:     // has not loaded yet.
83994:     if (!this.browser.contentDocument || !this.browser.contentDocument.body)
83972:       return 1.0;
83994: 
84025:     return this._viewport.width / this.browser.contentDocument.body.clientWidth;
83966:   },
83966: 
83966:   setBrowserSize: function(aWidth, aHeight) {
92905:     this.browserWidth = aWidth;
92905: 
92905:     if (!this.browser.contentWindow)
92905:       return;
92905:     let cwu = this.browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
92905:     cwu.setCSSViewport(aWidth, aHeight);
83966:   },
83966: 
83970:   getRequestLoadContext: function(aRequest) {
83970:     if (aRequest && aRequest.notificationCallbacks) {
83970:       try {
83970:         return aRequest.notificationCallbacks.getInterface(Ci.nsILoadContext);
83970:       } catch (ex) { }
83970:     }
83970: 
83970:     if (aRequest && aRequest.loadGroup && aRequest.loadGroup.notificationCallbacks) {
83970:       try {
83970:         return aRequest.loadGroup.notificationCallbacks.getInterface(Ci.nsILoadContext);
83970:       } catch (ex) { }
83970:     }
83970: 
83970:     return null;
83970:   },
83970: 
83970:   getWindowForRequest: function(aRequest) {
83970:     let loadContext = this.getRequestLoadContext(aRequest);
83970:     if (loadContext)
83970:       return loadContext.associatedWindow;
83970:     return null;
83970:   },
83970: 
83970:   observe: function(aSubject, aTopic, aData) {
86799:     switch (aTopic) {
86799:       case "document-shown":
86799:         // Is it on the top level?
86799:         let contentDocument = aSubject;
86799:         if (contentDocument == this.browser.contentDocument) {
86799:           ViewportHandler.updateMetadata(this);
86799:           this.documentIdForCurrentViewport = ViewportHandler.getIdForDocument(contentDocument);
86799:         }
86799:         break;
86799:     }
83970:   },
83970: 
83970:   QueryInterface: XPCOMUtils.generateQI([
83970:     Ci.nsIWebProgressListener,
83970:     Ci.nsISHistoryListener,
83970:     Ci.nsIObserver,
83970:     Ci.nsISupportsWeakReference
83970:   ])
80024: };
80024: 
83514: var BrowserEventHandler = {
83514:   init: function init() {
83992:     Services.obs.addObserver(this, "Gesture:SingleTap", false);
83992:     Services.obs.addObserver(this, "Gesture:ShowPress", false);
83992:     Services.obs.addObserver(this, "Gesture:CancelTouch", false);
84033:     Services.obs.addObserver(this, "Gesture:DoubleTap", false);
84037:     Services.obs.addObserver(this, "Gesture:Scroll", false);
88107:     Services.obs.addObserver(this, "dom-touch-listener-added", false);
83992: 
83714:     BrowserApp.deck.addEventListener("DOMUpdatePageReport", PopupBlockerObserver.onUpdatePageReport, false);
83514:   },
83514: 
83992:   observe: function(aSubject, aTopic, aData) {
84037:     if (aTopic == "Gesture:Scroll") {
84037:       // If we've lost our scrollable element, return. Don't cancel the
84037:       // override, as we probably don't want Java to handle panning until the
84037:       // user releases their finger.
84037:       if (this._scrollableElement == null)
84037:         return;
84037: 
84037:       // If this is the first scroll event and we can't scroll in the direction
84037:       // the user wanted, and neither can any non-root sub-frame, cancel the
84037:       // override so that Java can handle panning the main document.
84037:       let data = JSON.parse(aData);
84037:       if (this._firstScrollEvent) {
84302:         while (this._scrollableElement != null && !this._elementCanScroll(this._scrollableElement, data.x, data.y))
84037:           this._scrollableElement = this._findScrollableElement(this._scrollableElement, false);
84037: 
84037:         let doc = BrowserApp.selectedBrowser.contentDocument;
84302:         if (this._scrollableElement == doc.body || this._scrollableElement == doc.documentElement) {
84037:           sendMessageToJava({ gecko: { type: "Panning:CancelOverride" } });
84037:           return;
84037:         }
84037: 
84037:         this._firstScrollEvent = false;
84037:       }
84037: 
84037:       // Scroll the scrollable element
87882:       if (this._elementCanScroll(this._scrollableElement, data.x, data.y)) {
84037:         this._scrollElementBy(this._scrollableElement, data.x, data.y);
87882:         sendMessageToJava({ gecko: { type: "Gesture:ScrollAck", scrolled: true } });
87882:       } else {
87882:         sendMessageToJava({ gecko: { type: "Gesture:ScrollAck", scrolled: false } });
87882:       }
84037:     } else if (aTopic == "Gesture:CancelTouch") {
83992:       this._cancelTapHighlight();
83992:     } else if (aTopic == "Gesture:ShowPress") {
83992:       let data = JSON.parse(aData);
84302:       let closest = ElementTouchHelper.elementFromPoint(BrowserApp.selectedBrowser.contentWindow, data.x, data.y);
83992:       if (!closest)
84302:         closest = ElementTouchHelper.anyElementFromPoint(BrowserApp.selectedBrowser.contentWindow, data.x, data.y);
84037:       if (closest) {
83992:         this._doTapHighlight(closest);
84037: 
84037:         // If we've pressed a scrollable element, let Java know that we may
84037:         // want to override the scroll behaviour (for document sub-frames)
84037:         this._scrollableElement = this._findScrollableElement(closest, true);
84037:         this._firstScrollEvent = true;
84037: 
84037:         if (this._scrollableElement != null) {
84037:           // Discard if it's the top-level scrollable, we let Java handle this
84037:           let doc = BrowserApp.selectedBrowser.contentDocument;
84302:           if (this._scrollableElement != doc.body && this._scrollableElement != doc.documentElement)
84037:             sendMessageToJava({ gecko: { type: "Panning:Override" } });
84037:         }
84037:       }
83992:     } else if (aTopic == "Gesture:SingleTap") {
83992:       let element = this._highlightElement;
83992:       if (element && !FormAssistant.handleClick(element)) {
87259:         try {
83992:           let data = JSON.parse(aData);
83992:           [data.x, data.y] = ElementTouchHelper.toScreenCoords(element.ownerDocument.defaultView, data.x, data.y);
83992:   
83992:           this._sendMouseEvent("mousemove", element, data.x, data.y);
83992:           this._sendMouseEvent("mousedown", element, data.x, data.y);
83992:           this._sendMouseEvent("mouseup",   element, data.x, data.y);
84414:   
84414:           if (ElementTouchHelper.isElementClickable(element))
84414:             Haptic.performSimpleAction(Haptic.LongPress);
87259:         } catch(e) {
87259:           Cu.reportError(e);
87259:         }
83992:       }
83992:       this._cancelTapHighlight();
84033:     } else if (aTopic == "Gesture:DoubleTap") {
84033:       this._cancelTapHighlight();
84033:       this.onDoubleTap(aData);
88107:     } else if (aTopic == "dom-touch-listener-added") {
88107:       let browser = BrowserApp.getBrowserForWindow(aSubject);
88107:       if (!browser)
88107:         return;
88107: 
88107:       let tab = BrowserApp.getTabForBrowser(browser);
88107:       if (!tab)
88107:         return;
88107: 
88107:       sendMessageToJava({
88107:         gecko: {
88107:           type: "Tab:HasTouchListener",
88107:           tabID: tab.id
88107:         }
88107:       });
84033:     }
84033:   },
84033:  
84033:   _zoomOut: function() {
84033:     this._zoomedToElement = null;
84033:     // zoom out, try to keep the center in the center of the page
84033:     setTimeout(function() {
84033:       sendMessageToJava({ gecko: { type: "Browser:ZoomToPageWidth"} });
84033:     }, 0);    
84033:   },
84033: 
84033:   onDoubleTap: function(aData) {
84033:     let data = JSON.parse(aData);
84033: 
84033:     let rect = {};
84033:     let win = BrowserApp.selectedBrowser.contentWindow;
84033:     
84033:     let zoom = BrowserApp.selectedTab._viewport.zoom;
84033:     let element = ElementTouchHelper.anyElementFromPoint(win, data.x, data.y);
84033:     if (!element) {
84033:       this._zoomOut();
84033:       return;
84033:     }
84033: 
84033:     win = element.ownerDocument.defaultView;
84033:     while (element && win.getComputedStyle(element,null).display == "inline")
84033:       element = element.parentNode;
84033:     if (!element || element == this._zoomedToElement) {
84033:       this._zoomOut();
84033:     } else if (element) {
84033:       const margin = 15;
84033:       this._zoomedToElement = element;
84033:       rect = ElementTouchHelper.getBoundingContentRect(element);
84033: 
84033:       let zoom = BrowserApp.selectedTab.viewport.zoom;
84033:       rect.x *= zoom;
84033:       rect.y *= zoom;
84033:       rect.w *= zoom;
84033:       rect.h *= zoom;
84033: 
84033:       setTimeout(function() {
84033:         rect.type = "Browser:ZoomToRect";
84033:         rect.x -= margin;
84033:         rect.w += 2*margin;
84033:         sendMessageToJava({ gecko: rect });
84033:       }, 0);
83992:     }
83992:   },
83992: 
84037:   _firstScrollEvent: false,
84037: 
84037:   _scrollableElement: null,
84037: 
84037:   _highlightElement: null,
83992: 
83992:   _doTapHighlight: function _doTapHighlight(aElement) {
83992:     DOMUtils.setContentState(aElement, kStateActive);
83992:     this._highlightElement = aElement;
83992:   },
83992: 
83992:   _cancelTapHighlight: function _cancelTapHighlight() {
83992:     DOMUtils.setContentState(BrowserApp.selectedBrowser.contentWindow.document.documentElement, kStateActive);
83992:     this._highlightElement = null;
83992:   },
83992: 
83546:   _updateLastPosition: function(x, y, dx, dy) {
83485:     this.lastX = x;
83485:     this.lastY = y;
83509:     this.lastTime = Date.now();
83509: 
83566:     this.motionBuffer.push({ dx: dx, dy: dy, time: this.lastTime });
65863:   },
65863: 
83669:   _sendMouseEvent: function _sendMouseEvent(aName, aElement, aX, aY, aButton) {
83669:     // the element can be out of the aX/aY point because of the touch radius
83669:     // if outside, we gracefully move the touch point to the center of the element
83669:     if (!(aElement instanceof HTMLHtmlElement)) {
83669:       let isTouchClick = true;
83669:       let rects = ElementTouchHelper.getContentClientRects(aElement);
83669:       for (let i = 0; i < rects.length; i++) {
83669:         let rect = rects[i];
83669:         // We might be able to deal with fractional pixels, but mouse events won't.
83669:         // Deflate the bounds in by 1 pixel to deal with any fractional scroll offset issues.
83669:         let inBounds =
83669:           (aX > rect.left + 1 && aX < (rect.left + rect.width - 1)) &&
83669:           (aY > rect.top + 1 && aY < (rect.top + rect.height - 1));
83669:         if (inBounds) {
83669:           isTouchClick = false;
83669:           break;
83669:         }
83669:       }
83669: 
83669:       if (isTouchClick) {
83669:         let rect = {x: rects[0].left, y: rects[0].top, w: rects[0].width, h: rects[0].height};
83669:         if (rect.w == 0 && rect.h == 0)
83669:           return;
83669: 
83669:         let point = { x: rect.x + rect.w/2, y: rect.y + rect.h/2 };
83669:         aX = point.x;
83669:         aY = point.y;
83669:       }
83669:     }
83669: 
87259:     let window = aElement.ownerDocument.defaultView;
87259:     try {
87259:       [aX, aY] = ElementTouchHelper.toBrowserCoords(window, aX, aY);
87259:       let cwu = window.top.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
83669:       aButton = aButton || 0;
83669:       cwu.sendMouseEventToWindow(aName, Math.round(aX), Math.round(aY), aButton, 1, 0, true);
87259:     } catch(e) {
87259:       Cu.reportError(e);
87259:     }
83669:   },
83669: 
86657:   _hasScrollableOverflow: function(elem) {
86657:     var win = elem.ownerDocument.defaultView;
86657:     if (!win)
86657:       return false;
86657:     var computedStyle = win.getComputedStyle(elem);
86657:     if (!computedStyle)
86657:       return false;
86657:     return computedStyle.overflow == 'auto' || computedStyle.overflow == 'scroll';
86657:   },
86657: 
83546:   _findScrollableElement: function(elem, checkElem) {
83546:     // Walk the DOM tree until we find a scrollable element
83546:     let scrollable = false;
83546:     while (elem) {
83546:       /* Element is scrollable if its scroll-size exceeds its client size, and:
83546:        * - It has overflow 'auto' or 'scroll'
83546:        * - It's a textarea
84037:        * - It's an HTML/BODY node
84377:        * - It's a select element showing multiple rows
64816:        */
83546:       if (checkElem) {
83546:         if (((elem.scrollHeight > elem.clientHeight) ||
83546:              (elem.scrollWidth > elem.clientWidth)) &&
86657:             (this._hasScrollableOverflow(elem) ||
84377:              elem.mozMatchesSelector("html, body, textarea")) ||
84377:             (elem instanceof HTMLSelectElement && (elem.size > 1 || elem.multiple))) {
83546:           scrollable = true;
83546:           break;
83546:         }
66922:       } else {
83546:         checkElem = true;
83546:       }
83546: 
83546:       // Propagate up iFrames
84302:       if (!elem.parentNode && elem.documentElement && elem.documentElement.ownerDocument)
83546:         elem = elem.documentElement.ownerDocument.defaultView.frameElement;
83546:       else
83546:         elem = elem.parentNode;
83546:     }
83546: 
83546:     if (!scrollable)
83546:       return null;
83546: 
83546:     return elem;
83546:   },
83546: 
83777:   _elementReceivesInput: function(aElement) {
83777:     return aElement instanceof Element &&
83921:         kElementsReceivingInput.hasOwnProperty(aElement.tagName.toLowerCase()) ||
83921:         this._isEditable(aElement);
83921:   },
83921: 
83921:   _isEditable: function(aElement) {
83921:     let canEdit = false;
83921: 
83921:     if (aElement.isContentEditable || aElement.designMode == "on") {
83921:       canEdit = true;
83921:     } else if (aElement instanceof HTMLIFrameElement && (aElement.contentDocument.body.isContentEditable || aElement.contentDocument.designMode == "on")) {
83921:       canEdit = true;
83921:     } else {
83921:       canEdit = aElement.ownerDocument && aElement.ownerDocument.designMode == "on";
83921:     }
83921: 
83921:     return canEdit;
83777:   },
83777: 
83546:   _scrollElementBy: function(elem, x, y) {
83546:     elem.scrollTop = elem.scrollTop + y;
83546:     elem.scrollLeft = elem.scrollLeft + x;
83546:   },
83546: 
83546:   _elementCanScroll: function(elem, x, y) {
83546:     let scrollX = true;
83546:     let scrollY = true;
83546: 
83546:     if (x < 0) {
83546:       if (elem.scrollLeft <= 0) {
83546:         scrollX = false;
83546:       }
83546:     } else if (elem.scrollLeft >= (elem.scrollWidth - elem.clientWidth)) {
83546:       scrollX = false;
83546:     }
83546: 
83546:     if (y < 0) {
83546:       if (elem.scrollTop <= 0) {
83546:         scrollY = false;
83546:       }
83546:     } else if (elem.scrollTop >= (elem.scrollHeight - elem.clientHeight)) {
83546:       scrollY = false;
83546:     }
83546: 
83546:     return scrollX || scrollY;
80024:   }
80024: };
83627: 
83669: const kReferenceDpi = 240; // standard "pixel" size used in some preferences
83669: 
83669: const ElementTouchHelper = {
83992:   toBrowserCoords: function(aWindow, aX, aY) {
87259:     if (!aWindow)
87259:       throw "Must provide a window";
87259:   
87259:     let browser = BrowserApp.getBrowserForWindow(aWindow.top);
87259:     if (!browser)
87259:       throw "Unable to find a browser";
87259: 
87259:     let tab = BrowserApp.getTabForBrowser(browser);
87259:     if (!tab)
87259:       throw "Unable to find a tab";
87259: 
83992:     let viewport = tab.viewport;
83992:     return [
83992:         ((aX - tab.viewportExcess.x) * viewport.zoom + viewport.offsetX),
83992:         ((aY - tab.viewportExcess.y) * viewport.zoom + viewport.offsetY)
83992:     ];
83992:   },
83992: 
83992:   toScreenCoords: function(aWindow, aX, aY) {
87259:     if (!aWindow)
87259:       throw "Must provide a window";
87259:   
87259:     let browser = BrowserApp.getBrowserForWindow(aWindow.top);
87259:     if (!browser)
87259:       throw "Unable to find a browser";
87259: 
87259:     let tab = BrowserApp.getTabForBrowser(browser);
87259:     if (!tab)
87259:       throw "Unable to find a tab";
87259: 
83992:     let viewport = tab.viewport;
83992:     return [
83992:         (aX - viewport.offsetX)/viewport.zoom + tab.viewportExcess.x,
83992:         (aY - viewport.offsetY)/viewport.zoom + tab.viewportExcess.y
83992:     ];
83992:   },
83992: 
83710:   anyElementFromPoint: function(aWindow, aX, aY) {
83992:     [aX, aY] = this.toScreenCoords(aWindow, aX, aY);
83710:     let cwu = aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
83710:     let elem = cwu.elementFromPoint(aX, aY, false, true);
83710: 
83710:     while (elem && (elem instanceof HTMLIFrameElement || elem instanceof HTMLFrameElement)) {
83710:       let rect = elem.getBoundingClientRect();
83710:       aX -= rect.left;
83710:       aY -= rect.top;
83710:       cwu = elem.contentDocument.defaultView.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
83710:       elem = cwu.elementFromPoint(aX, aY, false, true);
83710:     }
83710: 
83710:     return elem;
83710:   },
83710: 
83669:   elementFromPoint: function(aWindow, aX, aY) {
83992:     [aX, aY] = this.toScreenCoords(aWindow, aX, aY);
83669:     // browser's elementFromPoint expect browser-relative client coordinates.
83669:     // subtract browser's scroll values to adjust
83669:     let cwu = aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
83669:     let elem = this.getClosest(cwu, aX, aY);
83669: 
83669:     // step through layers of IFRAMEs and FRAMES to find innermost element
83669:     while (elem && (elem instanceof HTMLIFrameElement || elem instanceof HTMLFrameElement)) {
83669:       // adjust client coordinates' origin to be top left of iframe viewport
83669:       let rect = elem.getBoundingClientRect();
83669:       aX -= rect.left;
83669:       aY -= rect.top;
83669:       cwu = elem.contentDocument.defaultView.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
83669:       elem = ElementTouchHelper.getClosest(cwu, aX, aY);
83669:     }
83669: 
83669:     return elem;
83669:   },
83669: 
83669:   get radius() {
83669:     let prefs = Services.prefs;
83669:     delete this.radius;
83669:     return this.radius = { "top": prefs.getIntPref("browser.ui.touch.top"),
83669:                            "right": prefs.getIntPref("browser.ui.touch.right"),
83669:                            "bottom": prefs.getIntPref("browser.ui.touch.bottom"),
83669:                            "left": prefs.getIntPref("browser.ui.touch.left")
83669:                          };
83669:   },
83669: 
83669:   get weight() {
83669:     delete this.weight;
83669:     return this.weight = { "visited": Services.prefs.getIntPref("browser.ui.touch.weight.visited") };
83669:   },
83669: 
83669:   /* Retrieve the closest element to a point by looking at borders position */
83669:   getClosest: function getClosest(aWindowUtils, aX, aY) {
83669:     if (!this.dpiRatio)
83669:       this.dpiRatio = aWindowUtils.displayDPI / kReferenceDpi;
83669: 
83669:     let dpiRatio = this.dpiRatio;
83669: 
83669:     let target = aWindowUtils.elementFromPoint(aX, aY,
83669:                                                true,   /* ignore root scroll frame*/
83669:                                                false); /* don't flush layout */
83669: 
83992:     // if this element is clickable we return quickly
84302:     if (this.isElementClickable(target))
83992:       return target;
83992: 
83669:     let target = null;
83669:     let nodes = aWindowUtils.nodesFromRect(aX, aY, this.radius.top * dpiRatio,
83669:                                                    this.radius.right * dpiRatio,
83669:                                                    this.radius.bottom * dpiRatio,
83669:                                                    this.radius.left * dpiRatio, true, false);
83669: 
83669:     let threshold = Number.POSITIVE_INFINITY;
83669:     for (let i = 0; i < nodes.length; i++) {
83669:       let current = nodes[i];
84302:       if (!current.mozMatchesSelector || !this.isElementClickable(current))
83669:         continue;
83669: 
83669:       let rect = current.getBoundingClientRect();
83669:       let distance = this._computeDistanceFromRect(aX, aY, rect);
83669: 
83669:       // increase a little bit the weight for already visited items
83669:       if (current && current.mozMatchesSelector("*:visited"))
83669:         distance *= (this.weight.visited / 100);
83669: 
83669:       if (distance < threshold) {
83669:         target = current;
83669:         threshold = distance;
83669:       }
83669:     }
83669: 
83669:     return target;
83669:   },
83669: 
84302:   isElementClickable: function isElementClickable(aElement) {
83669:     const selector = "a,:link,:visited,[role=button],button,input,select,textarea,label";
83669:     for (let elem = aElement; elem; elem = elem.parentNode) {
83669:       if (this._hasMouseListener(elem))
83669:         return true;
83669:       if (elem.mozMatchesSelector && elem.mozMatchesSelector(selector))
83669:         return true;
83669:     }
83669:     return false;
83669:   },
83669: 
83669:   _computeDistanceFromRect: function _computeDistanceFromRect(aX, aY, aRect) {
83669:     let x = 0, y = 0;
83669:     let xmost = aRect.left + aRect.width;
83669:     let ymost = aRect.top + aRect.height;
83669: 
83669:     // compute horizontal distance from left/right border depending if X is
83669:     // before/inside/after the element's rectangle
83669:     if (aRect.left < aX && aX < xmost)
83669:       x = Math.min(xmost - aX, aX - aRect.left);
83669:     else if (aX < aRect.left)
83669:       x = aRect.left - aX;
83669:     else if (aX > xmost)
83669:       x = aX - xmost;
83669: 
83669:     // compute vertical distance from top/bottom border depending if Y is
83669:     // above/inside/below the element's rectangle
83669:     if (aRect.top < aY && aY < ymost)
83669:       y = Math.min(ymost - aY, aY - aRect.top);
83669:     else if (aY < aRect.top)
83669:       y = aRect.top - aY;
83669:     if (aY > ymost)
83669:       y = aY - ymost;
83669: 
83669:     return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
83669:   },
83669: 
83669:   _els: Cc["@mozilla.org/eventlistenerservice;1"].getService(Ci.nsIEventListenerService),
83669:   _clickableEvents: ["mousedown", "mouseup", "click"],
83669:   _hasMouseListener: function _hasMouseListener(aElement) {
83669:     let els = this._els;
83669:     let listeners = els.getListenerInfoFor(aElement, {});
83669:     for (let i = 0; i < listeners.length; i++) {
83669:       if (this._clickableEvents.indexOf(listeners[i].type) != -1)
83669:         return true;
83669:     }
83669:     return false;
83669:   },
84017: 
83669:   getContentClientRects: function(aElement) {
83669:     let offset = { x: 0, y: 0 };
83669: 
83669:     let nativeRects = aElement.getClientRects();
83669:     // step out of iframes and frames, offsetting scroll values
84017:     for (let frame = aElement.ownerDocument.defaultView; frame.frameElement; frame = frame.parent) {
83669:       // adjust client coordinates' origin to be top left of iframe viewport
83669:       let rect = frame.frameElement.getBoundingClientRect();
83669:       let left = frame.getComputedStyle(frame.frameElement, "").borderLeftWidth;
83669:       let top = frame.getComputedStyle(frame.frameElement, "").borderTopWidth;
83669:       offset.x += rect.left + parseInt(left);
83669:       offset.y += rect.top + parseInt(top);
83669:     }
83669: 
83669:     let result = [];
83669:     for (let i = nativeRects.length - 1; i >= 0; i--) {
83669:       let r = nativeRects[i];
83669:       result.push({ left: r.left + offset.x,
83669:                     top: r.top + offset.y,
83669:                     width: r.width,
83669:                     height: r.height
83669:                   });
83669:     }
83669:     return result;
84033:   },
89247: 
84033:   getBoundingContentRect: function(aElement) {
84033:     if (!aElement)
84033:       return {x: 0, y: 0, w: 0, h: 0};
84033: 
84033:     let document = aElement.ownerDocument;
84033:     while (document.defaultView.frameElement)
84033:       document = document.defaultView.frameElement.ownerDocument;
84033: 
84033:     let cwu = document.defaultView.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
84033:     let scrollX = {}, scrollY = {};
84033:     cwu.getScrollXY(false, scrollX, scrollY);
84033: 
84033:     let r = aElement.getBoundingClientRect();
84033: 
84033:     // step out of iframes and frames, offsetting scroll values
84033:     for (let frame = aElement.ownerDocument.defaultView; frame.frameElement && frame != content; frame = frame.parent) {
84033:       // adjust client coordinates' origin to be top left of iframe viewport
84033:       let rect = frame.frameElement.getBoundingClientRect();
84033:       let left = frame.getComputedStyle(frame.frameElement, "").borderLeftWidth;
84033:       let top = frame.getComputedStyle(frame.frameElement, "").borderTopWidth;
84033:       scrollX.value += rect.left + parseInt(left);
84033:       scrollY.value += rect.top + parseInt(top);
84033:     }
84033: 
89247:     return {x: r.left + scrollX.value,
89247:             y: r.top + scrollY.value,
89247:             w: r.width,
89247:             h: r.height };
83669:   }
83669: };
83654: 
83654: var ErrorPageEventHandler = {
83654:   handleEvent: function(aEvent) {
83654:     switch (aEvent.type) {
83654:       case "click": {
83654:         // Don't trust synthetic events
83654:         if (!aEvent.isTrusted)
83654:           return;
83654: 
83654:         let target = aEvent.originalTarget;
83654:         let errorDoc = target.ownerDocument;
83654: 
83654:         // If the event came from an ssl error page, it is probably either the "Add
83654:         // Exception…" or "Get me out of here!" button
83654:         if (/^about:certerror\?e=nssBadCert/.test(errorDoc.documentURI)) {
83654:           let perm = errorDoc.getElementById("permanentExceptionButton");
83654:           let temp = errorDoc.getElementById("temporaryExceptionButton");
83654:           if (target == temp || target == perm) {
66922:             // Handle setting an cert exception and reloading the page
66922:             try {
66922:               // Add a new SSL exception for this URL
83654:               let uri = Services.io.newURI(errorDoc.location.href, null, null);
66922:               let sslExceptions = new SSLExceptions();
66922: 
83654:               if (target == perm)
66922:                 sslExceptions.addPermanentException(uri);
66922:               else
66922:                 sslExceptions.addTemporaryException(uri);
66922:             } catch (e) {
83654:               dump("Failed to set cert exception: " + e + "\n");
64816:             }
83654:             errorDoc.location.reload();
83654:           } else if (target == errorDoc.getElementById("getMeOutOfHereButton")) {
84313:             errorDoc.location = "about:home";
83654:           }
83654:         }
83654:         break;
83654:       }
65842:     }
64742:   }
64742: };
64792: 
83664: var FormAssistant = {
84564:   // Used to keep track of the element that corresponds to the current
84564:   // autocomplete suggestions
84564:   _currentInputElement: null,
88112:   _uiBusy: false,
84564: 
84564:   init: function() {
84564:     Services.obs.addObserver(this, "FormAssist:AutoComplete", false);
84564:     Services.obs.addObserver(this, "FormAssist:Closed", false);
84564: 
87060:     BrowserApp.deck.addEventListener("input", this, false);
84564:   },
84564: 
84564:   uninit: function() {
84564:     Services.obs.removeObserver(this, "FormAssist:AutoComplete");
84564:     Services.obs.removeObserver(this, "FormAssist:Closed");
84564:   },
84564: 
84564:   observe: function(aSubject, aTopic, aData) {
84564:     switch (aTopic) {
84564:       case "FormAssist:AutoComplete":
84564:         if (!this._currentInputElement)
84564:           break;
84564: 
84564:         // Remove focus from the textbox to avoid some bad IME interactions
84564:         this._currentInputElement.blur();
84564:         this._currentInputElement.value = aData;
84564:         break;
84564: 
84564:       case "FormAssist:Closed":
84564:         this._currentInputElement = null;
84564:         break;
84564:     }
84564:   },
84564: 
84564:   handleEvent: function(aEvent) {
84564:     switch (aEvent.type) {
87060:       case "input":
84564:         let currentElement = aEvent.target;
84564:         if (!this._isAutocomplete(currentElement))
84564:           break;
84564: 
84564:         // Keep track of input element so we can fill it in if the user
84564:         // selects an autocomplete suggestion
84564:         this._currentInputElement = currentElement;
87060:         let suggestions = this._getAutocompleteSuggestions(currentElement.value, currentElement);
84564: 
89248:         let rect = ElementTouchHelper.getBoundingContentRect(currentElement);
89248:         let viewport = BrowserApp.selectedTab.viewport;
84564: 
84564:         sendMessageToJava({
84564:           gecko: {
84564:             type:  "FormAssist:AutoComplete",
84564:             suggestions: suggestions,
89248:             rect: [rect.x - (viewport.x / viewport.zoom), rect.y - (viewport.y / viewport.zoom), rect.w, rect.h],
89248:             zoom: viewport.zoom
84564:           }
84564:         });
84564:     }
84564:   },
84564: 
84564:   _isAutocomplete: function (aElement) {
84564:     if (!(aElement instanceof HTMLInputElement) ||
84564:         (aElement.getAttribute("type") == "password") ||
84564:         (aElement.hasAttribute("autocomplete") &&
84564:          aElement.getAttribute("autocomplete").toLowerCase() == "off"))
84564:       return false;
84564: 
84564:     return true;
84564:   },
84564: 
84564:   /** Retrieve the autocomplete list from the autocomplete service for an element */
84564:   _getAutocompleteSuggestions: function(aSearchString, aElement) {
84564:     let results = Cc["@mozilla.org/satchel/form-autocomplete;1"].
84564:                   getService(Ci.nsIFormAutoComplete).
84564:                   autoCompleteSearch(aElement.name || aElement.id, aSearchString, aElement, null);
84564: 
84564:     let suggestions = [];
84564:     if (results.matchCount > 0) {
84564:       for (let i = 0; i < results.matchCount; i++) {
84564:         let value = results.getValueAt(i);
84564:         // Do not show the value if it is the current one in the input field
84564:         if (value == aSearchString)
84564:           continue;
84564: 
84564:         suggestions.push(value);
84564:       }
84564:     }
84564: 
84564:     return suggestions;
84564:   },
84564: 
83664:   show: function(aList, aElement) {
83664:     let data = JSON.parse(sendMessageToJava({ gecko: aList }));
83664:     let selected = data.button;
88113:     if (selected == -1)
88113:         return;
88113: 
83664:     if (!(selected instanceof Array)) {
83664:       let temp = [];
83664:       for (let i = 0; i < aList.listitems.length; i++) {
83664:         temp[i] = (i == selected);
83664:       }
83664:       selected = temp;
83664:     }
83664:     this.forOptions(aElement, function(aNode, aIndex) {
83664:       aNode.selected = selected[aIndex];
83664:     });
83723:     this.fireOnChange(aElement);
83664:   },
83664: 
83992:   handleClick: function(aTarget) {
88112:     // if we're busy looking at a select we want to eat any clicks that
88112:     // come to us, but not to process them
88112:     if (this._uiBusy)
88112:         return true;
88112: 
83992:     let target = aTarget;
83664:     while (target) {
87607:       if (this._isSelectElement(target) && !target.disabled) {
88112:         this._uiBusy = true;
86777:         target.focus();
83664:         let list = this.getListForElement(target);
83664:         this.show(list, target);
83664:         target = null;
88112:         this._uiBusy = false;
83664:         return true;
83664:       }
83664:       if (target)
83664:         target = target.parentNode;
83664:     }
83664:     return false;
83664:   },
83664: 
83723:   fireOnChange: function(aElement) {
83723:     let evt = aElement.ownerDocument.createEvent("Events");
83723:     evt.initEvent("change", true, true, aElement.defaultView, 0,
83723:                   false, false,
83723:                   false, false, null);
83723:     setTimeout(function() {
83723:       aElement.dispatchEvent(evt);
83723:     }, 0);
83723:   },
83723: 
83664:   _isSelectElement: function(aElement) {
83664:     return (aElement instanceof HTMLSelectElement);
83664:   },
83664: 
83664:   getListForElement: function(aElement) {
83664:     let result = {
83664:       type: "Prompt:Show",
83664:       multiple: aElement.multiple,
83664:       selected: [],
83664:       listitems: []
83664:     };
83664: 
83664:     if (aElement.multiple) {
83664:       result.buttons = [
83664:         { label: Strings.browser.GetStringFromName("selectHelper.closeMultipleSelectDialog") },
83664:       ];
83664:     }
83664: 
89902:     this.forOptions(aElement, function(aNode, aIndex, aIsGroup, aInGroup) {
88129:       let item = {
83664:         label: aNode.text || aNode.label,
89902:         isGroup: aIsGroup,
89902:         inGroup: aInGroup,
83664:         disabled: aNode.disabled,
83664:         id: aIndex
83664:       }
89902:       if (aInGroup)
88129:         item.disabled = item.disabled || aNode.parentNode.disabled;
88129: 
88129:       result.listitems[aIndex] = item;
83664:       result.selected[aIndex] = aNode.selected;
83664:     });
83664:     return result;
83664:   },
83664: 
83664:   forOptions: function(aElement, aFunction) {
83664:     let optionIndex = 0;
83664:     let children = aElement.children;
89902:     let numChildren = children.length;
83711:     // if there are no children in this select, we add a dummy row so that at least something appears
89902:     if (numChildren == 0)
83711:       aFunction.call(this, {label:""}, optionIndex);
89902:     for (let i = 0; i < numChildren; i++) {
83664:       let child = children[i];
89902:       if (child instanceof HTMLOptionElement) {
89902:         // This is a regular choice under no group.
89902:         aFunction.call(this, child, optionIndex, false, false);
83664:         optionIndex++;
89902:       } else if (child instanceof HTMLOptGroupElement) {
89902:         aFunction.call(this, child, optionIndex, true, false);
89902:         optionIndex++;
83664: 
83664:         let subchildren = child.children;
89902:         let numSubchildren = subchildren.length;
89902:         for (let j = 0; j < numSubchildren; j++) {
83664:           let subchild = subchildren[j];
89902:           aFunction.call(this, subchild, optionIndex, false, true);
83664:           optionIndex++;
83664:         }
83664:       }
83664:     }
83664:   }
83664: }
83664: 
66814: var XPInstallObserver = {
83922:   init: function xpi_init() {
83922:     Services.obs.addObserver(XPInstallObserver, "addon-install-blocked", false);
83922:     Services.obs.addObserver(XPInstallObserver, "addon-install-started", false);
83922: 
83922:     AddonManager.addInstallListener(XPInstallObserver);
83922:   },
83922: 
83922:   uninit: function xpi_uninit() {
83922:     Services.obs.removeObserver(XPInstallObserver, "addon-install-blocked");
83922:     Services.obs.removeObserver(XPInstallObserver, "addon-install-started");
83922: 
83922:     AddonManager.removeInstallListener(XPInstallObserver);
83922:   },
83922: 
83627:   observe: function xpi_observer(aSubject, aTopic, aData) {
64795:     switch (aTopic) {
67002:       case "addon-install-started":
83627:         NativeWindow.toast.show(Strings.browser.GetStringFromName("alertAddonsDownloading"), "short");
67002:         break;
66234:       case "addon-install-blocked":
83627:         let installInfo = aSubject.QueryInterface(Ci.amIWebInstallInfo);
83627:         let host = installInfo.originatingURI.host;
83627: 
83627:         let brandShortName = Strings.brand.GetStringFromName("brandShortName");
83922:         let notificationName, buttons, message;
83627:         let strings = Strings.browser;
83627:         let enabled = true;
66234:         try {
66362:           enabled = Services.prefs.getBoolPref("xpinstall.enabled");
66234:         }
66234:         catch (e) {}
83627: 
66234:         if (!enabled) {
65295:           notificationName = "xpinstall-disabled";
66362:           if (Services.prefs.prefIsLocked("xpinstall.enabled")) {
83922:             message = strings.GetStringFromName("xpinstallDisabledMessageLocked");
64795:             buttons = [];
83627:           } else {
83922:             message = strings.formatStringFromName("xpinstallDisabledMessage2", [brandShortName, host], 2);
64795:             buttons = [{
67199:               label: strings.GetStringFromName("xpinstallDisabledButton"),
64795:               callback: function editPrefs() {
66362:                 Services.prefs.setBoolPref("xpinstall.enabled", true);
64795:                 return false;
64795:               }
64795:             }];
64795:           }
83627:         } else {
65295:           notificationName = "xpinstall";
83922:           message = strings.formatStringFromName("xpinstallPromptWarning2", [brandShortName, host], 2);
64795: 
64795:           buttons = [{
67199:             label: strings.GetStringFromName("xpinstallPromptAllowButton"),
64795:             callback: function() {
66234:               // Kick off the install
66234:               installInfo.install();
64795:               return false;
64795:             }
64795:           }];
64795:         }
83922:         NativeWindow.doorhanger.show(message, aTopic, buttons);
64795:         break;
64795:     }
83922:   },
83922: 
83922:   onInstallEnded: function(aInstall, aAddon) {
83922:     let needsRestart = false;
83922:     if (aInstall.existingAddon && (aInstall.existingAddon.pendingOperations & AddonManager.PENDING_UPGRADE))
83922:       needsRestart = true;
83922:     else if (aAddon.pendingOperations & AddonManager.PENDING_INSTALL)
83922:       needsRestart = true;
83922: 
83922:     if (needsRestart) {
87385:       let buttons = [{
83922:         label: Strings.browser.GetStringFromName("notificationRestart.button"),
83922:         callback: function() {
83922:           // Notify all windows that an application quit has been requested
83922:           let cancelQuit = Cc["@mozilla.org/supports-PRBool;1"].createInstance(Ci.nsISupportsPRBool);
83922:           Services.obs.notifyObservers(cancelQuit, "quit-application-requested", "restart");
83922: 
83922:           // If nothing aborted, quit the app
83922:           if (cancelQuit.data == false) {
83922:             let appStartup = Cc["@mozilla.org/toolkit/app-startup;1"].getService(Ci.nsIAppStartup);
83922:             appStartup.quit(Ci.nsIAppStartup.eRestart | Ci.nsIAppStartup.eAttemptQuit);
64795:           }
83922:         }
83922:       }];
83922: 
83922:       let message = Strings.browser.GetStringFromName("notificationRestart.normal");
83922:       NativeWindow.doorhanger.show(message, "addon-app-restart", buttons, BrowserApp.selectedTab.id, { persistence: -1 });
83922:     } else {
83922:       let message = Strings.browser.GetStringFromName("alertAddonsInstalledNoRestart");
83922:       NativeWindow.toast.show(message, "short");
83922:     }
83922:   },
83922: 
83922:   onInstallFailed: function(aInstall) {
83922:     NativeWindow.toast.show(Strings.browser.GetStringFromName("alertAddonsFail"), "short");
83922:   },
83922: 
83922:   onDownloadProgress: function xpidm_onDownloadProgress(aInstall) {},
83922: 
83922:   onDownloadFailed: function(aInstall) {
83922:     this.onInstallFailed(aInstall);
83922:   },
83922: 
90048:   onDownloadCancelled: function(aInstall) {
90127:     let host = (aInstall.originatingURI instanceof Ci.nsIStandardURL) && aInstall.originatingURI.host;
90127:     if (!host)
90127:       host = (aInstall.sourceURI instanceof Ci.nsIStandardURL) && aInstall.sourceURI.host;
90127: 
90127:     let error = (host || aInstall.error == 0) ? "addonError" : "addonLocalError";
90127:     if (aInstall.error != 0)
90127:       error += aInstall.error;
90127:     else if (aInstall.addon && aInstall.addon.blocklistState == Ci.nsIBlocklistService.STATE_BLOCKED)
90127:       error += "Blocklisted";
90127:     else if (aInstall.addon && (!aInstall.addon.isCompatible || !aInstall.addon.isPlatformCompatible))
90127:       error += "Incompatible";
90127:     else
90127:       return; // No need to show anything in this case.
90127: 
90127:     let msg = Strings.browser.GetStringFromName(error);
90127:     // TODO: formatStringFromName
90127:     msg = msg.replace("#1", aInstall.name);
90127:     if (host)
90127:       msg = msg.replace("#2", host);
90127:     msg = msg.replace("#3", Strings.brand.GetStringFromName("brandShortName"));
90127:     msg = msg.replace("#4", Services.appinfo.version);
90048: 
90048:     NativeWindow.toast.show(msg, "short");
90048:   }
64795: };
83714: 
83966: // Blindly copied from Safari documentation for now.
83966: const kViewportMinScale  = 0;
83966: const kViewportMaxScale  = 10;
83966: const kViewportMinWidth  = 200;
83966: const kViewportMaxWidth  = 10000;
83966: const kViewportMinHeight = 223;
83966: const kViewportMaxHeight = 10000;
83966: 
83966: var ViewportHandler = {
86798:   // The cached viewport metadata for each document. We tie viewport metadata to each document
86798:   // instead of to each tab so that we don't have to update it when the document changes. Using an
86798:   // ES6 weak map lets us avoid leaks.
86798:   _metadata: new WeakMap(),
86798: 
86799:   // A list of document IDs, arbitrarily assigned. We use IDs to refer to content documents instead
86799:   // of strong references to avoid leaking them.
86799:   _documentIds: new WeakMap(),
86799:   _nextDocumentId: 0,
86799: 
83966:   init: function init() {
83966:     addEventListener("DOMMetaAdded", this, false);
83966:     addEventListener("resize", this, false);
83966:   },
83966: 
83966:   uninit: function uninit() {
83966:     removeEventListener("DOMMetaAdded", this, false);
83966:     removeEventListener("resize", this, false);
83966:   },
83966: 
83966:   handleEvent: function handleEvent(aEvent) {
83966:     let target = aEvent.originalTarget;
83966:     let document = target.ownerDocument || target;
83966:     let browser = BrowserApp.getBrowserForDocument(document);
83966:     let tab = BrowserApp.getTabForBrowser(browser);
83966:     if (!tab)
83966:       return;
83966: 
83966:     switch (aEvent.type) {
83966:       case "DOMMetaAdded":
83966:         if (target.name == "viewport")
83966:           this.updateMetadata(tab);
83966:         break;
83966: 
83966:       case "resize":
83966:         this.onResize();
83966:         break;
83966:     }
83966:   },
83966: 
83966:   resetMetadata: function resetMetadata(tab) {
83966:     tab.updateViewportMetadata(null);
83966:   },
83966: 
83966:   updateMetadata: function updateMetadata(tab) {
83966:     let metadata = this.getViewportMetadata(tab.browser.contentWindow);
83966:     tab.updateViewportMetadata(metadata);
83966:   },
83966: 
83966:   /**
83966:    * Returns an object with the page's preferred viewport properties:
83966:    *   defaultZoom (optional float): The initial scale when the page is loaded.
83966:    *   minZoom (optional float): The minimum zoom level.
83966:    *   maxZoom (optional float): The maximum zoom level.
83966:    *   width (optional int): The CSS viewport width in px.
83966:    *   height (optional int): The CSS viewport height in px.
83966:    *   autoSize (boolean): Resize the CSS viewport when the window resizes.
83966:    *   allowZoom (boolean): Let the user zoom in or out.
83966:    *   autoScale (boolean): Adjust the viewport properties to account for display density.
83966:    */
83966:   getViewportMetadata: function getViewportMetadata(aWindow) {
83966:     let doctype = aWindow.document.doctype;
83966:     if (doctype && /(WAP|WML|Mobile)/.test(doctype.publicId))
83966:       return { defaultZoom: 1, autoSize: true, allowZoom: true, autoScale: true };
83966: 
83966:     let windowUtils = aWindow.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
83966:     let handheldFriendly = windowUtils.getDocumentMetadata("HandheldFriendly");
83966:     if (handheldFriendly == "true")
83966:       return { defaultZoom: 1, autoSize: true, allowZoom: true, autoScale: true };
83966: 
83966:     if (aWindow.document instanceof XULDocument)
83966:       return { defaultZoom: 1, autoSize: true, allowZoom: false, autoScale: false };
83966: 
83966:     // viewport details found here
83966:     // http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/MetaTags.html
83966:     // http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html
83966: 
83966:     // Note: These values will be NaN if parseFloat or parseInt doesn't find a number.
83966:     // Remember that NaN is contagious: Math.max(1, NaN) == Math.min(1, NaN) == NaN.
83966:     let scale = parseFloat(windowUtils.getDocumentMetadata("viewport-initial-scale"));
83966:     let minScale = parseFloat(windowUtils.getDocumentMetadata("viewport-minimum-scale"));
83966:     let maxScale = parseFloat(windowUtils.getDocumentMetadata("viewport-maximum-scale"));
83966: 
83966:     let widthStr = windowUtils.getDocumentMetadata("viewport-width");
83966:     let heightStr = windowUtils.getDocumentMetadata("viewport-height");
83966:     let width = this.clamp(parseInt(widthStr), kViewportMinWidth, kViewportMaxWidth);
83966:     let height = this.clamp(parseInt(heightStr), kViewportMinHeight, kViewportMaxHeight);
83966: 
83966:     let allowZoomStr = windowUtils.getDocumentMetadata("viewport-user-scalable");
83966:     let allowZoom = !/^(0|no|false)$/.test(allowZoomStr); // WebKit allows 0, "no", or "false"
83966: 
83966:     scale = this.clamp(scale, kViewportMinScale, kViewportMaxScale);
83966:     minScale = this.clamp(minScale, kViewportMinScale, kViewportMaxScale);
83966:     maxScale = this.clamp(maxScale, kViewportMinScale, kViewportMaxScale);
83966: 
83966:     // If initial scale is 1.0 and width is not set, assume width=device-width
83966:     let autoSize = (widthStr == "device-width" ||
83966:                     (!widthStr && (heightStr == "device-height" || scale == 1.0)));
83966: 
83966:     return {
83966:       defaultZoom: scale,
83966:       minZoom: minScale,
83966:       maxZoom: maxScale,
83966:       width: width,
83966:       height: height,
83966:       autoSize: autoSize,
83966:       allowZoom: allowZoom,
83966:       autoScale: true
83966:     };
83966:   },
83966: 
83966:   onResize: function onResize() {
92913:     Tabs.getInstance().getSelectedTab().updateViewportSize();        
83966:   },
83966: 
83966:   clamp: function(num, min, max) {
83966:     return Math.max(min, Math.min(max, num));
83966:   },
83966: 
83966:   // The device-pixel-to-CSS-px ratio used to adjust meta viewport values.
83966:   // This is higher on higher-dpi displays, so pages stay about the same physical size.
83966:   getScaleRatio: function getScaleRatio() {
83966:     let prefValue = Services.prefs.getIntPref("browser.viewport.scaleRatio");
83966:     if (prefValue > 0)
83966:       return prefValue / 100;
83966: 
83966:     let dpi = this.displayDPI;
83966:     if (dpi < 200) // Includes desktop displays, and LDPI and MDPI Android devices
83966:       return 1;
83966:     else if (dpi < 300) // Includes Nokia N900, and HDPI Android devices
83966:       return 1.5;
83966: 
83966:     // For very high-density displays like the iPhone 4, calculate an integer ratio.
83966:     return Math.floor(dpi / 150);
83966:   },
83966: 
83966:   get displayDPI() {
83966:     let utils = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
83966:     delete this.displayDPI;
83966:     return this.displayDPI = utils.displayDPI;
86798:   },
86798: 
86798:   /**
86798:    * Returns the viewport metadata for the given document, or the default metrics if no viewport
86798:    * metadata is available for that document.
86798:    */
86798:   getMetadataForDocument: function getMetadataForDocument(aDocument) {
86798:     let metadata = this._metadata.get(aDocument, this.getDefaultMetadata());
86798:     return metadata;
86798:   },
86798: 
86798:   /** Updates the saved viewport metadata for the given content document. */
86798:   setMetadataForDocument: function setMetadataForDocument(aDocument, aMetadata) {
86798:     if (!aMetadata)
86798:       this._metadata.delete(aDocument);
86798:     else
86798:       this._metadata.set(aDocument, aMetadata);
86798:   },
86798: 
86798:   /** Returns the default viewport metadata for a document. */
86798:   getDefaultMetadata: function getDefaultMetadata() {
86798:     return {
86798:       autoSize: false,
86798:       allowZoom: true,
86798:       autoScale: true,
86798:       scaleRatio: ViewportHandler.getScaleRatio()
86798:     };
86799:   },
86799: 
86799:   /**
86799:    * Returns a globally unique ID for the given content document. Using IDs to refer to documents
86799:    * allows content documents to be identified without any possibility of leaking them.
86799:    */
86799:   getIdForDocument: function getIdForDocument(aDocument) {
86799:     let id = this._documentIds.get(aDocument, null);
86799:     if (id == null) {
86799:       id = this._nextDocumentId++;
86799:       this._documentIds.set(aDocument, id);
86799:     }
86799:     return id;
83966:   }
83966: };
83966: 
83714: /**
83714:  * Handler for blocked popups, triggered by DOMUpdatePageReport events in browser.xml
83714:  */
83714: var PopupBlockerObserver = {
83714:   onUpdatePageReport: function onUpdatePageReport(aEvent) {
83714:     let browser = BrowserApp.selectedBrowser;
83714:     if (aEvent.originalTarget != browser)
83714:       return;
83714: 
83714:     if (!browser.pageReport)
83714:       return;
83714: 
83714:     let result = Services.perms.testExactPermission(BrowserApp.selectedBrowser.currentURI, "popup");
83714:     if (result == Ci.nsIPermissionManager.DENY_ACTION)
83714:       return;
83714: 
83714:     // Only show the notification again if we've not already shown it. Since
83714:     // notifications are per-browser, we don't need to worry about re-adding
83714:     // it.
83714:     if (!browser.pageReport.reported) {
83714:       if (Services.prefs.getBoolPref("privacy.popups.showBrowserMessage")) {
83714:         let brandShortName = Strings.brand.GetStringFromName("brandShortName");
83714:         let message;
83714:         let popupCount = browser.pageReport.length;
83714: 
83714:         let strings = Strings.browser;
83714:         if (popupCount > 1)
83714:           message = strings.formatStringFromName("popupWarningMultiple", [brandShortName, popupCount], 2);
83714:         else
83714:           message = strings.formatStringFromName("popupWarning", [brandShortName], 1);
83714: 
83714:         let buttons = [
83714:           {
83714:             label: strings.GetStringFromName("popupButtonAllowOnce"),
83714:             callback: function() { PopupBlockerObserver.showPopupsForSite(); }
83714:           },
83714:           {
83714:             label: strings.GetStringFromName("popupButtonAlwaysAllow2"),
83714:             callback: function() { PopupBlockerObserver.allowPopupsForSite(true); }
83714:           },
83714:           {
83714:             label: strings.GetStringFromName("popupButtonNeverWarn2"),
83714:             callback: function() { PopupBlockerObserver.allowPopupsForSite(false); }
83714:           }
83714:         ];
83714: 
83714:         NativeWindow.doorhanger.show(message, "popup-blocked", buttons);
83714:       }
83714:       // Record the fact that we've reported this blocked popup, so we don't
83714:       // show it again.
83714:       browser.pageReport.reported = true;
83714:     }
83714:   },
83714: 
83714:   allowPopupsForSite: function allowPopupsForSite(aAllow) {
83714:     let currentURI = BrowserApp.selectedBrowser.currentURI;
83714:     Services.perms.add(currentURI, "popup", aAllow
83714:                        ?  Ci.nsIPermissionManager.ALLOW_ACTION
83714:                        :  Ci.nsIPermissionManager.DENY_ACTION);
83714:     dump("Allowing popups for: " + currentURI);
83714:   },
83714: 
83714:   showPopupsForSite: function showPopupsForSite() {
83714:     let uri = BrowserApp.selectedBrowser.currentURI;
83714:     let pageReport = BrowserApp.selectedBrowser.pageReport;
83714:     if (pageReport) {
83714:       for (let i = 0; i < pageReport.length; ++i) {
83966:         let popupURIspec = pageReport[i].popupWindowURI.spec;
83714: 
83714:         // Sometimes the popup URI that we get back from the pageReport
83714:         // isn't useful (for instance, netscape.com's popup URI ends up
83714:         // being "http://www.netscape.com", which isn't really the URI of
83714:         // the popup they're trying to show).  This isn't going to be
83714:         // useful to the user, so we won't create a menu item for it.
83714:         if (popupURIspec == "" || popupURIspec == "about:blank" || popupURIspec == uri.spec)
83714:           continue;
83714: 
83714:         let popupFeatures = pageReport[i].popupWindowFeatures;
83714:         let popupName = pageReport[i].popupWindowName;
83714: 
83714:         BrowserApp.addTab(popupURIspec);
83714:       }
83714:     }
83714:   }
83714: };
83786: 
83786: 
83786: var OfflineApps = {
83786:   init: function() {
83786:     BrowserApp.deck.addEventListener("MozApplicationManifest", this, false);
83786:   },
83786: 
83786:   uninit: function() {
83786:     BrowserApp.deck.removeEventListener("MozApplicationManifest", this, false);
83786:   },
83786: 
83786:   handleEvent: function(aEvent) {
83786:     if (aEvent.type == "MozApplicationManifest")
83786:       this.offlineAppRequested(aEvent.originalTarget.defaultView);
83786:   },
83786: 
83786:   offlineAppRequested: function(aContentWindow) {
83786:     if (!Services.prefs.getBoolPref("browser.offline-apps.notify"))
83786:       return;
83786: 
83786:     let browser = BrowserApp.getBrowserForWindow(aContentWindow);
83786:     let tab = BrowserApp.getTabForBrowser(browser);
83786:     let currentURI = aContentWindow.document.documentURIObject;
83786: 
83786:     // Don't bother showing UI if the user has already made a decision
83786:     if (Services.perms.testExactPermission(currentURI, "offline-app") != Services.perms.UNKNOWN_ACTION)
83786:       return;
83786: 
83786:     try {
83786:       if (Services.prefs.getBoolPref("offline-apps.allow_by_default")) {
83786:         // All pages can use offline capabilities, no need to ask the user
83786:         return;
83786:       }
83786:     } catch(e) {
83786:       // This pref isn't set by default, ignore failures
83786:     }
83786: 
83786:     let host = currentURI.asciiHost;
83786:     let notificationID = "offline-app-requested-" + host;
83786: 
83786:     let strings = Strings.browser;
83786:     let buttons = [{
83786:       label: strings.GetStringFromName("offlineApps.allow"),
83786:       callback: function() {
83786:         OfflineApps.allowSite(aContentWindow.document);
83786:       }
83786:     },
83786:     {
83786:       label: strings.GetStringFromName("offlineApps.never"),
83786:       callback: function() {
83786:         OfflineApps.disallowSite(aContentWindow.document);
83786:       }
83786:     },
83786:     {
83786:       label: strings.GetStringFromName("offlineApps.notNow"),
83786:       callback: function() { /* noop */ }
83786:     }];
83786: 
83786:     let message = strings.formatStringFromName("offlineApps.available2", [host], 1);
83786:     NativeWindow.doorhanger.show(message, notificationID, buttons, tab.id);
83786:   },
83786: 
83786:   allowSite: function(aDocument) {
83786:     Services.perms.add(aDocument.documentURIObject, "offline-app", Services.perms.ALLOW_ACTION);
83786: 
83786:     // When a site is enabled while loading, manifest resources will
83786:     // start fetching immediately.  This one time we need to do it
83786:     // ourselves.
83786:     this._startFetching(aDocument);
83786:   },
83786: 
83786:   disallowSite: function(aDocument) {
83786:     Services.perms.add(aDocument.documentURIObject, "offline-app", Services.perms.DENY_ACTION);
83786:   },
83786: 
83786:   _startFetching: function(aDocument) {
83786:     if (!aDocument.documentElement)
83786:       return;
83786: 
83786:     let manifest = aDocument.documentElement.getAttribute("manifest");
83786:     if (!manifest)
83786:       return;
83786: 
83786:     let manifestURI = Services.io.newURI(manifest, aDocument.characterSet, aDocument.documentURIObject);
83786:     let updateService = Cc["@mozilla.org/offlinecacheupdate-service;1"].getService(Ci.nsIOfflineCacheUpdateService);
83786:     updateService.scheduleUpdate(manifestURI, aDocument.documentURIObject, window);
83786:   }
83786: };
83833: 
83833: var IndexedDB = {
83833:   _permissionsPrompt: "indexedDB-permissions-prompt",
83833:   _permissionsResponse: "indexedDB-permissions-response",
83833: 
83833:   _quotaPrompt: "indexedDB-quota-prompt",
83833:   _quotaResponse: "indexedDB-quota-response",
83833:   _quotaCancel: "indexedDB-quota-cancel",
83833: 
83833:   init: function IndexedDB_init() {
83833:     Services.obs.addObserver(this, this._permissionsPrompt, false);
83833:     Services.obs.addObserver(this, this._quotaPrompt, false);
83833:     Services.obs.addObserver(this, this._quotaCancel, false);
83833:   },
83833: 
83833:   uninit: function IndexedDB_uninit() {
83833:     Services.obs.removeObserver(this, this._permissionsPrompt, false);
83833:     Services.obs.removeObserver(this, this._quotaPrompt, false);
83833:     Services.obs.removeObserver(this, this._quotaCancel, false);
83833:   },
83833: 
83833:   observe: function IndexedDB_observe(subject, topic, data) {
83833:     if (topic != this._permissionsPrompt &&
83833:         topic != this._quotaPrompt &&
83833:         topic != this._quotaCancel) {
83833:       throw new Error("Unexpected topic!");
83833:     }
83833: 
83833:     let requestor = subject.QueryInterface(Ci.nsIInterfaceRequestor);
83833: 
83833:     let contentWindow = requestor.getInterface(Ci.nsIDOMWindow);
83833:     let contentDocument = contentWindow.document;
83833:     let browser = BrowserApp.getBrowserForWindow(contentWindow);
83833:     if (!browser)
83833:       return;
83833: 
83833:     let host = contentDocument.documentURIObject.asciiHost;
83833: 
83833:     let strings = Strings.browser;
83833: 
83833:     let message, responseTopic;
83833:     if (topic == this._permissionsPrompt) {
83833:       message = strings.formatStringFromName("offlineApps.available2", [host], 1);
83833:       responseTopic = this._permissionsResponse;
83833:     } else if (topic == this._quotaPrompt) {
83833:       message = strings.formatStringFromName("indexedDBQuota.wantsTo", [ host, data ], 2);
83833:       responseTopic = this._quotaResponse;
83833:     } else if (topic == this._quotaCancel) {
83833:       responseTopic = this._quotaResponse;
83833:     }
83833: 
83833:     let notificationID = responseTopic + host;
83834:     let tab = BrowserApp.getTabForBrowser(browser);
83834:     let observer = requestor.getInterface(Ci.nsIObserver);
83833: 
83834:     if (topic == this._quotaCancel) {
83834:       NativeWindow.doorhanger.hide(notificationID, tab.id);
83834:       observer.observe(null, responseTopic, Ci.nsIPermissionManager.UNKNOWN_ACTION);
83834:       return;
83834:     }
83834: 
83833:     let buttons = [{
83833:       label: strings.GetStringFromName("offlineApps.allow"),
83833:       callback: function() {
83833:         observer.observe(null, responseTopic, Ci.nsIPermissionManager.ALLOW_ACTION);
83833:       }
83833:     },
83833:     {
83833:       label: strings.GetStringFromName("offlineApps.never"),
83833:       callback: function() {
83833:         observer.observe(null, responseTopic, Ci.nsIPermissionManager.DENY_ACTION);
83833:       }
83833:     },
83833:     {
83833:       label: strings.GetStringFromName("offlineApps.notNow"),
83833:       callback: function() {
83833:         observer.observe(null, responseTopic, Ci.nsIPermissionManager.UNKNOWN_ACTION);
83833:       }
83833:     }];
83833: 
83833:     NativeWindow.doorhanger.show(message, notificationID, buttons, tab.id);
83833:   }
83833: };
83993: 
83993: var ConsoleAPI = {
83993:   init: function init() {
83993:     Services.obs.addObserver(this, "console-api-log-event", false);
83993:   },
83993: 
83993:   uninit: function uninit() {
83993:     Services.obs.removeObserver(this, "console-api-log-event", false);
83993:   },
83993: 
83993:   observe: function observe(aMessage, aTopic, aData) {
83993:     aMessage = aMessage.wrappedJSObject;
83993: 
83993:     let mappedArguments = Array.map(aMessage.arguments, this.formatResult, this);
83993:     let joinedArguments = Array.join(mappedArguments, " ");
83993: 
83993:     if (aMessage.level == "error" || aMessage.level == "warn") {
83993:       let flag = (aMessage.level == "error" ? Ci.nsIScriptError.errorFlag : Ci.nsIScriptError.warningFlag);
83993:       let consoleMsg = Cc["@mozilla.org/scripterror;1"].createInstance(Ci.nsIScriptError);
83993:       consoleMsg.init(joinedArguments, null, null, 0, 0, flag, "content javascript");
83993:       Services.console.logMessage(consoleMsg);
83993:     } else if (aMessage.level == "trace") {
83993:       let bundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
83993:       let args = aMessage.arguments;
83993:       let filename = this.abbreviateSourceURL(args[0].filename);
83993:       let functionName = args[0].functionName || bundle.GetStringFromName("stacktrace.anonymousFunction");
83993:       let lineNumber = args[0].lineNumber;
83993: 
83993:       let body = bundle.formatStringFromName("stacktrace.outputMessage", [filename, functionName, lineNumber], 3);
83993:       body += "\n";
83993:       args.forEach(function(aFrame) {
83993:         let functionName = aFrame.functionName || bundle.GetStringFromName("stacktrace.anonymousFunction");
83993:         body += "  " + aFrame.filename + " :: " + functionName + " :: " + aFrame.lineNumber + "\n";
83993:       });
83993: 
83993:       Services.console.logStringMessage(body);
83993:     } else if (aMessage.level == "time" && aMessage.arguments) {
83993:       let bundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
83993:       let body = bundle.formatStringFromName("timer.start", [aMessage.arguments.name], 1);
83993:       Services.console.logStringMessage(body);
83993:     } else if (aMessage.level == "timeEnd" && aMessage.arguments) {
83993:       let bundle = Services.strings.createBundle("chrome://browser/locale/browser.properties");
83993:       let body = bundle.formatStringFromName("timer.end", [aMessage.arguments.name, aMessage.arguments.duration], 2);
83993:       Services.console.logStringMessage(body);
83993:     } else if (["group", "groupCollapsed", "groupEnd"].indexOf(aMessage.level) != -1) {
83993:       // Do nothing yet
83993:     } else {
83993:       Services.console.logStringMessage(joinedArguments);
83993:     }
83993:   },
83993: 
83993:   getResultType: function getResultType(aResult) {
83993:     let type = aResult === null ? "null" : typeof aResult;
83993:     if (type == "object" && aResult.constructor && aResult.constructor.name)
83993:       type = aResult.constructor.name;
83993:     return type.toLowerCase();
83993:   },
83993: 
83993:   formatResult: function formatResult(aResult) {
83993:     let output = "";
83993:     let type = this.getResultType(aResult);
83993:     switch (type) {
83993:       case "string":
83993:       case "boolean":
83993:       case "date":
83993:       case "error":
83993:       case "number":
83993:       case "regexp":
83993:         output = aResult.toString();
83993:         break;
83993:       case "null":
83993:       case "undefined":
83993:         output = type;
83993:         break;
83993:       default:
83993:         if (aResult.toSource) {
83993:           try {
83993:             output = aResult.toSource();
83993:           } catch (ex) { }
83993:         }
83993:         if (!output || output == "({})") {
83993:           output = aResult.toString();
83993:         }
83993:         break;
83993:     }
83993: 
83993:     return output;
83993:   },
83993: 
83993:   abbreviateSourceURL: function abbreviateSourceURL(aSourceURL) {
83993:     // Remove any query parameters.
83993:     let hookIndex = aSourceURL.indexOf("?");
83993:     if (hookIndex > -1)
83993:       aSourceURL = aSourceURL.substring(0, hookIndex);
83993: 
83993:     // Remove a trailing "/".
83993:     if (aSourceURL[aSourceURL.length - 1] == "/")
83993:       aSourceURL = aSourceURL.substring(0, aSourceURL.length - 1);
83993: 
83993:     // Remove all but the last path component.
83993:     let slashIndex = aSourceURL.lastIndexOf("/");
83993:     if (slashIndex > -1)
83993:       aSourceURL = aSourceURL.substring(slashIndex + 1);
83993: 
83993:     return aSourceURL;
83993:   }
83993: };
84386: 
84521: var ClipboardHelper = {
84521:   init: function() {
84521:     NativeWindow.contextmenus.add(Strings.browser.GetStringFromName("contextmenu.copy"), ClipboardHelper.getCopyContext(false), ClipboardHelper.copy.bind(ClipboardHelper));
84521:     NativeWindow.contextmenus.add(Strings.browser.GetStringFromName("contextmenu.copyAll"), ClipboardHelper.getCopyContext(true), ClipboardHelper.copy.bind(ClipboardHelper));
87130:     NativeWindow.contextmenus.add(Strings.browser.GetStringFromName("contextmenu.selectAll"), ClipboardHelper.selectAllContext, ClipboardHelper.select.bind(ClipboardHelper));
84521:     NativeWindow.contextmenus.add(Strings.browser.GetStringFromName("contextmenu.paste"), ClipboardHelper.pasteContext, ClipboardHelper.paste.bind(ClipboardHelper));
84521:     NativeWindow.contextmenus.add(Strings.browser.GetStringFromName("contextmenu.changeInputMethod"), NativeWindow.contextmenus.textContext, ClipboardHelper.inputMethod.bind(ClipboardHelper));
84521:   },
84521: 
84521:   get clipboardHelper() {
84521:     delete this.clipboardHelper;
84521:     return this.clipboardHelper = Cc["@mozilla.org/widget/clipboardhelper;1"].getService(Ci.nsIClipboardHelper);
84521:   },
84521: 
84521:   get clipboard() {
84521:     delete this.clipboard;
84521:     return this.clipboard = Cc["@mozilla.org/widget/clipboard;1"].getService(Ci.nsIClipboard);
84521:   },
84521: 
84521:   copy: function(aElement) {
84521:     let selectionStart = aElement.selectionStart;
84521:     let selectionEnd = aElement.selectionEnd;
84521:     if (selectionStart != selectionEnd) {
84521:       string = aElement.value.slice(selectionStart, selectionEnd);
84521:       this.clipboardHelper.copyString(string);
84521:     } else {
84521:       this.clipboardHelper.copyString(aElement.value);
84521:     }
84521:   },
84521: 
84521:   select: function(aElement) {
84521:     if (!aElement || !(aElement instanceof Ci.nsIDOMNSEditableElement))
84521:       return;
84521:     let target = aElement.QueryInterface(Ci.nsIDOMNSEditableElement);
84521:     target.editor.selectAll();
84521:     target.focus();
84521:   },
84521: 
84521:   paste: function(aElement) {
84521:     if (!aElement || !(aElement instanceof Ci.nsIDOMNSEditableElement))
84521:       return;
84521:     let target = aElement.QueryInterface(Ci.nsIDOMNSEditableElement);
84521:     target.editor.paste(Ci.nsIClipboard.kGlobalClipboard);
84521:     target.focus();  
84521:   },
84521: 
84521:   inputMethod: function(aElement) {
84521:     Cc["@mozilla.org/imepicker;1"].getService(Ci.nsIIMEPicker).show();
84521:   },
84521: 
84521:   getCopyContext: function(isCopyAll) {
84521:     return {
84521:       matches: function(aElement) {
84521:         if (NativeWindow.contextmenus.textContext.matches(aElement)) {
87130:           // Don't include "copy" for password fields.
87130:           // mozIsTextField(true) tests for only non-password fields.
87130:           if (aElement instanceof Ci.nsIDOMHTMLInputElement && !aElement.mozIsTextField(true))
87130:             return false;
87130: 
84521:           let selectionStart = aElement.selectionStart;
84521:           let selectionEnd = aElement.selectionEnd;
84521:           if (selectionStart != selectionEnd)
84521:             return true;
87130: 
87130:           if (isCopyAll && aElement.textLength > 0)
84521:             return true;
84521:         }
84521:         return false;
84521:       }
84521:     }
84521:   },
84521: 
87130:   selectAllContext: {
87130:     matches: function selectAllContextMatches(aElement) {
87130:       if (NativeWindow.contextmenus.textContext.matches(aElement)) {
87130:           let selectionStart = aElement.selectionStart;
87130:           let selectionEnd = aElement.selectionEnd;
87130:           return (selectionStart > 0 || selectionEnd < aElement.textLength);
87130:       }
87130:       return false;
87130:     }
87130:   },
87130: 
84521:   pasteContext: {
84521:     matches: function(aElement) {
84521:       if (NativeWindow.contextmenus.textContext.matches(aElement)) {
84521:         let flavors = ["text/unicode"];
84521:         return ClipboardHelper.clipboard.hasDataMatchingFlavors(flavors, flavors.length, Ci.nsIClipboard.kGlobalClipboard);
84521:       }
84521:       return false;
84521:     }
84521:   }
84521: }
84521: 
84386: var PluginHelper = {
84386:   showDoorHanger: function(aTab) {
85047:     let message = Strings.browser.GetStringFromName("clickToPlayPlugins.message");
84386:     let buttons = [
84386:       {
85047:         label: Strings.browser.GetStringFromName("clickToPlayPlugins.yes"),
84386:         callback: function() {
84386:           PluginHelper.playAllPlugins(aTab);
84386:         }
84386:       },
84386:       {
85047:         label: Strings.browser.GetStringFromName("clickToPlayPlugins.no"),
84386:         callback: function() {
84386:           // Do nothing
84386:         }
84386:       }
84386:     ]
84386:     NativeWindow.doorhanger.show(message, "ask-to-play-plugins", buttons, aTab.id);
84386:   },
84386: 
86786:   playAllPlugins: function(aTab, aEvent) {
86786:     if (aEvent) {
86786:       if (!aEvent.isTrusted)
86786:         return;
86786:       aEvent.preventDefault();
86786:     }
86786: 
89412:     this._findAndPlayAllPlugins(aTab.browser.contentWindow);
89412:   },
89412: 
89412:   // Helper function that recurses through sub-frames to find all plugin objects
89412:   _findAndPlayAllPlugins: function _findAndPlayAllPlugins(aWindow) {
89412:     let embeds = aWindow.document.getElementsByTagName("embed");
89412:     for (let i = 0; i < embeds.length; i++) {
89412:       if (!embeds[i].hasAttribute("played"))
89412:         this._playPlugin(embeds[i]);
89412:     }
89412: 
89412:     let objects = aWindow.document.getElementsByTagName("object");
89412:     for (let i = 0; i < objects.length; i++) {
89412:       if (!objects[i].hasAttribute("played"))
89412:         this._playPlugin(objects[i]);
89412:     }
89412: 
89412:     for (let i = 0; i < aWindow.frames.length; i++) {
89412:       this._findAndPlayAllPlugins(aWindow.frames[i]);
89412:     }
89412:   },
89412: 
89412:   _playPlugin: function _playPlugin(aPlugin) {
89412:     let objLoadingContent = aPlugin.QueryInterface(Ci.nsIObjectLoadingContent);
84386:     objLoadingContent.playPlugin();
89412: 
89412:     // Set an attribute on the plugin object to avoid re-loading it
89412:     aPlugin.setAttribute("played", true);
84386:   },
84386: 
84514:   getPluginPreference: function getPluginPreference() {
84514:     let pluginDisable = Services.prefs.getBoolPref("plugin.disable");
84514:     if (pluginDisable)
84514:       return "0";
84514: 
84514:     let clickToPlay = Services.prefs.getBoolPref("plugins.click_to_play");
84514:     return clickToPlay ? "2" : "1";
84514:   },
84514: 
84514:   setPluginPreference: function setPluginPreference(aValue) {
84514:     switch (aValue) {
84514:       case "0": // Enable Plugins = No
84514:         Services.prefs.setBoolPref("plugin.disable", true);
84514:         Services.prefs.clearUserPref("plugins.click_to_play");
84514:         break;
84514:       case "1": // Enable Plugins = Yes
84514:         Services.prefs.clearUserPref("plugin.disable");
84514:         Services.prefs.setBoolPref("plugins.click_to_play", false);
84514:         break;
84514:       case "2": // Enable Plugins = Tap to Play (default)
84514:         Services.prefs.clearUserPref("plugin.disable");
84514:         Services.prefs.clearUserPref("plugins.click_to_play");
84514:         break;
84514:     }
84514:   },
84514: 
84386:   // Copied from /browser/base/content/browser.js
84386:   isTooSmall : function (plugin, overlay) {
84386:     // Is the <object>'s size too small to hold what we want to show?
84386:     let pluginRect = plugin.getBoundingClientRect();
84386:     // XXX bug 446693. The text-shadow on the submitted-report text at
84386:     //     the bottom causes scrollHeight to be larger than it should be.
84386:     let overflows = (overlay.scrollWidth > pluginRect.width) ||
84386:                     (overlay.scrollHeight - 5 > pluginRect.height);
84386: 
84386:     return overflows;
84386:   }
84386: };
84883: 
84883: var PermissionsHelper = {
84883: 
86199:   _permissonTypes: ["password", "geolocation", "popup", "indexedDB",
84883:                     "offline-app", "desktop-notification"],
84883:   _permissionStrings: {
84883:     "password": {
84883:       label: "password.rememberPassword",
84883:       allowed: "password.remember",
84883:       denied: "password.never"
84883:     },
86199:     "geolocation": {
84883:       label: "geolocation.shareLocation",
86199:       allowed: "geolocation.alwaysAllow",
86199:       denied: "geolocation.neverAllow"
84883:     },
84883:     "popup": {
84883:       label: "blockPopups.label",
84883:       allowed: "popupButtonAlwaysAllow2",
84883:       denied: "popupButtonNeverWarn2"
84883:     },
84883:     "indexedDB": {
84883:       label: "offlineApps.storeOfflineData",
84883:       allowed: "offlineApps.allow",
84883:       denied: "offlineApps.never"
84883:     },
84883:     "offline-app": {
84883:       label: "offlineApps.storeOfflineData",
84883:       allowed: "offlineApps.allow",
84883:       denied: "offlineApps.never"
84883:     },
84883:     "desktop-notification": {
84883:       label: "desktopNotification.useNotifications",
84883:       allowed: "desktopNotification.allow",
84883:       denied: "desktopNotification.dontAllow"
84883:     }
84883:   },
84883: 
84883:   init: function init() {
84883:     Services.obs.addObserver(this, "Permissions:Get", false);
84883:     Services.obs.addObserver(this, "Permissions:Clear", false);
84883:   },
84883: 
84883:   observe: function observe(aSubject, aTopic, aData) {
84883:     let uri = BrowserApp.selectedBrowser.currentURI;
84883: 
84883:     switch (aTopic) {
84883:       case "Permissions:Get":
84883:         let permissions = [];
84883:         for (let i = 0; i < this._permissonTypes.length; i++) {
84883:           let type = this._permissonTypes[i];
84883:           let value = this.getPermission(uri, type);
84883: 
84883:           // Only add the permission if it was set by the user
84883:           if (value == Services.perms.UNKNOWN_ACTION)
84883:             continue;
84883: 
84883:           // Get the strings that correspond to the permission type
84883:           let typeStrings = this._permissionStrings[type];
84883:           let label = Strings.browser.GetStringFromName(typeStrings["label"]);
84883: 
84883:           // Get the key to look up the appropriate string entity
84883:           let valueKey = value == Services.perms.ALLOW_ACTION ?
84883:                          "allowed" : "denied";
84883:           let valueString = Strings.browser.GetStringFromName(typeStrings[valueKey]);
84883: 
84883:           // If we implement a two-line UI, we will need to pass the label and
84883:           // value individually and let java handle the formatting
84883:           let setting = Strings.browser.formatStringFromName("siteSettings.labelToValue",
84883:                                                              [ label, valueString ], 2)
84883:           permissions.push({
84883:             type: type,
84883:             setting: setting
84883:           });
84883:         }
84883: 
84883:         // Keep track of permissions, so we know which ones to clear
84883:         this._currentPermissions = permissions; 
84883: 
87258:         let host;
87258:         try {
87258:           host = uri.host;
87258:         } catch(e) {
87258:           host = uri.spec;
87258:         }
84883:         sendMessageToJava({
84883:           gecko: {
84883:             type: "Permissions:Data",
87258:             host: host,
84883:             permissions: permissions
84883:           }
84883:         });
84883:         break;
84883:  
84883:       case "Permissions:Clear":
84883:         // An array of the indices of the permissions we want to clear
84883:         let permissionsToClear = JSON.parse(aData);
84883: 
84883:         for (let i = 0; i < permissionsToClear.length; i++) {
84883:           let indexToClear = permissionsToClear[i];
84883:           let permissionType = this._currentPermissions[indexToClear]["type"];
84883:           this.clearPermission(uri, permissionType);
84883:         }
84883:         break;
84883:     }
84883:   },
84883: 
84883:   /**
84883:    * Gets the permission value stored for a specified permission type.
84883:    *
84883:    * @param aType
84883:    *        The permission type string stored in permission manager.
86199:    *        e.g. "geolocation", "indexedDB", "popup"
84883:    *
84883:    * @return A permission value defined in nsIPermissionManager.
84883:    */
84883:   getPermission: function getPermission(aURI, aType) {
84883:     // Password saving isn't a nsIPermissionManager permission type, so handle
84883:     // it seperately.
84883:     if (aType == "password") {
84883:       // By default, login saving is enabled, so if it is disabled, the
84883:       // user selected the never remember option
84883:       if (!Services.logins.getLoginSavingEnabled(aURI.prePath))
84883:         return Services.perms.DENY_ACTION;
84883: 
84883:       // Check to see if the user ever actually saved a login
84883:       if (Services.logins.countLogins(aURI.prePath, "", ""))
84883:         return Services.perms.ALLOW_ACTION;
84883: 
84883:       return Services.perms.UNKNOWN_ACTION;
84883:     }
84883: 
84883:     // Geolocation consumers use testExactPermission
86199:     if (aType == "geolocation")
84883:       return Services.perms.testExactPermission(aURI, aType);
84883: 
84883:     return Services.perms.testPermission(aURI, aType);
84883:   },
84883: 
84883:   /**
84883:    * Clears a user-set permission value for the site given a permission type.
84883:    *
84883:    * @param aType
84883:    *        The permission type string stored in permission manager.
86199:    *        e.g. "geolocation", "indexedDB", "popup"
84883:    */
84883:   clearPermission: function clearPermission(aURI, aType) {
84883:     // Password saving isn't a nsIPermissionManager permission type, so handle
84883:     // it seperately.
84883:     if (aType == "password") {
84883:       // Get rid of exisiting stored logings
84883:       let logins = Services.logins.findLogins({}, aURI.prePath, "", "");
84883:       for (let i = 0; i < logins.length; i++) {
84883:         Services.logins.removeLogin(logins[i]);
84883:       }
84883:       // Re-set login saving to enabled
84883:       Services.logins.setLoginSavingEnabled(aURI.prePath, true);
84883:     } else {
84883:       Services.perms.remove(aURI.host, aType);
86884:       // Clear content prefs set in ContentPermissionPrompt.js
86884:       Services.contentPrefs.removePref(aURI, aType + ".request.remember");
84883:     }
84883:   }
87960: };
86025: 
86025: var MasterPassword = {
86025:   pref: "privacy.masterpassword.enabled",
86196:   _tokenName: "",
86196: 
86025:   get _secModuleDB() {
86025:     delete this._secModuleDB;
86025:     return this._secModuleDB = Cc["@mozilla.org/security/pkcs11moduledb;1"].getService(Ci.nsIPKCS11ModuleDB);
86025:   },
86025: 
86025:   get _pk11DB() {
86025:     delete this._pk11DB;
86025:     return this._pk11DB = Cc["@mozilla.org/security/pk11tokendb;1"].getService(Ci.nsIPK11TokenDB);
86025:   },
86025: 
86025:   get enabled() {
86025:     let slot = this._secModuleDB.findSlotByName(this._tokenName);
86025:     if (slot) {
86025:       let status = slot.status;
86025:       return status != Ci.nsIPKCS11Slot.SLOT_UNINITIALIZED && status != Ci.nsIPKCS11Slot.SLOT_READY;
86025:     }
86025:     return false;
86025:   },
86025: 
86025:   setPassword: function setPassword(aPassword) {
86025:     try {
86025:       let status;
86025:       let slot = this._secModuleDB.findSlotByName(this._tokenName);
86025:       if (slot)
86025:         status = slot.status;
86025:       else
86025:         return false;
86025: 
86025:       let token = this._pk11DB.findTokenByName(this._tokenName);
86025: 
86025:       if (status == Ci.nsIPKCS11Slot.SLOT_UNINITIALIZED)
86025:         token.initPassword(aPassword);
86025:       else if (status == Ci.nsIPKCS11Slot.SLOT_READY)
86025:         token.changePassword("", aPassword);
86025: 
86025:       this.updatePref();
86025:       return true;
86025:     } catch(e) {
86025:       dump("MasterPassword.setPassword: " + e);
86025:     }
86025:     return false;
86025:   },
86025: 
86025:   removePassword: function removePassword(aOldPassword) {
86025:     try {
86025:       let token = this._pk11DB.getInternalKeyToken();
86025:       if (token.checkPassword(aOldPassword)) {
86025:         token.changePassword(aOldPassword, "");
86025:         this.updatePref();
86025:         return true;
86025:       }
86025:     } catch(e) {
86025:       dump("MasterPassword.removePassword: " + e + "\n");
86025:     }
86025:     NativeWindow.toast.show(Strings.browser.GetStringFromName("masterPassword.incorrect"), "short");
86025:     return false;
86025:   },
86025: 
86025:   updatePref: function() {
86025:     var prefs = [];
86025:     let pref = {
86025:       name: this.pref,
86025:       type: "bool",
86025:       value: this.enabled
86025:     };
86025:     prefs.push(pref);
86025: 
86025:     sendMessageToJava({
86025:       gecko: {
86025:         type: "Preferences:Data",
86025:         preferences: prefs
86025:       }
86025:     });
86025:   }
87960: };
87960: 
87960: var CharacterEncoding = {
87960:   _charsets: [],
87960: 
87960:   init: function init() {
87960:     Services.obs.addObserver(this, "CharEncoding:Get", false);
87960:     Services.obs.addObserver(this, "CharEncoding:Set", false);
87960:     this.sendState();
87960:   },
87960: 
87960:   uninit: function uninit() {
87960:     Services.obs.removeObserver(this, "CharEncoding:Get", false);
87960:     Services.obs.removeObserver(this, "CharEncoding:Set", false);
87960:   },
87960: 
87960:   observe: function observe(aSubject, aTopic, aData) {
87960:     switch (aTopic) {
87960:       case "CharEncoding:Get":
87960:         this.getEncoding();
87960:         break;
87960:       case "CharEncoding:Set":
87960:         this.setEncoding(aData);
87960:         break;
87960:     }
87960:   },
87960: 
87960:   sendState: function sendState() {
87960:     let showCharEncoding = "false";
87960:     try {
87960:       showCharEncoding = Services.prefs.getComplexValue("browser.menu.showCharacterEncoding", Ci.nsIPrefLocalizedString).data;
87960:     } catch (e) { /* Optional */ }
87960: 
87960:     sendMessageToJava({
87960:       gecko: {
87960:         type: "CharEncoding:State",
87960:         visible: showCharEncoding
87960:       }
87960:     });
87960:   },
87960: 
87960:   getEncoding: function getEncoding() {
87960:     function normalizeCharsetCode(charsetCode) {
87960:       return charsetCode.trim().toLowerCase();
87960:     }
87960: 
87960:     function getTitle(charsetCode) {
87960:       let charsetTitle = charsetCode;
87960:       try {
87960:         charsetTitle = Strings.charset.GetStringFromName(charsetCode + ".title");
87960:       } catch (e) {
87960:         dump("error: title not found for " + charsetCode);
87960:       }
87960:       return charsetTitle;
87960:     }
87960: 
87960:     if (!this._charsets.length) {
87960:       let charsets = Services.prefs.getComplexValue("intl.charsetmenu.browser.static", Ci.nsIPrefLocalizedString).data;
87960:       this._charsets = charsets.split(",").map(function (charset) {
87960:         return {
87960:           code: normalizeCharsetCode(charset),
87960:           title: getTitle(charset)
87960:         };
87960:       });
87960:     }
87960: 
87960:     // if document charset is not in charset options, add it
87960:     let docCharset = normalizeCharsetCode(BrowserApp.selectedBrowser.contentDocument.characterSet);
87960:     let selected = 0;
87960:     let charsetCount = this._charsets.length;
87960:     for (; selected < charsetCount && this._charsets[selected].code != docCharset; selected++);
87960:     if (selected == charsetCount) {
87960:       this._charsets.push({
87960:         code: docCharset,
87960:         title: getTitle(docCharset)
87960:       });
87960:     }
87960: 
87960:     sendMessageToJava({
87960:       gecko: {
87960:         type: "CharEncoding:Data",
87960:         charsets: this._charsets,
87960:         selected: selected
87960:       }
87960:     });
87960:   },
87960: 
87960:   setEncoding: function setEncoding(aEncoding) {
87960:     let browser = BrowserApp.selectedBrowser;
87960:     let docCharset = browser.docShell.QueryInterface(Ci.nsIDocCharset);
87960:     docCharset.charset = aEncoding;
87960:     browser.reload(Ci.nsIWebNavigation.LOAD_FLAGS_CHARSET_CHANGE);
89889:   }
87960: };
87960: 
