53414: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53414:  * vim: set ts=8 sw=4 et tw=79:
53414:  *
53414:  * ***** BEGIN LICENSE BLOCK *****
47584:  * Copyright (C) 2008 Apple Inc. All rights reserved.
47584:  *
47584:  * Redistribution and use in source and binary forms, with or without
47584:  * modification, are permitted provided that the following conditions
47584:  * are met:
47584:  * 1. Redistributions of source code must retain the above copyright
47584:  *    notice, this list of conditions and the following disclaimer.
47584:  * 2. Redistributions in binary form must reproduce the above copyright
47584:  *    notice, this list of conditions and the following disclaimer in the
47584:  *    documentation and/or other materials provided with the distribution.
47584:  *
47584:  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
47584:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
47584:  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
47584:  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
47584:  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
47584:  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
47584:  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
47584:  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
47584:  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
47584:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
47584:  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
53414:  * 
53414:  * ***** END LICENSE BLOCK ***** */
47584: 
47584: #ifndef AssemblerBuffer_h
47584: #define AssemblerBuffer_h
47584: 
47584: #include "assembler/wtf/Platform.h"
47584: 
47584: #if ENABLE_ASSEMBLER
47584: 
47584: #include <string.h>
47584: #include "assembler/jit/ExecutableAllocator.h"
47584: #include "assembler/wtf/Assertions.h"
47584: #include "jsstdint.h"
47584: 
47584: namespace JSC {
47584: 
47584:     class AssemblerBuffer {
47584:         static const int inlineCapacity = 256;
47584:     public:
47584:         AssemblerBuffer()
47584:             : m_buffer(m_inlineBuffer)
47584:             , m_capacity(inlineCapacity)
47584:             , m_size(0)
56037:             , m_oom(false)
47584:         {
47584:         }
47584: 
47584:         ~AssemblerBuffer()
47584:         {
47584:             if (m_buffer != m_inlineBuffer)
47584:                 free(m_buffer);
47584:         }
47584: 
47584:         void ensureSpace(int space)
47584:         {
47584:             if (m_size > m_capacity - space)
47584:                 grow();
47584:         }
47584: 
47584:         bool isAligned(int alignment) const
47584:         {
47584:             return !(m_size & (alignment - 1));
47584:         }
47584: 
47584:         void putByteUnchecked(int value)
47584:         {
47584:             ASSERT(!(m_size > m_capacity - 4));
47584:             m_buffer[m_size] = char(value);
47584:             m_size++;
47584:         }
47584: 
47584:         void putByte(int value)
47584:         {
47584:             if (m_size > m_capacity - 4)
47584:                 grow();
47584:             putByteUnchecked(value);
47584:         }
47584: 
47584:         void putShortUnchecked(int value)
47584:         {
47584:             ASSERT(!(m_size > m_capacity - 4));
47584:             *reinterpret_cast<short*>(&m_buffer[m_size]) = short(value);
47584:             m_size += 2;
47584:         }
47584: 
47584:         void putShort(int value)
47584:         {
47584:             if (m_size > m_capacity - 4)
47584:                 grow();
47584:             putShortUnchecked(value);
47584:         }
47584: 
47584:         void putIntUnchecked(int value)
47584:         {
47584:             ASSERT(!(m_size > m_capacity - 4));
47584:             *reinterpret_cast<int*>(&m_buffer[m_size]) = value;
47584:             m_size += 4;
47584:         }
47584: 
47584:         void putInt64Unchecked(int64_t value)
47584:         {
47584:             ASSERT(!(m_size > m_capacity - 8));
47584:             *reinterpret_cast<int64_t*>(&m_buffer[m_size]) = value;
47584:             m_size += 8;
47584:         }
47584: 
47584:         void putInt(int value)
47584:         {
47584:             if (m_size > m_capacity - 4)
47584:                 grow();
47584:             putIntUnchecked(value);
47584:         }
47584: 
47584:         void* data() const
47584:         {
47584:             return m_buffer;
47584:         }
47584: 
47584:         int size() const
47584:         {
47584:             return m_size;
47584:         }
47584: 
56037:         bool oom() const
56037:         {
56037:             return m_oom;
56037:         }
56037: 
56037:         /*
56037:          * The user must check for a NULL return value, which means
56037:          * no code was generated, or there was an OOM.
56037:          */
47584:         void* executableCopy(ExecutablePool* allocator)
47584:         {
56037:             if (m_oom)
56037:                 return 0;
56037: 
47584:             if (!m_size)
47584:                 return 0;
47584: 
47584:             void* result = allocator->alloc(m_size);
47584: 
47584:             if (!result)
47584:                 return 0;
47584: 
47584:             ExecutableAllocator::makeWritable(result, m_size);
47584: 
47584:             return memcpy(result, m_buffer, m_size);
47584:         }
47584: 
47584:         unsigned char *buffer() const {
56037:             ASSERT(!m_oom);
47584:             return reinterpret_cast<unsigned char *>(m_buffer);
47584:         }
47584: 
47584:     protected:
47584:         void append(const char* data, int size)
47584:         {
47584:             if (m_size > m_capacity - size)
47584:                 grow(size);
47584: 
56037:             // If we OOM and size > inlineCapacity, this would crash.
56037:             if (m_oom)
56037:                 return;
47584:             memcpy(m_buffer + m_size, data, size);
47584:             m_size += size;
47584:         }
47584: 
56037:         /*
56037:          * OOM handling: This class can OOM in the grow() method trying to
56037:          * allocate a new buffer. In response to an OOM, we need to avoid
56037:          * crashing and report the error. We also want to make it so that
56037:          * users of this class need to check for OOM only at certain points
56037:          * and not after every operation.
56037:          *
56037:          * Our strategy for handling an OOM is to set m_oom, and then set
56037:          * m_size to 0, preserving the current buffer. This way, the user
56037:          * can continue assembling into the buffer, deferring OOM checking
56037:          * until the user wants to read code out of the buffer.
56037:          *
56037:          * See also the |executableCopy| and |buffer| methods.
56037:          */
56037: 
47584:         void grow(int extraCapacity = 0)
47584:         {
56037:             int newCapacity = m_capacity + m_capacity / 2 + extraCapacity;
56037:             char* newBuffer;
47584: 
47584:             if (m_buffer == m_inlineBuffer) {
56037:                 newBuffer = static_cast<char*>(malloc(newCapacity));
56037:                 if (!newBuffer) {
56037:                     m_size = 0;
56037:                     m_oom = true;
56037:                     return;
56037:                 }
56037:                 memcpy(newBuffer, m_buffer, m_size);
56037:             } else {
56037:                 newBuffer = static_cast<char*>(realloc(m_buffer, newCapacity));
56037:                 if (!newBuffer) {
56037:                     m_size = 0;
56037:                     m_oom = true;
56037:                     return;
56037:                 }
56037:             }
56037: 
56037:             m_buffer = newBuffer;
56037:             m_capacity = newCapacity;
47584:         }
47584: 
47584:         char m_inlineBuffer[inlineCapacity];
47584:         char* m_buffer;
47584:         int m_capacity;
47584:         int m_size;
56037:         bool m_oom;
47584:     };
47584: 
47584: } // namespace JSC
47584: 
47584: #endif // ENABLE(ASSEMBLER)
47584: 
47584: #endif // AssemblerBuffer_h
