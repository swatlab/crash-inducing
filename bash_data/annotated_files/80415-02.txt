    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Vidur Apparao <vidur@netscape.com>
    1:  *   Johnny Stenback <jst@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsGlobalWindow_h___
    1: #define nsGlobalWindow_h___
    1: 
54231: #include "mozilla/XPCOM.h" // for TimeStamp/TimeDuration
54231: 
    1: // Local Includes
    1: // Helper Classes
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsWeakReference.h"
    1: #include "nsHashtable.h"
    1: #include "nsDataHashtable.h"
    1: #include "nsCycleCollectionParticipant.h"
11622: #include "nsDOMScriptObjectHolder.h"
    1: 
    1: // Interfaces Needed
    1: #include "nsDOMWindowList.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIBrowserDOMWindow.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDOMClientInformation.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMNavigator.h"
16677: #include "nsIDOMNavigatorGeolocation.h"
52355: #include "nsIDOMNavigatorDesktopNotification.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIDOMJSWindow.h"
    1: #include "nsIDOMChromeWindow.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIScriptTimeoutHandler.h"
    1: #include "nsITimer.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsPIDOMWindow.h"
 4040: #include "nsIDOMModalContentWindow.h"
    1: #include "nsIScriptSecurityManager.h"
72328: #include "nsEventListenerManager.h"
    1: #include "nsIDOMDocument.h"
54925: #ifndef MOZ_DISABLE_DOMCRYPTO
    1: #include "nsIDOMCrypto.h"
54925: #endif
    1: #include "nsIPrincipal.h"
    1: #include "nsPluginArray.h"
    1: #include "nsMimeTypeArray.h"
    1: #include "nsIXPCScriptable.h"
    1: #include "nsPoint.h"
    1: #include "nsSize.h"
30882: #include "nsRect.h"
    1: #include "mozFlushType.h"
    1: #include "prclist.h"
28438: #include "nsIDOMStorageObsolete.h"
    1: #include "nsIDOMStorageList.h"
37608: #include "nsIDOMStorageEvent.h"
60385: #include "nsIDOMStorageIndexedDB.h"
 1938: #include "nsIDOMOfflineResourceList.h"
 4040: #include "nsIArray.h"
29018: #include "nsIContent.h"
46347: #include "nsIIDBFactory.h"
42412: #include "nsFrameMessageManager.h"
48032: #include "mozilla/TimeStamp.h"
77146: #include "nsIDOMTouchEvent.h"
77149: #include "nsIInlineEventHandlers.h"
    1: 
55577: // JS includes
55577: #include "jsapi.h"
55577: #include "jswrapper.h"
55577: 
    1: #define DEFAULT_HOME_PAGE "www.mozilla.org"
    1: #define PREF_BROWSER_STARTUP_HOMEPAGE "browser.startup.homepage"
    1: 
54231: // Amount of time allowed between alert/prompt/confirm before enabling
54231: // the stop dialog checkbox.
54231: #define SUCCESSIVE_DIALOG_TIME_LIMIT 3 // 3 sec
54231: 
54231: // During click or mousedown events (and others, see nsDOMEvent) we allow modal
54231: // dialogs up to this limit, even if they were disabled.
54231: #define MAX_DIALOG_COUNT 10
54231: 
    1: class nsIDOMBarProp;
    1: class nsIDocument;
    1: class nsPresContext;
    1: class nsIDOMEvent;
37063: class nsIScrollableFrame;
 6910: class nsIControllers;
    1: 
    1: class nsBarProp;
    1: class nsLocation;
    1: class nsNavigator;
    1: class nsScreen;
    1: class nsHistory;
72298: class nsPerformance;
    1: class nsIDocShellLoadInfo;
    1: class WindowStateHolder;
    1: class nsGlobalWindowObserver;
    1: class nsGlobalWindow;
 6774: class nsDummyJavaPluginOwner;
14898: class PostMessageEvent;
35152: class nsRunnable;
    1: 
 1938: class nsDOMOfflineResourceList;
16677: class nsGeolocation;
56333: class nsDesktopNotificationCenter;
58023: class nsDOMMozURLProperty;
 1938: 
54925: #ifdef MOZ_DISABLE_DOMCRYPTO
54925: class nsIDOMCrypto;
54925: #endif
54925: 
    1: extern nsresult
10986: NS_CreateJSTimeoutHandler(nsGlobalWindow *aWindow,
79445:                           bool *aIsInterval,
    1:                           PRInt32 *aInterval,
    1:                           nsIScriptTimeoutHandler **aRet);
    1: 
    1: /*
    1:  * Timeout struct that holds information about each script
    1:  * timeout.  Holds a strong reference to an nsIScriptTimeoutHandler, which
    1:  * abstracts the language specific cruft.
    1:  */
    1: struct nsTimeout : PRCList
    1: {
    1:   nsTimeout();
    1:   ~nsTimeout();
    1: 
24195:   NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS(nsTimeout)
24195: 
    1:   nsrefcnt Release();
    1:   nsrefcnt AddRef();
    1: 
    1:   nsTimeout* Next() {
    1:     // Note: might not actually return an nsTimeout.  Use IsTimeout to check.
 3233:     return static_cast<nsTimeout*>(PR_NEXT_LINK(this));
    1:   }
    1: 
    1:   nsTimeout* Prev() {
    1:     // Note: might not actually return an nsTimeout.  Use IsTimeout to check.
 3233:     return static_cast<nsTimeout*>(PR_PREV_LINK(this));
    1:   }
    1: 
    1:   // Window for which this timeout fires
    1:   nsRefPtr<nsGlobalWindow> mWindow;
    1: 
    1:   // The actual timer object
    1:   nsCOMPtr<nsITimer> mTimer;
    1: 
    1:   // True if the timeout was cleared
79445:   bool mCleared;
    1: 
    1:   // True if this is one of the timeouts that are currently running
79445:   bool mRunning;
    1: 
72734:   // True if this is a repeating/interval timer
79445:   bool mIsInterval;
72734: 
    1:   // Returned as value of setTimeout()
    1:   PRUint32 mPublicId;
    1: 
72734:   // Interval in milliseconds
    1:   PRUint32 mInterval;
    1: 
48032:   // mWhen and mTimeRemaining can't be in a union, sadly, because they
48032:   // have constructors.
48032:   // Nominal time to run this timeout.  Use only when timeouts are not
48032:   // suspended.
48032:   mozilla::TimeStamp mWhen;
48032:   // Remaining time to wait.  Used only when timeouts are suspended.
48032:   mozilla::TimeDuration mTimeRemaining;
    1: 
    1:   // Principal with which to execute
    1:   nsCOMPtr<nsIPrincipal> mPrincipal;
    1: 
    1:   // stack depth at which timeout is firing
    1:   PRUint32 mFiringDepth;
    1: 
34729:   // 
34729:   PRUint32 mNestingLevel;
34729: 
    1:   // The popup state at timeout creation time if not created from
    1:   // another timeout
    1:   PopupControlState mPopupState;
    1: 
    1:   // The language-specific information about the callback.
    1:   nsCOMPtr<nsIScriptTimeoutHandler> mScriptHandler;
    1: 
    1: private:
    1:   // reference count for shared usage
24195:   nsAutoRefCnt mRefCnt;
    1: };
    1: 
    1: //*****************************************************************************
55577: // nsOuterWindow: Outer Window Proxy
55577: //*****************************************************************************
55577: 
79386: class nsOuterWindowProxy : public js::Wrapper
55577: {
55577: public:
79386:   nsOuterWindowProxy() : js::Wrapper((uintN)0) {}
55577: 
55577:   virtual bool isOuterWindow() {
55577:     return true;
55577:   }
55577:   JSString *obj_toString(JSContext *cx, JSObject *wrapper);
80415:   void finalize(JSContext *cx, JSObject *proxy);
55577: 
55577:   static nsOuterWindowProxy singleton;
55577: };
55577: 
55577: JSObject *NS_NewOuterWindowProxy(JSContext *cx, JSObject *parent);
55577: 
55577: //*****************************************************************************
    1: // nsGlobalWindow: Global Object for Scripting
    1: //*****************************************************************************
    1: // Beware that all scriptable interfaces implemented by
    1: // nsGlobalWindow will be reachable from JS, if you make this class
    1: // implement new interfaces you better know what you're
    1: // doing. Security wise this is very sensitive code. --
    1: // jst@netscape.com
    1: 
    1: // nsGlobalWindow inherits PRCList for maintaining a list of all inner
10976: // windows still in memory for any given outer window. This list is
    1: // needed to ensure that mOuterWindow doesn't end up dangling. The
    1: // nature of PRCList means that the window itself is always in the
    1: // list, and an outer window's list will also contain all inner window
    1: // objects that are still in memory (and in reality all inner window
    1: // object's lists also contain its outer and all other inner windows
    1: // belonging to the same outer window, but that's an unimportant
    1: // side effect of inheriting PRCList).
    1: 
    1: class nsGlobalWindow : public nsPIDOMWindow,
    1:                        public nsIScriptGlobalObject,
    1:                        public nsIDOMJSWindow,
    1:                        public nsIScriptObjectPrincipal,
74957:                        public nsIDOMEventTarget,
60385:                        public nsIDOMStorageIndexedDB,
    1:                        public nsSupportsWeakReference,
    1:                        public nsIInterfaceRequestor,
55577:                        public nsWrapperCache,
72298:                        public PRCListStr,
77146:                        public nsIDOMWindowPerformance,
77149:                        public nsITouchEventReceiver,
77149:                        public nsIInlineEventHandlers
    1: {
    1: public:
58023:   friend class nsDOMMozURLProperty;
58023: 
54231:   typedef mozilla::TimeStamp TimeStamp;
54231:   typedef mozilla::TimeDuration TimeDuration;
72692:   typedef nsDataHashtable<nsUint64HashKey, nsGlobalWindow*> WindowByIdTable;
54231: 
    1:   // public methods
    1:   nsPIDOMWindow* GetPrivateParent();
    1:   // callback for close event
    1:   void ReallyCloseWindow();
    1: 
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
80266:   // nsWrapperCache
80266:   JSObject *WrapObject(JSContext *cx, XPCWrappedNativeScope *scope,
80266:                        bool *triedToWrap)
80266:   {
80266:     NS_ASSERTION(IsOuterWindow(),
80266:                  "Inner window supports nsWrapperCache, fix WrapObject!");
80266:     *triedToWrap = true;
80266:     return EnsureInnerWindow() ? GetWrapper() : nsnull;
80266:   }
80266: 
    1:   // nsIScriptGlobalObject
    1:   virtual nsIScriptContext *GetContext();
    1:   virtual JSObject *GetGlobalJSObject();
47412:   JSObject *FastGetGlobalJSObject()
47412:   {
47412:     return mJSObject;
47412:   }
    1: 
    1:   virtual nsresult EnsureScriptEnvironment(PRUint32 aLangID);
    1: 
    1:   virtual nsIScriptContext *GetScriptContext(PRUint32 lang);
    1:   virtual void *GetScriptGlobal(PRUint32 lang);
    1: 
    1:   // Set a new script language context for this global.  The native global
    1:   // for the context is created by the context's GetNativeGlobal() method.
    1:   virtual nsresult SetScriptContext(PRUint32 lang, nsIScriptContext *aContext);
    1:   
68467:   virtual void OnFinalize(JSObject* aObject);
79445:   virtual void SetScriptsEnabled(bool aEnabled, bool aFireTimeouts);
    1: 
    1:   // nsIScriptObjectPrincipal
    1:   virtual nsIPrincipal* GetPrincipal();
    1: 
    1:   // nsIDOMWindow
    1:   NS_DECL_NSIDOMWINDOW
    1: 
72298:   // nsIDOMWindowPerformance
72298:   NS_DECL_NSIDOMWINDOWPERFORMANCE
72298: 
    1:   // nsIDOMJSWindow
    1:   NS_DECL_NSIDOMJSWINDOW
    1: 
    1:   // nsIDOMEventTarget
    1:   NS_DECL_NSIDOMEVENTTARGET
    1: 
77146:   // nsITouchEventReceiver
77146:   NS_DECL_NSITOUCHEVENTRECEIVER
77146: 
77149:   // nsIInlineEventHandlers
77149:   NS_DECL_NSIINLINEEVENTHANDLERS
77149: 
    1:   // nsPIDOMWindow
    1:   virtual NS_HIDDEN_(nsPIDOMWindow*) GetPrivateRoot();
79445:   virtual NS_HIDDEN_(void) ActivateOrDeactivate(bool aActivate);
79445:   virtual NS_HIDDEN_(void) SetActive(bool aActive);
79445:   virtual NS_HIDDEN_(void) SetIsBackground(bool aIsBackground);
72326:   virtual NS_HIDDEN_(void) SetChromeEventHandler(nsIDOMEventTarget* aChromeEventHandler);
    1: 
    1:   virtual NS_HIDDEN_(void) SetOpenerScriptPrincipal(nsIPrincipal* aPrincipal);
    1:   virtual NS_HIDDEN_(nsIPrincipal*) GetOpenerScriptPrincipal();
    1: 
79445:   virtual NS_HIDDEN_(PopupControlState) PushPopupControlState(PopupControlState state, bool aForce) const;
    1:   virtual NS_HIDDEN_(void) PopPopupControlState(PopupControlState state) const;
    1:   virtual NS_HIDDEN_(PopupControlState) GetPopupControlState() const;
    1: 
    1:   virtual NS_HIDDEN_(nsresult) SaveWindowState(nsISupports **aState);
    1:   virtual NS_HIDDEN_(nsresult) RestoreWindowState(nsISupports *aState);
25723:   virtual NS_HIDDEN_(void) SuspendTimeouts(PRUint32 aIncrease = 1,
79445:                                            bool aFreezeChildren = true);
79445:   virtual NS_HIDDEN_(nsresult) ResumeTimeouts(bool aThawChildren = true);
25723:   virtual NS_HIDDEN_(PRUint32) TimeoutSuspendCount();
    1:   virtual NS_HIDDEN_(nsresult) FireDelayedDOMEvents();
79445:   virtual NS_HIDDEN_(bool) IsFrozen() const
10340:   {
10340:     return mIsFrozen;
10340:   }
    1: 
79445:   virtual NS_HIDDEN_(bool) WouldReuseInnerWindow(nsIDocument *aNewDocument);
    1: 
    1:   virtual NS_HIDDEN_(void) SetDocShell(nsIDocShell* aDocShell);
    1:   virtual NS_HIDDEN_(nsresult) SetNewDocument(nsIDocument *aDocument,
53996:                                               nsISupports *aState,
79445:                                               bool aForceReuseInnerWindow);
43472:   void DispatchDOMWindowCreated();
73870:   virtual NS_HIDDEN_(void) SetOpenerWindow(nsIDOMWindow* aOpener,
79445:                                            bool aOriginalOpener);
    1:   virtual NS_HIDDEN_(void) EnsureSizeUpToDate();
    1: 
61768:   virtual NS_HIDDEN_(nsIDOMWindow*) EnterModalState();
61768:   virtual NS_HIDDEN_(void) LeaveModalState(nsIDOMWindow* aWindow);
    1: 
79445:   virtual NS_HIDDEN_(bool) CanClose();
37611:   virtual NS_HIDDEN_(nsresult) ForceClose();
37611: 
31738:   virtual NS_HIDDEN_(void) SetHasOrientationEventListener();
79901:   virtual NS_HIDDEN_(void) RemoveOrientationEventListener();
48711:   virtual NS_HIDDEN_(void) MaybeUpdateTouchState();
48711:   virtual NS_HIDDEN_(void) UpdateTouchState();
79445:   virtual NS_HIDDEN_(bool) DispatchCustomEvent(const char *aEventName);
31738: 
73871:   // nsIDOMStorageIndexedDB
73871:   NS_DECL_NSIDOMSTORAGEINDEXEDDB
    1: 
    1:   // nsIInterfaceRequestor
    1:   NS_DECL_NSIINTERFACEREQUESTOR
    1: 
    1:   // Object Management
    1:   nsGlobalWindow(nsGlobalWindow *aOuterWindow);
    1: 
30001:   static nsGlobalWindow *FromSupports(nsISupports *supports)
30001:   {
30001:     // Make sure this matches the casts we do in QueryInterface().
30001:     return (nsGlobalWindow *)(nsIScriptGlobalObject *)supports;
30001:   }
51078:   static nsISupports *ToSupports(nsGlobalWindow *win)
51078:   {
51078:     // Make sure this matches the casts we do in QueryInterface().
51078:     return (nsISupports *)(nsIScriptGlobalObject *)win;
51078:   }
    1:   static nsGlobalWindow *FromWrapper(nsIXPConnectWrappedNative *wrapper)
    1:   {
30001:     return FromSupports(wrapper->Native());
    1:   }
    1: 
54231:   inline nsGlobalWindow *GetTop()
54231:   {
54231:     nsCOMPtr<nsIDOMWindow> top;
54231:     GetTop(getter_AddRefs(top));
54231:     if (top)
54231:       return static_cast<nsGlobalWindow *>(static_cast<nsIDOMWindow *>(top.get()));
54231:     return nsnull;
54231:   }
54231: 
54231:   // Call this when a modal dialog is about to be opened.  Returns
54231:   // true if we've reached the state in this top level window where we
54231:   // ask the user if further dialogs should be blocked.
54231:   bool DialogOpenAttempted();
54231: 
54231:   // Returns true if dialogs have already been blocked for this
54231:   // window.
54231:   bool AreDialogsBlocked();
54231: 
54231:   // Ask the user if further dialogs should be blocked. This is used
54231:   // in the cases where we have no modifiable UI to show, in that case
54231:   // we show a separate dialog when asking this question.
54231:   bool ConfirmDialogAllowed();
54231: 
54231:   // Prevent further dialogs in this (top level) window
54231:   void PreventFurtherDialogs();
54231: 
    1:   nsIScriptContext *GetContextInternal()
    1:   {
    1:     if (mOuterWindow) {
    1:       return GetOuterWindowInternal()->mContext;
    1:     }
    1: 
    1:     return mContext;
    1:   }
    1: 
    1:   nsIScriptContext *GetScriptContextInternal(PRUint32 aLangID)
    1:   {
47537:     NS_ASSERTION(aLangID == nsIProgrammingLanguage::JAVASCRIPT,
47537:                  "We don't support this language ID");
    1:     if (mOuterWindow) {
47537:       return GetOuterWindowInternal()->mContext;
    1:     }
    1: 
47537:     return mContext;
    1:   }
    1: 
    1:   nsGlobalWindow *GetOuterWindowInternal()
    1:   {
 3233:     return static_cast<nsGlobalWindow *>(GetOuterWindow());
    1:   }
    1: 
    1:   nsGlobalWindow *GetCurrentInnerWindowInternal()
    1:   {
 3233:     return static_cast<nsGlobalWindow *>(mInnerWindow);
    1:   }
    1: 
    1:   nsGlobalWindow *EnsureInnerWindowInternal()
    1:   {
 3233:     return static_cast<nsGlobalWindow *>(EnsureInnerWindow());
    1:   }
    1: 
79445:   bool IsCreatingInnerWindow() const
    1:   {
    1:     return  mCreatingInnerWindow;
    1:   }
    1: 
79445:   bool IsChromeWindow() const
 4209:   {
 4209:     return mIsChrome;
 4209:   }
 4209: 
    1:   nsresult Observe(nsISupports* aSubject, const char* aTopic,
    1:                    const PRUnichar* aData);
    1: 
77579:   static void Init();
    1:   static void ShutDown();
11622:   static void CleanupCachedXBLHandlers(nsGlobalWindow* aWindow);
79445:   static bool IsCallerChrome();
    1:   static void CloseBlockScriptTerminationFunc(nsISupports *aRef);
    1: 
    1:   static void RunPendingTimeoutsRecursive(nsGlobalWindow *aTopWindow,
    1:                                           nsGlobalWindow *aWindow);
    1: 
    1:   friend class WindowStateHolder;
    1: 
11622:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsGlobalWindow,
    1:                                                          nsIScriptGlobalObject)
    1: 
 6774:   void InitJavaProperties();
 6774: 
11622:   virtual NS_HIDDEN_(void*)
11622:     GetCachedXBLPrototypeHandler(nsXBLPrototypeHandler* aKey);
11622: 
11622:   virtual NS_HIDDEN_(void)
11622:     CacheXBLPrototypeHandler(nsXBLPrototypeHandler* aKey,
11622:                              nsScriptObjectHolder& aHandler);
11622: 
79445:   virtual bool TakeFocus(bool aFocus, PRUint32 aFocusMethod);
29018:   virtual void SetReadyForFocus();
29018:   virtual void PageHidden();
68729:   virtual nsresult DispatchAsyncHashchange(nsIURI *aOldURI, nsIURI *aNewURI);
63195:   virtual nsresult DispatchSyncPopState();
37802: 
33525:   virtual nsresult SetArguments(nsIArray *aArguments, nsIPrincipal *aOrigin);
29018: 
79445:   static bool DOMWindowDumpEnabled();
11622: 
39378:   void MaybeForgiveSpamCount();
79445:   bool IsClosedOrClosing() {
39378:     return (mIsClosed ||
39378:             mInClose ||
39378:             mHavePendingClose ||
39378:             mCleanedUp);
39378:   }
39378: 
51581:   static void FirePopupBlockedEvent(nsIDOMDocument* aDoc,
51581:                                     nsIDOMWindow *aRequestingWindow, nsIURI *aPopupURI,
51581:                                     const nsAString &aPopupWindowName,
51581:                                     const nsAString &aPopupWindowFeatures);
51581: 
52336:   virtual PRUint32 GetSerial() {
52336:     return mSerial;
52336:   }
52336: 
56274:   static nsGlobalWindow* GetOuterWindowWithId(PRUint64 aWindowID) {
77919:     if (!sWindowsById) {
77919:       return nsnull;
77919:     }
77919: 
72691:     nsGlobalWindow* outerWindow = sWindowsById->Get(aWindowID);
72691:     return outerWindow && !outerWindow->IsInnerWindow() ? outerWindow : nsnull;
56274:   }
56274: 
77330:   static nsGlobalWindow* GetInnerWindowWithId(PRUint64 aInnerWindowID) {
77806:     if (!sWindowsById) {
77806:       return nsnull;
77806:     }
77806: 
77330:     nsGlobalWindow* innerWindow = sWindowsById->Get(aInnerWindowID);
77330:     return innerWindow && innerWindow->IsInnerWindow() ? innerWindow : nsnull;
77330:   }
77330: 
70840:   static bool HasIndexedDBSupport();
60385: 
72298:   static bool HasPerformanceSupport();
72298: 
72692:   static WindowByIdTable* GetWindowsTable() {
72692:     return sWindowsById;
72692:   }
72692: 
75136:   PRInt64 SizeOf() const;
72692: 
59871: private:
59871:   // Enable updates for the accelerometer.
72018:   void EnableDeviceMotionUpdates();
59871: 
59871:   // Disables updates for the accelerometer.
72018:   void DisableDeviceMotionUpdates();
59871: 
    1: protected:
68729:   friend class HashchangeCallback;
69041:   friend class nsBarProp;
68729: 
    1:   // Object Management
    1:   virtual ~nsGlobalWindow();
79445:   void CleanUp(bool aIgnoreModalDialog);
    1:   void ClearControllers();
61409:   static void TryClearWindowScope(nsISupports* aWindow);
61409:   void ClearScopeWhenAllScriptsStop();
37611:   nsresult FinalClose();
    1: 
79445:   void FreeInnerObjects(bool aClearScope);
11028:   nsGlobalWindow *CallerInnerWindow();
    1: 
39402:   nsresult InnerSetNewDocument(nsIDocument* aDocument);
39376: 
33525:   nsresult DefineArgumentsProperty(nsIArray *aArguments);
    1: 
    1:   // Get the parent, returns null if this is a toplevel window
73870:   nsIDOMWindow* GetParentInternal();
    1: 
    1:   // popup tracking
79445:   bool IsPopupSpamWindow()
    1:   {
    1:     if (IsInnerWindow() && !mOuterWindow) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     return GetOuterWindowInternal()->mIsPopupSpam;
    1:   }
    1: 
79445:   void SetPopupSpamWindow(bool aPopup)
    1:   {
    1:     if (IsInnerWindow() && !mOuterWindow) {
    1:       NS_ERROR("SetPopupSpamWindow() called on inner window w/o an outer!");
    1: 
    1:       return;
    1:     }
    1: 
    1:     GetOuterWindowInternal()->mIsPopupSpam = aPopup;
    1:   }
    1: 
    1:   // Window Control Functions
    1:   /**
    1:    * @param aURL the URL to load in the new window
    1:    * @param aName the name to use for the new window
    1:    * @param aOptions the window options to use for the new window
    1:    * @param aDialog true when called from variants of OpenDialog.  If this is
    1:    *                true, this method will skip popup blocking checks.  The
    1:    *                aDialog argument is passed on to the window watcher.
    1:    * @param aCalledNoScript true when called via the [noscript] open()
    1:    *                        and openDialog() methods.  When this is true, we do
    1:    *                        NOT want to use the JS stack for things like caller
    1:    *                        determination.
    1:    * @param aDoJSFixups true when this is the content-accessible JS version of
    1:    *                    window opening.  When true, popups do not cause us to
    1:    *                    throw, we save the caller's principal in the new window
    1:    *                    for later consumption, and we make sure that there is a
    1:    *                    document in the newly-opened window.  Note that this
    1:    *                    last will only be done if the newly-opened window is
    1:    *                    non-chrome.
    1:    * @param argv The arguments to pass to the new window.  The first
    1:    *             three args, if present, will be aURL, aName, and aOptions.  So
    1:    *             this param only matters if there are more than 3 arguments.
    1:    * @param argc The number of arguments in argv.
    1:    * @param aExtraArgument Another way to pass arguments in.  This is mutually
    1:    *                       exclusive with the argv/argc approach.
    1:    * @param aJSCallerContext The calling script's context. This must be nsnull
    1:    *                         when aCalledNoScript is true.
    1:    * @param aReturn [out] The window that was opened, if any.
    1:    *
    1:    * @note that the boolean args are const because the function shouldn't be
    1:    * messing with them.  That also makes it easier for the compiler to sort out
    1:    * its build warning stuff.
    1:    */
    1:   NS_HIDDEN_(nsresult) OpenInternal(const nsAString& aUrl,
    1:                                     const nsAString& aName,
    1:                                     const nsAString& aOptions,
79445:                                     bool aDialog,
79445:                                     bool aContentModal,
79445:                                     bool aCalledNoScript,
79445:                                     bool aDoJSFixups,
    1:                                     nsIArray *argv,
    1:                                     nsISupports *aExtraArgument,
    1:                                     nsIPrincipal *aCalleePrincipal,
    1:                                     JSContext *aJSCallerContext,
    1:                                     nsIDOMWindow **aReturn);
    1: 
    1:   static void CloseWindow(nsISupports* aWindow);
    1:   static void ClearWindowScope(nsISupports* aWindow);
    1: 
    1:   // Timeout Functions
48032:   // Language agnostic timeout function (all args passed).
48032:   // |interval| is in milliseconds.
    1:   nsresult SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
    1:                                 PRInt32 interval,
79445:                                 bool aIsInterval, PRInt32 *aReturn);
    1:   nsresult ClearTimeoutOrInterval(PRInt32 aTimerID);
    1: 
    1:   // JS specific timeout functions (JS args grabbed from context).
79445:   nsresult SetTimeoutOrInterval(bool aIsInterval, PRInt32* aReturn);
    1:   nsresult ClearTimeoutOrInterval();
72734:   nsresult ResetTimersForNonBackgroundWindow();
    1: 
    1:   // The timeout implementation functions.
    1:   void RunTimeout(nsTimeout *aTimeout);
39752:   void RunTimeout() { RunTimeout(nsnull); }
    1: 
    1:   void ClearAllTimeouts();
    1:   // Insert aTimeout into the list, before all timeouts that would
    1:   // fire after it, but no earlier than mTimeoutInsertionPoint, if any.
    1:   void InsertTimeoutIntoList(nsTimeout *aTimeout);
    1:   static void TimerCallback(nsITimer *aTimer, void *aClosure);
    1: 
    1:   // Helper Functions
    1:   nsresult GetTreeOwner(nsIDocShellTreeOwner** aTreeOwner);
    1:   nsresult GetTreeOwner(nsIBaseWindow** aTreeOwner);
    1:   nsresult GetWebBrowserChrome(nsIWebBrowserChrome** aBrowserChrome);
37063:   // GetScrollFrame does not flush.  Callers should do it themselves as needed,
37063:   // depending on which info they actually want off the scrollable frame.
37063:   nsIScrollableFrame *GetScrollFrame();
    1:   nsresult SecurityCheckURL(const char *aURL);
    1:   nsresult BuildURIfromBase(const char *aURL,
    1:                             nsIURI **aBuiltURI,
79445:                             bool *aFreeSecurityPass, JSContext **aCXused);
79445:   bool PopupWhitelisted();
34524:   PopupControlState RevisePopupAbuseLevel(PopupControlState);
79445:   void     FireAbuseEvents(bool aBlocked, bool aWindow,
    1:                            const nsAString &aPopupURL,
    1:                            const nsAString &aPopupWindowName,
    1:                            const nsAString &aPopupWindowFeatures);
    1:   void FireOfflineStatusEvent();
68729:   nsresult FireHashchange(const nsAString &aOldURL, const nsAString &aNewURL);
    1: 
    1:   void FlushPendingNotifications(mozFlushType aType);
    1:   void EnsureReflowFlushAndPaint();
    1:   nsresult CheckSecurityWidthAndHeight(PRInt32* width, PRInt32* height);
    1:   nsresult CheckSecurityLeftAndTop(PRInt32* left, PRInt32* top);
59572: 
59572:   // Arguments to this function should have values in app units
59572:   nsresult SetCSSViewportWidthAndHeight(nscoord width, nscoord height);
59572:   // Arguments to this function should have values in device pixels
59572:   nsresult SetDocShellWidthAndHeight(PRInt32 width, PRInt32 height);
59572: 
79445:   static bool CanSetProperty(const char *aPrefName);
    1: 
    1:   static void MakeScriptDialogTitle(nsAString &aOutTitle);
    1: 
79445:   bool CanMoveResizeWindows();
13308: 
79445:   bool     GetBlurSuppression();
    1: 
    1:   // If aDoFlush is true, we'll flush our own layout; otherwise we'll try to
    1:   // just flush our parent and only flush ourselves if we think we need to.
    1:   nsresult GetScrollXY(PRInt32* aScrollX, PRInt32* aScrollY,
79445:                        bool aDoFlush);
    1:   nsresult GetScrollMaxXY(PRInt32* aScrollMaxX, PRInt32* aScrollMaxY);
    1:   
13806:   nsresult GetOuterSize(nsIntSize* aSizeCSSPixels);
79445:   nsresult SetOuterSize(PRInt32 aLengthCSSPixels, bool aIsWidth);
30882:   nsRect GetInnerScreenRect();
13806: 
79445:   bool IsFrame()
    1:   {
    1:     return GetParentInternal() != nsnull;
    1:   }
    1: 
    1:   // If aLookForCallerOnJSStack is true, this method will look at the JS stack
    1:   // to determine who the caller is.  If it's false, it'll use |this| as the
    1:   // caller.
79445:   bool WindowExists(const nsAString& aName, bool aLookForCallerOnJSStack);
    1: 
    1:   already_AddRefed<nsIWidget> GetMainWidget();
30327:   nsIWidget* GetNearestWidget();
    1: 
    1:   void Freeze()
    1:   {
    1:     NS_ASSERTION(!IsFrozen(), "Double-freezing?");
    1:     mIsFrozen = PR_TRUE;
70324:     NotifyDOMWindowFrozen(this);
    1:   }
    1: 
    1:   void Thaw()
    1:   {
    1:     mIsFrozen = PR_FALSE;
70324:     NotifyDOMWindowThawed(this);
    1:   }
    1: 
79445:   bool IsInModalState();
    1: 
    1:   nsTimeout* FirstTimeout() {
    1:     // Note: might not actually return an nsTimeout.  Use IsTimeout to check.
 3233:     return static_cast<nsTimeout*>(PR_LIST_HEAD(&mTimeouts));
    1:   }
    1: 
    1:   nsTimeout* LastTimeout() {
    1:     // Note: might not actually return an nsTimeout.  Use IsTimeout to check.
 3233:     return static_cast<nsTimeout*>(PR_LIST_TAIL(&mTimeouts));
    1:   }
    1: 
79445:   bool IsTimeout(PRCList* aList) {
    1:     return aList != &mTimeouts;
    1:   }
    1: 
24816:   // Convenience functions for the many methods that need to scale
24816:   // from device to CSS pixels or vice versa.  Note: if a presentation
24816:   // context is not available, they will assume a 1:1 ratio.
24816:   PRInt32 DevToCSSIntPixels(PRInt32 px);
24816:   PRInt32 CSSToDevIntPixels(PRInt32 px);
24816:   nsIntSize DevToCSSIntPixels(nsIntSize px);
24816:   nsIntSize CSSToDevIntPixels(nsIntSize px);
24816: 
29018:   virtual void SetFocusedNode(nsIContent* aNode,
29018:                               PRUint32 aFocusMethod = 0,
79445:                               bool aNeedsFocus = false);
29018: 
29018:   virtual PRUint32 GetFocusMethod();
29018: 
79445:   virtual bool ShouldShowFocusRing();
41071: 
41071:   virtual void SetKeyboardIndicators(UIStateChangeType aShowAccelerators,
41071:                                      UIStateChangeType aShowFocusRings);
79445:   virtual void GetKeyboardIndicators(bool* aShowAccelerators,
79445:                                      bool* aShowFocusRings);
41071: 
79445:   void UpdateCanvasFocus(bool aFocusChanged, nsIContent* aNewContent);
29018: 
38336:   already_AddRefed<nsPIWindowRoot> GetTopWindowRoot();
38336: 
11693:   static void NotifyDOMWindowDestroyed(nsGlobalWindow* aWindow);
42340:   void NotifyWindowIDDestroyed(const char* aTopic);
11693: 
70324:   static void NotifyDOMWindowFrozen(nsGlobalWindow* aWindow);
70324:   static void NotifyDOMWindowThawed(nsGlobalWindow* aWindow);
70324:   
42996:   void ClearStatus();
42996: 
43680:   virtual void UpdateParentTarget();
43680: 
79445:   bool GetIsTabModalPromptAllowed();
62677: 
63938:   inline PRInt32 DOMMinTimeoutValue() const;
63938: 
    1:   // When adding new member variables, be careful not to create cycles
    1:   // through JavaScript.  If there is any chance that a member variable
    1:   // could own objects that are implemented in JavaScript, then those
    1:   // objects will keep the global object (this object) alive.  To prevent
    1:   // these cycles, ownership of such members must be released in
    1:   // |CleanUp| and |SetDocShell|.
    1: 
    1:   // This member is also used on both inner and outer windows, but
    1:   // for slightly different purposes. On inner windows it means the
    1:   // inner window is held onto by session history and should not
    1:   // change. On outer windows it means that the window is in a state
    1:   // where we don't want to force creation of a new inner window since
    1:   // we're in the middle of doing just that.
79445:   bool                          mIsFrozen : 1;
    1: 
 6774:   // True if the Java properties have been initialized on this
 6774:   // window. Only used on inner windows.
79445:   bool                          mDidInitJavaProperties : 1;
 6774:   
    1:   // These members are only used on outer window objects. Make sure
    1:   // you never set any of these on an inner object!
79445:   bool                          mFullScreen : 1;
79445:   bool                          mIsClosed : 1;
79445:   bool                          mInClose : 1;
    1:   // mHavePendingClose means we've got a termination function set to
    1:   // close us when the JS stops executing or that we have a close
    1:   // event posted.  If this is set, just ignore window.close() calls.
79445:   bool                          mHavePendingClose : 1;
79445:   bool                          mHadOriginalOpener : 1;
79445:   bool                          mIsPopupSpam : 1;
    1: 
    1:   // Indicates whether scripts are allowed to close this window.
79445:   bool                          mBlockScriptedClosingFlag : 1;
    1: 
    1:   // Track what sorts of events we need to fire when thawed
79445:   bool                          mFireOfflineStatusChangeEventOnThaw : 1;
    1: 
    1:   // Indicates whether we're in the middle of creating an initializing
    1:   // a new inner window object.
79445:   bool                          mCreatingInnerWindow : 1;
    1: 
 4209:   // Fast way to tell if this is a chrome window (without having to QI).
79445:   bool                          mIsChrome : 1;
 4209: 
61147:   // Hack to indicate whether a chrome window needs its message manager
61147:   // to be disconnected, since clean up code is shared in the global
61147:   // window superclass.
79445:   bool                          mCleanMessageManager : 1;
61147: 
29018:   // Indicates that the current document has never received a document focus
29018:   // event.
79445:   bool                   mNeedsFocus : 1;
79445:   bool                   mHasFocus : 1;
29018: 
41071:   // whether to show keyboard accelerators
79445:   bool                   mShowAccelerators : 1;
41071: 
41071:   // whether to show focus rings
79445:   bool                   mShowFocusRings : 1;
41071: 
41071:   // when true, show focus rings for the current focused content only.
41071:   // This will be reset when another element is focused
79445:   bool                   mShowFocusRingForContent : 1;
41071: 
42263:   // true if tab navigation has occurred for this window. Focus rings
41071:   // should be displayed.
79445:   bool                   mFocusByKeyOccurred : 1;
41071: 
72018:   // Indicates whether this window is getting device motion change events
79445:   bool                   mHasDeviceMotion : 1;
31738: 
42340:   // whether we've sent the destroy notification for our window id
79445:   bool                   mNotifiedIDDestroyed : 1;
42340: 
    1:   nsCOMPtr<nsIScriptContext>    mContext;
11416:   nsWeakPtr                     mOpener;
    1:   nsCOMPtr<nsIControllers>      mControllers;
    1:   nsCOMPtr<nsIArray>            mArguments;
    1:   nsCOMPtr<nsIArray>            mArgumentsLast;
33525:   nsCOMPtr<nsIPrincipal>        mArgumentsOrigin;
    1:   nsRefPtr<nsNavigator>         mNavigator;
    1:   nsRefPtr<nsScreen>            mScreen;
72298:   nsRefPtr<nsPerformance>       mPerformance;
    1:   nsRefPtr<nsDOMWindowList>     mFrames;
    1:   nsRefPtr<nsBarProp>           mMenubar;
    1:   nsRefPtr<nsBarProp>           mToolbar;
    1:   nsRefPtr<nsBarProp>           mLocationbar;
    1:   nsRefPtr<nsBarProp>           mPersonalbar;
    1:   nsRefPtr<nsBarProp>           mStatusbar;
    1:   nsRefPtr<nsBarProp>           mScrollbars;
    1:   nsCOMPtr<nsIWeakReference>    mWindowUtils;
    1:   nsString                      mStatus;
    1:   nsString                      mDefaultStatus;
    1:   // index 0->language_id 1, so index MAX-1 == language_id MAX
    1:   nsGlobalWindowObserver*       mObserver;
54925: #ifndef MOZ_DISABLE_DOMCRYPTO
    1:   nsCOMPtr<nsIDOMCrypto>        mCrypto;
54925: #endif
28438:   nsCOMPtr<nsIDOMStorage>      mLocalStorage;
37608:   nsCOMPtr<nsIDOMStorage>      mSessionStorage;
26323: 
47537:   nsCOMPtr<nsIXPConnectJSObjectHolder> mInnerWindowHolder;
    1:   nsCOMPtr<nsIPrincipal> mOpenerScriptPrincipal; // strong; used to determine
    1:                                                  // whether to clear scope
    1: 
    1:   // These member variable are used only on inner windows.
72328:   nsRefPtr<nsEventListenerManager> mListenerManager;
73617:   // mTimeouts is generally sorted by mWhen, unless mTimeoutInsertionPoint is
73617:   // non-null.  In that case, the dummy timeout pointed to by
73617:   // mTimeoutInsertionPoint may have a later mWhen than some of the timeouts
73617:   // that come after it.
    1:   PRCList                       mTimeouts;
    1:   // If mTimeoutInsertionPoint is non-null, insertions should happen after it.
73617:   // This is a dummy timeout at the moment; if that ever changes, the logic in
73617:   // ResetTimersForNonBackgroundWindow needs to change.
    1:   nsTimeout*                    mTimeoutInsertionPoint;
    1:   PRUint32                      mTimeoutPublicIdCounter;
    1:   PRUint32                      mTimeoutFiringDepth;
50477:   nsRefPtr<nsLocation>          mLocation;
61735:   nsRefPtr<nsHistory>           mHistory;
    1: 
15819:   // Holder of the dummy java plugin, used to expose window.java and
15819:   // window.packages.
 6774:   nsRefPtr<nsDummyJavaPluginOwner> mDummyJavaPluginOwner;
 6774: 
    1:   // These member variables are used on both inner and the outer windows.
    1:   nsCOMPtr<nsIPrincipal> mDocumentPrincipal;
    1:   nsCOMPtr<nsIDocument> mDoc;  // For fast access to principals
    1:   JSObject* mJSObject;
    1: 
60680:   typedef nsCOMArray<nsIDOMStorageEvent> nsDOMStorageEventArray;
37608:   nsDOMStorageEventArray mPendingStorageEvents;
79445:   nsAutoPtr< nsDataHashtable<nsStringHashKey, bool> > mPendingStorageEventsObsolete;
    1: 
25074:   PRUint32 mTimeoutsSuspendDepth;
25074: 
29018:   // the method that was used to focus mFocusedNode
29018:   PRUint32 mFocusMethod;
29018: 
52336:   PRUint32 mSerial;
52336: 
    1: #ifdef DEBUG
79445:   bool mSetOpenerWindowCalled;
14743:   nsCOMPtr<nsIURI> mLastOpenedURI;
    1: #endif
    1: 
79445:   bool mCleanedUp, mCallCleanUpAfterModalDialogCloses;
39378: 
10340:   nsCOMPtr<nsIDOMOfflineResourceList> mApplicationCache;
10340: 
11622:   nsDataHashtable<nsVoidPtrHashKey, void*> mCachedXBLPrototypeHandlers;
11622: 
25722:   nsCOMPtr<nsIDocument> mSuspendedDoc;
25722: 
46347:   nsCOMPtr<nsIIDBFactory> mIndexedDB;
44204: 
54231:   // In the case of a "trusted" dialog (@see PopupControlState), we
54231:   // set this counter to ensure a max of MAX_DIALOG_LIMIT
54231:   PRUint32                      mDialogAbuseCount;
54231: 
54231:   // This holds the time when the last modal dialog was shown, if two
54231:   // dialogs are shown within CONCURRENT_DIALOG_TIME_LIMIT the
54231:   // checkbox is shown. In the case of ShowModalDialog another Confirm
54231:   // dialog will be shown, the result of the checkbox/confirm dialog
54231:   // will be stored in mDialogDisabled variable.
54231:   TimeStamp                     mLastDialogQuitTime;
79445:   bool                          mDialogDisabled;
54231: 
58023:   nsRefPtr<nsDOMMozURLProperty> mURLProperty;
58023: 
    1:   friend class nsDOMScriptableHelper;
    1:   friend class nsDOMWindowUtils;
14898:   friend class PostMessageEvent;
22689:   static nsIDOMStorageList* sGlobalStorageList;
56274: 
72691:   static WindowByIdTable* sWindowsById;
76293:   static bool sWarnedAboutWindowInternal;
    1: };
    1: 
    1: /*
    1:  * nsGlobalChromeWindow inherits from nsGlobalWindow. It is the global
    1:  * object created for a Chrome Window only.
    1:  */
    1: class nsGlobalChromeWindow : public nsGlobalWindow,
    1:                              public nsIDOMChromeWindow
    1: {
    1: public:
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIDOMChromeWindow interface
    1:   NS_DECL_NSIDOMCHROMEWINDOW
    1: 
    1:   nsGlobalChromeWindow(nsGlobalWindow *aOuterWindow)
    1:     : nsGlobalWindow(aOuterWindow)
    1:   {
 4209:     mIsChrome = PR_TRUE;
61147:     mCleanMessageManager = PR_TRUE;
61147:   }
61147: 
61147:   ~nsGlobalChromeWindow()
61147:   {
61147:     NS_ABORT_IF_FALSE(mCleanMessageManager,
61147:                       "chrome windows may always disconnect the msg manager");
61147:     if (mMessageManager) {
61147:       static_cast<nsFrameMessageManager *>(
61147:         mMessageManager.get())->Disconnect();
61147:     }
61147: 
61147:     mCleanMessageManager = PR_FALSE;
    1:   }
    1: 
72139:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsGlobalChromeWindow,
    1:                                            nsGlobalWindow)
    1: 
    1:   nsCOMPtr<nsIBrowserDOMWindow> mBrowserDOMWindow;
42412:   nsCOMPtr<nsIChromeFrameMessageManager> mMessageManager;
    1: };
    1: 
 4040: /*
 4040:  * nsGlobalModalWindow inherits from nsGlobalWindow. It is the global
 4040:  * object created for a modal content windows only (i.e. not modal
 4040:  * chrome dialogs).
 4040:  */
 4040: class nsGlobalModalWindow : public nsGlobalWindow,
 4040:                             public nsIDOMModalContentWindow
 4040: {
 4040: public:
 4040:   nsGlobalModalWindow(nsGlobalWindow *aOuterWindow)
 4040:     : nsGlobalWindow(aOuterWindow)
 4040:   {
 4040:     mIsModalContentWindow = PR_TRUE;
 4040:   }
 4040: 
 4040:   NS_DECL_ISUPPORTS_INHERITED
 4040:   NS_DECL_NSIDOMMODALCONTENTWINDOW
 4040: 
 4040:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsGlobalModalWindow, nsGlobalWindow)
 4040: 
33525:   virtual NS_HIDDEN_(nsresult) SetNewDocument(nsIDocument *aDocument,
53996:                                               nsISupports *aState,
79445:                                               bool aForceReuseInnerWindow);
33525: 
 4040: protected:
 4040:   nsCOMPtr<nsIVariant> mReturnValue;
 4040: };
 4040: 
 4040: 
    1: //*****************************************************************************
    1: // nsNavigator: Script "navigator" object
    1: //*****************************************************************************
    1: 
    1: class nsNavigator : public nsIDOMNavigator,
15958:                     public nsIDOMClientInformation,
52355:                     public nsIDOMNavigatorGeolocation,
52355:                     public nsIDOMNavigatorDesktopNotification
    1: {
    1: public:
    1:   nsNavigator(nsIDocShell *aDocShell);
    1:   virtual ~nsNavigator();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSIDOMNAVIGATOR
    1:   NS_DECL_NSIDOMCLIENTINFORMATION
16677:   NS_DECL_NSIDOMNAVIGATORGEOLOCATION
52355:   NS_DECL_NSIDOMNAVIGATORDESKTOPNOTIFICATION
    1:   
    1:   void SetDocShell(nsIDocShell *aDocShell);
    1:   nsIDocShell *GetDocShell()
    1:   {
    1:     return mDocShell;
    1:   }
    1: 
    1:   void LoadingNewDocument();
    1:   nsresult RefreshMIMEArray();
    1: 
59810:   static bool HasDesktopNotificationSupport();
59810: 
75136:   PRInt64 SizeOf() const;
75136: 
    1: protected:
    1:   nsRefPtr<nsMimeTypeArray> mMimeTypes;
    1:   nsRefPtr<nsPluginArray> mPlugins;
16677:   nsRefPtr<nsGeolocation> mGeolocation;
56333:   nsRefPtr<nsDesktopNotificationCenter> mNotification;
    1:   nsIDocShell* mDocShell; // weak reference
    1: };
    1: 
60104: nsresult NS_GetNavigatorUserAgent(nsAString& aUserAgent);
60104: nsresult NS_GetNavigatorPlatform(nsAString& aPlatform);
60104: nsresult NS_GetNavigatorAppVersion(nsAString& aAppVersion);
60104: nsresult NS_GetNavigatorAppName(nsAString& aAppName);
60104: 
    1: /* factory function */
 4040: nsresult
79445: NS_NewScriptGlobalObject(bool aIsChrome, bool aIsModalContentWindow,
    1:                          nsIScriptGlobalObject **aResult);
    1: 
    1: #endif /* nsGlobalWindow_h___ */
