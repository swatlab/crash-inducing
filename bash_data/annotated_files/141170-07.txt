  5210: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "prmem.h"
     1: #include "prerror.h"
     1: #include "prprf.h"
     1: 
     1: #include "nsNSSComponent.h" // for PIPNSS string bundle calls.
  6479: #include "nsNSSCleaner.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsIMutableArray.h"
140656: #include "nsNSSCertificate.h"
     1: #include "nsNSSCertValidity.h"
     1: #include "nsPKCS12Blob.h"
     1: #include "nsPK11TokenDB.h"
     1: #include "nsIX509Cert.h"
     1: #include "nsIX509Cert3.h"
     1: #include "nsISMimeCert.h"
     1: #include "nsNSSASN1Object.h"
     1: #include "nsString.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsIURI.h"
     1: #include "nsCRT.h"
     1: #include "nsUsageArrayHelper.h"
     1: #include "nsICertificateDialogs.h"
     1: #include "nsNSSCertHelper.h"
     1: #include "nsISupportsPrimitives.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsCertVerificationThread.h"
  5210: #include "nsIObjectOutputStream.h"
  5210: #include "nsIObjectInputStream.h"
  5210: #include "nsIProgrammingLanguage.h"
 56495: #include "nsXULAppAPI.h"
124992: #include "ScopedNSSTypes.h"
 56495: 
     1: #include "nspr.h"
     1: #include "certdb.h"
     1: #include "secerr.h"
     1: #include "nssb64.h"
     1: #include "secasn1.h"
     1: #include "secder.h"
     1: #include "ssl.h"
     1: #include "ocsp.h"
     1: #include "plbase64.h"
     1: 
119899: using namespace mozilla;
119899: 
     1: #ifdef PR_LOGGING
     1: extern PRLogModuleInfo* gPIPNSSLog;
     1: #endif
     1: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
 80486: NSSCleanupAutoPtrClass_WithParam(PLArenaPool, PORT_FreeArena, FalseParam, false)
  6479: 
108991: // This is being stored in an uint32_t that can otherwise
     1: // only take values from nsIX509Cert's list of cert types.
     1: // As nsIX509Cert is frozen, we choose a value not contained
     1: // in the list to mean not yet initialized.
     1: #define CERT_TYPE_NOT_YET_INITIALIZED (1 << 30)
     1: 
     1: /* nsNSSCertificate */
     1: 
  8416: NS_IMPL_THREADSAFE_ISUPPORTS7(nsNSSCertificate, nsIX509Cert,
     1:                                                 nsIX509Cert2,
     1:                                                 nsIX509Cert3,
  7105:                                                 nsIIdentityInfo,
  8416:                                                 nsISMimeCert,
  8416:                                                 nsISerializable,
  8416:                                                 nsIClassInfo)
     1: 
 56495: /* static */
 56495: nsNSSCertificate*
140656: nsNSSCertificate::Create(CERTCertificate *cert)
 56495: {
 56495:   if (GeckoProcessType_Default != XRE_GetProcessType()) {
 56495:     NS_ERROR("Trying to initialize nsNSSCertificate in a non-chrome process!");
106838:     return nullptr;
 56495:   }
 56495:   if (cert)
140656:     return new nsNSSCertificate(cert);
 56495:   else
 56495:     return new nsNSSCertificate();
 56495: }
 56495: 
     1: nsNSSCertificate*
     1: nsNSSCertificate::ConstructFromDER(char *certDER, int derLen)
     1: {
 56495:   // On non-chrome process prevent instantiation
 56495:   if (GeckoProcessType_Default != XRE_GetProcessType())
106838:     return nullptr;
 56495: 
 56495:   nsNSSCertificate* newObject = nsNSSCertificate::Create();
 56495:   if (newObject && !newObject->InitFromDER(certDER, derLen)) {
  5210:     delete newObject;
106838:     newObject = nullptr;
  5210:   }
  5210: 
  5210:   return newObject;
  5210: }
  5210: 
 79445: bool
  5210: nsNSSCertificate::InitFromDER(char *certDER, int derLen)
  5210: {
     1:   nsNSSShutDownPreventionLock locker;
  5210:   if (isAlreadyShutDown())
 80486:     return false;
     1: 
     1:   if (!certDER || !derLen)
 80486:     return false;
     1: 
     1:   CERTCertificate *aCert = CERT_DecodeCertFromPackage(certDER, derLen);
     1:   
     1:   if (!aCert)
 80486:     return false;
     1: 
119899:   if (!aCert->dbhandle)
     1:   {
     1:     aCert->dbhandle = CERT_GetDefaultCertDB();
     1:   }
     1: 
  5210:   mCert = aCert;
 80486:   return true;
     1: }
     1: 
141170: nsNSSCertificate::nsNSSCertificate(CERTCertificate *cert)
141170:   : mCert(nullptr)
141170:   , mPermDelete(false)
141170:   , mCertType(CERT_TYPE_NOT_YET_INITIALIZED)
141170: #ifndef NSS_NO_LIBPKIX
141170:   , mCachedEVStatus(ev_status_unknown)
141170: #endif
     1: {
 67579: #if defined(DEBUG)
 56495:   if (GeckoProcessType_Default != XRE_GetProcessType())
 56495:     NS_ERROR("Trying to initialize nsNSSCertificate in a non-chrome process!");
 56495: #endif
 56495: 
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
140656:   if (cert) 
     1:     mCert = CERT_DupCertificate(cert);
     1: }
     1: 
141170: nsNSSCertificate::nsNSSCertificate()
141170:   : mCert(nullptr)
141170:   , mPermDelete(false)
141170:   , mCertType(CERT_TYPE_NOT_YET_INITIALIZED)
141170: #ifndef NSS_NO_LIBPKIX
141170:   , mCachedEVStatus(ev_status_unknown)
141170: #endif
  5210: {
 56495:   if (GeckoProcessType_Default != XRE_GetProcessType())
 56495:     NS_ERROR("Trying to initialize nsNSSCertificate in a non-chrome process!");
  5210: }
  5210: 
     1: nsNSSCertificate::~nsNSSCertificate()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   destructorSafeDestroyNSSReference();
     1:   shutdown(calledFromObject);
     1: }
     1: 
     1: void nsNSSCertificate::virtualDestroyNSSReference()
     1: {
     1:   destructorSafeDestroyNSSReference();
     1: }
     1: 
     1: void nsNSSCertificate::destructorSafeDestroyNSSReference()
     1: {
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   if (mPermDelete) {
     1:     if (mCertType == nsNSSCertificate::USER_CERT) {
     1:       nsCOMPtr<nsIInterfaceRequestor> cxt = new PipUIContext();
     1:       PK11_DeleteTokenCertAndKey(mCert, cxt);
     1:     } else if (!PK11_IsReadOnly(mCert->slot)) {
     1:       // If the list of built-ins does contain a non-removable
     1:       // copy of this certificate, our call will not remove
     1:       // the certificate permanently, but rather remove all trust.
     1:       SEC_DeletePermCertificate(mCert);
     1:     }
     1:   }
     1: 
     1:   if (mCert) {
106838:     mCert = nullptr;
     1:   }
     1: }
     1: 
     1: nsresult
108991: nsNSSCertificate::GetCertType(uint32_t *aCertType)
     1: {
     1:   if (mCertType == CERT_TYPE_NOT_YET_INITIALIZED) {
     1:      // only determine cert type once and cache it
     1:      mCertType = getCertType(mCert);
     1:   }
     1:   *aCertType = mCertType;
     1:   return NS_OK;
     1: }
     1: 
  7252: NS_IMETHODIMP
 79445: nsNSSCertificate::GetIsSelfSigned(bool *aIsSelfSigned)
  7252: {
  7252:   NS_ENSURE_ARG(aIsSelfSigned);
  7252: 
  7252:   nsNSSShutDownPreventionLock locker;
  7252:   if (isAlreadyShutDown())
  7252:     return NS_ERROR_NOT_AVAILABLE;
  7252: 
  7252:   *aIsSelfSigned = mCert->isRoot;
  7252:   return NS_OK;
  7252: }
  7252: 
     1: nsresult
     1: nsNSSCertificate::MarkForPermDeletion()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   // make sure user is logged in to the token
     1:   nsCOMPtr<nsIInterfaceRequestor> ctx = new PipUIContext();
     1: 
     1:   if (PK11_NeedLogin(mCert->slot)
     1:       && !PK11_NeedUserInit(mCert->slot)
     1:       && !PK11_IsInternal(mCert->slot))
     1:   {
 80486:     if (SECSuccess != PK11_Authenticate(mCert->slot, true, ctx))
     1:     {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   }
     1: 
 80486:   mPermDelete = true;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: GetKeyUsagesString(CERTCertificate *cert, nsINSSComponent *nssComponent, 
     1:                    nsString &text)
     1: {
     1:   text.Truncate();
     1: 
     1:   SECItem keyUsageItem;
119899:   keyUsageItem.data = nullptr;
     1: 
     1:   SECStatus srv;
     1: 
     1:   /* There is no extension, v1 or v2 certificate */
     1:   if (!cert->extensions)
     1:     return NS_OK;
     1: 
     1: 
     1:   srv = CERT_FindKeyUsageExtension(cert, &keyUsageItem);
     1:   if (srv == SECFailure) {
     1:     if (PORT_GetError () == SEC_ERROR_EXTENSION_NOT_FOUND)
     1:       return NS_OK;
     1:     else
     1:       return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   unsigned char keyUsage = keyUsageItem.data[0];
     1:   nsAutoString local;
     1:   nsresult rv;
     1:   const PRUnichar *comma = NS_LITERAL_STRING(",").get();
     1: 
     1:   if (keyUsage & KU_DIGITAL_SIGNATURE) {
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpKUSign", local);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       if (!text.IsEmpty()) text.Append(comma);
     1:       text.Append(local.get());
     1:     }
     1:   }
     1:   if (keyUsage & KU_NON_REPUDIATION) {
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpKUNonRep", local);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       if (!text.IsEmpty()) text.Append(comma);
     1:       text.Append(local.get());
     1:     }
     1:   }
     1:   if (keyUsage & KU_KEY_ENCIPHERMENT) {
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpKUEnc", local);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       if (!text.IsEmpty()) text.Append(comma);
     1:       text.Append(local.get());
     1:     }
     1:   }
     1:   if (keyUsage & KU_DATA_ENCIPHERMENT) {
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpKUDEnc", local);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       if (!text.IsEmpty()) text.Append(comma);
     1:       text.Append(local.get());
     1:     }
     1:   }
     1:   if (keyUsage & KU_KEY_AGREEMENT) {
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpKUKA", local);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       if (!text.IsEmpty()) text.Append(comma);
     1:       text.Append(local.get());
     1:     }
     1:   }
     1:   if (keyUsage & KU_KEY_CERT_SIGN) {
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpKUCertSign", local);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       if (!text.IsEmpty()) text.Append(comma);
     1:       text.Append(local.get());
     1:     }
     1:   }
     1:   if (keyUsage & KU_CRL_SIGN) {
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpKUCRLSign", local);
     1:     if (NS_SUCCEEDED(rv)) {
     1:       if (!text.IsEmpty()) text.Append(comma);
     1:       text.Append(local.get());
     1:     }
     1:   }
     1: 
     1:   PORT_Free (keyUsageItem.data);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsNSSCertificate::FormatUIStrings(const nsAutoString &nickname, nsAutoString &nickWithSerial, nsAutoString &details)
     1: {
 81303:   if (!NS_IsMainThread()) {
 81303:     NS_ERROR("nsNSSCertificate::FormatUIStrings called off the main thread");
 81303:     return NS_ERROR_NOT_SAME_THREAD;
 81303:   }
 81303:   
     1:   nsresult rv = NS_OK;
     1: 
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1: 
     1:   if (NS_FAILED(rv) || !nssComponent) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   
     1:   nsAutoString info;
     1:   nsAutoString temp1;
     1: 
     1:   nickWithSerial.Append(nickname);
     1: 
     1:   if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertInfoIssuedFor", info))) {
     1:     details.Append(info);
     1:     details.Append(PRUnichar(' '));
 81303:     if (NS_SUCCEEDED(GetSubjectName(temp1)) && !temp1.IsEmpty()) {
     1:       details.Append(temp1);
     1:     }
     1:     details.Append(PRUnichar('\n'));
     1:   }
     1: 
 81303:   if (NS_SUCCEEDED(GetSerialNumber(temp1)) && !temp1.IsEmpty()) {
     1:     details.AppendLiteral("  ");
     1:     if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertDumpSerialNo", info))) {
     1:       details.Append(info);
     1:       details.AppendLiteral(": ");
     1:     }
     1:     details.Append(temp1);
     1: 
     1:     nickWithSerial.AppendLiteral(" [");
     1:     nickWithSerial.Append(temp1);
     1:     nickWithSerial.Append(PRUnichar(']'));
     1: 
     1:     details.Append(PRUnichar('\n'));
     1:   }
     1: 
     1:   nsCOMPtr<nsIX509CertValidity> validity;
 81303:   rv = GetValidity(getter_AddRefs(validity));
 81303:   if (NS_SUCCEEDED(rv) && validity) {
     1:     details.AppendLiteral("  ");
     1:     if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertInfoValid", info))) {
     1:       details.Append(info);
     1:     }
     1: 
     1:     if (NS_SUCCEEDED(validity->GetNotBeforeLocalTime(temp1)) && !temp1.IsEmpty()) {
     1:       details.Append(PRUnichar(' '));
     1:       if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertInfoFrom", info))) {
     1:         details.Append(info);
     1:         details.Append(PRUnichar(' '));
     1:       }
     1:       details.Append(temp1);
     1:     }
     1: 
     1:     if (NS_SUCCEEDED(validity->GetNotAfterLocalTime(temp1)) && !temp1.IsEmpty()) {
     1:       details.Append(PRUnichar(' '));
     1:       if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertInfoTo", info))) {
     1:         details.Append(info);
     1:         details.Append(PRUnichar(' '));
     1:       }
     1:       details.Append(temp1);
     1:     }
     1: 
     1:     details.Append(PRUnichar('\n'));
     1:   }
     1: 
     1:   if (NS_SUCCEEDED(GetKeyUsagesString(mCert, nssComponent, temp1)) && !temp1.IsEmpty()) {
     1:     details.AppendLiteral("  ");
     1:     if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertDumpKeyUsage", info))) {
     1:       details.Append(info);
     1:       details.AppendLiteral(": ");
     1:     }
     1:     details.Append(temp1);
     1:     details.Append(PRUnichar('\n'));
     1:   }
     1: 
  7744:   nsAutoString firstEmail;
  7744:   const char *aWalkAddr;
  7744:   for (aWalkAddr = CERT_GetFirstEmailAddress(mCert)
  7744:         ;
  7744:         aWalkAddr
  7744:         ;
  7744:         aWalkAddr = CERT_GetNextEmailAddress(mCert, aWalkAddr))
  7744:   {
  7744:     NS_ConvertUTF8toUTF16 email(aWalkAddr);
  7744:     if (email.IsEmpty())
  7744:       continue;
  6905: 
  7744:     if (firstEmail.IsEmpty()) {
  6905:       /*
  6905:         * If the first email address from the subject DN is also present
  6905:         * in the subjectAltName extension, GetEmailAddresses() will return
  6905:         * it twice (as received from NSS). Remember the first address so that
  6905:         * we can filter out duplicates later on.
  6905:         */
  7744:       firstEmail = email;
  6905: 
  7744:       details.AppendLiteral("  ");
  7744:       if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertInfoEmail", info))) {
  7744:         details.Append(info);
  7744:         details.AppendLiteral(": ");
  7744:       }
  7744:       details.Append(email);
  7744:     }
  7744:     else {
  7744:       // Append current address if it's different from the first one.
  7744:       if (!firstEmail.Equals(email)) {
  6905:         details.AppendLiteral(", ");
  7744:         details.Append(email);
  6905:       }
  7744:     }
  6905:   }
  6905: 
  7744:   if (!firstEmail.IsEmpty()) {
  7744:     // We got at least one email address, so we want a newline
  6905:     details.Append(PRUnichar('\n'));
  6905:   }
  6905: 
     1:   if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertInfoIssuedBy", info))) {
     1:     details.Append(info);
     1:     details.Append(PRUnichar(' '));
     1: 
 81303:     if (NS_SUCCEEDED(GetIssuerName(temp1)) && !temp1.IsEmpty()) {
     1:       details.Append(temp1);
     1:     }
     1: 
     1:     details.Append(PRUnichar('\n'));
     1:   }
     1: 
     1:   if (NS_SUCCEEDED(nssComponent->GetPIPNSSBundleString("CertInfoStoredIn", info))) {
     1:     details.Append(info);
     1:     details.Append(PRUnichar(' '));
     1: 
 81303:     if (NS_SUCCEEDED(GetTokenName(temp1)) && !temp1.IsEmpty()) {
     1:       details.Append(temp1);
     1:     }
     1:   }
     1: 
     1:   /*
  6905:     the above produces the following output:
     1: 
     1:     Issued to: $subjectName
     1:     Serial number: $serialNumber
     1:     Valid from: $starting_date to $expiration_date
  6905:     Certificate Key usage: $usages
  6905:     Email: $address(es)
     1:     Issued by: $issuerName
     1:     Stored in: $token
     1:   */
     1:   
     1:   return rv;
     1: }
     1: 
     1: 
     1: /* readonly attribute string dbKey; */
     1: NS_IMETHODIMP 
     1: nsNSSCertificate::GetDbKey(char * *aDbKey)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   SECItem key;
     1: 
     1:   NS_ENSURE_ARG(aDbKey);
106838:   *aDbKey = nullptr;
     1:   key.len = NS_NSS_LONG*4+mCert->serialNumber.len+mCert->derIssuer.len;
     1:   key.data = (unsigned char *)nsMemory::Alloc(key.len);
     1:   if (!key.data)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   NS_NSS_PUT_LONG(0,key.data); // later put moduleID
     1:   NS_NSS_PUT_LONG(0,&key.data[NS_NSS_LONG]); // later put slotID
     1:   NS_NSS_PUT_LONG(mCert->serialNumber.len,&key.data[NS_NSS_LONG*2]);
     1:   NS_NSS_PUT_LONG(mCert->derIssuer.len,&key.data[NS_NSS_LONG*3]);
     1:   memcpy(&key.data[NS_NSS_LONG*4], mCert->serialNumber.data,
     1:          mCert->serialNumber.len);
     1:   memcpy(&key.data[NS_NSS_LONG*4+mCert->serialNumber.len],
     1:          mCert->derIssuer.data, mCert->derIssuer.len);
     1:   
106838:   *aDbKey = NSSBase64_EncodeItem(nullptr, nullptr, 0, &key);
     1:   nsMemory::Free(key.data); // SECItem is a 'c' type without a destrutor
     1:   return (*aDbKey) ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
     1: /* readonly attribute string windowTitle; */
     1: NS_IMETHODIMP 
     1: nsNSSCertificate::GetWindowTitle(char * *aWindowTitle)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NS_ENSURE_ARG(aWindowTitle);
     1:   if (mCert) {
     1:     if (mCert->nickname) {
     1:       *aWindowTitle = PL_strdup(mCert->nickname);
     1:     } else {
     1:       *aWindowTitle = CERT_GetCommonName(&mCert->subject);
     1:       if (!*aWindowTitle) {
     1:         if (mCert->subjectName) {
     1:           *aWindowTitle = PL_strdup(mCert->subjectName);
     1:         } else if (mCert->emailAddr) {
     1:           *aWindowTitle = PL_strdup(mCert->emailAddr);
     1:         } else {
     1:           *aWindowTitle = PL_strdup("");
     1:         }
     1:       }
     1:     }
     1:   } else {
106838:     NS_ERROR("Somehow got nullptr for mCertificate in nsNSSCertificate.");
106838:     *aWindowTitle = nullptr;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetNickname(nsAString &aNickname)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   if (mCert->nickname) {
     1:     CopyUTF8toUTF16(mCert->nickname, aNickname);
     1:   } else {
     1:     nsresult rv;
     1:     nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:     if (NS_FAILED(rv) || !nssComponent) {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:     nssComponent->GetPIPNSSBundleString("CertNoNickname", aNickname);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetEmailAddress(nsAString &aEmailAddress)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   if (mCert->emailAddr) {
     1:     CopyUTF8toUTF16(mCert->emailAddr, aEmailAddress);
     1:   } else {
     1:     nsresult rv;
     1:     nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:     if (NS_FAILED(rv) || !nssComponent) {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:     nssComponent->GetPIPNSSBundleString("CertNoEmailAddress", aEmailAddress);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsNSSCertificate::GetEmailAddresses(uint32_t *aLength, PRUnichar*** aAddresses)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NS_ENSURE_ARG(aLength);
     1:   NS_ENSURE_ARG(aAddresses);
     1: 
     1:   *aLength = 0;
     1: 
     1:   const char *aAddr;
     1:   for (aAddr = CERT_GetFirstEmailAddress(mCert)
     1:        ;
     1:        aAddr
     1:        ;
     1:        aAddr = CERT_GetNextEmailAddress(mCert, aAddr))
     1:   {
     1:     ++(*aLength);
     1:   }
     1: 
     1:   *aAddresses = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * (*aLength));
     1:   if (!*aAddresses)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
108991:   uint32_t iAddr;
     1:   for (aAddr = CERT_GetFirstEmailAddress(mCert), iAddr = 0
     1:        ;
     1:        aAddr
     1:        ;
     1:        aAddr = CERT_GetNextEmailAddress(mCert, aAddr), ++iAddr)
     1:   {
     1:     (*aAddresses)[iAddr] = ToNewUnicode(NS_ConvertUTF8toUTF16(aAddr));
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsNSSCertificate::ContainsEmailAddress(const nsAString &aEmailAddress, bool *result)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NS_ENSURE_ARG(result);
 80486:   *result = false;
     1: 
106838:   const char *aAddr = nullptr;
     1:   for (aAddr = CERT_GetFirstEmailAddress(mCert)
     1:        ;
     1:        aAddr
     1:        ;
     1:        aAddr = CERT_GetNextEmailAddress(mCert, aAddr))
     1:   {
     1:     NS_ConvertUTF8toUTF16 certAddr(aAddr);
     1:     ToLowerCase(certAddr);
     1: 
     1:     nsAutoString testAddr(aEmailAddress);
     1:     ToLowerCase(testAddr);
     1:     
     1:     if (certAddr == testAddr)
     1:     {
 80486:       *result = true;
     1:       break;
     1:     }
     1: 
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetCommonName(nsAString &aCommonName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   aCommonName.Truncate();
     1:   if (mCert) {
     1:     char *commonName = CERT_GetCommonName(&mCert->subject);
     1:     if (commonName) {
     1:       aCommonName = NS_ConvertUTF8toUTF16(commonName);
     1:       PORT_Free(commonName);
     1:     } /*else {
     1:       *aCommonName = ToNewUnicode(NS_LITERAL_STRING("<not set>")), 
     1:     }*/
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetOrganization(nsAString &aOrganization)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   aOrganization.Truncate();
     1:   if (mCert) {
     1:     char *organization = CERT_GetOrgName(&mCert->subject);
     1:     if (organization) {
     1:       aOrganization = NS_ConvertUTF8toUTF16(organization);
     1:       PORT_Free(organization);
     1:     } /*else {
     1:       *aOrganization = ToNewUnicode(NS_LITERAL_STRING("<not set>")), 
     1:     }*/
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetIssuerCommonName(nsAString &aCommonName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   aCommonName.Truncate();
     1:   if (mCert) {
     1:     char *commonName = CERT_GetCommonName(&mCert->issuer);
     1:     if (commonName) {
     1:       aCommonName = NS_ConvertUTF8toUTF16(commonName);
     1:       PORT_Free(commonName);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetIssuerOrganization(nsAString &aOrganization)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   aOrganization.Truncate();
     1:   if (mCert) {
     1:     char *organization = CERT_GetOrgName(&mCert->issuer);
     1:     if (organization) {
     1:       aOrganization = NS_ConvertUTF8toUTF16(organization);
     1:       PORT_Free(organization);
     1:     } else {
     1:       return GetIssuerCommonName(aOrganization);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetIssuerOrganizationUnit(nsAString &aOrganizationUnit)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   aOrganizationUnit.Truncate();
     1:   if (mCert) {
     1:     char *organizationUnit = CERT_GetOrgUnitName(&mCert->issuer);
     1:     if (organizationUnit) {
     1:       aOrganizationUnit = NS_ConvertUTF8toUTF16(organizationUnit);
     1:       PORT_Free(organizationUnit);
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute nsIX509Cert issuer; */
     1: NS_IMETHODIMP 
     1: nsNSSCertificate::GetIssuer(nsIX509Cert * *aIssuer)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NS_ENSURE_ARG(aIssuer);
106838:   *aIssuer = nullptr;
124992:   ScopedCERTCertificate issuer;
     1:   issuer = CERT_FindCertIssuer(mCert, PR_Now(), certUsageSSLClient);
     1:   if (issuer) {
 56495:     nsCOMPtr<nsIX509Cert> cert = nsNSSCertificate::Create(issuer);
 56495:     if (cert) {
     1:       *aIssuer = cert;
     1:       NS_ADDREF(*aIssuer);
 56495:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetOrganizationalUnit(nsAString &aOrganizationalUnit)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   aOrganizationalUnit.Truncate();
     1:   if (mCert) {
     1:     char *orgunit = CERT_GetOrgUnitName(&mCert->subject);
     1:     if (orgunit) {
     1:       aOrganizationalUnit = NS_ConvertUTF8toUTF16(orgunit);
     1:       PORT_Free(orgunit);
     1:     } /*else {
     1:       *aOrganizationalUnit = ToNewUnicode(NS_LITERAL_STRING("<not set>")), 
     1:     }*/
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* 
     1:  * nsIEnumerator getChain(); 
     1:  */
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetChain(nsIArray **_rvChain)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NS_ENSURE_ARG(_rvChain);
     1:   nsresult rv;
     1:   /* Get the cert chain from NSS */
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Getting chain for \"%s\"\n", mCert->nickname));
124992:   ScopedCERTCertList nssChain;
     1:   nssChain = CERT_GetCertChainFromCert(mCert, PR_Now(), certUsageSSLClient);
     1:   if (!nssChain)
     1:     return NS_ERROR_FAILURE;
     1:   /* enumerate the chain for scripting purposes */
     1:   nsCOMPtr<nsIMutableArray> array =
     1:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
     1:   if (NS_FAILED(rv)) { 
     1:     goto done; 
     1:   }
  3985:   CERTCertListNode *node;
     1:   for (node = CERT_LIST_HEAD(nssChain);
     1:        !CERT_LIST_END(node, nssChain);
     1:        node = CERT_LIST_NEXT(node)) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("adding %s to chain\n", node->cert->nickname));
 56495:     nsCOMPtr<nsIX509Cert> cert = nsNSSCertificate::Create(node->cert);
 80486:     array->AppendElement(cert, false);
     1:   }
     1:   *_rvChain = array;
     1:   NS_IF_ADDREF(*_rvChain);
     1:   rv = NS_OK;
     1: done:
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsNSSCertificate::GetAllTokenNames(uint32_t *aLength, PRUnichar*** aTokenNames)
 21038: {
 21038:   nsNSSShutDownPreventionLock locker;
 21038:   if (isAlreadyShutDown())
 21038:     return NS_ERROR_NOT_AVAILABLE;
 21038: 
 21038:   NS_ENSURE_ARG(aLength);
 21038:   NS_ENSURE_ARG(aTokenNames);
 21038:   *aLength = 0;
119899:   *aTokenNames = nullptr;
 21038: 
 21038:   /* Get the slots from NSS */
124992:   ScopedPK11SlotList slots;
 21038:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Getting slots for \"%s\"\n", mCert->nickname));
119899:   slots = PK11_GetAllSlotsForCert(mCert, nullptr);
 21038:   if (!slots) {
 21038:     if (PORT_GetError() == SEC_ERROR_NO_TOKEN)
 21038:       return NS_OK; // List of slots is empty, return empty array
 21038:     else
 21038:       return NS_ERROR_FAILURE;
 21038:   }
 21038: 
 21038:   /* read the token names from slots */
 21038:   PK11SlotListElement *le;
 21038: 
 21038:   for (le = slots->head; le; le = le->next) {
 21038:     ++(*aLength);
 21038:   }
 21038: 
 21038:   *aTokenNames = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * (*aLength));
 21038:   if (!*aTokenNames) {
 21038:     *aLength = 0;
 21038:     return NS_ERROR_OUT_OF_MEMORY;
 21038:   }
 21038: 
108991:   uint32_t iToken;
 21038:   for (le = slots->head, iToken = 0; le; le = le->next, ++iToken) {
 21038:     char *token = PK11_GetTokenName(le->slot);
 21038:     (*aTokenNames)[iToken] = ToNewUnicode(NS_ConvertUTF8toUTF16(token));
 21038:     if (!(*aTokenNames)[iToken]) {
 21038:       NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(iToken, *aTokenNames);
 21038:       *aLength = 0;
119899:       *aTokenNames = nullptr;
 21038:       return NS_ERROR_OUT_OF_MEMORY;
 21038:     }
 21038:   }
 21038: 
 21038:   return NS_OK;
 21038: }
 21038: 
 21038: NS_IMETHODIMP
     1: nsNSSCertificate::GetSubjectName(nsAString &_subjectName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   _subjectName.Truncate();
     1:   if (mCert->subjectName) {
     1:     _subjectName = NS_ConvertUTF8toUTF16(mCert->subjectName);
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetIssuerName(nsAString &_issuerName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   _issuerName.Truncate();
     1:   if (mCert->issuerName) {
     1:     _issuerName = NS_ConvertUTF8toUTF16(mCert->issuerName);
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetSerialNumber(nsAString &_serialNumber)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   _serialNumber.Truncate();
 27356:   char *tmpstr = CERT_Hexify(&mCert->serialNumber, 1);
 27356:   if (tmpstr) {
     1:     _serialNumber = NS_ConvertASCIItoUTF16(tmpstr);
 27356:     PORT_Free(tmpstr);
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetSha1Fingerprint(nsAString &_sha1Fingerprint)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   _sha1Fingerprint.Truncate();
     1:   unsigned char fingerprint[20];
     1:   SECItem fpItem;
     1:   memset(fingerprint, 0, sizeof fingerprint);
     1:   PK11_HashBuf(SEC_OID_SHA1, fingerprint, 
     1:                mCert->derCert.data, mCert->derCert.len);
     1:   fpItem.data = fingerprint;
     1:   fpItem.len = SHA1_LENGTH;
 27356:   char *fpStr = CERT_Hexify(&fpItem, 1);
 27356:   if (fpStr) {
     1:     _sha1Fingerprint = NS_ConvertASCIItoUTF16(fpStr);
 27356:     PORT_Free(fpStr);
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetMd5Fingerprint(nsAString &_md5Fingerprint)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   _md5Fingerprint.Truncate();
     1:   unsigned char fingerprint[20];
     1:   SECItem fpItem;
     1:   memset(fingerprint, 0, sizeof fingerprint);
     1:   PK11_HashBuf(SEC_OID_MD5, fingerprint, 
     1:                mCert->derCert.data, mCert->derCert.len);
     1:   fpItem.data = fingerprint;
     1:   fpItem.len = MD5_LENGTH;
 27356:   char *fpStr = CERT_Hexify(&fpItem, 1);
 27356:   if (fpStr) {
     1:     _md5Fingerprint = NS_ConvertASCIItoUTF16(fpStr);
 27356:     PORT_Free(fpStr);
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetTokenName(nsAString &aTokenName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   aTokenName.Truncate();
     1:   if (mCert) {
     1:     // HACK alert
     1:     // When the trust of a builtin cert is modified, NSS copies it into the
     1:     // cert db.  At this point, it is now "managed" by the user, and should
     1:     // not be listed with the builtins.  However, in the collection code
     1:     // used by PK11_ListCerts, the cert is found in the temp db, where it
     1:     // has been loaded from the token.  Though the trust is correct (grabbed
     1:     // from the cert db), the source is wrong.  I believe this is a safe
     1:     // way to work around this.
     1:     if (mCert->slot) {
     1:       char *token = PK11_GetTokenName(mCert->slot);
     1:       if (token) {
     1:         aTokenName = NS_ConvertUTF8toUTF16(token);
     1:       }
     1:     } else {
     1:       nsresult rv;
     1:       nsAutoString tok;
     1:       nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:       if (NS_FAILED(rv)) return rv;
     1:       rv = nssComponent->GetPIPNSSBundleString("InternalToken", tok);
     1:       if (NS_SUCCEEDED(rv))
     1:         aTokenName = tok;
     1:     }
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsNSSCertificate::GetRawDER(uint32_t *aLength, uint8_t **aArray)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   if (mCert) {
108991:     *aArray = (uint8_t*)nsMemory::Alloc(mCert->derCert.len);
     1:     if (*aArray) {
     1:       memcpy(*aArray, mCert->derCert.data, mCert->derCert.len);
     1:       *aLength = mCert->derCert.len;
     1:       return NS_OK;
     1:     }
     1:   }
     1:   *aLength = 0;
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
  6479: NS_IMETHODIMP
108991: nsNSSCertificate::ExportAsCMS(uint32_t chainMode,
108991:                               uint32_t *aLength, uint8_t **aArray)
  6479: {
  6479:   NS_ENSURE_ARG(aLength);
  6479:   NS_ENSURE_ARG(aArray);
  6479: 
  6479:   nsNSSShutDownPreventionLock locker;
  6479:   if (isAlreadyShutDown())
  6479:     return NS_ERROR_NOT_AVAILABLE;
  6479: 
  6479:   if (!mCert)
  6479:     return NS_ERROR_FAILURE;
  6479: 
  6479:   switch (chainMode) {
  6479:     case nsIX509Cert3::CMS_CHAIN_MODE_CertOnly:
  6479:     case nsIX509Cert3::CMS_CHAIN_MODE_CertChain:
  6479:     case nsIX509Cert3::CMS_CHAIN_MODE_CertChainWithRoot:
  6479:       break;
  6479:     default:
  6479:       return NS_ERROR_INVALID_ARG;
  6479:   };
  6479: 
  6479:   PLArenaPool *arena = PORT_NewArena(1024);
  6479:   PLArenaPoolCleanerFalseParam arenaCleaner(arena);
  6479:   if (!arena) {
  6479:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
  6479:            ("nsNSSCertificate::ExportAsCMS - out of memory\n"));
  6479:     return NS_ERROR_OUT_OF_MEMORY;
  6479:   }
  6479: 
124992:   ScopedNSSCMSMessage cmsg(NSS_CMSMessage_Create(nullptr));
  6479:   if (!cmsg) {
  6479:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
  6479:            ("nsNSSCertificate::ExportAsCMS - can't create CMS message\n"));
  6479:     return NS_ERROR_OUT_OF_MEMORY;
  6479:   }
  6479: 
  6479:   /*
  6479:    * first, create SignedData with the certificate only (no chain)
  6479:    */
124992:   ScopedNSSCMSSignedData sigd(NSS_CMSSignedData_CreateCertsOnly(cmsg, mCert,
124992:                                                                 false));
  6479:   if (!sigd) {
  6479:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
  6479:            ("nsNSSCertificate::ExportAsCMS - can't create SignedData\n"));
  6479:     return NS_ERROR_FAILURE;
  6479:   }
  6479: 
  6479:   /*
  6479:    * Calling NSS_CMSSignedData_CreateCertsOnly() will not allow us
  6479:    * to specify the inclusion of the root, but CERT_CertChainFromCert() does.
  6479:    * Since CERT_CertChainFromCert() also includes the certificate itself,
  6479:    * we have to start at the issuing cert (to avoid duplicate certs
  6479:    * in the SignedData).
  6479:    */
  6479:   if (chainMode == nsIX509Cert3::CMS_CHAIN_MODE_CertChain ||
  6479:       chainMode == nsIX509Cert3::CMS_CHAIN_MODE_CertChainWithRoot) {
124992:     ScopedCERTCertificate issuerCert(
124992:         CERT_FindCertIssuer(mCert, PR_Now(), certUsageAnyCA));
  6479:     /*
  6479:      * the issuerCert of a self signed root is the cert itself,
  6479:      * so make sure we're not adding duplicates, again
  6479:      */
  6479:     if (issuerCert && issuerCert != mCert) {
 79445:       bool includeRoot = 
  6479:         (chainMode == nsIX509Cert3::CMS_CHAIN_MODE_CertChainWithRoot);
124992:       ScopedCERTCertificateList certChain(
124992:           CERT_CertChainFromCert(issuerCert, certUsageAnyCA, includeRoot));
  6479:       if (certChain) {
  6479:         if (NSS_CMSSignedData_AddCertList(sigd, certChain) == SECSuccess) {
124992:           certChain.forget();
  6479:         }
  6479:         else {
  6479:           PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
  6479:                  ("nsNSSCertificate::ExportAsCMS - can't add chain\n"));
  6479:           return NS_ERROR_FAILURE;
  6479:         }
  6479:       }
  6479:       else { 
  6479:         /* try to add the issuerCert, at least */
  6479:         if (NSS_CMSSignedData_AddCertificate(sigd, issuerCert)
  6479:             == SECSuccess) {
124992:           issuerCert.forget();
  6479:         }
  6479:         else {
  6479:           PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
  6479:                  ("nsNSSCertificate::ExportAsCMS - can't add issuer cert\n"));
  6479:           return NS_ERROR_FAILURE;
  6479:         }
  6479:       }
  6479:     }
  6479:   }
  6479: 
  6479:   NSSCMSContentInfo *cinfo = NSS_CMSMessage_GetContentInfo(cmsg);
  6479:   if (NSS_CMSContentInfo_SetContent_SignedData(cmsg, cinfo, sigd)
  6479:        == SECSuccess) {
124992:     sigd.forget();
  6479:   }
  6479:   else {
  6479:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
  6479:            ("nsNSSCertificate::ExportAsCMS - can't attach SignedData\n"));
  6479:     return NS_ERROR_FAILURE;
  6479:   }
  6479: 
106838:   SECItem certP7 = { siBuffer, nullptr, 0 };
106838:   NSSCMSEncoderContext *ecx = NSS_CMSEncoder_Start(cmsg, nullptr, nullptr, &certP7, arena,
106838:                                                    nullptr, nullptr, nullptr, nullptr, nullptr,
106838:                                                    nullptr);
  6479:   if (!ecx) {
  6479:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
  6479:            ("nsNSSCertificate::ExportAsCMS - can't create encoder context\n"));
  6479:     return NS_ERROR_FAILURE;
  6479:   }
  6479: 
  6479:   if (NSS_CMSEncoder_Finish(ecx) != SECSuccess) {
  6479:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
  6479:            ("nsNSSCertificate::ExportAsCMS - failed to add encoded data\n"));
  6479:     return NS_ERROR_FAILURE;
  6479:   }
  6479: 
108991:   *aArray = (uint8_t*)nsMemory::Alloc(certP7.len);
  6479:   if (!*aArray)
  6479:     return NS_ERROR_OUT_OF_MEMORY;
  6479: 
  6479:   memcpy(*aArray, certP7.data, certP7.len);
  6479:   *aLength = certP7.len;
  6479:   return NS_OK;
  6479: }
  6479: 
     1: CERTCertificate *
     1: nsNSSCertificate::GetCert()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
106838:     return nullptr;
     1: 
106838:   return (mCert) ? CERT_DupCertificate(mCert) : nullptr;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::GetValidity(nsIX509CertValidity **aValidity)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NS_ENSURE_ARG(aValidity);
     1:   nsX509CertValidity *validity = new nsX509CertValidity(mCert);
     1: 
     1:   NS_ADDREF(validity);
  3233:   *aValidity = static_cast<nsIX509CertValidity*>(validity);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsNSSCertificate::VerifyForUsage(uint32_t usage, uint32_t *verificationResult)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NS_ENSURE_ARG(verificationResult);
     1: 
     1:   SECCertificateUsage nss_usage;
     1:   
     1:   switch (usage)
     1:   {
     1:     case CERT_USAGE_SSLClient:
     1:       nss_usage = certificateUsageSSLClient;
     1:       break;
     1: 
     1:     case CERT_USAGE_SSLServer:
     1:       nss_usage = certificateUsageSSLServer;
     1:       break;
     1: 
     1:     case CERT_USAGE_SSLServerWithStepUp:
     1:       nss_usage = certificateUsageSSLServerWithStepUp;
     1:       break;
     1: 
     1:     case CERT_USAGE_SSLCA:
     1:       nss_usage = certificateUsageSSLCA;
     1:       break;
     1: 
     1:     case CERT_USAGE_EmailSigner:
     1:       nss_usage = certificateUsageEmailSigner;
     1:       break;
     1: 
     1:     case CERT_USAGE_EmailRecipient:
     1:       nss_usage = certificateUsageEmailRecipient;
     1:       break;
     1: 
     1:     case CERT_USAGE_ObjectSigner:
     1:       nss_usage = certificateUsageObjectSigner;
     1:       break;
     1: 
     1:     case CERT_USAGE_UserCertImport:
     1:       nss_usage = certificateUsageUserCertImport;
     1:       break;
     1: 
     1:     case CERT_USAGE_VerifyCA:
     1:       nss_usage = certificateUsageVerifyCA;
     1:       break;
     1: 
     1:     case CERT_USAGE_ProtectedObjectSigner:
     1:       nss_usage = certificateUsageProtectedObjectSigner;
     1:       break;
     1: 
     1:     case CERT_USAGE_StatusResponder:
     1:       nss_usage = certificateUsageStatusResponder;
     1:       break;
     1: 
     1:     case CERT_USAGE_AnyCA:
     1:       nss_usage = certificateUsageAnyCA;
     1:       break;
     1: 
     1:     default:
     1:       return NS_ERROR_FAILURE;
     1:   }
     1: 
140656:   SECStatus verify_result;
141170: #ifndef NSS_NO_LIBPKIX
140656:   if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
141170: #endif
140656:     CERTCertDBHandle *defaultcertdb = CERT_GetDefaultCertDB();
140656:     verify_result = CERT_VerifyCertificateNow(defaultcertdb, mCert, true, 
140656:                                               nss_usage, nullptr, nullptr);
141170: #ifndef NSS_NO_LIBPKIX
140656:   }
140656:   else {
141170:     nsresult nsrv;
141170:     nsCOMPtr<nsINSSComponent> inss = do_GetService(kNSSComponentCID, &nsrv);
141170:     if (!inss)
141170:       return nsrv;
141170:     RefPtr<nsCERTValInParamWrapper> survivingParams;
141170:     nsrv = inss->GetDefaultCERTValInParam(survivingParams);
141170:     if (NS_FAILED(nsrv))
141170:       return nsrv;
140656:     CERTValOutParam cvout[1];
140656:     cvout[0].type = cert_po_end;
140656:     verify_result = CERT_PKIXVerifyCert(mCert, nss_usage,
140656:                                         survivingParams->GetRawPointerForNSS(),
140656:                                         cvout, nullptr);
140656:   }
141170: #endif
     1:   
 69383:   if (verify_result == SECSuccess)
     1:   {
     1:     *verificationResult = VERIFIED_OK;
     1:   }
     1:   else
     1:   {
     1:     int err = PR_GetError();
     1: 
     1:     // this list was cloned from verifyFailed
     1: 
     1:     switch (err)
     1:     {
     1:       case SEC_ERROR_INADEQUATE_KEY_USAGE:
     1:       case SEC_ERROR_INADEQUATE_CERT_TYPE:
     1:         *verificationResult = USAGE_NOT_ALLOWED;
     1:         break;
     1: 
     1:       case SEC_ERROR_REVOKED_CERTIFICATE:
     1:         *verificationResult = CERT_REVOKED;
     1:         break;
     1: 
     1:       case SEC_ERROR_EXPIRED_CERTIFICATE:
     1:         *verificationResult = CERT_EXPIRED;
     1:         break;
     1:         
     1:       case SEC_ERROR_UNTRUSTED_CERT:
     1:         *verificationResult = CERT_NOT_TRUSTED;
     1:         break;
     1:         
     1:       case SEC_ERROR_UNTRUSTED_ISSUER:
     1:         *verificationResult = ISSUER_NOT_TRUSTED;
     1:         break;
     1:         
     1:       case SEC_ERROR_UNKNOWN_ISSUER:
     1:         *verificationResult = ISSUER_UNKNOWN;
     1:         break;
     1:         
104409:       case SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED:
104409:         *verificationResult = SIGNATURE_ALGORITHM_DISABLED;
104409:         break;
104409: 
     1:       case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
     1:         *verificationResult = INVALID_CA;
     1:         break;
     1:         
     1:       case SEC_ERROR_CERT_USAGES_INVALID:
     1:       default:
     1:         *verificationResult = NOT_VERIFIED_UNKNOWN; 
     1:         break;
     1:     }
     1:   }
     1:   
     1:   return NS_OK;  
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
 79445: nsNSSCertificate::GetUsagesArray(bool localOnly,
108991:                                  uint32_t *_verified,
108991:                                  uint32_t *_count,
     1:                                  PRUnichar ***_usages)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv;
     1:   const int max_usages = 13;
     1:   PRUnichar *tmpUsages[max_usages];
     1:   const char *suffix = "";
108991:   uint32_t tmpCount;
     1:   nsUsageArrayHelper uah(mCert);
 69383:   rv = uah.GetUsagesArray(suffix, localOnly, max_usages, _verified, &tmpCount, tmpUsages);
     1:   NS_ENSURE_SUCCESS(rv,rv);
     1:   if (tmpCount > 0) {
     1:     *_usages = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *) * tmpCount);
     1:     if (!*_usages)
     1:       return NS_ERROR_OUT_OF_MEMORY;
108991:     for (uint32_t i=0; i<tmpCount; i++) {
     1:       (*_usages)[i] = tmpUsages[i];
     1:     }
     1:     *_count = tmpCount;
     1:     return NS_OK;
     1:   }
     1:   *_usages = (PRUnichar **)nsMemory::Alloc(sizeof(PRUnichar *));
     1:   if (!*_usages)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   *_count = 0;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::RequestUsagesArrayAsync(nsICertVerificationListener *aResultListener)
     1: {
     1:   if (!aResultListener)
     1:     return NS_ERROR_FAILURE;
     1:   
     1:   nsCertVerificationJob *job = new nsCertVerificationJob;
     1: 
     1:   job->mCert = this;
     1:   job->mListener = aResultListener;
     1: 
     1:   nsresult rv = nsCertVerificationThread::addJob(job);
     1:   if (NS_FAILED(rv))
     1:     delete job;
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsNSSCertificate::GetUsagesString(bool localOnly,
108991:                                   uint32_t   *_verified,
     1:                                   nsAString &_usages)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv;
     1:   const int max_usages = 13;
     1:   PRUnichar *tmpUsages[max_usages];
     1:   const char *suffix = "_p";
108991:   uint32_t tmpCount;
     1:   nsUsageArrayHelper uah(mCert);
 69383:   rv = uah.GetUsagesArray(suffix, localOnly, max_usages, _verified, &tmpCount, tmpUsages);
     1:   NS_ENSURE_SUCCESS(rv,rv);
     1:   _usages.Truncate();
108991:   for (uint32_t i=0; i<tmpCount; i++) {
     1:     if (i>0) _usages.AppendLiteral(",");
     1:     _usages.Append(tmpUsages[i]);
     1:     nsMemory::Free(tmpUsages[i]);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: #if defined(DEBUG_javi) || defined(DEBUG_jgmyers)
     1: void
     1: DumpASN1Object(nsIASN1Object *object, unsigned int level)
     1: {
     1:   nsAutoString dispNameU, dispValU;
     1:   unsigned int i;
     1:   nsCOMPtr<nsIMutableArray> asn1Objects;
     1:   nsCOMPtr<nsISupports> isupports;
     1:   nsCOMPtr<nsIASN1Object> currObject;
 79445:   bool processObjects;
108991:   uint32_t numObjects;
     1: 
     1:   for (i=0; i<level; i++)
     1:     printf ("  ");
     1: 
     1:   object->GetDisplayName(dispNameU);
     1:   nsCOMPtr<nsIASN1Sequence> sequence(do_QueryInterface(object));
     1:   if (sequence) {
     1:     printf ("%s ", NS_ConvertUTF16toUTF8(dispNameU).get());
     1:     sequence->GetIsValidContainer(&processObjects);
     1:     if (processObjects) {
     1:       printf("\n");
     1:       sequence->GetASN1Objects(getter_AddRefs(asn1Objects));
     1:       asn1Objects->GetLength(&numObjects);
     1:       for (i=0; i<numObjects;i++) {
     1:         asn1Objects->QueryElementAt(i, NS_GET_IID(nsISupports), getter_AddRefs(currObject));
     1:         DumpASN1Object(currObject, level+1);    
     1:       }
     1:     } else { 
     1:       object->GetDisplayValue(dispValU);
     1:       printf("= %s\n", NS_ConvertUTF16toUTF8(dispValU).get()); 
     1:     }
     1:   } else { 
     1:     object->GetDisplayValue(dispValU);
     1:     printf("%s = %s\n",NS_ConvertUTF16toUTF8(dispNameU).get(), 
     1:                        NS_ConvertUTF16toUTF8(dispValU).get()); 
     1:   }
     1: }
     1: #endif
     1: 
     1: /* readonly attribute nsIASN1Object ASN1Structure; */
     1: NS_IMETHODIMP 
     1: nsNSSCertificate::GetASN1Structure(nsIASN1Object * *aASN1Structure)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   NS_ENSURE_ARG_POINTER(aASN1Structure);
119899:   if (!mASN1Structure) {
     1:     // First create the recursive structure os ASN1Objects
     1:     // which tells us the layout of the cert.
     1:     rv = CreateASN1Struct();
     1:     if (NS_FAILED(rv)) {
     1:       return rv;
     1:     }
     1: #ifdef DEBUG_javi
     1:     DumpASN1Object(mASN1Structure, 0);
     1: #endif
     1:   }
     1:   *aASN1Structure = mASN1Structure;
     1:   NS_IF_ADDREF(*aASN1Structure);
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsNSSCertificate::Equals(nsIX509Cert *other, bool *result)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NS_ENSURE_ARG(other);
     1:   NS_ENSURE_ARG(result);
     1: 
     1:   nsCOMPtr<nsIX509Cert2> other2 = do_QueryInterface(other);
     1:   if (!other2)
     1:     return NS_ERROR_FAILURE;
     1:  
124992:   ScopedCERTCertificate cert(other2->GetCert());
     1:   *result = (mCert == cert);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNSSCertificate::SaveSMimeProfile()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
106838:   if (SECSuccess != CERT_SaveSMimeProfile(mCert, nullptr, nullptr))
     1:     return NS_ERROR_FAILURE;
     1:   else
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: char* nsNSSCertificate::defaultServerNickname(CERTCertificate* cert)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
106838:   char* nickname = nullptr;
     1:   int count;
 79445:   bool conflict;
106838:   char* servername = nullptr;
     1:   
     1:   servername = CERT_GetCommonName(&cert->subject);
 10259:   if (!servername) {
 10259:     // Certs without common names are strange, but they do exist...
 10259:     // Let's try to use another string for the nickname
 10259:     servername = CERT_GetOrgUnitName(&cert->subject);
 10259:     if (!servername) {
 10259:       servername = CERT_GetOrgName(&cert->subject);
 10259:       if (!servername) {
 10259:         servername = CERT_GetLocalityName(&cert->subject);
 10259:         if (!servername) {
 10259:           servername = CERT_GetStateName(&cert->subject);
 10259:           if (!servername) {
 10259:             servername = CERT_GetCountryName(&cert->subject);
 10259:             if (!servername) {
 10259:               // We tried hard, there is nothing more we can do.
 10259:               // A cert without any names doesn't really make sense.
106838:               return nullptr;
     1:             }
 10259:           }
 10259:         }
 10259:       }
 10259:     }
 10259:   }
     1:    
     1:   count = 1;
     1:   while (1) {
     1:     if (count == 1) {
     1:       nickname = PR_smprintf("%s", servername);
     1:     }
     1:     else {
     1:       nickname = PR_smprintf("%s #%d", servername, count);
     1:     }
119899:     if (!nickname) {
     1:       break;
     1:     }
     1: 
     1:     conflict = SEC_CertNicknameConflict(nickname, &cert->derSubject,
     1:                                         cert->dbhandle);
 10259:     if (!conflict) {
     1:       break;
     1:     }
 63704:     PR_Free(nickname);
     1:     count++;
     1:   }
     1:   PR_FREEIF(servername);
     1:   return nickname;
     1: }
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsNSSCertList, nsIX509CertList)
     1: 
 79445: nsNSSCertList::nsNSSCertList(CERTCertList *certList, bool adopt)
     1: {
     1:   if (certList) {
     1:     if (adopt) {
     1:       mCertList = certList;
     1:     } else {
     1:       mCertList = DupCertList(certList);
     1:     }
     1:   } else {
     1:     mCertList = CERT_NewCertList();
     1:   }
     1: }
     1: 
     1: /* void addCert (in nsIX509Cert cert); */
     1: NS_IMETHODIMP
     1: nsNSSCertList::AddCert(nsIX509Cert *aCert) 
     1: {
     1:   /* This should be a query interface, but currently this his how the
     1:    * rest of PSM is working */
     1:   nsCOMPtr<nsIX509Cert2> nssCert = do_QueryInterface(aCert);
     1:   CERTCertificate *cert;
     1: 
     1:   cert = nssCert->GetCert();
119899:   if (!cert) {
106838:     NS_ERROR("Somehow got nullptr for mCertificate in nsNSSCertificate.");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
119899:   if (!mCertList) {
106838:     NS_ERROR("Somehow got nullptr for mCertList in nsNSSCertList.");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   CERT_AddCertToListTail(mCertList,cert);
     1:   return NS_OK;
     1: }
     1: 
     1: /* void deleteCert (in nsIX509Cert cert); */
     1: NS_IMETHODIMP
     1: nsNSSCertList::DeleteCert(nsIX509Cert *aCert)
     1: {
     1:   /* This should be a query interface, but currently this his how the
     1:    * rest of PSM is working */
     1:   nsCOMPtr<nsIX509Cert2> nssCert = do_QueryInterface(aCert);
     1:   CERTCertificate *cert = nssCert->GetCert();
     1:   CERTCertListNode *node;
     1: 
119899:   if (!cert) {
106838:     NS_ERROR("Somehow got nullptr for mCertificate in nsNSSCertificate.");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
119899:   if (!mCertList) {
106838:     NS_ERROR("Somehow got nullptr for mCertList in nsNSSCertList.");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   for (node = CERT_LIST_HEAD(mCertList); !CERT_LIST_END(node,mCertList);
     1:                                              node = CERT_LIST_NEXT(node)) {
     1:     if (node->cert == cert) {
     1: 	CERT_RemoveCertListNode(node);
     1:         return NS_OK;
     1:     }
     1:   }
     1:   return NS_OK; /* should we fail if we couldn't find it? */
     1: }
     1: 
     1: CERTCertList *
     1: nsNSSCertList::DupCertList(CERTCertList *aCertList)
     1: {
     1:   if (!aCertList)
106838:     return nullptr;
     1: 
     1:   CERTCertList *newList = CERT_NewCertList();
     1: 
119899:   if (!newList) {
106838:     return nullptr;
     1:   }
     1: 
     1:   CERTCertListNode *node;
     1:   for (node = CERT_LIST_HEAD(aCertList); !CERT_LIST_END(node, aCertList);
     1:                                               node = CERT_LIST_NEXT(node)) {
     1:     CERTCertificate *cert = CERT_DupCertificate(node->cert);
     1:     CERT_AddCertToListTail(newList, cert);
     1:   }
     1:   return newList;
     1: }
     1: 
     1: void *
     1: nsNSSCertList::GetRawCertList()
     1: {
     1:   return mCertList;
     1: }
     1: 
     1: /* nsISimpleEnumerator getEnumerator (); */
     1: NS_IMETHODIMP
     1: nsNSSCertList::GetEnumerator(nsISimpleEnumerator **_retval) 
     1: {
     1:   nsCOMPtr<nsISimpleEnumerator> enumerator = new nsNSSCertListEnumerator(mCertList);
     1: 
     1:   *_retval = enumerator;
     1:   NS_ADDREF(*_retval);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsNSSCertListEnumerator, 
     1:                               nsISimpleEnumerator)
     1: 
     1: nsNSSCertListEnumerator::nsNSSCertListEnumerator(CERTCertList *certList)
     1: {
     1:   mCertList = nsNSSCertList::DupCertList(certList);
     1: }
     1: 
     1: /* boolean hasMoreElements (); */
     1: NS_IMETHODIMP
 79445: nsNSSCertListEnumerator::HasMoreElements(bool *_retval)
     1: { 
     1:   NS_ENSURE_TRUE(mCertList, NS_ERROR_FAILURE);
     1: 
     1:   *_retval = !CERT_LIST_EMPTY(mCertList);
     1:   return NS_OK;
     1: }
     1: 
     1: /* nsISupports getNext(); */
     1: NS_IMETHODIMP
     1: nsNSSCertListEnumerator::GetNext(nsISupports **_retval) 
     1: {
     1:   NS_ENSURE_TRUE(mCertList, NS_ERROR_FAILURE);
     1: 
     1:   CERTCertListNode *node = CERT_LIST_HEAD(mCertList);
     1:   if (CERT_LIST_END(node, mCertList)) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 56495:   nsCOMPtr<nsIX509Cert> nssCert = nsNSSCertificate::Create(node->cert);
     1:   if (!nssCert) { 
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1: 
     1:   *_retval = nssCert;
     1:   NS_ADDREF(*_retval);
     1: 
     1:   CERT_RemoveCertListNode(node);
     1:   return NS_OK;
     1: }
  5210: 
  5210: NS_IMETHODIMP
  5210: nsNSSCertificate::Write(nsIObjectOutputStream* aStream)
  5210: {
  5210:   NS_ENSURE_STATE(mCert);
  5210:   nsresult rv = aStream->Write32(mCert->derCert.len);
  5210:   if (NS_FAILED(rv)) {
  5210:     return rv;
  5210:   }
  5210:   
  5210:   return aStream->WriteByteArray(mCert->derCert.data, mCert->derCert.len);
  5210: }
  5210: 
  5210: NS_IMETHODIMP
  5210: nsNSSCertificate::Read(nsIObjectInputStream* aStream)
  5210: {
  5210:   NS_ENSURE_STATE(!mCert);
  5210:   
108991:   uint32_t len;
  5210:   nsresult rv = aStream->Read32(&len);
  5210:   if (NS_FAILED(rv)) {
  5210:     return rv;
  5210:   }
  5210: 
  5210:   nsXPIDLCString str;
  5210:   rv = aStream->ReadBytes(len, getter_Copies(str));
  5210:   if (NS_FAILED(rv)) {
  5210:     return rv;
  5210:   }
  5210: 
  5210:   if (!InitFromDER(const_cast<char*>(str.get()), len)) {
  5210:     return NS_ERROR_UNEXPECTED;
  5210:   }
  5210: 
  5210:   return NS_OK;
  5210: }
  5210: 
  5210: NS_IMETHODIMP 
108991: nsNSSCertificate::GetInterfaces(uint32_t *count, nsIID * **array)
  5210: {
  5210:   *count = 0;
106838:   *array = nullptr;
  5210:   return NS_OK;
  5210: }
  5210: 
  5210: NS_IMETHODIMP 
108991: nsNSSCertificate::GetHelperForLanguage(uint32_t language, nsISupports **_retval)
  5210: {
106838:   *_retval = nullptr;
  5210:   return NS_OK;
  5210: }
  5210: 
  5210: NS_IMETHODIMP 
  5210: nsNSSCertificate::GetContractID(char * *aContractID)
  5210: {
106838:   *aContractID = nullptr;
  5210:   return NS_OK;
  5210: }
  5210: 
  5210: NS_IMETHODIMP 
  5210: nsNSSCertificate::GetClassDescription(char * *aClassDescription)
  5210: {
106838:   *aClassDescription = nullptr;
  5210:   return NS_OK;
  5210: }
  5210: 
  5210: NS_IMETHODIMP 
  5210: nsNSSCertificate::GetClassID(nsCID * *aClassID)
  5210: {
  5210:   *aClassID = (nsCID*) nsMemory::Alloc(sizeof(nsCID));
  5210:   if (!*aClassID)
  5210:     return NS_ERROR_OUT_OF_MEMORY;
  5210:   return GetClassIDNoAlloc(*aClassID);
  5210: }
  5210: 
  5210: NS_IMETHODIMP 
108991: nsNSSCertificate::GetImplementationLanguage(uint32_t *aImplementationLanguage)
  5210: {
  5210:   *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
  5210:   return NS_OK;
  5210: }
  5210: 
  5210: NS_IMETHODIMP 
108991: nsNSSCertificate::GetFlags(uint32_t *aFlags)
  5210: {
  5210:   *aFlags = nsIClassInfo::THREADSAFE;
  5210:   return NS_OK;
  5210: }
  5210: 
  5210: static NS_DEFINE_CID(kNSSCertificateCID, NS_X509CERT_CID);
  5210: 
  5210: NS_IMETHODIMP 
  5210: nsNSSCertificate::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
  5210: {
  5210:   *aClassIDNoAlloc = kNSSCertificateCID;
  5210:   return NS_OK;
  5210: }
