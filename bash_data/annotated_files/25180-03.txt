    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "pratom.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMNSHTMLElement.h"
 1418: #include "nsIDOMEventTarget.h"
 1418: #include "nsPIDOMEventTarget.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsReadableUtils.h"
    1: 
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsIDOMNamedNodeMap.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIDOMEventListener.h"
    1: #include "nsIDOMEventGroup.h"
    1: #include "nsIDOMMouseListener.h"
    1: #include "nsIDOMFocusListener.h"
    1: #include "nsIDOMTextListener.h"
    1: #include "nsIDOMCompositionListener.h"
    1: #include "nsIDOMDragListener.h"
    1: #include "nsIDOMHTMLBRElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsITransactionManager.h"
    1: #include "nsIAbsorbingTransaction.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIViewManager.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIEnumerator.h"
    1: #include "nsIAtom.h"
15969: #include "nsCaret.h"
    1: #include "nsIWidget.h"
    1: #include "nsIPlaintextEditor.h"
    1: #include "nsGUIEvent.h"  // nsTextEventReply
    1: 
    1: #include "nsIFrame.h"  // Needed by IME code
    1: 
    1: #include "nsICSSStyleSheet.h"
    1: 
    1: #include "nsIContent.h"
    1: #include "nsServiceManagerUtils.h"
    1: 
    1: // transactions the editor knows how to build
    1: #include "TransactionFactory.h"
    1: #include "EditAggregateTxn.h"
    1: #include "PlaceholderTxn.h"
    1: #include "ChangeAttributeTxn.h"
    1: #include "CreateElementTxn.h"
    1: #include "InsertElementTxn.h"
    1: #include "DeleteElementTxn.h"
    1: #include "InsertTextTxn.h"
    1: #include "DeleteTextTxn.h"
    1: #include "DeleteRangeTxn.h"
    1: #include "SplitElementTxn.h"
    1: #include "JoinElementTxn.h"
    1: #include "nsStyleSheetTxns.h"
    1: #include "IMETextTxn.h"
20592: #include "nsString.h"
    1: 
    1: #include "nsEditor.h"
    1: #include "nsEditorUtils.h"
    1: #include "nsISelectionDisplay.h"
    1: #include "nsIInlineSpellChecker.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIParserService.h"
    1: 
    1: #define NS_ERROR_EDITOR_NO_SELECTION NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_EDITOR,1)
    1: #define NS_ERROR_EDITOR_NO_TEXTNODE  NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_EDITOR,2)
    1: 
    1: #ifdef NS_DEBUG_EDITOR
    1: static PRBool gNoisy = PR_FALSE;
    1: #endif
    1: 
    1: 
    1: // Defined in nsEditorRegistration.cpp
    1: extern nsIParserService *sParserService;
    1: 
    1: //---------------------------------------------------------------------------
    1: //
    1: // nsEditor: base editor class implementation
    1: //
    1: //---------------------------------------------------------------------------
    1: 
    1: nsEditor::nsEditor()
    1: :  mModCount(0)
    1: ,  mPresShellWeak(nsnull)
    1: ,  mViewManager(nsnull)
    1: ,  mUpdateCount(0)
    1: ,  mSpellcheckCheckboxState(eTriUnset)
    1: ,  mPlaceHolderTxn(nsnull)
    1: ,  mPlaceHolderName(nsnull)
    1: ,  mPlaceHolderBatch(0)
    1: ,  mSelState(nsnull)
    1: ,  mSavedSel()
    1: ,  mRangeUpdater()
    1: ,  mAction(nsnull)
    1: ,  mDirection(eNone)
    1: ,  mIMETextNode(nsnull)
    1: ,  mIMETextOffset(0)
    1: ,  mIMEBufferLength(0)
    1: ,  mInIMEMode(PR_FALSE)
    1: ,  mIsIMEComposing(PR_FALSE)
    1: ,  mShouldTxnSetSelection(PR_TRUE)
    1: ,  mDidPreDestroy(PR_FALSE)
    1: ,  mDocDirtyState(-1)
    1: ,  mDocWeak(nsnull)
    1: ,  mPhonetic(nsnull)
    1: {
    1:   //initialize member variables here
    1: }
    1: 
    1: nsEditor::~nsEditor()
    1: {
13021:   mTxnMgr = nsnull;
    1: 
    1:   delete mPhonetic;
    1:  
    1:   NS_IF_RELEASE(mViewManager);
    1: }
    1: 
 6601: NS_IMPL_ISUPPORTS5(nsEditor, nsIEditor, nsIEditorIMESupport,
 6601:                    nsISupportsWeakReference, nsIPhonetic, nsIMutationObserver)
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsIEditorMethods 
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::Init(nsIDOMDocument *aDoc, nsIPresShell* aPresShell, nsIContent *aRoot, nsISelectionController *aSelCon, PRUint32 aFlags)
    1: {
    1:   NS_PRECONDITION(nsnull!=aDoc && nsnull!=aPresShell, "bad arg");
    1:   if ((nsnull==aDoc) || (nsnull==aPresShell))
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   mFlags = aFlags;
    1:   mDocWeak = do_GetWeakReference(aDoc);  // weak reference to doc
    1:   mPresShellWeak = do_GetWeakReference(aPresShell);   // weak reference to pres shell
    1:   mSelConWeak = do_GetWeakReference(aSelCon);   // weak reference to selectioncontroller
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps) return NS_ERROR_NOT_INITIALIZED;
    1:   
    1:   //set up root element if we are passed one.  
    1:   if (aRoot)
    1:     mRootElement = do_QueryInterface(aRoot);
    1: 
 6601:   nsCOMPtr<nsINode> document = do_QueryInterface(aDoc);
 6601:   document->AddMutationObserver(this);
 6601: 
    1:   // Set up the DTD
    1:   // XXX - in the long run we want to get this from the document, but there
    1:   // is no way to do that right now.  So we leave it null here and set
    1:   // up a nav html dtd in nsHTMLEditor::Init
    1: 
    1:   mViewManager = ps->GetViewManager();
    1:   if (!mViewManager) {return NS_ERROR_NULL_POINTER;}
    1:   NS_ADDREF(mViewManager);
    1: 
    1:   mUpdateCount=0;
    1: 
    1:   /* initialize IME stuff */
    1:   mIMETextNode = nsnull;
    1:   mIMETextOffset = 0;
    1:   mIMEBufferLength = 0;
    1:   
    1:   /* Show the caret */
    1:   aSelCon->SetCaretReadOnly(PR_FALSE);
    1:   aSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
    1:   
    1:   aSelCon->SetSelectionFlags(nsISelectionDisplay::DISPLAY_ALL);//we want to see all the selection reflected to user
    1: 
    1: #if 1
    1:   // THIS BLOCK CAUSES ASSERTIONS because sometimes we don't yet have
    1:   // a moz-br but we do have a presshell.
    1: 
    1:   // Set the selection to the beginning:
    1: 
    1: //hack to get around this for now.
    1:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mSelConWeak);
    1:   if (shell)
    1:     BeginningOfDocument();
    1: #endif
    1: 
    1:   NS_POSTCONDITION(mDocWeak && mPresShellWeak, "bad state");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::PostCreate()
    1: {
    1:   // Set up spellchecking
    1:   nsresult rv = SyncRealTimeSpell();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Set up listeners
    1:   rv = CreateEventListeners();
    1:   if (NS_FAILED(rv))
    1:   {
    1:     RemoveEventListeners();
    1: 
    1:     return rv;
    1:   }
    1: 
    1:   rv = InstallEventListeners();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // nuke the modification count, so the doc appears unmodified
    1:   // do this before we notify listeners
    1:   ResetModificationCount();
    1:   
    1:   // update the UI with our state
    1:   NotifyDocumentListeners(eDocumentCreated);
    1:   NotifyDocumentListeners(eDocumentStateChanged);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsEditor::InstallEventListeners()
    1: {
    1:   NS_ENSURE_TRUE(mDocWeak && mPresShellWeak && mKeyListenerP &&
    1:                  mMouseListenerP && mFocusListenerP && mTextListenerP &&
    1:                  mCompositionListenerP && mDragListenerP,
    1:                  NS_ERROR_NOT_INITIALIZED);
    1: 
 1418:   nsCOMPtr<nsPIDOMEventTarget> piTarget = GetPIDOMEventTarget();
 1418: 
 1418:   if (!piTarget) {
    1:     RemoveEventListeners();
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // register the event listeners with the listener manager
    1:   nsCOMPtr<nsIDOMEventGroup> sysGroup;
 1418:   piTarget->GetSystemEventGroup(getter_AddRefs(sysGroup));
    1:   nsCOMPtr<nsIEventListenerManager> elmP;
 1418:   piTarget->GetListenerManager(PR_TRUE, getter_AddRefs(elmP));
    1: 
    1:   if (sysGroup && elmP)
    1:   {
    1:     rv = elmP->AddEventListenerByType(mKeyListenerP,
    1:                                       NS_LITERAL_STRING("keypress"),
    1:                                       NS_EVENT_FLAG_BUBBLE |
    1:                                       NS_PRIV_EVENT_UNTRUSTED_PERMITTED,
    1:                                       sysGroup);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv),
    1:                  "failed to register key listener in system group");
    1:   }
    1: 
 1418:   rv |= piTarget->AddEventListenerByIID(mMouseListenerP,
    1:                                         NS_GET_IID(nsIDOMMouseListener));
    1: 
 3131:   if (elmP) {
 3131:     // Focus event doesn't bubble so adding the listener to capturing phase.
 3131:     // Make sure this works after bug 235441 gets fixed.
 3131:     rv |= elmP->AddEventListenerByIID(mFocusListenerP,
 3131:                                       NS_GET_IID(nsIDOMFocusListener),
 3131:                                       NS_EVENT_FLAG_CAPTURE);
 3131:   }
    1: 
 1418:   rv |= piTarget->AddEventListenerByIID(mTextListenerP,
    1:                                         NS_GET_IID(nsIDOMTextListener));
    1: 
 1418:   rv |= piTarget->AddEventListenerByIID(mCompositionListenerP,
    1:                                         NS_GET_IID(nsIDOMCompositionListener));
    1: 
20592:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(piTarget));
20592:   if (target) {
20672:     // See bug 455215, we cannot use the standard dragstart event yet
20671:     rv |= target->AddEventListener(NS_LITERAL_STRING("draggesture"), mDragListenerP, PR_FALSE);
20592:     rv |= target->AddEventListener(NS_LITERAL_STRING("dragenter"), mDragListenerP, PR_FALSE);
20592:     rv |= target->AddEventListener(NS_LITERAL_STRING("dragover"), mDragListenerP, PR_FALSE);
20592:     rv |= target->AddEventListener(NS_LITERAL_STRING("dragleave"), mDragListenerP, PR_FALSE);
20592:     rv |= target->AddEventListener(NS_LITERAL_STRING("drop"), mDragListenerP, PR_FALSE);
20592:   }
    1: 
    1:   if (NS_FAILED(rv))
    1:   {
    1:     NS_ERROR("failed to register some event listeners");
    1: 
    1:     RemoveEventListeners();
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsEditor::RemoveEventListeners()
    1: {
    1:   if (!mDocWeak)
    1:   {
    1:     return;
    1:   }
    1: 
 1418:   nsCOMPtr<nsPIDOMEventTarget> piTarget = GetPIDOMEventTarget();
 1418: 
 1418:   if (piTarget)
    1:   {
 3131:     // unregister the event listeners with the DOM event target
 3131:     nsCOMPtr<nsIEventListenerManager> elmP;
 3131:     piTarget->GetListenerManager(PR_TRUE, getter_AddRefs(elmP));
    1:     if (mKeyListenerP)
    1:     {
    1:       nsCOMPtr<nsIDOMEventGroup> sysGroup;
 1418:       piTarget->GetSystemEventGroup(getter_AddRefs(sysGroup));
    1:       if (sysGroup && elmP)
    1:       {
    1:         elmP->RemoveEventListenerByType(mKeyListenerP,
    1:                                         NS_LITERAL_STRING("keypress"),
    1:                                         NS_EVENT_FLAG_BUBBLE |
    1:                                         NS_PRIV_EVENT_UNTRUSTED_PERMITTED,
    1:                                         sysGroup);
    1:       }
    1:     }
    1: 
    1:     if (mMouseListenerP)
    1:     {
 1418:       piTarget->RemoveEventListenerByIID(mMouseListenerP,
    1:                                          NS_GET_IID(nsIDOMMouseListener));
    1:     }
    1: 
 3131:     if (mFocusListenerP && elmP)
 3131:     {
 3131:       elmP->RemoveEventListenerByIID(mFocusListenerP,
 3131:                                      NS_GET_IID(nsIDOMFocusListener),
 3131:                                      NS_EVENT_FLAG_CAPTURE);
    1:     }
    1: 
    1:     if (mTextListenerP)
    1:     {
 1418:       piTarget->RemoveEventListenerByIID(mTextListenerP,
    1:                                          NS_GET_IID(nsIDOMTextListener));
    1:     }
    1: 
    1:     if (mCompositionListenerP)
    1:     {
 1418:       piTarget->RemoveEventListenerByIID(mCompositionListenerP,
    1:                                          NS_GET_IID(nsIDOMCompositionListener));
    1:     }
    1: 
    1:     if (mDragListenerP)
    1:     {
20592:       nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(piTarget));
20592:       if (target) {
20671:         target->RemoveEventListener(NS_LITERAL_STRING("draggesture"), mDragListenerP, PR_FALSE);
20592:         target->RemoveEventListener(NS_LITERAL_STRING("dragenter"), mDragListenerP, PR_FALSE);
20592:         target->RemoveEventListener(NS_LITERAL_STRING("dragover"), mDragListenerP, PR_FALSE);
20592:         target->RemoveEventListener(NS_LITERAL_STRING("dragleave"), mDragListenerP, PR_FALSE);
20592:         target->RemoveEventListener(NS_LITERAL_STRING("drop"), mDragListenerP, PR_FALSE);
20592:       }
    1:     }
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsEditor::GetDesiredSpellCheckState()
    1: {
    1:   // Check user override on this element
    1:   if (mSpellcheckCheckboxState != eTriUnset) {
    1:     return (mSpellcheckCheckboxState == eTriTrue);
    1:   }
    1: 
    1:   // Check user preferences
    1:   nsresult rv;
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
    1:   PRInt32 spellcheckLevel = 1;
    1:   if (NS_SUCCEEDED(rv) && prefBranch) {
    1:     prefBranch->GetIntPref("layout.spellcheckDefault", &spellcheckLevel);
    1:   }
    1: 
    1:   if (spellcheckLevel == 0) {
    1:     return PR_FALSE;                    // Spellchecking forced off globally
    1:   }
    1: 
    1:   // Check for password/readonly/disabled, which are not spellchecked
    1:   // regardless of DOM
    1:   PRUint32 flags;
    1:   if (NS_SUCCEEDED(GetFlags(&flags)) &&
    1:       flags & (nsIPlaintextEditor::eEditorPasswordMask |
    1:                nsIPlaintextEditor::eEditorReadonlyMask |
    1:                nsIPlaintextEditor::eEditorDisabledMask)) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   rv = GetPresShell(getter_AddRefs(presShell));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsPresContext* context = presShell->GetPresContext();
    1:     if (context && !context->IsDynamic()) {
    1:         return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   // Check DOM state
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(GetRoot());
    1:   if (!content) {
    1:     return PR_FALSE;
    1:   }
    1: 
16126:   if (content->IsRootOfNativeAnonymousSubtree()) {
    1:     content = content->GetParent();
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNSHTMLElement> element = do_QueryInterface(content);
    1:   if (!element) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRBool enable;
    1:   element->GetSpellcheck(&enable);
    1: 
    1:   return enable;
    1: }
    1: 
    1: NS_IMETHODIMP
22729: nsEditor::PreDestroy(PRBool aDestroyingFrames)
    1: {
    1:   if (mDidPreDestroy)
    1:     return NS_OK;
    1: 
    1:   // Let spellchecker clean up its observers etc. It is important not to
    1:   // actually free the spellchecker here, since the spellchecker could have
    1:   // caused flush notifications, which could have gotten here if a textbox
    1:   // is being removed. Setting the spellchecker to NULL could free the
    1:   // object that is still in use! It will be freed when the editor is
    1:   // destroyed.
    1:   if (mInlineSpellChecker)
22729:     mInlineSpellChecker->Cleanup(aDestroyingFrames);
    1: 
    1:   // tell our listeners that the doc is going away
    1:   NotifyDocumentListeners(eDocumentToBeDestroyed);
    1: 
 6601:   nsCOMPtr<nsINode> document = do_QueryReferent(mDocWeak);
 6601:   if (document)
 6601:     document->RemoveMutationObserver(this);
 6601: 
    1:   // Unregister event listeners
    1:   RemoveEventListeners();
    1:   mActionListeners.Clear();
    1:   mEditorObservers.Clear();
    1:   mDocStateListeners.Clear();
    1:   mInlineSpellChecker = nsnull;
    1: 
    1:   mDidPreDestroy = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetFlags(PRUint32 *aFlags)
    1: {
    1:   *aFlags = mFlags;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetFlags(PRUint32 aFlags)
    1: {
    1:   mFlags = aFlags;
    1: 
    1:   // Changing the flags can change whether spellchecking is on, so re-sync it
    1:   SyncRealTimeSpell();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetIsDocumentEditable(PRBool *aIsDocumentEditable)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDocumentEditable);
    1:   nsCOMPtr<nsIDOMDocument> doc;
    1:   GetDocument(getter_AddRefs(doc));
    1:   *aIsDocumentEditable = doc ? PR_TRUE : PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::GetDocument(nsIDOMDocument **aDoc)
    1: {
    1:   if (!aDoc)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aDoc = nsnull; // init out param
    1:   NS_PRECONDITION(mDocWeak, "bad state, mDocWeak weak pointer not initialized");
    1:   nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(mDocWeak);
    1:   if (!doc) return NS_ERROR_NOT_INITIALIZED;
    1:   NS_ADDREF(*aDoc = doc);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetPresShell(nsIPresShell **aPS)
    1: {
    1:   if (!aPS)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aPS = nsnull; // init out param
    1:   NS_PRECONDITION(mPresShellWeak, "bad state, null mPresShellWeak");
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps) return NS_ERROR_NOT_INITIALIZED;
    1:   NS_ADDREF(*aPS = ps);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: /* attribute string contentsMIMEType; */
    1: NS_IMETHODIMP
    1: nsEditor::GetContentsMIMEType(char * *aContentsMIMEType)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aContentsMIMEType);
    1:   *aContentsMIMEType = ToNewCString(mContentMIMEType);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetContentsMIMEType(const char * aContentsMIMEType)
    1: {
    1:   mContentMIMEType.Assign(aContentsMIMEType ? aContentsMIMEType : "");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetSelectionController(nsISelectionController **aSel)
    1: {
    1:   if (!aSel)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aSel = nsnull; // init out param
    1:   NS_PRECONDITION(mSelConWeak, "bad state, null mSelConWeak");
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryReferent(mSelConWeak);
    1:   if (!selCon) return NS_ERROR_NOT_INITIALIZED;
    1:   NS_ADDREF(*aSel = selCon);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DeleteSelection(EDirection aAction)
    1: {
    1:   return DeleteSelectionImpl(aAction);
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetSelection(nsISelection **aSelection)
    1: {
    1:   if (!aSelection)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aSelection = nsnull;
    1:   nsCOMPtr<nsISelectionController> selcon = do_QueryReferent(mSelConWeak);
    1:   if (!selcon) return NS_ERROR_NOT_INITIALIZED;
    1:   return selcon->GetSelection(nsISelectionController::SELECTION_NORMAL, aSelection);  // does an addref
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DoTransaction(nsITransaction *aTxn)
    1: {
    1: #ifdef NS_DEBUG_EDITOR
    1:   if (gNoisy) { printf("Editor::DoTransaction ----------\n"); }
    1: #endif
    1: 
    1:   nsresult result = NS_OK;
    1:   
    1:   if (mPlaceHolderBatch && !mPlaceHolderTxn)
    1:   {
    1:     // it's pretty darn amazing how many different types of pointers
    1:     // this transaction goes through here.  I bet this is a record.
    1:     
    1:     // We start off with an EditTxn since that's what the factory returns.
 3030:     nsRefPtr<EditTxn> editTxn;
 3030:     result = TransactionFactory::GetNewTransaction(PlaceholderTxn::GetCID(),
 3030:                                                    getter_AddRefs(editTxn));
    1:     if (NS_FAILED(result)) { return result; }
    1:     if (!editTxn) { return NS_ERROR_NULL_POINTER; }
    1: 
    1:     // Then we QI to an nsIAbsorbingTransaction to get at placeholder functionality
    1:     nsCOMPtr<nsIAbsorbingTransaction> plcTxn;
    1:     editTxn->QueryInterface(NS_GET_IID(nsIAbsorbingTransaction), getter_AddRefs(plcTxn));
    1:     // have to use line above instead of "plcTxn = do_QueryInterface(editTxn);"
    1:     // due to our broken interface model for transactions.
    1: 
    1:     // save off weak reference to placeholder txn
    1:     mPlaceHolderTxn = do_GetWeakReference(plcTxn);
    1:     plcTxn->Init(mPlaceHolderName, mSelState, this);
    1:     mSelState = nsnull;  // placeholder txn took ownership of this pointer
    1: 
    1:     // finally we QI to an nsITransaction since that's what DoTransaction() expects
    1:     nsCOMPtr<nsITransaction> theTxn = do_QueryInterface(plcTxn);
    1:     DoTransaction(theTxn);  // we will recurse, but will not hit this case in the nested call
    1: 
    1:     if (mTxnMgr)
    1:     {
    1:       nsCOMPtr<nsITransaction> topTxn;
    1:       result = mTxnMgr->PeekUndoStack(getter_AddRefs(topTxn));
    1:       if (NS_FAILED(result)) return result;
    1:       if (topTxn)
    1:       {
    1:         plcTxn = do_QueryInterface(topTxn);
    1:         if (plcTxn)
    1:         {
    1:           // there is a palceholder transaction on top of the undo stack.  It is 
    1:           // either the one we just created, or an earlier one that we are now merging
    1:           // into.  From here on out remember this placeholder instead of the one
    1:           // we just created.
    1:           mPlaceHolderTxn = do_GetWeakReference(plcTxn);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aTxn)
    1:   {  
    1:     // XXX: Why are we doing selection specific batching stuff here?
    1:     // XXX: Most entry points into the editor have auto variables that
    1:     // XXX: should trigger Begin/EndUpdateViewBatch() calls that will make
    1:     // XXX: these selection batch calls no-ops.
    1:     // XXX:
    1:     // XXX: I suspect that this was placed here to avoid multiple
    1:     // XXX: selection changed notifications from happening until after
    1:     // XXX: the transaction was done. I suppose that can still happen
    1:     // XXX: if an embedding application called DoTransaction() directly
    1:     // XXX: to pump its own transactions through the system, but in that
    1:     // XXX: case, wouldn't we want to use Begin/EndUpdateViewBatch() or
    1:     // XXX: its auto equivalent nsAutoUpdateViewBatch to ensure that
    1:     // XXX: selection listeners have access to accurate frame data?
    1:     // XXX:
    1:     // XXX: Note that if we did add Begin/EndUpdateViewBatch() calls
    1:     // XXX: we will need to make sure that they are disabled during
    1:     // XXX: the init of the editor for text widgets to avoid layout
    1:     // XXX: re-entry during initial reflow. - kin
    1: 
    1:     // get the selection and start a batch change
    1:     nsCOMPtr<nsISelection>selection;
    1:     result = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(result)) { return result; }
    1:     if (!selection) { return NS_ERROR_NULL_POINTER; }
    1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
    1: 
    1:     selPrivate->StartBatchChanges();
    1: 
    1:     if (mTxnMgr) {
    1:       result = mTxnMgr->DoTransaction(aTxn);
    1:     }
    1:     else {
    1:       result = aTxn->DoTransaction();
    1:     }
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = DoAfterDoTransaction(aTxn);
    1:     }
    1: 
    1:     selPrivate->EndBatchChanges(); // no need to check result here, don't lose result of operation
    1:   }
    1:  
    1:   NS_POSTCONDITION((NS_SUCCEEDED(result)), "transaction did not execute properly");
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::EnableUndo(PRBool aEnable)
    1: {
    1:   nsresult result=NS_OK;
    1: 
    1:   if (PR_TRUE==aEnable)
    1:   {
    1:     if (!mTxnMgr)
    1:     {
    1:       mTxnMgr = do_CreateInstance(NS_TRANSACTIONMANAGER_CONTRACTID, &result);
    1:       if (NS_FAILED(result) || !mTxnMgr) {
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:       }
    1:     }
    1:     mTxnMgr->SetMaxTransactionCount(-1);
    1:   }
    1:   else
    1:   { // disable the transaction manager if it is enabled
    1:     if (mTxnMgr)
    1:     {
    1:       mTxnMgr->Clear();
    1:       mTxnMgr->SetMaxTransactionCount(0);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetTransactionManager(nsITransactionManager* *aTxnManager)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aTxnManager);
    1:   
    1:   *aTxnManager = NULL;
    1:   if (!mTxnMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ADDREF(*aTxnManager = mTxnMgr);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetTransactionManager(nsITransactionManager *aTxnManager)
    1: {
    1:   NS_ENSURE_TRUE(aTxnManager, NS_ERROR_FAILURE);
    1: 
    1:   mTxnMgr = aTxnManager;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::Undo(PRUint32 aCount)
    1: {
    1: #ifdef NS_DEBUG_EDITOR
    1:   if (gNoisy) { printf("Editor::Undo ----------\n"); }
    1: #endif
    1: 
    1:   nsresult result = NS_OK;
    1:   ForceCompositionEnd();
    1: 
    1:   PRBool hasTxnMgr, hasTransaction = PR_FALSE;
    1:   CanUndo(&hasTxnMgr, &hasTransaction);
    1:   if (!hasTransaction)
    1:     return result;
    1: 
    1:   nsAutoRules beginRulesSniffing(this, kOpUndo, nsIEditor::eNone);
    1: 
    1:   if ((nsITransactionManager *)nsnull!=mTxnMgr.get())
    1:   {
    1:     PRUint32 i=0;
    1:     for ( ; i<aCount; i++)
    1:     {
    1:       result = mTxnMgr->UndoTransaction();
    1: 
    1:       if (NS_SUCCEEDED(result))
    1:         result = DoAfterUndoTransaction();
    1:           
    1:       if (NS_FAILED(result))
    1:         break;
    1:     }
    1:   }
    1: 
    1:   NotifyEditorObservers();  
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CanUndo(PRBool *aIsEnabled, PRBool *aCanUndo)
    1: {
    1:   if (!aIsEnabled || !aCanUndo)
    1:      return NS_ERROR_NULL_POINTER;
    1:   *aIsEnabled = ((PRBool)((nsITransactionManager *)0!=mTxnMgr.get()));
    1:   if (*aIsEnabled)
    1:   {
    1:     PRInt32 numTxns=0;
    1:     mTxnMgr->GetNumberOfUndoItems(&numTxns);
    1:     *aCanUndo = ((PRBool)(0!=numTxns));
    1:   }
    1:   else {
    1:     *aCanUndo = PR_FALSE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::Redo(PRUint32 aCount)
    1: {
    1: #ifdef NS_DEBUG_EDITOR
    1:   if (gNoisy) { printf("Editor::Redo ----------\n"); }
    1: #endif
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   PRBool hasTxnMgr, hasTransaction = PR_FALSE;
    1:   CanRedo(&hasTxnMgr, &hasTransaction);
    1:   if (!hasTransaction)
    1:     return result;
    1: 
    1:   nsAutoRules beginRulesSniffing(this, kOpRedo, nsIEditor::eNone);
    1: 
    1:   if ((nsITransactionManager *)nsnull!=mTxnMgr.get())
    1:   {
    1:     PRUint32 i=0;
    1:     for ( ; i<aCount; i++)
    1:     {
    1:       result = mTxnMgr->RedoTransaction();
    1: 
    1:       if (NS_SUCCEEDED(result))
    1:         result = DoAfterRedoTransaction();
    1: 
    1:       if (NS_FAILED(result))
    1:         break;
    1:     }
    1:   }
    1: 
    1:   NotifyEditorObservers();  
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CanRedo(PRBool *aIsEnabled, PRBool *aCanRedo)
    1: {
    1:   if (!aIsEnabled || !aCanRedo)
    1:      return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aIsEnabled = ((PRBool)((nsITransactionManager *)0!=mTxnMgr.get()));
    1:   if (*aIsEnabled)
    1:   {
    1:     PRInt32 numTxns=0;
    1:     mTxnMgr->GetNumberOfRedoItems(&numTxns);
    1:     *aCanRedo = ((PRBool)(0!=numTxns));
    1:   }
    1:   else {
    1:     *aCanRedo = PR_FALSE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::BeginTransaction()
    1: {
    1:   BeginUpdateViewBatch();
    1: 
    1:   if ((nsITransactionManager *)nsnull!=mTxnMgr.get())
    1:   {
    1:     mTxnMgr->BeginBatch();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::EndTransaction()
    1: {
    1:   if ((nsITransactionManager *)nsnull!=mTxnMgr.get())
    1:   {
    1:     mTxnMgr->EndBatch();
    1:   }
    1: 
    1:   EndUpdateViewBatch();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // These two routines are similar to the above, but do not use
    1: // the transaction managers batching feature.  Instead we use
    1: // a placeholder transaction to wrap up any further transaction
    1: // while the batch is open.  The advantage of this is that
    1: // placeholder transactions can later merge, if needed.  Merging
    1: // is unavailable between transaction manager batches.
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::BeginPlaceHolderTransaction(nsIAtom *aName)
    1: {
    1:   NS_PRECONDITION(mPlaceHolderBatch >= 0, "negative placeholder batch count!");
    1:   if (!mPlaceHolderBatch)
    1:   {
    1:     // time to turn on the batch
    1:     BeginUpdateViewBatch();
    1:     mPlaceHolderTxn = nsnull;
    1:     mPlaceHolderName = aName;
    1:     nsCOMPtr<nsISelection> selection;
    1:     nsresult res = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(res)) return res;
    1:     mSelState = new nsSelectionState();
    1:     if (!mSelState)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     mSelState->SaveSelection(selection);
    1:   }
    1:   mPlaceHolderBatch++;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::EndPlaceHolderTransaction()
    1: {
    1:   NS_PRECONDITION(mPlaceHolderBatch > 0, "zero or negative placeholder batch count when ending batch!");
    1:   if (mPlaceHolderBatch == 1)
    1:   {
    1:     nsCOMPtr<nsISelection>selection;
23383:     GetSelection(getter_AddRefs(selection));
    1: 
    1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
    1: 
    1:    // By making the assumption that no reflow happens during the calls
    1:    // to EndUpdateViewBatch and ScrollSelectionIntoView, we are able to
    1:    // allow the selection to cache a frame offset which is used by the
    1:    // caret drawing code. We only enable this cache here; at other times,
    1:    // we have no way to know whether reflow invalidates it
    1:    // See bugs 35296 and 199412.
    1:     if (selPrivate) {
    1:       selPrivate->SetCanCacheFrameOffset(PR_TRUE);
    1:     }
    1:     
    1:     // time to turn off the batch
    1:     EndUpdateViewBatch();
    1:     // make sure selection is in view
12392: 
12392:     // After ScrollSelectionIntoView(), the pending notifications might be
12392:     // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
    1:     ScrollSelectionIntoView(PR_FALSE);
    1: 
    1:     // cached for frame offset are Not available now
    1:     if (selPrivate) {
    1:       selPrivate->SetCanCacheFrameOffset(PR_FALSE);
    1:     }
    1: 
    1:     if (mSelState)
    1:     {
    1:       // we saved the selection state, but never got to hand it to placeholder 
    1:       // (else we ould have nulled out this pointer), so destroy it to prevent leaks.
    1:       delete mSelState;
    1:       mSelState = nsnull;
    1:     }
    1:     if (mPlaceHolderTxn)  // we might have never made a placeholder if no action took place
    1:     {
    1:       nsCOMPtr<nsIAbsorbingTransaction> plcTxn = do_QueryReferent(mPlaceHolderTxn);
    1:       if (plcTxn) 
    1:       {
    1:         plcTxn->EndPlaceHolderBatch();
    1:       }
    1:       else  
    1:       {
    1:         // in the future we will check to make sure undo is off here,
    1:         // since that is the only known case where the placeholdertxn would disappear on us.
    1:         // For now just removing the assert.
    1:       }
    1:       // notify editor observers of action unless it is uncommitted IME
    1:       if (!mInIMEMode) NotifyEditorObservers();
    1:     }
    1:   }
    1:   mPlaceHolderBatch--;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::ShouldTxnSetSelection(PRBool *aResult)
    1: {
    1:   if (!aResult) return NS_ERROR_NULL_POINTER;
    1:   *aResult = mShouldTxnSetSelection;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP  
    1: nsEditor::SetShouldTxnSetSelection(PRBool aShould)
    1: {
    1:   mShouldTxnSetSelection = aShould;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetDocumentIsEmpty(PRBool *aDocumentIsEmpty)
    1: {
    1:   *aDocumentIsEmpty = PR_TRUE;
    1: 
    1:   nsIDOMElement *rootElement = GetRoot(); 
    1:   if (!rootElement)
    1:     return NS_ERROR_NULL_POINTER; 
    1: 
    1:   PRBool hasChildNodes;
    1:   nsresult res = rootElement->HasChildNodes(&hasChildNodes);
    1: 
    1:   *aDocumentIsEmpty = !hasChildNodes;
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: // XXX: the rule system should tell us which node to select all on (ie, the root, or the body)
    1: NS_IMETHODIMP nsEditor::SelectAll()
    1: {
    1:   if (!mDocWeak || !mPresShellWeak) { return NS_ERROR_NOT_INITIALIZED; }
    1:   ForceCompositionEnd();
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryReferent(mSelConWeak);
    1:   if (!selCon) return NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult result = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
    1:   if (NS_SUCCEEDED(result) && selection)
    1:   {
    1:     result = SelectEntireDocument(selection);
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::BeginningOfDocument()
    1: {
    1:   if (!mDocWeak || !mPresShellWeak) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   // get the selection
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult result = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(result))
    1:     return result;
    1:   if (!selection)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1:     
    1:   // get the root element 
    1:   nsIDOMElement *rootElement = GetRoot(); 
    1:   if (!rootElement)
    1:     return NS_ERROR_NULL_POINTER; 
    1:   
    1:   // find first editable thingy
    1:   nsCOMPtr<nsIDOMNode> firstNode;
    1:   result = GetFirstEditableNode(rootElement, address_of(firstNode));
    1:   if (firstNode)
    1:   {
    1:     // if firstNode is text, set selection to beginning of the text node
    1:     if (IsTextNode(firstNode)) 
    1:     {
    1:       result = selection->Collapse(firstNode, 0);
    1:     }
    1:     else
    1:     { // otherwise, it's a leaf node and we set the selection just in front of it
    1:       nsCOMPtr<nsIDOMNode> parentNode;
    1:       result = firstNode->GetParentNode(getter_AddRefs(parentNode));
    1:       if (NS_FAILED(result)) { return result; }
    1:       if (!parentNode) { return NS_ERROR_NULL_POINTER; }
    1:       PRInt32 offsetInParent;
    1:       result = nsEditor::GetChildOffset(firstNode, parentNode, offsetInParent);
    1:       if (NS_FAILED(result)) return result;
    1:       result = selection->Collapse(parentNode, offsetInParent);
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // just the root node, set selection to inside the root
    1:     result = selection->Collapse(rootElement, 0);
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::EndOfDocument() 
    1: { 
    1:   if (!mDocWeak || !mPresShellWeak) { return NS_ERROR_NOT_INITIALIZED; } 
    1:   nsresult res; 
    1: 
    1:   // get selection 
    1:   nsCOMPtr<nsISelection> selection; 
    1:   res = GetSelection(getter_AddRefs(selection)); 
    1:   if (NS_FAILED(res)) return res; 
    1:   if (!selection)   return NS_ERROR_NULL_POINTER; 
    1:   
    1:   // get the root element 
    1:   nsIDOMElement *rootElement = GetRoot(); 
    1:   if (!rootElement)
    1:     return NS_ERROR_NULL_POINTER; 
    1: 
    1:   // get the length of the rot element 
    1:   PRUint32 len; 
    1:   res = GetLengthOfDOMNode(rootElement, len); 
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // set the selection to after the last child of the root element 
    1:   return selection->Collapse(rootElement, (PRInt32)len); 
    1: } 
    1:   
    1: NS_IMETHODIMP
    1: nsEditor::GetDocumentModified(PRBool *outDocModified)
    1: {
    1:   if (!outDocModified)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRInt32  modCount = 0;
    1:   GetModificationCount(&modCount);
    1: 
    1:   *outDocModified = (modCount != 0);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetDocumentCharacterSet(nsACString &characterSet)
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell;
    1: 
    1:   nsresult rv = GetPresShell(getter_AddRefs(presShell));
    1:   if (NS_SUCCEEDED(rv))
    1:   {
    1:     nsIDocument *doc = presShell->GetDocument();
    1:     if (doc) {
    1:       characterSet = doc->GetDocumentCharacterSet();
    1:       return NS_OK;
    1:     }
    1:     rv = NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetDocumentCharacterSet(const nsACString& characterSet)
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   nsresult rv = GetPresShell(getter_AddRefs(presShell));
    1:   if (NS_SUCCEEDED(rv))
    1:   {
    1:     nsIDocument *doc = presShell->GetDocument();
    1:     if (doc) {
    1:       doc->SetDocumentCharacterSet(characterSet);
    1:       return NS_OK;
    1:     }
    1:     rv = NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: //
    1: // Get an appropriate wrap width for saving this document.
    1: // This class just uses a pref; subclasses are expected to
    1: // override if they know more about the document.
    1: //
    1: NS_IMETHODIMP
    1: nsEditor::GetWrapWidth(PRInt32 *aWrapColumn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aWrapColumn);
    1:   *aWrapColumn = 72;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
    1:   if (NS_SUCCEEDED(rv) && prefBranch)
    1:     (void) prefBranch->GetIntPref("editor.htmlWrapColumn", aWrapColumn);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::Cut()
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CanCut(PRBool *aCanCut)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::Copy()
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CanCopy(PRBool *aCanCut)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::Paste(PRInt32 aSelectionType)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CanPaste(PRInt32 aSelectionType, PRBool *aCanPaste)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CanDrag(nsIDOMEvent *aEvent, PRBool *aCanDrag)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DoDrag(nsIDOMEvent *aEvent)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::InsertFromDrop(nsIDOMEvent *aEvent)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::SetAttribute(nsIDOMElement *aElement, const nsAString & aAttribute, const nsAString & aValue)
    1: {
 3030:   nsRefPtr<ChangeAttributeTxn> txn;
 3030:   nsresult result = CreateTxnForSetAttribute(aElement, aAttribute, aValue,
 3030:                                              getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::GetAttributeValue(nsIDOMElement *aElement, 
    1:                             const nsAString & aAttribute, 
    1:                             nsAString & aResultValue, 
    1:                             PRBool *aResultIsSet)
    1: {
    1:   if (!aResultIsSet)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aResultIsSet=PR_FALSE;
    1:   nsresult result=NS_OK;
    1:   if (aElement)
    1:   {
    1:     nsCOMPtr<nsIDOMAttr> attNode;
    1:     result = aElement->GetAttributeNode(aAttribute, getter_AddRefs(attNode));
    1:     if ((NS_SUCCEEDED(result)) && attNode)
    1:     {
    1:       attNode->GetSpecified(aResultIsSet);
    1:       attNode->GetValue(aResultValue);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::RemoveAttribute(nsIDOMElement *aElement, const nsAString& aAttribute)
    1: {
 3030:   nsRefPtr<ChangeAttributeTxn> txn;
 3030:   nsresult result = CreateTxnForRemoveAttribute(aElement, aAttribute,
 3030:                                                 getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::MarkNodeDirty(nsIDOMNode* aNode)
    1: {  
    1:   //  mark the node dirty.
    1:   nsCOMPtr<nsIDOMElement> element (do_QueryInterface(aNode));
    1:   if (element)
    1:     element->SetAttribute(NS_LITERAL_STRING("_moz_dirty"), EmptyString());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::GetInlineSpellChecker(PRBool autoCreate,
    1:                                               nsIInlineSpellChecker ** aInlineSpellChecker)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aInlineSpellChecker);
    1: 
    1:   if (mDidPreDestroy) {
    1:     // Don't allow people to get or create the spell checker once the editor
    1:     // is going away.
    1:     *aInlineSpellChecker = nsnull;
    1:     return autoCreate ? NS_ERROR_NOT_AVAILABLE : NS_OK;
    1:   }
    1: 
15173:   nsresult rv;
    1:   if (!mInlineSpellChecker && autoCreate) {
    1:     mInlineSpellChecker = do_CreateInstance(MOZ_INLINESPELLCHECKER_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
15173:   }
15173: 
15173:   if (mInlineSpellChecker) {
    1:     rv = mInlineSpellChecker->Init(this);
    1:     if (NS_FAILED(rv))
    1:       mInlineSpellChecker = nsnull;
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aInlineSpellChecker = mInlineSpellChecker);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::SyncRealTimeSpell()
    1: {
    1:   PRBool enable = GetDesiredSpellCheckState();
    1: 
    1:   nsCOMPtr<nsIInlineSpellChecker> spellChecker;
    1:   GetInlineSpellChecker(enable, getter_AddRefs(spellChecker));
    1: 
    1:   if (spellChecker) {
    1:     spellChecker->SetEnableRealTimeSpell(enable);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::SetSpellcheckUserOverride(PRBool enable)
    1: {
    1:   mSpellcheckCheckboxState = enable ? eTriTrue : eTriFalse;
    1: 
    1:   return SyncRealTimeSpell();
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  main node manipulation routines 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP nsEditor::CreateNode(const nsAString& aTag,
    1:                                    nsIDOMNode *    aParent,
    1:                                    PRInt32         aPosition,
    1:                                    nsIDOMNode **   aNewNode)
    1: {
    1:   PRInt32 i;
    1: 
    1:   nsAutoRules beginRulesSniffing(this, kOpCreateNode, nsIEditor::eNext);
    1:   
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillCreateNode(aTag, aParent, aPosition);
    1: 
 3030:   nsRefPtr<CreateElementTxn> txn;
 3030:   nsresult result = CreateTxnForCreateElement(aTag, aParent, aPosition,
 3030:                                               getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result)) 
    1:   {
    1:     result = DoTransaction(txn);  
    1:     if (NS_SUCCEEDED(result)) 
    1:     {
    1:       result = txn->GetNewNode(aNewNode);
    1:       NS_ASSERTION((NS_SUCCEEDED(result)), "GetNewNode can't fail if txn::DoTransaction succeeded.");
    1:     }
    1:   }
    1:   
    1:   mRangeUpdater.SelAdjCreateNode(aParent, aPosition);
    1:   
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidCreateNode(aTag, *aNewNode, aParent, aPosition, result);
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::InsertNode(nsIDOMNode * aNode,
    1:                                    nsIDOMNode * aParent,
    1:                                    PRInt32      aPosition)
    1: {
    1:   PRInt32 i;
    1:   nsAutoRules beginRulesSniffing(this, kOpInsertNode, nsIEditor::eNext);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillInsertNode(aNode, aParent, aPosition);
    1: 
 3030:   nsRefPtr<InsertElementTxn> txn;
 3030:   nsresult result = CreateTxnForInsertElement(aNode, aParent, aPosition,
 3030:                                               getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1: 
    1:   mRangeUpdater.SelAdjInsertNode(aParent, aPosition);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidInsertNode(aNode, aParent, aPosition, result);
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::SplitNode(nsIDOMNode * aNode,
    1:                     PRInt32      aOffset,
    1:                     nsIDOMNode **aNewLeftNode)
    1: {
    1:   PRInt32 i;
    1:   nsAutoRules beginRulesSniffing(this, kOpSplitNode, nsIEditor::eNext);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillSplitNode(aNode, aOffset);
    1: 
 3030:   nsRefPtr<SplitElementTxn> txn;
 3030:   nsresult result = CreateTxnForSplitNode(aNode, aOffset, getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  
    1:   {
    1:     result = DoTransaction(txn);
    1:     if (NS_SUCCEEDED(result))
    1:     {
    1:       result = txn->GetNewNode(aNewLeftNode);
    1:       NS_ASSERTION((NS_SUCCEEDED(result)), "result must succeeded for GetNewNode");
    1:     }
    1:   }
    1: 
    1:   mRangeUpdater.SelAdjSplitNode(aNode, aOffset, *aNewLeftNode);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:   {
    1:     nsIDOMNode *ptr = *aNewLeftNode;
    1:     mActionListeners[i]->DidSplitNode(aNode, aOffset, ptr, result);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::JoinNodes(nsIDOMNode * aLeftNode,
    1:                     nsIDOMNode * aRightNode,
    1:                     nsIDOMNode * aParent)
    1: {
    1:   PRInt32 i, offset;
    1:   nsAutoRules beginRulesSniffing(this, kOpJoinNode, nsIEditor::ePrevious);
    1: 
    1:   // remember some values; later used for saved selection updating.
    1:   // find the offset between the nodes to be joined.
    1:   nsresult result = GetChildOffset(aRightNode, aParent, offset);
    1:   if (NS_FAILED(result)) return result;
    1:   // find the number of children of the lefthand node
    1:   PRUint32 oldLeftNodeLen;
    1:   result = GetLengthOfDOMNode(aLeftNode, oldLeftNodeLen);
    1:   if (NS_FAILED(result)) return result;
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillJoinNodes(aLeftNode, aRightNode, aParent);
    1: 
 3030:   nsRefPtr<JoinElementTxn> txn;
 3030:   result = CreateTxnForJoinNode(aLeftNode, aRightNode, getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1: 
    1:   mRangeUpdater.SelAdjJoinNodes(aLeftNode, aRightNode, aParent, offset, (PRInt32)oldLeftNodeLen);
    1:   
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidJoinNodes(aLeftNode, aRightNode, aParent, result);
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::DeleteNode(nsIDOMNode * aElement)
    1: {
    1:   PRInt32 i, offset;
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   nsAutoRules beginRulesSniffing(this, kOpCreateNode, nsIEditor::ePrevious);
    1: 
    1:   // save node location for selection updating code.
    1:   nsresult result = GetNodeLocation(aElement, address_of(parent), &offset);
    1:   if (NS_FAILED(result)) return result;
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillDeleteNode(aElement);
    1: 
 3030:   nsRefPtr<DeleteElementTxn> txn;
 3030:   result = CreateTxnForDeleteElement(aElement, getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidDeleteNode(aElement, result);
    1: 
    1:   return result;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // ReplaceContainer: replace inNode with a new node (outNode) which is contructed 
    1: //                   to be of type aNodeType.  Put inNodes children into outNode.
    1: //                   Callers responsibility to make sure inNode's children can 
    1: //                   go in outNode.
    1: nsresult
    1: nsEditor::ReplaceContainer(nsIDOMNode *inNode, 
    1:                            nsCOMPtr<nsIDOMNode> *outNode, 
    1:                            const nsAString &aNodeType,
    1:                            const nsAString *aAttribute,
    1:                            const nsAString *aValue,
    1:                            PRBool aCloneAttributes)
    1: {
    1:   if (!inNode || !outNode)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // create new container
    1:   nsCOMPtr<nsIContent> newContent;
    1: 
    1:   //new call to use instead to get proper HTML element, bug# 39919
    1:   res = CreateHTMLContent(aNodeType, getter_AddRefs(newContent));
    1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(newContent);
    1:   if (NS_FAILED(res)) return res;
    1:     *outNode = do_QueryInterface(elem);
    1:   
    1:   // set attribute if needed
    1:   if (aAttribute && aValue && !aAttribute->IsEmpty())
    1:   {
    1:     res = elem->SetAttribute(*aAttribute, *aValue);
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1:   if (aCloneAttributes)
    1:   {
    1:     nsCOMPtr<nsIDOMNode>newNode = do_QueryInterface(elem);
    1:     res = CloneAttributes(newNode, inNode);
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1:   
    1:   // notify our internal selection state listener
    1:   // (Note: A nsAutoSelectionReset object must be created
    1:   //  before calling this to initialize mRangeUpdater)
    1:   nsAutoReplaceContainerSelNotify selStateNotify(mRangeUpdater, inNode, *outNode);
    1:   {
    1:     nsAutoTxnsConserveSelection conserveSelection(this);
    1:     nsCOMPtr<nsIDOMNode> child;
    1:     PRBool bHasMoreChildren;
    1:     inNode->HasChildNodes(&bHasMoreChildren);
    1:     while (bHasMoreChildren)
    1:     {
    1:       inNode->GetFirstChild(getter_AddRefs(child));
    1:       res = DeleteNode(child);
    1:       if (NS_FAILED(res)) return res;
    1: 
    1:       res = InsertNode(child, *outNode, -1);
    1:       if (NS_FAILED(res)) return res;
    1:       inNode->HasChildNodes(&bHasMoreChildren);
    1:     }
    1:   }
    1:   // insert new container into tree
    1:   res = InsertNode( *outNode, parent, offset);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   // delete old container
    1:   return DeleteNode(inNode);
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // RemoveContainer: remove inNode, reparenting its children into their
    1: //                  the parent of inNode
    1: //
    1: nsresult
    1: nsEditor::RemoveContainer(nsIDOMNode *inNode)
    1: {
    1:   if (!inNode)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   
    1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   // loop through the child nodes of inNode and promote them
    1:   // into inNode's parent.
    1:   PRBool bHasMoreChildren;
    1:   inNode->HasChildNodes(&bHasMoreChildren);
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   res = inNode->GetChildNodes(getter_AddRefs(nodeList));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!nodeList) return NS_ERROR_NULL_POINTER;
    1:   PRUint32 nodeOrigLen;
    1:   nodeList->GetLength(&nodeOrigLen);
    1: 
    1:   // notify our internal selection state listener
    1:   nsAutoRemoveContainerSelNotify selNotify(mRangeUpdater, inNode, parent, offset, nodeOrigLen);
    1:                                    
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   while (bHasMoreChildren)
    1:   {
    1:     inNode->GetLastChild(getter_AddRefs(child));
    1:     res = DeleteNode(child);
    1:     if (NS_FAILED(res)) return res;
    1:     res = InsertNode(child, parent, offset);
    1:     if (NS_FAILED(res)) return res;
    1:     inNode->HasChildNodes(&bHasMoreChildren);
    1:   }
    1:   return DeleteNode(inNode);
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // InsertContainerAbove:  insert a new parent for inNode, returned in outNode,
    1: //                   which is contructed to be of type aNodeType.  outNode becomes
    1: //                   a child of inNode's earlier parent.
    1: //                   Callers responsibility to make sure inNode's can be child
    1: //                   of outNode, and outNode can be child of old parent.
    1: nsresult
    1: nsEditor::InsertContainerAbove( nsIDOMNode *inNode, 
    1:                                 nsCOMPtr<nsIDOMNode> *outNode, 
    1:                                 const nsAString &aNodeType,
    1:                                 const nsAString *aAttribute,
    1:                                 const nsAString *aValue)
    1: {
    1:   if (!inNode || !outNode)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   // create new container
    1:   nsCOMPtr<nsIContent> newContent;
    1: 
    1:   //new call to use instead to get proper HTML element, bug# 39919
    1:   res = CreateHTMLContent(aNodeType, getter_AddRefs(newContent));
    1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(newContent);
    1:   if (NS_FAILED(res)) return res;
    1:   *outNode = do_QueryInterface(elem);
    1:   
    1:   // set attribute if needed
    1:   if (aAttribute && aValue && !aAttribute->IsEmpty())
    1:   {
    1:     res = elem->SetAttribute(*aAttribute, *aValue);
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1:   
    1:   // notify our internal selection state listener
    1:   nsAutoInsertContainerSelNotify selNotify(mRangeUpdater);
    1:   
    1:   // put inNode in new parent, outNode
    1:   res = DeleteNode(inNode);
    1:   if (NS_FAILED(res)) return res;
    1: 
    1:   {
    1:     nsAutoTxnsConserveSelection conserveSelection(this);
    1:     res = InsertNode(inNode, *outNode, 0);
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1: 
    1:   // put new parent in doc
    1:   return InsertNode(*outNode, parent, offset);
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // MoveNode:  move aNode to {aParent,aOffset}
    1: nsresult
    1: nsEditor::MoveNode(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aOffset)
    1: {
    1:   if (!aNode || !aParent)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIDOMNode> oldParent;
    1:   PRInt32 oldOffset;
    1:   nsresult res = GetNodeLocation(aNode, address_of(oldParent), &oldOffset);
    1:   
    1:   if (aOffset == -1)
    1:   {
    1:     PRUint32 unsignedOffset;
    1:     // magic value meaning "move to end of aParent"
    1:     res = GetLengthOfDOMNode(aParent, unsignedOffset);
    1:     if (NS_FAILED(res)) return res;
    1:     aOffset = (PRInt32)unsignedOffset;
    1:   }
    1:   
    1:   // don't do anything if it's already in right place
    1:   if ((aParent == oldParent.get()) && (oldOffset == aOffset)) return NS_OK;
    1:   
    1:   // notify our internal selection state listener
    1:   nsAutoMoveNodeSelNotify selNotify(mRangeUpdater, oldParent, oldOffset, aParent, aOffset);
    1:   
    1:   // need to adjust aOffset if we are moving aNode further along in its current parent
    1:   if ((aParent == oldParent.get()) && (oldOffset < aOffset)) 
    1:   {
    1:     aOffset--;  // this is because when we delete aNode, it will make the offsets after it off by one
    1:   }
    1: 
    1:   // put aNode in new parent
    1:   res = DeleteNode(aNode);
    1:   if (NS_FAILED(res)) return res;
    1:   return InsertNode(aNode, aParent, aOffset);
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  editor observer maintainance
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::AddEditorObserver(nsIEditorObserver *aObserver)
    1: {
    1:   // we don't keep ownership of the observers.  They must
    1:   // remove themselves as observers before they are destroyed.
    1:   
    1:   if (!aObserver)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Make sure the listener isn't already on the list
    1:   if (mEditorObservers.IndexOf(aObserver) == -1) 
    1:   {
    1:     if (!mEditorObservers.AppendObject(aObserver))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::RemoveEditorObserver(nsIEditorObserver *aObserver)
    1: {
    1:   if (!aObserver)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!mEditorObservers.RemoveObject(aObserver))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsEditor::NotifyEditorObservers(void)
    1: {
    1:   for (PRInt32 i = 0; i < mEditorObservers.Count(); i++)
    1:     mEditorObservers[i]->EditAction();
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  action listener maintainance
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::AddEditActionListener(nsIEditActionListener *aListener)
    1: {
    1:   if (!aListener)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Make sure the listener isn't already on the list
    1:   if (mActionListeners.IndexOf(aListener) == -1) 
    1:   {
    1:     if (!mActionListeners.AppendObject(aListener))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::RemoveEditActionListener(nsIEditActionListener *aListener)
    1: {
    1:   if (!aListener)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!mActionListeners.RemoveObject(aListener))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  docstate listener maintainance
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::AddDocumentStateListener(nsIDocumentStateListener *aListener)
    1: {
    1:   if (!aListener)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   if (mDocStateListeners.IndexOf(aListener) == -1)
    1:   {
    1:     if (!mDocStateListeners.AppendObject(aListener))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::RemoveDocumentStateListener(nsIDocumentStateListener *aListener)
    1: {
    1:   if (!aListener)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   if (!mDocStateListeners.RemoveObject(aListener))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  misc 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP nsEditor::OutputToString(const nsAString& aFormatType,
    1:                                        PRUint32 aFlags,
    1:                                        nsAString& aOutputString)
    1: {
    1:   // these should be implemented by derived classes.
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::OutputToStream(nsIOutputStream* aOutputStream,
    1:                          const nsAString& aFormatType,
    1:                          const nsACString& aCharsetOverride,
    1:                          PRUint32 aFlags)
    1: {
    1:   // these should be implemented by derived classes.
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DumpContentTree()
    1: {
    1: #ifdef DEBUG
    1:   nsCOMPtr<nsIContent> root = do_QueryInterface(mRootElement);
    1:   if (root)  root->List(stdout);
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DebugDumpContent()
    1: {
    1: #ifdef DEBUG
    1:   nsCOMPtr<nsIDOMHTMLDocument> doc = do_QueryReferent(mDocWeak);
    1:   if (!doc) return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsCOMPtr<nsIDOMHTMLElement>bodyElem;
    1:   doc->GetBody(getter_AddRefs(bodyElem));
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(bodyElem);
    1:   if (content)
    1:     content->List();
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DebugUnitTests(PRInt32 *outNumTests, PRInt32 *outNumTestsFailed)
    1: {
    1: #ifdef DEBUG
    1:   NS_NOTREACHED("This should never get called. Overridden by subclasses");
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  support for selection preservation
    1: #pragma mark -
    1: #endif
    1: 
    1: PRBool   
    1: nsEditor::ArePreservingSelection()
    1: {
    1:   return !(mSavedSel.IsEmpty());
    1: }
    1: 
    1: nsresult 
    1: nsEditor::PreserveSelectionAcrossActions(nsISelection *aSel)
    1: {
    1:   mSavedSel.SaveSelection(aSel);
    1:   mRangeUpdater.RegisterSelectionState(mSavedSel);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::RestorePreservedSelection(nsISelection *aSel)
    1: {
    1:   if (mSavedSel.IsEmpty()) return NS_ERROR_FAILURE;
    1:   mSavedSel.RestoreSelection(aSel);
    1:   StopPreservingSelection();
    1:   return NS_OK;
    1: }
    1: 
    1: void     
    1: nsEditor::StopPreservingSelection()
    1: {
    1:   mRangeUpdater.DropSelectionState(mSavedSel);
    1:   mSavedSel.MakeEmpty();
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsIEditorIMESupport 
    1: #pragma mark -
    1: #endif
    1: 
    1: //
    1: // The BeingComposition method is called from the Editor Composition event listeners.
    1: //
    1: NS_IMETHODIMP
    1: nsEditor::QueryComposition(nsTextEventReply* aReply)
    1: {
    1:   nsresult result;
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsCOMPtr<nsISelectionController> selcon = do_QueryReferent(mSelConWeak);
    1:   if (selcon)
    1:     selcon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
    1: 
    1:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps) return NS_ERROR_NOT_INITIALIZED;
15969:   nsRefPtr<nsCaret> caretP; 
    1:   result = ps->GetCaret(getter_AddRefs(caretP));
    1:   
    1:   if (NS_SUCCEEDED(result) && caretP) {
    1:     if (aReply) {
    1:       caretP->SetCaretDOMSelection(selection);
    1: 
    1:       // XXX_kin: BEGIN HACK! HACK! HACK!
    1:       // XXX_kin:
    1:       // XXX_kin: This is lame! The IME stuff needs caret coordinates
    1:       // XXX_kin: synchronously, but the editor could be using async
    1:       // XXX_kin: updates (reflows and paints) for performance reasons.
    1:       // XXX_kin: In order to give IME what it needs, we have to temporarily
    1:       // XXX_kin: switch to sync updating during this call so that the
    1:       // XXX_kin: nsAutoUpdateViewBatch can force sync reflows and paints
    1:       // XXX_kin: so that we get back accurate caret coordinates.
    1: 
    1:       PRUint32 flags = 0;
    1: 
    1:       if (NS_SUCCEEDED(GetFlags(&flags)) &&
    1:           (flags & nsIPlaintextEditor::eEditorUseAsyncUpdatesMask))
    1:       {
    1:         PRBool restoreFlags = PR_FALSE;
    1: 
    1:         if (NS_SUCCEEDED(SetFlags(flags & (~nsIPlaintextEditor::eEditorUseAsyncUpdatesMask))))
    1:         {
    1:            // Scope the viewBatch within this |if| block so that we
    1:            // force synchronous reflows and paints before restoring
    1:            // our editor flags below.
    1: 
    1:            nsAutoUpdateViewBatch viewBatch(this);
    1:            restoreFlags = PR_TRUE;
    1:         }
    1: 
    1:         // Restore the previous set of flags!
    1: 
    1:         if (restoreFlags)
    1:           SetFlags(flags);
    1:       }
    1: 
    1: 
    1:       // XXX_kin: END HACK! HACK! HACK!
    1: 
16305:       nsIView *view = nsnull;
23738:       nsRect rect;
16305:       result =
16603:         caretP->GetCaretCoordinates(nsCaret::eRenderingViewCoordinates,
16305:                                     selection,
23738:                                     &rect,
16305:                                     &(aReply->mCursorIsCollapsed),
16305:                                     &view);
23738:       aReply->mCursorPosition =
23738:         nsRect::ToOutsidePixels(rect,
23738:                                 ps->GetPresContext()->AppUnitsPerDevPixel());
16305:       if (NS_SUCCEEDED(result) && view)
16305:         aReply->mReferenceWidget = view->GetWidget();
    1:     }
    1:   }
    1:   return result;
    1: }
23738: 
    1: NS_IMETHODIMP
    1: nsEditor::BeginComposition(nsTextEventReply* aReply)
    1: {
    1: #ifdef DEBUG_tague
    1:   printf("nsEditor::StartComposition\n");
    1: #endif
    1:   nsresult ret = QueryComposition(aReply);
    1:   mInIMEMode = PR_TRUE;
    1:   if (mPhonetic)
    1:     mPhonetic->Truncate(0);
    1: 
    1:   return ret;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::EndComposition(void)
    1: {
    1:   if (!mInIMEMode) return NS_OK; // nothing to do
    1:   
    1:   nsresult result = NS_OK;
    1: 
    1:   // commit the IME transaction..we can get at it via the transaction mgr.
    1:   // Note that this means IME won't work without an undo stack!
    1:   if (mTxnMgr) 
    1:   {
    1:     nsCOMPtr<nsITransaction> txn;
    1:     result = mTxnMgr->PeekUndoStack(getter_AddRefs(txn));  
    1:     nsCOMPtr<nsIAbsorbingTransaction> plcTxn = do_QueryInterface(txn);
    1:     if (plcTxn)
    1:     {
    1:       result = plcTxn->Commit();
    1:     }
    1:   }
    1: 
    1:   /* reset the data we need to construct a transaction */
    1:   mIMETextNode = do_QueryInterface(nsnull);
    1:   mIMETextOffset = 0;
    1:   mIMEBufferLength = 0;
    1:   mInIMEMode = PR_FALSE;
    1:   mIsIMEComposing = PR_FALSE;
    1: 
    1:   // notify editor observers of action
    1:   NotifyEditorObservers();
    1: 
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetCompositionString(const nsAString& aCompositionString, nsIPrivateTextRangeList* aTextRangeList,nsTextEventReply* aReply)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetPhonetic(nsAString& aPhonetic)
    1: {
    1:   if (mPhonetic)
    1:     aPhonetic = *mPhonetic;
    1:   else
    1:     aPhonetic.Truncate(0);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: static nsresult
    1: GetEditorContentWindow(nsIPresShell *aPresShell, nsIDOMElement *aRoot, nsIWidget **aResult)
    1: {
    1:   if (!aPresShell || !aRoot || !aResult)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aResult = 0;
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aRoot);
    1: 
    1:   if (!content)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Not ref counted
    1:   nsIFrame *frame = aPresShell->GetPrimaryFrameFor(content);
    1: 
    1:   if (!frame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   *aResult = frame->GetWindow();
    1:   if (!*aResult)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
15919: nsEditor::GetWidget(nsIWidget **aWidget)
15919: {
15919:   if (!aWidget)
    1:     return NS_ERROR_NULL_POINTER;
15919:   *aWidget = nsnull;
    1:   nsCOMPtr<nsIPresShell> shell;
    1:   nsresult res = GetPresShell(getter_AddRefs(shell));
    1: 
    1:   if (NS_FAILED(res))
    1:     return res;
    1: 
    1:   if (!shell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIWidget> widget;
    1:   res = GetEditorContentWindow(shell, GetRoot(), getter_AddRefs(widget));
    1:   if (NS_FAILED(res))
    1:     return res;
15919:   if (!widget)
15919:     return NS_ERROR_NOT_AVAILABLE;
15919: 
15919:   NS_ADDREF(*aWidget = widget);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::ForceCompositionEnd()
    1: {
    1: 
    1: // We can test mInIMEMode and do some optimization for Mac and Window
    1: // Howerver, since UNIX support over-the-spot, we cannot rely on that 
    1: // flag for Unix.
    1: // We should use nsILookAndFeel to resolve this
    1: 
    1: #if defined(XP_MAC) || defined(XP_MACOSX) || defined(XP_WIN) || defined(XP_OS2)
    1:   if(! mInIMEMode)
    1:     return NS_OK;
    1: #endif
    1: 
    1: #ifdef XP_UNIX
    1:   if(mFlags & nsIPlaintextEditor::eEditorPasswordMask)
    1: 	return NS_OK;
    1: #endif
    1: 
15919:   nsCOMPtr<nsIWidget> widget;
15919:   nsresult res = GetWidget(getter_AddRefs(widget));
    1:   if (NS_FAILED(res))
    1:     return res;
    1: 
15919:   if (widget) {
15919:     res = widget->ResetInputState();
    1:     if (NS_FAILED(res)) 
    1:       return res;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetPreferredIMEState(PRUint32 *aState)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aState);
 1520:   *aState = nsIContent::IME_STATUS_ENABLE;
    1: 
    1:   PRUint32 flags;
 1520:   nsresult rv = GetFlags(&flags);
 1520:   NS_ENSURE_SUCCESS(rv, rv);
 1520: 
 1520:   if (flags & (nsIPlaintextEditor::eEditorReadonlyMask |
 1520:                nsIPlaintextEditor::eEditorDisabledMask)) {
    1:     *aState = nsIContent::IME_STATUS_DISABLE;
 1520:     return NS_OK;
 1520:   }
 1520: 
 1520:   nsCOMPtr<nsIPresShell> presShell;
 1520:   rv = GetPresShell(getter_AddRefs(presShell));
 1520:   NS_ENSURE_SUCCESS(rv, rv);
 1520: 
 1520:   nsCOMPtr<nsIContent> content = do_QueryInterface(GetRoot());
 1520:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
 1520: 
 1520:   nsIFrame* frame = presShell->GetPrimaryFrameFor(content);
 1520:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 1520: 
 1520:   switch (frame->GetStyleUIReset()->mIMEMode) {
 1520:     case NS_STYLE_IME_MODE_AUTO:
 1520:       if (flags & (nsIPlaintextEditor::eEditorPasswordMask))
  539:         *aState = nsIContent::IME_STATUS_PASSWORD;
 1520:       break;
 1520:     case NS_STYLE_IME_MODE_DISABLED:
 1520:       // we should use password state for |ime-mode: disabled;|.
 1520:       *aState = nsIContent::IME_STATUS_PASSWORD;
 1520:       break;
 1520:     case NS_STYLE_IME_MODE_ACTIVE:
 1520:       *aState |= nsIContent::IME_STATUS_OPEN;
 1520:       break;
 1520:     case NS_STYLE_IME_MODE_INACTIVE:
 1520:       *aState |= nsIContent::IME_STATUS_CLOSE;
 1520:       break;
 1520:   }
 1520: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
11912: nsEditor::GetComposing(PRBool* aResult)
11912: {
11912:   NS_ENSURE_ARG_POINTER(aResult);
11912:   *aResult = IsIMEComposing();
11912:   return NS_OK;
11912: }
11912: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  public nsEditor methods 
    1: #pragma mark -
    1: #endif
    1: /* Non-interface, public methods */
    1: 
    1: 
 6601: void
 6601: nsEditor::ContentAppended(nsIDocument *aDocument, nsIContent* aContainer,
 6601:                           PRInt32 aNewIndexInContainer)
 6601: {
 6601:   ContentInserted(aDocument, aContainer, nsnull, aNewIndexInContainer);
 6601: }
 6601: 
 6601: void
 6601: nsEditor::ContentInserted(nsIDocument *aDocument, nsIContent* aContainer,
 6601:                           nsIContent* aChild, PRInt32 aIndexInContainer)
 6601: {
 6601:   // XXX If we need aChild then nsEditor::ContentAppended should start passing
 6601:   //     in the child.
 6601:   if (!mRootElement)
 6601:   {
 6601:     // Need to remove the event listeners first because BeginningOfDocument
 6601:     // could set a new root (and event target) and we won't be able to remove
 6601:     // them from the old event target then.
 6601:     RemoveEventListeners();
 6601:     BeginningOfDocument();
 6601:     InstallEventListeners();
 6601:     SyncRealTimeSpell();
 6601:   }
 6601: }
 6601: 
 6601: void
 6601: nsEditor::ContentRemoved(nsIDocument *aDocument, nsIContent* aContainer,
 6601:                          nsIContent* aChild, PRInt32 aIndexInContainer)
 6601: {
 6601:   nsCOMPtr<nsIDOMHTMLElement> elem = do_QueryInterface(aChild);
 6601:   if (elem == mRootElement)
 6601:   {
 6601:     RemoveEventListeners();
 6601:     mRootElement = nsnull;
 6601:     mEventTarget = nsnull;
 6601:     InstallEventListeners();
 6601:   }
 6601: }
 6601: 
    1: NS_IMETHODIMP 
    1: nsEditor::GetRootElement(nsIDOMElement **aRootElement)
    1: {
    1:   if (!aRootElement)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   if (mRootElement)
    1:   {
    1:     // if we have cached the body element, use that
    1:     *aRootElement = mRootElement;
    1:     NS_ADDREF(*aRootElement);
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aRootElement = 0;
    1: 
    1:   NS_PRECONDITION(mDocWeak, "bad state, null mDocWeak");
    1:   nsCOMPtr<nsIDOMHTMLDocument> doc = do_QueryReferent(mDocWeak);
    1:   if (!doc) return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   // Use the documents body element as the editor root if we didn't
    1:   // get a root element during initialization.
    1: 
    1:   nsCOMPtr<nsIDOMHTMLElement> bodyElement; 
    1:   nsresult result = doc->GetBody(getter_AddRefs(bodyElement));
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   if (!bodyElement)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   mRootElement = bodyElement;
    1:   *aRootElement = bodyElement;
    1:   NS_ADDREF(*aRootElement);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: /** All editor operations which alter the doc should be prefaced
    1:  *  with a call to StartOperation, naming the action and direction */
    1: NS_IMETHODIMP
    1: nsEditor::StartOperation(PRInt32 opID, nsIEditor::EDirection aDirection)
    1: {
    1:   mAction = opID;
    1:   mDirection = aDirection;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: /** All editor operations which alter the doc should be followed
    1:  *  with a call to EndOperation */
    1: NS_IMETHODIMP
    1: nsEditor::EndOperation()
    1: {
    1:   mAction = nsnull;
    1:   mDirection = eNone;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CloneAttribute(const nsAString & aAttribute,
    1:                          nsIDOMNode *aDestNode, nsIDOMNode *aSourceNode)
    1: {
    1:   if (!aDestNode || !aSourceNode)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIDOMElement> destElement = do_QueryInterface(aDestNode);
    1:   nsCOMPtr<nsIDOMElement> sourceElement = do_QueryInterface(aSourceNode);
    1:   if (!destElement || !sourceElement)
    1:     return NS_ERROR_NO_INTERFACE;
    1: 
    1:   nsAutoString attrValue;
    1:   PRBool isAttrSet;
    1:   nsresult rv = GetAttributeValue(sourceElement,
    1:                                   aAttribute,
    1:                                   attrValue,
    1:                                   &isAttrSet);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   if (isAttrSet)
    1:     rv = SetAttribute(destElement, aAttribute, attrValue);
    1:   else
    1:     rv = RemoveAttribute(destElement, aAttribute);
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Objects must be DOM elements
    1: NS_IMETHODIMP
    1: nsEditor::CloneAttributes(nsIDOMNode *aDestNode, nsIDOMNode *aSourceNode)
    1: {
    1:   if (!aDestNode || !aSourceNode)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsCOMPtr<nsIDOMElement> destElement = do_QueryInterface(aDestNode);
    1:   nsCOMPtr<nsIDOMElement> sourceElement = do_QueryInterface(aSourceNode);
    1:   if (!destElement || !sourceElement)
    1:     return NS_ERROR_NO_INTERFACE;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> sourceAttributes;
    1:   sourceElement->GetAttributes(getter_AddRefs(sourceAttributes));
    1:   nsCOMPtr<nsIDOMNamedNodeMap> destAttributes;
    1:   destElement->GetAttributes(getter_AddRefs(destAttributes));
    1:   if (!sourceAttributes || !destAttributes)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsAutoEditBatch beginBatching(this);
    1: 
    1:   // Use transaction system for undo only if destination
    1:   //   is already in the document
    1:   nsIDOMElement *rootElement = GetRoot();
    1:   if (!rootElement)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRBool destInBody = PR_TRUE;
    1:   nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(rootElement);
    1:   nsCOMPtr<nsIDOMNode> p = aDestNode;
    1:   while (p && p != rootNode)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     if (NS_FAILED(p->GetParentNode(getter_AddRefs(tmp))) || !tmp)
    1:     {
    1:       destInBody = PR_FALSE;
    1:       break;
    1:     }
    1:     p = tmp;
    1:   }
    1: 
    1:   PRUint32 sourceCount;
    1:   sourceAttributes->GetLength(&sourceCount);
    1:   PRUint32 i, destCount;
    1:   destAttributes->GetLength(&destCount);
    1:   nsCOMPtr<nsIDOMNode> attrNode;
    1: 
    1:   // Clear existing attributes
    1:   for (i = 0; i < destCount; i++)
    1:   {
    1:     // always remove item number 0 (first item in list)
    1:     if( NS_SUCCEEDED(destAttributes->Item(0, getter_AddRefs(attrNode))) && attrNode)
    1:     {
    1:       nsCOMPtr<nsIDOMAttr> destAttribute = do_QueryInterface(attrNode);
    1:       if (destAttribute)
    1:       {
    1:         nsAutoString str;
    1:         if (NS_SUCCEEDED(destAttribute->GetName(str)))
    1:         {
    1:           if (destInBody)
    1:             RemoveAttribute(destElement, str);
    1:           else
    1:             destElement->RemoveAttribute(str);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   // Set just the attributes that the source element has
    1:   for (i = 0; i < sourceCount; i++)
    1:   {
    1:     if( NS_SUCCEEDED(sourceAttributes->Item(i, getter_AddRefs(attrNode))) && attrNode)
    1:     {
    1:       nsCOMPtr<nsIDOMAttr> sourceAttribute = do_QueryInterface(attrNode);
    1:       if (sourceAttribute)
    1:       {
    1:         nsAutoString sourceAttrName;
    1:         if (NS_SUCCEEDED(sourceAttribute->GetName(sourceAttrName)))
    1:         {
    1:           nsAutoString sourceAttrValue;
    1:           /*
    1:           Presence of an attribute in the named node map indicates that it was set on the 
    1:           element even if it has no value.
    1:           */
    1:           if (NS_SUCCEEDED(sourceAttribute->GetValue(sourceAttrValue)))
    1:           {
    1:             if (destInBody) {
    1:               result = SetAttributeOrEquivalent(destElement, sourceAttrName, sourceAttrValue, PR_FALSE);
    1:             }
    1:             else {
    1:               // the element is not inserted in the document yet, we don't want to put a
    1:               // transaction on the UndoStack
    1:               result = SetAttributeOrEquivalent(destElement, sourceAttrName, sourceAttrValue, PR_TRUE);
    1:             }
    1:           } else {
    1:             // Do we ever get here?
    1: #if DEBUG_cmanske
    1:             printf("Attribute in sourceAttribute has empty value in nsEditor::CloneAttributes()\n");
    1: #endif
    1:           }
    1:         }        
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  Protected and static methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP nsEditor::ScrollSelectionIntoView(PRBool aScrollToAnchor)
    1: {
    1:   nsCOMPtr<nsISelectionController> selCon;
    1:   if (NS_SUCCEEDED(GetSelectionController(getter_AddRefs(selCon))) && selCon)
    1:   {
    1:     PRInt16 region = nsISelectionController::SELECTION_FOCUS_REGION;
    1: 
    1:     if (aScrollToAnchor)
    1:       region = nsISelectionController::SELECTION_ANCHOR_REGION;
    1: 
    1:     PRBool syncScroll = PR_TRUE;
    1:     PRUint32 flags = 0;
    1: 
    1:     if (NS_SUCCEEDED(GetFlags(&flags)))
    1:     {
    1:       // If the editor is relying on asynchronous reflows, we have
    1:       // to use asynchronous requests to scroll, so that the scrolling happens
    1:       // after reflow requests are processed.
 5435:       // XXXbz why not just always do async scroll?
    1:       syncScroll = !(flags & nsIPlaintextEditor::eEditorUseAsyncUpdatesMask);
    1:     }
    1: 
12392:     // After ScrollSelectionIntoView(), the pending notifications might be
12392:     // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
    1:     selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
    1:                                     region, syncScroll);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::InsertTextImpl(const nsAString& aStringToInsert, 
    1:                                           nsCOMPtr<nsIDOMNode> *aInOutNode, 
    1:                                           PRInt32 *aInOutOffset,
    1:                                           nsIDOMDocument *aDoc)
    1: {
    1:   // NOTE: caller *must* have already used nsAutoTxnsConserveSelection stack-based
    1:   // class to turn off txn selection updating.  Caller also turned on rules sniffing
    1:   // if desired.
    1:   
    1:   if (!aInOutNode || !*aInOutNode || !aInOutOffset || !aDoc) return NS_ERROR_NULL_POINTER;
    1:   if (!mInIMEMode && aStringToInsert.IsEmpty()) return NS_OK;
    1:   nsCOMPtr<nsIDOMText> nodeAsText = do_QueryInterface(*aInOutNode);
    1:   PRInt32 offset = *aInOutOffset;
    1:   nsresult res;
    1:   if (mInIMEMode)
    1:   {
    1:     if (!nodeAsText)
    1:     {
    1:       // create a text node
    1:       res = aDoc->CreateTextNode(EmptyString(), getter_AddRefs(nodeAsText));
    1:       if (NS_FAILED(res)) return res;
    1:       if (!nodeAsText) return NS_ERROR_NULL_POINTER;
    1:       nsCOMPtr<nsIDOMNode> newNode = do_QueryInterface(nodeAsText);
    1:       // then we insert it into the dom tree
    1:       res = InsertNode(newNode, *aInOutNode, offset);
    1:       if (NS_FAILED(res)) return res;
    1:       offset = 0;
    1:     }
    1:     res = InsertTextIntoTextNodeImpl(aStringToInsert, nodeAsText, offset);
    1:     if (NS_FAILED(res)) return res;
    1:   }
    1:   else
    1:   {
    1:     if (nodeAsText)
    1:     {
    1:       // we are inserting text into an existing text node.
    1:       res = InsertTextIntoTextNodeImpl(aStringToInsert, nodeAsText, offset);
    1:       if (NS_FAILED(res)) return res;
    1:       *aInOutOffset += aStringToInsert.Length();
    1:     }
    1:     else
    1:     {
    1:       // we are inserting text into a non-text node
    1:       // first we have to create a textnode (this also populates it with the text)
    1:       res = aDoc->CreateTextNode(aStringToInsert, getter_AddRefs(nodeAsText));
    1:       if (NS_FAILED(res)) return res;
    1:       if (!nodeAsText) return NS_ERROR_NULL_POINTER;
    1:       nsCOMPtr<nsIDOMNode> newNode = do_QueryInterface(nodeAsText);
    1:       // then we insert it into the dom tree
    1:       res = InsertNode(newNode, *aInOutNode, offset);
    1:       if (NS_FAILED(res)) return res;
    1:       *aInOutNode = newNode;
    1:       *aInOutOffset = aStringToInsert.Length();
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::InsertTextIntoTextNodeImpl(const nsAString& aStringToInsert, 
    1:                                                      nsIDOMCharacterData *aTextNode, 
    1:                                                      PRInt32 aOffset, PRBool suppressIME)
    1: {
 3030:   nsRefPtr<EditTxn> txn;
20235:   nsresult result = NS_OK;
    1:   // suppressIME s used when editor must insert text, yet this text is not
    1:   // part of current ime operation.  example: adjusting whitespace around an ime insertion.
    1:   if (mIMETextRangeList && mInIMEMode && !suppressIME)
    1:   {
    1:     if (!mIMETextNode)
    1:     {
    1:       mIMETextNode = aTextNode;
    1:       mIMETextOffset = aOffset;
    1:     }
    1:     PRUint16 len ;
20235:     len = mIMETextRangeList->GetLength();
20235:     if (len > 0)
    1:     {
    1:       nsCOMPtr<nsIPrivateTextRange> range;
    1:       for (PRUint16 i = 0; i < len; i++) 
    1:       {
20235:         range = mIMETextRangeList->Item(i);
20235:         if (range)
    1:         {
    1:           PRUint16 type;
    1:           result = range->GetRangeType(&type);
    1:           if (NS_SUCCEEDED(result)) 
    1:           {
    1:             if (type == nsIPrivateTextRange::TEXTRANGE_RAWINPUT) 
    1:             {
    1:               PRUint16 start, end;
    1:               result = range->GetRangeStart(&start);
    1:               if (NS_SUCCEEDED(result)) 
    1:               {
    1:                 result = range->GetRangeEnd(&end);
    1:                 if (NS_SUCCEEDED(result)) 
    1:                 {
    1:                   if (!mPhonetic)
    1:                     mPhonetic = new nsString();
    1:                   if (mPhonetic)
    1:                   {
    1:                     nsAutoString tmp(aStringToInsert);                  
    1:                     tmp.Mid(*mPhonetic, start, end-start);
    1:                   }
    1:                 }
    1:               }
    1:             } // if
    1:           }
    1:         } // if
    1:       } // for
    1:     } // if
    1: 
 3030:     nsRefPtr<IMETextTxn> imeTxn;
 3030:     result = CreateTxnForIMEText(aStringToInsert, getter_AddRefs(imeTxn));
 3030:     txn = imeTxn;
    1:   }
    1:   else
    1:   {
 3030:     nsRefPtr<InsertTextTxn> insertTxn;
 3030:     result = CreateTxnForInsertText(aStringToInsert, aTextNode, aOffset,
 3030:                                     getter_AddRefs(insertTxn));
 3030:     txn = insertTxn;
 3030:   }
 3030:   if (NS_FAILED(result)) return result;
    1: 
    1:   // let listeners know what's up
    1:   PRInt32 i;
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillInsertText(aTextNode, aOffset, aStringToInsert);
    1:   
    1:   // XXX we may not need these view batches anymore.  This is handled at a higher level now I believe
    1:   BeginUpdateViewBatch();
    1:   result = DoTransaction(txn);
    1:   EndUpdateViewBatch();
    1: 
    1:   mRangeUpdater.SelAdjInsertText(aTextNode, aOffset, aStringToInsert);
    1:   
    1:   // let listeners know what happened
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidInsertText(aTextNode, aOffset, aStringToInsert, result);
    1: 
    1:   // Added some cruft here for bug 43366.  Layout was crashing because we left an 
    1:   // empty text node lying around in the document.  So I delete empty text nodes
    1:   // caused by IME.  I have to mark the IME transaction as "fixed", which means
    1:   // that furure ime txns won't merge with it.  This is because we don't want
    1:   // future ime txns trying to put their text into a node that is no longer in
    1:   // the document.  This does not break undo/redo, because all these txns are 
    1:   // wrapped in a parent PlaceHolder txn, and placeholder txns are already 
    1:   // savvy to having multiple ime txns inside them.
    1:   
    1:   // delete empty ime text node if there is one
    1:   if (mInIMEMode && mIMETextNode)
    1:   {
    1:     PRUint32 len;
    1:     mIMETextNode->GetLength(&len);
    1:     if (!len)
    1:     {
    1:       DeleteNode(mIMETextNode);
    1:       mIMETextNode = nsnull;
 3233:       static_cast<IMETextTxn*>(txn.get())->MarkFixed();  // mark the ime txn "fixed"
 3030:     }
 3030:   }
 3030:   
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::SelectEntireDocument(nsISelection *aSelection)
    1: {
    1:   if (!aSelection) { return NS_ERROR_NULL_POINTER; }
    1: 
    1:   nsIDOMElement *rootElement = GetRoot();
    1:   if (!rootElement) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   return aSelection->SelectAllChildren(rootElement);
    1: }
    1: 
    1: 
    1: nsresult nsEditor::GetFirstEditableNode(nsIDOMNode *aRoot, nsCOMPtr<nsIDOMNode> *outFirstNode)
    1: {
    1:   if (!aRoot || !outFirstNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult rv = NS_OK;
    1:   *outFirstNode = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> node = GetLeftmostChild(aRoot);
    1:   if (node && !IsEditable(node))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> next;
    1:     rv = GetNextNode(node, PR_TRUE, address_of(next));
    1:     node = next;
    1:   }
    1:   
    1:   if (node != aRoot)
    1:     *outFirstNode = node;
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef XXX_DEAD_CODE
    1: // jfrancis wants to keep this method around for reference
    1: nsresult nsEditor::GetLastEditableNode(nsIDOMNode *aRoot, nsCOMPtr<nsIDOMNode> *outLastNode)
    1: {
    1:   if (!aRoot || !outLastNode) return NS_ERROR_NULL_POINTER;
    1:   nsresult rv = NS_OK;
    1:   *outLastNode = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> node = GetRightmostChild(aRoot);
    1:   if (node && !IsEditable(node))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> next;
    1:     rv = GetPriorNode(node, PR_TRUE, address_of(next));
    1:     node = next;
    1:   }
    1: 
    1:   if (node != aRoot)
    1:     *outLastNode = node;
    1: 
    1:   return rv;
    1: }
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::NotifyDocumentListeners(TDocumentListenerNotification aNotificationType)
    1: {
    1:   PRInt32 numListeners = mDocStateListeners.Count();
    1:   if (!numListeners)
    1:     return NS_OK;    // maybe there just aren't any.
    1:  
    1:   nsresult rv = NS_OK;
    1:   PRInt32 i;
    1:   switch (aNotificationType)
    1:   {
    1:     case eDocumentCreated:
    1:       for (i = 0; i < numListeners;i++)
    1:       {
    1:         rv = mDocStateListeners[i]->NotifyDocumentCreated();
    1:         if (NS_FAILED(rv))
    1:           break;
    1:       }
    1:       break;
    1:       
    1:     case eDocumentToBeDestroyed:
    1:       for (i = 0; i < numListeners;i++)
    1:       {
    1:         rv = mDocStateListeners[i]->NotifyDocumentWillBeDestroyed();
    1:         if (NS_FAILED(rv))
    1:           break;
    1:       }
    1:       break;
    1:   
    1:     case eDocumentStateChanged:
    1:       {
    1:         PRBool docIsDirty;
    1:         rv = GetDocumentModified(&docIsDirty);
    1:         if (NS_FAILED(rv)) return rv;
    1:         
    1:         if (docIsDirty == mDocDirtyState)
    1:           return NS_OK;
    1:         
    1:         mDocDirtyState = (PRInt8)docIsDirty;
    1:         
    1:         for (i = 0; i < numListeners;i++)
    1:         {
    1:           rv = mDocStateListeners[i]->NotifyDocumentStateChanged(mDocDirtyState);
    1:           if (NS_FAILED(rv))
    1:             break;
    1:         }
    1:       }
    1:       break;
    1:     
    1:     default:
    1:       NS_NOTREACHED("Unknown notification");
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForInsertText(const nsAString & aStringToInsert,
    1:                                                nsIDOMCharacterData *aTextNode,
    1:                                                PRInt32 aOffset,
    1:                                                InsertTextTxn ** aTxn)
    1: {
    1:   if (!aTextNode || !aTxn) return NS_ERROR_NULL_POINTER;
    1:   nsresult result;
    1: 
    1:   result = TransactionFactory::GetNewTransaction(InsertTextTxn::GetCID(), (EditTxn **)aTxn);
    1:   if (NS_FAILED(result)) return result;
    1:   if (!*aTxn) return NS_ERROR_OUT_OF_MEMORY;
    1:   result = (*aTxn)->Init(aTextNode, aOffset, aStringToInsert, this);
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::DeleteText(nsIDOMCharacterData *aElement,
    1:                               PRUint32             aOffset,
    1:                               PRUint32             aLength)
    1: {
 3030:   nsRefPtr<DeleteTextTxn> txn;
 3030:   nsresult result = CreateTxnForDeleteText(aElement, aOffset, aLength,
 3030:                                            getter_AddRefs(txn));
    1:   nsAutoRules beginRulesSniffing(this, kOpDeleteText, nsIEditor::ePrevious);
    1:   if (NS_SUCCEEDED(result))  
    1:   {
    1:     // let listeners know what's up
    1:     PRInt32 i;
    1:     for (i = 0; i < mActionListeners.Count(); i++)
    1:       mActionListeners[i]->WillDeleteText(aElement, aOffset, aLength);
    1:     
    1:     result = DoTransaction(txn); 
    1:     
    1:     // let listeners know what happened
    1:     for (i = 0; i < mActionListeners.Count(); i++)
    1:       mActionListeners[i]->DidDeleteText(aElement, aOffset, aLength, result);
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForDeleteText(nsIDOMCharacterData *aElement,
    1:                                                PRUint32             aOffset,
    1:                                                PRUint32             aLength,
    1:                                                DeleteTextTxn      **aTxn)
    1: {
    1:   if (!aElement)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult result = TransactionFactory::GetNewTransaction(DeleteTextTxn::GetCID(), (EditTxn **)aTxn);
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = (*aTxn)->Init(this, aElement, aOffset, aLength, &mRangeUpdater);
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForSplitNode(nsIDOMNode *aNode,
    1:                                          PRUint32    aOffset,
    1:                                          SplitElementTxn **aTxn)
    1: {
    1:   if (!aNode)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult result = TransactionFactory::GetNewTransaction(SplitElementTxn::GetCID(), (EditTxn **)aTxn);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   return (*aTxn)->Init(this, aNode, aOffset);
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForJoinNode(nsIDOMNode  *aLeftNode,
    1:                                              nsIDOMNode  *aRightNode,
    1:                                              JoinElementTxn **aTxn)
    1: {
    1:   if (!aLeftNode || !aRightNode)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   nsresult result = TransactionFactory::GetNewTransaction(JoinElementTxn::GetCID(), (EditTxn **)aTxn);
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = (*aTxn)->Init(this, aLeftNode, aRightNode);
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: // END nsEditor core implementation
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsEditor public static helper methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: // BEGIN nsEditor public helper methods
    1: 
    1: nsresult
    1: nsEditor::SplitNodeImpl(nsIDOMNode * aExistingRightNode,
    1:                         PRInt32      aOffset,
    1:                         nsIDOMNode*  aNewLeftNode,
    1:                         nsIDOMNode*  aParent)
    1: {
    1: #ifdef NS_DEBUG_EDITOR
    1:   if (gNoisy) { printf("SplitNodeImpl: left=%p, right=%p, offset=%d\n", (void*)aNewLeftNode, (void*)aExistingRightNode, aOffset); }
    1: #endif
    1: 
    1:   NS_ASSERTION(((nsnull!=aExistingRightNode) &&
    1:                 (nsnull!=aNewLeftNode) &&
    1:                 (nsnull!=aParent)),
    1:                 "null arg");
    1:   nsresult result;
    1:   if ((nsnull!=aExistingRightNode) &&
    1:       (nsnull!=aNewLeftNode) &&
    1:       (nsnull!=aParent))
    1:   {
    1:     // get selection
    1:     nsCOMPtr<nsISelection> selection;
    1:     result = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(result)) return result;
    1:     if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:     // remember some selection points
    1:     nsCOMPtr<nsIDOMNode> selStartNode, selEndNode;
    1:     PRInt32 selStartOffset, selEndOffset;
    1:     result = GetStartNodeAndOffset(selection, address_of(selStartNode), &selStartOffset);
    1:     if (NS_FAILED(result)) selStartNode = nsnull;  // if selection is cleared, remember that
    1:     result = GetEndNodeAndOffset(selection, address_of(selEndNode), &selEndOffset);
    1:     if (NS_FAILED(result)) selStartNode = nsnull;  // if selection is cleared, remember that
    1: 
    1:     nsCOMPtr<nsIDOMNode> resultNode;
    1:     result = aParent->InsertBefore(aNewLeftNode, aExistingRightNode, getter_AddRefs(resultNode));
    1:     //printf("  after insert\n"); content->List();  // DEBUG
    1:     if (NS_SUCCEEDED(result))
    1:     {
    1:       // split the children between the 2 nodes
    1:       // at this point, aExistingRightNode has all the children
    1:       // move all the children whose index is < aOffset to aNewLeftNode
    1:       if (0<=aOffset) // don't bother unless we're going to move at least one child
    1:       {
    1:         // if it's a text node, just shuffle around some text
    1:         nsCOMPtr<nsIDOMCharacterData> rightNodeAsText( do_QueryInterface(aExistingRightNode) );
    1:         nsCOMPtr<nsIDOMCharacterData> leftNodeAsText( do_QueryInterface(aNewLeftNode) );
    1:         if (leftNodeAsText && rightNodeAsText)
    1:         {
    1:           // fix right node
    1:           nsAutoString leftText;
    1:           rightNodeAsText->SubstringData(0, aOffset, leftText);
    1:           rightNodeAsText->DeleteData(0, aOffset);
    1:           // fix left node
    1:           leftNodeAsText->SetData(leftText);
    1:           // moose          
    1:         }
    1:         else
    1:         {  // otherwise it's an interior node, so shuffle around the children
    1:            // go through list backwards so deletes don't interfere with the iteration
    1:           nsCOMPtr<nsIDOMNodeList> childNodes;
    1:           result = aExistingRightNode->GetChildNodes(getter_AddRefs(childNodes));
    1:           if ((NS_SUCCEEDED(result)) && (childNodes))
    1:           {
    1:             PRInt32 i=aOffset-1;
    1:             for ( ; ((NS_SUCCEEDED(result)) && (0<=i)); i--)
    1:             {
    1:               nsCOMPtr<nsIDOMNode> childNode;
    1:               result = childNodes->Item(i, getter_AddRefs(childNode));
    1:               if ((NS_SUCCEEDED(result)) && (childNode))
    1:               {
    1:                 result = aExistingRightNode->RemoveChild(childNode, getter_AddRefs(resultNode));
    1:                 //printf("  after remove\n"); content->List();  // DEBUG
    1:                 if (NS_SUCCEEDED(result))
    1:                 {
    1:                   nsCOMPtr<nsIDOMNode> firstChild;
    1:                   aNewLeftNode->GetFirstChild(getter_AddRefs(firstChild));
    1:                   result = aNewLeftNode->InsertBefore(childNode, firstChild, getter_AddRefs(resultNode));
    1:                   //printf("  after append\n"); content->List();  // DEBUG
    1:                 }
    1:               }
    1:             }
    1:           }        
    1:         }
    1:         // handle selection
    1:         if (GetShouldTxnSetSelection())
    1:         {
    1:           // editor wants us to set selection at split point
    1:           selection->Collapse(aNewLeftNode, aOffset);
    1:         }
    1:         else if (selStartNode)   
    1:         {
    1:           // else adjust the selection if needed.  if selStartNode is null, then there was no selection.
    1:           // HACK: this is overly simplified - multi-range selections need more work than this
    1:           if (selStartNode.get() == aExistingRightNode)
    1:           {
    1:             if (selStartOffset < aOffset)
    1:             {
    1:               selStartNode = aNewLeftNode;
    1:             }
    1:             else
    1:             {
    1:               selStartOffset -= aOffset;
    1:             }
    1:           }
    1:           if (selEndNode.get() == aExistingRightNode)
    1:           {
    1:             if (selEndOffset < aOffset)
    1:             {
    1:               selEndNode = aNewLeftNode;
    1:             }
    1:             else
    1:             {
    1:               selEndOffset -= aOffset;
    1:             }
    1:           }
    1:           selection->Collapse(selStartNode,selStartOffset);
    1:           selection->Extend(selEndNode,selEndOffset);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else
    1:     result = NS_ERROR_INVALID_ARG;
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsEditor::JoinNodesImpl(nsIDOMNode * aNodeToKeep,
    1:                         nsIDOMNode * aNodeToJoin,
    1:                         nsIDOMNode * aParent,
    1:                         PRBool       aNodeToKeepIsFirst)
    1: {
    1:   NS_ASSERTION(aNodeToKeep && aNodeToJoin && aParent, "null arg");
    1:   nsresult result;
    1:   if (aNodeToKeep && aNodeToJoin && aParent)
    1:   {
    1:     // get selection
    1:     nsCOMPtr<nsISelection> selection;
    1:     GetSelection(getter_AddRefs(selection));
    1:     if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:     // remember some selection points
    1:     nsCOMPtr<nsIDOMNode> selStartNode, selEndNode;
    1:     PRInt32 selStartOffset, selEndOffset, joinOffset, keepOffset;
    1:     result = GetStartNodeAndOffset(selection, address_of(selStartNode), &selStartOffset);
    1:     if (NS_FAILED(result)) selStartNode = nsnull;
    1:     result = GetEndNodeAndOffset(selection, address_of(selEndNode), &selEndOffset);
    1:     // Joe or Kin should comment here on why the following line is not a copy/paste error
    1:     if (NS_FAILED(result)) selStartNode = nsnull;
    1: 
    1:     nsCOMPtr<nsIDOMNode> leftNode;
    1:     if (aNodeToKeepIsFirst)
    1:       leftNode = aNodeToKeep;
    1:     else
    1:       leftNode = aNodeToJoin;
    1: 
    1:     PRUint32 firstNodeLength;
    1:     result = GetLengthOfDOMNode(leftNode, firstNodeLength);
    1:     if (NS_FAILED(result)) return result;
    1:     nsCOMPtr<nsIDOMNode> parent;
    1:     result = GetNodeLocation(aNodeToJoin, address_of(parent), &joinOffset);
    1:     if (NS_FAILED(result)) return result;
    1:     result = GetNodeLocation(aNodeToKeep, address_of(parent), &keepOffset);
    1:     if (NS_FAILED(result)) return result;
    1:     
    1:     // if selection endpoint is between the nodes, remember it as being
    1:     // in the one that is going away instead.  This simplifies later selection
    1:     // adjustment logic at end of this method.
    1:     if (selStartNode)
    1:     {
    1:       if (selStartNode == parent)
    1:       {
    1:         if (aNodeToKeepIsFirst)
    1:         {
    1:           if ((selStartOffset > keepOffset) && (selStartOffset <= joinOffset))
    1:           {
    1:             selStartNode = aNodeToJoin; 
    1:             selStartOffset = 0;
    1:           }
    1:         }
    1:         else
    1:         {
    1:           if ((selStartOffset > joinOffset) && (selStartOffset <= keepOffset))
    1:           {
    1:             selStartNode = aNodeToJoin; 
    1:             selStartOffset = firstNodeLength;
    1:           }
    1:         }
    1:       }
    1:       if (selEndNode == parent)
    1:       {
    1:         if (aNodeToKeepIsFirst)
    1:         {
    1:           if ((selEndOffset > keepOffset) && (selEndOffset <= joinOffset))
    1:           {
    1:             selEndNode = aNodeToJoin; 
    1:             selEndOffset = 0;
    1:           }
    1:         }
    1:         else
    1:         {
    1:           if ((selEndOffset > joinOffset) && (selEndOffset <= keepOffset))
    1:           {
    1:             selEndNode = aNodeToJoin; 
    1:             selEndOffset = firstNodeLength;
    1:           }
    1:         }
    1:       }
    1:     }
    1:     // ok, ready to do join now.
    1:     // if it's a text node, just shuffle around some text
    1:     nsCOMPtr<nsIDOMCharacterData> keepNodeAsText( do_QueryInterface(aNodeToKeep) );
    1:     nsCOMPtr<nsIDOMCharacterData> joinNodeAsText( do_QueryInterface(aNodeToJoin) );
    1:     if (keepNodeAsText && joinNodeAsText)
    1:     {
    1:       nsAutoString rightText;
    1:       nsAutoString leftText;
    1:       if (aNodeToKeepIsFirst)
    1:       {
    1:         keepNodeAsText->GetData(leftText);
    1:         joinNodeAsText->GetData(rightText);
    1:       }
    1:       else
    1:       {
    1:         keepNodeAsText->GetData(rightText);
    1:         joinNodeAsText->GetData(leftText);
    1:       }
    1:       leftText += rightText;
    1:       keepNodeAsText->SetData(leftText);          
    1:     }
    1:     else
    1:     {  // otherwise it's an interior node, so shuffle around the children
    1:       nsCOMPtr<nsIDOMNodeList> childNodes;
    1:       result = aNodeToJoin->GetChildNodes(getter_AddRefs(childNodes));
    1:       if ((NS_SUCCEEDED(result)) && (childNodes))
    1:       {
    1:         PRInt32 i;  // must be signed int!
    1:         PRUint32 childCount=0;
    1:         nsCOMPtr<nsIDOMNode> firstNode; //only used if aNodeToKeepIsFirst is false
    1:         childNodes->GetLength(&childCount);
    1:         if (!aNodeToKeepIsFirst)
    1:         { // remember the first child in aNodeToKeep, we'll insert all the children of aNodeToJoin in front of it
    1:           result = aNodeToKeep->GetFirstChild(getter_AddRefs(firstNode));  
    1:           // GetFirstChild returns nsnull firstNode if aNodeToKeep has no children, that's ok.
    1:         }
    1:         nsCOMPtr<nsIDOMNode> resultNode;
    1:         // have to go through the list backwards to keep deletes from interfering with iteration
    1:         nsCOMPtr<nsIDOMNode> previousChild;
    1:         for (i=childCount-1; ((NS_SUCCEEDED(result)) && (0<=i)); i--)
    1:         {
    1:           nsCOMPtr<nsIDOMNode> childNode;
    1:           result = childNodes->Item(i, getter_AddRefs(childNode));
    1:           if ((NS_SUCCEEDED(result)) && (childNode))
    1:           {
    1:             if (aNodeToKeepIsFirst)
    1:             { // append children of aNodeToJoin
    1:               //was result = aNodeToKeep->AppendChild(childNode, getter_AddRefs(resultNode));
    1:               result = aNodeToKeep->InsertBefore(childNode, previousChild, getter_AddRefs(resultNode));
    1:               previousChild = do_QueryInterface(childNode);
    1:             }
    1:             else
    1:             { // prepend children of aNodeToJoin
    1:               result = aNodeToKeep->InsertBefore(childNode, firstNode, getter_AddRefs(resultNode));
    1:               firstNode = do_QueryInterface(childNode);
    1:             }
    1:           }
    1:         }
    1:       }
    1:       else if (!childNodes) {
    1:         result = NS_ERROR_NULL_POINTER;
    1:       }
    1:     }
    1:     if (NS_SUCCEEDED(result))
    1:     { // delete the extra node
    1:       nsCOMPtr<nsIDOMNode> resultNode;
    1:       result = aParent->RemoveChild(aNodeToJoin, getter_AddRefs(resultNode));
    1:       
    1:       if (GetShouldTxnSetSelection())
    1:       {
    1:         // editor wants us to set selection at join point
    1:         selection->Collapse(aNodeToKeep, firstNodeLength);
    1:       }
    1:       else if (selStartNode)
    1:       {
    1:         // and adjust the selection if needed
    1:         // HACK: this is overly simplified - multi-range selections need more work than this
    1:         PRBool bNeedToAdjust = PR_FALSE;
    1:         
    1:         // check to see if we joined nodes where selection starts
    1:         if (selStartNode.get() == aNodeToJoin)
    1:         {
    1:           bNeedToAdjust = PR_TRUE;
    1:           selStartNode = aNodeToKeep;
    1:           if (aNodeToKeepIsFirst)
    1:           {
    1:             selStartOffset += firstNodeLength;
    1:           }
    1:         }
    1:         else if ((selStartNode.get() == aNodeToKeep) && !aNodeToKeepIsFirst)
    1:         {
    1:           bNeedToAdjust = PR_TRUE;
    1:           selStartOffset += firstNodeLength;
    1:         }
    1:                 
    1:         // check to see if we joined nodes where selection ends
    1:         if (selEndNode.get() == aNodeToJoin)
    1:         {
    1:           bNeedToAdjust = PR_TRUE;
    1:           selEndNode = aNodeToKeep;
    1:           if (aNodeToKeepIsFirst)
    1:           {
    1:             selEndOffset += firstNodeLength;
    1:           }
    1:         }
    1:         else if ((selEndNode.get() == aNodeToKeep) && !aNodeToKeepIsFirst)
    1:         {
    1:           bNeedToAdjust = PR_TRUE;
    1:           selEndOffset += firstNodeLength;
    1:         }
    1:         
    1:         // adjust selection if needed
    1:         if (bNeedToAdjust)
    1:         {
    1:           selection->Collapse(selStartNode,selStartOffset);
    1:           selection->Extend(selEndNode,selEndOffset);          
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else
    1:     result = NS_ERROR_INVALID_ARG;
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetChildOffset(nsIDOMNode *aChild, nsIDOMNode *aParent, PRInt32 &aOffset)
    1: {
    1:   NS_ASSERTION((aChild && aParent), "bad args");
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aParent);
    1:   nsCOMPtr<nsIContent> cChild = do_QueryInterface(aChild);
    1:   if (!cChild || !content)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   aOffset = content->IndexOf(cChild);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::GetNodeLocation(nsIDOMNode *inChild, nsCOMPtr<nsIDOMNode> *outParent, PRInt32 *outOffset)
    1: {
    1:   NS_ASSERTION((inChild && outParent && outOffset), "bad args");
    1:   nsresult result = NS_ERROR_NULL_POINTER;
    1:   if (inChild && outParent && outOffset)
    1:   {
    1:     result = inChild->GetParentNode(getter_AddRefs(*outParent));
    1:     if ((NS_SUCCEEDED(result)) && (*outParent))
    1:     {
    1:       result = GetChildOffset(inChild, *outParent, *outOffset);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: // returns the number of things inside aNode.  
    1: // If aNode is text, returns number of characters. If not, returns number of children nodes.
    1: nsresult
    1: nsEditor::GetLengthOfDOMNode(nsIDOMNode *aNode, PRUint32 &aCount) 
    1: {
    1:   aCount = 0;
    1:   if (!aNode) { return NS_ERROR_NULL_POINTER; }
    1:   nsresult result=NS_OK;
    1:   nsCOMPtr<nsIDOMCharacterData>nodeAsChar = do_QueryInterface(aNode);
    1:   if (nodeAsChar) {
    1:     nodeAsChar->GetLength(&aCount);
    1:   }
    1:   else
    1:   {
    1:     PRBool hasChildNodes;
    1:     aNode->HasChildNodes(&hasChildNodes);
    1:     if (hasChildNodes)
    1:     {
    1:       nsCOMPtr<nsIDOMNodeList>nodeList;
    1:       result = aNode->GetChildNodes(getter_AddRefs(nodeList));
    1:       if (NS_SUCCEEDED(result) && nodeList) {
    1:         nodeList->GetLength(&aCount);
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetPriorNode(nsIDOMNode  *aParentNode, 
    1:                        PRInt32      aOffset, 
    1:                        PRBool       aEditableNode, 
    1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                        PRBool       bNoBlockCrossing)
    1: {
    1:   // just another version of GetPriorNode that takes a {parent, offset}
    1:   // instead of a node
    1:   if (!aParentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
    1:   *aResultNode = nsnull;
    1:   
    1:   // if we are at beginning of node, or it is a textnode, then just look before it
    1:   if (!aOffset || IsTextNode(aParentNode))
    1:   {
    1:     if (bNoBlockCrossing && IsBlockNode(aParentNode))
    1:     {
    1:       // if we aren't allowed to cross blocks, don't look before this block
    1:       return NS_OK;
    1:     }
    1:     return GetPriorNode(aParentNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1:   }
    1: 
    1:   // else look before the child at 'aOffset'
    1:   nsCOMPtr<nsIDOMNode> child = GetChildAt(aParentNode, aOffset);
    1:   if (child)
    1:     return GetPriorNode(child, aEditableNode, aResultNode, bNoBlockCrossing);
    1: 
    1:   // unless there isn't one, in which case we are at the end of the node
    1:   // and want the deep-right child.
    1:   *aResultNode = GetRightmostChild(aParentNode, bNoBlockCrossing);
    1:   if (!*aResultNode || !aEditableNode || IsEditable(*aResultNode))
    1:     return NS_OK;
    1: 
    1:   // restart the search from the non-editable node we just found
    1:   nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(*aResultNode);
    1:   return GetPriorNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetNextNode(nsIDOMNode   *aParentNode, 
    1:                        PRInt32      aOffset, 
    1:                        PRBool       aEditableNode, 
    1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                        PRBool       bNoBlockCrossing)
    1: {
    1:   // just another version of GetNextNode that takes a {parent, offset}
    1:   // instead of a node
    1:   if (!aParentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   *aResultNode = nsnull;
    1: 
    1:   // if aParentNode is a text node, use it's location instead
    1:   if (IsTextNode(aParentNode))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> parent;
    1:     nsEditor::GetNodeLocation(aParentNode, address_of(parent), &aOffset);
    1:     aParentNode = parent;
    1:     aOffset++;  // _after_ the text node
    1:   }
    1:   // look at the child at 'aOffset'
    1:   nsCOMPtr<nsIDOMNode> child = GetChildAt(aParentNode, aOffset);
    1:   if (child)
    1:   {
    1:     if (bNoBlockCrossing && IsBlockNode(child))
    1:     {
    1:       *aResultNode = child;  // return this block
    1:       return NS_OK;
    1:     }
    1:     *aResultNode = GetLeftmostChild(child, bNoBlockCrossing);
    1:     if (!*aResultNode) 
    1:     {
    1:       *aResultNode = child;
    1:       return NS_OK;
    1:     }
    1:     if (!IsDescendantOfBody(*aResultNode))
    1:     {
    1:       *aResultNode = nsnull;
    1:       return NS_OK;
    1:     }
    1: 
    1:     if (!aEditableNode || IsEditable(*aResultNode))
    1:       return NS_OK;
    1: 
    1:     // restart the search from the non-editable node we just found
    1:     nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(*aResultNode);
    1:     return GetNextNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1:   }
    1:     
    1:   // unless there isn't one, in which case we are at the end of the node
    1:   // and want the next one.
    1:   if (bNoBlockCrossing && IsBlockNode(aParentNode))
    1:   {
    1:     // don't cross out of parent block
    1:     return NS_OK;
    1:   }
    1:   return GetNextNode(aParentNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetPriorNode(nsIDOMNode  *aCurrentNode, 
    1:                        PRBool       aEditableNode, 
    1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                        PRBool       bNoBlockCrossing)
    1: {
    1:   nsresult result;
    1:   if (!aCurrentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   *aResultNode = nsnull;  // init out-param
    1: 
    1:   if (IsRootNode(aCurrentNode))
    1:   {
    1:     // Don't allow traversal above the root node! This helps
    1:     // prevent us from accidentally editing browser content
    1:     // when the editor is in a text widget.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> candidate;
    1:   result = GetPriorNodeImpl(aCurrentNode, aEditableNode, address_of(candidate), bNoBlockCrossing);
    1:   if (NS_FAILED(result)) return result;
    1:   
    1:   if (!candidate)
    1:   {
    1:     // we could not find a prior node.  return null.
    1:     return NS_OK;
    1:   }
    1:   else if (!aEditableNode) *aResultNode = candidate;
    1:   else if (IsEditable(candidate)) *aResultNode = candidate;
    1:   else 
    1:   { // restart the search from the non-editable node we just found
    1:     nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(candidate);
    1:     return GetPriorNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::GetPriorNodeImpl(nsIDOMNode  *aCurrentNode, 
    1:                            PRBool       aEditableNode, 
    1:                            nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                            PRBool       bNoBlockCrossing)
    1: {
    1:   // called only by GetPriorNode so we don't need to check params.
    1: 
    1:   // if aCurrentNode has a left sibling, return that sibling's rightmost child (or itself if it has no children)
    1:   nsCOMPtr<nsIDOMNode> prevSibling;
    1:   nsresult result = aCurrentNode->GetPreviousSibling(getter_AddRefs(prevSibling));
    1:   if ((NS_SUCCEEDED(result)) && prevSibling)
    1:   {
    1:     if (bNoBlockCrossing && IsBlockNode(prevSibling))
    1:     {
    1:       // don't look inside prevsib, since it is a block
    1:       *aResultNode = prevSibling;
    1:       return NS_OK;
    1:     }
    1:     *aResultNode = GetRightmostChild(prevSibling, bNoBlockCrossing);
    1:     if (!*aResultNode) 
    1:     { 
    1:       *aResultNode = prevSibling;
    1:       return NS_OK;
    1:     }
    1:     if (!IsDescendantOfBody(*aResultNode))
    1:     {
    1:       *aResultNode = nsnull;
    1:       return NS_OK;
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // otherwise, walk up the parent tree until there is a child that comes before 
    1:     // the ancestor of aCurrentNode.  Then return that node's rightmost child
    1:     nsCOMPtr<nsIDOMNode> parent = do_QueryInterface(aCurrentNode);
    1:     nsCOMPtr<nsIDOMNode> node, notEditableNode;
    1:     do {
    1:       node = parent;
    1:       result = node->GetParentNode(getter_AddRefs(parent));
    1:       if ((NS_SUCCEEDED(result)) && parent)
    1:       {
    1:         if (!IsDescendantOfBody(parent))
    1:         {
    1:           *aResultNode = nsnull;
    1:           return NS_OK;
    1:         }
    1:         if ((bNoBlockCrossing && IsBlockNode(parent)) || IsRootNode(parent))
    1:         {
    1:           // we are at front of block or root, do not step out
    1:           *aResultNode = nsnull;
    1:           return NS_OK;
    1:         }
    1:         result = parent->GetPreviousSibling(getter_AddRefs(node));
    1:         if ((NS_SUCCEEDED(result)) && node)
    1:         {
    1:           if (bNoBlockCrossing && IsBlockNode(node))
    1:           {
    1:             // prev sibling is a block, do not step into it
    1:             *aResultNode = node;
    1:             return NS_OK;
    1:           }
    1:           *aResultNode = GetRightmostChild(node, bNoBlockCrossing);
    1:           if (!*aResultNode)  *aResultNode = node;
    1:           return NS_OK;
    1:         }
    1:       }
    1:     } while ((NS_SUCCEEDED(result)) && parent && !*aResultNode);
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::GetNextNode(nsIDOMNode  *aCurrentNode, 
    1:                       PRBool       aEditableNode, 
    1:                       nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                       PRBool       bNoBlockCrossing)
    1: {
    1:   if (!aCurrentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   *aResultNode = nsnull;  // init out-param
    1: 
    1:   if (IsRootNode(aCurrentNode))
    1:   {
    1:     // Don't allow traversal above the root node! This helps
    1:     // prevent us from accidentally editing browser content
    1:     // when the editor is in a text widget.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> candidate;
    1:   nsresult result = GetNextNodeImpl(aCurrentNode, aEditableNode,
    1:                                     address_of(candidate), bNoBlockCrossing);
    1:   if (NS_FAILED(result)) return result;
    1:   
    1:   if (!candidate)
    1:   {
    1:     // we could not find a next node.  return null.
    1:     *aResultNode = nsnull;
    1:     return NS_OK;
    1:   }
    1:   else if (!aEditableNode) *aResultNode = candidate;
    1:   else if (IsEditable(candidate)) *aResultNode = candidate;
    1:   else 
    1:   { // restart the search from the non-editable node we just found
    1:     nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(candidate);
    1:     return GetNextNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetNextNodeImpl(nsIDOMNode  *aCurrentNode, 
    1:                           PRBool       aEditableNode, 
    1:                           nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                           PRBool       bNoBlockCrossing)
    1: {
    1:   // called only by GetNextNode so we don't need to check params.
    1: 
    1:   // if aCurrentNode has a right sibling, return that sibling's leftmost child (or itself if it has no children)
    1:   nsCOMPtr<nsIDOMNode> nextSibling;
    1:   nsresult result = aCurrentNode->GetNextSibling(getter_AddRefs(nextSibling));
    1:   if ((NS_SUCCEEDED(result)) && nextSibling)
    1:   {
    1:     if (bNoBlockCrossing && IsBlockNode(nextSibling))
    1:     {
    1:       // next sibling is a block, do not step into it
    1:       *aResultNode = nextSibling;
    1:       return NS_OK;
    1:     }
    1:     *aResultNode = GetLeftmostChild(nextSibling, bNoBlockCrossing);
    1:     if (!*aResultNode)
    1:     { 
    1:       *aResultNode = nextSibling;
    1:       return NS_OK; 
    1:     }
    1:     if (!IsDescendantOfBody(*aResultNode))
    1:     {
    1:       *aResultNode = nsnull;
    1:       return NS_OK;
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // otherwise, walk up the parent tree until there is a child that comes after 
    1:     // the ancestor of aCurrentNode.  Then return that node's leftmost child
    1:     nsCOMPtr<nsIDOMNode> parent(do_QueryInterface(aCurrentNode));
    1:     nsCOMPtr<nsIDOMNode> node, notEditableNode;
    1:     do {
    1:       node = parent;
    1:       result = node->GetParentNode(getter_AddRefs(parent));
    1:       if ((NS_SUCCEEDED(result)) && parent)
    1:       {
    1:         if (!IsDescendantOfBody(parent))
    1:         {
    1:           *aResultNode = nsnull;
    1:           return NS_OK;
    1:         }
    1:         if ((bNoBlockCrossing && IsBlockNode(parent)) || IsRootNode(parent))
    1:         {
    1:           // we are at end of block or root, do not step out
    1:           *aResultNode = nsnull;
    1:           return NS_OK;
    1:         }
    1:         result = parent->GetNextSibling(getter_AddRefs(node));
    1:         if ((NS_SUCCEEDED(result)) && node)
    1:         {
    1:           if (bNoBlockCrossing && IsBlockNode(node))
    1:           {
    1:             // next sibling is a block, do not step into it
    1:             *aResultNode = node;
    1:             return NS_OK;
    1:           }
    1:           *aResultNode = GetLeftmostChild(node, bNoBlockCrossing);
    1:           if (!*aResultNode) *aResultNode = node;
    1:           return NS_OK; 
    1:         }
    1:       }
    1:     } while ((NS_SUCCEEDED(result)) && parent);
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: nsCOMPtr<nsIDOMNode>
    1: nsEditor::GetRightmostChild(nsIDOMNode *aCurrentNode, 
    1:                             PRBool bNoBlockCrossing)
    1: {
    1:   if (!aCurrentNode) return nsnull;
    1:   nsCOMPtr<nsIDOMNode> resultNode, temp=aCurrentNode;
    1:   PRBool hasChildren;
    1:   aCurrentNode->HasChildNodes(&hasChildren);
    1:   while (hasChildren)
    1:   {
    1:     temp->GetLastChild(getter_AddRefs(resultNode));
    1:     if (resultNode)
    1:     {
    1:       if (bNoBlockCrossing && IsBlockNode(resultNode))
    1:          return resultNode;
    1:       resultNode->HasChildNodes(&hasChildren);
    1:       temp = resultNode;
    1:     }
    1:     else 
    1:       hasChildren = PR_FALSE;
    1:   }
    1: 
    1:   return resultNode;
    1: }
    1: 
    1: nsCOMPtr<nsIDOMNode>
    1: nsEditor::GetLeftmostChild(nsIDOMNode *aCurrentNode,
    1:                            PRBool bNoBlockCrossing)
    1: {
    1:   if (!aCurrentNode) return nsnull;
    1:   nsCOMPtr<nsIDOMNode> resultNode, temp=aCurrentNode;
    1:   PRBool hasChildren;
    1:   aCurrentNode->HasChildNodes(&hasChildren);
    1:   while (hasChildren)
    1:   {
    1:     temp->GetFirstChild(getter_AddRefs(resultNode));
    1:     if (resultNode)
    1:     {
    1:       if (bNoBlockCrossing && IsBlockNode(resultNode))
    1:          return resultNode;
    1:       resultNode->HasChildNodes(&hasChildren);
    1:       temp = resultNode;
    1:     }
    1:     else 
    1:       hasChildren = PR_FALSE;
    1:   }
    1: 
    1:   return resultNode;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsBlockNode(nsIDOMNode *aNode)
    1: {
    1:   // stub to be overridden in nsHTMLEditor.
    1:   // screwing around with the class heirarchy here in order
    1:   // to not duplicate the code in GetNextNode/GetPrevNode
    1:   // across both nsEditor/nsHTMLEditor.  
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::CanContainTag(nsIDOMNode* aParent, const nsAString &aChildTag)
    1: {
    1:   nsCOMPtr<nsIDOMElement> parentElement = do_QueryInterface(aParent);
    1:   if (!parentElement) return PR_FALSE;
    1:   
    1:   nsAutoString parentStringTag;
    1:   parentElement->GetTagName(parentStringTag);
    1:   return TagCanContainTag(parentStringTag, aChildTag);
    1: }
    1: 
    1: PRBool 
    1: nsEditor::TagCanContain(const nsAString &aParentTag, nsIDOMNode* aChild)
    1: {
    1:   nsAutoString childStringTag;
    1:   
    1:   if (IsTextNode(aChild)) 
    1:   {
    1:     childStringTag.AssignLiteral("#text");
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMElement> childElement = do_QueryInterface(aChild);
    1:     if (!childElement) return PR_FALSE;
    1:     childElement->GetTagName(childStringTag);
    1:   }
    1:   return TagCanContainTag(aParentTag, childStringTag);
    1: }
    1: 
    1: PRBool 
    1: nsEditor::TagCanContainTag(const nsAString &aParentTag, const nsAString &aChildTag)
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsRootNode(nsIDOMNode *inNode) 
    1: {
    1:   if (!inNode)
    1:     return PR_FALSE;
    1: 
    1:   nsIDOMElement *rootElement = GetRoot();
    1: 
    1:   nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(rootElement);
    1: 
    1:   return inNode == rootNode;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsDescendantOfBody(nsIDOMNode *inNode) 
    1: {
    1:   if (!inNode) return PR_FALSE;
    1:   nsIDOMElement *rootElement = GetRoot();
    1:   if (!rootElement) return PR_FALSE;
    1:   nsCOMPtr<nsIDOMNode> root = do_QueryInterface(rootElement);
    1: 
    1:   if (inNode == root.get()) return PR_TRUE;
    1:   
    1:   nsCOMPtr<nsIDOMNode> parent, node = do_QueryInterface(inNode);
    1:   
    1:   do
    1:   {
    1:     node->GetParentNode(getter_AddRefs(parent));
    1:     if (parent == root) return PR_TRUE;
    1:     node = parent;
    1:   } while (parent);
    1:   
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsContainer(nsIDOMNode *aNode)
    1: {
    1:   return aNode ? PR_TRUE : PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsEditor::IsTextInDirtyFrameVisible(nsIDOMNode *aNode)
    1: {
    1:   // virtual method
    1:   //
    1:   // If this is a simple non-html editor,
    1:   // the best we can do is to assume it's visible.
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsEditable(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode) return PR_FALSE;
    1:   nsCOMPtr<nsIPresShell> shell;
    1:   GetPresShell(getter_AddRefs(shell));
    1:   if (!shell)  return PR_FALSE;
    1: 
 2896:   if (IsMozEditorBogusNode(aNode) || !IsModifiableNode(aNode)) return PR_FALSE;
    1: 
    1:   // see if it has a frame.  If so, we'll edit it.
    1:   // special case for textnodes: frame must have width.
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:   if (content)
    1:   {
    1:     nsIFrame *resultFrame = shell->GetPrimaryFrameFor(content);
    1:     if (!resultFrame)   // if it has no frame, it is not editable
    1:       return PR_FALSE;
    1:     NS_ASSERTION(content->IsNodeOfType(nsINode::eTEXT) ||
    1:                  content->IsNodeOfType(nsINode::eELEMENT),
    1:                  "frame for non element-or-text?");
    1:     if (!content->IsNodeOfType(nsINode::eTEXT))
    1:       return PR_TRUE;  // not a text node; has a frame
    1:     if (resultFrame->GetStateBits() & NS_FRAME_IS_DIRTY) // we can only trust width data for undirty frames
    1:     {
    1:       // In the past a comment said:
    1:       //   "assume all text nodes with dirty frames are editable"
    1:       // Nowadays we use a virtual function, that assumes TRUE
    1:       // in the simple editor world,
    1:       // and uses enhanced logic to find out in the HTML world.
    1:       return IsTextInDirtyFrameVisible(aNode);
    1:     }
    1:     if (resultFrame->GetSize().width > 0) 
    1:       return PR_TRUE;  // text node has width
    1:   }
    1:   return PR_FALSE;  // didn't pass any editability test
    1: }
    1: 
    1: PRBool
    1: nsEditor::IsMozEditorBogusNode(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode)
    1:     return PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIDOMElement>element = do_QueryInterface(aNode);
    1:   if (element)
    1:   {
    1:     nsAutoString val;
    1:     (void)element->GetAttribute(kMOZEditorBogusNodeAttr, val);
    1:     if (val.Equals(kMOZEditorBogusNodeValue)) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:     
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsEditor::CountEditableChildren(nsIDOMNode *aNode, PRUint32 &outCount) 
    1: {
    1:   outCount = 0;
    1:   if (!aNode) { return NS_ERROR_NULL_POINTER; }
    1:   nsresult res=NS_OK;
    1:   PRBool hasChildNodes;
    1:   aNode->HasChildNodes(&hasChildNodes);
    1:   if (hasChildNodes)
    1:   {
    1:     nsCOMPtr<nsIDOMNodeList>nodeList;
    1:     res = aNode->GetChildNodes(getter_AddRefs(nodeList));
    1:     if (NS_SUCCEEDED(res) && nodeList) 
    1:     {
    1:       PRUint32 i;
    1:       PRUint32 len;
    1:       nodeList->GetLength(&len);
    1:       for (i=0 ; i<len; i++)
    1:       {
    1:         nsCOMPtr<nsIDOMNode> child;
    1:         res = nodeList->Item((PRInt32)i, getter_AddRefs(child));
    1:         if ((NS_SUCCEEDED(res)) && (child))
    1:         {
    1:           if (IsEditable(child))
    1:           {
    1:             outCount++;
    1:           }
    1:         }
    1:       }
    1:     }
    1:     else if (!nodeList)
    1:       res = NS_ERROR_NULL_POINTER;
    1:   }
    1:   return res;
    1: }
    1: 
    1: //END nsEditor static utility methods
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::IncrementModificationCount(PRInt32 inNumMods)
    1: {
    1:   PRUint32 oldModCount = mModCount;
    1: 
    1:   mModCount += inNumMods;
    1: 
    1:   if ((oldModCount == 0 && mModCount != 0)
    1:    || (oldModCount != 0 && mModCount == 0))
    1:     NotifyDocumentListeners(eDocumentStateChanged);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::GetModificationCount(PRInt32 *outModCount)
    1: {
    1:   NS_ENSURE_ARG_POINTER(outModCount);
    1:   *outModCount = mModCount;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::ResetModificationCount()
    1: {
    1:   PRBool doNotify = (mModCount != 0);
    1: 
    1:   mModCount = 0;
    1: 
    1:   if (doNotify)
    1:     NotifyDocumentListeners(eDocumentStateChanged);
    1:   return NS_OK;
    1: }
    1: 
    1: //END nsEditor Private methods
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetTag: digs out the atom for the tag of this node
    1: //                    
    1: nsIAtom *
    1: nsEditor::GetTag(nsIDOMNode *aNode)
    1: {
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1: 
    1:   if (!content) 
    1:   {
    1:     NS_ASSERTION(aNode, "null node passed to nsEditor::Tag()");
    1: 
    1:     return nsnull;
    1:   }
    1:   
    1:   return content->Tag();
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetTagString: digs out string for the tag of this node
    1: //                    
    1: nsresult 
    1: nsEditor::GetTagString(nsIDOMNode *aNode, nsAString& outString)
    1: {
    1:   if (!aNode) 
    1:   {
    1:     NS_NOTREACHED("null node passed to nsEditor::GetTag()");
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   
    1:   nsIAtom *atom = GetTag(aNode);
    1:   if (!atom)
    1:   {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   atom->ToString(outString);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // NodesSameType: do these nodes have the same tag?
    1: //                    
    1: PRBool 
    1: nsEditor::NodesSameType(nsIDOMNode *aNode1, nsIDOMNode *aNode2)
    1: {
    1:   if (!aNode1 || !aNode2) 
    1:   {
    1:     NS_NOTREACHED("null node passed to nsEditor::NodesSameType()");
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   return GetTag(aNode1) == GetTag(aNode2);
    1: }
    1: 
    1: 
    1: // IsTextOrElementNode: true if node of dom type element or text
    1: //               
    1: PRBool
    1: nsEditor::IsTextOrElementNode(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode)
    1:   {
    1:     NS_NOTREACHED("null node passed to IsTextOrElementNode()");
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   PRUint16 nodeType;
    1:   aNode->GetNodeType(&nodeType);
    1:   return ((nodeType == nsIDOMNode::ELEMENT_NODE) || (nodeType == nsIDOMNode::TEXT_NODE));
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsTextNode: true if node of dom type text
    1: //               
    1: PRBool
    1: nsEditor::IsTextNode(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode)
    1:   {
    1:     NS_NOTREACHED("null node passed to IsTextNode()");
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   PRUint16 nodeType;
    1:   aNode->GetNodeType(&nodeType);
    1:   return (nodeType == nsIDOMNode::TEXT_NODE);
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetIndexOf: returns the position index of the node in the parent
    1: //
    1: PRInt32 
    1: nsEditor::GetIndexOf(nsIDOMNode *parent, nsIDOMNode *child)
    1: {
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(parent);
    1:   nsCOMPtr<nsIContent> cChild = do_QueryInterface(child);
    1:   NS_PRECONDITION(content, "null content in nsEditor::GetIndexOf");
    1:   NS_PRECONDITION(cChild, "null content in nsEditor::GetIndexOf");
    1: 
    1:   return content->IndexOf(cChild);
    1: }
    1:   
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetChildAt: returns the node at this position index in the parent
    1: //
    1: nsCOMPtr<nsIDOMNode> 
    1: nsEditor::GetChildAt(nsIDOMNode *aParent, PRInt32 aOffset)
    1: {
    1:   nsCOMPtr<nsIDOMNode> resultNode;
    1:   
    1:   nsCOMPtr<nsIContent> parent = do_QueryInterface(aParent);
    1: 
    1:   if (!parent) 
    1:     return resultNode;
    1: 
    1:   resultNode = do_QueryInterface(parent->GetChildAt(aOffset));
    1: 
    1:   return resultNode;
    1: }
    1:   
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetStartNodeAndOffset: returns whatever the start parent & offset is of 
    1: //                        the first range in the selection.
    1: nsresult 
    1: nsEditor::GetStartNodeAndOffset(nsISelection *aSelection,
    1:                                        nsCOMPtr<nsIDOMNode> *outStartNode,
    1:                                        PRInt32 *outStartOffset)
    1: {
    1:   if (!outStartNode || !outStartOffset || !aSelection) 
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // brade:  set outStartNode to null or ?
    1: 
    1:   nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(aSelection));
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   nsresult result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
    1:   if (NS_FAILED(result) || !enumerator)
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   enumerator->First(); 
    1:   nsCOMPtr<nsISupports> currentItem;
    1:   if (NS_FAILED(enumerator->CurrentItem(getter_AddRefs(currentItem))))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1:   if (!range)
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   if (NS_FAILED(range->GetStartContainer(getter_AddRefs(*outStartNode))))
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   if (NS_FAILED(range->GetStartOffset(outStartOffset)))
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetEndNodeAndOffset: returns whatever the end parent & offset is of 
    1: //                        the first range in the selection.
    1: nsresult 
    1: nsEditor::GetEndNodeAndOffset(nsISelection *aSelection,
    1:                                        nsCOMPtr<nsIDOMNode> *outEndNode,
    1:                                        PRInt32 *outEndOffset)
    1: {
    1:   if (!outEndNode || !outEndOffset) 
    1:     return NS_ERROR_NULL_POINTER;
    1:     
    1:   nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(aSelection));
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   nsresult result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
    1:   if (NS_FAILED(result) || !enumerator)
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   enumerator->First(); 
    1:   nsCOMPtr<nsISupports> currentItem;
    1:   if (NS_FAILED(enumerator->CurrentItem(getter_AddRefs(currentItem))))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1:   if (!range)
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   if (NS_FAILED(range->GetEndContainer(getter_AddRefs(*outEndNode))))
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   if (NS_FAILED(range->GetEndOffset(outEndOffset)))
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsPreformatted: checks the style info for the node for the preformatted
    1: //                 text style.
    1: nsresult 
    1: nsEditor::IsPreformatted(nsIDOMNode *aNode, PRBool *aResult)
    1: {
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:   
    1:   if (!aResult || !content) return NS_ERROR_NULL_POINTER;
    1:   
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
    1:   if (!ps) return NS_ERROR_NOT_INITIALIZED;
    1:   
    1:   nsIFrame *frame = ps->GetPrimaryFrameFor(content);
    1: 
    1:   NS_ASSERTION(frame, "no frame, see bug #188946");
    1:   if (!frame)
    1:   {
    1:     // Consider nodes without a style context to be NOT preformatted:
    1:     // For instance, this is true of JS tags inside the body (which show
    1:     // up as #text nodes but have no style context).
    1:     *aResult = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   const nsStyleText* styleText = frame->GetStyleText();
    1: 
11894:   *aResult = styleText->WhiteSpaceIsSignificant();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // SplitNodeDeep: this splits a node "deeply", splitting children as 
    1: //                appropriate.  The place to split is represented by
    1: //                a dom point at {splitPointParent, splitPointOffset}.
    1: //                That dom point must be inside aNode, which is the node to 
    1: //                split.  outOffset is set to the offset in the parent of aNode where
    1: //                the split terminates - where you would want to insert 
    1: //                a new element, for instance, if that's why you were splitting 
    1: //                the node.
    1: //
    1: nsresult
    1: nsEditor::SplitNodeDeep(nsIDOMNode *aNode, 
    1:                         nsIDOMNode *aSplitPointParent, 
    1:                         PRInt32 aSplitPointOffset,
    1:                         PRInt32 *outOffset,
    1:                         PRBool  aNoEmptyContainers,
    1:                         nsCOMPtr<nsIDOMNode> *outLeftNode,
    1:                         nsCOMPtr<nsIDOMNode> *outRightNode)
    1: {
    1:   if (!aNode || !aSplitPointParent || !outOffset) return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsIDOMNode> tempNode, parentNode;  
    1:   PRInt32 offset = aSplitPointOffset;
    1:   nsresult res;
    1:   
    1:   if (outLeftNode)  *outLeftNode  = nsnull;
    1:   if (outRightNode) *outRightNode = nsnull;
    1:   
    1:   nsCOMPtr<nsIDOMNode> nodeToSplit = do_QueryInterface(aSplitPointParent);
    1:   while (nodeToSplit)
    1:   {
    1:     // need to insert rules code call here to do things like
    1:     // not split a list if you are after the last <li> or before the first, etc.
    1:     // for now we just have some smarts about unneccessarily splitting
    1:     // textnodes, which should be universal enough to put straight in
    1:     // this nsEditor routine.
    1:     
    1:     nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(nodeToSplit);
    1:     PRUint32 len;
    1:     PRBool bDoSplit = PR_FALSE;
    1:     res = GetLengthOfDOMNode(nodeToSplit, len);
    1:     if (NS_FAILED(res)) return res;
    1:     
    1:     if (!(aNoEmptyContainers || nodeAsText) || (offset && (offset != (PRInt32)len)))
    1:     {
    1:       bDoSplit = PR_TRUE;
    1:       res = SplitNode(nodeToSplit, offset, getter_AddRefs(tempNode));
    1:       if (NS_FAILED(res)) return res;
    1:       if (outRightNode) *outRightNode = nodeToSplit;
    1:       if (outLeftNode)  *outLeftNode  = tempNode;
    1:     }
    1: 
    1:     res = nodeToSplit->GetParentNode(getter_AddRefs(parentNode));
    1:     if (NS_FAILED(res)) return res;
    1:     if (!parentNode) return NS_ERROR_FAILURE;
    1: 
    1:     if (!bDoSplit && offset)  // must be "end of text node" case, we didn't split it, just move past it
    1:     {
    1:       offset = GetIndexOf(parentNode, nodeToSplit) +1;
    1:       if (outLeftNode)  *outLeftNode  = nodeToSplit;
    1:     }
    1:     else
    1:     {
    1:       offset = GetIndexOf(parentNode, nodeToSplit);
    1:       if (outRightNode) *outRightNode = nodeToSplit;
    1:     }
    1:     
    1:     if (nodeToSplit.get() == aNode)  // we split all the way up to (and including) aNode; we're done
    1:       break;
    1:       
    1:     nodeToSplit = parentNode;
    1:   }
    1:   
    1:   if (!nodeToSplit)
    1:   {
    1:     NS_NOTREACHED("null node obtained in nsEditor::SplitNodeDeep()");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
    1:   *outOffset = offset;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // JoinNodeDeep:  this joins two like nodes "deeply", joining children as 
    1: //                appropriate.  
    1: nsresult
    1: nsEditor::JoinNodeDeep(nsIDOMNode *aLeftNode, 
    1:                        nsIDOMNode *aRightNode,
    1:                        nsCOMPtr<nsIDOMNode> *aOutJoinNode, 
    1:                        PRInt32 *outOffset)
    1: {
    1:   if (!aLeftNode || !aRightNode || !aOutJoinNode || !outOffset) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // while the rightmost children and their descendants of the left node 
    1:   // match the leftmost children and their descendants of the right node
    1:   // join them up.  Can you say that three times fast?
    1:   
    1:   nsCOMPtr<nsIDOMNode> leftNodeToJoin = do_QueryInterface(aLeftNode);
    1:   nsCOMPtr<nsIDOMNode> rightNodeToJoin = do_QueryInterface(aRightNode);
    1:   nsCOMPtr<nsIDOMNode> parentNode,tmp;
    1:   nsresult res = NS_OK;
    1:   
    1:   rightNodeToJoin->GetParentNode(getter_AddRefs(parentNode));
    1:   
    1:   while (leftNodeToJoin && rightNodeToJoin && parentNode &&
    1:           NodesSameType(leftNodeToJoin, rightNodeToJoin))
    1:   {
    1:     // adjust out params
    1:     PRUint32 length;
    1:     if (IsTextNode(leftNodeToJoin))
    1:     {
    1:       nsCOMPtr<nsIDOMCharacterData>nodeAsText;
    1:       nodeAsText = do_QueryInterface(leftNodeToJoin);
    1:       nodeAsText->GetLength(&length);
    1:     }
    1:     else
    1:     {
    1:       res = GetLengthOfDOMNode(leftNodeToJoin, length);
    1:       if (NS_FAILED(res)) return res;
    1:     }
    1:     
    1:     *aOutJoinNode = rightNodeToJoin;
    1:     *outOffset = length;
    1:     
    1:     // do the join
    1:     res = JoinNodes(leftNodeToJoin, rightNodeToJoin, parentNode);
    1:     if (NS_FAILED(res)) return res;
    1:     
    1:     if (IsTextNode(parentNode)) // we've joined all the way down to text nodes, we're done!
    1:       return NS_OK;
    1: 
    1:     else
    1:     {
    1:       // get new left and right nodes, and begin anew
    1:       parentNode = rightNodeToJoin;
    1:       leftNodeToJoin = GetChildAt(parentNode, length-1);
    1:       rightNodeToJoin = GetChildAt(parentNode, length);
    1: 
    1:       // skip over non-editable nodes
    1:       while (leftNodeToJoin && !IsEditable(leftNodeToJoin))
    1:       {
    1:         leftNodeToJoin->GetPreviousSibling(getter_AddRefs(tmp));
    1:         leftNodeToJoin = tmp;
    1:       }
    1:       if (!leftNodeToJoin) break;
    1:     
    1:       while (rightNodeToJoin && !IsEditable(rightNodeToJoin))
    1:       {
    1:         rightNodeToJoin->GetNextSibling(getter_AddRefs(tmp));
    1:         rightNodeToJoin = tmp;
    1:       }
    1:       if (!rightNodeToJoin) break;
    1:     }
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: nsresult nsEditor::BeginUpdateViewBatch()
    1: {
    1:   NS_PRECONDITION(mUpdateCount >= 0, "bad state");
    1: 
    1: 
    1:   if (0 == mUpdateCount)
    1:   {
    1:     // Turn off selection updates and notifications.
    1: 
    1:     nsCOMPtr<nsISelection> selection;
    1:     GetSelection(getter_AddRefs(selection));
    1: 
    1:     if (selection) 
    1:     {
    1:       nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
    1:       selPrivate->StartBatchChanges();
    1:     }
    1: 
    1:     // Turn off view updating.
10730:     mBatch.BeginUpdateViewBatch(mViewManager);
    1:   }
    1: 
    1:   mUpdateCount++;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult nsEditor::EndUpdateViewBatch()
    1: {
    1:   NS_PRECONDITION(mUpdateCount > 0, "bad state");
    1:   
    1:   if (mUpdateCount <= 0)
    1:   {
    1:     mUpdateCount = 0;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   mUpdateCount--;
    1: 
    1:   if (0 == mUpdateCount)
    1:   {
    1:     // Hide the caret with an StCaretHider. By the time it goes out
    1:     // of scope and tries to show the caret, reflow and selection changed
    1:     // notifications should've happened so the caret should have enough info
    1:     // to draw at the correct position.
    1: 
15969:     nsRefPtr<nsCaret> caret;
    1:     nsCOMPtr<nsIPresShell> presShell;
    1:     GetPresShell(getter_AddRefs(presShell));
    1: 
    1:     if (presShell)
    1:       presShell->GetCaret(getter_AddRefs(caret));
    1: 
    1:     StCaretHider caretHider(caret);
    1:         
    1:     PRUint32 flags = 0;
    1: 
    1:     GetFlags(&flags);
    1: 
    1:     // Turn view updating back on.
    1:     if (mViewManager)
    1:     {
    1:       PRUint32 updateFlag = NS_VMREFRESH_IMMEDIATE;
    1: 
    1:       // If we're doing async updates, use NS_VMREFRESH_DEFERRED here, so that
    1:       // the reflows we caused will get processed before the invalidates.
 5435:       if (flags & nsIPlaintextEditor::eEditorUseAsyncUpdatesMask) {
    1:         updateFlag = NS_VMREFRESH_DEFERRED;
25180:       } else if (presShell) {
 5435:         // Flush out layout.  Need to do this because if we have no invalidates
 5435:         // to flush the viewmanager code won't flush our reflow here, and we
 5435:         // have selection code that does sync caret scrolling in this case.
 5435:         presShell->FlushPendingNotifications(Flush_Layout);
 5435:       }
10730:       mBatch.EndUpdateViewBatch(updateFlag);
    1:     }
    1: 
    1:     // Turn selection updating and notifications back on.
    1: 
    1:     nsCOMPtr<nsISelection>selection;
    1:     GetSelection(getter_AddRefs(selection));
    1: 
    1:     if (selection) {
    1:       nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
    1:       selPrivate->EndBatchChanges();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::GetShouldTxnSetSelection()
    1: {
    1:   return mShouldTxnSetSelection;
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  protected nsEditor methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DeleteSelectionImpl(nsIEditor::EDirection aAction)
    1: {
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
 3030:   nsRefPtr<EditAggregateTxn> txn;
    1:   nsCOMPtr<nsIDOMNode> deleteNode;
    1:   PRInt32 deleteCharOffset = 0, deleteCharLength = 0;
 3030:   res = CreateTxnForDeleteSelection(aAction, getter_AddRefs(txn),
 3030:                                     getter_AddRefs(deleteNode),
 3030:                                     &deleteCharOffset, &deleteCharLength);
    1:   nsCOMPtr<nsIDOMCharacterData> deleteCharData(do_QueryInterface(deleteNode));
    1: 
    1:   if (NS_SUCCEEDED(res))  
    1:   {
    1:     nsAutoRules beginRulesSniffing(this, kOpDeleteSelection, aAction);
    1:     PRInt32 i;
    1:     // Notify nsIEditActionListener::WillDelete[Selection|Text|Node]
    1:     if (!deleteNode)
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->WillDeleteSelection(selection);
    1:     else if (deleteCharData)
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->WillDeleteText(deleteCharData, deleteCharOffset, 1);
    1:     else
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->WillDeleteNode(deleteNode);
    1: 
    1:     // Delete the specified amount
    1:     res = DoTransaction(txn);  
    1: 
    1:     // Notify nsIEditActionListener::DidDelete[Selection|Text|Node]
    1:     if (!deleteNode)
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->DidDeleteSelection(selection);
    1:     else if (deleteCharData)
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->DidDeleteText(deleteCharData, deleteCharOffset, 1, res);
    1:     else
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->DidDeleteNode(deleteNode, res);
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: // XXX: error handling in this routine needs to be cleaned up!
    1: NS_IMETHODIMP
    1: nsEditor::DeleteSelectionAndCreateNode(const nsAString& aTag,
    1:                                            nsIDOMNode ** aNewNode)
    1: {
    1:   nsCOMPtr<nsIDOMNode> parentSelectedNode;
    1:   PRInt32 offsetOfNewNode;
    1:   nsresult result = DeleteSelectionAndPrepareToCreateNode(parentSelectedNode,
    1:                                                           offsetOfNewNode);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   nsCOMPtr<nsIDOMNode> newNode;
    1:   result = CreateNode(aTag, parentSelectedNode, offsetOfNewNode,
    1:                       getter_AddRefs(newNode));
    1:   // XXX: ERROR_HANDLING  check result, and make sure aNewNode is set correctly in success/failure cases
    1:   *aNewNode = newNode;
    1:   NS_IF_ADDREF(*aNewNode);
    1: 
    1:   // we want the selection to be just after the new node
    1:   nsCOMPtr<nsISelection> selection;
    1:   result = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(result)) return result;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1:   return selection->Collapse(parentSelectedNode, offsetOfNewNode+1);
    1: }
    1: 
    1: 
    1: /* Non-interface, protected methods */
    1: 
    1: nsresult
    1: nsEditor::GetIMEBufferLength(PRInt32* length)
    1: {
    1:   *length = mIMEBufferLength;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsEditor::SetIsIMEComposing(){  
    1:   // We set mIsIMEComposing according to mIMETextRangeList.
    1:   nsCOMPtr<nsIPrivateTextRange> rangePtr;
    1:   PRUint16 listlen, type;
    1: 
    1:   mIsIMEComposing = PR_FALSE;
20235:   listlen = mIMETextRangeList->GetLength();
    1: 
    1:   for (PRUint16 i = 0; i < listlen; i++)
    1:   {
20235:       rangePtr = mIMETextRangeList->Item(i);
20235:       if (!rangePtr) continue;
20235:       nsresult result = rangePtr->GetRangeType(&type);
    1:       if (NS_FAILED(result)) continue;
    1:       if ( type == nsIPrivateTextRange::TEXTRANGE_RAWINPUT ||
    1:            type == nsIPrivateTextRange::TEXTRANGE_CONVERTEDTEXT ||
    1:            type == nsIPrivateTextRange::TEXTRANGE_SELECTEDRAWTEXT ||
    1:            type == nsIPrivateTextRange::TEXTRANGE_SELECTEDCONVERTEDTEXT )
    1:       {
    1:         mIsIMEComposing = PR_TRUE;
    1: #ifdef DEBUG_IME
    1:         printf("nsEditor::mIsIMEComposing = PR_TRUE\n");
    1: #endif
    1:         break;
    1:       }
    1:   }
    1:   return;
    1: }
    1: 
    1: PRBool
    1: nsEditor::IsIMEComposing() {
    1:   return mIsIMEComposing;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DeleteSelectionAndPrepareToCreateNode(nsCOMPtr<nsIDOMNode> &parentSelectedNode, PRInt32& offsetOfNewNode)
    1: {
    1:   nsresult result=NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsISelection> selection;
    1:   result = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(result)) return result;
    1:   if (!selection) return NS_ERROR_NULL_POINTER;
    1: 
    1:   PRBool collapsed;
    1:   result = selection->GetIsCollapsed(&collapsed);
    1:   if (NS_SUCCEEDED(result) && !collapsed) 
    1:   {
    1:     result = DeleteSelection(nsIEditor::eNone);
    1:     if (NS_FAILED(result)) {
    1:       return result;
    1:     }
    1:     // get the new selection
    1:     result = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(result)) {
    1:       return result;
    1:     }
    1: #ifdef NS_DEBUG
    1:     nsCOMPtr<nsIDOMNode>testSelectedNode;
    1:     nsresult debugResult = selection->GetAnchorNode(getter_AddRefs(testSelectedNode));
    1:     // no selection is ok.
    1:     // if there is a selection, it must be collapsed
    1:     if (testSelectedNode)
    1:     {
    1:       PRBool testCollapsed;
    1:       debugResult = selection->GetIsCollapsed(&testCollapsed);
    1:       NS_ASSERTION((NS_SUCCEEDED(result)), "couldn't get a selection after deletion");
    1:       NS_ASSERTION(testCollapsed, "selection not reset after deletion");
    1:     }
    1: #endif
    1:   }
    1:   // split the selected node
    1:   PRInt32 offsetOfSelectedNode;
    1:   result = selection->GetAnchorNode(getter_AddRefs(parentSelectedNode));
    1:   if (NS_SUCCEEDED(result) && NS_SUCCEEDED(selection->GetAnchorOffset(&offsetOfSelectedNode)) && parentSelectedNode)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> selectedNode;
    1:     PRUint32 selectedNodeContentCount=0;
    1:     nsCOMPtr<nsIDOMCharacterData>selectedParentNodeAsText;
    1:     selectedParentNodeAsText = do_QueryInterface(parentSelectedNode);
    1: 
    1:     offsetOfNewNode = offsetOfSelectedNode;
    1:     
    1:     /* if the selection is a text node, split the text node if necessary
    1:        and compute where to put the new node
    1:     */
    1:     if (selectedParentNodeAsText) 
    1:     { 
    1:       PRInt32 indexOfTextNodeInParent;
    1:       selectedNode = do_QueryInterface(parentSelectedNode);
    1:       selectedNode->GetParentNode(getter_AddRefs(parentSelectedNode));
    1:       selectedParentNodeAsText->GetLength(&selectedNodeContentCount);
    1:       GetChildOffset(selectedNode, parentSelectedNode, indexOfTextNodeInParent);
    1: 
    1:       if ((offsetOfSelectedNode!=0) && (((PRUint32)offsetOfSelectedNode)!=selectedNodeContentCount))
    1:       {
    1:         nsCOMPtr<nsIDOMNode> newSiblingNode;
    1:         result = SplitNode(selectedNode, offsetOfSelectedNode, getter_AddRefs(newSiblingNode));
    1:         // now get the node's offset in it's parent, and insert the new tag there
    1:         if (NS_SUCCEEDED(result)) {
    1:           result = GetChildOffset(selectedNode, parentSelectedNode, offsetOfNewNode);
    1:         }
    1:       }
    1:       else 
    1:       { // determine where to insert the new node
    1:         if (0==offsetOfSelectedNode) {
    1:           offsetOfNewNode = indexOfTextNodeInParent; // insert new node as previous sibling to selection parent
    1:         }
    1:         else {                 // insert new node as last child
    1:           GetChildOffset(selectedNode, parentSelectedNode, offsetOfNewNode);
    1:           offsetOfNewNode++;    // offsets are 0-based, and we need the index of the new node
    1:         }
    1:       }
    1:     }
    1:     // Here's where the new node was inserted
    1:   }
    1: #ifdef DEBUG
    1:   else {
    1:     printf("InsertLineBreak into an empty document is not yet supported\n");
    1:   }
    1: #endif
    1:   return result;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DoAfterDoTransaction(nsITransaction *aTxn)
    1: {
    1:   nsresult rv = NS_OK;
    1:   
    1:   PRBool  isTransientTransaction;
    1:   rv = aTxn->GetIsTransient(&isTransientTransaction);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   
    1:   if (!isTransientTransaction)
    1:   {
    1:     // we need to deal here with the case where the user saved after some
    1:     // edits, then undid one or more times. Then, the undo count is -ve,
    1:     // but we can't let a do take it back to zero. So we flip it up to
    1:     // a +ve number.
    1:     PRInt32 modCount;
    1:     GetModificationCount(&modCount);
    1:     if (modCount < 0)
    1:       modCount = -modCount;
    1:         
    1:     rv = IncrementModificationCount(1);    // don't count transient transactions
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DoAfterUndoTransaction()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   rv = IncrementModificationCount(-1);    // all undoable transactions are non-transient
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DoAfterRedoTransaction()
    1: {
    1:   return IncrementModificationCount(1);    // all redoable transactions are non-transient
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::CreateTxnForSetAttribute(nsIDOMElement *aElement, 
    1:                                    const nsAString& aAttribute, 
    1:                                    const nsAString& aValue,
    1:                                    ChangeAttributeTxn ** aTxn)
    1: {
    1:   nsresult result = NS_ERROR_NULL_POINTER;
    1:   if (nsnull != aElement)
    1:   {
    1:     result = TransactionFactory::GetNewTransaction(ChangeAttributeTxn::GetCID(), (EditTxn **)aTxn);
    1:     if (NS_SUCCEEDED(result))  {
    1:       result = (*aTxn)->Init(this, aElement, aAttribute, aValue, PR_FALSE);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::CreateTxnForRemoveAttribute(nsIDOMElement *aElement, 
    1:                                       const nsAString& aAttribute,
    1:                                       ChangeAttributeTxn ** aTxn)
    1: {
    1:   nsresult result = NS_ERROR_NULL_POINTER;
    1:   if (nsnull != aElement)
    1:   {
    1:     result = TransactionFactory::GetNewTransaction(ChangeAttributeTxn::GetCID(), (EditTxn **)aTxn);
    1:     if (NS_SUCCEEDED(result))  
    1:     {
    1:       nsAutoString value;
    1:       result = (*aTxn)->Init(this, aElement, aAttribute, value, PR_TRUE);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForCreateElement(const nsAString& aTag,
    1:                                                   nsIDOMNode     *aParent,
    1:                                                   PRInt32         aPosition,
    1:                                                   CreateElementTxn ** aTxn)
    1: {
    1:   nsresult result = NS_ERROR_NULL_POINTER;
    1:   if (nsnull != aParent)
    1:   {
    1:     result = TransactionFactory::GetNewTransaction(CreateElementTxn::GetCID(), (EditTxn **)aTxn);
    1:     if (NS_SUCCEEDED(result))  {
    1:       result = (*aTxn)->Init(this, aTag, aParent, aPosition);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForInsertElement(nsIDOMNode * aNode,
    1:                                                   nsIDOMNode * aParent,
    1:                                                   PRInt32      aPosition,
    1:                                                   InsertElementTxn ** aTxn)
    1: {
    1:   nsresult result = NS_ERROR_NULL_POINTER;
    1:   if (aNode && aParent && aTxn)
    1:   {
    1:     result = TransactionFactory::GetNewTransaction(InsertElementTxn::GetCID(), (EditTxn **)aTxn);
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = (*aTxn)->Init(aNode, aParent, aPosition, this);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForDeleteElement(nsIDOMNode * aElement,
    1:                                              DeleteElementTxn ** aTxn)
    1: {
    1:   nsresult result = NS_ERROR_NULL_POINTER;
    1:   if (nsnull != aElement)
    1:   {
    1:     result = TransactionFactory::GetNewTransaction(DeleteElementTxn::GetCID(), (EditTxn **)aTxn);
    1:     if (NS_SUCCEEDED(result)) {
 2896:       result = (*aTxn)->Init(this, aElement, &mRangeUpdater);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::CreateTxnForIMEText(const nsAString& aStringToInsert,
    1:                               IMETextTxn ** aTxn)
    1: {
    1:   NS_ASSERTION(aTxn, "illegal value- null ptr- aTxn");
    1:   if(!aTxn) return NS_ERROR_NULL_POINTER;
    1:      
    1:   nsresult  result;
    1: 
    1:   result = TransactionFactory::GetNewTransaction(IMETextTxn::GetCID(), (EditTxn **)aTxn);
    1:   if (nsnull!=*aTxn) {
    1:     result = (*aTxn)->Init(mIMETextNode,mIMETextOffset,mIMEBufferLength,mIMETextRangeList,aStringToInsert,mSelConWeak);
    1:   }
    1:   else {
    1:     result = NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::CreateTxnForAddStyleSheet(nsICSSStyleSheet* aSheet, AddStyleSheetTxn* *aTxn)
    1: {
    1:   nsresult rv = TransactionFactory::GetNewTransaction(AddStyleSheetTxn::GetCID(), (EditTxn **)aTxn);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:     
    1:   if (! *aTxn)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   return (*aTxn)->Init(this, aSheet);
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::CreateTxnForRemoveStyleSheet(nsICSSStyleSheet* aSheet, RemoveStyleSheetTxn* *aTxn)
    1: {
    1:   nsresult rv = TransactionFactory::GetNewTransaction(RemoveStyleSheetTxn::GetCID(), (EditTxn **)aTxn);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:     
    1:   if (! *aTxn)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   return (*aTxn)->Init(this, aSheet);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CreateTxnForDeleteSelection(nsIEditor::EDirection aAction,
    1:                                       EditAggregateTxn ** aTxn,
    1:                                       nsIDOMNode ** aNode,
    1:                                       PRInt32 *aOffset,
    1:                                       PRInt32 *aLength)
    1: {
    1:   if (!aTxn)
    1:     return NS_ERROR_NULL_POINTER;
    1:   *aTxn = nsnull;
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryReferent(mSelConWeak);
    1:   if (!selCon) return NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult result = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                                          getter_AddRefs(selection));
    1:   if ((NS_SUCCEEDED(result)) && selection)
    1:   {
    1:     // Check whether the selection is collapsed and we should do nothing:
    1:     PRBool isCollapsed;
    1:     result = (selection->GetIsCollapsed(&isCollapsed));
    1:     if (NS_SUCCEEDED(result) && isCollapsed && aAction == eNone)
    1:       return NS_OK;
    1: 
    1:     // allocate the out-param transaction
    1:     result = TransactionFactory::GetNewTransaction(EditAggregateTxn::GetCID(), (EditTxn **)aTxn);
    1:     if (NS_FAILED(result)) {
    1:       return result;
    1:     }
    1: 
    1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
    1:     nsCOMPtr<nsIEnumerator> enumerator;
    1:     result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
    1:     if (NS_SUCCEEDED(result) && enumerator)
    1:     {
    1:       for (enumerator->First(); NS_OK!=enumerator->IsDone(); enumerator->Next())
    1:       {
    1:         nsCOMPtr<nsISupports> currentItem;
    1:         result = enumerator->CurrentItem(getter_AddRefs(currentItem));
    1:         if ((NS_SUCCEEDED(result)) && (currentItem))
    1:         {
    1:           nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1:           range->GetCollapsed(&isCollapsed);
    1:           if (!isCollapsed)
    1:           {
 5270:             nsRefPtr<EditTxn> editTxn;
 5270:             result =
 5270:               TransactionFactory::GetNewTransaction(DeleteRangeTxn::GetCID(),
 5270:                                                     getter_AddRefs(editTxn));
 5270:             nsRefPtr<DeleteRangeTxn> txn =
 5270:               static_cast<DeleteRangeTxn*>(editTxn.get());
    1:             if (NS_SUCCEEDED(result) && txn)
    1:             {
    1:               txn->Init(this, range, &mRangeUpdater);
    1:               (*aTxn)->AppendChild(txn);
    1:             }
    1:             else
    1:               result = NS_ERROR_OUT_OF_MEMORY;
    1:           }
 5270:           // Same with range as with selection; if it is collapsed and action
 5270:           // is eNone, do nothing.
 5270:           else if (aAction != eNone)
    1:           { // we have an insertion point.  delete the thing in front of it or behind it, depending on aAction
    1:             result = CreateTxnForDeleteInsertionPoint(range, aAction, *aTxn, aNode, aOffset, aLength);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // if we didn't build the transaction correctly, destroy the out-param transaction so we don't leak it.
    1:   if (NS_FAILED(result))
    1:   {
    1:     NS_IF_RELEASE(*aTxn);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsEditor::CreateTxnForDeleteCharacter(nsIDOMCharacterData  *aData,
    1:                                       PRUint32              aOffset,
    1:                                       nsIEditor::EDirection aDirection,
    1:                                       DeleteTextTxn       **aTxn)
    1: {
    1:   NS_ASSERTION(aDirection == eNext || aDirection == ePrevious,
    1:                "invalid direction");
    1:   nsAutoString data;
    1:   aData->GetData(data);
    1:   PRUint32 segOffset, segLength = 1;
    1:   if (aDirection == eNext) {
    1:     segOffset = aOffset;
    1:     if (NS_IS_HIGH_SURROGATE(data[segOffset]) &&
    1:         segOffset + 1 < data.Length() &&
    1:         NS_IS_LOW_SURROGATE(data[segOffset+1])) {
    1:       // delete both halves of the surrogate pair
    1:       ++segLength;
    1:     }
    1:   } else {
    1:     segOffset = aOffset - 1;
    1:     if (NS_IS_LOW_SURROGATE(data[segOffset]) &&
    1:         segOffset > 0 &&
    1:         NS_IS_HIGH_SURROGATE(data[segOffset-1])) {
    1:       ++segLength;
    1:       --segOffset;
    1:     }
    1:   }
    1:   return CreateTxnForDeleteText(aData, segOffset, segLength, aTxn);
    1: }
    1: 
    1: //XXX: currently, this doesn't handle edge conditions because GetNext/GetPrior are not implemented
    1: NS_IMETHODIMP
    1: nsEditor::CreateTxnForDeleteInsertionPoint(nsIDOMRange          *aRange, 
    1:                                            nsIEditor::EDirection aAction,
    1:                                            EditAggregateTxn     *aTxn,
    1:                                            nsIDOMNode          **aNode,
    1:                                            PRInt32              *aOffset,
    1:                                            PRInt32              *aLength)
    1: {
    1:   NS_ASSERTION(aAction == eNext || aAction == ePrevious, "invalid action");
    1: 
    1:   // get the node and offset of the insertion point
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsresult result = aRange->GetStartContainer(getter_AddRefs(node));
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   PRInt32 offset;
    1:   result = aRange->GetStartOffset(&offset);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   // determine if the insertion point is at the beginning, middle, or end of the node
    1:   nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(node);
    1: 
    1:   PRUint32 count=0;
    1: 
    1:   if (nodeAsText)
    1:     nodeAsText->GetLength(&count);
    1:   else
    1:   { 
    1:     // get the child list and count
    1:     nsCOMPtr<nsIDOMNodeList>childList;
    1:     result = node->GetChildNodes(getter_AddRefs(childList));
    1:     if ((NS_SUCCEEDED(result)) && childList)
    1:       childList->GetLength(&count);
    1:   }
    1: 
    1:   PRBool isFirst = (0 == offset);
    1:   PRBool isLast  = (count == (PRUint32)offset);
    1: 
    1:   // XXX: if isFirst && isLast, then we'll need to delete the node 
    1:   //      as well as the 1 child
    1: 
    1:   // build a transaction for deleting the appropriate data
    1:   // XXX: this has to come from rule section
    1:   if ((ePrevious==aAction) && (PR_TRUE==isFirst))
    1:   { // we're backspacing from the beginning of the node.  Delete the first thing to our left
    1:     nsCOMPtr<nsIDOMNode> priorNode;
    1:     result = GetPriorNode(node, PR_TRUE, address_of(priorNode));
    1:     if ((NS_SUCCEEDED(result)) && priorNode)
    1:     { // there is a priorNode, so delete it's last child (if text content, delete the last char.)
    1:       // if it has no children, delete it
    1:       nsCOMPtr<nsIDOMCharacterData> priorNodeAsText = do_QueryInterface(priorNode);
    1:       if (priorNodeAsText)
    1:       {
    1:         PRUint32 length=0;
    1:         priorNodeAsText->GetLength(&length);
    1:         if (0<length)
    1:         {
    1:           DeleteTextTxn *txn;
    1:           result = CreateTxnForDeleteCharacter(priorNodeAsText, length,
    1:                                                ePrevious, &txn);
    1:           if (NS_SUCCEEDED(result)) {
    1:             aTxn->AppendChild(txn);
    1:             NS_ADDREF(*aNode = priorNode);
    1:             *aOffset = txn->GetOffset();
    1:             *aLength = txn->GetNumCharsToDelete();
    1:             NS_RELEASE(txn);
    1:           }
    1:         }
    1:         else
    1:         { // XXX: can you have an empty text node?  If so, what do you do?
    1:           printf("ERROR: found a text node with 0 characters\n");
    1:           result = NS_ERROR_UNEXPECTED;
    1:         }
    1:       }
    1:       else
    1:       { // priorNode is not text, so tell it's parent to delete it
    1:         DeleteElementTxn *txn;
    1:         result = CreateTxnForDeleteElement(priorNode, &txn);
    1:         if (NS_SUCCEEDED(result)) {
    1:           aTxn->AppendChild(txn);
    1:           NS_RELEASE(txn);
    1:           NS_ADDREF(*aNode = priorNode);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else if ((nsIEditor::eNext==aAction) && (PR_TRUE==isLast))
    1:   { // we're deleting from the end of the node.  Delete the first thing to our right
    1:     nsCOMPtr<nsIDOMNode> nextNode;
    1:     result = GetNextNode(node, PR_TRUE, address_of(nextNode));
    1:     if ((NS_SUCCEEDED(result)) && nextNode)
    1:     { // there is a nextNode, so delete it's first child (if text content, delete the first char.)
    1:       // if it has no children, delete it
    1:       nsCOMPtr<nsIDOMCharacterData> nextNodeAsText = do_QueryInterface(nextNode);
    1:       if (nextNodeAsText)
    1:       {
    1:         PRUint32 length=0;
    1:         nextNodeAsText->GetLength(&length);
    1:         if (0<length)
    1:         {
    1:           DeleteTextTxn *txn;
    1:           result = CreateTxnForDeleteCharacter(nextNodeAsText, 0, eNext, &txn);
    1:           if (NS_SUCCEEDED(result)) {
    1:             aTxn->AppendChild(txn);
    1:             NS_ADDREF(*aNode = nextNode);
    1:             *aOffset = txn->GetOffset();
    1:             *aLength = txn->GetNumCharsToDelete();
    1:             NS_RELEASE(txn);
    1:           }
    1:         }
    1:         else
    1:         { // XXX: can you have an empty text node?  If so, what do you do?
    1:           printf("ERROR: found a text node with 0 characters\n");
    1:           result = NS_ERROR_UNEXPECTED;
    1:         }
    1:       }
    1:       else
    1:       { // nextNode is not text, so tell it's parent to delete it
    1:         DeleteElementTxn *txn;
    1:         result = CreateTxnForDeleteElement(nextNode, &txn);
    1:         if (NS_SUCCEEDED(result)) {
    1:           aTxn->AppendChild(txn);
    1:           NS_RELEASE(txn);
    1:           NS_ADDREF(*aNode = nextNode);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else
    1:   {
    1:     if (nodeAsText)
    1:     { // we have text, so delete a char at the proper offset
 5270:       nsRefPtr<DeleteTextTxn> txn;
 5270:       result = CreateTxnForDeleteCharacter(nodeAsText, offset, aAction,
 5270:                                            getter_AddRefs(txn));
    1:       if (NS_SUCCEEDED(result)) {
    1:         aTxn->AppendChild(txn);
    1:         NS_ADDREF(*aNode = node);
    1:         *aOffset = txn->GetOffset();
    1:         *aLength = txn->GetNumCharsToDelete();
    1:       }
    1:     }
    1:     else
    1:     { // we're either deleting a node or some text, need to dig into the next/prev node to find out
    1:       nsCOMPtr<nsIDOMNode> selectedNode;
    1:       if (ePrevious==aAction)
    1:       {
    1:         result = GetPriorNode(node, offset, PR_TRUE, address_of(selectedNode));
    1:       }
    1:       else if (eNext==aAction)
    1:       {
    1:         result = GetNextNode(node, offset, PR_TRUE, address_of(selectedNode));
    1:       }
    1:       if (NS_FAILED(result)) { return result; }
    1:       if (selectedNode) 
    1:       {
    1:         nsCOMPtr<nsIDOMCharacterData> selectedNodeAsText =
    1:                                              do_QueryInterface(selectedNode);
    1:         if (selectedNodeAsText)
    1:         { // we are deleting from a text node, so do a text deletion
    1:           PRUint32 position = 0;    // default for forward delete
    1:           if (ePrevious==aAction)
    1:           {
    1:             selectedNodeAsText->GetLength(&position);
    1:           }
 5270:           nsRefPtr<DeleteTextTxn> delTextTxn;
    1:           result = CreateTxnForDeleteCharacter(selectedNodeAsText, position,
 5270:                                                aAction,
 5270:                                                getter_AddRefs(delTextTxn));
    1:           if (NS_FAILED(result))  { return result; }
    1:           if (!delTextTxn) { return NS_ERROR_NULL_POINTER; }
    1:           aTxn->AppendChild(delTextTxn);
    1:           NS_ADDREF(*aNode = selectedNode);
    1:           *aOffset = delTextTxn->GetOffset();
    1:           *aLength = delTextTxn->GetNumCharsToDelete();
    1:         }
    1:         else
    1:         {
 5270:           nsRefPtr<DeleteElementTxn> delElementTxn;
 5270:           result = CreateTxnForDeleteElement(selectedNode,
 5270:                                              getter_AddRefs(delElementTxn));
    1:           if (NS_FAILED(result))  { return result; }
    1:           if (!delElementTxn) { return NS_ERROR_NULL_POINTER; }
    1:           aTxn->AppendChild(delElementTxn);
    1:           NS_ADDREF(*aNode = selectedNode);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::CreateRange(nsIDOMNode *aStartParent, PRInt32 aStartOffset,
    1:                       nsIDOMNode *aEndParent, PRInt32 aEndOffset,
    1:                       nsIDOMRange **aRange)
    1: {
    1:   nsresult result;
    1:   result = CallCreateInstance("@mozilla.org/content/range;1", aRange);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   if (!*aRange)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   result = (*aRange)->SetStart(aStartParent, aStartOffset);
    1: 
    1:   if (NS_SUCCEEDED(result))
    1:     result = (*aRange)->SetEnd(aEndParent, aEndOffset);
    1: 
    1:   if (NS_FAILED(result))
    1:   {
    1:     NS_RELEASE((*aRange));
    1:     *aRange = 0;
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::AppendNodeToSelectionAsRange(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode) return NS_ERROR_NULL_POINTER;
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if(!selection) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMNode> parentNode;
    1:   res = aNode->GetParentNode(getter_AddRefs(parentNode));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!parentNode) return NS_ERROR_NULL_POINTER;
    1:   
    1:   PRInt32 offset;
    1:   res = GetChildOffset(aNode, parentNode, offset);
    1:   if (NS_FAILED(res)) return res;
    1:   
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   res = CreateRange(parentNode, offset, parentNode, offset+1, getter_AddRefs(range));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!range) return NS_ERROR_NULL_POINTER;
    1: 
    1:   return selection->AddRange(range);
    1: }
    1: 
    1: nsresult nsEditor::ClearSelection()
    1: {
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = nsEditor::GetSelection(getter_AddRefs(selection));
    1:   if (NS_FAILED(res)) return res;
    1:   if (!selection) return NS_ERROR_FAILURE;
    1:   return selection->RemoveAllRanges();  
    1: }
    1: 
    1: nsresult
    1: nsEditor::CreateHTMLContent(const nsAString& aTag, nsIContent** aContent)
    1: {
    1:   nsCOMPtr<nsIDOMDocument> tempDoc;
    1:   GetDocument(getter_AddRefs(tempDoc));
    1: 
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(tempDoc);
    1:   if (!doc)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // XXX Wallpaper over editor bug (editor tries to create elements with an
    1:   //     empty nodename).
    1:   if (aTag.IsEmpty()) {
    1:     NS_ERROR("Don't pass an empty tag to nsEditor::CreateHTMLContent, "
    1:              "check caller.");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> tag = do_GetAtom(aTag);
    1:   if (!tag)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(tempDoc);
    1:   if (htmlDoc) {
    1:       return doc->CreateElem(tag, nsnull, doc->GetDefaultNamespaceID(),
    1:                              PR_TRUE, aContent);
    1:   }
    1: 
    1:   return doc->CreateElem(tag, nsnull, kNameSpaceID_XHTML, PR_FALSE, aContent);
    1: }
    1: 
    1: nsresult
    1: nsEditor::SetAttributeOrEquivalent(nsIDOMElement * aElement,
    1:                                    const nsAString & aAttribute,
    1:                                    const nsAString & aValue,
    1:                                    PRBool aSuppressTransaction)
    1: {
    1:   return SetAttribute(aElement, aAttribute, aValue);
    1: }
    1: 
    1: nsresult
    1: nsEditor::RemoveAttributeOrEquivalent(nsIDOMElement * aElement,
    1:                                       const nsAString & aAttribute,
    1:                                       PRBool aSuppressTransaction)
    1: {
    1:   return RemoveAttribute(aElement, aAttribute);
    1: }
    1: 
    1: nsresult
    1: nsEditor::HandleInlineSpellCheck(PRInt32 action,
    1:                                    nsISelection *aSelection,
    1:                                    nsIDOMNode *previousSelectedNode,
    1:                                    PRInt32 previousSelectedOffset,
    1:                                    nsIDOMNode *aStartNode,
    1:                                    PRInt32 aStartOffset,
    1:                                    nsIDOMNode *aEndNode,
    1:                                    PRInt32 aEndOffset)
    1: {
    1:   return mInlineSpellChecker ? mInlineSpellChecker->SpellCheckAfterEditorChange(action,
    1:                                                        aSelection,
    1:                                                        previousSelectedNode,
    1:                                                        previousSelectedOffset,
    1:                                                        aStartNode,
    1:                                                        aStartOffset,
    1:                                                        aEndNode,
    1:                                                        aEndOffset) : NS_OK;
    1: }
    1: 
 1418: already_AddRefed<nsPIDOMEventTarget>
 1418: nsEditor::GetPIDOMEventTarget()
 1418: {
 1418:   nsPIDOMEventTarget* piTarget = mEventTarget;
 1418:   if (piTarget)
 1418:   {
 1418:     NS_ADDREF(piTarget);
 1418:     return piTarget;
    1:   }
    1: 
    1:   nsIDOMElement *rootElement = GetRoot();
    1: 
    1:   // Now hack to make sure we are not anonymous content.
    1:   // If we are grab the parent of root element for our observer.
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(rootElement);
    1: 
16126:   if (content && content->IsRootOfNativeAnonymousSubtree())
    1:   {
 1418:     mEventTarget = do_QueryInterface(content->GetParent());
 1418:     piTarget = mEventTarget;
 1418:     NS_IF_ADDREF(piTarget);
    1:   }
    1:   else
    1:   {
    1:     // Don't use getDocument here, because we have no way of knowing
    1:     // if Init() was ever called.  So we need to get the document
    1:     // ourselves, if it exists.
    1:     if (mDocWeak)
    1:     {
 1418:       CallQueryReferent(mDocWeak.get(), &piTarget);
    1:     }
    1:     else
    1:     {
    1:       NS_ERROR("not initialized yet");
    1:     }
    1:   }
    1: 
 1418:   return piTarget;
    1: }
    1: 
    1: nsIDOMElement *
    1: nsEditor::GetRoot()
    1: {
    1:   if (!mRootElement)
    1:   {
    1:     nsCOMPtr<nsIDOMElement> root;
    1: 
    1:     // Let GetRootElement() do the work
    1:     GetRootElement(getter_AddRefs(root));
    1:   }
    1: 
    1:   return mRootElement;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SwitchTextDirection()
    1: {
    1:   // Get the current root direction from its frame
    1:   nsIDOMElement *rootElement = GetRoot();
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(rootElement, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   rv = GetPresShell(getter_AddRefs(presShell));
    1:   if (NS_FAILED(rv))
    1:     return rv;  
    1: 
    1:   nsIFrame *frame = presShell->GetPrimaryFrameFor(content);
    1:   if (!frame)
    1:     return NS_ERROR_FAILURE; 
    1: 
    1:   // Apply the opposite direction
    1:   if (frame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL)
    1:     rv = rootElement->SetAttribute(NS_LITERAL_STRING("dir"), NS_LITERAL_STRING("ltr"));
    1:   else
    1:     rv = rootElement->SetAttribute(NS_LITERAL_STRING("dir"), NS_LITERAL_STRING("rtl"));
    1: 
    1:   return rv;
    1: }
    1: 
    1: #if DEBUG_JOE
    1: void
    1: nsEditor::DumpNode(nsIDOMNode *aNode, PRInt32 indent)
    1: {
    1:   PRInt32 i;
    1:   for (i=0; i<indent; i++)
    1:     printf("  ");
    1:   
    1:   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aNode);
    1:   nsCOMPtr<nsIDOMDocumentFragment> docfrag = do_QueryInterface(aNode);
    1:   
    1:   if (element || docfrag)
    1:   { 
    1:     if (element)
    1:     {
    1:       nsAutoString tag;
    1:       element->GetTagName(tag);
    1:       printf("<%s>\n", NS_LossyConvertUTF16toASCII(tag).get());
    1:     }
    1:     else
    1:     {
    1:       printf("<document fragment>\n");
    1:     }
    1:     nsCOMPtr<nsIDOMNodeList> childList;
    1:     aNode->GetChildNodes(getter_AddRefs(childList));
    1:     if (!childList) return NS_ERROR_NULL_POINTER;
    1:     PRUint32 numChildren;
    1:     childList->GetLength(&numChildren);
    1:     nsCOMPtr<nsIDOMNode> child, tmp;
    1:     aNode->GetFirstChild(getter_AddRefs(child));
    1:     for (i=0; i<numChildren; i++)
    1:     {
    1:       DumpNode(child, indent+1);
    1:       child->GetNextSibling(getter_AddRefs(tmp));
    1:       child = tmp;
    1:     }
    1:   }
    1:   else if (IsTextNode(aNode))
    1:   {
    1:     nsCOMPtr<nsIDOMCharacterData> textNode = do_QueryInterface(aNode);
    1:     nsAutoString str;
    1:     textNode->GetData(str);
    1:     nsCAutoString cstr;
    1:     LossyCopyUTF16toASCII(str, cstr);
    1:     cstr.ReplaceChar('\n', ' ');
    1:     printf("<textnode> %s\n", cstr.get());
    1:   }
    1: }
    1: #endif
 2896: 
 2896: PRBool
 2896: nsEditor::IsModifiableNode(nsIDOMNode *aNode)
 2896: {
 2896:   return PR_TRUE;
 2896: }
