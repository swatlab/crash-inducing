    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developers of the Original Code are
    1:  * Sun Microsystems and IBM Corporation
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Ginn Chen (ginn.chen@sun.com)
    1:  *   Aaron Leventhal (aleventh@us.ibm.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsHyperTextAccessible.h"
    1: #include "nsAccessibilityAtoms.h"
    1: #include "nsAccessibilityService.h"
    1: #include "nsAccessibleTreeWalker.h"
24999: #include "nsTextAttrs.h"
16001: 
    1: #include "nsIClipboard.h"
    1: #include "nsContentCID.h"
    1: #include "nsIDOMAbstractView.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIDOMDocument.h"
 4625: #include "nsPIDOMWindow.h"        
    1: #include "nsIDOMDocumentView.h"
    1: #include "nsIDOMRange.h"
16001: #include "nsIDOMNSRange.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIDOMXULDocument.h"
 4625: #include "nsIEditingSession.h"
 4625: #include "nsIEditor.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsIFrame.h"
 8755: #include "nsFrameSelection.h"
 8901: #include "nsILineIterator.h"
 4625: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIPlaintextEditor.h"
 8901: #include "nsIScrollableFrame.h"
 6072: #include "nsISelection2.h"
 8755: #include "nsISelectionPrivate.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsTextFragment.h"
 4261: #include "gfxSkipChars.h"
    1: 
    1: static NS_DEFINE_IID(kRangeCID, NS_RANGE_CID);
    1: 
    1: // ------------
    1: // nsHyperTextAccessible
    1: // ------------
    1: 
 4625: NS_IMPL_ADDREF_INHERITED(nsHyperTextAccessible, nsAccessibleWrap)
 4625: NS_IMPL_RELEASE_INHERITED(nsHyperTextAccessible, nsAccessibleWrap)
    1: 
    1: nsresult nsHyperTextAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   *aInstancePtr = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMXULDocument> xulDoc(do_QueryInterface(mDOMNode));
    1:   if (mDOMNode && !xulDoc) {
 4341:     // We need XUL doc check for now because for now nsDocAccessible must
 4341:     // inherit from nsHyperTextAccessible in order for HTML document accessibles
 4341:     // to get support for these interfaces.
    1:     // However at some point we may push <body> to implement the interfaces and
 4341:     // return nsDocAccessible to inherit from nsAccessibleWrap.
 4341: 
 4751:     if (aIID.Equals(NS_GET_IID(nsHyperTextAccessible))) {
 4751:       *aInstancePtr = static_cast<nsHyperTextAccessible*>(this);
 4751:       NS_ADDREF_THIS();
 4751:       return NS_OK;
 4751:     }
 4751: 
 7766:     if (mRoleMapEntry &&
 7766:         (mRoleMapEntry->role == nsIAccessibleRole::ROLE_GRAPHIC ||
10667:          mRoleMapEntry->role == nsIAccessibleRole::ROLE_IMAGE_MAP ||
10667:          mRoleMapEntry->role == nsIAccessibleRole::ROLE_SLIDER ||
10667:          mRoleMapEntry->role == nsIAccessibleRole::ROLE_PROGRESSBAR ||
10667:          mRoleMapEntry->role == nsIAccessibleRole::ROLE_SEPARATOR)) {
 7766:       // ARIA roles that these interfaces are not appropriate for
 4847:       return nsAccessible::QueryInterface(aIID, aInstancePtr);
 4847:     }
 4847: 
    1:     if (aIID.Equals(NS_GET_IID(nsIAccessibleText))) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleText*>(this);
    1:       NS_ADDREF_THIS();
    1:       return NS_OK;
    1:     }
 4341: 
 4341:     if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperText))) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleHyperText*>(this);
    1:       NS_ADDREF_THIS();
    1:       return NS_OK;
    1:     }
 4341: 
 4341:     if (aIID.Equals(NS_GET_IID(nsIAccessibleEditableText))) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleEditableText*>(this);
    1:       NS_ADDREF_THIS();
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return nsAccessible::QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
    1: nsHyperTextAccessible::nsHyperTextAccessible(nsIDOMNode* aNode, nsIWeakReference* aShell):
    1: nsAccessibleWrap(aNode, aShell)
    1: {
    1: }
    1: 
25822: nsresult
25822: nsHyperTextAccessible::GetRoleInternal(PRUint32 *aRole)
    1: {
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
    1:   if (!content) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsIAtom *tag = content->Tag();
    1: 
 3151:   if (tag == nsAccessibilityAtoms::form) {
    1:     *aRole = nsIAccessibleRole::ROLE_FORM;
    1:   }
    1:   else if (tag == nsAccessibilityAtoms::div ||
    1:            tag == nsAccessibilityAtoms::blockquote) {
    1:     *aRole = nsIAccessibleRole::ROLE_SECTION;
    1:   }
    1:   else if (tag == nsAccessibilityAtoms::h1 ||
    1:            tag == nsAccessibilityAtoms::h2 ||
    1:            tag == nsAccessibilityAtoms::h3 ||
    1:            tag == nsAccessibilityAtoms::h4 ||
    1:            tag == nsAccessibilityAtoms::h5 ||
    1:            tag == nsAccessibilityAtoms::h6) {
    1:     *aRole = nsIAccessibleRole::ROLE_HEADING;
    1:   }
    1:   else {
    1:     nsIFrame *frame = GetFrame();
23749:     if (frame && frame->GetType() == nsAccessibilityAtoms::blockFrame &&
23749:         frame->GetContent()->Tag() != nsAccessibilityAtoms::input) {
23749:       // An html:input @type="file" is the only input that is exposed as a
23749:       // blockframe. It must be exposed as ROLE_TEXT_CONTAINER for JAWS.
    1:       *aRole = nsIAccessibleRole::ROLE_PARAGRAPH;
    1:     }
    1:     else {
    1:       *aRole = nsIAccessibleRole::ROLE_TEXT_CONTAINER; // In ATK this works
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
21256: nsresult
21256: nsHyperTextAccessible::GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
21256:   nsresult rv = nsAccessibleWrap::GetStateInternal(aState, aExtraState);
21984:   NS_ENSURE_A11Y_SUCCESS(rv, rv);
21984: 
21984:   if (!aExtraState)
  262:     return NS_OK;
  262: 
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1:   if (editor) {
    1:     PRUint32 flags;
    1:     editor->GetFlags(&flags);
    1:     if (0 == (flags & nsIPlaintextEditor::eEditorReadonlyMask)) {
  262:       *aExtraState |= nsIAccessibleStates::EXT_STATE_EDITABLE;
    1:     }
    1:   }
    1: 
    1:   PRInt32 childCount;
    1:   GetChildCount(&childCount);
    1:   if (childCount > 0) {
  262:     *aExtraState |= nsIAccessibleStates::EXT_STATE_SELECTABLE_TEXT;
    1:   }
  262: 
  262:   return NS_OK;
    1: }
    1: 
    1: void nsHyperTextAccessible::CacheChildren()
    1: {
    1:   if (!mWeakShell) {
    1:     // This node has been shut down
    1:     mAccChildCount = eChildCountUninitialized;
    1:     return;
    1:   }
    1: 
 4625:   // Special case for text entry fields, go directly to editor's root for children
    1:   if (mAccChildCount == eChildCountUninitialized) {
 4625:     PRUint32 role;
25822:     GetRoleInternal(&role);
 4625:     if (role != nsIAccessibleRole::ROLE_ENTRY && role != nsIAccessibleRole::ROLE_PASSWORD_TEXT) {
 4625:       nsAccessible::CacheChildren();
 4625:       return;
 4625:     }
 4625:     nsCOMPtr<nsIEditor> editor;
 4625:     GetAssociatedEditor(getter_AddRefs(editor));
    1:     if (!editor) {
    1:       nsAccessible::CacheChildren();
    1:       return;
    1:     }
 8617:     mAccChildCount = 0;  // Avoid reentry
    1:     nsCOMPtr<nsIDOMElement> editorRoot;
    1:     editor->GetRootElement(getter_AddRefs(editorRoot));
    1:     nsCOMPtr<nsIDOMNode> editorRootDOMNode = do_QueryInterface(editorRoot);
    1:     if (!editorRootDOMNode) {
    1:       return;
    1:     }
    1:     nsAccessibleTreeWalker walker(mWeakShell, editorRootDOMNode, PR_TRUE);
29320:     nsRefPtr<nsAccessible> prevAcc;
    1:     PRInt32 childCount = 0;
    1:     walker.GetFirstChild();
    1:     SetFirstChild(walker.mState.accessible);
    1: 
    1:     while (walker.mState.accessible) {
    1:       ++ childCount;
29320:       prevAcc = nsAccUtils::QueryAccessible(walker.mState.accessible);
29320:       prevAcc->SetParent(this);
    1:       walker.GetNextSibling();
29320:       prevAcc->SetNextSibling(walker.mState.accessible);
    1:     }
    1:     mAccChildCount = childCount;
    1:   }
    1: }
    1: 
    1: // Substring must be entirely within the same text node
 4468: nsIntRect nsHyperTextAccessible::GetBoundsForString(nsIFrame *aFrame, PRUint32 aStartRenderedOffset,
 4468:                                                     PRUint32 aEndRenderedOffset)
    1: {
    1:   nsIntRect screenRect;
 4261:   NS_ENSURE_TRUE(aFrame, screenRect);
 5693:   if (aFrame->GetType() != nsAccessibilityAtoms::textFrame) {
 5693:     // XXX fallback for non-text frames, happens for bullets right now
 5693:     // but in the future bullets will have proper text frames
 5693:     return aFrame->GetScreenRectExternal();
 5693:   }
 4261: 
 4468:   PRInt32 startContentOffset, endContentOffset;
 4468:   nsresult rv = RenderedToContentOffset(aFrame, aStartRenderedOffset, &startContentOffset);
 4261:   NS_ENSURE_SUCCESS(rv, screenRect);
 4468:   rv = RenderedToContentOffset(aFrame, aEndRenderedOffset, &endContentOffset);
 4261:   NS_ENSURE_SUCCESS(rv, screenRect);
 4261: 
    1:   nsIFrame *frame;
 4468:   PRInt32 startContentOffsetInFrame;
 4261:   // Get the right frame continuation -- not really a child, but a sibling of
 4261:   // the primary frame passed in
 4468:   rv = aFrame->GetChildFrameContainingOffset(startContentOffset, PR_FALSE,
 4468:                                              &startContentOffsetInFrame, &frame);
    1:   NS_ENSURE_SUCCESS(rv, screenRect);
    1: 
    1:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
    1:   NS_ENSURE_TRUE(shell, screenRect);
    1: 
    1:   nsPresContext *context = shell->GetPresContext();
    1: 
 4468:   while (frame && startContentOffset < endContentOffset) {
    1:     // Start with this frame's screen rect, which we will 
    1:     // shrink based on the substring we care about within it.
    1:     // We will then add that frame to the total screenRect we
    1:     // are returning.
    1:     nsIntRect frameScreenRect = frame->GetScreenRectExternal();
    1: 
    1:     // Get the length of the substring in this frame that we want the bounds for
    1:     PRInt32 startFrameTextOffset, endFrameTextOffset;
    1:     frame->GetOffsets(startFrameTextOffset, endFrameTextOffset);
    1:     PRInt32 frameTotalTextLength = endFrameTextOffset - startFrameTextOffset;
 4468:     PRInt32 seekLength = endContentOffset - startContentOffset;
 4468:     PRInt32 frameSubStringLength = PR_MIN(frameTotalTextLength - startContentOffsetInFrame, seekLength);
    1: 
    1:     // Add the point where the string starts to the frameScreenRect
    1:     nsPoint frameTextStartPoint;
 4741:     rv = frame->GetPointFromOffset(startContentOffset, &frameTextStartPoint);
23738:     NS_ENSURE_SUCCESS(rv, nsIntRect());
    1:     frameScreenRect.x += context->AppUnitsToDevPixels(frameTextStartPoint.x);
    1: 
    1:     // Use the point for the end offset to calculate the width
    1:     nsPoint frameTextEndPoint;
 4741:     rv = frame->GetPointFromOffset(startContentOffset + frameSubStringLength, &frameTextEndPoint);
23738:     NS_ENSURE_SUCCESS(rv, nsIntRect());
    1:     frameScreenRect.width = context->AppUnitsToDevPixels(frameTextEndPoint.x - frameTextStartPoint.x);
    1: 
    1:     screenRect.UnionRect(frameScreenRect, screenRect);
    1: 
    1:     // Get ready to loop back for next frame continuation
 4468:     startContentOffset += frameSubStringLength;
 4468:     startContentOffsetInFrame = 0;
    1:     frame = frame->GetNextContinuation();
    1:   }
    1: 
    1:   return screenRect;
    1: }
    1: 
    1: /*
    1:  * Gets the specified text.
    1:  */
 4616: nsIFrame*
 4616: nsHyperTextAccessible::GetPosAndText(PRInt32& aStartOffset, PRInt32& aEndOffset,
 4616:                                      nsAString *aText, nsIFrame **aEndFrame,
 5245:                                      nsIntRect *aBoundsRect,
 5245:                                      nsIAccessible **aStartAcc,
 5245:                                      nsIAccessible **aEndAcc)
    1: {
 8755:   if (aStartOffset == nsIAccessibleText::TEXT_OFFSET_END_OF_TEXT) {
 6073:     GetCharacterCount(&aStartOffset);
 6073:   }
 8755:   if (aStartOffset == nsIAccessibleText::TEXT_OFFSET_CARET) {
 8755:     GetCaretOffset(&aStartOffset);
 8755:   }
 8755:   if (aEndOffset == nsIAccessibleText::TEXT_OFFSET_END_OF_TEXT) {
 6073:     GetCharacterCount(&aEndOffset);
 6073:   }
 8755:   if (aEndOffset == nsIAccessibleText::TEXT_OFFSET_CARET) {
 8755:     GetCaretOffset(&aEndOffset);
 8755:   }
 6073: 
    1:   PRInt32 startOffset = aStartOffset;
    1:   PRInt32 endOffset = aEndOffset;
11543:   // XXX this prevents text interface usage on <input type="password">
20566:   PRBool isPassword =
20566:     (nsAccUtils::Role(this) == nsIAccessibleRole::ROLE_PASSWORD_TEXT);
    1: 
    1:   // Clear out parameters and set up loop
    1:   if (aText) {
    1:     aText->Truncate();
    1:   }
    1:   if (endOffset < 0) {
    1:     const PRInt32 kMaxTextLength = 32767;
    1:     endOffset = kMaxTextLength; // Max end offset
    1:   }
    1:   else if (startOffset > endOffset) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIFrame *startFrame = nsnull;
    1:   if (aEndFrame) {
    1:     *aEndFrame = nsnull;
    1:   }
    1:   if (aBoundsRect) {
    1:     aBoundsRect->Empty();
    1:   }
 5245:   if (aStartAcc)
 5245:     *aStartAcc = nsnull;
 5245:   if (aEndAcc)
 5245:     *aEndAcc = nsnull;
    1: 
    1:   nsIntRect unionRect;
 6073:   nsCOMPtr<nsIAccessible> accessible, lastAccessible;
    1: 
 4261:   gfxSkipChars skipChars;
 4261:   gfxSkipCharsIterator iter;
 4261: 
    1:   // Loop through children and collect valid offsets, text and bounds
    1:   // depending on what we need for out parameters
    1:   while (NextChild(accessible)) {
 6073:     lastAccessible = accessible;
21169:     nsRefPtr<nsAccessNode> accessNode = nsAccUtils::QueryAccessNode(accessible);
21169: 
    1:     nsIFrame *frame = accessNode->GetFrame();
    1:     if (!frame) {
    1:       continue;
    1:     }
 4616:     nsIFrame *primaryFrame = frame;
20566:     if (nsAccUtils::IsText(accessible)) {
 4616:       // We only need info up to rendered offset -- that is what we're
 4616:       // converting to content offset
 5693:       PRInt32 substringEndOffset = -1;
 5693:       PRUint32 ourRenderedStart = 0;
 5693:       PRInt32 ourContentStart = 0;
 5693:       if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
 4261:         nsresult rv = frame->GetRenderedText(nsnull, &skipChars, &iter);
 4261:         if (NS_SUCCEEDED(rv)) {
 5693:           ourRenderedStart = iter.GetSkippedOffset();
 5693:           ourContentStart = iter.GetOriginalOffset();
 4616:           substringEndOffset =
 4616:             iter.ConvertOriginalToSkipped(skipChars.GetOriginalCharCount() +
 5693:                                           ourContentStart) - ourRenderedStart;
 4261:         }
 5693:       }
 5693:       if (substringEndOffset < 0) {
 4616:         // XXX for non-textframe text like list bullets,
 4616:         // should go away after list bullet rewrite
20566:         substringEndOffset = nsAccUtils::TextLength(accessible);
 4261:       }
    1:       if (startOffset < substringEndOffset) {
    1:         // Our start is within this substring
    1:         if (startOffset > 0 || endOffset < substringEndOffset) {
 4261:           // We don't want the whole string for this accessible
 4261:           // Get out the continuing text frame with this offset
    1:           PRInt32 outStartLineUnused;
 5693:           PRInt32 contentOffset;
 5693:           if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
 5699:             contentOffset = iter.ConvertSkippedToOriginal(startOffset) +
 5699:                             ourRenderedStart - ourContentStart;
 5693:           }
 5693:           else {
 5693:             contentOffset = startOffset;
 5693:           }
 4616:           frame->GetChildFrameContainingOffset(contentOffset, PR_TRUE,
 4616:                                                &outStartLineUnused, &frame);
    1:           if (aEndFrame) {
    1:             *aEndFrame = frame; // We ended in the current frame
 5245:             if (aEndAcc)
 5245:               NS_ADDREF(*aEndAcc = accessible);
    1:           }
 4261:           if (substringEndOffset > endOffset) {
 4261:             // Need to stop before the end of the available text
 4261:             substringEndOffset = endOffset;
 4261:           }
    1:           aEndOffset = endOffset;
    1:         }
    1:         if (aText) {
11543:           if (isPassword) {
11543:             for (PRInt32 count = startOffset; count < substringEndOffset; count ++)
11543:               *aText += '*'; // Show *'s only for password text
11543:           }
11543:           else {
29320:             nsRefPtr<nsAccessible> acc(nsAccUtils::QueryAccessible(accessible));
29320:             acc->AppendTextTo(*aText, startOffset,
 4616:                               substringEndOffset - startOffset);
    1:           }
11543:         }
 4261:         if (aBoundsRect) {    // Caller wants the bounds of the text
 4616:           aBoundsRect->UnionRect(*aBoundsRect,
 4616:                                  GetBoundsForString(primaryFrame, startOffset,
 4261:                                                     substringEndOffset));
    1:         }
    1:         if (!startFrame) {
    1:           startFrame = frame;
    1:           aStartOffset = startOffset;
 5245:           if (aStartAcc)
 5245:             NS_ADDREF(*aStartAcc = accessible);
    1:         }
 4261:         // We already started copying in this accessible's string,
 4261:         // for the next accessible we'll start at offset 0
    1:         startOffset = 0;
    1:       }
    1:       else {
 4261:         // We have not found the start position yet, get the new startOffset
 4261:         // that is relative to next accessible
    1:         startOffset -= substringEndOffset;
    1:       }
 4261:       // The endOffset needs to be relative to the new startOffset
    1:       endOffset -= substringEndOffset;
    1:     }
    1:     else {
    1:       // Embedded object, append marker
    1:       // XXX Append \n for <br>'s
    1:       if (startOffset >= 1) {
    1:         -- startOffset;
    1:       }
    1:       else {
    1:         if (endOffset > 0) {
    1:           if (aText) {
 8105:             if (frame->GetType() == nsAccessibilityAtoms::brFrame) {
 8105:               *aText += kForcedNewLineChar;
20566:             } else if (nsAccUtils::MustPrune(this)) {
 8105:               *aText += kImaginaryEmbeddedObjectChar;
 8105:               // Expose imaginary embedded object character if the accessible
 8105:               // hans't children.
 8105:             } else {
 8105:               *aText += kEmbeddedObjectChar;
 8105:             }
    1:           }
    1:           if (aBoundsRect) {
 4616:             aBoundsRect->UnionRect(*aBoundsRect,
 4616:                                    frame->GetScreenRectExternal());
    1:           }
    1:         }
    1:         if (!startFrame) {
    1:           startFrame = frame;
    1:           aStartOffset = 0;
 5245:           if (aStartAcc)
 5245:             NS_ADDREF(*aStartAcc = accessible);
    1:         }
    1:       }
    1:       -- endOffset;
    1:     }
    1:     if (endOffset <= 0 && startFrame) {
    1:       break; // If we don't have startFrame yet, get that in next loop iteration
    1:     }
    1:   }
    1: 
 6073:   if (aStartAcc && !*aStartAcc) {
 6073:     NS_IF_ADDREF(*aStartAcc = lastAccessible);
 6073:   }
    1:   if (aEndFrame && !*aEndFrame) {
    1:     *aEndFrame = startFrame;
 5245:     if (aStartAcc && aEndAcc)
 6073:       NS_IF_ADDREF(*aEndAcc = *aStartAcc);
    1:   }
    1: 
    1:   return startFrame;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::GetText(PRInt32 aStartOffset, PRInt32 aEndOffset, nsAString &aText)
    1: {
    1:   if (!mDOMNode) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   return GetPosAndText(aStartOffset, aEndOffset, &aText) ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: /*
    1:  * Gets the character count.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterCount(PRInt32 *aCharacterCount)
    1: {
    1:   *aCharacterCount = 0;
    1:   if (!mDOMNode) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAccessible> accessible;
    1: 
    1:   while (NextChild(accessible)) {
20566:     PRInt32 textLength = nsAccUtils::TextLength(accessible);
 4261:     NS_ENSURE_TRUE(textLength >= 0, nsnull);
 4261:     *aCharacterCount += textLength;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Gets the specified character.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterAtOffset(PRInt32 aOffset, PRUnichar *aCharacter)
    1: {
    1:   if (!mDOMNode) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   nsAutoString text;
    1:   nsresult rv = GetText(aOffset, aOffset + 1, text);
 4341:   if (NS_FAILED(rv)) {
 4341:     return rv;
 4341:   }
 4341: 
 4261:   if (text.IsEmpty()) {
 4261:     return NS_ERROR_FAILURE;
 4261:   }
    1:   *aCharacter = text.First();
    1:   return NS_OK;
    1: }
    1: 
 4261: nsresult nsHyperTextAccessible::DOMPointToHypertextOffset(nsIDOMNode* aNode, PRInt32 aNodeOffset,
 4261:                                                           PRInt32* aHyperTextOffset,
 6072:                                                           nsIAccessible **aFinalAccessible,
 6072:                                                           PRBool aIsEndOffset)
    1: {
    1:   // Turn a DOM Node and offset into an offset into this hypertext.
    1:   // On failure, return null. On success, return the DOM node which contains the offset.
 4261:   NS_ENSURE_ARG_POINTER(aHyperTextOffset);
 4261:   *aHyperTextOffset = 0;
10667: 
10667:   if (!aNode) {
10667:     return NS_ERROR_FAILURE;
10667:   }
    1:   if (aFinalAccessible) {
    1:     *aFinalAccessible = nsnull;
    1:   }
    1: 
 4261:   PRUint32 addTextOffset = 0;
    1:   nsCOMPtr<nsIDOMNode> findNode;
    1: 
    1:   unsigned short nodeType;
    1:   aNode->GetNodeType(&nodeType);
 5395:   if (aNodeOffset == -1) {
 5395:     findNode = aNode;
 5395:   }
 5395:   else if (nodeType == nsIDOMNode::TEXT_NODE) {
    1:     // For text nodes, aNodeOffset comes in as a character offset
    1:     // Text offset will be added at the end, if we find the offset in this hypertext
 4261:     // We want the "skipped" offset into the text (rendered text without the extra whitespace)
 4261:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 4261:     NS_ASSERTION(content, "No nsIContent for dom node");
 4261:     nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 4261:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
 4261:     nsIFrame *frame = presShell->GetPrimaryFrameFor(content);
 4261:     NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 4261:     nsresult rv = ContentToRenderedOffset(frame, aNodeOffset, &addTextOffset);
 4261:     NS_ENSURE_SUCCESS(rv, rv);
    1:     // Get the child node and 
    1:     findNode = aNode;
    1:   }
    1:   else {
    1:     // For non-text nodes, aNodeOffset comes in as a child node index
    1:     nsCOMPtr<nsIContent> parentContent(do_QueryInterface(aNode));
    1:     // Should not happen, but better to protect against crash if doc node is somehow passed in
    1:     NS_ENSURE_TRUE(parentContent, NS_ERROR_FAILURE);
  648:     // findNode could be null if aNodeOffset == # of child nodes, which means one of two things:
  648:     // 1) we're at the end of the children, keep findNode = null, so that we get the last possible offset
 4516:     // 2) there are no children and the passed-in node is mDOMNode, which means we're an aempty nsIAccessibleText
 4516:     // 3) there are no children, and the passed-in node is not mDOMNode -- use parentContent for the node to find
  648:      
    1:     findNode = do_QueryInterface(parentContent->GetChildAt(aNodeOffset));
  648:     if (!findNode && !aNodeOffset) {
 4516:       if (SameCOMIdentity(parentContent, mDOMNode)) {
 4516:         // There are no children, which means this is an empty nsIAccessibleText, in which
 4516:         // case we can only be at hypertext offset 0
 4516:         *aHyperTextOffset = 0;
 4516:         return NS_OK;
 4516:       }
  648:       findNode = do_QueryInterface(parentContent); // Case #2: there are no children
  648:     }
    1:   }
    1: 
    1:   // Get accessible for this findNode, or if that node isn't accessible, use the
    1:   // accessible for the next DOM node which has one (based on forward depth first search)
    1:   nsCOMPtr<nsIAccessible> descendantAccessible;
    1:   if (findNode) {
10510:     nsCOMPtr<nsIContent> findContent = do_QueryInterface(findNode);
33329:     if (findContent->IsHTML() && 
10510:         findContent->NodeInfo()->Equals(nsAccessibilityAtoms::br)) {
10510:       nsIContent *parent = findContent->GetParent();
16126:       if (parent &&
16126:           parent->IsRootOfNativeAnonymousSubtree() &&
16126:           parent->GetChildCount() == 1) {
10510:         // This <br> is the only node in a text control, therefore it is the hacky
10510:         // "bogus node" used when there is no text in a control
10510:         *aHyperTextOffset = 0;
10510:         return NS_OK;
10510:       }
10510:     }
    1:     descendantAccessible = GetFirstAvailableAccessible(findNode);
    1:   }
    1:   // From the descendant, go up and get the immediate child of this hypertext
    1:   nsCOMPtr<nsIAccessible> childAccessible;
    1:   while (descendantAccessible) {
    1:     nsCOMPtr<nsIAccessible> parentAccessible;
    1:     descendantAccessible->GetParent(getter_AddRefs(parentAccessible));
    1:     if (this == parentAccessible) {
    1:       childAccessible = descendantAccessible;
    1:       break;
    1:     }
    1:     // This offset no longer applies because the passed-in text object is not a child
    1:     // of the hypertext. This happens when there are nested hypertexts, e.g.
    1:     // <div>abc<h1>def</h1>ghi</div>
    1:     // If the passed-in DOM point was not on a direct child of the hypertext, we will
    1:     // return the offset for that entire hypertext
 6072:     if (aIsEndOffset) {
 6072:       // Not inclusive, the indicated char comes at index before this offset
 6072:       // If the end offset is after the first character of the passed in object, use 1 for
 1318:     // addTextOffset, to put us after the embedded object char. We'll only treat the offset as
 1318:     // before the embedded object char if we end at the very beginning of the child.
 1318:     addTextOffset = addTextOffset > 0;
 6072:     }
 6072:     else {
 6072:       // Start offset, inclusive
 6072:       // Make sure the offset lands on the embedded object character in order to indicate
 6072:       // the true inner offset is inside the subtree for that link
20566:       addTextOffset =
20566:         (nsAccUtils::TextLength(descendantAccessible) == static_cast<PRInt32>(addTextOffset)) ? 1 : 0;
 6072:     }
  764:     descendantAccessible = parentAccessible;
    1:   }  
    1: 
    1:   // Loop through, adding offsets until we reach childAccessible
    1:   // If childAccessible is null we will end up adding up the entire length of
    1:   // the hypertext, which is good -- it just means our offset node
    1:   // came after the last accessible child's node
    1:   nsCOMPtr<nsIAccessible> accessible;
    1:   while (NextChild(accessible) && accessible != childAccessible) {
20566:     PRInt32 textLength = nsAccUtils::TextLength(accessible);
 4261:     NS_ENSURE_TRUE(textLength >= 0, nsnull);
 4261:     *aHyperTextOffset += textLength;
    1:   }
    1:   if (accessible) {
 4261:     *aHyperTextOffset += addTextOffset;
    1:     NS_ASSERTION(accessible == childAccessible, "These should be equal whenever we exit loop and accessible != nsnull");
20566:     if (aFinalAccessible &&
20566:         (NextChild(accessible) ||
20566:          static_cast<PRInt32>(addTextOffset) < nsAccUtils::TextLength(childAccessible))) {  
    1:       // If not at end of last text node, we will return the accessible we were in
    1:       NS_ADDREF(*aFinalAccessible = childAccessible);
    1:     }
    1:   }
 5395: 
    1:   return NS_OK;
    1: }
    1: 
 6286: nsresult
16001: nsHyperTextAccessible::HypertextOffsetToDOMPoint(PRInt32 aHTOffset,
16001:                                                  nsIDOMNode **aNode,
16001:                                                  PRInt32 *aOffset)
16001: {
16001:   nsCOMPtr<nsIDOMNode> endNode;
16001:   PRInt32 endOffset;
16001: 
16001:   return HypertextOffsetsToDOMRange(aHTOffset, aHTOffset, aNode, aOffset,
16001:                                     getter_AddRefs(endNode), &endOffset);
16001: }
16001: 
16001: nsresult
 6286: nsHyperTextAccessible::HypertextOffsetsToDOMRange(PRInt32 aStartHTOffset,
 6286:                                                   PRInt32 aEndHTOffset,
 6286:                                                   nsIDOMNode **aStartNode,
 6286:                                                   PRInt32 *aStartOffset,
 6286:                                                   nsIDOMNode **aEndNode,
 6286:                                                   PRInt32 *aEndOffset)
 6286: {
 6286:   NS_ENSURE_ARG_POINTER(aStartNode);
 6286:   *aStartNode = nsnull;
 6286: 
 6286:   NS_ENSURE_ARG_POINTER(aStartOffset);
 6286:   *aStartOffset = -1;
 6286: 
 6286:   NS_ENSURE_ARG_POINTER(aEndNode);
 6286:   *aEndNode = nsnull;
 6286: 
 6286:   NS_ENSURE_ARG_POINTER(aEndOffset);
 6286:   *aEndOffset = -1;
 6286: 
18505:   // If the given offsets are 0 and associated editor is empty then return
18505:   // collapsed range with editor root element as range container.
18505:   if (aStartHTOffset == 0 && aEndHTOffset == 0) {
18505:     nsCOMPtr<nsIEditor> editor;
18505:     GetAssociatedEditor(getter_AddRefs(editor));
18505:     if (editor) {
18505:       PRBool isEmpty = PR_FALSE;
18505:       editor->GetDocumentIsEmpty(&isEmpty);
18505:       if (isEmpty) {
18505:         nsCOMPtr<nsIDOMElement> editorRootElm;
18505:         editor->GetRootElement(getter_AddRefs(editorRootElm));
18505: 
18505:         nsCOMPtr<nsIDOMNode> editorRoot(do_QueryInterface(editorRootElm));
18505:         if (editorRoot) {
18505:           *aStartOffset = *aEndOffset = 0;
18505:           NS_ADDREF(*aStartNode = editorRoot);
18505:           NS_ADDREF(*aEndNode = editorRoot);
18505: 
18505:           return NS_OK;
18505:         }
18505:       }
18505:     }
18505:   }
18505: 
 6286:   nsCOMPtr<nsIAccessible> startAcc, endAcc;
 6286:   PRInt32 startOffset = aStartHTOffset, endOffset = aEndHTOffset;
 6286:   nsIFrame *startFrame = nsnull, *endFrame = nsnull;
 6286: 
 6286:   startFrame = GetPosAndText(startOffset, endOffset, nsnull, &endFrame, nsnull,
 6286:                              getter_AddRefs(startAcc), getter_AddRefs(endAcc));
 6286:   if (!startAcc || !endAcc)
 6286:     return NS_ERROR_FAILURE;
 6286: 
 6286:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 6286:   nsresult rv = GetDOMPointByFrameOffset(startFrame, startOffset, startAcc,
 6286:                                          getter_AddRefs(startNode),
 6286:                                          &startOffset);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:   if (aStartHTOffset != aEndHTOffset) {
 6286:     rv = GetDOMPointByFrameOffset(endFrame, endOffset, endAcc,
 6286:                                   getter_AddRefs(endNode), &endOffset);
 6286:     NS_ENSURE_SUCCESS(rv, rv);
 6286:   } else {
 6286:     endNode = startNode;
 6286:     endOffset = startOffset;
 6286:   }
 6286: 
 6286:   NS_ADDREF(*aStartNode = startNode);
 6286:   *aStartOffset = startOffset;
 6286: 
 6286:   NS_ADDREF(*aEndNode = endNode);
 6286:   *aEndOffset = endOffset;
 6286: 
 6286:   return NS_OK;
 6286: }
 6286: 
 5418: PRInt32
 5418: nsHyperTextAccessible::GetRelativeOffset(nsIPresShell *aPresShell,
 5418:                                          nsIFrame *aFromFrame,
 5418:                                          PRInt32 aFromOffset,
 5418:                                          nsIAccessible *aFromAccessible,
 5418:                                          nsSelectionAmount aAmount,
 5418:                                          nsDirection aDirection,
 5418:                                          PRBool aNeedsStart)
    1: {
    1:   const PRBool kIsJumpLinesOk = PR_TRUE;          // okay to jump lines
    1:   const PRBool kIsScrollViewAStop = PR_FALSE;     // do not stop at scroll views
    1:   const PRBool kIsKeyboardSelect = PR_TRUE;       // is keyboard selection
    1:   const PRBool kIsVisualBidi = PR_FALSE;          // use visual order for bidi text
    1: 
    1:   EWordMovementType wordMovementType = aNeedsStart ? eStartWord : eEndWord;
    1:   if (aAmount == eSelectLine) {
    1:     aAmount = (aDirection == eDirNext) ? eSelectEndLine : eSelectBeginLine;
    1:   }
    1: 
    1:   // Ask layout for the new node and offset, after moving the appropriate amount
    1:   nsPeekOffsetStruct pos;
 4261: 
 5418:   nsresult rv;
 5418:   PRInt32 contentOffset = aFromOffset;
20566:   if (nsAccUtils::IsText(aFromAccessible)) {
21169:     nsRefPtr<nsAccessNode> accessNode =
21169:       nsAccUtils::QueryAccessNode(aFromAccessible);
 5418: 
 5418:     nsIFrame *frame = accessNode->GetFrame();
 5418:     NS_ENSURE_TRUE(frame, -1);
21169: 
 5693:     if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
 5418:       rv = RenderedToContentOffset(frame, aFromOffset, &contentOffset);
 4261:       NS_ENSURE_SUCCESS(rv, -1);
 5418:     }
 5693:   }
 4261: 
 4261:   pos.SetData(aAmount, aDirection, contentOffset,
 4261:               0, kIsJumpLinesOk, kIsScrollViewAStop, kIsKeyboardSelect, kIsVisualBidi,
    1:               wordMovementType);
 4261:   rv = aFromFrame->PeekOffset(&pos);
    1:   if (NS_FAILED(rv)) {
    1:     if (aDirection == eDirPrevious) {
    1:       // Use passed-in frame as starting point in failure case for now,
    1:       // this is a hack to deal with starting on a list bullet frame,
    1:       // which fails in PeekOffset() because the line iterator doesn't see it.
    1:       // XXX Need to look at our overall handling of list bullets, which are an odd case
    1:       pos.mResultContent = aFromFrame->GetContent();
    1:       PRInt32 endOffsetUnused;
    1:       aFromFrame->GetOffsets(pos.mContentOffset, endOffsetUnused);
    1:     }
    1:     else {
 4261:       return -1;
    1:     }
    1:   }
    1: 
    1:   // Turn the resulting node and offset into a hyperTextOffset
    1:   PRInt32 hyperTextOffset;
    1:   nsCOMPtr<nsIDOMNode> resultNode = do_QueryInterface(pos.mResultContent);
    1:   NS_ENSURE_TRUE(resultNode, -1);
    1: 
    1:   nsCOMPtr<nsIAccessible> finalAccessible;
 6072:   rv = DOMPointToHypertextOffset(resultNode, pos.mContentOffset, &hyperTextOffset,
 6072:                                  getter_AddRefs(finalAccessible),
 6072:                                  aDirection == eDirNext);
 4261:   // If finalAccessible == nsnull, then DOMPointToHypertextOffset() searched through the hypertext
    1:   // children without finding the node/offset position
    1:   NS_ENSURE_SUCCESS(rv, -1);
    1: 
    1:   if (!finalAccessible && aDirection == eDirPrevious) {
    1:     // If we reached the end during search, this means we didn't find the DOM point
    1:     // and we're actually at the start of the paragraph
    1:     hyperTextOffset = 0;
    1:   }  
    1:   else if (aAmount == eSelectBeginLine) {
    1:     // For line selection with needsStart, set start of line exactly to line break
  764:     if (pos.mContentOffset == 0 && mFirstChild && 
20566:         nsAccUtils::Role(mFirstChild) == nsIAccessibleRole::ROLE_STATICTEXT &&
20566:         nsAccUtils::TextLength(mFirstChild) == hyperTextOffset) {
  764:       // XXX Bullet hack -- we should remove this once list bullets use anonymous content
  764:       hyperTextOffset = 0;
  764:     }
    1:     if (!aNeedsStart && hyperTextOffset > 0) {
    1:       -- hyperTextOffset;
    1:     }
    1:   }
    1:   else if (aAmount == eSelectEndLine && finalAccessible) { 
    1:     // If not at very end of hypertext, we may need change the end of line offset by 1, 
    1:     // to make sure we are in the right place relative to the line ending
20566:     if (nsAccUtils::Role(finalAccessible) == nsIAccessibleRole::ROLE_WHITESPACE) {  // Landed on <br> hard line break
    1:       // if aNeedsStart, set end of line exactly 1 character past line break
    1:       // XXX It would be cleaner if we did not have to have the hard line break check,
    1:       // and just got the correct results from PeekOffset() for the <br> case -- the returned offset should
    1:       // come after the new line, as it does in other cases.
    1:       ++ hyperTextOffset;  // Get past hard line break
    1:     }
    1:     // We are now 1 character past the line break
    1:     if (!aNeedsStart) {
    1:       -- hyperTextOffset;
    1:     }
    1:   }
    1: 
    1:   return hyperTextOffset;
    1: }
    1: 
    1: /*
    1: Gets the specified text relative to aBoundaryType, which means:
    1: BOUNDARY_CHAR             The character before/at/after the offset is returned.
    1: BOUNDARY_WORD_START       From the word start before/at/after the offset to the next word start.
    1: BOUNDARY_WORD_END         From the word end before/at/after the offset to the next work end.
    1: BOUNDARY_LINE_START       From the line start before/at/after the offset to the next line start.
    1: BOUNDARY_LINE_END         From the line end before/at/after the offset to the next line start.
    1: */
    1: 
    1: nsresult nsHyperTextAccessible::GetTextHelper(EGetTextType aType, nsAccessibleTextBoundary aBoundaryType,
    1:                                               PRInt32 aOffset, PRInt32 *aStartOffset, PRInt32 *aEndOffset,
    1:                                               nsAString &aText)
    1: {
    1:   aText.Truncate();
16173: 
16173:   NS_ENSURE_ARG_POINTER(aStartOffset);
16173:   NS_ENSURE_ARG_POINTER(aEndOffset);
    1:   *aStartOffset = *aEndOffset = 0;
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
    1:   if (!presShell) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
 8755:   if (aOffset == nsIAccessibleText::TEXT_OFFSET_END_OF_TEXT) {
 8755:     GetCharacterCount(&aOffset);
 8755:   }
 8755:   if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET) {
 8755:     GetCaretOffset(&aOffset);
 8755:     if (aOffset > 0 && (aBoundaryType == BOUNDARY_LINE_START ||
 8755:                         aBoundaryType == BOUNDARY_LINE_END)) {
 8755:       // It is the same character offset when the caret is visually at the very end of a line
 8755:       // or the start of a new line. Getting text at the line should provide the line with the visual caret,
 8755:       // otherwise screen readers will announce the wrong line as the user presses up or down arrow and land
 8755:       // at the end of a line.
 8755:       nsCOMPtr<nsISelection> domSel;
16001:       nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                                   nsnull, getter_AddRefs(domSel));
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
 8755:       nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryInterface(domSel));
 8755:       nsCOMPtr<nsFrameSelection> frameSelection;
 8755:       rv = privateSelection->GetFrameSelection(getter_AddRefs(frameSelection));
 8755:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
 8755:       if (frameSelection->GetHint() == nsFrameSelection::HINTLEFT) {
 8755:         -- aOffset;  // We are at the start of a line
 8755:       }
 8755:     }
 8755:   }
 8755:   else if (aOffset < 0) {
 8755:     return NS_ERROR_FAILURE;
 8755:   }
    1: 
16173:   nsSelectionAmount amount;
16173:   PRBool needsStart = PR_FALSE;
16173:   switch (aBoundaryType) {
16173:     case BOUNDARY_CHAR:
16173:       amount = eSelectCharacter;
16173:       if (aType == eGetAt)
16173:         aType = eGetAfter; // Avoid returning 2 characters
16173:       break;
16173: 
16173:     case BOUNDARY_WORD_START:
16173:       needsStart = PR_TRUE;
16173:       amount = eSelectWord;
16173:       break;
16173: 
16173:     case BOUNDARY_WORD_END:
16173:       amount = eSelectWord;
16173:       break;
16173: 
16173:     case BOUNDARY_LINE_START:
16173:       // Newlines are considered at the end of a line. Since getting
16173:       // the BOUNDARY_LINE_START gets the text from the line-start to the next
16173:       // line-start, the newline is included at the end of the string.
16173:       needsStart = PR_TRUE;
16173:       amount = eSelectLine;
16173:       break;
16173: 
16173:     case BOUNDARY_LINE_END:
16173:       // Newlines are considered at the end of a line. Since getting
16173:       // the BOUNDARY_END_START gets the text from the line-end to the next
16173:       //line-end, the newline is included at the beginning of the string.
16173:       amount = eSelectLine;
16173:       break;
16173: 
16173:     case BOUNDARY_ATTRIBUTE_RANGE:
16173:     {
16173:       nsresult rv = GetTextAttributes(PR_FALSE, aOffset,
16173:                                       aStartOffset, aEndOffset, nsnull);
16173:       NS_ENSURE_SUCCESS(rv, rv);
16173:       
16173:       return GetText(*aStartOffset, *aEndOffset, aText);
16173:     }
16173: 
16173:     default:  // Note, sentence support is deprecated and falls through to here
16173:       return NS_ERROR_INVALID_ARG;
16173:   }
16173: 
 8755:   PRInt32 startOffset = aOffset + (aBoundaryType == BOUNDARY_LINE_END);  // Avoid getting the previous line
 8755:   PRInt32 endOffset = startOffset;
 8755: 
    1:   // Convert offsets to frame-relative
 5418:   nsCOMPtr<nsIAccessible> startAcc;
 5418:   nsIFrame *startFrame = GetPosAndText(startOffset, endOffset, nsnull, nsnull,
 5418:                                        nsnull, getter_AddRefs(startAcc));
 5418: 
    1:   if (!startFrame) {
    1:     PRInt32 textLength;
    1:     GetCharacterCount(&textLength);
 6074:     if (aBoundaryType == BOUNDARY_LINE_START && aOffset > 0 && aOffset == textLength) {
 6074:       // Asking for start of line, while on last character
21169:       if (startAcc) {
21169:         nsRefPtr<nsAccessNode> startAccessNode =
21169:           nsAccUtils::QueryAccessNode(startAcc);
 6074:         startFrame = startAccessNode->GetFrame();
 6074:       }
 6074:     }
 6074:     if (!startFrame) {
 8755:       return aOffset > textLength ? NS_ERROR_FAILURE : NS_OK;
    1:     }
 8744:     else {
 8744:       // We're on the last continuation since we're on the last character
 8744:       startFrame = startFrame->GetLastContinuation();
 8744:     }
 6074:   }
    1: 
    1:   PRInt32 finalStartOffset, finalEndOffset;
    1: 
    1:   // If aType == eGetAt we'll change both the start and end offset from
    1:   // the original offset
    1:   if (aType == eGetAfter) {
    1:     finalStartOffset = aOffset;
    1:   }
    1:   else {
    1:     finalStartOffset = GetRelativeOffset(presShell, startFrame, startOffset,
 5418:                                          startAcc, amount, eDirPrevious,
 5418:                                          needsStart);
    1:     NS_ENSURE_TRUE(finalStartOffset >= 0, NS_ERROR_FAILURE);
    1:   }
    1: 
    1:   if (aType == eGetBefore) {
    1:     endOffset = aOffset;
    1:   }
    1:   else {
    1:     // Start moving forward from the start so that we don't get 
    1:     // 2 words/lines if the offset occured on whitespace boundary
    1:     // Careful, startOffset and endOffset are passed by reference to GetPosAndText() and changed
 8755:     // For BOUNDARY_LINE_END, make sure we start of this line
 8755:     startOffset = endOffset = finalStartOffset + (aBoundaryType == BOUNDARY_LINE_END);
 5418:     nsCOMPtr<nsIAccessible> endAcc;
 5418:     nsIFrame *endFrame = GetPosAndText(startOffset, endOffset, nsnull, nsnull,
 5418:                                        nsnull, getter_AddRefs(endAcc));
20566:     if (nsAccUtils::Role(endAcc) == nsIAccessibleRole::ROLE_STATICTEXT) {
10509:       // Static text like list bullets will ruin our forward calculation,
10509:       // since the caret cannot be in the static text. Start just after the static text.
20566:       startOffset = endOffset = finalStartOffset +
20566:                                 (aBoundaryType == BOUNDARY_LINE_END) +
20566:                                 nsAccUtils::TextLength(endAcc);
20566: 
10509:       endFrame = GetPosAndText(startOffset, endOffset, nsnull, nsnull,
10509:                                nsnull, getter_AddRefs(endAcc));
10509:     }
10870:     if (!endFrame) {
10870:       return NS_ERROR_FAILURE;
10870:     }
 5418:     finalEndOffset = GetRelativeOffset(presShell, endFrame, endOffset, endAcc,
 5418:                                        amount, eDirNext, needsStart);
    1:     NS_ENSURE_TRUE(endOffset >= 0, NS_ERROR_FAILURE);
    1:     if (finalEndOffset == aOffset) {
 6065:       if (aType == eGetAt && amount == eSelectWord) { 
 6065:         // Fix word error for the first character in word: PeekOffset() will return the previous word when 
 6065:         // aOffset points to the first character of the word, but accessibility APIs want the current word 
 6065:         // that the first character is in
 6065:         return GetTextHelper(eGetAfter, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
 6065:       }
 6074:       PRInt32 textLength;
 6074:       GetCharacterCount(&textLength);
 6074:       if (finalEndOffset < textLength) {
    1:         // This happens sometimes when current character at finalStartOffset 
    1:         // is an embedded object character representing another hypertext, that
    1:         // the AT really needs to dig into separately
    1:         ++ finalEndOffset;
    1:       }
    1:     }
 6074:   }
    1: 
    1:   *aStartOffset = finalStartOffset;
    1:   *aEndOffset = finalEndOffset;
    1: 
    1:   NS_ASSERTION((finalStartOffset < aOffset && finalEndOffset >= aOffset) || aType != eGetBefore, "Incorrect results for GetTextHelper");
    1:   NS_ASSERTION((finalStartOffset <= aOffset && finalEndOffset > aOffset) || aType == eGetBefore, "Incorrect results for GetTextHelper");
    1: 
 6074:   GetPosAndText(finalStartOffset, finalEndOffset, &aText);
 6074:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * nsIAccessibleText impl.
    1:   */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetTextBeforeOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
    1:                                                          PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
    1: {
    1:   return GetTextHelper(eGetBefore, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::GetTextAtOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
    1:                                                      PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
    1: {
    1:   return GetTextHelper(eGetAt, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::GetTextAfterOffset(PRInt32 aOffset, nsAccessibleTextBoundary aBoundaryType,
    1:                                                         PRInt32 *aStartOffset, PRInt32 *aEndOffset, nsAString & aText)
    1: {
    1:   return GetTextHelper(eGetAfter, aBoundaryType, aOffset, aStartOffset, aEndOffset, aText);
    1: }
    1: 
16001: // nsIPersistentProperties
16001: // nsIAccessibleText::getTextAttributes(in boolean includeDefAttrs,
16001: //                                      in long offset,
16001: //                                      out long rangeStartOffset,
16001: //                                      out long rangeEndOffset);
16001: NS_IMETHODIMP
16001: nsHyperTextAccessible::GetTextAttributes(PRBool aIncludeDefAttrs,
16001:                                          PRInt32 aOffset,
16001:                                          PRInt32 *aStartOffset,
16001:                                          PRInt32 *aEndOffset,
16001:                                          nsIPersistentProperties **aAttributes)
    1: {
16001:   // 1. First we get spell check, then language, then the set of CSS-based
16001:   //    attributes.
16001:   // 2. As we get each new attribute, we pass the current start and end offsets
16001:   //    as in/out parameters. In other words, as attributes are collected,
16001:   //    the attribute range itself can only stay the same or get smaller.
16001:   //
16001:   // Example:
16001:   //  Current: range 5-10
16001:   //  Adding:  range 7-12
16001:   //  Result:  range 7-10
    1: 
16001:   NS_ENSURE_ARG_POINTER(aStartOffset);
16001:   *aStartOffset = 0;
16001: 
16001:   NS_ENSURE_ARG_POINTER(aEndOffset);
16001:   nsresult rv = GetCharacterCount(aEndOffset);
16001:   NS_ENSURE_SUCCESS(rv, rv);
16001: 
16173:   if (aAttributes) {
16001:     *aAttributes = nsnull;
16001: 
16001:     nsCOMPtr<nsIPersistentProperties> attributes =
16001:       do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
16001:     NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
16001: 
16001:     NS_ADDREF(*aAttributes = attributes);
16173:   }
16001: 
16001:   if (!mDOMNode)
    1:     return NS_ERROR_FAILURE;
16001: 
16001:   nsCOMPtr<nsIDOMNode> node;
16001:   PRInt32 nodeOffset = 0;
16001:   rv = HypertextOffsetToDOMPoint(aOffset, getter_AddRefs(node), &nodeOffset);
16001:   NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:   // Set 'misspelled' text attribute.
16001:   rv = GetSpellTextAttribute(node, nodeOffset, aStartOffset, aEndOffset,
16173:                              aAttributes ? *aAttributes : nsnull);
16001:   NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
16001:   if (content && content->IsNodeOfType(nsINode::eELEMENT))
16001:     node = do_QueryInterface(content->GetChildAt(nodeOffset));
16001: 
16001:   if (!node)
16001:     return NS_OK;
16001: 
24999:   nsTextAttrsMgr textAttrsMgr(this, mDOMNode, aIncludeDefAttrs, node);
24999:   return textAttrsMgr.GetAttributes(*aAttributes, aStartOffset, aEndOffset);
    1: }
    1: 
16001: // nsIPersistentProperties
16001: // nsIAccessibleText::defaultTextAttributes
16001: NS_IMETHODIMP
16001: nsHyperTextAccessible::GetDefaultTextAttributes(nsIPersistentProperties **aAttributes)
16001: {
16001:   NS_ENSURE_ARG_POINTER(aAttributes);
16001:   *aAttributes = nsnull;
    1: 
16001:   nsCOMPtr<nsIPersistentProperties> attributes =
16001:     do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
16001:   NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
16001: 
16001:   NS_ADDREF(*aAttributes = attributes);
16001: 
16001:   if (!mDOMNode)
16001:     return NS_ERROR_FAILURE;
16001: 
24999:   nsTextAttrsMgr textAttrsMgr(this, mDOMNode, PR_TRUE, nsnull);
24999:   return textAttrsMgr.GetAttributes(*aAttributes);
    1: }
    1: 
  401: nsresult
  401: nsHyperTextAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
    1: {
    1:   if (!mDOMNode) {
    1:     return NS_ERROR_FAILURE;  // Node already shut down
    1:   }
    1: 
  401:   nsresult rv = nsAccessibleWrap::GetAttributesInternal(aAttributes);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
20566:   nsCOMPtr<nsIContent> content = nsCoreUtils::GetRoleContent(mDOMNode);
    1:   NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);
    1:   nsIAtom *tag = content->Tag();
    1: 
  401:   PRInt32 headLevel = 0;
  144:   if (tag == nsAccessibilityAtoms::h1)
  401:     headLevel = 1;
  144:   else if (tag == nsAccessibilityAtoms::h2)
  401:     headLevel = 2;
  144:   else if (tag == nsAccessibilityAtoms::h3)
  401:     headLevel = 3;
  144:   else if (tag == nsAccessibilityAtoms::h4)
  401:     headLevel = 4;
  144:   else if (tag == nsAccessibilityAtoms::h5)
  401:     headLevel = 5;
  144:   else if (tag == nsAccessibilityAtoms::h6)
  401:     headLevel = 6;
  144: 
  401:   if (headLevel) {
  401:     nsAutoString strHeadLevel;
  401:     strHeadLevel.AppendInt(headLevel);
20536:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::level,
  401:                            strHeadLevel);
    1:   }
    1:   
 6792:   // Indicate when the current object uses block-level formatting
 6792:   // via formatting: block
15645:   // XXX: 'formatting' attribute is deprecated and will be removed in Mozilla2,
15645:   // use 'display' attribute instead.
 6792:   nsIFrame *frame = GetFrame();
 6792:   if (frame && frame->GetType() == nsAccessibilityAtoms::blockFrame) {
 6792:     nsAutoString oldValueUnused;
 6792:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("formatting"), NS_LITERAL_STRING("block"),
 6792:                                    oldValueUnused);
 6792:   }
 6792: 
 8901:   if (gLastFocusedNode == mDOMNode) {
 8901:     PRInt32 lineNumber = GetCaretLineNumber();
 8901:     if (lineNumber >= 1) {
 8901:       nsAutoString strLineNumber;
 8901:       strLineNumber.AppendInt(lineNumber);
20536:       nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::lineNumber,
 8901:                              strLineNumber);
 8901:     }
 8901:   }
 8901: 
    1:   return  NS_OK;
    1: }
    1: 
    1: /*
    1:  * Given an offset, the x, y, width, and height values are filled appropriately.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetCharacterExtents(PRInt32 aOffset, PRInt32 *aX, PRInt32 *aY,
    1:                                                          PRInt32 *aWidth, PRInt32 *aHeight,
  728:                                                          PRUint32 aCoordType)
    1: {
    1:   return GetRangeExtents(aOffset, aOffset + 1, aX, aY, aWidth, aHeight, aCoordType);
    1: }
    1: 
    1: /*
    1:  * Given a start & end offset, the x, y, width, and height values are filled appropriately.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetRangeExtents(PRInt32 aStartOffset, PRInt32 aEndOffset,
    1:                                                      PRInt32 *aX, PRInt32 *aY,
    1:                                                      PRInt32 *aWidth, PRInt32 *aHeight,
  728:                                                      PRUint32 aCoordType)
    1: {
    1:   nsIntRect boundsRect;
    1:   nsIFrame *endFrameUnused;
 2395:   if (!GetPosAndText(aStartOffset, aEndOffset, nsnull, &endFrameUnused, &boundsRect) ||
 2395:       boundsRect.IsEmpty()) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   *aX = boundsRect.x;
    1:   *aY = boundsRect.y;
    1:   *aWidth = boundsRect.width;
    1:   *aHeight = boundsRect.height;
    1: 
20536:   return nsAccUtils::ConvertScreenCoordsTo(aX, aY, aCoordType, this);
    1: }
    1: 
    1: /*
    1:  * Gets the offset of the character located at coordinates x and y. x and y are interpreted as being relative to
    1:  * the screen or this widget's window depending on coords.
    1:  */
  728: NS_IMETHODIMP
  728: nsHyperTextAccessible::GetOffsetAtPoint(PRInt32 aX, PRInt32 aY,
  728:                                         PRUint32 aCoordType, PRInt32 *aOffset)
    1: {
    1:   *aOffset = -1;
    1:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
    1:   if (!shell) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   nsIFrame *hyperFrame = GetFrame();
    1:   if (!hyperFrame) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   nsIntRect frameScreenRect = hyperFrame->GetScreenRectExternal();
    1: 
 8525:   nsIntPoint coords;
20536:   nsresult rv = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordType,
 8525:                                                   this, &coords);
 8525:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 8525:   // coords are currently screen coordinates, and we need to turn them into
    1:   // frame coordinates relative to the current accessible
 8525:   if (!frameScreenRect.Contains(coords.x, coords.y)) {
    1:     return NS_OK;   // Not found, will return -1
    1:   }
23738:   nsIntPoint pxInHyperText(coords.x - frameScreenRect.x,
 8525:                            coords.y - frameScreenRect.y);
    1:   nsPresContext *context = GetPresContext();
    1:   NS_ENSURE_TRUE(context, NS_ERROR_FAILURE);
23738:   nsPoint pointInHyperText(context->DevPixelsToAppUnits(pxInHyperText.x),
23738:                            context->DevPixelsToAppUnits(pxInHyperText.y));
    1: 
    1:   // Go through the frames to check if each one has the point.
    1:   // When one does, add up the character offsets until we have a match
    1: 
    1:   // We have an point in an accessible child of this, now we need to add up the
    1:   // offsets before it to what we already have
    1:   nsCOMPtr<nsIAccessible> accessible;
    1:   PRInt32 offset = 0;
    1: 
    1:   while (NextChild(accessible)) {
21169:     nsRefPtr<nsAccessNode> accessNode = nsAccUtils::QueryAccessNode(accessible);
21169: 
 4852:     nsIFrame *primaryFrame = accessNode->GetFrame();
 4852:     NS_ENSURE_TRUE(primaryFrame, NS_ERROR_FAILURE);
 4852: 
 4852:     nsIFrame *frame = primaryFrame;
    1:     while (frame) {
    1:       nsIContent *content = frame->GetContent();
    1:       NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
    1:       nsPoint pointInFrame = pointInHyperText - frame->GetOffsetToExternal(hyperFrame);
    1:       nsSize frameSize = frame->GetSize();
    1:       if (pointInFrame.x < frameSize.width && pointInFrame.y < frameSize.height) {
    1:         // Finished
 5693:         if (frame->GetType() == nsAccessibilityAtoms::textFrame) {
    1:           nsIFrame::ContentOffsets contentOffsets = frame->GetContentOffsetsFromPointExternal(pointInFrame, PR_TRUE);
    1:           if (contentOffsets.IsNull() || contentOffsets.content != content) {
    1:             return NS_OK; // Not found, will return -1
    1:           }
 4261:           PRUint32 addToOffset;
 4852:           nsresult rv = ContentToRenderedOffset(primaryFrame,
 4852:                                                 contentOffsets.offset,
 4852:                                                 &addToOffset);
 4261:           NS_ENSURE_SUCCESS(rv, rv);
 4261:           offset += addToOffset;
    1:         }
    1:         *aOffset = offset;
    1:         return NS_OK;
    1:       }
    1:       frame = frame->GetNextContinuation();
    1:     }
20566:     PRInt32 textLength = nsAccUtils::TextLength(accessible);
 4261:     NS_ENSURE_TRUE(textLength >= 0, NS_ERROR_FAILURE);
 4261:     offset += textLength;
    1:   }
    1: 
    1:   return NS_OK; // Not found, will return -1
    1: }
    1: 
    1: // ------- nsIAccessibleHyperText ---------------
14209: NS_IMETHODIMP
14209: nsHyperTextAccessible::GetLinkCount(PRInt32 *aLinkCount)
    1: {
14209:   NS_ENSURE_ARG_POINTER(aLinkCount);
14209:   *aLinkCount = 0;
    1:   if (!mDOMNode) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAccessible> accessible;
    1: 
    1:   while (NextChild(accessible)) {
20566:     if (nsAccUtils::IsEmbeddedObject(accessible))
14209:       ++*aLinkCount;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
13730: NS_IMETHODIMP
14209: nsHyperTextAccessible::GetLink(PRInt32 aLinkIndex, nsIAccessibleHyperLink **aLink)
    1: {
13730:   NS_ENSURE_ARG_POINTER(aLink);
    1:   *aLink = nsnull;
13730: 
13730:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
13730: 
14209:   PRInt32 linkIndex = aLinkIndex;
13730:   nsCOMPtr<nsIAccessible> accessible;
13730:   while (NextChild(accessible)) {
20566:     if (nsAccUtils::IsEmbeddedObject(accessible) && linkIndex-- == 0)
13730:       return CallQueryInterface(accessible, aLink);
    1:   }
    1: 
13730:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
14209: NS_IMETHODIMP
14209: nsHyperTextAccessible::GetLinkIndex(PRInt32 aCharIndex, PRInt32 *aLinkIndex)
    1: {
14209:   NS_ENSURE_ARG_POINTER(aLinkIndex);
    1:   *aLinkIndex = -1; // API says this magic value means 'not found'
    1: 
    1:   PRInt32 characterCount = 0;
    1:   PRInt32 linkIndex = 0;
    1:   if (!mDOMNode) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAccessible> accessible;
    1: 
    1:   while (NextChild(accessible) && characterCount <= aCharIndex) {
20566:     PRUint32 role = nsAccUtils::Role(accessible);
    1:     if (role == nsIAccessibleRole::ROLE_TEXT_LEAF ||
    1:         role == nsIAccessibleRole::ROLE_STATICTEXT) {
20566:       PRInt32 textLength = nsAccUtils::TextLength(accessible);
 4261:       NS_ENSURE_TRUE(textLength >= 0, NS_ERROR_FAILURE);
 4261:       characterCount += textLength;
    1:     }
    1:     else {
    1:       if (characterCount ++ == aCharIndex) {
    1:         *aLinkIndex = linkIndex;
    1:         break;
    1:       }
    1:       if (role != nsIAccessibleRole::ROLE_WHITESPACE) {
    1:         ++ linkIndex;
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * nsIAccessibleEditableText impl.
    1:   */
    1: NS_IMETHODIMP nsHyperTextAccessible::SetAttributes(PRInt32 aStartPos, PRInt32 aEndPos,
    1:                                                    nsISupports *aAttributes)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::SetTextContents(const nsAString &aText)
    1: {
    1:   PRInt32 numChars;
    1:   GetCharacterCount(&numChars);
    1:   if (numChars == 0 || NS_SUCCEEDED(DeleteText(0, numChars))) {
    1:     return InsertText(aText, 0);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::InsertText(const nsAString &aText, PRInt32 aPosition)
    1: {
    1:   if (NS_SUCCEEDED(SetCaretOffset(aPosition))) {
 4625:     nsCOMPtr<nsIEditor> editor;
 4625:     GetAssociatedEditor(getter_AddRefs(editor));
    1:     nsCOMPtr<nsIPlaintextEditor> peditor(do_QueryInterface(editor));
    1:     return peditor ? peditor->InsertText(aText) : NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::CopyText(PRInt32 aStartPos, PRInt32 aEndPos)
    1: {
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1:   if (editor && NS_SUCCEEDED(SetSelectionRange(aStartPos, aEndPos)))
    1:     return editor->Copy();
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::CutText(PRInt32 aStartPos, PRInt32 aEndPos)
    1: {
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1:   if (editor && NS_SUCCEEDED(SetSelectionRange(aStartPos, aEndPos)))
    1:     return editor->Cut();
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::DeleteText(PRInt32 aStartPos, PRInt32 aEndPos)
    1: {
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1:   if (editor && NS_SUCCEEDED(SetSelectionRange(aStartPos, aEndPos)))
    1:     return editor->DeleteSelection(nsIEditor::eNone);
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::PasteText(PRInt32 aPosition)
    1: {
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
    1:   if (editor && NS_SUCCEEDED(SetCaretOffset(aPosition)))
    1:     return editor->Paste(nsIClipboard::kGlobalClipboard);
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
 3155: NS_IMETHODIMP
 3381: nsHyperTextAccessible::GetAssociatedEditor(nsIEditor **aEditor)
 3155: {
 3155:   NS_ENSURE_ARG_POINTER(aEditor);
 3155: 
 4625:   *aEditor = nsnull;
 4625:   nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
 4625:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
 3155: 
 4625:   if (!content->HasFlag(NODE_IS_EDITABLE)) {
 5750:     // If we're inside an editable container, then return that container's editor
 5750:     nsCOMPtr<nsIAccessible> ancestor, current = this;
 5750:     while (NS_SUCCEEDED(current->GetParent(getter_AddRefs(ancestor))) && ancestor) {
 5750:       nsRefPtr<nsHyperTextAccessible> ancestorTextAccessible;
 5750:       ancestor->QueryInterface(NS_GET_IID(nsHyperTextAccessible),
 5750:                                getter_AddRefs(ancestorTextAccessible));
 5750:       if (ancestorTextAccessible) {
 5750:         // Recursion will stop at container doc because it has its own impl
 5750:         // of GetAssociatedEditor()
 5750:         return ancestorTextAccessible->GetAssociatedEditor(aEditor);
 5750:       }
 5750:       current = ancestor;
 5750:     }
 3155:     return NS_OK;
 3155:   }
 3155: 
 5679:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
20521:     nsCoreUtils::GetDocShellTreeItemFor(mDOMNode);
 4625:   nsCOMPtr<nsIEditingSession> editingSession(do_GetInterface(docShellTreeItem));
 4625:   if (!editingSession)
 4625:     return NS_OK; // No editing session interface
 4625: 
 4625:   nsCOMPtr<nsIPresShell> shell = GetPresShell();
 4625:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
 4625: 
 4625:   nsCOMPtr<nsIDocument> doc = shell->GetDocument();
 4625:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
 4625: 
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   return editingSession->GetEditorForWindow(doc->GetWindow(), aEditor);
 4625: }
 4625: 
    1: /**
    1:   * =================== Caret & Selection ======================
    1:   */
    1: 
    1: nsresult nsHyperTextAccessible::SetSelectionRange(PRInt32 aStartPos, PRInt32 aEndPos)
    1: {
    1:   // Set the selection
    1:   nsresult rv = SetSelectionBounds(0, aStartPos, aEndPos);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // If range 0 was successfully set, clear any additional selection 
    1:   // ranges remaining from previous selection
    1:   nsCOMPtr<nsISelection> domSel;
    1:   nsCOMPtr<nsISelectionController> selCon;
16001:   GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                 getter_AddRefs(selCon), getter_AddRefs(domSel));
    1:   if (domSel) {
    1:     PRInt32 numRanges;
    1:     domSel->GetRangeCount(&numRanges);
    1: 
    1:     for (PRInt32 count = 0; count < numRanges - 1; count ++) {
    1:       nsCOMPtr<nsIDOMRange> range;
    1:       domSel->GetRangeAt(1, getter_AddRefs(range));
    1:       domSel->RemoveRange(range);
    1:     }
    1:   }
    1:   
    1:   if (selCon) {
12392:     // XXX I'm not sure this can do synchronous scrolling. If the last param is
12392:     // set to true, this calling might flush the pending reflow. See bug 418470.
    1:     selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
11780:       nsISelectionController::SELECTION_FOCUS_REGION, PR_FALSE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHyperTextAccessible::SetCaretOffset(PRInt32 aCaretOffset)
    1: {
    1:   return SetSelectionRange(aCaretOffset, aCaretOffset);
    1: }
    1: 
    1: /*
    1:  * Gets the offset position of the caret (cursor).
    1:  */
22834: NS_IMETHODIMP
22834: nsHyperTextAccessible::GetCaretOffset(PRInt32 *aCaretOffset)
    1: {
22834:   *aCaretOffset = -1;
    1: 
22834:   // No caret if the focused node is not inside this DOM node and this DOM node
22834:   // is not inside of focused node.
22834:   PRBool isInsideOfFocusedNode =
22834:     nsCoreUtils::IsAncestorOf(gLastFocusedNode, mDOMNode);
22834: 
22834:   if (!isInsideOfFocusedNode && mDOMNode != gLastFocusedNode &&
22834:       !nsCoreUtils::IsAncestorOf(mDOMNode, gLastFocusedNode))
22834:     return NS_OK;
22834: 
22834:   // Turn the focus node and offset of the selection into caret hypretext
22834:   // offset.
    1:   nsCOMPtr<nsISelection> domSel;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
22834:   nsCOMPtr<nsIDOMNode> focusNode;
22834:   rv = domSel->GetFocusNode(getter_AddRefs(focusNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
22834:   PRInt32 focusOffset;
22834:   rv = domSel->GetFocusOffset(&focusOffset);
22834:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
22834:   // No caret if this DOM node is inside of focused node but the selection's
22834:   // focus point is not inside of this DOM node.
22834:   if (isInsideOfFocusedNode) {
22834:     nsCOMPtr<nsIDOMNode> resultNode =
22834:       nsCoreUtils::GetDOMNodeFromDOMPoint(focusNode, focusOffset);
22834:     if (resultNode != mDOMNode &&
22834:         !nsCoreUtils::IsAncestorOf(mDOMNode, resultNode))
22834:       return NS_OK;
22834:   }
22834: 
22834:   return DOMPointToHypertextOffset(focusNode, focusOffset, aCaretOffset);
    1: }
    1: 
 8901: PRInt32 nsHyperTextAccessible::GetCaretLineNumber()
 8901: {
 8901:   // Provide the line number for the caret, relative to the
 8901:   // currently focused node. Use a 1-based index
 8901:   nsCOMPtr<nsISelection> domSel;
16001:   GetSelections(nsISelectionController::SELECTION_NORMAL, nsnull,
16001:                 getter_AddRefs(domSel));
 8901:   nsCOMPtr<nsISelectionPrivate> privateSelection(do_QueryInterface(domSel));
 8901:   NS_ENSURE_TRUE(privateSelection, -1);
 8901:   nsCOMPtr<nsFrameSelection> frameSelection;
 8901:   privateSelection->GetFrameSelection(getter_AddRefs(frameSelection));
 8901:   NS_ENSURE_TRUE(frameSelection, -1);
 8901: 
 8901:   nsCOMPtr<nsIDOMNode> caretNode;
 8901:   domSel->GetFocusNode(getter_AddRefs(caretNode));
 8901:   nsCOMPtr<nsIContent> caretContent = do_QueryInterface(caretNode);
20521:   if (!caretContent || !nsCoreUtils::IsAncestorOf(mDOMNode, caretNode)) {
 8901:     return -1;
 8901:   }
 8901: 
 8901:   PRInt32 caretOffset, returnOffsetUnused;
 8901:   domSel->GetFocusOffset(&caretOffset);
 8901:   nsFrameSelection::HINT hint = frameSelection->GetHint();
 8901:   nsIFrame *caretFrame = frameSelection->GetFrameForNodeOffset(caretContent, caretOffset,
 8901:                                                                hint, &returnOffsetUnused);
 8901:   NS_ENSURE_TRUE(caretFrame, -1);
 8901: 
 8901:   PRInt32 lineNumber = 1;
21112:   nsAutoLineIterator lineIterForCaret;
 8901:   nsCOMPtr<nsIContent> hyperTextContent = do_QueryInterface(mDOMNode);
 8901:   while (caretFrame) {
 8901:     if (hyperTextContent == caretFrame->GetContent()) {
 8901:       return lineNumber; // Must be in a single line hyper text, there is no line iterator
 8901:     }
 8901:     nsIFrame *parentFrame = caretFrame->GetParent();
 8901:     if (!parentFrame)
 8901:       break;
 8901: 
 8901:     // Add lines for the sibling frames before the caret
 8901:     nsIFrame *sibling = parentFrame->GetFirstChild(nsnull);
 8901:     while (sibling && sibling != caretFrame) {
21112:       nsAutoLineIterator lineIterForSibling = sibling->GetLineIterator();
 8901:       if (lineIterForSibling) {
 8901:         // For the frames before that grab all the lines
21112:         PRInt32 addLines = lineIterForSibling->GetNumLines();
 8901:         lineNumber += addLines;
 8901:       }
 8901:       sibling = sibling->GetNextSibling();
 8901:     }
 8901: 
 8901:     // Get the line number relative to the container with lines
 8901:     if (!lineIterForCaret) {   // Add the caret line just once
21112:       lineIterForCaret = parentFrame->GetLineIterator();
 8901:       if (lineIterForCaret) {
 8901:         // Ancestor of caret
21112:         PRInt32 addLines = lineIterForCaret->FindLineContaining(caretFrame);
 8901:         lineNumber += addLines;
 8901:       }
 8901:     }
 8901: 
 8901:     caretFrame = parentFrame;
 8901:   }
 8901: 
 8901:   NS_NOTREACHED("DOM ancestry had this hypertext but frame ancestry didn't");
 8901:   return lineNumber;
 8901: }
 8901: 
16001: nsresult
16001: nsHyperTextAccessible::GetSelections(PRInt16 aType,
16001:                                      nsISelectionController **aSelCon,
 6072:                                      nsISelection **aDomSel,
 6072:                                      nsCOMArray<nsIDOMRange>* aRanges)
    1: {
 6072:   if (!mDOMNode) {
 6072:     return NS_ERROR_FAILURE;
 6072:   }
    1:   if (aSelCon) {
    1:     *aSelCon = nsnull;
    1:   }
    1:   if (aDomSel) {
    1:     *aDomSel = nsnull;
    1:   }
 6072:   if (aRanges) {
 6072:     aRanges->Clear();
 6072:   }
 6072:   
 6072:   nsCOMPtr<nsISelection> domSel;
 6072:   nsCOMPtr<nsISelectionController> selCon;
    1: 
 4625:   nsCOMPtr<nsIEditor> editor;
 4625:   GetAssociatedEditor(getter_AddRefs(editor));
 6072:   nsCOMPtr<nsIPlaintextEditor> peditor(do_QueryInterface(editor));
 6072:   if (peditor) {
 6072:     // Case 1: plain text editor
 6072:     // This is for form controls which have their own
 6072:     // selection controller separate from the document, for example
 6072:     // HTML:input, HTML:textarea, XUL:textbox, etc.
 6072:     editor->GetSelectionController(getter_AddRefs(selCon));
    1:   }
 6072:   else {
 6072:     // Case 2: rich content subtree (can be rich editor)
 6072:     // This uses the selection controller from the entire document
    1:     nsIFrame *frame = GetFrame();
    1:     NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
    1: 
    1:     // Get the selection and selection controller
    1:     frame->GetSelectionController(GetPresContext(),
    1:                                   getter_AddRefs(selCon));
16001:   }
    1:   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
16001: 
16001:   selCon->GetSelection(aType, getter_AddRefs(domSel));
 6072:   NS_ENSURE_TRUE(domSel, NS_ERROR_FAILURE);
10870: 
    1:   if (aSelCon) {
    1:     NS_ADDREF(*aSelCon = selCon);
    1:   }
 6072:   if (aDomSel) {
 6072:     NS_ADDREF(*aDomSel = domSel);
 6072:   }
16001: 
 6072:   if (aRanges) {
 6072:     nsCOMPtr<nsISelection2> selection2(do_QueryInterface(domSel));
 6072:     NS_ENSURE_TRUE(selection2, NS_ERROR_FAILURE);
    1: 
16001:     nsCOMPtr<nsIDOMNode> startNode(mDOMNode);
16001:     if (peditor) {
16001:       nsCOMPtr<nsIDOMElement> editorRoot;
16001:       editor->GetRootElement(getter_AddRefs(editorRoot));
16001:       startNode = do_QueryInterface(editorRoot);
16001:     }
16001:     NS_ENSURE_STATE(startNode);
16001: 
 6072:     nsCOMPtr<nsIDOMNodeList> childNodes;
10870:     nsresult rv = startNode->GetChildNodes(getter_AddRefs(childNodes));
 6072:     NS_ENSURE_SUCCESS(rv, rv);
 6072:     PRUint32 numChildren; 
 6072:     rv = childNodes->GetLength(&numChildren);
 6072:     NS_ENSURE_SUCCESS(rv, rv);
10870:     rv = selection2->GetRangesForIntervalCOMArray(startNode, 0,
10870:                                                   startNode, numChildren,
 6072:                                                   PR_TRUE, aRanges);
 6072:     NS_ENSURE_SUCCESS(rv, rv);
 6072:     // Remove collapsed ranges
 6072:     PRInt32 numRanges = aRanges->Count();
 6072:     for (PRInt32 count = 0; count < numRanges; count ++) {
 6072:       PRBool isCollapsed;
 6072:       (*aRanges)[count]->GetCollapsed(&isCollapsed);
 6072:       if (isCollapsed) {
 6072:         aRanges->RemoveObjectAt(count);
 6072:         -- numRanges;
 6072:         -- count;
 6072:       }
 6072:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Gets the number of selected regions.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
    1: {
    1:   nsCOMPtr<nsISelection> domSel;
 6072:   nsCOMArray<nsIDOMRange> ranges;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, nsnull, &ranges);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6072:   *aSelectionCount = ranges.Count();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Gets the start and end offset of the specified selection.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::GetSelectionBounds(PRInt32 aSelectionNum, PRInt32 *aStartOffset, PRInt32 *aEndOffset)
    1: {
    1:   *aStartOffset = *aEndOffset = 0;
    1: 
    1:   nsCOMPtr<nsISelection> domSel;
 6072:   nsCOMArray<nsIDOMRange> ranges;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel), &ranges);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6072:   PRInt32 rangeCount = ranges.Count();
    1:   if (aSelectionNum < 0 || aSelectionNum >= rangeCount)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
 6072:   nsCOMPtr<nsIDOMRange> range = ranges[aSelectionNum];
    1: 
 6072:   // Get start point
    1:   nsCOMPtr<nsIDOMNode> startNode;
    1:   range->GetStartContainer(getter_AddRefs(startNode));
    1:   PRInt32 startOffset;
    1:   range->GetStartOffset(&startOffset);
    1: 
 6072:   // Get end point
    1:   nsCOMPtr<nsIDOMNode> endNode;
    1:   range->GetEndContainer(getter_AddRefs(endNode));
    1:   PRInt32 endOffset;
    1:   range->GetEndOffset(&endOffset);
 6072: 
 6072:   PRInt16 rangeCompareResult;
 6072:   rv = range->CompareBoundaryPoints(nsIDOMRange::START_TO_END, range, &rangeCompareResult);
 6072:   NS_ENSURE_SUCCESS(rv, rv);
 6072: 
 6072:   if (rangeCompareResult < 0) {
 6072:     // Make sure start is before end, by swapping offsets
 6072:     // This occurs when the user selects backwards in the text
 6072:     startNode.swap(endNode);
 6072:     PRInt32 tempOffset = startOffset;
 6072:     startOffset = endOffset;
 6072:     endOffset = tempOffset;
    1:   }
 6072: 
 6072:   nsCOMPtr<nsIAccessible> startAccessible;
 6072:   rv = DOMPointToHypertextOffset(startNode, startOffset, aStartOffset, getter_AddRefs(startAccessible));
 6072:   NS_ENSURE_SUCCESS(rv, rv);
 6072:   if (!startAccessible) {
 6072:     *aStartOffset = 0; // Could not find start point within this hypertext, so starts before
 6072:   }
 6072: 
 6072:   return DOMPointToHypertextOffset(endNode, endOffset, aEndOffset, nsnull, PR_TRUE);
    1: }
    1: 
    1: /*
    1:  * Changes the start and end offset of the specified selection.
    1:  */
 6286: NS_IMETHODIMP
 6286: nsHyperTextAccessible::SetSelectionBounds(PRInt32 aSelectionNum,
 6286:                                           PRInt32 aStartOffset,
 6286:                                           PRInt32 aEndOffset)
    1: {
    1:   nsCOMPtr<nsISelection> domSel;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6286:   // Caret is a collapsed selection
 6286:   PRBool isOnlyCaret = (aStartOffset == aEndOffset);
    1: 
    1:   PRInt32 rangeCount;
    1:   domSel->GetRangeCount(&rangeCount);
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   if (aSelectionNum == rangeCount) { // Add a range
    1:     range = do_CreateInstance(kRangeCID);
    1:     NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1:   else if (aSelectionNum < 0 || aSelectionNum > rangeCount) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1:   else {
    1:     domSel->GetRangeAt(aSelectionNum, getter_AddRefs(range));
    1:     NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
    1:   }
    1: 
 6286:   PRInt32 startOffset, endOffset;
 6286:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1: 
 6286:   rv = HypertextOffsetsToDOMRange(aStartOffset, aEndOffset,
 6286:                                   getter_AddRefs(startNode), &startOffset,
 6286:                                   getter_AddRefs(endNode), &endOffset);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 5706: 
 6286:   rv = range->SetStart(startNode, startOffset);
 6073:   NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:   rv = isOnlyCaret ? range->Collapse(PR_TRUE) :
 6286:                      range->SetEnd(endNode, endOffset);
 5706:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelectionNum == rangeCount) { // Add successfully created new range
    1:     return domSel->AddRange(range);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Adds a selection bounded by the specified offsets.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::AddSelection(PRInt32 aStartOffset, PRInt32 aEndOffset)
    1: {
    1:   nsCOMPtr<nsISelection> domSel;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 rangeCount;
    1:   domSel->GetRangeCount(&rangeCount);
    1: 
    1:   return SetSelectionBounds(rangeCount, aStartOffset, aEndOffset);
    1: }
    1: 
    1: /*
    1:  * Removes the specified selection.
    1:  */
    1: NS_IMETHODIMP nsHyperTextAccessible::RemoveSelection(PRInt32 aSelectionNum)
    1: {
    1:   nsCOMPtr<nsISelection> domSel;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_NORMAL,
16001:                               nsnull, getter_AddRefs(domSel));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 rangeCount;
    1:   domSel->GetRangeCount(&rangeCount);
    1:   if (aSelectionNum < 0 || aSelectionNum >= rangeCount)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   domSel->GetRangeAt(aSelectionNum, getter_AddRefs(range));
    1:   return domSel->RemoveRange(range);
    1: }
    1: 
 6286: // void nsIAccessibleText::
 6286: //   scrollSubstringTo(in long startIndex, in long endIndex,
 6286: //                     in unsigned long scrollType);
 5245: NS_IMETHODIMP
 5245: nsHyperTextAccessible::ScrollSubstringTo(PRInt32 aStartIndex, PRInt32 aEndIndex,
 5245:                                          PRUint32 aScrollType)
 5245: {
 6286:   PRInt32 startOffset, endOffset;
 6286:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 5245: 
 6286:   nsresult rv = HypertextOffsetsToDOMRange(aStartIndex, aEndIndex,
 6286:                                            getter_AddRefs(startNode),
 6286:                                            &startOffset,
 6286:                                            getter_AddRefs(endNode),
 5245:                                            &endOffset);
 5245:   NS_ENSURE_SUCCESS(rv, rv);
 5245: 
20521:   return nsCoreUtils::ScrollSubstringTo(GetFrame(), startNode, startOffset,
 5245:                                         endNode, endOffset, aScrollType);
 5245: }
 5245: 
 6286: // void nsIAccessibleText::
 6286: //   scrollSubstringToPoint(in long startIndex, in long endIndex,
 6286: //                          in unsigned long coordinateType,
 6286: //                          in long x, in long y);
 6286: NS_IMETHODIMP
 6286: nsHyperTextAccessible::ScrollSubstringToPoint(PRInt32 aStartIndex,
 6286:                                               PRInt32 aEndIndex,
 6286:                                               PRUint32 aCoordinateType,
 6286:                                               PRInt32 aX, PRInt32 aY)
 6286: {
 6286:   nsIFrame *frame = GetFrame();
 6286:   if (!frame)
 6286:     return NS_ERROR_FAILURE;
 6286: 
 6286:   nsIntPoint coords;
20536:   nsresult rv = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordinateType,
 6286:                                                   this, &coords);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:   PRInt32 startOffset, endOffset;
 6286:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 6286: 
 6286:   rv = HypertextOffsetsToDOMRange(aStartIndex, aEndIndex,
 6286:                                   getter_AddRefs(startNode), &startOffset,
 6286:                                   getter_AddRefs(endNode), &endOffset);
 6286:   NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:   nsPresContext *presContext = frame->PresContext();
 6286: 
 6286:   PRBool initialScrolled = PR_FALSE;
 6286:   nsIFrame *parentFrame = frame;
11383:   while ((parentFrame = parentFrame->GetParent())) {
23554:     nsIScrollableFrame *scrollableFrame = do_QueryFrame(parentFrame);
 6286:     if (scrollableFrame) {
 6286:       if (!initialScrolled) {
 6286:         // Scroll substring to the given point. Turn the point into percents
20521:         // relative scrollable area to use nsCoreUtils::ScrollSubstringTo.
 6286:         nsIntRect frameRect = parentFrame->GetScreenRectExternal();
 6286:         PRInt32 devOffsetX = coords.x - frameRect.x;
 6286:         PRInt32 devOffsetY = coords.y - frameRect.y;
 6286: 
 6286:         nsPoint offsetPoint(presContext->DevPixelsToAppUnits(devOffsetX),
 6286:                             presContext->DevPixelsToAppUnits(devOffsetY));
 6286: 
 6286:         nsSize size(parentFrame->GetSize());
34727: 
34727:         // avoid divide by zero
34727:         size.width = size.width ? size.width : 1;
34727:         size.height = size.height ? size.height : 1;
34727: 
 6286:         PRInt16 hPercent = offsetPoint.x * 100 / size.width;
 6286:         PRInt16 vPercent = offsetPoint.y * 100 / size.height;
 6286: 
20521:         rv = nsCoreUtils::ScrollSubstringTo(GetFrame(), startNode, startOffset,
 6286:                                             endNode, endOffset,
 6286:                                             vPercent, hPercent);
 6286:         NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:         initialScrolled = PR_TRUE;
 6286:       } else {
 6286:         // Substring was scrolled to the given point already inside its closest
 6286:         // scrollable area. If there are nested scrollable areas then make
 6286:         // sure we scroll lower areas to the given point inside currently
 6286:         // traversed scrollable area.
20521:         nsCoreUtils::ScrollFrameToPoint(parentFrame, frame, coords);
 6286:       }
 6286:     }
 6286:     frame = parentFrame;
 6286:   }
 6286: 
 6286:   return NS_OK;
 6286: }
 6286: 
 4261: nsresult nsHyperTextAccessible::ContentToRenderedOffset(nsIFrame *aFrame, PRInt32 aContentOffset,
 4261:                                                         PRUint32 *aRenderedOffset)
 4261: {
 8374:   if (!aFrame) {
 8374:     // Current frame not rendered -- this can happen if text is set on
 8374:     // something with display: none
 8374:     *aRenderedOffset = 0;
 8374:     return NS_OK;
 8374:   }
 5693:   NS_ASSERTION(aFrame->GetType() == nsAccessibilityAtoms::textFrame,
 5693:                "Need text frame for offset conversion");
 5693:   NS_ASSERTION(aFrame->GetPrevContinuation() == nsnull,
 5693:                "Call on primary frame only");
 5693: 
 4261:   gfxSkipChars skipChars;
 4261:   gfxSkipCharsIterator iter;
23536:   // Only get info up to original offset, we know that will be larger than skipped offset
 4261:   nsresult rv = aFrame->GetRenderedText(nsnull, &skipChars, &iter, 0, aContentOffset);
 4261:   NS_ENSURE_SUCCESS(rv, rv);
 4261: 
 4261:   PRUint32 ourRenderedStart = iter.GetSkippedOffset();
 4261:   PRInt32 ourContentStart = iter.GetOriginalOffset();
 4261: 
 4261:   *aRenderedOffset = iter.ConvertOriginalToSkipped(aContentOffset + ourContentStart) -
 4261:                     ourRenderedStart;
 4261: 
 4261:   return NS_OK;
 4261: }
 4261: 
 4261: nsresult nsHyperTextAccessible::RenderedToContentOffset(nsIFrame *aFrame, PRUint32 aRenderedOffset,
 4261:                                                         PRInt32 *aContentOffset)
 4261: {
 8374:   *aContentOffset = 0;
 8374:   NS_ENSURE_TRUE(aFrame, NS_ERROR_FAILURE);
 8374: 
 5693:   NS_ASSERTION(aFrame->GetType() == nsAccessibilityAtoms::textFrame,
 5693:                "Need text frame for offset conversion");
 5693:   NS_ASSERTION(aFrame->GetPrevContinuation() == nsnull,
 5693:                "Call on primary frame only");
 5693: 
 4261:   gfxSkipChars skipChars;
 4261:   gfxSkipCharsIterator iter;
 4261:   // We only need info up to skipped offset -- that is what we're converting to original offset
 4261:   nsresult rv = aFrame->GetRenderedText(nsnull, &skipChars, &iter, 0, aRenderedOffset);
 4261:   NS_ENSURE_SUCCESS(rv, rv);
 4261: 
 4261:   PRUint32 ourRenderedStart = iter.GetSkippedOffset();
 4261:   PRInt32 ourContentStart = iter.GetOriginalOffset();
 4261: 
 4261:   *aContentOffset = iter.ConvertSkippedToOriginal(aRenderedOffset + ourRenderedStart) - ourContentStart;
 4261: 
 4261:   return NS_OK;
 4261: }
 4261: 
 6286: nsresult
 6286: nsHyperTextAccessible::GetDOMPointByFrameOffset(nsIFrame *aFrame,
 6286:                                                 PRInt32 aOffset,
 6286:                                                 nsIAccessible *aAccessible,
 6286:                                                 nsIDOMNode **aNode,
 6286:                                                 PRInt32 *aNodeOffset)
 6286: {
 6286:   NS_ENSURE_ARG(aAccessible);
 4261: 
 6286:   nsCOMPtr<nsIDOMNode> node;
 6286: 
 6286:   if (!aFrame) {
 6286:     // If the given frame is null then set offset after the DOM node of the
 6286:     // given accessible.
 6286:     nsCOMPtr<nsIAccessNode> accessNode(do_QueryInterface(aAccessible));
 6286: 
 6286:     nsCOMPtr<nsIDOMNode> DOMNode;
 6286:     accessNode->GetDOMNode(getter_AddRefs(DOMNode));
 6286:     nsCOMPtr<nsIContent> content(do_QueryInterface(DOMNode));
 6286:     NS_ENSURE_STATE(content);
 6286: 
 6286:     nsCOMPtr<nsIContent> parent(content->GetParent());
 6286:     NS_ENSURE_STATE(parent);
 6286: 
 6286:     *aNodeOffset = parent->IndexOf(content) + 1;
 6286:     node = do_QueryInterface(parent);
 6286: 
 6286:   } else if (aFrame->GetType() == nsAccessibilityAtoms::textFrame) {
 6286:     nsCOMPtr<nsIContent> content(aFrame->GetContent());
 6286:     NS_ENSURE_STATE(content);
 6286: 
 6286:     nsCOMPtr<nsIPresShell> shell(GetPresShell());
 6286:     NS_ENSURE_STATE(shell);
 6286: 
 6286:     nsIFrame *primaryFrame = shell->GetPrimaryFrameFor(content);
 6286:     nsresult rv = RenderedToContentOffset(primaryFrame, aOffset, aNodeOffset);
 6286:     NS_ENSURE_SUCCESS(rv, rv);
 6286: 
 6286:     node = do_QueryInterface(content);
 6286: 
 6286:   } else {
 6286:     nsCOMPtr<nsIContent> content(aFrame->GetContent());
 6286:     NS_ENSURE_STATE(content);
 6286: 
 6286:     nsCOMPtr<nsIContent> parent(content->GetParent());
 6286:     NS_ENSURE_STATE(parent);
 6286: 
 6286:     *aNodeOffset = parent->IndexOf(content);
 6286:     node = do_QueryInterface(parent);
 6286:   }
 6286: 
 6286:   NS_IF_ADDREF(*aNode = node);
 6286:   return NS_OK;
 6286: }
 6286: 
16001: // nsHyperTextAccessible
16001: nsresult
16001: nsHyperTextAccessible::DOMRangeBoundToHypertextOffset(nsIDOMRange *aRange,
16001:                                                       PRBool aIsStartBound,
16001:                                                       PRBool aIsStartHTOffset,
16001:                                                       PRInt32 *aHTOffset)
16001: {
16001:   nsCOMPtr<nsIDOMNode> node;
16001:   PRInt32 nodeOffset = 0;
16001: 
16001:   nsresult rv;
16001:   if (aIsStartBound) {
16001:     rv = aRange->GetStartContainer(getter_AddRefs(node));
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:     rv = aRange->GetStartOffset(&nodeOffset);
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001:   } else {
16001:     rv = aRange->GetEndContainer(getter_AddRefs(node));
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:     rv = aRange->GetEndOffset(&nodeOffset);
16001:     NS_ENSURE_SUCCESS(rv, rv);
16001:   }
16001: 
16001:   nsCOMPtr<nsIAccessible> startAcc;
16001:   rv = DOMPointToHypertextOffset(node, nodeOffset, aHTOffset,
16001:                                  getter_AddRefs(startAcc));
16001:   NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:   if (aIsStartHTOffset && !startAcc)
16001:     *aHTOffset = 0;
16001: 
16001:   return NS_OK;
16001: }
16001: 
16001: // nsHyperTextAccessible
16001: nsresult
16001: nsHyperTextAccessible::GetSpellTextAttribute(nsIDOMNode *aNode,
16001:                                              PRInt32 aNodeOffset,
16001:                                              PRInt32 *aHTStartOffset,
16001:                                              PRInt32 *aHTEndOffset,
16001:                                              nsIPersistentProperties *aAttributes)
16001: {
16001:   nsCOMArray<nsIDOMRange> ranges;
16001:   nsresult rv = GetSelections(nsISelectionController::SELECTION_SPELLCHECK,
16001:                               nsnull, nsnull, &ranges);
16001:   NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:   PRInt32 rangeCount = ranges.Count();
16001:   if (!rangeCount)
16001:     return NS_OK;
16001: 
16001:   for (PRInt32 index = 0; index < rangeCount; index++) {
16001:     nsCOMPtr<nsIDOMRange> range = ranges[index];
16001:     nsCOMPtr<nsIDOMNSRange> nsrange(do_QueryInterface(range));
16001:     NS_ENSURE_STATE(nsrange);
16001: 
16001:     PRInt16 result;
16001:     rv = nsrange->ComparePoint(aNode, aNodeOffset, &result);
16001:     NS_ENSURE_SUCCESS(rv, rv);
20634:     // ComparePoint checks boundary points, but we need to check that
20634:     // text at aNodeOffset is inside the range.
20634:     // See also bug 460690.
20634:     if (result == 0) {
20634:       nsCOMPtr<nsIDOMNode> end;
20634:       rv = range->GetEndContainer(getter_AddRefs(end));
20634:       NS_ENSURE_SUCCESS(rv, rv);
20634:       PRInt32 endOffset;
20634:       rv = range->GetEndOffset(&endOffset);
20634:       NS_ENSURE_SUCCESS(rv, rv);
20634:       if (aNode == end && aNodeOffset == endOffset) {
20634:         result = 1;
20634:       }
20634:     }
16001: 
16001:     if (result == 1) { // range is before point
16001:       PRInt32 startHTOffset = 0;
16001:       rv = DOMRangeBoundToHypertextOffset(range, PR_FALSE, PR_TRUE,
16001:                                           &startHTOffset);
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:       if (startHTOffset > *aHTStartOffset)
16001:         *aHTStartOffset = startHTOffset;
16001: 
16001:     } else if (result == -1) { // range is after point
16001:       PRInt32 endHTOffset = 0;
16001:       rv = DOMRangeBoundToHypertextOffset(range, PR_TRUE, PR_FALSE,
16001:                                           &endHTOffset);
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:       if (endHTOffset < *aHTEndOffset)
16001:         *aHTEndOffset = endHTOffset;
16001: 
16001:     } else { // point is in range
16001:       PRInt32 startHTOffset = 0;
16001:       rv = DOMRangeBoundToHypertextOffset(range, PR_TRUE, PR_TRUE,
16001:                                           &startHTOffset);
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:       PRInt32 endHTOffset = 0;
16001:       rv = DOMRangeBoundToHypertextOffset(range, PR_FALSE, PR_FALSE,
16001:                                           &endHTOffset);
16001:       NS_ENSURE_SUCCESS(rv, rv);
16001: 
16001:       if (startHTOffset > *aHTStartOffset)
16001:         *aHTStartOffset = startHTOffset;
16001:       if (endHTOffset < *aHTEndOffset)
16001:         *aHTEndOffset = endHTOffset;
16001: 
16173:       if (aAttributes) {
20536:         nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::invalid,
16001:                                NS_LITERAL_STRING("spelling"));
16173:       }
16001: 
16001:       return NS_OK;
16001:     }
16001:   }
16001: 
16001:   return NS_OK;
16001: }
