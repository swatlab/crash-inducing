    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
 3113:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsLayoutUtils.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsIFormControlFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsIContent.h"
    1: #include "nsFrameList.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIAtom.h"
    1: #include "nsCSSPseudoElements.h"
12349: #include "nsCSSAnonBoxes.h"
    1: #include "nsIView.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsDisplayList.h"
    1: #include "nsRegion.h"
    1: #include "nsFrameManager.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsBidiPresUtils.h"
    1: #include "gfxIImageFrame.h"
    1: #include "imgIContainer.h"
    1: #include "gfxRect.h"
 1442: #include "gfxContext.h"
 4032: #include "gfxFont.h"
    1: #include "nsIImage.h"
    1: #include "nsIInterfaceRequestorUtils.h"
 1345: #include "nsCSSRendering.h"
 4032: #include "nsContentUtils.h"
16601: #include "nsThemeConstants.h"
16228: #include "nsPIDOMWindow.h"
16228: #include "nsIBaseWindow.h"
16228: #include "nsIDocShell.h"
16228: #include "nsIDocShellTreeItem.h"
16228: #include "nsIWidget.h"
19214: #include "gfxMatrix.h"
19214: #include "gfxTypes.h"
19962: #include "gfxUserFontSet.h"
24551: #include "nsTArray.h"
25840: #include "nsTextFragment.h"
    1: 
12349: #ifdef MOZ_SVG
12349: #include "nsSVGUtils.h"
19125: #include "nsSVGIntegrationUtils.h"
    1: #include "nsSVGForeignObjectFrame.h"
    1: #include "nsSVGOuterSVGFrame.h"
    1: #endif
    1: 
    1: /**
    1:  * A namespace class for static layout utilities.
    1:  */
    1: 
11016: PRBool nsLayoutUtils::sDisableGetUsedXAssertions = PR_FALSE;
10780: 
10780: nsIFrame*
10780: nsLayoutUtils::GetLastContinuationWithChild(nsIFrame* aFrame)
10780: {
10780:   NS_PRECONDITION(aFrame, "NULL frame pointer");
10780:   aFrame = aFrame->GetLastContinuation();
10780:   while (!aFrame->GetFirstChild(nsnull) &&
10780:          aFrame->GetPrevContinuation()) {
10780:     aFrame = aFrame->GetPrevContinuation();
10780:   }
10780:   return aFrame;
10780: }
10780: 
    1: /**
    1:  * GetFirstChildFrame returns the first "real" child frame of a
    1:  * given frame.  It will descend down into pseudo-frames (unless the
    1:  * pseudo-frame is the :before generated frame).   
    1:  * @param aFrame the frame
    1:  * @param aFrame the frame's content node
    1:  */
    1: static nsIFrame*
    1: GetFirstChildFrame(nsIFrame*       aFrame,
    1:                    nsIContent*     aContent)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
    1:   // Get the first child frame
    1:   nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1: 
    1:   // If the child frame is a pseudo-frame, then return its first child.
    1:   // Note that the frame we create for the generated content is also a
    1:   // pseudo-frame and so don't drill down in that case
    1:   if (childFrame &&
    1:       childFrame->IsPseudoFrame(aContent) &&
    1:       !childFrame->IsGeneratedContentFrame()) {
    1:     return GetFirstChildFrame(childFrame, aContent);
    1:   }
    1: 
    1:   return childFrame;
    1: }
    1: 
    1: /**
    1:  * GetLastChildFrame returns the last "real" child frame of a
    1:  * given frame.  It will descend down into pseudo-frames (unless the
    1:  * pseudo-frame is the :after generated frame).   
    1:  * @param aFrame the frame
    1:  * @param aFrame the frame's content node
    1:  */
    1: static nsIFrame*
    1: GetLastChildFrame(nsIFrame*       aFrame,
    1:                   nsIContent*     aContent)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
10780:   // Get the last continuation frame that's a parent
10780:   nsIFrame* lastParentContinuation = nsLayoutUtils::GetLastContinuationWithChild(aFrame);
    1: 
    1:   // Get the last child frame
10780:   nsIFrame* firstChildFrame = lastParentContinuation->GetFirstChild(nsnull);
    1:   if (firstChildFrame) {
    1:     nsFrameList frameList(firstChildFrame);
    1:     nsIFrame*   lastChildFrame = frameList.LastChild();
    1: 
    1:     NS_ASSERTION(lastChildFrame, "unexpected error");
    1: 
    1:     // Get the frame's first continuation. This matters in case the frame has
    1:     // been continued across multiple lines or split by BiDi resolution.
    1:     lastChildFrame = lastChildFrame->GetFirstContinuation();
    1:     
    1:     // If the last child frame is a pseudo-frame, then return its last child.
    1:     // Note that the frame we create for the generated content is also a
    1:     // pseudo-frame and so don't drill down in that case
    1:     if (lastChildFrame &&
    1:         lastChildFrame->IsPseudoFrame(aContent) &&
    1:         !lastChildFrame->IsGeneratedContentFrame()) {
    1:       return GetLastChildFrame(lastChildFrame, aContent);
    1:     }
    1: 
    1:     return lastChildFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: nsIFrame*
    1: nsLayoutUtils::GetBeforeFrame(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1:   NS_ASSERTION(!aFrame->GetPrevContinuation(),
    1:                "aFrame must be first continuation");
    1:   
    1:   nsIFrame* firstFrame = GetFirstChildFrame(aFrame, aFrame->GetContent());
    1: 
    1:   if (firstFrame && IsGeneratedContentFor(nsnull, firstFrame,
    1:                                           nsCSSPseudoElements::before)) {
    1:     return firstFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: nsIFrame*
    1: nsLayoutUtils::GetAfterFrame(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
    1:   nsIFrame* lastFrame = GetLastChildFrame(aFrame, aFrame->GetContent());
    1: 
    1:   if (lastFrame && IsGeneratedContentFor(nsnull, lastFrame,
    1:                                          nsCSSPseudoElements::after)) {
    1:     return lastFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: nsIFrame*
 3113: nsLayoutUtils::GetClosestFrameOfType(nsIFrame* aFrame, nsIAtom* aFrameType)
    1: {
    1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
 3113:     if (frame->GetType() == aFrameType) {
    1:       return frame;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: nsIFrame*
    1: nsLayoutUtils::GetFloatFromPlaceholder(nsIFrame* aFrame) {
    1:   if (nsGkAtoms::placeholderFrame != aFrame->GetType()) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIFrame *outOfFlowFrame =
    1:     nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
    1:   if (outOfFlowFrame->GetStyleDisplay()->IsFloating()) {
    1:     return outOfFlowFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsLayoutUtils::IsGeneratedContentFor(nsIContent* aContent,
    1:                                      nsIFrame* aFrame,
    1:                                      nsIAtom* aPseudoElement)
    1: {
    1:   NS_PRECONDITION(aFrame, "Must have a frame");
    1:   NS_PRECONDITION(aPseudoElement, "Must have a pseudo name");
    1: 
    1:   if (!aFrame->IsGeneratedContentFrame()) {
    1:     return PR_FALSE;
    1:   }
16976:   nsIFrame* parent = aFrame->GetParent();
16976:   NS_ASSERTION(parent, "Generated content can't be root frame");
16976:   if (parent->IsGeneratedContentFrame()) {
16976:     // Not the root of the generated content
    1:     return PR_FALSE;
    1:   }
    1:   
16976:   if (aContent && parent->GetContent() != aContent) {
16976:     return PR_FALSE;
16976:   }
16976: 
16976:   return (aFrame->GetContent()->Tag() == nsGkAtoms::mozgeneratedcontentbefore) ==
16976:     (aPseudoElement == nsCSSPseudoElements::before);
    1: }
    1: 
    1: // static
    1: nsIFrame*
18884: nsLayoutUtils::GetCrossDocParentFrame(const nsIFrame* aFrame,
18884:                                       nsPoint* aExtraOffset)
    1: {
    1:   nsIFrame* p = aFrame->GetParent();
    1:   if (p)
    1:     return p;
    1: 
    1:   nsIView* v = aFrame->GetView();
    1:   if (!v)
    1:     return nsnull;
    1:   v = v->GetParent(); // anonymous inner view
    1:   if (!v)
    1:     return nsnull;
18884:   if (aExtraOffset) {
18884:     *aExtraOffset += v->GetPosition();
18884:   }
    1:   v = v->GetParent(); // subdocumentframe's view
    1:   if (!v)
    1:     return nsnull;
 3233:   return static_cast<nsIFrame*>(v->GetClientData());
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsLayoutUtils::IsProperAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
    1:                                              nsIFrame* aCommonAncestor)
    1: {
    1:   if (aFrame == aCommonAncestor)
    1:     return PR_FALSE;
    1:   
    1:   nsIFrame* parentFrame = GetCrossDocParentFrame(aFrame);
    1: 
    1:   while (parentFrame != aCommonAncestor) {
    1:     if (parentFrame == aAncestorFrame)
    1:       return PR_TRUE;
    1: 
    1:     parentFrame = GetCrossDocParentFrame(parentFrame);
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsLayoutUtils::IsProperAncestorFrame(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
    1:                                      nsIFrame* aCommonAncestor)
    1: {
    1:   if (aFrame == aCommonAncestor) {
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   nsIFrame* parentFrame = aFrame->GetParent();
    1: 
    1:   while (parentFrame != aCommonAncestor) {
    1:     if (parentFrame == aAncestorFrame) {
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     parentFrame = parentFrame->GetParent();
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: PRInt32
    1: nsLayoutUtils::DoCompareTreePosition(nsIContent* aContent1,
    1:                                      nsIContent* aContent2,
    1:                                      PRInt32 aIf1Ancestor,
    1:                                      PRInt32 aIf2Ancestor,
    1:                                      nsIContent* aCommonAncestor)
    1: {
    1:   NS_PRECONDITION(aContent1, "aContent1 must not be null");
    1:   NS_PRECONDITION(aContent2, "aContent2 must not be null");
    1: 
 7820:   nsAutoTArray<nsINode*, 32> content1Ancestors;
    1:   nsINode* c1;
    1:   for (c1 = aContent1; c1 && c1 != aCommonAncestor; c1 = c1->GetNodeParent()) {
    1:     content1Ancestors.AppendElement(c1);
    1:   }
    1:   if (!c1 && aCommonAncestor) {
    1:     // So, it turns out aCommonAncestor was not an ancestor of c1. Oops.
    1:     // Never mind. We can continue as if aCommonAncestor was null.
    1:     aCommonAncestor = nsnull;
    1:   }
    1: 
 7820:   nsAutoTArray<nsINode*, 32> content2Ancestors;
    1:   nsINode* c2;
    1:   for (c2 = aContent2; c2 && c2 != aCommonAncestor; c2 = c2->GetNodeParent()) {
    1:     content2Ancestors.AppendElement(c2);
    1:   }
    1:   if (!c2 && aCommonAncestor) {
    1:     // So, it turns out aCommonAncestor was not an ancestor of c2.
    1:     // We need to retry with no common ancestor hint.
    1:     return DoCompareTreePosition(aContent1, aContent2,
    1:                                  aIf1Ancestor, aIf2Ancestor, nsnull);
    1:   }
    1:   
 7820:   int last1 = content1Ancestors.Length() - 1;
 7820:   int last2 = content2Ancestors.Length() - 1;
    1:   nsINode* content1Ancestor = nsnull;
    1:   nsINode* content2Ancestor = nsnull;
    1:   while (last1 >= 0 && last2 >= 0
 7820:          && ((content1Ancestor = content1Ancestors.ElementAt(last1)) ==
 7820:              (content2Ancestor = content2Ancestors.ElementAt(last2)))) {
    1:     last1--;
    1:     last2--;
    1:   }
    1: 
    1:   if (last1 < 0) {
    1:     if (last2 < 0) {
    1:       NS_ASSERTION(aContent1 == aContent2, "internal error?");
    1:       return 0;
    1:     }
    1:     // aContent1 is an ancestor of aContent2
    1:     return aIf1Ancestor;
    1:   }
    1: 
    1:   if (last2 < 0) {
    1:     // aContent2 is an ancestor of aContent1
    1:     return aIf2Ancestor;
    1:   }
    1: 
    1:   // content1Ancestor != content2Ancestor, so they must be siblings with the same parent
    1:   nsINode* parent = content1Ancestor->GetNodeParent();
    1:   NS_ASSERTION(parent, "no common ancestor at all???");
    1:   if (!parent) { // different documents??
    1:     return 0;
    1:   }
    1: 
    1:   PRInt32 index1 = parent->IndexOf(content1Ancestor);
    1:   PRInt32 index2 = parent->IndexOf(content2Ancestor);
    1:   if (index1 < 0 || index2 < 0) {
    1:     // one of them must be anonymous; we can't determine the order
    1:     return 0;
    1:   }
    1: 
    1:   return index1 - index2;
    1: }
    1: 
    1: static nsIFrame* FillAncestors(nsIFrame* aFrame,
    1:                                nsIFrame* aStopAtAncestor, nsFrameManager* aFrameManager,
    1:                                nsTArray<nsIFrame*>* aAncestors)
    1: {
    1:   while (aFrame && aFrame != aStopAtAncestor) {
    1:     aAncestors->AppendElement(aFrame);
    1:     aFrame = nsLayoutUtils::GetParentOrPlaceholderFor(aFrameManager, aFrame);
    1:   }
    1:   return aFrame;
    1: }
    1: 
    1: // Return true if aFrame1 is after aFrame2
    1: static PRBool IsFrameAfter(nsIFrame* aFrame1, nsIFrame* aFrame2)
    1: {
    1:   nsIFrame* f = aFrame2;
    1:   do {
    1:     f = f->GetNextSibling();
    1:     if (f == aFrame1)
    1:       return PR_TRUE;
    1:   } while (f);
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: PRInt32
    1: nsLayoutUtils::DoCompareTreePosition(nsIFrame* aFrame1,
    1:                                      nsIFrame* aFrame2,
    1:                                      PRInt32 aIf1Ancestor,
    1:                                      PRInt32 aIf2Ancestor,
    1:                                      nsIFrame* aCommonAncestor)
    1: {
    1:   NS_PRECONDITION(aFrame1, "aFrame1 must not be null");
    1:   NS_PRECONDITION(aFrame2, "aFrame2 must not be null");
    1: 
  238:   nsPresContext* presContext = aFrame1->PresContext();
  238:   if (presContext != aFrame2->PresContext()) {
    1:     NS_ERROR("no common ancestor at all, different documents");
    1:     return 0;
    1:   }
    1:   nsFrameManager* frameManager = presContext->PresShell()->FrameManager();
    1: 
    1:   nsAutoTArray<nsIFrame*,20> frame1Ancestors;
    1:   if (!FillAncestors(aFrame1, aCommonAncestor, frameManager, &frame1Ancestors)) {
    1:     // We reached the root of the frame tree ... if aCommonAncestor was set,
    1:     // it is wrong
    1:     aCommonAncestor = nsnull;
    1:   }
    1: 
    1:   nsAutoTArray<nsIFrame*,20> frame2Ancestors;
    1:   if (!FillAncestors(aFrame2, aCommonAncestor, frameManager, &frame2Ancestors) &&
    1:       aCommonAncestor) {
    1:     // We reached the root of the frame tree ... aCommonAncestor was wrong.
    1:     // Try again with no hint.
    1:     return DoCompareTreePosition(aFrame1, aFrame2,
    1:                                  aIf1Ancestor, aIf2Ancestor, nsnull);
    1:   }
    1: 
    1:   PRInt32 last1 = PRInt32(frame1Ancestors.Length()) - 1;
    1:   PRInt32 last2 = PRInt32(frame2Ancestors.Length()) - 1;
    1:   while (last1 >= 0 && last2 >= 0 &&
    1:          frame1Ancestors[last1] == frame2Ancestors[last2]) {
    1:     last1--;
    1:     last2--;
    1:   }
    1: 
    1:   if (last1 < 0) {
    1:     if (last2 < 0) {
    1:       NS_ASSERTION(aFrame1 == aFrame2, "internal error?");
    1:       return 0;
    1:     }
    1:     // aFrame1 is an ancestor of aFrame2
    1:     return aIf1Ancestor;
    1:   }
    1: 
    1:   if (last2 < 0) {
    1:     // aFrame2 is an ancestor of aFrame1
    1:     return aIf2Ancestor;
    1:   }
    1: 
    1:   nsIFrame* ancestor1 = frame1Ancestors[last1];
    1:   nsIFrame* ancestor2 = frame2Ancestors[last2];
    1:   // Now we should be able to walk sibling chains to find which one is first
    1:   if (IsFrameAfter(ancestor2, ancestor1))
    1:     return -1;
    1:   if (IsFrameAfter(ancestor1, ancestor2))
    1:     return 1;
    1:   NS_WARNING("Frames were in different child lists???");
    1:   return 0;
    1: }
    1: 
    1: // static
    1: nsIFrame* nsLayoutUtils::GetLastSibling(nsIFrame* aFrame) {
    1:   if (!aFrame) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIFrame* next;
    1:   while ((next = aFrame->GetNextSibling()) != nsnull) {
    1:     aFrame = next;
    1:   }
    1:   return aFrame;
    1: }
    1: 
    1: // static
    1: nsIView*
    1: nsLayoutUtils::FindSiblingViewFor(nsIView* aParentView, nsIFrame* aFrame) {
 3233:   nsIFrame* parentViewFrame = static_cast<nsIFrame*>(aParentView->GetClientData());
    1:   nsIContent* parentViewContent = parentViewFrame ? parentViewFrame->GetContent() : nsnull;
    1:   for (nsIView* insertBefore = aParentView->GetFirstChild(); insertBefore;
    1:        insertBefore = insertBefore->GetNextSibling()) {
 3233:     nsIFrame* f = static_cast<nsIFrame*>(insertBefore->GetClientData());
    1:     if (!f) {
    1:       // this view could be some anonymous view attached to a meaningful parent
    1:       for (nsIView* searchView = insertBefore->GetParent(); searchView;
    1:            searchView = searchView->GetParent()) {
 3233:         f = static_cast<nsIFrame*>(searchView->GetClientData());
    1:         if (f) {
    1:           break;
    1:         }
    1:       }
    1:       NS_ASSERTION(f, "Can't find a frame anywhere!");
    1:     }
    1:     if (!f || !aFrame->GetContent() || !f->GetContent() ||
    1:         CompareTreePosition(aFrame->GetContent(), f->GetContent(), parentViewContent) > 0) {
    1:       // aFrame's content is after f's content (or we just don't know),
    1:       // so put our view before f's view
    1:       return insertBefore;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: //static
    1: nsIScrollableFrame*
    1: nsLayoutUtils::GetScrollableFrameFor(nsIFrame *aScrolledFrame)
    1: {
    1:   nsIFrame *frame = aScrolledFrame->GetParent();
    1:   if (!frame) {
    1:     return nsnull;
    1:   }
23554:   nsIScrollableFrame *sf = do_QueryFrame(frame);
    1:   return sf;
    1: }
    1: 
    1: //static
    1: nsIScrollableFrame*
    1: nsLayoutUtils::GetScrollableFrameFor(nsIScrollableView *aScrollableView)
    1: {
    1:   nsIFrame *frame = GetFrameFor(aScrollableView->View()->GetParent());
23554:   nsIScrollableFrame *sf = do_QueryFrame(frame);
    1:   return sf;
    1: }
    1: 
    1: //static
    1: nsPresContext::ScrollbarStyles
    1: nsLayoutUtils::ScrollbarStylesOfView(nsIScrollableView *aScrollableView)
    1: {
    1:   nsIScrollableFrame *sf = GetScrollableFrameFor(aScrollableView);
    1:   return sf ? sf->GetScrollbarStyles() :
    1:               nsPresContext::ScrollbarStyles(NS_STYLE_OVERFLOW_HIDDEN,
    1:                                              NS_STYLE_OVERFLOW_HIDDEN);
    1: }
    1: 
    1: // static
    1: nsIScrollableView*
    1: nsLayoutUtils::GetNearestScrollingView(nsIView* aView, Direction aDirection)
    1: {
    1:   // If aDirection is eEither, find first view with a scrolllable frame.
    1:   // Otherwise, find the first view that has a scrollable frame whose
    1:   // ScrollbarStyles is not NS_STYLE_OVERFLOW_HIDDEN in aDirection
    1:   // and where there is something currently not visible
    1:   // that can be scrolled to in aDirection.
    1:   NS_ASSERTION(aView, "GetNearestScrollingView expects a non-null view");
    1:   nsIScrollableView* scrollableView = nsnull;
    1:   for (; aView; aView = aView->GetParent()) {
    1:     scrollableView = aView->ToScrollableView();
    1:     if (scrollableView) {
    1:       nsPresContext::ScrollbarStyles ss =
    1:         nsLayoutUtils::ScrollbarStylesOfView(scrollableView);
    1:       nsIScrollableFrame *scrollableFrame = GetScrollableFrameFor(scrollableView);
    1:       NS_ASSERTION(scrollableFrame, "Must have scrollable frame for view!");
    1:       nsMargin margin = scrollableFrame->GetActualScrollbarSizes();
    1:       // Get size of total scrollable area
    1:       nscoord totalWidth, totalHeight;
    1:       scrollableView->GetContainerSize(&totalWidth, &totalHeight);
    1:       // Get size of currently visible area
    1:       nsSize visibleSize = aView->GetBounds().Size();
    1:       // aDirection can be eHorizontal, eVertical, or eEither
    1:       // If scrolling in a specific direction, require visible scrollbars or
    1:       // something to scroll to in that direction.
    1:       if (aDirection != eHorizontal &&
    1:           ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN &&
    1:           (aDirection == eEither || totalHeight > visibleSize.height || margin.LeftRight()))
    1:         break;
    1:       if (aDirection != eVertical &&
    1:           ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN &&
    1:           (aDirection == eEither || totalWidth > visibleSize.width || margin.TopBottom()))
    1:         break;
    1:     }
    1:   }
    1:   return scrollableView;
    1: }
    1: 
    1: nsPoint
    1: nsLayoutUtils::GetDOMEventCoordinatesRelativeTo(nsIDOMEvent* aDOMEvent, nsIFrame* aFrame)
    1: {
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aDOMEvent));
    1:   NS_ASSERTION(privateEvent, "bad implementation");
    1:   if (!privateEvent)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
20234:   nsEvent *event = privateEvent->GetInternalNSEvent();
20234:   if (!event)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1:   return GetEventCoordinatesRelativeTo(event, aFrame);
    1: }
    1: 
    1: nsPoint
 2817: nsLayoutUtils::GetEventCoordinatesRelativeTo(const nsEvent* aEvent, nsIFrame* aFrame)
    1: {
    1:   if (!aEvent || (aEvent->eventStructType != NS_MOUSE_EVENT && 
18445:                   aEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
23284:                   aEvent->eventStructType != NS_DRAG_EVENT &&
23284:                   aEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT))
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
 3233:   const nsGUIEvent* GUIEvent = static_cast<const nsGUIEvent*>(aEvent);
    1:   if (!GUIEvent->widget)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
19214:   /* If we walk up the frame tree and discover that any of the frames are
19214:    * transformed, we need to do extra work to convert from the global
19214:    * space to the local space.
19214:    */
    1:   nsIFrame* rootFrame = aFrame;
19214:   PRBool transformFound = PR_FALSE;
19214: 
    1:   for (nsIFrame* f = aFrame; f; f = GetCrossDocParentFrame(f)) {
19214:     if (f->IsTransformed())
19214:       transformFound = PR_TRUE;
19214: 
    1:     rootFrame = f;
    1:   }
    1: 
    1:   nsIView* rootView = rootFrame->GetView();
    1:   if (!rootView)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
  238:   nsPoint widgetToView = TranslateWidgetToView(rootFrame->PresContext(),
    1:                                GUIEvent->widget, GUIEvent->refPoint,
    1:                                rootView);
    1: 
    1:   if (widgetToView == nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE))
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
19214:   /* If we encountered a transform, we can't do simple arithmetic to figure
19214:    * out how to convert back to aFrame's coordinates and must use the CTM.
19214:    */
19214:   if (transformFound)
19214:     return InvertTransformsToRoot(aFrame, widgetToView);
19214:   
19214:   /* Otherwise, all coordinate systems are translations of one another,
19214:    * so we can just subtract out the different.
19214:    */
    1:   return widgetToView - aFrame->GetOffsetTo(rootFrame);
    1: }
    1: 
19214: gfxMatrix
19214: nsLayoutUtils::ChangeMatrixBasis(const gfxPoint &aOrigin,
19214:                                  const gfxMatrix &aMatrix)
19214: {
19214:   /* These are translation matrices from world-to-origin of relative frame and
19214:    * vice-versa.  Although I could use the gfxMatrix::Translate function to
19214:    * accomplish this, I'm hoping to reduce the overall number of matrix
19214:    * operations by hardcoding as many of the matrices as possible.
19214:    */
19214:   gfxMatrix worldToOrigin(1.0, 0.0, 0.0, 1.0, -aOrigin.x, -aOrigin.y);
19214:   gfxMatrix originToWorld(1.0, 0.0, 0.0, 1.0,  aOrigin.x,  aOrigin.y);
19214: 
19214:   /* Multiply all three to get the transform! */
19214:   gfxMatrix result(worldToOrigin);
19214:   result.Multiply(aMatrix);
19214:   result.Multiply(originToWorld);
19214:   return result;
19214: }
19214: 
19214: /**
19214:  * Given a gfxFloat, constrains its value to be between nscoord_MIN and nscoord_MAX.
19214:  *
19214:  * @param aVal The value to constrain (in/out)
19214:  */
19214: static void ConstrainToCoordValues(gfxFloat &aVal)
19214: {
19214:   if (aVal <= nscoord_MIN)
19214:     aVal = nscoord_MIN;
19214:   else if (aVal >= nscoord_MAX)
19214:     aVal = nscoord_MAX;
19214: }
19214: 
19214: nsRect
19214: nsLayoutUtils::RoundGfxRectToAppRect(const gfxRect &aRect, float aFactor)
19214: { 
19214:   /* Get a new gfxRect whose units are app units by scaling by the specified factor. */ 
19214:   gfxRect scaledRect(aRect.pos.x * aFactor, aRect.pos.y * aFactor,
19214:                      aRect.size.width * aFactor,
19214:                      aRect.size.height * aFactor);
19214:   
19214:   /* Round outward. */
19214:   scaledRect.RoundOut();
19214: 
19214:   /* We now need to constrain our results to the max and min values for coords. */
19214:   ConstrainToCoordValues(scaledRect.pos.x);
19214:   ConstrainToCoordValues(scaledRect.pos.y);
19214:   ConstrainToCoordValues(scaledRect.size.width);
19214:   ConstrainToCoordValues(scaledRect.size.height);
19214:   
19214:   /* Now typecast everything back.  This is guaranteed to be safe. */
19214:   return nsRect(nscoord(scaledRect.pos.x), nscoord(scaledRect.pos.y),
19214:                 nscoord(scaledRect.size.width), nscoord(scaledRect.size.height));
19214: }
19214: 
19214: nsRect
19214: nsLayoutUtils::MatrixTransformRect(const nsRect &aBounds,
19214:                                    const gfxMatrix &aMatrix, float aFactor)
19214: {
19214:   gfxRect image = aMatrix.TransformBounds(gfxRect(NSAppUnitsToFloatPixels(aBounds.x, aFactor),
19214:                                                   NSAppUnitsToFloatPixels(aBounds.y, aFactor),
19214:                                                   NSAppUnitsToFloatPixels(aBounds.width, aFactor),
19214:                                                   NSAppUnitsToFloatPixels(aBounds.height, aFactor)));
19214:   
19214:   return RoundGfxRectToAppRect(image, aFactor);
19214: }
19214: 
19214: nsPoint
19214: nsLayoutUtils::MatrixTransformPoint(const nsPoint &aPoint,
19214:                                     const gfxMatrix &aMatrix, float aFactor)
19214: {
19214:   gfxPoint image = aMatrix.Transform(gfxPoint(NSAppUnitsToFloatPixels(aPoint.x, aFactor),
19214:                                               NSAppUnitsToFloatPixels(aPoint.y, aFactor)));
19214:   return nsPoint(NSFloatPixelsToAppUnits(float(image.x), aFactor),
19214:                  NSFloatPixelsToAppUnits(float(image.y), aFactor));
19214: }
19214: 
19214: /**
19214:  * Returns the CTM at the specified frame.
19214:  *
19214:  * @param aFrame The frame at which we should calculate the CTM.
19214:  * @return The CTM at the specified frame.
19214:  */
19214: static gfxMatrix GetCTMAt(nsIFrame *aFrame)
19214: {
19214:   gfxMatrix ctm;
19214: 
19214:   /* Starting at the specified frame, we'll use the GetTransformMatrix
19214:    * function of the frame, which gives us a matrix from this frame up
19214:    * to some other ancestor frame.  Once this function returns null,
19214:    * we've hit the top of the frame tree and can stop.  We get the CTM
19214:    * by simply accumulating all of these matrices together.
19214:    */
19214:   while (aFrame)
19214:     ctm *= aFrame->GetTransformMatrix(&aFrame);
19214:   return ctm;
19214: }
19214: 
19214: nsPoint
19214: nsLayoutUtils::InvertTransformsToRoot(nsIFrame *aFrame,
19214:                                       const nsPoint &aPoint)
19214: {
19214:   NS_PRECONDITION(aFrame, "Why are you inverting transforms when there is no frame?");
19214: 
19214:   /* To invert everything to the root, we'll get the CTM, invert it, and use it to transform
19214:    * the point.
19214:    */
19214:   gfxMatrix ctm = GetCTMAt(aFrame);
19214: 
19214:   /* If the ctm is singular, hand back (0, 0) as a sentinel. */
19214:   if (ctm.IsSingular())
19214:     return nsPoint(0, 0);
19214: 
19214:   /* Otherwise, invert the CTM and use it to transform the point. */
19214:   return MatrixTransformPoint(aPoint, ctm.Invert(), aFrame->PresContext()->AppUnitsPerDevPixel());
19214: }
19214: 
    1: nsPoint
    1: nsLayoutUtils::GetEventCoordinatesForNearestView(nsEvent* aEvent,
    1:                                                  nsIFrame* aFrame,
    1:                                                  nsIView** aView)
    1: {
    1:   if (!aEvent || (aEvent->eventStructType != NS_MOUSE_EVENT && 
18445:                   aEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
18445:                   aEvent->eventStructType != NS_DRAG_EVENT))
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
 3233:   nsGUIEvent* GUIEvent = static_cast<nsGUIEvent*>(aEvent);
    1:   if (!GUIEvent->widget)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
    1:   nsPoint viewToFrame;
    1:   nsIView* frameView;
    1:   aFrame->GetOffsetFromView(viewToFrame, &frameView);
    1:   if (aView)
    1:     *aView = frameView;
    1: 
  238:   return TranslateWidgetToView(aFrame->PresContext(), GUIEvent->widget,
    1:                                GUIEvent->refPoint, frameView);
    1: }
    1: 
23738: static nsIntPoint GetWidgetOffset(nsIWidget* aWidget, nsIWidget*& aRootWidget) {
23738:   nsIntPoint offset(0, 0);
 3778:   nsIWidget* parent = aWidget->GetParent();
 3778:   while (parent) {
23738:     nsIntRect bounds;
 3778:     aWidget->GetBounds(bounds);
 3778:     offset += bounds.TopLeft();
 3778:     aWidget = parent;
 3778:     parent = aWidget->GetParent();
 3778:   }
 3778:   aRootWidget = aWidget;
 3778:   return offset;
 3778: }
 3778: 
    1: nsPoint
    1: nsLayoutUtils::TranslateWidgetToView(nsPresContext* aPresContext, 
    1:                                      nsIWidget* aWidget, nsIntPoint aPt,
    1:                                      nsIView* aView)
    1: {
 3778:   nsPoint viewOffset;
 3778:   nsIWidget* viewWidget = aView->GetNearestWidget(&viewOffset);
 3778: 
 3778:   nsIWidget* fromRoot;
23738:   nsIntPoint fromOffset = GetWidgetOffset(aWidget, fromRoot);
 3778:   nsIWidget* toRoot;
23738:   nsIntPoint toOffset = GetWidgetOffset(viewWidget, toRoot);
 3778: 
 3778:   nsIntPoint widgetPoint;
 3778:   if (fromRoot == toRoot) {
 3778:     widgetPoint = aPt + fromOffset - toOffset;
 3778:   } else {
25183:     nsIntPoint screenPoint = aWidget->WidgetToScreenOffset();
25183:     widgetPoint = aPt + screenPoint - viewWidget->WidgetToScreenOffset();
 3778:   }
 3778: 
 3778:   nsPoint widgetAppUnits(aPresContext->DevPixelsToAppUnits(widgetPoint.x),
 3778:                          aPresContext->DevPixelsToAppUnits(widgetPoint.y));
 3778:   return widgetAppUnits - viewOffset;
    1: }
    1: 
    1: // Combine aNewBreakType with aOrigBreakType, but limit the break types
    1: // to NS_STYLE_CLEAR_LEFT, RIGHT, LEFT_AND_RIGHT.
    1: PRUint8
    1: nsLayoutUtils::CombineBreakType(PRUint8 aOrigBreakType,
    1:                                 PRUint8 aNewBreakType)
    1: {
    1:   PRUint8 breakType = aOrigBreakType;
    1:   switch(breakType) {
    1:   case NS_STYLE_CLEAR_LEFT:
    1:     if ((NS_STYLE_CLEAR_RIGHT          == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = NS_STYLE_CLEAR_LEFT_AND_RIGHT;
    1:     }
    1:     break;
    1:   case NS_STYLE_CLEAR_RIGHT:
    1:     if ((NS_STYLE_CLEAR_LEFT           == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = NS_STYLE_CLEAR_LEFT_AND_RIGHT;
    1:     }
    1:     break;
    1:   case NS_STYLE_CLEAR_NONE:
    1:     if ((NS_STYLE_CLEAR_LEFT           == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_RIGHT          == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = aNewBreakType;
    1:     }
    1:   }
    1:   return breakType;
    1: }
    1: 
    1: PRBool
24659: nsLayoutUtils::IsRootElementFrame(nsIFrame* aFrame)
    1: {
    1:   return aFrame ==
24659:     aFrame->PresContext()->PresShell()->FrameConstructor()->GetRootElementFrame();
    1: }
    1: 
    1: #ifdef DEBUG
    1: #include <stdio.h>
    1: 
    1: static PRBool gDumpPaintList = PR_FALSE;
    1: static PRBool gDumpEventList = PR_FALSE;
    1: static PRBool gDumpRepaintRegionForCopy = PR_FALSE;
    1: #endif
    1: 
    1: nsIFrame*
 5440: nsLayoutUtils::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt,
20863:                                 PRBool aShouldIgnoreSuppression,
22095:                                 PRBool aIgnoreRootScrollFrame)
    1: {
    1:   nsDisplayListBuilder builder(aFrame, PR_TRUE, PR_FALSE);
    1:   nsDisplayList list;
    1:   nsRect target(aPt, nsSize(1, 1));
    1: 
 5440:   if (aShouldIgnoreSuppression)
 5440:     builder.IgnorePaintSuppression();
20863: 
22095:   if (aIgnoreRootScrollFrame) {
20863:     nsIFrame* rootScrollFrame =
20863:       aFrame->PresContext()->PresShell()->GetRootScrollFrame();
20863:     if (rootScrollFrame) {
20863:       builder.SetIgnoreScrollFrame(rootScrollFrame);
20863:     }
20863:   }
20863: 
    1:   builder.EnterPresShell(aFrame, target);
    1: 
    1:   nsresult rv =
    1:     aFrame->BuildDisplayListForStackingContext(&builder, target, &list);
    1: 
    1:   builder.LeavePresShell(aFrame, target);
    1:   NS_ENSURE_SUCCESS(rv, nsnull);
    1: 
    1: #ifdef DEBUG
    1:   if (gDumpEventList) {
    1:     fprintf(stderr, "Event handling --- (%d,%d):\n", aPt.x, aPt.y);
    1:     nsIFrameDebug::PrintDisplayList(&builder, list);
    1:   }
    1: #endif
    1:   
 9799:   nsDisplayItem::HitTestState hitTestState;
 9799:   nsIFrame* result = list.HitTest(&builder, aPt, &hitTestState);
    1:   list.DeleteAll();
    1:   return result;
    1: }
    1: 
    1: /**
    1:  * A simple display item that just renders a solid color across the entire
    1:  * visible area.
    1:  */
    1: class nsDisplaySolidColor : public nsDisplayItem {
    1: public:
    1:   nsDisplaySolidColor(nsIFrame* aFrame, nscolor aColor)
    1:     : nsDisplayItem(aFrame), mColor(aColor) {
    1:     MOZ_COUNT_CTOR(nsDisplaySolidColor);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplaySolidColor() {
    1:     MOZ_COUNT_DTOR(nsDisplaySolidColor);
    1:   }
    1: #endif
    1: 
    1:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect);
    1:   NS_DISPLAY_DECL_NAME("SolidColor")
    1: private:
    1:   nscolor   mColor;
    1: };
    1: 
    1: void nsDisplaySolidColor::Paint(nsDisplayListBuilder* aBuilder,
    1:      nsIRenderingContext* aCtx, const nsRect& aDirtyRect)
    1: {
    1:   aCtx->SetColor(mColor);
    1:   aCtx->FillRect(aDirtyRect);
    1: }
    1: 
14043: /**
14043:  * Remove all leaf display items that are not for descendants of
14043:  * aBuilder->GetReferenceFrame() from aList, and move all nsDisplayClip
14043:  * wrappers to their correct locations.
14043:  * @param aExtraPage the page we constructed aList for
14043:  * @param aY the Y-coordinate where aPage would be positioned relative
14043:  * to the main page (aBuilder->GetReferenceFrame()), considering only
14043:  * the content and ignoring page margins and dead space
14043:  * @param aList the list that is modified in-place
14043:  */
14043: static void
14043: PruneDisplayListForExtraPage(nsDisplayListBuilder* aBuilder,
14043:         nsIFrame* aExtraPage, nscoord aY, nsDisplayList* aList)
14043: {
14043:   nsDisplayList newList;
14043:   // The page which we're really constructing a display list for
14043:   nsIFrame* mainPage = aBuilder->ReferenceFrame();
14043: 
14043:   while (PR_TRUE) {
14043:     nsDisplayItem* i = aList->RemoveBottom();
14043:     if (!i)
14043:       break;
14043:     nsDisplayList* subList = i->GetList();
14043:     if (subList) {
14043:       PruneDisplayListForExtraPage(aBuilder, aExtraPage, aY, subList);
14043:       if (i->GetType() == nsDisplayItem::TYPE_CLIP) {
14043:         // This might clip an element which should appear on the first
14043:         // page, and that element might be visible if this uses a 'clip'
14043:         // property with a negative top.
14043:         // The clip area needs to be moved because the frame geometry doesn't
14043:         // put page content frames for adjacent pages vertically adjacent,
14043:         // there are page margins and dead space between them in print 
14043:         // preview, and in printing all pages are at (0,0)...
14043:         // XXX we have no way to test this right now that I know of;
14043:         // the 'clip' property requires an abs-pos element and we never
14043:         // paint abs-pos elements that start after the main page
14043:         // (bug 426909).
14043:         nsDisplayClip* clip = static_cast<nsDisplayClip*>(i);
14043:         clip->SetClipRect(clip->GetClipRect() + nsPoint(0, aY) -
14043:                 aExtraPage->GetOffsetTo(mainPage));
14043:       }
14043:       newList.AppendToTop(i);
14043:     } else {
14043:       nsIFrame* f = i->GetUnderlyingFrame();
14043:       if (f && nsLayoutUtils::IsProperAncestorFrameCrossDoc(mainPage, f)) {
14043:         // This one is in the page we care about, keep it
14043:         newList.AppendToTop(i);
14043:       } else {
14043:         // We're throwing this away so call its destructor now. The memory
14043:         // is owned by aBuilder which destroys all items at once.
23827:         i->~nsDisplayItem();
14043:       }
14043:     }
14043:   }
14043:   aList->AppendToTop(&newList);
14043: }
14043: 
14043: static nsresult
14043: BuildDisplayListForExtraPage(nsDisplayListBuilder* aBuilder,
14043:         nsIFrame* aPage, nscoord aY, nsDisplayList* aList)
14043: {
14043:   nsDisplayList list;
14043:   // Pass an empty dirty rect since we're only interested in finding
14043:   // placeholders whose out-of-flows are in the page
14043:   // aBuilder->GetReferenceFrame(), and the paths to those placeholders
14043:   // have already been marked as NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO.
14043:   // Note that we should still do a prune step since we don't want to
14043:   // rely on dirty-rect checking for correctness.
14043:   nsresult rv = aPage->BuildDisplayListForStackingContext(aBuilder, nsRect(), &list);
14043:   if (NS_FAILED(rv))
14043:     return rv;
14043:   PruneDisplayListForExtraPage(aBuilder, aPage, aY, &list);
14043:   aList->AppendToTop(&list);
14043:   return NS_OK;
14043: }
14043: 
14043: static nsIFrame*
14043: GetNextPage(nsIFrame* aPageContentFrame)
14043: {
14043:   // XXX ugh
14043:   nsIFrame* pageFrame = aPageContentFrame->GetParent();
14043:   NS_ASSERTION(pageFrame->GetType() == nsGkAtoms::pageFrame,
14043:                "pageContentFrame has unexpected parent");
14043:   nsIFrame* nextPageFrame = pageFrame->GetNextSibling();
14043:   if (!nextPageFrame)
14043:     return nsnull;
14043:   NS_ASSERTION(nextPageFrame->GetType() == nsGkAtoms::pageFrame,
14043:                "pageFrame's sibling is not a page frame...");
14043:   nsIFrame* f = nextPageFrame->GetFirstChild(nsnull);
14043:   NS_ASSERTION(f, "pageFrame has no page content frame!");
14043:   NS_ASSERTION(f->GetType() == nsGkAtoms::pageContentFrame,
14043:                "pageFrame's child is not page content!");
14043:   return f;
14043: }
14043: 
    1: nsresult
    1: nsLayoutUtils::PaintFrame(nsIRenderingContext* aRenderingContext, nsIFrame* aFrame,
    1:                           const nsRegion& aDirtyRegion, nscolor aBackground)
    1: {
25009:   nsAutoDisableGetUsedXAssertions disableAssert;
25009: 
    1:   nsDisplayListBuilder builder(aFrame, PR_FALSE, PR_TRUE);
    1:   nsDisplayList list;
    1:   nsRect dirtyRect = aDirtyRegion.GetBounds();
    1: 
    1:   builder.EnterPresShell(aFrame, dirtyRect);
    1: 
25009:   nsresult rv =
    1:     aFrame->BuildDisplayListForStackingContext(&builder, dirtyRect, &list);
14043:     
14043:   if (NS_SUCCEEDED(rv) && aFrame->GetType() == nsGkAtoms::pageContentFrame) {
14043:     // We may need to paint out-of-flow frames whose placeholders are
14043:     // on other pages. Add those pages to our display list. Note that
14043:     // out-of-flow frames can't be placed after their placeholders so
14043:     // we don't have to process earlier pages. The display lists for
14043:     // these extra pages are pruned so that only display items for the
14043:     // page we currently care about (which we would have reached by
14043:     // following placeholders to their out-of-flows) end up on the list.
14043:     nsIFrame* page = aFrame;
14043:     nscoord y = aFrame->GetSize().height;
14043:     while ((page = GetNextPage(page)) != nsnull) {
14043:       rv = BuildDisplayListForExtraPage(&builder, page, y, &list);
14043:       if (NS_FAILED(rv))
14043:         break;
14043:       y += page->GetSize().height;
14043:     }
14043:   }
    1: 
    1:   builder.LeavePresShell(aFrame, dirtyRect);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (NS_GET_A(aBackground) > 0) {
    1:     // Fill the visible area with a background color. In the common case,
    1:     // the visible area is entirely covered by the background of the root
    1:     // document (at least!) so this will be removed by the optimizer. In some
    1:     // cases we might not have a root frame, so this will prevent garbage
    1:     // from being drawn.
    1:     rv = list.AppendNewToBottom(new (&builder) nsDisplaySolidColor(aFrame, aBackground));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   if (gDumpPaintList) {
    1:     fprintf(stderr, "Painting --- before optimization (dirty %d,%d,%d,%d):\n",
    1:             dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
    1:     nsIFrameDebug::PrintDisplayList(&builder, list);
    1:   }
    1: #endif
    1:   
    1:   nsRegion visibleRegion = aDirtyRegion;
    1:   list.OptimizeVisibility(&builder, &visibleRegion);
    1: 
    1: #ifdef DEBUG
    1:   if (gDumpPaintList) {
    1:     fprintf(stderr, "Painting --- after optimization:\n");
    1:     nsIFrameDebug::PrintDisplayList(&builder, list);
    1:   }
    1: #endif
    1:   
    1:   list.Paint(&builder, aRenderingContext, aDirtyRegion.GetBounds());
    1:   // Flush the list so we don't trigger the IsEmpty-on-destruction assertion
    1:   list.DeleteAll();
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: AccumulateItemInRegion(nsRegion* aRegion, const nsRect& aAreaRect,
16739:                        const nsRect& aItemRect, const nsRect& aExclude,
16739:                        nsDisplayItem* aItem)
    1: {
    1:   nsRect damageRect;
    1:   if (damageRect.IntersectRect(aAreaRect, aItemRect)) {
16739:     nsRegion r;
16739:     r.Sub(damageRect, aExclude);
    1: #ifdef DEBUG
    1:     if (gDumpRepaintRegionForCopy) {
16739:       nsRect bounds = r.GetBounds();
    1:       fprintf(stderr, "Adding rect %d,%d,%d,%d for frame %p\n",
16739:               bounds.x, bounds.y, bounds.width, bounds.height,
    1:               (void*)aItem->GetUnderlyingFrame());
    1:     }
    1: #endif
16739:     aRegion->Or(*aRegion, r);
    1:   }
    1: }
    1: 
    1: static void
    1: AddItemsToRegion(nsDisplayListBuilder* aBuilder, nsDisplayList* aList,
    1:                  const nsRect& aRect, const nsRect& aClipRect, nsPoint aDelta,
    1:                  nsRegion* aRegion)
    1: {
    1:   for (nsDisplayItem* item = aList->GetBottom(); item; item = item->GetAbove()) {
    1:     nsDisplayList* sublist = item->GetList();
    1:     if (sublist) {
19125:       nsDisplayItem::Type type = item->GetType();
19125: #ifdef MOZ_SVG
19125:       if (type == nsDisplayItem::TYPE_SVG_EFFECTS) {
19125:         nsDisplaySVGEffects* effectsItem = static_cast<nsDisplaySVGEffects*>(item);
19125:         if (!aBuilder->IsMovingFrame(effectsItem->GetEffectsFrame())) {
19125:           // Invalidate the whole thing
19125:           nsRect r;
19125:           r.IntersectRect(aClipRect, effectsItem->GetBounds(aBuilder));
19125:           aRegion->Or(*aRegion, r);
19125:         }
19125:       } else
19125: #endif
19125:       if (type == nsDisplayItem::TYPE_CLIP) {
14466:         nsDisplayClip* clipItem = static_cast<nsDisplayClip*>(item);
14466:         nsRect clip = aClipRect;
14466:         // If the clipping frame is moving, then it isn't clipping any
14466:         // non-moving content (see ApplyAbsPosClipping), so we don't need
14466:         // to do anything special, but we should not restrict aClipRect.
14466:         if (!aBuilder->IsMovingFrame(clipItem->GetClippingFrame())) {
14466:           clip.IntersectRect(clip, clipItem->GetClipRect());
14466: 
14466:           // Invalidate the translation of the source area that was clipped out
14466:           nsRegion clippedOutSource;
14466:           clippedOutSource.Sub(aRect, clip);
14466:           clippedOutSource.MoveBy(aDelta);
14466:           aRegion->Or(*aRegion, clippedOutSource);
14466: 
14466:           // Invalidate the destination area that is clipped out
14466:           nsRegion clippedOutDestination;
14466:           clippedOutDestination.Sub(aRect + aDelta, clip);
14466:           aRegion->Or(*aRegion, clippedOutDestination);
14466:         }
    1:         AddItemsToRegion(aBuilder, sublist, aRect, clip, aDelta, aRegion);
    1:       } else {
    1:         // opacity, or a generic sublist
    1:         AddItemsToRegion(aBuilder, sublist, aRect, aClipRect, aDelta, aRegion);
    1:       }
    1:     } else {
    1:       nsRect r;
    1:       if (r.IntersectRect(aClipRect, item->GetBounds(aBuilder))) {
    1:         nsIFrame* f = item->GetUnderlyingFrame();
    1:         NS_ASSERTION(f, "Must have an underlying frame for leaf item");
16739:         nsRect exclude;
14202:         if (aBuilder->IsMovingFrame(f)) {
14202:           if (item->IsVaryingRelativeToMovingFrame(aBuilder)) {
14202:             // something like background-attachment:fixed that varies
14202:             // its drawing when it moves
16739:             AccumulateItemInRegion(aRegion, aRect + aDelta, r, exclude, item);
    1:           }
14202:         } else {
16739:           // not moving.
16739:           if (item->IsUniform(aBuilder)) {
16739:             // If it's uniform, we don't need to invalidate where one part
16739:             // of the item was copied to another part.
16739:             exclude.IntersectRect(r, r + aDelta);
16739:           }
    1:           // area where a non-moving element is visible must be repainted
16739:           AccumulateItemInRegion(aRegion, aRect + aDelta, r, exclude, item);
    1:           // we may have bitblitted an area that was painted by a non-moving
    1:           // element. This bitblitted data is invalid and was copied to
18364:           // "r + aDelta".
16739:           AccumulateItemInRegion(aRegion, aRect + aDelta, r + aDelta,
18364:                                  exclude, item);
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsLayoutUtils::ComputeRepaintRegionForCopy(nsIFrame* aRootFrame,
    1:                                            nsIFrame* aMovingFrame,
    1:                                            nsPoint aDelta,
    1:                                            const nsRect& aCopyRect,
    1:                                            nsRegion* aRepaintRegion)
    1: {
    1:   NS_ASSERTION(aRootFrame != aMovingFrame,
    1:                "The root frame shouldn't be the one that's moving, that makes no sense");
    1: 
    1:   // Build the 'after' display list over the whole area of interest.
    1:   // (We have to build the 'after' display list because the frame/view
14202:   // hierarchy has already been updated for the move.
14202:   // We need to ensure that the non-moving frame display items we get
14202:   // are the same ones we would have gotten if we had constructed the
14202:   // 'before' display list. So opaque moving items are only considered to
14202:   // cover the intersection of their old and new bounds (see
14202:   // nsDisplayItem::OptimizeVisibility). A moving clip item is not allowed
14202:   // to clip non-moving items --- this is enforced by the code that sets
14202:   // up nsDisplayClip items, in particular see ApplyAbsPosClipping.
14202:   // XXX but currently a non-moving clip item can incorrectly clip
14466:   // moving items! See bug 428156.
    1:   nsRect rect;
    1:   rect.UnionRect(aCopyRect, aCopyRect + aDelta);
14202:   nsDisplayListBuilder builder(aRootFrame, PR_FALSE, PR_TRUE);
14202:   builder.SetMovingFrame(aMovingFrame, aDelta);
    1:   nsDisplayList list;
    1: 
    1:   builder.EnterPresShell(aRootFrame, rect);
    1: 
    1:   nsresult rv =
    1:     aRootFrame->BuildDisplayListForStackingContext(&builder, rect, &list);
    1: 
    1:   builder.LeavePresShell(aRootFrame, rect);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifdef DEBUG
    1:   if (gDumpRepaintRegionForCopy) {
    1:     fprintf(stderr,
    1:             "Repaint region for copy --- before optimization (area %d,%d,%d,%d, frame %p):\n",
    1:             rect.x, rect.y, rect.width, rect.height, (void*)aMovingFrame);
    1:     nsIFrameDebug::PrintDisplayList(&builder, list);
    1:   }
    1: #endif
    1: 
    1:   // Optimize for visibility, but frames under aMovingFrame will not be
    1:   // considered opaque, so they don't cover non-moving frames.
    1:   nsRegion visibleRegion(aCopyRect);
    1:   visibleRegion.Or(visibleRegion, aCopyRect + aDelta);
    1:   list.OptimizeVisibility(&builder, &visibleRegion);
    1: 
    1: #ifdef DEBUG
    1:   if (gDumpRepaintRegionForCopy) {
    1:     fprintf(stderr, "Repaint region for copy --- after optimization:\n");
    1:     nsIFrameDebug::PrintDisplayList(&builder, list);
    1:   }
    1: #endif
    1: 
    1:   aRepaintRegion->SetEmpty();
    1:   // Any visible non-moving display items get added to the repaint region
    1:   // a) at their current location and b) offset by -aPt (their position in
    1:   // the 'before' display list) (unless they're uniform and we can exclude them).
    1:   // Also, any visible position-varying display items get added to the
    1:   // repaint region. All these areas are confined to aCopyRect+aDelta.
    1:   // We could do more work here: e.g., do another optimize-visibility pass
    1:   // with the moving items taken into account, either on the before-list
    1:   // or the after-list, or even both if we cloned the display lists ... but
    1:   // it's probably not worth it.
    1:   AddItemsToRegion(&builder, &list, aCopyRect, rect, aDelta, aRepaintRegion);
    1:   // Flush the list so we don't trigger the IsEmpty-on-destruction assertion
    1:   list.DeleteAll();
    1:   return NS_OK;
    1: }
    1: 
    1: PRInt32
    1: nsLayoutUtils::GetZIndex(nsIFrame* aFrame) {
    1:   if (!aFrame->GetStyleDisplay()->IsPositioned())
    1:     return 0;
    1: 
    1:   const nsStylePosition* position =
    1:     aFrame->GetStylePosition();
    1:   if (position->mZIndex.GetUnit() == eStyleUnit_Integer)
    1:     return position->mZIndex.GetIntValue();
    1: 
    1:   // sort the auto and 0 elements together
    1:   return 0;
    1: }
    1: 
    1: /**
    1:  * Uses a binary search for find where the cursor falls in the line of text
    1:  * It also keeps track of the part of the string that has already been measured
    1:  * so it doesn't have to keep measuring the same text over and over
    1:  *
    1:  * @param "aBaseWidth" contains the width in twips of the portion 
    1:  * of the text that has already been measured, and aBaseInx contains
    1:  * the index of the text that has already been measured.
    1:  *
    1:  * @param aTextWidth returns the (in twips) the length of the text that falls
    1:  * before the cursor aIndex contains the index of the text where the cursor falls
    1:  */
    1: PRBool
    1: nsLayoutUtils::BinarySearchForPosition(nsIRenderingContext* aRendContext, 
    1:                         const PRUnichar* aText,
    1:                         PRInt32    aBaseWidth,
    1:                         PRInt32    aBaseInx,
    1:                         PRInt32    aStartInx, 
    1:                         PRInt32    aEndInx, 
    1:                         PRInt32    aCursorPos, 
    1:                         PRInt32&   aIndex,
    1:                         PRInt32&   aTextWidth)
    1: {
    1:   PRInt32 range = aEndInx - aStartInx;
    1:   if ((range == 1) || (range == 2 && NS_IS_HIGH_SURROGATE(aText[aStartInx]))) {
    1:     aIndex   = aStartInx + aBaseInx;
    1:     aRendContext->GetWidth(aText, aIndex, aTextWidth);
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   PRInt32 inx = aStartInx + (range / 2);
    1: 
    1:   // Make sure we don't leave a dangling low surrogate
    1:   if (NS_IS_HIGH_SURROGATE(aText[inx-1]))
    1:     inx++;
    1: 
    1:   PRInt32 textWidth = 0;
    1:   aRendContext->GetWidth(aText, inx, textWidth);
    1: 
    1:   PRInt32 fullWidth = aBaseWidth + textWidth;
    1:   if (fullWidth == aCursorPos) {
    1:     aTextWidth = textWidth;
    1:     aIndex = inx;
    1:     return PR_TRUE;
    1:   } else if (aCursorPos < fullWidth) {
    1:     aTextWidth = aBaseWidth;
    1:     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, aStartInx, inx, aCursorPos, aIndex, aTextWidth)) {
    1:       return PR_TRUE;
    1:     }
    1:   } else {
    1:     aTextWidth = fullWidth;
    1:     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, inx, aEndInx, aCursorPos, aIndex, aTextWidth)) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
12349: static void
19125: AddBoxesForFrame(nsIFrame* aFrame,
19125:                  nsLayoutUtils::BoxCallback* aCallback)
    1: {
12349:   nsIAtom* pseudoType = aFrame->GetStyleContext()->GetPseudoType();
    1: 
12349:   if (pseudoType == nsCSSAnonBoxes::tableOuter) {
19125:     AddBoxesForFrame(aFrame->GetFirstChild(nsnull), aCallback);
12349:     nsIFrame* kid = aFrame->GetFirstChild(nsGkAtoms::captionList);
12349:     if (kid) {
19125:       AddBoxesForFrame(kid, aCallback);
12349:     }
12349:   } else if (pseudoType == nsCSSAnonBoxes::mozAnonymousBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozAnonymousPositionedBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozMathMLAnonymousBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozXULAnonymousBlock) {
12349:     for (nsIFrame* kid = aFrame->GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {
19125:       AddBoxesForFrame(kid, aCallback);
12349:     }
12349:   } else {
19125:     aCallback->AddBox(aFrame);
19125:   }
19125: }
19125: 
19125: void
19125: nsLayoutUtils::GetAllInFlowBoxes(nsIFrame* aFrame, BoxCallback* aCallback)
19125: {
19125:   while (aFrame) {
19125:     AddBoxesForFrame(aFrame, aCallback);
19125:     aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
19125:   }
19125: }
19125: 
19125: struct BoxToBorderRect : public nsLayoutUtils::BoxCallback {
19125:   nsIFrame*                    mRelativeTo;
19125:   nsLayoutUtils::RectCallback* mCallback;
19125: 
19125:   BoxToBorderRect(nsIFrame* aRelativeTo, nsLayoutUtils::RectCallback* aCallback)
19125:     : mCallback(aCallback), mRelativeTo(aRelativeTo) {}
19125: 
19125:   virtual void AddBox(nsIFrame* aFrame) {
12349: #ifdef MOZ_SVG
12349:     nsRect r;
12349:     nsIFrame* outer = nsSVGUtils::GetOuterSVGFrameAndCoveredRegion(aFrame, &r);
12349:     if (outer) {
19125:       mCallback->AddRect(r + outer->GetOffsetTo(mRelativeTo));
12349:     } else
12349: #endif
19125:       mCallback->AddRect(nsRect(aFrame->GetOffsetTo(mRelativeTo), aFrame->GetSize()));
12349:   }
19125: };
    1: 
12349: void
12349: nsLayoutUtils::GetAllInFlowRects(nsIFrame* aFrame, nsIFrame* aRelativeTo,
12349:                                  RectCallback* aCallback)
12349: {
19125:   BoxToBorderRect converter(aRelativeTo, aCallback);
19125:   GetAllInFlowBoxes(aFrame, &converter);
    1: }
    1: 
12349: struct RectAccumulator : public nsLayoutUtils::RectCallback {
12349:   nsRect       mResultRect;
12349:   nsRect       mFirstRect;
12349:   PRPackedBool mSeenFirstRect;
12349: 
12349:   RectAccumulator() : mSeenFirstRect(PR_FALSE) {}
12349: 
12349:   virtual void AddRect(const nsRect& aRect) {
12349:     mResultRect.UnionRect(mResultRect, aRect);
12349:     if (!mSeenFirstRect) {
12349:       mSeenFirstRect = PR_TRUE;
12349:       mFirstRect = aRect;
12349:     }
12349:   }
12349: };
12349: 
12349: nsRect
12349: nsLayoutUtils::GetAllInFlowRectsUnion(nsIFrame* aFrame, nsIFrame* aRelativeTo) {
12349:   RectAccumulator accumulator;
12349:   GetAllInFlowRects(aFrame, aRelativeTo, &accumulator);
12349:   return accumulator.mResultRect.IsEmpty() ? accumulator.mFirstRect
12349:           : accumulator.mResultRect;
    1: }
    1: 
15339: nsRect
15339: nsLayoutUtils::GetTextShadowRectsUnion(const nsRect& aTextAndDecorationsRect,
15339:                                        nsIFrame* aFrame)
15339: {
15339:   const nsStyleText* textStyle = aFrame->GetStyleText();
15699:   if (!textStyle->mTextShadow)
15339:     return aTextAndDecorationsRect;
15339: 
15339:   nsRect resultRect = aTextAndDecorationsRect;
15699:   for (PRUint32 i = 0; i < textStyle->mTextShadow->Length(); ++i) {
15339:     nsRect tmpRect(aTextAndDecorationsRect);
15699:     nsCSSShadowItem* shadow = textStyle->mTextShadow->ShadowAt(i);
15339: 
19207:     tmpRect.MoveBy(nsPoint(shadow->mXOffset, shadow->mYOffset));
19207:     tmpRect.Inflate(shadow->mRadius, shadow->mRadius);
15339: 
15339:     resultRect.UnionRect(resultRect, tmpRect);
15339:   }
15339:   return resultRect;
15339: }
15339: 
    1: nsresult
    1: nsLayoutUtils::GetFontMetricsForFrame(nsIFrame* aFrame,
    1:                                       nsIFontMetrics** aFontMetrics)
    1: {
 4355:   return nsLayoutUtils::GetFontMetricsForStyleContext(aFrame->GetStyleContext(),
 4355:                                                       aFontMetrics);
 4355: }
 4355: 
 4355: nsresult
 4355: nsLayoutUtils::GetFontMetricsForStyleContext(nsStyleContext* aStyleContext,
 4355:                                              nsIFontMetrics** aFontMetrics)
 4355: {
19962:   // pass the user font set object into the device context to pass along to CreateFontGroup
19962:   gfxUserFontSet* fs = aStyleContext->PresContext()->GetUserFontSet();
19962:   
19962:   return aStyleContext->PresContext()->DeviceContext()->GetMetricsFor(
19962:                   aStyleContext->GetStyleFont()->mFont,
 4355:                   aStyleContext->GetStyleVisibility()->mLangGroup,
22335:                   fs, *aFontMetrics);
    1: }
    1: 
    1: nsIFrame*
    1: nsLayoutUtils::FindChildContainingDescendant(nsIFrame* aParent, nsIFrame* aDescendantFrame)
    1: {
    1:   nsIFrame* result = aDescendantFrame;
    1: 
    1:   while (result) {
    1:     nsIFrame* parent = result->GetParent();
    1:     if (parent == aParent) {
    1:       break;
    1:     }
    1: 
    1:     // The frame is not an immediate child of aParent so walk up another level
    1:     result = parent;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsBlockFrame*
 9572: nsLayoutUtils::GetAsBlock(nsIFrame* aFrame)
 9572: {
23554:   nsBlockFrame* block = do_QueryFrame(aFrame);
 9572:   return block;
 9572: }
 9572: 
 9572: nsBlockFrame*
    1: nsLayoutUtils::FindNearestBlockAncestor(nsIFrame* aFrame)
    1: {
    1:   nsIFrame* nextAncestor;
    1:   for (nextAncestor = aFrame->GetParent(); nextAncestor;
    1:        nextAncestor = nextAncestor->GetParent()) {
 9572:     nsBlockFrame* block = GetAsBlock(nextAncestor);
 9572:     if (block)
    1:       return block;
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: nsIFrame*
21943: nsLayoutUtils::GetNonGeneratedAncestor(nsIFrame* aFrame)
21943: {
21943:   if (!(aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT))
21943:     return aFrame;
21943: 
21943:   nsFrameManager* frameManager = aFrame->PresContext()->FrameManager();
21943:   nsIFrame* f = aFrame;
21943:   do {
21943:     f = GetParentOrPlaceholderFor(frameManager, f);
21943:   } while (f->GetStateBits() & NS_FRAME_GENERATED_CONTENT);
21943:   return f;
21943: }
21943: 
21943: nsIFrame*
    1: nsLayoutUtils::GetParentOrPlaceholderFor(nsFrameManager* aFrameManager,
    1:                                          nsIFrame* aFrame)
    1: {
 6521:   if ((aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 6521:       && !(aFrame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
    1:     return aFrameManager->GetPlaceholderFrameFor(aFrame);
 6521:   }
    1:   return aFrame->GetParent();
    1: }
    1: 
    1: nsIFrame*
    1: nsLayoutUtils::GetClosestCommonAncestorViaPlaceholders(nsIFrame* aFrame1,
    1:                                                        nsIFrame* aFrame2,
    1:                                                        nsIFrame* aKnownCommonAncestorHint)
    1: {
    1:   NS_PRECONDITION(aFrame1, "aFrame1 must not be null");
    1:   NS_PRECONDITION(aFrame2, "aFrame2 must not be null");
    1: 
  238:   nsPresContext* presContext = aFrame1->PresContext();
  238:   if (presContext != aFrame2->PresContext()) {
    1:     // different documents, no common ancestor
    1:     return nsnull;
    1:   }
    1:   nsFrameManager* frameManager = presContext->PresShell()->FrameManager();
    1: 
24551:   nsAutoTArray<nsIFrame*, 8> frame1Ancestors;
    1:   nsIFrame* f1;
    1:   for (f1 = aFrame1; f1 && f1 != aKnownCommonAncestorHint;
    1:        f1 = GetParentOrPlaceholderFor(frameManager, f1)) {
    1:     frame1Ancestors.AppendElement(f1);
    1:   }
    1:   if (!f1 && aKnownCommonAncestorHint) {
    1:     // So, it turns out aKnownCommonAncestorHint was not an ancestor of f1. Oops.
    1:     // Never mind. We can continue as if aKnownCommonAncestorHint was null.
    1:     aKnownCommonAncestorHint = nsnull;
    1:   }
    1: 
24551:   nsAutoTArray<nsIFrame*, 8> frame2Ancestors;
    1:   nsIFrame* f2;
    1:   for (f2 = aFrame2; f2 && f2 != aKnownCommonAncestorHint;
    1:        f2 = GetParentOrPlaceholderFor(frameManager, f2)) {
    1:     frame2Ancestors.AppendElement(f2);
    1:   }
    1:   if (!f2 && aKnownCommonAncestorHint) {
    1:     // So, it turns out aKnownCommonAncestorHint was not an ancestor of f2.
    1:     // We need to retry with no common ancestor hint.
    1:     return GetClosestCommonAncestorViaPlaceholders(aFrame1, aFrame2, nsnull);
    1:   }
    1: 
    1:   // now frame1Ancestors and frame2Ancestors give us the parent frame chain
    1:   // up to aKnownCommonAncestorHint, or if that is null, up to and including
    1:   // the root frame. We need to walk from the end (i.e., the top of the
    1:   // frame (sub)tree) down to aFrame1/aFrame2 looking for the first difference.
    1:   nsIFrame* lastCommonFrame = aKnownCommonAncestorHint;
24551:   PRInt32 last1 = frame1Ancestors.Length() - 1;
24551:   PRInt32 last2 = frame2Ancestors.Length() - 1;
    1:   while (last1 >= 0 && last2 >= 0) {
24551:     nsIFrame* frame1 = frame1Ancestors.ElementAt(last1);
    1:     if (frame1 != frame2Ancestors.ElementAt(last2))
    1:       break;
    1:     lastCommonFrame = frame1;
    1:     last1--;
    1:     last2--;
    1:   }
    1:   return lastCommonFrame;
    1: }
    1: 
   94: nsIFrame*
   94: nsLayoutUtils::GetNextContinuationOrSpecialSibling(nsIFrame *aFrame)
   94: {
   94:   nsIFrame *result = aFrame->GetNextContinuation();
   94:   if (result)
   94:     return result;
   94: 
   94:   if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0) {
   94:     // We only store the "special sibling" annotation with the first
   94:     // frame in the flow. Walk back to find that frame now.
   94:     aFrame = aFrame->GetFirstInFlow();
   94: 
   94:     void* value = aFrame->GetProperty(nsGkAtoms::IBSplitSpecialSibling);
 3233:     return static_cast<nsIFrame*>(value);
   94:   }
   94: 
   94:   return nsnull;
   94: }
   94: 
19125: nsIFrame*
19125: nsLayoutUtils::GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame)
19125: {
19125:   nsIFrame *result = aFrame->GetFirstContinuation();
19125:   if (result->GetStateBits() & NS_FRAME_IS_SPECIAL) {
19125:     while (PR_TRUE) {
19125:       nsIFrame *f = static_cast<nsIFrame*>
19125:         (result->GetProperty(nsGkAtoms::IBSplitSpecialPrevSibling));
19125:       if (!f)
19125:         break;
19125:       result = f;
19125:     }
19125:   }
19125: 
19125:   return result;
19125: }
19125: 
    1: PRBool
    1: nsLayoutUtils::IsViewportScrollbarFrame(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
    1:     return PR_FALSE;
    1: 
    1:   nsIFrame* rootScrollFrame =
  238:     aFrame->PresContext()->PresShell()->GetRootScrollFrame();
    1:   if (!rootScrollFrame)
    1:     return PR_FALSE;
    1: 
23554:   nsIScrollableFrame* rootScrollableFrame = do_QueryFrame(rootScrollFrame);
    1:   NS_ASSERTION(rootScrollableFrame, "The root scorollable frame is null");
    1: 
    1:   if (!IsProperAncestorFrame(rootScrollFrame, aFrame))
    1:     return PR_FALSE;
    1: 
    1:   nsIFrame* rootScrolledFrame = rootScrollableFrame->GetScrolledFrame();
    1:   return !(rootScrolledFrame == aFrame ||
    1:            IsProperAncestorFrame(rootScrolledFrame, aFrame));
    1: }
    1: 
    1: static nscoord AddPercents(nsLayoutUtils::IntrinsicWidthType aType,
    1:                            nscoord aCurrent, float aPercent)
    1: {
    1:   nscoord result = aCurrent;
    1:   if (aPercent > 0.0f && aType == nsLayoutUtils::PREF_WIDTH) {
    1:     // XXX Should we also consider percentages for min widths, up to a
    1:     // limit?
    1:     if (aPercent >= 1.0f)
    1:       result = nscoord_MAX;
    1:     else
    1:       result = NSToCoordRound(float(result) / (1.0f - aPercent));
    1:   }
    1:   return result;
    1: }
    1: 
16031: static PRBool GetAbsoluteCoord(const nsStyleCoord& aStyle, nscoord& aResult)
16031: {
16031:   if (eStyleUnit_Coord != aStyle.GetUnit())
16031:     return PR_FALSE;
16031:   
16031:   aResult = aStyle.GetCoordValue();
16031:   return PR_TRUE;
16031: }
16031: 
 2301: static PRBool
 2301: GetPercentHeight(const nsStyleCoord& aStyle,
 2301:                  nsIFrame* aFrame,
 2301:                  nscoord& aResult)
 2301: {
 2301:   if (eStyleUnit_Percent != aStyle.GetUnit())
 2301:     return PR_FALSE;
 2301: 
 2301:   nsIFrame *f;
 2301:   for (f = aFrame->GetParent(); f && !f->IsContainingBlock();
 2301:        f = f->GetParent())
 2301:     ;
 2301:   if (!f) {
 2301:     NS_NOTREACHED("top of frame tree not a containing block");
 2301:     return PR_FALSE;
 2301:   }
 2301: 
 2301:   const nsStylePosition *pos = f->GetStylePosition();
 2301:   nscoord h;
16031:   if (!GetAbsoluteCoord(pos->mHeight, h) &&
16031:       !GetPercentHeight(pos->mHeight, f, h)) {
 2301:     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto ||
 2301:                  pos->mHeight.GetUnit() == eStyleUnit_Percent,
 2301:                  "unknown height unit");
 2301:     // There's no basis for the percentage height, so it acts like auto.
 2301:     // Should we consider a max-height < min-height pair a basis for
 2301:     // percentage heights?  The spec is somewhat unclear, and not doing
 2301:     // so is simpler and avoids troubling discontinuities in behavior,
 2301:     // so I'll choose not to. -LDB
 2301:     return PR_FALSE;
 2301:   }
 2301: 
 2301:   nscoord maxh;
16031:   if (GetAbsoluteCoord(pos->mMaxHeight, maxh) ||
16031:       GetPercentHeight(pos->mMaxHeight, f, maxh)) {
 2301:     if (maxh < h)
 2301:       h = maxh;
 2301:   } else {
 2301:     NS_ASSERTION(pos->mMaxHeight.GetUnit() == eStyleUnit_None ||
 2301:                  pos->mMaxHeight.GetUnit() == eStyleUnit_Percent,
 2301:                  "unknown max-height unit");
 2301:   }
 2301: 
 2301:   nscoord minh;
16031:   if (GetAbsoluteCoord(pos->mMinHeight, minh) ||
16031:       GetPercentHeight(pos->mMinHeight, f, minh)) {
 2301:     if (minh > h)
 2301:       h = minh;
 2301:   } else {
 9824:     NS_ASSERTION(pos->mMinHeight.GetUnit() == eStyleUnit_Percent,
 2301:                  "unknown min-height unit");
 2301:   }
 2301: 
 2301:   aResult = NSToCoordRound(aStyle.GetPercentValue() * h);
 2301:   return PR_TRUE;
 2301: }
 2301: 
 8046: // Handles only -moz-max-content and -moz-min-content, and
 8046: // -moz-fit-content for min-width and max-width, since the others
 8046: // (-moz-fit-content for width, and -moz-available) have no effect on
 1068: // intrinsic widths.
 1068: enum eWidthProperty { PROP_WIDTH, PROP_MAX_WIDTH, PROP_MIN_WIDTH };
 1068: static PRBool
 1068: GetIntrinsicCoord(const nsStyleCoord& aStyle,
 1068:                   nsIRenderingContext* aRenderingContext,
 1068:                   nsIFrame* aFrame,
 1068:                   eWidthProperty aProperty,
 1068:                   nscoord& aResult)
 1068: {
 1068:   NS_PRECONDITION(aProperty == PROP_WIDTH || aProperty == PROP_MAX_WIDTH ||
 1068:                   aProperty == PROP_MIN_WIDTH, "unexpected property");
 1068:   if (aStyle.GetUnit() != eStyleUnit_Enumerated)
 1068:     return PR_FALSE;
 1068:   PRInt32 val = aStyle.GetIntValue();
 8046:   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_MIN_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_FIT_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_AVAILABLE,
 1068:                "unexpected enumerated value for width property");
 8046:   if (val == NS_STYLE_WIDTH_AVAILABLE)
 1068:     return PR_FALSE;
 8046:   if (val == NS_STYLE_WIDTH_FIT_CONTENT) {
 1068:     if (aProperty == PROP_WIDTH)
 1068:       return PR_FALSE; // handle like 'width: auto'
 1068:     if (aProperty == PROP_MAX_WIDTH)
 8046:       // constrain large 'width' values down to -moz-max-content
 8046:       val = NS_STYLE_WIDTH_MAX_CONTENT;
 1068:     else
 8046:       // constrain small 'width' or 'max-width' values up to -moz-min-content
 8046:       val = NS_STYLE_WIDTH_MIN_CONTENT;
 1068:   }
 1068: 
 8046:   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_MIN_CONTENT,
 1068:                "should have reduced everything remaining to one of these");
 8046:   if (val == NS_STYLE_WIDTH_MAX_CONTENT)
 1068:     aResult = aFrame->GetPrefWidth(aRenderingContext);
 1068:   else
 1068:     aResult = aFrame->GetMinWidth(aRenderingContext);
 1068:   return PR_TRUE;
 1068: }
 1068: 
    1: #undef  DEBUG_INTRINSIC_WIDTH
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1: static PRInt32 gNoiseIndent = 0;
    1: #endif
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::IntrinsicForContainer(nsIRenderingContext *aRenderingContext,
    1:                                      nsIFrame *aFrame,
    1:                                      IntrinsicWidthType aType)
    1: {
    1:   NS_PRECONDITION(aFrame, "null frame");
    1:   NS_PRECONDITION(aType == MIN_WIDTH || aType == PREF_WIDTH, "bad type");
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:   nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:   printf(" %s intrinsic width for container:\n",
    1:          aType == MIN_WIDTH ? "min" : "pref");
    1: #endif
    1: 
    1:   nsIFrame::IntrinsicWidthOffsetData offsets =
    1:     aFrame->IntrinsicWidthOffsets(aRenderingContext);
    1: 
    1:   const nsStylePosition *stylePos = aFrame->GetStylePosition();
 1068:   PRUint8 boxSizing = stylePos->mBoxSizing;
    1:   const nsStyleCoord &styleWidth = stylePos->mWidth;
    1:   const nsStyleCoord &styleMinWidth = stylePos->mMinWidth;
    1:   const nsStyleCoord &styleMaxWidth = stylePos->mMaxWidth;
    1: 
    1:   // We build up two values starting with the content box, and then
    1:   // adding padding, border and margin.  The result is normally
    1:   // |result|.  Then, when we handle 'width', 'min-width', and
    1:   // 'max-width', we use the results we've been building in |min| as a
    1:   // minimum, overriding 'min-width'.  This ensures two things:
    1:   //   * that we don't let a value of 'box-sizing' specifying a width
    1:   //     smaller than the padding/border inside the box-sizing box give
    1:   //     a content width less than zero
    1:   //   * that we prevent tables from becoming smaller than their
    1:   //     intrinsic minimum width
    1:   nscoord result = 0, min = 0;
    1: 
    1:   // If we have a specified width (or a specified 'min-width' greater
    1:   // than the specified 'max-width', which works out to the same thing),
    1:   // don't even bother getting the frame's intrinsic width.
 1068:   if (styleWidth.GetUnit() == eStyleUnit_Enumerated &&
 8046:       (styleWidth.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:        styleWidth.GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT)) {
 8046:     // -moz-fit-content and -moz-available enumerated widths compute intrinsic
 1068:     // widths just like auto.
 8046:     // For -moz-max-content and -moz-min-content, we handle them like
 1068:     // specified widths, but ignore -moz-box-sizing.
 1068:     boxSizing = NS_STYLE_BOX_SIZING_CONTENT;
 1068:   } else if (styleWidth.GetUnit() != eStyleUnit_Coord &&
    1:              (styleMinWidth.GetUnit() != eStyleUnit_Coord ||
    1:               styleMaxWidth.GetUnit() != eStyleUnit_Coord ||
    1:               styleMaxWidth.GetCoordValue() > styleMinWidth.GetCoordValue())) {
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:     ++gNoiseIndent;
    1: #endif
    1:     if (aType == MIN_WIDTH)
    1:       result = aFrame->GetMinWidth(aRenderingContext);
    1:     else
    1:       result = aFrame->GetPrefWidth(aRenderingContext);
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:     --gNoiseIndent;
    1:     nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:     static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:     printf(" %s intrinsic width from frame is %d.\n",
    1:            aType == MIN_WIDTH ? "min" : "pref", result);
    1: #endif
 2301: 
 2301:     // Handle elements with an intrinsic ratio (or size) and a specified
 2301:     // height, min-height, or max-height.
 2301:     const nsStyleCoord &styleHeight = stylePos->mHeight;
 2301:     const nsStyleCoord &styleMinHeight = stylePos->mMinHeight;
 2301:     const nsStyleCoord &styleMaxHeight = stylePos->mMaxHeight;
 2301:     if (styleHeight.GetUnit() != eStyleUnit_Auto ||
 2301:         !(styleMinHeight.GetUnit() == eStyleUnit_Coord &&
 2301:           styleMinHeight.GetCoordValue() == 0) ||
 2301:         styleMaxHeight.GetUnit() != eStyleUnit_None) {
 2301: 
 2301:       nsSize ratio = aFrame->GetIntrinsicRatio();
 2301: 
 2301:       if (ratio.height != 0) {
 2301: 
 2301:         nscoord h;
16031:         if (GetAbsoluteCoord(styleHeight, h) ||
16031:             GetPercentHeight(styleHeight, aFrame, h)) {
 2301:           result =
 2301:             NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:         }
 2301: 
16031:         if (GetAbsoluteCoord(styleMaxHeight, h) ||
16031:             GetPercentHeight(styleMaxHeight, aFrame, h)) {
 2301:           h = NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:           if (h < result)
 2301:             result = h;
 2301:         }
 2301: 
16031:         if (GetAbsoluteCoord(styleMinHeight, h) ||
16031:             GetPercentHeight(styleMinHeight, aFrame, h)) {
 2301:           h = NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:           if (h > result)
 2301:             result = h;
 2301:         }
 2301:       }
 2301:     }
    1:   }
    1:       
    1:   if (aFrame->GetType() == nsGkAtoms::tableFrame) {
    1:     // Tables can't shrink smaller than their intrinsic minimum width,
    1:     // no matter what.
    1:     min = aFrame->GetMinWidth(aRenderingContext);
    1:   }
    1: 
    1:   // We also need to track what has been added on outside of the box
    1:   // (controlled by 'box-sizing') where 'width', 'min-width' and
    1:   // 'max-width' are applied.  We have to account for these properties
    1:   // after getting all the offsets (margin, border, padding) because
    1:   // percentages do not operate linearly.
    1:   // Doing this is ok because although percentages aren't handled
    1:   // linearly, they are handled monotonically.
    1:   nscoord coordOutsideWidth = offsets.hPadding;
    1:   float pctOutsideWidth = offsets.hPctPadding;
    1: 
    1:   float pctTotal = 0.0f;
    1: 
    1:   if (boxSizing == NS_STYLE_BOX_SIZING_PADDING) {
    1:     min += coordOutsideWidth;
 6254:     result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:     pctTotal += pctOutsideWidth;
    1: 
    1:     coordOutsideWidth = 0;
    1:     pctOutsideWidth = 0.0f;
    1:   }
    1: 
    1:   coordOutsideWidth += offsets.hBorder;
    1: 
    1:   if (boxSizing == NS_STYLE_BOX_SIZING_BORDER) {
    1:     min += coordOutsideWidth;
 6254:     result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:     pctTotal += pctOutsideWidth;
    1: 
    1:     coordOutsideWidth = 0;
    1:     pctOutsideWidth = 0.0f;
    1:   }
    1: 
    1:   coordOutsideWidth += offsets.hMargin;
    1:   pctOutsideWidth += offsets.hPctMargin;
    1: 
    1:   min += coordOutsideWidth;
 6254:   result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:   pctTotal += pctOutsideWidth;
    1: 
    1:   nscoord w;
16031:   if (GetAbsoluteCoord(styleWidth, w) ||
 1068:       GetIntrinsicCoord(styleWidth, aRenderingContext, aFrame,
 1068:                         PROP_WIDTH, w)) {
    1:     result = AddPercents(aType, w + coordOutsideWidth, pctOutsideWidth);
    1:   }
    1:   else if (aType == MIN_WIDTH && eStyleUnit_Percent == styleWidth.GetUnit() &&
    1:            aFrame->IsFrameOfType(nsIFrame::eReplaced)) {
    1:     // A percentage width on replaced elements means they can shrink to 0.
    1:     result = 0; // let |min| handle padding/border/margin
    1:   }
    1:   else {
    1:     result = AddPercents(aType, result, pctTotal);
    1:   }
    1: 
    1:   nscoord maxw;
16031:   if (GetAbsoluteCoord(styleMaxWidth, maxw) ||
 1068:       GetIntrinsicCoord(styleMaxWidth, aRenderingContext, aFrame,
 1068:                         PROP_MAX_WIDTH, maxw)) {
    1:     maxw = AddPercents(aType, maxw + coordOutsideWidth, pctOutsideWidth);
    1:     if (result > maxw)
    1:       result = maxw;
    1:   }
    1: 
    1:   nscoord minw;
16031:   if (GetAbsoluteCoord(styleMinWidth, minw) ||
 1068:       GetIntrinsicCoord(styleMinWidth, aRenderingContext, aFrame,
 1068:                         PROP_MIN_WIDTH, minw)) {
    1:     minw = AddPercents(aType, minw + coordOutsideWidth, pctOutsideWidth);
    1:     if (result < minw)
    1:       result = minw;
    1:   }
    1: 
    1:   min = AddPercents(aType, min, pctTotal);
    1:   if (result < min)
    1:     result = min;
    1: 
    1:   const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
    1:   if (aFrame->IsThemed(disp)) {
23738:     nsIntSize size(0, 0);
    1:     PRBool canOverride = PR_TRUE;
  238:     nsPresContext *presContext = aFrame->PresContext();
    1:     presContext->GetTheme()->
    1:       GetMinimumWidgetSize(aRenderingContext, aFrame, disp->mAppearance,
    1:                            &size, &canOverride);
    1: 
    1:     nscoord themeWidth = presContext->DevPixelsToAppUnits(size.width);
    1: 
    1:     // GMWS() returns a border-box width
    1:     themeWidth += offsets.hMargin;
    1:     themeWidth = AddPercents(aType, themeWidth, offsets.hPctMargin);
    1: 
    1:     if (themeWidth > result || !canOverride)
    1:       result = themeWidth;
    1:   }
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:   nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:   printf(" %s intrinsic width for container is %d twips.\n",
    1:          aType == MIN_WIDTH ? "min" : "pref", result);
    1: #endif
    1: 
    1:   return result;
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::ComputeWidthDependentValue(
    1:                  nscoord              aContainingBlockWidth,
    1:                  const nsStyleCoord&  aCoord)
    1: {
    1:   NS_PRECONDITION(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
    1:                   "unconstrained widths no longer supported");
    1: 
16031:   if (eStyleUnit_Coord == aCoord.GetUnit()) {
16031:     return aCoord.GetCoordValue();
    1:   }
    1:   if (eStyleUnit_Percent == aCoord.GetUnit()) {
    1:     return NSToCoordFloor(aContainingBlockWidth * aCoord.GetPercentValue());
    1:   }
 1363:   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
 1068:                aCoord.GetUnit() == eStyleUnit_Auto,
 1068:                "unexpected width value");
    1:   return 0;
    1: }
    1: 
    1: /* static */ nscoord
 1068: nsLayoutUtils::ComputeWidthValue(
 1068:                  nsIRenderingContext* aRenderingContext,
 1068:                  nsIFrame*            aFrame,
 1068:                  nscoord              aContainingBlockWidth,
 1068:                  nscoord              aContentEdgeToBoxSizing,
 1068:                  nscoord              aBoxSizingToMarginEdge,
 1068:                  const nsStyleCoord&  aCoord)
 1068: {
 1068:   NS_PRECONDITION(aFrame, "non-null frame expected");
 1068:   NS_PRECONDITION(aRenderingContext, "non-null rendering context expected");
 1068:   NS_PRECONDITION(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
 1068:                   "unconstrained widths no longer supported");
 1068:   NS_PRECONDITION(aContainingBlockWidth >= 0,
 1068:                   "width less than zero");
 1068: 
 1068:   nscoord result;
16031:   if (eStyleUnit_Coord == aCoord.GetUnit()) {
16031:     result = aCoord.GetCoordValue();
 1068:     NS_ASSERTION(result >= 0, "width less than zero");
 1068:     result -= aContentEdgeToBoxSizing;
 1068:   } else if (eStyleUnit_Percent == aCoord.GetUnit()) {
 1068:     NS_ASSERTION(aCoord.GetPercentValue() >= 0.0f, "width less than zero");
 1068:     result = NSToCoordFloor(aContainingBlockWidth * aCoord.GetPercentValue()) -
 1068:              aContentEdgeToBoxSizing;
 1068:   } else if (eStyleUnit_Enumerated == aCoord.GetUnit()) {
 1068:     PRInt32 val = aCoord.GetIntValue();
 1068:     switch (val) {
 8046:       case NS_STYLE_WIDTH_MAX_CONTENT:
 1068:         result = aFrame->GetPrefWidth(aRenderingContext);
 1068:         NS_ASSERTION(result >= 0, "width less than zero");
 1068:         break;
 8046:       case NS_STYLE_WIDTH_MIN_CONTENT:
 1068:         result = aFrame->GetMinWidth(aRenderingContext);
 1068:         NS_ASSERTION(result >= 0, "width less than zero");
 1068:         break;
 8046:       case NS_STYLE_WIDTH_FIT_CONTENT:
 1068:         {
 1068:           nscoord pref = aFrame->GetPrefWidth(aRenderingContext),
 1068:                    min = aFrame->GetMinWidth(aRenderingContext),
 1068:                   fill = aContainingBlockWidth -
 1068:                          (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
 1068:           result = PR_MAX(min, PR_MIN(pref, fill));
 1068:           NS_ASSERTION(result >= 0, "width less than zero");
 1068:         }
 1068:         break;
 8046:       case NS_STYLE_WIDTH_AVAILABLE:
 1068:         result = aContainingBlockWidth -
 1068:                  (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
 1068:     }
 1068:   } else {
 1068:     NS_NOTREACHED("unexpected width value");
 1068:     result = 0;
 1068:   }
 1068:   if (result < 0)
 1068:     result = 0;
 1068:   return result;
 1068: }
 1068: 
 1068: 
 1068: /* static */ nscoord
    1: nsLayoutUtils::ComputeHeightDependentValue(
    1:                  nscoord              aContainingBlockHeight,
    1:                  const nsStyleCoord&  aCoord)
    1: {
16031:   if (eStyleUnit_Coord == aCoord.GetUnit()) {
16031:     return aCoord.GetCoordValue();
    1:   }
    1:   if (eStyleUnit_Percent == aCoord.GetUnit()) {
    1:     // XXXldb Some callers explicitly check aContainingBlockHeight
    1:     // against NS_AUTOHEIGHT *and* unit against eStyleUnit_Percent
    1:     // before calling this function, so this assertion probably needs to
    1:     // be inside the percentage case.  However, it would be much more
    1:     // likely to catch problems if it were at the start of the function.
    1:     // XXXldb Many callers pass a non-'auto' containing block height when
    1:     // according to CSS2.1 they should be passing 'auto'.
    1:     NS_PRECONDITION(NS_AUTOHEIGHT != aContainingBlockHeight,
    1:                     "unexpected 'containing block height'");
    1: 
    1:     if (NS_AUTOHEIGHT != aContainingBlockHeight) {
    1:       return NSToCoordFloor(aContainingBlockHeight * aCoord.GetPercentValue());
    1:     }
    1:   }
 1363:   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
 1068:                aCoord.GetUnit() == eStyleUnit_Auto,
 1068:                "unexpected height value");
    1:   return 0;
    1: }
    1: 
    1: inline PRBool
    1: IsAutoHeight(const nsStyleCoord &aCoord, nscoord aCBHeight)
    1: {
    1:   nsStyleUnit unit = aCoord.GetUnit();
    1:   return unit == eStyleUnit_Auto ||  // only for 'height'
 1363:          unit == eStyleUnit_None ||  // only for 'max-height'
    1:          (unit == eStyleUnit_Percent && 
    1:           aCBHeight == NS_AUTOHEIGHT);
    1: }
    1: 
    1: #define MULDIV(a,b,c) (nscoord(PRInt64(a) * PRInt64(b) / PRInt64(c)))
    1: 
    1: /* static */ nsSize
    1: nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
 8142:                    nsIRenderingContext* aRenderingContext, nsIFrame* aFrame,
 8147:                    const nsIFrame::IntrinsicSize& aIntrinsicSize,
 8142:                    nsSize aIntrinsicRatio, nsSize aCBSize,
 1068:                    nsSize aMargin, nsSize aBorder, nsSize aPadding)
    1: {
    1:   const nsStylePosition *stylePos = aFrame->GetStylePosition();
    1:   // Handle intrinsic sizes and their interaction with
    1:   // {min-,max-,}{width,height} according to the rules in
    1:   // http://www.w3.org/TR/CSS21/visudet.html#min-max-widths
    1: 
    1:   // Note: throughout the following section of the function, I avoid
    1:   // a * (b / c) because of its reduced accuracy relative to a * b / c
    1:   // or (a * b) / c (which are equivalent).
    1: 
 1068:   const PRBool isAutoWidth = stylePos->mWidth.GetUnit() == eStyleUnit_Auto;
 1068:   const PRBool isAutoHeight = IsAutoHeight(stylePos->mHeight, aCBSize.height);
    1: 
    1:   nsSize boxSizingAdjust(0,0);
    1:   switch (stylePos->mBoxSizing) {
    1:     case NS_STYLE_BOX_SIZING_BORDER:
    1:       boxSizingAdjust += aBorder;
    1:       // fall through
    1:     case NS_STYLE_BOX_SIZING_PADDING:
    1:       boxSizingAdjust += aPadding;
    1:   }
 1068:   nscoord boxSizingToMarginEdgeWidth =
 1068:     aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width;
    1: 
    1:   nscoord width, minWidth, maxWidth, height, minHeight, maxHeight;
    1: 
    1:   if (!isAutoWidth) {
 1068:     width = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:               aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:               boxSizingToMarginEdgeWidth, stylePos->mWidth);
 1068:     NS_ASSERTION(width >= 0, "negative result from ComputeWidthValue");
    1:   }
    1: 
 1363:   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_None) {
 1068:     maxWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:                  aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:                  boxSizingToMarginEdgeWidth, stylePos->mMaxWidth);
 1068:     NS_ASSERTION(maxWidth >= 0, "negative result from ComputeWidthValue");
    1:   } else {
    1:     maxWidth = nscoord_MAX;
    1:   }
    1: 
 1068:   minWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:                aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:                boxSizingToMarginEdgeWidth, stylePos->mMinWidth);
 1068:   NS_ASSERTION(minWidth >= 0, "negative result from ComputeWidthValue");
    1: 
    1:   if (!isAutoHeight) {
16031:     height = nsLayoutUtils::
16031:       ComputeHeightDependentValue(aCBSize.height, stylePos->mHeight) -
    1:       boxSizingAdjust.height;
    1:     if (height < 0)
    1:       height = 0;
    1:   }
    1: 
    1:   if (!IsAutoHeight(stylePos->mMaxHeight, aCBSize.height)) {
16031:     maxHeight = nsLayoutUtils::
16031:       ComputeHeightDependentValue(aCBSize.height, stylePos->mMaxHeight) -
    1:       boxSizingAdjust.height;
    1:     if (maxHeight < 0)
    1:       maxHeight = 0;
    1:   } else {
    1:     maxHeight = nscoord_MAX;
    1:   }
    1: 
    1:   if (!IsAutoHeight(stylePos->mMinHeight, aCBSize.height)) {
16031:     minHeight = nsLayoutUtils::
16031:       ComputeHeightDependentValue(aCBSize.height, stylePos->mMinHeight) -
    1:       boxSizingAdjust.height;
    1:     if (minHeight < 0)
    1:       minHeight = 0;
    1:   } else {
    1:     minHeight = 0;
    1:   }
    1: 
 8142:   // Resolve percentage intrinsic width/height as necessary:
 8142: 
 8142:   NS_ASSERTION(aCBSize.width != NS_UNCONSTRAINEDSIZE,
 8142:                "Our containing block must not have unconstrained width!");
 8142: 
 8142:   PRBool hasIntrinsicWidth, hasIntrinsicHeight;
 8142:   nscoord intrinsicWidth, intrinsicHeight;
 8142: 
 8142:   if (aIntrinsicSize.width.GetUnit() == eStyleUnit_Coord ||
 8142:       aIntrinsicSize.width.GetUnit() == eStyleUnit_Percent) {
 8142:     hasIntrinsicWidth = PR_TRUE;
 8142:     intrinsicWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 8142:                            aFrame, aCBSize.width, 0, boxSizingAdjust.width +
 8142:                            boxSizingToMarginEdgeWidth, aIntrinsicSize.width);
 8142:   } else {
 8142:     hasIntrinsicWidth = PR_FALSE;
 8142:     intrinsicWidth = 0;
 8142:   }
 8142: 
 8142:   if (aIntrinsicSize.height.GetUnit() == eStyleUnit_Coord ||
 8142:       (aIntrinsicSize.height.GetUnit() == eStyleUnit_Percent &&
 8142:        aCBSize.height != NS_AUTOHEIGHT)) {
 8142:     hasIntrinsicHeight = PR_TRUE;
16031:     intrinsicHeight = nsLayoutUtils::
16031:       ComputeHeightDependentValue(aCBSize.height, aIntrinsicSize.height);
 8142:     if (intrinsicHeight < 0)
 8142:       intrinsicHeight = 0;
 8142:   } else {
 8142:     hasIntrinsicHeight = PR_FALSE;
 8142:     intrinsicHeight = 0;
 8142:   }
 8142: 
 8142:   NS_ASSERTION(aIntrinsicRatio.width >= 0 && aIntrinsicRatio.height >= 0,
 8142:                "Intrinsic ratio has a negative component!");
 8142: 
 8142:   // Now calculate the used values for width and height:
 8142: 
    1:   if (isAutoWidth) {
    1:     if (isAutoHeight) {
    1: 
    1:       // 'auto' width, 'auto' height
 8142: 
 8142:       // Get tentative values - CSS 2.1 sections 10.3.2 and 10.6.2:
 8142: 
 8142:       nscoord tentWidth, tentHeight;
 8142: 
 8142:       if (hasIntrinsicWidth) {
 8142:         tentWidth = intrinsicWidth;
 8142:       } else if (hasIntrinsicHeight && aIntrinsicRatio.height > 0) {
 8142:         tentWidth = MULDIV(intrinsicHeight, aIntrinsicRatio.width, aIntrinsicRatio.height);
 8142:       } else if (aIntrinsicRatio.width > 0) {
 8142:         tentWidth = aCBSize.width - boxSizingToMarginEdgeWidth; // XXX scrollbar?
 8142:         if (tentWidth < 0) tentWidth = 0;
 8142:       } else {
 8142:         tentWidth = nsPresContext::CSSPixelsToAppUnits(300);
 8142:       }
 8142: 
 8142:       if (hasIntrinsicHeight) {
 8142:         tentHeight = intrinsicHeight;
 8142:       } else if (aIntrinsicRatio.width > 0) {
 8142:         tentHeight = MULDIV(tentWidth, aIntrinsicRatio.height, aIntrinsicRatio.width);
 8142:       } else {
 8142:         tentHeight = nsPresContext::CSSPixelsToAppUnits(150);
 8142:       }
 8142: 
 8142:       // Now apply min/max-width/height - CSS 2.1 sections 10.4 and 10.7:
 8142: 
    1:       if (minWidth > maxWidth)
    1:         maxWidth = minWidth;
    1:       if (minHeight > maxHeight)
    1:         maxHeight = minHeight;
    1: 
    1:       nscoord heightAtMaxWidth, heightAtMinWidth,
    1:               widthAtMaxHeight, widthAtMinHeight;
 8142: 
 8142:       if (tentWidth > 0) {
 8142:         heightAtMaxWidth = MULDIV(maxWidth, tentHeight, tentWidth);
    1:         if (heightAtMaxWidth < minHeight)
    1:           heightAtMaxWidth = minHeight;
 8142:         heightAtMinWidth = MULDIV(minWidth, tentHeight, tentWidth);
    1:         if (heightAtMinWidth > maxHeight)
    1:           heightAtMinWidth = maxHeight;
    1:       } else {
 8142:         heightAtMaxWidth = tentHeight;
 8142:         heightAtMinWidth = tentHeight;
    1:       }
    1: 
 8142:       if (tentHeight > 0) {
 8142:         widthAtMaxHeight = MULDIV(maxHeight, tentWidth, tentHeight);
    1:         if (widthAtMaxHeight < minWidth)
    1:           widthAtMaxHeight = minWidth;
 8142:         widthAtMinHeight = MULDIV(minHeight, tentWidth, tentHeight);
    1:         if (widthAtMinHeight > maxWidth)
    1:           widthAtMinHeight = maxWidth;
    1:       } else {
 8142:         widthAtMaxHeight = tentWidth;
 8142:         widthAtMinHeight = tentWidth;
    1:       }
    1: 
 8142:       // The table at http://www.w3.org/TR/CSS21/visudet.html#min-max-widths :
 8142: 
 8142:       if (tentWidth > maxWidth) {
 8142:         if (tentHeight > maxHeight) {
 8142:           if (PRInt64(maxWidth) * PRInt64(tentHeight) <=
 8142:               PRInt64(maxHeight) * PRInt64(tentWidth)) {
    1:             width = maxWidth;
    1:             height = heightAtMaxWidth;
    1:           } else {
 8142:             width = widthAtMaxHeight;
    1:             height = maxHeight;
    1:           }
    1:         } else {
 8142:           // This also covers "(w > max-width) and (h < min-height)" since in
 8142:           // that case (max-width/w < 1), and with (h < min-height):
 8142:           //   max(max-width * h/w, min-height) == min-height
    1:           width = maxWidth;
    1:           height = heightAtMaxWidth;
    1:         }
 8142:       } else if (tentWidth < minWidth) {
 8142:         if (tentHeight < minHeight) {
 8142:           if (PRInt64(minWidth) * PRInt64(tentHeight) <= 
 8142:               PRInt64(minHeight) * PRInt64(tentWidth)) {
 8142:             width = widthAtMinHeight;
    1:             height = minHeight;
    1:           } else {
    1:             width = minWidth;
    1:             height = heightAtMinWidth;
    1:           }
    1:         } else {
 8142:           // This also covers "(w < min-width) and (h > max-height)" since in
 8142:           // that case (min-width/w > 1), and with (h > max-height):
 8142:           //   min(min-width * h/w, max-height) == max-height
    1:           width = minWidth;
    1:           height = heightAtMinWidth;
    1:         }
    1:       } else {
 8142:         if (tentHeight > maxHeight) {
 8142:           width = widthAtMaxHeight;
    1:           height = maxHeight;
 8142:         } else if (tentHeight < minHeight) {
 8142:           width = widthAtMinHeight;
    1:           height = minHeight;
    1:         } else {
 8142:           width = tentWidth;
 8142:           height = tentHeight;
    1:         }
    1:       }
    1: 
    1:     } else {
    1: 
    1:       // 'auto' width, non-'auto' height
    1:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
 8142:       if (aIntrinsicRatio.height > 0) {
 8142:         width = MULDIV(height, aIntrinsicRatio.width, aIntrinsicRatio.height);
 8142:       } else if (hasIntrinsicWidth) {
 8142:         width = intrinsicWidth;
    1:       } else {
 8142:         width = nsPresContext::CSSPixelsToAppUnits(300);
    1:       }
    1:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
    1: 
    1:     }
    1:   } else {
    1:     if (isAutoHeight) {
    1: 
    1:       // non-'auto' width, 'auto' height
    1:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
 8142:       if (aIntrinsicRatio.width > 0) {
 8142:         height = MULDIV(width, aIntrinsicRatio.height, aIntrinsicRatio.width);
 8142:       } else if (hasIntrinsicHeight) {
 8142:         height = intrinsicHeight;
    1:       } else {
 8142:         height = nsPresContext::CSSPixelsToAppUnits(150);
    1:       }
    1:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
    1: 
    1:     } else {
    1: 
    1:       // non-'auto' width, non-'auto' height
 8142:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
    1:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
    1: 
    1:     }
    1:   }
    1: 
    1:   return nsSize(width, height);
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::MinWidthFromInline(nsIFrame* aFrame,
    1:                                   nsIRenderingContext* aRenderingContext)
    1: {
    1:   nsIFrame::InlineMinWidthData data;
    1:   DISPLAY_MIN_WIDTH(aFrame, data.prevLines);
    1:   aFrame->AddInlineMinWidth(aRenderingContext, &data);
 2668:   data.ForceBreak(aRenderingContext);
    1:   return data.prevLines;
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::PrefWidthFromInline(nsIFrame* aFrame,
    1:                                    nsIRenderingContext* aRenderingContext)
    1: {
    1:   nsIFrame::InlinePrefWidthData data;
    1:   DISPLAY_PREF_WIDTH(aFrame, data.prevLines);
    1:   aFrame->AddInlinePrefWidth(aRenderingContext, &data);
 2668:   data.ForceBreak(aRenderingContext);
    1:   return data.prevLines;
    1: }
    1: 
    1: void
    1: nsLayoutUtils::DrawString(const nsIFrame*      aFrame,
    1:                           nsIRenderingContext* aContext,
    1:                           const PRUnichar*     aString,
    1:                           PRInt32              aLength,
24995:                           nsPoint              aPoint,
24995:                           PRUint8              aDirection)
    1: {
    1: #ifdef IBMBIDI
    1:   nsresult rv = NS_ERROR_FAILURE;
  238:   nsPresContext* presContext = aFrame->PresContext();
    1:   if (presContext->BidiEnabled()) {
    1:     nsBidiPresUtils* bidiUtils = presContext->GetBidiUtils();
    1: 
    1:     if (bidiUtils) {
24995:       if (aDirection == NS_STYLE_DIRECTION_INHERIT) {
24995:         aDirection = aFrame->GetStyleVisibility()->mDirection;
24995:       }
    1:       nsBidiDirection direction =
24995:         (NS_STYLE_DIRECTION_RTL == aDirection) ?
    1:         NSBIDI_RTL : NSBIDI_LTR;
    1:       rv = bidiUtils->RenderText(aString, aLength, direction,
    1:                                  presContext, *aContext,
    1:                                  aPoint.x, aPoint.y);
    1:     }
    1:   }
    1:   if (NS_FAILED(rv))
    1: #endif // IBMBIDI
    1:   { 
    1:     aContext->SetTextRunRTL(PR_FALSE);
    1:     aContext->DrawString(aString, aLength, aPoint.x, aPoint.y);
    1:   }
    1: }
    1: 
    1: nscoord
    1: nsLayoutUtils::GetStringWidth(const nsIFrame*      aFrame,
    1:                               nsIRenderingContext* aContext,
    1:                               const PRUnichar*     aString,
    1:                               PRInt32              aLength)
    1: {
    1: #ifdef IBMBIDI
  238:   nsPresContext* presContext = aFrame->PresContext();
    1:   if (presContext->BidiEnabled()) {
    1:     nsBidiPresUtils* bidiUtils = presContext->GetBidiUtils();
    1: 
    1:     if (bidiUtils) {
    1:       const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
    1:       nsBidiDirection direction =
    1:         (NS_STYLE_DIRECTION_RTL == vis->mDirection) ?
    1:         NSBIDI_RTL : NSBIDI_LTR;
    1:       return bidiUtils->MeasureTextWidth(aString, aLength,
    1:                                          direction, presContext, *aContext);
    1:     }
    1:   }
    1: #endif // IBMBIDI
    1:   aContext->SetTextRunRTL(PR_FALSE);
    1:   nscoord width;
    1:   aContext->GetWidth(aString, aLength, width);
    1:   return width;
    1: }
    1: 
    1: /* static */ PRBool
    1: nsLayoutUtils::GetFirstLineBaseline(const nsIFrame* aFrame, nscoord* aResult)
    1: {
15909:   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
15909:   if (!block) {
    1:     // For the first-line baseline we also have to check for a table, and if
    1:     // so, use the baseline of its first row.
    1:     nsIAtom* fType = aFrame->GetType();
    1:     if (fType == nsGkAtoms::tableOuterFrame) {
    1:       *aResult = aFrame->GetBaseline();
    1:       return PR_TRUE;
    1:     }
    1: 
    1:     // For first-line baselines, we have to consider scroll frames.
    1:     if (fType == nsGkAtoms::scrollFrame) {
23554:       nsIScrollableFrame *sFrame = do_QueryFrame(const_cast<nsIFrame*>(aFrame));
23554:       if (!sFrame) {
    1:         NS_NOTREACHED("not scroll frame");
    1:       }
    1:       nscoord kidBaseline;
    1:       if (GetFirstLineBaseline(sFrame->GetScrolledFrame(), &kidBaseline)) {
    1:         // Consider only the border and padding that contributes to the
    1:         // kid's position, not the scrolling, so we get the initial
    1:         // position.
    1:         *aResult = kidBaseline + aFrame->GetUsedBorderAndPadding().top;
    1:         return PR_TRUE;
    1:       }
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     // No baseline.
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   for (nsBlockFrame::const_line_iterator line = block->begin_lines(),
    1:                                      line_end = block->end_lines();
    1:        line != line_end; ++line) {
    1:     if (line->IsBlock()) {
    1:       nsIFrame *kid = line->mFirstChild;
    1:       nscoord kidBaseline;
    1:       if (GetFirstLineBaseline(kid, &kidBaseline)) {
    1:         *aResult = kidBaseline + kid->GetPosition().y;
    1:         return PR_TRUE;
    1:       }
    1:     } else {
    1:       // XXX Is this the right test?  We have some bogus empty lines
    1:       // floating around, but IsEmpty is perhaps too weak.
    1:       if (line->GetHeight() != 0 || !line->IsEmpty()) {
    1:         *aResult = line->mBounds.y + line->GetAscent();
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: /* static */ PRBool
    1: nsLayoutUtils::GetLastLineBaseline(const nsIFrame* aFrame, nscoord* aResult)
    1: {
15909:   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
15909:   if (!block)
    1:     // No baseline.  (We intentionally don't descend into scroll frames.)
    1:     return PR_FALSE;
    1: 
    1:   for (nsBlockFrame::const_reverse_line_iterator line = block->rbegin_lines(),
    1:                                              line_end = block->rend_lines();
    1:        line != line_end; ++line) {
    1:     if (line->IsBlock()) {
    1:       nsIFrame *kid = line->mFirstChild;
    1:       nscoord kidBaseline;
    1:       if (GetLastLineBaseline(kid, &kidBaseline)) {
    1:         *aResult = kidBaseline + kid->GetPosition().y;
    1:         return PR_TRUE;
    1:       } else if (kid->GetType() == nsGkAtoms::scrollFrame) {
    1:         // Use the bottom of the scroll frame.
    1:         // XXX CSS2.1 really doesn't say what to do here.
    1:         *aResult = kid->GetRect().YMost();
    1:         return PR_TRUE;
    1:       }
    1:     } else {
    1:       // XXX Is this the right test?  We have some bogus empty lines
    1:       // floating around, but IsEmpty is perhaps too weak.
    1:       if (line->GetHeight() != 0 || !line->IsEmpty()) {
    1:         *aResult = line->mBounds.y + line->GetAscent();
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
14460: static nscoord
14460: CalculateBlockContentBottom(nsBlockFrame* aFrame)
14460: {
14460:   NS_PRECONDITION(aFrame, "null ptr");
14460: 
14460:   nscoord contentBottom = 0;
14460: 
14460:   for (nsBlockFrame::line_iterator line = aFrame->begin_lines(),
14460:                                    line_end = aFrame->end_lines();
14460:        line != line_end; ++line) {
14460:     if (line->IsBlock()) {
14460:       nsIFrame* child = line->mFirstChild;
14460:       nscoord offset = child->GetRect().y - child->GetRelativeOffset().y;
14460:       contentBottom = PR_MAX(contentBottom,
14460:                         nsLayoutUtils::CalculateContentBottom(child) + offset);
14460:     }
14460:     else {
14460:       contentBottom = PR_MAX(contentBottom, line->mBounds.YMost());
14460:     }
14460:   }
14460:   return contentBottom;
14460: }
14460: 
14460: /* static */ nscoord
14460: nsLayoutUtils::CalculateContentBottom(nsIFrame* aFrame)
14460: {
14460:   NS_PRECONDITION(aFrame, "null ptr");
14460: 
14460:   nscoord contentBottom = aFrame->GetRect().height;
14460: 
14460:   if (aFrame->GetOverflowRect().height > contentBottom) {
14460:     nsBlockFrame* blockFrame = GetAsBlock(aFrame);
14460:     nsIAtom* childList = nsnull;
14460:     PRIntn nextListID = 0;
14460:     do {
14460:       if (childList == nsnull && blockFrame) {
14460:         contentBottom = PR_MAX(contentBottom, CalculateBlockContentBottom(blockFrame));
14460:       }
14460:       else if (childList != nsGkAtoms::overflowList &&
14460:                childList != nsGkAtoms::excessOverflowContainersList &&
14460:                childList != nsGkAtoms::overflowOutOfFlowList)
14460:       {
14460:         for (nsIFrame* child = aFrame->GetFirstChild(childList);
14460:             child; child = child->GetNextSibling())
14460:         {
14460:           nscoord offset = child->GetRect().y - child->GetRelativeOffset().y;
14460:           contentBottom = PR_MAX(contentBottom,
14460:                                  CalculateContentBottom(child) + offset);
14460:         }
14460:       }
14460: 
14460:       childList = aFrame->GetAdditionalChildListName(nextListID);
14460:       nextListID++;
14460:     } while (childList);
14460:   }
14460: 
14460:   return contentBottom;
14460: }
14460: 
    1: /* static */ nsIFrame*
    1: nsLayoutUtils::GetClosestLayer(nsIFrame* aFrame)
    1: {
    1:   nsIFrame* layer;
    1:   for (layer = aFrame; layer; layer = layer->GetParent()) {
    1:     if (layer->GetStyleDisplay()->IsPositioned() ||
    1:         (layer->GetParent() &&
    1:           layer->GetParent()->GetType() == nsGkAtoms::scrollFrame))
    1:       break;
    1:   }
    1:   if (layer)
    1:     return layer;
  238:   return aFrame->PresContext()->PresShell()->FrameManager()->GetRootFrame();
    1: }
    1: 
21752: /**
21752:  * Given an image being drawn into an appunit coordinate system, and
21752:  * a point in that coordinate system, map the point back into image
21752:  * pixel space.
21752:  * @param aSize the size of the image, in pixels
21752:  * @param aDest the rectangle that the image is being mapped into
21752:  * @param aPt a point in the same coordinate system as the rectangle
21752:  */
21323: static gfxPoint
22196: MapToFloatImagePixels(const gfxSize& aSize,
22196:                       const gfxRect& aDest, const gfxPoint& aPt)
21323: {
22196:   return gfxPoint(((aPt.x - aDest.pos.x)*aSize.width)/aDest.size.width,
22196:                   ((aPt.y - aDest.pos.y)*aSize.height)/aDest.size.height);
21323: }
21323: 
21752: /**
21752:  * Given an image being drawn into an pixel-based coordinate system, and
21752:  * a point in image space, map the point into the pixel-based coordinate
21752:  * system.
21752:  * @param aSize the size of the image, in pixels
21752:  * @param aDest the rectangle that the image is being mapped into
21752:  * @param aPt a point in image space
21752:  */
21752: static gfxPoint
22196: MapToFloatUserPixels(const gfxSize& aSize,
21752:                      const gfxRect& aDest, const gfxPoint& aPt)
21752: {
21752:   return gfxPoint(aPt.x*aDest.size.width/aSize.width + aDest.pos.x,
21752:                   aPt.y*aDest.size.height/aSize.height + aDest.pos.y);
21752: }
21752: 
24452: static nsresult
24452: DrawImageInternal(nsIRenderingContext* aRenderingContext,
24452:                   nsIImage*            aImage,
21323:                   const nsRect&        aDest,
21323:                   const nsRect&        aFill,
21323:                   const nsPoint&       aAnchor,
24452:                   const nsRect&        aDirty,
24452:                   const nsIntSize&     aImageSize,
24452:                   const nsIntRect&     aInnerRect)
    1: {
21402:   if (aDest.IsEmpty() || aFill.IsEmpty())
    1:     return NS_OK;
24452:   if (aImageSize.width == 0 || aImageSize.height == 0)
24452:     return NS_OK;
    1: 
21323:   nsCOMPtr<nsIDeviceContext> dc;
21323:   aRenderingContext->GetDeviceContext(*getter_AddRefs(dc));
21323:   gfxFloat appUnitsPerDevPixel = dc->AppUnitsPerDevPixel();
21323:   gfxContext *ctx = aRenderingContext->ThebesContext();
21323: 
22196:   gfxRect devPixelDest(aDest.x/appUnitsPerDevPixel,
22196:                        aDest.y/appUnitsPerDevPixel,
22196:                        aDest.width/appUnitsPerDevPixel,
22196:                        aDest.height/appUnitsPerDevPixel);
22196: 
21323:   // Compute the pixel-snapped area that should be drawn
21402:   gfxRect devPixelFill(aFill.x/appUnitsPerDevPixel,
21323:                        aFill.y/appUnitsPerDevPixel,
21323:                        aFill.width/appUnitsPerDevPixel,
21323:                        aFill.height/appUnitsPerDevPixel);
21323:   PRBool ignoreScale = PR_FALSE;
21323: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
21323:   ignoreScale = PR_TRUE;
21323: #endif
21402:   gfxRect fill = devPixelFill;
21323:   PRBool didSnap = ctx->UserToDevicePixelSnapped(fill, ignoreScale);
21323: 
21323:   // Compute dirty rect in gfx space
21323:   gfxRect dirty(aDirty.x/appUnitsPerDevPixel,
21323:                 aDirty.y/appUnitsPerDevPixel,
21323:                 aDirty.width/appUnitsPerDevPixel,
21323:                 aDirty.height/appUnitsPerDevPixel);
21323: 
24452:   gfxSize imageSize(aImageSize.width, aImageSize.height);
21323: 
21323:   // Compute the set of pixels that would be sampled by an ideal rendering
21323:   gfxPoint subimageTopLeft =
22201:     MapToFloatImagePixels(imageSize, devPixelDest, devPixelFill.TopLeft());
21323:   gfxPoint subimageBottomRight =
22201:     MapToFloatImagePixels(imageSize, devPixelDest, devPixelFill.BottomRight());
21323:   nsIntRect intSubimage;
21323:   intSubimage.MoveTo(NSToIntFloor(subimageTopLeft.x),
21323:                      NSToIntFloor(subimageTopLeft.y));
21323:   intSubimage.SizeTo(NSToIntCeil(subimageBottomRight.x) - intSubimage.x,
21323:                      NSToIntCeil(subimageBottomRight.y) - intSubimage.y);
21323: 
21323:   // Compute the anchor point and compute final fill rect.
21323:   // This code assumes that pixel-based devices have one pixel per
21323:   // device unit!
21323:   gfxPoint anchorPoint(aAnchor.x/appUnitsPerDevPixel,
21323:                        aAnchor.y/appUnitsPerDevPixel);
21752:   gfxPoint imageSpaceAnchorPoint =
22201:     MapToFloatImagePixels(imageSize, devPixelDest, anchorPoint);
22177:   gfxContextMatrixAutoSaveRestore saveMatrix(ctx);
22177: 
21323:   if (didSnap) {
22177:     NS_ASSERTION(!saveMatrix.Matrix().HasNonAxisAlignedTransform(),
21402:                  "How did we snap, then?");
21752:     imageSpaceAnchorPoint.Round();
21752:     anchorPoint = imageSpaceAnchorPoint;
21752:     anchorPoint = MapToFloatUserPixels(imageSize, devPixelDest, anchorPoint);
22177:     anchorPoint = saveMatrix.Matrix().Transform(anchorPoint);
21747:     anchorPoint.Round();
21323: 
21323:     // This form of Transform is safe to call since non-axis-aligned
21323:     // transforms wouldn't be snapped.
22177:     dirty = saveMatrix.Matrix().Transform(dirty);
21323: 
21323:     ctx->IdentityMatrix();
    1:   }
21323: 
21323:   gfxFloat scaleX = imageSize.width*appUnitsPerDevPixel/aDest.width;
21323:   gfxFloat scaleY = imageSize.height*appUnitsPerDevPixel/aDest.height;
21323:   if (didSnap) {
21323:     // ctx now has the identity matrix, so we need to adjust our
21323:     // scales to match
22177:     scaleX /= saveMatrix.Matrix().xx;
22177:     scaleY /= saveMatrix.Matrix().yy;
    1:   }
21323:   gfxFloat translateX = imageSpaceAnchorPoint.x - anchorPoint.x*scaleX;
21323:   gfxFloat translateY = imageSpaceAnchorPoint.y - anchorPoint.y*scaleY;
21323:   gfxMatrix transform(scaleX, 0, 0, scaleY, translateX, translateY);
21323: 
22177:   gfxRect finalFillRect = fill;
22177:   // If the user-space-to-image-space transform is not a straight
22177:   // translation by integers, then filtering will occur, and
22177:   // restricting the fill rect to the dirty rect would change the values
22177:   // computed for edge pixels, which we can't allow.
22177:   // Also, if didSnap is false then rounding out 'dirty' might not
22177:   // produce pixel-aligned coordinates, which would also break the values
22177:   // computed for edge pixels.
22177:   if (didSnap && !transform.HasNonIntegerTranslation()) {
22177:     dirty.RoundOut();
22177:     finalFillRect = fill.Intersect(dirty);
22177:   }
22177:   if (finalFillRect.IsEmpty())
22177:     return NS_OK;
22177: 
24452:   nsIntMargin padding(aInnerRect.x, aInnerRect.y,
24452:                       imageSize.width - aInnerRect.XMost(),
24452:                       imageSize.height - aInnerRect.YMost());
24452:   aImage->Draw(ctx, transform, finalFillRect, padding, intSubimage);
24452:   return NS_OK;
24452: }
24452: 
24452: /* Workhorse for DrawSingleUnscaledImage.  */
24452: static nsresult
24452: DrawSingleUnscaledImageInternal(nsIRenderingContext* aRenderingContext,
24452:                                 nsIImage*            aImage,
24452:                                 const nsPoint&       aDest,
24452:                                 const nsRect&        aDirty,
24452:                                 const nsRect*        aSourceArea,
24452:                                 const nsIntSize&     aImageSize,
24452:                                 const nsIntRect&     aInnerRect)
24452: {
24452:   if (aImageSize.width == 0 || aImageSize.height == 0)
24452:     return NS_OK;
24452: 
24452:   nscoord appUnitsPerCSSPixel = nsIDeviceContext::AppUnitsPerCSSPixel();
24452:   nsSize size(aImageSize.width*appUnitsPerCSSPixel,
24452:               aImageSize.height*appUnitsPerCSSPixel);
24452: 
24452:   nsRect source;
24452:   if (aSourceArea) {
24452:     source = *aSourceArea;
24452:   } else {
24452:     source.SizeTo(size);
24452:   }
24452: 
24452:   nsRect dest(aDest - source.TopLeft(), size);
24452:   nsRect fill(aDest, source.Size());
24452:   // Ensure that only a single image tile is drawn. If aSourceArea extends
24452:   // outside the image bounds, we want to honor the aSourceArea-to-aDest
24452:   // translation but we don't want to actually tile the image.
24452:   fill.IntersectRect(fill, dest);
24452:   return DrawImageInternal(aRenderingContext, aImage, dest, fill,
24452:                            aDest, aDirty, aImageSize, aInnerRect);
24452: }
24452: 
24452: /* Workhorse for DrawSingleImage.  */
24452: static nsresult
24452: DrawSingleImageInternal(nsIRenderingContext* aRenderingContext,
24452:                         nsIImage*            aImage,
24452:                         const nsRect&        aDest,
24452:                         const nsRect&        aDirty,
24452:                         const nsRect*        aSourceArea,
24452:                         const nsIntSize&     aImageSize,
24452:                         const nsIntRect&     aInnerRect)
24452: {
24452:   if (aImageSize.width == 0 || aImageSize.height == 0)
24452:     return NS_OK;
24452: 
24452:   nsRect source;
24452:   if (aSourceArea) {
24452:     source = *aSourceArea;
24452:   } else {
24452:     nscoord appUnitsPerCSSPixel = nsIDeviceContext::AppUnitsPerCSSPixel();
24452:     source.SizeTo(aImageSize.width*appUnitsPerCSSPixel,
24452:                   aImageSize.height*appUnitsPerCSSPixel);
24452:   }
24452: 
24452:   nsRect dest = nsLayoutUtils::GetWholeImageDestination(aImageSize, source,
24452:                                                         aDest);
24452:   // Ensure that only a single image tile is drawn. If aSourceArea extends
24452:   // outside the image bounds, we want to honor the aSourceArea-to-aDest
24452:   // transform but we don't want to actually tile the image.
24452:   nsRect fill;
24452:   fill.IntersectRect(aDest, dest);
24452:   return DrawImageInternal(aRenderingContext, aImage, dest, fill,
24452:                            fill.TopLeft(), aDirty, aImageSize, aInnerRect);
24452: }
24452: 
24452: /* The exposed Draw*Image functions just do interface conversion and call the
24452:    appropriate Draw*ImageInternal workhorse.  */
24452: 
24452: /* static */ nsresult
24452: nsLayoutUtils::DrawImage(nsIRenderingContext* aRenderingContext,
24452:                          imgIContainer*       aImage,
24452:                          const nsRect&        aDest,
24452:                          const nsRect&        aFill,
24452:                          const nsPoint&       aAnchor,
24452:                          const nsRect&        aDirty)
24452: {
24452:   nsCOMPtr<gfxIImageFrame> imgFrame;
24452:   aImage->GetCurrentFrame(getter_AddRefs(imgFrame));
24452:   if (!imgFrame) return NS_ERROR_FAILURE;
24452: 
24452:   nsCOMPtr<nsIImage> img(do_GetInterface(imgFrame));
24452:   if (!img) return NS_ERROR_FAILURE;
24452: 
21323:   nsIntRect innerRect;
21323:   imgFrame->GetRect(innerRect);
24452: 
24452:   nsIntSize imageSize;
24452:   aImage->GetWidth(&imageSize.width);
24452:   aImage->GetHeight(&imageSize.height);
24452: 
24452:   return DrawImageInternal(aRenderingContext, img,
24452:                            aDest, aFill, aAnchor, aDirty,
24452:                            imageSize, innerRect);
24452: }
24452: 
24452: /* static */ nsresult
24452: nsLayoutUtils::DrawImage(nsIRenderingContext* aRenderingContext,
24452:                          nsIImage*            aImage,
24452:                          const nsRect&        aDest,
24452:                          const nsRect&        aFill,
24452:                          const nsPoint&       aAnchor,
24452:                          const nsRect&        aDirty)
24452: {
24452:   nsIntSize imageSize(aImage->GetWidth(), aImage->GetHeight());
24452:   return DrawImageInternal(aRenderingContext, aImage,
24452:                            aDest, aFill, aAnchor, aDirty,
24452:                            imageSize, nsIntRect(nsIntPoint(0,0), imageSize));
    1: }
    1: 
21323: /* static */ nsresult
21323: nsLayoutUtils::DrawSingleUnscaledImage(nsIRenderingContext* aRenderingContext,
21323:                                        imgIContainer*       aImage,
21323:                                        const nsPoint&       aDest,
21323:                                        const nsRect&        aDirty,
21323:                                        const nsRect*        aSourceArea)
21323: {
24452:   nsCOMPtr<gfxIImageFrame> imgFrame;
24452:   aImage->GetCurrentFrame(getter_AddRefs(imgFrame));
24452:   if (!imgFrame) return NS_ERROR_FAILURE;
24452:  
24452:   nsCOMPtr<nsIImage> img(do_GetInterface(imgFrame));
24452:   if (!img) return NS_ERROR_FAILURE;
24452:  
24452:   nsIntRect innerRect;
24452:   imgFrame->GetRect(innerRect);
24452: 
24452:   nsIntSize imageSize;
24452:   aImage->GetWidth(&imageSize.width);
24452:   aImage->GetHeight(&imageSize.height);
24452: 
24452:   return DrawSingleUnscaledImageInternal(aRenderingContext, img,
24452:                                          aDest, aDirty, aSourceArea,
24452:                                          imageSize, innerRect);
21323: }
21323:  
21323: /* static */ nsresult
21323: nsLayoutUtils::DrawSingleImage(nsIRenderingContext* aRenderingContext,
21323:                                imgIContainer*       aImage,
21323:                                const nsRect&        aDest,
21323:                                const nsRect&        aDirty,
21323:                                const nsRect*        aSourceArea)
21323: {
24452:   nsCOMPtr<gfxIImageFrame> imgFrame;
24452:   aImage->GetCurrentFrame(getter_AddRefs(imgFrame));
24452:   if (!imgFrame) return NS_ERROR_FAILURE;
24452:  
24452:   nsCOMPtr<nsIImage> img(do_GetInterface(imgFrame));
24452:   if (!img) return NS_ERROR_FAILURE;
24452:  
24452:   nsIntRect innerRect;
24452:   imgFrame->GetRect(innerRect);
24452: 
24452:   nsIntSize imageSize;
24452:   aImage->GetWidth(&imageSize.width);
24452:   aImage->GetHeight(&imageSize.height);
24452: 
24452:   return DrawSingleImageInternal(aRenderingContext, img,
24452:                                  aDest, aDirty, aSourceArea,
24452:                                  imageSize, innerRect);
    1: }
21323: 
24452: /* static */ nsresult
24452: nsLayoutUtils::DrawSingleImage(nsIRenderingContext* aRenderingContext,
24452:                                nsIImage*            aImage,
24452:                                const nsRect&        aDest,
24452:                                const nsRect&        aDirty,
24452:                                const nsRect*        aSourceArea)
24452: {
24452:   nsIntSize imageSize(aImage->GetWidth(), aImage->GetHeight());
24452:   return DrawSingleImageInternal(aRenderingContext, aImage,
24452:                                  aDest, aDirty, aSourceArea,
24452:                                  imageSize,
24452:                                  nsIntRect(nsIntPoint(0, 0), imageSize));
    1: }
21323: 
24452: 
21323: /* static */ nsRect
21323: nsLayoutUtils::GetWholeImageDestination(const nsIntSize& aWholeImageSize,
21323:                                         const nsRect& aImageSourceArea,
21323:                                         const nsRect& aDestArea)
21323: {
21323:   double scaleX = double(aDestArea.width)/aImageSourceArea.width;
21323:   double scaleY = double(aDestArea.height)/aImageSourceArea.height;
21323:   nscoord destOffsetX = NSToCoordRound(aImageSourceArea.x*scaleX);
21323:   nscoord destOffsetY = NSToCoordRound(aImageSourceArea.y*scaleY);
21323:   nscoord appUnitsPerCSSPixel = nsIDeviceContext::AppUnitsPerCSSPixel();
21323:   nscoord wholeSizeX = NSToCoordRound(aWholeImageSize.width*appUnitsPerCSSPixel*scaleX);
21323:   nscoord wholeSizeY = NSToCoordRound(aWholeImageSize.height*appUnitsPerCSSPixel*scaleY);
21323:   return nsRect(aDestArea.TopLeft() - nsPoint(destOffsetX, destOffsetY),
21323:                 nsSize(wholeSizeX, wholeSizeY));
    1: }
 1105: 
 1105: void
 1105: nsLayoutUtils::SetFontFromStyle(nsIRenderingContext* aRC, nsStyleContext* aSC) 
 1105: {
 1105:   const nsStyleFont* font = aSC->GetStyleFont();
 1105:   const nsStyleVisibility* visibility = aSC->GetStyleVisibility();
 1105: 
22335:   aRC->SetFont(font->mFont, visibility->mLangGroup,
22335:                aSC->PresContext()->GetUserFontSet());
 1105: }
 1105: 
 1345: static PRBool NonZeroStyleCoord(const nsStyleCoord& aCoord)
 1345: {
 1345:   switch (aCoord.GetUnit()) {
 1345:   case eStyleUnit_Percent:
 1345:     return aCoord.GetPercentValue() > 0;
 1345:   case eStyleUnit_Coord:
 1345:     return aCoord.GetCoordValue() > 0;
 1345:   default:
 1345:     return PR_TRUE;
 1345:   }
 1345: }
 1345: 
 1345: /* static */ PRBool
20039: nsLayoutUtils::HasNonZeroCorner(const nsStyleCorners& aCorners)
 1345: {
20039:   NS_FOR_CSS_HALF_CORNERS(corner) {
20039:     if (NonZeroStyleCoord(aCorners.Get(corner)))
20039:       return PR_TRUE;
20039:   }
20039:   return PR_FALSE;
 1345: }
 1345: 
16601: /* static */ nsTransparencyMode
16601: nsLayoutUtils::GetFrameTransparency(nsIFrame* aFrame) {
 1345:   if (aFrame->GetStyleContext()->GetStyleDisplay()->mOpacity < 1.0f)
16601:     return eTransparencyTransparent;
 1345: 
20039:   if (HasNonZeroCorner(aFrame->GetStyleContext()->GetStyleBorder()->mBorderRadius))
16601:     return eTransparencyTransparent;
 1345: 
22675:   nsTransparencyMode transparency;
22675:   if (aFrame->IsThemed(&transparency))
22675:     return transparency;
 1345: 
16601:   if (aFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_GLASS)
16601:     return eTransparencyGlass;
24645: 
24645:   // We need an uninitialized window to be treated as opaque because
24645:   // doing otherwise breaks window display effects on some platforms,
24645:   // specifically Vista. (bug 450322)
24645:   if (aFrame->GetType() == nsGkAtoms::viewportFrame &&
24645:       !aFrame->GetFirstChild(nsnull)) {
24645:     return eTransparencyOpaque;
24645:   }
24645: 
 1345:   const nsStyleBackground* bg;
25022:   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bg))
16601:     return eTransparencyTransparent;
25276:   if (NS_GET_A(bg->mBackgroundColor) < 255 ||
25276:       NS_GET_A(bg->mFallbackBackgroundColor) < 255 ||
25276:       // bottom layer's clip is used for the color
25276:       bg->BottomLayer().mClip != NS_STYLE_BG_CLIP_BORDER)
16601:     return eTransparencyTransparent;
16601:   return eTransparencyOpaque;
 1345: }
 4032: 
 4032: static PRBool
 4032: IsNonzeroCoord(const nsStyleCoord& aCoord)
 4032: {
 4032:   if (eStyleUnit_Coord == aCoord.GetUnit())
 4032:     return aCoord.GetCoordValue() != 0;
 4032:   return PR_FALSE;
 4032: }
 4032: 
 4032: /* static */ PRUint32
 4032: nsLayoutUtils::GetTextRunFlagsForStyle(nsStyleContext* aStyleContext,
 4032:                                        const nsStyleText* aStyleText,
 4032:                                        const nsStyleFont* aStyleFont)
 4032: {
 4032:   PRUint32 result = 0;
 4032:   if (IsNonzeroCoord(aStyleText->mLetterSpacing)) {
 4032:     result |= gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES;
 4032:   }
 4032: #ifdef MOZ_SVG
 4032:   switch (aStyleContext->GetStyleSVG()->mTextRendering) {
 4032:   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
 4032:     result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032:     break;
 4032:   case NS_STYLE_TEXT_RENDERING_AUTO:
 4032:     if (aStyleFont->mFont.size <
 4032:         aStyleContext->PresContext()->GetAutoQualityMinFontSize()) {
 4032:       result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032:     }
 4032:     break;
 4032:   default:
 4032:     break;
 4032:   }
 4032: #endif
 4032:   return result;
 4032: }
11384: 
11384: /* static */ void
11384: nsLayoutUtils::GetRectDifferenceStrips(const nsRect& aR1, const nsRect& aR2,
11384:                                        nsRect* aHStrip, nsRect* aVStrip) {
11384:   NS_ASSERTION(aR1.TopLeft() == aR2.TopLeft(),
11384:                "expected rects at the same position");
11384:   nsRect unionRect(aR1.x, aR1.y, PR_MAX(aR1.width, aR2.width),
11384:                    PR_MAX(aR1.height, aR2.height));
11384:   nscoord VStripStart = PR_MIN(aR1.width, aR2.width);
11384:   nscoord HStripStart = PR_MIN(aR1.height, aR2.height);
11384:   *aVStrip = unionRect;
11384:   aVStrip->x += VStripStart;
11384:   aVStrip->width -= VStripStart;
11384:   *aHStrip = unionRect;
11384:   aHStrip->y += HStripStart;
11384:   aHStrip->height -= HStripStart;
11384: }
11384: 
16228: nsIDeviceContext*
16228: nsLayoutUtils::GetDeviceContextForScreenInfo(nsIDocShell* aDocShell)
16228: {
16228:   nsCOMPtr<nsIDocShell> docShell = aDocShell;
16228:   while (docShell) {
16228:     // Now make sure our size is up to date.  That will mean that the device
16228:     // context does the right thing on multi-monitor systems when we return it to
16228:     // the caller.  It will also make sure that our prescontext has been created,
16228:     // if we're supposed to have one.
16228:     nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(docShell);
16228:     if (!win) {
16228:       // No reason to go on
16228:       return nsnull;
16228:     }
16228: 
16228:     win->EnsureSizeUpToDate();
16228: 
16228:     nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(docShell);
16228:     NS_ENSURE_TRUE(baseWindow, nsnull);
16228: 
16228:     nsCOMPtr<nsIWidget> mainWidget;
16228:     baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
16228:     if (mainWidget) {
16228:       return mainWidget->GetDeviceContext();
16228:     }
16228: 
16228:     nsCOMPtr<nsIDocShellTreeItem> curItem = do_QueryInterface(docShell);
16228:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
16228:     curItem->GetParent(getter_AddRefs(parentItem));
16228:     docShell = do_QueryInterface(parentItem);
16228:   }
16228: 
16228:   return nsnull;
16228: }
16228: 
21903: /* static */ PRBool
21903: nsLayoutUtils::IsReallyFixedPos(nsIFrame* aFrame)
21903: {
21903:   NS_PRECONDITION(aFrame->GetParent(),
21903:                   "IsReallyFixedPos called on frame not in tree");
21903:   NS_PRECONDITION(aFrame->GetStyleDisplay()->mPosition ==
21903:                     NS_STYLE_POSITION_FIXED,
21903:                   "IsReallyFixedPos called on non-'position:fixed' frame");
21903: 
23170:   nsIAtom *parentType = aFrame->GetParent()->GetType();
23170:   return parentType == nsGkAtoms::viewportFrame ||
23170:          parentType == nsGkAtoms::pageContentFrame;
21903: }
21903: 
25840: static void DeleteTextFragment(void* aObject, nsIAtom* aPropertyName,
25840:                                void* aPropertyValue, void* aData)
25840: {
25840:   delete static_cast<nsTextFragment*>(aPropertyValue);
25840: }
25840: 
26295: /* static */ nsTextFragment*
26295: nsLayoutUtils::GetTextFragmentForPrinting(const nsIFrame* aFrame)
25840: {
26295:   nsPresContext* presContext = aFrame->PresContext();
26295:   NS_PRECONDITION(!presContext->IsDynamic(),
26295:                   "Shouldn't call this with dynamic PresContext");
25965: #ifdef MOZ_SVG
25964:   NS_PRECONDITION(aFrame->GetType() == nsGkAtoms::textFrame ||
25964:                   aFrame->GetType() == nsGkAtoms::svgGlyphFrame,
25840:                   "Wrong frame type!");
25965: #else
25965:   NS_PRECONDITION(aFrame->GetType() == nsGkAtoms::textFrame,
25965:                   "Wrong frame type!");
25965: #endif // MOZ_SVG
25840: 
26295:   nsIContent* content = aFrame->GetContent();
26295:   nsTextFragment* frag =
26295:     static_cast<nsTextFragment*>(presContext->PropertyTable()->
26295:       GetProperty(content, nsGkAtoms::clonedTextForPrint));
26295: 
26295:   if (!frag) {
26295:     frag = new nsTextFragment();
26295:     NS_ENSURE_TRUE(frag, nsnull);
26295:     *frag = *content->GetText();
25840:     nsresult rv = presContext->PropertyTable()->
26295:                     SetProperty(content, nsGkAtoms::clonedTextForPrint, frag,
25840:                                 DeleteTextFragment, nsnull);
25840:     if (NS_FAILED(rv)) {
25840:       delete frag;
26295:       return nsnull;
26295:     }
26295:   }
26295: 
26295:   return frag;
25840: }
25840: 
14319: nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
14319:                                      const nsAString& aValue)
14319:   : mContent(aContent),
14319:     mAttrName(aAttrName),
14319:     mValue(aValue)
14319: {
14319:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
14319: }
14319: 
14319: NS_IMETHODIMP
14319: nsSetAttrRunnable::Run()
14319: {
14319:   return mContent->SetAttr(kNameSpaceID_None, mAttrName, mValue, PR_TRUE);
14319: }
14319: 
14319: nsUnsetAttrRunnable::nsUnsetAttrRunnable(nsIContent* aContent,
14319:                                          nsIAtom* aAttrName)
14319:   : mContent(aContent),
14319:     mAttrName(aAttrName)
14319: {
14319:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
14319: }
14319: 
14319: NS_IMETHODIMP
14319: nsUnsetAttrRunnable::Run()
14319: {
14319:   return mContent->UnsetAttr(kNameSpaceID_None, mAttrName, PR_TRUE);
14319: }
23933: 
23933: nsReflowFrameRunnable::nsReflowFrameRunnable(nsIFrame* aFrame,
23933:                           nsIPresShell::IntrinsicDirty aIntrinsicDirty,
23933:                           nsFrameState aBitToAdd)
23933:   : mWeakFrame(aFrame),
23933:     mIntrinsicDirty(aIntrinsicDirty),
23933:     mBitToAdd(aBitToAdd)
23933: {
23933: }
23933: 
23933: NS_IMETHODIMP
23933: nsReflowFrameRunnable::Run()
23933: {
23933:   if (mWeakFrame.IsAlive()) {
23933:     mWeakFrame->PresContext()->PresShell()->
23933:       FrameNeedsReflow(mWeakFrame, mIntrinsicDirty, mBitToAdd);
23933:   }
23933:   return NS_OK;
23933: }
