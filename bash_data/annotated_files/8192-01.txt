   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Dave Hyatt <hyatt@mozilla.org> (Original Author)
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsTreeColFrame.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsIContent.h"
   1: #include "nsStyleContext.h"
   1: #include "nsINameSpaceManager.h" 
   1: #include "nsIDOMNSDocument.h"
   1: #include "nsIDocument.h"
   1: #include "nsIBoxObject.h"
8192: #include "nsTreeBoxObject.h"
   1: #include "nsIDOMElement.h"
   1: #include "nsITreeBoxObject.h"
   1: #include "nsITreeColumns.h"
   1: #include "nsIDOMXULTreeElement.h"
   1: #include "nsDisplayList.h"
   1: 
   1: //
   1: // NS_NewTreeColFrame
   1: //
   1: // Creates a new col frame
   1: //
   1: nsIFrame*
   1: NS_NewTreeColFrame(nsIPresShell* aPresShell, nsStyleContext* aContext,
   1:                    PRBool aIsRoot, nsIBoxLayout* aLayoutManager)
   1: {
   1:   return new (aPresShell) nsTreeColFrame(aPresShell, aContext, aIsRoot, aLayoutManager);
   1: } // NS_NewTreeColFrame
   1: 
   1: NS_IMETHODIMP_(nsrefcnt) 
   1: nsTreeColFrame::AddRef(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP_(nsrefcnt)
   1: nsTreeColFrame::Release(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: //
   1: // QueryInterface
   1: //
   1: NS_INTERFACE_MAP_BEGIN(nsTreeColFrame)
   1: NS_INTERFACE_MAP_END_INHERITING(nsBoxFrame)
   1: 
   1: // Destructor
   1: nsTreeColFrame::~nsTreeColFrame()
   1: {
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeColFrame::Init(nsIContent*      aContent,
   1:                      nsIFrame*        aParent,
   1:                      nsIFrame*        aPrevInFlow)
   1: {
   1:   nsresult rv = nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
   1:   InvalidateColumns();
   1:   return rv;
   1: }
   1: 
   1: void                                                                
   1: nsTreeColFrame::Destroy()                          
   1: {
8192:   InvalidateColumns(PR_FALSE);
   1:   nsBoxFrame::Destroy();
   1: }
   1: 
   1: class nsDisplayXULTreeColSplitterTarget : public nsDisplayItem {
   1: public:
   1:   nsDisplayXULTreeColSplitterTarget(nsIFrame* aFrame) : nsDisplayItem(aFrame) {
   1:     MOZ_COUNT_CTOR(nsDisplayXULTreeColSplitterTarget);
   1:   }
   1: #ifdef NS_BUILD_REFCNT_LOGGING
   1:   virtual ~nsDisplayXULTreeColSplitterTarget() {
   1:     MOZ_COUNT_DTOR(nsDisplayXULTreeColSplitterTarget);
   1:   }
   1: #endif
   1: 
   1:   virtual nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt);
   1:   NS_DISPLAY_DECL_NAME("XULTreeColSplitterTarget")
   1: };
   1: 
   1: nsIFrame* 
   1: nsDisplayXULTreeColSplitterTarget::HitTest(nsDisplayListBuilder* aBuilder,
   1:                                            nsPoint aPt)
   1: {
   1:   nsPoint pt = aPt - aBuilder->ToReferenceFrame(mFrame);
4665:   // If we are in either the first 4 pixels or the last 4 pixels, we're going to
   1:   // do something really strange.  Check for an adjacent splitter.
   1:   PRBool left = PR_FALSE;
   1:   PRBool right = PR_FALSE;
4665:   if (mFrame->GetSize().width - nsPresContext::CSSPixelsToAppUnits(4) <= pt.x)
   1:     right = PR_TRUE;
4665:   else if (nsPresContext::CSSPixelsToAppUnits(4) > pt.x)
   1:     left = PR_TRUE;
   1: 
   1:   if (left || right) {
   1:     // We are a header. Look for the correct splitter.
   1:     nsFrameList frames(mFrame->GetParent()->GetFirstChild(nsnull));
   1:     nsIFrame* child;
   1:     if (left)
   1:       child = frames.GetPrevSiblingFor(mFrame);
   1:     else
   1:       child = mFrame->GetNextSibling();
   1: 
   1:     if (child && child->GetContent()->NodeInfo()->Equals(nsGkAtoms::splitter,
   1:                                                          kNameSpaceID_XUL)) {
   1:       return child;
   1:     }
   1:   }
   1:   
   1:   return nsnull;
   1: }
   1: 
   1: nsresult
   1: nsTreeColFrame::BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
   1:                                             const nsRect&           aDirtyRect,
   1:                                             const nsDisplayListSet& aLists)
   1: {
   1:   if (!aBuilder->IsForEventDelivery())
   1:     return nsBoxFrame::BuildDisplayListForChildren(aBuilder, aDirtyRect, aLists);
   1:   
   1:   nsDisplayListCollection set;
   1:   nsresult rv = nsBoxFrame::BuildDisplayListForChildren(aBuilder, aDirtyRect, set);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   rv = WrapListsInRedirector(aBuilder, set, aLists);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return aLists.Content()->AppendNewToTop(new (aBuilder)
   1:       nsDisplayXULTreeColSplitterTarget(this));
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeColFrame::AttributeChanged(PRInt32 aNameSpaceID,
   1:                                  nsIAtom* aAttribute,
   1:                                  PRInt32 aModType)
   1: {
   1:   nsresult rv = nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute,
   1:                                              aModType);
   1: 
   1:   if (aAttribute == nsGkAtoms::ordinal || aAttribute == nsGkAtoms::primary) {
   1:     InvalidateColumns();
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsTreeColFrame::SetBounds(nsBoxLayoutState& aBoxLayoutState,
   1:                           const nsRect& aRect,
   1:                           PRBool aRemoveOverflowArea) {
   1:   nscoord oldWidth = mRect.width;
   1: 
   1:   nsBoxFrame::SetBounds(aBoxLayoutState, aRect, aRemoveOverflowArea);
   1:   if (mRect.width != oldWidth) {
   1:     nsITreeBoxObject* treeBoxObject = GetTreeBoxObject();
   1:     if (treeBoxObject) {
   1:       treeBoxObject->Invalidate();
   1:     }
   1:   }
   1: }
   1: 
   1: nsITreeBoxObject*
   1: nsTreeColFrame::GetTreeBoxObject()
   1: {
   1:   nsITreeBoxObject* result = nsnull;
   1: 
   1:   nsIContent* parent = mContent->GetParent();
   1:   if (parent) {
   1:     nsIContent* grandParent = parent->GetParent();
   1:     nsCOMPtr<nsIDOMXULElement> treeElement = do_QueryInterface(grandParent);
   1:     if (treeElement) {
   1:       nsCOMPtr<nsIBoxObject> boxObject;
   1:       treeElement->GetBoxObject(getter_AddRefs(boxObject));
   1: 
   1:       nsCOMPtr<nsITreeBoxObject> treeBoxObject = do_QueryInterface(boxObject);
   1:       result = treeBoxObject.get();
   1:     }
   1:   }
   1:   return result;
   1: }
   1: 
   1: void
8192: nsTreeColFrame::InvalidateColumns(PRBool aCanWalkFrameTree)
   1: {
   1:   nsITreeBoxObject* treeBoxObject = GetTreeBoxObject();
   1:   if (treeBoxObject) {
   1:     nsCOMPtr<nsITreeColumns> columns;
8192: 
8192:     if (aCanWalkFrameTree) {
   1:       treeBoxObject->GetColumns(getter_AddRefs(columns));
8192:     } else {
8192:       nsITreeBoxObject* body =
8192:         static_cast<nsTreeBoxObject*>(treeBoxObject)->GetCachedTreeBody();
8192:       if (body) {
8192:         body->GetColumns(getter_AddRefs(columns));
8192:       }
8192:     }
   1: 
   1:     if (columns)
   1:       columns->InvalidateColumns();
   1:   }
   1: }
