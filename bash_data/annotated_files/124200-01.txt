118737: /* This Source Code Form is subject to the terms of the Mozilla Public
118737:  * License, v. 2.0. If a copy of the MPL was not distributed with this
118737:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
116419: 
116419: #include "CC_Common.h"
116419: 
116419: #include "CSFLogStream.h"
116419: 
116419: #include "CSFMediaProvider.h"
116419: #include "CSFAudioTermination.h"
116419: #include "CSFVideoTermination.h"
116420: #include "MediaConduitErrors.h"
116420: #include "MediaConduitInterface.h"
116420: #include "MediaPipeline.h"
116419: #include "VcmSIPCCBinding.h"
116419: #include "csf_common.h"
116420: #include "PeerConnectionImpl.h"
116420: #include "nsThreadUtils.h"
116420: #include "transportflow.h"
116420: #include "transportlayer.h"
116420: #include "transportlayerdtls.h"
116420: #include "transportlayerice.h"
116420: #include "runnable_utils.h"
116420: #include "cpr_stdlib.h"
116420: #include "cpr_string.h"
116419: 
116419: #include <stdlib.h>
116419: #include <stdio.h>
116420: #include <ssl.h>
116420: #include <sslproto.h>
116419: 
116419: extern "C" {
116419: #include "ccsdp.h"
116419: #include "vcm.h"
116419: #include "cip_mmgr_mediadefinitions.h"
116419: #include "cip_Sipcc_CodecMask.h"
116419: 
116419: extern void lsm_start_multipart_tone_timer (vcm_tones_t tone,
116419:                                             uint32_t delay,
116419:                                             cc_call_handle_t callId);
116419: extern void lsm_start_continuous_tone_timer (vcm_tones_t tone,
116419:                                              uint32_t delay,
116419:                                              cc_call_handle_t callId);
116419: extern void lsm_update_active_tone(vcm_tones_t tone, cc_call_handle_t call_handle);
116419: extern void lsm_stop_multipart_tone_timer(void);
116419: extern void lsm_stop_continuous_tone_timer(void);
116419: 
116419: }//end extern "C"
116419: 
116419: static const char* logTag = "VcmSipccBinding";
116419: 
116419: typedef enum {
116419:     CC_AUDIO_1,
116419:     CC_VIDEO_1
116419: } cc_media_cap_name;
116419: 
116419: #define SIPSDP_ILBC_MODE20 20
116419: 
116419: /* static */
116419: 
116419: using namespace CSF;
116419: 
116419: VcmSIPCCBinding * VcmSIPCCBinding::_pSelf = NULL;
116420: int VcmSIPCCBinding::mAudioCodecMask = 0;
116420: int VcmSIPCCBinding::mVideoCodecMask = 0;
116419: 
116420: /**
116420:  * Convert a combined payload type value to a config value
116420:  *
116420:  * @param [in] payload - the combined payload type integer
116420:  * @param [out] config - the returned config value
116420:  *
116420:  * return int
116420:  */
116420: static int vcmPayloadType2AudioCodec(vcm_media_payload_type_t payload,
116420:                                      mozilla::AudioCodecConfig **config);
116419: 
116420: static int vcmPayloadType2VideoCodec(vcm_media_payload_type_t payload,
116420:                                      mozilla::VideoCodecConfig **config);
116420: static mozilla::RefPtr<TransportFlow> vcmCreateTransportFlow(sipcc::PeerConnectionImpl *pc,
116420:                                                              int level, bool rtcp,
116420:                                                              const char *fingerprint_alg,
116420:                                                              const char *fingerprint
116420:                                                              );
116420: 
116420: VcmSIPCCBinding::VcmSIPCCBinding ()
116420:   : streamObserver(NULL)
116419: {
116419:     delete _pSelf;//delete is NULL safe, so I don't need to check if it's NULL
116419:     _pSelf = this;
116419: }
116419: 
116419: VcmSIPCCBinding::~VcmSIPCCBinding ()
116419: {
116419:     assert(_pSelf != NULL);
116419:     _pSelf = NULL;
116419: }
116419: 
116419: void VcmSIPCCBinding::setStreamObserver(StreamObserver* obs)
116419: {
116419: 	streamObserver = obs;
116419: }
116419: 
116419: /* static */
116419: StreamObserver * VcmSIPCCBinding::getStreamObserver()
116419: {
116419:     if (_pSelf != NULL)
116419:     	return _pSelf->streamObserver;
116419: 
116419:     return NULL;
116419: }
116419: 
116419: void VcmSIPCCBinding::setMediaProviderObserver(MediaProviderObserver* obs)
116419: {
116419: 	mediaProviderObserver = obs;
116419: }
116419: 
116419: 
116419: MediaProviderObserver * VcmSIPCCBinding::getMediaProviderObserver()
116419: {
116419:     if (_pSelf != NULL)
116419:     	return _pSelf->mediaProviderObserver;
116419: 
116419:     return NULL;
116419: }
116419: 
116420: void VcmSIPCCBinding::setAudioCodecs(int codecMask)
116420: {
116420:   CSFLogDebugS(logTag, "SETTING AUDIO: " << codecMask);
116420:   VcmSIPCCBinding::mAudioCodecMask = codecMask;
116420: }
116420: 
116420: void VcmSIPCCBinding::setVideoCodecs(int codecMask)
116420: {
116420:   CSFLogDebugS(logTag, "SETTING VIDEO: " << codecMask);
116420:   VcmSIPCCBinding::mVideoCodecMask = codecMask;
116420: }
116420: 
116420: int VcmSIPCCBinding::getAudioCodecs()
116420: {
116420:   return VcmSIPCCBinding::mAudioCodecMask;
116420: }
116420: 
116420: int VcmSIPCCBinding::getVideoCodecs()
116420: {
116420:   return VcmSIPCCBinding::mVideoCodecMask;
116420: }
116420: 
116419: 
116419: /* static */
116419: AudioTermination * VcmSIPCCBinding::getAudioTermination()
116419: {
116420:     // commenting as part of media provider removal
116419:     return NULL;
116419: }
116419: 
116419: /* static */
116419: VideoTermination * VcmSIPCCBinding::getVideoTermination()
116419: {
116420:     // commenting as part of media provider removal
116419:     return NULL;
116419: }
116419: 
116419: /* static */
116419: AudioControl * VcmSIPCCBinding::getAudioControl()
116419: {
116420:     // commenting as part of media provider removal
116419:     return NULL;
116419: }
116419: 
116419: /* static */
116419: VideoControl * VcmSIPCCBinding::getVideoControl()
116419: {
116420:     // commenting as part of media provider removal
116419:     return NULL;
116419: }
116419: 
116419: /*
116419:  * Used to play busy verfication tone
116419:  */
116419: #define BUSY_VERIFICATION_DELAY       (10000)
116419: 
116419: /*
116419:  * Temp until added to config
116419:  */
116419: 
116419: #define TOH_DELAY                (10000)/*
116419:  * Used to play msg waiting and stutter dialtones.
116419:  * Both tones are 100ms on/off repeating 10 and
116419:  * 3 times respectively, followed by steady dialtone.
116419:  * Due to DSP limitations we first tell the DSP to
116419:  * play the 100ms on/off pairs the correct number of
116419:  * times, set a timer, and then tell it to play dialtone.
116419:  */
116419: #define MSG_WAITING_DELAY   (2050)
116419: #define STUTTER_DELAY       (650)
116419: 
116419: /*
116419:  * Used to play the busy verfication tone which
116419:  * is two seconds of dialtone followed by the
116419:  * callwaiting tone every ten seconds.
116419:  */
116419: #define BUSY_VERIFY_DELAY   (12000)
116419: 
116419: 
116419: #define VCM_MIN_VOLUME_BYTE       0
116419: #define VCM_MAX_VOLUME_BYTE       255
116419: #define VCM_MIN_VOLUME_LEVEL      0
116419: #define VCM_MAX_VOLUME_LEVEL      240
116419: #define VCM_RNG_MAX_VOLUME_LEVEL  248
116419: #define VCM_DEFAULT_AUDIO_VOLUME  144
116419: #define VCM_DEFAULT_RINGER_VOLUME 80
116419: #define VCM_VOLUME_ADJUST_LEVEL   8
116419: 
116419: 
116419: extern "C" {
116419: 
116419: 
116419: /* MediaTermination APIs expect dynmic payload type in upper 16 bits and
116419:    codec type in lower 16 bits. */
116419: #define CREATE_MT_MAP(a,b)        ((a << 16) | b)
116419: #define DYNAMIC_PAYLOAD_TYPE(x)    ((x >> 16) & 0xFFFF)
116419: 
116419: #define    MAX_SPROP_LEN    32
116419: 
116419: #define VCM_ERROR -1
116419: 
116419: struct h264_video
116419: {
116419:     char       sprop_parameter_set[MAX_SPROP_LEN];
116419:     int        packetization_mode;
116419:     int        profile_level_id;
116419:     int        max_mbps;
116419:     int        max_fs;
116419:     int        max_cpb;
116419:     int        max_dpb;
116419:     int        max_br;
116419:     int        tias_bw;
116419: };
116419: 
116420: #if 0
116419: static RingMode
116419: map_ring_mode (vcm_ring_mode_t mode)
116419: {
116419:     switch ( mode )
116419:     {
116419:     case VCM_INSIDE_RING:
116419:         return RingMode_INSIDE_RING;
116419:     case VCM_OUTSIDE_RING:
116419:         return RingMode_OUTSIDE_RING;
116419:     case VCM_FEATURE_RING:
116419:         return RingMode_FEATURE_RING;
116419:     case VCM_BELLCORE_DR1:
116419:         return RingMode_BELLCORE_DR1;
116419:     case VCM_BELLCORE_DR2:
116419:         return RingMode_BELLCORE_DR2;
116419:     case VCM_BELLCORE_DR3:
116419:         return RingMode_BELLCORE_DR3;
116419:     case VCM_BELLCORE_DR4:
116419:         return RingMode_BELLCORE_DR4;
116419:     case VCM_BELLCORE_DR5:
116419:         return RingMode_BELLCORE_DR5;
116419:     case VCM_FLASHONLY_RING:
116419:         return RingMode_FLASHONLY_RING;
116419:     case VCM_STATION_PRECEDENCE_RING:
116419:         return RingMode_PRECEDENCE_RING;
116419:     default:
116419:         CSFLogDebugS( logTag, "map_ring_mode(): Wrong ringmode passed");
116419:         return RingMode_INSIDE_RING;
116419:     }
116419: }
116420: #endif
116419: 
116419: /**
116419:  *  start/stop ringing
116419:  *
116419:  *  @param[in] ringMode   - VCM ring mode (ON/OFF)
116419:  *  @param[in] once       - type of ring - continuous or one shot.
116419:  *  @param[in] alert_info - header specified ring mode.
116419:  *  @param[in] line       - the line on which to start/stop ringing
116419:  *
116419:  *  @return    void
116419:  */
116419: 
116419: void vcmControlRinger (vcm_ring_mode_t ringMode,
116419:                        short once,
116419:                        cc_boolean alert_info,
116419:                        int line,
116419:                        cc_callid_t call_id)
116419: {
116419:     const char fname[] = "vcmControlRinger";
116419: 
116419:     CSFLogDebug( logTag, "%s: ringMode=%d once=%d", fname, ringMode, once);
116419: 
116419:     /* we need to pass the line parameter for this */
116420: 
116420: #if 0
116420:      // <emannion> part of media provider removal
116419:     if ( ringMode == VCM_RING_OFF )
116419:     {
116419:         //call media_ring_stop
116419:         if ( VcmSIPCCBinding::getAudioTermination()->ringStop( line ) != 0 )
116419:         {
116419:             CSFLogDebug( logTag, "%s: mediaRingStop failed", fname);
116419:         }
116419:     }
116419:     else if ( VcmSIPCCBinding::getAudioTermination()->ringStart( line, map_ring_mode(ringMode), (once != 0) ) != 0 )
116419:     {
116419:         CSFLogDebug( logTag, "%s: mediaRingStart failed", fname);
116419:     }
116420: #endif
116419: }
116419: 
116419: /**
116419:  *  To be Deprecated
116419:  *  This may be needed to be implemented if the DSP doesn't automatically enable the side tone
116419:  *  The stack will make a call to this method based on the call state. Provide a stub if this is not needed.
116419:  *
116419:  *  @param[in] side_tone - cc_boolean to enable/disable side tone
116419:  *
116419:  *  @return void
116419:  *
116419:  */
116419: 
116419: void vcmEnableSidetone(cc_uint16_t side_tone)
116419: {
116419:     /* NOT REQD for TNP */
116419:     CSFLogDebug( logTag, "vcmEnableSidetone: vcmEnableSidetone(): called");
116419: }
116419: 
116419: /*
116419:  *  Function:map_VCM_Media_Payload_type
116419:  *
116419:  *  Parameters:payload
116419:  *
116419:  *  Description: Converts VCM payload type to MediaManager Payload defs.
116419:  *
116419:  *  Returns:payload type corresponding to VCM payload
116419:  *
116419:  */
116419: 
116419: #define MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCMPayloadItem, CIPPayloadItem)\
116419:   vcmToCIP_Mappings[VCMPayloadItem] = CIPPayloadItem
116419: 
116419: static int
116419: map_VCM_Media_Payload_type( vcm_media_payload_type_t payload )
116419: {
116419:     static bool mappingInitialised = false;
116419:     static int vcmToCIP_Mappings[VCM_Media_Payload_Max] = { };
116419: 
116419:     if (!mappingInitialised)
116419:     {
116419:         int numElements = csf_countof(vcmToCIP_Mappings);
116419: 
116419:         std::fill_n(vcmToCIP_Mappings, numElements, cip_mmgr_MediaDefinitions_MEDIA_TYPE_NONSTANDARD);
116419: 
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_NonStandard, cip_mmgr_MediaDefinitions_MEDIA_TYPE_NONSTANDARD);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G711Alaw64k, cip_mmgr_MediaDefinitions_MEDIA_TYPE_G711ALAW64K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G711Alaw56k, cip_mmgr_MediaDefinitions_MEDIA_TYPE_G711ALAW56K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G711Ulaw64k, cip_mmgr_MediaDefinitions_MEDIA_TYPE_G711ULAW64K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G711Ulaw56k, cip_mmgr_MediaDefinitions_MEDIA_TYPE_G711ULAW56K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G722_64k,    cip_mmgr_MediaDefinitions_MEDIA_TYPE_G722_64K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G722_56k,    cip_mmgr_MediaDefinitions_MEDIA_TYPE_G722_56K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G722_48k,    cip_mmgr_MediaDefinitions_MEDIA_TYPE_G722_48K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_ILBC20,      cip_mmgr_MediaDefinitions_MEDIA_TYPE_ILBC20 | (VCM_Media_Payload_ILBC20 & 0XFFFF0000));
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_ILBC30,      cip_mmgr_MediaDefinitions_MEDIA_TYPE_ILBC30 | (cip_mmgr_MediaDefinitions_MEDIA_TYPE_ILBC30 & 0XFFFF0000));
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G7231,       cip_mmgr_MediaDefinitions_MEDIA_TYPE_G7231_5P3K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G728,        cip_mmgr_MediaDefinitions_MEDIA_TYPE_G728);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G729,        cip_mmgr_MediaDefinitions_MEDIA_TYPE_G729);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G729AnnexA,  cip_mmgr_MediaDefinitions_MEDIA_TYPE_G729ANNEXA);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_Is11172AudioCap, cip_mmgr_MediaDefinitions_MEDIA_TYPE_IS11172AUDIOCAP);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_Is13818AudioCap, cip_mmgr_MediaDefinitions_MEDIA_TYPE_IS13818AUDIOCAP);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G729AnnexB,             cip_mmgr_MediaDefinitions_MEDIA_TYPE_G729ANNEXB);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_GSM_Full_Rate,          cip_mmgr_MediaDefinitions_MEDIA_TYPE_GSM_FULL_RATE);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_GSM_Half_Rate,          cip_mmgr_MediaDefinitions_MEDIA_TYPE_GSM_HALF_RATE);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_GSM_Enhanced_Full_Rate, cip_mmgr_MediaDefinitions_MEDIA_TYPE_GSM_ENHANCED_FULL_RATE);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_Wide_Band_256k,         cip_mmgr_MediaDefinitions_MEDIA_TYPE_WIDE_BAND_256K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_Data64,                 cip_mmgr_MediaDefinitions_MEDIA_TYPE_DATA64);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_Data56,                 cip_mmgr_MediaDefinitions_MEDIA_TYPE_DATA56);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_GSM,             cip_mmgr_MediaDefinitions_MEDIA_TYPE_GSM);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_ActiveVoice,             cip_mmgr_MediaDefinitions_MEDIA_TYPE_ACTIVEVOICE);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G726_32K,             cip_mmgr_MediaDefinitions_MEDIA_TYPE_G726_32K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G726_24K,             cip_mmgr_MediaDefinitions_MEDIA_TYPE_G726_24K);
116419:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_G726_16K,             cip_mmgr_MediaDefinitions_MEDIA_TYPE_G726_16K);
116420:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_VP8,                  cip_mmgr_MediaDefinitions_MEDIA_TYPE_VP8);
116420:         MAKE_VCM_MEDIA_PAYLOAD_MAP_ENTRY(VCM_Media_Payload_OPUS,                 cip_mmgr_MediaDefinitions_MEDIA_TYPE_OPUS);
116419: 
116419:         mappingInitialised = true;
116419:     }
116419: 
116419:     int vcmIndex = payload & 0XFFFF;
116419: 
116419:     switch (vcmIndex)
116419:     {
116419:     case VCM_Media_Payload_ILBC20:
116419:         return ((payload & 0XFFFF0000) | cip_mmgr_MediaDefinitions_MEDIA_TYPE_ILBC20);
116419:     case VCM_Media_Payload_ILBC30:
116419:         return ((payload & 0XFFFF0000) | cip_mmgr_MediaDefinitions_MEDIA_TYPE_ILBC30);
116419:     case VCM_Media_Payload_H263:
116419:         return ((payload & 0XFFFF0000) | cip_mmgr_MediaDefinitions_MEDIA_TYPE_H263);
116419:     case VCM_Media_Payload_H264:
116419:         return ((payload & 0XFFFF0000) | RTP_H264_P0);
116419:     case VCM_Media_Payload_ISAC:
116419:         return ((payload & 0XFFFF0000) | cip_mmgr_MediaDefinitions_MEDIA_TYPE_ISAC);
116420:     case VCM_Media_Payload_VP8:
116420:         return ((payload & 0XFFFF0000) | cip_mmgr_MediaDefinitions_MEDIA_TYPE_VP8);
116419:     default:
116419:         //use the static array
116419:         if (vcmIndex < VCM_Media_Payload_Max)
116419:         {
116419:             return vcmToCIP_Mappings[vcmIndex];
116419:         }
116419: 
116419:         return cip_mmgr_MediaDefinitions_MEDIA_TYPE_NONSTANDARD;
116419:     }
116419: }
116419: 
116419: /*
116419:  *  Function:map_algorithmID
116419:  *
116419:  *  Parameters:algorithmID
116419:  *
116419:  *  Description: Converts VCM algorithmID type to media layer defs.
116419:  *
116419:  *  Returns:algorithmID value corresponding to VCM algorithmID
116419:  *
116419:  */
116419: static EncryptionAlgorithm
116419: map_algorithmID( vcm_crypto_algorithmID algorithmID )
116419: {
116419:     switch ( algorithmID )
116419:     {
116419:     case VCM_AES_128_COUNTER:
116419:         return EncryptionAlgorithm_AES_128_COUNTER;
116419: 
116419:     default:
116419:         return EncryptionAlgorithm_NONE;
116419:     }
116419: }
116419: 
116419: /*
116419:  *  Function:vcm_init
116419:  *
116419:  *  Parameters:none
116419:  *
116419:  *  Description: Nothing to do for TNP.
116419:  *
116419:  *  Returns:none
116419:  *
116419:  */
116419: void vcmInit (void)
116419: {
116419:     CSFLogDebug( logTag, "vcmInit() called.");
116419: }
116419: 
116419: /**
116419:  * The unloading of the VCM module
116419:  */
116419: void vcmUnload (void)
116419: {
116419:     CSFLogDebug( logTag, "vcmUnload() called.");
116419: }
116419: 
116419: /**
116419:  *  Allocate(Reserve) a receive port.
116419:  *
116419:  *  @param[in]  mcap_id - Media Capability ID
116419:  *  @param[in]  group_id - group identifier to which stream belongs.
116419:  *  @param[in]  stream_id - stream identifier
116419:  *  @param[in]  call_handle  - call identifier
116419:  *  @param[in]  port_requested - port requested (if zero -> give any)
116419:  *  @param[out]  port_allocated - port that was actually allocated.
116419:  *
116419:  *  @return    void
116419:  *
116419:  */
116419: 
116419: void vcmRxAllocPort(cc_mcapid_t mcap_id,
116419:                     cc_groupid_t group_id,
116419:                     cc_streamid_t stream_id,
116419:                     cc_call_handle_t  call_handle,
116419:                     cc_uint16_t port_requested,
116419:                     int *port_allocated)
116419: {
116419:     CSFLogDebug( logTag, "vcmRxAllocPort(): group_id=%d stream_id=%d call_handle=%d port_requested = %d",
116419:         group_id, stream_id, call_handle, port_requested);
116419: 
116420:     // Not in SDP/PeerConnection mode
116419:     int port = -1;
116419:     bool isVideo = false;
116419:     if(CC_IS_AUDIO(mcap_id))
116419:     {
116419:       isVideo = false;
116419:       if ( VcmSIPCCBinding::getAudioTermination() != NULL )
116419:         port = VcmSIPCCBinding::getAudioTermination()->rxAlloc( group_id, stream_id, port_requested );
116419:     }
116419:     else if(CC_IS_VIDEO(mcap_id))
116419:     {
116419:       isVideo = true;
116419:       if ( VcmSIPCCBinding::getVideoTermination() != NULL )
116419:         port = VcmSIPCCBinding::getVideoTermination()->rxAlloc( group_id, stream_id, port_requested );
116419:     }
116419: 
116419:     StreamObserver* obs = VcmSIPCCBinding::getStreamObserver();
116419:     if(obs != NULL)
116419:       obs->registerStream(call_handle, stream_id, isVideo);
116419: 
116419:     CSFLogDebug( logTag, "vcmRxAllocPort(): allocated port %d", port);
116419:     *port_allocated = port;
116419: }
116419: 
116420: 
116420: /**
116420:  *  Gets the ICE parameters for a stream. Called "alloc" for style consistency
116420:  *
116420:  *  @param[in]  mcap_id - Media Capability ID
116420:  *  @param[in]  group_id - group identifier to which stream belongs.
116420:  *  @param[in]  stream_id - stream identifier
116420:  *  @param[in]  call_handle  - call identifier
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[out] default_addrp - the ICE default addr
116420:  *  @param[out] port_allocatedp - the ICE default port
116420:  *  @param[out] candidatesp - the ICE candidate array
116420:  *  @param[out] candidate_ctp length of the array
116420:  *
116420:  *  @return    void
116420:  *
116420:  */
116420: void vcmRxAllocICE(cc_mcapid_t mcap_id,
116420:         cc_groupid_t group_id,
116420:         cc_streamid_t stream_id,
116420:         cc_call_handle_t  call_handle,
116420:         const char *peerconnection,
116420:         uint16_t level,
116420:         char **default_addrp, /* Out */
116420:         int *default_portp, /* Out */
116420:         char ***candidatesp, /* Out */
116420:         int *candidate_ctp /* Out */
116420: )
116420: {
116420:   *default_portp = -1;
116420: 
116420:   CSFLogDebug( logTag, "%s: group_id=%d stream_id=%d call_handle=%d PC = %s",
116420:     __FUNCTION__, group_id, stream_id, call_handle, peerconnection);
116420: 
116420:   // Note: we don't acquire any media resources here, and we assume that the
116420:   // ICE streams already exist, so we're just acquiring them. Any logic
116420:   // to make them on demand is elsewhere.
116420:   CSFLogDebug( logTag, "%s: acquiring peerconnection %s", __FUNCTION__, peerconnection);
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   MOZ_ASSERT(pc);
116420:   if (!pc) {
116420:     CSFLogError(logTag, "%s: AcquireInstance returned NULL", __FUNCTION__);
116420:     return;
116420:   }
116420: 
116420:   CSFLogDebug( logTag, "%s: Getting stream %d", __FUNCTION__, level);
122169:   mozilla::RefPtr<NrIceMediaStream> stream = pc->impl()->media()->
122169:     ice_media_stream(level-1);
116420:   MOZ_ASSERT(stream);
116420:   if (!stream) {
116420:     return;
116420:   }
116420: 
116420:   std::vector<std::string> candidates = stream->GetCandidates();
116420:   CSFLogDebug( logTag, "%s: Got %d candidates", __FUNCTION__, candidates.size());
116420: 
116420:   std::string default_addr;
116420:   int default_port;
116420: 
116420:   nsresult res = stream->GetDefaultCandidate(1, &default_addr, &default_port);
116420:   MOZ_ASSERT(NS_SUCCEEDED(res));
116420:   if (!NS_SUCCEEDED(res)) {
116420:     return;
116420:   }
116420: 
116420:   CSFLogDebug( logTag, "%s: Got default candidates %s:%d", __FUNCTION__,
116420:     default_addr.c_str(), default_port);
116420: 
116420:   // Note: this leaks memory if we are out of memory. Oh well.
116420:   *candidatesp = (char **) cpr_malloc(candidates.size() * sizeof(char *));
116420:   if (!(*candidatesp))
116420:     return;
116420: 
116420:   for (size_t i=0; i<candidates.size(); i++) {
116420:     (*candidatesp)[i] = (char *) cpr_malloc(candidates[i].size() + 1);
116420:     sstrncpy((*candidatesp)[i], candidates[i].c_str(), candidates[i].size() + 1);
116420:   }
116420:   *candidate_ctp = candidates.size();
116420: 
116420:   // Copy the default address
116420:   *default_addrp = (char *) cpr_malloc(default_addr.size() + 1);
116420:   if (!*default_addrp)
116420:     return;
116420:   sstrncpy(*default_addrp, default_addr.c_str(), default_addr.size() + 1);
116420:   *default_portp = default_port; /* This is the signal that things are cool */
116420: }
116420: 
116420: 
116420: /* Get ICE global parameters (ufrag and pwd)
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[out] ufragp - where to put the ufrag
116420:  *  @param[out] pwdp - where to put the pwd
116420:  *
116420:  *  @return void
116420:  */
116420: void vcmGetIceParams(const char *peerconnection, char **ufragp, char **pwdp)
116420: {
116420:   CSFLogDebug( logTag, "%s: PC = %s", __FUNCTION__, peerconnection);
116420: 
116420:   *ufragp = *pwdp = NULL;
116420: 
116420:  // Note: we don't acquire any media resources here, and we assume that the
116420:   // ICE streams already exist, so we're just acquiring them. Any logic
116420:   // to make them on demand is elsewhere.
116420:   CSFLogDebug( logTag, "%s: acquiring peerconnection %s", __FUNCTION__, peerconnection);
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   MOZ_ASSERT(pc);
116420:   if (!pc) {
116420:     return;
116420:   }
116420: 
122169:   std::vector<std::string> attrs = pc->impl()->media()->
122169:     ice_ctx()->GetGlobalAttributes();
116420: 
116420:   // Now fish through these looking for a ufrag and passwd
116420:   char *ufrag = NULL;
116420:   char *pwd = NULL;
116420: 
116420:   for (size_t i=0; i<attrs.size(); i++) {
116420:     if (attrs[i].compare(0, strlen("ice-ufrag:"), "ice-ufrag:") == 0) {
116420:       if (!ufrag) {
116420:         ufrag = (char *) cpr_malloc(attrs[i].size() + 1);
116420:         if (!ufrag)
116420:           return;
116420:         sstrncpy(ufrag, attrs[i].c_str(), attrs[i].size() + 1);
116420:         ufrag[attrs[i].size()] = 0;
116420:       }
116420:     }
116420: 
116420:     if (attrs[i].compare(0, strlen("ice-pwd:"), "ice-pwd:") == 0) {
116420:       pwd = (char *) cpr_malloc(attrs[i].size() + 1);
116420:       if (!pwd)
116420:         return;
116420:       sstrncpy(pwd, attrs[i].c_str(), attrs[i].size() + 1);
116420:       pwd[attrs[i].size()] = 0;
116420:     }
116420: 
116420:   }
116420:   if (!ufrag || !pwd) {
120060:     MOZ_ASSERT(PR_FALSE);
116420:     cpr_free(ufrag);
116420:     cpr_free(pwd);
116420:     CSFLogDebug( logTag, "%s: no ufrag or password", __FUNCTION__);
116420:     return;
116420:   }
116420: 
116420:   *ufragp = ufrag;
116420:   *pwdp = pwd;
116420: 
116420:   return;
116420: }
116420: 
116420: 
116420: 
116420: /* Set remote ICE global parameters.
116420:  *
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[in]  ufrag - the ufrag
116420:  *  @param[in]  pwd - the pwd
116420:  *
116420:  *  @return 0 success, error failure
116420:  */
116420: short vcmSetIceSessionParams(const char *peerconnection, char *ufrag, char *pwd)
116420: {
116420:   CSFLogDebug( logTag, "%s: PC = %s", __FUNCTION__, peerconnection);
116420: 
116420:   CSFLogDebug( logTag, "%s: acquiring peerconnection %s", __FUNCTION__, peerconnection);
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   MOZ_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   std::vector<std::string> attributes;
116420: 
116420:   if (ufrag)
116420:     attributes.push_back(ufrag);
116420:   if (pwd)
116420:     attributes.push_back(pwd);
116420: 
122169:   nsresult res = pc->impl()->media()->ice_ctx()->
122169:     ParseGlobalAttributes(attributes);
116420: 
116420:   if (!NS_SUCCEEDED(res)) {
116420:     CSFLogError( logTag, "%s: couldn't parse global parameters", __FUNCTION__ );
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   return 0;
116420: }
116420: 
116420: /* Set ice candidate for trickle ICE.
116420:  *
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[in]  icecandidate - the icecandidate
116420:  *  @param[in]  level - the m line level
116420:  *
116420:  *  @return 0 success, error failure
116420:  */
116420: short vcmSetIceCandidate(const char *peerconnection, const char *icecandidate, uint16_t level)
116420: {
116420:   CSFLogDebug( logTag, "%s: PC = %s", __FUNCTION__, peerconnection);
116420: 
116420:   CSFLogDebug( logTag, "%s: acquiring peerconnection %s", __FUNCTION__, peerconnection);
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   MOZ_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   CSFLogDebug( logTag, "%s(): Getting stream %d", __FUNCTION__, level);
122169:   mozilla::RefPtr<NrIceMediaStream> stream = pc->impl()->media()->
122169:     ice_media_stream(level-1);
116420:   if (!stream)
116420:     return VCM_ERROR;
116420: 
116420:   nsresult res;
122169:   nsresult rv = pc->impl()->media()->ice_ctx()->thread()->Dispatch(
116420:     WrapRunnableRet(stream, &NrIceMediaStream::ParseTrickleCandidate, icecandidate, &res),
116420:     NS_DISPATCH_SYNC);
116420: 
120253:   if (!NS_SUCCEEDED(rv)) {
120253:     CSFLogError( logTag, "%s(): Could not dispatch to ICE thread", __FUNCTION__, level);
120253:     return VCM_ERROR;
120253:   }
120253: 
116420:   if (!NS_SUCCEEDED(res)) {
116420:     CSFLogError( logTag, "%s(): Could not parse trickle candidate for stream %d", __FUNCTION__, level);
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   return 0;
116420: }
116420: 
116420: /* Start ICE checks
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @return 0 success, error failure
116420:  */
116420: short vcmStartIceChecks(const char *peerconnection)
116420: {
116420:   CSFLogDebug( logTag, "%s: PC = %s", __FUNCTION__, peerconnection);
116420: 
116420:   CSFLogDebug( logTag, "%s: acquiring peerconnection %s", __FUNCTION__, peerconnection);
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   MOZ_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   nsresult res;
122169:   nsresult rv = pc->impl()->media()->ice_ctx()->thread()->Dispatch(
122169:     WrapRunnableRet(pc->impl()->media()->ice_ctx(), &NrIceCtx::StartChecks, &res),
116420:       NS_DISPATCH_SYNC);
116420: 
120253:   if (!NS_SUCCEEDED(rv)) {
120253:     CSFLogError( logTag, "%s(): Could not dispatch to ICE thread", __FUNCTION__);
120253:     return VCM_ERROR;
120253:   }
120253: 
116420:   if (!NS_SUCCEEDED(res)) {
116420:     CSFLogError( logTag, "%s: couldn't start ICE checks", __FUNCTION__ );
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   return 0;
116420: }
116420: 
116420: 
116420: /* Set remote ICE media-level parameters.
116420:  *
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[in]  level - the m-line
116420:  *  @param[in]  ufrag - the ufrag
116420:  *  @param[in]  pwd - the pwd
116420:  *  @param[in]  candidates - the candidates
116420:  *  @param[i]   candidate_ct - the number of candidates
116420:  *  @return 0 success, error failure
116420:  */
116420: short vcmSetIceMediaParams(const char *peerconnection, int level, char *ufrag, char *pwd,
116420:                       char **candidates, int candidate_ct)
116420: {
116420:   CSFLogDebug( logTag, "%s: PC = %s", __FUNCTION__, peerconnection);
116420: 
116420:   CSFLogDebug( logTag, "%s: acquiring peerconnection %s", __FUNCTION__, peerconnection);
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   MOZ_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   CSFLogDebug( logTag, "%s(): Getting stream %d", __FUNCTION__, level);
122169:   mozilla::RefPtr<NrIceMediaStream> stream = pc->impl()->media()->
122169:     ice_media_stream(level-1);
116420:   if (!stream)
116420:     return VCM_ERROR;
116420: 
116420:   std::vector<std::string> attributes;
116420: 
116420:   if (ufrag)
116420:     attributes.push_back(ufrag);
116420:   if (pwd)
116420:     attributes.push_back(pwd);
116420: 
116420:   for (int i = 0; i<candidate_ct; i++) {
116420:     attributes.push_back(candidates[i]);
116420:   }
116420: 
116420:   nsresult res = stream->ParseAttributes(attributes);
116420: 
116420:   if (!NS_SUCCEEDED(res)) {
116420:     CSFLogError( logTag, "%s: couldn't parse global parameters", __FUNCTION__ );
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   return 0;
116420: }
116420: 
116420: /*
116420:  * Create a remote stream
116420:  *
116420:  *  @param[in] mcap_id - group identifier to which stream belongs.
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[out] pc_stream_id - the id of the allocated stream
116420:  *
116420:  *  TODO(ekr@rtfm.com): Revise along with everything else for the
116420:  *  new stream model.
116420:  *
116420:  *  Returns: zero(0) for success; otherwise, ERROR for failure
116420:  */
116420: short vcmCreateRemoteStream(
116420:   cc_mcapid_t mcap_id,
116420:   const char *peerconnection,
116420:   int *pc_stream_id,
116420:   vcm_media_payload_type_t payload) {
116452:   uint32_t hints = 0;
116420:   nsresult res;
116420: 
116420:   CSFLogDebug( logTag, "%s", __FUNCTION__);
116420: 
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   MOZ_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   if (CC_IS_AUDIO(mcap_id)) {
116420:     hints |= nsDOMMediaStream::HINT_CONTENTS_AUDIO;
116420:   }
116420:   if (CC_IS_VIDEO(mcap_id)) {
116420:     hints |= nsDOMMediaStream::HINT_CONTENTS_VIDEO;
116420:   }
116420: 
116420:   sipcc::RemoteSourceStreamInfo* info;
116420:   res = pc->impl()->CreateRemoteSourceStreamInfo(hints, &info);
116420:   if (NS_FAILED(res)) {
116420:     return VCM_ERROR;
116420:   }
116420: 
122169:   res = pc->impl()->media()->AddRemoteStream(info, pc_stream_id);
116420:   if (NS_FAILED(res)) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   if (CC_IS_AUDIO(mcap_id)) {
116420:     mozilla::AudioSegment *segment = new mozilla::AudioSegment();
116420:     segment->Init(1); // 1 Channel
116420:     // TODO(ekr@rtfm.com): Clean up Track IDs
116420:     info->GetMediaStream()->GetStream()->AsSourceStream()->AddTrack(1, 16000, 0, segment);
116420: 
116420:     // We aren't going to add any more tracks
116420:     info->GetMediaStream()->GetStream()->AsSourceStream()->
116420:         AdvanceKnownTracksTime(mozilla::STREAM_TIME_MAX);
116420:   }
116420:   if (CC_IS_VIDEO(mcap_id)) {
116420:     // AddTrack takes ownership of segment
116420:   }
116420: 
116420:   CSFLogDebug( logTag, "%s: created remote stream with index %d hints=%d",
116420:     __FUNCTION__, *pc_stream_id, hints);
116420: 
116420:   return 0;
116420: }
116420: 
116420: 
116420: /*
116420:  * Get DTLS key data
116420:  *
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[out] digest_algp    - the digest algorithm e.g. 'SHA-1'
116420:  *  @param[in] max_digest_alg_len - length of string
116420:  *  @param[out] digestp        - the digest string
116420:  *  @param[in] max_digest_len - length of string
116420:  *
116420:  *  Returns: zero(0) for success; otherwise, ERROR for failure
116420:  */
116420: short vcmGetDtlsIdentity(const char *peerconnection,
116420:                 char *digest_algp,
116420:                 size_t max_digest_alg_len,
116420:                 char *digestp,
116420:                 size_t max_digest_len) {
116420:   CSFLogDebug( logTag, "%s: acquiring peerconnection %s", __FUNCTION__, peerconnection);
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   MOZ_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   unsigned char digest[TransportLayerDtls::kMaxDigestLength];
116420:   size_t digest_len;
116420: 
116420:   nsresult res = pc->impl()->GetIdentity()->ComputeFingerprint("sha-256", digest,
116420:                                                                sizeof(digest),
116420:                                                                &digest_len);
116420:   if (!NS_SUCCEEDED(res)) {
116420:     CSFLogError( logTag, "%s: Could not compute identity fingerprint", __FUNCTION__);
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   // digest_len should be 32 for SHA-256
116420:   PR_ASSERT(digest_len == 32);
116420:   std::string fingerprint_txt = DtlsIdentity::FormatFingerprint(digest, digest_len);
116420:   if (max_digest_len <= fingerprint_txt.size()) {
116420:     CSFLogError( logTag, "%s: Formatted digest will not fit in provided buffer",
116420:                  __FUNCTION__);
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   sstrncpy(digest_algp, "sha-256", max_digest_alg_len);
116420:   sstrncpy(digestp, fingerprint_txt.c_str(), max_digest_len);
116420: 
116420:   return 0;
116420: }
116420: 
116420: /* Set negotiated DataChannel parameters.
116420:  *
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[in]  streams - the number of streams for this data channel
116420:  *  @param[in]  sctp_port - the negotiated sctp port
116420:  *  @param[in]  protocol - the protocol as a string
116420:  *
116420:  *  @return 0 success, error failure
116420:  */
116420: short vcmSetDataChannelParameters(const char *peerconnection, cc_uint16_t streams, int sctp_port, const char* protocol)
116420: {
116420:   CSFLogDebug( logTag, "%s: PC = %s", __FUNCTION__, peerconnection);
116420: 
116420:   CSFLogDebug( logTag, "%s: acquiring peerconnection %s", __FUNCTION__, peerconnection);
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   PR_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420: 
116420:   return 0;
116420: }
116420: 
116420: 
116420: 
116419: /**
116419:  *   Should we remove this from external API
116419:  *
116419:  *  @param[in] mcap_id - group identifier to which stream belongs.
116419:  *  @param[in]     group_id         - group identifier
116419:  *  @param[in]     stream_id        - stream identifier
116419:  *  @param[in]     call_handle      - call identifier
116419:  *  @param[in]     port_requested   - requested port.
116419:  *  @param[in]     listen_ip        - local IP for listening
116419:  *  @param[in]     is_multicast     - multicast stream?
116419:  *  @param[in,out] port_allocated   - allocated(reserved) port
116419:  *
116419:  *  tbd need to see if we can deprecate this API
116419:  *
116419:  *  @return       0 success, ERROR failure.
116419:  *
116419:  */
116419: 
116419: short vcmRxOpen(cc_mcapid_t mcap_id,
116419:                 cc_groupid_t group_id,
116419:                 cc_streamid_t stream_id,
116419:                 cc_call_handle_t call_handle,
116419:                 cc_uint16_t port_requested,
116419:                 cpr_ip_addr_t *listen_ip,
116419:                 cc_boolean is_multicast,
116419:                 int *port_allocated)
116419: {
116419:     char fname[] = "vcmRxOpen";
116419: 
116419:     char dottedIP[20] = "";
116419:     if(listen_ip)
116419:     {
116419:     	csf_sprintf(dottedIP, sizeof(dottedIP), "%u.%u.%u.%u",
116419:                 (listen_ip->u.ip4 >> 24) & 0xff, (listen_ip->u.ip4 >> 16) & 0xff,
116419:                 (listen_ip->u.ip4 >> 8) & 0xff, listen_ip->u.ip4 & 0xff );
116419:     }
116419: 
116419:     CSFLogDebug( logTag, "%s: group_id=%d call_handle=%d listen=%s:%d is_mcast=%d",
116419:                       fname, group_id, call_handle, dottedIP, port_requested, is_multicast);
116419: 
116419:     switch ( mcap_id )
116419:     {
116419:     case CC_AUDIO_1:
116419:         CSFLogDebug( logTag, "%s: audio stream", fname);
116419:         if ( VcmSIPCCBinding::getAudioTermination() != NULL )
116419:             *port_allocated = VcmSIPCCBinding::getAudioTermination()->rxOpen( group_id, stream_id,
116419:                                                     port_requested, listen_ip ? listen_ip->u.ip4 : 0,
116419:                                                     (is_multicast != 0) );
116419:         break;
116419:     case CC_VIDEO_1:
116419:         CSFLogDebug( logTag, "%s: video stream", fname);
116419:         if ( VcmSIPCCBinding::getVideoTermination() != NULL )
116419:             *port_allocated = VcmSIPCCBinding::getVideoTermination()->rxOpen( group_id, stream_id,
116419:                                                     port_requested, listen_ip ? listen_ip->u.ip4 : 0,
116419:                                                     (is_multicast != 0) );
116419:         break;
116419: 
116419:     default:
116419:         break;
116419:     }
116419:     return 0;
116419: }
116419: 
116419: /**
116419:  *  Start receive stream
116419:  *  Note: For video calls, for a given call_handle there will be
116419:  *        two media lines and the corresponding group_id/stream_id pair.
116419:  *        One RTP session is requested from media server for each
116419:  *        media line(group/stream) i.e. a video call would result in
116419:  *        two rtp_sessions in our session info list created by two
116419:  *        calls to vcm_rx/tx with mcap_id of AUDIO and VIDEO respectively.
116419:  *
116419:  *  @param[in]    mcap_id     - media type id
116419:  *  @param[in]    group_id    - group identifier associated with the stream
116419:  *  @param[in]    stream_id   - id of the stream one per each media line
116419:  *  @param[in]    call_handle     - call identifier
116419:  *  @param[in]    payload     - payload type
116419:  *  @param[in]    local_addr  - local ip address to use.
116419:  *  @param[in]    port        - local port (receive)
116419:  *  @param[in]    algorithmID - crypto alogrithm ID
116419:  *  @param[in]    rx_key      - rx key used when algorithm ID is encrypting
116419:  *  @param[in]    attrs       - media attributes
116419:  *
116419:  *  @return   zero(0) for success; otherwise, -1 for failure
116419:  *
116419:  */
116419: int vcmRxStart(cc_mcapid_t mcap_id,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_call_handle_t  call_handle,
116419:         vcm_media_payload_type_t payload,
116419:         cpr_ip_addr_t *local_addr,
116419:         cc_uint16_t port,
116419:         vcm_crypto_algorithmID algorithmID,
116419:         vcm_crypto_key_t *rx_key,
116419:         vcm_mediaAttrs_t *attrs)
116419: {
116419:     int         pt;
116419:     uint8_t    *key;
116419:     uint8_t    *salt;
116419:     cc_uint16_t    key_len;
116419:     cc_uint16_t    salt_len;
116419:     char        fname[] = "vcmRxStart";
116419: 
116419:     CSFLogDebug( logTag, "%s: group_id=%d call_handle=%d payload=%d port=%d algID=%d",
116419:         fname, group_id, call_handle, payload, port, algorithmID);
116419: 
116419:     if (call_handle == CC_NO_CALL_ID) {
116419:         /* no operation when no call ID */
116419:         return VCM_ERROR;
116419:     }
116419: 
116419:     /* Set up crypto parameters */
116419:     switch ( algorithmID )
116419:     {
116419:     case VCM_AES_128_COUNTER:
116419:         if ( rx_key == NULL )
116419:         {
116419:             /* No key provided */
116419:             CSFLogDebug( logTag, "vcmRxStart(): No key for algorithm ID %d",
116419:                       algorithmID);
116419:             return VCM_ERROR;
116419:         }
116419:         /* Set up key and Salt parameters */
116419:         key_len = rx_key->key_len;
116419:         key = &rx_key->key[0];
116419:         salt_len = rx_key->salt_len;
116419:         salt = &rx_key->salt[0];
116419:         break;
116419: 
116419:     default:
116419:         /* Give dummy data to avoid passing NULL for key/salt */
116419:         key_len = 0;
116419:         key = (uint8_t *)"";
116419:         salt_len = 0;
116419:         salt = (uint8_t *)"";
116419:         break;
116419:     }
116419: 
116419:     pt = map_VCM_Media_Payload_type(payload);
116419: 
116419:     switch ( mcap_id )
116419:     {
116419:     case CC_AUDIO_1:
116419:         if ( VcmSIPCCBinding::getAudioTermination() != NULL )
116419:             return VcmSIPCCBinding::getAudioTermination()->rxStart( group_id, stream_id, DYNAMIC_PAYLOAD_TYPE(pt),
116419:                                                                     attrs->audio.packetization_period, port, attrs->audio.avt_payload_type,
116419:                                                                     map_algorithmID(algorithmID), key, key_len, salt, salt_len,
116419:                                                                     attrs->audio.mixing_mode, attrs->audio.mixing_party );
116419:         break;
116419: 
116419:     case CC_VIDEO_1:
116419:         if ( VcmSIPCCBinding::getVideoTermination() != NULL )
116419:             return VcmSIPCCBinding::getVideoTermination()->rxStart( group_id, stream_id, DYNAMIC_PAYLOAD_TYPE(pt),
116419:                                                                     0,
116419:                                                                     port,
116419:                                                                     0,
116419:                                                                     map_algorithmID(algorithmID), key, key_len, salt, salt_len,
116419:                                                                     0, 0);
116419:         break;
116419: 
116419:     default:
116419:         break;
116419:     }
116419:     return VCM_ERROR;
116419: }
116419: 
116420: 
116420: /**
116420:  *  start rx stream
116420:  *  Same concept as vcmRxStart but for ICE/PeerConnection-based flows
116420:  *
116420:  *  @param[in]   mcap_id      - media cap id
116420:  *  @param[in]   group_id     - group identifier to which the stream belongs
116420:  *  @param[in]   stream_id    - stream id of the given media type.
116420:  *  @param[in]   level        - the m-line index
116420:  *  @param[in]   pc_stream_id - the media stream index (from PC.addStream())
116420:  *  @param[i]n   pc_track_id  - the track within the media stream
116420:  *  @param[in]   call_handle  - call handle
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[in]  num_payloads   - number of negotiated payloads
116420:  *  @param[in]  payloads       - negotiated codec details list
116420:  *  @param[in]   fingerprint_alg - the DTLS fingerprint algorithm
116420:  *  @param[in]   fingerprint  - the DTLS fingerprint
116420:  *  @param[in]   attrs        - media attributes
116420:  *
116420:  *  Returns: zero(0) for success; otherwise, ERROR for failure
116420:  */
116420: 
116420: int vcmRxStartICE(cc_mcapid_t mcap_id,
116420:         cc_groupid_t group_id,
116420:         cc_streamid_t stream_id,
116420:         int level,
116420:         int pc_stream_id,
116420:         int pc_track_id,
116420:         cc_call_handle_t  call_handle,
116420:         const char *peerconnection,
116420:         int num_payloads,
116420:         const vcm_media_payload_type_t* payloads,
116420:         const char *fingerprint_alg,
116420:         const char *fingerprint,
116420:         vcm_mediaAttrs_t *attrs)
116420: {
116420:   CSFLogDebug( logTag, "%s(%s)", __FUNCTION__, peerconnection);
116420: 
116420:   // Find the PC and get the stream
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   PR_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   if(!payloads) {
116420:       CSFLogError( logTag, "Unitialized payload list");
116420:       return VCM_ERROR;
116420:   }
116420: 
116420:   // Find the stream we need
116420:   nsRefPtr<sipcc::RemoteSourceStreamInfo> stream =
122169:     pc->impl()->media()->GetRemoteStream(pc_stream_id);
116420:   if (!stream) {
116420:     // This should never happen
120060:     PR_ASSERT(PR_FALSE);
116420:     return VCM_ERROR;
116420:   }
116420:   // Create the transport flows
116420:   mozilla::RefPtr<TransportFlow> rtp_flow =
116420:       vcmCreateTransportFlow(pc->impl(), level, false,
116420:                              fingerprint_alg, fingerprint);
118715:   if (!rtp_flow) {
118715:       CSFLogError( logTag, "Could not create RTP flow");
118715:       return VCM_ERROR;
118715:   }
116420:   mozilla::RefPtr<TransportFlow> rtcp_flow =
116420:       vcmCreateTransportFlow(pc->impl(), level, true,
116420:                              fingerprint_alg, fingerprint);
118715:   if (!rtcp_flow) {
118715:       CSFLogError( logTag, "Could not create RTCP flow");
118715:       return VCM_ERROR;
118715:   }
116420: 
116420:   if (CC_IS_AUDIO(mcap_id)) {
116420:     std::vector<mozilla::AudioCodecConfig *> configs;
116420:     // Instantiate an appropriate conduit
116420:     mozilla::RefPtr<mozilla::AudioSessionConduit> conduit =
116420:                     mozilla::AudioSessionConduit::Create();
116420:     if(!conduit)
116420:       return VCM_ERROR;
116420: 
116420:     mozilla::AudioCodecConfig *config_raw;
116420: 
116420:     for(int i=0; i <num_payloads ; i++)
116420:     {
116420:       int ret = vcmPayloadType2AudioCodec(payloads[i], &config_raw);
116420:       if (ret) {
120060:        PR_ASSERT(PR_FALSE);
116420:        return VCM_ERROR;
116420:       }
116420:       configs.push_back(config_raw);
116420:     }
116420: 
116420:     if (conduit->ConfigureRecvMediaCodecs(configs))
116420:       return VCM_ERROR;
116420: 
116420:     // Now we have all the pieces, create the pipeline
116420:     stream->StorePipeline(pc_track_id,
116420:       new mozilla::MediaPipelineReceiveAudio(
116420:         pc->impl()->GetMainThread().get(),
116420:         pc->impl()->GetSTSThread(),
116420:         stream->GetMediaStream(),
116420:         conduit, rtp_flow, rtcp_flow));
116420: 
116420:   } else if (CC_IS_VIDEO(mcap_id)) {
116420: 
116420:     std::vector<mozilla::VideoCodecConfig *> configs;
116420:     // Instantiate an appropriate conduit
116420:     mozilla::RefPtr<mozilla::VideoSessionConduit> conduit =
116420:              mozilla::VideoSessionConduit::Create();
116420:     if(!conduit)
116420:       return VCM_ERROR;
116420: 
116420:     mozilla::VideoCodecConfig *config_raw;
116420: 
116420:     for(int i=0; i <num_payloads; i++)
116420:     {
116420:       int ret = vcmPayloadType2VideoCodec(payloads[i], &config_raw);
116420:       if (ret) {
120060:        PR_ASSERT(PR_FALSE);
116420:        return VCM_ERROR;
116420:       }
116420:       configs.push_back(config_raw);
116420:     }
116420: 
116420:     if (conduit->ConfigureRecvMediaCodecs(configs))
116420:       return VCM_ERROR;
116420: 
116420:     // Now we have all the pieces, create the pipeline
116420:     stream->StorePipeline(pc_track_id,
116420:       new mozilla::MediaPipelineReceiveVideo(
116420:         pc->impl()->GetMainThread().get(),
116420:         pc->impl()->GetSTSThread(),
116420:         stream->GetMediaStream(),
116420:         conduit, rtp_flow, rtcp_flow));
116420: 
116420:   } else {
116420:     CSFLogError(logTag, "%s: mcap_id unrecognized", __FUNCTION__);
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   CSFLogDebug( logTag, "%s success", __FUNCTION__);
116420:   return 0;
116420: }
116420: 
116420: 
116419: /**
116419:  *  Close the receive stream.
116419:  *
116419:  *  @param[in]    mcap_id - Media Capability ID
116419:  *  @param[in]    group_id - group identifier that belongs to the stream.
116419:  *  @param[in]    stream_id - stream id of the given media type.
116419:  *  @param[in]    call_handle  - call identifier
116419:  *
116419:  *  @return   None
116419:  *
116419:  */
116419: 
116419: void vcmRxClose(cc_mcapid_t mcap_id,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_call_handle_t  call_handle)
116419: {
116419:     char fname[] = "vcmRxClose";
116419: 
116419:     CSFLogDebug( logTag, "%s: group_id=%d call_handle=%d", fname, group_id, call_handle);
116419: 
116419:     if (call_handle == CC_NO_CALL_ID) {
116419:         CSFLogDebugS( logTag, "No CALL ID");
116419:         /* no operation when no call ID */
116419:         return;
116419:     }
116419:     switch ( mcap_id )
116419:     {
116419:     case CC_AUDIO_1:
116419:         if ( VcmSIPCCBinding::getAudioTermination() != NULL )
116419:             VcmSIPCCBinding::getAudioTermination()->rxClose( group_id, stream_id );
116419:         break;
116419: 
116419:     case CC_VIDEO_1:
116419:         if ( VcmSIPCCBinding::getVideoTermination() != NULL )
116419:             VcmSIPCCBinding::getVideoTermination()->rxClose( group_id, stream_id );
116419:         break;
116419: 
116419:     default:
116419:         break;
116419:     }
116419: }
116419: 
116419: /**
116419:  *  Release the allocated port
116419:  * @param[in] mcap_id   - media capability id (0 is audio)
116419:  * @param[in] group_id  - group identifier
116419:  * @param[in] stream_id - stream identifier
116419:  * @param[in] call_handle   - call id
116419:  * @param[in] port     - port to be released
116419:  *
116419:  * @return void
116419:  */
116419: 
116419: void vcmRxReleasePort  (cc_mcapid_t mcap_id,
116419:                         cc_groupid_t group_id,
116419:                         cc_streamid_t stream_id,
116419:                         cc_call_handle_t  call_handle,
116419:                         int port)
116419: {
116419:     CSFLogDebug( logTag, "vcmRxReleasePort(): group_id=%d stream_id=%d call_handle=%d port=%d",
116419:                       group_id, stream_id, call_handle, port);
116419: 
116419:     if(CC_IS_AUDIO(mcap_id))
116419:     {
116419:         if ( VcmSIPCCBinding::getAudioTermination() != NULL )
116419:             VcmSIPCCBinding::getAudioTermination()->rxRelease( group_id, stream_id, port );
116419:     }
116419:     else if(CC_IS_VIDEO(mcap_id))
116419:     {
116419:         if ( VcmSIPCCBinding::getVideoTermination() != NULL )
116419:            VcmSIPCCBinding::getVideoTermination()->rxRelease( group_id, stream_id, port );
116419:     }
116419: 
116419:     StreamObserver* obs = VcmSIPCCBinding::getStreamObserver();
116419:     if(obs != NULL)
116419:     	obs->deregisterStream(call_handle, stream_id);
116419: }
116419: 
116419: /*
116419:  *  Function:map_tone_type
116419:  *
116419:  *  Description: Convert to corresponding JPhone tone.
116419:  *
116419:  *  Parameters:  tone - vcm tone
116419:  *
116419:  *  Returns:     Mapped tone type
116419:  *
116419:  */
116419: static ToneType
116419: map_tone_type( vcm_tones_t tone )
116419: {
116419:     switch ( tone )
116419:     {
116419:     case VCM_INSIDE_DIAL_TONE:
116419:         return ToneType_INSIDE_DIAL_TONE;
116419:     case VCM_OUTSIDE_DIAL_TONE:
116419:         return ToneType_OUTSIDE_DIAL_TONE;
116419:     case VCM_LINE_BUSY_TONE:
116419:         return ToneType_LINE_BUSY_TONE;
116419:     case VCM_ALERTING_TONE:
116419:         return ToneType_ALERTING_TONE;
116419:     case VCM_BUSY_VERIFY_TONE:
116419:         return ToneType_BUSY_VERIFY_TONE;
116419:     case VCM_STUTTER_TONE:
116419:         return ToneType_STUTTER_TONE;
116419:     case VCM_MSG_WAITING_TONE:
116419:         return ToneType_MSG_WAITING_TONE;
116419:     case VCM_REORDER_TONE:
116419:         return ToneType_REORDER_TONE;
116419:     case VCM_CALL_WAITING_TONE:
116419:         return ToneType_CALL_WAITING_TONE;
116419:     case VCM_CALL_WAITING_2_TONE:
116419:         return ToneType_CALL_WAITING_2_TONE;
116419:     case VCM_CALL_WAITING_3_TONE:
116419:         return ToneType_CALL_WAITING_3_TONE;
116419:     case VCM_CALL_WAITING_4_TONE:
116419:         return ToneType_CALL_WAITING_4_TONE;
116419:     case VCM_HOLD_TONE:
116419:         return ToneType_HOLD_TONE;
116419:     case VCM_CONFIRMATION_TONE:
116419:         return ToneType_CONFIRMATION_TONE;
116419:     case VCM_PERMANENT_SIGNAL_TONE:
116419:         return ToneType_PERMANENT_SIGNAL_TONE;
116419:     case VCM_REMINDER_RING_TONE:
116419:         return ToneType_REMINDER_RING_TONE;
116419:     case VCM_NO_TONE:
116419:         return ToneType_NO_TONE;
116419:     case VCM_ZIP_ZIP:
116419:         return ToneType_ZIP_ZIP;
116419:     case VCM_ZIP:
116419:         return ToneType_ZIP;
116419:     case VCM_BEEP_BONK:
116419:         return ToneType_BEEP_BONK;
116419:     case VCM_RECORDERWARNING_TONE:
116419:         return ToneType_RECORDERWARNING_TONE;
116419:     case VCM_RECORDERDETECTED_TONE:
116419:         return ToneType_RECORDERDETECTED_TONE;
116419:     case VCM_MONITORWARNING_TONE:
116419:         return ToneType_MONITORWARNING_TONE;
116419:     case VCM_SECUREWARNING_TONE:
116419:         return ToneType_SECUREWARNING_TONE;
116419:     default:
116419:         CSFLogDebugS( logTag, "map_tone_type(): WARNING..tone type not mapped.");
116419:         return ToneType_NO_TONE;
116419:     }
116419: }
116419: 
116419: /**
116419:  *  Start a tone (continuous)
116419:  *
116419:  *  Parameters:
116419:  *  @param[in] tone       - tone type
116419:  *  @param[in] alert_info - alertinfo header
116419:  *  @param[in] call_handle    - call identifier
116419:  *  @param[in] group_id - identifier of the group to which stream belongs
116419:  *  @param[in] stream_id   - stream identifier.
116419:  *  @param[in] direction  - network, speaker, both
116419:  *
116419:  *  @return void
116419:  *
116419:  */
116419: 
116419: void vcmToneStart(vcm_tones_t tone,
116419:         short alert_info,
116419:         cc_call_handle_t  call_handle,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_uint16_t direction)
116419: {
116419:     const char fname[] = "vcmToneStart";
116419: 
116419:     CSFLogDebug( logTag, "%s:tone=%d call_handle=%d dir=%d", fname, tone, call_handle, direction);
116419: 
116419:     VcmSIPCCBinding::getAudioTermination()->toneStart( map_tone_type(tone), (ToneDirection)direction,
116419:                                 alert_info, group_id, stream_id, FALSE );
116419:     /*
116419:      * Set delay value for multi-part tones and repeated tones.
116419:      * Currently the only multi-part tones are stutter and message
116419:      * waiting tones. The only repeated tones are call waiting and
116419:      * tone on hold tones.  If the DSP ever supports stutter and
116419:      * message waiting tones, these tones can be removed from this
116419:      * switch statement.
116419:      */
116419: 
116419:     /*
116419:     switch ( tone )
116419:     {
116419:     case VCM_MSG_WAITING_TONE:
116419:         lsm_start_multipart_tone_timer(tone, MSG_WAITING_DELAY, call_handle);
116419:         break;
116419: 
116419:     case VCM_HOLD_TONE:
116419:         lsm_start_continuous_tone_timer(tone, TOH_DELAY, call_handle);
116419:         break;
116419: 
116419:     default:
116419:         break;
116419:     }
116419:     */
116419: 
116419:     /*
116419:      * Update dcb->active_tone if start request
116419:      * is for an infinite duration tone.
116419:      */
116419:     //lsm_update_active_tone(tone, call_handle);
116419: }
116419: 
116419: /**
116419:  * Plays a short tone. uses the open audio path.
116419:  * If no audio path is open, plays on speaker.
116419:  *
116419:  * @param[in] tone       - tone type
116419:  * @param[in] alert_info - alertinfo header
116419:  * @param[in] call_handle    - call identifier
116419:  * @param[in] group_id - identifier of the group to which stream belongs
116419:  * @param[in] stream_id   - stream identifier.
116419:  * @param[in] direction  - network, speaker, both
116419:  *
116419:  * @return void
116419:  */
116419: 
116419: void vcmToneStartWithSpeakerAsBackup(vcm_tones_t tone,
116419:         short alert_info,
116419:         cc_call_handle_t  call_handle,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_uint16_t direction)
116419: {
116419:     const char fname[] = "vcmToneStartWithSpeakerAsBackup";
116419: 
116419:     CSFLogDebug( logTag, "%s:tone=%d call_handle=%d dir=%d", fname, tone, call_handle, direction);
116419: 
116419:     VcmSIPCCBinding::getAudioTermination()->toneStart( map_tone_type(tone), (ToneDirection)direction,
116419:                                 alert_info, group_id, stream_id, TRUE );
116419:     /*
116419:      * Update dcb->active_tone if start request
116419:      * is for an infinite duration tone.
116419:      */
116419:     //lsm_update_active_tone(tone, call_handle);
116419: }
116419: 
116419: /**
116419:  *  Stop the tone being played.
116419:  *
116419:  *  Description: Stop the tone being played currently
116419:  *
116419:  *
116419:  * @param[in] tone - tone to be stopeed
116419:  * @param[in] group_id - associated stream's group
116419:  * @param[in] stream_id - associated stream id
116419:  * @param[in] call_handle - the context (call) for this tone.
116419:  *
116419:  * @return void
116419:  *
116419:  */
116419: 
116419: void vcmToneStop(vcm_tones_t tone,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_call_handle_t call_handle)
116419: {
116419:     const char fname[] = "vcmToneStop";
116419: 
116419:     CSFLogDebug( logTag, "%s:tone=%d stream_id=%d", fname, tone, stream_id);
116419: /*
116419:     lsm_stop_multipart_tone_timer();
116419:     lsm_stop_continuous_tone_timer();
116419:     */
116419: 
116419:     VcmSIPCCBinding::getAudioTermination()->toneStop( map_tone_type(tone), group_id, stream_id );
116419: }
116419: 
116419: /**
116419:  *  should we remove from external API
116419:  *
116419:  *  @param[in]  mcap_id - Media Capability ID
116419:  *  @param[in]  group_id - group to which stream belongs
116419:  *  @param[in]  stream_id - stream identifier
116419:  *  @param[in]  call_handle - call identifier
116419:  *
116419:  *  @return  zero(0) for success; otherwise, ERROR for failure
116419:  *
116419:  */
116419: 
116419: short vcmTxOpen(cc_mcapid_t mcap_id,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_call_handle_t  call_handle)
116419: {
116419:     char        fname[] = "vcmTxOpen";
116419: 
116419:     CSFLogDebug( logTag, "%s: group_id=%d call_handle=%d", fname, group_id, call_handle);
116419: 
116419:     if (call_handle == CC_NO_CALL_ID) {
116419:         /* no operation when no call ID */
116419:         return VCM_ERROR;
116419:     }
116419:     return 0;
116419: }
116419: 
116419: /**
116419:  *  start tx stream
116419:  *  Note: For video calls, for a given call_handle there will be
116419:  *        two media lines and the corresponding group_id/stream_id pair.
116419:  *        One RTP session is requested from media server for each
116419:  *        media line(group/stream) i.e. a video call would result in
116419:  *        two rtp_sessions in our session info list created by two
116419:  *        calls to vcm_rx/tx with mcap_id of AUDIO and VIDEO respectively.
116419:  *
116419:  *  @param[in]   mcap_id      - media cap id
116419:  *  @param[in]   group_id     - group identifier to which the stream belongs
116419:  *  @param[in]   stream_id    - stream id of the given media type.
116419:  *  @param[in]   call_handle      - call identifier
116419:  *  @param[in]   payload      - payload type
116419:  *  @param[in]   tos          - bit marking
116419:  *  @param[in]   local_addr   - local address
116419:  *  @param[in]   local_port   - local port
116419:  *  @param[in]   remote_ip_addr - remote ip address
116419:  *  @param[in]   remote_port  - remote port
116419:  *  @param[in]   algorithmID  - crypto alogrithm ID
116419:  *  @param[in]   tx_key       - tx key used when algorithm ID is encrypting.
116419:  *  @param[in]   attrs        - media attributes
116419:  *
116419:  *  Returns: zero(0) for success; otherwise, ERROR for failure
116419:  *
116419:  */
116419: int vcmTxStart(cc_mcapid_t mcap_id,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_call_handle_t  call_handle,
116419:         vcm_media_payload_type_t payload,
116419:         short tos,
116419:         cpr_ip_addr_t *local_addr,
116419:         cc_uint16_t local_port,
116419:         cpr_ip_addr_t *remote_ip_addr,
116419:         cc_uint16_t remote_port,
116419:         vcm_crypto_algorithmID algorithmID,
116419:         vcm_crypto_key_t *tx_key,
116419:         vcm_mediaAttrs_t *attrs)
116419: {
116419:     const char fname[] = "vcmTxStart";
116419:     int         pt;
116419:     uint8_t    *key;
116419:     uint8_t    *salt;
116419:     cc_uint16_t    key_len;
116419:     cc_uint16_t    salt_len;
116419: 
116419:     char dottedIP[20];
116419:     csf_sprintf(dottedIP, sizeof(dottedIP), "%u.%u.%u.%u",
116419:                 (remote_ip_addr->u.ip4 >> 24) & 0xff, (remote_ip_addr->u.ip4 >> 16) & 0xff,
116419:                 (remote_ip_addr->u.ip4 >> 8) & 0xff, remote_ip_addr->u.ip4 & 0xff );
116419: 
116419:     CSFLogDebug( logTag, "%s: group_id=%d call_handle=%d payload=%d tos=%d local_port=%d remote=%s:%d algID=%d",
116419:         fname, group_id, call_handle, payload, tos, local_port,
116419:         dottedIP, remote_port, algorithmID);
116419: 
116419:     if (call_handle == CC_NO_CALL_ID) {
116419:         /* no operation when no call ID */
116419:         return VCM_ERROR;
116419:     }
116419: 
116419:     /* Set up crypto parameters */
116419:     switch ( algorithmID )
116419:     {
116419:     case VCM_AES_128_COUNTER:
116419:         if ( tx_key == NULL )
116419:         {
116419:             /* No key provided */
116419:             CSFLogDebug( logTag, "%s: No key for algorithm ID %d", fname, algorithmID);
116419:             return VCM_ERROR;
116419:         }
116419:         /* Set up key and Salt parameters */
116419:         key_len  = tx_key->key_len;
116419:         key      = &tx_key->key[0];
116419:         salt_len = tx_key->salt_len;
116419:         salt     = &tx_key->salt[0];
116419:         break;
116419: 
116419:     default:
116419:         /* Give dummy data to avoid passing NULL for key/salt */
116419:         key_len  = 0;
116419:         key      = (uint8_t *)"";
116419:         salt_len = 0;
116419:         salt     = (uint8_t *)"";
116419:         break;
116419:     }
116419: 
116419:     pt = map_VCM_Media_Payload_type(payload);
116419: 
116419:     switch ( mcap_id )
116419:     {
116419:     case CC_AUDIO_1:
116419:         if ( VcmSIPCCBinding::getAudioTermination() != NULL )
116419:             return VcmSIPCCBinding::getAudioTermination()->txStart( group_id, stream_id, pt,
116419:                                             attrs->audio.packetization_period, (attrs->audio.vad != 0),
116419:                                             tos, dottedIP, remote_port, attrs->audio.avt_payload_type,
116419:                                             map_algorithmID(algorithmID), key, key_len, salt, salt_len,
116419:                                             attrs->audio.mixing_mode, attrs->audio.mixing_party );
116419:         break;
116419: 
116419:     case CC_VIDEO_1:
116419:         if ( VcmSIPCCBinding::getVideoTermination() != NULL )
116419:            return VcmSIPCCBinding::getVideoTermination()->txStart( group_id, stream_id, pt,
116419:                                                                    0, 0, tos, dottedIP, remote_port, 0,
116419:                                                                    map_algorithmID(algorithmID), key, key_len, salt, salt_len, 0, 0 );
116419:         break;
116419: 
116419:     default:
116419:         break;
116419:     }
116419:     return VCM_ERROR;
116419: }
116419: 
116420: 
116420: /**
116420:  *  start tx stream
116420:  *  Same concept as vcmTxStart but for ICE/PeerConnection-based flows
116420:  *
116420:  *  @param[in]   mcap_id      - media cap id
116420:  *  @param[in]   group_id     - group identifier to which the stream belongs
116420:  *  @param[in]   stream_id    - stream id of the given media type.
116420:  *  @param[in]   level        - the m-line index
116420:  *  @param[in]   pc_stream_id - the media stream index (from PC.addStream())
116420:  *  @param[i]n   pc_track_id  - the track within the media stream
116420:  *  @param[in]   call_handle  - call handle
116420:  *  @param[in]  peerconnection - the peerconnection in use
116420:  *  @param[in]   payload      - payload type
116420:  *  @param[in]   tos          - bit marking
116420:  *  @param[in]   fingerprint_alg - the DTLS fingerprint algorithm
116420:  *  @param[in]   fingerprint  - the DTLS fingerprint
116420:  *  @param[in]   attrs        - media attributes
116420:  *
116420:  *  Returns: zero(0) for success; otherwise, ERROR for failure
116420:  *
116420:  */
116420: #define EXTRACT_DYNAMIC_PAYLOAD_TYPE(PTYPE) ((PTYPE)>>16)
116420: 
116420: int vcmTxStartICE(cc_mcapid_t mcap_id,
116420:         cc_groupid_t group_id,
116420:         cc_streamid_t stream_id,
116420:         int level,
116420:         int pc_stream_id,
116420:         int pc_track_id,
116420:         cc_call_handle_t  call_handle,
116420:         const char *peerconnection,
116420:         vcm_media_payload_type_t payload,
116420:         short tos,
116420:         const char *fingerprint_alg,
116420:         const char *fingerprint,
116420:         vcm_mediaAttrs_t *attrs)
116420: {
116420:   CSFLogDebug( logTag, "%s(%s)", __FUNCTION__, peerconnection);
116420: 
116420:   // Find the PC and get the stream
116420:   mozilla::ScopedDeletePtr<sipcc::PeerConnectionWrapper> pc(
116420:       sipcc::PeerConnectionImpl::AcquireInstance(peerconnection));
116420:   PR_ASSERT(pc);
116420:   if (!pc) {
116420:     return VCM_ERROR;
116420:   }
122169:   nsRefPtr<sipcc::LocalSourceStreamInfo> stream = pc->impl()->media()->
122169:     GetLocalStream(pc_stream_id);
116420: 
116420:   // Create the transport flows
116420:   mozilla::RefPtr<TransportFlow> rtp_flow =
116420:       vcmCreateTransportFlow(pc->impl(), level, false,
116420:                              fingerprint_alg, fingerprint);
118715:   if (!rtp_flow) {
118715:       CSFLogError( logTag, "Could not create RTP flow");
118715:       return VCM_ERROR;
118715:   }
116420:   mozilla::RefPtr<TransportFlow> rtcp_flow =
116420:       vcmCreateTransportFlow(pc->impl(), level, true,
116420:                              fingerprint_alg, fingerprint);
118715:   if (!rtcp_flow) {
118715:       CSFLogError( logTag, "Could not create RTCP flow");
118715:       return VCM_ERROR;
118715:   }
116420: 
116420:   if (CC_IS_AUDIO(mcap_id)) {
116420:     // Find the appropriate media conduit config
116420:     mozilla::AudioCodecConfig *config_raw;
116420:     int ret = vcmPayloadType2AudioCodec(payload, &config_raw);
116420:     if (ret) {
116420:       return VCM_ERROR;
116420:     }
116420: 
116420:     // Take possession of this pointer
116420:     mozilla::ScopedDeletePtr<mozilla::AudioCodecConfig> config(config_raw);
116420: 
116420:     // Instantiate an appropriate conduit
116420:     mozilla::RefPtr<mozilla::AudioSessionConduit> conduit =
116420:       mozilla::AudioSessionConduit::Create();
116420: 
124200:     if (!conduit || conduit->ConfigureSendMediaCodec(config))
116420:       return VCM_ERROR;
116420: 
116420:     mozilla::RefPtr<mozilla::MediaPipelineTransmit> pipeline =
116420:       new mozilla::MediaPipelineTransmit(
116420:         pc->impl()->GetMainThread().get(),
116420:         pc->impl()->GetSTSThread(),
116420:         stream->GetMediaStream(),
116420:         conduit, rtp_flow, rtcp_flow);
116420: 
116420:     CSFLogDebug(logTag, "Created audio pipeline %p, conduit=%p, pc_stream=%d pc_track=%d",
116420:                 pipeline.get(), conduit.get(), pc_stream_id, pc_track_id);
116420: 
116420:     // Now we have all the pieces, create the pipeline
116420:     stream->StorePipeline(pc_track_id, pipeline);
116420: 
116420:   } else if (CC_IS_VIDEO(mcap_id)) {
116420:     mozilla::VideoCodecConfig *config_raw;
116420:     int ret = vcmPayloadType2VideoCodec(payload, &config_raw);
116420:     if (ret) {
116420:       return VCM_ERROR;
116420:     }
116420: 
116420:     // Take possession of this pointer
116420:     mozilla::ScopedDeletePtr<mozilla::VideoCodecConfig> config(config_raw);
116420: 
116420:     // Instantiate an appropriate conduit
116420:     mozilla::RefPtr<mozilla::VideoSessionConduit> conduit =
116420:       mozilla::VideoSessionConduit::Create();
116420: 
116420:     // Find the appropriate media conduit config
124200:     if (!conduit || conduit->ConfigureSendMediaCodec(config))
116420:       return VCM_ERROR;
116420: 
116420:     // Create the pipeline
116420:     mozilla::RefPtr<mozilla::MediaPipeline> pipeline =
116420:         new mozilla::MediaPipelineTransmit(
116420:           pc->impl()->GetMainThread().get(),
116420:           pc->impl()->GetSTSThread(),
116420:           stream->GetMediaStream(),
116420:           conduit, rtp_flow, rtcp_flow);
116420: 
116420:     CSFLogDebug(logTag, "Created video pipeline %p, conduit=%p, pc_stream=%d pc_track=%d",
116420:                 pipeline.get(), conduit.get(), pc_stream_id, pc_track_id);
116420: 
116420:     // Now we have all the pieces, create the pipeline
116420:     stream->StorePipeline(pc_track_id, pipeline);
116420:   } else {
116420:     CSFLogError(logTag, "%s: mcap_id unrecognized", __FUNCTION__);
116420:     return VCM_ERROR;
116420:   }
116420: 
116420:   CSFLogDebug( logTag, "%s success", __FUNCTION__);
116420:   return 0;
116420: }
116420: 
116420: 
116419: /**
116419:  *  Close the transmit stream
116419:  *
116419:  *  @param[in] mcap_id - Media Capability ID
116419:  *  @param[in] group_id - identifier of the group to which stream belongs
116419:  *  @param[in] stream_id - stream id of the given media type.
116419:  *  @param[in] call_handle  - call identifier
116419:  *
116419:  *  @return     void
116419:  */
116419: 
116419: void vcmTxClose(cc_mcapid_t mcap_id,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_call_handle_t  call_handle)
116419: {
116419:     const char fname[] = "vcmTxClose";
116419: 
116419:     CSFLogDebug( logTag, "%s: group_id=%d call_handle=%d", fname, group_id, call_handle);
116419: 
116419:     if (call_handle == CC_NO_CALL_ID) {
116419:         /* no operation when no call ID */
116419:         return;
116419:     }
116419: 
116419:     switch ( mcap_id )
116419:     {
116419:     case CC_AUDIO_1:
116419:         if ( VcmSIPCCBinding::getAudioTermination() != NULL )
116419:             VcmSIPCCBinding::getAudioTermination()->txClose( group_id, stream_id);
116419:         break;
116419: 
116419:     case CC_VIDEO_1:
116419:         if ( VcmSIPCCBinding::getVideoTermination() != NULL )
116419:            VcmSIPCCBinding::getVideoTermination()->txClose( group_id, stream_id);
116419:         break;
116419: 
116419:     default:
116419:         break;
116419:     }
116419: }
116419: 
116420: #if 0
116419: static CodecRequestType
116419: map_codec_request_type( int request_type )
116419: {
116419:     switch ( request_type )
116419:     {
116419:     default:
116419:     case cip_sipcc_CodecMask_DSP_IGNORE:     return CodecRequestType_IGNORE;
116419:     case cip_sipcc_CodecMask_DSP_DECODEONLY: return CodecRequestType_DECODEONLY;
116419:     case cip_sipcc_CodecMask_DSP_ENCODEONLY: return CodecRequestType_ENCODEONLY;
116419:     case cip_sipcc_CodecMask_DSP_FULLDUPLEX: return CodecRequestType_FULLDUPLEX;
116419:     }
116419: }
116420: #endif
116419: 
116419: /**
116419:  * Get current list of audio codec that could be used
116419:  * @param request_type -
116419:  * The request_type should be VCM_DECODEONLY/ENCODEONLY/FULLDUPLEX/IGNORE
116419:  *
116419:  * @return A bit mask should be returned that specifies the list of the audio
116419:  * codecs. The bit mask should conform to the defines in this file.
116419:  * #define VCM_RESOURCE_G711     0x00000001
116419:  * #define VCM_RESOURCE_G729A    0x00000002
116419:  * ....
116419:  */
116419: 
116419: int vcmGetAudioCodecList(int request_type)
116419: {
116420: // Direct access to media layer replaced by locally stored codecMask
116420: // set in PeerConnectionImpl
116420: #if 0
116419:     const char fname[] = "vcmGetAudioCodecList";
116419:     int retVal;
116419:     int codecMask = 0;
116419: 
116419:     CSFLogDebug( logTag, "%s(request_type = %d)", fname, request_type);
116419: 
116419:     retVal = VcmSIPCCBinding::getAudioTermination() ? VcmSIPCCBinding::getAudioTermination()->getCodecList( map_codec_request_type(request_type) ) : 0;
116419: 
116419:     if ( retVal & AudioCodecMask_G711 ) {    codecMask |= cip_sipcc_CodecMask_DSP_RESOURCE_G711; CSFLogDebug( logTag, "%s", " G711"); }
116419:     if ( retVal & AudioCodecMask_LINEAR ) {  codecMask |= cip_sipcc_CodecMask_DSP_RESOURCE_LINEAR; CSFLogDebug( logTag, "%s", " LINEAR" ); }
116419:     if ( retVal & AudioCodecMask_G722 ) {    codecMask |= cip_sipcc_CodecMask_DSP_RESOURCE_G722; CSFLogDebug( logTag, "%s", " G722"); }
116419:     if ( retVal & AudioCodecMask_iLBC )  {   codecMask |= cip_sipcc_CodecMask_DSP_RESOURCE_iLBC; CSFLogDebug( logTag, "%s", " iLBC"); }
116419:     if ( retVal & AudioCodecMask_iSAC )   {  codecMask |= cip_sipcc_CodecMask_DSP_RESOURCE_iSAC; CSFLogDebug( logTag, "%s", " iSAC "); }
116419: 
116419:     CSFLogDebug( logTag, "%s(codec_mask = %X)", fname, codecMask);
116419:     return codecMask;
116420: #else
116420:   int codecMask = VcmSIPCCBinding::getAudioCodecs();
116420:   CSFLogDebug(logTag, "GetAudioCodecList returning %X", codecMask);
116420: 
116420:   return codecMask;
116420: #endif
116419: }
116419: 
116419: /**
116419:  * Get current list of video codec that could be used
116419:  * @param request_type -
116419:  * The request_type should be VCM_DECODEONLY/ENCODEONLY/FULLDUPLEX/IGNORE
116419:  *
116419:  * @return A bit mask should be returned that specifies the list of the audio
116419:  * codecs. The bit mask should conform to the defines in this file.
116419:  * #define VCM_RESOURCE_G711     0x00000001
116419:  * #define VCM_RESOURCE_G729A    0x00000002
116419:  * ....
116419:  */
116419: 
116419: #ifndef DSP_H264
116419: #define DSP_H264        0x00000001
116419: #endif
116419: 
116419: #ifndef DSP_H263
116419: #define DSP_H263        0x00000002
116419: #endif
116419: 
116419: int vcmGetVideoCodecList(int request_type)
116419: {
116420: // Direct access to media layer replaced by locally stored codecMask
116420: // set in PeerConnectionImpl
116420: #if 0
116419:     const char fname[] = "vcmGetVideoCodecList";
116419:     int retVal = 0;
116419:     int codecMask = 0;
116419: 
116419:     CSFLogDebug( logTag, "%s(request_type = %d)", fname, request_type);
116419: 
116419:     retVal = VcmSIPCCBinding::getVideoTermination() ? VcmSIPCCBinding::getVideoTermination()->getCodecList( map_codec_request_type(request_type) ) : 0;
116419: 
116419:     if ( retVal & VideoCodecMask_H264 )    codecMask |= DSP_H264;
116419:     if ( retVal & VideoCodecMask_H263 )    codecMask |= DSP_H263;
116419: 
116419:     CSFLogDebug( logTag, "%s(codec_mask = %X)", fname, codecMask);
116419: 
116419:     //return codecMask;
116419: 	return VCM_CODEC_RESOURCE_H264;
116420: #else
116420:   int codecMask = VcmSIPCCBinding::getVideoCodecs();
116420:   CSFLogDebug(logTag, "GetVideoCodecList returning %X", codecMask);
116420: 
116420:   return codecMask;
116420: #endif
116419: }
116419: 
116419: /**
116419:  * Get max supported H.264 video packetization mode.
116419:  * @return maximum supported video packetization mode for H.264. Value returned
116419:  * must be 0 or 1. Value 2 is not supported yet.
116419:  */
116419: int vcmGetVideoMaxSupportedPacketizationMode()
116419: {
116419:     return 0;
116419: }
116419: 
116419: /**
116419:  *  MEDIA control received from far end on signaling path
116419:  *
116419:  *  @param call_handle - call_handle of the call
116419:  *  @param to_encoder - the control request received
116419:  *        Only FAST_PICTURE_UPDATE is supported
116419:  *
116419:  *  @return  void
116419:  *
116419:  */
116419: 
116419: void vcmMediaControl(cc_call_handle_t  call_handle, vcm_media_control_to_encoder_t to_encoder)
116419: {
116419:     if ( to_encoder == VCM_MEDIA_CONTROL_PICTURE_FAST_UPDATE )
116419:     {
116419:     	StreamObserver* obs = VcmSIPCCBinding::getStreamObserver();
116419:     	if (obs != NULL)
116419:     	{
116419:     		obs->sendIFrame(call_handle);
116419:     	}
116419:     }
116419: }
116419: 
116419: /**
116419:  * Get the rx/tx stream statistics associated with the call.
116419:  *
116419:  * @param[in]  mcap_id  - media type (audio/video)
116419:  * @param[in]  group_id - group id of the stream
116419:  * @param[in]  stream_id - stram id of the stream
116419:  * @param[in]  call_handle - call identifier
116419:  * @param[out] rx_stats - ptr to the rx field in the stats struct
116419:  * @param[out] tx_stats - ptr to the tx field in the stats struct
116419:  *
116419:  */
116419: 
116419: int vcmGetRtpStats(cc_mcapid_t mcap_id,
116419:         cc_groupid_t group_id,
116419:         cc_streamid_t stream_id,
116419:         cc_call_handle_t  call_handle,
116419:         char *rx_stats,
116419:         char *tx_stats)
116419: {
116419:     return 0;
116419: }
116419: 
116419: /**
116419:  *  specifies DSCP marking for RTCP streams
116419:  *
116419:  *  @param group_id - call_handle of the call
116419:  *  @param dscp - the DSCP value to be used
116419:  *
116419:  *  @return  void
116419:  */
116419: 
116419: void vcmSetRtcpDscp(cc_groupid_t group_id, int dscp)
116419: {
116419:     // do nothing
116419: }
116419: 
116419: /**
116419:  *
116419:  * The wlan interface puts into unique situation where call control
116419:  * has to allocate the worst case bandwith before creating a
116419:  * inbound or outbound call. The function call will interface through
116419:  * media API into wlan to get the call bandwidth. The function
116419:  * return is asynchronous and will block till the return media
116419:  * callback signals to continue the execution.
116419:  *
116419:  * @note If not using WLAN interface simply return true
116419:  *
116419:  * @return true if the bandwidth can be allocated else false.
116419:  */
116419: 
116419: cc_boolean vcmAllocateBandwidth(cc_call_handle_t  call_handle, int sessions)
116419: {
116419:     return(TRUE);
116419: }
116419: 
116419: /**
116419:  *
116419:  * Free the bandwidth allocated for this call
116419:  * using the vcmAllocateBandwidth API
116419:  *
116419:  * @note  If not using WLAN provide a stub
116419:  */
116419: 
116419: void vcmRemoveBandwidth(cc_call_handle_t  call_handle)
116419: {
116419:     //do nothing
116419: }
116419: 
116419: /**
116419:  * @brief vcmActivateWlan
116419:  *
116419:  * Free the bandwidth allocated for this call
116419:  * using the vcmAllocateBandwidth API
116419:  *
116419:  * @note If not using WLAN provide a stub
116419:  */
116419: 
116419: void vcmActivateWlan(cc_boolean is_active)
116419: {
116419:     // do nothing
116419: }
116419: 
116419: /**
116419:  *  free the media pointer allocated in vcm_negotiate_attrs method
116419:  *
116419:  *  @param ptr - pointer to be freed
116419:  *
116419:  *  @return  void
116419:  */
116419: void vcmFreeMediaPtr(void *ptr)
116419: {
116419:   free(ptr);
116419: }
116419: 
116419: /**
116419:  * Verify if the SDP attributes for the requested video codec are acceptable
116419:  *
116419:  * This method is called for video codecs only. This method should parse the
116419:  * Video SDP attributes using the SDP helper API and verify if received
116419:  * attributes are acceptable. If the attributes are acceptable any attribute
116419:  * values if needed by vcmTxStart method should be bundled in the desired
116419:  * structure and its pointer should be returned in rccappptr. This opaque
116419:  * pointer shall be provided again when vcmTxStart is invoked.
116419:  *
116419:  * @param [in] media_type - codec for which we are negotiating
116419:  * @param [in] sdp_p - opaque SDP pointer to be used via SDP helper APIs
116419:  * @param [in] level - Parameter to be used with SDP helper APIs
116419:  * @param [out] rcapptr - variable to return the allocated attrib structure
116419:  *
116419:  * @return cc_boolean - true if attributes are accepted false otherwise
116419:  */
116419: 
116419: cc_boolean vcmCheckAttribs(cc_uint32_t media_type, void *sdp_p, int level, void **rcapptr)
116419: {
116419:     CSFLogDebug( logTag, "vcmCheckAttribs(): media=%d", media_type);
116419: 
116419:     cc_uint16_t     temp;
116419:     const char      *ptr;
116419:     uint32_t        t_uint;
116419:     struct h264_video *rcap;
116419: 
116419:     *rcapptr = NULL;
116419: 
116419:     switch (media_type)
116419:     {
116420:     case RTP_VP8:
116420:     	return TRUE;
116420: 
116419:     case RTP_H264_P0:
116419:     case RTP_H264_P1:
116419: 
116420:         rcap = (struct h264_video *) cpr_malloc( sizeof(struct h264_video) );
116419:         if ( rcap == NULL )
116419:         {
116419:             CSFLogDebugS( logTag, "vcmCheckAttribs(): Malloc Failed for rcap");
116419:             return FALSE;
116419:         }
116419:         memset( rcap, 0, sizeof(struct h264_video) );
116419: 
116419:         if ( (ptr = ccsdpAttrGetFmtpParamSets(sdp_p, level, 0, 1)) != NULL )
116419:         {
116419:             memset(rcap->sprop_parameter_set, 0, csf_countof(rcap->sprop_parameter_set));
116420:             sstrncpy(rcap->sprop_parameter_set, ptr, csf_countof(rcap->sprop_parameter_set));
116419:         }
116419: 
116419:         if ( ccsdpAttrGetFmtpPackMode(sdp_p, level, 0, 1, &temp) == SDP_SUCCESS )
116419:         {
116419:             rcap->packetization_mode = temp;
116419:         }
116419: 
116419:         if ( (ptr = ccsdpAttrGetFmtpProfileLevelId(sdp_p, level, 0, 1)) != NULL )
116419:         {
116419: #ifdef _WIN32
116419:             sscanf_s(ptr, "%x", &rcap->profile_level_id, sizeof(int*));
116419: #else
116419:             sscanf(ptr, "%x", &rcap->profile_level_id);
116419: #endif
116419:         }
116419: 
116419:         if ( ccsdpAttrGetFmtpMaxMbps(sdp_p, level, 0, 1, &t_uint) == SDP_SUCCESS )
116419:         {
116419:             rcap->max_mbps = t_uint;
116419:         }
116419: 
116419:         if ( ccsdpAttrGetFmtpMaxFs(sdp_p, level, 0, 1, &t_uint) == SDP_SUCCESS )
116419:         {
116419:             rcap->max_fs = t_uint;
116419:         }
116419: 
116419:         if ( ccsdpAttrGetFmtpMaxCpb(sdp_p, level, 0, 1, &t_uint) == SDP_SUCCESS )
116419:         {
116419:             rcap->max_cpb = t_uint;
116419:         }
116419: 
116419:         if ( ccsdpAttrGetFmtpMaxCpb(sdp_p, level, 0, 1, &t_uint) == SDP_SUCCESS )
116419:         {
116419:             rcap->max_dpb = t_uint;
116419:         }
116419: 
116419:         if ( ccsdpAttrGetFmtpMaxCpb(sdp_p, level, 0, 1, &t_uint) == SDP_SUCCESS )
116419:         {
116419:             rcap->max_br = t_uint;
116419:         }
116419: 
116419:         rcap->tias_bw = ccsdpGetBandwidthValue(sdp_p, level, 1);
116419:         if ( rcap->tias_bw == 0 )
116419:         {
116419:             // received bandwidth of 0 reject this
116419:             free(rcap);
116419:             return FALSE;
116419:         }
116419:         else if ( rcap->tias_bw == SDP_INVALID_VALUE )
116419:         {
116419:             // bandwidth not received pass 0 to ms
116419:             rcap->tias_bw = 0;
116419:         }
116419: 
116419:         CSFLogDebug( logTag, "vcmCheckAttribs(): Negotiated media attrs\nsprop=%s\npack_mode=%d\nprofile_level_id=%X\nmbps=%d\nmax_fs=%d\nmax_cpb=%d\nmax_dpb=%d\nbr=%d bw=%d\n",
116419:             rcap->sprop_parameter_set,
116419:             rcap->packetization_mode,
116419:             rcap->profile_level_id,
116419:             rcap->max_mbps,
116419:             rcap->max_fs,
116419:             rcap->max_cpb,
116419:             rcap->max_dpb,
116419:             rcap->max_br,
116419:             rcap->tias_bw);
116419: 
116419:         *rcapptr = rcap;
116419:         return TRUE;
116419: 
116419:     default:
116419:         return FALSE;
116419:     }
116419: }
116419: 
116419: /**
116419:  * Add Video attributes in the offer/answer SDP
116419:  *
116419:  * This method is called for video codecs only. This method should populate the
116419:  * Video SDP attributes using the SDP helper API
116419:  *
116419:  * @param [in] sdp_p - opaque SDP pointer to be used via SDP helper APIs
116419:  * @param [in] level - Parameter to be used with SDP helper APIs
116419:  * @param [in] media_type - codec for which the SDP attributes are to be populated
116419:  * @param [in] payload_number - RTP payload type used for the SDP
116419:  * @param [in] isOffer - cc_boolean indicating we are encoding an offer or an aswer
116419:  *
116419:  * @return void
116419:  */
116419: void vcmPopulateAttribs(void *sdp_p, int level, cc_uint32_t media_type,
116419:                           cc_uint16_t payload_number, cc_boolean isOffer)
116419: {
116419:     CSFLogDebug( logTag, "vcmPopulateAttribs(): media=%d PT=%d, isOffer=%d", media_type, payload_number, isOffer);
116419:     uint16_t a_inst;//, a_inst2, a_inst3, a_inst4;
116419:     int profile;
116419:     char profile_level_id[MAX_SPROP_LEN];
116419: 
116419:     switch (media_type)
116419:     {
116419:     case RTP_H264_P0:
116419:     case RTP_H264_P1:
116419: 
116419:         if ( ccsdpAddNewAttr(sdp_p, level, 0, SDP_ATTR_FMTP, &a_inst) != SDP_SUCCESS ) return;
116419: 
116419:         (void) ccsdpAttrSetFmtpPayloadType(sdp_p, level, 0, a_inst, payload_number);
116419: 
116419:         //(void) sdp_attr_set_fmtp_pack_mode(sdp_p, level, 0, a_inst, 1 /*packetization_mode*/);
116419:         //(void) sdp_attr_set_fmtp_parameter_sets(sdp_p, level, 0, a_inst, "J0KAFJWgUH5A,KM4H8n==");    // NAL units 27 42 80 14 95 a0 50 7e 40 28 ce 07 f2
116419: 
116419:         //profile = 0x42E000 + H264ToSDPLevel( vt_GetClientProfileLevel() );
116419:         profile = 0x42E00C;
116419:         csf_sprintf(profile_level_id, MAX_SPROP_LEN, "%X", profile);
116419:         (void) ccsdpAttrSetFmtpProfileLevelId(sdp_p, level, 0, a_inst, profile_level_id);
116419: 
116419:         //(void) sdp_attr_set_fmtp_max_mbps(sdp_p, level, 0, a_inst, max_mbps);
116419:         //(void) sdp_attr_set_fmtp_max_fs(sdp_p, level, 0, a_inst, max_fs);
116419:         //(void) sdp_attr_set_fmtp_max_cpb(sdp_p, level, 0, a_inst, max_cpb);
116419:         //(void) sdp_attr_set_fmtp_max_dpb(sdp_p, level, 0, a_inst, max_dpb);
116419:         //(void) sdp_attr_set_fmtp_max_br(sdp_p, level, 0, a_inst, max_br);
116419:         //(void) sdp_add_new_bw_line(sdp_p, level, &a_inst);
116419:         //(void) sdp_set_bw(sdp_p, level, a_inst, SDP_BW_MODIFIER_TIAS, tias_bw);
116419: 
116419:         break;
116419: 
116419:     default:
116419:         break;
116419:     }
116419: }
116419: 
116419: /**
116419:  * Send a DTMF digit
116419:  *
116419:  * This method is called for sending a DTMF tone for the specified duration
116419:  *
116419:  * @param [in] digit - the DTMF digit that needs to be played out.
116419:  * @param [in] duration - duration of the tone
116419:  * @param [in] direction - direction in which the tone needs to be played.
116419:  *
116419:  * @return void
116419:  */
116419: int vcmDtmfBurst(int digit, int duration, int direction)
116419: {
116419:     CSFLogDebug( logTag, "vcmDtmfBurst(): digit=%d duration=%d, direction=%d", digit, duration, direction);
116419:     StreamObserver* obs = VcmSIPCCBinding::getStreamObserver();
116419:     if(obs != NULL)
116419:     	obs->dtmfBurst(digit, duration, direction);
116419:     return 0;
116419: }
116419: 
116419: /**
116419:  * vcmGetILBCMode
116419:  *
116419:  * This method should return the mode that needs to be used in
116419:  * SDP
116419:  * @return int
116419:  */
116419: int vcmGetILBCMode()
116419: {
116419:     return 0;
116419: }
116419: 
116419: } // extern "C"
116420: 
116420: 
116420: #define EXTRACT_DYNAMIC_PAYLOAD_TYPE(PTYPE) ((PTYPE)>>16)
116420: #define CLEAR_DYNAMIC_PAYLOAD_TYPE(PTYPE)   (PTYPE & 0x0000FFFF)
116420: #define CHECK_DYNAMIC_PAYLOAD_TYPE(PTYPE)   (PTYPE & 0xFFFF0000)
116420: 
116420: static int vcmPayloadType2AudioCodec(vcm_media_payload_type_t payload_in,
116420:                                      mozilla::AudioCodecConfig **config) {
116420:   int wire_payload = -1;
116420:   // payload_in has the following bit setup
116420:   // upper 16 bits : Dynamic payload type
116420:   // lower 16 bits : VCM payload type
116420:   // Ex: For ISAC Codec: 103:41
116420:   //     For VP8  Codec: 120:120
116420: 
116420:   int payload = -1;
116420:   *config = NULL;
116420:   if (CHECK_DYNAMIC_PAYLOAD_TYPE(payload_in)) {
116420:     wire_payload = EXTRACT_DYNAMIC_PAYLOAD_TYPE(payload_in);
116420:     payload = CLEAR_DYNAMIC_PAYLOAD_TYPE(payload_in);
116420:   }
116420:   else {
116420:     //static payload type
116420:     wire_payload = payload_in;
116420:     payload = payload_in;
116420:   }
116420: 
116420:   switch(payload) {
116420:     case VCM_Media_Payload_G711Alaw64k:
116420:       *config = new mozilla::AudioCodecConfig(wire_payload, "PCMA", 8000, 80, 1, 64000);
116420:       break;
116420:     case VCM_Media_Payload_G711Ulaw64k:
116420:       *config = new mozilla::AudioCodecConfig(wire_payload, "PCMU", 8000, 80, 1, 64000);
116420:       break;
116420:     case VCM_Media_Payload_OPUS:
116420:       *config = new mozilla::AudioCodecConfig(wire_payload, "OPUS", 48000, 480, 1, 64000);
116420:       break;
116420:     case VCM_Media_Payload_ISAC:
116420:       //adaptive rate ISAC,30ms sample
116420:       *config = new mozilla::AudioCodecConfig(wire_payload, "ISAC", 16000, 480, 1, -1);
116420:       break;
116420:     case VCM_Media_Payload_ILBC20:
116420:       //ilBC 20ms sample
116420:       *config = new mozilla::AudioCodecConfig(wire_payload, "iLBC", 8000, 160, 1, 15200);
116420:       break;
116420:     case VCM_Media_Payload_ILBC30:
116420:       //ilBC 30ms sample
116420:       *config = new mozilla::AudioCodecConfig(wire_payload, "iLBC", 8000, 240, 1, 13300);
116420:       break;
116420:     case VCM_Media_Payload_G722_64k:
116420:     case VCM_Media_Payload_G722_56k:
116420:       //TODO: Check with Ekr, Derf if 64k and 56K are valid frequency rates for G722.1
116420:       // or G722.2
116420:       CSFLogError(logTag, "vcmPayloadType2AudioCodec Codec Not Implemented !");
120060:       PR_ASSERT(PR_FALSE);
116420:       return VCM_ERROR;
116420:     default:
116420:       CSFLogError(logTag, "vcmPayloadType2AudioCodec unknown codec. Apparent internal error");
120060:       PR_ASSERT(PR_FALSE);
116420:       return VCM_ERROR;
116420:   }
116420: 
116420:   return 0;
116420: }
116420: 
116420: static int vcmPayloadType2VideoCodec(vcm_media_payload_type_t payload_in,
116420:                               mozilla::VideoCodecConfig **config) {
116420:   int wire_payload = -1;
116420:   int payload = -1;
116420:   *config = NULL;
116420: 
116420:   if (CHECK_DYNAMIC_PAYLOAD_TYPE(payload_in)) {
116420:     wire_payload = EXTRACT_DYNAMIC_PAYLOAD_TYPE(payload_in);
116420:     payload = CLEAR_DYNAMIC_PAYLOAD_TYPE(payload_in);
116420:   }
116420:   else {
116420:     //static payload type
116420:     wire_payload = payload_in;
116420:     payload = payload_in;
116420:   }
116420: 
116420:   switch(payload)
116420:   {
116420:     case VCM_Media_Payload_I420:
116420:       *config = new mozilla::VideoCodecConfig(wire_payload, "I420", 176, 144);
116420:       break;
116420:     case VCM_Media_Payload_VP8:
116420:       *config = new mozilla::VideoCodecConfig(wire_payload, "VP8", 640, 480);
116420:       break;
116420:     default:
116420:       CSFLogError(logTag, "vcmPayloadType2VideoCodec unknown codec. Apparent internal error");
120060:       PR_ASSERT(PR_FALSE);
116420:       return VCM_ERROR;
116420:   }
116420:   return 0;
116420: }
116420: 
116420: 
116420: 
116420: static mozilla::RefPtr<TransportFlow>
116420: vcmCreateTransportFlow(sipcc::PeerConnectionImpl *pc, int level, bool rtcp,
116420:                        const char *fingerprint_alg,
116420:                        const char *fingerprint) {
116420: 
116420:   // TODO(ekr@rtfm.com): Check that if the flow already exists the digest
116420:   // is the same. The only way that can happen is if
116420:   //
116420:   // (a) We have an error or
116420:   // (b) The other side bundled but had mismatched digests for each line
116420:   //
116420:   // Not clear that either of these cases matters.
116420:   mozilla::RefPtr<TransportFlow> flow;
122169:   flow = pc->media()->GetTransportFlow(level, rtcp);
116420: 
116420:   if (!flow) {
116420:     CSFLogDebug(logTag, "Making new transport flow for level=%d rtcp=%s", level, rtcp ? "true" : "false");
116420: 
116420:     char id[32];
116420:     PR_snprintf(id, sizeof(id), "%s:%d,%s",
116420:                 pc->GetHandle().c_str(), level, rtcp ? "rtcp" : "rtp");
116420:     flow = new TransportFlow(id);
116420: 
120253: 
122169:     ScopedDeletePtr<TransportLayerIce> ice(
122169:         new TransportLayerIce("flow", pc->media()->ice_ctx(),
122169:                               pc->media()->ice_media_stream(level-1),
116420:                               rtcp ? 2 : 1));
120253: 
120253:     ScopedDeletePtr<TransportLayerDtls> dtls(new TransportLayerDtls());
116420:     dtls->SetRole(pc->GetRole() == sipcc::PeerConnectionImpl::kRoleOfferer ?
116420:                   TransportLayerDtls::CLIENT : TransportLayerDtls::SERVER);
116420:     dtls->SetIdentity(pc->GetIdentity());
116420: 
116420:     unsigned char remote_digest[TransportLayerDtls::kMaxDigestLength];
116420:     size_t digest_len;
116420: 
116420:     nsresult res = DtlsIdentity::ParseFingerprint(fingerprint,
116420:                                                   remote_digest,
116420:                                                   sizeof(remote_digest),
116420:                                                   &digest_len);
116420:     if (!NS_SUCCEEDED(res)) {
116420:       CSFLogError(logTag, "Could not convert fingerprint");
116420:       return NULL;
116420:     }
116420:     res = dtls->SetVerificationDigest(fingerprint_alg, remote_digest, digest_len);
116420:     if (!NS_SUCCEEDED(res)) {
116420:       CSFLogError(logTag, "Could not set remote DTLS digest");
116420:       return NULL;
116420:     }
116420: 
116452:     std::vector<uint16_t> srtp_ciphers;
116420:     srtp_ciphers.push_back(SRTP_AES128_CM_HMAC_SHA1_80);
116420:     srtp_ciphers.push_back(SRTP_AES128_CM_HMAC_SHA1_32);
116420: 
116420:     res = dtls->SetSrtpCiphers(srtp_ciphers);
116420:     if (!NS_SUCCEEDED(res)) {
116420:       CSFLogError(logTag, "Couldn't set SRTP ciphers");
116420:       return NULL;
116420:     }
116420: 
120253:     std::queue<TransportLayer *> layers;
120253:     layers.push(ice.forget());
120253:     layers.push(dtls.forget());
120253: 
120253: 
120253:     // Layers are now owned by the flow.
122169:     nsresult rv = pc->media()->ice_ctx()->thread()->Dispatch(
120253:         WrapRunnableRet(flow, &TransportFlow::PushLayers, layers, &res),
120253:         NS_DISPATCH_SYNC);
120253: 
120253:     if (NS_FAILED(rv) || NS_FAILED(res)) {
120253:       return NULL;
120253:     }
116420: 
122169:     pc->media()->AddTransportFlow(level, rtcp, flow);
116420:   }
116420: 
116420:   return flow;
116420: }
