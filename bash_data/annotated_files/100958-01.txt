     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 59513: /* vim:set ts=4 sw=4 et tw=78: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 46498: #include "base/basictypes.h"
 46498: 
 46498: #include "nsIDOMXULElement.h"
 46498: 
     1: #include "prmem.h"
 42923: #include "prenv.h"
     1: 
     1: #include "nsIServiceManager.h"
 64654: #include "nsMathUtils.h"
     1: 
     1: #include "nsContentUtils.h"
     1: 
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDOMCanvasRenderingContext2D.h"
     1: #include "nsICanvasRenderingContextInternal.h"
 42402: #include "nsHTMLCanvasElement.h"
 64654: #include "nsSVGEffects.h"
     1: #include "nsPresContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIVariant.h"
     1: 
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIFrame.h"
     1: #include "nsDOMError.h"
     1: #include "nsIScriptError.h"
     1: 
 38849: #include "nsCSSParser.h"
 63693: #include "mozilla/css/StyleRule.h"
 48174: #include "mozilla/css/Declaration.h"
 31311: #include "nsComputedDOMStyle.h"
  3964: #include "nsStyleSet.h"
     1: 
     1: #include "nsPrintfCString.h"
     1: 
     1: #include "nsReadableUtils.h"
     1: 
     1: #include "nsColor.h"
     1: #include "nsGfxCIID.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDOMWindow.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeNode.h"
     1: #include "nsIXPConnect.h"
 64542: #include "nsDisplayList.h"
     1: 
     1: #include "nsTArray.h"
     1: 
     1: #include "imgIEncoder.h"
     1: 
     1: #include "gfxContext.h"
     1: #include "gfxASurface.h"
  6313: #include "gfxImageSurface.h"
     1: #include "gfxPlatform.h"
  3964: #include "gfxFont.h"
 19733: #include "gfxBlur.h"
 46890: #include "gfxUtils.h"
 93575: #include "nsRenderingContext.h"
     1: 
     1: #include "nsFrameManager.h"
 46498: #include "nsFrameLoader.h"
 73724: #include "nsBidi.h"
 16043: #include "nsBidiPresUtils.h"
 42402: #include "Layers.h"
 29572: #include "CanvasUtils.h"
 42553: #include "nsIMemoryReporter.h"
 55007: #include "nsStyleUtil.h"
 63836: #include "CanvasImageCache.h"
 55007: 
 46890: #include <algorithm>
 93202: 
 93202: #include "jsapi.h"
 95834: #include "jsfriendapi.h"
 93202: 
 93202: #include "mozilla/Assertions.h"
 98543: #include "mozilla/CheckedInt.h"
 47933: #include "mozilla/dom/ContentParent.h"
 93202: #include "mozilla/dom/ImageData.h"
 47933: #include "mozilla/dom/PBrowserParent.h"
 46498: #include "mozilla/ipc/DocumentRendererParent.h"
 93202: #include "mozilla/ipc/PDocumentRendererParent.h"
 46890: 
 46498: // windows.h (included by chromium code) defines this, in its infinite wisdom
 46498: #undef DrawText
 46799: 
 72739: using namespace mozilla;
 72739: using namespace mozilla::CanvasUtils;
 72739: using namespace mozilla::dom;
 46890: using namespace mozilla::ipc;
 42402: using namespace mozilla::layers;
 17010: 
 67820: static float kDefaultFontSize = 10.0;
 67820: static NS_NAMED_LITERAL_STRING(kDefaultFontName, "sans-serif");
 67820: static NS_NAMED_LITERAL_STRING(kDefaultFontStyle, "10px sans-serif");
 67820: 
 42553: /* Memory reporter stuff */
 42553: static nsIMemoryReporter *gCanvasMemoryReporter = nsnull;
 42553: static PRInt64 gCanvasMemoryUsed = 0;
 42553: 
 72640: static PRInt64 GetCanvasMemoryUsed() {
 42553:     return gCanvasMemoryUsed;
 42553: }
 42553: 
 72640: // This is KIND_OTHER because it's not always clear where in memory the pixels of
 70251: // a canvas are stored.  Furthermore, this memory will be tracked by the
 70251: // underlying surface implementations.  See bug 655638 for details.
 42553: NS_MEMORY_REPORTER_IMPLEMENT(CanvasMemory,
 69726:     "canvas-2d-pixel-bytes",
 72640:     KIND_OTHER,
 72640:     UNITS_BYTES,
 72640:     GetCanvasMemoryUsed,
 70251:     "Memory used by 2D canvases. Each canvas requires (width * height * 4) "
 72640:     "bytes.")
 42553: 
 46756: static void
 46756: CopyContext(gfxContext* dest, gfxContext* src)
 46756: {
 46756:     dest->Multiply(src->CurrentMatrix());
 46756: 
 46756:     nsRefPtr<gfxPath> path = src->CopyPath();
 46756:     dest->NewPath();
 46756:     dest->AppendPath(path);
 46756: 
 46756:     nsRefPtr<gfxPattern> pattern = src->GetPattern();
 46756:     dest->SetPattern(pattern);
 46756: 
 46756:     dest->SetLineWidth(src->CurrentLineWidth());
 46756:     dest->SetLineCap(src->CurrentLineCap());
 46756:     dest->SetLineJoin(src->CurrentLineJoin());
 46756:     dest->SetMiterLimit(src->CurrentMiterLimit());
 46756:     dest->SetFillRule(src->CurrentFillRule());
 46756: 
 46756:     dest->SetAntialiasMode(src->CurrentAntialiasMode());
 72744: 
 72744:     AutoFallibleTArray<gfxFloat, 10> dashes;
 72744:     double dashOffset;
 72744:     if (src->CurrentDash(dashes, &dashOffset)) {
 72744:         dest->SetDash(dashes.Elements(), dashes.Length(), dashOffset);
 72744:     }
 46756: }
 46756: 
     1: /**
     1:  ** nsCanvasGradient
     1:  **/
     1: #define NS_CANVASGRADIENT_PRIVATE_IID \
     1:     { 0x491d39d8, 0x4058, 0x42bd, { 0xac, 0x76, 0x70, 0xd5, 0x62, 0x7f, 0x02, 0x10 } }
 90283: class nsCanvasGradient MOZ_FINAL : public nsIDOMCanvasGradient
     1: {
     1: public:
     1:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_CANVASGRADIENT_PRIVATE_IID)
     1: 
 38849:     nsCanvasGradient(gfxPattern* pat)
 38849:         : mPattern(pat)
     1:     {
     1:     }
     1: 
 27042:     gfxPattern* GetPattern() {
 27042:         return mPattern;
     1:     }
     1: 
     1:     /* nsIDOMCanvasGradient */
     1:     NS_IMETHOD AddColorStop (float offset,
     1:                              const nsAString& colorstr)
     1:     {
 67714:         if (!FloatValidate(offset) || offset < 0.0 || offset > 1.0)
 67714:             return NS_ERROR_DOM_INDEX_SIZE_ERR;
 67714: 
     1:         nscolor color;
 38849:         nsCSSParser parser;
 38849:         nsresult rv = parser.ParseColorString(nsString(colorstr),
 38849:                                               nsnull, 0, &color);
     1:         if (NS_FAILED(rv))
     1:             return NS_ERROR_DOM_SYNTAX_ERR;
     1: 
 16154:         mPattern->AddColorStop(offset, gfxRGBA(color));
 16154: 
     1:         return NS_OK;
     1:     }
     1: 
     1:     NS_DECL_ISUPPORTS
     1: 
     1: protected:
 16154:     nsRefPtr<gfxPattern> mPattern;
     1: };
     1: 
     1: NS_DEFINE_STATIC_IID_ACCESSOR(nsCanvasGradient, NS_CANVASGRADIENT_PRIVATE_IID)
     1: 
     1: NS_IMPL_ADDREF(nsCanvasGradient)
     1: NS_IMPL_RELEASE(nsCanvasGradient)
     1: 
 40490: DOMCI_DATA(CanvasGradient, nsCanvasGradient)
 40490: 
     1: NS_INTERFACE_MAP_BEGIN(nsCanvasGradient)
     1:   NS_INTERFACE_MAP_ENTRY(nsCanvasGradient)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasGradient)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasGradient)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
     1: NS_INTERFACE_MAP_END
     1: 
     1: /**
     1:  ** nsCanvasPattern
     1:  **/
     1: #define NS_CANVASPATTERN_PRIVATE_IID \
     1:     { 0xb85c6c8a, 0x0624, 0x4530, { 0xb8, 0xee, 0xff, 0xdf, 0x42, 0xe8, 0x21, 0x6d } }
 90283: class nsCanvasPattern MOZ_FINAL : public nsIDOMCanvasPattern
     1: {
     1: public:
     1:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_CANVASPATTERN_PRIVATE_IID)
     1: 
 16154:     nsCanvasPattern(gfxPattern* pat,
  7710:                     nsIPrincipal* principalForSecurityCheck,
 79445:                     bool forceWriteOnly,
 79445:                     bool CORSUsed)
 16154:         : mPattern(pat),
  7710:           mPrincipal(principalForSecurityCheck),
 78159:           mForceWriteOnly(forceWriteOnly),
 78159:           mCORSUsed(CORSUsed)
  7710:     {
  7710:     }
     1: 
 78159:     gfxPattern* GetPattern() const {
 27042:         return mPattern;
     1:     }
     1: 
 78159:     nsIPrincipal* Principal() const { return mPrincipal; }
 79445:     bool GetForceWriteOnly() const { return mForceWriteOnly; }
 79445:     bool GetCORSUsed() const { return mCORSUsed; }
     1: 
     1:     NS_DECL_ISUPPORTS
     1: 
     1: protected:
 16154:     nsRefPtr<gfxPattern> mPattern;
  7710:     nsCOMPtr<nsIPrincipal> mPrincipal;
 79445:     const bool mForceWriteOnly;
 79445:     const bool mCORSUsed;
     1: };
     1: 
     1: NS_DEFINE_STATIC_IID_ACCESSOR(nsCanvasPattern, NS_CANVASPATTERN_PRIVATE_IID)
     1: 
     1: NS_IMPL_ADDREF(nsCanvasPattern)
     1: NS_IMPL_RELEASE(nsCanvasPattern)
     1: 
 40490: DOMCI_DATA(CanvasPattern, nsCanvasPattern)
 40490: 
     1: NS_INTERFACE_MAP_BEGIN(nsCanvasPattern)
     1:   NS_INTERFACE_MAP_ENTRY(nsCanvasPattern)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasPattern)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasPattern)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
     1: NS_INTERFACE_MAP_END
     1: 
     1: /**
 15295:  ** nsTextMetrics
 15295:  **/
 15295: #define NS_TEXTMETRICS_PRIVATE_IID \
 15295:     { 0xc5b1c2f9, 0xcb4f, 0x4394, { 0xaf, 0xe0, 0xc6, 0x59, 0x33, 0x80, 0x8b, 0xf3 } }
 15295: class nsTextMetrics : public nsIDOMTextMetrics
 15295: {
 15295: public:
 15295:     nsTextMetrics(float w) : width(w) { }
 15295: 
 15295:     virtual ~nsTextMetrics() { }
 15295: 
 15295:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_TEXTMETRICS_PRIVATE_IID)
 15295: 
 15295:     NS_IMETHOD GetWidth(float* w) {
 15295:         *w = width;
 15295:         return NS_OK;
 15295:     }
 15295: 
 15295:     NS_DECL_ISUPPORTS
 15295: 
 15295: private:
 15295:     float width;
 15295: };
 15295: 
 15295: NS_DEFINE_STATIC_IID_ACCESSOR(nsTextMetrics, NS_TEXTMETRICS_PRIVATE_IID)
 15295: 
 15295: NS_IMPL_ADDREF(nsTextMetrics)
 15295: NS_IMPL_RELEASE(nsTextMetrics)
 15295: 
 40490: DOMCI_DATA(TextMetrics, nsTextMetrics)
 40490: 
 15295: NS_INTERFACE_MAP_BEGIN(nsTextMetrics)
 15295:   NS_INTERFACE_MAP_ENTRY(nsTextMetrics)
 15295:   NS_INTERFACE_MAP_ENTRY(nsIDOMTextMetrics)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(TextMetrics)
 15295:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 15295: NS_INTERFACE_MAP_END
 15295: 
 16043: struct nsCanvasBidiProcessor;
100504: class CanvasRenderingContext2DUserData;
 16043: 
 15295: /**
     1:  ** nsCanvasRenderingContext2D
     1:  **/
     1: class nsCanvasRenderingContext2D :
     1:     public nsIDOMCanvasRenderingContext2D,
     1:     public nsICanvasRenderingContextInternal
     1: {
     1: public:
     1:     nsCanvasRenderingContext2D();
     1:     virtual ~nsCanvasRenderingContext2D();
     1: 
     1:     nsresult Redraw();
     1: 
     1:     // nsICanvasRenderingContextInternal
 42402:     NS_IMETHOD SetCanvasElement(nsHTMLCanvasElement* aParentCanvas);
     1:     NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height);
 77560:     void Initialize(nsIDocShell *shell, PRInt32 width, PRInt32 height);
 31123:     NS_IMETHOD InitializeWithSurface(nsIDocShell *shell, gfxASurface *surface, PRInt32 width, PRInt32 height);
 79445:     bool EnsureSurface();
 93959:     NS_IMETHOD Render(gfxContext *ctx,
 93959:                       gfxPattern::GraphicsFilter aFilter,
 93959:                       PRUint32 aFlags = RenderFlagPremultAlpha);
  6313:     NS_IMETHOD GetInputStream(const char* aMimeType,
  6313:                               const PRUnichar* aEncoderOptions,
     1:                               nsIInputStream **aStream);
 14812:     NS_IMETHOD GetThebesSurface(gfxASurface **surface);
 72428:     mozilla::TemporaryRef<mozilla::gfx::SourceSurface> GetSurfaceSnapshot()
 72428:         { return nsnull; }
 72428: 
 79445:     NS_IMETHOD SetIsOpaque(bool isOpaque);
 50903:     NS_IMETHOD Reset();
 73612:     virtual already_AddRefed<CanvasLayer> GetCanvasLayer(nsDisplayListBuilder* aBuilder,
 64542:                                                          CanvasLayer *aOldLayer,
 47731:                                                          LayerManager *aManager);
 79445:     virtual bool ShouldForceInactiveLayer(LayerManager *aManager);
 73612:     virtual void MarkContextClean();
 79445:     NS_IMETHOD SetIsIPC(bool isIPC);
 63841:     // this rect is in canvas device space
 46498:     NS_IMETHOD Redraw(const gfxRect &r);
 63841:     // this rect is in mThebes's current user space
 63841:     NS_IMETHOD RedrawUser(const gfxRect &r);
 38331: 
 43655:     // nsISupports interface + CC
 43655:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 43655: 
 43655:     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsCanvasRenderingContext2D, nsIDOMCanvasRenderingContext2D)
     1: 
     1:     // nsIDOMCanvasRenderingContext2D interface
     1:     NS_DECL_NSIDOMCANVASRENDERINGCONTEXT2D
     1: 
 16154:     enum Style {
     1:         STYLE_STROKE = 0,
     1:         STYLE_FILL,
 16154:         STYLE_SHADOW,
 16154:         STYLE_MAX
     1:     };
     1: 
 63842:     class PathAutoSaveRestore
 63842:     {
 63842:     public:
 63842:         PathAutoSaveRestore(nsCanvasRenderingContext2D* aCtx) :
 63842:           mContext(aCtx->mThebes)
 63842:         {
 63842:             if (aCtx->mHasPath) {
 63842:                 mPath = mContext->CopyPath();
 63842:             }
 63842:         }
 63842:         ~PathAutoSaveRestore()
 63842:         {
 63842:             mContext->NewPath();
 63842:             if (mPath) {
 63842:                 mContext->AppendPath(mPath);
 63842:             }
 63842:         }
 63842:     private:
 63842:         gfxContext *mContext;
 63842:         nsRefPtr<gfxPath> mPath;
 63842:     };
 63842:     friend class PathAutoSaveRestore;
100504:     friend class CanvasRenderingContext2DUserData;
 63842: 
 19733: protected:
 93202:     nsresult GetImageDataArray(JSContext* aCx, int32_t aX, int32_t aY,
 93202:                                uint32_t aWidth, uint32_t aHeight,
 93202:                                JSObject** aRetval);
 93202: 
 38331:     /**
 38331:      * The number of living nsCanvasRenderingContexts.  When this goes down to
 38331:      * 0, we free the premultiply and unpremultiply tables, if they exist.
 38331:      */
 38331:     static PRUint32 sNumLivingContexts;
 38331: 
 38331:     /**
 38331:      * Lookup table used to speed up GetImageData().
 38331:      */
 38331:     static PRUint8 (*sUnpremultiplyTable)[256];
 38331: 
 38331:     /**
 38331:      * Lookup table used to speed up PutImageData().
 38331:      */
 38331:     static PRUint8 (*sPremultiplyTable)[256];
 38331: 
 19733:     // Some helpers.  Doesn't modify acolor on failure.
 38908:     nsresult SetStyleFromStringOrInterface(const nsAString& aStr, nsISupports *aInterface, Style aWhichStyle);
 38908:     nsresult GetStyleAsStringOrInterface(nsAString& aStr, nsISupports **aInterface, PRInt32 *aType, Style aWhichStyle);
 38908: 
     1:     void StyleColorToString(const nscolor& aColor, nsAString& aStr);
     1: 
     1:     void DirtyAllStyles();
 19733:     /**
 19733:      * applies the given style as the current source. If the given style is
 19733:      * a solid color, aUseGlobalAlpha indicates whether to multiply the alpha
 19733:      * by global alpha, and is ignored otherwise.
 19733:      */
 79445:     void ApplyStyle(Style aWhichStyle, bool aUseGlobalAlpha = true);
     1: 
 38331:     /**
 38331:      * Creates the unpremultiply lookup table, if it doesn't exist.
 38331:      */
 38331:     void EnsureUnpremultiplyTable();
 38331: 
 38331:     /**
 38331:      * Creates the premultiply lookup table, if it doesn't exist.
 38331:      */
 38331:     void EnsurePremultiplyTable();
 38331: 
 46890:     /**
 46890:      * Returns the image format this canvas should be allocated using. Takes
 46890:      * into account mOpaque, platform requirements, etc.
 46890:      */
 46890:     gfxASurface::gfxImageFormat GetImageFormat() const;
 46890: 
     1:     // Member vars
     1:     PRInt32 mWidth, mHeight;
 79445:     bool mValid;
 79445:     bool mZero;
 79445:     bool mOpaque;
 79445:     bool mResetLayer;
 79445:     bool mIPC;
 46890: 
 43655:     // the canvas element we're a context of
 43655:     nsCOMPtr<nsIDOMHTMLCanvasElement> mCanvasElement;
 43655:     nsHTMLCanvasElement *HTMLCanvasElement() {
 43655:         return static_cast<nsHTMLCanvasElement*>(mCanvasElement.get());
 43655:     }
     1: 
 77560:     // Initialize the Thebes rendering context
 77560:     void CreateThebes();
 77560: 
 31123:     // If mCanvasElement is not provided, then a docshell is
 31123:     nsCOMPtr<nsIDocShell> mDocShell;
100504:     nsTArray<CanvasRenderingContext2DUserData*> mUserDatas;
 31123: 
 42402:     // our drawing surfaces, contexts, and layers
 16154:     nsRefPtr<gfxContext> mThebes;
 16154:     nsRefPtr<gfxASurface> mSurface;
 79445:     bool mSurfaceCreated;
     1: 
     1:     PRUint32 mSaveCount;
 16154: 
 16154:     /**
 16362:      * Flag to avoid duplicate calls to InvalidateFrame. Set to true whenever
 16362:      * Redraw is called, reset to false when Render is called.
 16362:      */
 79445:     bool mIsEntireFrameInvalid;
 63841:     /**
 63841:      * When this is set, the first call to Redraw(gfxRect) should set
 63841:      * mIsEntireFrameInvalid since we expect it will be followed by
 63841:      * many more Redraw calls.
 63841:      */
 79445:     bool mPredictManyRedrawCalls;
 63842:     /**
 63842:      * This is set whenever there's a nonempty path set by the API user.
 63842:      */
 79445:     bool mHasPath;
 29573: 
 29573:     /**
 29573:      * Number of times we've invalidated before calling redraw
 29573:      */
 29573:     PRUint32 mInvalidateCount;
 29573:     static const PRUint32 kCanvasMaxInvalidateCount = 100;
 16362: 
 16362:     /**
 54783:      * Returns true iff the the given operator should affect areas of the
 54783:      * destination where the source is transparent. Among other things, this
 54783:      * implies that a fully transparent source would still affect the canvas.
 54783:      */
 79445:     bool OperatorAffectsUncoveredAreas(gfxContext::GraphicsOperator op) const
 54783:     {
 54783:         return op == gfxContext::OPERATOR_IN ||
 54783:                op == gfxContext::OPERATOR_OUT ||
 54783:                op == gfxContext::OPERATOR_DEST_IN ||
 54783:                op == gfxContext::OPERATOR_DEST_ATOP;
 54783:     }
 54783: 
 54783:     /**
 19733:      * Returns true iff a shadow should be drawn along with a
 19733:      * drawing operation.
 19733:      */
 79445:     bool NeedToDrawShadow()
 19733:     {
 19733:         ContextState& state = CurrentState();
 19733: 
 73030:         // The spec says we should not draw shadows when the alpha value is 0,
 73030:         // regardless of the operator being used.
 36899:         return state.StyleIsColor(STYLE_SHADOW) &&
 36899:                NS_GET_A(state.colorStyles[STYLE_SHADOW]) > 0 &&
 73030:                (state.shadowOffset != gfxPoint(0, 0) || state.shadowBlur != 0);
 19733:     }
 19733: 
 19733:     /**
 54783:      * Checks the current state to determine if an intermediate surface would
 54783:      * be necessary to complete a drawing operation. Does not check the
 54783:      * condition pertaining to global alpha and patterns since that does not
 54783:      * pertain to all drawing operations.
 54783:      */
 79445:     bool NeedToUseIntermediateSurface()
 54783:     {
 77560:         if (!mThebes) {
 77560:             // Haven't created a surface yet, default is OVER.
 77560:             return OperatorAffectsUncoveredAreas(gfxContext::OPERATOR_OVER);
 77560:         }
 77560:      
 54783:         // certain operators always need an intermediate surface, except
 54783:         // with quartz since quartz does compositing differently than cairo
 54783:         return OperatorAffectsUncoveredAreas(mThebes->CurrentOperator());
 54783: 
 54783:         // XXX there are other unhandled cases but they should be investigated
 54783:         // first to ensure we aren't using an intermediate surface unecessarily
 54783:     }
 54783: 
 54783:     /**
 36900:      * If the current operator is "source" then clear the destination before we
 36900:      * draw into it, to simulate the effect of an unbounded source operator.
 19733:      */
 36900:     void ClearSurfaceForUnboundedSource()
 19733:     {
 77560:         if (!mThebes) {
 77560:             // Haven't created a surface yet, default is OVER.
 77560:             return;
 77560:         }
 77560: 
 36900:         gfxContext::GraphicsOperator current = mThebes->CurrentOperator();
 36900:         if (current != gfxContext::OPERATOR_SOURCE)
 36900:             return;
 36900:         mThebes->SetOperator(gfxContext::OPERATOR_CLEAR);
 36900:         // It doesn't really matter what the source is here, since Paint
 36900:         // isn't bounded by the source and the mask covers the entire clip
 36900:         // region.
 36900:         mThebes->Paint();
 36900:         mThebes->SetOperator(current);
 19733:     }
 19733: 
 19733:     /**
 19733:      * Returns true iff the current source is such that global alpha would not
 19733:      * be handled correctly without the use of an intermediate surface.
 19733:      */
 79445:     bool NeedIntermediateSurfaceToHandleGlobalAlpha(Style aWhichStyle)
 19733:     {
 19733:         return CurrentState().globalAlpha != 1.0 && !CurrentState().StyleIsColor(aWhichStyle);
 19733:     }
 19733: 
 19733:     /**
 19733:      * Initializes the drawing of a shadow onto the canvas. The returned context
 19733:      * should have the shadow shape drawn onto it, and then ShadowFinalize
 19733:      * should be called. The return value is null if an error occurs.
 19733:      * @param extents The extents of the shadow object, in device space.
 19733:      * @param blur A newly contructed gfxAlphaBoxBlur, made with the default
 19733:      *  constructor and left uninitialized.
 19733:      * @remark The lifetime of the return value is tied to the lifetime of
 19733:      *  the gfxAlphaBoxBlur, so it does not need to be ref counted.
 19733:      */
 19733:     gfxContext* ShadowInitialize(const gfxRect& extents, gfxAlphaBoxBlur& blur);
 19733: 
 19733:     /**
 19733:      * Completes a shadow drawing operation.
 19733:      * @param blur The gfxAlphaBoxBlur that was passed to ShadowInitialize.
 19733:      */
 19733:     void ShadowFinalize(gfxAlphaBoxBlur& blur);
 19733: 
 19733:     /**
 19733:      * Draws the current path in the given style. Takes care of
 19733:      * any shadow drawing and will use intermediate surfaces as needed.
 29573:      *
 63841:      * If dirtyRect is given, it will contain the user-space dirty
 29573:      * rectangle of the draw operation.
 19733:      */
 29573:     nsresult DrawPath(Style style, gfxRect *dirtyRect = nsnull);
 19733: 
 19733:     /**
 16154:      * Draws a rectangle in the given style; used by FillRect and StrokeRect.
 16154:      */
 16154:     nsresult DrawRect(const gfxRect& rect, Style style);
     1: 
 31123:     /**
 31123:      * Gets the pres shell from either the canvas element or the doc shell
 31123:      */
 31123:     nsIPresShell *GetPresShell() {
 77547:       nsCOMPtr<nsIContent> content = do_QueryObject(mCanvasElement);
 31123:       if (content) {
 80527:         return content->OwnerDoc()->GetShell();
 31123:       }
 34155:       if (mDocShell) {
 34155:         nsCOMPtr<nsIPresShell> shell;
 34155:         mDocShell->GetPresShell(getter_AddRefs(shell));
 34155:         return shell.get();
 34155:       }
 34155:       return nsnull;
 31123:     }
 31123: 
 15295:     // text
 15295:     enum TextAlign {
 15295:         TEXT_ALIGN_START,
 15295:         TEXT_ALIGN_END,
 15295:         TEXT_ALIGN_LEFT,
 15295:         TEXT_ALIGN_RIGHT,
 15295:         TEXT_ALIGN_CENTER
 15295:     };
 15295: 
 15295:     enum TextBaseline {
 15295:         TEXT_BASELINE_TOP,
 15295:         TEXT_BASELINE_HANGING,
 15295:         TEXT_BASELINE_MIDDLE,
 15295:         TEXT_BASELINE_ALPHABETIC,
 15295:         TEXT_BASELINE_IDEOGRAPHIC,
 15295:         TEXT_BASELINE_BOTTOM
 15295:     };
 15295: 
  3964:     gfxFontGroup* GetCurrentFontStyle();
 67820:     gfxTextRun* MakeTextRun(const PRUnichar* aText,
 67820:                             PRUint32         aLength,
 67820:                             PRUint32         aAppUnitsPerDevUnit,
 67820:                             PRUint32         aFlags);
  3964: 
 15295:     enum TextDrawOperation {
 15295:         TEXT_DRAW_OPERATION_FILL,
 16043:         TEXT_DRAW_OPERATION_STROKE,
 16043:         TEXT_DRAW_OPERATION_MEASURE
 15295:     };
 15295: 
 15295:     /*
 16043:      * Implementation of the fillText, strokeText, and measure functions with
 16043:      * the operation abstracted to a flag.
 15295:      */
 16043:     nsresult DrawOrMeasureText(const nsAString& text,
 15295:                                float x,
 15295:                                float y,
 15295:                                float maxWidth,
 16043:                                TextDrawOperation op,
 16043:                                float* aWidth);
 15295: 
     1:     // style handling
 16154:     /*
 16154:      * The previous set style. Is equal to STYLE_MAX when there is no valid
 16154:      * previous style.
 16154:      */
 16154:     Style mLastStyle;
 79445:     bool mDirtyStyle[STYLE_MAX];
     1: 
     1:     // state stack handling
     1:     class ContextState {
     1:     public:
 19733:         ContextState() : shadowOffset(0.0, 0.0),
 19733:                          globalAlpha(1.0),
 19733:                          shadowBlur(0.0),
 15295:                          textAlign(TEXT_ALIGN_START),
 27042:                          textBaseline(TEXT_BASELINE_ALPHABETIC),
 80486:                          imageSmoothingEnabled(true)
 27042:         { }
     1: 
     1:         ContextState(const ContextState& other)
 19733:             : shadowOffset(other.shadowOffset),
 19733:               globalAlpha(other.globalAlpha),
 19733:               shadowBlur(other.shadowBlur),
 15295:               font(other.font),
 15295:               fontGroup(other.fontGroup),
 15295:               textAlign(other.textAlign),
 27042:               textBaseline(other.textBaseline),
 27042:               imageSmoothingEnabled(other.imageSmoothingEnabled)
     1:         {
     1:             for (int i = 0; i < STYLE_MAX; i++) {
     1:                 colorStyles[i] = other.colorStyles[i];
     1:                 gradientStyles[i] = other.gradientStyles[i];
     1:                 patternStyles[i] = other.patternStyles[i];
     1:             }
     1:         }
     1: 
 16154:         inline void SetColorStyle(Style whichStyle, nscolor color) {
     1:             colorStyles[whichStyle] = color;
     1:             gradientStyles[whichStyle] = nsnull;
     1:             patternStyles[whichStyle] = nsnull;
     1:         }
     1: 
 16154:         inline void SetPatternStyle(Style whichStyle, nsCanvasPattern* pat) {
     1:             gradientStyles[whichStyle] = nsnull;
     1:             patternStyles[whichStyle] = pat;
     1:         }
     1: 
 16154:         inline void SetGradientStyle(Style whichStyle, nsCanvasGradient* grad) {
     1:             gradientStyles[whichStyle] = grad;
     1:             patternStyles[whichStyle] = nsnull;
     1:         }
     1: 
 19733:         /**
 19733:          * returns true iff the given style is a solid color.
 19733:          */
 79445:         inline bool StyleIsColor(Style whichStyle) const
 19733:         {
 19733:             return !(patternStyles[whichStyle] ||
 19733:                      gradientStyles[whichStyle]);
 19733:         }
 19733: 
 19733:         gfxPoint shadowOffset;
     1:         float globalAlpha;
 19733:         float shadowBlur;
 15295: 
 15295:         nsString font;
 15295:         nsRefPtr<gfxFontGroup> fontGroup;
 15295:         TextAlign textAlign;
 15295:         TextBaseline textBaseline;
 15295: 
     1:         nscolor colorStyles[STYLE_MAX];
     1:         nsCOMPtr<nsCanvasGradient> gradientStyles[STYLE_MAX];
     1:         nsCOMPtr<nsCanvasPattern> patternStyles[STYLE_MAX];
 27042: 
 79445:         bool imageSmoothingEnabled;
     1:     };
     1: 
     1:     nsTArray<ContextState> mStyleStack;
     1: 
     1:     inline ContextState& CurrentState() {
     1:         return mStyleStack[mSaveCount];
     1:     }
     1: 
 12667:     // other helpers
 12667:     void GetAppUnitsValues(PRUint32 *perDevPixel, PRUint32 *perCSSPixel) {
 12667:         // If we don't have a canvas element, we just return something generic.
 12667:         PRUint32 devPixel = 60;
 12667:         PRUint32 cssPixel = 60;
 12667: 
 31123:         nsIPresShell *ps = GetPresShell();
 31123:         nsPresContext *pc;
 31123: 
 12667:         if (!ps) goto FINISH;
 31123:         pc = ps->GetPresContext();
 12667:         if (!pc) goto FINISH;
 12667:         devPixel = pc->AppUnitsPerDevPixel();
 12667:         cssPixel = pc->AppUnitsPerCSSPixel();
 12667: 
 12667:       FINISH:
 12667:         if (perDevPixel)
 12667:             *perDevPixel = devPixel;
 12685:         if (perCSSPixel)
 12667:             *perCSSPixel = cssPixel;
 12667:     }
 16043: 
 16043:     friend struct nsCanvasBidiProcessor;
     1: };
     1: 
100504: class CanvasRenderingContext2DUserData : public LayerUserData {
100504: public:
100504:     CanvasRenderingContext2DUserData(nsCanvasRenderingContext2D *aContext)
100504:         : mContext(aContext)
100504:     {
100504:         aContext->mUserDatas.AppendElement(this);
100504:     }
100504:     ~CanvasRenderingContext2DUserData()
100504:     {
100504:         if (mContext) {
100504:             mContext->mUserDatas.RemoveElement(this);
100504:         }
100504:     }
100504:     static void DidTransactionCallback(void* aData)
100504:     {
100504:         CanvasRenderingContext2DUserData* self =
100504:             static_cast<CanvasRenderingContext2DUserData*>(aData);
100504:         if (self->mContext) {
100504:             self->mContext->MarkContextClean();
100504:         }
100504:     }
100504:     bool IsForContext(nsCanvasRenderingContext2D *aContext)
100504:     {
100504:         return mContext == aContext;
100504:     }
100504:     void Forget()
100504:     {
100504:         mContext = nsnull;
100504:     }
100504: 
100504: private:
100504:     nsCanvasRenderingContext2D *mContext;
100504: };
100504: 
 67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsCanvasRenderingContext2D)
 67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsCanvasRenderingContext2D)
 43655: 
 43655: NS_IMPL_CYCLE_COLLECTION_CLASS(nsCanvasRenderingContext2D)
 43655: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsCanvasRenderingContext2D)
 43655:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCanvasElement)
 43655: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsCanvasRenderingContext2D)
 43655:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCanvasElement)
 43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 38331: 
 40490: DOMCI_DATA(CanvasRenderingContext2D, nsCanvasRenderingContext2D)
 40490: 
 43655: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsCanvasRenderingContext2D)
     1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasRenderingContext2D)
     1:   NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextInternal)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMCanvasRenderingContext2D)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasRenderingContext2D)
     1: NS_INTERFACE_MAP_END
     1: 
     1: /**
     1:  ** CanvasRenderingContext2D impl
     1:  **/
     1: 
 38331: 
 38331: // Initialize our static variables.
 38331: PRUint32 nsCanvasRenderingContext2D::sNumLivingContexts = 0;
 38331: PRUint8 (*nsCanvasRenderingContext2D::sUnpremultiplyTable)[256] = nsnull;
 38331: PRUint8 (*nsCanvasRenderingContext2D::sPremultiplyTable)[256] = nsnull;
 38331: 
     1: nsresult
 72428: NS_NewCanvasRenderingContext2DThebes(nsIDOMCanvasRenderingContext2D** aResult)
     1: {
 16154:     nsRefPtr<nsIDOMCanvasRenderingContext2D> ctx = new nsCanvasRenderingContext2D();
     1:     if (!ctx)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
 16154:     *aResult = ctx.forget().get();
     1:     return NS_OK;
     1: }
     1: 
     1: nsCanvasRenderingContext2D::nsCanvasRenderingContext2D()
 80486:     : mValid(false), mZero(false), mOpaque(false), mResetLayer(true)
 80486:     , mIPC(false)
 46890:     , mCanvasElement(nsnull)
 80486:     , mSaveCount(0), mIsEntireFrameInvalid(false)
 80486:     , mPredictManyRedrawCalls(false), mHasPath(false), mInvalidateCount(0)
 46890:     , mLastStyle(STYLE_MAX), mStyleStack(20)
     1: {
 38331:     sNumLivingContexts++;
     1: }
     1: 
     1: nsCanvasRenderingContext2D::~nsCanvasRenderingContext2D()
     1: {
 50903:     Reset();
100504:     // Drop references from all CanvasRenderingContext2DUserDatas to this context
100504:     for (PRUint32 i = 0; i < mUserDatas.Length(); ++i) {
100504:         mUserDatas[i]->Forget();
100504:     }
 38331:     sNumLivingContexts--;
 38331:     if (!sNumLivingContexts) {
 41036:         delete[] sUnpremultiplyTable;
 41036:         delete[] sPremultiplyTable;
 38331:         sUnpremultiplyTable = nsnull;
 38331:         sPremultiplyTable = nsnull;
 38331:     }
     1: }
     1: 
 50903: nsresult
 50903: nsCanvasRenderingContext2D::Reset()
     1: {
 64542:     if (mCanvasElement) {
 64542:         HTMLCanvasElement()->InvalidateCanvas();
 64542:     }
 64542: 
 46380:     // only do this for non-docshell created contexts,
 46380:     // since those are the ones that we created a surface for
 79646:     if (mValid && !mDocShell && mSurface)
 42553:         gCanvasMemoryUsed -= mWidth * mHeight * 4;
 42553: 
 11707:     mSurface = nsnull;
 16154:     mThebes = nsnull;
 80486:     mValid = false;
 80486:     mIsEntireFrameInvalid = false;
 80486:     mPredictManyRedrawCalls = false;
 50903:     return NS_OK;
     1: }
     1: 
     1: nsresult
 38908: nsCanvasRenderingContext2D::SetStyleFromStringOrInterface(const nsAString& aStr,
 38908:                                                           nsISupports *aInterface,
 38908:                                                           Style aWhichStyle)
     1: {
     1:     nsresult rv;
     1:     nscolor color;
     1: 
 38908:     if (!aStr.IsVoid()) {
 59514:         nsIDocument* document = mCanvasElement ?
 80526:                                 HTMLCanvasElement()->OwnerDoc() : nsnull;
 59514: 
 59514:         // Pass the CSS Loader object to the parser, to allow parser error
 59514:         // reports to include the outer window ID.
 59514:         nsCSSParser parser(document ? document->CSSLoader() : nsnull);
 38908:         rv = parser.ParseColorString(aStr, nsnull, 0, &color);
     1:         if (NS_FAILED(rv)) {
     1:             // Error reporting happens inside the CSS parser
     1:             return NS_OK;
     1:         }
     1: 
     1:         CurrentState().SetColorStyle(aWhichStyle, color);
     1: 
 80486:         mDirtyStyle[aWhichStyle] = true;
     1:         return NS_OK;
 38908:     }
 38908: 
 38908:     if (aInterface) {
 38908:         nsCOMPtr<nsCanvasGradient> grad(do_QueryInterface(aInterface));
     1:         if (grad) {
     1:             CurrentState().SetGradientStyle(aWhichStyle, grad);
 80486:             mDirtyStyle[aWhichStyle] = true;
     1:             return NS_OK;
     1:         }
     1: 
 38908:         nsCOMPtr<nsCanvasPattern> pattern(do_QueryInterface(aInterface));
     1:         if (pattern) {
     1:             CurrentState().SetPatternStyle(aWhichStyle, pattern);
 80486:             mDirtyStyle[aWhichStyle] = true;
     1:             return NS_OK;
     1:         }
     1:     }
     1: 
     1:     nsContentUtils::ReportToConsole(
     1:         nsIScriptError::warningFlag,
 59513:         "Canvas",
 84636:         mCanvasElement ? HTMLCanvasElement()->OwnerDoc() : nsnull,
 84636:         nsContentUtils::eDOM_PROPERTIES,
 84636:         "UnexpectedCanvasVariantStyle");
     1: 
     1:     return NS_OK;
     1: }
     1: 
 38908: nsresult
 38908: nsCanvasRenderingContext2D::GetStyleAsStringOrInterface(nsAString& aStr,
 38908:                                                         nsISupports **aInterface,
 38908:                                                         PRInt32 *aType,
 38908:                                                         Style aWhichStyle)
 38908: {
 38908:     if (CurrentState().patternStyles[aWhichStyle]) {
 80486:         aStr.SetIsVoid(true);
 38908:         NS_ADDREF(*aInterface = CurrentState().patternStyles[aWhichStyle]);
 38908:         *aType = CMG_STYLE_PATTERN;
 38908:     } else if (CurrentState().gradientStyles[aWhichStyle]) {
 80486:         aStr.SetIsVoid(true);
 38908:         NS_ADDREF(*aInterface = CurrentState().gradientStyles[aWhichStyle]);
 38908:         *aType = CMG_STYLE_GRADIENT;
 38908:     } else {
 38908:         StyleColorToString(CurrentState().colorStyles[aWhichStyle], aStr);
 38908:         *aInterface = nsnull;
 38908:         *aType = CMG_STYLE_STRING;
 38908:     }
 38908: 
 38908:     return NS_OK;
 38908: }
 38908: 
     1: void
     1: nsCanvasRenderingContext2D::StyleColorToString(const nscolor& aColor, nsAString& aStr)
     1: {
 55007:     // We can't reuse the normal CSS color stringification code,
 55007:     // because the spec calls for a different algorithm for canvas.
     1:     if (NS_GET_A(aColor) == 255) {
 96873:         CopyUTF8toUTF16(nsPrintfCString("#%02x%02x%02x",
     1:                                         NS_GET_R(aColor),
     1:                                         NS_GET_G(aColor),
     1:                                         NS_GET_B(aColor)),
     1:                         aStr);
     1:     } else {
 96873:         CopyUTF8toUTF16(nsPrintfCString("rgba(%d, %d, %d, ",
     1:                                         NS_GET_R(aColor),
     1:                                         NS_GET_G(aColor),
 55007:                                         NS_GET_B(aColor)),
     1:                         aStr);
 58482:         aStr.AppendFloat(nsStyleUtil::ColorComponentToFloat(NS_GET_A(aColor)));
 55007:         aStr.Append(')');
     1:     }
     1: }
     1: 
     1: void
     1: nsCanvasRenderingContext2D::DirtyAllStyles()
     1: {
     1:     for (int i = 0; i < STYLE_MAX; i++) {
 80486:         mDirtyStyle[i] = true;
     1:     }
     1: }
     1: 
     1: void
 19733: nsCanvasRenderingContext2D::ApplyStyle(Style aWhichStyle,
 79445:                                        bool aUseGlobalAlpha)
     1: {
     1:     if (mLastStyle == aWhichStyle &&
 19733:         !mDirtyStyle[aWhichStyle] &&
 19733:         aUseGlobalAlpha)
     1:     {
     1:         // nothing to do, this is already the set style
     1:         return;
     1:     }
     1: 
 77560:     if (!EnsureSurface()) {
 77560:       return;
 77560:     }
 77560: 
 19733:     // if not using global alpha, don't optimize with dirty bit
 19733:     if (aUseGlobalAlpha)
 80486:         mDirtyStyle[aWhichStyle] = false;
     1:     mLastStyle = aWhichStyle;
     1: 
     1:     nsCanvasPattern* pattern = CurrentState().patternStyles[aWhichStyle];
     1:     if (pattern) {
 31123:         if (mCanvasElement)
 43655:             CanvasUtils::DoDrawImageSecurityCheck(HTMLCanvasElement(),
 29572:                                                   pattern->Principal(),
 78159:                                                   pattern->GetForceWriteOnly(),
 78159:                                                   pattern->GetCORSUsed());
 27042: 
 27042:         gfxPattern* gpat = pattern->GetPattern();
 27042: 
 27042:         if (CurrentState().imageSmoothingEnabled)
 27042:             gpat->SetFilter(gfxPattern::FILTER_GOOD);
 27042:         else
 27042:             gpat->SetFilter(gfxPattern::FILTER_NEAREST);
 27042: 
 27042:         mThebes->SetPattern(gpat);
     1:         return;
     1:     }
     1: 
     1:     if (CurrentState().gradientStyles[aWhichStyle]) {
 27042:         gfxPattern* gpat = CurrentState().gradientStyles[aWhichStyle]->GetPattern();
 27042:         mThebes->SetPattern(gpat);
     1:         return;
     1:     }
     1: 
 19733:     gfxRGBA color(CurrentState().colorStyles[aWhichStyle]);
 19733:     if (aUseGlobalAlpha)
 19733:         color.a *= CurrentState().globalAlpha;
 19733: 
 19733:     mThebes->SetColor(color);
     1: }
     1: 
     1: nsresult
     1: nsCanvasRenderingContext2D::Redraw()
     1: {
 63841:     if (mIsEntireFrameInvalid)
 63841:         return NS_OK;
 80486:     mIsEntireFrameInvalid = true;
 63841: 
 43655:     if (!mCanvasElement) {
 43655:         NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
 16154:         return NS_OK;
 43655:     }
  6313: 
 50430:     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
 50430: 
 64542:     HTMLCanvasElement()->InvalidateCanvasContent(nsnull);
 42402: 
 42402:     return NS_OK;
     1: }
     1: 
 46498: NS_IMETHODIMP
 27097: nsCanvasRenderingContext2D::Redraw(const gfxRect& r)
 27097: {
 63841:     ++mInvalidateCount;
 63841: 
 63839:     if (mIsEntireFrameInvalid)
 63839:         return NS_OK;
 63839: 
 63841:     if (mPredictManyRedrawCalls ||
 63841:         mInvalidateCount > kCanvasMaxInvalidateCount) {
 63841:         return Redraw();
 63841:     }
 63841: 
 43655:     if (!mCanvasElement) {
 43655:         NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
 27097:         return NS_OK;
 43655:     }
 27097: 
 50430:     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
 50430: 
 64542:     HTMLCanvasElement()->InvalidateCanvasContent(&r);
 42402: 
 42402:     return NS_OK;
 27097: }
 27097: 
     1: NS_IMETHODIMP
 63841: nsCanvasRenderingContext2D::RedrawUser(const gfxRect& r)
 63841: {
 63841:     if (mIsEntireFrameInvalid) {
 63841:         ++mInvalidateCount;
 63841:         return NS_OK;
 63841:     }
 63841: 
 63841:     return Redraw(mThebes->UserToDevice(r));
 63841: }
 63841: 
 63841: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetDimensions(PRInt32 width, PRInt32 height)
     1: {
 77560:     Initialize(NULL, width, height);
 77560:     return NS_OK;
 77560: }
 77560: 
 77560: void
 77560: nsCanvasRenderingContext2D::Initialize(nsIDocShell *docShell, PRInt32 width, PRInt32 height) 
 77560: {
 77560:     Reset();
 77560: 
 77560:     NS_ASSERTION(!docShell ^ !mCanvasElement, "Cannot set both docshell and canvas element");
 77560:     mDocShell = docShell;
 77560: 
 77560:     mWidth = width;
 77560:     mHeight = height;
 77560: 
 80486:     mResetLayer = true;
 80486:     mValid = true;
 80486:     mSurfaceCreated = false;
 77560: 
 77560:     // set up the initial canvas defaults
 77560:     mStyleStack.Clear();
 77560:     mSaveCount = 0;
 77560: 
 77560:     ContextState *state = mStyleStack.AppendElement();
 77560:     state->globalAlpha = 1.0;
 77560: 
 77560:     state->colorStyles[STYLE_FILL] = NS_RGB(0,0,0);
 77560:     state->colorStyles[STYLE_STROKE] = NS_RGB(0,0,0);
 77560:     state->colorStyles[STYLE_SHADOW] = NS_RGBA(0,0,0,0);
 77560:     DirtyAllStyles();
 77560: 
 77560:     // always force a redraw, because if the surface dimensions were reset
 77560:     // then the surface became cleared, and we need to redraw everything.
 77560:     Redraw();
 77560: 
 77560:     return;
 77560: }
 77560: 
 77560: void
 77560: nsCanvasRenderingContext2D::CreateThebes()
 77560: {
 77560:     mThebes = new gfxContext(mSurface);
 80486:     mSurfaceCreated = true;
 77560:     
 77560:     mThebes->SetOperator(gfxContext::OPERATOR_CLEAR);
 77560:     mThebes->NewPath();
 77560:     mThebes->Rectangle(gfxRect(0, 0, mWidth, mHeight));
 77560:     mThebes->Fill();
 77560: 
 77560:     mThebes->SetLineWidth(1.0);
 77560:     mThebes->SetOperator(gfxContext::OPERATOR_OVER);
 77560:     mThebes->SetMiterLimit(10.0);
 77560:     mThebes->SetLineCap(gfxContext::LINE_CAP_BUTT);
 77560:     mThebes->SetLineJoin(gfxContext::LINE_JOIN_MITER);
 77560: 
 77560:     mThebes->NewPath();
 77560: }
 77560: 
 77560: NS_IMETHODIMP
 77560: nsCanvasRenderingContext2D::InitializeWithSurface(nsIDocShell *docShell, 
 77560:                                                   gfxASurface *surface, 
 77560:                                                   PRInt32 width, 
 77560:                                                   PRInt32 height)
 77560: {
 77560:     Initialize(docShell, width, height);
 77560:     
 77560:     mSurface = surface;
 77560:     CreateThebes();
 77560:     return mValid ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 77560: }
 77560: 
 79445: bool
 77560: nsCanvasRenderingContext2D::EnsureSurface()
 77560: {
 77560:     if (!mValid) {
 80486:         return false;
 77560:     }
 77560: 
 77560:     if (mSurface && mThebes && mSurfaceCreated) {
 77560:         if (mSurface->CairoStatus()) {
 80486:             return false;
 80486:         }
 80486:         return true;
 77560:     }
 77560:     
 31123:     nsRefPtr<gfxASurface> surface;
     1: 
 11707:     // Check that the dimensions are sane
 77560:     if (gfxASurface::CheckSurfaceSize(gfxIntSize(mWidth, mHeight), 0xffff)) {
 70071:         // Zero sized surfaces have problems, so just use a 1 by 1.
 77560:         if (mHeight == 0 || mWidth == 0) {
 80486:             mZero = true;
 77560:             mHeight = 1;
 77560:             mWidth = 1;
 73712:         } else {
 80486:             mZero = false;
 70071:         }
 46890: 
 46890:         gfxASurface::gfxImageFormat format = GetImageFormat();
 38331: 
 73612:         if (!PR_GetEnv("MOZ_CANVAS_IMAGE_SURFACE")) {
 77547:             nsCOMPtr<nsIContent> content = do_QueryObject(mCanvasElement);
 52173:             nsIDocument* ownerDoc = nsnull;
 52173:             if (content)
 80526:                 ownerDoc = content->OwnerDoc();
 52173:             nsRefPtr<LayerManager> layerManager = nsnull;
 52173: 
 52173:             if (ownerDoc)
 58813:               layerManager =
 58813:                 nsContentUtils::PersistentLayerManagerForDocument(ownerDoc);
 52173: 
 52173:             if (layerManager) {
 77560:               surface = layerManager->CreateOptimalSurface(gfxIntSize(mWidth, mHeight), format);
 52173:             } else {
 52173:               surface = gfxPlatform::GetPlatform()->
 77560:                 CreateOffscreenSurface(gfxIntSize(mWidth, mHeight), gfxASurface::ContentFromFormat(format));
 52173:             }
 42923:         }
 38331: 
 73612:         if (!surface || surface->CairoStatus()) {
 73612:             // If we couldn't create a surface of the type we want, fall back
 73612:             // to an image surface. This lets us handle surface sizes that
 73612:             // the underlying cairo backend might not handle.
 77560:             surface = new gfxImageSurface(gfxIntSize(mWidth, mHeight), format);
 73612:             if (!surface || surface->CairoStatus()) {
 73612:                 surface = nsnull;
 73612:             }
 73612:         }
 42553:     }
 42553:     if (surface) {
 42553:         if (gCanvasMemoryReporter == nsnull) {
 42553:             gCanvasMemoryReporter = new NS_MEMORY_REPORTER_NAME(CanvasMemory);
 42553:             NS_RegisterMemoryReporter(gCanvasMemoryReporter);
 42553:         }
 42553: 
 77560:         gCanvasMemoryUsed += mWidth * mHeight * 4;
 70145:         JSContext* context = nsContentUtils::GetCurrentJSContext();
 70145:         if (context) {
 77560:             JS_updateMallocCounter(context, mWidth * mHeight * 4);
 77560:         }
 77560:     } else {
 80486:         return false;
 77560:     }
 31123: 
 31123:     mSurface = surface;
 77560:     CreateThebes();
 77560: 
 77560:     if (mSurface->CairoStatus()) {
 80486:         return false;
 80486:     }
 80486:     return true;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2D::SetIsOpaque(bool isOpaque)
 15234: {
 15234:     if (isOpaque == mOpaque)
 15234:         return NS_OK;
 15234: 
 15234:     mOpaque = isOpaque;
 15234: 
 15234:     if (mValid) {
 15234:         /* If we've already been created, let SetDimensions take care of
 15234:          * recreating our surface
 15234:          */
 15234:         return SetDimensions(mWidth, mHeight);
 15234:     }
 15234: 
 15234:     return NS_OK;
 15234: }
 15234: 
 15234: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2D::SetIsIPC(bool isIPC)
 46756: {
 46902:     if (isIPC == mIPC)
 46756:         return NS_OK;
 46756: 
 46902:     mIPC = isIPC;
 46756: 
 46756:     if (mValid) {
 46756:         /* If we've already been created, let SetDimensions take care of
 46756:          * recreating our surface
 46756:          */
 46756:         return SetDimensions(mWidth, mHeight);
 46756:     }
 46756: 
 46756:     return NS_OK;
 46756: }
 46756: 
 46890: NS_IMETHODIMP
 93959: nsCanvasRenderingContext2D::Render(gfxContext *ctx, gfxPattern::GraphicsFilter aFilter, PRUint32 aFlags)
     1: {
     1:     nsresult rv = NS_OK;
     1: 
 77560:     if (!EnsureSurface())
  2756:         return NS_ERROR_FAILURE;
  2756: 
 16154:     nsRefPtr<gfxPattern> pat = new gfxPattern(mSurface);
     1: 
 29302:     pat->SetFilter(aFilter);
 42435:     pat->SetExtend(gfxPattern::EXTEND_PAD);
 29302: 
 15234:     gfxContext::GraphicsOperator op = ctx->CurrentOperator();
 15234:     if (mOpaque)
 15234:         ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 15234: 
     1:     // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
     1:     // pixel alignment for this stuff!
     1:     ctx->NewPath();
     1:     ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
     1:     ctx->Fill();
     1: 
 15234:     if (mOpaque)
 15234:         ctx->SetOperator(op);
 15234: 
 93959:     if (!(aFlags & RenderFlagPremultAlpha)) {
 93959:         nsRefPtr<gfxASurface> curSurface = ctx->CurrentSurface();
 93959:         nsRefPtr<gfxImageSurface> gis = curSurface->GetAsImageSurface();
 93959:         NS_ABORT_IF_FALSE(gis, "If non-premult alpha, must be able to get image surface!");
 93959: 
 93959:         gfxUtils::UnpremultiplyImageSurface(gis);
 93959:     }
 93959: 
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
  6313: nsCanvasRenderingContext2D::GetInputStream(const char *aMimeType,
  6313:                                            const PRUnichar *aEncoderOptions,
     1:                                            nsIInputStream **aStream)
     1: {
 77560:     if (!EnsureSurface())
  2756:         return NS_ERROR_FAILURE;
  2756: 
  9580:     nsresult rv;
  6313:     const char encoderPrefix[] = "@mozilla.org/image/encoder;2?type=";
  6313:     nsAutoArrayPtr<char> conid(new (std::nothrow) char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);
 11707: 
 11707:     if (!conid)
 11707:         return NS_ERROR_OUT_OF_MEMORY;
 11707: 
  6313:     strcpy(conid, encoderPrefix);
  6313:     strcat(conid, aMimeType);
  6313: 
  6313:     nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);
     1:     if (!encoder)
     1:         return NS_ERROR_FAILURE;
     1: 
  1754:     nsAutoArrayPtr<PRUint8> imageBuffer(new (std::nothrow) PRUint8[mWidth * mHeight * 4]);
     1:     if (!imageBuffer)
 11707:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
 16154:     nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(imageBuffer.get(),
 16154:                                                             gfxIntSize(mWidth, mHeight),
 16154:                                                             mWidth * 4,
 16154:                                                             gfxASurface::ImageFormatARGB32);
 16154: 
 16154:     if (!imgsurf || imgsurf->CairoStatus())
     1:         return NS_ERROR_FAILURE;
     1: 
 16154:     nsRefPtr<gfxContext> ctx = new gfxContext(imgsurf);
 16154: 
 16154:     if (!ctx || ctx->HasError())
 16154:         return NS_ERROR_FAILURE;
 16154: 
 16154:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 16154:     ctx->SetSource(mSurface, gfxPoint(0, 0));
 16154:     ctx->Paint();
     1: 
  9580:     rv = encoder->InitFromData(imageBuffer.get(),
     1:                                mWidth * mHeight * 4, mWidth, mHeight, mWidth * 4,
     1:                                imgIEncoder::INPUT_FORMAT_HOSTARGB,
  6313:                                nsDependentString(aEncoderOptions));
  9580:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     return CallQueryInterface(encoder, aStream);
     1: }
     1: 
 46890: gfxASurface::gfxImageFormat
 46890: nsCanvasRenderingContext2D::GetImageFormat() const
 46890: {
 46890:     gfxASurface::gfxImageFormat format = gfxASurface::ImageFormatARGB32;
 46890: 
 46890:     if (mOpaque)
 46890:         format = gfxASurface::ImageFormatRGB24;
 46890: 
 46890:     return format;
 46890: }
 46890: 
     1: //
     1: // nsCanvasRenderingContext2D impl
     1: //
     1: 
     1: NS_IMETHODIMP
 42402: nsCanvasRenderingContext2D::SetCanvasElement(nsHTMLCanvasElement* aCanvasElement)
     1: {
     1:     mCanvasElement = aCanvasElement;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetCanvas(nsIDOMHTMLCanvasElement **canvas)
     1: {
 43655:     NS_IF_ADDREF(*canvas = mCanvasElement);
 43655: 
     1:     return NS_OK;
     1: }
     1: 
     1: //
     1: // state
     1: //
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Save()
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     ContextState state = CurrentState();
     1:     mStyleStack.AppendElement(state);
 16154:     mThebes->Save();
     1:     mSaveCount++;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Restore()
     1: {
 77560:     if (!EnsureSurface()) 
 77560:         return NS_ERROR_FAILURE;
 77560: 
 11010:     if (mSaveCount == 0)
 11010:         return NS_OK;
     1: 
     1:     mStyleStack.RemoveElementAt(mSaveCount);
 16154:     mThebes->Restore();
 16154: 
 16154:     mLastStyle = STYLE_MAX;
     1:     DirtyAllStyles();
     1: 
     1:     mSaveCount--;
     1:     return NS_OK;
     1: }
     1: 
     1: //
     1: // transformations
     1: //
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Scale(float x, float y)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(x,y))
 68022:         return NS_OK;
     1: 
 16154:     mThebes->Scale(x, y);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Rotate(float angle)
     1: {
 77560:     if (!EnsureSurface()) 
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(angle))
 64490:         return NS_OK;
     1: 
 16154:     mThebes->Rotate(angle);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Translate(float x, float y)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(x,y))
 64641:         return NS_OK;
     1: 
 16154:     mThebes->Translate(gfxPoint(x, y));
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Transform(float m11, float m12, float m21, float m22, float dx, float dy)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(m11,m12,m21,m22,dx,dy))
 64640:         return NS_OK;
     1: 
 16154:     gfxMatrix matrix(m11, m12, m21, m22, dx, dy);
 16154:     mThebes->Multiply(matrix);
 16154: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetTransform(float m11, float m12, float m21, float m22, float dx, float dy)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(m11,m12,m21,m22,dx,dy))
 70906:         return NS_OK;
     1: 
 16154:     gfxMatrix matrix(m11, m12, m21, m22, dx, dy);
 16154:     mThebes->SetMatrix(matrix);
 16154: 
     1:     return NS_OK;
     1: }
     1: 
 72739: NS_IMETHODIMP
 72739: nsCanvasRenderingContext2D::SetMozCurrentTransform(JSContext* cx,
 72739:                                                    const jsval& matrix)
 72739: {
 72739:     nsresult rv;
 72739:     gfxMatrix newCTM;
 72739:     
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 72739:     if (!JSValToMatrix(cx, matrix, &newCTM, &rv)) {
 72739:         return rv;
 72739:     }
 72739: 
 72739:     mThebes->SetMatrix(newCTM);
 72739: 
 72739:     return NS_OK;
 72739: }
 72739: 
 72739: NS_IMETHODIMP
 72739: nsCanvasRenderingContext2D::GetMozCurrentTransform(JSContext* cx,
 72739:                                                    jsval* matrix)
 72739: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 72739:     return MatrixToJSVal(mThebes->CurrentMatrix(), cx, matrix);
 72739: }
 72739: 
 72739: NS_IMETHODIMP
 72739: nsCanvasRenderingContext2D::SetMozCurrentTransformInverse(JSContext* cx,
 72739:                                                           const jsval& matrix)
 72739: {
 72739:     nsresult rv;
 72739:     gfxMatrix newCTMInverse;
 72739:     
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 72739:     if (!JSValToMatrix(cx, matrix, &newCTMInverse, &rv)) {
 72739:         return rv;
 72739:     }
 72739: 
 72739:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 72739:     if (!newCTMInverse.IsSingular()) {
 72739:         mThebes->SetMatrix(newCTMInverse.Invert());
 72739:     }
 72739: 
 72739:     return NS_OK;
 72739: }
 72739: 
 72739: NS_IMETHODIMP
 72739: nsCanvasRenderingContext2D::GetMozCurrentTransformInverse(JSContext* cx,
 72739:                                                           jsval* matrix)
 72739: {
 72739:     gfxMatrix ctm = mThebes->CurrentMatrix();
 72739: 
 72739:     if (!mThebes->CurrentMatrix().IsSingular()) {
 72739:         ctm.Invert();
 72739:     } else {
 72739:         double NaN = JSVAL_TO_DOUBLE(JS_GetNaNValue(cx));
 72739:         ctm = gfxMatrix(NaN, NaN, NaN, NaN, NaN, NaN);
 72739:     }
 72739: 
 72739:     return MatrixToJSVal(ctm, cx, matrix);
 72739: }
 72739: 
     1: //
     1: // colors
     1: //
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetGlobalAlpha(float aGlobalAlpha)
     1: {
 64487:     if (!FloatValidate(aGlobalAlpha) || aGlobalAlpha < 0.0 || aGlobalAlpha > 1.0)
     1:         return NS_OK;
     1: 
     1:     CurrentState().globalAlpha = aGlobalAlpha;
  7648:     DirtyAllStyles();
  7648: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetGlobalAlpha(float *aGlobalAlpha)
     1: {
     1:     *aGlobalAlpha = CurrentState().globalAlpha;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 38908: nsCanvasRenderingContext2D::SetStrokeStyle(nsIVariant *aValue)
     1: {
 38908:     if (!aValue)
 38908:         return NS_ERROR_FAILURE;
 38908: 
 38908:     nsString str;
 38908: 
 38908:     nsresult rv;
 38908:     PRUint16 vtype;
 38908:     rv = aValue->GetDataType(&vtype);
 38908:     NS_ENSURE_SUCCESS(rv, rv);
 38908: 
 38908:     if (vtype == nsIDataType::VTYPE_INTERFACE ||
 38908:         vtype == nsIDataType::VTYPE_INTERFACE_IS)
 38908:     {
 38908:         nsIID *iid;
 38908:         nsCOMPtr<nsISupports> sup;
 38908:         rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
 38908:         NS_ENSURE_SUCCESS(rv, rv);
 42120:         if (iid)
 42120:             NS_Free(iid);
 38908: 
 80486:         str.SetIsVoid(true);
 38908:         return SetStrokeStyle_multi(str, sup);
     1:     }
     1: 
 38908:     rv = aValue->GetAsAString(str);
 38908:     NS_ENSURE_SUCCESS(rv, rv);
 38908: 
 38908:     return SetStrokeStyle_multi(str, nsnull);
 38908: }
 38908: 
     1: NS_IMETHODIMP
 38908: nsCanvasRenderingContext2D::GetStrokeStyle(nsIVariant **aResult)
     1: {
 38908:     nsCOMPtr<nsIWritableVariant> wv = do_CreateInstance(NS_VARIANT_CONTRACTID);
 38908: 
 38908:     nsCOMPtr<nsISupports> sup;
 38908:     nsString str;
 38908:     PRInt32 t;
 38908:     nsresult rv = GetStrokeStyle_multi(str, getter_AddRefs(sup), &t);
 38908:     NS_ENSURE_SUCCESS(rv, rv);
 38908: 
 38908:     if (t == CMG_STYLE_STRING) {
 38908:         rv = wv->SetAsAString(str);
 38908:     } else if (t == CMG_STYLE_PATTERN) {
 38908:         rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasPattern),
 38908:                                 sup);
 38908:     } else if (t == CMG_STYLE_GRADIENT) {
 38908:         rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasGradient),
 38908:                                 sup);
 38908:     } else {
 38908:         NS_ERROR("Unknown type from GetStroke/FillStyle_multi!");
     1:         return NS_ERROR_FAILURE;
 38908:     }
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
 38908:     NS_IF_ADDREF(*aResult = wv.get());
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 38908: nsCanvasRenderingContext2D::SetFillStyle(nsIVariant *aValue)
     1: {
 38908:     if (!aValue)
 38908:         return NS_ERROR_FAILURE;
 38908: 
 38908:     nsString str;
 38908:     nsresult rv;
 38908:     PRUint16 vtype;
 38908:     rv = aValue->GetDataType(&vtype);
 38908:     NS_ENSURE_SUCCESS(rv, rv);
 38908: 
 38908:     if (vtype == nsIDataType::VTYPE_INTERFACE ||
 38908:         vtype == nsIDataType::VTYPE_INTERFACE_IS)
 38908:     {
 38908:         nsIID *iid;
 38908:         nsCOMPtr<nsISupports> sup;
 38908:         rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
 38908:         NS_ENSURE_SUCCESS(rv, rv);
 38908: 
 80486:         str.SetIsVoid(true);
 38908:         return SetFillStyle_multi(str, sup);
     1:     }
     1: 
 38908:     rv = aValue->GetAsAString(str);
 38908:     NS_ENSURE_SUCCESS(rv, rv);
 38908: 
 38908:     return SetFillStyle_multi(str, nsnull);
 38908: }
 38908: 
     1: NS_IMETHODIMP
 38908: nsCanvasRenderingContext2D::GetFillStyle(nsIVariant **aResult)
     1: {
 38908:     nsCOMPtr<nsIWritableVariant> wv = do_CreateInstance(NS_VARIANT_CONTRACTID);
 38908: 
 38908:     nsCOMPtr<nsISupports> sup;
 38908:     nsString str;
 38908:     PRInt32 t;
 38908:     nsresult rv = GetFillStyle_multi(str, getter_AddRefs(sup), &t);
 38908:     NS_ENSURE_SUCCESS(rv, rv);
 38908: 
 38908:     if (t == CMG_STYLE_STRING) {
 38908:         rv = wv->SetAsAString(str);
 38908:     } else if (t == CMG_STYLE_PATTERN) {
 38908:         rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasPattern),
 38908:                                 sup);
 38908:     } else if (t == CMG_STYLE_GRADIENT) {
 38908:         rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasGradient),
 38908:                                 sup);
 38908:     } else {
 38908:         NS_ERROR("Unknown type from GetStroke/FillStyle_multi!");
     1:         return NS_ERROR_FAILURE;
 38908:     }
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
 38908:     NS_IF_ADDREF(*aResult = wv.get());
 38908:     return NS_OK;
     1: }
     1: 
 38908: NS_IMETHODIMP
 38908: nsCanvasRenderingContext2D::SetStrokeStyle_multi(const nsAString& aStr, nsISupports *aInterface)
 38908: {
 38908:     return SetStyleFromStringOrInterface(aStr, aInterface, STYLE_STROKE);
 38908: }
 38908: 
 38908: NS_IMETHODIMP
 38908: nsCanvasRenderingContext2D::GetStrokeStyle_multi(nsAString& aStr, nsISupports **aInterface, PRInt32 *aType)
 38908: {
 38908:     return GetStyleAsStringOrInterface(aStr, aInterface, aType, STYLE_STROKE);
 38908: }
 38908: 
 38908: NS_IMETHODIMP
 38908: nsCanvasRenderingContext2D::SetFillStyle_multi(const nsAString& aStr, nsISupports *aInterface)
 38908: {
 38908:     return SetStyleFromStringOrInterface(aStr, aInterface, STYLE_FILL);
 38908: }
 38908: 
 38908: NS_IMETHODIMP
 38908: nsCanvasRenderingContext2D::GetFillStyle_multi(nsAString& aStr, nsISupports **aInterface, PRInt32 *aType)
 38908: {
 38908:     return GetStyleAsStringOrInterface(aStr, aInterface, aType, STYLE_FILL);
     1: }
     1: 
 71561: NS_IMETHODIMP
 71561: nsCanvasRenderingContext2D::SetMozFillRule(const nsAString& aString)
 71561: {
 71561:     gfxContext::FillRule rule;
 71561:     
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 71561:     if (aString.EqualsLiteral("evenodd"))
 71561:         rule = gfxContext::FILL_RULE_EVEN_ODD;
 71561:     else if (aString.EqualsLiteral("nonzero"))
 71561:         rule = gfxContext::FILL_RULE_WINDING;
 71561:     else
 71561:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 71561:         return NS_OK;
 71561: 
 71561:     mThebes->SetFillRule(rule);
 71561:     return NS_OK;
 71561: }
 71561: 
 71561: NS_IMETHODIMP
 71561: nsCanvasRenderingContext2D::GetMozFillRule(nsAString& aString)
 71561: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 71561:     switch (mThebes->CurrentFillRule()) {
 71561:     case gfxContext::FILL_RULE_WINDING:
 71561:         aString.AssignLiteral("nonzero"); break;
 71561:     case gfxContext::FILL_RULE_EVEN_ODD:
 71561:         aString.AssignLiteral("evenodd"); break;
 71561:     }
 71561:     return NS_OK;
 71561: }
 71561: 
     1: //
     1: // gradients and patterns
     1: //
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::CreateLinearGradient(float x0, float y0, float x1, float y1,
     1:                                                  nsIDOMCanvasGradient **_retval)
     1: {
     1:     if (!FloatValidate(x0,y0,x1,y1))
 61745:         return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
     1: 
 16154:     nsRefPtr<gfxPattern> gradpat = new gfxPattern(x0, y0, x1, y1);
 16154:     if (!gradpat)
     1:         return NS_ERROR_OUT_OF_MEMORY;
 16154: 
 38849:     nsRefPtr<nsIDOMCanvasGradient> grad = new nsCanvasGradient(gradpat);
 16154:     if (!grad)
 16154:         return NS_ERROR_OUT_OF_MEMORY;
 16154: 
 16154:     *_retval = grad.forget().get();
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::CreateRadialGradient(float x0, float y0, float r0, float x1, float y1, float r1,
     1:                                                  nsIDOMCanvasGradient **_retval)
     1: {
     1:     if (!FloatValidate(x0,y0,r0,x1,y1,r1))
 61745:         return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
     1: 
 64634:     if (r0 < 0.0 || r1 < 0.0)
 64634:         return NS_ERROR_DOM_INDEX_SIZE_ERR;
 64634: 
 16154:     nsRefPtr<gfxPattern> gradpat = new gfxPattern(x0, y0, r0, x1, y1, r1);
 16154:     if (!gradpat)
     1:         return NS_ERROR_OUT_OF_MEMORY;
 16154: 
 38849:     nsRefPtr<nsIDOMCanvasGradient> grad = new nsCanvasGradient(gradpat);
 16154:     if (!grad)
 16154:         return NS_ERROR_OUT_OF_MEMORY;
 16154: 
 16154:     *_retval = grad.forget().get();
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::CreatePattern(nsIDOMHTMLElement *image,
     1:                                           const nsAString& repeat,
     1:                                           nsIDOMCanvasPattern **_retval)
     1: {
 83345:     nsCOMPtr<nsIContent> content = do_QueryInterface(image);
 83345:     if (!content) {
 64635:         return NS_ERROR_DOM_TYPE_MISMATCH_ERR;
 64635:     }
 83345: 
 16154:     gfxPattern::GraphicsExtend extend;
     1:     if (repeat.IsEmpty() || repeat.EqualsLiteral("repeat")) {
 16154:         extend = gfxPattern::EXTEND_REPEAT;
     1:     } else if (repeat.EqualsLiteral("repeat-x")) {
     1:         // XX
 16154:         extend = gfxPattern::EXTEND_REPEAT;
     1:     } else if (repeat.EqualsLiteral("repeat-y")) {
     1:         // XX
 16154:         extend = gfxPattern::EXTEND_REPEAT;
     1:     } else if (repeat.EqualsLiteral("no-repeat")) {
 16154:         extend = gfxPattern::EXTEND_NONE;
     1:     } else {
     1:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
     1:         return NS_ERROR_DOM_SYNTAX_ERR;
     1:     }
     1: 
 80000:     nsHTMLCanvasElement* canvas = nsHTMLCanvasElement::FromContent(content);
 80000:     if (canvas) {
 80000:         nsIntSize size = canvas->GetSize();
 80000:         if (size.width == 0 || size.height == 0) {
 80000:             return NS_ERROR_DOM_INVALID_STATE_ERR;
 80000:         }
 80000:     }
 80000: 
 32424:     // The canvas spec says that createPattern should use the first frame
 32424:     // of animated images
 29572:     nsLayoutUtils::SurfaceFromElementResult res =
 83345:         nsLayoutUtils::SurfaceFromElement(content->AsElement(),
 83345:             nsLayoutUtils::SFE_WANT_FIRST_FRAME | nsLayoutUtils::SFE_WANT_NEW_SURFACE);
 29572:     if (!res.mSurface)
 29572:         return NS_ERROR_NOT_AVAILABLE;
 29572: 
 29572:     nsRefPtr<gfxPattern> thebespat = new gfxPattern(res.mSurface);
 16154: 
 16154:     thebespat->SetExtend(extend);
 16154: 
 29572:     nsRefPtr<nsCanvasPattern> pat = new nsCanvasPattern(thebespat, res.mPrincipal,
 78159:                                                         res.mIsWriteOnly,
 78159:                                                         res.mCORSUsed);
 16154:     *_retval = pat.forget().get();
     1:     return NS_OK;
     1: }
     1: 
     1: //
     1: // shadows
     1: //
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetShadowOffsetX(float x)
     1: {
     1:     if (!FloatValidate(x))
 64488:         return NS_OK;
 64488: 
 19733:     CurrentState().shadowOffset.x = x;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetShadowOffsetX(float *x)
     1: {
 19733:     *x = static_cast<float>(CurrentState().shadowOffset.x);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetShadowOffsetY(float y)
     1: {
     1:     if (!FloatValidate(y))
 64488:         return NS_OK;
 64488: 
 19733:     CurrentState().shadowOffset.y = y;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetShadowOffsetY(float *y)
     1: {
 19733:     *y = static_cast<float>(CurrentState().shadowOffset.y);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetShadowBlur(float blur)
     1: {
 64488:     if (!FloatValidate(blur) || blur < 0.0)
 19733:         return NS_OK;
 64488: 
 19733:     CurrentState().shadowBlur = blur;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetShadowBlur(float *blur)
     1: {
 19733:     *blur = CurrentState().shadowBlur;
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 19733: nsCanvasRenderingContext2D::SetShadowColor(const nsAString& colorstr)
     1: {
 59514:     nsIDocument* document = mCanvasElement ?
 80526:                             HTMLCanvasElement()->OwnerDoc() : nsnull;
 59514: 
 59514:     // Pass the CSS Loader object to the parser, to allow parser error reports
 59514:     // to include the outer window ID.
 59514:     nsCSSParser parser(document ? document->CSSLoader() : nsnull);
 19733:     nscolor color;
 38849:     nsresult rv = parser.ParseColorString(colorstr, nsnull, 0, &color);
 19733:     if (NS_FAILED(rv)) {
 19733:         // Error reporting happens inside the CSS parser
 19733:         return NS_OK;
 19733:     }
 19733: 
 19733:     CurrentState().SetColorStyle(STYLE_SHADOW, color);
 19733: 
 80486:     mDirtyStyle[STYLE_SHADOW] = true;
 19733: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetShadowColor(nsAString& color)
     1: {
 19733:     StyleColorToString(CurrentState().colorStyles[STYLE_SHADOW], color);
 19733: 
 19733:     return NS_OK;
 19733: }
 19733: 
 55253: static const gfxFloat SIGMA_MAX = 100;
 19733: 
 19733: gfxContext*
 19733: nsCanvasRenderingContext2D::ShadowInitialize(const gfxRect& extents, gfxAlphaBoxBlur& blur)
 19733: {
 19733:     gfxIntSize blurRadius;
 19733: 
 52476:     float shadowBlur = CurrentState().shadowBlur;
 55253:     gfxFloat sigma = shadowBlur / 2;
 19733:     // limit to avoid overly huge temp images
 19733:     if (sigma > SIGMA_MAX)
 19733:         sigma = SIGMA_MAX;
 19733:     blurRadius = gfxAlphaBoxBlur::CalculateBlurRadius(gfxPoint(sigma, sigma));
 19733: 
 19733:     // calculate extents
 19733:     gfxRect drawExtents = extents;
 19733: 
 19733:     // intersect with clip to avoid making overly huge temp images
 19733:     gfxMatrix matrix = mThebes->CurrentMatrix();
 19733:     mThebes->IdentityMatrix();
 19733:     gfxRect clipExtents = mThebes->GetClipExtents();
 19733:     mThebes->SetMatrix(matrix);
 19733:     // outset by the blur radius so that blurs can leak onto the canvas even
 19733:     // when the shape is outside the clipping area
 68641:     clipExtents.Inflate(blurRadius.width, blurRadius.height);
 19733:     drawExtents = drawExtents.Intersect(clipExtents - CurrentState().shadowOffset);
 19733: 
 51264:     gfxContext* ctx = blur.Init(drawExtents, gfxIntSize(0,0), blurRadius, nsnull, nsnull);
 19733: 
 19733:     if (!ctx)
 19733:         return nsnull;
 19733: 
 19733:     return ctx;
 19733: }
 19733: 
 19733: void
 19733: nsCanvasRenderingContext2D::ShadowFinalize(gfxAlphaBoxBlur& blur)
 19733: {
 77560:     if (!EnsureSurface())
 77560:         return;
 77560: 
 19733:     ApplyStyle(STYLE_SHADOW);
 19733:     // canvas matrix was already applied, don't apply it twice, but do
 19733:     // apply the shadow offset
 19733:     gfxMatrix matrix = mThebes->CurrentMatrix();
 19733:     mThebes->IdentityMatrix();
 19733:     mThebes->Translate(CurrentState().shadowOffset);
 19733: 
 19733:     blur.Paint(mThebes);
 19733:     mThebes->SetMatrix(matrix);
 19733: }
 19733: 
 19733: nsresult
 29573: nsCanvasRenderingContext2D::DrawPath(Style style, gfxRect *dirtyRect)
 19733: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 79445:     bool doUseIntermediateSurface = false;
 55204:     
 55204:     if (mSurface->GetType() == gfxASurface::SurfaceTypeD2D) {
 55206:       if (style != STYLE_FILL) {
 55204:         // D2D does all operators correctly even if transparent areas of SOURCE
 55204:         // affect dest. We need to use an intermediate surface for STROKE because
 55204:         // we can't clip to the actual stroke shape easily, but prefer a geometric
 55204:         // clip over an intermediate surface for a FILL.
 55204:         doUseIntermediateSurface = NeedIntermediateSurfaceToHandleGlobalAlpha(style);
 55204:       }
 55204:     } else {
 19733:       /*
 19733:        * Need an intermediate surface when:
 19733:        * - globalAlpha != 1 and gradients/patterns are used (need to paint_with_alpha)
 36899:        * - certain operators are used
 19733:        */
 55204:       doUseIntermediateSurface = NeedToUseIntermediateSurface() ||
 54783:                                  NeedIntermediateSurfaceToHandleGlobalAlpha(style);
 55204:     }
 19733: 
 79445:     bool doDrawShadow = NeedToDrawShadow();
 19733: 
 36900:     // Clear the surface if we need to simulate unbounded SOURCE operator
 36900:     ClearSurfaceForUnboundedSource();
 36900: 
 19733:     if (doDrawShadow) {
 19733:         gfxMatrix matrix = mThebes->CurrentMatrix();
 19733:         mThebes->IdentityMatrix();
 19733: 
 19733:         // calculate extents of path
 19733:         gfxRect drawExtents;
 19733:         if (style == STYLE_FILL)
 19733:             drawExtents = mThebes->GetUserFillExtent();
 19733:         else // STYLE_STROKE
 19733:             drawExtents = mThebes->GetUserStrokeExtent();
 19733: 
 19733:         mThebes->SetMatrix(matrix);
 19733: 
 19733:         gfxAlphaBoxBlur blur;
 19733: 
 19733:         // no need for a ref here, the blur owns the context
 19733:         gfxContext* ctx = ShadowInitialize(drawExtents, blur);
 19733:         if (ctx) {
 80486:             ApplyStyle(style, false);
 19733:             CopyContext(ctx, mThebes);
 19733:             ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 19733: 
 19733:             if (style == STYLE_FILL)
 19733:                 ctx->Fill();
 19733:             else
 19733:                 ctx->Stroke();
 19733: 
 19733:             ShadowFinalize(blur);
 19733:         }
 19733:     }
 19733: 
 19733:     if (doUseIntermediateSurface) {
 19733:         nsRefPtr<gfxPath> path = mThebes->CopyPath();
 19733:         // if the path didn't copy correctly then we can't restore it, so bail
 19733:         if (!path)
 19733:             return NS_ERROR_FAILURE;
 19733: 
 19733:         // draw onto a pushed group
 19733:         mThebes->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
 19733: 
 19733:         // XXX for some reason clipping messes up the path when push/popping
 19733:         // copying the path seems to fix it, for unknown reasons
 19733:         mThebes->NewPath();
 19733:         mThebes->AppendPath(path);
 19733: 
 55204:         // don't want operators to be applied twice,
 55204:         if (mSurface->GetType() != gfxASurface::SurfaceTypeD2D) {
 19733:             mThebes->SetOperator(gfxContext::OPERATOR_SOURCE);
 55204:         } else {
 55204:             // In the case of D2D OPERATOR_OVER is much faster. So we can just
 55204:             // use that since it's the same as SOURCE for a transparent
 55204:             // destinations. It would be nice if cairo backends could make this
 55204:             // optimization internally but I see no very good way of doing this.
 55204:             mThebes->SetOperator(gfxContext::OPERATOR_OVER);
 55204:         }
 19733:     }
 19733: 
 19733:     ApplyStyle(style);
 55204: 
 55204:     if (style == STYLE_FILL) {
 55204:         if (!doUseIntermediateSurface &&
 55204:             CurrentState().globalAlpha != 1.0 &&
 55204:             !CurrentState().StyleIsColor(style))
 55204:         {
 55204:             mThebes->Clip();
 55204:             mThebes->Paint(CurrentState().globalAlpha);
 55204:         } else {
 19733:             mThebes->Fill();
 55204:         }
 55204:     } else
 19733:         mThebes->Stroke();
 19733: 
 29573:     // XXX do some more work to calculate the extents of shadows
 29573:     // XXX handle stroke extents
 29573:     if (dirtyRect && style == STYLE_FILL && !doDrawShadow) {
 29573:         *dirtyRect = mThebes->GetUserPathExtent();
 29573:     }
 29573: 
 19733:     if (doUseIntermediateSurface) {
 19733:         mThebes->PopGroupToSource();
 19733:         DirtyAllStyles();
 19733: 
 19733:         mThebes->Paint(CurrentState().StyleIsColor(style) ? 1.0 : CurrentState().globalAlpha);
 19733:     }
 19733: 
 29573:     if (dirtyRect) {
 29573:         if (style != STYLE_FILL || doDrawShadow) {
 29573:             // just use the clip extents
 29573:             *dirtyRect = mThebes->GetClipExtents();
 29573:         }
 29573:     }
 29573: 
     1:     return NS_OK;
     1: }
     1: 
     1: //
     1: // rects
     1: //
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::ClearRect(float x, float y, float w, float h)
     1: {
 77560:     if (!mSurfaceCreated)
 77560:         return NS_OK;
 77560: 
     1:     if (!FloatValidate(x,y,w,h))
 64433:         return NS_OK;
     1: 
 63842:     PathAutoSaveRestore pathSR(this);
 19733:     gfxContextAutoSaveRestore autoSR(mThebes);
 19733: 
 16154:     mThebes->SetOperator(gfxContext::OPERATOR_CLEAR);
 16154:     mThebes->NewPath();
 16154:     mThebes->Rectangle(gfxRect(x, y, w, h));
 16154:     mThebes->Fill();
 16154: 
 63841:     return RedrawUser(mThebes->GetUserPathExtent());
 16154: }
 16154: 
 16154: nsresult
 16154: nsCanvasRenderingContext2D::DrawRect(const gfxRect& rect, Style style)
 16154: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 68632:     if (!FloatValidate(rect.X(), rect.Y(), rect.Width(), rect.Height()))
 68020:         return NS_OK;
 16154: 
 63842:     PathAutoSaveRestore pathSR(this);
 16154: 
 16154:     mThebes->NewPath();
 16154:     mThebes->Rectangle(rect);
 16154: 
 29573:     gfxRect dirty;
 29573:     nsresult rv = DrawPath(style, &dirty);
 19733:     if (NS_FAILED(rv))
 19733:         return rv;
     1: 
 63841:     return RedrawUser(dirty);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::FillRect(float x, float y, float w, float h)
     1: {
 16154:     return DrawRect(gfxRect(x, y, w, h), STYLE_FILL);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::StrokeRect(float x, float y, float w, float h)
     1: {
 71612:     if (w == 0.f && h == 0.f) {
 71612:         return NS_OK;
 71612:     }
 16154:     return DrawRect(gfxRect(x, y, w, h), STYLE_STROKE);
     1: }
     1: 
     1: //
     1: // path bits
     1: //
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::BeginPath()
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 80486:     mHasPath = false;
 16154:     mThebes->NewPath();
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::ClosePath()
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     mThebes->ClosePath();
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Fill()
     1: {
 29573:     gfxRect dirty;
 29573:     nsresult rv = DrawPath(STYLE_FILL, &dirty);
 19733:     if (NS_FAILED(rv))
 19733:         return rv;
 63841:     return RedrawUser(dirty);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Stroke()
     1: {
 29573:     gfxRect dirty;
 29573:     nsresult rv = DrawPath(STYLE_STROKE, &dirty);
 19733:     if (NS_FAILED(rv))
 19733:         return rv;
 63841:     return RedrawUser(dirty);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Clip()
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     mThebes->Clip();
 16362:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::MoveTo(float x, float y)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(x,y))
 64637:         return NS_OK;
     1: 
 80486:     mHasPath = true;
 16154:     mThebes->MoveTo(gfxPoint(x, y));
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::LineTo(float x, float y)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(x,y))
 64636:         return NS_OK;
     1: 
 80486:     mHasPath = true;
 16154:     mThebes->LineTo(gfxPoint(x, y));
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::QuadraticCurveTo(float cpx, float cpy, float x, float y)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(cpx,cpy,x,y))
 64638:         return NS_OK;
     1: 
     1:     // we will always have a current point, since beginPath forces
     1:     // a moveto(0,0)
 16154:     gfxPoint c = mThebes->CurrentPoint();
 16154:     gfxPoint p(x,y);
 16154:     gfxPoint cp(cpx, cpy);
 16154: 
 80486:     mHasPath = true;
 16154:     mThebes->CurveTo((c+cp*2)/3.0, (p+cp*2)/3.0, p);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::BezierCurveTo(float cp1x, float cp1y,
     1:                                           float cp2x, float cp2y,
     1:                                           float x, float y)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(cp1x,cp1y,cp2x,cp2y,x,y))
 70905:         return NS_OK;
     1: 
 80486:     mHasPath = true;
 16154:     mThebes->CurveTo(gfxPoint(cp1x, cp1y),
 16154:                      gfxPoint(cp2x, cp2y),
 16154:                      gfxPoint(x, y));
 16154: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::ArcTo(float x1, float y1, float x2, float y2, float radius)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(x1,y1,x2,y2,radius))
 70904:         return NS_OK;
     1: 
 29337:     if (radius < 0)
     1:         return NS_ERROR_DOM_INDEX_SIZE_ERR;
     1: 
 80486:     mHasPath = true;
 63842: 
 16154:     gfxPoint p0 = mThebes->CurrentPoint();
 16154: 
 29337:     double dir, a2, b2, c2, cosx, sinx, d, anx, any, bnx, bny, x3, y3, x4, y4, cx, cy, angle0, angle1;
 29337:     bool anticlockwise;
 29337: 
 29337:     if ((x1 == p0.x && y1 == p0.y) || (x1 == x2 && y1 == y2) || radius == 0) {
 29337:         mThebes->LineTo(gfxPoint(x1, y1));
 29337:         return NS_OK;
     1:     }
     1: 
 29337:     dir = (x2-x1)*(p0.y-y1) + (y2-y1)*(x1-p0.x);
 29337:     if (dir == 0) {
 29337:         mThebes->LineTo(gfxPoint(x1, y1));
 29337:         return NS_OK;
     1:     }
 29337: 
 29337:     a2 = (p0.x-x1)*(p0.x-x1) + (p0.y-y1)*(p0.y-y1);
 29337:     b2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
 29337:     c2 = (p0.x-x2)*(p0.x-x2) + (p0.y-y2)*(p0.y-y2);
 29337:     cosx = (a2+b2-c2)/(2*sqrt(a2*b2));
 29337: 
 29337:     sinx = sqrt(1 - cosx*cosx);
 29337:     d = radius / ((1 - cosx) / sinx);
 29337: 
 29337:     anx = (x1-p0.x) / sqrt(a2);
 29337:     any = (y1-p0.y) / sqrt(a2);
 29337:     bnx = (x1-x2) / sqrt(b2);
 29337:     bny = (y1-y2) / sqrt(b2);
 29337:     x3 = x1 - anx*d;
 29337:     y3 = y1 - any*d;
 29337:     x4 = x1 - bnx*d;
 29337:     y4 = y1 - bny*d;
 29337:     anticlockwise = (dir < 0);
 29337:     cx = x3 + any*radius*(anticlockwise ? 1 : -1);
 29337:     cy = y3 - anx*radius*(anticlockwise ? 1 : -1);
 29337:     angle0 = atan2((y3-cy), (x3-cx));
 29337:     angle1 = atan2((y4-cy), (x4-cx));
 29337: 
 29337:     mThebes->LineTo(gfxPoint(x3, y3));
 29337: 
 29337:     if (anticlockwise)
 29337:         mThebes->NegativeArc(gfxPoint(cx, cy), radius, angle0, angle1);
     1:     else
 29337:         mThebes->Arc(gfxPoint(cx, cy), radius, angle0, angle1);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2D::Arc(float x, float y, float r, float startAngle, float endAngle, bool ccw)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(x,y,r,startAngle,endAngle))
 68021:         return NS_OK;
     1: 
 61742:     if (r < 0.0)
 61742:         return NS_ERROR_DOM_INDEX_SIZE_ERR;
 61742: 
 16154:     gfxPoint p(x,y);
 16154: 
 80486:     mHasPath = true;
     1:     if (ccw)
 16154:         mThebes->NegativeArc(p, r, startAngle, endAngle);
     1:     else
 16154:         mThebes->Arc(p, r, startAngle, endAngle);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::Rect(float x, float y, float w, float h)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     if (!FloatValidate(x,y,w,h))
 64639:         return NS_OK;
     1: 
 80486:     mHasPath = true;
 16154:     mThebes->Rectangle(gfxRect(x, y, w, h));
     1:     return NS_OK;
     1: }
     1: 
  3964: //
  3964: // text
  3964: //
 15295: 
 15400: /**
 15400:  * Helper function for SetFont that creates a style rule for the given font.
 15400:  * @param aFont The CSS font string
 15400:  * @param aNode The canvas element
 15400:  * @param aResult Pointer in which to place the new style rule.
 15400:  * @remark Assumes all pointer arguments are non-null.
 15400:  */
 15400: static nsresult
 15400: CreateFontStyleRule(const nsAString& aFont,
 15400:                     nsINode* aNode,
 63693:                     css::StyleRule** aResult)
 15400: {
 63693:     nsRefPtr<css::StyleRule> rule;
 79445:     bool changed;
 15400: 
 15400:     nsIPrincipal* principal = aNode->NodePrincipal();
 80526:     nsIDocument* document = aNode->OwnerDoc();
 48173: 
 15400:     nsIURI* docURL = document->GetDocumentURI();
 41900:     nsIURI* baseURL = document->GetDocBaseURI();
 15400: 
 59514:     // Pass the CSS Loader object to the parser, to allow parser error reports
 59514:     // to include the outer window ID.
 59514:     nsCSSParser parser(document->CSSLoader());
 59514: 
 48173:     nsresult rv = parser.ParseStyleAttribute(EmptyString(), docURL, baseURL,
 48173:                                              principal, getter_AddRefs(rule));
 15400:     if (NS_FAILED(rv))
 15400:         return rv;
 15400: 
 48173:     rv = parser.ParseProperty(eCSSProperty_font, aFont, docURL, baseURL,
 48173:                               principal, rule->GetDeclaration(), &changed,
 80486:                               false);
 48173:     if (NS_FAILED(rv))
 48173:         return rv;
 48173: 
 48173:     rv = parser.ParseProperty(eCSSProperty_line_height,
 48173:                               NS_LITERAL_STRING("normal"), docURL, baseURL,
 48173:                               principal, rule->GetDeclaration(), &changed,
 80486:                               false);
 48173:     if (NS_FAILED(rv))
 48173:         return rv;
 48173: 
 48173:     rule->RuleMatched();
 48173: 
 48173:     rule.forget(aResult);
 15400:     return NS_OK;
 15400: }
 15400: 
  3964: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::SetFont(const nsAString& font)
  3964: {
 15400:     nsresult rv;
 15400: 
 15400:     /*
 15400:      * If font is defined with relative units (e.g. ems) and the parent
 15400:      * style context changes in between calls, setting the font to the
 15400:      * same value as previous could result in a different computed value,
 15400:      * so we cannot have the optimization where we check if the new font
 15400:      * string is equal to the old one.
 15400:      */
 15400: 
 15400:     nsCOMPtr<nsIContent> content = do_QueryInterface(mCanvasElement);
 31123:     if (!content && !mDocShell) {
 31123:         NS_WARNING("Canvas element must be an nsIContent and non-null or a docshell must be provided");
 12667:         return NS_ERROR_FAILURE;
 12667:     }
 12667: 
 31123:     nsIPresShell* presShell = GetPresShell();
 12667:     if (!presShell)
 12667:       return NS_ERROR_FAILURE;
 31123:     nsIDocument* document = presShell->GetDocument();
  3964: 
  3964:     nsCOMArray<nsIStyleRule> rules;
  3964: 
 63693:     nsRefPtr<css::StyleRule> rule;
 38849:     rv = CreateFontStyleRule(font, document, getter_AddRefs(rule));
 15400:     if (NS_FAILED(rv))
 15400:         return rv;
  3964: 
 48174:     css::Declaration *declaration = rule->GetDeclaration();
 48174:     // The easiest way to see whether we got a syntax error or whether
 48174:     // we got 'inherit' or 'initial' is to look at font-size-adjust,
 48174:     // which the shorthand resets to either 'none' or
 48174:     // '-moz-system-font'.
 48174:     // We know the declaration is not !important, so we can use
 48174:     // GetNormalBlock().
 48174:     const nsCSSValue *fsaVal =
 50932:       declaration->GetNormalBlock()->ValueFor(eCSSProperty_font_size_adjust);
 48174:     if (!fsaVal || (fsaVal->GetUnit() != eCSSUnit_None &&
 48174:                     fsaVal->GetUnit() != eCSSUnit_System_Font)) {
 48174:         // We got an all-property value or a syntax error.  The spec says
 48174:         // this value must be ignored.
 48174:         return NS_OK;
 48174:     }
 48174: 
  3964:     rules.AppendObject(rule);
  3964: 
 12667:     nsStyleSet* styleSet = presShell->StyleSet();
  3964: 
 15400:     // have to get a parent style context for inherit-like relative
 15400:     // values (2em, bolder, etc.)
 15400:     nsRefPtr<nsStyleContext> parentContext;
 15400: 
 31123:     if (content && content->IsInDoc()) {
 15400:         // inherit from the canvas element
 41643:         parentContext = nsComputedDOMStyle::GetStyleContextForElement(
 41643:                 content->AsElement(),
 15400:                 nsnull,
 15400:                 presShell);
 15400:     } else {
 67820:         // otherwise inherit from default
 63693:         nsRefPtr<css::StyleRule> parentRule;
 67820:         rv = CreateFontStyleRule(kDefaultFontStyle,
 31123:                                  document,
 15400:                                  getter_AddRefs(parentRule));
 15400:         if (NS_FAILED(rv))
 15400:             return rv;
 15400:         nsCOMArray<nsIStyleRule> parentRules;
 15400:         parentRules.AppendObject(parentRule);
 40171:         parentContext = styleSet->ResolveStyleForRules(nsnull, parentRules);
 15400:     }
 15400: 
 15400:     if (!parentContext)
 15295:         return NS_ERROR_FAILURE;
 15400: 
 31309:     nsRefPtr<nsStyleContext> sc =
 40171:         styleSet->ResolveStyleForRules(parentContext, rules);
 15400:     if (!sc)
 15295:         return NS_ERROR_FAILURE;
  3964:     const nsStyleFont* fontStyle = sc->GetStyleFont();
  3964: 
  3964:     NS_ASSERTION(fontStyle, "Could not obtain font style");
  3964: 
 88039:     nsIAtom* language = sc->GetStyleFont()->mLanguage;
 38749:     if (!language) {
 38749:         language = presShell->GetPresContext()->GetLanguageFromCharset();
 38749:     }
 38749: 
 15666:     // use CSS pixels instead of dev pixels to avoid being affected by page zoom
 15666:     const PRUint32 aupcp = nsPresContext::AppUnitsPerCSSPixel();
 15666:     // un-zoom the font size to avoid being affected by text-only zoom
 88469:     //
 88469:     // Purposely ignore the font size that respects the user's minimum
 88469:     // font preference (fontStyle->mFont.size) in favor of the
 88469:     // computed size (fontStyle->mSize).  See
 88469:     // https://bugzilla.mozilla.org/show_bug.cgi?id=698652.
 88469:     const nscoord fontSize = nsStyleFont::UnZoomText(parentContext->PresContext(), fontStyle->mSize);
  3964: 
 79445:     bool printerFont = (presShell->GetPresContext()->Type() == nsPresContext::eContext_PrintPreview ||
 22866:                           presShell->GetPresContext()->Type() == nsPresContext::eContext_Print);
 22866: 
  3964:     gfxFontStyle style(fontStyle->mFont.style,
  3964:                        fontStyle->mFont.weight,
 24408:                        fontStyle->mFont.stretch,
 41037:                        NSAppUnitsToFloatPixels(fontSize, float(aupcp)),
 38492:                        language,
  3964:                        fontStyle->mFont.sizeAdjust,
  3964:                        fontStyle->mFont.systemFont,
 47359:                        printerFont,
 47359:                        fontStyle->mFont.languageOverride);
  3964: 
 96988:     fontStyle->mFont.AddFontFeaturesToStyle(&style);
 96988: 
 38493:     CurrentState().fontGroup =
 38493:         gfxPlatform::GetPlatform()->CreateFontGroup(fontStyle->mFont.name,
 38493:                                                     &style,
 38493:                                                     presShell->GetPresContext()->GetUserFontSet());
 15295:     NS_ASSERTION(CurrentState().fontGroup, "Could not get font group");
 48174: 
 48174:     // The font getter is required to be reserialized based on what we
 48174:     // parsed (including having line-height removed).  (Older drafts of
 48174:     // the spec required font sizes be converted to pixels, but that no
 48174:     // longer seems to be required.)
 48174:     declaration->GetValue(eCSSProperty_font, CurrentState().font);
 48174: 
  3964:     return NS_OK;
  3964: }
  3964: 
  3964: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::GetFont(nsAString& font)
 15295: {
 15295:     /* will initilize the value if not set, else does nothing */
 15295:     GetCurrentFontStyle();
 15295: 
 15295:     font = CurrentState().font;
 15295:     return NS_OK;
 15295: }
 15295: 
 15295: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::SetTextAlign(const nsAString& ta)
 15295: {
 15295:     if (ta.EqualsLiteral("start"))
 15295:         CurrentState().textAlign = TEXT_ALIGN_START;
 15295:     else if (ta.EqualsLiteral("end"))
 15295:         CurrentState().textAlign = TEXT_ALIGN_END;
 15295:     else if (ta.EqualsLiteral("left"))
 15295:         CurrentState().textAlign = TEXT_ALIGN_LEFT;
 15295:     else if (ta.EqualsLiteral("right"))
 15295:         CurrentState().textAlign = TEXT_ALIGN_RIGHT;
 15295:     else if (ta.EqualsLiteral("center"))
 15295:         CurrentState().textAlign = TEXT_ALIGN_CENTER;
 15295: 
 15295:     return NS_OK;
 15295: }
 15295: 
 15295: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::GetTextAlign(nsAString& ta)
 15295: {
 15295:     switch (CurrentState().textAlign)
 15295:     {
 15295:     case TEXT_ALIGN_START:
 15295:         ta.AssignLiteral("start");
 15295:         break;
 15295:     case TEXT_ALIGN_END:
 15295:         ta.AssignLiteral("end");
 15295:         break;
 15295:     case TEXT_ALIGN_LEFT:
 15295:         ta.AssignLiteral("left");
 15295:         break;
 15295:     case TEXT_ALIGN_RIGHT:
 15295:         ta.AssignLiteral("right");
 15295:         break;
 15295:     case TEXT_ALIGN_CENTER:
 15295:         ta.AssignLiteral("center");
 15295:         break;
 15295:     }
 15295: 
 15295:     return NS_OK;
 15295: }
 15295: 
 15295: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::SetTextBaseline(const nsAString& tb)
 15295: {
 15295:     if (tb.EqualsLiteral("top"))
 15295:         CurrentState().textBaseline = TEXT_BASELINE_TOP;
 15295:     else if (tb.EqualsLiteral("hanging"))
 15295:         CurrentState().textBaseline = TEXT_BASELINE_HANGING;
 15295:     else if (tb.EqualsLiteral("middle"))
 15295:         CurrentState().textBaseline = TEXT_BASELINE_MIDDLE;
 15295:     else if (tb.EqualsLiteral("alphabetic"))
 15295:         CurrentState().textBaseline = TEXT_BASELINE_ALPHABETIC;
 15295:     else if (tb.EqualsLiteral("ideographic"))
 15295:         CurrentState().textBaseline = TEXT_BASELINE_IDEOGRAPHIC;
 15295:     else if (tb.EqualsLiteral("bottom"))
 15295:         CurrentState().textBaseline = TEXT_BASELINE_BOTTOM;
 15295: 
 15295:     return NS_OK;
 15295: }
 15295: 
 15295: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::GetTextBaseline(nsAString& tb)
 15295: {
 15295:     switch (CurrentState().textBaseline)
 15295:     {
 15295:     case TEXT_BASELINE_TOP:
 15295:         tb.AssignLiteral("top");
 15295:         break;
 15295:     case TEXT_BASELINE_HANGING:
 15295:         tb.AssignLiteral("hanging");
 15295:         break;
 15295:     case TEXT_BASELINE_MIDDLE:
 15295:         tb.AssignLiteral("middle");
 15295:         break;
 15295:     case TEXT_BASELINE_ALPHABETIC:
 15295:         tb.AssignLiteral("alphabetic");
 15295:         break;
 15295:     case TEXT_BASELINE_IDEOGRAPHIC:
 15295:         tb.AssignLiteral("ideographic");
 15295:         break;
 15295:     case TEXT_BASELINE_BOTTOM:
 15295:         tb.AssignLiteral("bottom");
 15295:         break;
 15295:     }
 15295: 
 15295:     return NS_OK;
 15295: }
 15295: 
 15295: /*
 15295:  * Helper function that replaces the whitespace characters in a string
 15295:  * with U+0020 SPACE. The whitespace characters are defined as U+0020 SPACE,
 15295:  * U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), U+000B LINE
 15295:  * TABULATION, U+000C FORM FEED (FF), and U+000D CARRIAGE RETURN (CR).
 15295:  * @param str The string whose whitespace characters to replace.
 15295:  */
 15400: static inline void
 15400: TextReplaceWhitespaceCharacters(nsAutoString& str)
 15295: {
 15295:     str.ReplaceChar("\x09\x0A\x0B\x0C\x0D", PRUnichar(' '));
 15295: }
 15295: 
 15295: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::FillText(const nsAString& text, float x, float y, float maxWidth)
 15295: {
 16043:     return DrawOrMeasureText(text, x, y, maxWidth, TEXT_DRAW_OPERATION_FILL, nsnull);
 15295: }
 15295: 
 15295: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::StrokeText(const nsAString& text, float x, float y, float maxWidth)
 15295: {
 16043:     return DrawOrMeasureText(text, x, y, maxWidth, TEXT_DRAW_OPERATION_STROKE, nsnull);
 15295: }
 15295: 
 16043: NS_IMETHODIMP
 16043: nsCanvasRenderingContext2D::MeasureText(const nsAString& rawText,
 16043:                                         nsIDOMTextMetrics** _retval)
 16043: {
 16043:     float width;
 16043: 
 16043:     nsresult rv = DrawOrMeasureText(rawText, 0, 0, 0, TEXT_DRAW_OPERATION_MEASURE, &width);
 16043: 
 16043:     if (NS_FAILED(rv))
 16043:         return rv;
 16043: 
 16043:     nsRefPtr<nsIDOMTextMetrics> textMetrics = new nsTextMetrics(width);
 16043:     if (!textMetrics.get())
 16043:         return NS_ERROR_OUT_OF_MEMORY;
 16043: 
 16043:     *_retval = textMetrics.forget().get();
 16043: 
 16043:     return NS_OK;
 16043: }
 16043: 
 16043: /**
 16043:  * Used for nsBidiPresUtils::ProcessText
 16043:  */
 16043: struct NS_STACK_CLASS nsCanvasBidiProcessor : public nsBidiPresUtils::BidiProcessor
 16043: {
 16043:     virtual void SetText(const PRUnichar* text, PRInt32 length, nsBidiDirection direction)
 16043:     {
 95666:         mFontgrp->UpdateFontList(); // ensure user font generation is current
 86690:         mTextRun = mFontgrp->MakeTextRun(text,
 16043:                                          length,
 19733:                                          mThebes,
 16043:                                          mAppUnitsPerDevPixel,
 16043:                                          direction==NSBIDI_RTL ? gfxTextRunFactory::TEXT_IS_RTL : 0);
 16043:     }
 16043: 
 16043:     virtual nscoord GetWidth()
 16043:     {
 16043:         gfxTextRun::Metrics textRunMetrics = mTextRun->MeasureText(0,
 16043:                                                                    mTextRun->GetLength(),
 25417:                                                                    mDoMeasureBoundingBox ?
 25417:                                                                        gfxFont::TIGHT_INK_EXTENTS :
 25417:                                                                        gfxFont::LOOSE_INK_EXTENTS,
 19733:                                                                    mThebes,
 16043:                                                                    nsnull);
 16043: 
 19733:         // this only measures the height; the total width is gotten from the
 19733:         // the return value of ProcessText.
 19733:         if (mDoMeasureBoundingBox) {
 19733:             textRunMetrics.mBoundingBox.Scale(1.0 / mAppUnitsPerDevPixel);
 19733:             mBoundingBox = mBoundingBox.Union(textRunMetrics.mBoundingBox);
 19733:         }
 19733: 
 72749:         return NSToCoordRound(textRunMetrics.mAdvanceWidth);
 16043:     }
 16043: 
 16043:     virtual void DrawText(nscoord xOffset, nscoord width)
 16043:     {
 16043:         gfxPoint point = mPt;
 84284:         point.x += xOffset;
 16043: 
 16043:         // offset is given in terms of left side of string
 48913:         if (mTextRun->IsRightToLeft()) {
 48913:             // Bug 581092 - don't use rounded pixel width to advance to
 48913:             // right-hand end of run, because this will cause different
 48913:             // glyph positioning for LTR vs RTL drawing of the same
 48913:             // glyph string on OS X and DWrite where textrun widths may
 48913:             // involve fractional pixels.
 48913:             gfxTextRun::Metrics textRunMetrics =
 48913:                 mTextRun->MeasureText(0,
 48913:                                       mTextRun->GetLength(),
 48913:                                       mDoMeasureBoundingBox ?
 48913:                                           gfxFont::TIGHT_INK_EXTENTS :
 48913:                                           gfxFont::LOOSE_INK_EXTENTS,
 48913:                                       mThebes,
 48913:                                       nsnull);
 48913:             point.x += textRunMetrics.mAdvanceWidth;
 48913:             // old code was:
 48913:             //   point.x += width * mAppUnitsPerDevPixel;
 48913:             // TODO: restore this if/when we move to fractional coords
 48913:             // throughout the text layout process
 48913:         }
 16043: 
 19733:         mTextRun->Draw(mThebes,
 16043:                        point,
 88295:                        mOp == nsCanvasRenderingContext2D::TEXT_DRAW_OPERATION_STROKE ?
 88295:                                     gfxFont::GLYPH_STROKE : gfxFont::GLYPH_FILL,
 16043:                        0,
 16043:                        mTextRun->GetLength(),
 16043:                        nsnull,
 89450:                        nsnull,
 16043:                        nsnull);
 16043:     }
 16043: 
 16043:     // current text run
 86690:     nsAutoPtr<gfxTextRun> mTextRun;
 16043: 
 19733:     // pointer to the context, may not be the canvas's context
 19733:     // if an intermediate surface is being used
 19733:     gfxContext* mThebes;
 16043: 
 16043:     // position of the left side of the string, alphabetic baseline
 16043:     gfxPoint mPt;
 16043: 
 16043:     // current font
 16043:     gfxFontGroup* mFontgrp;
 16043: 
 16043:     // dev pixel conversion factor
 16043:     PRUint32 mAppUnitsPerDevPixel;
 16043: 
 16043:     // operation (fill or stroke)
 16043:     nsCanvasRenderingContext2D::TextDrawOperation mOp;
 19733: 
 19733:     // union of bounding boxes of all runs, needed for shadows
 19733:     gfxRect mBoundingBox;
 19733: 
 19733:     // true iff the bounding box should be measured
 79445:     bool mDoMeasureBoundingBox;
 16043: };
 16043: 
 15295: nsresult
 16043: nsCanvasRenderingContext2D::DrawOrMeasureText(const nsAString& aRawText,
 16043:                                               float aX,
 16043:                                               float aY,
 16043:                                               float aMaxWidth,
 16043:                                               TextDrawOperation aOp,
 16043:                                               float* aWidth)
 15295: {
 16043:     nsresult rv;
 16043: 
 16043:     if (!FloatValidate(aX, aY, aMaxWidth))
 15295:         return NS_ERROR_DOM_SYNTAX_ERR;
 15295: 
 16043:     // spec isn't clear on what should happen if aMaxWidth <= 0, so
 15295:     // treat it as an invalid argument
 15295:     // technically, 0 should be an invalid value as well, but 0 is the default
 15295:     // arg, and there is no way to tell if the default was used
 16043:     if (aMaxWidth < 0)
 15295:         return NS_ERROR_INVALID_ARG;
 15295: 
 15400:     nsCOMPtr<nsIContent> content = do_QueryInterface(mCanvasElement);
 31123:     if (!content && !mDocShell) {
 31123:         NS_WARNING("Canvas element must be an nsIContent and non-null or a docshell must be provided");
 15400:         return NS_ERROR_FAILURE;
 15400:     }
 15400: 
100364:     nsCOMPtr<nsIPresShell> presShell = GetPresShell();
 15400:     if (!presShell)
 15400:         return NS_ERROR_FAILURE;
 15400: 
 31123:     nsIDocument* document = presShell->GetDocument();
 31123: 
 15295:     // replace all the whitespace characters with U+0020 SPACE
 16043:     nsAutoString textToDraw(aRawText);
 15295:     TextReplaceWhitespaceCharacters(textToDraw);
 15295: 
 15400:     // for now, default to ltr if not in doc
 79445:     bool isRTL = false;
 15400: 
 31123:     if (content && content->IsInDoc()) {
 15400:         // try to find the closest context
 15400:         nsRefPtr<nsStyleContext> canvasStyle =
 41643:             nsComputedDOMStyle::GetStyleContextForElement(content->AsElement(),
 15400:                                                           nsnull,
 15400:                                                           presShell);
 15400:         if (!canvasStyle)
 15400:             return NS_ERROR_FAILURE;
 15400:         isRTL = canvasStyle->GetStyleVisibility()->mDirection ==
 15295:             NS_STYLE_DIRECTION_RTL;
 31123:     } else {
 31123:       isRTL = GET_BIDI_OPTION_DIRECTION(document->GetBidiOptions()) == IBMBIDI_TEXTDIRECTION_RTL;
 15400:     }
 15295: 
 88295:     Style style = aOp == TEXT_DRAW_OPERATION_FILL ? STYLE_FILL : STYLE_STROKE;
 88295: 
 88295:     bool doDrawShadow = NeedToDrawShadow();
 88295:     bool doUseIntermediateSurface = NeedToUseIntermediateSurface()
 88295:         || NeedIntermediateSurfaceToHandleGlobalAlpha(style);
 36900: 
 36900:     // Clear the surface if we need to simulate unbounded SOURCE operator
 36900:     ClearSurfaceForUnboundedSource();
 19733: 
 16043:     nsCanvasBidiProcessor processor;
 16043: 
 16043:     GetAppUnitsValues(&processor.mAppUnitsPerDevPixel, NULL);
 16043:     processor.mPt = gfxPoint(aX, aY);
 77560:     nsRefPtr<nsRenderingContext> ctx;
 77560:     if (mThebes) {
 19733:         processor.mThebes = mThebes;
 77560:     } else {
 77560:         ctx = presShell->GetReferenceRenderingContext();
 77560:         processor.mThebes = ctx->ThebesContext(); 
 77560:     }
 16043:     processor.mOp = aOp;
 19733:     processor.mBoundingBox = gfxRect(0, 0, 0, 0);
 29573:     processor.mDoMeasureBoundingBox = doDrawShadow || !mIsEntireFrameInvalid;
 16043: 
 16043:     processor.mFontgrp = GetCurrentFontStyle();
 16043:     NS_ASSERTION(processor.mFontgrp, "font group is null");
 16043: 
 72749:     nscoord totalWidthCoord;
 16043: 
 19733:     // calls bidi algo twice since it needs the full text width and the
 19733:     // bounding boxes before rendering anything
 73724:     nsBidi bidiEngine;
 73724:     rv = nsBidiPresUtils::ProcessText(textToDraw.get(),
 15295:                                       textToDraw.Length(),
 16043:                                       isRTL ? NSBIDI_RTL : NSBIDI_LTR,
 16043:                                       presShell->GetPresContext(),
 16043:                                       processor,
 16043:                                       nsBidiPresUtils::MODE_MEASURE,
 16043:                                       nsnull,
 16043:                                       0,
 73724:                                       &totalWidthCoord,
 73724:                                       &bidiEngine);
 16043:     if (NS_FAILED(rv))
 16043:         return rv;
 16043: 
 72749:     float totalWidth = float(totalWidthCoord) / processor.mAppUnitsPerDevPixel;
 16043:     if (aWidth)
 72749:         *aWidth = totalWidth;
 16043: 
 16043:     // if only measuring, don't need to do any more work
 16043:     if (aOp==TEXT_DRAW_OPERATION_MEASURE)
 16043:         return NS_OK;
 16043: 
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 77560:     processor.mThebes = mThebes;
 77560: 
 16043:     // offset pt.x based on text align
 15295:     gfxFloat anchorX;
 15295: 
 15295:     if (CurrentState().textAlign == TEXT_ALIGN_CENTER)
 15295:         anchorX = .5;
 15295:     else if (CurrentState().textAlign == TEXT_ALIGN_LEFT ||
 15295:              (!isRTL && CurrentState().textAlign == TEXT_ALIGN_START) ||
 15295:              (isRTL && CurrentState().textAlign == TEXT_ALIGN_END))
 15295:         anchorX = 0;
 15295:     else
 15295:         anchorX = 1;
 15295: 
 16043:     processor.mPt.x -= anchorX * totalWidth;
 16043: 
 16043:     // offset pt.y based on text baseline
 97471:     processor.mFontgrp->UpdateFontList(); // ensure user font generation is current
 16043:     NS_ASSERTION(processor.mFontgrp->FontListLength()>0, "font group contains no fonts");
 16043:     const gfxFont::Metrics& fontMetrics = processor.mFontgrp->GetFontAt(0)->GetMetrics();
 15295: 
 15295:     gfxFloat anchorY;
 15295: 
 15295:     switch (CurrentState().textBaseline)
 15295:     {
 63636:     case TEXT_BASELINE_HANGING:
 63636:         // fall through; best we can do with the information available
 15295:     case TEXT_BASELINE_TOP:
 15295:         anchorY = fontMetrics.emAscent;
 15295:         break;
 15295:         break;
 15295:     case TEXT_BASELINE_MIDDLE:
 15295:         anchorY = (fontMetrics.emAscent - fontMetrics.emDescent) * .5f;
 15295:         break;
 63636:     case TEXT_BASELINE_IDEOGRAPHIC:
 63636:         // fall through; best we can do with the information available
 15295:     case TEXT_BASELINE_ALPHABETIC:
 15295:         anchorY = 0;
 15295:         break;
 15295:     case TEXT_BASELINE_BOTTOM:
 15295:         anchorY = -fontMetrics.emDescent;
 15295:         break;
 15295:     }
 15295: 
 16043:     processor.mPt.y += anchorY;
 16043: 
 19733:     // correct bounding box to get it to be the correct size/position
 68634:     processor.mBoundingBox.width = totalWidth;
 19733:     processor.mBoundingBox.MoveBy(processor.mPt);
 19733: 
 16043:     processor.mPt.x *= processor.mAppUnitsPerDevPixel;
 16043:     processor.mPt.y *= processor.mAppUnitsPerDevPixel;
 16043: 
 16043:     // if text is over aMaxWidth, then scale the text horizontally such that its
 16043:     // width is precisely aMaxWidth
 19733:     gfxContextAutoSaveRestore autoSR;
 16043:     if (aMaxWidth > 0 && totalWidth > aMaxWidth) {
 19733:         autoSR.SetContext(mThebes);
 15295:         // translate the anchor point to 0, then scale and translate back
 16043:         gfxPoint trans(aX, 0);
 16154:         mThebes->Translate(trans);
 16154:         mThebes->Scale(aMaxWidth/totalWidth, 1);
 16154:         mThebes->Translate(-trans);
 15295:     }
 15295: 
 29573:     // save the previous bounding box
 29573:     gfxRect boundingBox = processor.mBoundingBox;
 29573: 
 19733:     // don't ever need to measure the bounding box twice
 80486:     processor.mDoMeasureBoundingBox = false;
 19733: 
 19733:     if (doDrawShadow) {
 19733:         // for some reason the box is too tight, probably rounding error
 68641:         processor.mBoundingBox.Inflate(2.0);
 19733: 
 19733:         // this is unnecessarily big is max-width scaling is involved, but it
 19733:         // will still produce correct output
 19733:         gfxRect drawExtents = mThebes->UserToDevice(processor.mBoundingBox);
 19733:         gfxAlphaBoxBlur blur;
 19733: 
 19733:         gfxContext* ctx = ShadowInitialize(drawExtents, blur);
 19733: 
 19733:         if (ctx) {
 88295:             ApplyStyle(style, false);
 19733:             CopyContext(ctx, mThebes);
 19733:             ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 19733:             processor.mThebes = ctx;
 16043: 
 73724:             rv = nsBidiPresUtils::ProcessText(textToDraw.get(),
 16043:                                               textToDraw.Length(),
 16043:                                               isRTL ? NSBIDI_RTL : NSBIDI_LTR,
 16043:                                               presShell->GetPresContext(),
 16043:                                               processor,
 16043:                                               nsBidiPresUtils::MODE_DRAW,
 16043:                                               nsnull,
 16043:                                               0,
 73724:                                               nsnull,
 73724:                                               &bidiEngine);
 16043:             if (NS_FAILED(rv))
 16043:                 return rv;
 16043: 
 19733:             ShadowFinalize(blur);
 19733:         }
 19733: 
 19733:         processor.mThebes = mThebes;
 19733:     }
 19733: 
 80486:     gfxContextPathAutoSaveRestore pathSR(mThebes, false);
 19733: 
 19733:     if (doUseIntermediateSurface) {
 19733:         mThebes->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
 19733: 
 19733:         // don't want operators to be applied twice
 19733:         mThebes->SetOperator(gfxContext::OPERATOR_SOURCE);
 19733:     }
 19733: 
 88295:     ApplyStyle(style);
 19733: 
 73724:     rv = nsBidiPresUtils::ProcessText(textToDraw.get(),
 19733:                                       textToDraw.Length(),
 19733:                                       isRTL ? NSBIDI_RTL : NSBIDI_LTR,
 19733:                                       presShell->GetPresContext(),
 19733:                                       processor,
 19733:                                       nsBidiPresUtils::MODE_DRAW,
 19733:                                       nsnull,
 19733:                                       0,
 73724:                                       nsnull,
 73724:                                       &bidiEngine);
 19733: 
 19733:     // this needs to be restored before function can return
 19733:     if (doUseIntermediateSurface) {
 19733:         mThebes->PopGroupToSource();
 19733:         DirtyAllStyles();
 19733:     }
 19733: 
 19754:     if (NS_FAILED(rv))
 19733:         return rv;
 19733: 
 88295:     if (doUseIntermediateSurface)
 88295:         mThebes->Paint(CurrentState().StyleIsColor(style) ? 1.0 : CurrentState().globalAlpha);
 19733: 
 29573:     if (aOp == nsCanvasRenderingContext2D::TEXT_DRAW_OPERATION_FILL && !doDrawShadow)
 63841:         return RedrawUser(boundingBox);
 29573: 
 16043:     return Redraw();
 15295: }
 15295: 
 15295: NS_IMETHODIMP
 15295: nsCanvasRenderingContext2D::SetMozTextStyle(const nsAString& textStyle)
 15295: {
 15295:     // font and mozTextStyle are the same value
 15295:     return SetFont(textStyle);
 15295: }
 15295: 
 15295: NS_IMETHODIMP
  3964: nsCanvasRenderingContext2D::GetMozTextStyle(nsAString& textStyle)
  3964: {
 15295:     // font and mozTextStyle are the same value
 15295:     return GetFont(textStyle);
  3964: }
  3964: 
 67820: gfxFontGroup*
 67820: nsCanvasRenderingContext2D::GetCurrentFontStyle()
  3964: {
 15295:     // use lazy initilization for the font group since it's rather expensive
 15295:     if(!CurrentState().fontGroup) {
 67820:         nsresult rv = SetMozTextStyle(kDefaultFontStyle);
 67820:         if (NS_FAILED(rv)) {
 67820:             gfxFontStyle style;
 67820:             style.size = kDefaultFontSize;
 67820:             CurrentState().fontGroup =
 67820:                 gfxPlatform::GetPlatform()->CreateFontGroup(kDefaultFontName,
 67820:                                                             &style,
 67820:                                                             nsnull);
 67820:             if (CurrentState().fontGroup) {
 67820:                 CurrentState().font = kDefaultFontStyle;
 67820:                 rv = NS_OK;
 67820:             } else {
 67820:                 rv = NS_ERROR_OUT_OF_MEMORY;
 67820:             }
 67820:         }
 67820:             
 67820:         NS_ASSERTION(NS_SUCCEEDED(rv), "Default canvas font is invalid");
  3964:     }
 15295: 
 15295:     return CurrentState().fontGroup;
  3964: }
  3964: 
 67820: gfxTextRun*
 67820: nsCanvasRenderingContext2D::MakeTextRun(const PRUnichar* aText,
 67820:                                         PRUint32         aLength,
 67820:                                         PRUint32         aAppUnitsPerDevUnit,
 67820:                                         PRUint32         aFlags)
 67820: {
 67820:     gfxFontGroup* currentFontStyle = GetCurrentFontStyle();
 67820:     if (!currentFontStyle)
 67820:         return nsnull;
 95666:     currentFontStyle->UpdateFontList(); // ensure user font generation is current
 86690:     return currentFontStyle->MakeTextRun(aText, aLength,
 67820:                                          mThebes, aAppUnitsPerDevUnit, aFlags);
 67820: }
 67820: 
 67820: 
     1: //
     1: // line caps/joins
     1: //
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetLineWidth(float width)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 61744:     if (!FloatValidate(width) || width <= 0.0)
 61744:         return NS_OK;
     1: 
 16154:     mThebes->SetLineWidth(width);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetLineWidth(float *width)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560:  
 16154:     gfxFloat d = mThebes->CurrentLineWidth();
 16154:     *width = static_cast<float>(d);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetLineCap(const nsAString& capstyle)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     gfxContext::GraphicsLineCap cap;
     1: 
     1:     if (capstyle.EqualsLiteral("butt"))
 16154:         cap = gfxContext::LINE_CAP_BUTT;
     1:     else if (capstyle.EqualsLiteral("round"))
 16154:         cap = gfxContext::LINE_CAP_ROUND;
     1:     else if (capstyle.EqualsLiteral("square"))
 16154:         cap = gfxContext::LINE_CAP_SQUARE;
     1:     else
     1:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 47330:         return NS_OK;
     1: 
 16154:     mThebes->SetLineCap(cap);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetLineCap(nsAString& capstyle)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     gfxContext::GraphicsLineCap cap = mThebes->CurrentLineCap();
 16154: 
 16154:     if (cap == gfxContext::LINE_CAP_BUTT)
     1:         capstyle.AssignLiteral("butt");
 16154:     else if (cap == gfxContext::LINE_CAP_ROUND)
     1:         capstyle.AssignLiteral("round");
 16154:     else if (cap == gfxContext::LINE_CAP_SQUARE)
     1:         capstyle.AssignLiteral("square");
     1:     else
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetLineJoin(const nsAString& joinstyle)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     gfxContext::GraphicsLineJoin j;
     1: 
     1:     if (joinstyle.EqualsLiteral("round"))
 16154:         j = gfxContext::LINE_JOIN_ROUND;
     1:     else if (joinstyle.EqualsLiteral("bevel"))
 16154:         j = gfxContext::LINE_JOIN_BEVEL;
     1:     else if (joinstyle.EqualsLiteral("miter"))
 16154:         j = gfxContext::LINE_JOIN_MITER;
     1:     else
     1:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 47330:         return NS_OK;
     1: 
 16154:     mThebes->SetLineJoin(j);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetLineJoin(nsAString& joinstyle)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     gfxContext::GraphicsLineJoin j = mThebes->CurrentLineJoin();
 16154: 
 16154:     if (j == gfxContext::LINE_JOIN_ROUND)
     1:         joinstyle.AssignLiteral("round");
 16154:     else if (j == gfxContext::LINE_JOIN_BEVEL)
     1:         joinstyle.AssignLiteral("bevel");
 16154:     else if (j == gfxContext::LINE_JOIN_MITER)
     1:         joinstyle.AssignLiteral("miter");
     1:     else
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetMiterLimit(float miter)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 61743:     if (!FloatValidate(miter) || miter <= 0.0)
 61743:         return NS_OK;
     1: 
 16154:     mThebes->SetMiterLimit(miter);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetMiterLimit(float *miter)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     gfxFloat d = mThebes->CurrentMiterLimit();
 16154:     *miter = static_cast<float>(d);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 72744: nsCanvasRenderingContext2D::SetMozDash(JSContext *cx, const jsval& patternArray)
 72744: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 72744:     AutoFallibleTArray<gfxFloat, 10> dashes;
 72744:     nsresult rv = JSValToDashArray(cx, patternArray, dashes);
 72744:     if (NS_SUCCEEDED(rv)) {
 72744:         mThebes->SetDash(dashes.Elements(), dashes.Length(),
 72744:                          mThebes->CurrentDashOffset());
 72744:     }
 72744:     return rv;
 72744: }
 72744: 
 72744: NS_IMETHODIMP
 72744: nsCanvasRenderingContext2D::GetMozDash(JSContext* cx, jsval* dashArray)
 72744: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 72744:     AutoFallibleTArray<gfxFloat, 10> dashes;
 72744:     if (!mThebes->CurrentDash(dashes, nsnull)) {
 72744:         dashes.SetLength(0);
 72744:     }
 72744:     return DashArrayToJSVal(dashes, cx, dashArray);
 72744: }
 72744: 
 72744: NS_IMETHODIMP
 72744: nsCanvasRenderingContext2D::SetMozDashOffset(float offset)
 72744: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 72744:     if (!FloatValidate(offset)) {
 72744:         return NS_ERROR_ILLEGAL_VALUE;
 72744:     }
 72744: 
 72744:     AutoFallibleTArray<gfxFloat, 10> dashes;
 72744:     if (!mThebes->CurrentDash(dashes, nsnull)) {
 72744:         // Either no dash is set or the cairo call failed.  Either
 72744:         // way, eat the error.
 72744: 
 72744:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 72744:         return NS_OK;
 72744:     }
 72744:     NS_ABORT_IF_FALSE(dashes.Length() > 0,
 72744:                       "CurrentDash() should have returned false");
 72744: 
 72744:     mThebes->SetDash(dashes.Elements(), dashes.Length(),
 72744:                      gfxFloat(offset));
 72744: 
 72744:     return NS_OK;
 72744: }
 72744: 
 72744: NS_IMETHODIMP
 72744: nsCanvasRenderingContext2D::GetMozDashOffset(float* offset)
 72744: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 72744:     *offset = float(mThebes->CurrentDashOffset());
 72744:     return NS_OK;
 72744: }
 72744: 
 72744: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2D::IsPointInPath(float x, float y, bool *retVal)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 55977:     if (!FloatValidate(x,y)) {
 80486:         *retVal = false;
 55977:         return NS_OK;
 55977:     }
     1: 
 71198:     gfxPoint pt(x, y);
 71198:     *retVal = mThebes->PointInFill(mThebes->DeviceToUser(pt));
     1:     return NS_OK;
     1: }
     1: 
     1: //
     1: // image
     1: //
     1: 
     1: // drawImage(in HTMLImageElement image, in float dx, in float dy);
     1: //   -- render image from 0,0 at dx,dy top-left coords
     1: // drawImage(in HTMLImageElement image, in float dx, in float dy, in float sw, in float sh);
     1: //   -- render image from 0,0 at dx,dy top-left coords clipping it to sw,sh
     1: // drawImage(in HTMLImageElement image, in float sx, in float sy, in float sw, in float sh, in float dx, in float dy, in float dw, in float dh);
     1: //   -- render the region defined by (sx,sy,sw,wh) in image-local space into the region (dx,dy,dw,dh) on the canvas
     1: 
     1: NS_IMETHODIMP
 34226: nsCanvasRenderingContext2D::DrawImage(nsIDOMElement *imgElt, float a1,
 34226:                                       float a2, float a3, float a4, float a5,
 34226:                                       float a6, float a7, float a8,
 34226:                                       PRUint8 optional_argc)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 83345:     nsCOMPtr<nsIContent> content = do_QueryInterface(imgElt);
 83345:     if (!content) {
 64612:         return NS_ERROR_DOM_TYPE_MISMATCH_ERR;
 64612:     }
 34226: 
 71611:     nsHTMLCanvasElement* canvas = nsHTMLCanvasElement::FromContent(content);
 71611:     if (canvas) {
 71611:         nsIntSize size = canvas->GetSize();
 71611:         if (size.width == 0 || size.height == 0) {
 71611:             return NS_ERROR_DOM_INVALID_STATE_ERR;
 71611:         }
 71611:     }
     1: 
 16154:     gfxMatrix matrix;
 16154:     nsRefPtr<gfxPattern> pattern;
 63836:     gfxIntSize imgSize;
 63836:     nsRefPtr<gfxASurface> imgsurf =
 63836:       CanvasImageCache::Lookup(imgElt, HTMLCanvasElement(), &imgSize);
 63836: 
 63836:     if (!imgsurf) {
 32424:         // The canvas spec says that drawImage should draw the first frame
 32424:         // of animated images
 32424:         PRUint32 sfeFlags = nsLayoutUtils::SFE_WANT_FIRST_FRAME;
 29572:         nsLayoutUtils::SurfaceFromElementResult res =
 83345:             nsLayoutUtils::SurfaceFromElement(content->AsElement(), sfeFlags);
 43798:         if (!res.mSurface) {
 43798:             // Spec says to silently do nothing if the element is still loading.
 43798:             return res.mIsStillLoading ? NS_OK : NS_ERROR_NOT_AVAILABLE;
 43798:         }
 29572: 
 69292:         // Force a copy if we're using drawImage with our destination
 29572:         // as a source to work around some Cairo self-copy semantics issues.
 29572:         if (res.mSurface == mSurface) {
 32424:             sfeFlags |= nsLayoutUtils::SFE_WANT_NEW_SURFACE;
 83345:             res = nsLayoutUtils::SurfaceFromElement(content->AsElement(),
 83345:                                                     sfeFlags);
 29572:             if (!res.mSurface)
 29572:                 return NS_ERROR_NOT_AVAILABLE;
 29572:         }
 29572: 
 63836:         imgsurf = res.mSurface.forget();
 63836:         imgSize = res.mSize;
 63836: 
 63836:         if (mCanvasElement) {
 63836:             CanvasUtils::DoDrawImageSecurityCheck(HTMLCanvasElement(),
 78159:                                                   res.mPrincipal,
 78159:                                                   res.mIsWriteOnly,
 78159:                                                   res.mCORSUsed);
 63836:         }
 63836: 
 63836:         if (res.mImageRequest) {
 63836:             CanvasImageCache::NotifyDrawImage(imgElt, HTMLCanvasElement(),
 63836:                                               res.mImageRequest, imgsurf, imgSize);
 63836:         }
 63836:     }
     1: 
 71611:     double sx,sy,sw,sh;
 71611:     double dx,dy,dw,dh;
 34226:     if (optional_argc == 0) {
 34226:         dx = a1;
 34226:         dy = a2;
     1:         sx = sy = 0.0;
 29572:         dw = sw = (double) imgSize.width;
 29572:         dh = sh = (double) imgSize.height;
 34226:     } else if (optional_argc == 2) {
 34226:         dx = a1;
 34226:         dy = a2;
 34226:         dw = a3;
 34226:         dh = a4;
     1:         sx = sy = 0.0;
 29572:         sw = (double) imgSize.width;
 29572:         sh = (double) imgSize.height;
 34226:     } else if (optional_argc == 6) {
 34226:         sx = a1;
 34226:         sy = a2;
 34226:         sw = a3;
 34226:         sh = a4;
 34226:         dx = a5;
 34226:         dy = a6;
 34226:         dw = a7;
 34226:         dh = a8;
     1:     } else {
     1:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 63842:         return NS_ERROR_INVALID_ARG;
     1:     }
     1: 
  6313:     if (dw == 0.0 || dh == 0.0) {
  6313:         // not really failure, but nothing to do --
  6313:         // and noone likes a divide-by-zero
 63842:         return NS_OK;
  6313:     }
  6313: 
 74273:     if (!FloatValidate(sx, sy, sw, sh) || !FloatValidate(dx, dy, dw, dh)) {
 71791:         return NS_OK;
  9673:     }
     1: 
 74273:     // check args
 74273:     if (sx < 0.0 || sy < 0.0 ||
 74273:         sw < 0.0 || sw > (double) imgSize.width ||
 74273:         sh < 0.0 || sh > (double) imgSize.height ||
 74273:         dw < 0.0 || dh < 0.0)
 74273:     {
 74273:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 63842:         return NS_ERROR_DOM_INDEX_SIZE_ERR;
     1:     }
     1: 
 16154:     matrix.Translate(gfxPoint(sx, sy));
 16154:     matrix.Scale(sw/dw, sh/dh);
 16154: 
 16154:     pattern = new gfxPattern(imgsurf);
 16154:     pattern->SetMatrix(matrix);
 70035:     pattern->SetExtend(gfxPattern::EXTEND_PAD);
 16154: 
 27042:     if (CurrentState().imageSmoothingEnabled)
 27042:         pattern->SetFilter(gfxPattern::FILTER_GOOD);
 27042:     else
 27042:         pattern->SetFilter(gfxPattern::FILTER_NEAREST);
 27042: 
 63842:     PathAutoSaveRestore pathSR(this);
 19733: 
 36900:     // Clear the surface if we need to simulate unbounded SOURCE operator
 36900:     ClearSurfaceForUnboundedSource();
 36900: 
 19733:     {
 63840:         gfxContextMatrixAutoSaveRestore autoMatrixSR(mThebes);
 63840: 
 16154:         mThebes->Translate(gfxPoint(dx, dy));
 19733: 
 19733:         gfxRect clip(0, 0, dw, dh);
 19733: 
 19733:         if (NeedToDrawShadow()) {
 19733:             gfxRect drawExtents = mThebes->UserToDevice(clip);
 19733:             gfxAlphaBoxBlur blur;
 19733: 
 19733:             gfxContext* ctx = ShadowInitialize(drawExtents, blur);
 19733: 
 19733:             if (ctx) {
 19733:                 CopyContext(ctx, mThebes);
 71667:                 ctx->SetPattern(pattern);
 19733:                 ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 19733:                 ctx->Clip(clip);
 19733:                 ctx->Paint();
 19733: 
 19733:                 ShadowFinalize(blur);
 19733:             }
 19733:         }
 19733: 
 71667:         mThebes->SetPattern(pattern);
 71667:         DirtyAllStyles();
 71667: 
 79445:         bool doUseIntermediateSurface = NeedToUseIntermediateSurface();
 54783:         if (doUseIntermediateSurface) {
 63840:             gfxContextAutoSaveRestore autoSR(mThebes);
 63840: 
 54783:             // draw onto a pushed group
 54783:             mThebes->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
 54783:             mThebes->Clip(clip);
 54783: 
 54783:             // don't want operators to be applied twice
 54783:             mThebes->SetOperator(gfxContext::OPERATOR_SOURCE);
 54783: 
 54783:             mThebes->Paint();
 54783:             mThebes->PopGroupToSource();
 54783:             mThebes->Paint(CurrentState().globalAlpha);
 54783:         } else if (CurrentState().globalAlpha == 1.0f &&
 54783:                    mThebes->CurrentOperator() == gfxContext::OPERATOR_OVER) {
 48423:             /* Direct2D isn't very good at clipping so use Fill() when we can */
 48939:             mThebes->NewPath();
 48423:             mThebes->Rectangle(clip);
 48423:             mThebes->Fill();
 48423:         } else {
 63840:             gfxContextAutoSaveRestore autoSR(mThebes);
 63840: 
 48423:             /* we need to use to clip instead of fill for globalAlpha */
 19733:             mThebes->Clip(clip);
 48423:             mThebes->Paint(CurrentState().globalAlpha);
 48423:         }
 63839: 
 63841:         RedrawUser(clip);
 19733:     }
     1: 
 63842:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::SetGlobalCompositeOperation(const nsAString& op)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     gfxContext::GraphicsOperator thebes_op;
 16154: 
 16154: #define CANVAS_OP_TO_THEBES_OP(cvsop,thebesop) \
     1:     if (op.EqualsLiteral(cvsop))   \
 16154:         thebes_op = gfxContext::OPERATOR_##thebesop;
     1: 
 71169:     CANVAS_OP_TO_THEBES_OP("copy", SOURCE)
 16154:     else CANVAS_OP_TO_THEBES_OP("destination-atop", DEST_ATOP)
 16154:     else CANVAS_OP_TO_THEBES_OP("destination-in", DEST_IN)
 16154:     else CANVAS_OP_TO_THEBES_OP("destination-out", DEST_OUT)
 16154:     else CANVAS_OP_TO_THEBES_OP("destination-over", DEST_OVER)
 16154:     else CANVAS_OP_TO_THEBES_OP("lighter", ADD)
 16154:     else CANVAS_OP_TO_THEBES_OP("source-atop", ATOP)
 16154:     else CANVAS_OP_TO_THEBES_OP("source-in", IN)
 16154:     else CANVAS_OP_TO_THEBES_OP("source-out", OUT)
 16154:     else CANVAS_OP_TO_THEBES_OP("source-over", OVER)
 16154:     else CANVAS_OP_TO_THEBES_OP("xor", XOR)
 47330:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 47330:     else return NS_OK;
     1: 
 16154: #undef CANVAS_OP_TO_THEBES_OP
 16154: 
 16154:     mThebes->SetOperator(thebes_op);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::GetGlobalCompositeOperation(nsAString& op)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 16154:     gfxContext::GraphicsOperator thebes_op = mThebes->CurrentOperator();
 16154: 
 16154: #define CANVAS_OP_TO_THEBES_OP(cvsop,thebesop) \
 16154:     if (thebes_op == gfxContext::OPERATOR_##thebesop) \
     1:         op.AssignLiteral(cvsop);
     1: 
 71169:     CANVAS_OP_TO_THEBES_OP("copy", SOURCE)
 16154:     else CANVAS_OP_TO_THEBES_OP("destination-atop", DEST_ATOP)
 16154:     else CANVAS_OP_TO_THEBES_OP("destination-in", DEST_IN)
 16154:     else CANVAS_OP_TO_THEBES_OP("destination-out", DEST_OUT)
 16154:     else CANVAS_OP_TO_THEBES_OP("destination-over", DEST_OVER)
 16154:     else CANVAS_OP_TO_THEBES_OP("lighter", ADD)
 16154:     else CANVAS_OP_TO_THEBES_OP("source-atop", ATOP)
 16154:     else CANVAS_OP_TO_THEBES_OP("source-in", IN)
 16154:     else CANVAS_OP_TO_THEBES_OP("source-out", OUT)
 16154:     else CANVAS_OP_TO_THEBES_OP("source-over", OVER)
 16154:     else CANVAS_OP_TO_THEBES_OP("xor", XOR)
     1:     else return NS_ERROR_FAILURE;
     1: 
 16154: #undef CANVAS_OP_TO_THEBES_OP
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 23407: nsCanvasRenderingContext2D::DrawWindow(nsIDOMWindow* aWindow, float aX, float aY,
 23407:                                        float aW, float aH,
 20451:                                        const nsAString& aBGColor,
 20451:                                        PRUint32 flags)
     1: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
     1:     NS_ENSURE_ARG(aWindow != nsnull);
     1: 
     1:     // protect against too-large surfaces that will cause allocation
     1:     // or overflow issues
 41037:     if (!gfxASurface::CheckSurfaceSize(gfxIntSize(PRInt32(aW), PRInt32(aH)),
 41037:                                        0xffff))
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     // We can't allow web apps to call this until we fix at least the
     1:     // following potential security issues:
     1:     // -- rendering cross-domain IFRAMEs and then extracting the results
     1:     // -- rendering the user's theme and then extracting the results
     1:     // -- rendering native anonymous content (e.g., file input paths;
     1:     // scrollbars should be allowed)
     1:     if (!nsContentUtils::IsCallerTrustedForRead()) {
     1:       // not permitted to use DrawWindow
     1:       // XXX ERRMSG we need to report an error to developers here! (bug 329026)
     1:         return NS_ERROR_DOM_SECURITY_ERR;
     1:     }
     1: 
     1:     // Flush layout updates
 38828:     if (!(flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DO_NOT_FLUSH))
 57129:         nsContentUtils::FlushLayoutForTree(aWindow);
     1: 
 39823:     nsRefPtr<nsPresContext> presContext;
     1:     nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aWindow);
     1:     if (win) {
     1:         nsIDocShell* docshell = win->GetDocShell();
     1:         if (docshell) {
     1:             docshell->GetPresContext(getter_AddRefs(presContext));
     1:         }
     1:     }
     1:     if (!presContext)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     nscolor bgColor;
 59514: 
 59514:     nsIDocument* elementDoc = mCanvasElement ?
 80526:                               HTMLCanvasElement()->OwnerDoc() : nsnull;
 59514: 
 59514:     // Pass the CSS Loader object to the parser, to allow parser error reports
 59514:     // to include the outer window ID.
 59514:     nsCSSParser parser(elementDoc ? elementDoc->CSSLoader() : nsnull);
 38849:     nsresult rv = parser.ParseColorString(PromiseFlatString(aBGColor),
 12002:                                           nsnull, 0, &bgColor);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     nsIPresShell* presShell = presContext->PresShell();
  2625:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
     1: 
     1:     nsRect r(nsPresContext::CSSPixelsToAppUnits(aX),
     1:              nsPresContext::CSSPixelsToAppUnits(aY),
     1:              nsPresContext::CSSPixelsToAppUnits(aW),
     1:              nsPresContext::CSSPixelsToAppUnits(aH));
 54079:     PRUint32 renderDocFlags = (nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING |
 54079:                                nsIPresShell::RENDER_DOCUMENT_RELATIVE);
 22950:     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_CARET) {
 22950:         renderDocFlags |= nsIPresShell::RENDER_CARET;
 22950:     }
 30503:     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_VIEW) {
 54079:         renderDocFlags &= ~(nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING |
 54079:                             nsIPresShell::RENDER_DOCUMENT_RELATIVE);
 30503:     }
 38805:     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_USE_WIDGET_LAYERS) {
 38805:         renderDocFlags |= nsIPresShell::RENDER_USE_WIDGET_LAYERS;
 38805:     }
 48224:     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_ASYNC_DECODE_IMAGES) {
 48224:         renderDocFlags |= nsIPresShell::RENDER_ASYNC_DECODE_IMAGES;
 48224:     }
 27137: 
 47739:     rv = presShell->RenderDocument(r, renderDocFlags, bgColor, mThebes);
     1: 
     1:     // get rid of the pattern surface ref, just in case
 16154:     mThebes->SetColor(gfxRGBA(1,1,1,1));
     1:     DirtyAllStyles();
     1: 
 27097:     // note that aX and aY are coordinates in the document that
 27097:     // we're drawing; aX and aY are drawn to 0,0 in current user
 27097:     // space.
 63841:     RedrawUser(gfxRect(0, 0, aW, aH));
     1: 
     1:     return rv;
     1: }
     1: 
 46498: NS_IMETHODIMP
 46498: nsCanvasRenderingContext2D::AsyncDrawXULElement(nsIDOMXULElement* aElem, float aX, float aY,
 46498:                                                 float aW, float aH,
 46498:                                                 const nsAString& aBGColor,
 46498:                                                 PRUint32 flags)
 46498: {
 77560:     if (!EnsureSurface())
 77560:         return NS_ERROR_FAILURE;
 77560: 
 46498:     NS_ENSURE_ARG(aElem != nsnull);
 46498: 
 46498:     // We can't allow web apps to call this until we fix at least the
 46498:     // following potential security issues:
 46498:     // -- rendering cross-domain IFRAMEs and then extracting the results
 46498:     // -- rendering the user's theme and then extracting the results
 46498:     // -- rendering native anonymous content (e.g., file input paths;
 46498:     // scrollbars should be allowed)
 46498:     if (!nsContentUtils::IsCallerTrustedForRead()) {
 46498:         // not permitted to use DrawWindow
 46498:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 46498:         return NS_ERROR_DOM_SECURITY_ERR;
 46498:     }
 46498: 
 46498:     nsCOMPtr<nsIFrameLoaderOwner> loaderOwner = do_QueryInterface(aElem);
 46498:     if (!loaderOwner)
 46498:         return NS_ERROR_FAILURE;
 46498: 
 60322:     nsRefPtr<nsFrameLoader> frameloader = loaderOwner->GetFrameLoader();
 46498:     if (!frameloader)
 46498:         return NS_ERROR_FAILURE;
 46498: 
 47933:     PBrowserParent *child = frameloader->GetRemoteBrowser();
 46498:     if (!child) {
 46498:         nsCOMPtr<nsIDOMWindow> window =
 46498:             do_GetInterface(frameloader->GetExistingDocShell());
 46498:         if (!window)
 46498:             return NS_ERROR_FAILURE;
 46498: 
 46498:         return DrawWindow(window, aX, aY, aW, aH, aBGColor, flags);
 46498:     }
 46498: 
 46498:     // protect against too-large surfaces that will cause allocation
 46498:     // or overflow issues
 46498:     if (!gfxASurface::CheckSurfaceSize(gfxIntSize(aW, aH), 0xffff))
 46498:         return NS_ERROR_FAILURE;
 46498: 
 79445:     bool flush =
 46498:         (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DO_NOT_FLUSH) == 0;
 46498: 
 46498:     PRUint32 renderDocFlags = nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
 46498:     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_CARET) {
 46498:         renderDocFlags |= nsIPresShell::RENDER_CARET;
 46498:     }
 46498:     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_VIEW) {
 46498:         renderDocFlags &= ~nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
 46498:     }
 46498: 
 56521:     nsRect rect(nsPresContext::CSSPixelsToAppUnits(aX),
 56521:                 nsPresContext::CSSPixelsToAppUnits(aY),
 56521:                 nsPresContext::CSSPixelsToAppUnits(aW),
 56521:                 nsPresContext::CSSPixelsToAppUnits(aH));
 46902:     if (mIPC) {
 46890:         PDocumentRendererParent *pdocrender =
 56521:             child->SendPDocumentRendererConstructor(rect,
 56522:                                                     mThebes->CurrentMatrix(),
 46756:                                                     nsString(aBGColor),
 56523:                                                     renderDocFlags, flush,
 56523:                                                     nsIntSize(mWidth, mHeight));
 46756:         if (!pdocrender)
 46756:             return NS_ERROR_FAILURE;
 46756: 
 46890:         DocumentRendererParent *docrender =
 46890:             static_cast<DocumentRendererParent *>(pdocrender);
 46498: 
 46498:         docrender->SetCanvasContext(this, mThebes);
 46756:     }
 46498: 
 46498:     return NS_OK;
 46498: }
 46498: 
     1: //
     1: // device pixel getting/setting
     1: //
 34198: 
 38331: void
 38331: nsCanvasRenderingContext2D::EnsureUnpremultiplyTable() {
 38331:   if (sUnpremultiplyTable)
 38331:     return;
 38331: 
 38331:   // Infallably alloc the unpremultiply table.
 38331:   sUnpremultiplyTable = new PRUint8[256][256];
 38331: 
 38331:   // It's important that the array be indexed first by alpha and then by rgb
 38331:   // value.  When we unpremultiply a pixel, we're guaranteed to do three
 38331:   // lookups with the same alpha; indexing by alpha first makes it likely that
 38331:   // those three lookups will be close to one another in memory, thus
 38331:   // increasing the chance of a cache hit.
 38331: 
 38331:   // a == 0 case
 38331:   for (PRUint32 c = 0; c <= 255; c++) {
 38331:     sUnpremultiplyTable[0][c] = c;
 38331:   }
 38331: 
 38331:   for (int a = 1; a <= 255; a++) {
 38331:     for (int c = 0; c <= 255; c++) {
 38331:       sUnpremultiplyTable[a][c] = (PRUint8)((c * 255) / a);
 38331:     }
 38331:   }
 38331: }
 38331: 
     1: 
     1: NS_IMETHODIMP
 93202: nsCanvasRenderingContext2D::GetImageData(double aSx, double aSy,
 93202:                                          double aSw, double aSh,
 93202:                                          JSContext* aCx,
 93202:                                          nsIDOMImageData** aRetval)
     1: {
 43655:     if (!mCanvasElement && !mDocShell) {
 43655:         NS_ERROR("No canvas element and no docshell in GetImageData!!!");
 43655:         return NS_ERROR_DOM_SECURITY_ERR;
 43655:     }
 43655: 
 43655:     // Check only if we have a canvas element; if we were created with a docshell,
 43655:     // then it's special internal use.
 43655:     if (mCanvasElement &&
 43655:         HTMLCanvasElement()->IsWriteOnly() &&
 93202:         !nsContentUtils::IsCallerTrustedForRead()) {
     1:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
     1:         return NS_ERROR_DOM_SECURITY_ERR;
     1:     }
     1: 
 93202:     if (!EnsureSurface()) {
 93202:         return NS_ERROR_FAILURE;
 93202:     }
 93202: 
 93202:     if (!NS_finite(aSx) || !NS_finite(aSy) ||
 93202:         !NS_finite(aSw) || !NS_finite(aSh)) {
 93202:         return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 93202:     }
 93202: 
 93202:     if (!aSw || !aSh) {
 93202:         return NS_ERROR_DOM_INDEX_SIZE_ERR;
 93202:     }
 93202: 
 93202:     int32_t x = JS_DoubleToInt32(aSx);
 93202:     int32_t y = JS_DoubleToInt32(aSy);
 93202:     int32_t wi = JS_DoubleToInt32(aSw);
 93202:     int32_t hi = JS_DoubleToInt32(aSh);
 93202: 
 93202:     // Handle negative width and height by flipping the rectangle over in the
 93202:     // relevant direction.
 93202:     uint32_t w, h;
 93202:     if (aSw < 0) {
 93202:         w = -wi;
 93202:         x -= w;
 93202:     } else {
 93202:         w = wi;
 93202:     }
 93202:     if (aSh < 0) {
 93202:         h = -hi;
 93202:         y -= h;
 93202:     } else {
 93202:         h = hi;
 93202:     }
 93202: 
 93202:     if (w == 0) {
 93202:         w = 1;
 93202:     }
 93202:     if (h == 0) {
 93202:         h = 1;
 93202:     }
 93202: 
 93202:     JSObject* array;
 93202:     nsresult rv = GetImageDataArray(aCx, x, y, w, h, &array);
 93202:     NS_ENSURE_SUCCESS(rv, rv);
 93202:     MOZ_ASSERT(array);
 93202: 
 93202:     nsRefPtr<ImageData> imageData = new ImageData(w, h, *array);
 93202:     imageData.forget(aRetval);
 93202:     return NS_OK;
 93202: }
 93202: 
 93202: nsresult
 93202: nsCanvasRenderingContext2D::GetImageDataArray(JSContext* aCx,
 93202:                                               int32_t aX,
 93202:                                               int32_t aY,
 93202:                                               uint32_t aWidth,
 93202:                                               uint32_t aHeight,
 93202:                                               JSObject** aRetval)
 93202: {
 93202:     MOZ_ASSERT(aWidth && aHeight);
 93202: 
 93202:     CheckedInt<uint32_t> len = CheckedInt<uint32_t>(aWidth) * aHeight * 4;
 98543:     if (!len.isValid()) {
 93202:         return NS_ERROR_DOM_INDEX_SIZE_ERR;
 93202:     }
 93202: 
 93202:     CheckedInt<int32_t> rightMost = CheckedInt<int32_t>(aX) + aWidth;
 93202:     CheckedInt<int32_t> bottomMost = CheckedInt<int32_t>(aY) + aHeight;
 93202: 
 98543:     if (!rightMost.isValid() || !bottomMost.isValid()) {
 51419:         return NS_ERROR_DOM_SYNTAX_ERR;
 93202:     }
 93202: 
 95834:     JSObject* darray = JS_NewUint8ClampedArray(aCx, len.value());
 93202:     if (!darray) {
 93202:         return NS_ERROR_OUT_OF_MEMORY;
 93202:     }
 93202: 
 95834:     uint8_t* data = JS_GetUint8ClampedArrayData(darray, aCx);
     1: 
 38927:     /* Copy the surface contents to the buffer */
 67641:     nsRefPtr<gfxImageSurface> tmpsurf =
 93202:         new gfxImageSurface(data,
 93202:                             gfxIntSize(aWidth, aHeight),
 93202:                             aWidth * 4,
 16154:                             gfxASurface::ImageFormatARGB32);
 67641: 
 67641:     if (tmpsurf->CairoStatus())
 16154:         return NS_ERROR_FAILURE;
 16154: 
 16154:     nsRefPtr<gfxContext> tmpctx = new gfxContext(tmpsurf);
 16154: 
 67641:     if (tmpctx->HasError())
 16154:         return NS_ERROR_FAILURE;
 16154: 
 70071:     if (!mZero) {
 67641:         gfxRect srcRect(0, 0, mWidth, mHeight);
 93202:         gfxRect destRect(aX, aY, aWidth, aHeight);
 67641: 
 67641:         bool finishedPainting = false;
 67641:         // In the common case, we want to avoid the Rectangle call.
 67641:         if (!srcRect.Contains(destRect)) {
 67641:             // If the requested area is entirely outside the canvas, we're done.
 67641:             gfxRect tmp = srcRect.Intersect(destRect);
 67641:             finishedPainting = tmp.IsEmpty();
 67641: 
 67641:             // Set clipping region if necessary.
 67641:             if (!finishedPainting) {
 67641:                 tmpctx->Rectangle(tmp);
 67641:             }
 67641:         }
 67641: 
 67641:         if (!finishedPainting) {
 16154:             tmpctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 93202:             tmpctx->SetSource(mSurface, gfxPoint(-aX, -aY));
 16154:             tmpctx->Paint();
 67641:         }
 70071:     }
 16154: 
 38927:     // make sure sUnpremultiplyTable has been created
 38331:     EnsureUnpremultiplyTable();
 38331: 
 38927:     // NOTE! dst is the same as src, and this relies on reading
 38927:     // from src and advancing that ptr before writing to dst.
 93202:     uint8_t *src = data;
 93202:     uint8_t *dst = data;
 93202: 
 93202:     for (uint32_t j = 0; j < aHeight; ++j) {
 93202:         for (uint32_t i = 0; i < aWidth; ++i) {
 38927:             // XXX Is there some useful swizzle MMX we can use here?
     1: #ifdef IS_LITTLE_ENDIAN
 38927:             PRUint8 b = *src++;
 38927:             PRUint8 g = *src++;
 38927:             PRUint8 r = *src++;
 38927:             PRUint8 a = *src++;
     1: #else
 38927:             PRUint8 a = *src++;
 38927:             PRUint8 r = *src++;
 38927:             PRUint8 g = *src++;
 38927:             PRUint8 b = *src++;
     1: #endif
  7213:             // Convert to non-premultiplied color
 38927:             *dst++ = sUnpremultiplyTable[a][r];
 38927:             *dst++ = sUnpremultiplyTable[a][g];
 38927:             *dst++ = sUnpremultiplyTable[a][b];
 38927:             *dst++ = a;
     1:         }
     1:     }
     1: 
 93202:     *aRetval = darray;
     1:     return NS_OK;
     1: }
     1: 
 38331: void
 38331: nsCanvasRenderingContext2D::EnsurePremultiplyTable() {
 38331:   if (sPremultiplyTable)
 38331:     return;
 38331: 
 38331:   // Infallably alloc the premultiply table.
 38331:   sPremultiplyTable = new PRUint8[256][256];
 38331: 
 38331:   // Like the unpremultiply table, it's important that we index the premultiply
 38331:   // table with the alpha value as the first index to ensure good cache
 38331:   // performance.
 38331: 
 38331:   for (int a = 0; a <= 255; a++) {
 38331:     for (int c = 0; c <= 255; c++) {
 38331:       sPremultiplyTable[a][c] = (a * c + 254) / 255;
 38331:     }
 38331:   }
 38331: }
 38331: 
     1: // void putImageData (in ImageData d, in float x, in float y);
     1: NS_IMETHODIMP
     1: nsCanvasRenderingContext2D::PutImageData()
     1: {
 38927:     /* Should never be called -- PutImageData_explicit is the QS entry point */
 38927:     return NS_ERROR_NOT_IMPLEMENTED;
 38927: }
 38927: 
 38927: NS_IMETHODIMP
 38927: nsCanvasRenderingContext2D::PutImageData_explicit(PRInt32 x, PRInt32 y, PRUint32 w, PRUint32 h,
 58610:                                                   unsigned char *aData, PRUint32 aDataLen,
 79445:                                                   bool hasDirtyRect, PRInt32 dirtyX, PRInt32 dirtyY,
 58610:                                                   PRInt32 dirtyWidth, PRInt32 dirtyHeight)
 38927: {
 77560:     if (!EnsureSurface())
 11707:         return NS_ERROR_FAILURE;
 11707: 
 51419:     if (w == 0 || h == 0)
 51419:         return NS_ERROR_DOM_SYNTAX_ERR;
 51419: 
 58610:     gfxRect dirtyRect;
 58610:     gfxRect imageDataRect(0, 0, w, h);
 58610: 
 58610:     if (hasDirtyRect) {
 58610:         // fix up negative dimensions
 58610:         if (dirtyWidth < 0) {
 58610:             NS_ENSURE_TRUE(dirtyWidth != INT_MIN, NS_ERROR_DOM_INDEX_SIZE_ERR);
 58610: 
 58610:             CheckedInt32 checkedDirtyX = CheckedInt32(dirtyX) + dirtyWidth;
 58610: 
 98543:             if (!checkedDirtyX.isValid())
 58610:                 return NS_ERROR_DOM_INDEX_SIZE_ERR;
 58610: 
 58610:             dirtyX = checkedDirtyX.value();
 58610:             dirtyWidth = -(int32)dirtyWidth;
 58610:         }
 58610: 
 58610:         if (dirtyHeight < 0) {
 58610:             NS_ENSURE_TRUE(dirtyHeight != INT_MIN, NS_ERROR_DOM_INDEX_SIZE_ERR);
 58610: 
 58610:             CheckedInt32 checkedDirtyY = CheckedInt32(dirtyY) + dirtyHeight;
 58610: 
 98543:             if (!checkedDirtyY.isValid())
 58610:                 return NS_ERROR_DOM_INDEX_SIZE_ERR;
 58610: 
 58610:             dirtyY = checkedDirtyY.value();
 58610:             dirtyHeight = -(int32)dirtyHeight;
 58610:         }
 58610: 
 58610:         // bound the dirty rect within the imageData rectangle
 58610:         dirtyRect = imageDataRect.Intersect(gfxRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight));
 58610: 
 58610:         if (dirtyRect.Width() <= 0 || dirtyRect.Height() <= 0)
 58610:             return NS_OK;
 58610:     } else {
 58610:         dirtyRect = imageDataRect;
 58610:     }
 58610: 
 58610:     dirtyRect.MoveBy(gfxPoint(x, y));
 58610:     dirtyRect = gfxRect(0, 0, mWidth, mHeight).Intersect(dirtyRect);
 58610: 
 58610:     if (dirtyRect.Width() <= 0 || dirtyRect.Height() <= 0)
 58610:         return NS_OK;
     1: 
 38927:     PRUint32 len = w * h * 4;
 38927:     if (aDataLen != len)
     1:         return NS_ERROR_DOM_SYNTAX_ERR;
     1: 
 38927:     nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(gfxIntSize(w, h),
 16154:                                                             gfxASurface::ImageFormatARGB32);
 16154:     if (!imgsurf || imgsurf->CairoStatus())
 16154:         return NS_ERROR_FAILURE;
 16154: 
 38927:     // ensure premultiply table has been created
 38927:     EnsurePremultiplyTable();
 38927: 
 38927:     PRUint8 *src = aData;
 38927:     PRUint8 *dst = imgsurf->Data();
 38927: 
 39338:     for (PRUint32 j = 0; j < h; j++) {
 39338:         for (PRUint32 i = 0; i < w; i++) {
 38927:             PRUint8 r = *src++;
 38927:             PRUint8 g = *src++;
 38927:             PRUint8 b = *src++;
 38927:             PRUint8 a = *src++;
 38927: 
 38927:             // Convert to premultiplied color (losslessly if the input came from getImageData)
 38927: #ifdef IS_LITTLE_ENDIAN
 38927:             *dst++ = sPremultiplyTable[a][b];
 38927:             *dst++ = sPremultiplyTable[a][g];
 38927:             *dst++ = sPremultiplyTable[a][r];
 38927:             *dst++ = a;
 38927: #else
 38927:             *dst++ = a;
 38927:             *dst++ = sPremultiplyTable[a][r];
 38927:             *dst++ = sPremultiplyTable[a][g];
 38927:             *dst++ = sPremultiplyTable[a][b];
 38927: #endif
 38927:         }
 38927:     }
 38927: 
 63842:     PathAutoSaveRestore pathSR(this);
 19733:     gfxContextAutoSaveRestore autoSR(mThebes);
 19733: 
 29493:     // ignore clipping region, as per spec
 29493:     mThebes->ResetClip();
 29493: 
 16154:     mThebes->IdentityMatrix();
 16154:     mThebes->NewPath();
 58610:     mThebes->Rectangle(dirtyRect);
 58610:     mThebes->SetSource(imgsurf, gfxPoint(x, y));
 16154:     mThebes->SetOperator(gfxContext::OPERATOR_SOURCE);
 16154:     mThebes->Fill();
     1: 
 58610:     return Redraw(dirtyRect);
     1: }
 14812: 
 14812: NS_IMETHODIMP
 14812: nsCanvasRenderingContext2D::GetThebesSurface(gfxASurface **surface)
 14812: {
 77560:     if (!EnsureSurface()) {
 14812:         *surface = nsnull;
 14812:         return NS_ERROR_NOT_AVAILABLE;
 14812:     }
 14812: 
 16154:     *surface = mSurface.get();
 14812:     NS_ADDREF(*surface);
 14812: 
 14812:     return NS_OK;
 14812: }
 14812: 
 18589: NS_IMETHODIMP
 18589: nsCanvasRenderingContext2D::CreateImageData()
 18589: {
 38927:     /* Should never be called; handled entirely in the quickstub */
 38927:     return NS_ERROR_NOT_IMPLEMENTED;
 18589: }
 18589: 
 27042: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2D::GetMozImageSmoothingEnabled(bool *retVal)
 27042: {
 27042:     *retVal = CurrentState().imageSmoothingEnabled;
 27042:     return NS_OK;
 27042: }
 27042: 
 27042: NS_IMETHODIMP
 79445: nsCanvasRenderingContext2D::SetMozImageSmoothingEnabled(bool val)
 27042: {
 27042:     if (val != CurrentState().imageSmoothingEnabled) {
 27042:         CurrentState().imageSmoothingEnabled = val;
 27042:         DirtyAllStyles();
 27042:     }
 27042: 
 27042:     return NS_OK;
 27042: }
 42402: 
 47731: static PRUint8 g2DContextLayerUserData;
 47731: 
 42402: already_AddRefed<CanvasLayer>
 64542: nsCanvasRenderingContext2D::GetCanvasLayer(nsDisplayListBuilder* aBuilder,
 64542:                                            CanvasLayer *aOldLayer,
 47731:                                            LayerManager *aManager)
 42402: {
100958:     // If we don't have anything to draw, don't bother.
100958:     if (!mValid || !mSurface || mSurface->CairoStatus() || !mThebes ||
100958:         !mSurfaceCreated) {
 42402:          return nsnull;
100958:     }
 42402: 
100504:     if (!mResetLayer && aOldLayer) {
100504:         CanvasRenderingContext2DUserData* userData =
100504:             static_cast<CanvasRenderingContext2DUserData*>(
100504:                     aOldLayer->GetUserData(&g2DContextLayerUserData));
100504:         if (userData && userData->IsForContext(this)) {
 47731:             NS_ADDREF(aOldLayer);
 47731:             return aOldLayer;
 47731:         }
100504:     }
 47731: 
 47731:     nsRefPtr<CanvasLayer> canvasLayer = aManager->CreateCanvasLayer();
 42402:     if (!canvasLayer) {
 42402:         NS_WARNING("CreateCanvasLayer returned null!");
 42402:         return nsnull;
 42402:     }
 64542:     CanvasRenderingContext2DUserData *userData = nsnull;
 64542:     if (aBuilder->IsPaintingToWindow()) {
 64542:       // Make the layer tell us whenever a transaction finishes (including
 64542:       // the current transaction), so we can clear our invalidation state and
 64542:       // start invalidating again. We need to do this for the layer that is
 64542:       // being painted to a window (there shouldn't be more than one at a time,
 64542:       // and if there is, flushing the invalidation state more often than
 64542:       // necessary is harmless).
 64542: 
 64542:       // The layer will be destroyed when we tear down the presentation
 64542:       // (at the latest), at which time this userData will be destroyed,
 64542:       // releasing the reference to the element.
 64542:       // The userData will receive DidTransactionCallbacks, which flush the
 64542:       // the invalidation state to indicate that the canvas is up to date.
100504:       userData = new CanvasRenderingContext2DUserData(this);
 64542:       canvasLayer->SetDidTransactionCallback(
 64542:               CanvasRenderingContext2DUserData::DidTransactionCallback, userData);
 64542:     }
 64542:     canvasLayer->SetUserData(&g2DContextLayerUserData, userData);
 42402: 
 42402:     CanvasLayer::Data data;
 42402: 
 42402:     data.mSurface = mSurface.get();
 42402:     data.mSize = nsIntSize(mWidth, mHeight);
 42402: 
 42402:     canvasLayer->Initialize(data);
 51950:     PRUint32 flags = mOpaque ? Layer::CONTENT_OPAQUE : 0;
 51950:     canvasLayer->SetContentFlags(flags);
 64540:     canvasLayer->Updated();
 42402: 
 80486:     mResetLayer = false;
 60330: 
 64542:     return canvasLayer.forget();
 42402: }
 42402: 
 79445: bool
 73612: nsCanvasRenderingContext2D::ShouldForceInactiveLayer(LayerManager *aManager)
 73612: {
 73612:     return !aManager->CanUseCanvasLayerForSize(gfxIntSize(mWidth, mHeight));
 73612: }
 73612: 
 42402: void
 42402: nsCanvasRenderingContext2D::MarkContextClean()
 42402: {
 63841:     if (mInvalidateCount > 0) {
 63841:         mPredictManyRedrawCalls = mInvalidateCount > kCanvasMaxInvalidateCount;
 63841:     }
 80486:     mIsEntireFrameInvalid = false;
 60330:     mInvalidateCount = 0;
 60330: }
 60330: 
