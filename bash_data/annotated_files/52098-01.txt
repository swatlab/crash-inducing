    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Andrei Volkov <av@netscape.com>
    1:  *   Brian Stell <bstell@netscape.com>
    1:  *   Peter Lubczynski <peterl@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "windows.h"
    1: #include "windowsx.h"
    1: 
    1: // XXXbz windowsx.h defines GetFirstChild, GetNextSibling,
    1: // GetPrevSibling are macros, apparently... Eeevil.  We have functions
    1: // called that on some classes, so undef them.
    1: #undef GetFirstChild
    1: #undef GetNextSibling
    1: #undef GetPrevSibling
    1: 
    1: #include "nsDebug.h"
    1: 
    1: #include "nsGUIEvent.h"
    1: 
    1: #include "nsPluginSafety.h"
    1: #include "nsPluginNativeWindow.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsTWeakRef.h"
    1: 
32799: #define NP_POPUP_API_VERSION 16
32799: 
32799: #define nsMajorVersion(v)       (((PRInt32)(v) >> 16) & 0xffff)
32799: #define nsMinorVersion(v)       ((PRInt32)(v) & 0xffff)
32799: #define versionOK(suppliedV, requiredV)                   \
32799:   (nsMajorVersion(suppliedV) == nsMajorVersion(requiredV) \
32799:    && nsMinorVersion(suppliedV) >= nsMinorVersion(requiredV))
32799: 
32799: 
25861: #define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION TEXT("MozillaPluginWindowPropertyAssociation")
29473: #define NS_PLUGIN_CUSTOM_MSG_ID TEXT("MozFlashUserRelay")
29473: #define WM_USER_FLASH WM_USER+1
29473: static UINT sWM_FLASHBOUNCEMSG = 0;
    1: 
    1: typedef nsTWeakRef<class nsPluginNativeWindowWin> PluginWindowWeakRef;
    1: 
    1: /**
    1:  *  PLEvent handling code
    1:  */
    1: class PluginWindowEvent : public nsRunnable {
    1: public:
    1:   PluginWindowEvent();
    1:   void Init(const PluginWindowWeakRef &ref, HWND hWnd, UINT msg, WPARAM wParam,
    1:             LPARAM lParam);
    1:   void Clear();
    1:   HWND   GetWnd()    { return mWnd; };
    1:   UINT   GetMsg()    { return mMsg; };
    1:   WPARAM GetWParam() { return mWParam; };
    1:   LPARAM GetLParam() { return mLParam; };
 2437:   PRBool InUse()     { return (mWnd!=NULL); };
    1: 
    1:   NS_DECL_NSIRUNNABLE
    1: 
    1: protected:
    1:   PluginWindowWeakRef mPluginWindowRef;
    1:   HWND   mWnd;
    1:   UINT   mMsg;
    1:   WPARAM mWParam;
    1:   LPARAM mLParam;
    1: };
    1: 
    1: PluginWindowEvent::PluginWindowEvent()
    1: {
    1:   Clear();
    1: }
    1: 
    1: void PluginWindowEvent::Clear()
    1: {
    1:   mWnd    = NULL;
    1:   mMsg    = 0;
    1:   mWParam = 0;
    1:   mLParam = 0;
    1: }
    1: 
    1: void PluginWindowEvent::Init(const PluginWindowWeakRef &ref, HWND aWnd,
    1:                              UINT aMsg, WPARAM aWParam, LPARAM aLParam)
    1: {
 2437:   NS_ASSERTION(aWnd != NULL, "invalid plugin event value");
 2437:   NS_ASSERTION(mWnd == NULL, "event already in use");
    1:   mPluginWindowRef = ref;
    1:   mWnd    = aWnd;
    1:   mMsg    = aMsg;
    1:   mWParam = aWParam;
    1:   mLParam = aLParam;
    1: }
    1: 
    1: /**
    1:  *  nsPluginNativeWindow Windows specific class declaration
    1:  */
    1: 
    1: typedef enum {
    1:   nsPluginType_Unknown = 0,
    1:   nsPluginType_Flash,
    1:   nsPluginType_Real,
52098:   nsPluginType_PDF,
    1:   nsPluginType_Other
    1: } nsPluginType;
    1: 
    1: class nsPluginNativeWindowWin : public nsPluginNativeWindow {
    1: public: 
    1:   nsPluginNativeWindowWin();
    1:   virtual ~nsPluginNativeWindowWin();
    1: 
    1:   virtual nsresult CallSetWindow(nsCOMPtr<nsIPluginInstance> &aPluginInstance);
    1: 
    1: private:
    1: #ifndef WINCE
    1:   nsresult SubclassAndAssociateWindow();
    1:   nsresult UndoSubclassAndAssociateWindow();
    1: #endif
    1: 
    1: public:
    1:   // locals
    1:   WNDPROC GetPrevWindowProc();
    1:   WNDPROC GetWindowProc();
 2437:   PluginWindowEvent * GetPluginWindowEvent(HWND aWnd,
 2437:                                            UINT aMsg,
 2206:                                            WPARAM aWParam,
 2206:                                            LPARAM aLParam);
    1: 
    1: private:
    1:   WNDPROC mPrevWinProc;
    1:   WNDPROC mPluginWinProc;
    1:   PluginWindowWeakRef mWeakRef;
    1:   nsRefPtr<PluginWindowEvent> mCachedPluginWindowEvent;
    1: 
52098:   HWND mParentWnd;
52098:   LONG_PTR mParentProc;
    1: public:
    1:   nsPluginType mPluginType;
    1: };
    1: 
    1: static PRBool sInMessageDispatch = PR_FALSE;
    1: static UINT sLastMsg = 0;
    1: 
29473: static PRBool ProcessFlashMessageDelayed(nsPluginNativeWindowWin * aWin, nsIPluginInstance * aInst,
    1:                                          HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
    1: {
    1:   NS_ENSURE_TRUE(aWin, NS_ERROR_NULL_POINTER);
29473:   NS_ENSURE_TRUE(aInst, NS_ERROR_NULL_POINTER);
    1: 
29473:   if (msg == sWM_FLASHBOUNCEMSG) {
29473:     // See PluginWindowEvent::Run() below.
29473:     NS_ASSERTION((sWM_FLASHBOUNCEMSG != 0), "RegisterWindowMessage failed in flash plugin WM_USER message handling!");
29473:     NS_TRY_SAFE_CALL_VOID(::CallWindowProc((WNDPROC)aWin->GetWindowProc(), hWnd, WM_USER_FLASH, wParam, lParam),
29473:                                            nsnull, aInst);
29473:     return TRUE;
29473:   }
29473: 
29473:   if (msg != WM_USER_FLASH)
    1:     return PR_FALSE; // no need to delay
    1: 
    1:   // do stuff
    1:   nsCOMPtr<nsIRunnable> pwe = aWin->GetPluginWindowEvent(hWnd, msg, wParam, lParam);
    1:   if (pwe) {
    1:     NS_DispatchToCurrentThread(pwe);
    1:     return PR_TRUE;  
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: class nsDelayedPopupsEnabledEvent : public nsRunnable
    1: {
    1: public:
29953:   nsDelayedPopupsEnabledEvent(nsIPluginInstance *inst)
    1:     : mInst(inst)
    1:   {}
    1: 
    1:   NS_DECL_NSIRUNNABLE
    1: 
    1: private:
29953:   nsCOMPtr<nsIPluginInstance> mInst;
    1: };
    1: 
    1: NS_IMETHODIMP nsDelayedPopupsEnabledEvent::Run()
    1: {
    1:   mInst->PushPopupsEnabledState(PR_FALSE);
    1:   return NS_OK;	
    1: }
    1: 
    1: /**
    1:  *   New plugin window procedure
    1:  */
    1: static LRESULT CALLBACK PluginWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
    1: {
12902:   nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
    1:   if (!win)
    1:     return TRUE;
    1: 
   56:   // The DispatchEvent(NS_PLUGIN_ACTIVATE) below can trigger a reentrant focus
   56:   // event which might destroy us.  Hold a strong ref on the plugin instance
   56:   // to prevent that, bug 374229.
   56:   nsCOMPtr<nsIPluginInstance> inst;
   56:   win->GetPluginInstance(inst);
   56: 
    1:   // Real may go into a state where it recursivly dispatches the same event
    1:   // when subclassed. If this is Real, lets examine the event and drop it
    1:   // on the floor if we get into this recursive situation. See bug 192914.
    1:   if (win->mPluginType == nsPluginType_Real) {
    1:     
    1:     if (sInMessageDispatch && (msg == sLastMsg)) {
    1: #ifdef DEBUG
    1:       printf("Dropping event %d for Real on the floor\n", msg);
    1: #endif
    1:       return PR_TRUE;  // prevents event dispatch
    1:     } else {
    1:       sLastMsg = msg;  // no need to prevent dispatch
    1:     }
    1:   }
    1: 
    1:   PRBool enablePopups = PR_FALSE;
    1: 
    1:   // Activate/deactivate mouse capture on the plugin widget
    1:   // here, before we pass the Windows event to the plugin
    1:   // because its possible our widget won't get paired events
    1:   // (see bug 131007) and we'll look frozen. Note that this
    1:   // is also done in ChildWindow::DispatchMouseEvent.
    1:   switch (msg) {
    1:     case WM_LBUTTONDOWN:
    1:     case WM_MBUTTONDOWN:
    1:     case WM_RBUTTONDOWN: {
    1:       nsCOMPtr<nsIWidget> widget;
    1:       win->GetPluginWidget(getter_AddRefs(widget));
    1:       if (widget)
    1:         widget->CaptureMouse(PR_TRUE);
    1:       break;
    1:     }
    1:     case WM_LBUTTONUP:
    1:       enablePopups = PR_TRUE;
    1: 
    1:       // fall through
    1:     case WM_MBUTTONUP:
    1:     case WM_RBUTTONUP: {
    1:       nsCOMPtr<nsIWidget> widget;
    1:       win->GetPluginWidget(getter_AddRefs(widget));
    1:       if (widget)
    1:         widget->CaptureMouse(PR_FALSE);
    1:       break;
    1:     }
    1:     case WM_KEYDOWN:
    1:       // Ignore repeating keydown messages...
    1:       if ((lParam & 0x40000000) != 0) {
    1:         break;
    1:       }
    1: 
    1:       // fall through
    1:     case WM_KEYUP:
    1:       enablePopups = PR_TRUE;
    1: 
    1:       break;
    1: 
    1: #ifndef WINCE
    1:     case WM_MOUSEACTIVATE: {
    1:       // If a child window of this plug-in is already focused,
37550:       // don't focus the parent to avoid focus dance. We'll 
37550:       // receive a follow up WM_SETFOCUS which will notify
37550:       // the appropriate window anyway.
    1:       HWND focusedWnd = ::GetFocus();
    1:       if (!::IsChild((HWND)win->window, focusedWnd)) {
37550:         // Notify the dom / focus manager the plugin has focus when one of
37550:         // it's child windows receives it. OOPP specific - this code is
37550:         // critical in notifying the dom of focus changes when the plugin
37550:         // window in the child process receives focus via a mouse click.
37550:         // WM_MOUSEACTIVATE is sent by nsWindow via a custom window event
37550:         // sent from PluginInstanceParent in response to focus events sent
37550:         // from the child. (bug 540052) Note, this gui event could also be
37550:         // sent directly from widget.
    1:         nsCOMPtr<nsIWidget> widget;
    1:         win->GetPluginWidget(getter_AddRefs(widget));
    1:         if (widget) {
29018:           nsGUIEvent event(PR_TRUE, NS_PLUGIN_ACTIVATE, widget);
    1:           nsEventStatus status;
    1:           widget->DispatchEvent(&event, status);
    1:         }
    1:       }
    1:     }
    1:     break;
    1: 
    1:     case WM_SETFOCUS:
    1:     case WM_KILLFOCUS: {
12327:       // RealPlayer can crash, don't process the message for those, see bug 328675
12327:       if (win->mPluginType == nsPluginType_Real && msg == sLastMsg)
12327:         return TRUE;
    1:       // Make sure setfocus and killfocus get through
    1:       // even if they are eaten by the plugin
    1:       WNDPROC prevWndProc = win->GetPrevWindowProc();
    1:       if (prevWndProc)
    1:         ::CallWindowProc(prevWndProc, hWnd, msg, wParam, lParam);
    1:       break;
    1:     }
    1: #endif
    1:   }
    1: 
    1:   // Macromedia Flash plugin may flood the message queue with some special messages
    1:   // (WM_USER+1) causing 100% CPU consumption and GUI freeze, see mozilla bug 132759;
    1:   // we can prevent this from happening by delaying the processing such messages;
    1:   if (win->mPluginType == nsPluginType_Flash) {
29473:     if (ProcessFlashMessageDelayed(win, inst, hWnd, msg, wParam, lParam))
    1:       return TRUE;
    1:   }
    1: 
29953:   if (enablePopups && inst) {
29953:     PRUint16 apiVersion;
29953:     if (NS_SUCCEEDED(inst->GetPluginAPIVersion(&apiVersion)) &&
32799:         !versionOK(apiVersion, NP_POPUP_API_VERSION)) {
29953:       inst->PushPopupsEnabledState(PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   sInMessageDispatch = PR_TRUE;
    1: 
29953:   LRESULT res = TRUE;
    1:   NS_TRY_SAFE_CALL_RETURN(res, 
    1:                           ::CallWindowProc((WNDPROC)win->GetWindowProc(), hWnd, msg, wParam, lParam),
    1:                           nsnull, inst);
    1: 
    1:   sInMessageDispatch = PR_FALSE;
    1: 
29953:   if (inst) {
    1:     // Popups are enabled (were enabled before the call to
    1:     // CallWindowProc()). Some plugins (at least the flash player)
    1:     // post messages from their key handlers etc that delay the actual
    1:     // processing, so we need to delay the disabling of popups so that
    1:     // popups remain enabled when the flash player ends up processing
    1:     // the actual key handlers. We do this by posting an event that
    1:     // does the disabling, this way our disabling will happen after
    1:     // the handlers in the plugin are done.
    1: 
    1:     // Note that it's not fatal if any of this fails (which won't
    1:     // happen unless we're out of memory anyways) since the plugin
    1:     // code will pop any popup state pushed by this plugin on
    1:     // destruction.
    1: 
29953:     nsCOMPtr<nsIRunnable> event = new nsDelayedPopupsEnabledEvent(inst);
29953:     if (event)
    1:       NS_DispatchToCurrentThread(event);
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: /**
    1:  *   nsPluginNativeWindowWin implementation
    1:  */
    1: nsPluginNativeWindowWin::nsPluginNativeWindowWin() : nsPluginNativeWindow()
    1: {
    1:   // initialize the struct fields
    1:   window = nsnull; 
    1:   x = 0; 
    1:   y = 0; 
    1:   width = 0; 
    1:   height = 0; 
    1: 
    1:   mPrevWinProc = NULL;
    1:   mPluginWinProc = NULL;
    1:   mPluginType = nsPluginType_Unknown;
29473: 
52098:   mParentWnd = NULL;
52098:   mParentProc = NULL;
52098: 
29473:   if (sWM_FLASHBOUNCEMSG == 0)
29473:     sWM_FLASHBOUNCEMSG = ::RegisterWindowMessage(NS_PLUGIN_CUSTOM_MSG_ID);
29473: 
    1: }
    1: 
    1: nsPluginNativeWindowWin::~nsPluginNativeWindowWin()
    1: {
    1:   // clear weak reference to self to prevent any pending events from
    1:   // dereferencing this.
    1:   mWeakRef.forget();
    1: }
    1: 
    1: WNDPROC nsPluginNativeWindowWin::GetPrevWindowProc()
    1: {
    1:   return mPrevWinProc;
    1: }
    1: 
    1: WNDPROC nsPluginNativeWindowWin::GetWindowProc()
    1: {
    1:   return mPluginWinProc;
    1: }
    1: 
    1: NS_IMETHODIMP PluginWindowEvent::Run()
    1: {
    1:   nsPluginNativeWindowWin *win = mPluginWindowRef.get();
    1:   if (!win)
    1:     return NS_OK;
    1: 
    1:   HWND hWnd = GetWnd();
    1:   if (!hWnd)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPluginInstance> inst;
    1:   win->GetPluginInstance(inst);
29473: 
29473:   if (GetMsg() == WM_USER_FLASH) {
29473:     // XXX Unwind issues related to runnable event callback depth for this
29473:     // event and destruction of the plugin. (Bug 493601)
29473:     ::PostMessage(hWnd, sWM_FLASHBOUNCEMSG, GetWParam(), GetLParam());
29473:   }
29473:   else {
29473:     // Currently not used, but added so that processing events here
29473:     // is more generic.
    1:     NS_TRY_SAFE_CALL_VOID(::CallWindowProc(win->GetWindowProc(), 
    1:                           hWnd, 
    1:                           GetMsg(), 
    1:                           GetWParam(), 
    1:                           GetLParam()),
    1:                           nsnull, inst);
29473:   }
29473: 
    1:   Clear();
    1:   return NS_OK;
    1: }
    1: 
 2437: PluginWindowEvent * 
    1: nsPluginNativeWindowWin::GetPluginWindowEvent(HWND aWnd, UINT aMsg, WPARAM aWParam, LPARAM aLParam)
    1: {
    1:   if (!mWeakRef) {
    1:     mWeakRef = this;
    1:     if (!mWeakRef)
    1:       return nsnull;
    1:   }
    1: 
    1:   PluginWindowEvent *event;
 2437: 
    1:   // We have the ability to alloc if needed in case in the future some plugin
    1:   // should post multiple PostMessages. However, this could lead to many
 2437:   // alloc's per second which could become a performance issue. See bug 169247.
 2437:   if (!mCachedPluginWindowEvent) 
 2437:   {
    1:     event = new PluginWindowEvent();
 2437:     if (!event) return nsnull;
 2437:     mCachedPluginWindowEvent = event;
    1:   }
 2437:   else if (mCachedPluginWindowEvent->InUse())
 2437:   {
 2437:     event = new PluginWindowEvent();
 2437:     if (!event) return nsnull;
 2437:   }
 2437:   else
 2437:   {
    1:     event = mCachedPluginWindowEvent;
    1:   }
    1: 
    1:   event->Init(mWeakRef, aWnd, aMsg, aWParam, aLParam);
    1:   return event;
    1: }
    1: 
    1: nsresult nsPluginNativeWindowWin::CallSetWindow(nsCOMPtr<nsIPluginInstance> &aPluginInstance)
    1: {
    1:   // check the incoming instance, null indicates that window is going away and we are
    1:   // not interested in subclassing business any more, undo and don't subclass
    1: 
52098:   // check plugin mime type and cache it if it will need special treatment later
52098:   if (mPluginType == nsPluginType_Unknown) {
52098:     if (aPluginInstance) {
52098:       const char* mimetype = nsnull;
52098:       aPluginInstance->GetMIMEType(&mimetype);
52098:       if (mimetype) { 
52098:         if (!strcmp(mimetype, "application/x-shockwave-flash"))
52098:           mPluginType = nsPluginType_Flash;
52098:         else if (!strcmp(mimetype, "audio/x-pn-realaudio-plugin"))
52098:           mPluginType = nsPluginType_Real;
52098:         else if (!strcmp(mimetype, "application/pdf"))
52098:           mPluginType = nsPluginType_PDF;
52098:         else
52098:           mPluginType = nsPluginType_Other;
52098:       }
52098:     }
52098:   }
52098: 
    1:   // WINCE does not subclass windows.  See bug 300011 for the details.
    1: #ifndef WINCE
    1:   if (!aPluginInstance) {
    1:     UndoSubclassAndAssociateWindow();
    1:     mPrevWinProc = NULL;
    1:   }
    1: 
    1:   // We need WndProc before plug-ins do subclass in nsPluginNativeWindow::CallSetWindow.
    1:   if (aPluginInstance) {
23614:     WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr((HWND)window, GWLP_WNDPROC);
    1:     if (currentWndProc != PluginWndProc)
    1:       mPrevWinProc = currentWndProc;
52098: 
52098:     // PDF plugin v7.0.9, v8.1.3, and v9.0 subclass parent window, bug 531551
52098:     // V8.2.2 and V9.1 don't have such problem.
52098:     if (mPluginType == nsPluginType_PDF) {
52098:       HWND parent = ::GetParent((HWND)window);
52098:       if (mParentWnd != parent) {
52098:         NS_ASSERTION(!mParentWnd, "Plugin's parent window changed");
52098:         mParentWnd = parent;
52098:         mParentProc = ::GetWindowLongPtr(mParentWnd, GWLP_WNDPROC);
52098:       }
52098:     }
    1:   }
    1: #endif
    1: 
    1:   nsPluginNativeWindow::CallSetWindow(aPluginInstance);
    1: 
    1: #ifndef WINCE
    1:   if (aPluginInstance)
    1:     SubclassAndAssociateWindow();
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifndef WINCE
    1: 
    1: nsresult nsPluginNativeWindowWin::SubclassAndAssociateWindow()
    1: {
32799:   if (type != NPWindowTypeWindow)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   HWND hWnd = (HWND)window;
    1:   if (!hWnd)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // check if we need to re-subclass
23614:   WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_WNDPROC);
    1:   if (PluginWndProc == currentWndProc)
    1:     return NS_OK;
    1: 
47318:   LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
37613: #ifdef MOZ_IPC
37613:   // Out of process plugins must not have the WS_CLIPCHILDREN style set on their
37613:   // parent windows or else synchronous paints (via UpdateWindow() and others)
37613:   // will cause deadlocks.
37614:   if (::GetPropW(hWnd, L"PluginInstanceParentProperty"))
37613:     style &= ~WS_CLIPCHILDREN;
37614:   else
37614:     style |= WS_CLIPCHILDREN;
37613: #else
35747:   style |= WS_CLIPCHILDREN;
37613: #endif
35747:   SetWindowLongPtr(hWnd, GWL_STYLE, style);
35747: 
23614:   mPluginWinProc = SubclassWindow(hWnd, (LONG_PTR)PluginWndProc);
    1:   if (!mPluginWinProc)
    1:     return NS_ERROR_FAILURE;
    1: 
12902:   nsPluginNativeWindowWin * win = (nsPluginNativeWindowWin *)::GetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
    1:   NS_ASSERTION(!win || (win == this), "plugin window already has property and this is not us");
    1:   
12902:   if (!::SetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION, (HANDLE)this))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginNativeWindowWin::UndoSubclassAndAssociateWindow()
    1: {
    1:   // release plugin instance
    1:   SetPluginInstance(nsnull);
    1: 
    1:   // remove window property
    1:   HWND hWnd = (HWND)window;
    1:   if (IsWindow(hWnd))
12902:     ::RemoveProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
    1: 
    1:   // restore the original win proc
    1:   // but only do this if this were us last time
    1:   if (mPluginWinProc) {
23614:     WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_WNDPROC);
    1:     if (currentWndProc == PluginWndProc)
23614:       SubclassWindow(hWnd, (LONG_PTR)mPluginWinProc);
35747: 
47318:     LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
35747:     style &= ~WS_CLIPCHILDREN;
35747:     SetWindowLongPtr(hWnd, GWL_STYLE, style);
    1:   }
    1: 
52098:   if (mPluginType == nsPluginType_PDF && mParentWnd) {
52098:     ::SetWindowLongPtr(mParentWnd, GWLP_WNDPROC, mParentProc);
52098:     mParentWnd = NULL;
52098:     mParentProc = NULL;
52098:   }
52098: 
    1:   return NS_OK;
    1: }
    1: #endif // WINCE
    1: 
    1: nsresult PLUG_NewPluginNativeWindow(nsPluginNativeWindow ** aPluginNativeWindow)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
    1: 
    1:   *aPluginNativeWindow = new nsPluginNativeWindowWin();
    1: 
    1:   return *aPluginNativeWindow ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: nsresult PLUG_DeletePluginNativeWindow(nsPluginNativeWindow * aPluginNativeWindow)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
    1:   nsPluginNativeWindowWin *p = (nsPluginNativeWindowWin *)aPluginNativeWindow;
    1:   delete p;
    1:   return NS_OK;
    1: }
