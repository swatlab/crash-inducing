   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /* rendering object for CSS display:inline objects */
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsInlineFrame.h"
   1: #include "nsBlockFrame.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsHTMLParts.h"
   1: #include "nsStyleContext.h"
   1: #include "nsIPresShell.h"
   1: #include "nsPresContext.h"
   1: #include "nsIRenderingContext.h"
   1: #include "nsIFontMetrics.h"
   1: #include "nsAbsoluteContainingBlock.h"
   1: #include "nsCSSAnonBoxes.h"
   1: #include "nsAutoPtr.h"
   1: #include "nsFrameManager.h"
   1: #ifdef ACCESSIBILITY
   1: #include "nsIServiceManager.h"
   1: #include "nsIAccessibilityService.h"
   1: #endif
   1: #include "nsDisplayList.h"
   1: 
   1: #ifdef DEBUG
   1: #undef NOISY_PUSHING
   1: #endif
   1: 
   1: 
   1: NS_DEFINE_IID(kInlineFrameCID, NS_INLINE_FRAME_CID);
   1: 
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: 
   1: // Basic nsInlineFrame methods
   1: 
   1: nsIFrame*
   1: NS_NewInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsInlineFrame(aContext);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsInlineFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
   1: {
3114:   NS_PRECONDITION(aInstancePtr, "null out param");
3114: 
   1:   if (aIID.Equals(kInlineFrameCID)) {
3114:     *aInstancePtr = this;
   1:     return NS_OK;
   1:   }
3114: 
   1:   return nsInlineFrameSuper::QueryInterface(aIID, aInstancePtr);
   1: }
   1: 
   1: void
   1: nsInlineFrame::Destroy()
   1: {
   1:   if (mState & NS_FRAME_GENERATED_CONTENT) {
   1:     // Make sure all the content nodes for the generated content inside
   1:     // this frame know it's going away.
   1:     // This is duplicated in nsBlockFrame::Destroy.
   1:     // See also nsCSSFrameConstructor::CreateGeneratedContentFrame which
   1:     // created this frame.
   1: 
   1:     // XXXbz would this be better done via a global structure in
   1:     // nsCSSFrameConstructor that could key off of
   1:     // GeneratedContentFrameRemoved or something?  The problem is that
   1:     // our kids are gone by the time that's called.
   1:     nsContainerFrame::CleanupGeneratedContentIn(mContent, this);
   1:   }
   1:   nsInlineFrameSuper::Destroy();
   1: }
   1: 
   1: #ifdef DEBUG
   1: NS_IMETHODIMP
   1: nsInlineFrame::GetFrameName(nsAString& aResult) const
   1: {
   1:   return MakeFrameName(NS_LITERAL_STRING("Inline"), aResult);
   1: }
   1: #endif
   1: 
   1: nsIAtom*
   1: nsInlineFrame::GetType() const
   1: {
   1:   return nsGkAtoms::inlineFrame;
   1: }
   1: 
   1: inline PRBool
   1: IsPaddingZero(nsStyleUnit aUnit, nsStyleCoord &aCoord)
   1: {
1364:     return ((aUnit == eStyleUnit_Coord && aCoord.GetCoordValue() == 0) ||
   1:             (aUnit == eStyleUnit_Percent && aCoord.GetPercentValue() == 0.0));
   1: }
   1: 
   1: inline PRBool
   1: IsMarginZero(nsStyleUnit aUnit, nsStyleCoord &aCoord)
   1: {
1364:     return (aUnit == eStyleUnit_Auto ||
   1:             (aUnit == eStyleUnit_Coord && aCoord.GetCoordValue() == 0) ||
   1:             (aUnit == eStyleUnit_Percent && aCoord.GetPercentValue() == 0.0));
   1: }
   1: 
   1: /* virtual */ PRBool
   1: nsInlineFrame::IsSelfEmpty()
   1: {
   1: #if 0
   1:   // I used to think inline frames worked this way, but it seems they
   1:   // don't.  At least not in our codebase.
   1:   if (GetPresContext()->CompatibilityMode() == eCompatibility_FullStandards) {
   1:     return PR_FALSE;
   1:   }
   1: #endif
   1:   const nsStyleMargin* margin = GetStyleMargin();
   1:   const nsStyleBorder* border = GetStyleBorder();
   1:   const nsStylePadding* padding = GetStylePadding();
   1:   nsStyleCoord coord;
   1:   // XXX Top and bottom removed, since they shouldn't affect things, but this
   1:   // doesn't really match with nsLineLayout.cpp's setting of
   1:   // ZeroEffectiveSpanBox, anymore, so what should this really be?
   1:   if (border->GetBorderWidth(NS_SIDE_RIGHT) != 0 ||
   1:       border->GetBorderWidth(NS_SIDE_LEFT) != 0 ||
   1:       !IsPaddingZero(padding->mPadding.GetRightUnit(),
   1:                      padding->mPadding.GetRight(coord)) ||
   1:       !IsPaddingZero(padding->mPadding.GetLeftUnit(),
   1:                      padding->mPadding.GetLeft(coord)) ||
   1:       !IsMarginZero(margin->mMargin.GetRightUnit(),
   1:                     margin->mMargin.GetRight(coord)) ||
   1:       !IsMarginZero(margin->mMargin.GetLeftUnit(),
   1:                     margin->mMargin.GetLeft(coord))) {
   1:     return PR_FALSE;
   1:   }
   1:   return PR_TRUE;
   1: }
   1: 
   1: PRBool
   1: nsInlineFrame::IsEmpty()
   1: {
   1:   if (!IsSelfEmpty()) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   for (nsIFrame *kid = mFrames.FirstChild(); kid; kid = kid->GetNextSibling()) {
   1:     if (!kid->IsEmpty())
   1:       return PR_FALSE;
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: PRBool
   1: nsInlineFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset)
   1: {
   1:   // Override the implementation in nsFrame, to skip empty inline frames
   1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
   1:   PRInt32 startOffset = *aOffset;
   1:   if (startOffset < 0)
   1:     startOffset = 1;
   1:   if (aForward == (startOffset == 0)) {
   1:     // We're before the frame and moving forward, or after it and moving backwards:
   1:     // skip to the other side, but keep going.
   1:     *aOffset = 1 - startOffset;
   1:   }
   1:   return PR_FALSE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsInlineFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                                 const nsRect&           aDirtyRect,
   1:                                 const nsDisplayListSet& aLists)
   1: {
   1:   nsresult rv = nsHTMLContainerFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   // The sole purpose of this is to trigger display of the selection
   1:   // window for Named Anchors, which don't have any children and
   1:   // normally don't have any size, but in Editor we use CSS to display
   1:   // an image to represent this "hidden" element.
   1:   if (!mFrames.FirstChild()) {
   1:     rv = DisplaySelectionOverlay(aBuilder, aLists);
   1:   }
   1:   return rv;
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: // Reflow methods
   1: 
   1: /* virtual */ void
   1: nsInlineFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
   1:                                  nsIFrame::InlineMinWidthData *aData)
   1: {
   1:   DoInlineIntrinsicWidth(aRenderingContext, aData, nsLayoutUtils::MIN_WIDTH);
   1: }
   1: 
   1: /* virtual */ void
   1: nsInlineFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
   1:                                   nsIFrame::InlinePrefWidthData *aData)
   1: {
   1:   DoInlineIntrinsicWidth(aRenderingContext, aData, nsLayoutUtils::PREF_WIDTH);
   1: }
   1: 
   1: /* virtual */ nsSize
   1: nsInlineFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
   1:                            nsSize aCBSize, nscoord aAvailableWidth,
   1:                            nsSize aMargin, nsSize aBorder, nsSize aPadding,
   1:                            PRBool aShrinkWrap)
   1: {
   1:   // Inlines and text don't compute size before reflow.
   1:   return nsSize(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
   1: }
   1: 
 686: void
 686: nsInlineFrame::ReparentFloatsForInlineChild(nsIFrame* aOurLineContainer,
 686:                                             nsIFrame* aFrame,
 686:                                             PRBool aReparentSiblings)
 686: {
 686:   NS_ASSERTION(aOurLineContainer->GetNextContinuation() ||
 686:                aOurLineContainer->GetPrevContinuation(),
 686:                "Don't call this when we have no continuation, it's a waste");
3667:   if (!aFrame) {
3667:     NS_ASSERTION(aReparentSiblings, "Why did we get called?");
3667:     return;
3667:   }
 686: 
 686:   nsIFrame* ancestor = aFrame;
 686:   nsIFrame* ancestorBlockChild;
 686:   do {
 686:     ancestorBlockChild = ancestor;
 686:     ancestor = ancestor->GetParent();
 686:     if (!ancestor)
 686:       return;
 686:   } while (!ancestor->IsFloatContainingBlock());
 686: 
 686:   if (ancestor == aOurLineContainer)
 686:     return;
 686: 
 686:   nsBlockFrame* ourBlock;
 686:   nsresult rv = aOurLineContainer->QueryInterface(kBlockFrameCID, (void**)&ourBlock);
 686:   NS_ASSERTION(NS_SUCCEEDED(rv), "Not a block, but broke vertically?");
 686:   nsBlockFrame* frameBlock;
 686:   rv = ancestor->QueryInterface(kBlockFrameCID, (void**)&frameBlock);
 686:   NS_ASSERTION(NS_SUCCEEDED(rv), "ancestor not a block");
 686: 
 686:   nsFrameList blockChildren(ancestor->GetFirstChild(nsnull));
 686:   PRBool isOverflow = !blockChildren.ContainsFrame(ancestorBlockChild);
 686: 
 686:   while (PR_TRUE) {
 686:     ourBlock->ReparentFloats(aFrame, frameBlock, isOverflow, PR_FALSE);
 686: 
 686:     if (!aReparentSiblings)
 686:       return;
 686:     nsIFrame* next = aFrame->GetNextSibling();
 686:     if (!next)
 686:       return;
 686:     if (next->GetParent() == aFrame->GetParent()) {
 686:       aFrame = next;
 686:       continue;
 686:     }
 686:     // This is paranoid and will hardly ever get hit ... but we can't actually
 686:     // trust that the frames in the sibling chain all have the same parent,
 686:     // because lazy reparenting may be going on. If we find a different
 686:     // parent we need to redo our analysis.
 686:     ReparentFloatsForInlineChild(aOurLineContainer, next, aReparentSiblings);
 686:     return;
 686:   }
 686: }
 686: 
   1: NS_IMETHODIMP
   1: nsInlineFrame::Reflow(nsPresContext*          aPresContext,
   1:                       nsHTMLReflowMetrics&     aMetrics,
   1:                       const nsHTMLReflowState& aReflowState,
   1:                       nsReflowStatus&          aStatus)
   1: {
   1:   DO_GLOBAL_REFLOW_COUNT("nsInlineFrame");
   1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
   1:   if (nsnull == aReflowState.mLineLayout) {
   1:     return NS_ERROR_INVALID_ARG;
   1:   }
   1: 
   1:   PRBool  lazilySetParentPointer = PR_FALSE;
   1: 
 686:   nsIFrame* lineContainer = aReflowState.mLineLayout->GetLineContainerFrame();
 686: 
   1:    // Check for an overflow list with our prev-in-flow
   1:   nsInlineFrame* prevInFlow = (nsInlineFrame*)GetPrevInFlow();
   1:   if (nsnull != prevInFlow) {
   1:     nsIFrame* prevOverflowFrames = prevInFlow->GetOverflowFrames(aPresContext, PR_TRUE);
   1: 
   1:     if (prevOverflowFrames) {
   1:       // When pushing and pulling frames we need to check for whether any
   1:       // views need to be reparented.
   1:       nsHTMLContainerFrame::ReparentFrameViewList(aPresContext, prevOverflowFrames,
   1:                                                   prevInFlow, this);
   1: 
   1:       if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
   1:         // If it's the initial reflow, then our child list must be empty, so
   1:         // just set the child list rather than calling InsertFrame(). This avoids
   1:         // having to get the last child frame in the list.
   1:         // Note that we don't set the parent pointer for the new frames. Instead wait
   1:         // to do this until we actually reflow the frame. If the overflow list contains
   1:         // thousands of frames this is a big performance issue (see bug #5588)
   1:         NS_ASSERTION(mFrames.IsEmpty(), "child list is not empty for initial reflow");
   1:         mFrames.SetFrames(prevOverflowFrames);
   1:         lazilySetParentPointer = PR_TRUE;
   1:       } else {
 686:         // Assign all floats to our block if necessary
 686:         if (lineContainer && lineContainer->GetPrevContinuation()) {
 686:           ReparentFloatsForInlineChild(lineContainer, prevOverflowFrames, PR_TRUE);
 686:         }
   1:         // Insert the new frames at the beginning of the child list
   1:         // and set their parent pointer
   1:         mFrames.InsertFrames(this, nsnull, prevOverflowFrames);
   1:       }
   1:     }
   1:   }
   1: 
   1:   // It's also possible that we have an overflow list for ourselves
   1: #ifdef DEBUG
   1:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
   1:     // If it's our initial reflow, then we should not have an overflow list.
   1:     // However, add an assertion in case we get reflowed more than once with
   1:     // the initial reflow reason
   1:     nsIFrame* overflowFrames = GetOverflowFrames(aPresContext, PR_FALSE);
   1:     NS_ASSERTION(!overflowFrames, "overflow list is not empty for initial reflow");
   1:   }
   1: #endif
   1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
   1:     nsIFrame* overflowFrames = GetOverflowFrames(aPresContext, PR_TRUE);
   1:     if (overflowFrames) {
   1:       NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
   1: 
   1:       // Because we lazily set the parent pointer of child frames we get from
   1:       // our prev-in-flow's overflow list, it's possible that we have not set
   1:       // the parent pointer for these frames.
   1:       mFrames.AppendFrames(this, overflowFrames);
   1:     }
   1:   }
   1: 
   1:   if (IsFrameTreeTooDeep(aReflowState, aMetrics)) {
   1: #ifdef DEBUG_kipp
   1:     {
   1:       extern char* nsPresShell_ReflowStackPointerTop;
   1:       char marker;
   1:       char* newsp = (char*) &marker;
   1:       printf("XXX: frame tree is too deep; approx stack size = %d\n",
   1:              nsPresShell_ReflowStackPointerTop - newsp);
   1:     }
   1: #endif
   1:     aStatus = NS_FRAME_COMPLETE;
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Set our own reflow state (additional state above and beyond
   1:   // aReflowState)
   1:   InlineReflowState irs;
   1:   irs.mPrevFrame = nsnull;
 686:   irs.mLineContainer = lineContainer;
   1:   irs.mNextInFlow = (nsInlineFrame*) GetNextInFlow();
   1:   irs.mSetParentPointer = lazilySetParentPointer;
   1: 
   1:   nsresult rv;
   1:   if (mFrames.IsEmpty()) {
   1:     // Try to pull over one frame before starting so that we know
   1:     // whether we have an anonymous block or not.
   1:     PRBool complete;
   1:     (void) PullOneFrame(aPresContext, irs, &complete);
   1:   }
   1: 
   1:   rv = ReflowFrames(aPresContext, aReflowState, irs, aMetrics, aStatus);
   1:   
   1:   // Note: the line layout code will properly compute our
   1:   // NS_FRAME_OUTSIDE_CHILDREN state for us.
   1: 
   1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
   1:   return rv;
   1: }
   1: 
   1: /* virtual */ PRBool
   1: nsInlineFrame::CanContinueTextRun() const
   1: {
   1:   // We can continue a text run through an inline frame
   1:   return PR_TRUE;
   1: }
   1: 
   1: nsresult
   1: nsInlineFrame::ReflowFrames(nsPresContext* aPresContext,
   1:                             const nsHTMLReflowState& aReflowState,
   1:                             InlineReflowState& irs,
   1:                             nsHTMLReflowMetrics& aMetrics,
   1:                             nsReflowStatus& aStatus)
   1: {
   1:   nsresult rv = NS_OK;
   1:   aStatus = NS_FRAME_COMPLETE;
   1: 
   1:   nsLineLayout* lineLayout = aReflowState.mLineLayout;
   1:   PRBool ltr = (NS_STYLE_DIRECTION_LTR == aReflowState.mStyleVisibility->mDirection);
   1:   nscoord leftEdge = 0;
   1:   if (nsnull == GetPrevContinuation()) {
   1:     leftEdge = ltr ? aReflowState.mComputedBorderPadding.left
   1:                    : aReflowState.mComputedBorderPadding.right;
   1:   }
   1:   nscoord availableWidth = aReflowState.availableWidth;
   1:   if (NS_UNCONSTRAINEDSIZE != availableWidth) {
   1:     // Subtract off left and right border+padding from availableWidth
   1:     availableWidth -= leftEdge;
   1:     availableWidth -= ltr ? aReflowState.mComputedBorderPadding.right
   1:                           : aReflowState.mComputedBorderPadding.left;
   1:     availableWidth = PR_MAX(0, availableWidth);
   1:   }
   1:   lineLayout->BeginSpan(this, &aReflowState, leftEdge, leftEdge + availableWidth);
   1: 
   1:   // First reflow our current children
   1:   nsIFrame* frame = mFrames.FirstChild();
   1:   PRBool done = PR_FALSE;
   1:   while (nsnull != frame) {
   1:     PRBool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
   1: 
   1:     // Check if we should lazily set the child frame's parent pointer
   1:     if (irs.mSetParentPointer) {
 686:       PRBool havePrevBlock =
 686:         irs.mLineContainer && irs.mLineContainer->GetPrevContinuation();
 686:       // If our block is the first in flow, then any floats under the pulled
 686:       // frame must already belong to our block.
 686:       if (havePrevBlock) {
 686:         // This has to happen before we update frame's parent; we need to
 686:         // know frame's ancestry under its old block.
 686:         // The blockChildren.ContainsFrame check performed by
 686:         // ReparentFloatsForInlineChild here may be slow, but we can't
 686:         // easily avoid it because we don't know where 'frame' originally
 686:         // came from. If we really really have to optimize this we could
 686:         // cache whether frame->GetParent() is under its containing blocks
 686:         // overflowList or not.
 686:         ReparentFloatsForInlineChild(irs.mLineContainer, frame, PR_FALSE);
 686:       }
   1:       frame->SetParent(this);
   1:       // We also need to check if frame has a next-in-flow. If it does, then set
   1:       // its parent frame pointer, too. Otherwise, if we reflow frame and it's
   1:       // complete we'll fail when deleting its next-in-flow which is no longer
   1:       // needed. This scenario doesn't happen often, but it can happen
   1:       nsIFrame* nextInFlow = frame->GetNextInFlow();
   1:       while (nextInFlow) {
   1:         // Since we only do lazy setting of parent pointers for the frame's
   1:         // initial reflow, this frame can't have a next-in-flow. That means
   1:         // the continuing child frame must be in our child list as well. If
   1:         // not, then something is wrong
   1:         NS_ASSERTION(mFrames.ContainsFrame(nextInFlow), "unexpected flow");
 686:         if (havePrevBlock) {
 686:           ReparentFloatsForInlineChild(irs.mLineContainer, nextInFlow, PR_FALSE);
 686:         }
   1:         nextInFlow->SetParent(this);
   1:         nextInFlow = nextInFlow->GetNextInFlow();
   1:       }
   1:     }
   1:     rv = ReflowInlineFrame(aPresContext, aReflowState, irs, frame, aStatus);
   1:     if (NS_FAILED(rv)) {
   1:       done = PR_TRUE;
   1:       break;
   1:     }
   1:     if (NS_INLINE_IS_BREAK(aStatus) || 
   1:         (!reflowingFirstLetter && NS_FRAME_IS_NOT_COMPLETE(aStatus))) {
   1:       done = PR_TRUE;
   1:       break;
   1:     }
   1:     irs.mPrevFrame = frame;
   1:     frame = frame->GetNextSibling();
   1:   }
   1: 
   1:   // Attempt to pull frames from our next-in-flow until we can't
   1:   if (!done && (nsnull != GetNextInFlow())) {
   1:     while (!done) {
   1:       PRBool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
   1:       PRBool isComplete;
   1:       if (!frame) { // Could be non-null if we pulled a first-letter frame and
   1:                     // it created a continuation, since we don't push those.
   1:         frame = PullOneFrame(aPresContext, irs, &isComplete);
   1:       }
   1: #ifdef NOISY_PUSHING
   1:       printf("%p pulled up %p\n", this, frame);
   1: #endif
   1:       if (nsnull == frame) {
   1:         if (!isComplete) {
   1:           aStatus = NS_FRAME_NOT_COMPLETE;
   1:         }
   1:         break;
   1:       }
   1:       rv = ReflowInlineFrame(aPresContext, aReflowState, irs, frame, aStatus);
   1:       if (NS_FAILED(rv)) {
   1:         done = PR_TRUE;
   1:         break;
   1:       }
   1:       if (NS_INLINE_IS_BREAK(aStatus) || 
   1:           (!reflowingFirstLetter && NS_FRAME_IS_NOT_COMPLETE(aStatus))) {
   1:         done = PR_TRUE;
   1:         break;
   1:       }
   1:       irs.mPrevFrame = frame;
   1:       frame = frame->GetNextSibling();
   1:     }
   1:   }
   1: #ifdef DEBUG
   1:   if (NS_FRAME_IS_COMPLETE(aStatus)) {
   1:     // We can't be complete AND have overflow frames!
   1:     nsIFrame* overflowFrames = GetOverflowFrames(aPresContext, PR_FALSE);
   1:     NS_ASSERTION(!overflowFrames, "whoops");
   1:   }
   1: #endif
   1: 
   1:   // If after reflowing our children they take up no area then make
   1:   // sure that we don't either.
   1:   //
   1:   // Note: CSS demands that empty inline elements still affect the
   1:   // line-height calculations. However, continuations of an inline
   1:   // that are empty we force to empty so that things like collapsed
   1:   // whitespace in an inline element don't affect the line-height.
   1:   nsSize size;
   1:   lineLayout->EndSpan(this, size);
1123: 
   1:   // Compute final width
   1:   aMetrics.width = size.width;
   1:   if (nsnull == GetPrevContinuation()) {
   1:     aMetrics.width += ltr ? aReflowState.mComputedBorderPadding.left
   1:                           : aReflowState.mComputedBorderPadding.right;
   1:   }
   1:   if (NS_FRAME_IS_COMPLETE(aStatus) && (!GetNextContinuation() || GetNextInFlow())) {
   1:     aMetrics.width += ltr ? aReflowState.mComputedBorderPadding.right
   1:                           : aReflowState.mComputedBorderPadding.left;
   1:   }
   1: 
1105:   nsLayoutUtils::SetFontFromStyle(aReflowState.rendContext, mStyleContext);
   1:   nsCOMPtr<nsIFontMetrics> fm;
   1:   aReflowState.rendContext->GetFontMetrics(*getter_AddRefs(fm));
   1: 
   1:   if (fm) {
   1:     // Compute final height of the frame.
   1:     //
   1:     // Do things the standard css2 way -- though it's hard to find it
   1:     // in the css2 spec! It's actually found in the css1 spec section
   1:     // 4.4 (you will have to read between the lines to really see
   1:     // it).
   1:     //
   1:     // The height of our box is the sum of our font size plus the top
   1:     // and bottom border and padding. The height of children do not
   1:     // affect our height.
   1:     fm->GetMaxAscent(aMetrics.ascent);
   1:     fm->GetHeight(aMetrics.height);
   1:   } else {
   1:     NS_WARNING("Cannot get font metrics - defaulting sizes to 0");
   1:     aMetrics.ascent = aMetrics.height = 0;
   1:   }
   1:   aMetrics.ascent += aReflowState.mComputedBorderPadding.top;
   1:   aMetrics.height += aReflowState.mComputedBorderPadding.top +
   1:     aReflowState.mComputedBorderPadding.bottom;
   1: 
   1:   // For now our overflow area is zero. The real value will be
   1:   // computed during vertical alignment of the line we are on.
   1:   aMetrics.mOverflowArea.SetRect(0, 0, 0, 0);
   1: 
   1: #ifdef NOISY_FINAL_SIZE
   1:   ListTag(stdout);
   1:   printf(": metrics=%d,%d ascent=%d\n",
   1:          aMetrics.width, aMetrics.height, aMetrics.ascent);
   1: #endif
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsInlineFrame::ReflowInlineFrame(nsPresContext* aPresContext,
   1:                                  const nsHTMLReflowState& aReflowState,
   1:                                  InlineReflowState& irs,
   1:                                  nsIFrame* aFrame,
   1:                                  nsReflowStatus& aStatus)
   1: {
   1:   nsLineLayout* lineLayout = aReflowState.mLineLayout;
   1:   PRBool reflowingFirstLetter = lineLayout->GetFirstLetterStyleOK();
   1:   PRBool pushedFrame;
   1:   nsresult rv =
   1:     lineLayout->ReflowFrame(aFrame, aStatus, nsnull, pushedFrame);
   1:   
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1:   if (NS_INLINE_IS_BREAK(aStatus)) {
   1:     if (NS_INLINE_IS_BREAK_BEFORE(aStatus)) {
   1:       if (aFrame != mFrames.FirstChild()) {
   1:         // Change break-before status into break-after since we have
   1:         // already placed at least one child frame. This preserves the
   1:         // break-type so that it can be propagated upward.
   1:         aStatus = NS_FRAME_NOT_COMPLETE |
   1:           NS_INLINE_BREAK | NS_INLINE_BREAK_AFTER |
   1:           (aStatus & NS_INLINE_BREAK_TYPE_MASK);
   1:         PushFrames(aPresContext, aFrame, irs.mPrevFrame);
   1:       }
   1:       else {
   1:         // Preserve reflow status when breaking-before our first child
   1:         // and propagate it upward without modification.
   1:         // Note: if we're lazily setting the frame pointer for our child 
   1:         // frames, then we need to set it now. Don't return and leave the
   1:         // remaining child frames in our child list with the wrong parent
   1:         // frame pointer...
   1:         if (irs.mSetParentPointer) {
 686:           if (irs.mLineContainer && irs.mLineContainer->GetPrevContinuation()) {
 686:             ReparentFloatsForInlineChild(irs.mLineContainer, aFrame->GetNextSibling(),
 686:                                          PR_TRUE);
 686:           }
   1:           for (nsIFrame* f = aFrame->GetNextSibling(); f; f = f->GetNextSibling()) {
   1:             f->SetParent(this);
   1:           }
   1:         }
   1:       }
   1:     }
   1:     else {
   1:       // Break-after
   1:       if (NS_FRAME_IS_NOT_COMPLETE(aStatus)) {
   1:         nsIFrame* newFrame;
   1:         rv = CreateNextInFlow(aPresContext, this, aFrame, newFrame);
   1:         if (NS_FAILED(rv)) {
   1:           return rv;
   1:         }
   1:       }
   1:       nsIFrame* nextFrame = aFrame->GetNextSibling();
   1:       if (nextFrame) {
   1:         aStatus |= NS_FRAME_NOT_COMPLETE;
   1:         PushFrames(aPresContext, nextFrame, aFrame);
   1:       }
   1:       else if (nsnull != GetNextInFlow()) {
   1:         // We must return an incomplete status if there are more child
   1:         // frames remaining in a next-in-flow that follows this frame.
   1:         nsInlineFrame* nextInFlow = (nsInlineFrame*) GetNextInFlow();
   1:         while (nsnull != nextInFlow) {
   1:           if (nextInFlow->mFrames.NotEmpty()) {
   1:             aStatus |= NS_FRAME_NOT_COMPLETE;
   1:             break;
   1:           }
   1:           nextInFlow = (nsInlineFrame*) nextInFlow->GetNextInFlow();
   1:         }
   1:       }
   1:     }
   1:   }
   1:   else if (NS_FRAME_IS_NOT_COMPLETE(aStatus)) {
   1:     if (nsGkAtoms::placeholderFrame == aFrame->GetType()) {
   1:       nsBlockReflowState* blockRS = lineLayout->mBlockRS;
   1:       blockRS->mBlock->SplitPlaceholder(*blockRS, aFrame);
   1:       // Allow the parent to continue reflowing
   1:       aStatus = NS_FRAME_COMPLETE;
   1:     }
   1:     else {
   1:       nsIFrame* newFrame;
   1:       rv = CreateNextInFlow(aPresContext, this, aFrame, newFrame);
   1:       if (NS_FAILED(rv)) {
   1:         return rv;
   1:       }
   1:       if (!reflowingFirstLetter) {
   1:         nsIFrame* nextFrame = aFrame->GetNextSibling();
   1:         if (nextFrame) {
   1:           PushFrames(aPresContext, nextFrame, aFrame);
   1:         }
   1:       }
   1:     }
   1:   }
   1:   return rv;
   1: }
   1: 
   1: nsIFrame*
   1: nsInlineFrame::PullOneFrame(nsPresContext* aPresContext,
   1:                             InlineReflowState& irs,
   1:                             PRBool* aIsComplete)
   1: {
   1:   PRBool isComplete = PR_TRUE;
   1: 
   1:   nsIFrame* frame = nsnull;
   1:   nsInlineFrame* nextInFlow = irs.mNextInFlow;
   1:   while (nsnull != nextInFlow) {
 686:     frame = nextInFlow->mFrames.FirstChild();
   1:     if (nsnull != frame) {
 686:       // If our block has no next continuation, then any floats belonging to
 686:       // the pulled frame must belong to our block already. This check ensures
 686:       // we do no extra work in the common non-vertical-breaking case.
 686:       if (irs.mLineContainer && irs.mLineContainer->GetNextContinuation()) {
 686:         // The blockChildren.ContainsFrame check performed by
 686:         // ReparentFloatsForInlineChild will be fast because frame's ancestor
 686:         // will be the first child of its containing block.
 686:         ReparentFloatsForInlineChild(irs.mLineContainer, frame, PR_FALSE);
 686:       }
 686:       nextInFlow->mFrames.RemoveFirstChild();
 686:       mFrames.InsertFrame(this, irs.mPrevFrame, frame);
   1:       isComplete = PR_FALSE;
   1:       nsHTMLContainerFrame::ReparentFrameView(aPresContext, frame, nextInFlow, this);
   1:       break;
   1:     }
   1:     nextInFlow = (nsInlineFrame*) nextInFlow->GetNextInFlow();
   1:     irs.mNextInFlow = nextInFlow;
   1:   }
   1: 
   1:   *aIsComplete = isComplete;
   1:   return frame;
   1: }
   1: 
   1: void
   1: nsInlineFrame::PushFrames(nsPresContext* aPresContext,
   1:                           nsIFrame* aFromChild,
   1:                           nsIFrame* aPrevSibling)
   1: {
   1:   NS_PRECONDITION(nsnull != aFromChild, "null pointer");
   1:   NS_PRECONDITION(nsnull != aPrevSibling, "pushing first child");
   1:   NS_PRECONDITION(aPrevSibling->GetNextSibling() == aFromChild, "bad prev sibling");
   1: 
   1: #ifdef NOISY_PUSHING
   1:       printf("%p pushing aFromChild %p, disconnecting from prev sib %p\n", 
   1:              this, aFromChild, aPrevSibling);
   1: #endif
   1:   // Disconnect aFromChild from its previous sibling
   1:   aPrevSibling->SetNextSibling(nsnull);
   1: 
   1:   // Add the frames to our overflow list (let our next in flow drain
   1:   // our overflow list when it is ready)
   1:   SetOverflowFrames(aPresContext, aFromChild);
   1: }
   1: 
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: 
   1: PRIntn
   1: nsInlineFrame::GetSkipSides() const
   1: {
   1:   PRIntn skip = 0;
   1:   if (!IsLeftMost()) {
   1:     nsInlineFrame* prev = (nsInlineFrame*) GetPrevContinuation();
   1:     if ((GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET) ||
   1:         (prev && (prev->mRect.height || prev->mRect.width))) {
   1:       // Prev continuation is not empty therefore we don't render our left
   1:       // border edge.
   1:       skip |= 1 << NS_SIDE_LEFT;
   1:     }
   1:     else {
   1:       // If the prev continuation is empty, then go ahead and let our left
   1:       // edge border render.
   1:     }
   1:   }
   1:   if (!IsRightMost()) {
   1:     nsInlineFrame* next = (nsInlineFrame*) GetNextContinuation();
   1:     if ((GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET) ||
   1:         (next && (next->mRect.height || next->mRect.width))) {
   1:       // Next continuation is not empty therefore we don't render our right
   1:       // border edge.
   1:       skip |= 1 << NS_SIDE_RIGHT;
   1:     }
   1:     else {
   1:       // If the next continuation is empty, then go ahead and let our right
   1:       // edge border render.
   1:     }
   1:   }
   1:   return skip;
   1: }
   1: 
   1: #ifdef ACCESSIBILITY
   1: NS_IMETHODIMP nsInlineFrame::GetAccessible(nsIAccessible** aAccessible)
   1: {
   1:   // Broken image accessibles are created here, because layout
   1:   // replaces the image or image control frame with an inline frame
   1:   *aAccessible = nsnull;
   1:   nsIAtom *tagAtom = mContent->Tag();
   1:   if ((tagAtom == nsGkAtoms::img || tagAtom == nsGkAtoms::input || 
   1:        tagAtom == nsGkAtoms::label) && mContent->IsNodeOfType(nsINode::eHTML)) {
   1:     // Only get accessibility service if we're going to use it
   1:     nsCOMPtr<nsIAccessibilityService> accService(do_GetService("@mozilla.org/accessibilityService;1"));
   1:     if (!accService)
   1:       return NS_ERROR_FAILURE;
   1:     if (tagAtom == nsGkAtoms::input)  // Broken <input type=image ... />
3233:       return accService->CreateHTMLButtonAccessible(static_cast<nsIFrame*>(this), aAccessible);
   1:     else if (tagAtom == nsGkAtoms::img)  // Create accessible for broken <img>
3233:       return accService->CreateHTMLImageAccessible(static_cast<nsIFrame*>(this), aAccessible);
   1:     else if (tagAtom == nsGkAtoms::label)  // Creat accessible for <label>
3233:       return accService->CreateHTMLLabelAccessible(static_cast<nsIFrame*>(this), aAccessible);
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: #endif
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: 
   1: // nsLineFrame implementation
   1: 
   1: static void
   1: ReParentChildListStyle(nsPresContext* aPresContext,
   1:                        nsFrameList& aFrameList,
   1:                        nsIFrame* aParentFrame)
   1: {
   1:   nsFrameManager *frameManager = aPresContext->FrameManager();
   1: 
   1:   for (nsIFrame* kid = aFrameList.FirstChild(); kid;
   1:        kid = kid->GetNextSibling()) {
   1:     NS_ASSERTION(kid->GetParent() == aParentFrame, "Bogus parentage");
   1:     frameManager->ReParentStyleContext(kid);
   1:   }
   1: }
   1: 
   1: nsIFrame*
   1: NS_NewFirstLineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsFirstLineFrame(aContext);
   1: }
   1: 
   1: #ifdef DEBUG
   1: NS_IMETHODIMP
   1: nsFirstLineFrame::GetFrameName(nsAString& aResult) const
   1: {
   1:   return MakeFrameName(NS_LITERAL_STRING("Line"), aResult);
   1: }
   1: #endif
   1: 
   1: nsIAtom*
   1: nsFirstLineFrame::GetType() const
   1: {
   1:   return nsGkAtoms::lineFrame;
   1: }
   1: 
   1: void
   1: nsFirstLineFrame::StealFramesFrom(nsIFrame* aFrame)
   1: {
   1:   nsIFrame* prevFrame = mFrames.GetPrevSiblingFor(aFrame);
   1:   if (prevFrame) {
   1:     prevFrame->SetNextSibling(nsnull);
   1:   }
   1:   else {
   1:     mFrames.SetFrames(nsnull);
   1:   }
   1: }
   1: 
   1: nsIFrame*
 686: nsFirstLineFrame::PullOneFrame(nsPresContext* aPresContext, InlineReflowState& irs,
 686:                                PRBool* aIsComplete)
   1: {
   1:   nsIFrame* frame = nsInlineFrame::PullOneFrame(aPresContext, irs, aIsComplete);
   1:   if (frame && !GetPrevInFlow()) {
   1:     // We are a first-line frame. Fixup the child frames
   1:     // style-context that we just pulled.
   1:     NS_ASSERTION(frame->GetParent() == this, "Incorrect parent?");
   1:     aPresContext->FrameManager()->ReParentStyleContext(frame);
   1:   }
   1:   return frame;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsFirstLineFrame::Reflow(nsPresContext* aPresContext,
   1:                          nsHTMLReflowMetrics& aMetrics,
   1:                          const nsHTMLReflowState& aReflowState,
   1:                          nsReflowStatus& aStatus)
   1: {
   1:   if (nsnull == aReflowState.mLineLayout) {
   1:     return NS_ERROR_INVALID_ARG;
   1:   }
   1: 
 686:   nsIFrame* lineContainer = aReflowState.mLineLayout->GetLineContainerFrame();
 686: 
   1:   // Check for an overflow list with our prev-in-flow
   1:   nsFirstLineFrame* prevInFlow = (nsFirstLineFrame*)GetPrevInFlow();
   1:   if (nsnull != prevInFlow) {
   1:     nsIFrame* prevOverflowFrames = prevInFlow->GetOverflowFrames(aPresContext, PR_TRUE);
   1:     if (prevOverflowFrames) {
   1:       nsFrameList frames(prevOverflowFrames);
   1:       
 686:       // Assign all floats to our block if necessary
 686:       if (lineContainer && lineContainer->GetPrevContinuation()) {
 686:         ReparentFloatsForInlineChild(lineContainer, prevOverflowFrames, PR_TRUE);
 686:       }
   1:       mFrames.InsertFrames(this, nsnull, prevOverflowFrames);
   1:       ReParentChildListStyle(aPresContext, frames, this);
   1:     }
   1:   }
   1: 
   1:   // It's also possible that we have an overflow list for ourselves
   1:   nsIFrame* overflowFrames = GetOverflowFrames(aPresContext, PR_TRUE);
   1:   if (overflowFrames) {
   1:     NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
   1:     nsFrameList frames(overflowFrames);
   1: 
   1:     mFrames.AppendFrames(nsnull, overflowFrames);
   1:     ReParentChildListStyle(aPresContext, frames, this);
   1:   }
   1: 
   1:   // Set our own reflow state (additional state above and beyond
   1:   // aReflowState)
   1:   InlineReflowState irs;
   1:   irs.mPrevFrame = nsnull;
 686:   irs.mLineContainer = lineContainer;
   1:   irs.mNextInFlow = (nsInlineFrame*) GetNextInFlow();
   1: 
   1:   nsresult rv;
   1:   PRBool wasEmpty = mFrames.IsEmpty();
   1:   if (wasEmpty) {
   1:     // Try to pull over one frame before starting so that we know
   1:     // whether we have an anonymous block or not.
   1:     PRBool complete;
   1:     PullOneFrame(aPresContext, irs, &complete);
   1:   }
   1: 
   1:   if (nsnull == GetPrevInFlow()) {
   1:     // XXX This is pretty sick, but what we do here is to pull-up, in
   1:     // advance, all of the next-in-flows children. We re-resolve their
   1:     // style while we are at at it so that when we reflow they have
   1:     // the right style.
   1:     //
   1:     // All of this is so that text-runs reflow properly.
   1:     irs.mPrevFrame = mFrames.LastChild();
   1:     for (;;) {
   1:       PRBool complete;
   1:       nsIFrame* frame = PullOneFrame(aPresContext, irs, &complete);
   1:       if (!frame) {
   1:         break;
   1:       }
   1:       irs.mPrevFrame = frame;
   1:     }
   1:     irs.mPrevFrame = nsnull;
   1:   }
   1:   else {
   1: // XXX do this in the Init method instead
   1:     // For continuations, we need to check and see if our style
   1:     // context is right. If its the same as the first-in-flow, then
   1:     // we need to fix it up (that way :first-line style doesn't leak
   1:     // into this continuation since we aren't the first line).
   1:     nsFirstLineFrame* first = (nsFirstLineFrame*) GetFirstInFlow();
   1:     if (mStyleContext == first->mStyleContext) {
   1:       // Fixup our style context and our children. First get the
   1:       // proper parent context.
   1:       nsStyleContext* parentContext = first->GetParent()->GetStyleContext();
   1:       if (parentContext) {
   1:         // Create a new style context that is a child of the parent
   1:         // style context thus removing the :first-line style. This way
   1:         // we behave as if an anonymous (unstyled) span was the child
   1:         // of the parent frame.
   1:         nsRefPtr<nsStyleContext> newSC;
   1:         newSC = aPresContext->StyleSet()->
   1:           ResolvePseudoStyleFor(nsnull,
   1:                                 nsCSSAnonBoxes::mozLineFrame, parentContext);
   1:         if (newSC) {
   1:           // Switch to the new style context.
   1:           SetStyleContext(newSC);
   1: 
   1:           // Re-resolve all children
   1:           ReParentChildListStyle(aPresContext, mFrames, this);
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   NS_ASSERTION(!aReflowState.mLineLayout->GetInFirstLine(),
   1:                "Nested first-line frames? BOGUS");
   1:   aReflowState.mLineLayout->SetInFirstLine(PR_TRUE);
   1:   rv = ReflowFrames(aPresContext, aReflowState, irs, aMetrics, aStatus);
   1:   aReflowState.mLineLayout->SetInFirstLine(PR_FALSE);
   1: 
   1:   // Note: the line layout code will properly compute our overflow state for us
   1: 
   1:   return rv;
   1: }
   1: 
   1: //////////////////////////////////////////////////////////////////////
   1: 
   1: nsIFrame*
   1: NS_NewPositionedInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsPositionedInlineFrame(aContext);
   1: }
   1: 
   1: void
   1: nsPositionedInlineFrame::Destroy()
   1: {
   1:   mAbsoluteContainer.DestroyFrames(this);
   1:   nsInlineFrame::Destroy();
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsPositionedInlineFrame::SetInitialChildList(nsIAtom*        aListName,
   1:                                              nsIFrame*       aChildList)
   1: {
   1:   nsresult  rv;
   1: 
   1:   if (mAbsoluteContainer.GetChildListName() == aListName) {
   1:     rv = mAbsoluteContainer.SetInitialChildList(this, aListName, aChildList);
   1:   } else {
   1:     rv = nsInlineFrame::SetInitialChildList(aListName, aChildList);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsPositionedInlineFrame::AppendFrames(nsIAtom*        aListName,
   1:                                       nsIFrame*       aFrameList)
   1: {
   1:   nsresult  rv;
   1:   
   1:   if (mAbsoluteContainer.GetChildListName() == aListName) {
   1:     rv = mAbsoluteContainer.AppendFrames(this, aListName, aFrameList);
   1:   } else {
   1:     rv = nsInlineFrame::AppendFrames(aListName, aFrameList);
   1:   }
   1: 
   1:   return rv;
   1: }
   1:   
   1: NS_IMETHODIMP
   1: nsPositionedInlineFrame::InsertFrames(nsIAtom*        aListName,
   1:                                       nsIFrame*       aPrevFrame,
   1:                                       nsIFrame*       aFrameList)
   1: {
   1:   nsresult  rv;
   1: 
   1:   if (mAbsoluteContainer.GetChildListName() == aListName) {
   1:     rv = mAbsoluteContainer.InsertFrames(this, aListName, aPrevFrame,
   1:                                          aFrameList);
   1:   } else {
   1:     rv = nsInlineFrame::InsertFrames(aListName, aPrevFrame, aFrameList);
   1:   }
   1: 
   1:   return rv;
   1: }
   1:   
   1: NS_IMETHODIMP
   1: nsPositionedInlineFrame::RemoveFrame(nsIAtom*        aListName,
   1:                                      nsIFrame*       aOldFrame)
   1: {
   1:   nsresult  rv;
   1: 
   1:   if (mAbsoluteContainer.GetChildListName() == aListName) {
   1:     rv = mAbsoluteContainer.RemoveFrame(this, aListName, aOldFrame);
   1:   } else {
   1:     rv = nsInlineFrame::RemoveFrame(aListName, aOldFrame);
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsPositionedInlineFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                                           const nsRect&           aDirtyRect,
   1:                                           const nsDisplayListSet& aLists)
   1: {
   1:   aBuilder->MarkFramesForDisplayList(this, mAbsoluteContainer.GetFirstChild(), aDirtyRect);
   1:   return nsHTMLContainerFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
   1: }
   1: 
   1: nsIAtom*
   1: nsPositionedInlineFrame::GetAdditionalChildListName(PRInt32 aIndex) const
   1: {
   1:   if (0 == aIndex) {
   1:     return mAbsoluteContainer.GetChildListName();
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: nsIFrame*
   1: nsPositionedInlineFrame::GetFirstChild(nsIAtom* aListName) const
   1: {
   1:   if (mAbsoluteContainer.GetChildListName() == aListName) {
   1:     nsIFrame* result = nsnull;
   1:     mAbsoluteContainer.FirstChild(this, aListName, &result);
   1:     return result;
   1:   }
   1: 
   1:   return nsInlineFrame::GetFirstChild(aListName);
   1: }
   1: 
   1: nsIAtom*
   1: nsPositionedInlineFrame::GetType() const
   1: {
   1:   return nsGkAtoms::positionedInlineFrame;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsPositionedInlineFrame::Reflow(nsPresContext*          aPresContext,
   1:                                 nsHTMLReflowMetrics&     aDesiredSize,
   1:                                 const nsHTMLReflowState& aReflowState,
   1:                                 nsReflowStatus&          aStatus)
   1: {
   1:   nsresult  rv = NS_OK;
   1: 
   1:   // Don't bother optimizing for fast incremental reflow of absolute
   1:   // children of an inline
   1: 
   1:   // Let the inline frame do its reflow first
   1:   rv = nsInlineFrame::Reflow(aPresContext, aDesiredSize, aReflowState, aStatus);
   1: 
   1:   // Let the absolutely positioned container reflow any absolutely positioned
   1:   // child frames that need to be reflowed
   1:   // We want to do this under either of two conditions:
   1:   //  1. If we didn't do the incremental reflow above.
   1:   //  2. If our size changed.
   1:   // Even though it's the padding edge that's the containing block, we
   1:   // can use our rect (the border edge) since if the border style
   1:   // changed, the reflow would have been targeted at us so we'd satisfy
   1:   // condition 1.
   1:   if (NS_SUCCEEDED(rv) &&
   1:       mAbsoluteContainer.HasAbsoluteFrames()) {
   1:     // The containing block for the abs pos kids is formed by our padding edge.
   1:     nsMargin computedBorder =
   1:       aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
   1:     nscoord containingBlockWidth =
   1:       aDesiredSize.width - computedBorder.LeftRight();
   1:     nscoord containingBlockHeight =
   1:       aDesiredSize.height - computedBorder.TopBottom();
   1: 
   1:     // Factor the absolutely positioned child bounds into the overflow area
   1:     // Don't include this frame's bounds, nor its inline descendants' bounds,
   1:     // and don't store the overflow property.
   1:     // That will all be done by nsLineLayout::RelativePositionFrames.
   1:     rv = mAbsoluteContainer.Reflow(this, aPresContext, aReflowState,
   1:                                    containingBlockWidth, containingBlockHeight,
   1:                                    PR_TRUE, PR_TRUE, // XXX could be optimized
   1:                                    &aDesiredSize.mOverflowArea);
   1:   }
   1: 
   1:   return rv;
   1: }
