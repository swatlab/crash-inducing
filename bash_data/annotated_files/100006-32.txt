     1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef jsopcode_h___
     1: #define jsopcode_h___
 84755: 
     1: /*
     1:  * JS bytecode definitions.
     1:  */
     1: #include <stddef.h>
     1: #include "jsprvtd.h"
     1: #include "jspubtd.h"
     1: #include "jsutil.h"
     1: 
     1: JS_BEGIN_EXTERN_C
     1: 
     1: /*
     1:  * JS operation bytecodes.
     1:  */
     1: typedef enum JSOp {
     1: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
     1:     op = val,
     1: #include "jsopcode.tbl"
     1: #undef OPDEF
 58070:     JSOP_LIMIT,
 58070: 
 58070:     /*
 74052:      * These pseudo-ops help js_DecompileValueGenerator decompile JSOP_SETPROP,
 74052:      * JSOP_SETELEM, and comprehension-tails, respectively.  They are never
 74052:      * stored in bytecode, so they don't preempt valid opcodes.
 58070:      */
 58070:     JSOP_GETPROP2 = JSOP_LIMIT,
 58070:     JSOP_GETELEM2 = JSOP_LIMIT + 1,
 74052:     JSOP_FORLOCAL = JSOP_LIMIT + 2,
 74052:     JSOP_FAKE_LIMIT = JSOP_FORLOCAL
     1: } JSOp;
     1: 
     1: /*
     1:  * JS bytecode formats.
     1:  */
     1: #define JOF_BYTE          0       /* single bytecode, no immediates */
     1: #define JOF_JUMP          1       /* signed 16-bit jump offset immediate */
 27012: #define JOF_ATOM          2       /* unsigned 16-bit constant index */
     1: #define JOF_UINT16        3       /* unsigned 16-bit immediate operand */
     1: #define JOF_TABLESWITCH   4       /* table switch */
     1: #define JOF_LOOKUPSWITCH  5       /* lookup switch */
     1: #define JOF_QARG          6       /* quickened get/set function argument ops */
 16429: #define JOF_LOCAL         7       /* var or block-local variable */
 90965: #define JOF_DOUBLE        8       /* uint32_t index for double value */
     1: #define JOF_UINT24        12      /* extended unsigned 24-bit literal (index) */
 84755: #define JOF_UINT8         13      /* uint8_t immediate, e.g. top 8 bits of 24-bit
     1:                                      atom index */
 84755: #define JOF_INT32         14      /* int32_t immediate operand */
 27012: #define JOF_OBJECT        15      /* unsigned 16-bit object index */
 84755: #define JOF_SLOTOBJECT    16      /* uint16_t slot index + object index */
 87976: #define JOF_REGEXP        17      /* unsigned 32-bit regexp index */
 84755: #define JOF_INT8          18      /* int8_t immediate operand */
 84755: #define JOF_ATOMOBJECT    19      /* uint16_t constant index + object index */
 84755: #define JOF_UINT16PAIR    20      /* pair of uint16_t immediates */
100006: #define JOF_SCOPECOORD    21      /* pair of uint16_t immediates followed by atom index */
  3235: #define JOF_TYPEMASK      0x001f  /* mask for above immediate types */
  3328: 
  3235: #define JOF_NAME          (1U<<5) /* name operation */
  3235: #define JOF_PROP          (2U<<5) /* obj.prop operation */
  3235: #define JOF_ELEM          (3U<<5) /* obj[index] operation */
  3235: #define JOF_XMLNAME       (4U<<5) /* XML name: *, a::b, @a, @a::b, etc. */
  3235: #define JOF_MODEMASK      (7U<<5) /* mask for above addressing modes */
  3235: #define JOF_SET           (1U<<8) /* set (i.e., assignment) operation */
  3235: #define JOF_DEL           (1U<<9) /* delete operation */
  3235: #define JOF_DEC          (1U<<10) /* decrement (--, not ++) opcode */
  3235: #define JOF_INC          (2U<<10) /* increment (++, not --) opcode */
  3235: #define JOF_INCDEC       (3U<<10) /* increment or decrement opcode */
  3235: #define JOF_POST         (1U<<12) /* postorder increment or decrement */
 48470: #define JOF_ASSIGNING     JOF_SET /* hint for Class.resolve, used for ops
     1:                                      that do simplex assignment */
 16489: #define JOF_DETECTING    (1U<<14) /* object detection for JSNewResolveOp */
 16489: #define JOF_BACKPATCH    (1U<<15) /* backpatch placeholder during codegen */
 16489: #define JOF_LEFTASSOC    (1U<<16) /* left-associative operator */
 16489: #define JOF_DECLARING    (1U<<17) /* var, const, or function declaration op */
 90965: /* (1U<<18) is unused */
 16489: #define JOF_PARENHEAD    (1U<<20) /* opcode consumes value of expression in
  1577:                                      parenthesized statement head */
 16489: #define JOF_INVOKE       (1U<<21) /* JSOP_CALL, JSOP_NEW, JSOP_EVAL */
 16489: #define JOF_TMPSLOT      (1U<<22) /* interpreter uses extra temporary slot
 12611:                                      to root intermediate objects besides
 12611:                                      the slots opcode uses */
 16489: #define JOF_TMPSLOT2     (2U<<22) /* interpreter uses extra 2 temporary slot
 12611:                                      besides the slots opcode uses */
 52909: #define JOF_TMPSLOT3     (3U<<22) /* interpreter uses extra 3 temporary slot
 52909:                                      besides the slots opcode uses */
 16489: #define JOF_TMPSLOT_SHIFT 22
 12611: #define JOF_TMPSLOT_MASK  (JS_BITMASK(2) << JOF_TMPSLOT_SHIFT)
     1: 
 88137: /* (1U<<24) is unused */
 52825: #define JOF_GNAME        (1U<<25) /* predicted global name */
 77391: #define JOF_TYPESET      (1U<<26) /* has an entry in a script's type sets */
 77357: #define JOF_DECOMPOSE    (1U<<27) /* followed by an equivalent decomposed
 77357:                                    * version of the opcode */
 82134: #define JOF_ARITH        (1U<<28) /* unary or binary arithmetic opcode */
 32729: 
 11377: /* Shorthands for type from format and type from opcode. */
 11377: #define JOF_TYPE(fmt)   ((fmt) & JOF_TYPEMASK)
 11377: #define JOF_OPTYPE(op)  JOF_TYPE(js_CodeSpec[op].format)
 11377: 
  1761: /* Shorthands for mode from format and mode from opcode. */
  1761: #define JOF_MODE(fmt)   ((fmt) & JOF_MODEMASK)
  1761: #define JOF_OPMODE(op)  JOF_MODE(js_CodeSpec[op].format)
  1761: 
     1: #define JOF_TYPE_IS_EXTENDED_JUMP(t) \
 86877:     ((unsigned)((t) - JOF_JUMP) <= (unsigned)(JOF_LOOKUPSWITCH - JOF_JUMP))
     1: 
     1: /*
     1:  * Immediate operand getters, setters, and bounds.
     1:  */
     1: 
 87974: static JS_ALWAYS_INLINE uint8_t
 87974: GET_UINT8(jsbytecode *pc)
 87974: {
 87974:     return (uint8_t) pc[1];
 87974: }
 87974: 
 87974: static JS_ALWAYS_INLINE void
 87974: SET_UINT8(jsbytecode *pc, uint8_t u)
 87974: {
 87974:     pc[1] = (jsbytecode) u;
 87974: }
 87974: 
 84755: /* Common uint16_t immediate format helpers. */
     1: #define UINT16_LEN              2
     1: #define UINT16_HI(i)            ((jsbytecode)((i) >> 8))
     1: #define UINT16_LO(i)            ((jsbytecode)(i))
 91237: #define GET_UINT16(pc)          ((unsigned)(((pc)[1] << 8) | (pc)[2]))
     1: #define SET_UINT16(pc,i)        ((pc)[1] = UINT16_HI(i), (pc)[2] = UINT16_LO(i))
 91237: #define UINT16_LIMIT            ((unsigned)1 << 16)
     1: 
 86877: /* Helpers for accessing the offsets of jump opcodes. */
 86877: #define JUMP_OFFSET_LEN         4
 86877: #define JUMP_OFFSET_MIN         INT32_MIN
 86877: #define JUMP_OFFSET_MAX         INT32_MAX
     1: 
 86877: static JS_ALWAYS_INLINE int32_t
 86877: GET_JUMP_OFFSET(jsbytecode *pc)
 86877: {
 86877:     return (pc[1] << 24) | (pc[2] << 16) | (pc[3] << 8) | pc[4];
 86877: }
     1: 
 86877: static JS_ALWAYS_INLINE void
 86877: SET_JUMP_OFFSET(jsbytecode *pc, int32_t off)
 86877: {
 86877:     pc[1] = (jsbytecode)(off >> 24);
 86877:     pc[2] = (jsbytecode)(off >> 16);
 86877:     pc[3] = (jsbytecode)(off >> 8);
 86877:     pc[4] = (jsbytecode)off;
 86877: }
     1: 
 87976: #define UINT32_INDEX_LEN        4
 87976: 
 87976: static JS_ALWAYS_INLINE uint32_t
 90965: GET_UINT32_INDEX(const jsbytecode *pc)
 87976: {
 87976:     return (pc[1] << 24) | (pc[2] << 16) | (pc[3] << 8) | pc[4];
 87976: }
 87976: 
 87976: static JS_ALWAYS_INLINE void
 87976: SET_UINT32_INDEX(jsbytecode *pc, uint32_t index)
 87976: {
 87976:     pc[1] = (jsbytecode)(index >> 24);
 87976:     pc[2] = (jsbytecode)(index >> 16);
 87976:     pc[3] = (jsbytecode)(index >> 8);
 87976:     pc[4] = (jsbytecode)index;
 87976: }
 87976: 
     1: #define UINT24_HI(i)            ((jsbytecode)((i) >> 16))
     1: #define UINT24_MID(i)           ((jsbytecode)((i) >> 8))
     1: #define UINT24_LO(i)            ((jsbytecode)(i))
     1: #define GET_UINT24(pc)          ((jsatomid)(((pc)[1] << 16) |                 \
     1:                                             ((pc)[2] << 8) |                  \
     1:                                             (pc)[3]))
     1: #define SET_UINT24(pc,i)        ((pc)[1] = UINT24_HI(i),                      \
     1:                                  (pc)[2] = UINT24_MID(i),                     \
     1:                                  (pc)[3] = UINT24_LO(i))
     1: 
 91450: #define GET_INT8(pc)            (int8_t((pc)[1]))
  3328: 
 91450: #define GET_INT32(pc)           (((uint32_t((pc)[1]) << 24) |                 \
 84755:                                   (uint32_t((pc)[2]) << 16) |                 \
 84755:                                   (uint32_t((pc)[3]) << 8)  |                 \
 84755:                                   uint32_t((pc)[4])))
 84755: #define SET_INT32(pc,i)         ((pc)[1] = (jsbytecode)(uint32_t(i) >> 24),   \
 84755:                                  (pc)[2] = (jsbytecode)(uint32_t(i) >> 16),   \
 84755:                                  (pc)[3] = (jsbytecode)(uint32_t(i) >> 8),    \
 84755:                                  (pc)[4] = (jsbytecode)uint32_t(i))
  3328: 
 80964: /* Index limit is determined by SN_3BYTE_OFFSET_FLAG, see frontend/BytecodeEmitter.h. */
  3235: #define INDEX_LIMIT_LOG2        23
 84755: #define INDEX_LIMIT             (uint32_t(1) << INDEX_LIMIT_LOG2)
     1: 
     1: /* Actual argument count operand format helpers. */
     1: #define ARGC_HI(argc)           UINT16_HI(argc)
     1: #define ARGC_LO(argc)           UINT16_LO(argc)
     1: #define GET_ARGC(pc)            GET_UINT16(pc)
     1: #define ARGC_LIMIT              UINT16_LIMIT
     1: 
 16429: /* Synonyms for quick JOF_QARG and JOF_LOCAL bytecodes. */
     1: #define GET_ARGNO(pc)           GET_UINT16(pc)
     1: #define SET_ARGNO(pc,argno)     SET_UINT16(pc,argno)
     1: #define ARGNO_LEN               2
     1: #define ARGNO_LIMIT             UINT16_LIMIT
     1: 
 16072: #define GET_SLOTNO(pc)          GET_UINT16(pc)
 16072: #define SET_SLOTNO(pc,varno)    SET_UINT16(pc,varno)
 16072: #define SLOTNO_LEN              2
 16072: #define SLOTNO_LIMIT            UINT16_LIMIT
     1: 
     1: struct JSCodeSpec {
 84755:     int8_t              length;         /* length including opcode byte */
 84755:     int8_t              nuses;          /* arity, -1 if variadic */
 84755:     int8_t              ndefs;          /* number of stack results */
 84755:     uint8_t             prec;           /* operator precedence */
 84755:     uint32_t            format;         /* immediate operand format */
 52555: 
 84755:     uint32_t type() const { return JOF_TYPE(format); }
     1: };
     1: 
     1: extern const JSCodeSpec js_CodeSpec[];
 91237: extern unsigned            js_NumCodeSpecs;
 12410: extern const char       *js_CodeName[];
     1: extern const char       js_EscapeMap[];
     1: 
 39928: /* Silence unreferenced formal parameter warnings */
 39928: #ifdef _MSC_VER
 39928: #pragma warning(push)
 39928: #pragma warning(disable:4100)
 39928: #endif
 39928: 
     1: /*
     1:  * Return a GC'ed string containing the chars in str, with any non-printing
     1:  * chars or quotes (' or " as specified by the quote argument) escaped, and
     1:  * with the quote character at the beginning and end of the result string.
     1:  */
     1: extern JSString *
     1: js_QuoteString(JSContext *cx, JSString *str, jschar quote);
     1: 
     1: /*
     1:  * JSPrinter operations, for printf style message formatting.  The return
     1:  * value from js_GetPrinterOutput() is the printer's cumulative output, in
     1:  * a GC'ed string.
 35113:  *
 35113:  * strict is true if the context in which the output will appear has
 35113:  * already been marked as strict, thus indicating that nested
 35113:  * functions need not be re-marked with a strict directive.  It should
 35113:  * be false in the outermost printer.
     1:  */
   437: 
     1: extern JSPrinter *
 35112: js_NewPrinter(JSContext *cx, const char *name, JSFunction *fun,
 91237:               unsigned indent, JSBool pretty, JSBool grouped, JSBool strict);
     1: 
 61225: extern void
     1: js_DestroyPrinter(JSPrinter *jp);
     1: 
     1: extern JSString *
     1: js_GetPrinterOutput(JSPrinter *jp);
     1: 
     1: extern int
     1: js_printf(JSPrinter *jp, const char *format, ...);
     1: 
     1: extern JSBool
     1: js_puts(JSPrinter *jp, const char *s);
     1: 
  3235: #define GET_ATOM_FROM_BYTECODE(script, pc, pcoff, atom)                       \
  3235:     JS_BEGIN_MACRO                                                            \
 86542:         JS_ASSERT(js_CodeSpec[*(pc)].format & JOF_ATOM);                      \
 90965:         (atom) = (script)->getAtom(GET_UINT32_INDEX((pc) + (pcoff)));         \
 32673:     JS_END_MACRO
 32673: 
 86542: #define GET_NAME_FROM_BYTECODE(script, pc, pcoff, name)                       \
 86542:     JS_BEGIN_MACRO                                                            \
 86542:         JSAtom *atom_;                                                        \
 86542:         GET_ATOM_FROM_BYTECODE(script, pc, pcoff, atom_);                     \
 86542:         JS_ASSERT(js_CodeSpec[*(pc)].format & (JOF_NAME | JOF_PROP));         \
 86542:         (name) = atom_->asPropertyName();                                     \
 86542:     JS_END_MACRO
 86542: 
 86078: namespace js {
 86078: 
 91237: extern unsigned
 86078: StackUses(JSScript *script, jsbytecode *pc);
 26729: 
 91237: extern unsigned
 86078: StackDefs(JSScript *script, jsbytecode *pc);
 26729: 
 86078: }  /* namespace js */
 18567: 
     1: /*
     1:  * Decompilers, for script, function, and expression pretty-printing.
     1:  */
     1: extern JSBool
     1: js_DecompileScript(JSPrinter *jp, JSScript *script);
     1: 
 34364: extern JSBool
 13702: js_DecompileFunctionBody(JSPrinter *jp);
     1: 
 34364: extern JSBool
 13702: js_DecompileFunction(JSPrinter *jp);
     1: 
 35379: /*
 35379:  * Some C++ compilers treat the language linkage (extern "C" vs.
 35379:  * extern "C++") as part of function (and thus pointer-to-function)
 35379:  * types. The use of this typedef (defined in "C") ensures that
 35379:  * js_DecompileToString's definition (in "C++") gets matched up with
 35379:  * this declaration.
 35379:  */
 35378: typedef JSBool (* JSDecompilerPtr)(JSPrinter *);
 35378: 
 35040: extern JSString *
 35040: js_DecompileToString(JSContext *cx, const char *name, JSFunction *fun,
 91237:                      unsigned indent, JSBool pretty, JSBool grouped, JSBool strict,
 35378:                      JSDecompilerPtr decompiler);
 35040: 
     1: /*
     1:  * Find the source expression that resulted in v, and return a newly allocated
     1:  * C-string containing it.  Fall back on v's string conversion (fallback) if we
     1:  * can't find the bytecode that generated and pushed v on the operand stack.
     1:  *
     1:  * Search the current stack frame if spindex is JSDVG_SEARCH_STACK.  Don't
     1:  * look for v on the stack if spindex is JSDVG_IGNORE_STACK.  Otherwise,
     1:  * spindex is the negative index of v, measured from cx->fp->sp, or from a
     1:  * lower frame's sp if cx->fp is native.
     1:  *
     1:  * The caller must call JS_free on the result after a succsesful call.
     1:  */
     1: extern char *
 91237: js_DecompileValueGenerator(JSContext *cx, int spindex, jsval v,
     1:                            JSString *fallback);
     1: 
 75501: /*
 75501:  * Given bytecode address pc in script's main program code, return the operand
 75501:  * stack depth just before (JSOp) *pc executes.
 75501:  */
 91237: extern unsigned
 75501: js_ReconstructStackDepth(JSContext *cx, JSScript *script, jsbytecode *pc);
 75501: 
 75501: #ifdef _MSC_VER
 75501: #pragma warning(pop)
 75501: #endif
 75501: 
 75501: JS_END_EXTERN_C
 75501: 
     1: #define JSDVG_IGNORE_STACK      0
     1: #define JSDVG_SEARCH_STACK      1
     1: 
 75501: /*
 75501:  * Get the length of variable-length bytecode like JSOP_TABLESWITCH.
 75501:  */
 75501: extern size_t
 84195: js_GetVariableBytecodeLength(jsbytecode *pc);
 75501: 
 48470: namespace js {
 48470: 
 48470: static inline char *
 91237: DecompileValueGenerator(JSContext *cx, int spindex, const Value &v,
 48470:                         JSString *fallback)
 48470: {
 78614:     return js_DecompileValueGenerator(cx, spindex, v, fallback);
 48470: }
 48470: 
 64374: /*
 64374:  * Sprintf, but with unlimited and automatically allocated buffering.
 64374:  */
 87952: class Sprinter
 87952: {
 87952:   public:
 87952:     struct InvariantChecker
 87952:     {
 87952:         const Sprinter *parent;
 87952: 
 87952:         explicit InvariantChecker(const Sprinter *p) : parent(p) {
 87952:             parent->checkInvariants();
 87952:         }
 87952: 
 87952:         ~InvariantChecker() {
 87952:             parent->checkInvariants();
 87952:         }
 87952:     };
 87952: 
 64374:     JSContext               *context;       /* context executing the decompiler */
 87952: 
 87952:   private:
 87952:     static const size_t     DefaultSize;
 87952: #ifdef DEBUG
 87952:     bool                    initialized;    /* true if this is initialized, use for debug builds */
 87952: #endif
 87952:     char                    *base;          /* malloc'd buffer address */
 64374:     size_t                  size;           /* size of buffer allocated at base */
 64374:     ptrdiff_t               offset;         /* offset of next free char in buffer */
 64374: 
 87952:     bool realloc_(size_t newSize);
 87952: 
 87952:   public:
 87952:     explicit Sprinter(JSContext *cx);
 87952:     ~Sprinter();
 87952: 
 87952:     /* Initialize this sprinter, returns false on error */
 87952:     bool init();
 87952: 
 87952:     void checkInvariants() const;
 87952: 
 87952:     const char *string() const;
 87952:     const char *stringEnd() const;
 87952:     /* Returns the string at offset |off| */
 87952:     char *stringAt(ptrdiff_t off) const;
 87952:     /* Returns the char at offset |off| */
 87952:     char &operator[](size_t off);
 87952:     /* Test if this Sprinter is empty */
 87952:     bool empty() const;
 64374: 
 64374:     /*
 87952:      * Attempt to reserve len + 1 space (for a trailing NULL byte). If the
 64374:      * attempt succeeds, return a pointer to the start of that space and adjust the
 87952:      * internal content. The caller *must* completely fill this space on success.
 64374:      */
 87952:     char *reserve(size_t len);
 87952:     /* Like reserve, but memory is initialized to 0 */
 87952:     char *reserveAndClear(size_t len);
 87952: 
 87952:     /*
 87952:      * Puts |len| characters from |s| at the current position and return an offset to
 87952:      * the beginning of this new data
 87952:      */
 87952:     ptrdiff_t put(const char *s, size_t len);
 90229:     ptrdiff_t put(const char *s);
 87952:     ptrdiff_t putString(JSString *str);
 87952: 
 87952:     /* Prints a formatted string into the buffer */
 87952:     int printf(const char *fmt, ...);
 87952: 
 87952:     /* Change the offset */
 87952:     void setOffset(const char *end);
 87952:     void setOffset(ptrdiff_t off);
 87952: 
 87952:     /* Get the offset */
 87952:     ptrdiff_t getOffset() const;
 87952:     ptrdiff_t getOffsetOf(const char *string) const;
 87952: };
 64374: 
 64374: extern ptrdiff_t
 64374: Sprint(Sprinter *sp, const char *format, ...);
 64374: 
 64556: extern bool
 64556: CallResultEscapes(jsbytecode *pc);
 64556: 
 91237: static inline unsigned
 77358: GetDecomposeLength(jsbytecode *pc, size_t len)
 77357: {
 77358:     /*
 90965:      * The last byte of a DECOMPOSE op stores the decomposed length.  This is a
 90965:      * constant: perhaps we should just hardcode values instead?
 77358:      */
 84195:     JS_ASSERT(size_t(js_CodeSpec[*pc].length) == len);
 91237:     return (unsigned) pc[len - 1];
 77357: }
 77357: 
 91237: static inline unsigned
 84195: GetBytecodeLength(jsbytecode *pc)
 84195: {
 84195:     JSOp op = (JSOp)*pc;
 84195:     JS_ASSERT(op < JSOP_LIMIT);
 84195: 
 84195:     if (js_CodeSpec[op].length != -1)
 84195:         return js_CodeSpec[op].length;
 84195:     return js_GetVariableBytecodeLength(pc);
 84195: }
 75501: 
 75501: extern bool
 75501: IsValidBytecodeOffset(JSContext *cx, JSScript *script, size_t offset);
 75501: 
 75504: inline bool
 75504: FlowsIntoNext(JSOp op)
 75504: {
 76343:     /* JSOP_YIELD is considered to flow into the next instruction, like JSOP_CALL. */
 75504:     return op != JSOP_STOP && op != JSOP_RETURN && op != JSOP_RETRVAL && op != JSOP_THROW &&
 86877:            op != JSOP_GOTO && op != JSOP_RETSUB;
 75504: }
 75504: 
 79778: /*
 82134:  * Counts accumulated for a single opcode in a script. The counts tracked vary
 94574:  * between opcodes, and this structure ensures that counts are accessed in a
 94574:  * coherent fashion.
 82134:  */
 94574: class PCCounts
 82134: {
 82134:     friend struct ::JSScript;
 82134:     double *counts;
 82134: #ifdef DEBUG
 82134:     size_t capacity;
 82134: #endif
 82134: 
 82134:  public:
 82134: 
 82134:     enum BaseCounts {
 82134:         BASE_INTERP = 0,
 82134:         BASE_METHODJIT,
 82134: 
 82134:         BASE_METHODJIT_STUBS,
 82134:         BASE_METHODJIT_CODE,
 82134:         BASE_METHODJIT_PICS,
 82134: 
 94574:         BASE_LIMIT
 82134:     };
 82134: 
 82134:     enum AccessCounts {
 94574:         ACCESS_MONOMORPHIC = BASE_LIMIT,
 82134:         ACCESS_DIMORPHIC,
 82134:         ACCESS_POLYMORPHIC,
 82134: 
 82134:         ACCESS_BARRIER,
 82134:         ACCESS_NOBARRIER,
 82134: 
 82134:         ACCESS_UNDEFINED,
 82134:         ACCESS_NULL,
 82134:         ACCESS_BOOLEAN,
 82134:         ACCESS_INT32,
 82134:         ACCESS_DOUBLE,
 82134:         ACCESS_STRING,
 82134:         ACCESS_OBJECT,
 82134: 
 94574:         ACCESS_LIMIT
 82134:     };
 82134: 
 82134:     static bool accessOp(JSOp op) {
 82134:         /*
 82134:          * Access ops include all name, element and property reads, as well as
 82134:          * SETELEM and SETPROP (for ElementCounts/PropertyCounts alignment).
 82134:          */
 94227:         if (op == JSOP_SETELEM || op == JSOP_SETPROP)
 82134:             return true;
 82134:         int format = js_CodeSpec[op].format;
 82134:         return !!(format & (JOF_NAME | JOF_GNAME | JOF_ELEM | JOF_PROP))
 82134:             && !(format & (JOF_SET | JOF_INCDEC));
 48470:     }
 82134: 
 82134:     enum ElementCounts {
 94574:         ELEM_ID_INT = ACCESS_LIMIT,
 82134:         ELEM_ID_DOUBLE,
 82134:         ELEM_ID_OTHER,
 82134:         ELEM_ID_UNKNOWN,
 82134: 
 82134:         ELEM_OBJECT_TYPED,
 82134:         ELEM_OBJECT_PACKED,
 82134:         ELEM_OBJECT_DENSE,
 82134:         ELEM_OBJECT_OTHER,
 82134: 
 94574:         ELEM_LIMIT
 82134:     };
 82134: 
 82134:     static bool elementOp(JSOp op) {
 87262:         return accessOp(op) && (JOF_MODE(js_CodeSpec[op].format) == JOF_ELEM);
 82134:     }
 82134: 
 82134:     enum PropertyCounts {
 94574:         PROP_STATIC = ACCESS_LIMIT,
 82134:         PROP_DEFINITE,
 82134:         PROP_OTHER,
 82134: 
 94574:         PROP_LIMIT
 82134:     };
 82134: 
 82134:     static bool propertyOp(JSOp op) {
 87262:         return accessOp(op) && (JOF_MODE(js_CodeSpec[op].format) == JOF_PROP);
 82134:     }
 82134: 
 82134:     enum ArithCounts {
 94574:         ARITH_INT = BASE_LIMIT,
 82134:         ARITH_DOUBLE,
 82134:         ARITH_OTHER,
 82134:         ARITH_UNKNOWN,
 82134: 
 94574:         ARITH_LIMIT
 82134:     };
 82134: 
 82134:     static bool arithOp(JSOp op) {
 82134:         return !!(js_CodeSpec[op].format & (JOF_INCDEC | JOF_ARITH));
 82134:     }
 82134: 
 82134:     static size_t numCounts(JSOp op)
 82134:     {
 82134:         if (accessOp(op)) {
 82134:             if (elementOp(op))
 94574:                 return ELEM_LIMIT;
 82134:             if (propertyOp(op))
 94574:                 return PROP_LIMIT;
 94574:             return ACCESS_LIMIT;
 82134:         }
 82134:         if (arithOp(op))
 94574:             return ARITH_LIMIT;
 94574:         return BASE_LIMIT;
 82134:     }
 82134: 
 82134:     static const char *countName(JSOp op, size_t which);
 82134: 
 82134:     double *rawCounts() { return counts; }
 82134: 
 82134:     double& get(size_t which) {
 82134:         JS_ASSERT(which < capacity);
 82134:         return counts[which];
 82134:     }
 84803: 
 86887:     /* Boolean conversion, for 'if (counters) ...' */
 84803:     operator void*() const {
 84803:         return counts;
 84803:     }
 82134: };
 82134: 
 82134: } /* namespace js */
 48470: 
 89372: #if defined(DEBUG)
 64374: /*
 64374:  * Disassemblers, for debugging only.
 64374:  */
 64374: extern JS_FRIEND_API(JSBool)
 71699: js_Disassemble(JSContext *cx, JSScript *script, JSBool lines, js::Sprinter *sp);
 64374: 
 91237: extern JS_FRIEND_API(unsigned)
 91237: js_Disassemble1(JSContext *cx, JSScript *script, jsbytecode *pc, unsigned loc,
 71699:                 JSBool lines, js::Sprinter *sp);
 82134: 
 82134: extern JS_FRIEND_API(void)
 82134: js_DumpPCCounts(JSContext *cx, JSScript *script, js::Sprinter *sp);
 69852: #endif
 64374: 
     1: #endif /* jsopcode_h___ */
