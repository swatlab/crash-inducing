    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Makoto Kato  <m_kato@ga2.so-net.ne.jp>
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Ginn Chen <ginn.chen@sun.com>
    1:  *   Simon BÃ¼nzli <zeniko@gmail.com>
15065:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
24836:  *   Ningjie Chen <chenn@email.uc.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
54603: #include "mozilla/dom/TabParent.h"
50731: 
    1: #include "nsCOMPtr.h"
    1: #include "nsEventStateManager.h"
    1: #include "nsEventListenerManager.h"
    1: #include "nsIMEStateManager.h"
24836: #include "nsContentEventHandler.h"
    1: #include "nsIContent.h"
94340: #include "nsINodeInfo.h"
    1: #include "nsIDocument.h"
    1: #include "nsIFrame.h"
    1: #include "nsIWidget.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsDOMEvent.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIEditorDocShell.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIComboboxControlFrame.h"
31443: #include "nsIScrollableFrame.h"
81041: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMXULControlElement.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsISelection.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsPIDOMWindow.h"
38336: #include "nsPIWindowRoot.h"
    1: #include "nsIEnumerator.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeNode.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIContentViewer.h"
 5298: #ifdef MOZ_XUL
 4709: #include "nsXULPopupManager.h"
 5298: #endif
37058: #include "nsFrameManager.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIScriptSecurityManager.h"
    1: 
29018: #include "nsFocusManager.h"
    1: 
    1: #include "nsIDOMXULElement.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMKeyEvent.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIMarkupDocumentViewer.h"
19319: #include "nsIDOMMouseScrollEvent.h"
18445: #include "nsIDOMDragEvent.h"
    1: #include "nsIDOMEventTarget.h"
77226: #include "nsIDOMUIEvent.h"
18445: #include "nsDOMDragEvent.h"
19703: #include "nsIDOMNSEditableElement.h"
    1: 
15969: #include "nsCaret.h"
    1: 
51754: #include "nsSubDocumentFrame.h"
    1: #include "nsIFrameTraversal.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsContentUtils.h"
    1: 
    1: #include "imgIContainer.h"
    1: #include "nsIProperties.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsEventDispatcher.h"
    1: 
 7093: #include "nsServiceManagerUtils.h"
 7093: #include "nsITimer.h"
68493: #include "nsFontMetrics.h"
23192: #include "nsIDOMXULDocument.h"
18445: #include "nsIDragService.h"
18445: #include "nsIDragSession.h"
18445: #include "nsDOMDataTransfer.h"
18445: #include "nsContentAreaDragDrop.h"
18445: #ifdef MOZ_XUL
20988: #include "nsTreeBodyFrame.h"
18445: #endif
31218: #include "nsIController.h"
36983: #include "nsICommandParams.h"
41540: #include "mozilla/Services.h"
64122: #include "mozAutoDocUpdate.h"
70852: #include "nsHTMLLabelElement.h"
18445: 
70840: #include "mozilla/Preferences.h"
78124: #include "mozilla/LookAndFeel.h"
84290: #include "sampler.h"
70840: 
95203: #include "nsIDOMClientRect.h"
95203: 
    1: #ifdef XP_MACOSX
32855: #import <ApplicationServices/ApplicationServices.h>
    1: #endif
    1: 
70840: using namespace mozilla;
54603: using namespace mozilla::dom;
54603: 
    1: //#define DEBUG_DOCSHELL_FOCUS
    1: 
 7093: #define NS_USER_INTERACTION_INTERVAL 5000 // ms
 7093: 
    1: static NS_DEFINE_CID(kFrameTraversalCID, NS_FRAMETRAVERSAL_CID);
    1: 
79445: static bool sLeftClickOnly = true;
79445: static bool sKeyCausesActivation = true;
    1: static PRUint32 sESMInstanceCount = 0;
    1: static PRInt32 sChromeAccessModifier = 0, sContentAccessModifier = 0;
    1: PRInt32 nsEventStateManager::sUserInputEventDepth = 0;
79445: bool nsEventStateManager::sNormalLMouseEventInProcess = false;
54151: nsEventStateManager* nsEventStateManager::sActiveESM = nsnull;
54257: nsIDocument* nsEventStateManager::sMouseOverDocument = nsnull;
79435: nsWeakFrame nsEventStateManager::sLastDragOverFrame = nsnull;
95203: nsIntPoint nsEventStateManager::sLastRefPoint = nsIntPoint(0,0);
95203: nsIntPoint nsEventStateManager::sLastScreenOffset = nsIntPoint(0,0);
95203: nsIntPoint nsEventStateManager::sLastScreenPoint = nsIntPoint(0,0);
95203: nsIntPoint nsEventStateManager::sLastClientPoint = nsIntPoint(0,0);
95203: bool nsEventStateManager::sIsPointerLocked = false;
95203: // Reference to the pointer locked element.
95203: nsWeakPtr nsEventStateManager::sPointerLockedElement;
95203: // Reference to the document which requested pointer lock.
95203: nsWeakPtr nsEventStateManager::sPointerLockedDoc;
79435: nsCOMPtr<nsIContent> nsEventStateManager::sDragOverContent = nsnull;
    1: 
 7093: static PRUint32 gMouseOrKeyboardEventCounter = 0;
 7093: static nsITimer* gUserInteractionTimer = nsnull;
 7093: static nsITimerCallback* gUserInteractionTimerCallback = nsnull;
 7093: 
26874: // Pixel scroll accumulation for synthetic line scrolls
26874: static nscoord gPixelScrollDeltaX = 0;
26874: static nscoord gPixelScrollDeltaY = 0;
26874: static PRUint32 gPixelScrollDeltaTimeout = 0;
26874: 
26874: static nscoord
37061: GetScrollableLineHeight(nsIFrame* aTargetFrame);
26874: 
77930: TimeStamp nsEventStateManager::sHandlingInputStart;
77930: 
79445: static inline bool
39761: IsMouseEventReal(nsEvent* aEvent)
39761: {
42296:   NS_ABORT_IF_FALSE(NS_IS_MOUSE_EVENT_STRUCT(aEvent), "Not a mouse event");
39761:   // Return true if not synthesized.
39761:   return static_cast<nsMouseEvent*>(aEvent)->reason == nsMouseEvent::eReal;
39761: }
39761: 
21191: #ifdef DEBUG_DOCSHELL_FOCUS
21191: static void
21191: PrintDocTree(nsIDocShellTreeItem* aParentItem, int aLevel)
21191: {
21191:   for (PRInt32 i=0;i<aLevel;i++) printf("  ");
21191: 
21191:   PRInt32 childWebshellCount;
21191:   aParentItem->GetChildCount(&childWebshellCount);
21191:   nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(aParentItem));
21191:   PRInt32 type;
21191:   aParentItem->GetItemType(&type);
21191:   nsCOMPtr<nsIPresShell> presShell;
21191:   parentAsDocShell->GetPresShell(getter_AddRefs(presShell));
39823:   nsRefPtr<nsPresContext> presContext;
21191:   parentAsDocShell->GetPresContext(getter_AddRefs(presContext));
21191:   nsCOMPtr<nsIContentViewer> cv;
21191:   parentAsDocShell->GetContentViewer(getter_AddRefs(cv));
21191:   nsCOMPtr<nsIDOMDocument> domDoc;
21191:   if (cv)
21191:     cv->GetDOMDocument(getter_AddRefs(domDoc));
21191:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
73870:   nsCOMPtr<nsIDOMWindow> domwin = doc ? doc->GetWindow() : nsnull;
21191:   nsIURI* uri = doc ? doc->GetDocumentURI() : nsnull;
21191: 
21191:   printf("DS %p  Type %s  Cnt %d  Doc %p  DW %p  EM %p%c",
21191:     static_cast<void*>(parentAsDocShell.get()),
21191:     type==nsIDocShellTreeItem::typeChrome?"Chrome":"Content",
21191:     childWebshellCount, static_cast<void*>(doc.get()),
21191:     static_cast<void*>(domwin.get()),
21191:     static_cast<void*>(presContext ? presContext->EventStateManager() : nsnull),
21191:     uri ? ' ' : '\n');
21191:   if (uri) {
21191:     nsCAutoString spec;
21191:     uri->GetSpec(spec);
21191:     printf("\"%s\"\n", spec.get());
21191:   }
21191: 
21191:   if (childWebshellCount > 0) {
21191:     for (PRInt32 i = 0; i < childWebshellCount; i++) {
21191:       nsCOMPtr<nsIDocShellTreeItem> child;
21191:       aParentItem->GetChildAt(i, getter_AddRefs(child));
21191:       PrintDocTree(child, aLevel + 1);
21191:     }
21191:   }
21191: }
21191: 
21191: static void
21191: PrintDocTreeAll(nsIDocShellTreeItem* aItem)
21191: {
21191:   nsCOMPtr<nsIDocShellTreeItem> item = aItem;
21191:   for(;;) {
21191:     nsCOMPtr<nsIDocShellTreeItem> parent;
21191:     item->GetParent(getter_AddRefs(parent));
21191:     if (!parent)
21191:       break;
21191:     item = parent;
21191:   }
21191: 
21191:   PrintDocTree(item, 0);
21191: }
21191: #endif
21191: 
 7093: class nsUITimerCallback : public nsITimerCallback
 7093: {
 7093: public:
 7093:   nsUITimerCallback() : mPreviousCount(0) {}
 7093:   NS_DECL_ISUPPORTS
 7093:   NS_DECL_NSITIMERCALLBACK
 7093: private:
 7093:   PRUint32 mPreviousCount;
 7093: };
 7093: 
 7093: NS_IMPL_ISUPPORTS1(nsUITimerCallback, nsITimerCallback)
 7093: 
 7093: // If aTimer is nsnull, this method always sends "user-interaction-inactive"
 7093: // notification.
 7093: NS_IMETHODIMP
 7093: nsUITimerCallback::Notify(nsITimer* aTimer)
 7093: {
 7093:   nsCOMPtr<nsIObserverService> obs =
41540:     mozilla::services::GetObserverService();
41540:   if (!obs)
41540:     return NS_ERROR_FAILURE;
 7093:   if ((gMouseOrKeyboardEventCounter == mPreviousCount) || !aTimer) {
 7093:     gMouseOrKeyboardEventCounter = 0;
 7093:     obs->NotifyObservers(nsnull, "user-interaction-inactive", nsnull);
57074:     if (gUserInteractionTimer) {
57074:       gUserInteractionTimer->Cancel();
57074:       NS_RELEASE(gUserInteractionTimer);
57074:     }
 7093:   } else {
 7093:     obs->NotifyObservers(nsnull, "user-interaction-active", nsnull);
57074:     nsEventStateManager::UpdateUserActivityTimer();
 7093:   }
 7093:   mPreviousCount = gMouseOrKeyboardEventCounter;
 7093:   return NS_OK;
 7093: }
 7093: 
    1: enum {
    1:  MOUSE_SCROLL_N_LINES,
    1:  MOUSE_SCROLL_PAGE,
    1:  MOUSE_SCROLL_HISTORY,
11660:  MOUSE_SCROLL_ZOOM,
11660:  MOUSE_SCROLL_PIXELS
    1: };
    1: 
    1: // mask values for ui.key.chromeAccess and ui.key.contentAccess
    1: #define NS_MODIFIER_SHIFT    1
    1: #define NS_MODIFIER_CONTROL  2
    1: #define NS_MODIFIER_ALT      4
    1: #define NS_MODIFIER_META     8
    1: 
    1: static nsIDocument *
    1: GetDocumentFromWindow(nsIDOMWindow *aWindow)
    1: {
    1:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aWindow);
    1:   nsCOMPtr<nsIDocument> doc;
    1: 
    1:   if (win) {
    1:     doc = do_QueryInterface(win->GetExtantDocument());
    1:   }
    1: 
    1:   return doc;
    1: }
    1: 
    1: static PRInt32
    1: GetAccessModifierMaskFromPref(PRInt32 aItemType)
    1: {
70842:   PRInt32 accessKey = Preferences::GetInt("ui.key.generalAccessKey", -1);
    1:   switch (accessKey) {
    1:     case -1:                             break; // use the individual prefs
    1:     case nsIDOMKeyEvent::DOM_VK_SHIFT:   return NS_MODIFIER_SHIFT;
    1:     case nsIDOMKeyEvent::DOM_VK_CONTROL: return NS_MODIFIER_CONTROL;
    1:     case nsIDOMKeyEvent::DOM_VK_ALT:     return NS_MODIFIER_ALT;
    1:     case nsIDOMKeyEvent::DOM_VK_META:    return NS_MODIFIER_META;
    1:     default:                             return 0;
    1:   }
    1: 
    1:   switch (aItemType) {
    1:   case nsIDocShellTreeItem::typeChrome:
70842:     return Preferences::GetInt("ui.key.chromeAccess", 0);
    1:   case nsIDocShellTreeItem::typeContent:
70842:     return Preferences::GetInt("ui.key.contentAccess", 0);
    1:   default:
    1:     return 0;
    1:   }
    1: }
    1: 
    1: static void
    1: GetBasePrefKeyForMouseWheel(nsMouseScrollEvent* aEvent, nsACString& aPref)
    1: {
    1:   NS_NAMED_LITERAL_CSTRING(prefbase,    "mousewheel");
    1:   NS_NAMED_LITERAL_CSTRING(horizscroll, ".horizscroll");
    1:   NS_NAMED_LITERAL_CSTRING(withshift,   ".withshiftkey");
    1:   NS_NAMED_LITERAL_CSTRING(withalt,     ".withaltkey");
    1:   NS_NAMED_LITERAL_CSTRING(withcontrol, ".withcontrolkey");
    1:   NS_NAMED_LITERAL_CSTRING(withmetakey, ".withmetakey");
    1:   NS_NAMED_LITERAL_CSTRING(withno,      ".withnokey");
    1: 
    1:   aPref = prefbase;
    1:   if (aEvent->scrollFlags & nsMouseScrollEvent::kIsHorizontal) {
    1:     aPref.Append(horizscroll);
    1:   }
    1:   if (aEvent->isShift) {
    1:     aPref.Append(withshift);
    1:   } else if (aEvent->isControl) {
    1:     aPref.Append(withcontrol);
    1:   } else if (aEvent->isAlt) {
    1:     aPref.Append(withalt);
    1:   } else if (aEvent->isMeta) {
    1:     aPref.Append(withmetakey);
    1:   } else {
    1:     aPref.Append(withno);
    1:   }
    1: }
    1: 
    1: class nsMouseWheelTransaction {
    1: public:
    1:   static nsIFrame* GetTargetFrame() { return sTargetFrame; }
    1:   static void BeginTransaction(nsIFrame* aTargetFrame,
24947:                                PRInt32 aNumLines,
79445:                                bool aScrollHorizontal);
25065:   // Be careful, UpdateTransaction may fire a DOM event, therefore, the target
25065:   // frame might be destroyed in the event handler.
79445:   static bool UpdateTransaction(PRInt32 aNumLines,
79445:                                   bool aScrollHorizontal);
    1:   static void EndTransaction();
    1:   static void OnEvent(nsEvent* aEvent);
24947:   static void Shutdown();
26874:   static PRUint32 GetTimeoutTime();
33016:   static PRInt32 AccelerateWheelDelta(PRInt32 aScrollLines,
79445:                    bool aIsHorizontal, bool aAllowScrollSpeedOverride,
70338:                    nsIScrollableFrame::ScrollUnit *aScrollQuantity,
79445:                    bool aLimitToMaxOnePageScroll = true);
79445:   static bool IsAccelerationEnabled();
32205: 
32205:   enum {
32205:     kScrollSeriesTimeout = 80
32205:   };
    1: protected:
23738:   static nsIntPoint GetScreenPoint(nsGUIEvent* aEvent);
24947:   static void OnFailToScrollTarget();
24947:   static void OnTimeout(nsITimer *aTimer, void *aClosure);
24947:   static void SetTimeout();
    1:   static PRUint32 GetIgnoreMoveDelayTime();
32205:   static PRInt32 GetAccelerationStart();
32205:   static PRInt32 GetAccelerationFactor();
33016:   static PRInt32 OverrideSystemScrollSpeed(PRInt32 aScrollLines,
79445:                                            bool aIsHorizontal);
33016:   static PRInt32 ComputeAcceleratedWheelDelta(PRInt32 aDelta, PRInt32 aFactor);
33016:   static PRInt32 LimitToOnePageScroll(PRInt32 aScrollLines,
79445:                    bool aIsHorizontal,
37058:                    nsIScrollableFrame::ScrollUnit *aScrollQuantity);
    1: 
    1:   static nsWeakFrame sTargetFrame;
    1:   static PRUint32    sTime;        // in milliseconds
    1:   static PRUint32    sMouseMoved;  // in milliseconds
24947:   static nsITimer*   sTimer;
32205:   static PRInt32     sScrollSeriesCounter;
    1: };
    1: 
    1: nsWeakFrame nsMouseWheelTransaction::sTargetFrame(nsnull);
    1: PRUint32    nsMouseWheelTransaction::sTime        = 0;
    1: PRUint32    nsMouseWheelTransaction::sMouseMoved  = 0;
24947: nsITimer*   nsMouseWheelTransaction::sTimer       = nsnull;
32205: PRInt32     nsMouseWheelTransaction::sScrollSeriesCounter = 0;
32205: 
79445: static bool
32205: OutOfTime(PRUint32 aBaseTime, PRUint32 aThreshold)
32205: {
32205:   PRUint32 now = PR_IntervalToMilliseconds(PR_IntervalNow());
32205:   return (now - aBaseTime > aThreshold);
32205: }
24947: 
79445: static bool
37058: CanScrollInRange(nscoord aMin, nscoord aValue, nscoord aMax, PRInt32 aDirection)
37058: {
37058:   return aDirection > 0 ? aValue < aMax : aMin < aValue;
37058: }
37058: 
79445: static bool
37058: CanScrollOn(nsIScrollableFrame* aScrollFrame, PRInt32 aNumLines,
79445:             bool aScrollHorizontal)
24947: {
37058:   NS_PRECONDITION(aScrollFrame, "aScrollFrame is null");
24947:   NS_PRECONDITION(aNumLines, "aNumLines must be non-zero");
37058:   nsPoint scrollPt = aScrollFrame->GetScrollPosition();
37058:   nsRect scrollRange = aScrollFrame->GetScrollRange();
37058: 
37058:   return aScrollHorizontal
37058:     ? CanScrollInRange(scrollRange.x, scrollPt.x, scrollRange.XMost(), aNumLines)
37058:     : CanScrollInRange(scrollRange.y, scrollPt.y, scrollRange.YMost(), aNumLines);
24947: }
    1: 
    1: void
    1: nsMouseWheelTransaction::BeginTransaction(nsIFrame* aTargetFrame,
24947:                                           PRInt32 aNumLines,
79445:                                           bool aScrollHorizontal)
    1: {
    1:   NS_ASSERTION(!sTargetFrame, "previous transaction is not finished!");
    1:   sTargetFrame = aTargetFrame;
32205:   sScrollSeriesCounter = 0;
24947:   if (!UpdateTransaction(aNumLines, aScrollHorizontal)) {
24947:     NS_ERROR("BeginTransaction is called even cannot scroll the frame");
24947:     EndTransaction();
24947:   }
24947: }
24947: 
79445: bool
24947: nsMouseWheelTransaction::UpdateTransaction(PRInt32 aNumLines,
79445:                                            bool aScrollHorizontal)
    1: {
37058:   nsIScrollableFrame* sf = GetTargetFrame()->GetScrollTargetFrame();
80486:   NS_ENSURE_TRUE(sf, false);
37058: 
37058:   if (!CanScrollOn(sf, aNumLines, aScrollHorizontal)) {
24947:     OnFailToScrollTarget();
24947:     // We should not modify the transaction state when the view will not be
24947:     // scrolled actually.
80486:     return false;
24947:   }
24947: 
24947:   SetTimeout();
32205: 
32205:   if (sScrollSeriesCounter != 0 && OutOfTime(sTime, kScrollSeriesTimeout))
32205:     sScrollSeriesCounter = 0;
32205:   sScrollSeriesCounter++;
32205: 
    1:   // We should use current time instead of nsEvent.time.
    1:   // 1. Some events doesn't have the correct creation time.
    1:   // 2. If the computer runs slowly by other processes eating the CPU resource,
    1:   //    the event creation time doesn't keep real time.
    1:   sTime = PR_IntervalToMilliseconds(PR_IntervalNow());
    1:   sMouseMoved = 0;
80486:   return true;
    1: }
    1: 
    1: void
    1: nsMouseWheelTransaction::EndTransaction()
    1: {
24947:   if (sTimer)
24947:     sTimer->Cancel();
    1:   sTargetFrame = nsnull;
32205:   sScrollSeriesCounter = 0;
75269: }
    1: 
    1: void
    1: nsMouseWheelTransaction::OnEvent(nsEvent* aEvent)
    1: {
    1:   if (!sTargetFrame)
    1:     return;
    1: 
    1:   if (OutOfTime(sTime, GetTimeoutTime())) {
24947:     // Even if the scroll event which is handled after timeout, but onTimeout
24947:     // was not fired by timer, then the scroll event will scroll old frame,
24947:     // therefore, we should call OnTimeout here and ensure to finish the old
24947:     // transaction.
24947:     OnTimeout(nsnull, nsnull);
    1:     return;
    1:   }
    1: 
70339:   PRInt32 message = aEvent->message;
70339:   // If the event is query scroll target info event, that causes modifying
70339:   // wheel transaction because DoScrollText() needs to use them.  Therefore,
70339:   // we should handle the event as its mouse scroll event here.
70339:   if (message == NS_QUERY_SCROLL_TARGET_INFO) {
70339:     nsQueryContentEvent* queryEvent = static_cast<nsQueryContentEvent*>(aEvent);
70339:     message = queryEvent->mInput.mMouseScrollEvent->message;
70339:   }
70339: 
70339:   switch (message) {
    1:     case NS_MOUSE_SCROLL:
70339:     case NS_MOUSE_PIXEL_SCROLL:
    1:       if (sMouseMoved != 0 &&
    1:           OutOfTime(sMouseMoved, GetIgnoreMoveDelayTime())) {
    1:         // Terminate the current mousewheel transaction if the mouse moved more
    1:         // than ignoremovedelay milliseconds ago
    1:         EndTransaction();
    1:       }
    1:       return;
    1:     case NS_MOUSE_MOVE:
    1:     case NS_DRAGDROP_OVER:
39761:       if (IsMouseEventReal(aEvent)) {
    1:         // If the cursor is moving to be outside the frame,
    1:         // terminate the scrollwheel transaction.
23738:         nsIntPoint pt = GetScreenPoint((nsGUIEvent*)aEvent);
    1:         nsIntRect r = sTargetFrame->GetScreenRectExternal();
    1:         if (!r.Contains(pt)) {
    1:           EndTransaction();
    1:           return;
    1:         }
    1: 
    1:         // If the cursor is moving inside the frame, and it is less than
    1:         // ignoremovedelay milliseconds since the last scroll operation, ignore
    1:         // the mouse move; otherwise, record the current mouse move time to be
    1:         // checked later
    1:         if (OutOfTime(sTime, GetIgnoreMoveDelayTime())) {
    1:           if (sMouseMoved == 0)
    1:             sMouseMoved = PR_IntervalToMilliseconds(PR_IntervalNow());
    1:         }
    1:       }
    1:       return;
    1:     case NS_KEY_PRESS:
    1:     case NS_KEY_UP:
    1:     case NS_KEY_DOWN:
    1:     case NS_MOUSE_BUTTON_UP:
    1:     case NS_MOUSE_BUTTON_DOWN:
    1:     case NS_MOUSE_DOUBLECLICK:
    1:     case NS_MOUSE_CLICK:
    1:     case NS_CONTEXTMENU:
    1:     case NS_DRAGDROP_DROP:
    1:       EndTransaction();
    1:       return;
    1:   }
    1: }
    1: 
24947: void
24947: nsMouseWheelTransaction::Shutdown()
24947: {
24947:   NS_IF_RELEASE(sTimer);
24947: }
24947: 
24947: void
24947: nsMouseWheelTransaction::OnFailToScrollTarget()
24947: {
24947:   NS_PRECONDITION(sTargetFrame, "We don't have mouse scrolling transaction");
28026: 
79445:   if (Preferences::GetBool("test.mousescroll", false)) {
24947:     // This event is used for automated tests, see bug 442774.
24947:     nsContentUtils::DispatchTrustedEvent(
80526:                       sTargetFrame->GetContent()->OwnerDoc(),
24947:                       sTargetFrame->GetContent(),
24947:                       NS_LITERAL_STRING("MozMouseScrollFailed"),
80486:                       true, true);
28026:   }
25065:   // The target frame might be destroyed in the event handler, at that time,
25065:   // we need to finish the current transaction
25065:   if (!sTargetFrame)
25065:     EndTransaction();
24947: }
24947: 
24947: void
24947: nsMouseWheelTransaction::OnTimeout(nsITimer* aTimer, void* aClosure)
24947: {
24947:   if (!sTargetFrame) {
24947:     // The transaction target was destroyed already
24947:     EndTransaction();
24947:     return;
24947:   }
24947:   // Store the sTargetFrame, the variable becomes null in EndTransaction.
24947:   nsIFrame* frame = sTargetFrame;
24947:   // We need to finish current transaction before DOM event firing. Because
24947:   // the next DOM event might create strange situation for us.
24947:   EndTransaction();
28026: 
79445:   if (Preferences::GetBool("test.mousescroll", false)) {
24947:     // This event is used for automated tests, see bug 442774.
24947:     nsContentUtils::DispatchTrustedEvent(
80526:                       frame->GetContent()->OwnerDoc(),
24947:                       frame->GetContent(),
24947:                       NS_LITERAL_STRING("MozMouseScrollTransactionTimeout"),
80486:                       true, true);
24947:   }
28026: }
24947: 
24947: void
24947: nsMouseWheelTransaction::SetTimeout()
24947: {
24947:   if (!sTimer) {
24947:     nsCOMPtr<nsITimer> timer = do_CreateInstance(NS_TIMER_CONTRACTID);
24947:     if (!timer)
24947:       return;
24947:     timer.swap(sTimer);
24947:   }
24947:   sTimer->Cancel();
68468: #ifdef DEBUG
24947:   nsresult rv =
68468: #endif
24947:   sTimer->InitWithFuncCallback(OnTimeout, nsnull, GetTimeoutTime(),
24947:                                nsITimer::TYPE_ONE_SHOT);
24947:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "nsITimer::InitWithFuncCallback failed");
24947: }
24947: 
23738: nsIntPoint
    1: nsMouseWheelTransaction::GetScreenPoint(nsGUIEvent* aEvent)
    1: {
    1:   NS_ASSERTION(aEvent, "aEvent is null");
    1:   NS_ASSERTION(aEvent->widget, "aEvent-widget is null");
25183:   return aEvent->refPoint + aEvent->widget->WidgetToScreenOffset();
    1: }
    1: 
    1: PRUint32
    1: nsMouseWheelTransaction::GetTimeoutTime()
    1: {
70842:   return Preferences::GetUint("mousewheel.transaction.timeout", 1500);
    1: }
    1: 
    1: PRUint32
    1: nsMouseWheelTransaction::GetIgnoreMoveDelayTime()
    1: {
70842:   return Preferences::GetUint("mousewheel.transaction.ignoremovedelay", 100);
    1: }
    1: 
79445: bool
70040: nsMouseWheelTransaction::IsAccelerationEnabled()
70040: {
70040:   return GetAccelerationStart() >= 0 && GetAccelerationFactor() > 0;
70040: }
70040: 
33016: PRInt32
33016: nsMouseWheelTransaction::AccelerateWheelDelta(PRInt32 aScrollLines,
79445:                            bool aIsHorizontal,
79445:                            bool aAllowScrollSpeedOverride,
70338:                            nsIScrollableFrame::ScrollUnit *aScrollQuantity,
79445:                            bool aLimitToMaxOnePageScroll)
32205: {
33016:   if (aAllowScrollSpeedOverride) {
33016:     aScrollLines = OverrideSystemScrollSpeed(aScrollLines, aIsHorizontal);
33016:   }
33016: 
33016:   // Accelerate by the sScrollSeriesCounter
32205:   PRInt32 start = GetAccelerationStart();
33016:   if (start >= 0 && sScrollSeriesCounter >= start) {
32205:     PRInt32 factor = GetAccelerationFactor();
33016:     if (factor > 0) {
33016:       aScrollLines = ComputeAcceleratedWheelDelta(aScrollLines, factor);
33016:     }
33016:   }
33016: 
33016:   // If the computed delta is larger than the page, we should limit
33016:   // the delta value to the one page size.
70338:   return !aLimitToMaxOnePageScroll ? aScrollLines :
70338:     LimitToOnePageScroll(aScrollLines, aIsHorizontal, aScrollQuantity);
32205: }
32205: 
32205: PRInt32
33016: nsMouseWheelTransaction::ComputeAcceleratedWheelDelta(PRInt32 aDelta,
33016:                                                       PRInt32 aFactor)
32205: {
32205:   if (aDelta == 0)
32205:     return 0;
32205: 
33016:   return PRInt32(NS_round(aDelta * sScrollSeriesCounter *
33016:                           (double)aFactor / 10));
32205: }
32205: 
32205: PRInt32
32205: nsMouseWheelTransaction::GetAccelerationStart()
32205: {
70842:   return Preferences::GetInt("mousewheel.acceleration.start", -1);
32205: }
32205: 
32205: PRInt32
32205: nsMouseWheelTransaction::GetAccelerationFactor()
32205: {
70842:   return Preferences::GetInt("mousewheel.acceleration.factor", -1);
32205: }
32205: 
33016: PRInt32
33016: nsMouseWheelTransaction::OverrideSystemScrollSpeed(PRInt32 aScrollLines,
79445:                                                    bool aIsHorizontal)
33016: {
33016:   NS_PRECONDITION(sTargetFrame, "We don't have mouse scrolling transaction");
33016: 
33016:   if (aScrollLines == 0) {
33016:     return 0;
33016:   }
33016: 
33016:   // We shouldn't override the scrolling speed on non root scroll frame.
33016:   if (sTargetFrame !=
33016:         sTargetFrame->PresContext()->PresShell()->GetRootScrollFrame()) {
33016:     return aScrollLines;
33016:   }
33016: 
33016:   // Compute the overridden speed to nsIWidget.  The widget can check the
33016:   // conditions (e.g., checking the prefs, and also whether the user customized
33016:   // the system settings of the mouse wheel scrolling or not), and can limit
33016:   // the speed for preventing the unexpected high speed scrolling.
47148:   nsCOMPtr<nsIWidget> widget(sTargetFrame->GetNearestWidget());
33016:   NS_ENSURE_TRUE(widget, aScrollLines);
33016:   PRInt32 overriddenDelta;
33016:   nsresult rv = widget->OverrideSystemMouseScrollSpeed(aScrollLines,
33016:                                                        aIsHorizontal,
33016:                                                        overriddenDelta);
33016:   NS_ENSURE_SUCCESS(rv, aScrollLines);
33016:   return overriddenDelta;
33016: }
33016: 
33016: PRInt32
33016: nsMouseWheelTransaction::LimitToOnePageScroll(PRInt32 aScrollLines,
79445:                            bool aIsHorizontal,
37058:                            nsIScrollableFrame::ScrollUnit *aScrollQuantity)
33016: {
33016:   NS_ENSURE_TRUE(aScrollQuantity, aScrollLines);
37058:   NS_PRECONDITION(*aScrollQuantity == nsIScrollableFrame::LINES,
33016:                   "aScrollQuantity isn't by line");
33016: 
33016:   NS_ENSURE_TRUE(sTargetFrame, aScrollLines);
37058:   nsIScrollableFrame* sf = sTargetFrame->GetScrollTargetFrame();
37058:   NS_ENSURE_TRUE(sf, aScrollLines);
33016: 
33016:   // Limit scrolling to be at most one page, but if possible, try to
33016:   // just adjust the number of scrolled lines.
37058:   nsSize lineAmount = sf->GetLineScrollAmount();
37058:   nscoord lineScroll = aIsHorizontal ? lineAmount.width : lineAmount.height;
37058: 
37058:   if (lineScroll == 0)
33016:     return aScrollLines;
33016: 
37058:   nsSize pageAmount = sf->GetPageScrollAmount();
37058:   nscoord pageScroll = aIsHorizontal ? pageAmount.width : pageAmount.height;
37058: 
71173:   if (NS_ABS(aScrollLines) * lineScroll < pageScroll)
33016:     return aScrollLines;
33016: 
37058:   nscoord maxLines = (pageScroll / lineScroll);
33016:   if (maxLines >= 1)
33016:     return ((aScrollLines < 0) ? -1 : 1) * maxLines;
33016: 
37058:   *aScrollQuantity = nsIScrollableFrame::PAGES;
33016:   return (aScrollLines < 0) ? -1 : 1;
33016: }
33016: 
    1: /******************************************************************/
    1: /* nsEventStateManager                                            */
    1: /******************************************************************/
    1: 
    1: nsEventStateManager::nsEventStateManager()
    1:   : mLockCursor(0),
95203:     mPreLockPoint(0,0),
    1:     mCurrentTarget(nsnull),
    1:     mLastMouseOverFrame(nsnull),
    1:     // init d&d gesture state machine variables
    1:     mGestureDownPoint(0,0),
    1:     mPresContext(nsnull),
    1:     mLClickCount(0),
    1:     mMClickCount(0),
    1:     mRClickCount(0),
80486:     m_haveShutdown(false),
80486:     mLastLineScrollConsumedX(false),
80486:     mLastLineScrollConsumedY(false),
80486:     mClickHoldContextMenu(false)
    1: {
 7093:   if (sESMInstanceCount == 0) {
 7093:     gUserInteractionTimerCallback = new nsUITimerCallback();
57074:     if (gUserInteractionTimerCallback)
 7093:       NS_ADDREF(gUserInteractionTimerCallback);
57074:     UpdateUserActivityTimer();
57074:   }
57074:   ++sESMInstanceCount;
57074: }
57074: 
57074: nsresult
57074: nsEventStateManager::UpdateUserActivityTimer(void)
57074: {
57074:   if (!gUserInteractionTimerCallback)
57074:     return NS_OK;
57074: 
57074:   if (!gUserInteractionTimer)
 7093:     CallCreateInstance("@mozilla.org/timer;1", &gUserInteractionTimer);
57074: 
 7093:   if (gUserInteractionTimer) {
 7093:     gUserInteractionTimer->InitWithCallback(gUserInteractionTimerCallback,
 7093:                                             NS_USER_INTERACTION_INTERVAL,
57074:                                             nsITimer::TYPE_ONE_SHOT);
57074:   }
57074:   return NS_OK;
    1: }
    1: 
71000: static const char* kObservedPrefs[] = {
71000:   "accessibility.accesskeycausesactivation",
71000:   "nglayout.events.dispatchLeftClickOnly",
71000:   "ui.key.generalAccessKey",
71000:   "ui.key.chromeAccess",
71000:   "ui.key.contentAccess",
71000:   "ui.click_hold_context_menus",
71000: #if 0
71000:   "mousewheel.withaltkey.action",
71000:   "mousewheel.withaltkey.numlines",
71000:   "mousewheel.withaltkey.sysnumlines",
71000:   "mousewheel.withcontrolkey.action",
71000:   "mousewheel.withcontrolkey.numlines",
71000:   "mousewheel.withcontrolkey.sysnumlines",
71000:   "mousewheel.withnokey.action",
71000:   "mousewheel.withnokey.numlines",
71000:   "mousewheel.withnokey.sysnumlines",
71000:   "mousewheel.withshiftkey.action",
71000:   "mousewheel.withshiftkey.numlines",
71000:   "mousewheel.withshiftkey.sysnumlines",
71000: #endif
71000:   "dom.popup_allowed_events",
71000:   nsnull
71000: };
71000: 
68780: nsresult
    1: nsEventStateManager::Init()
    1: {
    1:   nsCOMPtr<nsIObserverService> observerService =
41540:     mozilla::services::GetObserverService();
41540:   if (!observerService)
41540:     return NS_ERROR_FAILURE;
    1: 
80486:   observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, true);
    1: 
    1:   if (sESMInstanceCount == 1) {
71259:     sKeyCausesActivation =
71259:       Preferences::GetBool("accessibility.accesskeycausesactivation",
71259:                            sKeyCausesActivation);
    1:     sLeftClickOnly =
70840:       Preferences::GetBool("nglayout.events.dispatchLeftClickOnly",
    1:                            sLeftClickOnly);
    1:     sChromeAccessModifier =
    1:       GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeChrome);
    1:     sContentAccessModifier =
    1:       GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeContent);
    1:   }
71000:   Preferences::AddWeakObservers(this, kObservedPrefs);
    1: 
43674:   mClickHoldContextMenu =
79445:     Preferences::GetBool("ui.click_hold_context_menus", false);
43674: 
41540:   return NS_OK;
    1: }
    1: 
    1: nsEventStateManager::~nsEventStateManager()
    1: {
54151:   if (sActiveESM == this) {
54151:     sActiveESM = nsnull;
54151:   }
43674:   if (mClickHoldContextMenu)
    1:     KillClickHoldTimer();
    1: 
54257:   if (mDocument == sMouseOverDocument)
54257:     sMouseOverDocument = nsnull;
54257: 
    1:   --sESMInstanceCount;
    1:   if(sESMInstanceCount == 0) {
24947:     nsMouseWheelTransaction::Shutdown();
 7093:     if (gUserInteractionTimerCallback) {
 7093:       gUserInteractionTimerCallback->Notify(nsnull);
 7093:       NS_RELEASE(gUserInteractionTimerCallback);
 7093:     }
 7093:     if (gUserInteractionTimer) {
 7093:       gUserInteractionTimer->Cancel();
 7093:       NS_RELEASE(gUserInteractionTimer);
 7093:     }
    1:   }
    1: 
80526:   if (sDragOverContent && sDragOverContent->OwnerDoc() == mDocument) {
79435:     sDragOverContent = nsnull;
79435:   }
79435: 
    1:   if (!m_haveShutdown) {
    1:     Shutdown();
    1: 
    1:     // Don't remove from Observer service in Shutdown because Shutdown also
    1:     // gets called from xpcom shutdown observer.  And we don't want to remove
    1:     // from the service in that case.
    1: 
    1:     nsCOMPtr<nsIObserverService> observerService =
41540:       mozilla::services::GetObserverService();
41540:     if (observerService) {
    1:       observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
    1:     }
    1:   }
    1: 
    1: }
    1: 
    1: nsresult
    1: nsEventStateManager::Shutdown()
    1: {
71000:   Preferences::RemoveObservers(this, kObservedPrefs);
80486:   m_haveShutdown = true;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEventStateManager::Observe(nsISupports *aSubject,
    1:                              const char *aTopic,
    1:                              const PRUnichar *someData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID))
    1:     Shutdown();
    1:   else if (!nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
    1:     if (!someData)
    1:       return NS_OK;
    1: 
    1:     nsDependentString data(someData);
    1:     if (data.EqualsLiteral("accessibility.accesskeycausesactivation")) {
    1:       sKeyCausesActivation =
70840:         Preferences::GetBool("accessibility.accesskeycausesactivation",
    1:                              sKeyCausesActivation);
    1:     } else if (data.EqualsLiteral("nglayout.events.dispatchLeftClickOnly")) {
    1:       sLeftClickOnly =
70840:         Preferences::GetBool("nglayout.events.dispatchLeftClickOnly",
    1:                              sLeftClickOnly);
    1:     } else if (data.EqualsLiteral("ui.key.generalAccessKey")) {
    1:       sChromeAccessModifier =
    1:         GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeChrome);
    1:       sContentAccessModifier =
    1:         GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeContent);
    1:     } else if (data.EqualsLiteral("ui.key.chromeAccess")) {
    1:       sChromeAccessModifier =
    1:         GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeChrome);
    1:     } else if (data.EqualsLiteral("ui.key.contentAccess")) {
    1:       sContentAccessModifier =
    1:         GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeContent);
43674:     } else if (data.EqualsLiteral("ui.click_hold_context_menus")) {
43674:       mClickHoldContextMenu =
79445:         Preferences::GetBool("ui.click_hold_context_menus", false);
    1: #if 0
    1:     } else if (data.EqualsLiteral("mousewheel.withaltkey.action")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withaltkey.numlines")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withaltkey.sysnumlines")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withcontrolkey.action")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withcontrolkey.numlines")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withcontrolkey.sysnumlines")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withshiftkey.action")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withshiftkey.numlines")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withshiftkey.sysnumlines")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withnokey.action")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withnokey.numlines")) {
    1:     } else if (data.EqualsLiteral("mousewheel.withnokey.sysnumlines")) {
    1: #endif
    1:     } else if (data.EqualsLiteral("dom.popup_allowed_events")) {
    1:       nsDOMEvent::PopupAllowedEventsChanged();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 4484: NS_IMPL_CYCLE_COLLECTION_CLASS(nsEventStateManager)
 4484: 
 4484: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsEventStateManager)
68780:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIObserver)
 4484:    NS_INTERFACE_MAP_ENTRY(nsIObserver)
 4484:    NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 4484: NS_INTERFACE_MAP_END
 4484: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsEventStateManager)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsEventStateManager)
 4484: 
 4484: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsEventStateManager)
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCurrentTargetContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLastMouseOverElement);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mGestureDownContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mGestureDownFrameOwner);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLastLeftMouseDownContent);
37465:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLastLeftMouseDownContentParent);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLastMiddleMouseDownContent);
37465:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLastMiddleMouseDownContentParent);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLastRightMouseDownContent);
37465:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLastRightMouseDownContentParent);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mActiveContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mHoverContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mURLTargetContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstMouseOverEventElement);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstMouseOutEventElement);
 4484:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument);
 8407:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mAccessKeys);
 4484: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 4484: 
 4484: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsEventStateManager)
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCurrentTargetContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLastMouseOverElement);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mGestureDownContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mGestureDownFrameOwner);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLastLeftMouseDownContent);
37465:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLastLeftMouseDownContentParent);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLastMiddleMouseDownContent);
37465:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLastMiddleMouseDownContentParent);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLastRightMouseDownContent);
37465:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLastRightMouseDownContentParent);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mActiveContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mHoverContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mURLTargetContent);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstMouseOverEventElement);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstMouseOutEventElement);
 4484:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument);
 8407:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mAccessKeys);
 4484: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 4484: 
68780: nsresult
    1: nsEventStateManager::PreHandleEvent(nsPresContext* aPresContext,
    1:                                     nsEvent *aEvent,
    1:                                     nsIFrame* aTargetFrame,
82566:                                     nsEventStatus* aStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aStatus);
    1:   NS_ENSURE_ARG(aPresContext);
    1:   if (!aEvent) {
    1:     NS_ERROR("aEvent is null.  This should never happen.");
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   mCurrentTarget = aTargetFrame;
    1:   mCurrentTargetContent = nsnull;
    1: 
    1:   // Focus events don't necessarily need a frame.
    1:   if (NS_EVENT_NEEDS_FRAME(aEvent)) {
    1:     NS_ASSERTION(mCurrentTarget, "mCurrentTarget is null.  this should not happen.  see bug #13007");
    1:     if (!mCurrentTarget) return NS_ERROR_NULL_POINTER;
    1:   }
95203: #ifdef DEBUG
95203:   if (NS_IS_DRAG_EVENT(aEvent) && sIsPointerLocked) {
95203:     NS_ASSERTION(sIsPointerLocked,
95203:       "sIsPointerLocked is true. Drag events should be suppressed when the pointer is locked.");
95203:   }
95203: #endif
95203:   // Store last known screenPoint and clientPoint so pointer lock
95203:   // can use these values as constants.
95203:   if (NS_IS_TRUSTED_EVENT(aEvent) &&
95618:       ((NS_IS_MOUSE_EVENT_STRUCT(aEvent) &&
95203:        IsMouseEventReal(aEvent)) ||
95618:        aEvent->eventStructType == NS_MOUSE_SCROLL_EVENT)) {
95203:     if (!sIsPointerLocked) {
95203:       sLastScreenPoint = nsDOMUIEvent::CalculateScreenPoint(aPresContext, aEvent);
95203:       sLastClientPoint = nsDOMUIEvent::CalculateClientPoint(aPresContext, aEvent, nsnull);
95203:     }
95203:   }
    1: 
 7093:   // Do not take account NS_MOUSE_ENTER/EXIT so that loading a page
 7093:   // when user is not active doesn't change the state to active.
 7093:   if (NS_IS_TRUSTED_EVENT(aEvent) &&
 7093:       ((aEvent->eventStructType == NS_MOUSE_EVENT  &&
39761:         IsMouseEventReal(aEvent) &&
 7093:         aEvent->message != NS_MOUSE_ENTER &&
 7093:         aEvent->message != NS_MOUSE_EXIT) ||
 7093:        aEvent->eventStructType == NS_MOUSE_SCROLL_EVENT ||
 7093:        aEvent->eventStructType == NS_KEY_EVENT)) {
 7093:     if (gMouseOrKeyboardEventCounter == 0) {
 7093:       nsCOMPtr<nsIObserverService> obs =
41540:         mozilla::services::GetObserverService();
 7093:       if (obs) {
 7093:         obs->NotifyObservers(nsnull, "user-interaction-active", nsnull);
57074:         UpdateUserActivityTimer();
 7093:       }
 7093:     }
 7093:     ++gMouseOrKeyboardEventCounter;
 7093:   }
 7093: 
    1:   *aStatus = nsEventStatus_eIgnore;
    1: 
    1:   nsMouseWheelTransaction::OnEvent(aEvent);
    1: 
    1:   switch (aEvent->message) {
    1:   case NS_MOUSE_BUTTON_DOWN:
 3233:     switch (static_cast<nsMouseEvent*>(aEvent)->button) {
    1:     case nsMouseEvent::eLeftButton:
    1: #ifndef XP_OS2
    1:       BeginTrackingDragGesture(aPresContext, (nsMouseEvent*)aEvent, aTargetFrame);
    1: #endif
    1:       mLClickCount = ((nsMouseEvent*)aEvent)->clickCount;
    1:       SetClickCount(aPresContext, (nsMouseEvent*)aEvent, aStatus);
80486:       sNormalLMouseEventInProcess = true;
    1:       break;
    1:     case nsMouseEvent::eMiddleButton:
    1:       mMClickCount = ((nsMouseEvent*)aEvent)->clickCount;
    1:       SetClickCount(aPresContext, (nsMouseEvent*)aEvent, aStatus);
    1:       break;
    1:     case nsMouseEvent::eRightButton:
    1: #ifdef XP_OS2
    1:       BeginTrackingDragGesture(aPresContext, (nsMouseEvent*)aEvent, aTargetFrame);
    1: #endif
    1:       mRClickCount = ((nsMouseEvent*)aEvent)->clickCount;
    1:       SetClickCount(aPresContext, (nsMouseEvent*)aEvent, aStatus);
    1:       break;
    1:     }
    1:     break;
    1:   case NS_MOUSE_BUTTON_UP:
 3233:     switch (static_cast<nsMouseEvent*>(aEvent)->button) {
    1:       case nsMouseEvent::eLeftButton:
43674:         if (mClickHoldContextMenu) {
    1:           KillClickHoldTimer();
43674:         }
    1: #ifndef XP_OS2
    1:         StopTrackingDragGesture();
    1: #endif
80486:         sNormalLMouseEventInProcess = false;
63945:         // then fall through...
    1:       case nsMouseEvent::eRightButton:
    1: #ifdef XP_OS2
    1:         StopTrackingDragGesture();
    1: #endif
63945:         // then fall through...
    1:       case nsMouseEvent::eMiddleButton:
    1:         SetClickCount(aPresContext, (nsMouseEvent*)aEvent, aStatus);
    1:         break;
    1:     }
    1:     break;
    1:   case NS_MOUSE_EXIT:
12976:     // If the event is not a top-level window exit, then it's not
12976:     // really an exit --- we may have traversed widget boundaries but
    1:     // we're still in our toplevel window.
    1:     {
 3233:       nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(aEvent);
12976:       if (mouseEvent->exit != nsMouseEvent::eTopLevel) {
14640:         // Treat it as a synthetic move so we don't generate spurious
14640:         // "exit" or "move" events.  Any necessary "out" or "over" events
14640:         // will be generated by GenerateMouseEnterExit
14640:         mouseEvent->message = NS_MOUSE_MOVE;
14640:         mouseEvent->reason = nsMouseEvent::eSynthesized;
    1:         // then fall through...
    1:       } else {
    1:         GenerateMouseEnterExit((nsGUIEvent*)aEvent);
    1:         //This is a window level mouse exit event and should stop here
    1:         aEvent->message = 0;
    1:         break;
    1:       }
    1:     }
    1:   case NS_MOUSE_MOVE:
    1:     // on the Mac, GenerateDragGesture() may not return until the drag
    1:     // has completed and so |aTargetFrame| may have been deleted (moving
    1:     // a bookmark, for example).  If this is the case, however, we know
    1:     // that ClearFrameRefs() has been called and it cleared out
    1:     // |mCurrentTarget|. As a result, we should pass |mCurrentTarget|
    1:     // into UpdateCursor().
    1:     GenerateDragGesture(aPresContext, (nsMouseEvent*)aEvent);
    1:     UpdateCursor(aPresContext, aEvent, mCurrentTarget, aStatus);
    1:     GenerateMouseEnterExit((nsGUIEvent*)aEvent);
86861:     // Flush pending layout changes, so that later mouse move events
86861:     // will go to the right nodes.
86861:     FlushPendingEvents(aPresContext);
    1:     break;
    1:   case NS_DRAGDROP_GESTURE:
43674:     if (mClickHoldContextMenu) {
    1:       // an external drag gesture event came in, not generated internally
    1:       // by Gecko. Make sure we get rid of the click-hold timer.
    1:       KillClickHoldTimer();
43674:     }
    1:     break;
    1:   case NS_DRAGDROP_OVER:
18445:     // NS_DRAGDROP_DROP is fired before NS_DRAGDROP_DRAGDROP so send
18445:     // the enter/exit events before NS_DRAGDROP_DROP.
    1:     GenerateDragDropEnterExit(aPresContext, (nsGUIEvent*)aEvent);
    1:     break;
    1: 
    1:   case NS_KEY_PRESS:
    1:     {
    1: 
    1:       nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
    1: 
    1:       PRInt32 modifierMask = 0;
    1:       if (keyEvent->isShift)
    1:         modifierMask |= NS_MODIFIER_SHIFT;
    1:       if (keyEvent->isControl)
    1:         modifierMask |= NS_MODIFIER_CONTROL;
    1:       if (keyEvent->isAlt)
    1:         modifierMask |= NS_MODIFIER_ALT;
    1:       if (keyEvent->isMeta)
    1:         modifierMask |= NS_MODIFIER_META;
    1: 
    1:       // Prevent keyboard scrolling while an accesskey modifier is in use.
    1:       if (modifierMask && (modifierMask == sChromeAccessModifier ||
    1:                            modifierMask == sContentAccessModifier))
 1585:         HandleAccessKey(aPresContext, keyEvent, aStatus, nsnull,
    1:                         eAccessKeyProcessingNormal, modifierMask);
    1:     }
63945:     // then fall through...
    1:   case NS_KEY_DOWN:
    1:   case NS_KEY_UP:
    1:     {
29018:       nsIContent* content = GetFocusedContent();
29018:       if (content)
29018:         mCurrentTargetContent = content;
    1:     }
    1:     break;
    1:   case NS_MOUSE_SCROLL:
    1:     {
29018:       nsIContent* content = GetFocusedContent();
29018:       if (content)
29018:         mCurrentTargetContent = content;
    1: 
 3233:       nsMouseScrollEvent* msEvent = static_cast<nsMouseScrollEvent*>(aEvent);
    1: 
73896:       msEvent->delta = ComputeWheelDeltaFor(msEvent);
    1:     }
    1:     break;
19319:   case NS_MOUSE_PIXEL_SCROLL:
19319:     {
29018:       nsIContent* content = GetFocusedContent();
29018:       if (content)
29018:         mCurrentTargetContent = content;
19319: 
26874:       nsMouseScrollEvent *msEvent = static_cast<nsMouseScrollEvent*>(aEvent);
26874: 
26874:       // Clear old deltas after a period of non action
26874:       if (OutOfTime(gPixelScrollDeltaTimeout, nsMouseWheelTransaction::GetTimeoutTime())) {
26874:         gPixelScrollDeltaX = gPixelScrollDeltaY = 0;
26874:       }
26874:       gPixelScrollDeltaTimeout = PR_IntervalToMilliseconds(PR_IntervalNow());
26874: 
26874:       // If needed send a line scroll event for pixel scrolls with kNoLines
26874:       if (msEvent->scrollFlags & nsMouseScrollEvent::kNoLines) {
26874:         nscoord pixelHeight = aPresContext->AppUnitsToIntCSSPixels(
37061:           GetScrollableLineHeight(aTargetFrame));
26874: 
26874:         if (msEvent->scrollFlags & nsMouseScrollEvent::kIsVertical) {
26874:           gPixelScrollDeltaX += msEvent->delta;
26874:           if (!gPixelScrollDeltaX || !pixelHeight)
26874:             break;
26874: 
71173:           if (NS_ABS(gPixelScrollDeltaX) >= pixelHeight) {
26874:             PRInt32 numLines = (PRInt32)ceil((float)gPixelScrollDeltaX/(float)pixelHeight);
26874: 
26874:             gPixelScrollDeltaX -= numLines*pixelHeight;
26874: 
26874:             nsWeakFrame weakFrame(aTargetFrame);
26874:             SendLineScrollEvent(aTargetFrame, msEvent, aPresContext,
26874:               aStatus, numLines);
26874:             NS_ENSURE_STATE(weakFrame.IsAlive());
26874:           }
26874:         } else if (msEvent->scrollFlags & nsMouseScrollEvent::kIsHorizontal) {
26874:           gPixelScrollDeltaY += msEvent->delta;
26874:           if (!gPixelScrollDeltaY || !pixelHeight)
26874:             break;
26874: 
71173:           if (NS_ABS(gPixelScrollDeltaY) >= pixelHeight) {
26874:             PRInt32 numLines = (PRInt32)ceil((float)gPixelScrollDeltaY/(float)pixelHeight);
26874: 
26874:             gPixelScrollDeltaY -= numLines*pixelHeight;
26874: 
26874:             nsWeakFrame weakFrame(aTargetFrame);
26874:             SendLineScrollEvent(aTargetFrame, msEvent, aPresContext,
26874:               aStatus, numLines);
26874:             NS_ENSURE_STATE(weakFrame.IsAlive());
26874:           }
26874:         }
26874:       }
26874: 
19319:       // When the last line scroll has been canceled, eat the pixel scroll event
19319:       if ((msEvent->scrollFlags & nsMouseScrollEvent::kIsHorizontal) ?
19319:            mLastLineScrollConsumedX : mLastLineScrollConsumedY) {
19319:         *aStatus = nsEventStatus_eConsumeNoDefault;
19319:       }
19319:     }
19319:     break;
11914:   case NS_QUERY_SELECTED_TEXT:
78622:     DoQuerySelectedText(static_cast<nsQueryContentEvent*>(aEvent));
11914:     break;
11914:   case NS_QUERY_TEXT_CONTENT:
11914:     {
54603:       if (RemoteQueryContentEvent(aEvent))
54603:         break;
24836:       nsContentEventHandler handler(mPresContext);
11914:       handler.OnQueryTextContent((nsQueryContentEvent*)aEvent);
11914:     }
11914:     break;
11914:   case NS_QUERY_CARET_RECT:
11914:     {
54603:       // XXX remote event
24836:       nsContentEventHandler handler(mPresContext);
11914:       handler.OnQueryCaretRect((nsQueryContentEvent*)aEvent);
11914:     }
11914:     break;
24836:   case NS_QUERY_TEXT_RECT:
24836:     {
54603:       // XXX remote event
24836:       nsContentEventHandler handler(mPresContext);
24836:       handler.OnQueryTextRect((nsQueryContentEvent*)aEvent);
24836:     }
24836:     break;
24836:   case NS_QUERY_EDITOR_RECT:
24836:     {
54603:       // XXX remote event
24836:       nsContentEventHandler handler(mPresContext);
24836:       handler.OnQueryEditorRect((nsQueryContentEvent*)aEvent);
24836:     }
24836:     break;
26757:   case NS_QUERY_CONTENT_STATE:
26757:     {
54603:       // XXX remote event
26757:       nsContentEventHandler handler(mPresContext);
26757:       handler.OnQueryContentState(static_cast<nsQueryContentEvent*>(aEvent));
26757:     }
26757:     break;
26757:   case NS_QUERY_SELECTION_AS_TRANSFERABLE:
26757:     {
54603:       // XXX remote event
26757:       nsContentEventHandler handler(mPresContext);
26757:       handler.OnQuerySelectionAsTransferable(static_cast<nsQueryContentEvent*>(aEvent));
26757:     }
26757:     break;
28352:   case NS_QUERY_CHARACTER_AT_POINT:
28352:     {
54603:       // XXX remote event
28352:       nsContentEventHandler handler(mPresContext);
28352:       handler.OnQueryCharacterAtPoint(static_cast<nsQueryContentEvent*>(aEvent));
28352:     }
28352:     break;
63215:   case NS_QUERY_DOM_WIDGET_HITTEST:
63215:     {
63215:       // XXX remote event
63215:       nsContentEventHandler handler(mPresContext);
63215:       handler.OnQueryDOMWidgetHittest(static_cast<nsQueryContentEvent*>(aEvent));
63215:     }
63215:     break;
69947:   case NS_QUERY_SCROLL_TARGET_INFO:
69947:     {
69947:       DoQueryScrollTargetInfo(static_cast<nsQueryContentEvent*>(aEvent),
69947:                               aTargetFrame);
69947:       break;
69947:     }
24836:   case NS_SELECTION_SET:
24836:     {
54603:       nsSelectionEvent *selectionEvent =
54603:           static_cast<nsSelectionEvent*>(aEvent);
54603:       if (IsTargetCrossProcess(selectionEvent)) {
54603:         // Will not be handled locally, remote the event
54603:         if (GetCrossProcessTarget()->SendSelectionEvent(*selectionEvent))
80486:           selectionEvent->mSucceeded = true;
54603:         break;
54603:       }
24836:       nsContentEventHandler handler(mPresContext);
24836:       handler.OnSelectionEvent((nsSelectionEvent*)aEvent);
24836:     }
24836:     break;
31218:   case NS_CONTENT_COMMAND_CUT:
31218:   case NS_CONTENT_COMMAND_COPY:
31218:   case NS_CONTENT_COMMAND_PASTE:
31218:   case NS_CONTENT_COMMAND_DELETE:
31218:   case NS_CONTENT_COMMAND_UNDO:
31218:   case NS_CONTENT_COMMAND_REDO:
36983:   case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE:
31218:     {
31218:       DoContentCommandEvent(static_cast<nsContentCommandEvent*>(aEvent));
31218:     }
31218:     break;
39248:   case NS_CONTENT_COMMAND_SCROLL:
39248:     {
39248:       DoContentCommandScrollEvent(static_cast<nsContentCommandEvent*>(aEvent));
39248:     }
39248:     break;
50731:   case NS_TEXT_TEXT:
50731:     {
50731:       nsTextEvent *textEvent = static_cast<nsTextEvent*>(aEvent);
50731:       if (IsTargetCrossProcess(textEvent)) {
50731:         // Will not be handled locally, remote the event
54603:         if (GetCrossProcessTarget()->SendTextEvent(*textEvent)) {
50731:           // Cancel local dispatching
54603:           aEvent->flags |= NS_EVENT_FLAG_STOP_DISPATCH;
50731:         }
50731:       }
50731:     }
50731:     break;
50731:   case NS_COMPOSITION_START:
78622:     if (NS_IS_TRUSTED_EVENT(aEvent)) {
78622:       // If the event is trusted event, set the selected text to data of
78622:       // composition event.
78622:       nsCompositionEvent *compositionEvent =
78622:         static_cast<nsCompositionEvent*>(aEvent);
80486:       nsQueryContentEvent selectedText(true, NS_QUERY_SELECTED_TEXT,
78622:                                        compositionEvent->widget);
78622:       DoQuerySelectedText(&selectedText);
78622:       NS_ASSERTION(selectedText.mSucceeded, "Failed to get selected text");
78622:       compositionEvent->data = selectedText.mReply.mString;
78622:     }
78622:     // through to compositionend handling
78621:   case NS_COMPOSITION_UPDATE:
50731:   case NS_COMPOSITION_END:
50731:     {
50731:       nsCompositionEvent *compositionEvent =
50731:           static_cast<nsCompositionEvent*>(aEvent);
50731:       if (IsTargetCrossProcess(compositionEvent)) {
50731:         // Will not be handled locally, remote the event
54603:         if (GetCrossProcessTarget()->SendCompositionEvent(*compositionEvent)) {
50731:           // Cancel local dispatching
54603:           aEvent->flags |= NS_EVENT_FLAG_STOP_DISPATCH;
50731:         }
50731:       }
50731:     }
50731:     break;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: static PRInt32
    1: GetAccessModifierMask(nsISupports* aDocShell)
    1: {
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(aDocShell));
    1:   if (!treeItem)
    1:     return -1; // invalid modifier
    1: 
    1:   PRInt32 itemType;
    1:   treeItem->GetItemType(&itemType);
    1:   switch (itemType) {
    1: 
    1:   case nsIDocShellTreeItem::typeChrome:
    1:     return sChromeAccessModifier;
    1: 
    1:   case nsIDocShellTreeItem::typeContent:
    1:     return sContentAccessModifier;
    1: 
    1:   default:
    1:     return -1; // invalid modifier
    1:   }
    1: }
    1: 
79445: static bool
14328: IsAccessKeyTarget(nsIContent* aContent, nsIFrame* aFrame, nsAString& aKey)
 8407: {
23192:   if (!aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::accesskey, aKey,
23192:                              eIgnoreCase))
80486:     return false;
23192: 
23192:   nsCOMPtr<nsIDOMXULDocument> xulDoc =
80526:     do_QueryInterface(aContent->OwnerDoc());
33329:   if (!xulDoc && !aContent->IsXUL())
80486:     return true;
23192: 
23192:     // For XUL we do visibility checks.
 8407:   if (!aFrame)
80486:     return false;
 8407: 
 8407:   if (aFrame->IsFocusable())
80486:     return true;
 8407: 
80910:   if (!aFrame->IsVisibleConsideringAncestors())
80486:     return false;
 8407: 
23192:   // XUL controls can be activated.
 8407:   nsCOMPtr<nsIDOMXULControlElement> control(do_QueryInterface(aContent));
 8407:   if (control)
80486:     return true;
 8407: 
33329:   if (aContent->IsHTML()) {
15065:     nsIAtom* tag = aContent->Tag();
15065: 
15065:     // HTML area, label and legend elements are never focusable, so
15065:     // we need to check for them explicitly before giving up.
15065:     if (tag == nsGkAtoms::area ||
15065:         tag == nsGkAtoms::label ||
15065:         tag == nsGkAtoms::legend)
80486:       return true;
30176: 
33329:   } else if (aContent->IsXUL()) {
30176:     // XUL label elements are never focusable, so we need to check for them
30176:     // explicitly before giving up.
30176:     if (aContent->Tag() == nsGkAtoms::label)
80486:       return true;
80486:   }
80486: 
80486:   return false;
 8407: }
 8407: 
79445: bool
14328: nsEventStateManager::ExecuteAccessKey(nsTArray<PRUint32>& aAccessCharCodes,
79445:                                       bool aIsTrustedEvent)
14328: {
14328:   PRInt32 count, start = -1;
29018:   nsIContent* focusedContent = GetFocusedContent();
29018:   if (focusedContent) {
29018:     start = mAccessKeys.IndexOf(focusedContent);
29018:     if (start == -1 && focusedContent->GetBindingParent())
29018:       start = mAccessKeys.IndexOf(focusedContent->GetBindingParent());
14328:   }
14328:   nsIContent *content;
14328:   nsIFrame *frame;
14328:   PRInt32 length = mAccessKeys.Count();
14328:   for (PRUint32 i = 0; i < aAccessCharCodes.Length(); ++i) {
14328:     PRUint32 ch = aAccessCharCodes[i];
14328:     nsAutoString accessKey;
14328:     AppendUCS4ToUTF16(ch, accessKey);
14328:     for (count = 1; count <= length; ++count) {
14328:       content = mAccessKeys[(start + count) % length];
36655:       frame = content->GetPrimaryFrame();
14328:       if (IsAccessKeyTarget(content, frame, accessKey)) {
79445:         bool shouldActivate = sKeyCausesActivation;
14328:         while (shouldActivate && ++count <= length) {
14328:           nsIContent *oc = mAccessKeys[(start + count) % length];
36655:           nsIFrame *of = oc->GetPrimaryFrame();
14328:           if (IsAccessKeyTarget(oc, of, accessKey))
80486:             shouldActivate = false;
14328:         }
14328:         if (shouldActivate)
14328:           content->PerformAccesskey(shouldActivate, aIsTrustedEvent);
29018:         else {
29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:           if (fm) {
29018:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(content);
29018:             fm->SetFocus(element, nsIFocusManager::FLAG_BYKEY);
29018:           }
29018:         }
80486:         return true;
80486:       }
80486:     }
80486:   }
80486:   return false;
14328: }
14328: 
79445: bool
74612: nsEventStateManager::GetAccessKeyLabelPrefix(nsAString& aPrefix)
74612: {
74612:   aPrefix.Truncate();
74612:   nsAutoString separator, modifierText;
74612:   nsContentUtils::GetModifierSeparatorText(separator);
74612: 
74612:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
74612:   PRInt32 modifier = GetAccessModifierMask(container);
74612: 
74612:   if (modifier & NS_MODIFIER_CONTROL) {
74612:     nsContentUtils::GetControlText(modifierText);
74612:     aPrefix.Append(modifierText + separator);
74612:   }
74612:   if (modifier & NS_MODIFIER_META) {
74612:     nsContentUtils::GetMetaText(modifierText);
74612:     aPrefix.Append(modifierText + separator);
74612:   }
74612:   if (modifier & NS_MODIFIER_ALT) {
74612:     nsContentUtils::GetAltText(modifierText);
74612:     aPrefix.Append(modifierText + separator);
74612:   }
74612:   if (modifier & NS_MODIFIER_SHIFT) {
74612:     nsContentUtils::GetShiftText(modifierText);
74612:     aPrefix.Append(modifierText + separator);
74612:   }
74612:   return !aPrefix.IsEmpty();
74612: }
74612: 
    1: void
    1: nsEventStateManager::HandleAccessKey(nsPresContext* aPresContext,
    1:                                      nsKeyEvent *aEvent,
    1:                                      nsEventStatus* aStatus,
 1585:                                      nsIDocShellTreeItem* aBubbledFrom,
    1:                                      ProcessingAccessKeyState aAccessKeyState,
    1:                                      PRInt32 aModifierMask)
    1: {
    1:   nsCOMPtr<nsISupports> pcContainer = aPresContext->GetContainer();
    1: 
    1:   // Alt or other accesskey modifier is down, we may need to do an accesskey
14328:   if (mAccessKeys.Count() > 0 &&
14328:       aModifierMask == GetAccessModifierMask(pcContainer)) {
    1:     // Someone registered an accesskey.  Find and activate it.
79445:     bool isTrusted = NS_IS_TRUSTED_EVENT(aEvent);
14328:     nsAutoTArray<PRUint32, 10> accessCharCodes;
14328:     nsContentUtils::GetAccessKeyCandidates(aEvent, accessCharCodes);
14328:     if (ExecuteAccessKey(accessCharCodes, isTrusted)) {
    1:       *aStatus = nsEventStatus_eConsumeNoDefault;
14328:       return;
    1:     }
    1:   }
    1: 
    1:   // after the local accesskey handling
    1:   if (nsEventStatus_eConsumeNoDefault != *aStatus) {
    1:     // checking all sub docshells
    1: 
    1:     nsCOMPtr<nsIDocShellTreeNode> docShell(do_QueryInterface(pcContainer));
    1:     if (!docShell) {
    1:       NS_WARNING("no docShellTreeNode for presContext");
    1:       return;
    1:     }
    1: 
    1:     PRInt32 childCount;
    1:     docShell->GetChildCount(&childCount);
    1:     for (PRInt32 counter = 0; counter < childCount; counter++) {
    1:       // Not processing the child which bubbles up the handling
 1585:       nsCOMPtr<nsIDocShellTreeItem> subShellItem;
 1585:       docShell->GetChildAt(counter, getter_AddRefs(subShellItem));
 1585:       if (aAccessKeyState == eAccessKeyProcessingUp &&
 1585:           subShellItem == aBubbledFrom)
    1:         continue;
    1: 
    1:       nsCOMPtr<nsIDocShell> subDS = do_QueryInterface(subShellItem);
    1:       if (subDS && IsShellVisible(subDS)) {
 1585:         nsCOMPtr<nsIPresShell> subPS;
    1:         subDS->GetPresShell(getter_AddRefs(subPS));
    1: 
    1:         // Docshells need not have a presshell (eg. display:none
    1:         // iframes, docshells in transition between documents, etc).
    1:         if (!subPS) {
    1:           // Oh, well.  Just move on to the next child
    1:           continue;
    1:         }
    1: 
    1:         nsPresContext *subPC = subPS->GetPresContext();
    1: 
    1:         nsEventStateManager* esm =
 3233:           static_cast<nsEventStateManager *>(subPC->EventStateManager());
    1: 
    1:         if (esm)
 1585:           esm->HandleAccessKey(subPC, aEvent, aStatus, nsnull,
    1:                                eAccessKeyProcessingDown, aModifierMask);
    1: 
    1:         if (nsEventStatus_eConsumeNoDefault == *aStatus)
    1:           break;
    1:       }
    1:     }
    1:   }// if end . checking all sub docshell ends here.
    1: 
 1585:   // bubble up the process to the parent docshell if necessary
    1:   if (eAccessKeyProcessingDown != aAccessKeyState && nsEventStatus_eConsumeNoDefault != *aStatus) {
    1:     nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryInterface(pcContainer));
    1:     if (!docShell) {
 1585:       NS_WARNING("no docShellTreeItem for presContext");
    1:       return;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parentShellItem;
    1:     docShell->GetParent(getter_AddRefs(parentShellItem));
    1:     nsCOMPtr<nsIDocShell> parentDS = do_QueryInterface(parentShellItem);
    1:     if (parentDS) {
    1:       nsCOMPtr<nsIPresShell> parentPS;
    1: 
    1:       parentDS->GetPresShell(getter_AddRefs(parentPS));
    1:       NS_ASSERTION(parentPS, "Our PresShell exists but the parent's does not?");
    1: 
    1:       nsPresContext *parentPC = parentPS->GetPresContext();
    1:       NS_ASSERTION(parentPC, "PresShell without PresContext");
    1: 
    1:       nsEventStateManager* esm =
 3233:         static_cast<nsEventStateManager *>(parentPC->EventStateManager());
    1: 
    1:       if (esm)
 1585:         esm->HandleAccessKey(parentPC, aEvent, aStatus, docShell,
    1:                              eAccessKeyProcessingUp, aModifierMask);
    1:     }
    1:   }// if end. bubble up process
    1: }// end of HandleAccessKey
    1: 
73592: void
73592: nsEventStateManager::DispatchCrossProcessEvent(nsEvent* aEvent, nsIFrameLoader* frameLoader) {
73592:   nsFrameLoader* fml = static_cast<nsFrameLoader*>(frameLoader);
73592:   PBrowserParent* remoteBrowser = fml->GetRemoteBrowser();
73592:   TabParent* remote = static_cast<TabParent*>(remoteBrowser);
73592:   if (!remote) {
73592:     return;
73592:   }
73592: 
73592:   if (aEvent->eventStructType == NS_MOUSE_EVENT) {
73592:     nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(aEvent);
73592:     remote->SendRealMouseEvent(*mouseEvent);
73592:   }
73592: 
73592:   if (aEvent->eventStructType == NS_KEY_EVENT) {
73592:     nsKeyEvent* keyEvent = static_cast<nsKeyEvent*>(aEvent);
73592:     remote->SendRealKeyEvent(*keyEvent);
73592:   }
73592: 
73592:   if (aEvent->eventStructType == NS_MOUSE_SCROLL_EVENT) {
73592:     nsMouseScrollEvent* scrollEvent = static_cast<nsMouseScrollEvent*>(aEvent);
73592:     remote->SendMouseScrollEvent(*scrollEvent);
73592:   }
73592: }
73592: 
79445: bool
73592: nsEventStateManager::IsRemoteTarget(nsIContent* target) {
73592:   return target &&
80649:          (target->Tag() == nsGkAtoms::browser ||
80649:           target->Tag() == nsGkAtoms::iframe) &&
73592:          target->IsXUL() &&
73592:          target->AttrValueIs(kNameSpaceID_None, nsGkAtoms::Remote,
73592:                              nsGkAtoms::_true, eIgnoreCase);
73592: }
73592: 
73592: 
79445: bool
73592: nsEventStateManager::HandleCrossProcessEvent(nsEvent *aEvent,
73592:                                              nsIFrame* aTargetFrame,
73592:                                              nsEventStatus *aStatus) {
73592: 
73592:   switch (aEvent->eventStructType) {
73592:     case NS_KEY_EVENT:
73592:     case NS_MOUSE_SCROLL_EVENT:
73592:       break;
73592:     case NS_MOUSE_EVENT:
73592:       if (aEvent->message == NS_MOUSE_BUTTON_DOWN ||
73592:           aEvent->message == NS_MOUSE_BUTTON_UP ||
73592:           aEvent->message == NS_MOUSE_MOVE) {
73592:         break;
73592:       }
73592:     default:
80486:       return false;
73592:   }
73592: 
73592:   nsIContent* target = mCurrentTargetContent;
73592:   if (!target && aTargetFrame) {
73592:     target = aTargetFrame->GetContent();
73592:   }
73592: 
73592:   if (*aStatus == nsEventStatus_eConsumeNoDefault ||
73592:       !target ||
73592:       !IsRemoteTarget(target)) {
80486:     return false;
73592:   }
73592: 
73592:   nsCOMPtr<nsIFrameLoaderOwner> loaderOwner = do_QueryInterface(target);
73592:   if (!loaderOwner) {
80486:     return false;
73592:   }
73592: 
73592:   nsRefPtr<nsFrameLoader> frameLoader = loaderOwner->GetFrameLoader();
73592:   if (!frameLoader) {
80486:     return false;
73592:   }
73592: 
73592:   PRUint32 eventMode;
73592:   frameLoader->GetEventMode(&eventMode);
73592:   if (eventMode == nsIFrameLoader::EVENT_MODE_DONT_FORWARD_TO_CHILD) {
80486:     return false;
73592:   }
73592: 
73592:   nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, aTargetFrame);
73592:   aEvent->refPoint = pt.ToNearestPixels(mPresContext->AppUnitsPerDevPixel());
73592: 
73592:   DispatchCrossProcessEvent(aEvent, frameLoader);
80486:   return true;
73592: }
    1: 
    1: //
    1: // CreateClickHoldTimer
    1: //
    1: // Fire off a timer for determining if the user wants click-hold. This timer
    1: // is a one-shot that will be cancelled when the user moves enough to fire
    1: // a drag.
    1: //
    1: void
    1: nsEventStateManager::CreateClickHoldTimer(nsPresContext* inPresContext,
    1:                                           nsIFrame* inDownFrame,
    1:                                           nsGUIEvent* inMouseDownEvent)
    1: {
    1:   if (!NS_IS_TRUSTED_EVENT(inMouseDownEvent))
    1:     return;
    1: 
    1:   // just to be anal (er, safe)
    1:   if (mClickHoldTimer) {
    1:     mClickHoldTimer->Cancel();
    1:     mClickHoldTimer = nsnull;
    1:   }
    1: 
    1:   // if content clicked on has a popup, don't even start the timer
    1:   // since we'll end up conflicting and both will show.
    1:   if (mGestureDownContent) {
    1:     // check for the |popup| attribute
    1:     if (nsContentUtils::HasNonEmptyAttr(mGestureDownContent, kNameSpaceID_None,
    1:                                         nsGkAtoms::popup))
    1:       return;
    1:     
    1:     // check for a <menubutton> like bookmarks
    1:     if (mGestureDownContent->Tag() == nsGkAtoms::menubutton)
    1:       return;
    1:   }
    1: 
    1:   mClickHoldTimer = do_CreateInstance("@mozilla.org/timer;1");
43674:   if (mClickHoldTimer) {
43674:     PRInt32 clickHoldDelay =
70842:       Preferences::GetInt("ui.click_hold_context_menus.delay", 500);
    1:     mClickHoldTimer->InitWithFuncCallback(sClickHoldCallback, this,
43674:                                           clickHoldDelay,
    1:                                           nsITimer::TYPE_ONE_SHOT);
43674:   }
    1: } // CreateClickHoldTimer
    1: 
    1: 
    1: //
    1: // KillClickHoldTimer
    1: //
    1: // Stop the timer that would show the context menu dead in its tracks
    1: //
    1: void
    1: nsEventStateManager::KillClickHoldTimer()
    1: {
    1:   if (mClickHoldTimer) {
    1:     mClickHoldTimer->Cancel();
    1:     mClickHoldTimer = nsnull;
    1:   }
    1: }
    1: 
    1: 
    1: //
    1: // sClickHoldCallback
    1: //
    1: // This fires after the mouse has been down for a certain length of time.
    1: //
    1: void
    1: nsEventStateManager::sClickHoldCallback(nsITimer *aTimer, void* aESM)
    1: {
 3233:   nsEventStateManager* self = static_cast<nsEventStateManager*>(aESM);
    1:   if (self)
    1:     self->FireContextClick();
    1: 
    1:   // NOTE: |aTimer| and |self->mAutoHideTimer| are invalid after calling ClosePopup();
    1: 
    1: } // sAutoHideCallback
    1: 
    1: 
    1: //
    1: // FireContextClick
    1: //
    1: // If we're this far, our timer has fired, which means the mouse has been down
    1: // for a certain period of time and has not moved enough to generate a dragGesture.
    1: // We can be certain the user wants a context-click at this stage, so generate
    1: // a dom event and fire it in.
    1: //
    1: // After the event fires, check if PreventDefault() has been set on the event which
    1: // means that someone either ate the event or put up a context menu. This is our cue
    1: // to stop tracking the drag gesture. If we always did this, draggable items w/out
    1: // a context menu wouldn't be draggable after a certain length of time, which is
    1: // _not_ what we want.
    1: //
    1: void
    1: nsEventStateManager::FireContextClick()
    1: {
    1:   if (!mGestureDownContent)
    1:     return;
    1: 
    1: #ifdef XP_MACOSX
32855:   // Hack to ensure that we don't show a context menu when the user
32855:   // let go of the mouse after a long cpu-hogging operation prevented
    1:   // us from handling any OS events. See bug 117589.
32855:   if (!CGEventSourceButtonState(kCGEventSourceStateCombinedSessionState, kCGMouseButtonLeft))
    1:     return;
    1: #endif
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1: 
    1:   // Dispatch to the DOM. We have to fake out the ESM and tell it that the
    1:   // current target frame is actually where the mouseDown occurred, otherwise it
    1:   // will use the frame the mouse is currently over which may or may not be
    1:   // the same. (Note: saari and I have decided that we don't have to reset |mCurrentTarget|
    1:   // when we're through because no one else is doing anything more with this
    1:   // event and it will get reset on the very next event to the correct frame).
36655:   mCurrentTarget = mPresContext->GetPrimaryFrameFor(mGestureDownContent);
    1:   if (mCurrentTarget) {
  238:     NS_ASSERTION(mPresContext == mCurrentTarget->PresContext(),
    1:                  "a prescontext returned a primary frame that didn't belong to it?");
    1: 
    1:     // before dispatching, check that we're not on something that
    1:     // doesn't get a context menu
    1:     nsIAtom *tag = mGestureDownContent->Tag();
79445:     bool allowedToDispatch = true;
    1: 
33329:     if (mGestureDownContent->IsXUL()) {
    1:       if (tag == nsGkAtoms::scrollbar ||
    1:           tag == nsGkAtoms::scrollbarbutton ||
    1:           tag == nsGkAtoms::button)
80486:         allowedToDispatch = false;
    1:       else if (tag == nsGkAtoms::toolbarbutton) {
    1:         // a <toolbarbutton> that has the container attribute set
    1:         // will already have its own dropdown.
    1:         if (nsContentUtils::HasNonEmptyAttr(mGestureDownContent,
    1:                 kNameSpaceID_None, nsGkAtoms::container)) {
80486:           allowedToDispatch = false;
    1:         } else {
    1:           // If the toolbar button has an open menu, don't attempt to open
    1:             // a second menu
    1:           if (mGestureDownContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::open,
    1:                                                nsGkAtoms::_true, eCaseMatters)) {
80486:             allowedToDispatch = false;
    1:           }
    1:         }
    1:       }
    1:     }
33329:     else if (mGestureDownContent->IsHTML()) {
    1:       nsCOMPtr<nsIFormControl> formCtrl(do_QueryInterface(mGestureDownContent));
    1: 
    1:       if (formCtrl) {
    1:         // of all form controls, only ones dealing with text are
    1:         // allowed to have context menus
    1:         PRInt32 type = formCtrl->GetType();
    1: 
    1:         allowedToDispatch = (type == NS_FORM_INPUT_TEXT ||
50907:                              type == NS_FORM_INPUT_EMAIL ||
42372:                              type == NS_FORM_INPUT_SEARCH ||
42192:                              type == NS_FORM_INPUT_TEL ||
50909:                              type == NS_FORM_INPUT_URL ||
    1:                              type == NS_FORM_INPUT_PASSWORD ||
    1:                              type == NS_FORM_INPUT_FILE ||
    1:                              type == NS_FORM_TEXTAREA);
    1:       }
    1:       else if (tag == nsGkAtoms::applet ||
    1:                tag == nsGkAtoms::embed  ||
    1:                tag == nsGkAtoms::object) {
80486:         allowedToDispatch = false;
    1:       }
    1:     }
    1: 
    1:     if (allowedToDispatch) {
    1:       // make sure the widget sticks around
47148:       nsCOMPtr<nsIWidget> targetWidget(mCurrentTarget->GetNearestWidget());
    1:       // init the event while mCurrentTarget is still good
80486:       nsMouseEvent event(true, NS_CONTEXTMENU,
    1:                          targetWidget,
    1:                          nsMouseEvent::eReal);
    1:       event.clickCount = 1;
    1:       FillInEventFromGestureDown(&event);
    1:         
    1:       // stop selection tracking, we're in control now
    1:       if (mCurrentTarget)
    1:       {
70097:         nsRefPtr<nsFrameSelection> frameSel =
 8295:           mCurrentTarget->GetFrameSelection();
    1:         
    1:         if (frameSel && frameSel->GetMouseDownState()) {
    1:           // note that this can cause selection changed events to fire if we're in
    1:           // a text field, which will null out mCurrentTarget
80486:           frameSel->SetMouseDownState(false);
    1:         }
    1:       }
    1: 
    1:       // dispatch to DOM
    1:       nsEventDispatcher::Dispatch(mGestureDownContent, mPresContext, &event,
    1:                                   nsnull, &status);
    1: 
    1:       // We don't need to dispatch to frame handling because no frames
    1:       // watch NS_CONTEXTMENU except for nsMenuFrame and that's only for
    1:       // dismissal. That's just as well since we don't really know
    1:       // which frame to send it to.
    1:     }
    1:   }
    1: 
    1:   // now check if the event has been handled. If so, stop tracking a drag
    1:   if (status == nsEventStatus_eConsumeNoDefault) {
    1:     StopTrackingDragGesture();
    1:   }
    1: 
    1:   KillClickHoldTimer();
    1: 
    1: } // FireContextClick
    1: 
    1: 
    1: //
    1: // BeginTrackingDragGesture
    1: //
    1: // Record that the mouse has gone down and that we should move to TRACKING state
    1: // of d&d gesture tracker.
    1: //
43674: // We also use this to track click-hold context menus. When the mouse goes down,
    1: // fire off a short timer. If the timer goes off and we have yet to fire the
    1: // drag gesture (ie, the mouse hasn't moved a certain distance), then we can
    1: // assume the user wants a click-hold, so fire a context-click event. We only
    1: // want to cancel the drag gesture if the context-click event is handled.
    1: //
    1: void
    1: nsEventStateManager::BeginTrackingDragGesture(nsPresContext* aPresContext,
    1:                                               nsMouseEvent* inDownEvent,
    1:                                               nsIFrame* inDownFrame)
    1: {
43674:   if (!inDownEvent->widget)
43674:     return;
43674: 
    1:   // Note that |inDownEvent| could be either a mouse down event or a
    1:   // synthesized mouse move event.
25183:   mGestureDownPoint = inDownEvent->refPoint +
25183:     inDownEvent->widget->WidgetToScreenOffset();
    1: 
79435:   inDownFrame->GetContentForEvent(inDownEvent,
    1:                                   getter_AddRefs(mGestureDownContent));
    1: 
    1:   mGestureDownFrameOwner = inDownFrame->GetContent();
    1:   mGestureDownShift = inDownEvent->isShift;
    1:   mGestureDownControl = inDownEvent->isControl;
    1:   mGestureDownAlt = inDownEvent->isAlt;
    1:   mGestureDownMeta = inDownEvent->isMeta;
    1: 
43674:   if (mClickHoldContextMenu) {
    1:     // fire off a timer to track click-hold
    1:     CreateClickHoldTimer(aPresContext, inDownFrame, inDownEvent);
43674:   }
    1: }
    1: 
    1: 
    1: //
    1: // StopTrackingDragGesture
    1: //
    1: // Record that the mouse has gone back up so that we should leave the TRACKING
    1: // state of d&d gesture tracker and return to the START state.
    1: //
    1: void
    1: nsEventStateManager::StopTrackingDragGesture()
    1: {
    1:   mGestureDownContent = nsnull;
    1:   mGestureDownFrameOwner = nsnull;
    1: }
    1: 
    1: void
    1: nsEventStateManager::FillInEventFromGestureDown(nsMouseEvent* aEvent)
    1: {
47148:   NS_ASSERTION(aEvent->widget == mCurrentTarget->GetNearestWidget(),
    1:                "Incorrect widget in event");
    1: 
    1:   // Set the coordinates in the new event to the coordinates of
    1:   // the old event, adjusted for the fact that the widget might be
    1:   // different
25183:   nsIntPoint tmpPoint = aEvent->widget->WidgetToScreenOffset();
25183:   aEvent->refPoint = mGestureDownPoint - tmpPoint;
    1:   aEvent->isShift = mGestureDownShift;
    1:   aEvent->isControl = mGestureDownControl;
    1:   aEvent->isAlt = mGestureDownAlt;
    1:   aEvent->isMeta = mGestureDownMeta;
    1: }
    1: 
    1: //
    1: // GenerateDragGesture
    1: //
    1: // If we're in the TRACKING state of the d&d gesture tracker, check the current position
    1: // of the mouse in relation to the old one. If we've moved a sufficient amount from
    1: // the mouse down, then fire off a drag gesture event.
    1: void
    1: nsEventStateManager::GenerateDragGesture(nsPresContext* aPresContext,
    1:                                          nsMouseEvent *aEvent)
    1: {
    1:   NS_ASSERTION(aPresContext, "This shouldn't happen.");
    1:   if (IsTrackingDragGesture()) {
36655:     mCurrentTarget = mGestureDownFrameOwner->GetPrimaryFrame();
    1: 
    1:     if (!mCurrentTarget) {
    1:       StopTrackingDragGesture();
    1:       return;
    1:     }
    1: 
    1:     // Check if selection is tracking drag gestures, if so
    1:     // don't interfere!
    1:     if (mCurrentTarget)
    1:     {
70097:       nsRefPtr<nsFrameSelection> frameSel = mCurrentTarget->GetFrameSelection();
    1:       if (frameSel && frameSel->GetMouseDownState()) {
    1:         StopTrackingDragGesture();
    1:         return;
    1:       }
    1:     }
    1: 
37876:     // If non-native code is capturing the mouse don't start a drag.
37876:     if (nsIPresShell::IsMouseCapturePreventingDrag()) {
37876:       StopTrackingDragGesture();
37876:       return;
37876:     }
37876: 
    1:     static PRInt32 pixelThresholdX = 0;
    1:     static PRInt32 pixelThresholdY = 0;
    1: 
    1:     if (!pixelThresholdX) {
78124:       pixelThresholdX =
78124:         LookAndFeel::GetInt(LookAndFeel::eIntID_DragThresholdX, 0);
78124:       pixelThresholdY =
78124:         LookAndFeel::GetInt(LookAndFeel::eIntID_DragThresholdY, 0);
    1:       if (!pixelThresholdX)
    1:         pixelThresholdX = 5;
    1:       if (!pixelThresholdY)
    1:         pixelThresholdY = 5;
    1:     }
    1: 
    1:     // fire drag gesture if mouse has moved enough
25183:     nsIntPoint pt = aEvent->refPoint + aEvent->widget->WidgetToScreenOffset();
71173:     if (NS_ABS(pt.x - mGestureDownPoint.x) > pixelThresholdX ||
71173:         NS_ABS(pt.y - mGestureDownPoint.y) > pixelThresholdY) {
43674:       if (mClickHoldContextMenu) {
    1:         // stop the click-hold before we fire off the drag gesture, in case
    1:         // it takes a long time
    1:         KillClickHoldTimer();
43674:       }
    1: 
18445:       nsRefPtr<nsDOMDataTransfer> dataTransfer = new nsDOMDataTransfer();
18445:       if (!dataTransfer)
18445:         return;
18445: 
90375:       nsCOMPtr<nsISelection> selection;
18445:       nsCOMPtr<nsIContent> eventContent, targetContent;
79435:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(eventContent));
18445:       if (eventContent)
18445:         DetermineDragTarget(aPresContext, eventContent, dataTransfer,
90375:                             getter_AddRefs(selection), getter_AddRefs(targetContent));
18445: 
    1:       // Stop tracking the drag gesture now. This should stop us from
    1:       // reentering GenerateDragGesture inside DOM event processing.
    1:       StopTrackingDragGesture();
    1: 
18445:       if (!targetContent)
18445:         return;
18445: 
81998:       sLastDragOverFrame = nsnull;
47148:       nsCOMPtr<nsIWidget> widget = mCurrentTarget->GetNearestWidget();
  482: 
    1:       // get the widget from the target frame
18445:       nsDragEvent startEvent(NS_IS_TRUSTED_EVENT(aEvent), NS_DRAGDROP_START, widget);
18445:       FillInEventFromGestureDown(&startEvent);
18445: 
18445:       nsDragEvent gestureEvent(NS_IS_TRUSTED_EVENT(aEvent), NS_DRAGDROP_GESTURE, widget);
  482:       FillInEventFromGestureDown(&gestureEvent);
    1: 
18445:       startEvent.dataTransfer = gestureEvent.dataTransfer = dataTransfer;
40485:       startEvent.inputSource = gestureEvent.inputSource = aEvent->inputSource;
18445: 
    1:       // Dispatch to the DOM. By setting mCurrentTarget we are faking
    1:       // out the ESM and telling it that the current target frame is
    1:       // actually where the mouseDown occurred, otherwise it will use
    1:       // the frame the mouse is currently over which may or may not be
    1:       // the same. (Note: saari and I have decided that we don't have
    1:       // to reset |mCurrentTarget| when we're through because no one
    1:       // else is doing anything more with this event and it will get
    1:       // reset on the very next event to the correct frame).
    1: 
    1:       // Hold onto old target content through the event and reset after.
    1:       nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
    1: 
    1:       // Set the current target to the content for the mouse down
    1:       mCurrentTargetContent = targetContent;
    1: 
19703:       // Dispatch both the dragstart and draggesture events to the DOM. For
19703:       // elements in an editor, only fire the draggesture event so that the
19703:       // editor code can handle it but content doesn't see a dragstart.
  482:       nsEventStatus status = nsEventStatus_eIgnore;
18445:       nsEventDispatcher::Dispatch(targetContent, aPresContext, &startEvent, nsnull,
18445:                                   &status);
18445: 
18445:       nsDragEvent* event = &startEvent;
18445:       if (status != nsEventStatus_eConsumeNoDefault) {
18445:         status = nsEventStatus_eIgnore;
  482:         nsEventDispatcher::Dispatch(targetContent, aPresContext, &gestureEvent, nsnull,
  482:                                     &status);
18445:         event = &gestureEvent;
18445:       }
18445: 
18445:       // now that the dataTransfer has been updated in the dragstart and
18445:       // draggesture events, make it read only so that the data doesn't
18445:       // change during the drag.
18445:       dataTransfer->SetReadOnly();
18445: 
34683:       if (status != nsEventStatus_eConsumeNoDefault) {
79445:         bool dragStarted = DoDefaultDragStart(aPresContext, event, dataTransfer,
90375:                                               targetContent, selection);
34683:         if (dragStarted) {
56644:           sActiveESM = nsnull;
34683:           aEvent->flags |= NS_EVENT_FLAG_STOP_DISPATCH;
34683:         }
34683:       }
  482: 
    1:       // Note that frame event handling doesn't care about NS_DRAGDROP_GESTURE,
    1:       // which is just as well since we don't really know which frame to
    1:       // send it to
    1: 
    1:       // Reset mCurretTargetContent to what it was
    1:       mCurrentTargetContent = targetBeforeEvent;
    1:     }
    1: 
    1:     // Now flush all pending notifications, for better responsiveness
    1:     // while dragging.
    1:     FlushPendingEvents(aPresContext);
    1:   }
    1: } // GenerateDragGesture
    1: 
18445: void
18445: nsEventStateManager::DetermineDragTarget(nsPresContext* aPresContext,
18445:                                          nsIContent* aSelectionTarget,
18445:                                          nsDOMDataTransfer* aDataTransfer,
90375:                                          nsISelection** aSelection,
18445:                                          nsIContent** aTargetNode)
18445: {
18445:   *aTargetNode = nsnull;
18445: 
18445:   nsCOMPtr<nsISupports> container = aPresContext->GetContainer();
18445:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(container);
96238:   if (!window)
96238:     return;
18445: 
18445:   // GetDragData determines if a selection, link or image in the content
18445:   // should be dragged, and places the data associated with the drag in the
90375:   // data transfer.
90375:   // mGestureDownContent is the node where the mousedown event for the drag
90375:   // occurred, and aSelectionTarget is the node to use when a selection is used
79445:   bool canDrag;
18445:   nsCOMPtr<nsIContent> dragDataNode;
90375:   nsresult rv = nsContentAreaDragDrop::GetDragData(window, mGestureDownContent,
18445:                                                    aSelectionTarget, mGestureDownAlt,
90375:                                                    aDataTransfer, &canDrag, aSelection,
18445:                                                    getter_AddRefs(dragDataNode));
18445:   if (NS_FAILED(rv) || !canDrag)
18445:     return;
18445: 
18445:   // if GetDragData returned a node, use that as the node being dragged.
18445:   // Otherwise, if a selection is being dragged, use the node within the
18445:   // selection that was dragged. Otherwise, just use the mousedown target.
18445:   nsIContent* dragContent = mGestureDownContent;
18445:   if (dragDataNode)
18445:     dragContent = dragDataNode;
90375:   else if (*aSelection)
18445:     dragContent = aSelectionTarget;
18445: 
18445:   nsIContent* originalDragContent = dragContent;
18445: 
18445:   // If a selection isn't being dragged, look for an ancestor with the
18445:   // draggable property set. If one is found, use that as the target of the
18445:   // drag instead of the node that was clicked on. If a draggable node wasn't
18445:   // found, just use the clicked node.
90375:   if (!*aSelection) {
18445:     while (dragContent) {
81041:       nsCOMPtr<nsIDOMHTMLElement> htmlElement = do_QueryInterface(dragContent);
18445:       if (htmlElement) {
79445:         bool draggable = false;
18445:         htmlElement->GetDraggable(&draggable);
18445:         if (draggable)
18445:           break;
18445:       }
18445:       else {
18445:         nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(dragContent);
18445:         if (xulElement) {
18445:           // All XUL elements are draggable, so if a XUL element is
18445:           // encountered, stop looking for draggable nodes and just use the
18445:           // original clicked node instead.
18445:           // XXXndeakin
18445:           // In the future, we will want to improve this so that XUL has a
18445:           // better way to specify whether something is draggable than just
18445:           // on/off.
18445:           dragContent = mGestureDownContent;
18445:           break;
18445:         }
18445:         // otherwise, it's not an HTML or XUL element, so just keep looking
18445:       }
18445:       dragContent = dragContent->GetParent();
18445:     }
18445:   }
18445: 
18445:   // if no node in the hierarchy was found to drag, but the GetDragData method
18985:   // returned a node, use that returned node. Otherwise, nothing is draggable.
18985:   if (!dragContent && dragDataNode)
18985:     dragContent = dragDataNode;
18445: 
18445:   if (dragContent) {
18445:     // if an ancestor node was used instead, clear the drag data
18445:     // XXXndeakin rework this a bit. Find a way to just not call GetDragData if we don't need to.
18445:     if (dragContent != originalDragContent)
18445:       aDataTransfer->ClearAll();
18445:     *aTargetNode = dragContent;
18445:     NS_ADDREF(*aTargetNode);
18445:   }
18445: }
18445: 
79445: bool
18445: nsEventStateManager::DoDefaultDragStart(nsPresContext* aPresContext,
18445:                                         nsDragEvent* aDragEvent,
18445:                                         nsDOMDataTransfer* aDataTransfer,
18445:                                         nsIContent* aDragTarget,
90375:                                         nsISelection* aSelection)
18445: {
18445:   nsCOMPtr<nsIDragService> dragService =
18445:     do_GetService("@mozilla.org/widget/dragservice;1");
18445:   if (!dragService)
80486:     return false;
18445: 
18445:   // Default handling for the draggesture/dragstart event.
18445:   //
18445:   // First, check if a drag session already exists. This means that the drag
18445:   // service was called directly within a draggesture handler. In this case,
18445:   // don't do anything more, as it is assumed that the handler is managing
34683:   // drag and drop manually. Make sure to return true to indicate that a drag
34683:   // began.
18445:   nsCOMPtr<nsIDragSession> dragSession;
18445:   dragService->GetCurrentSession(getter_AddRefs(dragSession));
18445:   if (dragSession)
80486:     return true;
18445: 
18445:   // No drag session is currently active, so check if a handler added
18445:   // any items to be dragged. If not, there isn't anything to drag.
18445:   PRUint32 count = 0;
18445:   if (aDataTransfer)
18445:     aDataTransfer->GetMozItemCount(&count);
18445:   if (!count)
80486:     return false;
18445: 
18445:   // Get the target being dragged, which may not be the same as the
18445:   // target of the mouse event. If one wasn't set in the
18445:   // aDataTransfer during the event handler, just use the original
18445:   // target instead.
18445:   nsCOMPtr<nsIDOMNode> dragTarget;
18445:   nsCOMPtr<nsIDOMElement> dragTargetElement;
18445:   aDataTransfer->GetDragTarget(getter_AddRefs(dragTargetElement));
18445:   dragTarget = do_QueryInterface(dragTargetElement);
18445:   if (!dragTarget) {
18445:     dragTarget = do_QueryInterface(aDragTarget);
18445:     if (!dragTarget)
80486:       return false;
18445:   }
18445: 
18552:   // check which drag effect should initially be used. If the effect was not
18552:   // set, just use all actions, otherwise Windows won't allow a drop.
18552:   PRUint32 action;
18552:   aDataTransfer->GetEffectAllowedInt(&action);
18552:   if (action == nsIDragService::DRAGDROP_ACTION_UNINITIALIZED)
18552:     action = nsIDragService::DRAGDROP_ACTION_COPY |
18552:              nsIDragService::DRAGDROP_ACTION_MOVE |
18552:              nsIDragService::DRAGDROP_ACTION_LINK;
18445: 
18445:   // get any custom drag image that was set
18445:   PRInt32 imageX, imageY;
18445:   nsIDOMElement* dragImage = aDataTransfer->GetDragImage(&imageX, &imageY);
18445: 
18445:   nsCOMPtr<nsISupportsArray> transArray;
18445:   aDataTransfer->GetTransferables(getter_AddRefs(transArray));
18445:   if (!transArray)
80486:     return false;
18445: 
18445:   // XXXndeakin don't really want to create a new drag DOM event
18445:   // here, but we need something to pass to the InvokeDragSession
18445:   // methods.
18445:   nsCOMPtr<nsIDOMEvent> domEvent;
18445:   NS_NewDOMDragEvent(getter_AddRefs(domEvent), aPresContext, aDragEvent);
18445: 
18445:   nsCOMPtr<nsIDOMDragEvent> domDragEvent = do_QueryInterface(domEvent);
18445:   // if creating a drag event failed, starting a drag session will
18445:   // just fail.
90375: 
90375:   // Use InvokeDragSessionWithSelection if a selection is being dragged,
90375:   // such that the image can be generated from the selected text. However,
90375:   // use InvokeDragSessionWithImage if a custom image was set or something
90375:   // other than a selection is being dragged.
90375:   if (!dragImage && aSelection) {
90375:     dragService->InvokeDragSessionWithSelection(aSelection, transArray,
18445:                                                 action, domDragEvent,
18445:                                                 aDataTransfer);
18445:   }
18445:   else {
18445:     // if dragging within a XUL tree and no custom drag image was
18445:     // set, the region argument to InvokeDragSessionWithImage needs
18445:     // to be set to the area encompassing the selected rows of the
18445:     // tree to ensure that the drag feedback gets clipped to those
18445:     // rows. For other content, region should be null.
18445:     nsCOMPtr<nsIScriptableRegion> region;
18445: #ifdef MOZ_XUL
18445:     if (dragTarget && !dragImage) {
18445:       nsCOMPtr<nsIContent> content = do_QueryInterface(dragTarget);
18445:       if (content->NodeInfo()->Equals(nsGkAtoms::treechildren,
18445:                                       kNameSpaceID_XUL)) {
36655:         nsTreeBodyFrame* treeBody = do_QueryFrame(content->GetPrimaryFrame());
36655:         if (treeBody) {
20988:           treeBody->GetSelectionRegion(getter_AddRefs(region));
18445:         }
18445:       }
18445:     }
18445: #endif
18445: 
18445:     dragService->InvokeDragSessionWithImage(dragTarget, transArray,
18445:                                             region, action, dragImage,
18445:                                             imageX, imageY, domDragEvent,
18445:                                             aDataTransfer);
18445:   }
34683: 
80486:   return true;
18445: }
18445: 
    1: nsresult
 7251: nsEventStateManager::GetMarkupDocumentViewer(nsIMarkupDocumentViewer** aMv)
    1: {
 7251:   *aMv = nsnull;
 7251: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if(!fm) return NS_ERROR_FAILURE;
29018: 
29018:   nsCOMPtr<nsIDOMWindow> focusedWindow;
29018:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> ourWindow = do_QueryInterface(focusedWindow);
    1:   if(!ourWindow) return NS_ERROR_FAILURE;
    1: 
73870:   nsIDOMWindow *rootWindow = ourWindow->GetPrivateRoot();
    1:   if(!rootWindow) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMWindow> contentWindow;
    1:   rootWindow->GetContent(getter_AddRefs(contentWindow));
    1:   if(!contentWindow) return NS_ERROR_FAILURE;
    1: 
    1:   nsIDocument *doc = GetDocumentFromWindow(contentWindow);
    1:   if(!doc) return NS_ERROR_FAILURE;
    1: 
46225:   nsIPresShell *presShell = doc->GetShell();
    1:   if(!presShell) return NS_ERROR_FAILURE;
    1:   nsPresContext *presContext = presShell->GetPresContext();
    1:   if(!presContext) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsISupports> pcContainer = presContext->GetContainer();
    1:   if(!pcContainer) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDocShell> docshell(do_QueryInterface(pcContainer));
    1:   if(!docshell) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIContentViewer> cv;
    1:   docshell->GetContentViewer(getter_AddRefs(cv));
    1:   if(!cv) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIMarkupDocumentViewer> mv(do_QueryInterface(cv));
    1:   if(!mv) return NS_ERROR_FAILURE;
    1: 
 7251:   *aMv = mv;
 7251:   NS_IF_ADDREF(*aMv);
 7251: 
 7251:   return NS_OK;
 7251: }
 7251: 
 7251: nsresult
 7251: nsEventStateManager::ChangeTextSize(PRInt32 change)
 7251: {
 7251:   nsCOMPtr<nsIMarkupDocumentViewer> mv;
 7251:   nsresult rv = GetMarkupDocumentViewer(getter_AddRefs(mv));
 7251:   NS_ENSURE_SUCCESS(rv, rv);
 7251: 
 7251:   float textzoom;
70842:   float zoomMin = ((float)Preferences::GetInt("zoom.minPercent", 50)) / 100;
70842:   float zoomMax = ((float)Preferences::GetInt("zoom.maxPercent", 300)) / 100;
 7251:   mv->GetTextZoom(&textzoom);
 7251:   textzoom += ((float)change) / 10;
20751:   if (textzoom < zoomMin)
20751:     textzoom = zoomMin;
20751:   else if (textzoom > zoomMax)
20751:     textzoom = zoomMax;
 7251:   mv->SetTextZoom(textzoom);
 7251: 
 7251:   return NS_OK;
 7251: }
 7251: 
 7251: nsresult
 7251: nsEventStateManager::ChangeFullZoom(PRInt32 change)
 7251: {
 7251:   nsCOMPtr<nsIMarkupDocumentViewer> mv;
 7251:   nsresult rv = GetMarkupDocumentViewer(getter_AddRefs(mv));
 7251:   NS_ENSURE_SUCCESS(rv, rv);
 7251: 
 7187:   float fullzoom;
70842:   float zoomMin = ((float)Preferences::GetInt("zoom.minPercent", 50)) / 100;
70842:   float zoomMax = ((float)Preferences::GetInt("zoom.maxPercent", 300)) / 100;
 7187:   mv->GetFullZoom(&fullzoom);
 7187:   fullzoom += ((float)change) / 10;
 7187:   if (fullzoom < zoomMin)
 7187:     fullzoom = zoomMin;
 7187:   else if (fullzoom > zoomMax)
 7187:     fullzoom = zoomMax;
 7187:   mv->SetFullZoom(fullzoom);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsEventStateManager::DoScrollHistory(PRInt32 direction)
    1: {
    1:   nsCOMPtr<nsISupports> pcContainer(mPresContext->GetContainer());
    1:   if (pcContainer) {
    1:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(pcContainer));
    1:     if (webNav) {
    1:       // positive direction to go back one step, nonpositive to go forward
    1:       if (direction > 0)
    1:         webNav->GoBack();
    1:       else
    1:         webNav->GoForward();
    1:     }
    1:   }
    1: }
    1: 
    1: void
11660: nsEventStateManager::DoScrollZoom(nsIFrame *aTargetFrame,
 7251:                                   PRInt32 adjustment)
 7251: {
 7251:   // Exclude form controls and XUL content.
 7251:   nsIContent *content = aTargetFrame->GetContent();
 7251:   if (content &&
 7251:       !content->IsNodeOfType(nsINode::eHTML_FORM_CONTROL) &&
33329:       !content->IsXUL())
 7251:     {
11660:       // positive adjustment to decrease zoom, negative to increase
11660:       PRInt32 change = (adjustment > 0) ? -1 : 1;
11660: 
88004:       if (Preferences::GetBool("browser.zoom.full") || content->GetCurrentDoc()->IsSyntheticDocument()) {
11660:         ChangeFullZoom(change);
70840:       } else {
11660:         ChangeTextSize(change);
    1:       }
    1:     }
70840: }
    1: 
    1: static nsIFrame*
37058: GetParentFrameToScroll(nsIFrame* aFrame)
    1: {
37058:   if (!aFrame)
    1:     return nsnull;
    1: 
21930:   if (aFrame->GetStyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED &&
21930:       nsLayoutUtils::IsReallyFixedPos(aFrame))
37058:     return aFrame->PresContext()->GetPresShell()->GetRootScrollFrame();
    1: 
    1:   return aFrame->GetParent();
    1: }
    1: 
37061: static nscoord
37061: GetScrollableLineHeight(nsIFrame* aTargetFrame)
19319: {
37061:   for (nsIFrame* f = aTargetFrame; f; f = GetParentFrameToScroll(f)) {
37061:     nsIScrollableFrame* sf = f->GetScrollTargetFrame();
37061:     if (sf)
37061:       return sf->GetLineScrollAmount().height;
37061:   }
37061: 
19319:   // Fall back to the font height of the target frame.
76294:   nsRefPtr<nsFontMetrics> fm;
82681:   nsLayoutUtils::GetFontMetricsForFrame(aTargetFrame, getter_AddRefs(fm),
88124:     nsLayoutUtils::FontSizeInflationFor(aTargetFrame,
88124:                                         nsLayoutUtils::eNotInReflow));
19319:   NS_ASSERTION(fm, "FontMetrics is null!");
19319:   if (fm)
68495:     return fm->MaxHeight();
68495:   return 0;
26874: }
26874: 
26874: void
26874: nsEventStateManager::SendLineScrollEvent(nsIFrame* aTargetFrame,
26874:                                          nsMouseScrollEvent* aEvent,
26874:                                          nsPresContext* aPresContext,
26874:                                          nsEventStatus* aStatus,
26874:                                          PRInt32 aNumLines)
26874: {
26874:   nsCOMPtr<nsIContent> targetContent = aTargetFrame->GetContent();
26874:   if (!targetContent)
29018:     targetContent = GetFocusedContent();
26874:   if (!targetContent)
26874:     return;
26874: 
26874:   while (targetContent->IsNodeOfType(nsINode::eTEXT)) {
26874:     targetContent = targetContent->GetParent();
26874:   }
26874: 
79445:   bool isTrusted = (aEvent->flags & NS_EVENT_FLAG_TRUSTED) != 0;
26874:   nsMouseScrollEvent event(isTrusted, NS_MOUSE_SCROLL, nsnull);
26874:   event.refPoint = aEvent->refPoint;
26874:   event.widget = aEvent->widget;
26874:   event.time = aEvent->time;
26874:   event.isShift = aEvent->isShift;
26874:   event.isControl = aEvent->isControl;
26874:   event.isAlt = aEvent->isAlt;
26874:   event.isMeta = aEvent->isMeta;
26874:   event.scrollFlags = aEvent->scrollFlags;
26874:   event.delta = aNumLines;
40485:   event.inputSource = static_cast<nsMouseEvent_base*>(aEvent)->inputSource;
26874: 
26874:   nsEventDispatcher::Dispatch(targetContent, aPresContext, &event, nsnull, aStatus);
26874: }
26874: 
26874: void
26874: nsEventStateManager::SendPixelScrollEvent(nsIFrame* aTargetFrame,
26874:                                           nsMouseScrollEvent* aEvent,
26874:                                           nsPresContext* aPresContext,
26874:                                           nsEventStatus* aStatus)
26874: {
26874:   nsCOMPtr<nsIContent> targetContent = aTargetFrame->GetContent();
29018:   if (!targetContent) {
29018:     targetContent = GetFocusedContent();
26874:     if (!targetContent)
26874:       return;
29018:   }
26874: 
26874:   while (targetContent->IsNodeOfType(nsINode::eTEXT)) {
26874:     targetContent = targetContent->GetParent();
26874:   }
26874: 
37061:   nscoord lineHeight = GetScrollableLineHeight(aTargetFrame);
19319: 
79445:   bool isTrusted = (aEvent->flags & NS_EVENT_FLAG_TRUSTED) != 0;
19319:   nsMouseScrollEvent event(isTrusted, NS_MOUSE_PIXEL_SCROLL, nsnull);
19319:   event.refPoint = aEvent->refPoint;
19319:   event.widget = aEvent->widget;
19319:   event.time = aEvent->time;
19319:   event.isShift = aEvent->isShift;
19319:   event.isControl = aEvent->isControl;
19319:   event.isAlt = aEvent->isAlt;
19319:   event.isMeta = aEvent->isMeta;
19319:   event.scrollFlags = aEvent->scrollFlags;
40485:   event.inputSource = static_cast<nsMouseEvent_base*>(aEvent)->inputSource;
19319:   event.delta = aPresContext->AppUnitsToIntCSSPixels(aEvent->delta * lineHeight);
19319: 
19319:   nsEventDispatcher::Dispatch(targetContent, aPresContext, &event, nsnull, aStatus);
19319: }
19319: 
70222: PRInt32
73896: nsEventStateManager::ComputeWheelDeltaFor(nsMouseScrollEvent* aMouseEvent)
73896: {
73896:   PRInt32 delta = aMouseEvent->delta;
79445:   bool useSysNumLines = UseSystemScrollSettingFor(aMouseEvent);
73896:   if (!useSysNumLines) {
73896:     // If the scroll event's delta isn't to our liking, we can
73896:     // override it with the "numlines" parameter.  There are two
73896:     // things we can do:
73896:     //
73896:     // (1) Pick a different number.  Instead of scrolling 3
73896:     //     lines ("delta" in Gtk2), we would scroll 1 line.
73896:     // (2) Swap directions.  Instead of scrolling down, scroll up.
73896:     //
73896:     // For the first item, the magnitude of the parameter is
73896:     // used instead of the magnitude of the delta.  For the
73896:     // second item, if the parameter is negative we swap
73896:     // directions.
73896: 
73896:     PRInt32 numLines = GetScrollLinesFor(aMouseEvent);
73896: 
79445:     bool swapDirs = (numLines < 0);
73896:     PRInt32 userSize = swapDirs ? -numLines : numLines;
73896: 
79445:     bool deltaUp = (delta < 0);
73896:     if (swapDirs) {
73896:       deltaUp = !deltaUp;
73896:     }
73896:     delta = deltaUp ? -userSize : userSize;
73896:   }
73896: 
73896:   if (ComputeWheelActionFor(aMouseEvent, useSysNumLines) == MOUSE_SCROLL_PAGE) {
77226:     delta = (delta > 0) ? PRInt32(nsIDOMUIEvent::SCROLL_PAGE_DOWN) :
77226:                           PRInt32(nsIDOMUIEvent::SCROLL_PAGE_UP);
73896:   }
73896: 
73896:   return delta;
73896: }
73896: 
73896: PRInt32
70222: nsEventStateManager::ComputeWheelActionFor(nsMouseScrollEvent* aMouseEvent,
79445:                                            bool aUseSystemSettings)
70222: {
70222:   PRInt32 action = GetWheelActionFor(aMouseEvent);
70222:   if (aUseSystemSettings &&
70222:       (aMouseEvent->scrollFlags & nsMouseScrollEvent::kIsFullPage)) {
70222:     action = MOUSE_SCROLL_PAGE;
70222:   }
70222: 
70222:   if (aMouseEvent->message == NS_MOUSE_PIXEL_SCROLL) {
70222:     if (action == MOUSE_SCROLL_N_LINES || action == MOUSE_SCROLL_PAGE ||
70222:         (aMouseEvent->scrollFlags & nsMouseScrollEvent::kIsMomentum)) {
70222:       action = MOUSE_SCROLL_PIXELS;
70222:     } else {
70222:       // Do not scroll pixels when zooming
70222:       action = -1;
70222:     }
74642:   } else if (((aMouseEvent->scrollFlags & nsMouseScrollEvent::kHasPixels) &&
74642:               (aUseSystemSettings ||
74642:                action == MOUSE_SCROLL_N_LINES || action == MOUSE_SCROLL_PAGE)) ||
74642:              ((aMouseEvent->scrollFlags & nsMouseScrollEvent::kIsMomentum) &&
74642:               (action == MOUSE_SCROLL_HISTORY || action == MOUSE_SCROLL_ZOOM))) {
74642:     // Don't scroll lines or page when a pixel scroll event will follow.
74642:     // Also, don't do history scrolling or zooming for momentum scrolls,
74642:     // no matter what's going on with pixel scrolling.
70222:     action = -1;
70222:   }
70222: 
70222:   return action;
70222: }
70222: 
70222: PRInt32
70222: nsEventStateManager::GetWheelActionFor(nsMouseScrollEvent* aMouseEvent)
70222: {
70222:   nsCAutoString prefName;
70222:   GetBasePrefKeyForMouseWheel(aMouseEvent, prefName);
70222:   prefName.Append(".action");
70842:   return Preferences::GetInt(prefName.get());
70222: }
70222: 
70222: PRInt32
70222: nsEventStateManager::GetScrollLinesFor(nsMouseScrollEvent* aMouseEvent)
70222: {
70222:   NS_ASSERTION(!UseSystemScrollSettingFor(aMouseEvent),
70222:     "GetScrollLinesFor() called when should use system settings");
70222:   nsCAutoString prefName;
70222:   GetBasePrefKeyForMouseWheel(aMouseEvent, prefName);
70222:   prefName.Append(".numlines");
70842:   return Preferences::GetInt(prefName.get());
70222: }
70222: 
79445: bool
70222: nsEventStateManager::UseSystemScrollSettingFor(nsMouseScrollEvent* aMouseEvent)
70222: {
70222:   nsCAutoString prefName;
70222:   GetBasePrefKeyForMouseWheel(aMouseEvent, prefName);
70222:   prefName.Append(".sysnumlines");
70840:   return Preferences::GetBool(prefName.get());
70222: }
70222: 
    1: nsresult
37058: nsEventStateManager::DoScrollText(nsIFrame* aTargetFrame,
28609:                                   nsMouseScrollEvent* aMouseEvent,
37058:                                   nsIScrollableFrame::ScrollUnit aScrollQuantity,
79445:                                   bool aAllowScrollSpeedOverride,
94193:                                   nsQueryContentEvent* aQueryEvent,
94193:                                   nsIAtom *aOrigin)
    1: {
37058:   nsIScrollableFrame* frameToScroll = nsnull;
    1:   nsIFrame* scrollFrame = aTargetFrame;
28609:   PRInt32 numLines = aMouseEvent->delta;
79445:   bool isHorizontal = aMouseEvent->scrollFlags & nsMouseScrollEvent::kIsHorizontal;
28609:   aMouseEvent->scrollOverflow = 0;
    1: 
    1:   // If the user recently scrolled with the mousewheel, then they probably want
    1:   // to scroll the same view as before instead of the view under the cursor.
    1:   // nsMouseWheelTransaction tracks the frame currently being scrolled with the
    1:   // mousewheel. We consider the transaction ended when the mouse moves more than
    1:   // "mousewheel.transaction.ignoremovedelay" milliseconds after the last scroll
    1:   // operation, or any time the mouse moves out of the frame, or when more than
    1:   // "mousewheel.transaction.timeout" milliseconds have passed after the last
    1:   // operation, even if the mouse hasn't moved.
    1:   nsIFrame* lastScrollFrame = nsMouseWheelTransaction::GetTargetFrame();
    1:   if (lastScrollFrame) {
37058:     frameToScroll = lastScrollFrame->GetScrollTargetFrame();
37058:     if (frameToScroll) {
28609:       nsMouseWheelTransaction::UpdateTransaction(numLines, isHorizontal);
25065:       // When the scroll event will not scroll any views, UpdateTransaction
25065:       // fired MozMouseScrollFailed event which is for automated testing.
25065:       // In the event handler, the target frame might be destroyed.  Then,
25065:       // we should not keep handling this scroll event.
25065:       if (!nsMouseWheelTransaction::GetTargetFrame())
25065:         return NS_OK;
    1:     } else {
    1:       nsMouseWheelTransaction::EndTransaction();
    1:       lastScrollFrame = nsnull;
    1:     }
    1:   }
79445:   bool passToParent = lastScrollFrame ? false : true;
    1: 
    1:   for (; scrollFrame && passToParent;
37058:        scrollFrame = GetParentFrameToScroll(scrollFrame)) {
    1:     // Check whether the frame wants to provide us with a scrollable view.
37058:     frameToScroll = scrollFrame->GetScrollTargetFrame();
37058:     if (!frameToScroll) {
    1:       continue;
    1:     }
    1: 
37058:     nsPresContext::ScrollbarStyles ss = frameToScroll->GetScrollbarStyles();
    1:     if (NS_STYLE_OVERFLOW_HIDDEN ==
28609:         (isHorizontal ? ss.mHorizontal : ss.mVertical)) {
    1:       continue;
    1:     }
    1: 
    1:     // Check if the scrollable view can be scrolled any further.
37058:     nscoord lineHeight = frameToScroll->GetLineScrollAmount().height;
    1:     if (lineHeight != 0) {
37058:       if (CanScrollOn(frameToScroll, numLines, isHorizontal)) {
80486:         passToParent = false;
24947:         nsMouseWheelTransaction::BeginTransaction(scrollFrame,
28609:                                                   numLines, isHorizontal);
    1:       }
    1: 
    1:       // Comboboxes need special care.
23554:       nsIComboboxControlFrame* comboBox = do_QueryFrame(scrollFrame);
    1:       if (comboBox) {
    1:         if (comboBox->IsDroppedDown()) {
    1:           // Don't propagate to parent when drop down menu is active.
    1:           if (passToParent) {
80486:             passToParent = false;
37058:             frameToScroll = nsnull;
    1:             nsMouseWheelTransaction::EndTransaction();
    1:           }
    1:         } else {
    1:           // Always propagate when not dropped down (even if focused).
13114:           if (!passToParent) {
80486:             passToParent = true;
13114:             nsMouseWheelTransaction::EndTransaction();
13114:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
37058:   if (!passToParent && frameToScroll) {
70338:     if (aScrollQuantity == nsIScrollableFrame::LINES) {
70338:       // When this is called for querying the scroll target information,
70338:       // we shouldn't limit the scrolling amount to less one page.
70338:       // Otherwise, we shouldn't scroll more one page at once.
70338:       numLines =
70338:         nsMouseWheelTransaction::AccelerateWheelDelta(numLines, isHorizontal,
70338:                                                       aAllowScrollSpeedOverride,
70338:                                                       &aScrollQuantity,
70338:                                                       !aQueryEvent);
70338:     }
70338: #ifdef DEBUG
70338:     else {
70338:       NS_ASSERTION(!aAllowScrollSpeedOverride,
70338:         "aAllowScrollSpeedOverride is true but the quantity isn't by-line scrolling.");
70338:     }
70338: #endif
70338: 
70338:     if (aScrollQuantity == nsIScrollableFrame::PAGES) {
70338:       numLines = (numLines > 0) ? 1 : -1;
70338:     }
70338: 
69947:     if (aQueryEvent) {
70040:       // If acceleration is enabled, pixel scroll shouldn't be used for
70040:       // high resolution scrolling.
70040:       if (nsMouseWheelTransaction::IsAccelerationEnabled()) {
70040:         return NS_OK;
70040:       }
70040: 
69947:       nscoord appUnitsPerDevPixel =
69947:         aTargetFrame->PresContext()->AppUnitsPerDevPixel();
69947:       aQueryEvent->mReply.mLineHeight =
69947:         frameToScroll->GetLineScrollAmount().height / appUnitsPerDevPixel;
69947:       aQueryEvent->mReply.mPageHeight =
69947:         frameToScroll->GetPageScrollAmount().height / appUnitsPerDevPixel;
69947:       aQueryEvent->mReply.mPageWidth =
69947:         frameToScroll->GetPageScrollAmount().width / appUnitsPerDevPixel;
70338: 
70338:       // Returns computed numLines to widget which is needed to compute the
70338:       // pixel scrolling amout for high resolution scrolling.
70338:       aQueryEvent->mReply.mComputedScrollAmount = numLines;
70338: 
73896:       switch (aScrollQuantity) {
73896:         case nsIScrollableFrame::LINES:
73896:           aQueryEvent->mReply.mComputedScrollAction =
73896:             nsQueryContentEvent::SCROLL_ACTION_LINE;
73896:           break;
73896:         case nsIScrollableFrame::PAGES:
73896:           aQueryEvent->mReply.mComputedScrollAction =
73896:             nsQueryContentEvent::SCROLL_ACTION_PAGE;
73896:           break;
73896:         default:
73896:           aQueryEvent->mReply.mComputedScrollAction =
73896:             nsQueryContentEvent::SCROLL_ACTION_NONE;
73896:           break;
73896:       }
73896: 
80486:       aQueryEvent->mSucceeded = true;
69947:       return NS_OK;
69947:     }
69947: 
    1:     PRInt32 scrollX = 0;
28609:     PRInt32 scrollY = numLines;
    1: 
28609:     if (isHorizontal) {
    1:       scrollX = scrollY;
    1:       scrollY = 0;
    1:     }
    1: 
61924:     nsIScrollableFrame::ScrollMode mode;
61924:     if (aMouseEvent->scrollFlags & nsMouseScrollEvent::kNoDefer) {
61924:       mode = nsIScrollableFrame::INSTANT;
69947:     } else if (aScrollQuantity != nsIScrollableFrame::DEVICE_PIXELS ||
69947:                (aMouseEvent->scrollFlags &
69947:                   nsMouseScrollEvent::kAllowSmoothScroll) != 0) {
61924:       mode = nsIScrollableFrame::SMOOTH;
61924:     } else {
61924:       mode = nsIScrollableFrame::NORMAL;
61924:     }
61924: 
70338:     // XXX Why don't we limit the pixel scroll amount to less one page??
70338: 
37058:     nsIntPoint overflow;
37058:     frameToScroll->ScrollBy(nsIntPoint(scrollX, scrollY), aScrollQuantity,
94193:                             mode, &overflow, aOrigin);
37058:     aMouseEvent->scrollOverflow = isHorizontal ? overflow.x : overflow.y;
28609:     return NS_OK;
28609:   }
28609:   
    1:   if (passToParent) {
37058:     nsIFrame* newFrame = nsLayoutUtils::GetCrossDocParentFrame(
37058:         aTargetFrame->PresContext()->FrameManager()->GetRootFrame());
37058:     if (newFrame)
37058:       return DoScrollText(newFrame, aMouseEvent, aScrollQuantity,
94193:                           aAllowScrollSpeedOverride, aQueryEvent, aOrigin);
28609:   }
28609: 
28609:   aMouseEvent->scrollOverflow = numLines;
    1: 
    1:   return NS_OK;
    1: }
    1: 
31443: void
31443: nsEventStateManager::DecideGestureEvent(nsGestureNotifyEvent* aEvent,
31443:                                         nsIFrame* targetFrame)
31443: {
31443: 
31443:   NS_ASSERTION(aEvent->message == NS_GESTURENOTIFY_EVENT_START,
31443:                "DecideGestureEvent called with a non-gesture event");
31443: 
31443:   /* Check the ancestor tree to decide if any frame is willing* to receive
31443:    * a MozPixelScroll event. If that's the case, the current touch gesture
31443:    * will be used as a pan gesture; otherwise it will be a regular
31443:    * mousedown/mousemove/click event.
31443:    *
31443:    * *willing: determine if it makes sense to pan the element using scroll events:
31443:    *  - For web content: if there are any visible scrollbars on the touch point
31443:    *  - For XUL: if it's an scrollable element that can currently scroll in some
31443:     *    direction.
31443:    *
31443:    * Note: we'll have to one-off various cases to ensure a good usable behavior
31443:    */
31443:   nsGestureNotifyEvent::ePanDirection panDirection = nsGestureNotifyEvent::ePanNone;
79445:   bool displayPanFeedback = false;
31443:   for (nsIFrame* current = targetFrame; current;
31443:        current = nsLayoutUtils::GetCrossDocParentFrame(current)) {
31443: 
31443:     nsIAtom* currentFrameType = current->GetType();
31443: 
31443:     // Scrollbars should always be draggable
31443:     if (currentFrameType == nsGkAtoms::scrollbarFrame) {
31443:       panDirection = nsGestureNotifyEvent::ePanNone;
31443:       break;
31443:     }
31443: 
31443: #ifdef MOZ_XUL
31443:     // Special check for trees
31443:     nsTreeBodyFrame* treeFrame = do_QueryFrame(current);
31443:     if (treeFrame) {
31443:       if (treeFrame->GetHorizontalOverflow()) {
31443:         panDirection = nsGestureNotifyEvent::ePanHorizontal;
31443:       }
31443:       if (treeFrame->GetVerticalOverflow()) {
31443:         panDirection = nsGestureNotifyEvent::ePanVertical;
31443:       }
31443:       break;
31443:     }
31443: #endif
31443: 
31443:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(current);
31443:     if (scrollableFrame) {
31443:       if (current->IsFrameOfType(nsIFrame::eXULBox)) {
80486:         displayPanFeedback = true;
31443: 
37061:         nsRect scrollRange = scrollableFrame->GetScrollRange();
79445:         bool canScrollHorizontally = scrollRange.width > 0;
31443: 
31443:         if (targetFrame->GetType() == nsGkAtoms::menuFrame) {
31443:           // menu frames report horizontal scroll when they have submenus
31443:           // and we don't want that
80486:           canScrollHorizontally = false;
80486:           displayPanFeedback = false;
31443:         }
31443: 
31443:         // Vertical panning has priority over horizontal panning, so
37061:         // when vertical movement is possible we can just finish the loop.
37061:         if (scrollRange.height > 0) {
31443:           panDirection = nsGestureNotifyEvent::ePanVertical;
31443:           break;
31443:         }
31443: 
37061:         if (canScrollHorizontally) {
31443:           panDirection = nsGestureNotifyEvent::ePanHorizontal;
80486:           displayPanFeedback = false;
31443:         }
31443:       } else { //Not a XUL box
37292:         PRUint32 scrollbarVisibility = scrollableFrame->GetScrollbarVisibility();
31443: 
31443:         //Check if we have visible scrollbars
37292:         if (scrollbarVisibility & nsIScrollableFrame::VERTICAL) {
31443:           panDirection = nsGestureNotifyEvent::ePanVertical;
80486:           displayPanFeedback = true;
31443:           break;
31443:         }
31443: 
37292:         if (scrollbarVisibility & nsIScrollableFrame::HORIZONTAL) {
31443:           panDirection = nsGestureNotifyEvent::ePanHorizontal;
80486:           displayPanFeedback = true;
31443:         }
37061:       }
31443:     } //scrollableFrame
31443:   } //ancestor chain
31443: 
31443:   aEvent->displayPanFeedback = displayPanFeedback;
31443:   aEvent->panDirection = panDirection;
31443: }
31443: 
58135: #ifdef XP_MACOSX
47793: static bool
47793: NodeAllowsClickThrough(nsINode* aNode)
47793: {
47793:   while (aNode) {
47793:     if (aNode->IsElement() && aNode->AsElement()->IsXUL()) {
47793:       mozilla::dom::Element* element = aNode->AsElement();
47793:       static nsIContent::AttrValuesArray strings[] =
47793:         {&nsGkAtoms::always, &nsGkAtoms::never, nsnull};
47793:       switch (element->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::clickthrough,
47793:                                        strings, eCaseMatters)) {
47793:         case 0:
47793:           return true;
47793:         case 1:
47793:           return false;
47793:       }
47793:     }
47793:     aNode = nsContentUtils::GetCrossDocParentNode(aNode);
47793:   }
47793:   return true;
47793: }
58135: #endif
47793: 
68780: nsresult
    1: nsEventStateManager::PostHandleEvent(nsPresContext* aPresContext,
    1:                                      nsEvent *aEvent,
    1:                                      nsIFrame* aTargetFrame,
82566:                                      nsEventStatus* aStatus)
    1: {
    1:   NS_ENSURE_ARG(aPresContext);
    1:   NS_ENSURE_ARG_POINTER(aStatus);
   55: 
73592:   HandleCrossProcessEvent(aEvent, aTargetFrame, aStatus);
73592: 
    1:   mCurrentTarget = aTargetFrame;
    1:   mCurrentTargetContent = nsnull;
   55: 
 8236:   // Most of the events we handle below require a frame.
 8236:   // Add special cases here.
55257:   if (!mCurrentTarget && aEvent->message != NS_MOUSE_BUTTON_UP &&
55257:       aEvent->message != NS_MOUSE_BUTTON_DOWN) {
   55:     return NS_OK;
   55:   }
   55: 
    1:   //Keep the prescontext alive, we might need it after event dispatch
    1:   nsRefPtr<nsPresContext> presContext = aPresContext;
   55:   nsresult ret = NS_OK;
    1: 
    1:   switch (aEvent->message) {
    1:   case NS_MOUSE_BUTTON_DOWN:
    1:     {
 3233:       if (static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton &&
52199:           !sNormalLMouseEventInProcess) {
32435:         // We got a mouseup event while a mousedown event was being processed.
32435:         // Make sure that the capturing content is cleared.
32435:         nsIPresShell::SetCapturingContent(nsnull, 0);
    1:         break;
    1:       }
    1: 
55892:       nsCOMPtr<nsIContent> activeContent;
    1:       if (nsEventStatus_eConsumeNoDefault != *aStatus) {
    1:         nsCOMPtr<nsIContent> newFocus;      
79445:         bool suppressBlur = false;
    1:         if (mCurrentTarget) {
79435:           mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(newFocus));
    1:           const nsStyleUserInterface* ui = mCurrentTarget->GetStyleUserInterface();
95633:           suppressBlur = (ui->mUserFocus == NS_STYLE_USER_FOCUS_IGNORE);
95630:           activeContent = mCurrentTarget->GetContent();
29018:         }
29018: 
41068:         nsIFrame* currFrame = mCurrentTarget;
41068: 
41068:         // When a root content which isn't editable but has an editable HTML
41068:         // <body> element is clicked, we should redirect the focus to the
41068:         // the <body> element.  E.g., when an user click bottom of the editor
41068:         // where is outside of the <body> element, the <body> should be focused
41068:         // and the user can edit immediately after that.
41068:         //
41068:         // NOTE: The newFocus isn't editable that also means it's not in
41068:         // designMode.  In designMode, all contents are not focusable.
41068:         if (newFocus && !newFocus->IsEditable()) {
41068:           nsIDocument *doc = newFocus->GetCurrentDoc();
41634:           if (doc && newFocus == doc->GetRootElement()) {
41068:             nsIContent *bodyContent =
41068:               nsLayoutUtils::GetEditableRootContentByContentEditable(doc);
41068:             if (bodyContent) {
41068:               nsIFrame* bodyFrame = bodyContent->GetPrimaryFrame();
41068:               if (bodyFrame) {
41068:                 currFrame = bodyFrame;
41068:                 newFocus = bodyContent;
41068:               }
41068:             }
41068:           }
41068:         }
41068: 
29018:         // When the mouse is pressed, the default action is to focus the
29018:         // target. Look for the nearest enclosing focusable frame.
    1:         while (currFrame) {
    1:           // If the mousedown happened inside a popup, don't
    1:           // try to set focus on one of its containing elements
    1:           const nsStyleDisplay* display = currFrame->GetStyleDisplay();
    1:           if (display->mDisplay == NS_STYLE_DISPLAY_POPUP) {
    1:             newFocus = nsnull;
    1:             break;
    1:           }
    1: 
    1:           PRInt32 tabIndexUnused;
80486:           if (currFrame->IsFocusable(&tabIndexUnused, true)) {
    1:             newFocus = currFrame->GetContent();
    1:             nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(newFocus));
    1:             if (domElement)
    1:               break;
    1:           }
    1:           currFrame = currFrame->GetParent();
    1:         }
    1: 
29018:         nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:         if (fm) {
29018:           // if something was found to focus, focus it. Otherwise, if the
29018:           // element that was clicked doesn't have -moz-user-focus: ignore,
29018:           // clear the existing focus. For -moz-user-focus: ignore, the focus
29018:           // is just left as is.
29018:           // Another effect of mouse clicking, handled in nsSelection, is that
29018:           // it should update the caret position to where the mouse was
29018:           // clicked. Because the focus is cleared when clicking on a
29018:           // non-focusable node, the next press of the tab key will cause
29018:           // focus to be shifted from the caret position instead of the root.
29018:           if (newFocus && currFrame) {
29018:             // use the mouse flag and the noscroll flag so that the content
29018:             // doesn't unexpectedly scroll when clicking an element that is
29018:             // only hald visible
29018:             nsCOMPtr<nsIDOMElement> newFocusElement = do_QueryInterface(newFocus);
29018:             fm->SetFocus(newFocusElement, nsIFocusManager::FLAG_BYMOUSE |
29018:                                           nsIFocusManager::FLAG_NOSCROLL);
29018:           }
    1:           else if (!suppressBlur) {
29018:             // clear the focus within the frame and then set it as the
29018:             // focused frame
29018:             EnsureDocument(mPresContext);
29018:             if (mDocument) {
41071: #ifdef XP_MACOSX
41071:               if (!activeContent || !activeContent->IsXUL())
41071: #endif
29018:                 fm->ClearFocus(mDocument->GetWindow());
29018:               fm->SetFocusedWindow(mDocument->GetWindow());
29018:             }
29018:           }
    1:         }
    1: 
    1:         // The rest is left button-specific.
 3233:         if (static_cast<nsMouseEvent*>(aEvent)->button !=
    1:             nsMouseEvent::eLeftButton)
    1:           break;
    1: 
    1:         if (activeContent) {
    1:           // The nearest enclosing element goes into the
    1:           // :active state.  If we fail the QI to DOMElement,
    1:           // then we know we're only a node, and that we need
    1:           // to obtain our parent element and put it into :active
    1:           // instead.
    1:           nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(activeContent));
    1:           if (!elt) {
    1:             nsIContent* par = activeContent->GetParent();
    1:             if (par)
    1:               activeContent = par;
    1:           }
    1:         }
    1:       }
    1:       else {
    1:         // if we're here, the event handler returned false, so stop
    1:         // any of our own processing of a drag. Workaround for bug 43258.
    1:         StopTrackingDragGesture();
61173: 
61173:         // When the event was cancelled, there is currently a chrome document
61173:         // focused and a mousedown just occurred on a content document, ensure
61173:         // that the window that was clicked is focused.
61173:         EnsureDocument(mPresContext);
61173:         nsIFocusManager* fm = nsFocusManager::GetFocusManager();
61173:         if (mDocument && fm) {
61173:           nsCOMPtr<nsIDOMWindow> currentWindow;
61173:           fm->GetFocusedWindow(getter_AddRefs(currentWindow));
61173:           if (currentWindow && currentWindow != mDocument->GetWindow() &&
61173:               !nsContentUtils::IsChromeDoc(mDocument)) {
61173:             nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(currentWindow);
61173:             nsCOMPtr<nsIDocument> currentDoc = do_QueryInterface(win->GetExtantDocument());
61173:             if (nsContentUtils::IsChromeDoc(currentDoc)) {
61173:               fm->SetFocusedWindow(mDocument->GetWindow());
61173:             }
61173:           }
61173:         }
    1:       }
56644:       SetActiveManager(this, activeContent);
    1:     }
    1:     break;
    1:   case NS_MOUSE_BUTTON_UP:
    1:     {
56644:       ClearGlobalActiveContent(this);
39761:       if (IsMouseEventReal(aEvent)) {
    1:         if (!mCurrentTarget) {
68780:           GetEventTarget();
 8236:         }
 8236:         if (mCurrentTarget) {
39761:           ret = CheckForAndDispatchClick(presContext, (nsMouseEvent*)aEvent,
39761:                                          aStatus);
39761:         }
 8236:       }
32435: 
    1:       nsIPresShell *shell = presContext->GetPresShell();
    1:       if (shell) {
70097:         nsRefPtr<nsFrameSelection> frameSelection = shell->FrameSelection();
80486:         frameSelection->SetMouseDownState(false);
    1:       }
    1:     }
    1:     break;
    1:   case NS_MOUSE_SCROLL:
19319:   case NS_MOUSE_PIXEL_SCROLL:
19319:     {
19319:       nsMouseScrollEvent *msEvent = static_cast<nsMouseScrollEvent*>(aEvent);
19319: 
19319:       if (aEvent->message == NS_MOUSE_SCROLL) {
19319:         // Mark the subsequent pixel scrolls as valid / invalid, based on the
19319:         // observation if the previous line scroll has been canceled
19319:         if (msEvent->scrollFlags & nsMouseScrollEvent::kIsHorizontal) {
19319:           mLastLineScrollConsumedX = (nsEventStatus_eConsumeNoDefault == *aStatus);
19319:         } else if (msEvent->scrollFlags & nsMouseScrollEvent::kIsVertical) {
19319:           mLastLineScrollConsumedY = (nsEventStatus_eConsumeNoDefault == *aStatus);
19319:         }
19319:         if (!(msEvent->scrollFlags & nsMouseScrollEvent::kHasPixels)) {
19319:           // No generated pixel scroll event will follow.
19319:           // Create and send a pixel scroll DOM event now.
22220:           nsWeakFrame weakFrame(aTargetFrame);
19319:           SendPixelScrollEvent(aTargetFrame, msEvent, presContext, aStatus);
22220:           NS_ENSURE_STATE(weakFrame.IsAlive());
19319:         }
19319:       }
19319: 
19319:       if (*aStatus != nsEventStatus_eConsumeNoDefault) {
79445:         bool useSysNumLines = UseSystemScrollSettingFor(msEvent);
70222:         PRInt32 action = ComputeWheelActionFor(msEvent, useSysNumLines);
    1: 
    1:         switch (action) {
    1:         case MOUSE_SCROLL_N_LINES:
37058:           DoScrollText(aTargetFrame, msEvent, nsIScrollableFrame::LINES,
94193:                        useSysNumLines, nsnull, nsGkAtoms::mouseWheel);
    1:           break;
    1: 
    1:         case MOUSE_SCROLL_PAGE:
37058:           DoScrollText(aTargetFrame, msEvent, nsIScrollableFrame::PAGES,
80486:                        false);
    1:           break;
    1: 
    1:         case MOUSE_SCROLL_PIXELS:
94194:           {
94194:             bool fromLines = msEvent->scrollFlags & nsMouseScrollEvent::kFromLines;
37058:             DoScrollText(aTargetFrame, msEvent, nsIScrollableFrame::DEVICE_PIXELS,
94194:                          false, nsnull, (fromLines ? nsGkAtoms::mouseWheel : nsnull));
94194:           }
    1:           break;
    1: 
    1:         case MOUSE_SCROLL_HISTORY:
    1:           DoScrollHistory(msEvent->delta);
    1:           break;
    1: 
11660:         case MOUSE_SCROLL_ZOOM:
11660:           DoScrollZoom(aTargetFrame, msEvent->delta);
    1:           break;
    1: 
    1:         default:  // Including -1 (do nothing)
    1:           break;
    1:         }
    1:         *aStatus = nsEventStatus_eConsumeNoDefault;
19319:       }
19319:     }
    1:     break;
    1: 
31443:   case NS_GESTURENOTIFY_EVENT_START:
31443:     {
31443:       if (nsEventStatus_eConsumeNoDefault != *aStatus)
31443:         DecideGestureEvent(static_cast<nsGestureNotifyEvent*>(aEvent), mCurrentTarget);
31443:     }
31443:     break;
31443: 
18445:   case NS_DRAGDROP_ENTER:
18445:   case NS_DRAGDROP_OVER:
18445:     {
18445:       NS_ASSERTION(aEvent->eventStructType == NS_DRAG_EVENT, "Expected a drag event");
18445: 
18445:       nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
18445:       if (!dragSession)
18445:         break;
18445: 
34272:       // Reset the flag.
80486:       dragSession->SetOnlyChromeDrop(false);
34272:       if (mPresContext) {
34272:         EnsureDocument(mPresContext);
34272:       }
79445:       bool isChromeDoc = nsContentUtils::IsChromeDoc(mDocument);
34272: 
18445:       // the initial dataTransfer is the one from the dragstart event that
18445:       // was set on the dragSession when the drag began.
89615:       nsCOMPtr<nsIDOMDataTransfer> dataTransfer;
18445:       nsCOMPtr<nsIDOMDataTransfer> initialDataTransfer;
18445:       dragSession->GetDataTransfer(getter_AddRefs(initialDataTransfer));
18445: 
33528:       nsDragEvent *dragEvent = (nsDragEvent*)aEvent;
33528: 
33528:       // collect any changes to moz cursor settings stored in the event's
33528:       // data transfer.
33528:       UpdateDragDataTransfer(dragEvent);
33528: 
18445:       // cancelling a dragenter or dragover event means that a drop should be
18445:       // allowed, so update the dropEffect and the canDrop state to indicate
18445:       // that a drag is allowed. If the event isn't cancelled, a drop won't be
18445:       // allowed. Essentially, to allow a drop somewhere, specify the effects
18445:       // using the effectAllowed and dropEffect properties in a dragenter or
18445:       // dragover event and cancel the event. To not allow a drop somewhere,
18445:       // don't cancel the event or set the effectAllowed or dropEffect to
18445:       // "none". This way, if the event is just ignored, no drop will be
18445:       // allowed.
18445:       PRUint32 dropEffect = nsIDragService::DRAGDROP_ACTION_NONE;
18445:       if (nsEventStatus_eConsumeNoDefault == *aStatus) {
18445:         // if the event has a dataTransfer set, use it.
18445:         if (dragEvent->dataTransfer) {
18445:           // get the dataTransfer and the dropEffect that was set on it
18445:           dataTransfer = do_QueryInterface(dragEvent->dataTransfer);
18445:           dataTransfer->GetDropEffectInt(&dropEffect);
18445:         }
18445:         else {
18445:           // if dragEvent->dataTransfer is null, it means that no attempt was
18445:           // made to access the dataTransfer during the event, yet the event
18445:           // was cancelled. Instead, use the initial data transfer available
18445:           // from the drag session. The drop effect would not have been
18445:           // initialized (which is done in nsDOMDragEvent::GetDataTransfer),
18445:           // so set it from the drag action. We'll still want to filter it
18445:           // based on the effectAllowed below.
89615:           dataTransfer = initialDataTransfer;
18445: 
18445:           PRUint32 action;
18445:           dragSession->GetDragAction(&action);
18445: 
18445:           // filter the drop effect based on the action. Use UNINITIALIZED as
18445:           // any effect is allowed.
29545:           dropEffect = nsContentUtils::FilterDropEffect(action,
18445:                          nsIDragService::DRAGDROP_ACTION_UNINITIALIZED);
18445:         }
18445: 
18445:         // At this point, if the dataTransfer is null, it means that the
18445:         // drag was originally started by directly calling the drag service.
18445:         // Just assume that all effects are allowed.
18445:         PRUint32 effectAllowed = nsIDragService::DRAGDROP_ACTION_UNINITIALIZED;
18445:         if (dataTransfer)
18445:           dataTransfer->GetEffectAllowedInt(&effectAllowed);
18445: 
18445:         // set the drag action based on the drop effect and effect allowed.
18445:         // The drop effect field on the drag transfer object specifies the
18445:         // desired current drop effect. However, it cannot be used if the
18445:         // effectAllowed state doesn't include that type of action. If the
18445:         // dropEffect is "none", then the action will be 'none' so a drop will
18445:         // not be allowed.
18445:         PRUint32 action = nsIDragService::DRAGDROP_ACTION_NONE;
18445:         if (effectAllowed == nsIDragService::DRAGDROP_ACTION_UNINITIALIZED ||
18445:             dropEffect & effectAllowed)
18445:           action = dropEffect;
18445: 
18445:         if (action == nsIDragService::DRAGDROP_ACTION_NONE)
18445:           dropEffect = nsIDragService::DRAGDROP_ACTION_NONE;
18445: 
18445:         // inform the drag session that a drop is allowed on this node.
18445:         dragSession->SetDragAction(action);
18445:         dragSession->SetCanDrop(action != nsIDragService::DRAGDROP_ACTION_NONE);
34272: 
34272:         // For now, do this only for dragover.
34272:         //XXXsmaug dragenter needs some more work.
34272:         if (aEvent->message == NS_DRAGDROP_OVER && !isChromeDoc) {
34272:           // Someone has called preventDefault(), check whether is was content.
34272:           dragSession->SetOnlyChromeDrop(
34272:             !(aEvent->flags & NS_EVENT_FLAG_NO_DEFAULT_CALLED_IN_CONTENT));
34272:         }
34272:       } else if (aEvent->message == NS_DRAGDROP_OVER && !isChromeDoc) {
34605:         // No one called preventDefault(), so handle drop only in chrome.
80486:         dragSession->SetOnlyChromeDrop(true);
18445:       }
18445: 
18445:       // now set the drop effect in the initial dataTransfer. This ensures
18445:       // that we can get the desired drop effect in the drop event.
89615:       if (initialDataTransfer)
89615:         initialDataTransfer->SetDropEffectInt(dropEffect);
18445:     }
18445:     break;
18445: 
    1:   case NS_DRAGDROP_DROP:
18445:     {
18445:       // now fire the dragdrop event, for compatibility with XUL
18445:       if (mCurrentTarget && nsEventStatus_eConsumeNoDefault != *aStatus) {
18445:         nsCOMPtr<nsIContent> targetContent;
79435:         mCurrentTarget->GetContentForEvent(aEvent,
18445:                                            getter_AddRefs(targetContent));
18445: 
47148:         nsCOMPtr<nsIWidget> widget = mCurrentTarget->GetNearestWidget();
18445:         nsDragEvent event(NS_IS_TRUSTED_EVENT(aEvent), NS_DRAGDROP_DRAGDROP, widget);
18445: 
18445:         nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(aEvent);
18445:         event.refPoint = mouseEvent->refPoint;
46252:         if (mouseEvent->widget) {
46252:           event.refPoint += mouseEvent->widget->WidgetToScreenOffset();
46252:         }
46252:         event.refPoint -= widget->WidgetToScreenOffset();
18445:         event.isShift = mouseEvent->isShift;
18445:         event.isControl = mouseEvent->isControl;
18445:         event.isAlt = mouseEvent->isAlt;
18445:         event.isMeta = mouseEvent->isMeta;
40485:         event.inputSource = mouseEvent->inputSource;
18445: 
18445:         nsEventStatus status = nsEventStatus_eIgnore;
18445:         nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
18445:         if (presShell) {
18445:           presShell->HandleEventWithTarget(&event, mCurrentTarget,
18445:                                            targetContent, &status);
18445:         }
18445:       }
81998:       sLastDragOverFrame = nsnull;
56644:       ClearGlobalActiveContent(this);
18445:       break;
18445:     }
    1:   case NS_DRAGDROP_EXIT:
18445:      // make sure to fire the enter and exit_synth events after the
18445:      // NS_DRAGDROP_EXIT event, otherwise we'll clean up too early
    1:     GenerateDragDropEnterExit(presContext, (nsGUIEvent*)aEvent);
    1:     break;
    1: 
    1:   case NS_KEY_UP:
    1:     break;
    1: 
    1:   case NS_KEY_PRESS:
    1:     if (nsEventStatus_eConsumeNoDefault != *aStatus) {
    1:       nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
    1:       //This is to prevent keyboard scrolling while alt modifier in use.
    1:       if (!keyEvent->isAlt) {
    1:         switch(keyEvent->keyCode) {
    1:           case NS_VK_TAB:
29018:           case NS_VK_F6:
29018:             EnsureDocument(mPresContext);
29018:             nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:             if (fm && mDocument) {
    1:               // Shift focus forward or back depending on shift key
79445:               bool isDocMove = ((nsInputEvent*)aEvent)->isControl ||
29018:                                  (keyEvent->keyCode == NS_VK_F6);
68468:               PRUint32 dir =
68468:                 static_cast<nsInputEvent*>(aEvent)->isShift ?
68468:                   (isDocMove ? static_cast<PRUint32>(nsIFocusManager::MOVEFOCUS_BACKWARDDOC) :
68468:                                static_cast<PRUint32>(nsIFocusManager::MOVEFOCUS_BACKWARD)) :
68468:                   (isDocMove ? static_cast<PRUint32>(nsIFocusManager::MOVEFOCUS_FORWARDDOC) :
68468:                                static_cast<PRUint32>(nsIFocusManager::MOVEFOCUS_FORWARD));
29018:               nsCOMPtr<nsIDOMElement> result;
29018:               fm->MoveFocus(mDocument->GetWindow(), nsnull, dir,
29018:                             nsIFocusManager::FLAG_BYKEY,
29018:                             getter_AddRefs(result));
29018:             }
    1:             *aStatus = nsEventStatus_eConsumeNoDefault;
    1:             break;
    1:         }
    1:       }
    1:     }
    1:     break;
    1: 
    1:   case NS_MOUSE_ENTER:
    1:     if (mCurrentTarget) {
    1:       nsCOMPtr<nsIContent> targetContent;
79435:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
    1:       SetContentState(targetContent, NS_EVENT_STATE_HOVER);
    1:     }
    1:     break;
47793: 
47793: #ifdef XP_MACOSX
47793:   case NS_MOUSE_ACTIVATE:
47793:     if (mCurrentTarget) {
47793:       nsCOMPtr<nsIContent> targetContent;
79435:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
47793:       if (!NodeAllowsClickThrough(targetContent)) {
47793:         *aStatus = nsEventStatus_eConsumeNoDefault;
47793:       }
47793:     }
47793:     break;
47793: #endif
    1:   }
    1: 
    1:   //Reset target frame to null to avoid mistargeting after reentrant event
    1:   mCurrentTarget = nsnull;
51626:   mCurrentTargetContent = nsnull;
    1: 
    1:   return ret;
    1: }
    1: 
79445: bool
54603: nsEventStateManager::RemoteQueryContentEvent(nsEvent *aEvent)
54603: {
54603:   nsQueryContentEvent *queryEvent =
54603:       static_cast<nsQueryContentEvent*>(aEvent);
54603:   if (!IsTargetCrossProcess(queryEvent)) {
80486:     return false;
54603:   }
54603:   // Will not be handled locally, remote the event
54603:   GetCrossProcessTarget()->HandleQueryContentEvent(*queryEvent);
80486:   return true;
54603: }
54603: 
54603: TabParent*
50731: nsEventStateManager::GetCrossProcessTarget()
50731: {
54603:   return TabParent::GetIMETabParent();
50731: }
50731: 
79445: bool
50731: nsEventStateManager::IsTargetCrossProcess(nsGUIEvent *aEvent)
50731: {
54776:   // Check to see if there is a focused, editable content in chrome,
54776:   // in that case, do not forward IME events to content
54776:   nsIContent *focusedContent = GetFocusedContent();
54776:   if (focusedContent && focusedContent->IsEditable())
80486:     return false;
54603:   return TabParent::GetIMETabParent() != nsnull;
54603: }
50731: 
68780: void
    1: nsEventStateManager::NotifyDestroyPresContext(nsPresContext* aPresContext)
    1: {
    1:   nsIMEStateManager::OnDestroyPresContext(aPresContext);
68780: }
68780: 
68780: void
    1: nsEventStateManager::SetPresContext(nsPresContext* aPresContext)
    1: {
    1:   mPresContext = aPresContext;
68780: }
68780: 
68780: void
    1: nsEventStateManager::ClearFrameRefs(nsIFrame* aFrame)
    1: {
    1:   if (aFrame && aFrame == mCurrentTarget) {
    1:     mCurrentTargetContent = aFrame->GetContent();
    1:   }
    1: }
    1: 
    1: void
    1: nsEventStateManager::UpdateCursor(nsPresContext* aPresContext,
    1:                                   nsEvent* aEvent, nsIFrame* aTargetFrame,
    1:                                   nsEventStatus* aStatus)
    1: {
73592:   if (aTargetFrame && IsRemoteTarget(aTargetFrame->GetContent())) {
73592:     return;
73592:   }
73592: 
    1:   PRInt32 cursor = NS_STYLE_CURSOR_DEFAULT;
    1:   imgIContainer* container = nsnull;
79445:   bool haveHotspot = false;
    1:   float hotspotX = 0.0f, hotspotY = 0.0f;
    1: 
    1:   //If cursor is locked just use the locked one
    1:   if (mLockCursor) {
    1:     cursor = mLockCursor;
    1:   }
    1:   //If not locked, look for correct cursor
    1:   else if (aTargetFrame) {
    1:       nsIFrame::Cursor framecursor;
    1:       nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent,
    1:                                                                 aTargetFrame);
    1:       if (NS_FAILED(aTargetFrame->GetCursor(pt, framecursor)))
    1:         return;  // don't update the cursor if we failed to get it from the frame see bug 118877
    1:       cursor = framecursor.mCursor;
    1:       container = framecursor.mContainer;
    1:       haveHotspot = framecursor.mHaveHotspot;
    1:       hotspotX = framecursor.mHotspotX;
    1:       hotspotY = framecursor.mHotspotY;
    1:   }
    1: 
79445:   if (Preferences::GetBool("ui.use_activity_cursor", false)) {
32813:     // Check whether or not to show the busy cursor
32813:     nsCOMPtr<nsISupports> pcContainer = aPresContext->GetContainer();
32813:     nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(pcContainer));
32813:     if (!docShell) return;
32813:     PRUint32 busyFlags = nsIDocShell::BUSY_FLAGS_NONE;
32813:     docShell->GetBusyFlags(&busyFlags);
32813: 
32813:     // Show busy cursor everywhere before page loads
32813:     // and just replace the arrow cursor after page starts loading
32813:     if (busyFlags & nsIDocShell::BUSY_FLAGS_BUSY &&
32813:           (cursor == NS_STYLE_CURSOR_AUTO || cursor == NS_STYLE_CURSOR_DEFAULT))
32813:     {
32813:       cursor = NS_STYLE_CURSOR_SPINNING;
32813:       container = nsnull;
32813:     }
32813:   }
32813: 
    1:   if (aTargetFrame) {
    1:     SetCursor(cursor, container, haveHotspot, hotspotX, hotspotY,
80486:               aTargetFrame->GetNearestWidget(), false);
    1:   }
    1: 
    1:   if (mLockCursor || NS_STYLE_CURSOR_AUTO != cursor) {
    1:     *aStatus = nsEventStatus_eConsumeDoDefault;
    1:   }
    1: }
    1: 
68780: nsresult
    1: nsEventStateManager::SetCursor(PRInt32 aCursor, imgIContainer* aContainer,
79445:                                bool aHaveHotspot,
    1:                                float aHotspotX, float aHotspotY,
79445:                                nsIWidget* aWidget, bool aLockCursor)
    1: {
54257:   EnsureDocument(mPresContext);
54257:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
54257:   sMouseOverDocument = mDocument.get();
54257: 
    1:   nsCursor c;
    1: 
    1:   NS_ENSURE_TRUE(aWidget, NS_ERROR_FAILURE);
    1:   if (aLockCursor) {
    1:     if (NS_STYLE_CURSOR_AUTO != aCursor) {
    1:       mLockCursor = aCursor;
    1:     }
    1:     else {
    1:       //If cursor style is set to auto we unlock the cursor again.
    1:       mLockCursor = 0;
    1:     }
    1:   }
    1:   switch (aCursor) {
    1:   default:
    1:   case NS_STYLE_CURSOR_AUTO:
    1:   case NS_STYLE_CURSOR_DEFAULT:
    1:     c = eCursor_standard;
    1:     break;
    1:   case NS_STYLE_CURSOR_POINTER:
    1:     c = eCursor_hyperlink;
    1:     break;
    1:   case NS_STYLE_CURSOR_CROSSHAIR:
    1:     c = eCursor_crosshair;
    1:     break;
    1:   case NS_STYLE_CURSOR_MOVE:
    1:     c = eCursor_move;
    1:     break;
    1:   case NS_STYLE_CURSOR_TEXT:
    1:     c = eCursor_select;
    1:     break;
    1:   case NS_STYLE_CURSOR_WAIT:
    1:     c = eCursor_wait;
    1:     break;
    1:   case NS_STYLE_CURSOR_HELP:
    1:     c = eCursor_help;
    1:     break;
    1:   case NS_STYLE_CURSOR_N_RESIZE:
    1:     c = eCursor_n_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_S_RESIZE:
    1:     c = eCursor_s_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_W_RESIZE:
    1:     c = eCursor_w_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_E_RESIZE:
    1:     c = eCursor_e_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_NW_RESIZE:
    1:     c = eCursor_nw_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_SE_RESIZE:
    1:     c = eCursor_se_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_NE_RESIZE:
    1:     c = eCursor_ne_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_SW_RESIZE:
    1:     c = eCursor_sw_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_COPY: // CSS3
    1:     c = eCursor_copy;
    1:     break;
    1:   case NS_STYLE_CURSOR_ALIAS:
    1:     c = eCursor_alias;
    1:     break;
    1:   case NS_STYLE_CURSOR_CONTEXT_MENU:
    1:     c = eCursor_context_menu;
    1:     break;
    1:   case NS_STYLE_CURSOR_CELL:
    1:     c = eCursor_cell;
    1:     break;
    1:   case NS_STYLE_CURSOR_GRAB:
    1:     c = eCursor_grab;
    1:     break;
    1:   case NS_STYLE_CURSOR_GRABBING:
    1:     c = eCursor_grabbing;
    1:     break;
    1:   case NS_STYLE_CURSOR_SPINNING:
    1:     c = eCursor_spinning;
    1:     break;
    1:   case NS_STYLE_CURSOR_MOZ_ZOOM_IN:
    1:     c = eCursor_zoom_in;
    1:     break;
    1:   case NS_STYLE_CURSOR_MOZ_ZOOM_OUT:
    1:     c = eCursor_zoom_out;
    1:     break;
    1:   case NS_STYLE_CURSOR_NOT_ALLOWED:
    1:     c = eCursor_not_allowed;
    1:     break;
    1:   case NS_STYLE_CURSOR_COL_RESIZE:
    1:     c = eCursor_col_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_ROW_RESIZE:
    1:     c = eCursor_row_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_NO_DROP:
    1:     c = eCursor_no_drop;
    1:     break;
    1:   case NS_STYLE_CURSOR_VERTICAL_TEXT:
    1:     c = eCursor_vertical_text;
    1:     break;
    1:   case NS_STYLE_CURSOR_ALL_SCROLL:
    1:     c = eCursor_all_scroll;
    1:     break;
    1:   case NS_STYLE_CURSOR_NESW_RESIZE:
    1:     c = eCursor_nesw_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_NWSE_RESIZE:
    1:     c = eCursor_nwse_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_NS_RESIZE:
    1:     c = eCursor_ns_resize;
    1:     break;
    1:   case NS_STYLE_CURSOR_EW_RESIZE:
    1:     c = eCursor_ew_resize;
    1:     break;
10405:   case NS_STYLE_CURSOR_NONE:
10405:     c = eCursor_none;
10405:     break;
    1:   }
    1: 
    1:   // First, try the imgIContainer, if non-null
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   if (aContainer) {
    1:     PRUint32 hotspotX, hotspotY;
    1: 
    1:     // css3-ui says to use the CSS-specified hotspot if present,
    1:     // otherwise use the intrinsic hotspot, otherwise use the top left
    1:     // corner.
    1:     if (aHaveHotspot) {
    1:       PRInt32 imgWidth, imgHeight;
    1:       aContainer->GetWidth(&imgWidth);
    1:       aContainer->GetHeight(&imgHeight);
    1: 
38390:       // XXX NS_MAX(NS_lround(x), 0)?
    1:       hotspotX = aHotspotX > 0.0f
    1:                    ? PRUint32(aHotspotX + 0.5f) : PRUint32(0);
    1:       if (hotspotX >= PRUint32(imgWidth))
    1:         hotspotX = imgWidth - 1;
    1:       hotspotY = aHotspotY > 0.0f
    1:                    ? PRUint32(aHotspotY + 0.5f) : PRUint32(0);
    1:       if (hotspotY >= PRUint32(imgHeight))
    1:         hotspotY = imgHeight - 1;
    1:     } else {
    1:       hotspotX = 0;
    1:       hotspotY = 0;
    1:       nsCOMPtr<nsIProperties> props(do_QueryInterface(aContainer));
    1:       if (props) {
    1:         nsCOMPtr<nsISupportsPRUint32> hotspotXWrap, hotspotYWrap;
    1: 
    1:         props->Get("hotspotX", NS_GET_IID(nsISupportsPRUint32), getter_AddRefs(hotspotXWrap));
    1:         props->Get("hotspotY", NS_GET_IID(nsISupportsPRUint32), getter_AddRefs(hotspotYWrap));
    1: 
    1:         if (hotspotXWrap)
    1:           hotspotXWrap->GetData(&hotspotX);
    1:         if (hotspotYWrap)
    1:           hotspotYWrap->GetData(&hotspotY);
    1:       }
    1:     }
    1: 
    1:     rv = aWidget->SetCursor(aContainer, hotspotX, hotspotY);
    1:   }
    1: 
    1:   if (NS_FAILED(rv))
    1:     aWidget->SetCursor(c);
    1: 
    1:   return NS_OK;
    1: }
    1: 
15594: class NS_STACK_CLASS nsESMEventCB : public nsDispatchingCallback
    1: {
    1: public:
    1:   nsESMEventCB(nsIContent* aTarget) : mTarget(aTarget) {}
    1: 
    1:   virtual void HandleEvent(nsEventChainPostVisitor& aVisitor)
    1:   {
    1:     if (aVisitor.mPresContext) {
36655:       nsIFrame* frame = aVisitor.mPresContext->GetPrimaryFrameFor(mTarget);
    1:       if (frame) {
    1:         frame->HandleEvent(aVisitor.mPresContext,
    1:                            (nsGUIEvent*) aVisitor.mEvent,
    1:                            &aVisitor.mEventStatus);
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> mTarget;
    1: };
    1: 
    1: nsIFrame*
    1: nsEventStateManager::DispatchMouseEvent(nsGUIEvent* aEvent, PRUint32 aMessage,
    1:                                         nsIContent* aTargetContent,
    1:                                         nsIContent* aRelatedContent)
    1: {
95203:   // http://dvcs.w3.org/hg/webevents/raw-file/default/mouse-lock.html#methods
95203:   // "[When the mouse is locked on an element...e]vents that require the concept
95203:   // of a mouse cursor must not be dispatched (for example: mouseover, mouseout).
95203:   if (sIsPointerLocked &&
95203:       (aMessage == NS_MOUSELEAVE ||
95203:        aMessage == NS_MOUSEENTER ||
95203:        aMessage == NS_MOUSE_ENTER_SYNTH ||
95203:        aMessage == NS_MOUSE_EXIT_SYNTH)) {
95203:     mCurrentTargetContent = nsnull;
95203:     nsCOMPtr<Element> pointerLockedElement =
95203:       do_QueryReferent(nsEventStateManager::sPointerLockedElement);
95203:     if (!pointerLockedElement) {
95203:       NS_WARNING("Should have pointer locked element, but didn't.");
95203:       return nsnull;
95203:     }
95203:     nsCOMPtr<nsIContent> content = do_QueryInterface(pointerLockedElement);
95203:     return mPresContext->GetPrimaryFrameFor(content);
95203:   }
95203: 
84290:   SAMPLE_LABEL("Input", "DispatchMouseEvent");
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsMouseEvent event(NS_IS_TRUSTED_EVENT(aEvent), aMessage, aEvent->widget,
    1:                      nsMouseEvent::eReal);
    1:   event.refPoint = aEvent->refPoint;
    1:   event.isShift = ((nsMouseEvent*)aEvent)->isShift;
    1:   event.isControl = ((nsMouseEvent*)aEvent)->isControl;
    1:   event.isAlt = ((nsMouseEvent*)aEvent)->isAlt;
    1:   event.isMeta = ((nsMouseEvent*)aEvent)->isMeta;
34743:   event.pluginEvent = ((nsMouseEvent*)aEvent)->pluginEvent;
    1:   event.relatedTarget = aRelatedContent;
40485:   event.inputSource = static_cast<nsMouseEvent*>(aEvent)->inputSource;
    1: 
51626:   nsWeakFrame previousTarget = mCurrentTarget;
51626: 
    1:   mCurrentTargetContent = aTargetContent;
    1: 
    1:   nsIFrame* targetFrame = nsnull;
    1:   if (aTargetContent) {
    1:     nsESMEventCB callback(aTargetContent);
    1:     nsEventDispatcher::Dispatch(aTargetContent, mPresContext, &event, nsnull,
    1:                                 &status, &callback);
    1: 
    1:     // Although the primary frame was checked in event callback, 
    1:     // it may not be the same object after event dispatching and handling.
    1:     // So we need to refetch it.
36655:     if (mPresContext) {
36655:       targetFrame = mPresContext->GetPrimaryFrameFor(aTargetContent);
    1:     }
    1:   }
    1: 
    1:   mCurrentTargetContent = nsnull;
51626:   mCurrentTarget = previousTarget;
    1: 
    1:   return targetFrame;
    1: }
    1: 
78422: class MouseEnterLeaveDispatcher
78422: {
78422: public:
78422:   MouseEnterLeaveDispatcher(nsEventStateManager* aESM,
78422:                             nsIContent* aTarget, nsIContent* aRelatedTarget,
78422:                             nsGUIEvent* aEvent, PRUint32 aType)
78422:   : mESM(aESM), mEvent(aEvent), mType(aType)
78422:   {
78422:     nsPIDOMWindow* win =
80526:       aTarget ? aTarget->OwnerDoc()->GetInnerWindow() : nsnull;
78422:     if (win && win->HasMouseEnterLeaveEventListeners()) {
78422:       mRelatedTarget = aRelatedTarget ?
78422:         aRelatedTarget->FindFirstNonNativeAnonymous() : nsnull;
78422:       nsINode* commonParent = nsnull;
78422:       if (aTarget && aRelatedTarget) {
78422:         commonParent =
78422:           nsContentUtils::GetCommonAncestor(aTarget, aRelatedTarget);
78422:       }
78422:       nsIContent* current = aTarget;
78422:       // Note, it is ok if commonParent is null!
78422:       while (current && current != commonParent) {
78422:         if (!current->IsInNativeAnonymousSubtree()) {
78422:           mTargets.AppendObject(current);
78422:         }
78422:         // mouseenter/leave is fired only on elements.
78422:         current = current->GetParent();
78422:       }
78422:     }
78422:   }
78422: 
78422:   ~MouseEnterLeaveDispatcher()
78422:   {
78422:     for (PRInt32 i = 0; i < mTargets.Count(); ++i) {
78422:       mESM->DispatchMouseEvent(mEvent, mType, mTargets[i], mRelatedTarget);
78422:     }
78422:   }
78422: 
78422:   nsEventStateManager*   mESM;
78422:   nsCOMArray<nsIContent> mTargets;
78422:   nsCOMPtr<nsIContent>   mRelatedTarget;
78422:   nsGUIEvent*            mEvent;
78422:   PRUint32               mType;
78422: };
78422: 
    1: void
    1: nsEventStateManager::NotifyMouseOut(nsGUIEvent* aEvent, nsIContent* aMovingInto)
    1: {
    1:   if (!mLastMouseOverElement)
    1:     return;
    1:   // Before firing mouseout, check for recursion
    1:   if (mLastMouseOverElement == mFirstMouseOutEventElement)
    1:     return;
    1: 
    1:   if (mLastMouseOverFrame) {
    1:     // if the frame is associated with a subdocument,
    1:     // tell the subdocument that we're moving out of it
51754:     nsSubDocumentFrame* subdocFrame = do_QueryFrame(mLastMouseOverFrame.GetFrame());
    1:     if (subdocFrame) {
    1:       nsCOMPtr<nsIDocShell> docshell;
    1:       subdocFrame->GetDocShell(getter_AddRefs(docshell));
    1:       if (docshell) {
39823:         nsRefPtr<nsPresContext> presContext;
    1:         docshell->GetPresContext(getter_AddRefs(presContext));
    1: 
    1:         if (presContext) {
68780:           nsEventStateManager* kidESM = presContext->EventStateManager();
    1:           // Not moving into any element in this subdocument
    1:           kidESM->NotifyMouseOut(aEvent, nsnull);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   // That could have caused DOM events which could wreak havoc. Reverify
    1:   // things and be careful.
    1:   if (!mLastMouseOverElement)
    1:     return;
    1: 
    1:   // Store the first mouseOut event we fire and don't refire mouseOut
    1:   // to that element while the first mouseOut is still ongoing.
    1:   mFirstMouseOutEventElement = mLastMouseOverElement;
    1: 
    1:   // Don't touch hover state if aMovingInto is non-null.  Caller will update
    1:   // hover state itself, and we have optimizations for hover switching between
    1:   // two nearby elements both deep in the DOM tree that would be defeated by
    1:   // switching the hover state to null here.
    1:   if (!aMovingInto) {
    1:     // Unset :hover
    1:     SetContentState(nsnull, NS_EVENT_STATE_HOVER);
    1:   }
    1: 
78422:   MouseEnterLeaveDispatcher leaveDispatcher(this, mLastMouseOverElement, aMovingInto,
78422:                                             aEvent, NS_MOUSELEAVE);
78422: 
    1:   // Fire mouseout
    1:   DispatchMouseEvent(aEvent, NS_MOUSE_EXIT_SYNTH,
    1:                      mLastMouseOverElement, aMovingInto);
    1:   
    1:   mLastMouseOverFrame = nsnull;
    1:   mLastMouseOverElement = nsnull;
    1:   
    1:   // Turn recursion protection back off
    1:   mFirstMouseOutEventElement = nsnull;
    1: }
    1: 
    1: void
    1: nsEventStateManager::NotifyMouseOver(nsGUIEvent* aEvent, nsIContent* aContent)
    1: {
    1:   NS_ASSERTION(aContent, "Mouse must be over something");
    1: 
    1:   if (mLastMouseOverElement == aContent)
    1:     return;
    1: 
    1:   // Before firing mouseover, check for recursion
    1:   if (aContent == mFirstMouseOverEventElement)
    1:     return;
    1: 
    1:   // Check to see if we're a subdocument and if so update the parent
    1:   // document's ESM state to indicate that the mouse is over the
    1:   // content associated with our subdocument.
    1:   EnsureDocument(mPresContext);
    1:   nsIDocument *parentDoc = mDocument->GetParentDocument();
    1:   if (parentDoc) {
    1:     nsIContent *docContent = parentDoc->FindContentForSubDocument(mDocument);
    1:     if (docContent) {
46225:       nsIPresShell *parentShell = parentDoc->GetShell();
    1:       if (parentShell) {
68780:         nsEventStateManager* parentESM = parentShell->GetPresContext()->EventStateManager();
    1:         parentESM->NotifyMouseOver(aEvent, docContent);
    1:       }
    1:     }
    1:   }
    1:   // Firing the DOM event in the parent document could cause all kinds
    1:   // of havoc.  Reverify and take care.
    1:   if (mLastMouseOverElement == aContent)
    1:     return;
    1: 
    1:   // Remember mLastMouseOverElement as the related content for the
    1:   // DispatchMouseEvent() call below, since NotifyMouseOut() resets it, bug 298477.
    1:   nsCOMPtr<nsIContent> lastMouseOverElement = mLastMouseOverElement;
    1: 
78422:   MouseEnterLeaveDispatcher enterDispatcher(this, aContent, lastMouseOverElement,
78422:                                             aEvent, NS_MOUSEENTER);
78422:   
    1:   NotifyMouseOut(aEvent, aContent);
    1: 
    1:   // Store the first mouseOver event we fire and don't refire mouseOver
    1:   // to that element while the first mouseOver is still ongoing.
    1:   mFirstMouseOverEventElement = aContent;
    1:   
    1:   SetContentState(aContent, NS_EVENT_STATE_HOVER);
    1:   
    1:   // Fire mouseover
    1:   mLastMouseOverFrame = DispatchMouseEvent(aEvent, NS_MOUSE_ENTER_SYNTH,
    1:                                            aContent, lastMouseOverElement);
    1:   mLastMouseOverElement = aContent;
    1:   
    1:   // Turn recursion protection back off
    1:   mFirstMouseOverEventElement = nsnull;
    1: }
    1: 
    1: void
    1: nsEventStateManager::GenerateMouseEnterExit(nsGUIEvent* aEvent)
    1: {
    1:   EnsureDocument(mPresContext);
    1:   if (!mDocument)
    1:     return;
    1: 
    1:   // Hold onto old target content through the event and reset after.
    1:   nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
    1: 
    1:   switch(aEvent->message) {
    1:   case NS_MOUSE_MOVE:
    1:     {
95203:       if (sIsPointerLocked && aEvent->widget) {
95203:         // Perform mouse lock by recentering the mouse directly, then remembering the deltas.
95203:         nsIntRect bounds;
95203:         aEvent->widget->GetScreenBounds(bounds);
95203:         aEvent->lastRefPoint = GetMouseCoords(bounds);
95203: 
95203:         // refPoint should not be the centre on mousemove
95203:         if (aEvent->refPoint.x == aEvent->lastRefPoint.x &&
95203:             aEvent->refPoint.y == aEvent->lastRefPoint.y) {
95203:           aEvent->refPoint = sLastRefPoint;
95203:         } else {
95203:           aEvent->widget->SynthesizeNativeMouseMove(aEvent->lastRefPoint);
95203:         }
95203:       } else {
95203:         aEvent->lastRefPoint = nsIntPoint(sLastRefPoint.x, sLastRefPoint.y);
95203:       }
95203: 
95203:       // Update the last known refPoint with the current refPoint.
95203:       sLastRefPoint = nsIntPoint(aEvent->refPoint.x, aEvent->refPoint.y);
95203: 
    1:       // Get the target content target (mousemove target == mouseover target)
68780:       nsCOMPtr<nsIContent> targetElement = GetEventTargetContent(aEvent);
    1:       if (!targetElement) {
    1:         // We're always over the document root, even if we're only
    1:         // over dead space in a page (whose frame is not associated with
    1:         // any content) or in print preview dead space
41634:         targetElement = mDocument->GetRootElement();
    1:       }
    1:       if (targetElement) {
    1:         NotifyMouseOver(aEvent, targetElement);
    1:       }
    1:     }
    1:     break;
    1:   case NS_MOUSE_EXIT:
    1:     {
    1:       // This is actually the window mouse exit event. We're not moving
    1:       // into any new element.
 8562: 
 8562:       if (mLastMouseOverFrame &&
 8562:           nsContentUtils::GetTopLevelWidget(aEvent->widget) !=
47148:           nsContentUtils::GetTopLevelWidget(mLastMouseOverFrame->GetNearestWidget())) {
 8562:         // the MouseOut event widget doesn't have same top widget with
 8562:         // mLastMouseOverFrame, it's a spurious event for mLastMouseOverFrame
 8562:         break;
 8562:       }
 8562: 
    1:       NotifyMouseOut(aEvent, nsnull);
    1:     }
    1:     break;
    1:   }
    1: 
    1:   // reset mCurretTargetContent to what it was
    1:   mCurrentTargetContent = targetBeforeEvent;
    1: }
    1: 
    1: void
95203: nsEventStateManager::SetPointerLock(nsIWidget* aWidget,
95203:                                     nsIContent* aElement)
95203: {
95203:   // NOTE: aElement will be nsnull when unlocking.
95203:   sIsPointerLocked = !!aElement;
95203: 
95203:   if (!aWidget) {
95203:     return;
95203:   }
95203: 
95203:   // Reset mouse wheel transaction
95203:   nsMouseWheelTransaction::EndTransaction();
95203: 
95203:   // Deal with DnD events
95203:   nsCOMPtr<nsIDragService> dragService =
95203:     do_GetService("@mozilla.org/widget/dragservice;1");
95203: 
95203:   if (sIsPointerLocked) {
95203:     // Store the last known ref point so we can reposition the pointer after unlock.
95203:     mPreLockPoint = sLastRefPoint + sLastScreenOffset;
95203: 
95203:     nsIntRect bounds;
95203:     aWidget->GetScreenBounds(bounds);
95203:     sLastRefPoint = GetMouseCoords(bounds);
95203:     aWidget->SynthesizeNativeMouseMove(sLastRefPoint);
95203: 
95203:     // Retarget all events to this element via capture.
95203:     nsIPresShell::SetCapturingContent(aElement, CAPTURE_POINTERLOCK);
95203: 
95203:     // Suppress DnD
95203:     if (dragService) {
95203:       dragService->Suppress();
95203:     }
95203:   } else {
95203:     // Unlocking, so return pointer to the original position
95203:     aWidget->SynthesizeNativeMouseMove(sLastScreenPoint);
95203: 
95203:     // Don't retarget events to this element any more.
95203:     nsIPresShell::SetCapturingContent(nsnull, CAPTURE_POINTERLOCK);
95203: 
95203:     // Unsuppress DnD
95203:     if (dragService) {
95203:       dragService->Unsuppress();
95203:     }
95203:   }
95203: }
95203: 
95203: nsIntPoint
95203: nsEventStateManager::GetMouseCoords(nsIntRect aBounds)
95203: {
95203:   NS_ASSERTION(sIsPointerLocked, "GetMouseCoords when not pointer locked!");
95203: 
95203:   nsCOMPtr<nsIDocument> pointerLockedDoc =
95203:     do_QueryReferent(nsEventStateManager::sPointerLockedDoc);
95203:   if (!pointerLockedDoc) {
95203:     NS_WARNING("GetMouseCoords(): No Document");
95203:     return nsIntPoint(0, 0);
95203:   }
95203: 
95203:   nsCOMPtr<nsPIDOMWindow> domWin = pointerLockedDoc->GetInnerWindow();
95203:   if (!domWin) {
95203:     NS_WARNING("GetMouseCoords(): No Window");
95203:     return nsIntPoint(0, 0);
95203:   }
95203: 
95203:   int innerHeight;
95203:   domWin->GetInnerHeight(&innerHeight);
95203: 
95203:   return nsIntPoint((aBounds.width / 2) + aBounds.x,
95203:                     (innerHeight / 2) + (aBounds.y + (aBounds.height - innerHeight)));
95203: }
95203: 
95203: void
    1: nsEventStateManager::GenerateDragDropEnterExit(nsPresContext* aPresContext,
    1:                                                nsGUIEvent* aEvent)
    1: {
    1:   //Hold onto old target content through the event and reset after.
    1:   nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
    1: 
    1:   switch(aEvent->message) {
    1:   case NS_DRAGDROP_OVER:
    1:     {
58550:       // when dragging from one frame to another, events are fired in the
58550:       // order: dragexit, dragenter, dragleave
79435:       if (sLastDragOverFrame != mCurrentTarget) {
    1:         //We'll need the content, too, to check if it changed separately from the frames.
    1:         nsCOMPtr<nsIContent> lastContent;
    1:         nsCOMPtr<nsIContent> targetContent;
79435:         mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
79435: 
79435:         if (sLastDragOverFrame) {
  482:           //The frame has changed but the content may not have. Check before dispatching to content
79435:           sLastDragOverFrame->GetContentForEvent(aEvent, getter_AddRefs(lastContent));
79435: 
79435:           FireDragEnterOrExit(sLastDragOverFrame->PresContext(),
79435:                               aEvent, NS_DRAGDROP_EXIT_SYNTH,
79435:                               targetContent, lastContent, sLastDragOverFrame);
58550:         }
58550: 
58550:         FireDragEnterOrExit(aPresContext, aEvent, NS_DRAGDROP_ENTER,
58550:                             lastContent, targetContent, mCurrentTarget);
58550: 
79435:         if (sLastDragOverFrame) {
79435:           FireDragEnterOrExit(sLastDragOverFrame->PresContext(),
79435:                               aEvent, NS_DRAGDROP_LEAVE_SYNTH,
79435:                               targetContent, lastContent, sLastDragOverFrame);
79435:         }
79435: 
79435:         sLastDragOverFrame = mCurrentTarget;
  482:       }
  482:     }
  482:     break;
  482: 
  482:   case NS_DRAGDROP_EXIT:
  482:     {
  482:       //This is actually the window mouse exit event.
79435:       if (sLastDragOverFrame) {
  482:         nsCOMPtr<nsIContent> lastContent;
79435:         sLastDragOverFrame->GetContentForEvent(aEvent, getter_AddRefs(lastContent));
79435: 
79435:         nsRefPtr<nsPresContext> lastDragOverFramePresContext = sLastDragOverFrame->PresContext();
79435:         FireDragEnterOrExit(lastDragOverFramePresContext,
79435:                             aEvent, NS_DRAGDROP_EXIT_SYNTH,
79435:                             nsnull, lastContent, sLastDragOverFrame);
79435:         FireDragEnterOrExit(lastDragOverFramePresContext,
79435:                             aEvent, NS_DRAGDROP_LEAVE_SYNTH,
79435:                             nsnull, lastContent, sLastDragOverFrame);
79435: 
79435:         sLastDragOverFrame = nsnull;
  482:       }
  482:     }
  482:     break;
  482:   }
  482: 
  482:   //reset mCurretTargetContent to what it was
  482:   mCurrentTargetContent = targetBeforeEvent;
  482: 
  482:   // Now flush all pending notifications, for better responsiveness.
  482:   FlushPendingEvents(aPresContext);
  482: }
  482: 
  482: void
  482: nsEventStateManager::FireDragEnterOrExit(nsPresContext* aPresContext,
  482:                                          nsGUIEvent* aEvent,
  482:                                          PRUint32 aMsg,
  482:                                          nsIContent* aRelatedTarget,
  482:                                          nsIContent* aTargetContent,
  482:                                          nsWeakFrame& aTargetFrame)
  482: {
    1:   nsEventStatus status = nsEventStatus_eIgnore;
18445:   nsDragEvent event(NS_IS_TRUSTED_EVENT(aEvent), aMsg, aEvent->widget);
    1:   event.refPoint = aEvent->refPoint;
    1:   event.isShift = ((nsMouseEvent*)aEvent)->isShift;
    1:   event.isControl = ((nsMouseEvent*)aEvent)->isControl;
    1:   event.isAlt = ((nsMouseEvent*)aEvent)->isAlt;
    1:   event.isMeta = ((nsMouseEvent*)aEvent)->isMeta;
  482:   event.relatedTarget = aRelatedTarget;
40485:   event.inputSource = static_cast<nsMouseEvent*>(aEvent)->inputSource;
  482: 
  482:   mCurrentTargetContent = aTargetContent;
  482: 
  482:   if (aTargetContent != aRelatedTarget) {
    1:     //XXX This event should still go somewhere!!
  482:     if (aTargetContent)
  482:       nsEventDispatcher::Dispatch(aTargetContent, aPresContext, &event,
    1:                                   nsnull, &status);
    1: 
19702:     // adjust the drag hover if the dragenter event was cancelled or this is a drag exit
19702:     if (status == nsEventStatus_eConsumeNoDefault || aMsg == NS_DRAGDROP_EXIT)
  482:       SetContentState((aMsg == NS_DRAGDROP_ENTER) ? aTargetContent : nsnull,
  482:                       NS_EVENT_STATE_DRAGOVER);
33528: 
33528:     // collect any changes to moz cursor settings stored in the event's
33528:     // data transfer.
33528:     if (aMsg == NS_DRAGDROP_LEAVE_SYNTH || aMsg == NS_DRAGDROP_EXIT_SYNTH ||
33528:         aMsg == NS_DRAGDROP_ENTER)
33528:       UpdateDragDataTransfer(&event);
  482:   }
  482: 
  482:   // Finally dispatch the event to the frame
  482:   if (aTargetFrame)
  482:     aTargetFrame->HandleEvent(aPresContext, &event, &status);
    1: }
    1: 
33528: void
33528: nsEventStateManager::UpdateDragDataTransfer(nsDragEvent* dragEvent)
33528: {
33528:   NS_ASSERTION(dragEvent, "drag event is null in UpdateDragDataTransfer!");
33528:   if (!dragEvent->dataTransfer)
33528:     return;
33528: 
33528:   nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
33528: 
33528:   if (dragSession) {
33528:     // the initial dataTransfer is the one from the dragstart event that
33528:     // was set on the dragSession when the drag began.
33528:     nsCOMPtr<nsIDOMDataTransfer> initialDataTransfer;
33528:     dragSession->GetDataTransfer(getter_AddRefs(initialDataTransfer));
89615:     if (initialDataTransfer) {
33528:       // retrieve the current moz cursor setting and save it.
33528:       nsAutoString mozCursor;
89615:       dragEvent->dataTransfer->GetMozCursor(mozCursor);
89615:       initialDataTransfer->SetMozCursor(mozCursor);
33528:     }
33528:   }
33528: }
33528: 
    1: nsresult
    1: nsEventStateManager::SetClickCount(nsPresContext* aPresContext,
    1:                                    nsMouseEvent *aEvent,
    1:                                    nsEventStatus* aStatus)
    1: {
    1:   nsCOMPtr<nsIContent> mouseContent;
69450:   nsIContent* mouseContentParent = nsnull;
79435:   mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(mouseContent));
69450:   if (mouseContent) {
69450:     if (mouseContent->IsNodeOfType(nsINode::eTEXT)) {
69450:       mouseContent = mouseContent->GetParent();
69450:     }
69450:     if (mouseContent && mouseContent->IsRootOfNativeAnonymousSubtree()) {
69450:       mouseContentParent = mouseContent->GetParent();
69450:     }
69450:   }
    1: 
    1:   switch (aEvent->button) {
    1:   case nsMouseEvent::eLeftButton:
    1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
    1:       mLastLeftMouseDownContent = mouseContent;
51869:       mLastLeftMouseDownContentParent = mouseContentParent;
    1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
37465:       if (mLastLeftMouseDownContent == mouseContent ||
51869:           mLastLeftMouseDownContentParent == mouseContent ||
51869:           mLastLeftMouseDownContent == mouseContentParent) {
    1:         aEvent->clickCount = mLClickCount;
    1:         mLClickCount = 0;
    1:       } else {
    1:         aEvent->clickCount = 0;
    1:       }
    1:       mLastLeftMouseDownContent = nsnull;
37465:       mLastLeftMouseDownContentParent = nsnull;
    1:     }
    1:     break;
    1: 
    1:   case nsMouseEvent::eMiddleButton:
    1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
    1:       mLastMiddleMouseDownContent = mouseContent;
51869:       mLastMiddleMouseDownContentParent = mouseContentParent;
    1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
37465:       if (mLastMiddleMouseDownContent == mouseContent ||
51869:           mLastMiddleMouseDownContentParent == mouseContent ||
52181:           mLastMiddleMouseDownContent == mouseContentParent) {
    1:         aEvent->clickCount = mMClickCount;
    1:         mMClickCount = 0;
    1:       } else {
    1:         aEvent->clickCount = 0;
    1:       }
37465:       mLastMiddleMouseDownContent = nsnull;
37465:       mLastMiddleMouseDownContentParent = nsnull;
    1:     }
    1:     break;
    1: 
    1:   case nsMouseEvent::eRightButton:
    1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
    1:       mLastRightMouseDownContent = mouseContent;
51869:       mLastRightMouseDownContentParent = mouseContentParent;
    1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
37465:       if (mLastRightMouseDownContent == mouseContent ||
51869:           mLastRightMouseDownContentParent == mouseContent ||
52181:           mLastRightMouseDownContent == mouseContentParent) {
    1:         aEvent->clickCount = mRClickCount;
    1:         mRClickCount = 0;
    1:       } else {
    1:         aEvent->clickCount = 0;
    1:       }
37465:       mLastRightMouseDownContent = nsnull;
37465:       mLastRightMouseDownContentParent = nsnull;
    1:     }
    1:     break;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsEventStateManager::CheckForAndDispatchClick(nsPresContext* aPresContext,
    1:                                               nsMouseEvent *aEvent,
    1:                                               nsEventStatus* aStatus)
    1: {
    1:   nsresult ret = NS_OK;
    1:   PRInt32 flags = NS_EVENT_FLAG_NONE;
    1: 
    1:   //If mouse is still over same element, clickcount will be > 1.
    1:   //If it has moved it will be zero, so no click.
    1:   if (0 != aEvent->clickCount) {
    1:     //Check that the window isn't disabled before firing a click
    1:     //(see bug 366544).
    1:     if (aEvent->widget) {
79445:       bool enabled;
    1:       aEvent->widget->IsEnabled(&enabled);
    1:       if (!enabled) {
    1:         return ret;
    1:       }
    1:     }
    1:     //fire click
    1:     if (aEvent->button == nsMouseEvent::eMiddleButton ||
    1:         aEvent->button == nsMouseEvent::eRightButton) {
    1:       flags |=
    1:         sLeftClickOnly ? NS_EVENT_FLAG_NO_CONTENT_DISPATCH : NS_EVENT_FLAG_NONE;
    1:     }
    1: 
    1:     nsMouseEvent event(NS_IS_TRUSTED_EVENT(aEvent), NS_MOUSE_CLICK, aEvent->widget,
    1:                        nsMouseEvent::eReal);
    1:     event.refPoint = aEvent->refPoint;
    1:     event.clickCount = aEvent->clickCount;
    1:     event.isShift = aEvent->isShift;
    1:     event.isControl = aEvent->isControl;
    1:     event.isAlt = aEvent->isAlt;
    1:     event.isMeta = aEvent->isMeta;
    1:     event.time = aEvent->time;
    1:     event.flags |= flags;
    1:     event.button = aEvent->button;
40485:     event.inputSource = aEvent->inputSource;
    1: 
    1:     nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
    1:     if (presShell) {
68780:       nsCOMPtr<nsIContent> mouseContent = GetEventTargetContent(aEvent);
    1: 
    1:       ret = presShell->HandleEventWithTarget(&event, mCurrentTarget,
    1:                                              mouseContent, aStatus);
    1:       if (NS_SUCCEEDED(ret) && aEvent->clickCount == 2) {
    1:         //fire double click
    1:         nsMouseEvent event2(NS_IS_TRUSTED_EVENT(aEvent), NS_MOUSE_DOUBLECLICK,
    1:                             aEvent->widget, nsMouseEvent::eReal);
    1:         event2.refPoint = aEvent->refPoint;
    1:         event2.clickCount = aEvent->clickCount;
    1:         event2.isShift = aEvent->isShift;
    1:         event2.isControl = aEvent->isControl;
    1:         event2.isAlt = aEvent->isAlt;
    1:         event2.isMeta = aEvent->isMeta;
    1:         event2.flags |= flags;
    1:         event2.button = aEvent->button;
40485:         event2.inputSource = aEvent->inputSource;
    1: 
    1:         ret = presShell->HandleEventWithTarget(&event2, mCurrentTarget,
    1:                                                mouseContent, aStatus);
    1:       }
    1:     }
    1:   }
    1:   return ret;
    1: }
    1: 
68780: nsIFrame*
68780: nsEventStateManager::GetEventTarget()
    1: {
30569:   nsIPresShell *shell;
30569:   if (mCurrentTarget ||
30569:       !mPresContext ||
30569:       !(shell = mPresContext->GetPresShell())) {
68780:     return mCurrentTarget;
30569:   }
30569: 
30569:   if (mCurrentTargetContent) {
36655:     mCurrentTarget = mPresContext->GetPrimaryFrameFor(mCurrentTargetContent);
30569:     if (mCurrentTarget) {
68780:       return mCurrentTarget;
30569:     }
30569:   }
30569: 
40047:   nsIFrame* frame = shell->GetEventTargetFrame();
68780:   return (mCurrentTarget = frame);
68780: }
68780: 
68780: already_AddRefed<nsIContent>
68780: nsEventStateManager::GetEventTargetContent(nsEvent* aEvent)
    1: {
    1:   if (aEvent &&
    1:       (aEvent->message == NS_FOCUS_CONTENT ||
    1:        aEvent->message == NS_BLUR_CONTENT)) {
68780:     nsCOMPtr<nsIContent> content = GetFocusedContent();
68780:     return content.forget();
    1:   }
    1: 
    1:   if (mCurrentTargetContent) {
68780:     nsCOMPtr<nsIContent> content = mCurrentTargetContent;
68780:     return content.forget();
68780:   }
68780: 
68780:   nsIContent *content = nsnull;
    1: 
    1:   nsIPresShell *presShell = mPresContext->GetPresShell();
    1:   if (presShell) {
68780:     content = presShell->GetEventTargetContent(aEvent).get();
    1:   }
    1: 
    1:   // Some events here may set mCurrentTarget but not set the corresponding
    1:   // event target in the PresShell.
68780:   if (!content && mCurrentTarget) {
79435:     mCurrentTarget->GetContentForEvent(aEvent, &content);
68780:   }
68780: 
68780:   return content;
    1: }
    1: 
70852: static Element*
70852: GetLabelTarget(nsIContent* aPossibleLabel)
42951: {
70852:   nsHTMLLabelElement* label = nsHTMLLabelElement::FromContent(aPossibleLabel);
42951:   if (!label)
42951:     return nsnull;
42951: 
70852:   return label->GetLabeledElement();
42951: }
42951: 
    1: static nsIContent* FindCommonAncestor(nsIContent *aNode1, nsIContent *aNode2)
    1: {
    1:   // Find closest common ancestor
    1:   if (aNode1 && aNode2) {
    1:     // Find the nearest common ancestor by counting the distance to the
    1:     // root and then walking up again, in pairs.
    1:     PRInt32 offset = 0;
    1:     nsIContent *anc1 = aNode1;
    1:     for (;;) {
    1:       ++offset;
    1:       nsIContent* parent = anc1->GetParent();
    1:       if (!parent)
    1:         break;
    1:       anc1 = parent;
    1:     }
    1:     nsIContent *anc2 = aNode2;
    1:     for (;;) {
    1:       --offset;
    1:       nsIContent* parent = anc2->GetParent();
    1:       if (!parent)
    1:         break;
    1:       anc2 = parent;
    1:     }
    1:     if (anc1 == anc2) {
    1:       anc1 = aNode1;
    1:       anc2 = aNode2;
    1:       while (offset > 0) {
    1:         anc1 = anc1->GetParent();
    1:         --offset;
    1:       }
    1:       while (offset < 0) {
    1:         anc2 = anc2->GetParent();
    1:         ++offset;
    1:       }
    1:       while (anc1 != anc2) {
    1:         anc1 = anc1->GetParent();
    1:         anc2 = anc2->GetParent();
    1:       }
    1:       return anc1;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
81144: static Element*
81144: GetParentElement(Element* aElement)
81144: {
81144:   nsIContent* p = aElement->GetParent();
81144:   return (p && p->IsElement()) ? p->AsElement() : nsnull;
81144: }
81144: 
71112: /* static */
77844: void
81144: nsEventStateManager::SetFullScreenState(Element* aElement, bool aIsFullScreen)
77844: {
77844:   DoStateChange(aElement, NS_EVENT_STATE_FULL_SCREEN, aIsFullScreen);
81144:   Element* ancestor = aElement;
81144:   while ((ancestor = GetParentElement(ancestor))) {
81144:     DoStateChange(ancestor, NS_EVENT_STATE_FULL_SCREEN_ANCESTOR, aIsFullScreen);
81144:   }
77844: }
77844: 
77844: /* static */
71112: inline void
71112: nsEventStateManager::DoStateChange(Element* aElement, nsEventStates aState,
79445:                                    bool aAddState)
42949: {
71112:   if (aAddState) {
71112:     aElement->AddStates(aState);
71112:   } else {
71112:     aElement->RemoveStates(aState);
71112:   }
71112: }
71112: 
71112: /* static */
71113: inline void
71113: nsEventStateManager::DoStateChange(nsIContent* aContent, nsEventStates aState,
79445:                                    bool aStateAdded)
71113: {
71113:   if (aContent->IsElement()) {
71113:     DoStateChange(aContent->AsElement(), aState, aStateAdded);
71113:   }
71113: }
71113: 
71113: /* static */
71112: void
71112: nsEventStateManager::UpdateAncestorState(nsIContent* aStartNode,
71112:                                          nsIContent* aStopBefore,
71112:                                          nsEventStates aState,
79445:                                          bool aAddState)
71112: {
71112:   for (; aStartNode && aStartNode != aStopBefore;
71112:        aStartNode = aStartNode->GetParent()) {
71112:     // We might be starting with a non-element (e.g. a text node) and
71112:     // if someone is doing something weird might be ending with a
71112:     // non-element too (e.g. a document fragment)
71112:     if (!aStartNode->IsElement()) {
71112:       continue;
71112:     }
71112:     Element* element = aStartNode->AsElement();
71112:     DoStateChange(element, aState, aAddState);
71112:     Element* labelTarget = GetLabelTarget(element);
42951:     if (labelTarget) {
71112:       DoStateChange(labelTarget, aState, aAddState);
71112:     }
42949:   }
86028: 
86028:   if (aAddState) {
86028:     // We might be in a situation where a node was in hover both
86028:     // because it was hovered and because the label for it was
86028:     // hovered, and while we stopped hovering the node the label is
86028:     // still hovered.  Or we might have had two nested labels for the
86028:     // same node, and while one is no longer hovered the other still
86028:     // is.  In that situation, the label that's still hovered will be
86028:     // aStopBefore or some ancestor of it, and the call we just made
86028:     // to UpdateAncestorState with aAddState = false would have
86028:     // removed the hover state from the node.  But the node should
86028:     // still be in hover state.  To handle this situation we need to
86028:     // keep walking up the tree and any time we find a label mark its
86028:     // corresponding node as still in our state.
86028:     for ( ; aStartNode; aStartNode = aStartNode->GetParent()) {
86028:       if (!aStartNode->IsElement()) {
86028:         continue;
86028:       }
86028: 
86028:       Element* labelTarget = GetLabelTarget(aStartNode->AsElement());
86028:       if (labelTarget && !labelTarget->State().HasState(aState)) {
86028:         DoStateChange(labelTarget, aState, true);
86028:       }
86028:     }
86028:   }
42949: }
42949: 
79445: bool
56168: nsEventStateManager::SetContentState(nsIContent *aContent, nsEventStates aState)
    1: {
64122:   // We manage 4 states here: ACTIVE, HOVER, DRAGOVER, URLTARGET
64122:   // The input must be exactly one of them.
64122:   NS_PRECONDITION(aState == NS_EVENT_STATE_ACTIVE ||
64122:                   aState == NS_EVENT_STATE_HOVER ||
64122:                   aState == NS_EVENT_STATE_DRAGOVER ||
64122:                   aState == NS_EVENT_STATE_URLTARGET,
64122:                   "Unexpected state");
64122: 
64122:   nsCOMPtr<nsIContent> notifyContent1;
64122:   nsCOMPtr<nsIContent> notifyContent2;
79445:   bool updateAncestors;
64122: 
64122:   if (aState == NS_EVENT_STATE_HOVER || aState == NS_EVENT_STATE_ACTIVE) {
64122:     // Hover and active are hierarchical
80486:     updateAncestors = true;
    1: 
    1:     // check to see that this state is allowed by style. Check dragover too?
    1:     // XXX Is this even what we want?
64122:     if (mCurrentTarget)
    1:     {
    1:       const nsStyleUserInterface* ui = mCurrentTarget->GetStyleUserInterface();
    1:       if (ui->mUserInput == NS_STYLE_USER_INPUT_NONE)
80486:         return false;
    1:     }
    1: 
64122:     if (aState == NS_EVENT_STATE_ACTIVE) {
64122:       if (aContent != mActiveContent) {
64122:         notifyContent1 = aContent;
64122:         notifyContent2 = mActiveContent;
    1:         mActiveContent = aContent;
    1:       }
64122:     } else {
64122:       NS_ASSERTION(aState == NS_EVENT_STATE_HOVER, "How did that happen?");
64122:       nsIContent* newHover;
    1:       
63649:       if (mPresContext->IsDynamic()) {
    1:         newHover = aContent;
    1:       } else {
36655:         NS_ASSERTION(!aContent ||
36655:                      aContent->GetCurrentDoc() == mPresContext->PresShell()->GetDocument(),
36655:                      "Unexpected document");
36655:         nsIFrame *frame = aContent ? aContent->GetPrimaryFrame() : nsnull;
    1:         if (frame && nsLayoutUtils::IsViewportScrollbarFrame(frame)) {
    1:           // The scrollbars of viewport should not ignore the hover state.
    1:           // Because they are *not* the content of the web page.
    1:           newHover = aContent;
    1:         } else {
    1:           // All contents of the web page should ignore the hover state.
    1:           newHover = nsnull;
    1:         }
    1:       }
    1: 
64122:       if (newHover != mHoverContent) {
64122:         notifyContent1 = newHover;
64122:         notifyContent2 = mHoverContent;
64122:         mHoverContent = newHover;
64122:       }
64122:     }
64122:   } else {
80486:     updateAncestors = false;
64122:     if (aState == NS_EVENT_STATE_DRAGOVER) {
79435:       if (aContent != sDragOverContent) {
64122:         notifyContent1 = aContent;
79435:         notifyContent2 = sDragOverContent;
79435:         sDragOverContent = aContent;
64122:       }
64122:     } else if (aState == NS_EVENT_STATE_URLTARGET) {
64122:       if (aContent != mURLTargetContent) {
64122:         notifyContent1 = aContent;
64122:         notifyContent2 = mURLTargetContent;
64122:         mURLTargetContent = aContent;
64122:       }
64122:     }
64122:   }
64122: 
71112:   // We need to keep track of which of notifyContent1 and notifyContent2 is
71112:   // getting the state set and which is getting it unset.  If both are
71112:   // non-null, then notifyContent1 is having the state set and notifyContent2
71112:   // is having it unset.  But if one of them is null, we need to keep track of
71112:   // the right thing for notifyContent1 explicitly.
79445:   bool content1StateSet = true;
64122:   if (!notifyContent1) {
64122:     // This is ok because FindCommonAncestor wouldn't find anything
64122:     // anyway if notifyContent1 is null.
64122:     notifyContent1 = notifyContent2;
64122:     notifyContent2 = nsnull;
80486:     content1StateSet = false;
64122:   }
64122: 
64122:   if (notifyContent1 && mPresContext) {
    1:     EnsureDocument(mPresContext);
64122:     if (mDocument) {
71103:       nsAutoScriptBlocker scriptBlocker;
64122: 
71112:       if (updateAncestors) {
64122:         nsCOMPtr<nsIContent> commonAncestor =
64122:           FindCommonAncestor(notifyContent1, notifyContent2);
64122:         if (notifyContent2) {
71112:           // It's very important to first notify the state removal and
71112:           // then the state addition, because due to labels it's
71112:           // possible that we're removing state from some element but
71112:           // then adding it again (say because mHoverContent changed
71112:           // from a control to its label).
80486:           UpdateAncestorState(notifyContent2, commonAncestor, aState, false);
71112:         }
71112:         UpdateAncestorState(notifyContent1, commonAncestor, aState,
71112:                             content1StateSet);
64122:       } else {
64122:         if (notifyContent2) {
80486:           DoStateChange(notifyContent2, aState, false);
71113:         }
71113:         DoStateChange(notifyContent1, aState, content1StateSet);
64122:       }
    1:     }
    1:   }
    1: 
80486:   return true;
29018: }
29018: 
68780: void
29018: nsEventStateManager::ContentRemoved(nsIDocument* aDocument, nsIContent* aContent)
    1: {
95699:   /*
95699:    * Anchor and area elements when focused or hovered might make the UI to show
95699:    * the current link. We want to make sure that the UI gets informed when they
95699:    * are actually removed from the DOM.
95699:    */
95699:   if (aContent->IsHTML() &&
95699:       (aContent->Tag() == nsGkAtoms::a || aContent->Tag() == nsGkAtoms::area) &&
95699:       (aContent->AsElement()->State().HasAtLeastOneOfStates(NS_EVENT_STATE_FOCUS |
95699:                                                             NS_EVENT_STATE_HOVER))) {
95699:     nsGenericHTMLElement* element = static_cast<nsGenericHTMLElement*>(aContent);
95699:     element->LeaveLink(element->GetPresContext());
95699:   }
95699: 
29018:   // inform the focus manager that the content is being removed. If this
29018:   // content is focused, the focus will be removed without firing events.
41409:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm)
29018:     fm->ContentRemoved(aDocument, aContent);
    1: 
    1:   if (mHoverContent &&
    1:       nsContentUtils::ContentIsDescendantOf(mHoverContent, aContent)) {
    1:     // Since hover is hierarchical, set the current hover to the
    1:     // content's parent node.
42951:     SetContentState(aContent->GetParent(), NS_EVENT_STATE_HOVER);
    1:   }
    1: 
    1:   if (mActiveContent &&
    1:       nsContentUtils::ContentIsDescendantOf(mActiveContent, aContent)) {
    1:     // Active is hierarchical, so set the current active to the
    1:     // content's parent node.
42951:     SetContentState(aContent->GetParent(), NS_EVENT_STATE_ACTIVE);
    1:   }
    1: 
79435:   if (sDragOverContent &&
80526:       sDragOverContent->OwnerDoc() == aContent->OwnerDoc() &&
79435:       nsContentUtils::ContentIsDescendantOf(sDragOverContent, aContent)) {
79435:     sDragOverContent = nsnull;
    1:   }
    1: 
    1:   if (mLastMouseOverElement &&
    1:       nsContentUtils::ContentIsDescendantOf(mLastMouseOverElement, aContent)) {
    1:     // See bug 292146 for why we want to null this out
    1:     mLastMouseOverElement = nsnull;
    1:   }
68780: }
68780: 
79445: bool
68780: nsEventStateManager::EventStatusOK(nsGUIEvent* aEvent)
    1: {
68780:   return !(aEvent->message == NS_MOUSE_BUTTON_DOWN &&
68780:       static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton  && 
68780:       !sNormalLMouseEventInProcess);
    1: }
    1: 
    1: //-------------------------------------------
    1: // Access Key Registration
    1: //-------------------------------------------
68780: void
    1: nsEventStateManager::RegisterAccessKey(nsIContent* aContent, PRUint32 aKey)
    1: {
 8407:   if (aContent && mAccessKeys.IndexOf(aContent) == -1)
 8407:     mAccessKeys.AppendObject(aContent);
68780: }
68780: 
68780: void
    1: nsEventStateManager::UnregisterAccessKey(nsIContent* aContent, PRUint32 aKey)
    1: {
 8407:   if (aContent)
 8407:     mAccessKeys.RemoveObject(aContent);
68780: }
68780: 
68780: PRUint32
68780: nsEventStateManager::GetRegisteredAccessKey(nsIContent* aContent)
 5414: {
 5414:   NS_ENSURE_ARG(aContent);
 5414: 
 8407:   if (mAccessKeys.IndexOf(aContent) == -1)
68780:     return 0;
 5414: 
 8407:   nsAutoString accessKey;
 8407:   aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
68780:   return accessKey.First();
 5414: }
 5414: 
    1: void
    1: nsEventStateManager::EnsureDocument(nsPresContext* aPresContext)
    1: {
    1:   if (!mDocument)
    1:     mDocument = aPresContext->Document();
    1: }
    1: 
    1: void
    1: nsEventStateManager::FlushPendingEvents(nsPresContext* aPresContext)
    1: {
    1:   NS_PRECONDITION(nsnull != aPresContext, "nsnull ptr");
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
    1:   if (shell) {
27993:     shell->FlushPendingNotifications(Flush_InterruptibleLayout);
    1:   }
    1: }
    1: 
29018: nsIContent*
29018: nsEventStateManager::GetFocusedContent()
    1: {
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm || !mDocument)
29018:     return nsnull;
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> focusedWindow;
80486:   return nsFocusManager::GetFocusedDescendant(mDocument->GetWindow(), false,
29018:                                               getter_AddRefs(focusedWindow));
    1: }
    1: 
    1: //-------------------------------------------------------
80486: // Return true if the docshell is visible
    1: 
79445: bool
    1: nsEventStateManager::IsShellVisible(nsIDocShell* aShell)
    1: {
    1:   NS_ASSERTION(aShell, "docshell is null");
    1: 
    1:   nsCOMPtr<nsIBaseWindow> basewin = do_QueryInterface(aShell);
    1:   if (!basewin)
80486:     return true;
    1: 
79445:   bool isVisible = true;
    1:   basewin->GetVisibility(&isVisible);
    1: 
    1:   // We should be doing some additional checks here so that
    1:   // we don't tab into hidden tabs of tabbrowser.  -bryner
    1: 
    1:   return isVisible;
    1: }
31218: 
31218: nsresult
31218: nsEventStateManager::DoContentCommandEvent(nsContentCommandEvent* aEvent)
31218: {
31218:   EnsureDocument(mPresContext);
31218:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
38336:   nsCOMPtr<nsPIDOMWindow> window(mDocument->GetWindow());
31218:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
38336: 
38336:   nsCOMPtr<nsPIWindowRoot> root = window->GetTopWindowRoot();
38336:   NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
31218:   const char* cmd;
31218:   switch (aEvent->message) {
31218:     case NS_CONTENT_COMMAND_CUT:
31218:       cmd = "cmd_cut";
31218:       break;
31218:     case NS_CONTENT_COMMAND_COPY:
31218:       cmd = "cmd_copy";
31218:       break;
31218:     case NS_CONTENT_COMMAND_PASTE:
31218:       cmd = "cmd_paste";
31218:       break;
31218:     case NS_CONTENT_COMMAND_DELETE:
31218:       cmd = "cmd_delete";
31218:       break;
31218:     case NS_CONTENT_COMMAND_UNDO:
31218:       cmd = "cmd_undo";
31218:       break;
31218:     case NS_CONTENT_COMMAND_REDO:
31218:       cmd = "cmd_redo";
31218:       break;
36983:     case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE:
36983:       cmd = "cmd_pasteTransferable";
36983:       break;
31218:     default:
31218:       return NS_ERROR_NOT_IMPLEMENTED;
31218:   }
31218:   nsCOMPtr<nsIController> controller;
38336:   nsresult rv = root->GetControllerForCommand(cmd, getter_AddRefs(controller));
31218:   NS_ENSURE_SUCCESS(rv, rv);
31218:   if (!controller) {
31218:     // When GetControllerForCommand succeeded but there is no controller, the
31218:     // command isn't supported.
80486:     aEvent->mIsEnabled = false;
31218:   } else {
79445:     bool canDoIt;
31218:     rv = controller->IsCommandEnabled(cmd, &canDoIt);
31218:     NS_ENSURE_SUCCESS(rv, rv);
31218:     aEvent->mIsEnabled = canDoIt;
31218:     if (canDoIt && !aEvent->mOnlyEnabledCheck) {
36983:       switch (aEvent->message) {
36983:         case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE: {
36983:           nsCOMPtr<nsICommandController> commandController = do_QueryInterface(controller);
36983:           NS_ENSURE_STATE(commandController);
36983: 
36983:           nsCOMPtr<nsICommandParams> params = do_CreateInstance("@mozilla.org/embedcomp/command-params;1", &rv);
36983:           NS_ENSURE_SUCCESS(rv, rv);
36983: 
36983:           rv = params->SetISupportsValue("transferable", aEvent->mTransferable);
36983:           NS_ENSURE_SUCCESS(rv, rv);
36983: 
36983:           rv = commandController->DoCommandWithParams(cmd, params);
36983:           break;
36983:         }
36983:         
36983:         default:
31218:           rv = controller->DoCommand(cmd);
36983:           break;
36983:       }
31218:       NS_ENSURE_SUCCESS(rv, rv);
31218:     }
31218:   }
80486:   aEvent->mSucceeded = true;
31218:   return NS_OK;
31218: }
39248: 
39248: nsresult
39248: nsEventStateManager::DoContentCommandScrollEvent(nsContentCommandEvent* aEvent)
39248: {
39248:   NS_ENSURE_TRUE(mPresContext, NS_ERROR_NOT_AVAILABLE);
39248:   nsIPresShell* ps = mPresContext->GetPresShell();
39248:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_AVAILABLE);
39248:   NS_ENSURE_TRUE(aEvent->mScroll.mAmount != 0, NS_ERROR_INVALID_ARG);
39248: 
39248:   nsIScrollableFrame::ScrollUnit scrollUnit;
39248:   switch (aEvent->mScroll.mUnit) {
39248:     case nsContentCommandEvent::eCmdScrollUnit_Line:
39248:       scrollUnit = nsIScrollableFrame::LINES;
39248:       break;
39248:     case nsContentCommandEvent::eCmdScrollUnit_Page:
39248:       scrollUnit = nsIScrollableFrame::PAGES;
39248:       break;
39248:     case nsContentCommandEvent::eCmdScrollUnit_Whole:
39248:       scrollUnit = nsIScrollableFrame::WHOLE;
39248:       break;
39248:     default:
39248:       return NS_ERROR_INVALID_ARG;
39248:   }
39248: 
80486:   aEvent->mSucceeded = true;
39248: 
39248:   nsIScrollableFrame* sf =
39248:     ps->GetFrameToScrollAsScrollable(nsIPresShell::eEither);
39248:   aEvent->mIsEnabled = sf ? CanScrollOn(sf, aEvent->mScroll.mAmount,
39248:                                         aEvent->mScroll.mIsHorizontal) :
80486:                             false;
39248: 
39248:   if (!aEvent->mIsEnabled || aEvent->mOnlyEnabledCheck) {
39248:     return NS_OK;
39248:   }
39248: 
39248:   nsIntPoint pt(0, 0);
39248:   if (aEvent->mScroll.mIsHorizontal) {
39248:     pt.x = aEvent->mScroll.mAmount;
39248:   } else {
39248:     pt.y = aEvent->mScroll.mAmount;
39248:   }
39248: 
39248:   // The caller may want synchronous scrolling.
39248:   sf->ScrollBy(pt, scrollUnit, nsIScrollableFrame::INSTANT);
39248:   return NS_OK;
39248: }
54151: 
54151: void
69947: nsEventStateManager::DoQueryScrollTargetInfo(nsQueryContentEvent* aEvent,
69947:                                              nsIFrame* aTargetFrame)
69947: {
73896:   // Don't modify the test event which in mInput.
73896:   nsMouseScrollEvent msEvent(
73896:     NS_IS_TRUSTED_EVENT(aEvent->mInput.mMouseScrollEvent),
73896:     aEvent->mInput.mMouseScrollEvent->message,
73896:     aEvent->mInput.mMouseScrollEvent->widget);
73896: 
73896:   msEvent.isShift = aEvent->mInput.mMouseScrollEvent->isShift;
73896:   msEvent.isControl = aEvent->mInput.mMouseScrollEvent->isControl;
73896:   msEvent.isAlt = aEvent->mInput.mMouseScrollEvent->isAlt;
73896:   msEvent.isMeta = aEvent->mInput.mMouseScrollEvent->isMeta;
73896: 
73896:   msEvent.scrollFlags = aEvent->mInput.mMouseScrollEvent->scrollFlags;
73896:   msEvent.delta = ComputeWheelDeltaFor(aEvent->mInput.mMouseScrollEvent);
73896:   msEvent.scrollOverflow = aEvent->mInput.mMouseScrollEvent->scrollOverflow;
73896: 
79445:   bool useSystemSettings = UseSystemScrollSettingFor(&msEvent);
70222: 
69947:   nsIScrollableFrame::ScrollUnit unit;
79445:   bool allowOverrideSystemSettings;
73896:   switch (ComputeWheelActionFor(&msEvent, useSystemSettings)) {
70222:     case MOUSE_SCROLL_N_LINES:
70222:       unit = nsIScrollableFrame::LINES;
73896:       allowOverrideSystemSettings = useSystemSettings;
70222:       break;
70222:     case MOUSE_SCROLL_PAGE:
69947:       unit = nsIScrollableFrame::PAGES;
80486:       allowOverrideSystemSettings = false;
70222:       break;
70222:     default:
70222:       // Don't use high resolution scrolling when the action doesn't scroll
70222:       // contents.
70222:       return;
70222:   }
70222: 
73896:   DoScrollText(aTargetFrame, &msEvent, unit,
70222:                allowOverrideSystemSettings, aEvent);
69947: }
69947: 
69947: void
78622: nsEventStateManager::DoQuerySelectedText(nsQueryContentEvent* aEvent)
78622: {
78622:   if (RemoteQueryContentEvent(aEvent)) {
78622:     return;
78622:   }
78622:   nsContentEventHandler handler(mPresContext);
78622:   handler.OnQuerySelectedText(aEvent);
78622: }
78622: 
78622: void
56644: nsEventStateManager::SetActiveManager(nsEventStateManager* aNewESM,
54151:                                       nsIContent* aContent)
54151: {
54151:   if (sActiveESM && aNewESM != sActiveESM) {
54151:     sActiveESM->SetContentState(nsnull, NS_EVENT_STATE_ACTIVE);
54151:   }
54151:   sActiveESM = aNewESM;
56644:   if (sActiveESM && aContent) {
54151:     sActiveESM->SetContentState(aContent, NS_EVENT_STATE_ACTIVE);
54151:   }
54151: }
55892: 
55892: void
56644: nsEventStateManager::ClearGlobalActiveContent(nsEventStateManager* aClearer)
55892: {
56644:   if (aClearer) {
56644:     aClearer->SetContentState(nsnull, NS_EVENT_STATE_ACTIVE);
79435:     if (sDragOverContent) {
79435:       aClearer->SetContentState(nsnull, NS_EVENT_STATE_DRAGOVER);
79435:     }
56644:   }
56644:   if (sActiveESM && aClearer != sActiveESM) {
55892:     sActiveESM->SetContentState(nsnull, NS_EVENT_STATE_ACTIVE);
55892:   }
55892:   sActiveESM = nsnull;
55892: }
