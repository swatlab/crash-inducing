59799: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
46428:  * ***** BEGIN LICENSE BLOCK *****
46428:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
46428:  *
46428:  * The contents of this file are subject to the Mozilla Public License Version
46428:  * 1.1 (the "License"); you may not use this file except in compliance with
46428:  * the License. You may obtain a copy of the License at
46428:  * http://www.mozilla.org/MPL/
46428:  *
46428:  * Software distributed under the License is distributed on an "AS IS" basis,
46428:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
46428:  * for the specific language governing rights and limitations under the
46428:  * License.
46428:  *
46428:  * The Original Code is Mozilla Android code.
46428:  *
46428:  * The Initial Developer of the Original Code is Mozilla Foundation.
46428:  * Portions created by the Initial Developer are Copyright (C) 2010
46428:  * the Initial Developer. All Rights Reserved.
46428:  *
46428:  * Contributor(s):
46428:  *   Michael Wu <mwu@mozilla.com>
84717:  *   Alex Pakhotin <alexp@mozilla.com>
46428:  *
46428:  * Alternatively, the contents of this file may be used under the terms of
46428:  * either the GNU General Public License Version 2 or later (the "GPL"), or
46428:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
46428:  * in which case the provisions of the GPL or the LGPL are applicable instead
46428:  * of those above. If you wish to allow use of your version of this file only
46428:  * under the terms of either the GPL or the LGPL, and not to allow others to
46428:  * use your version of this file under the terms of the MPL, indicate your
46428:  * decision by deleting the provisions above and replace them with the notice
46428:  * and other provisions required by the GPL or the LGPL. If you do not delete
46428:  * the provisions above, a recipient may use your version of this file under
46428:  * the terms of any one of the MPL, the GPL or the LGPL.
46428:  *
46428:  * ***** END LICENSE BLOCK ***** */
46428: 
46428: package org.mozilla.gecko;
46428: 
46428: import java.io.*;
46428: import java.util.*;
46428: import java.util.concurrent.*;
46428: import java.util.concurrent.atomic.*;
46428: 
83777: import org.mozilla.gecko.gfx.InputConnectionHandler;
83777: 
46428: import android.os.*;
46428: import android.app.*;
46428: import android.text.*;
85502: import android.text.style.*;
46428: import android.view.*;
46428: import android.view.inputmethod.*;
46428: import android.content.*;
57363: import android.R;
83777: import android.text.method.TextKeyListener;
83777: import android.text.method.KeyListener;
46428: import android.util.*;
46428: 
46428: public class GeckoInputConnection
46428:     extends BaseInputConnection
83777:     implements TextWatcher, InputConnectionHandler
46428: {
84717:     private static final boolean DEBUG = false;
84717:     protected static final String LOGTAG = "GeckoInputConnection";
83868: 
84717:     public static GeckoInputConnection create(View targetView) {
84717:         if (DEBUG)
84717:             return new DebugGeckoInputConnection(targetView);
84717:         else
84717:             return new GeckoInputConnection(targetView);
78741:     }
78741: 
84717:     protected GeckoInputConnection(View targetView) {
46428:         super(targetView, true);
46428:         mQueryResult = new SynchronousQueue<String>();
83777: 
83777:         mEditableFactory = Editable.Factory.getInstance();
83777:         initEditable("");
83777:         mIMEState = IME_STATE_DISABLED;
83777:         mIMETypeHint = "";
83777:         mIMEActionHint = "";
48868:     }
48868: 
48868:     @Override
48868:     public boolean beginBatchEdit() {
78741:         mBatchMode = true;
48868:         return true;
48868:     }
48868: 
48868:     @Override
84717:     public boolean endBatchEdit() {
84717:         mBatchMode = false;
84717:         return true;
84717:     }
84717: 
84717:     @Override
48868:     public boolean commitCompletion(CompletionInfo text) {
48868:         return commitText(text.getText(), 1);
48868:     }
48868: 
48868:     @Override
48868:     public boolean commitText(CharSequence text, int newCursorPosition) {
84717:         replaceText(text, newCursorPosition, false);
85502: 
85502:         if (mComposing) {
85502:             if (DEBUG) Log.d(LOGTAG, ". . . commitText: endComposition");
85502:             endComposition();
85502:         }
48868:         return true;
48868:     }
48868: 
48868:     @Override
84717:     public boolean finishComposingText() {
85502:         if (mComposing) {
85502:             if (DEBUG) Log.d(LOGTAG, ". . . finishComposingText: endComposition");
85502:             endComposition();
85502:         }
48868: 
84717:         final Editable content = getEditable();
84717:         if (content != null) {
84717:             beginBatchEdit();
84717:             removeComposingSpans(content);
84717:             endBatchEdit();
78741:         }
48868:         return true;
48868:     }
48868: 
48868:     @Override
46428:     public Editable getEditable() {
84717:         return mEditable;
46428:     }
46428: 
46428:     @Override
57363:     public boolean performContextMenuAction(int id) {
84717:         final Editable content = getEditable();
84717:         if (content == null)
84717:             return false;
57363: 
84717:         String text = content.toString();
84717: 
84717:         int a = Selection.getSelectionStart(content);
84717:         int b = Selection.getSelectionEnd(content);
84717:         if (a < 0) a = 0;
84717:         if (b < 0) b = 0;
84717:         if (a > b) {
84717:             int tmp = a;
84717:             a = b;
84717:             b = tmp;
57363:         }
57363: 
57363:         switch (id) {
57363:             case R.id.selectAll:
58561:                 setSelection(0, text.length());
57363:                 break;
57363:             case R.id.cut:
57363:                 // Fill the clipboard
57363:                 GeckoAppShell.setClipboardText(text);
84717:                 // If selection is empty, we'll select everything
84717:                 if (a >= b)
57363:                     GeckoAppShell.sendEventToGecko(
57363:                         new GeckoEvent(GeckoEvent.IME_SET_SELECTION, 0, text.length()));
57363:                 GeckoAppShell.sendEventToGecko(
57363:                     new GeckoEvent(GeckoEvent.IME_DELETE_TEXT, 0, 0));
57363:                 break;
57363:             case R.id.paste:
57363:                 commitText(GeckoAppShell.getClipboardText(), 1);
57363:                 break;
57363:             case R.id.copy:
57363:                 // If there is no selection set, we must be doing "Copy All",
84717:                 // otherwise get the selection
84717:                 if (a < b)
84717:                     text = text.substring(a, b);
84717:                 GeckoAppShell.setClipboardText(text.substring(a, b));
57363:                 break;
57363:         }
57363:         return true;
57363:     }
57363: 
57363:     @Override
48868:     public ExtractedText getExtractedText(ExtractedTextRequest req, int flags) {
48868:         if (req == null)
48868:             return null;
48868: 
84717:         final Editable content = getEditable();
84717:         if (content == null)
79894:             return null;
79894: 
85368:         if ((flags & GET_EXTRACTED_TEXT_MONITOR) != 0)
85368:             mUpdateRequest = req;
85368: 
48868:         ExtractedText extract = new ExtractedText();
48868:         extract.flags = 0;
48868:         extract.partialStartOffset = -1;
48868:         extract.partialEndOffset = -1;
48868: 
84717:         int a = Selection.getSelectionStart(content);
84717:         int b = Selection.getSelectionEnd(content);
84717:         if (a > b) {
84717:             int tmp = a;
84717:             a = b;
84717:             b = tmp;
46428:         }
48868: 
84717:         extract.selectionStart = a;
84717:         extract.selectionEnd = b;
48868: 
84717:         extract.startOffset = 0;
85546: 
85546:         try {
84717:             extract.text = content.toString();
85546:         } catch (IndexOutOfBoundsException iob) {
85546:             Log.d(LOGTAG,
85546:                   "IndexOutOfBoundsException thrown from getExtractedText(). start: " +
85546:                   Selection.getSelectionStart(content) +
85546:                   " end: " + Selection.getSelectionEnd(content));
85546:             return null;
85546:         }
84717:         return extract;
46428:     }
48868: 
46428:     @Override
85368:     public boolean setSelection(int start, int end) {
85368:         GeckoAppShell.sendEventToGecko(
85368:             new GeckoEvent(GeckoEvent.IME_SET_SELECTION, start, end - start));
85368: 
85368:         return super.setSelection(start, end);
85368:     }
85368: 
85368:     @Override
46428:     public boolean setComposingText(CharSequence text, int newCursorPosition) {
84717:         replaceText(text, newCursorPosition, true);
83649:         return true;
83649:     }
83649: 
84717:     private void replaceText(CharSequence text, int newCursorPosition, boolean composing) {
84717:         if (DEBUG) Log.d(LOGTAG, String.format("IME: replaceText(\"%s\", %d, %s)", text, newCursorPosition, composing?"true":"false"));
84717: 
84717:         if (text == null)
84717:             text = "";
84717: 
84717:         final Editable content = getEditable();
84717:         if (content == null) {
84717:             return;
48868:         }
48868:         
84717:         beginBatchEdit();
48868:         
84717:         // delete composing text set previously.
84717:         int a = getComposingSpanStart(content);
84717:         int b = getComposingSpanEnd(content);
48868: 
84717:         if (DEBUG) Log.d(LOGTAG, "Composing span: " + a + " to " + b);
48868:         
84717:         if (b < a) {
84717:             int tmp = a;
84717:             a = b;
84717:             b = tmp;
48868:         }
48868: 
84717:         if (a != -1 && b != -1) {
84717:             removeComposingSpans(content);
48868:         } else {
84717:             a = Selection.getSelectionStart(content);
84717:             b = Selection.getSelectionEnd(content);
84717:             if (a < 0) a = 0;
84717:             if (b < 0) b = 0;
84717:             if (b < a) {
84717:                 int tmp = a;
84717:                 a = b;
84717:                 b = tmp;
84717:             }
48868:         }
48868: 
84717:         if (composing) {
84717:             Spannable sp = null;
84717:             if (!(text instanceof Spannable)) {
84717:                 sp = new SpannableStringBuilder(text);
84717:                 text = sp;
85502:                 sp.setSpan(COMPOSING_SPAN, 0, sp.length(),
85502:                         Spanned.SPAN_EXCLUSIVE_EXCLUSIVE | Spanned.SPAN_COMPOSING);
84717:             } else {
84717:                 sp = (Spannable)text;
84717:             }
84717:             setComposingSpans(sp);
78741:         }
78741:         
84717:         if (DEBUG) Log.d(LOGTAG, "Replacing from " + a + " to " + b + " with \""
84717:                 + text + "\", composing=" + composing
84717:                 + ", type=" + text.getClass().getCanonicalName());
78741:         
84717:         if (DEBUG) {
84717:             LogPrinter lp = new LogPrinter(Log.VERBOSE, LOGTAG);
84717:             lp.println("Current text:");
84717:             TextUtils.dumpSpans(content, lp, "  ");
84717:             lp.println("Composing text:");
84717:             TextUtils.dumpSpans(text, lp, "  ");
78741:         }
78741:         
84717:         // Position the cursor appropriately, so that after replacing the
84717:         // desired range of text it will be located in the correct spot.
84717:         // This allows us to deal with filters performing edits on the text
84717:         // we are providing here.
84717:         if (newCursorPosition > 0) {
84717:             newCursorPosition += b - 1;
84717:         } else {
84717:             newCursorPosition += a;
84717:         }
84717:         if (newCursorPosition < 0) newCursorPosition = 0;
84717:         if (newCursorPosition > content.length())
84717:             newCursorPosition = content.length();
84717:         Selection.setSelection(content, newCursorPosition);
78741: 
84717:         content.replace(a, b, text);
84717:         
84717:         if (DEBUG) {
84717:             LogPrinter lp = new LogPrinter(Log.VERBOSE, LOGTAG);
84717:             lp.println("Final text:");
84717:             TextUtils.dumpSpans(content, lp, "  ");
78741:         }
78741:         
84717:         endBatchEdit();
46428:     }
46428: 
85502:     @Override
85502:     public boolean setComposingRegion(int start, int end) {
85502:         if (mComposing) {
85502:             if (DEBUG) Log.d(LOGTAG, ". . . setComposingRegion: endComposition");
85502:             endComposition();
85502:         }
85502: 
85502:         return super.setComposingRegion(start, end);
85502:     }
85502: 
84717:     public String getComposingText() {
84717:         final Editable content = getEditable();
84717:         if (content == null) {
84717:             return null;
84717:         }
84717:         int a = getComposingSpanStart(content);
84717:         int b = getComposingSpanEnd(content);
48868: 
84717:         if (a < 0 || b < 0)
84717:             return null;
48868:         
84717:         if (b < a) {
84717:             int tmp = a;
84717:             a = b;
84717:             b = tmp;
84717:         }
48868: 
84717:         return TextUtils.substring(content, a, b);
46428:     }
46428:     
48868:     public boolean onKeyDel() {
48868:         // Some IMEs don't update us on deletions
48868:         // In that case we are not updated when a composition
48868:         // is destroyed, and Bad Things happen
48868: 
48868:         if (!mComposing)
48868:             return false;
48868: 
84717:         String text = getComposingText();
84717: 
84717:         if (text != null && text.length() > 1) {
84717:             text = text.substring(0, text.length() - 1);
84717:             replaceText(text, 1, false);
48868:             return false;
46428:         }
46428: 
48868:         commitText(null, 1);
48868:         return true;
48868:     }
46428: 
48868:     public void notifyTextChange(InputMethodManager imm, String text,
48868:                                  int start, int oldEnd, int newEnd) {
85368:         if (!mBatchMode) {
84717:             if (!text.contentEquals(mEditable)) {
84717:                 if (DEBUG) Log.d(LOGTAG, String.format(". . . notifyTextChange: current mEditable=\"%s\"",
84717:                                                        mEditable.toString()));
84717:                 setEditable(text);
78741:             }
48868:         }
48868: 
85368:         if (mUpdateRequest == null)
85368:             return;
85368: 
85368:         View v = GeckoApp.mAppContext.getLayerController().getView();
85368: 
85368:         if (imm == null) {
85368:             imm = (InputMethodManager)v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
85368:             if (imm == null)
85368:                 return;
85368:         }
85368: 
85368:         mUpdateExtract.flags = 0;
85368: 
85368:         // We update from (0, oldEnd) to (0, newEnd) because some Android IMEs
85368:         // assume that updates start at zero, according to jchen.
85368:         mUpdateExtract.partialStartOffset = 0;
85368:         mUpdateExtract.partialEndOffset = oldEnd;
85368: 
85368:         // Faster to not query for selection
85368:         mUpdateExtract.selectionStart = newEnd;
85368:         mUpdateExtract.selectionEnd = newEnd;
85368: 
85368:         mUpdateExtract.text = text.substring(0, newEnd);
85368:         mUpdateExtract.startOffset = 0;
85368: 
85368:         imm.updateExtractedText(v, mUpdateRequest.token, mUpdateExtract);
85368:     }
85368: 
48868:     public void notifySelectionChange(InputMethodManager imm,
48868:                                       int start, int end) {
85368:         if (!mBatchMode) {
84717:             final Editable content = getEditable();
84717:             int a = Selection.getSelectionStart(content);
84717:             int b = Selection.getSelectionEnd(content);
84717:             if (start != a || end != b) {
84717:                 if (DEBUG) Log.d(LOGTAG, String.format(". . . notifySelectionChange: current editable selection: [%d, %d]", a, b));
85368:                 super.setSelection(start, end);
85502: 
85502:                 // Check if the selection is inside composing span
85502:                 int ca = getComposingSpanStart(content);
85502:                 int cb = getComposingSpanEnd(content);
85502:                 if (cb < ca) {
85502:                     int tmp = ca;
85502:                     ca = cb;
85502:                     cb = tmp;
85502:                 }
85502:                 if (start < ca || start > cb || end < ca || end > cb) {
85502:                     if (DEBUG) Log.d(LOGTAG, ". . . notifySelectionChange: removeComposingSpans");
85502:                     removeComposingSpans(content);
85502:                 }
85368:             }
85368:         }
85368: 
85368:         if (imm != null && imm.isFullscreenMode()) {
85368:             View v = GeckoApp.mAppContext.getLayerController().getView();
85368:             imm.updateSelection(v, start, end, -1, -1);
78741:         }
48868:     }
48868: 
51142:     public void reset() {
51142:         mComposing = false;
78741:         mBatchMode = false;
85368:         mUpdateRequest = null;
51142:     }
51142: 
58020:     // TextWatcher
58020:     public void onTextChanged(CharSequence s, int start, int before, int count)
58020:     {
85502:         if (!mComposing) {
85502:             if (DEBUG) Log.d(LOGTAG, ". . . onTextChanged: IME_COMPOSITION_BEGIN");
85502:             GeckoAppShell.sendEventToGecko(
85502:                 new GeckoEvent(GeckoEvent.IME_COMPOSITION_BEGIN, 0, 0));
85502:             mComposing = true;
85502: 
85502:             if (DEBUG) Log.d(LOGTAG, ". . . onTextChanged: IME_SET_SELECTION, start=" + start + ", len=" + before);
58020:             GeckoAppShell.sendEventToGecko(
58020:                 new GeckoEvent(GeckoEvent.IME_SET_SELECTION, start, before));
85502:         }
58020: 
58196:         if (count == 0) {
85502:             if (DEBUG) Log.d(LOGTAG, ". . . onTextChanged: IME_DELETE_TEXT");
58020:             GeckoAppShell.sendEventToGecko(
58020:                 new GeckoEvent(GeckoEvent.IME_DELETE_TEXT, 0, 0));
58196:         } else {
85502:             sendTextToGecko(s.subSequence(start, start + count), start + count);
85502:         }
85178: 
85502:         if (DEBUG) Log.d(LOGTAG, ". . . onTextChanged: IME_SET_SELECTION, start=" + (start + count) + ", 0");
85178:         GeckoAppShell.sendEventToGecko(
62994:             new GeckoEvent(GeckoEvent.IME_SET_SELECTION, start + count, 0));
62994: 
63330:         // Block this thread until all pending events are processed
63330:         GeckoAppShell.geckoEventSync();
58020:     }
58020: 
85502:     private void endComposition() {
85502:         if (DEBUG) Log.d(LOGTAG, "IME: endComposition: IME_COMPOSITION_END");
85502:         GeckoAppShell.sendEventToGecko(
85502:             new GeckoEvent(GeckoEvent.IME_COMPOSITION_END, 0, 0));
85502:         mComposing = false;
85502:     }
85502: 
85502:     private void sendTextToGecko(CharSequence text, int caretPos) {
85502:         if (DEBUG) Log.d(LOGTAG, "IME: sendTextToGecko(\"" + text + "\")");
85502: 
85502:         // Handle composition text styles
85502:         if (text != null && text instanceof Spanned) {
85502:             Spanned span = (Spanned) text;
85502:             int spanStart = 0, spanEnd = 0;
85502:             boolean pastSelStart = false, pastSelEnd = false;
85502: 
85502:             do {
85502:                 int rangeType = GeckoEvent.IME_RANGE_CONVERTEDTEXT;
85502:                 int rangeStyles = 0, rangeForeColor = 0, rangeBackColor = 0;
85502: 
85502:                 // Find next offset where there is a style transition
85502:                 spanEnd = span.nextSpanTransition(spanStart + 1, text.length(),
85502:                     CharacterStyle.class);
85502: 
85502:                 // Empty range, continue
85502:                 if (spanEnd <= spanStart)
85502:                     continue;
85502: 
85502:                 // Get and iterate through list of span objects within range
85502:                 CharacterStyle styles[] = span.getSpans(
85502:                     spanStart, spanEnd, CharacterStyle.class);
85502: 
85502:                 for (CharacterStyle style : styles) {
85502:                     if (style instanceof UnderlineSpan) {
85502:                         // Text should be underlined
85502:                         rangeStyles |= GeckoEvent.IME_RANGE_UNDERLINE;
85502: 
85502:                     } else if (style instanceof ForegroundColorSpan) {
85502:                         // Text should be of a different foreground color
85502:                         rangeStyles |= GeckoEvent.IME_RANGE_FORECOLOR;
85502:                         rangeForeColor =
85502:                             ((ForegroundColorSpan)style).getForegroundColor();
85502: 
85502:                     } else if (style instanceof BackgroundColorSpan) {
85502:                         // Text should be of a different background color
85502:                         rangeStyles |= GeckoEvent.IME_RANGE_BACKCOLOR;
85502:                         rangeBackColor =
85502:                             ((BackgroundColorSpan)style).getBackgroundColor();
85502:                     }
85502:                 }
85502: 
85502:                 // Add range to array, the actual styles are
85502:                 //  applied when IME_SET_TEXT is sent
85502:                 if (DEBUG) Log.d(LOGTAG, String.format(". . . sendTextToGecko: IME_ADD_RANGE, %d, %d, %d, %d, %d, %d",
85502:                                                        spanStart, spanEnd - spanStart, rangeType, rangeStyles, rangeForeColor, rangeBackColor));
85502:                 GeckoAppShell.sendEventToGecko(
85502:                     new GeckoEvent(spanStart, spanEnd - spanStart,
85502:                                    rangeType, rangeStyles,
85502:                                    rangeForeColor, rangeBackColor));
85502: 
85502:                 spanStart = spanEnd;
85502:             } while (spanStart < text.length());
85502:         } else {
85502:             if (DEBUG) Log.d(LOGTAG, ". . . sendTextToGecko: IME_ADD_RANGE, 0, " + text.length() +
85502:                                      ", IME_RANGE_RAWINPUT, IME_RANGE_UNDERLINE)");
85502:             GeckoAppShell.sendEventToGecko(
85502:                 new GeckoEvent(0, text == null ? 0 : text.length(),
85502:                                GeckoEvent.IME_RANGE_RAWINPUT,
85502:                                GeckoEvent.IME_RANGE_UNDERLINE, 0, 0));
85502:         }
85502: 
85502:         // Change composition (treating selection end as where the caret is)
85502:         if (DEBUG) Log.d(LOGTAG, ". . . sendTextToGecko: IME_SET_TEXT, IME_RANGE_CARETPOSITION, \"" + text + "\")");
85502:         GeckoAppShell.sendEventToGecko(
85502:             new GeckoEvent(caretPos, 0,
85502:                            GeckoEvent.IME_RANGE_CARETPOSITION, 0, 0, 0,
85502:                            text.toString()));
85502:     }
85502: 
58020:     public void afterTextChanged(Editable s)
58020:     {
58020:     }
58020: 
58020:     public void beforeTextChanged(CharSequence s, int start, int count, int after)
58020:     {
58020:     }
58020: 
83777:     public InputConnection onCreateInputConnection(EditorInfo outAttrs)
83777:     {
83777:         outAttrs.inputType = InputType.TYPE_CLASS_TEXT;
83777:         outAttrs.imeOptions = EditorInfo.IME_ACTION_NONE;
83777:         outAttrs.actionLabel = null;
83777:         mKeyListener = TextKeyListener.getInstance();
83777: 
83777:         if (mIMEState == IME_STATE_PASSWORD)
83777:             outAttrs.inputType |= InputType.TYPE_TEXT_VARIATION_PASSWORD;
83777:         else if (mIMETypeHint.equalsIgnoreCase("url"))
83777:             outAttrs.inputType |= InputType.TYPE_TEXT_VARIATION_URI;
83777:         else if (mIMETypeHint.equalsIgnoreCase("email"))
83777:             outAttrs.inputType |= InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS;
83777:         else if (mIMETypeHint.equalsIgnoreCase("search"))
83777:             outAttrs.imeOptions = EditorInfo.IME_ACTION_SEARCH;
83777:         else if (mIMETypeHint.equalsIgnoreCase("tel"))
83777:             outAttrs.inputType = InputType.TYPE_CLASS_PHONE;
83777:         else if (mIMETypeHint.equalsIgnoreCase("number") ||
83777:                  mIMETypeHint.equalsIgnoreCase("range"))
83777:             outAttrs.inputType = InputType.TYPE_CLASS_NUMBER;
83777:         else if (mIMETypeHint.equalsIgnoreCase("datetime") ||
83777:                  mIMETypeHint.equalsIgnoreCase("datetime-local"))
83777:             outAttrs.inputType = InputType.TYPE_CLASS_DATETIME |
83777:                                  InputType.TYPE_DATETIME_VARIATION_NORMAL;
83777:         else if (mIMETypeHint.equalsIgnoreCase("date"))
83777:             outAttrs.inputType = InputType.TYPE_CLASS_DATETIME |
83777:                                  InputType.TYPE_DATETIME_VARIATION_DATE;
83777:         else if (mIMETypeHint.equalsIgnoreCase("time"))
83777:             outAttrs.inputType = InputType.TYPE_CLASS_DATETIME |
83777:                                  InputType.TYPE_DATETIME_VARIATION_TIME;
83777: 
83777:         if (mIMEActionHint.equalsIgnoreCase("go"))
83777:             outAttrs.imeOptions = EditorInfo.IME_ACTION_GO;
83777:         else if (mIMEActionHint.equalsIgnoreCase("done"))
83777:             outAttrs.imeOptions = EditorInfo.IME_ACTION_DONE;
83777:         else if (mIMEActionHint.equalsIgnoreCase("next"))
83777:             outAttrs.imeOptions = EditorInfo.IME_ACTION_NEXT;
83777:         else if (mIMEActionHint.equalsIgnoreCase("search"))
83777:             outAttrs.imeOptions = EditorInfo.IME_ACTION_SEARCH;
83777:         else if (mIMEActionHint.equalsIgnoreCase("send"))
83777:             outAttrs.imeOptions = EditorInfo.IME_ACTION_SEND;
83777:         else if (mIMEActionHint != null && mIMEActionHint.length() != 0)
83777:             outAttrs.actionLabel = mIMEActionHint;
83777: 
83777:         if (mIMELandscapeFS == false)
83777:             outAttrs.imeOptions |= EditorInfo.IME_FLAG_NO_EXTRACT_UI;
83777: 
83777:         reset();
83777:         return this;
83777:     }
83777: 
83777:     public boolean onKeyPreIme(int keyCode, KeyEvent event) {
83777:         switch (event.getAction()) {
83777:             case KeyEvent.ACTION_DOWN:
83777:                 return processKeyDown(keyCode, event, true);
83777:             case KeyEvent.ACTION_UP:
83777:                 return processKeyUp(keyCode, event, true);
83777:             case KeyEvent.ACTION_MULTIPLE:
83777:                 return onKeyMultiple(keyCode, event.getRepeatCount(), event);
83777:         }
83777:         return false;
83777:     }
83777: 
83777:     public boolean onKeyDown(int keyCode, KeyEvent event) {
83777:         return processKeyDown(keyCode, event, false);
83777:     }
83777: 
83777:     private boolean processKeyDown(int keyCode, KeyEvent event, boolean isPreIme) {
84717:         if (DEBUG) Log.d(LOGTAG, "IME: processKeyDown(keyCode=" + keyCode + ", event=" + event + ", " + isPreIme + ")");
84717: 
83777:         switch (keyCode) {
83777:             case KeyEvent.KEYCODE_MENU:
83777:             case KeyEvent.KEYCODE_BACK:
83777:             case KeyEvent.KEYCODE_VOLUME_UP:
83777:             case KeyEvent.KEYCODE_VOLUME_DOWN:
83777:             case KeyEvent.KEYCODE_SEARCH:
83777:                 return false;
83777:             case KeyEvent.KEYCODE_DEL:
83777:                 // See comments in GeckoInputConnection.onKeyDel
83777:                 if (onKeyDel()) {
83777:                     return true;
83777:                 }
83777:                 break;
83777:             case KeyEvent.KEYCODE_ENTER:
83777:                 if ((event.getFlags() & KeyEvent.FLAG_EDITOR_ACTION) != 0 &&
83777:                     mIMEActionHint.equalsIgnoreCase("next"))
83777:                     event = new KeyEvent(event.getAction(), KeyEvent.KEYCODE_TAB);
83777:                 break;
83777:             default:
83777:                 break;
83777:         }
83777: 
83777:         if (isPreIme && mIMEState != IME_STATE_DISABLED &&
83839:             (event.getMetaState() & KeyEvent.META_ALT_ON) != 0)
83777:             // Let active IME process pre-IME key events
83777:             return false;
83777: 
83777:         View v = GeckoApp.mAppContext.getLayerController().getView();
83777: 
83777:         // KeyListener returns true if it handled the event for us.
83777:         if (mIMEState == IME_STATE_DISABLED ||
83777:                 keyCode == KeyEvent.KEYCODE_ENTER ||
83777:                 keyCode == KeyEvent.KEYCODE_DEL ||
84027:                 keyCode == KeyEvent.KEYCODE_TAB ||
83777:                 (event.getFlags() & KeyEvent.FLAG_SOFT_KEYBOARD) != 0 ||
85368:                 !mKeyListener.onKeyDown(v, mEditable, keyCode, event)) {
85368:             // Make sure selection in Gecko is up-to-date
85368:             final Editable content = getEditable();
85368:             int a = Selection.getSelectionStart(content);
85368:             int b = Selection.getSelectionEnd(content);
85368:             GeckoAppShell.sendEventToGecko(
85368:                 new GeckoEvent(GeckoEvent.IME_SET_SELECTION, a, b - a));
85368: 
83777:             GeckoAppShell.sendEventToGecko(new GeckoEvent(event));
85368:         }
83777:         return true;
83777:     }
83777: 
83777:     public boolean onKeyUp(int keyCode, KeyEvent event) {
83777:         return processKeyUp(keyCode, event, false);
83777:     }
83777: 
83777:     private boolean processKeyUp(int keyCode, KeyEvent event, boolean isPreIme) {
84717:         if (DEBUG) Log.d(LOGTAG, "IME: processKeyUp(keyCode=" + keyCode + ", event=" + event + ", " + isPreIme + ")");
84717: 
83777:         switch (keyCode) {
83777:             case KeyEvent.KEYCODE_BACK:
83777:             case KeyEvent.KEYCODE_SEARCH:
83777:             case KeyEvent.KEYCODE_MENU:
83777:                 return false;
83777:             default:
83777:                 break;
83777:         }
83777: 
83777:         if (isPreIme && mIMEState != IME_STATE_DISABLED &&
83839:             (event.getMetaState() & KeyEvent.META_ALT_ON) != 0)
83777:             // Let active IME process pre-IME key events
83777:             return false;
83839: 
83777:         View v = GeckoApp.mAppContext.getLayerController().getView();
83777: 
83777:         if (mIMEState == IME_STATE_DISABLED ||
83777:             keyCode == KeyEvent.KEYCODE_ENTER ||
83777:             keyCode == KeyEvent.KEYCODE_DEL ||
83777:             (event.getFlags() & KeyEvent.FLAG_SOFT_KEYBOARD) != 0 ||
83777:             !mKeyListener.onKeyUp(v, mEditable, keyCode, event))
83777:             GeckoAppShell.sendEventToGecko(new GeckoEvent(event));
83777:         return true;
83777:     }
83777: 
83777:     public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) {
83777:         GeckoAppShell.sendEventToGecko(new GeckoEvent(event));
83777:         return true;
83777:     }
83777: 
83777:     public boolean onKeyLongPress(int keyCode, KeyEvent event) {
83777:         View v = GeckoApp.mAppContext.getLayerController().getView();
83777:         switch (keyCode) {
83777:             case KeyEvent.KEYCODE_MENU:
83777:                 InputMethodManager imm = (InputMethodManager)
83777:                     v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
83777:                 imm.toggleSoftInputFromWindow(v.getWindowToken(),
83777:                                               imm.SHOW_FORCED, 0);
83777:                 return true;
83777:             default:
83777:                 break;
83777:         }
83777:         return false;
83777:     }
83777: 
84032:     public boolean isIMEEnabled() {
84032:         // make sure this picks up PASSWORD and PLUGIN states as well
84032:         return mIMEState != IME_STATE_DISABLED;
84032:     }
83777: 
83777:     public void notifyIME(int type, int state) {
83777:         View v = GeckoApp.mAppContext.getLayerController().getView();
83777: 
83777:         if (v == null)
83777:             return;
83777: 
83777:         switch (type) {
83777:         case NOTIFY_IME_RESETINPUTSTATE:
85368:             if (DEBUG) Log.d(LOGTAG, ". . . notifyIME: reset");
83777: 
83777:             // Composition event is already fired from widget.
83777:             // So reset IME flags.
83777:             reset();
83777: 
83777:             // Don't use IMEStateUpdater for reset.
83777:             // Because IME may not work showSoftInput()
83777:             // after calling restartInput() immediately.
83777:             // So we have to call showSoftInput() delay.
83777:             InputMethodManager imm = (InputMethodManager) v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
85208:             if (imm == null) {
83777:                 // no way to reset IME status directly
83777:                 IMEStateUpdater.resetIME();
83777:             } else {
83777:                 imm.restartInput(v);
83777:             }
83777: 
83777:             // keep current enabled state
83777:             IMEStateUpdater.enableIME();
83777:             break;
83777: 
83777:         case NOTIFY_IME_CANCELCOMPOSITION:
85368:             if (DEBUG) Log.d(LOGTAG, ". . . notifyIME: cancel");
83777:             IMEStateUpdater.resetIME();
83777:             break;
83777: 
83777:         case NOTIFY_IME_FOCUSCHANGE:
85368:             if (DEBUG) Log.d(LOGTAG, ". . . notifyIME: focus");
83777:             IMEStateUpdater.resetIME();
83777:             break;
83777:         }
83777:     }
83777: 
83777:     public void notifyIMEEnabled(int state, String typeHint,
83777:                                         String actionHint, boolean landscapeFS)
83777:     {
83777:         View v = GeckoApp.mAppContext.getLayerController().getView();
83777: 
83777:         if (v == null)
83777:             return;
83777: 
83777:         /* When IME is 'disabled', IME processing is disabled.
83777:            In addition, the IME UI is hidden */
83777:         mIMEState = state;
83777:         mIMETypeHint = typeHint;
83777:         mIMEActionHint = actionHint;
83777:         mIMELandscapeFS = landscapeFS;
83777:         IMEStateUpdater.enableIME();
83777:     }
83777: 
83777: 
83777:     public void notifyIMEChange(String text, int start, int end, int newEnd) {
83777:         View v = GeckoApp.mAppContext.getLayerController().getView();
83777: 
83777:         if (v == null)
83777:             return;
83777: 
83777:         InputMethodManager imm = (InputMethodManager) v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
83777:         if (imm == null)
83777:             return;
83777: 
83777:         if (newEnd < 0)
83777:             notifySelectionChange(imm, start, end);
83777:         else
83777:             notifyTextChange(imm, text, start, end, newEnd);
83777:     }
83777: 
83777:     public void returnIMEQueryResult(String result, int selectionStart, int selectionLength) {
83777:         mSelectionStart = selectionStart;
83777:         mSelectionLength = selectionLength;
83777:         try {
83777:             mQueryResult.put(result);
83777:         } catch (InterruptedException e) {}
83777:     }
83777: 
84463:     static private final Timer mIMETimer = new Timer("GeckoInputConnection Timer");
83777: 
83777:     static private final int NOTIFY_IME_RESETINPUTSTATE = 0;
83777:     static private final int NOTIFY_IME_SETOPENSTATE = 1;
83777:     static private final int NOTIFY_IME_CANCELCOMPOSITION = 2;
83777:     static private final int NOTIFY_IME_FOCUSCHANGE = 3;
83777: 
83777: 
83777:     /* Delay updating IME states (see bug 573800) */
83777:     private static final class IMEStateUpdater extends TimerTask
83777:     {
83777:         static private IMEStateUpdater instance;
83777:         private boolean mEnable, mReset;
83777: 
83777:         static private IMEStateUpdater getInstance() {
83777:             if (instance == null) {
83777:                 instance = new IMEStateUpdater();
83777:                 mIMETimer.schedule(instance, 200);
83777:             }
83777:             return instance;
83777:         }
83777: 
83777:         static public synchronized void enableIME() {
83777:             getInstance().mEnable = true;
83777:         }
83777: 
83777:         static public synchronized void resetIME() {
83777:             getInstance().mReset = true;
83777:         }
83777: 
83777:         public void run() {
84717:             if (DEBUG) Log.d(LOGTAG, "IME: run()");
83777:             synchronized(IMEStateUpdater.class) {
83777:                 instance = null;
83777:             }
83777: 
83777:             View v = GeckoApp.mAppContext.getLayerController().getView();
84717:             if (DEBUG) Log.d(LOGTAG, "IME: v="+v);
83777: 
83777:             InputMethodManager imm = (InputMethodManager) v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
83777:             if (imm == null)
83777:                 return;
83777: 
83777:             if (mReset)
83777:                 imm.restartInput(v);
83777: 
83777:             if (!mEnable)
83777:                 return;
83777: 
83777:             if (mIMEState != IME_STATE_DISABLED &&
83777:                 mIMEState != IME_STATE_PLUGIN)
83777:                 imm.showSoftInput(v, 0);
83777:             else
83777:                 imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
83777:         }
83777:     }
83777: 
83777:     public void setEditable(String contents)
83777:     {
83777:         mEditable.removeSpan(this);
83777:         mEditable.replace(0, mEditable.length(), contents);
83777:         mEditable.setSpan(this, 0, contents.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);
83777:         Selection.setSelection(mEditable, contents.length());
83777:     }
83777: 
83777:     public void initEditable(String contents)
83777:     {
83777:         mEditable = mEditableFactory.newEditable(contents);
83777:         mEditable.setSpan(this, 0, contents.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);
83777:         Selection.setSelection(mEditable, contents.length());
83777:     }
83777: 
48868:     // Is a composition active?
48868:     boolean mComposing;
48868: 
83777:     // IME stuff
83777:     public static final int IME_STATE_DISABLED = 0;
83777:     public static final int IME_STATE_ENABLED = 1;
83777:     public static final int IME_STATE_PASSWORD = 2;
83777:     public static final int IME_STATE_PLUGIN = 3;
83777: 
85502:     final CharacterStyle COMPOSING_SPAN = new UnderlineSpan();
85502: 
83777:     KeyListener mKeyListener;
83777:     Editable mEditable;
83777:     Editable.Factory mEditableFactory;
83777:     static int mIMEState;
83777:     static String mIMETypeHint;
83777:     static String mIMEActionHint;
83777:     static boolean mIMELandscapeFS;
83777: 
83647:     private boolean mBatchMode;
48868: 
85368:     ExtractedTextRequest mUpdateRequest;
85368:     final ExtractedText mUpdateExtract = new ExtractedText();
85368: 
48868:     int mSelectionStart, mSelectionLength;
46428:     SynchronousQueue<String> mQueryResult;
46428: }
48868: 
84717: class DebugGeckoInputConnection
84717:     extends GeckoInputConnection
84717: {
84717:     public DebugGeckoInputConnection(View targetView) {
84717:         super(targetView);
84717:     }
84717: 
84717:     @Override
84717:     public boolean beginBatchEdit() {
84717:         Log.d(LOGTAG, "IME: beginBatchEdit");
84717:         return super.beginBatchEdit();
84717:     }
84717: 
84717:     @Override
84717:     public boolean endBatchEdit() {
84717:         Log.d(LOGTAG, "IME: endBatchEdit");
84717:         return super.endBatchEdit();
84717:     }
84717: 
84717:     @Override
84717:     public boolean commitCompletion(CompletionInfo text) {
84717:         Log.d(LOGTAG, "IME: commitCompletion");
84717:         return super.commitCompletion(text);
84717:     }
84717: 
84717:     @Override
84717:     public boolean commitText(CharSequence text, int newCursorPosition) {
84717:         Log.d(LOGTAG, String.format("IME: commitText(\"%s\", %d)", text, newCursorPosition));
84717:         return super.commitText(text, newCursorPosition);
84717:     }
84717: 
84717:     @Override
84717:     public boolean deleteSurroundingText(int leftLength, int rightLength) {
84717:         Log.d(LOGTAG, "IME: deleteSurroundingText(leftLen=" + leftLength +", rightLen=" + rightLength + ")");
84717:         return super.deleteSurroundingText(leftLength, rightLength);
84717:     }
84717: 
84717:     @Override
84717:     public boolean finishComposingText() {
84717:         Log.d(LOGTAG, "IME: finishComposingText");
84717:         return super.finishComposingText();
84717:     }
84717: 
84717:     @Override
84717:     public Editable getEditable() {
84717:         Log.d(LOGTAG, "IME: getEditable called from " + Thread.currentThread().getStackTrace()[0].toString());
84717:         return super.getEditable();
84717:     }
84717: 
84717:     @Override
84717:     public boolean performContextMenuAction(int id) {
84717:         Log.d(LOGTAG, "IME: performContextMenuAction");
84717:         return super.performContextMenuAction(id);
84717:     }
84717: 
84717:     @Override
84717:     public ExtractedText getExtractedText(ExtractedTextRequest req, int flags) {
84717:         Log.d(LOGTAG, "IME: getExtractedText");
84717:         ExtractedText extract = super.getExtractedText(req, flags);
84717:         if (extract != null)
84717:             Log.d(LOGTAG, String.format(". . . getExtractedText: extract.text=\"%s\", selStart=%d, selEnd=%d",
84717:                                         extract.text, extract.selectionStart, extract.selectionEnd));
84717:         return extract;
84717:     }
84717: 
84717:     @Override
84717:     public CharSequence getTextAfterCursor(int length, int flags) {
84717:         Log.d(LOGTAG, "IME: getTextAfterCursor(length=" + length + ", flags=" + flags + ")");
84717:         CharSequence s = super.getTextAfterCursor(length, flags);
84717:         Log.d(LOGTAG, ". . . getTextAfterCursor returns \"" + s + "\"");
84717:         return s;
84717:     }
84717: 
84717:     @Override
84717:     public CharSequence getTextBeforeCursor(int length, int flags) {
84717:         Log.d(LOGTAG, "IME: getTextBeforeCursor");
84717:         CharSequence s = super.getTextBeforeCursor(length, flags);
84717:         Log.d(LOGTAG, ". . . getTextBeforeCursor returns \"" + s + "\"");
84717:         return s;
84717:     }
84717: 
84717:     @Override
84717:     public boolean setComposingText(CharSequence text, int newCursorPosition) {
84717:         Log.d(LOGTAG, String.format("IME: setComposingText(\"%s\", %d)", text, newCursorPosition));
84717:         return super.setComposingText(text, newCursorPosition);
84717:     }
84717: 
84717:     @Override
84717:     public boolean setComposingRegion(int start, int end) {
84717:         Log.d(LOGTAG, "IME: setComposingRegion(start=" + start + ", end=" + end + ")");
84717:         return super.setComposingRegion(start, end);
84717:     }
84717: 
84717:     @Override
84717:     public boolean setSelection(int start, int end) {
84717:         Log.d(LOGTAG, "IME: setSelection(start=" + start + ", end=" + end + ")");
84717:         return super.setSelection(start, end);
84717:     }
84717: 
84717:     @Override
84717:     public String getComposingText() {
84717:         Log.d(LOGTAG, "IME: getComposingText");
84717:         String s = super.getComposingText();
84717:         Log.d(LOGTAG, ". . . getComposingText: Composing text = \"" + s + "\"");
84717:         return s;
84717:     }
84717:     
84717:     @Override
84717:     public boolean onKeyDel() {
84717:         Log.d(LOGTAG, "IME: onKeyDel");
84717:         return super.onKeyDel();
84717:     }
84717: 
84717:     @Override
84717:     public void notifyTextChange(InputMethodManager imm, String text,
84717:                                  int start, int oldEnd, int newEnd) {
85368:         Log.d(LOGTAG, String.format("IME: >notifyTextChange(\"%s\", start=%d, oldEnd=%d, newEnd=%d)",
85368:                                     text, start, oldEnd, newEnd));
84717:         super.notifyTextChange(imm, text, start, oldEnd, newEnd);
84717:     }
84717: 
84717:     @Override
84717:     public void notifySelectionChange(InputMethodManager imm,
84717:                                       int start, int end) {
85368:         Log.d(LOGTAG, String.format("IME: >notifySelectionChange(start=%d, end=%d)", start, end));
84717:         super.notifySelectionChange(imm, start, end);
84717:     }
84717: 
84717:     @Override
84717:     public void reset() {
84717:         Log.d(LOGTAG, "IME: reset");
84717:         super.reset();
84717:     }
84717: 
84717:     @Override
84717:     public void onTextChanged(CharSequence s, int start, int before, int count)
84717:     {
85368:         Log.d(LOGTAG, String.format("IME: onTextChanged(\"%s\" start=%d, before=%d, count=%d)", s, start, before, count));
84717:         super.onTextChanged(s, start, before, count);
84717:     }
84717: 
84717:     @Override
84717:     public void afterTextChanged(Editable s)
84717:     {
84717:         Log.d(LOGTAG, "IME: afterTextChanged(\"" + s + "\")");
84717:         super.afterTextChanged(s);
84717:     }
84717: 
84717:     @Override
84717:     public void beforeTextChanged(CharSequence s, int start, int count, int after)
84717:     {
84717:         Log.d(LOGTAG, String.format("IME: beforeTextChanged(\"%s\", start=%d, count=%d, after=%d)", s, start, count, after));
84717:         super.beforeTextChanged(s, start, count, after);
84717:     }
84717: 
84717:     @Override
84717:     public InputConnection onCreateInputConnection(EditorInfo outAttrs)
84717:     {
84717:         Log.d(LOGTAG, "IME: handleCreateInputConnection called");
84717:         return super.onCreateInputConnection(outAttrs);
84717:     }
84717: 
84717:     @Override
84717:     public boolean onKeyPreIme(int keyCode, KeyEvent event) {
84717:         Log.d(LOGTAG, "IME: onKeyPreIme(keyCode=" + keyCode + ", event=" + event + ")");
84717:         return super.onKeyPreIme(keyCode, event);
84717:     }
84717: 
84717:     @Override
84717:     public boolean onKeyDown(int keyCode, KeyEvent event) {
84717:         Log.d(LOGTAG, "IME: onKeyDown(keyCode=" + keyCode + ", event=" + event + ")");
84717:         return super.onKeyDown(keyCode, event);
84717:     }
84717: 
84717:     @Override
84717:     public boolean onKeyUp(int keyCode, KeyEvent event) {
84717:         Log.d(LOGTAG, "IME: onKeyUp(keyCode=" + keyCode + ", event=" + event + ")");
84717:         return super.onKeyUp(keyCode, event);
84717:     }
84717: 
84717:     @Override
84717:     public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) {
84717:         Log.d(LOGTAG, "IME: onKeyMultiple(keyCode=" + keyCode + ", repeatCount=" + repeatCount + ", event=" + event + ")");
84717:         return super.onKeyMultiple(keyCode, repeatCount, event);
84717:     }
84717: 
84717:     @Override
84717:     public boolean onKeyLongPress(int keyCode, KeyEvent event) {
84717:         Log.d(LOGTAG, "IME: onKeyLongPress(keyCode=" + keyCode + ", event=" + event + ")");
84717:         return super.onKeyLongPress(keyCode, event);
84717:     }
84717: 
84717:     @Override
84717:     public void notifyIME(int type, int state) {
85368:         Log.d(LOGTAG, String.format("IME: >notifyIME(type=%d, state=%d)", type, state));
84717:         super.notifyIME(type, state);
84717:     }
84717: 
84717:     @Override
84717:     public void notifyIMEChange(String text, int start, int end, int newEnd) {
85368:         Log.d(LOGTAG, String.format("IME: >notifyIMEChange(\"%s\", start=%d, end=%d, newEnd=%d)",
85368:                                     text, start, end, newEnd));
84717:         super.notifyIMEChange(text, start, end, newEnd);
84717:     }
84717: }
