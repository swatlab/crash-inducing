    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Conrad Carlen <ccarlen@netscape.com>
  295:  *  Ere Maijala <emaijala@kolumbus.fi>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsPluginDirServiceProvider.h"
    1: 
    1: #include "nsCRT.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsDependentString.h"
    1: #include "nsXPIDLString.h"
    1: #include "prmem.h"
    1: #include "nsArrayEnumerator.h"
    1: 
    1: typedef struct structVer
    1: {
    1:   WORD wMajor;
    1:   WORD wMinor;
    1:   WORD wRelease;
    1:   WORD wBuild;
    1: } verBlock;
    1: 
    1: static void
    1: ClearVersion(verBlock *ver)
    1: {
    1:   ver->wMajor   = 0;
    1:   ver->wMinor   = 0;
    1:   ver->wRelease = 0;
    1:   ver->wBuild   = 0;
    1: }
    1: 
    1: static BOOL
38314: FileExists(LPCWSTR szFile)
    1: {
38314:   return GetFileAttributesW(szFile) != 0xFFFFFFFF;
    1: }
    1: 
    1: // Get file version information from a file
    1: static BOOL
38314: GetFileVersion(LPCWSTR szFile, verBlock *vbVersion)
    1: {
    1:   UINT              uLen;
    1:   UINT              dwLen;
    1:   BOOL              bRv;
    1:   DWORD             dwHandle;
    1:   LPVOID            lpData;
    1:   LPVOID            lpBuffer;
    1:   VS_FIXEDFILEINFO  *lpBuffer2;
    1: 
    1:   ClearVersion(vbVersion);
    1:   if (FileExists(szFile)) {
    1:     bRv    = TRUE;
38323: #ifdef WINCE
38323:     // WinCe takes a non const file path string, while desktop take a const
38323:     LPWSTR lpFilepath = const_cast<LPWSTR>(szFile);
38323: #else
38323:     LPCWSTR lpFilepath = szFile;
38323: #endif
38323:     dwLen  = GetFileVersionInfoSizeW(lpFilepath, &dwHandle);
    1:     lpData = (LPVOID)malloc(dwLen);
    1:     uLen   = 0;
    1: 
38323:     if (lpData && GetFileVersionInfoW(lpFilepath, dwHandle, dwLen, lpData) != 0) {
38313:       if (VerQueryValueW(lpData, L"\\", &lpBuffer, &uLen) != 0) {
    1:         lpBuffer2 = (VS_FIXEDFILEINFO *)lpBuffer;
    1: 
    1:         vbVersion->wMajor   = HIWORD(lpBuffer2->dwFileVersionMS);
    1:         vbVersion->wMinor   = LOWORD(lpBuffer2->dwFileVersionMS);
    1:         vbVersion->wRelease = HIWORD(lpBuffer2->dwFileVersionLS);
    1:         vbVersion->wBuild   = LOWORD(lpBuffer2->dwFileVersionLS);
    1:       }
    1:     }
    1: 
    1:     free(lpData);
    1:   } else {
    1:     /* File does not exist */
    1:     bRv = FALSE;
    1:   }
    1: 
    1:   return bRv;
    1: }
    1: 
    1: // Will deep copy ver2 into ver1
    1: static void
    1: CopyVersion(verBlock *ver1, verBlock *ver2)
    1: {
    1:   ver1->wMajor   = ver2->wMajor;
    1:   ver1->wMinor   = ver2->wMinor;
    1:   ver1->wRelease = ver2->wRelease;
    1:   ver1->wBuild   = ver2->wBuild;
    1: }
    1: 
    1: // Convert a string version to a version struct
    1: static void
38313: TranslateVersionStr(const WCHAR* szVersion, verBlock *vbVersion)
    1: {
38314:   WCHAR* szNum1 = NULL;
38314:   WCHAR* szNum2 = NULL;
38314:   WCHAR* szNum3 = NULL;
38314:   WCHAR* szNum4 = NULL;
38314:   WCHAR* szJavaBuild = NULL;
    1: 
38313:   WCHAR *strVer = nsnull;
    1:   if (szVersion) {
38313:     strVer = wcsdup(szVersion);
    1:   }
    1: 
    1:   if (!strVer) {
    1:     // Out of memory
    1:     ClearVersion(vbVersion);
    1:     return;
    1:   }
    1: 
    1:   // Java may be using an underscore instead of a dot for the build ID
38313:   szJavaBuild = wcschr(strVer, '_');
    1:   if (szJavaBuild) {
    1:     szJavaBuild[0] = '.';
    1:   }
    1: 
38313:   szNum1 = wcstok(strVer, L".");
38313:   szNum2 = wcstok(NULL,   L".");
38313:   szNum3 = wcstok(NULL,   L".");
38313:   szNum4 = wcstok(NULL,   L".");
    1: 
38314:   vbVersion->wMajor   = szNum1 ? (WORD) _wtoi(szNum1) : 0;
38314:   vbVersion->wMinor   = szNum2 ? (WORD) _wtoi(szNum2) : 0;
38314:   vbVersion->wRelease = szNum3 ? (WORD) _wtoi(szNum3) : 0;
38314:   vbVersion->wBuild   = szNum4 ? (WORD) _wtoi(szNum4) : 0;
    1: 
25861:   free(strVer);
    1: }
    1: 
    1: // Compare two version struct, return zero if the same
    1: static int
    1: CompareVersion(verBlock vbVersionOld, verBlock vbVersionNew)
    1: {
    1:   if (vbVersionOld.wMajor > vbVersionNew.wMajor) {
    1:     return 4;
    1:   } else if (vbVersionOld.wMajor < vbVersionNew.wMajor) {
    1:     return -4;
    1:   }
    1: 
    1:   if (vbVersionOld.wMinor > vbVersionNew.wMinor) {
    1:     return 3;
    1:   } else if (vbVersionOld.wMinor < vbVersionNew.wMinor) {
    1:     return -3;
    1:   }
    1: 
    1:   if (vbVersionOld.wRelease > vbVersionNew.wRelease) {
    1:     return 2;
    1:   } else if (vbVersionOld.wRelease < vbVersionNew.wRelease) {
    1:     return -2;
    1:   }
    1: 
    1:   if (vbVersionOld.wBuild > vbVersionNew.wBuild) {
    1:     return 1;
    1:   } else if (vbVersionOld.wBuild < vbVersionNew.wBuild) {
    1:     return -1;
    1:   }
    1: 
    1:   /* the versions are all the same */
    1:   return 0;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsPluginDirServiceProvider::Constructor/Destructor
    1: //*****************************************************************************
    1: 
    1: nsPluginDirServiceProvider::nsPluginDirServiceProvider()
    1: {
    1: }
    1: 
    1: nsPluginDirServiceProvider::~nsPluginDirServiceProvider()
    1: {
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsPluginDirServiceProvider::nsISupports
    1: //*****************************************************************************
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsPluginDirServiceProvider,
    1:                               nsIDirectoryServiceProvider)
    1: 
    1: //*****************************************************************************
    1: // nsPluginDirServiceProvider::nsIDirectoryServiceProvider
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
25861: nsPluginDirServiceProvider::GetFile(const char *charProp, PRBool *persistant,
    1:                                     nsIFile **_retval)
    1: {
    1:   nsCOMPtr<nsILocalFile>  localFile;
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
25861:   NS_ENSURE_ARG(charProp);
25861: 
    1:   *_retval = nsnull;
 4252:   *persistant = PR_FALSE;
    1: 
    1:   nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
29079:   if (!prefs)
29079:     return NS_ERROR_FAILURE;
    1: 
25861:   if (nsCRT::strcmp(charProp, NS_WIN_4DOTX_SCAN_KEY) == 0) {
    1:     // Check our prefs to see if scanning the 4.x folder has been
    1:     // explictly overriden failure to get the pref is okay, we'll do
    1:     // what we've been doing -- a filtered scan
    1:     PRBool bScan4x;
    1:     if (NS_SUCCEEDED(prefs->GetBoolPref(NS_WIN_4DOTX_SCAN_KEY, &bScan4x)) &&
    1:         !bScan4x) {
29079:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Look for the plugin folder that the user has in their
    1:     // Communicator 4x install
    1:     HKEY keyloc;
    1:     long result;
    1:     DWORD type;
38313:     WCHAR szKey[_MAX_PATH] = L"Software\\Netscape\\Netscape Navigator";
38313:     WCHAR path[_MAX_PATH];
    1: 
38313:     result = ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &keyloc);
    1: 
    1:     if (result == ERROR_SUCCESS) {
38313:       WCHAR current_version[80];
25861:       DWORD length = NS_ARRAY_LENGTH(current_version);
    1: 
38313:       result = ::RegQueryValueExW(keyloc, L"CurrentVersion", NULL, &type,
    1:                                   (LPBYTE)&current_version, &length);
    1: 
    1:       ::RegCloseKey(keyloc);
38313:       wcscat(szKey, L"\\");
38313:       wcscat(szKey, current_version);
38313:       wcscat(szKey, L"\\Main");
38313:       result = ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &keyloc);
    1: 
    1:       if (result == ERROR_SUCCESS) {
25861:         DWORD pathlen = NS_ARRAY_LENGTH(path);
    1: 
38313:         result = ::RegQueryValueExW(keyloc, L"Plugins Directory", NULL, &type,
    1:                                    (LPBYTE)&path, &pathlen);
    1:         if (result == ERROR_SUCCESS) {
38313:           rv = NS_NewLocalFile(nsDependentString(path),
38313:                                PR_TRUE, getter_AddRefs(localFile));
    1:         }
    1: 
    1:         ::RegCloseKey(keyloc);
    1:       }
    1:     }
25861:   } else if (nsCRT::strcmp(charProp, NS_WIN_JRE_SCAN_KEY) == 0) {
    1:     nsXPIDLCString strVer;
25861:     if (NS_FAILED(prefs->GetCharPref(charProp, getter_Copies(strVer))))
    1:       return NS_ERROR_FAILURE;
    1:     verBlock minVer;
38313:     TranslateVersionStr(NS_ConvertASCIItoUTF16(strVer).get(), &minVer);
    1: 
    1:     // Look for the Java OJI plugin via the JRE install path
    1:     HKEY baseloc;
    1:     HKEY keyloc;
    1:     HKEY entryloc;
    1:     FILETIME modTime;
    1:     DWORD type;
    1:     DWORD index = 0;
    1:     DWORD numChars = _MAX_PATH;
    1:     DWORD pathlen;
    1:     verBlock maxVer;
    1:     ClearVersion(&maxVer);
38313:     WCHAR curKey[_MAX_PATH] = L"Software\\JavaSoft\\Java Runtime Environment";
38313:     WCHAR path[_MAX_PATH];
 8511:     // Add + 15 to prevent buffer overrun when adding \bin (+ optionally
 8511:     // \new_plugin)
 8511: #define JAVA_PATH_SIZE _MAX_PATH + 15
38313:     WCHAR newestPath[JAVA_PATH_SIZE];
38313:     WCHAR browserJavaVersion[_MAX_PATH];
    1: 
    1:     newestPath[0] = 0;
38313:     LONG result = ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, curKey, 0, KEY_READ,
    1:                                   &baseloc);
    1:     if (ERROR_SUCCESS != result)
    1:       return NS_ERROR_FAILURE;
    1: 
    1:     // Look for "BrowserJavaVersion"
38313:     if (ERROR_SUCCESS != ::RegQueryValueExW(baseloc, L"BrowserJavaVersion", NULL,
    1:                                             NULL, (LPBYTE)&browserJavaVersion,
    1:                                             &numChars))
    1:       browserJavaVersion[0] = 0;
    1: 
    1:     // We must enumerate through the keys because what if there is
    1:     // more than one version?
    1:     do {
    1:       path[0] = 0;
    1:       numChars = _MAX_PATH;
25861:       pathlen = NS_ARRAY_LENGTH(path);
38314:       result = ::RegEnumKeyExW(baseloc, index, curKey, &numChars, NULL, NULL,
    1:                                NULL, &modTime);
    1:       index++;
    1: 
    1:       // Skip major.minor as it always points to latest in its family
    1:       numChars = 0;
38313:       for (WCHAR *p = curKey; *p; p++) {
    1:         if (*p == '.') {
    1:           numChars++;
    1:         }
    1:       }
    1:       if (numChars < 2)
    1:         continue;
    1: 
    1:       if (ERROR_SUCCESS == result) {
38313:         if (ERROR_SUCCESS == ::RegOpenKeyExW(baseloc, curKey, 0,
    1:                                              KEY_QUERY_VALUE, &keyloc)) {
    1:           // We have a sub key
38313:           if (ERROR_SUCCESS == ::RegQueryValueExW(keyloc, L"JavaHome", NULL,
    1:                                                   &type, (LPBYTE)&path,
    1:                                                   &pathlen)) {
    1:             verBlock curVer;
12902:             TranslateVersionStr(curKey, &curVer);
    1:             if (CompareVersion(curVer, minVer) >= 0) {
38313:               if (!wcsncmp(browserJavaVersion, curKey, _MAX_PATH)) {
38313:                 wcscpy(newestPath, path);
    1:                 ::RegCloseKey(keyloc);
    1:                 break;
    1:               }
    1: 
    1:               if (CompareVersion(curVer, maxVer) >= 0) {
38313:                 wcscpy(newestPath, path);
    1:                 CopyVersion(&maxVer, &curVer);
    1:               }
    1:             }
    1:           }
    1:           ::RegCloseKey(keyloc);
    1:         }
    1:       }
    1:     } while (ERROR_SUCCESS == result);
    1: 
    1:     ::RegCloseKey(baseloc);
    1: 
62749:     if (newestPath[0] == 0) {
62749:       return NS_ERROR_FAILURE;
62749:     }
38313: 
62749:     // We require the newer NPAPI Java plugin.
62749:     wcscat(newestPath, L"\\bin\\new_plugin");
62749: 
62749:     rv = NS_NewLocalFile(nsDependentString(newestPath),
62749:                          PR_TRUE, getter_AddRefs(localFile));
62749: 
62749:     if (NS_SUCCEEDED(rv)) {
62749:       const WCHAR mozPath[_MAX_PATH] = L"Software\\mozilla.org\\Mozilla";
38314:       if (ERROR_SUCCESS == ::RegCreateKeyExW(HKEY_LOCAL_MACHINE, mozPath, 0,
    1:                                              NULL, REG_OPTION_NON_VOLATILE,
    1:                                              KEY_SET_VALUE|KEY_QUERY_VALUE,
    1:                                              NULL, &entryloc, NULL)) {
38313:         if (ERROR_SUCCESS != ::RegQueryValueExW(entryloc, L"CurrentVersion", 0,
    1:                                                 NULL, NULL, NULL)) {
62749:           static const WCHAR kMozillaVersion[] = NS_L(MOZILLA_VERSION);
38313:           ::RegSetValueExW(entryloc, L"CurrentVersion", 0, REG_SZ,
38313:                            (const BYTE*) kMozillaVersion,
38313:                            NS_ARRAY_LENGTH(kMozillaVersion));
    1:         }
    1:         ::RegCloseKey(entryloc);
    1:       }
    1:     }
25861:   } else if (nsCRT::strcmp(charProp, NS_WIN_QUICKTIME_SCAN_KEY) == 0) {
    1:     nsXPIDLCString strVer;
25861:     if (NS_FAILED(prefs->GetCharPref(charProp, getter_Copies(strVer))))
    1:       return NS_ERROR_FAILURE;
    1:     verBlock minVer;
38313:     TranslateVersionStr(NS_ConvertASCIItoUTF16(strVer).get(), &minVer);
    1: 
    1:     // Look for the Quicktime system installation plugins directory
    1:     HKEY keyloc;
    1:     long result;
    1:     DWORD type;
    1:     verBlock qtVer;
    1:     ClearVersion(&qtVer);
38313:     WCHAR path[_MAX_PATH];
25861:     DWORD pathlen = NS_ARRAY_LENGTH(path);
    1: 
    1:     // First we need to check the version of Quicktime via checking
    1:     // the EXE's version table
38313:     if (ERROR_SUCCESS == ::RegOpenKeyExW(HKEY_LOCAL_MACHINE,
38313:                                          L"software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\QuickTimePlayer.exe",
25861:                                          0, KEY_READ, &keyloc)) {
38313:       if (ERROR_SUCCESS == ::RegQueryValueExW(keyloc, NULL, NULL, &type,
    1:                                               (LPBYTE)&path, &pathlen)) {
25861:         GetFileVersion(path, &qtVer);
    1:       }
    1:       ::RegCloseKey(keyloc);
    1:     }
    1:     if (CompareVersion(qtVer, minVer) < 0)
    1:       return rv;
    1: 
38313:     if (ERROR_SUCCESS == ::RegOpenKeyExW(HKEY_LOCAL_MACHINE,
38313:                                          L"software\\Apple Computer, Inc.\\QuickTime",
25861:                                         0, KEY_READ, &keyloc)) {
25861:       DWORD pathlen = NS_ARRAY_LENGTH(path);
    1: 
38313:       result = ::RegQueryValueExW(keyloc, L"InstallDir", NULL, &type,
    1:                                   (LPBYTE)&path, &pathlen);
38313:       wcscat(path, L"\\Plugins");
    1:       if (result == ERROR_SUCCESS)
38313:         rv = NS_NewLocalFile(nsDependentString(path), PR_TRUE,
    1:                              getter_AddRefs(localFile));
    1:       ::RegCloseKey(keyloc);
    1:     }
25861:   } else if (nsCRT::strcmp(charProp, NS_WIN_WMP_SCAN_KEY) == 0) {
    1:     nsXPIDLCString strVer;
25861:     if (NS_FAILED(prefs->GetCharPref(charProp, getter_Copies(strVer))))
    1:       return NS_ERROR_FAILURE;
    1:     verBlock minVer;
38313:     TranslateVersionStr(NS_ConvertASCIItoUTF16(strVer).get(), &minVer);
    1: 
    1:     // Look for Windows Media Player system installation plugins directory
    1:     HKEY keyloc;
    1:     DWORD type;
    1:     verBlock wmpVer;
    1:     ClearVersion(&wmpVer);
38313:     WCHAR path[_MAX_PATH];
25861:     DWORD pathlen = NS_ARRAY_LENGTH(path);
    1: 
    1:     // First we need to check the version of WMP
38313:     if (ERROR_SUCCESS == ::RegOpenKeyExW(HKEY_LOCAL_MACHINE,
38313:                                          L"software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wmplayer.exe",
25861:                                          0, KEY_READ, &keyloc)) {
38313:       if (ERROR_SUCCESS == ::RegQueryValueExW(keyloc, NULL, NULL, &type,
    1:                                               (LPBYTE)&path, &pathlen)) {
25861:         GetFileVersion(path, &wmpVer);
    1:       }
    1:       ::RegCloseKey(keyloc);
    1:     }
    1:     if (CompareVersion(wmpVer, minVer) < 0)
    1:       return rv;
    1: 
38313:     if (ERROR_SUCCESS == ::RegOpenKeyExW(HKEY_LOCAL_MACHINE,
38313:                                          L"software\\Microsoft\\MediaPlayer", 0,
    1:                                          KEY_READ, &keyloc)) {
38313:       if (ERROR_SUCCESS == ::RegQueryValueExW(keyloc, L"Installation Directory",
    1:                                              NULL, &type, (LPBYTE)&path,
    1:                                              &pathlen)) {
38313:         rv = NS_NewLocalFile(nsDependentString(path), PR_TRUE,
38313:                              getter_AddRefs(localFile));
    1:       }
    1: 
    1:       ::RegCloseKey(keyloc);
    1:     }
25861:   } else if (nsCRT::strcmp(charProp, NS_WIN_ACROBAT_SCAN_KEY) == 0) {
    1:     nsXPIDLCString strVer;
25861:     if (NS_FAILED(prefs->GetCharPref(charProp, getter_Copies(strVer)))) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     verBlock minVer;
38313:     TranslateVersionStr(NS_ConvertASCIItoUTF16(strVer).get(), &minVer);
    1: 
    1:     // Look for Adobe Acrobat system installation plugins directory
    1:     HKEY baseloc;
    1:     HKEY keyloc;
    1:     FILETIME modTime;
    1:     DWORD type;
    1:     DWORD index = 0;
    1:     DWORD numChars = _MAX_PATH;
    1:     DWORD pathlen;
    1:     verBlock maxVer;
    1:     ClearVersion(&maxVer);
38313:     WCHAR curKey[_MAX_PATH] = L"software\\Adobe\\Acrobat Reader";
38313:     WCHAR path[_MAX_PATH];
    1:     // Add + 8 to prevent buffer overrun when adding \browser
38313:     WCHAR newestPath[_MAX_PATH + 8];
    1: 
    1:     newestPath[0] = 0;
38313:     if (ERROR_SUCCESS != ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, curKey, 0,
    1:                                          KEY_READ, &baseloc)) {
38313:       wcscpy(curKey, L"software\\Adobe\\Adobe Acrobat");
38313:       if (ERROR_SUCCESS != ::RegOpenKeyExW(HKEY_LOCAL_MACHINE, curKey, 0,
    1:                                            KEY_READ, &baseloc)) {
    1:         return NS_ERROR_FAILURE;
    1:       }
    1:     }
    1: 
    1:     // We must enumerate through the keys because what if there is
    1:     // more than one version?
    1:     LONG result = ERROR_SUCCESS;
    1:     while (ERROR_SUCCESS == result) {
    1:       path[0] = 0;
    1:       numChars = _MAX_PATH;
25861:       pathlen = NS_ARRAY_LENGTH(path);
38314:       result = ::RegEnumKeyExW(baseloc, index, curKey, &numChars, NULL, NULL,
    1:                                NULL, &modTime);
    1:       index++;
    1: 
    1:       if (ERROR_SUCCESS == result) {
    1:         verBlock curVer;
12902:         TranslateVersionStr(curKey, &curVer);
38313:         wcscat(curKey, L"\\InstallPath");
38313:         if (ERROR_SUCCESS == ::RegOpenKeyExW(baseloc, curKey, 0,
    1:                                              KEY_QUERY_VALUE, &keyloc)) {
    1:           // We have a sub key
38313:           if (ERROR_SUCCESS == ::RegQueryValueExW(keyloc, NULL, NULL, &type,
    1:                                                   (LPBYTE)&path, &pathlen)) {
    1:             if (CompareVersion(curVer, maxVer) >= 0 &&
    1:                 CompareVersion(curVer, minVer) >= 0) {
38313:               wcscpy(newestPath, path);
    1:               CopyVersion(&maxVer, &curVer);
    1:             }
    1:           }
    1: 
    1:           ::RegCloseKey(keyloc);
    1:         }
    1:       }
    1:     }
    1: 
    1:     ::RegCloseKey(baseloc);
    1: 
    1:     if (newestPath[0] != 0) {
38313:       wcscat(newestPath, L"\\browser");
38313:       rv = NS_NewLocalFile(nsDependentString(newestPath), PR_TRUE,
38313:                            getter_AddRefs(localFile));
    1:     }
    1: 
    1:   }
    1: 
    1:   if (localFile && NS_SUCCEEDED(rv))
    1:     return CallQueryInterface(localFile, _retval);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsPluginDirServiceProvider::GetPLIDDirectories(nsISimpleEnumerator **aEnumerator)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEnumerator);
    1:   *aEnumerator = nsnull;
    1: 
    1:   nsCOMArray<nsILocalFile> dirs;
    1: 
  295:   GetPLIDDirectoriesWithHKEY(HKEY_CURRENT_USER, dirs);
  295:   GetPLIDDirectoriesWithHKEY(HKEY_LOCAL_MACHINE, dirs);
  295: 
  295:   return NS_NewArrayEnumerator(aEnumerator, dirs);
  295: }
  295: 
  295: nsresult
  295: nsPluginDirServiceProvider::GetPLIDDirectoriesWithHKEY(HKEY aKey, nsCOMArray<nsILocalFile> &aDirs)
  295: {
38313:   WCHAR subkey[_MAX_PATH] = L"Software\\MozillaPlugins";
    1:   HKEY baseloc;
    1: 
38313:   if (ERROR_SUCCESS != ::RegOpenKeyExW(aKey, subkey, 0, KEY_READ, &baseloc))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   DWORD index = 0;
  295:   DWORD subkeylen = _MAX_PATH;
    1:   FILETIME modTime;
38314:   while (ERROR_SUCCESS == ::RegEnumKeyExW(baseloc, index++, subkey, &subkeylen,
  295:                                           NULL, NULL, NULL, &modTime)) {
  295:     subkeylen = _MAX_PATH;
  295:     HKEY keyloc;
  295: 
38313:     if (ERROR_SUCCESS == ::RegOpenKeyExW(baseloc, subkey, 0, KEY_QUERY_VALUE,
  295:                                          &keyloc)) {
    1:       DWORD type;
38313:       WCHAR path[_MAX_PATH];
25861:       DWORD pathlen = NS_ARRAY_LENGTH(path);
    1: 
38313:       if (ERROR_SUCCESS == ::RegQueryValueExW(keyloc, L"Path", NULL, &type,
    1:                                               (LPBYTE)&path, &pathlen)) {
    1:         nsCOMPtr<nsILocalFile> localFile;
38313:         if (NS_SUCCEEDED(NS_NewLocalFile(nsDependentString(path), PR_TRUE,
    1:                                          getter_AddRefs(localFile))) &&
25861:             localFile)
25861:         {
    1:           // Some vendors use a path directly to the DLL so chop off
    1:           // the filename
    1:           PRBool isDir = PR_FALSE;
    1:           if (NS_SUCCEEDED(localFile->IsDirectory(&isDir)) && !isDir) {
    1:             nsCOMPtr<nsIFile> temp;
    1:             localFile->GetParent(getter_AddRefs(temp));
    1:             if (temp)
    1:               localFile = do_QueryInterface(temp);
    1:           }
    1: 
    1:           // Now we check to make sure it's actually on disk and
    1:           // To see if we already have this directory in the array
    1:           PRBool isFileThere = PR_FALSE;
    1:           PRBool isDupEntry = PR_FALSE;
    1:           if (NS_SUCCEEDED(localFile->Exists(&isFileThere)) && isFileThere) {
  295:             PRInt32 c = aDirs.Count();
    1:             for (PRInt32 i = 0; i < c; i++) {
 3233:               nsIFile *dup = static_cast<nsIFile*>(aDirs[i]);
    1:               if (dup &&
    1:                   NS_SUCCEEDED(dup->Equals(localFile, &isDupEntry)) &&
    1:                   isDupEntry) {
    1:                 break;
    1:               }
    1:             }
    1: 
    1:             if (!isDupEntry) {
  295:               aDirs.AppendObject(localFile);
    1:             }
    1:           }
    1:         }
    1:       }
    1:       ::RegCloseKey(keyloc);
    1:     }
  295:   }
    1:   ::RegCloseKey(baseloc);
  295:   return NS_OK;
    1: }
    1: 
