43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
43113: /* vim:set expandtab ts=4 sw=4 sts=4 cin: */
43113: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is Mozilla.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Darin Fisher <darin@meer.net> (original author)
43113:  *   Christian Biesinger <cbiesinger@web.de>
43113:  *   Google Inc.
43113:  *   Jan Wrobel <wrobel@blues.ath.cx>
43113:  *   Jan Odvarko <odvarko@gmail.com>
43113:  *   Dave Camp <dcamp@mozilla.com>
43113:  *   Honza Bambas <honzab@firemni.cz>
46790:  *   Daniel Witte <dwitte@mozilla.com>
46909:  *   Jason Duell <jduell.mcbugs@gmail.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
46801: #ifdef MOZ_IPC
46801: #include "base/basictypes.h"
46801: #endif 
46801: 
43113: #include "nsHttpChannel.h"
43113: #include "nsHttpHandler.h"
43113: #include "nsIApplicationCacheService.h"
43113: #include "nsIApplicationCacheContainer.h"
43113: #include "nsIAuthInformation.h"
43113: #include "nsIStringBundle.h"
43113: #include "nsIIDNService.h"
43113: #include "nsIStreamListenerTee.h"
43113: #include "nsISeekableStream.h"
43113: #include "nsMimeTypes.h"
46790: #include "nsPrintfCString.h"
43113: #include "nsNetUtil.h"
43113: #include "prprf.h"
51363: #include "prnetdb.h"
43113: #include "nsEscape.h"
43113: #include "nsInt64.h"
43113: #include "nsStreamUtils.h"
43113: #include "nsIOService.h"
43113: #include "nsICacheService.h"
43113: #include "nsDNSPrefetch.h"
43113: #include "nsChannelClassifier.h"
49375: #include "nsIRedirectResultListener.h"
43113: 
43113: // True if the local cache should be bypassed when processing a request.
43113: #define BYPASS_LOCAL_CACHE(loadFlags) \
43113:         (loadFlags & (nsIRequest::LOAD_BYPASS_CACHE | \
43113:                       nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE))
43113: 
43113: static NS_DEFINE_CID(kStreamListenerTeeCID, NS_STREAMLISTENERTEE_CID);
43113: 
49375: class AutoRedirectVetoNotifier
49375: {
49375: public:
49375:     AutoRedirectVetoNotifier(nsHttpChannel* channel) : mChannel(channel) {}
49375:     ~AutoRedirectVetoNotifier() {ReportRedirectResult(false);}
49375:     void RedirectSucceeded() {ReportRedirectResult(true);}
49375: 
49375: private:
49375:     nsHttpChannel* mChannel;
49375:     void ReportRedirectResult(bool succeeded);
49375: };
49375: 
49375: void
49375: AutoRedirectVetoNotifier::ReportRedirectResult(bool succeeded)
49375: {
49375:     if (!mChannel)
49375:         return;
49375: 
51363:     mChannel->mRedirectChannel = nsnull;
51363: 
49375:     nsCOMPtr<nsIRedirectResultListener> vetoHook;
49375:     NS_QueryNotificationCallbacks(mChannel, 
49375:                                   NS_GET_IID(nsIRedirectResultListener), 
49375:                                   getter_AddRefs(vetoHook));
49375:     mChannel = nsnull;
49375:     if (vetoHook)
49375:         vetoHook->OnRedirectResult(succeeded);
49375: }
49375: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <public>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsHttpChannel::nsHttpChannel()
46790:     : mLogicalOffset(0)
43113:     , mCacheAccess(0)
43113:     , mPostID(0)
43113:     , mRequestTime(0)
53987:     , mOnCacheEntryAvailableCallback(nsnull)
53987:     , mAsyncCacheOpen(PR_FALSE)
43113:     , mPendingAsyncCallOnResume(nsnull)
43113:     , mSuspendCount(0)
43113:     , mApplyConversion(PR_TRUE)
43113:     , mCachedContentIsValid(PR_FALSE)
43113:     , mCachedContentIsPartial(PR_FALSE)
43113:     , mTransactionReplaced(PR_FALSE)
43113:     , mAuthRetryPending(PR_FALSE)
43113:     , mResuming(PR_FALSE)
43113:     , mInitedCacheEntry(PR_FALSE)
43113:     , mCacheForOfflineUse(PR_FALSE)
43113:     , mCachingOpportunistically(PR_FALSE)
43113:     , mFallbackChannel(PR_FALSE)
43113:     , mTracingEnabled(PR_TRUE)
43113:     , mCustomConditionalRequest(PR_FALSE)
48304:     , mFallingBack(PR_FALSE)
48304:     , mWaitingForRedirectCallback(PR_FALSE)
46906:     , mRemoteChannel(PR_FALSE)
48724:     , mRequestTimeInitialized(PR_FALSE)
43113: {
43113:     LOG(("Creating nsHttpChannel [this=%p]\n", this));
43113: }
43113: 
43113: nsHttpChannel::~nsHttpChannel()
43113: {
43113:     LOG(("Destroying nsHttpChannel [this=%p]\n", this));
43113: 
46930:     if (mAuthProvider) 
46930:         mAuthProvider->Disconnect(NS_ERROR_ABORT);
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::Init(nsIURI *uri,
43113:                     PRUint8 caps,
43113:                     nsProxyInfo *proxyInfo)
43113: {
46909:     nsresult rv = HttpBaseChannel::Init(uri, caps, proxyInfo);
43113:     if (NS_FAILED(rv)) 
43113:         return rv;
43113: 
46909:     LOG(("nsHttpChannel::Init [this=%p]\n", this));
43832: 
43832:     mAuthProvider =
43832:         do_CreateInstance("@mozilla.org/network/http-channel-auth-provider;1",
43832:                           &rv);
46909:     if (NS_FAILED(rv)) 
46909:         return rv;
43832:     rv = mAuthProvider->Init(this);
43113: 
43113:     return rv;
43113: }
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <private>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpChannel::AsyncCall(nsAsyncCallback funcPtr,
43113:                          nsRunnableMethod<nsHttpChannel> **retval)
43113: {
43113:     nsresult rv;
43113: 
43113:     nsRefPtr<nsRunnableMethod<nsHttpChannel> > event =
43113:         NS_NewRunnableMethod(this, funcPtr);
43113:     rv = NS_DispatchToCurrentThread(event);
43113:     if (NS_SUCCEEDED(rv) && retval) {
43113:         *retval = event;
43113:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::Connect(PRBool firstTime)
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::Connect [this=%p]\n", this));
43113: 
51363:     // Even if we're in private browsing mode, we still enforce existing STS
51363:     // data (it is read-only).
51363:     // if the connection is not using SSL and either the exact host matches or
51363:     // a superdomain wants to force HTTPS, do it.
51363:     PRBool usingSSL = PR_FALSE;
51363:     rv = mURI->SchemeIs("https", &usingSSL);
51363:     NS_ENSURE_SUCCESS(rv,rv);
51363: 
51363:     if (!usingSSL) {
51363:         // enforce Strict-Transport-Security
51363:         nsIStrictTransportSecurityService* stss = gHttpHandler->GetSTSService();
51363:         NS_ENSURE_TRUE(stss, NS_ERROR_OUT_OF_MEMORY);
51363: 
51363:         PRBool isStsHost = PR_FALSE;
51363:         rv = stss->IsStsURI(mURI, &isStsHost);
52258: 
52258:         // if STS fails, there's no reason to cancel the load, but it's
52258:         // worrisome.
52258:         NS_ASSERTION(NS_SUCCEEDED(rv),
52258:                      "Something is wrong with STS: IsStsURI failed.");
52258: 
52258:         if (NS_SUCCEEDED(rv) && isStsHost) {
51363:             LOG(("nsHttpChannel::Connect() STS permissions found\n"));
51363:             return AsyncCall(&nsHttpChannel::HandleAsyncRedirectChannelToHttps);
51363:         }
51363:     }
51363: 
43113:     // ensure that we are using a valid hostname
43113:     if (!net_IsValidHostName(nsDependentCString(mConnectionInfo->Host())))
43113:         return NS_ERROR_UNKNOWN_HOST;
43113: 
43113:     // true when called from AsyncOpen
43113:     if (firstTime) {
43113:         // are we offline?
43113:         PRBool offline = gIOService->IsOffline();
43113:         if (offline)
43113:             mLoadFlags |= LOAD_ONLY_FROM_CACHE;
43113:         else if (PL_strcmp(mConnectionInfo->ProxyType(), "unknown") == 0)
43113:             return ResolveProxy();  // Lazily resolve proxy info
43113: 
43113:         // Don't allow resuming when cache must be used
43113:         if (mResuming && (mLoadFlags & LOAD_ONLY_FROM_CACHE)) {
43113:             LOG(("Resuming from cache is not supported yet"));
43113:             return NS_ERROR_DOCUMENT_NOT_CACHED;
43113:         }
43113: 
43113:         // open a cache entry for this channel...
53987:         rv = OpenCacheEntry();
43113: 
43113:         if (NS_FAILED(rv)) {
43113:             LOG(("OpenCacheEntry failed [rv=%x]\n", rv));
43113:             // if this channel is only allowed to pull from the cache, then
43113:             // we must fail if we were unable to open a cache entry.
43113:             if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
43113:                 // If we have a fallback URI (and we're not already
43113:                 // falling back), process the fallback asynchronously.
43113:                 if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
43113:                     return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
43113:                 }
43113:                 return NS_ERROR_DOCUMENT_NOT_CACHED;
43113:             }
43113:             // otherwise, let's just proceed without using the cache.
43113:         }
43113: 
43113:         // if cacheForOfflineUse has been set, open up an offline cache
43113:         // entry to update
43113:         if (mCacheForOfflineUse) {
43113:             rv = OpenOfflineCacheEntryForWriting();
43113:             if (NS_FAILED(rv)) return rv;
43113:         }
43113: 
53987:         if (NS_SUCCEEDED(rv) && mAsyncCacheOpen)
43113:             return NS_OK;
43113:     }
43113: 
43113:     // we may or may not have a cache entry at this point
43113:     if (mCacheEntry) {
43113:         // inspect the cache entry to determine whether or not we need to go
43113:         // out to net to validate it.  this call sets mCachedContentIsValid
43113:         // and may set request headers as required for cache validation.
43113:         rv = CheckCache();
43113:         if (NS_FAILED(rv))
43113:             NS_WARNING("cache check failed");
43113: 
43113:         // read straight from the cache if possible...
43113:         if (mCachedContentIsValid) {
43113:             nsRunnableMethod<nsHttpChannel> *event = nsnull;
43113:             if (!mCachedContentIsPartial) {
43113:                 AsyncCall(&nsHttpChannel::AsyncOnExamineCachedResponse, &event);
43113:             }
43113:             rv = ReadFromCache();
43113:             if (NS_FAILED(rv) && event) {
43113:                 event->Revoke();
43113:             }
43113:             return rv;
43113:         }
43113:         else if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
43113:             // the cache contains the requested resource, but it must be 
43113:             // validated before we can reuse it.  since we are not allowed
43113:             // to hit the net, there's nothing more to do.  the document
43113:             // is effectively not in the cache.
43113:             return NS_ERROR_DOCUMENT_NOT_CACHED;
43113:         }
43113:     }
53987:     else if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
53987:         // If we have a fallback URI (and we're not already
53987:         // falling back), process the fallback asynchronously.
53987:         if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
53987:             return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
53987:         }
53987:         return NS_ERROR_DOCUMENT_NOT_CACHED;
53987:     }
43113: 
43113:     // check to see if authorization headers should be included
43832:     mAuthProvider->AddAuthorizationHeaders();
43113: 
43113:     if (mLoadFlags & LOAD_NO_NETWORK_IO) {
43113:         return NS_ERROR_DOCUMENT_NOT_CACHED;
43113:     }
43113: 
43113:     // hit the net...
43113:     rv = SetupTransaction();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = gHttpHandler->InitiateTransaction(mTransaction, mPriority);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
53987:     rv = mTransactionPump->AsyncRead(this, nsnull);
53987:     if (NS_FAILED(rv)) return rv;
53987: 
53987:     PRUint32 suspendCount = mSuspendCount;
53987:     while (suspendCount--)
53987:         mTransactionPump->Suspend();
53987: 
53987:     return NS_OK;
43113: }
43113: 
43113: // called when Connect fails
43113: nsresult
43113: nsHttpChannel::AsyncAbort(nsresult status)
43113: {
43113:     LOG(("nsHttpChannel::AsyncAbort [this=%p status=%x]\n", this, status));
43113: 
43113:     mStatus = status;
43113:     mIsPending = PR_FALSE;
43113: 
43113:     nsresult rv = AsyncCall(&nsHttpChannel::HandleAsyncNotifyListener);
43113:     // And if that fails?  Callers ignore our return value anyway....
43113:     
43113:     // finally remove ourselves from the load group.
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, status);
43113: 
43113:     return rv;
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncNotifyListener()
43113: {
43113:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
43113:     
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async notification [this=%p]\n",
43113:              this));
43113:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncNotifyListener;
43113:         return;
43113:     }
43113: 
43113:     DoNotifyListener();
43113: }
43113: 
43113: void
43113: nsHttpChannel::DoNotifyListener()
43113: {
48304:     // Make sure mIsPending is set to PR_FALSE. At this moment we are done from
48304:     // the point of view of our consumer and we have to report our self
48304:     // as not-pending.
43113:     if (mListener) {
43113:         mListener->OnStartRequest(this, mListenerContext);
48354:         mIsPending = PR_FALSE;
43113:         mListener->OnStopRequest(this, mListenerContext, mStatus);
43113:         mListener = 0;
43113:         mListenerContext = 0;
43113:     }
48354:     else {
48354:         mIsPending = PR_FALSE;
48354:     }
43113:     // We have to make sure to drop the reference to the callbacks too
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncRedirect()
43113: {
43113:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
43113:     
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async redirect [this=%p]\n", this));
43113:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncRedirect;
43113:         return;
43113:     }
43113: 
43113:     nsresult rv = NS_OK;
43113: 
43113:     LOG(("nsHttpChannel::HandleAsyncRedirect [this=%p]\n", this));
43113: 
43113:     // since this event is handled asynchronously, it is possible that this
43113:     // channel could have been canceled, in which case there would be no point
43113:     // in processing the redirect.
43113:     if (NS_SUCCEEDED(mStatus)) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncRedirect);
48304:         rv = AsyncProcessRedirection(mResponseHead->Status());
43113:         if (NS_FAILED(rv)) {
48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncRedirect);
48304:             ContinueHandleAsyncRedirect(rv);
48304:         }
48304:     }
48304:     else {
48304:         ContinueHandleAsyncRedirect(NS_OK);
48304:     }
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueHandleAsyncRedirect(nsresult rv)
48304: {
48304:     if (NS_FAILED(rv)) {
48304:         // If AsyncProcessRedirection fails, then we have to send out the
43113:         // OnStart/OnStop notifications.
48304:         LOG(("ContinueHandleAsyncRedirect got failure result [rv=%x]\n", rv));
43113:         mStatus = rv;
43113:         DoNotifyListener();
43113:     }
43113: 
43113:     // close the cache entry.  Blow it away if we couldn't process the redirect
43113:     // for some reason (the cache entry might be corrupt).
43113:     if (mCacheEntry) {
43113:         if (NS_FAILED(rv))
43113:             mCacheEntry->Doom();
43113:         CloseCacheEntry(PR_FALSE);
43113:     }
43113: 
43113:     mIsPending = PR_FALSE;
43113: 
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
48304: 
48304:     return NS_OK;
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncNotModified()
43113: {
43113:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
43113:     
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async not-modified [this=%p]\n",
43113:              this));
43113:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncNotModified;
43113:         return;
43113:     }
43113:     
43113:     LOG(("nsHttpChannel::HandleAsyncNotModified [this=%p]\n", this));
43113: 
43113:     DoNotifyListener();
43113: 
43113:     CloseCacheEntry(PR_TRUE);
43113: 
43113:     mIsPending = PR_FALSE;
43113: 
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncFallback()
43113: {
43113:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
43113: 
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async fallback [this=%p]\n", this));
43113:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncFallback;
43113:         return;
43113:     }
43113: 
43113:     nsresult rv = NS_OK;
43113: 
43113:     LOG(("nsHttpChannel::HandleAsyncFallback [this=%p]\n", this));
43113: 
43113:     // since this event is handled asynchronously, it is possible that this
43113:     // channel could have been canceled, in which case there would be no point
43113:     // in processing the fallback.
43113:     if (!mCanceled) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncFallback);
48304:         PRBool waitingForRedirectCallback;
48304:         rv = ProcessFallback(&waitingForRedirectCallback);
48304:         if (waitingForRedirectCallback)
48304:             return;
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncFallback);
48304:     }
48304: 
48304:     ContinueHandleAsyncFallback(rv);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueHandleAsyncFallback(nsresult rv)
48304: {
48304:     if (!mCanceled && (NS_FAILED(rv) || !mFallingBack)) {
43113:         // If ProcessFallback fails, then we have to send out the
43113:         // OnStart/OnStop notifications.
48304:         LOG(("ProcessFallback failed [rv=%x, %d]\n", rv, mFallingBack));
43113:         mStatus = NS_FAILED(rv) ? rv : NS_ERROR_DOCUMENT_NOT_CACHED;
43113:         DoNotifyListener();
43113:     }
43113: 
43113:     mIsPending = PR_FALSE;
43113: 
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
48304: 
48304:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::SetupTransaction()
43113: {
43113:     LOG(("nsHttpChannel::SetupTransaction [this=%p]\n", this));
43113: 
43113:     NS_ENSURE_TRUE(!mTransaction, NS_ERROR_ALREADY_INITIALIZED);
43113: 
43113:     nsresult rv;
43113: 
43113:     if (mCaps & NS_HTTP_ALLOW_PIPELINING) {
43113:         //
43113:         // disable pipelining if:
43113:         //   (1) pipelining has been explicitly disabled
43113:         //   (2) request corresponds to a top-level document load (link click)
43113:         //   (3) request method is non-idempotent
43113:         //
43113:         // XXX does the toplevel document check really belong here?  or, should
43113:         //     we push it out entirely to necko consumers?
43113:         //
43113:         if (!mAllowPipelining || (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI) ||
43113:             !(mRequestHead.Method() == nsHttp::Get ||
43113:               mRequestHead.Method() == nsHttp::Head ||
43113:               mRequestHead.Method() == nsHttp::Propfind ||
43113:               mRequestHead.Method() == nsHttp::Proppatch)) {
43113:             LOG(("  pipelining disallowed\n"));
43113:             mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
43113:         }
43113:     }
43113: 
43113:     // use the URI path if not proxying (transparent proxying such as SSL proxy
43113:     // does not count here). also, figure out what version we should be speaking.
43113:     nsCAutoString buf, path;
43113:     nsCString* requestURI;
43113:     if (mConnectionInfo->UsingSSL() || !mConnectionInfo->UsingHttpProxy()) {
43113:         rv = mURI->GetPath(path);
43113:         if (NS_FAILED(rv)) return rv;
43113:         // path may contain UTF-8 characters, so ensure that they're escaped.
43113:         if (NS_EscapeURL(path.get(), path.Length(), esc_OnlyNonASCII, buf))
43113:             requestURI = &buf;
43113:         else
43113:             requestURI = &path;
43113:         mRequestHead.SetVersion(gHttpHandler->HttpVersion());
43113:     }
43113:     else {
43113:         rv = mURI->GetUserPass(buf);
43113:         if (NS_FAILED(rv)) return rv;
43113:         if (!buf.IsEmpty() && ((strncmp(mSpec.get(), "http:", 5) == 0) ||
43113:                                 strncmp(mSpec.get(), "https:", 6) == 0)) {
43113:             nsCOMPtr<nsIURI> tempURI;
43113:             rv = mURI->Clone(getter_AddRefs(tempURI));
43113:             if (NS_FAILED(rv)) return rv;
43113:             rv = tempURI->SetUserPass(EmptyCString());
43113:             if (NS_FAILED(rv)) return rv;
43113:             rv = tempURI->GetAsciiSpec(path);
43113:             if (NS_FAILED(rv)) return rv;
43113:             requestURI = &path;
43113:         }
43113:         else
43113:             requestURI = &mSpec;
43113:         mRequestHead.SetVersion(gHttpHandler->ProxyHttpVersion());
43113:     }
43113: 
43113:     // trim off the #ref portion if any...
43113:     PRInt32 ref = requestURI->FindChar('#');
43113:     if (ref != kNotFound)
43113:         requestURI->SetLength(ref);
43113: 
43113:     mRequestHead.SetRequestURI(*requestURI);
43113: 
43113:     // set the request time for cache expiration calculations
43113:     mRequestTime = NowInSeconds();
48724:     mRequestTimeInitialized = PR_TRUE;
43113: 
43113:     // if doing a reload, force end-to-end
43113:     if (mLoadFlags & LOAD_BYPASS_CACHE) {
43113:         // We need to send 'Pragma:no-cache' to inhibit proxy caching even if
43113:         // no proxy is configured since we might be talking with a transparent
43113:         // proxy, i.e. one that operates at the network level.  See bug #14772.
43113:         mRequestHead.SetHeader(nsHttp::Pragma, NS_LITERAL_CSTRING("no-cache"), PR_TRUE);
43113:         // If we're configured to speak HTTP/1.1 then also send 'Cache-control:
43113:         // no-cache'
43113:         if (mRequestHead.Version() >= NS_HTTP_VERSION_1_1)
43113:             mRequestHead.SetHeader(nsHttp::Cache_Control, NS_LITERAL_CSTRING("no-cache"), PR_TRUE);
43113:     }
43113:     else if ((mLoadFlags & VALIDATE_ALWAYS) && (mCacheAccess & nsICache::ACCESS_READ)) {
43113:         // We need to send 'Cache-Control: max-age=0' to force each cache along
43113:         // the path to the origin server to revalidate its own entry, if any,
43113:         // with the next cache or server.  See bug #84847.
43113:         //
43113:         // If we're configured to speak HTTP/1.0 then just send 'Pragma: no-cache'
43113:         if (mRequestHead.Version() >= NS_HTTP_VERSION_1_1)
43113:             mRequestHead.SetHeader(nsHttp::Cache_Control, NS_LITERAL_CSTRING("max-age=0"), PR_TRUE);
43113:         else
43113:             mRequestHead.SetHeader(nsHttp::Pragma, NS_LITERAL_CSTRING("no-cache"), PR_TRUE);
43113:     }
43113: 
43113:     if (mResuming) {
43113:         char byteRange[32];
43113:         PR_snprintf(byteRange, sizeof(byteRange), "bytes=%llu-", mStartPos);
43113:         mRequestHead.SetHeader(nsHttp::Range, nsDependentCString(byteRange));
43113: 
43113:         if (!mEntityID.IsEmpty()) {
43113:             // Also, we want an error if this resource changed in the meantime
43113:             // Format of the entity id is: escaped_etag/size/lastmod
43113:             nsCString::const_iterator start, end, slash;
43113:             mEntityID.BeginReading(start);
43113:             mEntityID.EndReading(end);
43113:             mEntityID.BeginReading(slash);
43113: 
43113:             if (FindCharInReadable('/', slash, end)) {
43113:                 nsCAutoString ifMatch;
43113:                 mRequestHead.SetHeader(nsHttp::If_Match,
43113:                         NS_UnescapeURL(Substring(start, slash), 0, ifMatch));
43113: 
43113:                 ++slash; // Incrementing, so that searching for '/' won't find
43113:                          // the same slash again
43113:             }
43113: 
43113:             if (FindCharInReadable('/', slash, end)) {
43113:                 mRequestHead.SetHeader(nsHttp::If_Unmodified_Since,
43113:                         Substring(++slash, end));
43113:             }
43113:         }
43113:     }
43113: 
43113:     // create wrapper for this channel's notification callbacks
43113:     nsCOMPtr<nsIInterfaceRequestor> callbacks;
43113:     NS_NewNotificationCallbacksAggregation(mCallbacks, mLoadGroup,
43113:                                            getter_AddRefs(callbacks));
43113:     if (!callbacks)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     // create the transaction object
43113:     mTransaction = new nsHttpTransaction();
43113:     if (!mTransaction)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     // See bug #466080. Transfer LOAD_ANONYMOUS flag to socket-layer.
43113:     if (mLoadFlags & LOAD_ANONYMOUS)
43113:         mCaps |= NS_HTTP_LOAD_ANONYMOUS;
43113: 
43113:     mConnectionInfo->SetAnonymous((mLoadFlags & LOAD_ANONYMOUS) != 0);
43113: 
43113:     nsCOMPtr<nsIAsyncInputStream> responseStream;
43113:     rv = mTransaction->Init(mCaps, mConnectionInfo, &mRequestHead,
43113:                             mUploadStream, mUploadStreamHasHeaders,
43113:                             NS_GetCurrentThread(), callbacks, this,
43113:                             getter_AddRefs(responseStream));
43113:     if (NS_FAILED(rv)) {
46790:         mTransaction = nsnull;
43113:         return rv;
43113:     }
43113: 
43113:     rv = nsInputStreamPump::Create(getter_AddRefs(mTransactionPump),
43113:                                    responseStream);
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ApplyContentConversions()
43113: {
43113:     if (!mResponseHead)
43113:         return NS_OK;
43113: 
43113:     LOG(("nsHttpChannel::ApplyContentConversions [this=%p]\n", this));
43113: 
43113:     if (!mApplyConversion) {
43113:         LOG(("not applying conversion per mApplyConversion\n"));
43113:         return NS_OK;
43113:     }
43113: 
43113:     const char *val = mResponseHead->PeekHeader(nsHttp::Content_Encoding);
43113:     if (gHttpHandler->IsAcceptableEncoding(val)) {
43113:         nsCOMPtr<nsIStreamConverterService> serv;
43113:         nsresult rv = gHttpHandler->
43113:                 GetStreamConverterService(getter_AddRefs(serv));
43113:         // we won't fail to load the page just because we couldn't load the
43113:         // stream converter service.. carry on..
43113:         if (NS_SUCCEEDED(rv)) {
43113:             nsCOMPtr<nsIStreamListener> converter;
43113:             nsCAutoString from(val);
43113:             ToLowerCase(from);
43113:             rv = serv->AsyncConvertData(from.get(),
43113:                                         "uncompressed",
43113:                                         mListener,
43113:                                         mListenerContext,
43113:                                         getter_AddRefs(converter));
43113:             if (NS_SUCCEEDED(rv)) {
43113:                 LOG(("converter installed from \'%s\' to \'uncompressed\'\n", val));
43113:                 mListener = converter;
43113:             }
43113:         }
43113:     } else if (val != nsnull) {
43113:         LOG(("Unknown content encoding '%s', ignoring\n", val));
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: // NOTE: This function duplicates code from nsBaseChannel. This will go away
43113: // once HTTP uses nsBaseChannel (part of bug 312760)
43113: static void
43113: CallTypeSniffers(void *aClosure, const PRUint8 *aData, PRUint32 aCount)
43113: {
43113:   nsIChannel *chan = static_cast<nsIChannel*>(aClosure);
43113: 
43113:   const nsCOMArray<nsIContentSniffer>& sniffers =
43113:     gIOService->GetContentSniffers();
43113:   PRUint32 length = sniffers.Count();
43113:   for (PRUint32 i = 0; i < length; ++i) {
43113:     nsCAutoString newType;
43113:     nsresult rv =
43113:       sniffers[i]->GetMIMETypeFromContent(chan, aData, aCount, newType);
43113:     if (NS_SUCCEEDED(rv) && !newType.IsEmpty()) {
43113:       chan->SetContentType(newType);
43113:       break;
43113:     }
43113:   }
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::CallOnStartRequest()
43113: {
43113:     mTracingEnabled = PR_FALSE;
43113: 
43113:     if (mResponseHead && mResponseHead->ContentType().IsEmpty()) {
43113:         if (!mContentTypeHint.IsEmpty())
43113:             mResponseHead->SetContentType(mContentTypeHint);
43113:         else {
43113:             // Uh-oh.  We had better find out what type we are!
43113: 
43113:             // XXX This does not work with content-encodings...  but
43113:             // neither does applying the conversion from the URILoader
43113: 
43113:             nsCOMPtr<nsIStreamConverterService> serv;
43113:             nsresult rv = gHttpHandler->
43113:                 GetStreamConverterService(getter_AddRefs(serv));
43113:             // If we failed, we just fall through to the "normal" case
43113:             if (NS_SUCCEEDED(rv)) {
43113:                 nsCOMPtr<nsIStreamListener> converter;
43113:                 rv = serv->AsyncConvertData(UNKNOWN_CONTENT_TYPE,
43113:                                             "*/*",
43113:                                             mListener,
43113:                                             mListenerContext,
43113:                                             getter_AddRefs(converter));
43113:                 if (NS_SUCCEEDED(rv)) {
43113:                     mListener = converter;
43113:                 }
43113:             }
43113:         }
43113:     }
43113: 
43113:     if (mResponseHead && mResponseHead->ContentCharset().IsEmpty())
43113:         mResponseHead->SetContentCharset(mContentCharsetHint);
43113: 
52144:     if (mResponseHead) {
51740:         SetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH,
51740:                            mResponseHead->ContentLength());
52144:         // If we have a cache entry, set its predicted size to ContentLength to
52144:         // avoid caching an entry that will exceed the max size limit.
52144:         if (mCacheEntry) {
52144:             nsresult rv;
52144:             PRInt64 predictedDataSize = -1; // -1 in case GetAsInt64 fails.
52144:             GetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH, 
52144:                                &predictedDataSize);
52144:             rv = mCacheEntry->SetPredictedDataSize(predictedDataSize);
52144:             if (NS_FAILED(rv)) return rv;
52144:         }
52144:     }
43113:     // Allow consumers to override our content type
43113:     if ((mLoadFlags & LOAD_CALL_CONTENT_SNIFFERS) &&
43113:         gIOService->GetContentSniffers().Count() != 0) {
43113:         // NOTE: We can have both a txn pump and a cache pump when the cache
43113:         // content is partial. In that case, we need to read from the cache,
43113:         // because that's the one that has the initial contents. If that fails
43113:         // then give the transaction pump a shot.
43113: 
43113:         nsIChannel* thisChannel = static_cast<nsIChannel*>(this);
43113: 
43113:         PRBool typeSniffersCalled = PR_FALSE;
43113:         if (mCachePump) {
43113:           typeSniffersCalled =
43113:             NS_SUCCEEDED(mCachePump->PeekStream(CallTypeSniffers, thisChannel));
43113:         }
43113:         
43113:         if (!typeSniffersCalled && mTransactionPump) {
43113:           mTransactionPump->PeekStream(CallTypeSniffers, thisChannel);
43113:         }
43113:     }
43113: 
43113:     LOG(("  calling mListener->OnStartRequest\n"));
43113:     nsresult rv = mListener->OnStartRequest(this, mListenerContext);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // install stream converter if required
43113:     rv = ApplyContentConversions();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
52366:     // if this channel is for a download, close off access to the cache.
52366:     if (mCacheEntry && mChannelIsForDownload) {
52366:         mCacheEntry->Doom();
52366:         CloseCacheEntry(PR_FALSE);
52366:     }
52366: 
43113:     if (!mCanceled) {
43113:         // create offline cache entry if offline caching was requested
43113:         if (mCacheForOfflineUse) {
43113:             PRBool shouldCacheForOfflineUse;
43113:             rv = ShouldUpdateOfflineCacheEntry(&shouldCacheForOfflineUse);
43113:             if (NS_FAILED(rv)) return rv;
43113:             
43113:             if (shouldCacheForOfflineUse) {
43113:                 LOG(("writing to the offline cache"));
43113:                 rv = InitOfflineCacheEntry();
43113:                 if (NS_FAILED(rv)) return rv;
43113:                 
43113:                 if (mOfflineCacheEntry) {
43113:                   rv = InstallOfflineCacheListener();
43113:                   if (NS_FAILED(rv)) return rv;
43113:                 }
43113:             } else {
43113:                 LOG(("offline cache is up to date, not updating"));
43113:                 CloseOfflineCacheEntry();
43113:             }
43113:         }
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ProcessFailedSSLConnect(PRUint32 httpStatus)
43113: {
43113:     // Failure to set up SSL proxy tunnel means one of the following:
43113:     // 1) Proxy wants authorization, or forbids.
43113:     // 2) DNS at proxy couldn't resolve target URL.
43113:     // 3) Proxy connection to target failed or timed out.
43113:     // 4) Eve noticed our proxy CONNECT, and is replying with malicious HTML.
43113:     // 
43113:     // Our current architecture will parse response content with the
43113:     // permission of the target URL!  Given #4, we must avoid rendering the
43113:     // body of the reply, and instead give the user a (hopefully helpful) 
43113:     // boilerplate error page, based on just the HTTP status of the reply.
43113: 
43113:     NS_ABORT_IF_FALSE(mConnectionInfo->UsingSSL(),
43113:                       "SSL connect failed but not using SSL?");
43113:     nsresult rv;
43113:     switch (httpStatus) 
43113:     {
43113:     case 300: case 301: case 302: case 303: case 307:
43113:         // Bad redirect: not top-level, or it's a POST, bad/missing Location,
43113:         // or ProcessRedirect() failed for some other reason.  Legal
43113:         // redirects that fail because site not available, etc., are handled
43113:         // elsewhere, in the regular codepath.
43113:         rv = NS_ERROR_CONNECTION_REFUSED;
43113:         break;
43113:     case 403: // HTTP/1.1: "Forbidden"
43113:     case 407: // ProcessAuthentication() failed
43113:     case 501: // HTTP/1.1: "Not Implemented"
43113:         // user sees boilerplate Mozilla "Proxy Refused Connection" page.
43113:         rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
43113:         break;
43113:     // Squid sends 404 if DNS fails (regular 404 from target is tunneled)
43113:     case 404: // HTTP/1.1: "Not Found"
43113:     // RFC 2616: "some deployed proxies are known to return 400 or 500 when
43113:     // DNS lookups time out."  (Squid uses 500 if it runs out of sockets: so
43113:     // we have a conflict here).
43113:     case 400: // HTTP/1.1 "Bad Request"
43113:     case 500: // HTTP/1.1: "Internal Server Error"
43113:         /* User sees: "Address Not Found: Firefox can't find the server at
43113:          * www.foo.com."
43113:          */
43113:         rv = NS_ERROR_UNKNOWN_HOST; 
43113:         break;
43113:     case 502: // HTTP/1.1: "Bad Gateway" (invalid resp from target server)
43113:     // Squid returns 503 if target request fails for anything but DNS.
43113:     case 503: // HTTP/1.1: "Service Unavailable"
43113:         /* User sees: "Failed to Connect:
43113:          *  Firefox can't establish a connection to the server at
43113:          *  www.foo.com.  Though the site seems valid, the browser
43113:          *  was unable to establish a connection."
43113:          */
43113:         rv = NS_ERROR_CONNECTION_REFUSED;
43113:         break;
43113:     // RFC 2616 uses 504 for both DNS and target timeout, so not clear what to
43113:     // do here: picking target timeout, as DNS covered by 400/404/500
43113:     case 504: // HTTP/1.1: "Gateway Timeout" 
43113:         // user sees: "Network Timeout: The server at www.foo.com
43113:         //              is taking too long to respond."
43113:         rv = NS_ERROR_NET_TIMEOUT;
43113:         break;
43113:     // Confused proxy server or malicious response
43113:     default:
43113:         rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
43113:         break;
43113:     }
43113:     LOG(("Cancelling failed SSL proxy connection [this=%p httpStatus=%u]\n",
43113:          this, httpStatus)); 
43113:     Cancel(rv);
43113:     CallOnStartRequest();
43113:     return rv;
43113: }
43113: 
43113: PRBool
43113: nsHttpChannel::ShouldSSLProxyResponseContinue(PRUint32 httpStatus)
43113: {
43113:     // When SSL connect has failed, allow proxy reply to continue only if it's
43113:     // an auth request, or a redirect of a non-POST top-level document load.
43113:     switch (httpStatus) {
43113:     case 407:
43113:         return PR_TRUE;
43113:     case 300: case 301: case 302: case 303: case 307:
43113:       {
43113:         return ( (mLoadFlags & nsIChannel::LOAD_DOCUMENT_URI) &&
43113:                  mURI == mDocumentURI &&
43113:                  mRequestHead.Method() != nsHttp::Post);
43113:       }
43113:     }
43113:     return PR_FALSE;
43113: }
43113: 
51363: /**
51363:  * Decide whether or not to remember Strict-Transport-Security, and whether
51363:  * or not to enforce channel integrity.
51363:  *
51363:  * @return NS_ERROR_FAILURE if there's security information missing even though
51363:  *             it's an HTTPS connection.
51363:  */
51363: nsresult
51363: nsHttpChannel::ProcessSTSHeader()
51363: {
51363:     nsresult rv;
51363: 
51363:     // We need to check private browsing mode here since some permissions are
51363:     // allowed to be tweaked when private browsing mode is enabled, but STS is
51363:     // not allowed to operate at all in PBM.
51363:     if (gHttpHandler->InPrivateBrowsingMode())
51363:         return NS_OK;
51363: 
51363:     PRBool isHttps = PR_FALSE;
51363:     rv = mURI->SchemeIs("https", &isHttps);
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     // If this channel is not loading securely, STS doesn't do anything.
51363:     // The upgrade to HTTPS takes place earlier in the channel load process.
51363:     if (!isHttps)
51363:         return NS_OK;
51363: 
51363:     nsCAutoString asciiHost;
51363:     rv = mURI->GetAsciiHost(asciiHost);
52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
51363: 
51363:     // If the channel is not a hostname, but rather an IP, STS doesn't do
51363:     // anything.
51363:     PRNetAddr hostAddr;
51363:     if (PR_SUCCESS == PR_StringToNetAddr(asciiHost.get(), &hostAddr))
51363:         return NS_OK;
51363: 
51363:     nsIStrictTransportSecurityService* stss = gHttpHandler->GetSTSService();
51363:     NS_ENSURE_TRUE(stss, NS_ERROR_OUT_OF_MEMORY);
51363: 
52258:     // mSecurityInfo may not always be present, and if it's not then it is okay
52258:     // to just disregard any STS headers since we know nothing about the
52258:     // security of the connection.
52258:     NS_ENSURE_TRUE(mSecurityInfo, NS_OK);
52258: 
51363:     // Check the trustworthiness of the channel (are there any cert errors?)
51363:     // If there are certificate errors, we still load the data, we just ignore
51363:     // any STS headers that are present.
51363:     PRBool tlsIsBroken = PR_FALSE;
51363:     rv = stss->ShouldIgnoreStsHeader(mSecurityInfo, &tlsIsBroken);
52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
51363: 
51363:     // If this was already an STS host, the connection should have been aborted
51363:     // by the bad cert handler in the case of cert errors.  If it didn't abort the connection,
51363:     // there's probably something funny going on.
51363:     // If this wasn't an STS host, errors are allowed, but no more STS processing
51363:     // will happen during the session.
51363:     PRBool wasAlreadySTSHost;
51363:     rv = stss->IsStsURI(mURI, &wasAlreadySTSHost);
52258:     // Failure here means STS is broken.  Don't prevent the load, but this
52258:     // shouldn't fail.
52258:     NS_ENSURE_SUCCESS(rv, NS_OK);
51363:     NS_ASSERTION(!(wasAlreadySTSHost && tlsIsBroken),
51363:                  "connection should have been aborted by nss-bad-cert-handler");
51363: 
51363:     // Any STS header is ignored if the channel is not trusted due to
51363:     // certificate errors (STS Spec 7.1) -- there is nothing else to do, and
51363:     // the load may progress.
51363:     if (tlsIsBroken) {
51363:         LOG(("STS: Transport layer is not trustworthy, ignoring "
51363:              "STS headers and continuing load\n"));
51363:         return NS_OK;
51363:     }
51363: 
51363:     // If there's a STS header, process it (STS Spec 7.1).  At this point in
51363:     // processing, the channel is trusted, so the header should not be ignored.
51363:     const nsHttpAtom atom = nsHttp::ResolveAtom("Strict-Transport-Security");
51363:     nsCAutoString stsHeader;
51363:     rv = mResponseHead->GetHeader(atom, stsHeader);
51363:     if (rv == NS_ERROR_NOT_AVAILABLE) {
51363:         LOG(("STS: No STS header, continuing load.\n"));
51363:         return NS_OK;
51363:     }
52258:     // All other failures are fatal.
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     rv = stss->ProcessStsHeader(mURI, stsHeader.get());
51363:     if (NS_FAILED(rv)) {
51363:         LOG(("STS: Failed to parse STS header, continuing load.\n"));
51363:         return NS_OK;
51363:     }
51363: 
51363:     return NS_OK;
51363: }
51363: 
43113: nsresult
43113: nsHttpChannel::ProcessResponse()
43113: {
43113:     nsresult rv;
43113:     PRUint32 httpStatus = mResponseHead->Status();
43113: 
43113:     LOG(("nsHttpChannel::ProcessResponse [this=%p httpStatus=%u]\n",
43113:         this, httpStatus));
43113: 
52258:     if (mTransaction->SSLConnectFailed()) {
52258:         if (!ShouldSSLProxyResponseContinue(httpStatus))
43113:             return ProcessFailedSSLConnect(httpStatus);
52258:         // If SSL proxy response needs to complete, wait to process connection
52258:         // for Strict-Transport-Security.
52258:     } else {
52258:         // Given a successful connection, process any STS data that's relevant.
51363:         rv = ProcessSTSHeader();
52258:         NS_ASSERTION(NS_SUCCEEDED(rv), "ProcessSTSHeader failed, continuing load.");
52258:     }
51363: 
43113:     // notify "http-on-examine-response" observers
43113:     gHttpHandler->OnExamineResponse(this);
43113: 
46906:     if (!mRemoteChannel) {
46906:       // For non-remote channels, we are responsible for cookies.
46906:       // Set cookies, if any exist; done after OnExamineResponse to allow those
46906:       // observers to modify the cookie response headers.
43113:       SetCookie(mResponseHead->PeekHeader(nsHttp::Set_Cookie));
46906:     }
43113: 
43113:     // handle unused username and password in url (see bug 232567)
43113:     if (httpStatus != 401 && httpStatus != 407) {
43832:         if (!mAuthRetryPending)
43832:             mAuthProvider->CheckForSuperfluousAuth();
43113:         if (mCanceled)
43113:             return CallOnStartRequest();
43113: 
43832:         // reset the authentication's current continuation state because our
43832:         // last authentication attempt has been completed successfully
43832:         mAuthProvider->Disconnect(NS_ERROR_ABORT);
43832:         mAuthProvider = nsnull;
43113:         LOG(("  continuation state has been reset"));
43113:     }
43113: 
43113:     // handle different server response categories.  Note that we handle
43113:     // caching or not caching of error pages in
43113:     // nsHttpResponseHead::MustValidate; if you change this switch, update that
43113:     // one
43113:     switch (httpStatus) {
43113:     case 200:
43113:     case 203:
43113:         // Per RFC 2616, 14.35.2, "A server MAY ignore the Range header".
43113:         // So if a server does that and sends 200 instead of 206 that we
43113:         // expect, notify our caller.
43113:         // However, if we wanted to start from the beginning, let it go through
43113:         if (mResuming && mStartPos != 0) {
43113:             LOG(("Server ignored our Range header, cancelling [this=%p]\n", this));
43113:             Cancel(NS_ERROR_NOT_RESUMABLE);
43113:             rv = CallOnStartRequest();
43113:             break;
43113:         }
43113:         // these can normally be cached
43113:         rv = ProcessNormal();
43113:         MaybeInvalidateCacheEntryForSubsequentGet();
43113:         break;
43113:     case 206:
43113:         if (mCachedContentIsPartial) // an internal byte range request...
43113:             rv = ProcessPartialContent();
43113:         else
43113:             rv = ProcessNormal();
43113:         break;
43113:     case 300:
43113:     case 301:
43113:     case 302:
43113:     case 307:
43113:     case 303:
43113: #if 0
43113:     case 305: // disabled as a security measure (see bug 187996).
43113: #endif
43113:         // don't store the response body for redirects
43113:         MaybeInvalidateCacheEntryForSubsequentGet();
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessResponse);
48304:         rv = AsyncProcessRedirection(httpStatus);
48304:         if (NS_FAILED(rv)) {
48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessResponse);
48304:             LOG(("AsyncProcessRedirection failed [rv=%x]\n", rv));
48304:             rv = ContinueProcessResponse(rv);
43113:         }
43113:         break;
43113:     case 304:
43113:         rv = ProcessNotModified();
43113:         if (NS_FAILED(rv)) {
43113:             LOG(("ProcessNotModified failed [rv=%x]\n", rv));
43113:             rv = ProcessNormal();
43113:         }
43113:         break;
43113:     case 401:
43113:     case 407:
43832:         rv = mAuthProvider->ProcessAuthentication(
43832:             httpStatus, mConnectionInfo->UsingSSL() &&
43832:                         mTransaction->SSLConnectFailed());
43832:         if (rv == NS_ERROR_IN_PROGRESS)  {
43832:             // authentication prompt has been invoked and result
43832:             // is expected asynchronously
43832:             mAuthRetryPending = PR_TRUE;
43832:             // suspend the transaction pump to stop receiving the
43832:             // unauthenticated content data. We will throw that data
43832:             // away when user provides credentials or resume the pump
43832:             // when user refuses to authenticate.
43832:             LOG(("Suspending the transaction, asynchronously prompting for credentials"));
43832:             mTransactionPump->Suspend();
43832:             rv = NS_OK;
43832:         }
43832:         else if (NS_FAILED(rv)) {
43113:             LOG(("ProcessAuthentication failed [rv=%x]\n", rv));
43113:             if (mTransaction->SSLConnectFailed())
43113:                 return ProcessFailedSSLConnect(httpStatus);
43832:             if (!mAuthRetryPending)
43832:                 mAuthProvider->CheckForSuperfluousAuth();
43113:             rv = ProcessNormal();
43113:         }
43832:         else
43832:             mAuthRetryPending = PR_TRUE; // see DoAuthRetry
43113:         break;
43113:     default:
43113:         rv = ProcessNormal();
43113:         MaybeInvalidateCacheEntryForSubsequentGet();
43113:         break;
43113:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
48304: nsHttpChannel::ContinueProcessResponse(nsresult rv)
48304: {
48304:     if (NS_SUCCEEDED(rv)) {
48304:         InitCacheEntry();
48304:         CloseCacheEntry(PR_FALSE);
48304: 
48304:         if (mCacheForOfflineUse) {
48304:             // Store response in the offline cache
48304:             InitOfflineCacheEntry();
48304:             CloseOfflineCacheEntry();
48304:         }
48304:         return NS_OK;
48304:     }
48304: 
48304:     LOG(("ContinueProcessResponse got failure result [rv=%x]\n", rv));
48304:     if (mTransaction->SSLConnectFailed()) {
48304:         return ProcessFailedSSLConnect(mRedirectType);
48304:     }
48304:     return ProcessNormal();
48304: }
48304: 
48304: nsresult
43113: nsHttpChannel::ProcessNormal()
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::ProcessNormal [this=%p]\n", this));
43113: 
43113:     PRBool succeeded;
43113:     rv = GetRequestSucceeded(&succeeded);
43113:     if (NS_SUCCEEDED(rv) && !succeeded) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessNormal);
48304:         PRBool waitingForRedirectCallback;
48304:         rv = ProcessFallback(&waitingForRedirectCallback);
48304:         if (waitingForRedirectCallback) {
48304:             // The transaction has been suspended by ProcessFallback.
48304:             return NS_OK;
48304:         }
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessNormal);
48304:     }
48304: 
48304:     return ContinueProcessNormal(NS_OK);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueProcessNormal(nsresult rv)
48304: {
43113:     if (NS_FAILED(rv)) {
48304:         // Fill the failure status here, we have failed to fall back, thus we
48304:         // have to report our status as failed.
48304:         mStatus = rv;
43113:         DoNotifyListener();
43113:         return rv;
43113:     }
43113: 
48304:     if (mFallingBack) {
43113:         // Do not continue with normal processing, fallback is in
43113:         // progress now.
43113:         return NS_OK;
43113:     }
43113: 
43113:     // if we're here, then any byte-range requests failed to result in a partial
43113:     // response.  we must clear this flag to prevent BufferPartialContent from
43113:     // being called inside our OnDataAvailable (see bug 136678).
43113:     mCachedContentIsPartial = PR_FALSE;
43113: 
43113:     ClearBogusContentEncodingIfNeeded();
43113: 
43113:     // this must be called before firing OnStartRequest, since http clients,
43113:     // such as imagelib, expect our cache entry to already have the correct
43113:     // expiration time (bug 87710).
43113:     if (mCacheEntry) {
43113:         rv = InitCacheEntry();
43113:         if (NS_FAILED(rv))
43113:             CloseCacheEntry(PR_TRUE);
43113:     }
43113: 
43113:     // Check that the server sent us what we were asking for
43113:     if (mResuming) {
43113:         // Create an entity id from the response
43113:         nsCAutoString id;
43113:         rv = GetEntityID(id);
43113:         if (NS_FAILED(rv)) {
43113:             // If creating an entity id is not possible -> error
43113:             Cancel(NS_ERROR_NOT_RESUMABLE);
43113:         }
43113:         else if (mResponseHead->Status() != 206 &&
43113:                  mResponseHead->Status() != 200) {
43113:             // Probably 404 Not Found, 412 Precondition Failed or
43113:             // 416 Invalid Range -> error
43113:             LOG(("Unexpected response status while resuming, aborting [this=%p]\n",
43113:                  this));
43113:             Cancel(NS_ERROR_ENTITY_CHANGED);
43113:         }
43113:         // If we were passed an entity id, verify it's equal to the server's
43113:         else if (!mEntityID.IsEmpty()) {
43113:             if (!mEntityID.Equals(id)) {
43113:                 LOG(("Entity mismatch, expected '%s', got '%s', aborting [this=%p]",
43113:                      mEntityID.get(), id.get(), this));
43113:                 Cancel(NS_ERROR_ENTITY_CHANGED);
43113:             }
43113:         }
43113:     }
43113: 
43113:     rv = CallOnStartRequest();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // install cache listener if we still have a cache entry open
43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE)) {
43113:         rv = InstallCacheListener();
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::PromptTempRedirect()
43113: {
43113:     if (!gHttpHandler->PromptTempRedirect()) {
43113:         return NS_OK;
43113:     }
43113:     nsresult rv;
43113:     nsCOMPtr<nsIStringBundleService> bundleService =
43113:             do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     nsCOMPtr<nsIStringBundle> stringBundle;
43113:     rv = bundleService->CreateBundle(NECKO_MSGS_URL, getter_AddRefs(stringBundle));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     nsXPIDLString messageString;
43113:     rv = stringBundle->GetStringFromName(NS_LITERAL_STRING("RepostFormData").get(), getter_Copies(messageString));
43113:     // GetStringFromName can return NS_OK and NULL messageString.
43113:     if (NS_SUCCEEDED(rv) && messageString) {
43113:         PRBool repost = PR_FALSE;
43113: 
43113:         nsCOMPtr<nsIPrompt> prompt;
43113:         GetCallback(prompt);
43113:         if (!prompt)
43113:             return NS_ERROR_NO_INTERFACE;
43113: 
43113:         prompt->Confirm(nsnull, messageString, &repost);
43113:         if (!repost)
43113:             return NS_ERROR_FAILURE;
43113:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ProxyFailover()
43113: {
43113:     LOG(("nsHttpChannel::ProxyFailover [this=%p]\n", this));
43113: 
43113:     nsresult rv;
43113: 
43113:     nsCOMPtr<nsIProtocolProxyService> pps =
43113:             do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     nsCOMPtr<nsIProxyInfo> pi;
43113:     rv = pps->GetFailoverForProxy(mConnectionInfo->ProxyInfo(), mURI, mStatus,
43113:                                   getter_AddRefs(pi));
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     // XXXbz so where does this codepath remove us from the loadgroup,
43113:     // exactly?
48304:     return AsyncDoReplaceWithProxy(pi);
43113: }
43113: 
43113: void
43113: nsHttpChannel::HandleAsyncReplaceWithProxy()
43113: {
43113:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
43113: 
43113:     if (mSuspendCount) {
43113:         LOG(("Waiting until resume to do async proxy replacement [this=%p]\n",
43113:              this));
43113:         mPendingAsyncCallOnResume =
43113:             &nsHttpChannel::HandleAsyncReplaceWithProxy;
43113:         return;
43113:     }
43113: 
43113:     nsresult status = mStatus;
43113:     
43113:     nsCOMPtr<nsIProxyInfo> pi;
43113:     pi.swap(mTargetProxyInfo);
43113:     if (!mCanceled) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncReplaceWithProxy);
48304:         status = AsyncDoReplaceWithProxy(pi);
48304:         if (NS_SUCCEEDED(status))
48304:             return;
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueHandleAsyncReplaceWithProxy);
48304:     }
48304: 
48304:     if (NS_FAILED(status)) {
48304:         ContinueHandleAsyncReplaceWithProxy(status);
48304:     }
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueHandleAsyncReplaceWithProxy(nsresult status)
48304: {
43113:     if (mLoadGroup && NS_SUCCEEDED(status)) {
43113:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
43113:     }
48304:     else if (NS_FAILED(status)) {
43113:        AsyncAbort(status);
43113:     }
48304: 
48304:     // Return NS_OK here, even it seems to be breaking the async function stack
48304:     // contract (i.e. passing the result code to a function bellow).
48304:     // ContinueHandleAsyncReplaceWithProxy will always be at the bottom of the
48304:     // stack. If we would return the failure code, the async function stack
48304:     // logic would cancel the channel synchronously, which is undesired after
48304:     // invoking AsyncAbort above.
48304:     return NS_OK;
43113: }
43113: 
51363: void
51363: nsHttpChannel::HandleAsyncRedirectChannelToHttps()
51363: {
51363:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
51363: 
51363:     if (mSuspendCount) {
51363:         LOG(("Waiting until resume to do async redirect to https [this=%p]\n", this));
51363:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncRedirectChannelToHttps;
51363:         return;
51363:     }
51363: 
51363:     nsresult rv = AsyncRedirectChannelToHttps();
51363:     if (NS_FAILED(rv))
51363:         ContinueAsyncRedirectChannelToHttps(rv);
51363: }
51363: 
51363: nsresult
51363: nsHttpChannel::AsyncRedirectChannelToHttps()
51363: {
51363:     nsresult rv = NS_OK;
51363:     LOG(("nsHttpChannel::HandleAsyncRedirectChannelToHttps() [STS]\n"));
51363: 
51363:     nsCOMPtr<nsIChannel> newChannel;
51363:     nsCOMPtr<nsIURI> upgradedURI;
51363: 
51363:     rv = mURI->Clone(getter_AddRefs(upgradedURI));
51363:     NS_ENSURE_SUCCESS(rv,rv);
51363: 
51363:     upgradedURI->SetScheme(NS_LITERAL_CSTRING("https"));
51363: 
51363:     PRInt32 oldPort = -1;
51363:     rv = mURI->GetPort(&oldPort);
51363:     if (NS_FAILED(rv)) return rv;
51363: 
51363:     // Keep any nonstandard ports so only the scheme is changed.
51363:     // For example:
51363:     //  http://foo.com:80 -> https://foo.com:443
51363:     //  http://foo.com:81 -> https://foo.com:81
51363: 
51363:     if (oldPort == 80 || oldPort == -1)
51363:         upgradedURI->SetPort(-1);
51363:     else
51363:         upgradedURI->SetPort(oldPort);
51363: 
51363:     nsCOMPtr<nsIIOService> ioService;
51363:     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     rv = ioService->NewChannelFromURI(upgradedURI, getter_AddRefs(newChannel));
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     rv = SetupReplacementChannel(upgradedURI, newChannel, PR_TRUE);
51363:     NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:     // Inform consumers about this fake redirect
51363:     mRedirectChannel = newChannel;
51363:     PRUint32 flags = nsIChannelEventSink::REDIRECT_PERMANENT;
51363: 
51363:     PushRedirectAsyncFunc(
51363:         &nsHttpChannel::ContinueAsyncRedirectChannelToHttps);
51363:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, flags);
51363: 
51363:     if (NS_SUCCEEDED(rv))
51363:         rv = WaitForRedirectCallback();
51363: 
51363:     if (NS_FAILED(rv)) {
51363:         AutoRedirectVetoNotifier notifier(this);
51363:         PopRedirectAsyncFunc(
51363:             &nsHttpChannel::ContinueAsyncRedirectChannelToHttps);
51363:     }
51363: 
51363:     return rv;
51363: }
51363: 
51363: nsresult
51363: nsHttpChannel::ContinueAsyncRedirectChannelToHttps(nsresult rv)
51363: {
51363:     AutoRedirectVetoNotifier notifier(this);
51363: 
51363:     if (NS_FAILED(rv)) {
51363:         // Fill the failure status here, the update to https had been vetoed
51363:         // but from the security reasons we have to discard the whole channel
51363:         // load.
51363:         mStatus = rv;
51363:     }
51363: 
51363:     if (mLoadGroup)
51363:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
51363: 
51363:     if (NS_FAILED(rv)) {
51363:         // We have to manually notify the listener because there is not any pump
51363:         // that would call our OnStart/StopRequest after resume from waiting for
51363:         // the redirect callback.
51363:         DoNotifyListener();
51363:         return rv;
51363:     }
51363: 
51363:     // Make sure to do this _after_ calling OnChannelRedirect
51363:     mRedirectChannel->SetOriginalURI(mOriginalURI);
51363: 
51363:     // And now, notify observers the deprecated way
51363:     nsCOMPtr<nsIHttpEventSink> httpEventSink;
51363:     GetCallback(httpEventSink);
51363:     if (httpEventSink) {
51363:         // NOTE: nsIHttpEventSink is only used for compatibility with pre-1.8
51363:         // versions.
51363:         rv = httpEventSink->OnRedirect(this, mRedirectChannel);
51363:         if (NS_FAILED(rv)) {
51363:             mStatus = rv;
51363:             DoNotifyListener();
51363:             return rv;
51363:         }
51363:     }
51363: 
51363:     // open new channel
51363:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
51363:     if (NS_FAILED(rv)) {
51363:         mStatus = rv;
51363:         DoNotifyListener();
51363:         return rv;
51363:     }
51363: 
51363:     mStatus = NS_BINDING_REDIRECTED;
51363: 
51363:     notifier.RedirectSucceeded();
51363: 
51363:     // disconnect from the old listeners...
51363:     mListener = nsnull;
51363:     mListenerContext = nsnull;
51363: 
51363:     // ...and the old callbacks
51363:     mCallbacks = nsnull;
51363:     mProgressSink = nsnull;
51363: 
51363:     return rv;
51363: }
51363: 
43113: nsresult
48304: nsHttpChannel::AsyncDoReplaceWithProxy(nsIProxyInfo* pi)
43113: {
48304:     LOG(("nsHttpChannel::AsyncDoReplaceWithProxy [this=%p pi=%p]", this, pi));
43113:     nsresult rv;
43113: 
43113:     nsCOMPtr<nsIChannel> newChannel;
43113:     rv = gHttpHandler->NewProxiedChannel(mURI, pi, getter_AddRefs(newChannel));
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     rv = SetupReplacementChannel(mURI, newChannel, PR_TRUE);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     // Inform consumers about this fake redirect
48304:     mRedirectChannel = newChannel;
43113:     PRUint32 flags = nsIChannelEventSink::REDIRECT_INTERNAL;
48304: 
48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueDoReplaceWithProxy);
48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, flags);
48304: 
48304:     if (NS_SUCCEEDED(rv))
48304:         rv = WaitForRedirectCallback();
48304: 
48304:     if (NS_FAILED(rv)) {
49375:         AutoRedirectVetoNotifier notifier(this);
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueDoReplaceWithProxy);
48304:     }
48304: 
48304:     return rv;
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueDoReplaceWithProxy(nsresult rv)
48304: {
49375:     AutoRedirectVetoNotifier notifier(this);
49375: 
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
48304: 
43113:     // Make sure to do this _after_ calling OnChannelRedirect
48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
43113: 
43113:     // open new channel
48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     mStatus = NS_BINDING_REDIRECTED;
43113: 
49375:     notifier.RedirectSucceeded();
49375: 
43113:     // disconnect from the old listeners...
43113:     mListener = nsnull;
43113:     mListenerContext = nsnull;
43113: 
43113:     // ...and the old callbacks
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ResolveProxy()
43113: {
43113:     LOG(("nsHttpChannel::ResolveProxy [this=%p]\n", this));
43113: 
43113:     nsresult rv;
43113: 
43113:     nsCOMPtr<nsIProtocolProxyService> pps =
43113:             do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     return pps->AsyncResolve(mURI, 0, this, getter_AddRefs(mProxyRequest));
43113: }
43113: 
43113: PRBool
43113: nsHttpChannel::ResponseWouldVary()
43113: {
43113:     PRBool result = PR_FALSE;
43113:     nsCAutoString buf, metaKey;
43113:     mCachedResponseHead->GetHeader(nsHttp::Vary, buf);
43113:     if (!buf.IsEmpty()) {
43113:         NS_NAMED_LITERAL_CSTRING(prefix, "request-");
43113: 
43113:         // enumerate the elements of the Vary header...
43113:         char *val = buf.BeginWriting(); // going to munge buf
43113:         char *token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
43113:         while (token) {
43113:             //
43113:             // if "*", then assume response would vary.  technically speaking,
43113:             // "Vary: header, *" is not permitted, but we allow it anyways.
43113:             //
43113:             // if the response depends on the value of the "Cookie" header, then
43113:             // bail since we do not store cookies in the cache.  this is done
43113:             // for the following reasons:
43113:             //
43113:             //   1- cookies can be very large in size
43113:             //
43113:             //   2- cookies may contain sensitive information.  (for parity with
43113:             //      out policy of not storing Set-cookie headers in the cache
43113:             //      meta data, we likewise do not want to store cookie headers
43113:             //      here.)
43113:             //
43113:             // this implementation is obviously not fully standards compliant, but
43113:             // it is perhaps most prudent given the above issues.
43113:             //
43113:             if ((*token == '*') || (PL_strcasecmp(token, "cookie") == 0)) {
43113:                 result = PR_TRUE;
43113:                 break;
43113:             }
43113:             else {
43113:                 // build cache meta data key...
43113:                 metaKey = prefix + nsDependentCString(token);
43113: 
43113:                 // check the last value of the given request header to see if it has
43113:                 // since changed.  if so, then indeed the cached response is invalid.
43113:                 nsXPIDLCString lastVal;
43113:                 mCacheEntry->GetMetaDataElement(metaKey.get(), getter_Copies(lastVal));
43113:                 if (lastVal) {
43113:                     nsHttpAtom atom = nsHttp::ResolveAtom(token);
43113:                     const char *newVal = mRequestHead.PeekHeader(atom);
43113:                     if (newVal && (strcmp(newVal, lastVal) != 0)) {
43113:                         result = PR_TRUE; // yes, response would vary
43113:                         break;
43113:                     }
43113:                 }
43113:                 
43113:                 // next token...
43113:                 token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
43113:             }
43113:         }
43113:     }
43113:     return result;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <byte-range>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpChannel::SetupByteRangeRequest(PRUint32 partialLen)
43113: {
43113:     // cached content has been found to be partial, add necessary request
43113:     // headers to complete cache entry.
43113: 
43113:     // use strongest validator available...
43113:     const char *val = mCachedResponseHead->PeekHeader(nsHttp::ETag);
43113:     if (!val)
43113:         val = mCachedResponseHead->PeekHeader(nsHttp::Last_Modified);
43113:     if (!val) {
43113:         // if we hit this code it means mCachedResponseHead->IsResumable() is
43113:         // either broken or not being called.
43113:         NS_NOTREACHED("no cache validator");
43113:         return NS_ERROR_FAILURE;
43113:     }
43113: 
43113:     char buf[32];
43113:     PR_snprintf(buf, sizeof(buf), "bytes=%u-", partialLen);
43113: 
43113:     mRequestHead.SetHeader(nsHttp::Range, nsDependentCString(buf));
43113:     mRequestHead.SetHeader(nsHttp::If_Range, nsDependentCString(val));
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::ProcessPartialContent()
43113: {
43113:     // ok, we've just received a 206
43113:     //
43113:     // we need to stream whatever data is in the cache out first, and then
43113:     // pick up whatever data is on the wire, writing it into the cache.
43113: 
43113:     LOG(("nsHttpChannel::ProcessPartialContent [this=%p]\n", this)); 
43113: 
43113:     NS_ENSURE_TRUE(mCachedResponseHead, NS_ERROR_NOT_INITIALIZED);
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_INITIALIZED);
43113: 
43113:     // Make sure to clear bogus content-encodings before looking at the header
43113:     ClearBogusContentEncodingIfNeeded();
43113:     
43113:     // Check if the content-encoding we now got is different from the one we
43113:     // got before
43113:     if (PL_strcasecmp(mResponseHead->PeekHeader(nsHttp::Content_Encoding),
43113:                       mCachedResponseHead->PeekHeader(nsHttp::Content_Encoding))
43113:                       != 0) {
43113:         Cancel(NS_ERROR_INVALID_CONTENT_ENCODING);
43113:         return CallOnStartRequest();
43113:     }
43113: 
43113: 
43113:     // suspend the current transaction
43113:     nsresult rv = mTransactionPump->Suspend();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // merge any new headers with the cached response headers
43113:     rv = mCachedResponseHead->UpdateHeaders(mResponseHead->Headers());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // update the cached response head
43113:     nsCAutoString head;
43113:     mCachedResponseHead->Flatten(head, PR_TRUE);
43113:     rv = mCacheEntry->SetMetaDataElement("response-head", head.get());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // make the cached response be the current response
43113:     mResponseHead = mCachedResponseHead;
43113: 
43113:     rv = UpdateExpirationTime();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // notify observers interested in looking at a response that has been
43113:     // merged with any cached headers (http-on-examine-merged-response).
43113:     gHttpHandler->OnExamineMergedResponse(this);
43113: 
43113:     // the cached content is valid, although incomplete.
43113:     mCachedContentIsValid = PR_TRUE;
43113:     return ReadFromCache();
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::OnDoneReadingPartialCacheEntry(PRBool *streamDone)
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::OnDoneReadingPartialCacheEntry [this=%p]", this));
43113: 
43113:     // by default, assume we would have streamed all data or failed...
43113:     *streamDone = PR_TRUE;
43113: 
43113:     // setup cache listener to append to cache entry
43113:     PRUint32 size;
43113:     rv = mCacheEntry->GetDataSize(&size);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = InstallCacheListener(size);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // need to track the logical offset of the data being sent to our listener
43113:     mLogicalOffset = size;
43113: 
43113:     // we're now completing the cached content, so we can clear this flag.
43113:     // this puts us in the state of a regular download.
43113:     mCachedContentIsPartial = PR_FALSE;
43113: 
43113:     // resume the transaction if it exists, otherwise the pipe contained the
43113:     // remaining part of the document and we've now streamed all of the data.
43113:     if (mTransactionPump) {
43113:         rv = mTransactionPump->Resume();
43113:         if (NS_SUCCEEDED(rv))
43113:             *streamDone = PR_FALSE;
43113:     }
43113:     else
43113:         NS_NOTREACHED("no transaction");
43113:     return rv;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <cache>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpChannel::ProcessNotModified()
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::ProcessNotModified [this=%p]\n", this)); 
43113: 
43113:     if (mCustomConditionalRequest) {
43113:         LOG(("Bypassing ProcessNotModified due to custom conditional headers")); 
43113:         return NS_ERROR_FAILURE;
43113:     }
43113: 
43113:     NS_ENSURE_TRUE(mCachedResponseHead, NS_ERROR_NOT_INITIALIZED);
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_INITIALIZED);
43113: 
43113:     // merge any new headers with the cached response headers
43113:     rv = mCachedResponseHead->UpdateHeaders(mResponseHead->Headers());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // update the cached response head
43113:     nsCAutoString head;
43113:     mCachedResponseHead->Flatten(head, PR_TRUE);
43113:     rv = mCacheEntry->SetMetaDataElement("response-head", head.get());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // make the cached response be the current response
43113:     mResponseHead = mCachedResponseHead;
43113: 
43113:     rv = UpdateExpirationTime();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // notify observers interested in looking at a reponse that has been
43113:     // merged with any cached headers
43113:     gHttpHandler->OnExamineMergedResponse(this);
43113: 
43113:     mCachedContentIsValid = PR_TRUE;
43113:     rv = ReadFromCache();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mTransactionReplaced = PR_TRUE;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
48304: nsHttpChannel::ProcessFallback(PRBool *waitingForRedirectCallback)
43113: {
43113:     LOG(("nsHttpChannel::ProcessFallback [this=%p]\n", this));
43113:     nsresult rv;
43113: 
48304:     *waitingForRedirectCallback = PR_FALSE;
48304:     mFallingBack = PR_FALSE;
43113: 
43113:     // At this point a load has failed (either due to network problems
43113:     // or an error returned on the server).  Perform an application
43113:     // cache fallback if we have a URI to fall back to.
43113:     if (!mApplicationCache || mFallbackKey.IsEmpty() || mFallbackChannel) {
43113:         LOG(("  choosing not to fallback [%p,%s,%d]",
43113:              mApplicationCache.get(), mFallbackKey.get(), mFallbackChannel));
43113:         return NS_OK;
43113:     }
43113: 
43113:     // Make sure the fallback entry hasn't been marked as a foreign
43113:     // entry.
43113:     PRUint32 fallbackEntryType;
43113:     rv = mApplicationCache->GetTypes(mFallbackKey, &fallbackEntryType);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     if (fallbackEntryType & nsIApplicationCache::ITEM_FOREIGN) {
43113:         // This cache points to a fallback that refers to a different
43113:         // manifest.  Refuse to fall back.
43113:         return NS_OK;
43113:     }
43113: 
43113:     NS_ASSERTION(fallbackEntryType & nsIApplicationCache::ITEM_FALLBACK,
43113:                  "Fallback entry not marked correctly!");
43113: 
43113:     // Kill any opportunistic cache entry, and disable opportunistic
43113:     // caching for the fallback.
43113:     if (mOfflineCacheEntry) {
43113:         mOfflineCacheEntry->Doom();
43113:         mOfflineCacheEntry = 0;
43113:         mOfflineCacheAccess = 0;
43113:     }
43113: 
43113:     mCacheForOfflineUse = PR_FALSE;
43113:     mCachingOpportunistically = PR_FALSE;
43113:     mOfflineCacheClientID.Truncate();
43113:     mOfflineCacheEntry = 0;
43113:     mOfflineCacheAccess = 0;
43113: 
43113:     // Close the current cache entry.
43113:     if (mCacheEntry)
43113:         CloseCacheEntry(PR_TRUE);
43113: 
43113:     // Create a new channel to load the fallback entry.
43113:     nsRefPtr<nsIChannel> newChannel;
43113:     rv = gHttpHandler->NewChannel(mURI, getter_AddRefs(newChannel));
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     rv = SetupReplacementChannel(mURI, newChannel, PR_TRUE);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     // Make sure the new channel loads from the fallback key.
43113:     nsCOMPtr<nsIHttpChannelInternal> httpInternal =
43113:         do_QueryInterface(newChannel, &rv);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     rv = httpInternal->SetupFallbackChannel(mFallbackKey.get());
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     // ... and fallbacks should only load from the cache.
43113:     PRUint32 newLoadFlags = mLoadFlags | LOAD_REPLACE | LOAD_ONLY_FROM_CACHE;
43113:     rv = newChannel->SetLoadFlags(newLoadFlags);
43113: 
43113:     // Inform consumers about this fake redirect
48304:     mRedirectChannel = newChannel;
43113:     PRUint32 redirectFlags = nsIChannelEventSink::REDIRECT_INTERNAL;
48304: 
48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessFallback);
48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, redirectFlags);
48304: 
48304:     if (NS_SUCCEEDED(rv))
48304:         rv = WaitForRedirectCallback();
48304: 
48304:     if (NS_FAILED(rv)) {
49375:         AutoRedirectVetoNotifier notifier(this);
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessFallback);
48304:         return rv;
48304:     }
48304: 
48304:     // Indicate we are now waiting for the asynchronous redirect callback
48304:     // if all went OK.
48304:     *waitingForRedirectCallback = PR_TRUE;
48304:     return NS_OK;
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueProcessFallback(nsresult rv)
48304: {
49375:     AutoRedirectVetoNotifier notifier(this);
49375: 
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
48304: 
43113:     // Make sure to do this _after_ calling OnChannelRedirect
48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
48304: 
48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
49375:     if (NS_FAILED(rv))
49375:         return rv;
43113: 
43113:     // close down this channel
43113:     Cancel(NS_BINDING_REDIRECTED);
43113: 
49375:     notifier.RedirectSucceeded();
49375: 
43113:     // disconnect from our listener
43113:     mListener = 0;
43113:     mListenerContext = 0;
49375: 
43113:     // and from our callbacks
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113: 
48304:     mFallingBack = PR_TRUE;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: // Determines if a request is a byte range request for a subrange,
43113: // i.e. is a byte range request, but not a 0- byte range request.
43113: static PRBool
43113: IsSubRangeRequest(nsHttpRequestHead &aRequestHead)
43113: {
43113:     if (!aRequestHead.PeekHeader(nsHttp::Range))
43113:         return PR_FALSE;
43113:     nsCAutoString byteRange;
43113:     aRequestHead.GetHeader(nsHttp::Range, byteRange);
43113:     return !byteRange.EqualsLiteral("bytes=0-");
43113: }
43113: 
43113: nsresult
53987: nsHttpChannel::OpenCacheEntry()
43113: {
43113:     nsresult rv;
43113: 
53987:     mAsyncCacheOpen = PR_FALSE;
43113:     mLoadedFromApplicationCache = PR_FALSE;
43113: 
43113:     LOG(("nsHttpChannel::OpenCacheEntry [this=%p]", this));
43113: 
43113:     // make sure we're not abusing this function
43113:     NS_PRECONDITION(!mCacheEntry, "cache entry already open");
43113: 
43113:     nsCAutoString cacheKey;
43113: 
43113:     if (mRequestHead.Method() == nsHttp::Post) {
43113:         // If the post id is already set then this is an attempt to replay
43113:         // a post transaction via the cache.  Otherwise, we need a unique
43113:         // post id for this transaction.
43113:         if (mPostID == 0)
43113:             mPostID = gHttpHandler->GenerateUniqueID();
43113:     }
43113:     else if ((mRequestHead.Method() != nsHttp::Get) &&
52358:              (mRequestHead.Method() != nsHttp::Head) &&
52358:              (!(mLoadFlags & FORCE_OPEN_CACHE_ENTRY))) {
43113:         // don't use the cache for other types of requests
43113:         return NS_OK;
43113:     }
43113: 
43113:     if (mResuming) {
43113:         // We don't support caching for requests initiated
43113:         // via nsIResumableChannel.
43113:         return NS_OK;
43113:     }
43113: 
43113:     // Don't cache byte range requests which are subranges, only cache 0-
43113:     // byte range requests.
43113:     if (IsSubRangeRequest(mRequestHead))
43113:         return NS_OK;
43113: 
43113:     GenerateCacheKey(mPostID, cacheKey);
43113: 
43113:     // Set the desired cache access mode accordingly...
43113:     nsCacheAccessMode accessRequested;
53987:     rv = DetermineCacheAccess(&accessRequested);
53987:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     if (!mApplicationCache && mInheritApplicationCache) {
43113:         // Pick up an application cache from the notification
43113:         // callbacks if available
43113:         nsCOMPtr<nsIApplicationCacheContainer> appCacheContainer;
43113:         GetCallback(appCacheContainer);
43113: 
43113:         if (appCacheContainer) {
43113:             appCacheContainer->GetApplicationCache(getter_AddRefs(mApplicationCache));
43113:         }
43113:     }
43113: 
43113:     if (!mApplicationCache &&
43113:         (mChooseApplicationCache || (mLoadFlags & LOAD_CHECK_OFFLINE_CACHE))) {
43113:         // We're supposed to load from an application cache, but
43113:         // one was not supplied by the load group.  Ask the
43113:         // application cache service to choose one for us.
43113:         nsCOMPtr<nsIApplicationCacheService> appCacheService =
43113:             do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
43113:         if (appCacheService) {
43113:             nsresult rv = appCacheService->ChooseApplicationCache
43113:                 (cacheKey, getter_AddRefs(mApplicationCache));
43113:             NS_ENSURE_SUCCESS(rv, rv);
43113:         }
43113:     }
43113: 
43113:     nsCOMPtr<nsICacheSession> session;
43113: 
43113:     // If we have an application cache, we check it first.
43113:     if (mApplicationCache) {
43113:         nsCAutoString appCacheClientID;
43113:         mApplicationCache->GetClientID(appCacheClientID);
43113: 
43113:         nsCOMPtr<nsICacheService> serv =
43113:             do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         rv = serv->CreateSession(appCacheClientID.get(),
43113:                                  nsICache::STORE_OFFLINE,
43113:                                  nsICache::STREAM_BASED,
43113:                                  getter_AddRefs(session));
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
53987:         if (mLoadFlags & LOAD_BYPASS_LOCAL_CACHE_IF_BUSY) {
53987:             // must use synchronous open for LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
53987:             rv = session->OpenCacheEntry(cacheKey,
53987:                                          nsICache::ACCESS_READ, PR_FALSE,
53987:                                          getter_AddRefs(mCacheEntry));
53987:             if (NS_SUCCEEDED(rv)) {
53987:                 mCacheEntry->GetAccessGranted(&mCacheAccess);
53987:                 LOG(("nsHttpChannel::OpenCacheEntry [this=%p grantedAccess=%d]",
53987:                     this, mCacheAccess));
53987:                 mLoadedFromApplicationCache = PR_TRUE;
53987:                 return NS_OK;
53987:             } else if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
53987:                 LOG(("bypassing local cache since it is busy\n"));
53987:                 // Don't try to load normal cache entry
53987:                 return NS_ERROR_NOT_AVAILABLE;
53987:             }
53987:         } else {
53987:             mOnCacheEntryAvailableCallback =
53987:                 &nsHttpChannel::OnOfflineCacheEntryAvailable;
43113:             // We open with ACCESS_READ only, because we don't want to
43113:             // overwrite the offline cache entry non-atomically.
43113:             // ACCESS_READ will prevent us from writing to the offline
43113:             // cache as a normal cache entry.
53987:             rv = session->AsyncOpenCacheEntry(cacheKey,
53987:                                               nsICache::ACCESS_READ,
53987:                                               this);
53987: 
53987:             if (NS_SUCCEEDED(rv)) {
53987:                 mAsyncCacheOpen = PR_TRUE;
53987:                 return NS_OK;
53987:             }
53987:         }
53987: 
53987:         // sync or async opening failed
53987:         return OnOfflineCacheEntryAvailable(nsnull, nsICache::ACCESS_NONE,
53987:                                             rv, PR_TRUE);
53987:     }
53987: 
53987:     return OpenNormalCacheEntry(PR_TRUE);
53987: }
53987: 
53987: nsresult
53987: nsHttpChannel::OnOfflineCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
53987:                                             nsCacheAccessMode aAccess,
53987:                                             nsresult aEntryStatus,
53987:                                             PRBool aIsSync)
53987: {
53987:     nsresult rv;
53987: 
53987:     if (NS_SUCCEEDED(aEntryStatus)) {
53987:         // We successfully opened an offline cache session and the entry,
53987:         // so indicate we will load from the offline cache.
53987:         mLoadedFromApplicationCache = PR_TRUE;
53987:         mCacheEntry = aEntry;
53987:         mCacheAccess = aAccess;
53987:     }
53987: 
53987:     if (mCanceled && NS_FAILED(mStatus)) {
53987:         LOG(("channel was canceled [this=%p status=%x]\n", this, mStatus));
53987:         return mStatus;
53987:     }
53987: 
53987:     if (NS_SUCCEEDED(aEntryStatus))
53987:         // Called from OnCacheEntryAvailable, advance to the next state
53987:         return Connect(PR_FALSE);
53987: 
53987:     if (!mCacheForOfflineUse && !mFallbackChannel) {
53987:         nsCAutoString cacheKey;
53987:         GenerateCacheKey(mPostID, cacheKey);
53987: 
43113:         // Check for namespace match.
43113:         nsCOMPtr<nsIApplicationCacheNamespace> namespaceEntry;
43113:         rv = mApplicationCache->GetMatchingNamespace
43113:             (cacheKey, getter_AddRefs(namespaceEntry));
53987:         if (NS_FAILED(rv) && !aIsSync)
53987:             return Connect(PR_FALSE);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         PRUint32 namespaceType = 0;
43113:         if (!namespaceEntry ||
43113:             NS_FAILED(namespaceEntry->GetItemType(&namespaceType)) ||
43113:             (namespaceType &
43113:              (nsIApplicationCacheNamespace::NAMESPACE_FALLBACK |
43113:               nsIApplicationCacheNamespace::NAMESPACE_OPPORTUNISTIC |
43113:               nsIApplicationCacheNamespace::NAMESPACE_BYPASS)) == 0) {
43113:             // When loading from an application cache, only items
43113:             // on the whitelist or matching a
43113:             // fallback/opportunistic namespace should hit the
43113:             // network...
43113:             mLoadFlags |= LOAD_ONLY_FROM_CACHE;
43113: 
43113:             // ... and if there were an application cache entry,
43113:             // we would have found it earlier.
53987:             return aIsSync ? NS_ERROR_CACHE_KEY_NOT_FOUND : Connect(PR_FALSE);
43113:         }
43113: 
43113:         if (namespaceType &
43113:             nsIApplicationCacheNamespace::NAMESPACE_FALLBACK) {
43113:             rv = namespaceEntry->GetData(mFallbackKey);
53987:             if (NS_FAILED(rv) && !aIsSync)
53987:                 return Connect(PR_FALSE);
43113:             NS_ENSURE_SUCCESS(rv, rv);
43113:         }
43113: 
43113:         if ((namespaceType &
43113:              nsIApplicationCacheNamespace::NAMESPACE_OPPORTUNISTIC) &&
43113:             mLoadFlags & LOAD_DOCUMENT_URI) {
43113:             // Document loads for items in an opportunistic namespace
43113:             // should be placed in the offline cache.
43113:             nsCString clientID;
43113:             mApplicationCache->GetClientID(clientID);
43113: 
43113:             mCacheForOfflineUse = !clientID.IsEmpty();
43113:             SetOfflineCacheClientID(clientID);
43113:             mCachingOpportunistically = PR_TRUE;
43113:         }
43113:     }
53987: 
53987:     return OpenNormalCacheEntry(aIsSync);
53987: }
53987: 
53987: 
53987: nsresult
53987: nsHttpChannel::OpenNormalCacheEntry(PRBool aIsSync)
53987: {
53987:     NS_ASSERTION(!mCacheEntry, "We have already mCacheEntry");
53987: 
53987:     nsresult rv;
53987: 
53987:     nsCAutoString cacheKey;
53987:     GenerateCacheKey(mPostID, cacheKey);
53987: 
53987:     nsCacheStoragePolicy storagePolicy = DetermineStoragePolicy();
53987: 
53987:     nsCOMPtr<nsICacheSession> session;
43113:     rv = gHttpHandler->GetCacheSession(storagePolicy,
43113:                                        getter_AddRefs(session));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
53987:     nsCacheAccessMode accessRequested;
53987:     rv = DetermineCacheAccess(&accessRequested);
53987:     if (NS_FAILED(rv)) return rv;
53987: 
53987:     if (mLoadFlags & LOAD_BYPASS_LOCAL_CACHE_IF_BUSY) {
53987:         if (!aIsSync) {
53987:             // Unexpected state: we were called from OnCacheEntryAvailable(),
53987:             // so LOAD_BYPASS_LOCAL_CACHE_IF_BUSY shouldn't be set. Unless
53987:             // somebody altered mLoadFlags between OpenCacheEntry() and
53987:             // OnCacheEntryAvailable()...
53987:             NS_WARNING(
53987:                 "OpenNormalCacheEntry() called from OnCacheEntryAvailable() "
53987:                 "when LOAD_BYPASS_LOCAL_CACHE_IF_BUSY was specified");
53987:         }
53987: 
53987:         // must use synchronous open for LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
43113:         rv = session->OpenCacheEntry(cacheKey, accessRequested, PR_FALSE,
43113:                                      getter_AddRefs(mCacheEntry));
53987:         if (NS_SUCCEEDED(rv)) {
53987:             mCacheEntry->GetAccessGranted(&mCacheAccess);
53987:             LOG(("nsHttpChannel::OpenCacheEntry [this=%p grantedAccess=%d]",
53987:                 this, mCacheAccess));
53987:         }
53987:         else if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
51890:             LOG(("bypassing local cache since it is busy\n"));
53987:             rv = NS_ERROR_NOT_AVAILABLE;
53987:         }
53987:     }
53987:     else {
53987:         mOnCacheEntryAvailableCallback =
53987:             &nsHttpChannel::OnNormalCacheEntryAvailable;
51890:         rv = session->AsyncOpenCacheEntry(cacheKey, accessRequested, this);
53987:         if (NS_SUCCEEDED(rv)) {
53987:             mAsyncCacheOpen = PR_TRUE;
53987:             return NS_OK;
53987:         }
53987:     }
53987: 
53987:     if (!aIsSync)
53987:         // Called from OnCacheEntryAvailable, advance to the next state
53987:         rv = Connect(PR_FALSE);
53987: 
43113:     return rv;
43113: }
43113: 
53987: nsresult
53987: nsHttpChannel::OnNormalCacheEntryAvailable(nsICacheEntryDescriptor *aEntry,
53987:                                            nsCacheAccessMode aAccess,
53987:                                            nsresult aEntryStatus,
53987:                                            PRBool aIsSync)
53987: {
53987:     NS_ASSERTION(!aIsSync, "aIsSync should be false");
53987: 
53987:     if (NS_SUCCEEDED(aEntryStatus)) {
53987:         mCacheEntry = aEntry;
53987:         mCacheAccess = aAccess;
53987:     }
53987: 
53987:     if (mCanceled && NS_FAILED(mStatus)) {
53987:         LOG(("channel was canceled [this=%p status=%x]\n", this, mStatus));
53987:         return mStatus;
53987:     }
53987: 
53987:     if ((mLoadFlags & LOAD_ONLY_FROM_CACHE) && NS_FAILED(aEntryStatus))
53987:         // if this channel is only allowed to pull from the cache, then
53987:         // we must fail if we were unable to open a cache entry.
53987:         return NS_ERROR_DOCUMENT_NOT_CACHED;
53987: 
53987:     // advance to the next state...
53987:     return Connect(PR_FALSE);
53987: }
53987: 
43113: 
43113: nsresult
43113: nsHttpChannel::OpenOfflineCacheEntryForWriting()
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::OpenOfflineCacheEntryForWriting [this=%p]", this));
43113: 
43113:     // make sure we're not abusing this function
43113:     NS_PRECONDITION(!mOfflineCacheEntry, "cache entry already open");
43113: 
43113:     PRBool offline = gIOService->IsOffline();
43113:     if (offline) {
43113:         // only put things in the offline cache while online
43113:         return NS_OK;
43113:     }
43113: 
43113:     if (mRequestHead.Method() != nsHttp::Get) {
43113:         // only cache complete documents offline
43113:         return NS_OK;
43113:     }
43113: 
43113:     // Don't cache byte range requests which are subranges, only cache 0-
43113:     // byte range requests.
43113:     if (IsSubRangeRequest(mRequestHead))
43113:         return NS_OK;
43113: 
43113:     nsCAutoString cacheKey;
43113:     GenerateCacheKey(mPostID, cacheKey);
43113: 
43113:     NS_ENSURE_TRUE(!mOfflineCacheClientID.IsEmpty(),
43113:                    NS_ERROR_NOT_AVAILABLE);
43113: 
43113:     nsCOMPtr<nsICacheSession> session;
43113:     nsCOMPtr<nsICacheService> serv =
43113:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = serv->CreateSession(mOfflineCacheClientID.get(),
43113:                              nsICache::STORE_OFFLINE,
43113:                              nsICache::STREAM_BASED,
43113:                              getter_AddRefs(session));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = session->OpenCacheEntry(cacheKey, nsICache::ACCESS_READ_WRITE,
43113:                                  PR_FALSE, getter_AddRefs(mOfflineCacheEntry));
43113: 
43113:     if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
43113:         // access to the cache entry has been denied (because the cache entry
43113:         // is probably in use by another channel).  Either the cache is being
43113:         // read from (we're offline) or it's being updated elsewhere.
43113:         return NS_OK;
43113:     }
43113: 
43113:     if (NS_SUCCEEDED(rv)) {
43113:         mOfflineCacheEntry->GetAccessGranted(&mOfflineCacheAccess);
43113:         LOG(("got offline cache entry [access=%x]\n", mOfflineCacheAccess));
43113:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::GenerateCacheKey(PRUint32 postID, nsACString &cacheKey)
43113: {
43113:     cacheKey.Truncate();
43113: 
43113:     if (mLoadFlags & LOAD_ANONYMOUS) {
43113:       cacheKey.AssignLiteral("anon&");
43113:     }
43113: 
43113:     if (postID) {
43113:         char buf[32];
43113:         PR_snprintf(buf, sizeof(buf), "id=%x&", postID);
43113:         cacheKey.Append(buf);
43113:     }
43113: 
43113:     if (!cacheKey.IsEmpty()) {
43113:       cacheKey.AppendLiteral("uri=");
43113:     }
43113: 
43113:     // Strip any trailing #ref from the URL before using it as the key
43113:     const char *spec = mFallbackChannel ? mFallbackKey.get() : mSpec.get();
43113:     const char *p = strchr(spec, '#');
43113:     if (p)
43113:         cacheKey.Append(spec, p - spec);
43113:     else
43113:         cacheKey.Append(spec);
43113:     return NS_OK;
43113: }
43113: 
43113: // UpdateExpirationTime is called when a new response comes in from the server.
43113: // It updates the stored response-time and sets the expiration time on the
43113: // cache entry.  
43113: //
43113: // From section 13.2.4 of RFC2616, we compute expiration time as follows:
43113: //
43113: //    timeRemaining = freshnessLifetime - currentAge
43113: //    expirationTime = now + timeRemaining
43113: // 
43113: nsresult
43113: nsHttpChannel::UpdateExpirationTime()
43113: {
43113:     NS_ENSURE_TRUE(mResponseHead, NS_ERROR_FAILURE);
43113: 
43113:     nsresult rv;
43113: 
43113:     PRUint32 expirationTime = 0;
43113:     if (!mResponseHead->MustValidate()) {
43113:         PRUint32 freshnessLifetime = 0;
43113: 
43113:         rv = mResponseHead->ComputeFreshnessLifetime(&freshnessLifetime);
43113:         if (NS_FAILED(rv)) return rv;
43113: 
43113:         if (freshnessLifetime > 0) {
43113:             PRUint32 now = NowInSeconds(), currentAge = 0;
43113: 
43113:             rv = mResponseHead->ComputeCurrentAge(now, mRequestTime, &currentAge); 
43113:             if (NS_FAILED(rv)) return rv;
43113: 
43113:             LOG(("freshnessLifetime = %u, currentAge = %u\n",
43113:                 freshnessLifetime, currentAge));
43113: 
43113:             if (freshnessLifetime > currentAge) {
43113:                 PRUint32 timeRemaining = freshnessLifetime - currentAge;
43113:                 // be careful... now + timeRemaining may overflow
43113:                 if (now + timeRemaining < now)
43113:                     expirationTime = PRUint32(-1);
43113:                 else
43113:                     expirationTime = now + timeRemaining;
43113:             }
43113:             else
43113:                 expirationTime = now;
43113:         }
43113:     }
43113: 
43113:     rv = mCacheEntry->SetExpirationTime(expirationTime);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     if (mOfflineCacheEntry) {
43113:         rv = mOfflineCacheEntry->SetExpirationTime(expirationTime);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: // CheckCache is called from Connect after a cache entry has been opened for
43113: // this URL but before going out to net.  It's purpose is to set or clear the 
43113: // mCachedContentIsValid flag, and to configure an If-Modified-Since request
43113: // if validation is required.
43113: nsresult
43113: nsHttpChannel::CheckCache()
43113: {
43113:     nsresult rv = NS_OK;
43113: 
43113:     LOG(("nsHTTPChannel::CheckCache enter [this=%p entry=%p access=%d]",
43113:         this, mCacheEntry.get(), mCacheAccess));
43113:     
43113:     // Be pessimistic: assume the cache entry has no useful data.
43113:     mCachedContentIsValid = PR_FALSE;
43113: 
43113:     // Don't proceed unless we have opened a cache entry for reading.
43113:     if (!mCacheEntry || !(mCacheAccess & nsICache::ACCESS_READ))
43113:         return NS_OK;
43113: 
43113:     nsXPIDLCString buf;
43113: 
43113:     // Get the method that was used to generate the cached response
43113:     rv = mCacheEntry->GetMetaDataElement("request-method", getter_Copies(buf));
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     nsHttpAtom method = nsHttp::ResolveAtom(buf);
43113:     if (method == nsHttp::Head) {
43113:         // The cached response does not contain an entity.  We can only reuse
43113:         // the response if the current request is also HEAD.
43113:         if (mRequestHead.Method() != nsHttp::Head)
43113:             return NS_OK;
43113:     }
43113:     buf.Adopt(0);
43113: 
43113:     // We'll need this value in later computations...
43113:     PRUint32 lastModifiedTime;
43113:     rv = mCacheEntry->GetLastModified(&lastModifiedTime);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     // Determine if this is the first time that this cache entry
43113:     // has been accessed during this session.
43113:     PRBool fromPreviousSession =
43113:             (gHttpHandler->SessionStartTime() > lastModifiedTime);
43113: 
43113:     // Get the cached HTTP response headers
43113:     rv = mCacheEntry->GetMetaDataElement("response-head", getter_Copies(buf));
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     // Parse the cached HTTP response headers
43113:     mCachedResponseHead = new nsHttpResponseHead();
43113:     if (!mCachedResponseHead)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     rv = mCachedResponseHead->Parse((char *) buf.get());
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113:     buf.Adopt(0);
43113: 
43113:     // Don't bother to validate items that are read-only,
43113:     // unless they are read-only because of INHIBIT_CACHING or because
43113:     // we're updating the offline cache.
43113:     // Don't bother to validate if this is a fallback entry.
43113:     if (!mCacheForOfflineUse &&
43113:         (mLoadedFromApplicationCache ||
43113:          (mCacheAccess == nsICache::ACCESS_READ &&
43113:           !(mLoadFlags & INHIBIT_CACHING)) ||
43113:          mFallbackChannel)) {
43113:         mCachedContentIsValid = PR_TRUE;
43113:         return NS_OK;
43113:     }
43113: 
43113:     PRUint16 isCachedRedirect = mCachedResponseHead->Status()/100 == 3;
43113: 
43113:     if (method != nsHttp::Head && !isCachedRedirect) {
43113:         // If the cached content-length is set and it does not match the data
43113:         // size of the cached content, then the cached response is partial...
43113:         // either we need to issue a byte range request or we need to refetch
43113:         // the entire document.
51740:         nsInt64 contentLength = mCachedResponseHead->ContentLength();
51740:         if (contentLength != nsInt64(-1)) {
43113:             PRUint32 size;
43113:             rv = mCacheEntry->GetDataSize(&size);
43113:             NS_ENSURE_SUCCESS(rv, rv);
43113: 
51740:             if (nsInt64(size) != contentLength) {
43113:                 LOG(("Cached data size does not match the Content-Length header "
51740:                      "[content-length=%lld size=%u]\n", PRInt64(contentLength), size));
51740:                 if ((nsInt64(size) < contentLength) && mCachedResponseHead->IsResumable()) {
43113:                     // looks like a partial entry.
43113:                     rv = SetupByteRangeRequest(size);
43113:                     NS_ENSURE_SUCCESS(rv, rv);
43113:                     mCachedContentIsPartial = PR_TRUE;
43113:                 }
43113:                 return NS_OK;
43113:             }
43113:         }
43113:     }
43113: 
43113:     PRBool doValidation = PR_FALSE;
43113:     PRBool canAddImsHeader = PR_TRUE;
43113: 
43113:     mCustomConditionalRequest = 
43113:         mRequestHead.PeekHeader(nsHttp::If_Modified_Since) ||
43113:         mRequestHead.PeekHeader(nsHttp::If_None_Match) ||
43113:         mRequestHead.PeekHeader(nsHttp::If_Unmodified_Since) ||
43113:         mRequestHead.PeekHeader(nsHttp::If_Match) ||
43113:         mRequestHead.PeekHeader(nsHttp::If_Range);
43113: 
43113:     // If the LOAD_FROM_CACHE flag is set, any cached data can simply be used.
43113:     if (mLoadFlags & LOAD_FROM_CACHE) {
43113:         LOG(("NOT validating based on LOAD_FROM_CACHE load flag\n"));
43113:         doValidation = PR_FALSE;
43113:     }
43113:     // If the VALIDATE_ALWAYS flag is set, any cached data won't be used until
43113:     // it's revalidated with the server.
43113:     else if (mLoadFlags & VALIDATE_ALWAYS) {
43113:         LOG(("Validating based on VALIDATE_ALWAYS load flag\n"));
43113:         doValidation = PR_TRUE;
43113:     }
43113:     // Even if the VALIDATE_NEVER flag is set, there are still some cases in
43113:     // which we must validate the cached response with the server.
43113:     else if (mLoadFlags & VALIDATE_NEVER) {
43113:         LOG(("VALIDATE_NEVER set\n"));
43113:         // if no-store or if no-cache and ssl, validate cached response (see
43113:         // bug 112564 for an explanation of this logic)
43113:         if (mCachedResponseHead->NoStore() ||
43113:            (mCachedResponseHead->NoCache() && mConnectionInfo->UsingSSL())) {
43113:             LOG(("Validating based on (no-store || (no-cache && ssl)) logic\n"));
43113:             doValidation = PR_TRUE;
43113:         }
43113:         else {
43113:             LOG(("NOT validating based on VALIDATE_NEVER load flag\n"));
43113:             doValidation = PR_FALSE;
43113:         }
43113:     }
43113:     // check if validation is strictly required...
43113:     else if (mCachedResponseHead->MustValidate()) {
43113:         LOG(("Validating based on MustValidate() returning TRUE\n"));
43113:         doValidation = PR_TRUE;
43113:     }
43113: 
43113:     else if (ResponseWouldVary()) {
43113:         LOG(("Validating based on Vary headers returning TRUE\n"));
43113:         canAddImsHeader = PR_FALSE;
43113:         doValidation = PR_TRUE;
43113:     }
43113:     
43113:     else if (MustValidateBasedOnQueryUrl()) {
43113:         LOG(("Validating based on RFC 2616 section 13.9 "
43113:              "(query-url w/o explicit expiration-time)\n"));
43113:         doValidation = PR_TRUE;
43113:     }
43113:     // Check if the cache entry has expired...
43113:     else {
43113:         PRUint32 time = 0; // a temporary variable for storing time values...
43113: 
43113:         rv = mCacheEntry->GetExpirationTime(&time);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         if (NowInSeconds() <= time)
43113:             doValidation = PR_FALSE;
43113:         else if (mCachedResponseHead->MustValidateIfExpired())
43113:             doValidation = PR_TRUE;
43113:         else if (mLoadFlags & VALIDATE_ONCE_PER_SESSION) {
43113:             // If the cached response does not include expiration infor-
43113:             // mation, then we must validate the response, despite whether
43113:             // or not this is the first access this session.  This behavior
43113:             // is consistent with existing browsers and is generally expected
43113:             // by web authors.
43113:             rv = mCachedResponseHead->ComputeFreshnessLifetime(&time);
43113:             NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:             if (time == 0)
43113:                 doValidation = PR_TRUE;
43113:             else
43113:                 doValidation = fromPreviousSession;
43113:         }
43113:         else
43113:             doValidation = PR_TRUE;
43113: 
43113:         LOG(("%salidating based on expiration time\n", doValidation ? "V" : "Not v"));
43113:     }
43113: 
43113:     if (!doValidation && mRequestHead.PeekHeader(nsHttp::If_Match) &&
43113:         (method == nsHttp::Get || method == nsHttp::Head)) {
43113:         const char *requestedETag, *cachedETag;
43113:         cachedETag = mCachedResponseHead->PeekHeader(nsHttp::ETag);
43113:         requestedETag = mRequestHead.PeekHeader(nsHttp::If_Match);
43113:         if (cachedETag && (!strncmp(cachedETag, "W/", 2) ||
43113:             strcmp(requestedETag, cachedETag))) {
43113:             // User has defined If-Match header, if the cached entry is not 
43113:             // matching the provided header value or the cached ETag is weak,
43113:             // force validation.
43113:             doValidation = PR_TRUE;
43113:         }
43113:     }
43113: 
43113:     if (!doValidation) {
43113:         //
43113:         // Check the authorization headers used to generate the cache entry.
43113:         // We must validate the cache entry if:
43113:         //
43113:         // 1) the cache entry was generated prior to this session w/
43113:         //    credentials (see bug 103402).
43113:         // 2) the cache entry was generated w/o credentials, but would now
43113:         //    require credentials (see bug 96705).
43113:         //
43113:         // NOTE: this does not apply to proxy authentication.
43113:         //
43113:         mCacheEntry->GetMetaDataElement("auth", getter_Copies(buf));
43113:         doValidation =
43113:             (fromPreviousSession && !buf.IsEmpty()) ||
43113:             (buf.IsEmpty() && mRequestHead.PeekHeader(nsHttp::Authorization));
43113:     }
43113: 
43113:     if (!doValidation) {
43113:         // Sites redirect back to the original URI after setting a session/tracking
43113:         // cookie. In such cases, force revalidation so that we hit the net and do not
43113:         // cycle thru cached responses.
43113:         if (isCachedRedirect && mRequestHead.PeekHeader(nsHttp::Cookie))
43113:             doValidation = PR_TRUE;
43113:     }
43113: 
43113:     mCachedContentIsValid = !doValidation;
43113: 
43113:     if (doValidation) {
43113:         //
43113:         // now, we are definitely going to issue a HTTP request to the server.
43113:         // make it conditional if possible.
43113:         //
43113:         // do not attempt to validate no-store content, since servers will not
43113:         // expect it to be cached.  (we only keep it in our cache for the
43113:         // purposes of back/forward, etc.)
43113:         //
43113:         // the request method MUST be either GET or HEAD (see bug 175641).
43113:         //
43113:         // do not override conditional headers when consumer has defined its own
43113:         if (!mCachedResponseHead->NoStore() &&
43113:             (mRequestHead.Method() == nsHttp::Get ||
43113:              mRequestHead.Method() == nsHttp::Head) &&
43113:              !mCustomConditionalRequest) {
43113:             const char *val;
43113:             // Add If-Modified-Since header if a Last-Modified was given
43113:             // and we are allowed to do this (see bugs 510359 and 269303)
43113:             if (canAddImsHeader) {
43113:                 val = mCachedResponseHead->PeekHeader(nsHttp::Last_Modified);
43113:                 if (val)
43113:                     mRequestHead.SetHeader(nsHttp::If_Modified_Since,
43113:                                            nsDependentCString(val));
43113:             }
43113:             // Add If-None-Match header if an ETag was given in the response
43113:             val = mCachedResponseHead->PeekHeader(nsHttp::ETag);
43113:             if (val)
43113:                 mRequestHead.SetHeader(nsHttp::If_None_Match,
43113:                                        nsDependentCString(val));
43113:         }
43113:     }
43113: 
43113:     LOG(("nsHTTPChannel::CheckCache exit [this=%p doValidation=%d]\n", this, doValidation));
43113:     return NS_OK;
43113: }
43113: 
43113: PRBool
43113: nsHttpChannel::MustValidateBasedOnQueryUrl()
43113: {
43113:     // RFC 2616, section 13.9 states that GET-requests with a query-url
43113:     // MUST NOT be treated as fresh unless the server explicitly provides
43113:     // an expiration-time in the response. See bug #468594
43113:     // Section 13.2.1 (6th paragraph) defines "explicit expiration time"
43113:     if (mRequestHead.Method() == nsHttp::Get)
43113:     {
43113:         nsCAutoString query;
43113:         nsCOMPtr<nsIURL> url = do_QueryInterface(mURI);
43113:         nsresult rv = url->GetQuery(query);
43113:         if (NS_SUCCEEDED(rv) && !query.IsEmpty()) {
43113:             PRUint32 tmp; // we don't need the value, just whether it's set
43113:             rv = mCachedResponseHead->GetExpiresValue(&tmp);
43113:             if (NS_FAILED(rv)) {
43113:                 rv = mCachedResponseHead->GetMaxAgeValue(&tmp);
43113:                 if (NS_FAILED(rv)) {
43113:                     return PR_TRUE;
43113:                 }
43113:             }
43113:         }
43113:     }
43113:     return PR_FALSE;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsHttpChannel::ShouldUpdateOfflineCacheEntry(PRBool *shouldCacheForOfflineUse)
43113: {
43113:     *shouldCacheForOfflineUse = PR_FALSE;
43113: 
43113:     if (!mOfflineCacheEntry) {
43113:         return NS_OK;
43113:     }
43113: 
43113:     // if we're updating the cache entry, update the offline cache entry too
43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE)) {
43113:         *shouldCacheForOfflineUse = PR_TRUE;
43113:         return NS_OK;
43113:     }
43113: 
43113:     // if there's nothing in the offline cache, add it
43113:     if (mOfflineCacheEntry && (mOfflineCacheAccess == nsICache::ACCESS_WRITE)) {
43113:         *shouldCacheForOfflineUse = PR_TRUE;
43113:         return NS_OK;
43113:     }
43113: 
43113:     // if the document is newer than the offline entry, update it
43113:     PRUint32 docLastModifiedTime;
43113:     nsresult rv = mResponseHead->GetLastModifiedValue(&docLastModifiedTime);
43113:     if (NS_FAILED(rv)) {
43113:         *shouldCacheForOfflineUse = PR_TRUE;
43113:         return NS_OK;
43113:     }
43113: 
43113:     PRUint32 offlineLastModifiedTime;
43113:     rv = mOfflineCacheEntry->GetLastModified(&offlineLastModifiedTime);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     if (docLastModifiedTime > offlineLastModifiedTime) {
43113:         *shouldCacheForOfflineUse = PR_TRUE;
43113:         return NS_OK;
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: // If the data in the cache hasn't expired, then there's no need to
43113: // talk with the server, not even to do an if-modified-since.  This
43113: // method creates a stream from the cache, synthesizing all the various
43113: // channel-related events.
43113: nsresult
43113: nsHttpChannel::ReadFromCache()
43113: {
43113:     nsresult rv;
43113: 
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_FAILURE);
43113:     NS_ENSURE_TRUE(mCachedContentIsValid, NS_ERROR_FAILURE);
43113: 
43113:     LOG(("nsHttpChannel::ReadFromCache [this=%p] "
43113:          "Using cached copy of: %s\n", this, mSpec.get()));
43113: 
46790:     if (mCachedResponseHead)
43113:         mResponseHead = mCachedResponseHead;
43113: 
43113:     // if we don't already have security info, try to get it from the cache 
43113:     // entry. there are two cases to consider here: 1) we are just reading
43113:     // from the cache, or 2) this may be due to a 304 not modified response,
43113:     // in which case we could have security info from a socket transport.
43113:     if (!mSecurityInfo)
43113:         mCacheEntry->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
43113: 
43113:     if ((mCacheAccess & nsICache::ACCESS_WRITE) && !mCachedContentIsPartial) {
43113:         // We have write access to the cache, but we don't need to go to the
43113:         // server to validate at this time, so just mark the cache entry as
43113:         // valid in order to allow others access to this cache entry.
43113:         mCacheEntry->MarkValid();
43113:     }
43113: 
43113:     // if this is a cached redirect, we must process the redirect asynchronously
43113:     // since AsyncOpen may not have returned yet.  Make sure there is a Location
43113:     // header, otherwise we'll have to treat this like a normal 200 response.
43113:     if (mResponseHead && (mResponseHead->Status() / 100 == 3) 
43113:                       && (mResponseHead->PeekHeader(nsHttp::Location)))
43113:         return AsyncCall(&nsHttpChannel::HandleAsyncRedirect);
43113: 
43113:     // have we been configured to skip reading from the cache?
43113:     if ((mLoadFlags & LOAD_ONLY_IF_MODIFIED) && !mCachedContentIsPartial) {
43113:         // if offline caching has been requested and the offline cache needs
43113:         // updating, complete the call even if the main cache entry is
43113:         // up-to-date
43113:         PRBool shouldUpdateOffline;
43113:         if (!mCacheForOfflineUse ||
43113:             NS_FAILED(ShouldUpdateOfflineCacheEntry(&shouldUpdateOffline)) ||
43113:             !shouldUpdateOffline) {
43113: 
43113:             LOG(("skipping read from cache based on LOAD_ONLY_IF_MODIFIED "
43113:                  "load flag\n"));
43113:             return AsyncCall(&nsHttpChannel::HandleAsyncNotModified);
43113:         }
43113:     }
43113: 
43113:     // open input stream for reading...
43113:     nsCOMPtr<nsIInputStream> stream;
43113:     rv = mCacheEntry->OpenInputStream(0, getter_AddRefs(stream));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = nsInputStreamPump::Create(getter_AddRefs(mCachePump),
43113:                                    stream, nsInt64(-1), nsInt64(-1), 0, 0,
43113:                                    PR_TRUE);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
53987:     rv = mCachePump->AsyncRead(this, mListenerContext);
53987:     if (NS_FAILED(rv)) return rv;
53987: 
53987:     PRUint32 suspendCount = mSuspendCount;
53987:     while (suspendCount--)
53987:         mCachePump->Suspend();
53987: 
53987:     return NS_OK;
43113: }
43113: 
43113: void
43113: nsHttpChannel::CloseCacheEntry(PRBool doomOnFailure)
43113: {
43113:     if (!mCacheEntry)
43113:         return;
43113: 
43113:     LOG(("nsHttpChannel::CloseCacheEntry [this=%p] mStatus=%x mCacheAccess=%x",
43113:          this, mStatus, mCacheAccess));
43113: 
43113:     // If we have begun to create or replace a cache entry, and that cache
43113:     // entry is not complete and not resumable, then it needs to be doomed.
43113:     // Otherwise, CheckCache will make the mistake of thinking that the
43113:     // partial cache entry is complete.
43113: 
43113:     PRBool doom = PR_FALSE;
43113:     if (mInitedCacheEntry) {
43113:         NS_ASSERTION(mResponseHead, "oops");
43113:         if (NS_FAILED(mStatus) && doomOnFailure &&
43113:             (mCacheAccess & nsICache::ACCESS_WRITE) &&
43113:             !mResponseHead->IsResumable())
43113:             doom = PR_TRUE;
43113:     }
43113:     else if (mCacheAccess == nsICache::ACCESS_WRITE)
43113:         doom = PR_TRUE;
43113: 
43113:     if (doom) {
43113:         LOG(("  dooming cache entry!!"));
43113:         mCacheEntry->Doom();
43113:     }
43113: 
46790:     mCachedResponseHead = nsnull;
43113: 
43113:     mCachePump = 0;
43113:     mCacheEntry = 0;
43113:     mCacheAccess = 0;
43113:     mInitedCacheEntry = PR_FALSE;
43113: }
43113: 
43113: 
43113: void
43113: nsHttpChannel::CloseOfflineCacheEntry()
43113: {
43113:     if (!mOfflineCacheEntry)
43113:         return;
43113: 
43113:     LOG(("nsHttpChannel::CloseOfflineCacheEntry [this=%p]", this));
43113: 
43113:     if (NS_FAILED(mStatus)) {
43113:         mOfflineCacheEntry->Doom();
43113:     }
43113:     else {
43113:         PRBool succeeded;
43113:         if (NS_SUCCEEDED(GetRequestSucceeded(&succeeded)) && !succeeded)
43113:             mOfflineCacheEntry->Doom();
43113:     }
43113: 
43113:     mOfflineCacheEntry = 0;
43113:     mOfflineCacheAccess = 0;
43113: 
43113:     if (mCachingOpportunistically) {
43113:         nsCOMPtr<nsIApplicationCacheService> appCacheService =
43113:             do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
43113:         if (appCacheService) {
43113:             nsCAutoString cacheKey;
43113:             GenerateCacheKey(mPostID, cacheKey);
43113:             appCacheService->CacheOpportunistically(mApplicationCache,
43113:                                                     cacheKey);
43113:         }
43113:     }
43113: }
43113: 
43113: 
43113: // Initialize the cache entry for writing.
43113: //  - finalize storage policy
43113: //  - store security info
43113: //  - update expiration time
43113: //  - store headers and other meta data
43113: nsresult
43113: nsHttpChannel::InitCacheEntry()
43113: {
43113:     nsresult rv;
43113: 
43113:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_UNEXPECTED);
43113:     // if only reading, nothing to be done here.
43113:     if (mCacheAccess == nsICache::ACCESS_READ)
43113:         return NS_OK;
43113: 
43113:     // Don't cache the response again if already cached...
43113:     if (mCachedContentIsValid)
43113:         return NS_OK;
43113: 
43113:     LOG(("nsHttpChannel::InitCacheEntry [this=%p entry=%p]\n",
43113:         this, mCacheEntry.get()));
43113: 
43113:     // The no-store directive within the 'Cache-Control:' header indicates
43113:     // that we must not store the response in a persistent cache.
43113:     if (mResponseHead->NoStore())
43113:         mLoadFlags |= INHIBIT_PERSISTENT_CACHING;
43113: 
43113:     // Only cache SSL content on disk if the pref is set
43113:     if (!gHttpHandler->IsPersistentHttpsCachingEnabled() &&
43113:         mConnectionInfo->UsingSSL())
43113:         mLoadFlags |= INHIBIT_PERSISTENT_CACHING;
43113: 
43113:     if (mLoadFlags & INHIBIT_PERSISTENT_CACHING) {
43113:         rv = mCacheEntry->SetStoragePolicy(nsICache::STORE_IN_MEMORY);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     // Set the expiration time for this cache entry
43113:     rv = UpdateExpirationTime();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = AddCacheEntryHeaders(mCacheEntry);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mInitedCacheEntry = PR_TRUE;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsHttpChannel::InitOfflineCacheEntry()
43113: {
43113:     // This function can be called even when we fail to connect (bug 551990)
43113: 
43113:     if (!mOfflineCacheEntry) {
43113:         return NS_OK;
43113:     }
43113: 
43113:     if (mResponseHead && mResponseHead->NoStore()) {
43113:         CloseOfflineCacheEntry();
43113: 
43113:         return NS_OK;
43113:     }
43113: 
43113:     // This entry's expiration time should match the main entry's expiration
43113:     // time.  UpdateExpirationTime() will keep it in sync once the offline
43113:     // cache entry has been created.
43113:     if (mCacheEntry) {
43113:         PRUint32 expirationTime;
43113:         nsresult rv = mCacheEntry->GetExpirationTime(&expirationTime);
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         mOfflineCacheEntry->SetExpirationTime(expirationTime);
43113:     }
43113: 
43113:     return AddCacheEntryHeaders(mOfflineCacheEntry);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsHttpChannel::AddCacheEntryHeaders(nsICacheEntryDescriptor *entry)
43113: {
43113:     nsresult rv;
43113: 
43113:     // Store secure data in memory only
43113:     if (mSecurityInfo)
43113:         entry->SetSecurityInfo(mSecurityInfo);
43113: 
43113:     // Store the HTTP request method with the cache entry so we can distinguish
43113:     // for example GET and HEAD responses.
43113:     rv = entry->SetMetaDataElement("request-method",
43113:                                    mRequestHead.Method().get());
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // Store the HTTP authorization scheme used if any...
43113:     rv = StoreAuthorizationMetaData(entry);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // Iterate over the headers listed in the Vary response header, and
43113:     // store the value of the corresponding request header so we can verify
43113:     // that it has not varied when we try to re-use the cached response at
43113:     // a later time.  Take care not to store "Cookie" headers though.  We
43113:     // take care of "Vary: cookie" in ResponseWouldVary.
43113:     //
43113:     // NOTE: if "Vary: accept, cookie", then we will store the "accept" header
43113:     // in the cache.  we could try to avoid needlessly storing the "accept"
43113:     // header in this case, but it doesn't seem worth the extra code to perform
43113:     // the check.
43113:     {
43113:         nsCAutoString buf, metaKey;
43113:         mResponseHead->GetHeader(nsHttp::Vary, buf);
43113:         if (!buf.IsEmpty()) {
43113:             NS_NAMED_LITERAL_CSTRING(prefix, "request-");
43113:            
43113:             char *val = buf.BeginWriting(); // going to munge buf
43113:             char *token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
43113:             while (token) {
43113:                 if ((*token != '*') && (PL_strcasecmp(token, "cookie") != 0)) {
43113:                     nsHttpAtom atom = nsHttp::ResolveAtom(token);
43113:                     const char *requestVal = mRequestHead.PeekHeader(atom);
43113:                     if (requestVal) {
43113:                         // build cache meta data key and set meta data element...
43113:                         metaKey = prefix + nsDependentCString(token);
43113:                         entry->SetMetaDataElement(metaKey.get(), requestVal);
43113:                     }
43113:                 }
43113:                 token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
43113:             }
43113:         }
43113:     }
43113: 
43113: 
43113:     // Store the received HTTP head with the cache entry as an element of
43113:     // the meta data.
43113:     nsCAutoString head;
43113:     mResponseHead->Flatten(head, PR_TRUE);
43113:     rv = entry->SetMetaDataElement("response-head", head.get());
43113: 
43113:     return rv;
43113: }
43113: 
43113: inline void
43113: GetAuthType(const char *challenge, nsCString &authType)
43113: {
43113:     const char *p;
43113: 
43113:     // get the challenge type
43113:     if ((p = strchr(challenge, ' ')) != nsnull)
43113:         authType.Assign(challenge, p - challenge);
43113:     else
43113:         authType.Assign(challenge);
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::StoreAuthorizationMetaData(nsICacheEntryDescriptor *entry)
43113: {
43113:     // Not applicable to proxy authorization...
43113:     const char *val = mRequestHead.PeekHeader(nsHttp::Authorization);
43113:     if (!val)
43113:         return NS_OK;
43113: 
43113:     // eg. [Basic realm="wally world"]
43113:     nsCAutoString buf;
43113:     GetAuthType(val, buf);
43113:     return entry->SetMetaDataElement("auth", buf.get());
43113: }
43113: 
43113: // Finalize the cache entry
43113: //  - may need to rewrite response headers if any headers changed
43113: //  - may need to recalculate the expiration time if any headers changed
43113: //  - called only for freshly written cache entries
43113: nsresult
43113: nsHttpChannel::FinalizeCacheEntry()
43113: {
43113:     LOG(("nsHttpChannel::FinalizeCacheEntry [this=%p]\n", this));
43113: 
43113:     if (mResponseHead && mResponseHeadersModified) {
43113:         // Set the expiration time for this cache entry
43113:         nsresult rv = UpdateExpirationTime();
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: // Open an output stream to the cache entry and insert a listener tee into
43113: // the chain of response listeners.
43113: nsresult
43113: nsHttpChannel::InstallCacheListener(PRUint32 offset)
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("Preparing to write data into the cache [uri=%s]\n", mSpec.get()));
43113: 
43113:     NS_ASSERTION(mCacheEntry, "no cache entry");
43113:     NS_ASSERTION(mListener, "no listener");
43113: 
43113:     nsCOMPtr<nsIOutputStream> out;
43113:     rv = mCacheEntry->OpenOutputStream(offset, getter_AddRefs(out));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // XXX disk cache does not support overlapped i/o yet
43113: #if 0
43113:     // Mark entry valid inorder to allow simultaneous reading...
43113:     rv = mCacheEntry->MarkValid();
43113:     if (NS_FAILED(rv)) return rv;
43113: #endif
43113: 
43113:     nsCOMPtr<nsIStreamListenerTee> tee =
43113:         do_CreateInstance(kStreamListenerTeeCID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
51302:     nsCOMPtr<nsICacheService> serv =
51302:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
51302:     NS_ENSURE_SUCCESS(rv, rv);
51302: 
51302:     nsCOMPtr<nsIEventTarget> cacheIOTarget;
51302:     serv->GetCacheIOTarget(getter_AddRefs(cacheIOTarget));
51302: 
43113:     nsCacheStoragePolicy policy;
43113:     rv = mCacheEntry->GetStoragePolicy(&policy);
43113: 
51302:     if (NS_FAILED(rv) || policy == nsICache::STORE_ON_DISK_AS_FILE ||
51302:         !cacheIOTarget) {
51302:         LOG(("nsHttpChannel::InstallCacheListener sync tee %p rv=%x policy=%d "
51302:              "cacheIOTarget=%p", tee.get(), rv, policy, cacheIOTarget.get()));
43113:         rv = tee->Init(mListener, out, nsnull);
43113:     } else {
51302:         LOG(("nsHttpChannel::InstallCacheListener async tee %p", tee.get()));
51302:         rv = tee->InitAsync(mListener, cacheIOTarget, out, nsnull);
43113:     }
43113: 
43113:     if (NS_FAILED(rv)) return rv;
43113:     mListener = tee;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::InstallOfflineCacheListener()
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("Preparing to write data into the offline cache [uri=%s]\n",
43113:          mSpec.get()));
43113: 
43113:     NS_ASSERTION(mOfflineCacheEntry, "no offline cache entry");
43113:     NS_ASSERTION(mListener, "no listener");
43113: 
43113:     nsCOMPtr<nsIOutputStream> out;
43113:     rv = mOfflineCacheEntry->OpenOutputStream(0, getter_AddRefs(out));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     nsCOMPtr<nsIStreamListenerTee> tee =
43113:         do_CreateInstance(kStreamListenerTeeCID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = tee->Init(mListener, out, nsnull);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mListener = tee;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: void
43113: nsHttpChannel::ClearBogusContentEncodingIfNeeded()
43113: {
43113:     // For .gz files, apache sends both a Content-Type: application/x-gzip
43113:     // as well as Content-Encoding: gzip, which is completely wrong.  In
43113:     // this case, we choose to ignore the rogue Content-Encoding header. We
43113:     // must do this early on so as to prevent it from being seen up stream.
43113:     // The same problem exists for Content-Encoding: compress in default
43113:     // Apache installs.
43113:     if (mResponseHead->HasHeaderValue(nsHttp::Content_Encoding, "gzip") && (
43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP) ||
43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP2) ||
43113:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP3))) {
43113:         // clear the Content-Encoding header
43113:         mResponseHead->ClearHeader(nsHttp::Content_Encoding);
43113:     }
43113:     else if (mResponseHead->HasHeaderValue(nsHttp::Content_Encoding, "compress") && (
43113:              mResponseHead->ContentType().EqualsLiteral(APPLICATION_COMPRESS) ||
43113:              mResponseHead->ContentType().EqualsLiteral(APPLICATION_COMPRESS2))) {
43113:         // clear the Content-Encoding header
43113:         mResponseHead->ClearHeader(nsHttp::Content_Encoding);
43113:     }
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <redirect>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpChannel::SetupReplacementChannel(nsIURI       *newURI, 
43113:                                        nsIChannel   *newChannel,
43113:                                        PRBool        preserveMethod)
43113: {
43113:     LOG(("nsHttpChannel::SetupReplacementChannel "
43113:          "[this=%p newChannel=%p preserveMethod=%d]",
43113:          this, newChannel, preserveMethod));
49375: 
49375:     nsresult rv = HttpBaseChannel::SetupReplacementChannel(newURI, newChannel, preserveMethod);
49375:     if (NS_FAILED(rv))
49375:         return rv;
43113: 
43113:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(newChannel);
43113:     if (!httpChannel)
43113:         return NS_OK; // no other options to set
43113: 
43113:     // convey the mApplyConversion flag (bug 91862)
43113:     nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(httpChannel);
43113:     if (encodedChannel)
43113:         encodedChannel->SetApplyConversion(mApplyConversion);
43113: 
43113:     // transfer the resume information
43113:     if (mResuming) {
43113:         nsCOMPtr<nsIResumableChannel> resumableChannel(do_QueryInterface(newChannel));
43113:         if (!resumableChannel) {
43113:             NS_WARNING("Got asked to resume, but redirected to non-resumable channel!");
43113:             return NS_ERROR_NOT_RESUMABLE;
43113:         }
43113:         resumableChannel->ResumeAt(mStartPos, mEntityID);
43113:     }
43113: 
52140:     // transfer the remote flag
52140:     nsCOMPtr<nsIHttpChannelParentInternal> httpInternal = 
52140:         do_QueryInterface(newChannel);
52140:     if (httpInternal)
52140:         httpInternal->SetServicingRemoteChannel(mRemoteChannel);
52140: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
48304: nsHttpChannel::AsyncProcessRedirection(PRUint32 redirectType)
43113: {
48304:     LOG(("nsHttpChannel::AsyncProcessRedirection [this=%p type=%u]\n",
43113:         this, redirectType));
43113: 
43113:     const char *location = mResponseHead->PeekHeader(nsHttp::Location);
43113: 
43113:     // if a location header was not given, then we can't perform the redirect,
43113:     // so just carry on as though this were a normal response.
43113:     if (!location)
43113:         return NS_ERROR_FAILURE;
43113: 
43113:     // make sure non-ASCII characters in the location header are escaped.
43113:     nsCAutoString locationBuf;
43113:     if (NS_EscapeURL(location, -1, esc_OnlyNonASCII, locationBuf))
43113:         location = locationBuf.get();
43113: 
43113:     if (mRedirectionLimit == 0) {
43113:         LOG(("redirection limit reached!\n"));
43113:         // this error code is fatal, and should be conveyed to our listener.
43113:         Cancel(NS_ERROR_REDIRECT_LOOP);
43113:         return NS_ERROR_REDIRECT_LOOP;
43113:     }
43113: 
48304:     mRedirectType = redirectType;
48304: 
43113:     LOG(("redirecting to: %s [redirection-limit=%u]\n",
43113:         location, PRUint32(mRedirectionLimit)));
43113: 
43113:     nsresult rv;
43113: 
43113:     // create a new URI using the location header and the current URL
43113:     // as a base...
43113:     nsCOMPtr<nsIIOService> ioService;
43113:     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // the new uri should inherit the origin charset of the current uri
43113:     nsCAutoString originCharset;
43113:     rv = mURI->GetOriginCharset(originCharset);
43113:     if (NS_FAILED(rv))
43113:         originCharset.Truncate();
43113: 
48304:     rv = ioService->NewURI(nsDependentCString(location),
48304:                            originCharset.get(),
48304:                            mURI,
48304:                            getter_AddRefs(mRedirectURI));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     if (mApplicationCache) {
43113:         // if we are redirected to a different origin check if there is a fallback
43113:         // cache entry to fall back to. we don't care about file strict 
43113:         // checking, at least mURI is not a file URI.
48304:         if (!NS_SecurityCompareURIs(mURI, mRedirectURI, PR_FALSE)) {
48304:             PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirectionAfterFallback);
48304:             PRBool waitingForRedirectCallback;
48304:             rv = ProcessFallback(&waitingForRedirectCallback);
48304:             if (waitingForRedirectCallback)
48304:                 return NS_OK;
48304:             PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirectionAfterFallback);
48304:         }
48304:     }
48304: 
48304:     return ContinueProcessRedirectionAfterFallback(NS_OK);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueProcessRedirectionAfterFallback(nsresult rv)
48304: {
48304:     if (NS_SUCCEEDED(rv) && mFallingBack) {
43113:         // do not continue with redirect processing, fallback is in
43113:         // progress now.
43113:         return NS_OK;
43113:     }
43113: 
43113:     // Kill the current cache entry if we are redirecting
43113:     // back to ourself.
43113:     PRBool redirectingBackToSameURI = PR_FALSE;
43113:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE) &&
48304:         NS_SUCCEEDED(mURI->Equals(mRedirectURI, &redirectingBackToSameURI)) &&
43113:         redirectingBackToSameURI)
43113:             mCacheEntry->Doom();
43113: 
43113:     // move the reference of the old location to the new one if the new
43113:     // one has none.
48304:     nsCOMPtr<nsIURL> newURL = do_QueryInterface(mRedirectURI);
43113:     if (newURL) {
43113:         nsCAutoString ref;
43113:         rv = newURL->GetRef(ref);
43113:         if (NS_SUCCEEDED(rv) && ref.IsEmpty()) {
43113:             nsCOMPtr<nsIURL> baseURL(do_QueryInterface(mURI));
43113:             if (baseURL) {
43113:                 baseURL->GetRef(ref);
43113:                 if (!ref.IsEmpty())
43113:                     newURL->SetRef(ref);
43113:             }
43113:         }
43113:     }
43113: 
43113:     // if we need to re-send POST data then be sure to ask the user first.
48304:     PRBool preserveMethod = (mRedirectType == 307);
43113:     if (preserveMethod && mUploadStream) {
43113:         rv = PromptTempRedirect();
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
48304:     nsCOMPtr<nsIIOService> ioService;
48304:     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
48304:     nsCOMPtr<nsIChannel> newChannel;
48304:     rv = ioService->NewChannelFromURI(mRedirectURI, getter_AddRefs(newChannel));
43113:     if (NS_FAILED(rv)) return rv;
43113: 
48304:     rv = SetupReplacementChannel(mRedirectURI, newChannel, preserveMethod);
48304:     if (NS_FAILED(rv)) return rv;
48304: 
43113:     PRUint32 redirectFlags;
48304:     if (mRedirectType == 301) // Moved Permanently
43113:         redirectFlags = nsIChannelEventSink::REDIRECT_PERMANENT;
43113:     else
43113:         redirectFlags = nsIChannelEventSink::REDIRECT_TEMPORARY;
43113: 
43113:     // verify that this is a legal redirect
48304:     mRedirectChannel = newChannel;
48304: 
48304:     PushRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirection);
48304:     rv = gHttpHandler->AsyncOnChannelRedirect(this, newChannel, redirectFlags);
48304: 
48304:     if (NS_SUCCEEDED(rv))
48304:         rv = WaitForRedirectCallback();
48304: 
48304:     if (NS_FAILED(rv)) {
49375:         AutoRedirectVetoNotifier notifier(this);
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueProcessRedirection);
48304:     }
48304: 
48304:     return rv;
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueProcessRedirection(nsresult rv)
48304: {
49375:     AutoRedirectVetoNotifier notifier(this);
49375: 
48889:     LOG(("ContinueProcessRedirection [rv=%x]\n", rv));
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
48304:     NS_PRECONDITION(mRedirectChannel, "No redirect channel?");
48304: 
43113:     // Make sure to do this _after_ calling OnChannelRedirect
48304:     mRedirectChannel->SetOriginalURI(mOriginalURI);
43113: 
43113:     // And now, the deprecated way
43113:     nsCOMPtr<nsIHttpEventSink> httpEventSink;
43113:     GetCallback(httpEventSink);
43113:     if (httpEventSink) {
43113:         // NOTE: nsIHttpEventSink is only used for compatibility with pre-1.8
43113:         // versions.
48304:         rv = httpEventSink->OnRedirect(this, mRedirectChannel);
48304:         if (NS_FAILED(rv))
48304:             return rv;
43113:     }
43113:     // XXX we used to talk directly with the script security manager, but that
43113:     // should really be handled by the event sink implementation.
43113: 
43113:     // begin loading the new channel
48304:     rv = mRedirectChannel->AsyncOpen(mListener, mListenerContext);
48304: 
48304:     if (NS_FAILED(rv))
48304:         return rv;
43113: 
43113:     // close down this channel
43113:     Cancel(NS_BINDING_REDIRECTED);
43113:     
49375:     notifier.RedirectSucceeded();
49375: 
43113:     // disconnect from our listener
43113:     mListener = 0;
43113:     mListenerContext = 0;
49375: 
43113:     // and from our callbacks
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel <auth>
43113: //-----------------------------------------------------------------------------
43113: 
43832: NS_IMETHODIMP nsHttpChannel::OnAuthAvailable()
43113: {
43113:     LOG(("nsHttpChannel::OnAuthAvailable [this=%p]", this));
43113: 
43113:     // setting mAuthRetryPending flag and resuming the transaction
43113:     // triggers process of throwing away the unauthenticated data already
43113:     // coming from the network
43113:     mAuthRetryPending = PR_TRUE;
43113:     LOG(("Resuming the transaction, we got credentials from user"));
43113:     mTransactionPump->Resume();
43113:   
43113:     return NS_OK;
43113: }
43113: 
43832: NS_IMETHODIMP nsHttpChannel::OnAuthCancelled(PRBool userCancel)
43113: {
43832:     LOG(("nsHttpChannel::OnAuthCancelled [this=%p]", this));
43832: 
43832:     if (userCancel) {
43832:         // ensure call of OnStartRequest of the current listener here,
43832:         // it would not be called otherwise at all
43832:         nsresult rv = CallOnStartRequest();
43832: 
43832:         // drop mAuthRetryPending flag and resume the transaction
43832:         // this resumes load of the unauthenticated content data
43832:         mAuthRetryPending = PR_FALSE;
43832:         LOG(("Resuming the transaction, user cancelled the auth dialog"));
43832:         mTransactionPump->Resume();
43832: 
43113:         if (NS_FAILED(rv))
43832:             mTransactionPump->Cancel(rv);
43832:     }
43832:     
43832:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsISupports
43113: //-----------------------------------------------------------------------------
43113: 
46790: NS_IMPL_ADDREF_INHERITED(nsHttpChannel, HttpBaseChannel)
46790: NS_IMPL_RELEASE_INHERITED(nsHttpChannel, HttpBaseChannel)
43113: 
43113: NS_INTERFACE_MAP_BEGIN(nsHttpChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIRequest)
43113:     NS_INTERFACE_MAP_ENTRY(nsIChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
43113:     NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
43113:     NS_INTERFACE_MAP_ENTRY(nsIHttpChannel)
46915:     NS_INTERFACE_MAP_ENTRY(nsICacheInfoChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsICachingChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIUploadChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIUploadChannel2)
43113:     NS_INTERFACE_MAP_ENTRY(nsICacheListener)
43113:     NS_INTERFACE_MAP_ENTRY(nsIEncodedChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIHttpChannelInternal)
43113:     NS_INTERFACE_MAP_ENTRY(nsIResumableChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsITransportEventSink)
43113:     NS_INTERFACE_MAP_ENTRY(nsISupportsPriority)
43113:     NS_INTERFACE_MAP_ENTRY(nsIProtocolProxyCallback)
43113:     NS_INTERFACE_MAP_ENTRY(nsIProxiedChannel)
43832:     NS_INTERFACE_MAP_ENTRY(nsIHttpAuthenticableChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsITraceableChannel)
43113:     NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheContainer)
43113:     NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheChannel)
48304:     NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
46790: NS_INTERFACE_MAP_END_INHERITING(HttpBaseChannel)
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIRequest
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::Cancel(nsresult status)
43113: {
43113:     LOG(("nsHttpChannel::Cancel [this=%p status=%x]\n", this, status));
43113:     if (mCanceled) {
43113:         LOG(("  ignoring; already canceled\n"));
43113:         return NS_OK;
43113:     }
48304:     if (mWaitingForRedirectCallback) {
48304:         LOG(("channel canceled during wait for redirect callback"));
48304:     }
43113:     mCanceled = PR_TRUE;
43113:     mStatus = status;
43113:     if (mProxyRequest)
43113:         mProxyRequest->Cancel(status);
43113:     if (mTransaction)
43113:         gHttpHandler->CancelTransaction(mTransaction, status);
43113:     if (mTransactionPump)
43113:         mTransactionPump->Cancel(status);
43113:     if (mCachePump)
43113:         mCachePump->Cancel(status);
43832:     if (mAuthProvider)
43832:         mAuthProvider->Cancel(status);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::Suspend()
43113: {
43113:     NS_ENSURE_TRUE(mIsPending, NS_ERROR_NOT_AVAILABLE);
43113:     
43113:     LOG(("nsHttpChannel::Suspend [this=%p]\n", this));
43113: 
43113:     ++mSuspendCount;
43113: 
43113:     if (mTransactionPump)
43113:         return mTransactionPump->Suspend();
43113:     if (mCachePump)
43113:         return mCachePump->Suspend();
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::Resume()
43113: {
43113:     NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);
43113:     
43113:     LOG(("nsHttpChannel::Resume [this=%p]\n", this));
43113:         
43113:     if (--mSuspendCount == 0 && mPendingAsyncCallOnResume) {
43113:         nsresult rv = AsyncCall(mPendingAsyncCallOnResume);
43113:         mPendingAsyncCallOnResume = nsnull;
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113:     }
43113: 
43113:     if (mTransactionPump)
43113:         return mTransactionPump->Resume();
43113:     if (mCachePump)
43113:         return mCachePump->Resume();
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetSecurityInfo(nsISupports **securityInfo)
43113: {
43113:     NS_ENSURE_ARG_POINTER(securityInfo);
43113:     *securityInfo = mSecurityInfo;
43113:     NS_IF_ADDREF(*securityInfo);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::AsyncOpen(nsIStreamListener *listener, nsISupports *context)
43113: {
43113:     LOG(("nsHttpChannel::AsyncOpen [this=%p]\n", this));
43113: 
43113:     NS_ENSURE_ARG_POINTER(listener);
43113:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
43113: 
43113:     nsresult rv;
43113: 
49366:     if (mCanceled)
49366:         return mStatus;
49366: 
43113:     rv = NS_CheckPortSafety(mURI);
43113:     if (NS_FAILED(rv))
43113:         return rv;
43113: 
43113:     if (!(mConnectionInfo && mConnectionInfo->UsingHttpProxy())) {
43113:         // Start a DNS lookup very early in case the real open is queued the DNS can 
43113:         // happen in parallel. Do not do so in the presence of an HTTP proxy as 
43113:         // all lookups other than for the proxy itself are done by the proxy.
43113:         nsRefPtr<nsDNSPrefetch> prefetch = new nsDNSPrefetch(mURI);
43113:         if (prefetch) {
43113:             prefetch->PrefetchHigh();
43113:         }
43113:     }
43113:     
46906:     if (!mRemoteChannel) {
46906:       // For non-remote channels, we are responsible for cookies.
46906: 
43113:       // Remember the cookie header that was set, if any
43113:       const char *cookieHeader = mRequestHead.PeekHeader(nsHttp::Cookie);
46906:       if (cookieHeader) {
43113:         mUserSetCookieHeader = cookieHeader;
46906:       }
46906: 
43113:       AddCookiesToRequest();
46906:     }
43113: 
43113:     // notify "http-on-modify-request" observers
43113:     gHttpHandler->OnModifyRequest(this);
43113: 
43113:     // Adjust mCaps according to our request headers:
43113:     //  - If "Connection: close" is set as a request header, then do not bother
43113:     //    trying to establish a keep-alive connection.
43113:     if (mRequestHead.HasHeaderValue(nsHttp::Connection, "close"))
43113:         mCaps &= ~(NS_HTTP_ALLOW_KEEPALIVE | NS_HTTP_ALLOW_PIPELINING);
43113:     
43113:     if ((mLoadFlags & VALIDATE_ALWAYS) || 
43113:         (BYPASS_LOCAL_CACHE(mLoadFlags)))
43113:         mCaps |= NS_HTTP_REFRESH_DNS;
43113: 
43113:     mIsPending = PR_TRUE;
43113:     mWasOpened = PR_TRUE;
43113: 
43113:     mListener = listener;
43113:     mListenerContext = context;
43113: 
43113:     // add ourselves to the load group.  from this point forward, we'll report
43113:     // all failures asynchronously.
43113:     if (mLoadGroup)
43113:         mLoadGroup->AddRequest(this, nsnull);
43113: 
43113:     // We may have been cancelled already, either by on-modify-request
43113:     // listeners or by load group observers; in that case, we should
43113:     // not send the request to the server
43113:     if (mCanceled)
43113:         rv = mStatus;
43113:     else
43113:         rv = Connect();
43113:     if (NS_FAILED(rv)) {
43113:         LOG(("Calling AsyncAbort [rv=%x mCanceled=%i]\n", rv, mCanceled));
43113:         CloseCacheEntry(PR_TRUE);
43113:         AsyncAbort(rv);
47861:     } else if (mLoadFlags & LOAD_CLASSIFY_URI) {
43113:         nsRefPtr<nsChannelClassifier> classifier = new nsChannelClassifier();
43113:         if (!classifier) {
43113:             Cancel(NS_ERROR_OUT_OF_MEMORY);
43113:             return NS_OK;
43113:         }
43113: 
43113:         rv = classifier->Start(this);
43113:         if (NS_FAILED(rv)) {
43113:             Cancel(rv);
43113:         }
43113:     }
43113: 
43113:     return NS_OK;
43113: }
46790: 
43113: //-----------------------------------------------------------------------------
46790: // nsHttpChannel::nsIHttpChannelInternal
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
46790: nsHttpChannel::SetupFallbackChannel(const char *aFallbackKey)
43113: {
46790:     LOG(("nsHttpChannel::SetupFallbackChannel [this=%x, key=%s]",
46790:          this, aFallbackKey));
46790:     mFallbackChannel = PR_TRUE;
46790:     mFallbackKey = aFallbackKey;
46790: 
43113:     return NS_OK;
43113: }
52140: 
52140: //-----------------------------------------------------------------------------
52140: // nsHttpChannel::nsIHttpChannelParentInternal
52140: //-----------------------------------------------------------------------------
52140: 
52140: NS_IMETHODIMP
52140: nsHttpChannel::GetServicingRemoteChannel(PRBool *value)
52140: {
52140:     *value = mRemoteChannel;
52140:     return NS_OK;
52140: }
52140: NS_IMETHODIMP
52140: nsHttpChannel::SetServicingRemoteChannel(PRBool value)
52140: {
52140:     mRemoteChannel = value;
52140:     return NS_OK;
52140: }
46790: //-----------------------------------------------------------------------------
46790: // nsHttpChannel::nsIEncodedChannel
46790: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetApplyConversion(PRBool *value)
43113: {
43113:     NS_ENSURE_ARG_POINTER(value);
43113:     *value = mApplyConversion;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetApplyConversion(PRBool value)
43113: {
43113:     LOG(("nsHttpChannel::SetApplyConversion [this=%p value=%d]\n", this, value));
43113:     mApplyConversion = value;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetContentEncodings(nsIUTF8StringEnumerator** aEncodings)
43113: {
43113:     NS_PRECONDITION(aEncodings, "Null out param");
43113:     if (!mResponseHead) {
43113:         *aEncodings = nsnull;
43113:         return NS_OK;
43113:     }
43113:     
43113:     const char *encoding = mResponseHead->PeekHeader(nsHttp::Content_Encoding);
43113:     if (!encoding) {
43113:         *aEncodings = nsnull;
43113:         return NS_OK;
43113:     }
43113:     nsContentEncodings* enumerator = new nsContentEncodings(this, encoding);
43113:     if (!enumerator)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(*aEncodings = enumerator);
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsISupportsPriority
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetPriority(PRInt32 value)
43113: {
43113:     PRInt16 newValue = NS_CLAMP(value, PR_INT16_MIN, PR_INT16_MAX);
43113:     if (mPriority == newValue)
43113:         return NS_OK;
43113:     mPriority = newValue;
43113:     if (mTransaction)
43113:         gHttpHandler->RescheduleTransaction(mTransaction, mPriority);
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIProtocolProxyCallback
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnProxyAvailable(nsICancelable *request, nsIURI *uri,
43113:                                 nsIProxyInfo *pi, nsresult status)
43113: {
43113:     mProxyRequest = nsnull;
43113: 
43113:     // If status is a failure code, then it means that we failed to resolve
43113:     // proxy info.  That is a non-fatal error assuming it wasn't because the
43113:     // request was canceled.  We just failover to DIRECT when proxy resolution
43113:     // fails (failure can mean that the PAC URL could not be loaded).
43113:     
43113:     // Need to replace this channel with a new one.  It would be complex to try
43113:     // to change the value of mConnectionInfo since so much of our state may
43113:     // depend on its state.
43113:     mTargetProxyInfo = pi;
43113:     HandleAsyncReplaceWithProxy();
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIProxiedChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetProxyInfo(nsIProxyInfo **result)
43113: {
43113:     if (!mConnectionInfo)
43113:         *result = nsnull;
43113:     else {
43113:         *result = mConnectionInfo->ProxyInfo();
43113:         NS_IF_ADDREF(*result);
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43832: // nsHttpChannel::nsIHttpAuthenticableChannel
43832: //-----------------------------------------------------------------------------
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::GetIsSSL(PRBool *aIsSSL)
43832: {
43832:     *aIsSSL = mConnectionInfo->UsingSSL();
43832:     return NS_OK;
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::GetProxyMethodIsConnect(PRBool *aProxyMethodIsConnect)
43832: {
43832:     *aProxyMethodIsConnect =
43832:         (mConnectionInfo->UsingHttpProxy() && mConnectionInfo->UsingSSL());
43832:     return NS_OK;
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::GetServerResponseHeader(nsACString &value)
43832: {
43832:     if (!mResponseHead)
43832:         return NS_ERROR_NOT_AVAILABLE;
43832:     return mResponseHead->GetHeader(nsHttp::Server, value);
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::GetProxyChallenges(nsACString &value)
43832: {
43832:     if (!mResponseHead)
43832:         return NS_ERROR_UNEXPECTED;
43832:     return mResponseHead->GetHeader(nsHttp::Proxy_Authenticate, value);
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::GetWWWChallenges(nsACString &value)
43832: {
43832:     if (!mResponseHead)
43832:         return NS_ERROR_UNEXPECTED;
43832:     return mResponseHead->GetHeader(nsHttp::WWW_Authenticate, value);
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::SetProxyCredentials(const nsACString &value)
43832: {
43832:     return mRequestHead.SetHeader(nsHttp::Proxy_Authorization, value);
43832: }
43832: 
43832: NS_IMETHODIMP
43832: nsHttpChannel::SetWWWCredentials(const nsACString &value)
43832: {
43832:     return mRequestHead.SetHeader(nsHttp::Authorization, value);
43832: }
43832: 
43832: //-----------------------------------------------------------------------------
46909: // Methods that nsIHttpAuthenticableChannel dupes from other IDLs, which we
46909: // get from HttpBaseChannel, must be explicitly forwarded, because C++ sucks.
46909: //
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)
46909: {
46909:     return HttpBaseChannel::GetLoadFlags(aLoadFlags);
46909: }
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetURI(nsIURI **aURI)
46909: {
46909:     return HttpBaseChannel::GetURI(aURI);
46909: }
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetNotificationCallbacks(nsIInterfaceRequestor **aCallbacks)
46909: {
46909:     return HttpBaseChannel::GetNotificationCallbacks(aCallbacks);
46909: }
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetLoadGroup(nsILoadGroup **aLoadGroup)
46909: {
46909:     return HttpBaseChannel::GetLoadGroup(aLoadGroup);
46909: }
46909: 
46909: NS_IMETHODIMP
46909: nsHttpChannel::GetRequestMethod(nsACString& aMethod)
46909: {
46909:     return HttpBaseChannel::GetRequestMethod(aMethod);
46909: }
46909: 
46909: 
46909: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIRequestObserver
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
43113: {
43113:     if (!(mCanceled || NS_FAILED(mStatus))) {
43113:         // capture the request's status, so our consumers will know ASAP of any
43113:         // connection failures, etc - bug 93581
43113:         request->GetStatus(&mStatus);
43113:     }
43113: 
43113:     LOG(("nsHttpChannel::OnStartRequest [this=%p request=%p status=%x]\n",
43113:         this, request, mStatus));
43113: 
43113:     // Make sure things are what we expect them to be...
43113:     NS_ASSERTION(request == mCachePump || request == mTransactionPump,
43113:                  "Unexpected request");
43113:     NS_ASSERTION(!(mTransactionPump && mCachePump) || mCachedContentIsPartial,
43113:                  "If we have both pumps, the cache content must be partial");
43113: 
43113:     if (!mSecurityInfo && !mCachePump && mTransaction) {
43113:         // grab the security info from the connection object; the transaction
43113:         // is guaranteed to own a reference to the connection.
43113:         mSecurityInfo = mTransaction->SecurityInfo();
43113:     }
43113: 
43113:     // don't enter this block if we're reading from the cache...
43113:     if (NS_SUCCEEDED(mStatus) && !mCachePump && mTransaction) {
43113:         // all of the response headers have been acquired, so we can take ownership
43113:         // of them from the transaction.
43113:         mResponseHead = mTransaction->TakeResponseHead();
43113:         // the response head may be null if the transaction was cancelled.  in
43113:         // which case we just need to call OnStartRequest/OnStopRequest.
43113:         if (mResponseHead)
43113:             return ProcessResponse();
43113: 
43113:         NS_WARNING("No response head in OnStartRequest");
43113:     }
43113: 
43113:     // avoid crashing if mListener happens to be null...
43113:     if (!mListener) {
43113:         NS_NOTREACHED("mListener is null");
43113:         return NS_OK;
43113:     }
43113: 
43113:     // on proxy errors, try to failover
43113:     if (mConnectionInfo->ProxyInfo() &&
43113:        (mStatus == NS_ERROR_PROXY_CONNECTION_REFUSED ||
43113:         mStatus == NS_ERROR_UNKNOWN_PROXY_HOST ||
43113:         mStatus == NS_ERROR_NET_TIMEOUT)) {
48304: 
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest1);
43113:         if (NS_SUCCEEDED(ProxyFailover()))
43113:             return NS_OK;
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest1);
48304:     }
48304: 
48304:     return ContinueOnStartRequest2(NS_OK);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueOnStartRequest1(nsresult result)
48304: {
48304:     // Success indicates we passed ProxyFailover, in that case we must not continue
48304:     // with this code chain.
48304:     if (NS_SUCCEEDED(result))
48304:         return NS_OK;
48304: 
48304:     return ContinueOnStartRequest2(result);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueOnStartRequest2(nsresult result)
48304: {
43113:     // on other request errors, try to fall back
48304:     if (NS_FAILED(mStatus)) {
48304:         PushRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest3);
48304:         PRBool waitingForRedirectCallback;
48304:         nsresult rv = ProcessFallback(&waitingForRedirectCallback);
48304:         if (waitingForRedirectCallback)
43113:             return NS_OK;
48304:         PopRedirectAsyncFunc(&nsHttpChannel::ContinueOnStartRequest3);
48304:     }
48304: 
48304:     return ContinueOnStartRequest3(NS_OK);
48304: }
48304: 
48304: nsresult
48304: nsHttpChannel::ContinueOnStartRequest3(nsresult result)
48304: {
48304:     if (mFallingBack)
48304:         return NS_OK;
43113: 
43113:     return CallOnStartRequest();
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
43113: {
43113:     LOG(("nsHttpChannel::OnStopRequest [this=%p request=%p status=%x]\n",
43113:         this, request, status));
43113: 
43113:     // honor the cancelation status even if the underlying transaction completed.
43113:     if (mCanceled || NS_FAILED(mStatus))
43113:         status = mStatus;
43113: 
43113:     if (mCachedContentIsPartial) {
43113:         if (NS_SUCCEEDED(status)) {
43113:             // mTransactionPump should be suspended
43113:             NS_ASSERTION(request != mTransactionPump,
43113:                 "byte-range transaction finished prematurely");
43113: 
43113:             if (request == mCachePump) {
43113:                 PRBool streamDone;
43113:                 status = OnDoneReadingPartialCacheEntry(&streamDone);
43113:                 if (NS_SUCCEEDED(status) && !streamDone)
43113:                     return status;
43113:                 // otherwise, fall through and fire OnStopRequest...
43113:             }
43113:             else
43113:                 NS_NOTREACHED("unexpected request");
43113:         }
43113:         // Do not to leave the transaction in a suspended state in error cases.
43113:         if (NS_FAILED(status) && mTransaction)
43113:             gHttpHandler->CancelTransaction(mTransaction, status); 
43113:     }
43113: 
43113:     if (mTransaction) {
43113:         // determine if we should call DoAuthRetry
43113:         PRBool authRetry = mAuthRetryPending && NS_SUCCEEDED(status);
43113: 
43113:         //
43113:         // grab reference to connection in case we need to retry an
43113:         // authentication request over it.  this applies to connection based
43113:         // authentication schemes only.  for request based schemes, conn is not
43113:         // needed, so it may be null.
43113:         // 
43113:         // this code relies on the code in nsHttpTransaction::Close, which
43113:         // tests for NS_HTTP_STICKY_CONNECTION to determine whether or not to
43113:         // keep the connection around after the transaction is finished.
43113:         //
43113:         nsRefPtr<nsAHttpConnection> conn;
43113:         if (authRetry && (mCaps & NS_HTTP_STICKY_CONNECTION)) {
43113:             conn = mTransaction->Connection();
43113:             // This is so far a workaround to fix leak when reusing unpersistent
43113:             // connection for authentication retry. See bug 459620 comment 4
43113:             // for details.
43113:             if (conn && !conn->IsPersistent())
43113:                 conn = nsnull;
43113:         }
43113: 
43113:         // at this point, we're done with the transaction
46790:         mTransaction = nsnull;
43113:         mTransactionPump = 0;
43113: 
43113:         // handle auth retry...
43113:         if (authRetry) {
43113:             mAuthRetryPending = PR_FALSE;
43113:             status = DoAuthRetry(conn);
43113:             if (NS_SUCCEEDED(status))
43113:                 return NS_OK;
43113:         }
43113: 
43113:         // If DoAuthRetry failed, or if we have been cancelled since showing
43113:         // the auth. dialog, then we need to send OnStartRequest now
43113:         if (authRetry || (mAuthRetryPending && NS_FAILED(status))) {
43113:             NS_ASSERTION(NS_FAILED(status), "should have a failure code here");
43113:             // NOTE: since we have a failure status, we can ignore the return
43113:             // value from onStartRequest.
43113:             mListener->OnStartRequest(this, mListenerContext);
43113:         }
43113: 
43113:         // if this transaction has been replaced, then bail.
43113:         if (mTransactionReplaced)
43113:             return NS_OK;
43113:     }
43113: 
43113:     mIsPending = PR_FALSE;
43113:     mStatus = status;
43113: 
43113:     // perform any final cache operations before we close the cache entry.
48724:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE) &&
48724:         mRequestTimeInitialized){
43113:         FinalizeCacheEntry();
48724:     }
43113:     
43113:     if (mListener) {
43113:         LOG(("  calling OnStopRequest\n"));
43113:         mListener->OnStopRequest(this, mListenerContext, status);
43113:         mListener = 0;
43113:         mListenerContext = 0;
43113:     }
43113: 
43113:     if (mCacheEntry)
43113:         CloseCacheEntry(PR_TRUE);
43113: 
43113:     if (mOfflineCacheEntry)
43113:         CloseOfflineCacheEntry();
43113: 
43113:     if (mLoadGroup)
43113:         mLoadGroup->RemoveRequest(this, nsnull, status);
43113: 
43113:     mCallbacks = nsnull;
43113:     mProgressSink = nsnull;
43113:     
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIStreamListener
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnDataAvailable(nsIRequest *request, nsISupports *ctxt,
43113:                                nsIInputStream *input,
43113:                                PRUint32 offset, PRUint32 count)
43113: {
43113:     LOG(("nsHttpChannel::OnDataAvailable [this=%p request=%p offset=%u count=%u]\n",
43113:         this, request, offset, count));
43113: 
43113:     // don't send out OnDataAvailable notifications if we've been canceled.
43113:     if (mCanceled)
43113:         return mStatus;
43113: 
43113:     NS_ASSERTION(mResponseHead, "No response head in ODA!!");
43113: 
43113:     NS_ASSERTION(!(mCachedContentIsPartial && (request == mTransactionPump)),
43113:             "transaction pump not suspended");
43113: 
43113:     if (mAuthRetryPending || (request == mTransactionPump && mTransactionReplaced)) {
43113:         PRUint32 n;
43113:         return input->ReadSegments(NS_DiscardSegment, nsnull, count, &n);
43113:     }
43113: 
43113:     if (mListener) {
43113:         //
43113:         // synthesize transport progress event.  we do this here since we want
43113:         // to delay OnProgress events until we start streaming data.  this is
43113:         // crucially important since it impacts the lock icon (see bug 240053).
43113:         //
43113:         nsresult transportStatus;
43113:         if (request == mCachePump)
43113:             transportStatus = nsITransport::STATUS_READING;
43113:         else
43113:             transportStatus = nsISocketTransport::STATUS_RECEIVING_FROM;
43113: 
43113:         // mResponseHead may reference new or cached headers, but either way it
43113:         // holds our best estimate of the total content length.  Even in the case
43113:         // of a byte range request, the content length stored in the cached
43113:         // response headers is what we want to use here.
43113: 
51740:         PRUint64 progressMax(PRUint64(mResponseHead->ContentLength()));
43113:         PRUint64 progress = mLogicalOffset + PRUint64(count);
43113:         NS_ASSERTION(progress <= progressMax, "unexpected progress values");
43113: 
43113:         OnTransportStatus(nsnull, transportStatus, progress, progressMax);
43113: 
43113:         //
43113:         // we have to manually keep the logical offset of the stream up-to-date.
43113:         // we cannot depend solely on the offset provided, since we may have 
43113:         // already streamed some data from another source (see, for example,
43113:         // OnDoneReadingPartialCacheEntry).
43113:         //
43113:         nsresult rv =  mListener->OnDataAvailable(this,
43113:                                                   mListenerContext,
43113:                                                   input,
43113:                                                   mLogicalOffset,
43113:                                                   count);
43113:         if (NS_SUCCEEDED(rv))
43113:             mLogicalOffset = progress;
43113:         return rv;
43113:     }
43113: 
43113:     return NS_ERROR_ABORT;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsITransportEventSink
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnTransportStatus(nsITransport *trans, nsresult status,
43113:                                  PRUint64 progress, PRUint64 progressMax)
43113: {
43113:     // cache the progress sink so we don't have to query for it each time.
43113:     if (!mProgressSink)
43113:         GetCallback(mProgressSink);
43113: 
43113:     // block socket status event after Cancel or OnStopRequest has been called.
43113:     if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending && !(mLoadFlags & LOAD_BACKGROUND)) {
43113:         LOG(("sending status notification [this=%p status=%x progress=%llu/%llu]\n",
43113:             this, status, progress, progressMax));
43113: 
43113:         nsCAutoString host;
43113:         mURI->GetHost(host);
43113:         mProgressSink->OnStatus(this, nsnull, status,
43113:                                 NS_ConvertUTF8toUTF16(host).get());
43113: 
43113:         if (progress > 0) {
43113:             NS_ASSERTION(progress <= progressMax, "unexpected progress values");
43113:             mProgressSink->OnProgress(this, nsnull, progress, progressMax);
43113:         }
43113:     }
43113: #ifdef DEBUG
43113:     else
43113:         LOG(("skipping status notification [this=%p sink=%p pending=%u background=%x]\n",
43113:             this, mProgressSink.get(), mIsPending, (mLoadFlags & LOAD_BACKGROUND)));
43113: #endif
43113: 
43113:     return NS_OK;
43113: } 
43113: 
43113: //-----------------------------------------------------------------------------
46915: // nsHttpChannel::nsICacheInfoChannel
46915: //-----------------------------------------------------------------------------
46915: 
46915: NS_IMETHODIMP
46915: nsHttpChannel::IsFromCache(PRBool *value)
46915: {
46915:     if (!mIsPending)
46915:         return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:     // return false if reading a partial cache entry; the data isn't entirely
46915:     // from the cache!
46915: 
46915:     *value = (mCachePump || (mLoadFlags & LOAD_ONLY_IF_MODIFIED)) &&
46915:               mCachedContentIsValid && !mCachedContentIsPartial;
46915: 
46915:     return NS_OK;
46915: }
46915: 
46915: NS_IMETHODIMP
46915: nsHttpChannel::GetCacheTokenExpirationTime(PRUint32 *_retval)
46915: {
46915:     NS_ENSURE_ARG_POINTER(_retval);
46915:     if (!mCacheEntry)
46915:         return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:     return mCacheEntry->GetExpirationTime(_retval);
46915: }
46915: 
46915: NS_IMETHODIMP
46915: nsHttpChannel::GetCacheTokenCachedCharset(nsACString &_retval)
46915: {
46915:     nsresult rv;
46915: 
46915:     if (!mCacheEntry)
46915:         return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:     nsXPIDLCString cachedCharset;
46915:     rv = mCacheEntry->GetMetaDataElement("charset",
46915:                                          getter_Copies(cachedCharset));
46915:     if (NS_SUCCEEDED(rv))
46915:         _retval = cachedCharset;
46915: 
46915:     return rv;
46915: }
46915: 
46915: NS_IMETHODIMP
46915: nsHttpChannel::SetCacheTokenCachedCharset(const nsACString &aCharset)
46915: {
46915:     if (!mCacheEntry)
46915:         return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:     return mCacheEntry->SetMetaDataElement("charset",
46915:                                            PromiseFlatCString(aCharset).get());
46915: }
46915: 
46915: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsICachingChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetCacheToken(nsISupports **token)
43113: {
43113:     NS_ENSURE_ARG_POINTER(token);
43113:     if (!mCacheEntry)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     return CallQueryInterface(mCacheEntry, token);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetCacheToken(nsISupports *token)
43113: {
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetOfflineCacheToken(nsISupports **token)
43113: {
43113:     NS_ENSURE_ARG_POINTER(token);
43113:     if (!mOfflineCacheEntry)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     return CallQueryInterface(mOfflineCacheEntry, token);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetOfflineCacheToken(nsISupports *token)
43113: {
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: class nsHttpChannelCacheKey : public nsISupportsPRUint32,
43113:                               public nsISupportsCString
43113: {
43113:     NS_DECL_ISUPPORTS
43113: 
43113:     NS_DECL_NSISUPPORTSPRIMITIVE
43113:     NS_FORWARD_NSISUPPORTSPRUINT32(mSupportsPRUint32->)
43113:     
43113:     // Both interfaces declares toString method with the same signature.
43113:     // Thus we have to delegate only to nsISupportsPRUint32 implementation.
43113:     NS_SCRIPTABLE NS_IMETHOD GetData(nsACString & aData) 
43113:     { 
43113:         return mSupportsCString->GetData(aData);
43113:     }
43113:     NS_SCRIPTABLE NS_IMETHOD SetData(const nsACString & aData)
43113:     { 
43113:         return mSupportsCString->SetData(aData);
43113:     }
43113:     
43113: public:
43113:     nsresult SetData(PRUint32 aPostID, const nsACString& aKey);
43113: 
43113: protected:
43113:     nsCOMPtr<nsISupportsPRUint32> mSupportsPRUint32;
43113:     nsCOMPtr<nsISupportsCString> mSupportsCString;
43113: };
43113: 
43113: NS_IMPL_ADDREF(nsHttpChannelCacheKey)
43113: NS_IMPL_RELEASE(nsHttpChannelCacheKey)
43113: NS_INTERFACE_TABLE_HEAD(nsHttpChannelCacheKey)
43113: NS_INTERFACE_TABLE_BEGIN
43113: NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsHttpChannelCacheKey,
43113:                                    nsISupports, nsISupportsPRUint32)
43113: NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(nsHttpChannelCacheKey,
43113:                                    nsISupportsPrimitive, nsISupportsPRUint32)
43113: NS_INTERFACE_TABLE_ENTRY(nsHttpChannelCacheKey,
43113:                          nsISupportsPRUint32)
43113: NS_INTERFACE_TABLE_ENTRY(nsHttpChannelCacheKey,
43113:                          nsISupportsCString)
43113: NS_INTERFACE_TABLE_END
43113: NS_INTERFACE_TABLE_TAIL
43113: 
43113: NS_IMETHODIMP nsHttpChannelCacheKey::GetType(PRUint16 *aType)
43113: {
43113:     NS_ENSURE_ARG_POINTER(aType);
43113: 
43113:     *aType = TYPE_PRUINT32;
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult nsHttpChannelCacheKey::SetData(PRUint32 aPostID,
43113:                                         const nsACString& aKey)
43113: {
43113:     nsresult rv;
43113: 
43113:     mSupportsCString = 
43113:         do_CreateInstance(NS_SUPPORTS_CSTRING_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mSupportsCString->SetData(aKey);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mSupportsPRUint32 = 
43113:         do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     mSupportsPRUint32->SetData(aPostID);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetCacheKey(nsISupports **key)
43113: {
43113:     nsresult rv;
43113:     NS_ENSURE_ARG_POINTER(key);
43113: 
43113:     LOG(("nsHttpChannel::GetCacheKey [this=%p]\n", this));
43113: 
43113:     *key = nsnull;
43113: 
43113:     nsRefPtr<nsHttpChannelCacheKey> container =
43113:         new nsHttpChannelCacheKey();
43113: 
43113:     if (!container)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     nsCAutoString cacheKey;
43113:     rv = GenerateCacheKey(mPostID, cacheKey);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     rv = container->SetData(mPostID, cacheKey);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     return CallQueryInterface(container.get(), key);
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetCacheKey(nsISupports *key)
43113: {
43113:     nsresult rv;
43113: 
43113:     LOG(("nsHttpChannel::SetCacheKey [this=%p key=%p]\n", this, key));
43113: 
43113:     // can only set the cache key if a load is not in progress
43113:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
43113: 
43113:     if (!key)
43113:         mPostID = 0;
43113:     else {
43113:         // extract the post id
43113:         nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(key, &rv);
43113:         if (NS_FAILED(rv)) return rv;
43113: 
43113:         rv = container->GetData(&mPostID);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetCacheAsFile(PRBool *value)
43113: {
43113:     NS_ENSURE_ARG_POINTER(value);
43113:     if (!mCacheEntry)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     nsCacheStoragePolicy storagePolicy;
43113:     mCacheEntry->GetStoragePolicy(&storagePolicy);
43113:     *value = (storagePolicy == nsICache::STORE_ON_DISK_AS_FILE);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetCacheAsFile(PRBool value)
43113: {
43113:     if (!mCacheEntry || mLoadFlags & INHIBIT_PERSISTENT_CACHING)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     nsCacheStoragePolicy policy;
43113:     if (value)
43113:         policy = nsICache::STORE_ON_DISK_AS_FILE;
43113:     else
43113:         policy = nsICache::STORE_ANYWHERE;
43113:     return mCacheEntry->SetStoragePolicy(policy);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetCacheForOfflineUse(PRBool *value)
43113: {
43113:     *value = mCacheForOfflineUse;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetCacheForOfflineUse(PRBool value)
43113: {
43113:     mCacheForOfflineUse = value;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetOfflineCacheClientID(nsACString &value)
43113: {
43113:     value = mOfflineCacheClientID;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetOfflineCacheClientID(const nsACString &value)
43113: {
43113:     mOfflineCacheClientID = value;
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetCacheFile(nsIFile **cacheFile)
43113: {
43113:     if (!mCacheEntry)
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     return mCacheEntry->GetFile(cacheFile);
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIResumableChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::ResumeAt(PRUint64 aStartPos,
43113:                         const nsACString& aEntityID)
43113: {
43113:     LOG(("nsHttpChannel::ResumeAt [this=%p startPos=%llu id='%s']\n",
43113:          this, aStartPos, PromiseFlatCString(aEntityID).get()));
43113:     mEntityID = aEntityID;
43113:     mStartPos = aStartPos;
43113:     mResuming = PR_TRUE;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsICacheListener
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::OnCacheEntryAvailable(nsICacheEntryDescriptor *entry,
43113:                                      nsCacheAccessMode access,
43113:                                      nsresult status)
43113: {
53987:     nsresult rv;
53987: 
43113:     LOG(("nsHttpChannel::OnCacheEntryAvailable [this=%p entry=%p "
43113:          "access=%x status=%x]\n", this, entry, access, status));
43113: 
43113:     // if the channel's already fired onStopRequest, then we should ignore
43113:     // this event.
43113:     if (!mIsPending)
43113:         return NS_OK;
43113: 
53987:     nsOnCacheEntryAvailableCallback callback = mOnCacheEntryAvailableCallback;
53987:     mOnCacheEntryAvailableCallback = nsnull;
53987: 
53987:     NS_ASSERTION(callback,
53987:         "nsHttpChannel::OnCacheEntryAvailable called without callback");
53987:     rv = ((*this).*callback)(entry, access, status, PR_FALSE);
53987: 
43113:     if (NS_FAILED(rv)) {
53987:         LOG(("AsyncOpenCacheEntry failed [rv=%x]\n", rv));
53987:         if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
53987:             // If we have a fallback URI (and we're not already
53987:             // falling back), process the fallback asynchronously.
53987:             if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
53987:                 rv = AsyncCall(&nsHttpChannel::HandleAsyncFallback);
53987:                 if (NS_SUCCEEDED(rv))
53987:                     return rv;
53987:             }
53987:         }
43113:         CloseCacheEntry(PR_TRUE);
43113:         AsyncAbort(rv);
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: nsresult
43113: nsHttpChannel::DoAuthRetry(nsAHttpConnection *conn)
43113: {
43113:     LOG(("nsHttpChannel::DoAuthRetry [this=%p]\n", this));
43113: 
43113:     NS_ASSERTION(!mTransaction, "should not have a transaction");
43113:     nsresult rv;
43113: 
43113:     // toggle mIsPending to allow nsIObserver implementations to modify
43113:     // the request headers (bug 95044).
43113:     mIsPending = PR_FALSE;
43113: 
43113:     // fetch cookies, and add them to the request header.
43113:     // the server response could have included cookies that must be sent with
43113:     // this authentication attempt (bug 84794).
46906:     // TODO: save cookies from auth response and send them here (bug 572151).
46906:     if (!mRemoteChannel) {
46906:       // For non-remote channels, we are responsible for cookies.
43113:       AddCookiesToRequest();
46906:     }
43113: 
43113:     // notify "http-on-modify-request" observers
43113:     gHttpHandler->OnModifyRequest(this);
43113: 
43113:     mIsPending = PR_TRUE;
43113: 
43113:     // get rid of the old response headers
43113:     mResponseHead = nsnull;
43113: 
43113:     // set sticky connection flag and disable pipelining.
43113:     mCaps |=  NS_HTTP_STICKY_CONNECTION;
43113:     mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
43113:    
43113:     // and create a new one...
43113:     rv = SetupTransaction();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // transfer ownership of connection to transaction
43113:     if (conn)
43113:         mTransaction->SetConnection(conn);
43113: 
43113:     // rewind the upload stream
43113:     if (mUploadStream) {
43113:         nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
43113:         if (seekable)
43113:             seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
43113:     }
43113: 
43113:     rv = gHttpHandler->InitiateTransaction(mTransaction, mPriority);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
53987:     rv = mTransactionPump->AsyncRead(this, nsnull);
53987:     if (NS_FAILED(rv)) return rv;
53987: 
53987:     PRUint32 suspendCount = mSuspendCount;
53987:     while (suspendCount--)
53987:         mTransactionPump->Suspend();
53987: 
53987:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsIApplicationCacheChannel
43113: //-----------------------------------------------------------------------------
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetApplicationCache(nsIApplicationCache **out)
43113: {
43113:     NS_IF_ADDREF(*out = mApplicationCache);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetApplicationCache(nsIApplicationCache *appCache)
43113: {
43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
43113: 
43113:     mApplicationCache = appCache;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetLoadedFromApplicationCache(PRBool *aLoadedFromApplicationCache)
43113: {
43113:     *aLoadedFromApplicationCache = mLoadedFromApplicationCache;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetInheritApplicationCache(PRBool *aInherit)
43113: {
43113:     *aInherit = mInheritApplicationCache;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetInheritApplicationCache(PRBool aInherit)
43113: {
43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
43113: 
43113:     mInheritApplicationCache = aInherit;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::GetChooseApplicationCache(PRBool *aChoose)
43113: {
43113:     *aChoose = mChooseApplicationCache;
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetChooseApplicationCache(PRBool aChoose)
43113: {
43113:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
43113: 
43113:     mChooseApplicationCache = aChoose;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
48304: // nsHttpChannel::nsIAsyncVerifyRedirectCallback
48304: //-----------------------------------------------------------------------------
48304: 
48304: nsresult
48304: nsHttpChannel::WaitForRedirectCallback()
48304: {
48304:     nsresult rv;
50824:     LOG(("nsHttpChannel::WaitForRedirectCallback [this=%p]\n", this));
50824: 
48304:     if (mTransactionPump) {
48304:         rv = mTransactionPump->Suspend();
48304:         NS_ENSURE_SUCCESS(rv, rv);
48304:     }
48304:     if (mCachePump) {
48304:         rv = mCachePump->Suspend();
48304:         if (NS_FAILED(rv) && mTransactionPump) {
48304:             nsresult resume = mTransactionPump->Resume();
48304:             NS_ASSERTION(NS_SUCCEEDED(resume),
48304:                 "Failed to resume transaction pump");
48304:         }
48304:         NS_ENSURE_SUCCESS(rv, rv);
48304:     }
48304: 
48304:     mWaitingForRedirectCallback = PR_TRUE;
48304:     return NS_OK;
48304: }
48304: 
48304: NS_IMETHODIMP
48304: nsHttpChannel::OnRedirectVerifyCallback(nsresult result)
48304: {
48889:     LOG(("nsHttpChannel::OnRedirectVerifyCallback [this=%p] "
48889:          "result=%x stack=%d mWaitingForRedirectCallback=%u\n",
48889:          this, result, mRedirectFuncStack.Length(), mWaitingForRedirectCallback));
48304:     NS_ASSERTION(mWaitingForRedirectCallback,
48304:                  "Someone forgot to call WaitForRedirectCallback() ?!");
48304:     mWaitingForRedirectCallback = PR_FALSE;
48304: 
48304:     if (mCanceled && NS_SUCCEEDED(result))
48304:         result = NS_BINDING_ABORTED;
48304: 
48304:     for (PRUint32 i = mRedirectFuncStack.Length(); i > 0;) {
48304:         --i;
48304:         // Pop the last function pushed to the stack
48304:         nsContinueRedirectionFunc func = mRedirectFuncStack[i];
48304:         mRedirectFuncStack.RemoveElementAt(mRedirectFuncStack.Length() - 1);
48304: 
48304:         // Call it with the result we got from the callback or the deeper
48304:         // function call.
48304:         result = (this->*func)(result);
48304: 
48304:         // If a new function has been pushed to the stack and placed us in the
48304:         // waiting state, we need to break the chain and wait for the callback
48304:         // again.
48304:         if (mWaitingForRedirectCallback)
48304:             break;
48304:     }
48304: 
48304:     if (NS_FAILED(result) && !mCanceled) {
48304:         // First, cancel this channel if we are in failure state to set mStatus
48304:         // and let it be propagated to pumps.
48304:         Cancel(result);
48304:     }
48304: 
48304:     if (!mWaitingForRedirectCallback) {
48304:         // We are not waiting for the callback. At this moment we must release
48304:         // reference to the redirect target channel, otherwise we may leak.
48304:         mRedirectChannel = nsnull;
48304:     }
48304: 
48304:     // We always resume the pumps here. If all functions on stack have been
48304:     // called we need OnStopRequest to be triggered, and if we broke out of the
48304:     // loop above (and are thus waiting for a new callback) the suspension
48304:     // count must be balanced in the pumps.
48304:     if (mTransactionPump)
48304:         mTransactionPump->Resume();
48304:     if (mCachePump)
48304:         mCachePump->Resume();
48304: 
48304:     return result;
48304: }
48304: 
48304: void
48304: nsHttpChannel::PushRedirectAsyncFunc(nsContinueRedirectionFunc func)
48304: {
48304:     mRedirectFuncStack.AppendElement(func);
48304: }
48304: 
48304: void
48304: nsHttpChannel::PopRedirectAsyncFunc(nsContinueRedirectionFunc func)
48304: {
48304:     NS_ASSERTION(func == mRedirectFuncStack[mRedirectFuncStack.Length() - 1],
48304:         "Trying to pop wrong method from redirect async stack!");
48304: 
48304:     mRedirectFuncStack.TruncateLength(mRedirectFuncStack.Length() - 1);
48304: }
48304: 
48304: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsContentEncodings <public>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsHttpChannel::nsContentEncodings::nsContentEncodings(nsIHttpChannel* aChannel,
43113:                                                           const char* aEncodingHeader) :
43113:     mEncodingHeader(aEncodingHeader), mChannel(aChannel), mReady(PR_FALSE)
43113: {
43113:     mCurEnd = aEncodingHeader + strlen(aEncodingHeader);
43113:     mCurStart = mCurEnd;
43113: }
43113:     
43113: nsHttpChannel::nsContentEncodings::~nsContentEncodings()
43113: {
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsContentEncodings::nsISimpleEnumerator
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::nsContentEncodings::HasMore(PRBool* aMoreEncodings)
43113: {
43113:     if (mReady) {
43113:         *aMoreEncodings = PR_TRUE;
43113:         return NS_OK;
43113:     }
43113:     
43113:     nsresult rv = PrepareForNext();
43113:     *aMoreEncodings = NS_SUCCEEDED(rv);
43113:     return NS_OK;
43113: }
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::nsContentEncodings::GetNext(nsACString& aNextEncoding)
43113: {
43113:     aNextEncoding.Truncate();
43113:     if (!mReady) {
43113:         nsresult rv = PrepareForNext();
43113:         if (NS_FAILED(rv)) {
43113:             return NS_ERROR_FAILURE;
43113:         }
43113:     }
43113: 
43113:     const nsACString & encoding = Substring(mCurStart, mCurEnd);
43113: 
43113:     nsACString::const_iterator start, end;
43113:     encoding.BeginReading(start);
43113:     encoding.EndReading(end);
43113: 
43113:     PRBool haveType = PR_FALSE;
43113:     if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("gzip"),
43113:                                       start,
43113:                                       end)) {
43113:         aNextEncoding.AssignLiteral(APPLICATION_GZIP);
43113:         haveType = PR_TRUE;
43113:     }
43113: 
43113:     if (!haveType) {
43113:         encoding.BeginReading(start);
43113:         if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("compress"),
43113:                                           start,
43113:                                           end)) {
43113:             aNextEncoding.AssignLiteral(APPLICATION_COMPRESS);
43113:                                            
43113:             haveType = PR_TRUE;
43113:         }
43113:     }
43113:     
43113:     if (! haveType) {
43113:         encoding.BeginReading(start);
43113:         if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("deflate"),
43113:                                           start,
43113:                                           end)) {
43113:             aNextEncoding.AssignLiteral(APPLICATION_ZIP);
43113:             haveType = PR_TRUE;
43113:         }
43113:     }
43113: 
43113:     // Prepare to fetch the next encoding
43113:     mCurEnd = mCurStart;
43113:     mReady = PR_FALSE;
43113:     
43113:     if (haveType)
43113:         return NS_OK;
43113: 
43113:     NS_WARNING("Unknown encoding type");
43113:     return NS_ERROR_FAILURE;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsContentEncodings::nsISupports
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMPL_ISUPPORTS1(nsHttpChannel::nsContentEncodings, nsIUTF8StringEnumerator)
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsContentEncodings <private>
43113: //-----------------------------------------------------------------------------
43113: 
43113: nsresult
43113: nsHttpChannel::nsContentEncodings::PrepareForNext(void)
43113: {
43113:     NS_PRECONDITION(mCurStart == mCurEnd, "Indeterminate state");
43113:     
43113:     // At this point both mCurStart and mCurEnd point to somewhere
43113:     // past the end of the next thing we want to return
43113:     
43113:     while (mCurEnd != mEncodingHeader) {
43113:         --mCurEnd;
43113:         if (*mCurEnd != ',' && !nsCRT::IsAsciiSpace(*mCurEnd))
43113:             break;
43113:     }
43113:     if (mCurEnd == mEncodingHeader)
43113:         return NS_ERROR_NOT_AVAILABLE; // no more encodings
43113:     ++mCurEnd;
43113:         
43113:     // At this point mCurEnd points to the first char _after_ the
43113:     // header we want.  Furthermore, mCurEnd - 1 != mEncodingHeader
43113:     
43113:     mCurStart = mCurEnd - 1;
43113:     while (mCurStart != mEncodingHeader &&
43113:            *mCurStart != ',' && !nsCRT::IsAsciiSpace(*mCurStart))
43113:         --mCurStart;
43113:     if (*mCurStart == ',' || nsCRT::IsAsciiSpace(*mCurStart))
43113:         ++mCurStart; // we stopped because of a weird char, so move up one
43113:         
43113:     // At this point mCurStart and mCurEnd bracket the encoding string
43113:     // we want.  Check that it's not "identity"
43113:     if (Substring(mCurStart, mCurEnd).Equals("identity",
43113:                                              nsCaseInsensitiveCStringComparator())) {
43113:         mCurEnd = mCurStart;
43113:         return PrepareForNext();
43113:     }
43113:         
43113:     mReady = PR_TRUE;
43113:     return NS_OK;
43113: }
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsStreamListenerWrapper <private>
43113: //-----------------------------------------------------------------------------
43113: 
43113: // Wrapper class to make replacement of nsHttpChannel's listener
43113: // from JavaScript possible. It is workaround for bug 433711.
43113: class nsStreamListenerWrapper : public nsIStreamListener
43113: {
43113: public:
43113:     nsStreamListenerWrapper(nsIStreamListener *listener);
43113: 
43113:     NS_DECL_ISUPPORTS
43113:     NS_FORWARD_NSIREQUESTOBSERVER(mListener->)
43113:     NS_FORWARD_NSISTREAMLISTENER(mListener->)
43113: 
43113: private:
43113:     ~nsStreamListenerWrapper() {}
43113:     nsCOMPtr<nsIStreamListener> mListener;
43113: };
43113: 
43113: nsStreamListenerWrapper::nsStreamListenerWrapper(nsIStreamListener *listener)
43113:     : mListener(listener) 
43113: {
43113:     NS_ASSERTION(mListener, "no stream listener specified");
43113: }
43113: 
43113: NS_IMPL_ISUPPORTS2(nsStreamListenerWrapper,
43113:                    nsIStreamListener,
43113:                    nsIRequestObserver)
43113: 
43113: //-----------------------------------------------------------------------------
43113: // nsHttpChannel::nsITraceableChannel
43113: //-----------------------------------------------------------------------------
43113: 
43113: NS_IMETHODIMP
43113: nsHttpChannel::SetNewListener(nsIStreamListener *aListener, nsIStreamListener **_retval)
43113: {
43113:     if (!mTracingEnabled)
43113:         return NS_ERROR_FAILURE;
43113: 
43113:     NS_ENSURE_ARG_POINTER(aListener);
43113: 
43113:     nsCOMPtr<nsIStreamListener> wrapper = 
43113:         new nsStreamListenerWrapper(mListener);
43113: 
43113:     if (!wrapper)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     wrapper.forget(_retval);
43113:     mListener = aListener;
43113:     return NS_OK;
43113: }
43113: 
43113: void
43113: nsHttpChannel::MaybeInvalidateCacheEntryForSubsequentGet()
43113: {
43113:     // See RFC 2616 section 5.1.1. These are considered valid
43113:     // methods which DO NOT invalidate cache-entries for the
43113:     // referred resource. POST, PUT and DELETE as well as any
43113:     // other method not listed here will potentially invalidate
43113:     // any cached copy of the resource
43113:     if (mRequestHead.Method() == nsHttp::Options ||
43113:        mRequestHead.Method() == nsHttp::Get ||
43113:        mRequestHead.Method() == nsHttp::Head ||
43113:        mRequestHead.Method() == nsHttp::Trace ||
43113:        mRequestHead.Method() == nsHttp::Connect)
43113:         return;
43113:         
43113:     // NOTE:
43113:     // Following comments 24,32 and 33 in bug #327765, we only care about
43113:     // the cache in the protocol-handler.
43113:     // The logic below deviates from the original logic in OpenCacheEntry on
43113:     // one point by using only READ_ONLY access-policy. I think this is safe.
43113:     LOG(("MaybeInvalidateCacheEntryForSubsequentGet [this=%p]\n", this));
43113: 
43113:     nsCAutoString tmpCacheKey;
43113:     // passing 0 in first param gives the cache-key for a GET to my resource
43113:     GenerateCacheKey(0, tmpCacheKey);
43113: 
43113:     // Now, find the session holding the cache-entry
43113:     nsCOMPtr<nsICacheSession> session;
43113:     nsCacheStoragePolicy storagePolicy = DetermineStoragePolicy();
43113: 
43113:     nsresult rv;
43113:     rv = gHttpHandler->GetCacheSession(storagePolicy,
43113:                                        getter_AddRefs(session));
43113: 
43113:     if (NS_FAILED(rv)) return;
43113: 
43113:     // Finally, find the actual cache-entry
43113:     nsCOMPtr<nsICacheEntryDescriptor> tmpCacheEntry;
43113:     rv = session->OpenCacheEntry(tmpCacheKey, nsICache::ACCESS_READ,
43113:                                  PR_FALSE,
43113:                                  getter_AddRefs(tmpCacheEntry));
43113:     
43113:     // If entry was found, set its expiration-time = 0
43113:     if(NS_SUCCEEDED(rv)) {
43113:        tmpCacheEntry->SetExpirationTime(0);
43113:     }
43113: }
43113: 
43113: nsCacheStoragePolicy
43113: nsHttpChannel::DetermineStoragePolicy()
43113: {
43113:     nsCacheStoragePolicy policy = nsICache::STORE_ANYWHERE;
43113:     if (mLoadFlags & INHIBIT_PERSISTENT_CACHING)
43113:         policy = nsICache::STORE_IN_MEMORY;
43113: 
43113:     return policy;
43113: }
43113: 
53987: nsresult
53987: nsHttpChannel::DetermineCacheAccess(nsCacheAccessMode *_retval)
53987: {
53987:     PRBool offline = gIOService->IsOffline();
53987: 
53987:     if (offline || (mLoadFlags & INHIBIT_CACHING)) {
53987:         // If we have been asked to bypass the cache and not write to the
53987:         // cache, then don't use the cache at all.  Unless we're actually
53987:         // offline, which takes precedence over BYPASS_LOCAL_CACHE.
53987:         if (BYPASS_LOCAL_CACHE(mLoadFlags) && !offline)
53987:             return NS_ERROR_NOT_AVAILABLE;
53987:         *_retval = nsICache::ACCESS_READ;
53987:     }
53987:     else if (BYPASS_LOCAL_CACHE(mLoadFlags))
53987:         *_retval = nsICache::ACCESS_WRITE; // replace cache entry
53987:     else
53987:         *_retval = nsICache::ACCESS_READ_WRITE; // normal browsing
53987: 
53987:     return NS_OK;
53987: }
53987: 
43113: void
43113: nsHttpChannel::AsyncOnExamineCachedResponse()
43113: {
43113:     gHttpHandler->OnExamineCachedResponse(this);
43113: }
