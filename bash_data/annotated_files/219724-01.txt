     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsAutoCompleteController.h"
     1: #include "nsAutoCompleteSimpleResult.h"
     1: 
 92197: #include "nsAutoPtr.h"
     1: #include "nsNetCID.h"
     1: #include "nsIIOService.h"
     1: #include "nsToolkitCompsCID.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIAtomService.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsUnicharUtils.h"
162988: #include "nsITreeBoxObject.h"
     1: #include "nsITreeColumns.h"
     1: #include "nsIObserverService.h"
     1: #include "nsIDOMKeyEvent.h"
 41540: #include "mozilla/Services.h"
 46998: #include "mozilla/ModuleUtils.h"
     1: 
     1: static const char *kAutoCompleteSearchCID = "@mozilla.org/autocomplete/search;1?name=";
     1: 
154217: NS_IMPL_CYCLE_COLLECTION_CLASS(nsAutoCompleteController)
154217: 
 21610: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsAutoCompleteController)
106838:   tmp->SetInput(nullptr);
 21610: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 21610: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsAutoCompleteController)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mInput)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSearches)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mResults)
 21610: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 21610: 
 21610: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsAutoCompleteController)
 21610: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsAutoCompleteController)
 21610: NS_INTERFACE_TABLE_HEAD(nsAutoCompleteController)
200047:   NS_INTERFACE_TABLE(nsAutoCompleteController, nsIAutoCompleteController,
 21610:                      nsIAutoCompleteObserver, nsITimerCallback, nsITreeView)
 21610:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsAutoCompleteController)
 21610: NS_INTERFACE_MAP_END
     1: 
     1: nsAutoCompleteController::nsAutoCompleteController() :
 80486:   mDefaultIndexCompleted(false),
 80486:   mBackspaced(false),
 80486:   mPopupClosedByCompositionStart(false),
 92197:   mCompositionState(eCompositionState_None),
 23279:   mSearchStatus(nsAutoCompleteController::STATUS_NONE),
     1:   mRowCount(0),
  4881:   mSearchesOngoing(0),
 91356:   mSearchesFailed(0),
 91356:   mFirstSearchResult(false),
 91356:   mImmediateSearchesCount(0)
     1: {
     1: }
     1: 
     1: nsAutoCompleteController::~nsAutoCompleteController()
     1: {
106838:   SetInput(nullptr);
     1: }
     1: 
     1: ////////////////////////////////////////////////////////////////////////
     1: //// nsIAutoCompleteController
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetSearchStatus(uint16_t *aSearchStatus)
     1: {
     1:   *aSearchStatus = mSearchStatus;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetMatchCount(uint32_t *aMatchCount)
     1: {
     1:   *aMatchCount = mRowCount;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::GetInput(nsIAutoCompleteInput **aInput)
     1: {
     1:   *aInput = mInput;
     1:   NS_IF_ADDREF(*aInput);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::SetInput(nsIAutoCompleteInput *aInput)
     1: {
     1:   // Don't do anything if the input isn't changing.
     1:   if (mInput == aInput)
     1:     return NS_OK;
     1: 
     1:   // Clear out the current search context
     1:   if (mInput) {
  4881:     // Stop all searches in case they are async.
  4881:     StopSearch();
     1:     ClearResults();
     1:     ClosePopup();
 21610:     mSearches.Clear();
     1:   }
     1: 
     1:   mInput = aInput;
     1: 
     1:   // Nothing more to do if the input was just being set to null.
     1:   if (!aInput)
     1:     return NS_OK;
     1: 
     1:   nsAutoString newValue;
 13311:   aInput->GetTextValue(newValue);
     1: 
 12564:   // Clear out this reference in case the new input's popup has no tree
106838:   mTree = nullptr;
 12564: 
     1:   // Reset all search state members to default values
     1:   mSearchString = newValue;
 80486:   mDefaultIndexCompleted = false;
 80486:   mBackspaced = false;
     1:   mSearchStatus = nsIAutoCompleteController::STATUS_NONE;
     1:   mRowCount = 0;
     1:   mSearchesOngoing = 0;
     1: 
     1:   // Initialize our list of search objects
108991:   uint32_t searchCount;
 13311:   aInput->GetSearchCount(&searchCount);
 21610:   mResults.SetCapacity(searchCount);
 21610:   mSearches.SetCapacity(searchCount);
  4881:   mMatchCounts.SetLength(searchCount);
 91356:   mImmediateSearchesCount = 0;
     1: 
     1:   const char *searchCID = kAutoCompleteSearchCID;
     1: 
108991:   for (uint32_t i = 0; i < searchCount; ++i) {
     1:     // Use the search name to create the contract id string for the search service
110974:     nsAutoCString searchName;
 13311:     aInput->GetSearchAt(i, searchName);
110974:     nsAutoCString cid(searchCID);
     1:     cid.Append(searchName);
     1: 
     1:     // Use the created cid to get a pointer to the search service and store it for later
     1:     nsCOMPtr<nsIAutoCompleteSearch> search = do_GetService(cid.get());
 91356:     if (search) {
 21610:       mSearches.AppendObject(search);
 91356: 
 91356:       // Count immediate searches.
108991:       uint16_t searchType = nsIAutoCompleteSearchDescriptor::SEARCH_TYPE_DELAYED;
 91356:       nsCOMPtr<nsIAutoCompleteSearchDescriptor> searchDesc =
 91356:         do_QueryInterface(search);
 91356:       if (searchDesc && NS_SUCCEEDED(searchDesc->GetSearchType(&searchType)) &&
 91356:           searchType == nsIAutoCompleteSearchDescriptor::SEARCH_TYPE_IMMEDIATE)
 91356:         mImmediateSearchesCount++;
 91356:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::StartSearch(const nsAString &aSearchString)
     1: {
     1:   mSearchString = aSearchString;
 91356:   StartSearches();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 30200: nsAutoCompleteController::HandleText()
     1: {
 92197:   // Note: the events occur in the following order when IME is used.
 92197:   // 1. a compositionstart event(HandleStartComposition)
 92197:   // 2. some input events (HandleText), eCompositionState_Composing
 92197:   // 3. a compositionend event(HandleEndComposition)
 92197:   // 4. an input event(HandleText), eCompositionState_Committing
 87220:   // We should do nothing during composition.
 92197:   if (mCompositionState == eCompositionState_Composing) {
 87220:     return NS_OK;
 87220:   }
 87220: 
 92197:   bool handlingCompositionCommit =
 92197:     (mCompositionState == eCompositionState_Committing);
 92197:   bool popupClosedByCompositionStart = mPopupClosedByCompositionStart;
 92197:   if (handlingCompositionCommit) {
 92197:     mCompositionState = eCompositionState_None;
 92197:     mPopupClosedByCompositionStart = false;
 92197:   }
 92197: 
     1:   if (!mInput) {
  4881:     // Stop all searches in case they are async.
     1:     StopSearch();
     1:     // Note: if now is after blur and IME end composition,
     1:     // check mInput before calling.
     1:     // See https://bugzilla.mozilla.org/show_bug.cgi?id=193544#c31
     1:     NS_ERROR("Called before attaching to the control or after detaching from the control");
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsAutoString newValue;
 13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
 13311:   input->GetTextValue(newValue);
     1: 
  4881:   // Stop all searches in case they are async.
     1:   StopSearch();
     1: 
  6115:   if (!mInput) {
  6115:     // StopSearch() can call PostSearchCleanup() which might result
  6115:     // in a blur event, which could null out mInput, so we need to check it
  6115:     // again.  See bug #395344 for more details
  6115:     return NS_OK;
  6115:   }
  6115: 
 79445:   bool disabled;
 13311:   input->GetDisableAutoComplete(&disabled);
     1:   NS_ENSURE_TRUE(!disabled, NS_OK);
     1: 
     1:   // Don't search again if the new string is the same as the last search
 92197:   // However, if this is called immediately after compositionend event,
 92197:   // we need to search the same value again since the search was canceled
 92197:   // at compositionstart event handler.
 92197:   if (!handlingCompositionCommit && newValue.Length() > 0 &&
 92197:       newValue.Equals(mSearchString)) {
     1:     return NS_OK;
 92197:   }
     1: 
     1:   // Determine if the user has removed text from the end (probably by backspacing)
     1:   if (newValue.Length() < mSearchString.Length() &&
     1:       Substring(mSearchString, 0, newValue.Length()).Equals(newValue))
     1:   {
     1:     // We need to throw away previous results so we don't try to search through them again
     1:     ClearResults();
 80486:     mBackspaced = true;
     1:   } else
 80486:     mBackspaced = false;
     1: 
     1:   mSearchString = newValue;
     1: 
     1:   // Don't search if the value is empty
     1:   if (newValue.Length() == 0) {
 92197:     // If autocomplete popup was closed by compositionstart event handler,
 92197:     // we should reopen it forcibly even if the value is empty.
 92197:     if (popupClosedByCompositionStart && handlingCompositionCommit) {
 92197:       bool cancel;
 92197:       HandleKeyNavigation(nsIDOMKeyEvent::DOM_VK_DOWN, &cancel);
 92197:       return NS_OK;
 92197:     }
     1:     ClosePopup();
     1:     return NS_OK;
     1:   }
     1: 
 91356:   StartSearches();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsAutoCompleteController::HandleEnter(bool aIsPopupSelection, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   if (!mInput)
     1:     return NS_OK;
     1: 
219724:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
219724: 
     1:   // allow the event through unless there is something selected in the popup
219724:   input->GetPopupOpen(_retval);
     1:   if (*_retval) {
     1:     nsCOMPtr<nsIAutoCompletePopup> popup;
219724:     input->GetPopup(getter_AddRefs(popup));
     1: 
     1:     if (popup) {
108991:       int32_t selectedIndex;
     1:       popup->GetSelectedIndex(&selectedIndex);
     1:       *_retval = selectedIndex >= 0;
     1:     }
     1:   }
     1: 
 32032:   // Stop the search, and handle the enter.
 32032:   StopSearch();
 12436:   EnterMatch(aIsPopupSelection);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsAutoCompleteController::HandleEscape(bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   if (!mInput)
     1:     return NS_OK;
     1: 
219724:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
219724: 
     1:   // allow the event through if the popup is closed
219724:   input->GetPopupOpen(_retval);
     1: 
  4881:   // Stop all searches in case they are async.
  4881:   StopSearch();
     1:   ClearResults();
     1:   RevertTextValue();
     1:   ClosePopup();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::HandleStartComposition()
     1: {
 92197:   NS_ENSURE_TRUE(mCompositionState != eCompositionState_Composing, NS_OK);
     1: 
 80486:   mPopupClosedByCompositionStart = false;
 92197:   mCompositionState = eCompositionState_Composing;
     1: 
     1:   if (!mInput)
     1:     return NS_OK;
     1: 
 13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
 79445:   bool disabled;
 13311:   input->GetDisableAutoComplete(&disabled);
     1:   if (disabled)
     1:     return NS_OK;
     1: 
  4881:   // Stop all searches in case they are async.
     1:   StopSearch();
     1: 
 79445:   bool isOpen = false;
 13311:   input->GetPopupOpen(&isOpen);
 61559:   if (isOpen) {
     1:     ClosePopup();
 61559: 
 79445:     bool stillOpen = false;
 61559:     input->GetPopupOpen(&stillOpen);
 61559:     mPopupClosedByCompositionStart = !stillOpen;
 61559:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::HandleEndComposition()
     1: {
 92197:   NS_ENSURE_TRUE(mCompositionState == eCompositionState_Composing, NS_OK);
     1: 
 92197:   // We can't yet retrieve the committed value from the editor, since it isn't
 92197:   // completely committed yet. Set mCompositionState to
 92197:   // eCompositionState_Committing, so that when HandleText() is called (in
 92197:   // response to the "input" event), we know that we should handle the
 92197:   // committed text.
 92197:   mCompositionState = eCompositionState_Committing;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::HandleTab()
     1: {
 79445:   bool cancel;
 80486:   return HandleEnter(false, &cancel);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::HandleKeyNavigation(uint32_t aKey, bool *_retval)
     1: {
     1:   // By default, don't cancel the event
 80486:   *_retval = false;
     1: 
     1:   if (!mInput) {
 43921:     // Stop all searches in case they are async.
 43921:     StopSearch();
     1:     // Note: if now is after blur and IME end composition,
     1:     // check mInput before calling.
     1:     // See https://bugzilla.mozilla.org/show_bug.cgi?id=193544#c31
     1:     NS_ERROR("Called before attaching to the control or after detaching from the control");
     1:     return NS_OK;
     1:   }
     1: 
 13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
     1:   nsCOMPtr<nsIAutoCompletePopup> popup;
 13311:   input->GetPopup(getter_AddRefs(popup));
106838:   NS_ENSURE_TRUE(popup != nullptr, NS_ERROR_FAILURE);
     1: 
 79445:   bool disabled;
 13311:   input->GetDisableAutoComplete(&disabled);
     1:   NS_ENSURE_TRUE(!disabled, NS_OK);
     1: 
     1:   if (aKey == nsIDOMKeyEvent::DOM_VK_UP ||
     1:       aKey == nsIDOMKeyEvent::DOM_VK_DOWN ||
     1:       aKey == nsIDOMKeyEvent::DOM_VK_PAGE_UP ||
     1:       aKey == nsIDOMKeyEvent::DOM_VK_PAGE_DOWN)
     1:   {
     1:     // Prevent the input from handling up/down events, as it may move
     1:     // the cursor to home/end on some systems
 80486:     *_retval = true;
     1: 
 79445:     bool isOpen = false;
 13311:     input->GetPopupOpen(&isOpen);
     1:     if (isOpen) {
 79445:       bool reverse = aKey == nsIDOMKeyEvent::DOM_VK_UP ||
 80486:                       aKey == nsIDOMKeyEvent::DOM_VK_PAGE_UP ? true : false;
 79445:       bool page = aKey == nsIDOMKeyEvent::DOM_VK_PAGE_UP ||
 80486:                     aKey == nsIDOMKeyEvent::DOM_VK_PAGE_DOWN ? true : false;
     1: 
     1:       // Fill in the value of the textbox with whatever is selected in the popup
     1:       // if the completeSelectedIndex attribute is set.  We check this before
 13311:       // calling SelectBy of an earlier attempt to avoid crashing.
 79445:       bool completeSelection;
 13311:       input->GetCompleteSelectedIndex(&completeSelection);
     1: 
     1:       // Instruct the result view to scroll by the given amount and direction
     1:       popup->SelectBy(reverse, page);
     1: 
     1:       if (completeSelection)
     1:       {
108991:         int32_t selectedIndex;
     1:         popup->GetSelectedIndex(&selectedIndex);
     1:         if (selectedIndex >= 0) {
     1:           //  A result is selected, so fill in its value
     1:           nsAutoString value;
198844:           if (NS_SUCCEEDED(GetResultValueAt(selectedIndex, false, value))) {
 13311:             input->SetTextValue(value);
 13311:             input->SelectTextRange(value.Length(), value.Length());
     1:           }
     1:         } else {
     1:           // Nothing is selected, so fill in the last typed value
 13311:           input->SetTextValue(mSearchString);
 13311:           input->SelectTextRange(mSearchString.Length(), mSearchString.Length());
     1:         }
     1:       }
     1:     } else {
 14069: #ifdef XP_MACOSX
 14069:       // on Mac, only show the popup if the caret is at the start or end of
 14069:       // the input and there is no selection, so that the default defined key
 14069:       // shortcuts for up and down move to the beginning and end of the field
 14069:       // otherwise.
108991:       int32_t start, end;
 14069:       if (aKey == nsIDOMKeyEvent::DOM_VK_UP) {
 14069:         input->GetSelectionStart(&start);
 14069:         input->GetSelectionEnd(&end);
 14069:         if (start > 0 || start != end)
 80486:           *_retval = false;
 14069:       }
 14069:       else if (aKey == nsIDOMKeyEvent::DOM_VK_DOWN) {
 14069:         nsAutoString text;
 14069:         input->GetTextValue(text);
 14069:         input->GetSelectionStart(&start);
 14069:         input->GetSelectionEnd(&end);
108991:         if (start != end || end < (int32_t)text.Length())
 80486:           *_retval = false;
 14069:       }
 14069: #endif
 14069:       if (*_retval) {
     1:         // Open the popup if there has been a previous search, or else kick off a new search
131687:         if (!mResults.IsEmpty()) {
     1:           if (mRowCount) {
     1:             OpenPopup();
     1:           }
 43921:         } else {
 43921:           // Stop all searches in case they are async.
 43921:           StopSearch();
 43921: 
 43921:           if (!mInput) {
 61564:             // StopSearch() can call PostSearchCleanup() which might result
 61564:             // in a blur event, which could null out mInput, so we need to check it
 61564:             // again.  See bug #395344 for more details
 43921:             return NS_OK;
 43921:           }
 43921: 
 91356:           StartSearches();
     1:         }
 14069:       }
 43921:     }
     1:   } else if (   aKey == nsIDOMKeyEvent::DOM_VK_LEFT
     1:              || aKey == nsIDOMKeyEvent::DOM_VK_RIGHT
     1: #ifndef XP_MACOSX
     1:              || aKey == nsIDOMKeyEvent::DOM_VK_HOME
     1: #endif
     1:             )
     1:   {
     1:     // The user hit a text-navigation key.
 79445:     bool isOpen = false;
 13311:     input->GetPopupOpen(&isOpen);
     1:     if (isOpen) {
108991:       int32_t selectedIndex;
     1:       popup->GetSelectedIndex(&selectedIndex);
 79445:       bool shouldComplete;
 28774:       input->GetCompleteDefaultIndex(&shouldComplete);
     1:       if (selectedIndex >= 0) {
     1:         // The pop-up is open and has a selection, take its value
     1:         nsAutoString value;
198844:         if (NS_SUCCEEDED(GetResultValueAt(selectedIndex, false, value))) {
 13311:           input->SetTextValue(value);
 13311:           input->SelectTextRange(value.Length(), value.Length());
     1:         }
     1:       }
 28639:       else if (shouldComplete) {
 28639:         // We usually try to preserve the casing of what user has typed, but
 28639:         // if he wants to autocomplete, we will replace the value with the
 28639:         // actual autocomplete result.
 28639:         // The user wants explicitely to use that result, so this ensures
 28639:         // association of the result with the autocompleted text.
 28639:         nsAutoString value;
100136:         nsAutoString inputValue;
100136:         input->GetTextValue(inputValue);
100136:         if (NS_SUCCEEDED(GetDefaultCompleteValue(-1, false, value)) &&
100136:             value.Equals(inputValue, nsCaseInsensitiveStringComparator())) {
 28639:           input->SetTextValue(value);
 28639:           input->SelectTextRange(value.Length(), value.Length());
 28639:         }
 28639:       }
     1:       // Close the pop-up even if nothing was selected
     1:       ClearSearchTimer();
     1:       ClosePopup();
     1:     }
     1:     // Update last-searched string to the current input, since the input may
     1:     // have changed.  Without this, subsequent backspaces look like text
     1:     // additions, not text deletions.
     1:     nsAutoString value;
 13311:     input->GetTextValue(value);
     1:     mSearchString = value;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsAutoCompleteController::HandleDelete(bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   if (!mInput)
     1:     return NS_OK;
     1: 
 13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
 79445:   bool isOpen = false;
 13311:   input->GetPopupOpen(&isOpen);
     1:   if (!isOpen || mRowCount <= 0) {
     1:     // Nothing left to delete, proceed as normal
 30200:     HandleText();
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIAutoCompletePopup> popup;
 13311:   input->GetPopup(getter_AddRefs(popup));
     1: 
108991:   int32_t index, searchIndex, rowIndex;
     1:   popup->GetSelectedIndex(&index);
126827:   if (index == -1) {
126827:     // No row is selected in the list
126827:     HandleText();
126827:     return NS_OK;
126827:   }
126827: 
     1:   RowIndexToSearch(index, &searchIndex, &rowIndex);
     1:   NS_ENSURE_TRUE(searchIndex >= 0 && rowIndex >= 0, NS_ERROR_FAILURE);
     1: 
 21610:   nsIAutoCompleteResult *result = mResults[searchIndex];
     1:   NS_ENSURE_TRUE(result, NS_ERROR_FAILURE);
     1: 
     1:   nsAutoString search;
 13311:   input->GetSearchParam(search);
     1: 
     1:   // Clear the row in our result and in the DB.
 80486:   result->RemoveValueAt(rowIndex, true);
     1:   --mRowCount;
     1: 
 32086:   // We removed it, so make sure we cancel the event that triggered this call.
 80486:   *_retval = true;
 32086: 
     1:   // Unselect the current item.
     1:   popup->SetSelectedIndex(-1);
     1: 
     1:   // Tell the tree that the row count changed.
     1:   if (mTree)
     1:     mTree->RowCountChanged(mRowCount, -1);
     1: 
     1:   // Adjust index, if needed.
108991:   if (index >= (int32_t)mRowCount)
     1:     index = mRowCount - 1;
     1: 
     1:   if (mRowCount > 0) {
     1:     // There are still rows in the popup, select the current index again.
     1:     popup->SetSelectedIndex(index);
     1: 
     1:     // Complete to the new current value.
 79445:     bool shouldComplete = false;
129746:     input->GetCompleteDefaultIndex(&shouldComplete);
 19422:     if (shouldComplete) {
     1:       nsAutoString value;
198844:       if (NS_SUCCEEDED(GetResultValueAt(index, false, value))) {
 19422:         CompleteValue(value);
     1:       }
 19422:     }
     1: 
     1:     // Invalidate the popup.
     1:     popup->Invalidate();
     1:   } else {
     1:     // Nothing left in the popup, clear any pending search timers and
     1:     // close the popup.
     1:     ClearSearchTimer();
131055:     uint32_t minResults;
131055:     input->GetMinResultsForPopup(&minResults);
131055:     if (minResults) {
     1:       ClosePopup();
     1:     }
131055:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 52364: nsresult 
108991: nsAutoCompleteController::GetResultAt(int32_t aIndex, nsIAutoCompleteResult** aResult,
108991:                                       int32_t* aRowIndex)
 52364: {
108991:   int32_t searchIndex;
 52364:   RowIndexToSearch(aIndex, &searchIndex, aRowIndex);
 52364:   NS_ENSURE_TRUE(searchIndex >= 0 && *aRowIndex >= 0, NS_ERROR_FAILURE);
 52364: 
 52364:   *aResult = mResults[searchIndex];
 52364:   NS_ENSURE_TRUE(*aResult, NS_ERROR_FAILURE);
 52364:   return NS_OK;
 52364: }
 52364: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetValueAt(int32_t aIndex, nsAString & _retval)
     1: {
198844:   GetResultLabelAt(aIndex, _retval);
 52364: 
 52364:   return NS_OK;
 52364: }
 52364: 
 52364: NS_IMETHODIMP
108991: nsAutoCompleteController::GetLabelAt(int32_t aIndex, nsAString & _retval)
 52364: {
198844:   GetResultLabelAt(aIndex, _retval);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetCommentAt(int32_t aIndex, nsAString & _retval)
     1: {
108991:   int32_t rowIndex;
 52364:   nsIAutoCompleteResult* result;
 52364:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
 52364:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
  3718:   return result->GetCommentAt(rowIndex, _retval);
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetStyleAt(int32_t aIndex, nsAString & _retval)
     1: {
108991:   int32_t rowIndex;
 52364:   nsIAutoCompleteResult* result;
 52364:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
 52364:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
  3718:   return result->GetStyleAt(rowIndex, _retval);
  3718: }
     1: 
  3718: NS_IMETHODIMP
108991: nsAutoCompleteController::GetImageAt(int32_t aIndex, nsAString & _retval)
  3718: {
108991:   int32_t rowIndex;
 52364:   nsIAutoCompleteResult* result;
 52364:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
 52364:   NS_ENSURE_SUCCESS(rv, rv);
  3718: 
  3718:   return result->GetImageAt(rowIndex, _retval);
     1: }
     1: 
     1: NS_IMETHODIMP
198844: nsAutoCompleteController::GetFinalCompleteValueAt(int32_t aIndex,
198844:                                                   nsAString & _retval)
198844: {
198844:   int32_t rowIndex;
198844:   nsIAutoCompleteResult* result;
198844:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
198844:   NS_ENSURE_SUCCESS(rv, rv);
198844: 
198844:   return result->GetFinalCompleteValueAt(rowIndex, _retval);
198844: }
198844: 
198844: NS_IMETHODIMP
     1: nsAutoCompleteController::SetSearchString(const nsAString &aSearchString)
     1: {
     1:   mSearchString = aSearchString;
     1:   return NS_OK;
     1: }
     1: 
  8459: NS_IMETHODIMP
  8459: nsAutoCompleteController::GetSearchString(nsAString &aSearchString)
  8459: {
  8459:   aSearchString = mSearchString;
  8459:   return NS_OK;
  8459: }
  8459: 
  8459: 
     1: ////////////////////////////////////////////////////////////////////////
     1: //// nsIAutoCompleteObserver
     1: 
     1: NS_IMETHODIMP
 52365: nsAutoCompleteController::OnUpdateSearchResult(nsIAutoCompleteSearch *aSearch, nsIAutoCompleteResult* aResult)
 52365: {
 52365:   ClearResults();
 52365:   return OnSearchResult(aSearch, aResult);
 52365: }
 52365: 
 52365: NS_IMETHODIMP
     1: nsAutoCompleteController::OnSearchResult(nsIAutoCompleteSearch *aSearch, nsIAutoCompleteResult* aResult)
     1: {
     1:   // look up the index of the search which is returning
131687:   for (uint32_t i = 0; i < mSearches.Length(); ++i) {
 21610:     if (mSearches[i] == aSearch) {
     1:       ProcessResult(i, aResult);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: ////////////////////////////////////////////////////////////////////////
     1: //// nsITimerCallback
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::Notify(nsITimer *timer)
     1: {
106838:   mTimer = nullptr;
 91356: 
 91356:   if (mImmediateSearchesCount == 0) {
 91356:     // If there were no immediate searches, BeforeSearches has not yet been
 91356:     // called, so do it now.
 91356:     nsresult rv = BeforeSearches();
 91356:     if (NS_FAILED(rv))
 91356:       return rv;
 91356:   }
 91356:   StartSearch(nsIAutoCompleteSearchDescriptor::SEARCH_TYPE_DELAYED);
 91356:   AfterSearches();
     1:   return NS_OK;
     1: }
     1: 
     1: ////////////////////////////////////////////////////////////////////////
     1: // nsITreeView
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetRowCount(int32_t *aRowCount)
     1: {
     1:   *aRowCount = mRowCount;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
134832: nsAutoCompleteController::GetRowProperties(int32_t index, nsAString& aProps)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
134832: nsAutoCompleteController::GetCellProperties(int32_t row, nsITreeColumn* col,
134832:                                             nsAString& aProps)
     1: {
     1:   if (row >= 0) {
134832:     GetStyleAt(row, aProps);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
134832: nsAutoCompleteController::GetColumnProperties(nsITreeColumn* col, nsAString& aProps)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetImageSrc(int32_t row, nsITreeColumn* col, nsAString& _retval)
     1: {
179103:   const char16_t* colID;
  3718:   col->GetIdConst(&colID);
  3718: 
  3718:   if (NS_LITERAL_STRING("treecolAutoCompleteValue").Equals(colID))
  3718:     return GetImageAt(row, _retval);
  3718: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetProgressMode(int32_t row, nsITreeColumn* col, int32_t* _retval)
     1: {
     1:   NS_NOTREACHED("tree has no progress cells");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetCellValue(int32_t row, nsITreeColumn* col, nsAString& _retval)
     1: {
     1:   NS_NOTREACHED("all of our cells are text");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetCellText(int32_t row, nsITreeColumn* col, nsAString& _retval)
     1: {
179103:   const char16_t* colID;
     1:   col->GetIdConst(&colID);
     1: 
     1:   if (NS_LITERAL_STRING("treecolAutoCompleteValue").Equals(colID))
     1:     GetValueAt(row, _retval);
     1:   else if (NS_LITERAL_STRING("treecolAutoCompleteComment").Equals(colID))
     1:     GetCommentAt(row, _retval);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::IsContainer(int32_t index, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::IsContainerOpen(int32_t index, bool *_retval)
     1: {
     1:   NS_NOTREACHED("no container cells");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::IsContainerEmpty(int32_t index, bool *_retval)
     1: {
     1:   NS_NOTREACHED("no container cells");
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetLevel(int32_t index, int32_t *_retval)
     1: {
     1:   *_retval = 0;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::GetParentIndex(int32_t rowIndex, int32_t *_retval)
     1: {
 15107:   *_retval = -1;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::HasNextSibling(int32_t rowIndex, int32_t afterIndex, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::ToggleOpenState(int32_t index)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::SetTree(nsITreeBoxObject *tree)
     1: {
     1:   mTree = tree;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::GetSelection(nsITreeSelection * *aSelection)
     1: {
     1:   *aSelection = mSelection;
     1:   NS_IF_ADDREF(*aSelection);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsAutoCompleteController::SetSelection(nsITreeSelection * aSelection)
     1: {
     1:   mSelection = aSelection;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::SelectionChanged()
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::SetCellValue(int32_t row, nsITreeColumn* col, const nsAString& value)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::SetCellText(int32_t row, nsITreeColumn* col, const nsAString& value)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAutoCompleteController::CycleHeader(nsITreeColumn* col)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::CycleCell(int32_t row, nsITreeColumn* col)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::IsEditable(int32_t row, nsITreeColumn* col, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::IsSelectable(int32_t row, nsITreeColumn* col, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::IsSeparator(int32_t index, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsAutoCompleteController::IsSorted(bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::CanDrop(int32_t index, int32_t orientation,
 79445:                                   nsIDOMDataTransfer* dataTransfer, bool *_retval)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsAutoCompleteController::Drop(int32_t row, int32_t orientation, nsIDOMDataTransfer* dataTransfer)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
179103: nsAutoCompleteController::PerformAction(const char16_t *action)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
179103: nsAutoCompleteController::PerformActionOnRow(const char16_t *action, int32_t row)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
179103: nsAutoCompleteController::PerformActionOnCell(const char16_t* action, int32_t row, nsITreeColumn* col)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: ////////////////////////////////////////////////////////////////////////
     1: //// nsAutoCompleteController
     1: 
     1: nsresult
     1: nsAutoCompleteController::OpenPopup()
     1: {
108991:   uint32_t minResults;
     1:   mInput->GetMinResultsForPopup(&minResults);
     1: 
     1:   if (mRowCount >= minResults) {
 80486:     return mInput->SetPopupOpen(true);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsAutoCompleteController::ClosePopup()
     1: {
     1:   if (!mInput) {
     1:     return NS_OK;
     1:   }
  8246: 
219724:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
219724: 
 79445:   bool isOpen = false;
219724:   input->GetPopupOpen(&isOpen);
  8246:   if (!isOpen)
  8246:     return NS_OK;
  8246: 
     1:   nsCOMPtr<nsIAutoCompletePopup> popup;
219724:   input->GetPopup(getter_AddRefs(popup));
106838:   NS_ENSURE_TRUE(popup != nullptr, NS_ERROR_FAILURE);
     1:   popup->SetSelectedIndex(-1);
219724:   return input->SetPopupOpen(false);
     1: }
     1: 
     1: nsresult
 91356: nsAutoCompleteController::BeforeSearches()
     1: {
     1:   NS_ENSURE_STATE(mInput);
 91356: 
     1:   mSearchStatus = nsIAutoCompleteController::STATUS_SEARCHING;
 80486:   mDefaultIndexCompleted = false;
     1: 
 91356:   // The first search result will clear mResults array, though we should pass
 91356:   // the previous result to each search to allow them to reuse it.  So we
 91356:   // temporarily cache current results till AfterSearches().
 91356:   if (!mResultCache.AppendObjects(mResults)) {
 21610:     return NS_ERROR_OUT_OF_MEMORY;
 21610:   }
 18409: 
131687:   mSearchesOngoing = mSearches.Length();
 91356:   mSearchesFailed = 0;
 80486:   mFirstSearchResult = true;
     1: 
 12047:   // notify the input that the search is beginning
 91356:   mInput->OnSearchBegin();
 12047: 
 91356:   return NS_OK;
 91356: }
 91356: 
 91356: nsresult
108991: nsAutoCompleteController::StartSearch(uint16_t aSearchType)
 91356: {
 91356:   NS_ENSURE_STATE(mInput);
 91356:   nsCOMPtr<nsIAutoCompleteInput> input = mInput;
 91356: 
131687:   for (uint32_t i = 0; i < mSearches.Length(); ++i) {
 21610:     nsCOMPtr<nsIAutoCompleteSearch> search = mSearches[i];
 91356: 
 91356:     // Filter on search type.  Not all the searches implement this interface,
 91356:     // in such a case just consider them delayed.
108991:     uint16_t searchType = nsIAutoCompleteSearchDescriptor::SEARCH_TYPE_DELAYED;
 91356:     nsCOMPtr<nsIAutoCompleteSearchDescriptor> searchDesc =
 91356:       do_QueryInterface(search);
 91356:     if (searchDesc)
 91356:       searchDesc->GetSearchType(&searchType);
 91356:     if (searchType != aSearchType)
 91356:       continue;
 91356: 
 91356:     nsIAutoCompleteResult *result = mResultCache.SafeObjectAt(i);
     1: 
     1:     if (result) {
108991:       uint16_t searchResult;
     1:       result->GetSearchResult(&searchResult);
  4881:       if (searchResult != nsIAutoCompleteResult::RESULT_SUCCESS &&
 30200:           searchResult != nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING &&
 30200:           searchResult != nsIAutoCompleteResult::RESULT_NOMATCH)
106838:         result = nullptr;
     1:     }
     1: 
     1:     nsAutoString searchParam;
 21610:     nsresult rv = input->GetSearchParam(searchParam);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
  3233:     rv = search->StartSearch(mSearchString, searchParam, result, static_cast<nsIAutoCompleteObserver *>(this));
     1:     if (NS_FAILED(rv)) {
 91356:       ++mSearchesFailed;
     1:       --mSearchesOngoing;
     1:     }
 61564:     // Because of the joy of nested event loops (which can easily happen when some
 61564:     // code uses a generator for an asynchronous AutoComplete search),
 61564:     // nsIAutoCompleteSearch::StartSearch might cause us to be detached from our input
 61564:     // field.  The next time we iterate, we'd be touching something that we shouldn't
 61564:     // be, and result in a crash.
 61560:     if (!mInput) {
 61560:       // The search operation has been finished.
 61560:       return NS_OK;
 61560:     }
     1:   }
     1: 
 91356:   return NS_OK;
 91356: }
 91356: 
 91356: void
 91356: nsAutoCompleteController::AfterSearches()
 91356: {
 91356:   mResultCache.Clear();
131687:   if (mSearchesFailed == mSearches.Length())
     1:     PostSearchCleanup();
     1: }
     1: 
  4881: NS_IMETHODIMP
     1: nsAutoCompleteController::StopSearch()
     1: {
     1:   // Stop the timer if there is one
     1:   ClearSearchTimer();
     1: 
     1:   // Stop any ongoing asynchronous searches
     1:   if (mSearchStatus == nsIAutoCompleteController::STATUS_SEARCHING) {
131687:     for (uint32_t i = 0; i < mSearches.Length(); ++i) {
 21610:       nsCOMPtr<nsIAutoCompleteSearch> search = mSearches[i];
     1:       search->StopSearch();
     1:     }
  5252:     mSearchesOngoing = 0;
  5252:     // since we were searching, but now we've stopped,
  5252:     // we need to call PostSearchCleanup()
  5252:     PostSearchCleanup();
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 91356: nsAutoCompleteController::StartSearches()
     1: {
     1:   // Don't create a new search timer if we're already waiting for one to fire.
     1:   // If we don't check for this, we won't be able to cancel the original timer
     1:   // and may crash when it fires (bug 236659).
     1:   if (mTimer || !mInput)
     1:     return NS_OK;
     1: 
219724:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
219724: 
 91356:   // Get the timeout for delayed searches.
108991:   uint32_t timeout;
219724:   input->GetTimeout(&timeout);
     1: 
108991:   uint32_t immediateSearchesCount = mImmediateSearchesCount;
 91356:   if (timeout == 0) {
 91356:     // All the searches should be executed immediately.
131687:     immediateSearchesCount = mSearches.Length();
 91356:   }
 91356: 
 91356:   if (immediateSearchesCount > 0) {
 91356:     nsresult rv = BeforeSearches();
 91356:     if (NS_FAILED(rv))
 91356:       return rv;
 91356:     StartSearch(nsIAutoCompleteSearchDescriptor::SEARCH_TYPE_IMMEDIATE);
 91356: 
131687:     if (mSearches.Length() == immediateSearchesCount) {
 91356:       // Either all searches are immediate, or the timeout is 0.  In the
 91356:       // latter case we still have to execute the delayed searches, otherwise
 91356:       // this will be a no-op.
 91356:       StartSearch(nsIAutoCompleteSearchDescriptor::SEARCH_TYPE_DELAYED);
 91356: 
 91356:       // All the searches have been started, just finish.
 91356:       AfterSearches();
 91356:       return NS_OK;
 91356:     }
 91356:   }
 91356: 
 91356:   MOZ_ASSERT(timeout > 0, "Trying to delay searches with a 0 timeout!");
 91356: 
 91356:   // Now start the delayed searches.
 13311:   nsresult rv;
 13311:   mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
 13311:   if (NS_FAILED(rv))
 13311:       return rv;
 13311:   rv = mTimer->InitWithCallback(this, timeout, nsITimer::TYPE_ONE_SHOT);
 13311:   if (NS_FAILED(rv))
106838:       mTimer = nullptr;
 13311: 
 13311:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsAutoCompleteController::ClearSearchTimer()
     1: {
     1:   if (mTimer) {
     1:     mTimer->Cancel();
106838:     mTimer = nullptr;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 79445: nsAutoCompleteController::EnterMatch(bool aIsPopupSelection)
     1: {
 13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
     1:   nsCOMPtr<nsIAutoCompletePopup> popup;
 13311:   input->GetPopup(getter_AddRefs(popup));
106838:   NS_ENSURE_TRUE(popup != nullptr, NS_ERROR_FAILURE);
     1: 
 79445:   bool forceComplete;
 13311:   input->GetForceComplete(&forceComplete);
     1: 
     1:   // Ask the popup if it wants to enter a special value into the textbox
     1:   nsAutoString value;
     1:   popup->GetOverrideValue(value);
     1:   if (value.IsEmpty()) {
 79445:     bool shouldComplete;
129746:     input->GetCompleteDefaultIndex(&shouldComplete);
 79445:     bool completeSelection;
 13311:     input->GetCompleteSelectedIndex(&completeSelection);
 12436: 
108991:     int32_t selectedIndex;
100196:     popup->GetSelectedIndex(&selectedIndex);
100196:     if (selectedIndex >= 0) {
 12436:       // If completeselectedindex is false or a row was selected from the popup,
 12436:       // enter it into the textbox. If completeselectedindex is true, or
 12436:       // EnterMatch was called via other means, for instance pressing Enter,
100196:       // don't fill in the value as it will have already been filled in as
198844:       // needed, unless the final complete value differs.
198844:       nsAutoString finalValue, inputValue;
198844:       GetResultValueAt(selectedIndex, true, finalValue);
198844:       input->GetTextValue(inputValue);
198844:       if (!completeSelection || aIsPopupSelection ||
198844:           !finalValue.Equals(inputValue)) {
198844:         value = finalValue;
198844:       }
100196:     }
 28774:     else if (shouldComplete) {
 28774:       // We usually try to preserve the casing of what user has typed, but
 28774:       // if he wants to autocomplete, we will replace the value with the
 28774:       // actual autocomplete result.
 28774:       // The user wants explicitely to use that result, so this ensures
 28774:       // association of the result with the autocompleted text.
 28774:       nsAutoString defaultIndexValue;
100196:       if (NS_SUCCEEDED(GetFinalDefaultCompleteValue(defaultIndexValue)))
 28774:         value = defaultIndexValue;
 28774:     }
     1: 
     1:     if (forceComplete && value.IsEmpty()) {
     1:       // Since nothing was selected, and forceComplete is specified, that means
  4881:       // we have to find the first default match and enter it instead
131687:       for (uint32_t i = 0; i < mResults.Length(); ++i) {
 21610:         nsIAutoCompleteResult *result = mResults[i];
     1: 
     1:         if (result) {
108991:           int32_t defaultIndex;
     1:           result->GetDefaultIndex(&defaultIndex);
     1:           if (defaultIndex >= 0) {
198844:             result->GetFinalCompleteValueAt(defaultIndex, value);
     1:             break;
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   nsCOMPtr<nsIObserverService> obsSvc =
 41540:     mozilla::services::GetObserverService();
     1:   NS_ENSURE_STATE(obsSvc);
106838:   obsSvc->NotifyObservers(input, "autocomplete-will-enter-text", nullptr);
     1: 
     1:   if (!value.IsEmpty()) {
 13311:     input->SetTextValue(value);
 13311:     input->SelectTextRange(value.Length(), value.Length());
     1:     mSearchString = value;
     1:   }
     1: 
106838:   obsSvc->NotifyObservers(input, "autocomplete-did-enter-text", nullptr);
     1:   ClosePopup();
     1: 
 79445:   bool cancel;
 13311:   input->OnTextEntered(&cancel);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsAutoCompleteController::RevertTextValue()
     1: {
  9690:   // StopSearch() can call PostSearchCleanup() which might result
  9690:   // in a blur event, which could null out mInput, so we need to check it
  9690:   // again.  See bug #408463 for more details
  9690:   if (!mInput)
  9690:     return NS_OK;
  9690: 
     1:   nsAutoString oldValue(mSearchString);
 13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
     1: 
 79445:   bool cancel = false;
 13311:   input->OnTextReverted(&cancel);
     1: 
     1:   if (!cancel) {
     1:     nsCOMPtr<nsIObserverService> obsSvc =
 41540:       mozilla::services::GetObserverService();
     1:     NS_ENSURE_STATE(obsSvc);
106838:     obsSvc->NotifyObservers(input, "autocomplete-will-revert-text", nullptr);
     1: 
 80427:     nsAutoString inputValue;
 80427:     input->GetTextValue(inputValue);
 80427:     // Don't change the value if it is the same to prevent sending useless events.
 80427:     // NOTE: how can |RevertTextValue| be called with inputValue != oldValue?
 80427:     if (!oldValue.Equals(inputValue)) {
 13311:       input->SetTextValue(oldValue);
 80427:     }
     1: 
106838:     obsSvc->NotifyObservers(input, "autocomplete-did-revert-text", nullptr);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
108991: nsAutoCompleteController::ProcessResult(int32_t aSearchIndex, nsIAutoCompleteResult *aResult)
     1: {
     1:   NS_ENSURE_STATE(mInput);
 13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
  4881: 
  4881:   // If this is the first search result we are processing
  4881:   // we should clear out the previously cached results
  4881:   if (mFirstSearchResult) {
     1:     ClearResults();
 80486:     mFirstSearchResult = false;
  4881:   }
     1: 
108991:   uint16_t result = 0;
     1:   if (aResult)
     1:     aResult->GetSearchResult(&result);
  4881: 
  4881:   // if our results are incremental, the search is still ongoing
  4881:   if (result != nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING &&
  4881:       result != nsIAutoCompleteResult::RESULT_NOMATCH_ONGOING) {
  4881:     --mSearchesOngoing;
  4881:   }
  4881: 
108991:   uint32_t oldMatchCount = 0;
108991:   uint32_t matchCount = 0;
  5160:   if (aResult)
  4881:     aResult->GetMatchCount(&matchCount);
  4881: 
108991:   int32_t resultIndex = mResults.IndexOf(aResult);
 87705:   if (resultIndex == -1) {
  4881:     // cache the result
 21610:     mResults.AppendObject(aResult);
  4881:     mMatchCounts.AppendElement(matchCount);
 87705:     resultIndex = mResults.Count() - 1;
  4881:   }
  4881:   else {
  4881:     oldMatchCount = mMatchCounts[aSearchIndex];
 87705:     mMatchCounts[resultIndex] = matchCount;
  4881:   }
  4881: 
 87704:   bool isTypeAheadResult = false;
 87704:   if (aResult) {
 87704:     aResult->GetTypeAheadResult(&isTypeAheadResult);
 87704:   }
 87704: 
 87704:   if (!isTypeAheadResult) {
108991:     uint32_t oldRowCount = mRowCount;
 87704:     // If the search failed, increase the match count to include the error
 87704:     // description.
     1:     if (result == nsIAutoCompleteResult::RESULT_FAILURE) {
     1:       nsAutoString error;
     1:       aResult->GetErrorDescription(error);
     1:       if (!error.IsEmpty()) {
     1:         ++mRowCount;
 87704:         if (mTree) {
     1:           mTree->RowCountChanged(oldRowCount, 1);
     1:         }
 87704:       }
  4881:     } else if (result == nsIAutoCompleteResult::RESULT_SUCCESS ||
  4881:                result == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {
 87704:       // Increase the match count for all matches in this result.
  4881:       mRowCount += matchCount - oldMatchCount;
  4881: 
 87704:       if (mTree) {
  4881:         mTree->RowCountChanged(oldRowCount, matchCount - oldMatchCount);
 87704:       }
     1:     }
     1: 
     1:     // Refresh the popup view to display the new search results
     1:     nsCOMPtr<nsIAutoCompletePopup> popup;
 13311:     input->GetPopup(getter_AddRefs(popup));
106838:     NS_ENSURE_TRUE(popup != nullptr, NS_ERROR_FAILURE);
     1:     popup->Invalidate();
     1: 
131055:     uint32_t minResults;
131055:     input->GetMinResultsForPopup(&minResults);
131055: 
 11083:     // Make sure the popup is open, if necessary, since we now have at least one
 11083:     // search result ready to display. Don't force the popup closed if we might
 11083:     // get results in the future to avoid unnecessarily canceling searches.
131055:     if (mRowCount || !minResults) {
     1:       OpenPopup();
 87704:     } else if (result != nsIAutoCompleteResult::RESULT_NOMATCH_ONGOING) {
     1:       ClosePopup();
 82336:     }
 87704:   }
 87704: 
 87704:   if (result == nsIAutoCompleteResult::RESULT_SUCCESS ||
 87704:       result == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {
 87704:     // Try to autocomplete the default index for this search.
 87705:     CompleteDefaultIndex(resultIndex);
 87704:   }
     1: 
  5252:   if (mSearchesOngoing == 0) {
 87704:     // If this is the last search to return, cleanup.
  5252:     PostSearchCleanup();
  5252:   }
  4881: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsAutoCompleteController::PostSearchCleanup()
     1: {
  2165:   NS_ENSURE_STATE(mInput);
 13311:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
 16003: 
108991:   uint32_t minResults;
129746:   input->GetMinResultsForPopup(&minResults);
 16003: 
 16003:   if (mRowCount || minResults == 0) {
     1:     OpenPopup();
 16003:     if (mRowCount)
     1:       mSearchStatus = nsIAutoCompleteController::STATUS_COMPLETE_MATCH;
 16003:     else
 16003:       mSearchStatus = nsIAutoCompleteController::STATUS_COMPLETE_NO_MATCH;
     1:   } else {
     1:     mSearchStatus = nsIAutoCompleteController::STATUS_COMPLETE_NO_MATCH;
     1:     ClosePopup();
     1:   }
     1: 
     1:   // notify the input that the search is complete
 13311:   input->OnSearchComplete();
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsAutoCompleteController::ClearResults()
     1: {
108991:   int32_t oldRowCount = mRowCount;
     1:   mRowCount = 0;
 21610:   mResults.Clear();
  4881:   mMatchCounts.Clear();
  8988:   if (oldRowCount != 0) {
  8988:     if (mTree)
     1:       mTree->RowCountChanged(0, -oldRowCount);
  8988:     else if (mInput) {
  8988:       nsCOMPtr<nsIAutoCompletePopup> popup;
  8988:       mInput->GetPopup(getter_AddRefs(popup));
106838:       NS_ENSURE_TRUE(popup != nullptr, NS_ERROR_FAILURE);
  8988:       // if we had a tree, RowCountChanged() would have cleared the selection
  8988:       // when the selected row was removed.  But since we don't have a tree,
  8988:       // we need to clear the selection manually.
  8988:       popup->SetSelectedIndex(-1);
  8988:     }
  8988:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
108991: nsAutoCompleteController::CompleteDefaultIndex(int32_t aResultIndex)
     1: {
 88335:   if (mDefaultIndexCompleted || mBackspaced || mSearchString.Length() == 0 || !mInput)
     1:     return NS_OK;
     1: 
219724:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
219724: 
108991:   int32_t selectionStart;
219724:   input->GetSelectionStart(&selectionStart);
108991:   int32_t selectionEnd;
219724:   input->GetSelectionEnd(&selectionEnd);
 16203: 
 16203:   // Don't try to automatically complete to the first result if there's already
 16203:   // a selection or the cursor isn't at the end of the input
 16203:   if (selectionEnd != selectionStart ||
108991:       selectionEnd != (int32_t)mSearchString.Length())
 16203:     return NS_OK;
 16203: 
 79445:   bool shouldComplete;
219724:   input->GetCompleteDefaultIndex(&shouldComplete);
     1:   if (!shouldComplete)
     1:     return NS_OK;
     1: 
 28639:   nsAutoString resultValue;
 87705:   if (NS_SUCCEEDED(GetDefaultCompleteValue(aResultIndex, true, resultValue)))
 28639:     CompleteValue(resultValue);
 28639: 
 80486:   mDefaultIndexCompleted = true;
 28639: 
 28639:   return NS_OK;
 28639: }
 28639: 
 28639: nsresult
108991: nsAutoCompleteController::GetDefaultCompleteResult(int32_t aResultIndex,
100196:                                                    nsIAutoCompleteResult** _result,
108991:                                                    int32_t* _defaultIndex)
 28639: {
100196:   *_defaultIndex = -1;
108991:   int32_t resultIndex = aResultIndex;
100196: 
100196:   // If a result index was not provided, find the first defaultIndex result.
108991:   for (int32_t i = 0; resultIndex < 0 && i < mResults.Count(); ++i) {
100136:     nsIAutoCompleteResult *result = mResults[i];
100196:     if (result &&
100196:         NS_SUCCEEDED(result->GetDefaultIndex(_defaultIndex)) &&
100196:         *_defaultIndex >= 0) {
100196:       resultIndex = i;
100136:     }
100136:   }
100196:   NS_ENSURE_TRUE(resultIndex >= 0, NS_ERROR_FAILURE);
 99885: 
100196:   *_result = mResults.SafeObjectAt(resultIndex);
100196:   NS_ENSURE_TRUE(*_result, NS_ERROR_FAILURE);
 28639: 
100196:   if (*_defaultIndex < 0) {
     1:     // The search must explicitly provide a default index in order
 28639:     // for us to be able to complete.
100196:     (*_result)->GetDefaultIndex(_defaultIndex);
 28639:   }
100196: 
100196:   if (*_defaultIndex < 0) {
 87704:     // We were given a result index, but that result doesn't want to
 87704:     // be autocompleted.
 87704:     return NS_ERROR_FAILURE;
 87704:   }
     1: 
 88082:   // If the result wrongly notifies a RESULT_SUCCESS with no matches, or
 88082:   // provides a defaultIndex greater than its matchCount, avoid trying to
 88082:   // complete to an empty value.
108991:   uint32_t matchCount = 0;
100196:   (*_result)->GetMatchCount(&matchCount);
 88082:   // Here defaultIndex is surely non-negative, so can be cast to unsigned.
108991:   if ((uint32_t)(*_defaultIndex) >= matchCount) {
 88082:     return NS_ERROR_FAILURE;
100196:   }
100196: 
100196:   return NS_OK;
100196: }
100196: 
100196: nsresult
108991: nsAutoCompleteController::GetDefaultCompleteValue(int32_t aResultIndex,
100196:                                                   bool aPreserveCasing,
100196:                                                   nsAString &_retval)
100196: {
100196:   nsIAutoCompleteResult *result;
108991:   int32_t defaultIndex = -1;
100196:   nsresult rv = GetDefaultCompleteResult(aResultIndex, &result, &defaultIndex);
100196:   if (NS_FAILED(rv)) return rv;
 88082: 
     1:   nsAutoString resultValue;
     1:   result->GetValueAt(defaultIndex, resultValue);
 28639:   if (aPreserveCasing &&
 28639:       StringBeginsWith(resultValue, mSearchString,
 28639:                        nsCaseInsensitiveStringComparator())) {
 28639:     // We try to preserve user casing, otherwise we would end up changing
 28639:     // the case of what he typed, if we have a result with a different casing.
 28639:     // For example if we have result "Test", and user starts writing "tuna",
 28639:     // after digiting t, we would convert it to T trying to autocomplete "Test".
 28639:     // We will still complete to cased "Test" if the user explicitely choose
 28639:     // that result, by either selecting it in the results popup, or with
 28639:     // keyboard navigation or if autocompleting in the middle.
 28639:     nsAutoString casedResultValue;
 28639:     casedResultValue.Assign(mSearchString);
 28639:     // Use what the user has typed so far.
 28639:     casedResultValue.Append(Substring(resultValue,
 28639:                                       mSearchString.Length(),
 28639:                                       resultValue.Length()));
 28639:     _retval = casedResultValue;
 28639:   }
 28639:   else
 28639:     _retval = resultValue;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
100196: nsAutoCompleteController::GetFinalDefaultCompleteValue(nsAString &_retval)
100196: {
129746:   MOZ_ASSERT(mInput, "Must have a valid input");
219724:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
100196:   nsIAutoCompleteResult *result;
108991:   int32_t defaultIndex = -1;
100196:   nsresult rv = GetDefaultCompleteResult(-1, &result, &defaultIndex);
100196:   if (NS_FAILED(rv)) return rv;
100196: 
100196:   result->GetValueAt(defaultIndex, _retval);
100196:   nsAutoString inputValue;
219724:   input->GetTextValue(inputValue);
100196:   if (!_retval.Equals(inputValue, nsCaseInsensitiveStringComparator())) {
100196:     return NS_ERROR_FAILURE;
100196:   }
100196: 
198844:   nsAutoString finalCompleteValue;
198844:   rv = result->GetFinalCompleteValueAt(defaultIndex, finalCompleteValue);
198844:   if (NS_SUCCEEDED(rv)) {
198844:     _retval = finalCompleteValue;
100196:   }
100196: 
114589:   MOZ_ASSERT(FindInReadable(inputValue, _retval, nsCaseInsensitiveStringComparator()),
114589:              "Return value must include input value.");
100196:   return NS_OK;
100196: }
100196: 
100196: nsresult
 19422: nsAutoCompleteController::CompleteValue(nsString &aValue)
     1: /* mInput contains mSearchString, which we want to autocomplete to aValue.  If
     1:  * selectDifference is true, select the remaining portion of aValue not
     1:  * contained in mSearchString. */
     1: {
129746:   MOZ_ASSERT(mInput, "Must have a valid input");
219724:   nsCOMPtr<nsIAutoCompleteInput> input(mInput);
108991:   const int32_t mSearchStringLength = mSearchString.Length();
108991:   int32_t endSelect = aValue.Length();  // By default, select all of aValue.
     1: 
     1:   if (aValue.IsEmpty() ||
     1:       StringBeginsWith(aValue, mSearchString,
     1:                        nsCaseInsensitiveStringComparator())) {
     1:     // aValue is empty (we were asked to clear mInput), or mSearchString
     1:     // matches the beginning of aValue.  In either case we can simply
     1:     // autocomplete to aValue.
219724:     input->SetTextValue(aValue);
     1:   } else {
 70927:     nsresult rv;
 70927:     nsCOMPtr<nsIIOService> ios = do_GetService(NS_IOSERVICE_CONTRACTID, &rv);
 70927:     NS_ENSURE_SUCCESS(rv, rv);
110974:     nsAutoCString scheme;
 70927:     if (NS_SUCCEEDED(ios->ExtractScheme(NS_ConvertUTF16toUTF8(aValue), scheme))) {
 70927:       // Trying to autocomplete a URI from somewhere other than the beginning.
 70927:       // Only succeed if the missing portion is "http://"; otherwise do not
 70927:       // autocomplete.  This prevents us from "helpfully" autocompleting to a
 70927:       // URI that isn't equivalent to what the user expected.
108991:       const int32_t findIndex = 7; // length of "http://"
 70927: 
 70927:       if ((endSelect < findIndex + mSearchStringLength) ||
 70927:           !scheme.LowerCaseEqualsLiteral("http") ||
 70927:           !Substring(aValue, findIndex, mSearchStringLength).Equals(
 70927:             mSearchString, nsCaseInsensitiveStringComparator())) {
 70927:         return NS_OK;
 70927:       }
 70927: 
219724:       input->SetTextValue(mSearchString +
 70927:                           Substring(aValue, mSearchStringLength + findIndex,
 70927:                                     endSelect));
 70927: 
 70927:       endSelect -= findIndex; // We're skipping this many characters of aValue.
 70927:     } else {
 70927:       // Autocompleting something other than a URI from the middle.
 19422:       // Use the format "searchstring >> full string" to indicate to the user
 19422:       // what we are going to replace their search string with.
219724:       input->SetTextValue(mSearchString + NS_LITERAL_STRING(" >> ") + aValue);
 70927: 
 19422:       endSelect = mSearchString.Length() + 4 + aValue.Length();
 19422:     }
 70927:   }
     1: 
219724:   input->SelectTextRange(mSearchStringLength, endSelect);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
198844: nsAutoCompleteController::GetResultLabelAt(int32_t aIndex, nsAString & _retval)
 52364: {
198844:   return GetResultValueLabelAt(aIndex, false, false, _retval);
 52364: }
 52364: 
 52364: nsresult
198844: nsAutoCompleteController::GetResultValueAt(int32_t aIndex, bool aGetFinalValue,
198844:                                            nsAString & _retval)
     1: {
198844:   return GetResultValueLabelAt(aIndex, aGetFinalValue, true, _retval);
 52364: }
 52364: 
 52364: nsresult
198844: nsAutoCompleteController::GetResultValueLabelAt(int32_t aIndex,
198844:                                                 bool aGetFinalValue,
198844:                                                 bool aGetValue,
198844:                                                 nsAString & _retval)
 52364: {
108991:   NS_ENSURE_TRUE(aIndex >= 0 && (uint32_t) aIndex < mRowCount, NS_ERROR_ILLEGAL_VALUE);
     1: 
108991:   int32_t rowIndex;
 52364:   nsIAutoCompleteResult *result;
 52364:   nsresult rv = GetResultAt(aIndex, &result, &rowIndex);
 52364:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
108991:   uint16_t searchResult;
     1:   result->GetSearchResult(&searchResult);
     1: 
     1:   if (searchResult == nsIAutoCompleteResult::RESULT_FAILURE) {
198844:     if (aGetValue)
     1:       return NS_ERROR_FAILURE;
     1:     result->GetErrorDescription(_retval);
  4881:   } else if (searchResult == nsIAutoCompleteResult::RESULT_SUCCESS ||
  4881:              searchResult == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {
198844:     if (aGetFinalValue)
198844:       result->GetFinalCompleteValueAt(rowIndex, _retval);
198844:     else if (aGetValue)
     1:       result->GetValueAt(rowIndex, _retval);
 52364:     else
 52364:       result->GetLabelAt(rowIndex, _retval);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
  3188: /**
  3188:  * Given the index of a row in the autocomplete popup, find the
  3188:  * corresponding nsIAutoCompleteSearch index, and sub-index into
  3188:  * the search's results list.
  3188:  */
     1: nsresult
108991: nsAutoCompleteController::RowIndexToSearch(int32_t aRowIndex, int32_t *aSearchIndex, int32_t *aItemIndex)
     1: {
     1:   *aSearchIndex = -1;
     1:   *aItemIndex = -1;
     1: 
108991:   uint32_t index = 0;
  3188: 
  3188:   // Move index through the results of each registered nsIAutoCompleteSearch
  3188:   // until we find the given row
131687:   for (uint32_t i = 0; i < mSearches.Length(); ++i) {
 21875:     nsIAutoCompleteResult *result = mResults.SafeObjectAt(i);
     1:     if (!result)
     1:       continue;
     1: 
108991:     uint32_t rowCount = 0;
 87704: 
 87704:     // Skip past the result completely if it is marked as hidden
 87704:     bool isTypeAheadResult = false;
 87704:     result->GetTypeAheadResult(&isTypeAheadResult);
 87704: 
 87704:     if (!isTypeAheadResult) {
108991:       uint16_t searchResult;
     1:       result->GetSearchResult(&searchResult);
     1: 
  3188:       // Find out how many results were provided by the
 87704:       // current nsIAutoCompleteSearch.
  4881:       if (searchResult == nsIAutoCompleteResult::RESULT_SUCCESS ||
  4881:           searchResult == nsIAutoCompleteResult::RESULT_SUCCESS_ONGOING) {
     1:         result->GetMatchCount(&rowCount);
     1:       }
 87704:     }
     1: 
  3188:     // If the given row index is within the results range
  3188:     // of the current nsIAutoCompleteSearch then return the
  3188:     // search index and sub-index into the results array
108991:     if ((rowCount != 0) && (index + rowCount-1 >= (uint32_t) aRowIndex)) {
     1:       *aSearchIndex = i;
     1:       *aItemIndex = aRowIndex - index;
     1:       return NS_OK;
     1:     }
     1: 
  3188:     // Advance the popup table index cursor past the
  3188:     // results of the current search.
     1:     index += rowCount;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsAutoCompleteController)
     1: NS_GENERIC_FACTORY_CONSTRUCTOR(nsAutoCompleteSimpleResult)
     1: 
 46998: NS_DEFINE_NAMED_CID(NS_AUTOCOMPLETECONTROLLER_CID);
 46998: NS_DEFINE_NAMED_CID(NS_AUTOCOMPLETESIMPLERESULT_CID);
     1: 
 46998: static const mozilla::Module::CIDEntry kAutoCompleteCIDs[] = {
165161:   { &kNS_AUTOCOMPLETECONTROLLER_CID, false, nullptr, nsAutoCompleteControllerConstructor },
165161:   { &kNS_AUTOCOMPLETESIMPLERESULT_CID, false, nullptr, nsAutoCompleteSimpleResultConstructor },
165161:   { nullptr }
     1: };
     1: 
 46998: static const mozilla::Module::ContractIDEntry kAutoCompleteContracts[] = {
 46998:   { NS_AUTOCOMPLETECONTROLLER_CONTRACTID, &kNS_AUTOCOMPLETECONTROLLER_CID },
 46998:   { NS_AUTOCOMPLETESIMPLERESULT_CONTRACTID, &kNS_AUTOCOMPLETESIMPLERESULT_CID },
165161:   { nullptr }
 46998: };
 46998: 
 46998: static const mozilla::Module kAutoCompleteModule = {
 46998:   mozilla::Module::kVersion,
 46998:   kAutoCompleteCIDs,
 46998:   kAutoCompleteContracts
 46998: };
 46998: 
 46998: NSMODULE_DEFN(tkAutoCompleteModule) = &kAutoCompleteModule;
