 9499: /* -*- Mode: Objective-C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is 
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Josh Aas <josh@mozilla.com>
 7242:  *   Colin Barrett <cbarrett@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCocoaWindow.h"
    1: 
11978: #include "nsObjCExceptions.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIRollupListener.h"
    1: #include "nsChildView.h"
14885: #include "nsWindowMap.h"
26321: #include "nsAppShell.h"
    1: #include "nsIAppShell.h"
    1: #include "nsIAppShellService.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIXULWindow.h"
  235: #include "nsIPrefService.h"
  235: #include "nsIPrefBranch.h"
 7634: #include "nsToolkit.h"
 8590: #include "nsPrintfCString.h"
29018: #include "nsIServiceManager.h"
29018: #include "nsIDOMWindow.h"
29018: #include "nsPIDOMWindow.h"
29018: #include "nsIDOMElement.h"
11675: #include "nsThreadUtils.h"
13608: #include "nsMenuBarX.h"
15578: #include "nsMenuUtilsX.h"
20467: #include "nsStyleConsts.h"
20506: #include "nsNativeThemeColors.h"
27993: #include "nsChildView.h"
36806: #include "nsIMenuRollup.h"
    1: 
14002: #include "gfxPlatform.h"
27035: #include "qcms.h"
14002: 
38805: namespace mozilla {
38805: namespace layers {
38805: class LayerManager;
38805: }
38805: }
38805: using namespace mozilla::layers;
38805: 
26321: // defined in nsAppShell.mm
26321: extern nsCocoaAppModalWindowList *gCocoaAppModalWindowList;
26321: 
 6111: PRInt32 gXULModalLevel = 0;
26321: 
13491: // In principle there should be only one app-modal window at any given time.
13491: // But sometimes, despite our best efforts, another window appears above the
13491: // current app-modal window.  So we need to keep a linked list of app-modal
13491: // windows.  (A non-sheet window that appears above an app-modal window is
13491: // also made app-modal.)  See nsCocoaWindow::SetModal().
26321: nsCocoaWindowList *gGeckoAppModalWindowList = NULL;
 6111: 
28346: PRBool gConsumeRollupEvent;
28346: 
    1: // defined in nsMenuBarX.mm
    1: extern NSMenu* sApplicationMenu; // Application menu shared by all menubars
    1: 
    1: // defined in nsChildView.mm
    1: extern nsIRollupListener * gRollupListener;
36806: extern nsIMenuRollup     * gMenuRollup;
    1: extern nsIWidget         * gRollupWidget;
    1: extern BOOL                gSomeMenuBarPainted;
    1: 
36750: extern "C" {
36750:   // CGSPrivate.h
36750:   typedef NSInteger CGSConnection;
36750:   typedef NSInteger CGSWindow;
37144:   typedef NSUInteger CGSWindowFilterRef;
36750:   extern CGSConnection _CGSDefaultConnection(void);
36750:   extern CGError CGSSetWindowShadowAndRimParameters(const CGSConnection cid, CGSWindow wid, float standardDeviation, float density, int offsetX, int offsetY, unsigned int flags);
37144:   extern CGError CGSNewCIFilterByName(CGSConnection cid, CFStringRef filterName, CGSWindowFilterRef *outFilter);
37144:   extern CGError CGSSetCIFilterValuesFromDictionary(CGSConnection cid, CGSWindowFilterRef filter, CFDictionaryRef filterValues);
37144:   extern CGError CGSAddWindowFilter(CGSConnection cid, CGSWindow wid, CGSWindowFilterRef filter, NSInteger flags);
37144:   extern CGError CGSRemoveWindowFilter(CGSConnection cid, CGSWindow wid, CGSWindowFilterRef filter);
37144:   extern CGError CGSReleaseCIFilter(CGSConnection cid, CGSWindowFilterRef filter);
36750: }
36750: 
    1: #define NS_APPSHELLSERVICE_CONTRACTID "@mozilla.org/appshell/appShellService;1"
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED1(nsCocoaWindow, Inherited, nsPIWidgetCocoa)
    1: 
 5900: // A note on testing to see if your object is a sheet...
 5900: // |mWindowType == eWindowType_sheet| is true if your gecko nsIWidget is a sheet
 5900: // widget - whether or not the sheet is showing. |[mWindow isSheet]| will return
 5900: // true *only when the sheet is actually showing*. Choose your test wisely.
 5900: 
 2314: // roll up any popup windows
 2314: static void RollUpPopups()
 2314: {
 2314:   if (gRollupListener && gRollupWidget)
29148:     gRollupListener->Rollup(nsnull, nsnull);
 2314: }
 2314: 
    1: nsCocoaWindow::nsCocoaWindow()
    1: : mParent(nsnull)
    1: , mWindow(nil)
    1: , mDelegate(nil)
    1: , mSheetWindowParent(nil)
    1: , mPopupContentView(nil)
36750: , mShadowStyle(NS_STYLE_WINDOW_SHADOW_DEFAULT)
37144: , mWindowFilter(0)
    1: , mWindowMadeHere(PR_FALSE)
    1: , mSheetNeedsShow(PR_FALSE)
30550: , mFullScreen(PR_FALSE)
 6111: , mModal(PR_FALSE)
13491: , mNumModalDescendents(0)
    1: {
    1: 
    1: }
    1: 
29540: void nsCocoaWindow::DestroyNativeWindow()
29540: {
29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
29540: 
37144:   CleanUpWindowFilter();
29540:   // We want to unhook the delegate here because we don't want events
29540:   // sent to it after this object has been destroyed.
29540:   [mWindow setDelegate:nil];
29540:   [mWindow close];
29540:   [mDelegate autorelease];
29540: 
29540:   NS_OBJC_END_TRY_ABORT_BLOCK;
29540: }
29540: 
    1: nsCocoaWindow::~nsCocoaWindow()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
27679:   // Notify the children that we're gone.  Popup windows (e.g. tooltips) can
27679:   // have nsChildView children.  'kid' is an nsChildView object if and only if
33357:   // its 'type' is 'eWindowType_child' or 'eWindowType_plugin'.
33357:   // childView->ResetParent() can change our list of children while it's
33357:   // being iterated, so the way we iterate the list must allow for this.
30427:   for (nsIWidget* kid = mLastChild; kid;) {
27679:     nsWindowType kidType;
27679:     kid->GetWindowType(kidType);
33357:     if (kidType == eWindowType_child || kidType == eWindowType_plugin) {
27679:       nsChildView* childView = static_cast<nsChildView*>(kid);
30427:       kid = kid->GetPrevSibling();
27679:       childView->ResetParent();
27679:     } else {
 3233:       nsCocoaWindow* childWindow = static_cast<nsCocoaWindow*>(kid);
    1:       childWindow->mParent = nsnull;
30427:       kid = kid->GetPrevSibling();
    1:     }
27679:   }
    1: 
32510:   if (mWindow && mWindowMadeHere) {
29540:     DestroyNativeWindow();
    1:   }
    1: 
    1:   NS_IF_RELEASE(mPopupContentView);
 6111: 
 6111:   // Deal with the possiblity that we're being destroyed while running modal.
 6111:   NS_ASSERTION(!mModal, "Widget destroyed while running modal!");
 6111:   if (mModal) {
 6111:     --gXULModalLevel;
 6111:     NS_ASSERTION(gXULModalLevel >= 0, "Wierdness setting modality!");
 6111:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
56422: static void FitRectToVisibleAreaForScreen(nsIntRect &aRect, NSScreen *screen)
 8590: {
56422:   if (!screen)
56422:     return;
56422:   
56422:   nsIntRect screenBounds(nsCocoaUtils::CocoaRectToGeckoRect([screen visibleFrame]));
56422:   
56422:   if (aRect.width > screenBounds.width) {
56422:     aRect.width = screenBounds.width;
 8590:   }
56422:   if (aRect.height > screenBounds.height) {
56422:     aRect.height = screenBounds.height;
 8590:   }
56422:   
56422:   if (aRect.x - screenBounds.x + aRect.width > screenBounds.width) {
56422:     aRect.x += screenBounds.width - (aRect.x - screenBounds.x + aRect.width);
56422:   }
56422:   if (aRect.y - screenBounds.y + aRect.height > screenBounds.height) {
56422:     aRect.y += screenBounds.height - (aRect.y - screenBounds.y + aRect.height);
56422:   }
 8590: }
 8590: 
29540: // Some applications like Camino use native popup windows
29540: // (native context menus, native tooltips)
29540: static PRBool UseNativePopupWindows()
29540: {
29540:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
29540:   if (!prefs)
29540:     return PR_FALSE;
29540: 
29540:   PRBool useNativePopupWindows;
29540:   nsresult rv = prefs->GetBoolPref("ui.use_native_popup_windows", &useNativePopupWindows);
29540:   return (NS_SUCCEEDED(rv) && useNativePopupWindows);
29540: }
29540: 
33013: nsresult nsCocoaWindow::Create(nsIWidget *aParent,
33013:                                nsNativeWidget aNativeParent,
23738:                                const nsIntRect &aRect,
    1:                                EVENT_CALLBACK aHandleEventFunction,
    1:                                nsIDeviceContext *aContext,
    1:                                nsIAppShell *aAppShell,
    1:                                nsIToolkit *aToolkit,
33013:                                nsWidgetInitData *aInitData)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
40740:   // Because the hidden window is created outside of an event loop,
40740:   // we have to provide an autorelease pool (see bug 559075).
40740:   nsAutoreleasePool localPool;
40740: 
56422:   nsIntRect newBounds = aRect;
56422:   FitRectToVisibleAreaForScreen(newBounds, [NSScreen mainScreen]);
 8590: 
33357:   // Set defaults which can be overriden from aInitData in BaseCreate
33357:   mWindowType = eWindowType_toplevel;
33357:   mBorderStyle = eBorderStyle_default;
33357: 
56422:   Inherited::BaseCreate(aParent, newBounds, aHandleEventFunction, aContext, aAppShell,
    1:                         aToolkit, aInitData);
    1: 
    1:   mParent = aParent;
29540: 
33013:   // Applications that use native popups don't want us to create popup windows.
33013:   if ((mWindowType == eWindowType_popup) && UseNativePopupWindows())
33013:     return NS_OK;
33013: 
56422:   nsresult rv = CreateNativeWindow(nsCocoaUtils::GeckoRectToCocoaRect(newBounds),
30549:                                    mBorderStyle, PR_FALSE);
29540:   NS_ENSURE_SUCCESS(rv, rv);
29540: 
33013:   if (mWindowType == eWindowType_popup)
56422:     return CreatePopupContentView(newBounds, aHandleEventFunction, aContext, aAppShell, aToolkit);
29540: 
29540:   return NS_OK;
29540: 
29540:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
29540: }
29540: 
29618: static unsigned int WindowMaskForBorderStyle(nsBorderStyle aBorderStyle)
29618: {
29618:   PRBool allOrDefault = (aBorderStyle == eBorderStyle_all ||
29618:                          aBorderStyle == eBorderStyle_default);
29618: 
29618:   /* Apple's docs on NSWindow styles say that "a window's style mask should
29618:    * include NSTitledWindowMask if it includes any of the others [besides
29618:    * NSBorderlessWindowMask]".  This implies that a borderless window
29618:    * shouldn't have any other styles than NSBorderlessWindowMask.
29618:    */
29618:   if (!allOrDefault && !(aBorderStyle & eBorderStyle_title))
29618:     return NSBorderlessWindowMask;
29618: 
34004:   unsigned int mask = NSTitledWindowMask;
29618:   if (allOrDefault || aBorderStyle & eBorderStyle_close)
29618:     mask |= NSClosableWindowMask;
34004:   if (allOrDefault || aBorderStyle & eBorderStyle_minimize)
34004:     mask |= NSMiniaturizableWindowMask;
29618:   if (allOrDefault || aBorderStyle & eBorderStyle_resizeh)
29618:     mask |= NSResizableWindowMask;
29618: 
29618:   return mask;
29618: }
29618: 
54312: NS_IMETHODIMP nsCocoaWindow::ReparentNativeWidget(nsIWidget* aNewParent)
54312: {
54312:   return NS_ERROR_NOT_IMPLEMENTED;
54312: }
54312: 
30549: // If aRectIsFrameRect, aRect specifies the frame rect of the new window.
30549: // Otherwise, aRect.x/y specify the position of the window's frame relative to
30549: // the bottom of the menubar and aRect.width/height specify the size of the
30549: // content rect.
30549: nsresult nsCocoaWindow::CreateNativeWindow(const NSRect &aRect,
30549:                                            nsBorderStyle aBorderStyle,
30549:                                            PRBool aRectIsFrameRect)
29540: {
29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
29540: 
29618:   // We default to NSBorderlessWindowMask, add features if needed.
    1:   unsigned int features = NSBorderlessWindowMask;
    1: 
29618:   // Configure the window we will create based on the window type.
    1:   switch (mWindowType)
    1:   {
    1:     case eWindowType_invisible:
    1:     case eWindowType_child:
33357:     case eWindowType_plugin:
48256:       break;
29618:     case eWindowType_popup:
48256:       if (aBorderStyle != eBorderStyle_default && mBorderStyle & eBorderStyle_title) {
48256:         features |= NSTitledWindowMask;
48261:         if (aBorderStyle & eBorderStyle_close) {
48261:           features |= NSClosableWindowMask;
48261:         }
48256:       }
    1:       break;
29618:     case eWindowType_toplevel:
    1:     case eWindowType_dialog:
29618:       features = WindowMaskForBorderStyle(aBorderStyle);
    1:       break;
    1:     case eWindowType_sheet:
    1:       nsWindowType parentType;
29540:       mParent->GetWindowType(parentType);
    1:       if (parentType != eWindowType_invisible &&
29540:           aBorderStyle & eBorderStyle_resizeh) {
    1:         features = NSResizableWindowMask;
    1:       }
    1:       else {
    1:         features = NSMiniaturizableWindowMask;
    1:       }
    1:       features |= NSTitledWindowMask;
    1:       break;
    1:     default:
    1:       NS_ERROR("Unhandled window type!");
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
30549:   NSRect contentRect;
30549: 
30549:   if (aRectIsFrameRect) {
30549:     contentRect = [NSWindow contentRectForFrameRect:aRect styleMask:features];
30549:   } else {
    1:     /* 
    1:      * We pass a content area rect to initialize the native Cocoa window. The
    1:      * content rect we give is the same size as the size we're given by gecko.
    1:      * The origin we're given for non-popup windows is moved down by the height
    1:      * of the menu bar so that an origin of (0,100) from gecko puts the window
    1:      * 100 pixels below the top of the available desktop area. We also move the
    1:      * origin down by the height of a title bar if it exists. This is so the
    1:      * origin that gecko gives us for the top-left of  the window turns out to
    1:      * be the top-left of the window we create. This is how it was done in
    1:      * Carbon. If it ought to be different we'll probably need to look at all
    1:      * the callers.
    1:      *
    1:      * Note: This means that if you put a secondary screen on top of your main
    1:      * screen and open a window in the top screen, it'll be incorrectly shifted
    1:      * down by the height of the menu bar. Same thing would happen in Carbon.
    1:      *
    1:      * Note: If you pass a rect with 0,0 for an origin, the window ends up in a
    1:      * weird place for some reason. This stops that without breaking popups.
    1:      */
30549:     // Compensate for difference between frame and content area height (e.g. title bar).
30549:     NSRect newWindowFrame = [NSWindow frameRectForContentRect:aRect styleMask:features];
    1: 
30549:     contentRect = aRect;
30549:     contentRect.origin.y -= (newWindowFrame.size.height - aRect.size.height);
    1: 
    1:     if (mWindowType != eWindowType_popup)
31406:       contentRect.origin.y -= [[NSApp mainMenu] menuBarHeight];
30549:   }
    1: 
    1:   // NSLog(@"Top-level window being created at Cocoa rect: %f, %f, %f, %f\n",
    1:   //       rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
    1: 
34487:   Class windowClass = [BaseWindow class];
 8121:   // If we have a titlebar on a top-level window, we want to be able to control the 
 8121:   // titlebar color (for unified windows), so use the special ToolbarWindow class. 
29540:   // Note that we need to check the window type because we mark sheets as 
 8121:   // having titlebars.
31095:   if ((mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog) &&
 7242:       (features & NSTitledWindowMask))
 3574:     windowClass = [ToolbarWindow class];
 3574:   // If we're a popup window we need to use the PopupWindow class.
 3574:   else if (mWindowType == eWindowType_popup)
 3574:     windowClass = [PopupWindow class];
 7042:   // If we're a non-popup borderless window we need to use the
 7042:   // BorderlessWindow class.
 7042:   else if (features == NSBorderlessWindowMask)
 7042:     windowClass = [BorderlessWindow class];
 7242: 
 7242:   // Create the window
30549:   mWindow = [[windowClass alloc] initWithContentRect:contentRect styleMask:features 
 9499:                                  backing:NSBackingStoreBuffered defer:YES];
    1: 
30549:   // Make sure that the content rect we gave has been honored.
30549:   NSRect wantedFrame = [mWindow frameRectForContentRect:contentRect];
30549:   if (!NSEqualRects([mWindow frame], wantedFrame)) {
30549:     // This can happen when the window is not on the primary screen.
30549:     [mWindow setFrame:wantedFrame display:NO];
30549:   }
59551:   UpdateBounds();
30549: 
29540:   if (mWindowType == eWindowType_invisible) {
29540:     [mWindow setLevel:kCGDesktopWindowLevelKey];
29853:   } else if (mWindowType == eWindowType_popup) {
48254:     SetPopupWindowLevel();
29853:     [mWindow setHasShadow:YES];
29540:   }
29540: 
29540:   [mWindow setBackgroundColor:[NSColor whiteColor]];
29540:   [mWindow setContentMinSize:NSMakeSize(60, 60)];
30495:   [mWindow disableCursorRects];
29540: 
29540:   // setup our notification delegate. Note that setDelegate: does NOT retain.
29540:   mDelegate = [[WindowDelegate alloc] initWithGeckoWindow:this];
29540:   [mWindow setDelegate:mDelegate];
29540: 
30549:   [[WindowDataMap sharedWindowDataMap] ensureDataForWindow:mWindow];
29540:   mWindowMadeHere = PR_TRUE;
29540: 
29540:   return NS_OK;
29540: 
29540:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
29540: }
29540: 
29540: NS_IMETHODIMP nsCocoaWindow::CreatePopupContentView(const nsIntRect &aRect,
29540:                              EVENT_CALLBACK aHandleEventFunction,
29540:                              nsIDeviceContext *aContext,
29540:                              nsIAppShell *aAppShell,
29540:                              nsIToolkit *aToolkit)
29540: {
29540:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
29540: 
29540:   // We need to make our content view a ChildView.
    1:   mPopupContentView = new nsChildView();
29540:   if (!mPopupContentView)
29540:     return NS_ERROR_FAILURE;
29540: 
    1:   NS_ADDREF(mPopupContentView);
    1: 
 3233:   nsIWidget* thisAsWidget = static_cast<nsIWidget*>(this);
33013:   mPopupContentView->Create(thisAsWidget, nsnull, aRect, aHandleEventFunction,
33013:                             aContext, aAppShell, aToolkit, nsnull);
    1: 
    1:   ChildView* newContentView = (ChildView*)mPopupContentView->GetNativeData(NS_NATIVE_WIDGET);
    1:   [mWindow setContentView:newContentView];
29297: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Destroy()
    1: {
    1:   if (mPopupContentView)
    1:     mPopupContentView->Destroy();
    1: 
25875:   nsBaseWidget::Destroy();
    1:   nsBaseWidget::OnDestroy();
    1: 
62309:   if (mFullScreen) {
62309:     nsCocoaUtils::HideOSChromeOnScreen(PR_FALSE, [mWindow screen]);
62309:   }
62309: 
    1:   return NS_OK;
    1: }
    1: 
14886: nsIWidget* nsCocoaWindow::GetSheetWindowParent(void)
14886: {
14886:   if (mWindowType != eWindowType_sheet)
14886:     return nsnull;
14886:   nsCocoaWindow *parent = static_cast<nsCocoaWindow*>(mParent);
14886:   while (parent && (parent->mWindowType == eWindowType_sheet))
14886:     parent = static_cast<nsCocoaWindow*>(parent->mParent);
14886:   return parent;
14886: }
14886: 
    1: void* nsCocoaWindow::GetNativeData(PRUint32 aDataType)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
11978: 
    1:   void* retVal = nsnull;
    1:   
    1:   switch (aDataType) {
    1:     // to emulate how windows works, we always have to return a NSView
    1:     // for NS_NATIVE_WIDGET
    1:     case NS_NATIVE_WIDGET:
    1:     case NS_NATIVE_DISPLAY:
    1:       retVal = [mWindow contentView];
    1:       break;
    1:       
    1:     case NS_NATIVE_WINDOW:
    1:       retVal = mWindow;
    1:       break;
    1:       
    1:     case NS_NATIVE_GRAPHIC:
    1:       // There isn't anything that makes sense to return here,
    1:       // and it doesn't matter so just return nsnull.
31561:       NS_ERROR("Requesting NS_NATIVE_GRAPHIC on a top-level window!");
    1:       break;
    1:   }
    1: 
    1:   return retVal;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::IsVisible(PRBool & aState)
    1: {
61363:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
61363: 
61363:   aState = ([mWindow isVisible] || mSheetNeedsShow);
    1:   return NS_OK;
61363: 
61363:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
 6111: NS_IMETHODIMP nsCocoaWindow::SetModal(PRBool aState)
 6111: {
40766:   // This is used during startup (outside the event loop) when creating
40766:   // the add-ons compatibility checking dialog and the profile manager UI;
40766:   // therefore, it needs to provide an autorelease pool to avoid cocoa
40766:   // objects leaking.
40766:   nsAutoreleasePool localPool;
40766: 
 6111:   mModal = aState;
13491:   nsCocoaWindow *aParent = static_cast<nsCocoaWindow*>(mParent);
 6111:   if (aState) {
 6111:     ++gXULModalLevel;
26321:     if (gCocoaAppModalWindowList)
26321:       gCocoaAppModalWindowList->PushGecko(mWindow, this);
14843:     // When a non-sheet window gets "set modal", make the window(s) that it
14843:     // appears over behave as they should.  We can't rely on native methods to
14843:     // do this, for the following reason:  The OS runs modal non-sheet windows
14843:     // in an event loop (using [NSApplication runModalForWindow:] or similar
14843:     // methods) that's incompatible with the modal event loop in nsXULWindow::
14843:     // ShowModal() (each of these event loops is "exclusive", and can't run at
14843:     // the same time as other (similar) event loops).
14843:     if (mWindowType != eWindowType_sheet) {
13491:       while (aParent) {
13491:         if (aParent->mNumModalDescendents++ == 0) {
13491:           NSWindow *aWindow = aParent->GetCocoaWindow();
13491:           if (aParent->mWindowType != eWindowType_invisible) {
13491:             [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:NO];
13491:             [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:NO];
13491:             [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:NO];
13491:           }
13491:         }
13491:         aParent = static_cast<nsCocoaWindow*>(aParent->mParent);
13491:       }
13491:       [mWindow setLevel:NSModalPanelWindowLevel];
13491:       nsCocoaWindowList *windowList = new nsCocoaWindowList;
13491:       if (windowList) {
13491:         windowList->window = this; // Don't ADDREF
26321:         windowList->prev = gGeckoAppModalWindowList;
26321:         gGeckoAppModalWindowList = windowList;
13491:       }
13491:     }
13491:   }
13491:   else {
 6111:     --gXULModalLevel;
 6111:     NS_ASSERTION(gXULModalLevel >= 0, "Mismatched call to nsCocoaWindow::SetModal(PR_FALSE)!");
26321:     if (gCocoaAppModalWindowList)
26321:       gCocoaAppModalWindowList->PopGecko(mWindow, this);
14843:     if (mWindowType != eWindowType_sheet) {
13491:       while (aParent) {
13491:         if (--aParent->mNumModalDescendents == 0) {
13491:           NSWindow *aWindow = aParent->GetCocoaWindow();
13491:           if (aParent->mWindowType != eWindowType_invisible) {
13491:             [[aWindow standardWindowButton:NSWindowCloseButton] setEnabled:YES];
13491:             [[aWindow standardWindowButton:NSWindowMiniaturizeButton] setEnabled:YES];
13491:             [[aWindow standardWindowButton:NSWindowZoomButton] setEnabled:YES];
13491:           }
13491:         }
13491:         NS_ASSERTION(aParent->mNumModalDescendents >= 0, "Widget hierarchy changed while modal!");
13491:         aParent = static_cast<nsCocoaWindow*>(aParent->mParent);
13491:       }
26321:       if (gGeckoAppModalWindowList) {
26321:         NS_ASSERTION(gGeckoAppModalWindowList->window == this, "Widget hierarchy changed while modal!");
26321:         nsCocoaWindowList *saved = gGeckoAppModalWindowList;
26321:         gGeckoAppModalWindowList = gGeckoAppModalWindowList->prev;
13491:         delete saved; // "window" not ADDREFed
13491:       }
13491:       if (mWindowType == eWindowType_popup)
48254:         SetPopupWindowLevel();
13491:       else
13491:         [mWindow setLevel:NSNormalWindowLevel];
13491:     }
 6111:   }
 6111:   return NS_OK;
 6111: }
 6111: 
    1: // Hide or show this window
    1: NS_IMETHODIMP nsCocoaWindow::Show(PRBool bState)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
12278:   // We need to re-execute sometimes in order to bring already-visible
12278:   // windows forward.
61363:   if (!mSheetNeedsShow && !bState && ![mWindow isVisible])
11899:     return NS_OK;
11899: 
    1:   nsIWidget* parentWidget = mParent;
    1:   nsCOMPtr<nsPIWidgetCocoa> piParentWidget(do_QueryInterface(parentWidget));
    1:   NSWindow* nativeParentWindow = (parentWidget) ?
    1:     (NSWindow*)parentWidget->GetNativeData(NS_NATIVE_WINDOW) : nil;
    1: 
    1:   if (bState && !mBounds.IsEmpty()) {
    1:     if (mWindowType == eWindowType_sheet) {
    1:       // bail if no parent window (its basically what we do in Carbon)
61363:       if (!nativeParentWindow || !piParentWidget)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:       NSWindow* topNonSheetWindow = nativeParentWindow;
    1:       
    1:       // If this sheet is the child of another sheet, hide the parent so that
    1:       // this sheet can be displayed. Leave the parent mSheetNeedsShow alone,
    1:       // that is only used to handle sibling sheet contention. The parent will
    1:       // return once there are no more child sheets.
    1:       PRBool parentIsSheet = PR_FALSE;
    1:       if (NS_SUCCEEDED(piParentWidget->GetIsSheet(&parentIsSheet)) &&
    1:           parentIsSheet) {
    1:         piParentWidget->GetSheetWindowParent(&topNonSheetWindow);
    1:         [NSApp endSheet:nativeParentWindow];
    1:         [nativeParentWindow setAcceptsMouseMovedEvents:NO];
    1:       }
    1: 
    1:       nsCocoaWindow* sheetShown = nsnull;
    1:       if (NS_SUCCEEDED(piParentWidget->GetChildSheet(PR_TRUE, &sheetShown)) &&
    1:           (!sheetShown || sheetShown == this)) {
    1:         // If this sheet is already the sheet actually being shown, don't
    1:         // tell it to show again. Otherwise the number of calls to
    1:         // [NSApp beginSheet...] won't match up with [NSApp endSheet...].
12066:         if (![mWindow isVisible]) {
    1:           mSheetNeedsShow = PR_FALSE;
    1:           mSheetWindowParent = topNonSheetWindow;
15026:           // Only set contextInfo if our parent isn't a sheet.
15026:           NSWindow* contextInfo = parentIsSheet ? nil : mSheetWindowParent;
14885:           [TopLevelWindowData deactivateInWindow:mSheetWindowParent];
    1:           [mWindow setAcceptsMouseMovedEvents:YES];
    1:           [NSApp beginSheet:mWindow
    1:              modalForWindow:mSheetWindowParent
    1:               modalDelegate:mDelegate
    1:              didEndSelector:@selector(didEndSheet:returnCode:contextInfo:)
15026:                 contextInfo:contextInfo];
14885:           [TopLevelWindowData activateInWindow:mWindow];
    1:           SendSetZLevelEvent();
    1:         }
    1:       }
    1:       else {
    1:         // A sibling of this sheet is active, don't show this sheet yet.
    1:         // When the active sheet hides, its brothers and sisters that have
    1:         // mSheetNeedsShow set will have their opportunities to display.
    1:         mSheetNeedsShow = PR_TRUE;
    1:       }
    1:     }
    1:     else if (mWindowType == eWindowType_popup) {
 3574:       // If a popup window is shown after being hidden, it needs to be "reset"
 3574:       // for it to receive any mouse events aside from mouse-moved events
 3574:       // (because it was removed from the "window cache" when it was hidden
 3574:       // -- see below).  Setting the window number to -1 and then back to its
 3574:       // original value seems to accomplish this.  The idea was "borrowed"
 3574:       // from the Java Embedding Plugin.
33037:       NSInteger windowNumber = [mWindow windowNumber];
 3574:       [mWindow _setWindowNumber:-1];
 3574:       [mWindow _setWindowNumber:windowNumber];
    1:       [mWindow setAcceptsMouseMovedEvents:YES];
24417:       // For reasons that aren't yet clear, calls to [NSWindow orderFront:] or
24417:       // [NSWindow makeKeyAndOrderFront:] can sometimes trigger "Error (1000)
24417:       // creating CGSWindow", which in turn triggers an internal inconsistency
24417:       // NSException.  These errors shouldn't be fatal.  So we need to wrap
24417:       // calls to ...orderFront: in LOGONLY blocks.  See bmo bug 470864.
24417:       NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
    1:       [mWindow orderFront:nil];
24417:       NS_OBJC_END_TRY_LOGONLY_BLOCK;
    1:       SendSetZLevelEvent();
36750:       AdjustWindowShadow();
37144:       SetUpWindowFilter();
 3574:       // If our popup window is a non-native context menu, tell the OS (and
 3574:       // other programs) that a menu has opened.  This is how the OS knows to
 3574:       // close other programs' context menus when ours open.
 3574:       if ([mWindow isKindOfClass:[PopupWindow class]] &&
 3574:           [(PopupWindow*) mWindow isContextMenu]) {
 3574:         [[NSDistributedNotificationCenter defaultCenter]
 3574:           postNotificationName:@"com.apple.HIToolbox.beginMenuTrackingNotification"
 3574:                         object:@"org.mozilla.gecko.PopupWindow"];
 3574:       }
 8408: 
48254:       // If a parent window was supplied and this is a popup at the parent
48254:       // level, set its child window. This will cause the child window to
48254:       // appear above the parent and move when the parent does. Setting this
48254:       // needs to happen after the _setWindowNumber calls above, otherwise the
48254:       // window doesn't focus properly.
48254:       if (nativeParentWindow && mPopupLevel == ePopupLevelParent)
 8408:         [nativeParentWindow addChildWindow:mWindow
 8408:                             ordered:NSWindowAbove];
    1:     }
    1:     else {
    1:       [mWindow setAcceptsMouseMovedEvents:YES];
24417:       NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
    1:       [mWindow makeKeyAndOrderFront:nil];
24417:       NS_OBJC_END_TRY_LOGONLY_BLOCK;
    1:       SendSetZLevelEvent();
    1:     }
    1:   }
    1:   else {
    1:     // roll up any popups if a top-level window is going away
31095:     if (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog)
 2314:       RollUpPopups();
    1: 
    1:     // now get rid of the window/sheet
    1:     if (mWindowType == eWindowType_sheet) {
11899:       if (mSheetNeedsShow) {
11899:         // This is an attempt to hide a sheet that never had a chance to
11899:         // be shown. There's nothing to do other than make sure that it
11899:         // won't show.
11899:         mSheetNeedsShow = PR_FALSE;
11899:       }
11899:       else {
    1:         // get sheet's parent *before* hiding the sheet (which breaks the linkage)
    1:         NSWindow* sheetParent = mSheetWindowParent;
    1:         
    1:         // hide the sheet
    1:         [NSApp endSheet:mWindow];
    1:         
    1:         [mWindow setAcceptsMouseMovedEvents:NO];
    1: 
14885:         [TopLevelWindowData deactivateInWindow:mWindow];
    1: 
    1:         nsCocoaWindow* siblingSheetToShow = nsnull;
    1:         PRBool parentIsSheet = PR_FALSE;
    1: 
    1:         if (nativeParentWindow && piParentWidget &&
    1:             NS_SUCCEEDED(piParentWidget->GetChildSheet(PR_FALSE, &siblingSheetToShow)) &&
    1:             siblingSheetToShow) {
    1:           // First, give sibling sheets an opportunity to show.
    1:           siblingSheetToShow->Show(PR_TRUE);
    1:         }
    1:         else if (nativeParentWindow && piParentWidget &&
    1:                  NS_SUCCEEDED(piParentWidget->GetIsSheet(&parentIsSheet)) &&
    1:                  parentIsSheet) {
15026:           // Only set contextInfo if the parent of the parent sheet we're about
15026:           // to restore isn't itself a sheet.
15026:           NSWindow* contextInfo = sheetParent;
15026:           nsIWidget* grandparentWidget = nil;
15026:           if (NS_SUCCEEDED(piParentWidget->GetRealParent(&grandparentWidget)) && grandparentWidget) {
15026:             nsCOMPtr<nsPIWidgetCocoa> piGrandparentWidget(do_QueryInterface(grandparentWidget));
15026:             PRBool grandparentIsSheet = PR_FALSE;
15026:             if (piGrandparentWidget && NS_SUCCEEDED(piGrandparentWidget->GetIsSheet(&grandparentIsSheet)) &&
15026:                 grandparentIsSheet) {
15026:                 contextInfo = nil;
15026:             }
15026:           }
    1:           // If there are no sibling sheets, but the parent is a sheet, restore
    1:           // it.  It wasn't sent any deactivate events when it was hidden, so
    1:           // don't call through Show, just let the OS put it back up.
    1:           [nativeParentWindow setAcceptsMouseMovedEvents:YES];
    1:           [NSApp beginSheet:nativeParentWindow
    1:              modalForWindow:sheetParent
    1:               modalDelegate:[nativeParentWindow delegate]
    1:              didEndSelector:@selector(didEndSheet:returnCode:contextInfo:)
15026:                 contextInfo:contextInfo];
    1:         }
    1:         else {
    1:           // Sheet, that was hard.  No more siblings or parents, going back
    1:           // to a real window.
24417:           NS_OBJC_BEGIN_TRY_LOGONLY_BLOCK;
    1:           [sheetParent makeKeyAndOrderFront:nil];
24417:           NS_OBJC_END_TRY_LOGONLY_BLOCK;
    1:           [sheetParent setAcceptsMouseMovedEvents:YES];
    1:         }
    1:         SendSetZLevelEvent();
    1:       }
    1:     }
    1:     else {
 8769:       // If the window is a popup window with a parent window we need to
 8769:       // unhook it here before ordering it out. When you order out the child
 8769:       // of a window it hides the parent window.
 8769:       if (mWindowType == eWindowType_popup && nativeParentWindow)
 8769:         [nativeParentWindow removeChildWindow:mWindow];
 8769: 
37144:       CleanUpWindowFilter();
    1:       [mWindow orderOut:nil];
 3574:       // Unless it's explicitly removed from NSApp's "window cache", a popup
 3574:       // window will keep receiving mouse-moved events even after it's been
 3574:       // "ordered out" (instead of the browser window that was underneath it,
 3574:       // until you click on that window).  This is bmo bug 378645, but it's
 3574:       // surely an Apple bug.  The "window cache" is an undocumented subsystem,
 3574:       // all of whose methods are included in the NSWindowCache category of
 3574:       // the NSApplication class (in header files generated using class-dump).
 3574:       // This workaround was "borrowed" from the Java Embedding Plugin (which
 3574:       // uses it for a different purpose).
30470:       if (mWindowType == eWindowType_popup)
 3574:         [NSApp _removeWindowFromCache:mWindow];
 8408: 
    1:       // it's very important to turn off mouse moved events when hiding a window, otherwise
    1:       // the windows' tracking rects will interfere with each other. (bug 356528)
    1:       [mWindow setAcceptsMouseMovedEvents:NO];
11899: 
 3574:       // If our popup window is a non-native context menu, tell the OS (and
 3574:       // other programs) that a menu has closed.
 3574:       if ([mWindow isKindOfClass:[PopupWindow class]] &&
 3574:           [(PopupWindow*) mWindow isContextMenu]) {
 3574:         [[NSDistributedNotificationCenter defaultCenter]
 3574:           postNotificationName:@"com.apple.HIToolbox.endMenuTrackingNotification"
 3574:                         object:@"org.mozilla.gecko.PopupWindow"];
 3574:       }
    1:     }
    1:   }
    1:   
61363:   if (mPopupContentView)
61363:       mPopupContentView->Show(bState);
61363: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
36750: struct ShadowParams {
36750:   float standardDeviation;
36750:   float density;
36750:   int offsetX;
36750:   int offsetY;
36750:   unsigned int flags;
36750: };
36750: 
36750: // These numbers have been determined by looking at the results of
36750: // CGSGetWindowShadowAndRimParameters for native window types.
36750: static const ShadowParams kWindowShadowParameters[] = {
36750:   { 0.0f, 0.0f, 0, 0, 0 },        // none
36750:   { 8.0f, 0.5f, 0, 6, 1 },        // default
36750:   { 10.0f, 0.44f, 0, 10, 512 },   // menu
36750:   { 8.0f, 0.5f, 0, 6, 1 },        // tooltip
36750:   { 4.0f, 0.6f, 0, 4, 512 }       // sheet
36750: };
36750: 
36750: // This method will adjust the window shadow style for popup windows after
36750: // they have been made visible. Before they're visible, their window number
36750: // might be -1, which is not useful.
36750: // We won't attempt to change the shadow for windows that can acquire key state
36750: // since OS X will reset the shadow whenever that happens.
36750: void
36750: nsCocoaWindow::AdjustWindowShadow()
36750: {
36750:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
36750: 
36750:   if (![mWindow isVisible] || ![mWindow hasShadow] ||
36750:       [mWindow canBecomeKeyWindow] || [mWindow windowNumber] == -1)
36750:     return;
36750: 
36750:   const ShadowParams& params = kWindowShadowParameters[mShadowStyle];
36750:   CGSConnection cid = _CGSDefaultConnection();
36750:   CGSSetWindowShadowAndRimParameters(cid, [mWindow windowNumber],
36750:                                      params.standardDeviation, params.density,
36750:                                      params.offsetX, params.offsetY,
36750:                                      params.flags);
36750: 
36750:   NS_OBJC_END_TRY_ABORT_BLOCK;
36750: }
36750: 
37144: void
37144: nsCocoaWindow::SetUpWindowFilter()
37144: {
37144:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
37144: 
37144:   if (![mWindow isVisible] || [mWindow windowNumber] == -1)
37144:     return;
37144: 
37144:   CleanUpWindowFilter();
37144: 
39095:   // Only blur the background of menus and fake sheets, but not on PPC
39095:   // because it results in blank windows (bug 547723).
39095: #ifndef __ppc__
37144:   if (mShadowStyle != NS_STYLE_WINDOW_SHADOW_MENU &&
37144:       mShadowStyle != NS_STYLE_WINDOW_SHADOW_SHEET)
39095: #endif
37144:     return;
37144: 
37144:   // Create a CoreImage filter and set it up
37144:   CGSConnection cid = _CGSDefaultConnection();
37144:   CGSNewCIFilterByName(cid, (CFStringRef)@"CIGaussianBlur", &mWindowFilter);
37144:   NSDictionary *options = [NSDictionary dictionaryWithObject:[NSNumber numberWithFloat:2.0] forKey:@"inputRadius"];
37144:   CGSSetCIFilterValuesFromDictionary(cid, mWindowFilter, (CFDictionaryRef)options);
37144: 
37144:   // Now apply the filter to the window
37144:   NSInteger compositingType = 1 << 0; // Under the window
37144:   CGSAddWindowFilter(cid, [mWindow windowNumber], mWindowFilter, compositingType);
37144: 
37144:   NS_OBJC_END_TRY_ABORT_BLOCK;
37144: }
37144: 
37144: void
37144: nsCocoaWindow::CleanUpWindowFilter()
37144: {
37144:   if (!mWindowFilter || [mWindow windowNumber] == -1)
37144:     return;
37144: 
37144:   CGSConnection cid = _CGSDefaultConnection();
37144:   CGSRemoveWindowFilter(cid, [mWindow windowNumber], mWindowFilter);
37144:   CGSReleaseCIFilter(cid, mWindowFilter);
37144:   mWindowFilter = 0;
37144: }
37144: 
30515: nsresult
30515: nsCocoaWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
30515: {
30540:   if (mPopupContentView) {
30540:     mPopupContentView->ConfigureChildren(aConfigurations);
30515:   }
30515:   return NS_OK;
30515: }
30515: 
38805: LayerManager*
58812: nsCocoaWindow::GetLayerManager(LayerManagerPersistence, bool* aAllowRetaining)
38805: {
38805:   if (mPopupContentView) {
55858:     return mPopupContentView->GetLayerManager(aAllowRetaining);
38805:   }
38805:   return nsnull;
38805: }
38805: 
16601: nsTransparencyMode nsCocoaWindow::GetTransparencyMode()
 9499: {
18401:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
16601: 
16601:   return [mWindow isOpaque] ? eTransparencyOpaque : eTransparencyTransparent;
16601: 
18401:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(eTransparencyOpaque);
 9499: }
 9499: 
 9499: // This is called from nsMenuPopupFrame when making a popup transparent.
16601: // For other window types, nsChildView::SetTransparencyMode is used.
16601: void nsCocoaWindow::SetTransparencyMode(nsTransparencyMode aMode)
 9499: {
16601:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
16601: 
16601:   BOOL isTransparent = aMode == eTransparencyTransparent;
 9499:   BOOL currentTransparency = ![mWindow isOpaque];
16601:   if (isTransparent != currentTransparency) {
34853:     [mWindow setOpaque:!isTransparent];
34853:     [mWindow setBackgroundColor:(isTransparent ? [NSColor clearColor] : [NSColor whiteColor])];
 9499:   }
16601: 
16601:   NS_OBJC_END_TRY_ABORT_BLOCK;
 9499: }
 9499: 
    1: NS_IMETHODIMP nsCocoaWindow::Enable(PRBool aState)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::IsEnabled(PRBool *aState)
    1: {
    1:   if (aState)
    1:     *aState = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::ConstrainPosition(PRBool aAllowSlop,
    1:                                                PRInt32 *aX, PRInt32 *aY)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Move(PRInt32 aX, PRInt32 aY)
    1: {
 7635:   if (!mWindow || (mBounds.x == aX && mBounds.y == aY))
 7635:     return NS_OK;
 7635: 
 7635:   // The point we have is in Gecko coordinates (origin top-left). Convert
    1:   // it to Cocoa ones (origin bottom-left).
 8779:   NSPoint coord = {aX, nsCocoaUtils::FlippedScreenY(aY)};
    1:   [mWindow setFrameTopLeftPoint:coord];
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Position the window behind the given window
    1: NS_METHOD nsCocoaWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
    1:                                      nsIWidget *aWidget, PRBool aActivate)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // Note bug 278777, we need to update state when the window is unminimized
    1: // from the dock by users.
    1: NS_METHOD nsCocoaWindow::SetSizeMode(PRInt32 aMode)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   PRInt32 previousMode;
    1:   nsBaseWidget::GetSizeMode(&previousMode);
    1: 
    1:   nsresult rv = nsBaseWidget::SetSizeMode(aMode);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aMode == nsSizeMode_Normal) {
19112:     if ([mWindow isMiniaturized])
19112:       [mWindow deminiaturize:nil];
19112:     else if (previousMode == nsSizeMode_Maximized && [mWindow isZoomed])
    1:       [mWindow zoom:nil];
    1:   }
    1:   else if (aMode == nsSizeMode_Minimized) {
    1:     if (![mWindow isMiniaturized])
    1:       [mWindow miniaturize:nil];
    1:   }
    1:   else if (aMode == nsSizeMode_Maximized) {
    1:     if ([mWindow isMiniaturized])
    1:       [mWindow deminiaturize:nil];
    1:     if (![mWindow isZoomed])
    1:       [mWindow zoom:nil];
    1:   }
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
30549: // This has to preserve the window's frame bounds.
30549: // This method requires (as does the Windows impl.) that you call Resize shortly
30549: // after calling HideWindowChrome. See bug 498835 for fixing this.
30549: NS_IMETHODIMP nsCocoaWindow::HideWindowChrome(PRBool aShouldHide)
30549: {
30549:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
30549: 
30549:   if (!mWindowMadeHere ||
30549:       (mWindowType != eWindowType_toplevel && mWindowType != eWindowType_dialog))
30549:     return NS_ERROR_FAILURE;
30549: 
30549:   BOOL isVisible = [mWindow isVisible];
30549: 
30549:   // Remove child windows.
30549:   NSArray* childWindows = [mWindow childWindows];
30549:   NSEnumerator* enumerator = [childWindows objectEnumerator];
30549:   NSWindow* child = nil;
30549:   while ((child = [enumerator nextObject])) {
30549:     [mWindow removeChildWindow:child];
30549:   }
30549: 
30549:   // Remove the content view.
30549:   NSView* contentView = [mWindow contentView];
30549:   [contentView retain];
30549:   [contentView removeFromSuperviewWithoutNeedingDisplay];
30549: 
34487:   // Save state (like window title).
34487:   NSMutableDictionary* state = [mWindow exportState];
34487: 
30549:   // Recreate the window with the right border style.
30549:   NSRect frameRect = [mWindow frame];
30549:   DestroyNativeWindow();
30549:   nsresult rv = CreateNativeWindow(frameRect, aShouldHide ? eBorderStyle_none : mBorderStyle, PR_TRUE);
30549:   NS_ENSURE_SUCCESS(rv, rv);
30549: 
34487:   // Re-import state.
34487:   [mWindow importState:state];
34487: 
30549:   // Reparent the content view.
30549:   [mWindow setContentView:contentView];
30549:   [contentView release];
30549: 
30549:   // Reparent child windows.
30549:   enumerator = [childWindows objectEnumerator];
30549:   while ((child = [enumerator nextObject])) {
30549:     [mWindow addChildWindow:child ordered:NSWindowAbove];
30549:   }
30549: 
30549:   // Show the new window.
30549:   if (isVisible) {
30549:     rv = Show(PR_TRUE);
30549:     NS_ENSURE_SUCCESS(rv, rv);
30549:   }
30549: 
30549:   return NS_OK;
30549: 
30549:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
30549: }
30549: 
30549: 
30550: NS_METHOD nsCocoaWindow::MakeFullScreen(PRBool aFullScreen)
30550: {
30550:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
30550: 
30550:   NS_ASSERTION(mFullScreen != aFullScreen, "Unnecessary MakeFullScreen call");
30550: 
30550:   NSDisableScreenUpdates();
37145:   // The order here matters. When we exit full screen mode, we need to show the
37145:   // Dock first, otherwise the newly-created window won't have its minimize
37145:   // button enabled. See bug 526282.
37145:   nsCocoaUtils::HideOSChromeOnScreen(aFullScreen, [mWindow screen]);
30550:   nsresult rv = nsBaseWidget::MakeFullScreen(aFullScreen);
30550:   NSEnableScreenUpdates();
30550:   NS_ENSURE_SUCCESS(rv, rv);
30550: 
30550:   mFullScreen = aFullScreen;
30550: 
30550:   return NS_OK;
30550: 
30550:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
30550: }
30550: 
30550: 
    1: NS_IMETHODIMP nsCocoaWindow::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
56422:   nsIntRect newBounds = nsIntRect(aX, aY, aWidth, aHeight);
56422:   FitRectToVisibleAreaForScreen(newBounds, [mWindow screen]);
 8590: 
59551:   BOOL isMoving = (mBounds.x != newBounds.x || mBounds.y != newBounds.y);
59551:   BOOL isResizing = (mBounds.width != newBounds.width || mBounds.height != newBounds.height);
 7635: 
58552:   if (!mWindow || (!isMoving && !isResizing))
 7635:     return NS_OK;
 7635: 
59551:   NSRect newFrame = nsCocoaUtils::GeckoRectToCocoaRect(newBounds);
 7635: 
 8351:   // We ignore aRepaint -- we have to call display:YES, otherwise the
 8351:   // title bar doesn't immediately get repainted and is displayed in
 8351:   // the wrong place, leading to a visual jump.
 8351:   [mWindow setFrame:newFrame display:YES];
 7635: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978:   
59551:   return Resize(mBounds.x, mBounds.y, aWidth, aHeight, aRepaint);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
59551: NS_IMETHODIMP nsCocoaWindow::GetClientBounds(nsIntRect &aRect)
59551: {
59551:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
59551: 
59551:   if ([mWindow isKindOfClass:[ToolbarWindow class]] &&
59551:       [(ToolbarWindow*)mWindow drawsContentsIntoWindowFrame]) {
59551:     aRect = nsCocoaUtils::CocoaRectToGeckoRect([mWindow frame]);
59551:   } else {
59551:     NSRect contentRect = [mWindow contentRectForFrameRect:[mWindow frame]];
59551:     aRect = nsCocoaUtils::CocoaRectToGeckoRect(contentRect);
59551:   }
59551: 
59551:   return NS_OK;
59551: 
59551:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
59551: }
59551: 
59551: void
59551: nsCocoaWindow::UpdateBounds()
59551: {
59551:   mBounds = nsCocoaUtils::CocoaRectToGeckoRect([mWindow frame]);
59551: }
59551: 
23738: NS_IMETHODIMP nsCocoaWindow::GetScreenBounds(nsIntRect &aRect)
    1: {
39807:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
39807: 
59551:   NS_ASSERTION(mBounds == nsCocoaUtils::CocoaRectToGeckoRect([mWindow frame]),
59551:                "mBounds out of sync!");
59551: 
59551:   aRect = mBounds;
    1:   return NS_OK;
39807: 
39807:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
33232: NS_IMETHODIMP nsCocoaWindow::SetCursor(nsCursor aCursor)
33232: {
33232:   if (mPopupContentView)
33232:     return mPopupContentView->SetCursor(aCursor);
33232: 
33232:   return NS_OK;
33232: }
33232: 
33232: NS_IMETHODIMP nsCocoaWindow::SetCursor(imgIContainer* aCursor,
33232:                                        PRUint32 aHotspotX, PRUint32 aHotspotY)
33232: {
33232:   if (mPopupContentView)
33232:     return mPopupContentView->SetCursor(aCursor, aHotspotX, aHotspotY);
33232: 
33232:   return NS_OK;
33232: }
33232: 
    1: NS_IMETHODIMP nsCocoaWindow::SetTitle(const nsAString& aTitle)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   const nsString& strTitle = PromiseFlatString(aTitle);
    1:   NSString* title = [NSString stringWithCharacters:strTitle.get() length:strTitle.Length()];
    1:   [mWindow setTitle:title];
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
23738: NS_IMETHODIMP nsCocoaWindow::Invalidate(const nsIntRect & aRect, PRBool aIsSynchronous)
    1: {
    1:   if (mPopupContentView)
    1:     return mPopupContentView->Invalidate(aRect, aIsSynchronous);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::Update()
    1: {
    1:   if (mPopupContentView)
    1:     return mPopupContentView->Update();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Pass notification of some drag event to Gecko
    1: //
    1: // The drag manager has let us know that something related to a drag has
    1: // occurred in this window. It could be any number of things, ranging from 
    1: // a drop, to a drag enter/leave, or a drag over event. The actual event
    1: // is passed in |aMessage| and is passed along to our event hanlder so Gecko
    1: // knows about it.
    1: PRBool nsCocoaWindow::DragEvent(unsigned int aMessage, Point aMouseGlobal, UInt16 aKeyModifiers)
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::SendSetZLevelEvent()
    1: {
    1:   nsZLevelEvent event(PR_TRUE, NS_SETZLEVEL, this);
    1: 
    1:   event.refPoint.x = mBounds.x;
    1:   event.refPoint.y = mBounds.y;
    1:   event.time = PR_IntervalNow();
    1: 
    1:   event.mImmediate = PR_TRUE;
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   DispatchEvent(&event, status);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::GetChildSheet(PRBool aShown, nsCocoaWindow** _retval)
    1: {
    1:   nsIWidget* child = GetFirstChild();
    1: 
    1:   while (child) {
    1:     nsWindowType type;
11899:     if (NS_SUCCEEDED(child->GetWindowType(type)) && type == eWindowType_sheet) {
    1:       // if it's a sheet, it must be an nsCocoaWindow
11899:       nsCocoaWindow* cocoaWindow = static_cast<nsCocoaWindow*>(child);
11899:       if ((aShown && [cocoaWindow->mWindow isVisible]) ||
    1:           (!aShown && cocoaWindow->mSheetNeedsShow)) {
    1:         *_retval = cocoaWindow;
    1:         return NS_OK;
    1:       }
    1:     }
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1:   *_retval = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
15026: NS_IMETHODIMP nsCocoaWindow::GetRealParent(nsIWidget** parent)
15026: {
15026:   *parent = mParent;
15026:   return NS_OK;
15026: }
15026: 
    1: NS_IMETHODIMP nsCocoaWindow::GetIsSheet(PRBool* isSheet)
    1: {
    1:   mWindowType == eWindowType_sheet ? *isSheet = PR_TRUE : *isSheet = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::GetSheetWindowParent(NSWindow** sheetWindowParent)
    1: {
    1:   *sheetWindowParent = mSheetWindowParent;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::ResetInputState()
    1: {
    1:   return NS_OK;
    1: }
    1: 
 6118: // Invokes callback and ProcessEvent methods on Event Listener object
    1: NS_IMETHODIMP 
    1: nsCocoaWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
    1: {
    1:   aStatus = nsEventStatus_eIgnore;
    1: 
    1:   nsIWidget* aWidget = event->widget;
    1:   NS_IF_ADDREF(aWidget);
    1: 
    1:   if (mEventCallback)
    1:     aStatus = (*mEventCallback)(event);
    1: 
    1:   NS_IF_RELEASE(aWidget);
    1: 
    1:   return NS_OK;
    1: }
    1: 
31533: static nsSizeMode
31533: GetWindowSizeMode(NSWindow* aWindow) {
31533:   if ([aWindow isMiniaturized])
31533:     return nsSizeMode_Minimized;
31533:   if (([aWindow styleMask] & NSResizableWindowMask) && [aWindow isZoomed])
31533:     return nsSizeMode_Maximized;
31533:   return nsSizeMode_Normal;
31533: }
31533: 
    1: void
48258: nsCocoaWindow::ReportMoveEvent()
48258: {
59551:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
59551: 
59551:   UpdateBounds();
59551: 
48258:   // Dispatch the move event to Gecko
48258:   nsGUIEvent guiEvent(PR_TRUE, NS_MOVE, this);
59551:   guiEvent.refPoint.x = mBounds.x;
59551:   guiEvent.refPoint.y = mBounds.y;
48258:   guiEvent.time = PR_IntervalNow();
48258:   nsEventStatus status = nsEventStatus_eIgnore;
48258:   DispatchEvent(&guiEvent, status);
59551: 
59551:   NS_OBJC_END_TRY_ABORT_BLOCK;
48258: }
48258: 
48258: void
31533: nsCocoaWindow::DispatchSizeModeEvent()
19112: {
19112:   nsSizeModeEvent event(PR_TRUE, NS_SIZEMODE, this);
31533:   event.mSizeMode = GetWindowSizeMode(mWindow);
19112:   event.time = PR_IntervalNow();
19112: 
19112:   nsEventStatus status = nsEventStatus_eIgnore;
19112:   DispatchEvent(&event, status);
19112: }
19112: 
19112: void
59551: nsCocoaWindow::ReportSizeEvent()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
59551:   UpdateBounds();
34054: 
    1:   nsSizeEvent sizeEvent(PR_TRUE, NS_SIZE, this);
    1:   sizeEvent.time = PR_IntervalNow();
    1: 
59551:   nsIntRect innerBounds;
59551:   GetClientBounds(innerBounds);
59551:   sizeEvent.windowSize = &innerBounds;
    1:   sizeEvent.mWinWidth  = mBounds.width;
    1:   sizeEvent.mWinHeight = mBounds.height;
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   DispatchEvent(&sizeEvent, status);
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
27089: void nsCocoaWindow::SetMenuBar(nsMenuBarX *aMenuBar)
    1: {
    1:   if (mMenuBar)
    1:     mMenuBar->SetParent(nsnull);
27089:   mMenuBar = aMenuBar;
    1: 
29018:   // Only paint for active windows, or paint the hidden window menu bar if no
29018:   // other menu bar has been painted yet so that some reasonable menu bar is
29018:   // displayed when the app starts up.
29018:   id windowDelegate = [mWindow delegate];
29018:   if (mMenuBar &&
29018:       ((!gSomeMenuBarPainted && nsMenuUtilsX::GetHiddenWindowMenuBar() == mMenuBar) ||
29018:        (windowDelegate && [windowDelegate toplevelActiveState])))
    1:     mMenuBar->Paint();
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::SetFocus(PRBool aState)
    1: {
29018:   if (mPopupContentView) {
    1:     mPopupContentView->SetFocus(aState);
29018:   }
37853:   else if (aState && ([mWindow isVisible] || [mWindow isMiniaturized])) {
29018:     [mWindow setAcceptsMouseMovedEvents:YES];
29018:     [mWindow makeKeyAndOrderFront:nil];
29018:     SendSetZLevelEvent();
29018:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
25183: nsIntPoint nsCocoaWindow::WidgetToScreenOffset()
    1: {
25183:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
23738:   nsIntRect r = nsCocoaUtils::CocoaRectToGeckoRect([mWindow contentRectForFrameRect:[mWindow frame]]);
    1: 
25183:   return r.TopLeft();
25183: 
25183:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntPoint(0,0));
    1: }
    1: 
48256: nsIntPoint nsCocoaWindow::GetClientOffset()
48256: {
48256:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
48256: 
59551:   nsIntRect clientRect;
59551:   GetClientBounds(clientRect);
59551: 
59551:   return clientRect.TopLeft() - mBounds.TopLeft();
48256: 
48256:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntPoint(0, 0));
48256: }
48256: 
48256: nsIntSize nsCocoaWindow::ClientToWindowSize(const nsIntSize& aClientSize)
48256: {
48256:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
48256: 
48256:   // this is only called for popups currently. If needed, expand this to support
48256:   // other types of windows
48256:   if (!IsPopupWithTitleBar())
48256:     return aClientSize;
48256: 
48256:   NSRect rect(NSMakeRect(0.0, 0.0, aClientSize.width, aClientSize.height));
48256: 
48256:   NSRect inflatedRect = [mWindow frameRectForContentRect:rect];
48256:   return nsCocoaUtils::CocoaRectToGeckoRect(inflatedRect).Size();
48256: 
48256:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nsIntSize(0,0));
48256: }
48256: 
15578: nsMenuBarX* nsCocoaWindow::GetMenuBar()
    1: {
    1:   return mMenuBar;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::CaptureRollupEvents(nsIRollupListener * aListener, 
36806:                                                  nsIMenuRollup * aMenuRollup,
    1:                                                  PRBool aDoCapture, 
    1:                                                  PRBool aConsumeRollupEvent)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
36806:   gRollupListener = nsnull;
36806:   NS_IF_RELEASE(gMenuRollup);
    1:   NS_IF_RELEASE(gRollupWidget);
    1:   
    1:   if (aDoCapture) {
    1:     gRollupListener = aListener;
36806:     NS_IF_RELEASE(gMenuRollup);
36806:     gMenuRollup = aMenuRollup;
36806:     NS_IF_ADDREF(aMenuRollup);
    1:     gRollupWidget = this;
    1:     NS_ADDREF(this);
28346: 
28346:     gConsumeRollupEvent = aConsumeRollupEvent;
28346: 
 6494:     // Sometimes more than one popup window can be visible at the same time
 6494:     // (e.g. nested non-native context menus, or the test case (attachment
 6494:     // 276885) for bmo bug 392389, which displays a non-native combo-box in
 6494:     // a non-native popup window).  In these cases the "active" popup window
 6494:     // (the one that corresponds to the current gRollupWidget) should be the
 6494:     // topmost -- the (nested) context menu the mouse is currently over, or
 6494:     // the combo-box's drop-down list (when it's displayed).  But (among
 6494:     // windows that have the same "level") OS X makes topmost the window that
 6494:     // last received a mouse-down event, which may be incorrect (in the combo-
 6494:     // box case, it makes topmost the window containing the combo-box).  So
 6494:     // here we fiddle with a non-native popup window's level to make sure the
 6494:     // "active" one is always above any other non-native popup windows that
 6494:     // may be visible.
 6494:     if (mWindow && (mWindowType == eWindowType_popup))
48254:       SetPopupWindowLevel();
 6494:   } else {
48254:     // XXXndeakin this doesn't make sense.
48254:     // Why is the new window assumed to be a modal panel?
 6494:     if (mWindow && (mWindowType == eWindowType_popup))
 6494:       [mWindow setLevel:NSModalPanelWindowLevel];
    1:   }
    1:   
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: NS_IMETHODIMP nsCocoaWindow::GetAttention(PRInt32 aCycleCount)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   [NSApp requestUserAttention:NSInformationalRequest];
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
27993: PRBool
27993: nsCocoaWindow::HasPendingInputEvent()
27993: {
27993:   return nsChildView::DoHasPendingInputEvent();
27993: }
    1: 
20467: NS_IMETHODIMP nsCocoaWindow::SetWindowShadowStyle(PRInt32 aStyle)
20467: {
20467:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
20467: 
36750:   mShadowStyle = aStyle;
20467:   [mWindow setHasShadow:(aStyle != NS_STYLE_WINDOW_SHADOW_NONE)];
36750:   AdjustWindowShadow();
37144:   SetUpWindowFilter();
36750: 
20467:   return NS_OK;
20467: 
20467:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
20467: }
20467: 
31160: void nsCocoaWindow::SetShowsToolbarButton(PRBool aShow)
31160: {
31160:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
31160: 
31160:   [mWindow setShowsToolbarButton:aShow];
31160: 
31160:   NS_OBJC_END_TRY_ABORT_BLOCK;
31160: }
31160: 
14886: NS_IMETHODIMP nsCocoaWindow::SetWindowTitlebarColor(nscolor aColor, PRBool aActive)
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 7242:   // If they pass a color with a complete transparent alpha component, use the
 7242:   // native titlebar appearance.
 7242:   if (NS_GET_A(aColor) == 0) {
34487:     [mWindow setTitlebarColor:nil forActiveWindow:(BOOL)aActive]; 
 7242:   } else {
14002:     // Transform from sRGBA to monitor RGBA. This seems like it would make trying
14002:     // to match the system appearance lame, so probably we just shouldn't color 
14002:     // correct chrome.
19127:     if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
27035:       qcms_transform *transform = gfxPlatform::GetCMSRGBATransform();
19127:       if (transform) {
19127:         PRUint8 color[3];
19127:         color[0] = NS_GET_R(aColor);
19127:         color[1] = NS_GET_G(aColor);
19127:         color[2] = NS_GET_B(aColor);
27035:         qcms_transform_data(transform, color, color, 1);
19127:         aColor = NS_RGB(color[0], color[1], color[2]);
19127:       }
19127:     }
14002: 
34487:     [mWindow setTitlebarColor:[NSColor colorWithDeviceRed:NS_GET_R(aColor)/255.0
 7242:                                                     green:NS_GET_G(aColor)/255.0
 7242:                                                      blue:NS_GET_B(aColor)/255.0
14886:                                                     alpha:NS_GET_A(aColor)/255.0]
14886:               forActiveWindow:(BOOL)aActive];
 7242:   }
 7242:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 7242: }
 7242: 
34054: void nsCocoaWindow::SetDrawsInTitlebar(PRBool aState)
34054: {
34054:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
34054: 
34487:   [mWindow setDrawsContentsIntoWindowFrame:aState];
34054: 
34054:   NS_OBJC_END_TRY_ABORT_BLOCK;
34054: }
34054: 
32976: NS_IMETHODIMP nsCocoaWindow::SynthesizeNativeMouseEvent(nsIntPoint aPoint,
32976:                                                         PRUint32 aNativeMessage,
32976:                                                         PRUint32 aModifierFlags)
32976: {
32976:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
32976: 
32976:   if (mPopupContentView)
32976:     return mPopupContentView->SynthesizeNativeMouseEvent(aPoint, aNativeMessage,
32976:                                                          aModifierFlags);
32976: 
32976:   return NS_OK;
32976: 
32976:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
32976: }
32976: 
 4174: gfxASurface* nsCocoaWindow::GetThebesSurface()
 4174: {
 4174:   if (mPopupContentView)
 4174:     return mPopupContentView->GetThebesSurface();
 4174:   return nsnull;
 4174: }
 4174: 
 6348: NS_IMETHODIMP nsCocoaWindow::BeginSecureKeyboardInput()
 6348: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 6348:   nsresult rv = nsBaseWidget::BeginSecureKeyboardInput();
62281:   if (NS_SUCCEEDED(rv)) {
 6348:     ::EnableSecureEventInput();
62281:   }
 6348:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 6348: }
 6348: 
 6348: NS_IMETHODIMP nsCocoaWindow::EndSecureKeyboardInput()
 6348: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
 6348:   nsresult rv = nsBaseWidget::EndSecureKeyboardInput();
62281:   if (NS_SUCCEEDED(rv)) {
 6348:     ::DisableSecureEventInput();
62281:   }
 6348:   return rv;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 6348: }
 6348: 
20506: // Callback used by the default titlebar and toolbar shading.
20506: // *aIn == 0 at the top of the titlebar/toolbar, *aIn == 1 at the bottom
20506: /* static */ void
31548: nsCocoaWindow::UnifiedShading(void* aInfo, const CGFloat* aIn, CGFloat* aOut)
20506: {
20506:   UnifiedGradientInfo* info = (UnifiedGradientInfo*)aInfo;
20506:   // The gradient percentage at the bottom of the titlebar / top of the toolbar
20506:   float start = info->titlebarHeight / (info->titlebarHeight + info->toolbarHeight - 1);
20506:   const float startGrey = NativeGreyColorAsFloat(headerStartGrey, info->windowIsMain);
20506:   const float endGrey = NativeGreyColorAsFloat(headerEndGrey, info->windowIsMain);
20506:   // *aIn is the gradient percentage of the titlebar or toolbar gradient,
20506:   // a is the gradient percentage of the whole unified gradient.
20506:   float a = info->drawTitlebar ? *aIn * start : start + *aIn * (1 - start);
20506:   float result = (1.0f - a) * startGrey + a * endGrey;
20506:   aOut[0] = result;
20506:   aOut[1] = result;
20506:   aOut[2] = result;
20506:   aOut[3] = 1.0f;
20506: }
20506: 
48254: void nsCocoaWindow::SetPopupWindowLevel()
48254: {
48254:   // Floating popups are at the floating level and hide when the window is
48254:   // deactivated.
48254:   if (mPopupLevel == ePopupLevelFloating) {
48254:     [mWindow setLevel:NSFloatingWindowLevel];
48254:     [mWindow setHidesOnDeactivate:YES];
48254:   }
48254:   else {
48254:     // Otherwise, this is a top-level or parent popup. Parent popups always
48254:     // appear just above their parent and essentially ignore the level.
48254:     [mWindow setLevel:NSPopUpMenuWindowLevel];
48254:     [mWindow setHidesOnDeactivate:NO];
48254:   }
48254: }
48254: 
57526: PRBool nsCocoaWindow::IsChildInFailingLeftClickThrough(NSView *aChild)
57526: {
57526:   if ([aChild isKindOfClass:[ChildView class]]) {
57526:     ChildView* childView = (ChildView*) aChild;
57526:     if ([childView isInFailingLeftClickThrough])
57526:       return PR_TRUE;
57526:   }
57526:   NSArray* subviews = [aChild subviews];
57526:   if (subviews) {
57526:     NSUInteger count = [subviews count];
57526:     for (NSUInteger i = 0; i < count; ++i) {
57526:       NSView* aView = (NSView*) [subviews objectAtIndex:i];
57526:       if (IsChildInFailingLeftClickThrough(aView))
57526:         return PR_TRUE;
57526:     }
57526:   }
57526:   return PR_FALSE;
57526: }
57526: 
57526: // Don't focus a plugin if we're in a left click-through that will
57526: // fail (see [ChildView isInFailingLeftClickThrough]).  Called from
57526: // [ChildView shouldFocusPlugin].
57526: PRBool nsCocoaWindow::ShouldFocusPlugin()
57526: {
57526:   if (IsChildInFailingLeftClickThrough([mWindow contentView]))
57526:     return PR_FALSE;
57526: 
57526:   return PR_TRUE;
57526: }
57526: 
    1: @implementation WindowDelegate
    1: 
    1: // We try to find a gecko menu bar to paint. If one does not exist, just paint
    1: // the application menu by itself so that a window doesn't have some other
    1: // window's menu bar.
    1: + (void)paintMenubarForWindow:(NSWindow*)aWindow
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   // make sure we only act on windows that have this kind of
    1:   // object as a delegate
    1:   id windowDelegate = [aWindow delegate];
    1:   if ([windowDelegate class] != [self class])
    1:     return;
    1: 
    1:   nsCocoaWindow* geckoWidget = [windowDelegate geckoWidget];
    1:   NS_ASSERTION(geckoWidget, "Window delegate not returning a gecko widget!");
    1:   
15578:   nsMenuBarX* geckoMenuBar = geckoWidget->GetMenuBar();
    1:   if (geckoMenuBar) {
    1:     geckoMenuBar->Paint();
    1:   }
    1:   else {
    1:     // sometimes we don't have a native application menu early in launching
    1:     if (!sApplicationMenu)
    1:       return;
    1: 
 8087:     NSMenu* mainMenu = [NSApp mainMenu];
 8087:     NS_ASSERTION([mainMenu numberOfItems] > 0, "Main menu does not have any items, something is terribly wrong!");
    1: 
14024:     // Create a new menu bar.
14024:     // We create a GeckoNSMenu because all menu bar NSMenu objects should use that subclass for
14024:     // key handling reasons.
14024:     GeckoNSMenu* newMenuBar = [[GeckoNSMenu alloc] initWithTitle:@"MainMenuBar"];
 8087: 
 8087:     // move the application menu from the existing menu bar to the new one
 8087:     NSMenuItem* firstMenuItem = [[mainMenu itemAtIndex:0] retain];
 8087:     [mainMenu removeItemAtIndex:0];
 8087:     [newMenuBar insertItem:firstMenuItem atIndex:0];
 8087:     [firstMenuItem release];
    1: 
    1:     // set our new menu bar as the main menu
    1:     [NSApp setMainMenu:newMenuBar];
    1:     [newMenuBar release];
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (id)initWithGeckoWindow:(nsCocoaWindow*)geckoWind
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
    1:   [super init];
    1:   mGeckoWindow = geckoWind;
14885:   mToplevelActiveState = PR_FALSE;
31533:   mHasEverBeenZoomed = PR_FALSE;
    1:   return self;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (NSSize)windowWillResize:(NSWindow *)sender toSize:(NSSize)proposedFrameSize
    1: {
 2314:   RollUpPopups();
    1:   
    1:   return proposedFrameSize;
    1: }
    1: 
    1: - (void)windowDidResize:(NSNotification *)aNotification
    1: {
58552:   if (!mGeckoWindow)
    1:     return;
    1: 
31533:   // Resizing might have changed our zoom state.
31533:   mGeckoWindow->DispatchSizeModeEvent();
 5945:   mGeckoWindow->ReportSizeEvent();
    1: }
    1: 
    1: - (void)windowDidBecomeMain:(NSNotification *)aNotification
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 2314:   RollUpPopups();
35621:   ChildViewMouseTracker::ReEvaluateMouseEnterState();
 1579: 
13608:   // [NSApp _isRunningAppModal] will return true if we're running an OS dialog
13608:   // app modally. If one of those is up then we want it to retain its menu bar.
13608:   if ([NSApp _isRunningAppModal])
13608:     return;
    1:   NSWindow* window = [aNotification object];
    1:   if (window)
    1:     [WindowDelegate paintMenubarForWindow:window];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)windowDidResignMain:(NSNotification *)aNotification
    1: {
 2314:   RollUpPopups();
35621:   ChildViewMouseTracker::ReEvaluateMouseEnterState();
    1: 
13608:   // [NSApp _isRunningAppModal] will return true if we're running an OS dialog
13608:   // app modally. If one of those is up then we want it to retain its menu bar.
13608:   if ([NSApp _isRunningAppModal])
13608:     return;
15578:   nsRefPtr<nsMenuBarX> hiddenWindowMenuBar = nsMenuUtilsX::GetHiddenWindowMenuBar();
    1:   if (hiddenWindowMenuBar) {
    1:     // printf("painting hidden window menu bar due to window losing main status\n");
    1:     hiddenWindowMenuBar->Paint();
    1:   }
    1: }
    1: 
    1: - (void)windowDidBecomeKey:(NSNotification *)aNotification
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
33515:   RollUpPopups();
35621:   ChildViewMouseTracker::ReEvaluateMouseEnterState();
33515: 
    1:   NSWindow* window = [aNotification object];
    1:   if ([window isSheet])
    1:     [WindowDelegate paintMenubarForWindow:window];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)windowDidResignKey:(NSNotification *)aNotification
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
33515:   RollUpPopups();
35621:   ChildViewMouseTracker::ReEvaluateMouseEnterState();
33515: 
    1:   // If a sheet just resigned key then we should paint the menu bar
    1:   // for whatever window is now main.
    1:   NSWindow* window = [aNotification object];
    1:   if ([window isSheet])
    1:     [WindowDelegate paintMenubarForWindow:[NSApp mainWindow]];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)windowWillMove:(NSNotification *)aNotification
    1: {
 2314:   RollUpPopups();
    1: }
    1: 
 1357: - (void)windowDidMove:(NSNotification *)aNotification
 1357: {
48258:   if (mGeckoWindow)
48258:     mGeckoWindow->ReportMoveEvent();
 1357: }
    1: 
    1: - (BOOL)windowShouldClose:(id)sender
    1: {
    1:   // We only want to send NS_XUL_CLOSE and let gecko close the window
    1:   nsGUIEvent guiEvent(PR_TRUE, NS_XUL_CLOSE, mGeckoWindow);
    1:   guiEvent.time = PR_IntervalNow();
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   mGeckoWindow->DispatchEvent(&guiEvent, status);
    1:   return NO; // gecko will do it
    1: }
    1: 
    1: - (void)windowWillClose:(NSNotification *)aNotification
    1: {
 2314:   RollUpPopups();
    1: }
    1: 
    1: - (void)windowWillMiniaturize:(NSNotification *)aNotification
    1: {
 2314:   RollUpPopups();
    1: }
    1: 
19112: - (void)windowDidMiniaturize:(NSNotification *)aNotification
19112: {
19112:   if (mGeckoWindow)
31533:     mGeckoWindow->DispatchSizeModeEvent();
19112: }
19112: 
19112: - (void)windowDidDeminiaturize:(NSNotification *)aNotification
19112: {
19112:   if (mGeckoWindow)
31533:     mGeckoWindow->DispatchSizeModeEvent();
31533: }
31533: 
31533: - (BOOL)windowShouldZoom:(NSWindow *)window toFrame:(NSRect)proposedFrame
31533: {
31533:   if (!mHasEverBeenZoomed && [window isZoomed])
31533:     return NO; // See bug 429954.
31533: 
31533:   mHasEverBeenZoomed = YES;
31533:   return YES;
19112: }
19112: 
 4208: - (void)sendFocusEvent:(PRUint32)eventType
    1: {
    1:   if (!mGeckoWindow)
    1:     return;
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
 4208:   nsGUIEvent focusGuiEvent(PR_TRUE, eventType, mGeckoWindow);
    1:   focusGuiEvent.time = PR_IntervalNow();
    1:   mGeckoWindow->DispatchEvent(&focusGuiEvent, status);
    1: }
    1: 
    1: - (void)didEndSheet:(NSWindow*)sheet returnCode:(int)returnCode contextInfo:(void*)contextInfo
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
15026:   // Note: 'contextInfo' (if it is set) is the window that is the parent of
15026:   // the sheet.  The value of contextInfo is determined in
15026:   // nsCocoaWindow::Show().  If it's set, 'contextInfo' is always the top-
15026:   // level window, not another sheet itself.  But 'contextInfo' is nil if
15026:   // our parent window is also a sheet -- in that case we shouldn't send
15026:   // the top-level window any activate events (because it's our parent
15026:   // window that needs to get these events, not the top-level window).
14885:   [TopLevelWindowData deactivateInWindow:sheet];
    1:   [sheet orderOut:self];
15026:   if (contextInfo)
14885:     [TopLevelWindowData activateInWindow:(NSWindow*)contextInfo];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
  604: - (nsCocoaWindow*)geckoWidget
    1: {
    1:   return mGeckoWindow;
    1: }
    1: 
14885: - (PRBool)toplevelActiveState
14885: {
14885:   return mToplevelActiveState;
14885: }
14885: 
14885: - (void)sendToplevelActivateEvents
14885: {
14885:   if (!mToplevelActiveState) {
14885:     [self sendFocusEvent:NS_ACTIVATE];
14885:     mToplevelActiveState = PR_TRUE;
14885:   }
14885: }
14885: 
14885: - (void)sendToplevelDeactivateEvents
14885: {
14885:   if (mToplevelActiveState) {
14885:     [self sendFocusEvent:NS_DEACTIVATE];
14885:     mToplevelActiveState = PR_FALSE;
14885:   }
14885: }
14885: 
    1: @end
 2029: 
50873: static float
50873: GetDPI(NSWindow* aWindow)
50873: {
50873:   NSScreen* screen = [aWindow screen];
50873:   if (!screen)
50873:     return 96.0f;
50873: 
50873:   CGDirectDisplayID displayID =
50873:     [[[screen deviceDescription] objectForKey:@"NSScreenNumber"] intValue];
50873:   CGFloat heightMM = ::CGDisplayScreenSize(displayID).height;
50873:   size_t heightPx = ::CGDisplayPixelsHigh(displayID);
50873:   CGFloat scaleFactor = [aWindow userSpaceScaleFactor];
50873:   if (scaleFactor < 0.01 || heightMM < 1 || heightPx < 1) {
50873:     // Something extremely bogus is going on
50873:     return 96.0f;
50873:   }
50873: 
50873:   // Currently we don't do our own scaling to take account
50873:   // of userSpaceScaleFactor, so every "pixel" we draw is actually
50873:   // userSpaceScaleFactor screen pixels. So divide the screen height
50873:   // by userSpaceScaleFactor to get the number of "device pixels"
50873:   // available.
50873:   return (heightPx / scaleFactor) / (heightMM / MM_PER_INCH_FLOAT);
50873: }
50873: 
34487: @implementation BaseWindow
 7242: 
34487: - (id)initWithContentRect:(NSRect)aContentRect styleMask:(NSUInteger)aStyle backing:(NSBackingStoreType)aBufferingType defer:(BOOL)aFlag
 7242: {
34487:   [super initWithContentRect:aContentRect styleMask:aStyle backing:aBufferingType defer:aFlag];
34487:   mState = nil;
34487:   mDrawsIntoWindowFrame = NO;
34487:   mActiveTitlebarColor = nil;
34487:   mInactiveTitlebarColor = nil;
35620:   mScheduledShadowInvalidation = NO;
50873:   mDPI = GetDPI(self);
50873: 
34487:   return self;
34487: }
11978: 
34487: - (void)dealloc
34487: {
34487:   [mActiveTitlebarColor release];
34487:   [mInactiveTitlebarColor release];
34487:   [super dealloc];
34487: }
11978: 
34487: static const NSString* kStateTitleKey = @"title";
34487: static const NSString* kStateDrawsContentsIntoWindowFrameKey = @"drawsContentsIntoWindowFrame";
34487: static const NSString* kStateActiveTitlebarColorKey = @"activeTitlebarColor";
34487: static const NSString* kStateInactiveTitlebarColorKey = @"inactiveTitlebarColor";
36749: static const NSString* kStateShowsToolbarButton = @"showsToolbarButton";
34487: 
34487: - (void)importState:(NSDictionary*)aState
34487: {
34487:   [self setTitle:[aState objectForKey:kStateTitleKey]];
34487:   [self setDrawsContentsIntoWindowFrame:[[aState objectForKey:kStateDrawsContentsIntoWindowFrameKey] boolValue]];
34487:   [self setTitlebarColor:[aState objectForKey:kStateActiveTitlebarColorKey] forActiveWindow:YES];
34487:   [self setTitlebarColor:[aState objectForKey:kStateInactiveTitlebarColorKey] forActiveWindow:NO];
36749:   [self setShowsToolbarButton:[[aState objectForKey:kStateShowsToolbarButton] boolValue]];
34487: }
34487: 
34487: - (NSMutableDictionary*)exportState
34487: {
34487:   NSMutableDictionary* state = [NSMutableDictionary dictionaryWithCapacity:10];
34487:   [state setObject:[self title] forKey:kStateTitleKey];
34487:   [state setObject:[NSNumber numberWithBool:[self drawsContentsIntoWindowFrame]]
34487:             forKey:kStateDrawsContentsIntoWindowFrameKey];
34487:   NSColor* activeTitlebarColor = [self titlebarColorForActiveWindow:YES];
34487:   if (activeTitlebarColor) {
34487:     [state setObject:activeTitlebarColor forKey:kStateActiveTitlebarColorKey];
34487:   }
34487:   NSColor* inactiveTitlebarColor = [self titlebarColorForActiveWindow:NO];
34487:   if (inactiveTitlebarColor) {
34487:     [state setObject:inactiveTitlebarColor forKey:kStateInactiveTitlebarColorKey];
34487:   }
36749:   [state setObject:[NSNumber numberWithBool:[self showsToolbarButton]]
36749:             forKey:kStateShowsToolbarButton];
34487:   return state;
34487: }
34487: 
34487: - (void)setDrawsContentsIntoWindowFrame:(BOOL)aState
34487: {
34487:   mDrawsIntoWindowFrame = aState;
34487: }
34487: 
34487: - (BOOL)drawsContentsIntoWindowFrame
34487: {
34487:   return mDrawsIntoWindowFrame;
34487: }
34487: 
34487: // Pass nil here to get the default appearance.
34487: - (void)setTitlebarColor:(NSColor*)aColor forActiveWindow:(BOOL)aActive
34487: {
34487:   [aColor retain];
34487:   if (aActive) {
34487:     [mActiveTitlebarColor release];
34487:     mActiveTitlebarColor = aColor;
34487:   } else {
34487:     [mInactiveTitlebarColor release];
34487:     mInactiveTitlebarColor = aColor;
34487:   }
34487: }
34487: 
34487: - (NSColor*)titlebarColorForActiveWindow:(BOOL)aActive
34487: {
34487:   return aActive ? mActiveTitlebarColor : mInactiveTitlebarColor;
 7242: }
 7242: 
35620: - (void)deferredInvalidateShadow
35620: {
35620:   if (mScheduledShadowInvalidation || [self isOpaque] || ![self hasShadow])
35620:     return;
35620: 
35620:   [self performSelector:@selector(invalidateShadow) withObject:nil afterDelay:0];
35620:   mScheduledShadowInvalidation = YES;
35620: }
35620: 
35620: - (void)invalidateShadow
35620: {
35620:   [super invalidateShadow];
35620:   mScheduledShadowInvalidation = NO;
35620: }
35620: 
50873: - (float)getDPI
50873: {
50873:   return mDPI;
50873: }
50873: 
61539: - (BOOL)respondsToSelector:(SEL)aSelector
61539: {
61539:   // Claim the window doesn't respond to this so that the system
61539:   // doesn't steal keyboard equivalents for it. Bug 613710.
61539:   if (aSelector == @selector(cancelOperation:)) {
61539:     return NO;
61539:   }
61539: 
61539:   return [super respondsToSelector:aSelector];
61539: }
61539: 
50708: - (void) doCommandBySelector:(SEL)aSelector
50708: {
50708:   // We override this so that it won't beep if it can't act.
50708:   // We want to control the beeping for missing or disabled
50708:   // commands ourselves.
50708:   [self tryToPerform:aSelector with:nil];
50708: }
50708: 
 7242: @end
 7242: 
 7242: // This class allows us to have a "unified toolbar" style window. It works like this:
 7242: // 1) We set the window's style to textured.
 7242: // 2) Because of this, the background color applies to the entire window, including
 7242: //     the titlebar area. For normal textured windows, the default pattern is a 
19295: //    "brushed metal" image on Tiger and a unified gradient on Leopard.
 7242: // 3) We set the background color to a custom NSColor subclass that knows how tall the window is.
 7242: //    When -set is called on it, it sets a pattern (with a draw callback) as the fill. In that callback,
19295: //    it paints the the titlebar and background colors in the correct areas of the context it's given,
 7242: //    which will fill the entire window (CG will tile it horizontally for us).
19295: // 4) Whenever the window's main state changes and when [window display] is called,
19295: //    Cocoa redraws the titlebar using the patternDraw callback function.
 7242: //
 7242: // This class also provides us with a pill button to show/hide the toolbar.
19295: //
19295: // Drawing the unified gradient in the titlebar and the toolbar works like this:
19295: // 1) In the style sheet we set the toolbar's -moz-appearance to -moz-mac-unified-toolbar.
48165: // 2) When the toolbar is visible and we paint the application chrome
60289: //    window, the array that Gecko passes nsChildView::UpdateThemeGeometries
60289: //    will contain an entry for the widget type NS_THEME_TOOLBAR or
48165: //    NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR.
60289: // 3) nsChildView::UpdateThemeGeometries finds the toolbar frame's ToolbarWindow
60289: //    and passes the toolbar frame's height to setUnifiedToolbarHeight.
60289: // 4) If the toolbar height has changed, a titlebar redraw is triggered and the
60289: //    upper part of the unified gradient is drawn in the titlebar.
60289: // 5) The lower part of the unified gradient in the toolbar is drawn during
60289: //    normal window content painting in nsNativeThemeCocoa::DrawUnifiedToolbar.
19295: //
19295: // Whenever the unified gradient is drawn in the titlebar or the toolbar, both
19295: // titlebar height and toolbar height must be known in order to construct the
19295: // correct gradient (which is a linear gradient with the length
19295: // titlebarHeight + toolbarHeight - 1). But you can only get from the toolbar frame
19295: // to the containing window - the other direction doesn't work. That's why the
19295: // toolbar height is cached in the ToolbarWindow but nsNativeThemeCocoa can simply
19295: // query the window for its titlebar height when drawing the toolbar.
 2029: @implementation ToolbarWindow
 2029: 
31548: - (id)initWithContentRect:(NSRect)aContentRect styleMask:(NSUInteger)aStyle backing:(NSBackingStoreType)aBufferingType defer:(BOOL)aFlag
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 7242:   aStyle = aStyle | NSTexturedBackgroundWindowMask;
 7242:   if ((self = [super initWithContentRect:aContentRect styleMask:aStyle backing:aBufferingType defer:aFlag])) {
34487:     mColor = [[TitlebarAndBackgroundColor alloc] initWithWindow:self];
34487:     // Bypass our guard method below.
 7242:     [super setBackgroundColor:mColor];
34487:     mBackgroundColor = [NSColor whiteColor];
 7242: 
19295:     mUnifiedToolbarHeight = 0.0f;
19295: 
 7242:     // setBottomCornerRounded: is a private API call, so we check to make sure
 7242:     // we respond to it just in case.
 7242:     if ([self respondsToSelector:@selector(setBottomCornerRounded:)])
 7242:       [self setBottomCornerRounded:NO];
34855: 
34855:     [self setAutorecalculatesContentBorderThickness:NO forEdge:NSMaxYEdge];
34855:     [self setContentBorderThickness:0.0f forEdge:NSMaxYEdge];
 7242:   }
 7242:   return self;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 7242: }
 7242: 
 7242: - (void)dealloc
 7242: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 7242:   [mColor release];
34487:   [mBackgroundColor release];
 7242:   [super dealloc];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 7242: }
 7242: 
34487: - (void)setTitlebarColor:(NSColor*)aColor forActiveWindow:(BOOL)aActive
34487: {
34487:   [super setTitlebarColor:aColor forActiveWindow:aActive];
34487:   [self setTitlebarNeedsDisplayInRect:[self titlebarRect]];
34487: }
34487: 
 7242: - (void)setBackgroundColor:(NSColor*)aColor
 7242: {
34487:   [aColor retain];
34487:   [mBackgroundColor release];
34487:   mBackgroundColor = aColor;
 7242: }
 7242: 
 7242: - (NSColor*)windowBackgroundColor
 7242: {
34487:   return mBackgroundColor;
 7242: }
 7242: 
34054: - (void)setTitlebarNeedsDisplayInRect:(NSRect)aRect
34054: {
34054:   [self setTitlebarNeedsDisplayInRect:aRect sync:NO];
34054: }
34054: 
34054: - (void)setTitlebarNeedsDisplayInRect:(NSRect)aRect sync:(BOOL)aSync
34054: {
34054:   NSRect titlebarRect = [self titlebarRect];
34054:   NSRect rect = NSIntersectionRect(titlebarRect, aRect);
34054:   if (NSIsEmptyRect(rect))
34054:     return;
34054: 
34054:   NSView* borderView = [[self contentView] superview];
34054:   if (!borderView)
34054:     return;
34054: 
34054:   if (aSync) {
34054:     [borderView displayRect:rect];
34054:   } else {
34054:     [borderView setNeedsDisplayInRect:rect];
34054:   }
34054: }
34054: 
34054: - (NSRect)titlebarRect
34054: {
34054:   return NSMakeRect(0, [[self contentView] bounds].size.height,
34054:                     [self frame].size.width, [self titlebarHeight]);
14886: }
14886: 
19295: - (float)unifiedToolbarHeight
14886: {
19295:   return mUnifiedToolbarHeight;
 7242: }
 7242: 
19295: - (float)titlebarHeight
19295: {
19295:   NSRect frameRect = [self frame];
19295:   return frameRect.size.height - [self contentRectForFrameRect:frameRect].size.height;
19295: }
19295: 
60289: - (void)setUnifiedToolbarHeight:(float)aHeight
37194: {
60289:   if ([self drawsContentsIntoWindowFrame] || aHeight == mUnifiedToolbarHeight)
48165:     return;
48165: 
60289:   mUnifiedToolbarHeight = aHeight;
60289: 
60289:   // Update sheet positioning hint.
48165:   [self setContentBorderThickness:mUnifiedToolbarHeight forEdge:NSMaxYEdge];
48165: 
60289:   // Redraw the title bar. If we're inside painting, we'll do it right now,
60289:   // otherwise we'll just invalidate it.
60289:   BOOL needSyncRedraw = ([NSView focusView] != nil);
60289:   [self setTitlebarNeedsDisplayInRect:[self titlebarRect] sync:needSyncRedraw];
37194: }
37194: 
34054: - (void)setDrawsContentsIntoWindowFrame:(BOOL)aState
34054: {
34487:   BOOL stateChanged = ([self drawsContentsIntoWindowFrame] != aState);
34487:   [super setDrawsContentsIntoWindowFrame:aState];
57862:   if (stateChanged && [[self delegate] isKindOfClass:[WindowDelegate class]]) {
57862:     WindowDelegate *windowDelegate = (WindowDelegate *)[self delegate];
57862:     nsCocoaWindow *geckoWindow = [windowDelegate geckoWidget];
34054:     if (geckoWindow) {
34054:       // Re-layout our contents.
34054:       geckoWindow->ReportSizeEvent();
34054:     }
34054:     [self setTitlebarNeedsDisplayInRect:[self titlebarRect]];
34054:   }
34054: }
34054: 
31160: // Returning YES here makes the setShowsToolbarButton method work even though
31160: // the window doesn't contain an NSToolbar.
 2029: - (BOOL)_hasToolbar
 2029: {
 2029:   return YES;
 2029: }
 2029: 
 7242: // Dispatch a toolbar pill button clicked message to Gecko.
 2029: - (void)_toolbarPillButtonClicked:(id)sender
 2029: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
39602:   RollUpPopups();
39602: 
57862:   if ([[self delegate] isKindOfClass:[WindowDelegate class]]) {
57862:     WindowDelegate *windowDelegate = (WindowDelegate *)[self delegate];
57862:     nsCocoaWindow *geckoWindow = [windowDelegate geckoWidget];
15025:     if (!geckoWindow)
15025:       return;
 2029:     nsEventStatus status = nsEventStatus_eIgnore;
 2029:     nsGUIEvent guiEvent(PR_TRUE, NS_OS_TOOLBAR, geckoWindow);
 2029:     guiEvent.time = PR_IntervalNow();
 2029:     geckoWindow->DispatchEvent(&guiEvent, status);
57862:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 2029: }
 2029: 
 7106: // Retain and release "self" to avoid crashes when our widget (and its native
 7106: // window) is closed as a result of processing a key equivalent (e.g.
 7106: // Command+w or Command+q).  This workaround is only needed for a window
 7106: // that can become key.
 7106: - (BOOL)performKeyEquivalent:(NSEvent*)theEvent
 7106: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 7106:   NSWindow *nativeWindow = [self retain];
 7106:   BOOL retval = [super performKeyEquivalent:theEvent];
 7106:   [nativeWindow release];
 7106:   return retval;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 7106: }
 7106: 
13491: - (void)sendEvent:(NSEvent *)anEvent
13491: {
13491:   NSEventType type = [anEvent type];
13491:   
13491:   switch (type) {
13491:     case NSScrollWheel:
13491:     case NSLeftMouseDown:
13491:     case NSLeftMouseUp:
13491:     case NSRightMouseDown:
13491:     case NSRightMouseUp:
13491:     case NSOtherMouseDown:
13491:     case NSOtherMouseUp:
13491:     case NSMouseMoved:
13491:     case NSLeftMouseDragged:
13491:     case NSRightMouseDragged:
13491:     case NSOtherMouseDragged:
13520:     {
13491:       // Drop all mouse events if a modal window has appeared above us.
13491:       // This helps make us behave as if the OS were running a "real" modal
13491:       // event loop.
13491:       id delegate = [self delegate];
13491:       if (delegate && [delegate isKindOfClass:[WindowDelegate class]]) {
13491:         nsCocoaWindow *widget = [(WindowDelegate *)delegate geckoWidget];
13491:         if (widget) {
26321:           if (gGeckoAppModalWindowList && (widget != gGeckoAppModalWindowList->window))
13491:             return;
13491:           if (widget->HasModalDescendents())
13491:             return;
13491:         }
13491:       }
13491:       break;
13520:     }
13491:     default:
13491:       break;
13491:   }
13491: 
13491:   [super sendEvent:anEvent];
13491: }
13491: 
 2029: @end
 3574: 
 7242: // Custom NSColor subclass where most of the work takes place for drawing in
 7242: // the titlebar area.
 7242: @implementation TitlebarAndBackgroundColor
 7242: 
34487: - (id)initWithWindow:(ToolbarWindow*)aWindow
 7242: {
 7242:   if ((self = [super init])) {
 8908:     mWindow = aWindow; // weak ref to avoid a cycle
 7242:   }
 7242:   return self;
 7242: }
 7242: 
 7242: // Our pattern width is 1 pixel. CoreGraphics can cache and tile for us.
 7242: static const float sPatternWidth = 1.0f;
 7242: 
34054: static void
34054: DrawTitlebarGradient(CGContextRef aContext, float aTitlebarHeight,
34054:                      float aTitlebarOrigin, float aToolbarHeight, BOOL aIsMain)
 7242: {
34054:   // Create and draw a CGShading that uses nsCocoaWindow::UnifiedShading() as its callback.
34054:   CGFunctionCallbacks callbacks = {0, nsCocoaWindow::UnifiedShading, NULL};
34054:   UnifiedGradientInfo info = { aTitlebarHeight, aToolbarHeight, aIsMain, YES };
34054:   CGFunctionRef function = CGFunctionCreate(&info, 1, NULL, 4, NULL, &callbacks);
34054:   CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
34054:   CGShadingRef shading = CGShadingCreateAxial(colorSpace,
34054:                                               CGPointMake(0.0f, aTitlebarOrigin + aTitlebarHeight),
34054:                                               CGPointMake(0.0f, aTitlebarOrigin),
34054:                                               function, NO, NO);
34054:   CGColorSpaceRelease(colorSpace);
34054:   CGFunctionRelease(function);
34054:   CGContextDrawShading(aContext, shading);
34054:   CGShadingRelease(shading);
34054:   // Draw the one pixel border at the bottom of the titlebar.
34054:   if (aToolbarHeight == 0) {
34054:     CGRect borderRect = CGRectMake(0.0f, aTitlebarOrigin, sPatternWidth, 1.0f);
34054:     DrawNativeGreyColorInRect(aContext, headerBorderGrey, borderRect, aIsMain);
34054:   }
34054: }
11978: 
34054: // Pattern draw callback for standard titlebar gradients and solid titlebar colors
34054: static void
34054: RepeatedPatternDrawCallback(void* aInfo, CGContextRef aContext)
34054: {
34487:   ToolbarWindow *window = (ToolbarWindow*)aInfo;
 7242: 
 7242:   // Remember: this context is NOT flipped, so the origin is in the bottom left.
19295:   float titlebarHeight = [window titlebarHeight];
 7242:   float titlebarOrigin = [window frame].size.height - titlebarHeight;
 7242: 
 7242:   [NSGraphicsContext saveGraphicsState];
 7242:   [NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:aContext flipped:NO]];
 7242: 
34054:   BOOL isMain = [window isMainWindow];
34487:   NSColor *titlebarColor = [window titlebarColorForActiveWindow:isMain];
34054:   if (!titlebarColor) {
 7242:     // If the titlebar color is nil, draw the default titlebar shading.
34054:     DrawTitlebarGradient(aContext, titlebarHeight, titlebarOrigin,
34054:                          [window unifiedToolbarHeight], isMain);
 7242:   } else {
34054:     // If the titlebar color is not nil, just set and draw it normally.
 7242:     [titlebarColor set];
 7242:     NSRectFill(NSMakeRect(0.0f, titlebarOrigin, sPatternWidth, titlebarHeight));
 7242:   }
 7242: 
 7242:   // Draw the background color of the window everywhere but where the titlebar is.
34487:   [[window windowBackgroundColor] set];
 7242:   NSRectFill(NSMakeRect(0.0f, 0.0f, 1.0f, titlebarOrigin));
 7242: 
 7242:   [NSGraphicsContext restoreGraphicsState];
34054: }
11978: 
34054: // Pattern draw callback for "drawsContentsIntoWindowFrame" windows
34054: static void
34054: ContentPatternDrawCallback(void* aInfo, CGContextRef aContext)
34054: {
34487:   ToolbarWindow *window = (ToolbarWindow*)aInfo;
34054: 
34054:   NSView* view = [[[window contentView] subviews] lastObject];
34054:   if (!view || ![view isKindOfClass:[ChildView class]])
34054:     return;
34054: 
34054:   // Gecko drawing assumes flippedness, but the current context isn't flipped
34054:   // (because we're painting into the window's border view, which is not a
34054:   // ChildView, so it isn't flpped).
34054:   // So we need to set a flip transform.
34054:   CGContextScaleCTM(aContext, 1.0f, -1.0f);
34054:   CGContextTranslateCTM(aContext, 0.0f, -[window frame].size.height);
34054: 
34054:   NSRect titlebarRect = NSMakeRect(0, 0, [window frame].size.width, [window titlebarHeight]);
55858:   [(ChildView*)view drawRect:titlebarRect inTitlebarContext:aContext];
 7242: }
 7242: 
 7242: - (void)setFill
 7242: {
55858:   CGPatternDrawPatternCallback cb = [mWindow drawsContentsIntoWindowFrame] ?
34054:                                       &ContentPatternDrawCallback : &RepeatedPatternDrawCallback;
55858:   float patternWidth = [mWindow drawsContentsIntoWindowFrame] ? [mWindow frame].size.width : sPatternWidth;
55858: 
34054:   CGPatternCallbacks callbacks = {0, cb, NULL};
34487:   CGPatternRef pattern = CGPatternCreate(mWindow, CGRectMake(0.0f, 0.0f, patternWidth, [mWindow frame].size.height), 
34054:                                          CGAffineTransformIdentity, patternWidth, [mWindow frame].size.height,
 7242:                                          kCGPatternTilingConstantSpacing, true, &callbacks);
 7242: 
 7242:   // Set the pattern as the fill, which is what we were asked to do. All our
 7242:   // drawing will take place in the patternDraw callback.
 7242:   CGColorSpaceRef patternSpace = CGColorSpaceCreatePattern(NULL);
55858:   CGContextRef context = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
 7242:   CGContextSetFillColorSpace(context, patternSpace);
 7242:   CGColorSpaceRelease(patternSpace);
31548:   CGFloat component = 1.0f;
 7242:   CGContextSetFillPattern(context, pattern, &component);
 7242:   CGPatternRelease(pattern);
 7242: }
 7242: 
34487: - (void)set
 7242: {
34487:   [self setFill];
 7242: }
 7242: 
 7242: - (NSString*)colorSpaceName
 7242: {
 7242:   return NSDeviceRGBColorSpace;
 7242: }
 7242: 
 7242: @end
 7242: 
 3574: @implementation PopupWindow
 3574: 
 3574: // The OS treats our custom popup windows very strangely -- many mouse events
 3574: // sent to them never reach their target NSView objects.  (That these windows
 3574: // are borderless and of level NSPopUpMenuWindowLevel may have something to do
 3574: // with it.)  The best solution is to pre-empt the OS, as follows.  (All
 3574: // events for a given NSWindow object go through its sendEvent: method.)
 3574: - (void)sendEvent:(NSEvent *)anEvent
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 9368:   NSView *target = nil;
 9368:   NSView *contentView = nil;
 3574:   NSEventType type = [anEvent type];
 6494:   NSPoint windowLocation = NSZeroPoint;
 3574:   switch (type) {
 3574:     case NSScrollWheel:
 3574:     case NSLeftMouseDown:
 3574:     case NSLeftMouseUp:
 3574:     case NSRightMouseDown:
 3574:     case NSRightMouseUp:
 3574:     case NSOtherMouseDown:
 3574:     case NSOtherMouseUp:
 3574:     case NSMouseMoved:
 3574:     case NSLeftMouseDragged:
 3574:     case NSRightMouseDragged:
 3574:     case NSOtherMouseDragged:
 9368:       if ((contentView = [self contentView])) {
 8779:         // Since [anEvent window] might not be us, we can't use [anEvent locationInWindow].
 8779:         windowLocation = nsCocoaUtils::EventLocationForWindow(anEvent, self);
 8779:         target = [contentView hitTest:[contentView convertPoint:windowLocation fromView:nil]];
 9368:         // If the hit test failed, the event is targeted here but is not over the window.
47791:         // Send it to our content view.
 9368:         if (!target)
47791:           target = contentView;
 3574:       }
 3574:       break;
 3574:     default:
 3574:       break;
 3574:   }
 3574:   if (target) {
 3574:     switch (type) {
 3574:       case NSScrollWheel:
 3574:         [target scrollWheel:anEvent];
 3574:         break;
 3574:       case NSLeftMouseUp:
 3574:         [target mouseUp:anEvent];
 3574:         break;
 3574:       case NSRightMouseDown:
 3574:         [target rightMouseDown:anEvent];
 3574:         break;
 3574:       case NSRightMouseUp:
 3574:         [target rightMouseUp:anEvent];
 3574:         break;
 3574:       case NSOtherMouseDown:
 3574:         [target otherMouseDown:anEvent];
 3574:         break;
 3574:       case NSOtherMouseUp:
 3574:         [target otherMouseUp:anEvent];
 3574:         break;
 3574:       case NSMouseMoved:
 3574:         [target mouseMoved:anEvent];
 3574:         break;
 3574:       case NSLeftMouseDragged:
 3574:         [target mouseDragged:anEvent];
 3574:         break;
 3574:       case NSRightMouseDragged:
 3574:         [target rightMouseDragged:anEvent];
 3574:         break;
 3574:       case NSOtherMouseDragged:
 3574:         [target otherMouseDragged:anEvent];
 3574:         break;
 3574:       default:
 3574:         [super sendEvent:anEvent];
 3574:         break;
 3574:     }
 3574:   } else {
 3574:     [super sendEvent:anEvent];
 3574:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 3574: }
 3574: 
31548: - (id)initWithContentRect:(NSRect)contentRect styleMask:(NSUInteger)styleMask
 3574:       backing:(NSBackingStoreType)bufferingType defer:(BOOL)deferCreation
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11978: 
 3574:   mIsContextMenu = false;
 3574:   return [super initWithContentRect:contentRect styleMask:styleMask
 3574:           backing:bufferingType defer:deferCreation];
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 3574: }
 3574: 
 3574: - (BOOL)isContextMenu
 3574: {
 3574:   return mIsContextMenu;
 3574: }
 3574: 
 3574: - (void)setIsContextMenu:(BOOL)flag
 3574: {
 3574:   mIsContextMenu = flag;
 3574: }
 3574: 
48254: - (BOOL)canBecomeMainWindow
48254: {
48254:   // This is overriden because the default is 'yes' when a titlebar is present.
48254:   return NO;
48254: }
48254: 
 3574: @end
 7042: 
 7042: // According to Apple's docs on [NSWindow canBecomeKeyWindow] and [NSWindow
 7042: // canBecomeMainWindow], windows without a title bar or resize bar can't (by
 7042: // default) become key or main.  But if a window can't become key, it can't
 7042: // accept keyboard input (bmo bug 393250).  And it should also be possible for
 7042: // an otherwise "ordinary" window to become main.  We need to override these
 7042: // two methods to make this happen.
 7042: @implementation BorderlessWindow
 7042: 
 7042: - (BOOL)canBecomeKeyWindow
 7042: {
 7042:   return YES;
 7042: }
 7042: 
13491: - (void)sendEvent:(NSEvent *)anEvent
13491: {
13491:   NSEventType type = [anEvent type];
13491:   
13491:   switch (type) {
13491:     case NSScrollWheel:
13491:     case NSLeftMouseDown:
13491:     case NSLeftMouseUp:
13491:     case NSRightMouseDown:
13491:     case NSRightMouseUp:
13491:     case NSOtherMouseDown:
13491:     case NSOtherMouseUp:
13491:     case NSMouseMoved:
13491:     case NSLeftMouseDragged:
13491:     case NSRightMouseDragged:
13491:     case NSOtherMouseDragged:
13520:     {
13491:       // Drop all mouse events if a modal window has appeared above us.
13491:       // This helps make us behave as if the OS were running a "real" modal
13491:       // event loop.
13491:       id delegate = [self delegate];
13491:       if (delegate && [delegate isKindOfClass:[WindowDelegate class]]) {
13491:         nsCocoaWindow *widget = [(WindowDelegate *)delegate geckoWidget];
13491:         if (widget) {
26321:           if (gGeckoAppModalWindowList && (widget != gGeckoAppModalWindowList->window))
13491:             return;
13491:           if (widget->HasModalDescendents())
13491:             return;
13491:         }
13491:       }
13491:       break;
13520:     }
13491:     default:
13491:       break;
13491:   }
13491: 
13491:   [super sendEvent:anEvent];
13491: }
13491: 
 7042: // Apple's doc on this method says that the NSWindow class's default is not to
 7042: // become main if the window isn't "visible" -- so we should replicate that
 7042: // behavior here.  As best I can tell, the [NSWindow isVisible] method is an
 7042: // accurate test of what Apple means by "visibility".
 7042: - (BOOL)canBecomeMainWindow
 7042: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 7042:   if (![self isVisible])
 7042:     return NO;
 7042:   return YES;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 7042: }
 7042: 
 7106: // Retain and release "self" to avoid crashes when our widget (and its native
 7106: // window) is closed as a result of processing a key equivalent (e.g.
 7106: // Command+w or Command+q).  This workaround is only needed for a window
 7106: // that can become key.
 7106: - (BOOL)performKeyEquivalent:(NSEvent*)theEvent
 7106: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 7106:   NSWindow *nativeWindow = [self retain];
 7106:   BOOL retval = [super performKeyEquivalent:theEvent];
 7106:   [nativeWindow release];
 7106:   return retval;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 7106: }
 7106: 
 7042: @end
