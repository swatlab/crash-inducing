    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* vim:expandtab:shiftwidth=4:tabstop=4:
    1:  */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is Christopher Blizzard
    1:  * <blizzard@mozilla.org>.  Portions created by the Initial Developer
    1:  * are Copyright (C) 2001 the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
54309:  *   Mats Palmgren <matspal@gmail.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
38014: #ifdef MOZ_PLATFORM_MAEMO
40081: // needed to include hildon parts in gtk.h
19111: #define MAEMO_CHANGES
19111: #endif
19111: 
    1: #include "prlink.h"
    1: #include "nsWindow.h"
    1: #include "nsGTKToolkit.h"
    1: #include "nsIRollupListener.h"
    1: #include "nsIMenuRollup.h"
    1: #include "nsIDOMNode.h"
    1: 
    1: #include "nsWidgetsCID.h"
27557: #include "nsDragService.h"
    1: #include "nsIDragSessionGTK.h"
    1: 
    1: #include "nsGtkKeyUtils.h"
    1: #include "nsGtkCursors.h"
    1: 
23281: #include <gtk/gtk.h>
16529: #ifdef MOZ_X11
    1: #include <gdk/gdkx.h>
40081: #include <X11/Xatom.h>
54594: #include <X11/extensions/XShm.h>
39957: 
39957: #ifdef AIX
39957: #include <X11/keysym.h>
39957: #else
16529: #include <X11/XF86keysym.h>
39957: #endif
39957: 
16529: #include "gtk2xtbin.h"
16529: #endif /* MOZ_X11 */
16458: #include <gdk/gdkkeysyms.h>
30515: #include <gtk/gtkprivate.h>
11283: 
11283: #include "nsWidgetAtoms.h"
    1: 
    1: #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
    1: #define SN_API_NOT_YET_FROZEN
    1: #include <startup-notification-1.0/libsn/sn.h>
    1: #endif
    1: 
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsGfxCIID.h"
33057: #include "nsIObserverService.h"
    1: 
33517: #include "nsIdleService.h"
40087: #include "nsIPropertyBag2.h"
33517: 
    1: #ifdef ACCESSIBILITY
21255: #include "nsIAccessibilityService.h"
42313: #include "nsIAccessibleDocument.h"
    1: #include "prenv.h"
    1: #include "stdlib.h"
    1: static PRBool sAccessibilityChecked = PR_FALSE;
    1: /* static */
    1: PRBool nsWindow::sAccessibilityEnabled = PR_FALSE;
    1: static const char sSysPrefService [] = "@mozilla.org/system-preference-service;1";
    1: static const char sAccEnv [] = "GNOME_ACCESSIBILITY";
    1: static const char sAccessibilityKey [] = "config.use_system_prefs.accessibility";
    1: #endif
    1: 
    1: /* For SetIcon */
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIFile.h"
    1: #include "nsILocalFile.h"
    1: 
    1: /* SetCursor(imgIContainer*) */
    1: #include <gdk/gdk.h>
33057: #include <wchar.h>
    1: #include "imgIContainer.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsImageToPixbuf.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsAutoPtr.h"
    1: 
35698: extern "C" {
35698: #include "pixman.h"
35698: }
    1: #include "gfxPlatformGtk.h"
    1: #include "gfxContext.h"
    1: #include "gfxImageSurface.h"
61316: #include "gfxUtils.h"
44138: #include "Layers.h"
44138: #include "LayerManagerOGL.h"
44138: #include "GLContextProvider.h"
    1: 
16529: #ifdef MOZ_X11
16529: #include "gfxXlibSurface.h"
16529: #endif
16529: 
56628: #include "nsShmImage.h"
56628: 
16529: #ifdef MOZ_DFB
16529: extern "C" {
16529: #ifdef MOZ_DIRECT_DEBUG
16529: #define DIRECT_ENABLE_DEBUG
16529: #endif
16529: 
16529: #include <direct/debug.h>
16529: 
16529: D_DEBUG_DOMAIN( ns_Window, "nsWindow", "nsWindow" );
16529: }
16529: #include "gfxDirectFBSurface.h"
16529: #define GDK_WINDOW_XWINDOW(_win) _win
16529: #endif
16529: 
54594: using namespace mozilla;
46205: using mozilla::gl::GLContext;
46205: using mozilla::layers::LayerManagerOGL;
46205: 
25021: // Don't put more than this many rects in the dirty region, just fluff
25021: // out to the bounding-box if there are more
25021: #define MAX_RECTS_IN_REGION 100
25021: 
    1: /* utility functions */
    1: static PRBool     check_for_rollup(GdkWindow *aWindow,
    1:                                    gdouble aMouseX, gdouble aMouseY,
54150:                                    PRBool aIsWheel, PRBool aAlwaysRollup);
    1: static PRBool     is_mouse_in_window(GdkWindow* aWindow,
    1:                                      gdouble aMouseX, gdouble aMouseY);
    1: static nsWindow  *get_window_for_gtk_widget(GtkWidget *widget);
    1: static nsWindow  *get_window_for_gdk_window(GdkWindow *window);
    1: static GtkWidget *get_gtk_widget_for_gdk_window(GdkWindow *window);
    1: static GdkCursor *get_gtk_cursor(nsCursor aCursor);
    1: 
    1: static GdkWindow *get_inner_gdk_window (GdkWindow *aWindow,
    1:                                         gint x, gint y,
    1:                                         gint *retx, gint *rety);
    1: 
    1: static inline PRBool is_context_menu_key(const nsKeyEvent& inKeyEvent);
11930: static void   key_event_to_context_menu_event(nsMouseEvent &aEvent,
11930:                                               GdkEventKey *aGdkEvent);
    1: 
    1: static int    is_parent_ungrab_enter(GdkEventCrossing *aEvent);
    1: static int    is_parent_grab_leave(GdkEventCrossing *aEvent);
    1: 
    1: /* callbacks from widgets */
    1: static gboolean expose_event_cb           (GtkWidget *widget,
    1:                                            GdkEventExpose *event);
    1: static gboolean configure_event_cb        (GtkWidget *widget,
    1:                                            GdkEventConfigure *event);
28365: static void     container_unrealize_cb    (GtkWidget *widget);
    1: static void     size_allocate_cb          (GtkWidget *widget,
    1:                                            GtkAllocation *allocation);
    1: static gboolean delete_event_cb           (GtkWidget *widget,
    1:                                            GdkEventAny *event);
    1: static gboolean enter_notify_event_cb     (GtkWidget *widget,
    1:                                            GdkEventCrossing *event);
    1: static gboolean leave_notify_event_cb     (GtkWidget *widget,
    1:                                            GdkEventCrossing *event);
    1: static gboolean motion_notify_event_cb    (GtkWidget *widget,
    1:                                            GdkEventMotion *event);
    1: static gboolean button_press_event_cb     (GtkWidget *widget,
    1:                                            GdkEventButton *event);
    1: static gboolean button_release_event_cb   (GtkWidget *widget,
    1:                                            GdkEventButton *event);
    1: static gboolean focus_in_event_cb         (GtkWidget *widget,
    1:                                            GdkEventFocus *event);
    1: static gboolean focus_out_event_cb        (GtkWidget *widget,
    1:                                            GdkEventFocus *event);
    1: static gboolean key_press_event_cb        (GtkWidget *widget,
    1:                                            GdkEventKey *event);
    1: static gboolean key_release_event_cb      (GtkWidget *widget,
    1:                                            GdkEventKey *event);
    1: static gboolean scroll_event_cb           (GtkWidget *widget,
    1:                                            GdkEventScroll *event);
    1: static gboolean visibility_notify_event_cb(GtkWidget *widget,
    1:                                            GdkEventVisibility *event);
34456: static void     hierarchy_changed_cb      (GtkWidget *widget,
34456:                                            GtkWidget *previous_toplevel);
    1: static gboolean window_state_event_cb     (GtkWidget *widget,
    1:                                            GdkEventWindowState *event);
    1: static void     theme_changed_cb          (GtkSettings *settings,
    1:                                            GParamSpec *pspec,
    1:                                            nsWindow *data);
 9049: static nsWindow* GetFirstNSWindowForGDKWindow (GdkWindow *aGdkWindow);
 9049: 
    1: #ifdef __cplusplus
    1: extern "C" {
    1: #endif /* __cplusplus */
16529: #ifdef MOZ_X11
43761: static GdkFilterReturn popup_take_focus_filter (GdkXEvent *gdk_xevent,
43761:                                                 GdkEvent *event,
43761:                                                 gpointer data);
    1: static GdkFilterReturn plugin_window_filter_func (GdkXEvent *gdk_xevent,
    1:                                                   GdkEvent *event,
    1:                                                   gpointer data);
    1: static GdkFilterReturn plugin_client_message_filter (GdkXEvent *xevent,
    1:                                                      GdkEvent *event,
    1:                                                      gpointer data);
16529: #endif /* MOZ_X11 */
    1: #ifdef __cplusplus
    1: }
    1: #endif /* __cplusplus */
    1: 
    1: static gboolean drag_motion_event_cb      (GtkWidget *aWidget,
    1:                                            GdkDragContext *aDragContext,
    1:                                            gint aX,
    1:                                            gint aY,
    1:                                            guint aTime,
    1:                                            gpointer aData);
    1: static void     drag_leave_event_cb       (GtkWidget *aWidget,
    1:                                            GdkDragContext *aDragContext,
    1:                                            guint aTime,
    1:                                            gpointer aData);
    1: static gboolean drag_drop_event_cb        (GtkWidget *aWidget,
    1:                                            GdkDragContext *aDragContext,
    1:                                            gint aX,
    1:                                            gint aY,
    1:                                            guint aTime,
    1:                                            gpointer *aData);
    1: static void    drag_data_received_event_cb(GtkWidget *aWidget,
    1:                                            GdkDragContext *aDragContext,
    1:                                            gint aX,
    1:                                            gint aY,
    1:                                            GtkSelectionData  *aSelectionData,
    1:                                            guint aInfo,
    1:                                            guint32 aTime,
    1:                                            gpointer aData);
    1: 
 2475: static GdkModifierType gdk_keyboard_get_modifiers();
16529: #ifdef MOZ_X11
 2475: static PRBool gdk_keyboard_get_modmap_masks(Display*  aDisplay,
 2475:                                             PRUint32* aCapsLockMask,
 2475:                                             PRUint32* aNumLockMask,
 2475:                                             PRUint32* aScrollLockMask);
16529: #endif /* MOZ_X11 */
 2475: 
    1: /* initialization static functions */
    1: static nsresult    initialize_prefs        (void);
    1: 
40944: static void
40944: UpdateLastInputEventTime()
40944: {
40944:   nsCOMPtr<nsIdleService> idleService = do_GetService("@mozilla.org/widget/idleservice;1");
40944:   if (idleService) {
40944:     idleService->ResetIdleTimeOut();
40944:   }
33517: }
33517: 
    1: // this is the last window that had a drag event happen on it.
61355: nsWindow *nsWindow::sLastDragMotionWindow = NULL;
    1: PRBool nsWindow::sIsDraggingOutOf = PR_FALSE;
    1: 
    1: // This is the time of the last button press event.  The drag service
    1: // uses it as the time to start drags.
39762: guint32   nsWindow::sLastButtonPressTime = 0;
    1: // Time of the last button release event. We use it to detect when the
    1: // drag ended before we could properly setup drag and drop.
39762: guint32   nsWindow::sLastButtonReleaseTime = 0;
    1: 
    1: static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
    1: 
43760: // The window from which the focus manager asks us to dispatch key events.
    1: static nsWindow         *gFocusWindow          = NULL;
43760: static PRBool            gBlockActivateEvent   = PR_FALSE;
    1: static PRBool            gGlobalsInitialized   = PR_FALSE;
    1: static PRBool            gRaiseWindows         = PR_TRUE;
    1: static nsWindow         *gPluginFocusWindow    = NULL;
    1: 
36806: static nsIRollupListener*          gRollupListener;
36806: static nsIMenuRollup*              gMenuRollup;
10250: static nsWeakPtr                   gRollupWindow;
10250: static PRBool                      gConsumeRollupEvent;
10250: 
    1: 
    1: #define NS_WINDOW_TITLE_MAX_LENGTH 4095
    1: 
    1: // If after selecting profile window, the startup fail, please refer to
    1: // http://bugzilla.gnome.org/show_bug.cgi?id=88940
    1: 
    1: // needed for imgIContainer cursors
    1: // GdkDisplay* was added in 2.2
    1: typedef struct _GdkDisplay GdkDisplay;
    1: typedef GdkDisplay* (*_gdk_display_get_default_fn)(void);
    1: 
    1: typedef GdkCursor*  (*_gdk_cursor_new_from_pixbuf_fn)(GdkDisplay *display,
    1:                                                       GdkPixbuf *pixbuf,
    1:                                                       gint x,
    1:                                                       gint y);
    1: static _gdk_display_get_default_fn    _gdk_display_get_default;
    1: static _gdk_cursor_new_from_pixbuf_fn _gdk_cursor_new_from_pixbuf;
    1: static PRBool sPixbufCursorChecked;
    1: 
    1: // needed for GetAttention calls
    1: // gdk_window_set_urgency_hint was added in 2.8
    1: typedef void (*_gdk_window_set_urgency_hint_fn)(GdkWindow *window,
    1:                                                 gboolean urgency);
    1: 
    1: #define kWindowPositionSlop 20
    1: 
    1: // cursor cache
    1: static GdkCursor *gCursorCache[eCursorCount];
    1: 
19352: // imported in nsWidgetFactory.cpp
19352: PRBool gDisableNativeTheme = PR_FALSE;
19352: 
28365: static GtkWidget *gInvisibleContainer = NULL;
28365: 
39762: // Sometimes this actually also includes the state of the modifier keys, but
39762: // only the button state bits are used.
39762: static guint gButtonState;
39762: 
34456: // Some gobject functions expect functions for gpointer arguments.
34456: // gpointer is void* but C++ doesn't like casting functions to void*.
39762: template<class T> static inline gpointer
34456: FuncToGpointer(T aFunction)
34456: {
34456:     return reinterpret_cast<gpointer>
34456:         (reinterpret_cast<uintptr_t>
34456:          // This cast just provides a warning if T is not a function.
34456:          (reinterpret_cast<void (*)()>(aFunction)));
34456: }
34456: 
35698: // nsAutoRef<pixman_region32> uses nsSimpleRef<> to know how to automatically
35698: // destroy regions.
35698: template <>
35698: class nsSimpleRef<pixman_region32> : public pixman_region32 {
35698: protected:
35698:     typedef pixman_region32 RawRef;
35698: 
35698:     nsSimpleRef() { data = nsnull; }
35698:     nsSimpleRef(const RawRef &aRawRef) : pixman_region32(aRawRef) { }
35698: 
35698:     static void Release(pixman_region32& region) {
35698:         pixman_region32_fini(&region);
35698:     }
35698:     // Whether this needs to be released:
35698:     PRBool HaveResource() const { return data != nsnull; }
35698: 
35698:     pixman_region32& get() { return *this; }
35698: };
35698: 
    1: nsWindow::nsWindow()
    1: {
20621:     mIsTopLevel       = PR_FALSE;
20621:     mIsDestroyed      = PR_FALSE;
20621:     mNeedsResize      = PR_FALSE;
20621:     mNeedsMove        = PR_FALSE;
20621:     mListenForResizes = PR_FALSE;
20621:     mIsShown          = PR_FALSE;
20621:     mNeedsShow        = PR_FALSE;
20621:     mEnabled          = PR_TRUE;
20621:     mCreated          = PR_FALSE;
20621: 
    1:     mContainer           = nsnull;
30704:     mGdkWindow           = nsnull;
    1:     mShell               = nsnull;
    1:     mWindowGroup         = nsnull;
34456:     mHasMappedToplevel   = PR_FALSE;
34456:     mIsFullyObscured     = PR_FALSE;
    1:     mRetryPointerGrab    = PR_FALSE;
    1:     mTransientParent     = nsnull;
    1:     mWindowType          = eWindowType_child;
    1:     mSizeState           = nsSizeMode_Normal;
32018:     mLastSizeMode        = nsSizeMode_Normal;
32018: 
16529: #ifdef MOZ_X11
    1:     mOldFocusWindow      = 0;
16529: #endif /* MOZ_X11 */
    1:     mPluginType          = PluginType_NONE;
    1: 
    1:     if (!gGlobalsInitialized) {
    1:         gGlobalsInitialized = PR_TRUE;
    1: 
    1:         // It's OK if either of these fail, but it may not be one day.
    1:         initialize_prefs();
    1:     }
    1: 
22684:     mLastMotionPressure = 0;
    1: 
    1: #ifdef ACCESSIBILITY
    1:     mRootAccessible  = nsnull;
    1: #endif
    1: 
 9499:     mIsTransparent = PR_FALSE;
    1:     mTransparencyBitmap = nsnull;
    1: 
    1:     mTransparencyBitmapWidth  = 0;
    1:     mTransparencyBitmapHeight = 0;
16529: 
16529: #ifdef MOZ_DFB
16529:     mDFBCursorX     = 0;
16529:     mDFBCursorY     = 0;
16529: 
16529:     mDFBCursorCount = 0;
16529: 
16529:     mDFB            = NULL;
16529:     mDFBLayer       = NULL;
16529: #endif
    1: }
    1: 
    1: nsWindow::~nsWindow()
    1: {
    1:     LOG(("nsWindow::~nsWindow() [%p]\n", (void *)this));
61355:     if (sLastDragMotionWindow == this) {
61355:         sLastDragMotionWindow = NULL;
    1:     }
    1: 
    1:     delete[] mTransparencyBitmap;
    1:     mTransparencyBitmap = nsnull;
    1: 
16529: #ifdef MOZ_DFB
16529:     if (mDFBLayer)
16529:          mDFBLayer->Release( mDFBLayer );
16529: 
16529:     if (mDFB)
16529:          mDFB->Release( mDFB );
16529: #endif
16529: 
    1:     Destroy();
    1: }
    1: 
    1: /* static */ void
    1: nsWindow::ReleaseGlobals()
    1: {
  829:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gCursorCache); ++i) {
    1:     if (gCursorCache[i]) {
    1:       gdk_cursor_unref(gCursorCache[i]);
    1:       gCursorCache[i] = nsnull;
    1:     }
    1:   }
    1: }
    1: 
20621: NS_IMPL_ISUPPORTS_INHERITED1(nsWindow, nsBaseWidget,
    1:                              nsISupportsWeakReference)
    1: 
20621: void
20621: nsWindow::CommonCreate(nsIWidget *aParent, PRBool aListenForResizes)
20621: {
20621:     mParent = aParent;
20621:     mListenForResizes = aListenForResizes;
20621:     mCreated = PR_TRUE;
20621: }
20621: 
20621: void
20621: nsWindow::InitKeyEvent(nsKeyEvent &aEvent, GdkEventKey *aGdkEvent)
20621: {
20621:     aEvent.keyCode   = GdkKeyCodeToDOMKeyCode(aGdkEvent->keyval);
64460:     // NOTE: The state of given key event indicates adjacent state of
64460:     // modifier keys.  E.g., even if the event is Shift key press event,
64460:     // the bit for Shift is still false.  By the same token, even if the
64460:     // event is Shift key release event, the bit for Shift is still true.
64460:     // Unfortunately, gdk_keyboard_get_modifiers() returns current modifier
64460:     // state.  It means if there're some pending modifier key press or
64460:     // key release events, the result isn't what we want.
64460:     // Temporarily, we should compute the state only when the key event
64460:     // is GDK_KEY_PRESS.
64460:     guint modifierState = aGdkEvent->state;
64460:     guint changingMask = 0;
64460:     switch (aEvent.keyCode) {
64460:         case NS_VK_SHIFT:
64460:             changingMask = GDK_SHIFT_MASK;
64460:             break;
64460:         case NS_VK_CONTROL:
64460:             changingMask = GDK_CONTROL_MASK;
64460:             break;
64460:         case NS_VK_ALT:
64460:             changingMask = GDK_MOD1_MASK;
64460:             break;
64460:         case NS_VK_META:
64460:             changingMask = GDK_MOD4_MASK;
64460:             break;
64460:     }
64460:     if (changingMask != 0) {
64460:         // This key event is caused by pressing or releasing a modifier key.
64460:         if (aGdkEvent->type == GDK_KEY_PRESS) {
64460:             // If new modifier key is pressed, add the pressed mod mask.
64460:             modifierState |= changingMask;
64460:         } else {
64460:             // XXX If we could know the modifier keys state at the key release
64460:             // event, we should cut out changingMask from modifierState.
64460:         }
64460:     }
64460:     aEvent.isShift   = (modifierState & GDK_SHIFT_MASK) != 0;
64460:     aEvent.isControl = (modifierState & GDK_CONTROL_MASK) != 0;
64460:     aEvent.isAlt     = (modifierState & GDK_MOD1_MASK) != 0;
64460:     aEvent.isMeta    = (modifierState & GDK_MOD4_MASK) != 0;
64460: 
20621:     // The transformations above and in gdk for the keyval are not invertible
20621:     // so link to the GdkEvent (which will vanish soon after return from the
20621:     // event callback) to give plugins access to hardware_keycode and state.
20621:     // (An XEvent would be nice but the GdkEvent is good enough.)
34743:     aEvent.pluginEvent = (void *)aGdkEvent;
20621: 
20621:     aEvent.time      = aGdkEvent->time;
20621: }
20621: 
20621: void
23738: nsWindow::DispatchResizeEvent(nsIntRect &aRect, nsEventStatus &aStatus)
20621: {
20621:     nsSizeEvent event(PR_TRUE, NS_SIZE, this);
20621: 
20621:     event.windowSize = &aRect;
20621:     event.refPoint.x = aRect.x;
20621:     event.refPoint.y = aRect.y;
20621:     event.mWinWidth = aRect.width;
20621:     event.mWinHeight = aRect.height;
20621: 
20621:     nsEventStatus status;
20621:     DispatchEvent(&event, status);
20621: }
20621: 
20621: void
20621: nsWindow::DispatchActivateEvent(void)
20621: {
32520:     NS_ASSERTION(mContainer || mIsDestroyed,
32520:                  "DispatchActivateEvent only intended for container windows");
32520: 
20621: #ifdef ACCESSIBILITY
20621:     DispatchActivateEventAccessible();
20621: #endif //ACCESSIBILITY
20621:     nsGUIEvent event(PR_TRUE, NS_ACTIVATE, this);
20621:     nsEventStatus status;
20621:     DispatchEvent(&event, status);
20621: }
20621: 
20621: void
20621: nsWindow::DispatchDeactivateEvent(void)
20621: {
20621:     nsGUIEvent event(PR_TRUE, NS_DEACTIVATE, this);
20621:     nsEventStatus status;
20621:     DispatchEvent(&event, status);
20621: 
20621: #ifdef ACCESSIBILITY
20621:     DispatchDeactivateEventAccessible();
20621: #endif //ACCESSIBILITY
20621: }
20621: 
20621: 
20621: 
20621: nsresult
25825: nsWindow::DispatchEvent(nsGUIEvent *aEvent, nsEventStatus &aStatus)
20621: {
20621: #ifdef DEBUG
20621:     debug_DumpEvent(stdout, aEvent->widget, aEvent,
20621:                     nsCAutoString("something"), 0);
20621: #endif
20621: 
20621:     aStatus = nsEventStatus_eIgnore;
20621: 
20621:     // send it to the standard callback
20621:     if (mEventCallback)
20621:         aStatus = (* mEventCallback)(aEvent);
20621: 
20621:     return NS_OK;
20621: }
20621: 
20621: void
20621: nsWindow::OnDestroy(void)
20621: {
20621:     if (mOnDestroyCalled)
20621:         return;
20621: 
20621:     mOnDestroyCalled = PR_TRUE;
20621:     
39858:     // Prevent deletion.
39858:     nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
39858: 
20621:     // release references to children, device context, toolkit + app shell
20621:     nsBaseWidget::OnDestroy(); 
20621:     
39858:     // Remove association between this object and its parent and siblings.
39858:     nsBaseWidget::Destroy();
20621:     mParent = nsnull;
20621: 
20621:     nsGUIEvent event(PR_TRUE, NS_DESTROY, this);
20621:     nsEventStatus status;
20621:     DispatchEvent(&event, status);
20621: }
20621: 
20621: PRBool
20621: nsWindow::AreBoundsSane(void)
20621: {
20621:     if (mBounds.width > 0 && mBounds.height > 0)
20621:         return PR_TRUE;
20621: 
20621:     return PR_FALSE;
20621: }
20621: 
28365: static GtkWidget*
28365: EnsureInvisibleContainer()
28365: {
28365:     if (!gInvisibleContainer) {
28365:         // GtkWidgets need to be anchored to a GtkWindow to be realized (to
28365:         // have a window).  Using GTK_WINDOW_POPUP rather than
28365:         // GTK_WINDOW_TOPLEVEL in the hope that POPUP results in less
28365:         // initialization and window manager interaction.
28365:         GtkWidget* window = gtk_window_new(GTK_WINDOW_POPUP);
28365:         gInvisibleContainer = moz_container_new();
28365:         gtk_container_add(GTK_CONTAINER(window), gInvisibleContainer);
28365:         gtk_widget_realize(gInvisibleContainer);
28365: 
28365:     }
28365:     return gInvisibleContainer;
28365: }
28365: 
28365: static void
28365: CheckDestroyInvisibleContainer()
28365: {
28365:     NS_PRECONDITION(gInvisibleContainer, "oh, no");
28365: 
28365:     if (!gdk_window_peek_children(gInvisibleContainer->window)) {
28365:         // No children, so not in use.
28365:         // Make sure to destroy the GtkWindow also.
28365:         gtk_widget_destroy(gInvisibleContainer->parent);
28365:         gInvisibleContainer = NULL;
28365:     }
28365: }
28365: 
28365: // Change the containing GtkWidget on a sub-hierarchy of GdkWindows belonging
28365: // to aOldWidget and rooted at aWindow, and reparent any child GtkWidgets of
34746: // the GdkWindow hierarchy to aNewWidget.
28365: static void
28365: SetWidgetForHierarchy(GdkWindow *aWindow,
28365:                       GtkWidget *aOldWidget,
28365:                       GtkWidget *aNewWidget)
28365: {
28365:     gpointer data;
28365:     gdk_window_get_user_data(aWindow, &data);
28365: 
28365:     if (data != aOldWidget) {
28365:         if (!GTK_IS_WIDGET(data))
28365:             return;
28365: 
28365:         GtkWidget* widget = static_cast<GtkWidget*>(data);
28365:         if (widget->parent != aOldWidget)
28365:             return;
28365: 
28365:         // This window belongs to a child widget, which will no longer be a
28365:         // child of aOldWidget.
28365:         gtk_widget_reparent(widget, aNewWidget);
28365: 
28365:         return;
28365:     }
28365: 
28433:     GList *children = gdk_window_get_children(aWindow);
28433:     for(GList *list = children; list; list = list->next) {
28365:         SetWidgetForHierarchy(GDK_WINDOW(list->data), aOldWidget, aNewWidget);
28365:     }
28433:     g_list_free(children);
28365: 
28365:     gdk_window_set_user_data(aWindow, aNewWidget);
28365: }
28365: 
34746: // Walk the list of child windows and call destroy on them.
34746: void
34746: nsWindow::DestroyChildWindows()
34746: {
34746:     if (!mGdkWindow)
34746:         return;
34746: 
34813:     while (GList *children = gdk_window_peek_children(mGdkWindow)) {
34746:         GdkWindow *child = GDK_WINDOW(children->data);
34746:         nsWindow *kid = get_window_for_gdk_window(child);
34746:         if (kid) {
34746:             kid->Destroy();
34746:         } else {
34746:             // This child is not an nsWindow.
34746:             // Destroy the child GtkWidget.
34746:             gpointer data;
34746:             gdk_window_get_user_data(child, &data);
34746:             if (GTK_IS_WIDGET(data)) {
34746:                 gtk_widget_destroy(static_cast<GtkWidget*>(data));
34746:             }
34746:         }
34746:     }
34746: }
34746: 
    1: NS_IMETHODIMP
    1: nsWindow::Destroy(void)
    1: {
    1:     if (mIsDestroyed || !mCreated)
    1:         return NS_OK;
    1: 
    1:     LOG(("nsWindow::Destroy [%p]\n", (void *)this));
    1:     mIsDestroyed = PR_TRUE;
    1:     mCreated = PR_FALSE;
    1: 
46205:     /** Need to clean our LayerManager up while still alive */
49074:     if (mLayerManager) {
49074:         nsRefPtr<GLContext> gl = nsnull;
49074:         if (mLayerManager->GetBackendType() == LayerManager::LAYERS_OPENGL) {
49074:             LayerManagerOGL *ogllm = static_cast<LayerManagerOGL*>(mLayerManager.get());
49074:             gl = ogllm->gl();
49074:         }
49074: 
49074:         mLayerManager->Destroy();
49074: 
49074:         if (gl) {
49074:             gl->MarkDestroyed();
49074:         }
49074:     }
49074:     mLayerManager = nsnull;
46205: 
61184:     ClearCachedResources();
61184: 
    1:     g_signal_handlers_disconnect_by_func(gtk_settings_get_default(),
34456:                                          FuncToGpointer(theme_changed_cb),
    1:                                          this);
    1: 
    1:     // ungrab if required
    1:     nsCOMPtr<nsIWidget> rollupWidget = do_QueryReferent(gRollupWindow);
 3233:     if (static_cast<nsIWidget *>(this) == rollupWidget.get()) {
    1:         if (gRollupListener)
29148:             gRollupListener->Rollup(nsnull, nsnull);
36806:         NS_IF_RELEASE(gMenuRollup);
    1:         gRollupWindow = nsnull;
    1:         gRollupListener = nsnull;
    1:     }
    1: 
    1:     NativeShow(PR_FALSE);
    1: 
39627:     if (mIMModule) {
39627:         mIMModule->OnDestroyWindow(this);
39627:     }
    1: 
    1:     // make sure that we remove ourself as the focus window
    1:     if (gFocusWindow == this) {
    1:         LOGFOCUS(("automatically losing focus...\n"));
    1:         gFocusWindow = nsnull;
    1:     }
    1: 
16529: #ifdef MOZ_X11
    1:     // make sure that we remove ourself as the plugin focus window
    1:     if (gPluginFocusWindow == this) {
    1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
    1:     }
16529: #endif /* MOZ_X11 */
    1: 
 6721:     if (mWindowGroup) {
 6721:         g_object_unref(G_OBJECT(mWindowGroup));
    1:         mWindowGroup = nsnull;
 6721:     }
    1: 
    1:     // Destroy thebes surface now. Badness can happen if we destroy
    1:     // the surface after its X Window.
    1:     mThebesSurface = nsnull;
    1: 
25825:     if (mDragLeaveTimer) {
25825:         mDragLeaveTimer->Cancel();
25825:         mDragLeaveTimer = nsnull;
25825:     }
25825: 
28365:     GtkWidget *owningWidget = GetMozContainerWidget();
28365:     if (mShell) {
28365:         gtk_widget_destroy(mShell);
28365:         mShell = nsnull;
28365:         mContainer = nsnull;
30705:         NS_ABORT_IF_FALSE(!mGdkWindow,
30705:                           "mGdkWindow should be NULL when mContainer is destroyed");
28365:     }
28365:     else if (mContainer) {
28365:         gtk_widget_destroy(GTK_WIDGET(mContainer));
28365:         mContainer = nsnull;
30705:         NS_ABORT_IF_FALSE(!mGdkWindow,
30705:                           "mGdkWindow should be NULL when mContainer is destroyed");
30705:     }
30705:     else if (mGdkWindow) {
34746:         // Destroy child windows to ensure that their mThebesSurfaces are
34746:         // released and to remove references from GdkWindows back to their
34746:         // container widget.  (OnContainerUnrealize() does this when the
34746:         // MozContainer widget is destroyed.)
34746:         DestroyChildWindows();
34746: 
34746:         gdk_window_set_user_data(mGdkWindow, NULL);
30705:         g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", NULL);
30704:         gdk_window_destroy(mGdkWindow);
30704:         mGdkWindow = nsnull;
18490:     }
18490: 
28365:     if (gInvisibleContainer && owningWidget == gInvisibleContainer) {
28365:         CheckDestroyInvisibleContainer();
    1:     }
    1: 
    1: #ifdef ACCESSIBILITY
    1:      if (mRootAccessible) {
    1:          mRootAccessible = nsnull;
    1:      }
    1: #endif
    1: 
39858:     // Save until last because OnDestroy() may cause us to be deleted.
39858:     OnDestroy();
39858: 
    1:     return NS_OK;
    1: }
    1: 
20621: nsIWidget *
20621: nsWindow::GetParent(void)
20621: {
20621:     return mParent;
20621: }
20621: 
50783: float
50783: nsWindow::GetDPI()
50783: {
57858: 
57858: #ifdef MOZ_PLATFORM_MAEMO
57858:     static float sDPI = 0;
57858: 
57858:     if (!sDPI) {
57858:         // X on Maemo does not report true DPI: https://bugs.maemo.org/show_bug.cgi?id=4825
57858:         nsCOMPtr<nsIPropertyBag2> infoService = do_GetService("@mozilla.org/system-info;1");
57858:         NS_ASSERTION(infoService, "Could not find a system info service");
57858: 
57858:         nsCString deviceType;
57858:         infoService->GetPropertyAsACString(NS_LITERAL_STRING("device"), deviceType);
57858:         if (deviceType.EqualsLiteral("Nokia N900")) {
57858:             sDPI = 265.0f;
57858:         } else if (deviceType.EqualsLiteral("Nokia N8xx")) {
57858:             sDPI = 225.0f;
57858:         } else {
57858:             // Fall back to something sane.
57858:             NS_WARNING("Unknown device - using default DPI");
57858:             sDPI = 96.0f;
57858:         }
57858:     }
57858:     return sDPI;
57858: #else
50783:     Display *dpy = GDK_DISPLAY();
50783:     int defaultScreen = DefaultScreen(dpy);
50784:     double heightInches = DisplayHeightMM(dpy, defaultScreen)/MM_PER_INCH_FLOAT;
50783:     if (heightInches < 0.25) {
50783:         // Something's broken, but we'd better not crash.
50783:         return 96.0f;
50783:     }
50783:     return float(DisplayHeight(dpy, defaultScreen)/heightInches);
57858: #endif
50783: }
50783: 
    1: NS_IMETHODIMP
    1: nsWindow::SetParent(nsIWidget *aNewParent)
    1: {
30704:     if (mContainer || !mGdkWindow || !mParent) {
28365:         NS_NOTREACHED("nsWindow::SetParent - reparenting a non-child window");
28365:         return NS_ERROR_NOT_IMPLEMENTED;
28365:     }
28365: 
54312:     NS_ASSERTION(!mTransientParent, "child widget with transient parent");
54312: 
28365:     nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
28365:     mParent->RemoveChild(this);
28365: 
28365:     mParent = aNewParent;
28365: 
28365:     GtkWidget* oldContainer = GetMozContainerWidget();
28365:     if (!oldContainer) {
28365:         // The GdkWindows have been destroyed so there is nothing else to
28365:         // reparent.
30704:         NS_ABORT_IF_FALSE(GDK_WINDOW_OBJECT(mGdkWindow)->destroyed,
28365:                           "live GdkWindow with no widget");
28365:         return NS_OK;
28365:     }
28365: 
28365:     if (aNewParent) {
54310:         aNewParent->AddChild(this);
54312:         ReparentNativeWidget(aNewParent);
28365:     } else {
28365:         // aNewParent is NULL, but reparent to a hidden window to avoid
28365:         // destroying the GdkWindow and its descendants.
28365:         // An invisible container widget is needed to hold descendant
28365:         // GtkWidgets.
54312:         GtkWidget* newContainer = EnsureInvisibleContainer();
54312:         GdkWindow* newParentWindow = newContainer->window;
54312:         ReparentNativeWidgetInternal(aNewParent, newContainer, newParentWindow,
54312:                                      oldContainer);
54312:     }
54312:     return NS_OK;
54312: }
54312: 
54312: NS_IMETHODIMP
54312: nsWindow::ReparentNativeWidget(nsIWidget* aNewParent)
54312: {
54312:     NS_PRECONDITION(aNewParent, "");
54312:     NS_ASSERTION(!mIsDestroyed, "");
54312:     NS_ASSERTION(!static_cast<nsWindow*>(aNewParent)->mIsDestroyed, "");
54312: 
54312:     GtkWidget* oldContainer = GetMozContainerWidget();
54312:     if (!oldContainer) {
54312:         // The GdkWindows have been destroyed so there is nothing else to
54312:         // reparent.
54312:         NS_ABORT_IF_FALSE(GDK_WINDOW_OBJECT(mGdkWindow)->destroyed,
54312:                           "live GdkWindow with no widget");
54312:         return NS_OK;
54312:     }
54312:     NS_ABORT_IF_FALSE(!GDK_WINDOW_OBJECT(mGdkWindow)->destroyed,
54312:                       "destroyed GdkWindow with widget");
54312:     
54312:     nsWindow* newParent = static_cast<nsWindow*>(aNewParent);
54312:     GdkWindow* newParentWindow = newParent->mGdkWindow;
54312:     GtkWidget* newContainer = NULL;
54312:     if (newParentWindow) {
54312:         newContainer = get_gtk_widget_for_gdk_window(newParentWindow);
54312:     }
54312: 
54312:     if (mTransientParent) {
54312:       GtkWindow* topLevelParent =
54312:           GTK_WINDOW(gtk_widget_get_toplevel(newContainer));
54312:       gtk_window_set_transient_for(GTK_WINDOW(mShell), topLevelParent);
54312:       mTransientParent = topLevelParent;
54312:       if (mWindowGroup) {
54312:           g_object_unref(G_OBJECT(mWindowGroup));
54312:           mWindowGroup = NULL;
54312:       }
54312:       if (mTransientParent->group) {
54312:           gtk_window_group_add_window(mTransientParent->group,
54312:                                       GTK_WINDOW(mShell));
54312:           mWindowGroup = mTransientParent->group;
54312:           g_object_ref(G_OBJECT(mWindowGroup));
54312:       }
54312:       else if (GTK_WINDOW(mShell)->group) {
54312:           gtk_window_group_remove_window(GTK_WINDOW(mShell)->group,
54312:                                          GTK_WINDOW(mShell));
54312:       }
54312:     }
54312: 
54312:     ReparentNativeWidgetInternal(aNewParent, newContainer, newParentWindow,
54312:                                  oldContainer);
54312:     return NS_OK;
54312: }
54312: 
54312: void
54312: nsWindow::ReparentNativeWidgetInternal(nsIWidget* aNewParent,
54312:                                        GtkWidget* aNewContainer,
54312:                                        GdkWindow* aNewParentWindow,
54312:                                        GtkWidget* aOldContainer)
54312: {
54312:     if (!aNewContainer) {
28365:         // The new parent GdkWindow has been destroyed.
54312:         NS_ABORT_IF_FALSE(!aNewParentWindow ||
54312:                           GDK_WINDOW_OBJECT(aNewParentWindow)->destroyed,
28365:                           "live GdkWindow with no widget");
28365:         Destroy();
28365:     } else {
54312:         if (aNewContainer != aOldContainer) {
54312:             NS_ABORT_IF_FALSE(!GDK_WINDOW_OBJECT(aNewParentWindow)->destroyed,
28365:                               "destroyed GdkWindow with widget");
54312:             SetWidgetForHierarchy(mGdkWindow, aOldContainer, aNewContainer);
54312:         }
54312: 
54312:         if (!mIsTopLevel) {
54312:             gdk_window_reparent(mGdkWindow, aNewParentWindow, mBounds.x,
54312:                                 mBounds.y);
54312:         }
54312:     }
54312: 
54312:     nsWindow* newParent = static_cast<nsWindow*>(aNewParent);
34456:     PRBool parentHasMappedToplevel =
34456:         newParent && newParent->mHasMappedToplevel;
34456:     if (mHasMappedToplevel != parentHasMappedToplevel) {
34456:         SetHasMappedToplevel(parentHasMappedToplevel);
34456:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetModal(PRBool aModal)
    1: {
    1:     LOG(("nsWindow::SetModal [%p] %d\n", (void *)this, aModal));
43004:     if (mIsDestroyed)
43004:         return aModal ? NS_ERROR_NOT_AVAILABLE : NS_OK;
43004:     if (!mIsTopLevel || !mShell)
    1:         return NS_ERROR_FAILURE;
43004:     gtk_window_set_modal(GTK_WINDOW(mShell), aModal ? TRUE : FALSE);
    1:     return NS_OK;
    1: }
    1: 
30702: // nsIWidget method, which means IsShown.
    1: NS_IMETHODIMP
    1: nsWindow::IsVisible(PRBool& aState)
    1: {
30702:     aState = mIsShown;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::ConstrainPosition(PRBool aAllowSlop, PRInt32 *aX, PRInt32 *aY)
    1: {
    1:     if (mIsTopLevel && mShell) {
    1:         PRInt32 screenWidth = gdk_screen_width();
    1:         PRInt32 screenHeight = gdk_screen_height();
    1:         if (aAllowSlop) {
    1:             if (*aX < (kWindowPositionSlop - mBounds.width))
    1:                 *aX = kWindowPositionSlop - mBounds.width;
    1:             if (*aX > (screenWidth - kWindowPositionSlop))
    1:                 *aX = screenWidth - kWindowPositionSlop;
    1:             if (*aY < (kWindowPositionSlop - mBounds.height))
    1:                 *aY = kWindowPositionSlop - mBounds.height;
    1:             if (*aY > (screenHeight - kWindowPositionSlop))
    1:                 *aY = screenHeight - kWindowPositionSlop;
    1:         } else {
    1:             if (*aX < 0)
    1:                 *aX = 0;
    1:             if (*aX > (screenWidth - mBounds.width))
    1:                 *aX = screenWidth - mBounds.width;
    1:             if (*aY < 0)
    1:                 *aY = 0;
    1:             if (*aY > (screenHeight - mBounds.height))
    1:                 *aY = screenHeight - mBounds.height;
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
20621: nsWindow::Show(PRBool aState)
20621: {
34456:     if (aState == mIsShown)
34456:         return NS_OK;
34456: 
61184:     // Clear our cached resources when the window is hidden.
61184:     if (mIsShown && !aState) {
61184:         ClearCachedResources();
61184:     }
61184: 
20621:     mIsShown = aState;
20621: 
20621:     LOG(("nsWindow::Show [%p] state %d\n", (void *)this, aState));
20621: 
34456:     if (aState) {
34456:         // Now that this window is shown, mHasMappedToplevel needs to be
34456:         // tracked on viewable descendants.
34456:         SetHasMappedToplevel(mHasMappedToplevel);
34456:     }
34456: 
20621:     // Ok, someone called show on a window that isn't sized to a sane
20621:     // value.  Mark this window as needing to have Show() called on it
20621:     // and return.
20621:     if ((aState && !AreBoundsSane()) || !mCreated) {
20621:         LOG(("\tbounds are insane or window hasn't been created yet\n"));
20621:         mNeedsShow = PR_TRUE;
20621:         return NS_OK;
20621:     }
20621: 
20621:     // If someone is hiding this widget, clear any needing show flag.
20621:     if (!aState)
20621:         mNeedsShow = PR_FALSE;
20621: 
20621:     // If someone is showing this window and it needs a resize then
20621:     // resize the widget.
20621:     if (aState) {
20621:         if (mNeedsMove) {
20621:             NativeResize(mBounds.x, mBounds.y, mBounds.width, mBounds.height,
20621:                          PR_FALSE);
20621:         } else if (mNeedsResize) {
20621:             NativeResize(mBounds.width, mBounds.height, PR_FALSE);
20621:         }
20621:     }
20621: 
20621:     NativeShow(aState);
20621: 
20621:     return NS_OK;
20621: }
20621: 
20621: NS_IMETHODIMP
20621: nsWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
20621: {
23738:     mBounds.SizeTo(GetSafeWindowSize(nsIntSize(aWidth, aHeight)));
20621: 
20621:     if (!mCreated)
20621:         return NS_OK;
20621: 
20621:     // There are several cases here that we need to handle, based on a
20621:     // matrix of the visibility of the widget, the sanity of this resize
20621:     // and whether or not the widget was previously sane.
20621: 
20621:     // Has this widget been set to visible?
20621:     if (mIsShown) {
20621:         // Are the bounds sane?
20621:         if (AreBoundsSane()) {
20621:             // Yep?  Resize the window
20621:             //Maybe, the toplevel has moved
20621: 
59546:             // Note that if the widget needs to be positioned because its
59546:             // size was previously insane in Resize(x,y,w,h), then we need
20621:             // to set the x and y here too, because the widget wasn't
20621:             // moved back then
59546:             if (mNeedsMove)
20621:                 NativeResize(mBounds.x, mBounds.y,
20621:                              mBounds.width, mBounds.height, aRepaint);
20621:             else
20621:                 NativeResize(mBounds.width, mBounds.height, aRepaint);
20621: 
20621:             // Does it need to be shown because it was previously insane?
20621:             if (mNeedsShow)
20621:                 NativeShow(PR_TRUE);
20621:         }
20621:         else {
20621:             // If someone has set this so that the needs show flag is false
20621:             // and it needs to be hidden, update the flag and hide the
20621:             // window.  This flag will be cleared the next time someone
20621:             // hides the window or shows it.  It also prevents us from
20621:             // calling NativeShow(PR_FALSE) excessively on the window which
20621:             // causes unneeded X traffic.
20621:             if (!mNeedsShow) {
20621:                 mNeedsShow = PR_TRUE;
20621:                 NativeShow(PR_FALSE);
20621:             }
20621:         }
20621:     }
20621:     // If the widget hasn't been shown, mark the widget as needing to be
20621:     // resized before it is shown.
20621:     else {
20621:         if (AreBoundsSane() && mListenForResizes) {
20621:             // For widgets that we listen for resizes for (widgets created
20621:             // with native parents) we apparently _always_ have to resize.  I
20621:             // dunno why, but apparently we're lame like that.
20621:             NativeResize(aWidth, aHeight, aRepaint);
20621:         }
20621:         else {
20621:             mNeedsResize = PR_TRUE;
20621:         }
20621:     }
20621: 
20621:     // synthesize a resize event if this isn't a toplevel
20621:     if (mIsTopLevel || mListenForResizes) {
23738:         nsIntRect rect(mBounds.x, mBounds.y, aWidth, aHeight);
20621:         nsEventStatus status;
20621:         DispatchResizeEvent(rect, status);
20621:     }
20621: 
20621:     return NS_OK;
20621: }
20621: 
20621: NS_IMETHODIMP
20621: nsWindow::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight,
20621:                        PRBool aRepaint)
20621: {
20621:     mBounds.x = aX;
20621:     mBounds.y = aY;
23738:     mBounds.SizeTo(GetSafeWindowSize(nsIntSize(aWidth, aHeight)));
20621: 
59546:     mNeedsMove = PR_TRUE;
20621: 
20621:     if (!mCreated)
20621:         return NS_OK;
20621: 
20621:     // There are several cases here that we need to handle, based on a
20621:     // matrix of the visibility of the widget, the sanity of this resize
20621:     // and whether or not the widget was previously sane.
20621: 
20621:     // Has this widget been set to visible?
20621:     if (mIsShown) {
20621:         // Are the bounds sane?
20621:         if (AreBoundsSane()) {
20621:             // Yep?  Resize the window
20621:             NativeResize(aX, aY, aWidth, aHeight, aRepaint);
20621:             // Does it need to be shown because it was previously insane?
20621:             if (mNeedsShow)
20621:                 NativeShow(PR_TRUE);
20621:         }
20621:         else {
20621:             // If someone has set this so that the needs show flag is false
20621:             // and it needs to be hidden, update the flag and hide the
20621:             // window.  This flag will be cleared the next time someone
20621:             // hides the window or shows it.  It also prevents us from
20621:             // calling NativeShow(PR_FALSE) excessively on the window which
20621:             // causes unneeded X traffic.
20621:             if (!mNeedsShow) {
20621:                 mNeedsShow = PR_TRUE;
20621:                 NativeShow(PR_FALSE);
20621:             }
20621:         }
20621:     }
20621:     // If the widget hasn't been shown, mark the widget as needing to be
20621:     // resized before it is shown
20621:     else {
20621:         if (AreBoundsSane() && mListenForResizes){
20621:             // For widgets that we listen for resizes for (widgets created
20621:             // with native parents) we apparently _always_ have to resize.  I
20621:             // dunno why, but apparently we're lame like that.
20621:             NativeResize(aX, aY, aWidth, aHeight, aRepaint);
20621:         }
20621:         else {
20621:             mNeedsResize = PR_TRUE;
20621:         }
20621:     }
20621: 
20621:     if (mIsTopLevel || mListenForResizes) {
20621:         // synthesize a resize event
23738:         nsIntRect rect(aX, aY, aWidth, aHeight);
20621:         nsEventStatus status;
20621:         DispatchResizeEvent(rect, status);
20621:     }
20621: 
20621:     return NS_OK;
20621: }
20621: 
20621: NS_IMETHODIMP
20621: nsWindow::Enable(PRBool aState)
20621: {
20621:     mEnabled = aState;
20621: 
20621:     return NS_OK;
20621: }
20621: 
20621: NS_IMETHODIMP
20621: nsWindow::IsEnabled(PRBool *aState)
20621: {
20621:     *aState = mEnabled;
20621: 
20621:     return NS_OK;
20621: }
20621: 
20621: 
20621: 
20621: NS_IMETHODIMP
    1: nsWindow::Move(PRInt32 aX, PRInt32 aY)
    1: {
    1:     LOG(("nsWindow::Move [%p] %d %d\n", (void *)this,
    1:          aX, aY));
    1: 
34488:     if (mWindowType == eWindowType_toplevel ||
34488:         mWindowType == eWindowType_dialog) {
34488:         SetSizeMode(nsSizeMode_Normal);
34488:     }
34488: 
    1:     // Since a popup window's x/y coordinates are in relation to to
    1:     // the parent, the parent might have moved so we always move a
    1:     // popup window.
    1:     if (aX == mBounds.x && aY == mBounds.y &&
    1:         mWindowType != eWindowType_popup)
    1:         return NS_OK;
    1: 
    1:     // XXX Should we do some AreBoundsSane check here?
    1: 
    1:     mBounds.x = aX;
    1:     mBounds.y = aY;
    1: 
    1:     if (!mCreated)
    1:         return NS_OK;
    1: 
59547:     mNeedsMove = PR_FALSE;
59547: 
    1:     if (mIsTopLevel) {
    1:         gtk_window_move(GTK_WINDOW(mShell), aX, aY);
    1:     }
30704:     else if (mGdkWindow) {
30704:         gdk_window_move(mGdkWindow, aX, aY);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
14964: nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement  aPlacement,
14964:                       nsIWidget                  *aWidget,
    1:                       PRBool                      aActivate)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetZIndex(PRInt32 aZIndex)
    1: {
    1:     nsIWidget* oldPrev = GetPrevSibling();
    1: 
    1:     nsBaseWidget::SetZIndex(aZIndex);
    1: 
    1:     if (GetPrevSibling() == oldPrev) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     NS_ASSERTION(!mContainer, "Expected Mozilla child widget");
    1: 
30704:     // We skip the nsWindows that don't have mGdkWindows.
    1:     // These are probably in the process of being destroyed.
    1: 
    1:     if (!GetNextSibling()) {
    1:         // We're to be on top.
30704:         if (mGdkWindow)
30704:             gdk_window_raise(mGdkWindow);
    1:     } else {
    1:         // All the siblings before us need to be below our widget.
    1:         for (nsWindow* w = this; w;
 3233:              w = static_cast<nsWindow*>(w->GetPrevSibling())) {
30704:             if (w->mGdkWindow)
30704:                 gdk_window_lower(w->mGdkWindow);
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetSizeMode(PRInt32 aMode)
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("nsWindow::SetSizeMode [%p] %d\n", (void *)this, aMode));
    1: 
    1:     // Save the requested state.
    1:     rv = nsBaseWidget::SetSizeMode(aMode);
    1: 
    1:     // return if there's no shell or our current state is the same as
    1:     // the mode we were just set to.
    1:     if (!mShell || mSizeState == mSizeMode) {
    1:         return rv;
    1:     }
    1: 
    1:     switch (aMode) {
    1:     case nsSizeMode_Maximized:
    1:         gtk_window_maximize(GTK_WINDOW(mShell));
    1:         break;
    1:     case nsSizeMode_Minimized:
    1:         gtk_window_iconify(GTK_WINDOW(mShell));
    1:         break;
31567:     case nsSizeMode_Fullscreen:
31567:         MakeFullScreen(PR_TRUE);
31567:         break;
31567: 
    1:     default:
    1:         // nsSizeMode_Normal, really.
    1:         if (mSizeState == nsSizeMode_Minimized)
    1:             gtk_window_deiconify(GTK_WINDOW(mShell));
    1:         else if (mSizeState == nsSizeMode_Maximized)
    1:             gtk_window_unmaximize(GTK_WINDOW(mShell));
    1:         break;
    1:     }
    1: 
    1:     mSizeState = mSizeMode;
    1: 
    1:     return rv;
    1: }
    1: 
    1: typedef void (* SetUserTimeFunc)(GdkWindow* aWindow, guint32 aTimestamp);
    1: 
    1: // This will become obsolete when new GTK APIs are widely supported,
    1: // as described here: http://bugzilla.gnome.org/show_bug.cgi?id=347375
    1: static void
    1: SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow)
    1: {
    1:     nsCOMPtr<nsIToolkit> toolkit;
    1:     NS_GetCurrentToolkit(getter_AddRefs(toolkit));
    1:     if (!toolkit)
    1:         return;
    1: 
 3233:     nsGTKToolkit* GTKToolkit = static_cast<nsGTKToolkit*>
 3233:                                           (static_cast<nsIToolkit*>(toolkit));
    1:     nsCAutoString desktopStartupID;
    1:     GTKToolkit->GetDesktopStartupID(&desktopStartupID);
    1:     if (desktopStartupID.IsEmpty()) {
    1:         // We don't have the data we need. Fall back to an
    1:         // approximation ... using the timestamp of the remote command
    1:         // being received as a guess for the timestamp of the user event
    1:         // that triggered it.
    1:         PRUint32 timestamp = GTKToolkit->GetFocusTimestamp();
    1:         if (timestamp) {
    1:             gdk_window_focus(aWindow->window, timestamp);
    1:             GTKToolkit->SetFocusTimestamp(0);
    1:         }
    1:         return;
    1:     }
    1: 
    1: #ifdef MOZ_ENABLE_STARTUP_NOTIFICATION
    1:     GdkDrawable* drawable = GDK_DRAWABLE(aWindow->window);
    1:     GtkWindow* win = GTK_WINDOW(aWindow);
    1:     if (!win) {
    1:         NS_WARNING("Passed in widget was not a GdkWindow!");
    1:         return;
    1:     }
    1:     GdkScreen* screen = gtk_window_get_screen(win);
    1:     SnDisplay* snd =
    1:         sn_display_new(gdk_x11_drawable_get_xdisplay(drawable), nsnull, nsnull);
    1:     if (!snd)
    1:         return;
    1:     SnLauncheeContext* ctx =
    1:         sn_launchee_context_new(snd, gdk_screen_get_number(screen),
    1:                                 desktopStartupID.get());
    1:     if (!ctx) {
    1:         sn_display_unref(snd);
    1:         return;
    1:     }
    1: 
    1:     if (sn_launchee_context_get_id_has_timestamp(ctx)) {
    1:         PRLibrary* gtkLibrary;
    1:         SetUserTimeFunc setUserTimeFunc = (SetUserTimeFunc)
    1:             PR_FindFunctionSymbolAndLibrary("gdk_x11_window_set_user_time", &gtkLibrary);
    1:         if (setUserTimeFunc) {
    1:             setUserTimeFunc(aWindow->window, sn_launchee_context_get_timestamp(ctx));
    1:             PR_UnloadLibrary(gtkLibrary);
    1:         }
    1:     }
    1: 
    1:     sn_launchee_context_setup_window(ctx, gdk_x11_drawable_get_xid(drawable));
    1:     sn_launchee_context_complete(ctx);
    1: 
    1:     sn_launchee_context_unref(ctx);
    1:     sn_display_unref(snd);
    1: #endif
    1: 
    1:     GTKToolkit->SetDesktopStartupID(EmptyCString());
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetFocus(PRBool aRaise)
    1: {
    1:     // Make sure that our owning widget has focus.  If it doesn't try to
    1:     // grab it.  Note that we don't set our focus flag in this case.
    1: 
43760:     LOGFOCUS(("  SetFocus %d [%p]\n", aRaise, (void *)this));
    1: 
18490:     GtkWidget *owningWidget = GetMozContainerWidget();
    1:     if (!owningWidget)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // Raise the window if someone passed in PR_TRUE and the prefs are
    1:     // set properly.
    1:     GtkWidget *toplevelWidget = gtk_widget_get_toplevel(owningWidget);
    1: 
    1:     if (gRaiseWindows && aRaise && toplevelWidget &&
    1:         !GTK_WIDGET_HAS_FOCUS(owningWidget) &&
    1:         !GTK_WIDGET_HAS_FOCUS(toplevelWidget)) {
    1:         GtkWidget* top_window = nsnull;
    1:         GetToplevelWidget(&top_window);
    1:         if (top_window && (GTK_WIDGET_VISIBLE(top_window)))
    1:         {
    1:             gdk_window_show_unraised(top_window->window);
    1:             // Unset the urgency hint if possible.
    1:             SetUrgencyHint(top_window, PR_FALSE);
    1:         }
    1:     }
    1: 
  920:     nsRefPtr<nsWindow> owningWindow = get_window_for_gtk_widget(owningWidget);
    1:     if (!owningWindow)
    1:         return NS_ERROR_FAILURE;
    1: 
43760:     if (aRaise) {
43760:         // aRaise == PR_TRUE means request toplevel activation.
43760: 
43760:         // This is asynchronous.
43760:         // If and when the window manager accepts the request, then the focus
43760:         // widget will get a focus-in-event signal.
43760:         if (gRaiseWindows && owningWindow->mIsShown && owningWindow->mShell &&
43760:             !gtk_window_is_active(GTK_WINDOW(owningWindow->mShell))) {
43760: 
43760:             LOGFOCUS(("  requesting toplevel activation [%p]\n", (void *)this));
43760:             NS_ASSERTION(owningWindow->mWindowType != eWindowType_popup
43760:                          || mParent,
43760:                          "Presenting an override-redirect window");
    1:             gtk_window_present(GTK_WINDOW(owningWindow->mShell));
43760:         }
43760: 
43760:         return NS_OK;
43760:     }
43760: 
43760:     // aRaise == PR_FALSE means that keyboard events should be dispatched
43760:     // from this widget.
43760: 
43760:     // Ensure owningWidget is the focused GtkWidget within its toplevel window.
43760:     //
43760:     // For eWindowType_popup, this GtkWidget may not actually be the one that
43760:     // receives the key events as it may be the parent window that is active.
43760:     if (!gtk_widget_is_focus(owningWidget)) {
43760:         // This is synchronous.  It takes focus from a plugin or from a widget
43760:         // in an embedder.  The focus manager already knows that this window
43760:         // is active so gBlockActivateEvent avoids another (unnecessary)
43760:         // NS_ACTIVATE event.
43760:         gBlockActivateEvent = PR_TRUE;
    1:         gtk_widget_grab_focus(owningWidget);
43760:         gBlockActivateEvent = PR_FALSE;
    1:     }
    1: 
    1:     // If this is the widget that already has focus, return.
    1:     if (gFocusWindow == this) {
    1:         LOGFOCUS(("  already have focus [%p]\n", (void *)this));
    1:         return NS_OK;
    1:     }
    1: 
29018:     // Set this window to be the focused child window
    1:     gFocusWindow = this;
    1: 
39627:     if (mIMModule) {
39627:         mIMModule->OnFocusWindow(this);
39627:     }
    1: 
30583:     LOGFOCUS(("  widget now has focus in SetFocus() [%p]\n",
    1:               (void *)this));
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23738: nsWindow::GetScreenBounds(nsIntRect &aRect)
23738: {
48259:     if (mIsTopLevel && mContainer) {
48259:         // use the point including window decorations
48259:         gint x, y;
48259:         gdk_window_get_root_origin(GTK_WIDGET(mContainer)->window, &x, &y);
48259:         aRect.MoveTo(x, y);
48259:     }
48259:     else {
48259:         aRect.MoveTo(WidgetToScreenOffset());
48259:     }
48259:     aRect.SizeTo(mBounds.Size());
    1:     LOG(("GetScreenBounds %d %d | %d %d | %d %d\n",
    1:          aRect.x, aRect.y,
    1:          mBounds.width, mBounds.height,
    1:          aRect.width, aRect.height));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetForegroundColor(const nscolor &aColor)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetBackgroundColor(const nscolor &aColor)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetCursor(nsCursor aCursor)
    1: {
    1:     // if we're not the toplevel window pass up the cursor request to
    1:     // the toplevel window to handle it.
30704:     if (!mContainer && mGdkWindow) {
25258:         nsWindow *window = GetContainerWindow();
25258:         if (!window)
25258:             return NS_ERROR_FAILURE;
25258: 
    1:         return window->SetCursor(aCursor);
    1:     }
    1: 
    1:     // Only change cursor if it's actually been changed
    1:     if (aCursor != mCursor) {
    1:         GdkCursor *newCursor = NULL;
    1: 
    1:         newCursor = get_gtk_cursor(aCursor);
    1: 
    1:         if (nsnull != newCursor) {
    1:             mCursor = aCursor;
    1: 
    1:             if (!mContainer)
    1:                 return NS_OK;
    1: 
    1:             gdk_window_set_cursor(GTK_WIDGET(mContainer)->window, newCursor);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: static
    1: PRUint8* Data32BitTo1Bit(PRUint8* aImageData,
    1:                          PRUint32 aImageBytesPerRow,
    1:                          PRUint32 aWidth, PRUint32 aHeight)
    1: {
    1:   PRUint32 outBpr = (aWidth + 7) / 8;
    1: 
    1:   PRUint8* outData = new PRUint8[outBpr * aHeight];
    1:   if (!outData)
    1:       return NULL;
    1: 
    1:   PRUint8 *outRow = outData,
    1:           *imageRow = aImageData;
    1: 
    1:   for (PRUint32 curRow = 0; curRow < aHeight; curRow++) {
    1:       PRUint8 *irow = imageRow;
    1:       PRUint8 *orow = outRow;
    1:       PRUint8 imagePixels = 0;
    1:       PRUint8 offset = 0;
    1: 
    1:       for (PRUint32 curCol = 0; curCol < aWidth; curCol++) {
    1:           PRUint8 r = *imageRow++,
    1:                   g = *imageRow++,
    1:                   b = *imageRow++;
    1:                /* a = * */imageRow++;
    1: 
    1:           if ((r + b + g) < 3 * 128)
    1:               imagePixels |= (1 << offset);
    1: 
    1:           if (offset == 7) {
    1:               *outRow++ = imagePixels;
    1:               offset = 0;
    1:               imagePixels = 0;
    1:           } else {
    1:               offset++;
    1:           }
    1:       }
    1:       if (offset != 0)
    1:           *outRow++ = imagePixels;
    1: 
    1:       imageRow = irow + aImageBytesPerRow;
    1:       outRow = orow + outBpr;
    1:   }
    1: 
    1:   return outData;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetCursor(imgIContainer* aCursor,
    1:                     PRUint32 aHotspotX, PRUint32 aHotspotY)
    1: {
    1:     // if we're not the toplevel window pass up the cursor request to
    1:     // the toplevel window to handle it.
30704:     if (!mContainer && mGdkWindow) {
25258:         nsWindow *window = GetContainerWindow();
25258:         if (!window)
25258:             return NS_ERROR_FAILURE;
25258: 
    1:         return window->SetCursor(aCursor, aHotspotX, aHotspotY);
    1:     }
    1: 
    1:     if (!sPixbufCursorChecked) {
    1:         PRLibrary* lib;
    1:         _gdk_cursor_new_from_pixbuf = (_gdk_cursor_new_from_pixbuf_fn)
    1:             PR_FindFunctionSymbolAndLibrary("gdk_cursor_new_from_pixbuf", &lib);
  544:         if (lib) {
  544:             // We already link against GDK, so we can unload it.
  544:             PR_UnloadLibrary(lib);
  544:             lib = nsnull;
  544:         }
    1:         _gdk_display_get_default = (_gdk_display_get_default_fn)
    1:             PR_FindFunctionSymbolAndLibrary("gdk_display_get_default", &lib);
  544:         if (lib) {
  544:             // We already link against GDK, so we can unload it.
  544:             PR_UnloadLibrary(lib);
  544:             lib = nsnull;
  544:         }
    1:         sPixbufCursorChecked = PR_TRUE;
    1:     }
    1:     mCursor = nsCursor(-1);
    1: 
30479:     // Get the image's current frame
30479:     GdkPixbuf* pixbuf = nsImageToPixbuf::ImageToPixbuf(aCursor);
    1:     if (!pixbuf)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     int width = gdk_pixbuf_get_width(pixbuf);
    1:     int height = gdk_pixbuf_get_height(pixbuf);
    1:     // Reject cursors greater than 128 pixels in some direction, to prevent
    1:     // spoofing.
    1:     // XXX ideally we should rescale. Also, we could modify the API to
    1:     // allow trusted content to set larger cursors.
 6790:     if (width > 128 || height > 128) {
24530:         g_object_unref(pixbuf);
    1:         return NS_ERROR_NOT_AVAILABLE;
 6790:     }
    1: 
    1:     // Looks like all cursors need an alpha channel (tested on Gtk 2.4.4). This
    1:     // is of course not documented anywhere...
    1:     // So add one if there isn't one yet
    1:     if (!gdk_pixbuf_get_has_alpha(pixbuf)) {
    1:         GdkPixbuf* alphaBuf = gdk_pixbuf_add_alpha(pixbuf, FALSE, 0, 0, 0);
24530:         g_object_unref(pixbuf);
    1:         if (!alphaBuf) {
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:         pixbuf = alphaBuf;
    1:     }
    1: 
    1:     GdkCursor* cursor;
    1:     if (!_gdk_cursor_new_from_pixbuf || !_gdk_display_get_default) {
    1:         // Fallback to a monochrome cursor
    1:         GdkPixmap* mask = gdk_pixmap_new(NULL, width, height, 1);
 6790:         if (!mask) {
24530:             g_object_unref(pixbuf);
    1:             return NS_ERROR_OUT_OF_MEMORY;
 6790:         }
    1: 
    1:         PRUint8* data = Data32BitTo1Bit(gdk_pixbuf_get_pixels(pixbuf),
    1:                                         gdk_pixbuf_get_rowstride(pixbuf),
    1:                                         width, height);
    1:         if (!data) {
    1:             g_object_unref(mask);
24530:             g_object_unref(pixbuf);
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         GdkPixmap* image = gdk_bitmap_create_from_data(NULL, (const gchar*)data, width,
    1:                                                        height);
    1:         delete[] data;
    1:         if (!image) {
    1:             g_object_unref(mask);
24530:             g_object_unref(pixbuf);
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         gdk_pixbuf_render_threshold_alpha(pixbuf, mask, 0, 0, 0, 0, width,
    1:                                           height, 1);
    1: 
    1:         GdkColor fg = { 0, 0, 0, 0 }; // Black
    1:         GdkColor bg = { 0, 0xFFFF, 0xFFFF, 0xFFFF }; // White
    1: 
    1:         cursor = gdk_cursor_new_from_pixmap(image, mask, &fg, &bg, aHotspotX,
    1:                                             aHotspotY);
    1:         g_object_unref(image);
    1:         g_object_unref(mask);
    1:     } else {
    1:         // Now create the cursor
    1:         cursor = _gdk_cursor_new_from_pixbuf(_gdk_display_get_default(),
    1:                                              pixbuf,
    1:                                              aHotspotX, aHotspotY);
    1:     }
24530:     g_object_unref(pixbuf);
    1:     nsresult rv = NS_ERROR_OUT_OF_MEMORY;
    1:     if (cursor) {
    1:         if (mContainer) {
    1:             gdk_window_set_cursor(GTK_WIDGET(mContainer)->window, cursor);
    1:             rv = NS_OK;
    1:         }
    1:         gdk_cursor_unref(cursor);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
23738: nsWindow::Invalidate(const nsIntRect &aRect,
    1:                      PRBool           aIsSynchronous)
    1: {
34456:     if (!mGdkWindow)
30702:         return NS_OK;
30702: 
    1:     GdkRectangle rect;
    1:     rect.x = aRect.x;
    1:     rect.y = aRect.y;
    1:     rect.width = aRect.width;
    1:     rect.height = aRect.height;
    1: 
    1:     LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d (sync: %d)\n", (void *)this,
    1:              rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
    1: 
30704:     gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
    1:     if (aIsSynchronous)
30704:         gdk_window_process_updates(mGdkWindow, FALSE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::Update()
    1: {
30704:     if (!mGdkWindow)
    1:         return NS_OK;
    1: 
34456:     LOGDRAW(("Update [%p] %p\n", this, mGdkWindow));
34456: 
30704:     gdk_window_process_updates(mGdkWindow, FALSE);
35698:     // Send the updates to the server.
35698:     gdk_display_flush(gdk_drawable_get_display(GDK_DRAWABLE(mGdkWindow)));
    1:     return NS_OK;
    1: }
    1: 
    1: void*
    1: nsWindow::GetNativeData(PRUint32 aDataType)
    1: {
    1:     switch (aDataType) {
    1:     case NS_NATIVE_WINDOW:
    1:     case NS_NATIVE_WIDGET: {
30704:         if (!mGdkWindow)
    1:             return nsnull;
    1: 
30704:         return mGdkWindow;
    1:         break;
    1:     }
    1: 
    1:     case NS_NATIVE_PLUGIN_PORT:
    1:         return SetupPluginPort();
    1:         break;
    1: 
    1:     case NS_NATIVE_DISPLAY:
16529: #ifdef MOZ_X11
    1:         return GDK_DISPLAY();
16529: #else
16529:         return nsnull;
16529: #endif /* MOZ_X11 */
    1:         break;
    1: 
    1:     case NS_NATIVE_GRAPHIC: {
    1:         NS_ASSERTION(nsnull != mToolkit, "NULL toolkit, unable to get a GC");
 3233:         return (void *)static_cast<nsGTKToolkit *>(mToolkit)->GetSharedGC();
    1:         break;
    1:     }
    1: 
    1:     case NS_NATIVE_SHELLWIDGET:
    1:         return (void *) mShell;
    1: 
    1:     default:
    1:         NS_WARNING("nsWindow::GetNativeData called with bad value");
    1:         return nsnull;
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetTitle(const nsAString& aTitle)
    1: {
    1:     if (!mShell)
    1:         return NS_OK;
    1: 
    1:     // convert the string into utf8 and set the title.
    1: #define UTF8_FOLLOWBYTE(ch) (((ch) & 0xC0) == 0x80)
    1:     NS_ConvertUTF16toUTF8 titleUTF8(aTitle);
    1:     if (titleUTF8.Length() > NS_WINDOW_TITLE_MAX_LENGTH) {
    1:         // Truncate overlong titles (bug 167315). Make sure we chop after a
    1:         // complete sequence by making sure the next char isn't a follow-byte.
    1:         PRUint32 len = NS_WINDOW_TITLE_MAX_LENGTH;
    1:         while(UTF8_FOLLOWBYTE(titleUTF8[len]))
    1:             --len;
    1:         titleUTF8.Truncate(len);
    1:     }
    1:     gtk_window_set_title(GTK_WINDOW(mShell), (const char *)titleUTF8.get());
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetIcon(const nsAString& aIconSpec)
    1: {
    1:     if (!mShell)
    1:         return NS_OK;
    1: 
    1:     nsCOMPtr<nsILocalFile> iconFile;
    1:     nsCAutoString path;
24031:     nsTArray<nsCString> iconList;
    1: 
10124:     // Look for icons with the following suffixes appended to the base name.
10124:     // The last two entries (for the old XPM format) will be ignored unless
10124:     // no icons are found using the other suffixes. XPM icons are depricated.
10124: 
10124:     const char extensions[6][7] = { ".png", "16.png", "32.png", "48.png",
10124:                                     ".xpm", "16.xpm" };
10124: 
10124:     for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(extensions); i++) {
10124:         // Don't bother looking for XPM versions if we found a PNG.
24031:         if (i == NS_ARRAY_LENGTH(extensions) - 2 && iconList.Length())
10124:             break;
10124: 
10124:         nsAutoString extension;
10124:         extension.AppendASCII(extensions[i]);
10124: 
10124:         ResolveIconName(aIconSpec, extension, getter_AddRefs(iconFile));
    1:         if (iconFile) {
    1:             iconFile->GetNativePath(path);
24031:             iconList.AppendElement(path);
    1:         }
    1:     }
    1: 
    1:     // leave the default icon intact if no matching icons were found
24031:     if (iconList.Length() == 0)
    1:         return NS_OK;
    1: 
    1:     return SetWindowIconList(iconList);
    1: }
    1: 
25183: nsIntPoint
25183: nsWindow::WidgetToScreenOffset()
    1: {
    1:     gint x = 0, y = 0;
    1: 
48259:     if (mGdkWindow) {
30704:         gdk_window_get_origin(mGdkWindow, &x, &y);
25183:     }
25183: 
25183:     return nsIntPoint(x, y);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::EnableDragDrop(PRBool aEnable)
    1: {
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::CaptureMouse(PRBool aCapture)
    1: {
    1:     LOG(("CaptureMouse %p\n", (void *)this));
    1: 
30704:     if (!mGdkWindow)
    1:         return NS_OK;
    1: 
18490:     GtkWidget *widget = GetMozContainerWidget();
25258:     if (!widget)
25258:         return NS_ERROR_FAILURE;
    1: 
    1:     if (aCapture) {
    1:         gtk_grab_add(widget);
    1:         GrabPointer();
    1:     }
    1:     else {
    1:         ReleaseGrabs();
    1:         gtk_grab_remove(widget);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::CaptureRollupEvents(nsIRollupListener *aListener,
36806:                               nsIMenuRollup     *aMenuRollup,
    1:                               PRBool             aDoCapture,
    1:                               PRBool             aConsumeRollupEvent)
    1: {
30704:     if (!mGdkWindow)
    1:         return NS_OK;
    1: 
18490:     GtkWidget *widget = GetMozContainerWidget();
25258:     if (!widget)
25258:         return NS_ERROR_FAILURE;
    1: 
    1:     LOG(("CaptureRollupEvents %p\n", (void *)this));
    1: 
    1:     if (aDoCapture) {
10250:         gConsumeRollupEvent = aConsumeRollupEvent;
    1:         gRollupListener = aListener;
36806:         NS_IF_RELEASE(gMenuRollup);
36806:         gMenuRollup = aMenuRollup;
36806:         NS_IF_ADDREF(aMenuRollup);
 3233:         gRollupWindow = do_GetWeakReference(static_cast<nsIWidget*>
 3233:                                                        (this));
    1:         // real grab is only done when there is no dragging
    1:         if (!nsWindow::DragInProgress()) {
    1:             gtk_grab_add(widget);
    1:             GrabPointer();
    1:         }
    1:     }
    1:     else {
    1:         if (!nsWindow::DragInProgress()) {
    1:             ReleaseGrabs();
62720:         }
62720:         // There may not have been a drag in process when aDoCapture was set,
62720:         // so make sure to remove any added grab.  This is a no-op if the grab
62720:         // was not added to this widget.
    1:         gtk_grab_remove(widget);
    1:         gRollupListener = nsnull;
36806:         NS_IF_RELEASE(gMenuRollup);
    1:         gRollupWindow = nsnull;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::GetAttention(PRInt32 aCycleCount)
    1: {
    1:     LOG(("nsWindow::GetAttention [%p]\n", (void *)this));
    1: 
    1:     GtkWidget* top_window = nsnull;
    1:     GtkWidget* top_focused_window = nsnull;
    1:     GetToplevelWidget(&top_window);
    1:     if (gFocusWindow)
    1:         gFocusWindow->GetToplevelWidget(&top_focused_window);
    1: 
    1:     // Don't get attention if the window is focused anyway.
    1:     if (top_window && (GTK_WIDGET_VISIBLE(top_window)) &&
    1:         top_window != top_focused_window) {
    1:         SetUrgencyHint(top_window, PR_TRUE);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
27993: PRBool
27993: nsWindow::HasPendingInputEvent()
27993: {
27993:     // This sucks, but gtk/gdk has no way to answer the question we want while
27993:     // excluding paint events, and there's no X API that will let us peek
27993:     // without blocking or removing.  To prevent event reordering, peek
27993:     // anything except expose events.  Reordering expose and others should be
27993:     // ok, hopefully.
27993:     PRBool haveEvent;
27993: #ifdef MOZ_X11
27993:     XEvent ev;
27993:     haveEvent =
27993:         XCheckMaskEvent(GDK_DISPLAY(),
27993:                         KeyPressMask | KeyReleaseMask | ButtonPressMask |
27993:                         ButtonReleaseMask | EnterWindowMask | LeaveWindowMask |
27993:                         PointerMotionMask | PointerMotionHintMask |
27993:                         Button1MotionMask | Button2MotionMask |
27993:                         Button3MotionMask | Button4MotionMask |
27993:                         Button5MotionMask | ButtonMotionMask | KeymapStateMask |
27993:                         VisibilityChangeMask | StructureNotifyMask |
27993:                         ResizeRedirectMask | SubstructureNotifyMask |
27993:                         SubstructureRedirectMask | FocusChangeMask |
27993:                         PropertyChangeMask | ColormapChangeMask |
27993:                         OwnerGrabButtonMask, &ev);
27993:     if (haveEvent) {
27993:         XPutBackEvent(GDK_DISPLAY(), &ev);
27993:     }
27993: #else
27993:     haveEvent = PR_FALSE;
27993: #endif
27993:     return haveEvent;
27993: }
27993: 
18490: #if 0
    1: #ifdef DEBUG
18490: // Paint flashing code (disabled for cairo - see below)
    1: 
    1: #define CAPS_LOCK_IS_ON \
    1: (gdk_keyboard_get_modifiers() & GDK_LOCK_MASK)
    1: 
    1: #define WANT_PAINT_FLASHING \
    1: (debug_WantPaintFlashing() && CAPS_LOCK_IS_ON)
    1: 
16529: #ifdef MOZ_X11
    1: static void
    1: gdk_window_flash(GdkWindow *    aGdkWindow,
    1:                  unsigned int   aTimes,
    1:                  unsigned int   aInterval,  // Milliseconds
    1:                  GdkRegion *    aRegion)
    1: {
    1:   gint         x;
    1:   gint         y;
    1:   gint         width;
    1:   gint         height;
    1:   guint        i;
    1:   GdkGC *      gc = 0;
    1:   GdkColor     white;
    1: 
    1:   gdk_window_get_geometry(aGdkWindow,
    1:                           NULL,
    1:                           NULL,
    1:                           &width,
    1:                           &height,
    1:                           NULL);
    1: 
    1:   gdk_window_get_origin (aGdkWindow,
    1:                          &x,
    1:                          &y);
    1: 
    1:   gc = gdk_gc_new(GDK_ROOT_PARENT());
    1: 
    1:   white.pixel = WhitePixel(gdk_display,DefaultScreen(gdk_display));
    1: 
    1:   gdk_gc_set_foreground(gc,&white);
    1:   gdk_gc_set_function(gc,GDK_XOR);
    1:   gdk_gc_set_subwindow(gc,GDK_INCLUDE_INFERIORS);
    1: 
    1:   gdk_region_offset(aRegion, x, y);
    1:   gdk_gc_set_clip_region(gc, aRegion);
    1: 
    1:   /*
    1:    * Need to do this twice so that the XOR effect can replace
    1:    * the original window contents.
    1:    */
    1:   for (i = 0; i < aTimes * 2; i++)
    1:   {
    1:     gdk_draw_rectangle(GDK_ROOT_PARENT(),
    1:                        gc,
    1:                        TRUE,
    1:                        x,
    1:                        y,
    1:                        width,
    1:                        height);
    1: 
    1:     gdk_flush();
    1: 
    1:     PR_Sleep(PR_MillisecondsToInterval(aInterval));
    1:   }
    1: 
    1:   gdk_gc_destroy(gc);
    1: 
    1:   gdk_region_offset(aRegion, -x, -y);
    1: }
16529: #endif /* MOZ_X11 */
    1: #endif // DEBUG
18490: #endif
    1: 
61316: static void
61316: DispatchDidPaint(nsIWidget* aWidget)
61316: {
61316:     nsEventStatus status;
61316:     nsPaintEvent didPaintEvent(PR_TRUE, NS_DID_PAINT, aWidget);
61316:     aWidget->DispatchEvent(&didPaintEvent, status);
61316: }
61316: 
    1: gboolean
    1: nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
    1: {
    1:     if (mIsDestroyed) {
    1:         LOG(("Expose event on destroyed window [%p] window %p\n",
    1:              (void *)this, (void *)aEvent->window));
    1:         return FALSE;
    1:     }
    1: 
34456:     // Windows that are not visible will be painted after they become visible.
34456:     if (!mGdkWindow || mIsFullyObscured || !mHasMappedToplevel)
    1:         return FALSE;
    1: 
61316:     // Dispatch WILL_PAINT to allow scripts etc. to run before we
61316:     // dispatch PAINT
61316:     {
61316:         nsEventStatus status;
61316:         nsPaintEvent willPaintEvent(PR_TRUE, NS_WILL_PAINT, this);
61316:         willPaintEvent.willSendDidPaint = PR_TRUE;
61316:         DispatchEvent(&willPaintEvent, status);
69478: 
69478:         // If the window has been destroyed during WILL_PAINT, there is
69478:         // nothing left to do.
69478:         if (!mGdkWindow)
69478:             return TRUE;
61316:     }
61316: 
38805:     nsPaintEvent event(PR_TRUE, NS_PAINT, this);
38805:     event.refPoint.x = aEvent->area.x;
38805:     event.refPoint.y = aEvent->area.y;
47756:     event.willSendDidPaint = PR_TRUE;
    1: 
    1:     GdkRectangle *rects;
    1:     gint nrects;
    1:     gdk_region_get_rectangles(aEvent->region, &rects, &nrects);
 3368:     if (NS_UNLIKELY(!rects)) // OOM
 3368:         return FALSE;
 3368: 
25021:     if (nrects > MAX_RECTS_IN_REGION) {
25021:         // Just use the bounding box
25021:         rects[0] = aEvent->area;
25021:         nrects = 1;
25021:     }
25021: 
    1:     LOGDRAW(("sending expose event [%p] %p 0x%lx (rects follow):\n",
    1:              (void *)this, (void *)aEvent->window,
    1:              GDK_WINDOW_XWINDOW(aEvent->window)));
    1: 
    1:     GdkRectangle *r;
    1:     GdkRectangle *r_end = rects + nrects;
    1:     for (r = rects; r < r_end; ++r) {
38805:         event.region.Or(event.region, nsIntRect(r->x, r->y, r->width, r->height));
    1:         LOGDRAW(("\t%d %d %d %d\n", r->x, r->y, r->width, r->height));
    1:     }
    1: 
61316:     // Our bounds may have changed after dispatching WILL_PAINT.  Clip
61316:     // to the new bounds here.  The event region is relative to this
61316:     // window.
61316:     event.region.And(event.region,
61316:                      nsIntRect(0, 0, mBounds.width, mBounds.height));
61316: 
30516:     PRBool translucent = eTransparencyTransparent == GetTransparencyMode();
30516:     if (!translucent) {
30516:         GList *children =
30704:             gdk_window_peek_children(mGdkWindow);
30516:         while (children) {
30516:             GdkWindow *gdkWin = GDK_WINDOW(children->data);
30516:             nsWindow *kid = get_window_for_gdk_window(gdkWin);
30631:             if (kid && gdk_window_is_visible(gdkWin)) {
30516:                 nsAutoTArray<nsIntRect,1> clipRects;
30516:                 kid->GetWindowClipRegion(&clipRects);
30516:                 nsIntRect bounds;
30516:                 kid->GetBounds(bounds);
30516:                 for (PRUint32 i = 0; i < clipRects.Length(); ++i) {
30516:                     nsIntRect r = clipRects[i] + bounds.TopLeft();
38805:                     event.region.Sub(event.region, r);
30516:                 }
30516:             }
30516:             children = children->next;
30516:         }
30516:     }
30516: 
38805:     if (event.region.IsEmpty()) {
30516:         g_free(rects);
30516:         return TRUE;
30516:     }
30516: 
63893:     if (GetLayerManager()->GetBackendType() == LayerManager::LAYERS_OPENGL)
63893:     {
63893:         LayerManagerOGL *manager = static_cast<LayerManagerOGL*>(GetLayerManager());
44138:         manager->SetClippingRegion(event.region);
44138: 
44138:         nsEventStatus status;
44138:         DispatchEvent(&event, status);
61316: 
44138:         g_free(rects);
61316: 
61316:         DispatchDidPaint(this);
61316: 
44138:         return TRUE;
44138:     }
44138:             
38805:     nsRefPtr<gfxContext> ctx = new gfxContext(GetThebesSurface());
16529: 
38805: #ifdef MOZ_DFB
47118:     gfxPlatformGtk::SetGdkDrawable(ctx->OriginalSurface(),
30704:                                    GDK_DRAWABLE(mGdkWindow));
16529: 
16529:     // clip to the update region
61316:     gfxUtils::ClipToRegion(ctx, event.region);
47761: 
47761:     BasicLayerManager::BufferMode layerBuffering =
47761:         BasicLayerManager::BUFFER_NONE;
16529: #endif
16529: 
16529: #ifdef MOZ_X11
47761:     nsIntRect boundsRect; // for translucent only
    1: 
    1:     ctx->NewPath();
    1:     if (translucent) {
    1:         // Collapse update area to the bounding box. This is so we only have to
    1:         // call UpdateTranslucentWindowAlpha once. After we have dropped
    1:         // support for non-Thebes graphics, UpdateTranslucentWindowAlpha will be
    1:         // our private interface so we can rework things to avoid this.
47761:         boundsRect = event.region.GetBounds();
    1:         ctx->Rectangle(gfxRect(boundsRect.x, boundsRect.y,
    1:                                boundsRect.width, boundsRect.height));
    1:     } else {
61316:         gfxUtils::PathFromRegion(ctx, event.region);
    1:     }
    1:     ctx->Clip();
    1: 
47761:     BasicLayerManager::BufferMode layerBuffering;
    1:     if (translucent) {
47761:         // The double buffering is done here to extract the shape mask.
47761:         // (The shape mask won't be necessary when a visual with an alpha
47761:         // channel is used on compositing window managers.)
47761:         layerBuffering = BasicLayerManager::BUFFER_NONE;
    1:         ctx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
54594: #ifdef MOZ_HAVE_SHMIMAGE
56628:     } else if (nsShmImage::UseShm()) {
54594:         // We're using an xshm mapping as a back buffer.
54594:         layerBuffering = BasicLayerManager::BUFFER_NONE;
54594: #endif // MOZ_HAVE_SHMIMAGE
    1:     } else {
47761:         // Get the layer manager to do double buffering (if necessary).
47761:         layerBuffering = BasicLayerManager::BUFFER_BUFFERED;
    1:     }
 2467: 
 2467: #if 0
    1:     // NOTE: Paint flashing region would be wrong for cairo, since
    1:     // cairo inflates the update region, etc.  So don't paint flash
    1:     // for cairo.
 2467: #ifdef DEBUG
61316:     // XXX aEvent->region may refer to a newly-invalid area.  FIXME
61316:     if (0 && WANT_PAINT_FLASHING && aEvent->window)
    1:         gdk_window_flash(aEvent->window, 1, 100, aEvent->region);
 2467: #endif
 2467: #endif
    1: 
16529: #endif // MOZ_X11
16529: 
    1:     nsEventStatus status;
38805:     {
47761:       AutoLayerManagerSetup setupLayerManager(this, ctx, layerBuffering);
    1:       DispatchEvent(&event, status);
38805:     }
    1: 
16529: #ifdef MOZ_X11
  920:     // DispatchEvent can Destroy us (bug 378273), avoid doing any paint
  920:     // operations below if that happened - it will lead to XError and exit().
47761:     if (translucent) {
  920:         if (NS_LIKELY(!mIsDestroyed)) {
    1:             if (status != nsEventStatus_eIgnore) {
    1:                 nsRefPtr<gfxPattern> pattern = ctx->PopGroup();
    1:                 ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
    1:                 ctx->SetPattern(pattern);
    1:                 ctx->Paint();
    1: 
    1:                 nsRefPtr<gfxImageSurface> img =
    1:                     new gfxImageSurface(gfxIntSize(boundsRect.width, boundsRect.height),
    1:                                         gfxImageSurface::ImageFormatA8);
 3368:                 if (img && !img->CairoStatus()) {
    1:                     img->SetDeviceOffset(gfxPoint(-boundsRect.x, -boundsRect.y));
    1: 
    1:                     nsRefPtr<gfxContext> imgCtx = new gfxContext(img);
 3368:                     if (imgCtx) {
    1:                         imgCtx->SetPattern(pattern);
    1:                         imgCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
    1:                         imgCtx->Paint();
 3368:                     }
    1: 
23738:                     UpdateTranslucentWindowAlphaInternal(nsIntRect(boundsRect.x, boundsRect.y,
    1:                                                                    boundsRect.width, boundsRect.height),
    1:                                                          img->Data(), img->Stride());
 3368:                 }
47761:             }
47761:         }
  920:     }
54594: #  ifdef MOZ_HAVE_SHMIMAGE
56628:     if (nsShmImage::UseShm() && NS_LIKELY(!mIsDestroyed)) {
54594:         mShmImage->Put(mGdkWindow, rects, r_end);
54594:     }
54594: #  endif  // MOZ_HAVE_SHMIMAGE
16529: #endif // MOZ_X11
16529: 
    1:     g_free(rects);
    1: 
61316:     DispatchDidPaint(this);
47756: 
47756:     // Synchronously flush any new dirty areas
47756:     GdkRegion* dirtyArea = gdk_window_get_update_area(mGdkWindow);
47756:     if (dirtyArea) {
47756:         gdk_window_invalidate_region(mGdkWindow, dirtyArea, PR_FALSE);
47756:         gdk_region_destroy(dirtyArea);
47756:         gdk_window_process_updates(mGdkWindow, PR_FALSE);
47756:     }
47756: 
    1:     // check the return value!
    1:     return TRUE;
    1: }
    1: 
    1: gboolean
    1: nsWindow::OnConfigureEvent(GtkWidget *aWidget, GdkEventConfigure *aEvent)
    1: {
    1:     LOG(("configure event [%p] %d %d %d %d\n", (void *)this,
    1:          aEvent->x, aEvent->y, aEvent->width, aEvent->height));
    1: 
    1:     // can we shortcut?
    1:     if (mBounds.x == aEvent->x &&
    1:         mBounds.y == aEvent->y)
    1:         return FALSE;
    1: 
54150:     if (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog) {
54150:         check_for_rollup(aEvent->window, 0, 0, PR_FALSE, PR_TRUE);
54150:     }
54150: 
    1:     // Toplevel windows need to have their bounds set so that we can
    1:     // keep track of our location.  It's not often that the x,y is set
    1:     // by the layout engine.  Width and height are set elsewhere.
48259:     nsIntPoint pnt(aEvent->x, aEvent->y);
    1:     if (mIsTopLevel) {
    1:         // Need to translate this into the right coordinates
25183:         mBounds.MoveTo(WidgetToScreenOffset());
48259:         pnt = mBounds.TopLeft();
    1:     }
    1: 
    1:     nsGUIEvent event(PR_TRUE, NS_MOVE, this);
    1: 
48259:     event.refPoint = pnt;
    1: 
    1:     // XXX mozilla will invalidate the entire window after this move
    1:     // complete.  wtf?
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: 
    1:     return FALSE;
    1: }
    1: 
    1: void
28365: nsWindow::OnContainerUnrealize(GtkWidget *aWidget)
28365: {
28365:     // The GdkWindows are about to be destroyed (but not deleted), so remove
28365:     // their references back to their container widget while the GdkWindow
28365:     // hierarchy is still available.
28365: 
28365:     NS_ASSERTION(mContainer == MOZ_CONTAINER(aWidget),
28365:                  "unexpected \"unrealize\" signal");
28365: 
30704:     if (mGdkWindow) {
34746:         DestroyChildWindows();
30705: 
30705:         g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", NULL);
30705:         mGdkWindow = NULL;
28365:     }
28365: }
28365: 
28365: void
    1: nsWindow::OnSizeAllocate(GtkWidget *aWidget, GtkAllocation *aAllocation)
    1: {
    1:     LOG(("size_allocate [%p] %d %d %d %d\n",
    1:          (void *)this, aAllocation->x, aAllocation->y,
    1:          aAllocation->width, aAllocation->height));
    1: 
23738:     nsIntRect rect(aAllocation->x, aAllocation->y,
    1:                    aAllocation->width, aAllocation->height);
    1: 
    1:     ResizeTransparencyBitmap(rect.width, rect.height);
    1: 
    1:     mBounds.width = rect.width;
    1:     mBounds.height = rect.height;
    1: 
30704:     if (!mGdkWindow)
    1:         return;
    1: 
    1:     if (mTransparencyBitmap) {
    1:       ApplyTransparencyBitmap();
    1:     }
    1: 
    1:     nsEventStatus status;
    1:     DispatchResizeEvent (rect, status);
    1: }
    1: 
    1: void
    1: nsWindow::OnDeleteEvent(GtkWidget *aWidget, GdkEventAny *aEvent)
    1: {
    1:     nsGUIEvent event(PR_TRUE, NS_XUL_CLOSE, this);
    1: 
    1:     event.refPoint.x = 0;
    1:     event.refPoint.y = 0;
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: }
    1: 
    1: void
    1: nsWindow::OnEnterNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)
    1: {
39762:     // This skips NotifyVirtual and NotifyNonlinearVirtual enter notify events
39762:     // when the pointer enters a child window.  If the destination window is a
39762:     // Gecko window then we'll catch the corresponding event on that window,
39762:     // but we won't notice when the pointer directly enters a foreign (plugin)
39762:     // child window without passing over a visible portion of a Gecko window.
    1:     if (aEvent->subwindow != NULL)
    1:         return;
    1: 
39762:     // Check before is_parent_ungrab_enter() as the button state may have
39762:     // changed while a non-Gecko ancestor window had a pointer grab.
39762:     DispatchMissedButtonReleases(aEvent);
39762: 
39762:     if (is_parent_ungrab_enter(aEvent))
39762:         return;
39762: 
    1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_ENTER, this, nsMouseEvent::eReal);
    1: 
    1:     event.refPoint.x = nscoord(aEvent->x);
    1:     event.refPoint.y = nscoord(aEvent->y);
    1: 
    1:     event.time = aEvent->time;
    1: 
    1:     LOG(("OnEnterNotify: %p\n", (void *)this));
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: }
    1: 
39762: // XXX Is this the right test for embedding cases?
12976: static PRBool
12976: is_top_level_mouse_exit(GdkWindow* aWindow, GdkEventCrossing *aEvent)
12976: {
12976:     gint x = gint(aEvent->x_root);
12976:     gint y = gint(aEvent->y_root);
12976:     GdkDisplay* display = gdk_drawable_get_display(aWindow);
12976:     GdkWindow* winAtPt = gdk_display_get_window_at_pointer(display, &x, &y);
12976:     if (!winAtPt)
12976:         return PR_TRUE;
12976:     GdkWindow* topLevelAtPt = gdk_window_get_toplevel(winAtPt);
12976:     GdkWindow* topLevelWidget = gdk_window_get_toplevel(aWindow);
12976:     return topLevelAtPt != topLevelWidget;
12976: }
12976: 
    1: void
    1: nsWindow::OnLeaveNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)
    1: {
39762:     // This ignores NotifyVirtual and NotifyNonlinearVirtual leave notify
39762:     // events when the pointer leaves a child window.  If the destination
39762:     // window is a Gecko window then we'll catch the corresponding event on
39762:     // that window.
39762:     //
39762:     // XXXkt However, we will miss toplevel exits when the pointer directly
39762:     // leaves a foreign (plugin) child window without passing over a visible
39762:     // portion of a Gecko window.
    1:     if (aEvent->subwindow != NULL)
    1:         return;
    1: 
    1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_EXIT, this, nsMouseEvent::eReal);
    1: 
    1:     event.refPoint.x = nscoord(aEvent->x);
    1:     event.refPoint.y = nscoord(aEvent->y);
    1: 
    1:     event.time = aEvent->time;
    1: 
30704:     event.exit = is_top_level_mouse_exit(mGdkWindow, aEvent)
12976:         ? nsMouseEvent::eTopLevel : nsMouseEvent::eChild;
12976: 
    1:     LOG(("OnLeaveNotify: %p\n", (void *)this));
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: }
    1: 
16529: #ifdef MOZ_DFB
    1: void
    1: nsWindow::OnMotionNotifyEvent(GtkWidget *aWidget, GdkEventMotion *aEvent)
    1: {
16529:     int cursorX = (int) aEvent->x_root;
16529:     int cursorY = (int) aEvent->y_root;
16529: 
16529:     D_DEBUG_AT( ns_Window, "%s( %4d,%4d - [%d] )\n", __FUNCTION__, cursorX, cursorY, mDFBCursorCount );
16529: 
16529:     D_ASSUME( mDFBLayer != NULL );
16529: 
16529:     if (mDFBLayer)
16529:          mDFBLayer->GetCursorPosition( mDFBLayer, &cursorX, &cursorY );
16529: 
16529:     mDFBCursorCount++;
16529: 
16529: #if D_DEBUG_ENABLED
16529:     if (cursorX != (int) aEvent->x_root || cursorY != (int) aEvent->y_root)
16529:          D_DEBUG_AT( ns_Window, "  -> forward to %4d,%4d\n", cursorX, cursorY );
16529: #endif
16529: 
16529:     if (cursorX == mDFBCursorX && cursorY == mDFBCursorY) {
16529:          D_DEBUG_AT( ns_Window, "  -> dropping %4d,%4d\n", cursorX, cursorY );
16529: 
16529:          /* drop zero motion */
16529:          return;
16529:     }
16529: 
16529:     mDFBCursorX = cursorX;
16529:     mDFBCursorY = cursorY;
16529: 
16529: 
    1:     // when we receive this, it must be that the gtk dragging is over,
    1:     // it is dropped either in or out of mozilla, clear the flag
    1:     sIsDraggingOutOf = PR_FALSE;
    1: 
16529:     nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, this, nsMouseEvent::eReal);
16529: 
22684:     // should we move this into !synthEvent?
22684:     gdouble pressure = 0;
22684:     gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
22684:     // Sometime gdk generate 0 pressure value between normal values
22684:     // We have to ignore that and use last valid value
22684:     if (pressure)
22684:       mLastMotionPressure = pressure;
22684:     event.pressure = mLastMotionPressure;
22684: 
25183:     event.refPoint = nsIntPoint(cursorX, cursorY) - WidgetToScreenOffset();
16529: 
16529:     event.isShift   = (aEvent->state & GDK_SHIFT_MASK)
16529:         ? PR_TRUE : PR_FALSE;
16529:     event.isControl = (aEvent->state & GDK_CONTROL_MASK)
16529:         ? PR_TRUE : PR_FALSE;
16529:     event.isAlt     = (aEvent->state & GDK_MOD1_MASK)
16529:         ? PR_TRUE : PR_FALSE;
16529: 
16529:     event.time = aEvent->time;
16529: 
16529:     nsEventStatus status;
16529:     DispatchEvent(&event, status);
16529: }
16529: #else
16529: void
16529: nsWindow::OnMotionNotifyEvent(GtkWidget *aWidget, GdkEventMotion *aEvent)
16529: {
16529:     // when we receive this, it must be that the gtk dragging is over,
16529:     // it is dropped either in or out of mozilla, clear the flag
16529:     sIsDraggingOutOf = PR_FALSE;
16529: 
    1:     // see if we can compress this event
20644:     // XXXldb Why skip every other motion event when we have multiple,
20644:     // but not more than that?
16529:     PRPackedBool synthEvent = PR_FALSE;
20644: #ifdef MOZ_X11
20644:     XEvent xevent;
20644: 
20644:     while (XPending (GDK_WINDOW_XDISPLAY(aEvent->window))) {
20644:         XEvent peeked;
20644:         XPeekEvent (GDK_WINDOW_XDISPLAY(aEvent->window), &peeked);
20644:         if (peeked.xany.window != GDK_WINDOW_XWINDOW(aEvent->window)
20644:             || peeked.type != MotionNotify)
20359:             break;
20359: 
    1:         synthEvent = PR_TRUE;
20644:         XNextEvent (GDK_WINDOW_XDISPLAY(aEvent->window), &xevent);
20644:     }
20644: 
    1:     // if plugins still keeps the focus, get it back
    1:     if (gPluginFocusWindow && gPluginFocusWindow != this) {
  920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
    1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
    1:     }
16529: #endif /* MOZ_X11 */
    1: 
    1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_MOVE, this, nsMouseEvent::eReal);
    1: 
22684:     gdouble pressure = 0;
22684:     gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
22684:     // Sometime gdk generate 0 pressure value between normal values
22684:     // We have to ignore that and use last valid value
22684:     if (pressure)
22684:       mLastMotionPressure = pressure;
22684:     event.pressure = mLastMotionPressure;
22684: 
20644:     if (synthEvent) {
20644: #ifdef MOZ_X11
20644:         event.refPoint.x = nscoord(xevent.xmotion.x);
20644:         event.refPoint.y = nscoord(xevent.xmotion.y);
20644: 
20644:         event.isShift   = (xevent.xmotion.state & GDK_SHIFT_MASK)
20644:             ? PR_TRUE : PR_FALSE;
20644:         event.isControl = (xevent.xmotion.state & GDK_CONTROL_MASK)
20644:             ? PR_TRUE : PR_FALSE;
20644:         event.isAlt     = (xevent.xmotion.state & GDK_MOD1_MASK)
20644:             ? PR_TRUE : PR_FALSE;
20644: 
20644:         event.time = xevent.xmotion.time;
20644: #else
16529:         event.refPoint.x = nscoord(aEvent->x);
16529:         event.refPoint.y = nscoord(aEvent->y);
16529: 
16529:         event.isShift   = (aEvent->state & GDK_SHIFT_MASK)
16529:             ? PR_TRUE : PR_FALSE;
16529:         event.isControl = (aEvent->state & GDK_CONTROL_MASK)
16529:             ? PR_TRUE : PR_FALSE;
16529:         event.isAlt     = (aEvent->state & GDK_MOD1_MASK)
16529:             ? PR_TRUE : PR_FALSE;
16529: 
16529:         event.time = aEvent->time;
20644: #endif /* MOZ_X11 */
20644:     }
20644:     else {
20644:         // XXX see OnScrollEvent()
30704:         if (aEvent->window == mGdkWindow) {
20644:             event.refPoint.x = nscoord(aEvent->x);
20644:             event.refPoint.y = nscoord(aEvent->y);
20644:         } else {
25183:             nsIntPoint point(NSToIntFloor(aEvent->x_root), NSToIntFloor(aEvent->y_root));
25183:             event.refPoint = point - WidgetToScreenOffset();
20644:         }
20644: 
20644:         event.isShift   = (aEvent->state & GDK_SHIFT_MASK)
20644:             ? PR_TRUE : PR_FALSE;
20644:         event.isControl = (aEvent->state & GDK_CONTROL_MASK)
20644:             ? PR_TRUE : PR_FALSE;
20644:         event.isAlt     = (aEvent->state & GDK_MOD1_MASK)
20644:             ? PR_TRUE : PR_FALSE;
20644: 
20644:         event.time = aEvent->time;
20644:     }
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: }
16529: #endif
    1: 
39762: // If the automatic pointer grab on ButtonPress has deactivated before
39762: // ButtonRelease, and the mouse button is released while the pointer is not
39762: // over any a Gecko window, then the ButtonRelease event will not be received.
39762: // (A similar situation exists when the pointer is grabbed with owner_events
39762: // True as the ButtonRelease may be received on a foreign [plugin] window).
39762: // Use this method to check for released buttons when the pointer returns to a
39762: // Gecko window.
39762: void
39762: nsWindow::DispatchMissedButtonReleases(GdkEventCrossing *aGdkEvent)
39762: {
39762:     guint changed = aGdkEvent->state ^ gButtonState;
39762:     // Only consider button releases.
39762:     // (Ignore button presses that occurred outside Gecko.)
39762:     guint released = changed & gButtonState;
39762:     gButtonState = aGdkEvent->state;
39762: 
39762:     // Loop over each button, excluding mouse wheel buttons 4 and 5 for which
39762:     // GDK ignores releases.
39762:     for (guint buttonMask = GDK_BUTTON1_MASK;
39762:          buttonMask <= GDK_BUTTON3_MASK;
39762:          buttonMask <<= 1) {
39762: 
39762:         if (released & buttonMask) {
39762:             PRInt16 buttonType;
39762:             switch (buttonMask) {
39762:             case GDK_BUTTON1_MASK:
39762:                 buttonType = nsMouseEvent::eLeftButton;
39762:                 break;
39762:             case GDK_BUTTON2_MASK:
39762:                 buttonType = nsMouseEvent::eMiddleButton;
39762:                 break;
39762:             default:
39762:                 NS_ASSERTION(buttonMask == GDK_BUTTON3_MASK,
39762:                              "Unexpected button mask");
39762:                 buttonType = nsMouseEvent::eRightButton;
39762:             }
39762: 
39762:             LOG(("Synthesized button %u release on %p\n",
39762:                  guint(buttonType + 1), (void *)this));
39762: 
39762:             // Dispatch a synthesized button up event to tell Gecko about the
39762:             // change in state.  This event is marked as synthesized so that
39762:             // it is not dispatched as a DOM event, because we don't know the
39762:             // position, widget, modifiers, or time/order.
39762:             nsMouseEvent synthEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, this,
39762:                                     nsMouseEvent::eSynthesized);
39762:             synthEvent.button = buttonType;
39762:             nsEventStatus status;
39762:             DispatchEvent(&synthEvent, status);
39762: 
39762:             sLastButtonReleaseTime = aGdkEvent->time;
39762:         }
39762:     }
39762: }
39762: 
    1: void
 9049: nsWindow::InitButtonEvent(nsMouseEvent &aEvent,
 9049:                           GdkEventButton *aGdkEvent)
 9049: {
 9049:     // XXX see OnScrollEvent()
30704:     if (aGdkEvent->window == mGdkWindow) {
 9049:         aEvent.refPoint.x = nscoord(aGdkEvent->x);
 9049:         aEvent.refPoint.y = nscoord(aGdkEvent->y);
 9049:     } else {
25183:         nsIntPoint point(NSToIntFloor(aGdkEvent->x_root), NSToIntFloor(aGdkEvent->y_root));
25183:         aEvent.refPoint = point - WidgetToScreenOffset();
 9049:     }
 9049: 
 9049:     aEvent.isShift   = (aGdkEvent->state & GDK_SHIFT_MASK) != 0;
 9049:     aEvent.isControl = (aGdkEvent->state & GDK_CONTROL_MASK) != 0;
 9049:     aEvent.isAlt     = (aGdkEvent->state & GDK_MOD1_MASK) != 0;
 9049:     aEvent.isMeta    = (aGdkEvent->state & GDK_MOD4_MASK) != 0;
 9049: 
 9049:     aEvent.time = aGdkEvent->time;
 9049: 
 9049:     switch (aGdkEvent->type) {
 9049:     case GDK_2BUTTON_PRESS:
 9049:         aEvent.clickCount = 2;
 9049:         break;
 9049:     case GDK_3BUTTON_PRESS:
 9049:         aEvent.clickCount = 3;
 9049:         break;
 9049:         // default is one click
 9049:     default:
 9049:         aEvent.clickCount = 1;
 9049:     }
 9049: }
 9049: 
39762: static guint ButtonMaskFromGDKButton(guint button)
39762: {
39762:     return GDK_BUTTON1_MASK << (button - 1);
39762: }
39762: 
 9049: void
    1: nsWindow::OnButtonPressEvent(GtkWidget *aWidget, GdkEventButton *aEvent)
    1: {
39762:     LOG(("Button %u press on %p\n", aEvent->button, (void *)this));
39762: 
    1:     nsEventStatus status;
    1: 
39762:     // If you double click in GDK, it will actually generate a second
39762:     // GDK_BUTTON_PRESS before sending the GDK_2BUTTON_PRESS, and this is
    1:     // different than the DOM spec.  GDK puts this in the queue
    1:     // programatically, so it's safe to assume that if there's a
    1:     // double click in the queue, it was generated so we can just drop
    1:     // this click.
    1:     GdkEvent *peekedEvent = gdk_event_peek();
    1:     if (peekedEvent) {
    1:         GdkEventType type = peekedEvent->any.type;
    1:         gdk_event_free(peekedEvent);
    1:         if (type == GDK_2BUTTON_PRESS || type == GDK_3BUTTON_PRESS)
    1:             return;
    1:     }
    1: 
    1:     // Always save the time of this event
39762:     sLastButtonPressTime = aEvent->time;
39762:     sLastButtonReleaseTime = 0;
    1: 
25258:     nsWindow *containerWindow = GetContainerWindow();
25258:     if (!gFocusWindow && containerWindow) {
30583:         containerWindow->DispatchActivateEvent();
30583:     }
30583: 
30583:     // check to see if we should rollup
10250:     PRBool rolledUp = check_for_rollup(aEvent->window, aEvent->x_root,
54150:                                        aEvent->y_root, PR_FALSE, PR_FALSE);
10250:     if (gConsumeRollupEvent && rolledUp)
    1:         return;
    1: 
22684:     gdouble pressure = 0;
22684:     gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
22684:     mLastMotionPressure = pressure;
22684: 
    1:     PRUint16 domButton;
    1:     switch (aEvent->button) {
 3974:     case 1:
 3974:         domButton = nsMouseEvent::eLeftButton;
 3974:         break;
    1:     case 2:
    1:         domButton = nsMouseEvent::eMiddleButton;
    1:         break;
    1:     case 3:
    1:         domButton = nsMouseEvent::eRightButton;
    1:         break;
13248:     // These are mapped to horizontal scroll
13248:     case 6:
13248:     case 7:
13248:         {
13248:             nsMouseScrollEvent event(PR_TRUE, NS_MOUSE_SCROLL, this);
22684:             event.pressure = mLastMotionPressure;
13248:             event.scrollFlags = nsMouseScrollEvent::kIsHorizontal;
13248:             event.refPoint.x = nscoord(aEvent->x);
13248:             event.refPoint.y = nscoord(aEvent->y);
33016:             // XXX Why is this delta value different from the scroll event?
13248:             event.delta = (aEvent->button == 6) ? -2 : 2;
13248: 
13248:             event.isShift   = (aEvent->state & GDK_SHIFT_MASK) != 0;
13248:             event.isControl = (aEvent->state & GDK_CONTROL_MASK) != 0;
13248:             event.isAlt     = (aEvent->state & GDK_MOD1_MASK) != 0;
13248:             event.isMeta    = (aEvent->state & GDK_MOD4_MASK) != 0;
13248: 
13248:             event.time = aEvent->time;
13248: 
13248:             nsEventStatus status;
13248:             DispatchEvent(&event, status);
13248:             return;
13248:         }
11933:     // Map buttons 8-9 to back/forward
11933:     case 8:
11933:         DispatchCommandEvent(nsWidgetAtoms::Back);
11933:         return;
11933:     case 9:
11933:         DispatchCommandEvent(nsWidgetAtoms::Forward);
11933:         return;
    1:     default:
 3974:         return;
    1:     }
    1: 
39762:     gButtonState |= ButtonMaskFromGDKButton(aEvent->button);
39762: 
    1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_BUTTON_DOWN, this, nsMouseEvent::eReal);
    1:     event.button = domButton;
    1:     InitButtonEvent(event, aEvent);
22684:     event.pressure = mLastMotionPressure;
    1: 
    1:     DispatchEvent(&event, status);
    1: 
    1:     // right menu click on linux should also pop up a context menu
  920:     if (domButton == nsMouseEvent::eRightButton &&
  920:         NS_LIKELY(!mIsDestroyed)) {
    1:         nsMouseEvent contextMenuEvent(PR_TRUE, NS_CONTEXTMENU, this,
    1:                                       nsMouseEvent::eReal);
    1:         InitButtonEvent(contextMenuEvent, aEvent);
22684:         contextMenuEvent.pressure = mLastMotionPressure;
    1:         DispatchEvent(&contextMenuEvent, status);
    1:     }
    1: }
    1: 
    1: void
    1: nsWindow::OnButtonReleaseEvent(GtkWidget *aWidget, GdkEventButton *aEvent)
    1: {
39762:     LOG(("Button %u release on %p\n", aEvent->button, (void *)this));
39762: 
    1:     PRUint16 domButton;
39762:     sLastButtonReleaseTime = aEvent->time;
    1: 
    1:     switch (aEvent->button) {
 3974:     case 1:
 3974:         domButton = nsMouseEvent::eLeftButton;
 3974:         break;
    1:     case 2:
    1:         domButton = nsMouseEvent::eMiddleButton;
    1:         break;
    1:     case 3:
    1:         domButton = nsMouseEvent::eRightButton;
    1:         break;
 3974:     default:
    1:         return;
    1:     }
    1: 
39762:     gButtonState &= ~ButtonMaskFromGDKButton(aEvent->button);
39762: 
    1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_BUTTON_UP, this, nsMouseEvent::eReal);
    1:     event.button = domButton;
    1:     InitButtonEvent(event, aEvent);
22684:     gdouble pressure = 0;
22684:     gdk_event_get_axis ((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
22684:     event.pressure = pressure ? pressure : mLastMotionPressure;
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
22684:     mLastMotionPressure = pressure;
    1: }
    1: 
    1: void
    1: nsWindow::OnContainerFocusInEvent(GtkWidget *aWidget, GdkEventFocus *aEvent)
    1: {
43761:     NS_ASSERTION(mWindowType != eWindowType_popup,
43761:                  "Unexpected focus on a popup window");
43761: 
    1:     LOGFOCUS(("OnContainerFocusInEvent [%p]\n", (void *)this));
43004:     if (!mEnabled) {
    1:         LOGFOCUS(("Container focus is blocked [%p]\n", (void *)this));
    1:         return;
    1:     }
    1: 
    1:     // Unset the urgency hint, if possible
    1:     GtkWidget* top_window = nsnull;
    1:     GetToplevelWidget(&top_window);
    1:     if (top_window && (GTK_WIDGET_VISIBLE(top_window)))
    1:         SetUrgencyHint(top_window, PR_FALSE);
    1: 
43760:     // Return if being called within SetFocus because the focus manager
43760:     // already knows that the window is active.
43760:     if (gBlockActivateEvent) {
43760:         LOGFOCUS(("NS_ACTIVATE event is blocked [%p]\n", (void *)this));
43760:         return;
43760:     }
43760: 
43760:     // This is not usually the correct window for dispatching key events,
43760:     // but the focus manager will call SetFocus to set the correct window if
43760:     // keyboard input will be accepted.  Setting a non-NULL value here
43760:     // prevents OnButtonPressEvent() from dispatching NS_ACTIVATE if the
43760:     // widget is already active.
29018:     gFocusWindow = this;
43760: 
    1:     DispatchActivateEvent();
    1: 
    1:     LOGFOCUS(("Events sent from focus in event [%p]\n", (void *)this));
    1: }
    1: 
    1: void
    1: nsWindow::OnContainerFocusOutEvent(GtkWidget *aWidget, GdkEventFocus *aEvent)
    1: {
    1:     LOGFOCUS(("OnContainerFocusOutEvent [%p]\n", (void *)this));
    1: 
54150:     if (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog) {
59748:         nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
59748:         nsCOMPtr<nsIDragSession> dragSession;
59748:         dragService->GetCurrentSession(getter_AddRefs(dragSession));
59748: 
59748:         // Rollup popups when a window is focused out unless a drag is occurring.
59748:         // This check is because drags grab the keyboard and cause a focus out on
59748:         // versions of GTK before 2.18.
59748:         PRBool shouldRollup = !dragSession;
59748:         if (!shouldRollup) {
59748:             // we also roll up when a drag is from a different application
59748:             nsCOMPtr<nsIDOMNode> sourceNode;
59748:             dragSession->GetSourceNode(getter_AddRefs(sourceNode));
59748:             shouldRollup = (sourceNode == nsnull);
59748:         }
59748: 
59748:         if (shouldRollup) {
54150:             check_for_rollup(aEvent->window, 0, 0, PR_FALSE, PR_TRUE);
54150:         }
59748:     }
54150: 
16529: #ifdef MOZ_X11
    1:     // plugin lose focus
    1:     if (gPluginFocusWindow) {
  920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
    1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
    1:     }
16529: #endif /* MOZ_X11 */
    1: 
43759:     if (gFocusWindow) {
  920:         nsRefPtr<nsWindow> kungFuDeathGrip = gFocusWindow;
39627:         if (gFocusWindow->mIMModule) {
39627:             gFocusWindow->mIMModule->OnBlurWindow(gFocusWindow);
39627:         }
43759:         gFocusWindow = nsnull;
43759:     }
43759: 
29018:     DispatchDeactivateEvent();
    1: 
    1:     LOGFOCUS(("Done with container focus out [%p]\n", (void *)this));
    1: }
    1: 
11283: PRBool
11933: nsWindow::DispatchCommandEvent(nsIAtom* aCommand)
11283: {
11283:     nsEventStatus status;
11283:     nsCommandEvent event(PR_TRUE, nsWidgetAtoms::onAppCommand, aCommand, this);
11283:     DispatchEvent(&event, status);
11283:     return TRUE;
11283: }
11283: 
14328: static PRUint32
14824: GetCharCodeFor(const GdkEventKey *aEvent, guint aShiftState,
14328:                gint aGroup)
14328: {
14328:     guint keyval;
14824:     if (gdk_keymap_translate_keyboard_state(NULL, aEvent->hardware_keycode,
14824:                                             GdkModifierType(aShiftState),
14824:                                             aGroup,
14328:                                             &keyval, NULL, NULL, NULL)) {
14328:         GdkEventKey tmpEvent = *aEvent;
14328:         tmpEvent.state = guint(aShiftState);
14328:         tmpEvent.keyval = keyval;
14328:         tmpEvent.group = aGroup;
14328:         return nsConvertCharCodeToUnicode(&tmpEvent);
14328:     }
14328:     return 0;
14328: }
14328: 
14328: static gint
14328: GetKeyLevel(GdkEventKey *aEvent)
14328: {
14328:     gint level;
14328:     if (!gdk_keymap_translate_keyboard_state(NULL,
14328:                                              aEvent->hardware_keycode,
14328:                                              GdkModifierType(aEvent->state),
14328:                                              aEvent->group,
14328:                                              NULL, NULL, &level, NULL))
14328:         return -1;
14328:     return level;
14328: }
14328: 
14328: static PRBool
14328: IsBasicLatinLetterOrNumeral(PRUint32 aChar)
14328: {
14328:     return (aChar >= 'a' && aChar <= 'z') ||
14328:            (aChar >= 'A' && aChar <= 'Z') ||
14328:            (aChar >= '0' && aChar <= '9');
14328: }
14328: 
39627: static PRBool
39627: IsCtrlAltTab(GdkEventKey *aEvent)
39627: {
39627:     return aEvent->keyval == GDK_Tab &&
39627:         aEvent->state & GDK_CONTROL_MASK && aEvent->state & GDK_MOD1_MASK;
39627: }
39627: 
39627: PRBool
39627: nsWindow::DispatchKeyDownEvent(GdkEventKey *aEvent, PRBool *aCancelled)
39627: {
39627:     NS_PRECONDITION(aCancelled, "aCancelled must not be null");
39627: 
39627:     *aCancelled = PR_FALSE;
39627: 
39627:     if (IsCtrlAltTab(aEvent)) {
39627:         return PR_FALSE;
39627:     }
39627: 
39627:     // send the key down event
39627:     nsEventStatus status;
39627:     nsKeyEvent downEvent(PR_TRUE, NS_KEY_DOWN, this);
39627:     InitKeyEvent(downEvent, aEvent);
39627:     DispatchEvent(&downEvent, status);
39627:     *aCancelled = (status == nsEventStatus_eConsumeNoDefault);
39627:     return PR_TRUE;
39627: }
39627: 
    1: gboolean
14964: nsWindow::OnKeyPressEvent(GtkWidget *aWidget, GdkEventKey *aEvent)
    1: {
    1:     LOGFOCUS(("OnKeyPressEvent [%p]\n", (void *)this));
    1: 
    1:     // if we are in the middle of composing text, XIM gets to see it
    1:     // before mozilla does.
60496:     PRBool IMEWasEnabled = PR_FALSE;
60496:     if (mIMModule) {
60496:         IMEWasEnabled = mIMModule->IsEnabled();
60496:         if (mIMModule->OnKeyEvent(this, aEvent)) {
    1:             return TRUE;
39627:         }
60496:     }
    1: 
    1:     nsEventStatus status;
    1: 
    1:     // work around for annoying things.
39627:     if (IsCtrlAltTab(aEvent)) {
    1:         return TRUE;
    1:     }
    1: 
    1:     nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
    1: 
55062:     // Dispatch keydown event always.  At auto repeating, we should send
55062:     // KEYDOWN -> KEYPRESS -> KEYDOWN -> KEYPRESS ... -> KEYUP
55062:     // However, old distributions (e.g., Ubuntu 9.10) sent native key
55062:     // release event, so, on such platform, the DOM events will be:
55062:     // KEYDOWN -> KEYPRESS -> KEYUP -> KEYDOWN -> KEYPRESS -> KEYUP...
    1: 
    1:     PRBool isKeyDownCancelled = PR_FALSE;
39627:     if (DispatchKeyDownEvent(aEvent, &isKeyDownCancelled) &&
39627:         NS_UNLIKELY(mIsDestroyed)) {
39627:         return TRUE;
    1:     }
    1: 
60496:     // If a keydown event handler causes to enable IME, i.e., it moves
60496:     // focus from IME unusable content to IME usable editor, we should
60496:     // send the native key event to IME for the first input on the editor.
60496:     if (!IMEWasEnabled && mIMModule && mIMModule->IsEnabled()) {
60496:         // Notice our keydown event was already dispatched.  This prevents
60496:         // unnecessary DOM keydown event in the editor.
60496:         if (mIMModule->OnKeyEvent(this, aEvent, PR_TRUE)) {
60496:             return TRUE;
60496:         }
60496:     }
60496: 
    1:     // Don't pass modifiers as NS_KEY_PRESS events.
    1:     // TODO: Instead of selectively excluding some keys from NS_KEY_PRESS events,
    1:     //       we should instead selectively include (as per MSDN spec; no official
    1:     //       spec covers KeyPress events).
    1:     if (aEvent->keyval == GDK_Shift_L
    1:         || aEvent->keyval == GDK_Shift_R
    1:         || aEvent->keyval == GDK_Control_L
    1:         || aEvent->keyval == GDK_Control_R
    1:         || aEvent->keyval == GDK_Alt_L
    1:         || aEvent->keyval == GDK_Alt_R
    1:         || aEvent->keyval == GDK_Meta_L
    1:         || aEvent->keyval == GDK_Meta_R) {
    1:         return TRUE;
    1:     }
11283: 
16529: #ifdef MOZ_X11
39957: #if ! defined AIX // no XFree86 on AIX 5L
11283:     // Look for specialized app-command keys
11283:     switch (aEvent->keyval) {
11283:         case XF86XK_Back:
11933:             return DispatchCommandEvent(nsWidgetAtoms::Back);
11283:         case XF86XK_Forward:
11933:             return DispatchCommandEvent(nsWidgetAtoms::Forward);
11283:         case XF86XK_Refresh:
11933:             return DispatchCommandEvent(nsWidgetAtoms::Reload);
11283:         case XF86XK_Stop:
11933:             return DispatchCommandEvent(nsWidgetAtoms::Stop);
11283:         case XF86XK_Search:
11933:             return DispatchCommandEvent(nsWidgetAtoms::Search);
11283:         case XF86XK_Favorites:
11933:             return DispatchCommandEvent(nsWidgetAtoms::Bookmarks);
11283:         case XF86XK_HomePage:
11933:             return DispatchCommandEvent(nsWidgetAtoms::Home);
11283:     }
39957: #endif /* ! AIX */
16529: #endif /* MOZ_X11 */
11283: 
    1:     nsKeyEvent event(PR_TRUE, NS_KEY_PRESS, this);
    1:     InitKeyEvent(event, aEvent);
    1:     if (isKeyDownCancelled) {
    1:       // If prevent default set for onkeydown, do the same for onkeypress
    1:       event.flags |= NS_EVENT_FLAG_NO_DEFAULT;
    1:     }
    1:     event.charCode = nsConvertCharCodeToUnicode(aEvent);
    1:     if (event.charCode) {
    1:         event.keyCode = 0;
14328:         gint level = GetKeyLevel(aEvent);
14328:         if ((event.isControl || event.isAlt || event.isMeta) &&
14328:             (level == 0 || level == 1)) {
14824:             guint baseState =
14824:                 aEvent->state & ~(GDK_SHIFT_MASK | GDK_CONTROL_MASK |
14824:                                   GDK_MOD1_MASK | GDK_MOD4_MASK);
14328:             // We shold send both shifted char and unshifted char,
14328:             // all keyboard layout users can use all keys.
14328:             // Don't change event.charCode. On some keyboard layouts,
14328:             // ctrl/alt/meta keys are used for inputting some characters.
14328:             nsAlternativeCharCode altCharCodes(0, 0);
14328:             // unshifted charcode of current keyboard layout.
14328:             altCharCodes.mUnshiftedCharCode =
14824:                 GetCharCodeFor(aEvent, baseState, aEvent->group);
14328:             PRBool isLatin = (altCharCodes.mUnshiftedCharCode <= 0xFF);
14328:             // shifted charcode of current keyboard layout.
14328:             altCharCodes.mShiftedCharCode =
14824:                 GetCharCodeFor(aEvent, baseState | GDK_SHIFT_MASK,
14824:                                aEvent->group);
14328:             isLatin = isLatin && (altCharCodes.mShiftedCharCode <= 0xFF);
14328:             if (altCharCodes.mUnshiftedCharCode ||
14328:                 altCharCodes.mShiftedCharCode) {
14328:                 event.alternativeCharCodes.AppendElement(altCharCodes);
14328:             }
14328: 
14328:             if (!isLatin) {
14328:                 // Next, find latin inputtable keyboard layout.
 8298:                 GdkKeymapKey *keys;
14328:                 gint count;
14328:                 gint minGroup = -1;
14328:                 if (gdk_keymap_get_entries_for_keyval(NULL, GDK_a,
14328:                                                       &keys, &count)) {
14328:                     // find the minimum number group for latin inputtable layout
14328:                     for (gint i = 0; i < count && minGroup != 0; ++i) {
14328:                         if (keys[i].level != 0 && keys[i].level != 1)
 8298:                             continue;
14328:                         if (minGroup >= 0 && keys[i].group > minGroup)
 8298:                             continue;
14328:                         minGroup = keys[i].group;
 8298:                     }
 8298:                     g_free(keys);
14328:                 }
14328:                 if (minGroup >= 0) {
14967:                     PRUint32 unmodifiedCh =
14967:                                event.isShift ? altCharCodes.mShiftedCharCode :
14967:                                                altCharCodes.mUnshiftedCharCode;
14328:                     // unshifted charcode of found keyboard layout.
14328:                     PRUint32 ch =
14824:                         GetCharCodeFor(aEvent, baseState, minGroup);
14328:                     altCharCodes.mUnshiftedCharCode =
14328:                         IsBasicLatinLetterOrNumeral(ch) ? ch : 0;
14328:                     // shifted charcode of found keyboard layout.
14824:                     ch = GetCharCodeFor(aEvent, baseState | GDK_SHIFT_MASK,
14824:                                         minGroup);
14328:                     altCharCodes.mShiftedCharCode =
14328:                         IsBasicLatinLetterOrNumeral(ch) ? ch : 0;
14328:                     if (altCharCodes.mUnshiftedCharCode ||
14328:                         altCharCodes.mShiftedCharCode) {
14328:                         event.alternativeCharCodes.AppendElement(altCharCodes);
14328:                     }
14967:                     // If the charCode is not Latin, and the level is 0 or 1,
14967:                     // we should replace the charCode to Latin char if Alt and
14967:                     // Meta keys are not pressed. (Alt should be sent the
14967:                     // localized char for accesskey like handling of Web
14967:                     // Applications.)
14967:                     ch = event.isShift ? altCharCodes.mShiftedCharCode :
14967:                                          altCharCodes.mUnshiftedCharCode;
14967:                     if (ch && !(event.isAlt || event.isMeta) &&
14967:                         event.charCode == unmodifiedCh) {
14967:                         event.charCode = ch;
14967:                     }
14328:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     // before we dispatch a key, check if it's the context menu key.
    1:     // If so, send a context menu key event instead.
    1:     if (is_context_menu_key(event)) {
11930:         nsMouseEvent contextMenuEvent(PR_TRUE, NS_CONTEXTMENU, this,
11930:                                       nsMouseEvent::eReal,
11930:                                       nsMouseEvent::eContextMenuKey);
11930:         key_event_to_context_menu_event(contextMenuEvent, aEvent);
    1:         DispatchEvent(&contextMenuEvent, status);
    1:     }
    1:     else {
47210:         // If the character code is in the BMP, send the key press event.
47210:         // Otherwise, send a text event with the equivalent UTF-16 string.
47210:         if (IS_IN_BMP(event.charCode)) {
    1:             DispatchEvent(&event, status);
    1:         }
47210:         else {
47210:             nsTextEvent textEvent(PR_TRUE, NS_TEXT_TEXT, this);
47210:             PRUnichar textString[3];
47210:             textString[0] = H_SURROGATE(event.charCode);
47210:             textString[1] = L_SURROGATE(event.charCode);
47210:             textString[2] = 0;
47210:             textEvent.theText = textString;
47210:             textEvent.time = event.time;
47210:             DispatchEvent(&textEvent, status);
47210:         }
47210:     }
    1: 
    1:     // If the event was consumed, return.
    1:     if (status == nsEventStatus_eConsumeNoDefault) {
    1:         return TRUE;
    1:     }
    1: 
    1:     return FALSE;
    1: }
    1: 
    1: gboolean
14964: nsWindow::OnKeyReleaseEvent(GtkWidget *aWidget, GdkEventKey *aEvent)
    1: {
    1:     LOGFOCUS(("OnKeyReleaseEvent [%p]\n", (void *)this));
    1: 
39627:     if (mIMModule && mIMModule->OnKeyEvent(this, aEvent)) {
    1:         return TRUE;
39627:     }
    1: 
    1:     // send the key event as a key up event
    1:     nsKeyEvent event(PR_TRUE, NS_KEY_UP, this);
    1:     InitKeyEvent(event, aEvent);
    1: 
  920:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: 
    1:     // If the event was consumed, return.
    1:     if (status == nsEventStatus_eConsumeNoDefault) {
    1:         return TRUE;
    1:     }
    1: 
    1:     return FALSE;
    1: }
    1: 
    1: void
    1: nsWindow::OnScrollEvent(GtkWidget *aWidget, GdkEventScroll *aEvent)
    1: {
    1:     // check to see if we should rollup
10250:     PRBool rolledUp =  check_for_rollup(aEvent->window, aEvent->x_root,
54150:                                         aEvent->y_root, PR_TRUE, PR_FALSE);
10250:     if (gConsumeRollupEvent && rolledUp)
    1:         return;
    1: 
 8875:     nsMouseScrollEvent event(PR_TRUE, NS_MOUSE_SCROLL, this);
 8875:     switch (aEvent->direction) {
 8875:     case GDK_SCROLL_UP:
 8875:         event.scrollFlags = nsMouseScrollEvent::kIsVertical;
 8875:         event.delta = -3;
 8875:         break;
 8875:     case GDK_SCROLL_DOWN:
 8875:         event.scrollFlags = nsMouseScrollEvent::kIsVertical;
 8875:         event.delta = 3;
 8875:         break;
 8875:     case GDK_SCROLL_LEFT:
 8875:         event.scrollFlags = nsMouseScrollEvent::kIsHorizontal;
11492:         event.delta = -1;
 8875:         break;
 8875:     case GDK_SCROLL_RIGHT:
 8875:         event.scrollFlags = nsMouseScrollEvent::kIsHorizontal;
11492:         event.delta = 1;
 8875:         break;
 8875:     }
 8875: 
30704:     if (aEvent->window == mGdkWindow) {
25183:         // we are the window that the event happened on so no need for expensive WidgetToScreenOffset
 8875:         event.refPoint.x = nscoord(aEvent->x);
 8875:         event.refPoint.y = nscoord(aEvent->y);
 8875:     } else {
 8875:         // XXX we're never quite sure which GdkWindow the event came from due to our custom bubbling
 8875:         // in scroll_event_cb(), so use ScreenToWidget to translate the screen root coordinates into
 8875:         // coordinates relative to this widget.
25183:         nsIntPoint point(NSToIntFloor(aEvent->x_root), NSToIntFloor(aEvent->y_root));
25183:         event.refPoint = point - WidgetToScreenOffset();
 8875:     }
 8875: 
 8875:     event.isShift   = (aEvent->state & GDK_SHIFT_MASK) != 0;
 8875:     event.isControl = (aEvent->state & GDK_CONTROL_MASK) != 0;
 8875:     event.isAlt     = (aEvent->state & GDK_MOD1_MASK) != 0;
 8875:     event.isMeta    = (aEvent->state & GDK_MOD4_MASK) != 0;
 8875: 
 8875:     event.time = aEvent->time;
 8875: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: }
    1: 
    1: void
    1: nsWindow::OnVisibilityNotifyEvent(GtkWidget *aWidget,
    1:                                   GdkEventVisibility *aEvent)
    1: {
34456:     LOGDRAW(("Visibility event %i on [%p] %p\n",
34456:              aEvent->state, this, aEvent->window));
34456: 
34456:     if (!mGdkWindow)
34456:         return;
34456: 
    1:     switch (aEvent->state) {
    1:     case GDK_VISIBILITY_UNOBSCURED:
    1:     case GDK_VISIBILITY_PARTIAL:
34456:         if (mIsFullyObscured && mHasMappedToplevel) {
34456:             // GDK_EXPOSE events have been ignored, so make sure GDK
34456:             // doesn't think that the window has already been painted.
34456:             gdk_window_invalidate_rect(mGdkWindow, NULL, FALSE);
34456:         }
34456: 
34456:         mIsFullyObscured = PR_FALSE;
34456: 
19265:         // In Hildon/Maemo, a browser window will get into 'patially visible' state wheneven an
19265:         // autocomplete feature is dropped down (from urlbar or from an entry form completion),
19265:         // and there are no much further ways for that to happen in the plaftorm. In such cases, if hildon
19265:         // virtual keyboard is up, we can not grab focus to any dropdown list. Reason: nsWindow::EnsureGrabs()
19265:         // calls gdk_pointer_grab() which grabs the pointer (usually a mouse) so that all events are passed
19265:         // to this it until the pointer is ungrabbed.
39627:         if (!nsGtkIMModule::IsVirtualKeyboardOpened()) {
    1:             // if we have to retry the grab, retry it.
    1:             EnsureGrabs();
39627:         }
    1:         break;
    1:     default: // includes GDK_VISIBILITY_FULLY_OBSCURED
34456:         mIsFullyObscured = PR_TRUE;
    1:         break;
    1:     }
    1: }
    1: 
    1: void
    1: nsWindow::OnWindowStateEvent(GtkWidget *aWidget, GdkEventWindowState *aEvent)
    1: {
    1:     LOG(("nsWindow::OnWindowStateEvent [%p] changed %d new_window_state %d\n",
    1:          (void *)this, aEvent->changed_mask, aEvent->new_window_state));
    1: 
34456:     if (IS_MOZ_CONTAINER(aWidget)) {
34456:         // This event is notifying the container widget of changes to the
34456:         // toplevel window.  Just detect changes affecting whether windows are
34456:         // viewable.
34456:         //
34456:         // (A visibility notify event is sent to each window that becomes
34456:         // viewable when the toplevel is mapped, but we can't rely on that for
34456:         // setting mHasMappedToplevel because these toplevel window state
34456:         // events are asynchronous.  The windows in the hierarchy now may not
34456:         // be the same windows as when the toplevel was mapped, so they may
34456:         // not get VisibilityNotify events.)
34456:         PRBool mapped =
34456:             !(aEvent->new_window_state &
34456:               (GDK_WINDOW_STATE_ICONIFIED|GDK_WINDOW_STATE_WITHDRAWN));
34456:         if (mHasMappedToplevel != mapped) {
34456:             SetHasMappedToplevel(mapped);
34456:         }
34456:         return;
34456:     }
34456:     // else the widget is a shell widget.
34456: 
    1:     nsSizeModeEvent event(PR_TRUE, NS_SIZEMODE, this);
    1: 
    1:     // We don't care about anything but changes in the maximized/icon
    1:     // states
 9467:     if ((aEvent->changed_mask
 9467:          & (GDK_WINDOW_STATE_ICONIFIED|GDK_WINDOW_STATE_MAXIMIZED)) == 0) {
    1:         return;
    1:     }
    1: 
    1:     if (aEvent->new_window_state & GDK_WINDOW_STATE_ICONIFIED) {
    1:         LOG(("\tIconified\n"));
    1:         event.mSizeMode = nsSizeMode_Minimized;
    1:         mSizeState = nsSizeMode_Minimized;
64019: #ifdef ACCESSIBILITY
64019:         DispatchMinimizeEventAccessible();
64019: #endif //ACCESSIBILITY
    1:     }
    1:     else if (aEvent->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
    1:         LOG(("\tMaximized\n"));
    1:         event.mSizeMode = nsSizeMode_Maximized;
    1:         mSizeState = nsSizeMode_Maximized;
64019: #ifdef ACCESSIBILITY
64019:         DispatchMaximizeEventAccessible();
64019: #endif //ACCESSIBILITY
    1:     }
31567:     else if (aEvent->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {
31567:         LOG(("\tFullscreen\n"));
31567:         event.mSizeMode = nsSizeMode_Fullscreen;
31567:         mSizeState = nsSizeMode_Fullscreen;
31567:     }
    1:     else {
    1:         LOG(("\tNormal\n"));
    1:         event.mSizeMode = nsSizeMode_Normal;
    1:         mSizeState = nsSizeMode_Normal;
64019: #ifdef ACCESSIBILITY
64019:         DispatchRestoreEventAccessible();
64019: #endif //ACCESSIBILITY
    1:     }
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: }
    1: 
    1: void
    1: nsWindow::ThemeChanged()
    1: {
    1:     nsGUIEvent event(PR_TRUE, NS_THEMECHANGED, this);
    1:     nsEventStatus status = nsEventStatus_eIgnore;
    1:     DispatchEvent(&event, status);
    1: 
30704:     if (!mGdkWindow || NS_UNLIKELY(mIsDestroyed))
    1:         return;
    1: 
    1:     // Dispatch NS_THEMECHANGED to all child windows
    1:     GList *children =
30704:         gdk_window_peek_children(mGdkWindow);
    1:     while (children) {
    1:         GdkWindow *gdkWin = GDK_WINDOW(children->data);
    1: 
    1:         nsWindow *win = (nsWindow*) g_object_get_data(G_OBJECT(gdkWin),
    1:                                                       "nsWindow");
    1: 
  920:         if (win && win != this) { // guard against infinite recursion
  920:             nsRefPtr<nsWindow> kungFuDeathGrip = win;
    1:             win->ThemeChanged();
  920:         }
    1: 
    1:         children = children->next;
    1:     }
    1: }
    1: 
37793: void
37793: nsWindow::CheckNeedDragLeaveEnter(nsWindow* aInnerMostWidget,
37793:                                   nsIDragService* aDragService,
37793:                                   GdkDragContext *aDragContext,
37793:                                   nscoord aX, nscoord aY)
37793: {
37793:     // check to see if there was a drag motion window already in place
61355:     if (sLastDragMotionWindow) {
37793:         // same as the last window so no need for dragenter and dragleave events
61355:         if (sLastDragMotionWindow == aInnerMostWidget) {
37793:             UpdateDragStatus(aDragContext, aDragService);
37793:             return;
37793:         }
37793: 
37793:         // send a dragleave event to the last window that got a motion event
61355:         nsRefPtr<nsWindow> kungFuDeathGrip = sLastDragMotionWindow;
61355:         sLastDragMotionWindow->OnDragLeave();
37793:     }
37793: 
37793:     // Make sure that the drag service knows we're now dragging
37793:     aDragService->StartDragSession();
37793: 
37793:     // update our drag status and send a dragenter event to the window
37793:     UpdateDragStatus(aDragContext, aDragService);
37793:     aInnerMostWidget->OnDragEnter(aX, aY);
37793: 
37793:     // set the last window to the innerMostWidget
61355:     sLastDragMotionWindow = aInnerMostWidget;
37793: }
37793: 
    1: gboolean
    1: nsWindow::OnDragMotionEvent(GtkWidget *aWidget,
    1:                             GdkDragContext *aDragContext,
    1:                             gint aX,
    1:                             gint aY,
    1:                             guint aTime,
    1:                             gpointer aData)
    1: {
29217:     LOGDRAG(("nsWindow::OnDragMotionSignal\n"));
    1: 
39762:     if (sLastButtonReleaseTime) {
    1:       // The drag ended before it was even setup to handle the end of the drag
    1:       // So, we fake the button getting released again to release the drag
    1:       GtkWidget *widget = gtk_grab_get_current();
    1:       GdkEvent event;
    1:       gboolean retval;
    1:       memset(&event, 0, sizeof(event));
    1:       event.type = GDK_BUTTON_RELEASE;
39762:       event.button.time = sLastButtonReleaseTime;
    1:       event.button.button = 1;
39762:       sLastButtonReleaseTime = 0;
    1:       if (widget) {
    1:         g_signal_emit_by_name(widget, "button_release_event", &event, &retval);
    1:         return TRUE;
    1:       }
    1:     }
    1: 
    1:     sIsDraggingOutOf = PR_FALSE;
    1: 
    1:     // get our drag context
    1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
    1:     nsCOMPtr<nsIDragSessionGTK> dragSessionGTK = do_QueryInterface(dragService);
    1: 
    1:     // first, figure out which internal widget this drag motion actually
    1:     // happened on
    1:     nscoord retx = 0;
    1:     nscoord rety = 0;
    1: 
  920:     GdkWindow *innerWindow = get_inner_gdk_window(aWidget->window, aX, aY,
    1:                                                   &retx, &rety);
  920:     nsRefPtr<nsWindow> innerMostWidget = get_window_for_gdk_window(innerWindow);
    1: 
    1:     if (!innerMostWidget)
    1:         innerMostWidget = this;
    1: 
    1:     // update the drag context
    1:     dragSessionGTK->TargetSetLastContext(aWidget, aDragContext, aTime);
    1: 
37793:     // clear any drag leave timer that might be pending so that it
37793:     // doesn't get processed when we actually go out to get data.
37793:     if (mDragLeaveTimer) {
37793:         mDragLeaveTimer->Cancel();
37793:         mDragLeaveTimer = nsnull;
37793:     }
37793: 
37793:     CheckNeedDragLeaveEnter(innerMostWidget, dragService, aDragContext, retx, rety);
37793: 
    1:     // notify the drag service that we are starting a drag motion.
    1:     dragSessionGTK->TargetStartDragMotion();
    1: 
  482:     dragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
  482: 
18445:     nsDragEvent event(PR_TRUE, NS_DRAGDROP_OVER, innerMostWidget);
    1: 
    1:     InitDragEvent(event);
    1: 
    1:     event.refPoint.x = retx;
    1:     event.refPoint.y = rety;
    1:     event.time = aTime;
    1: 
    1:     nsEventStatus status;
    1:     innerMostWidget->DispatchEvent(&event, status);
    1: 
    1:     // we're done with the drag motion event.  notify the drag service.
    1:     dragSessionGTK->TargetEndDragMotion(aWidget, aDragContext, aTime);
    1: 
    1:     // and unset our context
    1:     dragSessionGTK->TargetSetLastContext(0, 0, 0);
    1: 
    1:     return TRUE;
    1: }
    1: 
    1: void
    1: nsWindow::OnDragLeaveEvent(GtkWidget *aWidget,
    1:                            GdkDragContext *aDragContext,
    1:                            guint aTime,
    1:                            gpointer aData)
    1: {
    1:     // XXX Do we want to pass this on only if the event's subwindow is null?
    1: 
29217:     LOGDRAG(("nsWindow::OnDragLeaveSignal(%p)\n", (void*)this));
    1: 
    1:     sIsDraggingOutOf = PR_TRUE;
    1: 
25825:     if (mDragLeaveTimer) {
25825:         return;
25825:     }
25825: 
    1:     // create a fast timer - we're delaying the drag leave until the
    1:     // next mainloop in hopes that we might be able to get a drag drop
    1:     // signal
    1:     mDragLeaveTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:     NS_ASSERTION(mDragLeaveTimer, "Failed to create drag leave timer!");
    1:     // fire this baby asafp, but not too quickly... see bug 216800 ;-)
    1:     mDragLeaveTimer->InitWithFuncCallback(DragLeaveTimerCallback,
    1:                                           (void *)this,
    1:                                           20, nsITimer::TYPE_ONE_SHOT);
    1: }
    1: 
    1: gboolean
    1: nsWindow::OnDragDropEvent(GtkWidget *aWidget,
    1:                           GdkDragContext *aDragContext,
    1:                           gint aX,
    1:                           gint aY,
    1:                           guint aTime,
    1:                           gpointer *aData)
    1: 
    1: {
29217:     LOGDRAG(("nsWindow::OnDragDropSignal\n"));
    1: 
    1:     // get our drag context
    1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
    1:     nsCOMPtr<nsIDragSessionGTK> dragSessionGTK = do_QueryInterface(dragService);
    1: 
    1:     nscoord retx = 0;
    1:     nscoord rety = 0;
    1: 
  920:     GdkWindow *innerWindow = get_inner_gdk_window(aWidget->window, aX, aY,
  920:                                                   &retx, &rety);
  920:     nsRefPtr<nsWindow> innerMostWidget = get_window_for_gdk_window(innerWindow);
    1: 
37793:     if (!innerMostWidget)
37793:         innerMostWidget = this;
37793: 
    1:     // set this now before any of the drag enter or leave events happen
    1:     dragSessionGTK->TargetSetLastContext(aWidget, aDragContext, aTime);
    1: 
    1:     // clear any drag leave timer that might be pending so that it
    1:     // doesn't get processed when we actually go out to get data.
    1:     if (mDragLeaveTimer) {
    1:         mDragLeaveTimer->Cancel();
25825:         mDragLeaveTimer = nsnull;
    1:     }
    1: 
37793:     CheckNeedDragLeaveEnter(innerMostWidget, dragService, aDragContext, retx, rety);
    1: 
    1:     // What we do here is dispatch a new drag motion event to
    1:     // re-validate the drag target and then we do the drop.  The events
    1:     // look the same except for the type.
    1: 
18445:     nsDragEvent event(PR_TRUE, NS_DRAGDROP_OVER, innerMostWidget);
    1: 
    1:     InitDragEvent(event);
    1: 
    1:     event.refPoint.x = retx;
    1:     event.refPoint.y = rety;
    1:     event.time = aTime;
    1: 
    1:     nsEventStatus status;
    1:     innerMostWidget->DispatchEvent(&event, status);
    1: 
  920:     // We need to check innerMostWidget->mIsDestroyed here because the nsRefPtr
  920:     // only protects innerMostWidget from being deleted, it does NOT protect
  920:     // against nsView::~nsView() calling Destroy() on it, bug 378670.
  920:     if (!innerMostWidget->mIsDestroyed) {
18552:         nsDragEvent event(PR_TRUE, NS_DRAGDROP_DROP, innerMostWidget);
    1:         event.refPoint.x = retx;
    1:         event.refPoint.y = rety;
    1: 
18552:         nsEventStatus status = nsEventStatus_eIgnore;
    1:         innerMostWidget->DispatchEvent(&event, status);
  920:     }
    1: 
    1:     // before we unset the context we need to do a drop_finish
    1: 
    1:     gdk_drop_finish(aDragContext, TRUE, aTime);
    1: 
    1:     // after a drop takes place we need to make sure that the drag
    1:     // service doesn't think that it still has a context.  if the other
    1:     // way ( besides the drop ) to end a drag event is during the leave
    1:     // event and and that case is handled in that handler.
    1:     dragSessionGTK->TargetSetLastContext(0, 0, 0);
    1: 
61355:     // clear the sLastDragMotion window
61355:     sLastDragMotionWindow = 0;
    1: 
    1:     // Make sure to end the drag session. If this drag started in a
    1:     // different app, we won't get a drag_end signal to end it from.
27557:     gint x, y;
27557:     GdkDisplay* display = gdk_display_get_default();
27557:     if (display) {
27557:       // get the current cursor position
27557:       gdk_display_get_pointer(display, NULL, &x, &y, NULL);
27557:       ((nsDragService *)dragService.get())->SetDragEndPoint(nsIntPoint(x, y));
27557:     }
  482:     dragService->EndDragSession(PR_TRUE);
    1: 
    1:     return TRUE;
    1: }
    1: 
    1: void
    1: nsWindow::OnDragDataReceivedEvent(GtkWidget *aWidget,
    1:                                   GdkDragContext *aDragContext,
    1:                                   gint aX,
    1:                                   gint aY,
    1:                                   GtkSelectionData  *aSelectionData,
    1:                                   guint aInfo,
    1:                                   guint aTime,
    1:                                   gpointer aData)
    1: {
29217:     LOGDRAG(("nsWindow::OnDragDataReceived(%p)\n", (void*)this));
    1: 
    1:     // get our drag context
    1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
    1:     nsCOMPtr<nsIDragSessionGTK> dragSessionGTK = do_QueryInterface(dragService);
    1: 
    1:     dragSessionGTK->TargetDataReceived(aWidget, aDragContext, aX, aY,
    1:                                        aSelectionData, aInfo, aTime);
    1: }
    1: 
    1: void
    1: nsWindow::OnDragLeave(void)
    1: {
29217:     LOGDRAG(("nsWindow::OnDragLeave(%p)\n", (void*)this));
    1: 
18445:     nsDragEvent event(PR_TRUE, NS_DRAGDROP_EXIT, this);
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: 
    1:     nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
    1: 
    1:     if (dragService) {
    1:         nsCOMPtr<nsIDragSession> currentDragSession;
    1:         dragService->GetCurrentSession(getter_AddRefs(currentDragSession));
    1: 
    1:         if (currentDragSession) {
    1:             nsCOMPtr<nsIDOMNode> sourceNode;
    1:             currentDragSession->GetSourceNode(getter_AddRefs(sourceNode));
    1: 
    1:             if (!sourceNode) {
    1:                 // We're leaving a window while doing a drag that was
    1:                 // initiated in a different app. End the drag session,
    1:                 // since we're done with it for now (until the user
    1:                 // drags back into mozilla).
  482:                 dragService->EndDragSession(PR_FALSE);
    1:             }
    1:         }
    1:     }
    1: }
    1: 
    1: void
    1: nsWindow::OnDragEnter(nscoord aX, nscoord aY)
    1: {
    1:     // XXX Do we want to pass this on only if the event's subwindow is null?
    1: 
29217:     LOGDRAG(("nsWindow::OnDragEnter(%p)\n", (void*)this));
    1: 
18445:     nsDragEvent event(PR_TRUE, NS_DRAGDROP_ENTER, this);
    1: 
    1:     event.refPoint.x = aX;
    1:     event.refPoint.y = aY;
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
    1: }
    1: 
    1: static void
    1: GetBrandName(nsXPIDLString& brandName)
    1: {
    1:     nsCOMPtr<nsIStringBundleService> bundleService =
    1:         do_GetService(NS_STRINGBUNDLE_CONTRACTID);
    1: 
    1:     nsCOMPtr<nsIStringBundle> bundle;
    1:     if (bundleService)
    1:         bundleService->CreateBundle(
    1:             "chrome://branding/locale/brand.properties",
    1:             getter_AddRefs(bundle));
    1: 
    1:     if (bundle)
    1:         bundle->GetStringFromName(
    1:             NS_LITERAL_STRING("brandShortName").get(),
    1:             getter_Copies(brandName));
    1: 
    1:     if (brandName.IsEmpty())
    1:         brandName.Assign(NS_LITERAL_STRING("Mozilla"));
    1: }
    1: 
30704: static GdkWindow *
30704: CreateGdkWindow(GdkWindow *parent, GtkWidget *widget)
30704: {
30704:     GdkWindowAttr attributes;
30704:     gint          attributes_mask = GDK_WA_VISUAL | GDK_WA_COLORMAP;
30704: 
30704:     attributes.event_mask = (GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK |
30704:                              GDK_VISIBILITY_NOTIFY_MASK |
30704:                              GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
30704:                              GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
30704: #ifdef HAVE_GTK_MOTION_HINTS
30704:                              GDK_POINTER_MOTION_HINT_MASK |
30704: #endif
30704:                              GDK_POINTER_MOTION_MASK);
30704: 
30704:     attributes.width = 1;
30704:     attributes.height = 1;
30704:     attributes.wclass = GDK_INPUT_OUTPUT;
30704:     attributes.visual = gtk_widget_get_visual(widget);
30704:     attributes.colormap = gtk_widget_get_colormap(widget);
30704:     attributes.window_type = GDK_WINDOW_CHILD;
30704: 
30704:     GdkWindow *window = gdk_window_new(parent, &attributes, attributes_mask);
30704:     gdk_window_set_user_data(window, widget);
30704: 
30704:     /* set the default pixmap to None so that you don't end up with the
30704:        gtk default which is BlackPixel. */
30704:     gdk_window_set_back_pixmap(window, NULL, FALSE);
30704: 
30704:     return window;
30704: }
30704: 
    1: nsresult
33013: nsWindow::Create(nsIWidget        *aParent,
    1:                  nsNativeWidget    aNativeParent,
23738:                  const nsIntRect  &aRect,
    1:                  EVENT_CALLBACK    aHandleEventFunction,
68668:                  nsDeviceContext *aContext,
    1:                  nsIAppShell      *aAppShell,
    1:                  nsIToolkit       *aToolkit,
    1:                  nsWidgetInitData *aInitData)
    1: {
    1:     // only set the base parent if we're going to be a dialog or a
    1:     // toplevel
    1:     nsIWidget *baseParent = aInitData &&
    1:         (aInitData->mWindowType == eWindowType_dialog ||
    1:          aInitData->mWindowType == eWindowType_toplevel ||
    1:          aInitData->mWindowType == eWindowType_invisible) ?
    1:         nsnull : aParent;
    1: 
 6721:     NS_ASSERTION(!mWindowGroup, "already have window group (leaking it)");
    1: 
    1:     // initialize all the common bits of this class
    1:     BaseCreate(baseParent, aRect, aHandleEventFunction, aContext,
    1:                aAppShell, aToolkit, aInitData);
    1: 
    1:     // Do we need to listen for resizes?
    1:     PRBool listenForResizes = PR_FALSE;;
    1:     if (aNativeParent || (aInitData && aInitData->mListenForResizes))
    1:         listenForResizes = PR_TRUE;
    1: 
    1:     // and do our common creation
    1:     CommonCreate(aParent, listenForResizes);
    1: 
    1:     // save our bounds
    1:     mBounds = aRect;
33357:     if (mWindowType != eWindowType_child &&
33357:         mWindowType != eWindowType_plugin) {
59547:         // We only move a toplevel window if someone has actually placed the
59547:         // window somewhere.  If no placement has taken place, we just let the
59547:         // window manager Do The Right Thing.
59547:         //
59547:         // Indicate that if we're shown, we at least need to have our size set.
59547:         // If we get explicitly moved, the position will also be set.
59547:         mNeedsResize = PR_TRUE;
    1:     }
    1: 
    1:     // figure out our parent window
30704:     GtkWidget      *parentMozContainer = nsnull;
    1:     GtkContainer   *parentGtkContainer = nsnull;
    1:     GdkWindow      *parentGdkWindow = nsnull;
    1:     GtkWindow      *topLevelParent = nsnull;
    1: 
    1:     if (aParent)
    1:         parentGdkWindow = GDK_WINDOW(aParent->GetNativeData(NS_NATIVE_WINDOW));
    1:     else if (aNativeParent && GDK_IS_WINDOW(aNativeParent))
    1:         parentGdkWindow = GDK_WINDOW(aNativeParent);
    1:     else if (aNativeParent && GTK_IS_CONTAINER(aNativeParent))
    1:         parentGtkContainer = GTK_CONTAINER(aNativeParent);
    1: 
    1:     if (parentGdkWindow) {
30704:         // get the widget for the window - it should be a moz container
30704:         parentMozContainer = get_gtk_widget_for_gdk_window(parentGdkWindow);
30704: 
30704:         if (!IS_MOZ_CONTAINER(parentMozContainer))
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         // get the toplevel window just in case someone needs to use it
    1:         // for setting transients or whatever.
    1:         topLevelParent =
    1:             GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(parentMozContainer)));
    1:     }
    1: 
    1:     // ok, create our windows
    1:     switch (mWindowType) {
    1:     case eWindowType_dialog:
    1:     case eWindowType_popup:
    1:     case eWindowType_toplevel:
    1:     case eWindowType_invisible: {
    1:         mIsTopLevel = PR_TRUE;
    1: 
    1:         nsXPIDLString brandName;
    1:         GetBrandName(brandName);
    1:         NS_ConvertUTF16toUTF8 cBrand(brandName);
    1: 
    1:         if (mWindowType == eWindowType_dialog) {
    1:             mShell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    1:             SetDefaultIcon();
    1:             gtk_window_set_wmclass(GTK_WINDOW(mShell), "Dialog", cBrand.get());
    1:             gtk_window_set_type_hint(GTK_WINDOW(mShell),
    1:                                      GDK_WINDOW_TYPE_HINT_DIALOG);
    1:             gtk_window_set_transient_for(GTK_WINDOW(mShell),
    1:                                          topLevelParent);
    1:             mTransientParent = topLevelParent;
    1:             // add ourselves to the parent window's window group
    1:             if (!topLevelParent) {
    1:                 gtk_widget_realize(mShell);
    1:                 GdkWindow* dialoglead = mShell->window;
    1:                 gdk_window_set_group(dialoglead, dialoglead);
    1:             }
30704:             if (parentGdkWindow) {
    1:                 nsWindow *parentnsWindow =
30704:                     get_window_for_gdk_window(parentGdkWindow);
    1:                 NS_ASSERTION(parentnsWindow,
30704:                              "no nsWindow for parentGdkWindow!");
    1:                 if (parentnsWindow && parentnsWindow->mWindowGroup) {
    1:                     gtk_window_group_add_window(parentnsWindow->mWindowGroup,
    1:                                                 GTK_WINDOW(mShell));
    1:                     // store this in case any children are created
    1:                     mWindowGroup = parentnsWindow->mWindowGroup;
 6721:                     g_object_ref(G_OBJECT(mWindowGroup));
    1:                     LOG(("adding window %p to group %p\n",
    1:                          (void *)mShell, (void *)mWindowGroup));
    1:                 }
    1:             }
    1:         }
    1:         else if (mWindowType == eWindowType_popup) {
48254:             // Popups that are not noautohide are only temporary. The are used
48254:             // for menus and the like and disappear when another window is used.
48254:             if (!aInitData->mNoAutoHide) {
43761:                 // For most popups, use the standard GtkWindowType
43761:                 // GTK_WINDOW_POPUP, which will use a Window with the
43761:                 // override-redirect attribute (for temporary windows).
43761:                 mShell = gtk_window_new(GTK_WINDOW_POPUP);
51873:                 gtk_window_set_wmclass(GTK_WINDOW(mShell), "Popup", cBrand.get());
43761:             } else {
43761:                 // For long-lived windows, their stacking order is managed by
43761:                 // the window manager, as indicated by GTK_WINDOW_TOPLEVEL ...
13078:                 mShell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
51873:                 gtk_window_set_wmclass(GTK_WINDOW(mShell), "Popup", cBrand.get());
43761:                 // ... but the window manager does not decorate this window,
43761:                 // nor provide a separate taskbar icon.
48261:                 if (mBorderStyle == eBorderStyle_default) {
48261:                   gtk_window_set_decorated(GTK_WINDOW(mShell), FALSE);
48261:                 }
48261:                 else {
48261:                   PRBool decorate = mBorderStyle & eBorderStyle_title;
48261:                   gtk_window_set_decorated(GTK_WINDOW(mShell), decorate);
48261:                   if (decorate) {
48261:                     gtk_window_set_deletable(GTK_WINDOW(mShell), mBorderStyle & eBorderStyle_close);
48261:                   }
48261:                 }
51873:                 gtk_window_set_skip_taskbar_hint(GTK_WINDOW(mShell), TRUE);
43761:                 // Element focus is managed by the parent window so the
43761:                 // WM_HINTS input field is set to False to tell the window
43761:                 // manager not to set input focus to this window ...
51873:                 gtk_window_set_accept_focus(GTK_WINDOW(mShell), FALSE);
43761: #ifdef MOZ_X11
43761:                 // ... but when the window manager offers focus through
43761:                 // WM_TAKE_FOCUS, focus is requested on the parent window.
43761:                 gtk_widget_realize(mShell);
43761:                 gdk_window_add_filter(mShell->window,
43761:                                       popup_take_focus_filter, NULL); 
43761: #endif
43761:             }
43761: 
12796:             GdkWindowTypeHint gtkTypeHint;
12796:             switch (aInitData->mPopupHint) {
12796:                 case ePopupTypeMenu:
12796:                     gtkTypeHint = GDK_WINDOW_TYPE_HINT_POPUP_MENU;
12796:                     break;
12796:                 case ePopupTypeTooltip:
12796:                     gtkTypeHint = GDK_WINDOW_TYPE_HINT_TOOLTIP;
12796:                     break;
12796:                 default:
12796:                     gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
12796:                     break;
12796:             }
12796:             gtk_window_set_type_hint(GTK_WINDOW(mShell), gtkTypeHint);
    1: 
    1:             if (topLevelParent) {
    1:                 gtk_window_set_transient_for(GTK_WINDOW(mShell),
    1:                                             topLevelParent);
    1:                 mTransientParent = topLevelParent;
    1: 
    1:                 if (topLevelParent->group) {
    1:                     gtk_window_group_add_window(topLevelParent->group,
    1:                                             GTK_WINDOW(mShell));
    1:                     mWindowGroup = topLevelParent->group;
 6721:                     g_object_ref(G_OBJECT(mWindowGroup));
    1:                 }
    1:             }
    1:         }
    1:         else { // must be eWindowType_toplevel
    1:             mShell = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    1:             SetDefaultIcon();
    1:             gtk_window_set_wmclass(GTK_WINDOW(mShell), "Toplevel", cBrand.get());
    1: 
    1:             // each toplevel window gets its own window group
    1:             mWindowGroup = gtk_window_group_new();
    1: 
    1:             // and add ourselves to the window group
    1:             LOG(("adding window %p to new group %p\n",
    1:                  (void *)mShell, (void *)mWindowGroup));
    1:             gtk_window_group_add_window(mWindowGroup, GTK_WINDOW(mShell));
    1:         }
    1: 
    1:         // create our container
30704:         GtkWidget *container = moz_container_new();
30704:         mContainer = MOZ_CONTAINER(container);
30704:         gtk_container_add(GTK_CONTAINER(mShell), container);
30704:         gtk_widget_realize(container);
    1: 
30515:         // Don't let GTK mess with the shapes of our GdkWindows
30704:         GTK_PRIVATE_SET_FLAG(container, GTK_HAS_SHAPE_MASK);
30515: 
    1:         // make sure this is the focus widget in the container
30704:         gtk_window_set_focus(GTK_WINDOW(mShell), container);
30704: 
30705:         // the drawing window
30705:         mGdkWindow = container->window;
    1: 
    1:         if (mWindowType == eWindowType_popup) {
    1:             // gdk does not automatically set the cursor for "temporary"
    1:             // windows, which are what gtk uses for popups.
    1: 
    1:             mCursor = eCursor_wait; // force SetCursor to actually set the
    1:                                     // cursor, even though our internal state
    1:                                     // indicates that we already have the
    1:                                     // standard cursor.
    1:             SetCursor(eCursor_standard);
48256: 
48256:             if (aInitData->mNoAutoHide) {
48256:                 gint wmd = ConvertBorderStyles(mBorderStyle);
48256:                 if (wmd != -1)
48256:                   gdk_window_set_decorations(mShell->window, (GdkWMDecoration) wmd);
48256:             }
    1:         }
    1:     }
    1:         break;
33357:     case eWindowType_plugin:
    1:     case eWindowType_child: {
    1:         if (parentMozContainer) {
30704:             mGdkWindow = CreateGdkWindow(parentGdkWindow, parentMozContainer);
34456:             nsWindow *parentnsWindow =
34456:                 get_window_for_gdk_window(parentGdkWindow);
34456:             if (parentnsWindow)
34456:                 mHasMappedToplevel = parentnsWindow->mHasMappedToplevel;
    1:         }
    1:         else if (parentGtkContainer) {
30704:             GtkWidget *container = moz_container_new();
30704:             mContainer = MOZ_CONTAINER(container);
30704:             gtk_container_add(parentGtkContainer, container);
30704:             gtk_widget_realize(container);
    1: 
30515:             // Don't let GTK mess with the shapes of our GdkWindows
30704:             GTK_PRIVATE_SET_FLAG(container, GTK_HAS_SHAPE_MASK);
30704: 
30705:             mGdkWindow = container->window;
    1:         }
    1:         else {
    1:             NS_WARNING("Warning: tried to create a new child widget with no parent!");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1:         break;
    1:     default:
    1:         break;
    1:     }
    1:     // Disable the double buffer because it will make the caret crazy
    1:     // For bug#153805 (Gtk2 double buffer makes carets misbehave)
16529:     // DirectFB's expose code depends on gtk double buffering
16529:     // XXX - I think this bug is probably dead, we can just use gtk's
16529:     // double-buffering everywhere
16529: #ifdef MOZ_X11
    1:     if (mContainer)
    1:         gtk_widget_set_double_buffered (GTK_WIDGET(mContainer),FALSE);
16529: #endif
    1: 
30704:     // label the drawing window with this object so we can find our way home
30704:     g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", this);
    1: 
    1:     if (mContainer)
    1:         g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
    1: 
    1:     if (mShell)
    1:         g_object_set_data(G_OBJECT(mShell), "nsWindow", this);
    1: 
    1:     // attach listeners for events
    1:     if (mShell) {
    1:         g_signal_connect(G_OBJECT(mShell), "configure_event",
    1:                          G_CALLBACK(configure_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mShell), "delete_event",
    1:                          G_CALLBACK(delete_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mShell), "window_state_event",
    1:                          G_CALLBACK(window_state_event_cb), NULL);
    1: 
    1:         GtkSettings* default_settings = gtk_settings_get_default();
    1:         g_signal_connect_after(default_settings,
    1:                                "notify::gtk-theme-name",
    1:                                G_CALLBACK(theme_changed_cb), this);
    1:         g_signal_connect_after(default_settings,
    1:                                "notify::gtk-font-name",
    1:                                G_CALLBACK(theme_changed_cb), this);
40081: 
40081: #ifdef MOZ_PLATFORM_MAEMO
40081:         if (mWindowType == eWindowType_toplevel) {
40081:             GdkWindow *gdkwin = mShell->window;
40081: 
40087:             // Tell the Hildon desktop that we support being rotated
40087:             gulong portrait_set = 1;
40087:             GdkAtom support = gdk_atom_intern("_HILDON_PORTRAIT_MODE_SUPPORT", FALSE);
40087:             gdk_property_change(gdkwin, support, gdk_x11_xatom_to_atom(XA_CARDINAL),
40087:                                 32, GDK_PROP_MODE_REPLACE,
40087:                                 (const guchar *) &portrait_set, 1);
40087: 
40081:             // Tell maemo-status-volume daemon to ungrab keys
40081:             gulong volume_set = 1;
40081:             GdkAtom keys = gdk_atom_intern("_HILDON_ZOOM_KEY_ATOM", FALSE);
40081:             gdk_property_change(gdkwin, keys, gdk_x11_xatom_to_atom(XA_INTEGER),
40081:                                 32, GDK_PROP_MODE_REPLACE, (const guchar *) &volume_set, 1);
40081:         }
40081: #endif
    1:     }
    1: 
    1:     if (mContainer) {
28365:         g_signal_connect(G_OBJECT(mContainer), "unrealize",
28365:                          G_CALLBACK(container_unrealize_cb), NULL);
    1:         g_signal_connect_after(G_OBJECT(mContainer), "size_allocate",
    1:                                G_CALLBACK(size_allocate_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "expose_event",
    1:                          G_CALLBACK(expose_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "enter_notify_event",
    1:                          G_CALLBACK(enter_notify_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "leave_notify_event",
    1:                          G_CALLBACK(leave_notify_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "motion_notify_event",
    1:                          G_CALLBACK(motion_notify_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "button_press_event",
    1:                          G_CALLBACK(button_press_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "button_release_event",
    1:                          G_CALLBACK(button_release_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "focus_in_event",
    1:                          G_CALLBACK(focus_in_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "focus_out_event",
    1:                          G_CALLBACK(focus_out_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "key_press_event",
    1:                          G_CALLBACK(key_press_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "key_release_event",
    1:                          G_CALLBACK(key_release_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "scroll_event",
    1:                          G_CALLBACK(scroll_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "visibility_notify_event",
    1:                          G_CALLBACK(visibility_notify_event_cb), NULL);
34456:         g_signal_connect(G_OBJECT(mContainer), "hierarchy_changed",
34456:                          G_CALLBACK(hierarchy_changed_cb), NULL);
34456:         // Initialize mHasMappedToplevel.
34456:         hierarchy_changed_cb(GTK_WIDGET(mContainer), NULL);
    1: 
    1:         gtk_drag_dest_set((GtkWidget *)mContainer,
    1:                           (GtkDestDefaults)0,
    1:                           NULL,
    1:                           0,
    1:                           (GdkDragAction)0);
    1: 
    1:         g_signal_connect(G_OBJECT(mContainer), "drag_motion",
    1:                          G_CALLBACK(drag_motion_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "drag_leave",
    1:                          G_CALLBACK(drag_leave_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "drag_drop",
    1:                          G_CALLBACK(drag_drop_event_cb), NULL);
    1:         g_signal_connect(G_OBJECT(mContainer), "drag_data_received",
    1:                          G_CALLBACK(drag_data_received_event_cb), NULL);
    1: 
    1:         // We create input contexts for all containers, except for
    1:         // toplevel popup windows
39627:         if (mWindowType != eWindowType_popup) {
39627:             mIMModule = new nsGtkIMModule(this);
39627:         }
39627:     } else if (!mIMModule) {
39627:         nsWindow *container = GetContainerWindow();
39627:         if (container) {
39627:             mIMModule = container->mIMModule;
39627:         }
    1:     }
    1: 
    1:     LOG(("nsWindow [%p]\n", (void *)this));
    1:     if (mShell) {
    1:         LOG(("\tmShell %p %p %lx\n", (void *)mShell, (void *)mShell->window,
    1:              GDK_WINDOW_XWINDOW(mShell->window)));
    1:     }
    1: 
    1:     if (mContainer) {
    1:         LOG(("\tmContainer %p %p %lx\n", (void *)mContainer,
    1:              (void *)GTK_WIDGET(mContainer)->window,
    1:              GDK_WINDOW_XWINDOW(GTK_WIDGET(mContainer)->window)));
    1:     }
30705:     else if (mGdkWindow) {
30704:         LOG(("\tmGdkWindow %p %lx\n", (void *)mGdkWindow,
30704:              GDK_WINDOW_XWINDOW(mGdkWindow)));
    1:     }
    1: 
    1:     // resize so that everything is set to the right dimensions
 2144:     if (!mIsTopLevel)
 1931:         Resize(mBounds.x, mBounds.y, mBounds.width, mBounds.height, PR_FALSE);
    1: 
    1: #ifdef ACCESSIBILITY
    1:     nsresult rv;
    1:     if (!sAccessibilityChecked) {
    1:         sAccessibilityChecked = PR_TRUE;
    1: 
    1:         //check if accessibility enabled/disabled by environment variable
    1:         const char *envValue = PR_GetEnv(sAccEnv);
    1:         if (envValue) {
19277:             sAccessibilityEnabled = atoi(envValue) != 0;
    1:             LOG(("Accessibility Env %s=%s\n", sAccEnv, envValue));
    1:         }
    1:         //check gconf-2 setting
    1:         else {
    1:             nsCOMPtr<nsIPrefBranch> sysPrefService =
    1:                 do_GetService(sSysPrefService, &rv);
    1:             if (NS_SUCCEEDED(rv) && sysPrefService) {
    1: 
    1:                 // do the work to get gconf setting.
    1:                 // will be done soon later.
    1:                 sysPrefService->GetBoolPref(sAccessibilityKey,
    1:                                             &sAccessibilityEnabled);
    1:             }
    1: 
    1:         }
    1:     }
    1:     if (sAccessibilityEnabled) {
    1:         LOG(("nsWindow:: Create Toplevel Accessibility\n"));
    1:         CreateRootAccessible();
    1:     }
    1: #endif
    1: 
16529: #ifdef MOZ_DFB
16529:     if (!mDFB) {
16529:          DirectFBCreate( &mDFB );
16529: 
16529:          D_ASSUME( mDFB != NULL );
16529: 
16529:          if (mDFB)
16529:               mDFB->GetDisplayLayer( mDFB, DLID_PRIMARY, &mDFBLayer );
16529: 
16529:          D_ASSUME( mDFBLayer != NULL );
16529: 
16529:          if (mDFBLayer)
16529:               mDFBLayer->GetCursorPosition( mDFBLayer, &mDFBCursorX, &mDFBCursorY );
16529:     }
16529: #endif
16529: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::SetWindowClass(const nsAString &xulWinType)
    1: {
    1:   if (!mShell)
    1:     return NS_ERROR_FAILURE;
    1: 
16529: #ifdef MOZ_X11
    1:   nsXPIDLString brandName;
    1:   GetBrandName(brandName);
    1: 
    1:   XClassHint *class_hint = XAllocClassHint();
    1:   if (!class_hint)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   const char *role = NULL;
    1:   class_hint->res_name = ToNewCString(xulWinType);
    1:   if (!class_hint->res_name) {
    1:     XFree(class_hint);
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   class_hint->res_class = ToNewCString(brandName);
    1:   if (!class_hint->res_class) {
    1:     nsMemory::Free(class_hint->res_name);
    1:     XFree(class_hint);
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Parse res_name into a name and role. Characters other than
    1:   // [A-Za-z0-9_-] are converted to '_'. Anything after the first
    1:   // colon is assigned to role; if there's no colon, assign the
    1:   // whole thing to both role and res_name.
    1:   for (char *c = class_hint->res_name; *c; c++) {
    1:     if (':' == *c) {
    1:       *c = 0;
    1:       role = c + 1;
    1:     }
    1:     else if (!isascii(*c) || (!isalnum(*c) && ('_' != *c) && ('-' != *c)))
    1:       *c = '_';
    1:   }
    1:   class_hint->res_name[0] = toupper(class_hint->res_name[0]);
    1:   if (!role) role = class_hint->res_name;
    1: 
    1:   gdk_window_set_role(GTK_WIDGET(mShell)->window, role);
    1:   // Can't use gtk_window_set_wmclass() for this; it prints
    1:   // a warning & refuses to make the change.
    1:   XSetClassHint(GDK_DISPLAY(),
    1:                 GDK_WINDOW_XWINDOW(GTK_WIDGET(mShell)->window),
    1:                 class_hint);
    1:   nsMemory::Free(class_hint->res_class);
    1:   nsMemory::Free(class_hint->res_name);
    1:   XFree(class_hint);
16529: #else /* MOZ_X11 */
16529: 
16529:   char *res_name;
16529: 
16529:   res_name = ToNewCString(xulWinType);
16529:   if (!res_name)
16529:     return NS_ERROR_OUT_OF_MEMORY;
16529: 
16529:   printf("WARN: res_name = '%s'\n", res_name);
16529: 
16529: 
16529:   const char *role = NULL;
16529: 
16529:   // Parse res_name into a name and role. Characters other than
16529:   // [A-Za-z0-9_-] are converted to '_'. Anything after the first
16529:   // colon is assigned to role; if there's no colon, assign the
16529:   // whole thing to both role and res_name.
16529:   for (char *c = res_name; *c; c++) {
16529:     if (':' == *c) {
16529:       *c = 0;
16529:       role = c + 1;
16529:     }
16529:     else if (!isascii(*c) || (!isalnum(*c) && ('_' != *c) && ('-' != *c)))
16529:       *c = '_';
16529:   }
16529:   res_name[0] = toupper(res_name[0]);
16529:   if (!role) role = res_name;
16529: 
16529:   gdk_window_set_role(GTK_WIDGET(mShell)->window, role);
16529: 
16529:   nsMemory::Free(res_name);
16529: 
16529: #endif /* MOZ_X11 */
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsWindow::NativeResize(PRInt32 aWidth, PRInt32 aHeight, PRBool  aRepaint)
    1: {
    1:     LOG(("nsWindow::NativeResize [%p] %d %d\n", (void *)this,
    1:          aWidth, aHeight));
    1: 
    1:     ResizeTransparencyBitmap(aWidth, aHeight);
    1: 
    1:     // clear our resize flag
    1:     mNeedsResize = PR_FALSE;
    1: 
    1:     if (mIsTopLevel) {
    1:         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
    1:     }
    1:     else if (mContainer) {
30705:         GtkWidget *widget = GTK_WIDGET(mContainer);
    1:         GtkAllocation allocation;
30705:         allocation.x = widget->allocation.x;
30705:         allocation.y = widget->allocation.y;
    1:         allocation.width = aWidth;
    1:         allocation.height = aHeight;
30705:         gtk_widget_size_allocate(widget, &allocation);
30705:     }
30705:     else if (mGdkWindow) {
30704:         gdk_window_resize(mGdkWindow, aWidth, aHeight);
    1:     }
26758: }
    1: 
    1: void
    1: nsWindow::NativeResize(PRInt32 aX, PRInt32 aY,
    1:                        PRInt32 aWidth, PRInt32 aHeight,
    1:                        PRBool  aRepaint)
    1: {
    1:     mNeedsResize = PR_FALSE;
    1:     mNeedsMove = PR_FALSE;
    1: 
    1:     LOG(("nsWindow::NativeResize [%p] %d %d %d %d\n", (void *)this,
    1:          aX, aY, aWidth, aHeight));
    1: 
    1:     ResizeTransparencyBitmap(aWidth, aHeight);
    1: 
    1:     if (mIsTopLevel) {
    1:         gtk_window_move(GTK_WINDOW(mShell), aX, aY);
    1:         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
    1:     }
    1:     else if (mContainer) {
    1:         GtkAllocation allocation;
30705:         allocation.x = aX;
30705:         allocation.y = aY;
    1:         allocation.width = aWidth;
    1:         allocation.height = aHeight;
    1:         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
30704:     }
30704:     else if (mGdkWindow) {
30704:         gdk_window_move_resize(mGdkWindow, aX, aY, aWidth, aHeight);
    1:     }
    1: }
    1: 
    1: void
    1: nsWindow::NativeShow (PRBool  aAction)
    1: {
    1:     if (aAction) {
    1:         // GTK wants us to set the window mask before we show the window
    1:         // for the first time, or setting the mask later won't work.
    1:         // GTK also wants us to NOT set the window mask if we're not really
    1:         // going to need it, because GTK won't let us unset the mask properly
    1:         // later.
    1:         // So, we delay setting the mask until the last moment: when the window
    1:         // is shown.
    1:         // XXX that may or may not be true for GTK+ 2.x
    1:         if (mTransparencyBitmap) {
    1:             ApplyTransparencyBitmap();
    1:         }
    1: 
    1:         // unset our flag now that our window has been shown
    1:         mNeedsShow = PR_FALSE;
    1: 
    1:         if (mIsTopLevel) {
    1:             // Set up usertime/startupID metadata for the created window.
    1:             if (mWindowType != eWindowType_invisible) {
    1:                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
    1:             }
    1: 
    1:             gtk_widget_show(GTK_WIDGET(mContainer));
    1:             gtk_widget_show(mShell);
    1:         }
    1:         else if (mContainer) {
    1:             gtk_widget_show(GTK_WIDGET(mContainer));
    1:         }
30704:         else if (mGdkWindow) {
30704:             gdk_window_show_unraised(mGdkWindow);
    1:         }
    1:     }
    1:     else {
    1:         if (mIsTopLevel) {
    1:             gtk_widget_hide(GTK_WIDGET(mShell));
    1:             gtk_widget_hide(GTK_WIDGET(mContainer));
    1:         }
    1:         else if (mContainer) {
    1:             gtk_widget_hide(GTK_WIDGET(mContainer));
30705:         }
30705:         else if (mGdkWindow) {
30704:             gdk_window_hide(mGdkWindow);
    1:         }
    1:     }
    1: }
    1: 
34456: void
34456: nsWindow::SetHasMappedToplevel(PRBool aState)
34456: {
34456:     // Even when aState == mHasMappedToplevel (as when this method is called
34456:     // from Show()), child windows need to have their state checked, so don't
34456:     // return early.
34456:     PRBool oldState = mHasMappedToplevel;
34456:     mHasMappedToplevel = aState;
34456: 
34456:     // mHasMappedToplevel is not updated for children of windows that are
34456:     // hidden; GDK knows not to send expose events for these windows.  The
34456:     // state is recorded on the hidden window itself, but, for child trees of
34456:     // hidden windows, their state essentially becomes disconnected from their
34456:     // hidden parent.  When the hidden parent gets shown, the child trees are
34456:     // reconnected, and the state of the window being shown can be easily
34456:     // propagated.
34456:     if (!mIsShown || !mGdkWindow)
34456:         return;
34456: 
34456:     if (aState && !oldState && !mIsFullyObscured) {
34456:         // GDK_EXPOSE events have been ignored but the window is now visible,
34456:         // so make sure GDK doesn't think that the window has already been
34456:         // painted.
34456:         gdk_window_invalidate_rect(mGdkWindow, NULL, FALSE);
34456: 
34456:         // Check that a grab didn't fail due to the window not being
34456:         // viewable.
34456:         EnsureGrabs();
34456:     }
34456: 
34456:     for (GList *children = gdk_window_peek_children(mGdkWindow);
34456:          children;
34456:          children = children->next) {
34456:         GdkWindow *gdkWin = GDK_WINDOW(children->data);
34456:         nsWindow *child = get_window_for_gdk_window(gdkWin);
34456: 
34456:         if (child && child->mHasMappedToplevel != aState) {
34456:             child->SetHasMappedToplevel(aState);
34456:         }
34456:     }
34456: }
34456: 
23738: nsIntSize
23738: nsWindow::GetSafeWindowSize(nsIntSize aSize)
23738: {
23738:     nsIntSize result = aSize;
18736:     const PRInt32 kInt16Max = 32767;
18736:     if (result.width > kInt16Max) {
15623:         NS_WARNING("Clamping huge window width");
18736:         result.width = kInt16Max;
18736:     }
18736:     if (result.height > kInt16Max) {
15623:         NS_WARNING("Clamping huge window height");
18736:         result.height = kInt16Max;
15623:     }
15623:     return result;
15623: }
15623: 
    1: void
    1: nsWindow::EnsureGrabs(void)
    1: {
    1:     if (mRetryPointerGrab)
    1:         GrabPointer();
    1: }
    1: 
16601: void
16601: nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
    1: {
    1:     if (!mShell) {
    1:         // Pass the request to the toplevel window
    1:         GtkWidget *topWidget = nsnull;
    1:         GetToplevelWidget(&topWidget);
    1:         if (!topWidget)
16601:             return;
    1: 
    1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
    1:         if (!topWindow)
16601:             return;
16601: 
16601:         topWindow->SetTransparencyMode(aMode);
16601:         return;
16601:     }
16601:     PRBool isTransparent = aMode == eTransparencyTransparent;
16601: 
16601:     if (mIsTransparent == isTransparent)
16601:         return;
16601: 
16601:     if (!isTransparent) {
    1:         if (mTransparencyBitmap) {
    1:             delete[] mTransparencyBitmap;
    1:             mTransparencyBitmap = nsnull;
    1:             mTransparencyBitmapWidth = 0;
    1:             mTransparencyBitmapHeight = 0;
    1:             gtk_widget_reset_shapes(mShell);
    1:         }
    1:     } // else the new default alpha values are "all 1", so we don't
    1:     // need to change anything yet
    1: 
16601:     mIsTransparent = isTransparent;
16601: }
16601: 
16601: nsTransparencyMode
16601: nsWindow::GetTransparencyMode()
    1: {
    1:     if (!mShell) {
    1:         // Pass the request to the toplevel window
    1:         GtkWidget *topWidget = nsnull;
    1:         GetToplevelWidget(&topWidget);
    1:         if (!topWidget) {
16601:             return eTransparencyOpaque;
    1:         }
    1: 
    1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
    1:         if (!topWindow) {
16601:             return eTransparencyOpaque;
16601:         }
16601: 
16601:         return topWindow->GetTransparencyMode();
16601:     }
16601: 
16601:     return mIsTransparent ? eTransparencyTransparent : eTransparencyOpaque;
    1: }
    1: 
30515: nsresult
30515: nsWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
30515: {
30515:     for (PRUint32 i = 0; i < aConfigurations.Length(); ++i) {
30515:         const Configuration& configuration = aConfigurations[i];
30515:         nsWindow* w = static_cast<nsWindow*>(configuration.mChild);
30515:         NS_ASSERTION(w->GetParent() == this,
30515:                      "Configured widget is not a child");
35698:         w->SetWindowClipRegion(configuration.mClipRegion, PR_TRUE);
30515:         if (w->mBounds.Size() != configuration.mBounds.Size()) {
30515:             w->Resize(configuration.mBounds.x, configuration.mBounds.y,
30515:                       configuration.mBounds.width, configuration.mBounds.height,
30515:                       PR_TRUE);
30515:         } else if (w->mBounds.TopLeft() != configuration.mBounds.TopLeft()) {
30515:             w->Move(configuration.mBounds.x, configuration.mBounds.y);
30515:         } 
35698:         w->SetWindowClipRegion(configuration.mClipRegion, PR_FALSE);
30515:     }
30515:     return NS_OK;
30515: }
30515: 
50394: static pixman_box32
50394: ToPixmanBox(const nsIntRect& aRect)
50394: {
50394:     pixman_box32_t result;
50394:     result.x1 = aRect.x;
50394:     result.y1 = aRect.y;
50394:     result.x2 = aRect.XMost();
50394:     result.y2 = aRect.YMost();
50394:     return result;
50394: }
50394: 
50394: static nsIntRect
50394: ToIntRect(const pixman_box32& aBox)
50394: {
50394:     nsIntRect result;
50394:     result.x = aBox.x1;
50394:     result.y = aBox.y1;
50394:     result.width = aBox.x2 - aBox.x1;
50394:     result.height = aBox.y2 - aBox.y1;
50394:     return result;
50394: }
50394: 
50394: static void
50394: InitRegion(pixman_region32* aRegion,
50394:            const nsTArray<nsIntRect>& aRects)
50394: {
50394:     nsAutoTArray<pixman_box32,10> rects;
50394:     rects.SetCapacity(aRects.Length());
50394:     for (PRUint32 i = 0; i < aRects.Length (); ++i) {
50394:         if (!aRects[i].IsEmpty()) {
50394:             rects.AppendElement(ToPixmanBox(aRects[i]));
50394:         }
50394:     }
50394: 
50394:     pixman_region32_init_rects(aRegion,
50394:                                rects.Elements(), rects.Length());
50394: }
50394: 
50394: static void
50394: GetIntRects(pixman_region32& aRegion, nsTArray<nsIntRect>* aRects)
50394: {
50394:     int nRects;
50394:     pixman_box32* boxes = pixman_region32_rectangles(&aRegion, &nRects);
50394:     aRects->SetCapacity(aRects->Length() + nRects);
50394:     for (int i = 0; i < nRects; ++i) {
50394:         aRects->AppendElement(ToIntRect(boxes[i]));
50394:     }
50394: }
50394: 
35698: void
35698: nsWindow::SetWindowClipRegion(const nsTArray<nsIntRect>& aRects,
35698:                               PRBool aIntersectWithExisting)
35698: {
35698:     const nsTArray<nsIntRect>* newRects = &aRects;
35698: 
35698:     nsAutoTArray<nsIntRect,1> intersectRects;
35698:     if (aIntersectWithExisting) {
35698:         nsAutoTArray<nsIntRect,1> existingRects;
35698:         GetWindowClipRegion(&existingRects);
35698: 
35698:         nsAutoRef<pixman_region32> existingRegion;
35698:         InitRegion(&existingRegion, existingRects);
35698:         nsAutoRef<pixman_region32> newRegion;
35698:         InitRegion(&newRegion, aRects);
35698:         nsAutoRef<pixman_region32> intersectRegion;
39053:         pixman_region32_init(&intersectRegion);
35698:         pixman_region32_intersect(&intersectRegion,
35698:                                   &newRegion, &existingRegion);
35698: 
59054:         // If mClipRects is null we haven't set a clip rect yet, so we
59054:         // need to set the clip even if it is equal.
59054:         if (mClipRects &&
59054:             pixman_region32_equal(&intersectRegion, &existingRegion)) {
35698:             return;
59054:         }
35698: 
35698:         if (!pixman_region32_equal(&intersectRegion, &newRegion)) {
35698:             GetIntRects(intersectRegion, &intersectRects);
35698:             newRects = &intersectRects;
35698:         }
35698:     }
35698: 
35698:     if (!StoreWindowClipRegion(*newRects))
35698:         return;
30515: 
30704:     if (!mGdkWindow)
35698:         return;
35698: 
35698:     GdkRegion *region = gdk_region_new(); // aborts on OOM
35698:     for (PRUint32 i = 0; i < newRects->Length(); ++i) {
35698:         const nsIntRect& r = newRects->ElementAt(i);
30515:         GdkRectangle rect = { r.x, r.y, r.width, r.height };
30515:         gdk_region_union_with_rect(region, &rect);
30515:     }
30515: 
30704:     gdk_window_shape_combine_region(mGdkWindow, region, 0, 0);
30515:     gdk_region_destroy(region);
30515: 
35698:     return;
30515: }
30515: 
    1: void
    1: nsWindow::ResizeTransparencyBitmap(PRInt32 aNewWidth, PRInt32 aNewHeight)
    1: {
    1:     if (!mTransparencyBitmap)
    1:         return;
    1: 
    1:     if (aNewWidth == mTransparencyBitmapWidth &&
    1:         aNewHeight == mTransparencyBitmapHeight)
    1:         return;
    1: 
    1:     PRInt32 newSize = ((aNewWidth+7)/8)*aNewHeight;
    1:     gchar* newBits = new gchar[newSize];
    1:     if (!newBits) {
    1:         delete[] mTransparencyBitmap;
    1:         mTransparencyBitmap = nsnull;
    1:         mTransparencyBitmapWidth = 0;
    1:         mTransparencyBitmapHeight = 0;
    1:         return;
    1:     }
    1:     // fill new mask with "opaque", first
    1:     memset(newBits, 255, newSize);
    1: 
    1:     // Now copy the intersection of the old and new areas into the new mask
    1:     PRInt32 copyWidth = PR_MIN(aNewWidth, mTransparencyBitmapWidth);
    1:     PRInt32 copyHeight = PR_MIN(aNewHeight, mTransparencyBitmapHeight);
    1:     PRInt32 oldRowBytes = (mTransparencyBitmapWidth+7)/8;
    1:     PRInt32 newRowBytes = (aNewWidth+7)/8;
    1:     PRInt32 copyBytes = (copyWidth+7)/8;
    1: 
    1:     PRInt32 i;
    1:     gchar* fromPtr = mTransparencyBitmap;
    1:     gchar* toPtr = newBits;
    1:     for (i = 0; i < copyHeight; i++) {
    1:         memcpy(toPtr, fromPtr, copyBytes);
    1:         fromPtr += oldRowBytes;
    1:         toPtr += newRowBytes;
    1:     }
    1: 
    1:     delete[] mTransparencyBitmap;
    1:     mTransparencyBitmap = newBits;
    1:     mTransparencyBitmapWidth = aNewWidth;
    1:     mTransparencyBitmapHeight = aNewHeight;
    1: }
    1: 
    1: static PRBool
    1: ChangedMaskBits(gchar* aMaskBits, PRInt32 aMaskWidth, PRInt32 aMaskHeight,
23738:         const nsIntRect& aRect, PRUint8* aAlphas, PRInt32 aStride)
    1: {
    1:     PRInt32 x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
    1:     PRInt32 maskBytesPerRow = (aMaskWidth + 7)/8;
    1:     for (y = aRect.y; y < yMax; y++) {
    1:         gchar* maskBytes = aMaskBits + y*maskBytesPerRow;
    1:         PRUint8* alphas = aAlphas;
    1:         for (x = aRect.x; x < xMax; x++) {
    1:             PRBool newBit = *alphas > 0;
    1:             alphas++;
    1: 
    1:             gchar maskByte = maskBytes[x >> 3];
    1:             PRBool maskBit = (maskByte & (1 << (x & 7))) != 0;
    1: 
    1:             if (maskBit != newBit) {
    1:                 return PR_TRUE;
    1:             }
    1:         }
    1:         aAlphas += aStride;
    1:     }
    1: 
    1:     return PR_FALSE;
    1: }
    1: 
    1: static
    1: void UpdateMaskBits(gchar* aMaskBits, PRInt32 aMaskWidth, PRInt32 aMaskHeight,
23738:         const nsIntRect& aRect, PRUint8* aAlphas, PRInt32 aStride)
    1: {
    1:     PRInt32 x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
    1:     PRInt32 maskBytesPerRow = (aMaskWidth + 7)/8;
    1:     for (y = aRect.y; y < yMax; y++) {
    1:         gchar* maskBytes = aMaskBits + y*maskBytesPerRow;
    1:         PRUint8* alphas = aAlphas;
    1:         for (x = aRect.x; x < xMax; x++) {
    1:             PRBool newBit = *alphas > 0;
    1:             alphas++;
    1: 
    1:             gchar mask = 1 << (x & 7);
    1:             gchar maskByte = maskBytes[x >> 3];
    1:             // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
    1:             maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
    1:         }
    1:         aAlphas += aStride;
    1:     }
    1: }
    1: 
    1: void
    1: nsWindow::ApplyTransparencyBitmap()
    1: {
    1:     gtk_widget_reset_shapes(mShell);
    1:     GdkBitmap* maskBitmap = gdk_bitmap_create_from_data(mShell->window,
    1:             mTransparencyBitmap,
    1:             mTransparencyBitmapWidth, mTransparencyBitmapHeight);
    1:     if (!maskBitmap)
    1:         return;
    1: 
    1:     gtk_widget_shape_combine_mask(mShell, maskBitmap, 0, 0);
24530:     g_object_unref(maskBitmap);
    1: }
    1: 
    1: nsresult
23738: nsWindow::UpdateTranslucentWindowAlphaInternal(const nsIntRect& aRect,
    1:                                                PRUint8* aAlphas, PRInt32 aStride)
    1: {
    1:     if (!mShell) {
    1:         // Pass the request to the toplevel window
    1:         GtkWidget *topWidget = nsnull;
    1:         GetToplevelWidget(&topWidget);
    1:         if (!topWidget)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
    1:         if (!topWindow)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas, aStride);
    1:     }
    1: 
 9499:     NS_ASSERTION(mIsTransparent, "Window is not transparent");
    1: 
    1:     if (mTransparencyBitmap == nsnull) {
    1:         PRInt32 size = ((mBounds.width+7)/8)*mBounds.height;
    1:         mTransparencyBitmap = new gchar[size];
    1:         if (mTransparencyBitmap == nsnull)
    1:             return NS_ERROR_FAILURE;
    1:         memset(mTransparencyBitmap, 255, size);
    1:         mTransparencyBitmapWidth = mBounds.width;
    1:         mTransparencyBitmapHeight = mBounds.height;
    1:     }
    1: 
    1:     NS_ASSERTION(aRect.x >= 0 && aRect.y >= 0
    1:             && aRect.XMost() <= mBounds.width && aRect.YMost() <= mBounds.height,
    1:             "Rect is out of window bounds");
    1: 
    1:     if (!ChangedMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height,
    1:                          aRect, aAlphas, aStride))
    1:         // skip the expensive stuff if the mask bits haven't changed; hopefully
    1:         // this is the common case
    1:         return NS_OK;
    1: 
    1:     UpdateMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height,
    1:                    aRect, aAlphas, aStride);
    1: 
    1:     if (!mNeedsShow) {
    1:         ApplyTransparencyBitmap();
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsWindow::GrabPointer(void)
    1: {
    1:     LOG(("GrabPointer %d\n", mRetryPointerGrab));
    1: 
    1:     mRetryPointerGrab = PR_FALSE;
    1: 
    1:     // If the window isn't visible, just set the flag to retry the
    1:     // grab.  When this window becomes visible, the grab will be
    1:     // retried.
34456:     if (!mHasMappedToplevel || mIsFullyObscured) {
    1:         LOG(("GrabPointer: window not visible\n"));
    1:         mRetryPointerGrab = PR_TRUE;
    1:         return;
    1:     }
    1: 
30704:     if (!mGdkWindow)
    1:         return;
    1: 
    1:     gint retval;
30704:     retval = gdk_pointer_grab(mGdkWindow, TRUE,
    1:                               (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
    1:                                              GDK_BUTTON_RELEASE_MASK |
    1:                                              GDK_ENTER_NOTIFY_MASK |
    1:                                              GDK_LEAVE_NOTIFY_MASK |
21947: #ifdef HAVE_GTK_MOTION_HINTS
21947:                                              GDK_POINTER_MOTION_HINT_MASK |
21947: #endif
21586:                                              GDK_POINTER_MOTION_MASK),
    1:                               (GdkWindow *)NULL, NULL, GDK_CURRENT_TIME);
    1: 
    1:     if (retval != GDK_GRAB_SUCCESS) {
    1:         LOG(("GrabPointer: pointer grab failed\n"));
    1:         mRetryPointerGrab = PR_TRUE;
    1:     }
    1: }
    1: 
    1: void
62719: nsWindow::ReleaseGrabs(void)
62719: {
62719:     LOG(("ReleaseGrabs\n"));
62719: 
62719:     mRetryPointerGrab = PR_FALSE;
    1:     gdk_pointer_ungrab(GDK_CURRENT_TIME);
    1: }
    1: 
    1: void
    1: nsWindow::GetToplevelWidget(GtkWidget **aWidget)
    1: {
    1:     *aWidget = nsnull;
    1: 
    1:     if (mShell) {
    1:         *aWidget = mShell;
    1:         return;
    1:     }
    1: 
18490:     GtkWidget *widget = GetMozContainerWidget();
    1:     if (!widget)
    1:         return;
    1: 
    1:     *aWidget = gtk_widget_get_toplevel(widget);
    1: }
    1: 
18490: GtkWidget *
18490: nsWindow::GetMozContainerWidget()
18490: {
30704:     if (!mGdkWindow)
25258:         return NULL;
25258: 
18490:     GtkWidget *owningWidget =
30704:         get_gtk_widget_for_gdk_window(mGdkWindow);
18490:     return owningWidget;
18490: }
18490: 
25258: nsWindow *
25258: nsWindow::GetContainerWindow()
25258: {
18490:     GtkWidget *owningWidget = GetMozContainerWidget();
25258:     if (!owningWidget)
25258:         return nsnull;
25258: 
25258:     nsWindow *window = get_window_for_gtk_widget(owningWidget);
25258:     NS_ASSERTION(window, "No nsWindow for container widget");
25258:     return window;
    1: }
    1: 
    1: void
    1: nsWindow::SetUrgencyHint(GtkWidget *top_window, PRBool state)
    1: {
    1:     if (!top_window)
    1:         return;
    1: 
    1:     // Try to get a pointer to gdk_window_set_urgency_hint
    1:     PRLibrary* lib;
    1:     _gdk_window_set_urgency_hint_fn _gdk_window_set_urgency_hint = nsnull;
    1:     _gdk_window_set_urgency_hint = (_gdk_window_set_urgency_hint_fn)
    1:            PR_FindFunctionSymbolAndLibrary("gdk_window_set_urgency_hint", &lib);
    1: 
    1:     if (_gdk_window_set_urgency_hint) {
    1:         _gdk_window_set_urgency_hint(top_window->window, state);
    1:         PR_UnloadLibrary(lib);
    1:     }
    1:     else if (state) {
    1:         gdk_window_show_unraised(top_window->window);
    1:     }
    1: }
    1: 
    1: void *
    1: nsWindow::SetupPluginPort(void)
    1: {
30704:     if (!mGdkWindow)
    1:         return nsnull;
    1: 
30704:     if (GDK_WINDOW_OBJECT(mGdkWindow)->destroyed == TRUE)
    1:         return nsnull;
    1: 
    1:     // we have to flush the X queue here so that any plugins that
    1:     // might be running on separate X connections will be able to use
    1:     // this window in case it was just created
16529: #ifdef MOZ_X11
    1:     XWindowAttributes xattrs;
30704:     XGetWindowAttributes(GDK_DISPLAY(), GDK_WINDOW_XWINDOW(mGdkWindow),
    1:                          &xattrs);
    1:     XSelectInput (GDK_DISPLAY (),
30704:                   GDK_WINDOW_XWINDOW(mGdkWindow),
    1:                   xattrs.your_event_mask |
    1:                   SubstructureNotifyMask);
    1: 
30704:     gdk_window_add_filter(mGdkWindow, plugin_window_filter_func, this);
    1: 
    1:     XSync(GDK_DISPLAY(), False);
16529: #endif /* MOZ_X11 */
    1: 
30704:     return (void *)GDK_WINDOW_XWINDOW(mGdkWindow);
    1: }
    1: 
    1: nsresult
24031: nsWindow::SetWindowIconList(const nsTArray<nsCString> &aIconList)
    1: {
    1:     GList *list = NULL;
    1: 
24031:     for (PRUint32 i = 0; i < aIconList.Length(); ++i) {
24031:         const char *path = aIconList[i].get();
    1:         LOG(("window [%p] Loading icon from %s\n", (void *)this, path));
    1: 
    1:         GdkPixbuf *icon = gdk_pixbuf_new_from_file(path, NULL);
    1:         if (!icon)
    1:             continue;
    1: 
    1:         list = g_list_append(list, icon);
    1:     }
    1: 
    1:     if (!list)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     gtk_window_set_icon_list(GTK_WINDOW(mShell), list);
    1: 
    1:     g_list_foreach(list, (GFunc) g_object_unref, NULL);
    1:     g_list_free(list);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsWindow::SetDefaultIcon(void)
    1: {
10124:     SetIcon(NS_LITERAL_STRING("default"));
    1: }
    1: 
    1: void
    1: nsWindow::SetPluginType(PluginType aPluginType)
    1: {
    1:     mPluginType = aPluginType;
    1: }
    1: 
16529: #ifdef MOZ_X11
    1: void
    1: nsWindow::SetNonXEmbedPluginFocus()
    1: {
    1:     if (gPluginFocusWindow == this || mPluginType!=PluginType_NONXEMBED) {
    1:         return;
    1:     }
    1: 
    1:     if (gPluginFocusWindow) {
  920:         nsRefPtr<nsWindow> kungFuDeathGrip = gPluginFocusWindow;
    1:         gPluginFocusWindow->LoseNonXEmbedPluginFocus();
    1:     }
    1: 
    1:     LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus\n"));
    1: 
    1:     Window curFocusWindow;
    1:     int focusState;
    1: 
30704:     XGetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
    1:                    &curFocusWindow,
    1:                    &focusState);
    1: 
    1:     LOGFOCUS(("\t curFocusWindow=%p\n", curFocusWindow));
    1: 
30704:     GdkWindow* toplevel = gdk_window_get_toplevel(mGdkWindow);
    1:     GdkWindow *gdkfocuswin = gdk_window_lookup(curFocusWindow);
    1: 
    1:     // lookup with the focus proxy window is supposed to get the
    1:     // same GdkWindow as toplevel. If the current focused window
    1:     // is not the focus proxy, we return without any change.
    1:     if (gdkfocuswin != toplevel) {
    1:         return;
    1:     }
    1: 
    1:     // switch the focus from the focus proxy to the plugin window
    1:     mOldFocusWindow = curFocusWindow;
30704:     XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
30704:                  GDK_WINDOW_XWINDOW(mGdkWindow));
    1:     gdk_error_trap_push();
30704:     XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
30704:                    GDK_WINDOW_XWINDOW(mGdkWindow),
    1:                    RevertToNone,
    1:                    CurrentTime);
    1:     gdk_flush();
    1:     gdk_error_trap_pop();
    1:     gPluginFocusWindow = this;
    1:     gdk_window_add_filter(NULL, plugin_client_message_filter, this);
    1: 
    1:     LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus oldfocus=%p new=%p\n",
30704:               mOldFocusWindow, GDK_WINDOW_XWINDOW(mGdkWindow)));
    1: }
    1: 
    1: void
    1: nsWindow::LoseNonXEmbedPluginFocus()
    1: {
    1:     LOGFOCUS(("nsWindow::LoseNonXEmbedPluginFocus\n"));
    1: 
    1:     // This method is only for the nsWindow which contains a
    1:     // Non-XEmbed plugin, for example, JAVA plugin.
    1:     if (gPluginFocusWindow != this || mPluginType!=PluginType_NONXEMBED) {
    1:         return;
    1:     }
    1: 
    1:     Window curFocusWindow;
    1:     int focusState;
    1: 
30704:     XGetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
    1:                    &curFocusWindow,
    1:                    &focusState);
    1: 
    1:     // we only switch focus between plugin window and focus proxy. If the
    1:     // current focused window is not the plugin window, just removing the
    1:     // event filter that blocks the WM_TAKE_FOCUS is enough. WM and gtk2
    1:     // will take care of the focus later.
    1:     if (!curFocusWindow ||
30704:         curFocusWindow == GDK_WINDOW_XWINDOW(mGdkWindow)) {
    1: 
    1:         gdk_error_trap_push();
30704:         XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
    1:                      mOldFocusWindow);
30704:         XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
    1:                        mOldFocusWindow,
    1:                        RevertToParent,
    1:                        CurrentTime);
    1:         gdk_flush();
    1:         gdk_error_trap_pop();
    1:     }
    1:     gPluginFocusWindow = NULL;
    1:     mOldFocusWindow = 0;
    1:     gdk_window_remove_filter(NULL, plugin_client_message_filter, this);
    1: 
    1:     LOGFOCUS(("nsWindow::LoseNonXEmbedPluginFocus end\n"));
    1: }
16529: #endif /* MOZ_X11 */
    1: 
    1: 
    1: gint
    1: nsWindow::ConvertBorderStyles(nsBorderStyle aStyle)
    1: {
    1:     gint w = 0;
    1: 
    1:     if (aStyle == eBorderStyle_default)
    1:         return -1;
    1: 
48256:     // note that we don't handle eBorderStyle_close yet
    1:     if (aStyle & eBorderStyle_all)
    1:         w |= GDK_DECOR_ALL;
    1:     if (aStyle & eBorderStyle_border)
    1:         w |= GDK_DECOR_BORDER;
    1:     if (aStyle & eBorderStyle_resizeh)
    1:         w |= GDK_DECOR_RESIZEH;
    1:     if (aStyle & eBorderStyle_title)
    1:         w |= GDK_DECOR_TITLE;
    1:     if (aStyle & eBorderStyle_menu)
    1:         w |= GDK_DECOR_MENU;
    1:     if (aStyle & eBorderStyle_minimize)
    1:         w |= GDK_DECOR_MINIMIZE;
    1:     if (aStyle & eBorderStyle_maximize)
    1:         w |= GDK_DECOR_MAXIMIZE;
    1: 
    1:     return w;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::MakeFullScreen(PRBool aFullScreen)
    1: {
31567:     LOG(("nsWindow::MakeFullScreen [%p] aFullScreen %d\n",
31567:          (void *)this, aFullScreen));
31567: 
31567:     if (aFullScreen) {
32018:         if (mSizeMode != nsSizeMode_Fullscreen)
32018:             mLastSizeMode = mSizeMode;
32018: 
31567:         mSizeMode = nsSizeMode_Fullscreen;
34744:         gtk_window_fullscreen(GTK_WINDOW(mShell));
31567:     }
32018:     else {
32018:         mSizeMode = mLastSizeMode;
34744:         gtk_window_unfullscreen(GTK_WINDOW(mShell));
32018:     }
32018: 
32018:     NS_ASSERTION(mLastSizeMode != nsSizeMode_Fullscreen,
32018:                  "mLastSizeMode should never be fullscreen");
 9857:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::HideWindowChrome(PRBool aShouldHide)
    1: {
    1:     if (!mShell) {
    1:         // Pass the request to the toplevel window
    1:         GtkWidget *topWidget = nsnull;
    1:         GetToplevelWidget(&topWidget);
25258:         if (!topWidget)
25258:             return NS_ERROR_FAILURE;
25258: 
    1:         nsWindow *topWindow = get_window_for_gtk_widget(topWidget);
25258:         if (!topWindow)
25258:             return NS_ERROR_FAILURE;
25258: 
    1:         return topWindow->HideWindowChrome(aShouldHide);
    1:     }
    1: 
    1:     // Sawfish, metacity, and presumably other window managers get
    1:     // confused if we change the window decorations while the window
    1:     // is visible.
10249:     PRBool wasVisible = PR_FALSE;
10249:     if (gdk_window_is_visible(mShell->window)) {
    1:         gdk_window_hide(mShell->window);
10249:         wasVisible = PR_TRUE;
10249:     }
    1: 
    1:     gint wmd;
    1:     if (aShouldHide)
    1:         wmd = 0;
    1:     else
    1:         wmd = ConvertBorderStyles(mBorderStyle);
    1: 
48256:     if (wmd != -1)
    1:       gdk_window_set_decorations(mShell->window, (GdkWMDecoration) wmd);
    1: 
10249:     if (wasVisible)
    1:         gdk_window_show(mShell->window);
    1: 
    1:     // For some window managers, adding or removing window decorations
    1:     // requires unmapping and remapping our toplevel window.  Go ahead
    1:     // and flush the queue here so that we don't end up with a BadWindow
    1:     // error later when this happens (when the persistence timer fires
    1:     // and GetWindowPos is called)
16529: #ifdef MOZ_X11
    1:     XSync(GDK_DISPLAY(), False);
16529: #else
16529:     gdk_flush ();
16529: #endif /* MOZ_X11 */
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: PRBool
    1: check_for_rollup(GdkWindow *aWindow, gdouble aMouseX, gdouble aMouseY,
54150:                  PRBool aIsWheel, PRBool aAlwaysRollup)
    1: {
    1:     PRBool retVal = PR_FALSE;
    1:     nsCOMPtr<nsIWidget> rollupWidget = do_QueryReferent(gRollupWindow);
    1: 
    1:     if (rollupWidget && gRollupListener) {
    1:         GdkWindow *currentPopup =
    1:             (GdkWindow *)rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
54150:         if (aAlwaysRollup || !is_mouse_in_window(currentPopup, aMouseX, aMouseY)) {
    1:             PRBool rollup = PR_TRUE;
    1:             if (aIsWheel) {
    1:                 gRollupListener->ShouldRollupOnMouseWheelEvent(&rollup);
    1:                 retVal = PR_TRUE;
    1:             }
    1:             // if we're dealing with menus, we probably have submenus and
    1:             // we don't want to rollup if the click is in a parent menu of
    1:             // the current submenu
29148:             PRUint32 popupsToRollup = PR_UINT32_MAX;
54150:             if (gMenuRollup && !aAlwaysRollup) {
10352:                 nsAutoTArray<nsIWidget*, 5> widgetChain;
36806:                 PRUint32 sameTypeCount = gMenuRollup->GetSubmenuWidgetChain(&widgetChain);
10352:                 for (PRUint32 i=0; i<widgetChain.Length(); ++i) {
10352:                     nsIWidget* widget = widgetChain[i];
    1:                     GdkWindow* currWindow =
    1:                         (GdkWindow*) widget->GetNativeData(NS_NATIVE_WINDOW);
    1:                     if (is_mouse_in_window(currWindow, aMouseX, aMouseY)) {
42263:                       // don't roll up if the mouse event occurred within a
42263:                       // menu of the same type. If the mouse event occurred
29148:                       // in a menu higher than that, roll up, but pass the
29148:                       // number of popups to Rollup so that only those of the
29148:                       // same type close up.
29148:                       if (i < sameTypeCount) {
    1:                         rollup = PR_FALSE;
29148:                       }
29148:                       else {
29148:                         popupsToRollup = sameTypeCount;
29148:                       }
    1:                       break;
    1:                     }
    1:                 } // foreach parent menu widget
    1:             } // if rollup listener knows about menus
    1: 
    1:             // if we've determined that we should still rollup, do it.
    1:             if (rollup) {
29148:                 gRollupListener->Rollup(popupsToRollup, nsnull);
29148:                 if (popupsToRollup == PR_UINT32_MAX) {
    1:                     retVal = PR_TRUE;
    1:                 }
    1:             }
29148:         }
    1:     } else {
    1:         gRollupWindow = nsnull;
    1:         gRollupListener = nsnull;
36806:         NS_IF_RELEASE(gMenuRollup);
    1:     }
    1: 
    1:     return retVal;
    1: }
    1: 
    1: /* static */
    1: PRBool
    1: nsWindow::DragInProgress(void)
    1: {
61355:     // sLastDragMotionWindow means the drag arrow is over mozilla
    1:     // sIsDraggingOutOf means the drag arrow is out of mozilla
    1:     // both cases mean the dragging is happenning.
61355:     return (sLastDragMotionWindow || sIsDraggingOutOf);
    1: }
    1: 
    1: /* static */
    1: PRBool
    1: is_mouse_in_window (GdkWindow* aWindow, gdouble aMouseX, gdouble aMouseY)
    1: {
    1:     gint x = 0;
    1:     gint y = 0;
    1:     gint w, h;
    1: 
    1:     gint offsetX = 0;
    1:     gint offsetY = 0;
    1: 
25258:     GdkWindow *window = aWindow;
    1: 
    1:     while (window) {
    1:         gint tmpX = 0;
    1:         gint tmpY = 0;
    1: 
    1:         gdk_window_get_position(window, &tmpX, &tmpY);
25258:         GtkWidget *widget = get_gtk_widget_for_gdk_window(window);
    1: 
    1:         // if this is a window, compute x and y given its origin and our
    1:         // offset
    1:         if (GTK_IS_WINDOW(widget)) {
    1:             x = tmpX + offsetX;
    1:             y = tmpY + offsetY;
    1:             break;
    1:         }
    1: 
    1:         offsetX += tmpX;
    1:         offsetY += tmpY;
    1:         window = gdk_window_get_parent(window);
    1:     }
    1: 
24530:     gdk_drawable_get_size(aWindow, &w, &h);
    1: 
    1:     if (aMouseX > x && aMouseX < x + w &&
    1:         aMouseY > y && aMouseY < y + h)
    1:         return PR_TRUE;
    1: 
    1:     return PR_FALSE;
    1: }
    1: 
    1: /* static */
    1: nsWindow *
    1: get_window_for_gtk_widget(GtkWidget *widget)
    1: {
25258:     gpointer user_data = g_object_get_data(G_OBJECT(widget), "nsWindow");
    1: 
 3233:     return static_cast<nsWindow *>(user_data);
    1: }
    1: 
    1: /* static */
    1: nsWindow *
    1: get_window_for_gdk_window(GdkWindow *window)
    1: {
25258:     gpointer user_data = g_object_get_data(G_OBJECT(window), "nsWindow");
    1: 
 3233:     return static_cast<nsWindow *>(user_data);
    1: }
    1: 
    1: /* static */
    1: GtkWidget *
    1: get_gtk_widget_for_gdk_window(GdkWindow *window)
    1: {
    1:     gpointer user_data = NULL;
    1:     gdk_window_get_user_data(window, &user_data);
    1: 
    1:     return GTK_WIDGET(user_data);
    1: }
    1: 
    1: /* static */
    1: GdkCursor *
    1: get_gtk_cursor(nsCursor aCursor)
    1: {
    1:     GdkPixmap *cursor;
    1:     GdkPixmap *mask;
    1:     GdkColor fg, bg;
    1:     GdkCursor *gdkcursor = nsnull;
    1:     PRUint8 newType = 0xff;
    1: 
    1:     if ((gdkcursor = gCursorCache[aCursor])) {
    1:         return gdkcursor;
    1:     }
    1: 
    1:     switch (aCursor) {
    1:     case eCursor_standard:
    1:         gdkcursor = gdk_cursor_new(GDK_LEFT_PTR);
    1:         break;
    1:     case eCursor_wait:
    1:         gdkcursor = gdk_cursor_new(GDK_WATCH);
    1:         break;
    1:     case eCursor_select:
    1:         gdkcursor = gdk_cursor_new(GDK_XTERM);
    1:         break;
    1:     case eCursor_hyperlink:
    1:         gdkcursor = gdk_cursor_new(GDK_HAND2);
    1:         break;
    1:     case eCursor_n_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_TOP_SIDE);
    1:         break;
    1:     case eCursor_s_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_SIDE);
    1:         break;
    1:     case eCursor_w_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_LEFT_SIDE);
    1:         break;
    1:     case eCursor_e_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_RIGHT_SIDE);
    1:         break;
    1:     case eCursor_nw_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_TOP_LEFT_CORNER);
    1:         break;
    1:     case eCursor_se_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_RIGHT_CORNER);
    1:         break;
    1:     case eCursor_ne_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_TOP_RIGHT_CORNER);
    1:         break;
    1:     case eCursor_sw_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_BOTTOM_LEFT_CORNER);
    1:         break;
    1:     case eCursor_crosshair:
    1:         gdkcursor = gdk_cursor_new(GDK_CROSSHAIR);
    1:         break;
    1:     case eCursor_move:
    1:         gdkcursor = gdk_cursor_new(GDK_FLEUR);
    1:         break;
    1:     case eCursor_help:
 5988:         gdkcursor = gdk_cursor_new(GDK_QUESTION_ARROW);
    1:         break;
    1:     case eCursor_copy: // CSS3
    1:         newType = MOZ_CURSOR_COPY;
    1:         break;
    1:     case eCursor_alias:
    1:         newType = MOZ_CURSOR_ALIAS;
    1:         break;
    1:     case eCursor_context_menu:
    1:         newType = MOZ_CURSOR_CONTEXT_MENU;
    1:         break;
    1:     case eCursor_cell:
    1:         gdkcursor = gdk_cursor_new(GDK_PLUS);
    1:         break;
    1:     case eCursor_grab:
    1:         newType = MOZ_CURSOR_HAND_GRAB;
    1:         break;
    1:     case eCursor_grabbing:
    1:         newType = MOZ_CURSOR_HAND_GRABBING;
    1:         break;
    1:     case eCursor_spinning:
    1:         newType = MOZ_CURSOR_SPINNING;
    1:         break;
    1:     case eCursor_zoom_in:
    1:         newType = MOZ_CURSOR_ZOOM_IN;
    1:         break;
    1:     case eCursor_zoom_out:
    1:         newType = MOZ_CURSOR_ZOOM_OUT;
    1:         break;
    1:     case eCursor_not_allowed:
    1:     case eCursor_no_drop:
    1:         newType = MOZ_CURSOR_NOT_ALLOWED;
    1:         break;
    1:     case eCursor_vertical_text:
    1:         newType = MOZ_CURSOR_VERTICAL_TEXT;
    1:         break;
    1:     case eCursor_all_scroll:
    1:         gdkcursor = gdk_cursor_new(GDK_FLEUR);
    1:         break;
    1:     case eCursor_nesw_resize:
    1:         newType = MOZ_CURSOR_NESW_RESIZE;
    1:         break;
    1:     case eCursor_nwse_resize:
    1:         newType = MOZ_CURSOR_NWSE_RESIZE;
    1:         break;
    1:     case eCursor_ns_resize:
29997:     case eCursor_row_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_SB_V_DOUBLE_ARROW);
    1:         break;
    1:     case eCursor_ew_resize:
29997:     case eCursor_col_resize:
    1:         gdkcursor = gdk_cursor_new(GDK_SB_H_DOUBLE_ARROW);
    1:         break;
10405:     case eCursor_none:
10405:         newType = MOZ_CURSOR_NONE;
10405:         break;
    1:     default:
    1:         NS_ASSERTION(aCursor, "Invalid cursor type");
    1:         gdkcursor = gdk_cursor_new(GDK_LEFT_PTR);
    1:         break;
    1:     }
    1: 
    1:     // if by now we don't have a xcursor, this means we have to make a
    1:     // custom one
    1:     if (newType != 0xff) {
    1:         gdk_color_parse("#000000", &fg);
    1:         gdk_color_parse("#ffffff", &bg);
    1: 
    1:         cursor = gdk_bitmap_create_from_data(NULL,
    1:                                              (char *)GtkCursors[newType].bits,
    1:                                              32, 32);
 6790:         if (!cursor)
 6790:             return NULL;
 6790: 
    1:         mask =
    1:             gdk_bitmap_create_from_data(NULL,
    1:                                         (char *)GtkCursors[newType].mask_bits,
    1:                                         32, 32);
 6790:         if (!mask) {
24530:             g_object_unref(cursor);
 6790:             return NULL;
 6790:         }
    1: 
    1:         gdkcursor = gdk_cursor_new_from_pixmap(cursor, mask, &fg, &bg,
    1:                                                GtkCursors[newType].hot_x,
    1:                                                GtkCursors[newType].hot_y);
    1: 
24530:         g_object_unref(mask);
24530:         g_object_unref(cursor);
    1:     }
    1: 
    1:     gCursorCache[aCursor] = gdkcursor;
    1: 
    1:     return gdkcursor;
    1: }
    1: 
    1: // gtk callbacks
    1: 
    1: /* static */
    1: gboolean
    1: expose_event_cb(GtkWidget *widget, GdkEventExpose *event)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     // XXX We are so getting lucky here.  We are doing all of
    1:     // mozilla's painting and then allowing default processing to occur.
    1:     // This means that Mozilla paints in all of it's stuff and then
    1:     // NO_WINDOW widgets (like scrollbars, for example) are painted by
    1:     // Gtk on top of what we painted.
    1: 
    1:     // This return window->OnExposeEvent(widget, event); */
    1: 
    1:     window->OnExposeEvent(widget, event);
    1:     return FALSE;
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: configure_event_cb(GtkWidget *widget,
    1:                    GdkEventConfigure *event)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     return window->OnConfigureEvent(widget, event);
    1: }
    1: 
    1: /* static */
    1: void
28365: container_unrealize_cb (GtkWidget *widget)
28365: {
28365:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
28365:     if (!window)
28365:         return;
28365: 
28365:     window->OnContainerUnrealize(widget);
28365: }
28365: 
28365: /* static */
28365: void
    1: size_allocate_cb (GtkWidget *widget, GtkAllocation *allocation)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
    1:     if (!window)
    1:         return;
    1: 
    1:     window->OnSizeAllocate(widget, allocation);
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: delete_event_cb(GtkWidget *widget, GdkEventAny *event)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     window->OnDeleteEvent(widget, event);
    1: 
    1:     return TRUE;
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: enter_notify_event_cb(GtkWidget *widget,
    1:                       GdkEventCrossing *event)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
    1:     if (!window)
    1:         return TRUE;
    1: 
    1:     window->OnEnterNotifyEvent(widget, event);
    1: 
    1:     return TRUE;
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: leave_notify_event_cb(GtkWidget *widget,
    1:                       GdkEventCrossing *event)
    1: {
    1:     if (is_parent_grab_leave(event)) {
    1:         return TRUE;
    1:     }
    1: 
 9467:     // bug 369599: Suppress LeaveNotify events caused by pointer grabs to
 9467:     // avoid generating spurious mouse exit events.
 9467:     gint x = gint(event->x_root);
 9467:     gint y = gint(event->y_root);
 9467:     GdkDisplay* display = gtk_widget_get_display(widget);
 9467:     GdkWindow* winAtPt = gdk_display_get_window_at_pointer(display, &x, &y);
 9467:     if (winAtPt == event->window) {
 9467:         return TRUE;
 9467:     }
 9467: 
  920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
    1:     if (!window)
    1:         return TRUE;
    1: 
    1:     window->OnLeaveNotifyEvent(widget, event);
    1: 
    1:     return TRUE;
    1: }
    1: 
 9049: nsWindow*
 9049: GetFirstNSWindowForGDKWindow(GdkWindow *aGdkWindow)
 9049: {
 9049:     nsWindow* window;
 9049:     while (!(window = get_window_for_gdk_window(aGdkWindow))) {
 9049:         // The event has bubbled to the moz_container widget as passed into each caller's *widget parameter,
 9049:         // but its corresponding nsWindow is an ancestor of the window that we need.  Instead, look at
 9049:         // event->window and find the first ancestor nsWindow of it because event->window may be in a plugin.
 9049:         aGdkWindow = gdk_window_get_parent(aGdkWindow);
 9049:         if (!aGdkWindow) {
 9049:             window = nsnull;
 9049:             break;
 9049:         }
 9049:     }
 9049:     return window;
 9049: }
 9049: 
    1: /* static */
    1: gboolean
    1: motion_notify_event_cb(GtkWidget *widget, GdkEventMotion *event)
    1: {
33517:     UpdateLastInputEventTime();
32815: 
 9049:     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
    1:     if (!window)
 9049:         return FALSE;
    1: 
    1:     window->OnMotionNotifyEvent(widget, event);
    1: 
21947: #ifdef HAVE_GTK_MOTION_HINTS
21947:     gdk_event_request_motions(event);
21947: #endif
    1:     return TRUE;
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: button_press_event_cb(GtkWidget *widget, GdkEventButton *event)
    1: {
33517:     UpdateLastInputEventTime();
32815: 
 9049:     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
    1:     if (!window)
 9049:         return FALSE;
    1: 
    1:     window->OnButtonPressEvent(widget, event);
    1: 
    1:     return TRUE;
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: button_release_event_cb(GtkWidget *widget, GdkEventButton *event)
    1: {
33517:     UpdateLastInputEventTime();
32815: 
 9049:     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
    1:     if (!window)
 9049:         return FALSE;
    1: 
    1:     window->OnButtonReleaseEvent(widget, event);
    1: 
    1:     return TRUE;
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: focus_in_event_cb(GtkWidget *widget, GdkEventFocus *event)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     window->OnContainerFocusInEvent(widget, event);
    1: 
    1:     return FALSE;
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: focus_out_event_cb(GtkWidget *widget, GdkEventFocus *event)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     window->OnContainerFocusOutEvent(widget, event);
    1: 
    1:     return FALSE;
    1: }
    1: 
16529: #ifdef MOZ_X11
43761: // For long-lived popup windows that don't really take focus themselves but
43761: // may have elements that accept keyboard input when the parent window is
43761: // active, focus is handled specially.  These windows include noautohide
43761: // panels.  (This special handling is not necessary for temporary popups where
43761: // the keyboard is grabbed.)
43761: //
43761: // Mousing over or clicking on these windows should not cause them to steal
43761: // focus from their parent windows, so, the input field of WM_HINTS is set to
43761: // False to request that the window manager not set the input focus to this
43761: // window.  http://tronche.com/gui/x/icccm/sec-4.html#s-4.1.7
43761: //
43761: // However, these windows can still receive WM_TAKE_FOCUS messages from the
43761: // window manager, so they can still detect when the user has indicated that
43761: // they wish to direct keyboard input at these windows.  When the window
43761: // manager offers focus to these windows (after a mouse over or click, for
43761: // example), a request to make the parent window active is issued.  When the
43761: // parent window becomes active, keyboard events will be received.
43761: 
43761: GdkFilterReturn
43761: popup_take_focus_filter(GdkXEvent *gdk_xevent,
43761:                         GdkEvent *event,
43761:                         gpointer data)
43761: {
43761:     XEvent* xevent = static_cast<XEvent*>(gdk_xevent);
43761:     if (xevent->type != ClientMessage)
43761:         return GDK_FILTER_CONTINUE;
43761: 
43761:     XClientMessageEvent& xclient = xevent->xclient;
43761:     if (xclient.message_type != gdk_x11_get_xatom_by_name("WM_PROTOCOLS"))
43761:         return GDK_FILTER_CONTINUE;
43761: 
43761:     Atom atom = xclient.data.l[0];
43761:     if (atom != gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS"))
43761:         return GDK_FILTER_CONTINUE;
43761: 
43761:     guint32 timestamp = xclient.data.l[1];
43761: 
43761:     GtkWidget* widget = get_gtk_widget_for_gdk_window(event->any.window);
43761:     if (!widget)
43761:         return GDK_FILTER_CONTINUE;
43761: 
43761:     GtkWindow* parent = gtk_window_get_transient_for(GTK_WINDOW(widget));
43761:     if (!parent)
43761:         return GDK_FILTER_CONTINUE;
43761: 
43761:     if (gtk_window_is_active(parent))
43761:         return GDK_FILTER_REMOVE; // leave input focus on the parent
43761: 
43761:     GdkWindow* parent_window = GTK_WIDGET(parent)->window;
43761:     if (!parent_window)
43761:         return GDK_FILTER_CONTINUE;
43761: 
43761:     // In case the parent has not been deconified.
43761:     gdk_window_show_unraised(parent_window);
43761: 
43761:     // Request focus on the parent window.
43761:     // Use gdk_window_focus rather than gtk_window_present to avoid
43761:     // raising the parent window.
43761:     gdk_window_focus(parent_window, timestamp);
43761:     return GDK_FILTER_REMOVE;
43761: }
43761: 
    1: /* static */
    1: GdkFilterReturn
    1: plugin_window_filter_func(GdkXEvent *gdk_xevent, GdkEvent *event, gpointer data)
    1: {
    1:     GdkWindow *plugin_window;
    1:     XEvent    *xevent;
    1: 
  920:     nsRefPtr<nsWindow> nswindow = (nsWindow*)data;
    1:     GdkFilterReturn return_val;
    1: 
    1:     xevent = (XEvent *)gdk_xevent;
    1:     return_val = GDK_FILTER_CONTINUE;
    1: 
    1:     switch (xevent->type)
    1:     {
    1:         case CreateNotify:
    1:         case ReparentNotify:
    1:             if (xevent->type==CreateNotify) {
    1:                 plugin_window = gdk_window_lookup(xevent->xcreatewindow.window);
    1:             }
    1:             else {
    1:                 if (xevent->xreparent.event != xevent->xreparent.parent)
    1:                     break;
    1:                 plugin_window = gdk_window_lookup (xevent->xreparent.window);
    1:             }
    1:             if (plugin_window) {
25258:                 GtkWidget *widget =
25258:                     get_gtk_widget_for_gdk_window(plugin_window);
    1: 
    1:                 if (GTK_IS_XTBIN(widget)) {
    1:                     nswindow->SetPluginType(nsWindow::PluginType_NONXEMBED);
    1:                     break;
    1:                 }
    1:                 else if(GTK_IS_SOCKET(widget)) {
    1:                     nswindow->SetPluginType(nsWindow::PluginType_XEMBED);
    1:                     break;
    1:                 }
    1:             }
    1:             nswindow->SetPluginType(nsWindow::PluginType_NONXEMBED);
    1:             return_val = GDK_FILTER_REMOVE;
    1:             break;
    1:         case EnterNotify:
    1:             nswindow->SetNonXEmbedPluginFocus();
    1:             break;
    1:         case DestroyNotify:
    1:             gdk_window_remove_filter
    1:                 ((GdkWindow*)(nswindow->GetNativeData(NS_NATIVE_WINDOW)),
    1:                  plugin_window_filter_func,
    1:                  nswindow);
    1:             // Currently we consider all plugins are non-xembed and calls
    1:             // LoseNonXEmbedPluginFocus without any checking.
    1:             nswindow->LoseNonXEmbedPluginFocus();
    1:             break;
    1:         default:
    1:             break;
    1:     }
    1:     return return_val;
    1: }
    1: 
    1: /* static */
    1: GdkFilterReturn
    1: plugin_client_message_filter(GdkXEvent *gdk_xevent,
    1:                              GdkEvent *event,
    1:                              gpointer data)
    1: {
    1:     XEvent    *xevent;
    1:     xevent = (XEvent *)gdk_xevent;
    1: 
    1:     GdkFilterReturn return_val;
    1:     return_val = GDK_FILTER_CONTINUE;
    1: 
    1:     if (!gPluginFocusWindow || xevent->type!=ClientMessage) {
    1:         return return_val;
    1:     }
    1: 
    1:     // When WM sends out WM_TAKE_FOCUS, gtk2 will use XSetInputFocus
    1:     // to set the focus to the focus proxy. To prevent this happen
    1:     // while the focus is on the plugin, we filter the WM_TAKE_FOCUS
    1:     // out.
    1:     if (gdk_x11_get_xatom_by_name("WM_PROTOCOLS")
    1:             != xevent->xclient.message_type) {
    1:         return return_val;
    1:     }
    1: 
    1:     if ((Atom) xevent->xclient.data.l[0] ==
    1:             gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS")) {
    1:         // block it from gtk2.0 focus proxy
    1:         return_val = GDK_FILTER_REMOVE;
    1:     }
    1: 
    1:     return return_val;
    1: }
16529: #endif /* MOZ_X11 */
    1: 
    1: /* static */
    1: gboolean
    1: key_press_event_cb(GtkWidget *widget, GdkEventKey *event)
    1: {
    1:     LOG(("key_press_event_cb\n"));
32815: 
33517:     UpdateLastInputEventTime();
32815: 
    1:     // find the window with focus and dispatch this event to that widget
    1:     nsWindow *window = get_window_for_gtk_widget(widget);
    1:     if (!window)
    1:         return FALSE;
    1: 
  920:     nsRefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
    1: 
22802: #ifdef MOZ_X11
22802:     // Keyboard repeat can cause key press events to queue up when there are
22802:     // slow event handlers (bug 301029).  Throttle these events by removing
22802:     // consecutive pending duplicate KeyPress events to the same window.
22802:     // We use the event time of the last one.
22802:     // Note: GDK calls XkbSetDetectableAutorepeat so that KeyRelease events
22802:     // are generated only when the key is physically released.
22802: #define NS_GDKEVENT_MATCH_MASK 0x1FFF /* GDK_SHIFT_MASK .. GDK_BUTTON5_MASK */
22802:     GdkDisplay* gdkDisplay = gtk_widget_get_display(widget);
22802:     Display* dpy = GDK_DISPLAY_XDISPLAY(gdkDisplay);
22802:     while (XPending(dpy)) {
22802:         XEvent next_event;
22802:         XPeekEvent(dpy, &next_event);
22802:         GdkWindow* nextGdkWindow =
22802:             gdk_window_lookup_for_display(gdkDisplay, next_event.xany.window);
22802:         if (nextGdkWindow != event->window ||
22802:             next_event.type != KeyPress ||
22802:             next_event.xkey.keycode != event->hardware_keycode ||
22802:             next_event.xkey.state != (event->state & NS_GDKEVENT_MATCH_MASK)) {
22802:             break;
22802:         }
22802:         XNextEvent(dpy, &next_event);
22802:         event->time = next_event.xkey.time;
22802:     }
22802: #endif
22802: 
14964:     return focusWindow->OnKeyPressEvent(widget, event);
    1: }
    1: 
    1: gboolean
    1: key_release_event_cb(GtkWidget *widget, GdkEventKey *event)
    1: {
    1:     LOG(("key_release_event_cb\n"));
32815: 
33517:     UpdateLastInputEventTime();
32815: 
    1:     // find the window with focus and dispatch this event to that widget
    1:     nsWindow *window = get_window_for_gtk_widget(widget);
    1:     if (!window)
    1:         return FALSE;
    1: 
  920:     nsRefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
    1: 
14964:     return focusWindow->OnKeyReleaseEvent(widget, event);
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: scroll_event_cb(GtkWidget *widget, GdkEventScroll *event)
    1: {
 9049:     nsWindow *window = GetFirstNSWindowForGDKWindow(event->window);
 9049:     if (!window)
    1:         return FALSE;
    1: 
    1:     window->OnScrollEvent(widget, event);
    1: 
    1:     return TRUE;
    1: }
    1: 
    1: /* static */
    1: gboolean
    1: visibility_notify_event_cb (GtkWidget *widget, GdkEventVisibility *event)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     window->OnVisibilityNotifyEvent(widget, event);
    1: 
    1:     return TRUE;
    1: }
    1: 
34456: static void
34456: hierarchy_changed_cb (GtkWidget *widget,
34456:                       GtkWidget *previous_toplevel)
34456: {
34456:     GtkWidget *toplevel = gtk_widget_get_toplevel(widget);
34456:     GdkWindowState old_window_state = GDK_WINDOW_STATE_WITHDRAWN;
34456:     GdkEventWindowState event;
34456: 
34456:     event.new_window_state = GDK_WINDOW_STATE_WITHDRAWN;
34456: 
34456:     if (GTK_IS_WINDOW(previous_toplevel)) {
34456:         g_signal_handlers_disconnect_by_func(previous_toplevel,
34456:                                              FuncToGpointer(window_state_event_cb),
34456:                                              widget);
35273:         if (previous_toplevel->window) {
35273:             old_window_state = gdk_window_get_state(previous_toplevel->window);
34456:         }
34456:     }
34456: 
34456:     if (GTK_IS_WINDOW(toplevel)) {
34456:         g_signal_connect_swapped(toplevel, "window-state-event",
34456:                                  G_CALLBACK(window_state_event_cb), widget);
35273:         if (toplevel->window) {
35273:             event.new_window_state = gdk_window_get_state(toplevel->window);
34456:         }
34456:     }
34456: 
34456:     event.changed_mask = static_cast<GdkWindowState>
34456:         (old_window_state ^ event.new_window_state);
34456: 
34456:     if (event.changed_mask) {
34456:         event.type = GDK_WINDOW_STATE;
34456:         event.window = NULL;
34456:         event.send_event = TRUE;
34456:         window_state_event_cb(widget, &event);
34456:     }
34456: }
34456: 
    1: /* static */
    1: gboolean
    1: window_state_event_cb (GtkWidget *widget, GdkEventWindowState *event)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     window->OnWindowStateEvent(widget, event);
    1: 
    1:     return FALSE;
    1: }
    1: 
    1: /* static */
    1: void
    1: theme_changed_cb (GtkSettings *settings, GParamSpec *pspec, nsWindow *data)
    1: {
  920:     nsRefPtr<nsWindow> window = data;
  920:     window->ThemeChanged();
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: // These are all of our drag and drop operations
    1: 
    1: void
18445: nsWindow::InitDragEvent(nsDragEvent &aEvent)
    1: {
    1:     // set the keyboard modifiers
    1:     gint x, y;
    1:     GdkModifierType state = (GdkModifierType)0;
    1:     gdk_window_get_pointer(NULL, &x, &y, &state);
    1:     aEvent.isShift = (state & GDK_SHIFT_MASK) ? PR_TRUE : PR_FALSE;
    1:     aEvent.isControl = (state & GDK_CONTROL_MASK) ? PR_TRUE : PR_FALSE;
    1:     aEvent.isAlt = (state & GDK_MOD1_MASK) ? PR_TRUE : PR_FALSE;
    1:     aEvent.isMeta = PR_FALSE; // GTK+ doesn't support the meta key
    1: }
    1: 
    1: // This will update the drag action based on the information in the
    1: // drag context.  Gtk gets this from a combination of the key settings
    1: // and what the source is offering.
    1: 
    1: void
37793: nsWindow::UpdateDragStatus(GdkDragContext *aDragContext,
    1:                            nsIDragService *aDragService)
    1: {
    1:     // default is to do nothing
    1:     int action = nsIDragService::DRAGDROP_ACTION_NONE;
    1: 
    1:     // set the default just in case nothing matches below
    1:     if (aDragContext->actions & GDK_ACTION_DEFAULT)
    1:         action = nsIDragService::DRAGDROP_ACTION_MOVE;
    1: 
    1:     // first check to see if move is set
    1:     if (aDragContext->actions & GDK_ACTION_MOVE)
    1:         action = nsIDragService::DRAGDROP_ACTION_MOVE;
    1: 
    1:     // then fall to the others
    1:     else if (aDragContext->actions & GDK_ACTION_LINK)
    1:         action = nsIDragService::DRAGDROP_ACTION_LINK;
    1: 
    1:     // copy is ctrl
    1:     else if (aDragContext->actions & GDK_ACTION_COPY)
    1:         action = nsIDragService::DRAGDROP_ACTION_COPY;
    1: 
    1:     // update the drag information
    1:     nsCOMPtr<nsIDragSession> session;
    1:     aDragService->GetCurrentSession(getter_AddRefs(session));
    1: 
    1:     if (session)
    1:         session->SetDragAction(action);
    1: }
    1: 
    1: 
    1: /* static */
    1: gboolean
    1: drag_motion_event_cb(GtkWidget *aWidget,
    1:                      GdkDragContext *aDragContext,
    1:                      gint aX,
    1:                      gint aY,
    1:                      guint aTime,
    1:                      gpointer aData)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     return window->OnDragMotionEvent(aWidget,
    1:                                      aDragContext,
    1:                                      aX, aY, aTime, aData);
    1: }
    1: /* static */
    1: void
    1: drag_leave_event_cb(GtkWidget *aWidget,
    1:                     GdkDragContext *aDragContext,
    1:                     guint aTime,
    1:                     gpointer aData)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
    1:     if (!window)
    1:         return;
    1: 
    1:     window->OnDragLeaveEvent(aWidget, aDragContext, aTime, aData);
    1: }
    1: 
    1: 
    1: /* static */
    1: gboolean
    1: drag_drop_event_cb(GtkWidget *aWidget,
    1:                    GdkDragContext *aDragContext,
    1:                    gint aX,
    1:                    gint aY,
    1:                    guint aTime,
    1:                    gpointer *aData)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
    1:     if (!window)
    1:         return FALSE;
    1: 
    1:     return window->OnDragDropEvent(aWidget,
    1:                                    aDragContext,
    1:                                    aX, aY, aTime, aData);
    1: }
    1: 
    1: /* static */
    1: void
    1: drag_data_received_event_cb(GtkWidget *aWidget,
    1:                             GdkDragContext *aDragContext,
    1:                             gint aX,
    1:                             gint aY,
    1:                             GtkSelectionData  *aSelectionData,
    1:                             guint aInfo,
    1:                             guint aTime,
    1:                             gpointer aData)
    1: {
  920:     nsRefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
    1:     if (!window)
    1:         return;
    1: 
    1:     window->OnDragDataReceivedEvent(aWidget,
    1:                                     aDragContext,
    1:                                     aX, aY,
    1:                                     aSelectionData,
    1:                                     aInfo, aTime, aData);
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: initialize_prefs(void)
    1: {
    1:     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
 2475:     if (!prefs)
 2475:         return NS_OK;
 2475: 
    1:     PRBool val = PR_TRUE;
    1:     nsresult rv;
19352: 
    1:     rv = prefs->GetBoolPref("mozilla.widget.raise-on-setfocus", &val);
    1:     if (NS_SUCCEEDED(rv))
    1:         gRaiseWindows = val;
    1: 
19352:     rv = prefs->GetBoolPref("mozilla.widget.disable-native-theme", &val);
19352:     if (NS_SUCCEEDED(rv))
19352:         gDisableNativeTheme = val;
19352: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsWindow::FireDragLeaveTimer(void)
    1: {
29217:     LOGDRAG(("nsWindow::FireDragLeaveTimer(%p)\n", (void*)this));
25825: 
25825:     mDragLeaveTimer = nsnull;
    1: 
    1:     // clean up any pending drag motion window info
61355:     if (sLastDragMotionWindow) {
61355:         nsRefPtr<nsWindow> kungFuDeathGrip = sLastDragMotionWindow;
    1:         // send our leave signal
61355:         sLastDragMotionWindow->OnDragLeave();
61355:         sLastDragMotionWindow = 0;
61355:     }
    1: }
    1: 
    1: /* static */
    1: void
    1: nsWindow::DragLeaveTimerCallback(nsITimer *aTimer, void *aClosure)
    1: {
 3233:     nsRefPtr<nsWindow> window = static_cast<nsWindow *>(aClosure);
    1:     window->FireDragLeaveTimer();
    1: }
    1: 
    1: /* static */
    1: GdkWindow *
    1: get_inner_gdk_window (GdkWindow *aWindow,
    1:                       gint x, gint y,
    1:                       gint *retx, gint *rety)
    1: {
    1:     gint cx, cy, cw, ch, cd;
    1:     GList * children = gdk_window_peek_children(aWindow);
    1:     guint num = g_list_length(children);
    1:     for (int i = 0; i < (int)num; i++) {
    1:         GList * child = g_list_nth(children, num - i - 1) ;
    1:         if (child) {
    1:             GdkWindow * childWindow = (GdkWindow *) child->data;
61174:             if (get_window_for_gdk_window(childWindow)) {
    1:                 gdk_window_get_geometry (childWindow, &cx, &cy, &cw, &ch, &cd);
    1:                 if ((cx < x) && (x < (cx + cw)) &&
    1:                     (cy < y) && (y < (cy + ch)) &&
    1:                     gdk_window_is_visible (childWindow)) {
    1:                     return get_inner_gdk_window (childWindow,
    1:                                                  x - cx, y - cy,
    1:                                                  retx, rety);
    1:                 }
    1:             }
    1:         }
61174:     }
    1:     *retx = x;
    1:     *rety = y;
    1:     return aWindow;
    1: }
    1: 
    1: inline PRBool
    1: is_context_menu_key(const nsKeyEvent& aKeyEvent)
    1: {
    1:     return ((aKeyEvent.keyCode == NS_VK_F10 && aKeyEvent.isShift &&
    1:              !aKeyEvent.isControl && !aKeyEvent.isMeta && !aKeyEvent.isAlt) ||
    1:             (aKeyEvent.keyCode == NS_VK_CONTEXT_MENU && !aKeyEvent.isShift &&
    1:              !aKeyEvent.isControl && !aKeyEvent.isMeta && !aKeyEvent.isAlt));
    1: }
    1: 
    1: void
11930: key_event_to_context_menu_event(nsMouseEvent &aEvent,
11930:                                 GdkEventKey *aGdkEvent)
11930: {
23738:     aEvent.refPoint = nsIntPoint(0, 0);
11930:     aEvent.isShift = PR_FALSE;
11930:     aEvent.isControl = PR_FALSE;
11930:     aEvent.isAlt = PR_FALSE;
11930:     aEvent.isMeta = PR_FALSE;
11930:     aEvent.time = aGdkEvent->time;
11930:     aEvent.clickCount = 1;
    1: }
    1: 
    1: /* static */
    1: int
    1: is_parent_ungrab_enter(GdkEventCrossing *aEvent)
    1: {
    1:     return (GDK_CROSSING_UNGRAB == aEvent->mode) &&
    1:         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
    1:          (GDK_NOTIFY_VIRTUAL == aEvent->detail));
    1: 
    1: }
    1: 
    1: /* static */
    1: int
    1: is_parent_grab_leave(GdkEventCrossing *aEvent)
    1: {
    1:     return (GDK_CROSSING_GRAB == aEvent->mode) &&
    1:         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
    1:             (GDK_NOTIFY_VIRTUAL == aEvent->detail));
    1: }
    1: 
 2475: static GdkModifierType
 2475: gdk_keyboard_get_modifiers()
 2475: {
 2475:     GdkModifierType m = (GdkModifierType) 0;
 2475: 
 2475:     gdk_window_get_pointer(NULL, NULL, NULL, &m);
 2475: 
 2475:     return m;
 2475: }
 2475: 
16529: #ifdef MOZ_X11
 2475: // Get the modifier masks for GDK_Caps_Lock, GDK_Num_Lock and GDK_Scroll_Lock.
 2475: // Return PR_TRUE on success, PR_FALSE on error.
 2475: static PRBool
 2475: gdk_keyboard_get_modmap_masks(Display*  aDisplay,
 2475:                               PRUint32* aCapsLockMask,
 2475:                               PRUint32* aNumLockMask,
 2475:                               PRUint32* aScrollLockMask)
 2475: {
 2475:     *aCapsLockMask = 0;
 2475:     *aNumLockMask = 0;
 2475:     *aScrollLockMask = 0;
 2475: 
 2475:     int min_keycode = 0;
 2475:     int max_keycode = 0;
 2475:     XDisplayKeycodes(aDisplay, &min_keycode, &max_keycode);
 2475: 
 2475:     int keysyms_per_keycode = 0;
 2475:     KeySym* xkeymap = XGetKeyboardMapping(aDisplay, min_keycode,
 2475:                                           max_keycode - min_keycode + 1,
 2475:                                           &keysyms_per_keycode);
 2475:     if (!xkeymap) {
 2475:         return PR_FALSE;
 2475:     }
 2475: 
 2475:     XModifierKeymap* xmodmap = XGetModifierMapping(aDisplay);
 2475:     if (!xmodmap) {
 2475:         XFree(xkeymap);
 2475:         return PR_FALSE;
 2475:     }
 2475: 
 2475:     /*
 2475:       The modifiermap member of the XModifierKeymap structure contains 8 sets
 2475:       of max_keypermod KeyCodes, one for each modifier in the order Shift,
 2475:       Lock, Control, Mod1, Mod2, Mod3, Mod4, and Mod5.
 2475:       Only nonzero KeyCodes have meaning in each set, and zero KeyCodes are ignored.
 2475:     */
 2475:     const unsigned int map_size = 8 * xmodmap->max_keypermod;
 2475:     for (unsigned int i = 0; i < map_size; i++) {
 2475:         KeyCode keycode = xmodmap->modifiermap[i];
 2475:         if (!keycode || keycode < min_keycode || keycode > max_keycode)
 2475:             continue;
 2475: 
 2475:         const KeySym* syms = xkeymap + (keycode - min_keycode) * keysyms_per_keycode;
 2475:         const unsigned int mask = 1 << (i / xmodmap->max_keypermod);
 2475:         for (int j = 0; j < keysyms_per_keycode; j++) {
 2475:             switch (syms[j]) {
 2475:                 case GDK_Caps_Lock:   *aCapsLockMask |= mask;   break;
 2475:                 case GDK_Num_Lock:    *aNumLockMask |= mask;    break;
 2475:                 case GDK_Scroll_Lock: *aScrollLockMask |= mask; break;
 2475:             }
 2475:         }
 2475:     }
 2475: 
 2475:     XFreeModifiermap(xmodmap);
 2475:     XFree(xkeymap);
 2475:     return PR_TRUE;
 2475: }
16529: #endif /* MOZ_X11 */
 2475: 
    1: #ifdef ACCESSIBILITY
    1: void
    1: nsWindow::CreateRootAccessible()
    1: {
    1:     if (mIsTopLevel && !mRootAccessible) {
42313:         nsAccessible *acc = DispatchAccessibleEvent();
    1: 
    1:         if (acc) {
    1:             mRootAccessible = acc;
    1:         }
    1:     }
    1: }
    1: 
42313: nsAccessible*
42313: nsWindow::DispatchAccessibleEvent()
42313: {
    1:     nsAccessibleEvent event(PR_TRUE, NS_GETACCESSIBLE, this);
    1: 
    1:     nsEventStatus status;
    1:     DispatchEvent(&event, status);
42313: 
42313:     return event.mAccessible;
42313: }
42313: 
42313: void
42313: nsWindow::DispatchEventToRootAccessible(PRUint32 aEventType)
42313: {
42313:     if (!sAccessibilityEnabled) {
42313:         return;
42313:     }
42313: 
42313:     nsCOMPtr<nsIAccessibilityService> accService =
42313:         do_GetService("@mozilla.org/accessibilityService;1");
42313:     if (!accService) {
42313:         return;
42313:     }
42313: 
54519:     // Get the root document accessible and fire event to it.
42313:     nsAccessible *acc = DispatchAccessibleEvent();
54519:     if (acc) {
54519:         accService->FireAccessibleEvent(aEventType, acc);
54519:     }
    1: }
    1: 
    1: void
20621: nsWindow::DispatchActivateEventAccessible(void)
    1: {
42313:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_ACTIVATE);
    1: }
    1: 
    1: void
20621: nsWindow::DispatchDeactivateEventAccessible(void)
20621: {
42313:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_DEACTIVATE);
    1: }
20621: 
64019: void
64019: nsWindow::DispatchMaximizeEventAccessible(void)
64019: {
64019:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MAXIMIZE);
64019: }
64019: 
64019: void
64019: nsWindow::DispatchMinimizeEventAccessible(void)
64019: {
64019:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MINIMIZE);
64019: }
64019: 
64019: void
64019: nsWindow::DispatchRestoreEventAccessible(void)
64019: {
64019:     DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_RESTORE);
64019: }
64019: 
    1: #endif /* #ifdef ACCESSIBILITY */
    1: 
    1: // nsChildWindow class
    1: 
    1: nsChildWindow::nsChildWindow()
    1: {
    1: }
    1: 
    1: nsChildWindow::~nsChildWindow()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::ResetInputState()
    1: {
39627:     return mIMModule ? mIMModule->ResetInputState(this) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
58017: nsWindow::SetInputMode(const IMEContext& aContext)
58017: {
58017:     return mIMModule ? mIMModule->SetInputMode(this, &aContext) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
58019: nsWindow::GetInputMode(IMEContext& aContext)
58019: {
39627:   if (!mIMModule) {
58019:       aContext.mStatus = nsIWidget::IME_STATUS_DISABLED;
    1:       return NS_OK;
    1:   }
58019:   return mIMModule->GetInputMode(&aContext);
39627: }
    1: 
    1: NS_IMETHODIMP
    1: nsWindow::CancelIMEComposition()
    1: {
39627:     return mIMModule ? mIMModule->CancelIMEComposition(this) : NS_OK;
39627: }
39627: 
39627: NS_IMETHODIMP
39627: nsWindow::OnIMEFocusChange(PRBool aFocus)
39627: {
39627:     if (mIMModule) {
39627:       mIMModule->OnFocusChangeInGecko(aFocus);
39627:     }
39655:     // XXX Return NS_ERROR_NOT_IMPLEMENTED, see bug 496360.
39655:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
 2475: NS_IMETHODIMP
 2475: nsWindow::GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState)
 2475: {
 2475:     NS_ENSURE_ARG_POINTER(aLEDState);
 2475: 
16529: #ifdef MOZ_X11
16529: 
 2475:     GdkModifierType modifiers = gdk_keyboard_get_modifiers();
 2475:     PRUint32 capsLockMask, numLockMask, scrollLockMask;
 2475:     PRBool foundMasks = gdk_keyboard_get_modmap_masks(
30704:                           GDK_WINDOW_XDISPLAY(mGdkWindow),
 2475:                           &capsLockMask, &numLockMask, &scrollLockMask);
 9754:     if (!foundMasks)
 9754:         return NS_ERROR_NOT_IMPLEMENTED;
 2475: 
 2475:     PRUint32 mask = 0;
 2475:     switch (aKeyCode) {
 2475:         case NS_VK_CAPS_LOCK:   mask = capsLockMask;   break;
 2475:         case NS_VK_NUM_LOCK:    mask = numLockMask;    break;
 2475:         case NS_VK_SCROLL_LOCK: mask = scrollLockMask; break;
 2475:     }
 2475:     if (mask == 0)
 2475:         return NS_ERROR_NOT_IMPLEMENTED;
 2475: 
 2475:     *aLEDState = (modifiers & mask) != 0;
 2475:     return NS_OK;
16529: #else
16529:     return NS_ERROR_NOT_IMPLEMENTED;
16529: #endif /* MOZ_X11 */
 2475: }
 2475: 
16529: #ifdef MOZ_X11
15409: /* static */ already_AddRefed<gfxASurface>
15409: nsWindow::GetSurfaceForGdkDrawable(GdkDrawable* aDrawable,
23738:                                    const nsIntSize& aSize)
15409: {
15409:     GdkVisual* visual = gdk_drawable_get_visual(aDrawable);
47113:     Screen* xScreen =
47113:         gdk_x11_screen_get_xscreen(gdk_drawable_get_screen(aDrawable));
47113:     Display* xDisplay = DisplayOfScreen(xScreen);
15409:     Drawable xDrawable = gdk_x11_drawable_get_xid(aDrawable);
15409: 
19352:     gfxASurface* result = nsnull;
19352: 
19352:     if (visual) {
19352:         Visual* xVisual = gdk_x11_visual_get_xvisual(visual);
19352: 
19352:         result = new gfxXlibSurface(xDisplay, xDrawable, xVisual,
15409:                                     gfxIntSize(aSize.width, aSize.height));
19352:     } else {
19352:         // no visual? we must be using an xrender format.  Find a format
19352:         // for this depth.
19352:         XRenderPictFormat *pf = NULL;
19352:         switch (gdk_drawable_get_depth(aDrawable)) {
19352:             case 32:
19352:                 pf = XRenderFindStandardFormat(xDisplay, PictStandardARGB32);
19352:                 break;
19352:             case 24:
19352:                 pf = XRenderFindStandardFormat(xDisplay, PictStandardRGB24);
19352:                 break;
19352:             default:
19352:                 NS_ERROR("Don't know how to handle the given depth!");
19352:                 break;
19352:         }
19352: 
47113:         result = new gfxXlibSurface(xScreen, xDrawable, pf,
19352:                                     gfxIntSize(aSize.width, aSize.height));
19352:     }
19352: 
15409:     NS_IF_ADDREF(result);
15409:     return result;
15409: }
16529: #endif
15409: 
    1: // return the gfxASurface for rendering to this widget
    1: gfxASurface*
    1: nsWindow::GetThebesSurface()
    1: {
34746:     if (!mGdkWindow)
34746:         return nsnull;
34746: 
13055:     GdkDrawable* d;
13055:     gint x_offset, y_offset;
30704:     gdk_window_get_internal_paint_info(mGdkWindow, &d, &x_offset, &y_offset);
13055: 
16529: #ifdef MOZ_X11
    1:     gint width, height;
    1:     gdk_drawable_get_size(d, &width, &height);
13055:     // Owen Taylor says this is the right thing to do!
13055:     width = PR_MIN(32767, width);
13055:     height = PR_MIN(32767, height);
54594:     gfxIntSize size(width, height);
54594:     Visual* visual = GDK_VISUAL_XVISUAL(gdk_drawable_get_visual(d));
54594: 
54594: #  ifdef MOZ_HAVE_SHMIMAGE
54594:     PRBool usingShm = PR_FALSE;
56628:     if (nsShmImage::UseShm()) {
54594:         // EnsureShmImage() is a dangerous interface, but we guarantee
54594:         // that the thebes surface and the shmimage have the same
54594:         // lifetime
56628:         mThebesSurface =
56628:             nsShmImage::EnsureShmImage(size,
54594:                                        visual, gdk_drawable_get_depth(d),
54594:                                        mShmImage);
54594:         usingShm = mThebesSurface != nsnull;
54594:     }
54594:     if (!usingShm)
54594: #  endif  // MOZ_HAVE_SHMIMAGE
13055: 
    1:     mThebesSurface = new gfxXlibSurface
    1:         (GDK_WINDOW_XDISPLAY(d),
    1:          GDK_WINDOW_XWINDOW(d),
54594:          visual,
54594:          size);
16529: #endif
16529: #ifdef MOZ_DFB
16529:     mThebesSurface = new gfxDirectFBSurface(gdk_directfb_surface_lookup(d));
16529: #endif
 7639: 
 7639:     // if the surface creation is reporting an error, then
 7639:     // we don't have a surface to give back
16529:     if (mThebesSurface && mThebesSurface->CairoStatus() != 0) {
 3368:         mThebesSurface = nsnull;
    1:     } else {
13055:         mThebesSurface->SetDeviceOffset(gfxPoint(-x_offset, -y_offset));
13055:     }
    1: 
    1:     return mThebesSurface;
    1: }
 8892: 
47857: // Code shared begin BeginMoveDrag and BeginResizeDrag
47857: PRBool
47857: nsWindow::GetDragInfo(nsMouseEvent* aMouseEvent,
47857:                       GdkWindow** aWindow, gint* aButton,
47857:                       gint* aRootX, gint* aRootY)
47857: {
47857:     if (aMouseEvent->button != nsMouseEvent::eLeftButton) {
47857:         // we can only begin a move drag with the left mouse button
47857:         return PR_FALSE;
47857:     }
47857:     *aButton = 1;
47857: 
47857:     // get the gdk window for this widget
47857:     GdkWindow* gdk_window = mGdkWindow;
47857:     if (!gdk_window) {
47857:         return PR_FALSE;
47857:     }
47857:     NS_ABORT_IF_FALSE(GDK_IS_WINDOW(gdk_window), "must really be window");
47857: 
47857:     // find the top-level window
47857:     gdk_window = gdk_window_get_toplevel(gdk_window);
47857:     NS_ABORT_IF_FALSE(gdk_window,
47857:                       "gdk_window_get_toplevel should not return null");
47857:     *aWindow = gdk_window;
47857: 
47857:     if (!aMouseEvent->widget) {
47857:         return PR_FALSE;
47857:     }
47857: 
47857:     // FIXME: It would be nice to have the widget position at the time
47857:     // of the event, but it's relatively unlikely that the widget has
47857:     // moved since the mousedown.  (On the other hand, it's quite likely
47857:     // that the mouse has moved, which is why we use the mouse position
47857:     // from the event.)
47857:     nsIntPoint offset = aMouseEvent->widget->WidgetToScreenOffset();
47857:     *aRootX = aMouseEvent->refPoint.x + offset.x;
47857:     *aRootY = aMouseEvent->refPoint.y + offset.y;
47857: 
47857:     return PR_TRUE;
47857: }
47857: 
47857: NS_IMETHODIMP
47857: nsWindow::BeginMoveDrag(nsMouseEvent* aEvent)
47857: {
47857:     NS_ABORT_IF_FALSE(aEvent, "must have event");
47857:     NS_ABORT_IF_FALSE(aEvent->eventStructType == NS_MOUSE_EVENT,
47857:                       "event must have correct struct type");
47857: 
47857:     GdkWindow *gdk_window;
47857:     gint button, screenX, screenY;
47857:     if (!GetDragInfo(aEvent, &gdk_window, &button, &screenX, &screenY)) {
47857:         return NS_ERROR_FAILURE;
47857:     }
47857: 
47857:     // tell the window manager to start the move
47857:     gdk_window_begin_move_drag(gdk_window, button, screenX, screenY,
47857:                                aEvent->time);
47857: 
47857:     return NS_OK;
47857: }
47857: 
 8892: NS_IMETHODIMP
 8892: nsWindow::BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical)
 8892: {
 8892:     NS_ENSURE_ARG_POINTER(aEvent);
 8892: 
 8892:     if (aEvent->eventStructType != NS_MOUSE_EVENT) {
 8892:         // you can only begin a resize drag with a mouse event
 8892:         return NS_ERROR_INVALID_ARG;
 8892:     }
 8892: 
 8892:     nsMouseEvent* mouse_event = static_cast<nsMouseEvent*>(aEvent);
 8892: 
47857:     GdkWindow *gdk_window;
47857:     gint button, screenX, screenY;
47857:     if (!GetDragInfo(mouse_event, &gdk_window, &button, &screenX, &screenY)) {
47857:         return NS_ERROR_FAILURE;
 8892:     }
 8892: 
 8892:     // work out what GdkWindowEdge we're talking about
 8892:     GdkWindowEdge window_edge;
 8892:     if (aVertical < 0) {
 8892:         if (aHorizontal < 0) {
 8892:             window_edge = GDK_WINDOW_EDGE_NORTH_WEST;
 8892:         } else if (aHorizontal == 0) {
 8892:             window_edge = GDK_WINDOW_EDGE_NORTH;
 8892:         } else {
 8892:             window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
 8892:         }
 8892:     } else if (aVertical == 0) {
 8892:         if (aHorizontal < 0) {
 8892:             window_edge = GDK_WINDOW_EDGE_WEST;
 8892:         } else if (aHorizontal == 0) {
 8892:             return NS_ERROR_INVALID_ARG;
 8892:         } else {
 8892:             window_edge = GDK_WINDOW_EDGE_EAST;
 8892:         }
 8892:     } else {
 8892:         if (aHorizontal < 0) {
 8892:             window_edge = GDK_WINDOW_EDGE_SOUTH_WEST;
 8892:         } else if (aHorizontal == 0) {
 8892:             window_edge = GDK_WINDOW_EDGE_SOUTH;
 8892:         } else {
 8892:             window_edge = GDK_WINDOW_EDGE_SOUTH_EAST;
 8892:         }
 8892:     }
 8892: 
 8892:     // tell the window manager to start the resize
47857:     gdk_window_begin_resize_drag(gdk_window, window_edge, button,
 8892:                                  screenX, screenY, aEvent->time);
 8892: 
 8892:     return NS_OK;
 8892: }
61184: 
61184: void
61184: nsWindow::ClearCachedResources()
61184: {
61184:     if (mLayerManager &&
61184:         mLayerManager->GetBackendType() == LayerManager::LAYERS_BASIC) {
61184:         static_cast<BasicLayerManager*> (mLayerManager.get())->
61184:             ClearCachedResources();
61184:     }
61184: 
61184:     GList* children = gdk_window_peek_children(mGdkWindow);
61184:     for (GList* list = children; list; list = list->next) {
61184:         nsWindow* window = get_window_for_gdk_window(GDK_WINDOW(list->data));
61184:         if (window) {
61184:             window->ClearCachedResources();
61184:         }
61184:     }
61184: }
