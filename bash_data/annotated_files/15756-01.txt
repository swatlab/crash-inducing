    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set sw=2 ts=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Kathleen Brade <brade@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsICharsetAlias.h"
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsHTMLDocument.h"
    1: #include "nsIParserFilter.h"
    1: #include "nsIHTMLContentSink.h"
    1: #include "nsIXMLContentSink.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsHTMLStyleSheet.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDOMNode.h" // for Find
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMComment.h"
    1: #include "nsIDOMDOMImplementation.h"
    1: #include "nsIDOMDocumentType.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMHTMLFormElement.h"
    1: #include "nsDOMString.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIURI.h"
    1: #include "nsIIOService.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIContentViewerContainer.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
 3101: #include "nsDocShellLoadTypes.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIWebShellServices.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsContentList.h"
    1: #include "nsDOMError.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsAttrName.h"
    1: #include "nsNodeUtils.h"
    1: 
    1: #include "nsNetCID.h"
    1: #include "nsIIOService.h"
    1: #include "nsICookieService.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsParserCIID.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMHTMLMapElement.h"
    1: #include "nsIDOMHTMLBodyElement.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsGenericDOMNodeList.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIFile.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsISelectElement.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsISelectionPrivate.h"//for toStringwithformat code
    1: 
    1: #include "nsICharsetDetector.h"
    1: #include "nsICharsetDetectionAdaptor.h"
    1: #include "nsCharsetDetectionAdaptorCID.h"
    1: #include "nsICharsetAlias.h"
    1: #include "nsContentUtils.h"
    1: #include "nsJSUtils.h"
    1: #include "nsIDocumentCharsetInfo.h"
    1: #include "nsIDocumentEncoder.h" //for outputting selection
    1: #include "nsICharsetResolver.h"
    1: #include "nsICachingChannel.h"
    1: #include "nsICacheEntryDescriptor.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIDocumentViewer.h"
    1: #include "nsIWyciwygChannel.h"
    1: #include "nsIScriptElement.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIMutableArray.h"
    1: #include "nsArrayUtils.h"
  803: #include "nsIEffectiveTLDService.h"
 2896: #include "nsIEventStateManager.h"
    1: 
    1: #include "nsIPrompt.h"
    1: //AHMED 12-2
    1: #include "nsBidiUtils.h"
    1: 
    1: #include "nsIEditingSession.h"
    1: #include "nsIEditor.h"
    1: #include "nsNodeInfoManager.h"
 2896: #include "nsIEditor.h"
 2896: #include "nsIEditorDocShell.h"
 2896: #include "nsIEditorStyleSheets.h"
 2896: #include "nsIInlineSpellChecker.h"
 2896: #include "nsRange.h"
14228: #include "mozAutoDocUpdate.h"
    1: 
    1: #define NS_MAX_DOCUMENT_WRITE_DEPTH 20
    1: 
    1: #define DETECTOR_CONTRACTID_MAX 127
    1: static char g_detector_contractid[DETECTOR_CONTRACTID_MAX + 1];
    1: static PRBool gInitDetector = PR_FALSE;
    1: static PRBool gPlugDetector = PR_FALSE;
    1: 
    1: #include "prmem.h"
    1: #include "prtime.h"
    1: 
    1: // Find/Search Includes
    1: const PRInt32 kForward  = 0;
    1: const PRInt32 kBackward = 1;
    1: 
    1: //#define DEBUG_charset
    1: 
    1: static NS_DEFINE_CID(kCParserCID, NS_PARSER_CID);
    1: 
    1: PRUint32       nsHTMLDocument::gWyciwygSessionCnt = 0;
    1: 
10248: // this function will return false if the command is not recognized
10248: // inCommandID will be converted as necessary for internal operations
10248: // inParam will be converted as necessary for internal operations
10248: // outParam will be Empty if no parameter is needed or if returning a boolean
10248: // outIsBoolean will determine whether to send param as a boolean or string
10248: // outBooleanParam will not be set unless outIsBoolean
10248: static PRBool ConvertToMidasInternalCommand(const nsAString & inCommandID,
10248:                                             const nsAString & inParam,
10248:                                             nsACString& outCommandID,
10248:                                             nsACString& outParam,
10248:                                             PRBool& isBoolean,
10248:                                             PRBool& boolValue);
10248: 
10248: static PRBool ConvertToMidasInternalCommand(const nsAString & inCommandID,
10248:                                             nsACString& outCommandID);
    1: static int PR_CALLBACK
    1: MyPrefChangedCallback(const char*aPrefName, void* instance_data)
    1: {
    1:   const nsAdoptingString& detector_name =
    1:     nsContentUtils::GetLocalizedStringPref("intl.charset.detector");
    1: 
    1:   if (detector_name.Length() > 0) {
    1:     PL_strncpy(g_detector_contractid, NS_CHARSET_DETECTOR_CONTRACTID_BASE,
    1:                DETECTOR_CONTRACTID_MAX);
    1:     PL_strncat(g_detector_contractid,
    1:                NS_ConvertUTF16toUTF8(detector_name).get(),
    1:                DETECTOR_CONTRACTID_MAX);
    1:     gPlugDetector = PR_TRUE;
    1:   } else {
    1:     g_detector_contractid[0]=0;
    1:     gPlugDetector = PR_FALSE;
    1:   }
    1: 
    1:   return 0;
    1: }
    1: 
    1: // ==================================================================
    1: // =
    1: // ==================================================================
    1: nsresult
    1: NS_NewHTMLDocument(nsIDocument** aInstancePtrResult)
    1: {
    1:   nsHTMLDocument* doc = new nsHTMLDocument();
    1:   NS_ENSURE_TRUE(doc, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   NS_ADDREF(doc);
    1:   nsresult rv = doc->Init();
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     NS_RELEASE(doc);
    1:   }
    1: 
    1:   *aInstancePtrResult = doc;
    1: 
    1:   return rv;
    1: }
    1: 
    1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
    1: nsHTMLDocument::nsHTMLDocument()
15474:   : nsDocument("text/html")
    1: {
    1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
15474:   mIsRegularHTML = PR_TRUE;
    1:   mDefaultElementType = kNameSpaceID_XHTML;
    1:   mCompatMode = eCompatibility_NavQuirks;
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLDocument)
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLDocument, nsDocument)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mImageMaps)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mImages)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mApplets)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEmbeds)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLinks)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAnchors)
11423:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFragmentParser)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mForms, nsIDOMNodeList)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mFormControls,
    1:                                                        nsIDOMNodeList)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLDocument, nsDocument)
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLDocument, nsDocument)
    1: 
12033: 
12033: // QueryInterface implementation for nsHTMLDocument
12033: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLDocument)
12033:   NS_INTERFACE_TABLE_INHERITED3(nsHTMLDocument,
12033:                                 nsIHTMLDocument,
12033:                                 nsIDOMHTMLDocument,
12033:                                 nsIDOMNSHTMLDocument)
12033:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
12033:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(HTMLDocument)
12033: NS_INTERFACE_MAP_END_INHERITING(nsDocument)
12033: 
12033: 
    1: nsresult
    1: nsHTMLDocument::Init()
    1: {
    1:   nsresult rv = nsDocument::Init();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Now reset the case-sensitivity of the CSSLoader, since we default
    1:   // to being HTML, not XHTML.  Also, reset the compatibility mode to
    1:   // match our compat mode.
    1:   CSSLoader()->SetCaseSensitive(IsXHTML());
    1:   CSSLoader()->SetCompatibilityMode(mCompatMode);
    1: 
15474:   PrePopulateIdentifierMap();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: void
    1: nsHTMLDocument::Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup)
    1: {
    1:   nsDocument::Reset(aChannel, aLoadGroup);
    1: 
    1:   if (aChannel) {
    1:     aChannel->GetLoadFlags(&mLoadFlags);
    1:   }
    1: }
    1: 
    1: void
    1: nsHTMLDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
    1:                            nsIPrincipal* aPrincipal)
    1: {
    1:   mLoadFlags = nsIRequest::LOAD_NORMAL;
    1: 
    1:   nsDocument::ResetToURI(aURI, aLoadGroup, aPrincipal);
    1: 
15474:   PrePopulateIdentifierMap();
    1: 
    1:   mImages = nsnull;
    1:   mApplets = nsnull;
    1:   mEmbeds = nsnull;
    1:   mLinks = nsnull;
    1:   mAnchors = nsnull;
    1: 
    1:   mImageMaps.Clear();
    1:   mForms = nsnull;
    1: 
    1:   NS_ASSERTION(!mWyciwygChannel,
    1:                "nsHTMLDocument::Reset() - Wyciwyg Channel  still exists!");
    1: 
    1:   mWyciwygChannel = nsnull;
    1: 
    1:   // Make the content type default to "text/html", we are a HTML
    1:   // document, after all. Once we start getting data, this may be
    1:   // changed.
    1:   mContentType = "text/html";
    1: }
    1: 
    1: nsStyleSet::sheetType
    1: nsHTMLDocument::GetAttrSheetType()
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::GetAttrSheetType();
    1:   }
    1:   
    1:   return nsStyleSet::eHTMLPresHintSheet;
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::CreateShell(nsPresContext* aContext,
    1:                             nsIViewManager* aViewManager,
    1:                             nsStyleSet* aStyleSet,
    1:                             nsIPresShell** aInstancePtrResult)
    1: {
    1:   return doCreateShell(aContext, aViewManager, aStyleSet, mCompatMode,
    1:                        aInstancePtrResult);
    1: }
    1: 
    1: // The following Try*Charset will return PR_FALSE only if the charset source
    1: // should be considered (ie. aCharsetSource < thisCharsetSource) but we failed
    1: // to get the charset from this source.
    1: 
    1: PRBool
    1: nsHTMLDocument::TryHintCharset(nsIMarkupDocumentViewer* aMarkupDV,
    1:                                PRInt32& aCharsetSource, nsACString& aCharset)
    1: {
    1:   if (aMarkupDV) {
    1:     PRInt32 requestCharsetSource;
    1:     nsresult rv = aMarkupDV->GetHintCharacterSetSource(&requestCharsetSource);
    1: 
    1:     if(NS_SUCCEEDED(rv) && kCharsetUninitialized != requestCharsetSource) {
    1:       nsCAutoString requestCharset;
    1:       rv = aMarkupDV->GetHintCharacterSet(requestCharset);
    1:       aMarkupDV->SetHintCharacterSetSource((PRInt32)(kCharsetUninitialized));
    1: 
    1:       if(requestCharsetSource <= aCharsetSource)
    1:         return PR_TRUE;
    1: 
    1:       if(NS_SUCCEEDED(rv)) {
    1:         aCharsetSource = requestCharsetSource;
    1:         aCharset = requestCharset;
    1: 
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsHTMLDocument::TryUserForcedCharset(nsIMarkupDocumentViewer* aMarkupDV,
    1:                                      nsIDocumentCharsetInfo*  aDocInfo,
    1:                                      PRInt32& aCharsetSource,
    1:                                      nsACString& aCharset)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if(kCharsetFromUserForced <= aCharsetSource)
    1:     return PR_TRUE;
    1: 
    1:   nsCAutoString forceCharsetFromDocShell;
    1:   if (aMarkupDV) {
    1:     rv = aMarkupDV->GetForceCharacterSet(forceCharsetFromDocShell);
    1:   }
    1: 
    1:   if(NS_SUCCEEDED(rv) && !forceCharsetFromDocShell.IsEmpty()) {
    1:     aCharset = forceCharsetFromDocShell;
    1:     //TODO: we should define appropriate constant for force charset
    1:     aCharsetSource = kCharsetFromUserForced;
    1:   } else if (aDocInfo) {
    1:     nsCOMPtr<nsIAtom> csAtom;
    1:     aDocInfo->GetForcedCharset(getter_AddRefs(csAtom));
    1:     if (csAtom) {
    1:       csAtom->ToUTF8String(aCharset);
    1:       aCharsetSource = kCharsetFromUserForced;
    1:       aDocInfo->SetForcedCharset(nsnull);
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsHTMLDocument::TryCacheCharset(nsICacheEntryDescriptor* aCacheDescriptor,
    1:                                 PRInt32& aCharsetSource,
    1:                                 nsACString& aCharset)
    1: {
    1:   nsresult rv;
    1: 
    1:   if (kCharsetFromCache <= aCharsetSource) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   nsXPIDLCString cachedCharset;
    1:   rv = aCacheDescriptor->GetMetaDataElement("charset",
    1:                                            getter_Copies(cachedCharset));
    1:   if (NS_SUCCEEDED(rv) && !cachedCharset.IsEmpty())
    1:   {
    1:     aCharset = cachedCharset;
    1:     aCharsetSource = kCharsetFromCache;
    1: 
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsHTMLDocument::TryBookmarkCharset(nsIDocShell* aDocShell,
    1:                                    nsIChannel* aChannel,
    1:                                    PRInt32& aCharsetSource,
    1:                                    nsACString& aCharset)
    1: {
    1:   if (kCharsetFromBookmarks <= aCharsetSource) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (!aChannel) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsICharsetResolver> bookmarksResolver =
    1:     do_GetService("@mozilla.org/embeddor.implemented/bookmark-charset-resolver;1");
    1: 
    1:   if (!bookmarksResolver) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRBool wantCharset;         // ignored for now
    1:   nsCAutoString charset;
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(aDocShell));
    1:   nsCOMPtr<nsISupports> closure;
    1:   nsresult rv = bookmarksResolver->RequestCharset(webNav,
    1:                                                   aChannel,
    1:                                                   &wantCharset,
    1:                                                   getter_AddRefs(closure),
    1:                                                   charset);
13800:   // FIXME: Bug 337970
    1:   NS_ASSERTION(!wantCharset, "resolved charset notification not implemented!");
    1: 
    1:   if (NS_SUCCEEDED(rv) && !charset.IsEmpty()) {
    1:     aCharset = charset;
    1:     aCharsetSource = kCharsetFromBookmarks;
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: static PRBool
    1: CheckSameOrigin(nsINode* aNode1, nsINode* aNode2)
    1: {
    1:   NS_PRECONDITION(aNode1, "Null node?");
    1:   NS_PRECONDITION(aNode2, "Null node?");
    1: 
 3286:   PRBool equal;
    1:   return
 3286:     NS_SUCCEEDED(aNode1->NodePrincipal()->
 3286:                    Equals(aNode2->NodePrincipal(), &equal)) &&
 3286:     equal;
    1: }
    1: 
    1: PRBool
    1: nsHTMLDocument::TryParentCharset(nsIDocumentCharsetInfo*  aDocInfo,
    1:                                  nsIDocument* aParentDocument,
    1:                                  PRInt32& aCharsetSource,
    1:                                  nsACString& aCharset)
    1: {
    1:   if (aDocInfo) {
    1:     PRInt32 source;
    1:     nsCOMPtr<nsIAtom> csAtom;
    1:     PRInt32 parentSource;
    1:     aDocInfo->GetParentCharsetSource(&parentSource);
    1:     if (kCharsetFromParentForced <= parentSource)
    1:       source = kCharsetFromParentForced;
    1:     else if (kCharsetFromHintPrevDoc == parentSource) {
    1:       // Make sure that's OK
    1:       if (!aParentDocument || !CheckSameOrigin(this, aParentDocument)) {
    1:         return PR_FALSE;
    1:       }
    1:       
    1:       // if parent is posted doc, set this prevent autodections
    1:       // I'm not sure this makes much sense... but whatever.
    1:       source = kCharsetFromHintPrevDoc;
    1:     }
    1:     else if (kCharsetFromCache <= parentSource) {
    1:       // Make sure that's OK
    1:       if (!aParentDocument || !CheckSameOrigin(this, aParentDocument)) {
    1:         return PR_FALSE;
    1:       }
    1: 
    1:       source = kCharsetFromParentFrame;
    1:     }
    1:     else
    1:       return PR_FALSE;
    1: 
    1:     if (source < aCharsetSource)
    1:       return PR_TRUE;
    1: 
    1:     aDocInfo->GetParentCharset(getter_AddRefs(csAtom));
    1:     if (csAtom) {
    1:       csAtom->ToUTF8String(aCharset);
    1:       aCharsetSource = source;
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsHTMLDocument::UseWeakDocTypeDefault(PRInt32& aCharsetSource,
    1:                                       nsACString& aCharset)
    1: {
    1:   if (kCharsetFromWeakDocTypeDefault <= aCharsetSource)
    1:     return PR_TRUE;
    1:   // fallback value in case docshell return error
    1:   aCharset.AssignLiteral("ISO-8859-1");
    1: 
    1:   const nsAdoptingString& defCharset =
    1:     nsContentUtils::GetLocalizedStringPref("intl.charset.default");
    1: 
    1:   if (!defCharset.IsEmpty()) {
    1:     LossyCopyUTF16toASCII(defCharset, aCharset);
    1:     aCharsetSource = kCharsetFromWeakDocTypeDefault;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsHTMLDocument::TryDefaultCharset( nsIMarkupDocumentViewer* aMarkupDV,
    1:                                    PRInt32& aCharsetSource,
    1:                                    nsACString& aCharset)
    1: {
    1:   if(kCharsetFromUserDefault <= aCharsetSource)
    1:     return PR_TRUE;
    1: 
    1:   nsCAutoString defaultCharsetFromDocShell;
    1:   if (aMarkupDV) {
    1:     nsresult rv =
    1:       aMarkupDV->GetDefaultCharacterSet(defaultCharsetFromDocShell);
    1:     if(NS_SUCCEEDED(rv)) {
    1:       aCharset = defaultCharsetFromDocShell;
    1: 
    1:       aCharsetSource = kCharsetFromUserDefault;
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::StartAutodetection(nsIDocShell *aDocShell, nsACString& aCharset,
    1:                                    const char* aCommand)
    1: {
    1:   nsCOMPtr <nsIParserFilter> cdetflt;
    1: 
    1:   nsresult rv_detect;
    1:   if(!gInitDetector) {
    1:     const nsAdoptingString& detector_name =
    1:       nsContentUtils::GetLocalizedStringPref("intl.charset.detector");
    1: 
    1:     if(!detector_name.IsEmpty()) {
    1:       PL_strncpy(g_detector_contractid, NS_CHARSET_DETECTOR_CONTRACTID_BASE,
    1:                  DETECTOR_CONTRACTID_MAX);
    1:       PL_strncat(g_detector_contractid,
    1:                  NS_ConvertUTF16toUTF8(detector_name).get(),
    1:                  DETECTOR_CONTRACTID_MAX);
    1:       gPlugDetector = PR_TRUE;
    1:     }
    1: 
    1:     nsContentUtils::RegisterPrefCallback("intl.charset.detector",
    1:                                          MyPrefChangedCallback,
    1:                                          nsnull);
    1: 
    1:     gInitDetector = PR_TRUE;
    1:   }
    1: 
    1:   if (gPlugDetector) {
    1:     nsCOMPtr <nsICharsetDetector> cdet =
    1:       do_CreateInstance(g_detector_contractid, &rv_detect);
    1:     if (NS_SUCCEEDED(rv_detect)) {
    1:       cdetflt = do_CreateInstance(NS_CHARSET_DETECTION_ADAPTOR_CONTRACTID,
    1:                                   &rv_detect);
    1: 
    1:       nsCOMPtr<nsICharsetDetectionAdaptor> adp = do_QueryInterface(cdetflt);
    1:       if (adp) {
    1:         nsCOMPtr<nsIWebShellServices> wss = do_QueryInterface(aDocShell);
    1:         if (wss) {
    1:           rv_detect = adp->Init(wss, cdet, this, mParser,
    1:                                 PromiseFlatCString(aCharset).get(), aCommand);
    1: 
    1:           if (mParser)
    1:             mParser->SetParserFilter(cdetflt);
    1:         }
    1:       }
    1:     }
    1:     else {
    1:       // IF we cannot create the detector, don't bother to
    1:       // create one next time.
    1:       gPlugDetector = PR_FALSE;
    1:     }
    1:   }
    1: }
    1: 
 1300: void
 1300: nsHTMLDocument::SetDocumentCharacterSet(const nsACString& aCharSetID)
 1300: {
 1300:   nsDocument::SetDocumentCharacterSet(aCharSetID);
 1300:   // Make sure to stash this charset on our channel as needed if it's a wyciwyg
 1300:   // channel.
 1300:   nsCOMPtr<nsIWyciwygChannel> wyciwygChannel = do_QueryInterface(mChannel);
 1300:   if (wyciwygChannel) {
 1300:     wyciwygChannel->SetCharsetAndSource(GetDocumentCharacterSetSource(),
 1300:                                         aCharSetID);
 1300:   }
 1300: }
 1300: 
    1: nsresult
    1: nsHTMLDocument::StartDocumentLoad(const char* aCommand,
    1:                                   nsIChannel* aChannel,
    1:                                   nsILoadGroup* aLoadGroup,
    1:                                   nsISupports* aContainer,
    1:                                   nsIStreamListener **aDocListener,
    1:                                   PRBool aReset,
    1:                                   nsIContentSink* aSink)
    1: {
    1:   nsCAutoString contentType;
    1:   aChannel->GetContentType(contentType);
    1: 
    1:   if (contentType.Equals("application/xhtml+xml") &&
    1:       (!aCommand || nsCRT::strcmp(aCommand, "view-source") != 0)) {
    1:     // We're parsing XHTML as XML, remember that.
    1: 
15474:     mIsRegularHTML = PR_FALSE;
    1:     mCompatMode = eCompatibility_FullStandards;
    1:   }
    1: #ifdef DEBUG
    1:   else {
15474:     NS_ASSERTION(mIsRegularHTML,
15474:                  "Hey, someone forgot to reset mIsRegularHTML!!!");
    1:   }
    1: #endif
    1: 
    1:   CSSLoader()->SetCaseSensitive(IsXHTML());
    1:   CSSLoader()->SetCompatibilityMode(mCompatMode);
    1:   
    1:   PRBool needsParser = PR_TRUE;
    1:   if (aCommand)
    1:   {
    1:     if (!nsCRT::strcmp(aCommand, "view delayedContentLoad")) {
    1:       needsParser = PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsICacheEntryDescriptor> cacheDescriptor;
    1:   nsresult rv = nsDocument::StartDocumentLoad(aCommand,
    1:                                               aChannel, aLoadGroup,
    1:                                               aContainer,
    1:                                               aDocListener, aReset);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // Store the security info for future use with wyciwyg channels.
    1:   aChannel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   rv = aChannel->GetURI(getter_AddRefs(uri));
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsICachingChannel> cachingChan = do_QueryInterface(aChannel);
    1:   if (cachingChan) {
    1:     nsCOMPtr<nsISupports> cacheToken;
    1:     cachingChan->GetCacheToken(getter_AddRefs(cacheToken));
    1:     if (cacheToken)
    1:       cacheDescriptor = do_QueryInterface(cacheToken);
    1:   }
    1: 
    1:   if (needsParser) {
    1:     mParser = do_CreateInstance(kCParserCID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(aContainer));
    1: 
    1:   nsCOMPtr<nsIDocumentCharsetInfo> dcInfo;
    1:   docShell->GetDocumentCharsetInfo(getter_AddRefs(dcInfo));
    1:   PRInt32 textType = GET_BIDI_OPTION_TEXTTYPE(GetBidiOptions());
    1: 
    1:   // Look for the parent document.  Note that at this point we don't have our
    1:   // content viewer set up yet, and therefore do not have a useful
    1:   // mParentDocument.
    1: 
    1:   // in this block of code, if we get an error result, we return it
    1:   // but if we get a null pointer, that's perfectly legal for parent
    1:   // and parentContentViewer
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(docShell));
    1:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
    1:   docShellAsItem->GetSameTypeParent(getter_AddRefs(parentAsItem));
    1: 
    1:   nsCOMPtr<nsIDocShell> parent(do_QueryInterface(parentAsItem));
    1:   nsCOMPtr<nsIDocument> parentDocument;
    1:   nsCOMPtr<nsIContentViewer> parentContentViewer;
    1:   if (parent) {
    1:     rv = parent->GetContentViewer(getter_AddRefs(parentContentViewer));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     nsCOMPtr<nsIDocumentViewer> docViewer =
    1:       do_QueryInterface(parentContentViewer);
    1:     if (docViewer) {
    1:       docViewer->GetDocument(getter_AddRefs(parentDocument));
    1:     }
    1:   }
    1: 
    1:   //
    1:   // The following logic is mirrored in nsWebShell::Embed!
    1:   //
    1:   nsCOMPtr<nsIMarkupDocumentViewer> muCV;
    1:   PRBool muCVIsParent = PR_FALSE;
    1:   nsCOMPtr<nsIContentViewer> cv;
    1:   docShell->GetContentViewer(getter_AddRefs(cv));
    1:   if (cv) {
    1:      muCV = do_QueryInterface(cv);
    1:   } else {
    1:     muCV = do_QueryInterface(parentContentViewer);
    1:     if (muCV) {
    1:       muCVIsParent = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   nsCAutoString scheme;
    1:   uri->GetScheme(scheme);
    1: 
    1:   nsCAutoString urlSpec;
    1:   uri->GetSpec(urlSpec);
    1: #ifdef DEBUG_charset
    1:   printf("Determining charset for %s\n", urlSpec.get());
    1: #endif
    1: 
 1300:   // These are the charset source and charset for our document
    1:   PRInt32 charsetSource;
    1:   nsCAutoString charset;
    1: 
 1300:   // These are the charset source and charset for the parser.  This can differ
 1300:   // from that for the document if the channel is a wyciwyg channel.
 1300:   PRInt32 parserCharsetSource;
 1300:   nsCAutoString parserCharset;
 1300: 
 1300:   nsCOMPtr<nsIWyciwygChannel> wyciwygChannel;
 1300:   
    1:   if (IsXHTML()) {
    1:     charsetSource = kCharsetFromDocTypeDefault;
    1:     charset.AssignLiteral("UTF-8");
    1:     TryChannelCharset(aChannel, charsetSource, charset);
 1300:     parserCharsetSource = charsetSource;
 1300:     parserCharset = charset;
    1:   } else {
    1:     charsetSource = kCharsetUninitialized;
 1300:     wyciwygChannel = do_QueryInterface(aChannel);
    1: 
    1:     // The following charset resolving calls has implied knowledge
    1:     // about charset source priority order. Each try will return true
    1:     // if the source is higher or equal to the source as its name
    1:     // describes. Some try call might change charset source to
    1:     // multiple values, like TryHintCharset and TryParentCharset. It
    1:     // should be always safe to try more sources.
    1:     if (!TryUserForcedCharset(muCV, dcInfo, charsetSource, charset)) {
    1:       TryHintCharset(muCV, charsetSource, charset);
    1:       TryParentCharset(dcInfo, parentDocument, charsetSource, charset);
 1300: 
 1300:       // Don't actually get the charset from the channel if this is a
 1300:       // wyciwyg channel; it'll always be UTF-16
 1300:       if (!wyciwygChannel &&
 1300:           TryChannelCharset(aChannel, charsetSource, charset)) {
    1:         // Use the channel's charset (e.g., charset from HTTP
    1:         // "Content-Type" header).
    1:       }
    1:       else if (!scheme.EqualsLiteral("about") &&          // don't try to access bookmarks for about:blank
    1:                TryBookmarkCharset(docShell, aChannel, charsetSource, charset)) {
    1:         // Use the bookmark's charset.
    1:       }
    1:       else if (cacheDescriptor && !urlSpec.IsEmpty() &&
    1:                TryCacheCharset(cacheDescriptor, charsetSource, charset)) {
    1:         // Use the cache's charset.
    1:       }
    1:       else if (TryDefaultCharset(muCV, charsetSource, charset)) {
    1:         // Use the default charset.
    1:         // previous document charset might be inherited as default charset.
    1:       }
    1:       else {
    1:         // Use the weak doc type default charset
    1:         UseWeakDocTypeDefault(charsetSource, charset);
    1:       }
    1:     }
    1: 
    1:     PRBool isPostPage = PR_FALSE;
    1:     // check if current doc is from POST command
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:     if (httpChannel) {
    1:       nsCAutoString methodStr;
    1:       rv = httpChannel->GetRequestMethod(methodStr);
    1:       isPostPage = (NS_SUCCEEDED(rv) &&
    1:                     methodStr.EqualsLiteral("POST"));
    1:     }
    1: 
    1:     if (isPostPage && muCV && kCharsetFromHintPrevDoc > charsetSource) {
    1:       nsCAutoString requestCharset;
    1:       muCV->GetPrevDocCharacterSet(requestCharset);
    1:       if (!requestCharset.IsEmpty()) {
    1:         charsetSource = kCharsetFromHintPrevDoc;
    1:         charset = requestCharset;
    1:       }
    1:     }
    1: 
 1300:     if (wyciwygChannel) {
 1300:       // We know for sure that the parser needs to be using UTF16.
 1300:       parserCharset = "UTF-16";
 1300:       parserCharsetSource = charsetSource < kCharsetFromChannel ?
 1300:         kCharsetFromChannel : charsetSource;
 1300:         
 1300:       nsCAutoString cachedCharset;
 1300:       PRInt32 cachedSource;
 1300:       rv = wyciwygChannel->GetCharsetAndSource(&cachedSource, cachedCharset);
 1300:       if (NS_SUCCEEDED(rv)) {
 1300:         if (cachedSource > charsetSource) {
 1300:           charsetSource = cachedSource;
 1300:           charset = cachedCharset;
 1300:         }
 1300:       } else {
 1300:         // Don't propagate this error.
 1300:         rv = NS_OK;
 1300:       }
 1300:       
 1300:     } else {
 1300:       parserCharset = charset;
 1300:       parserCharsetSource = charsetSource;
 1300:     }
 1300: 
    1:     if(kCharsetFromAutoDetection > charsetSource && !isPostPage) {
    1:       StartAutodetection(docShell, charset, aCommand);
    1:     }
    1: 
    1:     // ahmed
    1:     // Check if 864 but in Implicit mode !
 1300:     // XXXbz why is this happening after StartAutodetection ?
    1:     if ((textType == IBMBIDI_TEXTTYPE_LOGICAL) &&
    1:         (charset.LowerCaseEqualsLiteral("ibm864"))) {
    1:       charset.AssignLiteral("IBM864i");
    1:     }
    1:   }
    1: 
 1300:   SetDocumentCharacterSetSource(charsetSource);
    1:   SetDocumentCharacterSet(charset);
    1: 
    1:   // set doc charset to muCV for next document.
    1:   // Don't propagate this back up to the parent document if we have one.
    1:   if (muCV && !muCVIsParent)
    1:     muCV->SetPrevDocCharacterSet(charset);
    1: 
    1:   if(cacheDescriptor) {
 1300:     NS_ASSERTION(charset == parserCharset,
 1300:                  "How did those end up different here?  wyciwyg channels are "
 1300:                  "not nsICachingChannel");
    1:     rv = cacheDescriptor->SetMetaDataElement("charset",
    1:                                              charset.get());
    1:     NS_ASSERTION(NS_SUCCEEDED(rv),"cannot SetMetaDataElement");
    1:   }
    1: 
    1:   // Set the parser as the stream listener for the document loader...
    1:   if (mParser) {
    1:     rv = CallQueryInterface(mParser, aDocListener);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1: #ifdef DEBUG_charset
    1:     printf(" charset = %s source %d\n",
    1:           charset.get(), charsetSource);
    1: #endif
 1300:     mParser->SetDocumentCharset(parserCharset, parserCharsetSource);
    1:     mParser->SetCommand(aCommand);
    1: 
    1:     // create the content sink
    1:     nsCOMPtr<nsIContentSink> sink;
    1: 
    1:     if (aSink)
    1:       sink = aSink;
    1:     else {
    1:       if (IsXHTML()) {
    1:         nsCOMPtr<nsIXMLContentSink> xmlsink;
    1:         rv = NS_NewXMLContentSink(getter_AddRefs(xmlsink), this, uri,
    1:                                   docShell, aChannel);
    1: 
    1:         sink = xmlsink;
    1:       } else {
    1:         nsCOMPtr<nsIHTMLContentSink> htmlsink;
    1: 
    1:         rv = NS_NewHTMLContentSink(getter_AddRefs(htmlsink), this, uri,
    1:                                    docShell, aChannel);
    1: 
    1:         sink = htmlsink;
    1:       }
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       NS_ASSERTION(sink,
    1:                    "null sink with successful result from factory method");
    1:     }
    1: 
    1:     mParser->SetContentSink(sink);
    1:     // parser the content of the URI
    1:     mParser->Parse(uri, nsnull, (void *)this);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::StopDocumentLoad()
    1: {
    1:   // If we're writing (i.e., there's been a document.open call), then
    1:   // nsDocument::StopDocumentLoad will do the wrong thing and simply terminate
    1:   // our parser.
    1:   if (mWriteState != eNotWriting) {
    1:     Close();
    1:   } else {
    1:     nsDocument::StopDocumentLoad();
    1:   }
    1: }
    1: 
    1: // static
    1: void
    1: nsHTMLDocument::DocumentWriteTerminationFunc(nsISupports *aRef)
    1: {
    1:   nsCOMPtr<nsIArray> arr = do_QueryInterface(aRef);
    1:   NS_ASSERTION(arr, "Must have array!");
    1: 
    1:   nsCOMPtr<nsIDocument> doc = do_QueryElementAt(arr, 0);
    1:   NS_ASSERTION(doc, "Must have document!");
    1:   
    1:   nsCOMPtr<nsIParser> parser = do_QueryElementAt(arr, 1);
    1:   NS_ASSERTION(parser, "Must have parser!");
    1: 
 3233:   nsHTMLDocument *htmldoc = static_cast<nsHTMLDocument*>(doc.get());
    1: 
    1:   // Check whether htmldoc still has the same parser.  If not, it's
    1:   // not for us to mess with it.
    1:   if (htmldoc->mParser != parser) {
    1:     return;
    1:   }
    1: 
    1:   // If the document is in the middle of a document.write() call, this
    1:   // most likely means that script on a page document.write()'d out a
    1:   // script tag that did location="..." and we're right now finishing
    1:   // up executing the script that was written with
    1:   // document.write(). Since there's still script on the stack (the
    1:   // script that called document.write()) we don't want to release the
    1:   // parser now, that would cause the next document.write() call to
    1:   // cancel the load that was initiated by the location="..." in the
    1:   // script that was written out by document.write().
    1: 
    1:   if (!htmldoc->mWriteLevel && htmldoc->mWriteState != eDocumentOpened) {
    1:     // Release the document's parser so that the call to EndLoad()
    1:     // doesn't just return early and set the termination function again.
    1: 
    1:     htmldoc->mParser = nsnull;
    1:   }
    1: 
    1:   htmldoc->EndLoad();
    1: }
    1: 
    1: void
    1: nsHTMLDocument::EndLoad()
    1: {
    1:   if (mParser && mWriteState != eDocumentClosed) {
    1:     nsCOMPtr<nsIJSContextStack> stack =
    1:       do_GetService("@mozilla.org/js/xpc/ContextStack;1");
    1: 
    1:     if (stack) {
    1:       JSContext *cx = nsnull;
    1:       stack->Peek(&cx);
    1: 
    1:       if (cx) {
    1:         nsIScriptContext *scx = nsJSUtils::GetDynamicScriptContext(cx);
    1: 
    1:         if (scx) {
    1:           // The load of the document was terminated while we're
    1:           // called from within JS and we have a parser (i.e. we're in
    1:           // the middle of doing document.write()). In stead of
    1:           // releasing the parser and ending the document load
    1:           // directly, we'll make that happen once the script is done
    1:           // executing. This way subsequent document.write() calls
    1:           // won't end up creating a new parser and interrupting other
    1:           // loads that were started while the script was
    1:           // running. I.e. this makes the following case work as
    1:           // expected:
    1:           //
    1:           //   document.write("foo");
    1:           //   location.href = "http://www.mozilla.org";
    1:           //   document.write("bar");
    1: 
    1:           nsresult rv;
    1: 
    1:           nsCOMPtr<nsIMutableArray> arr =
    1:             do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
    1:           if (NS_SUCCEEDED(rv)) {
 3233:             rv = arr->AppendElement(static_cast<nsIDocument*>(this),
    1:                                     PR_FALSE);
    1:             if (NS_SUCCEEDED(rv)) {
    1:               rv = arr->AppendElement(mParser, PR_FALSE);
    1:               if (NS_SUCCEEDED(rv)) {
    1:                 rv = scx->SetTerminationFunction(DocumentWriteTerminationFunc,
    1:                                                  arr);
    1:                 // If we fail to set the termination function, just go ahead
    1:                 // and EndLoad now.  The slight bugginess involved is better
    1:                 // than leaking.
    1:                 if (NS_SUCCEEDED(rv)) {
    1:                   return;
    1:                 }
    1:               }
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Reset this now, since we're really done "loading" this document.written
    1:   // document.
    1:   NS_ASSERTION(mWriteState == eNotWriting || mWriteState == ePendingClose ||
    1:                mWriteState == eDocumentClosed, "EndLoad called early");
    1:   mWriteState = eNotWriting;
    1: 
 2896:   PRBool turnOnEditing =
 2896:     mParser && (HasFlag(NODE_IS_EDITABLE) || mContentEditableCount > 0);
    1:   // Note: nsDocument::EndLoad nulls out mParser.
    1:   nsDocument::EndLoad();
 2896:   if (turnOnEditing) {
 2896:     EditingStateChanged();
 2896:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetTitle(const nsAString& aTitle)
    1: {
    1:   return nsDocument::SetTitle(aTitle);
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::AddImageMap(nsIDOMHTMLMapElement* aMap)
    1: {
    1:   // XXX We should order the maps based on their order in the document.
    1:   // XXX Otherwise scripts that add/remove maps with duplicate names
    1:   // XXX will cause problems
    1:   NS_PRECONDITION(nsnull != aMap, "null ptr");
    1:   if (nsnull == aMap) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   if (mImageMaps.AppendObject(aMap)) {
    1:     return NS_OK;
    1:   }
    1:   return NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::RemoveImageMap(nsIDOMHTMLMapElement* aMap)
    1: {
    1:   NS_PRECONDITION(nsnull != aMap, "null ptr");
    1:   mImageMaps.RemoveObject(aMap);
    1: }
    1: 
    1: nsIDOMHTMLMapElement *
    1: nsHTMLDocument::GetImageMap(const nsAString& aMapName)
    1: {
    1:   nsAutoString name;
    1:   PRUint32 i, n = mImageMaps.Count();
    1:   nsIDOMHTMLMapElement *firstMatch = nsnull;
    1: 
    1:   for (i = 0; i < n; ++i) {
    1:     nsIDOMHTMLMapElement *map = mImageMaps[i];
    1:     NS_ASSERTION(map, "Null map in map list!");
    1: 
    1:     PRBool match;
    1:     nsresult rv;
    1: 
    1:     if (IsXHTML()) {
    1:       rv = map->GetId(name);
    1: 
    1:       match = name.Equals(aMapName);
    1:     } else {
    1:       rv = map->GetName(name);
    1: 
    1:       match = name.Equals(aMapName, nsCaseInsensitiveStringComparator());
    1:     }
    1: 
    1:     if (match && NS_SUCCEEDED(rv)) {
    1:       // Quirk: if the first matching map is empty, remember it, but keep
    1:       // searching for a non-empty one, only use it if none was found (bug 264624).
    1:       if (mCompatMode == eCompatibility_NavQuirks) {
    1:         nsCOMPtr<nsIDOMHTMLCollection> mapAreas;
    1:         rv = map->GetAreas(getter_AddRefs(mapAreas));
    1:         if (NS_SUCCEEDED(rv) && mapAreas) {
    1:           PRUint32 length = 0;
    1:           mapAreas->GetLength(&length);
    1:           if (length == 0) {
    1:             if (!firstMatch) {
    1:               firstMatch = map;
    1:             }
    1:             continue;
    1:           }
    1:         }
    1:       }
    1:       return map;
    1:     }
    1:   }
    1: 
    1:   return firstMatch;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::SetCompatibilityMode(nsCompatibility aMode)
    1: {
    1:   NS_ASSERTION(!IsXHTML() || aMode == eCompatibility_FullStandards,
    1:                "Bad compat mode for XHTML document!");
    1: 
    1:   mCompatMode = aMode;
    1:   CSSLoader()->SetCompatibilityMode(mCompatMode);
  981:   nsCOMPtr<nsIPresShell> shell = GetPrimaryShell();
    1:   if (shell) {
    1:     nsPresContext *pc = shell->GetPresContext();
    1:     if (pc) {
    1:       pc->CompatibilityModeChanged();
    1:     }
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsHTMLDocument::IsCaseSensitive()
    1: {
    1:   return IsXHTML();
    1: }
    1: 
    1: //
    1: // nsIDOMDocument interface implementation
    1: //
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateElement(const nsAString& aTagName,
    1:                               nsIDOMElement** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1:   nsresult rv;
    1: 
    1:   nsAutoString tagName(aTagName);
    1: 
    1:   // if we are in quirks, allow surrounding '<' '>' for IE compat
    1:   if (mCompatMode == eCompatibility_NavQuirks &&
    1:       tagName.Length() > 2 &&
    1:       tagName.First() == '<' &&
    1:       tagName.Last() == '>') {
    1:     tagName = Substring(tagName, 1, tagName.Length() - 2); 
    1:   }
    1: 
    1:   rv = nsContentUtils::CheckQName(tagName, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!IsXHTML()) {
    1:     ToLowerCase(tagName);
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(tagName);
    1: 
    1:   nsCOMPtr<nsIContent> content;
    1:   rv = CreateElem(name, nsnull, GetDefaultNamespaceID(), PR_TRUE,
    1:                   getter_AddRefs(content));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return CallQueryInterface(content, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateElementNS(const nsAString& aNamespaceURI,
    1:                                 const nsAString& aQualifiedName,
    1:                                 nsIDOMElement** aReturn)
    1: {
    1:   return nsDocument::CreateElementNS(aNamespaceURI, aQualifiedName, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateProcessingInstruction(const nsAString& aTarget,
    1:                                             const nsAString& aData,
    1:                                             nsIDOMProcessingInstruction** aReturn)
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::CreateProcessingInstruction(aTarget, aData, aReturn);
    1:   }
    1: 
    1:   // There are no PIs for HTML
    1:   *aReturn = nsnull;
    1: 
    1:   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateCDATASection(const nsAString& aData,
    1:                                    nsIDOMCDATASection** aReturn)
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::CreateCDATASection(aData, aReturn);
    1:   }
    1: 
    1:   // There are no CDATASections in HTML
    1:   *aReturn = nsnull;
    1: 
    1:   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateEntityReference(const nsAString& aName,
    1:                                       nsIDOMEntityReference** aReturn)
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::CreateEntityReference(aName, aReturn);
    1:   }
    1: 
    1:   // There are no EntityReferences in HTML
    1:   *aReturn = nsnull;
    1: 
    1:   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetDoctype(nsIDOMDocumentType** aDocumentType)
    1: {
    1:   return nsDocument::GetDoctype(aDocumentType);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetImplementation(nsIDOMDOMImplementation** aImplementation)
    1: {
    1:   return nsDocument::GetImplementation(aImplementation);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetDocumentElement(nsIDOMElement** aDocumentElement)
    1: {
    1:   return nsDocument::GetDocumentElement(aDocumentElement);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateDocumentFragment(nsIDOMDocumentFragment** aReturn)
    1: {
    1:   return nsDocument::CreateDocumentFragment(aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateComment(const nsAString& aData, nsIDOMComment** aReturn)
    1: {
    1:   return nsDocument::CreateComment(aData, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateAttribute(const nsAString& aName, nsIDOMAttr** aReturn)
    1: {
    1:   return nsDocument::CreateAttribute(aName, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateTextNode(const nsAString& aData, nsIDOMText** aReturn)
    1: {
    1:   return nsDocument::CreateTextNode(aData, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetElementsByTagName(const nsAString& aTagname,
    1:                                      nsIDOMNodeList** aReturn)
    1: {
    1:   nsAutoString tmp(aTagname);
    1:   if (!IsXHTML()) {
    1:     ToLowerCase(tmp); // HTML elements are lower case internally.
    1:   }
    1:   return nsDocument::GetElementsByTagName(tmp, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetBaseURI(nsAString &aURI)
    1: {
    1:   aURI.Truncate();
    1:   nsIURI *uri = mDocumentBaseURI; // WEAK
    1: 
    1:   if (!uri) {
    1:     uri = mDocumentURI;
    1:   }
    1: 
    1:   if (uri) {
    1:     nsCAutoString spec;
    1:     uri->GetSpec(spec);
    1: 
    1:     CopyUTF8toUTF16(spec, aURI);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIDOM3Document interface implementation
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetXmlEncoding(nsAString& aXmlEncoding)
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::GetXmlEncoding(aXmlEncoding);
    1:   }
    1: 
    1:   SetDOMStringToNull(aXmlEncoding);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetXmlStandalone(PRBool *aXmlStandalone)
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::GetXmlStandalone(aXmlStandalone);
    1:   }
    1: 
    1:   *aXmlStandalone = PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetXmlStandalone(PRBool aXmlStandalone)
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::SetXmlStandalone(aXmlStandalone);
    1:   }
    1: 
    1:   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetXmlVersion(nsAString& aXmlVersion)
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::GetXmlVersion(aXmlVersion);
    1:   }
    1: 
    1:   SetDOMStringToNull(aXmlVersion);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetXmlVersion(const nsAString& aXmlVersion)
    1: {
    1:   if (IsXHTML()) {
    1:     return nsDocument::SetXmlVersion(aXmlVersion);
    1:   }
    1: 
    1:   return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: }
    1: 
    1: //
    1: // nsIDOMHTMLDocument interface implementation
    1: //
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetTitle(nsAString& aTitle)
    1: {
    1:   return nsDocument::GetTitle(aTitle);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetReferrer(nsAString& aReferrer)
    1: {
    1:   return nsDocument::GetReferrer(aReferrer);
    1: }
    1: 
    1: void
    1: nsHTMLDocument::GetDomainURI(nsIURI **aURI)
    1: {
    1:   nsIPrincipal *principal = NodePrincipal();
    1: 
    1:   principal->GetDomain(aURI);
    1:   if (!*aURI) {
    1:     principal->GetURI(aURI);
    1:   }
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetDomain(nsAString& aDomain)
    1: {
    1:   nsCOMPtr<nsIURI> uri;
    1:   GetDomainURI(getter_AddRefs(uri));
    1: 
    1:   if (!uri) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCAutoString hostName;
    1: 
    1:   if (NS_SUCCEEDED(uri->GetHost(hostName))) {
    1:     CopyUTF8toUTF16(hostName, aDomain);
    1:   } else {
    1:     // If we can't get the host from the URI (e.g. about:, javascript:,
    1:     // etc), just return an null string.
    1:     SetDOMStringToNull(aDomain);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetDomain(const nsAString& aDomain)
    1: {
    1:   if (aDomain.IsEmpty())
    1:     return NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN;
    1: 
    1:   // Create new URI
    1:   nsCOMPtr<nsIURI> uri;
    1:   GetDomainURI(getter_AddRefs(uri));
    1: 
    1:   if (!uri) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
 9732:   nsCAutoString newURIString;
 9732:   if (NS_FAILED(uri->GetScheme(newURIString)))
 9732:     return NS_ERROR_FAILURE;
 9732:   nsCAutoString path;
 9732:   if (NS_FAILED(uri->GetPath(path)))
 9732:     return NS_ERROR_FAILURE;
 9732:   newURIString.AppendLiteral("://");
 9732:   AppendUTF16toUTF8(aDomain, newURIString);
 9732:   newURIString.Append(path);
 9732: 
    1:   nsCOMPtr<nsIURI> newURI;
 9732:   if (NS_FAILED(NS_NewURI(getter_AddRefs(newURI), newURIString)))
 9732:     return NS_ERROR_FAILURE;
    1: 
 7845:   // Check new domain - must be a superdomain of the current host
 7845:   // For example, a page from foo.bar.com may set domain to bar.com,
 7845:   // but not to ar.com, baz.com, or fi.foo.bar.com.
 7845:   nsCAutoString current, domain;
11364:   if (NS_FAILED(uri->GetAsciiHost(current)))
 7845:     current.Truncate();
11364:   if (NS_FAILED(newURI->GetAsciiHost(domain)))
 7845:     domain.Truncate();
 7845: 
 7845:   PRBool ok = current.Equals(domain);
 7845:   if (current.Length() > domain.Length() &&
 7845:       StringEndsWith(current, domain) &&
 7845:       current.CharAt(current.Length() - domain.Length() - 1) == '.') {
11364:     // We're golden if the new domain is the current page's base domain or a
11364:     // subdomain of it.
 7845:     nsCOMPtr<nsIEffectiveTLDService> tldService =
 7845:       do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID);
 7845:     if (!tldService)
 7845:       return NS_ERROR_NOT_AVAILABLE;
 7845: 
11364:     nsCAutoString currentBaseDomain;
11364:     ok = NS_SUCCEEDED(tldService->GetBaseDomain(uri, 0, currentBaseDomain));
11364:     NS_ASSERTION(StringEndsWith(domain, currentBaseDomain) ==
11364:                  (domain.Length() >= currentBaseDomain.Length()),
11364:                  "uh-oh!  slight optimization wasn't valid somehow!");
11364:     ok = ok && domain.Length() >= currentBaseDomain.Length();
 7845:   }
 7845:   if (!ok) {
 7845:     // Error: illegal domain
 7845:     return NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN;
 7845:   }
 7845: 
    1:   return NodePrincipal()->SetDomain(newURI);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetURL(nsAString& aURL)
    1: {
    1:   nsCAutoString str;
    1: 
    1:   if (mDocumentURI) {
    1:     mDocumentURI->GetSpec(str);
    1:   }
    1: 
    1:   CopyUTF8toUTF16(str, aURL);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetBody(nsIDOMHTMLElement** aBody)
    1: {
    1:   *aBody = nsnull;
    1: 
 8938:   nsIContent* body = GetBodyContent();
 8938: 
 8938:   if (body) {
    1:     // There is a body element, return that as the body.
 8938:     return CallQueryInterface(body, aBody);
 8938:   }
 8938: 
    1:   // The document is most likely a frameset document so look for the
    1:   // outer most frameset element
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1: 
    1:   nsresult rv;
    1:   if (IsXHTML()) {
    1:     rv = GetElementsByTagNameNS(NS_LITERAL_STRING("http://www.w3.org/1999/xhtml"),
    1:                                 NS_LITERAL_STRING("frameset"),
    1:                                 getter_AddRefs(nodeList));
    1:   } else {
    1:     rv = GetElementsByTagName(NS_LITERAL_STRING("frameset"),
    1:                               getter_AddRefs(nodeList));
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
 8938: 
 8938:   nsCOMPtr<nsIDOMNode> node;
 8938:   nodeList->Item(0, getter_AddRefs(node));
 8938: 
 8938:   return node ? CallQueryInterface(node, aBody) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetBody(nsIDOMHTMLElement* aBody)
    1: {
 8938:   nsCOMPtr<nsIContent> newBody = do_QueryInterface(aBody);
 8938:   nsIContent* root = GetRootContent();
 8938: 
 8938:   // The body element must be either a body tag or a frameset tag. And we must
 8938:   // have a html root tag, otherwise GetBody will not return the newly set
 8938:   // body.
 8938:   if (!newBody || !(newBody->Tag() == nsGkAtoms::body ||
 8938:                     newBody->Tag() == nsGkAtoms::frameset) ||
 8938:       !root || !root->IsNodeOfType(nsINode::eHTML) ||
 8938:       root->Tag() != nsGkAtoms::html) {
    1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:   }
    1: 
 8938:   nsCOMPtr<nsIDOMElement> rootElem = do_QueryInterface(root);
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1: 
 8938:   // Use DOM methods so that we pass through the appropriate security checks.
 8938:   nsCOMPtr<nsIDOMNode> currentBody = do_QueryInterface(GetBodyContent());
 8938:   if (currentBody) {
 8938:     return rootElem->ReplaceChild(aBody, currentBody, getter_AddRefs(tmp));
 8938:   }
 8938: 
 8938:   return rootElem->AppendChild(aBody, getter_AddRefs(tmp));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetImages(nsIDOMHTMLCollection** aImages)
    1: {
    1:   if (!mImages) {
15474:     mImages = new nsContentList(this, nsGkAtoms::img, GetDefaultNamespaceID());
    1:     if (!mImages) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   *aImages = mImages;
    1:   NS_ADDREF(*aImages);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetApplets(nsIDOMHTMLCollection** aApplets)
    1: {
    1:   if (!mApplets) {
    1:     mApplets = new nsContentList(this, nsGkAtoms::applet,
15474:                                  GetDefaultNamespaceID());
    1:     if (!mApplets) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   *aApplets = mApplets;
    1:   NS_ADDREF(*aApplets);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsHTMLDocument::MatchLinks(nsIContent *aContent, PRInt32 aNamespaceID,
    1:                            nsIAtom* aAtom, void* aData)
    1: {
    1:   nsIDocument* doc = aContent->GetCurrentDoc();
    1: 
    1:   if (doc) {
    1:     NS_ASSERTION(aContent->IsInDoc(),
    1:                  "This method should never be called on content nodes that "
    1:                  "are not in a document!");
    1: #ifdef DEBUG
    1:     {
    1:       nsCOMPtr<nsIHTMLDocument> htmldoc =
    1:         do_QueryInterface(aContent->GetCurrentDoc());
    1:       NS_ASSERTION(htmldoc,
    1:                    "Huh, how did this happen? This should only be used with "
    1:                    "HTML documents!");
    1:     }
    1: #endif
    1: 
    1:     nsINodeInfo *ni = aContent->NodeInfo();
    1:     PRInt32 namespaceID = doc->GetDefaultNamespaceID();
    1: 
    1:     nsIAtom *localName = ni->NameAtom();
    1:     if (ni->NamespaceID() == namespaceID &&
    1:         (localName == nsGkAtoms::a || localName == nsGkAtoms::area)) {
    1:       return aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::href);
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetLinks(nsIDOMHTMLCollection** aLinks)
    1: {
    1:   if (!mLinks) {
    1:     mLinks = new nsContentList(this, MatchLinks, nsnull, nsnull);
    1:     if (!mLinks) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   *aLinks = mLinks;
    1:   NS_ADDREF(*aLinks);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsHTMLDocument::MatchAnchors(nsIContent *aContent, PRInt32 aNamespaceID,
    1:                              nsIAtom* aAtom, void* aData)
    1: {
    1:   NS_ASSERTION(aContent->IsInDoc(),
    1:                "This method should never be called on content nodes that "
    1:                "are not in a document!");
    1: #ifdef DEBUG
    1:   {
    1:     nsCOMPtr<nsIHTMLDocument> htmldoc =
    1:       do_QueryInterface(aContent->GetCurrentDoc());
    1:     NS_ASSERTION(htmldoc,
    1:                  "Huh, how did this happen? This should only be used with "
    1:                  "HTML documents!");
    1:   }
    1: #endif
    1: 
    1:   PRInt32 namespaceID = aContent->GetCurrentDoc()->GetDefaultNamespaceID();
    1:   if (aContent->NodeInfo()->Equals(nsGkAtoms::a, namespaceID)) {
    1:     return aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::name);
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetAnchors(nsIDOMHTMLCollection** aAnchors)
    1: {
    1:   if (!mAnchors) {
    1:     mAnchors = new nsContentList(this, MatchAnchors, nsnull, nsnull);
    1:     if (!mAnchors) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   *aAnchors = mAnchors;
    1:   NS_ADDREF(*aAnchors);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetCookie(nsAString& aCookie)
    1: {
    1:   aCookie.Truncate(); // clear current cookie in case service fails;
    1:                       // no cookie isn't an error condition.
    1: 
    1:   // not having a cookie service isn't an error
    1:   nsCOMPtr<nsICookieService> service = do_GetService(NS_COOKIESERVICE_CONTRACTID);
    1:   if (service) {
    1:     // Get a URI from the document principal. We use the original
    1:     // codebase in case the codebase was changed by SetDomain
    1:     nsCOMPtr<nsIURI> codebaseURI;
    1:     NodePrincipal()->GetURI(getter_AddRefs(codebaseURI));
    1: 
    1:     if (!codebaseURI) {
    1:       // Document's principal is not a codebase (may be system), so
    1:       // can't set cookies
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsXPIDLCString cookie;
    1:     service->GetCookieString(codebaseURI, mChannel, getter_Copies(cookie));
    1:     CopyASCIItoUTF16(cookie, aCookie);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetCookie(const nsAString& aCookie)
    1: {
    1:   // not having a cookie service isn't an error
    1:   nsCOMPtr<nsICookieService> service = do_GetService(NS_COOKIESERVICE_CONTRACTID);
    1:   if (service && mDocumentURI) {
    1:     nsCOMPtr<nsIPrompt> prompt;
    1:     nsCOMPtr<nsPIDOMWindow> window = GetWindow();
    1:     if (window) {
    1:       window->GetPrompter(getter_AddRefs(prompt));
    1:     }
    1: 
    1:     nsCOMPtr<nsIURI> codebaseURI;
    1:     NodePrincipal()->GetURI(getter_AddRefs(codebaseURI));
    1: 
    1:     if (!codebaseURI) {
    1:       // Document's principal is not a codebase (may be system), so
    1:       // can't set cookies
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     NS_LossyConvertUTF16toASCII cookie(aCookie);
    1:     service->SetCookieString(codebaseURI, prompt, cookie.get(), mChannel);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // XXX TBI: accepting arguments to the open method.
    1: nsresult
    1: nsHTMLDocument::OpenCommon(const nsACString& aContentType, PRBool aReplace)
    1: {
    1:   if (IsXHTML()) {
    1:     // No calling document.open() on XHTML
    1: 
    1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // If we already have a parser we ignore the document.open call.
    1:   if (mParser) {
    1: 
    1:     return NS_OK;
    1:   }
    1: 
 8565:   NS_ASSERTION(nsContentUtils::CanCallerAccess(static_cast<nsIDOMHTMLDocument*>(this)),
 8565:                "XOW should have caught this!");
    1: 
    1:   if (!aContentType.EqualsLiteral("text/html") &&
    1:       !aContentType.EqualsLiteral("text/plain")) {
    1:     NS_WARNING("Unsupported type; fix the caller");
    1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:   }
    1: 
 2400:   // check whether we're in the middle of unload.  If so, ignore this call.
 2400:   nsCOMPtr<nsIDocShell> shell = do_QueryReferent(mDocumentContainer);
15756:   if (!shell) {
15756:     // We won't be able to create a parser anyway.
15756:     return NS_OK;
15756:   }
15756: 
 2400:   PRBool inUnload;
 2400:   shell->GetIsInUnload(&inUnload);
 2400:   if (inUnload) {
 2400:     return NS_OK;
 2400:   }
 2400: 
    1:   // Note: We want to use GetDocumentFromContext here because this document
    1:   // should inherit the security information of the document that's opening us,
    1:   // (since if it's secure, then it's presumeably trusted).
    1:   nsCOMPtr<nsIDocument> callerDoc =
    1:     do_QueryInterface(nsContentUtils::GetDocumentFromContext());
    1: 
    1:   // Grab a reference to the calling documents security info (if any)
    1:   // and principal as it may be lost in the call to Reset().
    1:   nsCOMPtr<nsISupports> securityInfo;
    1:   if (callerDoc) {
    1:     securityInfo = callerDoc->GetSecurityInfo();
    1:   }
    1: 
    1:   nsCOMPtr<nsIPrincipal> callerPrincipal;
10689:   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
10689: 
10689:   secMan->GetSubjectPrincipal(getter_AddRefs(callerPrincipal));
10689: 
10689:   if (!callerPrincipal) {
10689:     // If we're called from C++ we can't do a document.open w/o
10689:     // changing the principal of the document to something like
10689:     // about:blank (as that's the only sane thing to do when we don't
10689:     // know the origin of this call), and since we can't change the
10689:     // principals of a document for security reasons we'll have to
10689:     // refuse to go ahead with this call.
10689: 
10689:     return NS_ERROR_DOM_SECURITY_ERR;
10689:   }
10689: 
10689:   // We're called from script. Make sure the script is from the same
10689:   // origin, not just that the caller can access the document. This is
10689:   // needed to keep document principals from ever changing, which is
10689:   // needed because of the way we use our XOW code, and is a sane
10689:   // thing to do anyways.
10689: 
10689:   PRBool equals = PR_FALSE;
10689:   if (NS_FAILED(callerPrincipal->Equals(NodePrincipal(), &equals)) ||
10689:       !equals) {
10689:     return NS_ERROR_DOM_SECURITY_ERR;
10689:   }
    1: 
    1:   // The URI for the document after this call. Get it from the calling
    1:   // principal (if available), or set it to "about:blank" if no
    1:   // principal is reachable.
    1:   nsCOMPtr<nsIURI> uri;
    1:   callerPrincipal->GetURI(getter_AddRefs(uri));
10689: 
    1:   if (!uri) {
    1:     rv = NS_NewURI(getter_AddRefs(uri),
    1:                    NS_LITERAL_CSTRING("about:blank"));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   // Stop current loads targeted at the window this document is in.
15756:   if (mScriptGlobalObject) {
    1:     nsCOMPtr<nsIContentViewer> cv;
15756:     shell->GetContentViewer(getter_AddRefs(cv));
    1: 
    1:     if (cv) {
    1:       PRBool okToUnload;
    1:       rv = cv->PermitUnload(&okToUnload);
    1: 
    1:       if (NS_SUCCEEDED(rv) && !okToUnload) {
    1:         // We don't want to unload, so stop here, but don't throw an
    1:         // exception.
    1:         return NS_OK;
    1:       }
    1:     }
    1: 
15756:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(shell));
    1:     webnav->Stop(nsIWebNavigation::STOP_NETWORK);
    1:   }
    1: 
    1:   // The open occurred after the document finished loading.
    1:   // So we reset the document and create a new one.
    1:   nsCOMPtr<nsIChannel> channel;
    1:   nsCOMPtr<nsILoadGroup> group = do_QueryReferent(mDocumentLoadGroup);
    1: 
    1:   rv = NS_NewChannel(getter_AddRefs(channel), uri, nsnull, group);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // Set the caller principal, if any, on the channel so that we'll
    1:   // make sure to use it when we reset.
    1:   rv = channel->SetOwner(callerPrincipal);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Before we reset the doc notify the globalwindow of the change,
    1:   // but only if we still have a window (i.e. our window object the
    1:   // current inner window in our outer window).
    1: 
    1:   // Hold onto ourselves on the offchance that we're down to one ref
    1:   nsCOMPtr<nsIDOMDocument> kungFuDeathGrip =
    1:     do_QueryInterface((nsIHTMLDocument*)this);
    1: 
    1:   nsPIDOMWindow *window = GetInnerWindow();
    1:   if (window) {
    1:     // Remember the old scope in case the call to SetNewDocument changes it.
    1:     nsCOMPtr<nsIScriptGlobalObject> oldScope(do_QueryReferent(mScopeObject));
    1: 
    1:     rv = window->SetNewDocument(this, nsnull, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Now make sure we're not flagged as the initial document anymore, now
    1:     // that we've had stuff done to us.  From now on, if anyone tries to
    1:     // document.open() us, they get a new inner window.
    1:     SetIsInitialDocument(PR_FALSE);
    1: 
    1:     nsCOMPtr<nsIScriptGlobalObject> newScope(do_QueryReferent(mScopeObject));
    1:     if (oldScope && newScope != oldScope) {
    1:       nsContentUtils::ReparentContentWrappersInScope(oldScope, newScope);
    1:     }
    1:   }
    1: 
    1:   // XXX This is a nasty workaround for a scrollbar code bug
    1:   // (http://bugzilla.mozilla.org/show_bug.cgi?id=55334).
    1: 
    1:   // Hold on to our root element
 8938:   nsCOMPtr<nsIContent> root = GetRootContent();
    1: 
    1:   if (root) {
 8938:     PRInt32 rootIndex = mChildren.IndexOfChild(root);
    1:     NS_ASSERTION(rootIndex >= 0, "Root must be in list!");
    1:     
    1:     PRUint32 count = root->GetChildCount();
    1: 
    1:     // Remove all the children from the root.
    1:     while (count-- > 0) {
    1:       root->RemoveChildAt(count, PR_TRUE);
    1:     }
    1: 
 8938:     count = root->GetAttrCount();
    1: 
    1:     // Remove all attributes from the root element
    1:     while (count-- > 0) {
    1:       const nsAttrName* name = root->GetAttrNameAt(count);
13301:       // Hold a strong reference here so that the atom doesn't go away during
13301:       // UnsetAttr.
13301:       nsCOMPtr<nsIAtom> localName = name->LocalName();
13301:       root->UnsetAttr(name->NamespaceID(), localName, PR_FALSE);
    1:     }
    1: 
    1:     // Remove the root from the childlist
    1:     mChildren.RemoveChildAt(rootIndex);
 8938:     mCachedRootContent = nsnull;
    1:   }
    1: 
    1:   // Call Reset(), this will now do the full reset, except removing
    1:   // the root from the document, doing that confuses the scrollbar
    1:   // code in mozilla since the document in the root element and all
    1:   // the anonymous content (i.e. scrollbar elements) is set to
    1:   // null.
    1: 
    1:   Reset(channel, group);
    1: 
    1:   if (root) {
    1:     // Tear down the frames for the root element.
 7043:     MOZ_AUTO_DOC_UPDATE(this, UPDATE_CONTENT_MODEL, PR_TRUE);
    1:     nsNodeUtils::ContentRemoved(this, root, 0);
    1: 
    1:     // Put the root element back into the document, we don't notify
    1:     // the document about this insertion since the sink will do that
    1:     // for us and that'll create frames for the root element and the
    1:     // scrollbars work as expected (since the document in the root
    1:     // element was never set to null)
    1: 
    1:     mChildren.AppendChild(root);
    1:   }
    1: 
 2896:   if (IsEditingOn()) {
    1:     // Reset() blows away all event listeners in the document, and our
    1:     // editor relies heavily on those. Midas is turned on, to make it
    1:     // work, re-initialize it to give it a chance to add its event
    1:     // listeners again.
    1: 
 2896:     TurnEditingOff();
 2896:     EditingStateChanged();
    1:   }
    1: 
    1:   // Zap the old title -- otherwise it would hang around until document.close()
    1:   // (which might never come) if the new document doesn't explicitly set one.
    1:   // Void the title to make sure that we actually respect any titles set by the
    1:   // new document.
    1:   SetTitle(EmptyString());
    1:   mDocumentTitle.SetIsVoid(PR_TRUE);
    1: 
    1:   // Store the security info of the caller now that we're done
    1:   // resetting the document.
    1:   mSecurityInfo = securityInfo;
    1: 
    1:   mParser = do_CreateInstance(kCParserCID, &rv);
    1: 
    1:   // This will be propagated to the parser when someone actually calls write()
    1:   mContentType = aContentType;
    1: 
    1:   mWriteState = eDocumentOpened;
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIHTMLContentSink> sink;
    1: 
15756:     rv = NS_NewHTMLContentSink(getter_AddRefs(sink), this, uri, shell,
    1:                                channel);
15756:     if (NS_FAILED(rv)) {
15756:       // Don't use a parser without a content sink.
15756:       mParser = nsnull;
15756:       mWriteState = eNotWriting;
15756:       return rv;
15756:     }
    1: 
    1:     mParser->SetContentSink(sink);
    1:   }
    1: 
    1:   // Prepare the docshell and the document viewer for the impending
    1:   // out of band document.write()
15756:   shell->PrepareForNewContentModel();
    1: 
    1:   // Now check whether we were opened with a "replace" argument.  If
    1:   // so, we need to tell the docshell to not create a new history
 3101:   // entry for this load. Otherwise, make sure that we're doing a normal load,
 3101:   // not whatever type of load was previously done on this docshell.
15756:   shell->SetLoadType(aReplace ? LOAD_NORMAL_REPLACE : LOAD_NORMAL);
    1: 
    1:   nsCOMPtr<nsIContentViewer> cv;
15756:   shell->GetContentViewer(getter_AddRefs(cv));
    1:   nsCOMPtr<nsIDocumentViewer> docViewer = do_QueryInterface(cv);
    1:   if (docViewer) {
 3233:     docViewer->LoadStart(static_cast<nsIHTMLDocument *>(this));
    1:   }
    1: 
    1:   // Add a wyciwyg channel request into the document load group
    1:   NS_ASSERTION(!mWyciwygChannel, "nsHTMLDocument::OpenCommon(): wyciwyg "
    1:                "channel already exists!");
    1: 
    1:   // In case the editor is listening and will see the new channel
    1:   // being added, make sure mWriteLevel is non-zero so that the editor
    1:   // knows that document.open/write/close() is being called on this
    1:   // document.
    1:   ++mWriteLevel;
    1: 
    1:   CreateAndAddWyciwygChannel();
    1: 
    1:   --mWriteLevel;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Open()
    1: {
    1:   nsCOMPtr<nsIDOMDocument> doc;
    1:   return Open(NS_LITERAL_CSTRING("text/html"), PR_FALSE, getter_AddRefs(doc));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Open(const nsACString& aContentType, PRBool aReplace,
    1:                      nsIDOMDocument** aReturn)
    1: {
    1:   nsresult rv = OpenCommon(aContentType, aReplace);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return CallQueryInterface(this, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Clear()
    1: {
    1:   // This method has been deprecated
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Close()
    1: {
    1:   if (IsXHTML()) {
    1:     // No calling document.close() on XHTML!
    1: 
    1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (mParser && mWriteState == eDocumentOpened) {
    1:     mPendingScripts.RemoveElement(GenerateParserKey());
    1: 
    1:     mWriteState = mPendingScripts.Count() == 0
    1:                   ? eDocumentClosed
    1:                   : ePendingClose;
    1: 
    1:     ++mWriteLevel;
    1:     rv = mParser->Parse(EmptyString(), mParser->GetRootContextKey(),
    1:                         mContentType, PR_TRUE);
    1:     --mWriteLevel;
    1: 
    1:     // XXX Make sure that all the document.written content is
    1:     // reflowed.  We should remove this call once we change
    1:     // nsHTMLDocument::OpenCommon() so that it completely destroys the
    1:     // earlier document's content and frame hierarchy.  Right now, it
    1:     // re-uses the earlier document's root content object and
    1:     // corresponding frame objects.  These re-used frame objects think
    1:     // that they have already been reflowed, so they drop initial
    1:     // reflows.  For certain cases of document.written content, like a
    1:     // frameset document, the dropping of the initial reflow means
    1:     // that we end up in document.close() without appended any reflow
    1:     // commands to the reflow queue and, consequently, without adding
    1:     // the dummy layout request to the load group.  Since the dummy
    1:     // layout request is not added to the load group, the onload
    1:     // handler of the frameset fires before the frames get reflowed
    1:     // and loaded.  That is the long explanation for why we need this
    1:     // one line of code here!
    1:     // XXXbz as far as I can tell this may not be needed anymore; all
    1:     // the testcases in bug 57636 pass without this line...  Leaving
    1:     // it be for now, though.  In any case, there's no reason to do
    1:     // this if we have no presshell, since in that case none of the
    1:     // above about reusing frames applies.
 1722:     if (GetPrimaryShell()) {
    1:       FlushPendingNotifications(Flush_Layout);
    1:     }
    1: 
    1:     // Remove the wyciwyg channel request from the document load group
    1:     // that we added in OpenCommon().  If all other requests between
    1:     // document.open() and document.close() have completed, then this
    1:     // method should cause the firing of an onload event.
    1:     NS_ASSERTION(mWyciwygChannel, "nsHTMLDocument::Close(): Trying to remove "
    1:                  "non-existent wyciwyg channel!");
    1:     RemoveWyciwygChannel();
    1:     NS_ASSERTION(!mWyciwygChannel, "nsHTMLDocument::Close(): "
    1:                  "nsIWyciwygChannel could not be removed!");
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::WriteCommon(const nsAString& aText,
    1:                             PRBool aNewlineTerminate)
    1: {
    1:   mTooDeepWriteRecursion =
    1:     (mWriteLevel > NS_MAX_DOCUMENT_WRITE_DEPTH || mTooDeepWriteRecursion);
    1:   NS_ENSURE_STATE(!mTooDeepWriteRecursion);
    1: 
    1:   if (IsXHTML()) {
    1:     // No calling document.write*() on XHTML!
    1: 
    1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   void *key = GenerateParserKey();
    1:   if (mWriteState == eDocumentClosed ||
    1:       (mWriteState == ePendingClose &&
    1:        mPendingScripts.IndexOf(key) == kNotFound)) {
    1:     mWriteState = eDocumentClosed;
    1:     mParser->Terminate();
    1:     NS_ASSERTION(!mParser, "mParser should have been null'd out");
    1:   }
    1: 
    1:   if (!mParser) {
    1:     rv = Open();
    1: 
    1:     // If Open() fails, or if it didn't create a parser (as it won't
    1:     // if the user chose to not discard the current document through
    1:     // onbeforeunload), don't write anything.
    1:     if (NS_FAILED(rv) || !mParser) {
    1:       return rv;
    1:     }
    1:   }
    1: 
    1:   static NS_NAMED_LITERAL_STRING(new_line, "\n");
    1: 
    1:   // Save the data in cache
    1:   if (mWyciwygChannel) {
    1:     if (!aText.IsEmpty()) {
    1:       mWyciwygChannel->WriteToCacheEntry(aText);
    1:     }
    1: 
    1:     if (aNewlineTerminate) {
    1:       mWyciwygChannel->WriteToCacheEntry(new_line);
    1:     }
    1:   }
    1: 
    1:   ++mWriteLevel;
    1: 
    1:   // This could be done with less code, but for performance reasons it
    1:   // makes sense to have the code for two separate Parse() calls here
    1:   // since the concatenation of strings costs more than we like. And
    1:   // why pay that price when we don't need to?
    1:   if (aNewlineTerminate) {
    1:     rv = mParser->Parse(aText + new_line,
    1:                         key, mContentType,
    1:                         (mWriteState == eNotWriting || (mWriteLevel > 1)));
    1:   } else {
    1:     rv = mParser->Parse(aText,
    1:                         key, mContentType,
    1:                         (mWriteState == eNotWriting || (mWriteLevel > 1)));
    1:   }
    1: 
    1:   --mWriteLevel;
    1: 
    1:   mTooDeepWriteRecursion = (mWriteLevel != 0 && mTooDeepWriteRecursion);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Write(const nsAString& aText)
    1: {
    1:   return WriteCommon(aText, PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Writeln(const nsAString& aText)
    1: {
    1:   return WriteCommon(aText, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::ScriptWriteCommon(PRBool aNewlineTerminate)
    1: {
10286:   nsAXPCNativeCallContext *ncc = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::XPConnect()->
10286:     GetCurrentNativeCallContext(&ncc);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (ncc) {
    1:     // We're called from JS, concatenate the extra arguments into
    1:     // string_buffer
    1:     PRUint32 i, argc;
    1: 
    1:     ncc->GetArgc(&argc);
    1: 
    1:     JSContext *cx = nsnull;
    1:     rv = ncc->GetJSContext(&cx);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     jsval *argv = nsnull;
    1:     ncc->GetArgvPtr(&argv);
    1:     NS_ENSURE_TRUE(argv, NS_ERROR_UNEXPECTED);
    1: 
    1:     if (argc == 1) {
    1:       JSAutoRequest ar(cx);
    1: 
    1:       JSString *jsstr = JS_ValueToString(cx, argv[0]);
    1:       NS_ENSURE_TRUE(jsstr, NS_ERROR_OUT_OF_MEMORY);
    1: 
 3233:       nsDependentString str(reinterpret_cast<const PRUnichar *>
 3233:                                             (::JS_GetStringChars(jsstr)),
    1:                           ::JS_GetStringLength(jsstr));
    1: 
    1:       return WriteCommon(str, aNewlineTerminate);
    1:     }
    1: 
    1:     if (argc > 1) {
    1:       nsAutoString string_buffer;
    1: 
    1:       for (i = 0; i < argc; ++i) {
    1:         JSAutoRequest ar(cx);
    1: 
    1:         JSString *str = JS_ValueToString(cx, argv[i]);
    1:         NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
    1: 
 3233:         string_buffer.Append(reinterpret_cast<const PRUnichar *>
 3233:                                              (::JS_GetStringChars(str)),
    1:                              ::JS_GetStringLength(str));
    1:       }
    1: 
    1:       return WriteCommon(string_buffer, aNewlineTerminate);
    1:     }
    1:   }
    1: 
    1:   // No arguments...
    1:   return WriteCommon(EmptyString(), aNewlineTerminate);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Write()
    1: {
    1:   return ScriptWriteCommon(PR_FALSE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Writeln()
    1: {
    1:   return ScriptWriteCommon(PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::ImportNode(nsIDOMNode* aImportedNode,
    1:                            PRBool aDeep,
    1:                            nsIDOMNode** aReturn)
    1: {
    1:   return nsDocument::ImportNode(aImportedNode, aDeep, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CreateAttributeNS(const nsAString& aNamespaceURI,
    1:                                   const nsAString& aQualifiedName,
    1:                                   nsIDOMAttr** aReturn)
    1: {
    1:   return nsDocument::CreateAttributeNS(aNamespaceURI, aQualifiedName, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
    1:                                        const nsAString& aLocalName,
    1:                                        nsIDOMNodeList** aReturn)
    1: {
    1:   nsAutoString tmp(aLocalName);
    1: 
    1:   if (!IsXHTML()) {
    1:     ToLowerCase(tmp); // HTML elements are lower case internally.
    1:   }
    1: 
    1:   return nsDocument::GetElementsByTagNameNS(aNamespaceURI, tmp, aReturn);
    1: }
    1: 
15474: NS_IMETHODIMP
15474: nsHTMLDocument::GetElementById(const nsAString& aElementId,
15474:                                nsIDOMElement** aReturn)
15474: {
15474:   return nsDocument::GetElementById(aElementId, aReturn);
15474: }
15474: 
    1: PRBool
    1: nsHTMLDocument::MatchNameAttribute(nsIContent* aContent, PRInt32 aNamespaceID,
    1:                                    nsIAtom* aAtom, void* aData)
    1: {
    1:   NS_PRECONDITION(aContent, "Must have content node to work with!");
 3233:   nsString* elementName = static_cast<nsString*>(aData);
    1:   return aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
    1:                                *elementName, eCaseMatters);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetElementsByName(const nsAString& aElementName,
    1:                                   nsIDOMNodeList** aReturn)
    1: {
    1:   void* elementNameData = new nsString(aElementName);
    1:   NS_ENSURE_TRUE(elementNameData, NS_ERROR_OUT_OF_MEMORY);
    1:   nsContentList* elements =
    1:     new nsContentList(this,
    1:                       MatchNameAttribute,
    1:                       nsContentUtils::DestroyMatchString,
    1:                       elementNameData);
    1:   NS_ENSURE_TRUE(elements, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   *aReturn = elements;
    1:   NS_ADDREF(*aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::ScriptLoading(nsIScriptElement *aScript)
    1: {
    1:   if (mWriteState == eNotWriting) {
    1:     return;
    1:   }
    1: 
    1:   mPendingScripts.AppendElement(aScript);
    1: }
    1: 
    1: void
    1: nsHTMLDocument::ScriptExecuted(nsIScriptElement *aScript)
    1: {
    1:   if (mWriteState == eNotWriting) {
    1:     return;
    1:   }
    1: 
    1:   mPendingScripts.RemoveElement(aScript);
    1:   if (mPendingScripts.Count() == 0 && mWriteState == ePendingClose) {
    1:     // The last pending script just finished, terminate our parser now.
    1:     mWriteState = eDocumentClosed;
    1:   }
    1: }
    1: 
    1: void
    1: nsHTMLDocument::AddedForm()
    1: {
    1:   ++mNumForms;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::RemovedForm()
    1: {
    1:   --mNumForms;
    1: }
    1: 
    1: PRInt32
    1: nsHTMLDocument::GetNumFormsSynchronous()
    1: {
    1:   return mNumForms;
    1: }
    1: 
    1: nsresult
 1750: nsHTMLDocument::GetBodySize(PRInt32* aWidth,
    1:                             PRInt32* aHeight)
    1: {
    1:   *aWidth = *aHeight = 0;
    1: 
    1:   FlushPendingNotifications(Flush_Layout);
    1: 
 1750:   nsCOMPtr<nsIPresShell> shell = GetPrimaryShell();
 1750:   
 1750:   if (!shell)
 1750:     return NS_OK;
 1750: 
    1:   // Find the <body> element: this is what we'll want to use for the
    1:   // document's width and height values.
 8938:   nsIContent* body = GetBodyContent();
 8938:   if (!body) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Now grab its frame
 1750:   nsIFrame* frame = shell->GetPrimaryFrameFor(body);
 1750:   if (!frame)
 1750:     return NS_OK;
 1750:   
 1750:   nsSize size = frame->GetSize();
    1: 
    1:   *aWidth = nsPresContext::AppUnitsToIntCSSPixels(size.width);
    1:   *aHeight = nsPresContext::AppUnitsToIntCSSPixels(size.height);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetWidth(PRInt32* aWidth)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aWidth);
 1750: 
 1750:   PRInt32 height;
 1750:   return GetBodySize(aWidth, &height);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetHeight(PRInt32* aHeight)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aHeight);
 1750: 
 1750:   PRInt32 width;
 1750:   return GetBodySize(&width, aHeight);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetAlinkColor(nsAString& aAlinkColor)
    1: {
    1:   aAlinkColor.Truncate();
    1: 
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->GetALink(aAlinkColor);
    1:   } else if (mAttrStyleSheet) {
    1:     nscolor color;
    1:     nsresult rv = mAttrStyleSheet->GetActiveLinkColor(color);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       NS_RGBToHex(color, aAlinkColor);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetAlinkColor(const nsAString& aAlinkColor)
    1: {
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->SetALink(aAlinkColor);
    1:   } else if (mAttrStyleSheet) {
    1:     nsAttrValue value;
    1:     if (value.ParseColor(aAlinkColor, this)) {
    1:       nscolor color;
    1:       value.GetColorValue(color);
    1:       mAttrStyleSheet->SetActiveLinkColor(color);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetLinkColor(nsAString& aLinkColor)
    1: {
    1:   aLinkColor.Truncate();
    1: 
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->GetLink(aLinkColor);
    1:   } else if (mAttrStyleSheet) {
    1:     nscolor color;
    1:     nsresult rv = mAttrStyleSheet->GetLinkColor(color);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       NS_RGBToHex(color, aLinkColor);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetLinkColor(const nsAString& aLinkColor)
    1: {
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->SetLink(aLinkColor);
    1:   } else if (mAttrStyleSheet) {
    1:     nsAttrValue value;
    1:     if (value.ParseColor(aLinkColor, this)) {
    1:       nscolor color;
    1:       value.GetColorValue(color);
    1:       mAttrStyleSheet->SetLinkColor(color);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetVlinkColor(nsAString& aVlinkColor)
    1: {
    1:   aVlinkColor.Truncate();
    1: 
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->GetVLink(aVlinkColor);
    1:   } else if (mAttrStyleSheet) {
    1:     nscolor color;
    1:     nsresult rv = mAttrStyleSheet->GetVisitedLinkColor(color);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       NS_RGBToHex(color, aVlinkColor);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetVlinkColor(const nsAString& aVlinkColor)
    1: {
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->SetVLink(aVlinkColor);
    1:   } else if (mAttrStyleSheet) {
    1:     nsAttrValue value;
    1:     if (value.ParseColor(aVlinkColor, this)) {
    1:       nscolor color;
    1:       value.GetColorValue(color);
    1:       mAttrStyleSheet->SetVisitedLinkColor(color);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetBgColor(nsAString& aBgColor)
    1: {
    1:   aBgColor.Truncate();
    1: 
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->GetBgColor(aBgColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetBgColor(const nsAString& aBgColor)
    1: {
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->SetBgColor(aBgColor);
    1:   }
    1:   // XXXldb And otherwise?
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetFgColor(nsAString& aFgColor)
    1: {
    1:   aFgColor.Truncate();
    1: 
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->GetText(aFgColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetFgColor(const nsAString& aFgColor)
    1: {
 8938:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyContent());
    1: 
    1:   if (body) {
    1:     body->SetText(aFgColor);
    1:   }
    1:   // XXXldb And otherwise?
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetEmbeds(nsIDOMHTMLCollection** aEmbeds)
    1: {
    1:   if (!mEmbeds) {
15474:     mEmbeds = new nsContentList(this, nsGkAtoms::embed, GetDefaultNamespaceID());
    1:     if (!mEmbeds) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   *aEmbeds = mEmbeds;
    1:   NS_ADDREF(*aEmbeds);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetSelection(nsAString& aReturn)
    1: {
    1:   aReturn.Truncate();
    1: 
    1:   nsCOMPtr<nsIConsoleService> consoleService
    1:     (do_GetService("@mozilla.org/consoleservice;1"));
    1: 
    1:   if (consoleService) {
    1:     consoleService->LogStringMessage(NS_LITERAL_STRING("Deprecated method document.getSelection() called.  Please use window.getSelection() instead.").get());
    1:   }
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   NS_ENSURE_TRUE(window, NS_OK);
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult rv = window->GetSelection(getter_AddRefs(selection));
    1:   NS_ENSURE_TRUE(selection && NS_SUCCEEDED(rv), rv);
    1: 
    1:   nsXPIDLString str;
    1: 
    1:   rv = selection->ToString(getter_Copies(str));
    1: 
    1:   aReturn.Assign(str);
    1: 
    1:   return rv;
    1: }
    1: 
    1: static void
    1: ReportUseOfDeprecatedMethod(nsHTMLDocument* aDoc, const char* aWarning)
    1: {
    1:   nsContentUtils::ReportToConsole(nsContentUtils::eDOM_PROPERTIES,
    1:                                   aWarning,
    1:                                   nsnull, 0,
 3233:                                   static_cast<nsIDocument*>(aDoc)->
    1:                                     GetDocumentURI(),
    1:                                   EmptyString(), 0, 0,
    1:                                   nsIScriptError::warningFlag,
    1:                                   "DOM Events");
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CaptureEvents(PRInt32 aEventFlags)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfCaptureEventsWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::ReleaseEvents(PRInt32 aEventFlags)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfReleaseEventsWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::RouteEvent(nsIDOMEvent* aEvt)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfRouteEventWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: // readonly attribute DOMString compatMode;
    1: // Returns "BackCompat" if we are in quirks mode, "CSS1Compat" if we are
    1: // in almost standards or full standards mode. See bug 105640.  This was
    1: // implemented to match MSIE's compatMode property
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetCompatMode(nsAString& aCompatMode)
    1: {
    1:   NS_ASSERTION(mCompatMode == eCompatibility_NavQuirks ||
    1:                mCompatMode == eCompatibility_AlmostStandards ||
    1:                mCompatMode == eCompatibility_FullStandards,
    1:                "mCompatMode is neither quirks nor strict for this document");
    1: 
    1:   if (mCompatMode == eCompatibility_NavQuirks) {
    1:     aCompatMode.AssignLiteral("BackCompat");
    1:   } else {
    1:     aCompatMode.AssignLiteral("CSS1Compat");
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Mapped to document.embeds for NS4 compatibility
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetPlugins(nsIDOMHTMLCollection** aPlugins)
    1: {
    1:   *aPlugins = nsnull;
    1: 
    1:   return GetEmbeds(aPlugins);
    1: }
    1: 
    1: static void
    1: FindNamedItems(nsIAtom* aName, nsIContent *aContent,
15474:                nsIdentifierMapEntry* aEntry)
    1: {
15474:   NS_ASSERTION(aEntry->HasNameContentList(),
    1:                "Entry w/o content list passed to FindNamedItems()!");
15474:   NS_ASSERTION(!aEntry->IsInvalidName(),
    1:                "Entry that should never have a list passed to FindNamedItems()!");
    1: 
    1:   if (aContent->IsNodeOfType(nsINode::eTEXT)) {
    1:     // Text nodes are not named items nor can they have children.
    1:     return;
    1:   }
    1: 
15474:   if (aName == nsContentUtils::IsNamedItem(aContent)) {
15474:     aEntry->AddNameContent(aContent);
15474:   }
15474: 
15474:   if (!aEntry->GetIdContent() &&
    1:       // Maybe this node has the right id?
    1:       aName == aContent->GetID()) {
15474:     aEntry->AddIdContent(aContent);
    1:   }
    1: 
    1:   PRUint32 i, count = aContent->GetChildCount();
    1:   for (i = 0; i < count; ++i) {
15474:     FindNamedItems(aName, aContent->GetChildAt(i), aEntry);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::ResolveName(const nsAString& aName,
    1:                             nsIDOMHTMLFormElement *aForm,
    1:                             nsISupports **aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
15474:   if (!mIsRegularHTML) {
15474:     // We don't dynamically resolve names on non-HTML documents.
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> name(do_GetAtom(aName));
    1: 
    1:   // We have built a table and cache the named items. The table will
    1:   // be updated as content is added and removed.
15474:   nsIdentifierMapEntry *entry = mIdentifierMap.PutEntry(name);
    1:   NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
    1: 
15474:   if (entry->IsInvalidName()) {
    1:     // There won't be any named items by this name -- it's reserved
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Now we know we _might_ have items.  Before looking at
    1:   // entry->mNameContentList, make sure to flush out content (see
    1:   // bug 69826).
    1:   // This is a perf killer while the document is loading!
    1: 
    1:   // Make sure to stash away the current generation so we can check whether the
    1:   // table changes when we flush.
15474:   PRUint32 generation = mIdentifierMap.GetGeneration();
    1:   
    1:   // If we already have an entry->mNameContentList, we need to flush out
    1:   // notifications too, so that it will get updated properly.
15474:   FlushPendingNotifications(entry->HasNameContentList() ?
    1:                             Flush_ContentAndNotify : Flush_Content);
    1: 
15474:   if (generation != mIdentifierMap.GetGeneration()) {
    1:     // Table changed, so the entry pointer is no longer valid; look up the
    1:     // entry again, adding if necessary (the adding may be necessary in case
    1:     // the flush actually deleted entries).
15474:     entry = mIdentifierMap.PutEntry(name);
    1:     NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
15474:   if (!entry->HasNameContentList()) {
    1: #ifdef DEBUG_jst
    1:     {
    1:       printf ("nsHTMLDocument name cache miss for name '%s'\n",
    1:               NS_ConvertUTF16toUTF8(aName).get());
    1:     }
    1: #endif
    1: 
15474:     nsresult rv = entry->CreateNameContentList();
15474:     if (NS_FAILED(rv))
15474:       return rv;
    1: 
 8938:     nsIContent* root = GetRootContent();
 8938:     if (root && !aName.IsEmpty()) {
15474:       FindNamedItems(name, root, entry);
15474:     }
15474:   }
15474: 
15474:   nsBaseContentList *list = entry->GetNameContentList();
    1: 
    1:   PRUint32 length;
    1:   list->GetLength(&length);
    1: 
    1:   if (length > 0) {
    1:     if (length == 1) {
    1:       // Only one element in the list, return the element instead of
    1:       // returning the list
    1: 
    1:       nsCOMPtr<nsIDOMNode> node;
    1: 
    1:       list->Item(0, getter_AddRefs(node));
    1: 
    1:       nsCOMPtr<nsIContent> ourContent(do_QueryInterface(node));
    1:       if (aForm && ourContent &&
    1:           !nsContentUtils::BelongsInForm(aForm, ourContent)) {
    1:         // This is not the content you are looking for
    1:         node = nsnull;
    1:       }
    1: 
    1:       *aResult = node;
    1:       NS_IF_ADDREF(*aResult);
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     // The list contains more than one element, return the whole
    1:     // list, unless...
    1: 
    1:     if (aForm) {
    1:       // ... we're called from a form, in that case we create a
    1:       // nsFormNameContentList which will filter out the elements in the
    1:       // list that don't belong to aForm
    1: 
    1:       nsFormContentList *fc_list = new nsFormContentList(aForm, *list);
    1:       NS_ENSURE_TRUE(fc_list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       PRUint32 len;
    1:       fc_list->GetLength(&len);
    1: 
    1:       if (len < 2) {
    1:         // After the nsFormContentList is done filtering there's either
    1:         // nothing or one element in the list.  Return that element, or null
    1:         // if there's no element in the list.
    1: 
    1:         nsCOMPtr<nsIDOMNode> node;
    1: 
    1:         fc_list->Item(0, getter_AddRefs(node));
    1: 
    1:         NS_IF_ADDREF(*aResult = node);
    1: 
    1:         delete fc_list;
    1: 
    1:         return NS_OK;
    1:       }
    1: 
    1:       list = fc_list;
    1:     }
    1: 
    1:     return CallQueryInterface(list, aResult);
    1:   }
    1: 
    1:   // No named items were found, see if there's one registerd by id for
    1:   // aName. If we get this far, FindNamedItems() will have been called
    1:   // for aName, so we're guaranteed that if there is an element with
    1:   // the id aName, it'll be entry's IdContent.
    1: 
    1:   nsIContent *e = entry->GetIdContent();
    1: 
15474:   if (e && e->IsNodeOfType(nsINode::eHTML)) {
    1:     nsIAtom *tag = e->Tag();
    1: 
    1:     if ((tag == nsGkAtoms::embed  ||
    1:          tag == nsGkAtoms::img    ||
    1:          tag == nsGkAtoms::object ||
    1:          tag == nsGkAtoms::applet) &&
    1:         (!aForm || nsContentUtils::BelongsInForm(aForm, e))) {
    1:       NS_ADDREF(*aResult = e);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
15474: // Pre-fill the name hash with names that are likely to be resolved in
15474: // this document to avoid walking the tree looking for elements with
15474: // these names.
15474: 
15474: nsresult
15474: nsHTMLDocument::PrePopulateIdentifierMap()
15474: {
15474:   static const char names[][13] = {
15474:     "write", "writeln", "open", "close", "forms", "elements",
15474:     "characterSet", "nodeType", "parentNode", "cookie"
15474:   };
15474: 
15474:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(names); ++i) {
15474:     nsCOMPtr<nsIAtom> atom(do_GetAtom(names[i]));
15474:     NS_ENSURE_TRUE(atom, NS_ERROR_OUT_OF_MEMORY);
15474:   
15474:     nsIdentifierMapEntry* entry = mIdentifierMap.PutEntry(atom);
15474:     NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
15474: 
15474:     entry->SetInvalidName();
15474:   }
15474: 
15474:   return NS_OK;
15474: }
15474: 
    1: //----------------------------
    1: 
11877: /* virtual */ nsIContent*
11877: nsHTMLDocument::GetBodyContentExternal()
11877: {
11877:   return GetBodyContent();
11877: }
11877: 
 8938: nsIContent*
15473: nsHTMLDocument::GetHtmlContent()
15473: {
15473:   nsIContent* rootContent = GetRootContent();
15473:   if (rootContent && rootContent->Tag() == nsGkAtoms::html &&
15473:       rootContent->IsNodeOfType(nsINode::eHTML))
15473:     return rootContent;
15473:   return nsnull;
15473: }
15473: 
15473: nsIContent*
    1: nsHTMLDocument::GetBodyContent()
    1: {
15473:   nsIContent* html = GetHtmlContent();
15473:   if (!html)
15473:     return nsnull;
15473: 
15473:   // Look for body inside html. This needs to run forwards to find
15473:   // the first body element.
15473:   for (PRUint32 i = 0; i < html->GetChildCount(); ++i) {
15473:     nsIContent* body = html->GetChildAt(i);
 8938:     if (body->Tag() == nsGkAtoms::body &&
15473:         body->IsNodeOfType(nsINode::eHTML))
 8938:       return body;
 8938:   }
 8938:   return nsnull;
    1: }
    1: 
    1: // forms related stuff
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetForms(nsIDOMHTMLCollection** aForms)
    1: {
    1:   nsContentList *forms = nsHTMLDocument::GetForms();
    1:   if (!forms)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*aForms = forms);
    1:   return NS_OK;
    1: }
    1: 
    1: nsContentList*
    1: nsHTMLDocument::GetForms()
    1: {
    1:   if (!mForms)
15474:     mForms = new nsContentList(this, nsGkAtoms::form, GetDefaultNamespaceID());
    1: 
    1:   return mForms;
    1: }
    1: 
    1: static PRBool MatchFormControls(nsIContent* aContent, PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAtom, void* aData)
    1: {
    1:   return aContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL);
    1: }
    1: 
    1: nsContentList*
    1: nsHTMLDocument::GetFormControls()
    1: {
    1:   if (!mFormControls) {
    1:     mFormControls = new nsContentList(this, MatchFormControls, nsnull, nsnull);
    1:   }
    1: 
    1:   return mFormControls;
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::CreateAndAddWyciwygChannel(void)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsCAutoString url, originalSpec;
    1: 
    1:   mDocumentURI->GetSpec(originalSpec);
    1: 
    1:   // Generate the wyciwyg url
    1:   url = NS_LITERAL_CSTRING("wyciwyg://")
    1:       + nsPrintfCString("%d", gWyciwygSessionCnt++)
    1:       + NS_LITERAL_CSTRING("/")
    1:       + originalSpec;
    1: 
    1:   nsCOMPtr<nsIURI> wcwgURI;
    1:   NS_NewURI(getter_AddRefs(wcwgURI), url);
    1: 
    1:   // Create the nsIWyciwygChannel to store out-of-band
    1:   // document.write() script to cache
    1:   nsCOMPtr<nsIChannel> channel;
    1:   // Create a wyciwyg Channel
    1:   rv = NS_NewChannel(getter_AddRefs(channel), wcwgURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mWyciwygChannel = do_QueryInterface(channel);
    1: 
    1:   mWyciwygChannel->SetSecurityInfo(mSecurityInfo);
    1: 
 1300:   // Note: we want to treat this like a "previous document" hint so that,
 1300:   // e.g. a <meta> tag in the document.write content can override it.
 4527:   SetDocumentCharacterSetSource(kCharsetFromHintPrevDoc);
 1300:   mWyciwygChannel->SetCharsetAndSource(kCharsetFromHintPrevDoc,
 1300:                                        GetDocumentCharacterSet());
 1300: 
    1:   // Use our new principal
    1:   channel->SetOwner(NodePrincipal());
    1: 
    1:   // Inherit load flags from the original document's channel
    1:   channel->SetLoadFlags(mLoadFlags);
    1: 
    1:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1: 
    1:   // Use the Parent document's loadgroup to trigger load notifications
    1:   if (loadGroup && channel) {
    1:     rv = channel->SetLoadGroup(loadGroup);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsLoadFlags loadFlags = 0;
    1:     channel->GetLoadFlags(&loadFlags);
    1:     loadFlags |= nsIChannel::LOAD_DOCUMENT_URI;
    1:     channel->SetLoadFlags(loadFlags);
    1: 
    1:     channel->SetOriginalURI(wcwgURI);
    1: 
    1:     rv = loadGroup->AddRequest(mWyciwygChannel, nsnull);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to add request to load group.");
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::RemoveWyciwygChannel(void)
    1: {
    1:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1: 
    1:   // note there can be a write request without a load group if
    1:   // this is a synchronously constructed about:blank document
    1:   if (loadGroup && mWyciwygChannel) {
    1:     mWyciwygChannel->CloseCacheEntry(NS_OK);
    1:     loadGroup->RemoveRequest(mWyciwygChannel, nsnull, NS_OK);
    1:   }
    1: 
    1:   mWyciwygChannel = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void *
    1: nsHTMLDocument::GenerateParserKey(void)
    1: {
    1:   if (!mScriptLoader) {
    1:     // If we don't have a script loader, then the parser probably isn't parsing
    1:     // anything anyway, so just return null.
    1:     return nsnull;
    1:   }
    1: 
    1:   // The script loader provides us with the currently executing script element,
    1:   // which is guaranteed to be unique per script.
    1:   return mScriptLoader->GetCurrentScript();
    1: }
    1: 
    1: /* attribute DOMString designMode; */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetDesignMode(nsAString & aDesignMode)
    1: {
 2896:   if (HasFlag(NODE_IS_EDITABLE)) {
    1:     aDesignMode.AssignLiteral("on");
    1:   }
    1:   else {
    1:     aDesignMode.AssignLiteral("off");
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 7199: void
 7199: nsHTMLDocument::EndUpdate(nsUpdateType aUpdateType)
 7199: {
 7199:   nsDocument::EndUpdate(aUpdateType);
 7199: 
 7235:   if (mUpdateNestLevel == 0 && mContentEditableCount > 0 != IsEditingOn()) {
 7199:     EditingStateChanged();
 7199:   }
 7199: }
 7199: 
 2896: nsresult
 2896: nsHTMLDocument::ChangeContentEditableCount(nsIContent *aElement,
 2896:                                            PRInt32 aChange)
    1: {
 2896:   NS_ASSERTION(mContentEditableCount + aChange >= 0,
 2896:                "Trying to decrement too much.");
 2896: 
 2896:   mContentEditableCount += aChange;
 2896: 
 7199:   if (mParser ||
 7235:       (mUpdateNestLevel > 0 && mContentEditableCount > 0 != IsEditingOn())) {
 2896:     return NS_OK;
 2896:   }
 2896: 
 2896:   EditingState oldState = mEditingState;
 2896: 
 2896:   nsresult rv = EditingStateChanged();
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   if (oldState == mEditingState && mEditingState == eContentEditable) {
 2896:     // We just changed the contentEditable state of a node, we need to reset
 2896:     // the spellchecking state of that node.
 2896:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aElement);
 2896:     if (node) {
 2896:       nsPIDOMWindow *window = GetWindow();
 2896:       if (!window)
 2896:         return NS_ERROR_FAILURE;
 2896: 
 2896:       nsIDocShell *docshell = window->GetDocShell();
 2896:       if (!docshell)
 2896:         return NS_ERROR_FAILURE;
 2896: 
 2896:       nsCOMPtr<nsIEditorDocShell> editorDocShell =
 2896:         do_QueryInterface(docshell, &rv);
 2896:       NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:       nsCOMPtr<nsIEditor> editor;
 3605:       editorDocShell->GetEditor(getter_AddRefs(editor));
 3605:       if (editor) {
 2896:         nsCOMPtr<nsIDOMRange> range;
 2896:         rv = NS_NewRange(getter_AddRefs(range));
 2896:         NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:         rv = range->SelectNode(node);
 2896:         NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:         nsCOMPtr<nsIInlineSpellChecker> spellChecker;
 2896:         rv = editor->GetInlineSpellChecker(PR_FALSE,
 2896:                                            getter_AddRefs(spellChecker));
 2896:         NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:         if (spellChecker) {
 2896:           rv = spellChecker->SpellCheckRange(range);
 2896:           NS_ENSURE_SUCCESS(rv, rv);
 2896:         }
 2896:       }
 2896:     }
 3605:   }
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
 3991: static PRBool
 3991: DocAllResultMatch(nsIContent* aContent, PRInt32 aNamespaceID, nsIAtom* aAtom,
 3991:                   void* aData)
 3991: {
 3991:   if (aContent->GetID() == aAtom) {
 3991:     return PR_TRUE;
 3991:   }
 3991: 
 3991:   nsGenericHTMLElement* elm = nsGenericHTMLElement::FromContent(aContent);
 3991:   if (!elm || aContent->GetNameSpaceID() != kNameSpaceID_None) {
 3991:     return PR_FALSE;
 3991:   }
 3991: 
 3991:   nsIAtom* tag = elm->Tag();
 3991:   if (tag != nsGkAtoms::img    &&
 3991:       tag != nsGkAtoms::form   &&
 3991:       tag != nsGkAtoms::applet &&
 3991:       tag != nsGkAtoms::embed  &&
 3991:       tag != nsGkAtoms::object &&
 3991:       tag != nsGkAtoms::input) {
 3991:     return PR_FALSE;
 3991:   }
 3991: 
 3991:   const nsAttrValue* val = elm->GetParsedAttr(nsGkAtoms::name);
 3991:   return val && val->Type() == nsAttrValue::eAtom &&
 3991:          val->GetAtomValue() == aAtom;
 3991: }
 3991: 
 3991: 
 3991: nsresult
 3991: nsHTMLDocument::GetDocumentAllResult(const nsAString& aID, nsISupports** aResult)
 3991: {
 3991:   *aResult = nsnull;
 3991: 
 3991:   nsCOMPtr<nsIAtom> id = do_GetAtom(aID);
15474:   nsIdentifierMapEntry *entry;
15474:   if (IdTableIsLive()) {
15474:     entry = mIdentifierMap.GetEntry(id);
15474:     // If we did a lookup and it failed, there are no items with this id
15474:     if (!entry)
15474:       return NS_OK;
15474:   } else {
15474:     entry = mIdentifierMap.PutEntry(id);
 3991:     NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
 3991:   }
 3991: 
 8938:   nsIContent* root = GetRootContent();
 8938:   if (!root) {
 3991:     return NS_OK;
 3991:   }
 3991: 
15474:   nsRefPtr<nsContentList> docAllList = entry->GetDocAllList();
15474:   if (!docAllList) {
15474:     docAllList = new nsContentList(root, DocAllResultMatch,
 3991:                                    nsnull, nsnull, PR_TRUE, id);
15474:     NS_ENSURE_TRUE(docAllList, NS_ERROR_OUT_OF_MEMORY);
15474:     entry->SetDocAllList(docAllList);
15474:   }
15253: 
 3991:   // Check if there are more than 1 entries. Do this by getting the second one
 3991:   // rather than the length since getting the length always requires walking
 3991:   // the entire document.
 3991: 
15253:   nsIContent* cont = docAllList->Item(1, PR_TRUE);
 3991:   if (cont) {
15253:     NS_ADDREF(*aResult = static_cast<nsIDOMNodeList*>(docAllList));
 3991:     return NS_OK;
 3991:   }
 3991: 
 3991:   // There's only 0 or 1 items. Return the first one or null.
15253:   NS_IF_ADDREF(*aResult = docAllList->Item(0, PR_TRUE));
 3991: 
 3991:   return NS_OK;
 3991: }
 3991: 
 2896: static void
 2896: NotifyEditableStateChange(nsINode *aNode, nsIDocument *aDocument,
 2896:                           PRBool aEditable)
 2896: {
 2896:   PRUint32 i, n = aNode->GetChildCount();
 2896:   for (i = 0; i < n; ++i) {
 2896:     nsIContent *child = aNode->GetChildAt(i);
 2896:     if (child->HasFlag(NODE_IS_EDITABLE) != aEditable) {
 2896:       aDocument->ContentStatesChanged(child, nsnull,
 2896:                                       NS_EVENT_STATE_MOZ_READONLY |
 2896:                                       NS_EVENT_STATE_MOZ_READWRITE);
 2896:     }
 2896:     NotifyEditableStateChange(child, aDocument, aEditable);
 2896:   }
 2896: }
 2896: 
11925: void
11925: nsHTMLDocument::TearingDownEditor(nsIEditor *aEditor)
11925: {
11925:   if (IsEditingOn()) {
11925:     mEditingState = eTearingDown;
11925: 
11925:     nsCOMPtr<nsIEditorStyleSheets> editorss = do_QueryInterface(aEditor);
11925:     if (editorss) {
11925:       editorss->RemoveOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/contenteditable.css"));
11925:       if (mEditingState == eDesignMode)
11925:         editorss->RemoveOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/designmode.css"));
11925:     }
11925:   }
11925: }
11925: 
 2896: nsresult
 2896: nsHTMLDocument::TurnEditingOff()
 2896: {
 2896:   NS_ASSERTION(mEditingState != eOff, "Editing is already off.");
 2896: 
 2896:   nsPIDOMWindow *window = GetWindow();
 2896:   if (!window)
 2896:     return NS_ERROR_FAILURE;
 2896: 
 2896:   nsIDocShell *docshell = window->GetDocShell();
 2896:   if (!docshell)
 2896:     return NS_ERROR_FAILURE;
 2896: 
 2896:   nsresult rv;
 2896:   nsCOMPtr<nsIEditingSession> editSession = do_GetInterface(docshell, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   // turn editing off
 7856:   rv = editSession->TearDownEditorOnWindow(window);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   mEditingState = eOff;
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
 7289: static PRBool HasPresShell(nsPIDOMWindow *aWindow)
 7289: {
 7289:   nsIDocShell *docShell = aWindow->GetDocShell();
 7289:   if (!docShell)
 7289:     return PR_FALSE;
 7289:   nsCOMPtr<nsIPresShell> presShell;
 7289:   docShell->GetPresShell(getter_AddRefs(presShell));
 7289:   return presShell != nsnull;
 7289: }
 7289: 
 2896: nsresult
14631: nsHTMLDocument::SetEditingState(EditingState aState)
14631: {
14631:   mEditingState = aState;
14631:   return NS_OK;
14631: }
14631: 
14631: nsresult
 2896: nsHTMLDocument::EditingStateChanged()
 2896: {
14887:   if (mRemovedFromDocShell) {
14887:     return NS_OK;
14887:   }
14887: 
11925:   if (mEditingState == eSettingUp || mEditingState == eTearingDown) {
 2896:     // XXX We shouldn't recurse.
 2896:     return NS_OK;
 2896:   }
 2896: 
 2896:   PRBool designMode = HasFlag(NODE_IS_EDITABLE);
 2896:   EditingState newState = designMode ? eDesignMode :
 2896:                           (mContentEditableCount > 0 ? eContentEditable : eOff);
 2896:   if (mEditingState == newState) {
 2896:     // No changes in editing mode.
 2896:     return NS_OK;
 2896:   }
 2896: 
 2896:   if (newState == eOff) {
 2896:     // Editing is being turned off.
 2896:     return TurnEditingOff();
 2896:   }
 2896: 
    1:   // get editing session
    1:   nsPIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDocShell *docshell = window->GetDocShell();
    1:   if (!docshell)
    1:     return NS_ERROR_FAILURE;
    1: 
 2896:   nsresult rv;
 2896:   nsCOMPtr<nsIEditingSession> editSession = do_GetInterface(docshell, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 7350:   if (!HasPresShell(window)) {
 7289:     // We should not make the window editable or setup its editor.
 7289:     // It's probably style=display:none.
 7289:     return NS_OK;
 7289:   }
 7289: 
 7350:   PRBool makeWindowEditable = mEditingState == eOff;
 7350:   if (makeWindowEditable) {
 2896:     // Editing is being turned on (through designMode or contentEditable)
 2896:     // Turn on editor.
 2896:     // XXX This can cause flushing which can change the editing state, so make
 2896:     //     sure to avoid recursing.
 2896:     EditingState oldState = mEditingState;
 2896:     mEditingState = eSettingUp;
 2896: 
 2896:     rv = editSession->MakeWindowEditable(window, "html", PR_FALSE, PR_FALSE,
 2896:                                          PR_TRUE);
 2896:     NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:     mEditingState = oldState;
 7350:   }
 2896: 
 2896:   // XXX Need to call TearDownEditorOnWindow for all failures.
 2896:   nsCOMPtr<nsIEditorDocShell> editorDocShell =
 2896:     do_QueryInterface(docshell, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   nsCOMPtr<nsIEditor> editor;
 3605:   editorDocShell->GetEditor(getter_AddRefs(editor));
 3605:   if (!editor)
 3605:     return NS_ERROR_FAILURE;
 2896: 
 2896:   nsCOMPtr<nsIEditorStyleSheets> editorss = do_QueryInterface(editor, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 7269:   editorss->AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/contenteditable.css"));
 2896: 
 2896:   // Should we update the editable state of all the nodes in the document? We
 2896:   // need to do this when the designMode value changes, as that overrides
 2896:   // specific states on the elements.
 2896:   PRBool updateState;
 2896: 
 2896:   PRBool spellRecheckAll = PR_FALSE;
 2896:   if (designMode) {
 2896:     // designMode is being turned on (overrides contentEditable).
 7269:     editorss->AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/designmode.css"));
 2896: 
 7856:     // Disable scripting and plugins.
 7856:     rv = editSession->DisableJSAndPlugins(window);
 3072:     NS_ENSURE_SUCCESS(rv, rv);
 3072: 
 2896:     updateState = PR_TRUE;
 2896:     spellRecheckAll = mEditingState == eContentEditable;
 2896:   }
 2896:   else if (mEditingState == eDesignMode) {
 2896:     // designMode is being turned off (contentEditable is still on).
 7269:     editorss->RemoveOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/designmode.css"));
 2896: 
 7856:     rv = editSession->RestoreJSAndPlugins(window);
 2896:     NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:     updateState = PR_TRUE;
 2896:   }
 2896:   else {
 2896:     // contentEditable is being turned on (and designMode is off).
 2896:     updateState = PR_FALSE;
 2896:   }
 2896: 
 2896:   mEditingState = newState;
 2896: 
 7350:   if (makeWindowEditable) {
 2896:     // Set the editor to not insert br's on return when in p
 2896:     // elements by default.
 2896:     // XXX Do we only want to do this for designMode?
 2896:     PRBool unused;
 2896:     rv = ExecCommand(NS_LITERAL_STRING("insertBrOnReturn"), PR_FALSE,
 2896:                      NS_LITERAL_STRING("false"), &unused);
 2896: 
 2896:     if (NS_FAILED(rv)) {
 2896:       // Editor setup failed. Editing is not on after all.
 2896:       // XXX Should we reset the editable flag on nodes?
 7856:       editSession->TearDownEditorOnWindow(window);
 2896:       mEditingState = eOff;
 2896: 
 2896:       return rv;
 2896:     }
 7350:   }
 2896: 
 2896:   if (updateState) {
 2896:     mozAutoDocUpdate upd(this, UPDATE_CONTENT_STATE, PR_TRUE);
 2896:     NotifyEditableStateChange(this, this, !designMode);
 2896:   }
 2896: 
 2896:   // Resync the editor's spellcheck state.
 2896:   if (spellRecheckAll) {
 2896:     nsCOMPtr<nsISelectionController> selcon;
 2896:     nsresult rv = editor->GetSelectionController(getter_AddRefs(selcon));
 2896:     NS_ENSURE_SUCCESS(rv, rv); 
 2896: 
 2896:     nsCOMPtr<nsISelection> spellCheckSelection;
 2896:     rv = selcon->GetSelection(nsISelectionController::SELECTION_SPELLCHECK,
 2896:                               getter_AddRefs(spellCheckSelection));
 2896:     if (NS_SUCCEEDED(rv)) {
 2896:       spellCheckSelection->RemoveAllRanges();
 2896:     }
 2896:   }
 2896:   editor->SyncRealTimeSpell();
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
 2896: NS_IMETHODIMP
 2896: nsHTMLDocument::SetDesignMode(const nsAString & aDesignMode)
 2896: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
    1:     nsCOMPtr<nsIPrincipal> subject;
    1:     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
    1:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (subject) {
 3286:       PRBool subsumes;
 3286:       rv = subject->Subsumes(NodePrincipal(), &subsumes);
    1:       NS_ENSURE_SUCCESS(rv, rv);
 3286: 
 3286:       NS_ENSURE_TRUE(subsumes, NS_ERROR_DOM_PROP_ACCESS_DENIED);
    1:     }
    1:   }
    1: 
 2896:   PRBool editableMode = HasFlag(NODE_IS_EDITABLE);
 2896:   if (aDesignMode.LowerCaseEqualsASCII(editableMode ? "off" : "on")) {
 2896:     SetEditableFlag(!editableMode);
 2896: 
 2896:     return EditingStateChanged();
 2896:   }
 2896: 
 2896:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::GetMidasCommandManager(nsICommandManager** aCmdMgr)
    1: {
    1:   // initialize return value
    1:   NS_ENSURE_ARG_POINTER(aCmdMgr);
    1: 
    1:   // check if we have it cached
    1:   if (mMidasCommandManager) {
    1:     NS_ADDREF(*aCmdMgr = mMidasCommandManager);
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aCmdMgr = nsnull;
    1: 
    1:   nsPIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDocShell *docshell = window->GetDocShell();
    1:   if (!docshell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mMidasCommandManager = do_GetInterface(docshell);
    1:   if (!mMidasCommandManager)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ADDREF(*aCmdMgr = mMidasCommandManager);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: struct MidasCommand {
    1:   const char*  incomingCommandString;
    1:   const char*  internalCommandString;
    1:   const char*  internalParamString;
    1:   PRPackedBool useNewParam;
    1:   PRPackedBool convertToBoolean;
    1: };
    1: 
    1: static const struct MidasCommand gMidasCommandTable[] = {
    1:   { "bold",          "cmd_bold",            "", PR_TRUE,  PR_FALSE },
    1:   { "italic",        "cmd_italic",          "", PR_TRUE,  PR_FALSE },
    1:   { "underline",     "cmd_underline",       "", PR_TRUE,  PR_FALSE },
    1:   { "strikethrough", "cmd_strikethrough",   "", PR_TRUE,  PR_FALSE },
    1:   { "subscript",     "cmd_subscript",       "", PR_TRUE,  PR_FALSE },
    1:   { "superscript",   "cmd_superscript",     "", PR_TRUE,  PR_FALSE },
    1:   { "cut",           "cmd_cut",             "", PR_TRUE,  PR_FALSE },
    1:   { "copy",          "cmd_copy",            "", PR_TRUE,  PR_FALSE },
    1:   { "paste",         "cmd_paste",           "", PR_TRUE,  PR_FALSE },
    1:   { "delete",        "cmd_delete",          "", PR_TRUE,  PR_FALSE },
    1:   { "selectall",     "cmd_selectAll",       "", PR_TRUE,  PR_FALSE },
    1:   { "undo",          "cmd_undo",            "", PR_TRUE,  PR_FALSE },
    1:   { "redo",          "cmd_redo",            "", PR_TRUE,  PR_FALSE },
    1:   { "indent",        "cmd_indent",          "", PR_TRUE,  PR_FALSE },
    1:   { "outdent",       "cmd_outdent",         "", PR_TRUE,  PR_FALSE },
    1:   { "backcolor",     "cmd_backgroundColor", "", PR_FALSE, PR_FALSE },
    1:   { "forecolor",     "cmd_fontColor",       "", PR_FALSE, PR_FALSE },
    1:   { "hilitecolor",   "cmd_highlight",       "", PR_FALSE, PR_FALSE },
    1:   { "fontname",      "cmd_fontFace",        "", PR_FALSE, PR_FALSE },
    1:   { "fontsize",      "cmd_fontSize",        "", PR_FALSE, PR_FALSE },
    1:   { "increasefontsize", "cmd_increaseFont", "", PR_FALSE, PR_FALSE },
    1:   { "decreasefontsize", "cmd_decreaseFont", "", PR_FALSE, PR_FALSE },
    1:   { "inserthorizontalrule", "cmd_insertHR", "", PR_TRUE,  PR_FALSE },
    1:   { "createlink",    "cmd_insertLinkNoUI",  "", PR_FALSE, PR_FALSE },
    1:   { "insertimage",   "cmd_insertImageNoUI", "", PR_FALSE, PR_FALSE },
    1:   { "inserthtml",    "cmd_insertHTML",      "", PR_FALSE, PR_FALSE },
    1:   { "gethtml",       "cmd_getContents",     "", PR_FALSE, PR_FALSE },
    1:   { "justifyleft",   "cmd_align",       "left", PR_TRUE,  PR_FALSE },
    1:   { "justifyright",  "cmd_align",      "right", PR_TRUE,  PR_FALSE },
    1:   { "justifycenter", "cmd_align",     "center", PR_TRUE,  PR_FALSE },
    1:   { "justifyfull",   "cmd_align",    "justify", PR_TRUE,  PR_FALSE },
    1:   { "removeformat",  "cmd_removeStyles",    "", PR_TRUE,  PR_FALSE },
    1:   { "unlink",        "cmd_removeLinks",     "", PR_TRUE,  PR_FALSE },
    1:   { "insertorderedlist",   "cmd_ol",        "", PR_TRUE,  PR_FALSE },
    1:   { "insertunorderedlist", "cmd_ul",        "", PR_TRUE,  PR_FALSE },
    1:   { "insertparagraph", "cmd_paragraphState", "p", PR_TRUE, PR_FALSE },
    1:   { "formatblock",   "cmd_paragraphState",  "", PR_FALSE, PR_FALSE },
    1:   { "heading",       "cmd_paragraphState",  "", PR_FALSE, PR_FALSE },
    1:   { "styleWithCSS",  "cmd_setDocumentUseCSS", "", PR_FALSE, PR_TRUE },
    1:   { "contentReadOnly", "cmd_setDocumentReadOnly", "", PR_FALSE, PR_TRUE },
    1:   { "insertBrOnReturn", "cmd_insertBrOnReturn", "", PR_FALSE, PR_TRUE },
    1:   { "enableObjectResizing", "cmd_enableObjectResizing", "", PR_FALSE, PR_TRUE },
    1:   { "enableInlineTableEditing", "cmd_enableInlineTableEditing", "", PR_FALSE, PR_TRUE },
    1: #if 0
    1: // no editor support to remove alignments right now
    1:   { "justifynone",   "cmd_align",           "", PR_TRUE,  PR_FALSE },
    1: 
    1: // the following will need special review before being turned on
    1:   { "saveas",        "cmd_saveAs",          "", PR_TRUE,  PR_FALSE },
    1:   { "print",         "cmd_print",           "", PR_TRUE,  PR_FALSE },
    1: #endif
    1:   { NULL, NULL, NULL, PR_FALSE, PR_FALSE }
    1: };
    1: 
    1: #define MidasCommandCount ((sizeof(gMidasCommandTable) / sizeof(struct MidasCommand)) - 1)
    1: 
 8426: static const char* const gBlocks[] = {
 8426:   "ADDRESS",
 8426:   "BLOCKQUOTE",
 8426:   "DD",
 8426:   "DIV",
 8426:   "DL",
 8426:   "DT",
 8426:   "H1",
 8426:   "H2",
 8426:   "H3",
 8426:   "H4",
 8426:   "H5",
 8426:   "H6",
 8426:   "P",
 8426:   "PRE"
    1: };
    1: 
10248: static PRBool
10248: ConvertToMidasInternalCommandInner(const nsAString & inCommandID,
    1:                                    const nsAString & inParam,
    1:                                    nsACString& outCommandID,
    1:                                    nsACString& outParam,
    1:                                    PRBool& outIsBoolean,
10248:                                    PRBool& outBooleanValue,
10248:                                    PRBool aIgnoreParams)
    1: {
    1:   NS_ConvertUTF16toUTF8 convertedCommandID(inCommandID);
    1: 
    1:   // Hack to support old boolean commands that were backwards (see bug 301490).
    1:   PRBool invertBool = PR_FALSE;
    1:   if (convertedCommandID.LowerCaseEqualsLiteral("usecss")) {
    1:     convertedCommandID.Assign("styleWithCSS");
    1:     invertBool = PR_TRUE;
    1:   }
    1:   else if (convertedCommandID.LowerCaseEqualsLiteral("readonly")) {
    1:     convertedCommandID.Assign("contentReadOnly");
    1:     invertBool = PR_TRUE;
    1:   }
    1: 
    1:   PRUint32 i;
    1:   PRBool found = PR_FALSE;
    1:   for (i = 0; i < MidasCommandCount; ++i) {
    1:     if (convertedCommandID.Equals(gMidasCommandTable[i].incomingCommandString,
    1:                                   nsCaseInsensitiveCStringComparator())) {
    1:       found = PR_TRUE;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   if (found) {
    1:     // set outCommandID (what we use internally)
    1:     outCommandID.Assign(gMidasCommandTable[i].internalCommandString);
    1: 
    1:     // set outParam & outIsBoolean based on flags from the table
    1:     outIsBoolean = gMidasCommandTable[i].convertToBoolean;
    1: 
10248:     if (!aIgnoreParams) {
    1:       if (gMidasCommandTable[i].useNewParam) {
    1:         outParam.Assign(gMidasCommandTable[i].internalParamString);
    1:       }
    1:       else {
    1:         // handle checking of param passed in
    1:         if (outIsBoolean) {
    1:           // if this is a boolean value and it's not explicitly false
    1:           // (e.g. no value) we default to "true". For old backwards commands
    1:           // we invert the check (see bug 301490).
    1:           if (invertBool) {
    1:             outBooleanValue = inParam.LowerCaseEqualsLiteral("false");
    1:           }
    1:           else {
    1:             outBooleanValue = !inParam.LowerCaseEqualsLiteral("false");
    1:           }
    1:           outParam.Truncate();
    1:         }
    1:         else {
    1:           // check to see if we need to convert the parameter
 2896:           if (outCommandID.EqualsLiteral("cmd_paragraphState")) {
 8426:             const PRUnichar *start = inParam.BeginReading();
 8426:             const PRUnichar *end = inParam.EndReading();
 8426:             if (start != end && *start == '<' && *(end - 1) == '>') {
 8426:               ++start;
 8426:               --end;
 8426:             }
 8426: 
 8426:             NS_ConvertUTF16toUTF8 convertedParam(Substring(start, end));
    1:             PRUint32 j;
 8426:             for (j = 0; j < NS_ARRAY_LENGTH(gBlocks); ++j) {
 8426:               if (convertedParam.Equals(gBlocks[j],
    1:                                         nsCaseInsensitiveCStringComparator())) {
 8426:                 outParam.Assign(gBlocks[j]);
    1:                 break;
    1:               }
    1:             }
    1: 
 8426:             return j != NS_ARRAY_LENGTH(gBlocks);
 2896:           }
 2896:           else {
 8426:             CopyUTF16toUTF8(inParam, outParam);
    1:           }
    1:         }
 2896:       }
10248:     }
    1:   } // end else for useNewParam (do convert existing param)
    1:   else {
    1:     // reset results if the command is not found in our table
    1:     outCommandID.SetLength(0);
    1:     outParam.SetLength(0);
    1:     outIsBoolean = PR_FALSE;
    1:   }
    1: 
    1:   return found;
    1: }
    1: 
10248: static PRBool
10248: ConvertToMidasInternalCommand(const nsAString & inCommandID,
10248:                               const nsAString & inParam,
10248:                               nsACString& outCommandID,
10248:                               nsACString& outParam,
10248:                               PRBool& outIsBoolean,
10248:                               PRBool& outBooleanValue)
10248: {
10248:   return ConvertToMidasInternalCommandInner(inCommandID, inParam, outCommandID,
10248:                                             outParam, outIsBoolean,
10248:                                             outBooleanValue, PR_FALSE);
10248: }
10248: 
10248: static PRBool
10248: ConvertToMidasInternalCommand(const nsAString & inCommandID,
10248:                               nsACString& outCommandID)
10248: {
10248:   nsCAutoString dummyCString;
10248:   nsAutoString dummyString;
10248:   PRBool dummyBool;
10248:   return ConvertToMidasInternalCommandInner(inCommandID, dummyString,
10248:                                             outCommandID, dummyCString,
10248:                                             dummyBool, dummyBool, PR_TRUE);
10248: }
10248: 
    1: jsval
    1: nsHTMLDocument::sCutCopyInternal_id = JSVAL_VOID;
    1: jsval
    1: nsHTMLDocument::sPasteInternal_id = JSVAL_VOID;
    1: 
    1: /* Helper function to check security of clipboard commands. If aPaste is */
    1: /* true, we check paste, else we check cutcopy */
    1: nsresult
    1: nsHTMLDocument::DoClipboardSecurityCheck(PRBool aPaste)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
    1: 
    1:   if (stack) {
    1:     JSContext *cx = nsnull;
    1:     stack->Peek(&cx);
10022:     if (!cx) {
10022:       return NS_OK;
10022:     }
10022: 
10022:     JSAutoRequest ar(cx);
    1: 
    1:     NS_NAMED_LITERAL_CSTRING(classNameStr, "Clipboard");
    1: 
    1:     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
    1: 
    1:     if (aPaste) {
    1:       if (nsHTMLDocument::sPasteInternal_id == JSVAL_VOID) {
    1:         nsHTMLDocument::sPasteInternal_id =
    1:           STRING_TO_JSVAL(::JS_InternString(cx, "paste"));
    1:       }
    1:       rv = secMan->CheckPropertyAccess(cx, nsnull, classNameStr.get(),
    1:                                        nsHTMLDocument::sPasteInternal_id,
    1:                                        nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
    1:     } else {
    1:       if (nsHTMLDocument::sCutCopyInternal_id == JSVAL_VOID) {
    1:         nsHTMLDocument::sCutCopyInternal_id =
    1:           STRING_TO_JSVAL(::JS_InternString(cx, "cutcopy"));
    1:       }
    1:       rv = secMan->CheckPropertyAccess(cx, nsnull, classNameStr.get(),
    1:                                        nsHTMLDocument::sCutCopyInternal_id,
    1:                                        nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: /* TODO: don't let this call do anything if the page is not done loading */
    1: /* boolean execCommand(in DOMString commandID, in boolean doShowUI,
    1:                                                in DOMString value); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::ExecCommand(const nsAString & commandID,
    1:                             PRBool doShowUI,
    1:                             const nsAString & value,
    1:                             PRBool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1: 
    1:   //  for optional parameters see dom/src/base/nsHistory.cpp: HistoryImpl::Go()
    1:   //  this might add some ugly JS dependencies?
    1: 
    1:   *_retval = PR_FALSE;
    1: 
    1:   // if editing is not on, bail
 2896:   if (!IsEditingOn())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // if they are requesting UI from us, let's fail since we have no UI
    1:   if (doShowUI)
 2896:     return NS_OK;
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (commandID.LowerCaseEqualsLiteral("gethtml"))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (commandID.LowerCaseEqualsLiteral("cut") ||
    1:       (commandID.LowerCaseEqualsLiteral("copy"))) {
    1:     rv = DoClipboardSecurityCheck(PR_FALSE);
    1:   } else if (commandID.LowerCaseEqualsLiteral("paste")) {
    1:     rv = DoClipboardSecurityCheck(PR_TRUE);
    1:   }
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramStr;
    1:   PRBool isBool, boolVal;
    1:   if (!ConvertToMidasInternalCommand(commandID, value,
    1:                                      cmdToDispatch, paramStr, isBool, boolVal))
 2896:     return NS_OK;
    1: 
    1:   if (!isBool && paramStr.IsEmpty()) {
    1:     rv = cmdMgr->DoCommand(cmdToDispatch.get(), nsnull, window);
    1:   } else {
    1:     // we have a command that requires a parameter, create params
    1:     nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
    1:                                             NS_COMMAND_PARAMS_CONTRACTID, &rv);
    1:     if (!cmdParams)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (isBool)
    1:       rv = cmdParams->SetBooleanValue("state_attribute", boolVal);
    1:     else if (cmdToDispatch.Equals("cmd_fontFace"))
    1:       rv = cmdParams->SetStringValue("state_attribute", value);
    1:     else if (cmdToDispatch.Equals("cmd_insertHTML"))
    1:       rv = cmdParams->SetStringValue("state_data", value);
    1:     else
    1:       rv = cmdParams->SetCStringValue("state_attribute", paramStr.get());
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     rv = cmdMgr->DoCommand(cmdToDispatch.get(), cmdParams, window);
    1:   }
    1: 
    1:   *_retval = NS_SUCCEEDED(rv);
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* TODO: don't let this call do anything if the page is not done loading */
    1: /* boolean execCommandShowHelp(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::ExecCommandShowHelp(const nsAString & commandID,
    1:                                     PRBool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = PR_FALSE;
    1: 
    1:   // if editing is not on, bail
 2896:   if (!IsEditingOn())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* boolean queryCommandEnabled(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandEnabled(const nsAString & commandID,
    1:                                     PRBool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = PR_FALSE;
    1: 
    1:   // if editing is not on, bail
 2896:   if (!IsEditingOn())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramStr;
10248:   if (!ConvertToMidasInternalCommand(commandID, cmdToDispatch))
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: 
    1:   return cmdMgr->IsCommandEnabled(cmdToDispatch.get(), window, _retval);
    1: }
    1: 
    1: /* boolean queryCommandIndeterm (in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandIndeterm(const nsAString & commandID,
    1:                                      PRBool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = PR_FALSE;
    1: 
    1:   // if editing is not on, bail
 2896:   if (!IsEditingOn())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramToCheck;
    1:   PRBool dummy;
    1:   if (!ConvertToMidasInternalCommand(commandID, commandID,
    1:                                      cmdToDispatch, paramToCheck, dummy, dummy))
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
    1:                                            NS_COMMAND_PARAMS_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = cmdMgr->GetCommandState(cmdToDispatch.get(), window, cmdParams);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // if command does not have a state_mixed value, this call fails, so we fail too,
    1:   // which is what is expected
    1:   rv = cmdParams->GetBooleanValue("state_mixed", _retval);
    1:   return rv;
    1: }
    1: 
    1: /* boolean queryCommandState(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandState(const nsAString & commandID, PRBool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = PR_FALSE;
    1: 
    1:   // if editing is not on, bail
 2896:   if (!IsEditingOn())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramToCheck;
    1:   PRBool dummy, dummy2;
    1:   if (!ConvertToMidasInternalCommand(commandID, commandID,
    1:                                      cmdToDispatch, paramToCheck, dummy, dummy2))
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
    1:                                            NS_COMMAND_PARAMS_CONTRACTID, &rv);
    1:   if (!cmdParams)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   rv = cmdMgr->GetCommandState(cmdToDispatch.get(), window, cmdParams);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // handle alignment as a special case (possibly other commands too?)
    1:   // Alignment is special because the external api is individual
    1:   // commands but internally we use cmd_align with different
    1:   // parameters.  When getting the state of this command, we need to
    1:   // return the boolean for this particular alignment rather than the
    1:   // string of 'which alignment is this?'
    1:   if (cmdToDispatch.Equals("cmd_align")) {
    1:     char * actualAlignmentType = nsnull;
    1:     rv = cmdParams->GetCStringValue("state_attribute", &actualAlignmentType);
    1:     if (NS_SUCCEEDED(rv) && actualAlignmentType && actualAlignmentType[0]) {
    1:       *_retval = paramToCheck.Equals(actualAlignmentType);
    1:     }
    1:     if (actualAlignmentType)
    1:       nsMemory::Free(actualAlignmentType);
    1:   }
    1:   else {
    1:     rv = cmdParams->GetBooleanValue("state_all", _retval);
    1:     if (NS_FAILED(rv))
    1:       *_retval = PR_FALSE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* boolean queryCommandSupported(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandSupported(const nsAString & commandID,
    1:                                       PRBool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = PR_FALSE;
    1: 
    1:   // if editing is not on, bail
 2896:   if (!IsEditingOn())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* DOMString queryCommandText(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandText(const nsAString & commandID,
    1:                                  nsAString & _retval)
    1: {
    1:   _retval.SetLength(0);
    1: 
    1:   // if editing is not on, bail
 2896:   if (!IsEditingOn())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* DOMString queryCommandValue(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandValue(const nsAString & commandID,
    1:                                   nsAString &_retval)
    1: {
    1:   _retval.SetLength(0);
    1: 
    1:   // if editing is not on, bail
 2896:   if (!IsEditingOn())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramStr;
10248:   if (!ConvertToMidasInternalCommand(commandID, cmdToDispatch))
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: 
    1:   // create params
    1:   nsresult rv;
    1:   nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
    1:                                            NS_COMMAND_PARAMS_CONTRACTID, &rv);
    1:   if (!cmdParams)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // this is a special command since we are calling "DoCommand rather than
    1:   // GetCommandState like the other commands
    1:   if (cmdToDispatch.Equals("cmd_getContents"))
    1:   {
    1:     rv = cmdParams->SetBooleanValue("selection_only", PR_TRUE);
    1:     if (NS_FAILED(rv)) return rv;
    1:     rv = cmdParams->SetCStringValue("format", "text/html");
    1:     if (NS_FAILED(rv)) return rv;
    1:     rv = cmdMgr->DoCommand(cmdToDispatch.get(), cmdParams, window);
    1:     if (NS_FAILED(rv)) return rv;
    1:     return cmdParams->GetStringValue("result", _retval);
    1:   }
    1: 
    1:   rv = cmdParams->SetCStringValue("state_attribute", paramStr.get());
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = cmdMgr->GetCommandState(cmdToDispatch.get(), window, cmdParams);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsXPIDLCString cStringResult;
    1:   rv = cmdParams->GetCStringValue("state_attribute",
    1:                                   getter_Copies(cStringResult));
    1:   CopyUTF8toUTF16(cStringResult, _retval);
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef DEBUG
    1: nsresult
    1: nsHTMLDocument::CreateElem(nsIAtom *aName, nsIAtom *aPrefix,
    1:                            PRInt32 aNamespaceID, PRBool aDocumentDefaultType,
    1:                            nsIContent** aResult)
    1: {
    1:   NS_ASSERTION(!aDocumentDefaultType || IsXHTML() ||
    1:                aNamespaceID == kNameSpaceID_None,
    1:                "HTML elements in an HTML document should have "
    1:                "kNamespaceID_None as their namespace ID.");
    1: 
    1:   if (IsXHTML() &&
    1:       (aDocumentDefaultType || aNamespaceID == kNameSpaceID_XHTML)) {
    1:     nsCAutoString name, lcName;
    1:     aName->ToUTF8String(name);
    1:     ToLowerCase(name, lcName);
    1:     NS_ASSERTION(lcName.Equals(name),
    1:                  "aName should be lowercase, fix caller.");
    1:   }
    1: 
    1:   return nsDocument::CreateElem(aName, aPrefix, aNamespaceID,
    1:                                 aDocumentDefaultType, aResult);
    1: }
    1: #endif
