    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
34352:  * vim: set ts=4 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsinterp_h___
    1: #define jsinterp_h___
    1: /*
    1:  * JS interpreter interface.
    1:  */
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
11377: #include "jsopcode.h"
    1: 
69223: #include "vm/Stack.h"
    1: 
42714: namespace js {
42714: 
    1: /*
    1:  * Refresh and return fp->scopeChain.  It may be stale if block scopes are
    1:  * active but not yet reflected by objects in the scope chain.  If a block
    1:  * scope contains a with, eval, XML filtering predicate, or similar such
    1:  * dynamically scoped construct, then compile-time block scope at fp->blocks
    1:  * must reflect at runtime.
    1:  */
86077: 
86077: extern JSObject *
86077: GetScopeChain(JSContext *cx);
86077: 
    1: extern JSObject *
69223: GetScopeChain(JSContext *cx, StackFrame *fp);
    1: 
    1: /*
64363:  * ScriptPrologue/ScriptEpilogue must be called in pairs. ScriptPrologue
64363:  * must be called before the script executes. ScriptEpilogue must be called
64363:  * after the script returns or exits via exception.
64363:  */
64363: 
64363: inline bool
69223: ScriptPrologue(JSContext *cx, StackFrame *fp, JSScript *script);
64363: 
64363: inline bool
69223: ScriptEpilogue(JSContext *cx, StackFrame *fp, bool ok);
64389: 
64389: /*
64389:  * It is not valid to call ScriptPrologue when a generator is resumed or to
64389:  * call ScriptEpilogue when a generator yields. However, the debugger still
64389:  * needs LIFO notification of generator start/stop. This pair of functions does
64389:  * the right thing based on the state of 'fp'.
64389:  */
64389: 
64389: inline bool
69223: ScriptPrologueOrGeneratorResume(JSContext *cx, StackFrame *fp);
64389: 
64389: inline bool
69223: ScriptEpilogueOrGeneratorYield(JSContext *cx, StackFrame *fp, bool ok);
64363: 
64363: /* Implemented in jsdbgapi: */
64363: 
84070: /*
84070:  * Announce to the debugger that the thread has entered a new JavaScript frame,
84070:  * |fp|. Call whatever hooks have been registered to observe new frames, and
84070:  * return a JSTrapStatus code indication how execution should proceed:
84070:  *
84070:  * - JSTRAP_CONTINUE: Continue execution normally.
84070:  * 
84070:  * - JSTRAP_THROW: Throw an exception. ScriptDebugPrologue has set |cx|'s
84070:  *   pending exception to the value to be thrown.
84070:  *
84070:  * - JSTRAP_ERROR: Terminate execution (as is done when a script is terminated
84070:  *   for running too long). ScriptDebugPrologue has cleared |cx|'s pending
84070:  *   exception.
84070:  *
84070:  * - JSTRAP_RETURN: Return from the new frame immediately. ScriptDebugPrologue
84070:  *   has set |cx->fp()|'s return value appropriately.
84070:  */
84070: extern JSTrapStatus
69223: ScriptDebugPrologue(JSContext *cx, StackFrame *fp);
64363: 
64363: extern bool
69223: ScriptDebugEpilogue(JSContext *cx, StackFrame *fp, bool ok);
64363: 
64363: /*
68904:  * For a given |call|, convert null/undefined |this| into the global object for
68904:  * the callee and replace other primitives with boxed versions. This assumes
68904:  * that call.callee() is not strict mode code. This is the special/slow case of
68904:  * ComputeThis.
    1:  */
53081: extern bool
68904: BoxNonStrictThis(JSContext *cx, const CallReceiver &call);
68904: 
68904: /*
68904:  * Ensure that fp->thisValue() is the correct value of |this| for the scripted
68904:  * call represented by |fp|. ComputeThis is necessary because fp->thisValue()
68904:  * may be set to 'undefined' when 'this' should really be the global object (as
68904:  * an optimization to avoid global-this computation).
68904:  */
68904: inline bool
69223: ComputeThis(JSContext *cx, StackFrame *fp);
69223: 
77341: enum MaybeConstruct {
77341:     NO_CONSTRUCT = INITIAL_NONE,
77341:     CONSTRUCT = INITIAL_CONSTRUCT
77341: };
77341: 
69223: /*
76829:  * InvokeKernel assumes that the given args have been pushed on the top of the
76829:  * VM stack. Additionally, if 'args' is contained in a CallArgsList, that they
76829:  * have already been marked 'active'.
    1:  */
71697: extern bool
79387: InvokeKernel(JSContext *cx, CallArgs args, MaybeConstruct construct = NO_CONSTRUCT);
48470: 
    1: /*
76829:  * Invoke assumes that 'args' has been pushed (via ContextStack::pushInvokeArgs)
76829:  * and is currently at the top of the VM stack.
71697:  */
71697: inline bool
71697: Invoke(JSContext *cx, InvokeArgsGuard &args, MaybeConstruct construct = NO_CONSTRUCT)
71697: {
71697:     args.setActive();
76829:     bool ok = InvokeKernel(cx, args, construct);
71697:     args.setInactive();
71697:     return ok;
71697: }
71697: 
71697: /*
76829:  * This Invoke overload places the least requirements on the caller: it may be
76829:  * called at any time and it takes care of copying the given callee, this, and
76829:  * arguments onto the stack.
76829:  */
76829: extern bool
76829: Invoke(JSContext *cx, const Value &thisv, const Value &fval, uintN argc, Value *argv,
76829:        Value *rval);
76829: 
76829: /*
76829:  * This helper takes care of the infinite-recursion check necessary for
76829:  * getter/setter calls.
76829:  */
76829: extern bool
76829: InvokeGetterOrSetter(JSContext *cx, JSObject *obj, const Value &fval, uintN argc, Value *argv,
76829:                      Value *rval);
76829: 
76829: /*
76829:  * InvokeConstructor* implement a function call from a constructor context
76829:  * (e.g. 'new') handling the the creation of the new 'this' object.
    1:  */
86484: extern bool
76829: InvokeConstructorKernel(JSContext *cx, const CallArgs &args);
53557: 
76829: /* See the InvokeArgsGuard overload of Invoke. */
76829: inline bool
76829: InvokeConstructor(JSContext *cx, InvokeArgsGuard &args)
76829: {
76829:     args.setActive();
76829:     bool ok = InvokeConstructorKernel(cx, ImplicitCast<CallArgs>(args));
76829:     args.setInactive();
76829:     return ok;
76829: }
76829: 
76829: /* See the fval overload of Invoke. */
53557: extern bool
76829: InvokeConstructor(JSContext *cx, const Value &fval, uintN argc, Value *argv, Value *rval);
    1: 
53557: /*
71695:  * Executes a script with the given scopeChain/this. The 'type' indicates
71695:  * whether this is eval code or global code. To support debugging, the
71695:  * evalFrame parameter can point to an arbitrary frame in the context's call
71695:  * stack to simulate executing an eval in that frame.
53557:  */
71695: extern bool
76829: ExecuteKernel(JSContext *cx, JSScript *script, JSObject &scopeChain, const Value &thisv,
71695:               ExecuteType type, StackFrame *evalInFrame, Value *result);
69223: 
76829: /* Execute a script with the given scopeChain as global code. */
76829: extern bool
76829: Execute(JSContext *cx, JSScript *script, JSObject &scopeChain, Value *rval);
76829: 
69223: /* Flags to toggle js::Interpret() execution. */
69223: enum InterpMode
69223: {
69223:     JSINTERP_NORMAL    = 0, /* interpreter is running normally */
87646:     JSINTERP_REJOIN    = 1, /* as normal, but the frame has already started */
87646:     JSINTERP_SKIP_TRAP = 2  /* as REJOIN, but skip trap at first opcode */
69223: };
    1: 
53557: /*
53557:  * Execute the caller-initialized frame for a user-defined script or function
53557:  * pointed to by cx->fp until completion or error.
53557:  */
86484: extern JS_NEVER_INLINE bool
71363: Interpret(JSContext *cx, StackFrame *stopFp, InterpMode mode = JSINTERP_NORMAL);
48474: 
86484: extern bool
69223: RunScript(JSContext *cx, JSScript *script, StackFrame *fp);
12551: 
48470: extern bool
62411: CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs);
    1: 
86542: inline bool
86542: CheckRedeclaration(JSContext *cx, JSObject *obj, PropertyName *name, uintN attrs)
86542: {
86542:     return CheckRedeclaration(cx, obj, ATOM_TO_JSID(name), attrs);
86542: }
86542: 
48470: extern bool
59890: StrictlyEqual(JSContext *cx, const Value &lval, const Value &rval, JSBool *equal);
    1: 
64551: extern bool
64551: LooselyEqual(JSContext *cx, const Value &lval, const Value &rval, JSBool *equal);
64551: 
32760: /* === except that NaN is the same as NaN and -0 is not the same as +0. */
48470: extern bool
59890: SameValue(JSContext *cx, const Value &v1, const Value &v2, JSBool *same);
32760: 
48470: extern JSType
48470: TypeOfValue(JSContext *cx, const Value &v);
48470: 
48529: extern JSBool
48547: HasInstance(JSContext *cx, JSObject *obj, const js::Value *v, JSBool *bp);
48529: 
48470: extern bool
48470: ValueToId(JSContext *cx, const Value &v, jsid *idp);
48470: 
15996: /*
48582:  * @param closureLevel      The static level of the closure that the cookie
48582:  *                          pertains to.
48582:  * @param cookie            Level amount is a "skip" (delta) value from the
48582:  *                          closure level.
48582:  * @return  The value of the upvar.
27169:  */
71697: extern const Value &
71697: GetUpvar(JSContext *cx, uintN level, UpvarCookie cookie);
71697: 
71697: /* Search the call stack for the nearest frame with static level targetLevel. */
71697: extern StackFrame *
71697: FindUpvarFrame(JSContext *cx, uintN targetLevel);
48582: 
77168: /*
77168:  * A linked list of the |FrameRegs regs;| variables belonging to all
77168:  * js::Interpret C++ frames on this thread's stack.
77168:  *
77168:  * Note that this is *not* a list of all JS frames running under the
77168:  * interpreter; that would include inlined frames, whose FrameRegs are
77168:  * saved in various pieces in various places. Rather, this lists each
77168:  * js::Interpret call's live 'regs'; when control returns to that call, it
77168:  * will resume execution with this 'regs' instance.
77168:  *
77168:  * When Debugger puts a script in single-step mode, all js::Interpret
77168:  * invocations that might be presently running that script must have
77168:  * interrupts enabled. It's not practical to simply check
77168:  * script->stepModeEnabled() at each point some callee could have changed
77168:  * it, because there are so many places js::Interpret could possibly cause
77168:  * JavaScript to run: each place an object might be coerced to a primitive
77168:  * or a number, for example. So instead, we simply expose a list of the
77168:  * 'regs' those frames are using, and let Debugger tweak the affected
77168:  * js::Interpret frames when an onStep handler is established.
77168:  *
77168:  * Elements of this list are allocated within the js::Interpret stack
77168:  * frames themselves; the list is headed by this thread's js::ThreadData.
77168:  */
77168: class InterpreterFrames {
77168:   public:
77168:     class InterruptEnablerBase {
77168:       public:
77168:         virtual void enableInterrupts() const = 0;
77168:     };
77168: 
77168:     InterpreterFrames(JSContext *cx, FrameRegs *regs, const InterruptEnablerBase &enabler);
77168:     ~InterpreterFrames();
77168: 
77168:     /* If this js::Interpret frame is running |script|, enable interrupts. */
79734:     inline void enableInterruptsIfRunning(JSScript *script);
77168: 
77169:     InterpreterFrames *older;
77169: 
77168:   private:
77168:     JSContext *context;
77168:     FrameRegs *regs;
77168:     const InterruptEnablerBase &enabler;
77168: };
77168: 
52657: /*
52657:  * Unwind block and scope chains to match the given depth. The function sets
52657:  * fp->sp on return to stackDepth.
52657:  */
86484: extern void
86484: UnwindScope(JSContext *cx, uint32_t stackDepth);
52657: 
77822: extern bool
86855: OnUnknownMethod(JSContext *cx, JSObject *obj, Value idval, Value *vp);
52657: 
77822: extern bool
86483: IsActiveWithOrBlock(JSContext *cx, JSObject &obj, uint32_t stackDepth);
77822: 
78614: /************************************************************************/
78614: 
78614: /*
78614:  * To really poison a set of values, using 'magic' or 'undefined' isn't good
78614:  * enough since often these will just be ignored by buggy code (see bug 629974)
78614:  * in debug builds and crash in release builds. Instead, we use a safe-for-crash
78614:  * pointer.
78614:  */
78614: static JS_ALWAYS_INLINE void
78614: Debug_SetValueRangeToCrashOnTouch(Value *beg, Value *end)
78614: {
78614: #ifdef DEBUG
78614:     for (Value *v = beg; v != end; ++v)
78614:         v->setObject(*reinterpret_cast<JSObject *>(0x42));
78614: #endif
78614: }
78614: 
78614: static JS_ALWAYS_INLINE void
78614: Debug_SetValueRangeToCrashOnTouch(Value *vec, size_t len)
78614: {
78614: #ifdef DEBUG
78614:     Debug_SetValueRangeToCrashOnTouch(vec, vec + len);
78614: #endif
78614: }
78614: 
83301: static JS_ALWAYS_INLINE void
83301: Debug_SetValueRangeToCrashOnTouch(HeapValue *vec, size_t len)
83301: {
83301: #ifdef DEBUG
83301:     Debug_SetValueRangeToCrashOnTouch((Value *) vec, len);
83301: #endif
83301: }
83301: 
77822: }  /* namespace js */
53125: 
    1: #endif /* jsinterp_h___ */
