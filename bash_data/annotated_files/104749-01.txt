 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 65507: const Ci = Components.interfaces;
 65507: const Cc = Components.classes;
 65507: const Cr = Components.results;
 65507: const Cu = Components.utils;
 65507: 
 65507: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 66362: Cu.import("resource://gre/modules/Services.jsm");
 65507: 
 67205: // Whitelist of methods we remote - to check against malicious data.
 67205: // For example, it would be dangerous to allow content to show auth prompts.
 67205: const REMOTABLE_METHODS = {
 67205:   alert: { outParams: [] },
 67205:   alertCheck: { outParams: [4] },
 67205:   confirm: { outParams: [] },
 67205:   prompt: { outParams: [3, 5] },
 67205:   confirmEx: { outParams: [8] },
 67205:   confirmCheck: { outParams: [4] },
 67205:   select: { outParams: [5] }
 67205: };
 67205: 
 66537: var gPromptService = null;
 66537: 
 66322: function PromptService() {
 66537:   gPromptService = this;
 65507: }
 65507: 
 66322: PromptService.prototype = {
 65507:   classID: Components.ID("{9a61149b-2276-4a0a-b79c-be994ad106cf}"),
 65791: 
 66322:   QueryInterface: XPCOMUtils.generateQI([Ci.nsIPromptFactory, Ci.nsIPromptService, Ci.nsIPromptService2]),
 65507: 
 66322:   /* ----------  nsIPromptFactory  ---------- */
 66322:   // XXX Copied from nsPrompter.js.
 66322:   getPrompt: function getPrompt(domWin, iid) {
 66322:     let doc = this.getDocument();
 67205:     if (!doc) {
 66322:       let fallback = this._getFallbackService();
 66322:       return fallback.getPrompt(domWin, iid);
 66322:     }
 67205: 
 66322:     let p = new Prompt(domWin, doc);
 66322:     p.QueryInterface(iid);
 66322:     return p;
 66322:   },
 66322: 
 66322:   /* ----------  private memebers  ---------- */
 66322: 
 66322:   _getFallbackService: function _getFallbackService() {
 66322:     return Components.classesByID["{7ad1b327-6dfa-46ec-9234-f2a620ea7e00}"]
 66322:                      .getService(Ci.nsIPromptService);
 66322:   },
 66322: 
 66322:   getDocument: function getDocument() {
 66362:     let win = Services.wm.getMostRecentWindow("navigator:browser");
 65791:     return win ? win.document : null;
 65507:   },
 65507: 
 66322:   // nsIPromptService and nsIPromptService2 methods proxy to our Prompt class
 66322:   // if we can show in-document popups, or to the fallback service otherwise.
 66322:   callProxy: function(aMethod, aArguments) {
 67205:     let prompt;
 66322:     let doc = this.getDocument();
 66322:     if (!doc) {
 66322:       let fallback = this._getFallbackService();
 66322:       return fallback[aMethod].apply(fallback, aArguments);
 66322:     }
 66322:     let domWin = aArguments[0];
 67205:     prompt = new Prompt(domWin, doc);
 67205:     return prompt[aMethod].apply(prompt, Array.prototype.slice.call(aArguments, 1));
 66322:   },
 66322: 
 66322:   /* ----------  nsIPromptService  ---------- */
 66322: 
 66322:   alert: function() {
 66927:     return this.callProxy("alert", arguments);
 66322:   },
 66322:   alertCheck: function() {
 66322:     return this.callProxy("alertCheck", arguments);
 66322:   },
 66322:   confirm: function() {
 66322:     return this.callProxy("confirm", arguments);
 66322:   },
 66322:   confirmCheck: function() {
 66322:     return this.callProxy("confirmCheck", arguments);
 66322:   },
 66322:   confirmEx: function() {
 66322:     return this.callProxy("confirmEx", arguments);
 66322:   },
 66322:   prompt: function() {
 66322:     return this.callProxy("prompt", arguments);
 66322:   },
 66322:   promptUsernameAndPassword: function() {
 66322:     return this.callProxy("promptUsernameAndPassword", arguments);
 66322:   },
 66322:   promptPassword: function() {
 66322:     return this.callProxy("promptPassword", arguments);
 66322:   },
 66322:   select: function() {
 66322:     return this.callProxy("select", arguments);
 66322:   },
 66322: 
 66322:   /* ----------  nsIPromptService2  ---------- */
 66322:   promptAuth: function() {
 66322:     return this.callProxy("promptAuth", arguments);
 66322:   },
 66322:   asyncPromptAuth: function() {
 66322:     return this.callProxy("asyncPromptAuth", arguments);
 66322:   }
 66322: };
 66322: 
 66322: function Prompt(aDomWin, aDocument) {
 66322:   this._domWin = aDomWin;
 66322:   this._doc = aDocument;
 66322: }
 66322: 
 66322: Prompt.prototype = {
 66322:   _domWin: null,
 66322:   _doc: null,
 66322: 
 66322:   QueryInterface: XPCOMUtils.generateQI([Ci.nsIPrompt, Ci.nsIAuthPrompt, Ci.nsIAuthPrompt2]),
 66322: 
 66322:   /* ---------- internal methods ---------- */
 83577:   commonPrompt: function commonPrompt(aTitle, aText, aButtons, aCheckMsg, aCheckState, aInputs) {
 83577:     if (aCheckMsg)
 86776:       aInputs.push({ type: "checkbox", label: PromptUtils.cleanUpLabel(aCheckMsg), checked: aCheckState.value });
 66322: 
 92125:     if (this._domWin)
 91677:       PromptUtils.fireDialogEvent(this._domWin, "DOMWillOpenModalDialog");
 91677: 
 83664:     let msg = { type: "Prompt:Show" };
 83577:     if (aTitle) msg.title = aTitle;
 83577:     if (aText) msg.text = aText;
 83577:     msg.buttons = aButtons || [
 83577:       { label: PromptUtils.getLocaleString("OK") },
 83577:       { label: PromptUtils.getLocaleString("Cancel") }
 83577:     ];
 83577:     msg.inputs = aInputs;
 83577:     return PromptUtils.sendMessageToJava(msg);
 65507:   },
 65507: 
 66322:   /*
 66322:    * ---------- interface disambiguation ----------
 66322:    *
 66322:    * XXX Copied from nsPrompter.js.
 66322:    *
 66322:    * nsIPrompt and nsIAuthPrompt share 3 method names with slightly
 66322:    * different arguments. All but prompt() have the same number of
 66322:    * arguments, so look at the arg types to figure out how we're being
 66322:    * called. :-(
 66322:    */
 66322:   prompt: function prompt() {
 67057:     if (gPromptService.inContentProcess)
 67057:       return gPromptService.callProxy("prompt", [null].concat(Array.prototype.slice.call(arguments)));
 67057: 
 66322:     // also, the nsIPrompt flavor has 5 args instead of 6.
 66322:     if (typeof arguments[2] == "object")
 66322:       return this.nsIPrompt_prompt.apply(this, arguments);
 66322:     else
 66322:       return this.nsIAuthPrompt_prompt.apply(this, arguments);
 66322:   },
 66322: 
 66322:   promptUsernameAndPassword: function promptUsernameAndPassword() {
 66322:     // Both have 6 args, so use types.
 66322:     if (typeof arguments[2] == "object")
 66322:       return this.nsIPrompt_promptUsernameAndPassword.apply(this, arguments);
 66322:     else
 66322:       return this.nsIAuthPrompt_promptUsernameAndPassword.apply(this, arguments);
 66322:   },
 66322: 
 66322:   promptPassword: function promptPassword() {
 66322:     // Both have 5 args, so use types.
 66322:     if (typeof arguments[2] == "object")
 66322:       return this.nsIPrompt_promptPassword.apply(this, arguments);
 66322:     else
 66322:       return this.nsIAuthPrompt_promptPassword.apply(this, arguments);
 66322:   },
 66322: 
 66322:   /* ----------  nsIPrompt  ---------- */
 66322: 
 66322:   alert: function alert(aTitle, aText) {
 83577:     this.commonPrompt(aTitle, aText, [{ label: PromptUtils.getLocaleString("OK") }], "", {value: false}, []);
 66322:   },
 66322: 
 66322:   alertCheck: function alertCheck(aTitle, aText, aCheckMsg, aCheckState) {
 83577:     let data = this.commonPrompt(aTitle, aText, [{ label: PromptUtils.getLocaleString("OK") }], aCheckMsg, aCheckState, []);
 83577:     if (aCheckMsg)
 83577:       aCheckState.value = data.checkbox == "true";
 66322:   },
 66322: 
 66322:   confirm: function confirm(aTitle, aText) {
 83577:     let data = this.commonPrompt(aTitle, aText, null, "", {value: false}, []);
 83577:     return (data.button == 0);
 66322:   },
 66322: 
 66322:   confirmCheck: function confirmCheck(aTitle, aText, aCheckMsg, aCheckState) {
 83577:     let data = this.commonPrompt(aTitle, aText, null, aCheckMsg, aCheckState, []);
104749:     let ok = data.button == 0;
 83577:     if (aCheckMsg)
 83577:       aCheckState.value = data.checkbox == "true";
104749:     return ok;
 66322:   },
 66322: 
 66322:   confirmEx: function confirmEx(aTitle, aText, aButtonFlags, aButton0,
 65507:                       aButton1, aButton2, aCheckMsg, aCheckState) {
 83577:     let buttons = [];
 65507:     let titles = [aButton0, aButton1, aButton2];
 65507:     for (let i = 0; i < 3; i++) {
 65507:       let bTitle = null;
 65507:       switch (aButtonFlags & 0xff) {
 65507:         case Ci.nsIPromptService.BUTTON_TITLE_OK :
 66322:           bTitle = PromptUtils.getLocaleString("OK");
 65507:           break;
 65507:         case Ci.nsIPromptService.BUTTON_TITLE_CANCEL :
 66322:           bTitle = PromptUtils.getLocaleString("Cancel");
 65507:           break;
 65507:         case Ci.nsIPromptService.BUTTON_TITLE_YES :
 66322:           bTitle = PromptUtils.getLocaleString("Yes");
 65507:           break;
 65507:         case Ci.nsIPromptService.BUTTON_TITLE_NO :
 66322:           bTitle = PromptUtils.getLocaleString("No");
 65507:           break;
 65507:         case Ci.nsIPromptService.BUTTON_TITLE_SAVE :
 66322:           bTitle = PromptUtils.getLocaleString("Save");
 65507:           break;
 65507:         case Ci.nsIPromptService.BUTTON_TITLE_DONT_SAVE :
 66322:           bTitle = PromptUtils.getLocaleString("DontSave");
 65507:           break;
 65507:         case Ci.nsIPromptService.BUTTON_TITLE_REVERT :
 66322:           bTitle = PromptUtils.getLocaleString("Revert");
 65507:           break;
 65507:         case Ci.nsIPromptService.BUTTON_TITLE_IS_STRING :
 86776:           bTitle = PromptUtils.cleanUpLabel(titles[i]);
 65507:         break;
 65507:       }
 65507: 
 83577:       if (bTitle)
 83577:         buttons.push({label:bTitle});
 65507: 
 65507:       aButtonFlags >>= 8;
 65507:     }
 65507: 
 83577:     let data = this.commonPrompt(aTitle, aText, buttons, aCheckMsg, aCheckState, []);
 83577:     aCheckState.value = data.checkbox == "true";
 83577:     return data.button;
 65507:   },
 65507: 
 66322:   nsIPrompt_prompt: function nsIPrompt_prompt(aTitle, aText, aValue, aCheckMsg, aCheckState) {
 83577:     let inputs = [{ type: "textbox", value: aValue.value }];
 83577:     let data = this.commonPrompt(aTitle, aText, null, aCheckMsg, aCheckState, inputs);
 83577: 
104749:     let ok = data.button == 0;
 83577:     if (aCheckMsg)
 83577:       aCheckState.value = data.checkbox == "true";
104749:     if (ok)
 83577:       aValue.value = data.textbox;
104749:     return ok;
 65507:   },
 65507: 
 66322:   nsIPrompt_promptPassword: function nsIPrompt_promptPassword(
 66322:       aTitle, aText, aPassword, aCheckMsg, aCheckState) {
 86025:     let inputs = [{ type: "password", hint: "Password", value: aPassword.value || "" }];
 83577:     let data = this.commonPrompt(aTitle, aText, null, aCheckMsg, aCheckState, inputs);
 83577: 
104749:     let ok = data.button == 0;
 83577:     if (aCheckMsg)
 83577:       aCheckState.value = data.checkbox == "true";
104749:     if (ok)
 83577:       aPassword.value = data.password;
104749:     return ok;
 65507:   },
 65507: 
 66322:   nsIPrompt_promptUsernameAndPassword: function nsIPrompt_promptUsernameAndPassword(
 66322:       aTitle, aText, aUsername, aPassword, aCheckMsg, aCheckState) {
 83577:     let inputs = [{ type: "textbox",  hint: PromptUtils.getLocaleString("username", "passwdmgr"), value: aUsername.value },
 83577:                   { type: "password", hint: PromptUtils.getLocaleString("password", "passwdmgr"), value: aPassword.value }];
 83577:     let data = this.commonPrompt(aTitle, aText, null, aCheckMsg, aCheckState, inputs);
104749: 
104749:     let ok = data.button == 0;
 83577:     if (aCheckMsg)
 83577:       aCheckState.value = data.checkbox == "true";
104749:     if (ok) {
 83577:       aUsername.value = data.textbox;
 83577:       aPassword.value = data.password;
104749:     }
104749:     return ok;
 65507:   },
 65507: 
 66322:   select: function select(aTitle, aText, aCount, aSelectList, aOutSelection) {
 83577:     let data = this.commonPrompt(aTitle, aText, [
 83577:       { label: PromptUtils.getLocaleString("OK") }
 83577:     ], "", {value: false}, [
 83577:       { type: "menulist",  values: aSelectList },
 83577:     ]);
104749: 
104749:     let ok = data.button == 0;
104749:     if (ok)
 83577:       aOutSelection.value = data.menulist;
104749: 
104749:     return ok;
 66322:   },
 66322: 
 66322:   /* ----------  nsIAuthPrompt  ---------- */
 66322: 
 66322:   nsIAuthPrompt_prompt : function (title, text, passwordRealm, savePassword, defaultText, result) {
 66584:     // TODO: Port functions from nsLoginManagerPrompter.js to here
 66322:     if (defaultText)
 66322:       result.value = defaultText;
 66322:     return this.nsIPrompt_prompt(title, text, result, null, {});
 66322:   },
 66322: 
 66585:   nsIAuthPrompt_promptUsernameAndPassword : function (aTitle, aText, aPasswordRealm, aSavePassword, aUser, aPass) {
 66585:     return nsIAuthPrompt_loginPrompt(aTitle, aText, aPasswordRealm, aSavePassword, aUser, aPass);
 66322:   },
 66322: 
 66585:   nsIAuthPrompt_promptPassword : function (aTitle, aText, aPasswordRealm, aSavePassword, aPass) {
 66585:     return nsIAuthPrompt_loginPrompt(aTitle, aText, aPasswordRealm, aSavePassword, null, aPass);
 66322:   },
 66322: 
 66585:   nsIAuthPrompt_loginPrompt: function(aTitle, aPasswordRealm, aSavePassword, aUser, aPass) {
 66585:     let checkMsg = null;
 66585:     let check = { value: false };
 66585:     let [hostname, realm, aUser] = PromptUtils.getHostnameAndRealm(aPasswordRealm);
 66585: 
 66585:     let canSave = PromptUtils.canSaveLogin(hostname, aSavePassword);
 66585:     if (canSave) {
 66585:       // Look for existing logins.
 66585:       let foundLogins = PromptUtils.pwmgr.findLogins({}, hostname, null, realm);
 66585:       [checkMsg, check] = PromptUtils.getUsernameAndPassword(foundLogins, aUser, aPass);
 66585:     }
 66585: 
 66585:     let ok = false;
 66585:     if (aUser)
 66585:       ok = this.nsIPrompt_promptUsernameAndPassword(aTitle, aText, aUser, aPass, checkMsg, check);
 66585:     else
 66585:       ok = this.nsIPrompt_promptPassword(aTitle, aText, aPass, checkMsg, check);
 66585: 
 66585:     if (ok && canSave && check.value)
 66585:       PromptUtils.savePassword(hostname, realm, aUser, aPass);
 66585: 
104749:     return ok;
104749:   },
 66585: 
 66322:   /* ----------  nsIAuthPrompt2  ---------- */
 66322: 
 66584:   promptAuth: function promptAuth(aChannel, aLevel, aAuthInfo) {
 66585:     let checkMsg = null;
 66585:     let check = { value: false };
 66585:     let message = PromptUtils.makeDialogText(aChannel, aAuthInfo);
 66585:     let [username, password] = PromptUtils.getAuthInfo(aAuthInfo);
 66585:     let [hostname, httpRealm] = PromptUtils.getAuthTarget(aChannel, aAuthInfo);
 66585:     let foundLogins = PromptUtils.pwmgr.findLogins({}, hostname, null, httpRealm);
 66322: 
 66585:     let canSave = PromptUtils.canSaveLogin(hostname, null);
 66585:     if (canSave)
 66585:       [checkMsg, check] = PromptUtils.getUsernameAndPassword(foundLogins, username, password);
 66322: 
 66585:     if (username.value && password.value) {
 66585:       PromptUtils.setAuthInfo(aAuthInfo, username.value, password.value);
 65519:     }
 66322: 
 74530:     let canAutologin = false;
 74530:     if (aAuthInfo.flags & Ci.nsIAuthInformation.AUTH_PROXY &&
 74530:         !(aAuthInfo.flags & Ci.nsIAuthInformation.PREVIOUS_FAILED) &&
 74530:         Services.prefs.getBoolPref("signon.autologin.proxy"))
 74530:       canAutologin = true;
 74530: 
 74530:     let ok = canAutologin;
 74530:     if (!ok && aAuthInfo.flags & Ci.nsIAuthInformation.ONLY_PASSWORD)
 66585:       ok = this.nsIPrompt_promptPassword(null, message, password, checkMsg, check);
 74530:     else if (!ok)
 66585:       ok = this.nsIPrompt_promptUsernameAndPassword(null, message, username, password, checkMsg, check);
 66585: 
 66585:     PromptUtils.setAuthInfo(aAuthInfo, username.value, password.value);
 66585: 
 74530:     if (ok && canSave && check.value)
 66585:       PromptUtils.savePassword(foundLogins, username, password, hostname, httpRealm);
 66585: 
 66585:     return ok;
 65519:   },
 65519: 
 74530:   _asyncPrompts: {},
 74530:   _asyncPromptInProgress: false,
 74530: 
 74530:   _doAsyncPrompt : function() {
 74530:     if (this._asyncPromptInProgress)
 74530:       return;
 74530: 
 74530:     // Find the first prompt key we have in the queue
 74530:     let hashKey = null;
 74530:     for (hashKey in this._asyncPrompts)
 74530:       break;
 74530: 
 74530:     if (!hashKey)
 74530:       return;
 74530: 
 74530:     // If login manger has logins for this host, defer prompting if we're
 74530:     // already waiting on a master password entry.
 74530:     let prompt = this._asyncPrompts[hashKey];
 74530:     let prompter = prompt.prompter;
 74530:     let [hostname, httpRealm] = PromptUtils.getAuthTarget(prompt.channel, prompt.authInfo);
 74530:     let foundLogins = PromptUtils.pwmgr.findLogins({}, hostname, null, httpRealm);
 74530:     if (foundLogins.length > 0 && PromptUtils.pwmgr.uiBusy)
 74530:       return;
 74530: 
 74530:     this._asyncPromptInProgress = true;
 74530:     prompt.inProgress = true;
 74530: 
 74530:     let self = this;
 74530: 
 74530:     let runnable = {
 74530:       run: function() {
 74530:         let ok = false;
 74530:         try {
 74530:           ok = prompter.promptAuth(prompt.channel, prompt.level, prompt.authInfo);
 74530:         } catch (e) {
 74530:           Cu.reportError("_doAsyncPrompt:run: " + e + "\n");
 74530:         }
 74530: 
 74530:         delete self._asyncPrompts[hashKey];
 74530:         prompt.inProgress = false;
 74530:         self._asyncPromptInProgress = false;
 74530: 
 74530:         for each (let consumer in prompt.consumers) {
 74530:           if (!consumer.callback)
 74530:             // Not having a callback means that consumer didn't provide it
 74530:             // or canceled the notification
 74530:             continue;
 74530: 
 74530:           try {
 74530:             if (ok)
 74530:               consumer.callback.onAuthAvailable(consumer.context, prompt.authInfo);
 74530:             else
 74530:               consumer.callback.onAuthCancelled(consumer.context, true);
 74530:           } catch (e) { /* Throw away exceptions caused by callback */ }
 74530:         }
 74530:         self._doAsyncPrompt();
 74530:       }
 74530:     }
 74530: 
 74530:     Services.tm.mainThread.dispatch(runnable, Ci.nsIThread.DISPATCH_NORMAL);
 74530:   },
 74530: 
 66584:   asyncPromptAuth: function asyncPromptAuth(aChannel, aCallback, aContext, aLevel, aAuthInfo) {
 74530:     let cancelable = null;
 74530:     try {
 74530:       // If the user submits a login but it fails, we need to remove the
 74530:       // notification bar that was displayed. Conveniently, the user will
 74530:       // be prompted for authentication again, which brings us here.
 74530:       //this._removeLoginNotifications();
 74530: 
 74530:       cancelable = {
 74530:         QueryInterface: XPCOMUtils.generateQI([Ci.nsICancelable]),
 74530:         callback: aCallback,
 74530:         context: aContext,
 74530:         cancel: function() {
 74530:           this.callback.onAuthCancelled(this.context, false);
 74530:           this.callback = null;
 74530:           this.context = null;
 74530:         }
 74530:       };
 74530:       let [hostname, httpRealm] = PromptUtils.getAuthTarget(aChannel, aAuthInfo);
 74530:       let hashKey = aLevel + "|" + hostname + "|" + httpRealm;
 74530:       let asyncPrompt = this._asyncPrompts[hashKey];
 74530:       if (asyncPrompt) {
 74530:         asyncPrompt.consumers.push(cancelable);
 74530:         return cancelable;
 74530:       }
 74530: 
 74530:       asyncPrompt = {
 74530:         consumers: [cancelable],
 74530:         channel: aChannel,
 74530:         authInfo: aAuthInfo,
 74530:         level: aLevel,
 74530:         inProgress : false,
 74530:         prompter: this
 74530:       }
 74530: 
 74530:       this._asyncPrompts[hashKey] = asyncPrompt;
 74530:       this._doAsyncPrompt();
 74530:     } catch (e) {
 74530:       Cu.reportError("PromptService: " + e + "\n");
 74530:       throw e;
 74530:     }
 74530:     return cancelable;
 66322:   }
 66322: };
 66322: 
 66322: let PromptUtils = {
 66585:   getLocaleString: function pu_getLocaleString(aKey, aService) {
 66585:     if (aService == "passwdmgr")
 86776:       return this.cleanUpLabel(this.passwdBundle.GetStringFromName(aKey));
 66584: 
 86776:     return this.cleanUpLabel(this.bundle.GetStringFromName(aKey));
 86776:   },
 86776: 
 86776:   //
 86776:   // Copied from chrome://global/content/commonDialog.js
 86776:   //
 86776:   cleanUpLabel: function cleanUpLabel(aLabel) {
 86776:     // This is for labels which may contain embedded access keys.
 86776:     // If we end in (&X) where X represents the access key, optionally preceded
 86776:     // by spaces and/or followed by the ':' character,
 86776:     // remove the access key placeholder + leading spaces from the label.
 86776:     // Otherwise a character preceded by one but not two &s is the access key.
 86776: 
 86776:     // Note that if you change the following code, see the comment of
 86776:     // nsTextBoxFrame::UpdateAccessTitle.
 86776:     if (!aLabel)
 86776:       return "";
 86776: 
 86776:     if (/ *\(\&([^&])\)(:)?$/.test(aLabel)) {
 86776:       aLabel = RegExp.leftContext + RegExp.$2;
 86776:     } else if (/^(.*[^&])?\&(([^&]).*$)/.test(aLabel)) {
 86776:       aLabel = RegExp.$1 + RegExp.$2;
 86776:     }
 86776: 
 86776:     // Special code for using that & symbol
 86776:     aLabel = aLabel.replace(/\&\&/g, "&");
 86776: 
 86776:     return aLabel;
 66322:   },
 66322: 
 66585:   get pwmgr() {
 66585:     delete this.pwmgr;
 66585:     return this.pwmgr = Cc["@mozilla.org/login-manager;1"].getService(Ci.nsILoginManager);
 66585:   },
 66585: 
 66585:   getHostnameAndRealm: function pu_getHostnameAndRealm(aRealmString) {
 66585:     let httpRealm = /^.+ \(.+\)$/;
 66585:     if (httpRealm.test(aRealmString))
 66585:       return [null, null, null];
 66585: 
 66585:     let uri = Services.io.newURI(aRealmString, null, null);
 66585:     let pathname = "";
 66585: 
 66585:     if (uri.path != "/")
 66585:       pathname = uri.path;
 66585: 
 66585:     let formattedHostname = this._getFormattedHostname(uri);
 66585:     return [formattedHostname, formattedHostname + pathname, uri.username];
 66585:   },
 66585: 
 66585:   canSaveLogin: function pu_canSaveLogin(aHostname, aSavePassword) {
 66585:     let canSave = !this._inPrivateBrowsing && this.pwmgr.getLoginSavingEnabled(aHostname)
 66585:     if (aSavePassword)
 66585:       canSave = canSave && (aSavePassword == Ci.nsIAuthPrompt.SAVE_PASSWORD_PERMANENTLY)
 66585:     return canSave;
 66585:   },
 66585: 
 66585:   getUsernameAndPassword: function pu_getUsernameAndPassword(aFoundLogins, aUser, aPass) {
 66585:     let checkLabel = null;
 66585:     let check = { value: false };
 66585:     let selectedLogin;
 66585: 
 66585:     checkLabel = this.getLocaleString("rememberPassword", "passwdmgr");
 66585: 
 66585:     // XXX Like the original code, we can't deal with multiple
 66585:     // account selection. (bug 227632)
 66585:     if (aFoundLogins.length > 0) {
 66585:       selectedLogin = aFoundLogins[0];
 66585: 
 66585:       // If the caller provided a username, try to use it. If they
 66585:       // provided only a password, this will try to find a password-only
 66585:       // login (or return null if none exists).
 66585:       if (aUser.value)
 66585:         selectedLogin = this.findLogin(aFoundLogins, "username", aUser.value);
 66585: 
 66585:       if (selectedLogin) {
 66585:         check.value = true;
 66585:         aUser.value = selectedLogin.username;
 66585:         // If the caller provided a password, prefer it.
 66585:         if (!aPass.value)
 66585:           aPass.value = selectedLogin.password;
 66585:       }
 65519:     }
 65519: 
 66585:     return [checkLabel, check];
 66585:   },
 65519: 
 66585:   findLogin: function pu_findLogin(aLogins, aName, aValue) {
 66585:     for (let i = 0; i < aLogins.length; i++)
 66585:       if (aLogins[i][aName] == aValue)
 66585:         return aLogins[i];
 66585:     return null;
 66585:   },
 66585: 
 66585:   savePassword: function pu_savePassword(aLogins, aUser, aPass, aHostname, aRealm) {
 66585:     let selectedLogin = this.findLogin(aLogins, "username", aUser.value);
 66585: 
 66585:     // If we didn't find an existing login, or if the username
 66585:     // changed, save as a new login.
 66585:     if (!selectedLogin) {
 66585:       // add as new
 66585:       var newLogin = Cc["@mozilla.org/login-manager/loginInfo;1"].createInstance(Ci.nsILoginInfo);
 66585:       newLogin.init(aHostname, null, aRealm, aUser.value, aPass.value, "", "");
 66585:       this.pwmgr.addLogin(newLogin);
 66585:     } else if (aPass.value != selectedLogin.password) {
 66585:       // update password
 66585:       this.updateLogin(selectedLogin, aPass.value);
 65519:     } else {
 66585:       this.updateLogin(selectedLogin);
 66585:     }
 66585:   },
 66585: 
 66585:   updateLogin: function pu_updateLogin(aLogin, aPassword) {
 66585:     let now = Date.now();
 66585:     let propBag = Cc["@mozilla.org/hash-property-bag;1"].createInstance(Ci.nsIWritablePropertyBag);
 66585:     if (aPassword) {
 66585:       propBag.setProperty("password", aPassword);
 66585:       // Explicitly set the password change time here (even though it would
 66585:       // be changed automatically), to ensure that it's exactly the same
 66585:       // value as timeLastUsed.
 66585:       propBag.setProperty("timePasswordChanged", now);
 66585:     }
 66585:     propBag.setProperty("timeLastUsed", now);
 66585:     propBag.setProperty("timesUsedIncrement", 1);
 66585: 
 66585:     this.pwmgr.modifyLogin(aLogin, propBag);
 66585:   },
 66585: 
 66585:   // JS port of http://mxr.mozilla.org/mozilla-central/source/embedding/components/windowwatcher/src/nsPrompt.cpp#388
 66585:   makeDialogText: function pu_makeDialogText(aChannel, aAuthInfo) {
 66585:     let isProxy    = (aAuthInfo.flags & Ci.nsIAuthInformation.AUTH_PROXY);
 66585:     let isPassOnly = (aAuthInfo.flags & Ci.nsIAuthInformation.ONLY_PASSWORD);
 66585: 
 66585:     let username = aAuthInfo.username;
 66585:     let [displayHost, realm] = this.getAuthTarget(aChannel, aAuthInfo);
 66585: 
 66585:     // Suppress "the site says: $realm" when we synthesized a missing realm.
 66585:     if (!aAuthInfo.realm && !isProxy)
 66585:     realm = "";
 66585: 
 66585:     // Trim obnoxiously long realms.
 66585:     if (realm.length > 150) {
 66585:       realm = realm.substring(0, 150);
 66585:       // Append "..." (or localized equivalent).
 66585:       realm += this.ellipsis;
 65519:     }
 65519: 
 66585:     let text;
 66585:     if (isProxy)
 66585:       text = this.bundle.formatStringFromName("EnterLoginForProxy", [realm, displayHost], 2);
 66585:     else if (isPassOnly)
 66585:       text = this.bundle.formatStringFromName("EnterPasswordFor", [username, displayHost], 2);
 66585:     else if (!realm)
 66585:       text = this.bundle.formatStringFromName("EnterUserPasswordFor", [displayHost], 1);
 66585:     else
 66585:       text = this.bundle.formatStringFromName("EnterLoginForRealm", [realm, displayHost], 2);
 65519: 
 66585:     return text;
 65519:   },
 65519: 
 66322:   // JS port of http://mxr.mozilla.org/mozilla-central/source/embedding/components/windowwatcher/public/nsPromptUtils.h#89
 66585:   getAuthHostPort: function pu_getAuthHostPort(aChannel, aAuthInfo) {
 66322:     let uri = aChannel.URI;
 66322:     let res = { host: null, port: -1 };
 66322:     if (aAuthInfo.flags & aAuthInfo.AUTH_PROXY) {
 66322:       let proxy = aChannel.QueryInterface(Ci.nsIProxiedChannel);
 66322:       res.host = proxy.proxyInfo.host;
 66322:       res.port = proxy.proxyInfo.port;
 66322:     } else {
 66322:       res.host = uri.host;
 66322:       res.port = uri.port;
 65519:     }
 65519:     return res;
 66585:   },
 66585: 
 66585:   getAuthTarget : function pu_getAuthTarget(aChannel, aAuthInfo) {
 66585:     let hostname, realm;
 66585:     // If our proxy is demanding authentication, don't use the
 66585:     // channel's actual destination.
 66585:     if (aAuthInfo.flags & Ci.nsIAuthInformation.AUTH_PROXY) {
 66585:         if (!(aChannel instanceof Ci.nsIProxiedChannel))
 66585:           throw "proxy auth needs nsIProxiedChannel";
 66585: 
 66585:       let info = aChannel.proxyInfo;
 66585:       if (!info)
 66585:         throw "proxy auth needs nsIProxyInfo";
 66585: 
 66585:       // Proxies don't have a scheme, but we'll use "moz-proxy://"
 66585:       // so that it's more obvious what the login is for.
 66585:       let idnService = Cc["@mozilla.org/network/idn-service;1"].getService(Ci.nsIIDNService);
 66585:       hostname = "moz-proxy://" + idnService.convertUTF8toACE(info.host) + ":" + info.port;
 66585:       realm = aAuthInfo.realm;
 66585:       if (!realm)
 66585:         realm = hostname;
 66585: 
 66585:       return [hostname, realm];
 65507:     }
 66585:     hostname = this.getFormattedHostname(aChannel.URI);
 66585: 
 66585:     // If a HTTP WWW-Authenticate header specified a realm, that value
 66585:     // will be available here. If it wasn't set or wasn't HTTP, we'll use
 66585:     // the formatted hostname instead.
 66585:     realm = aAuthInfo.realm;
 66585:     if (!realm)
 66585:       realm = hostname;
 66585: 
 66585:     return [hostname, realm];
 66585:   },
 66585: 
 66585:   getAuthInfo : function pu_getAuthInfo(aAuthInfo) {
 66585:     let flags = aAuthInfo.flags;
 66585:     let username = {value: ""};
 66585:     let password = {value: ""};
 66585: 
 66585:     if (flags & Ci.nsIAuthInformation.NEED_DOMAIN && aAuthInfo.domain)
 66585:       username.value = aAuthInfo.domain + "\\" + aAuthInfo.username;
 66585:     else
 66585:       username.value = aAuthInfo.username;
 66585: 
 66585:     password.value = aAuthInfo.password
 66585: 
 66585:     return [username, password];
 66585:   },
 66585: 
 66585:   setAuthInfo : function (aAuthInfo, username, password) {
 66585:     var flags = aAuthInfo.flags;
 66585:     if (flags & Ci.nsIAuthInformation.NEED_DOMAIN) {
 66585:       // Domain is separated from username by a backslash
 66585:       var idx = username.indexOf("\\");
 66585:       if (idx == -1) {
 66585:         aAuthInfo.username = username;
 66585:       } else {
 66585:         aAuthInfo.domain   =  username.substring(0, idx);
 66585:         aAuthInfo.username =  username.substring(idx+1);
 66585:       }
 66585:     } else {
 66585:       aAuthInfo.username = username;
 66585:     }
 66585:     aAuthInfo.password = password;
 66585:   },
 66585: 
 66585:   getFormattedHostname : function pu_getFormattedHostname(uri) {
 66585:     let scheme = uri.scheme;
 66585:     let hostname = scheme + "://" + uri.host;
 66585: 
 66585:     // If the URI explicitly specified a port, only include it when
 66585:     // it's not the default. (We never want "http://foo.com:80")
 66585:     port = uri.port;
 66585:     if (port != -1) {
 66585:       let handler = Services.io.getProtocolHandler(scheme);
 66585:       if (port != handler.defaultPort)
 66585:         hostname += ":" + port;
 66585:     }
 66585:     return hostname;
 66585:   },
 91677: 
 83577:   sendMessageToJava: function(aMsg) {
 83577:     let data = Cc["@mozilla.org/android/bridge;1"].getService(Ci.nsIAndroidBridge).handleGeckoMessage(JSON.stringify({ gecko: aMsg }));
 83577:     return JSON.parse(data);
 91677:   },
 91677: 
 91677:   fireDialogEvent: function(aDomWin, aEventName) {
 91677:     let event = aDomWin.document.createEvent("Events");
 91677:     event.initEvent(aEventName, true, true);
 91677:     aDomWin.dispatchEvent(event);
 83577:   }
 65507: };
 65507: 
 66584: XPCOMUtils.defineLazyGetter(PromptUtils, "passwdBundle", function () {
 66584:   return Services.strings.createBundle("chrome://passwordmgr/locale/passwordmgr.properties");
 66584: });
 66584: 
 66322: XPCOMUtils.defineLazyGetter(PromptUtils, "bundle", function () {
 66362:   return Services.strings.createBundle("chrome://global/locale/commonDialogs.properties");
 66322: });
 66322: 
 66346: const NSGetFactory = XPCOMUtils.generateNSGetFactory([PromptService]);
