34546: /* -*- Mode: C++; tab-width: 40; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
34546: /* ***** BEGIN LICENSE BLOCK *****
34546:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
34546:  *
34546:  * The contents of this file are subject to the Mozilla Public License Version
34546:  * 1.1 (the "License"); you may not use this file except in compliance with
34546:  * the License. You may obtain a copy of the License at
34546:  * http://www.mozilla.org/MPL/
34546:  *
34546:  * Software distributed under the License is distributed on an "AS IS" basis,
34546:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
34546:  * for the specific language governing rights and limitations under the
34546:  * License.
34546:  *
34546:  * The Original Code is mozilla.org code.
34546:  *
67612:  * The Initial Developer of the Original Code is the Mozilla Foundation.
34546:  * Portions created by the Initial Developer are Copyright (C) 2009
34546:  * the Initial Developer. All Rights Reserved.
34546:  *
34546:  * Contributor(s):
34546:  *  Vladimir Vukicevic <vladimir@pobox.com>
34546:  *
34546:  * Alternatively, the contents of this file may be used under the terms of
34546:  * either the GNU General Public License Version 2 or later (the "GPL"), or
34546:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
34546:  * in which case the provisions of the GPL or the LGPL are applicable instead
34546:  * of those above. If you wish to allow use of your version of this file only
34546:  * under the terms of either the GPL or the LGPL, and not to allow others to
34546:  * use your version of this file under the terms of the MPL, indicate your
34546:  * decision by deleting the provisions above and replace them with the notice
34546:  * and other provisions required by the GPL or the LGPL. If you do not delete
34546:  * the provisions above, a recipient may use your version of this file under
34546:  * the terms of any one of the MPL, the GPL or the LGPL.
34546:  *
34546:  * ***** END LICENSE BLOCK ***** */
34546: 
34546: #include <windows.h>
34546: #include <winternl.h>
34546: 
34546: #include <stdio.h>
82446: #include <string.h>
82446: 
82446: #include <map>
34546: 
71934: #ifdef XRE_WANT_DLL_BLOCKLIST
71934: #define XRE_SetupDllBlocklist SetupDllBlocklist
71934: #else
71934: #include "nsXULAppAPI.h"
71934: #endif
71934: 
34546: #include "nsAutoPtr.h"
90723: #include "nsThreadUtils.h"
34546: 
34546: #include "prlog.h"
34546: 
34546: #include "nsWindowsDllInterceptor.h"
34546: 
78610: #if defined(MOZ_CRASHREPORTER) && !defined(NO_BLOCKLIST_CRASHREPORTER)
78469: #include "nsExceptionHandler.h"
78495: #endif
78469: 
78469: #define ALL_VERSIONS   ((unsigned long long)-1LL)
78469: 
78469: // DLLs sometimes ship without a version number, particularly early
78469: // releases. Blocking "version <= 0" has the effect of blocking unversioned
78469: // DLLs (since the call to get version info fails), but not blocking
78469: // any versioned instance.
78469: #define UNVERSIONED    ((unsigned long long)0LL)
78469: 
78469: // Convert the 4 (decimal) components of a DLL version number into a
78469: // single unsigned long long, as needed by the blocklist
78469: #define MAKE_VERSION(a,b,c,d)\
78469:   ((a##ULL << 48) + (b##ULL << 32) + (c##ULL << 16) + d##ULL)
78469: 
78469: struct DllBlockInfo {
78469:   // The name of the DLL -- in LOWERCASE!  It will be compared to
78469:   // a lowercase version of the DLL name only.
78469:   const char *name;
78469: 
78469:   // If maxVersion is ALL_VERSIONS, we'll block all versions of this
78469:   // dll.  Otherwise, we'll block all versions less than or equal to
78469:   // the given version, as queried by GetFileVersionInfo and
78469:   // VS_FIXEDFILEINFO's dwFileVersionMS and dwFileVersionLS fields.
78469:   //
78469:   // Note that the version is usually 4 components, which is A.B.C.D
78469:   // encoded as 0x AAAA BBBB CCCC DDDD ULL (spaces added for clarity),
78469:   // but it's not required to be of that format.
78469:   unsigned long long maxVersion;
78469: };
78469: 
78469: static DllBlockInfo sWindowsDllBlocklist[] = {
78469:   // EXAMPLE:
78469:   // { "uxtheme.dll", ALL_VERSIONS },
78469:   // { "uxtheme.dll", 0x0000123400000000ULL },
78469:   // The DLL name must be in lowercase!
78469:   
78469:   // NPFFAddon - Known malware
78469:   { "npffaddon.dll", ALL_VERSIONS},
78469: 
78469:   // AVG 8 - Antivirus vendor AVG, old version, plugin already blocklisted
78469:   {"avgrsstx.dll", MAKE_VERSION(8,5,0,401)},
78469:   
78469:   // calc.dll - Suspected malware
78469:   {"calc.dll", MAKE_VERSION(1,0,0,1)},
78469: 
78469:   // hook.dll - Suspected malware
78469:   {"hook.dll", ALL_VERSIONS},
78469:   
78469:   // GoogleDesktopNetwork3.dll - Extremely old, unversioned instances
78469:   // of this DLL cause crashes
78469:   {"googledesktopnetwork3.dll", UNVERSIONED},
78469: 
78469:   // rdolib.dll - Suspected malware
78469:   {"rdolib.dll", MAKE_VERSION(6,0,88,4)},
78469: 
78469:   // fgjk4wvb.dll - Suspected malware
78469:   {"fgjk4wvb.dll", MAKE_VERSION(8,8,8,8)},
78469:   
78469:   // radhslib.dll - Naomi internet filter - unmaintained since 2006
78469:   {"radhslib.dll", UNVERSIONED},
78469: 
78469:   // Music download filter for vkontakte.ru - old instances
78469:   // of this DLL cause crashes
78469:   {"vksaver.dll", MAKE_VERSION(2,2,2,0)},
78469: 
78469:   // Topcrash in Firefox 4.0b1
78469:   {"rlxf.dll", MAKE_VERSION(1,2,323,1)},
78469: 
78469:   // psicon.dll - Topcrashes in Thunderbird, and some crashes in Firefox
78469:   // Adobe photoshop library, now redundant in later installations
78469:   {"psicon.dll", ALL_VERSIONS},
78469: 
78469:   // Topcrash in Firefox 4 betas (bug 618899)
78469:   {"accelerator.dll", MAKE_VERSION(3,2,1,6)},
78469: 
82445:   // Topcrash with Roboform in Firefox 8 (bug 699134)
82445:   {"rf-firefox.dll", MAKE_VERSION(7,6,1,0)},
82445:   {"roboform.dll", MAKE_VERSION(7,6,1,0)},
82445: 
78469:   // leave these two in always for tests
78469:   { "mozdllblockingtest.dll", ALL_VERSIONS },
78469:   { "mozdllblockingtest_versioned.dll", 0x0000000400000000ULL },
78469: 
78469:   { NULL, 0 }
78469: };
34546: 
34611: #ifndef STATUS_DLL_NOT_FOUND
34611: #define STATUS_DLL_NOT_FOUND ((DWORD)0xC0000135L)
34611: #endif
34611: 
34749: // define this for very verbose dll load debug spew
34749: #undef DEBUG_very_verbose
34749: 
90723: extern bool gInXPCOMLoadOnMainThread;
90723: 
82446: namespace {
82446: 
34546: typedef NTSTATUS (NTAPI *LdrLoadDll_func) (PWCHAR filePath, PULONG flags, PUNICODE_STRING moduleFileName, PHANDLE handle);
34546: 
34546: static LdrLoadDll_func stub_LdrLoadDll = 0;
34546: 
90723: template <class T>
90723: struct RVAMap {
90723:   RVAMap(HANDLE map, DWORD offset) {
90723:     SYSTEM_INFO info;
90723:     GetSystemInfo(&info);
90723: 
90723:     DWORD alignedOffset = (offset / info.dwAllocationGranularity) *
90723:                           info.dwAllocationGranularity;
90723: 
90723:     NS_ASSERTION(offset - alignedOffset < info.dwAllocationGranularity, "Wtf");
90723: 
90723:     mRealView = ::MapViewOfFile(map, FILE_MAP_READ, 0, alignedOffset,
90723:                                 sizeof(T) + (offset - alignedOffset));
90723: 
92537:     mMappedView = mRealView ? reinterpret_cast<T*>((char*)mRealView + (offset - alignedOffset)) :
92537:                               nsnull;
90723:   }
90723:   ~RVAMap() {
90723:     if (mRealView) {
90723:       ::UnmapViewOfFile(mRealView);
90723:     }
90723:   }
90723:   operator const T*() const { return mMappedView; }
90723:   const T* operator->() const { return mMappedView; }
90723: private:
90723:   const T* mMappedView;
90723:   void* mRealView;
90723: };
90723: 
90723: bool
90723: CheckASLR(const wchar_t* path)
90723: {
90723:   bool retval = false;
90723: 
90723:   HANDLE file = ::CreateFileW(path, GENERIC_READ, FILE_SHARE_READ,
90723:                               NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
90723:                               NULL);
90723:   if (file != INVALID_HANDLE_VALUE) {
90723:     HANDLE map = ::CreateFileMappingW(file, NULL, PAGE_READONLY, 0, 0, NULL);
90723:     if (map) {
90723:       RVAMap<IMAGE_DOS_HEADER> peHeader(map, 0);
90723:       if (peHeader) {
90723:         RVAMap<IMAGE_NT_HEADERS> ntHeader(map, peHeader->e_lfanew);
90723:         if (ntHeader) {
90723:           // If the DLL has no code, permit it regardless of ASLR status.
90723:           if (ntHeader->OptionalHeader.SizeOfCode == 0) {
90723:             retval = true;
90723:           }
90723:           // Check to see if the DLL supports ASLR
90723:           else if ((ntHeader->OptionalHeader.DllCharacteristics &
90723:                     IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) != 0) {
90723:             retval = true;
90723:           }
90723:         }
90723:       }
90723:       ::CloseHandle(map);
90723:     }
90723:     ::CloseHandle(file);
90723:   }
90723: 
90723:   return retval;
90723: }
90723: 
82446: /**
82446:  * Some versions of Windows call LoadLibraryEx to get the version information
82446:  * for a DLL, which causes our patched LdrLoadDll implementation to re-enter
82446:  * itself and cause infinite recursion and a stack-exhaustion crash. We protect
82446:  * against reentrancy by allowing recursive loads of the same DLL.
82446:  *
82446:  * Note that we don't use __declspec(thread) because that doesn't work in DLLs
82446:  * loaded via LoadLibrary and there can be a limited number of TLS slots, so
82446:  * we roll our own.
82446:  */
82446: class ReentrancySentinel
82446: {
82446: public:
82446:   explicit ReentrancySentinel(const char* dllName)
82446:   {
82446:     DWORD currentThreadId = GetCurrentThreadId();
82446:     EnterCriticalSection(&sLock);
82446:     mPreviousDllName = (*sThreadMap)[currentThreadId];
82446: 
82446:     // If there is a DLL currently being loaded and it has the same name
82446:     // as the current attempt, we're re-entering.
82446:     mReentered = mPreviousDllName && !stricmp(mPreviousDllName, dllName);
82446:     (*sThreadMap)[currentThreadId] = dllName;
82446:     LeaveCriticalSection(&sLock);
82446:   }
82446:     
82446:   ~ReentrancySentinel()
82446:   {
82446:     DWORD currentThreadId = GetCurrentThreadId();
82446:     EnterCriticalSection(&sLock);
82446:     (*sThreadMap)[currentThreadId] = mPreviousDllName;
82446:     LeaveCriticalSection(&sLock);
82446:   }
82446: 
82446:   bool BailOut() const
82446:   {
82446:     return mReentered;
82446:   };
82446:     
82446:   static void InitializeStatics()
82446:   {
82446:     InitializeCriticalSection(&sLock);
82446:     sThreadMap = new std::map<DWORD, const char*>;
82446:   }
82446: 
82446: private:
82446:   static CRITICAL_SECTION sLock;
82446:   static std::map<DWORD, const char*>* sThreadMap;
82446: 
82446:   const char* mPreviousDllName;
82446:   bool mReentered;
82446: };
82446: 
82446: CRITICAL_SECTION ReentrancySentinel::sLock;
82446: std::map<DWORD, const char*>* ReentrancySentinel::sThreadMap;
82446: 
91323: static
91323: wchar_t* getFullPath (PWCHAR filePath, wchar_t* fname)
91323: {
91323:   // In Windows 8, the first parameter seems to be used for more than just the
91323:   // path name.  For example, its numerical value can be 1.  Passing a non-valid
91323:   // pointer to SearchPathW will cause a crash, so we need to check to see if we
91323:   // are handed a valid pointer, and otherwise just pass NULL to SearchPathW.
91323:   PWCHAR sanitizedFilePath = (intptr_t(filePath) < 1024) ? NULL : filePath;
91323: 
91323:   // figure out the length of the string that we need
91323:   DWORD pathlen = SearchPathW(sanitizedFilePath, fname, L".dll", 0, NULL, NULL);
91323:   if (pathlen == 0) {
91323:     return nsnull;
91323:   }
91323: 
91323:   wchar_t* full_fname = new wchar_t[pathlen+1];
91323:   if (!full_fname) {
91323:     // couldn't allocate memory?
91323:     return nsnull;
91323:   }
91323: 
91323:   // now actually grab it
91323:   SearchPathW(sanitizedFilePath, fname, L".dll", pathlen+1, full_fname, NULL);
91323:   return full_fname;
91323: }
91323: 
34546: static NTSTATUS NTAPI
34546: patched_LdrLoadDll (PWCHAR filePath, PULONG flags, PUNICODE_STRING moduleFileName, PHANDLE handle)
34546: {
34546:   // We have UCS2 (UTF16?), we want ASCII, but we also just want the filename portion
34546: #define DLLNAME_MAX 128
34546:   char dllName[DLLNAME_MAX+1];
72183:   wchar_t *dll_part;
72183:   DllBlockInfo *info;
34546: 
34749:   int len = moduleFileName->Length / 2;
34749:   wchar_t *fname = moduleFileName->Buffer;
91323:   nsAutoArrayPtr<wchar_t> full_fname;
90723: 
34749:   // The filename isn't guaranteed to be null terminated, but in practice
34749:   // it always will be; ensure that this is so, and bail if not.
34749:   // This is done instead of the more robust approach because of bug 527122,
34749:   // where lots of weird things were happening when we tried to make a copy.
34749:   if (moduleFileName->MaximumLength < moduleFileName->Length+2 ||
34749:       fname[len] != 0)
34749:   {
34749: #ifdef DEBUG
34749:     printf_stderr("LdrLoadDll: non-null terminated string found!\n");
34749: #endif
34749:     goto continue_loading;
34749:   }
34546: 
72183:   dll_part = wcsrchr(fname, L'\\');
34546:   if (dll_part) {
34546:     dll_part = dll_part + 1;
34749:     len -= dll_part - fname;
34546:   } else {
34546:     dll_part = fname;
34546:   }
34546: 
34749: #ifdef DEBUG_very_verbose
34749:   printf_stderr("LdrLoadDll: dll_part '%S' %d\n", dll_part, len);
34749: #endif
34749: 
34546:   // if it's too long, then, we assume we won't want to block it,
34546:   // since DLLNAME_MAX should be at least long enough to hold the longest
34546:   // entry in our blocklist.
34749:   if (len > DLLNAME_MAX) {
34749: #ifdef DEBUG
34749:     printf_stderr("LdrLoadDll: len too long! %d\n", len);
34749: #endif
34546:     goto continue_loading;
34749:   }
34546: 
34546:   // copy over to our char byte buffer, lowercasing ASCII as we go
34546:   for (int i = 0; i < len; i++) {
34546:     wchar_t c = dll_part[i];
34546: 
34546:     if (c > 0x7f) {
34546:       // welp, it's not ascii; if we need to add non-ascii things to
34546:       // our blocklist, we'll have to remove this limitation.
34546:       goto continue_loading;
34546:     }
34546: 
34749:     // ensure that dll name is all lowercase
34749:     if (c >= 'A' && c <= 'Z')
34749:       c += 'a' - 'A';
34749: 
34546:     dllName[i] = (char) c;
34546:   }
34546: 
34546:   dllName[len] = 0;
34546: 
34749: #ifdef DEBUG_very_verbose
34749:   printf_stderr("LdrLoadDll: dll name '%s'\n", dllName);
34749: #endif
34749: 
34546:   // then compare to everything on the blocklist
72183:   info = &sWindowsDllBlocklist[0];
34546:   while (info->name) {
34546:     if (strcmp(info->name, dllName) == 0)
34546:       break;
34546: 
34546:     info++;
34546:   }
34546: 
34546:   if (info->name) {
34749:     bool load_ok = false;
34749: 
34749: #ifdef DEBUG_very_verbose
34749:     printf_stderr("LdrLoadDll: info->name: '%s'\n", info->name);
34749: #endif
34546: 
34546:     if (info->maxVersion != ALL_VERSIONS) {
82446:       ReentrancySentinel sentinel(dllName);
82446:       if (sentinel.BailOut()) {
82446:         goto continue_loading;
82446:       }
82446: 
91323:       full_fname = getFullPath(filePath, fname);
91323:       if (!full_fname) {
91323:         // uh, we couldn't find the DLL at all, so...
91323:         printf_stderr("LdrLoadDll: Blocking load of '%s' (SearchPathW didn't find it?)\n", dllName);
91323:         return STATUS_DLL_NOT_FOUND;
91323:       }
91323: 
34546:       DWORD zero;
34546:       DWORD infoSize = GetFileVersionInfoSizeW(full_fname, &zero);
34546: 
34546:       // If we failed to get the version information, we block.
34546: 
34546:       if (infoSize != 0) {
72183:         nsAutoArrayPtr<unsigned char> infoData(new unsigned char[infoSize]);
34546:         VS_FIXEDFILEINFO *vInfo;
34546:         UINT vInfoLen;
34546: 
34546:         if (GetFileVersionInfoW(full_fname, 0, infoSize, infoData) &&
34546:             VerQueryValueW(infoData, L"\\", (LPVOID*) &vInfo, &vInfoLen))
34546:         {
34546:           unsigned long long fVersion =
34546:             ((unsigned long long)vInfo->dwFileVersionMS) << 32 |
34546:             ((unsigned long long)vInfo->dwFileVersionLS);
34546: 
34546:           // finally do the version check, and if it's greater than our block
34546:           // version, keep loading
34546:           if (fVersion > info->maxVersion)
34749:             load_ok = true;
34546:         }
34546:       }
34749:     }
34749: 
34749:     if (!load_ok) {
34749:       printf_stderr("LdrLoadDll: Blocking load of '%s' -- see http://www.mozilla.com/en-US/blocklist/\n", dllName);
34546:       return STATUS_DLL_NOT_FOUND;
34546:     }
34749:   }
34546: 
34546: continue_loading:
34749: #ifdef DEBUG_very_verbose
34749:   printf_stderr("LdrLoadDll: continuing load... ('%S')\n", moduleFileName->Buffer);
34749: #endif
34749: 
36467:   NS_SetHasLoadedNewDLLs();
36467: 
90723:   if (gInXPCOMLoadOnMainThread && NS_IsMainThread()) {
90723:     // Check to ensure that the DLL has ASLR.
91323:     full_fname = getFullPath(filePath, fname);
91323:     if (!full_fname) {
91323:       // uh, we couldn't find the DLL at all, so...
91323:       printf_stderr("LdrLoadDll: Blocking load of '%s' (SearchPathW didn't find it?)\n", dllName);
91323:       return STATUS_DLL_NOT_FOUND;
91323:     }
91323: 
90723:     if (!CheckASLR(full_fname)) {
90723:       printf_stderr("LdrLoadDll: Blocking load of '%s'.  XPCOM components must support ASLR.\n", dllName);
90723:       return STATUS_DLL_NOT_FOUND;
90723:     }
90723:   }
90723: 
34546:   return stub_LdrLoadDll(filePath, flags, moduleFileName, handle);
34546: }
34546: 
34546: WindowsDllInterceptor NtDllIntercept;
34546: 
82446: } // anonymous namespace
82446: 
34546: void
71934: XRE_SetupDllBlocklist()
34546: {
34546:   NtDllIntercept.Init("ntdll.dll");
34546: 
82446:   ReentrancySentinel::InitializeStatics();
82446: 
69198:   bool ok = NtDllIntercept.AddHook("LdrLoadDll", reinterpret_cast<intptr_t>(patched_LdrLoadDll), (void**) &stub_LdrLoadDll);
34546: 
34749: #ifdef DEBUG
34546:   if (!ok)
34749:     printf_stderr ("LdrLoadDll hook failed, no dll blocklisting active\n");
34749: #endif
78469: 
78610: #if defined(MOZ_CRASHREPORTER) && !defined(NO_BLOCKLIST_CRASHREPORTER)
78469:   if (!ok) {
78469:     CrashReporter::AppendAppNotesToCrashReport(NS_LITERAL_CSTRING("DllBlockList Failed\n"));
34546:   }
78495: #endif
78469: }
