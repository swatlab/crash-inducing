     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: 
     1: #ifndef nsEditorUtils_h__
     1: #define nsEditorUtils_h__
     1: 
     1: 
     1: #include "nsCOMPtr.h"
104487: #include "nsDebug.h"
104487: #include "nsEditor.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIEditor.h"
104487: #include "nscore.h"
104487: #include "prtypes.h"
     1: 
104487: class nsIAtom;
104487: class nsIContentIterator;
104487: class nsIDOMDocument;
104487: class nsIDOMRange;
104487: class nsISelection;
104487: template <class E> class nsCOMArray;
     1: 
     1: /***************************************************************************
     1:  * stack based helper class for batching a collection of txns inside a 
     1:  * placeholder txn.
     1:  */
 15596: class NS_STACK_CLASS nsAutoPlaceHolderBatch
     1: {
     1:   private:
     1:     nsCOMPtr<nsIEditor> mEd;
     1:   public:
     1:     nsAutoPlaceHolderBatch( nsIEditor *aEd, nsIAtom *atom) : mEd(do_QueryInterface(aEd)) 
     1:                    { if (mEd) mEd->BeginPlaceHolderTransaction(atom); }
     1:     ~nsAutoPlaceHolderBatch() { if (mEd) mEd->EndPlaceHolderTransaction(); }
     1: };
     1: 
     1: /***************************************************************************
     1:  * stack based helper class for batching a collection of txns.  
     1:  * Note: I changed this to use placeholder batching so that we get
     1:  * proper selection save/restore across undo/redo.
     1:  */
     1: class nsAutoEditBatch : public nsAutoPlaceHolderBatch
     1: {
     1:   public:
     1:     nsAutoEditBatch( nsIEditor *aEd) : nsAutoPlaceHolderBatch(aEd,nsnull)  {}
     1:     ~nsAutoEditBatch() {}
     1: };
     1: 
     1: /***************************************************************************
     1:  * stack based helper class for saving/restoring selection.  Note that this
     1:  * assumes that the nodes involved are still around afterwards!
     1:  */
 15596: class NS_STACK_CLASS nsAutoSelectionReset
     1: {
     1:   private:
     1:     /** ref-counted reference to the selection that we are supposed to restore */
106286:     nsRefPtr<mozilla::Selection> mSel;
     1:     nsEditor *mEd;  // non-owning ref to nsEditor
     1: 
     1:   public:
     1:     /** constructor responsible for remembering all state needed to restore aSel */
106286:     nsAutoSelectionReset(mozilla::Selection* aSel, nsEditor* aEd);
     1:     
     1:     /** destructor restores mSel to its former state */
     1:     ~nsAutoSelectionReset();
     1: 
     1:     /** Abort: cancel selection saver */
     1:     void Abort();
     1: };
     1: 
     1: /***************************************************************************
     1:  * stack based helper class for StartOperation()/EndOperation() sandwich
     1:  */
 15596: class NS_STACK_CLASS nsAutoRules
     1: {
     1:   public:
     1:   
 97808:   nsAutoRules(nsEditor *ed, nsEditor::OperationID action,
 97808:               nsIEditor::EDirection aDirection) :
 80486:          mEd(ed), mDoNothing(false)
     1:   { 
     1:     if (mEd && !mEd->mAction) // mAction will already be set if this is nested call
     1:     {
     1:       mEd->StartOperation(action, aDirection);
     1:     }
 80486:     else mDoNothing = true; // nested calls will end up here
     1:   }
     1:   ~nsAutoRules() 
     1:   {
     1:     if (mEd && !mDoNothing) 
     1:     {
     1:       mEd->EndOperation();
     1:     }
     1:   }
     1:   
     1:   protected:
     1:   nsEditor *mEd;
 79445:   bool mDoNothing;
     1: };
     1: 
     1: 
     1: /***************************************************************************
     1:  * stack based helper class for turning off active selection adjustment
     1:  * by low level transactions
     1:  */
 15596: class NS_STACK_CLASS nsAutoTxnsConserveSelection
     1: {
     1:   public:
     1:   
 80486:   nsAutoTxnsConserveSelection(nsEditor *ed) : mEd(ed), mOldState(true)
     1:   {
     1:     if (mEd) 
     1:     {
     1:       mOldState = mEd->GetShouldTxnSetSelection();
 80486:       mEd->SetShouldTxnSetSelection(false);
     1:     }
     1:   }
     1:   
     1:   ~nsAutoTxnsConserveSelection() 
     1:   {
     1:     if (mEd) 
     1:     {
     1:       mEd->SetShouldTxnSetSelection(mOldState);
     1:     }
     1:   }
     1:   
     1:   protected:
     1:   nsEditor *mEd;
 79445:   bool mOldState;
     1: };
     1: 
     1: /***************************************************************************
     1:  * stack based helper class for batching reflow and paint requests.
     1:  */
 15596: class NS_STACK_CLASS nsAutoUpdateViewBatch
     1: {
     1:   public:
     1:   
     1:   nsAutoUpdateViewBatch(nsEditor *ed) : mEd(ed)
     1:   {
     1:     NS_ASSERTION(mEd, "null mEd pointer!");
     1: 
     1:     if (mEd) 
     1:       mEd->BeginUpdateViewBatch();
     1:   }
     1:   
     1:   ~nsAutoUpdateViewBatch() 
     1:   {
     1:     if (mEd) 
     1:       mEd->EndUpdateViewBatch();
     1:   }
     1:   
     1:   protected:
     1:   nsEditor *mEd;
     1: };
     1: 
     1: /******************************************************************************
     1:  * some helper classes for iterating the dom tree
     1:  *****************************************************************************/
     1: 
     1: class nsBoolDomIterFunctor 
     1: {
     1:   public:
 79445:     virtual bool operator()(nsIDOMNode* aNode)=0;
     1: };
     1: 
 15596: class NS_STACK_CLASS nsDOMIterator
     1: {
     1:   public:
     1:     nsDOMIterator();
     1:     virtual ~nsDOMIterator();
     1:     
     1:     nsresult Init(nsIDOMRange* aRange);
     1:     nsresult Init(nsIDOMNode* aNode);
     1:     nsresult AppendList(nsBoolDomIterFunctor& functor,
     1:                         nsCOMArray<nsIDOMNode>& arrayOfNodes) const;
     1:   protected:
     1:     nsCOMPtr<nsIContentIterator> mIter;
     1: };
     1: 
     1: class nsDOMSubtreeIterator : public nsDOMIterator
     1: {
     1:   public:
     1:     nsDOMSubtreeIterator();
     1:     virtual ~nsDOMSubtreeIterator();
     1: 
     1:     nsresult Init(nsIDOMRange* aRange);
     1: };
     1: 
     1: class nsTrivialFunctor : public nsBoolDomIterFunctor
     1: {
     1:   public:
 79445:     virtual bool operator()(nsIDOMNode* aNode)  // used to build list of all nodes iterator covers
     1:     {
 80486:       return true;
     1:     }
     1: };
     1: 
     1: 
     1: /******************************************************************************
     1:  * general dom point utility struct
     1:  *****************************************************************************/
 15596: struct NS_STACK_CLASS DOMPoint
     1: {
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   PRInt32 offset;
     1:   
     1:   DOMPoint() : node(0),offset(0) {}
     1:   DOMPoint(nsIDOMNode *aNode, PRInt32 aOffset) : 
     1:                  node(aNode),offset(aOffset) {}
     1:   void SetPoint(nsIDOMNode *aNode, PRInt32 aOffset)
     1:   {
     1:     node = aNode; offset = aOffset;
     1:   }
     1:   void GetPoint(nsCOMPtr<nsIDOMNode> &aNode, PRInt32 &aOffset)
     1:   {
     1:     aNode = node; aOffset = offset;
     1:   }
     1: };
     1: 
     1: 
     1: class nsEditorUtils
     1: {
     1:   public:
 79445:     static bool IsDescendantOf(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 *aOffset = 0);
 79445:     static bool IsLeafNode(nsIDOMNode *aNode);
     1: };
     1: 
     1: 
     1: class nsIDOMEvent;
     1: class nsISimpleEnumerator;
104487: class nsITransferable;
     1: 
     1: class nsEditorHookUtils
     1: {
     1:   public:
 79445:     static bool     DoInsertionHook(nsIDOMDocument *aDoc, nsIDOMEvent *aEvent,
     1:                                     nsITransferable *aTrans);
     1:   private:
     1:     static nsresult GetHookEnumeratorFromDocument(nsIDOMDocument *aDoc,
     1:                                                   nsISimpleEnumerator **aEnumerator);
     1: };
     1: 
     1: #endif // nsEditorUtils_h__
