    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //
    1: // Eric Vaughan
    1: // Netscape Communications
    1: //
    1: // See documentation in associated header file
    1: //
    1: 
    1: #include "nsImageBoxFrame.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsStyleContext.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsPresContext.h"
    1: #include "nsBoxLayoutState.h"
    1: 
    1: #include "nsHTMLParts.h"
    1: #include "nsString.h"
    1: #include "nsLeafFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIDocument.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsImageMap.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIURL.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "prprf.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsTextFragment.h"
    1: #include "nsIDOMHTMLMapElement.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsTransform2D.h"
    1: #include "nsITheme.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIURI.h"
    1: #include "nsNetUtil.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsDisplayList.h"
    1: 
    1: #include "nsContentUtils.h"
    1: 
    1: #define ONLOAD_CALLED_TOO_EARLY 1
    1: 
    1: class nsImageBoxFrameEvent : public nsRunnable
    1: {
    1: public:
    1:   nsImageBoxFrameEvent(nsIContent *content, PRUint32 message)
    1:     : mContent(content), mMessage(message) {}
    1: 
    1:   NS_IMETHOD Run();
    1: 
    1: private:
    1:   nsCOMPtr<nsIContent> mContent;
    1:   PRUint32 mMessage;
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsImageBoxFrameEvent::Run()
    1: {
    1:   nsIDocument* doc = mContent->GetOwnerDoc();
    1:   if (!doc) {
    1:     return NS_OK;
    1:   }
    1: 
  981:   nsIPresShell *pres_shell = doc->GetPrimaryShell();
    1:   if (!pres_shell) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsPresContext> pres_context = pres_shell->GetPresContext();
    1:   if (!pres_context) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsEvent event(PR_TRUE, mMessage);
    1: 
    1:   event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
    1:   nsEventDispatcher::Dispatch(mContent, pres_context, &event, nsnull, &status);
    1:   return NS_OK;
    1: }
    1: 
    1: // Fire off an event that'll asynchronously call the image elements
    1: // onload handler once handled. This is needed since the image library
    1: // can't decide if it wants to call it's observer methods
    1: // synchronously or asynchronously. If an image is loaded from the
    1: // cache the notifications come back synchronously, but if the image
    1: // is loaded from the netswork the notifications come back
    1: // asynchronously.
    1: 
    1: void
    1: FireImageDOMEvent(nsIContent* aContent, PRUint32 aMessage)
    1: {
    1:   NS_ASSERTION(aMessage == NS_LOAD || aMessage == NS_LOAD_ERROR,
    1:                "invalid message");
    1: 
    1:   nsCOMPtr<nsIRunnable> event = new nsImageBoxFrameEvent(aContent, aMessage);
    1:   if (NS_FAILED(NS_DispatchToCurrentThread(event)))
    1:     NS_WARNING("failed to dispatch image event");
    1: }
    1: 
    1: //
    1: // NS_NewImageBoxFrame
    1: //
    1: // Creates a new image frame and returns it
    1: //
    1: nsIFrame*
    1: NS_NewImageBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsImageBoxFrame (aPresShell, aContext);
    1: } // NS_NewTitledButtonFrame
    1: 
    1: NS_IMETHODIMP
    1: nsImageBoxFrame::AttributeChanged(PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aAttribute,
    1:                                   PRInt32 aModType)
    1: {
    1:   nsresult rv = nsLeafBoxFrame::AttributeChanged(aNameSpaceID, aAttribute,
    1:                                                  aModType);
    1: 
    1:   if (aAttribute == nsGkAtoms::src) {
    1:     UpdateImage();
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
    1:   }
    1:   else if (aAttribute == nsGkAtoms::validate)
    1:     UpdateLoadFlags();
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsImageBoxFrame::nsImageBoxFrame(nsIPresShell* aShell, nsStyleContext* aContext):
    1:   nsLeafBoxFrame(aShell, aContext),
28285:   mIntrinsicSize(0,0),
28285:   mLoadFlags(nsIRequest::LOAD_NORMAL),
    1:   mUseSrcAttr(PR_FALSE),
28285:   mSuppressStyleCheck(PR_FALSE)
    1: {
    1:   MarkIntrinsicWidthsDirty();
    1: }
    1: 
    1: nsImageBoxFrame::~nsImageBoxFrame()
    1: {
    1: }
    1: 
    1: 
    1: /* virtual */ void
    1: nsImageBoxFrame::MarkIntrinsicWidthsDirty()
    1: {
    1:   SizeNeedsRecalc(mImageSize);
    1:   nsLeafBoxFrame::MarkIntrinsicWidthsDirty();
    1: }
    1: 
    1: void
    1: nsImageBoxFrame::Destroy()
    1: {
    1:   // Release image loader first so that it's refcnt can go to zero
    1:   if (mImageRequest)
22953:     mImageRequest->CancelAndForgetObserver(NS_ERROR_FAILURE);
    1: 
    1:   if (mListener)
 3233:     reinterpret_cast<nsImageBoxListener*>(mListener.get())->SetFrame(nsnull); // set the frame to null so we don't send messages to a dead object.
    1: 
    1:   nsLeafBoxFrame::Destroy();
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsImageBoxFrame::Init(nsIContent*      aContent,
    1:                       nsIFrame*        aParent,
    1:                       nsIFrame*        aPrevInFlow)
    1: {
    1:   if (!mListener) {
    1:     nsImageBoxListener *listener;
    1:     NS_NEWXPCOM(listener, nsImageBoxListener);
    1:     NS_ADDREF(listener);
    1:     listener->SetFrame(this);
    1:     listener->QueryInterface(NS_GET_IID(imgIDecoderObserver), getter_AddRefs(mListener));
    1:     NS_RELEASE(listener);
    1:   }
    1: 
    1:   mSuppressStyleCheck = PR_TRUE;
    1:   nsresult rv = nsLeafBoxFrame::Init(aContent, aParent, aPrevInFlow);
    1:   mSuppressStyleCheck = PR_FALSE;
    1: 
    1:   UpdateLoadFlags();
    1:   UpdateImage();
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsImageBoxFrame::UpdateImage()
    1: {
    1:   if (mImageRequest) {
32162:     mImageRequest->CancelAndForgetObserver(NS_ERROR_FAILURE);
    1:     mImageRequest = nsnull;
    1:   }
    1: 
    1:   // get the new image src
    1:   nsAutoString src;
    1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::src, src);
    1:   mUseSrcAttr = !src.IsEmpty();
    1:   if (mUseSrcAttr) {
    1:     nsIDocument* doc = mContent->GetDocument();
    1:     if (!doc) {
    1:       // No need to do anything here...
    1:       return;
    1:     }
    1:     nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1:     nsCOMPtr<nsIURI> uri;
    1:     nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(uri),
    1:                                               src,
    1:                                               doc,
    1:                                               baseURI);
    1: 
 3088:     if (uri && nsContentUtils::CanLoadImage(uri, mContent, doc,
 3088:                                             mContent->NodePrincipal())) {
 3088:       nsContentUtils::LoadImage(uri, doc, mContent->NodePrincipal(),
 3088:                                 doc->GetDocumentURI(), mListener, mLoadFlags,
    1:                                 getter_AddRefs(mImageRequest));
    1:     }
    1:   } else {
    1:     // Only get the list-style-image if we aren't being drawn
    1:     // by a native theme.
    1:     PRUint8 appearance = GetStyleDisplay()->mAppearance;
    1:     if (!(appearance && nsBox::gTheme && 
    1:           nsBox::gTheme->ThemeSupportsWidget(nsnull, this, appearance))) {
    1:       // get the list-style-image
    1:       imgIRequest *styleRequest = GetStyleList()->mListStyleImage;
    1:       if (styleRequest) {
    1:         styleRequest->Clone(mListener, getter_AddRefs(mImageRequest));
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (!mImageRequest) {
    1:     // We have no image, so size to 0
    1:     mIntrinsicSize.SizeTo(0, 0);
    1:   }
    1: }
    1: 
    1: void
    1: nsImageBoxFrame::UpdateLoadFlags()
    1: {
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::always, &nsGkAtoms::never, nsnull};
    1:   switch (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::validate,
    1:                                     strings, eCaseMatters)) {
    1:     case 0:
    1:       mLoadFlags = nsIRequest::VALIDATE_ALWAYS;
    1:       break;
    1:     case 1:
    1:       mLoadFlags = nsIRequest::VALIDATE_NEVER|nsIRequest::LOAD_FROM_CACHE;
    1:       break;
    1:     default:
    1:       mLoadFlags = nsIRequest::LOAD_NORMAL;
    1:       break;
    1:   }
    1: }
    1: 
    1: class nsDisplayXULImage : public nsDisplayItem {
    1: public:
    1:   nsDisplayXULImage(nsImageBoxFrame* aFrame) : nsDisplayItem(aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayXULImage);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayXULImage() {
    1:     MOZ_COUNT_DTOR(nsDisplayXULImage);
    1:   }
    1: #endif
    1: 
    1:   // Doesn't handle HitTest because nsLeafBoxFrame already creates an
    1:   // event receiver for us
    1:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect);
    1:   NS_DISPLAY_DECL_NAME("XULImage")
    1: };
    1: 
    1: void nsDisplayXULImage::Paint(nsDisplayListBuilder* aBuilder,
    1:      nsIRenderingContext* aCtx, const nsRect& aDirtyRect)
    1: {
 3233:   static_cast<nsImageBoxFrame*>(mFrame)->
    1:     PaintImage(*aCtx, aDirtyRect, aBuilder->ToReferenceFrame(mFrame));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageBoxFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                   const nsRect&           aDirtyRect,
    1:                                   const nsDisplayListSet& aLists)
    1: {       
    1:   nsresult rv = nsLeafBoxFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if ((0 == mRect.width) || (0 == mRect.height)) {
    1:     // Do not render when given a zero area. This avoids some useless
    1:     // scaling work while we wait for our image dimensions to arrive
    1:     // asynchronously.
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   return aLists.Content()->AppendNewToTop(new (aBuilder) nsDisplayXULImage(this));
    1: }
    1: 
    1: void
    1: nsImageBoxFrame::PaintImage(nsIRenderingContext& aRenderingContext,
    1:                             const nsRect& aDirtyRect, nsPoint aPt)
    1: {
    1:   nsRect rect;
    1:   GetClientRect(rect);
    1: 
    1:   rect += aPt;
    1: 
    1:   if (!mImageRequest)
    1:     return;
    1: 
    1:   // don't draw if the image is not dirty
    1:   nsRect dirty;
    1:   if (!dirty.IntersectRect(aDirtyRect, rect))
    1:     return;
    1: 
    1:   nsCOMPtr<imgIContainer> imgCon;
    1:   mImageRequest->GetImage(getter_AddRefs(imgCon));
    1: 
    1:   if (imgCon) {
    1:     PRBool hasSubRect = !mUseSrcAttr && (mSubRect.width > 0 || mSubRect.height > 0);
21323:     nsLayoutUtils::DrawSingleImage(&aRenderingContext, imgCon,
26926:         nsLayoutUtils::GetGraphicsFilterForFrame(this),
    1:         rect, dirty, hasSubRect ? &mSubRect : nsnull);
    1:   }
    1: }
    1: 
    1: 
    1: //
    1: // DidSetStyleContext
    1: //
    1: // When the style context changes, make sure that all of our image is up to date.
    1: //
20441: /* virtual */ void
20836: nsImageBoxFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
    1: {
20836:   nsLeafBoxFrame::DidSetStyleContext(aOldStyleContext);
20441: 
    1:   // Fetch our subrect.
    1:   const nsStyleList* myList = GetStyleList();
    1:   mSubRect = myList->mImageRegion; // before |mSuppressStyleCheck| test!
    1: 
    1:   if (mUseSrcAttr || mSuppressStyleCheck)
20441:     return; // No more work required, since the image isn't specified by style.
    1: 
    1:   // If we're using a native theme implementation, we shouldn't draw anything.
    1:   const nsStyleDisplay* disp = GetStyleDisplay();
    1:   if (disp->mAppearance && nsBox::gTheme && 
    1:       nsBox::gTheme->ThemeSupportsWidget(nsnull, this, disp->mAppearance))
20441:     return;
    1: 
    1:   // If list-style-image changes, we have a new image.
    1:   nsCOMPtr<nsIURI> oldURI, newURI;
    1:   if (mImageRequest)
    1:     mImageRequest->GetURI(getter_AddRefs(oldURI));
    1:   if (myList->mListStyleImage)
    1:     myList->mListStyleImage->GetURI(getter_AddRefs(newURI));
    1:   PRBool equal;
    1:   if (newURI == oldURI ||   // handles null==null
    1:       (newURI && oldURI &&
    1:        NS_SUCCEEDED(newURI->Equals(oldURI, &equal)) && equal))
20441:     return;
    1: 
    1:   UpdateImage();
    1: } // DidSetStyleContext
    1: 
    1: void
    1: nsImageBoxFrame::GetImageSize()
    1: {
    1:   if (mIntrinsicSize.width > 0 && mIntrinsicSize.height > 0) {
    1:     mImageSize.width = mIntrinsicSize.width;
    1:     mImageSize.height = mIntrinsicSize.height;
    1:   } else {
    1:     mImageSize.width = 0;
    1:     mImageSize.height = 0;
    1:   }
    1: }
    1: 
    1: 
    1: /**
    1:  * Ok return our dimensions
    1:  */
    1: nsSize
    1: nsImageBoxFrame::GetPrefSize(nsBoxLayoutState& aState)
    1: {
    1:   nsSize size(0,0);
    1:   DISPLAY_PREF_SIZE(this, size);
    1:   if (DoesNeedRecalc(mImageSize))
    1:      GetImageSize();
    1: 
    1:   if (!mUseSrcAttr && (mSubRect.width > 0 || mSubRect.height > 0))
    1:     size = nsSize(mSubRect.width, mSubRect.height);
    1:   else
    1:     size = mImageSize;
    1:   AddBorderAndPadding(size);
    1:   nsIBox::AddCSSPrefSize(aState, this, size);
    1: 
    1:   nsSize minSize = GetMinSize(aState);
    1:   nsSize maxSize = GetMaxSize(aState);  
    1: 
 9862:   return BoundsCheck(minSize, size, maxSize);
    1: }
    1: 
    1: nsSize
    1: nsImageBoxFrame::GetMinSize(nsBoxLayoutState& aState)
    1: {
    1:   // An image can always scale down to (0,0).
    1:   nsSize size(0,0);
    1:   DISPLAY_MIN_SIZE(this, size);
    1:   AddBorderAndPadding(size);
    1:   nsIBox::AddCSSMinSize(aState, this, size);
    1:   return size;
    1: }
    1: 
    1: nscoord
    1: nsImageBoxFrame::GetBoxAscent(nsBoxLayoutState& aState)
    1: {
    1:   return GetPrefSize(aState).height;
    1: }
    1: 
    1: nsIAtom*
    1: nsImageBoxFrame::GetType() const
    1: {
    1:   return nsGkAtoms::imageBoxFrame;
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsImageBoxFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("ImageBox"), aResult);
    1: }
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP nsImageBoxFrame::OnStartContainer(imgIRequest *request,
    1:                                                 imgIContainer *image)
    1: {
    1:   NS_ENSURE_ARG_POINTER(image);
    1: 
    1:   // Ensure the animation (if any) is started
    1:   image->StartAnimation();
    1: 
    1:   nscoord w, h;
    1:   image->GetWidth(&w);
    1:   image->GetHeight(&h);
    1: 
    1:   mIntrinsicSize.SizeTo(nsPresContext::CSSPixelsToAppUnits(w),
    1:                         nsPresContext::CSSPixelsToAppUnits(h));
    1: 
  925:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
  925:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsImageBoxFrame::OnStopContainer(imgIRequest *request,
    1:                                                imgIContainer *image)
    1: {
  238:   nsBoxLayoutState state(PresContext());
    1:   this->Redraw(state);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsImageBoxFrame::OnStopDecode(imgIRequest *request,
    1:                                             nsresult aStatus,
    1:                                             const PRUnichar *statusArg)
    1: {
    1:   if (NS_SUCCEEDED(aStatus))
    1:     // Fire an onload DOM event.
    1:     FireImageDOMEvent(mContent, NS_LOAD);
    1:   else {
    1:     // Fire an onerror DOM event.
    1:     mIntrinsicSize.SizeTo(0, 0);
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
    1:     FireImageDOMEvent(mContent, NS_LOAD_ERROR);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsImageBoxFrame::FrameChanged(imgIContainer *container,
23738:                                             nsIntRect *dirtyRect)
    1: {
  238:   nsBoxLayoutState state(PresContext());
    1:   this->Redraw(state);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS2(nsImageBoxListener, imgIDecoderObserver, imgIContainerObserver)
    1: 
    1: nsImageBoxListener::nsImageBoxListener()
    1: {
    1: }
    1: 
    1: nsImageBoxListener::~nsImageBoxListener()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsImageBoxListener::OnStartContainer(imgIRequest *request,
    1:                                                    imgIContainer *image)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->OnStartContainer(request, image);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageBoxListener::OnStopContainer(imgIRequest *request,
    1:                                                   imgIContainer *image)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->OnStopContainer(request, image);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageBoxListener::OnStopDecode(imgIRequest *request,
    1:                                                nsresult status,
    1:                                                const PRUnichar *statusArg)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->OnStopDecode(request, status, statusArg);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageBoxListener::FrameChanged(imgIContainer *container,
23738:                                                nsIntRect *dirtyRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
30479:   return mFrame->FrameChanged(container, dirtyRect);
    1: }
    1: 
