     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: 
     1: #include "nsIAppShellService.h"
     1: #include "nsISupportsArray.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsIURL.h"
     1: #include "nsNetUtil.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIObserverService.h"
     1: #include "nsIObserver.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsIJSContextStack.h"
     1: 
     1: #include "nsIWindowMediator.h"
     1: #include "nsIWindowWatcher.h"
     1: #include "nsPIWindowWatcher.h"
 73870: #include "nsIDOMWindow.h"
111187: #include "nsPIDOMWindow.h"
     1: #include "nsWebShellWindow.h"
     1: 
     1: #include "nsIEnumerator.h"
     1: #include "nsCRT.h"
     1: #include "prprf.h"    
     1: 
     1: #include "nsWidgetsCID.h"
     1: #include "nsIRequestObserver.h"
     1: 
     1: /* For implementing GetHiddenWindowAndJSContext */
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIScriptContext.h"
     1: #include "jsapi.h"
     1: 
     1: #include "nsAppShellService.h"
     1: #include "nsISupportsPrimitives.h"
     1: #include "nsIPlatformCharset.h"
     1: #include "nsICharsetConverterManager.h"
     1: #include "nsIUnicodeDecoder.h"
 36503: #include "nsIChromeRegistry.h"
     1: 
 72016: #include "mozilla/Preferences.h"
 82448: #include "mozilla/StartupTimeline.h"
 72016: 
 72016: using namespace mozilla;
 72016: 
   679: // Default URL for the hidden window, can be overridden by a pref on Mac
 33777: #define DEFAULT_HIDDENWINDOW_URL "resource://gre-resources/hiddenWindow.html"
   679: 
     1: class nsIAppShell;
     1: 
     1: nsAppShellService::nsAppShellService() : 
 80486:   mXPCOMWillShutDown(false),
 80486:   mXPCOMShuttingDown(false),
  5221:   mModalWindowCount(0),
 80486:   mApplicationProvidedHiddenWindow(false)
     1: {
     1:   nsCOMPtr<nsIObserverService> obs
     1:     (do_GetService("@mozilla.org/observer-service;1"));
     1: 
 35179:   if (obs) {
 80486:     obs->AddObserver(this, "xpcom-will-shutdown", false);
 80486:     obs->AddObserver(this, "xpcom-shutdown", false);
     1:   }
 35179: }
     1: 
     1: nsAppShellService::~nsAppShellService()
     1: {
     1: }
     1: 
     1: 
     1: /*
     1:  * Implement the nsISupports methods...
     1:  */
     1: NS_IMPL_ISUPPORTS2(nsAppShellService,
     1:                    nsIAppShellService,
     1:                    nsIObserver)
     1: 
     1: NS_IMETHODIMP
 80433: nsAppShellService::CreateHiddenWindow()
     1: {
     1:   nsresult rv;
108991:   int32_t initialHeight = 100, initialWidth = 100;
     1: 
     1: #ifdef XP_MACOSX
108991:   uint32_t    chromeMask = 0;
 72016:   nsAdoptingCString prefVal =
 72016:       Preferences::GetCString("browser.hiddenWindowChromeURL");
 95695:   const char* hiddenWindowURL = prefVal.get() ? prefVal.get() : DEFAULT_HIDDENWINDOW_URL;
 95695:   mApplicationProvidedHiddenWindow = prefVal.get() ? true : false;
     1: #else
   679:   static const char hiddenWindowURL[] = DEFAULT_HIDDENWINDOW_URL;
108991:   uint32_t    chromeMask =  nsIWebBrowserChrome::CHROME_ALL;
     1: #endif
     1: 
     1:   nsCOMPtr<nsIURI> url;
     1:   rv = NS_NewURI(getter_AddRefs(url), hiddenWindowURL);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsRefPtr<nsWebShellWindow> newWindow;
106838:   rv = JustCreateTopWindow(nullptr, url,
     1:                            chromeMask, initialWidth, initialHeight,
 80486:                            true, getter_AddRefs(newWindow));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   mHiddenWindow.swap(newWindow);
     1: 
     1:   // RegisterTopLevelWindow(newWindow); -- Mac only
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAppShellService::DestroyHiddenWindow()
     1: {
     1:   if (mHiddenWindow) {
     1:     mHiddenWindow->Destroy();
     1: 
106838:     mHiddenWindow = nullptr;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /*
     1:  * Create a new top level window and display the given URL within it...
     1:  */
     1: NS_IMETHODIMP
     1: nsAppShellService::CreateTopLevelWindow(nsIXULWindow *aParent,
     1:                                         nsIURI *aUrl, 
108991:                                         uint32_t aChromeMask,
108991:                                         int32_t aInitialWidth,
108991:                                         int32_t aInitialHeight,
     1:                                         nsIXULWindow **aResult)
     1: 
     1: {
     1:   nsresult rv;
     1: 
 82448:   StartupTimeline::RecordOnce(StartupTimeline::CREATE_TOP_LEVEL_WINDOW);
 78726: 
106838:   nsWebShellWindow *newWindow = nullptr;
     1:   rv = JustCreateTopWindow(aParent, aUrl,
     1:                            aChromeMask, aInitialWidth, aInitialHeight,
 80486:                            false, &newWindow);  // addrefs
     1: 
     1:   *aResult = newWindow; // transfer ref
     1: 
     1:   if (NS_SUCCEEDED(rv)) {
     1:     // the addref resulting from this is the owning addref for this window
     1:     RegisterTopLevelWindow(*aResult);
 33261:     nsCOMPtr<nsIXULWindow> parent;
 33261:     if (aChromeMask & nsIWebBrowserChrome::CHROME_DEPENDENT)
 33261:       parent = aParent;
 33261:     (*aResult)->SetZLevel(CalculateWindowZLevel(parent, aChromeMask));
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
108991: uint32_t
     1: nsAppShellService::CalculateWindowZLevel(nsIXULWindow *aParent,
108991:                                          uint32_t      aChromeMask)
     1: {
108991:   uint32_t zLevel;
     1: 
     1:   zLevel = nsIXULWindow::normalZ;
     1:   if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_RAISED)
     1:     zLevel = nsIXULWindow::raisedZ;
     1:   else if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_LOWERED)
     1:     zLevel = nsIXULWindow::loweredZ;
     1: 
     1: #ifdef XP_MACOSX
     1:   /* Platforms on which modal windows are always application-modal, not
     1:      window-modal (that's just the Mac, right?) want modal windows to
     1:      be stacked on top of everyone else.
     1: 
     1:      On Mac OS X, bind modality to parent window instead of app (ala Mac OS 9)
     1:   */
108991:   uint32_t modalDepMask = nsIWebBrowserChrome::CHROME_MODAL |
     1:                           nsIWebBrowserChrome::CHROME_DEPENDENT;
     1:   if (aParent && (aChromeMask & modalDepMask)) {
     1:     aParent->GetZLevel(&zLevel);
     1:   }
     1: #else
     1:   /* Platforms with native support for dependent windows (that's everyone
     1:       but pre-Mac OS X, right?) know how to stack dependent windows. On these
     1:       platforms, give the dependent window the same level as its parent,
     1:       so we won't try to override the normal platform behaviour. */
     1:   if ((aChromeMask & nsIWebBrowserChrome::CHROME_DEPENDENT) && aParent)
     1:     aParent->GetZLevel(&zLevel);
     1: #endif
     1: 
     1:   return zLevel;
     1: }
     1: 
 58605: #ifdef XP_WIN
     1: /*
 51548:  * Checks to see if any existing window is currently in fullscreen mode.
 51548:  */
 79445: static bool
 51548: CheckForFullscreenWindow()
 51548: {
 51548:   nsCOMPtr<nsIWindowMediator> wm(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
 51548:   if (!wm)
 80486:     return false;
 51548: 
 51548:   nsCOMPtr<nsISimpleEnumerator> windowList;
106838:   wm->GetXULWindowEnumerator(nullptr, getter_AddRefs(windowList));
 51548:   if (!windowList)
 80486:     return false;
 51548: 
 51548:   for (;;) {
 79445:     bool more = false;
 51548:     windowList->HasMoreElements(&more);
 51548:     if (!more)
 80486:       return false;
 51548: 
 51548:     nsCOMPtr<nsISupports> supportsWindow;
 51548:     windowList->GetNext(getter_AddRefs(supportsWindow));
 51548:     nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(supportsWindow));
 51548:     if (baseWin) {
108991:       int32_t sizeMode;
 51548:       nsCOMPtr<nsIWidget> widget;
 51548:       baseWin->GetMainWidget(getter_AddRefs(widget));
 51548:       if (widget && NS_SUCCEEDED(widget->GetSizeMode(&sizeMode)) && 
 51548:           sizeMode == nsSizeMode_Fullscreen) {
 80486:         return true;
 51548:       }
 51548:     }
 51548:   }
 80486:   return false;
 51548: }
 58605: #endif
 51548: 
 51548: /*
     1:  * Just do the window-making part of CreateTopLevelWindow
     1:  */
     1: nsresult
     1: nsAppShellService::JustCreateTopWindow(nsIXULWindow *aParent,
     1:                                        nsIURI *aUrl, 
108991:                                        uint32_t aChromeMask,
108991:                                        int32_t aInitialWidth,
108991:                                        int32_t aInitialHeight,
 79445:                                        bool aIsHiddenWindow,
     1:                                        nsWebShellWindow **aResult)
     1: {
106838:   *aResult = nullptr;
 35179:   NS_ENSURE_STATE(!mXPCOMWillShutDown);
     1: 
 33261:   nsCOMPtr<nsIXULWindow> parent;
 33261:   if (aChromeMask & nsIWebBrowserChrome::CHROME_DEPENDENT)
 33261:     parent = aParent;
 33261: 
 31556:   nsRefPtr<nsWebShellWindow> window = new nsWebShellWindow(aChromeMask);
     1:   NS_ENSURE_TRUE(window, NS_ERROR_OUT_OF_MEMORY);
     1: 
 51548: #ifdef XP_WIN
 51548:   // If the parent is currently fullscreen, tell the child to ignore persisted
 51548:   // full screen states. This way new browser windows open on top of fullscreen
 51548:   // windows normally.
 51548:   if (window && CheckForFullscreenWindow())
 80486:     window->IgnoreXULSizeMode(true);
 51548: #endif
 51548: 
     1:   nsWidgetInitData widgetInitData;
     1: 
     1:   if (aIsHiddenWindow)
     1:     widgetInitData.mWindowType = eWindowType_invisible;
     1:   else
     1:     widgetInitData.mWindowType = aChromeMask & nsIWebBrowserChrome::CHROME_OPENAS_DIALOG ?
     1:       eWindowType_dialog : eWindowType_toplevel;
     1: 
     1:   if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_POPUP)
     1:     widgetInitData.mWindowType = eWindowType_popup;
     1: 
 90340:   if (aChromeMask & nsIWebBrowserChrome::CHROME_MAC_SUPPRESS_ANIMATION)
 90340:     widgetInitData.mIsAnimationSuppressed = true;
 90340: 
     1: #ifdef XP_MACOSX
     1:   // Mac OS X sheet support
 13491:   // Adding CHROME_OPENAS_CHROME to sheetMask makes modal windows opened from
 13491:   // nsGlobalWindow::ShowModalDialog() be dialogs (not sheets), while modal
 13491:   // windows opened from nsPromptService::DoDialog() still are sheets.  This
 13491:   // fixes bmo bug 395465 (see nsCocoaWindow::StandardCreate() and
 13491:   // nsCocoaWindow::SetModal()).
108991:   uint32_t sheetMask = nsIWebBrowserChrome::CHROME_OPENAS_DIALOG |
 13491:                        nsIWebBrowserChrome::CHROME_MODAL |
 13491:                        nsIWebBrowserChrome::CHROME_OPENAS_CHROME;
 33261:   if (parent && ((aChromeMask & sheetMask) == sheetMask))
     1:     widgetInitData.mWindowType = eWindowType_sheet;
     1: #endif
     1: 
 46259: #if defined(XP_WIN)
 46259:   if (widgetInitData.mWindowType == eWindowType_toplevel ||
 46259:       widgetInitData.mWindowType == eWindowType_dialog)
 80486:     widgetInitData.clipChildren = true;
 46259: #endif
 46259: 
     1:   // note default chrome overrides other OS chrome settings, but
     1:   // not internal chrome
     1:   if (aChromeMask & nsIWebBrowserChrome::CHROME_DEFAULT)
     1:     widgetInitData.mBorderStyle = eBorderStyle_default;
     1:   else if ((aChromeMask & nsIWebBrowserChrome::CHROME_ALL) == nsIWebBrowserChrome::CHROME_ALL)
     1:     widgetInitData.mBorderStyle = eBorderStyle_all;
     1:   else {
     1:     widgetInitData.mBorderStyle = eBorderStyle_none; // assumes none == 0x00
     1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_BORDERS)
  3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_border);
     1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_TITLEBAR)
  3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_title);
     1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_CLOSE)
  3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_close);
     1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_RESIZE) {
  3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_resizeh);
     1:       // only resizable windows get the maximize button (but not dialogs)
     1:       if (!(aChromeMask & nsIWebBrowserChrome::CHROME_OPENAS_DIALOG))
  3233:         widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_maximize);
     1:     }
     1:     // all windows (except dialogs) get minimize buttons and the system menu
     1:     if (!(aChromeMask & nsIWebBrowserChrome::CHROME_OPENAS_DIALOG))
  3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_minimize | eBorderStyle_menu);
     1:     // but anyone can explicitly ask for a minimize button
     1:     if (aChromeMask & nsIWebBrowserChrome::CHROME_WINDOW_MIN) {
  3233:       widgetInitData.mBorderStyle = static_cast<enum nsBorderStyle>(widgetInitData.mBorderStyle | eBorderStyle_minimize);
     1:     }  
     1:   }
     1: 
     1:   if (aInitialWidth == nsIAppShellService::SIZE_TO_CONTENT ||
     1:       aInitialHeight == nsIAppShellService::SIZE_TO_CONTENT) {
     1:     aInitialWidth = 1;
     1:     aInitialHeight = 1;
 80486:     window->SetIntrinsicallySized(true);
     1:   }
     1: 
 79445:   bool center = aChromeMask & nsIWebBrowserChrome::CHROME_CENTER_SCREEN;
 33261: 
 36503:   nsCOMPtr<nsIXULChromeRegistry> reg =
 42314:     mozilla::services::GetXULChromeRegistryService();
 36503:   if (reg) {
110974:     nsAutoCString package;
 36503:     package.AssignLiteral("global");
 79445:     bool isRTL = false;
 36503:     reg->IsLocaleRTL(package, &isRTL);
 36503:     widgetInitData.mRTL = isRTL;
 36503:   }
 36503: 
106838:   nsresult rv = window->Initialize(parent, center ? aParent : nullptr,
 80433:                                    aUrl, aInitialWidth, aInitialHeight,
     1:                                    aIsHiddenWindow, widgetInitData);
     1: 
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   window.swap(*aResult); // transfer reference
 33261:   if (parent)
 33261:     parent->AddChildWindow(*aResult);
     1: 
 33261:   if (center)
 80486:     rv = (*aResult)->Center(parent, parent ? false : true, false);
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsAppShellService::GetHiddenWindow(nsIXULWindow **aWindow)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aWindow);
     1: 
     1:   *aWindow = mHiddenWindow;
     1:   NS_IF_ADDREF(*aWindow);
     1:   return *aWindow ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP
 73870: nsAppShellService::GetHiddenDOMWindow(nsIDOMWindow **aWindow)
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIDocShell> docShell;
     1:   NS_ENSURE_TRUE(mHiddenWindow, NS_ERROR_FAILURE);
     1: 
     1:   rv = mHiddenWindow->GetDocShell(getter_AddRefs(docShell));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 73870:   nsCOMPtr<nsIDOMWindow> hiddenDOMWindow(do_GetInterface(docShell, &rv));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   *aWindow = hiddenDOMWindow;
     1:   NS_IF_ADDREF(*aWindow);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 73870: nsAppShellService::GetHiddenWindowAndJSContext(nsIDOMWindow **aWindow,
     1:                                                JSContext    **aJSContext)
     1: {
     1:     nsresult rv = NS_OK;
     1:     if ( aWindow && aJSContext ) {
106838:         *aWindow    = nullptr;
106838:         *aJSContext = nullptr;
     1: 
     1:         if ( mHiddenWindow ) {
 73870:             // Convert hidden window to nsIDOMWindow and extract its JSContext.
     1:             do {
     1:                 // 1. Get doc for hidden window.
     1:                 nsCOMPtr<nsIDocShell> docShell;
     1:                 rv = mHiddenWindow->GetDocShell(getter_AddRefs(docShell));
     1:                 if (NS_FAILED(rv)) break;
     1: 
 73870:                 // 2. Convert that to an nsIDOMWindow.
 73870:                 nsCOMPtr<nsIDOMWindow> hiddenDOMWindow(do_GetInterface(docShell));
     1:                 if(!hiddenDOMWindow) break;
     1: 
     1:                 // 3. Get script global object for the window.
     1:                 nsCOMPtr<nsIScriptGlobalObject> sgo;
     1:                 sgo = do_QueryInterface( hiddenDOMWindow );
     1:                 if (!sgo) { rv = NS_ERROR_FAILURE; break; }
     1: 
     1:                 // 4. Get script context from that.
     1:                 nsIScriptContext *scriptContext = sgo->GetContext();
     1:                 if (!scriptContext) { rv = NS_ERROR_FAILURE; break; }
     1: 
     1:                 // 5. Get JSContext from the script context.
 78415:                 JSContext *jsContext = scriptContext->GetNativeContext();
     1:                 if (!jsContext) { rv = NS_ERROR_FAILURE; break; }
     1: 
     1:                 // Now, give results to caller.
     1:                 *aWindow    = hiddenDOMWindow.get();
     1:                 NS_IF_ADDREF( *aWindow );
     1:                 *aJSContext = jsContext;
     1:             } while (0);
     1:         } else {
     1:             rv = NS_ERROR_FAILURE;
     1:         }
     1:     } else {
     1:         rv = NS_ERROR_NULL_POINTER;
     1:     }
     1:     return rv;
     1: }
     1: 
  5221: NS_IMETHODIMP
 79445: nsAppShellService::GetApplicationProvidedHiddenWindow(bool* aAPHW)
  5221: {
  5221:     *aAPHW = mApplicationProvidedHiddenWindow;
  5221:     return NS_OK;
  5221: }
  5221: 
     1: /*
     1:  * Register a new top level window (created elsewhere)
     1:  */
     1: NS_IMETHODIMP
     1: nsAppShellService::RegisterTopLevelWindow(nsIXULWindow* aWindow)
     1: {
118490:   NS_ENSURE_ARG_POINTER(aWindow);
118490: 
111187:   nsCOMPtr<nsIDocShell> docShell;
111187:   aWindow->GetDocShell(getter_AddRefs(docShell));
111187:   nsCOMPtr<nsPIDOMWindow> domWindow(do_GetInterface(docShell));
118490:   NS_ENSURE_TRUE(domWindow, NS_ERROR_FAILURE);
111187:   domWindow->SetInitialPrincipalToSubject();
111187: 
     1:   // tell the window mediator about the new window
     1:   nsCOMPtr<nsIWindowMediator> mediator
     1:     ( do_GetService(NS_WINDOWMEDIATOR_CONTRACTID) );
     1:   NS_ASSERTION(mediator, "Couldn't get window mediator.");
     1: 
     1:   if (mediator)
     1:     mediator->RegisterWindow(aWindow);
     1: 
     1:   // tell the window watcher about the new window
     1:   nsCOMPtr<nsPIWindowWatcher> wwatcher ( do_GetService(NS_WINDOWWATCHER_CONTRACTID) );
     1:   NS_ASSERTION(wwatcher, "No windowwatcher?");
111187:   if (wwatcher && domWindow) {
     1:     wwatcher->AddWindow(domWindow, 0);
     1:   }
     1: 
     1:   // an ongoing attempt to quit is stopped by a newly opened window
     1:   nsCOMPtr<nsIObserverService> obssvc =
     1:     do_GetService("@mozilla.org/observer-service;1");
     1:   NS_ASSERTION(obssvc, "Couldn't get observer service.");
     1: 
     1:   if (obssvc)
106838:     obssvc->NotifyObservers(aWindow, "xul-window-registered", nullptr);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsAppShellService::UnregisterTopLevelWindow(nsIXULWindow* aWindow)
     1: {
     1:   if (mXPCOMShuttingDown) {
     1:     /* return an error code in order to:
     1:        - avoid doing anything with other member variables while we are in
     1:          the destructor
     1:        - notify the caller not to release the AppShellService after
     1:          unregistering the window
     1:          (we don't want to be deleted twice consecutively to
     1:          mHiddenWindow->Destroy() in our destructor)
     1:     */
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   NS_ENSURE_ARG_POINTER(aWindow);
     1: 
     1:   if (aWindow == mHiddenWindow) {
     1:     // CreateHiddenWindow() does not register the window, so we're done.
     1:     return NS_OK;
     1:   }
     1: 
     1:   // tell the window mediator
     1:   nsCOMPtr<nsIWindowMediator> mediator
     1:     ( do_GetService(NS_WINDOWMEDIATOR_CONTRACTID) );
     1:   NS_ASSERTION(mediator, "Couldn't get window mediator. Doing xpcom shutdown?");
     1: 
     1:   if (mediator)
     1:     mediator->UnregisterWindow(aWindow);
     1: 
     1:   // tell the window watcher
     1:   nsCOMPtr<nsPIWindowWatcher> wwatcher ( do_GetService(NS_WINDOWWATCHER_CONTRACTID) );
     1:   NS_ASSERTION(wwatcher, "Couldn't get windowwatcher, doing xpcom shutdown?");
     1:   if (wwatcher) {
     1:     nsCOMPtr<nsIDocShell> docShell;
     1:     aWindow->GetDocShell(getter_AddRefs(docShell));
     1:     if (docShell) {
     1:       nsCOMPtr<nsIDOMWindow> domWindow(do_GetInterface(docShell));
     1:       if (domWindow)
     1:         wwatcher->RemoveWindow(domWindow);
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsAppShellService::Observe(nsISupports* aSubject, const char *aTopic,
     1:                            const PRUnichar *aData)
     1: {
 35179:   if (!strcmp(aTopic, "xpcom-will-shutdown")) {
 80486:     mXPCOMWillShutDown = true;
 35179:   } else if (!strcmp(aTopic, "xpcom-shutdown")) {
 80486:     mXPCOMShuttingDown = true;
     1:     if (mHiddenWindow) {
     1:       mHiddenWindow->Destroy();
     1:     }
 35179:   } else {
 35179:     NS_ERROR("Unexpected observer topic!");
 35179:   }
     1: 
     1:   return NS_OK;
     1: }
