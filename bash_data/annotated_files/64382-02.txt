52880: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52880:  * vim: set ts=4 sw=4 et tw=99:
52880:  *
52880:  * ***** BEGIN LICENSE BLOCK *****
52880:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52880:  *
52880:  * The contents of this file are subject to the Mozilla Public License Version
52880:  * 1.1 (the "License"); you may not use this file except in compliance with
52880:  * the License. You may obtain a copy of the License at
52880:  * http://www.mozilla.org/MPL/
52880:  *
52880:  * Software distributed under the License is distributed on an "AS IS" basis,
52880:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52880:  * for the specific language governing rights and limitations under the
52880:  * License.
52880:  *
52880:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52880:  * May 28, 2008.
52880:  *
52880:  * The Initial Developer of the Original Code is
52880:  *   Brendan Eich <brendan@mozilla.org>
52880:  *
52880:  * Contributor(s):
52880:  *   David Mandelin <dmandelin@mozilla.com>
52880:  *
52880:  * Alternatively, the contents of this file may be used under the terms of
52880:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52880:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52880:  * in which case the provisions of the GPL or the LGPL are applicable instead
52880:  * of those above. If you wish to allow use of your version of this file only
52880:  * under the terms of either the GPL or the LGPL, and not to allow others to
52880:  * use your version of this file under the terms of the MPL, indicate your
52880:  * decision by deleting the provisions above and replace them with the notice
52880:  * and other provisions required by the GPL or the LGPL. If you do not delete
52880:  * the provisions above, a recipient may use your version of this file under
52880:  * the terms of any one of the MPL, the GPL or the LGPL.
52880:  *
52880:  * ***** END LICENSE BLOCK ***** */
52880: #include "PolyIC.h"
52880: #include "StubCalls.h"
52880: #include "CodeGenIncludes.h"
52880: #include "StubCalls-inl.h"
55463: #include "BaseCompiler.h"
52880: #include "assembler/assembler/LinkBuffer.h"
60164: #include "TypedArrayIC.h"
52880: #include "jsscope.h"
52880: #include "jsnum.h"
60164: #include "jstypedarray.h"
56738: #include "jsatominlines.h"
53081: #include "jsobjinlines.h"
52880: #include "jsscopeinlines.h"
52896: #include "jspropertycache.h"
52896: #include "jspropertycacheinlines.h"
57723: #include "jsinterpinlines.h"
53089: #include "jsautooplen.h"
52880: 
53270: #if defined JS_POLYIC
53270: 
52880: using namespace js;
52880: using namespace js::mjit;
53270: using namespace js::mjit::ic;
52880: 
56738: typedef JSC::FunctionPtr FunctionPtr;
60164: typedef JSC::MacroAssembler::RegisterID RegisterID;
60164: typedef JSC::MacroAssembler::Jump Jump;
60164: typedef JSC::MacroAssembler::Imm32 Imm32;
56738: 
52880: /* Rough over-estimate of how much memory we need to unprotect. */
52880: static const uint32 INLINE_PATH_LENGTH = 64;
52880: 
60590: /* Static initializer to prime platforms that use constant offsets for ICs. */
60590: #ifndef JS_HAS_IC_LABELS
60590: ICOffsetInitializer::ICOffsetInitializer()
60590: {
60590:     {
60590:         GetPropLabels &labels = PICInfo::getPropLabels_;
60590: #if defined JS_CPU_X86
60590:         labels.dslotsLoadOffset = -15;
60590:         labels.inlineShapeOffset = 6;
60592:         labels.stubShapeJumpOffset = 12;
60592:         labels.inlineValueLoadOffset = -12;
60590: #endif
60590:     }
60590:     {
60590:         SetPropLabels &labels = PICInfo::setPropLabels_;
60595: #if defined JS_CPU_X86
60595:         labels.inlineShapeDataOffset = 6;
60595:         /* Store w/ address offset patch is two movs. */
60595:         labels.inlineShapeJumpOffset = 12;
60595:         labels.stubShapeJumpOffset = 12;
60595: #endif
60590:     }
60590:     {
60590:         BindNameLabels &labels = PICInfo::bindNameLabels_;
60590: #if defined JS_CPU_X86
60590:         labels.inlineJumpOffset = 10;
60593:         labels.stubJumpOffset = 5;
60590: #endif
60590:     }
60594:     {
60594:         ScopeNameLabels &labels = PICInfo::scopeNameLabels_;
60594: #if defined JS_CPU_X86
60594:         labels.inlineJumpOffset = 5;
60594:         labels.stubJumpOffset = 5;
60594: #endif
60594:     }
60590: }
60590: 
60590: ICOffsetInitializer s_ICOffsetInitializer;
60590: GetPropLabels PICInfo::getPropLabels_;
60590: SetPropLabels PICInfo::setPropLabels_;
60590: BindNameLabels PICInfo::bindNameLabels_;
60594: ScopeNameLabels PICInfo::scopeNameLabels_;
60590: #endif
60590: 
55463: // Helper class to simplify LinkBuffer usage in PIC stub generators.
55463: // This guarantees correct OOM and refcount handling for buffers while they
55463: // are instantiated and rooted.
55463: class PICLinker : public LinkerHelper
55463: {
57671:     ic::BasePolyIC &ic;
52880: 
55463:   public:
58064:     PICLinker(Assembler &masm, ic::BasePolyIC &ic)
58064:       : LinkerHelper(masm), ic(ic)
55463:     { }
55463: 
58064:     bool init(JSContext *cx) {
58064:         JSC::ExecutablePool *pool = LinkerHelper::init(cx);
55463:         if (!pool)
55463:             return false;
59897:         if (!ic.addPool(cx, pool)) {
55463:             pool->release();
55463:             js_ReportOutOfMemory(cx);
55463:             return false;
55463:         }
55463:         return true;
55463:     }
55463: };
55463: 
55463: class PICStubCompiler : public BaseCompiler
52880: {
52906:   protected:
52880:     const char *type;
52880:     VMFrame &f;
52880:     JSScript *script;
52880:     ic::PICInfo &pic;
56738:     void *stub;
52880: 
52880:   public:
56738:     PICStubCompiler(const char *type, VMFrame &f, JSScript *script, ic::PICInfo &pic, void *stub)
56738:       : BaseCompiler(f.cx), type(type), f(f), script(script), pic(pic), stub(stub)
52880:     { }
52880: 
56738:     bool isCallOp() const {
54836:         if (pic.kind == ic::PICInfo::CALL)
54836:             return true;
56738:         return !!(js_CodeSpec[pic.op].format & JOF_CALLOP);
54836:     }
54836: 
56738:     LookupStatus error() {
56738:         disable("error");
56738:         return Lookup_Error;
52880:     }
52880: 
56738:     LookupStatus error(JSContext *cx) {
56738:         return error();
52887:     }
52887: 
56738:     LookupStatus disable(const char *reason) {
56738:         return disable(f.cx, reason);
56738:     }
56738: 
56738:     LookupStatus disable(JSContext *cx, const char *reason) {
56738:         return pic.disable(cx, reason, stub);
52880:     }
52880: 
52880:   protected:
56738:     void spew(const char *event, const char *op) {
53487: #ifdef JS_METHODJIT_SPEW
52880:         JaegerSpew(JSpew_PICs, "%s %s: %s (%s: %d)\n",
52880:                    type, event, op, script->filename,
55463:                    js_FramePCToLineNumber(cx, f.fp()));
53487: #endif
52880:     }
52880: };
52880: 
52887: class SetPropCompiler : public PICStubCompiler
52887: {
52887:     JSObject *obj;
52887:     JSAtom *atom;
54749:     int lastStubSecondShapeGuard;
52887: 
52887:   public:
52887:     SetPropCompiler(VMFrame &f, JSScript *script, JSObject *obj, ic::PICInfo &pic, JSAtom *atom,
55503:                     VoidStubPIC stub)
56738:       : PICStubCompiler("setprop", f, script, pic, JS_FUNC_TO_DATA_PTR(void *, stub)),
56738:         obj(obj), atom(atom), lastStubSecondShapeGuard(pic.secondShapeGuard)
52887:     { }
52887: 
58063:     static void reset(Repatcher &repatcher, ic::PICInfo &pic)
52887:     {
60595:         SetPropLabels &labels = pic.setPropLabels();
60595:         repatcher.repatchLEAToLoadPtr(labels.getDslotsLoad(pic.fastPathRejoin, pic.u.vr));
60595:         repatcher.repatch(labels.getInlineShapeData(pic.fastPathStart, pic.shapeGuard),
53531:                           int32(JSObjectMap::INVALID_SHAPE));
60601:         repatcher.relink(labels.getInlineShapeJump(pic.fastPathStart.labelAtOffset(pic.shapeGuard)),
52887:                          pic.slowPathStart);
52887: 
56575:         FunctionPtr target(JS_FUNC_TO_DATA_PTR(void *, ic::SetProp));
56575:         repatcher.relink(pic.slowPathCall, target);
52887:     }
52887: 
56738:     LookupStatus patchInline(const Shape *shape, bool inlineSlot)
52887:     {
52889:         JS_ASSERT(!pic.inlinePathPatched);
52887:         JaegerSpew(JSpew_PICs, "patch setprop inline at %p\n", pic.fastPathStart.executableAddress());
52887: 
58063:         Repatcher repatcher(f.jit());
60595:         SetPropLabels &labels = pic.setPropLabels();
52887: 
52887:         int32 offset;
55746:         if (inlineSlot) {
60595:             CodeLocationInstruction istr = labels.getDslotsLoad(pic.fastPathRejoin, pic.u.vr);
52887:             repatcher.repatchLoadPtrToLEA(istr);
52887: 
52887:             // 
52887:             // We've patched | mov dslots, [obj + DSLOTS_OFFSET]
52887:             // To:           | lea fslots, [obj + DSLOTS_OFFSET]
52887:             //
52887:             // Because the offset is wrong, it's necessary to correct it
52887:             // below.
52887:             //
55746:             int32 diff = int32(JSObject::getFixedSlotOffset(0)) -
55746:                          int32(offsetof(JSObject, slots));
52887:             JS_ASSERT(diff != 0);
53531:             offset  = (int32(shape->slot) * sizeof(Value)) + diff;
52887:         } else {
55746:             offset = shape->slot * sizeof(Value);
52887:         }
52887: 
60595:         repatcher.repatch(labels.getInlineShapeData(pic.fastPathStart, pic.shapeGuard),
60595:                           obj->shape());
60595:         repatcher.patchAddressOffsetForValueStore(labels.getInlineValueStore(pic.fastPathRejoin,
60595:                                                                              pic.u.vr),
60595:                                                   offset, pic.u.vr.isTypeKnown());
52887: 
52887:         pic.inlinePathPatched = true;
52887: 
56738:         return Lookup_Cacheable;
52887:     }
52887: 
60595:     int getLastStubSecondShapeGuard() const {
60595:         return lastStubSecondShapeGuard ? POST_INST_OFFSET(lastStubSecondShapeGuard) : 0;
60595:     }
60595: 
58063:     void patchPreviousToHere(CodeLocationLabel cs)
52887:     {
58063:         Repatcher repatcher(pic.lastCodeBlock(f.jit()));
58063:         CodeLocationLabel label = pic.lastPathStart();
58063: 
52887:         // Patch either the inline fast path or a generated stub. The stub
52887:         // omits the prefix of the inline fast path that loads the shape, so
52887:         // the offsets are different.
60601:         if (pic.stubsGenerated) {
60601:             repatcher.relink(pic.setPropLabels().getStubShapeJump(label), cs);
60601:         } else {
60601:             CodeLocationLabel shapeGuard = label.labelAtOffset(pic.shapeGuard);
60601:             repatcher.relink(pic.setPropLabels().getInlineShapeJump(shapeGuard), cs);
60601:         }
60595:         if (int secondGuardOffset = getLastStubSecondShapeGuard())
60595:             repatcher.relink(label.jumpAtOffset(secondGuardOffset), cs);
52887:     }
52887: 
56738:     LookupStatus generateStub(uint32 initialShape, const Shape *shape, bool adding, bool inlineSlot)
52887:     {
53620:         /* Exits to the slow path. */
55463:         Vector<Jump, 8> slowExits(cx);
55463:         Vector<Jump, 8> otherGuards(cx);
53620: 
52887:         Assembler masm;
52887: 
52887:         // Shape guard.
53054:         if (pic.shapeNeedsRemat()) {
53054:             masm.loadShape(pic.objReg, pic.shapeReg);
53054:             pic.shapeRegHasBaseShape = true;
53054:         }
53054: 
53054:         Label start = masm.label();
60602:         Jump shapeGuard = masm.branch32FixedLength(Assembler::NotEqual, pic.shapeReg,
60600:                                                    Imm32(initialShape));
53315: 
53315:         Label stubShapeJumpLabel = masm.label();
52887: 
60601:         pic.setPropLabels().setStubShapeJump(masm, start, stubShapeJumpLabel);
60601: 
53531:         JS_ASSERT_IF(!shape->hasDefaultSetter(), obj->getClass() == &js_CallClass);
53054: 
54749:         MaybeJump skipOver;
53620: 
53620:         if (adding) {
53620:             JS_ASSERT(shape->hasSlot());
53620:             pic.shapeRegHasBaseShape = false;
53620: 
53620:             /* Emit shape guards for the object's prototype chain. */
53620:             JSObject *proto = obj->getProto();
54749:             RegisterID lastReg = pic.objReg;
53620:             while (proto) {
54749:                 masm.loadPtr(Address(lastReg, offsetof(JSObject, proto)), pic.shapeReg);
56738:                 Jump protoGuard = masm.guardShape(pic.shapeReg, proto);
54749:                 if (!otherGuards.append(protoGuard))
56738:                     return error();
53620: 
53620:                 proto = proto->getProto();
54749:                 lastReg = pic.shapeReg;
53620:             }
53620: 
53620:             if (pic.kind == ic::PICInfo::SETMETHOD) {
53620:                 /*
53620:                  * Guard that the value is equal to the shape's method.
53620:                  * We already know it is a function, so test the payload.
53620:                  */
53620:                 JS_ASSERT(shape->isMethod());
53620:                 JSObject *funobj = &shape->methodObject();
56575:                 if (pic.u.vr.isConstant()) {
56575:                     JS_ASSERT(funobj == &pic.u.vr.value().toObject());
53620:                 } else {
53620:                     Jump mismatchedFunction =
56575:                         masm.branchPtr(Assembler::NotEqual, pic.u.vr.dataReg(), ImmPtr(funobj));
53620:                     if (!slowExits.append(mismatchedFunction))
56738:                         return error();
53620:                 }
53620:             }
53620: 
55746:             if (inlineSlot) {
53620:                 Address address(pic.objReg,
55746:                                 JSObject::getFixedSlotOffset(shape->slot));
54582:                 masm.storeValue(pic.u.vr, address);
53620:             } else {
53620:                 /* Check capacity. */
55746:                 Address capacity(pic.objReg, offsetof(JSObject, capacity));
53620:                 masm.load32(masm.payloadOf(capacity), pic.shapeReg);
53620:                 Jump overCapacity = masm.branch32(Assembler::LessThanOrEqual, pic.shapeReg,
53620:                                                   Imm32(shape->slot));
53620:                 if (!slowExits.append(overCapacity))
56738:                     return error();
53620: 
55746:                 masm.loadPtr(Address(pic.objReg, offsetof(JSObject, slots)), pic.shapeReg);
55746:                 Address address(pic.shapeReg, shape->slot * sizeof(Value));
54582:                 masm.storeValue(pic.u.vr, address);
53620:             }
53620: 
53620:             uint32 newShape = obj->shape();
53620:             JS_ASSERT(newShape != initialShape);
53620: 
53620:             /* Write the object's new shape. */
53620:             masm.storePtr(ImmPtr(shape), Address(pic.objReg, offsetof(JSObject, lastProp)));
53620:             masm.store32(Imm32(newShape), Address(pic.objReg, offsetof(JSObject, objShape)));
53620: 
53650:             /* If this is a method shape, update the object's flags. */
53650:             if (shape->isMethod()) {
53650:                 Address flags(pic.objReg, offsetof(JSObject, flags));
53650: 
53650:                 /* Use shapeReg to load, bitwise-or, and store flags. */
53650:                 masm.load32(flags, pic.shapeReg);
53650:                 masm.or32(Imm32(JSObject::METHOD_BARRIER), pic.shapeReg);
53650:                 masm.store32(pic.shapeReg, flags);
53650:             }
53620:         } else if (shape->hasDefaultSetter()) {
55746:             Address address(pic.objReg, JSObject::getFixedSlotOffset(shape->slot));
55746:             if (!inlineSlot) {
55746:                 masm.loadPtr(Address(pic.objReg, offsetof(JSObject, slots)), pic.objReg);
55746:                 address = Address(pic.objReg, shape->slot * sizeof(Value));
52887:             }
52887: 
52890:             // If the scope is branded, or has a method barrier. It's now necessary
52890:             // to guard that we're not overwriting a function-valued property.
53531:             if (obj->brandedOrHasMethodBarrier()) {
52890:                 masm.loadTypeTag(address, pic.shapeReg);
53023:                 Jump skip = masm.testObject(Assembler::NotEqual, pic.shapeReg);
53315:                 masm.loadPayload(address, pic.shapeReg);
54749:                 Jump rebrand = masm.testFunction(Assembler::Equal, pic.shapeReg);
54749:                 if (!slowExits.append(rebrand))
56738:                     return error();
53023:                 skip.linkTo(masm.label(), &masm);
53054:                 pic.shapeRegHasBaseShape = false;
52890:             }
52890: 
54582:             masm.storeValue(pic.u.vr, address);
52887:         } else {
53840:             //   \ /        In general, two function objects with different JSFunctions
53840:             //    #         can have the same shape, thus we must not rely on the identity
53840:             // >--+--<      of 'fun' remaining the same. However, since:
53840:             //   |||         1. the shape includes all arguments and locals and their setters
53840:             //    \\     V     and getters, and
53840:             //      \===/    2. arguments and locals have different getters
53840:             //              then we can rely on fun->nargs remaining invariant.
53840:             JSFunction *fun = obj->getCallObjCalleeFunction();
53531:             uint16 slot = uint16(shape->shortid);
53054: 
53054:             /* Guard that the call object has a frame. */
60777:             masm.loadObjPrivate(pic.objReg, pic.shapeReg);
53057:             Jump escapedFrame = masm.branchTestPtr(Assembler::Zero, pic.shapeReg, pic.shapeReg);
53054: 
53057:             {
53840:                 Address addr(pic.shapeReg, shape->setterOp() == SetCallArg
53840:                                            ? JSStackFrame::offsetOfFormalArg(fun, slot)
53840:                                            : JSStackFrame::offsetOfFixed(slot));
54582:                 masm.storeValue(pic.u.vr, addr);
53057:                 skipOver = masm.jump();
53057:             }
53057: 
53057:             escapedFrame.linkTo(masm.label(), &masm);
53057:             {
53840:                 if (shape->setterOp() == SetCallVar)
53057:                     slot += fun->nargs;
55746:                 masm.loadPtr(Address(pic.objReg, offsetof(JSObject, slots)), pic.objReg);
53057: 
55746:                 Address dslot(pic.objReg, (slot + JSObject::CALL_RESERVED_SLOTS) * sizeof(Value));
54582:                 masm.storeValue(pic.u.vr, dslot);
53057:             }
53057: 
53054:             pic.shapeRegHasBaseShape = false;
52887:         }
60601: 
52887:         Jump done = masm.jump();
52887: 
54749:         // Common all secondary guards into one big exit.
54749:         MaybeJump slowExit;
54749:         if (otherGuards.length()) {
54749:             for (Jump *pj = otherGuards.begin(); pj != otherGuards.end(); ++pj)
54749:                 pj->linkTo(masm.label(), &masm);
54749:             slowExit = masm.jump();
54749:             pic.secondShapeGuard = masm.distanceOf(masm.label()) - masm.distanceOf(start);
54749:         } else {
54749:             pic.secondShapeGuard = 0;
54749:         }
54749: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
52887: 
58074:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58074:         }
58064: 
54749:         buffer.link(shapeGuard, pic.slowPathStart);
54749:         if (slowExit.isSet())
54749:             buffer.link(slowExit.get(), pic.slowPathStart);
53620:         for (Jump *pj = slowExits.begin(); pj != slowExits.end(); ++pj)
53620:             buffer.link(*pj, pic.slowPathStart);
56575:         buffer.link(done, pic.fastPathRejoin);
54749:         if (skipOver.isSet())
56575:             buffer.link(skipOver.get(), pic.fastPathRejoin);
58064:         CodeLocationLabel cs = buffer.finalize();
52887:         JaegerSpew(JSpew_PICs, "generate setprop stub %p %d %d at %p\n",
52887:                    (void*)&pic,
53620:                    initialShape,
52887:                    pic.stubsGenerated,
52887:                    cs.executableAddress());
52887: 
52887:         // This function can patch either the inline fast path for a generated
52887:         // stub. The stub omits the prefix of the inline fast path that loads
52887:         // the shape, so the offsets are different.
58063:         patchPreviousToHere(cs);
52887: 
52887:         pic.stubsGenerated++;
58063:         pic.updateLastPath(buffer, start);
52887: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
52887:             disable("max stubs reached");
52887: 
56738:         return Lookup_Cacheable;
52887:     }
52887: 
56738:     LookupStatus update()
52887:     {
56738:         JS_ASSERT(pic.hit);
52887: 
53620:         if (obj->isDenseArray())
53620:             return disable("dense array");
53620:         if (!obj->isNative())
52887:             return disable("non-native");
53620: 
53865:         Class *clasp = obj->getClass();
53865: 
62395:         if (clasp->setProperty != StrictPropertyStub)
53865:             return disable("set property hook");
53865:         if (clasp->ops.lookupProperty)
53865:             return disable("ops lookup property hook");
53865:         if (clasp->ops.setProperty)
53865:             return disable("ops set property hook");
53865: 
53620:         jsid id = ATOM_TO_JSID(atom);
52887: 
52887:         JSObject *holder;
52887:         JSProperty *prop = NULL;
55463:         if (!obj->lookupProperty(cx, id, &holder, &prop))
56738:             return error();
53620: 
53620:         /* If the property exists but is on a prototype, treat as addprop. */
53620:         if (prop && holder != obj) {
53620:             const Shape *shape = (const Shape *) prop;
53620: 
53620:             if (!holder->isNative())
53620:                 return disable("non-native holder");
53620: 
53620:             if (!shape->writable())
53620:                 return disable("readonly");
53620:             if (!shape->hasDefaultSetter() || !shape->hasDefaultGetter())
53620:                 return disable("getter/setter in prototype");
53620:             if (shape->hasShortID())
53620:                 return disable("short ID in prototype");
53620:             if (!shape->hasSlot())
53620:                 return disable("missing slot");
53620: 
53620:             prop = NULL;
53620:         }
53620: 
53620:         if (!prop) {
53620:             /* Adding a property to the object. */
53620:             if (obj->isDelegate())
53620:                 return disable("delegate");
56008:             if (!obj->isExtensible())
56008:                 return disable("not extensible");
53620: 
53620:             if (clasp->addProperty != PropertyStub)
53620:                 return disable("add property hook");
53865:             if (clasp->ops.defineProperty)
53865:                 return disable("ops define property hook");
53620: 
53620:             uint32 index;
53620:             if (js_IdIsIndex(id, &index))
53620:                 return disable("index");
53620: 
53620:             uint32 initialShape = obj->shape();
53620: 
55463:             if (!obj->ensureClassReservedSlots(cx))
56738:                 return error();
53620: 
53620:             uint32 slots = obj->numSlots();
53620:             uintN flags = 0;
53620:             PropertyOp getter = clasp->getProperty;
53620: 
53620:             if (pic.kind == ic::PICInfo::SETMETHOD) {
53620:                 if (!obj->canHaveMethodBarrier())
53620:                     return disable("can't have method barrier");
53620: 
53620:                 JSObject *funobj = &f.regs.sp[-1].toObject();
53620:                 if (funobj != GET_FUNCTION_PRIVATE(cx, funobj))
53620:                     return disable("mismatched function");
53620: 
53620:                 flags |= Shape::METHOD;
53620:                 getter = CastAsPropertyOp(funobj);
53620:             }
53620: 
59009:             /*
59009:              * Define the property but do not set it yet. For setmethod,
59009:              * populate the slot to satisfy the method invariant (in case we
59009:              * hit an early return below).
59009:              */
53620:             const Shape *shape =
55463:                 obj->putProperty(cx, id, getter, clasp->setProperty,
53620:                                  SHAPE_INVALID_SLOT, JSPROP_ENUMERATE, flags, 0);
53620:             if (!shape)
56738:                 return error();
59009:             if (flags & Shape::METHOD)
59009:                 obj->nativeSetSlot(shape->slot, f.regs.sp[-1]);
53620: 
53889:             /*
53889:              * Test after calling putProperty since it can switch obj into
53889:              * dictionary mode, specifically if the shape tree ancestor line
53889:              * exceeds PropertyTree::MAX_HEIGHT.
53889:              */
53889:             if (obj->inDictionaryMode())
53889:                 return disable("dictionary");
53889: 
53620:             if (!shape->hasDefaultSetter())
53620:                 return disable("adding non-default setter");
53620:             if (!shape->hasSlot())
53620:                 return disable("adding invalid slot");
53620: 
53620:             /*
53620:              * Watch for cases where the object reallocated its slots when
53620:              * adding the property, and disable the PIC.  Otherwise we will
53620:              * keep generating identical PICs as side exits are taken on the
53620:              * capacity checks.  Alternatively, we could avoid the disable
53620:              * and just not generate a stub in case there are multiple shapes
53620:              * that can flow here which don't all require reallocation.
53620:              * Doing this would cause us to walk down this same update path
53620:              * every time a reallocation is needed, however, which will
53620:              * usually be a slowdown even if there *are* other shapes that
53620:              * don't realloc.
53620:              */
53620:             if (obj->numSlots() != slots)
53620:                 return disable("insufficient slot capacity");
53620: 
55746:             return generateStub(initialShape, shape, true, !obj->hasSlotsArray());
53620:         }
53582: 
53582:         const Shape *shape = (const Shape *) prop;
53620:         if (pic.kind == ic::PICInfo::SETMETHOD && !shape->isMethod())
53620:             return disable("set method on non-method shape");
53582:         if (!shape->writable())
53582:             return disable("readonly");
52887: 
53531:         if (shape->hasDefaultSetter()) {
53531:             if (!shape->hasSlot())
52887:                 return disable("invalid slot");
53054:         } else {
53531:             if (shape->hasSetterValue())
53054:                 return disable("scripted setter");
53531:             if (shape->setterOp() != SetCallArg &&
53531:                 shape->setterOp() != SetCallVar) {
53054:                 return disable("setter");
53054:             }
53054:         }
52887: 
52887:         JS_ASSERT(obj == holder);
52895:         if (!pic.inlinePathPatched &&
53531:             !obj->brandedOrHasMethodBarrier() &&
53531:             shape->hasDefaultSetter() &&
52895:             !obj->isDenseArray()) {
55746:             return patchInline(shape, !obj->hasSlotsArray());
52895:         } 
52895: 
55746:         return generateStub(obj->shape(), shape, false, !obj->hasSlotsArray());
52887:     }
52887: };
52887: 
56738: static bool
56738: IsCacheableProtoChain(JSObject *obj, JSObject *holder)
56738: {
56738:     while (obj != holder) {
56738:         JSObject *proto = obj->getProto();
56738:         if (!proto->isNative())
56738:             return false;
56738:         obj = proto;
56738:     }
56738:     return true;
56738: }
56738: 
56738: template <typename IC>
56738: struct GetPropertyHelper {
57125:     // These fields are set in the constructor and describe a property lookup.
56738:     JSContext   *cx;
56738:     JSObject    *obj;
56738:     JSAtom      *atom;
56738:     IC          &ic;
56738: 
57125:     // These fields are set by |bind| and |lookup|. After a call to either
57125:     // function, these are set exactly as they are in JSOP_GETPROP or JSOP_NAME.
56738:     JSObject    *aobj;
56738:     JSObject    *holder;
57125:     JSProperty  *prop;
57125:  
57125:     // This field is set by |bind| and |lookup| only if they returned
57125:     // Lookup_Cacheable, otherwise it is NULL.
56738:     const Shape *shape;
56738: 
56738:     GetPropertyHelper(JSContext *cx, JSObject *obj, JSAtom *atom, IC &ic)
57125:       : cx(cx), obj(obj), atom(atom), ic(ic), holder(NULL), prop(NULL), shape(NULL)
56738:     { }
56738: 
56738:   public:
56738:     LookupStatus bind() {
56738:         if (!js_FindProperty(cx, ATOM_TO_JSID(atom), &obj, &holder, &prop))
56738:             return ic.error(cx);
56738:         if (!prop)
56738:             return ic.disable(cx, "lookup failed");
57169:         if (!obj->isNative())
57169:             return ic.disable(cx, "non-native");
57125:         if (!IsCacheableProtoChain(obj, holder))
57125:             return ic.disable(cx, "non-native holder");
56738:         shape = (const Shape *)prop;
56738:         return Lookup_Cacheable;
56738:     }
56738: 
56738:     LookupStatus lookup() {
56738:         JSObject *aobj = js_GetProtoIfDenseArray(obj);
56738:         if (!aobj->isNative())
56738:             return ic.disable(cx, "non-native");
56738:         if (!aobj->lookupProperty(cx, ATOM_TO_JSID(atom), &holder, &prop))
56738:             return ic.error(cx);
56738:         if (!prop)
56738:             return ic.disable(cx, "lookup failed");
56738:         if (!IsCacheableProtoChain(obj, holder))
56738:             return ic.disable(cx, "non-native holder");
56738:         shape = (const Shape *)prop;
56738:         return Lookup_Cacheable;
56738:     }
56738: 
56738:     LookupStatus testForGet() {
56738:         if (!shape->hasDefaultGetter()) {
56738:             if (!shape->isMethod())
56738:                 return ic.disable(cx, "getter");
56738:             if (!ic.isCallOp())
56738:                 return ic.disable(cx, "method valued shape");
56738:         } else if (!shape->hasSlot()) {
56738:             return ic.disable(cx, "no slot");
56738:         }
56738: 
56738:         return Lookup_Cacheable;
56738:     }
56738: 
56738:     LookupStatus lookupAndTest() {
56738:         LookupStatus status = lookup();
56738:         if (status != Lookup_Cacheable)
56738:             return status;
56738:         return testForGet();
56738:     }
56738: };
56738: 
52880: class GetPropCompiler : public PICStubCompiler
52880: {
52880:     JSObject    *obj;
52880:     JSAtom      *atom;
52884:     int         lastStubSecondShapeGuard;
52880: 
52880:   public:
52880:     GetPropCompiler(VMFrame &f, JSScript *script, JSObject *obj, ic::PICInfo &pic, JSAtom *atom,
55503:                     VoidStubPIC stub)
56738:       : PICStubCompiler(pic.kind == ic::PICInfo::CALL ? "callprop" : "getprop", f, script, pic,
56738:                         JS_FUNC_TO_DATA_PTR(void *, stub)),
56201:         obj(obj),
56201:         atom(atom),
54749:         lastStubSecondShapeGuard(pic.secondShapeGuard)
52880:     { }
52880: 
60592:     int getLastStubSecondShapeGuard() const {
60595:         return lastStubSecondShapeGuard ? POST_INST_OFFSET(lastStubSecondShapeGuard) : 0;
60592:     }
60592: 
58063:     static void reset(Repatcher &repatcher, ic::PICInfo &pic)
52880:     {
60592:         GetPropLabels &labels = pic.getPropLabels();
60592:         repatcher.repatchLEAToLoadPtr(labels.getDslotsLoad(pic.fastPathRejoin));
60592:         repatcher.repatch(labels.getInlineShapeData(pic.getFastShapeGuard()),
53531:                           int32(JSObjectMap::INVALID_SHAPE));
60592:         repatcher.relink(labels.getInlineShapeJump(pic.getFastShapeGuard()), pic.slowPathStart);
53353: 
53353:         if (pic.hasTypeCheck()) {
60592:             /* TODO: combine pic.u.get into ICLabels? */
60592:             repatcher.relink(labels.getInlineTypeJump(pic.fastPathStart), pic.getSlowTypeCheck());
53353:         }
52884: 
55503:         VoidStubPIC stub;
53298:         switch (pic.kind) {
53298:           case ic::PICInfo::GET:
53261:             stub = ic::GetProp;
53298:             break;
53298:           case ic::PICInfo::CALL:
53261:             stub = ic::CallProp;
53298:             break;
53298:           default:
53261:             JS_NOT_REACHED("invalid pic kind for GetPropCompiler::reset");
53298:             return;
53298:         }
53261: 
56575:         FunctionPtr target(JS_FUNC_TO_DATA_PTR(void *, stub));
56575:         repatcher.relink(pic.slowPathCall, target);
52884:     }
52884: 
56738:     LookupStatus generateArgsLengthStub()
53123:     {
53123:         Assembler masm;
53123: 
56575:         Jump notArgs = masm.testObjClass(Assembler::NotEqual, pic.objReg, obj->getClass());
53123: 
55746:         masm.loadPtr(Address(pic.objReg, offsetof(JSObject, slots)), pic.objReg);
55746:         masm.load32(Address(pic.objReg, JSObject::JSSLOT_ARGS_LENGTH * sizeof(Value)),
53123:                     pic.objReg);
53123:         masm.move(pic.objReg, pic.shapeReg);
59970:         Jump overridden = masm.branchTest32(Assembler::NonZero, pic.shapeReg,
59970:                                             Imm32(JSObject::ARGS_LENGTH_OVERRIDDEN_BIT));
53857:         masm.rshift32(Imm32(JSObject::ARGS_PACKED_BITS_COUNT), pic.objReg);
53123:         
53315:         masm.move(ImmType(JSVAL_TYPE_INT32), pic.shapeReg);
53123:         Jump done = masm.jump();
53123: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
53123: 
58074:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58074:         }
58064: 
53123:         buffer.link(notArgs, pic.slowPathStart);
53123:         buffer.link(overridden, pic.slowPathStart);
56575:         buffer.link(done, pic.fastPathRejoin);
53123: 
58064:         CodeLocationLabel start = buffer.finalize();
53123:         JaegerSpew(JSpew_PICs, "generate args length stub at %p\n",
53123:                    start.executableAddress());
53123: 
58063:         patchPreviousToHere(start);
53123: 
53123:         disable("args length done");
53123: 
56738:         return Lookup_Cacheable;
53123:     }
53123: 
56738:     LookupStatus generateArrayLengthStub()
52884:     {
52884:         Assembler masm;
52884: 
56575:         masm.loadObjClass(pic.objReg, pic.shapeReg);
56575:         Jump isDense = masm.testClass(Assembler::Equal, pic.shapeReg, &js_ArrayClass);
56575:         Jump notArray = masm.testClass(Assembler::NotEqual, pic.shapeReg, &js_SlowArrayClass);
52884: 
52884:         isDense.linkTo(masm.label(), &masm);
55746:         masm.load32(Address(pic.objReg, offsetof(JSObject, privateData)), pic.objReg);
52884:         Jump oob = masm.branch32(Assembler::Above, pic.objReg, Imm32(JSVAL_INT_MAX));
53315:         masm.move(ImmType(JSVAL_TYPE_INT32), pic.shapeReg);
52884:         Jump done = masm.jump();
52884: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
52884: 
58074:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58074:         }
58064: 
52884:         buffer.link(notArray, pic.slowPathStart);
52884:         buffer.link(oob, pic.slowPathStart);
56575:         buffer.link(done, pic.fastPathRejoin);
52884: 
58064:         CodeLocationLabel start = buffer.finalize();
52884:         JaegerSpew(JSpew_PICs, "generate array length stub at %p\n",
52884:                    start.executableAddress());
52884: 
58063:         patchPreviousToHere(start);
52884: 
52884:         disable("array length done");
52884: 
56738:         return Lookup_Cacheable;
52884:     }
52884: 
59970:     LookupStatus generateStringObjLengthStub()
59970:     {
59970:         Assembler masm;
59970: 
59970:         Jump notStringObj = masm.testObjClass(Assembler::NotEqual, pic.objReg, obj->getClass());
60248:         masm.loadPtr(Address(pic.objReg, offsetof(JSObject, slots)), pic.objReg);
60248:         masm.loadPayload(Address(pic.objReg, JSObject::JSSLOT_PRIMITIVE_THIS * sizeof(Value)),
60248:                          pic.objReg);
59970:         masm.loadPtr(Address(pic.objReg, JSString::offsetOfLengthAndFlags()), pic.objReg);
59970:         masm.urshift32(Imm32(JSString::LENGTH_SHIFT), pic.objReg);
59970:         masm.move(ImmType(JSVAL_TYPE_INT32), pic.shapeReg);
59970:         Jump done = masm.jump();
59970: 
59970:         PICLinker buffer(masm, pic);
59970:         if (!buffer.init(cx))
59970:             return error();
59970: 
59970:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
59970:             !buffer.verifyRange(f.jit())) {
59970:             return disable("code memory is out of range");
59970:         }
59970: 
59970:         buffer.link(notStringObj, pic.slowPathStart);
59970:         buffer.link(done, pic.fastPathRejoin);
59970: 
59970:         CodeLocationLabel start = buffer.finalize();
59970:         JaegerSpew(JSpew_PICs, "generate string object length stub at %p\n",
59970:                    start.executableAddress());
59970: 
59970:         patchPreviousToHere(start);
59970: 
59970:         disable("string object length done");
59970: 
59970:         return Lookup_Cacheable;
59970:     }
59970: 
56738:     LookupStatus generateStringCallStub()
52907:     {
52907:         JS_ASSERT(pic.hasTypeCheck());
52907:         JS_ASSERT(pic.kind == ic::PICInfo::CALL);
52907: 
53840:         if (!f.fp()->script()->compileAndGo)
52907:             return disable("String.prototype without compile-and-go");
52907: 
56738:         GetPropertyHelper<GetPropCompiler> getprop(cx, obj, atom, *this);
56738:         LookupStatus status = getprop.lookupAndTest();
56738:         if (status != Lookup_Cacheable)
56738:             return status;
56738:         if (getprop.obj != getprop.holder)
52907:             return disable("proto walk on String.prototype");
52907: 
52907:         Assembler masm;
52907: 
52907:         /* Only strings are allowed. */
53315:         Jump notString = masm.branchPtr(Assembler::NotEqual, pic.typeReg(),
53315:                                         ImmType(JSVAL_TYPE_STRING));
52907: 
52907:         /*
56738:          * Sink pic.objReg, since we're about to lose it.
52907:          *
52907:          * Note: This is really hacky, and relies on f.regs.sp being set
52907:          * correctly in ic::CallProp. Should we just move the store higher
52907:          * up in the fast path, or put this offset in PICInfo?
52907:          */
53482:         uint32 thisvOffset = uint32(f.regs.sp - f.fp()->slots()) - 1;
52907:         Address thisv(JSFrameReg, sizeof(JSStackFrame) + thisvOffset * sizeof(Value));
54582:         masm.storeValueFromComponents(ImmType(JSVAL_TYPE_STRING),
54582:                                       pic.objReg, thisv);
52907: 
52907:         /*
52907:          * Clobber objReg with String.prototype and do some PIC stuff. Well,
52907:          * really this is now a MIC, except it won't ever be patched, so we
52907:          * just disable the PIC at the end. :FIXME:? String.prototype probably
52907:          * does not get random shape changes.
52907:          */
52907:         masm.move(ImmPtr(obj), pic.objReg);
52907:         masm.loadShape(pic.objReg, pic.shapeReg);
52907:         Jump shapeMismatch = masm.branch32(Assembler::NotEqual, pic.shapeReg,
52907:                                            Imm32(obj->shape()));
56738:         masm.loadObjProp(obj, pic.objReg, getprop.shape, pic.shapeReg, pic.objReg);
52907: 
52907:         Jump done = masm.jump();
52907: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
52907: 
58064:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58064:         }
58064: 
60592:         buffer.link(notString, pic.getSlowTypeCheck());
55463:         buffer.link(shapeMismatch, pic.slowPathStart);
56575:         buffer.link(done, pic.fastPathRejoin);
52907: 
58064:         CodeLocationLabel cs = buffer.finalize();
52907:         JaegerSpew(JSpew_PICs, "generate string call stub at %p\n",
52907:                    cs.executableAddress());
52907: 
52907:         /* Patch the type check to jump here. */
53353:         if (pic.hasTypeCheck()) {
58063:             Repatcher repatcher(f.jit());
60592:             repatcher.relink(pic.getPropLabels().getInlineTypeJump(pic.fastPathStart), cs);
53353:         }
52907: 
52907:         /* Disable the PIC so we don't keep generating stubs on the above shape mismatch. */
52907:         disable("generated string call stub");
52907: 
56738:         return Lookup_Cacheable;
52907:     }
52907: 
56738:     LookupStatus generateStringLengthStub()
52884:     {
52887:         JS_ASSERT(pic.hasTypeCheck());
52884: 
52884:         Assembler masm;
53315:         Jump notString = masm.branchPtr(Assembler::NotEqual, pic.typeReg(),
53315:                                         ImmType(JSVAL_TYPE_STRING));
59888:         masm.loadPtr(Address(pic.objReg, JSString::offsetOfLengthAndFlags()), pic.objReg);
53216:         // String length is guaranteed to be no more than 2**28, so the 32-bit operation is OK.
59888:         masm.urshift32(Imm32(JSString::LENGTH_SHIFT), pic.objReg);
53315:         masm.move(ImmType(JSVAL_TYPE_INT32), pic.shapeReg);
52884:         Jump done = masm.jump();
52884: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
52884: 
58064:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58064:         }
58064: 
60592:         buffer.link(notString, pic.getSlowTypeCheck());
56575:         buffer.link(done, pic.fastPathRejoin);
52884: 
58064:         CodeLocationLabel start = buffer.finalize();
52884:         JaegerSpew(JSpew_PICs, "generate string length stub at %p\n",
52884:                    start.executableAddress());
52884: 
53353:         if (pic.hasTypeCheck()) {
58063:             Repatcher repatcher(f.jit());
60592:             repatcher.relink(pic.getPropLabels().getInlineTypeJump(pic.fastPathStart), start);
53353:         }
52884: 
53311:         disable("generated string length stub");
53311: 
56738:         return Lookup_Cacheable;
52880:     }
52880: 
56738:     LookupStatus patchInline(JSObject *holder, const Shape *shape)
52880:     {
52880:         spew("patch", "inline");
58063:         Repatcher repatcher(f.jit());
60592:         GetPropLabels &labels = pic.getPropLabels();
52880: 
52880:         int32 offset;
55746:         if (!holder->hasSlotsArray()) {
60592:             CodeLocationInstruction istr = labels.getDslotsLoad(pic.fastPathRejoin);
52880:             repatcher.repatchLoadPtrToLEA(istr);
52880: 
52880:             // 
52880:             // We've patched | mov dslots, [obj + DSLOTS_OFFSET]
52880:             // To:           | lea fslots, [obj + DSLOTS_OFFSET]
52880:             //
52880:             // Because the offset is wrong, it's necessary to correct it
52880:             // below.
52880:             //
55746:             int32 diff = int32(JSObject::getFixedSlotOffset(0)) -
55746:                          int32(offsetof(JSObject, slots));
52880:             JS_ASSERT(diff != 0);
53531:             offset  = (int32(shape->slot) * sizeof(Value)) + diff;
52880:         } else {
55746:             offset = shape->slot * sizeof(Value);
52880:         }
52880: 
60592:         repatcher.repatch(labels.getInlineShapeData(pic.getFastShapeGuard()), obj->shape());
60592:         repatcher.patchAddressOffsetForValueLoad(labels.getValueLoad(pic.fastPathRejoin), offset);
52880: 
52880:         pic.inlinePathPatched = true;
52880: 
56738:         return Lookup_Cacheable;
52880:     }
52880: 
56738:     LookupStatus generateStub(JSObject *holder, const Shape *shape)
52880:     {
55463:         Vector<Jump, 8> shapeMismatches(cx);
52880: 
52880:         Assembler masm;
52880: 
52895:         Label start;
60592:         Jump shapeGuardJump;
53123:         Jump argsLenGuard;
60590: 
60590:         bool setStubShapeOffset = true;
52895:         if (obj->isDenseArray()) {
52895:             start = masm.label();
60592:             shapeGuardJump = masm.testObjClass(Assembler::NotEqual, pic.objReg, obj->getClass());
56575: 
53270:             /* 
53270:              * No need to assert validity of GETPROP_STUB_SHAPE_JUMP in this case:
53270:              * the IC is disabled after a dense array hit, so no patching can occur.
53270:              */
60590: #ifndef JS_HAS_IC_LABELS
60590:             setStubShapeOffset = false;
60590: #endif
52895:         } else {
52887:             if (pic.shapeNeedsRemat()) {
52880:                 masm.loadShape(pic.objReg, pic.shapeReg);
53054:                 pic.shapeRegHasBaseShape = true;
52880:             }
52880: 
52895:             start = masm.label();
60602:             shapeGuardJump = masm.branch32FixedLength(Assembler::NotEqual, pic.shapeReg,
60597:                                                       Imm32(obj->shape()));
52895:         }
53315:         Label stubShapeJumpLabel = masm.label();
53315: 
60592:         if (!shapeMismatches.append(shapeGuardJump))
56738:             return error();
56735: 
56738:         RegisterID holderReg = pic.objReg;
56738:         if (obj != holder) {
56738:             // Bake in the holder identity. Careful not to clobber |objReg|, since we can't remat it.
56738:             holderReg = pic.shapeReg;
56738:             masm.move(ImmPtr(holder), holderReg);
56738:             pic.shapeRegHasBaseShape = false;
53270: 
56738:             // Guard on the holder's shape.
56738:             Jump j = masm.guardShape(holderReg, holder);
56738:             if (!shapeMismatches.append(j))
56738:                 return error();
56735: 
54749:             pic.secondShapeGuard = masm.distanceOf(masm.label()) - masm.distanceOf(start);
52880:         } else {
54749:             pic.secondShapeGuard = 0;
52880:         }
52906: 
52906:         /* Load the value out of the object. */
56738:         masm.loadObjProp(holder, holderReg, shape, pic.shapeReg, pic.objReg);
52880:         Jump done = masm.jump();
52880: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
52880: 
58074:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58074:         }
58064: 
52880:         // The guard exit jumps to the original slow case.
52880:         for (Jump *pj = shapeMismatches.begin(); pj != shapeMismatches.end(); ++pj)
52880:             buffer.link(*pj, pic.slowPathStart);
52880: 
52880:         // The final exit jumps to the store-back in the inline stub.
56575:         buffer.link(done, pic.fastPathRejoin);
58064:         CodeLocationLabel cs = buffer.finalize();
52906:         JaegerSpew(JSpew_PICs, "generated %s stub at %p\n", type, cs.executableAddress());
52880: 
58063:         patchPreviousToHere(cs);
52884: 
52884:         pic.stubsGenerated++;
58063:         pic.updateLastPath(buffer, start);
52884: 
60590:         if (setStubShapeOffset)
60595:             pic.getPropLabels().setStubShapeJump(masm, start, stubShapeJumpLabel);
53315: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
52884:             disable("max stubs reached");
52895:         if (obj->isDenseArray())
52895:             disable("dense array");
52884: 
56738:         return Lookup_Cacheable;
52884:     }
52884: 
58063:     void patchPreviousToHere(CodeLocationLabel cs)
52884:     {
58063:         Repatcher repatcher(pic.lastCodeBlock(f.jit()));
58063:         CodeLocationLabel label = pic.lastPathStart();
58063: 
52880:         // Patch either the inline fast path or a generated stub. The stub
52880:         // omits the prefix of the inline fast path that loads the shape, so
52880:         // the offsets are different.
52880:         int shapeGuardJumpOffset;
52880:         if (pic.stubsGenerated)
60592:             shapeGuardJumpOffset = pic.getPropLabels().getStubShapeJumpOffset();
52880:         else
60592:             shapeGuardJumpOffset = pic.shapeGuard + pic.getPropLabels().getInlineShapeJumpOffset();
58063:         repatcher.relink(label.jumpAtOffset(shapeGuardJumpOffset), cs);
60592:         if (int secondGuardOffset = getLastStubSecondShapeGuard())
60592:             repatcher.relink(label.jumpAtOffset(secondGuardOffset), cs);
52880:     }
52880: 
56738:     LookupStatus update()
52880:     {
56738:         JS_ASSERT(pic.hit);
52880: 
56738:         GetPropertyHelper<GetPropCompiler> getprop(cx, obj, atom, *this);
56738:         LookupStatus status = getprop.lookupAndTest();
56738:         if (status != Lookup_Cacheable)
56738:             return status;
52880: 
56738:         if (obj == getprop.holder && !pic.inlinePathPatched)
56738:             return patchInline(getprop.holder, getprop.shape);
52880:         
56738:         return generateStub(getprop.holder, getprop.shape);
52880:     }
52880: };
60598: 
53054: class ScopeNameCompiler : public PICStubCompiler
53054: {
60594:   private:
60594:     typedef Vector<Jump, 8, ContextAllocPolicy> JumpList;
60594: 
53054:     JSObject *scopeChain;
53054:     JSAtom *atom;
56738:     GetPropertyHelper<ScopeNameCompiler> getprop;
57125:     ScopeNameCompiler *thisFromCtor() { return this; }
60594: 
60594:     void patchPreviousToHere(CodeLocationLabel cs)
60594:     {
60594:         ScopeNameLabels &       labels = pic.scopeNameLabels();
60594:         Repatcher               repatcher(pic.lastCodeBlock(f.jit()));
60594:         CodeLocationLabel       start = pic.lastPathStart();
60594:         JSC::CodeLocationJump   jump;
60594:         
60594:         // Patch either the inline fast path or a generated stub.
60594:         if (pic.stubsGenerated)
60594:             jump = labels.getStubJump(start);
60594:         else
60594:             jump = labels.getInlineJump(start);
60594:         repatcher.relink(jump, cs);
60594:     }
60594: 
60594:     LookupStatus walkScopeChain(Assembler &masm, JumpList &fails)
60594:     {
60594:         /* Walk the scope chain. */
60594:         JSObject *tobj = scopeChain;
60594: 
60594:         /* For GETXPROP, we'll never enter this loop. */
60594:         JS_ASSERT_IF(pic.kind == ic::PICInfo::XNAME, tobj && tobj == getprop.holder);
60594:         JS_ASSERT_IF(pic.kind == ic::PICInfo::XNAME, getprop.obj == tobj);
60594: 
60594:         while (tobj && tobj != getprop.holder) {
63085:             if (!IsCacheableNonGlobalScope(tobj))
60594:                 return disable("non-cacheable scope chain object");
60594:             JS_ASSERT(tobj->isNative());
60594: 
60594:             if (tobj != scopeChain) {
60594:                 /* scopeChain will never be NULL, but parents can be NULL. */
60594:                 Jump j = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
60594:                 if (!fails.append(j))
60594:                     return error();
60594:             }
60594:             
60594:             /* Guard on intervening shapes. */
60594:             masm.loadShape(pic.objReg, pic.shapeReg);
60594:             Jump j = masm.branch32(Assembler::NotEqual, pic.shapeReg, Imm32(tobj->shape()));
60594:             if (!fails.append(j))
60594:                 return error();
60594: 
60594:             /* Load the next link in the scope chain. */
60594:             Address parent(pic.objReg, offsetof(JSObject, parent));
60594:             masm.loadPtr(parent, pic.objReg);
60594: 
60594:             tobj = tobj->getParent();
60594:         }
60594: 
60594:         if (tobj != getprop.holder)
60594:             return disable("scope chain walk terminated early");
60594: 
60594:         return Lookup_Cacheable;
60594:     }
60594: 
53054:   public:
53054:     ScopeNameCompiler(VMFrame &f, JSScript *script, JSObject *scopeChain, ic::PICInfo &pic,
55503:                       JSAtom *atom, VoidStubPIC stub)
56738:       : PICStubCompiler("name", f, script, pic, JS_FUNC_TO_DATA_PTR(void *, stub)),
56738:         scopeChain(scopeChain), atom(atom),
57125:         getprop(f.cx, NULL, atom, *thisFromCtor())
53054:     { }
53054: 
58063:     static void reset(Repatcher &repatcher, ic::PICInfo &pic)
53054:     {
60594:         ScopeNameLabels &labels = pic.scopeNameLabels();
60594: 
60594:         /* Link the inline path back to the slow path. */
60594:         JSC::CodeLocationJump inlineJump = labels.getInlineJump(pic.fastPathStart);
60594:         repatcher.relink(inlineJump, pic.slowPathStart);
53054: 
55503:         VoidStubPIC stub = (pic.kind == ic::PICInfo::NAME) ? ic::Name : ic::XName;
56575:         FunctionPtr target(JS_FUNC_TO_DATA_PTR(void *, stub));
56575:         repatcher.relink(pic.slowPathCall, target);
53054:     }
53054: 
56738:     LookupStatus generateGlobalStub(JSObject *obj)
53164:     {
53164:         Assembler masm;
55463:         JumpList fails(cx);
60594:         ScopeNameLabels &labels = pic.scopeNameLabels();
53164: 
54847:         /* For GETXPROP, the object is already in objReg. */
54847:         if (pic.kind == ic::PICInfo::NAME)
53840:             masm.loadPtr(Address(JSFrameReg, JSStackFrame::offsetOfScopeChain()), pic.objReg);
53164: 
56738:         JS_ASSERT(obj == getprop.holder);
56738:         JS_ASSERT(getprop.holder == scopeChain->getGlobal());
53164: 
56738:         LookupStatus status = walkScopeChain(masm, fails);
56738:         if (status != Lookup_Cacheable)
56738:             return status;
53164: 
54847:         /* If a scope chain walk was required, the final object needs a NULL test. */
54847:         MaybeJump finalNull;
54847:         if (pic.kind == ic::PICInfo::NAME)
54847:             finalNull = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
53164:         masm.loadShape(pic.objReg, pic.shapeReg);
56738:         Jump finalShape = masm.branch32(Assembler::NotEqual, pic.shapeReg, Imm32(getprop.holder->shape()));
53164: 
56738:         masm.loadObjProp(obj, pic.objReg, getprop.shape, pic.shapeReg, pic.objReg);
53164:         Jump done = masm.jump();
53164: 
60594:         /* All failures flow to here, so there is a common point to patch. */
53164:         for (Jump *pj = fails.begin(); pj != fails.end(); ++pj)
53164:             pj->linkTo(masm.label(), &masm);
54847:         if (finalNull.isSet())
54847:             finalNull.get().linkTo(masm.label(), &masm);
53164:         finalShape.linkTo(masm.label(), &masm);
53164:         Label failLabel = masm.label();
53164:         Jump failJump = masm.jump();
53164: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
53164: 
58074:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58074:         }
58064: 
53164:         buffer.link(failJump, pic.slowPathStart);
56575:         buffer.link(done, pic.fastPathRejoin);
58064:         CodeLocationLabel cs = buffer.finalize();
53164:         JaegerSpew(JSpew_PICs, "generated %s global stub at %p\n", type, cs.executableAddress());
53164:         spew("NAME stub", "global");
53164: 
60594:         patchPreviousToHere(cs);
53164: 
53164:         pic.stubsGenerated++;
58063:         pic.updateLastPath(buffer, failLabel);
60594:         labels.setStubJump(masm, failLabel, failJump);
53164: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
53164:             disable("max stubs reached");
53164: 
56738:         return Lookup_Cacheable;
53164:     }
53164: 
53164:     enum CallObjPropKind {
53164:         ARG,
53164:         VAR
53164:     };
53164: 
56738:     LookupStatus generateCallStub(JSObject *obj)
53164:     {
53164:         Assembler masm;
55463:         Vector<Jump, 8, ContextAllocPolicy> fails(cx);
60594:         ScopeNameLabels &labels = pic.scopeNameLabels();
53164: 
54847:         /* For GETXPROP, the object is already in objReg. */
54847:         if (pic.kind == ic::PICInfo::NAME)
53840:             masm.loadPtr(Address(JSFrameReg, JSStackFrame::offsetOfScopeChain()), pic.objReg);
53164: 
56738:         JS_ASSERT(obj == getprop.holder);
56738:         JS_ASSERT(getprop.holder != scopeChain->getGlobal());
53164: 
53164:         CallObjPropKind kind;
56738:         const Shape *shape = getprop.shape;
58293:         if (shape->getterOp() == GetCallArg) {
53164:             kind = ARG;
58293:         } else if (shape->getterOp() == GetCallVar) {
53164:             kind = VAR;
53164:         } else {
53164:             return disable("unhandled callobj sprop getter");
53164:         }
53164: 
56738:         LookupStatus status = walkScopeChain(masm, fails);
56738:         if (status != Lookup_Cacheable)
56738:             return status;
53054: 
54847:         /* If a scope chain walk was required, the final object needs a NULL test. */
54847:         MaybeJump finalNull;
54847:         if (pic.kind == ic::PICInfo::NAME)
54847:             finalNull = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
53054:         masm.loadShape(pic.objReg, pic.shapeReg);
56738:         Jump finalShape = masm.branch32(Assembler::NotEqual, pic.shapeReg, Imm32(getprop.holder->shape()));
53054: 
53054:         /* Get callobj's stack frame. */
60777:         masm.loadObjPrivate(pic.objReg, pic.shapeReg);
53054: 
56738:         JSFunction *fun = getprop.holder->getCallObjCalleeFunction();
53531:         uint16 slot = uint16(shape->shortid);
53054: 
53054:         Jump skipOver;
53054:         Jump escapedFrame = masm.branchTestPtr(Assembler::Zero, pic.shapeReg, pic.shapeReg);
53054: 
53054:         /* Not-escaped case. */
53054:         {
53840:             Address addr(pic.shapeReg, kind == ARG ? JSStackFrame::offsetOfFormalArg(fun, slot)
53840:                                                    : JSStackFrame::offsetOfFixed(slot));
53144:             masm.loadPayload(addr, pic.objReg);
53054:             masm.loadTypeTag(addr, pic.shapeReg);
53054:             skipOver = masm.jump();
53054:         }
53054: 
53056:         escapedFrame.linkTo(masm.label(), &masm);
53056: 
53056:         {
55746:             masm.loadPtr(Address(pic.objReg, offsetof(JSObject, slots)), pic.objReg);
53056: 
53056:             if (kind == VAR)
53056:                 slot += fun->nargs;
55746:             Address dslot(pic.objReg, (slot + JSObject::CALL_RESERVED_SLOTS) * sizeof(Value));
54414: 
54414:             /* Safe because type is loaded first. */
54414:             masm.loadValueAsComponents(dslot, pic.shapeReg, pic.objReg);
53056:         }
53056: 
53056:         skipOver.linkTo(masm.label(), &masm);
53056:         Jump done = masm.jump();
53056: 
53054:         // All failures flow to here, so there is a common point to patch.
53054:         for (Jump *pj = fails.begin(); pj != fails.end(); ++pj)
53054:             pj->linkTo(masm.label(), &masm);
54847:         if (finalNull.isSet())
54847:             finalNull.get().linkTo(masm.label(), &masm);
53054:         finalShape.linkTo(masm.label(), &masm);
53054:         Label failLabel = masm.label();
53054:         Jump failJump = masm.jump();
53054: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
53054: 
58074:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58074:         }
58064: 
53054:         buffer.link(failJump, pic.slowPathStart);
56575:         buffer.link(done, pic.fastPathRejoin);
58064:         CodeLocationLabel cs = buffer.finalize();
53164:         JaegerSpew(JSpew_PICs, "generated %s call stub at %p\n", type, cs.executableAddress());
53054: 
60594:         patchPreviousToHere(cs);
53054: 
53054:         pic.stubsGenerated++;
58063:         pic.updateLastPath(buffer, failLabel);
60594:         labels.setStubJump(masm, failLabel, failJump);
53054: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
53054:             disable("max stubs reached");
53054: 
56738:         return Lookup_Cacheable;
53054:     }
53054: 
56738:     LookupStatus updateForName()
54847:     {
56738:         // |getprop.obj| is filled by bind()
56738:         LookupStatus status = getprop.bind();
56738:         if (status != Lookup_Cacheable)
56738:             return status;
54847: 
56738:         return update(getprop.obj);
54847:     }
54847: 
56738:     LookupStatus updateForXName()
54847:     {
56738:         // |obj| and |getprop.obj| are NULL, but should be the given scopeChain.
56738:         getprop.obj = scopeChain;
56738:         LookupStatus status = getprop.lookup();
56738:         if (status != Lookup_Cacheable)
56738:             return status;
54847: 
56738:         return update(getprop.obj);
54847:     }
54847: 
56738:     LookupStatus update(JSObject *obj)
53054:     {
56738:         if (obj != getprop.holder)
56735:             return disable("property is on proto of a scope object");
56735: 
56738:         if (obj->getClass() == &js_CallClass)
56738:             return generateCallStub(obj);
56735: 
56738:         LookupStatus status = getprop.testForGet();
56738:         if (status != Lookup_Cacheable)
56738:             return status;
53164: 
53164:         if (!obj->getParent())
56738:             return generateGlobalStub(obj);
53164: 
53054:         return disable("scope object not handled yet");
53054:     }
54847: 
54847:     bool retrieve(Value *vp)
54847:     {
56738:         JSObject *obj = getprop.obj;
56738:         JSObject *holder = getprop.holder;
57125:         const JSProperty *prop = getprop.prop;
56738: 
57125:         if (!prop) {
54847:             /* Kludge to allow (typeof foo == "undefined") tests. */
54847:             disable("property not found");
54847:             if (pic.kind == ic::PICInfo::NAME) {
54847:                 JSOp op2 = js_GetOpcode(cx, script, cx->regs->pc + JSOP_NAME_LENGTH);
54847:                 if (op2 == JSOP_TYPEOF) {
54847:                     vp->setUndefined();
54847:                     return true;
54847:                 }
54847:             }
54847:             ReportAtomNotDefined(cx, atom);
54847:             return false;
54847:         }
57125: 
58718:         // If the property was found, but we decided not to cache it, then
58718:         // take a slow path and do a full property fetch.
58718:         if (!getprop.shape)
58718:             return obj->getProperty(cx, ATOM_TO_JSID(atom), vp);
58718: 
57125:         const Shape *shape = getprop.shape;
54847:         JSObject *normalized = obj;
54847:         if (obj->getClass() == &js_WithClass && !shape->hasDefaultGetter())
54847:             normalized = js_UnwrapWithObject(cx, obj);
56738:         NATIVE_GET(cx, normalized, holder, shape, JSGET_METHOD_BARRIER, vp, return false);
54847: 
54847:         return true;
54847:     }
53054: };
60598:  
53055: class BindNameCompiler : public PICStubCompiler
53055: {
53055:     JSObject *scopeChain;
53055:     JSAtom *atom;
53055: 
53055:   public:
53055:     BindNameCompiler(VMFrame &f, JSScript *script, JSObject *scopeChain, ic::PICInfo &pic,
55503:                       JSAtom *atom, VoidStubPIC stub)
56738:       : PICStubCompiler("bind", f, script, pic, JS_FUNC_TO_DATA_PTR(void *, stub)),
56738:         scopeChain(scopeChain), atom(atom)
53055:     { }
53055: 
58063:     static void reset(Repatcher &repatcher, ic::PICInfo &pic)
53055:     {
60593:         BindNameLabels &labels = pic.bindNameLabels();
60593: 
60593:         /* Link the inline jump back to the slow path. */
60593:         JSC::CodeLocationJump inlineJump = labels.getInlineJump(pic.getFastShapeGuard());
60593:         repatcher.relink(inlineJump, pic.slowPathStart);
60593: 
60593:         /* Link the slow path to call the IC entry point. */
56575:         FunctionPtr target(JS_FUNC_TO_DATA_PTR(void *, ic::BindName));
58063:         repatcher.relink(pic.slowPathCall, target);
53055:     }
53055: 
60593:     void patchPreviousToHere(CodeLocationLabel cs)
60593:     {
60593:         BindNameLabels &labels = pic.bindNameLabels();
60593:         Repatcher repatcher(pic.lastCodeBlock(f.jit()));
60593:         JSC::CodeLocationJump jump;
60593:         
60593:         /* Patch either the inline fast path or a generated stub. */
60593:         if (pic.stubsGenerated)
60593:             jump = labels.getStubJump(pic.lastPathStart());
60593:         else
60593:             jump = labels.getInlineJump(pic.getFastShapeGuard());
60593:         repatcher.relink(jump, cs);
60593:     }
60593: 
56738:     LookupStatus generateStub(JSObject *obj)
53055:     {
53055:         Assembler masm;
55463:         js::Vector<Jump, 8, ContextAllocPolicy> fails(cx);
53055: 
60593:         BindNameLabels &labels = pic.bindNameLabels();
60593: 
53055:         /* Guard on the shape of the scope chain. */
53840:         masm.loadPtr(Address(JSFrameReg, JSStackFrame::offsetOfScopeChain()), pic.objReg);
53055:         masm.loadShape(pic.objReg, pic.shapeReg);
53055:         Jump firstShape = masm.branch32(Assembler::NotEqual, pic.shapeReg,
53055:                                         Imm32(scopeChain->shape()));
53055: 
53055:         /* Walk up the scope chain. */
53055:         JSObject *tobj = scopeChain;
53244:         Address parent(pic.objReg, offsetof(JSObject, parent));
53055:         while (tobj && tobj != obj) {
63085:             if (!IsCacheableNonGlobalScope(tobj))
53055:                 return disable("non-cacheable obj in scope chain");
53315:             masm.loadPtr(parent, pic.objReg);
53055:             Jump nullTest = masm.branchTestPtr(Assembler::Zero, pic.objReg, pic.objReg);
53055:             if (!fails.append(nullTest))
56738:                 return error();
53055:             masm.loadShape(pic.objReg, pic.shapeReg);
53055:             Jump shapeTest = masm.branch32(Assembler::NotEqual, pic.shapeReg,
53055:                                            Imm32(tobj->shape()));
58701:             if (!fails.append(shapeTest))
58701:                 return error();
53055:             tobj = tobj->getParent();
53055:         }
53055:         if (tobj != obj)
53055:             return disable("indirect hit");
53055: 
53055:         Jump done = masm.jump();
53055: 
53055:         // All failures flow to here, so there is a common point to patch.
53055:         for (Jump *pj = fails.begin(); pj != fails.end(); ++pj)
53055:             pj->linkTo(masm.label(), &masm);
53055:         firstShape.linkTo(masm.label(), &masm);
53055:         Label failLabel = masm.label();
53055:         Jump failJump = masm.jump();
53055: 
58064:         PICLinker buffer(masm, pic);
58064:         if (!buffer.init(cx))
56738:             return error();
53055: 
58074:         if (!buffer.verifyRange(pic.lastCodeBlock(f.jit())) ||
58074:             !buffer.verifyRange(f.jit())) {
58064:             return disable("code memory is out of range");
58074:         }
58064: 
53055:         buffer.link(failJump, pic.slowPathStart);
56575:         buffer.link(done, pic.fastPathRejoin);
58064:         CodeLocationLabel cs = buffer.finalize();
53055:         JaegerSpew(JSpew_PICs, "generated %s stub at %p\n", type, cs.executableAddress());
53055: 
60593:         patchPreviousToHere(cs);
53055: 
53055:         pic.stubsGenerated++;
58063:         pic.updateLastPath(buffer, failLabel);
60593:         labels.setStubJump(masm, failLabel, failJump);
53055: 
53344:         if (pic.stubsGenerated == MAX_PIC_STUBS)
53055:             disable("max stubs reached");
53055: 
56738:         return Lookup_Cacheable;
53055:     }
53055: 
53055:     JSObject *update()
53055:     {
53055:         JS_ASSERT(scopeChain->getParent());
53055: 
55463:         JSObject *obj = js_FindIdentifierBase(cx, scopeChain, ATOM_TO_JSID(atom));
53055:         if (!obj)
53055:             return obj;
53055: 
53055:         if (!pic.hit) {
53055:             spew("first hit", "nop");
53055:             pic.hit = true;
53055:             return obj;
53055:         }
53055: 
56738:         LookupStatus status = generateStub(obj);
56738:         if (status == Lookup_Error)
53055:             return NULL;
53055: 
53055:         return obj;
53055:     }
53055: };
60598: 
56201: static void JS_FASTCALL
56201: DisabledLengthIC(VMFrame &f, ic::PICInfo *pic)
56201: {
56201:     stubs::Length(f);
56201: }
56201: 
56201: static void JS_FASTCALL
56201: DisabledGetPropIC(VMFrame &f, ic::PICInfo *pic)
56201: {
56201:     stubs::GetProp(f);
56201: }
56201: 
56201: static void JS_FASTCALL
56201: DisabledGetPropICNoCache(VMFrame &f, ic::PICInfo *pic)
56201: {
56201:     stubs::GetPropNoCache(f, pic->atom);
56201: }
56201: 
52880: void JS_FASTCALL
55503: ic::GetProp(VMFrame &f, ic::PICInfo *pic)
52880: {
53840:     JSScript *script = f.fp()->script();
52880: 
55503:     JSAtom *atom = pic->atom;
52892:     if (atom == f.cx->runtime->atomState.lengthAtom) {
52884:         if (f.regs.sp[-1].isString()) {
56201:             GetPropCompiler cc(f, script, NULL, *pic, NULL, DisabledLengthIC);
56738:             LookupStatus status = cc.generateStringLengthStub();
56738:             if (status == Lookup_Error)
52884:                 THROW();
53081:             JSString *str = f.regs.sp[-1].toString();
52884:             f.regs.sp[-1].setInt32(str->length());
52884:             return;
52884:         } else if (!f.regs.sp[-1].isPrimitive()) {
53081:             JSObject *obj = &f.regs.sp[-1].toObject();
59970:             if (obj->isArray() || (obj->isArguments() && !obj->isArgsLengthOverridden()) ||
59970:                 obj->isString()) {
56201:                 GetPropCompiler cc(f, script, obj, *pic, NULL, DisabledLengthIC);
52884:                 if (obj->isArray()) {
56738:                     LookupStatus status = cc.generateArrayLengthStub();
56738:                     if (status == Lookup_Error)
52884:                         THROW();
52884:                     f.regs.sp[-1].setNumber(obj->getArrayLength());
53123:                 } else if (obj->isArguments()) {
56738:                     LookupStatus status = cc.generateArgsLengthStub();
56738:                     if (status == Lookup_Error)
53123:                         THROW();
53446:                     f.regs.sp[-1].setInt32(int32_t(obj->getArgsInitialLength()));
59970:                 } else if (obj->isString()) {
59970:                     LookupStatus status = cc.generateStringObjLengthStub();
59970:                     if (status == Lookup_Error)
59970:                         THROW();
59970:                     JSString *str = obj->getPrimitiveThis().toString();
59970:                     f.regs.sp[-1].setInt32(str->length());
53123:                 }
52884:                 return;
52884:             }
52884:         }
52884:         atom = f.cx->runtime->atomState.lengthAtom;
52884:     }
52880: 
52880:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52880:     if (!obj)
52880:         THROW();
52880: 
56738:     if (pic->shouldUpdate(f.cx)) {
56201:         VoidStubPIC stub = pic->usePropCache
56201:                            ? DisabledGetPropIC
56201:                            : DisabledGetPropICNoCache;
56201:         GetPropCompiler cc(f, script, obj, *pic, atom, stub);
52880:         if (!cc.update()) {
52880:             cc.disable("error");
52880:             THROW();
52880:         }
52880:     }
52880: 
52880:     Value v;
52880:     if (!obj->getProperty(f.cx, ATOM_TO_JSID(atom), &v))
52880:         THROW();
52880:     f.regs.sp[-1] = v;
52880: }
60598: 
55503: template <JSBool strict>
55503: static void JS_FASTCALL
56201: DisabledSetPropIC(VMFrame &f, ic::PICInfo *pic)
52916: {
56201:     stubs::SetName<strict>(f, pic->atom);
52916: }
52916: 
55503: template <JSBool strict>
52916: static void JS_FASTCALL
56201: DisabledSetPropICNoCache(VMFrame &f, ic::PICInfo *pic)
52887: {
56201:     stubs::SetPropNoCache<strict>(f, pic->atom);
52887: }
52887: 
52897: void JS_FASTCALL
55503: ic::SetProp(VMFrame &f, ic::PICInfo *pic)
52886: {
52887:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52887:     if (!obj)
52887:         THROW();
52887: 
53840:     JSScript *script = f.fp()->script();
55503:     JS_ASSERT(pic->isSet());
52887: 
56738:     VoidStubPIC stub = pic->usePropCache
56738:                        ? STRICT_VARIANT(DisabledSetPropIC)
56738:                        : STRICT_VARIANT(DisabledSetPropICNoCache);
56738: 
52916:     //
52887:     // Important: We update the PIC before looking up the property so that the
52887:     // PIC is updated only if the property already exists. The PIC doesn't try
52887:     // to optimize adding new properties; that is for the slow case.
52916:     //
52916:     // Also note, we can't use SetName for PROPINC PICs because the property
52916:     // cache can't handle a GET and SET from the same scripted PC.
56738:     if (pic->shouldUpdate(f.cx)) {
52916: 
55503:         SetPropCompiler cc(f, script, obj, *pic, pic->atom, stub);
56738:         LookupStatus status = cc.update();
56738:         if (status == Lookup_Error)
52887:             THROW();
52887:     }
52887:     
52887:     Value rval = f.regs.sp[-1];
55503:     stub(f, pic);
52886: }
60598: 
52896: static void JS_FASTCALL
56201: DisabledCallPropIC(VMFrame &f, ic::PICInfo *pic)
52896: {
55503:     stubs::CallProp(f, pic->atom);
52896: }
52896: 
52896: void JS_FASTCALL
55503: ic::CallProp(VMFrame &f, ic::PICInfo *pic)
52896: {
52896:     JSContext *cx = f.cx;
52896:     JSFrameRegs &regs = f.regs;
52896: 
53840:     JSScript *script = f.fp()->script();
52896: 
52896:     Value lval;
52896:     lval = regs.sp[-1];
52896: 
52896:     Value objv;
52896:     if (lval.isObject()) {
52896:         objv = lval;
52896:     } else {
52896:         JSProtoKey protoKey;
52896:         if (lval.isString()) {
52896:             protoKey = JSProto_String;
52896:         } else if (lval.isNumber()) {
52896:             protoKey = JSProto_Number;
52896:         } else if (lval.isBoolean()) {
52896:             protoKey = JSProto_Boolean;
52896:         } else {
52896:             JS_ASSERT(lval.isNull() || lval.isUndefined());
52896:             js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
52896:             THROW();
52896:         }
52896:         JSObject *pobj;
52896:         if (!js_GetClassPrototype(cx, NULL, protoKey, &pobj))
52896:             THROW();
53023:         objv.setObject(*pobj);
52896:     }
52896: 
53081:     JSObject *aobj = js_GetProtoIfDenseArray(&objv.toObject());
52896:     Value rval;
52896: 
52896:     PropertyCacheEntry *entry;
52896:     JSObject *obj2;
52896:     JSAtom *atom;
52896:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
52896:     if (!atom) {
52896:         if (entry->vword.isFunObj()) {
53023:             rval.setObject(entry->vword.toFunObj());
52896:         } else if (entry->vword.isSlot()) {
52896:             uint32 slot = entry->vword.toSlot();
56567:             rval = obj2->nativeGetSlot(slot);
52896:         } else {
53531:             JS_ASSERT(entry->vword.isShape());
53531:             const Shape *shape = entry->vword.toShape();
53531:             NATIVE_GET(cx, &objv.toObject(), obj2, shape, JSGET_NO_METHOD_BARRIER, &rval,
52896:                        THROW());
52896:         }
52896:         regs.sp++;
52896:         regs.sp[-2] = rval;
52896:         regs.sp[-1] = lval;
55713:     } else {
52896:         /*
52896:          * Cache miss: use the immediate atom that was loaded for us under
52896:          * PropertyCache::test.
52896:          */
52896:         jsid id;
55503:         id = ATOM_TO_JSID(pic->atom);
52896: 
52896:         regs.sp++;
52896:         regs.sp[-1].setNull();
52896:         if (lval.isObject()) {
53081:             if (!js_GetMethod(cx, &objv.toObject(), id,
53261:                               JS_LIKELY(!objv.toObject().getOps()->getProperty)
52896:                               ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
52896:                               : JSGET_NO_METHOD_BARRIER,
52896:                               &rval)) {
52896:                 THROW();
52896:             }
52896:             regs.sp[-1] = objv;
52896:             regs.sp[-2] = rval;
52896:         } else {
53244:             JS_ASSERT(!objv.toObject().getOps()->getProperty);
53081:             if (!js_GetPropertyHelper(cx, &objv.toObject(), id,
52896:                                       JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER,
52896:                                       &rval)) {
52896:                 THROW();
52896:             }
52896:             regs.sp[-1] = lval;
52896:             regs.sp[-2] = rval;
52896:         }
52896:     }
52896: 
56201:     GetPropCompiler cc(f, script, &objv.toObject(), *pic, pic->atom, DisabledCallPropIC);
52907:     if (lval.isObject()) {
56738:         if (pic->shouldUpdate(cx)) {
56738:             LookupStatus status = cc.update();
56738:             if (status == Lookup_Error)
52896:                 THROW();
52896:         }
52907:     } else if (lval.isString()) {
56738:         LookupStatus status = cc.generateStringCallStub();
56738:         if (status == Lookup_Error)
52907:             THROW();
52906:     } else {
52907:         cc.disable("non-string primitive");
52896:     }
52896: 
52896: #if JS_HAS_NO_SUCH_METHOD
55713:     if (JS_UNLIKELY(rval.isUndefined()) && regs.sp[-1].isObject()) {
64345:         regs.sp[-2].setString(pic->atom);
52896:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
52896:             THROW();
52896:     }
52896: #endif
52896: }
60598: 
53054: static void JS_FASTCALL
56201: DisabledNameIC(VMFrame &f, ic::PICInfo *pic)
53054: {
53054:     stubs::Name(f);
53054: }
53054: 
54847: static void JS_FASTCALL
56201: DisabledXNameIC(VMFrame &f, ic::PICInfo *pic)
54847: {
54847:     stubs::GetProp(f);
54847: }
54847: 
54847: void JS_FASTCALL
55503: ic::XName(VMFrame &f, ic::PICInfo *pic)
54847: {
54847:     JSScript *script = f.fp()->script();
54847: 
54847:     /* GETXPROP is guaranteed to have an object. */
54847:     JSObject *obj = &f.regs.sp[-1].toObject();
54847: 
56201:     ScopeNameCompiler cc(f, script, obj, *pic, pic->atom, DisabledXNameIC);
54847: 
56738:     LookupStatus status = cc.updateForXName();
56738:     if (status == Lookup_Error)
54847:         THROW();
54847: 
54847:     Value rval;
54847:     if (!cc.retrieve(&rval))
54847:         THROW();
54847:     f.regs.sp[-1] = rval;
54847: }
54847: 
53109: void JS_FASTCALL
55503: ic::Name(VMFrame &f, ic::PICInfo *pic)
53054: {
53840:     JSScript *script = f.fp()->script();
53054: 
56201:     ScopeNameCompiler cc(f, script, &f.fp()->scopeChain(), *pic, pic->atom, DisabledNameIC);
53054: 
56738:     LookupStatus status = cc.updateForName();
56738:     if (status == Lookup_Error)
53054:         THROW();
53054: 
53054:     Value rval;
54847:     if (!cc.retrieve(&rval))
53054:         THROW();
53054:     f.regs.sp[0] = rval;
53054: }
60598: 
53055: static void JS_FASTCALL
56201: DisabledBindNameIC(VMFrame &f, ic::PICInfo *pic)
53055: {
53055:     stubs::BindName(f);
53055: }
53055: 
56201: static void JS_FASTCALL
56201: DisabledBindNameICNoCache(VMFrame &f, ic::PICInfo *pic)
56201: {
56201:     stubs::BindNameNoCache(f, pic->atom);
56201: }
56201: 
53055: void JS_FASTCALL
55503: ic::BindName(VMFrame &f, ic::PICInfo *pic)
53055: {
53840:     JSScript *script = f.fp()->script();
53055: 
56201:     VoidStubPIC stub = pic->usePropCache
56201:                        ? DisabledBindNameIC
56201:                        : DisabledBindNameICNoCache;
56201:     BindNameCompiler cc(f, script, &f.fp()->scopeChain(), *pic, pic->atom, stub);
53055: 
53055:     JSObject *obj = cc.update();
53055:     if (!obj) {
53055:         cc.disable("error");
53055:         THROW();
53055:     }
53055: 
53055:     f.regs.sp[0].setObject(*obj);
53055: }
53055: 
56738: bool
56738: BaseIC::isCallOp()
56738: {
56738:     return !!(js_CodeSpec[op].format & JOF_CALLOP);
56738: }
56738: 
56738: void
56738: BaseIC::spew(JSContext *cx, const char *event, const char *message)
56738: {
56738: #ifdef JS_METHODJIT_SPEW
56738:     JaegerSpew(JSpew_PICs, "%s %s: %s (%s: %d)\n",
56738:                js_CodeName[op], event, message, cx->fp()->script()->filename,
56738:                js_FramePCToLineNumber(cx, cx->fp()));
56738: #endif
56738: }
56738: 
56738: LookupStatus
56738: BaseIC::disable(JSContext *cx, const char *reason, void *stub)
56738: {
56738:     spew(cx, "disabled", reason);
58063:     Repatcher repatcher(cx->fp()->jit());
56738:     repatcher.relink(slowPathCall, FunctionPtr(stub));
56738:     return Lookup_Uncacheable;
56738: }
56738: 
56738: bool
56738: BaseIC::shouldUpdate(JSContext *cx)
56738: {
56738:     if (!hit) {
56738:         hit = true;
56738:         spew(cx, "ignored", "first hit");
56738:         return false;
56738:     }
56738:     JS_ASSERT(stubsGenerated < MAX_PIC_STUBS);
56738:     return true;
56738: }
56738: 
56738: static void JS_FASTCALL
56738: DisabledGetElem(VMFrame &f, ic::GetElementIC *ic)
56738: {
56738:     stubs::GetElem(f);
56738: }
56738: 
57723: static void JS_FASTCALL
57723: DisabledCallElem(VMFrame &f, ic::GetElementIC *ic)
57723: {
57723:     stubs::CallElem(f);
57723: }
57723: 
56738: bool
56738: GetElementIC::shouldUpdate(JSContext *cx)
56738: {
56738:     if (!hit) {
56738:         hit = true;
56738:         spew(cx, "ignored", "first hit");
56738:         return false;
56738:     }
56738:     JS_ASSERT(stubsGenerated < MAX_GETELEM_IC_STUBS);
56738:     return true;
56738: }
56738: 
56738: LookupStatus
56738: GetElementIC::disable(JSContext *cx, const char *reason)
56738: {
56738:     slowCallPatched = true;
57723:     void *stub = (op == JSOP_GETELEM)
57723:                  ? JS_FUNC_TO_DATA_PTR(void *, DisabledGetElem)
57723:                  : JS_FUNC_TO_DATA_PTR(void *, DisabledCallElem);
57723:     BaseIC::disable(cx, reason, stub);
56738:     return Lookup_Uncacheable;
56738: }
56738: 
56738: LookupStatus
56738: GetElementIC::error(JSContext *cx)
56738: {
56738:     disable(cx, "error");
56738:     return Lookup_Error;
56738: }
56738: 
56738: void
58063: GetElementIC::purge(Repatcher &repatcher)
56738: {
56738:     // Repatch the inline jumps.
56738:     if (inlineTypeGuardPatched)
56738:         repatcher.relink(fastPathStart.jumpAtOffset(inlineTypeGuard), slowPathStart);
56738:     if (inlineClaspGuardPatched)
56738:         repatcher.relink(fastPathStart.jumpAtOffset(inlineClaspGuard), slowPathStart);
56738: 
56738:     if (slowCallPatched) {
60597:         if (op == JSOP_GETELEM) {
60597:             repatcher.relink(slowPathCall,
60597:                              FunctionPtr(JS_FUNC_TO_DATA_PTR(void *, ic::GetElement)));
60597:         } else if (op == JSOP_CALLELEM) {
60597:             repatcher.relink(slowPathCall,
60597:                              FunctionPtr(JS_FUNC_TO_DATA_PTR(void *, ic::CallElement)));
60597:         }
56738:     }
56738: 
56738:     reset();
56738: }
56738: 
56738: LookupStatus
56738: GetElementIC::attachGetProp(JSContext *cx, JSObject *obj, const Value &v, jsid id, Value *vp)
56738: {
56738:     JS_ASSERT(v.isString());
56738: 
56738:     GetPropertyHelper<GetElementIC> getprop(cx, obj, JSID_TO_ATOM(id), *this);
56738:     LookupStatus status = getprop.lookupAndTest();
56738:     if (status != Lookup_Cacheable)
56738:         return status;
56738: 
56738:     Assembler masm;
56738: 
56738:     // Guard on the string's type and identity.
56738:     MaybeJump atomTypeGuard;
56738:     if (hasInlineTypeGuard() && !inlineTypeGuardPatched) {
56738:         // We link all string-key dependent stubs together, and store the
56738:         // first set of guards in the IC, separately, from int-key dependent
56738:         // stubs. As long as we guarantee that the first string-key dependent
56738:         // stub guards on the key type, then all other string-key stubs can
56738:         // omit the guard.
56738:         JS_ASSERT(!idRemat.isTypeKnown());
56738:         atomTypeGuard = masm.testString(Assembler::NotEqual, typeReg);
56738:     } else {
56738:         // If there was no inline type guard, then a string type is guaranteed.
56738:         // Otherwise, we are guaranteed the type has already been checked, via
56738:         // the comment above.
56738:         JS_ASSERT_IF(!hasInlineTypeGuard(), idRemat.knownType() == JSVAL_TYPE_STRING);
56738:     }
56738: 
56738:     // Reify the shape before guards that could flow into shape guarding stubs.
56738:     if (!obj->isDenseArray() && !typeRegHasBaseShape) {
56738:         masm.loadShape(objReg, typeReg);
56738:         typeRegHasBaseShape = true;
56738:     }
56738: 
56738:     MaybeJump atomIdGuard;
56738:     if (!idRemat.isConstant())
56738:         atomIdGuard = masm.branchPtr(Assembler::NotEqual, idRemat.dataReg(), ImmPtr(v.toString()));
56738: 
56738:     // Guard on the base shape (or in the dense array case, the clasp).
56738:     Jump shapeGuard;
56738:     if (obj->isDenseArray()) {
56738:         shapeGuard = masm.testObjClass(Assembler::NotEqual, objReg, obj->getClass());
56738:     } else {
56738:         shapeGuard = masm.branch32(Assembler::NotEqual, typeReg, Imm32(obj->shape()));
56738:     }
56738: 
56738:     // Guard on the prototype, if applicable.
56738:     MaybeJump protoGuard;
56738:     JSObject *holder = getprop.holder;
56738:     RegisterID holderReg = objReg;
56738:     if (obj != holder) {
56738:         // Bake in the holder identity. Careful not to clobber |objReg|, since we can't remat it.
56738:         holderReg = typeReg;
56738:         masm.move(ImmPtr(holder), holderReg);
56738:         typeRegHasBaseShape = false;
56738: 
56738:         // Guard on the holder's shape.
56738:         protoGuard = masm.guardShape(holderReg, holder);
56738:     }
56738: 
57723:     if (op == JSOP_CALLELEM) {
57723:         // Emit a write of |obj| to the top of the stack, before we lose it.
57723:         Value *thisVp = &cx->regs->sp[-1];
57723:         Address thisSlot(JSFrameReg, JSStackFrame::offsetOfFixed(thisVp - cx->fp()->slots()));
57723:         masm.storeValueFromComponents(ImmType(JSVAL_TYPE_OBJECT), objReg, thisSlot);
57723:     }
57723: 
56738:     // Load the value.
56738:     const Shape *shape = getprop.shape;
56738:     masm.loadObjProp(holder, holderReg, shape, typeReg, objReg);
56738: 
56738:     Jump done = masm.jump();
56738: 
58064:     PICLinker buffer(masm, *this);
58064:     if (!buffer.init(cx))
56738:         return error(cx);
56738: 
58064:     if (hasLastStringStub && !buffer.verifyRange(lastStringStub))
58064:         return disable(cx, "code memory is out of range");
58119:     if (!buffer.verifyRange(cx->fp()->jit()))
58064:         return disable(cx, "code memory is out of range");
58064: 
56738:     // Patch all guards.
56738:     buffer.maybeLink(atomIdGuard, slowPathStart);
56738:     buffer.maybeLink(atomTypeGuard, slowPathStart);
56738:     buffer.link(shapeGuard, slowPathStart);
56738:     buffer.maybeLink(protoGuard, slowPathStart);
56738:     buffer.link(done, fastPathRejoin);
56738: 
58064:     CodeLocationLabel cs = buffer.finalize();
56738: #if DEBUG
64345:     char *chars = js_DeflateString(cx, v.toString()->getChars(cx), v.toString()->length());
57723:     JaegerSpew(JSpew_PICs, "generated %s stub at %p for atom 0x%x (\"%s\") shape 0x%x (%s: %d)\n",
57723:                js_CodeName[op], cs.executableAddress(), id, chars, holder->shape(),
57723:                cx->fp()->script()->filename, js_FramePCToLineNumber(cx, cx->fp()));
56738:     cx->free(chars);
56738: #endif
56738: 
56738:     // Update the inline guards, if needed.
56738:     if (shouldPatchInlineTypeGuard() || shouldPatchUnconditionalClaspGuard()) {
58063:         Repatcher repatcher(cx->fp()->jit());
56738: 
56738:         if (shouldPatchInlineTypeGuard()) {
56738:             // A type guard is present in the inline path, and this is the
56738:             // first string stub, so patch it now.
56738:             JS_ASSERT(!inlineTypeGuardPatched);
56738:             JS_ASSERT(atomTypeGuard.isSet());
56738: 
58063:             repatcher.relink(fastPathStart.jumpAtOffset(inlineTypeGuard), cs);
56738:             inlineTypeGuardPatched = true;
56738:         }
56738: 
56738:         if (shouldPatchUnconditionalClaspGuard()) {
56738:             // The clasp guard is unconditional, meaning there is no type
56738:             // check. This is the first stub, so it has to be patched. Note
56738:             // that it is wrong to patch the inline clasp guard otherwise,
56738:             // because it follows an integer-id guard.
56738:             JS_ASSERT(!hasInlineTypeGuard());
56738: 
58063:             repatcher.relink(fastPathStart.jumpAtOffset(inlineClaspGuard), cs);
56738:             inlineClaspGuardPatched = true;
56738:         }
56738:     }
56738: 
56738:     // If there were previous stub guards, patch them now.
56738:     if (hasLastStringStub) {
58063:         Repatcher repatcher(lastStringStub);
58063:         CodeLocationLabel stub(lastStringStub.start());
56738:         if (atomGuard)
58063:             repatcher.relink(stub.jumpAtOffset(atomGuard), cs);
58063:         repatcher.relink(stub.jumpAtOffset(firstShapeGuard), cs);
56738:         if (secondShapeGuard)
58063:             repatcher.relink(stub.jumpAtOffset(secondShapeGuard), cs);
56738:     }
56738: 
56738:     // Update state.
56738:     hasLastStringStub = true;
58063:     lastStringStub = JITCode(cs.executableAddress(), buffer.size());
56738:     if (atomIdGuard.isSet()) {
56738:         atomGuard = buffer.locationOf(atomIdGuard.get()) - cs;
56738:         JS_ASSERT(atomGuard == buffer.locationOf(atomIdGuard.get()) - cs);
56738:         JS_ASSERT(atomGuard);
56738:     } else {
56738:         atomGuard = 0;
56738:     }
56738:     if (protoGuard.isSet()) {
56738:         secondShapeGuard = buffer.locationOf(protoGuard.get()) - cs;
56738:         JS_ASSERT(secondShapeGuard == buffer.locationOf(protoGuard.get()) - cs);
56738:         JS_ASSERT(secondShapeGuard);
56738:     } else {
56738:         secondShapeGuard = 0;
56738:     }
56738:     firstShapeGuard = buffer.locationOf(shapeGuard) - cs;
56738:     JS_ASSERT(firstShapeGuard == buffer.locationOf(shapeGuard) - cs);
56738:     JS_ASSERT(firstShapeGuard);
56738: 
56738:     stubsGenerated++;
56738: 
56738:     if (stubsGenerated == MAX_GETELEM_IC_STUBS)
56738:         disable(cx, "max stubs reached");
56738: 
56738:     // Finally, fetch the value to avoid redoing the property lookup.
56738:     if (shape->isMethod())
56738:         *vp = ObjectValue(shape->methodObject());
56738:     else
56738:         *vp = holder->getSlot(shape->slot);
56738: 
56738:     return Lookup_Cacheable;
56738: }
56738: 
60598: #if defined JS_POLYIC_TYPED_ARRAY
56738: LookupStatus
60164: GetElementIC::attachTypedArray(JSContext *cx, JSObject *obj, const Value &v, jsid id, Value *vp)
60164: {
60164:     if (!v.isInt32())
60164:         return disable(cx, "typed array with string key");
60164: 
60164:     if (op == JSOP_CALLELEM)
60164:         return disable(cx, "typed array with call");
60164: 
60164:     // The fast-path guarantees that after the dense clasp guard, the type is
60164:     // known to be int32, either via type inference or the inline type check.
60164:     JS_ASSERT(hasInlineTypeGuard() || idRemat.knownType() == JSVAL_TYPE_INT32);
60164: 
60164:     Assembler masm;
60164: 
60164:     // Guard on this typed array's clasp.
60164:     Jump claspGuard = masm.testObjClass(Assembler::NotEqual, objReg, obj->getClass());
60164: 
60164:     // Get the internal typed array.
60164:     masm.loadPtr(Address(objReg, offsetof(JSObject, privateData)), objReg);
60164: 
60164:     // Bounds check.
60164:     Jump outOfBounds;
60164:     Address typedArrayLength(objReg, js::TypedArray::lengthOffset());
60164:     if (idRemat.isConstant()) {
60164:         JS_ASSERT(idRemat.value().toInt32() == v.toInt32());
60164:         outOfBounds = masm.branch32(Assembler::BelowOrEqual, typedArrayLength, Imm32(v.toInt32()));
60164:     } else {
60164:         outOfBounds = masm.branch32(Assembler::BelowOrEqual, typedArrayLength, idRemat.dataReg());
60164:     }
60164: 
60164:     // Load the array's packed data vector.
60164:     masm.loadPtr(Address(objReg, js::TypedArray::dataOffset()), objReg);
60164: 
60164:     js::TypedArray *tarray = js::TypedArray::fromJSObject(obj);
60164:     int shift = tarray->slotWidth();
60164:     if (idRemat.isConstant()) {
60164:         int32 index = v.toInt32();
60164:         Address addr(objReg, index * shift);
60164:         LoadFromTypedArray(masm, tarray, addr, typeReg, objReg);
60164:     } else {
60164:         Assembler::Scale scale = Assembler::TimesOne;
60164:         switch (shift) {
60164:           case 2:
60164:             scale = Assembler::TimesTwo;
60164:             break;
60164:           case 4:
60164:             scale = Assembler::TimesFour;
60164:             break;
60164:           case 8:
60164:             scale = Assembler::TimesEight;
60164:             break;
60164:         }
60164:         BaseIndex addr(objReg, idRemat.dataReg(), scale);
60164:         LoadFromTypedArray(masm, tarray, addr, typeReg, objReg);
60164:     }
60164: 
64382:     Jump done = masm.jump();
60164: 
60164:     PICLinker buffer(masm, *this);
60164:     if (!buffer.init(cx))
60164:         return error(cx);
60164: 
60164:     if (!buffer.verifyRange(cx->fp()->jit()))
60164:         return disable(cx, "code memory is out of range");
60164: 
60164:     buffer.link(claspGuard, slowPathStart);
64382:     buffer.link(outOfBounds, slowPathStart);
64382:     buffer.link(done, fastPathRejoin);
60164: 
60164:     CodeLocationLabel cs = buffer.finalizeCodeAddendum();
60164:     JaegerSpew(JSpew_PICs, "generated getelem typed array stub at %p\n", cs.executableAddress());
60164: 
60164:     // If we can generate a typed array stub, the clasp guard is conditional.
60164:     // Also, we only support one typed array.
60164:     JS_ASSERT(!shouldPatchUnconditionalClaspGuard());
60164:     JS_ASSERT(!inlineClaspGuardPatched);
60164: 
60164:     Repatcher repatcher(cx->fp()->jit());
60164:     repatcher.relink(fastPathStart.jumpAtOffset(inlineClaspGuard), cs);
60164:     inlineClaspGuardPatched = true;
60164: 
60164:     stubsGenerated++;
60164: 
60164:     // In the future, it might make sense to attach multiple typed array stubs.
60164:     // For simplicitly, they are currently monomorphic.
60164:     if (stubsGenerated == MAX_GETELEM_IC_STUBS)
60164:         disable(cx, "max stubs reached");
60164: 
60164:     disable(cx, "generated typed array stub");
60164: 
60164:     // Fetch the value as expected of Lookup_Cacheable for GetElement.
60164:     if (!obj->getProperty(cx, id, vp))
60164:         return Lookup_Error;
60164: 
60164:     return Lookup_Cacheable;
60164: }
60598: #endif /* JS_POLYIC_TYPED_ARRAY */
60164: 
60164: LookupStatus
56738: GetElementIC::update(JSContext *cx, JSObject *obj, const Value &v, jsid id, Value *vp)
56738: {
56738:     if (v.isString())
56738:         return attachGetProp(cx, obj, v, id, vp);
60164: 
60598: #if defined JS_POLYIC_TYPED_ARRAY
60164:     if (js_IsTypedArray(obj))
60164:         return attachTypedArray(cx, obj, v, id, vp);
60598: #endif
60164: 
56738:     return disable(cx, "unhandled object and key type");
56738: }
56738: 
56738: void JS_FASTCALL
57723: ic::CallElement(VMFrame &f, ic::GetElementIC *ic)
57723: {
57723:     JSContext *cx = f.cx;
57723: 
57723:     // Right now, we don't optimize for strings.
57723:     if (!f.regs.sp[-2].isObject()) {
57723:         ic->disable(cx, "non-object");
57723:         stubs::CallElem(f);
57723:         return;
57723:     }
57723: 
57723:     Value thisv = f.regs.sp[-2];
57723:     JSObject *thisObj = ValuePropertyBearer(cx, thisv, -2);
57723:     if (!thisObj)
57723:         THROW();
57723: 
57723:     jsid id;
57723:     Value idval = f.regs.sp[-1];
57723:     if (idval.isInt32() && INT_FITS_IN_JSID(idval.toInt32()))
57723:         id = INT_TO_JSID(idval.toInt32());
57723:     else if (!js_InternNonIntElementId(cx, thisObj, idval, &id))
57723:         THROW();
57723: 
57723:     if (ic->shouldUpdate(cx)) {
57723: #ifdef DEBUG
57723:         f.regs.sp[-2] = MagicValue(JS_GENERIC_MAGIC);
57723: #endif
57723:         LookupStatus status = ic->update(cx, thisObj, idval, id, &f.regs.sp[-2]);
57723:         if (status != Lookup_Uncacheable) {
57723:             if (status == Lookup_Error)
57723:                 THROW();
57723: 
57723:             // If the result can be cached, the value was already retrieved.
57723:             JS_ASSERT(!f.regs.sp[-2].isMagic());
57723:             f.regs.sp[-1].setObject(*thisObj);
57723:             return;
57723:         }
57723:     }
57723: 
57723:     /* Get or set the element. */
57723:     if (!js_GetMethod(cx, thisObj, id, JSGET_NO_METHOD_BARRIER, &f.regs.sp[-2]))
57723:         THROW();
57723: 
57723: #if JS_HAS_NO_SUCH_METHOD
57723:     if (JS_UNLIKELY(f.regs.sp[-2].isUndefined()) && thisv.isObject()) {
57723:         f.regs.sp[-2] = f.regs.sp[-1];
57723:         f.regs.sp[-1].setObject(*thisObj);
57723:         if (!js_OnUnknownMethod(cx, f.regs.sp - 2))
57723:             THROW();
57723:     } else
57723: #endif
57723:     {
57723:         f.regs.sp[-1] = thisv;
57723:     }
57723: }
57723: 
57723: void JS_FASTCALL
56738: ic::GetElement(VMFrame &f, ic::GetElementIC *ic)
56738: {
56738:     JSContext *cx = f.cx;
56738: 
56738:     // Right now, we don't optimize for strings.
56738:     if (!f.regs.sp[-2].isObject()) {
56738:         ic->disable(cx, "non-object");
56738:         stubs::GetElem(f);
56738:         return;
56738:     }
56738: 
56738:     JSObject *obj = ValueToObject(cx, &f.regs.sp[-2]);
56738:     if (!obj)
56738:         THROW();
56738: 
56738:     Value idval = f.regs.sp[-1];
56738: 
56738:     jsid id;
56738:     if (idval.isInt32() && INT_FITS_IN_JSID(idval.toInt32())) {
56738:         id = INT_TO_JSID(idval.toInt32());
56738:     } else {
56738:         if (!js_InternNonIntElementId(cx, obj, idval, &id))
56738:             THROW();
56738:     }
56738: 
56738:     if (ic->shouldUpdate(cx)) {
56738: #ifdef DEBUG
56738:         f.regs.sp[-2] = MagicValue(JS_GENERIC_MAGIC);
56738: #endif
56738:         LookupStatus status = ic->update(cx, obj, idval, id, &f.regs.sp[-2]);
56738:         if (status != Lookup_Uncacheable) {
56738:             if (status == Lookup_Error)
56738:                 THROW();
56738: 
56738:             // If the result can be cached, the value was already retrieved.
56738:             JS_ASSERT(!f.regs.sp[-2].isMagic());
56738:             return;
56738:         }
56738:     }
56738: 
56738:     if (!obj->getProperty(cx, id, &f.regs.sp[-2]))
56738:         THROW();
56738: }
60598: 
57671: #define APPLY_STRICTNESS(f, s)                          \
57671:     (FunctionTemplateConditional(s, f<true>, f<false>))
57671: 
57671: LookupStatus
57671: SetElementIC::disable(JSContext *cx, const char *reason)
57671: {
57671:     slowCallPatched = true;
57671:     VoidStub stub = APPLY_STRICTNESS(stubs::SetElem, strictMode);
57671:     BaseIC::disable(cx, reason, JS_FUNC_TO_DATA_PTR(void *, stub));
57671:     return Lookup_Uncacheable;
57671: }
57671: 
57671: LookupStatus
57671: SetElementIC::error(JSContext *cx)
57671: {
57671:     disable(cx, "error");
57671:     return Lookup_Error;
57671: }
57671: 
57671: void
58063: SetElementIC::purge(Repatcher &repatcher)
57671: {
57671:     // Repatch the inline jumps.
57671:     if (inlineClaspGuardPatched)
57671:         repatcher.relink(fastPathStart.jumpAtOffset(inlineClaspGuard), slowPathStart);
57671:     if (inlineHoleGuardPatched)
57671:         repatcher.relink(fastPathStart.jumpAtOffset(inlineHoleGuard), slowPathStart);
57671: 
57671:     if (slowCallPatched) {
57671:         void *stub = JS_FUNC_TO_DATA_PTR(void *, APPLY_STRICTNESS(ic::SetElement, strictMode));
57671:         repatcher.relink(slowPathCall, FunctionPtr(stub));
57671:     }
57671: 
57671:     reset();
57671: }
57671: 
57671: LookupStatus
57671: SetElementIC::attachHoleStub(JSContext *cx, JSObject *obj, int32 keyval)
57671: {
57671:     if (keyval < 0)
57671:         return disable(cx, "negative key index");
57671: 
57671:     // We may have failed a capacity check instead of a dense array check.
57671:     // However we should still build the IC in this case, since it could
57671:     // be in a loop that is filling in the array. We can assert, however,
57671:     // that either we're in capacity or there's a hole - guaranteed by
57671:     // the fast path.
57671:     JS_ASSERT((jsuint)keyval >= obj->getDenseArrayCapacity() ||
57671:               obj->getDenseArrayElement(keyval).isMagic(JS_ARRAY_HOLE));
57671: 
57671:     if (js_PrototypeHasIndexedProperties(cx, obj))
57671:         return disable(cx, "prototype has indexed properties");
57671: 
57671:     Assembler masm;
57671: 
58694:     Vector<Jump, 4> fails(cx);
58694: 
58694:     // Test for indexed properties in Array.prototype. We test each shape
58694:     // along the proto chain. This affords us two optimizations:
58694:     //  1) Loading the prototype can be avoided because the shape would change;
58694:     //     instead we can bake in their identities.
58694:     //  2) We only have to test the shape, rather than INDEXED.
58694:     for (JSObject *pobj = obj->getProto(); pobj; pobj = pobj->getProto()) {
58694:         if (!pobj->isNative())
58694:             return disable(cx, "non-native array prototype");
58694:         masm.move(ImmPtr(pobj), objReg);
58694:         Jump j = masm.guardShape(objReg, pobj);
58694:         if (!fails.append(j))
58694:             return error(cx);
58694:     }
57671: 
57671:     // Restore |obj|.
57671:     masm.rematPayload(StateRemat::FromInt32(objRemat), objReg);
57671: 
57671:     // Guard against negative indices.
57671:     MaybeJump keyGuard;
57671:     if (!hasConstantKey)
57671:         keyGuard = masm.branch32(Assembler::LessThan, keyReg, Imm32(0));
57671: 
57671:     // Update the array length if necessary.
57671:     Jump skipUpdate;
57671:     Address arrayLength(objReg, offsetof(JSObject, privateData));
57671:     if (hasConstantKey) {
57671:         skipUpdate = masm.branch32(Assembler::Above, arrayLength, Imm32(keyValue));
57671:         masm.store32(Imm32(keyValue + 1), arrayLength);
57671:     } else {
57671:         skipUpdate = masm.branch32(Assembler::Above, arrayLength, keyReg);
57671:         masm.add32(Imm32(1), keyReg);
57671:         masm.store32(keyReg, arrayLength);
57671:         masm.sub32(Imm32(1), keyReg);
57671:     }
57671:     skipUpdate.linkTo(masm.label(), &masm);
57671: 
57671:     // Store the value back.
57671:     masm.loadPtr(Address(objReg, offsetof(JSObject, slots)), objReg);
57671:     if (hasConstantKey) {
57671:         Address slot(objReg, keyValue * sizeof(Value));
57671:         masm.storeValue(vr, slot);
57671:     } else {
57671:         BaseIndex slot(objReg, keyReg, Assembler::JSVAL_SCALE);
57671:         masm.storeValue(vr, slot);
57671:     }
57671: 
57671:     Jump done = masm.jump();
57671: 
57671:     JS_ASSERT(!execPool);
57671:     JS_ASSERT(!inlineHoleGuardPatched);
57671: 
58064:     LinkerHelper buffer(masm);
58064:     execPool = buffer.init(cx);
57671:     if (!execPool)
57671:         return error(cx);
57671: 
58064:     if (!buffer.verifyRange(cx->fp()->jit()))
58064:         return disable(cx, "code memory is out of range");
58064: 
57671:     // Patch all guards.
58694:     for (size_t i = 0; i < fails.length(); i++)
58694:         buffer.link(fails[i], slowPathStart);
57671:     buffer.link(done, fastPathRejoin);
57671: 
58064:     CodeLocationLabel cs = buffer.finalize();
57671:     JaegerSpew(JSpew_PICs, "generated dense array hole stub at %p\n", cs.executableAddress());
57671: 
58063:     Repatcher repatcher(cx->fp()->jit());
58063:     repatcher.relink(fastPathStart.jumpAtOffset(inlineHoleGuard), cs);
57671:     inlineHoleGuardPatched = true;
57671: 
57671:     disable(cx, "generated dense array hole stub");
57671: 
57671:     return Lookup_Cacheable;
57671: }
57671: 
60598: #if defined JS_POLYIC_TYPED_ARRAY
57671: LookupStatus
60164: SetElementIC::attachTypedArray(JSContext *cx, JSObject *obj, int32 key)
60164: {
60164:     // Right now, only one clasp guard extension is supported.
60164:     JS_ASSERT(!inlineClaspGuardPatched);
60164: 
60164:     Assembler masm;
60164: 
60164:     // Guard on this typed array's clasp.
60164:     Jump claspGuard = masm.testObjClass(Assembler::NotEqual, objReg, obj->getClass());
60164: 
60164:     // Get the internal typed array.
60164:     masm.loadPtr(Address(objReg, offsetof(JSObject, privateData)), objReg);
60164: 
60164:     // Bounds check.
60164:     Jump outOfBounds;
60164:     Address typedArrayLength(objReg, js::TypedArray::lengthOffset());
60164:     if (hasConstantKey)
60164:         outOfBounds = masm.branch32(Assembler::BelowOrEqual, typedArrayLength, Imm32(keyValue));
60164:     else
60164:         outOfBounds = masm.branch32(Assembler::BelowOrEqual, typedArrayLength, keyReg);
60164: 
60164:     // Load the array's packed data vector.
60164:     js::TypedArray *tarray = js::TypedArray::fromJSObject(obj);
60164:     masm.loadPtr(Address(objReg, js::TypedArray::dataOffset()), objReg);
60164: 
60164:     int shift = tarray->slotWidth();
60164:     if (hasConstantKey) {
60164:         Address addr(objReg, keyValue * shift);
60164:         if (!StoreToTypedArray(cx, masm, tarray, addr, vr, volatileMask))
60164:             return error(cx);
60164:     } else {
60164:         Assembler::Scale scale = Assembler::TimesOne;
60164:         switch (shift) {
60164:           case 2:
60164:             scale = Assembler::TimesTwo;
60164:             break;
60164:           case 4:
60164:             scale = Assembler::TimesFour;
60164:             break;
60164:           case 8:
60164:             scale = Assembler::TimesEight;
60164:             break;
60164:         }
60164:         BaseIndex addr(objReg, keyReg, scale);
60164:         if (!StoreToTypedArray(cx, masm, tarray, addr, vr, volatileMask))
60164:             return error(cx);
60164:     }
60164: 
60164:     Jump done = masm.jump();
60164: 
60164:     // The stub does not rely on any pointers or numbers that could be ruined
60164:     // by a GC or shape regenerated GC. We let this stub live for the lifetime
60164:     // of the script.
60164:     JS_ASSERT(!execPool);
60164:     LinkerHelper buffer(masm);
60164:     execPool = buffer.init(cx);
60164:     if (!execPool)
60164:         return error(cx);
60164: 
60164:     if (!buffer.verifyRange(cx->fp()->jit()))
60164:         return disable(cx, "code memory is out of range");
60164: 
60164:     // Note that the out-of-bounds path simply does nothing.
60164:     buffer.link(claspGuard, slowPathStart);
60164:     buffer.link(outOfBounds, fastPathRejoin);
60164:     buffer.link(done, fastPathRejoin);
60164:     masm.finalize(buffer);
60164: 
60164:     CodeLocationLabel cs = buffer.finalizeCodeAddendum();
60164:     JaegerSpew(JSpew_PICs, "generated setelem typed array stub at %p\n", cs.executableAddress());
60164: 
60164:     Repatcher repatcher(cx->fp()->jit());
60164:     repatcher.relink(fastPathStart.jumpAtOffset(inlineClaspGuard), cs);
60164:     inlineClaspGuardPatched = true;
60164: 
60164:     stubsGenerated++;
60164: 
60164:     // In the future, it might make sense to attach multiple typed array stubs.
60164:     // For simplicitly, they are currently monomorphic.
60164:     if (stubsGenerated == MAX_GETELEM_IC_STUBS)
60164:         disable(cx, "max stubs reached");
60164: 
60164:     disable(cx, "generated typed array stub");
60164: 
60164:     return Lookup_Cacheable;
60164: }
60598: #endif /* JS_POLYIC_TYPED_ARRAY */
60164: 
60164: LookupStatus
57671: SetElementIC::update(JSContext *cx, const Value &objval, const Value &idval)
57671: {
57671:     if (!objval.isObject())
57671:         return disable(cx, "primitive lval");
57671:     if (!idval.isInt32())
57671:         return disable(cx, "non-int32 key");
57671: 
57671:     JSObject *obj = &objval.toObject();
57671:     int32 key = idval.toInt32();
57671: 
57671:     if (obj->isDenseArray())
57671:         return attachHoleStub(cx, obj, key);
57671: 
60598: #if defined JS_POLYIC_TYPED_ARRAY
60164:     if (js_IsTypedArray(obj))
60164:         return attachTypedArray(cx, obj, key);
60598: #endif
60164: 
57671:     return disable(cx, "unsupported object type");
57671: }
57671: 
57671: template<JSBool strict>
57672: void JS_FASTCALL
57671: ic::SetElement(VMFrame &f, ic::SetElementIC *ic)
57671: {
57671:     JSContext *cx = f.cx;
57671: 
57671:     if (ic->shouldUpdate(cx)) {
57671:         LookupStatus status = ic->update(cx, f.regs.sp[-3], f.regs.sp[-2]);
57671:         if (status == Lookup_Error)
57671:             THROW();
57671:     }
57671: 
57671:     stubs::SetElem<strict>(f);
57671: }
57671: 
57671: template void JS_FASTCALL ic::SetElement<true>(VMFrame &f, SetElementIC *ic);
57671: template void JS_FASTCALL ic::SetElement<false>(VMFrame &f, SetElementIC *ic);
57671: 
53083: void
55503: JITScript::purgePICs()
52880: {
58063:     if (!nPICs && !nGetElems && !nSetElems)
58063:         return;
58063: 
58063:     Repatcher repatcher(this);
58063: 
62075:     ic::PICInfo *pics_ = pics();
55503:     for (uint32 i = 0; i < nPICs; i++) {
62075:         ic::PICInfo &pic = pics_[i];
53055:         switch (pic.kind) {
53055:           case ic::PICInfo::SET:
53620:           case ic::PICInfo::SETMETHOD:
58063:             SetPropCompiler::reset(repatcher, pic);
53055:             break;
53055:           case ic::PICInfo::NAME:
54847:           case ic::PICInfo::XNAME:
58063:             ScopeNameCompiler::reset(repatcher, pic);
53055:             break;
53055:           case ic::PICInfo::BIND:
58063:             BindNameCompiler::reset(repatcher, pic);
53055:             break;
53353:           case ic::PICInfo::CALL: /* fall-through */
53307:           case ic::PICInfo::GET:
58063:             GetPropCompiler::reset(repatcher, pic);
53055:             break;
53353:           default:
53353:             JS_NOT_REACHED("Unhandled PIC kind");
53353:             break;
53055:         }
52880:         pic.reset();
52880:     }
56738: 
62075:     ic::GetElementIC *getElems_ = getElems();
62075:     ic::SetElementIC *setElems_ = setElems();
56738:     for (uint32 i = 0; i < nGetElems; i++)
62075:         getElems_[i].purge(repatcher);
57671:     for (uint32 i = 0; i < nSetElems; i++)
62075:         setElems_[i].purge(repatcher);
52880: }
52880: 
55503: void
55503: ic::PurgePICs(JSContext *cx, JSScript *script)
55503: {
55503:     if (script->jitNormal)
55503:         script->jitNormal->purgePICs();
55503:     if (script->jitCtor)
55503:         script->jitCtor->purgePICs();
55503: }
55503: 
53119: #endif /* JS_POLYIC */
53119: 
