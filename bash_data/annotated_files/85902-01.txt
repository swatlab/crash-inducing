59414: # -*- Mode: js2; indent-tabs-mode: nil; js2-basic-offset: 2; -*-
41306: # ***** BEGIN LICENSE BLOCK *****
41306: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
41306: #
41306: # The contents of this file are subject to the Mozilla Public License Version
41306: # 1.1 (the "License"); you may not use this file except in compliance with
41306: # the License. You may obtain a copy of the License at
41306: # http://www.mozilla.org/MPL/
41306: #
41306: # Software distributed under the License is distributed on an "AS IS" basis,
41306: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41306: # for the specific language governing rights and limitations under the
41306: # License.
41306: #
41306: # The Original Code is aboutSupport.xhtml.
41306: #
41306: # The Initial Developer of the Original Code is
41306: # Mozilla Foundation
41306: # Portions created by the Initial Developer are Copyright (C) 2009
41306: # the Initial Developer. All Rights Reserved.
41306: #
41306: # Contributor(s):
41306: #   Curtis Bartley <cbartley@mozilla.com>
41306: #
41306: # Alternatively, the contents of this file may be used under the terms of
41306: # either the GNU General Public License Version 2 or later (the "GPL"), or
41306: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41306: # in which case the provisions of the GPL or the LGPL are applicable instead
41306: # of those above. If you wish to allow use of your version of this file only
41306: # under the terms of either the GPL or the LGPL, and not to allow others to
41306: # use your version of this file under the terms of the MPL, indicate your
41306: # decision by deleting the provisions above and replace them with the notice
41306: # and other provisions required by the GPL or the LGPL. If you do not delete
41306: # the provisions above, a recipient may use your version of this file under
41306: # the terms of any one of the MPL, the GPL or the LGPL.
41306: #
41306: # ***** END LICENSE BLOCK *****
41306: 
41306: const Cc = Components.classes;
41306: const Ci = Components.interfaces;
41306: 
53802: Components.utils.import("resource://gre/modules/AddonManager.jsm");
53802: Components.utils.import("resource://gre/modules/Services.jsm");
41306: 
53802: const ELLIPSIS = Services.prefs.getComplexValue("intl.ellipsis",
41306:                                                 Ci.nsIPrefLocalizedString).data;
41306: 
41306: // We use a preferences whitelist to make sure we only show preferences that
41306: // are useful for support and won't compromise the user's privacy.  Note that
41306: // entries are *prefixes*: for example, "accessibility." applies to all prefs
41306: // under the "accessibility.*" branch.
41306: const PREFS_WHITELIST = [
41306:   "accessibility.",
81625:   "browser.display.",
41306:   "browser.fixup.",
41306:   "browser.history_expire_",
41306:   "browser.link.open_newwindow",
41306:   "browser.places.",
41306:   "browser.startup.homepage",
41306:   "browser.tabs.",
41306:   "browser.zoom.",
41306:   "dom.",
41306:   "extensions.checkCompatibility",
41306:   "extensions.lastAppVersion",
41306:   "font.",
81625:   "general.autoScroll",
41306:   "general.useragent.",
51975:   "gfx.",
63185:   "html5.",
51975:   "layers.",
41306:   "javascript.",
41306:   "keyword.",
41306:   "layout.css.dpi",
81625:   "mousewheel.",
41306:   "network.",
81625:   "permissions.default.image",
41306:   "places.",
73435:   "plugin.",
73435:   "plugins.",
41306:   "print.",
41306:   "privacy.",
71011:   "security.",
71011:   "webgl."
41306: ];
41306: 
41306: // The blacklist, unlike the whitelist, is a list of regular expressions.
41306: const PREFS_BLACKLIST = [
41306:   /^network[.]proxy[.]/,
41306:   /[.]print_to_filename$/,
41306: ];
41306: 
41306: window.onload = function () {
41306:   // Get the support URL.
41306:   let urlFormatter = Cc["@mozilla.org/toolkit/URLFormatterService;1"]
41306:                        .getService(Ci.nsIURLFormatter);
41306:   let supportUrl = urlFormatter.formatURLPref("app.support.baseURL");
41306: 
41306:   // Update the application basics section.
53802:   document.getElementById("application-box").textContent = Services.appinfo.name;
51930:   document.getElementById("useragent-box").textContent = navigator.userAgent;
41306:   document.getElementById("supportLink").href = supportUrl;
55838:   let version = Services.appinfo.version;
55838:   try {
55838:     version += " (" + Services.prefs.getCharPref("app.support.vendor") + ")";
55838:   } catch (e) {
55838:   }
55838:   document.getElementById("version-box").textContent = version;
41306: 
41306:   // Update the other sections.
42036:   populatePreferencesSection();
41684:   populateExtensionsSection();
50527:   populateGraphicsSection();
41306: }
41306: 
41306: function populateExtensionsSection() {
53802:   AddonManager.getAddonsByTypes(["extension"], function(extensions) {
64651:     extensions.sort(function(a,b) {
64651:       if (a.isActive != b.isActive)
64651:         return b.isActive ? 1 : -1;
64651:       let lc = a.name.localeCompare(b.name);
64651:       if (lc != 0)
64651:         return lc;
64651:       if (a.version != b.version)
64651:         return a.version > b.version ? 1 : -1;
64651:       return 0;
64651:     });
41306:     let trExtensions = [];
53802:     for (let i = 0; i < extensions.length; i++) {
53802:       let extension = extensions[i];
41306:       let tr = createParentElement("tr", [
41306:         createElement("td", extension.name),
41306:         createElement("td", extension.version),
53802:         createElement("td", extension.isActive),
41306:         createElement("td", extension.id),
41306:       ]);
41306:       trExtensions.push(tr);
41306:     }
41306:     appendChildren(document.getElementById("extensions-tbody"), trExtensions);
42036:   });
41306: }
41306: 
41306: function populatePreferencesSection() {
41306:   let modifiedPrefs = getModifiedPrefs();
41306: 
41306:   function comparePrefs(pref1, pref2) {
41306:     if (pref1.name < pref2.name)
41306:       return -1;
41306:     if (pref1.name > pref2.name)
41306:       return 1;
41306:     return 0;
41306:   }
41306: 
41306:   let sortedPrefs = modifiedPrefs.sort(comparePrefs);
41306: 
41306:   let trPrefs = [];
41306:   sortedPrefs.forEach(function (pref) {
41306:     let tdName = createElement("td", pref.name, "pref-name");
41306:     let tdValue = createElement("td", formatPrefValue(pref.value), "pref-value");
41306:     let tr = createParentElement("tr", [tdName, tdValue]);
41306:     trPrefs.push(tr);
41306:   });
41306: 
41306:   appendChildren(document.getElementById("prefs-tbody"), trPrefs);
41306: }
41306: 
50527: function populateGraphicsSection() {
51578:   function createHeader(name)
51578:   {
51578:     let elem = createElement("th", name);
51578:     elem.className = "column";
51578:     return elem;
51578:   }
51578: 
69379:   function pushInfoRow(table, name, value)
69379:   {
69379:     if(value) {
69379:       table.push(createParentElement("tr", [
69379:         createHeader(bundle.GetStringFromName(name)),
69379:         createElement("td", value),
69379:       ]));
69379:     }
69379:   }
69379:   
82416:   function pushLiteralInfoRow(table, name, value)
82416:   {
82416:     table.push(createParentElement("tr", [
82416:       createHeader(name),
82416:       createElement("td", value),
82416:     ]));
82416:   }
82416: 
69380:   function errorMessageForFeature(feature) {
69380:     var errorMessage;
69380:     var status;
69380:     try {
69380:       status = gfxInfo.getFeatureStatus(feature);
69380:     } catch(e) {}
69380:     switch (status) {
69380:       case gfxInfo.FEATURE_BLOCKED_DEVICE:
69380:       case gfxInfo.FEATURE_DISCOURAGED:
69380:         errorMessage = bundle.GetStringFromName("blockedGfxCard");
69380:         break;
69380:       case gfxInfo.FEATURE_BLOCKED_OS_VERSION:
69380:         errorMessage = bundle.GetStringFromName("blockedOSVersion");
69380:         break;
69380:       case gfxInfo.FEATURE_BLOCKED_DRIVER_VERSION:
69380:         var suggestedDriverVersion;
69380:         try {
69380:           suggestedDriverVersion = gfxInfo.getFeatureSuggestedDriverVersion(feature);
69380:         } catch(e) {}
69380:         if (suggestedDriverVersion)
71649:           errorMessage = bundle.formatStringFromName("tryNewerDriver", [suggestedDriverVersion], 1);
69380:         else
69380:           errorMessage = bundle.GetStringFromName("blockedDriver");
69380:         break;
69380:     }
69380:     return errorMessage;
69380:   }
69380: 
69380:   function pushFeatureInfoRow(table, name, feature, isEnabled, message) {
69380:     message = message || isEnabled;
69380:     if (!isEnabled) {
69380:       var errorMessage = errorMessageForFeature(feature);
69380:       if (errorMessage)
69380:         message = errorMessage;
69380:     }
69380:     table.push(createParentElement("tr", [
69380:       createHeader(bundle.GetStringFromName(name)),
69380:       createElement("td", message),
69380:     ]));
69380:   }
69380: 
69379:   function hexValueToString(value)
69379:   {
69379:     return value
69379:            ? String('0000' + value.toString(16)).slice(-4)
69379:            : null;
69379:   }
69379: 
53802:   let bundle = Services.strings.createBundle("chrome://global/locale/aboutSupport.properties");
51975:   let graphics_tbody = document.getElementById("graphics-tbody");
51975: 
55163:   var gfxInfo = null;
50527:   try {
50527:     // nsIGfxInfo is currently only implemented on Windows
55163:     gfxInfo = Cc["@mozilla.org/gfx/info;1"].getService(Ci.nsIGfxInfo);
55163:   } catch(e) {}
55163: 
55163:   if (gfxInfo) {
51578:     let trGraphics = [];
69379:     pushInfoRow(trGraphics, "adapterDescription", gfxInfo.adapterDescription);
85902:     pushInfoRow(trGraphics, "adapterVendorID", hexValueToString(gfxInfo.adapterVendorID));
85902:     pushInfoRow(trGraphics, "adapterDeviceID", hexValueToString(gfxInfo.adapterDeviceID));
69379:     pushInfoRow(trGraphics, "adapterRAM", gfxInfo.adapterRAM);
69379:     pushInfoRow(trGraphics, "adapterDrivers", gfxInfo.adapterDriver);
69379:     pushInfoRow(trGraphics, "driverVersion", gfxInfo.adapterDriverVersion);
69379:     pushInfoRow(trGraphics, "driverDate", gfxInfo.adapterDriverDate);
55060: 
69380: #ifdef XP_WIN
76321:     pushInfoRow(trGraphics, "adapterDescription2", gfxInfo.adapterDescription2);
85902:     pushInfoRow(trGraphics, "adapterVendorID2", hexValueToString(gfxInfo.adapterVendorID2));
85902:     pushInfoRow(trGraphics, "adapterDeviceID2", hexValueToString(gfxInfo.adapterDeviceID2));
76321:     pushInfoRow(trGraphics, "adapterRAM2", gfxInfo.adapterRAM2);
76321:     pushInfoRow(trGraphics, "adapterDrivers2", gfxInfo.adapterDriver2);
76321:     pushInfoRow(trGraphics, "driverVersion2", gfxInfo.adapterDriverVersion2);
76321:     pushInfoRow(trGraphics, "driverDate2", gfxInfo.adapterDriverDate2);
76321:     pushInfoRow(trGraphics, "isGPU2Active", gfxInfo.isGPU2Active);
76321: 
69380:     var version = Cc["@mozilla.org/system-info;1"]
69380:                   .getService(Ci.nsIPropertyBag2)
69380:                   .getProperty("version");
69380:     var isWindowsVistaOrHigher = (parseFloat(version) >= 6.0);
69380:     if (isWindowsVistaOrHigher) {
69380:       var d2dEnabled = "false";
55378:       try {
55378:         d2dEnabled = gfxInfo.D2DEnabled;
55378:       } catch(e) {}
69380:       pushFeatureInfoRow(trGraphics, "direct2DEnabled", gfxInfo.FEATURE_DIRECT2D, d2dEnabled);
69380: 
69380:       var dwEnabled = "false";
69281:       try {
69380:         dwEnabled = gfxInfo.DWriteEnabled + " (" + gfxInfo.DWriteVersion + ")";
55378:       } catch(e) {}
69664:       pushInfoRow(trGraphics, "directWriteEnabled", dwEnabled);  
69664: 
69664:       var cleartypeParams = "";
69664:       try {
69664:         cleartypeParams = gfxInfo.cleartypeParameters;
69664:       } catch(e) {
69664:         cleartypeParams = bundle.GetStringFromName("clearTypeParametersNotFound");
69380:       }
69664:       pushInfoRow(trGraphics, "clearTypeParameters", cleartypeParams);  
69664:     }
69664: 
69380: #endif
51578: 
59414:     var webglrenderer;
69380:     var webglenabled;
59414:     try {
59414:       webglrenderer = gfxInfo.getWebGLParameter("full-renderer");
69380:       webglenabled = true;
59414:     } catch (e) {
69380:       webglrenderer = false;
69380:       webglenabled = false;
59414:     }
69380: #ifdef XP_WIN
69380:     // If ANGLE is not available but OpenGL is, we want to report on the OpenGL feature, because that's what's going to get used.
69380:     // In all other cases we want to report on the ANGLE feature.
69380:     var webglfeature = gfxInfo.FEATURE_WEBGL_ANGLE;
69380:     if (gfxInfo.getFeatureStatus(gfxInfo.FEATURE_WEBGL_ANGLE)  != gfxInfo.FEATURE_NO_INFO &&
69380:         gfxInfo.getFeatureStatus(gfxInfo.FEATURE_WEBGL_OPENGL) == gfxInfo.FEATURE_NO_INFO)
69380:       webglfeature = gfxInfo.FEATURE_WEBGL_OPENGL;
69380: #else
69380:     var webglfeature = gfxInfo.FEATURE_WEBGL_OPENGL;
69380: #endif
69380:     pushFeatureInfoRow(trGraphics, "webglRenderer", webglfeature, webglenabled, webglrenderer);
59414: 
51975:     appendChildren(graphics_tbody, trGraphics);
62108:     
82416:     // display registered graphics properties
82416:     let graphics_info_properties = document.getElementById("graphics-info-properties");
82416:     var info = gfxInfo.getInfo();
82416:     let trGraphicsProperties = [];
82416:     for (var property in info) {
82416:       pushLiteralInfoRow(trGraphicsProperties, property, info[property]);
82416:     }
82416:     appendChildren(graphics_info_properties, trGraphicsProperties);
82416:    
62108:     // display any failures that have occurred
62108:     let graphics_failures_tbody = document.getElementById("graphics-failures-tbody");
62108:     let trGraphicsFailures = gfxInfo.getFailures().map(function (value)
62108:         createParentElement("tr", [
62108:             createElement("td", value)
62108:         ])
62108:     );
62108:     appendChildren(graphics_failures_tbody, trGraphicsFailures);
62108: 
82416: 
82416: 
55163:   } // end if (gfxInfo)
50527: 
53802:   let windows = Services.ww.getWindowEnumerator();
51975:   let acceleratedWindows = 0;
51975:   let totalWindows = 0;
51975:   let mgrType;
51975:   while (windows.hasMoreElements()) {
51975:     totalWindows++;
51975: 
51975:     let awindow = windows.getNext().QueryInterface(Ci.nsIInterfaceRequestor);
51975:     let windowutils = awindow.getInterface(Ci.nsIDOMWindowUtils);
51975:     if (windowutils.layerManagerType != "Basic") {
51975:       acceleratedWindows++;
51975:       mgrType = windowutils.layerManagerType;
51975:     }
51975:   }
51975: 
82944:   let msg = acceleratedWindows;
69380:   if (acceleratedWindows) {
82944:     msg += "/" + totalWindows + " " + mgrType;
69380:   } else {
69380: #ifdef XP_WIN
69380:     var feature = gfxInfo.FEATURE_DIRECT3D_9_LAYERS;
69380: #else
69380:     var feature = gfxInfo.FEATURE_OPENGL_LAYERS;
69380: #endif
69380:     var errMsg = errorMessageForFeature(feature);
69380:     if (errMsg)
69380:       msg += ". " + errMsg;
69380:   }
51975: 
60284:   appendChildren(graphics_tbody, [
60284:     createParentElement("tr", [
60284:       createHeader(bundle.GetStringFromName("acceleratedWindows")),
60284:       createElement("td", msg),
60284:     ])
60284:   ]);
50527: }
50527: 
53802: function getPrefValue(aName) {
53802:   let value = "";
53802:   let type = Services.prefs.getPrefType(aName);
53802:   switch (type) {
53802:     case Ci.nsIPrefBranch2.PREF_STRING:
53802:       value = Services.prefs.getComplexValue(aName, Ci.nsISupportsString).data;
53802:       break;
53802:     case Ci.nsIPrefBranch2.PREF_BOOL:
53802:       value = Services.prefs.getBoolPref(aName);
53802:       break;
53802:     case Ci.nsIPrefBranch2.PREF_INT:
53802:       value = Services.prefs.getIntPref(aName);
53802:       break;
53802:   }
53802: 
53802:   return { name: aName, value: value };
53802: }
50527: 
41306: function formatPrefValue(prefValue) {
41306:   // Some pref values are really long and don't have spaces.  This can cause
41306:   // problems when copying and pasting into some WYSIWYG editors.  In general
41306:   // the exact contents of really long pref values aren't particularly useful,
41306:   // so we truncate them to some reasonable length.
41306:   let maxPrefValueLen = 120;
41306:   let text = "" + prefValue;
41306:   if (text.length > maxPrefValueLen)
41306:     text = text.substring(0, maxPrefValueLen) + ELLIPSIS;
41306:   return text;
41306: }
41306: 
41306: function getModifiedPrefs() {
41306:   // We use the low-level prefs API to identify prefs that have been
41306:   // modified, rather that Application.prefs.all since the latter is
41306:   // much, much slower.  Application.prefs.all also gets slower each
41306:   // time it's called.  See bug 517312.
41306:   let prefNames = getWhitelistedPrefNames();
53802:   let prefs = [getPrefValue(prefName)
41306:                       for each (prefName in prefNames)
53802:                           if (Services.prefs.prefHasUserValue(prefName)
41306:                             && !isBlacklisted(prefName))];
41306:   return prefs;
41306: }
41306: 
41306: function getWhitelistedPrefNames() {
41306:   let results = [];
41306:   PREFS_WHITELIST.forEach(function (prefStem) {
53802:     let prefNames = Services.prefs.getChildList(prefStem);
41306:     results = results.concat(prefNames);
41306:   });
41306:   return results;
41306: }
41306: 
41306: function isBlacklisted(prefName) {
41306:   return PREFS_BLACKLIST.some(function (re) re.test(prefName));
41306: }
41306: 
41306: function createParentElement(tagName, childElems) {
41306:   let elem = document.createElement(tagName);
41306:   appendChildren(elem, childElems);
41306:   return elem;
41306: }
41306: 
71649: function createElement(tagName, textContent, opt_class) {
41306:   let elem = document.createElement(tagName);
71649:   elem.textContent = textContent;
41306:   elem.className = opt_class || "";
41306:   return elem;
41306: }
41306: 
41306: function appendChildren(parentElem, childNodes) {
41306:   for (let i = 0; i < childNodes.length; i++)
41306:     parentElem.appendChild(childNodes[i]);
41306: }
41306: 
41306: function copyContentsToClipboard() {
41306:   // Get the HTML and text representations for the important part of the page.
41306:   let contentsDiv = document.getElementById("contents");
41306:   let dataHtml = contentsDiv.innerHTML;
41306:   let dataText = createTextForElement(contentsDiv);
41306: 
41306:   // We can't use plain strings, we have to use nsSupportsString.
41306:   let supportsStringClass = Cc["@mozilla.org/supports-string;1"];
41306:   let ssHtml = supportsStringClass.createInstance(Ci.nsISupportsString);
41306:   let ssText = supportsStringClass.createInstance(Ci.nsISupportsString);
41306: 
41306:   let transferable = Cc["@mozilla.org/widget/transferable;1"]
41306:                        .createInstance(Ci.nsITransferable);
41306: 
41306:   // Add the HTML flavor.
41306:   transferable.addDataFlavor("text/html");
41306:   ssHtml.data = dataHtml;
41306:   transferable.setTransferData("text/html", ssHtml, dataHtml.length * 2);
41306: 
41306:   // Add the plain text flavor.
41306:   transferable.addDataFlavor("text/unicode");
41306:   ssText.data = dataText;
41306:   transferable.setTransferData("text/unicode", ssText, dataText.length * 2);
41306: 
41306:   // Store the data into the clipboard.
41306:   let clipboard = Cc["@mozilla.org/widget/clipboard;1"]
41306:                     .getService(Ci.nsIClipboard);
41306:   clipboard.setData(transferable, null, clipboard.kGlobalClipboard);
41306: }
41306: 
41306: // Return the plain text representation of an element.  Do a little bit
41306: // of pretty-printing to make it human-readable.
41306: function createTextForElement(elem) {
41306:   // Generate the initial text.
41306:   let textFragmentAccumulator = [];
41306:   generateTextForElement(elem, "", textFragmentAccumulator);
41306:   let text = textFragmentAccumulator.join("");
41306: 
41306:   // Trim extraneous whitespace before newlines, then squash extraneous
41306:   // blank lines.
41306:   text = text.replace(/[ \t]+\n/g, "\n");
41306:   text = text.replace(/\n\n\n+/g, "\n\n");
41306: 
41306:   // Actual CR/LF pairs are needed for some Windows text editors.
41306: #ifdef XP_WIN
41306:   text = text.replace(/\n/g, "\r\n");
41306: #endif
41306: 
41306:   return text;
41306: }
41306: 
41306: function generateTextForElement(elem, indent, textFragmentAccumulator) {
41306:   // Add a little extra spacing around most elements.
41306:   if (elem.tagName != "td")
41306:     textFragmentAccumulator.push("\n");
41306: 
41306:   // Generate the text representation for each child node.
41306:   let node = elem.firstChild;
41306:   while (node) {
41306: 
41306:     if (node.nodeType == Node.TEXT_NODE) {
41306:       // Text belonging to this element uses its indentation level.
41306:       generateTextForTextNode(node, indent, textFragmentAccumulator);
41306:     }
41306:     else if (node.nodeType == Node.ELEMENT_NODE) {
41306:       // Recurse on the child element with an extra level of indentation.
41306:       generateTextForElement(node, indent + "  ", textFragmentAccumulator);
41306:     }
41306: 
41306:     // Advance!
41306:     node = node.nextSibling;
41306:   }
41306: }
41306: 
41306: function generateTextForTextNode(node, indent, textFragmentAccumulator) {
41306:   // If the text node is the first of a run of text nodes, then start
41306:   // a new line and add the initial indentation.
41306:   let prevNode = node.previousSibling;
41306:   if (!prevNode || prevNode.nodeType == Node.TEXT_NODE)
41306:     textFragmentAccumulator.push("\n" + indent);
41306: 
41306:   // Trim the text node's text content and add proper indentation after
41306:   // any internal line breaks.
41306:   let text = node.textContent.trim().replace("\n", "\n" + indent, "g");
41306:   textFragmentAccumulator.push(text);
41306: }
41306: 
41306: function openProfileDirectory() {
41306:   // Get the profile directory.
53802:   let currProfD = Services.dirsvc.get("ProfD", Ci.nsIFile);
41306:   let profileDir = currProfD.path;
41306: 
41306:   // Show the profile directory.
41306:   let nsLocalFile = Components.Constructor("@mozilla.org/file/local;1",
41306:                                            "nsILocalFile", "initWithPath");
41306:   new nsLocalFile(profileDir).reveal();
41306: }
