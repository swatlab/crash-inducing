51215: /* vim:set tw=80 expandtab softtabstop=4 ts=4 sw=4: */
51215: /* ***** BEGIN LICENSE BLOCK *****
51215:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
51215:  *
51215:  * The contents of this file are subject to the Mozilla Public License Version
51215:  * 1.1 (the "License"); you may not use this file except in compliance with
51215:  * the License. You may obtain a copy of the License at
51215:  * http://www.mozilla.org/MPL/
51215:  *
51215:  * Software distributed under the License is distributed on an "AS IS" basis,
51215:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
51215:  * for the specific language governing rights and limitations under the
51215:  * License.
51215:  *
51215:  * The Original Code is the Mozilla ICO Decoder.
51215:  *
51215:  * The Initial Developer of the Original Code is
51215:  * Netscape.
51215:  * Portions created by the Initial Developer are Copyright (C) 2001
51215:  * the Initial Developer. All Rights Reserved.
51215:  *
51215:  * Contributor(s):
51215:  *   David Hyatt <hyatt@netscape.com> (Original Author)
51215:  *   Christian Biesinger <cbiesinger@web.de>
51215:  *   Bobby Holley <bobbyholley@gmail.com>
77228:  *   Brian R. Bondy <netzen@gmail.com>
51215:  *
51215:  * Alternatively, the contents of this file may be used under the terms of
51215:  * either the GNU General Public License Version 2 or later (the "GPL"), or
51215:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
51215:  * in which case the provisions of the GPL or the LGPL are applicable instead
51215:  * of those above. If you wish to allow use of your version of this file only
51215:  * under the terms of either the GPL or the LGPL, and not to allow others to
51215:  * use your version of this file under the terms of the MPL, indicate your
51215:  * decision by deleting the provisions above and replace them with the notice
51215:  * and other provisions required by the GPL or the LGPL. If you do not delete
51215:  * the provisions above, a recipient may use your version of this file under
51215:  * the terms of any one of the MPL, the GPL or the LGPL.
51215:  *
51215:  * ***** END LICENSE BLOCK ***** */
51215: 
51215: /* This is a Cross-Platform ICO Decoder, which should work everywhere, including
51215:  * Big-Endian machines like the PowerPC. */
51215: 
51215: #include <stdlib.h>
51215: 
77230: #include "Endian.h"
51215: #include "nsICODecoder.h"
51215: 
51215: #include "nsIInputStream.h"
51215: #include "nsIComponentManager.h"
51215: #include "RasterImage.h"
51215: #include "imgIContainerObserver.h"
51215: 
51215: #include "nsIProperties.h"
51215: #include "nsISupportsPrimitives.h"
51215: 
51241: namespace mozilla {
51241: namespace imagelib {
51215: 
51215: #define ICONCOUNTOFFSET 4
51215: #define DIRENTRYOFFSET 6
51215: #define BITMAPINFOSIZE 40
51215: #define PREFICONSIZE 16
51215: 
51215: // ----------------------------------------
51215: // Actual Data Processing
51215: // ----------------------------------------
51215: 
77228: PRUint32
77228: nsICODecoder::CalcAlphaRowSize() 
51215: {
51215:   // Calculate rowsize in DWORD's and then return in # of bytes
51215:   PRUint32 rowSize = (mDirEntry.mWidth + 31) / 32; // +31 to round up
51215:   return rowSize * 4; // Return rowSize in bytes
51215: }
51215: 
77228: // Obtains the number of colors from the bits per pixel
77228: PRUint16
77228: nsICODecoder::GetNumColors() 
77228: {
77228:   PRUint16 numColors = 0;
77228:   if (mBPP <= 8) {
77228:     switch (mBPP) {
77228:     case 1:
77228:       numColors = 2;
77228:       break;
77228:     case 4:
77228:       numColors = 16;
77228:       break;
77228:     case 8:
77228:       numColors = 256;
77228:       break;
77228:     default:
77228:       numColors = (PRUint16)-1;
77228:     }
77228:   }
77228:   return numColors;
77228: }
77228: 
77228: 
51215: nsICODecoder::nsICODecoder()
51215: {
77228:   mPos = mImageOffset = mCurrIcon = mNumIcons = mBPP = mRowBytes = 0;
77228:   mIsPNG = PR_FALSE;
51215:   mRow = nsnull;
77228:   mOldLine = mCurLine = 1; // Otherwise decoder will never start
51215: }
51215: 
51215: nsICODecoder::~nsICODecoder()
51215: {
51215:   if (mRow) {
77228:     moz_free(mRow);
51215:   }
51247: }
51247: 
53664: void
51247: nsICODecoder::FinishInternal()
51247: {
53673:   // We shouldn't be called in error cases
53675:   NS_ABORT_IF_FALSE(!HasError(), "Shouldn't call FinishInternal after error!");
53673: 
77228:   // Finish the internally used decoder as well
77228:   if (mContainedDecoder) {
77228:     mContainedDecoder->FinishSharedDecoder();
77228:     mDecodeDone = mContainedDecoder->GetDecodeDone();
77228:   }
77228: }
51247: 
77228: // Returns a buffer filled with the bitmap file header in little endian:
77228: // Signature 2 bytes 'BM'
77228: // FileSize	 4 bytes File size in bytes
77228: // reserved	 4 bytes unused (=0)
77228: // DataOffset	 4 bytes File offset to Raster Data
77228: // Returns PR_TRUE if successful
77228: PRBool nsICODecoder::FillBitmapFileHeaderBuffer(PRInt8 *bfh) 
77228: {
77228:   memset(bfh, 0, 14);
77228:   bfh[0] = 'B';
77228:   bfh[1] = 'M';
77228:   PRInt32 dataOffset = 0;
77228:   PRInt32 fileSize = 0;
77228:   dataOffset = BFH_LENGTH + BITMAPINFOSIZE;
51592: 
77228:   // The color table is present only if BPP is <= 8
77228:   if (mDirEntry.mBitCount <= 8) {
77228:     PRUint16 numColors = GetNumColors();
77228:     if (numColors == (PRUint16)-1) {
77228:       return PR_FALSE;
77228:     }
77228:     dataOffset += 4 * numColors;
77228:     fileSize = dataOffset + mDirEntry.mWidth * mDirEntry.mHeight;
77228:   } else {
77228:     fileSize = dataOffset + (mDirEntry.mBitCount * mDirEntry.mWidth * 
77228:                              mDirEntry.mHeight) / 8;
77228:   }
51247: 
77228:   fileSize = NATIVE32_TO_LITTLE(fileSize);
77228:   memcpy(bfh + 2, &fileSize, sizeof(fileSize));
77228:   dataOffset = NATIVE32_TO_LITTLE(dataOffset);
77228:   memcpy(bfh + 10, &dataOffset, sizeof(dataOffset));
77228:   return PR_TRUE;
77228: }
77228: 
77228: // A BMP inside of an ICO has *2 height because of the AND mask
77228: // that follows the actual bitmap.  The BMP shouldn't know about
77228: // this difference though.
77228: void 
77228: nsICODecoder::FillBitmapInformationBufferHeight(PRInt8 *bih) 
77228: {
77228:   PRInt32 height = mDirEntry.mHeight;
77228:   height = NATIVE32_TO_LITTLE(height);
77228:   memcpy(bih + 8, &height, sizeof(height));
77228: }
77228: 
77228: // The BMP information header's bits per pixel should be trusted
77228: // more than what we have.  Usually the ICO's BPP is set to 0
77228: PRInt32 
77228: nsICODecoder::ExtractBPPFromBitmap(PRInt8 *bih)
77228: {
77228:   PRInt32 bitsPerPixel;
77228:   memcpy(&bitsPerPixel, bih + 14, sizeof(bitsPerPixel));
77228:   bitsPerPixel = LITTLE_TO_NATIVE32(bitsPerPixel);
77228:   return bitsPerPixel;
77228: }
77228: 
77519: PRInt32 
77519: nsICODecoder::ExtractBIHSizeFromBitmap(PRInt8 *bih)
77519: {
77519:   PRInt32 headerSize;
77519:   memcpy(&headerSize, bih, sizeof(headerSize));
77519:   headerSize = LITTLE_TO_NATIVE32(headerSize);
77519:   return headerSize;
77519: }
77519: 
77228: void
77228: nsICODecoder::SetHotSpotIfCursor() {
77228:   if (!mIsCursor) {
77228:     return;
77228:   }
77228: 
77228:   nsCOMPtr<nsISupportsPRUint32> intwrapx = 
77228:     do_CreateInstance("@mozilla.org/supports-PRUint32;1");
77228:   nsCOMPtr<nsISupportsPRUint32> intwrapy = 
77228:     do_CreateInstance("@mozilla.org/supports-PRUint32;1");
77228: 
77228:   if (intwrapx && intwrapy) {
77228:     intwrapx->SetData(mDirEntry.mXHotspot);
77228:     intwrapy->SetData(mDirEntry.mYHotspot);
77228: 
77228:     mImage->Set("hotspotX", intwrapx);
77228:     mImage->Set("hotspotY", intwrapy);
51247:   }
51215: }
51215: 
53664: void
51241: nsICODecoder::WriteInternal(const char* aBuffer, PRUint32 aCount)
51215: {
53675:   NS_ABORT_IF_FALSE(!HasError(), "Shouldn't call WriteInternal after error!");
51215: 
51215:   if (!aCount) // aCount=0 means EOF
53664:     return;
51215: 
51215:   while (aCount && (mPos < ICONCOUNTOFFSET)) { // Skip to the # of icons.
51215:     if (mPos == 2) { // if the third byte is 1: This is an icon, 2: a cursor
51215:       if ((*aBuffer != 1) && (*aBuffer != 2)) {
53662:         PostDataError();
53664:         return;
51215:       }
51215:       mIsCursor = (*aBuffer == 2);
51215:     }
51215:     mPos++; aBuffer++; aCount--;
51215:   }
51215: 
51215:   if (mPos == ICONCOUNTOFFSET && aCount >= 2) {
51215:     mNumIcons = LITTLE_TO_NATIVE16(((PRUint16*)aBuffer)[0]);
51215:     aBuffer += 2;
51215:     mPos += 2;
51215:     aCount -= 2;
51215:   }
51215: 
51215:   if (mNumIcons == 0)
53664:     return; // Nothing to do.
51215: 
51215:   PRUint16 colorDepth = 0;
77228:   // Loop through each entry's dir entry
51215:   while (mCurrIcon < mNumIcons) { 
51215:     if (mPos >= DIRENTRYOFFSET + (mCurrIcon * sizeof(mDirEntryArray)) && 
51215:         mPos < DIRENTRYOFFSET + ((mCurrIcon + 1) * sizeof(mDirEntryArray))) {
77228:       PRUint32 toCopy = sizeof(mDirEntryArray) - 
77228:                         (mPos - DIRENTRYOFFSET - mCurrIcon * sizeof(mDirEntryArray));
77228:       if (toCopy > aCount) {
51215:         toCopy = aCount;
77228:       }
51215:       memcpy(mDirEntryArray + sizeof(mDirEntryArray) - toCopy, aBuffer, toCopy);
51215:       mPos += toCopy;
51215:       aCount -= toCopy;
51215:       aBuffer += toCopy;
51215:     }
51215:     if (aCount == 0)
53664:       return; // Need more data
51215: 
51215:     IconDirEntry e;
77228:     if (mPos == (DIRENTRYOFFSET + ICODIRENTRYSIZE) + 
77228:                 (mCurrIcon * sizeof(mDirEntryArray))) {
51215:       mCurrIcon++;
51215:       ProcessDirEntry(e);
77228:       if ((e.mWidth == PREFICONSIZE && e.mHeight == PREFICONSIZE && 
77228:            e.mBitCount >= colorDepth) || 
77228:           (mCurrIcon == mNumIcons && mImageOffset == 0)) {
51215:         mImageOffset = e.mImageOffset;
51215: 
77228:         // ensure mImageOffset is >= size of the direntry headers (bug #245631)
77228:         PRUint32 minImageOffset = DIRENTRYOFFSET + 
77228:                                   mNumIcons * sizeof(mDirEntryArray);
51215:         if (mImageOffset < minImageOffset) {
53662:           PostDataError();
53664:           return;
51215:         }
51215: 
51215:         colorDepth = e.mBitCount;
51215:         memcpy(&mDirEntry, &e, sizeof(IconDirEntry));
51215:       }
51215:     }
51215:   }
51215: 
51215:   if (mPos < mImageOffset) {
51215:     // Skip to (or at least towards) the desired image offset
51215:     PRUint32 toSkip = mImageOffset - mPos;
51215:     if (toSkip > aCount)
51215:       toSkip = aCount;
51215: 
51215:     mPos    += toSkip;
51215:     aBuffer += toSkip;
51215:     aCount  -= toSkip;
51215:   }
51215: 
77228:   // If we are within the first PNGSIGNATURESIZE bytes of the image data,
77228:   // then we have either a BMP or a PNG.  We use the first PNGSIGNATURESIZE
77228:   // bytes to determine which one we have.
77228:   if (mCurrIcon == mNumIcons && mPos >= mImageOffset && 
77228:       mPos < mImageOffset + PNGSIGNATURESIZE)
77228:   {
77228:     PRUint32 toCopy = PNGSIGNATURESIZE - (mPos - mImageOffset);
77228:     if (toCopy > aCount) {
77228:       toCopy = aCount;
77228:     }
77228: 
77228:     memcpy(mSignature + (mPos - mImageOffset), aBuffer, toCopy);
77228:     mPos += toCopy;
77228:     aCount -= toCopy;
77228:     aBuffer += toCopy;
77228: 
77228:     mIsPNG = !memcmp(mSignature, nsPNGDecoder::pngSignatureBytes, 
77228:                      PNGSIGNATURESIZE);
77228:     if (mIsPNG) {
77228:       mContainedDecoder = new nsPNGDecoder();
77228:       mContainedDecoder->InitSharedDecoder(mImage, mObserver);
77228:       mContainedDecoder->Write(mSignature, PNGSIGNATURESIZE);
77228:       mDataError = mContainedDecoder->HasDataError();
77228:       if (mContainedDecoder->HasDataError()) {
77228:         return;
77228:       }
77228:     }
77228:   }
77228: 
77228:   // If we have a PNG, let the PNG decoder do all of the rest of the work
77228:   if (mIsPNG && mContainedDecoder && mPos >= mImageOffset + PNGSIGNATURESIZE) {
77228:     mContainedDecoder->Write(aBuffer, aCount);
77228:     mDataError = mContainedDecoder->HasDataError();
77228:     if (mContainedDecoder->HasDataError()) {
77228:       return;
77228:     }
77228:     mPos += aCount;
77228:     aBuffer += aCount;
77228:     aCount = 0;
77228: 
77228:     // Raymond Chen says that 32bpp only are valid PNG ICOs
77228:     // http://blogs.msdn.com/b/oldnewthing/archive/2010/10/22/10079192.aspx
77228:     if (static_cast<nsPNGDecoder*>(mContainedDecoder.get())->HasValidInfo() && 
77228:         static_cast<nsPNGDecoder*>(mContainedDecoder.get())->GetPixelDepth() != 32) {
77228:       PostDataError();
77228:     }
77228:     return;
77228:   }
77228: 
77228:   // We've processed all of the icon dir entries and are within the 
77228:   // bitmap info size
77228:   if (!mIsPNG && mCurrIcon == mNumIcons && mPos >= mImageOffset && 
77228:       mPos >= mImageOffset + PNGSIGNATURESIZE && 
77228:       mPos < mImageOffset + BITMAPINFOSIZE) {
77228: 
77228:     // As we were decoding, we did not know if we had a PNG signature or the
77228:     // start of a bitmap information header.  At this point we know we had
77228:     // a bitmap information header and not a PNG signature, so fill the bitmap
77228:     // information header with the data it should already have.
77228:     memcpy(mBIHraw, mSignature, PNGSIGNATURESIZE);
77228: 
51215:     // We've found the icon.
51215:     PRUint32 toCopy = sizeof(mBIHraw) - (mPos - mImageOffset);
51215:     if (toCopy > aCount)
51215:       toCopy = aCount;
51215: 
51215:     memcpy(mBIHraw + (mPos - mImageOffset), aBuffer, toCopy);
51215:     mPos += toCopy;
51215:     aCount -= toCopy;
51215:     aBuffer += toCopy;
51215:   }
51215: 
77228:   // If we have a BMP inside the ICO and we have read the BIH header
77228:   if (!mIsPNG && mPos == mImageOffset + BITMAPINFOSIZE) {
77519: 
77519:     // Make sure we have a sane value for the bitmap information header
77519:     PRInt32 bihSize = ExtractBIHSizeFromBitmap(reinterpret_cast<PRInt8*>(mBIHraw));
77519:     if (bihSize != BITMAPINFOSIZE) {
77519:       PostDataError();
77519:       return;
77519:     }
77228:     // We are extracting the BPP from the BIH header as it should be trusted 
77228:     // over the one we have from the icon header
77519:     mBPP = ExtractBPPFromBitmap(reinterpret_cast<PRInt8*>(mBIHraw));
51215:     
77228:     // Init the bitmap decoder which will do most of the work for us
77228:     // It will do everything except the AND mask which isn't present in bitmaps
77228:     // bmpDecoder is for local scope ease, it will be freed by mContainedDecoder
77228:     nsBMPDecoder *bmpDecoder = new nsBMPDecoder(); 
77228:     mContainedDecoder = bmpDecoder;
77228:     bmpDecoder->SetUseAlphaData(PR_TRUE);
77228:     mContainedDecoder->SetSizeDecode(IsSizeDecode());
77228:     mContainedDecoder->InitSharedDecoder(mImage, mObserver);
51215: 
77228:     // The ICO format when containing a BMP does not include the 14 byte
77228:     // bitmap file header. To use the code of the BMP decoder we need to 
77228:     // generate this header ourselves and feed it to the BMP decoder.
77228:     PRInt8 bfhBuffer[BMPFILEHEADERSIZE];
77228:     if (!FillBitmapFileHeaderBuffer(bfhBuffer)) {
53662:       PostDataError();
53664:       return;
51215:     }
77228:     mContainedDecoder->Write((const char*)bfhBuffer, sizeof(bfhBuffer));
77228:     mDataError = mContainedDecoder->HasDataError();
77228:     if (mContainedDecoder->HasDataError()) {
77228:       return;
51215:     }
51215: 
77228:     // Setup the cursor hot spot if one is present
77228:     SetHotSpotIfCursor();
51215: 
77228:     // Fix the height on the BMP resource
77228:     FillBitmapInformationBufferHeight((PRInt8*)mBIHraw);
51215: 
77228:     // Write out the BMP's bitmap info header
77228:     mContainedDecoder->Write(mBIHraw, sizeof(mBIHraw));
77228:     mDataError = mContainedDecoder->HasDataError();
77228:     if (mContainedDecoder->HasDataError()) {
77228:       return;
51215:     }
51215: 
77519:     // We have the size. If we're doing a size decode, we got what
77519:     // we came for.
77519:     if (IsSizeDecode())
77519:       return;
77519: 
77228:     // Sometimes the ICO BPP header field is not filled out
77228:     // so we should trust the contained resource over our own
77228:     // information.
77228:     mBPP = bmpDecoder->GetBitsPerPixel();
77228: 
77228:     // Check to make sure we have valid color settings
77228:     PRUint16 numColors = GetNumColors();
77228:     if (numColors == (PRUint16)-1) {
77228:       PostDataError();
77228:       return;
77228:     }
77228:   }
77228: 
77228:   // If we have a BMP
77228:   if (!mIsPNG && mContainedDecoder && mPos >= mImageOffset + BITMAPINFOSIZE) {
77228:     PRUint16 numColors = GetNumColors();
77228:     if (numColors == (PRUint16)-1) {
77228:       PostDataError();
77228:       return;
77228:     }
77228:     // Feed the actual image data (not including headers) into the BMP decoder
77228:     PRInt32 bmpDataOffset = mDirEntry.mImageOffset + BITMAPINFOSIZE;
77228:     PRInt32 bmpDataEnd = mDirEntry.mImageOffset + BITMAPINFOSIZE + 
77228:                          static_cast<nsBMPDecoder*>(mContainedDecoder.get())->GetCompressedImageSize() +
77228:                          4 * numColors;
77228: 
77228:     // If we are feeding in the core image data, but we have not yet
77228:     // reached the ICO's 'AND buffer mask'
77228:     if (mPos >= bmpDataOffset && mPos < bmpDataEnd) {
77228: 
77228:       // Figure out how much data the BMP decoder wants
77228:       PRUint32 toFeed = bmpDataEnd - mPos;
77228:       if (toFeed > aCount) {
77228:         toFeed = aCount;
77228:       }
77228: 
77228:       mContainedDecoder->Write(aBuffer, toFeed);
77228:       mDataError = mContainedDecoder->HasDataError();
77228:       if (mContainedDecoder->HasDataError()) {
77228:         return;
77228:       }
77228: 
77228:       mPos += toFeed;
77228:       aCount -= toFeed;
77228:       aBuffer += toFeed;
77228:     }
77228:   
77228:     // If the bitmap is fully processed, treat any left over data as the ICO's
77228:     // 'AND buffer mask' which appears after the bitmap resource.
77228:     if (!mIsPNG && mPos >= bmpDataEnd) {
77228:       // There may be an optional AND bit mask after the data.  This is
77228:       // only used if the alpha data is not already set. The alpha data 
77228:       // is used for 32bpp bitmaps as per the comment in ICODecoder.h
77228:       // The alpha mask should be checked in all other cases.
77228:       if (static_cast<nsBMPDecoder*>(mContainedDecoder.get())->GetBitsPerPixel() != 32) {
77228:         PRUint32 rowSize = ((mDirEntry.mWidth + 31) / 32) * 4; // + 31 to round up
77228:         if (mPos == bmpDataEnd) {
77228:           mPos++;
77228:           mRowBytes = 0;
51215:           mCurLine = mDirEntry.mHeight;
77228:           mRow = (PRUint8*)moz_realloc(mRow, rowSize);
51215:           if (!mRow) {
53662:             PostDecoderError(NS_ERROR_OUT_OF_MEMORY);
53664:             return;
51215:           }
51215:         }
51215: 
51215:         // Ensure memory has been allocated before decoding.
77228:         NS_ABORT_IF_FALSE(mRow, "mRow is null");
77228:         NS_ABORT_IF_FALSE(mImage, "mImage is null");
77228:         if (!mRow || !mImage) {
53662:           PostDataError();
53664:           return;
51215:         }
51215: 
51215:         while (mCurLine > 0 && aCount > 0) {
71173:           PRUint32 toCopy = NS_MIN(rowSize - mRowBytes, aCount);
51215:           if (toCopy) {
51215:             memcpy(mRow + mRowBytes, aBuffer, toCopy);
51215:             aCount -= toCopy;
51215:             aBuffer += toCopy;
51215:             mRowBytes += toCopy;
51215:           }
51215:           if (rowSize == mRowBytes) {
51215:             mCurLine--;
51215:             mRowBytes = 0;
51215: 
77519:             PRUint32* imageData = 
77519:               static_cast<nsBMPDecoder*>(mContainedDecoder.get())->GetImageData();
77519:             if (!imageData) {
77519:               PostDataError();
77519:               return;
77519:             }
77228:             PRUint32* decoded = imageData + mCurLine * mDirEntry.mWidth;
51215:             PRUint32* decoded_end = decoded + mDirEntry.mWidth;
51215:             PRUint8* p = mRow, *p_end = mRow + rowSize; 
51215:             while (p < p_end) {
51215:               PRUint8 idx = *p++;
51215:               for (PRUint8 bit = 0x80; bit && decoded<decoded_end; bit >>= 1) {
51215:                 // Clear pixel completely for transparency.
77228:                 if (idx & bit) {
77228:                   *decoded = 0;
77228:                 }
51215:                 decoded++;
51215:               }
51215:             }
51215:           }
51215:         }
51215:       }
77228:     }
77228:   }
51215: }
51215: 
51215: void
51215: nsICODecoder::ProcessDirEntry(IconDirEntry& aTarget)
51215: {
51215:   memset(&aTarget, 0, sizeof(aTarget));
51215:   memcpy(&aTarget.mWidth, mDirEntryArray, sizeof(aTarget.mWidth));
51215:   memcpy(&aTarget.mHeight, mDirEntryArray + 1, sizeof(aTarget.mHeight));
51215:   memcpy(&aTarget.mColorCount, mDirEntryArray + 2, sizeof(aTarget.mColorCount));
51215:   memcpy(&aTarget.mReserved, mDirEntryArray + 3, sizeof(aTarget.mReserved));
51215:   memcpy(&aTarget.mPlanes, mDirEntryArray + 4, sizeof(aTarget.mPlanes));
51215:   aTarget.mPlanes = LITTLE_TO_NATIVE16(aTarget.mPlanes);
51215:   memcpy(&aTarget.mBitCount, mDirEntryArray + 6, sizeof(aTarget.mBitCount));
51215:   aTarget.mBitCount = LITTLE_TO_NATIVE16(aTarget.mBitCount);
51215:   memcpy(&aTarget.mBytesInRes, mDirEntryArray + 8, sizeof(aTarget.mBytesInRes));
51215:   aTarget.mBytesInRes = LITTLE_TO_NATIVE32(aTarget.mBytesInRes);
77228:   memcpy(&aTarget.mImageOffset, mDirEntryArray + 12, 
77228:          sizeof(aTarget.mImageOffset));
51215:   aTarget.mImageOffset = LITTLE_TO_NATIVE32(aTarget.mImageOffset);
51215: }
51215: 
51241: } // namespace imagelib
51241: } // namespace mozilla
