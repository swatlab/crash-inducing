70324: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
70324: /* ***** BEGIN LICENSE BLOCK *****
70324:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
70324:  *
70324:  * The contents of this file are subject to the Mozilla Public License Version
70324:  * 1.1 (the "License"); you may not use this file except in compliance with
70324:  * the License. You may obtain a copy of the License at
70324:  * http://www.mozilla.org/MPL/
70324:  *
70324:  * Software distributed under the License is distributed on an "AS IS" basis,
70324:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
70324:  * for the specific language governing rights and limitations under the
70324:  * License.
70324:  *
70324:  * The Original Code is mozilla.org code.
70324:  *
70324:  * The Initial Developer of the Original Code is
70324:  * Wellington Fernando de Macedo and Clayton Williams.
70324:  * Portions created by the Initial Developer are Copyright (C) 2008
70324:  * the Initial Developer. All Rights Reserved.
70324:  *
70324:  * Contributor(s):
70324:  *    Wellington Fernando de Macedo <wfernandom2004@gmail.com>
70324:  *    Clayton Williams <claytonw@mit.edu>
70324:  *
70324:  * Alternatively, the contents of this file may be used under the terms of
70324:  * either of the GNU General Public License Version 2 or later (the "GPL"),
70324:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
70324:  * in which case the provisions of the GPL or the LGPL are applicable instead
70324:  * of those above. If you wish to allow use of your version of this file only
70324:  * under the terms of either the GPL or the LGPL, and not to allow others to
70324:  * use your version of this file under the terms of the MPL, indicate your
70324:  * decision by deleting the provisions above and replace them with the notice
70324:  * and other provisions required by the GPL or the LGPL. If you do not delete
70324:  * the provisions above, a recipient may use your version of this file under
70324:  * the terms of any one of the MPL, the GPL or the LGPL.
70324:  *
70324:  * ***** END LICENSE BLOCK ***** */
70324: 
80467: #include "mozilla/Util.h"
80467: 
70324: #include "nsEventSource.h"
70324: #include "nsNetUtil.h"
70324: #include "nsMimeTypes.h"
70324: #include "nsDOMMessageEvent.h"
70324: #include "nsIJSContextStack.h"
70324: #include "nsIPromptFactory.h"
70324: #include "nsIWindowWatcher.h"
70324: #include "nsPresContext.h"
70324: #include "nsContentPolicyUtils.h"
70324: #include "nsIStringBundle.h"
70324: #include "nsIConsoleService.h"
70324: #include "nsIObserverService.h"
70324: #include "nsIScriptObjectPrincipal.h"
70324: #include "jsdbgapi.h"
70324: #include "nsJSUtils.h"
70324: #include "nsIAsyncVerifyRedirectCallback.h"
70324: #include "nsIScriptError.h"
70324: #include "nsICharsetConverterManager.h"
70324: #include "nsIChannelPolicy.h"
70324: #include "nsIContentSecurityPolicy.h"
75263: #include "nsContentUtils.h"
70840: #include "mozilla/Preferences.h"
79460: #include "xpcpublic.h"
84054: #include "nsCrossSiteListenerProxy.h"
88267: #include "nsWrapperCacheInlines.h"
89667: #include "nsDOMEventTargetHelper.h"
70840: 
70840: using namespace mozilla;
70324: 
70324: #define REPLACEMENT_CHAR     (PRUnichar)0xFFFD
70324: #define BOM_CHAR             (PRUnichar)0xFEFF
70324: #define SPACE_CHAR           (PRUnichar)0x0020
70324: #define CR_CHAR              (PRUnichar)0x000D
70324: #define LF_CHAR              (PRUnichar)0x000A
70324: #define COLON_CHAR           (PRUnichar)0x003A
70324: 
70324: #define DEFAULT_BUFFER_SIZE 4096
70324: 
70324: // Reconnection time related values in milliseconds. The default one is equal
70324: // to the default value of the pref dom.server-events.default-reconnection-time
70324: #define MIN_RECONNECTION_TIME_VALUE       500
70324: #define DEFAULT_RECONNECTION_TIME_VALUE   5000
70324: #define MAX_RECONNECTION_TIME_VALUE       PR_IntervalToMilliseconds(DELAY_INTERVAL_LIMIT)
70324: 
70324: nsEventSource::nsEventSource() :
70324:   mStatus(PARSE_STATE_OFF),
80486:   mFrozen(false),
80486:   mErrorLoadOnRedirect(false),
80486:   mGoingToDispatchAllMessages(false),
84054:   mWithCredentials(false),
90244:   mWaitingForOnStopRequest(false),
70324:   mLastConvertionResult(NS_OK),
70324:   mReadyState(nsIEventSource::CONNECTING),
70324:   mScriptLine(0),
77330:   mInnerWindowID(0)
70324: {
70324: }
70324: 
70324: nsEventSource::~nsEventSource()
70324: {
70324:   Close();
70324: }
70324: 
70324: //-----------------------------------------------------------------------------
70324: // nsEventSource::nsISupports
70324: //-----------------------------------------------------------------------------
70324: 
70324: NS_IMPL_CYCLE_COLLECTION_CLASS(nsEventSource)
70324: 
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsEventSource)
90244:   bool isBlack = tmp->IsBlack();
90244:   if (isBlack || tmp->mWaitingForOnStopRequest) {
88267:     if (tmp->mListenerManager) {
88267:       tmp->mListenerManager->UnmarkGrayJSListeners();
88267:       NS_UNMARK_LISTENER_WRAPPER(Open)
88267:       NS_UNMARK_LISTENER_WRAPPER(Message)
88267:       NS_UNMARK_LISTENER_WRAPPER(Error)
88267:     }
90244:     if (!isBlack) {
90244:       xpc_UnmarkGrayObject(tmp->PreservingWrapper() ? 
90244:                            tmp->GetWrapperPreserveColor() :
90244:                            tmp->GetExpandoObjectPreserveColor());
90244:     }
88267:     return true;
88267:   }
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
88267: 
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsEventSource)
88267:   return tmp->IsBlack();
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
88267: 
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsEventSource)
88267:   return tmp->IsBlack();
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
88267: 
88267: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(nsEventSource,
89667:                                                nsDOMEventTargetHelper)
88267: NS_IMPL_CYCLE_COLLECTION_TRACE_END
88267: 
70324: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsEventSource,
89667:                                                   nsDOMEventTargetHelper)
70324:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSrc)
70324:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNotificationCallbacks)
70324:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLoadGroup)
70324:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannelEventSink)
70324:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mHttpChannel)
70324:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTimer)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnOpenListener)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnMessageListener)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnErrorListener)
70324:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mUnicodeDecoder)
70324: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
70324: 
89667: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsEventSource, nsDOMEventTargetHelper)
70324:   tmp->Close();
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnOpenListener)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnMessageListener)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnErrorListener)
70324: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
70324: 
70324: DOMCI_DATA(EventSource, nsEventSource)
70324: 
70324: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsEventSource)
70324:   NS_INTERFACE_MAP_ENTRY(nsIEventSource)
70324:   NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
70324:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
70324:   NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
70324:   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
70324:   NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
70324:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
70324:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
70324:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(EventSource)
89667: NS_INTERFACE_MAP_END_INHERITING(nsDOMEventTargetHelper)
70324: 
89667: NS_IMPL_ADDREF_INHERITED(nsEventSource, nsDOMEventTargetHelper)
89667: NS_IMPL_RELEASE_INHERITED(nsEventSource, nsDOMEventTargetHelper)
70324: 
70324: //-----------------------------------------------------------------------------
70324: // nsEventSource::nsIEventSource
70324: //-----------------------------------------------------------------------------
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::GetUrl(nsAString& aURL)
70324: {
70324:   aURL = mOriginalURL;
70324:   return NS_OK;
70324: }
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::GetReadyState(PRInt32 *aReadyState)
70324: {
70324:   NS_ENSURE_ARG_POINTER(aReadyState);
70324:   *aReadyState = mReadyState;
70324:   return NS_OK;
70324: }
70324: 
84054: NS_IMETHODIMP
84054: nsEventSource::GetWithCredentials(bool *aWithCredentials)
84054: {
84054:   NS_ENSURE_ARG_POINTER(aWithCredentials);
84054:   *aWithCredentials = mWithCredentials;
84054:   return NS_OK;
84054: }
84054: 
79469: #define NS_EVENTSRC_IMPL_DOMEVENTLISTENER(_eventlistenername, _eventlistener)  \
79469:   NS_IMETHODIMP                                                                \
79469:   nsEventSource::GetOn##_eventlistenername(nsIDOMEventListener * *aListener)   \
79469:   {                                                                            \
79469:     return GetInnerEventListener(_eventlistener, aListener);                   \
79469:   }                                                                            \
79469:                                                                                \
79469:   NS_IMETHODIMP                                                                \
79469:   nsEventSource::SetOn##_eventlistenername(nsIDOMEventListener * aListener)    \
79469:   {                                                                            \
79469:     return RemoveAddEventListener(NS_LITERAL_STRING(#_eventlistenername),      \
79469:                                   _eventlistener, aListener);                  \
79469:   }
79469: 
79469: NS_EVENTSRC_IMPL_DOMEVENTLISTENER(open, mOnOpenListener)
79469: NS_EVENTSRC_IMPL_DOMEVENTLISTENER(error, mOnErrorListener)
79469: NS_EVENTSRC_IMPL_DOMEVENTLISTENER(message, mOnMessageListener)
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::Close()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return NS_OK;
70324:   }
70324: 
70324:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
70324:   if (os) {
70324:     os->RemoveObserver(this, DOM_WINDOW_DESTROYED_TOPIC);
70324:     os->RemoveObserver(this, DOM_WINDOW_FROZEN_TOPIC);
70324:     os->RemoveObserver(this, DOM_WINDOW_THAWED_TOPIC);
70324:   }
70324: 
70324:   if (mTimer) {
70324:     mTimer->Cancel();
70324:     mTimer = nsnull;
70324:   }
70324: 
70324:   ResetConnection();
70324: 
70324:   ClearFields();
70324: 
70324:   while (mMessagesToDispatch.GetSize() != 0) {
70324:     delete static_cast<Message*>(mMessagesToDispatch.PopFront());
70324:   }
70324: 
70324:   mSrc = nsnull;
80486:   mFrozen = false;
70324: 
70324:   mScriptContext = nsnull;
70324:   mOwner = nsnull;
70324: 
70324:   mUnicodeDecoder = nsnull;
70324: 
70324:   mReadyState = nsIEventSource::CLOSED;
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: /**
70324:  * This Init method should only be called by C++ consumers.
70324:  */
70324: NS_IMETHODIMP
70324: nsEventSource::Init(nsIPrincipal* aPrincipal,
70324:                     nsIScriptContext* aScriptContext,
70324:                     nsPIDOMWindow* aOwnerWindow,
84054:                     const nsAString& aURL,
84054:                     bool aWithCredentials)
70324: {
70324:   NS_ENSURE_ARG(aPrincipal);
70324: 
70324:   if (mReadyState != nsIEventSource::CONNECTING || !PrefEnabled()) {
70324:     return NS_ERROR_DOM_SECURITY_ERR;
70324:   }
70324: 
70324:   mPrincipal = aPrincipal;
70324:   mScriptContext = aScriptContext;
84054:   mWithCredentials = aWithCredentials;
70324:   if (aOwnerWindow) {
70324:     mOwner = aOwnerWindow->IsOuterWindow() ?
70324:       aOwnerWindow->GetCurrentInnerWindow() : aOwnerWindow;
70324:   } else {
70324:     mOwner = nsnull;
70324:   }
70324: 
70324:   nsCOMPtr<nsIJSContextStack> stack =
70324:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
70324:   JSContext* cx = nsnull;
70324:   if (stack && NS_SUCCEEDED(stack->Peek(&cx)) && cx) {
70324:     const char *filename;
70324:     if (nsJSUtils::GetCallingLocation(cx, &filename, &mScriptLine)) {
70324:       mScriptFile.AssignASCII(filename);
70324:     }
70324: 
77330:     mInnerWindowID = nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(cx);
70324:   }
70324: 
70324:   // Get the load group for the page. When requesting we'll add ourselves to it.
70324:   // This way any pending requests will be automatically aborted if the user
70324:   // leaves the page.
70324:   if (mScriptContext) {
70324:     nsCOMPtr<nsIDocument> doc =
70324:       nsContentUtils::GetDocumentFromScriptContext(mScriptContext);
70324:     if (doc) {
70324:       mLoadGroup = doc->GetDocumentLoadGroup();
70324:     }
70324:   }
70324: 
70324:   // get the src
70324:   nsCOMPtr<nsIURI> baseURI;
70324:   nsresult rv = GetBaseURI(getter_AddRefs(baseURI));
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   nsCOMPtr<nsIURI> srcURI;
70324:   rv = NS_NewURI(getter_AddRefs(srcURI), aURL, nsnull, baseURI);
70324:   NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SYNTAX_ERR);
70324: 
70324:   // we observe when the window freezes and thaws
70324:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
70324:   NS_ENSURE_STATE(os);
70324: 
80486:   rv = os->AddObserver(this, DOM_WINDOW_DESTROYED_TOPIC, true);
70324:   NS_ENSURE_SUCCESS(rv, rv);
80486:   rv = os->AddObserver(this, DOM_WINDOW_FROZEN_TOPIC, true);
70324:   NS_ENSURE_SUCCESS(rv, rv);
80486:   rv = os->AddObserver(this, DOM_WINDOW_THAWED_TOPIC, true);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
84054:   nsAutoString origin;
84054:   rv = nsContentUtils::GetUTFOrigin(srcURI, origin);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   nsCAutoString spec;
70324:   rv = srcURI->GetSpec(spec);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   mOriginalURL = NS_ConvertUTF8toUTF16(spec);
70324:   mSrc = srcURI;
70324:   mOrigin = origin;
70324: 
70324:   mReconnectionTime =
70842:     Preferences::GetInt("dom.server-events.default-reconnection-time",
70324:                         DEFAULT_RECONNECTION_TIME_VALUE);
70324: 
70324:   nsCOMPtr<nsICharsetConverterManager> convManager =
70324:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   rv = convManager->GetUnicodeDecoder("UTF-8", getter_AddRefs(mUnicodeDecoder));
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324:   mUnicodeDecoder->SetInputErrorBehavior(nsIUnicodeDecoder::kOnError_Recover);
70324: 
70324:   // the constructor should throw a SYNTAX_ERROR only if it fails resolving the
70324:   // url parameter, so we don't care about the InitChannelAndRequestEventSource
70324:   // result.
70324:   InitChannelAndRequestEventSource();
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: //-----------------------------------------------------------------------------
70324: // nsEventSource::nsIJSNativeInitializer methods:
70324: //-----------------------------------------------------------------------------
70324: 
70324: /**
70324:  * This Initialize method is called from XPConnect via nsIJSNativeInitializer.
70324:  * It is used for constructing our nsEventSource from javascript. It expects a
70324:  * URL string parameter. Also, initializes the principal, the script context
70324:  * and the window owner.
70324:  */
70324: NS_IMETHODIMP
70324: nsEventSource::Initialize(nsISupports* aOwner,
70324:                           JSContext* aContext,
70324:                           JSObject* aObject,
70324:                           PRUint32 aArgc,
70324:                           jsval* aArgv)
70324: {
70324:   if (mReadyState != nsIEventSource::CONNECTING || !PrefEnabled() ||
70324:       aArgc < 1) {
70324:     return NS_ERROR_FAILURE;
70324:   }
70324: 
70324:   JSAutoRequest ar(aContext);
70324: 
70324:   JSString* jsstr = JS_ValueToString(aContext, aArgv[0]);
70324:   if (!jsstr) {
70324:     return NS_ERROR_DOM_SYNTAX_ERR;
70324:   }
70324: 
70324:   JS::Anchor<JSString *> deleteProtector(jsstr);
70324:   size_t length;
70324:   const jschar *chars = JS_GetStringCharsAndLength(aContext, jsstr, &length);
70324:   if (!chars) {
70324:     return NS_ERROR_OUT_OF_MEMORY;
70324:   }
70324: 
70324:   nsAutoString urlParam;
70324: 
70324:   urlParam.Assign(chars, length);
70324: 
70324:   nsCOMPtr<nsPIDOMWindow> ownerWindow = do_QueryInterface(aOwner);
70324:   NS_ENSURE_STATE(ownerWindow);
70324: 
70324:   nsCOMPtr<nsIScriptGlobalObject> sgo = do_QueryInterface(aOwner);
70324:   NS_ENSURE_STATE(sgo);
70324:   nsCOMPtr<nsIScriptContext> scriptContext = sgo->GetContext();
70324:   NS_ENSURE_STATE(scriptContext);
70324: 
70324:   nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal =
70324:     do_QueryInterface(aOwner);
70324:   NS_ENSURE_STATE(scriptPrincipal);
70324:   nsCOMPtr<nsIPrincipal> principal = scriptPrincipal->GetPrincipal();
70324:   NS_ENSURE_STATE(principal);
70324: 
84054:   bool withCredentialsParam = false;
84054:   if (aArgc >= 2) {
84054:     NS_ENSURE_TRUE(!JSVAL_IS_PRIMITIVE(aArgv[1]), NS_ERROR_INVALID_ARG);
84054: 
84054:     JSObject *obj = JSVAL_TO_OBJECT(aArgv[1]);
84054:     NS_ASSERTION(obj, "obj shouldn't be null!!");
84054: 
84054:     JSBool hasProperty = JS_FALSE;
84054:     NS_ENSURE_TRUE(JS_HasProperty(aContext, obj, "withCredentials",
84054:                                   &hasProperty), NS_ERROR_FAILURE);
84054: 
84054:     if (hasProperty) {
84054:       jsval withCredentialsVal;
84054:       NS_ENSURE_TRUE(JS_GetProperty(aContext, obj, "withCredentials",
84054:                                     &withCredentialsVal), NS_ERROR_FAILURE);
84054: 
84054:       JSBool withCredentials = JS_FALSE;
84054:       NS_ENSURE_TRUE(JS_ValueToBoolean(aContext, withCredentialsVal,
84054:                                        &withCredentials), NS_ERROR_FAILURE);
84054:       withCredentialsParam = !!withCredentials;
84054:     }
84054:   }
84054: 
84054:   return Init(principal, scriptContext, ownerWindow,
84054:               urlParam, withCredentialsParam);
70324: }
70324: 
70324: //-----------------------------------------------------------------------------
70324: // nsEventSource::nsIObserver
70324: //-----------------------------------------------------------------------------
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::Observe(nsISupports* aSubject,
70324:                        const char* aTopic,
70324:                        const PRUnichar* aData)
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return NS_OK;
70324:   }
70324: 
70324:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aSubject);
70324:   if (!mOwner || window != mOwner) {
70324:     return NS_OK;
70324:   }
70324: 
70325:   nsresult rv;
70324:   if (strcmp(aTopic, DOM_WINDOW_FROZEN_TOPIC) == 0) {
70324:     rv = Freeze();
70324:     NS_ASSERTION(rv, "Freeze() failed");
70324:   } else if (strcmp(aTopic, DOM_WINDOW_THAWED_TOPIC) == 0) {
70324:     rv = Thaw();
70324:     NS_ASSERTION(rv, "Thaw() failed");
70324:   } else if (strcmp(aTopic, DOM_WINDOW_DESTROYED_TOPIC) == 0) {
70324:     Close();
70324:   }
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: //-----------------------------------------------------------------------------
70324: // nsEventSource::nsIStreamListener
70324: //-----------------------------------------------------------------------------
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::OnStartRequest(nsIRequest *aRequest,
70324:                               nsISupports *ctxt)
70324: {
70324:   nsresult rv = CheckHealthOfRequestCallback(aRequest);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aRequest, &rv);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
79445:   bool requestSucceeded;
70324:   rv = httpChannel->GetRequestSucceeded(&requestSucceeded);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   nsCAutoString contentType;
70324:   rv = httpChannel->GetContentType(contentType);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   if (!requestSucceeded || !contentType.EqualsLiteral(TEXT_EVENT_STREAM)) {
70324:     DispatchFailConnection();
70324:     return NS_ERROR_NOT_AVAILABLE;
70324:   }
70324: 
70324:   nsCOMPtr<nsIPrincipal> principal = mPrincipal;
70324:   if (nsContentUtils::IsSystemPrincipal(principal)) {
70324:     // Don't give this channel the system principal.
70324:     principal = do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
70324:     NS_ENSURE_SUCCESS(rv, rv);
70324:   }
70324:   rv = httpChannel->SetOwner(principal);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   nsCOMPtr<nsIRunnable> event =
70324:     NS_NewRunnableMethod(this, &nsEventSource::AnnounceConnection);
70324:   NS_ENSURE_STATE(event);
70324: 
70324:   rv = NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   mStatus = PARSE_STATE_BEGIN_OF_STREAM;
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: // this method parses the characters as they become available instead of
70324: // buffering them.
70324: NS_METHOD
70324: nsEventSource::StreamReaderFunc(nsIInputStream *aInputStream,
70324:                                 void *aClosure,
70324:                                 const char *aFromRawSegment,
70324:                                 PRUint32 aToOffset,
70324:                                 PRUint32 aCount,
70324:                                 PRUint32 *aWriteCount)
70324: {
70324:   nsEventSource* thisObject = static_cast<nsEventSource*>(aClosure);
70324:   if (!thisObject || !aWriteCount) {
70324:     NS_WARNING("nsEventSource cannot read from stream: no aClosure or aWriteCount");
70324:     return NS_ERROR_FAILURE;
70324:   }
70324: 
70324:   *aWriteCount = 0;
70324: 
70324:   PRInt32 srcCount, outCount;
70324:   PRUnichar out[2];
70324:   nsresult rv;
70324: 
70324:   const char *p = aFromRawSegment,
70324:              *end = aFromRawSegment + aCount;
70324: 
70324:   do {
70324:     srcCount = aCount - (p - aFromRawSegment);
70324:     outCount = 2;
70324: 
70324:     thisObject->mLastConvertionResult =
70324:       thisObject->mUnicodeDecoder->Convert(p, &srcCount, out, &outCount);
70324: 
70324:     if (thisObject->mLastConvertionResult == NS_ERROR_ILLEGAL_INPUT) {
70324:       // There's an illegal byte in the input. It's now the responsibility
70324:       // of this calling code to output a U+FFFD REPLACEMENT CHARACTER, advance
70324:       // over the bad byte and reset the decoder.
70324:       rv = thisObject->ParseCharacter(REPLACEMENT_CHAR);
70324:       NS_ENSURE_SUCCESS(rv, rv);
70324:       p = p + srcCount + 1;
70324:       thisObject->mUnicodeDecoder->Reset();
70324:     } else {
70324:       for (PRInt32 i = 0; i < outCount; ++i) {
70324:         rv = thisObject->ParseCharacter(out[i]);
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324:       }
70324:       p = p + srcCount;
70324:     }
70324:   } while (p < end &&
70324:            thisObject->mLastConvertionResult != NS_PARTIAL_MORE_INPUT &&
70324:            thisObject->mLastConvertionResult != NS_OK);
70324: 
70324:   // check if the last byte was a bad one and
70324:   // clear the state since it was handled above.
70324:   if (thisObject->mLastConvertionResult == NS_ERROR_ILLEGAL_INPUT) {
70324:     thisObject->mLastConvertionResult = NS_OK;
70324:   }
70324: 
70324:   *aWriteCount = aCount;
70324:   return NS_OK;
70324: }
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::OnDataAvailable(nsIRequest *aRequest,
70324:                                nsISupports *aContext,
70324:                                nsIInputStream *aInputStream,
70324:                                PRUint32 aOffset,
70324:                                PRUint32 aCount)
70324: {
70324:   NS_ENSURE_ARG_POINTER(aInputStream);
70324: 
70324:   nsresult rv = CheckHealthOfRequestCallback(aRequest);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   PRUint32 totalRead;
70324:   return aInputStream->ReadSegments(nsEventSource::StreamReaderFunc, this,
70324:                                     aCount, &totalRead);
70324: }
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::OnStopRequest(nsIRequest *aRequest,
70324:                              nsISupports *aContext,
70324:                              nsresult aStatusCode)
70324: {
90244:   mWaitingForOnStopRequest = false;
90244: 
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return NS_ERROR_ABORT;
70324:   }
70324: 
70324:   if (NS_FAILED(aStatusCode)) {
70324:     DispatchFailConnection();
70324:     return aStatusCode;
70324:   }
70324: 
70324:   nsresult rv;
70324:   nsresult healthOfRequestResult = CheckHealthOfRequestCallback(aRequest);
70324:   if (NS_SUCCEEDED(healthOfRequestResult)) {
70324:     // check if we had an incomplete UTF8 char at the end of the stream
70324:     if (mLastConvertionResult == NS_PARTIAL_MORE_INPUT) {
70324:       rv = ParseCharacter(REPLACEMENT_CHAR);
70324:       NS_ENSURE_SUCCESS(rv, rv);
70324:     }
70324: 
70324:     // once we reach the end of the stream we must
70324:     // dispatch the current event
70324:     switch (mStatus)
70324:     {
70324:       case PARSE_STATE_CR_CHAR:
70324:       case PARSE_STATE_COMMENT:
70324:       case PARSE_STATE_FIELD_NAME:
70324:       case PARSE_STATE_FIRST_CHAR_OF_FIELD_VALUE:
70324:       case PARSE_STATE_FIELD_VALUE:
70324:       case PARSE_STATE_BEGIN_OF_LINE:
70324:         rv = SetFieldAndClear();
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         rv = DispatchCurrentMessageEvent();  // there is an empty line (CRCR)
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         break;
70324: 
70324:       // Just for not getting warnings when compiling
70324:       case PARSE_STATE_OFF:
70324:       case PARSE_STATE_BEGIN_OF_STREAM:
70324:       case PARSE_STATE_BOM_WAS_READ:
70324:         break;
70324:     }
70324:   }
70324: 
70324:   nsCOMPtr<nsIRunnable> event =
70324:     NS_NewRunnableMethod(this, &nsEventSource::ReestablishConnection);
70324:   NS_ENSURE_STATE(event);
70324: 
70324:   rv = NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   return healthOfRequestResult;
70324: }
70324: 
70324: /**
70324:  * Simple helper class that just forwards the redirect callback back
70324:  * to the nsEventSource.
70324:  */
70324: class AsyncVerifyRedirectCallbackFwr : public nsIAsyncVerifyRedirectCallback
70324: {
70324: public:
70324:   AsyncVerifyRedirectCallbackFwr(nsEventSource* aEventsource)
70324:     : mEventSource(aEventsource)
70324:   {
70324:   }
70324: 
70324:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
70324:   NS_DECL_CYCLE_COLLECTION_CLASS(AsyncVerifyRedirectCallbackFwr)
70324: 
70324:   // nsIAsyncVerifyRedirectCallback implementation
70324:   NS_IMETHOD OnRedirectVerifyCallback(nsresult aResult)
70324:   {
70324:     nsresult rv = mEventSource->OnRedirectVerifyCallback(aResult);
70324:     if (NS_FAILED(rv)) {
80486:       mEventSource->mErrorLoadOnRedirect = true;
70324:       mEventSource->DispatchFailConnection();
70324:     }
70324: 
70324:     return NS_OK;
70324:   }
70324: 
70324: private:
70324:   nsRefPtr<nsEventSource> mEventSource;
70324: };
70324: 
70324: NS_IMPL_CYCLE_COLLECTION_CLASS(AsyncVerifyRedirectCallbackFwr)
70324: 
70324: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(AsyncVerifyRedirectCallbackFwr)
70324:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mEventSource, nsIEventSource)
70324: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
70324: 
70324: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(AsyncVerifyRedirectCallbackFwr)
70324:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mEventSource)
70324: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
70324: 
70324: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(AsyncVerifyRedirectCallbackFwr)
70324:   NS_INTERFACE_MAP_ENTRY(nsISupports)
70324:   NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
70324: NS_INTERFACE_MAP_END
70324: 
70324: NS_IMPL_CYCLE_COLLECTING_ADDREF(AsyncVerifyRedirectCallbackFwr)
70324: NS_IMPL_CYCLE_COLLECTING_RELEASE(AsyncVerifyRedirectCallbackFwr)
70324: 
70324: //-----------------------------------------------------------------------------
70324: // nsEventSource::nsIChannelEventSink
70324: //-----------------------------------------------------------------------------
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
70324:                                       nsIChannel *aNewChannel,
70324:                                       PRUint32    aFlags,
70324:                                       nsIAsyncVerifyRedirectCallback *aCallback)
70324: {
70324:   nsCOMPtr<nsIRequest> aOldRequest = do_QueryInterface(aOldChannel);
70324:   NS_PRECONDITION(aOldRequest, "Redirect from a null request?");
70324: 
70324:   nsresult rv = CheckHealthOfRequestCallback(aOldRequest);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   NS_PRECONDITION(aNewChannel, "Redirect without a channel?");
70324: 
70324:   nsCOMPtr<nsIURI> newURI;
70324:   rv = NS_GetFinalChannelURI(aNewChannel, getter_AddRefs(newURI));
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   if (!CheckCanRequestSrc(newURI)) {
70324:     DispatchFailConnection();
70324:     return NS_ERROR_DOM_SECURITY_ERR;
70324:   }
70324: 
70324:   // Prepare to receive callback
70324:   mRedirectFlags = aFlags;
70324:   mRedirectCallback = aCallback;
70324:   mNewRedirectChannel = aNewChannel;
70324: 
70324:   if (mChannelEventSink) {
70324:     nsRefPtr<AsyncVerifyRedirectCallbackFwr> fwd =
70324:       new AsyncVerifyRedirectCallbackFwr(this);
70324: 
70324:     rv = mChannelEventSink->AsyncOnChannelRedirect(aOldChannel,
70324:                                                    aNewChannel,
70324:                                                    aFlags, fwd);
70324:     if (NS_FAILED(rv)) {
70324:       mRedirectCallback = nsnull;
70324:       mNewRedirectChannel = nsnull;
80486:       mErrorLoadOnRedirect = true;
70324:       DispatchFailConnection();
70324:     }
70324:     return rv;
70324:   }
70324:   OnRedirectVerifyCallback(NS_OK);
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::OnRedirectVerifyCallback(nsresult aResult)
70324: {
70324:   NS_ABORT_IF_FALSE(mRedirectCallback, "mRedirectCallback not set in callback");
70324:   NS_ABORT_IF_FALSE(mNewRedirectChannel,
70324:                     "mNewRedirectChannel not set in callback");
70324: 
70324:   NS_ENSURE_SUCCESS(aResult, aResult);
70324: 
70324:   // update our channel
70324: 
70324:   mHttpChannel = do_QueryInterface(mNewRedirectChannel);
70324:   NS_ENSURE_STATE(mHttpChannel);
70324: 
70324:   nsresult rv = SetupHttpChannel();
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   if ((mRedirectFlags & nsIChannelEventSink::REDIRECT_PERMANENT) != 0) {
70324:     rv = NS_GetFinalChannelURI(mHttpChannel, getter_AddRefs(mSrc));
70324:     NS_ENSURE_SUCCESS(rv, rv);
70324:   }
70324: 
70324:   mNewRedirectChannel = nsnull;
70324: 
70324:   mRedirectCallback->OnRedirectVerifyCallback(aResult);
70324:   mRedirectCallback = nsnull;
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: //-----------------------------------------------------------------------------
70324: // nsEventSource::nsIInterfaceRequestor
70324: //-----------------------------------------------------------------------------
70324: 
70324: NS_IMETHODIMP
70324: nsEventSource::GetInterface(const nsIID & aIID,
70324:                             void **aResult)
70324: {
70324:   // Make sure to return ourselves for the channel event sink interface,
70324:   // no matter what.  We can forward these to mNotificationCallbacks
70324:   // if it wants to get notifications for them.  But we
70324:   // need to see these notifications for proper functioning.
70324:   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
70324:     mChannelEventSink = do_GetInterface(mNotificationCallbacks);
70324:     *aResult = static_cast<nsIChannelEventSink*>(this);
70324:     NS_ADDREF_THIS();
70324:     return NS_OK;
70324:   }
70324: 
70324:   // Now give mNotificationCallbacks (if non-null) a chance to return the
70324:   // desired interface.
70324:   if (mNotificationCallbacks) {
70324:     nsresult rv = mNotificationCallbacks->GetInterface(aIID, aResult);
70324:     if (NS_SUCCEEDED(rv)) {
70324:       NS_ASSERTION(*aResult, "Lying nsIInterfaceRequestor implementation!");
70324:       return rv;
70324:     }
70324:   }
70324: 
70324:   if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
70324:       aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
70324:     nsresult rv = CheckInnerWindowCorrectness();
70324:     NS_ENSURE_SUCCESS(rv, NS_ERROR_UNEXPECTED);
70324: 
70324:     nsCOMPtr<nsIPromptFactory> wwatch =
70324:       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
70324:     NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:     // Get the an auth prompter for our window so that the parenting
70324:     // of the dialogs works as it should when using tabs.
70324: 
70324:     nsCOMPtr<nsIDOMWindow> window;
70324:     if (mOwner) {
70324:       window = mOwner->GetOuterWindow();
70324:     }
70324: 
70324:     return wwatch->GetPrompt(window, aIID, aResult);
70324:   }
70324: 
70324:   return QueryInterface(aIID, aResult);
70324: }
70324: 
70324: // static
79445: bool
70324: nsEventSource::PrefEnabled()
70324: {
79445:   return Preferences::GetBool("dom.server-events.enabled", false);
70324: }
70324: 
70324: nsresult
70324: nsEventSource::GetBaseURI(nsIURI **aBaseURI)
70324: {
70324:   NS_ENSURE_ARG_POINTER(aBaseURI);
70324: 
70324:   *aBaseURI = nsnull;
70324: 
70324:   nsCOMPtr<nsIURI> baseURI;
70324: 
70324:   // first we try from document->GetBaseURI()
70324:   nsCOMPtr<nsIDocument> doc =
70324:     nsContentUtils::GetDocumentFromScriptContext(mScriptContext);
70324:   if (doc) {
70324:     baseURI = doc->GetBaseURI();
70324:   }
70324: 
70324:   // otherwise we get from the doc's principal
70324:   if (!baseURI) {
70324:     nsresult rv = mPrincipal->GetURI(getter_AddRefs(baseURI));
70324:     NS_ENSURE_SUCCESS(rv, rv);
70324:   }
70324: 
70324:   NS_ENSURE_STATE(baseURI);
70324: 
70324:   baseURI.forget(aBaseURI);
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::SetupHttpChannel()
70324: {
70324:   mHttpChannel->SetRequestMethod(NS_LITERAL_CSTRING("GET"));
70324: 
70324:   /* set the http request headers */
70324: 
70324:   mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Accept"),
80486:     NS_LITERAL_CSTRING(TEXT_EVENT_STREAM), false);
70324: 
70324:   // LOAD_BYPASS_CACHE already adds the Cache-Control: no-cache header
70324: 
70324:   if (!mLastEventID.IsEmpty()) {
70324:     mHttpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Last-Event-ID"),
80486:       NS_ConvertUTF16toUTF8(mLastEventID), false);
70324:   }
70324: 
70324:   nsCOMPtr<nsIURI> codebase;
70324:   nsresult rv = GetBaseURI(getter_AddRefs(codebase));
70324:   if (NS_SUCCEEDED(rv)) {
70324:     rv = mHttpChannel->SetReferrer(codebase);
70324:     NS_ENSURE_SUCCESS(rv, rv);
70324:   }
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::InitChannelAndRequestEventSource()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return NS_ERROR_ABORT;
70324:   }
70324: 
70324:   // eventsource validation
70324: 
70324:   if (!CheckCanRequestSrc()) {
70324:     DispatchFailConnection();
70324:     return NS_ERROR_DOM_SECURITY_ERR;
70324:   }
70324: 
70324:   nsLoadFlags loadFlags;
70324:   loadFlags = nsIRequest::LOAD_BACKGROUND | nsIRequest::LOAD_BYPASS_CACHE;
70324: 
70324:   // get Content Security Policy from principal to pass into channel
70324:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
70324:   nsCOMPtr<nsIContentSecurityPolicy> csp;
70324:   nsresult rv = mPrincipal->GetCsp(getter_AddRefs(csp));
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324:   if (csp) {
70324:     channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
70324:     channelPolicy->SetContentSecurityPolicy(csp);
81091:     channelPolicy->SetLoadType(nsIContentPolicy::TYPE_DATAREQUEST);
70324:   }
70324: 
70324:   nsCOMPtr<nsIChannel> channel;
70324:   rv = NS_NewChannel(getter_AddRefs(channel), mSrc, nsnull, mLoadGroup,
70324:                      nsnull, loadFlags, channelPolicy);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   mHttpChannel = do_QueryInterface(channel);
70324:   NS_ENSURE_TRUE(mHttpChannel, NS_ERROR_NO_INTERFACE);
70324: 
70324:   rv = SetupHttpChannel();
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
90939:   nsCOMPtr<nsIInterfaceRequestor> notificationCallbacks;
90939:   mHttpChannel->GetNotificationCallbacks(getter_AddRefs(notificationCallbacks));
90939:   if (notificationCallbacks != this) {
90939:     mNotificationCallbacks = notificationCallbacks;
90939:     mHttpChannel->SetNotificationCallbacks(this);
90939:   }
90939: 
84054:   nsCOMPtr<nsIStreamListener> listener =
84054:     new nsCORSListenerProxy(this, mPrincipal, mHttpChannel,
84054:                             mWithCredentials, &rv);
84054:   NS_ENSURE_SUCCESS(rv, rv);
84054: 
70324:   // Start reading from the channel
90244:   rv = mHttpChannel->AsyncOpen(listener, nsnull);
90244:   if (NS_SUCCEEDED(rv)) {
90244:     mWaitingForOnStopRequest = true;
90244:   }
90244:   return rv;
70324: }
70324: 
70324: void
70324: nsEventSource::AnnounceConnection()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return;
70324:   }
70324: 
70324:   if (mReadyState != nsIEventSource::CONNECTING) {
70324:     NS_WARNING("Unexpected mReadyState!!!");
70324:     return;
70324:   }
70324: 
70324:   // When a user agent is to announce the connection, the user agent must set
70324:   // the readyState attribute to OPEN and queue a task to fire a simple event
70324:   // named open at the EventSource object.
70324: 
70324:   mReadyState = nsIEventSource::OPEN;
70324: 
70324:   nsresult rv = CheckInnerWindowCorrectness();
70324:   if (NS_FAILED(rv)) {
70324:     return;
70324:   }
70324: 
70324:   nsCOMPtr<nsIDOMEvent> event;
70324:   rv = NS_NewDOMEvent(getter_AddRefs(event), nsnull, nsnull);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to create the open event!!!");
70324:     return;
70324:   }
70324: 
70324:   // it doesn't bubble, and it isn't cancelable
80486:   rv = event->InitEvent(NS_LITERAL_STRING("open"), false, false);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to init the open event!!!");
70324:     return;
70324:   }
70324: 
70324:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(event);
80486:   privateEvent->SetTrusted(true);
70324: 
70324:   rv = DispatchDOMEvent(nsnull, event, nsnull, nsnull);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to dispatch the open event!!!");
70324:     return;
70324:   }
70324: }
70324: 
70324: nsresult
70324: nsEventSource::ResetConnection()
70324: {
70324:   if (mHttpChannel) {
70324:     mHttpChannel->Cancel(NS_ERROR_ABORT);
70324:   }
70324: 
70324:   if (mUnicodeDecoder) {
70324:     mUnicodeDecoder->Reset();
70324:   }
70324:   mLastConvertionResult = NS_OK;
70324: 
70324:   mHttpChannel = nsnull;
70324:   mNotificationCallbacks = nsnull;
70324:   mChannelEventSink = nsnull;
70324:   mStatus = PARSE_STATE_OFF;
70324:   mRedirectCallback = nsnull;
70324:   mNewRedirectChannel = nsnull;
70324: 
70324:   mReadyState = nsIEventSource::CONNECTING;
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: void
70324: nsEventSource::ReestablishConnection()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return;
70324:   }
70324: 
70324:   if (mReadyState != nsIEventSource::OPEN) {
70324:     NS_WARNING("Unexpected mReadyState!!!");
70324:     return;
70324:   }
70324: 
70324:   nsresult rv = ResetConnection();
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to reset the connection!!!");
70324:     return;
70324:   }
70324: 
70324:   rv = CheckInnerWindowCorrectness();
70324:   if (NS_FAILED(rv)) {
70324:     return;
70324:   }
70324: 
70324:   nsCOMPtr<nsIDOMEvent> event;
70324:   rv = NS_NewDOMEvent(getter_AddRefs(event), nsnull, nsnull);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to create the error event!!!");
70324:     return;
70324:   }
70324: 
70324:   // it doesn't bubble, and it isn't cancelable
80486:   rv = event->InitEvent(NS_LITERAL_STRING("error"), false, false);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to init the error event!!!");
70324:     return;
70324:   }
70324: 
70324:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(event);
80486:   privateEvent->SetTrusted(true);
70324: 
70324:   rv = DispatchDOMEvent(nsnull, event, nsnull, nsnull);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to dispatch the error event!!!");
70324:     return;
70324:   }
70324: 
70324:   rv = SetReconnectionTimeout();
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to set the timeout for reestablishing the connection!!!");
70324:     return;
70324:   }
70324: }
70324: 
70324: nsresult
70324: nsEventSource::SetReconnectionTimeout()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return NS_ERROR_ABORT;
70324:   }
70324: 
70324:   // the timer will be used whenever the requests are going finished.
70324:   if (!mTimer) {
70324:     mTimer = do_CreateInstance("@mozilla.org/timer;1");
70324:     NS_ENSURE_STATE(mTimer);
70324:   }
70324: 
70324:   NS_ASSERTION(mReconnectionTime >= 0, "mReconnectionTime lies");
70324:   nsresult rv = mTimer->InitWithFuncCallback(TimerCallback, this,
70324:                                              mReconnectionTime,
70324:                                              nsITimer::TYPE_ONE_SHOT);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::PrintErrorOnConsole(const char *aBundleURI,
70324:                                    const PRUnichar *aError,
70324:                                    const PRUnichar **aFormatStrings,
70324:                                    PRUint32 aFormatStringsLen)
70324: {
70324:   nsCOMPtr<nsIStringBundleService> bundleService =
70324:     mozilla::services::GetStringBundleService();
70324:   NS_ENSURE_STATE(bundleService);
70324: 
70324:   nsCOMPtr<nsIStringBundle> strBundle;
70324:   nsresult rv =
70324:     bundleService->CreateBundle(aBundleURI, getter_AddRefs(strBundle));
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   nsCOMPtr<nsIConsoleService> console(
70324:     do_GetService(NS_CONSOLESERVICE_CONTRACTID, &rv));
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
86030:   nsCOMPtr<nsIScriptError> errObj(
70324:     do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv));
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   // Localize the error message
70324:   nsXPIDLString message;
70324:   if (aFormatStrings) {
70324:     rv = strBundle->FormatStringFromName(aError, aFormatStrings,
70324:                                          aFormatStringsLen,
70324:                                          getter_Copies(message));
70324:   } else {
70324:     rv = strBundle->GetStringFromName(aError, getter_Copies(message));
70324:   }
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
86030:   rv = errObj->InitWithWindowID(message.get(),
70324:                                 mScriptFile.get(),
70324:                                 nsnull,
70324:                                 mScriptLine, 0,
70324:                                 nsIScriptError::errorFlag,
77330:                                 "Event Source", mInnerWindowID);
86030:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   // print the error message directly to the JS console
86030:   rv = console->LogMessage(errObj);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::ConsoleError()
70324: {
70324:   nsCAutoString targetSpec;
70324:   nsresult rv = mSrc->GetSpec(targetSpec);
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   NS_ConvertUTF8toUTF16 specUTF16(targetSpec);
70324:   const PRUnichar *formatStrings[] = { specUTF16.get() };
70324: 
70324:   if (mReadyState == nsIEventSource::CONNECTING) {
70324:     rv = PrintErrorOnConsole("chrome://global/locale/appstrings.properties",
70324:                              NS_LITERAL_STRING("connectionFailure").get(),
80467:                              formatStrings, ArrayLength(formatStrings));
70324:   } else {
70324:     rv = PrintErrorOnConsole("chrome://global/locale/appstrings.properties",
70324:                              NS_LITERAL_STRING("netInterrupt").get(),
80467:                              formatStrings, ArrayLength(formatStrings));
70324:   }
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::DispatchFailConnection()
70324: {
70324:   nsCOMPtr<nsIRunnable> event =
70324:     NS_NewRunnableMethod(this, &nsEventSource::FailConnection);
70324:   NS_ENSURE_STATE(event);
70324: 
70324:   return NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
70324: }
70324: 
70324: void
70324: nsEventSource::FailConnection()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return;
70324:   }
70324: 
70324:   nsresult rv = ConsoleError();
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to print to the console error");
70324:   }
70324: 
70324:   // When a user agent is to fail the connection, the user agent must set the
70324:   // readyState attribute to CLOSED and queue a task to fire a simple event
70324:   // named error at the EventSource  object.
70324: 
70324:   Close(); // it sets mReadyState to CLOSED
70324: 
70324:   rv = CheckInnerWindowCorrectness();
70324:   if (NS_FAILED(rv)) {
70324:     return;
70324:   }
70324: 
70324:   nsCOMPtr<nsIDOMEvent> event;
70324:   rv = NS_NewDOMEvent(getter_AddRefs(event), nsnull, nsnull);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to create the error event!!!");
70324:     return;
70324:   }
70324: 
70324:   // it doesn't bubble, and it isn't cancelable
80486:   rv = event->InitEvent(NS_LITERAL_STRING("error"), false, false);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to init the error event!!!");
70324:     return;
70324:   }
70324: 
70324:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(event);
80486:   privateEvent->SetTrusted(true);
70324: 
70324:   rv = DispatchDOMEvent(nsnull, event, nsnull, nsnull);
70324:   if (NS_FAILED(rv)) {
70324:     NS_WARNING("Failed to dispatch the error event!!!");
70324:     return;
70324:   }
70324: }
70324: 
79445: bool
70324: nsEventSource::CheckCanRequestSrc(nsIURI* aSrc)
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED) {
80486:     return false;
70324:   }
70324: 
79445:   bool isValidURI = false;
79445:   bool isValidContentLoadPolicy = false;
79445:   bool isValidProtocol = false;
70324: 
70324:   nsCOMPtr<nsIURI> srcToTest = aSrc ? aSrc : mSrc.get();
80486:   NS_ENSURE_TRUE(srcToTest, false);
70324: 
70324:   PRUint32 aCheckURIFlags =
70324:     nsIScriptSecurityManager::DISALLOW_INHERIT_PRINCIPAL |
70324:     nsIScriptSecurityManager::DISALLOW_SCRIPT;
70324: 
70324:   nsresult rv = nsContentUtils::GetSecurityManager()->
70324:     CheckLoadURIWithPrincipal(mPrincipal,
70324:                               srcToTest,
70324:                               aCheckURIFlags);
70324:   isValidURI = NS_SUCCEEDED(rv);
70324: 
70324:   // After the security manager, the content-policy check
70324: 
70324:   nsCOMPtr<nsIDocument> doc =
70324:     nsContentUtils::GetDocumentFromScriptContext(mScriptContext);
70324: 
70324:   // mScriptContext should be initialized because of GetBaseURI() above.
70324:   // Still need to consider the case that doc is nsnull however.
70324:   rv = CheckInnerWindowCorrectness();
80486:   NS_ENSURE_SUCCESS(rv, false);
70324:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
81091:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_DATAREQUEST,
70324:                                  srcToTest,
70324:                                  mPrincipal,
70324:                                  doc,
70324:                                  NS_LITERAL_CSTRING(TEXT_EVENT_STREAM),
70324:                                  nsnull,    // extra
70324:                                  &shouldLoad,
70324:                                  nsContentUtils::GetContentPolicy(),
70324:                                  nsContentUtils::GetSecurityManager());
70324:   isValidContentLoadPolicy = NS_SUCCEEDED(rv) && NS_CP_ACCEPTED(shouldLoad);
70324: 
70324:   nsCAutoString targetURIScheme;
70324:   rv = srcToTest->GetScheme(targetURIScheme);
70324:   if (NS_SUCCEEDED(rv)) {
70324:     // We only have the http support for now
70324:     isValidProtocol = targetURIScheme.EqualsLiteral("http") ||
70324:                       targetURIScheme.EqualsLiteral("https");
70324:   }
70324: 
84054:   return isValidURI && isValidContentLoadPolicy && isValidProtocol;
70324: }
70324: 
70324: // static
70324: void
70324: nsEventSource::TimerCallback(nsITimer* aTimer, void* aClosure)
70324: {
70324:   nsRefPtr<nsEventSource> thisObject = static_cast<nsEventSource*>(aClosure);
70324: 
70324:   if (thisObject->mReadyState == nsIEventSource::CLOSED) {
70324:     return;
70324:   }
70324: 
70324:   NS_PRECONDITION(!thisObject->mHttpChannel,
70324:                   "the channel hasn't been cancelled!!");
70324: 
70324:   if (!thisObject->mFrozen) {
70324:     nsresult rv = thisObject->InitChannelAndRequestEventSource();
70324:     if (NS_FAILED(rv)) {
70324:       NS_WARNING("thisObject->InitChannelAndRequestEventSource() failed");
70324:       return;
70324:     }
70324:   }
70324: }
70324: 
70324: nsresult
70324: nsEventSource::Thaw()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED || !mFrozen) {
70324:     return NS_OK;
70324:   }
70324: 
70324:   NS_ASSERTION(!mHttpChannel, "the connection hasn't been closed!!!");
70324: 
80486:   mFrozen = false;
70324:   nsresult rv;
70324:   if (!mGoingToDispatchAllMessages && mMessagesToDispatch.GetSize() > 0) {
70324:     nsCOMPtr<nsIRunnable> event =
70324:       NS_NewRunnableMethod(this, &nsEventSource::DispatchAllMessageEvents);
70324:     NS_ENSURE_STATE(event);
70324: 
80486:     mGoingToDispatchAllMessages = true;
70324: 
70324:     rv = NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
70324:     NS_ENSURE_SUCCESS(rv, rv);
70324:   }
70324: 
70324:   rv = InitChannelAndRequestEventSource();
70324:   NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::Freeze()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED || mFrozen) {
70324:     return NS_OK;
70324:   }
70324: 
70324:   NS_ASSERTION(!mHttpChannel, "the connection hasn't been closed!!!");
80486:   mFrozen = true;
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::DispatchCurrentMessageEvent()
70324: {
70324:   nsAutoPtr<Message> message(new Message());
70324:   *message = mCurrentMessage;
70324: 
70324:   ClearFields();
70324: 
70324:   if (message->mData.IsEmpty()) {
70324:     return NS_OK;
70324:   }
70324: 
70324:   // removes the trailing LF from mData
70324:   NS_ASSERTION(message->mData.CharAt(message->mData.Length() - 1) == LF_CHAR,
70324:                "Invalid trailing character! LF was expected instead.");
70324:   message->mData.SetLength(message->mData.Length() - 1);
70324: 
70324:   if (message->mEventName.IsEmpty()) {
70324:     message->mEventName.AssignLiteral("message");
70324:   }
70324: 
70324:   if (message->mLastEventID.IsEmpty() && !mLastEventID.IsEmpty()) {
70324:     message->mLastEventID.Assign(mLastEventID);
70324:   }
70324: 
70324:   PRInt32 sizeBefore = mMessagesToDispatch.GetSize();
70324:   mMessagesToDispatch.Push(message.forget());
70324:   NS_ENSURE_TRUE(mMessagesToDispatch.GetSize() == sizeBefore + 1,
70324:                  NS_ERROR_OUT_OF_MEMORY);
70324: 
70324: 
70324:   if (!mGoingToDispatchAllMessages) {
70324:     nsCOMPtr<nsIRunnable> event =
70324:       NS_NewRunnableMethod(this, &nsEventSource::DispatchAllMessageEvents);
70324:     NS_ENSURE_STATE(event);
70324: 
80486:     mGoingToDispatchAllMessages = true;
70324: 
70324:     return NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
70324:   }
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: void
70324: nsEventSource::DispatchAllMessageEvents()
70324: {
70324:   if (mReadyState == nsIEventSource::CLOSED || mFrozen) {
70324:     return;
70324:   }
70324: 
80486:   mGoingToDispatchAllMessages = false;
70324: 
70324:   nsresult rv = CheckInnerWindowCorrectness();
70324:   if (NS_FAILED(rv)) {
70324:     return;
70324:   }
70324: 
70373:   // Let's play get the JSContext
70373:   nsCOMPtr<nsIScriptGlobalObject> sgo = do_QueryInterface(mOwner);
70373:   NS_ENSURE_TRUE(sgo,);
70373: 
70373:   nsIScriptContext* scriptContext = sgo->GetContext();
70373:   NS_ENSURE_TRUE(scriptContext,);
70373: 
78415:   JSContext* cx = scriptContext->GetNativeContext();
70373:   NS_ENSURE_TRUE(cx,);
70373: 
70324:   while (mMessagesToDispatch.GetSize() > 0) {
70324:     nsAutoPtr<Message>
70324:       message(static_cast<Message*>(mMessagesToDispatch.PopFront()));
70324: 
70373:     // Now we can turn our string into a jsval
70373:     jsval jsData;
70373:     {
70373:       JSString* jsString;
70373:       JSAutoRequest ar(cx);
70373:       jsString = JS_NewUCStringCopyN(cx,
70373:                                      message->mData.get(),
70373:                                      message->mData.Length());
70373:       NS_ENSURE_TRUE(jsString,);
70373: 
70373:       jsData = STRING_TO_JSVAL(jsString);
70373:     }
70373: 
70324:     // create an event that uses the MessageEvent interface,
70324:     // which does not bubble, is not cancelable, and has no default action
70324: 
70324:     nsCOMPtr<nsIDOMEvent> event;
70324:     rv = NS_NewDOMMessageEvent(getter_AddRefs(event), nsnull, nsnull);
70324:     if (NS_FAILED(rv)) {
70324:       NS_WARNING("Failed to create the message event!!!");
70324:       return;
70324:     }
70324: 
70324:     nsCOMPtr<nsIDOMMessageEvent> messageEvent = do_QueryInterface(event);
70324:     rv = messageEvent->InitMessageEvent(message->mEventName,
80486:                                         false, false,
70373:                                         jsData,
84054:                                         mOrigin,
70324:                                         message->mLastEventID, nsnull);
70324:     if (NS_FAILED(rv)) {
70324:       NS_WARNING("Failed to init the message event!!!");
70324:       return;
70324:     }
70324: 
70324:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(event);
80486:     privateEvent->SetTrusted(true);
70324: 
70324:     rv = DispatchDOMEvent(nsnull, event, nsnull, nsnull);
70324:     if (NS_FAILED(rv)) {
70324:       NS_WARNING("Failed to dispatch the message event!!!");
70324:       return;
70324:     }
70324:   }
70324: }
70324: 
70324: nsresult
70324: nsEventSource::ClearFields()
70324: {
70324:   // mLastEventID and mReconnectionTime must be cached
70324: 
70324:   mCurrentMessage.mEventName.Truncate();
70324:   mCurrentMessage.mLastEventID.Truncate();
70324:   mCurrentMessage.mData.Truncate();
70324: 
70324:   mLastFieldName.Truncate();
70324:   mLastFieldValue.Truncate();
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::SetFieldAndClear()
70324: {
70324:   if (mLastFieldName.IsEmpty()) {
70324:     mLastFieldValue.Truncate();
70324:     return NS_OK;
70324:   }
70324: 
70324:   PRUnichar first_char;
70324:   first_char = mLastFieldName.CharAt(0);
70324: 
70324:   switch (first_char)  // with no case folding performed
70324:   {
70324:     case PRUnichar('d'):
70324:       if (mLastFieldName.EqualsLiteral("data")) {
70324:         // If the field name is "data" append the field value to the data
70324:         // buffer, then append a single U+000A LINE FEED (LF) character
70324:         // to the data buffer.
70324:         mCurrentMessage.mData.Append(mLastFieldValue);
70324:         mCurrentMessage.mData.Append(LF_CHAR);
70324:       }
70324:       break;
70324: 
70324:     case PRUnichar('e'):
70324:       if (mLastFieldName.EqualsLiteral("event")) {
70324:         mCurrentMessage.mEventName.Assign(mLastFieldValue);
70324:       }
70324:       break;
70324: 
70324:     case PRUnichar('i'):
70324:       if (mLastFieldName.EqualsLiteral("id")) {
70324:         mCurrentMessage.mLastEventID.Assign(mLastFieldValue);
70324:         mLastEventID.Assign(mLastFieldValue);
70324:       }
70324:       break;
70324: 
70324:     case PRUnichar('r'):
70324:       if (mLastFieldName.EqualsLiteral("retry")) {
70324:         PRUint32 newValue=0;
70324:         PRUint32 i = 0;  // we must ensure that there are only digits
79445:         bool assign = true;
70324:         for (i = 0; i < mLastFieldValue.Length(); ++i) {
70324:           if (mLastFieldValue.CharAt(i) < (PRUnichar)'0' ||
70324:               mLastFieldValue.CharAt(i) > (PRUnichar)'9') {
80486:             assign = false;
70324:             break;
70324:           }
70324:           newValue = newValue*10 +
70324:                      (((PRUint32)mLastFieldValue.CharAt(i))-
70324:                        ((PRUint32)((PRUnichar)'0')));
70324:         }
70324: 
70324:         if (assign) {
70324:           if (newValue < MIN_RECONNECTION_TIME_VALUE) {
70324:             mReconnectionTime = MIN_RECONNECTION_TIME_VALUE;
70324:           } else if (newValue > MAX_RECONNECTION_TIME_VALUE) {
70324:             mReconnectionTime = MAX_RECONNECTION_TIME_VALUE;
70324:           } else {
70324:             mReconnectionTime = newValue;
70324:           }
70324:         }
70324:         break;
70324:       }
70324:       break;
70324:   }
70324: 
70324:   mLastFieldName.Truncate();
70324:   mLastFieldValue.Truncate();
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::CheckHealthOfRequestCallback(nsIRequest *aRequestCallback)
70324: {
70324:   // check if we have been closed or if the request has been canceled
70324:   // or if we have been frozen
70324:   if (mReadyState == nsIEventSource::CLOSED || !mHttpChannel ||
70324:       mFrozen || mErrorLoadOnRedirect) {
70324:     return NS_ERROR_ABORT;
70324:   }
70324: 
70324:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aRequestCallback);
70324:   NS_ENSURE_STATE(httpChannel);
70324: 
70324:   if (httpChannel != mHttpChannel) {
70324:     NS_WARNING("wrong channel from request callback");
70324:     return NS_ERROR_ABORT;
70324:   }
70324: 
70324:   return NS_OK;
70324: }
70324: 
70324: nsresult
70324: nsEventSource::ParseCharacter(PRUnichar aChr)
70324: {
70324:   nsresult rv;
70324: 
70324:   if (mReadyState == nsIEventSource::CLOSED) {
70324:     return NS_ERROR_ABORT;
70324:   }
70324: 
70324:   switch (mStatus)
70324:   {
70324:     case PARSE_STATE_OFF:
70324:       NS_ERROR("Invalid state");
70324:       return NS_ERROR_FAILURE;
70324:       break;
70324: 
70324:     case PARSE_STATE_BEGIN_OF_STREAM:
70324:       if (aChr == BOM_CHAR) {
70324:         mStatus = PARSE_STATE_BOM_WAS_READ;  // ignore it
70324:       } else if (aChr == CR_CHAR) {
70324:         mStatus = PARSE_STATE_CR_CHAR;
70324:       } else if (aChr == LF_CHAR) {
70324:         mStatus = PARSE_STATE_BEGIN_OF_LINE;
70324:       } else if (aChr == COLON_CHAR) {
70324:         mStatus = PARSE_STATE_COMMENT;
70324:       } else {
70324:         mLastFieldName += aChr;
70324:         mStatus = PARSE_STATE_FIELD_NAME;
70324:       }
70324: 
70324:       break;
70324: 
70324:     case PARSE_STATE_BOM_WAS_READ:
70324:       if (aChr == CR_CHAR) {
70324:         mStatus = PARSE_STATE_CR_CHAR;
70324:       } else if (aChr == LF_CHAR) {
70324:         mStatus = PARSE_STATE_BEGIN_OF_LINE;
70324:       } else if (aChr == COLON_CHAR) {
70324:         mStatus = PARSE_STATE_COMMENT;
70324:       } else {
70324:         mLastFieldName += aChr;
70324:         mStatus = PARSE_STATE_FIELD_NAME;
70324:       }
70324:       break;
70324: 
70324:     case PARSE_STATE_CR_CHAR:
70324:       if (aChr == CR_CHAR) {
70324:         rv = DispatchCurrentMessageEvent();  // there is an empty line (CRCR)
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324:       } else if (aChr == LF_CHAR) {
70324:         mStatus = PARSE_STATE_BEGIN_OF_LINE;
70324:       } else if (aChr == COLON_CHAR) {
70324:         mStatus = PARSE_STATE_COMMENT;
70324:       } else {
70324:         mLastFieldName += aChr;
70324:         mStatus = PARSE_STATE_FIELD_NAME;
70324:       }
70324: 
70324:       break;
70324: 
70324:     case PARSE_STATE_COMMENT:
70324:       if (aChr == CR_CHAR) {
70324:         mStatus = PARSE_STATE_CR_CHAR;
70324:       } else if (aChr == LF_CHAR) {
70324:         mStatus = PARSE_STATE_BEGIN_OF_LINE;
70324:       }
70324: 
70324:       break;
70324: 
70324:     case PARSE_STATE_FIELD_NAME:
70324:       if (aChr == CR_CHAR) {
70324:         rv = SetFieldAndClear();
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         mStatus = PARSE_STATE_CR_CHAR;
70324:       } else if (aChr == LF_CHAR) {
70324:         rv = SetFieldAndClear();
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         mStatus = PARSE_STATE_BEGIN_OF_LINE;
70324:       } else if (aChr == COLON_CHAR) {
70324:         mStatus = PARSE_STATE_FIRST_CHAR_OF_FIELD_VALUE;
70324:       } else {
70324:         mLastFieldName += aChr;
70324:       }
70324: 
70324:       break;
70324: 
70324:     case PARSE_STATE_FIRST_CHAR_OF_FIELD_VALUE:
70324:       if (aChr == CR_CHAR) {
70324:         rv = SetFieldAndClear();
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         mStatus = PARSE_STATE_CR_CHAR;
70324:       } else if (aChr == LF_CHAR) {
70324:         rv = SetFieldAndClear();
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         mStatus = PARSE_STATE_BEGIN_OF_LINE;
70324:       } else if (aChr == SPACE_CHAR) {
70324:         mStatus = PARSE_STATE_FIELD_VALUE;
70324:       } else {
70324:         mLastFieldValue += aChr;
70324:         mStatus = PARSE_STATE_FIELD_VALUE;
70324:       }
70324: 
70324:       break;
70324: 
70324:     case PARSE_STATE_FIELD_VALUE:
70324:       if (aChr == CR_CHAR) {
70324:         rv = SetFieldAndClear();
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         mStatus = PARSE_STATE_CR_CHAR;
70324:       } else if (aChr == LF_CHAR) {
70324:         rv = SetFieldAndClear();
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         mStatus = PARSE_STATE_BEGIN_OF_LINE;
70324:       } else {
70324:         mLastFieldValue += aChr;
70324:       }
70324: 
70324:       break;
70324: 
70324:     case PARSE_STATE_BEGIN_OF_LINE:
70324:       if (aChr == CR_CHAR) {
70324:         rv = DispatchCurrentMessageEvent();  // there is an empty line
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         mStatus = PARSE_STATE_CR_CHAR;
70324:       } else if (aChr == LF_CHAR) {
70324:         rv = DispatchCurrentMessageEvent();  // there is an empty line
70324:         NS_ENSURE_SUCCESS(rv, rv);
70324: 
70324:         mStatus = PARSE_STATE_BEGIN_OF_LINE;
70324:       } else if (aChr == COLON_CHAR) {
70324:         mStatus = PARSE_STATE_COMMENT;
70324:       } else {
70324:         mLastFieldName += aChr;
70324:         mStatus = PARSE_STATE_FIELD_NAME;
70324:       }
70324: 
70324:       break;
70324:   }
70324: 
70324:   return NS_OK;
70324: }
