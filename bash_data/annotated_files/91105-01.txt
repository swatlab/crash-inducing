47804: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
43310: /* ***** BEGIN LICENSE BLOCK *****
43310:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43310:  *
43310:  * The contents of this file are subject to the Mozilla Public License Version
43310:  * 1.1 (the "License"); you may not use this file except in compliance with
43310:  * the License. You may obtain a copy of the License at
43310:  * http://www.mozilla.org/MPL/
43310:  *
43310:  * Software distributed under the License is distributed on an "AS IS" basis,
43310:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43310:  * for the specific language governing rights and limitations under the
43310:  * License.
43310:  *
43310:  * The Original Code is mozilla.org code.
43310:  *
43310:  * The Initial Developer of the Original Code is
43310:  * Mozilla Foundation.
43310:  * Portions created by the Initial Developer are Copyright (C) 2010
43310:  * the Initial Developer. All Rights Reserved.
43310:  *
43310:  * Contributor(s):
43310:  *  Alexander Surkov <surkov.alexander@gmail.com> (original author)
43310:  *
43310:  * Alternatively, the contents of this file may be used under the terms of
43310:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43310:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43310:  * in which case the provisions of the GPL or the LGPL are applicable instead
43310:  * of those above. If you wish to allow use of your version of this file only
43310:  * under the terms of either the GPL or the LGPL, and not to allow others to
43310:  * use your version of this file under the terms of the MPL, indicate your
43310:  * decision by deleting the provisions above and replace them with the notice
43310:  * and other provisions required by the GPL or the LGPL. If you do not delete
43310:  * the provisions above, a recipient may use your version of this file under
43310:  * the terms of any one of the MPL, the GPL or the LGPL.
43310:  *
43310:  * ***** END LICENSE BLOCK ***** */
43310: 
43310: #include "nsAccDocManager.h"
43310: 
43310: #include "nsAccessibilityService.h"
43310: #include "nsAccUtils.h"
47105: #include "nsApplicationAccessible.h"
43310: #include "nsOuterDocAccessible.h"
43310: #include "nsRootAccessibleWrap.h"
67790: #include "States.h"
43310: 
43310: #include "nsCURILoader.h"
43310: #include "nsDocShellLoadTypes.h"
43310: #include "nsIChannel.h"
43310: #include "nsIContentViewer.h"
43310: #include "nsIDOMDocument.h"
72328: #include "nsEventListenerManager.h"
43310: #include "nsIDOMEventTarget.h"
43310: #include "nsIDOMWindow.h"
43310: #include "nsIInterfaceRequestorUtils.h"
43310: #include "nsIWebNavigation.h"
43310: #include "nsServiceManagerUtils.h"
43310: 
74618: using namespace mozilla::a11y;
74618: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager
43310: ////////////////////////////////////////////////////////////////////////////////
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager public
43310: 
43310: nsDocAccessible*
43310: nsAccDocManager::GetDocAccessible(nsIDocument *aDocument)
43310: {
43310:   if (!aDocument)
43310:     return nsnull;
43310: 
49017:   // Ensure CacheChildren is called before we query cache.
49017:   nsAccessNode::GetApplicationAccessible()->EnsureChildren();
49017: 
56292:   nsDocAccessible* docAcc = mDocAccessibleCache.GetWeak(aDocument);
43310:   if (docAcc)
43310:     return docAcc;
43310: 
43310:   return CreateDocOrRootAccessible(aDocument);
43310: }
43310: 
43310: nsAccessible*
56292: nsAccDocManager::FindAccessibleInCache(nsINode* aNode) const
43310: {
43310:   nsSearchAccessibleInCacheArg arg;
56292:   arg.mNode = aNode;
43310: 
43310:   mDocAccessibleCache.EnumerateRead(SearchAccessibleInDocCache,
43310:                                     static_cast<void*>(&arg));
43310: 
43310:   return arg.mAccessible;
43310: }
43310: 
79853: #ifdef DEBUG
79853: bool
79853: nsAccDocManager::IsProcessingRefreshDriverNotification() const
79853: {
79853:   bool isDocRefreshing = false;
79853:   mDocAccessibleCache.EnumerateRead(SearchIfDocIsRefreshing,
79853:                                     static_cast<void*>(&isDocRefreshing));
79853: 
79853:   return isDocRefreshing;
79853: }
79853: #endif
79853: 
43765: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager protected
43310: 
79445: bool
43310: nsAccDocManager::Init()
43310: {
43310:   mDocAccessibleCache.Init(4);
43310: 
43310:   nsCOMPtr<nsIWebProgress> progress =
43310:     do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
43310: 
43310:   if (!progress)
80486:     return false;
43310: 
43310:   progress->AddProgressListener(static_cast<nsIWebProgressListener*>(this),
43310:                                 nsIWebProgress::NOTIFY_STATE_DOCUMENT);
43310: 
80486:   return true;
43310: }
43310: 
43310: void
43310: nsAccDocManager::Shutdown()
43310: {
43310:   nsCOMPtr<nsIWebProgress> progress =
43310:     do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
43310: 
43310:   if (progress)
43310:     progress->RemoveProgressListener(static_cast<nsIWebProgressListener*>(this));
43310: 
43310:   ClearDocCache();
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsISupports
43310: 
43310: NS_IMPL_THREADSAFE_ISUPPORTS3(nsAccDocManager,
43310:                               nsIWebProgressListener,
43310:                               nsIDOMEventListener,
43310:                               nsISupportsWeakReference)
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsIWebProgressListener
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnStateChange(nsIWebProgress *aWebProgress,
43310:                                nsIRequest *aRequest, PRUint32 aStateFlags,
43310:                                nsresult aStatus)
43310: {
43310:   NS_ASSERTION(aStateFlags & STATE_IS_DOCUMENT, "Other notifications excluded");
43310: 
43310:   if (nsAccessibilityService::IsShutdown() || !aWebProgress ||
43310:       (aStateFlags & (STATE_START | STATE_STOP)) == 0)
43310:     return NS_OK;
43310: 
43310:   nsCOMPtr<nsIDOMWindow> DOMWindow;
43310:   aWebProgress->GetDOMWindow(getter_AddRefs(DOMWindow));
43310:   NS_ENSURE_STATE(DOMWindow);
43310: 
43310:   nsCOMPtr<nsIDOMDocument> DOMDocument;
43310:   DOMWindow->GetDocument(getter_AddRefs(DOMDocument));
43310:   NS_ENSURE_STATE(DOMDocument);
43310: 
43310:   nsCOMPtr<nsIDocument> document(do_QueryInterface(DOMDocument));
43310: 
43310:   // Document was loaded.
43310:   if (aStateFlags & STATE_STOP) {
43310:     NS_LOG_ACCDOCLOAD("document loaded", aWebProgress, aRequest, aStateFlags)
43310: 
43310:     // Figure out an event type to notify the document has been loaded.
43310:     PRUint32 eventType = nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_STOPPED;
43310: 
43310:     // Some XUL documents get start state and then stop state with failure
43310:     // status when everything is ok. Fire document load complete event in this
43310:     // case.
43310:     if (NS_SUCCEEDED(aStatus) || !nsCoreUtils::IsContentDocument(document))
43310:       eventType = nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE;
43310: 
43310:     // If end consumer has been retargeted for loaded content then do not fire
43310:     // any event because it means no new document has been loaded, for example,
43310:     // it happens when user clicks on file link.
43310:     if (aRequest) {
43310:       PRUint32 loadFlags = 0;
43310:       aRequest->GetLoadFlags(&loadFlags);
43310:       if (loadFlags & nsIChannel::LOAD_RETARGETED_DOCUMENT_URI)
43310:         eventType = 0;
43310:     }
43310: 
43310:     HandleDOMDocumentLoad(document, eventType);
43310:     return NS_OK;
43310:   }
43310: 
43310:   // Document loading was started.
43310:   NS_LOG_ACCDOCLOAD("start document loading", aWebProgress, aRequest,
43310:                     aStateFlags)
43310: 
56292:   nsDocAccessible* docAcc = mDocAccessibleCache.GetWeak(document);
43310:   if (!docAcc)
43310:     return NS_OK;
43310: 
43310:   nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(DOMWindow));
43310:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(webNav));
43310:   NS_ENSURE_STATE(docShell);
43310: 
75013:   bool isReloading = false;
43310:   PRUint32 loadType;
43310:   docShell->GetLoadType(&loadType);
43310:   if (loadType == LOAD_RELOAD_NORMAL ||
43310:       loadType == LOAD_RELOAD_BYPASS_CACHE ||
43310:       loadType == LOAD_RELOAD_BYPASS_PROXY ||
43310:       loadType == LOAD_RELOAD_BYPASS_PROXY_AND_CACHE) {
75013:     isReloading = true;
43310:   }
43310: 
75013:   docAcc->NotifyOfLoading(isReloading);
43310:   return NS_OK;
43310: }
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnProgressChange(nsIWebProgress *aWebProgress,
43310:                                   nsIRequest *aRequest,
43310:                                   PRInt32 aCurSelfProgress,
43310:                                   PRInt32 aMaxSelfProgress,
43310:                                   PRInt32 aCurTotalProgress,
43310:                                   PRInt32 aMaxTotalProgress)
43310: {
43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
43310:   return NS_OK;
43310: }
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnLocationChange(nsIWebProgress *aWebProgress,
82127:                                   nsIRequest *aRequest, nsIURI *aLocation,
82127:                                   PRUint32 aFlags)
43310: {
43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
43310:   return NS_OK;
43310: }
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnStatusChange(nsIWebProgress *aWebProgress,
43310:                                 nsIRequest *aRequest, nsresult aStatus,
43310:                                 const PRUnichar *aMessage)
43310: {
43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
43310:   return NS_OK;
43310: }
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnSecurityChange(nsIWebProgress *aWebProgress,
43310:                                   nsIRequest *aRequest,
43310:                                   PRUint32 aState)
43310: {
43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
43310:   return NS_OK;
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsIDOMEventListener
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::HandleEvent(nsIDOMEvent *aEvent)
43310: {
43310:   nsAutoString type;
43310:   aEvent->GetType(type);
43310: 
43310:   nsCOMPtr<nsIDOMEventTarget> target;
43310:   aEvent->GetTarget(getter_AddRefs(target));
43310: 
43310:   nsCOMPtr<nsIDocument> document(do_QueryInterface(target));
43310:   NS_ASSERTION(document, "pagehide or DOMContentLoaded for non document!");
43310:   if (!document)
43310:     return NS_OK;
43310: 
43310:   if (type.EqualsLiteral("pagehide")) {
43310:     // 'pagehide' event is registered on every DOM document we create an
43310:     // accessible for, process the event for the target. This document
43310:     // accessible and all its sub document accessible are shutdown as result of
43310:     // processing.
43310: 
43310:     NS_LOG_ACCDOCDESTROY("received 'pagehide' event", document)
43310: 
43310:     // Ignore 'pagehide' on temporary documents since we ignore them entirely in
43310:     // accessibility.
43310:     if (document->IsInitialDocument())
43310:       return NS_OK;
43310: 
43310:     // Shutdown this one and sub document accessibles.
56639: 
56639:     // We're allowed to not remove listeners when accessible document is
56639:     // shutdown since we don't keep strong reference on chrome event target and
56639:     // listeners are removed automatically when chrome event target goes away.
56639:     nsDocAccessible* docAccessible = mDocAccessibleCache.GetWeak(document);
56639:     if (docAccessible)
56639:       docAccessible->Shutdown();
56639: 
43310:     return NS_OK;
43310:   }
43310: 
43310:   // XXX: handle error pages loading separately since they get neither
43310:   // webprogress notifications nor 'pageshow' event.
43310:   if (type.EqualsLiteral("DOMContentLoaded") &&
43310:       nsCoreUtils::IsErrorPage(document)) {
43310:     NS_LOG_ACCDOCLOAD2("handled 'DOMContentLoaded' event", document)
43310:     HandleDOMDocumentLoad(document,
57986:                           nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE);
43310:   }
43310: 
43310:   return NS_OK;
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager private
43310: 
43310: void
43310: nsAccDocManager::HandleDOMDocumentLoad(nsIDocument *aDocument,
57986:                                        PRUint32 aLoadEventType)
43310: {
43310:   // Document accessible can be created before we were notified the DOM document
43310:   // was loaded completely. However if it's not created yet then create it.
56292:   nsDocAccessible* docAcc = mDocAccessibleCache.GetWeak(aDocument);
43310:   if (!docAcc) {
43310:     docAcc = CreateDocOrRootAccessible(aDocument);
43310:     if (!docAcc)
43310:       return;
43310:   }
43310: 
75013:   docAcc->NotifyOfLoad(aLoadEventType);
43310: }
43310: 
43310: void
43310: nsAccDocManager::AddListeners(nsIDocument *aDocument,
79445:                               bool aAddDOMContentLoadedListener)
43310: {
43310:   nsPIDOMWindow *window = aDocument->GetWindow();
72326:   nsIDOMEventTarget *target = window->GetChromeEventHandler();
80486:   nsEventListenerManager* elm = target->GetListenerManager(true);
43310:   elm->AddEventListenerByType(this, NS_LITERAL_STRING("pagehide"),
72331:                               NS_EVENT_FLAG_CAPTURE);
43310: 
43310:   NS_LOG_ACCDOCCREATE_TEXT("  added 'pagehide' listener")
43310: 
43310:   if (aAddDOMContentLoadedListener) {
43310:     elm->AddEventListenerByType(this, NS_LITERAL_STRING("DOMContentLoaded"),
72331:                                 NS_EVENT_FLAG_CAPTURE);
43310:     NS_LOG_ACCDOCCREATE_TEXT("  added 'DOMContentLoaded' listener")
43310:   }
43310: }
43310: 
43310: nsDocAccessible*
43310: nsAccDocManager::CreateDocOrRootAccessible(nsIDocument *aDocument)
43310: {
55834:   // Ignore temporary, hiding, resource documents and documents without
55834:   // docshell.
43763:   if (aDocument->IsInitialDocument() || !aDocument->IsVisible() ||
55834:       aDocument->IsResourceDoc() || !aDocument->IsActive())
43310:     return nsnull;
43310: 
91105:   // Ignore documents without presshell and not having root frame.
46225:   nsIPresShell* presShell = aDocument->GetShell();
91105:   if (!presShell || !presShell->GetRootFrame())
43310:     return nsnull;
43310: 
43310:   // Do not create document accessible until role content is loaded, otherwise
43310:   // we get accessible document with wrong role.
43504:   nsIContent *rootElm = nsCoreUtils::GetRoleContent(aDocument);
43504:   if (!rootElm)
43504:     return nsnull;
43310: 
79445:   bool isRootDoc = nsCoreUtils::IsRootDocument(aDocument);
43310: 
61317:   nsDocAccessible* parentDocAcc = nsnull;
61317:   if (!isRootDoc) {
43310:     // XXXaaronl: ideally we would traverse the presshell chain. Since there's
43310:     // no easy way to do that, we cheat and use the document hierarchy.
61317:     parentDocAcc = GetDocAccessible(aDocument->GetParentDocument());
61317:     NS_ASSERTION(parentDocAcc,
61317:                  "Can't create an accessible for the document!");
61317:     if (!parentDocAcc)
61317:       return nsnull;
47105:   }
47105: 
43310:   // We only create root accessibles for the true root, otherwise create a
43310:   // doc accessible.
57413:   nsRefPtr<nsDocAccessible> docAcc = isRootDoc ?
89801:     new nsRootAccessibleWrap(aDocument, rootElm, presShell) :
89801:     new nsDocAccessibleWrap(aDocument, rootElm, presShell);
43310: 
57413:   // Cache the document accessible into document cache.
57413:   if (!docAcc || !mDocAccessibleCache.Put(aDocument, docAcc))
43310:     return nsnull;
43310: 
61317:   // Initialize the document accessible.
61317:   if (!docAcc->Init()) {
61317:     docAcc->Shutdown();
61317:     return nsnull;
61317:   }
61317:   docAcc->SetRoleMapEntry(nsAccUtils::GetRoleMapEntry(aDocument));
61317: 
61317:   // Bind the document to the tree.
61317:   if (isRootDoc) {
61317:     nsAccessible* appAcc = nsAccessNode::GetApplicationAccessible();
61317:     if (!appAcc->AppendChild(docAcc)) {
61317:       docAcc->Shutdown();
43310:       return nsnull;
43310:     }
43310: 
61317:     // Fire reorder event to notify new accessible document has been attached to
74015:     // the tree. The reorder event is delivered after the document tree is
74015:     // constructed because event processing and tree construction are done by
74015:     // the same document.
61317:     nsRefPtr<AccEvent> reorderEvent =
61317:       new AccEvent(nsIAccessibleEvent::EVENT_REORDER, appAcc, eAutoDetect,
61317:                    AccEvent::eCoalesceFromSameSubtree);
61317:     docAcc->FireDelayedAccessibleEvent(reorderEvent);
61317: 
61317:   } else {
61317:     parentDocAcc->BindChildDocument(docAcc);
43310:   }
43310: 
43765:   NS_LOG_ACCDOCCREATE("document creation finished", aDocument)
79384:   NS_LOG_ACCDOCCREATE_STACK
43310: 
43310:   AddListeners(aDocument, isRootDoc);
43310:   return docAcc;
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager static
43310: 
43310: PLDHashOperator
58488: nsAccDocManager::GetFirstEntryInDocCache(const nsIDocument* aKey,
58488:                                          nsDocAccessible* aDocAccessible,
43310:                                          void* aUserArg)
43310: {
43310:   NS_ASSERTION(aDocAccessible,
58488:                "No doc accessible for the object in doc accessible cache!");
58488:   *reinterpret_cast<nsDocAccessible**>(aUserArg) = aDocAccessible;
43310: 
58488:   return PL_DHASH_STOP;
58488: }
43310: 
58488: void
58488: nsAccDocManager::ClearDocCache()
58488: {
58488:   nsDocAccessible* docAcc = nsnull;
58488:   while (mDocAccessibleCache.EnumerateRead(GetFirstEntryInDocCache, static_cast<void*>(&docAcc))) {
58488:     if (docAcc)
58488:       docAcc->Shutdown();
58488:   }
43310: }
43310: 
43310: PLDHashOperator
56292: nsAccDocManager::SearchAccessibleInDocCache(const nsIDocument* aKey,
43310:                                             nsDocAccessible* aDocAccessible,
43310:                                             void* aUserArg)
43310: {
43310:   NS_ASSERTION(aDocAccessible,
43310:                "No doc accessible for the object in doc accessible cache!");
43310: 
43310:   if (aDocAccessible) {
43310:     nsSearchAccessibleInCacheArg* arg =
43310:       static_cast<nsSearchAccessibleInCacheArg*>(aUserArg);
61461:     arg->mAccessible = aDocAccessible->GetAccessible(arg->mNode);
43538:     if (arg->mAccessible)
43310:       return PL_DHASH_STOP;
43310:   }
43310: 
43310:   return PL_DHASH_NEXT;
43310: }
79853: 
79853: #ifdef DEBUG
79853: PLDHashOperator
79853: nsAccDocManager::SearchIfDocIsRefreshing(const nsIDocument* aKey,
79853:                                          nsDocAccessible* aDocAccessible,
79853:                                          void* aUserArg)
79853: {
79853:   NS_ASSERTION(aDocAccessible,
79853:                "No doc accessible for the object in doc accessible cache!");
79853: 
79853:   if (aDocAccessible && aDocAccessible->mNotificationController &&
79853:       aDocAccessible->mNotificationController->IsUpdating()) {
79853:     *(static_cast<bool*>(aUserArg)) = true;
79853:     return PL_DHASH_STOP;
79853:   }
79853: 
79853:   return PL_DHASH_NEXT;
79853: }
79853: #endif
