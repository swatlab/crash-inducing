    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsXMLHttpRequest.h"
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIURI.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsNetUtil.h"
32329: #include "nsStreamUtils.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsIUploadChannel.h"
32329: #include "nsIUploadChannel2.h"
    1: #include "nsIDOMSerializer.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "prprf.h"
    1: #include "nsIDOMEventListener.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsWeakPtr.h"
91519: #include "nsCharsetAlias.h"
    1: #include "nsIScriptGlobalObject.h"
80058: #include "nsDOMClassInfoID.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMWindow.h"
32329: #include "nsIMIMEService.h"
32329: #include "nsCExternalHandlerService.h"
    1: #include "nsIVariant.h"
86103: #include "nsVariant.h"
86103: #include "nsIScriptError.h"
86103: #include "xpcpublic.h"
    1: #include "nsStringStream.h"
    1: #include "nsIStreamConverterService.h"
    1: #include "nsICachingChannel.h"
    1: #include "nsContentUtils.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsDOMJSUtils.h"
    1: #include "nsCOMArray.h"
    1: #include "nsIScriptableUConv.h"
    1: #include "nsCycleCollectionParticipant.h"
   68: #include "nsIContentPolicy.h"
   68: #include "nsContentPolicyUtils.h"
   68: #include "nsContentErrors.h"
 1526: #include "nsLayoutStatics.h"
19951: #include "nsCrossSiteListenerProxy.h"
 3941: #include "nsDOMError.h"
 4064: #include "nsIHTMLDocument.h"
 4106: #include "nsIMultiPartChannel.h"
 8947: #include "nsIScriptObjectPrincipal.h"
13258: #include "nsIStorageStream.h"
14092: #include "nsIPromptFactory.h"
14092: #include "nsIWindowWatcher.h"
41763: #include "nsCharSeparatedTokenizer.h"
35023: #include "nsIConsoleService.h"
41212: #include "nsIChannelPolicy.h"
41212: #include "nsChannelPolicy.h"
41212: #include "nsIContentSecurityPolicy.h"
48889: #include "nsAsyncRedirectVerifyHelper.h"
58163: #include "nsStringBuffer.h"
69662: #include "nsDOMFile.h"
69662: #include "nsIFileChannel.h"
82487: #include "mozilla/Telemetry.h"
95834: #include "jsfriendapi.h"
87692: #include "sampler.h"
94512: #include "mozilla/dom/bindings/XMLHttpRequestBinding.h"
94307: #include "nsIDOMFormData.h"
94307: 
88267: #include "nsWrapperCacheInlines.h"
    1: 
80467: using namespace mozilla;
94307: using namespace mozilla::dom;
80467: 
    1: #define LOAD_STR "load"
    1: #define ERROR_STR "error"
16665: #define ABORT_STR "abort"
88284: #define TIMEOUT_STR "timeout"
16665: #define LOADSTART_STR "loadstart"
    1: #define PROGRESS_STR "progress"
    1: #define UPLOADPROGRESS_STR "uploadprogress"
    1: #define READYSTATE_STR "readystatechange"
63715: #define LOADEND_STR "loadend"
    1: 
    1: // CIDs
    1: 
    1: // State
69662: #define XML_HTTP_REQUEST_UNSENT           (1 << 0) // 0 UNSENT
69662: #define XML_HTTP_REQUEST_OPENED           (1 << 1) // 1 OPENED
69662: #define XML_HTTP_REQUEST_HEADERS_RECEIVED (1 << 2) // 2 HEADERS_RECEIVED
69662: #define XML_HTTP_REQUEST_LOADING          (1 << 3) // 3 LOADING
69662: #define XML_HTTP_REQUEST_DONE             (1 << 4) // 4 DONE
69662: #define XML_HTTP_REQUEST_SENT             (1 << 5) // Internal, OPENED in IE and external view
69662: #define XML_HTTP_REQUEST_STOPPED          (1 << 6) // Internal, LOADING in IE and external view
    1: // The above states are mutually exclusive, change with ChangeState() only.
    1: // The states below can be combined.
    1: #define XML_HTTP_REQUEST_ABORTED        (1 << 7)  // Internal
    1: #define XML_HTTP_REQUEST_ASYNC          (1 << 8)  // Internal
    1: #define XML_HTTP_REQUEST_PARSEBODY      (1 << 9)  // Internal
63932: #define XML_HTTP_REQUEST_SYNCLOOPING    (1 << 10) // Internal
63932: #define XML_HTTP_REQUEST_MULTIPART      (1 << 11) // Internal
63932: #define XML_HTTP_REQUEST_GOT_FINAL_STOP (1 << 12) // Internal
63932: #define XML_HTTP_REQUEST_BACKGROUND     (1 << 13) // Internal
19152: // This is set when we've got the headers for a multipart XMLHttpRequest,
19152: // but haven't yet started to process the first part.
63932: #define XML_HTTP_REQUEST_MPART_HEADERS  (1 << 14) // Internal
63932: #define XML_HTTP_REQUEST_USE_XSITE_AC   (1 << 15) // Internal
63932: #define XML_HTTP_REQUEST_NEED_AC_PREFLIGHT (1 << 16) // Internal
63932: #define XML_HTTP_REQUEST_AC_WITH_CREDENTIALS (1 << 17) // Internal
88284: #define XML_HTTP_REQUEST_TIMED_OUT (1 << 18) // Internal
90101: #define XML_HTTP_REQUEST_DELETED (1 << 19) // Internal
    1: 
    1: #define XML_HTTP_REQUEST_LOADSTATES         \
69662:   (XML_HTTP_REQUEST_UNSENT |                \
    1:    XML_HTTP_REQUEST_OPENED |                \
69662:    XML_HTTP_REQUEST_HEADERS_RECEIVED |      \
69662:    XML_HTTP_REQUEST_LOADING |               \
69662:    XML_HTTP_REQUEST_DONE |                  \
    1:    XML_HTTP_REQUEST_SENT |                  \
    1:    XML_HTTP_REQUEST_STOPPED)
    1: 
13282: #define NS_BADCERTHANDLER_CONTRACTID \
13282:   "@mozilla.org/content/xmlhttprequest-bad-cert-handler;1"
13282: 
23607: #define NS_PROGRESS_EVENT_INTERVAL 50
20640: 
94307: #define IMPL_STRING_GETTER(_name)                                               \
94307:   NS_IMETHODIMP                                                                 \
94307:   nsXMLHttpRequest::_name(nsAString& aOut)                                      \
94307:   {                                                                             \
94307:     nsString tmp;                                                               \
94307:     _name(tmp);                                                                 \
94307:     aOut = tmp;                                                                 \
94307:     return NS_OK;                                                               \
94307:   }
94307: 
82543: NS_IMPL_ISUPPORTS1(nsXHRParseEndListener, nsIDOMEventListener)
82543: 
25722: class nsResumeTimeoutsEvent : public nsRunnable
25722: {
25722: public:
25722:   nsResumeTimeoutsEvent(nsPIDOMWindow* aWindow) : mWindow(aWindow) {}
25722: 
25722:   NS_IMETHOD Run()
25722:   {
80486:     mWindow->ResumeTimeouts(false);
25722:     return NS_OK;
25722:   }
25722: 
25722: private:
25722:   nsCOMPtr<nsPIDOMWindow> mWindow;
25722: };
25722: 
16664: 
    1: // This helper function adds the given load flags to the request's existing
    1: // load flags.
    1: static void AddLoadFlags(nsIRequest *request, nsLoadFlags newFlags)
    1: {
    1:   nsLoadFlags flags;
    1:   request->GetLoadFlags(&flags);
    1:   flags |= newFlags;
    1:   request->SetLoadFlags(flags);
    1: }
    1: 
79445: static nsresult IsCapabilityEnabled(const char *capability, bool *enabled)
13282: {
13282:   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
13282:   if (!secMan)
13282:     return NS_ERROR_FAILURE;
13282: 
13282:   return secMan->IsCapabilityEnabled(capability, enabled);
13282: }
13282: 
    1: // Helper proxy class to be used when expecting an
    1: // multipart/x-mixed-replace stream of XML documents.
    1: 
    1: class nsMultipartProxyListener : public nsIStreamListener
    1: {
    1: public:
    1:   nsMultipartProxyListener(nsIStreamListener *dest);
    1:   virtual ~nsMultipartProxyListener();
    1: 
    1:   /* additional members */
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSISTREAMLISTENER
    1:   NS_DECL_NSIREQUESTOBSERVER
    1: 
    1: private:
    1:   nsCOMPtr<nsIStreamListener> mDestListener;
    1: };
    1: 
    1: 
    1: nsMultipartProxyListener::nsMultipartProxyListener(nsIStreamListener *dest)
    1:   : mDestListener(dest)
    1: {
    1: }
    1: 
    1: nsMultipartProxyListener::~nsMultipartProxyListener()
    1: {
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS2(nsMultipartProxyListener, nsIStreamListener,
    1:                    nsIRequestObserver)
    1: 
    1: /** nsIRequestObserver methods **/
    1: 
    1: NS_IMETHODIMP
    1: nsMultipartProxyListener::OnStartRequest(nsIRequest *aRequest,
    1:                                          nsISupports *ctxt)
    1: {
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
    1: 
    1:   nsCAutoString contentType;
    1:   nsresult rv = channel->GetContentType(contentType);
    1: 
    1:   if (!contentType.EqualsLiteral("multipart/x-mixed-replace")) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   // If multipart/x-mixed-replace content, we'll insert a MIME
    1:   // decoder in the pipeline to handle the content and pass it along
    1:   // to our original listener.
    1: 
19152:   nsCOMPtr<nsIXMLHttpRequest> xhr = do_QueryInterface(mDestListener);
19152: 
    1:   nsCOMPtr<nsIStreamConverterService> convServ =
    1:     do_GetService("@mozilla.org/streamConverters;1", &rv);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIStreamListener> toListener(mDestListener);
    1:     nsCOMPtr<nsIStreamListener> fromListener;
    1: 
    1:     rv = convServ->AsyncConvertData("multipart/x-mixed-replace",
    1:                                     "*/*",
    1:                                     toListener,
    1:                                     nsnull,
    1:                                     getter_AddRefs(fromListener));
    1:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && fromListener, NS_ERROR_UNEXPECTED);
    1: 
    1:     mDestListener = fromListener;
    1:   }
    1: 
19152:   if (xhr) {
19152:     static_cast<nsXMLHttpRequest*>(xhr.get())->mState |=
19152:       XML_HTTP_REQUEST_MPART_HEADERS;
19152:    }
19152: 
    1:   return mDestListener->OnStartRequest(aRequest, ctxt);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMultipartProxyListener::OnStopRequest(nsIRequest *aRequest,
    1:                                         nsISupports *ctxt,
    1:                                         nsresult status)
    1: {
    1:   return mDestListener->OnStopRequest(aRequest, ctxt, status);
    1: }
    1: 
    1: /** nsIStreamListener methods **/
    1: 
    1: NS_IMETHODIMP
    1: nsMultipartProxyListener::OnDataAvailable(nsIRequest *aRequest,
    1:                                           nsISupports *ctxt,
    1:                                           nsIInputStream *inStr,
    1:                                           PRUint32 sourceOffset,
    1:                                           PRUint32 count)
    1: {
    1:   return mDestListener->OnDataAvailable(aRequest, ctxt, inStr, sourceOffset,
    1:                                         count);
    1: }
    1: 
    1: /////////////////////////////////////////////
16665: 
16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXHREventTarget)
16665: 
29226: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXHREventTarget,
89667:                                                   nsDOMEventTargetHelper)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnLoadListener)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnErrorListener)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnAbortListener)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnLoadStartListener)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnProgressListener)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnLoadendListener)
88284:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnTimeoutListener)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
29226: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXHREventTarget,
89667:                                                 nsDOMEventTargetHelper)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnLoadListener)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnErrorListener)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnAbortListener)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnLoadStartListener)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnProgressListener)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnLoadendListener)
88284:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnTimeoutListener)
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
29226: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXHREventTarget)
16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestEventTarget)
89667: NS_INTERFACE_MAP_END_INHERITING(nsDOMEventTargetHelper)
89667: 
89667: NS_IMPL_ADDREF_INHERITED(nsXHREventTarget, nsDOMEventTargetHelper)
89667: NS_IMPL_RELEASE_INHERITED(nsXHREventTarget, nsDOMEventTargetHelper)
    1: 
92083: void
92083: nsXHREventTarget::DisconnectFromOwner()
92083: {
92083:   nsDOMEventTargetHelper::DisconnectFromOwner();
92083:   NS_DISCONNECT_EVENT_HANDLER(Load)
92083:   NS_DISCONNECT_EVENT_HANDLER(Error)
92083:   NS_DISCONNECT_EVENT_HANDLER(Abort)
92083:   NS_DISCONNECT_EVENT_HANDLER(Load)
92083:   NS_DISCONNECT_EVENT_HANDLER(Progress)
92083:   NS_DISCONNECT_EVENT_HANDLER(Loadend)
92083:   NS_DISCONNECT_EVENT_HANDLER(Timeout)
92083: }
92083: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::GetOnload(nsIDOMEventListener** aOnLoad)
79469: {
79469:   return GetInnerEventListener(mOnLoadListener, aOnLoad);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::SetOnload(nsIDOMEventListener* aOnLoad)
79469: {
79469:   return RemoveAddEventListener(NS_LITERAL_STRING(LOAD_STR),
79469:                                 mOnLoadListener, aOnLoad);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::GetOnerror(nsIDOMEventListener** aOnerror)
79469: {
79469:   return GetInnerEventListener(mOnErrorListener, aOnerror);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::SetOnerror(nsIDOMEventListener* aOnerror)
79469: {
79469:   return RemoveAddEventListener(NS_LITERAL_STRING(ERROR_STR),
79469:                                 mOnErrorListener, aOnerror);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::GetOnabort(nsIDOMEventListener** aOnabort)
79469: {
79469:   return GetInnerEventListener(mOnAbortListener, aOnabort);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::SetOnabort(nsIDOMEventListener* aOnabort)
79469: {
79469:   return RemoveAddEventListener(NS_LITERAL_STRING(ABORT_STR),
79469:                                 mOnAbortListener, aOnabort);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::GetOnloadstart(nsIDOMEventListener** aOnloadstart)
79469: {
79469:   return GetInnerEventListener(mOnLoadStartListener, aOnloadstart);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::SetOnloadstart(nsIDOMEventListener* aOnloadstart)
79469: {
79469:   return RemoveAddEventListener(NS_LITERAL_STRING(LOADSTART_STR),
79469:                                 mOnLoadStartListener, aOnloadstart);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::GetOnprogress(nsIDOMEventListener** aOnprogress)
79469: {
79469:   return GetInnerEventListener(mOnProgressListener, aOnprogress);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::SetOnprogress(nsIDOMEventListener* aOnprogress)
79469: {
79469:   return RemoveAddEventListener(NS_LITERAL_STRING(PROGRESS_STR),
79469:                                 mOnProgressListener, aOnprogress);
79469: }
79469: 
88284: /* attribute nsIDOMEventListener ontimeout; */
88284: NS_IMETHODIMP
88284: nsXHREventTarget::GetOntimeout(nsIDOMEventListener * *aOntimeout)
88284: {
88284:   return GetInnerEventListener(mOnTimeoutListener, aOntimeout);
88284: }
88284: NS_IMETHODIMP
88284: nsXHREventTarget::SetOntimeout(nsIDOMEventListener *aOntimeout)
88284: {
88284:   return RemoveAddEventListener(NS_LITERAL_STRING(TIMEOUT_STR),
88284:                                 mOnTimeoutListener, aOntimeout);
88284: }
88284: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::GetOnloadend(nsIDOMEventListener** aOnLoadend)
79469: {
79469:   return GetInnerEventListener(mOnLoadendListener, aOnLoadend);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXHREventTarget::SetOnloadend(nsIDOMEventListener* aOnLoadend)
79469: {
79469:   return RemoveAddEventListener(NS_LITERAL_STRING(LOADEND_STR),
79469:                                 mOnLoadendListener, aOnLoadend);
79469: }
63715: 
16665: /////////////////////////////////////////////
19701: 
40490: DOMCI_DATA(XMLHttpRequestUpload, nsXMLHttpRequestUpload)
40490: 
19701: NS_INTERFACE_MAP_BEGIN(nsXMLHttpRequestUpload)
16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequestUpload)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XMLHttpRequestUpload)
16665: NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
16665: 
16665: NS_IMPL_ADDREF_INHERITED(nsXMLHttpRequestUpload, nsXHREventTarget)
16665: NS_IMPL_RELEASE_INHERITED(nsXMLHttpRequestUpload, nsXHREventTarget)
16665: 
16665: /////////////////////////////////////////////
16665: //
16665: //
16665: /////////////////////////////////////////////
16665: 
16665: nsXMLHttpRequest::nsXMLHttpRequest()
78800:   : mResponseBodyDecodedPos(0),
78800:     mResponseType(XML_HTTP_RESPONSE_TYPE_DEFAULT),
69662:     mRequestObserver(nsnull), mState(XML_HTTP_REQUEST_UNSENT),
80486:     mUploadTransferred(0), mUploadTotal(0), mUploadComplete(true),
80486:     mProgressSinceLastProgressEvent(false),
20640:     mUploadProgress(0), mUploadProgressMax(0),
88284:     mRequestSentTime(0), mTimeoutMilliseconds(0),
90244:     mErrorLoad(false), mWaitingForOnStopRequest(false),
90244:     mProgressTimerIsActive(false), mProgressEventWasDelayed(false),
82543:     mIsHtml(false),
82543:     mWarnAboutMultipartHtml(false),
82543:     mWarnAboutSyncHtml(false),
88284:     mLoadLengthComputable(false), mLoadTotal(0),
80486:     mFirstStartRequestSeen(false),
80486:     mInLoadProgressEvent(false),
78799:     mResultJSON(JSVAL_VOID),
78799:     mResultArrayBuffer(nsnull)
16665: {
16665:   nsLayoutStatics::AddRef();
94512: 
94512:   SetIsDOMBinding();
94307: #ifdef DEBUG
94307:   StaticAssertions();
94307: #endif
16665: }
16665: 
16665: nsXMLHttpRequest::~nsXMLHttpRequest()
16665: {
90101:   mState |= XML_HTTP_REQUEST_DELETED;
90101: 
16665:   if (mState & (XML_HTTP_REQUEST_STOPPED |
16665:                 XML_HTTP_REQUEST_SENT |
69662:                 XML_HTTP_REQUEST_LOADING)) {
16665:     Abort();
16665:   }
16665: 
16665:   NS_ABORT_IF_FALSE(!(mState & XML_HTTP_REQUEST_SYNCLOOPING), "we rather crash than hang");
16665:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
16665: 
16665:   nsLayoutStatics::Release();
16665: }
16665: 
70838: void
70838: nsXMLHttpRequest::RootResultArrayBuffer()
70838: {
72322:   nsContentUtils::PreserveWrapper(
72322:     static_cast<nsIDOMEventTarget*>(
72322:       static_cast<nsDOMEventTargetHelper*>(this)), this);
70838: }
70838: 
16665: /**
16665:  * This Init method is called from the factory constructor.
16665:  */
16665: nsresult
16665: nsXMLHttpRequest::Init()
16665: {
92083:   // Set the original mPrincipal, if available.
16665:   // Get JSContext from stack.
16665:   nsCOMPtr<nsIJSContextStack> stack =
16665:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
16665: 
16665:   if (!stack) {
16665:     return NS_OK;
16665:   }
16665: 
16665:   JSContext *cx;
16665: 
16665:   if (NS_FAILED(stack->Peek(&cx)) || !cx) {
16665:     return NS_OK;
16665:   }
16665: 
16665:   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
16665:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
16665:   if (secMan) {
72150:     nsresult rv = secMan->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
72150:     NS_ENSURE_SUCCESS(rv, rv);
16665:   }
16665:   NS_ENSURE_STATE(subjectPrincipal);
16665: 
16665:   nsIScriptContext* context = GetScriptContextFromJSContext(cx);
94512:   nsCOMPtr<nsPIDOMWindow> window;
16665:   if (context) {
94512:     window = do_QueryInterface(context->GetGlobalObject());
94512:     if (window) {
94512:       window = window->GetCurrentInnerWindow();
94512:     }
94512:   }
94512: 
94512:   Construct(subjectPrincipal, window);
16665:   return NS_OK;
16665: }
16665: /**
16665:  * This Init method should only be called by C++ consumers.
16665:  */
16665: NS_IMETHODIMP
16665: nsXMLHttpRequest::Init(nsIPrincipal* aPrincipal,
16665:                        nsIScriptContext* aScriptContext,
23201:                        nsPIDOMWindow* aOwnerWindow,
23201:                        nsIURI* aBaseURI)
16665: {
16665:   NS_ENSURE_ARG_POINTER(aPrincipal);
94512:   Construct(aPrincipal,
94512:             aOwnerWindow ? aOwnerWindow->GetCurrentInnerWindow() : nsnull,
94512:             aBaseURI);
16665:   return NS_OK;
16665: }
16665: 
16665: /**
16665:  * This Initialize method is called from XPConnect via nsIJSNativeInitializer.
16665:  */
16665: NS_IMETHODIMP
16665: nsXMLHttpRequest::Initialize(nsISupports* aOwner, JSContext* cx, JSObject* obj,
16665:                              PRUint32 argc, jsval *argv)
16665: {
92083:   nsCOMPtr<nsPIDOMWindow> owner = do_QueryInterface(aOwner);
92083:   if (!owner) {
16665:     NS_WARNING("Unexpected nsIJSNativeInitializer owner");
16665:     return NS_OK;
16665:   }
16665: 
16665:   // This XHR object is bound to a |window|,
16665:   // so re-set principal and script context.
16665:   nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal = do_QueryInterface(aOwner);
16665:   NS_ENSURE_STATE(scriptPrincipal);
94512: 
94512:   Construct(scriptPrincipal->GetPrincipal(), owner);
16665:   return NS_OK;
16665: }
16665: 
19944: void
78799: nsXMLHttpRequest::ResetResponse()
78799: {
78799:   mResponseXML = nsnull;
78799:   mResponseBody.Truncate();
78800:   mResponseText.Truncate();
78799:   mResponseBlob = nsnull;
88536:   mDOMFile = nsnull;
88536:   mBuilder = nsnull;
78799:   mResultArrayBuffer = nsnull;
78799:   mResultJSON = JSVAL_VOID;
78799:   mLoadTransferred = 0;
78800:   mResponseBodyDecodedPos = 0;
78799: }
78799: 
78799: void
19944: nsXMLHttpRequest::SetRequestObserver(nsIRequestObserver* aObserver)
19944: {
19944:   mRequestObserver = aObserver;
19944: }
19944: 
16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpRequest)
16665: 
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsXMLHttpRequest)
90244:   bool isBlack = tmp->IsBlack();
90244:   if (isBlack || tmp->mWaitingForOnStopRequest) {
88267:     if (tmp->mListenerManager) {
88267:       tmp->mListenerManager->UnmarkGrayJSListeners();
88267:       NS_UNMARK_LISTENER_WRAPPER(Load)
88267:       NS_UNMARK_LISTENER_WRAPPER(Error)
88267:       NS_UNMARK_LISTENER_WRAPPER(Abort)
88267:       NS_UNMARK_LISTENER_WRAPPER(LoadStart)
88267:       NS_UNMARK_LISTENER_WRAPPER(Progress)
88267:       NS_UNMARK_LISTENER_WRAPPER(Loadend)
88267:       NS_UNMARK_LISTENER_WRAPPER(UploadProgress)
88267:       NS_UNMARK_LISTENER_WRAPPER(Readystatechange)
88267:     }
93345:     if (!isBlack && tmp->PreservingWrapper()) {
93345:       xpc_UnmarkGrayObject(tmp->GetWrapperPreserveColor());
90244:     }
88267:     return true;
88267:   }
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
88267: 
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsXMLHttpRequest)
88267:   return tmp->IsBlack();
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
88267: 
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsXMLHttpRequest)
88267:   return tmp->IsBlack();
88267: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
88267: 
16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXMLHttpRequest,
16665:                                                   nsXHREventTarget)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mReadRequest)
21005:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mResponseXML)
64070:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCORSPreflightChannel)
16665: 
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnUploadProgressListener)
79469:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnReadystatechangeListener)
79469: 
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXMLParserStreamListener)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannelEventSink)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mProgressEventSink)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mUpload,
16665:                                                        nsIXMLHttpRequestUpload)
16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
16665: 
16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsXMLHttpRequest,
16665:                                                 nsXHREventTarget)
70838:   tmp->mResultArrayBuffer = nsnull;
78115:   tmp->mResultJSON = JSVAL_VOID;
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChannel)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mReadRequest)
21005:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mResponseXML)
64070:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCORSPreflightChannel)
16665: 
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnUploadProgressListener)
79469:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnReadystatechangeListener)
79469: 
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mXMLParserStreamListener)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChannelEventSink)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mProgressEventSink)
16665: 
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mUpload)
16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16665: 
70838: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED(nsXMLHttpRequest,
70838:                                                nsXHREventTarget)
70838:   if(tmp->mResultArrayBuffer) {
70838:     NS_IMPL_CYCLE_COLLECTION_TRACE_JS_CALLBACK(tmp->mResultArrayBuffer,
70838:                                                "mResultArrayBuffer")
70838:   }
78115:   if (JSVAL_IS_GCTHING(tmp->mResultJSON)) {
78115:     void *gcThing = JSVAL_TO_GCTHING(tmp->mResultJSON);
78115:     NS_IMPL_CYCLE_COLLECTION_TRACE_JS_CALLBACK(gcThing, "mResultJSON")
78115:   }
70838: NS_IMPL_CYCLE_COLLECTION_TRACE_END
70838: 
40490: DOMCI_DATA(XMLHttpRequest, nsXMLHttpRequest)
16665: 
16665: // QueryInterface implementation for nsXMLHttpRequest
16665: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXMLHttpRequest)
16665:   NS_INTERFACE_MAP_ENTRY(nsIXMLHttpRequest)
16665:   NS_INTERFACE_MAP_ENTRY(nsIJSXMLHttpRequest)
16665:   NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
16665:   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
16665:   NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
16665:   NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
16665:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
16665:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
16665:   NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
20640:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XMLHttpRequest)
16665: NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
16665: 
16665: NS_IMPL_ADDREF_INHERITED(nsXMLHttpRequest, nsXHREventTarget)
16665: NS_IMPL_RELEASE_INHERITED(nsXMLHttpRequest, nsXHREventTarget)
16665: 
92083: void
92083: nsXMLHttpRequest::DisconnectFromOwner()
92083: {
92083:   nsXHREventTarget::DisconnectFromOwner();
92083:   NS_DISCONNECT_EVENT_HANDLER(UploadProgress)
92083:   NS_DISCONNECT_EVENT_HANDLER(Readystatechange)
92084:   Abort();
92083: }
92083: 
79469: NS_IMETHODIMP
79469: nsXMLHttpRequest::GetOnreadystatechange(nsIDOMEventListener * *aOnreadystatechange)
79469: {
79469:   return
79469:     nsXHREventTarget::GetInnerEventListener(mOnReadystatechangeListener,
79469:                                             aOnreadystatechange);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXMLHttpRequest::SetOnreadystatechange(nsIDOMEventListener * aOnreadystatechange)
79469: {
79469:   return
79469:     nsXHREventTarget::RemoveAddEventListener(NS_LITERAL_STRING(READYSTATE_STR),
79469:                                              mOnReadystatechangeListener,
79469:                                              aOnreadystatechange);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXMLHttpRequest::GetOnuploadprogress(nsIDOMEventListener * *aOnuploadprogress)
79469: {
79469:   return
79469:     nsXHREventTarget::GetInnerEventListener(mOnUploadProgressListener,
79469:                                             aOnuploadprogress);
79469: }
79469: 
79469: NS_IMETHODIMP
79469: nsXMLHttpRequest::SetOnuploadprogress(nsIDOMEventListener * aOnuploadprogress)
79469: {
79469:   return
79469:     nsXHREventTarget::RemoveAddEventListener(NS_LITERAL_STRING(UPLOADPROGRESS_STR),
79469:                                              mOnUploadProgressListener,
79469:                                              aOnuploadprogress);
79469: }
    1: 
    1: /* readonly attribute nsIChannel channel; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetChannel(nsIChannel **aChannel)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aChannel);
    1:   NS_IF_ADDREF(*aChannel = mChannel);
    1: 
    1:   return NS_OK;
    1: }
    1: 
84264: static void LogMessage(const char* aWarning, nsPIDOMWindow* aWindow)
84264: {
84264:   nsCOMPtr<nsIDocument> doc;
84264:   if (aWindow) {
84264:     doc = do_QueryInterface(aWindow->GetExtantDocument());
84264:   }
84636:   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
84636:                                   "DOM", doc,
84636:                                   nsContentUtils::eDOM_PROPERTIES,
84636:                                   aWarning);
84264: }
84264: 
    1: /* readonly attribute nsIDOMDocument responseXML; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetResponseXML(nsIDOMDocument **aResponseXML)
    1: {
94307:   nsresult rv = NS_OK;
94307:   nsIDocument* responseXML = GetResponseXML(rv);
94307:   NS_ENSURE_SUCCESS(rv, rv);
94307: 
94307:   if (!responseXML) {
    1:     *aResponseXML = nsnull;
94307:     return NS_OK;
94307:   }
94307: 
94307:   return CallQueryInterface(responseXML, aResponseXML);
94307: }
94307: 
94307: nsIDocument*
94307: nsXMLHttpRequest::GetResponseXML(nsresult& aRv)
94307: {
69662:   if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT &&
69662:       mResponseType != XML_HTTP_RESPONSE_TYPE_DOCUMENT) {
94307:     aRv = NS_ERROR_DOM_INVALID_STATE_ERR;
94307:     return nsnull;
    1:   }
82543:   if (mWarnAboutMultipartHtml) {
82543:     mWarnAboutMultipartHtml = false;
92083:     LogMessage("HTMLMultipartXHRWarning", GetOwner());
82543:   }
82543:   if (mWarnAboutSyncHtml) {
82543:     mWarnAboutSyncHtml = false;
92083:     LogMessage("HTMLSyncXHRWarning", GetOwner());
82543:   }
94307:   return (XML_HTTP_REQUEST_DONE & mState) ? mResponseXML : nsnull;
    1: }
    1: 
    1: /*
    1:  * This piece copied from nsXMLDocument, we try to get the charset
    1:  * from HTTP headers.
    1:  */
    1: nsresult
78800: nsXMLHttpRequest::DetectCharset()
    1: {
78800:   mResponseCharset.Truncate();
78800:   mDecoder = nsnull;
78800: 
78800:   if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT &&
78800:       mResponseType != XML_HTTP_RESPONSE_TYPE_TEXT &&
78801:       mResponseType != XML_HTTP_RESPONSE_TYPE_JSON &&
78801:       mResponseType != XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
78800:     return NS_OK;
78800:   }
78800: 
78800:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(mReadRequest);
    1:   if (!channel) {
    1:     channel = mChannel;
78800:   }
78800: 
78800:   nsCAutoString charsetVal;
78800:   nsresult rv = channel ? channel->GetContentCharset(charsetVal) :
78800:                 NS_ERROR_FAILURE;
    1:   if (NS_SUCCEEDED(rv)) {
91519:     rv = nsCharsetAlias::GetPreferred(charsetVal, mResponseCharset);
78800:   }
78800: 
78800:   if (NS_FAILED(rv) || mResponseCharset.IsEmpty()) {
78800:     // MS documentation states UTF-8 is default for responseText
78800:     mResponseCharset.AssignLiteral("UTF-8");
78800:   }
78800: 
84266:   if (mResponseType == XML_HTTP_RESPONSE_TYPE_JSON &&
84266:       !mResponseCharset.EqualsLiteral("UTF-8")) {
84266:     // The XHR spec says only UTF-8 is supported for responseType == "json"
92083:     LogMessage("JSONCharsetWarning", GetOwner());
84266:     mResponseCharset.AssignLiteral("UTF-8");
84266:   }
84266: 
78800:   nsCOMPtr<nsICharsetConverterManager> ccm =
78800:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
78800:   NS_ENSURE_SUCCESS(rv, rv);
78800: 
78800:   return ccm->GetUnicodeDecoderRaw(mResponseCharset.get(),
78800:                                    getter_AddRefs(mDecoder));
    1: }
    1: 
    1: nsresult
78800: nsXMLHttpRequest::AppendToResponseText(const char * aSrcBuffer,
78800:                                        PRUint32 aSrcBufferLen)
    1: {
78800:   NS_ENSURE_STATE(mDecoder);
78800: 
78800:   PRInt32 destBufferLen;
78800:   nsresult rv = mDecoder->GetMaxLength(aSrcBuffer, aSrcBufferLen,
78800:                                        &destBufferLen);
78800:   NS_ENSURE_SUCCESS(rv, rv);
78800: 
78800:   if (!mResponseText.SetCapacity(mResponseText.Length() + destBufferLen)) {
78800:     return NS_ERROR_OUT_OF_MEMORY;
78800:   }
78800: 
78800:   PRUnichar* destBuffer = mResponseText.BeginWriting() + mResponseText.Length();
78800: 
78800:   PRInt32 totalChars = mResponseText.Length();
78800: 
    1:   // This code here is basically a copy of a similar thing in
    1:   // nsScanner::Append(const char* aBuffer, PRUint32 aLen).
    1:   // If we get illegal characters in the input we replace
    1:   // them and don't just fail.
    1:   do {
78800:     PRInt32 srclen = (PRInt32)aSrcBufferLen;
78800:     PRInt32 destlen = (PRInt32)destBufferLen;
78800:     rv = mDecoder->Convert(aSrcBuffer,
78800:                            &srclen,
78800:                            destBuffer,
78800:                            &destlen);
    1:     if (NS_FAILED(rv)) {
    1:       // We consume one byte, replace it with U+FFFD
    1:       // and try the conversion again.
78800: 
78800:       destBuffer[destlen] = (PRUnichar)0xFFFD; // add replacement character
78800:       destlen++; // skip written replacement character
78800:       destBuffer += destlen;
78800:       destBufferLen -= destlen;
78800: 
78800:       if (srclen < (PRInt32)aSrcBufferLen) {
78800:         srclen++; // Consume the invalid character
78800:       }
78800:       aSrcBuffer += srclen;
78800:       aSrcBufferLen -= srclen;
78800: 
78800:       mDecoder->Reset();
78800:     }
78800: 
78800:     totalChars += destlen;
78800: 
78800:   } while (NS_FAILED(rv) && aSrcBufferLen > 0);
78800: 
78800:   mResponseText.SetLength(totalChars);
78800: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute AString responseText; */
94307: NS_IMETHODIMP
94307: nsXMLHttpRequest::GetResponseText(nsAString& aResponseText)
94307: {
94307:   nsresult rv = NS_OK;
94307:   nsString responseText;
94307:   GetResponseText(responseText, rv);
94307:   aResponseText = responseText;
94307:   return rv;
94307: }
94307: 
94307: void
94307: nsXMLHttpRequest::GetResponseText(nsString& aResponseText, nsresult& aRv)
    1: {
    1:   aResponseText.Truncate();
    1: 
69662:   if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT &&
78801:       mResponseType != XML_HTTP_RESPONSE_TYPE_TEXT &&
78801:       mResponseType != XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
94307:     aRv = NS_ERROR_DOM_INVALID_STATE_ERR;
94307:     return;
69662:   }
69662: 
78801:   if (mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT &&
78801:       !mInLoadProgressEvent) {
80486:     aResponseText.SetIsVoid(true);
94307:     return;
78801:   }
78801: 
78800:   if (!(mState & (XML_HTTP_REQUEST_DONE | XML_HTTP_REQUEST_LOADING))) {
94307:     return;
78800:   }
78800: 
78800:   // We only decode text lazily if we're also parsing to a doc.
78800:   // Also, if we've decoded all current data already, then no need to decode
78800:   // more.
82735:   if (!mResponseXML ||
78800:       mResponseBodyDecodedPos == mResponseBody.Length()) {
78800:     aResponseText = mResponseText;
94307:     return;
94307:   }
94307: 
94307:   if (mResponseCharset != mResponseXML->GetDocumentCharacterSet()) {
94307:     mResponseCharset = mResponseXML->GetDocumentCharacterSet();
78800:     mResponseText.Truncate();
78800:     mResponseBodyDecodedPos = 0;
78800: 
78800:     nsCOMPtr<nsICharsetConverterManager> ccm =
94307:       do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &aRv);
94307:     if (NS_FAILED(aRv)) {
94307:       return;
94307:     }
94307: 
94307:     aRv = ccm->GetUnicodeDecoderRaw(mResponseCharset.get(),
78800:                                     getter_AddRefs(mDecoder));
94307:     if (NS_FAILED(aRv)) {
94307:       return;
94307:     }
78800:   }
78800: 
78800:   NS_ASSERTION(mResponseBodyDecodedPos < mResponseBody.Length(),
78800:                "Unexpected mResponseBodyDecodedPos");
94307:   aRv = AppendToResponseText(mResponseBody.get() + mResponseBodyDecodedPos,
78800:                              mResponseBody.Length() - mResponseBodyDecodedPos);
94307:   if (NS_FAILED(aRv)) {
94307:     return;
94307:   }
78800: 
78800:   mResponseBodyDecodedPos = mResponseBody.Length();
78800:   
78800:   if (mState & XML_HTTP_REQUEST_DONE) {
78800:     // Free memory buffer which we no longer need
78800:     mResponseBody.Truncate();
78800:     mResponseBodyDecodedPos = 0;
78800:   }
78800: 
78800:   aResponseText = mResponseText;
    1: }
    1: 
78115: nsresult
78115: nsXMLHttpRequest::CreateResponseParsedJSON(JSContext* aCx)
50604: {
78115:   if (!aCx) {
50604:     return NS_ERROR_FAILURE;
78115:   }
84266:   // The Unicode converter has already zapped the BOM if there was one
78115:   if (!JS_ParseJSON(aCx,
94307:                     static_cast<const jschar*>(mResponseText.get()),
78800:                     mResponseText.Length(), &mResultJSON)) {
78115:     return NS_ERROR_FAILURE;
78115:   }
78115: 
78115:   return NS_OK;
78115: }
78115: 
88536: nsresult
88536: nsXMLHttpRequest::CreatePartialBlob()
88536: {
88536:   if (mDOMFile) {
88536:     if (mLoadTotal == mLoadTransferred) {
88536:       mResponseBlob = mDOMFile;
88536:     } else {
88536:       mResponseBlob =
88536:         mDOMFile->CreateSlice(0, mLoadTransferred, EmptyString());
88536:     }
88536:     return NS_OK;
88536:   }
88536: 
97346:   // mBuilder can be null if the request has been canceled
97346:   if (!mBuilder) {
97346:     return NS_OK;
97346:   }
97346: 
88536:   nsCAutoString contentType;
88536:   if (mLoadTotal == mLoadTransferred) {
88536:     mChannel->GetContentType(contentType);
88536:   }
88536: 
88536:   return mBuilder->GetBlobInternal(NS_ConvertASCIItoUTF16(contentType),
88536:                                    false, getter_AddRefs(mResponseBlob));
88536: }
88536: 
69662: /* attribute AString responseType; */
70067: NS_IMETHODIMP nsXMLHttpRequest::GetResponseType(nsAString& aResponseType)
69662: {
69662:   switch (mResponseType) {
69662:   case XML_HTTP_RESPONSE_TYPE_DEFAULT:
69662:     aResponseType.Truncate();
69662:     break;
69662:   case XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER:
69662:     aResponseType.AssignLiteral("arraybuffer");
69662:     break;
69662:   case XML_HTTP_RESPONSE_TYPE_BLOB:
69662:     aResponseType.AssignLiteral("blob");
69662:     break;
69662:   case XML_HTTP_RESPONSE_TYPE_DOCUMENT:
69662:     aResponseType.AssignLiteral("document");
69662:     break;
69662:   case XML_HTTP_RESPONSE_TYPE_TEXT:
69662:     aResponseType.AssignLiteral("text");
69662:     break;
78115:   case XML_HTTP_RESPONSE_TYPE_JSON:
84266:     aResponseType.AssignLiteral("json");
78115:     break;
78801:   case XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT:
78801:     aResponseType.AssignLiteral("moz-chunked-text");
78801:     break;
78801:   case XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER:
78801:     aResponseType.AssignLiteral("moz-chunked-arraybuffer");
78801:     break;
88536:   case XML_HTTP_RESPONSE_TYPE_MOZ_BLOB:
88536:     aResponseType.AssignLiteral("moz-blob");
88536:     break;
69662:   default:
69662:     NS_ERROR("Should not happen");
69662:   }
69662: 
69662:   return NS_OK;
69662: }
69662: 
94307: #ifdef DEBUG
94307: void
94307: nsXMLHttpRequest::StaticAssertions()
94307: {
94307: #define ASSERT_ENUM_EQUAL(_lc, _uc) \
94307:   MOZ_STATIC_ASSERT(\
94307:     bindings::prototypes::XMLHttpRequestResponseType::_lc \
94307:       == bindings::prototypes::XMLHttpRequestResponseType::value(XML_HTTP_RESPONSE_TYPE_ ## _uc), \
94307:     #_uc " should match")
94307: 
94512:   ASSERT_ENUM_EQUAL(_empty, DEFAULT);
94512:   ASSERT_ENUM_EQUAL(arraybuffer, ARRAYBUFFER);
94512:   ASSERT_ENUM_EQUAL(blob, BLOB);
94512:   ASSERT_ENUM_EQUAL(document, DOCUMENT);
94512:   ASSERT_ENUM_EQUAL(json, JSON);
94512:   ASSERT_ENUM_EQUAL(text, TEXT);
94512:   ASSERT_ENUM_EQUAL(moz_chunked_text, CHUNKED_TEXT);
94512:   ASSERT_ENUM_EQUAL(moz_chunked_arraybuffer, CHUNKED_ARRAYBUFFER);
94512:   ASSERT_ENUM_EQUAL(moz_blob, MOZ_BLOB);
94307: #undef ASSERT_ENUM_EQUAL
94307: }
94307: #endif
94307: 
69662: /* attribute AString responseType; */
70067: NS_IMETHODIMP nsXMLHttpRequest::SetResponseType(const nsAString& aResponseType)
69662: {
94307:   nsXMLHttpRequest::ResponseType responseType;
94307:   if (aResponseType.IsEmpty()) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_DEFAULT;
94307:   } else if (aResponseType.EqualsLiteral("arraybuffer")) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER;
94307:   } else if (aResponseType.EqualsLiteral("blob")) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_BLOB;
94307:   } else if (aResponseType.EqualsLiteral("document")) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_DOCUMENT;
94307:   } else if (aResponseType.EqualsLiteral("text")) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_TEXT;
94307:   } else if (aResponseType.EqualsLiteral("json")) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_JSON;
94307:   } else if (aResponseType.EqualsLiteral("moz-chunked-text")) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT;
94307:   } else if (aResponseType.EqualsLiteral("moz-chunked-arraybuffer")) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER;
94307:   } else if (aResponseType.EqualsLiteral("moz-blob")) {
94307:     responseType = XML_HTTP_RESPONSE_TYPE_MOZ_BLOB;
94307:   } else {
94307:     return NS_OK;
94307:   }
94307: 
94307:   nsresult rv = NS_OK;
94307:   SetResponseType(responseType, rv);
94307:   return rv;
94307: }
94307: 
94307: void
94512: nsXMLHttpRequest::SetResponseType(XMLHttpRequestResponseType aType,
94512:                                   nsresult& aRv)
94512: {
94512:   SetResponseType(ResponseType(aType), aRv);
94512: }
94512: 
94512: void
94307: nsXMLHttpRequest::SetResponseType(nsXMLHttpRequest::ResponseType aResponseType,
94307:                                   nsresult& aRv)
94307: {
69662:   // If the state is not OPENED or HEADERS_RECEIVED raise an
69662:   // INVALID_STATE_ERR exception and terminate these steps.
69662:   if (!(mState & (XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT |
94307:                   XML_HTTP_REQUEST_HEADERS_RECEIVED))) {
94307:     aRv = NS_ERROR_DOM_INVALID_STATE_ERR;
94307:     return;
94307:   }
69662: 
84264:   // sync request is not allowed setting responseType in window context
92083:   if (HasOrHasHadOwner() &&
84264:       !(mState & (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_ASYNC))) {
92083:     LogMessage("ResponseTypeSyncXHRWarning", GetOwner());
94307:     aRv = NS_ERROR_DOM_INVALID_ACCESS_ERR;
94307:     return;
94307:   }
94307: 
94307:   if (!(mState & XML_HTTP_REQUEST_ASYNC) &&
94307:       (aResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT ||
94307:        aResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER)) {
94307:     aRv = NS_ERROR_DOM_INVALID_STATE_ERR;
94307:     return;
84264:   }
84264: 
69662:   // Set the responseType attribute's value to the given value.
94307:   mResponseType = aResponseType;
69662: 
69662:   // If the state is OPENED, SetCacheAsFile would have no effect here
69662:   // because the channel hasn't initialized the cache entry yet.
69662:   // SetCacheAsFile will be called from OnStartRequest.
69662:   // If the state is HEADERS_RECEIVED, however, we need to call
69662:   // it immediately because OnStartRequest is already dispatched.
69662:   if (mState & XML_HTTP_REQUEST_HEADERS_RECEIVED) {
69662:     nsCOMPtr<nsICachingChannel> cc(do_QueryInterface(mChannel));
69662:     if (cc) {
88536:       cc->SetCacheAsFile(mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
88536:                          mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB);
69662:     }
69662:   }
94307:   aRv = NS_OK;
69662: }
69662: 
69662: /* readonly attribute jsval response; */
94307: NS_IMETHODIMP
94307: nsXMLHttpRequest::GetResponse(JSContext *aCx, jsval *aResult)
69662: {
69662:   nsresult rv = NS_OK;
94307:   *aResult = GetResponse(aCx, rv);
94307:   return rv;
94307: }
94307: 
94307: JS::Value
94307: nsXMLHttpRequest::GetResponse(JSContext* aCx, nsresult& aRv)
94307: {
69662:   switch (mResponseType) {
69662:   case XML_HTTP_RESPONSE_TYPE_DEFAULT:
69662:   case XML_HTTP_RESPONSE_TYPE_TEXT:
78801:   case XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT:
69662:   {
69662:     nsString str;
94307:     aRv = GetResponseText(str);
94307:     if (NS_FAILED(aRv)) {
94307:       return JSVAL_NULL;
94307:     }
94307:     JS::Value result;
94307:     if (!xpc::StringToJsval(aCx, str, &result)) {
94307:       aRv = NS_ERROR_OUT_OF_MEMORY;
94307:       return JSVAL_NULL;
94307:     }
94307:     return result;
94307:   }
69662: 
69662:   case XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER:
78801:   case XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER:
94307:   {
94307:     if (!(mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER &&
94307:           mState & XML_HTTP_REQUEST_DONE) &&
94307:         !(mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER &&
78801:           mInLoadProgressEvent)) {
94307:       return JSVAL_NULL;
94307:     }
94307: 
70838:     if (!mResultArrayBuffer) {
84707:       RootResultArrayBuffer();
94307:       aRv = nsContentUtils::CreateArrayBuffer(aCx, mResponseBody,
84707:                                               &mResultArrayBuffer);
94307:       if (NS_FAILED(aRv)) {
94307:         return JSVAL_NULL;
94307:       }
94307:     }
94307:     return OBJECT_TO_JSVAL(mResultArrayBuffer);
94307:   }
69662:   case XML_HTTP_RESPONSE_TYPE_BLOB:
88536:   case XML_HTTP_RESPONSE_TYPE_MOZ_BLOB:
94307:   {
94307:     if (!(mState & XML_HTTP_REQUEST_DONE)) {
94307:       if (mResponseType != XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
94307:         return JSVAL_NULL;
94307:       }
94307: 
88536:       if (!mResponseBlob) {
94307:         aRv = CreatePartialBlob();
94307:         if (NS_FAILED(aRv)) {
94307:           return JSVAL_NULL;
94307:         }
94307:       }
94307:     }
94307: 
94307:     if (!mResponseBlob) {
94307:       return JSVAL_NULL;
94307:     }
94307: 
94307:     JS::Value result = JSVAL_NULL;
80154:     JSObject* scope = JS_GetGlobalForScopeChain(aCx);
94307:     aRv = nsContentUtils::WrapNative(aCx, scope, mResponseBlob, &result,
80486:                                      nsnull, true);
94307:     return result;
94307:   }
69662:   case XML_HTTP_RESPONSE_TYPE_DOCUMENT:
94307:   {
94307:     if (!(mState & XML_HTTP_REQUEST_DONE) || !mResponseXML) {
94307:       return JSVAL_NULL;
94307:     }
94307: 
80154:     JSObject* scope = JS_GetGlobalForScopeChain(aCx);
94307:     JS::Value result = JSVAL_NULL;
94307:     aRv = nsContentUtils::WrapNative(aCx, scope, mResponseXML, &result,
80486:                                      nsnull, true);
94307:     return result;
94307:   }
78115:   case XML_HTTP_RESPONSE_TYPE_JSON:
94307:   {
94307:     if (!(mState & XML_HTTP_REQUEST_DONE)) {
94307:       return JSVAL_NULL;
94307:     }
94307: 
78115:     if (mResultJSON == JSVAL_VOID) {
94307:       aRv = CreateResponseParsedJSON(aCx);
78800:       mResponseText.Truncate();
94307:       if (NS_FAILED(aRv)) {
84266:         // Per spec, errors aren't propagated. null is returned instead.
94307:         aRv = NS_OK;
84266:         // It would be nice to log the error to the console. That's hard to
84266:         // do without calling window.onerror as a side effect, though.
84266:         JS_ClearPendingException(aCx);
84266:         mResultJSON = JSVAL_NULL;
84266:       }
78115:     }
94307:     return mResultJSON;
94307:   }
69662:   default:
69662:     NS_ERROR("Should not happen");
69662:   }
69662: 
94307:   return JSVAL_NULL;
69662: }
69662: 
    1: /* readonly attribute unsigned long status; */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetStatus(PRUint32 *aStatus)
    1: {
94307:   *aStatus = GetStatus();
94307:   return NS_OK;
94307: }
94307: 
94307: uint32_t
94307: nsXMLHttpRequest::GetStatus()
94307: {
19952:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
19952:     // Make sure we don't leak status information from denied cross-site
19952:     // requests.
19952:     if (mChannel) {
19952:       nsresult status;
19952:       mChannel->GetStatus(&status);
19952:       if (NS_FAILED(status)) {
94307:         return 0;
19952:       }
19952:     }
19952:   }
19952: 
94034:   PRUint16 readyState;
94034:   GetReadyState(&readyState);
94034:   if (readyState == UNSENT || readyState == OPENED || mErrorLoad) {
94307:     return 0;
94034:   }
94034: 
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
94307:   if (!httpChannel) {
94307:     return 0;
94307:   }
94307: 
94307:   PRUint32 status;
94307:   nsresult rv = httpChannel->GetResponseStatus(&status);
94034:   if (NS_FAILED(rv)) {
94307:     status = 0;
94307:   }
94307: 
94307:   return status;
94307: }
94307: 
94307: IMPL_STRING_GETTER(GetStatusText)
94307: void
94307: nsXMLHttpRequest::GetStatusText(nsString& aStatusText)
    1: {
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
    1: 
    1:   aStatusText.Truncate();
    1: 
94307:   if (!httpChannel) {
94307:     return;
94307:   }
94307: 
39491:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
39491:     // Make sure we don't leak status information from denied cross-site
39491:     // requests.
39491:     if (mChannel) {
39491:       nsresult status;
39491:       mChannel->GetStatus(&status);
39491:       if (NS_FAILED(status)) {
94307:         return;
94307:       }
94307:     }
94307:   }
94307: 
94307:   nsCString statusText;
94307:   httpChannel->GetResponseStatusText(statusText);
94307:   if (statusText.IsVoid()) {
94307:     aStatusText.SetIsVoid(true);
94307:   } else {
94307:     // We use UTF8ToNewUnicode here because it truncates after invalid UTF-8
94307:     // characters, CopyUTF8toUTF16 just doesn't copy in that case.
94307:     PRUint32 length;
94307:     PRUnichar* chars = UTF8ToNewUnicode(statusText, &length);
94307:     aStatusText.Adopt(chars, length);
94307:   }
    1: }
    1: 
88284: void
88284: nsXMLHttpRequest::CloseRequestWithError(const nsAString& aType,
88284:                                         const PRUint32 aFlag)
    1: {
    1:   if (mReadRequest) {
    1:     mReadRequest->Cancel(NS_BINDING_ABORTED);
    1:   }
    1:   if (mChannel) {
    1:     mChannel->Cancel(NS_BINDING_ABORTED);
    1:   }
64070:   if (mCORSPreflightChannel) {
64070:     mCORSPreflightChannel->Cancel(NS_BINDING_ABORTED);
19951:   }
88284:   if (mTimeoutTimer) {
88284:     mTimeoutTimer->Cancel();
88284:   }
20640:   PRUint32 responseLength = mResponseBody.Length();
78799:   ResetResponse();
88284:   mState |= aFlag;
    1: 
90101:   // If we're in the destructor, don't risk dispatching an event.
90516:   if (mState & XML_HTTP_REQUEST_DELETED) {
90516:     mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
90101:     return;
90516:   }
90101: 
69662:   if (!(mState & (XML_HTTP_REQUEST_UNSENT |
11304:                   XML_HTTP_REQUEST_OPENED |
69662:                   XML_HTTP_REQUEST_DONE))) {
80486:     ChangeState(XML_HTTP_REQUEST_DONE, true);
    1: 
16665:     if (!(mState & XML_HTTP_REQUEST_SYNCLOOPING)) {
88284:       DispatchProgressEvent(this, aType, mLoadLengthComputable, responseLength,
20640:                             mLoadTotal);
16665:       if (mUpload && !mUploadComplete) {
80486:         mUploadComplete = true;
88284:         DispatchProgressEvent(mUpload, aType, true, mUploadTransferred,
16665:                               mUploadTotal);
16665:       }
16665:     }
82572:   }
16665: 
    1:   // The ChangeState call above calls onreadystatechange handlers which
64068:   // if they load a new url will cause nsXMLHttpRequest::Open to clear
    1:   // the abort state bit. If this occurs we're not uninitialized (bug 361773).
    1:   if (mState & XML_HTTP_REQUEST_ABORTED) {
80486:     ChangeState(XML_HTTP_REQUEST_UNSENT, false);  // IE seems to do it
    1:   }
    1: 
18378:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
88284: }
88284: 
88284: /* void abort (); */
94307: void
88284: nsXMLHttpRequest::Abort()
88284: {
88284:   CloseRequestWithError(NS_LITERAL_STRING(ABORT_STR), XML_HTTP_REQUEST_ABORTED);
94307: }
94307: 
94307: NS_IMETHODIMP
94307: nsXMLHttpRequest::SlowAbort()
94307: {
94307:   Abort();
    1:   return NS_OK;
    1: }
    1: 
90481: /* DOMString getAllResponseHeaders(); */
94307: IMPL_STRING_GETTER(GetAllResponseHeaders)
94307: void
94307: nsXMLHttpRequest::GetAllResponseHeaders(nsString& aResponseHeaders)
    1: {
90481:   aResponseHeaders.Truncate();
    1: 
90450:   // If the state is UNSENT or OPENED,
90450:   // return the empty string and terminate these steps.
90450:   if (mState & (XML_HTTP_REQUEST_UNSENT |
90450:                 XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
94307:     return;
90450:   }
90450: 
19951:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
94307:     return;
19951:   }
19951: 
90481:   if (nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel()) {
57364:     nsRefPtr<nsHeaderVisitor> visitor = new nsHeaderVisitor();
90481:     if (NS_SUCCEEDED(httpChannel->VisitResponseHeaders(visitor))) {
94307:       CopyASCIItoUTF16(visitor->Headers(), aResponseHeaders);
94307:     }
94307:     return;
90481:   }
90481: 
90481:   if (!mChannel) {
94307:     return;
90481:   }
90481: 
90450:   // Even non-http channels supply content type.
90481:   nsCAutoString value;
90450:   if (NS_SUCCEEDED(mChannel->GetContentType(value))) {
90481:     aResponseHeaders.AppendLiteral("Content-Type: ");
94307:     AppendASCIItoUTF16(value, aResponseHeaders);
94307:     if (NS_SUCCEEDED(mChannel->GetContentCharset(value)) && !value.IsEmpty()) {
90481:       aResponseHeaders.AppendLiteral(";charset=");
94307:       AppendASCIItoUTF16(value, aResponseHeaders);
90481:     }
90481:     aResponseHeaders.Append('\n');
90481:   }
94307: }
94307: 
    1: NS_IMETHODIMP
94307: nsXMLHttpRequest::GetResponseHeader(const nsACString& aHeader,
94307:                                     nsACString& aResult)
    1: {
    1:   nsresult rv = NS_OK;
94307:   GetResponseHeader(aHeader, aResult, rv);
94307:   return rv;
94307: }
94307: 
94307: void
94307: nsXMLHttpRequest::GetResponseHeader(const nsACString& header,
94307:                                     nsACString& _retval, nsresult& aRv)
94307: {
80486:   _retval.SetIsVoid(true);
54923: 
54923:   nsCOMPtr<nsIHttpChannel> httpChannel = GetCurrentHttpChannel();
54923: 
54923:   if (!httpChannel) {
90450:     // If the state is UNSENT or OPENED,
90450:     // return null and terminate these steps.
90450:     if (mState & (XML_HTTP_REQUEST_UNSENT |
90450:                   XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
94307:       return;
90450:     }
90450: 
90450:     // Even non-http channels supply content type.
90450:     // Remember we don't leak header information from denied cross-site
90450:     // requests.
90450:     nsresult status;
90450:     if (!mChannel ||
90450:         NS_FAILED(mChannel->GetStatus(&status)) ||
90450:         NS_FAILED(status) ||
90450:         !header.LowerCaseEqualsASCII("content-type")) {
94307:       return;
90450:     }
90450: 
90450:     if (NS_FAILED(mChannel->GetContentType(_retval))) {
90450:       // Means no content type
90450:       _retval.SetIsVoid(true);
94307:       return;
90450:     }
90450: 
90450:     nsCString value;
90450:     if (NS_SUCCEEDED(mChannel->GetContentCharset(value)) &&
90450:         !value.IsEmpty()) {
90450:       _retval.Append(";charset=");
90450:       _retval.Append(value);
90450:     }
90450: 
94307:     return;
54923:   }
    1: 
21639:   // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
79445:   bool chrome = false; // default to false in case IsCapabilityEnabled fails
21639:   IsCapabilityEnabled("UniversalXPConnect", &chrome);
21639:   if (!chrome &&
21639:        (header.LowerCaseEqualsASCII("set-cookie") ||
21639:         header.LowerCaseEqualsASCII("set-cookie2"))) {
21639:     NS_WARNING("blocked access to response header");
94307:     return;
21639:   }
21639: 
19951:   // Check for dangerous headers
19951:   if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
19951:     // Make sure we don't leak header information from denied cross-site
19951:     // requests.
19951:     if (mChannel) {
19951:       nsresult status;
19951:       mChannel->GetStatus(&status);
19951:       if (NS_FAILED(status)) {
94307:         return;
19951:       }
19951:     }
19951: 
19951:     const char *kCrossOriginSafeHeaders[] = {
19951:       "cache-control", "content-language", "content-type", "expires",
19951:       "last-modified", "pragma"
19951:     };
79445:     bool safeHeader = false;
19951:     PRUint32 i;
80467:     for (i = 0; i < ArrayLength(kCrossOriginSafeHeaders); ++i) {
19951:       if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
80486:         safeHeader = true;
19951:         break;
19951:       }
19951:     }
19951: 
19951:     if (!safeHeader) {
54923:       nsCAutoString headerVal;
54923:       // The "Access-Control-Expose-Headers" header contains a comma separated
54923:       // list of method names.
54923:       httpChannel->
54923:         GetResponseHeader(NS_LITERAL_CSTRING("Access-Control-Expose-Headers"),
54923:                           headerVal);
54923:       nsCCharSeparatedTokenizer exposeTokens(headerVal, ',');
54923:       while(exposeTokens.hasMoreTokens()) {
54923:         const nsDependentCSubstring& token = exposeTokens.nextToken();
54923:         if (token.IsEmpty()) {
54923:           continue;
54923:         }
54923:         if (!IsValidHTTPToken(token)) {
94307:           return;
19951:         }
54923:         if (header.Equals(token, nsCaseInsensitiveCStringComparator())) {
80486:           safeHeader = true;
54923:         }
54923:       }
54923:     }
54923: 
54923:     if (!safeHeader) {
94307:       return;
94307:     }
94307:   }
94307: 
94307:   aRv = httpChannel->GetResponseHeader(header, _retval);
94307:   if (aRv == NS_ERROR_NOT_AVAILABLE) {
    1:     // Means no header
80486:     _retval.SetIsVoid(true);
94307:     aRv = NS_OK;
94307:   }
    1: }
    1: 
77186: already_AddRefed<nsILoadGroup>
77186: nsXMLHttpRequest::GetLoadGroup() const
20560: {
20560:   if (mState & XML_HTTP_REQUEST_BACKGROUND) {                 
77186:     return nsnull;
20560:   }
20560: 
92083:   nsresult rv = NS_ERROR_FAILURE;
92083:   nsIScriptContext* sc =
92083:     const_cast<nsXMLHttpRequest*>(this)->GetContextForEventHandlers(&rv);
29226:   nsCOMPtr<nsIDocument> doc =
92083:     nsContentUtils::GetDocumentFromScriptContext(sc);
20560:   if (doc) {
77186:     return doc->GetDocumentLoadGroup();
77186:   }
77186: 
77186:   return nsnull;
20560: }
20560: 
20560: nsresult
16665: nsXMLHttpRequest::CreateReadystatechangeEvent(nsIDOMEvent** aDOMEvent)
    1: {
    1:   nsresult rv = nsEventDispatcher::CreateEvent(nsnull, nsnull,
    1:                                                NS_LITERAL_STRING("Events"),
    1:                                                aDOMEvent);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privevent(do_QueryInterface(*aDOMEvent));
    1:   if (!privevent) {
    1:     NS_IF_RELEASE(*aDOMEvent);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
16665:   (*aDOMEvent)->InitEvent(NS_LITERAL_STRING(READYSTATE_STR),
80486:                           false, false);
16665: 
16665:   // We assume anyone who managed to call CreateReadystatechangeEvent is trusted
80486:   privevent->SetTrusted(true);
16665: 
16665:   return NS_OK;
    1: }
    1: 
16665: void
72322: nsXMLHttpRequest::DispatchProgressEvent(nsDOMEventTargetHelper* aTarget,
16665:                                         const nsAString& aType,
79445:                                         bool aUseLSEventWrapper,
79445:                                         bool aLengthComputable,
16665:                                         PRUint64 aLoaded, PRUint64 aTotal,
16665:                                         PRUint64 aPosition, PRUint64 aTotalSize)
16665: {
19953:   NS_ASSERTION(aTarget, "null target");
78799:   NS_ASSERTION(!aType.IsEmpty(), "missing event type");
78799: 
78799:   if (NS_FAILED(CheckInnerWindowCorrectness()) ||
19953:       (!AllowUploadProgress() &&
19953:        (aTarget == mUpload || aType.EqualsLiteral(UPLOADPROGRESS_STR)))) {
16665:     return;
16665:   }
16665: 
79445:   bool dispatchLoadend = aType.EqualsLiteral(LOAD_STR) ||
63715:                            aType.EqualsLiteral(ERROR_STR) ||
88284:                            aType.EqualsLiteral(TIMEOUT_STR) ||
63715:                            aType.EqualsLiteral(ABORT_STR);
63715:   
16665:   nsCOMPtr<nsIDOMEvent> event;
16665:   nsresult rv = nsEventDispatcher::CreateEvent(nsnull, nsnull,
16665:                                                NS_LITERAL_STRING("ProgressEvent"),
16665:                                                getter_AddRefs(event));
16665:   if (NS_FAILED(rv)) {
16665:     return;
16665:   }
16665: 
16665:   nsCOMPtr<nsIPrivateDOMEvent> privevent(do_QueryInterface(event));
16665:   if (!privevent) {
16665:     return;
16665:   }
80486:   privevent->SetTrusted(true);
    1: 
16665:   nsCOMPtr<nsIDOMProgressEvent> progress = do_QueryInterface(event);
16665:   if (!progress) {
16665:     return;
16665:   }
16665: 
80486:   progress->InitProgressEvent(aType, false, false, aLengthComputable,
16665:                               aLoaded, (aTotal == LL_MAXUINT) ? 0 : aTotal);
16665: 
16665:   if (aUseLSEventWrapper) {
16665:     nsCOMPtr<nsIDOMProgressEvent> xhrprogressEvent =
92083:       new nsXMLHttpProgressEvent(progress, aPosition, aTotalSize, GetOwner());
16665:     event = xhrprogressEvent;
16665:   }
16665:   aTarget->DispatchDOMEvent(nsnull, event, nsnull, nsnull);
63715:   
63715:   if (dispatchLoadend) {
63715:     DispatchProgressEvent(aTarget, NS_LITERAL_STRING(LOADEND_STR),
63715:                           aUseLSEventWrapper, aLengthComputable,
63715:                           aLoaded, aTotal, aPosition, aTotalSize);
63715:   }
    1: }
    1:                                           
    1: already_AddRefed<nsIHttpChannel>
    1: nsXMLHttpRequest::GetCurrentHttpChannel()
    1: {
    1:   nsIHttpChannel *httpChannel = nsnull;
    1: 
    1:   if (mReadRequest) {
    1:     CallQueryInterface(mReadRequest, &httpChannel);
    1:   }
    1: 
    1:   if (!httpChannel && mChannel) {
    1:     CallQueryInterface(mChannel, &httpChannel);
    1:   }
    1: 
    1:   return httpChannel;
    1: }
    1: 
75263: bool
75263: nsXMLHttpRequest::IsSystemXHR()
75263: {
75263:   return !!nsContentUtils::IsSystemPrincipal(mPrincipal);
75263: }
75263: 
19951: nsresult
19951: nsXMLHttpRequest::CheckChannelForCrossSiteRequest(nsIChannel* aChannel)
19951: {
63932:   // First check if cross-site requests are enabled...
63932:   if (IsSystemXHR()) {
43831:     return NS_OK;
43831:   }
43831: 
63932:   // ...or if this is a same-origin request.
43831:   if (nsContentUtils::CheckMayLoad(mPrincipal, aChannel)) {
19951:     return NS_OK;
19951:   }
19951: 
87071:   // exempt data URIs from the same origin check.
87071:   nsCOMPtr<nsIURI> channelURI;
87071:   bool dataScheme = false;
87071:   if (NS_SUCCEEDED(NS_GetFinalChannelURI(aChannel,
87071:                                          getter_AddRefs(channelURI))) &&
87071:       NS_SUCCEEDED(channelURI->SchemeIs("data", &dataScheme)) &&
87071:       dataScheme) {
87071:     return NS_OK;
87071:   }
87071: 
19951:   // This is a cross-site request
19951:   mState |= XML_HTTP_REQUEST_USE_XSITE_AC;
19951: 
25455:   // Check if we need to do a preflight request.
25455:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
25455:   NS_ENSURE_TRUE(httpChannel, NS_ERROR_DOM_BAD_URI);
25455: 
25455:   nsCAutoString method;
25455:   httpChannel->GetRequestMethod(method);
64070:   if (!mCORSUnsafeHeaders.IsEmpty() ||
25455:       HasListenersFor(NS_LITERAL_STRING(UPLOADPROGRESS_STR)) ||
54922:       (mUpload && mUpload->HasListeners()) ||
54922:       (!method.LowerCaseEqualsLiteral("get") &&
54922:        !method.LowerCaseEqualsLiteral("post") &&
54922:        !method.LowerCaseEqualsLiteral("head"))) {
25455:     mState |= XML_HTTP_REQUEST_NEED_AC_PREFLIGHT;
25455:   }
25455: 
19951:   return NS_OK;
19951: }
19951: 
    1: NS_IMETHODIMP
64068: nsXMLHttpRequest::Open(const nsACString& method, const nsACString& url,
79445:                        bool async, const nsAString& user,
64068:                        const nsAString& password, PRUint8 optional_argc)
    1: {
64068:   if (!optional_argc) {
64068:     // No optional arguments were passed in. Default async to true.
80486:     async = true;
64068:   }
94307:   return Open(method, url, async, user, password);
94307: }
94307: 
94307: nsresult
94307: nsXMLHttpRequest::Open(const nsACString& method, const nsACString& url,
94307:                        bool async, const nsAString& user,
94307:                        const nsAString& password)
94307: {
94307:   NS_ENSURE_ARG(!method.IsEmpty());
94307: 
82487:   Telemetry::Accumulate(Telemetry::XMLHTTPREQUEST_ASYNC_OR_SYNC,
82487:                         async ? 0 : 1);
64068: 
11887:   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
11887: 
 2795:   // Disallow HTTP/1.1 TRACE method (see bug 302489)
 2795:   // and MS IIS equivalent TRACK (see bug 381264)
 4064:   if (method.LowerCaseEqualsLiteral("trace") ||
 4064:       method.LowerCaseEqualsLiteral("track")) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
84264:   // sync request is not allowed using withCredential or responseType
84264:   // in window context
92083:   if (!async && HasOrHasHadOwner() &&
84264:       (mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS ||
88284:        mTimeoutMilliseconds ||
84264:        mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT)) {
84264:     if (mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS) {
92083:       LogMessage("WithCredentialsSyncXHRWarning", GetOwner());
84264:     }
88284:     if (mTimeoutMilliseconds) {
92083:       LogMessage("TimeoutSyncXHRWarning", GetOwner());
88284:     }
84264:     if (mResponseType != XML_HTTP_RESPONSE_TYPE_DEFAULT) {
92083:       LogMessage("ResponseTypeSyncXHRWarning", GetOwner());
84264:     }
84264:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
84264:   }
84264: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIURI> uri;
    1: 
 8067:   if (mState & (XML_HTTP_REQUEST_OPENED |
69662:                 XML_HTTP_REQUEST_HEADERS_RECEIVED |
69662:                 XML_HTTP_REQUEST_LOADING |
    1:                 XML_HTTP_REQUEST_SENT |
    1:                 XML_HTTP_REQUEST_STOPPED)) {
    1:     // IE aborts as well
    1:     Abort();
    1: 
    1:     // XXX We should probably send a warning to the JS console
    1:     //     that load was aborted and event listeners were cleared
    1:     //     since this looks like a situation that could happen
    1:     //     by accident and you could spend a lot of time wondering
    1:     //     why things didn't work.
 8067:   }
 8067: 
88284:   // Unset any pre-existing aborted and timed-out states.
88284:   mState &= ~XML_HTTP_REQUEST_ABORTED & ~XML_HTTP_REQUEST_TIMED_OUT;
    1: 
    1:   if (async) {
    1:     mState |= XML_HTTP_REQUEST_ASYNC;
    1:   } else {
    1:     mState &= ~XML_HTTP_REQUEST_ASYNC;
    1:   }
    1: 
19152:   mState &= ~XML_HTTP_REQUEST_MPART_HEADERS;
19152: 
92083:   nsIScriptContext* sc = GetContextForEventHandlers(&rv);
92083:   NS_ENSURE_SUCCESS(rv, rv);
29226:   nsCOMPtr<nsIDocument> doc =
92083:     nsContentUtils::GetDocumentFromScriptContext(sc);
20331:   
20331:   nsCOMPtr<nsIURI> baseURI;
23201:   if (mBaseURI) {
23201:     baseURI = mBaseURI;
23201:   }
23201:   else if (doc) {
20331:     baseURI = doc->GetBaseURI();
20331:   }
20331: 
20331:   rv = NS_NewURI(getter_AddRefs(uri), url, nsnull, baseURI);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
 8947:   rv = CheckInnerWindowCorrectness();
 8947:   NS_ENSURE_SUCCESS(rv, rv);
   68:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
 2501:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_XMLHTTPREQUEST,
   68:                                  uri,
 8947:                                  mPrincipal,
   68:                                  doc,
   68:                                  EmptyCString(), //mime guess
   68:                                  nsnull,         //extra
 4367:                                  &shouldLoad,
 4367:                                  nsContentUtils::GetContentPolicy(),
 4367:                                  nsContentUtils::GetSecurityManager());
   68:   if (NS_FAILED(rv)) return rv;
   68:   if (NS_CP_REJECTED(shouldLoad)) {
   68:     // Disallowed by content policy
   68:     return NS_ERROR_CONTENT_BLOCKED;
   68:   }
   68: 
    1:   if (!user.IsEmpty()) {
    1:     nsCAutoString userpass;
    1:     CopyUTF16toUTF8(user, userpass);
    1:     if (!password.IsEmpty()) {
    1:       userpass.Append(':');
    1:       AppendUTF16toUTF8(password, userpass);
    1:     }
    1:     uri->SetUserPass(userpass);
    1:   }
    1: 
20560:   // When we are called from JS we can find the load group for the page,
20560:   // and add ourselves to it. This way any pending requests
20560:   // will be automatically aborted if the user leaves the page.
77186:   nsCOMPtr<nsILoadGroup> loadGroup = GetLoadGroup();
    1: 
41212:   // get Content Security Policy from principal to pass into channel
41212:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
41212:   nsCOMPtr<nsIContentSecurityPolicy> csp;
41350:   rv = mPrincipal->GetCsp(getter_AddRefs(csp));
41350:   NS_ENSURE_SUCCESS(rv, rv);
41212:   if (csp) {
41212:     channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
41212:     channelPolicy->SetContentSecurityPolicy(csp);
41212:     channelPolicy->SetLoadType(nsIContentPolicy::TYPE_XMLHTTPREQUEST);
41212:   }
41212:   rv = NS_NewChannel(getter_AddRefs(mChannel),
41212:                      uri,
41212:                      nsnull,                    // ioService
41212:                      loadGroup,
41212:                      nsnull,                    // callbacks
52200:                      nsIRequest::LOAD_BACKGROUND,
41212:                      channelPolicy);
20560:   if (NS_FAILED(rv)) return rv;
    1: 
25455:   mState &= ~(XML_HTTP_REQUEST_USE_XSITE_AC |
25455:               XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
25455: 
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
    1:   if (httpChannel) {
    1:     rv = httpChannel->SetRequestMethod(method);
 4064:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   ChangeState(XML_HTTP_REQUEST_OPENED);
    1: 
    1:   return rv;
    1: }
    1: 
    1: /*
    1:  * "Copy" from a stream.
    1:  */
    1: NS_METHOD
    1: nsXMLHttpRequest::StreamReaderFunc(nsIInputStream* in,
    1:                                    void* closure,
    1:                                    const char* fromRawSegment,
    1:                                    PRUint32 toOffset,
    1:                                    PRUint32 count,
    1:                                    PRUint32 *writeCount)
    1: {
 3233:   nsXMLHttpRequest* xmlHttpRequest = static_cast<nsXMLHttpRequest*>(closure);
    1:   if (!xmlHttpRequest || !writeCount) {
    1:     NS_WARNING("XMLHttpRequest cannot read from stream: no closure or writeCount");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
88536:   nsresult rv = NS_OK;
88536: 
88536:   if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
88536:       xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
88536:     if (!xmlHttpRequest->mDOMFile) {
88536:       if (!xmlHttpRequest->mBuilder) {
88536:         xmlHttpRequest->mBuilder = new nsDOMBlobBuilder();
88536:       }
88536:       rv = xmlHttpRequest->mBuilder->AppendVoidPtr(fromRawSegment, count);
88536:     }
88536:     // Clear the cache so that the blob size is updated.
88536:     if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
88536:       xmlHttpRequest->mResponseBlob = nsnull;
88536:     }
88536:     if (NS_SUCCEEDED(rv)) {
69662:       *writeCount = count;
88536:     }
88536:     return rv;
69662:   }
69662: 
78800:   if ((xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT &&
78800:        xmlHttpRequest->mResponseXML) ||
78800:       xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_ARRAYBUFFER ||
78801:       xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER) {
    1:     // Copy for our own use
69662:     PRUint32 previousLength = xmlHttpRequest->mResponseBody.Length();
    1:     xmlHttpRequest->mResponseBody.Append(fromRawSegment,count);
69662:     if (count > 0 && xmlHttpRequest->mResponseBody.Length() == previousLength) {
69662:       return NS_ERROR_OUT_OF_MEMORY;
69662:     }
78801:   } else if (xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT ||
78800:              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_TEXT ||
78801:              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_JSON ||
78801:              xmlHttpRequest->mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT) {
78800:     NS_ASSERTION(!xmlHttpRequest->mResponseXML,
78800:                  "We shouldn't be parsing a doc here");
78800:     xmlHttpRequest->AppendToResponseText(fromRawSegment, count);
69662:   }
    1: 
    1:   if (xmlHttpRequest->mState & XML_HTTP_REQUEST_PARSEBODY) {
    1:     // Give the same data to the parser.
    1: 
    1:     // We need to wrap the data in a new lightweight stream and pass that
    1:     // to the parser, because calling ReadSegments() recursively on the same
    1:     // stream is not supported.
    1:     nsCOMPtr<nsIInputStream> copyStream;
    1:     rv = NS_NewByteInputStream(getter_AddRefs(copyStream), fromRawSegment, count);
    1: 
29232:     if (NS_SUCCEEDED(rv) && xmlHttpRequest->mXMLParserStreamListener) {
    1:       NS_ASSERTION(copyStream, "NS_NewByteInputStream lied");
    1:       nsresult parsingResult = xmlHttpRequest->mXMLParserStreamListener
    1:                                   ->OnDataAvailable(xmlHttpRequest->mReadRequest,
    1:                                                     xmlHttpRequest->mContext,
    1:                                                     copyStream, toOffset, count);
    1: 
    1:       // No use to continue parsing if we failed here, but we
    1:       // should still finish reading the stream
    1:       if (NS_FAILED(parsingResult)) {
    1:         xmlHttpRequest->mState &= ~XML_HTTP_REQUEST_PARSEBODY;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     *writeCount = count;
    1:   } else {
    1:     *writeCount = 0;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
88536: bool nsXMLHttpRequest::CreateDOMFile(nsIRequest *request)
69662: {
69662:   nsCOMPtr<nsIFile> file;
69662:   nsCOMPtr<nsICachingChannel> cc(do_QueryInterface(request));
69662:   if (cc) {
69662:     cc->GetCacheFile(getter_AddRefs(file));
69662:   } else {
69662:     nsCOMPtr<nsIFileChannel> fc = do_QueryInterface(request);
69662:     if (fc) {
69662:       fc->GetFile(getter_AddRefs(file));
69662:     }
69662:   }
80889:   bool fromFile = false;
69662:   if (file) {
69662:     nsCAutoString contentType;
69662:     mChannel->GetContentType(contentType);
72855:     nsCOMPtr<nsISupports> cacheToken;
72855:     if (cc) {
72855:       cc->GetCacheToken(getter_AddRefs(cacheToken));
80889:       // We need to call IsFromCache to determine whether the response is
80889:       // fully cached (i.e. whether we can skip reading the response).
80889:       cc->IsFromCache(&fromFile);
80889:     } else {
80889:       // If the response is coming from the local resource, we can skip
80889:       // reading the response unconditionally.
80889:       fromFile = true;
72855:     }
72856: 
88536:     mDOMFile =
73691:       new nsDOMFileFile(file, NS_ConvertASCIItoUTF16(contentType), cacheToken);
88536:     mBuilder = nsnull;
88536:     NS_ASSERTION(mResponseBody.IsEmpty(), "mResponseBody should be empty");
69662:   }
80889:   return fromFile;
69662: }
69662: 
    1: NS_IMETHODIMP
78799: nsXMLHttpRequest::OnDataAvailable(nsIRequest *request,
78799:                                   nsISupports *ctxt,
78799:                                   nsIInputStream *inStr,
78799:                                   PRUint32 sourceOffset,
78799:                                   PRUint32 count)
    1: {
    1:   NS_ENSURE_ARG_POINTER(inStr);
    1: 
    1:   NS_ABORT_IF_FALSE(mContext.get() == ctxt,"start context different from OnDataAvailable context");
    1: 
80889:   mProgressSinceLastProgressEvent = true;
80889: 
81017:   bool cancelable = false;
88536:   if ((mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
88536:        mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) && !mDOMFile) {
88536:     cancelable = CreateDOMFile(request);
81017:     // The nsIStreamListener contract mandates us
81017:     // to read from the stream before returning.
81017:   }
81017: 
81017:   PRUint32 totalRead;
81017:   nsresult rv = inStr->ReadSegments(nsXMLHttpRequest::StreamReaderFunc,
81017:                                     (void*)this, count, &totalRead);
81017:   NS_ENSURE_SUCCESS(rv, rv);
81017: 
81017:   if (cancelable) {
80889:     // We don't have to read from the local file for the blob response
88536:     mDOMFile->GetSize(&mLoadTransferred);
80889:     ChangeState(XML_HTTP_REQUEST_LOADING);
80889:     return request->Cancel(NS_OK);
80889:   }
78799: 
78799:   mLoadTransferred += totalRead;
78799: 
78799:   ChangeState(XML_HTTP_REQUEST_LOADING);
78799:   
80486:   MaybeDispatchProgressEvents(false);
78799: 
78799:   return NS_OK;
    1: }
    1: 
79445: bool
 5746: IsSameOrBaseChannel(nsIRequest* aPossibleBase, nsIChannel* aChannel)
 5746: {
 5746:   nsCOMPtr<nsIMultiPartChannel> mpChannel = do_QueryInterface(aPossibleBase);
 5746:   if (mpChannel) {
 5746:     nsCOMPtr<nsIChannel> baseChannel;
 5746:     nsresult rv = mpChannel->GetBaseChannel(getter_AddRefs(baseChannel));
80486:     NS_ENSURE_SUCCESS(rv, false);
 5746:     
 5746:     return baseChannel == aChannel;
 5746:   }
 5746: 
 5746:   return aPossibleBase == aChannel;
 5746: }
 5746: 
    1: /* void onStartRequest (in nsIRequest request, in nsISupports ctxt); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
    1: {
88104:   SAMPLE_LABEL("nsXMLHttpRequest", "OnStartRequest");
20640:   nsresult rv = NS_OK;
19944:   if (!mFirstStartRequestSeen && mRequestObserver) {
80486:     mFirstStartRequestSeen = true;
19944:     mRequestObserver->OnStartRequest(request, ctxt);
19944:   }
19944: 
 5746:   if (!IsSameOrBaseChannel(request, mChannel)) {
 5746:     return NS_OK;
 5746:   }
 5746: 
    1:   // Don't do anything if we have been aborted
69662:   if (mState & XML_HTTP_REQUEST_UNSENT)
    1:     return NS_OK;
    1: 
88284:   /* Apparently, Abort() should set XML_HTTP_REQUEST_UNSENT.  See bug 361773.
88284:      XHR2 spec says this is correct. */
    1:   if (mState & XML_HTTP_REQUEST_ABORTED) {
    1:     NS_ERROR("Ugh, still getting data on an aborted XMLHttpRequest!");
    1: 
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
88284:   // Don't do anything if we have timed out.
88284:   if (mState & XML_HTTP_REQUEST_TIMED_OUT) {
88284:     return NS_OK;
88284:   }
88284: 
    1:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
    1:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
    1: 
63932:   nsCOMPtr<nsIPrincipal> documentPrincipal;
63932:   if (IsSystemXHR()) {
13653:     // Don't give this document the system principal.  We need to keep track of
13653:     // mPrincipal being system because we use it for various security checks
13653:     // that should be passing, but the document data shouldn't get a system
13653:     // principal.
13653:     nsresult rv;
13653:     documentPrincipal = do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
13653:     NS_ENSURE_SUCCESS(rv, rv);
63932:   } else {
63932:     documentPrincipal = mPrincipal;
13653:   }
13653: 
13653:   channel->SetOwner(documentPrincipal);
 3028: 
78799:   nsresult status;
78799:   request->GetStatus(&status);
78799:   mErrorLoad = mErrorLoad || NS_FAILED(status);
78799: 
78799:   if (mUpload && !mUploadComplete && !mErrorLoad &&
78799:       (mState & XML_HTTP_REQUEST_ASYNC)) {
88284:     if (mProgressTimerIsActive) {
88284:       mProgressTimerIsActive = false;
78799:       mProgressNotifier->Cancel();
78799:     }
80486:     MaybeDispatchProgressEvents(true);
80486:     mUploadComplete = true;
78799:     DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOAD_STR),
80486:                           true, mUploadTotal, mUploadTotal);
78799:   }
78799: 
    1:   mReadRequest = request;
    1:   mContext = ctxt;
    1:   mState |= XML_HTTP_REQUEST_PARSEBODY;
19152:   mState &= ~XML_HTTP_REQUEST_MPART_HEADERS;
69662:   ChangeState(XML_HTTP_REQUEST_HEADERS_RECEIVED);
69662: 
88536:   if (mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
88536:       mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB) {
69662:     nsCOMPtr<nsICachingChannel> cc(do_QueryInterface(mChannel));
69662:     if (cc) {
80486:       cc->SetCacheAsFile(true);
69662:     }
69662:   }
    1: 
78799:   ResetResponse();
20331: 
78800:   if (!mOverrideMimeType.IsEmpty()) {
94307:     channel->SetContentType(NS_ConvertUTF16toUTF8(mOverrideMimeType));
78800:   }
78800: 
78800:   DetectCharset();
78800: 
20331:   // Set up responseXML
79445:   bool parseBody = mResponseType == XML_HTTP_RESPONSE_TYPE_DEFAULT ||
69662:                      mResponseType == XML_HTTP_RESPONSE_TYPE_DOCUMENT;
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
69662:   if (parseBody && httpChannel) {
    1:     nsCAutoString method;
    1:     httpChannel->GetRequestMethod(method);
    1:     parseBody = !method.EqualsLiteral("HEAD");
    1:   }
    1: 
82543:   mIsHtml = false;
82543:   mWarnAboutMultipartHtml = false;
82543:   mWarnAboutSyncHtml = false;
    1:   if (parseBody && NS_SUCCEEDED(status)) {
    1:     // We can gain a huge performance win by not even trying to
    1:     // parse non-XML data. This also protects us from the situation
    1:     // where we have an XML document and sink, but HTML (or other)
    1:     // parser, which can produce unreliable results.
    1:     nsCAutoString type;
    1:     channel->GetContentType(type);
    1: 
82735:     if ((mResponseType == XML_HTTP_RESPONSE_TYPE_DOCUMENT) &&
82735:         type.EqualsLiteral("text/html")) {
82735:       // HTML parsing is only supported for responseType == "document" to
82735:       // avoid running the parser and, worse, populating responseXML for
82735:       // legacy users of XHR who use responseType == "" for retrieving the
82735:       // responseText of text/html resources. This legacy case is so common
82735:       // that it's not useful to emit a warning about it.
82543:       if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
82543:         // We don't make cool new features available in the bad synchronous
82543:         // mode. The synchronous mode is for legacy only.
82543:         mWarnAboutSyncHtml = true;
82543:         mState &= ~XML_HTTP_REQUEST_PARSEBODY;
82543:       } else if (mState & XML_HTTP_REQUEST_MULTIPART) {
82543:         // HTML parsing is supported only for non-multipart responses. The
82543:         // multipart implementation assumes that it's OK to start the next part
82543:         // immediately after the last part. That doesn't work with the HTML
82543:         // parser, because when OnStopRequest for one part has fired, the
82543:         // parser thread still hasn't posted back the runnables that make the
82543:         // parsing appear finished.
82543:         //
82543:         // On the other hand, multipart support seems to be a legacy feature,
82543:         // so it isn't clear that use cases justify adding support for deferring
82543:         // the multipart stream events between parts to accommodate the
82543:         // asynchronous nature of the HTML parser.
82543:         mWarnAboutMultipartHtml = true;
82543:         mState &= ~XML_HTTP_REQUEST_PARSEBODY;
82543:       } else {
82543:         mIsHtml = true;
82543:       }
82543:     } else if (type.Find("xml") == kNotFound) {
    1:       mState &= ~XML_HTTP_REQUEST_PARSEBODY;
    1:     }
    1:   } else {
    1:     // The request failed, so we shouldn't be parsing anyway
    1:     mState &= ~XML_HTTP_REQUEST_PARSEBODY;
    1:   }
    1: 
    1:   if (mState & XML_HTTP_REQUEST_PARSEBODY) {
20331:     nsCOMPtr<nsIURI> baseURI, docURI;
92083:     nsIScriptContext* sc = GetContextForEventHandlers(&rv);
92083:     NS_ENSURE_SUCCESS(rv, rv);
29226:     nsCOMPtr<nsIDocument> doc =
92083:       nsContentUtils::GetDocumentFromScriptContext(sc);
20331: 
20331:     if (doc) {
20331:       docURI = doc->GetDocumentURI();
20331:       baseURI = doc->GetBaseURI();
20331:     }
20331: 
20331:     // Create an empty document from it.  Here we have to cheat a little bit...
20331:     // Setting the base URI to |baseURI| won't work if the document has a null
20331:     // principal, so use mPrincipal when creating the document, then reset the
20331:     // principal.
20331:     const nsAString& emptyStr = EmptyString();
92083:     nsCOMPtr<nsIScriptGlobalObject> global = do_QueryInterface(GetOwner());
94307:     nsCOMPtr<nsIDOMDocument> responseDoc;
20331:     rv = nsContentUtils::CreateDocument(emptyStr, emptyStr, nsnull, docURI,
82543:                                         baseURI, mPrincipal, global,
82543:                                         mIsHtml ? DocumentFlavorHTML :
82543:                                                   DocumentFlavorLegacyGuess,
94307:                                         getter_AddRefs(responseDoc));
20331:     NS_ENSURE_SUCCESS(rv, rv);
94307:     mResponseXML = do_QueryInterface(responseDoc);
94307:     mResponseXML->SetPrincipal(documentPrincipal);
20331: 
63932:     if (IsSystemXHR()) {
94307:       mResponseXML->ForceEnableXULXBL();
51490:     }
51490: 
20331:     if (mState & XML_HTTP_REQUEST_USE_XSITE_AC) {
20331:       nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mResponseXML);
20331:       if (htmlDoc) {
20331:         htmlDoc->DisableCookieAccess();
20331:       }
20331:     }
20331: 
    1:     nsCOMPtr<nsIStreamListener> listener;
    1:     nsCOMPtr<nsILoadGroup> loadGroup;
    1:     channel->GetLoadGroup(getter_AddRefs(loadGroup));
    1: 
94307:     rv = mResponseXML->StartDocumentLoad(kLoadAsData, channel, loadGroup,
20331:                                          nsnull, getter_AddRefs(listener),
20331:                                          !(mState & XML_HTTP_REQUEST_USE_XSITE_AC));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     mXMLParserStreamListener = listener;
20331:     rv = mXMLParserStreamListener->OnStartRequest(request, ctxt);
20331:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
20640:   // We won't get any progress events anyway if we didn't have progress
20640:   // events when starting the request - so maybe no need to start timer here.
20640:   if (NS_SUCCEEDED(rv) &&
20640:       (mState & XML_HTTP_REQUEST_ASYNC) &&
20640:       HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR))) {
20640:     StartProgressEventTimer();
20640:   }
20640: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onStopRequest (in nsIRequest request, in nsISupports ctxt, in nsresult status, in wstring statusArg); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
    1: {
87692:   SAMPLE_LABEL("content", "nsXMLHttpRequest::OnStopRequest");
 5746:   if (!IsSameOrBaseChannel(request, mChannel)) {
 5746:     return NS_OK;
 5746:   }
 5746: 
90244:   mWaitingForOnStopRequest = false;
90244: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // If we're loading a multipart stream of XML documents, we'll get
    1:   // an OnStopRequest() for the last part in the stream, and then
    1:   // another one for the end of the initiating
    1:   // "multipart/x-mixed-replace" stream too. So we must check that we
    1:   // still have an xml parser stream listener before accessing it
    1:   // here.
 4106:   nsCOMPtr<nsIMultiPartChannel> mpChannel = do_QueryInterface(request);
 4106:   if (mpChannel) {
79445:     bool last;
 4106:     rv = mpChannel->GetIsLastPart(&last);
 4106:     NS_ENSURE_SUCCESS(rv, rv);
 4106:     if (last) {
 4106:       mState |= XML_HTTP_REQUEST_GOT_FINAL_STOP;
 4106:     }
 4106:   }
 4106:   else {
 4106:     mState |= XML_HTTP_REQUEST_GOT_FINAL_STOP;
 4106:   }
 4106: 
22035:   if (mRequestObserver && mState & XML_HTTP_REQUEST_GOT_FINAL_STOP) {
22035:     NS_ASSERTION(mFirstStartRequestSeen, "Inconsistent state!");
80486:     mFirstStartRequestSeen = false;
22035:     mRequestObserver->OnStopRequest(request, ctxt, status);
22035:   }
22035: 
41710:   // make sure to notify the listener if we were aborted
41710:   // XXX in fact, why don't we do the cleanup below in this case??
88284:   // XML_HTTP_REQUEST_UNSENT is for abort calls.  See OnStartRequest above.
88284:   if ((mState & XML_HTTP_REQUEST_UNSENT) ||
88284:       (mState & XML_HTTP_REQUEST_TIMED_OUT)) {
41710:     if (mXMLParserStreamListener)
41710:       (void) mXMLParserStreamListener->OnStopRequest(request, ctxt, status);
22035:     return NS_OK;
41710:   }
22035: 
22035:   // Is this good enough here?
22035:   if (mState & XML_HTTP_REQUEST_PARSEBODY && mXMLParserStreamListener) {
71743:     mXMLParserStreamListener->OnStopRequest(request, ctxt, status);
22035:   }
22035: 
    1:   mXMLParserStreamListener = nsnull;
    1:   mReadRequest = nsnull;
    1:   mContext = nsnull;
    1: 
78799:   // If we're received data since the last progress event, make sure to fire
82543:   // an event for it, except in the HTML case, defer the last progress event
82543:   // until the parser is done.
82543:   if (!mIsHtml) {
80486:     MaybeDispatchProgressEvents(true);
82543:   }
78799: 
88536:   if (NS_SUCCEEDED(status) &&
88536:       (mResponseType == XML_HTTP_RESPONSE_TYPE_BLOB ||
88536:        mResponseType == XML_HTTP_RESPONSE_TYPE_MOZ_BLOB)) {
88536:     if (!mDOMFile) {
88536:       CreateDOMFile(request);
88536:     }
88536:     if (mDOMFile) {
88536:       mResponseBlob = mDOMFile;
88536:       mDOMFile = nsnull;
88536:     } else {
69662:       // Smaller files may be written in cache map instead of separate files.
69662:       // Also, no-store response cannot be written in persistent cache.
69662:       nsCAutoString contentType;
69662:       mChannel->GetContentType(contentType);
88536:       mBuilder->GetBlobInternal(NS_ConvertASCIItoUTF16(contentType),
88536:                                 false, getter_AddRefs(mResponseBlob));
88536:       mBuilder = nsnull;
88536:     }
88536:     NS_ASSERTION(mResponseBody.IsEmpty(), "mResponseBody should be empty");
78800:     NS_ASSERTION(mResponseText.IsEmpty(), "mResponseText should be empty");
69662:   }
88536: 
88536:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(request));
88536:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
69662: 
    1:   channel->SetNotificationCallbacks(nsnull);
    1:   mNotificationCallbacks = nsnull;
    1:   mChannelEventSink = nsnull;
    1:   mProgressEventSink = nsnull;
    1: 
82345:   mState &= ~XML_HTTP_REQUEST_SYNCLOOPING;
82345: 
    1:   if (NS_FAILED(status)) {
    1:     // This can happen if the server is unreachable. Other possible
    1:     // reasons are that the user leaves the page or hits the ESC key.
71743: 
80486:     mErrorLoad = true;
71743:     mResponseXML = nsnull;
71743:   }
71743: 
    1:   // If we're uninitialized at this point, we encountered an error
    1:   // earlier and listeners have already been notified. Also we do
    1:   // not want to do this if we already completed.
69662:   if (mState & (XML_HTTP_REQUEST_UNSENT |
69662:                 XML_HTTP_REQUEST_DONE)) {
    1:     return NS_OK;
    1:   }
    1: 
82543:   if (!mResponseXML) {
82543:     ChangeStateToDone();
82543:     return NS_OK;
82543:   }
82543:   if (mIsHtml) {
82543:     NS_ASSERTION(!(mState & XML_HTTP_REQUEST_SYNCLOOPING),
82543:       "We weren't supposed to support HTML parsing with XHR!");
82543:     nsCOMPtr<nsIDOMEventTarget> eventTarget = do_QueryInterface(mResponseXML);
82543:     nsEventListenerManager* manager = eventTarget->GetListenerManager(true);
82543:     manager->AddEventListenerByType(new nsXHRParseEndListener(this),
82543:                                     NS_LITERAL_STRING("DOMContentLoaded"),
82543:                                     NS_EVENT_FLAG_BUBBLE |
82543:                                     NS_EVENT_FLAG_SYSTEM_EVENT);
82543:     return NS_OK;
82543:   }
    1:   // We might have been sent non-XML data. If that was the case,
    1:   // we should null out the document member. The idea in this
    1:   // check here is that if there is no document element it is not
    1:   // an XML document. We might need a fancier check...
94307:   if (!mResponseXML->GetRootElement()) {
20331:     mResponseXML = nsnull;
    1:   }
82543:   ChangeStateToDone();
82543:   return NS_OK;
82543: }
82543: 
82543: void
82543: nsXMLHttpRequest::ChangeStateToDone()
82543: {
82543:   if (mIsHtml) {
82543:     // In the HTML case, this has to be deferred, because the parser doesn't
82543:     // do it's job synchronously.
82543:     MaybeDispatchProgressEvents(true);
82543:   }
88284: 
80486:   ChangeState(XML_HTTP_REQUEST_DONE, true);
88284:   if (mTimeoutTimer) {
88284:     mTimeoutTimer->Cancel();
88284:   }
    1: 
16665:   NS_NAMED_LITERAL_STRING(errorStr, ERROR_STR);
16665:   NS_NAMED_LITERAL_STRING(loadStr, LOAD_STR);
16665:   DispatchProgressEvent(this,
16665:                         mErrorLoad ? errorStr : loadStr,
16665:                         !mErrorLoad,
78799:                         mLoadTransferred,
78799:                         mErrorLoad ? 0 : mLoadTransferred);
16665:   if (mErrorLoad && mUpload && !mUploadComplete) {
80486:     DispatchProgressEvent(mUpload, errorStr, true,
16665:                           mUploadTransferred, mUploadTotal);
    1:   }
    1: 
71743:   if (mErrorLoad) {
71743:     // By nulling out channel here we make it so that Send() can test
71743:     // for that and throw. Also calling the various status
71743:     // methods/members will not throw.
71743:     // This matches what IE does.
71743:     mChannel = nsnull;
95581:     mCORSPreflightChannel = nsnull;
71743:   }
71743:   else if (!(mState & XML_HTTP_REQUEST_GOT_FINAL_STOP)) {
    1:     // We're a multipart request, so we're not done. Reset to opened.
    1:     ChangeState(XML_HTTP_REQUEST_OPENED);
    1:   }
    1: }
    1: 
 3941: NS_IMETHODIMP
95834: nsXMLHttpRequest::SendAsBinary(const nsAString &aBody, JSContext *aCx)
 3941: {
94307:   nsresult rv = NS_OK;
95834:   SendAsBinary(aCx, aBody, rv);
94307:   return rv;
94307: }
94307: 
94307: void
95834: nsXMLHttpRequest::SendAsBinary(JSContext *aCx, const nsAString &aBody, nsresult& aRv)
94307: {
 3941:   char *data = static_cast<char*>(NS_Alloc(aBody.Length() + 1));
94307:   if (!data) {
94307:     aRv = NS_ERROR_OUT_OF_MEMORY;
94307:     return;
94307:   }
 3941: 
 3941:   nsAString::const_iterator iter, end;
 3941:   aBody.BeginReading(iter);
 3941:   aBody.EndReading(end);
 3941:   char *p = data;
 3941:   while (iter != end) {
 3941:     if (*iter & 0xFF00) {
 3941:       NS_Free(data);
94307:       aRv = NS_ERROR_DOM_INVALID_CHARACTER_ERR;
94307:       return;
 3941:     }
 3941:     *p++ = static_cast<char>(*iter++);
 3941:   }
 3941:   *p = '\0';
 3941: 
 3941:   nsCOMPtr<nsIInputStream> stream;
94307:   aRv = NS_NewByteInputStream(getter_AddRefs(stream), data, aBody.Length(),
94307:                               NS_ASSIGNMENT_ADOPT);
94307:   if (NS_FAILED(aRv)){
 3941:     NS_Free(data);
94307:     return;
94307:   }
94307: 
94307:   nsCOMPtr<nsIWritableVariant> variant = new nsVariant();
94307: 
94307:   aRv = variant->SetAsISupports(stream);
94307:   if (NS_FAILED(aRv)) {
94307:     return;
94307:   }
94307: 
95834:   aRv = Send(variant, aCx);
94307: }
94307: 
94307: static nsresult
94307: GetRequestBody(nsIDOMDocument* aDoc, nsIInputStream** aResult,
94307:                nsACString& aContentType, nsACString& aCharset)
94307: {
94307:   aContentType.AssignLiteral("application/xml");
94307:   nsAutoString inputEncoding;
94307:   aDoc->GetInputEncoding(inputEncoding);
94307:   if (!DOMStringIsNull(inputEncoding)) {
94307:     CopyUTF16toUTF8(inputEncoding, aCharset);
94307:   }
94307:   else {
94307:     aCharset.AssignLiteral("UTF-8");
94307:   }
94307: 
94307:   // Serialize to a stream so that the encoding used will
94307:   // match the document's.
94307:   nsresult rv;
94307:   nsCOMPtr<nsIDOMSerializer> serializer =
94307:     do_CreateInstance(NS_XMLSERIALIZER_CONTRACTID, &rv);
 3941:   NS_ENSURE_SUCCESS(rv, rv);
 3941: 
94307:   nsCOMPtr<nsIStorageStream> storStream;
94307:   rv = NS_NewStorageStream(4096, PR_UINT32_MAX, getter_AddRefs(storStream));
 3941:   NS_ENSURE_SUCCESS(rv, rv);
 3941: 
94307:   nsCOMPtr<nsIOutputStream> output;
94307:   rv = storStream->GetOutputStream(0, getter_AddRefs(output));
94307:   NS_ENSURE_SUCCESS(rv, rv);
94307: 
94307:   // Make sure to use the encoding we'll send
94307:   rv = serializer->SerializeToStream(aDoc, output, aCharset);
94307:   NS_ENSURE_SUCCESS(rv, rv);
94307: 
94307:   output->Close();
94307: 
94307:   return storStream->NewInputStream(0, aResult);
94307: }
94307: 
94307: static nsresult
94307: GetRequestBody(const nsAString& aString, nsIInputStream** aResult,
94307:                nsACString& aContentType, nsACString& aCharset)
94307: {
94307:   aContentType.AssignLiteral("text/plain");
94307:   aCharset.AssignLiteral("UTF-8");
94307: 
94307:   return NS_NewCStringInputStream(aResult, NS_ConvertUTF16toUTF8(aString));
94307: }
94307: 
94307: static nsresult
94307: GetRequestBody(nsIInputStream* aStream, nsIInputStream** aResult,
94307:                nsACString& aContentType, nsACString& aCharset)
94307: {
94307:   aContentType.AssignLiteral("text/plain");
94307:   aCharset.Truncate();
94307: 
94307:   NS_ADDREF(*aResult = aStream);
94307: 
94307:   return NS_OK;
94307: }
94307: 
94307: static nsresult
94307: GetRequestBody(nsIXHRSendable* aSendable, nsIInputStream** aResult,
94307:                nsACString& aContentType, nsACString& aCharset)
94307: {
94307:   return aSendable->GetSendInfo(aResult, aContentType, aCharset);
94307: }
94307: 
94307: static nsresult
95834: GetRequestBody(JSObject* aArrayBuffer, JSContext *aCx, nsIInputStream** aResult,
94307:                nsACString& aContentType, nsACString& aCharset)
94307: {
95834:   NS_ASSERTION(JS_IsArrayBufferObject(aArrayBuffer, aCx), "Not an ArrayBuffer!");
94307:   aContentType.SetIsVoid(true);
94307:   aCharset.Truncate();
94307: 
95834:   PRInt32 length = JS_GetArrayBufferByteLength(aArrayBuffer, aCx);
95834:   char* data = reinterpret_cast<char*>(JS_GetArrayBufferData(aArrayBuffer, aCx));
94307: 
94307:   nsCOMPtr<nsIInputStream> stream;
94307:   nsresult rv = NS_NewByteInputStream(getter_AddRefs(stream), data, length,
94307:                                       NS_ASSIGNMENT_COPY);
94307:   NS_ENSURE_SUCCESS(rv, rv);
94307: 
94307:   stream.forget(aResult);
94307: 
94307:   return NS_OK;
 3941: }
 3941: 
38677: static nsresult
95834: GetRequestBody(nsIVariant* aBody, JSContext *aCx, nsIInputStream** aResult,
38677:                nsACString& aContentType, nsACString& aCharset)
38677: {
38677:   *aResult = nsnull;
38677: 
38677:   PRUint16 dataType;
38677:   nsresult rv = aBody->GetDataType(&dataType);
38677:   NS_ENSURE_SUCCESS(rv, rv);
38677: 
38677:   if (dataType == nsIDataType::VTYPE_INTERFACE ||
38677:       dataType == nsIDataType::VTYPE_INTERFACE_IS) {
38677:     nsCOMPtr<nsISupports> supports;
38677:     nsID *iid;
38677:     rv = aBody->GetAsInterface(&iid, getter_AddRefs(supports));
38677:     NS_ENSURE_SUCCESS(rv, rv);
38677: 
38677:     nsMemory::Free(iid);
38677: 
38677:     // document?
38677:     nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(supports);
38677:     if (doc) {
94307:       return GetRequestBody(doc, aResult, aContentType, aCharset);
38677:     }
38677: 
38677:     // nsISupportsString?
38677:     nsCOMPtr<nsISupportsString> wstr = do_QueryInterface(supports);
38677:     if (wstr) {
38677:       nsAutoString string;
38677:       wstr->GetData(string);
38677: 
94307:       return GetRequestBody(string, aResult, aContentType, aCharset);
38677:     }
38677: 
38677:     // nsIInputStream?
38677:     nsCOMPtr<nsIInputStream> stream = do_QueryInterface(supports);
38677:     if (stream) {
94307:       return GetRequestBody(stream, aResult, aContentType, aCharset);
38677:     }
38677: 
38679:     // nsIXHRSendable?
38679:     nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(supports);
38679:     if (sendable) {
94307:       return GetRequestBody(sendable, aResult, aContentType, aCharset);
38679:     }
78114: 
78114:     // ArrayBuffer?
78114:     jsval realVal;
78114:     JSObject* obj;
78114:     nsresult rv = aBody->GetAsJSVal(&realVal);
78114:     if (NS_SUCCEEDED(rv) && !JSVAL_IS_PRIMITIVE(realVal) &&
78114:         (obj = JSVAL_TO_OBJECT(realVal)) &&
95834:         (JS_IsArrayBufferObject(obj, aCx))) {
95834:       return GetRequestBody(obj, aCx, aResult, aContentType, aCharset);
78114:     }
38677:   }
38677:   else if (dataType == nsIDataType::VTYPE_VOID ||
38677:            dataType == nsIDataType::VTYPE_EMPTY) {
38677:     // Makes us act as if !aBody, don't upload anything
94307:     aContentType.AssignLiteral("text/plain");
94307:     aCharset.AssignLiteral("UTF-8");
94307: 
38677:     return NS_OK;
38677:   }
38677: 
38677:   PRUnichar* data = nsnull;
38677:   PRUint32 len = 0;
38677:   rv = aBody->GetAsWStringWithSize(&len, &data);
38677:   NS_ENSURE_SUCCESS(rv, rv);
38677: 
38677:   nsString string;
38677:   string.Adopt(data, len);
38677: 
94307:   return GetRequestBody(string, aResult, aContentType, aCharset);
94307: }
94307: 
94307: /* static */
94307: nsresult
95834: nsXMLHttpRequest::GetRequestBody(nsIVariant* aVariant, JSContext *aCx,
94512:                                  const Nullable<RequestBody>& aBody,
94307:                                  nsIInputStream** aResult,
94307:                                  nsACString& aContentType, nsACString& aCharset)
94307: {
94307:   if (aVariant) {
95834:     return ::GetRequestBody(aVariant, aCx, aResult, aContentType, aCharset);
94307:   }
94307: 
94512:   const RequestBody& body = aBody.Value();
94307:   RequestBody::Value value = body.GetValue();
94307:   switch (body.GetType()) {
94307:     case nsXMLHttpRequest::RequestBody::ArrayBuffer:
94307:     {
95834:       return ::GetRequestBody(value.mArrayBuffer, aCx, aResult, aContentType, aCharset);
94307:     }
94307:     case nsXMLHttpRequest::RequestBody::Blob:
94307:     {
94307:       nsresult rv;
94307:       nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(value.mBlob, &rv);
94307:       NS_ENSURE_SUCCESS(rv, rv);
94307: 
94307:       return ::GetRequestBody(sendable, aResult, aContentType, aCharset);
94307:     }
94307:     case nsXMLHttpRequest::RequestBody::Document:
94307:     {
94307:       nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(value.mDocument);
94307:       return ::GetRequestBody(document, aResult, aContentType, aCharset);
94307:     }
94307:     case nsXMLHttpRequest::RequestBody::DOMString:
94307:     {
94307:       return ::GetRequestBody(*value.mString, aResult, aContentType, aCharset);
94307:     }
94307:     case nsXMLHttpRequest::RequestBody::FormData:
94307:     {
94307:       nsresult rv;
94307:       nsCOMPtr<nsIXHRSendable> sendable = do_QueryInterface(value.mFormData, &rv);
94307:       NS_ENSURE_SUCCESS(rv, rv);
94307: 
94307:       return ::GetRequestBody(sendable, aResult, aContentType, aCharset);
94307:     }
94307:     case nsXMLHttpRequest::RequestBody::InputStream:
94307:     {
94307:       return ::GetRequestBody(value.mStream, aResult, aContentType, aCharset);
94307:     }
94307:     default:
94307:     {
94307:       return NS_ERROR_FAILURE;
94307:     }
94307:   }
94307: 
94307:   NS_NOTREACHED("Default cases exist for a reason");
94307:   return NS_OK;
38677: }
38677: 
20556: /* void send (in nsIVariant aBody); */
20556: NS_IMETHODIMP
95834: nsXMLHttpRequest::Send(nsIVariant *aBody, JSContext *aCx)
    1: {
95834:   return Send(aCx, aBody, Nullable<RequestBody>());
94307: }
94307: 
94307: nsresult
95834: nsXMLHttpRequest::Send(JSContext *aCx, nsIVariant* aVariant, const Nullable<RequestBody>& aBody)
94307: {
20556:   NS_ENSURE_TRUE(mPrincipal, NS_ERROR_NOT_INITIALIZED);
20556: 
20556:   nsresult rv = CheckInnerWindowCorrectness();
20556:   NS_ENSURE_SUCCESS(rv, rv);
20556: 
20556:   // Return error if we're already processing a request
20556:   if (XML_HTTP_REQUEST_SENT & mState) {
20556:     return NS_ERROR_FAILURE;
20556:   }
20556: 
20556:   // Make sure we've been opened
20556:   if (!mChannel || !(XML_HTTP_REQUEST_OPENED & mState)) {
20556:     return NS_ERROR_NOT_INITIALIZED;
20556:   }
20556: 
52200: 
52200:   // nsIRequest::LOAD_BACKGROUND prevents throbber from becoming active, which
52200:   // in turn keeps STOP button from becoming active.  If the consumer passed in
52200:   // a progress event handler we must load with nsIRequest::LOAD_NORMAL or
52200:   // necko won't generate any progress notifications.
52200:   if (HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR)) ||
52200:       HasListenersFor(NS_LITERAL_STRING(UPLOADPROGRESS_STR)) ||
52200:       (mUpload && mUpload->HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR)))) {
52200:     nsLoadFlags loadFlags;
52200:     mChannel->GetLoadFlags(&loadFlags);
52200:     loadFlags &= ~nsIRequest::LOAD_BACKGROUND;
52200:     loadFlags |= nsIRequest::LOAD_NORMAL;
52200:     mChannel->SetLoadFlags(loadFlags);
52200:   }
52200: 
20556:   // XXX We should probably send a warning to the JS console
20556:   //     if there are no event listeners set and we are doing
20556:   //     an asynchronous call.
20556: 
20556:   // Ignore argument if method is GET, there is no point in trying to
20556:   // upload anything
20556:   nsCAutoString method;
    1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
20556: 
20556:   if (httpChannel) {
20556:     httpChannel->GetRequestMethod(method); // If GET, method name will be uppercase
20556: 
63932:     if (!IsSystemXHR()) {
62277:       // Get the referrer for the request.
62277:       //
62277:       // If it weren't for history.push/replaceState, we could just use the
62277:       // principal's URI here.  But since we want changes to the URI effected
62277:       // by push/replaceState to be reflected in the XHR referrer, we have to
62277:       // be more clever.
62277:       //
62277:       // If the document's original URI (before any push/replaceStates) matches
62277:       // our principal, then we use the document's current URI (after
62277:       // push/replaceStates).  Otherwise (if the document is, say, a data:
62277:       // URI), we just use the principal's URI.
62277: 
62277:       nsCOMPtr<nsIURI> principalURI;
62277:       mPrincipal->GetURI(getter_AddRefs(principalURI));
62277: 
92083:       nsIScriptContext* sc = GetContextForEventHandlers(&rv);
92083:       NS_ENSURE_SUCCESS(rv, rv);
62277:       nsCOMPtr<nsIDocument> doc =
92083:         nsContentUtils::GetDocumentFromScriptContext(sc);
62277: 
62277:       nsCOMPtr<nsIURI> docCurURI;
62277:       nsCOMPtr<nsIURI> docOrigURI;
62277:       if (doc) {
62277:         docCurURI = doc->GetDocumentURI();
62277:         docOrigURI = doc->GetOriginalURI();
62277:       }
62277: 
62277:       nsCOMPtr<nsIURI> referrerURI;
62277: 
62277:       if (principalURI && docCurURI && docOrigURI) {
79445:         bool equal = false;
62277:         principalURI->Equals(docOrigURI, &equal);
62277:         if (equal) {
62277:           referrerURI = docCurURI;
62277:         }
62277:       }
62277: 
62277:       if (!referrerURI)
62277:         referrerURI = principalURI;
62277: 
62277:       httpChannel->SetReferrer(referrerURI);
20556:     }
35023: 
35023:     // Some extensions override the http protocol handler and provide their own
35023:     // implementation. The channels returned from that implementation doesn't
35023:     // seem to always implement the nsIUploadChannel2 interface, presumably
35023:     // because it's a new interface.
35023:     // Eventually we should remove this and simply require that http channels
35023:     // implement the new interface.
35023:     // See bug 529041
35023:     nsCOMPtr<nsIUploadChannel2> uploadChannel2 =
35023:       do_QueryInterface(httpChannel);
35023:     if (!uploadChannel2) {
35023:       nsCOMPtr<nsIConsoleService> consoleService =
35023:         do_GetService(NS_CONSOLESERVICE_CONTRACTID);
35023:       if (consoleService) {
35023:         consoleService->LogStringMessage(NS_LITERAL_STRING(
35027:           "Http channel implementation doesn't support nsIUploadChannel2. An extension has supplied a non-functional http protocol handler. This will break behavior and in future releases not work at all."
35027:                                                            ).get());
35023:       }
35023:     }
20556:   }
20556: 
20556:   mUploadTransferred = 0;
20556:   mUploadTotal = 0;
20556:   // By default we don't have any upload, so mark upload complete.
80486:   mUploadComplete = true;
80486:   mErrorLoad = false;
80486:   mLoadLengthComputable = false;
20640:   mLoadTotal = 0;
20640:   mUploadProgress = 0;
20640:   mUploadProgressMax = 0;
94512:   if ((aVariant || !aBody.IsNull()) && httpChannel &&
94307:       !method.EqualsLiteral("GET")) {
38677: 
38677:     nsCAutoString charset;
38677:     nsCAutoString defaultContentType;
    1:     nsCOMPtr<nsIInputStream> postDataStream;
38677: 
95834:     rv = GetRequestBody(aVariant, aCx, aBody, getter_AddRefs(postDataStream),
38677:                         defaultContentType, charset);
13258:     NS_ENSURE_SUCCESS(rv, rv);
13258: 
    1:     if (postDataStream) {
    1:       // If no content type header was set by the client, we set it to
    1:       // application/xml.
    1:       nsCAutoString contentType;
    1:       if (NS_FAILED(httpChannel->
    1:                       GetRequestHeader(NS_LITERAL_CSTRING("Content-Type"),
    1:                                        contentType)) ||
    1:           contentType.IsEmpty()) {
23635:         contentType = defaultContentType;
    1:       }
    1: 
 3251:       // We don't want to set a charset for streams.
 3251:       if (!charset.IsEmpty()) {
 8603:         nsCAutoString specifiedCharset;
79445:         bool haveCharset;
 8603:         PRInt32 charsetStart, charsetEnd;
 8603:         rv = NS_ExtractCharsetFromContentType(contentType, specifiedCharset,
 8603:                                               &haveCharset, &charsetStart,
 8603:                                               &charsetEnd);
23635:         if (NS_SUCCEEDED(rv)) {
82961:           // special case: the extracted charset is quoted with single quotes
82961:           // -- for the purpose of preserving what was set we want to handle
82961:           // them as delimiters (although they aren't really)
82961:           if (specifiedCharset.Length() >= 2 &&
82961:               specifiedCharset.First() == '\'' &&
82961:               specifiedCharset.Last() == '\'') {
82961:             specifiedCharset = Substring(specifiedCharset, 1,
82961:                                          specifiedCharset.Length() - 2);
82961:           }
82961: 
 8603:           // If the content-type the page set already has a charset parameter,
 8603:           // and it's the same charset, up to case, as |charset|, just send the
 8603:           // page-set content-type header.  Apparently at least
 8603:           // google-web-toolkit is broken and relies on the exact case of its
 8603:           // charset parameter, which makes things break if we use |charset|
 8603:           // (which is always a fully resolved charset per our charset alias
 8603:           // table, hence might be differently cased).
 8603:           if (!specifiedCharset.Equals(charset,
 8603:                                        nsCaseInsensitiveCStringComparator())) {
 8603:             nsCAutoString newCharset("; charset=");
 8603:             newCharset.Append(charset);
 8603:             contentType.Replace(charsetStart, charsetEnd - charsetStart,
 8603:                                 newCharset);
 8603:           }
 3251:         }
23635:       }
 1407: 
32329:       // If necessary, wrap the stream in a buffered stream so as to guarantee
32329:       // support for our upload when calling ExplicitSetUploadStream.
32329:       if (!NS_InputStreamIsBuffered(postDataStream)) {
32329:         nsCOMPtr<nsIInputStream> bufferedStream;
32329:         rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream),
32329:                                        postDataStream, 
32329:                                        4096);
32329:         NS_ENSURE_SUCCESS(rv, rv);
32329: 
32329:         postDataStream = bufferedStream;
32329:       }
32329: 
80486:       mUploadComplete = false;
20714:       PRUint32 uploadTotal = 0;
20714:       postDataStream->Available(&uploadTotal);
20714:       mUploadTotal = uploadTotal;
32329: 
32329:       // We want to use a newer version of the upload channel that won't
32329:       // ignore the necessary headers for an empty Content-Type.
35023:       nsCOMPtr<nsIUploadChannel2> uploadChannel2(do_QueryInterface(httpChannel));
35023:       // This assertion will fire if buggy extensions are installed
54922:       NS_ASSERTION(uploadChannel2, "http must support nsIUploadChannel2");
35023:       if (uploadChannel2) {
35023:           uploadChannel2->ExplicitSetUploadStream(postDataStream, contentType,
80486:                                                  -1, method, false);
35023:       }
35023:       else {
35023:         // http channel doesn't support the new nsIUploadChannel2. Emulate
35023:         // as best we can using nsIUploadChannel
35023:         if (contentType.IsEmpty()) {
35023:           contentType.AssignLiteral("application/octet-stream");
35023:         }
35023:         nsCOMPtr<nsIUploadChannel> uploadChannel =
35023:           do_QueryInterface(httpChannel);
35023:         uploadChannel->SetUploadStream(postDataStream, contentType, -1);
35023:         // Reset the method to its original value
35023:         httpChannel->SetRequestMethod(method);
35023:       }
20556:     }
20556:   }
20556: 
54922:   if (httpChannel) {
54922:     nsCAutoString contentTypeHeader;
54922:     rv = httpChannel->GetRequestHeader(NS_LITERAL_CSTRING("Content-Type"),
54922:                                        contentTypeHeader);
54922:     if (NS_SUCCEEDED(rv)) {
54922:       nsCAutoString contentType, charset;
54922:       rv = NS_ParseContentType(contentTypeHeader, contentType, charset);
54922:       NS_ENSURE_SUCCESS(rv, rv);
54922:   
54922:       if (!contentType.LowerCaseEqualsLiteral("text/plain") &&
54922:           !contentType.LowerCaseEqualsLiteral("application/x-www-form-urlencoded") &&
54922:           !contentType.LowerCaseEqualsLiteral("multipart/form-data")) {
64070:         mCORSUnsafeHeaders.AppendElement(NS_LITERAL_CSTRING("Content-Type"));
54922:       }
54922:     }
54922:   }
54922: 
78799:   ResetResponse();
20560: 
20560:   rv = CheckChannelForCrossSiteRequest(mChannel);
20560:   NS_ENSURE_SUCCESS(rv, rv);
20560: 
79445:   bool withCredentials = !!(mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS);
20560: 
20560:   // Hook us up to listen to redirects and the like
20560:   mChannel->GetNotificationCallbacks(getter_AddRefs(mNotificationCallbacks));
20560:   mChannel->SetNotificationCallbacks(this);
20560: 
20560:   // Create our listener
20560:   nsCOMPtr<nsIStreamListener> listener = this;
20560:   if (mState & XML_HTTP_REQUEST_MULTIPART) {
94239:     Telemetry::Accumulate(Telemetry::MULTIPART_XHR_RESPONSE, 1);
20560:     listener = new nsMultipartProxyListener(listener);
20560:     if (!listener) {
20560:       return NS_ERROR_OUT_OF_MEMORY;
20560:     }
94239:   } else {
94239:     Telemetry::Accumulate(Telemetry::MULTIPART_XHR_RESPONSE, 0);
20560:   }
20560: 
93840:   // Blocking gets are common enough out of XHR that we should mark
93840:   // the channel slow by default for pipeline purposes
93840:   AddLoadFlags(mChannel, nsIRequest::INHIBIT_PIPELINE);
93840: 
63932:   if (!IsSystemXHR()) {
64070:     // Always create a nsCORSListenerProxy here even if it's
20560:     // a same-origin request right now, since it could be redirected.
64070:     listener = new nsCORSListenerProxy(listener, mPrincipal, mChannel,
87071:                                        withCredentials, true, &rv);
20560:     NS_ENSURE_TRUE(listener, NS_ERROR_OUT_OF_MEMORY);
20560:     NS_ENSURE_SUCCESS(rv, rv);
20560:   }
20560: 
    1:   // Bypass the network cache in cases where it makes no sense:
    1:   // 1) Multipart responses are very large and would likely be doomed by the
    1:   //    cache once they grow too large, so they are not worth caching.
    1:   // 2) POST responses are always unique, and we provide no API that would
    1:   //    allow our consumers to specify a "cache key" to access old POST
    1:   //    responses, so they are not worth caching.
    1:   if ((mState & XML_HTTP_REQUEST_MULTIPART) || method.EqualsLiteral("POST")) {
    1:     AddLoadFlags(mChannel,
    1:         nsIRequest::LOAD_BYPASS_CACHE | nsIRequest::INHIBIT_CACHING);
    1:   }
    1:   // When we are sync loading, we need to bypass the local cache when it would
    1:   // otherwise block us waiting for exclusive access to the cache.  If we don't
    1:   // do this, then we could dead lock in some cases (see bug 309424).
20133:   else if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
    1:     AddLoadFlags(mChannel,
    1:         nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY);
    1:   }
    1: 
    1:   // Since we expect XML data, set the type hint accordingly
    1:   // This means that we always try to parse local files as XML
    1:   // ignoring return value, as this is not critical
    1:   mChannel->SetContentType(NS_LITERAL_CSTRING("application/xml"));
    1: 
88284:   // We're about to send the request.  Start our timeout.
88284:   mRequestSentTime = PR_Now();
88284:   StartTimeoutTimer();
88284: 
64069:   // Set up the preflight if needed
64069:   if (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT) {
64069:     // Check to see if this initial OPTIONS request has already been cached
64069:     // in our special Access Control Cache.
64069: 
64069:     rv = NS_StartCORSPreflight(mChannel, listener,
64069:                                mPrincipal, withCredentials,
64070:                                mCORSUnsafeHeaders,
64070:                                getter_AddRefs(mCORSPreflightChannel));
19951:     NS_ENSURE_SUCCESS(rv, rv);
19951:   }
19951:   else {
    1:     // Start reading from the channel
    1:     rv = mChannel->AsyncOpen(listener, nsnull);
19951:   }
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     // Drop our ref to the channel to avoid cycles
    1:     mChannel = nsnull;
64070:     mCORSPreflightChannel = nsnull;
    1:     return rv;
    1:   }
    1: 
90244:   // Either AsyncOpen was called, or CORS will open the channel later.
90244:   mWaitingForOnStopRequest = true;
90244: 
    1:   // If we're synchronous, spin an event loop here and wait
    1:   if (!(mState & XML_HTTP_REQUEST_ASYNC)) {
20133:     mState |= XML_HTTP_REQUEST_SYNCLOOPING;
25074: 
25722:     nsCOMPtr<nsIDocument> suspendedDoc;
25074:     nsCOMPtr<nsIRunnable> resumeTimeoutRunnable;
92083:     if (GetOwner()) {
25074:       nsCOMPtr<nsIDOMWindow> topWindow;
92083:       if (NS_SUCCEEDED(GetOwner()->GetTop(getter_AddRefs(topWindow)))) {
25074:         nsCOMPtr<nsPIDOMWindow> suspendedWindow(do_QueryInterface(topWindow));
25722:         if (suspendedWindow &&
25722:             (suspendedWindow = suspendedWindow->GetCurrentInnerWindow())) {
25722:           suspendedDoc = do_QueryInterface(suspendedWindow->GetExtantDocument());
25722:           if (suspendedDoc) {
25722:             suspendedDoc->SuppressEventHandling();
25722:           }
80486:           suspendedWindow->SuspendTimeouts(1, false);
25722:           resumeTimeoutRunnable = new nsResumeTimeoutsEvent(suspendedWindow);
25074:         }
25074:       }
25074:     }
25074: 
54235:     ChangeState(XML_HTTP_REQUEST_SENT);
94465: 
94465:     {
94465:       nsAutoSyncOperation sync(suspendedDoc);
54235:       // Note, calling ChangeState may have cleared
54235:       // XML_HTTP_REQUEST_SYNCLOOPING flag.
    1:       nsIThread *thread = NS_GetCurrentThread();
    1:       while (mState & XML_HTTP_REQUEST_SYNCLOOPING) {
    1:         if (!NS_ProcessNextEvent(thread)) {
    1:           rv = NS_ERROR_UNEXPECTED;
    1:           break;
    1:         }
    1:       }
94465:     }
25074: 
25722:     if (suspendedDoc) {
80486:       suspendedDoc->UnsuppressEventHandlingAndFireEvents(true);
25722:     }
25722: 
25074:     if (resumeTimeoutRunnable) {
25074:       NS_DispatchToCurrentThread(resumeTimeoutRunnable);
25074:     }
16665:   } else {
54235:     // Now that we've successfully opened the channel, we can change state.  Note
54235:     // that this needs to come after the AsyncOpen() and rv check, because this
54235:     // can run script that would try to restart this request, and that could end
54235:     // up doing our AsyncOpen on a null channel if the reentered AsyncOpen fails.
54235:     ChangeState(XML_HTTP_REQUEST_SENT);
84916:     if ((!mUploadComplete &&
84916:          HasListenersFor(NS_LITERAL_STRING(UPLOADPROGRESS_STR))) ||
20640:         (mUpload && mUpload->HasListenersFor(NS_LITERAL_STRING(PROGRESS_STR)))) {
20640:       StartProgressEventTimer();
20640:     }
80486:     DispatchProgressEvent(this, NS_LITERAL_STRING(LOADSTART_STR), false,
16665:                           0, 0);
16665:     if (mUpload && !mUploadComplete) {
80486:       DispatchProgressEvent(mUpload, NS_LITERAL_STRING(LOADSTART_STR), true,
16665:                             0, mUploadTotal);
16665:     }
    1:   }
    1: 
    1:   if (!mChannel) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* void setRequestHeader (in AUTF8String header, in AUTF8String value); */
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::SetRequestHeader(const nsACString& header,
    1:                                    const nsACString& value)
    1: {
 4064:   nsresult rv;
 4064: 
64070:   // Make sure we don't store an invalid header name in mCORSUnsafeHeaders
19952:   if (!IsValidHTTPToken(header)) {
19952:     return NS_ERROR_FAILURE;
19952:   }
19952: 
19951:   // Check that we haven't already opened the channel. We can't rely on
19951:   // the channel throwing from mChannel->SetRequestHeader since we might
64070:   // still be waiting for mCORSPreflightChannel to actually open mChannel
64070:   if (mCORSPreflightChannel) {
79445:     bool pending;
64070:     rv = mCORSPreflightChannel->IsPending(&pending);
19951:     NS_ENSURE_SUCCESS(rv, rv);
19951:     
19951:     if (pending) {
19951:       return NS_ERROR_IN_PROGRESS;
19951:     }
19951:   }
19951: 
74332:   if (!(mState & XML_HTTP_REQUEST_OPENED))
72497:     return NS_ERROR_IN_PROGRESS;
72497: 
 4106:   if (!mChannel)             // open() initializes mChannel, and open()
 4106:     return NS_ERROR_FAILURE; // must be called before first setRequestHeader()
 4106: 
 4064:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
 4106:   if (!httpChannel) {
 4106:     return NS_OK;
 4106:   }
    1: 
    1:   // Prevent modification to certain HTTP headers (see bug 302263), unless
86399:   // the executing script has UniversalXPConnect.
    1: 
79445:   bool privileged;
86399:   rv = IsCapabilityEnabled("UniversalXPConnect", &privileged);
    1:   if (NS_FAILED(rv))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!privileged) {
 4064:     // Check for dangerous headers
    1:     const char *kInvalidHeaders[] = {
57507:       "accept-charset", "accept-encoding", "access-control-request-headers",
57507:       "access-control-request-method", "connection", "content-length",
57507:       "cookie", "cookie2", "content-transfer-encoding", "date", "expect",
57507:       "host", "keep-alive", "origin", "referer", "te", "trailer",
57507:       "transfer-encoding", "upgrade", "user-agent", "via"
    1:     };
 4064:     PRUint32 i;
80467:     for (i = 0; i < ArrayLength(kInvalidHeaders); ++i) {
    1:       if (header.LowerCaseEqualsASCII(kInvalidHeaders[i])) {
    1:         NS_WARNING("refusing to set request header");
    1:         return NS_OK;
    1:       }
    1:     }
15889:     if (StringBeginsWith(header, NS_LITERAL_CSTRING("proxy-"),
15889:                          nsCaseInsensitiveCStringComparator()) ||
15889:         StringBeginsWith(header, NS_LITERAL_CSTRING("sec-"),
15889:                          nsCaseInsensitiveCStringComparator())) {
15889:       NS_WARNING("refusing to set request header");
15889:       return NS_OK;
15889:     }
19951: 
19951:     // Check for dangerous cross-site headers
63932:     bool safeHeader = IsSystemXHR();
19951:     if (!safeHeader) {
54922:       // Content-Type isn't always safe, but we'll deal with it in Send()
19951:       const char *kCrossOriginSafeHeaders[] = {
54922:         "accept", "accept-language", "content-language", "content-type",
54922:         "last-event-id"
19951:       };
80467:       for (i = 0; i < ArrayLength(kCrossOriginSafeHeaders); ++i) {
19951:         if (header.LowerCaseEqualsASCII(kCrossOriginSafeHeaders[i])) {
63932:           safeHeader = true;
19951:           break;
19951:         }
19951:       }
19951:     }
19951: 
19951:     if (!safeHeader) {
64070:       mCORSUnsafeHeaders.AppendElement(header);
19951:     }
 4064:   }
 4064: 
 4054:   // We need to set, not add to, the header.
80486:   rv = httpChannel->SetRequestHeader(header, value, false);
72497:   if (NS_SUCCEEDED(rv)) {
72497:     // We'll want to duplicate this header for any replacement channels (eg. on redirect)
72497:     RequestHeader reqHeader = {
72497:       nsCString(header), nsCString(value)
72497:     };
72497:     mModifiedRequestHeaders.AppendElement(reqHeader);
72497:   }
72497: 
72497:   return rv;
 4051: }
 4051: 
88284: /* attribute unsigned long timeout; */
88284: NS_IMETHODIMP
88284: nsXMLHttpRequest::GetTimeout(PRUint32 *aTimeout)
88284: {
94307:   *aTimeout = GetTimeout();
88284:   return NS_OK;
88284: }
94307: 
88284: NS_IMETHODIMP
88284: nsXMLHttpRequest::SetTimeout(PRUint32 aTimeout)
88284: {
94307:   nsresult rv = NS_OK;
94307:   SetTimeout(aTimeout, rv);
94307:   return rv;
94307: }
94307: 
94307: void
94307: nsXMLHttpRequest::SetTimeout(uint32_t aTimeout, nsresult& aRv)
94307: {
94307:   if (!(mState & (XML_HTTP_REQUEST_ASYNC | XML_HTTP_REQUEST_UNSENT)) &&
94307:       HasOrHasHadOwner()) {
94307:     /* Timeout is not supported for synchronous requests with an owning window,
94307:        per XHR2 spec. */
94307:     LogMessage("TimeoutSyncXHRWarning", GetOwner());
94307:     aRv = NS_ERROR_DOM_INVALID_ACCESS_ERR;
94307:     return;
94307:   }
94307: 
88284:   mTimeoutMilliseconds = aTimeout;
88284:   if (mRequestSentTime) {
88284:     StartTimeoutTimer();
88284:   }
88284: }
88284: 
88284: void
88284: nsXMLHttpRequest::StartTimeoutTimer()
88284: {
88284:   NS_ABORT_IF_FALSE(mRequestSentTime,
88284:                     "StartTimeoutTimer mustn't be called before the request was sent!");
88284:   if (mState & XML_HTTP_REQUEST_DONE) {
88284:     // do nothing!
88284:     return;
88284:   }
88284: 
88284:   if (mTimeoutTimer) {
88284:     mTimeoutTimer->Cancel();
88284:   }
88284: 
88284:   if (!mTimeoutMilliseconds) {
88284:     return;
88284:   }
88284: 
88284:   if (!mTimeoutTimer) {
88284:     mTimeoutTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
88284:   }
88284:   PRUint32 elapsed =
88284:     (PRUint32)((PR_Now() - mRequestSentTime) / PR_USEC_PER_MSEC);
88284:   mTimeoutTimer->InitWithCallback(
88284:     this,
88284:     mTimeoutMilliseconds > elapsed ? mTimeoutMilliseconds - elapsed : 0,
88284:     nsITimer::TYPE_ONE_SHOT
88284:   );
88284: }
88284: 
94307: /* readonly attribute unsigned short readyState; */
    1: NS_IMETHODIMP
69662: nsXMLHttpRequest::GetReadyState(PRUint16 *aState)
    1: {
94307:   *aState = GetReadyState();
94307:   return NS_OK;
94307: }
94307: 
94307: uint16_t
94307: nsXMLHttpRequest::GetReadyState()
94307: {
    1:   // Translate some of our internal states for external consumers
69662:   if (mState & XML_HTTP_REQUEST_UNSENT) {
94307:     return UNSENT;
94307:   }
94307:   if (mState & (XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT)) {
94307:     return OPENED;
94307:   }
94307:   if (mState & XML_HTTP_REQUEST_HEADERS_RECEIVED) {
94307:     return HEADERS_RECEIVED;
94307:   }
94307:   if (mState & (XML_HTTP_REQUEST_LOADING | XML_HTTP_REQUEST_STOPPED)) {
94307:     return LOADING;
94307:   }
94307:   MOZ_ASSERT(mState & XML_HTTP_REQUEST_DONE);
94307:   return DONE;
94307: }
94307: 
94307: /* void overrideMimeType(in DOMString mimetype); */
94307: NS_IMETHODIMP
94307: nsXMLHttpRequest::SlowOverrideMimeType(const nsAString& aMimeType)
94307: {
94307:   OverrideMimeType(aMimeType);
    1:   return NS_OK;
    1: }
    1: 
    1: /* attribute boolean multipart; */
    1: NS_IMETHODIMP
79445: nsXMLHttpRequest::GetMultipart(bool *_retval)
    1: {
94307:   *_retval = GetMultipart();
    1:   return NS_OK;
    1: }
    1: 
94307: bool
94307: nsXMLHttpRequest::GetMultipart()
94307: {
94307:   return !!(mState & XML_HTTP_REQUEST_MULTIPART);
94307: }
94307: 
    1: NS_IMETHODIMP
79445: nsXMLHttpRequest::SetMultipart(bool aMultipart)
    1: {
94307:   nsresult rv = NS_OK;
94307:   SetMultipart(aMultipart, rv);
94307:   return rv;
94307: }
94307: 
94307: void
94307: nsXMLHttpRequest::SetMultipart(bool aMultipart, nsresult& aRv)
94307: {
69662:   if (!(mState & XML_HTTP_REQUEST_UNSENT)) {
    1:     // Can't change this while we're in the middle of something.
94307:     aRv = NS_ERROR_IN_PROGRESS;
94307:     return;
    1:   }
    1: 
    1:   if (aMultipart) {
    1:     mState |= XML_HTTP_REQUEST_MULTIPART;
    1:   } else {
    1:     mState &= ~XML_HTTP_REQUEST_MULTIPART;
    1:   }
    1: }
    1: 
13282: /* attribute boolean mozBackgroundRequest; */
13282: NS_IMETHODIMP
79445: nsXMLHttpRequest::GetMozBackgroundRequest(bool *_retval)
13282: {
94307:   *_retval = GetMozBackgroundRequest();
13282:   return NS_OK;
13282: }
13282: 
94307: bool
94307: nsXMLHttpRequest::GetMozBackgroundRequest()
94307: {
94307:   return !!(mState & XML_HTTP_REQUEST_BACKGROUND);
94307: }
94307: 
13282: NS_IMETHODIMP
79445: nsXMLHttpRequest::SetMozBackgroundRequest(bool aMozBackgroundRequest)
13282: {
94307:   nsresult rv = NS_OK;
94307:   SetMozBackgroundRequest(aMozBackgroundRequest, rv);
94307:   return rv;
94307: }
94307: 
94307: void
94307: nsXMLHttpRequest::SetMozBackgroundRequest(bool aMozBackgroundRequest, nsresult& aRv)
94307: {
79445:   bool privileged;
94307:   aRv = IsCapabilityEnabled("UniversalXPConnect", &privileged);
94307:   if (NS_FAILED(aRv)) {
94307:     return;
94307:   }
94307: 
94307:   if (!privileged) {
94307:     aRv = NS_ERROR_DOM_SECURITY_ERR;
94307:     return;
94307:   }
13282: 
69662:   if (!(mState & XML_HTTP_REQUEST_UNSENT)) {
13282:     // Can't change this while we're in the middle of something.
94307:     aRv = NS_ERROR_IN_PROGRESS;
94307:     return;
13282:   }
13282: 
13282:   if (aMozBackgroundRequest) {
13282:     mState |= XML_HTTP_REQUEST_BACKGROUND;
13282:   } else {
13282:     mState &= ~XML_HTTP_REQUEST_BACKGROUND;
13282:   }
13282: }
13282: 
19954: /* attribute boolean withCredentials; */
19954: NS_IMETHODIMP
79445: nsXMLHttpRequest::GetWithCredentials(bool *_retval)
19954: {
94307:   *_retval = GetWithCredentials();
19954:   return NS_OK;
19954: }
19954: 
94307: bool
94307: nsXMLHttpRequest::GetWithCredentials()
94307: {
94307:   return !!(mState & XML_HTTP_REQUEST_AC_WITH_CREDENTIALS);
94307: }
94307: 
19954: NS_IMETHODIMP
79445: nsXMLHttpRequest::SetWithCredentials(bool aWithCredentials)
19954: {
94307:   nsresult rv = NS_OK;
94307:   SetWithCredentials(aWithCredentials, rv);
94307:   return rv;
94307: }
94307: 
94307: void
94307: nsXMLHttpRequest::SetWithCredentials(bool aWithCredentials, nsresult& aRv)
94307: {
19954:   // Return error if we're already processing a request
19954:   if (XML_HTTP_REQUEST_SENT & mState) {
94307:     aRv = NS_ERROR_FAILURE;
94307:     return;
19954:   }
19954: 
84264:   // sync request is not allowed setting withCredentials in window context
92083:   if (HasOrHasHadOwner() &&
84264:       !(mState & (XML_HTTP_REQUEST_UNSENT | XML_HTTP_REQUEST_ASYNC))) {
92083:     LogMessage("WithCredentialsSyncXHRWarning", GetOwner());
94307:     aRv = NS_ERROR_DOM_INVALID_ACCESS_ERR;
94307:     return;
84264:   }
84264: 
19954:   if (aWithCredentials) {
19954:     mState |= XML_HTTP_REQUEST_AC_WITH_CREDENTIALS;
94307:   } else {
19954:     mState &= ~XML_HTTP_REQUEST_AC_WITH_CREDENTIALS;
19954:   }
19954: }
19954: 
    1: nsresult
79445: nsXMLHttpRequest::ChangeState(PRUint32 aState, bool aBroadcast)
    1: {
    1:   // If we are setting one of the mutually exclusive states,
    1:   // unset those state bits first.
    1:   if (aState & XML_HTTP_REQUEST_LOADSTATES) {
    1:     mState &= ~XML_HTTP_REQUEST_LOADSTATES;
    1:   }
    1:   mState |= aState;
    1:   nsresult rv = NS_OK;
    1: 
20640:   if (mProgressNotifier &&
69662:       !(aState & (XML_HTTP_REQUEST_HEADERS_RECEIVED | XML_HTTP_REQUEST_LOADING))) {
88284:     mProgressTimerIsActive = false;
20640:     mProgressNotifier->Cancel();
20640:   }
20640: 
54235:   if ((aState & XML_HTTP_REQUEST_LOADSTATES) && // Broadcast load states only
54235:       aBroadcast &&
54235:       (mState & XML_HTTP_REQUEST_ASYNC ||
54235:        aState & XML_HTTP_REQUEST_OPENED ||
69662:        aState & XML_HTTP_REQUEST_DONE)) {
    1:     nsCOMPtr<nsIDOMEvent> event;
16665:     rv = CreateReadystatechangeEvent(getter_AddRefs(event));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
16664:     DispatchDOMEvent(nsnull, event, nsnull, nsnull);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
48889: /*
48889:  * Simple helper class that just forwards the redirect callback back
48889:  * to the nsXMLHttpRequest.
48889:  */
48889: class AsyncVerifyRedirectCallbackForwarder : public nsIAsyncVerifyRedirectCallback
48889: {
48889: public:
48889:   AsyncVerifyRedirectCallbackForwarder(nsXMLHttpRequest *xhr)
48889:     : mXHR(xhr)
48889:   {
48889:   }
48889: 
48889:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
48889:   NS_DECL_CYCLE_COLLECTION_CLASS(AsyncVerifyRedirectCallbackForwarder)
48889: 
48889:   // nsIAsyncVerifyRedirectCallback implementation
48889:   NS_IMETHOD OnRedirectVerifyCallback(nsresult result)
48889:   {
48889:     mXHR->OnRedirectVerifyCallback(result);
48889: 
48889:     return NS_OK;
48889:   }
48889: 
48889: private:
48889:   nsRefPtr<nsXMLHttpRequest> mXHR;
48889: };
48889: 
48889: NS_IMPL_CYCLE_COLLECTION_CLASS(AsyncVerifyRedirectCallbackForwarder)
48889: 
48889: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(AsyncVerifyRedirectCallbackForwarder)
71743: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mXHR, nsIXMLHttpRequest)
48889: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
48889: 
48889: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(AsyncVerifyRedirectCallbackForwarder)
48889:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mXHR)
48889: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
48889: 
48889: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(AsyncVerifyRedirectCallbackForwarder)
48889:   NS_INTERFACE_MAP_ENTRY(nsISupports)
48889:   NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
48889: NS_INTERFACE_MAP_END
48889: 
48889: NS_IMPL_CYCLE_COLLECTING_ADDREF(AsyncVerifyRedirectCallbackForwarder)
48889: NS_IMPL_CYCLE_COLLECTING_RELEASE(AsyncVerifyRedirectCallbackForwarder)
48889: 
48889: 
    1: /////////////////////////////////////////////////////
    1: // nsIChannelEventSink methods:
    1: //
    1: NS_IMETHODIMP
48889: nsXMLHttpRequest::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
    1:                                          nsIChannel *aNewChannel,
48889:                                          PRUint32    aFlags,
48889:                                          nsIAsyncVerifyRedirectCallback *callback)
    1: {
    1:   NS_PRECONDITION(aNewChannel, "Redirect without a channel?");
    1: 
 4064:   nsresult rv;
 4054: 
24084:   if (!NS_IsInternalSameURIRedirect(aOldChannel, aNewChannel, aFlags)) {
19951:     rv = CheckChannelForCrossSiteRequest(aNewChannel);
48889:     if (NS_FAILED(rv)) {
48889:       NS_WARNING("nsXMLHttpRequest::OnChannelRedirect: "
48889:                  "CheckChannelForCrossSiteRequest returned failure");
48889:       return rv;
48889:     }
 4064: 
19952:     // Disable redirects for preflighted cross-site requests entirely for now
19951:     // Note, do this after the call to CheckChannelForCrossSiteRequest
19951:     // to make sure that XML_HTTP_REQUEST_USE_XSITE_AC is up-to-date
19952:     if ((mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT)) {
19951:        return NS_ERROR_DOM_BAD_URI;
13898:     }
24084:   }
13898: 
48889:   // Prepare to receive callback
48889:   mRedirectCallback = callback;
48889:   mNewRedirectChannel = aNewChannel;
48889: 
13898:   if (mChannelEventSink) {
48889:     nsRefPtr<AsyncVerifyRedirectCallbackForwarder> fwd =
48889:       new AsyncVerifyRedirectCallbackForwarder(this);
48889: 
48889:     rv = mChannelEventSink->AsyncOnChannelRedirect(aOldChannel,
48889:                                                    aNewChannel,
48889:                                                    aFlags, fwd);
16665:     if (NS_FAILED(rv)) {
48889:         mRedirectCallback = nsnull;
48889:         mNewRedirectChannel = nsnull;
48889:     }
48889:     return rv;
48889:   }
48889:   OnRedirectVerifyCallback(NS_OK);
48889:   return NS_OK;
48889: }
48889: 
48889: void
48889: nsXMLHttpRequest::OnRedirectVerifyCallback(nsresult result)
48889: {
48889:   NS_ASSERTION(mRedirectCallback, "mRedirectCallback not set in callback");
48889:   NS_ASSERTION(mNewRedirectChannel, "mNewRedirectChannel not set in callback");
48889: 
72497:   if (NS_SUCCEEDED(result)) {
48889:     mChannel = mNewRedirectChannel;
72497: 
72497:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mChannel));
72497:     if (httpChannel) {
72497:       // Ensure all original headers are duplicated for the new channel (bug #553888)
72497:       for (PRUint32 i = mModifiedRequestHeaders.Length(); i > 0; ) {
72497:         --i;
72497:         httpChannel->SetRequestHeader(mModifiedRequestHeaders[i].header,
72497:                                       mModifiedRequestHeaders[i].value,
80486:                                       false);
72497:       }
72497:     }
72497:   } else {
80486:     mErrorLoad = true;
72497:   }
48889: 
48889:   mNewRedirectChannel = nsnull;
48889: 
48889:   mRedirectCallback->OnRedirectVerifyCallback(result);
48889:   mRedirectCallback = nsnull;
    1: }
    1: 
    1: /////////////////////////////////////////////////////
    1: // nsIProgressEventSink methods:
    1: //
    1: 
78799: void
79445: nsXMLHttpRequest::MaybeDispatchProgressEvents(bool aFinalProgress)
78799: {
88284:   if (aFinalProgress && mProgressTimerIsActive) {
88284:     mProgressTimerIsActive = false;
78799:     mProgressNotifier->Cancel();
78799:   }
78799: 
88284:   if (mProgressTimerIsActive ||
78799:       !mProgressSinceLastProgressEvent ||
78799:       mErrorLoad ||
78799:       !(mState & XML_HTTP_REQUEST_ASYNC)) {
78799:     return;
78799:   }
78799: 
78799:   if (!aFinalProgress) {
78799:     StartProgressEventTimer();
78799:   }
78799: 
78799:   // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
78799:   // XML_HTTP_REQUEST_SENT
78799:   if ((XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT) & mState) {
78799:     if (aFinalProgress) {
78799:       mUploadTotal = mUploadTransferred;
78799:       mUploadProgressMax = mUploadProgress;
80486:       mUploadLengthComputable = true;
78799:     }
78799:     DispatchProgressEvent(this, NS_LITERAL_STRING(UPLOADPROGRESS_STR),
80486:                           true, mUploadLengthComputable, mUploadTransferred,
78799:                           mUploadTotal, mUploadProgress,
78799:                           mUploadProgressMax);
78799:     if (mUpload && !mUploadComplete) {
78799:       DispatchProgressEvent(mUpload, NS_LITERAL_STRING(PROGRESS_STR),
80486:                             true, mUploadLengthComputable, mUploadTransferred,
78799:                             mUploadTotal, mUploadProgress,
78799:                             mUploadProgressMax);
78799:     }
78799:   } else {
78799:     if (aFinalProgress) {
78799:       mLoadTotal = mLoadTransferred;
80486:       mLoadLengthComputable = true;
80486:     }
80486:     mInLoadProgressEvent = true;
78799:     DispatchProgressEvent(this, NS_LITERAL_STRING(PROGRESS_STR),
80486:                           true, mLoadLengthComputable, mLoadTransferred,
78799:                           mLoadTotal, mLoadTransferred, mLoadTotal);
80486:     mInLoadProgressEvent = false;
78801:     if (mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_TEXT ||
78801:         mResponseType == XML_HTTP_RESPONSE_TYPE_CHUNKED_ARRAYBUFFER) {
78801:       mResponseBody.Truncate();
78801:       mResponseText.Truncate();
78801:       mResultArrayBuffer = nsnull;
78801:     }
78799:   }
78799: 
80486:   mProgressSinceLastProgressEvent = false;
78799: }
78799: 
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnProgress(nsIRequest *aRequest, nsISupports *aContext, PRUint64 aProgress, PRUint64 aProgressMax)
    1: {
19152:   // We're in middle of processing multipart headers and we don't want to report
19152:   // any progress because upload's 'load' is dispatched when we start to load
19152:   // the first response.
19152:   if (XML_HTTP_REQUEST_MPART_HEADERS & mState) {
19152:     return NS_OK;
19152:   }
19152: 
    1:   // We're uploading if our state is XML_HTTP_REQUEST_OPENED or
    1:   // XML_HTTP_REQUEST_SENT
79445:   bool upload = !!((XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT) & mState);
16665:   // When uploading, OnProgress reports also headers in aProgress and aProgressMax.
16665:   // So, try to remove the headers, if possible.
79445:   bool lengthComputable = (aProgressMax != LL_MAXUINT);
16665:   if (upload) {
78799:     PRUint64 loaded = aProgress;
78799:     PRUint64 total = aProgressMax;
16665:     if (lengthComputable) {
20714:       PRUint64 headerSize = aProgressMax - mUploadTotal;
16665:       loaded -= headerSize;
16665:       total -= headerSize;
16665:     }
78799:     mUploadLengthComputable = lengthComputable;
16665:     mUploadTransferred = loaded;
20640:     mUploadProgress = aProgress;
20640:     mUploadProgressMax = aProgressMax;
80486:     mProgressSinceLastProgressEvent = true;
80486: 
80486:     MaybeDispatchProgressEvents(false);
20640:   } else {
20640:     mLoadLengthComputable = lengthComputable;
78799:     mLoadTotal = lengthComputable ? aProgressMax : 0;
78799:     
78799:     // Don't dispatch progress events here. OnDataAvailable will take care
78799:     // of that.
16665:   }
    1: 
    1:   if (mProgressEventSink) {
    1:     mProgressEventSink->OnProgress(aRequest, aContext, aProgress,
    1:                                    aProgressMax);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::OnStatus(nsIRequest *aRequest, nsISupports *aContext, nsresult aStatus, const PRUnichar *aStatusArg)
    1: {
    1:   if (mProgressEventSink) {
    1:     mProgressEventSink->OnStatus(aRequest, aContext, aStatus, aStatusArg);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: bool
19953: nsXMLHttpRequest::AllowUploadProgress()
19953: {
19953:   return !(mState & XML_HTTP_REQUEST_USE_XSITE_AC) ||
19953:     (mState & XML_HTTP_REQUEST_NEED_AC_PREFLIGHT);
19953: }
19953: 
    1: /////////////////////////////////////////////////////
    1: // nsIInterfaceRequestor methods:
    1: //
    1: NS_IMETHODIMP
    1: nsXMLHttpRequest::GetInterface(const nsIID & aIID, void **aResult)
    1: {
14092:   nsresult rv;
14092: 
    1:   // Make sure to return ourselves for the channel event sink interface and
    1:   // progress event sink interface, no matter what.  We can forward these to
    1:   // mNotificationCallbacks if it wants to get notifications for them.  But we
    1:   // need to see these notifications for proper functioning.
    1:   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
    1:     mChannelEventSink = do_GetInterface(mNotificationCallbacks);
 3233:     *aResult = static_cast<nsIChannelEventSink*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   } else if (aIID.Equals(NS_GET_IID(nsIProgressEventSink))) {
    1:     mProgressEventSink = do_GetInterface(mNotificationCallbacks);
 3233:     *aResult = static_cast<nsIProgressEventSink*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Now give mNotificationCallbacks (if non-null) a chance to return the
13239:   // desired interface.
    1:   if (mNotificationCallbacks) {
14092:     rv = mNotificationCallbacks->GetInterface(aIID, aResult);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       NS_ASSERTION(*aResult, "Lying nsIInterfaceRequestor implementation!");
    1:       return rv;
    1:     }
    1:   }
    1: 
13282:   if (mState & XML_HTTP_REQUEST_BACKGROUND) {
13282:     nsCOMPtr<nsIInterfaceRequestor> badCertHandler(do_CreateInstance(NS_BADCERTHANDLER_CONTRACTID, &rv));
13282: 
13282:     // Ignore failure to get component, we may not have all its dependencies
13282:     // available
13282:     if (NS_SUCCEEDED(rv)) {
13282:       rv = badCertHandler->GetInterface(aIID, aResult);
13282:       if (NS_SUCCEEDED(rv))
13282:         return rv;
13282:     }
13282:   }
14092:   else if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
14092:            aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
14092:     nsCOMPtr<nsIPromptFactory> wwatch =
14092:       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
14092:     NS_ENSURE_SUCCESS(rv, rv);
14092: 
14092:     // Get the an auth prompter for our window so that the parenting
14092:     // of the dialogs works as it should when using tabs.
14092: 
14092:     nsCOMPtr<nsIDOMWindow> window;
92083:     if (GetOwner()) {
92083:       window = GetOwner()->GetOuterWindow();
14092:     }
14092: 
14092:     return wwatch->GetPrompt(window, aIID,
14092:                              reinterpret_cast<void**>(aResult));
14092: 
14092:   }
13282: 
    1:   return QueryInterface(aIID, aResult);
    1: }
    1: 
94512: JS::Value
94512: nsXMLHttpRequest::GetInterface(JSContext* aCx, nsIJSIID* aIID, nsresult& aRv)
94512: {
94512:   const nsID* iid = aIID->GetID();
94512:   nsCOMPtr<nsISupports> result;
94512:   JS::Value v = JSVAL_NULL;
94512:   aRv = GetInterface(*iid, getter_AddRefs(result));
94512:   NS_ENSURE_SUCCESS(aRv, JSVAL_NULL);
94512: 
94512:   JSObject* global = JS_GetGlobalForObject(aCx, GetWrapper());
94512:   aRv = nsContentUtils::WrapNative(aCx, global, result, iid, &v);
94512:   return NS_SUCCEEDED(aRv) ? v : JSVAL_NULL;
94512: }
94512: 
94307: nsXMLHttpRequestUpload*
94307: nsXMLHttpRequest::GetUpload()
94307: {
94307:   if (!mUpload) {
94307:     mUpload = new nsXMLHttpRequestUpload(this);
94307:   }
94307:   return mUpload;
94307: }
94307: 
16665: NS_IMETHODIMP
16665: nsXMLHttpRequest::GetUpload(nsIXMLHttpRequestUpload** aUpload)
16665: {
94307:   nsRefPtr<nsXMLHttpRequestUpload> upload = GetUpload();
94307:   upload.forget(aUpload);
16665:   return NS_OK;
16665: }
16665: 
88284: void
88284: nsXMLHttpRequest::HandleTimeoutCallback()
88284: {
88284:   if (mState & XML_HTTP_REQUEST_DONE) {
88284:     NS_NOTREACHED("nsXMLHttpRequest::HandleTimeoutCallback with completed request");
88284:     // do nothing!
88284:     return;
88284:   }
88284: 
88284:   CloseRequestWithError(NS_LITERAL_STRING(TIMEOUT_STR),
88284:                         XML_HTTP_REQUEST_TIMED_OUT);
88284: }
88284: 
20640: NS_IMETHODIMP
20640: nsXMLHttpRequest::Notify(nsITimer* aTimer)
20640: {
88284:   if (mProgressNotifier == aTimer) {
88284:     HandleProgressTimerCallback();
88284:     return NS_OK;
88284:   }
88284: 
88284:   if (mTimeoutTimer == aTimer) {
88284:     HandleTimeoutCallback();
88284:     return NS_OK;
88284:   }
88284: 
88284:   // Just in case some JS user wants to QI to nsITimerCallback and play with us...
88284:   NS_WARNING("Unexpected timer!");
88284:   return NS_ERROR_INVALID_POINTER;
88284: }
88284: 
88284: void
88284: nsXMLHttpRequest::HandleProgressTimerCallback()
88284: {
88284:   mProgressTimerIsActive = false;
20640:   if (!(XML_HTTP_REQUEST_MPART_HEADERS & mState)) {
80486:     MaybeDispatchProgressEvents(false);
78799:   }
20640: }
20640: 
20640: void
20640: nsXMLHttpRequest::StartProgressEventTimer()
20640: {
20640:   if (!mProgressNotifier) {
20640:     mProgressNotifier = do_CreateInstance(NS_TIMER_CONTRACTID);
20640:   }
20640:   if (mProgressNotifier) {
80486:     mProgressEventWasDelayed = false;
88284:     mProgressTimerIsActive = true;
20640:     mProgressNotifier->Cancel();
20640:     mProgressNotifier->InitWithCallback(this, NS_PROGRESS_EVENT_INTERVAL,
20640:                                         nsITimer::TYPE_ONE_SHOT);
20640:   }
20640: }
20640: 
    1: NS_IMPL_ISUPPORTS1(nsXMLHttpRequest::nsHeaderVisitor, nsIHttpHeaderVisitor)
    1: 
    1: NS_IMETHODIMP nsXMLHttpRequest::
    1: nsHeaderVisitor::VisitHeader(const nsACString &header, const nsACString &value)
    1: {
21639:     // See bug #380418. Hide "Set-Cookie" headers from non-chrome scripts.
79445:     bool chrome = false; // default to false in case IsCapabilityEnabled fails
21639:     IsCapabilityEnabled("UniversalXPConnect", &chrome);
21639:     if (!chrome &&
21639:          (header.LowerCaseEqualsASCII("set-cookie") ||
21639:           header.LowerCaseEqualsASCII("set-cookie2"))) {
21639:         NS_WARNING("blocked access to response header");
21639:     } else {
    1:         mHeaders.Append(header);
    1:         mHeaders.Append(": ");
    1:         mHeaders.Append(value);
    1:         mHeaders.Append('\n');
21639:     }
    1:     return NS_OK;
    1: }
    1: 
    1: // DOM event class to handle progress notifications
16665: nsXMLHttpProgressEvent::nsXMLHttpProgressEvent(nsIDOMProgressEvent* aInner,
16665:                                                PRUint64 aCurrentProgress,
79614:                                                PRUint64 aMaxProgress,
79614:                                                nsPIDOMWindow* aWindow)
79614:   : mWindow(aWindow)
    1: {
16665:   mInner = static_cast<nsDOMProgressEvent*>(aInner);
    1:   mCurProgress = aCurrentProgress;
    1:   mMaxProgress = aMaxProgress;
    1: }
    1: 
    1: nsXMLHttpProgressEvent::~nsXMLHttpProgressEvent()
    1: {}
    1: 
16665: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLHttpProgressEvent)
16665: 
40490: DOMCI_DATA(XMLHttpProgressEvent, nsXMLHttpProgressEvent)
40490: 
16665: // QueryInterface implementation for nsXMLHttpProgressEvent
16665: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXMLHttpProgressEvent)
16665:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMProgressEvent)
16665:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEvent, nsIDOMProgressEvent)
16665:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSEvent)
16665:   NS_INTERFACE_MAP_ENTRY(nsIPrivateDOMEvent)
16665:   NS_INTERFACE_MAP_ENTRY(nsIDOMProgressEvent)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMLSProgressEvent)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XMLHttpProgressEvent)
    1: NS_INTERFACE_MAP_END
    1: 
16665: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXMLHttpProgressEvent)
16665: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXMLHttpProgressEvent)
16665: 
16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsXMLHttpProgressEvent)
16665:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInner);
79614:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mWindow);
16665: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16665: 
16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsXMLHttpProgressEvent)
16665:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mInner,
16665:                                                        nsIDOMProgressEvent)
79614:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mWindow);
16665: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: NS_IMETHODIMP nsXMLHttpProgressEvent::GetInput(nsIDOMLSInput * *aInput)
    1: {
    1:   *aInput = nsnull;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
79614: void
79614: nsXMLHttpProgressEvent::WarnAboutLSProgressEvent(nsIDocument::DeprecatedOperations aOperation)
79614: {
79614:   if (!mWindow) {
79614:     return;
79614:   }
79614:   nsCOMPtr<nsIDocument> document =
79614:     do_QueryInterface(mWindow->GetExtantDocument());
79614:   if (!document) {
79614:     return;
79614:   }
79614:   document->WarnOnceAbout(aOperation);
79614: }
79614: 
    1: NS_IMETHODIMP nsXMLHttpProgressEvent::GetPosition(PRUint32 *aPosition)
    1: {
79614:   WarnAboutLSProgressEvent(nsIDocument::ePosition);
    1:   // XXX can we change the iface?
    1:   LL_L2UI(*aPosition, mCurProgress);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsXMLHttpProgressEvent::GetTotalSize(PRUint32 *aTotalSize)
    1: {
79614:   WarnAboutLSProgressEvent(nsIDocument::eTotalSize);
    1:   // XXX can we change the iface?
    1:   LL_L2UI(*aTotalSize, mMaxProgress);
    1:   return NS_OK;
    1: }
