152542: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
152542: /* This Source Code Form is subject to the terms of the Mozilla Public
152542:  * License, v. 2.0. If a copy of the MPL was not distributed with this
152542:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
152542: 
152542: /**
152542:  * Code responsible for managing style changes: tracking what style
152542:  * changes need to happen, scheduling them, and doing them.
152542:  */
152542: 
152542: #ifndef mozilla_RestyleManager_h
152542: #define mozilla_RestyleManager_h
152542: 
152542: #include "nsISupportsImpl.h"
152544: #include "nsChangeHint.h"
152544: #include "RestyleTracker.h"
152544: #include "nsPresContext.h"
152542: 
152544: class nsRefreshDriver;
152544: class nsIFrame;
152546: struct TreeMatchContext;
152542: 
152542: namespace mozilla {
152542: 
152544: namespace dom {
152544:   class Element;
152544: } // namespace dom
152544: 
153814: class RestyleManager MOZ_FINAL {
152542: public:
152544:   friend class ::nsRefreshDriver;
152544:   friend class RestyleTracker;
152544: 
152544:   typedef mozilla::dom::Element Element;
152544: 
152542:   RestyleManager(nsPresContext* aPresContext);
152542: 
152542:   NS_INLINE_DECL_REFCOUNTING(mozilla::RestyleManager)
152542: 
152542:   void Disconnect() {
152542:     mPresContext = nullptr;
152542:   }
152542: 
152542:   nsPresContext* PresContext() const {
152542:     MOZ_ASSERT(mPresContext);
152542:     return mPresContext;
152542:   }
152542: 
152544:   nsCSSFrameConstructor* FrameConstructor() const
152544:     { return PresContext()->FrameConstructor(); }
152544: 
152544:   // Should be called when a frame is going to be destroyed and
152544:   // WillDestroyFrameTree hasn't been called yet.
152544:   void NotifyDestroyingFrame(nsIFrame* aFrame);
152544: 
152544:   // Forwarded nsIDocumentObserver method, to handle restyling (and
152544:   // passing the notification to the frame).
152544:   nsresult ContentStateChanged(nsIContent*   aContent,
152544:                                nsEventStates aStateMask);
152544: 
152544:   // Forwarded nsIMutationObserver method, to handle restyling.
152544:   void AttributeWillChange(Element* aElement,
152544:                            int32_t  aNameSpaceID,
152544:                            nsIAtom* aAttribute,
152544:                            int32_t  aModType);
152544:   // Forwarded nsIMutationObserver method, to handle restyling (and
152544:   // passing the notification to the frame).
152544:   void AttributeChanged(Element* aElement,
152544:                         int32_t  aNameSpaceID,
152544:                         nsIAtom* aAttribute,
152544:                         int32_t  aModType);
152544: 
152544:   // Get an integer that increments every time there is a style change
152544:   // as a result of a change to the :hover content state.
152544:   uint32_t GetHoverGeneration() const { return mHoverGeneration; }
152544: 
152544:   // Get a counter that increments on every style change, that we use to
152544:   // track whether off-main-thread animations are up-to-date.
152544:   uint64_t GetAnimationGeneration() const { return mAnimationGeneration; }
152544: 
152546:   /**
152546:    * Reparent the style contexts of this frame subtree.  The parent frame of
152546:    * aFrame must be changed to the new parent before this function is called;
152546:    * the new parent style context will be automatically computed based on the
152546:    * new position in the frame tree.
152546:    *
152546:    * @param aFrame the root of the subtree to reparent.  Must not be null.
152546:    */
152546:   NS_HIDDEN_(nsresult) ReparentStyleContext(nsIFrame* aFrame);
152546: 
152546:   /**
152546:    * Re-resolve the style contexts for a frame tree, building
152546:    * aChangeList based on the resulting style changes, plus aMinChange
152546:    * applied to aFrame.
152546:    */
152546:   NS_HIDDEN_(void)
152546:     ComputeStyleChangeFor(nsIFrame* aFrame,
152546:                           nsStyleChangeList* aChangeList,
152546:                           nsChangeHint aMinChange,
152546:                           RestyleTracker& aRestyleTracker,
152546:                           bool aRestyleDescendants);
152546: 
152546: #ifdef DEBUG
152546:   /**
152546:    * DEBUG ONLY method to verify integrity of style tree versus frame tree
152546:    */
152546:   NS_HIDDEN_(void) DebugVerifyStyleTree(nsIFrame* aFrame);
152546: #endif
152546: 
152544:   // Note: It's the caller's responsibility to make sure to wrap a
152544:   // ProcessRestyledFrames call in a view update batch and a script blocker.
152544:   // This function does not call ProcessAttachedQueue() on the binding manager.
152544:   // If the caller wants that to happen synchronously, it needs to handle that
152544:   // itself.
152544:   nsresult ProcessRestyledFrames(nsStyleChangeList& aRestyleArray);
152544: 
152544: private:
152544:   void RestyleForEmptyChange(Element* aContainer);
152544: 
152544: public:
152544:   // Restyling for a ContentInserted (notification after insertion) or
152544:   // for a CharacterDataChanged.  |aContainer| must be non-null; when
152544:   // the container is null, no work is needed.
152544:   void RestyleForInsertOrChange(Element* aContainer, nsIContent* aChild);
152544: 
152544:   // This would be the same as RestyleForInsertOrChange if we got the
152544:   // notification before the removal.  However, we get it after, so we need the
152544:   // following sibling in addition to the old child.  |aContainer| must be
152544:   // non-null; when the container is null, no work is needed.  aFollowingSibling
152544:   // is the sibling that used to come after aOldChild before the removal.
152544:   void RestyleForRemove(Element* aContainer,
152544:                         nsIContent* aOldChild,
152544:                         nsIContent* aFollowingSibling);
152544: 
152544:   // Same for a ContentAppended.  |aContainer| must be non-null; when
152544:   // the container is null, no work is needed.
152544:   void RestyleForAppend(Element* aContainer, nsIContent* aFirstNewContent);
152544: 
152544:   // Process any pending restyles. This should be called after
152544:   // CreateNeededFrames.
152544:   // Note: It's the caller's responsibility to make sure to wrap a
152544:   // ProcessPendingRestyles call in a view update batch and a script blocker.
152544:   // This function does not call ProcessAttachedQueue() on the binding manager.
152544:   // If the caller wants that to happen synchronously, it needs to handle that
152544:   // itself.
152544:   void ProcessPendingRestyles();
152544: 
153810:   // ProcessPendingRestyles calls into one of our RestyleTracker
153810:   // objects.  It then calls back to these functions at the beginning
153810:   // and end of its work.
153810:   void BeginProcessingRestyles();
153810:   void EndProcessingRestyles();
153810: 
152544:   // Rebuilds all style data by throwing out the old rule tree and
152544:   // building a new one, and additionally applying aExtraHint (which
152544:   // must not contain nsChangeHint_ReconstructFrame) to the root frame.
152544:   void RebuildAllStyleData(nsChangeHint aExtraHint);
152544: 
152544:   // Helper that does part of the work of RebuildAllStyleData, shared by
152544:   // RestyleElement for 'rem' handling.
152544:   void DoRebuildAllStyleData(RestyleTracker& aRestyleTracker,
152544:                              nsChangeHint aExtraHint);
152544: 
152544:   // See PostRestyleEventCommon below.
152544:   void PostRestyleEvent(Element* aElement,
152544:                         nsRestyleHint aRestyleHint,
152544:                         nsChangeHint aMinChangeHint)
152544:   {
152544:     if (mPresContext) {
152544:       PostRestyleEventCommon(aElement, aRestyleHint, aMinChangeHint,
152544:                              mPresContext->IsProcessingAnimationStyleChange());
152544:     }
152544:   }
152544: 
152544:   // See PostRestyleEventCommon below.
152544:   void PostAnimationRestyleEvent(Element* aElement,
152544:                                  nsRestyleHint aRestyleHint,
152544:                                  nsChangeHint aMinChangeHint)
152544:   {
152544:     PostRestyleEventCommon(aElement, aRestyleHint, aMinChangeHint, true);
152544:   }
152544: 
152544:   void PostRestyleEventForLazyConstruction()
152544:   {
152544:     PostRestyleEventInternal(true);
152544:   }
152544: 
152544:   void FlushOverflowChangedTracker()
152544:   {
152544:     mOverflowChangedTracker.Flush();
152544:   }
152544: 
152544: private:
152544:   /**
152544:    * Notify the frame constructor that an element needs to have its
152544:    * style recomputed.
152544:    * @param aElement: The element to be restyled.
152544:    * @param aRestyleHint: Which nodes need to have selector matching run
152544:    *                      on them.
152544:    * @param aMinChangeHint: A minimum change hint for aContent and its
152544:    *                        descendants.
152544:    * @param aForAnimation: Whether the style should be computed with or
152544:    *                       without animation data.  Animation code
152544:    *                       sometimes needs to pass true; other code
152544:    *                       should generally pass the the pres context's
152544:    *                       IsProcessingAnimationStyleChange() value
152544:    *                       (which is the default value).
152544:    */
152544:   void PostRestyleEventCommon(Element* aElement,
152544:                               nsRestyleHint aRestyleHint,
152544:                               nsChangeHint aMinChangeHint,
152544:                               bool aForAnimation);
152544:   void PostRestyleEventInternal(bool aForLazyConstruction);
152544: 
152544: public:
152544:   /**
152544:    * Asynchronously clear style data from the root frame downwards and ensure
152544:    * it will all be rebuilt. This is safe to call anytime; it will schedule
152544:    * a restyle and take effect next time style changes are flushed.
152544:    * This method is used to recompute the style data when some change happens
152544:    * outside of any style rules, like a color preference change or a change
152544:    * in a system font size, or to fix things up when an optimization in the
152544:    * style data has become invalid. We assume that the root frame will not
152544:    * need to be reframed.
152544:    */
152544:   void PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint);
152544: 
152544: private:
152544:   /* aMinHint is the minimal change that should be made to the element */
152544:   // XXXbz do we really need the aPrimaryFrame argument here?
152544:   void RestyleElement(Element*        aElement,
152544:                       nsIFrame*       aPrimaryFrame,
152544:                       nsChangeHint    aMinHint,
152544:                       RestyleTracker& aRestyleTracker,
152544:                       bool            aRestyleDescendants);
152544: 
152544:   nsresult StyleChangeReflow(nsIFrame* aFrame, nsChangeHint aHint);
152544: 
152544:   // Returns true if this function managed to successfully move a frame, and
152544:   // false if it could not process the position change, and a reflow should
152544:   // be performed instead.
152544:   bool RecomputePosition(nsIFrame* aFrame);
152544: 
152542: private:
152542:   nsPresContext* mPresContext; // weak, disconnected in Disconnect
152544: 
152544:   bool mRebuildAllStyleData : 1;
152544:   // True if we're already waiting for a refresh notification
152544:   bool mObservingRefreshDriver : 1;
152544:   // True if we're in the middle of a nsRefreshDriver refresh
152544:   bool mInStyleRefresh : 1;
152544:   uint32_t mHoverGeneration;
152544:   nsChangeHint mRebuildAllExtraHint;
152544: 
152544:   OverflowChangedTracker mOverflowChangedTracker;
152544: 
152544:   // The total number of animation flushes by this frame constructor.
152544:   // Used to keep the layer and animation manager in sync.
152544:   uint64_t mAnimationGeneration;
152544: 
152544:   RestyleTracker mPendingRestyles;
152544:   RestyleTracker mPendingAnimationRestyles;
152542: };
152542: 
153814: /**
153814:  * An ElementRestyler is created for *each* element in a subtree that we
153814:  * recompute styles for.
153814:  */
153814: class ElementRestyler MOZ_FINAL {
153814: public:
153814:   typedef mozilla::dom::Element Element;
153814: 
153814:   // Construct for the root of the subtree that we're restyling.
153815:   ElementRestyler(nsPresContext* aPresContext,
153816:                   nsIFrame* aFrame,
153821:                   nsStyleChangeList* aChangeList,
153823:                   nsChangeHint aHintsHandledByAncestors,
153825:                   RestyleTracker& aRestyleTracker,
153826:                   TreeMatchContext& aTreeMatchContext,
153825:                   nsTArray<nsIContent*>& aVisibleKidsOfHiddenElement);
153814: 
153814:   // Construct for an element whose parent is being restyled.
153827:   enum ConstructorFlags {
153827:     FOR_OUT_OF_FLOW_CHILD = 1<<0
153827:   };
153816:   ElementRestyler(const ElementRestyler& aParentRestyler,
153827:                   nsIFrame* aFrame,
153827:                   uint32_t aConstructorFlags);
153814: 
153814:   // Construct for a frame whose parent is being restyled, but whose
153814:   // style context is the parent style context for its parent frame.
153814:   // (This is only used for table frames, whose style contexts are used
153814:   // as the parent style context for their outer table frame (table
153814:   // wrapper frame).  We should probably try to get rid of this
153814:   // exception and have the inheritance go the other way.)
153814:   enum ParentContextFromChildFrame { PARENT_CONTEXT_FROM_CHILD_FRAME };
153814:   ElementRestyler(ParentContextFromChildFrame,
153816:                   const ElementRestyler& aParentFrameRestyler,
153816:                   nsIFrame* aFrame);
153814: 
153814:   /**
153814:    * Restyle our frame's element and its subtree.
153814:    *
153814:    * Use eRestyle_Self for the aRestyleHint argument to mean
153814:    * "reresolve our style context but not kids", use eRestyle_Subtree
153814:    * to mean "reresolve our style context and kids", and use
153814:    * nsRestyleHint(0) to mean recompute a new style context for our
153814:    * current parent and existing rulenode, and the same for kids.
153814:    */
153826:   void Restyle(nsRestyleHint aRestyleHint);
153814: 
153815:   /**
153815:    * mHintsHandled changes over time; it starts off as the hints that
153815:    * have been handled by ancestors, and by the end of Restyle it
153815:    * represents the hints that have been handled for this frame.  This
153815:    * method is intended to be called after Restyle, to find out what
153815:    * hints have been handled for this frame.
153815:    */
153815:   nsChangeHint HintsHandledForFrame() { return mHintsHandled; }
153815: 
153814: private:
153836:   /**
153836:    * First half of Restyle().
153836:    */
163470:   void RestyleSelf(nsIFrame* aSelf, nsRestyleHint aRestyleHint);
153836: 
153836:   /**
153836:    * Restyle the children of this frame (and, in turn, their children).
153836:    *
153836:    * Second half of Restyle().
153836:    */
153836:   void RestyleChildren(nsRestyleHint aChildRestyleHint);
153836: 
153836:   /**
153836:    * Helper for RestyleSelf().
153836:    */
153814:   void CaptureChange(nsStyleContext* aOldContext,
153814:                      nsStyleContext* aNewContext,
153814:                      nsChangeHint aChangeToAssume);
153814: 
153836:   /**
153836:    * Helpers for RestyleChildren().
153836:    */
153836:   void RestyleUndisplayedChildren(nsRestyleHint aChildRestyleHint);
153836:   void RestyleBeforePseudo();
163470:   void RestyleAfterPseudo(nsIFrame* aFrame);
163470:   void RestyleContentChildren(nsIFrame* aParent,
163470:                               nsRestyleHint aChildRestyleHint);
153836:   void InitializeAccessibilityNotifications();
153836:   void SendAccessibilityNotifications();
153836: 
153824:   enum DesiredA11yNotifications {
153824:     eSkipNotifications,
153824:     eSendAllNotifications,
153824:     eNotifyIfShown
153824:   };
153824: 
153824:   enum A11yNotificationType {
153824:     eDontNotify,
153824:     eNotifyShown,
153824:     eNotifyHidden
153824:   };
153824: 
153814: private:
153814:   nsPresContext* const mPresContext;
153816:   nsIFrame* const mFrame;
153819:   nsIContent* const mParentContent;
153819:   // |mContent| is the node that we used for rule matching of
153819:   // normal elements (not pseudo-elements) and for which we generate
153819:   // framechange hints if we need them.
153819:   nsIContent* const mContent;
153821:   nsStyleChangeList* const mChangeList;
153815:   // We have already generated change list entries for hints listed in
153815:   // mHintsHandled (initially it's those handled by ancestors, but by
153815:   // the end of Restyle it is those handled for this frame as well).  We
153815:   // need to generate a new change list entry for the frame when its
153815:   // style comparision returns a hint other than one of these hints.
153815:   nsChangeHint mHintsHandled;
153822:   // See nsStyleContext::CalcStyleDifference
153822:   nsChangeHint mParentFrameHintsNotHandledForDescendants;
153822:   nsChangeHint mHintsNotHandledForDescendants;
153823:   RestyleTracker& mRestyleTracker;
153826:   TreeMatchContext& mTreeMatchContext;
153834:   nsIFrame* mResolvedChild; // child that provides our parent style context
153824: 
154029: #ifdef ACCESSIBILITY
153824:   const DesiredA11yNotifications mDesiredA11yNotifications;
153824:   DesiredA11yNotifications mKidsDesiredA11yNotifications;
153824:   A11yNotificationType mOurA11yNotification;
153825:   nsTArray<nsIContent*>& mVisibleKidsOfHiddenElement;
153831:   bool mWasFrameVisible;
154029: #endif
153814: };
153814: 
152542: } // namespace mozilla
152542: 
152542: #endif /* mozilla_RestyleManager_h */
