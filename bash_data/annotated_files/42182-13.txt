    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "imgRequestProxy.h"
    1: 
    1: #include "nsIInputStream.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIMultiPartChannel.h"
    1: 
    1: #include "nsString.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsCRT.h"
    1: 
    1: #include "ImageErrors.h"
    1: #include "ImageLogging.h"
    1: 
    1: #include "nspr.h"
35581: #include "imgContainerRequest.h"
    1: 
18557: NS_IMPL_ISUPPORTS4(imgRequestProxy, imgIRequest, nsIRequest,
18557:                    nsISupportsPriority, nsISecurityInfoProvider)
    1: 
    1: imgRequestProxy::imgRequestProxy() :
    1:   mOwner(nsnull),
    1:   mListener(nsnull),
    1:   mLoadFlags(nsIRequest::LOAD_NORMAL),
32516:   mLocksHeld(0),
    1:   mCanceled(PR_FALSE),
13293:   mIsInLoadGroup(PR_FALSE),
32424:   mListenerIsStrongRef(PR_FALSE),
32516:   mDecodeRequested(PR_FALSE)
    1: {
    1:   /* member initializers and constructor code */
    1: 
    1: }
    1: 
    1: imgRequestProxy::~imgRequestProxy()
    1: {
    1:   /* destructor code */
    1:   NS_PRECONDITION(!mListener, "Someone forgot to properly cancel this request!");
22953: 
32516:   // Unlock the image the proper number of times if we're holding locks on it.
32516:   // Note that UnlockImage() decrements mLocksHeld each time it's called.
32516:   if (mOwner) {
32516:     while (mLocksHeld)
32424:       UnlockImage();
32516:   }
32424: 
    1:   // Explicitly set mListener to null to ensure that the RemoveProxy
    1:   // call below can't send |this| to an arbitrary listener while |this|
13293:   // is being destroyed.  This is all belt-and-suspenders in view of the
13293:   // above assert.
13293:   NullOutListener();
    1: 
    1:   if (mOwner) {
    1:     if (!mCanceled) {
    1:       mCanceled = PR_TRUE;
    1: 
    1:       /* Call RemoveProxy with a successful status.  This will keep the
    1:          channel, if still downloading data, from being canceled if 'this' is
    1:          the last observer.  This allows the image to continue to download and
    1:          be cached even if no one is using it currently.
    1:          
    1:          Passing false to aNotify means that we will still get
    1:          OnStopRequest, if needed.
    1:        */
    1:       mOwner->RemoveProxy(this, NS_OK, PR_FALSE);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult imgRequestProxy::Init(imgRequest *request, nsILoadGroup *aLoadGroup, imgIDecoderObserver *aObserver)
    1: {
 6229:   NS_PRECONDITION(!mOwner && !mListener, "imgRequestProxy is already initialized");
    1:   NS_PRECONDITION(request, "no request");
    1:   if (!request)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   LOG_SCOPE_WITH_PARAM(gImgLog, "imgRequestProxy::Init", "request", request);
    1: 
    1:   mOwner = request;
    1:   mListener = aObserver;
13293:   // Make sure to addref mListener before the AddProxy call below, since
13293:   // that call might well want to release it if the imgRequest has
13293:   // already seen OnStopRequest.
13293:   if (mListener) {
13293:     mListenerIsStrongRef = PR_TRUE;
13293:     NS_ADDREF(mListener);
13293:   }
    1:   mLoadGroup = aLoadGroup;
    1: 
23532:   // Note: AddProxy won't send all the On* notifications immediately
 6229:   request->AddProxy(this);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult imgRequestProxy::ChangeOwner(imgRequest *aNewOwner)
    1: {
    1:   if (mCanceled)
    1:     return NS_OK;
    1: 
32424:   // Were we decoded before?
32424:   PRBool wasDecoded = PR_FALSE;
32424:   if (mOwner->GetImageStatus() & imgIRequest::STATUS_FRAME_COMPLETE)
32424:     wasDecoded = PR_TRUE;
32424: 
32516:   // If we're holding locks, unlock the old image.
32516:   // Note that UnlockImage decrements mLocksHeld each time it's called.
32516:   PRUint32 oldLockCount = mLocksHeld;
32516:   while (mLocksHeld)
32424:     UnlockImage();
32424: 
    1:   // Passing false to aNotify means that mListener will still get
    1:   // OnStopRequest, if needed.
    1:   mOwner->RemoveProxy(this, NS_IMAGELIB_CHANGING_OWNER, PR_FALSE);
    1: 
    1:   mOwner = aNewOwner;
    1: 
 6229:   mOwner->AddProxy(this);
    1: 
32516:   // If we were decoded, or if we'd previously requested a decode, request a
32516:   // decode on the new image
32516:   if (wasDecoded || mDecodeRequested)
32516:     mOwner->RequestDecode();
32424: 
32516:   // If we were locked, apply the locks here
32516:   for (PRUint32 i = 0; i < oldLockCount; i++)
32424:     LockImage();
32424: 
    1:   return NS_OK;
    1: }
    1: 
    1: void imgRequestProxy::AddToLoadGroup()
    1: {
    1:   NS_ASSERTION(!mIsInLoadGroup, "Whaa, we're already in the loadgroup!");
    1: 
    1:   if (!mIsInLoadGroup && mLoadGroup) {
    1:     mLoadGroup->AddRequest(this, nsnull);
    1:     mIsInLoadGroup = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::RemoveFromLoadGroup(PRBool releaseLoadGroup)
    1: {
    1:   if (!mIsInLoadGroup)
    1:     return;
    1: 
    1:   /* calling RemoveFromLoadGroup may cause the document to finish
    1:      loading, which could result in our death.  We need to make sure
    1:      that we stay alive long enough to fight another battle... at
    1:      least until we exit this function.
    1:   */
    1:   nsCOMPtr<imgIRequest> kungFuDeathGrip(this);
    1: 
42182:   mLoadGroup->RemoveRequest(this, NS_OK, nsnull);
    1:   mIsInLoadGroup = PR_FALSE;
    1: 
    1:   if (releaseLoadGroup) {
    1:     // We're done with the loadgroup, release it.
    1:     mLoadGroup = nsnull;
    1:   }
    1: }
    1: 
    1: 
    1: /**  nsIRequest / imgIRequest methods **/
    1: 
    1: /* readonly attribute wstring name; */
    1: NS_IMETHODIMP imgRequestProxy::GetName(nsACString &aName)
    1: {
    1:   aName.Truncate();
    1:   if (mOwner) {
    1:     nsCOMPtr<nsIURI> uri;
    1:     mOwner->GetURI(getter_AddRefs(uri));
    1:     if (uri)
    1:       uri->GetSpec(aName);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /* boolean isPending (); */
    1: NS_IMETHODIMP imgRequestProxy::IsPending(PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* readonly attribute nsresult status; */
    1: NS_IMETHODIMP imgRequestProxy::GetStatus(nsresult *aStatus)
    1: {
24472:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* void cancel (in nsresult status); */
    1: NS_IMETHODIMP imgRequestProxy::Cancel(nsresult status)
    1: {
    1:   if (mCanceled || !mOwner)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   LOG_SCOPE(gImgLog, "imgRequestProxy::Cancel");
    1: 
    1:   mCanceled = PR_TRUE;
    1: 
22953:   nsCOMPtr<nsIRunnable> ev = new imgCancelRunnable(this, status);
22953:   return NS_DispatchToCurrentThread(ev);
22953: }
22953: 
22953: void
22953: imgRequestProxy::DoCancel(nsresult status)
22953: {
    1:   // Passing false to aNotify means that mListener will still get
    1:   // OnStopRequest, if needed.
    1:   mOwner->RemoveProxy(this, status, PR_FALSE);
    1: 
13293:   NullOutListener();
22953: }
22953: 
22953: /* void cancelAndForgetObserver (in nsresult aStatus); */
22953: NS_IMETHODIMP imgRequestProxy::CancelAndForgetObserver(nsresult aStatus)
22953: {
22953:   if (mCanceled || !mOwner)
22953:     return NS_ERROR_FAILURE;
22953: 
22953:   LOG_SCOPE(gImgLog, "imgRequestProxy::CancelAndForgetObserver");
22953: 
22953:   mCanceled = PR_TRUE;
22953: 
39122:   // Now cheat and make sure our removal from loadgroup happens async
39122:   PRBool oldIsInLoadGroup = mIsInLoadGroup;
39122:   mIsInLoadGroup = PR_FALSE;
39122:   
22953:   // Passing false to aNotify means that mListener will still get
22953:   // OnStopRequest, if needed.
22953:   mOwner->RemoveProxy(this, aStatus, PR_FALSE);
22953: 
39122:   mIsInLoadGroup = oldIsInLoadGroup;
39122: 
39122:   if (mIsInLoadGroup) {
39122:     nsCOMPtr<nsIRunnable> ev =
41361:       NS_NewRunnableMethod(this, &imgRequestProxy::DoRemoveFromLoadGroup);
39122:     NS_DispatchToCurrentThread(ev);
39122:   }
39122: 
22953:   NullOutListener();
21421: 
21421:   return NS_OK;
    1: }
    1: 
32424: /* void requestDecode (); */
32424: NS_IMETHODIMP
32424: imgRequestProxy::RequestDecode()
32424: {
32424:   if (!mOwner)
32424:     return NS_ERROR_FAILURE;
32424: 
32516:   // Flag this, so we know to transfer the request if our owner changes
32516:   mDecodeRequested = PR_TRUE;
32424: 
32516:   // Forward the request
32516:   return mOwner->RequestDecode();
32424: }
32424: 
32424: /* void lockImage (); */
32424: NS_IMETHODIMP
32424: imgRequestProxy::LockImage()
32424: {
32424:   if (!mOwner)
32424:     return NS_ERROR_FAILURE;
32424: 
32516:   // Increment our lock count
32516:   mLocksHeld++;
32424: 
32516:   // Forward the request
32516:   return mOwner->LockImage();
32424: }
32424: 
32424: /* void unlockImage (); */
32424: NS_IMETHODIMP
32424: imgRequestProxy::UnlockImage()
32424: {
32424:   if (!mOwner)
32424:     return NS_ERROR_FAILURE;
32424: 
32516:   // Decrement our lock count
32516:   NS_ABORT_IF_FALSE(mLocksHeld > 0, "calling unlock but no locks!");
32516:   mLocksHeld--;
32424: 
32516:   // Forward the request
32516:   return mOwner->UnlockImage();
32424: }
32424: 
    1: /* void suspend (); */
    1: NS_IMETHODIMP imgRequestProxy::Suspend()
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* void resume (); */
    1: NS_IMETHODIMP imgRequestProxy::Resume()
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* attribute nsILoadGroup loadGroup */
    1: NS_IMETHODIMP imgRequestProxy::GetLoadGroup(nsILoadGroup **loadGroup)
    1: {
    1:   NS_IF_ADDREF(*loadGroup = mLoadGroup.get());
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP imgRequestProxy::SetLoadGroup(nsILoadGroup *loadGroup)
    1: {
    1:   mLoadGroup = loadGroup;
    1:   return NS_OK;
    1: }
    1: 
    1: /* attribute nsLoadFlags loadFlags */
    1: NS_IMETHODIMP imgRequestProxy::GetLoadFlags(nsLoadFlags *flags)
    1: {
    1:   *flags = mLoadFlags;
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP imgRequestProxy::SetLoadFlags(nsLoadFlags flags)
    1: {
    1:   mLoadFlags = flags;
    1:   return NS_OK;
    1: }
    1: 
    1: /**  imgIRequest methods **/
    1: 
    1: /* attribute imgIContainer image; */
    1: NS_IMETHODIMP imgRequestProxy::GetImage(imgIContainer * *aImage)
    1: {
    1:   if (!mOwner)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mOwner->GetImage(aImage);
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute unsigned long imageStatus; */
    1: NS_IMETHODIMP imgRequestProxy::GetImageStatus(PRUint32 *aStatus)
    1: {
    1:   if (!mOwner) {
    1:     *aStatus = imgIRequest::STATUS_ERROR;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   *aStatus = mOwner->GetImageStatus();
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIURI URI; */
    1: NS_IMETHODIMP imgRequestProxy::GetURI(nsIURI **aURI)
    1: {
    1:   if (!mOwner)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mOwner->GetURI(aURI);
    1: }
    1: 
    1: /* readonly attribute imgIDecoderObserver decoderObserver; */
    1: NS_IMETHODIMP imgRequestProxy::GetDecoderObserver(imgIDecoderObserver **aDecoderObserver)
    1: {
    1:   *aDecoderObserver = mListener;
    1:   NS_IF_ADDREF(*aDecoderObserver);
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute string mimeType; */
    1: NS_IMETHODIMP imgRequestProxy::GetMimeType(char **aMimeType)
    1: {
    1:   if (!mOwner)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   const char *type = mOwner->GetMimeType();
    1:   if (!type)
    1:     return NS_ERROR_FAILURE;
    1: 
26655:   *aMimeType = NS_strdup(type);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgRequestProxy::Clone(imgIDecoderObserver* aObserver,
    1:                                      imgIRequest** aClone)
    1: {
    1:   NS_PRECONDITION(aClone, "Null out param");
    1:   *aClone = nsnull;
    1:   imgRequestProxy* clone = new imgRequestProxy();
    1:   if (!clone) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   NS_ADDREF(clone);
    1: 
    1:   // It is important to call |SetLoadFlags()| before calling |Init()| because
    1:   // |Init()| adds the request to the loadgroup.
    1:   // When a request is added to a loadgroup, its load flags are merged
    1:   // with the load flags of the loadgroup.
    1:   // XXXldb That's not true anymore.  Stuff from imgLoader adds the
    1:   // request to the loadgroup.
    1:   clone->SetLoadFlags(mLoadFlags);
    1:   nsresult rv = clone->Init(mOwner, mLoadGroup, aObserver);
    1:   if (NS_FAILED(rv)) {
    1:     NS_RELEASE(clone);
    1:     return rv;
    1:   }
    1: 
    1:   // Assign to *aClone before calling NotifyProxyListener so that if
    1:   // the caller expects to only be notified for requests it's already
    1:   // holding pointers to it won't be surprised.
    1:   *aClone = clone;
    1: 
    1:   // Send the notifications to the clone's observer
    1:   mOwner->NotifyProxyListener(clone);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 7703: /* readonly attribute nsIPrincipal imagePrincipal; */
 7703: NS_IMETHODIMP imgRequestProxy::GetImagePrincipal(nsIPrincipal **aPrincipal)
 7703: {
 7703:   if (!mOwner)
 7703:     return NS_ERROR_FAILURE;
 7703: 
 7703:   return mOwner->GetPrincipal(aPrincipal);
 7703: }
 7703: 
    1: /** nsISupportsPriority methods **/
    1: 
    1: NS_IMETHODIMP imgRequestProxy::GetPriority(PRInt32 *priority)
    1: {
    1:   NS_ENSURE_STATE(mOwner);
    1:   *priority = mOwner->Priority();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgRequestProxy::SetPriority(PRInt32 priority)
    1: {
    1:   NS_ENSURE_STATE(mOwner && !mCanceled);
    1:   mOwner->AdjustPriority(this, priority - mOwner->Priority());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgRequestProxy::AdjustPriority(PRInt32 priority)
    1: {
    1:   NS_ENSURE_STATE(mOwner && !mCanceled);
    1:   mOwner->AdjustPriority(this, priority);
    1:   return NS_OK;
    1: }
    1: 
18557: /** nsISecurityInfoProvider methods **/
18557: 
18557: NS_IMETHODIMP imgRequestProxy::GetSecurityInfo(nsISupports** _retval)
18557: {
18557:   if (mOwner)
18557:     return mOwner->GetSecurityInfo(_retval);
18557: 
18557:   *_retval = nsnull;
18557:   return NS_OK;
18557: }
18557: 
25037: NS_IMETHODIMP imgRequestProxy::GetHasTransferredData(PRBool* hasData)
25037: {
25037:   if (mOwner) {
25037:     *hasData = mOwner->HasTransferredData();
25037:   } else {
25037:     // The safe thing to do is to claim we have data
25037:     *hasData = PR_TRUE;
25037:   }
25037:   return NS_OK;
25037: }
25037: 
    1: /** imgIContainerObserver methods **/
    1: 
30479: void imgRequestProxy::FrameChanged(imgIContainer *container, nsIntRect * dirtyRect)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::FrameChanged");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
30479:     mListener->FrameChanged(container, dirtyRect);
    1:   }
    1: }
    1: 
    1: /** imgIDecoderObserver methods **/
    1: 
    1: void imgRequestProxy::OnStartDecode()
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStartDecode");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStartDecode(this);
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::OnStartContainer(imgIContainer *image)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStartContainer");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStartContainer(this, image);
    1:   }
    1: }
    1: 
30479: void imgRequestProxy::OnStartFrame(PRUint32 frame)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStartFrame");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStartFrame(this, frame);
    1:   }
    1: }
    1: 
30479: void imgRequestProxy::OnDataAvailable(PRBool aCurrentFrame, const nsIntRect * rect)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnDataAvailable");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
30479:     mListener->OnDataAvailable(this, aCurrentFrame, rect);
    1:   }
    1: }
    1: 
30479: void imgRequestProxy::OnStopFrame(PRUint32 frame)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStopFrame");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStopFrame(this, frame);
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::OnStopContainer(imgIContainer *image)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStopContainer");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStopContainer(this, image);
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::OnStopDecode(nsresult status, const PRUnichar *statusArg)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequestProxy::OnStopDecode");
    1: 
22953:   if (mListener && !mCanceled) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStopDecode(this, status, statusArg);
    1:   }
    1: }
    1: 
32424: void imgRequestProxy::OnDiscard()
32424: {
32424:   LOG_FUNC(gImgLog, "imgRequestProxy::OnDiscard");
32424: 
32424:   if (mListener && !mCanceled) {
32424:     // Hold a ref to the listener while we call it, just in case.
32424:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
32424:     mListener->OnDiscard(this);
32424:   }
32424: }
32424: 
32424: 
    1: 
    1: 
    1: void imgRequestProxy::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
    1: {
    1: #ifdef PR_LOGGING
    1:   nsCAutoString name;
    1:   GetName(name);
    1:   LOG_FUNC_WITH_PARAM(gImgLog, "imgRequestProxy::OnStartRequest", "name", name.get());
    1: #endif
    1: 
22953:   // Notify even if mCanceled, since OnStartRequest is guaranteed by the
22953:   // nsIStreamListener contract so it makes sense to do the same here.
    1:   if (mListener) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStartRequest(this);
    1:   }
    1: }
    1: 
    1: void imgRequestProxy::OnStopRequest(nsIRequest *request, nsISupports *ctxt,
    1:                                     nsresult statusCode, PRBool lastPart)
    1: {
    1: #ifdef PR_LOGGING
    1:   nsCAutoString name;
    1:   GetName(name);
    1:   LOG_FUNC_WITH_PARAM(gImgLog, "imgRequestProxy::OnStopRequest", "name", name.get());
    1: #endif
13419:   // There's all sorts of stuff here that could kill us (the OnStopRequest call
13419:   // on the listener, the removal from the loadgroup, the release of the
13419:   // listener, etc).  Don't let them do it.
13419:   nsCOMPtr<imgIRequest> kungFuDeathGrip(this);
    1: 
    1:   if (mListener) {
    1:     // Hold a ref to the listener while we call it, just in case.
    1:     nsCOMPtr<imgIDecoderObserver> kungFuDeathGrip(mListener);
    1:     mListener->OnStopRequest(this, lastPart);
    1:   }
    1: 
    1:   // If we're expecting more data from a multipart channel, re-add ourself
    1:   // to the loadgroup so that the document doesn't lose track of the load.
    1:   // If the request is already a background request and there's more data
    1:   // coming, we can just leave the request in the loadgroup as-is.
    1:   if (lastPart || (mLoadFlags & nsIRequest::LOAD_BACKGROUND) == 0) {
    1:     RemoveFromLoadGroup(lastPart);
    1:     // More data is coming, so change the request to be a background request
    1:     // and put it back in the loadgroup.
    1:     if (!lastPart) {
    1:       mLoadFlags |= nsIRequest::LOAD_BACKGROUND;
    1:       AddToLoadGroup();
    1:     }
    1:   }
13293: 
13293:   if (mListenerIsStrongRef) {
13293:     NS_PRECONDITION(mListener, "How did that happen?");
13293:     // Drop our strong ref to the listener now that we're done with
13293:     // everything.  Note that this can cancel us and other fun things
13293:     // like that.  Don't add anything in this method after this point.
13293:     imgIDecoderObserver* obs = mListener;
13293:     mListenerIsStrongRef = PR_FALSE;
13293:     NS_RELEASE(obs);
13293:   }
    1: }
    1: 
13293: void imgRequestProxy::NullOutListener()
13293: {
13293:   if (mListenerIsStrongRef) {
13293:     // Releasing could do weird reentery stuff, so just play it super-safe
13293:     nsCOMPtr<imgIDecoderObserver> obs;
13293:     obs.swap(mListener);
13293:     mListenerIsStrongRef = PR_FALSE;
13293:   } else {
13293:     mListener = nsnull;
13293:   }
13293: }
35581: 
35581: NS_IMETHODIMP
35581: imgRequestProxy::GetStaticRequest(imgIRequest** aReturn)
35581: {
35581:   *aReturn = nsnull;
35581:   nsCOMPtr<imgIContainer> img, currentFrame;
35581:   GetImage(getter_AddRefs(img));
35581:   if (img) {
35581:     PRBool animated = PR_FALSE;
35581:     nsresult rv = img->GetAnimated(&animated);
35581:     if (NS_SUCCEEDED(rv) && !animated) {
35581:       NS_ADDREF(*aReturn = this);
35581:       return NS_OK;
35581:     }
35581: 
35581:     PRInt32 w = 0;
35581:     PRInt32 h = 0;
35581:     img->GetWidth(&w);
35581:     img->GetHeight(&h);
35581:     nsIntRect rect(0, 0, w, h);
35581:     img->ExtractFrame(imgIContainer::FRAME_CURRENT, rect,
35581:                       imgIContainer::FLAG_SYNC_DECODE,
35581:                       getter_AddRefs(currentFrame));
35581:   }
35581: 
35581:   nsCOMPtr<nsIURI> uri;
35581:   GetURI(getter_AddRefs(uri));
35581:   PRUint32 imageStatus = 0;
35581:   GetImageStatus(&imageStatus);
35581:   nsCOMPtr<nsIPrincipal> principal;
35581:   GetImagePrincipal(getter_AddRefs(principal));
35581: 
35581:   imgContainerRequest* req =
35581:     new imgContainerRequest(currentFrame, uri, imageStatus,
35581:                             mOwner ? mOwner->GetState() : 0,
35581:                             principal);
35581:   if (!req) {
35581:     return NS_ERROR_OUT_OF_MEMORY;
35581:   }
35581: 
35581:   NS_ADDREF(*aReturn = req);
35581:   return NS_OK;
35581: }
35581: 
