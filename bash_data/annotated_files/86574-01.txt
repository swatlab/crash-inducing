    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript Debugging support - Value and Property support
    1:  */
    1: 
    1: #include "jsd.h"
30637: #include "jsapi.h"
59931: #include "jsfriendapi.h"
    1: 
    1: #ifdef DEBUG
    1: void JSD_ASSERT_VALID_VALUE(JSDValue* jsdval)
    1: {
    1:     JS_ASSERT(jsdval);
    1:     JS_ASSERT(jsdval->nref > 0);
    1:     if(!JS_CLIST_IS_EMPTY(&jsdval->props))
    1:     {
    1:         JS_ASSERT(CHECK_BIT_FLAG(jsdval->flags, GOT_PROPS));
    1:         JS_ASSERT(JSVAL_IS_OBJECT(jsdval->val));
    1:     }
    1: 
    1:     if(jsdval->proto)
    1:     {
    1:         JS_ASSERT(CHECK_BIT_FLAG(jsdval->flags, GOT_PROTO));
    1:         JS_ASSERT(jsdval->proto->nref > 0);
    1:     }
    1:     if(jsdval->parent)
    1:     {
    1:         JS_ASSERT(CHECK_BIT_FLAG(jsdval->flags, GOT_PARENT));
    1:         JS_ASSERT(jsdval->parent->nref > 0);
    1:     }
    1:     if(jsdval->ctor)
    1:     {
    1:         JS_ASSERT(CHECK_BIT_FLAG(jsdval->flags, GOT_CTOR));
    1:         JS_ASSERT(jsdval->ctor->nref > 0);
    1:     }
    1: }
    1: 
    1: void JSD_ASSERT_VALID_PROPERTY(JSDProperty* jsdprop)
    1: {
    1:     JS_ASSERT(jsdprop);
    1:     JS_ASSERT(jsdprop->name);
    1:     JS_ASSERT(jsdprop->name->nref > 0);
    1:     JS_ASSERT(jsdprop->val);
    1:     JS_ASSERT(jsdprop->val->nref > 0);
    1:     if(jsdprop->alias)
    1:         JS_ASSERT(jsdprop->alias->nref > 0);
    1: }
    1: #endif
    1: 
    1: 
    1: JSBool
    1: jsd_IsValueObject(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_OBJECT(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueNumber(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_NUMBER(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueInt(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_INT(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueDouble(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_DOUBLE(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueString(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_STRING(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueBoolean(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_BOOLEAN(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueNull(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_NULL(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueVoid(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_VOID(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValuePrimitive(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return JSVAL_IS_PRIMITIVE(jsdval->val);
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueFunction(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return !JSVAL_IS_PRIMITIVE(jsdval->val) &&
60563:            JS_ObjectIsCallable(jsdc->dumbContext, JSVAL_TO_OBJECT(jsdval->val));
    1: }
    1: 
    1: JSBool
    1: jsd_IsValueNative(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     JSContext* cx = jsdc->dumbContext;
    1:     JSFunction* fun;
    1:     JSExceptionState* exceptionState;
54754:     JSCrossCompartmentCall *call = NULL;
    1: 
    1:     if(jsd_IsValueFunction(jsdc, jsdval))
    1:     {
    1:         JSBool ok = JS_FALSE;
    1:         JS_BeginRequest(cx);
60563:         call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, JSVAL_TO_OBJECT(jsdval->val));
54754:         if(!call) {
54754:             JS_EndRequest(cx);
54754: 
54754:             return JS_FALSE;
54754:         }
54754: 
    1:         exceptionState = JS_SaveExceptionState(cx);
60563:         fun = JSD_GetValueFunction(jsdc, jsdval);
    1:         JS_RestoreExceptionState(cx, exceptionState);
    1:         if(fun)
    1:             ok = JS_GetFunctionScript(cx, fun) ? JS_FALSE : JS_TRUE;
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         JS_EndRequest(cx);
    1:         JS_ASSERT(fun);
    1:         return ok;
    1:     }
60563:     return !JSVAL_IS_PRIMITIVE(jsdval->val);
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: JSBool
    1: jsd_GetValueBoolean(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     jsval val = jsdval->val;
    1:     if(!JSVAL_IS_BOOLEAN(val))
    1:         return JS_FALSE;
    1:     return JSVAL_TO_BOOLEAN(val);
    1: }
    1: 
84755: int32_t
    1: jsd_GetValueInt(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     jsval val = jsdval->val;
    1:     if(!JSVAL_IS_INT(val))
    1:         return 0;
    1:     return JSVAL_TO_INT(val);
    1: }
    1: 
48470: jsdouble
    1: jsd_GetValueDouble(JSDContext* jsdc, JSDValue* jsdval)
    1: {
48470:     if(!JSVAL_IS_DOUBLE(jsdval->val))
    1:         return 0;
48470:     return JSVAL_TO_DOUBLE(jsdval->val);
    1: }
    1: 
    1: JSString*
    1: jsd_GetValueString(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     JSContext* cx = jsdc->dumbContext;
    1:     JSExceptionState* exceptionState;
54754:     JSCrossCompartmentCall *call = NULL;
62384:     jsval stringval;
62384:     JSString *string;
62384:     JSBool needWrap;
62384:     JSObject *scopeObj;
    1: 
62384:     if(jsdval->string)
62384:         return jsdval->string;
62384: 
62384:     /* Reuse the string without copying or re-rooting it */
62384:     if(JSVAL_IS_STRING(jsdval->val)) {
    1:         jsdval->string = JSVAL_TO_STRING(jsdval->val);
62384:         return jsdval->string;
62384:     }
62384: 
    1:     JS_BeginRequest(cx);
62384: 
62384:     /* Objects call JS_ValueToString in their own compartment. */
86574:     scopeObj = !JSVAL_IS_PRIMITIVE(jsdval->val) ? JSVAL_TO_OBJECT(jsdval->val) : jsdc->glob;
62384:     call = JS_EnterCrossCompartmentCall(cx, scopeObj);
54754:     if(!call) {
54754:         JS_EndRequest(cx);
62384:         return NULL;
62384:     }
62384:     exceptionState = JS_SaveExceptionState(cx);
54754: 
62384:     string = JS_ValueToString(cx, jsdval->val);
62384: 
62384:     JS_RestoreExceptionState(cx, exceptionState);
62384:     JS_LeaveCrossCompartmentCall(call);
64525:     call = NULL;
62384: 
62972:     if(string) {
62384:         stringval = STRING_TO_JSVAL(string);
62384:         call = JS_EnterCrossCompartmentCall(cx, jsdc->glob);
62972:     }
62972:     if(!string || !call || !JS_WrapValue(cx, &stringval)) {
62972:         if(call)
62972:             JS_LeaveCrossCompartmentCall(call);
62384:         JS_EndRequest(cx);
54754:         return NULL;
54754:     }
54754: 
62384:     jsdval->string = JSVAL_TO_STRING(stringval);
47403:     if(!JS_AddNamedStringRoot(cx, &jsdval->string, "ValueString"))
    1:         jsdval->string = NULL;
62384: 
54754:     JS_LeaveCrossCompartmentCall(call);
    1:     JS_EndRequest(cx);
62384: 
    1:     return jsdval->string;
    1: }
    1: 
58976: JSString*
61691: jsd_GetValueFunctionId(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     JSContext* cx = jsdc->dumbContext;
    1:     JSFunction* fun;
    1:     JSExceptionState* exceptionState;
54754:     JSCrossCompartmentCall *call = NULL;
    1: 
    1:     if(!jsdval->funName && jsd_IsValueFunction(jsdc, jsdval))
    1:     {
    1:         JS_BeginRequest(cx);
54754: 
56450:         call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, JSVAL_TO_OBJECT(jsdval->val));
54754:         if(!call) {
54754:             JS_EndRequest(cx);
54754: 
54754:             return NULL;
54754:         }
54754: 
    1:         exceptionState = JS_SaveExceptionState(cx);
60563:         fun = JSD_GetValueFunction(jsdc, jsdval);
    1:         JS_RestoreExceptionState(cx, exceptionState);
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         JS_EndRequest(cx);
    1:         if(!fun)
    1:             return NULL;
58976:         jsdval->funName = JS_GetFunctionId(fun);
59931: 
59931:         /* For compatibility we return "anonymous", not an empty string here. */
58976:         if (!jsdval->funName)
59931:             jsdval->funName = JS_GetAnonymousString(jsdc->jsrt);
    1:     }
    1:     return jsdval->funName;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
62384: /*
62384:  * Create a new JSD value referring to a jsval. Copy string values into the
62384:  * JSD compartment. Leave all other GCTHINGs in their native compartments
62384:  * and access them through cross-compartment calls.
62384:  */
    1: JSDValue*
    1: jsd_NewValue(JSDContext* jsdc, jsval val)
    1: {
    1:     JSDValue* jsdval;
54754:     JSCrossCompartmentCall *call = NULL;
    1: 
    1:     if(!(jsdval = (JSDValue*) calloc(1, sizeof(JSDValue))))
    1:         return NULL;
    1: 
    1:     if(JSVAL_IS_GCTHING(val))
    1:     {
62384:         JSBool ok;
    1:         JS_BeginRequest(jsdc->dumbContext);
54754: 
54754:         call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, jsdc->glob);
54754:         if(!call) {
54754:             JS_EndRequest(jsdc->dumbContext);
59929:             free(jsdval);
54754:             return NULL;
54754:         }
54754: 
47403:         ok = JS_AddNamedValueRoot(jsdc->dumbContext, &jsdval->val, "JSDValue");
62384:         if(ok && JSVAL_IS_STRING(val)) {
62384:             if(!JS_WrapValue(jsdc->dumbContext, &val)) {
62384:                 ok = JS_FALSE;
62384:             }
62384:         }
62384: 
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         JS_EndRequest(jsdc->dumbContext);
    1:         if(!ok)
    1:         {
    1:             free(jsdval);
    1:             return NULL;
    1:         }
    1:     }
    1:     jsdval->val  = val;
    1:     jsdval->nref = 1;
    1:     JS_INIT_CLIST(&jsdval->props);
    1: 
    1:     return jsdval;
    1: }
    1: 
    1: void
    1: jsd_DropValue(JSDContext* jsdc, JSDValue* jsdval)
    1: {
54754:     JSCrossCompartmentCall *call = NULL;
54754: 
    1:     JS_ASSERT(jsdval->nref > 0);
    1:     if(0 == --jsdval->nref)
    1:     {
    1:         jsd_RefreshValue(jsdc, jsdval);
    1:         if(JSVAL_IS_GCTHING(jsdval->val))
    1:         {
    1:             JS_BeginRequest(jsdc->dumbContext);
54754:             call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, jsdc->glob);
54754:             if(!call) {
54754:                 JS_EndRequest(jsdc->dumbContext);
54754: 
54754:                 return;
54754:             }
54754: 
47403:             JS_RemoveValueRoot(jsdc->dumbContext, &jsdval->val);
54754:             JS_LeaveCrossCompartmentCall(call);
    1:             JS_EndRequest(jsdc->dumbContext);
    1:         }
    1:         free(jsdval);
    1:     }
    1: }
    1: 
    1: jsval
    1: jsd_GetValueWrappedJSVal(JSDContext* jsdc, JSDValue* jsdval)
    1: {
30637:     JSObject* obj;
30637:     JSContext* cx;
30637:     jsval val = jsdval->val;
30637:     if (!JSVAL_IS_PRIMITIVE(val)) {
30637:         cx = JSD_GetDefaultJSContext(jsdc);
79734:         obj = JS_ObjectToOuterObject(cx, JSVAL_TO_OBJECT(val));
30637:         if (!obj)
30637:         {
30637:             JS_ClearPendingException(cx);
30637:             val = JSVAL_NULL;
30637:         }
30637:         else
30637:             val = OBJECT_TO_JSVAL(obj);
30637:     }
30637:     
30637:     return val;
    1: }
    1: 
    1: static JSDProperty* _newProperty(JSDContext* jsdc, JSPropertyDesc* pd,
    1:                                  uintN additionalFlags)
    1: {
    1:     JSDProperty* jsdprop;
    1: 
    1:     if(!(jsdprop = (JSDProperty*) calloc(1, sizeof(JSDProperty))))
    1:         return NULL;
    1: 
    1:     JS_INIT_CLIST(&jsdprop->links);
    1:     jsdprop->nref = 1;
    1:     jsdprop->flags = pd->flags | additionalFlags;
    1:     jsdprop->slot = pd->slot;
    1: 
    1:     if(!(jsdprop->name = jsd_NewValue(jsdc, pd->id)))
    1:         goto new_prop_fail;
    1: 
    1:     if(!(jsdprop->val = jsd_NewValue(jsdc, pd->value)))
    1:         goto new_prop_fail;
    1: 
    1:     if((jsdprop->flags & JSDPD_ALIAS) &&
    1:        !(jsdprop->alias = jsd_NewValue(jsdc, pd->alias)))
    1:         goto new_prop_fail;
    1: 
    1:     return jsdprop;
    1: new_prop_fail:
    1:     jsd_DropProperty(jsdc, jsdprop);
    1:     return NULL;
    1: }
    1: 
    1: static void _freeProps(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     JSDProperty* jsdprop;
    1: 
    1:     while(jsdprop = (JSDProperty*)jsdval->props.next,
    1:           jsdprop != (JSDProperty*)&jsdval->props)
    1:     {
    1:         JS_REMOVE_AND_INIT_LINK(&jsdprop->links);
    1:         jsd_DropProperty(jsdc, jsdprop);
    1:     }
    1:     JS_ASSERT(JS_CLIST_IS_EMPTY(&jsdval->props));
    1:     CLEAR_BIT_FLAG(jsdval->flags, GOT_PROPS);
    1: }
    1: 
    1: static JSBool _buildProps(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     JSContext* cx = jsdc->dumbContext;
56450:     JSObject *obj;
    1:     JSPropertyDescArray pda;
    1:     uintN i;
54754:     JSCrossCompartmentCall *call = NULL;
    1: 
    1:     JS_ASSERT(JS_CLIST_IS_EMPTY(&jsdval->props));
    1:     JS_ASSERT(!(CHECK_BIT_FLAG(jsdval->flags, GOT_PROPS)));
    1:     JS_ASSERT(JSVAL_IS_OBJECT(jsdval->val));
    1: 
56450:     if(JSVAL_IS_PRIMITIVE(jsdval->val))
    1:         return JS_FALSE;
    1: 
56450:     obj = JSVAL_TO_OBJECT(jsdval->val);
56450: 
    1:     JS_BeginRequest(cx);
56450:     call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, obj);
56450:     if(!call)
56450:     {
54754:         JS_EndRequest(jsdc->dumbContext);
54754:         return JS_FALSE;
54754:     }
54754: 
56450:     if(!JS_GetPropertyDescArray(cx, obj, &pda))
    1:     {
    1:         JS_EndRequest(cx);
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     for(i = 0; i < pda.length; i++)
    1:     {
    1:         JSDProperty* prop = _newProperty(jsdc, &pda.array[i], 0);
    1:         if(!prop)
    1:         {
    1:             _freeProps(jsdc, jsdval);
    1:             break;
    1:         }
    1:         JS_APPEND_LINK(&prop->links, &jsdval->props);
    1:     }
    1:     JS_PutPropertyDescArray(cx, &pda);
54754:     JS_LeaveCrossCompartmentCall(call);
    1:     JS_EndRequest(cx);
    1:     SET_BIT_FLAG(jsdval->flags, GOT_PROPS);
    1:     return !JS_CLIST_IS_EMPTY(&jsdval->props);
    1: }
    1: 
    1: #undef  DROP_CLEAR_VALUE
    1: #define DROP_CLEAR_VALUE(jsdc, x) if(x){jsd_DropValue(jsdc,x); x = NULL;}
    1: 
    1: void
    1: jsd_RefreshValue(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     JSContext* cx = jsdc->dumbContext;
54754:     JSCrossCompartmentCall *call = NULL;
    1: 
    1:     if(jsdval->string)
    1:     {
    1:         /* if the jsval is a string, then we didn't need to root the string */
    1:         if(!JSVAL_IS_STRING(jsdval->val))
    1:         {
    1:             JS_BeginRequest(cx);
54754:             call = JS_EnterCrossCompartmentCall(cx, jsdc->glob);
54754:             if(!call) {
54754:                 JS_EndRequest(cx);
54754: 
54754:                 return;
54754:             }
54754: 
47403:             JS_RemoveStringRoot(cx, &jsdval->string);
54754:             JS_LeaveCrossCompartmentCall(call);
    1:             JS_EndRequest(cx);
    1:         }
    1:         jsdval->string = NULL;
    1:     }
    1: 
    1:     jsdval->funName = NULL;
    1:     jsdval->className = NULL;
    1:     DROP_CLEAR_VALUE(jsdc, jsdval->proto);
    1:     DROP_CLEAR_VALUE(jsdc, jsdval->parent);
    1:     DROP_CLEAR_VALUE(jsdc, jsdval->ctor);
    1:     _freeProps(jsdc, jsdval);
    1:     jsdval->flags = 0;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: uintN
    1: jsd_GetCountOfProperties(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     JSDProperty* jsdprop;
    1:     uintN count = 0;
    1: 
    1:     if(!(CHECK_BIT_FLAG(jsdval->flags, GOT_PROPS)))
    1:         if(!_buildProps(jsdc, jsdval))
    1:             return 0;
    1: 
    1:     for(jsdprop = (JSDProperty*)jsdval->props.next;
    1:         jsdprop != (JSDProperty*)&jsdval->props;
    1:         jsdprop = (JSDProperty*)jsdprop->links.next)
    1:     {
    1:         count++;
    1:     }
    1:     return count;
    1: }
    1: 
    1: JSDProperty*
    1: jsd_IterateProperties(JSDContext* jsdc, JSDValue* jsdval, JSDProperty **iterp)
    1: {
    1:     JSDProperty* jsdprop = *iterp;
    1:     if(!(CHECK_BIT_FLAG(jsdval->flags, GOT_PROPS)))
    1:     {
    1:         JS_ASSERT(!jsdprop);
    1:         if(!_buildProps(jsdc, jsdval))
    1:             return NULL;
    1:     }
    1: 
    1:     if(!jsdprop)
    1:         jsdprop = (JSDProperty*)jsdval->props.next;
    1:     if(jsdprop == (JSDProperty*)&jsdval->props)
    1:         return NULL;
    1:     *iterp = (JSDProperty*)jsdprop->links.next;
    1: 
    1:     JS_ASSERT(jsdprop);
    1:     jsdprop->nref++;
    1:     return jsdprop;
    1: }
    1: 
    1: JSDProperty*
    1: jsd_GetValueProperty(JSDContext* jsdc, JSDValue* jsdval, JSString* name)
    1: {
    1:     JSContext* cx = jsdc->dumbContext;
    1:     JSDProperty* jsdprop;
    1:     JSDProperty* iter = NULL;
    1:     JSObject* obj;
    1:     uintN  attrs = 0;
    1:     JSBool found;
    1:     JSPropertyDesc pd;
    1:     const jschar * nameChars;
    1:     size_t nameLen;
48470:     jsval val, nameval;
48470:     jsid nameid;
54754:     JSCrossCompartmentCall *call = NULL;
    1: 
    1:     if(!jsd_IsValueObject(jsdc, jsdval))
    1:         return NULL;
    1: 
    1:     /* If we already have the prop, then return it */
    1:     while(NULL != (jsdprop = jsd_IterateProperties(jsdc, jsdval, &iter)))
    1:     {
    1:         JSString* propName = jsd_GetValueString(jsdc, jsdprop->name);
59889:         if(propName) {
59889:             intN result;
59889:             if (JS_CompareStrings(cx, propName, name, &result) && !result)
    1:                 return jsdprop;
59889:         }
    1:         JSD_DropProperty(jsdc, jsdprop);
    1:     }
    1:     /* Not found in property list, look it up explicitly */
    1: 
    1:     if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
    1:         return NULL;
    1: 
59889:     if (!(nameChars = JS_GetStringCharsZAndLength(cx, name, &nameLen)))
59889:         return NULL;
    1: 
    1:     JS_BeginRequest(cx);
56450:     call = JS_EnterCrossCompartmentCall(cx, obj);
54754:     if(!call) {
54754:         JS_EndRequest(cx);
54754: 
54754:         return NULL;
54754:     }
    1: 
    1:     JS_GetUCPropertyAttributes(cx, obj, nameChars, nameLen, &attrs, &found);
    1:     if (!found)
    1:     {
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         JS_EndRequest(cx);
    1:         return NULL;
    1:     }
    1: 
    1:     JS_ClearPendingException(cx);
    1: 
    1:     if(!JS_GetUCProperty(cx, obj, nameChars, nameLen, &val))
    1:     {
    1:         if (JS_IsExceptionPending(cx))
    1:         {
    1:             if (!JS_GetPendingException(cx, &pd.value))
    1:             {
54754:                 JS_LeaveCrossCompartmentCall(call);
    1:                 JS_EndRequest(cx);
    1:                 return NULL;
    1:             }
    1:             pd.flags = JSPD_EXCEPTION;
    1:         }
    1:         else
    1:         {
    1:             pd.flags = JSPD_ERROR;
    1:             pd.value = JSVAL_VOID;
    1:         }
    1:     }
    1:     else
    1:     {
    1:         pd.value = val;
    1:     }
    1: 
54754:     JS_LeaveCrossCompartmentCall(call);
    1:     JS_EndRequest(cx);
    1: 
48470:     nameval = STRING_TO_JSVAL(name);
48470:     if (!JS_ValueToId(cx, nameval, &nameid) ||
48470:         !JS_IdToValue(cx, nameid, &pd.id)) {
48470:         return NULL;
48470:     }
48470: 
48470:     pd.slot = pd.spare = 0;
48470:     pd.alias = JSVAL_NULL;
    1:     pd.flags |= (attrs & JSPROP_ENUMERATE) ? JSPD_ENUMERATE : 0
    1:         | (attrs & JSPROP_READONLY)  ? JSPD_READONLY  : 0
    1:         | (attrs & JSPROP_PERMANENT) ? JSPD_PERMANENT : 0;
    1: 
    1:     return _newProperty(jsdc, &pd, JSDPD_HINTED);
    1: }
    1: 
60563: /*
60563:  * Retrieve a JSFunction* from a JSDValue*. This differs from
60563:  * JS_ValueToFunction by fully unwrapping the object first.
60563:  */
60563: JSFunction*
60563: jsd_GetValueFunction(JSDContext* jsdc, JSDValue* jsdval)
60563: {
60563:     JSObject *obj;
60563:     JSFunction *fun;
60563:     JSCrossCompartmentCall *call = NULL;
60563:     if (!JSVAL_IS_OBJECT(jsdval->val))
60563:         return NULL;
60563:     if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
60563:         return NULL;
67915:     obj = JS_UnwrapObject(obj);
60563: 
60563:     call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, obj);
60563:     if (!call)
60563:         return NULL;
60563:     fun = JS_ValueToFunction(jsdc->dumbContext, OBJECT_TO_JSVAL(obj));
60563:     JS_LeaveCrossCompartmentCall(call);
60563: 
60563:     return fun;
60563: }
    1: 
    1: JSDValue*
    1: jsd_GetValuePrototype(JSDContext* jsdc, JSDValue* jsdval)
    1: {
54754:     JSCrossCompartmentCall *call = NULL;
54754: 
    1:     if(!(CHECK_BIT_FLAG(jsdval->flags, GOT_PROTO)))
    1:     {
    1:         JSObject* obj;
    1:         JSObject* proto;
    1:         JS_ASSERT(!jsdval->proto);
    1:         SET_BIT_FLAG(jsdval->flags, GOT_PROTO);
    1:         if(!JSVAL_IS_OBJECT(jsdval->val))
    1:             return NULL;
    1:         if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
    1:             return NULL;
    1:         JS_BeginRequest(jsdc->dumbContext);
56450:         call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, obj);
54754:         if(!call) {
54754:             JS_EndRequest(jsdc->dumbContext);
54754: 
54754:             return NULL;
54754:         }
    1:         proto = JS_GetPrototype(jsdc->dumbContext, obj);
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         JS_EndRequest(jsdc->dumbContext);
    1:         if(!proto)
    1:             return NULL;
    1:         jsdval->proto = jsd_NewValue(jsdc, OBJECT_TO_JSVAL(proto));
    1:     }
    1:     if(jsdval->proto)
    1:         jsdval->proto->nref++;
    1:     return jsdval->proto;
    1: }
    1: 
    1: JSDValue*
    1: jsd_GetValueParent(JSDContext* jsdc, JSDValue* jsdval)
    1: {
54754:     JSCrossCompartmentCall *call = NULL;
54754: 
    1:     if(!(CHECK_BIT_FLAG(jsdval->flags, GOT_PARENT)))
    1:     {
    1:         JSObject* obj;
    1:         JSObject* parent;
    1:         JS_ASSERT(!jsdval->parent);
    1:         SET_BIT_FLAG(jsdval->flags, GOT_PARENT);
    1:         if(!JSVAL_IS_OBJECT(jsdval->val))
    1:             return NULL;
    1:         if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
    1:             return NULL;
    1:         JS_BeginRequest(jsdc->dumbContext);
55815:         call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, obj);
54754:         if(!call) {
54754:             JS_EndRequest(jsdc->dumbContext);
54754: 
54754:             return NULL;
54754:         }
83331:         parent = JS_GetParentOrScopeChain(jsdc->dumbContext,obj);
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         JS_EndRequest(jsdc->dumbContext);
    1:         if(!parent)
    1:             return NULL;
    1:         jsdval->parent = jsd_NewValue(jsdc, OBJECT_TO_JSVAL(parent));
    1:     }
    1:     if(jsdval->parent)
    1:         jsdval->parent->nref++;
    1:     return jsdval->parent;
    1: }
    1: 
    1: JSDValue*
    1: jsd_GetValueConstructor(JSDContext* jsdc, JSDValue* jsdval)
    1: {
54754:     JSCrossCompartmentCall *call = NULL;
54754: 
    1:     if(!(CHECK_BIT_FLAG(jsdval->flags, GOT_CTOR)))
    1:     {
    1:         JSObject* obj;
    1:         JSObject* proto;
    1:         JSObject* ctor;
    1:         JS_ASSERT(!jsdval->ctor);
    1:         SET_BIT_FLAG(jsdval->flags, GOT_CTOR);
    1:         if(!JSVAL_IS_OBJECT(jsdval->val))
    1:             return NULL;
    1:         if(!(obj = JSVAL_TO_OBJECT(jsdval->val)))
    1:             return NULL;
    1:         JS_BeginRequest(jsdc->dumbContext);
56450:         call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, obj);
54754:         if(!call) {
54754:             JS_EndRequest(jsdc->dumbContext);
54754: 
54754:             return NULL;
54754:         }
    1:         proto = JS_GetPrototype(jsdc->dumbContext,obj);
    1:         if(!proto)
    1:         {
54754:             JS_LeaveCrossCompartmentCall(call);
    1:             JS_EndRequest(jsdc->dumbContext);
    1:             return NULL;
    1:         }
    1:         ctor = JS_GetConstructor(jsdc->dumbContext,proto);
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         JS_EndRequest(jsdc->dumbContext);
    1:         if(!ctor)
    1:             return NULL;
    1:         jsdval->ctor = jsd_NewValue(jsdc, OBJECT_TO_JSVAL(ctor));
    1:     }
    1:     if(jsdval->ctor)
    1:         jsdval->ctor->nref++;
    1:     return jsdval->ctor;
    1: }
    1: 
    1: const char*
    1: jsd_GetValueClassName(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     jsval val = jsdval->val;
54754:     JSCrossCompartmentCall *call = NULL;
54754: 
    1:     if(!jsdval->className && JSVAL_IS_OBJECT(val))
    1:     {
    1:         JSObject* obj;
    1:         if(!(obj = JSVAL_TO_OBJECT(val)))
    1:             return NULL;
    1:         JS_BeginRequest(jsdc->dumbContext);
56450:         call = JS_EnterCrossCompartmentCall(jsdc->dumbContext, obj);
54754:         if(!call) {
54754:             JS_EndRequest(jsdc->dumbContext);
54754: 
54754:             return NULL;
54754:         }
    1:         if(JS_GET_CLASS(jsdc->dumbContext, obj))
    1:             jsdval->className = JS_GET_CLASS(jsdc->dumbContext, obj)->name;
54754:         JS_LeaveCrossCompartmentCall(call);
    1:         JS_EndRequest(jsdc->dumbContext);
    1:     }
    1:     return jsdval->className;
    1: }
    1: 
33644: JSDScript*
33644: jsd_GetScriptForValue(JSDContext* jsdc, JSDValue* jsdval)
33644: {
33644:     JSContext* cx = jsdc->dumbContext;
33644:     jsval val = jsdval->val;
54754:     JSFunction* fun = NULL;
33644:     JSExceptionState* exceptionState;
33644:     JSScript* script = NULL;
33644:     JSDScript* jsdscript;
54754:     JSCrossCompartmentCall *call = NULL;
33644: 
33644:     if (!jsd_IsValueFunction(jsdc, jsdval))
33644:         return NULL;
33644: 
33644:     JS_BeginRequest(cx);
54754:     call = JS_EnterCrossCompartmentCall(cx, JSVAL_TO_OBJECT(val));
54754:     if (!call) {
54754:         JS_EndRequest(cx);
54754: 
54754:         return NULL;
54754:     }
56784: 
33644:     exceptionState = JS_SaveExceptionState(cx);
60563:     fun = JSD_GetValueFunction(jsdc, jsdval);
33644:     JS_RestoreExceptionState(cx, exceptionState);
33644:     if (fun)
33644:         script = JS_GetFunctionScript(cx, fun);
54754:     JS_LeaveCrossCompartmentCall(call);
33644:     JS_EndRequest(cx);
33644: 
33644:     if (!script)
33644:         return NULL;
33644: 
33644:     JSD_LOCK_SCRIPTS(jsdc);
33644:     jsdscript = jsd_FindJSDScript(jsdc, script);
33644:     JSD_UNLOCK_SCRIPTS(jsdc);
33644:     return jsdscript;
33644: }
33644: 
33644: 
    1: /***************************************************************************/
    1: /***************************************************************************/
    1: 
    1: JSDValue*
    1: jsd_GetPropertyName(JSDContext* jsdc, JSDProperty* jsdprop)
    1: {
    1:     jsdprop->name->nref++;
    1:     return jsdprop->name;
    1: }
    1: 
    1: JSDValue*
    1: jsd_GetPropertyValue(JSDContext* jsdc, JSDProperty* jsdprop)
    1: {
    1:     jsdprop->val->nref++;
    1:     return jsdprop->val;
    1: }
    1: 
    1: JSDValue*
    1: jsd_GetPropertyAlias(JSDContext* jsdc, JSDProperty* jsdprop)
    1: {
    1:     if(jsdprop->alias)
    1:         jsdprop->alias->nref++;
    1:     return jsdprop->alias;
    1: }
    1: 
    1: uintN
    1: jsd_GetPropertyFlags(JSDContext* jsdc, JSDProperty* jsdprop)
    1: {
    1:     return jsdprop->flags;
    1: }
    1: 
    1: uintN
    1: jsd_GetPropertyVarArgSlot(JSDContext* jsdc, JSDProperty* jsdprop)
    1: {
    1:     return jsdprop->slot;
    1: }
    1: 
    1: void
    1: jsd_DropProperty(JSDContext* jsdc, JSDProperty* jsdprop)
    1: {
    1:     JS_ASSERT(jsdprop->nref > 0);
    1:     if(0 == --jsdprop->nref)
    1:     {
    1:         JS_ASSERT(JS_CLIST_IS_EMPTY(&jsdprop->links));
    1:         DROP_CLEAR_VALUE(jsdc, jsdprop->val);
    1:         DROP_CLEAR_VALUE(jsdc, jsdprop->name);
    1:         DROP_CLEAR_VALUE(jsdc, jsdprop->alias);
    1:         free(jsdprop);
    1:     }
    1: }
