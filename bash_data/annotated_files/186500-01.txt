     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim:set ts=2 sts=2 sw=2 et cin: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 29835: /*
 29841:  * nsWindow - Native window management and event handling.
 29841:  * 
 29835:  * nsWindow is organized into a set of major blocks and
 29835:  * block subsections. The layout is as follows:
 29835:  *
 29835:  *  Includes
 29835:  *  Variables
 29835:  *  nsIWidget impl.
 29835:  *     nsIWidget methods and utilities
 29835:  *  nsSwitchToUIThread impl.
 29835:  *     nsSwitchToUIThread methods and utilities
 29835:  *  Moz events
 29835:  *     Event initialization
 29835:  *     Event dispatching
 29835:  *  Native events
 29835:  *     Wndproc(s)
 29835:  *     Event processing
 29835:  *     OnEvent event handlers
 29835:  *  IME management and accessibility
 29835:  *  Transparency
 29835:  *  Popup hook handling
 29835:  *  Misc. utilities
 29835:  *  Child window impl.
 29835:  *
 29835:  * Search for "BLOCK:" to find major blocks.
 29835:  * Search for "SECTION:" to find specific sections.
 29835:  *
 29835:  * Blocks should be split out into separate files if they
 29835:  * become unmanageable.
 29835:  *
 29835:  * Related source:
 29835:  *
 29835:  *  nsWindowDefs.h     - Definitions, macros, structs, enums
 29835:  *                       and general setup.
 29835:  *  nsWindowDbg.h/.cpp - Debug related code and directives.
 29835:  *  nsWindowGfx.h/.cpp - Graphics and painting.
 29835:  *
 29835:  */
 29835: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Includes
 29835:  **
 29835:  ** Include headers.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
134925: #include "mozilla/MathAlgorithms.h"
163419: #include "mozilla/MiscEvents.h"
163417: #include "mozilla/MouseEvents.h"
163416: #include "mozilla/TouchEvents.h"
134925: 
163890: #include "mozilla/ipc/MessageChannel.h"
129543: #include <algorithm>
 36056: 
     1: #include "nsWindow.h"
 29835: 
108835: #include <shellapi.h>
 29835: #include <windows.h>
 29835: #include <process.h>
 29835: #include <commctrl.h>
 29835: #include <unknwn.h>
 90802: #include <psapi.h>
 29835: 
 29835: #include "prlog.h"
 29835: #include "prtime.h"
 29835: #include "prprf.h"
 29835: #include "prmem.h"
157466: #include "prenv.h"
 29835: 
 68748: #include "mozilla/WidgetTraceEvent.h"
     1: #include "nsIAppShell.h"
 29835: #include "nsISupportsPrimitives.h"
 77227: #include "nsIDOMMouseEvent.h"
 29835: #include "nsITheme.h"
 29835: #include "nsIObserverService.h"
 29835: #include "nsIScreenManager.h"
 29835: #include "imgIContainer.h"
 29835: #include "nsIFile.h"
 29835: #include "nsIRollupListener.h"
 29835: #include "nsIServiceManager.h"
 29835: #include "nsIClipboard.h"
 29835: #include "nsIMM32Handler.h"
 91613: #include "WinMouseScrollHandler.h"
 68493: #include "nsFontMetrics.h"
     1: #include "nsIFontEnumerator.h"
     1: #include "nsFont.h"
     1: #include "nsRect.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsNativeCharsetUtils.h"
 80435: #include "nsGkAtoms.h"
 29835: #include "nsCRT.h"
 29835: #include "nsAppDirectoryServiceDefs.h"
 29835: #include "nsXPIDLString.h"
 29835: #include "nsWidgetsCID.h"
 30540: #include "nsTHashtable.h"
 30540: #include "nsHashKeys.h"
 32183: #include "nsString.h"
 41540: #include "mozilla/Services.h"
 49249: #include "nsNativeThemeWin.h"
 57388: #include "nsWindowsDllInterceptor.h"
149859: #include "nsLayoutUtils.h"
149859: #include "nsView.h"
 58814: #include "nsIWindowMediator.h"
 58814: #include "nsIServiceManager.h"
 29835: #include "nsWindowGfx.h"
 38727: #include "gfxWindowsPlatform.h"
 40028: #include "Layers.h"
 77158: #include "nsPrintfCString.h"
 70956: #include "mozilla/Preferences.h"
 78043: #include "nsISound.h"
 81361: #include "WinTaskbar.h"
 86569: #include "WinUtils.h"
 98715: #include "WidgetUtils.h"
108457: #include "nsIWidgetListener.h"
139549: #include "mozilla/dom/Touch.h"
158268: #include "mozilla/gfx/2D.h"
173674: #include "nsToolkitCompsCID.h"
173674: #include "nsIAppStartup.h"
172560: #include "mozilla/WindowsVersion.h"
 68855: 
 43174: #ifdef MOZ_ENABLE_D3D9_LAYER
 42612: #include "LayerManagerD3D9.h"
 43174: #endif
 68855: 
 54816: #ifdef MOZ_ENABLE_D3D10_LAYER
 54816: #include "LayerManagerD3D10.h"
 54816: #endif
 68855: 
 60833: #include "nsIGfxInfo.h"
 26576: #include "nsUXThemeConstants.h"
 48247: #include "KeyboardLayout.h"
 23335: #include "nsNativeDragTarget.h"
 29835: #include <mmsystem.h> // needed for WIN32_LEAN_AND_MEAN
 29835: #include <zmouse.h>
 31281: #include <richedit.h>
 29835: 
 29835: #if defined(ACCESSIBILITY)
152637: 
152637: #ifdef DEBUG
152637: #include "mozilla/a11y/Logging.h"
152637: #endif
152637: 
 31281: #include "oleidl.h"
  7756: #include <winuser.h>
102366: #include "nsAccessibilityService.h"
149859: #include "mozilla/a11y/DocAccessible.h"
124964: #include "mozilla/a11y/Platform.h"
 29835: #if !defined(WINABLEAPI)
  7756: #include <winable.h>
 29835: #endif // !defined(WINABLEAPI)
 29835: #endif // defined(ACCESSIBILITY)
 29835: 
 33486: #include "nsIWinTaskbar.h"
 77693: #define NS_TASKBAR_CONTRACTID "@mozilla.org/windows-taskbar;1"
 33486: 
 29835: #include "nsWindowDefs.h"
 29835: 
 62476: #include "nsCrashOnException.h"
 51658: #include "nsIXULRuntime.h"
 51658: 
 82052: #include "nsIContent.h"
 82052: 
119111: #include "mozilla/HangMonitor.h"
134054: #include "WinIMEHandler.h"
119111: 
166507: #include "npapi.h"
166507: 
173674: #if !defined(SM_CONVERTIBLESLATEMODE)
173674: #define SM_CONVERTIBLESLATEMODE 0x2003
173674: #endif
173674: 
139549: using namespace mozilla;
139549: using namespace mozilla::dom;
139549: using namespace mozilla::layers;
 48247: using namespace mozilla::widget;
 48247: 
 31122: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Variables
 29835:  **
 29835:  ** nsWindow Class static initializations and global variables. 
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsWindow statics
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: bool            nsWindow::sDropShadowEnabled      = true;
108991: uint32_t        nsWindow::sInstanceCount          = 0;
 79445: bool            nsWindow::sSwitchKeyboardLayout   = false;
  7271: BOOL            nsWindow::sIsOleInitialized       = FALSE;
164874: HCURSOR         nsWindow::sHCursor                = nullptr;
106838: imgIContainer*  nsWindow::sCursorImgContainer     = nullptr;
106838: nsWindow*       nsWindow::sCurrentWindow          = nullptr;
 79445: bool            nsWindow::sJustGotDeactivate      = false;
 79445: bool            nsWindow::sJustGotActivate        = false;
 79445: bool            nsWindow::sIsInMouseCapture       = false;
 29835: 
 29835: // imported in nsWidgetFactory.cpp
 29835: TriStateBool    nsWindow::sCanQuit                = TRI_UNKNOWN;
 29835: 
 29835: // Hook Data Memebers for Dropdowns. sProcessHook Tells the
 29835: // hook methods whether they should be processing the hook
 29835: // messages.
164874: HHOOK           nsWindow::sMsgFilterHook          = nullptr;
164874: HHOOK           nsWindow::sCallProcHook           = nullptr;
164874: HHOOK           nsWindow::sCallMouseHook          = nullptr;
 79445: bool            nsWindow::sProcessHook            = false;
 29835: UINT            nsWindow::sRollupMsgId            = 0;
164874: HWND            nsWindow::sRollupMsgWnd           = nullptr;
 29835: UINT            nsWindow::sHookTimerId            = 0;
 29835: 
 29835: // Mouse Clicks - static variable definitions for figuring
 29835: // out 1 - 3 Clicks.
 29835: POINT           nsWindow::sLastMousePoint         = {0};
 29835: POINT           nsWindow::sLastMouseMovePoint     = {0};
 29835: LONG            nsWindow::sLastMouseDownTime      = 0L;
 29835: LONG            nsWindow::sLastClickCount         = 0L;
 29835: BYTE            nsWindow::sLastMouseButton        = 0;
 29835: 
 29835: // Trim heap on minimize. (initialized, but still true.)
 29835: int             nsWindow::sTrimOnMinimize         = 2;
     1: 
 57092: // Default value for general window class (used when the pref is the empty string).
 57092: const char*     nsWindow::sDefaultMainWindowClass = kClassNameGeneral;
 57092: 
 58814: // If we're using D3D9, this will not be allowed during initial 5 seconds.
 58814: bool            nsWindow::sAllowD3D9              = false;
 33529: 
 63258: TriStateBool nsWindow::sHasBogusPopupsDropShadowOnMultiMonitor = TRI_UNKNOWN;
 63258: 
 37550: // Used in OOPP plugin focus processing.
174217: const wchar_t* kOOPPPluginFocusEventId   = L"OOPP Plugin Focus Widget Event";
108991: uint32_t        nsWindow::sOOPPPluginFocusEvent   =
 37550:                   RegisterWindowMessageW(kOOPPPluginFocusEventId);
 37550: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: globals variables
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: static const char *sScreenManagerContractID       = "@mozilla.org/gfx/screenmanager;1";
 29835: 
 29835: #ifdef PR_LOGGING
168666: extern PRLogModuleInfo* gWindowsLog;
     1: #endif
 29835: 
 29835: // Global used in Show window enumerations.
 79445: static bool     gWindowsVisible                   = false;
 29835: 
 82031: // True if we have sent a notification that we are suspending/sleeping.
 82031: static bool     gIsSleepMode                      = false;
 82031: 
 29835: static NS_DEFINE_CID(kCClipboardCID, NS_CLIPBOARD_CID);
 29835: 
 57388: // General purpose user32.dll hook object
 57388: static WindowsDllInterceptor sUser32Intercept;
 57388: 
 87238: // 2 pixel offset for eTransparencyBorderlessGlass which equals the size of
 87238: // the default window border Windows paints. Glass will be extended inward
 87238: // this distance to remove the border.
108991: static const int32_t kGlassMarginAdjustment = 2;
 61413: 
 87238: // When the client area is extended out into the default window frame area,
 87238: // this is the minimum amount of space along the edge of resizable windows
 87238: // we will always display a resize cursor in, regardless of the underlying
 87238: // content.
108991: static const int32_t kResizableBorderMinSize = 3;
 79695: 
 79695: // We should never really try to accelerate windows bigger than this. In some
 79695: // cases this might lead to no D3D9 acceleration where we could have had it
 79695: // but D3D9 does not reliably report when it supports bigger windows. 8192
 79695: // is as safe as we can get, we know at least D3D10 hardware always supports
 79695: // this, other hardware we expect to report correctly in D3D9.
 79695: #define MAX_ACCELERATED_DIMENSION 8192
 79695: 
153599: // On window open (as well as after), Windows has an unfortunate habit of
153599: // sending rather a lot of WM_NCHITTEST messages. Because we have to do point
153599: // to DOM target conversions for these, we cache responses for a given
153599: // coordinate this many milliseconds:
153599: #define HITTEST_CACHE_LIFETIME_MS 50
153599: 
 79695: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: nsIWidget impl.
 29835:  **
 29835:  ** nsIWidget interface implementation, broken down into
 29835:  ** sections.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsWindow construction and destruction
 29835:  *
 29835:  **************************************************************/
 29835: 
128620: nsWindow::nsWindow() : nsWindowBase()
 29835: {
106838:   mIconSmall            = nullptr;
106838:   mIconBig              = nullptr;
106838:   mWnd                  = nullptr;
106838:   mPaintDC              = nullptr;
158268:   mCompositeDC          = nullptr;
106838:   mPrevWndProc          = nullptr;
106838:   mNativeDragTarget     = nullptr;
 79626:   mInDtor               = false;
 79626:   mIsVisible            = false;
 79626:   mIsTopWidgetWindow    = false;
 79626:   mUnicodeWidget        = true;
 79626:   mDisplayPanFeedback   = false;
 79626:   mTouchWindow          = false;
 79626:   mCustomNonClient      = false;
 79626:   mHideChrome           = false;
 79626:   mFullscreenMode       = false;
 79626:   mMousePresent         = false;
 84178:   mDestroyCalled        = false;
183346:   mHasTaskbarIconBeenCreated = false;
183346:   mMouseTransparent     = false;
 84178:   mPickerDisplayCount   = 0;
 29835:   mWindowType           = eWindowType_child;
 29835:   mBorderStyle          = eBorderStyle_default;
 46335:   mOldSizeMode          = nsSizeMode_Normal;
 97778:   mLastSizeMode         = nsSizeMode_Normal;
     1:   mLastSize.width       = 0;
     1:   mLastSize.height      = 0;
     1:   mOldStyle             = 0;
     1:   mOldExStyle           = 0;
     1:   mPainting             = 0;
 29835:   mLastKeyboardLayout   = 0;
120269:   mBlurSuppressLevel    = 0;
 89510:   mLastPaintEndTime     = TimeStamp::Now();
153599:   mCachedHitTestPoint.x = 0;
153599:   mCachedHitTestPoint.y = 0;
153599:   mCachedHitTestTime    = TimeStamp::Now();
153599:   mCachedHitTestResult  = 0;
 29835: #ifdef MOZ_XUL
106838:   mTransparentSurface   = nullptr;
106838:   mMemoryDC             = nullptr;
 29835:   mTransparencyMode     = eTransparencyOpaque;
 39718:   memset(&mGlassMargins, 0, sizeof mGlassMargins);
 29835: #endif
 29835:   mBackground           = ::GetSysColor(COLOR_BTNFACE);
 29835:   mBrush                = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
 29835:   mForeground           = ::GetSysColor(COLOR_WINDOWTEXT);
 29835: 
106838:   mTaskbarPreview = nullptr;
 33486: 
 29835:   // Global initialization
 29835:   if (!sInstanceCount) {
 81361:     // Global app registration id for Win7 and up. See
 81361:     // WinTaskbar.cpp for details.
 81361:     mozilla::widget::WinTaskbar::RegisterAppUserModelID();
145592:     KeyboardLayout::GetInstance()->OnLayoutChange(::GetKeyboardLayout(0));
134054:     IMEHandler::Initialize();
164874:     if (SUCCEEDED(::OleInitialize(nullptr))) {
  7271:       sIsOleInitialized = TRUE;
 91613:     }
  7271:     NS_ASSERTION(sIsOleInitialized, "***** OLE is not initialized!\n");
 91613:     MouseScrollHandler::Initialize();
 49249:     // Init titlebar button info for custom frames.
 49249:     nsUXThemeData::InitTitlebarInfo();
 55268:     // Init theme data
 55268:     nsUXThemeData::UpdateNativeThemeInfo();
145607:     RedirectedKeyDownMessageManager::Forget();
 29835:   } // !sInstanceCount
 29835: 
106838:   mIdleService = nullptr;
 27326: 
     1:   sInstanceCount++;
 23335: }
 23335: 
     1: nsWindow::~nsWindow()
     1: {
 79626:   mInDtor = true;
 30223: 
 30223:   // If the widget was released without calling Destroy() then the native window still
 30223:   // exists, and we need to destroy it. This will also result in a call to OnDestroy.
 30223:   //
 30223:   // XXX How could this happen???
164874:   if (nullptr != mWnd)
     1:     Destroy();
     1: 
103754:   // Free app icon resources.  This must happen after `OnDestroy` (see bug 708033).
103754:   if (mIconSmall)
103754:     ::DestroyIcon(mIconSmall);
103754: 
103754:   if (mIconBig)
103754:     ::DestroyIcon(mIconBig);
103754: 
 24836:   sInstanceCount--;
 24836: 
 29835:   // Global shutdown
 29841:   if (sInstanceCount == 0) {
134054:     IMEHandler::Terminate();
 29835:     NS_IF_RELEASE(sCursorImgContainer);
  7271:     if (sIsOleInitialized) {
  7968:       ::OleFlushClipboard();
  7271:       ::OleUninitialize();
  7271:       sIsOleInitialized = FALSE;
  7271:     }
 68855:   }
 68855: 
     1:   NS_IF_RELEASE(mNativeDragTarget);
 29835: }
 29835: 
 29835: NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::Create, nsIWidget::Destroy
 29835:  *
 29835:  * Creating and destroying windows for this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 33013: // Allow Derived classes to modify the height that is passed
 68855: // when the window is created or resized.
108991: int32_t nsWindow::GetHeight(int32_t aProposedHeight)
 33013: {
 68855:   return aProposedHeight;
 33013: }
 33013: 
 29835: // Create the proper widget
 33013: nsresult
 33013: nsWindow::Create(nsIWidget *aParent,
 33013:                  nsNativeWidget aNativeParent,
 29835:                  const nsIntRect &aRect,
 68668:                  nsDeviceContext *aContext,
 29835:                  nsWidgetInitData *aInitData)
 29835: {
 51041:   nsWidgetInitData defaultInitData;
 51041:   if (!aInitData)
 51041:     aInitData = &defaultInitData;
 51041: 
 29835:   mUnicodeWidget = aInitData->mUnicode;
 33013: 
 51041:   nsIWidget *baseParent = aInitData->mWindowType == eWindowType_dialog ||
     1:                           aInitData->mWindowType == eWindowType_toplevel ||
 51041:                           aInitData->mWindowType == eWindowType_invisible ?
106838:                           nullptr : aParent;
106838: 
106838:   mIsTopWidgetWindow = (nullptr == baseParent);
 55224:   mBounds = aRect;
     1: 
 80842:   // Ensure that the toolkit is created.
 80842:   nsToolkit::GetToolkit();
 80842: 
108460:   BaseCreate(baseParent, aRect, aContext, aInitData);
     1: 
     1:   HWND parent;
 43018:   if (aParent) { // has a nsIWidget parent
164874:     parent = aParent ? (HWND)aParent->GetNativeData(NS_NATIVE_WINDOW) : nullptr;
 43018:     mParent = aParent;
     1:   } else { // has a nsNative parent
     1:     parent = (HWND)aNativeParent;
 86569:     mParent = aNativeParent ?
106838:       WinUtils::GetNSWindowPtr((HWND)aNativeParent) : nullptr;
     1:   }
     1: 
 51919:   mIsRTL = aInitData->mRTL;
     1: 
     1:   DWORD style = WindowStyle();
     1:   DWORD extendedStyle = WindowExStyle();
     1: 
     1:   if (mWindowType == eWindowType_popup) {
116459:     if (!aParent) {
164874:       parent = nullptr;
116459:     }
116459: 
172560:     if (IsVistaOrLater() && !IsWin8OrLater()) {
116459:       extendedStyle |= WS_EX_COMPOSITED;
116459:     }
 77050: 
183346:     if (aInitData->mMouseTransparent) {
 77050:       // This flag makes the window transparent to mouse events
183346:       mMouseTransparent = true;
 77050:       extendedStyle |= WS_EX_TRANSPARENT;
 77050:     }
 31952:   } else if (mWindowType == eWindowType_invisible) {
 31952:     // Make sure CreateWindowEx succeeds at creating a toplevel window
 31960:     style &= ~0x40000000; // WS_CHILDWINDOW
 51041:   } else {
     1:     // See if the caller wants to explictly set clip children and clip siblings
     1:     if (aInitData->clipChildren) {
     1:       style |= WS_CLIPCHILDREN;
     1:     } else {
     1:       style &= ~WS_CLIPCHILDREN;
     1:     }
     1:     if (aInitData->clipSiblings) {
     1:       style |= WS_CLIPSIBLINGS;
     1:     }
     1:   }
     1: 
 57092:   nsAutoString className;
 57092:   if (aInitData->mDropShadow) {
 57092:     GetWindowPopupClass(className);
 57092:   } else {
 57092:     GetWindowClass(className);
 57092:   }
 77660:   // Plugins are created in the disabled state so that they can't
 77660:   // steal focus away from our main window.  This is especially
 77660:   // important if the plugin has loaded in a background tab.
 77660:   if(aInitData->mWindowType == eWindowType_plugin) {
 77660:     style |= WS_DISABLED;
 77660:   }
     1:   mWnd = ::CreateWindowExW(extendedStyle,
 57092:                            className.get(),
     1:                            L"",
     1:                            style,
     1:                            aRect.x,
     1:                            aRect.y,
     1:                            aRect.width,
     1:                            GetHeight(aRect.height),
     1:                            parent,
164874:                            nullptr,
     1:                            nsToolkit::mDllInstance,
164874:                            nullptr);
     1: 
 46192:   if (!mWnd) {
 46192:     NS_WARNING("nsWindow CreateWindowEx failed.");
     1:     return NS_ERROR_FAILURE;
 46192:   }
     1: 
156534:   if (mIsRTL && WinUtils::dwmSetWindowAttributePtr) {
 52118:     DWORD dwAttribute = TRUE;    
156534:     WinUtils::dwmSetWindowAttributePtr(mWnd, DWMWA_NONCLIENT_RTL_LAYOUT, &dwAttribute, sizeof dwAttribute);
 52118:   }
 52118: 
 91763:   if (mWindowType != eWindowType_plugin &&
 91763:       mWindowType != eWindowType_invisible &&
 91617:       MouseScrollHandler::Device::IsFakeScrollableWindowNeeded()) {
 91763:     // Ugly Thinkpad Driver Hack (Bugs 507222 and 594977)
 59750:     //
 91763:     // We create two zero-sized windows as descendants of the top-level window,
 91763:     // like so:
 59750:     //
 59750:     //   Top-level window (MozillaWindowClass)
 59750:     //     FAKETRACKPOINTSCROLLCONTAINER (MozillaWindowClass)
 59750:     //       FAKETRACKPOINTSCROLLABLE (MozillaWindowClass)
 59750:     //
 91763:     // We need to have the middle window, otherwise the Trackpoint driver
 59750:     // will fail to deliver scroll messages.  WM_MOUSEWHEEL messages are
 59750:     // sent to the FAKETRACKPOINTSCROLLABLE, which then propagate up the
 59750:     // window hierarchy until they are handled by nsWindow::WindowProc.
 59750:     // WM_HSCROLL messages are also sent to the FAKETRACKPOINTSCROLLABLE,
 59750:     // but these do not propagate automatically, so we have the window
 59750:     // procedure pretend that they were dispatched to the top-level window
 59750:     // instead.
 59750:     //
 59750:     // The FAKETRACKPOINTSCROLLABLE needs to have the specific window styles it
 59750:     // is given below so that it catches the Trackpoint driver's heuristics.
 59750:     HWND scrollContainerWnd = ::CreateWindowW
 59750:       (className.get(), L"FAKETRACKPOINTSCROLLCONTAINER",
 59750:        WS_CHILD | WS_VISIBLE,
164874:        0, 0, 0, 0, mWnd, nullptr, nsToolkit::mDllInstance, nullptr);
 59750:     HWND scrollableWnd = ::CreateWindowW
 59750:       (className.get(), L"FAKETRACKPOINTSCROLLABLE",
 59750:        WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP | 0x30,
164874:        0, 0, 0, 0, scrollContainerWnd, nullptr, nsToolkit::mDllInstance,
164874:        nullptr);
 59750: 
 59750:     // Give the FAKETRACKPOINTSCROLLABLE window a specific ID so that
 59750:     // WindowProcInternal can distinguish it from the top-level window
 59750:     // easily.
 59750:     ::SetWindowLongPtrW(scrollableWnd, GWLP_ID, eFakeTrackPointScrollableID);
 59750: 
 59750:     // Make FAKETRACKPOINTSCROLLABLE use nsWindow::WindowProc, and store the
 59750:     // old window procedure in its "user data".
 59750:     WNDPROC oldWndProc;
 59750:     if (mUnicodeWidget)
 59750:       oldWndProc = (WNDPROC)::SetWindowLongPtrW(scrollableWnd, GWLP_WNDPROC,
 59750:                                                 (LONG_PTR)nsWindow::WindowProc);
 59750:     else
 59750:       oldWndProc = (WNDPROC)::SetWindowLongPtrA(scrollableWnd, GWLP_WNDPROC,
 59750:                                                 (LONG_PTR)nsWindow::WindowProc);
 59750:     ::SetWindowLongPtrW(scrollableWnd, GWLP_USERDATA, (LONG_PTR)oldWndProc);
 33357:   }
 32183: 
     1:   SubclassWindow(TRUE);
     1: 
134065:   IMEHandler::InitInputContext(this, mInputContext);
120230: 
 70972:   // If the internal variable set by the config.trim_on_minimize pref has not
 70972:   // been initialized, and if this is the hidden window (conveniently created
 70972:   // before any visible windows, and after the profile has been initialized),
 70972:   // do some initialization work.
 29835:   if (sTrimOnMinimize == 2 && mWindowType == eWindowType_invisible) {
 70972:     // Our internal trim prevention logic is effective on 2K/XP at maintaining
 70972:     // the working set when windows are minimized, but on Vista and up it has
 70972:     // little to no effect. Since this feature has been the source of numerous
 70972:     // bugs over the years, disable it (sTrimOnMinimize=1) on Vista and up.
 70956:     sTrimOnMinimize =
 70972:       Preferences::GetBool("config.trim_on_minimize",
172560:         IsVistaOrLater() ? 1 : 0);
 70956:     sSwitchKeyboardLayout =
 79445:       Preferences::GetBool("intl.keyboard.per_window_layout", false);
     1:   }
     1: 
149981:   // Query for command button metric data for rendering the titlebar. We
149981:   // only do this once on the first window.
150730:   if (mWindowType == eWindowType_toplevel &&
150730:       (!nsUXThemeData::sTitlebarInfoPopulatedThemed ||
150730:        !nsUXThemeData::sTitlebarInfoPopulatedAero)) {
149981:     nsUXThemeData::UpdateTitlebarInfo(mWnd);
149981:   }
     1:   return NS_OK;
     1: }
     1: 
 30223: // Close this nsWindow
 30223: NS_METHOD nsWindow::Destroy()
 30223: {
 77212:   // WM_DESTROY has already fired, avoid calling it twice
 77212:   if (mOnDestroyCalled)
 30223:     return NS_OK;
 30223: 
 84178:   // Don't destroy windows that have file pickers open, we'll tear these down
 84178:   // later once the picker is closed.
 84178:   mDestroyCalled = true;
 84178:   if (mPickerDisplayCount)
 84178:     return NS_OK;
 84178: 
 30223:   // During the destruction of all of our children, make sure we don't get deleted.
 30223:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 30223: 
 40028:   /**
 40028:    * On windows the LayerManagerOGL destructor wants the widget to be around for
164874:    * cleanup. It also would like to have the HWND intact, so we nullptr it here.
 40028:    */
 49074:   if (mLayerManager) {
 49074:     mLayerManager->Destroy();
 49074:   }
106838:   mLayerManager = nullptr;
 40028: 
 51000:   /* We should clear our cached resources now and not wait for the GC to
 50777:    * delete the nsWindow. */
 51000:   ClearCachedResources();
 50777: 
 30223:   // The DestroyWindow function destroys the specified window. The function sends WM_DESTROY
 30223:   // and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus
 30223:   // from it. The function also destroys the window's menu, flushes the thread message queue,
 30223:   // destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if
 30223:   // the window is at the top of the viewer chain).
 30223:   //
 30223:   // If the specified window is a parent or owner window, DestroyWindow automatically destroys
 30223:   // the associated child or owned windows when it destroys the parent or owner window. The
 30223:   // function first destroys child or owned windows, and then it destroys the parent or owner
 30223:   // window.
 30223:   VERIFY(::DestroyWindow(mWnd));
 30223:   
 30223:   // Our windows can be subclassed which may prevent us receiving WM_DESTROY. If OnDestroy()
 30223:   // didn't get called, call it now.
 79626:   if (false == mOnDestroyCalled) {
152199:     MSGResult msgResult;
152199:     mWindowHook.Notify(mWnd, WM_DESTROY, 0, 0, msgResult);
 30223:     OnDestroy();
 58032:   }
 30223: 
 30223:   return NS_OK;
 30223: }
 30223: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window class utilities
 29835:  *
 29835:  * Utilities for calculating the proper window class name for
 29835:  * Create window.
 29835:  *
 29835:  **************************************************************/
 29835: 
 57092: void nsWindow::RegisterWindowClass(const nsString& aClassName, UINT aExtraStyle,
 57092:                                    LPWSTR aIconID)
 57092: {
 29835:   WNDCLASSW wc;
 57092:   if (::GetClassInfoW(nsToolkit::mDllInstance, aClassName.get(), &wc)) {
 57092:     // already registered
 57092:     return;
 57092:   }
 57092: 
 57092:   wc.style         = CS_DBLCLKS | aExtraStyle;
 29835:   wc.lpfnWndProc   = ::DefWindowProcW;
 29835:   wc.cbClsExtra    = 0;
 29835:   wc.cbWndExtra    = 0;
 29835:   wc.hInstance     = nsToolkit::mDllInstance;
164874:   wc.hIcon         = aIconID ? ::LoadIconW(::GetModuleHandleW(nullptr), aIconID) : nullptr;
164874:   wc.hCursor       = nullptr;
 29835:   wc.hbrBackground = mBrush;
164874:   wc.lpszMenuName  = nullptr;
 57092:   wc.lpszClassName = aClassName.get();
 57092: 
 57092:   if (!::RegisterClassW(&wc)) {
 57092:     // For older versions of Win32 (i.e., not XP), the registration may
 57092:     // fail with aExtraStyle, so we have to re-register without it.
 57092:     wc.style = CS_DBLCLKS;
 57092:     ::RegisterClassW(&wc);
 57092:   }
 57092: }
 57092: 
 57103: static LPWSTR const gStockApplicationIcon = MAKEINTRESOURCEW(32512);
 57103: 
 57092: // Return the proper window class for everything except popups.
 57092: void nsWindow::GetWindowClass(nsString& aWindowClass)
 57092: {
 57092:   switch (mWindowType) {
 57092:   case eWindowType_invisible:
 57092:     aWindowClass.AssignLiteral(kClassNameHidden);
 57103:     RegisterWindowClass(aWindowClass, 0, gStockApplicationIcon);
 57092:     break;
 57092:   case eWindowType_dialog:
 57092:     aWindowClass.AssignLiteral(kClassNameDialog);
 57092:     RegisterWindowClass(aWindowClass, 0, 0);
 57092:     break;
 57092:   default:
 57092:     GetMainWindowClass(aWindowClass);
 57103:     RegisterWindowClass(aWindowClass, 0, gStockApplicationIcon);
 57092:     break;
 57092:   }
 29835: }
 29835: 
 29835: // Return the proper popup window class
 57092: void nsWindow::GetWindowPopupClass(nsString& aWindowClass)
 57092: {
 57092:   aWindowClass.AssignLiteral(kClassNameDropShadow);
 57103:   RegisterWindowClass(aWindowClass, CS_XP_DROPSHADOW, gStockApplicationIcon);
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window styles utilities
 29835:  *
 29835:  * Return the proper windows styles and extended styles.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Return nsWindow styles
 29835: DWORD nsWindow::WindowStyle()
 29835: {
 29835:   DWORD style;
 29835: 
 29835:   switch (mWindowType) {
 33357:     case eWindowType_plugin:
 29835:     case eWindowType_child:
 29835:       style = WS_OVERLAPPED;
 29835:       break;
 29835: 
 29835:     case eWindowType_dialog:
 46264:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU | DS_3DLOOK |
 46264:               DS_MODALFRAME | WS_CLIPCHILDREN;
 29835:       if (mBorderStyle != eBorderStyle_default)
 29835:         style |= WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
 29835:       break;
 29835: 
 29835:     case eWindowType_popup:
 29835:       style = WS_POPUP;
 50770:       if (!HasGlass()) {
 29835:         style |= WS_OVERLAPPED;
 29835:       }
 29835:       break;
 29835: 
 29835:     default:
 31561:       NS_ERROR("unknown border style");
 29835:       // fall through
 29835: 
 29835:     case eWindowType_toplevel:
 29835:     case eWindowType_invisible:
 29835:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU |
 46264:               WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CLIPCHILDREN;
 29835:       break;
 29835:   }
 29835: 
 31589:   if (mBorderStyle != eBorderStyle_default && mBorderStyle != eBorderStyle_all) {
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_border))
 31589:       style &= ~WS_BORDER;
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_title)) {
 31589:       style &= ~WS_DLGFRAME;
 31589:       style |= WS_POPUP;
 31589:       style &= ~WS_CHILD;
 31589:     }
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_close))
 31589:       style &= ~0;
 31589:     // XXX The close box can only be removed by changing the window class,
 31589:     // as far as I know   --- roc+moz@cs.cmu.edu
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none ||
 31589:       !(mBorderStyle & (eBorderStyle_menu | eBorderStyle_close)))
 31589:       style &= ~WS_SYSMENU;
 31589:     // Looks like getting rid of the system menu also does away with the
 31589:     // close box. So, we only get rid of the system menu if you want neither it
 31589:     // nor the close box. How does the Windows "Dialog" window class get just
 31589:     // closebox and no sysmenu? Who knows.
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_resizeh))
 31589:       style &= ~WS_THICKFRAME;
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_minimize))
 31589:       style &= ~WS_MINIMIZEBOX;
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_maximize))
 31589:       style &= ~WS_MAXIMIZEBOX;
 48256: 
 48256:     if (IsPopupWithTitleBar()) {
 48256:       style |= WS_CAPTION;
 48261:       if (mBorderStyle & eBorderStyle_close) {
 48261:         style |= WS_SYSMENU;
 48261:       }
 48256:     }
 48256:   }
 48256: 
 29835:   VERIFY_WINDOW_STYLE(style);
 29835:   return style;
 29835: }
 29835: 
 29835: // Return nsWindow extended styles
 29835: DWORD nsWindow::WindowExStyle()
 29835: {
 29835:   switch (mWindowType)
 29835:   {
 33357:     case eWindowType_plugin:
 29835:     case eWindowType_child:
 29835:       return 0;
 29835: 
 29835:     case eWindowType_dialog:
 29835:       return WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME;
 29835: 
 29835:     case eWindowType_popup:
 48254:     {
 68855:       DWORD extendedStyle = WS_EX_TOOLWINDOW;
 48254:       if (mPopupLevel == ePopupLevelTop)
 48254:         extendedStyle |= WS_EX_TOPMOST;
 48254:       return extendedStyle;
 48254:     }
 29835:     default:
 31561:       NS_ERROR("unknown border style");
 29835:       // fall through
 29835: 
 29835:     case eWindowType_toplevel:
 29835:     case eWindowType_invisible:
 29835:       return WS_EX_WINDOWEDGE;
 29835:   }
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window subclassing utilities
 29835:  *
 29835:  * Set or clear window subclasses on native windows. Used in
 29835:  * Create and Destroy.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Subclass (or remove the subclass from) this component's nsWindow
 29835: void nsWindow::SubclassWindow(BOOL bState)
 29835: {
100251:   if (bState) {
100251:     if (!mWnd || !IsWindow(mWnd)) {
 33486:       NS_ERROR("Invalid window handle");
 33486:     }
 29835: 
100251:     if (mUnicodeWidget) {
100251:       mPrevWndProc =
100251:         reinterpret_cast<WNDPROC>(
100251:           SetWindowLongPtrW(mWnd,
100251:                             GWLP_WNDPROC,
100251:                             reinterpret_cast<LONG_PTR>(nsWindow::WindowProc)));
100251:     } else {
100251:       mPrevWndProc =
100251:         reinterpret_cast<WNDPROC>(
100251:           SetWindowLongPtrA(mWnd,
100251:                             GWLP_WNDPROC,
100251:                             reinterpret_cast<LONG_PTR>(nsWindow::WindowProc)));
100251:     }
 29835:     NS_ASSERTION(mPrevWndProc, "Null standard window procedure");
 29835:     // connect the this pointer to the nsWindow handle
155877:     WinUtils::SetNSWindowBasePtr(mWnd, this);
100251:   } else {
100251:     if (IsWindow(mWnd)) {
100251:       if (mUnicodeWidget) {
100251:         SetWindowLongPtrW(mWnd,
100251:                           GWLP_WNDPROC,
100251:                           reinterpret_cast<LONG_PTR>(mPrevWndProc));
100251:       } else {
100251:         SetWindowLongPtrA(mWnd,
100251:                           GWLP_WNDPROC,
100251:                           reinterpret_cast<LONG_PTR>(mPrevWndProc));
100251:       }
100251:     }
164874:     WinUtils::SetNSWindowBasePtr(mWnd, nullptr);
164874:     mPrevWndProc = nullptr;
 29835:   }
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetParent, nsIWidget::GetParent
 29835:  *
 29835:  * Set or clear the parent widgets using window properties, and
 29835:  * handles calculating native parent handles.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Get and set parent widgets
     1: NS_IMETHODIMP nsWindow::SetParent(nsIWidget *aNewParent)
     1: {
 43018:   mParent = aNewParent;
 43018: 
  3419:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
  3419:   nsIWidget* parent = GetParent();
  3419:   if (parent) {
  3419:     parent->RemoveChild(this);
  3419:   }
 54312:   if (aNewParent) {
 54312:     ReparentNativeWidget(aNewParent);
 54312:     aNewParent->AddChild(this);
 54312:     return NS_OK;
 54312:   }
 54312:   if (mWnd) {
 54312:     // If we have no parent, SetParent should return the desktop.
106838:     VERIFY(::SetParent(mWnd, nullptr));
 54312:   }
 54312:   return NS_OK;
 54312: }
 54312: 
 54312: NS_IMETHODIMP
 54312: nsWindow::ReparentNativeWidget(nsIWidget* aNewParent)
 54312: {
 54312:   NS_PRECONDITION(aNewParent, "");
 54312: 
 54312:   mParent = aNewParent;
 54312:   if (mWindowType == eWindowType_popup) {
 54312:     return NS_OK;
 54312:   }
     1:   HWND newParent = (HWND)aNewParent->GetNativeData(NS_NATIVE_WINDOW);
     1:   NS_ASSERTION(newParent, "Parent widget has a null native window handle");
  3419:   if (newParent && mWnd) {
     1:     ::SetParent(mWnd, newParent);
  3419:   }
  4577:   return NS_OK;
     1: }
     1: 
     1: nsIWidget* nsWindow::GetParent(void)
     1: {
 79626:   return GetParentWindow(false);
 27505: }
 27505: 
 50783: float nsWindow::GetDPI()
 50783: {
 50783:   HDC dc = ::GetDC(mWnd);
 50783:   if (!dc)
 50783:     return 96.0f;
 50783: 
 50784:   double heightInches = ::GetDeviceCaps(dc, VERTSIZE)/MM_PER_INCH_FLOAT;
 50783:   int heightPx = ::GetDeviceCaps(dc, VERTRES);
 50783:   ::ReleaseDC(mWnd, dc);
 50783:   if (heightInches < 0.25) {
 50783:     // Something's broken
 50783:     return 96.0f;
 50783:   }
 50783:   return float(heightPx/heightInches);
 50783: }
 50783: 
120488: double nsWindow::GetDefaultScaleInternal()
116171: {
177527:   return WinUtils::LogToPhysFactor();
116171: }
116171: 
155877: nsWindow*
155877: nsWindow::GetParentWindow(bool aIncludeOwner)
155877: {
155877:   return static_cast<nsWindow*>(GetParentWindowBase(aIncludeOwner));
155877: }
155877: 
155877: nsWindowBase*
155877: nsWindow::GetParentWindowBase(bool aIncludeOwner)
 19016: {
 19016:   if (mIsTopWidgetWindow) {
     1:     // Must use a flag instead of mWindowType to tell if the window is the
     1:     // owned by the topmost widget, because a child window can be embedded inside
     1:     // a HWND which is not associated with a nsIWidget.
106838:     return nullptr;
     1:   }
 19016: 
     1:   // If this widget has already been destroyed, pretend we have no parent.
     1:   // This corresponds to code in Destroy which removes the destroyed
     1:   // widget from its parent's child list.
 30223:   if (mInDtor || mOnDestroyCalled)
106838:     return nullptr;
     1: 
 27505: 
 27505:   // aIncludeOwner set to true implies walking the parent chain to retrieve the
 27505:   // root owner. aIncludeOwner set to false implies the search will stop at the
 27505:   // true parent (default).
106838:   nsWindow* widget = nullptr;
     1:   if (mWnd) {
106838:     HWND parent = nullptr;
 27505:     if (aIncludeOwner)
 27505:       parent = ::GetParent(mWnd);
 27505:     else
 27505:       parent = ::GetAncestor(mWnd, GA_PARENT);
 68855: 
     1:     if (parent) {
 86569:       widget = WinUtils::GetNSWindowPtr(parent);
     1:       if (widget) {
     1:         // If the widget is in the process of being destroyed then
     1:         // do NOT return it
 30223:         if (widget->mInDtor) {
106838:           widget = nullptr;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
155877:   return static_cast<nsWindowBase*>(widget);
     1: }
     1:  
 58811: BOOL CALLBACK
 58811: nsWindow::EnumAllChildWindProc(HWND aWnd, LPARAM aParam)
 58811: {
 86569:   nsWindow *wnd = WinUtils::GetNSWindowPtr(aWnd);
 58811:   if (wnd) {
 58811:     ((nsWindow::WindowEnumCallback*)aParam)(wnd);
 58811:   }
 58811:   return TRUE;
 58811: }
 58811: 
 58811: BOOL CALLBACK
 58811: nsWindow::EnumAllThreadWindowProc(HWND aWnd, LPARAM aParam)
 58811: {
 86569:   nsWindow *wnd = WinUtils::GetNSWindowPtr(aWnd);
 58811:   if (wnd) {
 58811:     ((nsWindow::WindowEnumCallback*)aParam)(wnd);
 58811:   }
 58811:   EnumChildWindows(aWnd, EnumAllChildWindProc, aParam);
 58811:   return TRUE;
 58811: }
 58811: 
 58811: void
 58811: nsWindow::EnumAllWindows(WindowEnumCallback aCallback)
 58811: {
 58811:   EnumThreadWindows(GetCurrentThreadId(),
 58811:                     EnumAllThreadWindowProc,
 61524:                     (LPARAM)aCallback);
 58811: }
 58811: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::Show
 29835:  *
 29835:  * Hide or show this component.
 29835:  *
 29835:  **************************************************************/
     1: 
 79445: NS_METHOD nsWindow::Show(bool bState)
     1: {
 62852:   if (mWindowType == eWindowType_popup) {
 63258:     // See bug 603793. When we try to draw D3D9/10 windows with a drop shadow
 62852:     // without the DWM on a secondary monitor, windows fails to composite
 62852:     // our windows correctly. We therefor switch off the drop shadow for
 62852:     // pop-up windows when the DWM is disabled and two monitors are
 62852:     // connected.
 63258:     if (HasBogusPopupsDropShadowOnMultiMonitor() &&
 86569:         WinUtils::GetMonitorCount() > 1 &&
 62852:         !nsUXThemeData::CheckForCompositor())
 62852:     {
 62852:       if (sDropShadowEnabled) {
 62852:         ::SetClassLongA(mWnd, GCL_STYLE, 0);
 79626:         sDropShadowEnabled = false;
 62852:       }
 62852:     } else {
 62852:       if (!sDropShadowEnabled) {
 62852:         ::SetClassLongA(mWnd, GCL_STYLE, CS_DROPSHADOW);
 79626:         sDropShadowEnabled = true;
 62852:       }
 62852:     }
119388: 
119388:     // WS_EX_COMPOSITED conflicts with the WS_EX_LAYERED style and causes
119388:     // some popup menus to become invisible.
119388:     LONG_PTR exStyle = ::GetWindowLongPtrW(mWnd, GWL_EXSTYLE);
119388:     if (exStyle & WS_EX_LAYERED) {
119388:       ::SetWindowLongPtrW(mWnd, GWL_EXSTYLE, exStyle & ~WS_EX_COMPOSITED);
119388:     }
 62852:   }
 62852: 
 79445:   bool syncInvalidate = false;
 79445: 
 79445:   bool wasVisible = mIsVisible;
 16326:   // Set the status now so that anyone asking during ShowWindow or
 16326:   // SetWindowPos would get the correct answer.
 16326:   mIsVisible = bState;
 16326: 
 62612:   // We may have cached an out of date visible state. This can happen
 62612:   // when session restore sets the full screen mode.
 62612:   if (mIsVisible)
 62612:     mOldStyle |= WS_VISIBLE;
 62612:   else
 62612:     mOldStyle &= ~WS_VISIBLE;
 62612: 
 50583:   if (!mIsVisible && wasVisible) {
 51000:       ClearCachedResources();
 51000:   }
 50583: 
     1:   if (mWnd) {
     1:     if (bState) {
 16326:       if (!wasVisible && mWindowType == eWindowType_toplevel) {
 62274:         // speed up the initial paint after show for
 62274:         // top level windows:
 79626:         syncInvalidate = true;
     1:         switch (mSizeMode) {
 64173:           case nsSizeMode_Fullscreen:
 64173:             ::ShowWindow(mWnd, SW_SHOW);
 64173:             break;
 24970:           case nsSizeMode_Maximized :
 24970:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
 24970:             break;
     1:           case nsSizeMode_Minimized :
     1:             ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
 24795:             break;
     1:           default:
     1:             if (CanTakeFocus()) {
 24795:               ::ShowWindow(mWnd, SW_SHOWNORMAL);
     1:             } else {
     1:               // Place the window behind the foreground window
     1:               // (as long as it is not topmost)
     1:               HWND wndAfter = ::GetForegroundWindow();
     1:               if (!wndAfter)
     1:                 wndAfter = HWND_BOTTOM;
 25349:               else if (GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST)
     1:                 wndAfter = HWND_TOP;
     1:               ::SetWindowPos(mWnd, wndAfter, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE | 
     1:                              SWP_NOMOVE | SWP_NOACTIVATE);
     1:               GetAttention(2);
     1:             }
 23335:             break;
     1:         }
     1:       } else {
     1:         DWORD flags = SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW;
 16326:         if (wasVisible)
     1:           flags |= SWP_NOZORDER;
     1: 
     1:         if (mWindowType == eWindowType_popup) {
     1:           // ensure popups are the topmost of the TOPMOST
     1:           // layer. Remember not to set the SWP_NOZORDER
     1:           // flag as that might allow the taskbar to overlap
 68855:           // the popup.
     1:           flags |= SWP_NOACTIVATE;
  8408:           HWND owner = ::GetWindow(mWnd, GW_OWNER);
  8408:           ::SetWindowPos(mWnd, owner ? 0 : HWND_TOPMOST, 0, 0, 0, 0, flags);
     1:         } else {
 26616:           if (mWindowType == eWindowType_dialog && !CanTakeFocus())
 26616:             flags |= SWP_NOACTIVATE;
 68855: 
     1:           ::SetWindowPos(mWnd, HWND_TOP, 0, 0, 0, 0, flags);
     1:         }
     1:       }
 41071: 
 41071:       if (!wasVisible && (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog)) {
 41071:         // when a toplevel window or dialog is shown, initialize the UI state
 41071:         ::SendMessageW(mWnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
 41071:       }
     1:     } else {
104347:       // Clear contents to avoid ghosting of old content if we display
104347:       // this window again.
104347:       if (wasVisible && mTransparencyMode == eTransparencyTransparent) {
104347:         ClearTranslucentWindow();
104347:       }
     1:       if (mWindowType != eWindowType_dialog) {
     1:         ::ShowWindow(mWnd, SW_HIDE);
     1:       } else {
     1:         ::SetWindowPos(mWnd, 0, 0, 0, 0, 0, SWP_HIDEWINDOW | SWP_NOSIZE | SWP_NOMOVE |
     1:                        SWP_NOZORDER | SWP_NOACTIVATE);
     1:       }
     1:     }
     1:   }
     1:   
     1: #ifdef MOZ_XUL
 87336:   if (!wasVisible && bState) {
 87336:     Invalidate();
126129:     if (syncInvalidate && !mInDtor && !mOnDestroyCalled) {
 87336:       ::UpdateWindow(mWnd);
 87336:     }
 87336:   }
     1: #endif
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::IsVisible
 29835:  *
 29835:  * Returns the visibility state.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79626: // Return true if the whether the component is visible, false otherwise
105772: bool nsWindow::IsVisible() const
105772: {
105772:   return mIsVisible;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window clipping utilities
 29835:  *
 29835:  * Used in Size and Move operations for setting the proper
 29835:  * window clipping regions for window transparency.
 29835:  *
 29835:  **************************************************************/
     1: 
 26576: // XP and Vista visual styles sometimes require window clipping regions to be applied for proper
 26576: // transparency. These routines are called on size and move operations.
 26576: void nsWindow::ClearThemeRegion()
 26576: {
172560:   if (IsVistaOrLater() && !HasGlass() &&
 52101:       (mWindowType == eWindowType_popup && !IsPopupWithTitleBar() &&
 52101:        (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel))) {
164874:     SetWindowRgn(mWnd, nullptr, false);
 26650:   }
 26576: }
 26576: 
 26576: void nsWindow::SetThemeRegion()
 26576: {
 26576:   // Popup types that have a visual styles region applied (bug 376408). This can be expanded
 26576:   // for other window types as needed. The regions are applied generically to the base window
 26576:   // so default constants are used for part and state. At some point we might need part and
 26576:   // state values from nsNativeThemeWin's GetThemePartAndState, but currently windows that
 26576:   // change shape based on state haven't come up.
172560:   if (IsVistaOrLater() && !HasGlass() &&
 52101:       (mWindowType == eWindowType_popup && !IsPopupWithTitleBar() &&
 52101:        (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel))) {
106838:     HRGN hRgn = nullptr;
 26576:     RECT rect = {0,0,mBounds.width,mBounds.height};
 26576:     
 36844:     HDC dc = ::GetDC(mWnd);
 90802:     GetThemeBackgroundRegion(nsUXThemeData::GetTheme(eUXTooltip), dc, TTP_STANDARD, TS_NORMAL, &rect, &hRgn);
 26576:     if (hRgn) {
 26576:       if (!SetWindowRgn(mWnd, hRgn, false)) // do not delete or alter hRgn if accepted.
 26576:         DeleteObject(hRgn);
 26576:     }
 36844:     ::ReleaseDC(mWnd, dc);
 26576:   }
 26576: }
 26576: 
 29835: /**************************************************************
 29835:  *
 48711:  * SECTION: nsIWidget::RegisterTouchWindow,
 48711:  * nsIWidget::UnregisterTouchWindow, and helper functions
 48711:  *
 48711:  * Used to register the native window to receive touch events
 48711:  *
 48711:  **************************************************************/
 48711: 
 48711: NS_METHOD nsWindow::RegisterTouchWindow() {
150013:   if (Preferences::GetInt("dom.w3c_touch_events.enabled", 0)) {
 79626:     mTouchWindow = true;
 48711:     mGesture.RegisterTouchWindow(mWnd);
 51212:     ::EnumChildWindows(mWnd, nsWindow::RegisterTouchForDescendants, 0);
150013:   }
 48711:   return NS_OK;
 48711: }
 48711: 
 48711: NS_METHOD nsWindow::UnregisterTouchWindow() {
 79626:   mTouchWindow = false;
 48711:   mGesture.UnregisterTouchWindow(mWnd);
 51212:   ::EnumChildWindows(mWnd, nsWindow::UnregisterTouchForDescendants, 0);
 48711:   return NS_OK;
 48711: }
 48711: 
 48711: BOOL CALLBACK nsWindow::RegisterTouchForDescendants(HWND aWnd, LPARAM aMsg) {
 86569:   nsWindow* win = WinUtils::GetNSWindowPtr(aWnd);
 48711:   if (win)
 48711:     win->mGesture.RegisterTouchWindow(aWnd);
 48711:   return TRUE;
 48711: }
 48711: 
 48711: BOOL CALLBACK nsWindow::UnregisterTouchForDescendants(HWND aWnd, LPARAM aMsg) {
 86569:   nsWindow* win = WinUtils::GetNSWindowPtr(aWnd);
 48711:   if (win)
 48711:     win->mGesture.UnregisterTouchWindow(aWnd);
 48711:   return TRUE;
 48711: }
 48711: 
 48711: /**************************************************************
 48711:  *
 33506:  * SECTION: nsIWidget::Move, nsIWidget::Resize,
 33506:  * nsIWidget::Size, nsIWidget::BeginResizeDrag
 29835:  *
 29835:  * Repositioning and sizing a window.
 29835:  *
 29835:  **************************************************************/
 29835: 
106923: void
106923: nsWindow::SetSizeConstraints(const SizeConstraints& aConstraints)
106923: {
106923:   SizeConstraints c = aConstraints;
106923:   if (mWindowType != eWindowType_popup) {
129543:     c.mMinSize.width = std::max(int32_t(::GetSystemMetrics(SM_CXMINTRACK)), c.mMinSize.width);
129543:     c.mMinSize.height = std::max(int32_t(::GetSystemMetrics(SM_CYMINTRACK)), c.mMinSize.height);
106923:   }
106923: 
106923:   nsBaseWidget::SetSizeConstraints(c);
106923: }
106923: 
     1: // Move this component
125634: NS_METHOD nsWindow::Move(double aX, double aY)
     1: {
 34488:   if (mWindowType == eWindowType_toplevel ||
 34488:       mWindowType == eWindowType_dialog) {
 34488:     SetSizeMode(nsSizeMode_Normal);
 34488:   }
     1: 
125978:   // for top-level windows only, convert coordinates from global display pixels
125978:   // (the "parent" coordinate space) to the window's device pixel space
162431:   CSSToLayoutDeviceScale scale = BoundsUseDisplayPixels() ? GetDefaultScale()
162431:                                     : CSSToLayoutDeviceScale(1.0);
162431:   int32_t x = NSToIntRound(aX * scale.scale);
162431:   int32_t y = NSToIntRound(aY * scale.scale);
125636: 
141202:   // Check to see if window needs to be moved first
141202:   // to avoid a costly call to SetWindowPos. This check
141202:   // can not be moved to the calling code in nsView, because
141202:   // some platforms do not position child windows correctly
141202: 
141202:   // Only perform this check for non-popup windows, since the positioning can
141202:   // in fact change even when the x/y do not.  We always need to perform the
141202:   // check. See bug #97805 for details.
141202:   if (mWindowType != eWindowType_popup && (mBounds.x == x) && (mBounds.y == y))
141202:   {
141202:     // Nothing to do, since it is already positioned correctly.
141202:     return NS_OK;
141202:   }
141202: 
125636:   mBounds.x = x;
125636:   mBounds.y = y;
     1: 
     1:   if (mWnd) {
     1: #ifdef DEBUG
     1:     // complain if a window is moved offscreen (legal, but potentially worrisome)
     1:     if (mIsTopWidgetWindow) { // only a problem for top-level windows
     1:       // Make sure this window is actually on the screen before we move it
     1:       // XXX: Needs multiple monitor support
     1:       HDC dc = ::GetDC(mWnd);
     1:       if (dc) {
     1:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
     1:           RECT workArea;
     1:           ::SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0);
     1:           // no annoying assertions. just mention the issue.
125636:           if (x < 0 || x >= workArea.right || y < 0 || y >= workArea.bottom) {
 76714:             PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:                    ("window moved to offscreen position\n"));
 76714:           }
     1:         }
     1:       ::ReleaseDC(mWnd, dc);
     1:       }
     1:     }
     1: #endif
 26576:     ClearThemeRegion();
 58633: 
 58633:     UINT flags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE;
 58633:     // Workaround SetWindowPos bug with D3D9. If our window has a clip
 58633:     // region, some drivers or OSes may incorrectly copy into the clipped-out
 58633:     // area.
 58633:     if (mWindowType == eWindowType_plugin &&
181945:         (!mLayerManager || mLayerManager->GetBackendType() == LayersBackend::LAYERS_D3D9) &&
 58633:         mClipRects &&
 68638:         (mClipRectCount != 1 || !mClipRects[0].IsEqualInterior(nsIntRect(0, 0, mBounds.width, mBounds.height)))) {
 58633:       flags |= SWP_NOCOPYBITS;
 58633:     }
164874:     VERIFY(::SetWindowPos(mWnd, nullptr, x, y, 0, 0, flags));
 58633: 
 26576:     SetThemeRegion();
     1:   }
120177:   NotifyRollupGeometryChange();
     1:   return NS_OK;
     1: }
     1: 
     1: // Resize this component
125634: NS_METHOD nsWindow::Resize(double aWidth, double aHeight, bool aRepaint)
     1: {
125978:   // for top-level windows only, convert coordinates from global display pixels
125978:   // (the "parent" coordinate space) to the window's device pixel space
162431:   CSSToLayoutDeviceScale scale = BoundsUseDisplayPixels() ? GetDefaultScale()
162431:                                     : CSSToLayoutDeviceScale(1.0);
162431:   int32_t width = NSToIntRound(aWidth * scale.scale);
162431:   int32_t height = NSToIntRound(aHeight * scale.scale);
125636: 
125636:   NS_ASSERTION((width >= 0) , "Negative width passed to nsWindow::Resize");
125636:   NS_ASSERTION((height >= 0), "Negative height passed to nsWindow::Resize");
125636: 
125634:   ConstrainSize(&width, &height);
     1: 
 46192:   // Avoid unnecessary resizing calls
125634:   if (mBounds.width == width && mBounds.height == height) {
110896:     if (aRepaint) {
110896:       Invalidate();
110896:     }
 46192:     return NS_OK;
110896:   }
 46192: 
     1: #ifdef MOZ_XUL
 16601:   if (eTransparencyTransparent == mTransparencyMode)
125634:     ResizeTranslucentWindow(width, height);
     1: #endif
     1: 
     1:   // Set cached value for lightweight and printing
125634:   mBounds.width  = width;
125634:   mBounds.height = height;
     1: 
     1:   if (mWnd) {
     1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE;
 30750: 
     1:     if (!aRepaint) {
     1:       flags |= SWP_NOREDRAW;
     1:     }
     1: 
 26576:     ClearThemeRegion();
164874:     VERIFY(::SetWindowPos(mWnd, nullptr, 0, 0,
164874:                           width, GetHeight(height), flags));
 26576:     SetThemeRegion();
     1:   }
     1: 
     1:   if (aRepaint)
 87336:     Invalidate();
     1: 
120177:   NotifyRollupGeometryChange();
     1:   return NS_OK;
     1: }
     1: 
     1: // Resize this component
125634: NS_METHOD nsWindow::Resize(double aX, double aY, double aWidth, double aHeight, bool aRepaint)
     1: {
125978:   // for top-level windows only, convert coordinates from global display pixels
125978:   // (the "parent" coordinate space) to the window's device pixel space
162431:   CSSToLayoutDeviceScale scale = BoundsUseDisplayPixels() ? GetDefaultScale()
162431:                                     : CSSToLayoutDeviceScale(1.0);
162431:   int32_t x = NSToIntRound(aX * scale.scale);
162431:   int32_t y = NSToIntRound(aY * scale.scale);
162431:   int32_t width = NSToIntRound(aWidth * scale.scale);
162431:   int32_t height = NSToIntRound(aHeight * scale.scale);
125636: 
125636:   NS_ASSERTION((width >= 0),  "Negative width passed to nsWindow::Resize");
125636:   NS_ASSERTION((height >= 0), "Negative height passed to nsWindow::Resize");
125636: 
125634:   ConstrainSize(&width, &height);
     1: 
 46192:   // Avoid unnecessary resizing calls
125634:   if (mBounds.x == x && mBounds.y == y &&
125634:       mBounds.width == width && mBounds.height == height) {
110896:     if (aRepaint) {
110896:       Invalidate();
110896:     }
 46192:     return NS_OK;
110896:   }
 46192: 
     1: #ifdef MOZ_XUL
 16601:   if (eTransparencyTransparent == mTransparencyMode)
125634:     ResizeTranslucentWindow(width, height);
     1: #endif
     1: 
     1:   // Set cached value for lightweight and printing
125634:   mBounds.x      = x;
125634:   mBounds.y      = y;
125634:   mBounds.width  = width;
125634:   mBounds.height = height;
     1: 
     1:   if (mWnd) {
     1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE;
     1:     if (!aRepaint) {
     1:       flags |= SWP_NOREDRAW;
     1:     }
 26576: 
 26576:     ClearThemeRegion();
164874:     VERIFY(::SetWindowPos(mWnd, nullptr, x, y,
164874:                           width, GetHeight(height), flags));
 26576:     SetThemeRegion();
     1:   }
     1: 
     1:   if (aRepaint)
 87336:     Invalidate();
     1: 
120177:   NotifyRollupGeometryChange();
     1:   return NS_OK;
     1: }
     1: 
 33506: NS_IMETHODIMP
164381: nsWindow::BeginResizeDrag(WidgetGUIEvent* aEvent,
164381:                           int32_t aHorizontal,
164381:                           int32_t aVertical)
 33506: {
 33506:   NS_ENSURE_ARG_POINTER(aEvent);
 33506: 
 33506:   if (aEvent->eventStructType != NS_MOUSE_EVENT) {
 33506:     // you can only begin a resize drag with a mouse event
 33506:     return NS_ERROR_INVALID_ARG;
 33506:   }
 33506: 
166409:   if (aEvent->AsMouseEvent()->button != WidgetMouseEvent::eLeftButton) {
 33506:     // you can only begin a resize drag with the left mouse button
 33506:     return NS_ERROR_INVALID_ARG;
 33506:   }
 33506: 
 33506:   // work out what sizemode we're talking about
 33506:   WPARAM syscommand;
 33506:   if (aVertical < 0) {
 33506:     if (aHorizontal < 0) {
 33506:       syscommand = SC_SIZE | WMSZ_TOPLEFT;
 33506:     } else if (aHorizontal == 0) {
 33506:       syscommand = SC_SIZE | WMSZ_TOP;
 33506:     } else {
 33506:       syscommand = SC_SIZE | WMSZ_TOPRIGHT;
 33506:     }
 33506:   } else if (aVertical == 0) {
 33506:     if (aHorizontal < 0) {
 33506:       syscommand = SC_SIZE | WMSZ_LEFT;
 33506:     } else if (aHorizontal == 0) {
 33506:       return NS_ERROR_INVALID_ARG;
 33506:     } else {
 33506:       syscommand = SC_SIZE | WMSZ_RIGHT;
 33506:     }
 33506:   } else {
 33506:     if (aHorizontal < 0) {
 33506:       syscommand = SC_SIZE | WMSZ_BOTTOMLEFT;
 33506:     } else if (aHorizontal == 0) {
 33506:       syscommand = SC_SIZE | WMSZ_BOTTOM;
 33506:     } else {
 33506:       syscommand = SC_SIZE | WMSZ_BOTTOMRIGHT;
 33506:     }
 33506:   }
 33506: 
 33506:   // resizing doesn't work if the mouse is already captured
 79626:   CaptureMouse(false);
 33506: 
 33506:   // find the top-level window
 86569:   HWND toplevelWnd = WinUtils::GetTopLevelHWND(mWnd, true);
 33506: 
 33506:   // tell Windows to start the resize
 33506:   ::PostMessage(toplevelWnd, WM_SYSCOMMAND, syscommand,
 33506:                 POINTTOPOINTS(aEvent->refPoint));
 33506: 
 33506:   return NS_OK;
 33506: }
 68855: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window Z-order and state.
 29835:  *
 29835:  * nsIWidget::PlaceBehind, nsIWidget::SetSizeMode,
 29835:  * nsIWidget::ConstrainPosition
 29835:  *
 29835:  * Z-order, positioning, restore, minimize, and maximize.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Position the window behind the given window
 29835: NS_METHOD nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
 79445:                                 nsIWidget *aWidget, bool aActivate)
 29835: {
 29835:   HWND behind = HWND_TOP;
 29835:   if (aPlacement == eZPlacementBottom)
 29835:     behind = HWND_BOTTOM;
 29835:   else if (aPlacement == eZPlacementBelow && aWidget)
 29835:     behind = (HWND)aWidget->GetNativeData(NS_NATIVE_WINDOW);
 29835:   UINT flags = SWP_NOMOVE | SWP_NOREPOSITION | SWP_NOSIZE;
 29835:   if (!aActivate)
 29835:     flags |= SWP_NOACTIVATE;
 29835: 
 29835:   if (!CanTakeFocus() && behind == HWND_TOP)
 29835:   {
 29835:     // Can't place the window to top so place it behind the foreground window
 29835:     // (as long as it is not topmost)
 29835:     HWND wndAfter = ::GetForegroundWindow();
 29835:     if (!wndAfter)
 29835:       behind = HWND_BOTTOM;
 29835:     else if (!(GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST))
 29835:       behind = wndAfter;
 29835:     flags |= SWP_NOACTIVATE;
 29835:   }
 29835: 
 29835:   ::SetWindowPos(mWnd, behind, 0, 0, 0, 0, flags);
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: // Maximize, minimize or restore the window.
108991: NS_IMETHODIMP nsWindow::SetSizeMode(int32_t aMode) {
 29835: 
 29835:   nsresult rv;
 29835: 
 29835:   // Let's not try and do anything if we're already in that state.
 29835:   // (This is needed to prevent problems when calling window.minimize(), which
 29835:   // calls us directly, and then the OS triggers another call to us.)
 29835:   if (aMode == mSizeMode)
 29835:     return NS_OK;
 29835: 
 29835:   // save the requested state
 97778:   mLastSizeMode = mSizeMode;
 29835:   rv = nsBaseWidget::SetSizeMode(aMode);
 29835:   if (NS_SUCCEEDED(rv) && mIsVisible) {
 29835:     int mode;
 29835: 
 29835:     switch (aMode) {
 30075:       case nsSizeMode_Fullscreen :
 47780:         mode = SW_SHOW;
 30075:         break;
 30075: 
 29835:       case nsSizeMode_Maximized :
 29835:         mode = SW_MAXIMIZE;
 29835:         break;
 34786: 
 29835:       case nsSizeMode_Minimized :
 34786:         // Using SW_SHOWMINIMIZED prevents the working set from being trimmed but
 34786:         // keeps the window active in the tray. So after the window is minimized,
 34786:         // windows will fire WM_WINDOWPOSCHANGED (OnWindowPosChanged) at which point
 34786:         // we will do some additional processing to get the active window set right.
 34786:         // If sTrimOnMinimize is set, we let windows handle minimization normally
 34786:         // using SW_MINIMIZE.
 29835:         mode = sTrimOnMinimize ? SW_MINIMIZE : SW_SHOWMINIMIZED;
 34786:         break;
 34786: 
 29835:       default :
 29835:         mode = SW_RESTORE;
 29835:     }
 74541: 
 74541:     WINDOWPLACEMENT pl;
 74541:     pl.length = sizeof(pl);
 74541:     ::GetWindowPlacement(mWnd, &pl);
 74541:     // Don't call ::ShowWindow if we're trying to "restore" a window that is
 74541:     // already in a normal state.  Prevents a bug where snapping to one side
 74541:     // of the screen and then minimizing would cause Windows to forget our
 74541:     // window's correct restored position/size.
 74541:     if( !(pl.showCmd == SW_SHOWNORMAL && mode == SW_RESTORE) ) {
 29835:       ::ShowWindow(mWnd, mode);
 74541:     }
108457:     // we activate here to ensure that the right child window is focused
 97778:     if (mode == SW_MAXIMIZE || mode == SW_SHOW)
108457:       DispatchFocusToTopLevelWindow(true);
 29835:   }
 29835:   return rv;
 29835: }
 29835: 
 29835: // Constrain a potential move to fit onscreen
138041: // Position (aX, aY) is specified in Windows screen (logical) pixels
 79445: NS_METHOD nsWindow::ConstrainPosition(bool aAllowSlop,
108991:                                       int32_t *aX, int32_t *aY)
 29835: {
 29835:   if (!mIsTopWidgetWindow) // only a problem for top-level windows
 29835:     return NS_OK;
 29835: 
162431:   double dpiScale = GetDefaultScale().scale;
138041: 
138041:   // we need to use the window size in logical screen pixels
138041:   int32_t logWidth = std::max<int32_t>(NSToIntRound(mBounds.width / dpiScale), 1);
138041:   int32_t logHeight = std::max<int32_t>(NSToIntRound(mBounds.height / dpiScale), 1);
138041: 
 79445:   bool doConstrain = false; // whether we have enough info to do anything
 29835: 
 29835:   /* get our playing field. use the current screen, or failing that
 29835:     for any reason, use device caps for the default screen. */
 29835:   RECT screenRect;
 29835: 
 29835:   nsCOMPtr<nsIScreenManager> screenmgr = do_GetService(sScreenManagerContractID);
 29835:   if (screenmgr) {
 29835:     nsCOMPtr<nsIScreen> screen;
108991:     int32_t left, top, width, height;
 29835: 
138041:     screenmgr->ScreenForRect(*aX, *aY, logWidth, logHeight,
 29835:                              getter_AddRefs(screen));
 29835:     if (screen) {
 47969:       if (mSizeMode != nsSizeMode_Fullscreen) {
 47969:         // For normalized windows, use the desktop work area.
138041:         screen->GetAvailRectDisplayPix(&left, &top, &width, &height);
 47969:       } else {
 47969:         // For full screen windows, use the desktop.
138041:         screen->GetRectDisplayPix(&left, &top, &width, &height);
 47969:       }
 29835:       screenRect.left = left;
 29835:       screenRect.right = left + width;
 29835:       screenRect.top = top;
 29835:       screenRect.bottom = top + height;
 79626:       doConstrain = true;
 29835:     }
 29835:   } else {
 29835:     if (mWnd) {
 29835:       HDC dc = ::GetDC(mWnd);
 29835:       if (dc) {
 29835:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
 47969:           if (mSizeMode != nsSizeMode_Fullscreen) {
 29835:             ::SystemParametersInfo(SPI_GETWORKAREA, 0, &screenRect, 0);
 47969:           } else {
 47969:             screenRect.left = screenRect.top = 0;
 47969:             screenRect.right = GetSystemMetrics(SM_CXFULLSCREEN);
 47969:             screenRect.bottom = GetSystemMetrics(SM_CYFULLSCREEN);
 47969:           }
 79626:           doConstrain = true;
 29835:         }
 29835:         ::ReleaseDC(mWnd, dc);
 29835:       }
 29835:     }
 29835:   }
 29835: 
 29835:   if (aAllowSlop) {
138041:     if (*aX < screenRect.left - logWidth + kWindowPositionSlop)
138041:       *aX = screenRect.left - logWidth + kWindowPositionSlop;
 29835:     else if (*aX >= screenRect.right - kWindowPositionSlop)
 29835:       *aX = screenRect.right - kWindowPositionSlop;
 29835: 
138041:     if (*aY < screenRect.top - logHeight + kWindowPositionSlop)
138041:       *aY = screenRect.top - logHeight + kWindowPositionSlop;
 29835:     else if (*aY >= screenRect.bottom - kWindowPositionSlop)
 29835:       *aY = screenRect.bottom - kWindowPositionSlop;
 29835: 
 29835:   } else {
 29835: 
 29835:     if (*aX < screenRect.left)
 29835:       *aX = screenRect.left;
138041:     else if (*aX >= screenRect.right - logWidth)
138041:       *aX = screenRect.right - logWidth;
 29835: 
 29835:     if (*aY < screenRect.top)
 29835:       *aY = screenRect.top;
138041:     else if (*aY >= screenRect.bottom - logHeight)
138041:       *aY = screenRect.bottom - logHeight;
 29835:   }
 29835: 
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::Enable, nsIWidget::IsEnabled
 29835:  *
 29835:  * Enabling and disabling the widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: // Enable/disable this component
 79445: NS_METHOD nsWindow::Enable(bool bState)
     1: {
     1:   if (mWnd) {
     1:     ::EnableWindow(mWnd, bState);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 29835: // Return the current enable state
106103: bool nsWindow::IsEnabled() const
106103: {
106103:   return !mWnd ||
106103:          (::IsWindowEnabled(mWnd) &&
106103:           ::IsWindowEnabled(::GetAncestor(mWnd, GA_ROOT)));
     1: }
     1: 
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetFocus
 29835:  *
 29835:  * Give the focus to this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: NS_METHOD nsWindow::SetFocus(bool aRaise)
     1: {
     1:   if (mWnd) {
 34735: #ifdef WINSTATE_DEBUG_OUTPUT
 86569:     if (mWnd == WinUtils::GetTopLevelHWND(mWnd)) {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:              ("*** SetFocus: [  top] raise=%d\n", aRaise));
 76714:     } else {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:              ("*** SetFocus: [child] raise=%d\n", aRaise));
 76714:     }
 34735: #endif
     1:     // Uniconify, if necessary
 86569:     HWND toplevelWnd = WinUtils::GetTopLevelHWND(mWnd);
 33214:     if (aRaise && ::IsIconic(toplevelWnd)) {
     1:       ::ShowWindow(toplevelWnd, SW_RESTORE);
 33214:     }
     1:     ::SetFocus(mWnd);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Bounds
 29835:  *
 46200:  * GetBounds, GetClientBounds, GetScreenBounds, GetClientOffset
 46200:  * SetDrawsInTitlebar, GetNonClientMargins, SetNonClientMargins
 29835:  *
 29835:  * Bound calculations.
 29835:  *
 29835:  **************************************************************/
 29835: 
 46192: // Return the window's full dimensions in screen coordinates.
 46192: // If the window has a parent, converts the origin to an offset
 46192: // of the parent's screen origin.
 23738: NS_METHOD nsWindow::GetBounds(nsIntRect &aRect)
     1: {
     1:   if (mWnd) {
     1:     RECT r;
     1:     VERIFY(::GetWindowRect(mWnd, &r));
     1: 
     1:     // assign size
     1:     aRect.width  = r.right - r.left;
     1:     aRect.height = r.bottom - r.top;
     1: 
 64624:     // popup window bounds' are in screen coordinates, not relative to parent
 64624:     // window
 64624:     if (mWindowType == eWindowType_popup) {
 64624:       aRect.x = r.left;
 64624:       aRect.y = r.top;
 64624:       return NS_OK;
 64624:     }
 64624: 
 46192:     // chrome on parent:
 46192:     //  ___      5,5   (chrome start)
 46192:     // |  ____   10,10 (client start)
 46192:     // | |  ____ 20,20 (child start)
 46192:     // | | |
 46192:     // 20,20 - 5,5 = 15,15 (??)
 46192:     // minus GetClientOffset:
 46192:     // 15,15 - 5,5 = 10,10
 46192:     //
 46192:     // no chrome on parent:
 46192:     //  ______   10,10 (win start)
 46192:     // |  ____   20,20 (child start)
 46192:     // | |
 46192:     // 20,20 - 10,10 = 10,10
 46192:     //
 46192:     // walking the chain:
 46192:     //  ___      5,5   (chrome start)
 46192:     // |  ___    10,10 (client start)
 46192:     // | |  ___  20,20 (child start)
 46192:     // | | |  __ 30,30 (child start)
 46192:     // | | | |
 46192:     // 30,30 - 20,20 = 10,10 (offset from second child to first)
 46192:     // 20,20 - 5,5 = 15,15 + 10,10 = 25,25 (??)
 46192:     // minus GetClientOffset:
 46192:     // 25,25 - 5,5 = 20,20 (offset from second child to parent client)
 46192: 
     1:     // convert coordinates if parent exists
     1:     HWND parent = ::GetParent(mWnd);
     1:     if (parent) {
     1:       RECT pr;
     1:       VERIFY(::GetWindowRect(parent, &pr));
     1:       r.left -= pr.left;
     1:       r.top  -= pr.top;
 46192:       // adjust for chrome
 46192:       nsWindow* pWidget = static_cast<nsWindow*>(GetParent());
 46192:       if (pWidget && pWidget->IsTopLevelWidget()) {
 48256:         nsIntPoint clientOffset = pWidget->GetClientOffset();
 46192:         r.left -= clientOffset.x;
 46192:         r.top  -= clientOffset.y;
 46192:       }
     1:     }
     1:     aRect.x = r.left;
     1:     aRect.y = r.top;
     1:   } else {
     1:     aRect = mBounds;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: // Get this component dimension
 23738: NS_METHOD nsWindow::GetClientBounds(nsIntRect &aRect)
     1: {
     1:   if (mWnd) {
     1:     RECT r;
     1:     VERIFY(::GetClientRect(mWnd, &r));
     1: 
 83107:     nsIntRect bounds;
 83107:     GetBounds(bounds);
 83107:     aRect.MoveTo(bounds.TopLeft() + GetClientOffset());
     1:     aRect.width  = r.right - r.left;
     1:     aRect.height = r.bottom - r.top;
     1: 
     1:   } else {
     1:     aRect.SetRect(0,0,0,0);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 29835: // Like GetBounds, but don't offset by the parent
 23738: NS_METHOD nsWindow::GetScreenBounds(nsIntRect &aRect)
     1: {
     1:   if (mWnd) {
     1:     RECT r;
     1:     VERIFY(::GetWindowRect(mWnd, &r));
     1: 
     1:     aRect.width  = r.right - r.left;
     1:     aRect.height = r.bottom - r.top;
     1:     aRect.x = r.left;
     1:     aRect.y = r.top;
     1:   } else
     1:     aRect = mBounds;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 46192: // return the x,y offset of the client area from the origin
 46192: // of the window. If the window is borderless returns (0,0).
 48256: nsIntPoint nsWindow::GetClientOffset()
 46192: {
 46192:   if (!mWnd) {
 48256:     return nsIntPoint(0, 0);
 46192:   }
 46192: 
 46192:   RECT r1;
 46192:   GetWindowRect(mWnd, &r1);
 46192:   nsIntPoint pt = WidgetToScreenOffset();
 48256:   return nsIntPoint(pt.x - r1.left, pt.y - r1.top);
 46192: }
 46192: 
 46200: void
 79445: nsWindow::SetDrawsInTitlebar(bool aState)
 46200: {
 79626:   nsWindow * window = GetTopLevelWindow(true);
 46200:   if (window && window != this) {
 46200:     return window->SetDrawsInTitlebar(aState);
 46200:   }
 46200: 
 46200:   if (aState) {
135125:     // top, right, bottom, left for nsIntMargin
135125:     nsIntMargin margins(0, -1, -1, -1);
 46200:     SetNonClientMargins(margins);
 46200:   }
 46200:   else {
 46200:     nsIntMargin margins(-1, -1, -1, -1);
 46200:     SetNonClientMargins(margins);
 46200:   }
 46200: }
 46200: 
 46200: NS_IMETHODIMP
 46200: nsWindow::GetNonClientMargins(nsIntMargin &margins)
 46200: {
 79626:   nsWindow * window = GetTopLevelWindow(true);
 46200:   if (window && window != this) {
 46200:     return window->GetNonClientMargins(margins);
 46200:   }
 46200: 
 46200:   if (mCustomNonClient) {
 46200:     margins = mNonClientMargins;
 46200:     return NS_OK;
 46200:   }
 46200: 
 46332:   margins.top = GetSystemMetrics(SM_CYCAPTION);
 46332:   margins.bottom = GetSystemMetrics(SM_CYFRAME);
 46332:   margins.top += margins.bottom;
101616:   margins.left = margins.right = GetSystemMetrics(SM_CXFRAME);
 46200: 
 46200:   return NS_OK;
 46200: }
 46200: 
 47788: void
 47788: nsWindow::ResetLayout()
 47788: {
 47788:   // This will trigger a frame changed event, triggering
 47788:   // nc calc size and a sizemode gecko event.
 47788:   SetWindowPos(mWnd, 0, 0, 0, 0, 0,
 47788:                SWP_FRAMECHANGED|SWP_NOACTIVATE|SWP_NOMOVE|
 47788:                SWP_NOOWNERZORDER|SWP_NOSIZE|SWP_NOZORDER);
 47788: 
 47788:   // If hidden, just send the frame changed event for now.
 47788:   if (!mIsVisible)
 47788:     return;
 47788: 
 47788:   // Send a gecko size event to trigger reflow.
 47788:   RECT clientRc = {0};
 47788:   GetClientRect(mWnd, &clientRc);
120800:   nsIntRect evRect(WinUtils::ToIntRect(clientRc));
 47788:   OnResize(evRect);
 47788: 
 47788:   // Invalidate and update
 87336:   Invalidate();
 47788: }
 47788: 
 57388: // Internally track the caption status via a window property. Required
 57388: // due to our internal handling of WM_NCACTIVATE when custom client
 57388: // margins are set.
174217: static const wchar_t kManageWindowInfoProperty[] = L"ManageWindowInfoProperty";
 57388: typedef BOOL (WINAPI *GetWindowInfoPtr)(HWND hwnd, PWINDOWINFO pwi);
164874: static GetWindowInfoPtr sGetWindowInfoPtrStub = nullptr;
 57388: 
 57388: BOOL WINAPI
 57388: GetWindowInfoHook(HWND hWnd, PWINDOWINFO pwi)
 57388: {
 57388:   if (!sGetWindowInfoPtrStub) {
 57388:     NS_ASSERTION(FALSE, "Something is horribly wrong in GetWindowInfoHook!");
 57388:     return FALSE;
 57388:   }
 57388:   int windowStatus = 
 61525:     reinterpret_cast<LONG_PTR>(GetPropW(hWnd, kManageWindowInfoProperty));
 57388:   // No property set, return the default data.
 57388:   if (!windowStatus)
 57388:     return sGetWindowInfoPtrStub(hWnd, pwi);
 57388:   // Call GetWindowInfo and update dwWindowStatus with our
 57388:   // internally tracked value. 
 57388:   BOOL result = sGetWindowInfoPtrStub(hWnd, pwi);
 57388:   if (result && pwi)
 57388:     pwi->dwWindowStatus = (windowStatus == 1 ? 0 : WS_ACTIVECAPTION);
 57388:   return result;
 57388: }
 57388: 
 57388: void
 79445: nsWindow::UpdateGetWindowInfoCaptionStatus(bool aActiveCaption)
 57388: {
 57388:   if (!mWnd)
 57388:     return;
 57388: 
 57388:   if (!sGetWindowInfoPtrStub) {
 57388:     sUser32Intercept.Init("user32.dll");
 69198:     if (!sUser32Intercept.AddHook("GetWindowInfo", reinterpret_cast<intptr_t>(GetWindowInfoHook),
 57388:                                   (void**) &sGetWindowInfoPtrStub))
 57388:       return;
 57388:   }
 57388:   // Update our internally tracked caption status
 57388:   SetPropW(mWnd, kManageWindowInfoProperty, 
 57388:     reinterpret_cast<HANDLE>(static_cast<int>(aActiveCaption) + 1));
 57388: }
 57388: 
108835: /**
108835:  * Called when the window layout changes: full screen mode transitions,
108835:  * theme changes, and composition changes. Calculates the new non-client
108835:  * margins and fires off a frame changed event, which triggers an nc calc
108835:  * size windows event, kicking the changes in.
108835:  *
108835:  * The offsets calculated here are based on the value of `mNonClientMargins`
108835:  * which is specified in the "chromemargins" attribute of the window.  For
108835:  * each margin, the value specified has the following meaning:
108835:  *    -1 - leave the default frame in place
108835:  *     0 - remove the frame
108835:  *    >0 - frame size equals min(0, (default frame size - margin value))
108835:  *
108835:  * This function calculates and populates `mNonClientOffset`.
108835:  * In our processing of `WM_NCCALCSIZE`, the frame size will be calculated
108835:  * as (default frame size - offset).  For example, if the left frame should
108835:  * be 1 pixel narrower than the default frame size, `mNonClientOffset.left`
108835:  * will equal 1.
108835:  *
108835:  * For maximized, fullscreen, and minimized windows, the values stored in
108835:  * `mNonClientMargins` are ignored, and special processing takes place.
108835:  *
108835:  * For non-glass windows, we only allow frames to be their default size
108835:  * or removed entirely.
108835:  */
 79445: bool
108991: nsWindow::UpdateNonClientMargins(int32_t aSizeMode, bool aReflowWindow)
 46200: {
 46200:   if (!mCustomNonClient)
 79626:     return false;
 46200: 
108835:   if (aSizeMode == -1) {
 46332:     aSizeMode = mSizeMode;
108835:   }
108835: 
108835:   bool hasCaption = (mBorderStyle
108835:                     & (eBorderStyle_all
108835:                      | eBorderStyle_title
108835:                      | eBorderStyle_menu
108835:                      | eBorderStyle_default));
108835: 
108835:   // mCaptionHeight is the default size of the NC area at
108835:   // the top of the window. If the window has a caption,
108835:   // the size is calculated as the sum of:
108835:   //      SM_CYFRAME        - The thickness of the sizing border
108835:   //                          around a resizable window
108835:   //      SM_CXPADDEDBORDER - The amount of border padding
108835:   //                          for captioned windows
108835:   //      SM_CYCAPTION      - The height of the caption area
108835:   //
108835:   // If the window does not have a caption, mCaptionHeight will be equal to
108835:   // `GetSystemMetrics(SM_CYFRAME)`
108835:   mCaptionHeight = GetSystemMetrics(SM_CYFRAME)
108835:                  + (hasCaption ? GetSystemMetrics(SM_CYCAPTION)
108835:                                  + GetSystemMetrics(SM_CXPADDEDBORDER)
108835:                                : 0);
108835: 
108835:   // mHorResizeMargin is the size of the default NC areas on the
108835:   // left and right sides of our window.  It is calculated as
108835:   // the sum of:
108835:   //      SM_CXFRAME        - The thickness of the sizing border
108835:   //      SM_CXPADDEDBORDER - The amount of border padding
108835:   //                          for captioned windows
108835:   //
108835:   // If the window does not have a caption, mHorResizeMargin will be equal to
108835:   // `GetSystemMetrics(SM_CXFRAME)`
108835:   mHorResizeMargin = GetSystemMetrics(SM_CXFRAME)
108835:                    + (hasCaption ? GetSystemMetrics(SM_CXPADDEDBORDER) : 0);
108835: 
108835:   // mVertResizeMargin is the size of the default NC area at the
108835:   // bottom of the window. It is calculated as the sum of:
108835:   //      SM_CYFRAME        - The thickness of the sizing border
108835:   //      SM_CXPADDEDBORDER - The amount of border padding
108835:   //                          for captioned windows.
108835:   //
108835:   // If the window does not have a caption, mVertResizeMargin will be equal to
108835:   // `GetSystemMetrics(SM_CYFRAME)`
108835:   mVertResizeMargin = GetSystemMetrics(SM_CYFRAME)
108835:                     + (hasCaption ? GetSystemMetrics(SM_CXPADDEDBORDER) : 0);
108835: 
108835:   if (aSizeMode == nsSizeMode_Minimized) {
108835:     // Use default frame size for minimized windows
108835:     mNonClientOffset.top = 0;
108835:     mNonClientOffset.left = 0;
108835:     mNonClientOffset.right = 0;
108835:     mNonClientOffset.bottom = 0;
108835:   } else if (aSizeMode == nsSizeMode_Fullscreen) {
108835:     // Remove the default frame from the top of our fullscreen window.  This
108835:     // makes the whole caption part of our client area, allowing us to draw
108835:     // in the whole caption area.  Additionally remove the default frame from
108835:     // the left, right, and bottom.
 46200:     mNonClientOffset.top = mCaptionHeight;
108835:     mNonClientOffset.bottom = mVertResizeMargin;
108835:     mNonClientOffset.left = mHorResizeMargin;
108835:     mNonClientOffset.right = mHorResizeMargin;
108835:   } else if (aSizeMode == nsSizeMode_Maximized) {
108835:     // Remove the default frame from the top of our maximized window.  This
108835:     // makes the whole caption part of our client area, allowing us to draw
108835:     // in the whole caption area.  Use default frame size on left, right, and
108835:     // bottom. The reason this works is that, for maximized windows,
108835:     // Windows positions them so that their frames fall off the screen.
108835:     // This gives the illusion of windows having no frames when they are
108835:     // maximized.  If we try to mess with the frame sizes by setting these
108835:     // offsets to positive values, our client area will fall off the screen.
108835:     mNonClientOffset.top = mCaptionHeight;
108835:     mNonClientOffset.bottom = 0;
108835:     mNonClientOffset.left = 0;
108835:     mNonClientOffset.right = 0;
108835: 
108835:     APPBARDATA appBarData;
108835:     appBarData.cbSize = sizeof(appBarData);
108835:     UINT taskbarState = SHAppBarMessage(ABM_GETSTATE, &appBarData);
108835:     if (ABS_AUTOHIDE & taskbarState) {
108835:       UINT edge = -1;
164874:       appBarData.hWnd = FindWindow(L"Shell_TrayWnd", nullptr);
108835:       if (appBarData.hWnd) {
108835:         HMONITOR taskbarMonitor = ::MonitorFromWindow(appBarData.hWnd,
108835:                                                       MONITOR_DEFAULTTOPRIMARY);
108835:         HMONITOR windowMonitor = ::MonitorFromWindow(mWnd,
108835:                                                      MONITOR_DEFAULTTONEAREST);
108835:         if (taskbarMonitor == windowMonitor) {
108835:           SHAppBarMessage(ABM_GETTASKBARPOS, &appBarData);
108835:           edge = appBarData.uEdge;
108835:         }
108835:       }
108835: 
108835:       if (ABE_LEFT == edge) {
108835:         mNonClientOffset.left -= 1;
108835:       } else if (ABE_RIGHT == edge) {
108835:         mNonClientOffset.right -= 1;
108835:       } else if (ABE_BOTTOM == edge || ABE_TOP == edge) {
108835:         mNonClientOffset.bottom -= 1;
108835:       }
108835:     }
108835:   } else {
108835:     bool glass = nsUXThemeData::CheckForCompositor();
108835: 
108835:     // We're dealing with a "normal" window (not maximized, minimized, or
108835:     // fullscreen), so process `mNonClientMargins` and set `mNonClientOffset`
108835:     // accordingly.
108835:     //
108835:     // Setting `mNonClientOffset` to 0 has the effect of leaving the default
108835:     // frame intact.  Setting it to a value greater than 0 reduces the frame
108835:     // size by that amount.
108835: 
108835:     if (mNonClientMargins.top > 0 && glass) {
129543:       mNonClientOffset.top = std::min(mCaptionHeight, mNonClientMargins.top);
108835:     } else if (mNonClientMargins.top == 0) {
108835:       mNonClientOffset.top = mCaptionHeight;
108835:     } else {
108835:       mNonClientOffset.top = 0;
108835:     }
108835: 
108835:     if (mNonClientMargins.bottom > 0 && glass) {
129543:       mNonClientOffset.bottom = std::min(mVertResizeMargin, mNonClientMargins.bottom);
108835:     } else if (mNonClientMargins.bottom == 0) {
108835:       mNonClientOffset.bottom = mVertResizeMargin;
108835:     } else {
108835:       mNonClientOffset.bottom = 0;
108835:     }
108835: 
108835:     if (mNonClientMargins.left > 0 && glass) {
129543:       mNonClientOffset.left = std::min(mHorResizeMargin, mNonClientMargins.left);
108835:     } else if (mNonClientMargins.left == 0) {
 46332:       mNonClientOffset.left = mHorResizeMargin;
108835:     } else {
108835:       mNonClientOffset.left = 0;
108835:     }
108835: 
108835:     if (mNonClientMargins.right > 0 && glass) {
129543:       mNonClientOffset.right = std::min(mHorResizeMargin, mNonClientMargins.right);
108835:     } else if (mNonClientMargins.right == 0) {
 46332:       mNonClientOffset.right = mHorResizeMargin;
108835:     } else {
 87238:       mNonClientOffset.right = 0;
 87238:     }
 48424:   }
 46200: 
 47788:   if (aReflowWindow) {
 47788:     // Force a reflow of content based on the new client
 47788:     // dimensions.
 47788:     ResetLayout();
 46332:   }
 46200: 
 79626:   return true;
 46200: }
 46200: 
 46200: NS_IMETHODIMP
 46200: nsWindow::SetNonClientMargins(nsIntMargin &margins)
 46200: {
 46200:   if (!mIsTopWidgetWindow ||
 46200:       mBorderStyle & eBorderStyle_none ||
 46200:       mHideChrome)
 46200:     return NS_ERROR_INVALID_ARG;
 46200: 
 46200:   // Request for a reset
 46200:   if (margins.top == -1 && margins.left == -1 &&
 46200:       margins.right == -1 && margins.bottom == -1) {
 79626:     mCustomNonClient = false;
 46200:     mNonClientMargins = margins;
 57394:     RemovePropW(mWnd, kManageWindowInfoProperty);
 47788:     // Force a reflow of content based on the new client
 47788:     // dimensions.
 47788:     ResetLayout();
 46200:     return NS_OK;
 46200:   }
 46200: 
 46200:   if (margins.top < -1 || margins.bottom < -1 ||
 46200:       margins.left < -1 || margins.right < -1)
 46200:     return NS_ERROR_INVALID_ARG;
 46200: 
 46200:   mNonClientMargins = margins;
 79626:   mCustomNonClient = true;
 46200:   if (!UpdateNonClientMargins()) {
 46200:     NS_WARNING("UpdateNonClientMargins failed!");
111328:     return NS_OK;
 46200:   }
 46200: 
 46200:   return NS_OK;
 46200: }
 46200: 
 49251: void
 49251: nsWindow::InvalidateNonClientRegion()
 49251: {
 49251:   // +-+-----------------------+-+
 49251:   // | | app non-client chrome | |
 49251:   // | +-----------------------+ |
 49251:   // | |   app client chrome   | | }
 49251:   // | +-----------------------+ | }
 49251:   // | |      app content      | | } area we don't want to invalidate
 49251:   // | +-----------------------+ | }
 49251:   // | |   app client chrome   | | }
 49251:   // | +-----------------------+ | 
 49251:   // +---------------------------+ <
 49251:   //  ^                         ^    windows non-client chrome
 49251:   // client area = app *
 49251:   RECT rect;
 49251:   GetWindowRect(mWnd, &rect);
164874:   MapWindowPoints(nullptr, mWnd, (LPPOINT)&rect, 2);
 49251:   HRGN winRgn = CreateRectRgnIndirect(&rect);
 49251: 
 49251:   // Subtract app client chrome and app content leaving
 49251:   // windows non-client chrome and app non-client chrome
 49251:   // in winRgn.
 49251:   GetWindowRect(mWnd, &rect);
 49251:   rect.top += mCaptionHeight;
 49251:   rect.right -= mHorResizeMargin;
 49251:   rect.bottom -= mHorResizeMargin;
 49251:   rect.left += mVertResizeMargin;
164874:   MapWindowPoints(nullptr, mWnd, (LPPOINT)&rect, 2);
 49251:   HRGN clientRgn = CreateRectRgnIndirect(&rect);
 49251:   CombineRgn(winRgn, winRgn, clientRgn, RGN_DIFF);
 49251:   DeleteObject(clientRgn);
 49251: 
 49251:   // triggers ncpaint and paint events for the two areas
164874:   RedrawWindow(mWnd, nullptr, winRgn, RDW_FRAME | RDW_INVALIDATE);
 49251:   DeleteObject(winRgn);
 49251: }
 49251: 
 49251: HRGN
 49251: nsWindow::ExcludeNonClientFromPaintRegion(HRGN aRegion)
 49251: {
 49251:   RECT rect;
164874:   HRGN rgn = nullptr;
 49251:   if (aRegion == (HRGN)1) { // undocumented value indicating a full refresh
 49251:     GetWindowRect(mWnd, &rect);
 49251:     rgn = CreateRectRgnIndirect(&rect);
 49251:   } else {
 49251:     rgn = aRegion;
 49251:   }
 49251:   GetClientRect(mWnd, &rect);
164874:   MapWindowPoints(mWnd, nullptr, (LPPOINT)&rect, 2);
 49251:   HRGN nonClientRgn = CreateRectRgnIndirect(&rect);
 49251:   CombineRgn(rgn, rgn, nonClientRgn, RGN_DIFF);
 49251:   DeleteObject(nonClientRgn);
 49251:   return rgn;
 49251: }
 49251: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetBackgroundColor
 29835:  *
 29835:  * Sets the window background paint color.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: NS_METHOD nsWindow::SetBackgroundColor(const nscolor &aColor)
     1: {
     1:   nsBaseWidget::SetBackgroundColor(aColor);
     1: 
     1:   if (mBrush)
     1:     ::DeleteObject(mBrush);
     1: 
     1:   mBrush = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
164874:   if (mWnd != nullptr) {
 25349:     ::SetClassLongPtrW(mWnd, GCLP_HBRBACKGROUND, (LONG_PTR)mBrush);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetCursor
 29835:  *
 29835:  * SetCursor and related utilities for manging cursor state.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: // Set this component cursor
     1: NS_METHOD nsWindow::SetCursor(nsCursor aCursor)
     1: {
     1:   // Only change cursor if it's changing
     1: 
     1:   //XXX mCursor isn't always right.  Scrollbars and others change it, too.
     1:   //XXX If we want this optimization we need a better way to do it.
     1:   //if (aCursor != mCursor) {
164874:   HCURSOR newCursor = nullptr;
     1: 
     1:   switch (aCursor) {
     1:     case eCursor_select:
164874:       newCursor = ::LoadCursor(nullptr, IDC_IBEAM);
     1:       break;
     1: 
     1:     case eCursor_wait:
164874:       newCursor = ::LoadCursor(nullptr, IDC_WAIT);
     1:       break;
     1: 
     1:     case eCursor_hyperlink:
     1:     {
164874:       newCursor = ::LoadCursor(nullptr, IDC_HAND);
     1:       break;
     1:     }
     1: 
     1:     case eCursor_standard:
154014:     case eCursor_context_menu: // XXX See bug 258960.
164874:       newCursor = ::LoadCursor(nullptr, IDC_ARROW);
     1:       break;
     1: 
     1:     case eCursor_n_resize:
     1:     case eCursor_s_resize:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZENS);
     1:       break;
     1: 
     1:     case eCursor_w_resize:
     1:     case eCursor_e_resize:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZEWE);
     1:       break;
     1: 
     1:     case eCursor_nw_resize:
     1:     case eCursor_se_resize:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZENWSE);
     1:       break;
     1: 
     1:     case eCursor_ne_resize:
     1:     case eCursor_sw_resize:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZENESW);
     1:       break;
     1: 
     1:     case eCursor_crosshair:
164874:       newCursor = ::LoadCursor(nullptr, IDC_CROSS);
     1:       break;
     1: 
     1:     case eCursor_move:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZEALL);
     1:       break;
     1: 
     1:     case eCursor_help:
164874:       newCursor = ::LoadCursor(nullptr, IDC_HELP);
     1:       break;
     1: 
     1:     case eCursor_copy: // CSS3
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COPY));
     1:       break;
     1: 
     1:     case eCursor_alias:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ALIAS));
     1:       break;
     1: 
     1:     case eCursor_cell:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_CELL));
     1:       break;
     1: 
     1:     case eCursor_grab:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRAB));
     1:       break;
     1: 
     1:     case eCursor_grabbing:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRABBING));
     1:       break;
     1: 
     1:     case eCursor_spinning:
164874:       newCursor = ::LoadCursor(nullptr, IDC_APPSTARTING);
     1:       break;
     1: 
     1:     case eCursor_zoom_in:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMIN));
     1:       break;
     1: 
     1:     case eCursor_zoom_out:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMOUT));
     1:       break;
     1: 
     1:     case eCursor_not_allowed:
     1:     case eCursor_no_drop:
164874:       newCursor = ::LoadCursor(nullptr, IDC_NO);
     1:       break;
     1: 
     1:     case eCursor_col_resize:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COLRESIZE));
     1:       break;
     1: 
     1:     case eCursor_row_resize:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ROWRESIZE));
     1:       break;
     1: 
     1:     case eCursor_vertical_text:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_VERTICALTEXT));
     1:       break;
     1: 
     1:     case eCursor_all_scroll:
     1:       // XXX not 100% appropriate perhaps
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZEALL);
     1:       break;
     1: 
     1:     case eCursor_nesw_resize:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZENESW);
     1:       break;
     1: 
     1:     case eCursor_nwse_resize:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZENWSE);
     1:       break;
     1: 
     1:     case eCursor_ns_resize:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZENS);
     1:       break;
     1: 
     1:     case eCursor_ew_resize:
164874:       newCursor = ::LoadCursor(nullptr, IDC_SIZEWE);
     1:       break;
     1: 
 10405:     case eCursor_none:
 10405:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_NONE));
 10405:       break;
 10405: 
     1:     default:
     1:       NS_ERROR("Invalid cursor type");
     1:       break;
     1:   }
     1: 
164874:   if (nullptr != newCursor) {
     1:     mCursor = aCursor;
     1:     HCURSOR oldCursor = ::SetCursor(newCursor);
     1:     
 29835:     if (sHCursor == oldCursor) {
 29835:       NS_IF_RELEASE(sCursorImgContainer);
164874:       if (sHCursor != nullptr)
 29835:         ::DestroyIcon(sHCursor);
164874:       sHCursor = nullptr;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29835: // Setting the actual cursor
     1: NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,
108991:                                   uint32_t aHotspotX, uint32_t aHotspotY)
     1: {
 29835:   if (sCursorImgContainer == aCursor && sHCursor) {
 29835:     ::SetCursor(sHCursor);
     1:     return NS_OK;
     1:   }
     1: 
108991:   int32_t width;
108991:   int32_t height;
 30804: 
 30804:   nsresult rv;
 30804:   rv = aCursor->GetWidth(&width);
 30804:   NS_ENSURE_SUCCESS(rv, rv);
 30804:   rv = aCursor->GetHeight(&height);
 30804:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
  6354:   // Reject cursors greater than 128 pixels in either direction, to prevent
     1:   // spoofing.
     1:   // XXX ideally we should rescale. Also, we could modify the API to
     1:   // allow trusted content to set larger cursors.
     1:   if (width > 128 || height > 128)
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
 30804:   HCURSOR cursor;
 79420:   // No scaling
 79420:   gfxIntSize size(0, 0);
 79626:   rv = nsWindowGfx::CreateIcon(aCursor, true, aHotspotX, aHotspotY, size, &cursor);
 30804:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   mCursor = nsCursor(-1);
     1:   ::SetCursor(cursor);
     1: 
 29835:   NS_IF_RELEASE(sCursorImgContainer);
 29835:   sCursorImgContainer = aCursor;
 29835:   NS_ADDREF(sCursorImgContainer);
 29835: 
164874:   if (sHCursor != nullptr)
 29835:     ::DestroyIcon(sHCursor);
 29835:   sHCursor = cursor;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::Get/SetTransparencyMode
 29835:  *
 29835:  * Manage the transparency mode of the top-level window
 29835:  * containing this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: #ifdef MOZ_XUL
 29835: nsTransparencyMode nsWindow::GetTransparencyMode()
 29835: {
 79626:   return GetTopLevelWindow(true)->GetWindowTranslucencyInner();
 29835: }
 29835: 
 29835: void nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
 29835: {
 79626:   GetTopLevelWindow(true)->SetWindowTranslucencyInner(aMode);
 29835: }
 39718: 
 61413: static const nsIntRegion
 61413: RegionFromArray(const nsTArray<nsIntRect>& aRects)
 61413: {
 61413:   nsIntRegion region;
108991:   for (uint32_t i = 0; i < aRects.Length(); ++i) {
 61413:     region.Or(region, aRects[i]);
 61413:   }
 61413:   return region;
 61413: }
 61413: 
 69806: void nsWindow::UpdateOpaqueRegion(const nsIntRegion &aOpaqueRegion)
 61413: {
 61413:   if (!HasGlass() || GetParent())
 39718:     return;
 39718: 
 46200:   // If there is no opaque region or hidechrome=true, set margins
 61413:   // to support a full sheet of glass. Comments in MSDN indicate
 61413:   // all values must be set to -1 to get a full sheet of glass.
 61413:   MARGINS margins = { -1, -1, -1, -1 };
 69806:   if (!aOpaqueRegion.IsEmpty()) {
 59822:     nsIntRect pluginBounds;
 59822:     for (nsIWidget* child = GetFirstChild(); child; child = child->GetNextSibling()) {
 59822:       nsWindowType type;
 59822:       child->GetWindowType(type);
 59822:       if (type == eWindowType_plugin) {
 61413:         // Collect the bounds of all plugins for GetLargestRectangle.
 59822:         nsIntRect childBounds;
 59822:         child->GetBounds(childBounds);
 59822:         pluginBounds.UnionRect(pluginBounds, childBounds);
 59822:       }
 59822:     }
 59822: 
 69806:     nsIntRect clientBounds;
 69806:     GetClientBounds(clientBounds);
 69806: 
 59822:     // Find the largest rectangle and use that to calculate the inset. Our top
 59822:     // priority is to include the bounds of all plugins.
 69806:     nsIntRect largest = aOpaqueRegion.GetLargestRectangle(pluginBounds);
 39718:     margins.cxLeftWidth = largest.x;
 39718:     margins.cxRightWidth = clientBounds.width - largest.XMost();
 39718:     margins.cyBottomHeight = clientBounds.height - largest.YMost();
 57439:     if (mCustomNonClient) {
 51610:       // The minimum glass height must be the caption buttons height,
 51610:       // otherwise the buttons are drawn incorrectly.
129543:       largest.y = std::max<uint32_t>(largest.y,
 56099:                          nsUXThemeData::sCommandButtons[CMDBUTTONIDX_BUTTONBOX].cy);
 39718:     }
 57439:     margins.cyTopHeight = largest.y;
 57439:   }
 46200: 
 46200:   // Only update glass area if there are changes
 39718:   if (memcmp(&mGlassMargins, &margins, sizeof mGlassMargins)) {
 39718:     mGlassMargins = margins;
 39718:     UpdateGlass();
 39718:   }
 39718: }
 39718: 
 46200: void nsWindow::UpdateGlass()
 46200: {
 50770:   MARGINS margins = mGlassMargins;
 46200: 
 46200:   // DWMNCRP_USEWINDOWSTYLE - The non-client rendering area is
 46200:   //                          rendered based on the window style.
 46200:   // DWMNCRP_ENABLED        - The non-client area rendering is
 46200:   //                          enabled; the window style is ignored.
 39718:   DWMNCRENDERINGPOLICY policy = DWMNCRP_USEWINDOWSTYLE;
 50770:   switch (mTransparencyMode) {
 50770:   case eTransparencyBorderlessGlass:
 61976:     // Only adjust if there is some opaque rectangle
 51144:     if (margins.cxLeftWidth >= 0) {
 61976:       margins.cxLeftWidth += kGlassMarginAdjustment;
 61976:       margins.cyTopHeight += kGlassMarginAdjustment;
 61976:       margins.cxRightWidth += kGlassMarginAdjustment;
 61976:       margins.cyBottomHeight += kGlassMarginAdjustment;
 50770:     }
 50770:     // Fall through
 50770:   case eTransparencyGlass:
 39718:     policy = DWMNCRP_ENABLED;
 50770:     break;
 39718:   }
 46200: 
 61412:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 61412:          ("glass margins: left:%d top:%d right:%d bottom:%d\n",
 61412:           margins.cxLeftWidth, margins.cyTopHeight,
 61412:           margins.cxRightWidth, margins.cyBottomHeight));
 61412: 
 46200:   // Extends the window frame behind the client area
 39718:   if (nsUXThemeData::CheckForCompositor()) {
156534:     WinUtils::dwmExtendFrameIntoClientAreaPtr(mWnd, &margins);
156534:     WinUtils::dwmSetWindowAttributePtr(mWnd, DWMWA_NCRENDERING_POLICY, &policy, sizeof policy);
 39718:   }
 39718: }
 29835: #endif
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::HideWindowChrome
 29835:  *
 29835:  * Show or hide window chrome.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: NS_IMETHODIMP nsWindow::HideWindowChrome(bool aShouldHide)
     1: {
 86569:   HWND hwnd = WinUtils::GetTopLevelHWND(mWnd, true);
 86569:   if (!WinUtils::GetNSWindowPtr(hwnd))
     1:   {
     1:     NS_WARNING("Trying to hide window decorations in an embedded context");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 46335:   if (mHideChrome == aShouldHide)
 46335:     return NS_OK;
 46335: 
 25349:   DWORD_PTR style, exStyle;
 46200:   mHideChrome = aShouldHide;
     1:   if (aShouldHide) {
 25349:     DWORD_PTR tempStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
 25349:     DWORD_PTR tempExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
     1: 
 46234:     style = tempStyle & ~(WS_CAPTION | WS_THICKFRAME);
     1:     exStyle = tempExStyle & ~(WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE |
     1:                               WS_EX_CLIENTEDGE | WS_EX_STATICEDGE);
     1: 
     1:     mOldStyle = tempStyle;
     1:     mOldExStyle = tempExStyle;
     1:   }
     1:   else {
 46234:     if (!mOldStyle || !mOldExStyle) {
 25349:       mOldStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
 25349:       mOldExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
 46234:     }
     1: 
     1:     style = mOldStyle;
     1:     exStyle = mOldExStyle;
     1:   }
     1: 
 19016:   VERIFY_WINDOW_STYLE(style);
 25349:   ::SetWindowLongPtrW(hwnd, GWL_STYLE, style);
 25349:   ::SetWindowLongPtrW(hwnd, GWL_EXSTYLE, exStyle);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 80035:  * SECTION: nsWindow::Invalidate
 29835:  *
 32293:  * Invalidate an area of the client for painting.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: // Invalidate this component visible area
 87336: NS_METHOD nsWindow::Invalidate(bool aEraseBackground, 
 80035:                                bool aUpdateNCArea,
 80035:                                bool aIncludeChildren)
 80035: {
 80035:   if (!mWnd) {
 80035:     return NS_OK;
 80035:   }
 80035: 
 29835: #ifdef WIDGET_DEBUG_OUTPUT
     1:   debug_DumpInvalidate(stdout,
     1:                        this,
106838:                        nullptr,
110974:                        nsAutoCString("noname"),
108991:                        (int32_t) mWnd);
 29835: #endif // WIDGET_DEBUG_OUTPUT
 37619: 
 80035:   DWORD flags = RDW_INVALIDATE;
 80035:   if (aEraseBackground) {
 80035:     flags |= RDW_ERASE;
 80035:   }
 80035:   if (aUpdateNCArea) {
 80035:     flags |= RDW_FRAME;
 80035:   }
 80035:   if (aIncludeChildren) {
 80035:     flags |= RDW_ALLCHILDREN;
 80035:   }
 80035: 
164874:   VERIFY(::RedrawWindow(mWnd, nullptr, nullptr, flags));
     1:   return NS_OK;
     1: }
     1: 
     1: // Invalidate this component visible area
 87336: NS_METHOD nsWindow::Invalidate(const nsIntRect & aRect)
     1: {
     1:   if (mWnd)
     1:   {
 29835: #ifdef WIDGET_DEBUG_OUTPUT
     1:     debug_DumpInvalidate(stdout,
     1:                          this,
     1:                          &aRect,
110974:                          nsAutoCString("noname"),
108991:                          (int32_t) mWnd);
 29835: #endif // WIDGET_DEBUG_OUTPUT
     1: 
     1:     RECT rect;
     1: 
     1:     rect.left   = aRect.x;
     1:     rect.top    = aRect.y;
     1:     rect.right  = aRect.x + aRect.width;
     1:     rect.bottom = aRect.y + aRect.height;
     1: 
     1:     VERIFY(::InvalidateRect(mWnd, &rect, FALSE));
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 30075: NS_IMETHODIMP
 79445: nsWindow::MakeFullScreen(bool aFullScreen)
 30075: {
164874:   // taskbarInfo will be nullptr pre Windows 7 until Bug 680227 is resolved.
 77693:   nsCOMPtr<nsIWinTaskbar> taskbarInfo =
 77693:     do_GetService(NS_TASKBAR_CONTRACTID);
 77693: 
 52096:   mFullscreenMode = aFullScreen;
 46335:   if (aFullScreen) {
 51547:     if (mSizeMode == nsSizeMode_Fullscreen)
 51547:       return NS_OK;
 46335:     mOldSizeMode = mSizeMode;
 46335:     SetSizeMode(nsSizeMode_Fullscreen);
 77693: 
 77693:     // Notify the taskbar that we will be entering full screen mode.
 77693:     if (taskbarInfo) {
 77693:       taskbarInfo->PrepareFullScreenHWND(mWnd, TRUE);
 77693:     }
 46335:   } else {
 46335:     SetSizeMode(mOldSizeMode);
 46335:   }
 46335: 
 46335:   UpdateNonClientMargins();
 46335: 
 79445:   bool visible = mIsVisible;
 67849:   if (mOldSizeMode == nsSizeMode_Normal)
 79626:     Show(false);
 53999:   
 46335:   // Will call hide chrome, reposition window. Note this will
 46335:   // also cache dimensions for restoration, so it should only
 46335:   // be called once per fullscreen request.
 51547:   nsresult rv = nsBaseWidget::MakeFullScreen(aFullScreen);
 51547: 
 64073:   if (visible) {
 79626:     Show(true);
 87336:     Invalidate();
 53999:   }
 53999: 
 77693:   // Notify the taskbar that we have exited full screen mode.
 77693:   if (!aFullScreen && taskbarInfo) {
 77693:     taskbarInfo->PrepareFullScreenHWND(mWnd, FALSE);
 77693:   }
 77693: 
108457:   if (mWidgetListener)
108457:     mWidgetListener->SizeModeChanged(mSizeMode);
 51547: 
 51547:   return rv;
 30075: }
 30075: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Native data storage
 29835:  *
 29835:  * nsIWidget::GetNativeData
 29835:  * nsIWidget::FreeNativeData
 29835:  *
 29835:  * Set or clear native data based on a constant.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: // Return some native data according to aDataType
108991: void* nsWindow::GetNativeData(uint32_t aDataType)
     1: {
 57092:   nsAutoString className;
     1:   switch (aDataType) {
 52079:     case NS_NATIVE_TMP_WINDOW:
 57092:       GetWindowClass(className);
 54349:       return (void*)::CreateWindowExW(mIsRTL ? WS_EX_LAYOUTRTL : 0,
 57092:                                       className.get(),
 52079:                                       L"",
 52079:                                       WS_CHILD,
 52079:                                       CW_USEDEFAULT,
 52079:                                       CW_USEDEFAULT,
 52079:                                       CW_USEDEFAULT,
 52079:                                       CW_USEDEFAULT,
 52079:                                       mWnd,
164874:                                       nullptr,
 52079:                                       nsToolkit::mDllInstance,
164874:                                       nullptr);
 21999:     case NS_NATIVE_PLUGIN_PORT:
     1:     case NS_NATIVE_WIDGET:
     1:     case NS_NATIVE_WINDOW:
 77658:     case NS_NATIVE_SHAREABLE_WINDOW:
     1:       return (void*)mWnd;
     1:     case NS_NATIVE_GRAPHIC:
     1:       // XXX:  This is sleezy!!  Remember to Release the DC after using it!
     1: #ifdef MOZ_XUL
 16601:       return (void*)(eTransparencyTransparent == mTransparencyMode) ?
     1:         mMemoryDC : ::GetDC(mWnd);
     1: #else
     1:       return (void*)::GetDC(mWnd);
     1: #endif
 24836: 
 25395:     case NS_NATIVE_TSF_THREAD_MGR:
 25395:     case NS_NATIVE_TSF_CATEGORY_MGR:
 25395:     case NS_NATIVE_TSF_DISPLAY_ATTR_MGR:
134067:       return IMEHandler::GetNativeData(aDataType);
 24836: 
     1:     default:
     1:       break;
     1:   }
     1: 
164874:   return nullptr;
     1: }
     1: 
 29835: // Free some native data according to aDataType
108991: void nsWindow::FreeNativeData(void * data, uint32_t aDataType)
     1: {
     1:   switch (aDataType)
     1:   {
     1:     case NS_NATIVE_GRAPHIC:
     1: #ifdef MOZ_XUL
 16601:       if (eTransparencyTransparent != mTransparencyMode)
     1:         ::ReleaseDC(mWnd, (HDC)data);
     1: #else
     1:       ::ReleaseDC(mWnd, (HDC)data);
     1: #endif
     1:       break;
     1:     case NS_NATIVE_WIDGET:
     1:     case NS_NATIVE_WINDOW:
     1:     case NS_NATIVE_PLUGIN_PORT:
     1:       break;
     1:     default:
     1:       break;
     1:   }
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetTitle
 29835:  *
 29835:  * Set the main windows title text.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: NS_METHOD nsWindow::SetTitle(const nsAString& aTitle)
 29835: {
 29835:   const nsString& strTitle = PromiseFlatString(aTitle);
 29835:   ::SendMessageW(mWnd, WM_SETTEXT, (WPARAM)0, (LPARAM)(LPCWSTR)strTitle.get());
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetIcon
 29835:  *
 29835:  * Set the main windows icon.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: NS_METHOD nsWindow::SetIcon(const nsAString& aIconSpec) 
 29835: {
 29835:   // Assume the given string is a local identifier for an icon file.
 29835: 
101111:   nsCOMPtr<nsIFile> iconFile;
 29835:   ResolveIconName(aIconSpec, NS_LITERAL_STRING(".ico"),
 29835:                   getter_AddRefs(iconFile));
 29835:   if (!iconFile)
 29835:     return NS_OK; // not an error if icon is not found
 29835: 
 29835:   nsAutoString iconPath;
 29835:   iconFile->GetPath(iconPath);
 29835: 
 29835:   // XXX this should use MZLU (see bug 239279)
 29835: 
 29835:   ::SetLastError(0);
 29835: 
164874:   HICON bigIcon = (HICON)::LoadImageW(nullptr,
 29835:                                       (LPCWSTR)iconPath.get(),
 29835:                                       IMAGE_ICON,
 29835:                                       ::GetSystemMetrics(SM_CXICON),
 29835:                                       ::GetSystemMetrics(SM_CYICON),
 29835:                                       LR_LOADFROMFILE );
164874:   HICON smallIcon = (HICON)::LoadImageW(nullptr,
 29835:                                         (LPCWSTR)iconPath.get(),
 29835:                                         IMAGE_ICON,
 29835:                                         ::GetSystemMetrics(SM_CXSMICON),
 29835:                                         ::GetSystemMetrics(SM_CYSMICON),
 29835:                                         LR_LOADFROMFILE );
 29835: 
 29835:   if (bigIcon) {
 29835:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)bigIcon);
 29835:     if (icon)
 29835:       ::DestroyIcon(icon);
103754:     mIconBig = bigIcon;
 29835:   }
 29835: #ifdef DEBUG_SetIcon
 29835:   else {
 29835:     NS_LossyConvertUTF16toASCII cPath(iconPath);
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:            ("\nIcon load error; icon=%s, rc=0x%08X\n\n", 
 76714:             cPath.get(), ::GetLastError()));
 29835:   }
 29835: #endif
 29835:   if (smallIcon) {
 29835:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)smallIcon);
 29835:     if (icon)
 29835:       ::DestroyIcon(icon);
103754:     mIconSmall = smallIcon;
 29835:   }
 29835: #ifdef DEBUG_SetIcon
 29835:   else {
 29835:     NS_LossyConvertUTF16toASCII cPath(iconPath);
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:            ("\nSmall icon load error; icon=%s, rc=0x%08X\n\n", 
 76714:             cPath.get(), ::GetLastError()));
 29835:   }
 29835: #endif
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::WidgetToScreenOffset
 29835:  *
 29835:  * Return this widget's origin in screen coordinates.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: nsIntPoint nsWindow::WidgetToScreenOffset()
 29835: {
 29835:   POINT point;
 29835:   point.x = 0;
 29835:   point.y = 0;
 29835:   ::ClientToScreen(mWnd, &point);
 29835:   return nsIntPoint(point.x, point.y);
 29835: }
 29835: 
 48256: nsIntSize nsWindow::ClientToWindowSize(const nsIntSize& aClientSize)
 48256: {
106923:   if (mWindowType == eWindowType_popup && !IsPopupWithTitleBar())
 48256:     return aClientSize;
 48256: 
 48256:   // just use (200, 200) as the position
 48256:   RECT r;
 48256:   r.left = 200;
 48256:   r.top = 200;
 48256:   r.right = 200 + aClientSize.width;
 48256:   r.bottom = 200 + aClientSize.height;
 79626:   ::AdjustWindowRectEx(&r, WindowStyle(), false, WindowExStyle());
 48256: 
 48256:   return nsIntSize(r.right - r.left, r.bottom - r.top);
 48256: }
 48256: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::EnableDragDrop
 29835:  *
 29835:  * Enables/Disables drag and drop of files on this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: NS_METHOD nsWindow::EnableDragDrop(bool aEnable)
 29835: {
 43018:   NS_ASSERTION(mWnd, "nsWindow::EnableDragDrop() called after Destroy()");
 43018: 
 29835:   nsresult rv = NS_ERROR_FAILURE;
 29835:   if (aEnable) {
106838:     if (nullptr == mNativeDragTarget) {
 29835:        mNativeDragTarget = new nsNativeDragTarget(this);
164874:        if (nullptr != mNativeDragTarget) {
 29835:          mNativeDragTarget->AddRef();
 29835:          if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget,TRUE,FALSE)) {
 29835:            if (S_OK == ::RegisterDragDrop(mWnd, (LPDROPTARGET)mNativeDragTarget)) {
 29835:              rv = NS_OK;
 29835:            }
 29835:          }
 29835:        }
 29835:     }
 29835:   } else {
164874:     if (nullptr != mWnd && nullptr != mNativeDragTarget) {
 29835:       ::RevokeDragDrop(mWnd);
 29835:       if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget, FALSE, TRUE)) {
 29835:         rv = NS_OK;
 29835:       }
 43018:       mNativeDragTarget->DragCancel();
 29835:       NS_RELEASE(mNativeDragTarget);
 29835:     }
 29835:   }
 29835:   return rv;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::CaptureMouse
 29835:  *
 29835:  * Enables/Disables system mouse capture.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: NS_METHOD nsWindow::CaptureMouse(bool aCapture)
 29835: {
 29835:   if (!nsToolkit::gMouseTrailer) {
 29835:     NS_ERROR("nsWindow::CaptureMouse called after nsToolkit destroyed");
 29835:     return NS_OK;
 29835:   }
 29835: 
 29835:   if (aCapture) {
 29835:     nsToolkit::gMouseTrailer->SetCaptureWindow(mWnd);
 29835:     ::SetCapture(mWnd);
 29835:   } else {
164874:     nsToolkit::gMouseTrailer->SetCaptureWindow(nullptr);
 29835:     ::ReleaseCapture();
 29835:   }
 60909:   sIsInMouseCapture = aCapture;
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::CaptureRollupEvents
 29835:  *
 29835:  * Dealing with event rollup on destroy for popups. Enables &
 29835:  * Disables system capture of any and all events that would
 29835:  * cause a dropdown to be rolled up.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: NS_IMETHODIMP nsWindow::CaptureRollupEvents(nsIRollupListener * aListener,
120177:                                             bool aDoCapture)
 29835: {
 29835:   if (aDoCapture) {
120177:     gRollupListener = aListener;
 29835:     if (!sMsgFilterHook && !sCallProcHook && !sCallMouseHook) {
 29835:       RegisterSpecialDropdownHooks();
 29835:     }
 79626:     sProcessHook = true;
 29835:   } else {
120177:     gRollupListener = nullptr;
 79626:     sProcessHook = false;
 29835:     UnregisterSpecialDropdownHooks();
 29835:   }
 29835: 
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::GetAttention
 29835:  *
 29835:  * Bring this window to the user's attention.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Draw user's attention to this window until it comes to foreground.
 29835: NS_IMETHODIMP
108991: nsWindow::GetAttention(int32_t aCycleCount)
 29835: {
 29835:   // Got window?
 29835:   if (!mWnd)
 29835:     return NS_ERROR_NOT_INITIALIZED;
 29835: 
 86569:   HWND flashWnd = WinUtils::GetTopLevelHWND(mWnd, false, false);
 29835:   HWND fgWnd = ::GetForegroundWindow();
 80121:   // Don't flash if the flash count is 0 or if the foreground window is our
 80121:   // window handle or that of our owned-most window.
 80121:   if (aCycleCount == 0 || 
 80121:       flashWnd == fgWnd ||
 86569:       flashWnd == WinUtils::GetTopLevelHWND(fgWnd, false, false)) {
 29835:     return NS_OK;
 80121:   }
 29835: 
 29835:   DWORD defaultCycleCount = 0;
 29835:   ::SystemParametersInfo(SPI_GETFOREGROUNDFLASHCOUNT, 0, &defaultCycleCount, 0);
 29835: 
 29835:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
 29835:     FLASHW_ALL, aCycleCount > 0 ? aCycleCount : defaultCycleCount, 0 };
 29835:   ::FlashWindowEx(&flashInfo);
 68855: 
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: void nsWindow::StopFlashing()
 29835: {
 29835:   HWND flashWnd = mWnd;
 29835:   while (HWND ownerWnd = ::GetWindow(flashWnd, GW_OWNER)) {
 29835:     flashWnd = ownerWnd;
 29835:   }
 29835: 
 29835:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
 29835:     FLASHW_STOP, 0, 0 };
 29835:   ::FlashWindowEx(&flashInfo);
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::HasPendingInputEvent
 29835:  *
 29835:  * Ask whether there user input events pending.  All input events are
 29835:  * included, including those not targeted at this nsIwidget instance.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: bool
 29835: nsWindow::HasPendingInputEvent()
 29835: {
 29835:   // If there is pending input or the user is currently
 29835:   // moving the window then return true.
 29835:   // Note: When the user is moving the window WIN32 spins
 29835:   // a separate event loop and input events are not
 29835:   // reported to the application.
 30504:   if (HIWORD(GetQueueStatus(QS_INPUT)))
 79626:     return true;
 30504:   GUITHREADINFO guiInfo;
 30504:   guiInfo.cbSize = sizeof(GUITHREADINFO);
 30504:   if (!GetGUIThreadInfo(GetCurrentThreadId(), &guiInfo))
 79626:     return false;
 30504:   return GUI_INMOVESIZE == (guiInfo.flags & GUI_INMOVESIZE);
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 40028:  * SECTION: nsIWidget::GetLayerManager
 40028:  *
 40028:  * Get the layer manager associated with this widget.
 40028:  *
 40028:  **************************************************************/
 40028: 
 60398: struct LayerManagerPrefs {
 60398:   LayerManagerPrefs()
 79626:     : mAccelerateByDefault(true)
 79626:     , mDisableAcceleration(false)
 79626:     , mPreferOpenGL(false)
 79626:     , mPreferD3D9(false)
 60398:   {}
 79445:   bool mAccelerateByDefault;
 79445:   bool mDisableAcceleration;
 79445:   bool mForceAcceleration;
 79445:   bool mPreferOpenGL;
 79445:   bool mPreferD3D9;
 60398: };
 60398: 
 60398: static void
 60398: GetLayerManagerPrefs(LayerManagerPrefs* aManagerPrefs)
 60398: {
 70956:   Preferences::GetBool("layers.acceleration.disabled",
 60398:                        &aManagerPrefs->mDisableAcceleration);
 70956:   Preferences::GetBool("layers.acceleration.force-enabled",
 60833:                        &aManagerPrefs->mForceAcceleration);
 70956:   Preferences::GetBool("layers.prefer-opengl",
 60398:                        &aManagerPrefs->mPreferOpenGL);
 70956:   Preferences::GetBool("layers.prefer-d3d9",
 60398:                        &aManagerPrefs->mPreferD3D9);
 60398: 
 60398:   const char *acceleratedEnv = PR_GetEnv("MOZ_ACCELERATED");
 60398:   aManagerPrefs->mAccelerateByDefault =
 60398:     aManagerPrefs->mAccelerateByDefault ||
 60398:     (acceleratedEnv && (*acceleratedEnv != '0'));
 60398: 
 79445:   bool safeMode = false;
 60398:   nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
 60398:   if (xr)
 60398:     xr->GetInSafeMode(&safeMode);
 60398:   aManagerPrefs->mDisableAcceleration =
 60398:     aManagerPrefs->mDisableAcceleration || safeMode;
 60398: }
 60398: 
 75149: LayerManager*
141527: nsWindow::GetLayerManager(PLayerTransactionChild* aShadowManager,
 75149:                           LayersBackend aBackendHint,
 75149:                           LayerManagerPersistence aPersistence,
 75149:                           bool* aAllowRetaining)
 55858: {
 55858:   if (aAllowRetaining) {
 55858:     *aAllowRetaining = true;
 55858:   }
 55858: 
 57918: #ifdef MOZ_ENABLE_D3D10_LAYER
 57918:   if (mLayerManager) {
181945:     if (mLayerManager->GetBackendType() == LayersBackend::LAYERS_D3D10)
105710:     {
105710:       LayerManagerD3D10 *layerManagerD3D10 =
105710:         static_cast<LayerManagerD3D10*>(mLayerManager.get());
 57918:       if (layerManagerD3D10->device() !=
 57918:           gfxWindowsPlatform::GetPlatform()->GetD3D10Device())
 57918:       {
108476:         MOZ_ASSERT(!mLayerManager->IsInTransaction());
108476: 
 58810:         mLayerManager->Destroy();
106838:         mLayerManager = nullptr;
 57918:       }
 57918:     }
 57918:   }
 57918: #endif
 57918: 
 79695:   RECT windowRect;
 79695:   ::GetClientRect(mWnd, &windowRect);
 79695: 
143173:   // Try OMTC first.
143173:   if (!mLayerManager && ShouldUseOffMainThreadCompositing()) {
143173:     // e10s uses the parameter to pass in the shadow manager from the TabChild
143173:     // so we don't expect to see it there since this doesn't support e10s.
143173:     NS_ASSERTION(aShadowManager == nullptr, "Async Compositor not supported with e10s");
143173:     CreateCompositor();
143173:   }
143173: 
 58814:   if (!mLayerManager ||
 58814:       (!sAllowD3D9 && aPersistence == LAYER_MANAGER_PERSISTENT &&
181945:         mLayerManager->GetBackendType() == LayersBackend::LAYERS_BASIC &&
143173:         !ShouldUseOffMainThreadCompositing())) {
 58814:     // If D3D9 is not currently allowed but the permanent manager is required,
 58814:     // -and- we're currently using basic layers, run through this check.
 60398:     LayerManagerPrefs prefs;
 60398:     GetLayerManagerPrefs(&prefs);
 51978: 
 51995:     /* We don't currently support using an accelerated layer manager with
 51995:      * transparent windows so don't even try. I'm also not sure if we even
 51995:      * want to support this case. See bug #593471 */
 60398:     if (eTransparencyTransparent == mTransparencyMode ||
 79695:         prefs.mDisableAcceleration ||
 79695:         windowRect.right - windowRect.left > MAX_ACCELERATED_DIMENSION ||
102784:         windowRect.bottom - windowRect.top > MAX_ACCELERATED_DIMENSION)
122281:       mUseLayersAcceleration = false;
 60398:     else if (prefs.mAccelerateByDefault)
122281:       mUseLayersAcceleration = true;
122281: 
122281:     if (mUseLayersAcceleration) {
 58814:       if (aPersistence == LAYER_MANAGER_PERSISTENT && !sAllowD3D9) {
108476:         MOZ_ASSERT(!mLayerManager || !mLayerManager->IsInTransaction());
108476: 
 58814:         // This will clear out our existing layer manager if we have one since
 58814:         // if we hit this with a LayerManager we're always using BasicLayers.
 58814:         nsToolkit::StartAllowingD3D9();
 58814:       }
 58814: 
 54816: #ifdef MOZ_ENABLE_D3D10_LAYER
 81596:       if (!prefs.mPreferD3D9 && !prefs.mPreferOpenGL) {
105710:         nsRefPtr<LayerManagerD3D10> layerManager =
105710:           new LayerManagerD3D10(this);
 91135:         if (layerManager->Initialize(prefs.mForceAcceleration)) {
 54816:           mLayerManager = layerManager;
 54816:         }
 54816:       }
 54816: #endif
 43174: #ifdef MOZ_ENABLE_D3D9_LAYER
 60398:       if (!prefs.mPreferOpenGL && !mLayerManager && sAllowD3D9) {
105710:         nsRefPtr<LayerManagerD3D9> layerManager =
105710:           new LayerManagerD3D9(this);
 91135:         if (layerManager->Initialize(prefs.mForceAcceleration)) {
 43174:           mLayerManager = layerManager;
 43174:         }
 43174:       }
 43174: #endif
 42612:     }
 51995: 
 51995:     // Fall back to software if we couldn't use any hardware backends.
 99815:     if (!mLayerManager) {
 54111:       mLayerManager = CreateBasicLayerManager();
 51995:     }
 99815:   }
 51995: 
 79629:   NS_ASSERTION(mLayerManager, "Couldn't provide a valid layer manager.");
 79629: 
 51995:   return mLayerManager;
 40028: }
 40028: 
 40028: /**************************************************************
 40028:  *
 29835:  * SECTION: nsIWidget::GetThebesSurface
 29835:  *
 29835:  * Get the Thebes surface associated with this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: gfxASurface *nsWindow::GetThebesSurface()
 29835: {
 38727: #ifdef CAIRO_HAS_D2D_SURFACE
 38727:   if (mD2DWindowSurface) {
 38727:     return mD2DWindowSurface;
 38727:   }
 38727: #endif
 29835:   if (mPaintDC)
 29835:     return (new gfxWindowsSurface(mPaintDC));
 29835: 
108991:   uint32_t flags = gfxWindowsSurface::FLAG_TAKE_DC;
 47767:   if (mTransparencyMode != eTransparencyOpaque) {
 47767:       flags |= gfxWindowsSurface::FLAG_IS_TRANSPARENT;
 47767:   }
 47767:   return (new gfxWindowsSurface(mWnd, flags));
 29835: }
 29835: 
 29835: /**************************************************************
 30327:  *
 30327:  * SECTION: nsIWidget::OnDefaultButtonLoaded
 30327:  *
 30327:  * Called after the dialog is loaded and it has a default button.
 30327:  *
 30327:  **************************************************************/
 30327:  
 30327: NS_IMETHODIMP
 30327: nsWindow::OnDefaultButtonLoaded(const nsIntRect &aButtonRect)
 30327: {
 30327:   if (aButtonRect.IsEmpty())
 30327:     return NS_OK;
 30327: 
 30327:   // Don't snap when we are not active.
 30327:   HWND activeWnd = ::GetActiveWindow();
 30327:   if (activeWnd != ::GetForegroundWindow() ||
 86569:       WinUtils::GetTopLevelHWND(mWnd, true) !=
 86569:         WinUtils::GetTopLevelHWND(activeWnd, true)) {
 30327:     return NS_OK;
 30327:   }
 30327: 
 79445:   bool isAlwaysSnapCursor =
 79445:     Preferences::GetBool("ui.cursor_snapping.always_enabled", false);
 30327: 
 30327:   if (!isAlwaysSnapCursor) {
 30327:     BOOL snapDefaultButton;
 30327:     if (!::SystemParametersInfo(SPI_GETSNAPTODEFBUTTON, 0,
 30327:                                 &snapDefaultButton, 0) || !snapDefaultButton)
 30327:       return NS_OK;
 30327:   }
 30327: 
 30327:   nsIntRect widgetRect;
 30327:   nsresult rv = GetScreenBounds(widgetRect);
 30327:   NS_ENSURE_SUCCESS(rv, rv);
 30327:   nsIntRect buttonRect(aButtonRect + widgetRect.TopLeft());
 30327: 
 30327:   nsIntPoint centerOfButton(buttonRect.x + buttonRect.width / 2,
 30327:                             buttonRect.y + buttonRect.height / 2);
 30327:   // The center of the button can be outside of the widget.
 30327:   // E.g., it could be hidden by scrolling.
 30327:   if (!widgetRect.Contains(centerOfButton)) {
 30327:     return NS_OK;
 30327:   }
 30327: 
 30327:   if (!::SetCursorPos(centerOfButton.x, centerOfButton.y)) {
 30327:     NS_ERROR("SetCursorPos failed");
 30327:     return NS_ERROR_FAILURE;
 30327:   }
 30327:   return NS_OK;
 30327: }
 30327: 
 33016: NS_IMETHODIMP
136110: nsWindow::OverrideSystemMouseScrollSpeed(double aOriginalDeltaX,
136110:                                          double aOriginalDeltaY,
136110:                                          double& aOverriddenDeltaX,
136110:                                          double& aOverriddenDeltaY)
 33016: {
 33016:   // The default vertical and horizontal scrolling speed is 3, this is defined
 33016:   // on the document of SystemParametersInfo in MSDN.
108991:   const uint32_t kSystemDefaultScrollingSpeed = 3;
108991: 
136110:   double absOriginDeltaX = Abs(aOriginalDeltaX);
136110:   double absOriginDeltaY = Abs(aOriginalDeltaY);
 37978: 
 33016:   // Compute the simple overridden speed.
136110:   double absComputedOverriddenDeltaX, absComputedOverriddenDeltaY;
 33016:   nsresult rv =
136110:     nsBaseWidget::OverrideSystemMouseScrollSpeed(absOriginDeltaX,
136110:                                                  absOriginDeltaY,
136110:                                                  absComputedOverriddenDeltaX,
136110:                                                  absComputedOverriddenDeltaY);
 33016:   NS_ENSURE_SUCCESS(rv, rv);
 33016: 
136110:   aOverriddenDeltaX = aOriginalDeltaX;
136110:   aOverriddenDeltaY = aOriginalDeltaY;
136110: 
136110:   if (absComputedOverriddenDeltaX == absOriginDeltaX &&
136110:       absComputedOverriddenDeltaY == absOriginDeltaY) {
 33016:     // We don't override now.
 33016:     return NS_OK;
 33016:   }
 33016: 
 33016:   // Otherwise, we should check whether the user customized the system settings
 33016:   // or not.  If the user did it, we should respect the will.
 33016:   UINT systemSpeed;
 33016:   if (!::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &systemSpeed, 0)) {
 33016:     return NS_ERROR_FAILURE;
 33016:   }
 33016:   // The default vertical scrolling speed is 3, this is defined on the document
 33016:   // of SystemParametersInfo in MSDN.
 33016:   if (systemSpeed != kSystemDefaultScrollingSpeed) {
 33016:     return NS_OK;
 33016:   }
 33016: 
 33016:   // Only Vista and later, Windows has the system setting of horizontal
 33016:   // scrolling by the mouse wheel.
172560:   if (IsVistaOrLater()) {
 33016:     if (!::SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0, &systemSpeed, 0)) {
 33016:       return NS_ERROR_FAILURE;
 33016:     }
 33016:     // The default horizontal scrolling speed is 3, this is defined on the
 33016:     // document of SystemParametersInfo in MSDN.
 33016:     if (systemSpeed != kSystemDefaultScrollingSpeed) {
 33016:       return NS_OK;
 33016:     }
 33016:   }
 33016: 
 33016:   // Limit the overridden delta value from the system settings.  The mouse
 33016:   // driver might accelerate the scrolling speed already.  If so, we shouldn't
 33016:   // override the scrolling speed for preventing the unexpected high speed
 33016:   // scrolling.
136110:   double absDeltaLimitX, absDeltaLimitY;
 33016:   rv =
 33016:     nsBaseWidget::OverrideSystemMouseScrollSpeed(kSystemDefaultScrollingSpeed,
136110:                                                  kSystemDefaultScrollingSpeed,
136110:                                                  absDeltaLimitX,
136110:                                                  absDeltaLimitY);
 33016:   NS_ENSURE_SUCCESS(rv, rv);
 33016: 
 37978:   // If the given delta is larger than our computed limitation value, the delta
 37978:   // was accelerated by the mouse driver.  So, we should do nothing here.
136110:   if (absDeltaLimitX <= absOriginDeltaX || absDeltaLimitY <= absOriginDeltaY) {
 37978:     return NS_OK;
 37978:   }
 37978: 
136110:   aOverriddenDeltaX = std::min(absComputedOverriddenDeltaX, absDeltaLimitX);
136110:   aOverriddenDeltaY = std::min(absComputedOverriddenDeltaY, absDeltaLimitY);
136110: 
136110:   if (aOriginalDeltaX < 0) {
136110:     aOverriddenDeltaX *= -1;
136110:   }
136110:   if (aOriginalDeltaY < 0) {
136110:     aOverriddenDeltaY *= -1;
136110:   }
 33016:   return NS_OK;
 33016: }
 33016: 
158268: mozilla::TemporaryRef<mozilla::gfx::DrawTarget>
158268: nsWindow::StartRemoteDrawing()
158268: {
158268:   MOZ_ASSERT(!mCompositeDC);
175170:   NS_ASSERTION(IsRenderMode(gfxWindowsPlatform::RENDER_DIRECT2D) ||
175170:                IsRenderMode(gfxWindowsPlatform::RENDER_GDI),
175170:                "Unexpected render mode for remote drawing");
158268: 
174311:   HDC dc = (HDC)GetNativeData(NS_NATIVE_GRAPHIC);
175170:   nsRefPtr<gfxASurface> surf;
175170: 
175170:   if (mTransparencyMode == eTransparencyTransparent) {
175170:     if (!mTransparentSurface) {
175170:       SetupTranslucentWindowMemoryBitmap(mTransparencyMode);
175170:     }
175170:     if (mTransparentSurface) {
175170:       surf = mTransparentSurface;
175170:     }
175170:   } 
175170:   
175170:   if (!surf) {
158268:     if (!dc) {
158268:       return nullptr;
158268:     }
158268:     uint32_t flags = (mTransparencyMode == eTransparencyOpaque) ? 0 :
158268:         gfxWindowsSurface::FLAG_IS_TRANSPARENT;
175170:     surf = new gfxWindowsSurface(dc, flags);
175170:   }
158268: 
158268:   mozilla::gfx::IntSize size(surf->GetSize().width, surf->GetSize().height);
158268:   if (size.width <= 0 || size.height <= 0) {
175170:     if (dc) {
174311:       FreeNativeData(dc, NS_NATIVE_GRAPHIC);
175170:     }
158268:     return nullptr;
158268:   }
158268: 
158268:   MOZ_ASSERT(!mCompositeDC);
158268:   mCompositeDC = dc;
158268: 
158268:   return mozilla::gfx::Factory::CreateDrawTargetForCairoSurface(surf->CairoSurface(), size);
158268: }
158268: 
158268: void
158268: nsWindow::EndRemoteDrawing()
158268: {
175170:   if (mTransparencyMode == eTransparencyTransparent) {
175170:     MOZ_ASSERT(IsRenderMode(gfxWindowsPlatform::RENDER_DIRECT2D)
175170:                || mTransparentSurface);
174311:     UpdateTranslucentWindow();
175170:   }
175170:   if (mCompositeDC) {
174311:     FreeNativeData(mCompositeDC, NS_NATIVE_GRAPHIC);
175170:   }
158268:   mCompositeDC = nullptr;
158268: }
158268: 
 30327: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Moz Events
 29835:  **
 29835:  ** Moz GUI event management. 
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Mozilla event initialization
 29835:  *
 29835:  * Helpers for initializing moz events.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Event intialization
164381: void nsWindow::InitEvent(WidgetGUIEvent& event, nsIntPoint* aPoint)
 29835: {
106838:   if (nullptr == aPoint) {     // use the point from the event
 29835:     // get the message position in client coordinates
164874:     if (mWnd != nullptr) {
 29835: 
 29835:       DWORD pos = ::GetMessagePos();
 29835:       POINT cpos;
 29835:       
 29835:       cpos.x = GET_X_LPARAM(pos);
 29835:       cpos.y = GET_Y_LPARAM(pos);
 29835: 
 29835:       ::ScreenToClient(mWnd, &cpos);
 29835:       event.refPoint.x = cpos.x;
 29835:       event.refPoint.y = cpos.y;
     1:     } else {
 29835:       event.refPoint.x = 0;
 29835:       event.refPoint.y = 0;
 29835:     }
 29835:   }
 29835:   else {  
 29835:     // use the point override if provided
 29835:     event.refPoint.x = aPoint->x;
 29835:     event.refPoint.y = aPoint->y;
 29835:   }
 29835: 
 29835:   event.time = ::GetMessageTime();
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Moz event dispatch helpers
 29835:  *
 29835:  * Helpers for dispatching different types of moz events.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Main event dispatch. Invokes callback and ProcessEvent method on
 29835: // Event Listener object. Part of nsIWidget.
164381: NS_IMETHODIMP nsWindow::DispatchEvent(WidgetGUIEvent* event,
164381:                                       nsEventStatus& aStatus)
 29835: {
 29835: #ifdef WIDGET_DEBUG_OUTPUT
 29835:   debug_DumpEvent(stdout,
 29835:                   event->widget,
 29835:                   event,
110974:                   nsAutoCString("something"),
108991:                   (int32_t) mWnd);
 29835: #endif // WIDGET_DEBUG_OUTPUT
 29835: 
 29835:   aStatus = nsEventStatus_eIgnore;
 29835: 
 46195:   // Top level windows can have a view attached which requires events be sent
 46195:   // to the underlying base window and the view. Added when we combined the
 46195:   // base chrome window with the main content child for nc client area (title
 46195:   // bar) rendering.
108461:   if (mAttachedWidgetListener) {
108461:     aStatus = mAttachedWidgetListener->HandleEvent(event, mUseAttachedEvents);
108460:   }
108460:   else if (mWidgetListener) {
108460:     aStatus = mWidgetListener->HandleEvent(event, mUseAttachedEvents);
 29835:   }
 29835: 
 29835:   // the window can be destroyed during processing of seemingly innocuous events like, say,
 29835:   // mousedowns due to the magic of scripting. mousedowns will return nsEventStatus_eIgnore,
 29835:   // which causes problems with the deleted window. therefore:
 29835:   if (mOnDestroyCalled)
 29835:     aStatus = nsEventStatus_eConsumeNoDefault;
 29835:   return NS_OK;
 29835: }
 29835: 
108991: bool nsWindow::DispatchStandardEvent(uint32_t aMsg)
 29835: {
164381:   WidgetGUIEvent event(true, aMsg, this);
 29835:   InitEvent(event);
 29835: 
 79445:   bool result = DispatchWindowEvent(&event);
 29835:   return result;
 29835: }
 29835: 
164381: bool nsWindow::DispatchKeyboardEvent(WidgetGUIEvent* event)
159742: {
159742:   nsEventStatus status;
159742:   DispatchEvent(event, status);
159742:   return ConvertStatus(status);
159742: }
159742: 
166866: bool nsWindow::DispatchScrollEvent(WidgetGUIEvent* event)
166866: {
166866:   nsEventStatus status;
166866:   DispatchEvent(event, status);
166866:   return ConvertStatus(status);
166866: }
166866: 
164381: bool nsWindow::DispatchWindowEvent(WidgetGUIEvent* event)
 29835: {
 29835:   nsEventStatus status;
 29835:   DispatchEvent(event, status);
 29835:   return ConvertStatus(status);
 29835: }
 29835: 
164381: bool nsWindow::DispatchWindowEvent(WidgetGUIEvent* event,
164381:                                    nsEventStatus& aStatus)
164381: {
 29835:   DispatchEvent(event, aStatus);
 29835:   return ConvertStatus(aStatus);
 29835: }
 29835: 
 29835: // Recursively dispatch synchronous paints for nsIWidget
 29835: // descendants with invalidated rectangles.
 29835: BOOL CALLBACK nsWindow::DispatchStarvedPaints(HWND aWnd, LPARAM aMsg)
 29835: {
 29835:   LONG_PTR proc = ::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
 29835:   if (proc == (LONG_PTR)&nsWindow::WindowProc) {
 29835:     // its one of our windows so check to see if it has a
 29835:     // invalidated rect. If it does. Dispatch a synchronous
 29835:     // paint.
164874:     if (GetUpdateRect(aWnd, nullptr, FALSE))
 29835:       VERIFY(::UpdateWindow(aWnd));
 29835:   }
 29835:   return TRUE;
 29835: }
 29835: 
 29835: // Check for pending paints and dispatch any pending paint
 29835: // messages for any nsIWidget which is a descendant of the
 29835: // top-level window that *this* window is embedded within.
 29835: //
 29835: // Note: We do not dispatch pending paint messages for non
 29835: // nsIWidget managed windows.
 29835: void nsWindow::DispatchPendingEvents()
 29835: {
 35287:   if (mPainting) {
 35287:     NS_WARNING("We were asked to dispatch pending events during painting, "
 35287:                "denying since that's unsafe.");
 35287:     return;
 35287:   }
 35287: 
 29835:   // We need to ensure that reflow events do not get starved.
 29835:   // At the same time, we don't want to recurse through here
 29835:   // as that would prevent us from dispatching starved paints.
 29835:   static int recursionBlocker = 0;
 29835:   if (recursionBlocker++ == 0) {
106838:     NS_ProcessPendingEvents(nullptr, PR_MillisecondsToInterval(100));
 29835:     --recursionBlocker;
 29835:   }
 29835: 
 87254:   // Quickly check to see if there are any paint events pending,
 87254:   // but only dispatch them if it has been long enough since the
 87254:   // last paint completed.
 87254:   if (::GetQueueStatus(QS_PAINT) &&
 87254:       ((TimeStamp::Now() - mLastPaintEndTime).ToMilliseconds() >= 50)) {
 29835:     // Find the top level window.
 86569:     HWND topWnd = WinUtils::GetTopLevelHWND(mWnd);
 29835: 
 55226:     // Dispatch pending paints for topWnd and all its descendant windows.
 29835:     // Note: EnumChildWindows enumerates all descendant windows not just
 55226:     // the children (but not the window itself).
 55226:     nsWindow::DispatchStarvedPaints(topWnd, 0);
 51212:     ::EnumChildWindows(topWnd, nsWindow::DispatchStarvedPaints, 0);
 29835:   }
 29835: }
 29835: 
 79445: bool nsWindow::DispatchPluginEvent(UINT aMessage,
 49149:                                      WPARAM aWParam,
 49149:                                      LPARAM aLParam,
 79445:                                      bool aDispatchPendingEvents)
 79445: {
145601:   bool ret = nsWindowBase::DispatchPluginEvent(
145603:                WinUtils::InitMSG(aMessage, aWParam, aLParam, mWnd));
151028:   if (aDispatchPendingEvents && !Destroyed()) {
 49149:     DispatchPendingEvents();
 49149:   }
 49149:   return ret;
 49149: }
 49149: 
 29835: // Deal with all sort of mouse event
108991: bool nsWindow::DispatchMouseEvent(uint32_t aEventType, WPARAM wParam,
 79445:                                     LPARAM lParam, bool aIsContextMenuKey,
108991:                                     int16_t aButton, uint16_t aInputSource)
 29835: {
 79445:   bool result = false;
 29835: 
 40944:   UserActivity();
 40944: 
108460:   if (!mWidgetListener) {
 29835:     return result;
 29835:   }
 29835: 
 46202:   switch (aEventType) {
 46202:     case NS_MOUSE_BUTTON_DOWN:
 79626:       CaptureMouse(true);
 46202:       break;
 46202: 
 46202:     // NS_MOUSE_MOVE and NS_MOUSE_EXIT are here because we need to make sure capture flag
 46202:     // isn't left on after a drag where we wouldn't see a button up message (see bug 324131).
 46202:     case NS_MOUSE_BUTTON_UP:
 46202:     case NS_MOUSE_MOVE:
 46202:     case NS_MOUSE_EXIT:
 60909:       if (!(wParam & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) && sIsInMouseCapture)
 79626:         CaptureMouse(false);
 46202:       break;
 46202: 
 46202:     default:
 46202:       break;
 46202: 
 46202:   } // switch
 46202: 
 29835:   nsIntPoint eventPoint;
 29835:   eventPoint.x = GET_X_LPARAM(lParam);
 29835:   eventPoint.y = GET_Y_LPARAM(lParam);
 29835: 
164386:   WidgetMouseEvent event(true, aEventType, this, WidgetMouseEvent::eReal,
164386:                          aIsContextMenuKey ? WidgetMouseEvent::eContextMenuKey :
164386:                                              WidgetMouseEvent::eNormal);
 29835:   if (aEventType == NS_CONTEXTMENU && aIsContextMenuKey) {
 29835:     nsIntPoint zero(0, 0);
 29835:     InitEvent(event, &zero);
 29835:   } else {
 29835:     InitEvent(event, &eventPoint);
 29835:   }
 29835: 
102101:   ModifierKeyState modifierKeyState;
 96889:   modifierKeyState.InitInputEvent(event);
 29835:   event.button    = aButton;
 40485:   event.inputSource = aInputSource;
 29835: 
 29835:   nsIntPoint mpScreen = eventPoint + WidgetToScreenOffset();
 29835: 
 29835:   // Suppress mouse moves caused by widget creation
 29835:   if (aEventType == NS_MOUSE_MOVE) 
 29835:   {
 29835:     if ((sLastMouseMovePoint.x == mpScreen.x) && (sLastMouseMovePoint.y == mpScreen.y))
 29835:       return result;
 29835:     sLastMouseMovePoint.x = mpScreen.x;
 29835:     sLastMouseMovePoint.y = mpScreen.y;
 29835:   }
 29835: 
135921:   bool insideMovementThreshold = (DeprecatedAbs(sLastMousePoint.x - eventPoint.x) < (short)::GetSystemMetrics(SM_CXDOUBLECLK)) &&
135921:                                    (DeprecatedAbs(sLastMousePoint.y - eventPoint.y) < (short)::GetSystemMetrics(SM_CYDOUBLECLK));
 29835: 
 29835:   BYTE eventButton;
 29835:   switch (aButton) {
164386:     case WidgetMouseEvent::eLeftButton:
 29835:       eventButton = VK_LBUTTON;
 29835:       break;
164386:     case WidgetMouseEvent::eMiddleButton:
 29835:       eventButton = VK_MBUTTON;
 29835:       break;
164386:     case WidgetMouseEvent::eRightButton:
 29835:       eventButton = VK_RBUTTON;
 29835:       break;
 29835:     default:
 29835:       eventButton = 0;
 29835:       break;
 29835:   }
 29835: 
 29835:   // Doubleclicks are used to set the click count, then changed to mousedowns
 29835:   // We're going to time double-clicks from mouse *up* to next mouse *down*
 29835:   LONG curMsgTime = ::GetMessageTime();
 29835: 
 29835:   if (aEventType == NS_MOUSE_DOUBLECLICK) {
 29835:     event.message = NS_MOUSE_BUTTON_DOWN;
 29835:     event.button = aButton;
 29835:     sLastClickCount = 2;
 29835:   }
 29835:   else if (aEventType == NS_MOUSE_BUTTON_UP) {
 29835:     // remember when this happened for the next mouse down
 29835:     sLastMousePoint.x = eventPoint.x;
 29835:     sLastMousePoint.y = eventPoint.y;
 29835:     sLastMouseButton = eventButton;
 29835:   }
 29835:   else if (aEventType == NS_MOUSE_BUTTON_DOWN) {
 29835:     // now look to see if we want to convert this to a double- or triple-click
 29835:     if (((curMsgTime - sLastMouseDownTime) < (LONG)::GetDoubleClickTime()) && insideMovementThreshold &&
 29835:         eventButton == sLastMouseButton) {
 29835:       sLastClickCount ++;
 29835:     } else {
 29835:       // reset the click count, to count *this* click
 29835:       sLastClickCount = 1;
 29835:     }
 29835:     // Set last Click time on MouseDown only
 29835:     sLastMouseDownTime = curMsgTime;
 29835:   }
 29835:   else if (aEventType == NS_MOUSE_MOVE && !insideMovementThreshold) {
 29835:     sLastClickCount = 0;
 29835:   }
 29835:   else if (aEventType == NS_MOUSE_EXIT) {
164386:     event.exit = IsTopLevelMouseExit(mWnd) ?
164386:                    WidgetMouseEvent::eTopLevel : WidgetMouseEvent::eChild;
 29835:   }
 29835:   event.clickCount = sLastClickCount;
 29835: 
 29835: #ifdef NS_DEBUG_XX
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:          ("Msg Time: %d Click Count: %d\n", curMsgTime, event.clickCount));
 29835: #endif
 29835: 
 32799:   NPEvent pluginEvent;
 29835: 
 29835:   switch (aEventType)
 29835:   {
 29835:     case NS_MOUSE_BUTTON_DOWN:
 29835:       switch (aButton) {
164386:         case WidgetMouseEvent::eLeftButton:
 29835:           pluginEvent.event = WM_LBUTTONDOWN;
 29835:           break;
164386:         case WidgetMouseEvent::eMiddleButton:
 29835:           pluginEvent.event = WM_MBUTTONDOWN;
 29835:           break;
164386:         case WidgetMouseEvent::eRightButton:
 29835:           pluginEvent.event = WM_RBUTTONDOWN;
 29835:           break;
 29835:         default:
 29835:           break;
 29835:       }
 29835:       break;
 29835:     case NS_MOUSE_BUTTON_UP:
 29835:       switch (aButton) {
164386:         case WidgetMouseEvent::eLeftButton:
 29835:           pluginEvent.event = WM_LBUTTONUP;
 29835:           break;
164386:         case WidgetMouseEvent::eMiddleButton:
 29835:           pluginEvent.event = WM_MBUTTONUP;
 29835:           break;
164386:         case WidgetMouseEvent::eRightButton:
 29835:           pluginEvent.event = WM_RBUTTONUP;
 29835:           break;
 29835:         default:
 29835:           break;
 29835:       }
 29835:       break;
 29835:     case NS_MOUSE_DOUBLECLICK:
 29835:       switch (aButton) {
164386:         case WidgetMouseEvent::eLeftButton:
 29835:           pluginEvent.event = WM_LBUTTONDBLCLK;
 29835:           break;
164386:         case WidgetMouseEvent::eMiddleButton:
 29835:           pluginEvent.event = WM_MBUTTONDBLCLK;
 29835:           break;
164386:         case WidgetMouseEvent::eRightButton:
 29835:           pluginEvent.event = WM_RBUTTONDBLCLK;
 29835:           break;
 29835:         default:
 29835:           break;
 29835:       }
 29835:       break;
 29835:     case NS_MOUSE_MOVE:
 29835:       pluginEvent.event = WM_MOUSEMOVE;
 29835:       break;
 37167:     case NS_MOUSE_EXIT:
 37167:       pluginEvent.event = WM_MOUSELEAVE;
 37167:       break;
 29835:     default:
 29835:       pluginEvent.event = WM_NULL;
 29835:       break;
 29835:   }
 29835: 
 29835:   pluginEvent.wParam = wParam;     // plugins NEED raw OS event flags!
 29835:   pluginEvent.lParam = lParam;
 29835: 
 34743:   event.pluginEvent = (void *)&pluginEvent;
 29835: 
 29835:   // call the event callback
108460:   if (mWidgetListener) {
 29835:     if (nsToolkit::gMouseTrailer)
 29835:       nsToolkit::gMouseTrailer->Disable();
 29835:     if (aEventType == NS_MOUSE_MOVE) {
 60909:       if (nsToolkit::gMouseTrailer && !sIsInMouseCapture) {
 29835:         nsToolkit::gMouseTrailer->SetMouseTrailerWindow(mWnd);
 29835:       }
 29835:       nsIntRect rect;
 29835:       GetBounds(rect);
 29835:       rect.x = 0;
 29835:       rect.y = 0;
 29835: 
154119:       if (rect.Contains(LayoutDeviceIntPoint::ToUntyped(event.refPoint))) {
164874:         if (sCurrentWindow == nullptr || sCurrentWindow != this) {
106838:           if ((nullptr != sCurrentWindow) && (!sCurrentWindow->mInDtor)) {
 29835:             LPARAM pos = sCurrentWindow->lParamToClient(lParamToScreen(lParam));
 79626:             sCurrentWindow->DispatchMouseEvent(NS_MOUSE_EXIT, wParam, pos, false, 
164386:                                                WidgetMouseEvent::eLeftButton,
164386:                                                aInputSource);
 29835:           }
 29835:           sCurrentWindow = this;
 30223:           if (!mInDtor) {
 29835:             LPARAM pos = sCurrentWindow->lParamToClient(lParamToScreen(lParam));
 79626:             sCurrentWindow->DispatchMouseEvent(NS_MOUSE_ENTER, wParam, pos, false,
164386:                                                WidgetMouseEvent::eLeftButton,
164386:                                                aInputSource);
 29835:           }
 29835:         }
 29835:       }
 29835:     } else if (aEventType == NS_MOUSE_EXIT) {
 29835:       if (sCurrentWindow == this) {
106838:         sCurrentWindow = nullptr;
 29835:       }
 29835:     }
 29835: 
 29835:     result = DispatchWindowEvent(&event);
 29835: 
 29835:     if (nsToolkit::gMouseTrailer)
 29835:       nsToolkit::gMouseTrailer->Enable();
 29835: 
 29835:     // Release the widget with NS_IF_RELEASE() just in case
 29835:     // the context menu key code in nsEventListenerManager::HandleEvent()
 29835:     // released it already.
 29835:     return result;
 29835:   }
 29835: 
 29835:   return result;
 29835: }
 29835: 
120269: void nsWindow::DispatchFocusToTopLevelWindow(bool aIsActivate)
120269: {
120269:   if (aIsActivate)
120269:     sJustGotActivate = false;
120269:   sJustGotDeactivate = false;
120269: 
120269:   // retrive the toplevel window or dialog
120269:   HWND curWnd = mWnd;
164874:   HWND toplevelWnd = nullptr;
120269:   while (curWnd) {
120269:     toplevelWnd = curWnd;
120269: 
120269:     nsWindow *win = WinUtils::GetNSWindowPtr(curWnd);
 35499:     if (win) {
 35499:       nsWindowType wintype;
 35499:       win->GetWindowType(wintype);
 35499:       if (wintype == eWindowType_toplevel || wintype == eWindowType_dialog)
 35499:         break;
 35499:     }
 35499: 
120269:     curWnd = ::GetParent(curWnd); // Parent or owner (if has no parent)
120269:   }
120269: 
 29835:   if (toplevelWnd) {
 86569:     nsWindow *win = WinUtils::GetNSWindowPtr(toplevelWnd);
122223:     if (win && win->mWidgetListener) {
122223:       if (aIsActivate) {
122223:         win->mWidgetListener->WindowActivated();
122223:       } else {
122223:         if (!win->BlurEventsSuppressed()) {
122223:           win->mWidgetListener->WindowDeactivated();
122223:         }
122223:       }
108457:     }
108457:   }
 29835: }
 29835: 
 79445: bool nsWindow::IsTopLevelMouseExit(HWND aWnd)
 29835: {
 29835:   DWORD pos = ::GetMessagePos();
 29835:   POINT mp;
 29835:   mp.x = GET_X_LPARAM(pos);
 29835:   mp.y = GET_Y_LPARAM(pos);
 29835:   HWND mouseWnd = ::WindowFromPoint(mp);
 29835: 
 86569:   // WinUtils::GetTopLevelHWND() will return a HWND for the window frame
 86569:   // (which includes the non-client area).  If the mouse has moved into
 86569:   // the non-client area, we should treat it as a top-level exit.
 86569:   HWND mouseTopLevel = WinUtils::GetTopLevelHWND(mouseWnd);
 29835:   if (mouseWnd == mouseTopLevel)
 79626:     return true;
 29835: 
 86569:   return WinUtils::GetTopLevelHWND(aWnd) != mouseTopLevel;
 29835: }
 29835: 
120269: bool nsWindow::BlurEventsSuppressed()
120269: {
120269:   // are they suppressed in this window?
120269:   if (mBlurSuppressLevel > 0)
120269:     return true;
120269: 
120269:   // are they suppressed by any container widget?
120269:   HWND parentWnd = ::GetParent(mWnd);
120269:   if (parentWnd) {
120269:     nsWindow *parent = WinUtils::GetNSWindowPtr(parentWnd);
120269:     if (parent)
120269:       return parent->BlurEventsSuppressed();
120269:   }
120269:   return false;
120269: }
120269: 
120269: // In some circumstances (opening dependent windows) it makes more sense
120269: // (and fixes a crash bug) to not blur the parent window. Called from
120269: // nsFilePicker.
120269: void nsWindow::SuppressBlurEvents(bool aSuppress)
120269: {
120269:   if (aSuppress)
120269:     ++mBlurSuppressLevel; // for this widget
120269:   else {
120269:     NS_ASSERTION(mBlurSuppressLevel > 0, "unbalanced blur event suppression");
120269:     if (mBlurSuppressLevel > 0)
120269:       --mBlurSuppressLevel;
120269:   }
120269: }
120269: 
 79445: bool nsWindow::ConvertStatus(nsEventStatus aStatus)
 29835: {
 29835:   return aStatus == nsEventStatus_eConsumeNoDefault;
 29835: }
 29835: 
 29835: /**************************************************************
 38103:  *
 38103:  * SECTION: IPC
 38103:  *
 38103:  * IPC related helpers.
 38103:  *
 38103:  **************************************************************/
 38103: 
 38103: // static
 38103: bool
 38103: nsWindow::IsAsyncResponseEvent(UINT aMsg, LRESULT& aResult)
 38103: {
 38103:   switch(aMsg) {
 38103:     case WM_SETFOCUS:
 38103:     case WM_KILLFOCUS:
 38103:     case WM_ENABLE:
 38103:     case WM_WINDOWPOSCHANGING:
 38103:     case WM_WINDOWPOSCHANGED:
 38103:     case WM_PARENTNOTIFY:
 38103:     case WM_ACTIVATEAPP:
 38103:     case WM_NCACTIVATE:
 38103:     case WM_ACTIVATE:
 38103:     case WM_CHILDACTIVATE:
 38103:     case WM_IME_SETCONTEXT:
 38103:     case WM_IME_NOTIFY:
 38103:     case WM_SHOWWINDOW:
 38103:     case WM_CANCELMODE:
 38103:     case WM_MOUSEACTIVATE:
 39729:     case WM_CONTEXTMENU:
 38103:       aResult = 0;
 38103:     return true;
 38103: 
 38103:     case WM_SETTINGCHANGE:
 38103:     case WM_SETCURSOR:
 38103:     return false;
 38103:   }
 38103: 
 38103: #ifdef DEBUG
 38103:   char szBuf[200];
 38103:   sprintf(szBuf,
 38103:     "An unhandled ISMEX_SEND message was received during spin loop! (%X)", aMsg);
 38103:   NS_WARNING(szBuf);
 38103: #endif
 38103: 
 38103:   return false;
 38103: }
 38103: 
 38103: void
 38400: nsWindow::IPCWindowProcHandler(UINT& msg, WPARAM& wParam, LPARAM& lParam)
 38103: {
163890:   NS_ASSERTION(!mozilla::ipc::MessageChannel::IsPumpingMessages(),
 38103:                "Failed to prevent a nonqueued message from running!");
 38400: 
 39241:   // Modal UI being displayed in windowless plugins.
163890:   if (mozilla::ipc::MessageChannel::IsSpinLoopActive() &&
164874:       (InSendMessageEx(nullptr) & (ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
 39241:     LRESULT res;
 39241:     if (IsAsyncResponseEvent(msg, res)) {
 39241:       ReplyMessage(res);
 39241:     }
 39241:     return;
 39241:   }
 39241: 
 39241:   // Handle certain sync plugin events sent to the parent which
 39241:   // trigger ipc calls that result in deadlocks.
 39241: 
 40964:   DWORD dwResult = 0;
 79445:   bool handled = false;
 40964: 
 40964:   switch(msg) {
 39241:     // Windowless flash sending WM_ACTIVATE events to the main window
 39241:     // via calls to ShowWindow.
 40964:     case WM_ACTIVATE:
 40964:       if (lParam != 0 && LOWORD(wParam) == WA_ACTIVE &&
 63933:           IsWindow((HWND)lParam)) {
 63933:         // Check for Adobe Reader X sync activate message from their
 63933:         // helper window and ignore. Fixes an annoying focus problem.
164874:         if ((InSendMessageEx(nullptr) & (ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
174217:           wchar_t szClass[10];
 63933:           HWND focusWnd = (HWND)lParam;
 63933:           if (IsWindowVisible(focusWnd) &&
 63933:               GetClassNameW(focusWnd, szClass,
179103:                             sizeof(szClass)/sizeof(char16_t)) &&
 63933:               !wcscmp(szClass, L"Edit") &&
 86569:               !WinUtils::IsOurProcessWindow(focusWnd)) {
 63933:             break;
 63933:           }
 63933:         }
 79626:         handled = true;
 63933:       }
 40964:     break;
 40964:     // Plugins taking or losing focus triggering focus app messages.
 40964:     case WM_SETFOCUS:
 40964:     case WM_KILLFOCUS:
 39241:     // Windowed plugins that pass sys key events to defwndproc generate
 39241:     // WM_SYSCOMMAND events to the main window.
 40964:     case WM_SYSCOMMAND:
 40964:     // Windowed plugins that fire context menu selection events to parent
 40964:     // windows.
 40964:     case WM_CONTEXTMENU:
 42381:     // IME events fired as a result of synchronous focus changes
 42381:     case WM_IME_SETCONTEXT:
 79626:       handled = true;
 40964:     break;
 40964:   }
 40964: 
 40964:   if (handled &&
164874:       (InSendMessageEx(nullptr) & (ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
 40964:     ReplyMessage(dwResult);
 39037:   }
 38103: }
 38103: 
 38103: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Native events
 29835:  **
 29835:  ** Main Windows message handlers and OnXXX handlers for
 29835:  ** Windows event handling.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Wind proc.
 29835:  *
 29835:  * The main Windows event procedures and associated
 29835:  * message processing methods.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: static bool
108991: DisplaySystemMenu(HWND hWnd, nsSizeMode sizeMode, bool isRtl, int32_t x, int32_t y)
 56383: {
 56383:   HMENU hMenu = GetSystemMenu(hWnd, FALSE);
 56383:   if (hMenu) {
 69677:     MENUITEMINFO mii;
 69677:     mii.cbSize = sizeof(MENUITEMINFO);
 69677:     mii.fMask = MIIM_STATE;
 69677:     mii.fType = 0;
 69677: 
 56383:     // update the options
 69677:     mii.fState = MF_ENABLED;
 69677:     SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
 69677:     SetMenuItemInfo(hMenu, SC_SIZE, FALSE, &mii);
 69677:     SetMenuItemInfo(hMenu, SC_MOVE, FALSE, &mii);
 69677:     SetMenuItemInfo(hMenu, SC_MAXIMIZE, FALSE, &mii);
 69677:     SetMenuItemInfo(hMenu, SC_MINIMIZE, FALSE, &mii);
 69677: 
 69677:     mii.fState = MF_GRAYED;
 56383:     switch(sizeMode) {
 56383:       case nsSizeMode_Fullscreen:
 72140:         SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
 56383:         // intentional fall through
 56383:       case nsSizeMode_Maximized:
 69677:         SetMenuItemInfo(hMenu, SC_SIZE, FALSE, &mii);
 69677:         SetMenuItemInfo(hMenu, SC_MOVE, FALSE, &mii);
 69677:         SetMenuItemInfo(hMenu, SC_MAXIMIZE, FALSE, &mii);
 56383:         break;
 56383:       case nsSizeMode_Minimized:
 69677:         SetMenuItemInfo(hMenu, SC_MINIMIZE, FALSE, &mii);
 56383:         break;
 56383:       case nsSizeMode_Normal:
 69677:         SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
 56383:         break;
 56383:     }
 56383:     LPARAM cmd =
 56383:       TrackPopupMenu(hMenu,
 56383:                      (TPM_LEFTBUTTON|TPM_RIGHTBUTTON|
 56383:                       TPM_RETURNCMD|TPM_TOPALIGN|
 56383:                       (isRtl ? TPM_RIGHTALIGN : TPM_LEFTALIGN)),
164874:                      x, y, 0, hWnd, nullptr);
 56383:     if (cmd) {
 56383:       PostMessage(hWnd, WM_SYSCOMMAND, cmd, 0);
 79626:       return true;
 79626:     }
 79626:   }
 79626:   return false;
 56383: }
 56383: 
119111: inline static mozilla::HangMonitor::ActivityType ActivityTypeForMessage(UINT msg)
119111: {
119111:   if ((msg >= WM_KEYFIRST && msg <= WM_IME_KEYLAST) ||
119111:       (msg >= WM_MOUSEFIRST && msg <= WM_MOUSELAST) ||
119111:       (msg >= MOZ_WM_MOUSEWHEEL_FIRST && msg <= MOZ_WM_MOUSEWHEEL_LAST) ||
119111:       (msg >= NS_WM_IMEFIRST && msg <= NS_WM_IMELAST)) {
119111:     return mozilla::HangMonitor::kUIActivity;
119111:   }
119111: 
119111:   // This may not actually be right, but we don't want to reset the timer if
119111:   // we're not actually processing a UI message.
119111:   return mozilla::HangMonitor::kActivityUIAVail;
119111: }
119111: 
 50680: // The WndProc procedure for all nsWindows in this toolkit. This merely catches
 50681: // exceptions and passes the real work to WindowProcInternal. See bug 587406
 50681: // and http://msdn.microsoft.com/en-us/library/ms633573%28VS.85%29.aspx
 29835: LRESULT CALLBACK nsWindow::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 29835: {
119111:   HangMonitor::NotifyActivity(ActivityTypeForMessage(msg));
119111: 
 62476:   return mozilla::CallWindowProcCrashProtected(WindowProcInternal, hWnd, msg, wParam, lParam);
 50680: }
 50680: 
 50680: LRESULT CALLBACK nsWindow::WindowProcInternal(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 50680: {
 59750:   if (::GetWindowLongPtrW(hWnd, GWLP_ID) == eFakeTrackPointScrollableID) {
 59750:     // This message was sent to the FAKETRACKPOINTSCROLLABLE.
 59750:     if (msg == WM_HSCROLL) {
 59750:       // Route WM_HSCROLL messages to the main window.
 59750:       hWnd = ::GetParent(::GetParent(hWnd));
 59750:     } else {
 59750:       // Handle all other messages with its original window procedure.
 59750:       WNDPROC prevWindowProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
 59750:       return ::CallWindowProcW(prevWindowProc, hWnd, msg, wParam, lParam);
 59750:     }
 59750:   }
 59750: 
 68748:   if (msg == MOZ_WM_TRACE) {
 68748:     // This is a tracer event for measuring event loop latency.
 68748:     // See WidgetTraceEvent.cpp for more details.
 68748:     mozilla::SignalTracerThread();
 68748:     return 0;
 68748:   }
 68748: 
 38400:   // Get the window which caused the event and ask it to process the message
125942:   nsWindow *targetWindow = WinUtils::GetNSWindowPtr(hWnd);
125942:   NS_ASSERTION(targetWindow, "nsWindow* is null!");
125942:   if (!targetWindow)
125942:     return ::DefWindowProcW(hWnd, msg, wParam, lParam);
125942: 
125942:   // Hold the window for the life of this method, in case it gets
125942:   // destroyed during processing, unless we're in the dtor already.
125942:   nsCOMPtr<nsISupports> kungFuDeathGrip;
125942:   if (!targetWindow->mInDtor)
125942:     kungFuDeathGrip = do_QueryInterface((nsBaseWidget*)targetWindow);
125942: 
125942:   targetWindow->IPCWindowProcHandler(msg, wParam, lParam);
125942: 
125942:   // Create this here so that we store the last rolled up popup until after
 29835:   // the event has been processed.
 29835:   nsAutoRollup autoRollup;
 29835: 
 29835:   LRESULT popupHandlingResult;
 29835:   if (DealWithPopups(hWnd, msg, wParam, lParam, &popupHandlingResult))
 29835:     return popupHandlingResult;
 29835: 
 29835:   // Call ProcessMessage
 29835:   LRESULT retValue;
125942:   if (targetWindow->ProcessMessage(msg, wParam, lParam, &retValue)) {
 29835:     return retValue;
 29835:   }
 38401: 
125942:   LRESULT res = ::CallWindowProcW(targetWindow->GetPrevWindowProc(),
 29835:                                   hWnd, msg, wParam, lParam);
 38401: 
 38401:   return res;
 29835: }
 29835: 
 29835: // The main windows message processing method for plugins.
 29835: // The result means whether this method processed the native
 29835: // event for plugin. If false, the native event should be
 29835: // processed by the caller self.
 79445: bool
 29835: nsWindow::ProcessMessageForPlugin(const MSG &aMsg,
152201:                                   MSGResult& aResult)
152201: {
152201:   aResult.mResult = 0;
152201:   aResult.mConsumed = true;
152201: 
 79445:   bool eventDispatched = false;
 29835:   switch (aMsg.message) {
 29835:     case WM_CHAR:
 29835:     case WM_SYSCHAR:
152201:       aResult.mResult = ProcessCharMessage(aMsg, &eventDispatched);
 29835:       break;
 29835: 
 29835:     case WM_KEYUP:
 29835:     case WM_SYSKEYUP:
152201:       aResult.mResult = ProcessKeyUpMessage(aMsg, &eventDispatched);
 29835:       break;
 29835: 
 29835:     case WM_KEYDOWN:
 29835:     case WM_SYSKEYDOWN:
152201:       aResult.mResult = ProcessKeyDownMessage(aMsg, &eventDispatched);
 29835:       break;
 29835: 
 29835:     case WM_DEADCHAR:
 29835:     case WM_SYSDEADCHAR:
 29835: 
 29835:     case WM_CUT:
 29835:     case WM_COPY:
 29835:     case WM_PASTE:
 29835:     case WM_CLEAR:
 29835:     case WM_UNDO:
 29835:       break;
 29835: 
 29835:     default:
 79626:       return false;
 29835:   }
 29835: 
152201:   if (!eventDispatched) {
152201:     aResult.mConsumed = nsWindowBase::DispatchPluginEvent(aMsg);
152201:   }
152201:   if (!Destroyed()) {
 29835:     DispatchPendingEvents();
152201:   }
 79626:   return true;
 29835: }
 29835: 
 71484: static void ForceFontUpdate()
 71484: {
 71484:   // update device context font cache
 71484:   // Dirty but easiest way:
 71484:   // Changing nsIPrefBranch entry which triggers callbacks
 71484:   // and flows into calling mDeviceContext->FlushFontCache()
 71484:   // to update the font cache in all the instance of Browsers
 71484:   static const char kPrefName[] = "font.internaluseonly.changed";
 79445:   bool fontInternalChange =
 79445:     Preferences::GetBool(kPrefName, false);
 71484:   Preferences::SetBool(kPrefName, !fontInternalChange);
 71484: }
 71484: 
 79445: static bool CleartypeSettingChanged()
 71484: {
 71484:   static int currentQuality = -1;
 71484:   BYTE quality = cairo_win32_get_system_text_quality();
 71484: 
 71484:   if (currentQuality == quality)
 79626:     return false;
 71484: 
 71484:   if (currentQuality < 0) {
 71484:     currentQuality = quality;
 79626:     return false;
 71484:   }
 71484:   currentQuality = quality;
 79626:   return true;
 71484: }
 71484: 
152198: bool
152198: nsWindow::ExternalHandlerProcessMessage(UINT aMessage,
152198:                                         WPARAM& aWParam,
152198:                                         LPARAM& aLParam,
152198:                                         MSGResult& aResult)
152198: {
152199:   if (mWindowHook.Notify(mWnd, aMessage, aWParam, aLParam, aResult)) {
152198:     return true;
152198:   }
152198: 
152202:   if (IMEHandler::ProcessMessage(this, aMessage, aWParam, aLParam, aResult)) {
152198:     return true;
152198:   }
152198: 
152198:   if (MouseScrollHandler::ProcessMessage(this, aMessage, aWParam, aLParam,
152200:                                          aResult)) {
152198:     return true;
152198:   }
152198: 
152198:   if (PluginHasFocus()) {
152198:     MSG nativeMsg = WinUtils::InitMSG(aMessage, aWParam, aLParam, mWnd);
152201:     if (ProcessMessageForPlugin(nativeMsg, aResult)) {
152198:       return true;
152198:     }
152198:   }
152198: 
152198:   return false;
152198: }
152198: 
 29835: // The main windows message processing method.
152198: bool
152198: nsWindow::ProcessMessage(UINT msg, WPARAM& wParam, LPARAM& lParam,
 29835:                          LRESULT *aRetValue)
 29835: {
 38103: #if defined(EVENT_DEBUG_OUTPUT)
 38103:   // First param shows all events, second param indicates whether
 38103:   // to show mouse move events. See nsWindowDbg for details.
 38103:   PrintEvent(msg, SHOW_REPEAT_EVENTS, SHOW_MOUSEMOVE_EVENTS);
 38103: #endif
 38103: 
152198:   MSGResult msgResult(aRetValue);
152198:   if (ExternalHandlerProcessMessage(msg, wParam, lParam, msgResult)) {
152198:     return (msgResult.mConsumed || !mWnd);
 29835:   }
 29835: 
 79445:   bool result = false;    // call the default nsWindow proc
 29835:   *aRetValue = 0;
 29835: 
 46200:   // Glass hit testing w/custom transparent margins
 46200:   LRESULT dwmHitResult;
 46200:   if (mCustomNonClient &&
 46200:       nsUXThemeData::CheckForCompositor() &&
156534:       WinUtils::dwmDwmDefWindowProcPtr(mWnd, msg, wParam, lParam, &dwmHitResult)) {
 46200:     *aRetValue = dwmHitResult;
 79626:     return true;
 46200:   }
 46200: 
152198:   // (Large blocks of code should be broken out into OnEvent handlers.)
 29835:   switch (msg) {
 29835:     // WM_QUERYENDSESSION must be handled by all windows.
 29835:     // Otherwise Windows thinks the window can just be killed at will.
 29835:     case WM_QUERYENDSESSION:
 29835:       if (sCanQuit == TRI_UNKNOWN)
 29835:       {
 29835:         // Ask if it's ok to quit, and store the answer until we
 29835:         // get WM_ENDSESSION signaling the round is complete.
 29835:         nsCOMPtr<nsIObserverService> obsServ =
 41540:           mozilla::services::GetObserverService();
 29835:         nsCOMPtr<nsISupportsPRBool> cancelQuit =
 29835:           do_CreateInstance(NS_SUPPORTS_PRBOOL_CONTRACTID);
 79626:         cancelQuit->SetData(false);
106838:         obsServ->NotifyObservers(cancelQuit, "quit-application-requested", nullptr);
 29835: 
 79445:         bool abortQuit;
 29835:         cancelQuit->GetData(&abortQuit);
 29835:         sCanQuit = abortQuit ? TRI_FALSE : TRI_TRUE;
 29835:       }
 29835:       *aRetValue = sCanQuit ? TRUE : FALSE;
 79626:       result = true;
 29835:       break;
 68855: 
 29835:     case WM_ENDSESSION:
 34610:     case MOZ_WM_APP_QUIT:
 34610:       if (msg == MOZ_WM_APP_QUIT || (wParam == TRUE && sCanQuit == TRI_TRUE))
 29835:       {
 29835:         // Let's fake a shutdown sequence without actually closing windows etc.
 29835:         // to avoid Windows killing us in the middle. A proper shutdown would
 29835:         // require having a chance to pump some messages. Unfortunately
 29835:         // Windows won't let us do that. Bug 212316.
 29835:         nsCOMPtr<nsIObserverService> obsServ =
 41540:           mozilla::services::GetObserverService();
 29835:         NS_NAMED_LITERAL_STRING(context, "shutdown-persist");
106838:         obsServ->NotifyObservers(nullptr, "quit-application-granted", nullptr);
106838:         obsServ->NotifyObservers(nullptr, "quit-application-forced", nullptr);
106838:         obsServ->NotifyObservers(nullptr, "quit-application", nullptr);
106838:         obsServ->NotifyObservers(nullptr, "profile-change-net-teardown", context.get());
106838:         obsServ->NotifyObservers(nullptr, "profile-change-teardown", context.get());
106838:         obsServ->NotifyObservers(nullptr, "profile-before-change", context.get());
136414:         obsServ->NotifyObservers(nullptr, "profile-before-change2", context.get());
 29835:         // Then a controlled but very quick exit.
 29835:         _exit(0);
 29835:       }
 29835:       sCanQuit = TRI_UNKNOWN;
 79626:       result = true;
 29835:       break;
 29835: 
 29835:     case WM_SYSCOLORCHANGE:
 82569:       OnSysColorChanged();
 29835:       break;
 29835: 
 58327:     case WM_THEMECHANGED:
 29835:     {
 46200:       // Update non-client margin offsets 
 46200:       UpdateNonClientMargins();
 58327:       nsUXThemeData::InitTitlebarInfo();
 55268:       nsUXThemeData::UpdateNativeThemeInfo();
 46200: 
108452:       NotifyThemeChanged();
 29835: 
 29835:       // Invalidate the window so that the repaint will
 29835:       // pick up the new theme.
 87336:       Invalidate(true, true, true);
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_FONTCHANGE:
 29835:     {
126616:       // We only handle this message for the hidden window,
126616:       // as we only need to update the (global) font list once
126616:       // for any given change, not once per window!
126616:       if (mWindowType != eWindowType_invisible) {
126616:         break;
126616:       }
126616: 
 29835:       nsresult rv;
 79445:       bool didChange = false;
 29835: 
 29835:       // update the global font list
 29835:       nsCOMPtr<nsIFontEnumerator> fontEnum = do_GetService("@mozilla.org/gfx/fontenumerator;1", &rv);
 29835:       if (NS_SUCCEEDED(rv)) {
 29835:         fontEnum->UpdateFontList(&didChange);
 71484:         ForceFontUpdate();
 29835:       } //if (NS_SUCCEEDED(rv))
 29835:     }
 29835:     break;
 29835: 
 46200:     case WM_NCCALCSIZE:
 46200:     {
 51380:       if (mCustomNonClient) {
108835:         // If `wParam` is `FALSE`, `lParam` points to a `RECT` that contains
108835:         // the proposed window rectangle for our window.  During our
108835:         // processing of the `WM_NCCALCSIZE` message, we are expected to
108835:         // modify the `RECT` that `lParam` points to, so that its value upon
108835:         // our return is the new client area.  We must return 0 if `wParam`
108835:         // is `FALSE`.
108835:         //
108835:         // If `wParam` is `TRUE`, `lParam` points to a `NCCALCSIZE_PARAMS`
108835:         // struct.  This struct contains an array of 3 `RECT`s, the first of
108835:         // which has the exact same meaning as the `RECT` that is pointed to
108835:         // by `lParam` when `wParam` is `FALSE`.  The remaining `RECT`s, in
108835:         // conjunction with our return value, can
108835:         // be used to specify portions of the source and destination window
108835:         // rectangles that are valid and should be preserved.  We opt not to
108835:         // implement an elaborate client-area preservation technique, and
108835:         // simply return 0, which means "preserve the entire old client area
108835:         // and align it with the upper-left corner of our new client area".
108835:         RECT *clientRect = wParam
108835:                          ? &(reinterpret_cast<NCCALCSIZE_PARAMS*>(lParam))->rgrc[0]
108835:                          : (reinterpret_cast<RECT*>(lParam));
108835:         clientRect->top      += (mCaptionHeight - mNonClientOffset.top);
108835:         clientRect->left     += (mHorResizeMargin - mNonClientOffset.left);
108835:         clientRect->right    -= (mHorResizeMargin - mNonClientOffset.right);
108835:         clientRect->bottom   -= (mVertResizeMargin - mNonClientOffset.bottom);
108835: 
 79626:         result = true;
 46200:         *aRetValue = 0;
 46200:       }
 46200:       break;
 46200:     }
 46200: 
 46200:     case WM_NCHITTEST:
 46200:     {
183346:       if (mMouseTransparent) {
183346:         // Treat this window as transparent.
183346:         *aRetValue = HTTRANSPARENT;
183346:         result = true;
183346:         break;
183346:       }
183346: 
 46200:       /*
 46200:        * If an nc client area margin has been moved, we are responsible
 46200:        * for calculating where the resize margins are and returning the
 46200:        * appropriate set of hit test constants. DwmDefWindowProc (above)
 46200:        * will handle hit testing on it's command buttons if we are on a
 46200:        * composited desktop.
 46200:        */
 46200: 
 51380:       if (!mCustomNonClient)
 46200:         break;
 46200: 
 46200:       *aRetValue =
 46200:         ClientMarginHitTestPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
 79626:       result = true;
 46200:       break;
 46200:     }
 46200: 
 49251:     case WM_SETTEXT:
 49251:       /*
 49251:        * WM_SETTEXT paints the titlebar area. Avoid this if we have a
 49251:        * custom titlebar we paint ourselves.
 49251:        */
 49251: 
 50350:       if (!mCustomNonClient || mNonClientMargins.top == -1)
 49251:         break;
 49251: 
 49251:       {
 49251:         // From msdn, the way around this is to disable the visible state
 49251:         // temporarily. We need the text to be set but we don't want the
 49251:         // redraw to occur.
 49251:         DWORD style = GetWindowLong(mWnd, GWL_STYLE);
 49251:         SetWindowLong(mWnd, GWL_STYLE, style & ~WS_VISIBLE);
 49251:         *aRetValue = CallWindowProcW(GetPrevWindowProc(), mWnd,
 49251:                                      msg, wParam, lParam);
 49251:         SetWindowLong(mWnd, GWL_STYLE, style);
 79626:         return true;
 49251:       }
 49251: 
 49251:     case WM_NCACTIVATE:
 49251:     {
 49251:       /*
 49251:        * WM_NCACTIVATE paints nc areas. Avoid this and re-route painting
 49251:        * through WM_NCPAINT via InvalidateNonClientRegion.
 49251:        */
 49251: 
 49251:       if (!mCustomNonClient)
 49251:         break;
 49251: 
 49251:       // let the dwm handle nc painting on glass
 49251:       if(nsUXThemeData::CheckForCompositor())
 49251:         break;
 49251: 
 49251:       if (wParam == TRUE) {
 49251:         // going active
 49251:         *aRetValue = FALSE; // ignored
 79626:         result = true;
 79626:         UpdateGetWindowInfoCaptionStatus(true);
 49251:         // invalidate to trigger a paint
 49251:         InvalidateNonClientRegion();
 49251:         break;
 49251:       } else {
 49251:         // going inactive
 49251:         *aRetValue = TRUE; // go ahead and deactive
 79626:         result = true;
 79626:         UpdateGetWindowInfoCaptionStatus(false);
 49251:         // invalidate to trigger a paint
 49251:         InvalidateNonClientRegion();
 49251:         break;
 49251:       }
 49251:     }
 49251: 
 49251:     case WM_NCPAINT:
 49251:     {
 49251:       /*
 49251:        * Reset the non-client paint region so that it excludes the
 49251:        * non-client areas we paint manually. Then call defwndproc
 49251:        * to do the actual painting.
 49251:        */
 49251: 
 49251:       if (!mCustomNonClient)
 49251:         break;
 49251: 
 49251:       // let the dwm handle nc painting on glass
 49251:       if(nsUXThemeData::CheckForCompositor())
 49251:         break;
 49251: 
 49251:       HRGN paintRgn = ExcludeNonClientFromPaintRegion((HRGN)wParam);
 49251:       LRESULT res = CallWindowProcW(GetPrevWindowProc(), mWnd,
 49251:                                     msg, (WPARAM)paintRgn, lParam);
 49251:       if (paintRgn != (HRGN)wParam)
 49251:         DeleteObject(paintRgn);
 49251:       *aRetValue = res;
 79626:       result = true;
 49251:     }
 49251:     break;
 49251: 
 29835:     case WM_POWERBROADCAST:
 29835:       switch (wParam)
 29835:       {
 29835:         case PBT_APMSUSPEND:
 82031:           PostSleepWakeNotification(true);
 29835:           break;
 29835:         case PBT_APMRESUMEAUTOMATIC:
 29835:         case PBT_APMRESUMECRITICAL:
 29835:         case PBT_APMRESUMESUSPEND:
 82031:           PostSleepWakeNotification(false);
 82031:           break;
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_CLOSE: // close request
108457:       if (mWidgetListener)
108457:         mWidgetListener->RequestWindowClose(this);
 79626:       result = true; // abort window closure
 29835:       break;
 29835: 
 29835:     case WM_DESTROY:
 29835:       // clean up.
 29835:       OnDestroy();
 79626:       result = true;
 29835:       break;
 29835: 
 29835:     case WM_PAINT:
 71484:       if (CleartypeSettingChanged()) {
 71484:         ForceFontUpdate();
 71484:         gfxFontCache *fc = gfxFontCache::GetCache();
 71484:         if (fc) {
 71484:           fc->Flush();
 71484:         }
 71484:       }
164874:       *aRetValue = (int) OnPaint(nullptr, 0);
 79626:       result = true;
 29835:       break;
 29835: 
 29835:     case WM_PRINTCLIENT:
 47756:       result = OnPaint((HDC) wParam, 0);
 29835:       break;
 29835: 
 29835:     case WM_HOTKEY:
 29835:       result = OnHotKey(wParam, lParam);
 29835:       break;
 29835: 
 29835:     case WM_SYSCHAR:
 29835:     case WM_CHAR:
 29835:     {
145603:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam, mWnd);
106838:       result = ProcessCharMessage(nativeMsg, nullptr);
 29835:       DispatchPendingEvents();
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_SYSKEYUP:
 29835:     case WM_KEYUP:
 29835:     {
145603:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam, mWnd);
 62480:       nativeMsg.time = ::GetMessageTime();
106838:       result = ProcessKeyUpMessage(nativeMsg, nullptr);
 29835:       DispatchPendingEvents();
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_SYSKEYDOWN:
 29835:     case WM_KEYDOWN:
 29835:     {
145603:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam, mWnd);
106838:       result = ProcessKeyDownMessage(nativeMsg, nullptr);
 29835:       DispatchPendingEvents();
 29835:     }
 29835:     break;
 29835: 
 29835:     // say we've dealt with erase background if widget does
 29835:     // not need auto-erasing
 29835:     case WM_ERASEBKGND:
 32194:       if (!AutoErase((HDC)wParam)) {
 29835:         *aRetValue = 1;
 79626:         result = true;
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_MOUSEMOVE:
 29835:     {
 79626:       mMousePresent = true;
 59195: 
 29835:       // Suppress dispatch of pending events
 29835:       // when mouse moves are generated by widget
 29835:       // creation instead of user input.
 29835:       LPARAM lParamScreen = lParamToScreen(lParam);
 29835:       POINT mp;
 29835:       mp.x      = GET_X_LPARAM(lParamScreen);
 29835:       mp.y      = GET_Y_LPARAM(lParamScreen);
 79445:       bool userMovedMouse = false;
 29835:       if ((sLastMouseMovePoint.x != mp.x) || (sLastMouseMovePoint.y != mp.y)) {
 79626:         userMovedMouse = true;
 29835:       }
 29835: 
 40485:       result = DispatchMouseEvent(NS_MOUSE_MOVE, wParam, lParam,
164386:                                   false, WidgetMouseEvent::eLeftButton,
164386:                                   MOUSE_INPUT_SOURCE());
 29835:       if (userMovedMouse) {
 29835:         DispatchPendingEvents();
 29835:       }
 29835:     }
 29835:     break;
 29835: 
 59195:     case WM_NCMOUSEMOVE:
 59195:       // If we receive a mouse move event on non-client chrome, make sure and
 59195:       // send an NS_MOUSE_EXIT event as well.
 60909:       if (mMousePresent && !sIsInMouseCapture)
 59195:         SendMessage(mWnd, WM_MOUSELEAVE, 0, 0);
 59195:     break;
 59195: 
 29835:     case WM_LBUTTONDOWN:
 29835:     {
 29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam,
164386:                                   false, WidgetMouseEvent::eLeftButton,
164386:                                   MOUSE_INPUT_SOURCE());
 29835:       DispatchPendingEvents();
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_LBUTTONUP:
 29835:     {
 29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam,
164386:                                   false, WidgetMouseEvent::eLeftButton,
164386:                                   MOUSE_INPUT_SOURCE());
 29835:       DispatchPendingEvents();
 68855:     }
 68855:     break;
 68855: 
 29835:     case WM_MOUSELEAVE:
 29835:     {
 59195:       if (!mMousePresent)
 59195:         break;
 79626:       mMousePresent = false;
 59195: 
 29835:       // We need to check mouse button states and put them in for
 29835:       // wParam.
 29835:       WPARAM mouseState = (GetKeyState(VK_LBUTTON) ? MK_LBUTTON : 0)
 29835:         | (GetKeyState(VK_MBUTTON) ? MK_MBUTTON : 0)
 29835:         | (GetKeyState(VK_RBUTTON) ? MK_RBUTTON : 0);
 29835:       // Synthesize an event position because we don't get one from
 29835:       // WM_MOUSELEAVE.
 29835:       LPARAM pos = lParamToClient(::GetMessagePos());
 79626:       DispatchMouseEvent(NS_MOUSE_EXIT, mouseState, pos, false,
164386:                          WidgetMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_CONTEXTMENU:
 29835:     {
 29835:       // if the context menu is brought up from the keyboard, |lParam|
 48920:       // will be -1.
 29835:       LPARAM pos;
 79445:       bool contextMenukey = false;
 48920:       if (lParam == -1)
 29835:       {
 79626:         contextMenukey = true;
 29835:         pos = lParamToClient(GetMessagePos());
 29835:       }
 29835:       else
 29835:       {
 29835:         pos = lParamToClient(lParam);
 29835:       }
 40485: 
 29835:       result = DispatchMouseEvent(NS_CONTEXTMENU, wParam, pos, contextMenukey,
 29835:                                   contextMenukey ?
164386:                                     WidgetMouseEvent::eLeftButton :
164386:                                     WidgetMouseEvent::eRightButton,
164386:                                   MOUSE_INPUT_SOURCE());
153105:       if (lParam != -1 && !result && mCustomNonClient) {
164386:         WidgetMouseEvent event(true, NS_MOUSE_MOZHITTEST, this,
164386:                                WidgetMouseEvent::eReal,
164386:                                WidgetMouseEvent::eNormal);
155853:         event.refPoint = LayoutDeviceIntPoint(GET_X_LPARAM(pos), GET_Y_LPARAM(pos));
153105:         event.inputSource = MOUSE_INPUT_SOURCE();
153105:         event.mFlags.mOnlyChromeDispatch = true;
153105:         if (DispatchWindowEvent(&event)) {
 55063:           // Blank area hit, throw up the system menu.
 56383:           DisplaySystemMenu(mWnd, mSizeMode, mIsRTL, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
 79626:           result = true;
 55157:         }
 55157:       }
153105:     }
 55157:     break;
 55157: 
 55157:     case WM_LBUTTONDBLCLK:
164386:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam,
164386:                                   lParam, false,
164386:                                   WidgetMouseEvent::eLeftButton,
 46334:                                   MOUSE_INPUT_SOURCE());
 46334:       DispatchPendingEvents();
 46334:       break;
 46334: 
164386:     case WM_MBUTTONDOWN:
164386:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam,
164386:                                   lParam, false,
164386:                                   WidgetMouseEvent::eMiddleButton,
 46334:                                   MOUSE_INPUT_SOURCE());
 46334:       DispatchPendingEvents();
 46334:       break;
 46334: 
164386:     case WM_MBUTTONUP:
164386:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam,
164386:                                   lParam, false,
164386:                                   WidgetMouseEvent::eMiddleButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_MBUTTONDBLCLK:
164386:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam,
164386:                                   lParam, false,
164386:                                   WidgetMouseEvent::eMiddleButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_NCMBUTTONDOWN:
164386:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, 0,
164386:                                   lParamToClient(lParam), false,
164386:                                   WidgetMouseEvent::eMiddleButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_NCMBUTTONUP:
164386:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0,
164386:                                   lParamToClient(lParam), false,
164386:                                   WidgetMouseEvent::eMiddleButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_NCMBUTTONDBLCLK:
164386:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0,
164386:                                   lParamToClient(lParam), false,
164386:                                   WidgetMouseEvent::eMiddleButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_RBUTTONDOWN:
164386:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam,
164386:                                   lParam, false,
164386:                                   WidgetMouseEvent::eRightButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_RBUTTONUP:
164386:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam,
164386:                                   lParam, false,
164386:                                   WidgetMouseEvent::eRightButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_RBUTTONDBLCLK:
164386:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam,
164386:                                   lParam, false,
164386:                                   WidgetMouseEvent::eRightButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_NCRBUTTONDOWN:
164386:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, 0,
164386:                                   lParamToClient(lParam), false,
164386:                                   WidgetMouseEvent::eRightButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
164386:     case WM_NCRBUTTONUP:
164386:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0,
164386:                                   lParamToClient(lParam), false,
164386:                                   WidgetMouseEvent::eRightButton,
164386:                                   MOUSE_INPUT_SOURCE());
164386:       DispatchPendingEvents();
164386:       break;
164386: 
 46334:     case WM_NCRBUTTONDBLCLK:
164386:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0,
164386:                                   lParamToClient(lParam), false,
164386:                                   WidgetMouseEvent::eRightButton,
 46334:                                   MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 46334: 
 63936:     case WM_EXITSIZEMOVE:
 63936:       if (!sIsInMouseCapture) {
108452:         NotifySizeMoveDone();
 63936:       }
 63936:       break;
 63936: 
 71877:     case WM_NCLBUTTONDBLCLK:
 71877:       DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0, lParamToClient(lParam),
164386:                          false, WidgetMouseEvent::eLeftButton,
 71877:                          MOUSE_INPUT_SOURCE());
 71877:       result = 
 71877:         DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0, lParamToClient(lParam),
164386:                            false, WidgetMouseEvent::eLeftButton,
 71877:                            MOUSE_INPUT_SOURCE());
 71877:       DispatchPendingEvents();
 71877:       break;
 71877: 
 29835:     case WM_APPCOMMAND:
185230:       result = HandleAppCommandMsg(wParam, lParam, aRetValue);
 29835:       break;
 29835: 
 29835:     // The WM_ACTIVATE event is fired when a window is raised or lowered,
 29835:     // and the loword of wParam specifies which. But we don't want to tell
 29835:     // the focus system about this until the WM_SETFOCUS or WM_KILLFOCUS
 29835:     // events are fired. Instead, set either the sJustGotActivate or
108457:     // gJustGotDeactivate flags and activate/deactivate once the focus
108457:     // events arrive.
 29835:     case WM_ACTIVATE:
108460:       if (mWidgetListener) {
108991:         int32_t fActive = LOWORD(wParam);
 29835: 
 29835:         if (WA_INACTIVE == fActive) {
120269:           // when minimizing a window, the deactivation and focus events will
108457:           // be fired in the reverse order. Instead, just deactivate right away.
120269:           if (HIWORD(wParam))
108457:             DispatchFocusToTopLevelWindow(false);
 29835:           else
 79626:             sJustGotDeactivate = true;
 68855: 
 29835:           if (mIsTopWidgetWindow)
145592:             mLastKeyboardLayout = KeyboardLayout::GetInstance()->GetLayout();
 29835: 
 29835:         } else {
 29835:           StopFlashing();
 29835: 
 79626:           sJustGotActivate = true;
164386:           WidgetMouseEvent event(true, NS_MOUSE_ACTIVATE, this,
164386:                                  WidgetMouseEvent::eReal);
 29835:           InitEvent(event);
102101:           ModifierKeyState modifierKeyState;
 96889:           modifierKeyState.InitInputEvent(event);
 51212:           DispatchWindowEvent(&event);
 29835:           if (sSwitchKeyboardLayout && mLastKeyboardLayout)
 29835:             ActivateKeyboardLayout(mLastKeyboardLayout, 0);
 68855:         }
 68855:       }
 68855:       break;
 68855: 
 29835:     case WM_MOUSEACTIVATE:
178890:       // A popup with a parent owner should not be activated when clicked but
178890:       // should still allow the mouse event to be fired, so the return value
178890:       // is set to MA_NOACTIVATE. But if the owner isn't the frontmost window,
178890:       // just use default processing so that the window is activated.
178890:       if (IsPopup() && IsOwnerForegroundWindow()) {
 29835:         *aRetValue = MA_NOACTIVATE;
 79626:         result = true;
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_WINDOWPOSCHANGING:
 29835:     {
 29835:       LPWINDOWPOS info = (LPWINDOWPOS)lParam;
 29835:       OnWindowPosChanging(info);
163806:       result = true;
 29835:     }
 29835:     break;
 29835: 
106923:     case WM_GETMINMAXINFO:
106923:     {
106923:       MINMAXINFO* mmi = (MINMAXINFO*)lParam;
106923:       // Set the constraints. The minimum size should also be constrained to the
106923:       // default window maximum size so that it fits on screen.
106923:       mmi->ptMinTrackSize.x =
129543:         std::min((int32_t)mmi->ptMaxTrackSize.x,
129543:                std::max((int32_t)mmi->ptMinTrackSize.x, mSizeConstraints.mMinSize.width));
106923:       mmi->ptMinTrackSize.y =
129543:         std::min((int32_t)mmi->ptMaxTrackSize.y,
129543:         std::max((int32_t)mmi->ptMinTrackSize.y, mSizeConstraints.mMinSize.height));
129543:       mmi->ptMaxTrackSize.x = std::min((int32_t)mmi->ptMaxTrackSize.x, mSizeConstraints.mMaxSize.width);
129543:       mmi->ptMaxTrackSize.y = std::min((int32_t)mmi->ptMaxTrackSize.y, mSizeConstraints.mMaxSize.height);
106923:     }
106923:     break;
106923: 
 29835:     case WM_SETFOCUS:
 60495:       // If previous focused window isn't ours, it must have received the
 60495:       // redirected message.  So, we should forget it.
 86569:       if (!WinUtils::IsOurProcessWindow(HWND(wParam))) {
145607:         RedirectedKeyDownMessageManager::Forget();
 60495:       }
 29835:       if (sJustGotActivate) {
108457:         DispatchFocusToTopLevelWindow(true);
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_KILLFOCUS:
 89672:       if (sJustGotDeactivate) {
108457:         DispatchFocusToTopLevelWindow(false);
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_WINDOWPOSCHANGED:
 29835:     {
 29835:       WINDOWPOS* wp = (LPWINDOWPOS)lParam;
163806:       OnWindowPosChanged(wp);
163806:       result = true;
 31347:     }
 29835:     break;
 29835: 
 29835:     case WM_INPUTLANGCHANGEREQUEST:
 29835:       *aRetValue = TRUE;
 79626:       result = false;
 29835:       break;
 29835: 
 29835:     case WM_INPUTLANGCHANGE:
145592:       KeyboardLayout::GetInstance()->
145592:         OnLayoutChange(reinterpret_cast<HKL>(lParam));
145592:       result = false; // always pass to child window
 29835:       break;
 29835: 
 29835:     case WM_DESTROYCLIPBOARD:
 29835:     {
 29835:       nsIClipboard* clipboard;
 29835:       nsresult rv = CallGetService(kCClipboardCID, &clipboard);
 51212:       if(NS_SUCCEEDED(rv)) {
 29835:         clipboard->EmptyClipboard(nsIClipboard::kGlobalClipboard);
 29835:         NS_RELEASE(clipboard);
 29835:       }
 51212:     }
 29835:     break;
 29835: 
 29835: #ifdef ACCESSIBILITY
 29835:     case WM_GETOBJECT:
 29835:     {
 29835:       *aRetValue = 0;
 73809:       // Do explicit casting to make it working on 64bit systems (see bug 649236
 73809:       // for details).
 73809:       DWORD objId = static_cast<DWORD>(lParam);
 73809:       if (objId == OBJID_CLIENT) { // oleacc.dll will be loaded dynamically
149859:         a11y::Accessible* rootAccessible = GetAccessible(); // Held by a11y cache
 29835:         if (rootAccessible) {
164874:           IAccessible *msaaAccessible = nullptr;
 29835:           rootAccessible->GetNativeInterface((void**)&msaaAccessible); // does an addref
 29835:           if (msaaAccessible) {
 29835:             *aRetValue = LresultFromObject(IID_IAccessible, wParam, msaaAccessible); // does an addref
 29835:             msaaAccessible->Release(); // release extra addref
 79626:             result = true;  // We handled the WM_GETOBJECT message
 29835:           }
 29835:         }
 29835:       }
 29835:     }
 29835: #endif
 29835: 
 29835:     case WM_SYSCOMMAND:
 58330:     {
 58330:       WPARAM filteredWParam = (wParam &0xFFF0);
 29835:       // prevent Windows from trimming the working set. bug 76831
 58330:       if (!sTrimOnMinimize && filteredWParam == SC_MINIMIZE) {
 29835:         ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
 79626:         result = true;
 29835:       }
 56383: 
 56383:       // Handle the system menu manually when we're in full screen mode
 56383:       // so we can set the appropriate options.
 58330:       if (filteredWParam == SC_KEYMENU && lParam == VK_SPACE &&
 56383:           mSizeMode == nsSizeMode_Fullscreen) {
 56383:         DisplaySystemMenu(mWnd, mSizeMode, mIsRTL,
 56383:                           MOZ_SYSCONTEXT_X_POS,
 56383:                           MOZ_SYSCONTEXT_Y_POS);
 79626:         result = true;
 56383:       }
 58330:     }
 29835:     break;
 29835: 
 29835:   case WM_DWMCOMPOSITIONCHANGED:
 57844:     // First, update the compositor state to latest one. All other methods
 57844:     // should use same state as here for consistency painting.
 79626:     nsUXThemeData::CheckForCompositor(true);
 57844: 
 46200:     UpdateNonClientMargins();
 57394:     RemovePropW(mWnd, kManageWindowInfoProperty);
 29835:     BroadcastMsg(mWnd, WM_DWMCOMPOSITIONCHANGED);
108452:     NotifyThemeChanged();
 39718:     UpdateGlass();
 87336:     Invalidate(true, true, true);
 29835:     break;
 29835: 
 41071:   case WM_UPDATEUISTATE:
 41071:   {
 41071:     // If the UI state has changed, fire an event so the UI updates the
 41071:     // keyboard cues based on the system setting and how the window was
 41071:     // opened. For example, a dialog opened via a keyboard press on a button
 41071:     // should enable cues, whereas the same dialog opened via a mouse click of
 41071:     // the button should not.
108991:     int32_t action = LOWORD(wParam);
 41071:     if (action == UIS_SET || action == UIS_CLEAR) {
108991:       int32_t flags = HIWORD(wParam);
108455:       UIStateChangeType showAccelerators = UIStateChangeType_NoChange;
108455:       UIStateChangeType showFocusRings = UIStateChangeType_NoChange;
 41071:       if (flags & UISF_HIDEACCEL)
108455:         showAccelerators = (action == UIS_SET) ? UIStateChangeType_Clear : UIStateChangeType_Set;
 41071:       if (flags & UISF_HIDEFOCUS)
108455:         showFocusRings = (action == UIS_SET) ? UIStateChangeType_Clear : UIStateChangeType_Set;
108455:       NotifyUIStateChanged(showAccelerators, showFocusRings);
 41071:     }
 41071: 
 41071:     break;
 41071:   }
 41071: 
 29835:   /* Gesture support events */
 29835:   case WM_TABLET_QUERYSYSTEMGESTURESTATUS:
 29835:     // According to MS samples, this must be handled to enable
 29835:     // rotational support in multi-touch drivers.
 79626:     result = true;
 29835:     *aRetValue = TABLET_ROTATE_GESTURE_ENABLE;
 29835:     break;
 29835: 
 48711:   case WM_TOUCH:
 48711:     result = OnTouch(wParam, lParam);
 48711:     if (result) {
 48711:       *aRetValue = 0;
 48711:     }
 48711:     break;
 48711: 
 29835:   case WM_GESTURE:
 29835:     result = OnGesture(wParam, lParam);
 29835:     break;
 31443: 
 31443:   case WM_GESTURENOTIFY:
 31443:     {
 31443:       if (mWindowType != eWindowType_invisible &&
 51608:           mWindowType != eWindowType_plugin) {
 51608:         // A GestureNotify event is dispatched to decide which single-finger panning
 51608:         // direction should be active (including none) and if pan feedback should
 51608:         // be displayed. Java and plugin windows can make their own calls.
 31443:         GESTURENOTIFYSTRUCT * gestureinfo = (GESTURENOTIFYSTRUCT*)lParam;
 31443:         nsPointWin touchPoint;
 31443:         touchPoint = gestureinfo->ptsLocation;
 31443:         touchPoint.ScreenToClient(mWnd);
163726:         WidgetGestureNotifyEvent gestureNotifyEvent(true,
163726:                                    NS_GESTURENOTIFY_EVENT_START, this);
154119:         gestureNotifyEvent.refPoint = LayoutDeviceIntPoint::FromUntyped(touchPoint);
 31443:         nsEventStatus status;
 31443:         DispatchEvent(&gestureNotifyEvent, status);
 31443:         mDisplayPanFeedback = gestureNotifyEvent.displayPanFeedback;
 48711:         if (!mTouchWindow)
 31443:           mGesture.SetWinGestureSupport(mWnd, gestureNotifyEvent.panDirection);
 31443:       }
 79626:       result = false; //should always bubble to DefWindowProc
 31443:     }
 31443:     break;
 29835: 
 31218:     case WM_CLEAR:
 31218:     {
163715:       WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_DELETE, this);
 31218:       DispatchWindowEvent(&command);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case WM_CUT:
 31218:     {
163715:       WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_CUT, this);
 31218:       DispatchWindowEvent(&command);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case WM_COPY:
 31218:     {
163715:       WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_COPY, this);
 31218:       DispatchWindowEvent(&command);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case WM_PASTE:
 31218:     {
163715:       WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_PASTE, this);
 31218:       DispatchWindowEvent(&command);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_UNDO:
 31218:     {
163715:       WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_UNDO, this);
 31218:       DispatchWindowEvent(&command);
 31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_REDO:
 31218:     {
163715:       WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_REDO, this);
 31218:       DispatchWindowEvent(&command);
 31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_CANPASTE:
 31218:     {
 31218:       // Support EM_CANPASTE message only when wParam isn't specified or
 31218:       // is plain text format.
 31218:       if (wParam == 0 || wParam == CF_TEXT || wParam == CF_UNICODETEXT) {
163715:         WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_PASTE,
 79626:                                           this, true);
 31218:         DispatchWindowEvent(&command);
 31218:         *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:         result = true;
 31218:       }
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_CANUNDO:
 31218:     {
163715:       WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_UNDO,
 79626:                                         this, true);
 31218:       DispatchWindowEvent(&command);
 31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_CANREDO:
 31218:     {
163715:       WidgetContentCommandEvent command(true, NS_CONTENT_COMMAND_REDO,
 79626:                                         this, true);
 31218:       DispatchWindowEvent(&command);
 31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:       result = true;
 31218:     }
 31218:     break;
 31985: 
 29835:     default:
 29835:     {
 33486:       if (msg == nsAppShell::GetTaskbarButtonCreatedMessage())
 33486:         SetHasTaskbarIconBeenCreated();
 37550:       if (msg == sOOPPPluginFocusEvent) {
 44190:         if (wParam == 1) {
 37550:           // With OOPP, the plugin window exists in another process and is a child of
 37550:           // this window. This window is a placeholder plugin window for the dom. We
 37550:           // receive this event when the child window receives focus. (sent from
 37550:           // PluginInstanceParent.cpp)
 37550:           ::SendMessage(mWnd, WM_MOUSEACTIVATE, 0, 0); // See nsPluginNativeWindowWin.cpp
 44190:         } else {
 44190:           // WM_KILLFOCUS was received by the child process.
 44190:           if (sJustGotDeactivate) {
108457:             DispatchFocusToTopLevelWindow(false);
 44190:           }
 44190:         }
 37550:       }
 29835:     }
 29835:     break;
173674:     case WM_SETTINGCHANGE:
173674:       if (IsWin8OrLater() && lParam &&
173674:           !wcsicmp(L"ConvertibleSlateMode", (wchar_t*)lParam)) {
173674:         // If we're switching into slate mode, switch to Metro for hardware
176774:         // that supports this feature if the pref is set.
176774:         if (GetSystemMetrics(SM_CONVERTIBLESLATEMODE) == 0 &&
176774:             Preferences::GetBool("browser.shell.desktop-auto-switch-enabled",
176774:                                  false)) {
173674:           nsCOMPtr<nsIAppStartup> appStartup(do_GetService(NS_APPSTARTUP_CONTRACTID));
173674:           if (appStartup) {
173674:             appStartup->Quit(nsIAppStartup::eForceQuit |
173674:                              nsIAppStartup::eRestartTouchEnvironment);
173674:           }
173674:         }
173674:       }
173674:     break;
173674: 
 29835:   }
 29835: 
 29835:   //*aRetValue = result;
 29835:   if (mWnd) {
 29835:     return result;
 29835:   }
 29835:   else {
 29835:     //Events which caused mWnd destruction and aren't consumed
 29835:     //will crash during the Windows default processing.
 79626:     return true;
 29835:   }
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Broadcast messaging
 29835:  *
 29835:  * Broadcast messages to all windows.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Enumerate all child windows sending aMsg to each of them
 29835: BOOL CALLBACK nsWindow::BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg)
 29835: {
 29835:   WNDPROC winProc = (WNDPROC)::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
 29835:   if (winProc == &nsWindow::WindowProc) {
 29835:     // it's one of our windows so go ahead and send a message to it
 29835:     ::CallWindowProcW(winProc, aWnd, aMsg, 0, 0);
 29835:   }
 29835:   return TRUE;
 29835: }
 29835: 
 29835: // Enumerate all top level windows specifying that the children of each
 29835: // top level window should be enumerated. Do *not* send the message to
 29835: // each top level window since it is assumed that the toolkit will send
 29835: // aMsg to them directly.
 29835: BOOL CALLBACK nsWindow::BroadcastMsg(HWND aTopWindow, LPARAM aMsg)
 29835: {
 29835:   // Iterate each of aTopWindows child windows sending the aMsg
 29835:   // to each of them.
 29835:   ::EnumChildWindows(aTopWindow, nsWindow::BroadcastMsgToChildren, aMsg);
 29835:   return TRUE;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Event processing helpers
 29835:  *
 29835:  * Special processing for certain event types and 
 29835:  * synthesized events.
 29835:  *
 29835:  **************************************************************/
 29835: 
108991: int32_t
108991: nsWindow::ClientMarginHitTestPoint(int32_t mx, int32_t my)
 46200: {
 87238:   if (mSizeMode == nsSizeMode_Minimized ||
 87238:       mSizeMode == nsSizeMode_Fullscreen) {
 87238:     return HTCLIENT;
 87238:   }
 87238: 
 46200:   // Calculations are done in screen coords
 46200:   RECT winRect;
 46200:   GetWindowRect(mWnd, &winRect);
 46200: 
 46200:   // hit return constants:
 46200:   // HTBORDER                     - non-resizable border
 46200:   // HTBOTTOM, HTLEFT, HTRIGHT, HTTOP - resizable border
 46200:   // HTBOTTOMLEFT, HTBOTTOMRIGHT  - resizable corner
 46200:   // HTTOPLEFT, HTTOPRIGHT        - resizable corner
 46200:   // HTCAPTION                    - general title bar area
 46200:   // HTCLIENT                     - area considered the client
 46200:   // HTCLOSE                      - hovering over the close button
 46200:   // HTMAXBUTTON                  - maximize button
 46200:   // HTMINBUTTON                  - minimize button
 46200: 
108991:   int32_t testResult = HTCLIENT;
 46200: 
 87238:   bool isResizable = (mBorderStyle & (eBorderStyle_all |
 87238:                                       eBorderStyle_resizeh |
 87238:                                       eBorderStyle_default)) > 0 ? true : false;
 87238:   if (mSizeMode == nsSizeMode_Maximized)
 87238:     isResizable = false;
 87238: 
124757:   // Ensure being accessible to borders of window.  Even if contents are in
124757:   // this area, the area must behave as border.
135125:   nsIntMargin nonClientSize(std::max(mCaptionHeight - mNonClientOffset.top,
124757:                                      kResizableBorderMinSize),
129543:                             std::max(mHorResizeMargin - mNonClientOffset.right,
124757:                                      kResizableBorderMinSize),
129543:                             std::max(mVertResizeMargin - mNonClientOffset.bottom,
135125:                                      kResizableBorderMinSize),
135125:                             std::max(mHorResizeMargin - mNonClientOffset.left,
124757:                                      kResizableBorderMinSize));
124757: 
124757:   bool allowContentOverride = mSizeMode == nsSizeMode_Maximized ||
124757:                               (mx >= winRect.left + nonClientSize.left &&
124757:                                mx <= winRect.right - nonClientSize.right &&
124757:                                my >= winRect.top + nonClientSize.top &&
124757:                                my <= winRect.bottom - nonClientSize.bottom);
124757: 
124757:   // The border size.  If there is no content under mouse cursor, the border
124757:   // size should be larger than the values in system settings.  Otherwise,
124757:   // contents under the mouse cursor should be able to override the behavior.
124757:   // E.g., user must expect that Firefox button always opens the popup menu
124757:   // even when the user clicks on the above edge of it.
135125:   nsIntMargin borderSize(std::max(nonClientSize.top,    mVertResizeMargin),
129543:                          std::max(nonClientSize.right,  mHorResizeMargin),
135125:                          std::max(nonClientSize.bottom, mVertResizeMargin),
135125:                          std::max(nonClientSize.left,   mHorResizeMargin));
124757: 
 79445:   bool top    = false;
 79445:   bool bottom = false;
 79445:   bool left   = false;
 79445:   bool right  = false;
 46200: 
124757:   if (my >= winRect.top && my < winRect.top + borderSize.top) {
 79626:     top = true;
124757:   } else if (my <= winRect.bottom && my > winRect.bottom - borderSize.bottom) {
 79626:     bottom = true;
124757:   }
124757: 
 87238:   // (the 2x case here doubles the resize area for corners)
124757:   int multiplier = (top || bottom) ? 2 : 1;
124757:   if (mx >= winRect.left &&
124757:       mx < winRect.left + (multiplier * borderSize.left)) {
 79626:     left = true;
124757:   } else if (mx <= winRect.right &&
124757:              mx > winRect.right - (multiplier * borderSize.right)) {
 79626:     right = true;
124757:   }
 46200: 
 87238:   if (isResizable) {
 46200:     if (top) {
 46200:       testResult = HTTOP;
 46200:       if (left)
 46200:         testResult = HTTOPLEFT;
 46200:       else if (right)
 46200:         testResult = HTTOPRIGHT;
 46200:     } else if (bottom) {
 46200:       testResult = HTBOTTOM;
 46200:       if (left)
 46200:         testResult = HTBOTTOMLEFT;
 46200:       else if (right)
 46200:         testResult = HTBOTTOMRIGHT;
 46200:     } else {
 46200:       if (left)
 46200:         testResult = HTLEFT;
 46200:       if (right)
 46200:         testResult = HTRIGHT;
 46200:     }
 87238:   } else {
 87238:     if (top)
 87238:       testResult = HTCAPTION;
 87238:     else if (bottom || left || right)
 87238:       testResult = HTBORDER;
 87238:   }
 46200: 
124758:   if (!sIsInMouseCapture && allowContentOverride) {
153599:     POINT pt = { mx, my };
153599:     ::ScreenToClient(mWnd, &pt);
153599:     if (pt.x == mCachedHitTestPoint.x && pt.y == mCachedHitTestPoint.y &&
153599:         TimeStamp::Now() - mCachedHitTestTime < TimeDuration::FromMilliseconds(HITTEST_CACHE_LIFETIME_MS)) {
153599:       testResult = mCachedHitTestResult;
153599:     } else {
164386:       WidgetMouseEvent event(true, NS_MOUSE_MOZHITTEST, this,
164386:                              WidgetMouseEvent::eReal,
164386:                              WidgetMouseEvent::eNormal);
154119:       event.refPoint = LayoutDeviceIntPoint(pt.x, pt.y);
153105:       event.inputSource = MOUSE_INPUT_SOURCE();
153105:       event.mFlags.mOnlyChromeDispatch = true;
153105:       bool result = DispatchWindowEvent(&event);
 46334:       if (result) {
 46334:         // The mouse is over a blank area
 46334:         testResult = testResult == HTCLIENT ? HTCAPTION : testResult;
 46334: 
 46334:       } else {
 46334:         // There's content over the mouse pointer. Set HTCLIENT
 46334:         // to possibly override a resizer border.
 46334:         testResult = HTCLIENT;
 46334:       }
153599:       mCachedHitTestPoint = pt;
153599:       mCachedHitTestTime = TimeStamp::Now();
153599:       mCachedHitTestResult = testResult;
153599:     }
 46334:   }
 46334: 
 46200:   return testResult;
 46200: }
 46200: 
 82031: void nsWindow::PostSleepWakeNotification(const bool aIsSleepMode)
 82031: {
 82031:   if (aIsSleepMode == gIsSleepMode)
 82031:     return;
 82031: 
 82031:   gIsSleepMode = aIsSleepMode;
 82031: 
 41540:   nsCOMPtr<nsIObserverService> observerService =
 41540:     mozilla::services::GetObserverService();
 29835:   if (observerService)
106838:     observerService->NotifyObservers(nullptr,
121564:       aIsSleepMode ? NS_WIDGET_SLEEP_OBSERVER_TOPIC :
121564:                      NS_WIDGET_WAKE_OBSERVER_TOPIC, nullptr);
 29835: }
 29835: 
 79445: LRESULT nsWindow::ProcessCharMessage(const MSG &aMsg, bool *aEventDispatched)
 29835: {
145599:   if (IMEHandler::IsComposingOn(this)) {
145599:     IMEHandler::NotifyIME(this, REQUEST_TO_COMMIT_COMPOSITION);
145599:   }
 29835:   // These must be checked here too as a lone WM_CHAR could be received
145599:   // if a child window didn't handle it (for example Alt+Space in a content
145599:   // window)
102101:   ModifierKeyState modKeyState;
145592:   NativeKey nativeKey(this, aMsg, modKeyState);
145599:   return static_cast<LRESULT>(nativeKey.HandleCharMessage(aMsg,
145599:                                                           aEventDispatched));
 29835: }
 29835: 
 79445: LRESULT nsWindow::ProcessKeyUpMessage(const MSG &aMsg, bool *aEventDispatched)
 29835: {
145597:   if (IMEHandler::IsComposingOn(this)) {
145597:     return 0;
145597:   }
 29835: 
102101:   ModifierKeyState modKeyState;
145597:   NativeKey nativeKey(this, aMsg, modKeyState);
145597:   return static_cast<LRESULT>(nativeKey.HandleKeyUpMessage(aEventDispatched));
 29835: }
 29835: 
 29835: LRESULT nsWindow::ProcessKeyDownMessage(const MSG &aMsg,
 79445:                                         bool *aEventDispatched)
 29835: {
145608:   // If this method doesn't call NativeKey::HandleKeyDownMessage(), this method
145608:   // must clean up the redirected message information itself.  For more
145608:   // information, see above comment of
145608:   // RedirectedKeyDownMessageManager::AutoFlusher class definition in
145608:   // KeyboardLayout.h.
145607:   RedirectedKeyDownMessageManager::AutoFlusher redirectedMsgFlusher(this, aMsg);
 60495: 
102101:   ModifierKeyState modKeyState;
 29835: 
 29835:   LRESULT result = 0;
134058:   if (!IMEHandler::IsComposingOn(this)) {
145608:     NativeKey nativeKey(this, aMsg, modKeyState);
145608:     result =
145608:       static_cast<LRESULT>(nativeKey.HandleKeyDownMessage(aEventDispatched));
145608:     // HandleKeyDownMessage cleaned up the redirected message information
145608:     // itself, so, we should do nothing.
145607:     redirectedMsgFlusher.Cancel();
 29835:   }
 29835: 
 29835:   if (aMsg.wParam == VK_MENU ||
102101:       (aMsg.wParam == VK_F10 && !modKeyState.IsShift())) {
 29835:     // We need to let Windows handle this keypress,
 79626:     // by returning false, if there's a native menu
 29835:     // bar somewhere in our containing window hierarchy.
 29835:     // Otherwise we handle the keypress and don't pass
 79626:     // it on to Windows, by returning true.
 79445:     bool hasNativeMenu = false;
 29835:     HWND hWnd = mWnd;
 29835:     while (hWnd) {
 29835:       if (::GetMenu(hWnd)) {
 79626:         hasNativeMenu = true;
 29835:         break;
 29835:       }
 29835:       hWnd = ::GetParent(hWnd);
 29835:     }
 29835:     result = !hasNativeMenu;
 29835:   }
 29835: 
 29835:   return result;
 29835: }
 29835: 
 29835: nsresult
108991: nsWindow::SynthesizeNativeKeyEvent(int32_t aNativeKeyboardLayout,
108991:                                    int32_t aNativeKeyCode,
108991:                                    uint32_t aModifierFlags,
 29835:                                    const nsAString& aCharacters,
 29835:                                    const nsAString& aUnmodifiedCharacters)
 29835: {
145592:   KeyboardLayout* keyboardLayout = KeyboardLayout::GetInstance();
145610:   return keyboardLayout->SynthesizeNativeKeyEvent(
145610:            this, aNativeKeyboardLayout, aNativeKeyCode, aModifierFlags,
145610:            aCharacters, aUnmodifiedCharacters);
 29835: }
 29835: 
 33863: nsresult
 33863: nsWindow::SynthesizeNativeMouseEvent(nsIntPoint aPoint,
108991:                                      uint32_t aNativeMessage,
108991:                                      uint32_t aModifierFlags)
 33863: {
114824:   ::SetCursorPos(aPoint.x, aPoint.y);
 33863: 
 33863:   INPUT input;
 33863:   memset(&input, 0, sizeof(input));
 33863: 
 33863:   input.type = INPUT_MOUSE;
 33863:   input.mi.dwFlags = aNativeMessage;
 33863:   ::SendInput(1, &input, sizeof(INPUT));
 33863: 
 33863:   return NS_OK;
 33863: }
 33863: 
 93735: nsresult
 93735: nsWindow::SynthesizeNativeMouseScrollEvent(nsIntPoint aPoint,
108991:                                            uint32_t aNativeMessage,
 93735:                                            double aDeltaX,
 93735:                                            double aDeltaY,
 93735:                                            double aDeltaZ,
108991:                                            uint32_t aModifierFlags,
108991:                                            uint32_t aAdditionalFlags)
 93735: {
 93735:   return MouseScrollHandler::SynthesizeNativeMouseScrollEvent(
 93735:            this, aPoint, aNativeMessage,
 93735:            (aNativeMessage == WM_MOUSEWHEEL || aNativeMessage == WM_VSCROLL) ?
108991:              static_cast<int32_t>(aDeltaY) : static_cast<int32_t>(aDeltaX),
 93735:            aModifierFlags, aAdditionalFlags);
 93735: }
 93735: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: OnXXX message handlers
 29835:  *
 29835:  * For message handlers that need to be broken out or
 29835:  * implemented in specific platform code.
 29835:  *
 29835:  **************************************************************/
 29835: 
163806: void nsWindow::OnWindowPosChanged(WINDOWPOS* wp)
 31345: {
106838:   if (wp == nullptr)
 31345:     return;
 31345: 
 34735: #ifdef WINSTATE_DEBUG_OUTPUT
 86569:   if (mWnd == WinUtils::GetTopLevelHWND(mWnd)) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** OnWindowPosChanged: [  top] "));
 76714:   } else {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** OnWindowPosChanged: [child] "));
 76714:   }
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("WINDOWPOS flags:"));
 76714:   if (wp->flags & SWP_FRAMECHANGED) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_FRAMECHANGED "));
 76714:   }
 76714:   if (wp->flags & SWP_SHOWWINDOW) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_SHOWWINDOW "));
 76714:   }
 76714:   if (wp->flags & SWP_NOSIZE) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOSIZE "));
 76714:   }
 76714:   if (wp->flags & SWP_HIDEWINDOW) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_HIDEWINDOW "));
 76714:   }
 76714:   if (wp->flags & SWP_NOZORDER) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOZORDER "));
 76714:   }
 76714:   if (wp->flags & SWP_NOACTIVATE) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOACTIVATE "));
 76714:   }
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("\n"));
 31345: #endif
 31345: 
 34735:   // Handle window size mode changes
 46335:   if (wp->flags & SWP_FRAMECHANGED && mSizeMode != nsSizeMode_Fullscreen) {
 56369: 
 56369:     // Bug 566135 - Windows theme code calls show window on SW_SHOWMINIMIZED
 56369:     // windows when fullscreen games disable desktop composition. If we're
 56369:     // minimized and not being activated, ignore the event and let windows
 56369:     // handle it.
 56369:     if (mSizeMode == nsSizeMode_Minimized && (wp->flags & SWP_NOACTIVATE))
 56369:       return;
 56369: 
 31345:     WINDOWPLACEMENT pl;
 31345:     pl.length = sizeof(pl);
 31345:     ::GetWindowPlacement(mWnd, &pl);
 31345: 
108457:     // Windows has just changed the size mode of this window. The call to
108457:     // SizeModeChanged will trigger a call into SetSizeMode where we will
 31345:     // set the min/max window state again or for nsSizeMode_Normal, call
 31345:     // SetWindow with a parameter of SW_RESTORE. There's no need however as
 31345:     // this window's mode has already changed. Updating mSizeMode here
 31345:     // insures the SetSizeMode call is a no-op. Addresses a bug on Win7 related
 31345:     // to window docking. (bug 489258)
108457:     if (pl.showCmd == SW_SHOWMAXIMIZED)
108457:       mSizeMode = (mFullscreenMode ? nsSizeMode_Fullscreen : nsSizeMode_Maximized);
108457:     else if (pl.showCmd == SW_SHOWMINIMIZED)
108457:       mSizeMode = nsSizeMode_Minimized;
108457:     else if (mFullscreenMode)
108457:       mSizeMode = nsSizeMode_Fullscreen;
108457:     else
108457:       mSizeMode = nsSizeMode_Normal;
 31345: 
 34786:     // If !sTrimOnMinimize, we minimize windows using SW_SHOWMINIMIZED (See
 34786:     // SetSizeMode for internal calls, and WM_SYSCOMMAND for external). This
 34786:     // prevents the working set from being trimmed but keeps the window active.
 34786:     // After the window is minimized, we need to do some touch up work on the
 34786:     // active window. (bugs 76831 & 499816)
108457:     if (!sTrimOnMinimize && nsSizeMode_Minimized == mSizeMode)
 34786:       ActivateOtherWindowHelper(mWnd);
 34786: 
 34735: #ifdef WINSTATE_DEBUG_OUTPUT
 34735:     switch (mSizeMode) {
 34735:       case nsSizeMode_Normal:
 76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                  ("*** mSizeMode: nsSizeMode_Normal\n"));
 34735:         break;
 34735:       case nsSizeMode_Minimized:
 76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                ("*** mSizeMode: nsSizeMode_Minimized\n"));
 34735:         break;
 34735:       case nsSizeMode_Maximized:
 76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                  ("*** mSizeMode: nsSizeMode_Maximized\n");
 34735:         break;
 34735:       default:
 76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** mSizeMode: ??????\n");
 34735:         break;
 34735:     };
 34735: #endif
 34735: 
108457:     if (mWidgetListener)
108457:       mWidgetListener->SizeModeChanged(mSizeMode);
108457: 
108457:     // If window was restored, window activation was bypassed during the 
 97778:     // SetSizeMode call originating from OnWindowPosChanging to avoid saving
108457:     // pre-restore attributes. Force activation now to get correct attributes.
 97778:     if (mLastSizeMode != nsSizeMode_Normal && mSizeMode == nsSizeMode_Normal)
108457:       DispatchFocusToTopLevelWindow(true);
 97778: 
 34735:     // Skip window size change events below on minimization.
 34735:     if (mSizeMode == nsSizeMode_Minimized)
 34735:       return;
 34735:   }
 34735: 
163806:   // Handle window position changes
163806:   if (!(wp->flags & SWP_NOMOVE)) {
163806:     mBounds.x = wp->x;
163806:     mBounds.y = wp->y;
163806: 
163806:     if (mWidgetListener) {
163806:       mWidgetListener->WindowMoved(this, wp->x, wp->y);
163806:     }
163806:   }
163806: 
 34735:   // Handle window size changes
 56922:   if (!(wp->flags & SWP_NOSIZE)) {
 34735:     RECT r;
108991:     int32_t newWidth, newHeight;
 34735: 
 34735:     ::GetWindowRect(mWnd, &r);
 34735: 
 34735:     newWidth  = r.right - r.left;
 34735:     newHeight = r.bottom - r.top;
 34735:     nsIntRect rect(wp->x, wp->y, newWidth, newHeight);
 34735: 
 34735: #ifdef MOZ_XUL
 34735:     if (eTransparencyTransparent == mTransparencyMode)
 34735:       ResizeTranslucentWindow(newWidth, newHeight);
 34735: #endif
 34735: 
 34735:     if (newWidth > mLastSize.width)
 34735:     {
 34735:       RECT drect;
 34735: 
 34735:       // getting wider
 34735:       drect.left   = wp->x + mLastSize.width;
 34735:       drect.top    = wp->y;
 34735:       drect.right  = drect.left + (newWidth - mLastSize.width);
 34735:       drect.bottom = drect.top + newHeight;
 34735: 
164874:       ::RedrawWindow(mWnd, &drect, nullptr,
 34735:                      RDW_INVALIDATE |
 34735:                      RDW_NOERASE |
 34735:                      RDW_NOINTERNALPAINT |
 34735:                      RDW_ERASENOW |
 34735:                      RDW_ALLCHILDREN);
 34735:     }
 34735:     if (newHeight > mLastSize.height)
 34735:     {
 34735:       RECT drect;
 34735: 
 34735:       // getting taller
 34735:       drect.left   = wp->x;
 34735:       drect.top    = wp->y + mLastSize.height;
 34735:       drect.right  = drect.left + newWidth;
 34735:       drect.bottom = drect.top + (newHeight - mLastSize.height);
 34735: 
164874:       ::RedrawWindow(mWnd, &drect, nullptr,
 34735:                      RDW_INVALIDATE |
 34735:                      RDW_NOERASE |
 34735:                      RDW_NOINTERNALPAINT |
 34735:                      RDW_ERASENOW |
 34735:                      RDW_ALLCHILDREN);
 34735:     }
 34735: 
 34735:     mBounds.width    = newWidth;
 34735:     mBounds.height   = newHeight;
 34735:     mLastSize.width  = newWidth;
 34735:     mLastSize.height = newHeight;
 34735: 
 34735: #ifdef WINSTATE_DEBUG_OUTPUT
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:            ("*** Resize window: %d x %d x %d x %d\n", wp->x, wp->y, 
 76714:             newWidth, newHeight));
 34735: #endif
 34735: 
108835:     // If a maximized window is resized, recalculate the non-client margins.
 48424:     if (mSizeMode == nsSizeMode_Maximized) {
 79626:       if (UpdateNonClientMargins(nsSizeMode_Maximized, true)) {
 48424:         // gecko resize event already sent by UpdateNonClientMargins.
 48424:         return;
 48424:       }
 48424:     }
 48424: 
 34735:     // Recalculate the width and height based on the client area for gecko events.
 34735:     if (::GetClientRect(mWnd, &r)) {
 34735:       rect.width  = r.right - r.left;
 34735:       rect.height = r.bottom - r.top;
 34735:     }
 34735:     
 34735:     // Send a gecko resize event
163806:     OnResize(rect);
 34735:   }
 34735: }
 34786: 
 34786: // static
 34786: void nsWindow::ActivateOtherWindowHelper(HWND aWnd)
 34786: {
 34786:   // Find the next window that is enabled, visible, and not minimized.
 34786:   HWND hwndBelow = ::GetNextWindow(aWnd, GW_HWNDNEXT);
 34786:   while (hwndBelow && (!::IsWindowEnabled(hwndBelow) || !::IsWindowVisible(hwndBelow) ||
 34786:                        ::IsIconic(hwndBelow))) {
 34786:     hwndBelow = ::GetNextWindow(hwndBelow, GW_HWNDNEXT);
 34786:   }
 34786: 
 34786:   // Push ourselves to the bottom of the stack, then activate the
 34786:   // next window.
 34786:   ::SetWindowPos(aWnd, HWND_BOTTOM, 0, 0, 0, 0,
 34786:                  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
 34786:   if (hwndBelow)
 34786:     ::SetForegroundWindow(hwndBelow);
 34786: 
 34786:   // Play the minimize sound while we're here, since that is also
 34786:   // forgotten when we use SW_SHOWMINIMIZED.
 78043:   nsCOMPtr<nsISound> sound(do_CreateInstance("@mozilla.org/sound;1"));
 78043:   if (sound) {
 78043:     sound->PlaySystemSound(NS_LITERAL_STRING("Minimize"));
 78043:   }
 34786: }
 68855: 
 29835: void nsWindow::OnWindowPosChanging(LPWINDOWPOS& info)
 29835: {
 46332:   // Update non-client margins if the frame size is changing, and let the
 46332:   // browser know we are changing size modes, so alternative css can kick in.
 46335:   // If we're going into fullscreen mode, ignore this, since it'll reset
 46335:   // margins to normal mode. 
 56369:   if ((info->flags & SWP_FRAMECHANGED && !(info->flags & SWP_NOSIZE)) &&
 56369:       mSizeMode != nsSizeMode_Fullscreen) {
 46332:     WINDOWPLACEMENT pl;
 46332:     pl.length = sizeof(pl);
 46332:     ::GetWindowPlacement(mWnd, &pl);
108457:     nsSizeMode sizeMode;
 46332:     if (pl.showCmd == SW_SHOWMAXIMIZED)
 62115:       sizeMode = (mFullscreenMode ? nsSizeMode_Fullscreen : nsSizeMode_Maximized);
 46332:     else if (pl.showCmd == SW_SHOWMINIMIZED)
 46332:       sizeMode = nsSizeMode_Minimized;
 63113:     else if (mFullscreenMode)
 63113:       sizeMode = nsSizeMode_Fullscreen;
 46332:     else
 46332:       sizeMode = nsSizeMode_Normal;
 46332: 
108457:     if (mWidgetListener)
108457:       mWidgetListener->SizeModeChanged(sizeMode);
 46332: 
 79626:     UpdateNonClientMargins(sizeMode, false);
 46332:   }
 46332: 
 29835:   // enforce local z-order rules
 29835:   if (!(info->flags & SWP_NOZORDER)) {
 29835:     HWND hwndAfter = info->hwndInsertAfter;
 29835: 
 29835:     nsWindow *aboveWindow = 0;
108457:     nsWindowZ placement;
 29835: 
 29835:     if (hwndAfter == HWND_BOTTOM)
108457:       placement = nsWindowZBottom;
 29835:     else if (hwndAfter == HWND_TOP || hwndAfter == HWND_TOPMOST || hwndAfter == HWND_NOTOPMOST)
108457:       placement = nsWindowZTop;
 29835:     else {
108457:       placement = nsWindowZRelative;
 86569:       aboveWindow = WinUtils::GetNSWindowPtr(hwndAfter);
 29835:     }
108457: 
108457:     if (mWidgetListener) {
108457:       nsCOMPtr<nsIWidget> actualBelow = nullptr;
108457:       if (mWidgetListener->ZLevelChanged(false, &placement,
108457:                                          aboveWindow, getter_AddRefs(actualBelow))) {
108457:         if (placement == nsWindowZBottom)
 29835:           info->hwndInsertAfter = HWND_BOTTOM;
108457:         else if (placement == nsWindowZTop)
 29835:           info->hwndInsertAfter = HWND_TOP;
 29835:         else {
108457:           info->hwndInsertAfter = (HWND)actualBelow->GetNativeData(NS_NATIVE_WINDOW);
108457:         }
108457:       }
108457:     }
 29835:   }
 29835:   // prevent rude external programs from making hidden window visible
 29835:   if (mWindowType == eWindowType_invisible)
 29835:     info->flags &= ~SWP_SHOWWINDOW;
 29835: }
 29835: 
 40944: void nsWindow::UserActivity()
 40944: {
 40944:   // Check if we have the idle service, if not we try to get it.
 40944:   if (!mIdleService) {
 40944:     mIdleService = do_GetService("@mozilla.org/widget/idleservice;1");
 40944:   }
 40944: 
 40944:   // Check that we now have the idle service.
 40944:   if (mIdleService) {
103224:     mIdleService->ResetIdleTimeOut(0);
 40944:   }
 40944: }
 40944: 
 79445: bool nsWindow::OnTouch(WPARAM wParam, LPARAM lParam)
 48711: {
108991:   uint32_t cInputs = LOWORD(wParam);
 48711:   PTOUCHINPUT pInputs = new TOUCHINPUT[cInputs];
 48711: 
114690:   if (mGesture.GetTouchInputInfo((HTOUCHINPUT)lParam, cInputs, pInputs)) {
163724:     WidgetTouchEvent* touchEventToSend = nullptr;
163724:     WidgetTouchEvent* touchEndEventToSend = nullptr;
114690:     nsEventStatus status;
114690: 
114690:     // Walk across the touch point array processing each contact point
114690:     for (uint32_t i = 0; i < cInputs; i++) {
114690:       uint32_t msg;
114690: 
114690:       if (pInputs[i].dwFlags & (TOUCHEVENTF_DOWN | TOUCHEVENTF_MOVE)) {
114690:         // Create a standard touch event to send
114690:         if (!touchEventToSend) {
163724:           touchEventToSend = new WidgetTouchEvent(true, NS_TOUCH_MOVE, this);
114690:           touchEventToSend->time = ::GetMessageTime();
114690:           ModifierKeyState modifierKeyState;
114690:           modifierKeyState.InitInputEvent(*touchEventToSend);
114690:         }
114690: 
114690:         // Pres shell expects this event to be a NS_TOUCH_START if new contact
114690:         // points have been added since the last event sent.
114690:         if (pInputs[i].dwFlags & TOUCHEVENTF_DOWN) {
114690:           touchEventToSend->message = msg = NS_TOUCH_START;
114690:         } else {
114690:           msg = NS_TOUCH_MOVE;
114690:         }
114690:       } else if (pInputs[i].dwFlags & TOUCHEVENTF_UP) {
114690:         // Pres shell expects removed contacts points to be delivered in a
114690:         // separate NS_TOUCH_END event containing only the contact points
114690:         // that were removed.
114690:         if (!touchEndEventToSend) {
163724:           touchEndEventToSend = new WidgetTouchEvent(true, NS_TOUCH_END, this);
114690:           touchEndEventToSend->time = ::GetMessageTime();
114690:           ModifierKeyState modifierKeyState;
114690:           modifierKeyState.InitInputEvent(*touchEndEventToSend);
114690:         }
114690:         msg = NS_TOUCH_END;
114690:       } else {
114690:         // Filter out spurious Windows events we don't understand, like palm
114690:         // contact.
114690:         continue;
114690:       }
114690: 
114690:       // Setup the touch point we'll append to the touch event array
114690:       nsPointWin touchPoint;
114690:       touchPoint.x = TOUCH_COORD_TO_PIXEL(pInputs[i].x);
114690:       touchPoint.y = TOUCH_COORD_TO_PIXEL(pInputs[i].y);
114690:       touchPoint.ScreenToClient(mWnd);
144637:       nsRefPtr<Touch> touch =
139549:         new Touch(pInputs[i].dwID,
114690:                   touchPoint,
114690:                   /* radius, if known */
114690:                   pInputs[i].dwFlags & TOUCHINPUTMASKF_CONTACTAREA ?
114690:                     nsIntPoint(
114690:                       TOUCH_COORD_TO_PIXEL(pInputs[i].cxContact) / 2,
114690:                       TOUCH_COORD_TO_PIXEL(pInputs[i].cyContact) / 2) :
114690:                     nsIntPoint(1,1),
114690:                   /* rotation angle and force */
114690:                   0.0f, 0.0f);
114690: 
114690:       // Append to the appropriate event
114690:       if (msg == NS_TOUCH_START || msg == NS_TOUCH_MOVE) {
114690:         touchEventToSend->touches.AppendElement(touch);
114690:       } else {
114690:         touchEndEventToSend->touches.AppendElement(touch);
114690:       }
114690:     }
114690: 
114690:     // Dispatch touch start and move event if we have one.
114690:     if (touchEventToSend) {
114690:       DispatchEvent(touchEventToSend, status);
114690:       delete touchEventToSend;
114690:     }
114690: 
114690:     // Dispatch touch end event if we have one.
114690:     if (touchEndEventToSend) {
114690:       DispatchEvent(touchEndEventToSend, status);
114690:       delete touchEndEventToSend;
114690:     }
114690:   }
114690: 
 48711:   delete [] pInputs;
 48711:   mGesture.CloseTouchInputHandle((HTOUCHINPUT)lParam);
 79626:   return true;
 48711: }
 48711: 
108991: static int32_t RoundDown(double aDouble)
108991: {
108991:   return aDouble > 0 ? static_cast<int32_t>(floor(aDouble)) :
108991:                        static_cast<int32_t>(ceil(aDouble));
108070: }
108070: 
 29835: // Gesture event processing. Handles WM_GESTURE events.
 79445: bool nsWindow::OnGesture(WPARAM wParam, LPARAM lParam)
 29835: {
 29835:   // Treatment for pan events which translate into scroll events:
 29835:   if (mGesture.IsPanEvent(lParam)) {
 29835:     if ( !mGesture.ProcessPanMessage(mWnd, wParam, lParam) )
 79626:       return false; // ignore
 29835: 
 29835:     nsEventStatus status;
 29835: 
165701:     WidgetWheelEvent wheelEvent(true, NS_WHEEL_WHEEL, this);
108070: 
102101:     ModifierKeyState modifierKeyState;
108070:     modifierKeyState.InitInputEvent(wheelEvent);
108070: 
108070:     wheelEvent.button      = 0;
108070:     wheelEvent.time        = ::GetMessageTime();
108070:     wheelEvent.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_TOUCH;
 29835: 
 79445:     bool endFeedback = true;
 29835: 
108070:     if (mGesture.PanDeltaToPixelScroll(wheelEvent)) {
108070:       DispatchEvent(&wheelEvent, status);
 30890:     }
 30890: 
 31443:     if (mDisplayPanFeedback) {
110714:       mGesture.UpdatePanFeedbackX(mWnd,
135921:                                   DeprecatedAbs(RoundDown(wheelEvent.overflowDeltaX)),
108070:                                   endFeedback);
110714:       mGesture.UpdatePanFeedbackY(mWnd,
135921:                                   DeprecatedAbs(RoundDown(wheelEvent.overflowDeltaY)),
108070:                                   endFeedback);
 29835:       mGesture.PanFeedbackFinalize(mWnd, endFeedback);
 30890:     }
 30890: 
 29835:     mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
 29835: 
 79626:     return true;
 29835:   }
 29835: 
 29835:   // Other gestures translate into simple gesture events:
163725:   WidgetSimpleGestureEvent event(true, 0, this, 0, 0.0);
 29835:   if ( !mGesture.ProcessGestureMessage(mWnd, wParam, lParam, event) ) {
 79626:     return false; // fall through to DefWndProc
 29835:   }
 29835:   
 29835:   // Polish up and send off the new event
102101:   ModifierKeyState modifierKeyState;
 96889:   modifierKeyState.InitInputEvent(event);
 29835:   event.button    = 0;
 29835:   event.time      = ::GetMessageTime();
 77227:   event.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_TOUCH;
 29835: 
 29835:   nsEventStatus status;
 29835:   DispatchEvent(&event, status);
 29835:   if (status == nsEventStatus_eIgnore) {
 79626:     return false; // Ignored, fall through
 29835:   }
 29835: 
 29835:   // Only close this if we process and return true.
 29835:   mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
 29835: 
 79626:   return true; // Handled
 29835: }
 68855: 
106128: static BOOL WINAPI EnumFirstChild(HWND hwnd, LPARAM lParam)
106128: {
106128:   *((HWND*)lParam) = hwnd;
106128:   return FALSE;
106128: }
106128: 
106128: static void InvalidatePluginAsWorkaround(nsWindow *aWindow, const nsIntRect &aRect)
106128: {
106128:   aWindow->Invalidate(aRect);
106128: 
106128:   // XXX - Even more evil workaround!! See bug 762948, flash's bottom
106128:   // level sandboxed window doesn't seem to get our invalidate. We send
106128:   // an invalidate to it manually. This is totally specialized for this
106128:   // bug, for other child window structures this will just be a more or
106128:   // less bogus invalidate but since that should not have any bad
106128:   // side-effects this will have to do for now.
106128:   HWND current = (HWND)aWindow->GetNativeData(NS_NATIVE_WINDOW);
106128: 
106128:   RECT windowRect;
106128:   RECT parentRect;
106128: 
106128:   ::GetWindowRect(current, &parentRect);
106128:         
106128:   HWND next = current;
106128: 
106128:   do {
106128:     current = next;
106128: 
106128:     ::EnumChildWindows(current, &EnumFirstChild, (LPARAM)&next);
106128: 
106128:     ::GetWindowRect(next, &windowRect);
106128:     // This is relative to the screen, adjust it to be relative to the
106128:     // window we're reconfiguring.
106128:     windowRect.left -= parentRect.left;
106128:     windowRect.top -= parentRect.top;
106128:   } while (next != current && windowRect.top == 0 && windowRect.left == 0);
106128: 
106128:   if (windowRect.top == 0 && windowRect.left == 0) {
106128:     RECT rect;
106128:     rect.left   = aRect.x;
106128:     rect.top    = aRect.y;
106128:     rect.right  = aRect.XMost();
106128:     rect.bottom = aRect.YMost();
106128: 
106128:     ::InvalidateRect(next, &rect, FALSE);
106128:   }
106128: }
106128: 
 30515: nsresult
 30515: nsWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
 30515: {
 30515:   // XXXroc we could use BeginDeferWindowPos/DeferWindowPos/EndDeferWindowPos
 30515:   // here, if that helps in some situations. So far I haven't seen a
 30515:   // need.
108991:   for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
 30515:     const Configuration& configuration = aConfigurations[i];
 30515:     nsWindow* w = static_cast<nsWindow*>(configuration.mChild);
 30515:     NS_ASSERTION(w->GetParent() == this,
 30515:                  "Configured widget is not a child");
 79626:     nsresult rv = w->SetWindowClipRegion(configuration.mClipRegion, true);
 51672:     NS_ENSURE_SUCCESS(rv, rv);
 30688:     nsIntRect bounds;
 30688:     w->GetBounds(bounds);
 30688:     if (bounds.Size() != configuration.mBounds.Size()) {
 30515:       w->Resize(configuration.mBounds.x, configuration.mBounds.y,
 30515:                 configuration.mBounds.width, configuration.mBounds.height,
 79626:                 true);
 30688:     } else if (bounds.TopLeft() != configuration.mBounds.TopLeft()) {
 30688:       w->Move(configuration.mBounds.x, configuration.mBounds.y);
 58644: 
 58644: 
 58644:       if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 58644:           gfxWindowsPlatform::RENDER_DIRECT2D ||
181945:           GetLayerManager()->GetBackendType() != LayersBackend::LAYERS_BASIC) {
 58644:         // XXX - Workaround for Bug 587508. This will invalidate the part of the
 58644:         // plugin window that might be touched by moving content somehow. The
 58644:         // underlying problem should be found and fixed!
 58644:         nsIntRegion r;
 58644:         r.Sub(bounds, configuration.mBounds);
 58644:         r.MoveBy(-bounds.x,
 58644:                  -bounds.y);
106128:         nsIntRect toInvalidate = r.GetBounds();
106128: 
106128:         InvalidatePluginAsWorkaround(w, toInvalidate);
 79626:       }
 79626:     }
 79626:     rv = w->SetWindowClipRegion(configuration.mClipRegion, false);
 30515:     NS_ENSURE_SUCCESS(rv, rv);
 30515:   }
 30515:   return NS_OK;
 30515: }
 30515: 
 30515: static HRGN
 30515: CreateHRGNFromArray(const nsTArray<nsIntRect>& aRects)
 30515: {
108991:   int32_t size = sizeof(RGNDATAHEADER) + sizeof(RECT)*aRects.Length();
108991:   nsAutoTArray<uint8_t,100> buf;
186013:   buf.SetLength(size);
 30515:   RGNDATA* data = reinterpret_cast<RGNDATA*>(buf.Elements());
 30515:   RECT* rects = reinterpret_cast<RECT*>(data->Buffer);
 30515:   data->rdh.dwSize = sizeof(data->rdh);
 30515:   data->rdh.iType = RDH_RECTANGLES;
 30515:   data->rdh.nCount = aRects.Length();
 30515:   nsIntRect bounds;
108991:   for (uint32_t i = 0; i < aRects.Length(); ++i) {
 30515:     const nsIntRect& r = aRects[i];
 30515:     bounds.UnionRect(bounds, r);
 30515:     ::SetRect(&rects[i], r.x, r.y, r.XMost(), r.YMost());
 30515:   }
 30515:   ::SetRect(&data->rdh.rcBound, bounds.x, bounds.y, bounds.XMost(), bounds.YMost());
164874:   return ::ExtCreateRegion(nullptr, buf.Length(), data);
 30515: }
 30515: 
124362: static void
124362: ArrayFromRegion(const nsIntRegion& aRegion, nsTArray<nsIntRect>& aRects)
124362: {
 59749:   const nsIntRect* r;
 59749:   for (nsIntRegionRectIterator iter(aRegion); (r = iter.Next());) {
124362:     aRects.AppendElement(*r);
124362:   }
 59749: }
 59749: 
 30515: nsresult
 30515: nsWindow::SetWindowClipRegion(const nsTArray<nsIntRect>& aRects,
 79445:                               bool aIntersectWithExisting)
 30515: {
 30688:   if (!aIntersectWithExisting) {
 30688:     if (!StoreWindowClipRegion(aRects))
 30688:       return NS_OK;
 51672:   } else {
 51672:     // In this case still early return if nothing changed.
 51672:     if (mClipRects && mClipRectCount == aRects.Length() &&
 51672:         memcmp(mClipRects,
 51672:                aRects.Elements(),
 51672:                sizeof(nsIntRect)*mClipRectCount) == 0) {
 51672:       return NS_OK;
 51672:     }
 59749: 
 59749:     // get current rects
 59749:     nsTArray<nsIntRect> currentRects;
 59749:     GetWindowClipRegion(&currentRects);
 59749:     // create region from them
 59749:     nsIntRegion currentRegion = RegionFromArray(currentRects);
 59749:     // create region from new rects
 59749:     nsIntRegion newRegion = RegionFromArray(aRects);
 59749:     // intersect regions
 59749:     nsIntRegion intersection;
 59749:     intersection.And(currentRegion, newRegion);
 59749:     // create int rect array from intersection
124362:     nsTArray<nsIntRect> rects;
124362:     ArrayFromRegion(intersection, rects);
 59749:     // store
 59749:     if (!StoreWindowClipRegion(rects))
 59749:       return NS_OK;
 30688:   }
 30688: 
 30515:   HRGN dest = CreateHRGNFromArray(aRects);
 30515:   if (!dest)
 30515:     return NS_ERROR_OUT_OF_MEMORY;
 30515: 
 30515:   if (aIntersectWithExisting) {
 30515:     HRGN current = ::CreateRectRgn(0, 0, 0, 0);
 30515:     if (current) {
 30515:       if (::GetWindowRgn(mWnd, current) != 0 /*ERROR*/) {
 30515:         ::CombineRgn(dest, dest, current, RGN_AND);
 30515:       }
 30515:       ::DeleteObject(current);
 30515:     }
 30515:   }
 30515: 
 89735:   // If a plugin is not visible, especially if it is in a background tab,
 77660:   // it should not be able to steal keyboard focus.  This code checks whether
 77660:   // the region that the plugin is being clipped to is NULLREGION.  If it is,
 77660:   // the plugin window gets disabled.
 77660:   if(mWindowType == eWindowType_plugin) {
 77660:     if(NULLREGION == ::CombineRgn(dest, dest, dest, RGN_OR)) {
 91763:       ::ShowWindow(mWnd, SW_HIDE);
 77660:       ::EnableWindow(mWnd, FALSE);
 77660:     } else {
 77660:       ::EnableWindow(mWnd, TRUE);
 91763:       ::ShowWindow(mWnd, SW_SHOW);
 77660:     }
 77660:   }
 30515:   if (!::SetWindowRgn(mWnd, dest, TRUE)) {
 30515:     ::DeleteObject(dest);
 30515:     return NS_ERROR_FAILURE;
 30515:   }
 30515:   return NS_OK;
 30515: }
 30515: 
 30223: // WM_DESTROY event handler
     1: void nsWindow::OnDestroy()
     1: {
 79626:   mOnDestroyCalled = true;
     1: 
 30223:   // Make sure we don't get destroyed in the process of tearing down.
 30223:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 30223:   
108456:   // Dispatch the destroy notification.
 30223:   if (!mInDtor)
108456:     NotifyWindowDestroyed();
 30223: 
 30223:   // Prevent the widget from sending additional events.
108460:   mWidgetListener = nullptr;
108461:   mAttachedWidgetListener = nullptr;
 30223: 
 30223:   // Free our subclass and clear |this| stored in the window props. We will no longer
 30223:   // receive events from Windows after this point.
     1:   SubclassWindow(FALSE);
  4186: 
108460:   // Once mWidgetListener is cleared and the subclass is reset, sCurrentWindow can be
 30223:   // cleared. (It's used in tracking windows for mouse events.)
 30223:   if (sCurrentWindow == this)
106838:     sCurrentWindow = nullptr;
 30223: 
 30223:   // Disconnects us from our parent, will call our GetParent().
 30223:   nsBaseWidget::Destroy();
 30223: 
 30223:   // Release references to children, device context, toolkit, and app shell.
 30223:   nsBaseWidget::OnDestroy();
 30223:   
 30223:   // Clear our native parent handle.
106838:   // XXX Windows will take care of this in the proper order, and SetParent(nullptr)'s
 30223:   // remove child on the parent already took place in nsBaseWidget's Destroy call above.
106838:   //SetParent(nullptr);
106838:   mParent = nullptr;
 30223: 
 30223:   // We have to destroy the native drag target before we null out our window pointer.
 79626:   EnableDragDrop(false);
  4186: 
 30223:   // If we're going away and for some reason we're still the rollup widget, rollup and
 30223:   // turn off capture.
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
127124:   nsCOMPtr<nsIWidget> rollupWidget;
127124:   if (rollupListener) {
127124:     rollupWidget = rollupListener->GetRollupWidget();
127124:   }
120177:   if (this == rollupWidget) {
120177:     if ( rollupListener )
169007:       rollupListener->Rollup(0, nullptr, nullptr);
120177:     CaptureRollupEvents(nullptr, false);
 30223:   }
 30223: 
134064:   IMEHandler::OnDestroyWindow(this);
 30223: 
 30223:   // Turn off mouse trails if enabled.
 30223:   MouseTrailer* mtrailer = nsToolkit::gMouseTrailer;
 30223:   if (mtrailer) {
 30223:     if (mtrailer->GetMouseTrailerWindow() == mWnd)
 30223:       mtrailer->DestroyTimer();
 30223: 
 30223:     if (mtrailer->GetCaptureWindow() == mWnd)
106838:       mtrailer->SetCaptureWindow(nullptr);
 30223:   }
 30223: 
 30223:   // Free GDI window class objects
     1:   if (mBrush) {
     1:     VERIFY(::DeleteObject(mBrush));
164874:     mBrush = nullptr;
     1:   }
     1: 
 30223: 
 30223:   // Destroy any custom cursor resources.
 30223:   if (mCursor == -1)
 30223:     SetCursor(eCursor_standard);
 30223: 
 30223: #ifdef MOZ_XUL
 30223:   // Reset transparency
 30223:   if (eTransparencyTransparent == mTransparencyMode)
 30223:     SetupTranslucentWindowMemoryBitmap(eTransparencyOpaque);
 30223: #endif
 30223: 
 43073:   // Finalize panning feedback to possibly restore window displacement
 79626:   mGesture.PanFeedbackFinalize(mWnd, true);
 43073: 
 30223:   // Clear the main HWND.
164874:   mWnd = nullptr;
     1: }
     1: 
     1: // Send a resize message to the listener
 79445: bool nsWindow::OnResize(nsIntRect &aWindowRect)
     1: {
 38727: #ifdef CAIRO_HAS_D2D_SURFACE
 38727:   if (mD2DWindowSurface) {
164874:     mD2DWindowSurface = nullptr;
 87336:     Invalidate();
 38727:   }
 38727: #endif
 51610: 
109287:   bool result = mWidgetListener ?
109287:                 mWidgetListener->WindowResized(this, aWindowRect.width, aWindowRect.height) : false;
109287: 
108460:   // If there is an attached view, inform it as well as the normal widget listener.
108461:   if (mAttachedWidgetListener) {
109287:     return mAttachedWidgetListener->WindowResized(this, aWindowRect.width, aWindowRect.height);
109287:   }
109287: 
109287:   return result;
     1: }
     1: 
 79445: bool nsWindow::OnHotKey(WPARAM wParam, LPARAM lParam)
 29835: {
 79626:   return true;
 29835: }
 29835: 
 32194: // Can be overriden. Controls auto-erase of background.
 79445: bool nsWindow::AutoErase(HDC dc)
 32194: {
 79626:   return false;
     1: }
     1: 
 58814: void
 58814: nsWindow::AllowD3D9Callback(nsWindow *aWindow)
 58814: {
143173:   if (aWindow->mLayerManager && !aWindow->ShouldUseOffMainThreadCompositing()) {
 58814:     aWindow->mLayerManager->Destroy();
164874:     aWindow->mLayerManager = nullptr;
 58814:   }
 58814: }
 58814: 
 58814: void
 58814: nsWindow::AllowD3D9WithReinitializeCallback(nsWindow *aWindow)
 58814: {
143173:   if (aWindow->mLayerManager && !aWindow->ShouldUseOffMainThreadCompositing()) {
 58814:     aWindow->mLayerManager->Destroy();
164874:     aWindow->mLayerManager = nullptr;
 58814:     (void) aWindow->GetLayerManager();
 58814:   }
 58814: }
 58814: 
 58814: void
 58814: nsWindow::StartAllowingD3D9(bool aReinitialize)
 58814: {
 58814:   sAllowD3D9 = true;
 58814: 
 60398:   LayerManagerPrefs prefs;
 60398:   GetLayerManagerPrefs(&prefs);
 60398:   if (prefs.mDisableAcceleration) {
 60398:     // The guarantee here is, if there's *any* chance that after we
 60398:     // throw out our layer managers we'd create at least one new,
 60398:     // accelerated one, we *will* throw out all the current layer
 60398:     // managers.  We early-return here because currently, if
 60398:     // |disableAcceleration|, we will always use basic managers and
143173:     // it's a waste to recreate them. If we're using OMTC we don't want to
143173:     // recreate out layer manager and its compositor either. This is even
143173:     // more wasteful.
 60398:     //
 60398:     // NB: the above implies that it's eminently possible for us to
 60398:     // skip this early return but still recreate basic managers.
 60398:     // That's OK.  It's *not* OK to take this early return when we
 60398:     // *might* have created an accelerated manager.
 60398:     return;
 60398:   }
 60398: 
 58814:   if (aReinitialize) {
 58814:     EnumAllWindows(AllowD3D9WithReinitializeCallback);
 58814:   } else {
 58814:     EnumAllWindows(AllowD3D9Callback);
 58814:   }
 58814: }
 58814: 
156813: void
156813: nsWindow::GetPreferredCompositorBackends(nsTArray<LayersBackend>& aHints)
154493: {
154493:   LayerManagerPrefs prefs;
154493:   GetLayerManagerPrefs(&prefs);
156813: 
174312:   // We don't currently support using an accelerated layer manager with
174312:   // transparent windows so don't even try. I'm also not sure if we even
174312:   // want to support this case. See bug 593471
174312:   if (!(prefs.mDisableAcceleration ||
174312:         mTransparencyMode == eTransparencyTransparent)) {
166143:     if (prefs.mPreferOpenGL) {
181945:       aHints.AppendElement(LayersBackend::LAYERS_OPENGL);
166143:     }
156813:     if (!prefs.mPreferD3D9) {
181945:       aHints.AppendElement(LayersBackend::LAYERS_D3D11);
181945:     }
181945:     aHints.AppendElement(LayersBackend::LAYERS_D3D9);
181945:   }
181945:   aHints.AppendElement(LayersBackend::LAYERS_BASIC);
154493: }
154493: 
155796: void
155796: nsWindow::WindowUsesOMTC()
155796: {
155796:   ULONG_PTR style = ::GetClassLongPtr(mWnd, GCL_STYLE);
155796:   if (!style) {
155796:     NS_WARNING("Could not get window class style");
155796:     return;
155796:   }
155796:   style |= CS_HREDRAW | CS_VREDRAW;
155796:   DebugOnly<ULONG_PTR> result = ::SetClassLongPtr(mWnd, GCL_STYLE, style);
155796:   NS_WARN_IF_FALSE(result, "Could not reset window class style");
155796: }
155796: 
 63258: bool
 63258: nsWindow::HasBogusPopupsDropShadowOnMultiMonitor() {
 63258:   if (sHasBogusPopupsDropShadowOnMultiMonitor == TRI_UNKNOWN) {
 63258:     // Since any change in the preferences requires a restart, this can be
 63258:     // done just once.
 63258:     // Check for Direct2D first.
 63258:     sHasBogusPopupsDropShadowOnMultiMonitor =
 63258:       gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 63258:         gfxWindowsPlatform::RENDER_DIRECT2D ? TRI_TRUE : TRI_FALSE;
 63258:     if (!sHasBogusPopupsDropShadowOnMultiMonitor) {
 63258:       // Otherwise check if Direct3D 9 may be used.
 63258:       LayerManagerPrefs prefs;
 63258:       GetLayerManagerPrefs(&prefs);
 63258:       if (!prefs.mDisableAcceleration && !prefs.mPreferOpenGL) {
 63258:         nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
 63258:         if (gfxInfo) {
108991:           int32_t status;
 63258:           if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS, &status))) {
 63258:             if (status == nsIGfxInfo::FEATURE_NO_INFO || prefs.mForceAcceleration)
 63258:             {
 63258:               sHasBogusPopupsDropShadowOnMultiMonitor = TRI_TRUE;
 63258:             }
 63258:           }
 63258:         }
 63258:       }
 63258:     }
 63258:   }
 63258:   return !!sHasBogusPopupsDropShadowOnMultiMonitor;
 63258: }
 63258: 
 82569: void
 82569: nsWindow::OnSysColorChanged()
 82569: {
 82569:   if (mWindowType == eWindowType_invisible) {
 82569:     ::EnumThreadWindows(GetCurrentThreadId(), nsWindow::BroadcastMsg, WM_SYSCOLORCHANGE);
 82569:   }
 82569:   else {
 82569:     // Note: This is sent for child windows as well as top-level windows.
 82569:     // The Win32 toolkit normally only sends these events to top-level windows.
 82569:     // But we cycle through all of the childwindows and send it to them as well
 82569:     // so all presentations get notified properly.
 82569:     // See nsWindow::GlobalMsgWindowProc.
108452:     NotifySysColorChanged();
 82569:   }
 82569: }
 82569: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: IME management and accessibility
 29835:  **
 29835:  ** Handles managing IME input and accessibility.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
135097: NS_IMETHODIMP
135097: nsWindow::NotifyIME(NotificationToIME aNotification)
135097: {
135097:   return IMEHandler::NotifyIME(this, aNotification);
     1: }
     1: 
 82841: NS_IMETHODIMP_(void)
 82841: nsWindow::SetInputContext(const InputContext& aContext,
 82841:                           const InputContextAction& aAction)
 82840: {
134065:   InputContext newInputContext = aContext;
137547:   IMEHandler::SetInputContext(this, newInputContext, aAction);
134065:   mInputContext = newInputContext;
 82841: }
 82841: 
 82841: NS_IMETHODIMP_(InputContext)
 82841: nsWindow::GetInputContext()
   539: {
 82842:   mInputContext.mIMEState.mOpen = IMEState::CLOSED;
145608:   if (WinUtils::IsIMEEnabled(mInputContext) && IMEHandler::GetOpenState(this)) {
 82842:     mInputContext.mIMEState.mOpen = IMEState::OPEN;
134066:   } else {
134066:     mInputContext.mIMEState.mOpen = IMEState::CLOSED;
 82842:   }
 82841:   return mInputContext;
     1: }
     1: 
  2475: NS_IMETHODIMP
108991: nsWindow::GetToggledKeyState(uint32_t aKeyCode, bool* aLEDState)
  2475: {
  2475: #ifdef DEBUG_KBSTATE
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("GetToggledKeyState\n"));
  2475: #endif 
  2475:   NS_ENSURE_ARG_POINTER(aLEDState);
  2475:   *aLEDState = (::GetKeyState(aKeyCode) & 1) != 0;
  2475:   return NS_OK;
  2475: }
     1: 
 24836: NS_IMETHODIMP
135101: nsWindow::NotifyIMEOfTextChange(uint32_t aStart,
108991:                                 uint32_t aOldEnd,
108991:                                 uint32_t aNewEnd)
 24836: {
134061:   return IMEHandler::NotifyIMEOfTextChange(aStart, aOldEnd, aNewEnd);
134061: }
 24836: 
121726: nsIMEUpdatePreference
121726: nsWindow::GetIMEUpdatePreference()
121726: {
134062:   return IMEHandler::GetUpdatePreference();
134062: }
 24836: 
     1: #ifdef ACCESSIBILITY
152637: #ifdef DEBUG
149859: #define NS_LOG_WMGETOBJECT(aWnd, aHwnd, aAcc)                                  \
152637:   if (a11y::logging::IsEnabled(a11y::logging::ePlatforms)) {                   \
152637:     printf("Get the window:\n  {\n     HWND: %d, parent HWND: %d, wndobj: %p,\n",\
152637:            aHwnd, ::GetParent(aHwnd), aWnd);                                   \
152637:     printf("     acc: %p", aAcc);                                              \
149859:     if (aAcc) {                                                                \
 47996:       nsAutoString name;                                                       \
149859:       aAcc->Name(name);                                                        \
152637:       printf(", accname: %s", NS_ConvertUTF16toUTF8(name).get());              \
149859:     }                                                                          \
152637:     printf("\n }\n");                                                          \
152637:   }
149859: 
 47996: #else
149859: #define NS_LOG_WMGETOBJECT(aWnd, aHwnd, aAcc)
149859: #endif
 47996: 
122283: a11y::Accessible*
149859: nsWindow::GetAccessible()
     1: {
102366:   // If the pref was ePlatformIsDisabled, return null here, disabling a11y.
102366:   if (a11y::PlatformDisabledState() == a11y::ePlatformIsDisabled)
106838:     return nullptr;
 39169: 
 30223:   if (mInDtor || mOnDestroyCalled || mWindowType == eWindowType_invisible) {
106838:     return nullptr;
     1:   }
     1: 
149859:   // In case of popup window return a popup accessible.
149859:   nsView* view = nsView::GetViewFor(this);
149859:   if (view) {
149859:     nsIFrame* frame = view->GetFrame();
149859:     if (frame && nsLayoutUtils::IsPopup(frame)) {
149859:       nsCOMPtr<nsIAccessibilityService> accService =
149859:         services::GetAccessibilityService();
149859:       if (accService) {
149859:         a11y::DocAccessible* docAcc =
149859:           GetAccService()->GetDocAccessible(frame->PresContext()->PresShell());
149859:         if (docAcc) {
149859:           NS_LOG_WMGETOBJECT(this, mWnd,
152637:                              docAcc->GetAccessibleOrDescendant(frame->GetContent()));
152637:           return docAcc->GetAccessibleOrDescendant(frame->GetContent());
149859:         }
149859:       }
149859:     }
149859:   }
149859: 
149859:   // otherwise root document accessible.
149859:   NS_LOG_WMGETOBJECT(this, mWnd, GetRootAccessible());
149859:   return GetRootAccessible();
     1: }
     1: #endif
     1: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Transparency
 29835:  **
 29835:  ** Window transparency helpers.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
     1: #ifdef MOZ_XUL
     1: 
108991: void nsWindow::ResizeTranslucentWindow(int32_t aNewWidth, int32_t aNewHeight, bool force)
     1: {
     1:   if (!force && aNewWidth == mBounds.width && aNewHeight == mBounds.height)
     1:     return;
     1: 
 43936:   nsRefPtr<gfxWindowsSurface> newSurface =
181941:     new gfxWindowsSurface(gfxIntSize(aNewWidth, aNewHeight), gfxImageFormat::ARGB32);
 43936:   mTransparentSurface = newSurface;
 43936:   mMemoryDC = newSurface->GetDC();
 43936: }
     1: 
 16601: void nsWindow::SetWindowTranslucencyInner(nsTransparencyMode aMode)
 16601: {
 16601:   if (aMode == mTransparencyMode)
 16601:     return;
     1: 
 46335:   // stop on dialogs and popups!
 86569:   HWND hWnd = WinUtils::GetTopLevelHWND(mWnd, true);
 86569:   nsWindow* parent = WinUtils::GetNSWindowPtr(hWnd);
 46335: 
 46335:   if (!parent)
     1:   {
     1:     NS_WARNING("Trying to use transparent chrome in an embedded context");
 16601:     return;
     1:   }
     1: 
 46335:   if (parent != this) {
 46335:     NS_WARNING("Setting SetWindowTranslucencyInner on a parent this is not us!");
 46335:   }
 46335: 
 46335:   if (aMode == eTransparencyTransparent) {
 46335:     // If we're switching to the use of a transparent window, hide the chrome
 46335:     // on our parent.
 79626:     HideWindowChrome(true);
 46335:   } else if (mHideChrome && mTransparencyMode == eTransparencyTransparent) {
 46335:     // if we're switching out of transparent, re-enable our parent's chrome.
 79626:     HideWindowChrome(false);
 46335:   }
 46335: 
 46335:   LONG_PTR style = ::GetWindowLongPtrW(hWnd, GWL_STYLE),
 46335:     exStyle = ::GetWindowLongPtr(hWnd, GWL_EXSTYLE);
 46335:  
 46335:    if (parent->mIsVisible)
 46335:      style |= WS_VISIBLE;
 46335:    if (parent->mSizeMode == nsSizeMode_Maximized)
 46335:      style |= WS_MAXIMIZE;
 46335:    else if (parent->mSizeMode == nsSizeMode_Minimized)
 46335:      style |= WS_MINIMIZE;
 46335: 
 46335:    if (aMode == eTransparencyTransparent)
 16601:      exStyle |= WS_EX_LAYERED;
 46335:    else
 46335:      exStyle &= ~WS_EX_LAYERED;
 46234: 
 46234:   VERIFY_WINDOW_STYLE(style);
 46234:   ::SetWindowLongPtrW(hWnd, GWL_STYLE, style);
 46234:   ::SetWindowLongPtrW(hWnd, GWL_EXSTYLE, exStyle);
     1: 
 50770:   if (HasGlass())
 42856:     memset(&mGlassMargins, 0, sizeof mGlassMargins);
 16601:   mTransparencyMode = aMode;
 16601: 
 16601:   SetupTranslucentWindowMemoryBitmap(aMode);
 39718:   UpdateGlass();
 16601: }
 16601: 
 16601: void nsWindow::SetupTranslucentWindowMemoryBitmap(nsTransparencyMode aMode)
 16601: {
 16601:   if (eTransparencyTransparent == aMode) {
 79626:     ResizeTranslucentWindow(mBounds.width, mBounds.height, true);
     1:   } else {
106838:     mTransparentSurface = nullptr;
164874:     mMemoryDC = nullptr;
     1:   }
     1: }
     1: 
104347: void nsWindow::ClearTranslucentWindow()
104347: {
104347:   if (mTransparentSurface) {
104347:     nsRefPtr<gfxContext> thebesContext = new gfxContext(mTransparentSurface);
104347:     thebesContext->SetOperator(gfxContext::OPERATOR_CLEAR);
104347:     thebesContext->Paint();
104347:     UpdateTranslucentWindow();
104347:  }
104347: }
104347: 
     1: nsresult nsWindow::UpdateTranslucentWindow()
     1: {
     1:   if (mBounds.IsEmpty())
     1:     return NS_OK;
     1: 
     1:   ::GdiFlush();
     1: 
     1:   BLENDFUNCTION bf = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
     1:   SIZE winSize = { mBounds.width, mBounds.height };
     1:   POINT srcPos = { 0, 0 };
 86569:   HWND hWnd = WinUtils::GetTopLevelHWND(mWnd, true);
     1:   RECT winRect;
     1:   ::GetWindowRect(hWnd, &winRect);
     1: 
     1:   // perform the alpha blend
 79445:   bool updateSuccesful = 
164874:     ::UpdateLayeredWindow(hWnd, nullptr, (POINT*)&winRect, &winSize, mMemoryDC,
164874:                           &srcPos, 0, &bf, ULW_ALPHA);
 43936: 
 44140: #ifdef CAIRO_HAS_D2D_SURFACE
 43936:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 43936:       gfxWindowsPlatform::RENDER_DIRECT2D) {
 43936:     nsIntRect r(0, 0, 0, 0);
 43936:     static_cast<gfxD2DSurface*>(mTransparentSurface.get())->ReleaseDC(&r);
 43936:   }
 44140: #endif
 43936: 
 43936:   if (!updateSuccesful) {
  5223:     return NS_ERROR_FAILURE;
 43936:   }
  5223: 
  5223:   return NS_OK;
  5223: }
  5223: 
 19822: #endif //MOZ_XUL
 29835: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Popup rollup hooks
 29835:  **
 29835:  ** Deals with CaptureRollup on popup windows.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: // Schedules a timer for a window, so we can rollup after processing the hook event
 29835: void nsWindow::ScheduleHookTimer(HWND aWnd, UINT aMsgId)
 29835: {
 29835:   // In some cases multiple hooks may be scheduled
 29835:   // so ignore any other requests once one timer is scheduled
 29835:   if (sHookTimerId == 0) {
 29835:     // Remember the window handle and the message ID to be used later
 29835:     sRollupMsgId = aMsgId;
 29835:     sRollupMsgWnd = aWnd;
 29835:     // Schedule native timer for doing the rollup after
 29835:     // this event is done being processed
164874:     sHookTimerId = ::SetTimer(nullptr, 0, 0, (TIMERPROC)HookTimerForPopups);
 29835:     NS_ASSERTION(sHookTimerId, "Timer couldn't be created.");
 29835:   }
 29835: }
 29835: 
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835: int gLastMsgCode = 0;
 29835: extern MSGFEventMsgInfo gMSGFEvents[];
 29835: #endif
 29835: 
 29835: // Process Menu messages, rollup when popup is clicked.
 29835: LRESULT CALLBACK nsWindow::MozSpecialMsgFilter(int code, WPARAM wParam, LPARAM lParam)
 29835: {
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:   if (sProcessHook) {
 29835:     MSG* pMsg = (MSG*)lParam;
 29835: 
 29835:     int inx = 0;
164874:     while (gMSGFEvents[inx].mId != code && gMSGFEvents[inx].mStr != nullptr) {
 29835:       inx++;
 29835:     }
 29835:     if (code != gLastMsgCode) {
 29835:       if (gMSGFEvents[inx].mId == code) {
 29835: #ifdef DEBUG
 76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                ("MozSpecialMessageProc - code: 0x%X  - %s  hw: %p\n", 
 76714:                 code, gMSGFEvents[inx].mStr, pMsg->hwnd));
 29835: #endif
 29835:       } else {
 29835: #ifdef DEBUG
 76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                ("MozSpecialMessageProc - code: 0x%X  - %d  hw: %p\n", 
 76714:                 code, gMSGFEvents[inx].mId, pMsg->hwnd));
 29835: #endif
 29835:       }
 29835:       gLastMsgCode = code;
 29835:     }
 29835:     PrintEvent(pMsg->message, FALSE, FALSE);
 29835:   }
 29835: #endif // #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835: 
 29835:   if (sProcessHook && code == MSGF_MENU) {
 29835:     MSG* pMsg = (MSG*)lParam;
 29835:     ScheduleHookTimer( pMsg->hwnd, pMsg->message);
 29835:   }
 29835: 
 29835:   return ::CallNextHookEx(sMsgFilterHook, code, wParam, lParam);
 29835: }
 29835: 
 29835: // Process all mouse messages. Roll up when a click is in a native window
 29835: // that doesn't have an nsIWidget.
 29835: LRESULT CALLBACK nsWindow::MozSpecialMouseProc(int code, WPARAM wParam, LPARAM lParam)
 29835: {
 29835:   if (sProcessHook) {
 86569:     switch (WinUtils::GetNativeMessage(wParam)) {
 29835:       case WM_LBUTTONDOWN:
 29835:       case WM_RBUTTONDOWN:
 29835:       case WM_MBUTTONDOWN:
 29835:       case WM_MOUSEWHEEL:
 29835:       case WM_MOUSEHWHEEL:
 29835:       {
 29835:         MOUSEHOOKSTRUCT* ms = (MOUSEHOOKSTRUCT*)lParam;
 86569:         nsIWidget* mozWin = WinUtils::GetNSWindowPtr(ms->hwnd);
 29835:         if (mozWin) {
 29835:           // If this window is windowed plugin window, the mouse events are not
 29835:           // sent to us.
 33357:           if (static_cast<nsWindow*>(mozWin)->mWindowType == eWindowType_plugin)
 29835:             ScheduleHookTimer(ms->hwnd, (UINT)wParam);
 29835:         } else {
 29835:           ScheduleHookTimer(ms->hwnd, (UINT)wParam);
 29835:         }
 29835:         break;
 29835:       }
 29835:     }
 29835:   }
 29835:   return ::CallNextHookEx(sCallMouseHook, code, wParam, lParam);
 29835: }
 29835: 
 29835: // Process all messages. Roll up when the window is moving, or
 29835: // is resizing or when maximized or mininized.
 29835: LRESULT CALLBACK nsWindow::MozSpecialWndProc(int code, WPARAM wParam, LPARAM lParam)
 29835: {
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:   if (sProcessHook) {
 29835:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
 29835:     PrintEvent(cwpt->message, FALSE, FALSE);
 29835:   }
 29835: #endif
 29835: 
 29835:   if (sProcessHook) {
 29835:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
 29835:     if (cwpt->message == WM_MOVING ||
 29835:         cwpt->message == WM_SIZING ||
 29835:         cwpt->message == WM_GETMINMAXINFO) {
 29835:       ScheduleHookTimer(cwpt->hwnd, (UINT)cwpt->message);
 29835:     }
 29835:   }
 29835: 
 29835:   return ::CallNextHookEx(sCallProcHook, code, wParam, lParam);
 29835: }
 29835: 
 29835: // Register the special "hooks" for dropdown processing.
 29835: void nsWindow::RegisterSpecialDropdownHooks()
 29835: {
 29835:   NS_ASSERTION(!sMsgFilterHook, "sMsgFilterHook must be NULL!");
 29835:   NS_ASSERTION(!sCallProcHook,  "sCallProcHook must be NULL!");
 29835: 
 29835:   DISPLAY_NMM_PRT("***************** Installing Msg Hooks ***************\n");
 29835: 
 29835:   // Install msg hook for moving the window and resizing
 29835:   if (!sMsgFilterHook) {
 29835:     DISPLAY_NMM_PRT("***** Hooking sMsgFilterHook!\n");
164874:     sMsgFilterHook = SetWindowsHookEx(WH_MSGFILTER, MozSpecialMsgFilter,
164874:                                       nullptr, GetCurrentThreadId());
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:     if (!sMsgFilterHook) {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:              ("***** SetWindowsHookEx is NOT installed for WH_MSGFILTER!\n"));
 29835:     }
 29835: #endif
 29835:   }
 29835: 
 29835:   // Install msg hook for menus
 29835:   if (!sCallProcHook) {
 29835:     DISPLAY_NMM_PRT("***** Hooking sCallProcHook!\n");
164874:     sCallProcHook  = SetWindowsHookEx(WH_CALLWNDPROC, MozSpecialWndProc,
164874:                                       nullptr, GetCurrentThreadId());
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:     if (!sCallProcHook) {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:              ("***** SetWindowsHookEx is NOT installed for WH_CALLWNDPROC!\n"));
 29835:     }
 29835: #endif
 29835:   }
 29835: 
 29835:   // Install msg hook for the mouse
 29835:   if (!sCallMouseHook) {
 29835:     DISPLAY_NMM_PRT("***** Hooking sCallMouseHook!\n");
164874:     sCallMouseHook  = SetWindowsHookEx(WH_MOUSE, MozSpecialMouseProc,
164874:                                        nullptr, GetCurrentThreadId());
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:     if (!sCallMouseHook) {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:              ("***** SetWindowsHookEx is NOT installed for WH_MOUSE!\n"));
 29835:     }
 29835: #endif
 29835:   }
 29835: }
 29835: 
 29835: // Unhook special message hooks for dropdowns.
 29835: void nsWindow::UnregisterSpecialDropdownHooks()
 29835: {
 29835:   DISPLAY_NMM_PRT("***************** De-installing Msg Hooks ***************\n");
 29835: 
 29835:   if (sCallProcHook) {
 29835:     DISPLAY_NMM_PRT("***** Unhooking sCallProcHook!\n");
 29835:     if (!::UnhookWindowsHookEx(sCallProcHook)) {
 29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sCallProcHook!\n");
 29835:     }
164874:     sCallProcHook = nullptr;
 29835:   }
 29835: 
 29835:   if (sMsgFilterHook) {
 29835:     DISPLAY_NMM_PRT("***** Unhooking sMsgFilterHook!\n");
 29835:     if (!::UnhookWindowsHookEx(sMsgFilterHook)) {
 29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sMsgFilterHook!\n");
 29835:     }
164874:     sMsgFilterHook = nullptr;
 29835:   }
 29835: 
 29835:   if (sCallMouseHook) {
 29835:     DISPLAY_NMM_PRT("***** Unhooking sCallMouseHook!\n");
 29835:     if (!::UnhookWindowsHookEx(sCallMouseHook)) {
 29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sCallMouseHook!\n");
 29835:     }
164874:     sCallMouseHook = nullptr;
 29835:   }
 29835: }
 29835: 
 29835: // This timer is designed to only fire one time at most each time a "hook" function
 29835: // is used to rollup the dropdown. In some cases, the timer may be scheduled from the
 29835: // hook, but that hook event or a subsequent event may roll up the dropdown before
 29835: // this timer function is executed.
 29835: //
 29835: // For example, if an MFC control takes focus, the combobox will lose focus and rollup
 29835: // before this function fires.
 29835: VOID CALLBACK nsWindow::HookTimerForPopups(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
 29835: {
 29835:   if (sHookTimerId != 0) {
164874:     // if the window is nullptr then we need to use the ID to kill the timer
164874:     BOOL status = ::KillTimer(nullptr, sHookTimerId);
 29835:     NS_ASSERTION(status, "Hook Timer was not killed.");
 29835:     sHookTimerId = 0;
 29835:   }
 29835: 
 29835:   if (sRollupMsgId != 0) {
120177:     // Note: DealWithPopups does the check to make sure that the rollup widget is set.
 29835:     LRESULT popupHandlingResult;
 29835:     nsAutoRollup autoRollup;
 29835:     DealWithPopups(sRollupMsgWnd, sRollupMsgId, 0, 0, &popupHandlingResult);
 29835:     sRollupMsgId = 0;
164874:     sRollupMsgWnd = nullptr;
 29835:   }
 29835: }
 29835: 
 51000: BOOL CALLBACK nsWindow::ClearResourcesCallback(HWND aWnd, LPARAM aMsg)
 50583: {
 86569:     nsWindow *window = WinUtils::GetNSWindowPtr(aWnd);
 50583:     if (window) {
 51000:         window->ClearCachedResources();
 50583:     }  
 50583:     return TRUE;
 50583: }
 50583: 
 50583: void
 51000: nsWindow::ClearCachedResources()
 51000: {
 51000: #ifdef CAIRO_HAS_D2D_SURFACE
106838:     mD2DWindowSurface = nullptr;
 51000: #endif
 51000:     if (mLayerManager &&
181945:         mLayerManager->GetBackendType() == LayersBackend::LAYERS_BASIC) {
159030:       mLayerManager->ClearCachedResources();
 51000:     }
 61525:     ::EnumChildWindows(mWnd, nsWindow::ClearResourcesCallback, 0);
 51000: }
 50583: 
 79445: static bool IsDifferentThreadWindow(HWND aWnd)
 29835: {
164874:   return ::GetCurrentThreadId() != ::GetWindowThreadProcessId(aWnd, nullptr);
 29835: }
 29835: 
178885: // static
 79445: bool
178887: nsWindow::EventIsInsideWindow(nsWindow* aWindow)
 29835: {
 29835:   RECT r;
 29835:   ::GetWindowRect(aWindow->mWnd, &r);
 29835:   DWORD pos = ::GetMessagePos();
 29835:   POINT mp;
 29835:   mp.x = GET_X_LPARAM(pos);
 29835:   mp.y = GET_Y_LPARAM(pos);
 29835: 
 29835:   // was the event inside this window?
178885:   return static_cast<bool>(::PtInRect(&r, mp));
178885: }
178885: 
178885: // static
127124: bool
178888: nsWindow::GetPopupsToRollup(nsIRollupListener* aRollupListener,
178888:                             uint32_t* aPopupsToRollup)
178888: {
178888:   // If we're dealing with menus, we probably have submenus and we don't want
178888:   // to rollup some of them if the click is in a parent menu of the current
178888:   // submenu.
178888:   *aPopupsToRollup = UINT32_MAX;
178888:   nsAutoTArray<nsIWidget*, 5> widgetChain;
178888:   uint32_t sameTypeCount =
178888:     aRollupListener->GetSubmenuWidgetChain(&widgetChain);
178888:   for (uint32_t i = 0; i < widgetChain.Length(); ++i) {
178888:     nsIWidget* widget = widgetChain[i];
178888:     if (EventIsInsideWindow(static_cast<nsWindow*>(widget))) {
178888:       // Don't roll up if the mouse event occurred within a menu of the
178888:       // same type. If the mouse event occurred in a menu higher than that,
178888:       // roll up, but pass the number of popups to Rollup so that only those
178888:       // of the same type close up.
178888:       if (i < sameTypeCount) {
178888:         return false;
178888:       }
178888: 
178888:       *aPopupsToRollup = sameTypeCount;
178888:       break;
178888:     }
178888:   }
178888:   return true;
178888: }
178888: 
178888: // static
178888: bool
179345: nsWindow::NeedsToHandleNCActivateDelayed(HWND aWnd)
179345: {
179345:   // While popup is open, popup window might be activated by other application.
179345:   // At this time, we need to take back focus to the previous window but it
179345:   // causes flickering its nonclient area because WM_NCACTIVATE comes before
179345:   // WM_ACTIVATE and we cannot know which window will take focus at receiving
179345:   // WM_NCACTIVATE. Therefore, we need a hack for preventing the flickerling.
179345:   //
179345:   // If non-popup window receives WM_NCACTIVATE at deactivating, default
179345:   // wndproc shouldn't handle it as deactivating. Instead, at receiving
179345:   // WM_ACTIVIATE after that, WM_NCACTIVATE should be sent again manually.
179345:   // This returns true if the window needs to handle WM_NCACTIVATE later.
179345: 
179345:   nsWindow* window = WinUtils::GetNSWindowPtr(aWnd);
179345:   return window && !window->IsPopup();
179345: }
179345: 
179345: // static
179345: bool
178885: nsWindow::DealWithPopups(HWND aWnd, UINT aMessage,
178885:                          WPARAM aWParam, LPARAM aLParam, LRESULT* aResult)
178885: {
178885:   NS_ASSERTION(aResult, "Bad outResult");
178885: 
178890:   // XXX Why do we use the return value of WM_MOUSEACTIVATE for all messages?
178885:   *aResult = MA_NOACTIVATE;
178885: 
178885:   if (!::IsWindowVisible(aWnd)) {
127124:     return false;
178885:   }
178885: 
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
127124:   NS_ENSURE_TRUE(rollupListener, false);
178885: 
178885:   nsCOMPtr<nsIWidget> popup = rollupListener->GetRollupWidget();
178885:   if (!popup) {
127479:     return false;
178885:   }
178885: 
179345:   static bool sSendingNCACTIVATE = false;
179345:   static bool sPendingNCACTIVATE = false;
178888:   uint32_t popupsToRollup = UINT32_MAX;
178887: 
178887:   nsWindow* popupWindow = static_cast<nsWindow*>(popup.get());
178885:   UINT nativeMessage = WinUtils::GetNativeMessage(aMessage);
178885:   switch (nativeMessage) {
178885:     case WM_LBUTTONDOWN:
178885:     case WM_RBUTTONDOWN:
178885:     case WM_MBUTTONDOWN:
178885:     case WM_NCLBUTTONDOWN:
178885:     case WM_NCRBUTTONDOWN:
178885:     case WM_NCMBUTTONDOWN:
178889:       if (!EventIsInsideWindow(popupWindow) &&
178889:           GetPopupsToRollup(rollupListener, &popupsToRollup)) {
178889:         break;
178889:       }
178889:       return false;
178885: 
178885:     case WM_MOUSEWHEEL:
178885:     case WM_MOUSEHWHEEL:
178887:       // We need to check if the popup thinks that it should cause closing
178887:       // itself when mouse wheel events are fired outside the rollup widget.
178887:       if (!EventIsInsideWindow(popupWindow)) {
178887:         *aResult = MA_ACTIVATE;
178889:         if (rollupListener->ShouldRollupOnMouseWheelEvent() &&
178889:             GetPopupsToRollup(rollupListener, &popupsToRollup)) {
178889:           break;
178889:         }
178889:       }
178889:       return false;
178887: 
178887:     case WM_ACTIVATEAPP:
178885:       break;
178885: 
178885:     case WM_ACTIVATE:
179345:       // NOTE: Don't handle WA_INACTIVE for preventing popup taking focus
179345:       // because we cannot distinguish it's caused by mouse or not.
179345:       if (LOWORD(aWParam) == WA_ACTIVE && aLParam) {
179345:         nsWindow* window = WinUtils::GetNSWindowPtr(aWnd);
179345:         if (window && window->IsPopup()) {
179345:           // Cancel notifying widget listeners of deactivating the previous
179345:           // active window (see WM_KILLFOCUS case in ProcessMessage()).
179345:           sJustGotDeactivate = false;
179345:           // Reactivate the window later.
179345:           ::PostMessageW(aWnd, MOZ_WM_REACTIVATE, aWParam, aLParam);
179345:           return true;
179345:         }
180235:         // Don't rollup the popup when focus moves back to the parent window
180235:         // from a popup because such case is caused by strange mouse drivers.
180235:         nsWindow* prevWindow =
180235:           WinUtils::GetNSWindowPtr(reinterpret_cast<HWND>(aLParam));
180235:         if (prevWindow && prevWindow->IsPopup()) {
180235:           return false;
180235:         }
180235:       } else if (LOWORD(aWParam) == WA_INACTIVE) {
180235:         nsWindow* activeWindow =
180235:           WinUtils::GetNSWindowPtr(reinterpret_cast<HWND>(aLParam));
180235:         if (sPendingNCACTIVATE && NeedsToHandleNCActivateDelayed(aWnd)) {
179345:           // If focus moves to non-popup widget or focusable popup, the window
179345:           // needs to update its nonclient area.
179345:           if (!activeWindow || !activeWindow->IsPopup()) {
179345:             sSendingNCACTIVATE = true;
179345:             ::SendMessageW(aWnd, WM_NCACTIVATE, false, 0);
179345:             sSendingNCACTIVATE = false;
179345:           }
179345:           sPendingNCACTIVATE = false;
179345:         }
180235:         // If focus moves from/to popup, we don't need to rollup the popup
180235:         // because such case is caused by strange mouse drivers.
180235:         if (activeWindow) {
180235:           if (activeWindow->IsPopup()) {
178889:             return false;
180235:           }
180235:           nsWindow* deactiveWindow = WinUtils::GetNSWindowPtr(aWnd);
180235:           if (deactiveWindow && deactiveWindow->IsPopup()) {
180235:             return false;
180235:           }
180235:         }
180235:       }
180235:       break;
178889: 
179345:     case MOZ_WM_REACTIVATE:
179345:       // The previous active window should take back focus.
179345:       if (::IsWindow(reinterpret_cast<HWND>(aLParam))) {
179345:         ::SetForegroundWindow(reinterpret_cast<HWND>(aLParam));
179345:       }
179345:       return true;
179345: 
179345:     case WM_NCACTIVATE:
179345:       if (!aWParam && !sSendingNCACTIVATE &&
179345:           NeedsToHandleNCActivateDelayed(aWnd)) {
179345:         // Don't just consume WM_NCACTIVATE. It doesn't handle only the
179345:         // nonclient area state change.
179345:         ::DefWindowProcW(aWnd, aMessage, TRUE, aLParam);
179345:         // Accept the deactivating because it's necessary to receive following
179345:         // WM_ACTIVATE.
179345:         *aResult = TRUE;
179345:         sPendingNCACTIVATE = true;
179345:         return true;
179345:       }
179345:       return false;
179345: 
178885:     case WM_MOUSEACTIVATE:
178889:       if (!EventIsInsideWindow(popupWindow) &&
178889:           GetPopupsToRollup(rollupListener, &popupsToRollup)) {
178889:         // WM_MOUSEACTIVATE may be caused by moving the mouse (e.g., X-mouse
178889:         // of TweakUI is enabled. Then, check if the popup should be rolled up
178889:         // with rollup listener. If not, just consume the message.
178889:         if (HIWORD(aLParam) == WM_MOUSEMOVE &&
178889:             !rollupListener->ShouldRollupOnMouseActivate()) {
178889:           return true;
178889:         }
178889:         // Otherwise, it should be handled by wndproc.
178889:         return false;
178889:       }
178889: 
178889:       // Prevent the click inside the popup from causing a change in window
178889:       // activation. Since the popup is shown non-activated, we need to eat any
178889:       // requests to activate the window while it is displayed. Windows will
178889:       // automatically activate the popup on the mousedown otherwise.
178889:       return true;
178885: 
178885:     case WM_KILLFOCUS:
178885:       // If focus moves to other window created in different process/thread,
178885:       // e.g., a plugin window, popups should be rolled up.
178885:       if (IsDifferentThreadWindow(reinterpret_cast<HWND>(aWParam))) {
180235:         break;
178885:       }
178885:       return false;
178885: 
178885:     case WM_MOVING:
178885:     case WM_SIZING:
178885:     case WM_MENUSELECT:
180235:       break;
178885: 
178885:     default:
178885:       return false;
178885:   }
178885: 
178885:   // Only need to deal with the last rollup for left mouse down events.
 82030:   NS_ASSERTION(!mLastRollup, "mLastRollup is null");
169007: 
169007:   bool consumeRollupEvent;
178885:   if (nativeMessage == WM_LBUTTONDOWN) {
169007:     POINT pt;
178885:     pt.x = GET_X_LPARAM(aLParam);
178885:     pt.y = GET_Y_LPARAM(aLParam);
178885:     ::ClientToScreen(aWnd, &pt);
169007:     nsIntPoint pos(pt.x, pt.y);
169007: 
178885:     consumeRollupEvent =
178885:       rollupListener->Rollup(popupsToRollup, &pos, &mLastRollup);
 82030:     NS_IF_ADDREF(mLastRollup);
178885:   } else {
178885:     consumeRollupEvent =
178885:       rollupListener->Rollup(popupsToRollup, nullptr, nullptr);
169007:   }
 29835: 
 29835:   // Tell hook to stop processing messages
 79626:   sProcessHook = false;
 29835:   sRollupMsgId = 0;
164874:   sRollupMsgWnd = nullptr;
 29835: 
178885:   // If we are NOT supposed to be consuming events, let it go through
178885:   if (consumeRollupEvent && nativeMessage != WM_RBUTTONDOWN) {
178885:     *aResult = MA_ACTIVATE;
127124:     return true;
 29835:   }
127124: 
127124:   return false;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Misc. utility methods and functions.
 29835:  **
 29835:  ** General use.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: // Note that the result of GetTopLevelWindow method can be different from the
 86569: // result of WinUtils::GetTopLevelHWND().  The result can be non-floating
 86569: // window.  Because our top level window may be contained in another window
 86569: // which is not managed by us.
 79445: nsWindow* nsWindow::GetTopLevelWindow(bool aStopOnDialogOrPopup)
 29835: {
 29835:   nsWindow* curWindow = this;
 29835: 
 79626:   while (true) {
 29835:     if (aStopOnDialogOrPopup) {
 29835:       switch (curWindow->mWindowType) {
 29835:         case eWindowType_dialog:
 29835:         case eWindowType_popup:
 29835:           return curWindow;
 51212:         default:
 51212:           break;
 29835:       }
 29835:     }
 29835: 
 29835:     // Retrieve the top level parent or owner window
 79626:     nsWindow* parentWindow = curWindow->GetParentWindow(true);
 29835: 
 29835:     if (!parentWindow)
 29835:       return curWindow;
 29835: 
 29835:     curWindow = parentWindow;
 29835:   }
 29835: }
 29835: 
 29835: static BOOL CALLBACK gEnumWindowsProc(HWND hwnd, LPARAM lParam)
 29835: {
 29835:   DWORD pid;
 29835:   ::GetWindowThreadProcessId(hwnd, &pid);
 29835:   if (pid == GetCurrentProcessId() && ::IsWindowVisible(hwnd))
 29835:   {
 79626:     gWindowsVisible = true;
 29835:     return FALSE;
 29835:   }
 29835:   return TRUE;
 29835: }
 29835: 
 79445: bool nsWindow::CanTakeFocus()
 29835: {
 79626:   gWindowsVisible = false;
 29835:   EnumWindows(gEnumWindowsProc, 0);
 29835:   if (!gWindowsVisible) {
 79626:     return true;
 29835:   } else {
 29835:     HWND fgWnd = ::GetForegroundWindow();
 29835:     if (!fgWnd) {
 79626:       return true;
 29835:     }
 29835:     DWORD pid;
 29835:     GetWindowThreadProcessId(fgWnd, &pid);
 29835:     if (pid == GetCurrentProcessId()) {
 79626:       return true;
 79626:     }
 79626:   }
 79626:   return false;
 29835: }
 29835: 
 57092: void nsWindow::GetMainWindowClass(nsAString& aClass)
 57092: {
 70956:   NS_PRECONDITION(aClass.IsEmpty(), "aClass should be empty string");
 70956:   nsresult rv = Preferences::GetString("ui.window_class_override", &aClass);
 70956:   if (NS_FAILED(rv) || aClass.IsEmpty()) {
 57092:     aClass.AssignASCII(sDefaultMainWindowClass);
 57092:   }
 70956: }
 57092: 
 30750: LPARAM nsWindow::lParamToScreen(LPARAM lParam)
 30750: {
 30750:   POINT pt;
 30750:   pt.x = GET_X_LPARAM(lParam);
 30750:   pt.y = GET_Y_LPARAM(lParam);
 30750:   ::ClientToScreen(mWnd, &pt);
 30750:   return MAKELPARAM(pt.x, pt.y);
 30750: }
 30750: 
 30750: LPARAM nsWindow::lParamToClient(LPARAM lParam)
 30750: {
 30750:   POINT pt;
 30750:   pt.x = GET_X_LPARAM(lParam);
 30750:   pt.y = GET_Y_LPARAM(lParam);
 30750:   ::ScreenToClient(mWnd, &pt);
 30750:   return MAKELPARAM(pt.x, pt.y);
 30750: }
 30750: 
 84178: void nsWindow::PickerOpen()
 84178: {
 84178:   mPickerDisplayCount++;
 84178: }
 84178: 
 84178: void nsWindow::PickerClosed()
 84178: {
 84178:   NS_ASSERTION(mPickerDisplayCount > 0, "mPickerDisplayCount out of sync!");
 84178:   if (!mPickerDisplayCount)
 84178:     return;
 84178:   mPickerDisplayCount--;
 84178:   if (!mPickerDisplayCount && mDestroyCalled) {
 84178:     Destroy();
 84178:   }
 84178: }
 84178: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: ChildWindow impl.
 29835:  **
 29835:  ** Child window overrides.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: // return the style for a child nsWindow
 29835: DWORD ChildWindow::WindowStyle()
 29835: {
 29835:   DWORD style = WS_CLIPCHILDREN | nsWindow::WindowStyle();
 29835:   if (!(style & WS_POPUP))
 29835:     style |= WS_CHILD; // WS_POPUP and WS_CHILD are mutually exclusive.
 29835:   VERIFY_WINDOW_STYLE(style);
 29835:   return style;
 31006: }
