    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nspr.h"
    1: #include "prlog.h"
    1: 
    1: #include "nsDocLoader.h"
    1: #include "nsCURILoader.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIWebProgressListener2.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsXPIDLString.h"
    1: 
    1: #include "nsIURL.h"
    1: #include "nsCOMPtr.h"
    1: #include "nscore.h"
    1: #include "nsWeakPtr.h"
    1: #include "nsAutoPtr.h"
    1: 
    1: #include "nsIDOMWindow.h"
    1: 
    1: #include "nsIStringBundle.h"
    1: #include "nsIScriptSecurityManager.h"
    1: 
    1: #include "nsITransport.h"
    1: #include "nsISocketTransport.h"
    1: 
25008: #include "nsIDOMDocument.h"
25008: #include "nsIDocument.h"
47906: #include "nsPresContext.h"
48889: #include "nsIAsyncVerifyRedirectCallback.h"
25008: 
    1: static NS_DEFINE_CID(kThisImplCID, NS_THIS_DOCLOADER_IMPL_CID);
    1: 
    1: #if defined(PR_LOGGING)
    1: //
    1: // Log module for nsIDocumentLoader logging...
    1: //
    1: // To enable logging (see prlog.h for full details):
    1: //
    1: //    set NSPR_LOG_MODULES=DocLoader:5
    1: //    set NSPR_LOG_FILE=nspr.log
    1: //
    1: // this enables PR_LOG_DEBUG level information and places all output in
    1: // the file nspr.log
    1: //
    1: PRLogModuleInfo* gDocLoaderLog = nsnull;
    1: #endif /* PR_LOGGING */
    1: 
    1: 
    1: #if defined(DEBUG)
    1: void GetURIStringFromRequest(nsIRequest* request, nsACString &name)
    1: {
    1:     if (request)
    1:         request->GetName(name);
    1:     else
    1:         name.AssignLiteral("???");
    1: }
    1: #endif /* DEBUG */
    1: 
    1: struct nsRequestInfo : public PLDHashEntryHdr
    1: {
    1:   nsRequestInfo(const void *key)
    1:     : mKey(key), mCurrentProgress(0), mMaxProgress(0), mUploading(PR_FALSE)
77946:    , mIsDone(PR_FALSE)
    1:   {
    1:   }
    1: 
30795:   nsIRequest* Request() {
30795:     return static_cast<nsIRequest*>(const_cast<void*>(mKey));
30795:   }
30795: 
    1:   const void* mKey; // Must be first for the pldhash stubs to work
64617:   PRInt64 mCurrentProgress;
64617:   PRInt64 mMaxProgress;
    1:   PRBool mUploading;
30795: 
77946:   PRBool mIsDone;
77946:   nsString mLastStatus;
77946:   nsresult mLastStatusCode;
    1: };
    1: 
    1: 
20261: static PRBool
    1: RequestInfoHashInitEntry(PLDHashTable *table, PLDHashEntryHdr *entry,
    1:                          const void *key)
    1: {
    1:   // Initialize the entry with placement new
    1:   new (entry) nsRequestInfo(key);
    1:   return PR_TRUE;
    1: }
    1: 
30797: static void
30797: RequestInfoHashClearEntry(PLDHashTable *table, PLDHashEntryHdr *entry)
30797: {
30797:   nsRequestInfo* info = static_cast<nsRequestInfo *>(entry);
30797:   info->~nsRequestInfo();
30797: }
29263: 
29263: struct nsListenerInfo {
29263:   nsListenerInfo(nsIWeakReference *aListener, unsigned long aNotifyMask) 
29263:     : mWeakListener(aListener),
29263:       mNotifyMask(aNotifyMask)
29263:   {
28579:   }
29263: 
29263:   // Weak pointer for the nsIWebProgressListener...
29263:   nsWeakPtr mWeakListener;
29263: 
29263:   // Mask indicating which notifications the listener wants to receive.
29263:   unsigned long mNotifyMask;
28579: };
28579: 
29263: 
    1: nsDocLoader::nsDocLoader()
25008:   : mParent(nsnull),
29263:     mListenerInfoList(8),
64617:     mCurrentSelfProgress(0),
64617:     mMaxSelfProgress(0),
64617:     mCurrentTotalProgress(0),
64617:     mMaxTotalProgress(0),
64617:     mCompletedTotalProgress(0),
25008:     mIsLoadingDocument(PR_FALSE),
25008:     mIsRestoringDocument(PR_FALSE),
40679:     mDontFlushLayout(PR_FALSE),
25008:     mIsFlushingLayout(PR_FALSE)
    1: {
    1: #if defined(PR_LOGGING)
    1:   if (nsnull == gDocLoaderLog) {
    1:       gDocLoaderLog = PR_NewLogModule("DocLoader");
    1:   }
    1: #endif /* PR_LOGGING */
    1: 
    1:   static PLDHashTableOps hash_table_ops =
    1:   {
    1:     PL_DHashAllocTable,
    1:     PL_DHashFreeTable,
    1:     PL_DHashVoidPtrKeyStub,
    1:     PL_DHashMatchEntryStub,
    1:     PL_DHashMoveEntryStub,
30797:     RequestInfoHashClearEntry,
    1:     PL_DHashFinalizeStub,
    1:     RequestInfoHashInitEntry
    1:   };
    1: 
    1:   if (!PL_DHashTableInit(&mRequestInfoHash, &hash_table_ops, nsnull,
    1:                          sizeof(nsRequestInfo), 16)) {
    1:     mRequestInfoHash.ops = nsnull;
    1:   }
    1: 
    1:   ClearInternalProgress();
    1: 
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: created.\n", this));
    1: }
    1: 
    1: nsresult
    1: nsDocLoader::SetDocLoaderParent(nsDocLoader *aParent)
    1: {
    1:   mParent = aParent;
    1:   return NS_OK; 
    1: }
    1: 
    1: nsresult
    1: nsDocLoader::Init()
    1: {
    1:   if (!mRequestInfoHash.ops) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   nsresult rv = NS_NewLoadGroup(getter_AddRefs(mLoadGroup), this);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: load group %x.\n", this, mLoadGroup.get()));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsDocLoader::~nsDocLoader()
    1: {
    1: 		/*
    1: 			|ClearWeakReferences()| here is intended to prevent people holding weak references
    1: 			from re-entering this destructor since |QueryReferent()| will |AddRef()| me, and the
    1: 			subsequent |Release()| will try to destroy me.  At this point there should be only
    1: 			weak references remaining (otherwise, we wouldn't be getting destroyed).
    1: 
    1: 			An alternative would be incrementing our refcount (consider it a compressed flag
    1: 			saying "Don't re-destroy.").  I haven't yet decided which is better. [scc]
    1: 		*/
    1:   // XXXbz now that NS_IMPL_RELEASE stabilizes by setting refcount to 1, is
    1:   // this needed?
    1:   ClearWeakReferences();
    1: 
    1:   Destroy();
    1: 
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG,
    1:          ("DocLoader:%p: deleted.\n", this));
    1: 
    1:   if (mRequestInfoHash.ops) {
    1:     PL_DHashTableFinish(&mRequestInfoHash);
    1:   }
    1: }
    1: 
    1: 
    1: /*
    1:  * Implementation of ISupports methods...
    1:  */
19169: NS_IMPL_THREADSAFE_ADDREF(nsDocLoader)
19169: NS_IMPL_THREADSAFE_RELEASE(nsDocLoader)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsDocLoader)
    1:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIRequestObserver)
    1:    NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
    1:    NS_INTERFACE_MAP_ENTRY(nsIDocumentLoader)
    1:    NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:    NS_INTERFACE_MAP_ENTRY(nsIWebProgress)
    1:    NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)   
    1:    NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
    1:    NS_INTERFACE_MAP_ENTRY(nsIChannelEventSink)
    1:    NS_INTERFACE_MAP_ENTRY(nsISecurityEventSink)
    1:    NS_INTERFACE_MAP_ENTRY(nsISupportsPriority)
    1:    if (aIID.Equals(kThisImplCID))
 3233:      foundInterface = static_cast<nsIDocumentLoader *>(this);
    1:    else
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: /*
    1:  * Implementation of nsIInterfaceRequestor methods...
    1:  */
    1: NS_IMETHODIMP nsDocLoader::GetInterface(const nsIID& aIID, void** aSink)
    1: {
    1:   nsresult rv = NS_ERROR_NO_INTERFACE;
    1: 
    1:   NS_ENSURE_ARG_POINTER(aSink);
    1: 
    1:   if(aIID.Equals(NS_GET_IID(nsILoadGroup))) {
    1:     *aSink = mLoadGroup;
    1:     NS_IF_ADDREF((nsISupports*)*aSink);
    1:     rv = NS_OK;
    1:   } else {
    1:     rv = QueryInterface(aIID, aSink);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* static */
    1: already_AddRefed<nsDocLoader>
    1: nsDocLoader::GetAsDocLoader(nsISupports* aSupports)
    1: {
    1:   if (!aSupports) {
    1:     return nsnull;
    1:   }
    1:   
    1:   nsDocLoader* ptr;
    1:   CallQueryInterface(aSupports, &ptr);
    1:   return ptr;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsDocLoader::AddDocLoaderAsChildOfRoot(nsDocLoader* aDocLoader)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIDocumentLoader> docLoaderService =
    1:     do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsRefPtr<nsDocLoader> rootDocLoader = GetAsDocLoader(docLoaderService);
    1:   NS_ENSURE_TRUE(rootDocLoader, NS_ERROR_UNEXPECTED);
    1: 
    1:   return rootDocLoader->AddChildLoader(aDocLoader);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::Stop(void)
    1: {
    1:   nsresult rv = NS_OK;
29263:   PRInt32 count, i;
    1: 
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: Stop() called\n", this));
    1: 
29263:   count = mChildList.Count();
    1: 
    1:   nsCOMPtr<nsIDocumentLoader> loader;
    1:   for (i=0; i < count; i++) {
29263:     loader = ChildAt(i);
    1: 
    1:     if (loader) {
    1:       (void) loader->Stop();
    1:     }
    1:   }
    1: 
    1:   if (mLoadGroup)
    1:     rv = mLoadGroup->Cancel(NS_BINDING_ABORTED);
    1: 
40679:   // Don't report that we're flushing layout so IsBusy returns false after a
40679:   // Stop call.
40679:   mIsFlushingLayout = PR_FALSE;
40679: 
    1:   // Clear out mChildrenInOnload.  We want to make sure to fire our
    1:   // onload at this point, and there's no issue with mChildrenInOnload
    1:   // after this, since mDocumentRequest will be null after the
    1:   // DocLoaderIsEmpty() call.
    1:   mChildrenInOnload.Clear();
    1: 
    1:   // Make sure to call DocLoaderIsEmpty now so that we reset mDocumentRequest,
    1:   // etc, as needed.  We could be getting into here from a subframe onload, in
    1:   // which case the call to DocLoaderIsEmpty() is coming but hasn't quite
    1:   // happened yet, Canceling the loadgroup did nothing (because it was already
    1:   // empty), and we're about to start a new load (which is what triggered this
    1:   // Stop() call).
    1: 
    1:   // XXXbz If the child frame loadgroups were requests in mLoadgroup, I suspect
    1:   // we wouldn't need the call here....
    1: 
    1:   NS_ASSERTION(!IsBusy(), "Shouldn't be busy here");
25008:   DocLoaderIsEmpty(PR_FALSE);
    1:   
    1:   return rv;
    1: }       
    1: 
    1: 
    1: PRBool
    1: nsDocLoader::IsBusy()
    1: {
    1:   nsresult rv;
    1: 
    1:   //
    1:   // A document loader is busy if either:
    1:   //
    1:   //   1. One of its children is in the middle of an onload handler.  Note that
    1:   //      the handler may have already removed this child from mChildList!
    1:   //   2. It is currently loading a document and either has parts of it still
    1:   //      loading, or has a busy child docloader.
25008:   //   3. It's currently flushing layout in DocLoaderIsEmpty().
    1:   //
    1: 
25008:   if (mChildrenInOnload.Count() || mIsFlushingLayout) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   /* Is this document loader busy? */
    1:   if (!mIsLoadingDocument) {
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   PRBool busy;
    1:   rv = mLoadGroup->IsPending(&busy);
    1:   if (NS_FAILED(rv)) {
    1:     return PR_FALSE;
    1:   }
    1:   if (busy) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   /* check its child document loaders... */
29263:   PRInt32 count, i;
    1: 
29263:   count = mChildList.Count();
    1: 
    1:   for (i=0; i < count; i++) {
29263:     nsIDocumentLoader* loader = ChildAt(i);
    1: 
    1:     // This is a safe cast, because we only put nsDocLoader objects into the
    1:     // array
 3233:     if (loader && static_cast<nsDocLoader*>(loader)->IsBusy())
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::GetContainer(nsISupports** aResult)
    1: {
 3233:    NS_ADDREF(*aResult = static_cast<nsIDocumentLoader*>(this));
    1: 
    1:    return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::GetLoadGroup(nsILoadGroup** aResult)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (nsnull == aResult) {
    1:     rv = NS_ERROR_NULL_POINTER;
    1:   } else {
    1:     *aResult = mLoadGroup;
    1:     NS_IF_ADDREF(*aResult);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsDocLoader::Destroy()
    1: {
    1:   Stop();
    1: 
    1:   // Remove the document loader from the parent list of loaders...
    1:   if (mParent) 
    1:   {
    1:     mParent->RemoveChildLoader(this);
    1:   }
    1: 
    1:   // Release all the information about network requests...
    1:   ClearRequestInfoHash();
    1: 
29263:   // Release all the information about registered listeners...
29263:   PRInt32 count = mListenerInfoList.Count();
29263:   for(PRInt32 i = 0; i < count; i++) {
29263:     nsListenerInfo *info =
29263:       static_cast<nsListenerInfo*>(mListenerInfoList.ElementAt(i));
29263: 
29263:     delete info;
29263:   }
29263: 
    1:   mListenerInfoList.Clear();
    1:   mListenerInfoList.Compact();
    1: 
    1:   mDocumentRequest = 0;
    1: 
    1:   if (mLoadGroup)
    1:     mLoadGroup->SetGroupObserver(nsnull);
    1: 
    1:   DestroyChildren();
    1: }
    1: 
    1: void
    1: nsDocLoader::DestroyChildren()
    1: {
29263:   PRInt32 i, count;
    1:   
29263:   count = mChildList.Count();
    1:   // if the doc loader still has children...we need to enumerate the
    1:   // children and make them null out their back ptr to the parent doc
    1:   // loader
    1:   for (i=0; i < count; i++)
    1:   {
29263:     nsIDocumentLoader* loader = ChildAt(i);
    1: 
    1:     if (loader) {
    1:       // This is a safe cast, as we only put nsDocLoader objects into the
    1:       // array
 3233:       static_cast<nsDocLoader*>(loader)->SetDocLoaderParent(nsnull);
    1:     }
    1:   }
    1:   mChildList.Clear();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::OnStartRequest(nsIRequest *request, nsISupports *aCtxt)
    1: {
    1:   // called each time a request is added to the group.
    1: 
    1: #ifdef PR_LOGGING
    1:   if (PR_LOG_TEST(gDocLoaderLog, PR_LOG_DEBUG)) {
    1:     nsCAutoString name;
    1:     request->GetName(name);
    1: 
    1:     PRUint32 count = 0;
    1:     if (mLoadGroup)
    1:       mLoadGroup->GetActiveCount(&count);
    1: 
    1:     PR_LOG(gDocLoaderLog, PR_LOG_DEBUG,
    1:            ("DocLoader:%p: OnStartRequest[%p](%s) mIsLoadingDocument=%s, %u active URLs",
    1:             this, request, name.get(),
    1:             (mIsLoadingDocument ? "true" : "false"),
    1:             count));
    1:   }
    1: #endif /* PR_LOGGING */
    1:   PRBool bJustStartedLoading = PR_FALSE;
    1: 
    1:   nsLoadFlags loadFlags = 0;
    1:   request->GetLoadFlags(&loadFlags);
    1: 
    1:   if (!mIsLoadingDocument && (loadFlags & nsIChannel::LOAD_DOCUMENT_URI)) {
    1:       bJustStartedLoading = PR_TRUE;
    1:       mIsLoadingDocument = PR_TRUE;
    1:       ClearInternalProgress(); // only clear our progress if we are starting a new load....
    1:   }
    1: 
    1:   //
    1:   // Create a new nsRequestInfo for the request that is starting to
    1:   // load...
    1:   //
    1:   AddRequestInfo(request);
    1: 
27070:   //
27070:   // Only fire a doStartDocumentLoad(...) if the document loader
27070:   // has initiated a load...  Otherwise, this notification has
27070:   // resulted from a request being added to the load group.
27070:   //
27070:   if (mIsLoadingDocument) {
    1:     if (loadFlags & nsIChannel::LOAD_DOCUMENT_URI) {
    1:       //
    1:       // Make sure that the document channel is null at this point...
    1:       // (unless its been redirected)
    1:       //
    1:       NS_ASSERTION((loadFlags & nsIChannel::LOAD_REPLACE) ||
    1:                    !(mDocumentRequest.get()),
    1:                    "Overwriting an existing document channel!");
    1: 
    1:       // This request is associated with the entire document...
    1:       mDocumentRequest = request;
    1:       mLoadGroup->SetDefaultLoadRequest(request); 
    1: 
    1:       // Only fire the start document load notification for the first
    1:       // document URI...  Do not fire it again for redirections
    1:       //
    1:       if (bJustStartedLoading) {
    1:         // Update the progress status state
    1:         mProgressStateFlags = nsIWebProgressListener::STATE_START;
    1: 
    1:         // Fire the start document load notification
    1:         doStartDocumentLoad();
    1:         return NS_OK;
    1:       }
    1:     } 
    1:   }
    1: 
    1:   NS_ASSERTION(!mIsLoadingDocument || mDocumentRequest,
    1:                "mDocumentRequest MUST be set for the duration of a page load!");
    1: 
    1:   doStartURLLoad(request);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::OnStopRequest(nsIRequest *aRequest, 
    1:                            nsISupports *aCtxt,
    1:                            nsresult aStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1: #ifdef PR_LOGGING
    1:   if (PR_LOG_TEST(gDocLoaderLog, PR_LOG_DEBUG)) {
    1:     nsCAutoString name;
    1:     aRequest->GetName(name);
    1: 
    1:     PRUint32 count = 0;
    1:     if (mLoadGroup)
    1:       mLoadGroup->GetActiveCount(&count);
    1: 
    1:     PR_LOG(gDocLoaderLog, PR_LOG_DEBUG,
    1:            ("DocLoader:%p: OnStopRequest[%p](%s) status=%x mIsLoadingDocument=%s, %u active URLs",
    1:            this, aRequest, name.get(),
    1:            aStatus, (mIsLoadingDocument ? "true" : "false"),
    1:            count));
    1:   }
    1: #endif
    1: 
    1:   PRBool bFireTransferring = PR_FALSE;
    1: 
    1:   //
    1:   // Set the Maximum progress to the same value as the current progress.
    1:   // Since the URI has finished loading, all the data is there.  Also,
    1:   // this will allow a more accurate estimation of the max progress (in case
    1:   // the old value was unknown ie. -1)
    1:   //
    1:   nsRequestInfo *info = GetRequestInfo(aRequest);
    1:   if (info) {
77946:     info->mIsDone = PR_TRUE;
30795: 
64617:     PRInt64 oldMax = info->mMaxProgress;
    1: 
    1:     info->mMaxProgress = info->mCurrentProgress;
27070:     
    1:     //
    1:     // If a request whose content-length was previously unknown has just
    1:     // finished loading, then use this new data to try to calculate a
    1:     // mMaxSelfProgress...
    1:     //
64617:     if ((oldMax < PRInt64(0)) && (mMaxSelfProgress < PRInt64(0))) {
    1:       mMaxSelfProgress = CalculateMaxProgress();
    1:     }
    1: 
27070:     // As we know the total progress of this request now, save it to be part
27070:     // of CalculateMaxProgress() result. We need to remove the info from the
27070:     // hash, see bug 480713.
27070:     mCompletedTotalProgress += info->mMaxProgress;
27070:     
    1:     //
    1:     // Determine whether a STATE_TRANSFERRING notification should be
    1:     // 'synthesized'.
    1:     //
    1:     // If nsRequestInfo::mMaxProgress (as stored in oldMax) and
    1:     // nsRequestInfo::mCurrentProgress are both 0, then the
    1:     // STATE_TRANSFERRING notification has not been fired yet...
    1:     //
    1:     if ((oldMax == LL_ZERO) && (info->mCurrentProgress == LL_ZERO)) {
    1:       nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1: 
    1:       // Only fire a TRANSFERRING notification if the request is also a
    1:       // channel -- data transfer requires a nsIChannel!
    1:       //
    1:       if (channel) {
    1:         if (NS_SUCCEEDED(aStatus)) {
    1:           bFireTransferring = PR_TRUE;
    1:         }
    1:         //
    1:         // If the request failed (for any reason other than being
    1:         // redirected or retargeted), the TRANSFERRING notification can
    1:         // still be fired if a HTTP connection was established to a server.
    1:         //
    1:         else if (aStatus != NS_BINDING_REDIRECTED &&
    1:                  aStatus != NS_BINDING_RETARGETED) {
    1:           //
    1:           // Only if the load has been targeted (see bug 268483)...
    1:           //
    1:           PRUint32 lf;
    1:           channel->GetLoadFlags(&lf);
    1:           if (lf & nsIChannel::LOAD_TARGETED) {
    1:             nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aRequest));
    1:             if (httpChannel) {
    1:               PRUint32 responseCode;
    1:               rv = httpChannel->GetResponseStatus(&responseCode);
    1:               if (NS_SUCCEEDED(rv)) {
    1:                 //
    1:                 // A valid server status indicates that a connection was
    1:                 // established to the server... So, fire the notification
    1:                 // even though a failure occurred later...
    1:                 //
    1:                 bFireTransferring = PR_TRUE;
    1:               }
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (bFireTransferring) {
    1:     // Send a STATE_TRANSFERRING notification for the request.
    1:     PRInt32 flags;
    1:     
    1:     flags = nsIWebProgressListener::STATE_TRANSFERRING |
    1:             nsIWebProgressListener::STATE_IS_REQUEST;
    1:     //
    1:     // Move the WebProgress into the STATE_TRANSFERRING state if necessary...
    1:     //
    1:     if (mProgressStateFlags & nsIWebProgressListener::STATE_START) {
    1:       mProgressStateFlags = nsIWebProgressListener::STATE_TRANSFERRING;
    1: 
    1:       // Send STATE_TRANSFERRING for the document too...
    1:       flags |= nsIWebProgressListener::STATE_IS_DOCUMENT;
    1:     }
    1: 
    1:     FireOnStateChange(this, aRequest, flags, NS_OK);
    1:   }
    1: 
    1:   //
    1:   // Fire the OnStateChange(...) notification for stop request
    1:   //
    1:   doStopURLLoad(aRequest, aStatus);
    1:   
27070:   // Clear this request out of the hash to avoid bypass of FireOnStateChange
27070:   // when address of the request is reused.
27070:   RemoveRequestInfo(aRequest);
27070:   
27070:   //
27070:   // Only fire the DocLoaderIsEmpty(...) if the document loader has initiated a
27070:   // load.  This will handle removing the request from our hashtable as needed.
27070:   //
27070:   if (mIsLoadingDocument) {
25008:     DocLoaderIsEmpty(PR_TRUE);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult nsDocLoader::RemoveChildLoader(nsDocLoader* aChild)
    1: {
    1:   nsresult rv = mChildList.RemoveElement(aChild) ? NS_OK : NS_ERROR_FAILURE;
    1:   if (NS_SUCCEEDED(rv)) {
    1:     aChild->SetDocLoaderParent(nsnull);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsresult nsDocLoader::AddChildLoader(nsDocLoader* aChild)
    1: {
    1:   nsresult rv = mChildList.AppendElement(aChild) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1:   if (NS_SUCCEEDED(rv)) {
    1:     aChild->SetDocLoaderParent(this);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocLoader::GetDocumentChannel(nsIChannel ** aChannel)
    1: {
    1:   if (!mDocumentRequest) {
    1:     *aChannel = nsnull;
    1:     return NS_OK;
    1:   }
    1:   
    1:   return CallQueryInterface(mDocumentRequest, aChannel);
    1: }
    1: 
    1: 
25008: void nsDocLoader::DocLoaderIsEmpty(PRBool aFlushLayout)
    1: {
    1:   if (mIsLoadingDocument) {
    1:     /* In the unimagineably rude circumstance that onload event handlers
    1:        triggered by this function actually kill the window ... ok, it's
    1:        not unimagineable; it's happened ... this deathgrip keeps this object
    1:        alive long enough to survive this function call. */
    1:     nsCOMPtr<nsIDocumentLoader> kungFuDeathGrip(this);
    1: 
25008:     // Don't flush layout if we're still busy.
25008:     if (IsBusy()) {
25008:       return;
25008:     }
25008: 
25008:     NS_ASSERTION(!mIsFlushingLayout, "Someone screwed up");
25008: 
47906:     // The load group for this DocumentLoader is idle.  Flush if we need to.
40679:     if (aFlushLayout && !mDontFlushLayout) {
25008:       nsCOMPtr<nsIDOMDocument> domDoc = do_GetInterface(GetAsSupports(this));
25008:       nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
25008:       if (doc) {
47906:         // We start loads from style resolution, so we need to flush out style
47906:         // no matter what.  If we have user fonts, we also need to flush layout,
47906:         // since the reflow is what starts font loads.
47906:         mozFlushType flushType = Flush_Style;
47906:         nsIPresShell* shell = doc->GetShell();
47906:         if (shell) {
47906:           // Be safe in case this presshell is in teardown now
47906:           nsPresContext* presContext = shell->GetPresContext();
47906:           if (presContext && presContext->GetUserFontSet()) {
47906:             flushType = Flush_Layout;
47906:           }
47906:         }
40679:         mDontFlushLayout = mIsFlushingLayout = PR_TRUE;
47906:         doc->FlushPendingNotifications(flushType);
40679:         mDontFlushLayout = mIsFlushingLayout = PR_FALSE;
25008:       }
25008:     }
25008: 
25008:     // And now check whether we're really busy; that might have changed with
25008:     // the layout flush.
    1:     if (!IsBusy()) {
27070:       // Clear out our request info hash, now that our load really is done and
27070:       // we don't need it anymore to CalculateMaxProgress().
27070:       ClearInternalProgress();
27070: 
    1:       PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:              ("DocLoader:%p: Is now idle...\n", this));
    1: 
    1:       nsCOMPtr<nsIRequest> docRequest = mDocumentRequest;
    1: 
    1:       NS_ASSERTION(mDocumentRequest, "No Document Request!");
    1:       mDocumentRequest = 0;
    1:       mIsLoadingDocument = PR_FALSE;
    1: 
    1:       // Update the progress status state - the document is done
    1:       mProgressStateFlags = nsIWebProgressListener::STATE_STOP;
    1: 
    1: 
    1:       nsresult loadGroupStatus = NS_OK; 
    1:       mLoadGroup->GetStatus(&loadGroupStatus);
    1: 
    1:       // 
    1:       // New code to break the circular reference between 
    1:       // the load group and the docloader... 
    1:       // 
    1:       mLoadGroup->SetDefaultLoadRequest(nsnull); 
    1: 
    1:       // Take a ref to our parent now so that we can call DocLoaderIsEmpty() on
    1:       // it even if our onload handler removes us from the docloader tree.
    1:       nsRefPtr<nsDocLoader> parent = mParent;
    1: 
    1:       // Note that if calling ChildEnteringOnload() on the parent returns false
    1:       // then calling our onload handler is not safe.  That can only happen on
    1:       // OOM, so that's ok.
    1:       if (!parent || parent->ChildEnteringOnload(this)) {
    1:         // Do nothing with our state after firing the
    1:         // OnEndDocumentLoad(...). The document loader may be loading a *new*
    1:         // document - if LoadDocument() was called from a handler!
    1:         //
    1:         doStopDocumentLoad(docRequest, loadGroupStatus);
    1: 
    1:         if (parent) {
    1:           parent->ChildDoneWithOnload(this);
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void nsDocLoader::doStartDocumentLoad(void)
    1: {
    1: 
    1: #if defined(DEBUG)
    1:   nsCAutoString buffer;
    1: 
    1:   GetURIStringFromRequest(mDocumentRequest, buffer);
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: ++ Firing OnStateChange for start document load (...)."
    1:           "\tURI: %s \n",
    1:           this, buffer.get()));
    1: #endif /* DEBUG */
    1: 
    1:   // Fire an OnStatus(...) notification STATE_START.  This indicates
    1:   // that the document represented by mDocumentRequest has started to
    1:   // load...
    1:   FireOnStateChange(this,
    1:                     mDocumentRequest,
    1:                     nsIWebProgressListener::STATE_START |
    1:                     nsIWebProgressListener::STATE_IS_DOCUMENT |
    1:                     nsIWebProgressListener::STATE_IS_REQUEST |
    1:                     nsIWebProgressListener::STATE_IS_WINDOW |
    1:                     nsIWebProgressListener::STATE_IS_NETWORK,
    1:                     NS_OK);
    1: }
    1: 
    1: void nsDocLoader::doStartURLLoad(nsIRequest *request)
    1: {
    1: #if defined(DEBUG)
    1:   nsCAutoString buffer;
    1: 
    1:   GetURIStringFromRequest(request, buffer);
    1:     PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:           ("DocLoader:%p: ++ Firing OnStateChange start url load (...)."
    1:            "\tURI: %s\n",
    1:             this, buffer.get()));
    1: #endif /* DEBUG */
    1: 
    1:   FireOnStateChange(this,
    1:                     request,
    1:                     nsIWebProgressListener::STATE_START |
    1:                     nsIWebProgressListener::STATE_IS_REQUEST,
    1:                     NS_OK);
    1: }
    1: 
77946: // PLDHashTable enumeration callback that finds a RequestInfo that's not done
77946: // yet.
77946: static PLDHashOperator
77946: FindUnfinishedRequestCallback(PLDHashTable *table, PLDHashEntryHdr *hdr,
77946:                               PRUint32 number, void *arg)
77946: {
77946:   nsRequestInfo* info = static_cast<nsRequestInfo *>(hdr);
77946:   nsRequestInfo** retval = static_cast<nsRequestInfo**>(arg);
77946: 
77946:   if (!info->mIsDone && !info->mLastStatus.IsEmpty()) {
77946:     *retval = info;
77946:     return PL_DHASH_STOP;
77946:   }
77946: 
77946:   return PL_DHASH_NEXT;
77946: }
77946: 
77946: 
    1: void nsDocLoader::doStopURLLoad(nsIRequest *request, nsresult aStatus)
    1: {
    1: #if defined(DEBUG)
    1:   nsCAutoString buffer;
    1: 
    1:   GetURIStringFromRequest(request, buffer);
    1:     PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:           ("DocLoader:%p: ++ Firing OnStateChange for end url load (...)."
    1:            "\tURI: %s status=%x\n",
    1:             this, buffer.get(), aStatus));
    1: #endif /* DEBUG */
    1: 
    1:   FireOnStateChange(this,
    1:                     request,
    1:                     nsIWebProgressListener::STATE_STOP |
    1:                     nsIWebProgressListener::STATE_IS_REQUEST,
    1:                     aStatus);
30795: 
77946:   // Fire a status change message for a random unfinished request to make sure
77946:   // that the displayed status is not outdated.
77946:   nsRequestInfo* unfinishedRequest = nsnull;
77946:   PL_DHashTableEnumerate(&mRequestInfoHash, FindUnfinishedRequestCallback,
77946:                          &unfinishedRequest);
77946:   if (unfinishedRequest) {
77946:     FireOnStatusChange(this, unfinishedRequest->Request(),
77946:                        unfinishedRequest->mLastStatusCode,
77946:                        unfinishedRequest->mLastStatus.get());
30795:   }
    1: }
    1: 
    1: void nsDocLoader::doStopDocumentLoad(nsIRequest *request,
    1:                                          nsresult aStatus)
    1: {
    1: #if defined(DEBUG)
    1:   nsCAutoString buffer;
    1: 
    1:   GetURIStringFromRequest(request, buffer);
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: ++ Firing OnStateChange for end document load (...)."
    1:          "\tURI: %s Status=%x\n",
    1:           this, buffer.get(), aStatus));
    1: #endif /* DEBUG */
    1: 
    1:   //
    1:   // Fire an OnStateChange(...) notification indicating the the
    1:   // current document has finished loading...
    1:   //
    1:   FireOnStateChange(this,
    1:                     request,
    1:                     nsIWebProgressListener::STATE_STOP |
    1:                     nsIWebProgressListener::STATE_IS_DOCUMENT,
    1:                     aStatus);
    1: 
    1:   //
    1:   // Fire a final OnStateChange(...) notification indicating the the
    1:   // current document has finished loading...
    1:   //
    1:   FireOnStateChange(this,
    1:                     request,
    1:                     nsIWebProgressListener::STATE_STOP |
    1:                     nsIWebProgressListener::STATE_IS_WINDOW |
    1:                     nsIWebProgressListener::STATE_IS_NETWORK,
    1:                     aStatus);
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////////
    1: // The following section contains support for nsIWebProgress and related stuff
    1: ////////////////////////////////////////////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::AddProgressListener(nsIWebProgressListener *aListener,
    1:                                      PRUint32 aNotifyMask)
    1: {
29263:   nsresult rv;
29263: 
29263:   nsListenerInfo* info = GetListenerInfo(aListener);
29263:   if (info) {
    1:     // The listener is already registered!
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsWeakPtr listener = do_GetWeakReference(aListener);
    1:   if (!listener) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
29263:   info = new nsListenerInfo(listener, aNotifyMask);
29263:   if (!info) {
29263:     return NS_ERROR_OUT_OF_MEMORY;
29263:   }
29263: 
29263:   rv = mListenerInfoList.AppendElement(info) ? NS_OK : NS_ERROR_FAILURE;
29263:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::RemoveProgressListener(nsIWebProgressListener *aListener)
    1: {
29263:   nsresult rv;
29263: 
29263:   nsListenerInfo* info = GetListenerInfo(aListener);
29263:   if (info) {
29263:     rv = mListenerInfoList.RemoveElement(info) ? NS_OK : NS_ERROR_FAILURE;
29263:     delete info;
29263:   } else {
29263:     // The listener is not registered!
29263:     rv = NS_ERROR_FAILURE;
29263:   }
29263:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::GetDOMWindow(nsIDOMWindow **aResult)
    1: {
    1:   return CallGetInterface(this, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocLoader::GetIsLoadingDocument(PRBool *aIsLoadingDocument)
    1: {
    1:   *aIsLoadingDocument = mIsLoadingDocument;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRInt64 nsDocLoader::GetMaxTotalProgress()
    1: {
64617:   PRInt64 newMaxTotal = 0;
    1: 
29263:   PRInt32 count = mChildList.Count();
    1:   nsCOMPtr<nsIWebProgress> webProgress;
29263:   for (PRInt32 i=0; i < count; i++) 
    1:   {
64617:     PRInt64 individualProgress = 0;
29263:     nsIDocumentLoader* docloader = ChildAt(i);
    1:     if (docloader)
    1:     {
    1:       // Cast is safe since all children are nsDocLoader too
    1:       individualProgress = ((nsDocLoader *) docloader)->GetMaxTotalProgress();
    1:     }
64617:     if (individualProgress < PRInt64(0)) // if one of the elements doesn't know it's size
    1:                                          // then none of them do
    1:     {
64617:        newMaxTotal = PRInt64(-1);
    1:        break;
    1:     }
    1:     else
    1:      newMaxTotal += individualProgress;
    1:   }
    1: 
64617:   PRInt64 progress = -1;
64617:   if (mMaxSelfProgress >= PRInt64(0) && newMaxTotal >= PRInt64(0))
    1:     progress = newMaxTotal + mMaxSelfProgress;
    1:   
    1:   return progress;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////////
    1: // The following section contains support for nsIProgressEventSink which is used to 
    1: // pass progress and status between the actual request and the doc loader. The doc loader
    1: // then turns around and makes the right web progress calls based on this information.
    1: ////////////////////////////////////////////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP nsDocLoader::OnProgress(nsIRequest *aRequest, nsISupports* ctxt, 
    1:                                       PRUint64 aProgress, PRUint64 aProgressMax)
    1: {
    1:   nsRequestInfo *info;
64617:   PRInt64 progressDelta = 0;
    1: 
    1:   //
    1:   // Update the RequestInfo entry with the new progress data
    1:   //
    1:   info = GetRequestInfo(aRequest);
    1:   if (info) {
    1:     // suppress sending STATE_TRANSFERRING if this is upload progress (see bug 240053)
64617:     if (!info->mUploading && (PRInt64(0) == info->mCurrentProgress) && (PRInt64(0) == info->mMaxProgress)) {
    1:       //
    1:       // If we receive an OnProgress event from a toplevel channel that the URI Loader
    1:       // has not yet targeted, then we must suppress the event.  This is necessary to
    1:       // ensure that webprogresslisteners do not get confused when the channel is
    1:       // finally targeted.  See bug 257308.
    1:       //
    1:       nsLoadFlags lf = 0;
    1:       aRequest->GetLoadFlags(&lf);
    1:       if ((lf & nsIChannel::LOAD_DOCUMENT_URI) && !(lf & nsIChannel::LOAD_TARGETED)) {
    1:         PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:             ("DocLoader:%p Ignoring OnProgress while load is not targeted\n", this));
    1:         return NS_OK;
    1:       }
    1: 
    1:       //
    1:       // This is the first progress notification for the entry.  If
    1:       // (aMaxProgress > 0) then the content-length of the data is known,
    1:       // so update mMaxSelfProgress...  Otherwise, set it to -1 to indicate
    1:       // that the content-length is no longer known.
    1:       //
31382:       if (PRUint64(aProgressMax) != LL_MAXUINT) {
    1:         mMaxSelfProgress  += PRInt64(aProgressMax);
    1:         info->mMaxProgress = PRInt64(aProgressMax);
    1:       } else {
64617:         mMaxSelfProgress   =  PRInt64(-1);
64617:         info->mMaxProgress =  PRInt64(-1);
    1:       }
    1: 
    1:       // Send a STATE_TRANSFERRING notification for the request.
    1:       PRInt32 flags;
    1:     
    1:       flags = nsIWebProgressListener::STATE_TRANSFERRING | 
    1:               nsIWebProgressListener::STATE_IS_REQUEST;
    1:       //
    1:       // Move the WebProgress into the STATE_TRANSFERRING state if necessary...
    1:       //
    1:       if (mProgressStateFlags & nsIWebProgressListener::STATE_START) {
    1:         mProgressStateFlags = nsIWebProgressListener::STATE_TRANSFERRING;
    1: 
    1:         // Send STATE_TRANSFERRING for the document too...
    1:         flags |= nsIWebProgressListener::STATE_IS_DOCUMENT;
    1:       }
    1: 
    1:       FireOnStateChange(this, aRequest, flags, NS_OK);
    1:     }
    1: 
    1:     // Update the current progress count...
64617:     progressDelta = PRInt64(aProgress) - info->mCurrentProgress;
    1:     mCurrentSelfProgress += progressDelta;
    1: 
    1:     info->mCurrentProgress = PRInt64(aProgress);
    1:   }
    1:   //
    1:   // The request is not part of the load group, so ignore its progress
    1:   // information...
    1:   //
    1:   else {
    1: #if defined(DEBUG)
    1:     nsCAutoString buffer;
    1: 
    1:     GetURIStringFromRequest(aRequest, buffer);
    1:     PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:            ("DocLoader:%p OOPS - No Request Info for: %s\n",
    1:             this, buffer.get()));
    1: #endif /* DEBUG */
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   //
    1:   // Fire progress notifications out to any registered nsIWebProgressListeners
    1:   //
    1:   FireOnProgressChange(this, aRequest, aProgress, aProgressMax, progressDelta,
    1:                        mCurrentTotalProgress, mMaxTotalProgress);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocLoader::OnStatus(nsIRequest* aRequest, nsISupports* ctxt, 
    1:                                         nsresult aStatus, const PRUnichar* aStatusArg)
    1: {
    1:   //
    1:   // Fire progress notifications out to any registered nsIWebProgressListeners
    1:   //
    1:   if (aStatus) {
    1:     // Remember the current status for this request
    1:     nsRequestInfo *info;
    1:     info = GetRequestInfo(aRequest);
    1:     if (info) {
    1:       PRBool uploading = (aStatus == nsITransport::STATUS_WRITING ||
    1:                           aStatus == nsISocketTransport::STATUS_SENDING_TO);
    1:       // If switching from uploading to downloading (or vice versa), then we
    1:       // need to reset our progress counts.  This is designed with HTTP form
    1:       // submission in mind, where an upload is performed followed by download
    1:       // of possibly several documents.
    1:       if (info->mUploading != uploading) {
    1:         mCurrentSelfProgress  = mMaxSelfProgress  = LL_ZERO;
    1:         mCurrentTotalProgress = mMaxTotalProgress = LL_ZERO;
27070:         mCompletedTotalProgress = LL_ZERO;
    1:         info->mUploading = uploading;
    1:         info->mCurrentProgress = LL_ZERO;
    1:         info->mMaxProgress = LL_ZERO;
    1:       }
    1:     }
    1: 
42314:     nsCOMPtr<nsIStringBundleService> sbs =
42314:       mozilla::services::GetStringBundleService();
42314:     if (!sbs)
42314:       return NS_ERROR_FAILURE;
    1:     nsXPIDLString msg;
42314:     nsresult rv = sbs->FormatStatusMessage(aStatus, aStatusArg,
42314:                                            getter_Copies(msg));
42314:     if (NS_FAILED(rv))
42314:       return rv;
30795: 
30795:     // Keep around the message. In case a request finishes, we need to make sure
30795:     // to send the status message of another request to our user to that we
30795:     // don't display, for example, "Transferring" messages for requests that are
30795:     // already done.
30795:     if (info) {
77946:       info->mLastStatus = msg;
77946:       info->mLastStatusCode = aStatus;
30795:     }
    1:     FireOnStatusChange(this, aRequest, aStatus, msg);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: void nsDocLoader::ClearInternalProgress()
    1: {
    1:   ClearRequestInfoHash();
    1: 
    1:   mCurrentSelfProgress  = mMaxSelfProgress  = LL_ZERO;
    1:   mCurrentTotalProgress = mMaxTotalProgress = LL_ZERO;
27070:   mCompletedTotalProgress = LL_ZERO;
    1: 
    1:   mProgressStateFlags = nsIWebProgressListener::STATE_STOP;
    1: }
    1: 
    1: 
    1: void nsDocLoader::FireOnProgressChange(nsDocLoader *aLoadInitiator,
    1:                                        nsIRequest *request,
    1:                                        PRInt64 aProgress,
    1:                                        PRInt64 aProgressMax,
    1:                                        PRInt64 aProgressDelta,
    1:                                        PRInt64 aTotalProgress,
    1:                                        PRInt64 aMaxTotalProgress)
    1: {
    1:   if (mIsLoadingDocument) {
    1:     mCurrentTotalProgress += aProgressDelta;
    1:     mMaxTotalProgress = GetMaxTotalProgress();
    1: 
    1:     aTotalProgress    = mCurrentTotalProgress;
    1:     aMaxTotalProgress = mMaxTotalProgress;
    1:   }
    1: 
    1: #if defined(DEBUG)
    1:   nsCAutoString buffer;
    1: 
    1:   GetURIStringFromRequest(request, buffer);
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: Progress (%s): curSelf: %d maxSelf: %d curTotal: %d maxTotal %d\n",
    1:           this, buffer.get(), aProgress, aProgressMax, aTotalProgress, aMaxTotalProgress));
    1: #endif /* DEBUG */
    1: 
29263:   /*
29263:    * First notify any listeners of the new progress info...
29263:    *
29263:    * Operate the elements from back to front so that if items get
29263:    * get removed from the list it won't affect our iteration
29263:    */
29262:   nsCOMPtr<nsIWebProgressListener> listener;
29263:   PRInt32 count = mListenerInfoList.Count();
29262: 
29263:   while (--count >= 0) {
29263:     nsListenerInfo *info;
29263: 
29263:     info = static_cast<nsListenerInfo*>(mListenerInfoList.SafeElementAt(count));
29263:     if (!info || !(info->mNotifyMask & nsIWebProgress::NOTIFY_PROGRESS)) {
29262:       continue;
29262:     }
29262: 
29263:     listener = do_QueryReferent(info->mWeakListener);
29262:     if (!listener) {
29262:       // the listener went away. gracefully pull it out of the list.
29263:       mListenerInfoList.RemoveElementAt(count);
29263:       delete info;
29262:       continue;
29262:     }
29262: 
    1:     // XXX truncates 64-bit to 32-bit
    1:     listener->OnProgressChange(aLoadInitiator,request,
    1:                                PRInt32(aProgress), PRInt32(aProgressMax),
    1:                                PRInt32(aTotalProgress), PRInt32(aMaxTotalProgress));
29262:   }
29263: 
29262:   mListenerInfoList.Compact();
    1: 
    1:   // Pass the notification up to the parent...
    1:   if (mParent) {
    1:     mParent->FireOnProgressChange(aLoadInitiator, request,
    1:                                   aProgress, aProgressMax,
    1:                                   aProgressDelta,
    1:                                   aTotalProgress, aMaxTotalProgress);
    1:   }
    1: }
    1: 
    1: 
    1: void nsDocLoader::FireOnStateChange(nsIWebProgress *aProgress,
    1:                                     nsIRequest *aRequest,
    1:                                     PRInt32 aStateFlags,
    1:                                     nsresult aStatus)
    1: {
    1:   //
    1:   // Remove the STATE_IS_NETWORK bit if necessary.
    1:   //
    1:   // The rule is to remove this bit, if the notification has been passed
    1:   // up from a child WebProgress, and the current WebProgress is already
    1:   // active...
    1:   //
    1:   if (mIsLoadingDocument &&
    1:       (aStateFlags & nsIWebProgressListener::STATE_IS_NETWORK) && 
    1:       (this != aProgress)) {
    1:     aStateFlags &= ~nsIWebProgressListener::STATE_IS_NETWORK;
    1:   }
    1: 
    1:   // Add the STATE_RESTORING bit if necessary.
    1:   if (mIsRestoringDocument)
    1:     aStateFlags |= nsIWebProgressListener::STATE_RESTORING;
    1: 
    1: #if defined(DEBUG)
    1:   nsCAutoString buffer;
    1: 
    1:   GetURIStringFromRequest(aRequest, buffer);
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: Status (%s): code: %x\n",
    1:          this, buffer.get(), aStateFlags));
    1: #endif /* DEBUG */
    1: 
    1:   NS_ASSERTION(aRequest, "Firing OnStateChange(...) notification with a NULL request!");
    1: 
29263:   /*                                                                           
29263:    * First notify any listeners of the new state info...
29263:    *
29263:    * Operate the elements from back to front so that if items get
29263:    * get removed from the list it won't affect our iteration
29263:    */
29262:   nsCOMPtr<nsIWebProgressListener> listener;
29263:   PRInt32 count = mListenerInfoList.Count();
42891:   PRInt32 notifyMask = (aStateFlags >> 16) & nsIWebProgress::NOTIFY_STATE_ALL;
29262: 
29263:   while (--count >= 0) {
29263:     nsListenerInfo *info;
29263: 
29263:     info = static_cast<nsListenerInfo*>(mListenerInfoList.SafeElementAt(count));
42891:     if (!info || !(info->mNotifyMask & notifyMask)) {
29262:       continue;
29262:     }
29262: 
29263:     listener = do_QueryReferent(info->mWeakListener);
29262:     if (!listener) {
29262:       // the listener went away. gracefully pull it out of the list.
29263:       mListenerInfoList.RemoveElementAt(count);
29263:       delete info;
29262:       continue;
29262:     }
29262: 
    1:     listener->OnStateChange(aProgress, aRequest, aStateFlags, aStatus);
29262:   }
29263: 
29262:   mListenerInfoList.Compact();
    1: 
    1:   // Pass the notification up to the parent...
    1:   if (mParent) {
    1:     mParent->FireOnStateChange(aProgress, aRequest, aStateFlags, aStatus);
    1:   }
    1: }
    1: 
    1: 
    1: 
    1: void
    1: nsDocLoader::FireOnLocationChange(nsIWebProgress* aWebProgress,
    1:                                   nsIRequest* aRequest,
71723:                                   nsIURI *aUri)
    1: {
29263:   /*                                                                           
29263:    * First notify any listeners of the new state info...
29263:    *
29263:    * Operate the elements from back to front so that if items get
29263:    * get removed from the list it won't affect our iteration
29263:    */
29262:   nsCOMPtr<nsIWebProgressListener> listener;
29263:   PRInt32 count = mListenerInfoList.Count();
29262: 
29263:   while (--count >= 0) {
29263:     nsListenerInfo *info;
29263: 
29263:     info = static_cast<nsListenerInfo*>(mListenerInfoList.SafeElementAt(count));
29263:     if (!info || !(info->mNotifyMask & nsIWebProgress::NOTIFY_LOCATION)) {
29262:       continue;
29262:     }
29262: 
29263:     listener = do_QueryReferent(info->mWeakListener);
29262:     if (!listener) {
29262:       // the listener went away. gracefully pull it out of the list.
29263:       mListenerInfoList.RemoveElementAt(count);
29263:       delete info;
29262:       continue;
29262:     }
29262: 
    1:     listener->OnLocationChange(aWebProgress, aRequest, aUri);
29262:   }
29263: 
29262:   mListenerInfoList.Compact();
    1: 
    1:   // Pass the notification up to the parent...
    1:   if (mParent) {
71723:     mParent->FireOnLocationChange(aWebProgress, aRequest, aUri);
    1:   }
    1: }
    1: 
    1: void
    1: nsDocLoader::FireOnStatusChange(nsIWebProgress* aWebProgress,
    1:                                 nsIRequest* aRequest,
    1:                                 nsresult aStatus,
    1:                                 const PRUnichar* aMessage)
    1: {
29263:   /*                                                                           
29263:    * First notify any listeners of the new state info...
29263:    *
29263:    * Operate the elements from back to front so that if items get
29263:    * get removed from the list it won't affect our iteration
29263:    */
29262:   nsCOMPtr<nsIWebProgressListener> listener;
29263:   PRInt32 count = mListenerInfoList.Count();
29262: 
29263:   while (--count >= 0) {
29263:     nsListenerInfo *info;
29263: 
29263:     info = static_cast<nsListenerInfo*>(mListenerInfoList.SafeElementAt(count));
29263:     if (!info || !(info->mNotifyMask & nsIWebProgress::NOTIFY_STATUS)) {
29262:       continue;
29262:     }
29262: 
29263:     listener = do_QueryReferent(info->mWeakListener);
29262:     if (!listener) {
29262:       // the listener went away. gracefully pull it out of the list.
29263:       mListenerInfoList.RemoveElementAt(count);
29263:       delete info;
29262:       continue;
29262:     }
29262: 
    1:     listener->OnStatusChange(aWebProgress, aRequest, aStatus, aMessage);
29262:   }
29262:   mListenerInfoList.Compact();
    1:   
    1:   // Pass the notification up to the parent...
    1:   if (mParent) {
    1:     mParent->FireOnStatusChange(aWebProgress, aRequest, aStatus, aMessage);
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsDocLoader::RefreshAttempted(nsIWebProgress* aWebProgress,
    1:                               nsIURI *aURI,
    1:                               PRInt32 aDelay,
    1:                               PRBool aSameURI)
    1: {
    1:   /*
    1:    * Returns true if the refresh may proceed,
    1:    * false if the refresh should be blocked.
    1:    *
    1:    * First notify any listeners of the refresh attempt...
29263:    *
29263:    * Iterate the elements from back to front so that if items
29263:    * get removed from the list it won't affect our iteration
    1:    */
    1:   PRBool allowRefresh = PR_TRUE;
29263:   PRInt32 count = mListenerInfoList.Count();
    1: 
29263:   while (--count >= 0) {
29263:     nsListenerInfo *info;
29263: 
29263:     info = static_cast<nsListenerInfo*>(mListenerInfoList.SafeElementAt(count));
29263:     if (!info || !(info->mNotifyMask & nsIWebProgress::NOTIFY_REFRESH)) {
29262:       continue;
29262:     }
29262: 
29262:     nsCOMPtr<nsIWebProgressListener> listener =
29263:       do_QueryReferent(info->mWeakListener);
29262:     if (!listener) {
29262:       // the listener went away. gracefully pull it out of the list.
29263:       mListenerInfoList.RemoveElementAt(count);
29263:       delete info;
29262:       continue;
29262:     }
29262: 
    1:     nsCOMPtr<nsIWebProgressListener2> listener2 =
29263:       do_QueryReferent(info->mWeakListener);
    1:     if (!listener2)
    1:       continue;
    1: 
    1:     PRBool listenerAllowedRefresh;
    1:     nsresult listenerRV = listener2->OnRefreshAttempted(
    1:         aWebProgress, aURI, aDelay, aSameURI, &listenerAllowedRefresh);
    1:     if (NS_FAILED(listenerRV))
    1:       continue;
    1: 
    1:     allowRefresh = allowRefresh && listenerAllowedRefresh;
29262:   }
29263: 
29262:   mListenerInfoList.Compact();
    1: 
    1:   // Pass the notification up to the parent...
    1:   if (mParent) {
    1:     allowRefresh = allowRefresh &&
    1:       mParent->RefreshAttempted(aWebProgress, aURI, aDelay, aSameURI);
    1:   }
    1: 
    1:   return allowRefresh;
    1: }
    1: 
29263: nsListenerInfo * 
29263: nsDocLoader::GetListenerInfo(nsIWebProgressListener *aListener)
29263: {
29263:   PRInt32 i, count;
29263:   nsListenerInfo *info;
29263: 
29263:   nsCOMPtr<nsISupports> listener1 = do_QueryInterface(aListener);
29263:   count = mListenerInfoList.Count();
29263:   for (i=0; i<count; i++) {
29263:     info = static_cast<nsListenerInfo*>(mListenerInfoList.SafeElementAt(i));
29263: 
29263:     NS_ASSERTION(info, "There should NEVER be a null listener in the list");
29263:     if (info) {
29263:       nsCOMPtr<nsISupports> listener2 = do_QueryReferent(info->mWeakListener);
29263:       if (listener1 == listener2)
29263:         return info;
29263:     }
29263:   }
29263:   return nsnull;
29263: }
29263: 
    1: nsresult nsDocLoader::AddRequestInfo(nsIRequest *aRequest)
    1: {
    1:   if (!PL_DHashTableOperate(&mRequestInfoHash, aRequest, PL_DHASH_ADD)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
27070: void nsDocLoader::RemoveRequestInfo(nsIRequest *aRequest)
27070: {
27070:   PL_DHashTableOperate(&mRequestInfoHash, aRequest, PL_DHASH_REMOVE);
27070: }
27070: 
    1: nsRequestInfo * nsDocLoader::GetRequestInfo(nsIRequest *aRequest)
    1: {
    1:   nsRequestInfo *info =
 3233:     static_cast<nsRequestInfo *>
 3233:                (PL_DHashTableOperate(&mRequestInfoHash, aRequest,
    1:                                         PL_DHASH_LOOKUP));
    1: 
    1:   if (PL_DHASH_ENTRY_IS_FREE(info)) {
    1:     // Nothing found in the hash, return null.
    1: 
    1:     return nsnull;
    1:   }
    1: 
    1:   // Return what we found in the hash...
    1: 
    1:   return info;
    1: }
    1: 
    1: // PLDHashTable enumeration callback that just removes every entry
    1: // from the hash.
20261: static PLDHashOperator
    1: RemoveInfoCallback(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
    1:                    void *arg)
    1: {
    1:   return PL_DHASH_REMOVE;
    1: }
    1: 
    1: void nsDocLoader::ClearRequestInfoHash(void)
    1: {
    1:   if (!mRequestInfoHash.ops || !mRequestInfoHash.entryCount) {
    1:     // No hash, or the hash is empty, nothing to do here then...
    1: 
    1:     return;
    1:   }
    1: 
    1:   PL_DHashTableEnumerate(&mRequestInfoHash, RemoveInfoCallback, nsnull);
    1: }
    1: 
    1: // PLDHashTable enumeration callback that calculates the max progress.
20261: static PLDHashOperator
    1: CalcMaxProgressCallback(PLDHashTable *table, PLDHashEntryHdr *hdr,
    1:                         PRUint32 number, void *arg)
    1: {
 3233:   const nsRequestInfo *info = static_cast<const nsRequestInfo *>(hdr);
64617:   PRInt64 *max = static_cast<PRInt64 *>(arg);
    1: 
    1:   if (info->mMaxProgress < info->mCurrentProgress) {
64617:     *max = PRInt64(-1);
    1: 
    1:     return PL_DHASH_STOP;
    1:   }
    1: 
    1:   *max += info->mMaxProgress;
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: PRInt64 nsDocLoader::CalculateMaxProgress()
    1: {
64617:   PRInt64 max = mCompletedTotalProgress;
    1:   PL_DHashTableEnumerate(&mRequestInfoHash, CalcMaxProgressCallback, &max);
    1:   return max;
    1: }
    1: 
48889: NS_IMETHODIMP nsDocLoader::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
    1:                                                   nsIChannel *aNewChannel,
48889:                                                   PRUint32 aFlags,
48889:                                                   nsIAsyncVerifyRedirectCallback *cb)
    1: {
    1:   if (aOldChannel)
    1:   {
    1:     nsLoadFlags loadFlags = 0;
    1:     PRInt32 stateFlags = nsIWebProgressListener::STATE_REDIRECTING |
    1:                          nsIWebProgressListener::STATE_IS_REQUEST;
    1: 
    1:     aOldChannel->GetLoadFlags(&loadFlags);
    1:     // If the document channel is being redirected, then indicate that the
    1:     // document is being redirected in the notification...
    1:     if (loadFlags & nsIChannel::LOAD_DOCUMENT_URI)
    1:     {
    1:       stateFlags |= nsIWebProgressListener::STATE_IS_DOCUMENT;
    1: 
    1: #if defined(DEBUG)
    1:       nsCOMPtr<nsIRequest> request(do_QueryInterface(aOldChannel));
    1:       NS_ASSERTION(request == mDocumentRequest, "Wrong Document Channel");
    1: #endif /* DEBUG */
    1:     }
    1: 
54823:     OnRedirectStateChange(aOldChannel, aNewChannel, aFlags, stateFlags);
    1:     FireOnStateChange(this, aOldChannel, stateFlags, NS_OK);
    1:   }
    1: 
48889:   cb->OnRedirectVerifyCallback(NS_OK);
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Implementation of nsISecurityEventSink method...
    1:  */
    1: 
    1: NS_IMETHODIMP nsDocLoader::OnSecurityChange(nsISupports * aContext,
    1:                                             PRUint32 aState)
    1: {
    1:   //
    1:   // Fire progress notifications out to any registered nsIWebProgressListeners.  
    1:   //
    1:   
    1:   nsCOMPtr<nsIRequest> request = do_QueryInterface(aContext);
 3233:   nsIWebProgress* webProgress = static_cast<nsIWebProgress*>(this);
    1: 
29263:   /*                                                                           
29263:    * First notify any listeners of the new state info...
29263:    *
29263:    * Operate the elements from back to front so that if items get
29263:    * get removed from the list it won't affect our iteration
29263:    */
29262:   nsCOMPtr<nsIWebProgressListener> listener;
29263:   PRInt32 count = mListenerInfoList.Count();
29262: 
29263:   while (--count >= 0) {
29263:     nsListenerInfo *info;
29263: 
29263:     info = static_cast<nsListenerInfo*>(mListenerInfoList.SafeElementAt(count));
29263:     if (!info || !(info->mNotifyMask & nsIWebProgress::NOTIFY_SECURITY)) {
29262:       continue;
29262:     }
29262: 
29263:     listener = do_QueryReferent(info->mWeakListener);
29262:     if (!listener) {
29262:       // the listener went away. gracefully pull it out of the list.
29263:       mListenerInfoList.RemoveElementAt(count);
29263:       delete info;
29262:       continue;
29262:     }
29262: 
    1:     listener->OnSecurityChange(webProgress, request, aState);
29262:   }
29263: 
29262:   mListenerInfoList.Compact();
    1: 
    1:   // Pass the notification up to the parent...
    1:   if (mParent) {
    1:     mParent->OnSecurityChange(aContext, aState);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /*
    1:  * Implementation of nsISupportsPriority methods...
    1:  *
    1:  * The priority of the DocLoader _is_ the priority of its LoadGroup.
    1:  *
    1:  * XXX(darin): Once we start storing loadgroups in loadgroups, this code will
    1:  * go away. 
    1:  */
    1: 
    1: NS_IMETHODIMP nsDocLoader::GetPriority(PRInt32 *aPriority)
    1: {
    1:   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(mLoadGroup);
    1:   if (p)
    1:     return p->GetPriority(aPriority);
    1: 
    1:   *aPriority = 0;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocLoader::SetPriority(PRInt32 aPriority)
    1: {
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: SetPriority(%d) called\n", this, aPriority));
    1: 
    1:   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(mLoadGroup);
    1:   if (p)
    1:     p->SetPriority(aPriority);
    1: 
29263:   PRInt32 count = mChildList.Count();
    1: 
    1:   nsDocLoader *loader;
29263:   for (PRInt32 i=0; i < count; i++) {
29263:     loader = static_cast<nsDocLoader*>(ChildAt(i));
    1:     if (loader) {
    1:       loader->SetPriority(aPriority);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocLoader::AdjustPriority(PRInt32 aDelta)
    1: {
    1:   PR_LOG(gDocLoaderLog, PR_LOG_DEBUG, 
    1:          ("DocLoader:%p: AdjustPriority(%d) called\n", this, aDelta));
    1: 
    1:   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(mLoadGroup);
    1:   if (p)
    1:     p->AdjustPriority(aDelta);
    1: 
29263:   PRInt32 count = mChildList.Count();
    1: 
    1:   nsDocLoader *loader;
29263:   for (PRInt32 i=0; i < count; i++) {
29263:     loader = static_cast<nsDocLoader*>(ChildAt(i));
    1:     if (loader) {
    1:       loader->AdjustPriority(aDelta);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: 
    1: #if 0
    1: void nsDocLoader::DumpChannelInfo()
    1: {
    1:   nsChannelInfo *info;
    1:   PRInt32 i, count;
    1:   PRInt32 current=0, max=0;
    1: 
    1:   
    1:   printf("==== DocLoader=%x\n", this);
    1: 
    1:   count = mChannelInfoList.Count();
    1:   for(i=0; i<count; i++) {
    1:     info = (nsChannelInfo *)mChannelInfoList.ElementAt(i);
    1: 
    1: #if defined(DEBUG)
    1:     nsCAutoString buffer;
    1:     nsresult rv = NS_OK;
    1:     if (info->mURI) {
    1:       rv = info->mURI->GetSpec(buffer);
    1:     }
    1: 
    1:     printf("  [%d] current=%d  max=%d [%s]\n", i,
    1:            info->mCurrentProgress, 
    1:            info->mMaxProgress, buffer.get());
    1: #endif /* DEBUG */
    1: 
    1:     current += info->mCurrentProgress;
    1:     if (max >= 0) {
    1:       if (info->mMaxProgress < info->mCurrentProgress) {
    1:         max = -1;
    1:       } else {
    1:         max += info->mMaxProgress;
    1:       }
    1:     }
    1:   }
    1: 
    1:   printf("\nCurrent=%d   Total=%d\n====\n", current, max);
    1: }
    1: #endif /* 0 */
