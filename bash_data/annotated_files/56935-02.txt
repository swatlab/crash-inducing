    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set tw=80 expandtab softtabstop=2 ts=2 sw=2: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef nsGenericHTMLElement_h___
    1: #define nsGenericHTMLElement_h___
    1: 
10073: #include "nsMappedAttributeElement.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsINameSpaceManager.h"  // for kNameSpaceID_None
    1: #include "nsIFormControl.h"
    1: #include "nsIDOMNSHTMLFrameElement.h"
    1: #include "nsFrameLoader.h"
 2896: #include "nsGkAtoms.h"
50721: #include "nsContentCreatorFunctions.h"
    1: 
    1: class nsIDOMAttr;
    1: class nsIDOMEventListener;
    1: class nsIDOMNodeList;
    1: class nsIFrame;
    1: class nsIStyleRule;
    1: class nsChildContentList;
    1: class nsDOMCSSDeclaration;
    1: class nsIDOMCSSStyleDeclaration;
    1: class nsIURI;
    1: class nsIFormControlFrame;
    1: class nsIForm;
    1: class nsPresState;
    1: class nsILayoutHistoryState;
    1: class nsIEditor;
    1: struct nsRect;
    1: struct nsSize;
34395: class nsHTMLFormElement;
    1: 
10073: typedef nsMappedAttributeElement nsGenericHTMLElementBase;
    1: 
    1: /**
    1:  * A common superclass for HTML elements
    1:  */
 4306: class nsGenericHTMLElement : public nsGenericHTMLElementBase
    1: {
    1: public:
48124:   nsGenericHTMLElement(already_AddRefed<nsINodeInfo> aNodeInfo)
 4306:     : nsGenericHTMLElementBase(aNodeInfo)
    1:   {
48124:     NS_ASSERTION(mNodeInfo->NamespaceID() == kNameSpaceID_XHTML,
33350:                  "Unexpected namespace");
    1:   }
    1: 
    1:   /** Typesafe, non-refcounting cast from nsIContent.  Cheaper than QI. **/
    1:   static nsGenericHTMLElement* FromContent(nsIContent *aContent)
    1:   {
33329:     if (aContent->IsHTML())
 3233:       return static_cast<nsGenericHTMLElement*>(aContent);
    1:     return nsnull;
    1:   }
    1: 
    1:   /**
    1:    * Handle QI for the standard DOM interfaces (DOMNode, DOMElement,
    1:    * DOMHTMLElement) and handles tearoffs for other standard interfaces.
    1:    * @param aElement the element as nsIDOMHTMLElement*
    1:    * @param aIID the IID to QI to
    1:    * @param aInstancePtr the QI'd method [OUT]
    1:    * @see nsGenericHTMLElementTearoff
    1:    */
    1:   nsresult DOMQueryInterface(nsIDOMHTMLElement *aElement, REFNSIID aIID,
    1:                              void **aInstancePtr);
    1: 
    1:   // From nsGenericElement
    1:   nsresult CopyInnerTo(nsGenericElement* aDest) const;
    1: 
    1:   // Implementation for nsIDOMNode
    1:   NS_METHOD GetNodeName(nsAString& aNodeName);
    1: 
    1:   // Implementation for nsIDOMElement
    1:   NS_METHOD SetAttribute(const nsAString& aName,
    1:                          const nsAString& aValue);
    1:   NS_METHOD GetTagName(nsAString& aTagName);
    1:   NS_METHOD GetElementsByTagName(const nsAString& aTagname,
    1:                                  nsIDOMNodeList** aReturn);
    1: 
    1:   // nsIDOMHTMLElement methods. Note that these are non-virtual
    1:   // methods, implementations are expected to forward calls to these
    1:   // methods.
    1:   nsresult GetId(nsAString& aId);
    1:   nsresult SetId(const nsAString& aId);
    1:   nsresult GetTitle(nsAString& aTitle);
    1:   nsresult SetTitle(const nsAString& aTitle);
    1:   nsresult GetLang(nsAString& aLang);
    1:   nsresult SetLang(const nsAString& aLang);
    1:   nsresult GetDir(nsAString& aDir);
    1:   nsresult SetDir(const nsAString& aDir);
    1:   nsresult GetClassName(nsAString& aClassName);
    1:   nsresult SetClassName(const nsAString& aClassName);
    1: 
    1:   // nsIDOMNSHTMLElement methods. Note that these are non-virtual
    1:   // methods, implementations are expected to forward calls to these
    1:   // methods.
    1:   nsresult GetOffsetTop(PRInt32* aOffsetTop);
    1:   nsresult GetOffsetLeft(PRInt32* aOffsetLeft);
    1:   nsresult GetOffsetWidth(PRInt32* aOffsetWidth);
    1:   nsresult GetOffsetHeight(PRInt32* aOffsetHeight);
    1:   nsresult GetOffsetParent(nsIDOMElement** aOffsetParent);
    1:   virtual nsresult GetInnerHTML(nsAString& aInnerHTML);
    1:   virtual nsresult SetInnerHTML(const nsAString& aInnerHTML);
34226:   nsresult ScrollIntoView(PRBool aTop, PRUint8 optional_argc);
48696:   // Declare Focus(), Blur(), GetTabIndex(), SetTabIndex(), GetHidden(),
48696:   // SetHidden(), GetSpellcheck(), SetSpellcheck(), and GetDraggable() such that
48696:   // classes that inherit interfaces with those methods properly override them.
    1:   NS_IMETHOD Focus();
    1:   NS_IMETHOD Blur();
    1:   NS_IMETHOD GetTabIndex(PRInt32 *aTabIndex);
    1:   NS_IMETHOD SetTabIndex(PRInt32 aTabIndex);
48696:   NS_IMETHOD GetHidden(PRBool* aHidden);
48696:   NS_IMETHOD SetHidden(PRBool aHidden);
    1:   NS_IMETHOD GetSpellcheck(PRBool* aSpellcheck);
    1:   NS_IMETHOD SetSpellcheck(PRBool aSpellcheck);
18445:   NS_IMETHOD GetDraggable(PRBool* aDraggable);
18445:   NS_IMETHOD SetDraggable(PRBool aDraggable);
 2896:   nsresult GetContentEditable(nsAString &aContentEditable);
39457:   nsresult GetIsContentEditable(PRBool* aContentEditable);
 2896:   nsresult SetContentEditable(const nsAString &aContentEditable);
    1: 
    1:   // Implementation for nsIContent
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
 2896:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
 2896:                               PRBool aNullParent = PR_TRUE);
 2896:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 2896:                    const nsAString& aValue, PRBool aNotify)
 2896:   {
 2896:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
 2896:   }
 2896:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 2896:                            nsIAtom* aPrefix, const nsAString& aValue,
 2896:                            PRBool aNotify);
    1:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                              PRBool aNotify);
41071:   virtual PRBool IsFocusable(PRInt32 *aTabIndex = nsnull, PRBool aWithMouse = PR_FALSE)
14348:   {
14792:     PRBool isFocusable = PR_FALSE;
43884:     IsHTMLFocusable(aWithMouse, &isFocusable, aTabIndex);
14348:     return isFocusable;
14348:   }
14348:   /**
14348:    * Returns PR_TRUE if a subclass is not allowed to override the value returned
14348:    * in aIsFocusable.
14348:    */
43884:   virtual PRBool IsHTMLFocusable(PRBool aWithMouse,
43884:                                  PRBool *aIsFocusable,
43884:                                  PRInt32 *aTabIndex);
    1:   virtual void PerformAccesskey(PRBool aKeyCausesActivation,
    1:                                 PRBool aIsTrustedEvent);
    1: 
  723:   /**
  723:    * Check if an event for an anchor can be handled
  723:    * @return PR_TRUE if the event can be handled, PR_FALSE otherwise
  723:    */
  723:   PRBool CheckHandleEventForAnchorsPreconditions(nsEventChainVisitor& aVisitor);
  723:   nsresult PreHandleEventForAnchors(nsEventChainPreVisitor& aVisitor);
    1:   nsresult PostHandleEventForAnchors(nsEventChainPostVisitor& aVisitor);
    1:   PRBool IsHTMLLink(nsIURI** aURI) const;
    1: 
26909:   // As above, but makes sure to return a URI object that we can mutate with
26909:   // impunity without changing our current URI.  That is, if the URI is cached
26909:   // it clones it and returns the clone.
26909:   void GetHrefURIToMutate(nsIURI** aURI);
26909: 
    1:   // HTML element methods
11169:   void Compact() { mAttrsAndChildren.Compact(); }
    1: 
 2896:   virtual void UpdateEditableState();
 2896: 
    1:   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAttribute,
    1:                                 const nsAString& aValue,
    1:                                 nsAttrValue& aResult);
    1: 
    1:   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
10073:   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
    1: 
    1:   /**
    1:    * Get the base target for any links within this piece
    1:    * of content. Generally, this is the document's base target,
    1:    * but certain content carries a local base for backward
    1:    * compatibility.
    1:    *
    1:    * @param aBaseTarget the base target [OUT]
    1:    */
    1:   void GetBaseTarget(nsAString& aBaseTarget) const;
    1: 
    1:   /**
36655:    * Get the primary form control frame for this element.  Same as
36655:    * GetPrimaryFrame(), except it QI's to nsIFormControlFrame.
    1:    *
36655:    * @param aFlush whether to flush out frames so that they're up to date.
36655:    * @return the primary frame as nsIFormControlFrame
    1:    */
36655:   nsIFormControlFrame* GetFormControlFrame(PRBool aFlushFrames);
    1: 
    1:   //----------------------------------------
    1: 
    1:   /**
    1:    * Parse an alignment attribute (top/middle/bottom/baseline)
    1:    *
    1:    * @param aString the string to parse
    1:    * @param aResult the resulting HTMLValue
    1:    * @return whether the value was parsed
    1:    */
    1:   static PRBool ParseAlignValue(const nsAString& aString,
    1:                                 nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Parse a div align string to value (left/right/center/middle/justify)
    1:    *
    1:    * @param aString the string to parse
    1:    * @param aResult the resulting HTMLValue
    1:    * @return whether the value was parsed
    1:    */
47237:   static PRBool ParseDivAlignValue(const nsAString& aString,
47237:                                    nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Convert a table halign string to value (left/right/center/char/justify)
    1:    *
    1:    * @param aString the string to parse
    1:    * @param aResult the resulting HTMLValue
    1:    * @return whether the value was parsed
    1:    */
43545:   static PRBool ParseTableHAlignValue(const nsAString& aString,
43545:                                       nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Convert a table cell halign string to value
    1:    *
    1:    * @param aString the string to parse
    1:    * @param aResult the resulting HTMLValue
    1:    * @return whether the value was parsed
    1:    */
48442:   static PRBool ParseTableCellHAlignValue(const nsAString& aString,
48442:                                           nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Convert a table valign string to value (left/right/center/char/justify/
    1:    * abscenter/absmiddle/middle)
    1:    *
    1:    * @param aString the string to parse
    1:    * @param aResult the resulting HTMLValue
    1:    * @return whether the value was parsed
    1:    */
    1:   static PRBool ParseTableVAlignValue(const nsAString& aString,
    1:                                       nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Convert an image attribute to value (width, height, hspace, vspace, border)
    1:    *
    1:    * @param aAttribute the attribute to parse
    1:    * @param aString the string to parse
    1:    * @param aResult the resulting HTMLValue
    1:    * @return whether the value was parsed
    1:    */
    1:   static PRBool ParseImageAttribute(nsIAtom* aAttribute,
    1:                                     const nsAString& aString,
    1:                                     nsAttrValue& aResult);
    1:   /**
    1:    * Convert a frameborder string to value (yes/no/1/0)
    1:    *
    1:    * @param aString the string to parse
    1:    * @param aResult the resulting HTMLValue
    1:    * @return whether the value was parsed
    1:    */
    1:   static PRBool ParseFrameborderValue(const nsAString& aString,
    1:                                       nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Convert a scrolling string to value (yes/no/on/off/scroll/noscroll/auto)
    1:    *
    1:    * @param aString the string to parse
    1:    * @param aResult the resulting HTMLValue
    1:    * @return whether the value was parsed
    1:    */
    1:   static PRBool ParseScrollingValue(const nsAString& aString,
    1:                                     nsAttrValue& aResult);
    1: 
    1:   /*
    1:    * Attribute Mapping Helpers
    1:    */
    1: 
    1:   /**
    1:    * A style attribute mapping function for the most common attributes, to be
    1:    * called by subclasses' attribute mapping functions.  Currently handles
    1:    * dir and lang, could handle others.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapCommonAttributesInto(const nsMappedAttributes* aAttributes, 
    1:                                       nsRuleData* aRuleData);
    1:   static const MappedAttributeEntry sCommonAttributeMap[];
    1:   static const MappedAttributeEntry sImageMarginSizeAttributeMap[];
    1:   static const MappedAttributeEntry sImageBorderAttributeMap[];
    1:   static const MappedAttributeEntry sImageAlignAttributeMap[];
    1:   static const MappedAttributeEntry sDivAlignAttributeMap[];
    1:   static const MappedAttributeEntry sBackgroundAttributeMap[];
    1:   static const MappedAttributeEntry sBackgroundColorAttributeMap[];
    1:   static const MappedAttributeEntry sScrollingAttributeMap[];
    1:   
    1:   /**
    1:    * Helper to map the align attribute into a style struct.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapImageAlignAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                          nsRuleData* aData);
    1: 
    1:   /**
    1:    * Helper to map the align attribute into a style struct for things
    1:    * like <div>, <h1>, etc.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapDivAlignAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                        nsRuleData* aData);
    1: 
    1:   /**
    1:    * Helper to map the image border attribute into a style struct.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapImageBorderAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                           nsRuleData* aData);
    1:   /**
    1:    * Helper to map the image margin attribute into a style struct.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapImageMarginAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                           nsRuleData* aData);
    1:   /**
    1:    * Helper to map the image position attribute into a style struct.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapImageSizeAttributesInto(const nsMappedAttributes* aAttributes,
    1:                                          nsRuleData* aData);
    1:   /**
    1:    * Helper to map the background attribute
    1:    * into a style struct.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapBackgroundInto(const nsMappedAttributes* aAttributes,
    1:                                 nsRuleData* aData);
    1:   /**
    1:    * Helper to map the bgcolor attribute
    1:    * into a style struct.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapBGColorInto(const nsMappedAttributes* aAttributes,
    1:                              nsRuleData* aData);
    1:   /**
    1:    * Helper to map the background attributes (currently background and bgcolor)
    1:    * into a style struct.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
    1:                                           nsRuleData* aData);
    1:   /**
    1:    * Helper to map the scrolling attribute on FRAME and IFRAME
    1:    * into a style struct.
    1:    *
    1:    * @param aAttributes the list of attributes to map
    1:    * @param aData the returned rule data [INOUT]
    1:    * @see GetAttributeMappingFunction
    1:    */
    1:   static void MapScrollingAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                         nsRuleData* aData);
    1:   /**
    1:    * Get the presentation state for a piece of content, or create it if it does
    1:    * not exist.  Generally used by SaveState().
    1:    *
    1:    * @param aContent the content to get presentation state for.
    1:    * @param aPresState the presentation state (out param)
    1:    */
    1:   static nsresult GetPrimaryPresState(nsGenericHTMLElement* aContent,
    1:                                       nsPresState** aPresState);
    1:   /**
    1:    * Get the layout history object *and* generate the key for a particular
    1:    * piece of content.
    1:    *
    1:    * @param aContent the content to generate the key for
 3727:    * @param aRead if true, won't return a layout history state (and won't
 3727:    *              generate a key) if the layout history state is empty.
    1:    * @param aState the history state object (out param)
    1:    * @param aKey the key (out param)
    1:    */
    1:   static nsresult GetLayoutHistoryAndKey(nsGenericHTMLElement* aContent,
 3727:                                          PRBool aRead,
    1:                                          nsILayoutHistoryState** aState,
    1:                                          nsACString& aKey);
    1:   /**
    1:    * Restore the state for a form control.  Ends up calling
    1:    * nsIFormControl::RestoreState().
    1:    *
    1:    * @param aContent an nsGenericHTMLElement* pointing to the form control
    1:    * @param aControl an nsIFormControl* pointing to the form control
    1:    * @return PR_FALSE if RestoreState() was not called, the return
    1:    *         value of RestoreState() otherwise.
    1:    */
    1:   static PRBool RestoreFormControlState(nsGenericHTMLElement* aContent,
    1:                                         nsIFormControl* aControl);
    1: 
    1:   /**
    1:    * Get the presentation context for this content node.
    1:    * @return the presentation context
    1:    */
    1:   NS_HIDDEN_(nsPresContext*) GetPresContext();
    1: 
    1:   // Form Helper Routines
    1:   /**
    1:    * Find an ancestor of this content node which is a form (could be null)
    1:    * @param aCurrentForm the current form for this node.  If this is
    1:    *        non-null, and no ancestor form is found, and the current form is in
    1:    *        a connected subtree with the node, the current form will be
    1:    *        returned.  This is needed to handle cases when HTML elements have a
    1:    *        current form that they're not descendants of.
51301:    * @note This method should not be called if the element has a form attribute.
    1:    */
51301:   nsHTMLFormElement* FindAncestorForm(nsHTMLFormElement* aCurrentForm = nsnull);
    1: 
    1:   virtual void RecompileScriptEventListeners();
    1: 
    1:   /**
    1:    * See if the document being tested has nav-quirks mode enabled.
    1:    * @param doc the document
    1:    */
    1:   static PRBool InNavQuirksMode(nsIDocument* aDoc);
    1: 
24836:   /**
24836:    * Locate an nsIEditor rooted at this content node, if there is one.
24836:    */
24836:   NS_HIDDEN_(nsresult) GetEditor(nsIEditor** aEditor);
24836:   NS_HIDDEN_(nsresult) GetEditorInternal(nsIEditor** aEditor);
24836: 
50992:   /**
50992:    * Helper method for NS_IMPL_URI_ATTR macro.
50992:    * Gets the absolute URI value of an attribute, by resolving any relative
50992:    * URIs in the attribute against the baseuri of the element. If the attribute
50992:    * isn't a relative URI the value of the attribute is returned as is. Only
50992:    * works for attributes in null namespace.
50992:    *
50992:    * @param aAttr      name of attribute.
50992:    * @param aBaseAttr  name of base attribute.
50992:    * @param aResult    result value [out]
50992:    */
50992:   NS_HIDDEN_(nsresult) GetURIAttr(nsIAtom* aAttr, nsIAtom* aBaseAttr, nsAString& aResult);
50992: 
52359:   /**
54342:    * Returns the current disabled state of the element.
54342:    */
54342:   virtual bool IsDisabled() const {
54342:     return HasAttr(kNameSpaceID_None, nsGkAtoms::disabled);
54342:   }
54342: 
    1: protected:
    1:   /**
43079:    * Add/remove this element to the documents name cache
43079:    */
43079:   void AddToNameTable(nsIAtom* aName) {
43079:     NS_ASSERTION(HasFlag(NODE_HAS_NAME), "Node lacking NODE_HAS_NAME flag");
43079:     nsIDocument* doc = GetCurrentDoc();
43079:     if (doc && !IsInAnonymousSubtree()) {
43079:       doc->AddToNameTable(this, aName);
43079:     }
43079:   }
43079:   void RemoveFromNameTable() {
43079:     if (HasFlag(NODE_HAS_NAME)) {
43079:       nsIDocument* doc = GetCurrentDoc();
43079:       if (doc) {
43079:         doc->RemoveFromNameTable(this, GetParsedAttr(nsGkAtoms::name)->
43079:                                          GetAtomValue());
43079:       }
43079:     }
43079:   }
43079: 
43079:   /**
    1:    * Register or unregister an access key to this element based on the
    1:    * accesskey attribute.
    1:    */
43077:   void RegAccessKey()
43077:   {
43077:     if (HasFlag(NODE_HAS_ACCESSKEY)) {
43077:       RegUnRegAccessKey(PR_TRUE);
43077:     }
43077:   }
43077: 
43077:   void UnregAccessKey()
43077:   {
43077:     if (HasFlag(NODE_HAS_ACCESSKEY)) {
43077:       RegUnRegAccessKey(PR_FALSE);
43077:     }
43077:   }
43077: 
43077: private:
    1:   void RegUnRegAccessKey(PRBool aDoReg);
    1: 
43077: protected:
    1:   /**
    1:    * Determine whether an attribute is an event (onclick, etc.)
    1:    * @param aName the attribute
    1:    * @return whether the name is an event handler name
    1:    */
    1:   PRBool IsEventName(nsIAtom* aName);
    1: 
    1:   virtual nsresult AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                                 const nsAString* aValue, PRBool aNotify);
    1: 
    1:   virtual nsresult
    1:     GetEventListenerManagerForAttr(nsIEventListenerManager** aManager,
    1:                                    nsISupports** aTarget,
    1:                                    PRBool* aDefer);
    1: 
    1:   virtual const nsAttrName* InternalGetExistingAttrNameFromQName(const nsAString& aStr) const;
    1: 
    1:   /**
    1:    * Helper method for NS_IMPL_STRING_ATTR macro.
    1:    * Gets the value of an attribute, returns empty string if
    1:    * attribute isn't set. Only works for attributes in null namespace.
    1:    *
    1:    * @param aAttr    name of attribute.
    1:    * @param aDefault default-value to return if attribute isn't set.
    1:    * @param aResult  result value [out]
    1:    * @result always NS_OK
    1:    */
    1:   NS_HIDDEN_(nsresult) GetAttrHelper(nsIAtom* aAttr, nsAString& aValue);
    1: 
    1:   /**
    1:    * Helper method for NS_IMPL_STRING_ATTR macro.
    1:    * Sets the value of an attribute, returns specified default value if the
    1:    * attribute isn't set. Only works for attributes in null namespace.
    1:    *
    1:    * @param aAttr    name of attribute.
    1:    * @param aDefault default-value to return if attribute isn't set.
    1:    * @param aResult  result value [out]
    1:    */
    1:   NS_HIDDEN_(nsresult) SetAttrHelper(nsIAtom* aAttr, const nsAString& aValue);
    1: 
    1:   /**
    1:    * Helper method for NS_IMPL_STRING_ATTR_DEFAULT_VALUE macro.
    1:    * Gets the value of an attribute, returns specified default value if the
    1:    * attribute isn't set. Only works for attributes in null namespace.
    1:    *
    1:    * @param aAttr    name of attribute.
    1:    * @param aDefault default-value to return if attribute isn't set.
    1:    * @param aResult  result value [out]
    1:    */
    1:   NS_HIDDEN_(nsresult) GetStringAttrWithDefault(nsIAtom* aAttr,
    1:                                                 const char* aDefault,
    1:                                                 nsAString& aResult);
    1: 
    1:   /**
    1:    * Helper method for NS_IMPL_BOOL_ATTR macro.
    1:    * Gets value of boolean attribute. Only works for attributes in null
    1:    * namespace.
    1:    *
    1:    * @param aAttr    name of attribute.
    1:    * @param aValue   Boolean value of attribute.
    1:    */
    1:   NS_HIDDEN_(nsresult) GetBoolAttr(nsIAtom* aAttr, PRBool* aValue) const;
    1: 
    1:   /**
    1:    * Helper method for NS_IMPL_BOOL_ATTR macro.
    1:    * Sets value of boolean attribute by removing attribute or setting it to
    1:    * the empty string. Only works for attributes in null namespace.
    1:    *
    1:    * @param aAttr    name of attribute.
    1:    * @param aValue   Boolean value of attribute.
    1:    */
    1:   NS_HIDDEN_(nsresult) SetBoolAttr(nsIAtom* aAttr, PRBool aValue);
    1: 
    1:   /**
    1:    * Helper method for NS_IMPL_INT_ATTR macro.
    1:    * Gets the integer-value of an attribute, returns specified default value
    1:    * if the attribute isn't set or isn't set to an integer. Only works for
    1:    * attributes in null namespace.
    1:    *
    1:    * @param aAttr    name of attribute.
    1:    * @param aDefault default-value to return if attribute isn't set.
    1:    * @param aResult  result value [out]
    1:    */
    1:   NS_HIDDEN_(nsresult) GetIntAttr(nsIAtom* aAttr, PRInt32 aDefault, PRInt32* aValue);
    1: 
    1:   /**
    1:    * Helper method for NS_IMPL_INT_ATTR macro.
    1:    * Sets value of attribute to specified integer. Only works for attributes
    1:    * in null namespace.
    1:    *
    1:    * @param aAttr    name of attribute.
    1:    * @param aValue   Integer value of attribute.
    1:    */
    1:   NS_HIDDEN_(nsresult) SetIntAttr(nsIAtom* aAttr, PRInt32 aValue);
    1: 
    1:   /**
15751:    * Helper method for NS_IMPL_FLOAT_ATTR macro.
15751:    * Gets the float-value of an attribute, returns specified default value
15751:    * if the attribute isn't set or isn't set to a float. Only works for
15751:    * attributes in null namespace.
15751:    *
15751:    * @param aAttr    name of attribute.
15751:    * @param aDefault default-value to return if attribute isn't set.
15751:    * @param aResult  result value [out]
15751:    */
15751:   NS_HIDDEN_(nsresult) GetFloatAttr(nsIAtom* aAttr, float aDefault, float* aValue);
15751: 
15751:   /**
15751:    * Helper method for NS_IMPL_FLOAT_ATTR macro.
15751:    * Sets value of attribute to specified float. Only works for attributes
15751:    * in null namespace.
15751:    *
15751:    * @param aAttr    name of attribute.
15751:    * @param aValue   Float value of attribute.
15751:    */
15751:   NS_HIDDEN_(nsresult) SetFloatAttr(nsIAtom* aAttr, float aValue);
15751: 
15751:   /**
25979:    * Helper for GetURIAttr and GetHrefURIForAnchors which returns an
26909:    * nsIURI in the out param.
26909:    *
26909:    * @param aCloneIfCached if true, clone the URI before returning if
26909:    * it's cached.
25979:    *
25979:    * @return PR_TRUE if we had the attr, PR_FALSE otherwise.
25979:    */
25979:   NS_HIDDEN_(PRBool) GetURIAttr(nsIAtom* aAttr, nsIAtom* aBaseAttr,
26909:                                 PRBool aCloneIfCached, nsIURI** aURI) const;
25979: 
25979:   /**
    1:    * This method works like GetURIAttr, except that it supports multiple
    1:    * URIs separated by whitespace (one or more U+0020 SPACE characters).
    1:    *
    1:    * Gets the absolute URI values of an attribute, by resolving any relative
    1:    * URIs in the attribute against the baseuri of the element. If a substring
    1:    * isn't a relative URI, the substring is returned as is. Only works for
    1:    * attributes in null namespace.
    1:    *
    1:    * @param aAttr    name of attribute.
    1:    * @param aResult  result value [out]
    1:    */
    1:   NS_HIDDEN_(nsresult) GetURIListAttr(nsIAtom* aAttr, nsAString& aResult);
    1: 
    1:   /**
54823:    * Helper method for NS_IMPL_ENUM_ATTR_DEFAULT_VALUE.
54823:    * Gets the enum value string of an attribute and using a default value if
54823:    * the attribute is missing or the string is an invalid enum value.
54823:    *
54823:    * @param aType     the name of the attribute.
54823:    * @param aDefault  the default value if the attribute is missing or invalid.
54823:    * @param aResult   string corresponding to the value [out].
54823:    */
54823:   NS_HIDDEN_(nsresult) GetEnumAttr(nsIAtom* aAttr,
54823:                                    const char* aDefault,
54823:                                    nsAString& aResult);
54823: 
54823:   /**
    1:    * Locates the nsIEditor associated with this node.  In general this is
    1:    * equivalent to GetEditorInternal(), but for designmode or contenteditable,
    1:    * this may need to get an editor that's not actually on this element's
    1:    * associated TextControlFrame.  This is used by the spellchecking routines
    1:    * to get the editor affected by changing the spellcheck attribute on this
    1:    * node.
    1:    */
    1:   virtual already_AddRefed<nsIEditor> GetAssociatedEditor();
    1: 
    1:   /**
16722:    * Get the frame's offset information for offsetTop/Left/Width/Height.
16722:    * @note This method flushes pending notifications (Flush_Layout).
16722:    * @param aRect the offset information [OUT]
16722:    * @param aOffsetParent the parent the offset is relative to (offsetParent)
16722:    *        [OUT]
16722:    */
16722:   virtual void GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent);
16722: 
16722:   /**
    1:    * Returns true if this is the current document's body element
    1:    */
    1:   PRBool IsCurrentBodyElement();
    1: 
    1:   /**
    1:    * Ensures all editors associated with a subtree are synced, for purposes of
    1:    * spellchecking.
    1:    */
    1:   static void SyncEditorsOnSubtree(nsIContent* content);
 2896: 
 2896:   enum ContentEditableTristate {
 2896:     eInherit = -1,
 2896:     eFalse = 0,
 2896:     eTrue = 1
 2896:   };
 2896: 
 2896:   /**
 2896:    * Returns eTrue if the element has a contentEditable attribute and its value
 2896:    * is "true" or an empty string. Returns eFalse if the element has a
 2896:    * contentEditable attribute and its value is "false". Otherwise returns
 2896:    * eInherit.
 2896:    */
 2896:   NS_HIDDEN_(ContentEditableTristate) GetContentEditableValue() const
 2896:   {
 2896:     static const nsIContent::AttrValuesArray values[] =
 2896:       { &nsGkAtoms::_false, &nsGkAtoms::_true, &nsGkAtoms::_empty, nsnull };
 2896: 
29482:     if (!HasFlag(NODE_MAY_HAVE_CONTENT_EDITABLE_ATTR))
29482:       return eInherit;
29482: 
 2896:     PRInt32 value = FindAttrValueIn(kNameSpaceID_None,
 2896:                                     nsGkAtoms::contenteditable, values,
 2896:                                     eIgnoreCase);
 2896: 
 2896:     return value > 0 ? eTrue : (value == 0 ? eFalse : eInherit);
 2896:   }
 2896: 
38489:   // Used by A, AREA, LINK, and STYLE.
38489:   already_AddRefed<nsIURI> GetHrefURIForAnchors() const;
38489: 
 2896:   /**
 3444:    * Returns whether this element is an editable root. There are two types of
 3444:    * editable roots:
 3444:    *   1) the documentElement if the whole document is editable (for example for
 3444:    *      desginMode=on)
 3444:    *   2) an element that is marked editable with contentEditable=true and that
 3444:    *      doesn't have a parent or whose parent is not editable.
 3444:    * Note that this doesn't return input and textarea elements that haven't been
 3444:    * made editable through contentEditable or designMode.
 2896:    */
 2896:   PRBool IsEditableRoot() const;
 2896: 
55189: private:
 2896:   void ChangeEditableState(PRInt32 aChange);
    1: };
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * A helper class for form elements that can contain children
    1:  */
    1: class nsGenericHTMLFormElement : public nsGenericHTMLElement,
    1:                                  public nsIFormControl
    1: {
    1: public:
48124:   nsGenericHTMLFormElement(already_AddRefed<nsINodeInfo> aNodeInfo);
    1:   virtual ~nsGenericHTMLFormElement();
    1: 
    1:   NS_IMETHOD QueryInterface(REFNSIID aIID, void** aInstancePtr);
    1: 
    1:   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
14188:   virtual void SaveSubtreeState();
    1: 
    1:   // nsIFormControl
47801:   virtual mozilla::dom::Element* GetFormElement();
19131:   virtual void SetForm(nsIDOMHTMLFormElement* aForm);
19131:   virtual void ClearForm(PRBool aRemoveFromForm, PRBool aNotify);
    1: 
47801:   nsresult GetForm(nsIDOMHTMLFormElement** aForm);
47801: 
    1:   NS_IMETHOD SaveState()
    1:   {
    1:     return NS_OK;
    1:   }
14188:   
    1:   virtual PRBool RestoreState(nsPresState* aState)
    1:   {
    1:     return PR_FALSE;
    1:   }
    1:   virtual PRBool AllowDrop()
    1:   {
    1:     return PR_TRUE;
    1:   }
    1:   
    1:   virtual PRBool IsSubmitControl() const;
    1: 
42192:           PRBool IsTextControl(PRBool aExcludePassword) const;
42192: 
42192:           PRBool IsSingleLineTextControl(PRBool aExcludePassword) const;
42192: 
42487:           PRBool IsLabelableControl() const;
42487: 
51181:           PRBool IsSubmittableControl() const;
51181: 
    1:   // nsIContent
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
    1:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
    1:                               PRBool aNullParent = PR_TRUE);
    1:   virtual PRUint32 GetDesiredIMEState();
56168:   virtual nsEventStates IntrinsicState() const;
    1: 
29018:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
29018: 
54342:   virtual bool IsDisabled() const {
54342:     return HasAttr(kNameSpaceID_None, nsGkAtoms::disabled) ||
54342:            (mFieldSet && mFieldSet->IsDisabled());
54342:   }
54342: 
54342:   /**
54342:    * This callback is called by a fieldest on all it's elements whenever it's
54342:    * disabled attribute is changed so the element knows it's disabled state
54342:    * might have changed.
54342:    *
54342:    * @param aStates States for which a change should be notified.
54342:    * @note Classes redefining this method should not call ContentStatesChanged
54342:    * but they should pass aStates instead.
54342:    */
56168:   virtual void FieldSetDisabledChanged(nsEventStates aStates, PRBool aNotify);
54346: 
55188:   void FieldSetFirstLegendChanged(PRBool aNotify) {
54346:     UpdateFieldSet();
54346: 
54346:     // The disabled state may have change because the element might not be in
54346:     // the first legend anymore.
56168:     FieldSetDisabledChanged(nsEventStates(), aNotify);
54346:   }
54342: 
50904:   /**
56935:    * This callback is called by a fieldset on all it's elements when it's being
56935:    * destroyed. When called, the elements should check that aFieldset is there
56935:    * first parent fieldset and null mFieldset in that case only.
56935:    *
56935:    * @param aFieldSet The fieldset being removed.
56935:    */
56935:   void ForgetFieldSet(nsIContent* aFieldset) {
56935:     if (mFieldSet == aFieldset) {
56935:       mFieldSet = nsnull;
56935:     }
56935:   }
56935: 
56935:   /**
50904:    * Returns if the control can be disabled.
50904:    */
50904:   PRBool CanBeDisabled() const;
50904: 
    1: protected:
    1:   virtual nsresult BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                                  const nsAString* aValue, PRBool aNotify);
    1: 
    1:   virtual nsresult AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                                 const nsAString* aValue, PRBool aNotify);
    1: 
    1:   /**
42460:    * Returns if the element should react on autofocus attribute.
42460:    */
42460:   virtual PRBool AcceptAutofocus() const
42460:   {
42460:     return PR_FALSE;
42460:   }
42460: 
 2896:   void UpdateEditableFormControlState();
    1: 
43129:   PRBool IsSingleLineTextControlInternal(PRBool aExcludePassword, PRInt32 mType) const;
43129: 
51301:   /**
51301:    * This method will update the form owner, using @form or looking to a parent.
51301:    *
51301:    * @param aBindToTree Whether the element is being attached to the tree.
51301:    * @param aFormIdElement The element associated with the id in @form. If
51301:    * aBindToTree is false, aFormIdElement *must* contain the element associated
51301:    * with the id in @form. Otherwise, it *must* be null.
51492:    *
51492:    * @note Callers of UpdateFormOwner have to be sure the element is in a
51492:    * document (GetCurrentDoc() != nsnull).
51301:    */
51301:   void UpdateFormOwner(bool aBindToTree, Element* aFormIdElement);
51301: 
51301:   /**
54342:    * This method will update mFieldset and set it to the first fieldset parent.
54342:    */
54342:   void UpdateFieldSet();
54342: 
54342:   /**
51301:    * Add a form id observer which will observe when the element with the id in
51301:    * @form will change.
51301:    *
51301:    * @return The element associated with the current id in @form (may be null).
51301:    */
51301:   Element* AddFormIdObserver();
51301: 
51301:   /**
51301:    * Remove the form id observer.
51301:    */
51301:   void RemoveFormIdObserver();
51301: 
51301:   /**
51301:    * This method is a a callback for IDTargetObserver (from nsIDocument).
51301:    * It will be called each time the element associated with the id in @form
51301:    * changes.
51301:    */
51301:   static PRBool FormIdUpdated(Element* aOldElement, Element* aNewElement,
51301:                               void* aData);
51301: 
20109:   // The focusability state of this form control.  eUnfocusable means that it
20109:   // shouldn't be focused at all, eInactiveWindow means it's in an inactive
20109:   // window, eActiveWindow means it's in an active window.
20109:   enum FocusTristate {
20109:     eUnfocusable,
20109:     eInactiveWindow,
20109:     eActiveWindow
20109:   };
20109: 
20109:   // Get our focus state.  If this returns eInactiveWindow, it will set this
20109:   // element as the focused element for that window.
20109:   FocusTristate FocusState();
20109: 
    1:   /** The form that contains this control */
34395:   nsHTMLFormElement* mForm;
54342: 
54342:   /* This is a pointer to our closest fieldset parent if any */
54342:   nsGenericHTMLFormElement* mFieldSet;
    1: };
    1: 
 7654: // If this flag is set on an nsGenericHTMLFormElement, that means that we have
 7654: // added ourselves to our mForm.  It's possible to have a non-null mForm, but
 7654: // not have this flag set.  That happens when the form is set via the content
 7654: // sink.
43787: #define ADDED_TO_FORM (1 << ELEMENT_TYPE_SPECIFIC_BITS_OFFSET)
 7654: 
 7654: // If this flag is set on an nsGenericHTMLFormElement, that means that its form
 7654: // is in the process of being unbound from the tree, and this form element
 7654: // hasn't re-found its form in nsGenericHTMLFormElement::UnbindFromTree yet.
43787: #define MAYBE_ORPHAN_FORM_ELEMENT (1 << (ELEMENT_TYPE_SPECIFIC_BITS_OFFSET+1))
 7654: 
 7654: // NOTE: I don't think it's possible to have the above two flags set at the
 7654: // same time, so if it becomes an issue we can probably merge them into the
 7654: // same bit.  --bz
 7654: 
43785: // Make sure we have enough space for those bits
43787: PR_STATIC_ASSERT(ELEMENT_TYPE_SPECIFIC_BITS_OFFSET + 1 < 32);
43785: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * A helper class for frame elements
    1:  */
    1: 
    1: class nsGenericHTMLFrameElement : public nsGenericHTMLElement,
    1:                                   public nsIDOMNSHTMLFrameElement,
    1:                                   public nsIFrameLoaderOwner
    1: {
    1: public:
50721:   nsGenericHTMLFrameElement(already_AddRefed<nsINodeInfo> aNodeInfo,
56805:                             mozilla::dom::FromParser aFromParser)
    1:     : nsGenericHTMLElement(aNodeInfo)
    1:   {
56805:     mNetworkCreated = aFromParser == mozilla::dom::FROM_PARSER_NETWORK;
    1:   }
    1:   virtual ~nsGenericHTMLFrameElement();
    1: 
12033:   // nsISupports
12033:   NS_IMETHOD QueryInterface(REFNSIID aIID, void** aInstancePtr);
12033: 
    1:   // nsIDOMNSHTMLFrameElement
    1:   NS_DECL_NSIDOMNSHTMLFRAMEELEMENT
    1: 
    1:   // nsIFrameLoaderOwner
    1:   NS_DECL_NSIFRAMELOADEROWNER
    1: 
    1:   // nsIContent
43884:   virtual PRBool IsHTMLFocusable(PRBool aWithMouse, PRBool *aIsFocusable, PRInt32 *aTabIndex);
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
    1:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
    1:                               PRBool aNullParent = PR_TRUE);
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                    const nsAString& aValue, PRBool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                            nsIAtom* aPrefix, const nsAString& aValue,
    1:                            PRBool aNotify);
 8462:   virtual void DestroyContent();
    1: 
35581:   nsresult CopyInnerTo(nsGenericElement* aDest) const;
35581: 
    1:   // nsIDOMNSHTMLElement 
    1:   NS_IMETHOD GetTabIndex(PRInt32 *aTabIndex);
    1:   NS_IMETHOD SetTabIndex(PRInt32 aTabIndex);
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsGenericHTMLFrameElement,
    1:                                                      nsGenericHTMLElement)
    1: 
    1: protected:
    1:   // This doesn't really ensure a frame loade in all cases, only when
    1:   // it makes sense.
    1:   nsresult EnsureFrameLoader();
    1:   nsresult LoadSrc();
    1:   nsresult GetContentDocument(nsIDOMDocument** aContentDocument);
    1: 
34076:   nsRefPtr<nsFrameLoader> mFrameLoader;
50721:   // True when the element is created by the parser
50721:   // using NS_FROM_PARSER_NETWORK flag.
50721:   // If the element is modified, it may lose the flag.
50721:   PRPackedBool            mNetworkCreated;
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * A macro to implement the getter and setter for a given string
    1:  * valued content property. The method uses the generic GetAttr and
    1:  * SetAttr methods.
    1:  */
    1: #define NS_IMPL_STRING_ATTR(_class, _method, _atom)                  \
    1:   NS_IMETHODIMP                                                      \
    1:   _class::Get##_method(nsAString& aValue)                            \
    1:   {                                                                  \
    1:     return GetAttrHelper(nsGkAtoms::_atom, aValue);                  \
    1:   }                                                                  \
    1:   NS_IMETHODIMP                                                      \
    1:   _class::Set##_method(const nsAString& aValue)                      \
    1:   {                                                                  \
    1:     return SetAttrHelper(nsGkAtoms::_atom, aValue);                  \
    1:   }
    1: 
    1: /**
    1:  * A macro to implement the getter and setter for a given string
    1:  * valued content property with a default value.
    1:  * The method uses the generic GetAttr and SetAttr methods.
    1:  */
    1: #define NS_IMPL_STRING_ATTR_DEFAULT_VALUE(_class, _method, _atom, _default) \
    1:   NS_IMETHODIMP                                                      \
    1:   _class::Get##_method(nsAString& aValue)                            \
    1:   {                                                                  \
    1:     return GetStringAttrWithDefault(nsGkAtoms::_atom, _default, aValue);\
    1:   }                                                                  \
    1:   NS_IMETHODIMP                                                      \
    1:   _class::Set##_method(const nsAString& aValue)                      \
    1:   {                                                                  \
    1:     return SetAttrHelper(nsGkAtoms::_atom, aValue);                \
    1:   }
    1: 
    1: /**
    1:  * A macro to implement the getter and setter for a given boolean
    1:  * valued content property. The method uses the generic GetAttr and
    1:  * SetAttr methods.
    1:  */
    1: #define NS_IMPL_BOOL_ATTR(_class, _method, _atom)                     \
    1:   NS_IMETHODIMP                                                       \
    1:   _class::Get##_method(PRBool* aValue)                                \
    1:   {                                                                   \
    1:     return GetBoolAttr(nsGkAtoms::_atom, aValue);                   \
    1:   }                                                                   \
    1:   NS_IMETHODIMP                                                       \
    1:   _class::Set##_method(PRBool aValue)                                 \
    1:   {                                                                   \
    1:     return SetBoolAttr(nsGkAtoms::_atom, aValue);                   \
    1:   }
    1: 
    1: /**
    1:  * A macro to implement the getter and setter for a given integer
    1:  * valued content property. The method uses the generic GetAttr and
    1:  * SetAttr methods.
    1:  */
    1: #define NS_IMPL_INT_ATTR(_class, _method, _atom)                    \
56074:   NS_IMPL_INT_ATTR_DEFAULT_VALUE(_class, _method, _atom, 0)
    1: 
    1: #define NS_IMPL_INT_ATTR_DEFAULT_VALUE(_class, _method, _atom, _default)  \
    1:   NS_IMETHODIMP                                                           \
    1:   _class::Get##_method(PRInt32* aValue)                                   \
    1:   {                                                                       \
    1:     return GetIntAttr(nsGkAtoms::_atom, _default, aValue);              \
    1:   }                                                                       \
    1:   NS_IMETHODIMP                                                           \
    1:   _class::Set##_method(PRInt32 aValue)                                    \
    1:   {                                                                       \
    1:     return SetIntAttr(nsGkAtoms::_atom, aValue);                        \
    1:   }
    1: 
    1: /**
15751:  * A macro to implement the getter and setter for a given float
15751:  * valued content property. The method uses the generic GetAttr and
15751:  * SetAttr methods.
15751:  */
15751: #define NS_IMPL_FLOAT_ATTR(_class, _method, _atom)                    \
15751:   NS_IMPL_FLOAT_ATTR_DEFAULT_VALUE(_class, _method, _atom, 0.0)
15751: 
15751: #define NS_IMPL_FLOAT_ATTR_DEFAULT_VALUE(_class, _method, _atom, _default)  \
15751:   NS_IMETHODIMP                                                             \
15751:   _class::Get##_method(float* aValue)                                   \
15751:   {                                                                         \
15751:     return GetFloatAttr(nsGkAtoms::_atom, _default, aValue);                \
15751:   }                                                                         \
15751:   NS_IMETHODIMP                                                             \
15751:   _class::Set##_method(float aValue)                                    \
15751:   {                                                                         \
15751:     return SetFloatAttr(nsGkAtoms::_atom, aValue);                          \
15751:   }
15751: 
15751: /**
    1:  * A macro to implement the getter and setter for a given content
    1:  * property that needs to return a URI in string form.  The method
    1:  * uses the generic GetAttr and SetAttr methods.  This macro is much
    1:  * like the NS_IMPL_STRING_ATTR macro, except we make sure the URI is
    1:  * absolute.
    1:  */
    1: #define NS_IMPL_URI_ATTR(_class, _method, _atom)                    \
    1:   NS_IMETHODIMP                                                     \
    1:   _class::Get##_method(nsAString& aValue)                           \
    1:   {                                                                 \
    1:     return GetURIAttr(nsGkAtoms::_atom, nsnull, aValue);          \
    1:   }                                                                 \
    1:   NS_IMETHODIMP                                                     \
    1:   _class::Set##_method(const nsAString& aValue)                     \
    1:   {                                                                 \
    1:     return SetAttrHelper(nsGkAtoms::_atom, aValue);               \
    1:   }
    1: 
    1: #define NS_IMPL_URI_ATTR_WITH_BASE(_class, _method, _atom, _base_atom)       \
    1:   NS_IMETHODIMP                                                              \
    1:   _class::Get##_method(nsAString& aValue)                                    \
    1:   {                                                                          \
    1:     return GetURIAttr(nsGkAtoms::_atom, nsGkAtoms::_base_atom, aValue);  \
    1:   }                                                                          \
    1:   NS_IMETHODIMP                                                              \
    1:   _class::Set##_method(const nsAString& aValue)                              \
    1:   {                                                                          \
    1:     return SetAttrHelper(nsGkAtoms::_atom, aValue);                        \
    1:   }
    1: 
    1: /**
56696:  * A macro to implement getter and setter for action and form action content
56698:  * attributes. It's very similar to NS_IMPL_URI_ATTR excepted that if the
56696:  * content attribute is the empty string, the empty string is returned.
56696:  */
56696: #define NS_IMPL_ACTION_ATTR(_class, _method, _atom)                 \
56696:   NS_IMETHODIMP                                                     \
56696:   _class::Get##_method(nsAString& aValue)                           \
56696:   {                                                                 \
56696:     GetAttr(kNameSpaceID_None, nsGkAtoms::_atom, aValue);           \
56696:     if (aValue.IsEmpty()) {                                         \
56696:       return NS_OK;                                                 \
56696:     }                                                               \
56696:     return GetURIAttr(nsGkAtoms::_atom, nsnull, aValue);            \
56696:   }                                                                 \
56696:   NS_IMETHODIMP                                                     \
56696:   _class::Set##_method(const nsAString& aValue)                     \
56696:   {                                                                 \
56696:     return SetAttrHelper(nsGkAtoms::_atom, aValue);                 \
56696:   }
56696: 
56696: /**
39007:  * A macro to implement the getter and setter for a given content
39007:  * property that needs to set a non-negative integer. The method
39007:  * uses the generic GetAttr and SetAttr methods. This macro is much
39007:  * like the NS_IMPL_INT_ATTR macro except we throw an exception if
39007:  * the set value is negative.
39007:  */
39007: #define NS_IMPL_NON_NEGATIVE_INT_ATTR(_class, _method, _atom)             \
39007:   NS_IMPL_NON_NEGATIVE_INT_ATTR_DEFAULT_VALUE(_class, _method, _atom, -1)
39007: 
39007: #define NS_IMPL_NON_NEGATIVE_INT_ATTR_DEFAULT_VALUE(_class, _method, _atom, _default)  \
39007:   NS_IMETHODIMP                                                           \
39007:   _class::Get##_method(PRInt32* aValue)                                   \
39007:   {                                                                       \
39007:     return GetIntAttr(nsGkAtoms::_atom, _default, aValue);                \
39007:   }                                                                       \
39007:   NS_IMETHODIMP                                                           \
39007:   _class::Set##_method(PRInt32 aValue)                                    \
39007:   {                                                                       \
39007:     if (aValue < 0) {                                                     \
39007:       return NS_ERROR_DOM_INDEX_SIZE_ERR;                                 \
39007:     }                                                                     \
39007:     return SetIntAttr(nsGkAtoms::_atom, aValue);                          \
39007:   }
39007: 
39007: /**
41437:  * A macro to implement the getter and setter for a given content
41437:  * property that needs to set an enumerated string. The method
41437:  * uses a specific GetEnumAttr and the generic SetAttrHelper methods.
41437:  */
41437: #define NS_IMPL_ENUM_ATTR_DEFAULT_VALUE(_class, _method, _atom, _default) \
41437:   NS_IMETHODIMP                                                           \
41437:   _class::Get##_method(nsAString& aValue)                                 \
41437:   {                                                                       \
41437:     return GetEnumAttr(nsGkAtoms::_atom, _default, aValue);               \
41437:   }                                                                       \
41437:   NS_IMETHODIMP                                                           \
41437:   _class::Set##_method(const nsAString& aValue)                           \
41437:   {                                                                       \
41437:     return SetAttrHelper(nsGkAtoms::_atom, aValue);                       \
41437:   }
41437: 
41437: /**
42581:  * A macro to implement the getter and setter for a given content
42581:  * property that needs to set a positive integer. The method uses
42581:  * the generic GetAttr and SetAttr methods. This macro is much like
42581:  * the NS_IMPL_NON_NEGATIVE_INT_ATTR macro except the exception is
42581:  * thrown also when the value is equal to 0.
42581:  */
42581: #define NS_IMPL_POSITIVE_INT_ATTR(_class, _method, _atom)                 \
42581:   NS_IMPL_POSITIVE_INT_ATTR_DEFAULT_VALUE(_class, _method, _atom, 1)
42581: 
42581: #define NS_IMPL_POSITIVE_INT_ATTR_DEFAULT_VALUE(_class, _method, _atom, _default)  \
42581:   NS_IMETHODIMP                                                           \
42581:   _class::Get##_method(PRInt32* aValue)                                   \
42581:   {                                                                       \
42581:     return GetIntAttr(nsGkAtoms::_atom, _default, aValue);                \
42581:   }                                                                       \
42581:   NS_IMETHODIMP                                                           \
42581:   _class::Set##_method(PRInt32 aValue)                                    \
42581:   {                                                                       \
42581:     if (aValue <= 0) {                                                    \
42581:       return NS_ERROR_DOM_INDEX_SIZE_ERR;                                 \
42581:     }                                                                     \
42581:     return SetIntAttr(nsGkAtoms::_atom, aValue);                          \
42581:   }
42581: 
42581: /**
    1:  * QueryInterface() implementation helper macros
    1:  */
    1: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGUOUS_BEGIN(_class, _base)        \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:     NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMNode, _base)             \
21218:     NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMElement, _base)          \
21218:     NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsIDOMHTMLElement, _base)
21218: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                         \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_AMBIGUOUS_BEGIN(_class, nsIDOMHTMLElement)
21218: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE_AMBIGUOUS(_class, _base, \
 4838:                                                                _base_if)      \
    1:   rv = _base::QueryInterface(aIID, aInstancePtr);                             \
    1:   if (NS_SUCCEEDED(rv))                                                       \
    1:     return rv;                                                                \
    1:                                                                               \
21218:   rv = DOMQueryInterface(static_cast<_base_if *>(this), aIID, aInstancePtr);  \
    1:   if (NS_SUCCEEDED(rv))                                                       \
    1:     return rv;                                                                \
    1:                                                                               \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
    1: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(_class, _base)           \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE_AMBIGUOUS(_class, _base,       \
    1:                                                          nsIDOMHTMLElement)
    1: 
    1: #define NS_HTML_CONTENT_INTERFACE_MAP_END                                     \
21218:   NS_ELEMENT_INTERFACE_MAP_END
    1: 
 4838: #define NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(_class)                \
39587:     NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(_class)                              \
 4838:   NS_HTML_CONTENT_INTERFACE_MAP_END
    1: 
    1: #define NS_INTERFACE_MAP_ENTRY_IF_TAG(_interface, _tag)                       \
    1:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(_interface,                              \
    1:                                      mNodeInfo->Equals(nsGkAtoms::_tag))
    1: 
    1: 
48124: #define NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO_GETTER(_getter) \
48124:   if (aIID.Equals(NS_GET_IID(nsIClassInfo)) ||               \
48124:       aIID.Equals(NS_GET_IID(nsXPCClassInfo))) {             \
48124:     foundInterface = _getter ();                             \
    1:     if (!foundInterface) {                                   \
    1:       *aInstancePtr = nsnull;                                \
    1:       return NS_ERROR_OUT_OF_MEMORY;                         \
    1:     }                                                        \
    1:   } else
    1: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE0(_class)                              \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE1(_class, _i1)                         \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE2(_class, _i1, _i2)                    \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218: 
26701: #define NS_HTML_CONTENT_INTERFACE_TABLE3(_class, _i1, _i2, _i3)          \
26701:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
26701:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
26701:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
26701:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
26701:   NS_OFFSET_AND_INTERFACE_TABLE_END
26701: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE4(_class, _i1, _i2, _i3, _i4)          \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE5(_class, _i1, _i2, _i3, _i4, _i5)     \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE6(_class, _i1, _i2, _i3, _i4, _i5,     \
21218:                                          _i6)                                 \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218: 
52042: #define NS_HTML_CONTENT_INTERFACE_TABLE7(_class, _i1, _i2, _i3, _i4, _i5,     \
52042:                                          _i6, _i7)                            \
52042:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
52042:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
52042:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
52042:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
52042:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
52042:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
52042:     NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
52042:     NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
52042:   NS_OFFSET_AND_INTERFACE_TABLE_END
52042: 
48892: #define NS_HTML_CONTENT_INTERFACE_TABLE8(_class, _i1, _i2, _i3, _i4, _i5,     \
48892:                                          _i6, _i7, _i8)                       \
48892:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
48892:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
48892:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
48892:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
48892:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
48892:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
48892:     NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
48892:     NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
48892:     NS_INTERFACE_TABLE_ENTRY(_class, _i8)                                     \
48892:   NS_OFFSET_AND_INTERFACE_TABLE_END
48892: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE9(_class, _i1, _i2, _i3, _i4, _i5,     \
21218:                                          _i6, _i7, _i8, _i9)                  \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i8)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i9)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218: 
21218: #define NS_HTML_CONTENT_INTERFACE_TABLE10(_class, _i1, _i2, _i3, _i4, _i5,    \
21218:                                           _i6, _i7, _i8, _i9, _i10)           \
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_BEGIN(_class)                               \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i8)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i9)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i10)                                    \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
    1: 
    1: 
56805: /**
56805:  * A macro to declare the NS_NewHTMLXXXElement() functions.
56805:  */
    1: #define NS_DECLARE_NS_NEW_HTML_ELEMENT(_elementName)                       \
    1: nsGenericHTMLElement*                                                      \
48124: NS_NewHTML##_elementName##Element(already_AddRefed<nsINodeInfo> aNodeInfo, \
56805:                                   mozilla::dom::FromParser aFromParser = mozilla::dom::NOT_FROM_PARSER);
    1: 
40996: #define NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED(_elementName)             \
40996: inline nsGenericHTMLElement*                                               \
48124: NS_NewHTML##_elementName##Element(already_AddRefed<nsINodeInfo> aNodeInfo, \
56805:                                   mozilla::dom::FromParser aFromParser = mozilla::dom::NOT_FROM_PARSER) \
40996: {                                                                          \
40996:   return NS_NewHTMLSharedElement(aNodeInfo, aFromParser);                  \
40996: }
40996: 
56805: /**
56805:  * A macro to implement the NS_NewHTMLXXXElement() functions.
56805:  */
56805: #define NS_IMPL_NS_NEW_HTML_ELEMENT(_elementName)                            \
56805: nsGenericHTMLElement*                                                        \
56805: NS_NewHTML##_elementName##Element(already_AddRefed<nsINodeInfo> aNodeInfo,   \
56805:                                   mozilla::dom::FromParser aFromParser)      \
56805: {                                                                            \
56805:   return new nsHTML##_elementName##Element(aNodeInfo);                       \
56805: }
56805: 
56805: #define NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(_elementName)               \
56805: nsGenericHTMLElement*                                                        \
56805: NS_NewHTML##_elementName##Element(already_AddRefed<nsINodeInfo> aNodeInfo,   \
56805:                                   mozilla::dom::FromParser aFromParser)      \
56805: {                                                                            \
56805:   return new nsHTML##_elementName##Element(aNodeInfo, aFromParser);          \
56805: }
56805: 
47632: // Here, we expand 'NS_DECLARE_NS_NEW_HTML_ELEMENT()' by hand.
47632: // (Calling the macro directly (with no args) produces compiler warnings.)
47632: nsGenericHTMLElement*
48124: NS_NewHTMLElement(already_AddRefed<nsINodeInfo> aNodeInfo,
56805:                   mozilla::dom::FromParser aFromParser = mozilla::dom::NOT_FROM_PARSER);
46287: 
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Shared)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(SharedList)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(SharedObject)
    1: 
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Anchor)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Area)
15751: #if defined(MOZ_MEDIA)
15751: NS_DECLARE_NS_NEW_HTML_ELEMENT(Audio)
15751: #endif
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(BR)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Body)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Button)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Canvas)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Mod)
52362: NS_DECLARE_NS_NEW_HTML_ELEMENT(DataList)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Div)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(FieldSet)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Font)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Form)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Frame)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(FrameSet)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(HR)
40996: NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED(Head)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Heading)
40996: NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED(Html)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(IFrame)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Image)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Input)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(LI)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Label)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Legend)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Link)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Map)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Meta)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Object)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(OptGroup)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Option)
41438: NS_DECLARE_NS_NEW_HTML_ELEMENT(Output)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Paragraph)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Pre)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Script)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Select)
15751: #if defined(MOZ_MEDIA)
15751: NS_DECLARE_NS_NEW_HTML_ELEMENT(Source)
15751: #endif
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Span)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Style)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(TableCaption)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(TableCell)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(TableCol)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Table)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(TableRow)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(TableSection)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Tbody)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(TextArea)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Tfoot)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Thead)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Title)
    1: NS_DECLARE_NS_NEW_HTML_ELEMENT(Unknown)
15751: #if defined(MOZ_MEDIA)
15751: NS_DECLARE_NS_NEW_HTML_ELEMENT(Video)
15751: #endif
    1: 
    1: #endif /* nsGenericHTMLElement_h___ */
