16839: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
16839: /* vim:expandtab:shiftwidth=4:tabstop=4:
16839:  */
16839: /* ***** BEGIN LICENSE BLOCK *****
16839:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
16839:  *
16839:  * The contents of this file are subject to the Mozilla Public License Version
16839:  * 1.1 (the "License"); you may not use this file except in compliance with
16839:  * the License. You may obtain a copy of the License at
16839:  * http://www.mozilla.org/MPL/
16839:  *
16839:  * Software distributed under the License is distributed on an "AS IS" basis,
16839:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
16839:  * for the specific language governing rights and limitations under the
16839:  * License.
16839:  *
16839:  * The Original Code is mozilla.org code.
16839:  *
16839:  * The Initial Developer of the Original Code is
16839:  *  Oleg Romashin <romaxa@gmail.com>.
16839:  *
16839:  * Contributor(s):
16839:  *  Oleg Romashin <romaxa@gmail.com>.
16839:  *
16839:  * Alternatively, the contents of this file may be used under the terms of
16839:  * either the GNU General Public License Version 2 or later (the "GPL"), or
16839:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
16839:  * in which case the provisions of the GPL or the LGPL are applicable instead
16839:  * of those above. If you wish to allow use of your version of this file only
16839:  * under the terms of either the GPL or the LGPL, and not to allow others to
16839:  * use your version of this file under the terms of the MPL, indicate your
16839:  * decision by deleting the provisions above and replace them with the notice
16839:  * and other provisions required by the GPL or the LGPL. If you do not delete
16839:  * the provisions above, a recipient may use your version of this file under
16839:  * the terms of any one of the MPL, the GPL or the LGPL.
16839:  *
16839:  * ***** END LICENSE BLOCK ***** */
16839: 
38955: #include "qmimedata.h"
38955: #include "qwidget.h"
38955: 
16839: #include "nsDragService.h"
16844: #include "nsISupportsPrimitives.h"
16844: #include "nsXPIDLString.h"
18501: #include "nsIDOMMouseEvent.h"
16839: 
16844: NS_IMPL_ADDREF_INHERITED(nsDragService, nsBaseDragService)
16844: NS_IMPL_RELEASE_INHERITED(nsDragService, nsBaseDragService)
16844: NS_IMPL_QUERY_INTERFACE2(nsDragService, nsIDragService, nsIDragSession )
16844: 
16844: nsDragService::nsDragService() : mDrag(NULL)
16839: {
16839:     /* member initializers and constructor code */
16844:         
16844:     // TODO: Any other better source? (the main window?)
16844:     //mHiddenWidget = new QWidget(0,QWidget::tr("DragDrop"),0);
16844:     mHiddenWidget = new QWidget();
16839: }
16839: 
16839: nsDragService::~nsDragService()
16839: {
16839:     /* destructor code */
16844:     delete mHiddenWidget;
16844: }
16844: 
16848: NS_IMETHODIMP
16848: nsDragService::SetDropActionType( PRUint32 aActionType )
16844: {
16844:     mDropAction = Qt::IgnoreAction;
16844: 
16844:     if (aActionType & DRAGDROP_ACTION_COPY)
16844:     {
16844:         mDropAction |= Qt::CopyAction;
16844:     }
16844:     if (aActionType & DRAGDROP_ACTION_MOVE)
16844:     {
16844:         mDropAction |= Qt::MoveAction;
16844:     }
16844:     if (aActionType & DRAGDROP_ACTION_LINK)
16844:     {
16844:         mDropAction |= Qt::LinkAction;
16844:     }
16844: 
16844:     return NS_OK;
16844: }
16844: 
16848: NS_IMETHODIMP
16848: nsDragService::SetupDragSession(
16844:                                 nsISupportsArray *aTransferables,
16844:                                 PRUint32 aActionType)
16844: {
16844:     PRUint32 itemCount = 0;
16844:     aTransferables->Count(&itemCount);
16844:     if (0 == itemCount)
16844:     {
16844:         qDebug("No items to drag?");
16844:         return NS_ERROR_FAILURE;
16844:     }
16844: 
16844:     if (1 != itemCount)
16844:     {
16844:         qDebug("Dragging more than one item, cannot do (yet?)");
16844:         return NS_ERROR_NOT_IMPLEMENTED;
16844:     }
16844: 
16844:     SetDropActionType(aActionType);
16844: 
16844:     QMimeData *mimeData = new QMimeData;
16844: 
16844:     nsCOMPtr<nsISupports> genericItem;
16844:     aTransferables->GetElementAt(0, getter_AddRefs(genericItem));
16844:     nsCOMPtr<nsITransferable> transferable(do_QueryInterface(genericItem));
16844: 
16844:     if (transferable)
16844:     {
16844:         nsCOMPtr <nsISupportsArray> flavorList;
16844:         transferable->FlavorsTransferableCanExport(getter_AddRefs(flavorList));
16844: 
16844:         if (flavorList)
16844:         {
16844:             PRUint32 flavorCount;
16844:             flavorList->Count( &flavorCount );
16844: 
16844:             for (PRUint32 flavor=0; flavor < flavorCount; flavor++)
16844:             {
16844:                 nsCOMPtr<nsISupports> genericWrapper;
16844:                 flavorList->GetElementAt(flavor, getter_AddRefs(genericWrapper));
16844:                 nsCOMPtr<nsISupportsCString> currentFlavor;
16844:                 currentFlavor = do_QueryInterface(genericWrapper);
16844: 
16844:                 if (currentFlavor)
16844:                 {
16844:                     nsCOMPtr<nsISupports> data;
16844:                     PRUint32 dataLen = 0;
16844:                     nsXPIDLCString flavorStr;
16844:                     currentFlavor->ToString(getter_Copies(flavorStr));
16844: 
16844:                     // Is it some flavor we think we could support?
16844:                     if (!strcmp(kURLMime, flavorStr.get())
16844:                      || !strcmp(kURLDataMime, flavorStr.get())
16844:                      || !strcmp(kURLDescriptionMime, flavorStr.get())
16844:                      || !strcmp(kHTMLMime, flavorStr.get())
16844:                      || !strcmp(kUnicodeMime, flavorStr.get())
16844:                         )
16844:                     {
16844:                         transferable->GetTransferData(flavorStr,getter_AddRefs(data),&dataLen);
16844: 
16844:                         nsCOMPtr<nsISupportsString> wideString;
16844:                         wideString = do_QueryInterface(data);
16844:                         if (!wideString)
16844:                         {
16844:                             return NS_ERROR_FAILURE;
16844:                         }
16844: 
16844:                         nsAutoString utf16string;
16844:                         wideString->GetData(utf16string);
16844:                         QByteArray ba((const char*) utf16string.get(), dataLen);
16844: 
16844:                         mimeData->setData(flavorStr.get(), ba);
16844:                     }
16844:                 }
16844:             }
16844:         }
16844:     }
16844: 
16844:     mDrag = new QDrag( mHiddenWidget ); // TODO: Better drag source here?
16844:     mDrag->setMimeData(mimeData);
16844: 
16844:     // mDrag and mimeData SHOULD NOT be destroyed. They are destroyed by QT.
16844: 
16844:     return NS_OK;
16839: }
16839: 
16839: /* void invokeDragSession (in nsIDOMNode aDOMNode, in nsISupportsArray aTransferables, in nsIScriptableRegion aRegion, in unsigned long aActionType); */
16839: NS_IMETHODIMP
16848: nsDragService::InvokeDragSession(
16848:                                 nsIDOMNode *aDOMNode,
16848:                                 nsISupportsArray *aTransferables,
16848:                                 nsIScriptableRegion *aRegion,
16848:                                 PRUint32 aActionType)
16839: {
16844:     nsBaseDragService::InvokeDragSession( 
16844:                                         aDOMNode,
16844:                                         aTransferables,
16844:                                         aRegion,
16844:                                         aActionType);
16844: 
16844:     SetupDragSession( aTransferables, aActionType);
16844: 
16844:     return NS_OK;
16844: }
16844: 
16844: NS_IMETHODIMP
16844: nsDragService::ExecuteDrag()
16844: {
16844:     Qt::DropAction dropAction = mDrag->exec( mDropAction );
16844: 
16844:     return NS_OK;
16839: }
16839: 
16839: /* void invokeDragSessionWithImage ( nsIDOMNode DOMNode , nsISupportsArray transferableArray , nsIScriptableRegion region , PRUint32 actionType , nsIDOMNode image , PRInt32 imageX , PRInt32 imageY , nsIDOMMouseEvent dragEvent ); */
16839: NS_IMETHODIMP
16844: nsDragService::InvokeDragSessionWithImage(
16844:                         nsIDOMNode *aDOMNode,
16844:                         nsISupportsArray*aTransferables,
16844:                         nsIScriptableRegion* aRegion,
16844:                         PRUint32 aActionType,
16844:                         nsIDOMNode* aImage,
16844:                         PRInt32 aImageX,
16844:                         PRInt32 aImageY,
18501:                         nsIDOMDragEvent* aDragEvent,
18501:                         nsIDOMDataTransfer* aDataTransfer)
16839: {
16844:     nsBaseDragService::InvokeDragSessionWithImage(
16844:                                         aDOMNode, aTransferables,
16844:                                         aRegion, aActionType,
16844:                                         aImage,
16844:                                         aImageX, aImageY,
18501:                                         aDragEvent,
18501:                                         aDataTransfer);
16844: 
16844:     SetupDragSession( aTransferables, aActionType);
16844: 
16844:     // Setup Image, and other stuff
16844:     if (aImage)
16844:     {
16844:         // Use the custom image 
16844:         // (aImageX,aImageY) specifies the offset "within the image where
16844:         // the cursor would be positioned"
16844: 
16844:         // So, convert the aImage to QPixmap and X and Y to q QPoint
16844:         // and then:
16844:         // mDrag->setPixmap( pixmap ) or mDrag->setDragCursor( pixmap );
16844:         // mDrad->setHotSpot( point );
16844:         
16844:         // TODO: Not implemented yet as this cannot be currently tested
16844:         qDebug("Support for drag image not implemented");
16844:     }
16844: 
16844:     return ExecuteDrag();
16839: }
16839: 
16839: NS_IMETHODIMP
18501: nsDragService::InvokeDragSessionWithSelection(nsISelection* aSelection,
18501:                                               nsISupportsArray* aTransferableArray,
18501:                                               PRUint32 aActionType,
18501:                                               nsIDOMDragEvent* aDragEvent,
18501:                                               nsIDOMDataTransfer* aDataTransfer)
16839: {
16844:     nsBaseDragService::InvokeDragSessionWithSelection(
16844:                                         aSelection,
18501:                                         aTransferableArray,
16844:                                         aActionType,
18501:                                         aDragEvent,
18501:                                         aDataTransfer);
16844: 
18501:     SetupDragSession( aTransferableArray, aActionType);
16844: 
16844:     // Setup selection related properties
16844:     // There is however nothing that needs to be set
16844: 
16844:     return ExecuteDrag();
16839: }
16839: 
16839: /* nsIDragSession getCurrentSession (); */
16839: NS_IMETHODIMP
16839: nsDragService::GetCurrentSession(nsIDragSession **_retval)
16839: {
16839:     return NS_ERROR_NOT_IMPLEMENTED;
16839: }
16839: 
16839: /* void startDragSession (); */
16839: NS_IMETHODIMP
16839: nsDragService::StartDragSession()
16839: {
16848:     return nsBaseDragService::StartDragSession();
16839: }
16839: 
16839: /* void endDragSession (in PRBool aDoneDrag); */
16839: NS_IMETHODIMP
16839: nsDragService::EndDragSession(PRBool aDoneDrag)
16839: {
16848:     return nsBaseDragService::EndDragSession(aDoneDrag);
16839: }
16839: 
16839: /* void fireDragEventAtSource (in unsigned long aMsg); */
16839: NS_IMETHODIMP
16839: nsDragService::FireDragEventAtSource(PRUint32 aMsg)
16839: {
16848:     return nsBaseDragService::FireDragEventAtSource(aMsg);
16839: }
16839: 
16848: /* TODO: What is this? */
16839: NS_IMETHODIMP
16839: nsDragService::Suppress()
16839: {
16848:     return nsBaseDragService::Suppress();
16839: }
16839: 
16848: /* TODO: What is this? */
16839: NS_IMETHODIMP
16839: nsDragService::Unsuppress()
16839: {
16848:     return nsBaseDragService::Unsuppress();
16839: }
16839: 
