    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for CSS display:inline objects */
    1: 
    1: #ifndef nsInlineFrame_h___
    1: #define nsInlineFrame_h___
    1: 
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsAbsoluteContainingBlock.h"
    1: #include "nsLineLayout.h"
    1: 
    1: class nsAnonymousBlockFrame;
    1: 
    1: #define nsInlineFrameSuper nsHTMLContainerFrame
    1: 
    1: // NS_INLINE_FRAME_HARD_TEXT_OFFSETS is used for access keys, where what
    1: // would normally be 1 text frame is split into 3 sets of an inline parent 
    1: // and text child (the pre access key text, the underlined key text, and
    1: // the post access key text). The offsets of the 3 text frame children
    1: // are set in nsCSSFrameConstructor
    1: 
    1: #define NS_INLINE_FRAME_HARD_TEXT_OFFSETS            0x00100000
    1: 
    1: /**  In Bidi left (or right) margin/padding/border should be applied to left
    1:  *  (or right) most frame (or a continuation frame).
    1:  *  This state value shows if this frame is left (or right) most continuation
    1:  *  or not.
    1:  */
    1: #define NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET     0x00200000
    1: 
    1: #define NS_INLINE_FRAME_BIDI_VISUAL_IS_LEFT_MOST     0x00400000
    1: 
    1: #define NS_INLINE_FRAME_BIDI_VISUAL_IS_RIGHT_MOST    0x00800000
    1: 
    1: /**
    1:  * Inline frame class.
    1:  *
    1:  * This class manages a list of child frames that are inline frames. Working with
    1:  * nsLineLayout, the class will reflow and place inline frames on a line.
    1:  */
    1: class nsInlineFrame : public nsInlineFrameSuper
    1: {
    1: public:
23554:   NS_DECLARE_FRAME_ACCESSOR(nsInlineFrame)
23554:   NS_DECL_QUERYFRAME
23554: 
23511:   friend nsIFrame* NS_NewInlineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
23510: 
    1:   // nsIFrame overrides
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1: 
    1: #ifdef ACCESSIBILITY
    1:   NS_IMETHODIMP GetAccessible(nsIAccessible** aAccessible);
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
    1: #endif
    1:   virtual nsIAtom* GetType() const;
    1: 
    1:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
    1:   {
    1:     return nsInlineFrameSuper::IsFrameOfType(aFlags &
 1588:       ~(nsIFrame::eBidiInlineContainer | nsIFrame::eLineParticipant));
    1:   }
    1: 
    1:   virtual PRBool IsEmpty();
    1:   virtual PRBool IsSelfEmpty();
    1: 
    1:   virtual PRBool PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset);
    1:   
    1:   // nsIHTMLReflow overrides
    1:   virtual void AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                                  InlineMinWidthData *aData);
    1:   virtual void AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                                   InlinePrefWidthData *aData);
    1:   virtual nsSize ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                              nsSize aCBSize, nscoord aAvailableWidth,
    1:                              nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                              PRBool aShrinkWrap);
 6862:   virtual nsRect ComputeTightBounds(gfxContext* aContext) const;
    1:   NS_IMETHOD Reflow(nsPresContext* aPresContext,
    1:                     nsHTMLReflowMetrics& aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus& aStatus);
    1: 
    1:   virtual PRBool CanContinueTextRun() const;
    1: 
30638:   virtual void PullOverflowsFromPrevInFlow();
30638: 
    1:   // Take all of the frames away from this frame. The caller is
    1:   // presumed to keep them alive.
    1:   void StealAllFrames() {
    1:     mFrames.SetFrames(nsnull);
    1:   }
    1: 
    1:   /**
    1:    * Return true if the frame is leftmost frame or continuation.
    1:    */
    1:   PRBool IsLeftMost() const {
    1:     // If the frame's bidi visual state is set, return is-leftmost state
    1:     // else return true if it's the first continuation.
    1:     return (GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET)
 6770:              ? !!(GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_IS_LEFT_MOST)
    1:              : (!GetPrevInFlow());
    1:   }
    1: 
    1:   /**
    1:    * Return true if the frame is rightmost frame or continuation.
    1:    */
    1:   PRBool IsRightMost() const {
    1:     // If the frame's bidi visual state is set, return is-rightmost state
    1:     // else return true if it's the last continuation.
    1:     return (GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET)
 6770:              ? !!(GetStateBits() & NS_INLINE_FRAME_BIDI_VISUAL_IS_RIGHT_MOST)
    1:              : (!GetNextInFlow());
    1:   }
    1: 
    1: protected:
    1:   // Additional reflow state used during our reflow methods
    1:   struct InlineReflowState {
    1:     nsIFrame* mPrevFrame;
    1:     nsInlineFrame* mNextInFlow;
  686:     nsIFrame*      mLineContainer;
    1:     PRPackedBool mSetParentPointer;  // when reflowing child frame first set its
    1:                                      // parent frame pointer
    1: 
    1:     InlineReflowState()  {
    1:       mPrevFrame = nsnull;
    1:       mNextInFlow = nsnull;
  686:       mLineContainer = nsnull;
    1:       mSetParentPointer = PR_FALSE;
  731:     }
    1:   };
    1: 
    1:   nsInlineFrame(nsStyleContext* aContext) : nsInlineFrameSuper(aContext) {}
    1: 
    1:   virtual PRIntn GetSkipSides() const;
    1: 
    1:   nsresult ReflowFrames(nsPresContext* aPresContext,
    1:                         const nsHTMLReflowState& aReflowState,
    1:                         InlineReflowState& rs,
    1:                         nsHTMLReflowMetrics& aMetrics,
    1:                         nsReflowStatus& aStatus);
    1: 
    1:   nsresult ReflowInlineFrame(nsPresContext* aPresContext,
    1:                              const nsHTMLReflowState& aReflowState,
    1:                              InlineReflowState& rs,
    1:                              nsIFrame* aFrame,
    1:                              nsReflowStatus& aStatus);
    1: 
  686:   /**
  686:    * Reparent floats whose placeholders are inline descendants of aFrame from
  686:    * whatever block they're currently parented by to aOurBlock.
  686:    * @param aReparentSiblings if this is true, we follow aFrame's
  686:    * GetNextSibling chain reparenting them all
  686:    */
  686:   void ReparentFloatsForInlineChild(nsIFrame* aOurBlock, nsIFrame* aFrame,
  686:                                     PRBool aReparentSiblings);
  686: 
    1:   virtual nsIFrame* PullOneFrame(nsPresContext* aPresContext,
    1:                                  InlineReflowState& rs,
    1:                                  PRBool* aIsComplete);
    1: 
    1:   virtual void PushFrames(nsPresContext* aPresContext,
    1:                           nsIFrame* aFromChild,
    1:                           nsIFrame* aPrevSibling);
    1: 
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * Variation on inline-frame used to manage lines for line layout in
    1:  * special situations (:first-line style in particular).
    1:  */
    1: class nsFirstLineFrame : public nsInlineFrame {
    1: public:
    1:   friend nsIFrame* NS_NewFirstLineFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
    1: #endif
    1:   virtual nsIAtom* GetType() const;
    1:   NS_IMETHOD Reflow(nsPresContext* aPresContext,
    1:                     nsHTMLReflowMetrics& aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus& aStatus);
    1: 
30638:   virtual void PullOverflowsFromPrevInFlow();
30638: 
    1:   // Take frames starting at aFrame until the end of the frame-list
    1:   // away from this frame. The caller is presumed to keep them alive.
    1:   void StealFramesFrom(nsIFrame* aFrame);
    1: 
    1: protected:
    1:   nsFirstLineFrame(nsStyleContext* aContext) : nsInlineFrame(aContext) {}
    1: 
    1:   virtual nsIFrame* PullOneFrame(nsPresContext* aPresContext,
    1:                                  InlineReflowState& rs,
    1:                                  PRBool* aIsComplete);
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Derived class created for relatively positioned inline-level elements
    1: // that acts as a containing block for child absolutely positioned
    1: // elements
    1: 
    1: class nsPositionedInlineFrame : public nsInlineFrame
    1: {
    1: public:
 4205:   nsPositionedInlineFrame(nsStyleContext* aContext)
 4205:     : nsInlineFrame(aContext)
 4205:     , mAbsoluteContainer(nsGkAtoms::absoluteList)
 4205:   {}
    1: 
    1:   virtual ~nsPositionedInlineFrame() { } // useful for debugging
    1: 
    1:   virtual void Destroy();
    1: 
    1:   NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
    1:                                  nsIFrame*       aChildList);
    1:   NS_IMETHOD AppendFrames(nsIAtom*        aListName,
    1:                           nsIFrame*       aFrameList);
    1:   NS_IMETHOD InsertFrames(nsIAtom*        aListName,
    1:                           nsIFrame*       aPrevFrame,
    1:                           nsIFrame*       aFrameList);
    1:   NS_IMETHOD RemoveFrame(nsIAtom*        aListName,
    1:                          nsIFrame*       aOldFrame);
    1: 
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1: 
    1:   virtual nsIAtom* GetAdditionalChildListName(PRInt32 aIndex) const;
    1: 
    1:   virtual nsIFrame* GetFirstChild(nsIAtom* aListName) const;
    1: 
    1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
    1:                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus&          aStatus);
    1:   
    1:   virtual nsIAtom* GetType() const;
    1: 
 9835:   virtual PRBool NeedsView() { return PR_TRUE; }
 9835: 
    1: protected:
    1:   nsAbsoluteContainingBlock mAbsoluteContainer;
    1: };
    1: 
    1: #endif /* nsInlineFrame_h___ */
