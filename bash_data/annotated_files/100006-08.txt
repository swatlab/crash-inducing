 98180: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98180:  * vim: set ts=8 sw=4 et tw=79:
 98180:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 98180: 
 98180: #ifndef TreeContext_h__
 98180: #define TreeContext_h__
 98180: 
 98180: #include "jstypes.h"
 98180: #include "jsatom.h"
 98180: #include "jsopcode.h"
 98180: #include "jsscript.h"
 98180: #include "jsprvtd.h"
 98180: #include "jspubtd.h"
 98180: 
 98180: #include "frontend/ParseMaps.h"
 98180: 
 98180: #include "vm/ScopeObject.h"
 98180: 
 98180: typedef struct BindData BindData;
 98180: 
 98180: namespace js {
 98180: 
 98687: struct StmtInfo;
 98180: 
 98687: class ContextFlags {
 98687: 
 98687:     // This class's data is all private and so only visible to these friends.
 98798:     friend struct SharedContext;
 98798:     friend struct FunctionBox;
 98180: 
 98180:     // This function/global/eval code body contained a Use Strict Directive.
 98180:     // Treat certain strict warnings as errors, and forbid the use of 'with'.
 99779:     // See also StrictModeGetter, JSScript::strictModeCode,
 99779:     // JSREPORT_STRICT_ERROR, and JSOPTION_STRICT_MODE.
 98180:     //
 98687:     bool            inStrictMode:1;
 98180: 
 98180:     // The (static) bindings of this script need to support dynamic name
 98180:     // read/write access. Here, 'dynamic' means dynamic dictionary lookup on
 98180:     // the scope chain for a dynamic set of keys. The primary examples are:
 98180:     //  - direct eval
 98180:     //  - function::
 98180:     //  - with
 98180:     // since both effectively allow any name to be accessed. Non-exmaples are:
 98180:     //  - upvars of nested functions
 98180:     //  - function statement
 98180:     // since the set of assigned name is known dynamically. 'with' could be in
 98180:     // the non-example category, provided the set of all free variables within
 98180:     // the with block was noted. However, we do not optimize 'with' so, for
 98180:     // simplicity, 'with' is treated like eval.
 98180:     //
 98180:     // Note: access through the arguments object is not considered dynamic
 98180:     // binding access since it does not go through the normal name lookup
 98180:     // mechanism. This is debatable and could be changed (although care must be
 98180:     // taken not to turn off the whole 'arguments' optimization). To answer the
 98180:     // more general "is this argument aliased" question, script->needsArgsObj
 98180:     // should be tested (see JSScript::argIsAlised).
 98687:     //
 98687:     bool            bindingsAccessedDynamically:1;
 98687: 
 98687:     // The |fun*| flags are only relevant if |inFunction| is true.  Due to
 98687:     // sloppiness, however, some are set in cases where |inFunction| is
 98687:     // false.
 98687: 
 98687:     // The function needs Call object per call.
 98687:     bool            funIsHeavyweight:1;
 98687: 
 98687:     // We parsed a yield statement in the function.
 98687:     bool            funIsGenerator:1;
 98180: 
 98180:     // The function or a function that encloses it may define new local names
 98180:     // at runtime through means other than calling eval.
 98687:     bool            funMightAliasLocals:1;
 98180: 
 98180:     // This function does something that can extend the set of bindings in its
 98180:     // call objects --- it does a direct eval in non-strict code, or includes a
 98180:     // function statement (as opposed to a function definition).
 98180:     //
 98180:     // This flag is *not* inherited by enclosed or enclosing functions; it
 98180:     // applies only to the function in whose flags it appears.
 98180:     //
 98687:     bool            funHasExtensibleScope:1;
 98180: 
 98180:     // Technically, every function has a binding named 'arguments'. Internally,
 98180:     // this binding is only added when 'arguments' is mentioned by the function
 98180:     // body. This flag indicates whether 'arguments' has been bound either
 98180:     // through implicit use:
 98180:     //   function f() { return arguments }
 98180:     // or explicit redeclaration:
 98180:     //   function f() { var arguments; return arguments }
 98180:     //
 98180:     // Note 1: overwritten arguments (function() { arguments = 3 }) will cause
 98180:     // this flag to be set but otherwise require no special handling:
 98180:     // 'arguments' is just a local variable and uses of 'arguments' will just
 98180:     // read the local's current slot which may have been assigned. The only
 98180:     // special semantics is that the initial value of 'arguments' is the
 98180:     // arguments object (not undefined, like normal locals).
 98180:     //
 98180:     // Note 2: if 'arguments' is bound as a formal parameter, there will be an
 98180:     // 'arguments' in Bindings, but, as the "LOCAL" in the name indicates, this
 98180:     // flag will not be set. This is because, as a formal, 'arguments' will
 98180:     // have no special semantics: the initial value is unconditionally the
 98180:     // actual argument (or undefined if nactual < nformal).
 98180:     //
 98687:     bool            funArgumentsHasLocalBinding:1;
 98180: 
 98180:     // In many cases where 'arguments' has a local binding (as described above)
 98180:     // we do not need to actually create an arguments object in the function
 98180:     // prologue: instead we can analyze how 'arguments' is used (using the
 98180:     // simple dataflow analysis in analyzeSSA) to determine that uses of
 98180:     // 'arguments' can just read from the stack frame directly. However, the
 98180:     // dataflow analysis only looks at how JSOP_ARGUMENTS is used, so it will
 98180:     // be unsound in several cases. The frontend filters out such cases by
 98180:     // setting this flag which eagerly sets script->needsArgsObj to true.
 98180:     //
 98687:     bool            funDefinitelyNeedsArgsObj:1;
 98180: 
 98687:   public:
 98687:     ContextFlags(JSContext *cx)
 98687:       : inStrictMode(cx->hasRunOption(JSOPTION_STRICT_MODE)),
 98687:         bindingsAccessedDynamically(false),
 98687:         funIsHeavyweight(false),
 98687:         funIsGenerator(false),
 98687:         funMightAliasLocals(false),
 98687:         funHasExtensibleScope(false),
 98687:         funArgumentsHasLocalBinding(false),
 98687:         funDefinitelyNeedsArgsObj(false)
 98687:     { }
 98687: };
 98180: 
 98445: struct SharedContext {
 98181:     JSContext       *context;
 98181: 
 98180:     uint32_t        bodyid;         /* block number of program/function body */
 98180:     uint32_t        blockidGen;     /* preincremented block number generator */
 98445: 
 98180:     StmtInfo        *topStmt;       /* top of statement info stack */
 98180:     StmtInfo        *topScopeStmt;  /* top lexical scope statement */
 99421:     Rooted<StaticBlockObject *> blockChain;
100006:                                     /* compile time block scope chain (NB: one
100006:                                        deeper than the topScopeStmt/downScope
100006:                                        chain when in head of let block/expr) */
 98180: 
 98180:   private:
 99421:     RootedFunction  fun_;           /* function to store argument and variable
 98476:                                        names when inFunction is set */
 99421:     RootedObject    scopeChain_;    /* scope chain object for the script */
 98180: 
 98180:   public:
 98445:     unsigned        staticLevel;    /* static compilation unit nesting level */
 98445: 
 98445:     FunctionBox     *funbox;        /* null or box for function we're compiling
 98476:                                        if inFunction is set and not in
 98445:                                        js::frontend::CompileFunctionBody */
 98445:     FunctionBox     *functionList;
 98445: 
 98445:     Bindings        bindings;       /* bindings in this code, including
 98445:                                        arguments if we're compiling a function */
 99364:     Bindings::AutoRooter bindingsRoot; /* root for stack allocated bindings. */
 98445: 
 98477:     const bool      inFunction:1;   /* parsing/emitting inside function body */
 98477: 
 98477:     bool            inForInit:1;    /* parsing/emitting init expr of for; exclude 'in' */
 98445: 
 98687:     ContextFlags    cxFlags;
 98687: 
 98476:     inline SharedContext(JSContext *cx, bool inFunction);
 98476: 
 98687:     bool inStrictMode()                const { return cxFlags.inStrictMode; }
 98687:     bool bindingsAccessedDynamically() const { return cxFlags.bindingsAccessedDynamically; }
 98687:     bool funIsHeavyweight()            const { return cxFlags.funIsHeavyweight; }
 98687:     bool funIsGenerator()              const { return cxFlags.funIsGenerator; }
 98687:     bool funMightAliasLocals()         const { return cxFlags.funMightAliasLocals; }
 98687:     bool funHasExtensibleScope()       const { return cxFlags.funHasExtensibleScope; }
 98687:     bool funArgumentsHasLocalBinding() const { return cxFlags.funArgumentsHasLocalBinding; }
 98687:     bool funDefinitelyNeedsArgsObj()   const { return cxFlags.funDefinitelyNeedsArgsObj; }
 98445: 
 98687:     void setInStrictMode()                  { cxFlags.inStrictMode                = true; }
 98687:     void setBindingsAccessedDynamically()   { cxFlags.bindingsAccessedDynamically = true; }
 98687:     void setFunIsHeavyweight()              { cxFlags.funIsHeavyweight            = true; }
 98687:     void setFunIsGenerator()                { cxFlags.funIsGenerator              = true; }
 98687:     void setFunMightAliasLocals()           { cxFlags.funMightAliasLocals         = true; }
 98687:     void setFunHasExtensibleScope()         { cxFlags.funHasExtensibleScope       = true; }
 98687:     void setFunArgumentsHasLocalBinding()   { cxFlags.funArgumentsHasLocalBinding = true; }
 98687:     void setFunDefinitelyNeedsArgsObj()     { JS_ASSERT(cxFlags.funArgumentsHasLocalBinding);
 98687:                                               cxFlags.funDefinitelyNeedsArgsObj   = true; }
 98445: 
100006:     unsigned argumentsLocalSlot() const;
 98445: 
 98180:     JSFunction *fun() const {
 98476:         JS_ASSERT(inFunction);
 98180:         return fun_;
 98180:     }
 98180:     void setFunction(JSFunction *fun) {
 98476:         JS_ASSERT(inFunction);
 98180:         fun_ = fun;
 98180:     }
 98180:     JSObject *scopeChain() const {
 98476:         JS_ASSERT(!inFunction);
 98180:         return scopeChain_;
 98180:     }
 98180:     void setScopeChain(JSObject *scopeChain) {
 98476:         JS_ASSERT(!inFunction);
 98180:         scopeChain_ = scopeChain;
 98180:     }
 98180: 
 98180:     unsigned blockid();
 98180: 
 98180:     // True if we are at the topmost level of a entire script or function body.
 98180:     // For example, while parsing this code we would encounter f1 and f2 at
 98180:     // body level, but we would not encounter f3 or f4 at body level:
 98180:     //
 98180:     //   function f1() { function f2() { } }
 98180:     //   if (cond) { function f3() { if (cond) { function f4() { } } } }
 98180:     //
 98180:     bool atBodyLevel();
 98180: 
 98180:     // Return true if we need to check for conditions that elicit
 98180:     // JSOPTION_STRICT warnings or strict mode errors.
 98180:     inline bool needStrictChecks();
 98445: };
 98180: 
 98445: typedef HashSet<JSAtom *> FuncStmtSet;
 98445: struct Parser;
 98180: 
 98445: struct TreeContext {                /* tree context for semantic checks */
 98445:     SharedContext   *sc;            /* context shared between parsing and bytecode generation */
 98180: 
 98445:     uint32_t        parenDepth;     /* nesting depth of parens that might turn out
 98445:                                        to be generator expressions */
 98445:     uint32_t        yieldCount;     /* number of |yield| tokens encountered at
 98445:                                        non-zero depth in current paren tree */
 98445:     ParseNode       *blockNode;     /* parse node for a block with let declarations
 98445:                                        (block with its own lexical scope)  */
 98445:     AtomDecls       decls;          /* function, const, and var declarations */
 98445:     ParseNode       *yieldNode;     /* parse node for a yield expression that might
 98445:                                        be an error if we turn out to be inside a
 98445:                                        generator expression */
 98180: 
 98445:   private:
 98445:     TreeContext     **parserTC;     /* this points to the Parser's active tc
 98445:                                        and holds either |this| or one of
 98445:                                        |this|'s descendents */
 98180: 
 98445:   public:
 98445:     OwnedAtomDefnMapPtr lexdeps;    /* unresolved lexical name dependencies */
 98180: 
 98445:     TreeContext     *parent;        /* Enclosing function or global context.  */
 98180: 
 98445:     ParseNode       *innermostWith; /* innermost WITH parse node */
 98180: 
 98445:     FuncStmtSet     *funcStmts;     /* Set of (non-top-level) function statements
 98445:                                        that will alias any top-level bindings with
 98445:                                        the same name. */
 98180: 
 98451:     /*
 98451:      * Flags that are set for a short time during parsing to indicate context
 98451:      * or the presence of a code feature.
 98451:      */
 98451:     bool            hasReturnExpr:1; /* function has 'return <expr>;' */
 98451:     bool            hasReturnVoid:1; /* function has 'return;' */
 98451: 
 98453:     // Set when parsing a declaration-like destructuring pattern.  This flag
 98453:     // causes PrimaryExpr to create PN_NAME parse nodes for variable references
 98453:     // which are not hooked into any definition's use chain, added to any tree
 98453:     // context's AtomList, etc. etc.  CheckDestructuring will do that work
 98453:     // later.
 98453:     //
 98453:     // The comments atop CheckDestructuring explain the distinction between
 98453:     // assignment-like and declaration-like destructuring patterns, and why
 98453:     // they need to be treated differently.
 98453:     bool            inDeclDestructuring:1;
 98453: 
 98445:     void trace(JSTracer *trc);
 98180: 
 98445:     inline TreeContext(Parser *prs, SharedContext *sc);
 98445:     inline ~TreeContext();
 98180: 
 99147:     inline bool init();
 98180: };
 98180: 
 98180: /*
 98180:  * NB: If you add enumerators for scope statements, add them between STMT_WITH
 98180:  * and STMT_CATCH, or you will break the STMT_TYPE_IS_SCOPE macro. If you add
 98180:  * non-looping statement enumerators, add them before STMT_DO_LOOP or you will
 98180:  * break the STMT_TYPE_IS_LOOP macro.
 98180:  *
 98180:  * Also remember to keep the statementName array in BytecodeEmitter.cpp in
 98180:  * sync.
 98180:  */
 98180: enum StmtType {
 98180:     STMT_LABEL,                 /* labeled statement:  L: s */
 98180:     STMT_IF,                    /* if (then) statement */
 98180:     STMT_ELSE,                  /* else clause of if statement */
 98180:     STMT_SEQ,                   /* synthetic sequence of statements */
 98180:     STMT_BLOCK,                 /* compound statement: { s1[;... sN] } */
 98180:     STMT_SWITCH,                /* switch statement */
 98180:     STMT_WITH,                  /* with statement */
 98180:     STMT_CATCH,                 /* catch block */
 98180:     STMT_TRY,                   /* try block */
 98180:     STMT_FINALLY,               /* finally block */
 98180:     STMT_SUBROUTINE,            /* gosub-target subroutine body */
 98180:     STMT_DO_LOOP,               /* do/while loop statement */
 98180:     STMT_FOR_LOOP,              /* for loop statement */
 98180:     STMT_FOR_IN_LOOP,           /* for/in loop statement */
 98180:     STMT_WHILE_LOOP,            /* while loop statement */
 98180:     STMT_LIMIT
 98180: };
 98180: 
 98180: inline bool
 98180: STMT_TYPE_IN_RANGE(uint16_t type, StmtType begin, StmtType end)
 98180: {
 98180:     return begin <= type && type <= end;
 98180: }
 98180: 
 98180: /*
 98180:  * A comment on the encoding of the js::StmtType enum and type-testing macros:
 98180:  *
 98180:  * STMT_TYPE_MAYBE_SCOPE tells whether a statement type is always, or may
 98180:  * become, a lexical scope.  It therefore includes block and switch (the two
 98180:  * low-numbered "maybe" scope types) and excludes with (with has dynamic scope
 98180:  * pending the "reformed with" in ES4/JS2).  It includes all try-catch-finally
 98180:  * types, which are high-numbered maybe-scope types.
 98180:  *
 98180:  * STMT_TYPE_LINKS_SCOPE tells whether a js::StmtInfo of the given type eagerly
 98180:  * links to other scoping statement info records.  It excludes the two early
 98180:  * "maybe" types, block and switch, as well as the try and both finally types,
 98180:  * since try and the other trailing maybe-scope types don't need block scope
 98180:  * unless they contain let declarations.
 98180:  *
 98180:  * We treat WITH as a static scope because it prevents lexical binding from
 98180:  * continuing further up the static scope chain. With the lost "reformed with"
 98180:  * proposal for ES4, we would be able to model it statically, too.
 98180:  */
 98180: #define STMT_TYPE_MAYBE_SCOPE(type)                                           \
 98180:     (type != STMT_WITH &&                                                     \
 98180:      STMT_TYPE_IN_RANGE(type, STMT_BLOCK, STMT_SUBROUTINE))
 98180: 
 98180: #define STMT_TYPE_LINKS_SCOPE(type)                                           \
 98180:     STMT_TYPE_IN_RANGE(type, STMT_WITH, STMT_CATCH)
 98180: 
 98180: #define STMT_TYPE_IS_TRYING(type)                                             \
 98180:     STMT_TYPE_IN_RANGE(type, STMT_TRY, STMT_SUBROUTINE)
 98180: 
 98180: #define STMT_TYPE_IS_LOOP(type) ((type) >= STMT_DO_LOOP)
 98180: 
 98180: #define STMT_MAYBE_SCOPE(stmt)  STMT_TYPE_MAYBE_SCOPE((stmt)->type)
 98180: #define STMT_LINKS_SCOPE(stmt)  (STMT_TYPE_LINKS_SCOPE((stmt)->type) ||       \
 98180:                                  ((stmt)->flags & SIF_SCOPE))
 98180: #define STMT_IS_TRYING(stmt)    STMT_TYPE_IS_TRYING((stmt)->type)
 98180: #define STMT_IS_LOOP(stmt)      STMT_TYPE_IS_LOOP((stmt)->type)
 98180: 
 98180: struct StmtInfo {
 98180:     uint16_t        type;           /* statement type */
 98180:     uint16_t        flags;          /* flags, see below */
 98180:     uint32_t        blockid;        /* for simplified dominance computation */
 98180:     ptrdiff_t       update;         /* loop update offset (top if none) */
 98180:     ptrdiff_t       breaks;         /* offset of last break in loop */
 98180:     ptrdiff_t       continues;      /* offset of last continue in loop */
 99421:     RootedAtom      label;          /* name of LABEL */
 99421:     Rooted<StaticBlockObject *> blockObj; /* block scope object */
 98180:     StmtInfo        *down;          /* info for enclosing statement */
 98180:     StmtInfo        *downScope;     /* next enclosing lexical scope */
 98180: 
 98180:     StmtInfo(JSContext *cx) : label(cx), blockObj(cx) {}
 98180: };
 98180: 
 98180: #define SIF_SCOPE        0x0001     /* statement has its own lexical scope */
 98180: #define SIF_BODY_BLOCK   0x0002     /* STMT_BLOCK type is a function body */
 98180: #define SIF_FOR_BLOCK    0x0004     /* for (let ...) induced block scope */
 98180: 
 98180: #define SET_STATEMENT_TOP(stmt, top)                                          \
 98180:     ((stmt)->update = (top), (stmt)->breaks = (stmt)->continues = (-1))
 98180: 
 98180: namespace frontend {
 98180: 
 98180: bool
 98445: SetStaticLevel(SharedContext *sc, unsigned staticLevel);
 98180: 
 98180: bool
 98445: GenerateBlockId(SharedContext *sc, uint32_t &blockid);
 98180: 
 98180: /*
 98180:  * Push the C-stack-allocated struct at stmt onto the stmtInfo stack.
 98180:  */
 98180: void
 98445: PushStatement(SharedContext *sc, StmtInfo *stmt, StmtType type, ptrdiff_t top);
 98180: 
 98180: /*
 98445:  * Push a block scope statement and link blockObj into sc->blockChain. To pop
 98180:  * this statement info record, use PopStatementTC as usual, or if appropriate
 98180:  * (if generating code), PopStatementBCE.
 98180:  */
 98180: void
 98445: PushBlockScope(SharedContext *sc, StmtInfo *stmt, StaticBlockObject &blockObj, ptrdiff_t top);
 98180: 
 98180: /*
 98445:  * Pop sc->topStmt. If the top StmtInfo struct is not stack-allocated, it
 98180:  * is up to the caller to free it.
 98180:  */
 98180: void
 98445: PopStatementSC(SharedContext *sc);
 98180: 
 98180: /*
 98180:  * Find a lexically scoped variable (one declared by let, catch, or an array
 98445:  * comprehension) named by atom, looking in sc's compile-time scopes.
 98180:  *
 98180:  * If a WITH statement is reached along the scope stack, return its statement
 98180:  * info record, so callers can tell that atom is ambiguous. If slotp is not
 98180:  * null, then if atom is found, set *slotp to its stack slot, otherwise to -1.
 98180:  * This means that if slotp is not null, all the block objects on the lexical
 98180:  * scope chain must have had their depth slots computed by the code generator,
 98180:  * so the caller must be under EmitTree.
 98180:  *
 98180:  * In any event, directly return the statement info record in which atom was
 98180:  * found. Otherwise return null.
 98180:  */
 98180: StmtInfo *
 98445: LexicalLookup(SharedContext *sc, JSAtom *atom, int *slotp, StmtInfo *stmt = NULL);
 98180: 
 98180: } // namespace frontend
 98180: 
 98180: } // namespace js
 98180: 
 98180: #endif // TreeContext_h__
