    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* representation of one line within a block frame, a CSS line box */
    1: 
    1: #include "nsLineBox.h"
    1: #include "nsLineLayout.h"
    1: #include "prprf.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsFrameManager.h"
    1: #ifdef IBMBIDI
    1: #include "nsBidiPresUtils.h"
    1: #endif
    1: 
    1: #ifdef DEBUG
    1: static PRInt32 ctorCount;
    1: PRInt32 nsLineBox::GetCtorCount() { return ctorCount; }
    1: #endif
    1: 
79445: nsLineBox::nsLineBox(nsIFrame* aFrame, PRInt32 aCount, bool aIsBlock)
    1:   : mFirstChild(aFrame),
    1:     mBounds(0, 0, 0, 0),
27983:     mAscent(0),
    1:     mData(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsLineBox);
    1: #ifdef DEBUG
    1:   ++ctorCount;
    1:   NS_ASSERTION(!aIsBlock || aCount == 1, "Blocks must have exactly one child");
    1:   nsIFrame* f = aFrame;
    1:   for (PRInt32 n = aCount; n > 0; f = f->GetNextSibling(), --n) {
 2829:     NS_ASSERTION(aIsBlock == f->GetStyleDisplay()->IsBlockOutside(),
    1:                  "wrong kind of child frame");
    1:   }
    1: #endif
    1: 
    1:   mAllFlags = 0;
    1: #if NS_STYLE_CLEAR_NONE > 0
    1:   mFlags.mBreakType = NS_STYLE_CLEAR_NONE;
    1: #endif
    1:   SetChildCount(aCount);
    1:   MarkDirty();
    1:   mFlags.mBlock = aIsBlock;
    1: }
    1: 
    1: nsLineBox::~nsLineBox()
    1: {
    1:   MOZ_COUNT_DTOR(nsLineBox);
    1:   Cleanup();
    1: }
    1: 
    1: nsLineBox*
    1: NS_NewLineBox(nsIPresShell* aPresShell, nsIFrame* aFrame,
79445:               PRInt32 aCount, bool aIsBlock)
    1: {
    1:   return new (aPresShell)nsLineBox(aFrame, aCount, aIsBlock);
    1: }
    1: 
    1: // Overloaded new operator. Uses an arena (which comes from the presShell)
    1: // to perform the allocation.
    1: void*
    1: nsLineBox::operator new(size_t sz, nsIPresShell* aPresShell) CPP_THROW_NEW
    1: {
31620:   return aPresShell->AllocateMisc(sz);
    1: }
    1: 
    1: // Overloaded delete operator. Doesn't actually free the memory, because we
    1: // use an arena
    1: void
    1: nsLineBox::operator delete(void* aPtr, size_t sz)
    1: {
    1: }
    1: 
    1: void
    1: nsLineBox::Destroy(nsIPresShell* aPresShell)
    1: {
    1:   // Destroy the object. This won't actually free the memory, though
    1:   delete this;
    1: 
    1:   // Have the pres shell recycle the memory
31620:   aPresShell->FreeMisc(sizeof(*this), (void*)this);
    1: }
    1: 
    1: void
    1: nsLineBox::Cleanup()
    1: {
    1:   if (mData) {
    1:     if (IsBlock()) {
    1:       delete mBlockData;
    1:     }
    1:     else {
    1:       delete mInlineData;
    1:     }
    1:     mData = nsnull;
    1:   }
    1: }
    1: 
    1: #ifdef DEBUG
    1: static void
    1: ListFloats(FILE* out, PRInt32 aIndent, const nsFloatCacheList& aFloats)
    1: {
    1:   nsFloatCache* fc = aFloats.Head();
    1:   while (fc) {
    1:     nsFrame::IndentBy(out, aIndent);
32107:     nsIFrame* frame = fc->mFloat;
32107:     fprintf(out, "floatframe@%p ", static_cast<void*>(frame));
 3744:     if (frame) {
31709:       nsAutoString frameName;
31709:       frame->GetFrameName(frameName);
    1:       fputs(NS_LossyConvertUTF16toASCII(frameName).get(), out);
    1:     }
32107:     else {
 3744:       fputs("\n###!!! NULL out-of-flow frame", out);
 3744:     }
    1:     fprintf(out, "\n");
    1:     fc = fc->Next();
    1:   }
    1: }
    1: #endif
    1: 
    1: #ifdef DEBUG
    1: const char *
    1: BreakTypeToString(PRUint8 aBreakType)
    1: {
    1:   switch (aBreakType) {
    1:   case NS_STYLE_CLEAR_NONE: return "nobr";
    1:   case NS_STYLE_CLEAR_LEFT: return "leftbr";
    1:   case NS_STYLE_CLEAR_RIGHT: return "rightbr";
    1:   case NS_STYLE_CLEAR_LEFT_AND_RIGHT: return "leftbr+rightbr";
    1:   case NS_STYLE_CLEAR_LINE: return "linebr";
    1:   case NS_STYLE_CLEAR_BLOCK: return "blockbr";
    1:   case NS_STYLE_CLEAR_COLUMN: return "columnbr";
    1:   case NS_STYLE_CLEAR_PAGE: return "pagebr";
    1:   default:
    1:     break;
    1:   }
    1:   return "unknown";
    1: }
    1: 
    1: char*
    1: nsLineBox::StateToString(char* aBuf, PRInt32 aBufSize) const
    1: {
    1:   PR_snprintf(aBuf, aBufSize, "%s,%s,%s,%s,%s,before:%s,after:%s[0x%x]",
    1:               IsBlock() ? "block" : "inline",
    1:               IsDirty() ? "dirty" : "clean",
    1:               IsPreviousMarginDirty() ? "prevmargindirty" : "prevmarginclean",
    1:               IsImpactedByFloat() ? "impacted" : "not impacted",
    1:               IsLineWrapped() ? "wrapped" : "not wrapped",
    1:               BreakTypeToString(GetBreakTypeBefore()),
    1:               BreakTypeToString(GetBreakTypeAfter()),
    1:               mAllFlags);
    1:   return aBuf;
    1: }
    1: 
    1: void
    1: nsLineBox::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   PRInt32 i;
    1: 
    1:   for (i = aIndent; --i >= 0; ) fputs("  ", out);
    1:   char cbuf[100];
    1:   fprintf(out, "line %p: count=%d state=%s ",
 3233:           static_cast<const void*>(this), GetChildCount(),
    1:           StateToString(cbuf, sizeof(cbuf)));
    1:   if (IsBlock() && !GetCarriedOutBottomMargin().IsZero()) {
    1:     fprintf(out, "bm=%d ", GetCarriedOutBottomMargin().get());
    1:   }
    1:   fprintf(out, "{%d,%d,%d,%d} ",
    1:           mBounds.x, mBounds.y, mBounds.width, mBounds.height);
    1:   if (mData) {
55026:     fprintf(out, "vis-overflow={%d,%d,%d,%d} scr-overflow={%d,%d,%d,%d} ",
55026:             mData->mOverflowAreas.VisualOverflow().x,
55026:             mData->mOverflowAreas.VisualOverflow().y,
55026:             mData->mOverflowAreas.VisualOverflow().width,
55026:             mData->mOverflowAreas.VisualOverflow().height,
55026:             mData->mOverflowAreas.ScrollableOverflow().x,
55026:             mData->mOverflowAreas.ScrollableOverflow().y,
55026:             mData->mOverflowAreas.ScrollableOverflow().width,
55026:             mData->mOverflowAreas.ScrollableOverflow().height);
    1:   }
    1:   fprintf(out, "<\n");
    1: 
    1:   nsIFrame* frame = mFirstChild;
    1:   PRInt32 n = GetChildCount();
    1:   while (--n >= 0) {
31709:     frame->List(out, aIndent + 1);
    1:     frame = frame->GetNextSibling();
    1:   }
    1: 
    1:   for (i = aIndent; --i >= 0; ) fputs("  ", out);
    1:   if (HasFloats()) {
    1:     fputs("> floats <\n", out);
    1:     ListFloats(out, aIndent + 1, mInlineData->mFloats);
    1:     for (i = aIndent; --i >= 0; ) fputs("  ", out);
    1:   }
    1:   fputs(">\n", out);
    1: }
    1: #endif
    1: 
    1: nsIFrame*
    1: nsLineBox::LastChild() const
    1: {
    1:   nsIFrame* frame = mFirstChild;
    1:   PRInt32 n = GetChildCount() - 1;
    1:   while (--n >= 0) {
    1:     frame = frame->GetNextSibling();
    1:   }
    1:   return frame;
    1: }
    1: 
79445: bool
    1: nsLineBox::IsLastChild(nsIFrame* aFrame) const
    1: {
    1:   nsIFrame* lastFrame = LastChild();
    1:   return aFrame == lastFrame;
    1: }
    1: 
    1: PRInt32
    1: nsLineBox::IndexOf(nsIFrame* aFrame) const
    1: {
    1:   PRInt32 i, n = GetChildCount();
    1:   nsIFrame* frame = mFirstChild;
    1:   for (i = 0; i < n; i++) {
    1:     if (frame == aFrame) {
    1:       return i;
    1:     }
    1:     frame = frame->GetNextSibling();
    1:   }
    1:   return -1;
    1: }
    1: 
79445: bool
    1: nsLineBox::IsEmpty() const
    1: {
    1:   if (IsBlock())
    1:     return mFirstChild->IsEmpty();
    1: 
    1:   PRInt32 n;
    1:   nsIFrame *kid;
    1:   for (n = GetChildCount(), kid = mFirstChild;
    1:        n > 0;
    1:        --n, kid = kid->GetNextSibling())
    1:   {
    1:     if (!kid->IsEmpty())
    1:       return PR_FALSE;
    1:   }
31327:   if (HasBullet()) {
31327:     return PR_FALSE;
31327:   }
    1:   return PR_TRUE;
    1: }
    1: 
79445: bool
81519: nsLineBox::CachedIsEmpty()
    1: {
    1:   if (mFlags.mDirty) {
    1:     return IsEmpty();
    1:   }
    1:   
    1:   if (mFlags.mEmptyCacheValid) {
    1:     return mFlags.mEmptyCacheState;
    1:   }
    1: 
79445:   bool result;
    1:   if (IsBlock()) {
    1:     result = mFirstChild->CachedIsEmpty();
    1:   } else {
    1:     PRInt32 n;
    1:     nsIFrame *kid;
    1:     result = PR_TRUE;
    1:     for (n = GetChildCount(), kid = mFirstChild;
    1:          n > 0;
    1:          --n, kid = kid->GetNextSibling())
    1:       {
    1:         if (!kid->CachedIsEmpty()) {
    1:           result = PR_FALSE;
    1:           break;
    1:         }
    1:       }
31327:     if (HasBullet()) {
31327:       result = PR_FALSE;
31327:     }
    1:   }
    1: 
    1:   mFlags.mEmptyCacheValid = PR_TRUE;
    1:   mFlags.mEmptyCacheState = result;
    1:   return result;
    1: }
    1: 
    1: void
36647: nsLineBox::DeleteLineList(nsPresContext* aPresContext, nsLineList& aLines,
36647:                           nsIFrame* aDestructRoot)
    1: {
    1:   if (! aLines.empty()) {
    1:     // Delete our child frames before doing anything else. In particular
    1:     // we do all of this before our base class releases it's hold on the
    1:     // view.
32385: #ifdef DEBUG
32385:     PRInt32 numFrames = 0;
32385: #endif
    1:     for (nsIFrame* child = aLines.front()->mFirstChild; child; ) {
    1:       nsIFrame* nextChild = child->GetNextSibling();
36646:       child->SetNextSibling(nsnull);
36647:       child->DestroyFrom((aDestructRoot) ? aDestructRoot : child);
    1:       child = nextChild;
32385: #ifdef DEBUG
32385:       numFrames++;
32385: #endif
    1:     }
    1: 
    1:     nsIPresShell *shell = aPresContext->PresShell();
    1: 
    1:     do {
    1:       nsLineBox* line = aLines.front();
32385: #ifdef DEBUG
32385:       numFrames -= line->GetChildCount();
32385: #endif
    1:       aLines.pop_front();
    1:       line->Destroy(shell);
    1:     } while (! aLines.empty());
32385: #ifdef DEBUG
32385:     NS_ASSERTION(numFrames == 0, "number of frames deleted does not match");
32385: #endif
    1:   }
    1: }
    1: 
79445: bool
    1: nsLineBox::RFindLineContaining(nsIFrame* aFrame,
    1:                                const nsLineList::iterator& aBegin,
    1:                                nsLineList::iterator& aEnd,
33389:                                nsIFrame* aLastFrameBeforeEnd,
    1:                                PRInt32* aFrameIndexInLine)
    1: {
    1:   NS_PRECONDITION(aFrame, "null ptr");
33389:   nsIFrame* curFrame = aLastFrameBeforeEnd;
    1:   while (aBegin != aEnd) {
    1:     --aEnd;
33389:     NS_ASSERTION(aEnd->IsLastChild(curFrame), "Unexpected curFrame");
33389:     // i is the index of curFrame in aEnd
33389:     PRInt32 i = aEnd->GetChildCount() - 1;
33389:     while (i >= 0) {
33389:       if (curFrame == aFrame) {
33389:         *aFrameIndexInLine = i;
    1:         return PR_TRUE;
    1:       }
33389:       --i;
33389:       curFrame = curFrame->GetPrevSibling();
33389:     }
    1:   }
    1:   *aFrameIndexInLine = -1;
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsCollapsingMargin
    1: nsLineBox::GetCarriedOutBottomMargin() const
    1: {
    1:   NS_ASSERTION(IsBlock(),
    1:                "GetCarriedOutBottomMargin called on non-block line.");
    1:   return (IsBlock() && mBlockData)
    1:     ? mBlockData->mCarriedOutBottomMargin
    1:     : nsCollapsingMargin();
    1: }
    1: 
79445: bool
    1: nsLineBox::SetCarriedOutBottomMargin(nsCollapsingMargin aValue)
    1: {
79445:   bool changed = false;
    1:   if (IsBlock()) {
    1:     if (!aValue.IsZero()) {
    1:       if (!mBlockData) {
    1:         mBlockData = new ExtraBlockData(mBounds);
    1:       }
    1:       changed = aValue != mBlockData->mCarriedOutBottomMargin;
    1:       mBlockData->mCarriedOutBottomMargin = aValue;
    1:     }
    1:     else if (mBlockData) {
    1:       changed = aValue != mBlockData->mCarriedOutBottomMargin;
    1:       mBlockData->mCarriedOutBottomMargin = aValue;
    1:       MaybeFreeData();
    1:     }
    1:   }
    1:   return changed;
    1: }
    1: 
    1: void
    1: nsLineBox::MaybeFreeData()
    1: {
55026:   if (mData && mData->mOverflowAreas == nsOverflowAreas(mBounds, mBounds)) {
    1:     if (IsInline()) {
    1:       if (mInlineData->mFloats.IsEmpty()) {
    1:         delete mInlineData;
    1:         mInlineData = nsnull;
    1:       }
    1:     }
    1:     else if (mBlockData->mCarriedOutBottomMargin.IsZero()) {
    1:       delete mBlockData;
    1:       mBlockData = nsnull;
    1:     }
    1:   }
    1: }
    1: 
    1: // XXX get rid of this???
    1: nsFloatCache*
    1: nsLineBox::GetFirstFloat()
    1: {
    1:   NS_ABORT_IF_FALSE(IsInline(), "block line can't have floats");
    1:   return mInlineData ? mInlineData->mFloats.Head() : nsnull;
    1: }
    1: 
    1: // XXX this might be too eager to free memory
    1: void
    1: nsLineBox::FreeFloats(nsFloatCacheFreeList& aFreeList)
    1: {
    1:   NS_ABORT_IF_FALSE(IsInline(), "block line can't have floats");
    1:   if (IsInline() && mInlineData) {
    1:     if (mInlineData->mFloats.NotEmpty()) {
    1:       aFreeList.Append(mInlineData->mFloats);
    1:     }
    1:     MaybeFreeData();
    1:   }
    1: }
    1: 
    1: void
    1: nsLineBox::AppendFloats(nsFloatCacheFreeList& aFreeList)
    1: { 
    1:   NS_ABORT_IF_FALSE(IsInline(), "block line can't have floats");
    1:   if (IsInline()) {
    1:     if (aFreeList.NotEmpty()) {
    1:       if (!mInlineData) {
    1:         mInlineData = new ExtraInlineData(mBounds);
    1:       }
    1:       mInlineData->mFloats.Append(aFreeList);
    1:     }
    1:   }
    1: }
    1: 
79445: bool
    1: nsLineBox::RemoveFloat(nsIFrame* aFrame)
    1: {
    1:   NS_ABORT_IF_FALSE(IsInline(), "block line can't have floats");
    1:   if (IsInline() && mInlineData) {
    1:     nsFloatCache* fc = mInlineData->mFloats.Find(aFrame);
    1:     if (fc) {
    1:       // Note: the placeholder is part of the line's child list
    1:       // and will be removed later.
    1:       mInlineData->mFloats.Remove(fc);
    1:       delete fc;
    1:       MaybeFreeData();
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
55026: nsLineBox::SetOverflowAreas(const nsOverflowAreas& aOverflowAreas)
    1: {
55026:   NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
55026:     NS_ASSERTION(aOverflowAreas.Overflow(otype).width >= 0,
55026:                  "illegal width for combined area");
55026:     NS_ASSERTION(aOverflowAreas.Overflow(otype).height >= 0,
55026:                  "illegal height for combined area");
55026:   }
68638:   if (!aOverflowAreas.VisualOverflow().IsEqualInterior(mBounds) ||
68638:       !aOverflowAreas.ScrollableOverflow().IsEqualEdges(mBounds)) {
55026:     if (!mData) {
55026:       if (IsInline()) {
55026:         mInlineData = new ExtraInlineData(mBounds);
    1:       }
    1:       else {
55026:         mBlockData = new ExtraBlockData(mBounds);
    1:       }
    1:     }
55026:     mData->mOverflowAreas = aOverflowAreas;
    1:   }
55026:   else if (mData) {
    1:     // Store away new value so that MaybeFreeData compares against
    1:     // the right value.
55026:     mData->mOverflowAreas = aOverflowAreas;
    1:     MaybeFreeData();
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: 
    1: static nsLineBox* gDummyLines[1];
    1: 
    1: nsLineIterator::nsLineIterator()
    1: {
    1:   mLines = gDummyLines;
    1:   mNumLines = 0;
    1:   mIndex = 0;
    1:   mRightToLeft = PR_FALSE;
    1: }
    1: 
    1: nsLineIterator::~nsLineIterator()
    1: {
    1:   if (mLines != gDummyLines) {
    1:     delete [] mLines;
    1:   }
    1: }
    1: 
21112: /* virtual */ void
21112: nsLineIterator::DisposeLineIterator()
21112: {
21112:   delete this;
21112: }
    1: 
    1: nsresult
79445: nsLineIterator::Init(nsLineList& aLines, bool aRightToLeft)
    1: {
    1:   mRightToLeft = aRightToLeft;
    1: 
    1:   // Count the lines
    1:   PRInt32 numLines = aLines.size();
    1:   if (0 == numLines) {
    1:     // Use gDummyLines so that we don't need null pointer checks in
    1:     // the accessor methods
    1:     mLines = gDummyLines;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Make a linear array of the lines
    1:   mLines = new nsLineBox*[numLines];
    1:   if (!mLines) {
    1:     // Use gDummyLines so that we don't need null pointer checks in
    1:     // the accessor methods
    1:     mLines = gDummyLines;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   nsLineBox** lp = mLines;
    1:   for (nsLineList::iterator line = aLines.begin(), line_end = aLines.end() ;
    1:        line != line_end;
    1:        ++line)
    1:   {
    1:     *lp++ = line;
    1:   }
    1:   mNumLines = numLines;
    1:   return NS_OK;
    1: }
    1: 
21112: PRInt32
21112: nsLineIterator::GetNumLines()
    1: {
21112:   return mNumLines;
    1: }
    1: 
79445: bool
21112: nsLineIterator::GetDirection()
    1: {
21112:   return mRightToLeft;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLineIterator::GetLine(PRInt32 aLineNumber,
    1:                         nsIFrame** aFirstFrameOnLine,
    1:                         PRInt32* aNumFramesOnLine,
    1:                         nsRect& aLineBounds,
    1:                         PRUint32* aLineFlags)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFirstFrameOnLine);
    1:   NS_ENSURE_ARG_POINTER(aNumFramesOnLine);
    1:   NS_ENSURE_ARG_POINTER(aLineFlags);
    1: 
    1:   if ((aLineNumber < 0) || (aLineNumber >= mNumLines)) {
    1:     *aFirstFrameOnLine = nsnull;
    1:     *aNumFramesOnLine = 0;
    1:     aLineBounds.SetRect(0, 0, 0, 0);
    1:     return NS_OK;
    1:   }
    1:   nsLineBox* line = mLines[aLineNumber];
    1:   *aFirstFrameOnLine = line->mFirstChild;
    1:   *aNumFramesOnLine = line->GetChildCount();
    1:   aLineBounds = line->mBounds;
    1: 
    1:   PRUint32 flags = 0;
    1:   if (line->IsBlock()) {
    1:     flags |= NS_LINE_FLAG_IS_BLOCK;
    1:   }
    1:   else {
    1:     if (line->HasBreakAfter())
    1:       flags |= NS_LINE_FLAG_ENDS_IN_BREAK;
    1:   }
    1:   *aLineFlags = flags;
    1: 
    1:   return NS_OK;
    1: }
    1: 
21112: PRInt32
77978: nsLineIterator::FindLineContaining(nsIFrame* aFrame, PRInt32 aStartLine)
    1: {
77978:   NS_PRECONDITION(aStartLine <= mNumLines, "Bogus line numbers");
77978:   PRInt32 lineNumber = aStartLine;
    1:   while (lineNumber != mNumLines) {
77978:     nsLineBox* line = mLines[lineNumber];
    1:     if (line->Contains(aFrame)) {
21112:       return lineNumber;
    1:     }
77978:     ++lineNumber;
    1:   }
21112:   return -1;
    1: }
    1: 
    1: #ifdef IBMBIDI
    1: NS_IMETHODIMP
    1: nsLineIterator::CheckLineOrder(PRInt32                  aLine,
79445:                                bool                     *aIsReordered,
    1:                                nsIFrame                 **aFirstVisual,
    1:                                nsIFrame                 **aLastVisual)
    1: {
    1:   NS_ASSERTION (aLine >= 0 && aLine < mNumLines, "aLine out of range!");
    1:   nsLineBox* line = mLines[aLine];
    1: 
    1:   if (!line->mFirstChild) { // empty line
    1:     *aIsReordered = PR_FALSE;
    1:     *aFirstVisual = nsnull;
    1:     *aLastVisual = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsIFrame* leftmostFrame;
    1:   nsIFrame* rightmostFrame;
73724:   *aIsReordered = nsBidiPresUtils::CheckLineOrder(line->mFirstChild, line->GetChildCount(), &leftmostFrame, &rightmostFrame);
    1: 
    1:   // map leftmost/rightmost to first/last according to paragraph direction
    1:   *aFirstVisual = mRightToLeft ? rightmostFrame : leftmostFrame;
    1:   *aLastVisual = mRightToLeft ? leftmostFrame : rightmostFrame;
    1: 
    1:   return NS_OK;
    1: }
    1: #endif // IBMBIDI
    1: 
    1: NS_IMETHODIMP
    1: nsLineIterator::FindFrameAt(PRInt32 aLineNumber,
    1:                             nscoord aX,
    1:                             nsIFrame** aFrameFound,
79445:                             bool* aXIsBeforeFirstFrame,
79445:                             bool* aXIsAfterLastFrame)
    1: {
    1:   NS_PRECONDITION(aFrameFound && aXIsBeforeFirstFrame && aXIsAfterLastFrame,
    1:                   "null OUT ptr");
    1:   if (!aFrameFound || !aXIsBeforeFirstFrame || !aXIsAfterLastFrame) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   if ((aLineNumber < 0) || (aLineNumber >= mNumLines)) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
    1:   nsLineBox* line = mLines[aLineNumber];
    1:   if (!line) {
    1:     *aFrameFound = nsnull;
    1:     *aXIsBeforeFirstFrame = PR_TRUE;
    1:     *aXIsAfterLastFrame = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (line->mBounds.width == 0 && line->mBounds.height == 0)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIFrame* frame = line->mFirstChild;
    1:   nsIFrame* closestFromLeft = nsnull;
    1:   nsIFrame* closestFromRight = nsnull;
    1:   PRInt32 n = line->GetChildCount();
    1:   while (n--) {
    1:     nsRect rect = frame->GetRect();
    1:     if (rect.width > 0) {
    1:       // If aX is inside this frame - this is it
    1:       if (rect.x <= aX && rect.XMost() > aX) {
    1:         closestFromLeft = closestFromRight = frame;
    1:         break;
    1:       }
    1:       if (rect.x < aX) {
    1:         if (!closestFromLeft || 
    1:             rect.XMost() > closestFromLeft->GetRect().XMost())
    1:           closestFromLeft = frame;
    1:       }
    1:       else {
    1:         if (!closestFromRight ||
    1:             rect.x < closestFromRight->GetRect().x)
    1:           closestFromRight = frame;
    1:       }
    1:     }
    1:     frame = frame->GetNextSibling();
    1:   }
    1:   if (!closestFromLeft && !closestFromRight) {
    1:     // All frames were zero-width. Just take the first one.
    1:     closestFromLeft = closestFromRight = line->mFirstChild;
    1:   }
    1:   *aXIsBeforeFirstFrame = mRightToLeft ? !closestFromRight : !closestFromLeft;
    1:   *aXIsAfterLastFrame = mRightToLeft ? !closestFromLeft : !closestFromRight;
    1:   if (closestFromLeft == closestFromRight) {
    1:     *aFrameFound = closestFromLeft;
    1:   }
    1:   else if (!closestFromLeft) {
    1:     *aFrameFound = closestFromRight;
    1:   }
    1:   else if (!closestFromRight) {
    1:     *aFrameFound = closestFromLeft;
    1:   }
    1:   else { // we're between two frames
    1:     nscoord delta = closestFromRight->GetRect().x - closestFromLeft->GetRect().XMost();
    1:     if (aX < closestFromLeft->GetRect().XMost() + delta/2)
    1:       *aFrameFound = closestFromLeft;
    1:     else
    1:       *aFrameFound = closestFromRight;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLineIterator::GetNextSiblingOnLine(nsIFrame*& aFrame, PRInt32 aLineNumber)
    1: {
    1:   aFrame = aFrame->GetNextSibling();
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1: nsFloatCacheList::nsFloatCacheList() :
    1:   mHead(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsFloatCacheList);
    1: }
    1: #endif
    1: 
    1: nsFloatCacheList::~nsFloatCacheList()
    1: {
    1:   DeleteAll();
    1:   MOZ_COUNT_DTOR(nsFloatCacheList);
    1: }
    1: 
    1: void
    1: nsFloatCacheList::DeleteAll()
    1: {
    1:   nsFloatCache* c = mHead;
    1:   while (c) {
    1:     nsFloatCache* next = c->Next();
    1:     delete c;
    1:     c = next;
    1:   }
    1:   mHead = nsnull;
    1: }
    1: 
    1: nsFloatCache*
    1: nsFloatCacheList::Tail() const
    1: {
    1:   nsFloatCache* fc = mHead;
    1:   while (fc) {
    1:     if (!fc->mNext) {
    1:       break;
    1:     }
    1:     fc = fc->mNext;
    1:   }
    1:   return fc;
    1: }
    1: 
    1: void
    1: nsFloatCacheList::Append(nsFloatCacheFreeList& aList)
    1: {
    1:   NS_PRECONDITION(aList.NotEmpty(), "Appending empty list will fail");
    1:   
    1:   nsFloatCache* tail = Tail();
    1:   if (tail) {
    1:     NS_ASSERTION(!tail->mNext, "Bogus!");
    1:     tail->mNext = aList.mHead;
    1:   }
    1:   else {
    1:     NS_ASSERTION(!mHead, "Bogus!");
    1:     mHead = aList.mHead;
    1:   }
    1:   aList.mHead = nsnull;
    1:   aList.mTail = nsnull;
    1: }
    1: 
    1: nsFloatCache*
    1: nsFloatCacheList::Find(nsIFrame* aOutOfFlowFrame)
    1: {
    1:   nsFloatCache* fc = mHead;
    1:   while (fc) {
32107:     if (fc->mFloat == aOutOfFlowFrame) {
    1:       break;
    1:     }
    1:     fc = fc->Next();
    1:   }
    1:   return fc;
    1: }
    1: 
    1: nsFloatCache*
    1: nsFloatCacheList::RemoveAndReturnPrev(nsFloatCache* aElement)
    1: {
    1:   nsFloatCache* fc = mHead;
    1:   nsFloatCache* prev = nsnull;
    1:   while (fc) {
    1:     if (fc == aElement) {
    1:       if (prev) {
    1:         prev->mNext = fc->mNext;
    1:       } else {
    1:         mHead = fc->mNext;
    1:       }
    1:       return prev;
    1:     }
    1:     prev = fc;
    1:     fc = fc->mNext;
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1: nsFloatCacheFreeList::nsFloatCacheFreeList() :
    1:   mTail(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsFloatCacheFreeList);
    1: }
    1: 
    1: nsFloatCacheFreeList::~nsFloatCacheFreeList()
    1: {
    1:   MOZ_COUNT_DTOR(nsFloatCacheFreeList);
    1: }
    1: #endif
    1:   
    1: void
    1: nsFloatCacheFreeList::Append(nsFloatCacheList& aList)
    1: {
    1:   NS_PRECONDITION(aList.NotEmpty(), "Appending empty list will fail");
    1:   
    1:   if (mTail) {
    1:     NS_ASSERTION(!mTail->mNext, "Bogus");
    1:     mTail->mNext = aList.mHead;
    1:   }
    1:   else {
    1:     NS_ASSERTION(!mHead, "Bogus");
    1:     mHead = aList.mHead;
    1:   }
    1:   mTail = aList.Tail();
    1:   aList.mHead = nsnull;
    1: }
    1: 
    1: void
    1: nsFloatCacheFreeList::Remove(nsFloatCache* aElement)
    1: {
    1:   nsFloatCache* prev = nsFloatCacheList::RemoveAndReturnPrev(aElement);
    1:   if (mTail == aElement) {
    1:     mTail = prev;
    1:   }
    1: }
    1: 
    1: void
    1: nsFloatCacheFreeList::DeleteAll()
    1: {
    1:   nsFloatCacheList::DeleteAll();
    1:   mTail = nsnull;
    1: }
    1: 
    1: nsFloatCache*
32108: nsFloatCacheFreeList::Alloc(nsIFrame* aFloat)
    1: {
32108:   NS_PRECONDITION(aFloat->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
32108:                   "This is a float cache, why isn't the frame out-of-flow?");
    1:   nsFloatCache* fc = mHead;
    1:   if (mHead) {
    1:     if (mHead == mTail) {
    1:       mHead = mTail = nsnull;
    1:     }
    1:     else {
    1:       mHead = fc->mNext;
    1:     }
    1:     fc->mNext = nsnull;
    1:   }
    1:   else {
    1:     fc = new nsFloatCache();
    1:   }
32108:   fc->mFloat = aFloat;
    1:   return fc;
    1: }
    1: 
    1: void
    1: nsFloatCacheFreeList::Append(nsFloatCache* aFloat)
    1: {
    1:   NS_ASSERTION(!aFloat->mNext, "Bogus!");
    1:   aFloat->mNext = nsnull;
    1:   if (mTail) {
    1:     NS_ASSERTION(!mTail->mNext, "Bogus!");
    1:     mTail->mNext = aFloat;
    1:     mTail = aFloat;
    1:   }
    1:   else {
    1:     NS_ASSERTION(!mHead, "Bogus!");
    1:     mHead = mTail = aFloat;
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsFloatCache::nsFloatCache()
32107:   : mFloat(nsnull),
    1:     mNext(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsFloatCache);
    1: }
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1: nsFloatCache::~nsFloatCache()
    1: {
    1:   MOZ_COUNT_DTOR(nsFloatCache);
    1: }
    1: #endif
