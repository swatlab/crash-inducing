    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is thebes gfx
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * mozilla.org.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Stuart Parmenter <pavlov@pavlov.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
68670: #include "nsDeviceContext.h"
68670: #include "nsCRT.h"
68670: #include "nsFontMetrics.h"
68670: #include "nsRenderingContext.h"
68670: #include "nsIView.h"
68670: #include "nsIWidget.h"
68670: 
68670: #include "mozilla/Services.h"
71640: #include "mozilla/Preferences.h"
68670: #include "nsIServiceManager.h"
27091: #include "nsILanguageAtomService.h"
68666: #include "nsIObserver.h"
68666: #include "nsIObserverService.h"
    1: 
    1: #include "gfxImageSurface.h"
    1: 
    1: #ifdef MOZ_ENABLE_GTK2
    1: #include "nsSystemFontsGTK2.h"
    1: #include "gfxPDFSurface.h"
    1: #include "gfxPSSurface.h"
    1: static nsSystemFontsGTK2 *gSystemFonts = nsnull;
    1: #elif XP_WIN
    1: #include "nsSystemFontsWin.h"
    1: #include "gfxWindowsSurface.h"
    1: #include "gfxPDFSurface.h"
    1: static nsSystemFontsWin *gSystemFonts = nsnull;
    1: #elif defined(XP_OS2)
    1: #include "nsSystemFontsOS2.h"
68670: #include "gfxOS2Surface.h"
 8925: #include "gfxPDFSurface.h"
    1: static nsSystemFontsOS2 *gSystemFonts = nsnull;
    1: #elif XP_MACOSX
    1: #include "nsSystemFontsMac.h"
    1: #include "gfxQuartzSurface.h"
    1: static nsSystemFontsMac *gSystemFonts = nsnull;
16758: #elif defined(MOZ_WIDGET_QT)
16758: #include "nsSystemFontsQt.h"
55144: #include "gfxPDFSurface.h"
16758: static nsSystemFontsQt *gSystemFonts = nsnull;
42153: #elif defined(ANDROID)
42153: #include "nsSystemFontsAndroid.h"
57613: #include "gfxPDFSurface.h"
42153: static nsSystemFontsAndroid *gSystemFonts = nsnull;
    1: #else
    1: #error Need to declare gSystemFonts!
    1: #endif
    1: 
71640: using namespace mozilla;
68666: using mozilla::services::GetObserverService;
    1: 
68666: class nsFontCache : public nsIObserver
27091: {
27091: public:
68666:     nsFontCache()   { MOZ_COUNT_CTOR(nsFontCache); }
68666:     ~nsFontCache()  { MOZ_COUNT_DTOR(nsFontCache); }
27091: 
68666:     NS_DECL_ISUPPORTS
68666:     NS_DECL_NSIOBSERVER
68666: 
68670:     void Init(nsDeviceContext* aContext);
68666:     void Destroy();
68666: 
38492:     nsresult GetMetricsFor(const nsFont& aFont, nsIAtom* aLanguage,
27091:                            gfxUserFontSet* aUserFontSet,
68492:                            nsFontMetrics*& aMetrics);
27091: 
68666:     void FontMetricsDeleted(const nsFontMetrics* aFontMetrics);
68666:     void Compact();
68666:     void Flush();
27091: 
27091: protected:
68670:     nsDeviceContext*          mContext; // owner
68670:     nsCOMPtr<nsIAtom>         mLocaleLanguage;
68492:     nsTArray<nsFontMetrics*>  mFontMetrics;
27091: };
27091: 
68666: NS_IMPL_ISUPPORTS1(nsFontCache, nsIObserver)
68666: 
68666: // The Init and Destroy methods are necessary because it's not
68666: // safe to call AddObserver from a constructor or RemoveObserver
68666: // from a destructor.  That should be fixed.
68666: void
68670: nsFontCache::Init(nsDeviceContext* aContext)
27091: {
68666:     mContext = aContext;
68666:     // register as a memory-pressure observer to free font resources
68666:     // in low-memory situations.
68666:     nsCOMPtr<nsIObserverService> obs = GetObserverService();
68666:     if (obs)
68666:         obs->AddObserver(this, "memory-pressure", PR_FALSE);
68670: 
68670:     nsCOMPtr<nsILanguageAtomService> langService;
68670:     langService = do_GetService(NS_LANGUAGEATOMSERVICE_CONTRACTID);
68670:     if (langService) {
68670:         mLocaleLanguage = langService->GetLocaleLanguage();
68670:     }
68670:     if (!mLocaleLanguage) {
68670:         mLocaleLanguage = do_GetAtom("x-western");
68670:     }
27091: }
27091: 
68666: void
68666: nsFontCache::Destroy()
27091: {
68666:     nsCOMPtr<nsIObserverService> obs = GetObserverService();
68666:     if (obs)
68666:         obs->RemoveObserver(this, "memory-pressure");
27091:     Flush();
27091: }
27091: 
68666: NS_IMETHODIMP
68666: nsFontCache::Observe(nsISupports*, const char* aTopic, const PRUnichar*)
27091: {
68666:     if (!nsCRT::strcmp(aTopic, "memory-pressure"))
68666:         Compact();
27091:     return NS_OK;
27091: }
27091: 
27091: nsresult
38492: nsFontCache::GetMetricsFor(const nsFont& aFont, nsIAtom* aLanguage,
68666:                            gfxUserFontSet* aUserFontSet,
68666:                            nsFontMetrics*& aMetrics)
27091: {
68670:     if (!aLanguage)
68670:         aLanguage = mLocaleLanguage;
68670: 
27091:     // First check our cache
27091:     // start from the end, which is where we put the most-recent-used element
27091: 
68492:     nsFontMetrics* fm;
27091:     PRInt32 n = mFontMetrics.Length() - 1;
27091:     for (PRInt32 i = n; i >= 0; --i) {
27091:         fm = mFontMetrics[i];
68497:         if (fm->Font().Equals(aFont) && fm->GetUserFontSet() == aUserFontSet &&
68497:             fm->Language() == aLanguage) {
27091:             if (i != n) {
27091:                 // promote it to the end of the cache
27091:                 mFontMetrics.RemoveElementAt(i);
27091:                 mFontMetrics.AppendElement(fm);
27091:             }
68491:             fm->GetThebesFontGroup()->UpdateFontList();
27091:             NS_ADDREF(aMetrics = fm);
27091:             return NS_OK;
27091:         }
27091:     }
27091: 
27091:     // It's not in the cache. Get font metrics and then cache them.
27091: 
68492:     fm = new nsFontMetrics();
68492:     NS_ADDREF(fm);
68492:     nsresult rv = fm->Init(aFont, aLanguage, mContext, aUserFontSet);
27091:     if (NS_SUCCEEDED(rv)) {
27091:         // the mFontMetrics list has the "head" at the end, because append
27091:         // is cheaper than insert
27091:         mFontMetrics.AppendElement(fm);
27091:         aMetrics = fm;
27091:         NS_ADDREF(aMetrics);
27091:         return NS_OK;
27091:     }
27091:     fm->Destroy();
27091:     NS_RELEASE(fm);
27091: 
27091:     // One reason why Init() fails is because the system is running out of
27091:     // resources. e.g., on Win95/98 only a very limited number of GDI
27091:     // objects are available. Compact the cache and try again.
27091: 
27091:     Compact();
68492:     fm = new nsFontMetrics();
68492:     NS_ADDREF(fm);
38492:     rv = fm->Init(aFont, aLanguage, mContext, aUserFontSet);
27091:     if (NS_SUCCEEDED(rv)) {
27091:         mFontMetrics.AppendElement(fm);
27091:         aMetrics = fm;
27091:         return NS_OK;
27091:     }
27091:     fm->Destroy();
27091:     NS_RELEASE(fm);
27091: 
27091:     // could not setup a new one, send an old one (XXX search a "best
27091:     // match"?)
27091: 
27091:     n = mFontMetrics.Length() - 1; // could have changed in Compact()
27091:     if (n >= 0) {
27091:         aMetrics = mFontMetrics[n];
27091:         NS_ADDREF(aMetrics);
27091:         return NS_OK;
27091:     }
27091: 
68666:     NS_POSTCONDITION(NS_SUCCEEDED(rv),
68666:                      "font metrics should not be null - bug 136248");
27091:     return rv;
27091: }
27091: 
68666: void
68666: nsFontCache::FontMetricsDeleted(const nsFontMetrics* aFontMetrics)
27091: {
27091:     mFontMetrics.RemoveElement(aFontMetrics);
27091: }
27091: 
68666: void
68666: nsFontCache::Compact()
27091: {
27091:     // Need to loop backward because the running element can be removed on
27091:     // the way
27091:     for (PRInt32 i = mFontMetrics.Length()-1; i >= 0; --i) {
68492:         nsFontMetrics* fm = mFontMetrics[i];
68492:         nsFontMetrics* oldfm = fm;
27091:         // Destroy() isn't here because we want our device context to be
27091:         // notified
27091:         NS_RELEASE(fm); // this will reset fm to nsnull
27091:         // if the font is really gone, it would have called back in
27091:         // FontMetricsDeleted() and would have removed itself
32089:         if (mFontMetrics.IndexOf(oldfm) != mFontMetrics.NoIndex) {
27091:             // nope, the font is still there, so let's hold onto it too
27091:             NS_ADDREF(oldfm);
27091:         }
27091:     }
27091: }
27091: 
68666: void
68666: nsFontCache::Flush()
27091: {
27091:     for (PRInt32 i = mFontMetrics.Length()-1; i >= 0; --i) {
68492:         nsFontMetrics* fm = mFontMetrics[i];
27091:         // Destroy() will unhook our device context from the fm so that we
27091:         // won't waste time in triggering the notification of
27091:         // FontMetricsDeleted() in the subsequent release
27091:         fm->Destroy();
27091:         NS_RELEASE(fm);
27091:     }
27091:     mFontMetrics.Clear();
27091: }
27091: 
68670: nsDeviceContext::nsDeviceContext()
68670:     : mWidth(0), mHeight(0), mDepth(0),
68670:       mAppUnitsPerDevPixel(-1), mAppUnitsPerDevNotScaledPixel(-1),
68670:       mAppUnitsPerPhysicalInch(-1),
68670:       mPixelScale(1.0f), mPrintingScale(1.0f),
68670:       mFontCache(nsnull)
    1: {
    1: }
    1: 
68666: // Note: we use a bare pointer for mFontCache so that nsFontCache
68670: // can be an incomplete type in nsDeviceContext.h.
68666: // Therefore we have to do all the refcounting by hand.
68670: nsDeviceContext::~nsDeviceContext()
    1: {
68666:     if (mFontCache) {
68666:         mFontCache->Destroy();
68666:         NS_RELEASE(mFontCache);
27091:     }
27091: }
27091: 
68670: nsresult
68670: nsDeviceContext::GetMetricsFor(const nsFont& aFont,
68670:                                nsIAtom* aLanguage,
68670:                                gfxUserFontSet* aUserFontSet,
68670:                                nsFontMetrics*& aMetrics)
27091: {
68670:     if (!mFontCache) {
27091:         mFontCache = new nsFontCache();
68666:         NS_ADDREF(mFontCache);
68666:         mFontCache->Init(this);
68670:     }
68670: 
68670:     return mFontCache->GetMetricsFor(aFont, aLanguage, aUserFontSet, aMetrics);
68670: }
68670: 
68670: nsresult
68670: nsDeviceContext::FlushFontCache(void)
68670: {
68670:     if (mFontCache)
68670:         mFontCache->Flush();
68666:     return NS_OK;
27091: }
27091: 
68670: nsresult
68670: nsDeviceContext::FontMetricsDeleted(const nsFontMetrics* aFontMetrics)
27091: {
27091:     if (mFontCache) {
27091:         mFontCache->FontMetricsDeleted(aFontMetrics);
27091:     }
27091:     return NS_OK;
27091: }
27091: 
22866: PRBool
68670: nsDeviceContext::IsPrinterSurface()
22866: {
22866:     return(mPrintingSurface != NULL);
22866: }
22866: 
68670: void
68670: nsDeviceContext::SetDPI()
    1: {
50782:     float dpi = -1.0f;
    1: 
    1:     // PostScript, PDF and Mac (when printing) all use 72 dpi
32950:     // Use a printing DC to determine the other dpi values
32950:     if (mPrintingSurface) {
32950:         switch (mPrintingSurface->GetType()) {
32950:         case gfxASurface::SurfaceTypePDF:
32950:         case gfxASurface::SurfaceTypePS:
32950:         case gfxASurface::SurfaceTypeQuartz:
50782:             dpi = 72.0f;
32950:             break;
32950: #ifdef XP_WIN
32950:         case gfxASurface::SurfaceTypeWin32:
36240:         case gfxASurface::SurfaceTypeWin32Printing: {
68670:             HDC dc = reinterpret_cast<gfxWindowsSurface*>(mPrintingSurface.get())->GetDC();
68670:             PRInt32 OSVal = GetDeviceCaps(dc, LOGPIXELSY);
50782:             dpi = 144.0f;
32950:             mPrintingScale = float(OSVal) / dpi;
32950:             break;
36240:         }
32950: #endif
32950: #ifdef XP_OS2
68670:         case gfxASurface::SurfaceTypeOS2: {
32950:             LONG lDPI;
68670:             HDC dc = GpiQueryDevice(reinterpret_cast<gfxOS2Surface*>(mPrintingSurface.get())->GetPS());
68670:             if (DevQueryCaps(dc, CAPS_VERTICAL_FONT_RES, 1, &lDPI))
32950:                 dpi = lDPI;
32950:             break;
68670:         }
32950: #endif
36237:         default:
36237:             NS_NOTREACHED("Unexpected printing surface type");
36237:             break;
32950:         }
50782: 
50782:         mAppUnitsPerDevNotScaledPixel =
50782:             NS_lround((AppUnitsPerCSSPixel() * 96) / dpi);
    1:     } else {
50782:         // A value of -1 means use the maximum of 96 and the system DPI.
28470:         // A value of 0 means use the system DPI. A positive value is used as the DPI.
28470:         // This sets the physical size of a device pixel and thus controls the
50782:         // interpretation of physical units.
71640:         PRInt32 prefDPI = Preferences::GetInt("layout.css.dpi", -1);
    1: 
50782:         if (prefDPI > 0) {
50782:             dpi = prefDPI;
50782:         } else if (mWidget) {
50782:             dpi = mWidget->GetDPI();
50433: 
50782:             if (prefDPI < 0) {
72496:                 dpi = NS_MAX(96.0f, dpi);
50782:             }
50782:         } else {
50782:             dpi = 96.0f;
50433:         }
35286: 
50782:         // The number of device pixels per CSS pixel. A value <= 0 means choose
50782:         // automatically based on the DPI. A positive value is used as-is. This effectively
50782:         // controls the size of a CSS "px".
50782:         float devPixelsPerCSSPixel = -1.0;
50433: 
71640:         nsAdoptingCString prefString = Preferences::GetCString("layout.css.devPixelsPerPx");
71640:         if (!prefString.IsEmpty()) {
50782:             devPixelsPerCSSPixel = static_cast<float>(atof(prefString));
50397:         }
    1: 
50782:         if (devPixelsPerCSSPixel <= 0) {
50782:             if (mWidget) {
50782:                 devPixelsPerCSSPixel = mWidget->GetDefaultScale();
50782:             } else {
50782:                 devPixelsPerCSSPixel = 1.0;
50782:             }
50782:         }
    1: 
50782:         mAppUnitsPerDevNotScaledPixel =
72496:             NS_MAX(1, NS_lround(AppUnitsPerCSSPixel() / devPixelsPerCSSPixel));
50782:     }
50782: 
50782:     NS_ASSERTION(dpi != -1.0, "no dpi set");
50782: 
50791:     mAppUnitsPerPhysicalInch = NS_lround(dpi * mAppUnitsPerDevNotScaledPixel);
 4003:     UpdateScaledAppUnits();
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::Init(nsIWidget *aWidget)
    1: {
54311:     if (mScreenManager && mWidget == aWidget)
54311:         return NS_OK;
54311: 
    1:     mWidget = aWidget;
    1:     SetDPI();
    1: 
54311:     if (mScreenManager)
54311:         return NS_OK;
27091: 
    1:     mScreenManager = do_GetService("@mozilla.org/gfx/screenmanager;1");
    1: 
    1:     return NS_OK;
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::CreateRenderingContext(nsRenderingContext *&aContext)
    1: {
68670:     NS_ABORT_IF_FALSE(mPrintingSurface, "only call for printing dcs");
    1: 
68670:     nsRefPtr<nsRenderingContext> pContext = new nsRenderingContext();
    1: 
68483:     pContext->Init(this, mPrintingSurface);
11804:     pContext->Scale(mPrintingScale, mPrintingScale);
    1:     aContext = pContext;
    1:     NS_ADDREF(aContext);
    1: 
    1:     return NS_OK;
    1: }
    1: 
68670: /* static */ void
68670: nsDeviceContext::ClearCachedSystemFonts()
 2282: {
 2282:     if (gSystemFonts) {
 2282:         delete gSystemFonts;
 2282:         gSystemFonts = nsnull;
 2282:     }
 2282: }
 2282: 
68670: nsresult
68670: nsDeviceContext::GetSystemFont(nsSystemFontID aID, nsFont *aFont) const
    1: {
    1:     if (!gSystemFonts) {
    1: #ifdef MOZ_ENABLE_GTK2
    1:         gSystemFonts = new nsSystemFontsGTK2();
    1: #elif XP_WIN
    1:         gSystemFonts = new nsSystemFontsWin();
    1: #elif XP_OS2
    1:         gSystemFonts = new nsSystemFontsOS2();
    1: #elif XP_MACOSX
    1:         gSystemFonts = new nsSystemFontsMac();
16758: #elif defined(MOZ_WIDGET_QT)
16758:         gSystemFonts = new nsSystemFontsQt();
42153: #elif defined(ANDROID)
42153:         gSystemFonts = new nsSystemFontsAndroid();
    1: #else
    1: #error Need to know how to create gSystemFonts, fix me!
    1: #endif
    1:     }
    1: 
    1:     nsString fontName;
12929:     gfxFontStyle fontStyle;
    1:     nsresult rv = gSystemFonts->GetSystemFont(aID, &fontName, &fontStyle);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     aFont->name = fontName;
    1:     aFont->style = fontStyle.style;
    1:     aFont->systemFont = fontStyle.systemFont;
 1660:     aFont->variant = NS_FONT_VARIANT_NORMAL;
    1:     aFont->weight = fontStyle.weight;
24408:     aFont->stretch = fontStyle.stretch;
 1660:     aFont->decorations = NS_FONT_DECORATION_NONE;
 4257:     aFont->size = NSFloatPixelsToAppUnits(fontStyle.size, UnscaledAppUnitsPerDevPixel());
    1:     //aFont->langGroup = fontStyle.langGroup;
    1:     aFont->sizeAdjust = fontStyle.sizeAdjust;
    1: 
    1:     return rv;
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::GetDepth(PRUint32& aDepth)
    1: {
23019:     if (mDepth == 0) {
14339:         nsCOMPtr<nsIScreen> primaryScreen;
14339:         mScreenManager->GetPrimaryScreen(getter_AddRefs(primaryScreen));
14339:         primaryScreen->GetColorDepth(reinterpret_cast<PRInt32 *>(&mDepth));
14339:     }
14339: 
    1:     aDepth = mDepth;
    1:     return NS_OK;
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::GetDeviceSurfaceDimensions(nscoord &aWidth, nscoord &aHeight)
    1: {
    1:     if (mPrintingSurface) {
    1:         // we have a printer device
    1:         aWidth = mWidth;
    1:         aHeight = mHeight;
    1:     } else {
    1:         nsRect area;
    1:         ComputeFullAreaUsingScreen(&area);
    1:         aWidth = area.width;
    1:         aHeight = area.height;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::GetRect(nsRect &aRect)
    1: {
    1:     if (mPrintingSurface) {
    1:         // we have a printer device
    1:         aRect.x = 0;
    1:         aRect.y = 0;
    1:         aRect.width = mWidth;
    1:         aRect.height = mHeight;
    1:     } else
    1:         ComputeFullAreaUsingScreen ( &aRect );
    1: 
    1:     return NS_OK;
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::GetClientRect(nsRect &aRect)
    1: {
    1:     if (mPrintingSurface) {
    1:         // we have a printer device
    1:         aRect.x = 0;
    1:         aRect.y = 0;
    1:         aRect.width = mWidth;
    1:         aRect.height = mHeight;
    1:     }
    1:     else
    1:         ComputeClientRectUsingScreen(&aRect);
    1: 
    1:     return NS_OK;
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::InitForPrinting(nsIDeviceContextSpec *aDevice)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aDevice);
    1: 
 2476:     mDeviceContextSpec = aDevice;
    1: 
    1:     nsresult rv = aDevice->GetSurfaceForPrinter(getter_AddRefs(mPrintingSurface));
    1:     if (NS_FAILED(rv))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     Init(nsnull);
    1: 
    1:     CalcPrintingSize();
    1: 
    1:     return NS_OK;
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::BeginDocument(PRUnichar*  aTitle,
    1:                                PRUnichar*  aPrintToFileName,
    1:                                PRInt32     aStartPage,
    1:                                PRInt32     aEndPage)
    1: {
    1:     static const PRUnichar kEmpty[] = { '\0' };
13596:     nsresult rv;
    1: 
13596:     rv = mPrintingSurface->BeginPrinting(nsDependentString(aTitle ? aTitle : kEmpty),
    1:                                          nsDependentString(aPrintToFileName ? aPrintToFileName : kEmpty));
13596: 
13596:     if (NS_SUCCEEDED(rv) && mDeviceContextSpec)
13596:         rv = mDeviceContextSpec->BeginDocument(aTitle, aPrintToFileName, aStartPage, aEndPage);
13596: 
13596:     return rv;
    1: }
    1: 
    1: 
68670: nsresult
68670: nsDeviceContext::EndDocument(void)
    1: {
13596:     nsresult rv = NS_OK;
13596: 
    1:     if (mPrintingSurface) {
13596:         rv = mPrintingSurface->EndPrinting();
13596:         if (NS_SUCCEEDED(rv))
    1:             mPrintingSurface->Finish();
    1:     }
13596: 
    1:     if (mDeviceContextSpec)
    1:         mDeviceContextSpec->EndDocument();
13596: 
13596:     return rv;
    1: }
    1: 
    1: 
68670: nsresult
68670: nsDeviceContext::AbortDocument(void)
    1: {
13596:     nsresult rv = mPrintingSurface->AbortPrinting();
    1: 
    1:     if (mDeviceContextSpec)
    1:         mDeviceContextSpec->EndDocument();
13596: 
13596:     return rv;
    1: }
    1: 
    1: 
68670: nsresult
68670: nsDeviceContext::BeginPage(void)
    1: {
13596:     nsresult rv = NS_OK;
13596: 
  183:     if (mDeviceContextSpec)
13596:         rv = mDeviceContextSpec->BeginPage();
13596: 
13596:     if (NS_FAILED(rv)) return rv;
  183: 
  183: #ifdef XP_MACOSX
74024:     // We need to get a new surface for each page on the Mac, as the
74024:     // CGContextRefs are only good for one page.
74024:     // And we don't null it out in EndPage because mPrintingSurface needs
74024:     // to be available also in-between EndPage/BeginPage (bug 665218).
  183:     mDeviceContextSpec->GetSurfaceForPrinter(getter_AddRefs(mPrintingSurface));
  183: #endif
74024: 
13596:     rv = mPrintingSurface->BeginPage();
    1: 
13596:     return rv;
    1: }
    1: 
68670: nsresult
68670: nsDeviceContext::EndPage(void)
    1: {
13596:     nsresult rv = mPrintingSurface->EndPage();
    1: 
    1:     if (mDeviceContextSpec)
    1:         mDeviceContextSpec->EndPage();
    1: 
13596:     return rv;
    1: }
    1: 
    1: void
68670: nsDeviceContext::ComputeClientRectUsingScreen(nsRect* outRect)
    1: {
    1:     // we always need to recompute the clientRect
    1:     // because the window may have moved onto a different screen. In the single
    1:     // monitor case, we only need to do the computation if we haven't done it
    1:     // once already, and remember that we have because we're assured it won't change.
    1:     nsCOMPtr<nsIScreen> screen;
    1:     FindScreen (getter_AddRefs(screen));
    1:     if (screen) {
    1:         PRInt32 x, y, width, height;
    1:         screen->GetAvailRect(&x, &y, &width, &height);
    1: 
    1:         // convert to device units
    1:         outRect->y = NSIntPixelsToAppUnits(y, AppUnitsPerDevPixel());
    1:         outRect->x = NSIntPixelsToAppUnits(x, AppUnitsPerDevPixel());
    1:         outRect->width = NSIntPixelsToAppUnits(width, AppUnitsPerDevPixel());
    1:         outRect->height = NSIntPixelsToAppUnits(height, AppUnitsPerDevPixel());
    1:     }
    1: }
    1: 
    1: void
68670: nsDeviceContext::ComputeFullAreaUsingScreen(nsRect* outRect)
    1: {
    1:     // if we have more than one screen, we always need to recompute the clientRect
    1:     // because the window may have moved onto a different screen. In the single
    1:     // monitor case, we only need to do the computation if we haven't done it
    1:     // once already, and remember that we have because we're assured it won't change.
    1:     nsCOMPtr<nsIScreen> screen;
    1:     FindScreen ( getter_AddRefs(screen) );
    1:     if ( screen ) {
    1:         PRInt32 x, y, width, height;
    1:         screen->GetRect ( &x, &y, &width, &height );
    1: 
    1:         // convert to device units
    1:         outRect->y = NSIntPixelsToAppUnits(y, AppUnitsPerDevPixel());
    1:         outRect->x = NSIntPixelsToAppUnits(x, AppUnitsPerDevPixel());
    1:         outRect->width = NSIntPixelsToAppUnits(width, AppUnitsPerDevPixel());
    1:         outRect->height = NSIntPixelsToAppUnits(height, AppUnitsPerDevPixel());
    1: 
    1:         mWidth = outRect->width;
    1:         mHeight = outRect->height;
    1:     }
    1: }
    1: 
    1: //
    1: // FindScreen
    1: //
    1: // Determines which screen intersects the largest area of the given surface.
    1: //
    1: void
68670: nsDeviceContext::FindScreen(nsIScreen** outScreen)
    1: {
29056:     if (mWidget && mWidget->GetNativeData(NS_NATIVE_WINDOW))
29056:         mScreenManager->ScreenForNativeWidget(mWidget->GetNativeData(NS_NATIVE_WINDOW),
29056:                                               outScreen);
    1:     else
    1:         mScreenManager->GetPrimaryScreen(outScreen);
    1: }
    1: 
    1: void
68670: nsDeviceContext::CalcPrintingSize()
    1: {
    1:     if (!mPrintingSurface)
    1:         return;
    1: 
    1:     PRBool inPoints = PR_TRUE;
    1: 
58638:     gfxSize size(0, 0);
    1:     switch (mPrintingSurface->GetType()) {
    1:     case gfxASurface::SurfaceTypeImage:
    1:         inPoints = PR_FALSE;
    1:         size = reinterpret_cast<gfxImageSurface*>(mPrintingSurface.get())->GetSize();
    1:         break;
    1: 
57613: #if defined(MOZ_PDF_PRINTING)
    1:     case gfxASurface::SurfaceTypePDF:
    1:         inPoints = PR_TRUE;
    1:         size = reinterpret_cast<gfxPDFSurface*>(mPrintingSurface.get())->GetSize();
    1:         break;
    1: #endif
    1: 
    1: #ifdef MOZ_ENABLE_GTK2
    1:     case gfxASurface::SurfaceTypePS:
    1:         inPoints = PR_TRUE;
    1:         size = reinterpret_cast<gfxPSSurface*>(mPrintingSurface.get())->GetSize();
    1:         break;
    1: #endif
    1: 
    1: #ifdef XP_MACOSX
  314:     case gfxASurface::SurfaceTypeQuartz:
    1:         inPoints = PR_TRUE; // this is really only true when we're printing
    1:         size = reinterpret_cast<gfxQuartzSurface*>(mPrintingSurface.get())->GetSize();
    1:         break;
    1: #endif
    1: 
    1: #ifdef XP_WIN
    1:     case gfxASurface::SurfaceTypeWin32:
 6274:     case gfxASurface::SurfaceTypeWin32Printing:
    1:         {
    1:             inPoints = PR_FALSE;
68670:             HDC dc = reinterpret_cast<gfxWindowsSurface*>(mPrintingSurface.get())->GetDC();
    1:             if (!dc)
29056:                 dc = GetDC((HWND)mWidget->GetNativeData(NS_NATIVE_WIDGET));
11804:             size.width = NSFloatPixelsToAppUnits(::GetDeviceCaps(dc, HORZRES)/mPrintingScale, AppUnitsPerDevPixel());
11804:             size.height = NSFloatPixelsToAppUnits(::GetDeviceCaps(dc, VERTRES)/mPrintingScale, AppUnitsPerDevPixel());
    1:             mDepth = (PRUint32)::GetDeviceCaps(dc, BITSPIXEL);
68670:             if (dc != reinterpret_cast<gfxWindowsSurface*>(mPrintingSurface.get())->GetDC())
29056:                 ReleaseDC((HWND)mWidget->GetNativeData(NS_NATIVE_WIDGET), dc);
    1:             break;
    1:         }
    1: #endif
10970: 
10970: #ifdef XP_OS2
10970:     case gfxASurface::SurfaceTypeOS2:
10970:         {
10970:             inPoints = PR_FALSE;
10970:             // we already set the size in the surface constructor we set for
10970:             // printing, so just get those values here
10970:             size = reinterpret_cast<gfxOS2Surface*>(mPrintingSurface.get())->GetSize();
11205:             // as they are in pixels we need to scale them to app units
11205:             size.width = NSFloatPixelsToAppUnits(size.width, AppUnitsPerDevPixel());
11205:             size.height = NSFloatPixelsToAppUnits(size.height, AppUnitsPerDevPixel());
10970:             // still need to get the depth from the device context
68670:             HDC dc = GpiQueryDevice(reinterpret_cast<gfxOS2Surface*>(mPrintingSurface.get())->GetPS());
10970:             LONG value;
10970:             if (DevQueryCaps(dc, CAPS_COLOR_BITCOUNT, 1, &value))
10970:                 mDepth = value;
10970:             else
10970:                 mDepth = 8; // default to 8bpp, should be enough for printers
10970:             break;
10970:         }
10970: #endif
    1:     default:
31561:         NS_ERROR("trying to print to unknown surface type");
    1:     }
    1: 
    1:     if (inPoints) {
50791:         // For printing, CSS inches and physical inches are identical
50791:         // so it doesn't matter which we use here
50791:         mWidth = NSToCoordRound(float(size.width) * AppUnitsPerPhysicalInch() / 72);
50791:         mHeight = NSToCoordRound(float(size.height) * AppUnitsPerPhysicalInch() / 72);
    1:     } else {
    1:         mWidth = NSToIntRound(size.width);
    1:         mHeight = NSToIntRound(size.height);
    1:     }
    1: }
    1: 
68670: PRBool nsDeviceContext::CheckDPIChange() {
 4003:     PRInt32 oldDevPixels = mAppUnitsPerDevNotScaledPixel;
50791:     PRInt32 oldInches = mAppUnitsPerPhysicalInch;
    1: 
    1:     SetDPI();
    1: 
 4003:     return oldDevPixels != mAppUnitsPerDevNotScaledPixel ||
50791:         oldInches != mAppUnitsPerPhysicalInch;
    1: }
 4003: 
 4003: PRBool
68670: nsDeviceContext::SetPixelScale(float aScale)
 4003: {
 4003:     if (aScale <= 0) {
 4003:         NS_NOTREACHED("Invalid pixel scale value");
 4003:         return PR_FALSE;
 4003:     }
 4003:     PRInt32 oldAppUnitsPerDevPixel = mAppUnitsPerDevPixel;
 4003:     mPixelScale = aScale;
 4003:     UpdateScaledAppUnits();
 4003:     return oldAppUnitsPerDevPixel != mAppUnitsPerDevPixel;
 4003: }
 4003: 
 4003: void
68670: nsDeviceContext::UpdateScaledAppUnits()
 4003: {
47722:     mAppUnitsPerDevPixel =
72496:         NS_MAX(1, NSToIntRound(float(mAppUnitsPerDevNotScaledPixel) / mPixelScale));
 4003: }
