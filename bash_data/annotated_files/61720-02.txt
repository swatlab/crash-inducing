    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Morten Nilsen <morten@nilsen.com>
    1:  *   Christian Biesinger <cbiesinger@web.de>
    1:  *   Jan Varga <varga@ku.sk>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsRect.h"
    1: #include "nsHTMLDocument.h"
    1: #include "nsIImageDocument.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMKeyEvent.h"
    1: #include "nsIDOMMouseEvent.h"
    1: #include "nsIDOMEventListener.h"
    1: #include "nsGkAtoms.h"
    1: #include "imgIRequest.h"
    1: #include "imgILoader.h"
    1: #include "imgIContainer.h"
    1: #include "nsStubImageDecoderObserver.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsMediaDocument.h"
    1: #include "nsStyleSet.h"
    1: #include "nsIChannel.h"
    1: #include "nsIContentPolicy.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNSHTMLElement.h"
    1: #include "nsContentErrors.h"
25034: #include "nsURILoader.h"
11359: #include "nsIDocShell.h"
11359: #include "nsIContentViewer.h"
11359: #include "nsIMarkupDocumentViewer.h"
33860: #include "nsIDocShellTreeItem.h"
35157: #include "nsThreadUtils.h"
37061: #include "nsIScrollableFrame.h"
41930: #include "mozilla/dom/Element.h"
41634: 
41634: using namespace mozilla::dom;
    1: 
    1: #define AUTOMATIC_IMAGE_RESIZING_PREF "browser.enable_automatic_image_resizing"
30811: #define CLICK_IMAGE_RESIZING_PREF "browser.enable_click_image_resizing"
32357: //XXX A hack needed for Firefox's site specific zoom.
32357: #define SITE_SPECIFIC_ZOOM "browser.zoom.siteSpecific"
    1: 
    1: class nsImageDocument;
    1: 
    1: class ImageListener: public nsMediaDocumentStreamListener
    1: {
    1: public:
    1:   ImageListener(nsImageDocument* aDocument);
    1:   virtual ~ImageListener();
    1: 
53658:   /* nsIRequestObserver */
53658:   NS_IMETHOD OnStartRequest(nsIRequest* request, nsISupports *ctxt);
    1: };
    1: 
    1: class nsImageDocument : public nsMediaDocument,
    1:                         public nsIImageDocument,
    1:                         public nsStubImageDecoderObserver,
    1:                         public nsIDOMEventListener
    1: {
    1: public:
    1:   nsImageDocument();
    1:   virtual ~nsImageDocument();
    1: 
 4838:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   virtual nsresult Init();
    1: 
    1:   virtual nsresult StartDocumentLoad(const char*         aCommand,
    1:                                      nsIChannel*         aChannel,
    1:                                      nsILoadGroup*       aLoadGroup,
    1:                                      nsISupports*        aContainer,
    1:                                      nsIStreamListener** aDocListener,
    1:                                      PRBool              aReset = PR_TRUE,
    1:                                      nsIContentSink*     aSink = nsnull);
    1: 
    1:   virtual void SetScriptGlobalObject(nsIScriptGlobalObject* aScriptGlobalObject);
    1:   virtual void Destroy();
32128:   virtual void OnPageShow(PRBool aPersisted,
32128:                           nsIDOMEventTarget* aDispatchStartTarget);
    1: 
    1:   NS_DECL_NSIIMAGEDOCUMENT
    1: 
    1:   // imgIDecoderObserver (override nsStubImageDecoderObserver)
    1:   NS_IMETHOD OnStartContainer(imgIRequest* aRequest, imgIContainer* aImage);
53658:   NS_IMETHOD OnStopDecode(imgIRequest *aRequest, nsresult aStatus, const PRUnichar *aStatusArg);
    1: 
    1:   // nsIDOMEventListener
    1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
    1: 
22219:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsImageDocument, nsMediaDocument)
22219: 
    1:   friend class ImageListener;
35157: 
35157:   void DefaultCheckOverflowing() { CheckOverflowing(mResizeImageByDefault); }
35157: 
48124:   virtual nsXPCClassInfo* GetClassInfo();
    1: protected:
21079:   virtual nsresult CreateSyntheticDocument();
    1: 
    1:   nsresult CheckOverflowing(PRBool changeState);
    1: 
    1:   void UpdateTitleAndCharset();
    1: 
14535:   nsresult ScrollImageTo(PRInt32 aX, PRInt32 aY, PRBool restoreImage);
14535: 
    1:   float GetRatio() {
38390:     return NS_MIN((float)mVisibleWidth / mImageWidth,
    1:                   (float)mVisibleHeight / mImageHeight);
    1:   }
    1: 
32128:   void ResetZoomLevel();
11359:   float GetZoomLevel();
11359: 
    1:   nsCOMPtr<nsIContent>          mImageContent;
    1: 
    1:   PRInt32                       mVisibleWidth;
    1:   PRInt32                       mVisibleHeight;
    1:   PRInt32                       mImageWidth;
    1:   PRInt32                       mImageHeight;
    1: 
    1:   PRPackedBool                  mResizeImageByDefault;
30811:   PRPackedBool                  mClickResizingEnabled;
    1:   PRPackedBool                  mImageIsOverflowing;
    1:   // mImageIsResized is true if the image is currently resized
    1:   PRPackedBool                  mImageIsResized;
    1:   // mShouldResize is true if the image should be resized when it doesn't fit
    1:   // mImageIsResized cannot be true when this is false, but mImageIsResized
    1:   // can be false when this is true
    1:   PRPackedBool                  mShouldResize;
    1:   PRPackedBool                  mFirstResize;
16327:   // mObservingImageLoader is true while the observer is set.
16327:   PRPackedBool                  mObservingImageLoader;
32128: 
32128:   float                         mOriginalZoomLevel;
    1: };
    1: 
    1: ImageListener::ImageListener(nsImageDocument* aDocument)
    1:   : nsMediaDocumentStreamListener(aDocument)
    1: {
    1: }
    1: 
    1: ImageListener::~ImageListener()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: ImageListener::OnStartRequest(nsIRequest* request, nsISupports *ctxt)
    1: {
    1:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
    1: 
    1:   nsImageDocument *imgDoc = (nsImageDocument*)mDocument.get();
    1:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
    1:   if (!channel) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsPIDOMWindow> domWindow =
    1:     do_QueryInterface(imgDoc->GetScriptGlobalObject());
    1:   NS_ENSURE_TRUE(domWindow, NS_ERROR_UNEXPECTED);
    1: 
    1:   // Do a ShouldProcess check to see whether to keep loading the image.
    1:   nsCOMPtr<nsIURI> channelURI;
    1:   channel->GetURI(getter_AddRefs(channelURI));
    1: 
    1:   nsCAutoString mimeType;
    1:   channel->GetContentType(mimeType);
    1: 
 4367:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 4367:   nsCOMPtr<nsIPrincipal> channelPrincipal;
 4367:   if (secMan) {
 4367:     secMan->GetChannelPrincipal(channel, getter_AddRefs(channelPrincipal));
 4367:   }
 4367:   
    1:   PRInt16 decision = nsIContentPolicy::ACCEPT;
    1:   nsresult rv = NS_CheckContentProcessPolicy(nsIContentPolicy::TYPE_IMAGE,
    1:                                              channelURI,
 4367:                                              channelPrincipal,
    1:                                              domWindow->GetFrameElementInternal(),
    1:                                              mimeType,
    1:                                              nsnull,
    1:                                              &decision,
 4367:                                              nsContentUtils::GetContentPolicy(),
 4367:                                              secMan);
    1:                                                
    1:   if (NS_FAILED(rv) || NS_CP_REJECTED(decision)) {
    1:     request->Cancel(NS_ERROR_CONTENT_BLOCKED);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(imgDoc->mImageContent);
    1:   NS_ENSURE_TRUE(imageLoader, NS_ERROR_UNEXPECTED);
    1: 
    1:   imageLoader->AddObserver(imgDoc);
16327:   imgDoc->mObservingImageLoader = PR_TRUE;
    1:   imageLoader->LoadImageWithChannel(channel, getter_AddRefs(mNextStream));
    1: 
    1:   return nsMediaDocumentStreamListener::OnStartRequest(request, ctxt);
    1: }
    1: 
    1: 
    1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
32128: nsImageDocument::nsImageDocument() : mOriginalZoomLevel(1.0)
    1: {
    1: 
    1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
    1: }
    1: 
    1: nsImageDocument::~nsImageDocument()
    1: {
    1: }
    1: 
22219: NS_IMPL_CYCLE_COLLECTION_CLASS(nsImageDocument)
22219: 
22219: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsImageDocument, nsMediaDocument)
22219:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mImageContent)
22219: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
22219: 
22219: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsImageDocument, nsMediaDocument)
22219:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mImageContent)
22219: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
22219: 
    1: NS_IMPL_ADDREF_INHERITED(nsImageDocument, nsMediaDocument)
    1: NS_IMPL_RELEASE_INHERITED(nsImageDocument, nsMediaDocument)
    1: 
48124: DOMCI_NODE_DATA(ImageDocument, nsImageDocument)
40490: 
58492: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsImageDocument)
21218:   NS_HTML_DOCUMENT_INTERFACE_TABLE_BEGIN(nsImageDocument)
21218:     NS_INTERFACE_TABLE_ENTRY(nsImageDocument, nsIImageDocument)
21218:     NS_INTERFACE_TABLE_ENTRY(nsImageDocument, imgIDecoderObserver)
21218:     NS_INTERFACE_TABLE_ENTRY(nsImageDocument, imgIContainerObserver)
21218:     NS_INTERFACE_TABLE_ENTRY(nsImageDocument, nsIDOMEventListener)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ImageDocument)
    1: NS_INTERFACE_MAP_END_INHERITING(nsMediaDocument)
    1: 
    1: 
    1: nsresult
    1: nsImageDocument::Init()
    1: {
    1:   nsresult rv = nsMediaDocument::Init();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mResizeImageByDefault =
    1:     nsContentUtils::GetBoolPref(AUTOMATIC_IMAGE_RESIZING_PREF);
30811:   mClickResizingEnabled =
30811:     nsContentUtils::GetBoolPref(CLICK_IMAGE_RESIZING_PREF);
    1:   mShouldResize = mResizeImageByDefault;
    1:   mFirstResize = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageDocument::StartDocumentLoad(const char*         aCommand,
    1:                                    nsIChannel*         aChannel,
    1:                                    nsILoadGroup*       aLoadGroup,
    1:                                    nsISupports*        aContainer,
    1:                                    nsIStreamListener** aDocListener,
    1:                                    PRBool              aReset,
    1:                                    nsIContentSink*     aSink)
    1: {
    1:   nsresult rv =
    1:     nsMediaDocument::StartDocumentLoad(aCommand, aChannel, aLoadGroup,
    1:                                        aContainer, aDocListener, aReset,
    1:                                        aSink);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
32357:   mOriginalZoomLevel =
32357:     nsContentUtils::GetBoolPref(SITE_SPECIFIC_ZOOM, PR_FALSE) ?
32357:       1.0 : GetZoomLevel();
32128: 
    1:   NS_ASSERTION(aDocListener, "null aDocListener");
    1:   *aDocListener = new ImageListener(this);
    1:   if (!*aDocListener)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*aDocListener);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsImageDocument::Destroy()
    1: {
    1:   if (mImageContent) {
    1:     // Remove our event listener from the image content.
    1:     nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(mImageContent);
    1:     target->RemoveEventListener(NS_LITERAL_STRING("click"), this, PR_FALSE);
    1: 
    1:     // Break reference cycle with mImageContent, if we have one
16327:     if (mObservingImageLoader) {
    1:       nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
    1:       if (imageLoader) {
    1:         imageLoader->RemoveObserver(this);
    1:       }
16327:     }
    1: 
    1:     mImageContent = nsnull;
    1:   }
    1: 
    1:   nsMediaDocument::Destroy();
    1: }
    1: 
    1: void
    1: nsImageDocument::SetScriptGlobalObject(nsIScriptGlobalObject* aScriptGlobalObject)
    1: {
    1:   // If the script global object is changing, we need to unhook our event
    1:   // listeners on the window.
    1:   nsCOMPtr<nsIDOMEventTarget> target;
    1:   if (mScriptGlobalObject &&
    1:       aScriptGlobalObject != mScriptGlobalObject) {
    1:     target = do_QueryInterface(mScriptGlobalObject);
    1:     target->RemoveEventListener(NS_LITERAL_STRING("resize"), this, PR_FALSE);
    1:     target->RemoveEventListener(NS_LITERAL_STRING("keypress"), this,
    1:                                 PR_FALSE);
    1:   }
    1: 
    1:   // Set the script global object on the superclass before doing
    1:   // anything that might require it....
    1:   nsHTMLDocument::SetScriptGlobalObject(aScriptGlobalObject);
    1: 
    1:   if (aScriptGlobalObject) {
41634:     if (!GetRootElement()) {
    1:       // Create synthetic document
19629: #ifdef DEBUG
19629:       nsresult rv =
19629: #endif
19629:         CreateSyntheticDocument();
    1:       NS_ASSERTION(NS_SUCCEEDED(rv), "failed to create synthetic document");
    1: 
    1:       target = do_QueryInterface(mImageContent);
    1:       target->AddEventListener(NS_LITERAL_STRING("click"), this, PR_FALSE);
    1:     }
    1: 
    1:     target = do_QueryInterface(aScriptGlobalObject);
    1:     target->AddEventListener(NS_LITERAL_STRING("resize"), this, PR_FALSE);
    1:     target->AddEventListener(NS_LITERAL_STRING("keypress"), this, PR_FALSE);
    1:   }
    1: }
    1: 
32128: void
32128: nsImageDocument::OnPageShow(PRBool aPersisted,
32128:                             nsIDOMEventTarget* aDispatchStartTarget)
32128: {
32128:   if (aPersisted) {
32357:     mOriginalZoomLevel =
32357:       nsContentUtils::GetBoolPref(SITE_SPECIFIC_ZOOM, PR_FALSE) ?
32357:         1.0 : GetZoomLevel();
32128:   }
32128:   nsMediaDocument::OnPageShow(aPersisted, aDispatchStartTarget);
32128: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::GetImageResizingEnabled(PRBool* aImageResizingEnabled)
    1: {
    1:   *aImageResizingEnabled = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::GetImageIsOverflowing(PRBool* aImageIsOverflowing)
    1: {
    1:   *aImageIsOverflowing = mImageIsOverflowing;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::GetImageIsResized(PRBool* aImageIsResized)
    1: {
    1:   *aImageIsResized = mImageIsResized;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::GetImageRequest(imgIRequest** aImageRequest)
    1: {
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
    1:   if (imageLoader) {
    1:     return imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                                    aImageRequest);
    1:   }
    1: 
    1:   *aImageRequest = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::ShrinkToFit()
    1: {
55836:   if (!mImageContent) {
55836:     return NS_OK;
55836:   }
33860:   if (GetZoomLevel() != mOriginalZoomLevel && mImageIsResized &&
33860:       !nsContentUtils::IsChildOfSameType(this)) {
11359:     return NS_OK;
11359:   }
11359: 
 4291:   // Keep image content alive while changing the attributes.
 4291:   nsCOMPtr<nsIContent> imageContent = mImageContent;
    1:   nsCOMPtr<nsIDOMHTMLImageElement> image = do_QueryInterface(mImageContent);
38390:   image->SetWidth(NS_MAX(1, NSToCoordFloor(GetRatio() * mImageWidth)));
38390:   image->SetHeight(NS_MAX(1, NSToCoordFloor(GetRatio() * mImageHeight)));
    1:   
14535:   // The view might have been scrolled when zooming in, scroll back to the
14535:   // origin now that we're showing a shrunk-to-window version.
14535:   (void) ScrollImageTo(0, 0, PR_FALSE);
14535: 
 4291:   imageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::style,
    1:                         NS_LITERAL_STRING("cursor: -moz-zoom-in"), PR_TRUE);
    1:   
    1:   mImageIsResized = PR_TRUE;
    1:   
    1:   UpdateTitleAndCharset();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::RestoreImageTo(PRInt32 aX, PRInt32 aY)
    1: {
14535:   return ScrollImageTo(aX, aY, PR_TRUE);
14535: }
14535: 
14535: nsresult
14535: nsImageDocument::ScrollImageTo(PRInt32 aX, PRInt32 aY, PRBool restoreImage)
14535: {
    1:   float ratio = GetRatio();
    1: 
14535:   if (restoreImage) {
    1:     RestoreImage();
    1:     FlushPendingNotifications(Flush_Layout);
14535:   }
    1: 
46225:   nsIPresShell *shell = GetShell();
    1:   if (!shell)
    1:     return NS_OK;
    1: 
37061:   nsIScrollableFrame* sf = shell->GetRootScrollFrameAsScrollable();
37061:   if (!sf)
    1:     return NS_OK;
    1: 
37061:   nsRect portRect = sf->GetScrollPortRect();
37061:   sf->ScrollTo(nsPoint(nsPresContext::CSSPixelsToAppUnits(aX/ratio) - portRect.width/2,
37061:                        nsPresContext::CSSPixelsToAppUnits(aY/ratio) - portRect.height/2),
37061:                nsIScrollableFrame::INSTANT);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::RestoreImage()
    1: {
55836:   if (!mImageContent) {
55836:     return NS_OK;
55836:   }
 4291:   // Keep image content alive while changing the attributes.
 4291:   nsCOMPtr<nsIContent> imageContent = mImageContent;
 4291:   imageContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::width, PR_TRUE);
 4291:   imageContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::height, PR_TRUE);
    1:   
    1:   if (mImageIsOverflowing) {
 4291:     imageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::style,
    1:                           NS_LITERAL_STRING("cursor: -moz-zoom-out"), PR_TRUE);
    1:   }
    1:   else {
 4291:     imageContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::style, PR_TRUE);
    1:   }
    1:   
    1:   mImageIsResized = PR_FALSE;
    1:   
    1:   UpdateTitleAndCharset();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::ToggleImageSize()
    1: {
    1:   mShouldResize = PR_TRUE;
    1:   if (mImageIsResized) {
    1:     mShouldResize = PR_FALSE;
32128:     ResetZoomLevel();
    1:     RestoreImage();
    1:   }
    1:   else if (mImageIsOverflowing) {
32128:     ResetZoomLevel();
    1:     ShrinkToFit();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageDocument::OnStartContainer(imgIRequest* aRequest, imgIContainer* aImage)
    1: {
    1:   aImage->GetWidth(&mImageWidth);
    1:   aImage->GetHeight(&mImageHeight);
35157:   nsCOMPtr<nsIRunnable> runnable =
41361:     NS_NewRunnableMethod(this, &nsImageDocument::DefaultCheckOverflowing);
35157:   nsContentUtils::AddScriptRunner(runnable);
    1:   UpdateTitleAndCharset();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
53658: nsImageDocument::OnStopDecode(imgIRequest *aRequest,
53658:                               nsresult aStatus,
53658:                               const PRUnichar *aStatusArg)
53658: {
53658:   UpdateTitleAndCharset();
53658: 
53658:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
53658:   if (imageLoader) {
53658:     mObservingImageLoader = PR_FALSE;
53658:     imageLoader->RemoveObserver(this);
53658:   }
53658: 
53658:   // mImageContent can be null if the document is already destroyed
53658:   if (NS_FAILED(aStatus) && mStringBundle && mImageContent) {
53658:     nsCAutoString src;
53658:     mDocumentURI->GetSpec(src);
53658:     NS_ConvertUTF8toUTF16 srcString(src);
53658:     const PRUnichar* formatString[] = { srcString.get() };
53658:     nsXPIDLString errorMsg;
53658:     NS_NAMED_LITERAL_STRING(str, "InvalidImage");
53658:     mStringBundle->FormatStringFromName(str.get(), formatString, 1,
53658:                                         getter_Copies(errorMsg));
53658: 
53658:     mImageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::alt, errorMsg, PR_FALSE);
53658:   }
53658: 
53658:   return NS_OK;
53658: }
53658: 
53658: NS_IMETHODIMP
    1: nsImageDocument::HandleEvent(nsIDOMEvent* aEvent)
    1: {
    1:   nsAutoString eventType;
    1:   aEvent->GetType(eventType);
    1:   if (eventType.EqualsLiteral("resize")) {
    1:     CheckOverflowing(PR_FALSE);
    1:   }
30811:   else if (eventType.EqualsLiteral("click") && mClickResizingEnabled) {
32128:     ResetZoomLevel();
    1:     mShouldResize = PR_TRUE;
    1:     if (mImageIsResized) {
    1:       PRInt32 x = 0, y = 0;
    1:       nsCOMPtr<nsIDOMMouseEvent> event(do_QueryInterface(aEvent));
    1:       if (event) {
    1:         event->GetClientX(&x);
    1:         event->GetClientY(&y);
    1:         PRInt32 left = 0, top = 0;
    1:         nsCOMPtr<nsIDOMNSHTMLElement> nsElement(do_QueryInterface(mImageContent));
    1:         nsElement->GetOffsetLeft(&left);
    1:         nsElement->GetOffsetTop(&top);
    1:         x -= left;
    1:         y -= top;
    1:       }
    1:       mShouldResize = PR_FALSE;
    1:       RestoreImageTo(x, y);
    1:     }
    1:     else if (mImageIsOverflowing) {
    1:       ShrinkToFit();
    1:     }
    1:   }
    1:   else if (eventType.EqualsLiteral("keypress")) {
    1:     nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aEvent);
    1:     PRUint32 charCode;
15300:     PRBool ctrlKey, metaKey, altKey;
    1:     keyEvent->GetCharCode(&charCode);
15300:     keyEvent->GetCtrlKey(&ctrlKey);
15300:     keyEvent->GetMetaKey(&metaKey);
15300:     keyEvent->GetAltKey(&altKey);
    1:     // plus key
15300:     if (charCode == 0x2B && !ctrlKey && !metaKey && !altKey) {
    1:       mShouldResize = PR_FALSE;
    1:       if (mImageIsResized) {
32128:         ResetZoomLevel();
    1:         RestoreImage();
    1:       }
    1:     }
    1:     // minus key
15300:     else if (charCode == 0x2D && !ctrlKey && !metaKey && !altKey) {
    1:       mShouldResize = PR_TRUE;
    1:       if (mImageIsOverflowing) {
32128:         ResetZoomLevel();
    1:         ShrinkToFit();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageDocument::CreateSyntheticDocument()
    1: {
    1:   // Synthesize an html document that refers to the image
    1:   nsresult rv = nsMediaDocument::CreateSyntheticDocument();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
41634:   Element* body = GetBodyElement();
    1:   if (!body) {
    1:     NS_WARNING("no body on image document!");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
19197:   nodeInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::img, nsnull,
29004:                                            kNameSpaceID_XHTML);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
48124:   mImageContent = NS_NewHTMLImageElement(nodeInfo.forget());
    1:   if (!mImageContent) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
    1:   NS_ENSURE_TRUE(imageLoader, NS_ERROR_UNEXPECTED);
    1: 
    1:   nsCAutoString src;
    1:   mDocumentURI->GetSpec(src);
    1: 
61720:   // Push a null JSContext on the stack so that code that runs within
61720:   // the below code doesn't think it's being called by JS. See bug
61720:   // 604262.
61720:   nsCxPusher pusher;
61720:   pusher.PushNull();
61720: 
    1:   NS_ConvertUTF8toUTF16 srcString(src);
    1:   // Make sure not to start the image load from here...
    1:   imageLoader->SetLoadingEnabled(PR_FALSE);
    1:   mImageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::src, srcString, PR_FALSE);
    1:   mImageContent->SetAttr(kNameSpaceID_None, nsGkAtoms::alt, srcString, PR_FALSE);
    1: 
    1:   body->AppendChildTo(mImageContent, PR_FALSE);
    1:   imageLoader->SetLoadingEnabled(PR_TRUE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageDocument::CheckOverflowing(PRBool changeState)
    1: {
 4043:   /* Create a scope so that the style context gets destroyed before we might
10073:    * call RebuildStyleData.  Also, holding onto pointers to the
 4043:    * presentatation through style resolution is potentially dangerous.
 4043:    */
 4043:   {
46225:     nsIPresShell *shell = GetShell();
    1:     if (!shell) {
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsPresContext *context = shell->GetPresContext();
    1:     nsRect visibleArea = context->GetVisibleArea();
    1: 
41634:     Element* body = GetBodyElement();
41634:     if (!body) {
    1:       NS_WARNING("no body on image document!");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsRefPtr<nsStyleContext> styleContext =
41634:       context->StyleSet()->ResolveStyleFor(body, nsnull);
    1: 
    1:     nsMargin m;
    1:     if (styleContext->GetStyleMargin()->GetMargin(m))
    1:       visibleArea.Deflate(m);
15992:     m = styleContext->GetStyleBorder()->GetActualBorder();
    1:     visibleArea.Deflate(m);
    1:     if (styleContext->GetStylePadding()->GetPadding(m))
    1:       visibleArea.Deflate(m);
    1: 
33860:     mVisibleWidth = nsPresContext::AppUnitsToIntCSSPixels(visibleArea.width);
33860:     mVisibleHeight = nsPresContext::AppUnitsToIntCSSPixels(visibleArea.height);
 4043:   }
    1: 
    1:   PRBool imageWasOverflowing = mImageIsOverflowing;
    1:   mImageIsOverflowing =
    1:     mImageWidth > mVisibleWidth || mImageHeight > mVisibleHeight;
    1:   PRBool windowBecameBigEnough = imageWasOverflowing && !mImageIsOverflowing;
    1: 
    1:   if (changeState || mShouldResize || mFirstResize ||
    1:       windowBecameBigEnough) {
    1:     if (mImageIsOverflowing && (changeState || mShouldResize)) {
    1:       ShrinkToFit();
    1:     }
    1:     else if (mImageIsResized || mFirstResize || windowBecameBigEnough) {
    1:       RestoreImage();
    1:     }
    1:   }
    1:   mFirstResize = PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void 
    1: nsImageDocument::UpdateTitleAndCharset()
    1: {
    1:   nsCAutoString typeStr;
    1:   nsCOMPtr<imgIRequest> imageRequest;
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mImageContent);
    1:   if (imageLoader) {
    1:     imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                             getter_AddRefs(imageRequest));
    1:   }
    1:     
    1:   if (imageRequest) {
    1:     nsXPIDLCString mimeType;
    1:     imageRequest->GetMimeType(getter_Copies(mimeType));
    1:     ToUpperCase(mimeType);
    1:     nsXPIDLCString::const_iterator start, end;
    1:     mimeType.BeginReading(start);
    1:     mimeType.EndReading(end);
    1:     nsXPIDLCString::const_iterator iter = end;
    1:     if (FindInReadable(NS_LITERAL_CSTRING("IMAGE/"), start, iter) && 
    1:         iter != end) {
    1:       // strip out "X-" if any
    1:       if (*iter == 'X') {
    1:         ++iter;
    1:         if (iter != end && *iter == '-') {
    1:           ++iter;
    1:           if (iter == end) {
    1:             // looks like "IMAGE/X-" is the type??  Bail out of here.
    1:             mimeType.BeginReading(iter);
    1:           }
    1:         } else {
    1:           --iter;
    1:         }
    1:       }
    1:       typeStr = Substring(iter, end);
    1:     } else {
    1:       typeStr = mimeType;
    1:     }
    1:   }
    1: 
    1:   nsXPIDLString status;
    1:   if (mImageIsResized) {
    1:     nsAutoString ratioStr;
    1:     ratioStr.AppendInt(NSToCoordFloor(GetRatio() * 100));
    1: 
    1:     const PRUnichar* formatString[1] = { ratioStr.get() };
    1:     mStringBundle->FormatStringFromName(NS_LITERAL_STRING("ScaledImage").get(),
    1:                                         formatString, 1,
    1:                                         getter_Copies(status));
    1:   }
    1: 
    1:   static const char* const formatNames[4] = 
    1:   {
    1:     "ImageTitleWithNeitherDimensionsNorFile",
    1:     "ImageTitleWithoutDimensions",
    1:     "ImageTitleWithDimensions",
    1:     "ImageTitleWithDimensionsAndFile",
    1:   };
    1: 
    1:   nsMediaDocument::UpdateTitleAndCharset(typeStr, formatNames,
    1:                                          mImageWidth, mImageHeight, status);
    1: }
    1: 
11359: void
32128: nsImageDocument::ResetZoomLevel()
11359: {
11359:   nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
11359:   if (docShell) {
33860:     if (nsContentUtils::IsChildOfSameType(this)) {
33860:       return;
33860:     }
33860: 
11359:     nsCOMPtr<nsIContentViewer> cv;
11359:     docShell->GetContentViewer(getter_AddRefs(cv));
11359:     nsCOMPtr<nsIMarkupDocumentViewer> mdv = do_QueryInterface(cv);
11359:     if (mdv) {
32128:       mdv->SetFullZoom(mOriginalZoomLevel);
11359:     }
11359:   }
11359: }
11359: 
11359: float
11359: nsImageDocument::GetZoomLevel()
11359: {
32128:   float zoomLevel = mOriginalZoomLevel;
11359:   nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
11359:   if (docShell) {
11359:     nsCOMPtr<nsIContentViewer> cv;
11359:     docShell->GetContentViewer(getter_AddRefs(cv));
11359:     nsCOMPtr<nsIMarkupDocumentViewer> mdv = do_QueryInterface(cv);
11359:     if (mdv) {
11359:       mdv->GetFullZoom(&zoomLevel);
11359:     }
11359:   }
11359:   return zoomLevel;
11359: }
    1: 
    1: nsresult
    1: NS_NewImageDocument(nsIDocument** aResult)
    1: {
    1:   nsImageDocument* doc = new nsImageDocument();
    1:   if (!doc) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ADDREF(doc);
    1:   nsresult rv = doc->Init();
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     NS_RELEASE(doc);
    1:   }
    1: 
    1:   *aResult = doc;
    1: 
    1:   return rv;
    1: }
