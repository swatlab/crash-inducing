    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is inline spellchecker code.
    1:  *
    1:  * The Initial Developer of the Original Code is Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004-2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brett Wilson <brettw@gmail.com> (original author)
    1:  *   Robert O'Callahan <rocallahan@novell.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "mozInlineSpellWordUtil.h"
    1: #include "nsDebug.h"
    1: #include "nsIAtom.h"
    1: #include "nsComponentManagerUtils.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
68870: #include "nsIDOMDocumentView.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNSRange.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIEditor.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMHTMLBRElement.h"
 5409: #include "nsUnicharUtilCIID.h"
 5409: #include "nsServiceManagerUtils.h"
33290: #include "nsIContent.h"
49292: #include "nsTextFragment.h"
    1: 
    1: // IsIgnorableCharacter
    1: //
    1: //    These characters are ones that we should ignore in input.
    1: 
    1: inline PRBool IsIgnorableCharacter(PRUnichar ch)
    1: {
    1:   return (ch == 0x200D || // ZERO-WIDTH JOINER
    1:           ch == 0xAD ||   // SOFT HYPHEN
    1:           ch == 0x1806);  // MONGOLIAN TODO SOFT HYPHEN
    1: }
    1: 
    1: // IsConditionalPunctuation
    1: //
    1: //    Some characters (like apostrophes) require characters on each side to be
    1: //    part of a word, and are otherwise punctuation.
    1: 
    1: inline PRBool IsConditionalPunctuation(PRUnichar ch)
    1: {
    1:   return (ch == '\'' ||
    1:           ch == 0x2019); // RIGHT SINGLE QUOTATION MARK
    1: }
    1: 
    1: // mozInlineSpellWordUtil::Init
    1: 
    1: nsresult
    1: mozInlineSpellWordUtil::Init(nsWeakPtr aWeakEditor)
    1: {
    1:   nsresult rv;
    1: 
 5409:   mCategories = do_GetService(NS_UNICHARCATEGORY_CONTRACTID, &rv);
 5409:   if (NS_FAILED(rv))
 5409:     return rv;
 5409:   
    1:   // getting the editor can fail commonly because the editor was detached, so
    1:   // don't assert
    1:   nsCOMPtr<nsIEditor> editor = do_QueryReferent(aWeakEditor, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   rv = editor->GetDocument(getter_AddRefs(domDoc));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mDocument = do_QueryInterface(domDoc, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mDOMDocumentRange = do_QueryInterface(domDoc, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // view
68870:   nsCOMPtr<nsIDOMDocumentView> docView = do_QueryInterface(domDoc, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
68870:   nsCOMPtr<nsIDOMAbstractView> abstractView;
68870:   rv = docView->GetDefaultView(getter_AddRefs(abstractView));
68870:   NS_ENSURE_SUCCESS(rv, rv);
68870:   mCSSView = do_QueryInterface(abstractView, &rv);
68870:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Find the root node for the editor. For contenteditable we'll need something
    1:   // cleverer here.
    1:   nsCOMPtr<nsIDOMElement> rootElt;
    1:   rv = editor->GetRootElement(getter_AddRefs(rootElt));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   mRootNode = rootElt;
    1:   NS_ASSERTION(mRootNode, "GetRootElement returned null *and* claimed to suceed!");
    1:   return NS_OK;
    1: }
    1: 
    1: static PRBool
    1: IsTextNode(nsIDOMNode* aNode)
    1: {
    1:   PRUint16 type = 0;
    1:   aNode->GetNodeType(&type);
    1:   return type == nsIDOMNode::TEXT_NODE;
    1: }
    1: 
    1: typedef void (* OnLeaveNodeFunPtr)(nsIDOMNode* aNode, void* aClosure);
    1: 
    1: // Find the next node in the DOM tree in preorder. This isn't fast because
    1: // one call to GetNextSibling can be O(N) in the number of siblings...
    1: // Calls OnLeaveNodeFunPtr when the traversal leaves a node
42872: // XXXbz if this used nsINode, this would be trivial
    1: static nsIDOMNode*
    1: FindNextNode(nsIDOMNode* aNode, nsIDOMNode* aRoot,
    1:              OnLeaveNodeFunPtr aOnLeaveNode = nsnull, void* aClosure = nsnull)
    1: {
    1:   NS_PRECONDITION(aNode, "Null starting node?");
    1: 
    1:   nsCOMPtr<nsIDOMNode> next;
    1:   aNode->GetFirstChild(getter_AddRefs(next));
    1:   if (next)
    1:     return next;
    1:   
    1:   // Don't look at siblings or otherwise outside of aRoot
    1:   if (aNode == aRoot)
    1:     return nsnull;
    1: 
    1:   aNode->GetNextSibling(getter_AddRefs(next));
    1:   if (next)
    1:     return next;
    1: 
    1:   // Go up
    1:   for (;;) {
    1:     if (aOnLeaveNode) {
    1:       aOnLeaveNode(aNode, aClosure);
    1:     }
    1:     
    1:     aNode->GetParentNode(getter_AddRefs(next));
    1:     if (next == aRoot || ! next)
    1:       return nsnull;
    1:     aNode = next;
    1:     
    1:     aNode->GetNextSibling(getter_AddRefs(next));
    1:     if (next)
    1:       return next;
    1:   }
    1: }
    1: 
    1: // aNode is not a text node. Find the first text node starting at aNode/aOffset
    1: // in a preorder DOM traversal.
    1: static nsIDOMNode*
    1: FindNextTextNode(nsIDOMNode* aNode, PRInt32 aOffset, nsIDOMNode* aRoot)
    1: {
    1:   NS_PRECONDITION(aNode, "Null starting node?");
    1:   NS_ASSERTION(!IsTextNode(aNode), "FindNextTextNode should start with a non-text node");
    1: 
33290:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
33290:   nsCOMPtr<nsIDOMNode> checkNode;
    1:   // Need to start at the aOffset'th child
33290:   nsIContent* child = node->GetChildAt(aOffset);
33290: 
    1:   if (child) {
33290:     checkNode = do_QueryInterface(child);
    1:   } else {
22436:     // aOffset was beyond the end of the child list. 
22436:     // goto next node in a preorder DOM traversal.
42872:     // XXXbz this is generally reimplementing GetNextNode.
42872:     nsINode* next = node->GetNextSibling();
33290:     if (!next) {
33290:       nsCOMPtr<nsINode> root = do_QueryInterface(aRoot);
22436:       while (!next) {
22436:         // Go up
33290:         next = node->GetNodeParent();
33290:         if (next == root || !next) {
22436:           return nsnull;
    1:         }
33290:         node = next;
42872:         next = node->GetNextSibling();
22436:       }
33290:     }
33290:     checkNode = do_QueryInterface(next);
    1:   }
    1:   
    1:   while (checkNode && !IsTextNode(checkNode)) {
    1:     checkNode = FindNextNode(checkNode, aRoot);
    1:   }
33290:   return checkNode.get();
    1: }
    1: 
    1: // mozInlineSpellWordUtil::SetEnd
    1: //
    1: //    We have two ranges "hard" and "soft". The hard boundary is simply
    1: //    the scope of the root node. The soft boundary is that which is set
    1: //    by the caller of this class by calling this function. If this function is
    1: //    not called, the soft boundary is the same as the hard boundary.
    1: //
    1: //    When we reach the soft boundary (mSoftEnd), we keep
    1: //    going until we reach the end of a word. This allows the caller to set the
    1: //    end of the range to anything, and we will always check whole multiples of
    1: //    words. When we reach the hard boundary we stop no matter what.
    1: //
    1: //    There is no beginning soft boundary. This is because we only go to the
    1: //    previous node once, when finding the previous word boundary in
    1: //    SetPosition(). You might think of the soft boundary as being this initial
    1: //    position.
    1: 
    1: nsresult
    1: mozInlineSpellWordUtil::SetEnd(nsIDOMNode* aEndNode, PRInt32 aEndOffset)
    1: {
    1:   NS_PRECONDITION(aEndNode, "Null end node?");
    1: 
    1:   NS_ASSERTION(mRootNode, "Not initialized");
    1: 
    1:   InvalidateWords();
    1: 
    1:   if (!IsTextNode(aEndNode)) {
    1:     // End at the start of the first text node after aEndNode/aEndOffset.
    1:     aEndNode = FindNextTextNode(aEndNode, aEndOffset, mRootNode);
    1:     aEndOffset = 0;
    1:   }
    1:   mSoftEnd = NodeOffset(aEndNode, aEndOffset);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: mozInlineSpellWordUtil::SetPosition(nsIDOMNode* aNode, PRInt32 aOffset)
    1: {
    1:   InvalidateWords();
    1: 
    1:   if (!IsTextNode(aNode)) {
    1:     // Start at the start of the first text node after aNode/aOffset.
    1:     aNode = FindNextTextNode(aNode, aOffset, mRootNode);
    1:     aOffset = 0;
    1:   }
    1:   mSoftBegin = NodeOffset(aNode, aOffset);
    1: 
    1:   EnsureWords();
    1:   
    1:   PRInt32 textOffset = MapDOMPositionToSoftTextOffset(mSoftBegin);
    1:   if (textOffset < 0)
    1:     return NS_OK;
    1:   mNextWordIndex = FindRealWordContaining(textOffset, HINT_END, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: mozInlineSpellWordUtil::EnsureWords()
    1: {
    1:   if (mSoftTextValid)
    1:     return;
    1:   BuildSoftText();
    1:   BuildRealWords();
    1:   mSoftTextValid = PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: mozInlineSpellWordUtil::MakeRangeForWord(const RealWord& aWord, nsIDOMRange** aRange)
    1: {
    1:   NodeOffset begin = MapSoftTextOffsetToDOMPosition(aWord.mSoftTextOffset, HINT_BEGIN);
    1:   NodeOffset end = MapSoftTextOffsetToDOMPosition(aWord.EndOffset(), HINT_END);
    1:   return MakeRange(begin, end, aRange);
    1: }
    1: 
    1: // mozInlineSpellWordUtil::GetRangeForWord
    1: 
    1: nsresult
    1: mozInlineSpellWordUtil::GetRangeForWord(nsIDOMNode* aWordNode,
    1:                                         PRInt32 aWordOffset,
    1:                                         nsIDOMRange** aRange)
    1: {
    1:   // Set our soft end and start
    1:   NodeOffset pt = NodeOffset(aWordNode, aWordOffset);
    1:   
    1:   InvalidateWords();
    1:   mSoftBegin = mSoftEnd = pt;
    1:   EnsureWords();
    1:   
    1:   PRInt32 offset = MapDOMPositionToSoftTextOffset(pt);
    1:   if (offset < 0)
    1:     return MakeRange(pt, pt, aRange);
    1:   PRInt32 wordIndex = FindRealWordContaining(offset, HINT_BEGIN, PR_FALSE);
    1:   if (wordIndex < 0)
    1:     return MakeRange(pt, pt, aRange);
    1:   return MakeRangeForWord(mRealWords[wordIndex], aRange);
    1: }
    1: 
    1: // This is to fix characters that the spellchecker may not like
    1: static void
    1: NormalizeWord(const nsSubstring& aInput, PRInt32 aPos, PRInt32 aLen, nsAString& aOutput)
    1: {
    1:   aOutput.Truncate();
    1:   for (PRInt32 i = 0; i < aLen; i++) {
    1:     PRUnichar ch = aInput.CharAt(i + aPos);
    1: 
    1:     // remove ignorable characters from the word
    1:     if (IsIgnorableCharacter(ch))
    1:       continue;
    1: 
    1:     // the spellchecker doesn't handle curly apostrophes in all languages
    1:     if (ch == 0x2019) { // RIGHT SINGLE QUOTATION MARK
    1:       ch = '\'';
    1:     }
    1: 
    1:     aOutput.Append(ch);
    1:   }
    1: }
    1: 
    1: // mozInlineSpellWordUtil::GetNextWord
    1: //
    1: //    FIXME-optimization: we shouldn't have to generate a range every single
    1: //    time. It would be better if the inline spellchecker didn't require a
    1: //    range unless the word was misspelled. This may or may not be possible.
    1: 
    1: nsresult
    1: mozInlineSpellWordUtil::GetNextWord(nsAString& aText, nsIDOMRange** aRange,
    1:                                     PRBool* aSkipChecking)
    1: {
    1: #ifdef DEBUG_SPELLCHECK
    1:   printf("GetNextWord called; mNextWordIndex=%d\n", mNextWordIndex);
    1: #endif
    1: 
    1:   if (mNextWordIndex < 0 ||
    1:       mNextWordIndex >= PRInt32(mRealWords.Length())) {
    1:     mNextWordIndex = -1;
    1:     *aRange = nsnull;
    1:     *aSkipChecking = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1:   
    1:   const RealWord& word = mRealWords[mNextWordIndex];
    1:   nsresult rv = MakeRangeForWord(word, aRange);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   ++mNextWordIndex;
    1:   *aSkipChecking = !word.mCheckableWord;
    1:   ::NormalizeWord(mSoftText, word.mSoftTextOffset, word.mLength, aText);
    1: 
    1: #ifdef DEBUG_SPELLCHECK
    1:   printf("GetNextWord returning: %s (skip=%d)\n",
    1:          NS_ConvertUTF16toUTF8(aText).get(), *aSkipChecking);
    1: #endif
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: // mozInlineSpellWordUtil::MakeRange
    1: //
    1: //    Convenience function for creating a range over the current document.
    1: 
    1: nsresult
    1: mozInlineSpellWordUtil::MakeRange(NodeOffset aBegin, NodeOffset aEnd,
    1:                                   nsIDOMRange** aRange)
    1: {
    1:   if (! mDOMDocumentRange)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   nsresult rv = mDOMDocumentRange->CreateRange(aRange);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = (*aRange)->SetStart(aBegin.mNode, aBegin.mOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = (*aRange)->SetEnd(aEnd.mNode, aEnd.mOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /*********** DOM text extraction ************/
    1: 
    1: // IsDOMWordSeparator
    1: //
    1: //    Determines if the given character should be considered as a DOM Word
    1: //    separator. Basically, this is whitespace, although it could also have
    1: //    certain punctuation that we know ALWAYS breaks words. This is important.
    1: //    For example, we can't have any punctuation that could appear in a URL
    1: //    or email address in this, because those need to always fit into a single
    1: //    DOM word.
    1: 
    1: static PRBool
    1: IsDOMWordSeparator(PRUnichar ch)
    1: {
    1:   // simple spaces
    1:   if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')
    1:     return PR_TRUE;
    1: 
    1:   // complex spaces - check only if char isn't ASCII (uncommon)
    1:   if (ch >= 0xA0 &&
    1:       (ch == 0x00A0 ||  // NO-BREAK SPACE
    1:        ch == 0x2002 ||  // EN SPACE
    1:        ch == 0x2003 ||  // EM SPACE
    1:        ch == 0x2009 ||  // THIN SPACE
    1:        ch == 0x200C ||  // ZERO WIDTH NON-JOINER
    1:        ch == 0x3000))   // IDEOGRAPHIC SPACE
    1:     return PR_TRUE;
    1: 
    1:   // otherwise not a space
    1:   return PR_FALSE;
    1: }
    1: 
    1: static PRBool
    1: IsBRElement(nsIDOMNode* aNode)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIDOMHTMLBRElement> elt = do_QueryInterface(aNode, &rv);
    1:   return NS_SUCCEEDED(rv);
    1: }
    1: 
    1: // Find the previous node in the DOM tree in preorder. This isn't fast because
    1: // one call to GetPrevSibling can be O(N) in the number of siblings...
    1: static nsIDOMNode*
    1: FindPrevNode(nsIDOMNode* aNode, nsIDOMNode* aRoot)
    1: {
    1:   if (aNode == aRoot)
    1:     return nsnull;
    1:   
    1:   nsCOMPtr<nsIDOMNode> prev;
    1:   aNode->GetPreviousSibling(getter_AddRefs(prev));
    1:   if (prev) {
    1:     for (;;) {
    1:       nsCOMPtr<nsIDOMNode> lastChild;
    1:       prev->GetLastChild(getter_AddRefs(lastChild));
    1:       if (!lastChild)
    1:         return prev;
    1:       prev = lastChild;
    1:     }
    1:   }
    1: 
    1:   // No prev sibling. So we are the first child of our parent, if any. Our
    1:   // parent is our previous node.
    1:   aNode->GetParentNode(getter_AddRefs(prev));
    1:   return prev;
    1: }
    1: 
    1: /**
    1:  * Check if there's a DOM word separator before aBeforeOffset in this node.
    1:  * Always returns PR_TRUE if it's a BR element.
54192:  * aSeparatorOffset is set to the index of the first character in the last
54192:  * separator if any is found (0 for BR elements).
54192:  *
54192:  * This function does not modify aSeparatorOffset when it returns false.
    1:  */
    1: static PRBool
    1: ContainsDOMWordSeparator(nsIDOMNode* aNode, PRInt32 aBeforeOffset,
    1:                          PRInt32* aSeparatorOffset)
    1: {
    1:   if (IsBRElement(aNode)) {
    1:     *aSeparatorOffset = 0;
    1:     return PR_TRUE;
    1:   }
    1:   
    1:   if (!IsTextNode(aNode))
    1:     return PR_FALSE;
    1: 
49292:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
49292:   NS_ASSERTION(content, "Where is our content?");
49292:   const nsTextFragment* textFragment = content->GetText();
49292:   NS_ASSERTION(textFragment, "Where is our text?");
49292:   for (PRInt32 i = NS_MIN(aBeforeOffset, PRInt32(textFragment->GetLength())) - 1; i >= 0; --i) {
49292:     if (IsDOMWordSeparator(textFragment->CharAt(i))) {
54192:       // Be greedy, find as many separators as we can
54192:       for (PRInt32 j = i - 1; j >= 0; --j) {
54192:         if (IsDOMWordSeparator(textFragment->CharAt(j))) {
54192:           i = j;
54192:         } else {
54192:           break;
54192:         }
54192:       }
    1:       *aSeparatorOffset = i;
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: static PRBool
68870: IsBreakElement(nsIDOMViewCSS* aDocView, nsIDOMNode* aNode)
    1: {
    1:   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aNode);
    1:   if (!element)
    1:     return PR_FALSE;
    1:     
    1:   if (IsBRElement(aNode))
    1:     return PR_TRUE;
    1:   
    1:   nsCOMPtr<nsIDOMCSSStyleDeclaration> style;
    1:   aDocView->GetComputedStyle(element, EmptyString(), getter_AddRefs(style));
    1:   if (!style)
    1:     return PR_FALSE;
    1: 
    1: #ifdef DEBUG_SPELLCHECK
    1:   printf("    searching element %p\n", (void*)aNode);
    1: #endif
    1: 
    1:   nsAutoString display;
    1:   style->GetPropertyValue(NS_LITERAL_STRING("display"), display);
    1: #ifdef DEBUG_SPELLCHECK
    1:   printf("      display=\"%s\"\n", NS_ConvertUTF16toUTF8(display).get());
    1: #endif
    1:   if (!display.EqualsLiteral("inline"))
    1:     return PR_TRUE;
    1: 
    1:   nsAutoString position;
    1:   style->GetPropertyValue(NS_LITERAL_STRING("position"), position);
    1: #ifdef DEBUG_SPELLCHECK
    1:   printf("      position=%s\n", NS_ConvertUTF16toUTF8(position).get());
    1: #endif
    1:   if (!position.EqualsLiteral("static"))
    1:     return PR_TRUE;
    1:     
    1:   // XXX What about floats? What else?
    1:   return PR_FALSE;
    1: }
    1: 
    1: struct CheckLeavingBreakElementClosure {
68870:   nsIDOMViewCSS* mDocView;
    1:   PRPackedBool   mLeftBreakElement;
    1: };
    1: 
    1: static void
    1: CheckLeavingBreakElement(nsIDOMNode* aNode, void* aClosure)
    1: {
    1:   CheckLeavingBreakElementClosure* cl =
 3233:     static_cast<CheckLeavingBreakElementClosure*>(aClosure);
    1:   if (!cl->mLeftBreakElement && IsBreakElement(cl->mDocView, aNode)) {
    1:     cl->mLeftBreakElement = PR_TRUE;
    1:   }
    1: }
    1: 
    1: void
    1: mozInlineSpellWordUtil::NormalizeWord(nsSubstring& aWord)
    1: {
    1:   nsAutoString result;
    1:   ::NormalizeWord(aWord, 0, aWord.Length(), result);
    1:   aWord = result;
    1: }
    1: 
    1: void
    1: mozInlineSpellWordUtil::BuildSoftText()
    1: {
    1:   // First we have to work backwards from mSoftStart to find a text node
    1:   // containing a DOM word separator, a non-inline-element
    1:   // boundary, or the hard start node. That's where we'll start building the
    1:   // soft string from.
    1:   nsIDOMNode* node = mSoftBegin.mNode;
    1:   PRInt32 firstOffsetInNode = 0;
    1:   PRInt32 checkBeforeOffset = mSoftBegin.mOffset;
    1:   while (node) {
54191:     if (ContainsDOMWordSeparator(node, checkBeforeOffset, &firstOffsetInNode)) {
54191:       if (node == mSoftBegin.mNode) {
54191:         // If we find a word separator on the first node, look at the preceding
54191:         // word on the text node as well.
54191:         PRInt32 newOffset = 0;
54191:         if (firstOffsetInNode > 0) {
54191:           // Try to find the previous word boundary.  We ignore the return value
54191:           // of ContainsDOMWordSeparator here because there might be no preceding
54191:           // word separator (such as when we're at the end of the first word in
54191:           // the text node), in which case we just set the found offsets to 0.
54191:           // Otherwise, ContainsDOMWordSeparator finds us the correct word
54191:           // boundary so that we can avoid looking at too many words.
54191:           ContainsDOMWordSeparator(node, firstOffsetInNode - 1, &newOffset);
54191:         }
54191:         firstOffsetInNode = newOffset;
54191:         mSoftBegin.mOffset = newOffset;
54191:       }
    1:       break;
54191:     }
    1:     checkBeforeOffset = PR_INT32_MAX;
    1:     if (IsBreakElement(mCSSView, node)) {
    1:       // Since FindPrevNode follows tree *preorder*, we're about to traverse
    1:       // up out of 'node'. Since node induces breaks (e.g., it's a block),
    1:       // don't bother trying to look outside it, just stop now.
    1:       break;
    1:     }
    1:     node = FindPrevNode(node, mRootNode);
    1:   }
    1: 
    1:   // Now build up the string moving forward through the DOM until we reach
    1:   // the soft end and *then* see a DOM word separator, a non-inline-element
    1:   // boundary, or the hard end node.
    1:   mSoftText.Truncate();
    1:   mSoftTextDOMMapping.Clear();
    1:   PRBool seenSoftEnd = PR_FALSE;
    1:   // Leave this outside the loop so large heap string allocations can be reused
    1:   // across iterations
    1:   while (node) {
    1:     if (node == mSoftEnd.mNode) {
    1:       seenSoftEnd = PR_TRUE;
    1:     }
    1: 
    1:     PRBool exit = PR_FALSE;
    1:     if (IsTextNode(node)) {
49292:       nsCOMPtr<nsIContent> content = do_QueryInterface(node);
49292:       NS_ASSERTION(content, "Where is our content?");
49292:       const nsTextFragment* textFragment = content->GetText();
49292:       NS_ASSERTION(textFragment, "Where is our text?");
49292:       PRInt32 lastOffsetInNode = textFragment->GetLength();
    1: 
    1:       if (seenSoftEnd) {
    1:         // check whether we can stop after this
    1:         for (PRInt32 i = node == mSoftEnd.mNode ? mSoftEnd.mOffset : 0;
49292:              i < PRInt32(textFragment->GetLength()); ++i) {
49292:           if (IsDOMWordSeparator(textFragment->CharAt(i))) {
    1:             exit = PR_TRUE;
    1:             // stop at the first separator after the soft end point
    1:             lastOffsetInNode = i;
    1:             break;
    1:           }
    1:         }
    1:       }
    1:       
    1:       if (firstOffsetInNode < lastOffsetInNode) {
    1:         PRInt32 len = lastOffsetInNode - firstOffsetInNode;
    1:         mSoftTextDOMMapping.AppendElement(
    1:           DOMTextMapping(NodeOffset(node, firstOffsetInNode), mSoftText.Length(), len));
49292:         textFragment->AppendTo(mSoftText, firstOffsetInNode, len);
    1:       }
    1:       
    1:       firstOffsetInNode = 0;
    1:     }
    1: 
    1:     if (exit)
    1:       break;
    1: 
    1:     CheckLeavingBreakElementClosure closure = { mCSSView, PR_FALSE };
    1:     node = FindNextNode(node, mRootNode, CheckLeavingBreakElement, &closure);
    1:     if (closure.mLeftBreakElement || (node && IsBreakElement(mCSSView, node))) {
    1:       // We left, or are entering, a break element (e.g., block). Maybe we can
    1:       // stop now.
    1:       if (seenSoftEnd)
    1:         break;
    1:       // Record the break
    1:       mSoftText.Append(' ');
    1:     }
    1:   }
    1:   
    1: #ifdef DEBUG_SPELLCHECK
    1:   printf("Got DOM string: %s\n", NS_ConvertUTF16toUTF8(mSoftText).get());
    1: #endif
    1: }
    1: 
    1: void
    1: mozInlineSpellWordUtil::BuildRealWords()
    1: {
    1:   // This is pretty simple. We just have to walk mSoftText, tokenizing it
    1:   // into "real words".
    1:   // We do an outer traversal of words delimited by IsDOMWordSeparator, calling
    1:   // SplitDOMWord on each of those DOM words
    1:   PRInt32 wordStart = -1;
    1:   mRealWords.Clear();
    1:   for (PRInt32 i = 0; i < PRInt32(mSoftText.Length()); ++i) {
    1:     if (IsDOMWordSeparator(mSoftText.CharAt(i))) {
    1:       if (wordStart >= 0) {
    1:         SplitDOMWord(wordStart, i);
    1:         wordStart = -1;
    1:       }
    1:     } else {
    1:       if (wordStart < 0) {
    1:         wordStart = i;
    1:       }
    1:     }
    1:   }
    1:   if (wordStart >= 0) {
    1:     SplitDOMWord(wordStart, mSoftText.Length());
    1:   }
    1: }
    1: 
    1: /*********** DOM/realwords<->mSoftText mapping functions ************/
    1: 
    1: PRInt32
    1: mozInlineSpellWordUtil::MapDOMPositionToSoftTextOffset(NodeOffset aNodeOffset)
    1: {
    1:   if (!mSoftTextValid) {
    1:     NS_ERROR("Soft text must be valid if we're to map into it");
    1:     return -1;
    1:   }
    1:   
    1:   for (PRInt32 i = 0; i < PRInt32(mSoftTextDOMMapping.Length()); ++i) {
    1:     const DOMTextMapping& map = mSoftTextDOMMapping[i];
    1:     if (map.mNodeOffset.mNode == aNodeOffset.mNode) {
    1:       // Allow offsets at either end of the string, in particular, allow the
    1:       // offset that's at the end of the contributed string
    1:       PRInt32 offsetInContributedString =
    1:         aNodeOffset.mOffset - map.mNodeOffset.mOffset;
    1:       if (offsetInContributedString >= 0 &&
    1:           offsetInContributedString <= map.mLength)
    1:         return map.mSoftTextOffset + offsetInContributedString;
    1:       return -1;
    1:     }
    1:   }
    1:   return -1;
    1: }
    1: 
    1: mozInlineSpellWordUtil::NodeOffset
    1: mozInlineSpellWordUtil::MapSoftTextOffsetToDOMPosition(PRInt32 aSoftTextOffset,
    1:                                                        DOMMapHint aHint)
    1: {
    1:   NS_ASSERTION(mSoftTextValid, "Soft text must be valid if we're to map out of it");
    1:   if (!mSoftTextValid)
    1:     return NodeOffset(nsnull, -1);
    1:   
    1:   // The invariant is that the range start..end includes the last mapping,
    1:   // if any, such that mSoftTextOffset <= aSoftTextOffset
    1:   PRInt32 start = 0;
    1:   PRInt32 end = mSoftTextDOMMapping.Length();
    1:   while (end - start >= 2) {
    1:     PRInt32 mid = (start + end)/2;
    1:     const DOMTextMapping& map = mSoftTextDOMMapping[mid];
    1:     if (map.mSoftTextOffset > aSoftTextOffset) {
    1:       end = mid;
    1:     } else {
    1:       start = mid;
    1:     }
    1:   }
    1:   
    1:   if (start >= end)
    1:     return NodeOffset(nsnull, -1);
    1: 
    1:   // 'start' is now the last mapping, if any, such that
    1:   // mSoftTextOffset <= aSoftTextOffset.
    1:   // If we're doing HINT_END, then we may want to return the end of the
    1:   // the previous mapping instead of the start of this mapping
    1:   if (aHint == HINT_END && start > 0) {
    1:     const DOMTextMapping& map = mSoftTextDOMMapping[start - 1];
    1:     if (map.mSoftTextOffset + map.mLength == aSoftTextOffset)
    1:       return NodeOffset(map.mNodeOffset.mNode, map.mNodeOffset.mOffset + map.mLength);
    1:   }
    1:   
    1:   // We allow ourselves to return the end of this mapping even if we're
    1:   // doing HINT_START. This will only happen if there is no mapping which this
    1:   // point is the start of. I'm not 100% sure this is OK...
    1:   const DOMTextMapping& map = mSoftTextDOMMapping[start];
    1:   PRInt32 offset = aSoftTextOffset - map.mSoftTextOffset;
    1:   if (offset >= 0 && offset <= map.mLength)
    1:     return NodeOffset(map.mNodeOffset.mNode, map.mNodeOffset.mOffset + offset);
    1:     
    1:   return NodeOffset(nsnull, -1);
    1: }
    1: 
    1: PRInt32
    1: mozInlineSpellWordUtil::FindRealWordContaining(PRInt32 aSoftTextOffset,
    1:     DOMMapHint aHint, PRBool aSearchForward)
    1: {
    1:   NS_ASSERTION(mSoftTextValid, "Soft text must be valid if we're to map out of it");
    1:   if (!mSoftTextValid)
    1:     return -1;
    1: 
    1:   // The invariant is that the range start..end includes the last word,
    1:   // if any, such that mSoftTextOffset <= aSoftTextOffset
    1:   PRInt32 start = 0;
    1:   PRInt32 end = mRealWords.Length();
    1:   while (end - start >= 2) {
    1:     PRInt32 mid = (start + end)/2;
    1:     const RealWord& word = mRealWords[mid];
    1:     if (word.mSoftTextOffset > aSoftTextOffset) {
    1:       end = mid;
    1:     } else {
    1:       start = mid;
    1:     }
    1:   }
    1:   
    1:   if (start >= end)
    1:     return -1;
    1: 
    1:   // 'start' is now the last word, if any, such that
    1:   // mSoftTextOffset <= aSoftTextOffset.
    1:   // If we're doing HINT_END, then we may want to return the end of the
    1:   // the previous word instead of the start of this word
    1:   if (aHint == HINT_END && start > 0) {
    1:     const RealWord& word = mRealWords[start - 1];
    1:     if (word.mSoftTextOffset + word.mLength == aSoftTextOffset)
    1:       return start - 1;
    1:   }
    1:   
    1:   // We allow ourselves to return the end of this word even if we're
    1:   // doing HINT_START. This will only happen if there is no word which this
    1:   // point is the start of. I'm not 100% sure this is OK...
    1:   const RealWord& word = mRealWords[start];
    1:   PRInt32 offset = aSoftTextOffset - word.mSoftTextOffset;
    1:   if (offset >= 0 && offset <= word.mLength)
    1:     return start;
    1: 
    1:   if (aSearchForward) {
    1:     if (mRealWords[0].mSoftTextOffset > aSoftTextOffset) {
    1:       // All words have mSoftTextOffset > aSoftTextOffset
    1:       return 0;
    1:     }
    1:     // 'start' is the last word such that mSoftTextOffset <= aSoftTextOffset.
    1:     // Word start+1, if it exists, will be the first with
    1:     // mSoftTextOffset > aSoftTextOffset.
    1:     if (start + 1 < PRInt32(mRealWords.Length()))
    1:       return start + 1;
    1:   }
    1: 
    1:   return -1;
    1: }
    1: 
    1: /*********** Word Splitting ************/
    1: 
    1: // classifies a given character in the DOM word
    1: enum CharClass {
    1:   CHAR_CLASS_WORD,
    1:   CHAR_CLASS_SEPARATOR,
    1:   CHAR_CLASS_END_OF_INPUT };
    1: 
    1: // Encapsulates DOM-word to real-word splitting
    1: struct WordSplitState
    1: {
    1:   mozInlineSpellWordUtil*    mWordUtil;
    1:   const nsDependentSubstring mDOMWordText;
    1:   PRInt32                    mDOMWordOffset;
    1:   CharClass                  mCurCharClass;
    1: 
    1:   WordSplitState(mozInlineSpellWordUtil* aWordUtil,
    1:                  const nsString& aString, PRInt32 aStart, PRInt32 aLen)
    1:     : mWordUtil(aWordUtil), mDOMWordText(aString, aStart, aLen),
    1:       mDOMWordOffset(0), mCurCharClass(CHAR_CLASS_END_OF_INPUT) {}
    1: 
    1:   CharClass ClassifyCharacter(PRInt32 aIndex, PRBool aRecurse) const;
    1:   void Advance();
    1:   void AdvanceThroughSeparators();
    1:   void AdvanceThroughWord();
    1: 
    1:   // Finds special words like email addresses and URLs that may start at the
    1:   // current position, and returns their length, or 0 if not found. This allows
    1:   // arbitrary word breaking rules to be used for these special entities, as
    1:   // long as they can not contain whitespace.
    1:   PRInt32 FindSpecialWord();
    1: 
    1:   // Similar to FindSpecialWord except that this takes a split word as
    1:   // input. This checks for things that do not require special word-breaking
    1:   // rules.
    1:   PRBool ShouldSkipWord(PRInt32 aStart, PRInt32 aLength);
    1: };
    1: 
    1: // WordSplitState::ClassifyCharacter
    1: 
    1: CharClass
    1: WordSplitState::ClassifyCharacter(PRInt32 aIndex, PRBool aRecurse) const
    1: {
    1:   NS_ASSERTION(aIndex >= 0 && aIndex <= PRInt32(mDOMWordText.Length()),
    1:                "Index out of range");
    1:   if (aIndex == PRInt32(mDOMWordText.Length()))
    1:     return CHAR_CLASS_SEPARATOR;
    1: 
    1:   // this will classify the character, we want to treat "ignorable" characters
    1:   // such as soft hyphens as word characters.
 5409:   nsIUGenCategory::nsUGenCategory
 5409:     charCategory = mWordUtil->GetCategories()->Get(PRUint32(mDOMWordText[aIndex]));
 5409:   if (charCategory == nsIUGenCategory::kLetter ||
    1:       IsIgnorableCharacter(mDOMWordText[aIndex]))
    1:     return CHAR_CLASS_WORD;
    1: 
    1:   // If conditional punctuation is surrounded immediately on both sides by word
    1:   // characters it also counts as a word character.
    1:   if (IsConditionalPunctuation(mDOMWordText[aIndex])) {
    1:     if (!aRecurse) {
    1:       // not allowed to look around, this punctuation counts like a separator
    1:       return CHAR_CLASS_SEPARATOR;
    1:     }
    1: 
    1:     // check the left-hand character
    1:     if (aIndex == 0)
    1:       return CHAR_CLASS_SEPARATOR;
    1:     if (ClassifyCharacter(aIndex - 1, false) != CHAR_CLASS_WORD)
    1:       return CHAR_CLASS_SEPARATOR;
68618:     // If the previous charatcer is a word-char, make sure that it's not a
68618:     // special dot character.
68618:     if (mDOMWordText[aIndex - 1] == '.')
68618:       return CHAR_CLASS_SEPARATOR;
    1: 
    1:     // now we know left char is a word-char, check the right-hand character
    1:     if (aIndex == PRInt32(mDOMWordText.Length()) - 1)
    1:       return CHAR_CLASS_SEPARATOR;
    1:     if (ClassifyCharacter(aIndex + 1, false) != CHAR_CLASS_WORD)
    1:       return CHAR_CLASS_SEPARATOR;
68618:     // If the next charatcer is a word-char, make sure that it's not a
68618:     // special dot character.
68618:     if (mDOMWordText[aIndex + 1] == '.')
68618:       return CHAR_CLASS_SEPARATOR;
    1: 
    1:     // char on either side is a word, this counts as a word
    1:     return CHAR_CLASS_WORD;
    1:   }
    1: 
68618:   // The dot character, if appearing at the end of a word, should
68618:   // be considered part of that word.  Example: "etc.", or
68618:   // abbreviations
68618:   if (aIndex > 0 &&
68618:       mDOMWordText[aIndex] == '.' &&
68618:       mDOMWordText[aIndex - 1] != '.' &&
68618:       ClassifyCharacter(aIndex - 1, false) != CHAR_CLASS_WORD) {
68618:     return CHAR_CLASS_WORD;
68618:   }
68618: 
    1:   // all other punctuation
 5409:   if (charCategory == nsIUGenCategory::kSeparator ||
 5409:       charCategory == nsIUGenCategory::kOther ||
 5409:       charCategory == nsIUGenCategory::kPunctuation ||
68618:       charCategory == nsIUGenCategory::kSymbol) {
68618:     // Don't break on hyphens, as hunspell handles them on its own.
68618:     if (aIndex > 0 &&
68618:         mDOMWordText[aIndex] == '-' &&
68618:         mDOMWordText[aIndex - 1] != '-' &&
68618:         ClassifyCharacter(aIndex - 1, false) == CHAR_CLASS_WORD) {
68618:       // A hyphen is only meaningful as a separator inside a word
68618:       // if the previous and next characters are a word character.
68618:       if (aIndex == PRInt32(mDOMWordText.Length()) - 1)
    1:         return CHAR_CLASS_SEPARATOR;
68618:       if (mDOMWordText[aIndex + 1] != '.' &&
68618:           ClassifyCharacter(aIndex + 1, false) == CHAR_CLASS_WORD)
68618:         return CHAR_CLASS_WORD;
68618:     }
68618:     return CHAR_CLASS_SEPARATOR;
68618:   }
    1: 
    1:   // any other character counts as a word
    1:   return CHAR_CLASS_WORD;
    1: }
    1: 
    1: 
    1: // WordSplitState::Advance
    1: 
    1: void
    1: WordSplitState::Advance()
    1: {
    1:   NS_ASSERTION(mDOMWordOffset >= 0, "Negative word index");
    1:   NS_ASSERTION(mDOMWordOffset < (PRInt32)mDOMWordText.Length(),
    1:                "Length beyond end");
    1: 
    1:   mDOMWordOffset ++;
    1:   if (mDOMWordOffset >= (PRInt32)mDOMWordText.Length())
    1:     mCurCharClass = CHAR_CLASS_END_OF_INPUT;
    1:   else
    1:     mCurCharClass = ClassifyCharacter(mDOMWordOffset, PR_TRUE);
    1: }
    1: 
    1: 
    1: // WordSplitState::AdvanceThroughSeparators
    1: 
    1: void
    1: WordSplitState::AdvanceThroughSeparators()
    1: {
    1:   while (mCurCharClass == CHAR_CLASS_SEPARATOR)
    1:     Advance();
    1: }
    1: 
    1: // WordSplitState::AdvanceThroughWord
    1: 
    1: void
    1: WordSplitState::AdvanceThroughWord()
    1: {
    1:   while (mCurCharClass == CHAR_CLASS_WORD)
    1:     Advance();
    1: }
    1: 
    1: 
    1: // WordSplitState::FindSpecialWord
    1: 
    1: PRInt32
    1: WordSplitState::FindSpecialWord()
    1: {
    1:   PRInt32 i;
    1: 
    1:   // Search for email addresses. We simply define these as any sequence of
    1:   // characters with an '@' character in the middle. The DOM word is already
    1:   // split on whitepace, so we know that everything to the end is the address
    1:   //
    1:   // Also look for periods, this tells us if we want to run the URL finder.
    1:   PRBool foundDot = PR_FALSE;
    1:   PRInt32 firstColon = -1;
    1:   for (i = mDOMWordOffset;
    1:        i < PRInt32(mDOMWordText.Length()); i ++) {
    1:     if (mDOMWordText[i] == '@') {
    1:       // only accept this if there are unambiguous word characters (don't bother
    1:       // recursing to disambiguate apostrophes) on each side. This prevents
    1:       // classifying, e.g. "@home" as an email address
    1: 
    1:       // Use this condition to only accept words with '@' in the middle of
    1:       // them. It works, but the inlinespellcker doesn't like this. The problem
    1:       // is that you type "fhsgfh@" that's a misspelled word followed by a
    1:       // symbol, but when you type another letter "fhsgfh@g" that first word
    1:       // need to be unmarked misspelled. It doesn't do this. it only checks the
    1:       // current position for potentially removing a spelling range.
    1:       if (i > 0 && ClassifyCharacter(i - 1, PR_FALSE) == CHAR_CLASS_WORD &&
    1:           i < (PRInt32)mDOMWordText.Length() - 1 &&
    1:           ClassifyCharacter(i + 1, PR_FALSE) == CHAR_CLASS_WORD)
    1: 
    1:       return mDOMWordText.Length() - mDOMWordOffset;
    1:     } else if (mDOMWordText[i] == '.' && ! foundDot &&
    1:         i > 0 && i < (PRInt32)mDOMWordText.Length() - 1) {
    1:       // we found a period not at the end, we should check harder for URLs
    1:       foundDot = PR_TRUE;
    1:     } else if (mDOMWordText[i] == ':' && firstColon < 0) {
    1:       firstColon = i;
    1:     }
    1:   }
    1: 
    1:   // If the first colon is followed by a slash, consider it a URL
    1:   // This will catch things like asdf://foo.com
    1:   if (firstColon >= 0 && firstColon < (PRInt32)mDOMWordText.Length() - 1 &&
    1:       mDOMWordText[firstColon + 1] == '/') {
    1:     return mDOMWordText.Length() - mDOMWordOffset;
    1:   }
    1: 
    1:   // Check the text before the first colon against some known protocols. It
    1:   // is impossible to check against all protocols, especially since you can
    1:   // plug in new protocols. We also don't want to waste time here checking
    1:   // against a lot of obscure protocols.
    1:   if (firstColon > mDOMWordOffset) {
    1:     nsString protocol(Substring(mDOMWordText, mDOMWordOffset,
    1:                       firstColon - mDOMWordOffset));
    1:     if (protocol.EqualsIgnoreCase("http") ||
    1:         protocol.EqualsIgnoreCase("https") ||
    1:         protocol.EqualsIgnoreCase("news") ||
    1:         protocol.EqualsIgnoreCase("ftp") ||
    1:         protocol.EqualsIgnoreCase("file") ||
    1:         protocol.EqualsIgnoreCase("javascript") ||
    1:         protocol.EqualsIgnoreCase("ftp")) {
    1:       return mDOMWordText.Length() - mDOMWordOffset;
    1:     }
    1:   }
    1: 
    1:   // not anything special
    1:   return -1;
    1: }
    1: 
    1: // WordSplitState::ShouldSkipWord
    1: 
    1: PRBool
    1: WordSplitState::ShouldSkipWord(PRInt32 aStart, PRInt32 aLength)
    1: {
    1:   PRInt32 last = aStart + aLength;
    1: 
    1:   // check to see if the word contains a digit
    1:   for (PRInt32 i = aStart; i < last; i ++) {
    1:     PRUnichar ch = mDOMWordText[i];
    1:     // XXX Shouldn't this be something a lot more complex, Unicode-based?
    1:     if (ch >= '0' && ch <= '9')
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   // not special
    1:   return PR_FALSE;
    1: }
    1: 
    1: // mozInlineSpellWordUtil::SplitDOMWord
    1: 
    1: void
    1: mozInlineSpellWordUtil::SplitDOMWord(PRInt32 aStart, PRInt32 aEnd)
    1: {
    1:   WordSplitState state(this, mSoftText, aStart, aEnd - aStart);
    1:   state.mCurCharClass = state.ClassifyCharacter(0, PR_TRUE);
    1: 
    1:   while (state.mCurCharClass != CHAR_CLASS_END_OF_INPUT) {
    1:     state.AdvanceThroughSeparators();
    1:     if (state.mCurCharClass == CHAR_CLASS_END_OF_INPUT)
    1:       break;
    1: 
    1:     PRInt32 specialWordLength = state.FindSpecialWord();
    1:     if (specialWordLength > 0) {
    1:       mRealWords.AppendElement(
    1:         RealWord(aStart + state.mDOMWordOffset, specialWordLength, PR_FALSE));
    1: 
    1:       // skip the special word
    1:       state.mDOMWordOffset += specialWordLength;
    1:       if (state.mDOMWordOffset + aStart >= aEnd)
    1:         state.mCurCharClass = CHAR_CLASS_END_OF_INPUT;
    1:       else
    1:         state.mCurCharClass = state.ClassifyCharacter(state.mDOMWordOffset, PR_TRUE);
    1:       continue;
    1:     }
    1: 
    1:     // save the beginning of the word
    1:     PRInt32 wordOffset = state.mDOMWordOffset;
    1: 
    1:     // find the end of the word
    1:     state.AdvanceThroughWord();
    1:     PRInt32 wordLen = state.mDOMWordOffset - wordOffset;
    1:     mRealWords.AppendElement(
    1:       RealWord(aStart + wordOffset, wordLen,
    1:                !state.ShouldSkipWord(wordOffset, wordLen)));
    1:   }
    1: }
