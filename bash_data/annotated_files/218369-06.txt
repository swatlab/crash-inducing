162892: /* This Source Code Form is subject to the terms of the Mozilla Public
162892:  * License, v. 2.0. If a copy of the MPL was not distributed with this
162892:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
162892: 
162892: #ifndef CacheStorageService__h__
162892: #define CacheStorageService__h__
162892: 
162892: #include "nsICacheStorageService.h"
191183: #include "nsIMemoryReporter.h"
162892: 
196910: #include "nsITimer.h"
162892: #include "nsClassHashtable.h"
214756: #include "nsDataHashtable.h"
162892: #include "nsString.h"
162892: #include "nsThreadUtils.h"
162892: #include "nsProxyRelease.h"
162892: #include "mozilla/Mutex.h"
162892: #include "mozilla/Atomics.h"
214756: #include "mozilla/TimeStamp.h"
162892: #include "nsTArray.h"
162892: 
162892: class nsIURI;
162892: class nsICacheEntryOpenCallback;
162892: class nsICacheEntryDoomCallback;
162892: class nsICacheStorageVisitor;
162892: class nsIRunnable;
162892: class nsIThread;
162892: class nsIEventTarget;
162892: 
162892: namespace mozilla {
162892: namespace net {
162892: 
162892: class CacheStorageService;
162892: class CacheStorage;
162892: class CacheEntry;
179522: class CacheEntryHandle;
162892: class CacheEntryTable;
162892: 
162892: class CacheMemoryConsumer
162892: {
162892: private:
162892:   friend class CacheStorageService;
196910:   uint32_t mReportedMemoryConsumption : 30;
196910:   uint32_t mFlags : 2;
196910: 
196910: private:
196910:   CacheMemoryConsumer() MOZ_DELETE;
196910: 
162892: protected:
196910:   enum {
196910:     // No special treatment, reports always to the disk-entries pool.
196910:     NORMAL = 0,
196910:     // This consumer is belonging to a memory-only cache entry, used to decide
196910:     // which of the two disk and memory pools count this consumption at.
196910:     MEMORY_ONLY = 1 << 0,
196910:     // Prevent reports of this consumer at all, used for disk data chunks since
196910:     // we throw them away as soon as the entry is not used by any consumer and
196910:     // don't want to make them wipe the whole pool out during their short life.
196910:     DONT_REPORT = 1 << 1
196910:   };
196910: 
196910:   CacheMemoryConsumer(uint32_t aFlags);
196910:   ~CacheMemoryConsumer() { DoMemoryReport(0); }
162892:   void DoMemoryReport(uint32_t aCurrentSize);
162892: };
162892: 
162892: class CacheStorageService : public nsICacheStorageService
191183:                           , public nsIMemoryReporter
196910:                           , public nsITimerCallback
162892: {
162892: public:
162892:   NS_DECL_THREADSAFE_ISUPPORTS
162892:   NS_DECL_NSICACHESTORAGESERVICE
191183:   NS_DECL_NSIMEMORYREPORTER
196910:   NS_DECL_NSITIMERCALLBACK
162892: 
162892:   CacheStorageService();
162892: 
162892:   void Shutdown();
162892:   void DropPrivateBrowsingEntries();
162892: 
205824:   // Takes care of deleting any pending trashes for both cache1 and cache2
205824:   // as well as the cache directory of an inactive cache version when requested.
205824:   static void CleaupCacheDirectories(uint32_t aVersion, uint32_t aActive);
185299: 
162892:   static CacheStorageService* Self() { return sSelf; }
191183:   static nsISupports* SelfISupports() { return static_cast<nsICacheStorageService*>(Self()); }
162892:   nsresult Dispatch(nsIRunnable* aEvent);
162892:   static bool IsRunning() { return sSelf && !sSelf->mShutdown; }
181625:   static bool IsOnManagementThread();
181625:   already_AddRefed<nsIEventTarget> Thread() const;
162892:   mozilla::Mutex& Lock() { return mLock; }
162892: 
201508:   // Helper thread-safe interface to pass entry info, only difference from
201508:   // nsICacheStorageVisitor is that instead of nsIURI only the uri spec is
201508:   // passed.
201508:   class EntryInfoCallback {
201508:   public:
201508:     virtual void OnEntryInfo(const nsACString & aURISpec, const nsACString & aIdEnhance,
201508:                              int64_t aDataSize, int32_t aFetchCount,
201508:                              uint32_t aLastModifiedTime, uint32_t aExpirationTime) = 0;
201508:   };
201508: 
201508:   // Invokes OnEntryInfo for the given aEntry, synchronously.
201508:   static void GetCacheEntryInfo(CacheEntry* aEntry, EntryInfoCallback *aVisitor);
201508: 
191183:   // Memory reporting
191183:   size_t SizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const;
191183:   size_t SizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const;
191183:   MOZ_DEFINE_MALLOC_SIZE_OF(MallocSizeOf)
191183: 
162892: private:
162892:   virtual ~CacheStorageService();
162892:   void ShutdownBackground();
162892: 
162892: private:
162892:   // The following methods may only be called on the management
162892:   // thread.
162892:   friend class CacheEntry;
162892: 
162892:   /**
162892:    * Registers the entry in management ordered arrays, a mechanism
162892:    * helping with weighted purge of entries.
162892:    * Management arrays keep hard reference to the entry.  Entry is
162892:    * responsible to remove it self or the service is responsible to
162892:    * remove the entry when it's no longer needed.
162892:    */
162892:   void RegisterEntry(CacheEntry* aEntry);
162892: 
162892:   /**
162892:    * Deregisters the entry from management arrays.  References are
162892:    * then released.
162892:    */
162892:   void UnregisterEntry(CacheEntry* aEntry);
162892: 
162892:   /**
162892:    * Removes the entry from the related entry hash table, if still present.
162892:    */
179522:   bool RemoveEntry(CacheEntry* aEntry, bool aOnlyUnreferenced = false);
162892: 
162892:   /**
162892:    * Tells the storage service whether this entry is only to be stored in
162892:    * memory.
162892:    */
162892:   void RecordMemoryOnlyEntry(CacheEntry* aEntry,
162892:                              bool aOnlyInMemory,
162892:                              bool aOverwrite);
162892: 
162892: private:
214756:   // These are helpers for telemetry monitorying of the memory pools.
214756:   void TelemetryPrune(TimeStamp &now);
214756:   void TelemetryRecordEntryCreation(CacheEntry const* entry);
214756:   void TelemetryRecordEntryRemoval(CacheEntry const* entry);
214756: 
214756: private:
162892:   // Following methods are thread safe to call.
162892:   friend class CacheStorage;
162892: 
162892:   /**
162892:    * Get, or create when not existing and demanded, an entry for the storage
162892:    * and uri+id extension.
162892:    */
162892:   nsresult AddStorageEntry(CacheStorage const* aStorage,
162892:                            nsIURI* aURI,
162892:                            const nsACString & aIdExtension,
162892:                            bool aCreateIfNotExist,
162892:                            bool aReplace,
179522:                            CacheEntryHandle** aResult);
162892: 
162892:   /**
212449:    * Check existance of an entry.  This may throw NS_ERROR_NOT_AVAILABLE
212449:    * when the information cannot be obtained synchronously w/o blocking.
212449:    */
212449:   nsresult CheckStorageEntry(CacheStorage const* aStorage,
212449:                              nsIURI* aURI,
212449:                              const nsACString & aIdExtension,
212449:                              bool* aResult);
212449: 
212449:   /**
162892:    * Removes the entry from the related entry hash table, if still present
162892:    * and returns it.
162892:    */
162892:   nsresult DoomStorageEntry(CacheStorage const* aStorage,
162892:                             nsIURI* aURI,
162892:                             const nsACString & aIdExtension,
162892:                             nsICacheEntryDoomCallback* aCallback);
162892: 
162892:   /**
162892:    * Removes and returns entry table for the storage.
162892:    */
162892:   nsresult DoomStorageEntries(CacheStorage const* aStorage,
162892:                               nsICacheEntryDoomCallback* aCallback);
162892: 
162892:   /**
162892:    * Walk all entiries beloging to the storage.
162892:    */
162892:   nsresult WalkStorageEntries(CacheStorage const* aStorage,
162892:                               bool aVisitEntries,
162892:                               nsICacheStorageVisitor* aVisitor);
162892: 
196908: private:
196908:   friend class CacheFileIOManager;
196908: 
191180:   /**
191180:    * CacheFileIOManager uses this method to notify CacheStorageService that
191180:    * an active entry was removed. This method is called even if the entry
191180:    * removal was originated by CacheStorageService.
191180:    */
196908:   void CacheFileDoomed(nsILoadContextInfo* aLoadContextInfo,
196908:                        const nsACString & aIdExtension,
196908:                        const nsACString & aURISpec);
191180: 
201508:   /**
201508:    * Tries to find an existing entry in the hashtables and synchronously call
201508:    * OnCacheEntryInfo of the aVisitor callback when found.
201508:    * @retuns
201508:    *   true, when the entry has been found that also implies the callbacks has
201508:    *        beem invoked
201508:    *   false, when an entry has not been found
201508:    */
201508:   bool GetCacheEntryInfo(nsILoadContextInfo* aLoadContextInfo,
201508:                          const nsACString & aIdExtension,
201508:                          const nsACString & aURISpec,
201508:                          EntryInfoCallback *aCallback);
201508: 
162892: private:
162892:   friend class CacheMemoryConsumer;
162892: 
162892:   /**
162892:    * When memory consumption of this entry radically changes, this method
162892:    * is called to reflect the size of allocated memory.  This call may purge
162892:    * unspecified number of entries from memory (but not from disk).
162892:    */
162892:   void OnMemoryConsumptionChange(CacheMemoryConsumer* aConsumer,
162892:                                  uint32_t aCurrentMemoryConsumption);
196910: 
196910:   /**
196910:    * If not already pending, it schedules mPurgeTimer that fires after 1 second
196910:    * and dispatches PurgeOverMemoryLimit().
196910:    */
196910:   void SchedulePurgeOverMemoryLimit();
196910: 
196910:   /**
196910:    * Called on the management thread, removes all expired and then least used
196910:    * entries from the memory, first from the disk pool and then from the memory
196910:    * pool.
196910:    */
162892:   void PurgeOverMemoryLimit();
162892: 
162892: private:
162892:   nsresult DoomStorageEntries(nsCSubstring const& aContextKey,
197520:                               nsILoadContextInfo* aContext,
162892:                               bool aDiskStorage,
162892:                               nsICacheEntryDoomCallback* aCallback);
162892:   nsresult AddStorageEntry(nsCSubstring const& aContextKey,
162892:                            nsIURI* aURI,
162892:                            const nsACString & aIdExtension,
162892:                            bool aWriteToDisk,
162892:                            bool aCreateIfNotExist,
162892:                            bool aReplace,
179522:                            CacheEntryHandle** aResult);
162892: 
162892:   static CacheStorageService* sSelf;
162892: 
162892:   mozilla::Mutex mLock;
162892: 
162892:   bool mShutdown;
162892: 
162892:   // Accessible only on the service thread
196910:   class MemoryPool
196910:   {
196910:   public:
196910:     enum EType
196910:     {
196910:       DISK,
196910:       MEMORY,
196910:     } mType;
196910: 
196910:     MemoryPool(EType aType);
196910:     ~MemoryPool();
196910: 
162892:     nsTArray<nsRefPtr<CacheEntry> > mFrecencyArray;
162892:     nsTArray<nsRefPtr<CacheEntry> > mExpirationArray;
162892:     mozilla::Atomic<uint32_t> mMemorySize;
196910: 
196910:     bool OnMemoryConsumptionChange(uint32_t aSavedMemorySize,
196910:                                    uint32_t aCurrentMemoryConsumption);
196910:     /**
196910:      * Purges entries from memory based on the frecency ordered array.
196910:      */
196910:     void PurgeOverMemoryLimit();
196910:     void PurgeExpired();
196910:     void PurgeByFrecency(bool &aFrecencyNeedsSort, uint32_t aWhat);
196910:     void PurgeAll(uint32_t aWhat);
196910: 
196910:   private:
196910:     uint32_t const Limit() const;
196910:     MemoryPool() MOZ_DELETE;
196910:   };
196910: 
196910:   MemoryPool mDiskPool;
196910:   MemoryPool mMemoryPool;
196910:   MemoryPool& Pool(bool aUsingDisk)
196910:   {
196910:     return aUsingDisk ? mDiskPool : mMemoryPool;
196910:   }
196910:   MemoryPool const& Pool(bool aUsingDisk) const
196910:   {
196910:     return aUsingDisk ? mDiskPool : mMemoryPool;
196910:   }
196910: 
196910:   nsCOMPtr<nsITimer> mPurgeTimer;
196910: 
196910:   class PurgeFromMemoryRunnable : public nsRunnable
196910:   {
196910:   public:
196910:     PurgeFromMemoryRunnable(CacheStorageService* aService, uint32_t aWhat)
196910:       : mService(aService), mWhat(aWhat) { }
196910: 
196910:   private:
196910:     virtual ~PurgeFromMemoryRunnable() { }
196910: 
196910:     NS_IMETHOD Run()
196910:     {
196910:       // TODO not all flags apply to both pools
196910:       mService->Pool(true).PurgeAll(mWhat);
196910:       mService->Pool(false).PurgeAll(mWhat);
196910:       return NS_OK;
196910:     }
196910: 
196910:     nsRefPtr<CacheStorageService> mService;
196910:     uint32_t mWhat;
196910:   };
214756: 
214756:   // Used just for telemetry purposes, accessed only on the management thread.
214756:   // Note: not included in the memory reporter, this is not expected to be huge
214756:   // and also would be complicated to report since reporting happens on the main
214756:   // thread but this table is manipulated on the management thread.
214756:   nsDataHashtable<nsCStringHashKey, mozilla::TimeStamp> mPurgeTimeStamps;
162892: };
162892: 
162892: template<class T>
172237: void ProxyRelease(nsCOMPtr<T> &object, nsIThread* thread)
162892: {
162892:   T* release;
162892:   object.forget(&release);
162892: 
172237:   NS_ProxyRelease(thread, release);
172237: }
172237: 
172237: template<class T>
172237: void ProxyReleaseMainThread(nsCOMPtr<T> &object)
172237: {
172237:   nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
172237:   ProxyRelease(object, mainThread);
162892: }
162892: 
162892: } // net
162892: } // mozilla
162892: 
162892: #define NS_CACHE_STORAGE_SERVICE_CID \
162892:   { 0xea70b098, 0x5014, 0x4e21, \
162892:   { 0xae, 0xe1, 0x75, 0xe6, 0xb2, 0xc4, 0xb8, 0xe0 } } \
162892: 
162892: #define NS_CACHE_STORAGE_SERVICE_CONTRACTID \
162892:   "@mozilla.org/netwerk/cache-storage-service;1"
162892: 
210530: #define NS_CACHE_STORAGE_SERVICE_CONTRACTID2 \
210530:   "@mozilla.org/network/cache-storage-service;1"
210530: 
162892: #endif
