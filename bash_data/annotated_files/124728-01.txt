120195: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
120195:  */
120195: /* This Source Code Form is subject to the terms of the Mozilla Public
120195:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
120195:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
120195: 
120195: #ifndef js_heap_api_h___
120195: #define js_heap_api_h___
120195: 
124728: #include "jsfriendapi.h"
124728: 
120196: /* These values are private to the JS engine. */
120196: namespace js {
120196: namespace gc {
120195: 
120196: /*
120196:  * Page size must be static to support our arena pointer optimizations, so we
120196:  * are forced to support each platform with non-4096 pages as a special case.
120196:  * Note: The freelist supports a maximum arena shift of 15.
120196:  * Note: Do not use JS_CPU_SPARC here, this header is used outside JS.
120196:  */
120196: #if (defined(SOLARIS) || defined(__FreeBSD__)) && \
120196:     (defined(__sparc) || defined(__sparcv9) || defined(__ia64))
120196: const size_t PageShift = 13;
120196: const size_t ArenaShift = PageShift;
121078: #elif defined(__powerpc64__)
120196: const size_t PageShift = 16;
120196: const size_t ArenaShift = 12;
120196: #else
120196: const size_t PageShift = 12;
120196: const size_t ArenaShift = PageShift;
120196: #endif
120196: const size_t PageSize = size_t(1) << PageShift;
120196: const size_t ArenaSize = size_t(1) << ArenaShift;
120196: const size_t ArenaMask = ArenaSize - 1;
120196: 
120196: const size_t ChunkShift = 20;
120196: const size_t ChunkSize = size_t(1) << ChunkShift;
120196: const size_t ChunkMask = ChunkSize - 1;
120196: 
120196: } /* namespace gc */
120196: } /* namespace js */
120196: 
120196: namespace JS {
124506: 
120196: namespace shadow {
120196: 
120196: struct ArenaHeader
120196: {
120196:     JSCompartment *compartment;
120196: };
120196: 
120196: } /* namespace shadow */
120196: 
120196: static inline shadow::ArenaHeader *
120196: GetGCThingArena(void *thing)
120196: {
120196:     uintptr_t addr = uintptr_t(thing);
120196:     addr &= ~js::gc::ArenaMask;
120196:     return reinterpret_cast<shadow::ArenaHeader *>(addr);
120196: }
120195: 
120195: static inline JSCompartment *
120195: GetGCThingCompartment(void *thing)
120195: {
120195:     JS_ASSERT(thing);
124506:     return GetGCThingArena(thing)->compartment;
120195: }
120195: 
120195: static inline JSCompartment *
120195: GetObjectCompartment(JSObject *obj)
120195: {
120195:     return GetGCThingCompartment(obj);
120195: }
120195: 
124728: /*
124728:  * This should be called when an object that is marked gray is exposed to the JS
124728:  * engine (by handing it to running JS code or writing it into live JS
124728:  * data). During incremental GC, since the gray bits haven't been computed yet,
124728:  * we conservatively mark the object black.
124728:  */
124728: static JS_ALWAYS_INLINE void
124728: ExposeGCThingToActiveJS(void *thing, JSGCTraceKind kind)
124728: {
124728:     JS_ASSERT(kind != JSTRACE_SHAPE);
124728: 
124728:     if (js::GCThingIsMarkedGray(thing))
124728:         js::UnmarkGrayGCThingRecursively(thing, kind);
124728:     else if (js::IsIncrementalBarrierNeededOnGCThing(thing, kind))
124728:         js::IncrementalReferenceBarrier(thing);
124728: }
124728: 
120196: } /* namespace JS */
120195: 
120195: #endif /* js_heap_api_h___ */
