16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: basic shared codebook operations
31034:  last mod: $Id: sharedbook.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: #include <stdlib.h>
16295: #include <math.h>
16295: #include <string.h>
16295: #include <ogg/ogg.h>
16295: #include "os.h"
16295: #include "misc.h"
16295: #include "vorbis/codec.h"
16295: #include "codebook.h"
16295: #include "scales.h"
16295: 
16295: /**** pack/unpack helpers ******************************************/
16295: int _ilog(unsigned int v){
16295:   int ret=0;
16295:   while(v){
16295:     ret++;
16295:     v>>=1;
16295:   }
16295:   return(ret);
16295: }
16295: 
16295: /* 32 bit float (not IEEE; nonnormalized mantissa +
16295:    biased exponent) : neeeeeee eeemmmmm mmmmmmmm mmmmmmmm
16295:    Why not IEEE?  It's just not that important here. */
16295: 
16295: #define VQ_FEXP 10
16295: #define VQ_FMAN 21
16295: #define VQ_FEXP_BIAS 768 /* bias toward values smaller than 1. */
16295: 
16295: /* doesn't currently guard under/overflow */
16295: long _float32_pack(float val){
16295:   int sign=0;
16295:   long exp;
16295:   long mant;
16295:   if(val<0){
16295:     sign=0x80000000;
16295:     val= -val;
16295:   }
16295:   exp= floor(log(val)/log(2.f));
16295:   mant=rint(ldexp(val,(VQ_FMAN-1)-exp));
16295:   exp=(exp+VQ_FEXP_BIAS)<<VQ_FMAN;
16295: 
16295:   return(sign|exp|mant);
16295: }
16295: 
16295: float _float32_unpack(long val){
16295:   double mant=val&0x1fffff;
16295:   int    sign=val&0x80000000;
16295:   long   exp =(val&0x7fe00000L)>>VQ_FMAN;
16295:   if(sign)mant= -mant;
16295:   return(ldexp(mant,exp-(VQ_FMAN-1)-VQ_FEXP_BIAS));
16295: }
16295: 
16295: /* given a list of word lengths, generate a list of codewords.  Works
16295:    for length ordered or unordered, always assigns the lowest valued
16295:    codewords first.  Extended to handle unused entries (length 0) */
16295: ogg_uint32_t *_make_words(long *l,long n,long sparsecount){
16295:   long i,j,count=0;
16295:   ogg_uint32_t marker[33];
16295:   ogg_uint32_t *r=_ogg_malloc((sparsecount?sparsecount:n)*sizeof(*r));
16295:   memset(marker,0,sizeof(marker));
16295: 
16295:   for(i=0;i<n;i++){
16295:     long length=l[i];
16295:     if(length>0){
16295:       ogg_uint32_t entry=marker[length];
16295: 
16295:       /* when we claim a node for an entry, we also claim the nodes
16295:          below it (pruning off the imagined tree that may have dangled
16295:          from it) as well as blocking the use of any nodes directly
16295:          above for leaves */
16295: 
16295:       /* update ourself */
16295:       if(length<32 && (entry>>length)){
16295:         /* error condition; the lengths must specify an overpopulated tree */
16295:         _ogg_free(r);
16295:         return(NULL);
16295:       }
16295:       r[count++]=entry;
16295: 
16295:       /* Look to see if the next shorter marker points to the node
16295:          above. if so, update it and repeat.  */
16295:       {
16295:         for(j=length;j>0;j--){
16295: 
16295:           if(marker[j]&1){
16295:             /* have to jump branches */
16295:             if(j==1)
16295:               marker[1]++;
16295:             else
16295:               marker[j]=marker[j-1]<<1;
16295:             break; /* invariant says next upper marker would already
16295:                       have been moved if it was on the same path */
16295:           }
16295:           marker[j]++;
16295:         }
16295:       }
16295: 
16295:       /* prune the tree; the implicit invariant says all the longer
16295:          markers were dangling from our just-taken node.  Dangle them
16295:          from our *new* node. */
16295:       for(j=length+1;j<33;j++)
16295:         if((marker[j]>>1) == entry){
16295:           entry=marker[j];
16295:           marker[j]=marker[j-1]<<1;
16295:         }else
16295:           break;
16295:     }else
16295:       if(sparsecount==0)count++;
16295:   }
16295: 
30043:   /* sanity check the huffman tree; an underpopulated tree must be
30043:      rejected. The only exception is the one-node pseudo-nil tree,
30043:      which appears to be underpopulated because the tree doesn't
30043:      really exist; there's only one possible 'codeword' or zero bits,
30043:      but the above tree-gen code doesn't mark that. */
30043:   if(sparsecount != 1){
30043:     for(i=1;i<33;i++)
30043:       if(marker[i] & (0xffffffffUL>>(32-i))){
30043: 	_ogg_free(r);
30043: 	return(NULL);
30043:       }
30043:   }
30043: 
16295:   /* bitreverse the words because our bitwise packer/unpacker is LSb
16295:      endian */
16295:   for(i=0,count=0;i<n;i++){
16295:     ogg_uint32_t temp=0;
16295:     for(j=0;j<l[i];j++){
16295:       temp<<=1;
16295:       temp|=(r[count]>>j)&1;
16295:     }
16295: 
16295:     if(sparsecount){
16295:       if(l[i])
16295:         r[count++]=temp;
16295:     }else
16295:       r[count++]=temp;
16295:   }
16295: 
16295:   return(r);
16295: }
16295: 
16295: /* there might be a straightforward one-line way to do the below
16295:    that's portable and totally safe against roundoff, but I haven't
16295:    thought of it.  Therefore, we opt on the side of caution */
16295: long _book_maptype1_quantvals(const static_codebook *b){
16295:   long vals=floor(pow((float)b->entries,1.f/b->dim));
16295: 
16295:   /* the above *should* be reliable, but we'll not assume that FP is
16295:      ever reliable when bitstream sync is at stake; verify via integer
16295:      means that vals really is the greatest value of dim for which
16295:      vals^b->bim <= b->entries */
16295:   /* treat the above as an initial guess */
16295:   while(1){
16295:     long acc=1;
16295:     long acc1=1;
16295:     int i;
16295:     for(i=0;i<b->dim;i++){
16295:       acc*=vals;
16295:       acc1*=vals+1;
16295:     }
16295:     if(acc<=b->entries && acc1>b->entries){
16295:       return(vals);
16295:     }else{
16295:       if(acc>b->entries){
16295:         vals--;
16295:       }else{
16295:         vals++;
16295:       }
16295:     }
16295:   }
16295: }
16295: 
16295: /* unpack the quantized list of values for encode/decode ***********/
16295: /* we need to deal with two map types: in map type 1, the values are
16295:    generated algorithmically (each column of the vector counts through
16295:    the values in the quant vector). in map type 2, all the values came
16295:    in in an explicit list.  Both value lists must be unpacked */
16295: float *_book_unquantize(const static_codebook *b,int n,int *sparsemap){
16295:   long j,k,count=0;
16295:   if(b->maptype==1 || b->maptype==2){
16295:     int quantvals;
16295:     float mindel=_float32_unpack(b->q_min);
16295:     float delta=_float32_unpack(b->q_delta);
16295:     float *r=_ogg_calloc(n*b->dim,sizeof(*r));
16295: 
16295:     /* maptype 1 and 2 both use a quantized value vector, but
16295:        different sizes */
16295:     switch(b->maptype){
16295:     case 1:
16295:       /* most of the time, entries%dimensions == 0, but we need to be
16295:          well defined.  We define that the possible vales at each
16295:          scalar is values == entries/dim.  If entries%dim != 0, we'll
16295:          have 'too few' values (values*dim<entries), which means that
16295:          we'll have 'left over' entries; left over entries use zeroed
16295:          values (and are wasted).  So don't generate codebooks like
16295:          that */
16295:       quantvals=_book_maptype1_quantvals(b);
16295:       for(j=0;j<b->entries;j++){
16295:         if((sparsemap && b->lengthlist[j]) || !sparsemap){
16295:           float last=0.f;
16295:           int indexdiv=1;
16295:           for(k=0;k<b->dim;k++){
16295:             int index= (j/indexdiv)%quantvals;
16295:             float val=b->quantlist[index];
16295:             val=fabs(val)*delta+mindel+last;
16295:             if(b->q_sequencep)last=val;
16295:             if(sparsemap)
16295:               r[sparsemap[count]*b->dim+k]=val;
16295:             else
16295:               r[count*b->dim+k]=val;
16295:             indexdiv*=quantvals;
16295:           }
16295:           count++;
16295:         }
16295: 
16295:       }
16295:       break;
16295:     case 2:
16295:       for(j=0;j<b->entries;j++){
16295:         if((sparsemap && b->lengthlist[j]) || !sparsemap){
16295:           float last=0.f;
16295: 
16295:           for(k=0;k<b->dim;k++){
16295:             float val=b->quantlist[j*b->dim+k];
16295:             val=fabs(val)*delta+mindel+last;
16295:             if(b->q_sequencep)last=val;
16295:             if(sparsemap)
16295:               r[sparsemap[count]*b->dim+k]=val;
16295:             else
16295:               r[count*b->dim+k]=val;
16295:           }
16295:           count++;
16295:         }
16295:       }
16295:       break;
16295:     }
16295: 
16295:     return(r);
16295:   }
16295:   return(NULL);
16295: }
16295: 
16295: void vorbis_staticbook_clear(static_codebook *b){
16295:   if(b->allocedp){
16295:     if(b->quantlist)_ogg_free(b->quantlist);
16295:     if(b->lengthlist)_ogg_free(b->lengthlist);
16295:     if(b->nearest_tree){
16295:       _ogg_free(b->nearest_tree->ptr0);
16295:       _ogg_free(b->nearest_tree->ptr1);
16295:       _ogg_free(b->nearest_tree->p);
16295:       _ogg_free(b->nearest_tree->q);
16295:       memset(b->nearest_tree,0,sizeof(*b->nearest_tree));
16295:       _ogg_free(b->nearest_tree);
16295:     }
16295:     if(b->thresh_tree){
16295:       _ogg_free(b->thresh_tree->quantthresh);
16295:       _ogg_free(b->thresh_tree->quantmap);
16295:       memset(b->thresh_tree,0,sizeof(*b->thresh_tree));
16295:       _ogg_free(b->thresh_tree);
16295:     }
16295: 
16295:     memset(b,0,sizeof(*b));
16295:   }
16295: }
16295: 
16295: void vorbis_staticbook_destroy(static_codebook *b){
16295:   if(b->allocedp){
16295:     vorbis_staticbook_clear(b);
16295:     _ogg_free(b);
16295:   }
16295: }
16295: 
16295: void vorbis_book_clear(codebook *b){
16295:   /* static book is not cleared; we're likely called on the lookup and
16295:      the static codebook belongs to the info struct */
16295:   if(b->valuelist)_ogg_free(b->valuelist);
16295:   if(b->codelist)_ogg_free(b->codelist);
16295: 
16295:   if(b->dec_index)_ogg_free(b->dec_index);
16295:   if(b->dec_codelengths)_ogg_free(b->dec_codelengths);
16295:   if(b->dec_firsttable)_ogg_free(b->dec_firsttable);
16295: 
16295:   memset(b,0,sizeof(*b));
16295: }
16295: 
16295: int vorbis_book_init_encode(codebook *c,const static_codebook *s){
16295: 
16295:   memset(c,0,sizeof(*c));
16295:   c->c=s;
16295:   c->entries=s->entries;
16295:   c->used_entries=s->entries;
16295:   c->dim=s->dim;
16295:   c->codelist=_make_words(s->lengthlist,s->entries,0);
16295:   c->valuelist=_book_unquantize(s,s->entries,NULL);
16295: 
16295:   return(0);
16295: }
16295: 
16295: static ogg_uint32_t bitreverse(ogg_uint32_t x){
16295:   x=    ((x>>16)&0x0000ffffUL) | ((x<<16)&0xffff0000UL);
16295:   x=    ((x>> 8)&0x00ff00ffUL) | ((x<< 8)&0xff00ff00UL);
16295:   x=    ((x>> 4)&0x0f0f0f0fUL) | ((x<< 4)&0xf0f0f0f0UL);
16295:   x=    ((x>> 2)&0x33333333UL) | ((x<< 2)&0xccccccccUL);
16295:   return((x>> 1)&0x55555555UL) | ((x<< 1)&0xaaaaaaaaUL);
16295: }
16295: 
16295: static int sort32a(const void *a,const void *b){
16295:   return ( **(ogg_uint32_t **)a>**(ogg_uint32_t **)b)-
16295:     ( **(ogg_uint32_t **)a<**(ogg_uint32_t **)b);
16295: }
16295: 
16295: /* decode codebook arrangement is more heavily optimized than encode */
16295: int vorbis_book_init_decode(codebook *c,const static_codebook *s){
16295:   int i,j,n=0,tabn;
16295:   int *sortindex;
16295:   memset(c,0,sizeof(*c));
16295: 
16295:   /* count actually used entries */
16295:   for(i=0;i<s->entries;i++)
16295:     if(s->lengthlist[i]>0)
16295:       n++;
16295: 
16295:   c->entries=s->entries;
16295:   c->used_entries=n;
16295:   c->dim=s->dim;
16295: 
16295:   if(n>0){
16295: 
16295:     /* two different remappings go on here.
16295: 
16295:     First, we collapse the likely sparse codebook down only to
16295:     actually represented values/words.  This collapsing needs to be
16295:     indexed as map-valueless books are used to encode original entry
16295:     positions as integers.
16295: 
16295:     Second, we reorder all vectors, including the entry index above,
16295:     by sorted bitreversed codeword to allow treeless decode. */
16295: 
16295:     /* perform sort */
16295:     ogg_uint32_t *codes=_make_words(s->lengthlist,s->entries,c->used_entries);
16295:     ogg_uint32_t **codep=alloca(sizeof(*codep)*n);
16295: 
16295:     if(codes==NULL)goto err_out;
16295: 
16295:     for(i=0;i<n;i++){
16295:       codes[i]=bitreverse(codes[i]);
16295:       codep[i]=codes+i;
16295:     }
16295: 
16295:     qsort(codep,n,sizeof(*codep),sort32a);
16295: 
16295:     sortindex=alloca(n*sizeof(*sortindex));
16295:     c->codelist=_ogg_malloc(n*sizeof(*c->codelist));
16295:     /* the index is a reverse index */
16295:     for(i=0;i<n;i++){
16295:       int position=codep[i]-codes;
16295:       sortindex[position]=i;
16295:     }
16295: 
16295:     for(i=0;i<n;i++)
16295:       c->codelist[sortindex[i]]=codes[i];
16295:     _ogg_free(codes);
16295: 
16295: 
16295:     c->valuelist=_book_unquantize(s,n,sortindex);
16295:     c->dec_index=_ogg_malloc(n*sizeof(*c->dec_index));
16295: 
16295:     for(n=0,i=0;i<s->entries;i++)
16295:       if(s->lengthlist[i]>0)
16295:         c->dec_index[sortindex[n++]]=i;
16295: 
16295:     c->dec_codelengths=_ogg_malloc(n*sizeof(*c->dec_codelengths));
16295:     for(n=0,i=0;i<s->entries;i++)
16295:       if(s->lengthlist[i]>0)
16295:         c->dec_codelengths[sortindex[n++]]=s->lengthlist[i];
16295: 
16295:     c->dec_firsttablen=_ilog(c->used_entries)-4; /* this is magic */
16295:     if(c->dec_firsttablen<5)c->dec_firsttablen=5;
16295:     if(c->dec_firsttablen>8)c->dec_firsttablen=8;
16295: 
16295:     tabn=1<<c->dec_firsttablen;
16295:     c->dec_firsttable=_ogg_calloc(tabn,sizeof(*c->dec_firsttable));
16295:     c->dec_maxlength=0;
16295: 
16295:     for(i=0;i<n;i++){
16295:       if(c->dec_maxlength<c->dec_codelengths[i])
16295:         c->dec_maxlength=c->dec_codelengths[i];
16295:       if(c->dec_codelengths[i]<=c->dec_firsttablen){
16295:         ogg_uint32_t orig=bitreverse(c->codelist[i]);
16295:         for(j=0;j<(1<<(c->dec_firsttablen-c->dec_codelengths[i]));j++)
16295:           c->dec_firsttable[orig|(j<<c->dec_codelengths[i])]=i+1;
16295:       }
16295:     }
16295: 
16295:     /* now fill in 'unused' entries in the firsttable with hi/lo search
16295:        hints for the non-direct-hits */
16295:     {
16295:       ogg_uint32_t mask=0xfffffffeUL<<(31-c->dec_firsttablen);
16295:       long lo=0,hi=0;
16295: 
16295:       for(i=0;i<tabn;i++){
16295:         ogg_uint32_t word=i<<(32-c->dec_firsttablen);
16295:         if(c->dec_firsttable[bitreverse(word)]==0){
16295:           while((lo+1)<n && c->codelist[lo+1]<=word)lo++;
16295:           while(    hi<n && word>=(c->codelist[hi]&mask))hi++;
16295: 
16295:           /* we only actually have 15 bits per hint to play with here.
16295:              In order to overflow gracefully (nothing breaks, efficiency
16295:              just drops), encode as the difference from the extremes. */
16295:           {
16295:             unsigned long loval=lo;
16295:             unsigned long hival=n-hi;
16295: 
16295:             if(loval>0x7fff)loval=0x7fff;
16295:             if(hival>0x7fff)hival=0x7fff;
16295:             c->dec_firsttable[bitreverse(word)]=
16295:               0x80000000UL | (loval<<15) | hival;
16295:           }
16295:         }
16295:       }
16295:     }
16295:   }
16295: 
16295:   return(0);
16295:  err_out:
16295:   vorbis_book_clear(c);
16295:   return(-1);
16295: }
16295: 
16295: static float _dist(int el,float *ref, float *b,int step){
16295:   int i;
16295:   float acc=0.f;
16295:   for(i=0;i<el;i++){
16295:     float val=(ref[i]-b[i*step]);
16295:     acc+=val*val;
16295:   }
16295:   return(acc);
16295: }
16295: 
16295: int _best(codebook *book, float *a, int step){
16295:   encode_aux_threshmatch *tt=book->c->thresh_tree;
16295: 
16295: #if 0
16295:   encode_aux_nearestmatch *nt=book->c->nearest_tree;
16295:   encode_aux_pigeonhole *pt=book->c->pigeon_tree;
16295: #endif
16295:   int dim=book->dim;
16295:   int k,o;
16295:   /*int savebest=-1;
16295:     float saverr;*/
16295: 
16295:   /* do we have a threshhold encode hint? */
16295:   if(tt){
16295:     int index=0,i;
16295:     /* find the quant val of each scalar */
16295:     for(k=0,o=step*(dim-1);k<dim;k++,o-=step){
16295: 
16295:       i=tt->threshvals>>1;
16295:       if(a[o]<tt->quantthresh[i]){
16295: 
16295:         for(;i>0;i--)
16295:           if(a[o]>=tt->quantthresh[i-1])
16295:             break;
16295: 
16295:       }else{
16295: 
16295:         for(i++;i<tt->threshvals-1;i++)
16295:           if(a[o]<tt->quantthresh[i])break;
16295: 
16295:       }
16295: 
16295:       index=(index*tt->quantvals)+tt->quantmap[i];
16295:     }
16295:     /* regular lattices are easy :-) */
16295:     if(book->c->lengthlist[index]>0) /* is this unused?  If so, we'll
16295:                                         use a decision tree after all
16295:                                         and fall through*/
16295:       return(index);
16295:   }
16295: 
16295: #if 0
16295:   /* do we have a pigeonhole encode hint? */
16295:   if(pt){
16295:     const static_codebook *c=book->c;
16295:     int i,besti=-1;
16295:     float best=0.f;
16295:     int entry=0;
16295: 
16295:     /* dealing with sequentialness is a pain in the ass */
16295:     if(c->q_sequencep){
16295:       int pv;
16295:       long mul=1;
16295:       float qlast=0;
16295:       for(k=0,o=0;k<dim;k++,o+=step){
16295:         pv=(int)((a[o]-qlast-pt->min)/pt->del);
16295:         if(pv<0 || pv>=pt->mapentries)break;
16295:         entry+=pt->pigeonmap[pv]*mul;
16295:         mul*=pt->quantvals;
16295:         qlast+=pv*pt->del+pt->min;
16295:       }
16295:     }else{
16295:       for(k=0,o=step*(dim-1);k<dim;k++,o-=step){
16295:         int pv=(int)((a[o]-pt->min)/pt->del);
16295:         if(pv<0 || pv>=pt->mapentries)break;
16295:         entry=entry*pt->quantvals+pt->pigeonmap[pv];
16295:       }
16295:     }
16295: 
16295:     /* must be within the pigeonholable range; if we quant outside (or
16295:        in an entry that we define no list for), brute force it */
16295:     if(k==dim && pt->fitlength[entry]){
16295:       /* search the abbreviated list */
16295:       long *list=pt->fitlist+pt->fitmap[entry];
16295:       for(i=0;i<pt->fitlength[entry];i++){
16295:         float this=_dist(dim,book->valuelist+list[i]*dim,a,step);
16295:         if(besti==-1 || this<best){
16295:           best=this;
16295:           besti=list[i];
16295:         }
16295:       }
16295: 
16295:       return(besti);
16295:     }
16295:   }
16295: 
16295:   if(nt){
16295:     /* optimized using the decision tree */
16295:     while(1){
16295:       float c=0.f;
16295:       float *p=book->valuelist+nt->p[ptr];
16295:       float *q=book->valuelist+nt->q[ptr];
16295: 
16295:       for(k=0,o=0;k<dim;k++,o+=step)
16295:         c+=(p[k]-q[k])*(a[o]-(p[k]+q[k])*.5);
16295: 
16295:       if(c>0.f) /* in A */
16295:         ptr= -nt->ptr0[ptr];
16295:       else     /* in B */
16295:         ptr= -nt->ptr1[ptr];
16295:       if(ptr<=0)break;
16295:     }
16295:     return(-ptr);
16295:   }
16295: #endif
16295: 
16295:   /* brute force it! */
16295:   {
16295:     const static_codebook *c=book->c;
16295:     int i,besti=-1;
16295:     float best=0.f;
16295:     float *e=book->valuelist;
16295:     for(i=0;i<book->entries;i++){
16295:       if(c->lengthlist[i]>0){
16295:         float this=_dist(dim,e,a,step);
16295:         if(besti==-1 || this<best){
16295:           best=this;
16295:           besti=i;
16295:         }
16295:       }
16295:       e+=dim;
16295:     }
16295: 
16295:     /*if(savebest!=-1 && savebest!=besti){
16295:       fprintf(stderr,"brute force/pigeonhole disagreement:\n"
16295:               "original:");
16295:       for(i=0;i<dim*step;i+=step)fprintf(stderr,"%g,",a[i]);
16295:       fprintf(stderr,"\n"
16295:               "pigeonhole (entry %d, err %g):",savebest,saverr);
16295:       for(i=0;i<dim;i++)fprintf(stderr,"%g,",
16295:                                 (book->valuelist+savebest*dim)[i]);
16295:       fprintf(stderr,"\n"
16295:               "bruteforce (entry %d, err %g):",besti,best);
16295:       for(i=0;i<dim;i++)fprintf(stderr,"%g,",
16295:                                 (book->valuelist+besti*dim)[i]);
16295:       fprintf(stderr,"\n");
16295:       }*/
16295:     return(besti);
16295:   }
16295: }
16295: 
16295: long vorbis_book_codeword(codebook *book,int entry){
16295:   if(book->c) /* only use with encode; decode optimizations are
16295:                  allowed to break this */
16295:     return book->codelist[entry];
16295:   return -1;
16295: }
16295: 
16295: long vorbis_book_codelen(codebook *book,int entry){
16295:   if(book->c) /* only use with encode; decode optimizations are
16295:                  allowed to break this */
16295:     return book->c->lengthlist[entry];
16295:   return -1;
16295: }
16295: 
16295: #ifdef _V_SELFTEST
16295: 
16295: /* Unit tests of the dequantizer; this stuff will be OK
16295:    cross-platform, I simply want to be sure that special mapping cases
16295:    actually work properly; a bug could go unnoticed for a while */
16295: 
16295: #include <stdio.h>
16295: 
16295: /* cases:
16295: 
16295:    no mapping
16295:    full, explicit mapping
16295:    algorithmic mapping
16295: 
16295:    nonsequential
16295:    sequential
16295: */
16295: 
16295: static long full_quantlist1[]={0,1,2,3,    4,5,6,7, 8,3,6,1};
16295: static long partial_quantlist1[]={0,7,2};
16295: 
16295: /* no mapping */
16295: static_codebook test1={
16295:   4,16,
16295:   NULL,
16295:   0,
16295:   0,0,0,0,
16295:   NULL,
30043:   NULL,NULL,NULL,
30043:   0
16295: };
16295: static float *test1_result=NULL;
16295: 
16295: /* linear, full mapping, nonsequential */
16295: static_codebook test2={
16295:   4,3,
16295:   NULL,
16295:   2,
16295:   -533200896,1611661312,4,0,
16295:   full_quantlist1,
30043:   NULL,NULL,NULL,
30043:   0
16295: };
16295: static float test2_result[]={-3,-2,-1,0, 1,2,3,4, 5,0,3,-2};
16295: 
16295: /* linear, full mapping, sequential */
16295: static_codebook test3={
16295:   4,3,
16295:   NULL,
16295:   2,
16295:   -533200896,1611661312,4,1,
16295:   full_quantlist1,
30043:   NULL,NULL,NULL,
30043:   0
16295: };
16295: static float test3_result[]={-3,-5,-6,-6, 1,3,6,10, 5,5,8,6};
16295: 
16295: /* linear, algorithmic mapping, nonsequential */
16295: static_codebook test4={
16295:   3,27,
16295:   NULL,
16295:   1,
16295:   -533200896,1611661312,4,0,
16295:   partial_quantlist1,
30043:   NULL,NULL,NULL,
30043:   0
16295: };
16295: static float test4_result[]={-3,-3,-3, 4,-3,-3, -1,-3,-3,
16295:                               -3, 4,-3, 4, 4,-3, -1, 4,-3,
16295:                               -3,-1,-3, 4,-1,-3, -1,-1,-3,
16295:                               -3,-3, 4, 4,-3, 4, -1,-3, 4,
16295:                               -3, 4, 4, 4, 4, 4, -1, 4, 4,
16295:                               -3,-1, 4, 4,-1, 4, -1,-1, 4,
16295:                               -3,-3,-1, 4,-3,-1, -1,-3,-1,
16295:                               -3, 4,-1, 4, 4,-1, -1, 4,-1,
16295:                               -3,-1,-1, 4,-1,-1, -1,-1,-1};
16295: 
16295: /* linear, algorithmic mapping, sequential */
16295: static_codebook test5={
16295:   3,27,
16295:   NULL,
16295:   1,
16295:   -533200896,1611661312,4,1,
16295:   partial_quantlist1,
30043:   NULL,NULL,NULL,
30043:   0
16295: };
16295: static float test5_result[]={-3,-6,-9, 4, 1,-2, -1,-4,-7,
16295:                               -3, 1,-2, 4, 8, 5, -1, 3, 0,
16295:                               -3,-4,-7, 4, 3, 0, -1,-2,-5,
16295:                               -3,-6,-2, 4, 1, 5, -1,-4, 0,
16295:                               -3, 1, 5, 4, 8,12, -1, 3, 7,
16295:                               -3,-4, 0, 4, 3, 7, -1,-2, 2,
16295:                               -3,-6,-7, 4, 1, 0, -1,-4,-5,
16295:                               -3, 1, 0, 4, 8, 7, -1, 3, 2,
16295:                               -3,-4,-5, 4, 3, 2, -1,-2,-3};
16295: 
16295: void run_test(static_codebook *b,float *comp){
16295:   float *out=_book_unquantize(b,b->entries,NULL);
16295:   int i;
16295: 
16295:   if(comp){
16295:     if(!out){
16295:       fprintf(stderr,"_book_unquantize incorrectly returned NULL\n");
16295:       exit(1);
16295:     }
16295: 
16295:     for(i=0;i<b->entries*b->dim;i++)
16295:       if(fabs(out[i]-comp[i])>.0001){
16295:         fprintf(stderr,"disagreement in unquantized and reference data:\n"
16295:                 "position %d, %g != %g\n",i,out[i],comp[i]);
16295:         exit(1);
16295:       }
16295: 
16295:   }else{
16295:     if(out){
16295:       fprintf(stderr,"_book_unquantize returned a value array: \n"
16295:               " correct result should have been NULL\n");
16295:       exit(1);
16295:     }
16295:   }
16295: }
16295: 
16295: int main(){
16295:   /* run the nine dequant tests, and compare to the hand-rolled results */
16295:   fprintf(stderr,"Dequant test 1... ");
16295:   run_test(&test1,test1_result);
16295:   fprintf(stderr,"OK\nDequant test 2... ");
16295:   run_test(&test2,test2_result);
16295:   fprintf(stderr,"OK\nDequant test 3... ");
16295:   run_test(&test3,test3_result);
16295:   fprintf(stderr,"OK\nDequant test 4... ");
16295:   run_test(&test4,test4_result);
16295:   fprintf(stderr,"OK\nDequant test 5... ");
16295:   run_test(&test5,test5_result);
16295:   fprintf(stderr,"OK\n\n");
16295: 
16295:   return(0);
16295: }
16295: 
16295: #endif
