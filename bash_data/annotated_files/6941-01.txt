   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   John Gaunt (jgaunt@netscape.com)
   1:  *   Aaron Leventhal (aaronl@netscape.com)
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsAccessible.h"
1628: #include "nsAccessibleRelation.h"
4451: #include "nsHyperTextAccessibleWrap.h"
4451: 
   1: #include "nsIAccessibleDocument.h"
4451: #include "nsIAccessibleHyperText.h"
4451: #include "nsAccessibleTreeWalker.h"
4451: 
4451: #include "nsIDOMElement.h"
4451: #include "nsIDOMDocument.h"
4451: #include "nsIDOMDocumentXBL.h"
4451: #include "nsIDOMDocumentTraversal.h"
4451: #include "nsIDOMHTMLDocument.h"
4451: #include "nsIDOMHTMLFormElement.h"
4451: #include "nsIDOMNodeFilter.h"
1253: #include "nsIDOMNSHTMLElement.h"
4451: #include "nsIDOMTreeWalker.h"
4451: #include "nsIDOMXULButtonElement.h"
4451: #include "nsIDOMXULDocument.h"
4451: #include "nsIDOMXULElement.h"
4451: #include "nsIDOMXULLabelElement.h"
4451: #include "nsIDOMXULSelectCntrlEl.h"
4451: #include "nsIDOMXULSelectCntrlItemEl.h"
4451: #include "nsPIDOMWindow.h"
4451: 
4451: #include "nsIDocument.h"
4451: #include "nsIContent.h"
4451: #include "nsIForm.h"
4451: #include "nsIFormControl.h"
4451: 
   1: #include "nsIPresShell.h"
   1: #include "nsPresContext.h"
   1: #include "nsIFrame.h"
   1: #include "nsIViewManager.h"
4451: #include "nsIDocShellTreeItem.h"
4451: 
   1: #include "nsXPIDLString.h"
   1: #include "nsUnicharUtils.h"
6279: #include "nsReadableUtils.h"
   1: #include "prdtoa.h"
   1: #include "nsIAtom.h"
   1: #include "nsIPrefService.h"
   1: #include "nsIPrefBranch.h"
   1: #include "nsIURI.h"
   1: #include "nsITimer.h"
   1: #include "nsIMutableArray.h"
 511: #include "nsIObserverService.h"
4451: #include "nsIServiceManager.h"
   1: 
   1: #ifdef NS_DEBUG
   1: #include "nsIFrameDebug.h"
   1: #include "nsIDOMCharacterData.h"
   1: #endif
   1: 
   1: /**
   1:  * nsAccessibleDOMStringList implementation
   1:  */
   1: nsAccessibleDOMStringList::nsAccessibleDOMStringList()
   1: {
   1: }
   1: 
   1: nsAccessibleDOMStringList::~nsAccessibleDOMStringList()
   1: {
   1: }
   1: 
   1: NS_IMPL_ISUPPORTS1(nsAccessibleDOMStringList, nsIDOMDOMStringList)
   1: 
   1: NS_IMETHODIMP
   1: nsAccessibleDOMStringList::Item(PRUint32 aIndex, nsAString& aResult)
   1: {
   1:   if (aIndex >= (PRUint32)mNames.Count()) {
   1:     SetDOMStringToNull(aResult);
   1:   } else {
   1:     mNames.StringAt(aIndex, aResult);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsAccessibleDOMStringList::GetLength(PRUint32 *aLength)
   1: {
   1:   *aLength = (PRUint32)mNames.Count();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsAccessibleDOMStringList::Contains(const nsAString& aString, PRBool *aResult)
   1: {
   1:   *aResult = mNames.IndexOf(aString) > -1;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: /*
   1:  * Class nsAccessible
   1:  */
   1: 
   1: //-----------------------------------------------------
   1: // construction 
   1: //-----------------------------------------------------
   1: NS_IMPL_ADDREF_INHERITED(nsAccessible, nsAccessNode)
   1: NS_IMPL_RELEASE_INHERITED(nsAccessible, nsAccessNode)
   1: 
   1: #ifdef DEBUG_A11Y
   1: /*
   1:  * static
   1:  * help method. to detect whether this accessible object implements
   1:  * nsIAccessibleText, when it is text or has text child node.
   1:  */
   1: PRBool nsAccessible::IsTextInterfaceSupportCorrect(nsIAccessible *aAccessible)
   1: {
   1:   PRBool foundText = PR_FALSE;
   1: 
6486:   nsCOMPtr<nsIAccessibleDocument> accDoc = do_QueryInterface(aAccessible);
6486:   if (accDoc) {
6486:     // Don't test for accessible docs, it makes us create accessibles too
6486:     // early and fire mutation events before we need to
6486:     return PR_TRUE;
6486:   }
   1:   nsCOMPtr<nsIAccessible> child, nextSibling;
   1:   aAccessible->GetFirstChild(getter_AddRefs(child));
   1:   while (child) {
   1:     if (IsText(child)) {
   1:       foundText = PR_TRUE;
   1:       break;
   1:     }
   1:     child->GetNextSibling(getter_AddRefs(nextSibling));
   1:     child.swap(nextSibling);
   1:   }
   1:   if (foundText) {
   1:     // found text child node
   1:     nsCOMPtr<nsIAccessibleText> text = do_QueryInterface(aAccessible);
   1:     if (!text) {
   1:       return PR_FALSE;
   1:     }
   1:   }
   1:   return PR_TRUE; 
   1: }
   1: #endif
   1: 
   1: nsresult nsAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
   1: {
   1:   // Custom-built QueryInterface() knows when we support nsIAccessibleSelectable
   1:   // based on role attribute and waistate:multiselectable
   1:   *aInstancePtr = nsnull;
   1:   
   1:   if (aIID.Equals(NS_GET_IID(nsIAccessible))) {
3233:     *aInstancePtr = static_cast<nsIAccessible*>(this);
   1:     NS_ADDREF_THIS();
   1:     return NS_OK;
   1:   }
   1: 
   1:   if(aIID.Equals(NS_GET_IID(nsPIAccessible))) {
3233:     *aInstancePtr = static_cast<nsPIAccessible*>(this);
   1:     NS_ADDREF_THIS();
   1:     return NS_OK;
   1:   }
   1: 
   1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleSelectable))) {
   1:     nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:     if (!content) {
   1:       return NS_ERROR_FAILURE; // This accessible has been shut down
   1:     }
   1:     if (HasRoleAttribute(content)) {
   1:       // If we have an XHTML role attribute present and the
6279:       // waistate multiselectable attribute is true, then we need
   1:       // to support nsIAccessibleSelectable
   1:       // If either attribute (role or multiselectable) change, then we'll
   1:       // destroy this accessible so that we can follow COM identity rules.
6279:       nsAutoString multiselectable;
6279:       if (nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_multiselectable, multiselectable) &&
6279:           multiselectable.EqualsLiteral("true")) {
3233:         *aInstancePtr = static_cast<nsIAccessibleSelectable*>(this);
   1:         NS_ADDREF_THIS();
4648:         return NS_OK;
   1:       }
   1:     }
   1:   }
   1: 
   1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleValue))) {
   1:     if (mRoleMapEntry && mRoleMapEntry->valueRule != eNoValue) {
3233:       *aInstancePtr = static_cast<nsIAccessibleValue*>(this);
   1:       NS_ADDREF_THIS();
4648:       return NS_OK;
   1:     }
   1:   }                       
   1: 
   1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperLink))) {
   1:     nsCOMPtr<nsIAccessible> parent(GetParent());
   1:     nsCOMPtr<nsIAccessibleHyperText> hyperTextParent(do_QueryInterface(parent));
   1:     if (hyperTextParent) {
3233:       *aInstancePtr = static_cast<nsIAccessibleHyperLink*>(this);
   1:       NS_ADDREF_THIS();
   1:       return NS_OK;
   1:     }
   1:     return NS_ERROR_NO_INTERFACE;
   1:   }
   1: 
4470:   return nsAccessNodeWrap::QueryInterface(aIID, aInstancePtr);
   1: }
   1: 
   1: nsAccessible::nsAccessible(nsIDOMNode* aNode, nsIWeakReference* aShell): nsAccessNodeWrap(aNode, aShell), 
   1:   mParent(nsnull), mFirstChild(nsnull), mNextSibling(nsnull), mRoleMapEntry(nsnull),
   1:   mAccChildCount(eChildCountUninitialized)
   1: {
   1: #ifdef NS_DEBUG_X
   1:    {
   1:      nsCOMPtr<nsIPresShell> shell(do_QueryReferent(aShell));
 732:      printf(">>> %p Created Acc - DOM: %p  PS: %p", 
3233:             (void*)static_cast<nsIAccessible*>(this), (void*)aNode,
 732:             (void*)shell.get());
 732:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
 732:     if (content) {
 732:       nsAutoString buf;
 732:       if (content->NodeInfo())
 732:         content->NodeInfo()->GetQualifiedName(buf);
 732:       printf(" Con: %s@%p", NS_ConvertUTF16toUTF8(buf).get(), (void *)content.get());
 732:       if (NS_SUCCEEDED(GetName(buf))) {
 732:         printf(" Name:[%s]", NS_ConvertUTF16toUTF8(buf).get());
   1:        }
   1:      }
   1:      printf("\n");
   1:    }
   1: #endif
   1: }
   1: 
   1: //-----------------------------------------------------
   1: // destruction
   1: //-----------------------------------------------------
   1: nsAccessible::~nsAccessible()
   1: {
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetName(nsAString& aName)
   1: {
   1:   aName.Truncate();
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:   if (!content) {
   1:     return NS_ERROR_FAILURE;  // Node shut down
   1:   }
   1: 
   1:   PRBool canAggregateName = mRoleMapEntry &&
   1:                             mRoleMapEntry->nameRule == eNameOkFromChildren;
   1: 
   1:   if (content->IsNodeOfType(nsINode::eHTML)) {
   1:     return GetHTMLName(aName, canAggregateName);
   1:   }
   1: 
   1:   if (content->IsNodeOfType(nsINode::eXUL)) {
   1:     return GetXULName(aName, canAggregateName);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetDescription(nsAString& aDescription)
   1: {
   1:   // There are 4 conditions that make an accessible have no accDescription:
   1:   // 1. it's a text node; or
   1:   // 2. It has no DHTML describedby property
   1:   // 3. it doesn't have an accName; or
   1:   // 4. its title attribute already equals to its accName nsAutoString name; 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:   if (!content) {
   1:     return NS_ERROR_FAILURE;  // Node shut down
   1:   }
   1:   if (!content->IsNodeOfType(nsINode::eTEXT)) {
   1:     nsAutoString description;
6279:     nsresult rv = GetTextFromRelationID(eAria_describedby, description);
   1:     if (NS_FAILED(rv)) {
   1:       PRBool isXUL = content->IsNodeOfType(nsINode::eXUL);
   1:       if (isXUL) {
   1:         // Try XUL <description control="[id]">description text</description>
   1:         nsIContent *descriptionContent =
6279:           nsAccUtils::FindNeighbourPointingToNode(content, eAria_none,
6279:                                                   nsAccessibilityAtoms::description,
   1:                                                   nsAccessibilityAtoms::control);
   1: 
   1:         if (descriptionContent) {
   1:           // We have a description content node
   1:           AppendFlatStringFromSubtree(descriptionContent, &description);
   1:         }
   1:       }
   1:       if (description.IsEmpty()) {
   1:         nsIAtom *descAtom = isXUL ? nsAccessibilityAtoms::tooltiptext :
   1:                                     nsAccessibilityAtoms::title;
   1:         if (content->GetAttr(kNameSpaceID_None, descAtom, description)) {
   1:           nsAutoString name;
   1:           GetName(name);
   1:           if (name.IsEmpty() || description == name) {
   1:             // Don't use tooltip for a description if this object
   1:             // has no name or the tooltip is the same as the name
   1:             description.Truncate();
   1:           }
   1:         }
   1:       }
   1:     }
   1:     description.CompressWhitespace();
   1:     aDescription = description;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // mask values for ui.key.chromeAccess and ui.key.contentAccess
   1: #define NS_MODIFIER_SHIFT    1
   1: #define NS_MODIFIER_CONTROL  2
   1: #define NS_MODIFIER_ALT      4
   1: #define NS_MODIFIER_META     8
   1: 
   1: // returns the accesskey modifier mask used in the given node's context
   1: // (i.e. chrome or content), or 0 if an error occurs
   1: static PRInt32
5414: GetAccessModifierMask(nsIContent* aContent)
   1: {
   1:   nsCOMPtr<nsIPrefBranch> prefBranch =
   1:     do_GetService(NS_PREFSERVICE_CONTRACTID);
   1:   if (!prefBranch)
   1:     return 0;
   1: 
   1:   // use ui.key.generalAccessKey (unless it is -1)
   1:   PRInt32 accessKey;
   1:   nsresult rv = prefBranch->GetIntPref("ui.key.generalAccessKey", &accessKey);
   1:   if (NS_SUCCEEDED(rv) && accessKey != -1) {
   1:     switch (accessKey) {
   1:       case nsIDOMKeyEvent::DOM_VK_SHIFT:   return NS_MODIFIER_SHIFT;
   1:       case nsIDOMKeyEvent::DOM_VK_CONTROL: return NS_MODIFIER_CONTROL;
   1:       case nsIDOMKeyEvent::DOM_VK_ALT:     return NS_MODIFIER_ALT;
   1:       case nsIDOMKeyEvent::DOM_VK_META:    return NS_MODIFIER_META;
   1:       default:                             return 0;
   1:     }
   1:   }
   1: 
   1:   // get the docShell to this DOMNode, return 0 on failure
5414:   nsCOMPtr<nsIDocument> document = aContent->GetCurrentDoc();
   1:   if (!document)
   1:     return 0;
   1:   nsCOMPtr<nsISupports> container = document->GetContainer();
   1:   if (!container)
   1:     return 0;
   1:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
   1:   if (!treeItem)
   1:     return 0;
   1: 
   1:   // determine the access modifier used in this context
   1:   PRInt32 itemType, accessModifierMask = 0;
   1:   treeItem->GetItemType(&itemType);
   1:   switch (itemType) {
   1: 
   1:   case nsIDocShellTreeItem::typeChrome:
   1:     rv = prefBranch->GetIntPref("ui.key.chromeAccess", &accessModifierMask);
   1:     break;
   1: 
   1:   case nsIDocShellTreeItem::typeContent:
   1:     rv = prefBranch->GetIntPref("ui.key.contentAccess", &accessModifierMask);
   1:     break;
   1:   }
   1: 
   1:   return NS_SUCCEEDED(rv) ? accessModifierMask : 0;
   1: }
   1: 
5414: NS_IMETHODIMP
5414: nsAccessible::GetKeyboardShortcut(nsAString& aAccessKey)
   1: {
5414:   aAccessKey.Truncate();
5414: 
5414:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
5414:   if (!content)
   1:     return NS_ERROR_FAILURE;
5414: 
5414:   PRUint32 key = nsAccUtils::GetAccessKeyFor(content);
6095:   if (!key && content->IsNodeOfType(nsIContent::eELEMENT)) {
6095:     // Copy access key from label node unless it is labeled
6095:     // via an ancestor <label>, in which case that would be redundant
5414:     nsCOMPtr<nsIContent> labelContent(GetLabelContent(content));
6095:     nsCOMPtr<nsIDOMNode> labelNode = do_QueryInterface(labelContent);
6095:     if (labelNode && !nsAccUtils::IsAncestorOf(labelNode, mDOMNode))
5414:       key = nsAccUtils::GetAccessKeyFor(labelContent);
5414:   }
5414: 
5414:   if (!key)
5414:     return NS_OK;
5414: 
5414:   nsAutoString accesskey(key);
5414: 
5414:   // Append the modifiers in reverse order, result: Control+Alt+Shift+Meta+<key>
   1:   nsAutoString propertyKey;
5414:   PRInt32 modifierMask = GetAccessModifierMask(content);
   1:   if (modifierMask & NS_MODIFIER_META) {
   1:     propertyKey.AssignLiteral("VK_META");
   1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
   1:   }
   1:   if (modifierMask & NS_MODIFIER_SHIFT) {
   1:     propertyKey.AssignLiteral("VK_SHIFT");
   1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
   1:   }
   1:   if (modifierMask & NS_MODIFIER_ALT) {
   1:     propertyKey.AssignLiteral("VK_ALT");
   1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
   1:   }
   1:   if (modifierMask & NS_MODIFIER_CONTROL) {
   1:     propertyKey.AssignLiteral("VK_CONTROL");
   1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
   1:   }
5414: 
5414:   aAccessKey = accesskey;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::SetParent(nsIAccessible *aParent)
   1: {
6411: #ifdef DEBUG
6411:   if (aParent && aParent != mParent) {
6411:     nsCOMPtr<nsPIAccessible> privParent = do_QueryInterface(mParent);
6411:     if (privParent) {
6411:       nsCOMPtr<nsIAccessible> firstChild;
6411:       privParent->GetCachedFirstChild(getter_AddRefs(firstChild));
6411:       NS_ASSERTION(firstChild != this, "Reparenting other node's first child!");
6411:     }
6411:   }
6411: #endif
   1:   mParent = aParent;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::SetFirstChild(nsIAccessible *aFirstChild)
   1: {
 763: #ifdef DEBUG
 763:   // If there's parent of this child already, make sure it's us!
 763:   nsCOMPtr<nsPIAccessible> privChild = do_QueryInterface(aFirstChild);
 763:   if (privChild) {
 763:     nsCOMPtr<nsIAccessible> parent;
 763:     privChild->GetCachedParent(getter_AddRefs(parent));
 763:     NS_ASSERTION(!parent || parent == this, "Stealing child!");
 763:   }
 763: #endif
 763: 
   1:   mFirstChild = aFirstChild;
 763: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::SetNextSibling(nsIAccessible *aNextSibling)
   1: {
   1:   mNextSibling = aNextSibling? aNextSibling: DEAD_END_ACCESSIBLE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::Init()
   1: {
   1:   nsIContent *content = GetRoleContent(mDOMNode);
   1:   nsAutoString roleString;
6067:   if (content && GetARIARole(content, roleString)) {
   1:     nsCString utf8Role = NS_ConvertUTF16toUTF8(roleString); // For easy comparison
   1:     ToLowerCase(utf8Role);
   1:     PRUint32 index;
2136:     for (index = 0; nsARIAMap::gWAIRoleMap[index].roleString; index ++) {
2136:       if (utf8Role.Equals(nsARIAMap::gWAIRoleMap[index].roleString)) {
   1:         break; // The dynamic role attribute maps to an entry in our table
   1:       }
   1:     }
   1:     // Always use some entry if there is a role string
   1:     // If no match, we use the last entry which maps to ROLE_NOTHING
2136:     mRoleMapEntry = &nsARIAMap::gWAIRoleMap[index];
   1:   }
   1: 
   1:   return nsAccessNodeWrap::Init();
   1: }
   1: 
   1: nsIContent *nsAccessible::GetRoleContent(nsIDOMNode *aDOMNode)
   1: {
   1:   // Given the DOM node for an acessible, return content node that
   1:   // we should look at role string from
   1:   // For non-document accessibles, this is the associated content node.
   1:   // For doc accessibles, first try the <body> if it's HTML and there is
   1:   // a role attribute used there.
   1:   // For any other doc accessible , this is the document element.
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aDOMNode));
   1:   if (!content) {
   1:     nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(aDOMNode));
   1:     if (domDoc) {
   1:       nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(aDOMNode));
   1:       if (htmlDoc) {
   1:         nsCOMPtr<nsIDOMHTMLElement> bodyElement;
   1:         htmlDoc->GetBody(getter_AddRefs(bodyElement));
   1:         content = do_QueryInterface(bodyElement);
   1:       }
   1:       if (!content || !HasRoleAttribute(content)) {
   1:         nsCOMPtr<nsIDOMElement> docElement;
   1:         domDoc->GetDocumentElement(getter_AddRefs(docElement));
   1:         content = do_QueryInterface(docElement);
   1:       }
   1:     }
   1:   }
   1:   return content;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::Shutdown()
   1: {
   1:   mNextSibling = nsnull;
   1:   // Make sure none of it's children point to this parent
   1:   if (mFirstChild) {
   1:     nsCOMPtr<nsIAccessible> current(mFirstChild), next;
   1:     while (current) {
   1:       nsCOMPtr<nsPIAccessible> privateAcc(do_QueryInterface(current));
   1:       current->GetNextSibling(getter_AddRefs(next));
   1:       privateAcc->SetParent(nsnull);
   1:       current = next;
   1:     }
   1:   }
   1:   // Now invalidate the child count and pointers to other accessibles
   1:   InvalidateChildren();
   1:   if (mParent) {
   1:     nsCOMPtr<nsPIAccessible> privateParent(do_QueryInterface(mParent));
   1:     privateParent->InvalidateChildren();
   1:     mParent = nsnull;
   1:   }
   1: 
   1:   return nsAccessNodeWrap::Shutdown();
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::InvalidateChildren()
   1: {
   1:   // Document has transformed, reset our invalid children and child count
3776: 
3776:   // Reset the sibling pointers, they will be set up again the next time
3776:   // CacheChildren() is called.
3776:   // Note: we don't want to start creating accessibles at this point,
3776:   // so don't use GetNextSibling() here. (bug 387252)
3776:   nsAccessible* child = static_cast<nsAccessible*>(mFirstChild);
3776:   while (child && child->mNextSibling != DEAD_END_ACCESSIBLE) {
3776:     nsIAccessible *next = child->mNextSibling;
3776:     child->mNextSibling = nsnull;
3776:     child = static_cast<nsAccessible*>(next);
3776:   }
3776: 
   1:   mAccChildCount = eChildCountUninitialized;
   1:   mFirstChild = nsnull;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetParent(nsIAccessible **  aParent)
   1: {
   1:   nsresult rv = GetCachedParent(aParent);
   1:   if (NS_FAILED(rv) || *aParent) {
   1:     return rv;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessibleDocument> docAccessible(GetDocAccessible());
   1:   NS_ENSURE_TRUE(docAccessible, NS_ERROR_FAILURE);
   1: 
6486:   return docAccessible->GetAccessibleInParentChain(mDOMNode, PR_TRUE, aParent);
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetCachedParent(nsIAccessible **  aParent)
   1: {
   1:   *aParent = nsnull;
   1:   if (!mWeakShell) {
   1:     // This node has been shut down
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   NS_IF_ADDREF(*aParent = mParent);
   1:   return NS_OK;
   1: }
   1: 
6411: NS_IMETHODIMP nsAccessible::GetCachedFirstChild(nsIAccessible **  aFirstChild)
6411: {
6411:   *aFirstChild = nsnull;
6411:   if (!mWeakShell) {
6411:     // This node has been shut down
6411:     return NS_ERROR_FAILURE;
6411:   }
6411:   NS_IF_ADDREF(*aFirstChild = mFirstChild);
6411:   return NS_OK;
6411: }
6411: 
   1:   /* readonly attribute nsIAccessible nextSibling; */
   1: NS_IMETHODIMP nsAccessible::GetNextSibling(nsIAccessible * *aNextSibling) 
   1: { 
   1:   *aNextSibling = nsnull; 
   1:   if (!mWeakShell) {
   1:     // This node has been shut down
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   if (!mParent) {
   1:     nsCOMPtr<nsIAccessible> parent(GetParent());
   1:     if (parent) {
   1:       PRInt32 numChildren;
   1:       parent->GetChildCount(&numChildren);  // Make sure we cache all of the children
   1:     }
   1:   }
   1: 
   1:   if (mNextSibling || !mParent) {
   1:     // If no parent, don't try to calculate a new sibling
   1:     // It either means we're at the root or shutting down the parent
   1:     if (mNextSibling != DEAD_END_ACCESSIBLE) {
   1:       NS_IF_ADDREF(*aNextSibling = mNextSibling);
   1:     }
   1:     return NS_OK;
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1:   /* readonly attribute nsIAccessible previousSibling; */
   1: NS_IMETHODIMP nsAccessible::GetPreviousSibling(nsIAccessible * *aPreviousSibling) 
   1: {
   1:   *aPreviousSibling = nsnull;
   1: 
   1:   if (!mWeakShell) {
   1:     // This node has been shut down
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> parent;
   1:   if (NS_FAILED(GetParent(getter_AddRefs(parent))) || !parent) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> testAccessible, prevSibling;
   1:   parent->GetFirstChild(getter_AddRefs(testAccessible));
   1:   while (testAccessible && this != testAccessible) {
   1:     prevSibling = testAccessible;
   1:     prevSibling->GetNextSibling(getter_AddRefs(testAccessible));
   1:   }
   1: 
   1:   if (!prevSibling) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   NS_ADDREF(*aPreviousSibling = prevSibling);
   1:   return NS_OK;
   1: }
   1: 
   1:   /* readonly attribute nsIAccessible firstChild; */
   1: NS_IMETHODIMP nsAccessible::GetFirstChild(nsIAccessible * *aFirstChild) 
   1: {  
   1:   if (gIsCacheDisabled) {
   1:     InvalidateChildren();
   1:   }
   1:   PRInt32 numChildren;
   1:   GetChildCount(&numChildren);  // Make sure we cache all of the children
   1: 
6411: #ifdef DEBUG
6411:   nsCOMPtr<nsPIAccessible> firstChild(do_QueryInterface(mFirstChild));
6411:   if (firstChild) {
6411:     nsCOMPtr<nsIAccessible> realParent;
6411:     firstChild->GetCachedParent(getter_AddRefs(realParent));
6411:     NS_ASSERTION(!realParent || realParent == this,
6411:                  "Two accessibles have the same first child accessible.");
6411:   }
6411: #endif
6411: 
   1:   NS_IF_ADDREF(*aFirstChild = mFirstChild);
   1: 
   1:   return NS_OK;  
   1: }
   1: 
   1:   /* readonly attribute nsIAccessible lastChild; */
   1: NS_IMETHODIMP nsAccessible::GetLastChild(nsIAccessible * *aLastChild)
   1: {  
   1:   GetChildAt(-1, aLastChild);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetChildAt(PRInt32 aChildNum, nsIAccessible **aChild)
   1: {
   1:   // aChildNum is a zero-based index
   1: 
   1:   PRInt32 numChildren;
   1:   GetChildCount(&numChildren);
   1: 
   1:   // If no children or aChildNum is larger than numChildren, return null
   1:   if (aChildNum >= numChildren || numChildren == 0 || !mWeakShell) {
   1:     *aChild = nsnull;
   1:     return NS_ERROR_FAILURE;
   1:   // If aChildNum is less than zero, set aChild to last index
   1:   } else if (aChildNum < 0) {
   1:     aChildNum = numChildren - 1;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> current(mFirstChild), nextSibling;
   1:   PRInt32 index = 0;
   1: 
   1:   while (current) {
   1:     nextSibling = current;
   1:     if (++index > aChildNum) {
   1:       break;
   1:     }
   1:     nextSibling->GetNextSibling(getter_AddRefs(current));
   1:   }
   1: 
   1:   NS_IF_ADDREF(*aChild = nextSibling);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // readonly attribute nsIArray children;
   1: NS_IMETHODIMP nsAccessible::GetChildren(nsIArray **aOutChildren)
   1: {
   1:   nsCOMPtr<nsIMutableArray> children = do_CreateInstance(NS_ARRAY_CONTRACTID);
   1:   if (!children)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsCOMPtr<nsIAccessible> curChild;
   1:   while (NextChild(curChild)) {
   1:     children->AppendElement(curChild, PR_FALSE);
   1:   }
   1:   
   1:   NS_ADDREF(*aOutChildren = children);
   1:   return NS_OK;
   1: }
   1: 
   1: nsIAccessible *nsAccessible::NextChild(nsCOMPtr<nsIAccessible>& aAccessible)
   1: {
   1:   nsCOMPtr<nsIAccessible> nextChild;
   1:   if (!aAccessible) {
   1:     GetFirstChild(getter_AddRefs(nextChild));
   1:   }
   1:   else {
   1:     aAccessible->GetNextSibling(getter_AddRefs(nextChild));
   1:   }
   1:   return (aAccessible = nextChild);
   1: }
   1: 
   1: void nsAccessible::CacheChildren()
   1: {
   1:   if (!mWeakShell) {
   1:     // This node has been shut down
   1:     mAccChildCount = eChildCountUninitialized;
   1:     return;
   1:   }
   1: 
   1:   if (mAccChildCount == eChildCountUninitialized) {
   1:     PRBool allowsAnonChildren = PR_FALSE;
   1:     GetAllowsAnonChildAccessibles(&allowsAnonChildren);
   1:     nsAccessibleTreeWalker walker(mWeakShell, mDOMNode, allowsAnonChildren);
   1:     // Seed the frame hint early while we're still on a container node.
   1:     // This is better than doing the GetPrimaryFrameFor() later on
   1:     // a text node, because text nodes aren't in the frame map.
   1:     walker.mState.frame = GetFrame();
   1: 
   1:     nsCOMPtr<nsPIAccessible> privatePrevAccessible;
   1:     PRInt32 childCount = 0;
   1:     walker.GetFirstChild();
   1:     SetFirstChild(walker.mState.accessible);
   1: 
   1:     while (walker.mState.accessible) {
   1:       ++ childCount;
   1:       privatePrevAccessible = do_QueryInterface(walker.mState.accessible);
   1:       privatePrevAccessible->SetParent(this);
   1:       walker.GetNextSibling();
   1:       privatePrevAccessible->SetNextSibling(walker.mState.accessible);
   1:     }
   1:     mAccChildCount = childCount;
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetAllowsAnonChildAccessibles(PRBool *aAllowsAnonChildren)
   1: {
   1:   *aAllowsAnonChildren = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: /* readonly attribute long childCount; */
   1: NS_IMETHODIMP nsAccessible::GetChildCount(PRInt32 *aAccChildCount) 
   1: {
   1:   CacheChildren();
   1:   *aAccChildCount = mAccChildCount;
   1:   return NS_OK;  
   1: }
   1: 
   1: /* readonly attribute long indexInParent; */
   1: NS_IMETHODIMP nsAccessible::GetIndexInParent(PRInt32 *aIndexInParent)
   1: {
   1:   *aIndexInParent = -1;
   1:   if (!mWeakShell) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> parent;
   1:   GetParent(getter_AddRefs(parent));
   1:   if (!parent) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> sibling;
   1:   parent->GetFirstChild(getter_AddRefs(sibling));
   1:   if (!sibling) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   *aIndexInParent = 0;
   1:   while (sibling != this) {
   1:     NS_ASSERTION(sibling, "Never ran into the same child that we started from");
   1: 
   1:     if (!sibling)
   1:       return NS_ERROR_FAILURE;
   1: 
   1:     ++*aIndexInParent;
   1:     nsCOMPtr<nsIAccessible> tempAccessible;
   1:     sibling->GetNextSibling(getter_AddRefs(tempAccessible));
   1:     sibling = tempAccessible;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::TestChildCache(nsIAccessible *aCachedChild)
   1: {
   1: #ifndef DEBUG_A11Y
   1:   return NS_OK;
   1: #else
   1:   // All cached accessible nodes should be in the parent
   1:   // It will assert if not all the children were created
   1:   // when they were first cached, and no invalidation
   1:   // ever corrected parent accessible's child cache.
   1:   if (mAccChildCount == eChildCountUninitialized) {
   1:     return NS_OK;
   1:   }
   1:   nsCOMPtr<nsIAccessible> sibling = mFirstChild;
   1: 
   1:   while (sibling != aCachedChild) {
   1:     NS_ASSERTION(sibling, "[TestChildCache] Never ran into the same child that we started from");
   1:     if (!sibling)
   1:       return NS_ERROR_FAILURE;
   1: 
   1:     nsCOMPtr<nsIAccessible> tempAccessible;
   1:     sibling->GetNextSibling(getter_AddRefs(tempAccessible));
   1:     sibling = tempAccessible;
   1:   }
   1:   return NS_OK;
   1: #endif
   1: }
   1: 
   1: nsresult nsAccessible::GetTranslatedString(const nsAString& aKey, nsAString& aStringOut)
   1: {
   1:   nsXPIDLString xsValue;
   1: 
   1:   if (!gStringBundle || 
   1:     NS_FAILED(gStringBundle->GetStringFromName(PromiseFlatString(aKey).get(), getter_Copies(xsValue)))) 
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   aStringOut.Assign(xsValue);
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult nsAccessible::GetFullKeyName(const nsAString& aModifierName, const nsAString& aKeyName, nsAString& aStringOut)
   1: {
   1:   nsXPIDLString modifierName, separator;
   1: 
   1:   if (!gKeyStringBundle ||
   1:       NS_FAILED(gKeyStringBundle->GetStringFromName(PromiseFlatString(aModifierName).get(), 
   1:                                                     getter_Copies(modifierName))) ||
   1:       NS_FAILED(gKeyStringBundle->GetStringFromName(PromiseFlatString(NS_LITERAL_STRING("MODIFIER_SEPARATOR")).get(), 
   1:                                                     getter_Copies(separator)))) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   aStringOut = modifierName + separator + aKeyName; 
   1:   return NS_OK;
   1: }
   1: 
   1: PRBool nsAccessible::IsVisible(PRBool *aIsOffscreen) 
   1: {
   1:   // We need to know if at least a kMinPixels around the object is visible
   1:   // Otherwise it will be marked nsIAccessibleStates::STATE_OFFSCREEN
   1:   // The STATE_INVISIBLE flag is for elements which are programmatically hidden
   1:   
 733:   *aIsOffscreen = PR_TRUE;
   1: 
   1:   const PRUint16 kMinPixels  = 12;
   1:    // Set up the variables we need, return false if we can't get at them all
   1:   nsCOMPtr<nsIPresShell> shell(GetPresShell());
   1:   if (!shell) 
   1:     return PR_FALSE;
   1: 
   1:   nsIViewManager* viewManager = shell->GetViewManager();
   1:   if (!viewManager)
   1:     return PR_FALSE;
   1: 
   1:   nsIFrame *frame = GetFrame();
   1:   if (!frame) {
   1:     return PR_FALSE;
   1:   }
   1: 
   1:   // If visibility:hidden or visibility:collapsed then mark with STATE_INVISIBLE
   1:   if (!frame->GetStyleVisibility()->IsVisible())
   1:   {
   1:       return PR_FALSE;
   1:   }
   1: 
   1:   nsPresContext *presContext = shell->GetPresContext();
   1:   if (!presContext)
   1:     return PR_FALSE;
   1: 
   1:   // Get the bounds of the current frame, relative to the current view.
   1:   // We don't use the more accurate GetBoundsRect, because that is more expensive
   1:   // and the STATE_OFFSCREEN flag that this is used for only needs to be a rough
   1:   // indicator
   1: 
   1:   nsRect relFrameRect = frame->GetRect();
1209:   nsIView *containingView = frame->GetViewExternal();
1209:   if (containingView) {
1209:     // When frame itself has a view, it has the same bounds as the view
1209:     relFrameRect.x = relFrameRect.y = 0;
1209:   }
1209:   else {
   1:     nsPoint frameOffset;
   1:     frame->GetOffsetFromView(frameOffset, &containingView);
   1:     if (!containingView)
   1:       return PR_FALSE;  // no view -- not visible
   1:     relFrameRect.x = frameOffset.x;
   1:     relFrameRect.y = frameOffset.y;
   1:   }
   1: 
   1:   nsRectVisibility rectVisibility;
   1:   viewManager->GetRectVisibility(containingView, relFrameRect,
   1:                                  nsPresContext::CSSPixelsToAppUnits(kMinPixels),
   1:                                  &rectVisibility);
   1: 
   1:   if (rectVisibility == nsRectVisibility_kZeroAreaRect) {
   1:     if (frame->GetNextContinuation()) {
   1:       // Zero area rects can occur in the first frame of a multi-frame text flow,
   1:       // in which case the next frame exists because the text flow is visible
   1:       rectVisibility = nsRectVisibility_kVisible;
   1:     }
   1:     else if (IsCorrectFrameType(frame, nsAccessibilityAtoms::inlineFrame)) {
   1:       // Yuck. Unfortunately inline frames can contain larger frames inside of them,
   1:       // so we can't really believe this is a zero area rect without checking more deeply.
   1:       // GetBounds() will do that for us.
   1:       PRInt32 x, y, width, height;
   1:       GetBounds(&x, &y, &width, &height);
   1:       if (width > 0 && height > 0) {
   1:         rectVisibility = nsRectVisibility_kVisible;    
   1:       }
   1:     }
   1:   }
   1: 
 733:   if (rectVisibility == nsRectVisibility_kZeroAreaRect || !mDOMNode) {
 733:     return PR_FALSE;   // Hidden element
 733:   }
 733:   
 673:   // Currently one of:
 673:   // nsRectVisibility_kVisible, 
 673:   // nsRectVisibility_kAboveViewport, 
 673:   // nsRectVisibility_kBelowViewport, 
 673:   // nsRectVisibility_kLeftOfViewport, 
 673:   // nsRectVisibility_kRightOfViewport
   1:   // This view says it is visible, but we need to check the parent view chain :(
   1:   nsCOMPtr<nsIDOMDocument> domDoc;
   1:   mDOMNode->GetOwnerDocument(getter_AddRefs(domDoc));
   1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
 733:   if (!doc)  {
 673:     return PR_FALSE;
   1:   }
   1: 
 733:   PRBool isVisible = CheckVisibilityInParentChain(doc, containingView);
 733:   if (isVisible && rectVisibility == nsRectVisibility_kVisible) {
 733:     *aIsOffscreen = PR_FALSE;
 733:   }
 733:   return isVisible;
 733: }
 733: 
5424: nsresult
 262: nsAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
   1:   *aState = 0;
   1: 
 262:   if (aExtraState)
 262:     *aExtraState = 0;
 262: 
 262:   if (!mDOMNode && aExtraState) {
 262:     *aExtraState = nsIAccessibleStates::EXT_STATE_DEFUNCT;
 262:     return NS_OK; // Node shut down
 262:   }
 262: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
 618:   if (!content) {
 618:     return NS_OK;  // On document, this is not an error
 618:   }
   1: 
   1:   // Set STATE_UNAVAILABLE state based on disabled attribute
   1:   // The disabled attribute is mostly used in XUL elements and HTML forms, but
   1:   // if someone sets it on another attribute, 
   1:   // it seems reasonable to consider it unavailable
   1:   PRBool isDisabled;
   1:   if (content->IsNodeOfType(nsINode::eHTML)) {
   1:     // In HTML, just the presence of the disabled attribute means it is disabled,
   1:     // therefore disabled="false" indicates disabled!
   1:     isDisabled = content->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::disabled);
   1:   }
   1:   else {
   1:     isDisabled = content->AttrValueIs(kNameSpaceID_None,
   1:                                       nsAccessibilityAtoms::disabled,
   1:                                       nsAccessibilityAtoms::_true,
   1:                                       eCaseMatters);
   1:   }
   1:   if (isDisabled) {
   1:     *aState |= nsIAccessibleStates::STATE_UNAVAILABLE;
   1:   }
   1:   else if (content->IsNodeOfType(nsINode::eELEMENT)) {
   1:     nsIFrame *frame = GetFrame();
   1:     if (frame && frame->IsFocusable()) {
   1:       *aState |= nsIAccessibleStates::STATE_FOCUSABLE;
   1:     }
   1: 
   1:     if (gLastFocusedNode == mDOMNode) {
   1:       *aState |= nsIAccessibleStates::STATE_FOCUSED;
   1:     }
   1:   }
   1: 
   1:   // Check if nsIAccessibleStates::STATE_INVISIBLE and
   1:   // STATE_OFFSCREEN flags should be turned on for this object.
   1:   PRBool isOffscreen;
   1:   if (!IsVisible(&isOffscreen)) {
   1:     *aState |= nsIAccessibleStates::STATE_INVISIBLE;
   1:   }
   1:   if (isOffscreen) {
   1:     *aState |= nsIAccessibleStates::STATE_OFFSCREEN;
   1:   }
   1: 
5707:   nsIFrame *frame = GetFrame();
5707:   if (frame && (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW))
5707:     *aState |= nsIAccessibleStates::STATE_FLOATING;
5707: 
   1:   return NS_OK;
   1: }
   1: 
   1:   /* readonly attribute boolean focusedChild; */
   1: NS_IMETHODIMP nsAccessible::GetFocusedChild(nsIAccessible **aFocusedChild) 
   1: { 
   1:   nsCOMPtr<nsIAccessible> focusedChild;
   1:   if (gLastFocusedNode == mDOMNode) {
   1:     focusedChild = this;
   1:   }
   1:   else if (gLastFocusedNode) {
   1:     nsCOMPtr<nsIAccessibilityService> accService =
   1:       do_GetService("@mozilla.org/accessibilityService;1");
   1:     NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
 674: 
 674:     accService->GetAccessibleFor(gLastFocusedNode,
   1:                                  getter_AddRefs(focusedChild));
   1:     if (focusedChild) {
   1:       nsCOMPtr<nsIAccessible> focusedParentAccessible;
   1:       focusedChild->GetParent(getter_AddRefs(focusedParentAccessible));
   1:       if (focusedParentAccessible != this) {
   1:         focusedChild = nsnull;
   1:       }
   1:     }
   1:   }
   1: 
   1:   NS_IF_ADDREF(*aFocusedChild = focusedChild);
   1:   return NS_OK;
   1: }
   1: 
   1:   /* nsIAccessible getChildAtPoint (in long x, in long y); */
5680: NS_IMETHODIMP
5680: nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,
5680:                               nsIAccessible **aAccessible)
   1: {
5680:   NS_ENSURE_ARG_POINTER(aAccessible);
   1:   *aAccessible = nsnull;
   1: 
6068:   if (!mDOMNode) {
6068:     return NS_ERROR_FAILURE;  // Already shut down
6068:   }
6068: 
6068:   // If we can't find the point in a child, we will return the fallback answer:
6068:   // we return |this| if the point is within it, otherwise nsnull
6068:   nsCOMPtr<nsIAccessible> fallbackAnswer;
6068:   PRInt32 x, y, width, height;
6068:   GetBounds(&x, &y, &width, &height);
6068:   if (aX >= x && aX < x + width &&
6068:       aY >= y && aY < y + height) {
6068:     fallbackAnswer = this;
6068:   }
6068:   if (MustPrune(this)) {  // Do not dig any further
6068:     NS_IF_ADDREF(*aAccessible = fallbackAnswer);
6068:     return NS_OK;
6068:   }
6068: 
5680:   // Search an accessible at the given point starting from accessible document
5680:   // because containing block (see CSS2) for out of flow element (for example,
5680:   // absolutely positioned element) may be different from its DOM parent and
5680:   // therefore accessible for containing block may be different from accessible
5680:   // for DOM parent but GetFrameForPoint() should be called for containing block
5680:   // to get an out of flow element.
5680:   nsCOMPtr<nsIAccessibleDocument> accDocument;
5680:   nsresult rv = GetAccessibleDocument(getter_AddRefs(accDocument));
5680:   NS_ENSURE_SUCCESS(rv, rv);
6068:   NS_ENSURE_TRUE(accDocument, NS_ERROR_FAILURE);
5680: 
5680:   nsCOMPtr<nsPIAccessNode> accessNodeDocument(do_QueryInterface(accDocument));
5680:   NS_ASSERTION(accessNodeDocument,
5680:                "nsIAccessibleDocument doesn't implement nsPIAccessNode");
5680: 
5680:   nsIFrame *frame = accessNodeDocument->GetFrame();
5680:   NS_ENSURE_STATE(frame);
5680: 
5680:   nsPresContext *presContext = frame->PresContext();
5680: 
5680:   nsIntRect screenRect = frame->GetScreenRectExternal();
5680:   nsPoint offset(presContext->DevPixelsToAppUnits(aX - screenRect.x),
5680:                  presContext->DevPixelsToAppUnits(aY - screenRect.y));
5680: 
5680:   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
5680:   nsIFrame *foundFrame = presShell->GetFrameForPoint(frame, offset);
6068:   nsCOMPtr<nsIContent> content;
6068:   if (!foundFrame || !(content = foundFrame->GetContent())) {
6068:     NS_IF_ADDREF(*aAccessible = fallbackAnswer);
   1:     return NS_OK;
6068:   }
5680: 
5680:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(content));
5680:   nsCOMPtr<nsIAccessibilityService> accService = GetAccService();
5680: 
5680:   nsCOMPtr<nsIDOMNode> relevantNode;
5680:   accService->GetRelevantContentNodeFor(node, getter_AddRefs(relevantNode));
6068:   if (!relevantNode) {
6068:     NS_IF_ADDREF(*aAccessible = fallbackAnswer);
5680:     return NS_OK;
6068:   }
5680: 
5680:   nsCOMPtr<nsIAccessible> accessible;
5680:   accService->GetAccessibleFor(relevantNode, getter_AddRefs(accessible));
6068:   if (!accessible) {
6068:     // No accessible for the node with the point, so find the first
6068:     // accessible in the DOM parent chain
6486:     accDocument->GetAccessibleInParentChain(relevantNode, PR_TRUE,
6068:                                             getter_AddRefs(accessible));
6068:     if (!accessible) {
6068:       NS_IF_ADDREF(*aAccessible = fallbackAnswer);
5680:       return NS_OK;
6068:     }
6068:   }
6068: 
6068:   if (accessible == this) {
6068:     // Manually walk through accessible children and see if
6068:     // the are within this point.
6068:     // This takes care of cases where layout won't walk into
6068:     // things for us, such as image map areas and sub documents
6068:     nsCOMPtr<nsIAccessible> child;
6068:     while (NextChild(child)) {
6068:       PRInt32 childX, childY, childWidth, childHeight;
6068:       child->GetBounds(&childX, &childY, &childWidth, &childHeight);
6068:       if (aX >= childX && aX < childX + childWidth &&
6068:           aY >= childY && aY < childY + childHeight &&
6068:           (State(child) & nsIAccessibleStates::STATE_INVISIBLE) == 0) {
6068:         // Don't walk into offscreen or invisible items
6068:         NS_IF_ADDREF(*aAccessible = child);
6068:         return NS_OK;
6068:       }
6068:     }
6068:     // Fall through -- the point is in this accessible but not in a child
6068:     // We are allowed to return |this| as the answer
6068:   }
6068:   else {
5680:     nsCOMPtr<nsIAccessible> parent;
6068:     while (PR_TRUE) {
5680:       accessible->GetParent(getter_AddRefs(parent));
6068:       if (!parent) {
6068:         // Reached the top of the hierarchy
6068:         // these bounds were inside an accessible that is not a descendant of this one
6068:         NS_IF_ADDREF(*aAccessible = fallbackAnswer);
6068:         return NS_OK;
6068:       }
6068:       if (parent == this) {
6068:         // We reached |this|, so |accessible| is the
6068:         // child we want to return
6068:         break;
6068:       }
5680:       accessible.swap(parent);
6068:     }
6068:   }
6068: 
6068:   NS_IF_ADDREF(*aAccessible = accessible);
5680:   return NS_OK;
   1: }
   1: 
   1: void nsAccessible::GetBoundsRect(nsRect& aTotalBounds, nsIFrame** aBoundingFrame)
   1: {
   1: /*
   1:  * This method is used to determine the bounds of a content node.
   1:  * Because HTML wraps and links are not always rectangular, this
   1:  * method uses the following algorithm:
   1:  *
   1:  * 1) Start with an empty rectangle
   1:  * 2) Add the rect for the primary frame from for the DOM node.
   1:  * 3) For each next frame at the same depth with the same DOM node, add that rect to total
   1:  * 4) If that frame is an inline frame, search deeper at that point in the tree, adding all rects
   1:  */
   1: 
   1:   // Initialization area
   1:   *aBoundingFrame = nsnull;
   1:   nsIFrame *firstFrame = GetBoundsFrame();
   1:   if (!firstFrame)
   1:     return;
   1: 
   1:   // Find common relative parent
   1:   // This is an ancestor frame that will incompass all frames for this content node.
   1:   // We need the relative parent so we can get absolute screen coordinates
   1:   nsIFrame *ancestorFrame = firstFrame;
   1: 
   1:   while (ancestorFrame) {  
   1:     *aBoundingFrame = ancestorFrame;
   1:     // If any other frame type, we only need to deal with the primary frame
   1:     // Otherwise, there may be more frames attached to the same content node
   1:     if (!IsCorrectFrameType(ancestorFrame, nsAccessibilityAtoms::inlineFrame) &&
   1:         !IsCorrectFrameType(ancestorFrame, nsAccessibilityAtoms::textFrame))
   1:       break;
   1:     ancestorFrame = ancestorFrame->GetParent();
   1:   }
   1: 
   1:   nsIFrame *iterFrame = firstFrame;
   1:   nsCOMPtr<nsIContent> firstContent(do_QueryInterface(mDOMNode));
   1:   nsIContent* iterContent = firstContent;
   1:   PRInt32 depth = 0;
   1: 
   1:   // Look only at frames below this depth, or at this depth (if we're still on the content node we started with)
   1:   while (iterContent == firstContent || depth > 0) {
   1:     // Coordinates will come back relative to parent frame
   1:     nsRect currFrameBounds = iterFrame->GetRect();
   1:     
   1:     // Make this frame's bounds relative to common parent frame
   1:     currFrameBounds +=
   1:       iterFrame->GetParent()->GetOffsetToExternal(*aBoundingFrame);
   1: 
   1:     // Add this frame's bounds to total
   1:     aTotalBounds.UnionRect(aTotalBounds, currFrameBounds);
   1: 
   1:     nsIFrame *iterNextFrame = nsnull;
   1: 
   1:     if (IsCorrectFrameType(iterFrame, nsAccessibilityAtoms::inlineFrame)) {
   1:       // Only do deeper bounds search if we're on an inline frame
   1:       // Inline frames can contain larger frames inside of them
   1:       iterNextFrame = iterFrame->GetFirstChild(nsnull);
   1:     }
   1: 
   1:     if (iterNextFrame) 
   1:       ++depth;  // Child was found in code above this: We are going deeper in this iteration of the loop
   1:     else {  
   1:       // Use next sibling if it exists, or go back up the tree to get the first next-in-flow or next-sibling 
   1:       // within our search
   1:       while (iterFrame) {
   1:         iterNextFrame = iterFrame->GetNextContinuation();
   1:         if (!iterNextFrame)
   1:           iterNextFrame = iterFrame->GetNextSibling();
   1:         if (iterNextFrame || --depth < 0) 
   1:           break;
   1:         iterFrame = iterFrame->GetParent();
   1:       }
   1:     }
   1: 
   1:     // Get ready for the next round of our loop
   1:     iterFrame = iterNextFrame;
   1:     if (iterFrame == nsnull)
   1:       break;
   1:     iterContent = nsnull;
   1:     if (depth == 0)
   1:       iterContent = iterFrame->GetContent();
   1:   }
   1: }
   1: 
   1: 
   1: /* void getBounds (out long x, out long y, out long width, out long height); */
   1: NS_IMETHODIMP nsAccessible::GetBounds(PRInt32 *x, PRInt32 *y, PRInt32 *width, PRInt32 *height)
   1: {
   1:   // This routine will get the entire rectange for all the frames in this node
   1:   // -------------------------------------------------------------------------
   1:   //      Primary Frame for node
   1:   //  Another frame, same node                <- Example
   1:   //  Another frame, same node
   1: 
   1:   nsPresContext *presContext = GetPresContext();
   1:   if (!presContext)
   1:   {
   1:     *x = *y = *width = *height = 0;
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsRect unionRectTwips;
   1:   nsIFrame* aBoundingFrame = nsnull;
   1:   GetBoundsRect(unionRectTwips, &aBoundingFrame);   // Unions up all primary frames for this node and all siblings after it
   1:   if (!aBoundingFrame) {
   1:     *x = *y = *width = *height = 0;
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   *x      = presContext->AppUnitsToDevPixels(unionRectTwips.x); 
   1:   *y      = presContext->AppUnitsToDevPixels(unionRectTwips.y);
   1:   *width  = presContext->AppUnitsToDevPixels(unionRectTwips.width);
   1:   *height = presContext->AppUnitsToDevPixels(unionRectTwips.height);
   1: 
   1:   // We have the union of the rectangle, now we need to put it in absolute screen coords
   1: 
   1:   nsRect orgRectPixels = aBoundingFrame->GetScreenRectExternal();
   1:   *x += orgRectPixels.x;
   1:   *y += orgRectPixels.y;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // helpers
   1: 
   1: /**
   1:   * Static
   1:   * Helper method to help sub classes make sure they have the proper
   1:   *     frame when walking the frame tree to get at children and such
   1:   */
   1: PRBool nsAccessible::IsCorrectFrameType( nsIFrame* aFrame, nsIAtom* aAtom ) 
   1: {
   1:   NS_ASSERTION(aFrame != nsnull, "aFrame is null in call to IsCorrectFrameType!");
   1:   NS_ASSERTION(aAtom != nsnull, "aAtom is null in call to IsCorrectFrameType!");
   1: 
   1:   return aFrame->GetType() == aAtom;
   1: }
   1: 
   1: 
   1: nsIFrame* nsAccessible::GetBoundsFrame()
   1: {
   1:   return GetFrame();
   1: }
   1: 
   1: already_AddRefed<nsIAccessible>
   1: nsAccessible::GetMultiSelectFor(nsIDOMNode *aNode)
   1: {
   1:   NS_ENSURE_TRUE(aNode, nsnull);
   1:   nsCOMPtr<nsIAccessibilityService> accService =
   1:     do_GetService("@mozilla.org/accessibilityService;1");
   1:   NS_ENSURE_TRUE(accService, nsnull);
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   accService->GetAccessibleFor(aNode, getter_AddRefs(accessible));
   1:   if (!accessible) {
   1:     return nsnull;
   1:   }
   1: 
 262:   PRUint32 state = State(accessible);
   1:   if (0 == (state & nsIAccessibleStates::STATE_SELECTABLE)) {
   1:     return nsnull;
   1:   }
   1: 
   1:   PRUint32 containerRole;
   1:   while (0 == (state & nsIAccessibleStates::STATE_MULTISELECTABLE)) {
   1:     nsIAccessible *current = accessible;
   1:     current->GetParent(getter_AddRefs(accessible));
   1:     if (!accessible || (NS_SUCCEEDED(accessible->GetFinalRole(&containerRole)) &&
   1:                         containerRole == nsIAccessibleRole::ROLE_PANE)) {
   1:       return nsnull;
   1:     }
 262:     state = State(accessible);
   1:   }
   1:   nsIAccessible *returnAccessible = nsnull;
   1:   accessible.swap(returnAccessible);
   1:   return returnAccessible;
   1: }
   1: 
   1: /* void removeSelection (); */
   1: NS_IMETHODIMP nsAccessible::SetSelected(PRBool aSelect)
   1: {
   1:   // Add or remove selection
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
 262:   PRUint32 state = State(this);
   1:   if (state & nsIAccessibleStates::STATE_SELECTABLE) {
   1:     nsCOMPtr<nsIAccessible> multiSelect = GetMultiSelectFor(mDOMNode);
   1:     if (!multiSelect) {
   1:       return aSelect ? TakeFocus() : NS_ERROR_FAILURE;
   1:     }
   1:     nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:     NS_ASSERTION(content, "Called for dead accessible");
   1: 
6279:     // For ARIA widgets use WAI namespace or hyphenated property, depending on what doc accepts
6279:     PRUint32 nameSpaceID = kNameSpaceID_None;  // Default
6279:     if (mRoleMapEntry) {
6279:       if (0 == (nsAccUtils::GetAriaPropTypes(content, mWeakShell) &
6279:                 nsIAccessibleDocument::eCheckNamespaced)) {
6279:         // No WAI namespaced properties used in this doc, use hyphenated property
   1:         if (aSelect) {
6279:           return content->SetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_selected,
6279:                                   NS_LITERAL_STRING("true"), PR_TRUE);
6279:         }
6279:         return content->UnsetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_selected, PR_TRUE);
6279:       }
6279:       nameSpaceID = kNameSpaceID_WAIProperties;
6279:     }
6279:     // Use normal property
6279:     if (aSelect) {
6279:       return content->SetAttr(nameSpaceID, nsAccessibilityAtoms::selected,
6279:                               NS_LITERAL_STRING("true"), PR_TRUE);
   1:     }
   1:     return content->UnsetAttr(nameSpaceID, nsAccessibilityAtoms::selected, PR_TRUE);
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: /* void takeSelection (); */
   1: NS_IMETHODIMP nsAccessible::TakeSelection()
   1: {
   1:   // Select only this item
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
 262:   PRUint32 state = State(this);
   1:   if (state & nsIAccessibleStates::STATE_SELECTABLE) {
   1:     nsCOMPtr<nsIAccessible> multiSelect = GetMultiSelectFor(mDOMNode);
   1:     if (multiSelect) {
   1:       nsCOMPtr<nsIAccessibleSelectable> selectable = do_QueryInterface(multiSelect);
   1:       selectable->ClearSelection();
   1:     }
   1:     return SetSelected(PR_TRUE);
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: /* void takeFocus (); */
   1: NS_IMETHODIMP nsAccessible::TakeFocus()
   1: { 
1253:   nsCOMPtr<nsIDOMNSHTMLElement> htmlElement(do_QueryInterface(mDOMNode));
1253:   if (htmlElement) {
1253:     // HTML Elements also set the caret position
1253:     // in order to affect tabbing order
1253:     return htmlElement->Focus();
1253:   }
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:   if (!content) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   content->SetFocus(GetPresContext());
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult nsAccessible::AppendStringWithSpaces(nsAString *aFlatString, const nsAString& textEquivalent)
   1: {
   1:   // Insert spaces to insure that words from controls aren't jammed together
   1:   if (!textEquivalent.IsEmpty()) {
   1:     if (!aFlatString->IsEmpty())
   1:       aFlatString->Append(PRUnichar(' '));
   1:     aFlatString->Append(textEquivalent);
   1:     aFlatString->Append(PRUnichar(' '));
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult nsAccessible::AppendNameFromAccessibleFor(nsIContent *aContent,
   1:                                                    nsAString *aFlatString,
   1:                                                    PRBool aFromValue)
   1: {
   1:   nsAutoString textEquivalent, value;
   1: 
   1:   nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(aContent));
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   if (domNode == mDOMNode) {
   1:     accessible = this;
4300:     if (!aFromValue) {
4300:       // prevent recursive call GetName()
4300:       return NS_OK;
4300:     }
   1:   }
   1:   else {
   1:     nsCOMPtr<nsIAccessibilityService> accService =
   1:       do_GetService("@mozilla.org/accessibilityService;1");
   1:     NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
   1:     accService->GetAccessibleInWeakShell(domNode, mWeakShell, getter_AddRefs(accessible));
   1:   }
   1:   if (accessible) {
   1:     if (aFromValue) {
   1:       accessible->GetValue(textEquivalent);
   1:     }
   1:     else {
   1:       accessible->GetName(textEquivalent);
   1:     }
   1:   }
   1: 
   1:   textEquivalent.CompressWhitespace();
   1:   return AppendStringWithSpaces(aFlatString, textEquivalent);
   1: }
   1: 
   1: /*
   1:  * AppendFlatStringFromContentNode and AppendFlatStringFromSubtree
   1:  *
   1:  * This method will glean useful text, in whatever form it exists, from any content node given to it.
   1:  * It is used by any decendant of nsAccessible that needs to get text from a single node, as
   1:  * well as by nsAccessible::AppendFlatStringFromSubtree, which gleans and concatenates text from any node and
   1:  * that node's decendants.
   1:  */
   1: 
   1: nsresult nsAccessible::AppendFlatStringFromContentNode(nsIContent *aContent, nsAString *aFlatString)
   1: {
   1:   if (aContent->IsNodeOfType(nsINode::eTEXT)) {
   1:     // If it's a text node, append the text
   1:     PRBool isHTMLBlock = PR_FALSE;
   1:     nsCOMPtr<nsIPresShell> shell = GetPresShell();
   1:     if (!shell) {
   1:       return NS_ERROR_FAILURE;  
   1:     }
   1: 
   1:     nsIContent *parentContent = aContent->GetParent();
   1:     nsCOMPtr<nsIContent> appendedSubtreeStart(do_QueryInterface(mDOMNode));
   1:     if (parentContent && parentContent != appendedSubtreeStart) {
   1:       nsIFrame *frame = shell->GetPrimaryFrameFor(parentContent);
   1:       if (frame) {
   1:         // If this text is inside a block level frame (as opposed to span level), we need to add spaces around that 
   1:         // block's text, so we don't get words jammed together in final name
   1:         // Extra spaces will be trimmed out later
   1:         const nsStyleDisplay* display = frame->GetStyleDisplay();
2830:         if (display->IsBlockOutside() ||
   1:           display->mDisplay == NS_STYLE_DISPLAY_TABLE_CELL) {
   1:           isHTMLBlock = PR_TRUE;
   1:           if (!aFlatString->IsEmpty()) {
   1:             aFlatString->Append(PRUnichar(' '));
   1:           }
   1:         }
   1:       }
   1:     }
   1:     if (aContent->TextLength() > 0) {
4261:       nsIFrame *frame = shell->GetPrimaryFrameFor(aContent);
4261:       NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
4261:       nsresult rv = frame->GetRenderedText(aFlatString);
4261:       NS_ENSURE_SUCCESS(rv, rv);
4261:       if (isHTMLBlock && !aFlatString->IsEmpty()) {
   1:         aFlatString->Append(PRUnichar(' '));
   1:       }
4261:     }
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsAutoString textEquivalent;
   1:   if (!aContent->IsNodeOfType(nsINode::eHTML)) {
   1:     if (aContent->IsNodeOfType(nsINode::eXUL)) {
   1:       nsCOMPtr<nsIPresShell> shell = GetPresShell();
   1:       if (!shell) {
   1:         return NS_ERROR_FAILURE;  
   1:       }
   1:       nsIFrame *frame = shell->GetPrimaryFrameFor(aContent);
   1:       if (!frame || !frame->GetStyleVisibility()->IsVisible()) {
   1:         return NS_OK;
   1:       }
   1: 
   1:       nsCOMPtr<nsIDOMXULLabeledControlElement> labeledEl(do_QueryInterface(aContent));
   1:       if (labeledEl) {
   1:         labeledEl->GetLabel(textEquivalent);
   1:       }
   1:       else {
   1:         if (aContent->NodeInfo()->Equals(nsAccessibilityAtoms::label, kNameSpaceID_XUL)) {
   1:           aContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::value, textEquivalent);
   1:         }
   1:         if (textEquivalent.IsEmpty()) {
   1:           aContent->GetAttr(kNameSpaceID_None,
   1:                             nsAccessibilityAtoms::tooltiptext, textEquivalent);
   1:         }
   1:       }
   1:       AppendNameFromAccessibleFor(aContent, &textEquivalent, PR_TRUE /* use value */);
   1: 
   1:       return AppendStringWithSpaces(aFlatString, textEquivalent);
   1:     }
   1:     return NS_OK; // Not HTML and not XUL -- we don't handle it yet
   1:   }
   1: 
   1:   nsCOMPtr<nsIAtom> tag = aContent->Tag();
   1:   if (tag == nsAccessibilityAtoms::img) {
   1:     return AppendNameFromAccessibleFor(aContent, aFlatString);
   1:   }
   1: 
   1:   if (tag == nsAccessibilityAtoms::input) {
   1:     static nsIContent::AttrValuesArray strings[] =
   1:       {&nsAccessibilityAtoms::button, &nsAccessibilityAtoms::submit,
   1:        &nsAccessibilityAtoms::reset, &nsAccessibilityAtoms::image, nsnull};
   1:     if (aContent->FindAttrValueIn(kNameSpaceID_None, nsAccessibilityAtoms::type,
   1:                                   strings, eIgnoreCase) >= 0) {
   1:       return AppendNameFromAccessibleFor(aContent, aFlatString);
   1:     }
   1:   }
   1: 
   1:   if (tag == nsAccessibilityAtoms::object && !aContent->GetChildCount()) {
   1:     // If object has no alternative content children, try title
   1:     aContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::title, textEquivalent);
   1:   }
   1:   else if (tag == nsAccessibilityAtoms::br) {
   1:     // If it's a line break, insert a space so that words aren't jammed together
   1:     aFlatString->AppendLiteral("\r\n");
   1:     return NS_OK;
   1:   }
   1:   else if (tag != nsAccessibilityAtoms::a && tag != nsAccessibilityAtoms::area) { 
   1:     AppendNameFromAccessibleFor(aContent, aFlatString, PR_TRUE /* use value */);
   1:   }
   1: 
   1:   textEquivalent.CompressWhitespace();
   1:   return AppendStringWithSpaces(aFlatString, textEquivalent);
   1: }
   1: 
   1: 
   1: nsresult nsAccessible::AppendFlatStringFromSubtree(nsIContent *aContent, nsAString *aFlatString)
   1: {
6941:   static nsIContent *startContent = nsnull;
6941:   // never run into the same content node, to prevent infinite recursion
6941:   if (startContent == aContent) {
6941:     return NS_OK;
6941:   }
6941:   if (!startContent) {
6941:     startContent = aContent;
6941:   }
   1:   nsresult rv = AppendFlatStringFromSubtreeRecurse(aContent, aFlatString);
   1:   if (NS_SUCCEEDED(rv) && !aFlatString->IsEmpty()) {
   1:     nsAString::const_iterator start, end;
   1:     aFlatString->BeginReading(start);
   1:     aFlatString->EndReading(end);
   1: 
   1:     PRInt32 spacesToTruncate = 0;
   1:     while (-- end != start && *end == ' ')
   1:       ++ spacesToTruncate;
   1: 
   1:     if (spacesToTruncate > 0)
   1:       aFlatString->Truncate(aFlatString->Length() - spacesToTruncate);
   1:   }
   1: 
6941:   if (startContent == aContent) {
6941:     // we are leaving the original invoking
6941:     startContent = nsnull;
6941:   }
   1:   return rv;
   1: }
   1: 
   1: nsresult nsAccessible::AppendFlatStringFromSubtreeRecurse(nsIContent *aContent, nsAString *aFlatString)
   1: {
   1:   // Depth first search for all text nodes that are decendants of content node.
   1:   // Append all the text into one flat string
   1:   PRUint32 numChildren = 0;
   1:   nsCOMPtr<nsIDOMXULSelectControlElement> selectControlEl(do_QueryInterface(aContent));
   1:   if (!selectControlEl) {  // Don't walk children of elements with options, just get label directly
   1:     numChildren = aContent->GetChildCount();
   1:   }
   1: 
   1:   if (numChildren == 0) {
   1:     // There are no children or they are irrelvant: get the text from the current node
   1:     AppendFlatStringFromContentNode(aContent, aFlatString);
   1:     return NS_OK;
   1:   }
   1: 
   1:   // There are relevant children: use them to get the text.
   1:   PRUint32 index;
   1:   for (index = 0; index < numChildren; index++) {
   1:     AppendFlatStringFromSubtreeRecurse(aContent->GetChildAt(index), aFlatString);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsIContent *nsAccessible::GetLabelContent(nsIContent *aForNode)
   1: {
   1:   if (aForNode->IsNodeOfType(nsINode::eXUL))
6279:     return nsAccUtils::FindNeighbourPointingToNode(aForNode, eAria_none,
6279:                                                    nsAccessibilityAtoms::label,
   1:                                                    nsAccessibilityAtoms::control);
   1: 
   1:   return GetHTMLLabelContent(aForNode);
   1: }
   1: 
   1: nsIContent* nsAccessible::GetHTMLLabelContent(nsIContent *aForNode)
   1: {
   1:   // Get either <label for="[id]"> element which explictly points to aForNode, or 
   1:   // <label> ancestor which implicitly point to it
   1:   nsIContent *walkUpContent = aForNode;
   1: 
   1:   // go up tree get name of ancestor label if there is one. Don't go up farther than form element
   1:   while ((walkUpContent = walkUpContent->GetParent()) != nsnull) {
   1:     nsIAtom *tag = walkUpContent->Tag();
   1:     if (tag == nsAccessibilityAtoms::label) {
   1:       return walkUpContent;  // An ancestor <label> implicitly points to us
   1:     }
   1:     if (tag == nsAccessibilityAtoms::form ||
   1:         tag == nsAccessibilityAtoms::body) {
   1:       // Reached top ancestor in form
   1:       // There can be a label targeted at this control using the 
   1:       // for="control_id" attribute. To save computing time, only 
   1:       // look for those inside of a form element
   1:       nsAutoString forId;
6065:       if (!nsAccUtils::GetID(aForNode, forId)) {
6065:         break;
6065:       }
   1:       // Actually we'll be walking down the content this time, with a depth first search
6279:       return nsAccUtils::FindDescendantPointingToID(&forId, walkUpContent, eAria_none,
   1:                                                     nsAccessibilityAtoms::_for);
   1:     }
   1:   }
   1: 
   1:   return nsnull;
   1: }
   1: 
6279: nsresult nsAccessible::GetTextFromRelationID(EAriaProperty aIDProperty, nsString &aName)
   1: {
   1:   // Get DHTML name from content subtree pointed to by ID attribute
   1:   aName.Truncate();
6861:   nsCOMPtr<nsIContent> content = GetRoleContent(mDOMNode);
   1:   NS_ASSERTION(content, "Called from shutdown accessible");
   1: 
   1:   nsAutoString ids;
6279:   if (!nsAccUtils::GetAriaProperty(content, mWeakShell, aIDProperty, ids)) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   ids.CompressWhitespace(PR_TRUE, PR_TRUE);
   1: 
6861:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(content->GetOwnerDoc());
   1:   NS_ENSURE_TRUE(domDoc, NS_ERROR_FAILURE);
   1:   
   1:   nsresult rv = NS_ERROR_FAILURE;
   1: 
   1:   // Support idlist as in aaa::labelledby="id1 id2 id3"
   1:   while (!ids.IsEmpty()) {
   1:     nsAutoString id;
   1:     PRInt32 idLength = ids.FindChar(' ');
   1:     NS_ASSERTION(idLength != 0, "Should not be 0 because of CompressWhitespace() call above");
   1:     if (idLength == kNotFound) {
   1:       id = ids;
   1:       ids.Truncate();
   1:     } else {
   1:       id = Substring(ids, 0, idLength);
   1:       ids.Cut(0, idLength + 1);
   1:     }
   1: 
   1:     if (!aName.IsEmpty()) {
   1:       aName += ' '; // Need whitespace between multiple labels or descriptions
   1:     }
   1:     nsCOMPtr<nsIDOMElement> labelElement;
   1:     domDoc->GetElementById(id, getter_AddRefs(labelElement));
   1:     content = do_QueryInterface(labelElement);
   1:     if (!content) {
   1:       return NS_OK;
   1:     }
   1:     // We have a label content
   1:     rv = AppendFlatStringFromSubtree(content, &aName);
   1:     if (NS_SUCCEEDED(rv)) {
   1:       aName.CompressWhitespace();
   1:     }
   1:   }
   1:   
   1:   return rv;
   1: }
   1: 
   1: /**
   1:   * Only called if the element is not a nsIDOMXULControlElement. Initially walks up
   1:   *   the DOM tree to the form, concatonating label elements as it goes. Then checks for
   1:   *   labels with the for="controlID" property.
   1:   */
   1: nsresult nsAccessible::GetHTMLName(nsAString& aLabel, PRBool aCanAggregateSubtree)
   1: {
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:   if (!content) {
   1:     return NS_ERROR_FAILURE;   // Node shut down
   1:   }
   1: 
   1:   // Check for DHTML accessibility labelledby relationship property
   1:   nsAutoString label;
6279:   nsresult rv = GetTextFromRelationID(eAria_labelledby, label);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     aLabel = label;
   1:     return rv;
   1:   }
   1: 
   1:   nsIContent *labelContent = GetHTMLLabelContent(content);
   1:   if (labelContent) {
   1:     AppendFlatStringFromSubtree(labelContent, &label);
   1:     label.CompressWhitespace();
   1:     if (!label.IsEmpty()) {
   1:       aLabel = label;
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   if (aCanAggregateSubtree) {
   1:     // Don't use AppendFlatStringFromSubtree for container widgets like menulist
   1:     nsresult rv = AppendFlatStringFromSubtree(content, &aLabel);
1942:     if (NS_SUCCEEDED(rv) && !aLabel.IsEmpty()) {
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   // Still try the title as as fallback method in that case.
   1:   if (!content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::title,
   1:                         aLabel)) {
   1:     aLabel.SetIsVoid(PR_TRUE);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: /**
   1:   * 3 main cases for XUL Controls to be labeled
   1:   *   1 - control contains label="foo"
   1:   *   2 - control has, as a child, a label element
   1:   *        - label has either value="foo" or children
   1:   *   3 - non-child label contains control="controlID"
   1:   *        - label has either value="foo" or children
   1:   * Once a label is found, the search is discontinued, so a control
   1:   *  that has a label child as well as having a label external to
   1:   *  the control that uses the control="controlID" syntax will use
   1:   *  the child label for its Name.
   1:   */
   1: nsresult nsAccessible::GetXULName(nsAString& aLabel, PRBool aCanAggregateSubtree)
   1: {
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
   1:   NS_ASSERTION(content, "No nsIContent for DOM node");
   1: 
   1:   // First check for label override via accessibility labelledby relationship
   1:   nsAutoString label;
6279:   nsresult rv = GetTextFromRelationID(eAria_labelledby, label);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     aLabel = label;
   1:     return rv;
   1:   }
   1: 
   1:   // CASE #1 (via label attribute) -- great majority of the cases
   1:   nsCOMPtr<nsIDOMXULLabeledControlElement> labeledEl(do_QueryInterface(mDOMNode));
   1:   if (labeledEl) {
   1:     rv = labeledEl->GetLabel(label);
   1:   }
   1:   else {
   1:     nsCOMPtr<nsIDOMXULSelectControlItemElement> itemEl(do_QueryInterface(mDOMNode));
   1:     if (itemEl) {
   1:       rv = itemEl->GetLabel(label);
   1:     }
   1:     else {
   1:       nsCOMPtr<nsIDOMXULSelectControlElement> select(do_QueryInterface(mDOMNode));
   1:       // Use label if this is not a select control element which 
   1:       // uses label attribute to indicate which option is selected
   1:       if (!select) {
   1:         nsCOMPtr<nsIDOMXULElement> xulEl(do_QueryInterface(mDOMNode));
   1:         if (xulEl) {
   1:           rv = xulEl->GetAttribute(NS_LITERAL_STRING("label"), label);
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   // CASES #2 and #3 ------ label as a child or <label control="id" ... > </label>
   1:   if (NS_FAILED(rv) || label.IsEmpty()) {
   1:     label.Truncate();
   1:     nsIContent *labelContent =
6279:       nsAccUtils::FindNeighbourPointingToNode(content, eAria_none,
6279:                                               nsAccessibilityAtoms::label,
   1:                                               nsAccessibilityAtoms::control);
   1: 
   1:     nsCOMPtr<nsIDOMXULLabelElement> xulLabel(do_QueryInterface(labelContent));
   1:     // Check if label's value attribute is used
   1:     if (xulLabel && NS_SUCCEEDED(xulLabel->GetValue(label)) && label.IsEmpty()) {
   1:       // If no value attribute, a non-empty label must contain
   1:       // children that define it's text -- possibly using HTML
   1:       AppendFlatStringFromSubtree(labelContent, &label);
   1:     }
   1:   }
   1: 
   1:   // XXX If CompressWhiteSpace worked on nsAString we could avoid a copy
   1:   label.CompressWhitespace();
   1:   if (!label.IsEmpty()) {
   1:     aLabel = label;
   1:     return NS_OK;
   1:   }
   1: 
   1:   content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::tooltiptext, label);
   1:   label.CompressWhitespace();
   1:   if (!label.IsEmpty()) {
   1:     aLabel = label;
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Can get text from title of <toolbaritem> if we're a child of a <toolbaritem>
   1:   nsIContent *bindingParent = content->GetBindingParent();
   1:   nsIContent *parent = bindingParent? bindingParent->GetParent() :
   1:                                       content->GetParent();
   1:   while (parent) {
   1:     if (parent->Tag() == nsAccessibilityAtoms::toolbaritem &&
   1:         parent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::title, label)) {
   1:       label.CompressWhitespace();
   1:       aLabel = label;
   1:       return NS_OK;
   1:     }
   1:     parent = parent->GetParent();
   1:   }
   1: 
   1:   // Don't use AppendFlatStringFromSubtree for container widgets like menulist
   1:   return aCanAggregateSubtree? AppendFlatStringFromSubtree(content, &aLabel) : NS_OK;
   1: }
   1: 
 763: PRBool nsAccessible::IsNodeRelevant(nsIDOMNode *aNode)
 763: {
 763:   // Can this node be accessible and attached to
 763:   // the document's accessible tree?
 763:   nsCOMPtr<nsIAccessibilityService> accService =
 763:     do_GetService("@mozilla.org/accessibilityService;1");
 763:   NS_ENSURE_TRUE(accService, PR_FALSE);
 763:   nsCOMPtr<nsIDOMNode> relevantNode;
 763:   accService->GetRelevantContentNodeFor(aNode, getter_AddRefs(relevantNode));
 763:   return aNode == relevantNode;
 763: }
 763: 
 511: NS_IMETHODIMP
3153: nsAccessible::FireToolkitEvent(PRUint32 aEvent, nsIAccessible *aTarget,
3153:                                void * aData)
3153: {
3153:   // Don't fire event for accessible that has been shut down.
3153:   if (!mWeakShell)
3153:     return NS_ERROR_FAILURE;
3153: 
3153:   nsCOMPtr<nsIAccessibleEvent> accEvent =
3153:     new nsAccEvent(aEvent, aTarget, aData);
3153:   NS_ENSURE_TRUE(accEvent, NS_ERROR_OUT_OF_MEMORY);
3153: 
3153:   return FireAccessibleEvent(accEvent);
3153: }
3153: 
3153: NS_IMETHODIMP
 511: nsAccessible::FireAccessibleEvent(nsIAccessibleEvent *aEvent)
 511: {
 763:   NS_ENSURE_ARG_POINTER(aEvent);
 763:   nsCOMPtr<nsIDOMNode> eventNode;
 763:   aEvent->GetDOMNode(getter_AddRefs(eventNode));
 763:   NS_ENSURE_TRUE(IsNodeRelevant(eventNode), NS_ERROR_FAILURE);
 763: 
 511:   nsCOMPtr<nsIObserverService> obsService =
 511:     do_GetService("@mozilla.org/observer-service;1");
 511:   NS_ENSURE_TRUE(obsService, NS_ERROR_FAILURE);
 511: 
 511:   return obsService->NotifyObservers(aEvent, NS_ACCESSIBLE_EVENT_TOPIC, nsnull);
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetFinalRole(PRUint32 *aRole)
   1: {
4850:   NS_ENSURE_ARG_POINTER(aRole);
4850:   *aRole = nsIAccessibleRole::ROLE_NOTHING;
4850: 
   1:   if (mRoleMapEntry) {
   1:     *aRole = mRoleMapEntry->role;
4265: 
4265:     // These unfortunate exceptions don't fit into the ARIA table
4265:     // This is where the nsIAccessible role depends on both the role and ARIA state
4265:     if (*aRole == nsIAccessibleRole::ROLE_ENTRY) {
4265:       nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
6279:       nsAutoString secret;
6279:       if (content && nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_secret, secret) &&
6279:           secret.EqualsLiteral("true")) {
4265:         // For entry field with aaa:secret="true"
4265:         *aRole = nsIAccessibleRole::ROLE_PASSWORD_TEXT;
4265:       }
4265:     }
4265:     else if (*aRole == nsIAccessibleRole::ROLE_PUSHBUTTON) {
4265:       nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
4265:       if (content) {
6279:         if (nsAccUtils::HasAriaProperty(content, mWeakShell, eAria_pressed)) {
4265:           // For aaa:pressed="false" or aaa:pressed="true"
4265:           // For simplicity, any pressed attribute indicates it's a toggle button
4265:           *aRole = nsIAccessibleRole::ROLE_TOGGLE_BUTTON;
4265:         }
6279:         else {
6279:           nsAutoString haspopup;
6279:           if (nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_haspopup, haspopup) &&
6279:               haspopup.EqualsLiteral("true")) {
4265:             // For button with aaa:haspopup="true"
4265:             *aRole = nsIAccessibleRole::ROLE_BUTTONMENU;
4265:           }
4265:         }
4265:       }
6279:     }
4265:   
   1:     if (*aRole != nsIAccessibleRole::ROLE_NOTHING) {
   1:       return NS_OK;
   1:     }
   1:   }
   1:   return mDOMNode ? GetRole(aRole) : NS_ERROR_FAILURE;  // Node already shut down
   1: }
   1: 
 401: NS_IMETHODIMP
 401: nsAccessible::GetAttributes(nsIPersistentProperties **aAttributes)
   1: {
 401:   NS_ENSURE_ARG_POINTER(aAttributes);
   1: 
 665:   if (!mDOMNode)
 665:     return NS_ERROR_FAILURE;
 665: 
   1:   nsCOMPtr<nsIPersistentProperties> attributes =
   1:      do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
   1:   NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
   1: 
4516:   nsAccEvent::GetLastEventAttributes(mDOMNode, attributes);
4516:  
 401:   nsresult rv = GetAttributesInternal(attributes);
 401:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIContent> content = GetRoleContent(mDOMNode);
   1:   nsAutoString id;
6844:   nsAutoString oldValueUnused;
6065:   if (content && nsAccUtils::GetID(content, id)) {
   1:     attributes->SetStringProperty(NS_LITERAL_CSTRING("id"), id, oldValueUnused);
6844:   }
6844: 
   1:   // XXX In the future we may need to expose the dynamic content role inheritance chain
   1:   // through this attribute
   1:   nsAutoString xmlRole;
6067:   if (GetARIARole(content, xmlRole)) {
   1:     attributes->SetStringProperty(NS_LITERAL_CSTRING("xml-roles"), xmlRole, oldValueUnused);          
   1:   }
   1: 
6279:   // Make sure to keep these two arrays in sync
6279:   PRUint32 ariaPropTypes = nsAccUtils::GetAriaPropTypes(content, mWeakShell);
6279:   char *ariaPropertyString[] = { "live", "channel", "atomic", "relevant", "datatype", "level",
3123:                              "posinset", "setsize", "sort", "grab", "dropeffect"};
6279:   EAriaProperty ariaPropertyEnum[] = { eAria_live, eAria_channel, eAria_atomic, eAria_relevant,
6279:                                      eAria_datatype, eAria_level, eAria_posinset, eAria_setsize,
6279:                                      eAria_sort, eAria_grab, eAria_dropeffect};
6279:   NS_ASSERTION(NS_ARRAY_LENGTH(ariaPropertyString) == NS_ARRAY_LENGTH(ariaPropertyEnum),
6279:                "ARIA attributes and object property name arrays out of sync");
6279:   for (PRUint32 index = 0; index < NS_ARRAY_LENGTH(ariaPropertyString); index ++) {
   1:     nsAutoString value;
6279:     if (nsAccUtils::GetAriaProperty(content, mWeakShell, ariaPropertyEnum[index], value, ariaPropTypes)) {
   1:       ToLowerCase(value);
6279:       attributes->SetStringProperty(nsDependentCString(ariaPropertyString[index]), value, oldValueUnused);    
   1:     }
   1:   }
6066: 
6066:   // Get container-foo computed live region properties based on the closest container with
6066:   // the live region attribute
6066:   nsAutoString atomic, live, relevant, channel, busy;
6066:   while (content) {
6066:     if (relevant.IsEmpty() &&
6279:         nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_relevant, relevant, ariaPropTypes))
6066:       attributes->SetStringProperty(NS_LITERAL_CSTRING("container-relevant"), relevant, oldValueUnused);
6066:     if (live.IsEmpty() &&
6279:         nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_live, live, ariaPropTypes))
6066:       attributes->SetStringProperty(NS_LITERAL_CSTRING("container-live"), live, oldValueUnused);
6066:     if (channel.IsEmpty() &&
6279:         nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_channel, channel, ariaPropTypes))
6066:       attributes->SetStringProperty(NS_LITERAL_CSTRING("container-channel"), channel, oldValueUnused);
6066:     if (atomic.IsEmpty() &&
6279:         nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_atomic, atomic, ariaPropTypes))
6066:       attributes->SetStringProperty(NS_LITERAL_CSTRING("container-atomic"), atomic, oldValueUnused);
6066:     if (busy.IsEmpty() &&
6279:         nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_busy, busy, ariaPropTypes))
6066:       attributes->SetStringProperty(NS_LITERAL_CSTRING("container-busy"), busy, oldValueUnused);
6066:     content = content->GetParent();
6066:   }
   1: 
3146:   if (!nsAccUtils::HasAccGroupAttrs(attributes)) {
 401:     // The role of an accessible can be pointed by ARIA attribute but ARIA
 401:     // posinset, level, setsize may be skipped. Therefore we calculate here
 401:     // these properties to map them into description.
 401: 
 439:     // If accessible is invisible we don't want to calculate group ARIA
 439:     // attributes for it.
 401:     PRUint32 role = Role(this);
4516:     if ((role == nsIAccessibleRole::ROLE_LISTITEM ||
 401:         role == nsIAccessibleRole::ROLE_MENUITEM ||
 401:         role == nsIAccessibleRole::ROLE_RADIOBUTTON ||
 401:         role == nsIAccessibleRole::ROLE_PAGETAB ||
4516:         role == nsIAccessibleRole::ROLE_OUTLINEITEM) &&
4516:         0 == (State(this) & nsIAccessibleStates::STATE_INVISIBLE)) {
 401:       nsCOMPtr<nsIAccessible> parent = GetParent();
 401:       NS_ENSURE_TRUE(parent, NS_ERROR_FAILURE);
 401: 
 401:       PRInt32 positionInGroup = 0;
 401:       PRInt32 setSize = 0;
 401: 
 401:       nsCOMPtr<nsIAccessible> sibling, nextSibling;
 401:       parent->GetFirstChild(getter_AddRefs(sibling));
 401:       NS_ENSURE_TRUE(sibling, NS_ERROR_FAILURE);
 401: 
 401:       PRBool foundCurrent = PR_FALSE;
 401:       PRUint32 siblingRole;
 401:       while (sibling) {
 401:         sibling->GetFinalRole(&siblingRole);
 439:         if (siblingRole == role &&
 439:             !(State(sibling) & nsIAccessibleStates::STATE_INVISIBLE)) {
 401:           ++ setSize;
 401:           if (!foundCurrent) {
 401:             ++ positionInGroup;
 401:             if (sibling == this)
 401:               foundCurrent = PR_TRUE;
 401:           }
 401:         }
 401:         sibling->GetNextSibling(getter_AddRefs(nextSibling));
 401:         sibling = nextSibling;
 401:       }
 401: 
 401:       PRInt32 groupLevel = 0;
 401:       if (role == nsIAccessibleRole::ROLE_OUTLINEITEM) {
 401:         groupLevel = 1;
 401:         nsCOMPtr<nsIAccessible> nextParent;
 401:         while (parent) {
 401:           parent->GetFinalRole(&role);
 401: 
 401:           if (role == nsIAccessibleRole::ROLE_OUTLINE)
 401:             break;
4471:           if (role == nsIAccessibleRole::ROLE_GROUPING)
 401:             ++ groupLevel;
 401: 
 401:           parent->GetParent(getter_AddRefs(nextParent));
 401:           parent.swap(nextParent);
 401:         }
 401:       }
 401: 
3146:       nsAccUtils::SetAccGroupAttrs(attributes, groupLevel, positionInGroup,
 401:                                    setSize);
 401:     }
 401:   }
 401: 
   1:   attributes.swap(*aAttributes);
   1: 
   1:   return NS_OK;
   1: }
   1: 
 401: nsresult
 401: nsAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
 401: {
 401:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(mDOMNode));
 401:   NS_ENSURE_TRUE(element, NS_ERROR_UNEXPECTED);
 401: 
 401:   nsAutoString tagName;
 401:   element->GetTagName(tagName);
 401:   if (!tagName.IsEmpty()) {
 401:     nsAutoString oldValueUnused;
 401:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("tag"), tagName,
 401:                                    oldValueUnused);
 401:   }
 401: 
 401:   return NS_OK;
 401: }
 401: 
 144: NS_IMETHODIMP
 144: nsAccessible::GroupPosition(PRInt32 *aGroupLevel,
 144:                             PRInt32 *aSimilarItemsInGroup,
 144:                             PRInt32 *aPositionInGroup)
 144: {
 144:   // Every element exposes level/posinset/sizeset for IAccessdible::attributes
 144:   // if they make sense for it. These attributes are mapped into groupPosition.
 144:   // If 'level' attribute doesn't make sense element then it isn't represented
 144:   // via IAccessible::attributes and groupLevel of groupPosition method is 0.
 144:   // Elements that expose 'level' attribute only (like html headings elements)
6100:   // don't support this method and all arguments  are equalled 0.
 144: 
 144:   NS_ENSURE_ARG_POINTER(aGroupLevel);
 144:   NS_ENSURE_ARG_POINTER(aSimilarItemsInGroup);
 144:   NS_ENSURE_ARG_POINTER(aPositionInGroup);
 144: 
 144:   *aGroupLevel = 0;
 144:   *aSimilarItemsInGroup = 0;
 144:   *aPositionInGroup = 0;
 144: 
 144:   nsCOMPtr<nsIPersistentProperties> attributes;
 144:   nsresult rv = GetAttributes(getter_AddRefs(attributes));
 144:   NS_ENSURE_SUCCESS(rv, rv);
 757:   if (!attributes) {
 757:     return NS_ERROR_FAILURE;
 757:   }
 144:   PRInt32 level, posInSet, setSize;
3146:   nsAccUtils::GetAccGroupAttrs(attributes, &level, &posInSet, &setSize);
 144: 
 144:   if (!posInSet && !setSize)
 144:     return NS_OK;
 144: 
 144:   *aGroupLevel = level;
 144: 
 579:   *aPositionInGroup = posInSet;
 144:   *aSimilarItemsInGroup = setSize - 1;
 144: 
 144:   return NS_OK;
 144: }
 144: 
   1: PRBool nsAccessible::MappedAttrState(nsIContent *aContent, PRUint32 *aStateInOut,
   1:                                      nsStateMapEntry *aStateMapEntry)
   1: {
   1:   // Return true if we should continue
6279:   if (aStateMapEntry->attributeName == eAria_none) {
   1:     return PR_FALSE;  // Stop looking -- no more states
   1:   }
   1: 
   1:   nsAutoString attribValue;
6279:   if (nsAccUtils::GetAriaProperty(aContent, mWeakShell, aStateMapEntry->attributeName, attribValue)) {
2136:     if (aStateMapEntry->attributeValue == kBoolState) {
   1:       // No attribute value map specified in state map entry indicates state cleared
   1:       if (attribValue.EqualsLiteral("false")) {
5752:         *aStateInOut &= ~aStateMapEntry->state;
5752:       }
5752:       else {
5752:         *aStateInOut |= aStateMapEntry->state;
5752:       }
5752:     }
5752:     else if (NS_ConvertUTF16toUTF8(attribValue).Equals(aStateMapEntry->attributeValue)) {
5752:       *aStateInOut |= aStateMapEntry->state;
   1:     }
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
 262: NS_IMETHODIMP
 262: nsAccessible::GetFinalState(PRUint32 *aState, PRUint32 *aExtraState)
   1: {
 262:   NS_ENSURE_ARG_POINTER(aState);
 262: 
 262:   nsresult rv = GetState(aState, aExtraState);
 262:   NS_ENSURE_SUCCESS(rv, rv);
 262: 
4381:   // Apply ARIA states to be sure accessible states will be overriden.
5448:   *aState |= GetARIAState();
4381: 
6596:   if (mRoleMapEntry && mRoleMapEntry->role == nsIAccessibleRole::ROLE_PAGETAB) {
6596:     if (*aState & nsIAccessibleStates::STATE_FOCUSED) {
6596:       *aState |= nsIAccessibleStates::STATE_SELECTED;
6596:     } else {
6596:       // Expose 'selected' state on ARIA tab if the focus is on internal element
6596:       // of related tabpanel.
6596:       nsCOMPtr<nsIAccessible> tabPanel;
6596:       rv = GetAccessibleRelated(nsIAccessibleRelation::RELATION_LABEL_FOR,
6596:                                 getter_AddRefs(tabPanel));
6596:       NS_ENSURE_SUCCESS(rv, rv);
6596: 
6596:       if (tabPanel && Role(tabPanel) == nsIAccessibleRole::ROLE_PROPERTYPAGE) {
6596:         nsCOMPtr<nsIAccessNode> tabPanelAccessNode(do_QueryInterface(tabPanel));
6596:         nsCOMPtr<nsIDOMNode> tabPanelNode;
6596:         tabPanelAccessNode->GetDOMNode(getter_AddRefs(tabPanelNode));
6596:         NS_ENSURE_STATE(tabPanelNode);
6596: 
6596:         if (nsAccUtils::IsAncestorOf(tabPanelNode, gLastFocusedNode))
6596:           *aState |= nsIAccessibleStates::STATE_SELECTED;
6596:       }
6596:     }
6596:   }
6596: 
3465:   // Set additional states which presence depends on another states.
6172:   if (!aExtraState)
6172:     return NS_OK;
6172: 
3465:   if (!(*aState & nsIAccessibleStates::STATE_UNAVAILABLE)) {
3465:     *aExtraState |= nsIAccessibleStates::EXT_STATE_ENABLED |
3465:                     nsIAccessibleStates::EXT_STATE_SENSITIVE;
3465:   }
3465: 
4267:   const PRUint32 kExpandCollapseStates =
4267:     nsIAccessibleStates::STATE_COLLAPSED | nsIAccessibleStates::STATE_EXPANDED;
4267:   if (*aState & kExpandCollapseStates) {
3465:     *aExtraState |= nsIAccessibleStates::EXT_STATE_EXPANDABLE;
4267:     if ((*aState & kExpandCollapseStates) == kExpandCollapseStates) {
4267:       // Cannot be both expanded and collapsed -- this happens 
4267:       // in ARIA expanded combobox because of limitation of nsARIAMap
4267:       // XXX Perhaps we will be able to make this less hacky if 
4267:       // we support extended states in nsARIAMap, e.g. derive
4267:       // COLLAPSED from EXPANDABLE && !EXPANDED
4267:       *aExtraState &= ~nsIAccessibleStates::STATE_COLLAPSED;
4267:     }
3465:   }
6172: 
6172:   PRUint32 role;
6172:   rv = GetFinalRole(&role);
6172:   NS_ENSURE_SUCCESS(rv, rv);
6172: 
6172:   if (role == nsIAccessibleRole::ROLE_ENTRY ||
6172:       role == nsIAccessibleRole::ROLE_PASSWORD_TEXT ||
6172:       role == nsIAccessibleRole::ROLE_COMBOBOX) {
6172: 
6172:     nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
6172:     NS_ENSURE_STATE(content);
6172: 
6172:     nsAutoString autocomplete;
6279:     if (nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_autocomplete, autocomplete) &&
6172:         (autocomplete.EqualsIgnoreCase("inline") ||
6172:          autocomplete.EqualsIgnoreCase("list") ||
6172:          autocomplete.EqualsIgnoreCase("both"))) {
6172:       *aExtraState |= nsIAccessibleStates::EXT_STATE_SUPPORTS_AUTOCOMPLETION;
6172:     }
6172: 
6172:     // XXX We can remove this hack once we support RDF-based role & state maps
6172:     if (mRoleMapEntry && mRoleMapEntry->role == nsIAccessibleRole::ROLE_ENTRY) {
6279:       nsAutoString multiline;
6279:       if (nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_multiline, multiline) &&
6279:           multiline.EqualsLiteral("true")) {
6172:         *aExtraState |= nsIAccessibleStates::EXT_STATE_MULTI_LINE;
6172:       }
6172:       else {
6172:         *aExtraState |= nsIAccessibleStates::EXT_STATE_SINGLE_LINE;
6172:       }
6172:     }
6172:   }
6172: 
6172:   // For some reasons DOM node may have not a frame. We tract such accessibles
6172:   // as invisible.
5424:   nsIFrame *frame = GetFrame();
6172:   if (!frame)
6172:     return NS_OK;
6172: 
5424:   const nsStyleDisplay* display = frame->GetStyleDisplay();
5424:   if (display && display->mOpacity == 1.0f &&
5424:       !(*aState & nsIAccessibleStates::STATE_INVISIBLE)) {
5424:     *aExtraState |= nsIAccessibleStates::EXT_STATE_OPAQUE;
5424:   }
5424: 
5424:   const nsStyleXUL *xulStyle = frame->GetStyleXUL();
5424:   if (xulStyle) {
5424:     // In XUL all boxes are either vertical or horizontal
5424:     if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL) {
5424:       *aExtraState |= nsIAccessibleStates::EXT_STATE_VERTICAL;
5424:     }
5424:     else {
5424:       *aExtraState |= nsIAccessibleStates::EXT_STATE_HORIZONTAL;
5424:     }
5424:   }
3465: 
4381:   return NS_OK;
 262: }
 262: 
5448: PRUint32
5448: nsAccessible::GetARIAState()
 262: {
   1:   // Test for universal states first
   1:   nsIContent *content = GetRoleContent(mDOMNode);
5448:   if (!content) {
5448:     return 0;
5448:   }
5448: 
5448:   PRUint32 ariaState = 0;
2136:   PRUint32 index = 0;
6279:   while (MappedAttrState(content, &ariaState, &nsARIAMap::gWAIUnivStateMap[index])) {
2136:     ++ index;
 262:   }
 262: 
 262:   if (!mRoleMapEntry)
5448:     return ariaState;
 262: 
   1:   // Once DHTML role is used, we're only readonly if DHTML readonly used
5448:   ariaState &= ~nsIAccessibleStates::STATE_READONLY;
5448: 
5448:   if (ariaState & nsIAccessibleStates::STATE_UNAVAILABLE) {
   1:     // Disabled elements are not selectable or focusable, even if disabled
   1:     // via DHTML accessibility disabled property
5448:     ariaState &= ~(nsIAccessibleStates::STATE_SELECTABLE |
 262:                    nsIAccessibleStates::STATE_FOCUSABLE);
 262:   }
 262: 
5448:   ariaState |= mRoleMapEntry->state;
5448:   if (MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap1) &&
5448:       MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap2) &&
5448:       MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap3) &&
5448:       MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap4) &&
5448:       MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap5) &&
5448:       MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap6) &&
5448:       MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap7)) {
5448:     MappedAttrState(content, &ariaState, &mRoleMapEntry->attributeMap8);
5448:   }
5448: 
5448:   return ariaState;
   1: }
   1: 
   1: // Not implemented by this class
   1: 
   1: /* DOMString getValue (); */
   1: NS_IMETHODIMP nsAccessible::GetValue(nsAString& aValue)
   1: {
   1:   if (!mDOMNode) {
   1:     return NS_ERROR_FAILURE;  // Node already shut down
   1:   }
   1:   if (mRoleMapEntry) {
   1:     if (mRoleMapEntry->valueRule == eNoValue) {
   1:       return NS_OK;
   1:     }
   1:     nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
6279:     if (content && nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_valuenow, aValue)) {
   1:       return NS_OK;
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
4274: // nsIAccessibleValue
4274: NS_IMETHODIMP
4274: nsAccessible::GetMaximumValue(double *aMaximumValue)
   1: {
6279:   return GetAttrValue(eAria_valuemax, aMaximumValue);
4274: }
4274: 
4274: NS_IMETHODIMP
4274: nsAccessible::GetMinimumValue(double *aMinimumValue)
4274: {
6279:   return GetAttrValue(eAria_valuemin, aMinimumValue);
4274: }
4274: 
4274: NS_IMETHODIMP
4274: nsAccessible::GetMinimumIncrement(double *aMinIncrement)
4274: {
4274:   NS_ENSURE_ARG_POINTER(aMinIncrement);
4274:   *aMinIncrement = 0;
4274: 
4274:   // No mimimum increment in dynamic content spec right now
4274:   return NS_OK_NO_ARIA_VALUE;
4274: }
4274: 
4274: NS_IMETHODIMP
4274: nsAccessible::GetCurrentValue(double *aValue)
4274: {
6279:   return GetAttrValue(eAria_valuenow, aValue);
4274: }
4274: 
4274: NS_IMETHODIMP
4274: nsAccessible::SetCurrentValue(double aValue)
4274: {
4274:   if (!mDOMNode)
4039:     return NS_ERROR_FAILURE;  // Node already shut down
4274: 
4274:   if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
4274:     return NS_OK_NO_ARIA_VALUE;
4274: 
   1:   const PRUint32 kValueCannotChange = nsIAccessibleStates::STATE_READONLY |
   1:                                       nsIAccessibleStates::STATE_UNAVAILABLE;
   1: 
4274:   if (State(this) & kValueCannotChange)
   1:     return NS_ERROR_FAILURE;
4274: 
4274:   double minValue = 0;
4274:   if (NS_SUCCEEDED(GetMinimumValue(&minValue)) && aValue < minValue)
   1:     return NS_ERROR_INVALID_ARG;
4274: 
4274:   double maxValue = 0;
4274:   if (NS_SUCCEEDED(GetMaximumValue(&maxValue)) && aValue > maxValue)
   1:     return NS_ERROR_INVALID_ARG;
4274: 
   1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
4274:   NS_ENSURE_STATE(content);
4274: 
   1:   nsAutoString newValue;
   1:   newValue.AppendFloat(aValue);
6279:   if (0 == (nsAccUtils::GetAriaPropTypes(content, mWeakShell) &
6279:             nsIAccessibleDocument::eCheckNamespaced)) {
6279:     // No WAI namespaced properties used in this doc
6279:     return content->SetAttr(kNameSpaceID_None,
6279:                             nsAccessibilityAtoms::aria_valuenow, newValue, PR_TRUE);
6279:   }
   1:   return content->SetAttr(kNameSpaceID_WAIProperties,
   1:                           nsAccessibilityAtoms::valuenow, newValue, PR_TRUE);
   1: }
   1: 
   1: /* void setName (in DOMString name); */
   1: NS_IMETHODIMP nsAccessible::SetName(const nsAString& name)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsAccessible::GetDefaultKeyBinding(nsAString& aKeyBinding)
   1: {
   1:   aKeyBinding.Truncate();
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsAccessible::GetKeyBindings(PRUint8 aActionIndex,
   1:                              nsIDOMDOMStringList **aKeyBindings)
   1: {
   1:   // Currently we support only unique key binding on element for default action.
   1:   NS_ENSURE_TRUE(aActionIndex == 0, NS_ERROR_INVALID_ARG);
   1: 
   1:   nsAccessibleDOMStringList *keyBindings = new nsAccessibleDOMStringList();
   1:   NS_ENSURE_TRUE(keyBindings, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   nsAutoString defaultKey;
   1:   nsresult rv = GetDefaultKeyBinding(defaultKey);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (!defaultKey.IsEmpty())
   1:     keyBindings->Add(defaultKey);
   1: 
   1:   NS_ADDREF(*aKeyBindings = keyBindings);
   1:   return NS_OK;
   1: }
   1: 
   1: /* unsigned long getRole (); */
   1: NS_IMETHODIMP nsAccessible::GetRole(PRUint32 *aRole)
   1: {
4850:   NS_ENSURE_ARG_POINTER(aRole);
   1:   *aRole = nsIAccessibleRole::ROLE_NOTHING;
   1:   return NS_OK;
   1: }
   1: 
   1: /* PRUint8 getAccNumActions (); */
   1: NS_IMETHODIMP nsAccessible::GetNumActions(PRUint8 *aNumActions)
   1: {
   1:   *aNumActions = 0;
   1:   return NS_OK;
   1: }
   1: 
   1: /* DOMString getAccActionName (in PRUint8 index); */
   1: NS_IMETHODIMP nsAccessible::GetActionName(PRUint8 index, nsAString& aName)
   1: {
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: /* DOMString getActionDescription (in PRUint8 index); */
   1: NS_IMETHODIMP nsAccessible::GetActionDescription(PRUint8 aIndex, nsAString& aDescription)
   1: {
   1:   // default to localized action name.
   1:   nsAutoString name;
   1:   nsresult rv = GetActionName(aIndex, name);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return GetTranslatedString(name, aDescription);
   1: }
   1: 
   1: /* void doAction (in PRUint8 index); */
   1: NS_IMETHODIMP nsAccessible::DoAction(PRUint8 index)
   1: {
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: /* DOMString getHelp (); */
   1: NS_IMETHODIMP nsAccessible::GetHelp(nsAString& _retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: /* nsIAccessible getAccessibleToRight(); */
   1: NS_IMETHODIMP nsAccessible::GetAccessibleToRight(nsIAccessible **_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: /* nsIAccessible getAccessibleToLeft(); */
   1: NS_IMETHODIMP nsAccessible::GetAccessibleToLeft(nsIAccessible **_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: /* nsIAccessible getAccessibleAbove(); */
   1: NS_IMETHODIMP nsAccessible::GetAccessibleAbove(nsIAccessible **_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: /* nsIAccessible getAccessibleBelow(); */
   1: NS_IMETHODIMP nsAccessible::GetAccessibleBelow(nsIAccessible **_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
6066: nsIDOMNode* nsAccessible::GetAtomicRegion()
6066: {
6066:   nsCOMPtr<nsIContent> content = do_QueryInterface(mDOMNode);
6066:   nsIContent *loopContent = content;
6066:   nsAutoString atomic;
6279:   PRUint32 ariaPropTypes = nsAccUtils::GetAriaPropTypes(content, mWeakShell);
6279: 
6279:   while (loopContent && !nsAccUtils::GetAriaProperty(loopContent, mWeakShell,
6279:                                                      eAria_atomic, atomic,
6279:                                                      ariaPropTypes)) {
6066:     loopContent = loopContent->GetParent();
6066:   }
6066: 
6066:   nsCOMPtr<nsIDOMNode> atomicRegion;
6066:   if (atomic.EqualsLiteral("true")) {
6066:     atomicRegion = do_QueryInterface(loopContent);
6066:   }
6066:   return atomicRegion;
6066: }
   1: 
   1: /* nsIAccessible getAccessibleRelated(); */
   1: NS_IMETHODIMP nsAccessible::GetAccessibleRelated(PRUint32 aRelationType, nsIAccessible **aRelated)
   1: {
   1:   // When adding support for relations, make sure to add them to
   1:   // appropriate places in nsAccessibleWrap implementations
   1:   *aRelated = nsnull;
   1: 
   1:   // Relationships are defined on the same content node
   1:   // that the role would be defined on
   1:   nsIContent *content = GetRoleContent(mDOMNode);
   1:   if (!content) {
   1:     return NS_ERROR_FAILURE;  // Node already shut down
   1:   }
   1: 
   1:   nsCOMPtr<nsIDOMNode> relatedNode;
   1:   nsAutoString relatedID;
   1: 
   1:   // Search for the related DOM node according to the specified "relation type"
   1:   switch (aRelationType)
   1:   {
1628:   case nsIAccessibleRelation::RELATION_LABEL_FOR:
   1:     {
   1:       if (content->Tag() == nsAccessibilityAtoms::label) {
   1:         nsIAtom *relatedIDAttr = content->IsNodeOfType(nsINode::eHTML) ?
   1:           nsAccessibilityAtoms::_for : nsAccessibilityAtoms::control;
   1:         content->GetAttr(kNameSpaceID_None, relatedIDAttr, relatedID);
   1:       }
   1:       if (relatedID.IsEmpty()) {
6279:         relatedNode =
6279:           do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_labelledby));
   1:       }
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_LABELLED_BY:
   1:     {
6279:       if (!nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_labelledby, relatedID)) {
   1:         relatedNode = do_QueryInterface(GetLabelContent(content));
   1:       }
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_DESCRIBED_BY:
   1:     {
6279:       if (!nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_describedby, relatedID)) {
6279:         relatedNode = do_QueryInterface(
6279:           nsAccUtils::FindNeighbourPointingToNode(content, eAria_none,
   1:                                                   nsAccessibilityAtoms::description,
6279:                                                   nsAccessibilityAtoms::control));
6279: 
   1:       }
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_DESCRIPTION_FOR:
   1:     {
   1:       relatedNode =
6279:         do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_describedby));
   1: 
   1:       if (!relatedNode && content->Tag() == nsAccessibilityAtoms::description &&
   1:           content->IsNodeOfType(nsINode::eXUL)) {
   1:         // This affectively adds an optional control attribute to xul:description,
   1:         // which only affects accessibility, by allowing the description to be
   1:         // tied to a control.
   1:         content->GetAttr(kNameSpaceID_None,
   1:                          nsAccessibilityAtoms::control, relatedID);
   1:       }
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_NODE_CHILD_OF:
   1:     {
6279:       relatedNode =
6279:         do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_owns));
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_CONTROLLED_BY:
   1:     {
6279:       relatedNode =
6279:         do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_controls));
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_CONTROLLER_FOR:
   1:     {
6279:       nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_controls, relatedID);
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_FLOWS_TO:
   1:     {
6279:       nsAccUtils::GetAriaProperty(content, mWeakShell, eAria_flowto, relatedID);
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_FLOWS_FROM:
   1:     {
6279:       relatedNode =
6279:         do_QueryInterface(nsAccUtils::FindNeighbourPointingToNode(content, eAria_flowto));
   1:       break;
   1:     }
1628:   case nsIAccessibleRelation::RELATION_DEFAULT_BUTTON:
   1:     {
   1:       if (content->IsNodeOfType(nsINode::eHTML)) {
4451:         // HTML form controls implements nsIFormControl interface.
4451:         nsCOMPtr<nsIFormControl> control(do_QueryInterface(content));
4451:         if (control) {
4451:           nsCOMPtr<nsIDOMHTMLFormElement> htmlform;
4451:           control->GetForm(getter_AddRefs(htmlform));
4451:           nsCOMPtr<nsIForm> form(do_QueryInterface(htmlform));
4451:           if (form)
   1:             relatedNode = do_QueryInterface(form->GetDefaultSubmitElement());
   1:         }
   1:       }
   1:       else {
   1:         // In XUL, use first <button default="true" .../> in the document
   1:         nsCOMPtr<nsIDOMXULDocument> xulDoc = do_QueryInterface(content->GetDocument());
   1:         nsCOMPtr<nsIDOMXULButtonElement> buttonEl;
   1:         if (xulDoc) {
   1:           nsCOMPtr<nsIDOMNodeList> possibleDefaultButtons;
   1:           xulDoc->GetElementsByAttribute(NS_LITERAL_STRING("default"),
   1:                                          NS_LITERAL_STRING("true"),
   1:                                          getter_AddRefs(possibleDefaultButtons));
   1:           if (possibleDefaultButtons) {
   1:             PRUint32 length;
   1:             possibleDefaultButtons->GetLength(&length);
   1:             nsCOMPtr<nsIDOMNode> possibleButton;
   1:             // Check for button in list of default="true" elements
   1:             for (PRUint32 count = 0; count < length && !buttonEl; count ++) {
   1:               possibleDefaultButtons->Item(count, getter_AddRefs(possibleButton));
   1:               buttonEl = do_QueryInterface(possibleButton);
   1:             }
   1:           }
   1:           if (!buttonEl) { // Check for anonymous accept button in <dialog>
   1:             nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(xulDoc));
   1:             if (xblDoc) {
   1:               nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(xulDoc);
   1:               NS_ASSERTION(domDoc, "No DOM document");
   1:               nsCOMPtr<nsIDOMElement> rootEl;
   1:               domDoc->GetDocumentElement(getter_AddRefs(rootEl));
   1:               if (rootEl) {
   1:                 nsCOMPtr<nsIDOMElement> possibleButtonEl;
   1:                 xblDoc->GetAnonymousElementByAttribute(rootEl,
   1:                                                       NS_LITERAL_STRING("default"),
   1:                                                       NS_LITERAL_STRING("true"),
   1:                                                       getter_AddRefs(possibleButtonEl));
   1:                 buttonEl = do_QueryInterface(possibleButtonEl);
   1:               }
   1:             }
   1:           }
   1:           relatedNode = do_QueryInterface(buttonEl);
   1:         }
   1:       }
   1:       break;
   1:     }
4516:   case nsIAccessibleRelation::RELATION_MEMBER_OF:
4516:     {
6066:       relatedNode = GetAtomicRegion();
4516:       break;
4516:     }
   1:   default:
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1:   }
   1: 
   1:   if (!relatedID.IsEmpty()) {
   1:     // In some cases we need to get the relatedNode from an ID-style attribute
   1:     nsCOMPtr<nsIDOMDocument> domDoc;
   1:     mDOMNode->GetOwnerDocument(getter_AddRefs(domDoc));
   1:     NS_ENSURE_TRUE(domDoc, NS_ERROR_FAILURE);
   1:     nsCOMPtr<nsIDOMElement> relatedEl;
   1:     domDoc->GetElementById(relatedID, getter_AddRefs(relatedEl));
   1:     relatedNode = do_QueryInterface(relatedEl);
   1:   }
   1: 
   1:   // Return the corresponding accessible if the related DOM node is found
   1:   if (relatedNode) {
1628:     nsCOMPtr<nsIAccessibilityService> accService = GetAccService();
   1:     NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
2985:     accService->GetAccessibleInWeakShell(relatedNode, mWeakShell, aRelated);
2985:   }
2985:   return NS_OK;
   1: }
   1: 
1628: NS_IMETHODIMP
1628: nsAccessible::GetRelationsCount(PRUint32 *aCount)
1628: {
1628:   NS_ENSURE_ARG_POINTER(aCount);
1628:   *aCount = 0;
1628: 
1628:   nsCOMPtr<nsIArray> relations;
1628:   nsresult rv = GetRelations(getter_AddRefs(relations));
1628:   NS_ENSURE_SUCCESS(rv, rv);
1628: 
1628:   return relations->GetLength(aCount);
1628: }
1628: 
1628: NS_IMETHODIMP
1628: nsAccessible::GetRelation(PRUint32 aIndex, nsIAccessibleRelation **aRelation)
1628: {
1628:   NS_ENSURE_ARG_POINTER(aRelation);
1628:   *aRelation = nsnull;
1628: 
1628:   nsCOMPtr<nsIArray> relations;
1628:   nsresult rv = GetRelations(getter_AddRefs(relations));
1628:   NS_ENSURE_SUCCESS(rv, rv);
1628: 
1628:   nsCOMPtr<nsIAccessibleRelation> relation;
1628:   rv = relations->QueryElementAt(aIndex, NS_GET_IID(nsIAccessibleRelation),
1628:                                  getter_AddRefs(relation));
1628:   NS_ENSURE_SUCCESS(rv, rv);
1628: 
1628:   NS_IF_ADDREF(*aRelation = relation);
1628:   return rv;
1628: }
1628: 
1628: NS_IMETHODIMP
1628: nsAccessible::GetRelations(nsIArray **aRelations)
1628: {
1628:   NS_ENSURE_ARG_POINTER(aRelations);
1628: 
1628:   nsCOMPtr<nsIMutableArray> relations = do_CreateInstance(NS_ARRAY_CONTRACTID);
1628:   NS_ENSURE_TRUE(relations, NS_ERROR_OUT_OF_MEMORY);
1628: 
5475:   for (PRUint32 relType = nsIAccessibleRelation::RELATION_FIRST;
5475:        relType < nsIAccessibleRelation::RELATION_LAST;
5475:        ++relType) {
1628:     nsCOMPtr<nsIAccessible> accessible;
5475:     GetAccessibleRelated(relType, getter_AddRefs(accessible));
1628: 
1628:     if (accessible) {
1628:       nsCOMPtr<nsIAccessibleRelation> relation =
1828:         new nsAccessibleRelationWrap(relType, accessible);
1628:       NS_ENSURE_TRUE(relation, NS_ERROR_OUT_OF_MEMORY);
1628: 
1628:       relations->AppendElement(relation, PR_FALSE);
1628:     }
1628:   }
1628: 
1628:   NS_ADDREF(*aRelations = relations);
1628:   return NS_OK;
1628: }
1628: 
   1: /* void extendSelection (); */
   1: NS_IMETHODIMP nsAccessible::ExtendSelection()
   1: {
   1:   // XXX Should be implemented, but not high priority
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: /* [noscript] void getNativeInterface(out voidPtr aOutAccessible); */
   1: NS_IMETHODIMP nsAccessible::GetNativeInterface(void **aOutAccessible)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: void nsAccessible::DoCommandCallback(nsITimer *aTimer, void *aClosure)
   1: {
   1:   NS_ASSERTION(gDoCommandTimer, "How did we get here if there was no gDoCommandTimer?");
   1:   NS_RELEASE(gDoCommandTimer);
   1: 
3233:   nsIContent *content = reinterpret_cast<nsIContent*>(aClosure);
   1:   nsCOMPtr<nsIDOMXULElement> xulElement(do_QueryInterface(content));
   1:   if (xulElement) {
   1:     xulElement->Click();
   1:   }
   1:   else {
   1:     nsIDocument *doc = content->GetDocument();
   1:     if (!doc) {
   1:       return;
   1:     }
 981:     nsCOMPtr<nsIPresShell> presShell = doc->GetPrimaryShell();
   1:     nsPIDOMWindow *outerWindow = doc->GetWindow();
   1:     if (presShell && outerWindow) {
   1:       nsAutoPopupStatePusher popupStatePusher(outerWindow, openAllowed);
   1: 
   1:       nsMouseEvent downEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull,
   1:                              nsMouseEvent::eSynthesized);
   1:       nsMouseEvent upEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull,
   1:                            nsMouseEvent::eSynthesized);
   1:       nsMouseEvent clickEvent(PR_TRUE, NS_MOUSE_CLICK, nsnull,
   1:                               nsMouseEvent::eSynthesized);
   1: 
   1:       nsEventStatus eventStatus = nsEventStatus_eIgnore;
   1:       content->DispatchDOMEvent(&downEvent, nsnull,
   1:                                  presShell->GetPresContext(), &eventStatus);
   1:       content->DispatchDOMEvent(&upEvent, nsnull,
   1:                                  presShell->GetPresContext(), &eventStatus);
   1:       content->DispatchDOMEvent(&clickEvent, nsnull,
   1:                                  presShell->GetPresContext(), &eventStatus);
   1:     }
   1:   }
   1: }
   1: 
   1: /*
   1:  * Use Timer to execute "Click" command of XUL/HTML element (e.g. menuitem, button...).
   1:  *
   1:  * When "Click" is to open a "modal" dialog/window, it won't return untill the
   1:  * dialog/window is closed. If executing "Click" command directly in
   1:  * nsXXXAccessible::DoAction, it will block AT-Tools(e.g. GOK) that invoke
   1:  * "action" of mozilla accessibles direclty.
   1:  */
   1: nsresult nsAccessible::DoCommand(nsIContent *aContent)
   1: {
   1:   nsCOMPtr<nsIContent> content = aContent;
   1:   if (!content) {
   1:     content = do_QueryInterface(mDOMNode);
   1:   }
   1:   if (gDoCommandTimer) {
   1:     // Already have timer going for another command
   1:     NS_WARNING("Doubling up on do command timers doesn't work. This wasn't expected.");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
   1:   if (!timer) {
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   } 
   1: 
   1:   NS_ADDREF(gDoCommandTimer = timer);
   1:   return gDoCommandTimer->InitWithFuncCallback(DoCommandCallback,
   1:                                                (void*)content, 0,
   1:                                                nsITimer::TYPE_ONE_SHOT);
   1: }
   1: 
   1: already_AddRefed<nsIAccessible>
   1: nsAccessible::GetNextWithState(nsIAccessible *aStart, PRUint32 matchState)
   1: {
   1:   // Return the next descendant that matches one of the states in matchState
   1:   // Uses depth first search
   1:   NS_ASSERTION(matchState, "GetNextWithState() not called with a state to match");
   1:   NS_ASSERTION(aStart, "GetNextWithState() not called with an accessible to start with");
   1:   nsCOMPtr<nsIAccessible> look, current = aStart;
   1:   PRUint32 state = 0;
   1:   while (0 == (state & matchState)) {
   1:     current->GetFirstChild(getter_AddRefs(look));
   1:     while (!look) {
   1:       if (current == this) {
   1:         return nsnull; // At top of subtree
   1:       }
   1:       current->GetNextSibling(getter_AddRefs(look));
   1:       if (!look) {
   1:         current->GetParent(getter_AddRefs(look));
   1:         current.swap(look);
   1:         continue;
   1:       }
   1:     }
   1:     current.swap(look);
 262:     state = State(current);
   1:   }
   1: 
   1:   nsIAccessible *returnAccessible = nsnull;
   1:   current.swap(returnAccessible);
   1: 
   1:   return returnAccessible;
   1: }
   1: 
   1: // nsIAccessibleSelectable
   1: NS_IMETHODIMP nsAccessible::GetSelectedChildren(nsIArray **aSelectedAccessibles)
   1: {
   1:   *aSelectedAccessibles = nsnull;
   1: 
   1:   nsCOMPtr<nsIMutableArray> selectedAccessibles =
   1:     do_CreateInstance(NS_ARRAY_CONTRACTID);
   1:   NS_ENSURE_STATE(selectedAccessibles);
   1: 
   1:   nsCOMPtr<nsIAccessible> selected = this;
   1:   while ((selected = GetNextWithState(selected, nsIAccessibleStates::STATE_SELECTED)) != nsnull) {
   1:     selectedAccessibles->AppendElement(selected, PR_FALSE);
   1:   }
   1: 
   1:   PRUint32 length = 0;
   1:   selectedAccessibles->GetLength(&length); 
   1:   if (length) { // length of nsIArray containing selected options
   1:     *aSelectedAccessibles = selectedAccessibles;
   1:     NS_ADDREF(*aSelectedAccessibles);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // return the nth selected descendant nsIAccessible object
   1: NS_IMETHODIMP nsAccessible::RefSelection(PRInt32 aIndex, nsIAccessible **aSelected)
   1: {
   1:   *aSelected = nsnull;
   1:   if (aIndex < 0) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   nsCOMPtr<nsIAccessible> selected = this;
   1:   PRInt32 count = 0;
   1:   while (count ++ <= aIndex) {
   1:     selected = GetNextWithState(selected, nsIAccessibleStates::STATE_SELECTED);
   1:     if (!selected) {
   1:       return NS_ERROR_FAILURE; // aIndex out of range
   1:     }
   1:   }
   1:   NS_IF_ADDREF(*aSelected = selected);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
   1: {
   1:   *aSelectionCount = 0;
   1:   nsCOMPtr<nsIAccessible> selected = this;
   1:   while ((selected = GetNextWithState(selected, nsIAccessibleStates::STATE_SELECTED)) != nsnull) {
   1:     ++ *aSelectionCount;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::AddChildToSelection(PRInt32 aIndex)
   1: {
   1:   // Tree views and other container widgets which may have grandchildren should
   1:   // implement a selection methods for their specific interfaces, because being
   1:   // able to deal with selection on a per-child basis would not be enough.
   1: 
   1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
   1: 
   1:   nsCOMPtr<nsIAccessible> child;
   1:   GetChildAt(aIndex, getter_AddRefs(child));
   1: 
 262:   PRUint32 state = State(child);
   1:   if (!(state & nsIAccessibleStates::STATE_SELECTABLE)) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   return child->SetSelected(PR_TRUE);
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::RemoveChildFromSelection(PRInt32 aIndex)
   1: {
   1:   // Tree views and other container widgets which may have grandchildren should
   1:   // implement a selection methods for their specific interfaces, because being
   1:   // able to deal with selection on a per-child basis would not be enough.
   1: 
   1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
   1: 
   1:   nsCOMPtr<nsIAccessible> child;
   1:   GetChildAt(aIndex, getter_AddRefs(child));
   1: 
 262:   PRUint32 state = State(child);
   1:   if (!(state & nsIAccessibleStates::STATE_SELECTED)) {
   1:     return NS_OK;
   1:   }
   1: 
   1:   return child->SetSelected(PR_FALSE);
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::IsChildSelected(PRInt32 aIndex, PRBool *aIsSelected)
   1: {
   1:   // Tree views and other container widgets which may have grandchildren should
   1:   // implement a selection methods for their specific interfaces, because being
   1:   // able to deal with selection on a per-child basis would not be enough.
   1: 
   1:   *aIsSelected = PR_FALSE;
   1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
   1: 
   1:   nsCOMPtr<nsIAccessible> child;
   1:   GetChildAt(aIndex, getter_AddRefs(child));
   1: 
 262:   PRUint32 state = State(child);
   1:   if (state & nsIAccessibleStates::STATE_SELECTED) {
   1:     *aIsSelected = PR_TRUE;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::ClearSelection()
   1: {
   1:   nsCOMPtr<nsIAccessible> selected = this;
   1:   while ((selected = GetNextWithState(selected, nsIAccessibleStates::STATE_SELECTED)) != nsnull) {
   1:     selected->SetSelected(PR_FALSE);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::SelectAllSelection(PRBool *_retval)
   1: {
   1:   nsCOMPtr<nsIAccessible> selectable = this;
   1:   while ((selectable = GetNextWithState(selectable, nsIAccessibleStates::STATE_SELECTED)) != nsnull) {
   1:     selectable->SetSelected(PR_TRUE);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: // nsIAccessibleHyperLink
   1: // Because of new-atk design, any embedded object in text can implement
   1: // nsIAccessibleHyperLink, which helps determine where it is located
   1: // within containing text
   1: 
   1: NS_IMETHODIMP nsAccessible::GetAnchors(PRInt32 *aAnchors)
   1: {
   1:   *aAnchors = 1;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetStartIndex(PRInt32 *aStartIndex)
   1: {
   1:   *aStartIndex = 0;
   1:   PRInt32 endIndex;
   1:   return GetLinkOffset(aStartIndex, &endIndex);
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetEndIndex(PRInt32 *aEndIndex)
   1: {
   1:   *aEndIndex = 0;
   1:   PRInt32 startIndex;
   1:   return GetLinkOffset(&startIndex, aEndIndex);
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetURI(PRInt32 i, nsIURI **aURI)
   1: {
   1:   *aURI = nsnull;
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::GetObject(PRInt32 aIndex,
   1:                                       nsIAccessible **aAccessible)
   1: {
   1:   if (aIndex != 0) {
   1:     *aAccessible = nsnull;
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   *aAccessible = this;
   1:   NS_ADDREF_THIS();
   1:   return NS_OK;
   1: }
   1: 
   1: // nsIAccessibleHyperLink::IsValid()
   1: NS_IMETHODIMP nsAccessible::IsValid(PRBool *aIsValid)
   1: {
 262:   PRUint32 state = State(this);
6433:   *aIsValid = (0 == (state & nsIAccessibleStates::STATE_INVALID));
   1:   // XXX In order to implement this we would need to follow every link
   1:   // Perhaps we can get information about invalid links from the cache
   1:   // In the mean time authors can use role="wairole:link" aaa:invalid="true"
   1:   // to force it for links they internally know to be invalid
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsAccessible::IsSelected(PRBool *aIsSelected)
   1: {
   1:   *aIsSelected = (gLastFocusedNode == mDOMNode);
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult nsAccessible::GetLinkOffset(PRInt32* aStartOffset, PRInt32* aEndOffset)
   1: {
   1:   *aStartOffset = *aEndOffset = 0;
   1:   nsCOMPtr<nsIAccessible> parent(GetParent());
   1:   if (!parent) {
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCOMPtr<nsIAccessible> accessible, nextSibling;
   1:   PRInt32 characterCount = 0;
   1:   parent->GetFirstChild(getter_AddRefs(accessible));
   1: 
   1:   while (accessible) {
   1:     if (IsText(accessible)) {
   1:       characterCount += TextLength(accessible);
   1:     }
   1:     else if (accessible == this) {
   1:       *aStartOffset = characterCount;
   1:       *aEndOffset = characterCount + 1;
   1:       return NS_OK;
   1:     }
   1:     else {
   1:       ++ characterCount;
   1:     }
   1:     accessible->GetNextSibling(getter_AddRefs(nextSibling));
   1:     accessible.swap(nextSibling);
   1:   }
   1: 
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: PRInt32 nsAccessible::TextLength(nsIAccessible *aAccessible)
   1: {
 460:   if (!IsText(aAccessible))
   1:     return 1;
 460: 
4261:   nsCOMPtr<nsPIAccessNode> pAccNode(do_QueryInterface(aAccessible));
4261:   NS_ASSERTION(pAccNode, "QI to nsPIAccessNode failed");
4261: 
4261:   nsIFrame *frame = pAccNode->GetFrame();
5693:   if (frame && frame->GetType() == nsAccessibilityAtoms::textFrame) {
5693:     // Ensure that correct text length is calculated (with non-rendered whitespace chars not counted)
4261:     nsIContent *content = frame->GetContent();
4261:     if (content) {
4261:       PRUint32 length;
4261:       nsresult rv = nsHyperTextAccessible::ContentToRenderedOffset(frame, content->TextLength(), &length);
5693:       return NS_SUCCEEDED(rv) ? static_cast<PRInt32>(length) : -1;
4261:     }
4261:   }
4261: 
4261:   // For list bullets (or anything other accessible which would compute its own text
4261:   // They don't have their own frame.
4261:   // XXX In the future, list bullets may have frame and anon content, so 
4261:   // we should be able to remove this at that point
 460:   nsCOMPtr<nsPIAccessible> pAcc(do_QueryInterface(aAccessible));
4261:   NS_ASSERTION(pAcc, "QI to nsPIAccessible failed");
 460: 
 460:   nsAutoString text;
4261:   pAcc->AppendTextTo(text, 0, PR_UINT32_MAX); // Get all the text
 460:   return text.Length();
 460: }
 460: 
 460: NS_IMETHODIMP
4261: nsAccessible::AppendTextTo(nsAString& aText, PRUint32 aStartOffset, PRUint32 aLength)
 460: {
 460:   return NS_OK;
   1: }
   1: 
   1: already_AddRefed<nsIAccessible>
   1: nsAccessible::GetFirstAvailableAccessible(nsIDOMNode *aStartNode, PRBool aRequireLeaf)
   1: {
   1:   nsIAccessibilityService *accService = GetAccService();
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   nsCOMPtr<nsIDOMTreeWalker> walker; 
   1:   nsCOMPtr<nsIDOMNode> currentNode(aStartNode);
   1: 
   1:   while (currentNode) {
   1:     accService->GetAccessibleInWeakShell(currentNode, mWeakShell, getter_AddRefs(accessible)); // AddRef'd
   1:     if (accessible && (!aRequireLeaf || IsLeaf(accessible))) {
   1:       nsIAccessible *retAccessible = accessible;
   1:       NS_ADDREF(retAccessible);
   1:       return retAccessible;
   1:     }
   1:     if (!walker) {
   1:       // Instantiate walker lazily since we won't need it in 90% of the cases
   1:       // where the first DOM node we're given provides an accessible
   1:       nsCOMPtr<nsIDOMDocument> document;
   1:       currentNode->GetOwnerDocument(getter_AddRefs(document));
   1:       nsCOMPtr<nsIDOMDocumentTraversal> trav = do_QueryInterface(document);
   1:       NS_ASSERTION(trav, "No DOM document traversal for document");
   1:       NS_ENSURE_TRUE(trav, nsnull);
   1:       trav->CreateTreeWalker(mDOMNode, nsIDOMNodeFilter::SHOW_ELEMENT | nsIDOMNodeFilter::SHOW_TEXT,
   1:                             nsnull, PR_FALSE, getter_AddRefs(walker));
   1:       NS_ENSURE_TRUE(walker, nsnull);
   1:       walker->SetCurrentNode(currentNode);
   1:     }
   1: 
   1:     walker->NextNode(getter_AddRefs(currentNode));
   1:   }
   1: 
   1:   return nsnull;
   1: }
   1: 
   1: PRBool nsAccessible::CheckVisibilityInParentChain(nsIDocument* aDocument, nsIView* aView)
   1: {
   1:   nsIDocument* document = aDocument;
   1:   nsIView* view = aView;
   1:   // both view chain and widget chain are broken between chrome and content
   1:   while (document != nsnull) {
   1:     while (view != nsnull) {
   1:       if (view->GetVisibility() == nsViewVisibility_kHide) {
   1:         return PR_FALSE;
   1:       }
   1:       view = view->GetParent();
   1:     }
   1: 
   1:     nsIDocument* parentDoc = document->GetParentDocument();
   1:     if (parentDoc != nsnull) {
   1:       nsIContent* content = parentDoc->FindContentForSubDocument(document);
   1:       if (content != nsnull) {
 981:         nsIPresShell* shell = parentDoc->GetPrimaryShell();
   1:         nsIFrame* frame = shell->GetPrimaryFrameFor(content);
   1:         while (frame != nsnull && !frame->HasView()) {
   1:           frame = frame->GetParent();
   1:         }
   1: 
   1:         if (frame != nsnull) {
   1:           view = frame->GetViewExternal();
   1:         }
   1:       }
   1:     }
   1: 
   1:     document = parentDoc;
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
4274: 
4274: nsresult
6279: nsAccessible::GetAttrValue(EAriaProperty aProperty, double *aValue)
4274: {
4274:   NS_ENSURE_ARG_POINTER(aValue);
4274:   *aValue = 0;
4274: 
4274:   if (!mDOMNode)
4274:     return NS_ERROR_FAILURE;  // Node already shut down
4274: 
4274:  if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
4274:     return NS_OK_NO_ARIA_VALUE;
4274: 
4274:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
4274:   NS_ENSURE_STATE(content);
4274: 
4274:   PRInt32 result = NS_OK;
4274:   nsAutoString value;
6279:   if (nsAccUtils::GetAriaProperty(content, mWeakShell, aProperty, value))
4274:     *aValue = value.ToFloat(&result);
4274: 
4274:   return result;
4274: }
4274: 
4685: PRBool nsAccessible::MustPrune(nsIAccessible *aAccessible)
4685: { 
4685:   PRUint32 role = Role(aAccessible);
4685:   return role == nsIAccessibleRole::ROLE_MENUITEM || 
4685:          role == nsIAccessibleRole::ROLE_ENTRY ||
4685:          role == nsIAccessibleRole::ROLE_PASSWORD_TEXT ||
4685:          role == nsIAccessibleRole::ROLE_PUSHBUTTON ||
4685:          role == nsIAccessibleRole::ROLE_TOGGLE_BUTTON ||
4685:          role == nsIAccessibleRole::ROLE_GRAPHIC ||
4685:          role == nsIAccessibleRole::ROLE_SLIDER ||
4685:          role == nsIAccessibleRole::ROLE_PROGRESSBAR ||
4685:          role == nsIAccessibleRole::ROLE_SEPARATOR;
4685: }
