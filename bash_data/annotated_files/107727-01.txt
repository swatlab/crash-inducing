 16300: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 16300: /* vim:set ts=2 sw=2 sts=2 et cindent: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 33372: 
 21542: #include <limits>
 16300: #include "nsNetUtil.h"
 16300: #include "nsAudioStream.h"
 16300: #include "nsHTMLVideoElement.h"
 16300: #include "nsIObserver.h"
 16300: #include "nsIObserverService.h"
 20627: #include "nsTArray.h"
 41387: #include "VideoUtils.h"
 41387: #include "nsBuiltinDecoder.h"
 73701: #include "nsBuiltinDecoderStateMachine.h"
 75108: #include "nsTimeRanges.h"
 75263: #include "nsContentUtils.h"
 41387: 
 41954: using namespace mozilla;
 27222: 
 33372: #ifdef PR_LOGGING
 41387: PRLogModuleInfo* gBuiltinDecoderLog;
 41387: #define LOG(type, msg) PR_LOG(gBuiltinDecoderLog, type, msg)
 33372: #else
 33372: #define LOG(type, msg)
 33372: #endif
 33372: 
 41387: NS_IMPL_THREADSAFE_ISUPPORTS1(nsBuiltinDecoder, nsIObserver)
 19675: 
 41387: void nsBuiltinDecoder::Pause() 
 19690: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 28798:   if (mPlayState == PLAY_STATE_SEEKING || mPlayState == PLAY_STATE_ENDED) {
 20627:     mNextState = PLAY_STATE_PAUSED;
 19690:     return;
 19675:   }
 19675: 
 20627:   ChangeState(PLAY_STATE_PAUSED);
 19690: }
 19690: 
 60727: void nsBuiltinDecoder::SetVolume(double aVolume)
 19690: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 60727:   mInitialVolume = aVolume;
 41387:   if (mDecoderStateMachine) {
 60727:     mDecoderStateMachine->SetVolume(aVolume);
 19690:   }
 19690: }
 19690: 
 97204: void nsBuiltinDecoder::SetAudioCaptured(bool aCaptured)
 97204: {
 97204:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 97204:   mInitialAudioCaptured = aCaptured;
 97204:   if (mDecoderStateMachine) {
 97204:     mDecoderStateMachine->SetAudioCaptured(aCaptured);
 97204:   }
 97204: }
 97204: 
 97204: void nsBuiltinDecoder::AddOutputStream(SourceMediaStream* aStream, bool aFinishWhenEnded)
 97204: {
 97204:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 97204: 
 97204:   {
 97204:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 97204:     OutputMediaStream* ms = mOutputStreams.AppendElement();
 97204:     ms->Init(PRInt64(mCurrentTime*USECS_PER_S), aStream, aFinishWhenEnded);
 97204:   }
 97204: 
 97207:   // This can be called before Load(), in which case our mDecoderStateMachine
 97207:   // won't have been created yet and we can rely on Load() to schedule it
 97207:   // once it is created.
 97207:   if (mDecoderStateMachine) {
 97204:     // Make sure the state machine thread runs so that any buffered data
 97207:     // is fed into our stream.
 97204:     ScheduleStateMachineThread();
 97204:   }
 97207: }
 97204: 
 60727: double nsBuiltinDecoder::GetDuration()
 19690: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 74647:   if (mInfiniteStream) {
 74647:     return std::numeric_limits<double>::infinity();
 74647:   }
 21542:   if (mDuration >= 0) {
 68450:      return static_cast<double>(mDuration) / static_cast<double>(USECS_PER_S);
 21542:   }
 60727:   return std::numeric_limits<double>::quiet_NaN();
 19690: }
 19690: 
 79445: void nsBuiltinDecoder::SetInfinite(bool aInfinite)
 74647: {
 74647:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 74647:   mInfiniteStream = aInfinite;
 74647: }
 74647: 
 79445: bool nsBuiltinDecoder::IsInfinite()
 74647: {
 74647:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 74647:   return mInfiniteStream;
 74647: }
 74647: 
 41387: nsBuiltinDecoder::nsBuiltinDecoder() :
 24721:   mDecoderPosition(0),
 24721:   mPlaybackPosition(0),
 20776:   mCurrentTime(0.0),
 20627:   mInitialVolume(0.0),
 20627:   mRequestedSeekTime(-1.0),
 25380:   mDuration(-1),
 79547:   mSeekable(true),
 69142:   mReentrantMonitor("media.decoder"),
 20627:   mPlayState(PLAY_STATE_PAUSED),
 23763:   mNextState(PLAY_STATE_PAUSED),
 79547:   mResourceLoaded(false),
 79547:   mIgnoreProgressData(false),
 79547:   mInfiniteStream(false)
 19690: {
 41387:   MOZ_COUNT_CTOR(nsBuiltinDecoder);
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 33372: #ifdef PR_LOGGING
 41387:   if (!gBuiltinDecoderLog) {
 41387:     gBuiltinDecoderLog = PR_NewLogModule("nsBuiltinDecoder");
 33372:   }
 33372: #endif
 19690: }
 19690: 
 79445: bool nsBuiltinDecoder::Init(nsHTMLMediaElement* aElement)
 19690: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 32897:   if (!nsMediaDecoder::Init(aElement))
 79547:     return false;
 32897: 
 38651:   nsContentUtils::RegisterShutdownObserver(this);
 79547:   return true;
 20627: }
 19690: 
 41387: void nsBuiltinDecoder::Shutdown()
 19690: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 28622:   
 28622:   if (mShuttingDown)
 28622:     return;
 28622: 
 79547:   mShuttingDown = true;
 22529: 
 28622:   // This changes the decoder state to SHUTDOWN and does other things
 28622:   // necessary to unblock the state machine thread if it's blocked, so
 28622:   // the asynchronous shutdown in nsDestroyStateMachine won't deadlock.
 41387:   if (mDecoderStateMachine) {
 41387:     mDecoderStateMachine->Shutdown();
 28622:   }
 28622: 
 28622:   // Force any outstanding seek and byterange requests to complete
 28622:   // to prevent shutdown from deadlocking.
 90148:   if (mResource) {
 90148:     mResource->Close();
 32933:   }
 28622: 
 20627:   ChangeState(PLAY_STATE_SHUTDOWN);
 20627:   nsMediaDecoder::Shutdown();
 19690: 
 38651:   nsContentUtils::UnregisterShutdownObserver(this);
 19690: }
 19690: 
 41387: nsBuiltinDecoder::~nsBuiltinDecoder()
 19690: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 48905:   UnpinForSeek();
 41387:   MOZ_COUNT_DTOR(nsBuiltinDecoder);
 19675: }
 19675: 
 90148: nsresult nsBuiltinDecoder::Load(MediaResource* aResource,
 54993:                                 nsIStreamListener** aStreamListener,
 54993:                                 nsMediaDecoder* aCloneDonor)
 19675: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 32901:   if (aStreamListener) {
106838:     *aStreamListener = nullptr;
 32901:   }
 21079: 
 26836:   {
 26836:     // Hold the lock while we do this to set proper lock ordering
 26836:     // expectations for dynamic deadlock detectors: decoder lock(s)
 26836:     // should be grabbed before the cache lock
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 32897: 
 90148:     nsresult rv = aResource->Open(aStreamListener);
 32900:     if (NS_FAILED(rv)) {
 87741:       LOG(PR_LOG_DEBUG, ("%p Failed to open stream!", this));
 90148:       delete aResource;
 26836:       return rv;
 32900:     }
 32899: 
 90148:     mResource = aResource;
 26836:   }
 19690: 
 41387:   mDecoderStateMachine = CreateStateMachine();
 41387:   if (!mDecoderStateMachine) {
 87009:     LOG(PR_LOG_DEBUG, ("%p Failed to create state machine!", this));
 41387:     return NS_ERROR_FAILURE;
 41387:   }
 41387: 
 54993:   nsBuiltinDecoder* cloneDonor = static_cast<nsBuiltinDecoder*>(aCloneDonor);
 54993:   if (NS_FAILED(mDecoderStateMachine->Init(cloneDonor ?
106838:                                            cloneDonor->mDecoderStateMachine : nullptr))) {
 87009:     LOG(PR_LOG_DEBUG, ("%p Failed to init state machine!", this));
 40132:     return NS_ERROR_FAILURE;
 40132:   }
 21542:   {
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 41387:     mDecoderStateMachine->SetSeekable(mSeekable);
 41387:     mDecoderStateMachine->SetDuration(mDuration);
 90238:     mDecoderStateMachine->SetVolume(mInitialVolume);
 97844:     mDecoderStateMachine->SetAudioCaptured(mInitialAudioCaptured);
 67873:     
 67873:     if (mFrameBufferLength > 0) {
 67873:       // The valid mFrameBufferLength value was specified earlier
 67873:       mDecoderStateMachine->SetFrameBufferLength(mFrameBufferLength);
 67873:     }
 21542:   }
 19690: 
 20627:   ChangeState(PLAY_STATE_LOADING);
 19690: 
 73701:   return ScheduleStateMachineThread();
 51397: }
 51397: 
 67873: nsresult nsBuiltinDecoder::RequestFrameBufferLength(PRUint32 aLength)
 67873: {
 67873:   nsresult res = nsMediaDecoder::RequestFrameBufferLength(aLength);
 67873:   NS_ENSURE_SUCCESS(res,res);
 67873: 
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 67873:   if (mDecoderStateMachine) {
 67873:       mDecoderStateMachine->SetFrameBufferLength(aLength);
 67873:   }
 67873:   return res;
 67873: }
 67873: 
 73701: nsresult nsBuiltinDecoder::ScheduleStateMachineThread()
 51397: {
 73701:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 73701:   NS_ASSERTION(mDecoderStateMachine,
 73701:                "Must have state machine to start state machine thread");
 87739:   NS_ENSURE_STATE(mDecoderStateMachine);
 73701: 
 73700:   if (mShuttingDown)
 73700:     return NS_OK;
 73701:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 73701:   nsBuiltinDecoderStateMachine* m =
 73701:     static_cast<nsBuiltinDecoderStateMachine*>(mDecoderStateMachine.get());
 73701:   return m->ScheduleStateMachine();
 20627: }
 20627: 
 41387: nsresult nsBuiltinDecoder::Play()
 20627: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
106838:   NS_ASSERTION(mDecoderStateMachine != nullptr, "Should have state machine.");
 73701:   nsresult res = ScheduleStateMachineThread();
 51397:   NS_ENSURE_SUCCESS(res,res);
 20627:   if (mPlayState == PLAY_STATE_SEEKING) {
 20627:     mNextState = PLAY_STATE_PLAYING;
 20627:     return NS_OK;
 20627:   }
 26838:   if (mPlayState == PLAY_STATE_ENDED)
 26838:     return Seek(0);
 20627: 
 20627:   ChangeState(PLAY_STATE_PLAYING);
 19690:   return NS_OK;
 19675: }
 19675: 
 75108: /**
 79547:  * Returns true if aValue is inside a range of aRanges, and put the range
 75108:  * index in aIntervalIndex if it is not null.
 79547:  * If aValue is not inside a range, false is returned, and aIntervalIndex, if
 86739:  * not null, is set to the index of the range which ends immediately before aValue
 75108:  * (and can be -1 if aValue is before aRanges.Start(0)).
 75108:  */
 79445: static bool IsInRanges(nsTimeRanges& aRanges, double aValue, PRInt32& aIntervalIndex) {
 75108:   PRUint32 length;
 75108:   aRanges.GetLength(&length);
 75108:   for (PRUint32 i = 0; i < length; i++) {
 75108:     double start, end;
 75108:     aRanges.Start(i, &start);
 75108:     if (start > aValue) {
 75108:       aIntervalIndex = i - 1;
 79547:       return false;
 75108:     }
 75108:     aRanges.End(i, &end);
 75108:     if (aValue <= end) {
 75108:       aIntervalIndex = i;
 79547:       return true;
 75108:     }
 75108:   }
 75108:   aIntervalIndex = length - 1;
 79547:   return false;
 75108: }
 75108: 
 60727: nsresult nsBuiltinDecoder::Seek(double aTime)
 19690: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 20627: 
 75108:   NS_ABORT_IF_FALSE(aTime >= 0.0, "Cannot seek to a negative value.");
 75108: 
 75108:   nsTimeRanges seekable;
 75108:   nsresult res;
 75108:   PRUint32 length = 0;
 75108:   res = GetSeekable(&seekable);
 75108:   NS_ENSURE_SUCCESS(res, NS_OK);
 75108: 
 75108:   seekable.GetLength(&length);
 75108:   if (!length) {
 75108:     return NS_OK;
 75108:   }
 75108: 
 75108:   // If the position we want to seek to is not in a seekable range, we seek
 75108:   // to the closest position in the seekable ranges instead. If two positions
 86739:   // are equally close, we seek to the closest position from the currentTime.
 75108:   // See seeking spec, point 7 :
 86739:   // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#seeking
 75108:   PRInt32 range = 0;
 75108:   if (!IsInRanges(seekable, aTime, range)) {
 75108:     if (range != -1) {
 90479:       // |range + 1| can't be negative, because the only possible negative value
 90479:       // for |range| is -1.
 90479:       if (PRUint32(range + 1) < length) {
 75108:         double leftBound, rightBound;
 75108:         res = seekable.End(range, &leftBound);
 75108:         NS_ENSURE_SUCCESS(res, NS_OK);
 75108:         res = seekable.Start(range + 1, &rightBound);
 75108:         NS_ENSURE_SUCCESS(res, NS_OK);
 86739:         double distanceLeft = NS_ABS(leftBound - aTime);
 86739:         double distanceRight = NS_ABS(rightBound - aTime);
 75108:         if (distanceLeft == distanceRight) {
 75108:           distanceLeft = NS_ABS(leftBound - mCurrentTime);
 75108:           distanceRight = NS_ABS(rightBound - mCurrentTime);
 75108:         } 
 75108:         aTime = (distanceLeft < distanceRight) ? leftBound : rightBound;
 75108:       } else {
 86739:         // Seek target is after the end last range in seekable data.
 86739:         // Clamp the seek target to the end of the last seekable range.
 86739:         res = seekable.End(length - 1, &aTime);
 86739:         NS_ENSURE_SUCCESS(res, NS_OK);
 86739:       }
 86739:     } else {
 75108:       // aTime is before the first range in |seekable|, the closest point we can
 75108:       // seek to is the start of the first range.
 75108:       seekable.Start(0, &aTime);
 75108:     }
 75108:   }
 20627: 
 20627:   mRequestedSeekTime = aTime;
 61823:   mCurrentTime = aTime;
 20627: 
 20627:   // If we are already in the seeking state, then setting mRequestedSeekTime
 20627:   // above will result in the new seek occurring when the current seek
 20627:   // completes.
 20627:   if (mPlayState != PLAY_STATE_SEEKING) {
 79445:     bool paused = false;
 78968:     if (mElement) {
 78968:       mElement->GetPaused(&paused);
 41387:     }
 78968:     mNextState = paused ? PLAY_STATE_PAUSED : PLAY_STATE_PLAYING;
 48905:     PinForSeek();
 20627:     ChangeState(PLAY_STATE_SEEKING);
 19675:   }
 19675: 
 73701:   return ScheduleStateMachineThread();
 19690: }
 19690: 
 41387: nsresult nsBuiltinDecoder::PlaybackRateChanged()
 19690: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 19690:   return NS_ERROR_NOT_IMPLEMENTED;
 19690: }
 19690: 
 60727: double nsBuiltinDecoder::GetCurrentTime()
 16300: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 20776:   return mCurrentTime;
 16300: }
 16300: 
 41387: already_AddRefed<nsIPrincipal> nsBuiltinDecoder::GetCurrentPrincipal()
 18910: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
106838:   return mResource ? mResource->GetCurrentPrincipal() : nullptr;
 18910: }
 16300: 
 51477: void nsBuiltinDecoder::AudioAvailable(float* aFrameBuffer,
 51477:                                       PRUint32 aFrameBufferLength,
 54997:                                       float aTime)
 16300: {
 52051:   // Auto manage the frame buffer's memory. If we return due to an error
 52051:   // here, this ensures we free the memory. Otherwise, we pass off ownership
 52051:   // to HTMLMediaElement::NotifyAudioAvailable().
 52051:   nsAutoArrayPtr<float> frameBuffer(aFrameBuffer);
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 82604:   if (mShuttingDown || !mElement) {
 22529:     return;
 51477:   }
 52051:   mElement->NotifyAudioAvailable(frameBuffer.forget(), aFrameBufferLength, aTime);
 51477: }
 51477: 
 51477: void nsBuiltinDecoder::MetadataLoaded(PRUint32 aChannels,
 97172:                                       PRUint32 aRate,
106910:                                       bool aHasAudio,
106910:                                       const nsHTMLMediaElement::MetadataTags* aTags)
 51477: {
 51477:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 51477:   if (mShuttingDown) {
 51477:     return;
 51477:   }
 51477: 
 21542:   {
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 41387:     mDuration = mDecoderStateMachine ? mDecoderStateMachine->GetDuration() : -1;
 47958:     // Duration has changed so we should recompute playback rate
 47958:     UpdatePlaybackRate();
 21542:   }
 21542: 
 74647:   if (mDuration == -1) {
 79547:     SetInfinite(true);
 74647:   }
 74647: 
 98473:   if (mElement) {
 24331:     // Make sure the element and the frame (if any) are told about
 24331:     // our new size.
 24331:     Invalidate();
106910:     mElement->MetadataLoaded(aChannels, aRate, aHasAudio, aTags);
 16300:   }
 23763: 
 23763:   if (!mResourceLoaded) {
 23763:     StartProgress();
 78689:   } else if (mElement) {
 23763:     // Resource was loaded during metadata loading, when progress
 23763:     // events are being ignored. Fire the final progress event.
 53767:     mElement->DispatchAsyncEvent(NS_LITERAL_STRING("progress"));
 23763:   }
 22529: 
 22567:   // Only inform the element of FirstFrameLoaded if not doing a load() in order
 22567:   // to fulfill a seek, otherwise we'll get multiple loadedfirstframe events.
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 90148:   bool resourceIsLoaded = !mResourceLoaded && mResource &&
 90148:     mResource->IsDataCachedToEndOfResource(mDecoderPosition);
 98473:   if (mElement) {
 28528:     mElement->FirstFrameLoaded(resourceIsLoaded);
 16300:   }
 20627: 
 82990:   // This can run cache callbacks.
 90148:   mResource->EnsureCacheUpToDate();
 82990: 
 20627:   // The element can run javascript via events
 20627:   // before reaching here, so only change the
 20627:   // state if we're still set to the original
 20627:   // loading state.
 20627:   if (mPlayState == PLAY_STATE_LOADING) {
 20627:     if (mRequestedSeekTime >= 0.0) {
 20627:       ChangeState(PLAY_STATE_SEEKING);
 41387:     }
 41387:     else {
 20627:       ChangeState(mNextState);
 20627:     }
 20627:   }
 23763: 
 28528:   if (resourceIsLoaded) {
 23763:     ResourceLoaded();
 23763:   }
 82990: 
 82990:   // Run NotifySuspendedStatusChanged now to give us a chance to notice
 82990:   // that autoplay should run.
 82990:   NotifySuspendedStatusChanged();
 16300: }
 16300: 
 41387: void nsBuiltinDecoder::ResourceLoaded()
 16300: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 40132: 
 23763:   // Don't handle ResourceLoaded if we are shutting down, or if
 23763:   // we need to ignore progress data due to seeking (in the case
 23763:   // that the seek results in reaching end of file, we get a bogus call
 23763:   // to ResourceLoaded).
 23400:   if (mShuttingDown)
 22529:     return;
 22529: 
 23763:   {
 23763:     // If we are seeking or loading then the resource loaded notification we get
 23763:     // should be ignored, since it represents the end of the seek request.
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 24721:     if (mIgnoreProgressData || mResourceLoaded || mPlayState == PLAY_STATE_LOADING)
 23763:       return;
 23763: 
 79547:     Progress(false);
 23763: 
 79547:     mResourceLoaded = true;
 23763:     StopProgress();
 24721:   }
 23763: 
 23763:   // Ensure the final progress event gets fired
 16300:   if (mElement) {
 16300:     mElement->ResourceLoaded();
 16300:   }
 16300: }
 16300: 
 41387: void nsBuiltinDecoder::NetworkError()
 21394: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 28622:   if (mShuttingDown)
 22529:     return;
 22529: 
 21394:   if (mElement)
 21394:     mElement->NetworkError();
 28622: 
 28622:   Shutdown();
 21394: }
 21394: 
 41387: void nsBuiltinDecoder::DecodeError()
 32934: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 32934:   if (mShuttingDown)
 32934:     return;
 32934: 
 32934:   if (mElement)
 32934:     mElement->DecodeError();
 32934: 
 32934:   Shutdown();
 32934: }
 32934: 
 79445: bool nsBuiltinDecoder::IsSeeking() const
 16300: {
 98472:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 98473:   return mPlayState == PLAY_STATE_SEEKING;
 22783: }
 22783: 
 79445: bool nsBuiltinDecoder::IsEnded() const
 22783: {
 98472:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 22783:   return mPlayState == PLAY_STATE_ENDED || mPlayState == PLAY_STATE_SHUTDOWN;
 20627: }
 20627: 
 41387: void nsBuiltinDecoder::PlaybackEnded()
 20627: {
 41387:   if (mShuttingDown || mPlayState == nsBuiltinDecoder::PLAY_STATE_SEEKING)
 22529:     return;
 22529: 
 98474:   printf("nsBuiltinDecoder::PlaybackEnded mPlayState=%d\n", mPlayState);
 28871:   PlaybackPositionChanged();
 26838:   ChangeState(PLAY_STATE_ENDED);
 26838: 
 16300:   if (mElement)  {
 28525:     UpdateReadyStateForData();
 20627:     mElement->PlaybackEnded();
 16300:   }
 74647: 
 74647:   // This must be called after |mElement->PlaybackEnded()| call above, in order
 74647:   // to fire the required durationchange.
 74647:   if (IsInfinite()) {
 79547:     SetInfinite(false);
 74647:   }
 16300: }
 16300: 
 41387: NS_IMETHODIMP nsBuiltinDecoder::Observe(nsISupports *aSubjet,
 16300:                                         const char *aTopic,
 16300:                                         const PRUnichar *someData)
 16300: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 16300:   if (strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
 16300:     Shutdown();
 16300:   }
 16300: 
 16300:   return NS_OK;
 16300: }
 16300: 
 24721: nsMediaDecoder::Statistics
 41387: nsBuiltinDecoder::GetStatistics()
 16300: {
 48104:   NS_ASSERTION(NS_IsMainThread() || OnStateMachineThread(),
 48104:                "Should be on main or state machine thread.");
 24721:   Statistics result;
 24721: 
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 90148:   if (mResource) {
 24721:     result.mDownloadRate = 
 90148:       mResource->GetDownloadRate(&result.mDownloadRateReliable);
 26836:     result.mDownloadPosition =
 90148:       mResource->GetCachedDataEnd(mDecoderPosition);
 90148:     result.mTotalBytes = mResource->GetLength();
 26836:     result.mPlaybackRate = ComputePlaybackRate(&result.mPlaybackRateReliable);
 24721:     result.mDecoderPosition = mDecoderPosition;
 24721:     result.mPlaybackPosition = mPlaybackPosition;
 41387:   }
 41387:   else {
 26836:     result.mDownloadRate = 0;
 79547:     result.mDownloadRateReliable = true;
 26836:     result.mPlaybackRate = 0;
 79547:     result.mPlaybackRateReliable = true;
 26836:     result.mDecoderPosition = 0;
 26836:     result.mPlaybackPosition = 0;
 26836:     result.mDownloadPosition = 0;
 26836:     result.mTotalBytes = 0;
 26836:   }
 26836: 
 24721:   return result;
 20627: }
 20627: 
 79445: double nsBuiltinDecoder::ComputePlaybackRate(bool* aReliable)
 20627: {
 69142:   GetReentrantMonitor().AssertCurrentThreadIn();
 73701:   NS_ASSERTION(NS_IsMainThread() || OnStateMachineThread(),
 40132:                "Should be on main or state machine thread.");
 40132: 
 90148:   PRInt64 length = mResource ? mResource->GetLength() : -1;
 26836:   if (mDuration >= 0 && length >= 0) {
 79547:     *aReliable = true;
 68450:     return length * static_cast<double>(USECS_PER_S) / mDuration;
 21542:   }
 26836:   return mPlaybackStatistics.GetRateAtLastStop(aReliable);
 16300: }
 16300: 
 41387: void nsBuiltinDecoder::UpdatePlaybackRate()
 26836: {
 73701:   NS_ASSERTION(NS_IsMainThread() || OnStateMachineThread(),
 40132:                "Should be on main or state machine thread.");
 69142:   GetReentrantMonitor().AssertCurrentThreadIn();
 90148:   if (!mResource)
 26836:     return;
 79445:   bool reliable;
 26836:   PRUint32 rate = PRUint32(ComputePlaybackRate(&reliable));
 28527:   if (reliable) {
 28527:     // Avoid passing a zero rate
 40132:     rate = NS_MAX(rate, 1u);
 41387:   }
 41387:   else {
 26836:     // Set a minimum rate of 10,000 bytes per second ... sometimes we just
 26836:     // don't have good data
 40132:     rate = NS_MAX(rate, 10000u);
 26836:   }
 90148:   mResource->SetPlaybackRate(rate);
 26836: }
 26836: 
 41387: void nsBuiltinDecoder::NotifySuspendedStatusChanged()
 26836: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 90148:   if (!mResource)
 26836:     return;
 90148:   MediaResource* activeStream;
 90148:   bool suspended = mResource->IsSuspendedByCache(&activeStream);
 84350:   
 99596:   if (mElement) {
 99596:     if (suspended) {
 99596:       // If this is an autoplay element, we need to kick off its autoplaying
 99596:       // now so we consume data and hopefully free up cache space.
 26836:       mElement->NotifyAutoplayDataReady();
 26836:     }
 99596:     mElement->NotifySuspendedByCache(suspended);
 99597:     UpdateReadyStateForData();
 99596:   } 
 26836: }
 26836: 
 41387: void nsBuiltinDecoder::NotifyBytesDownloaded()
 24721: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 24721:   UpdateReadyStateForData();
 79547:   Progress(false);
 24721: }
 24721: 
 41387: void nsBuiltinDecoder::NotifyDownloadEnded(nsresult aStatus)
 24721: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 40132: 
 51938:   if (aStatus == NS_BINDING_ABORTED) {
 51938:     // Download has been cancelled by user.
 78689:     if (mElement) {
 51938:       mElement->LoadAborted();
 78689:     }
 24721:     return;
 51938:   }
 24721: 
 24721:   {
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 26836:     UpdatePlaybackRate();
 24721:   }
 24721: 
 24721:   if (NS_SUCCEEDED(aStatus)) {
 24721:     ResourceLoaded();
 41387:   }
 41387:   else if (aStatus != NS_BASE_STREAM_CLOSED) {
 24721:     NetworkError();
 24721:   }
 24721:   UpdateReadyStateForData();
 24721: }
 24721: 
 97204: void nsBuiltinDecoder::NotifyPrincipalChanged()
 97204: {
 97204:   if (mElement) {
 97204:     mElement->NotifyDecoderPrincipalChanged();
 97204:   }
 97204: }
 97204: 
 41387: void nsBuiltinDecoder::NotifyBytesConsumed(PRInt64 aBytes)
 24721: {
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 41387:   NS_ASSERTION(OnStateMachineThread() || mDecoderStateMachine->OnDecodeThread(),
 40132:                "Should be on play state machine or decode thread.");
 24721:   if (!mIgnoreProgressData) {
 24721:     mDecoderPosition += aBytes;
 60723:     mPlaybackStatistics.AddBytes(aBytes);
 24721:   }
 24721: }
 24721: 
 41387: void nsBuiltinDecoder::NextFrameUnavailableBuffering()
 39441: {
 39441:   NS_ASSERTION(NS_IsMainThread(), "Should be called on main thread");
 41387:   if (!mElement || mShuttingDown || !mDecoderStateMachine)
 39441:     return;
 39441: 
 39441:   mElement->UpdateReadyStateForData(nsHTMLMediaElement::NEXT_FRAME_UNAVAILABLE_BUFFERING);
 39441: }
 39441: 
 41387: void nsBuiltinDecoder::NextFrameAvailable()
 39441: {
 39441:   NS_ASSERTION(NS_IsMainThread(), "Should be called on main thread");
 41387:   if (!mElement || mShuttingDown || !mDecoderStateMachine)
 39441:     return;
 39441: 
 39441:   mElement->UpdateReadyStateForData(nsHTMLMediaElement::NEXT_FRAME_AVAILABLE);
 39441: }
 39441: 
 41387: void nsBuiltinDecoder::NextFrameUnavailable()
 39441: {
 39441:   NS_ASSERTION(NS_IsMainThread(), "Should be called on main thread");
 41387:   if (!mElement || mShuttingDown || !mDecoderStateMachine)
 39441:     return;
 39441:   mElement->UpdateReadyStateForData(nsHTMLMediaElement::NEXT_FRAME_UNAVAILABLE);
 39441: }
 39441: 
 41387: void nsBuiltinDecoder::UpdateReadyStateForData()
 24721: {
 39441:   NS_ASSERTION(NS_IsMainThread(), "Should be called on main thread");
 41387:   if (!mElement || mShuttingDown || !mDecoderStateMachine)
 24721:     return;
 39441:   nsHTMLMediaElement::NextFrameStatus frameStatus =
 41387:     mDecoderStateMachine->GetNextFrameStatus();
 24919:   mElement->UpdateReadyStateForData(frameStatus);
 16300: }
 20627: 
 41387: void nsBuiltinDecoder::SeekingStopped()
 20627: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 40132: 
 22529:   if (mShuttingDown)
 22529:     return;
 22529: 
 79445:   bool seekWasAborted = false;
 20627:   {
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 20627: 
 20627:     // An additional seek was requested while the current seek was
 20627:     // in operation.
 48905:     if (mRequestedSeekTime >= 0.0) {
 20627:       ChangeState(PLAY_STATE_SEEKING);
 79547:       seekWasAborted = true;
 48905:     } else {
 48905:       UnpinForSeek();
 98474:       printf("nsBuiltinDecoder::SeekingStopped, next state=%d\n", mNextState);
 20627:       ChangeState(mNextState);
 20627:     }
 48905:   }
 20627: 
 20627:   if (mElement) {
 28525:     UpdateReadyStateForData();
 61823:     if (!seekWasAborted) {
 20627:       mElement->SeekCompleted();
 20627:     }
 20627:   }
 61823: }
 20627: 
 28857: // This is called when seeking stopped *and* we're at the end of the
 28857: // media.
 41387: void nsBuiltinDecoder::SeekingStoppedAtEnd()
 28857: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 40132: 
 28857:   if (mShuttingDown)
 28857:     return;
 28857: 
 79445:   bool fireEnded = false;
 79445:   bool seekWasAborted = false;
 28857:   {
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 28857: 
 28857:     // An additional seek was requested while the current seek was
 28857:     // in operation.
 28857:     if (mRequestedSeekTime >= 0.0) {
 28857:       ChangeState(PLAY_STATE_SEEKING);
 79547:       seekWasAborted = true;
 48905:     } else {
 48905:       UnpinForSeek();
 98474:       printf("nsBuiltinDecoder::SeekingStoppedAtEnd, next state=PLAY_STATE_ENDED\n");
 79547:       fireEnded = true;
 77484:       ChangeState(PLAY_STATE_ENDED);
 28857:     }
 28857:   }
 28857: 
 28857:   if (mElement) {
 28857:     UpdateReadyStateForData();
 61823:     if (!seekWasAborted) {
 28857:       mElement->SeekCompleted();
 28857:       if (fireEnded) {
 28857:         mElement->PlaybackEnded();
 28857:       }
 28857:     }
 28857:   }
 61823: }
 28857: 
 41387: void nsBuiltinDecoder::SeekingStarted()
 20627: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 22529:   if (mShuttingDown)
 20627:     return;
 20627: 
 20627:   if (mElement) {
 28525:     UpdateReadyStateForData();
 20627:     mElement->SeekStarted();
 20627:   }
 20627: }
 20627: 
 41387: void nsBuiltinDecoder::ChangeState(PlayState aState)
 20627: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");   
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 20627: 
 20627:   if (mNextState == aState) {
 20627:     mNextState = PLAY_STATE_PAUSED;
 20627:   }
 20627: 
 20627:   if (mPlayState == PLAY_STATE_SHUTDOWN) {
 69142:     mReentrantMonitor.NotifyAll();
 20627:     return;
 20627:   }
 20627: 
 20627:   mPlayState = aState;
 87739:   if (mDecoderStateMachine) {
 20627:     switch (aState) {
 20627:     case PLAY_STATE_PLAYING:
 63623:       mDecoderStateMachine->Play();
 20627:       break;
 20627:     case PLAY_STATE_SEEKING:
 41387:       mDecoderStateMachine->Seek(mRequestedSeekTime);
 20627:       mRequestedSeekTime = -1.0;
 20627:       break;
 87739:     default:
 20627:       /* No action needed */
 20627:       break;
 87739:     }
 20627:   }
 69142:   mReentrantMonitor.NotifyAll();
 20627: }
 20776: 
 41387: void nsBuiltinDecoder::PlaybackPositionChanged()
 20776: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 22529:   if (mShuttingDown)
 22529:     return;
 22529: 
 60727:   double lastTime = mCurrentTime;
 20776: 
 20776:   // Control the scope of the monitor so it is not
 20776:   // held while the timeupdate and the invalidate is run.
 20776:   {
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 41387:     if (mDecoderStateMachine) {
 91522:       if (!IsSeeking()) {
 91522:         // Only update the current playback position if we're not seeking.
 91522:         // If we are seeking, the update could have been scheduled on the
 91522:         // state machine thread while we were playing but after the seek
 91522:         // algorithm set the current playback position on the main thread,
 91522:         // and we don't want to override the seek algorithm and change the
 91522:         // current time after the seek has started but before it has
 91522:         // completed.
 41387:         mCurrentTime = mDecoderStateMachine->GetCurrentTime();
 98474:       } else {
 98474:         printf("Suppressed timeupdate during seeking: currentTime=%f, new time=%f\n",
 98474:                mCurrentTime, mDecoderStateMachine->GetCurrentTime());
 91522:       }
 41387:       mDecoderStateMachine->ClearPositionChangeFlag();
 20776:     }
 20776:   }
 20776: 
 20776:   // Invalidate the frame so any video data is displayed.
 20776:   // Do this before the timeupdate event so that if that
 20776:   // event runs JavaScript that queries the media size, the
 20776:   // frame has reflowed and the size updated beforehand.
 20776:   Invalidate();
 20776: 
 20776:   if (mElement && lastTime != mCurrentTime) {
 53770:     FireTimeUpdate();
 20776:   }
 20776: }
 21542: 
 41387: void nsBuiltinDecoder::DurationChanged()
 40132: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 40132:   PRInt64 oldDuration = mDuration;
 41387:   mDuration = mDecoderStateMachine ? mDecoderStateMachine->GetDuration() : -1;
 47958:   // Duration has changed so we should recompute playback rate
 47958:   UpdatePlaybackRate();
 47958: 
 74647:   if (mElement && oldDuration != mDuration && !IsInfinite()) {
 68450:     LOG(PR_LOG_DEBUG, ("%p duration changed to %lld", this, mDuration));
 53767:     mElement->DispatchEvent(NS_LITERAL_STRING("durationchange"));
 40132:   }
 40132: }
 40132: 
 68450: void nsBuiltinDecoder::SetDuration(double aDuration)
 24775: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 68450:   mDuration = static_cast<PRInt64>(NS_round(aDuration * static_cast<double>(USECS_PER_S)));
 47958: 
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 41387:   if (mDecoderStateMachine) {
 41387:     mDecoderStateMachine->SetDuration(mDuration);
 47958:   }
 47958: 
 47958:   // Duration has changed so we should recompute playback rate
 26836:   UpdatePlaybackRate();
 24775: }
 24775: 
 79445: void nsBuiltinDecoder::SetSeekable(bool aSeekable)
 21542: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 21542:   mSeekable = aSeekable;
 41387:   if (mDecoderStateMachine) {
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 41387:     mDecoderStateMachine->SetSeekable(aSeekable);
 21542:   }
 21542: }
 21542: 
 79445: bool nsBuiltinDecoder::IsSeekable()
 21542: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 21542:   return mSeekable;
 21542: }
 23400: 
 75108: nsresult nsBuiltinDecoder::GetSeekable(nsTimeRanges* aSeekable)
 75108: {
 75108:   //TODO : change 0.0 to GetInitialTime() when available
 75108:   double initialTime = 0.0;
 75108: 
 75108:   if (IsSeekable()) {
 75108:     double end = IsInfinite() ? std::numeric_limits<double>::infinity()
 75108:                               : initialTime + GetDuration();
 75108:     aSeekable->Add(initialTime, end);
 75108:     return NS_OK;
 75108:   }
 75108: 
107727:   if (mDecoderStateMachine && mDecoderStateMachine->IsSeekableInBufferedRanges()) {
 75108:     return GetBuffered(aSeekable);
 98899:   } else {
 98899:     // The stream is not seekable using only buffered ranges, and is not
 98899:     // seekable. Don't allow seeking (return no ranges in |seekable|).
 98899:     return NS_OK;
 98899:   }
 75108: }
 75108: 
 77175: void nsBuiltinDecoder::SetEndTime(double aTime)
 77175: {
 77175:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 77175:   if (mDecoderStateMachine) {
 77175:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 77175:     mDecoderStateMachine->SetFragmentEndTime(static_cast<PRInt64>(aTime * USECS_PER_S));
 77175:   }
 77175: }
 77175: 
 41387: void nsBuiltinDecoder::Suspend()
 24020: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 90148:   if (mResource) {
 90148:     mResource->Suspend(true);
 24020:   }
 24020: }
 24020: 
 79445: void nsBuiltinDecoder::Resume(bool aForceBuffering)
 24020: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 90148:   if (mResource) {
 90148:     mResource->Resume();
 24020:   }
 48104:   if (aForceBuffering) {
 69142:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 87739:     if (mDecoderStateMachine) {
 48104:       mDecoderStateMachine->StartBuffering();
 48104:     }
 24020:   }
 87739: }
 24020: 
 41387: void nsBuiltinDecoder::StopProgressUpdates()
 23763: {
 73696:   NS_ASSERTION(OnStateMachineThread() || OnDecodeThread(),
 73696:                "Should be on state machine or decode thread.");
 73696:   GetReentrantMonitor().AssertCurrentThreadIn();
 79547:   mIgnoreProgressData = true;
 90148:   if (mResource) {
 90148:     mResource->SetReadMode(nsMediaCacheStream::MODE_METADATA);
 26836:   }
 23763: }
 23763: 
 41387: void nsBuiltinDecoder::StartProgressUpdates()
 23763: {
 73696:   NS_ASSERTION(OnStateMachineThread() || OnDecodeThread(),
 73696:                "Should be on state machine or decode thread.");
 73696:   GetReentrantMonitor().AssertCurrentThreadIn();
 79547:   mIgnoreProgressData = false;
 90148:   if (mResource) {
 90148:     mResource->SetReadMode(nsMediaCacheStream::MODE_PLAYBACK);
 90148:     mDecoderPosition = mPlaybackPosition = mResource->Tell();
 23763:   }
 26836: }
 27217: 
 41387: void nsBuiltinDecoder::MoveLoadsToBackground()
 27217: {
 40132:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 90148:   if (mResource) {
 90148:     mResource->MoveLoadsToBackground();
 27217:   }
 27217: }
 41391: 
 41391: void nsBuiltinDecoder::UpdatePlaybackOffset(PRInt64 aOffset)
 41391: {
 69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 41391:   mPlaybackPosition = NS_MAX(aOffset, mPlaybackPosition);
 41391: }
 73701: 
 82604: bool nsBuiltinDecoder::OnStateMachineThread() const
 82604: {
 73701:   return IsCurrentThread(nsBuiltinDecoderStateMachine::GetStateMachineThread());
 73701: }
 82604: 
 82604: void nsBuiltinDecoder::NotifyAudioAvailableListener()
 82604: {
 82604:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
 82604:   if (mDecoderStateMachine) {
 82604:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
 82604:     mDecoderStateMachine->NotifyAudioAvailableListener();
 82604:   }
 82604: }
