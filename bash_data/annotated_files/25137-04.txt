    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brian Ryner <bryner@brianryner.com>
    1:  *   Kai Engert <kengert@redhat.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef _NSNSSIOLAYER_H
    1: #define _NSNSSIOLAYER_H
    1: 
    1: #include "prtypes.h"
    1: #include "prio.h"
    1: #include "certt.h"
    1: #include "nsString.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsITransportSecurityInfo.h"
    1: #include "nsISSLSocketControl.h"
 8463: #include "nsSSLStatus.h"
    1: #include "nsISSLStatusProvider.h"
 5220: #include "nsIIdentityInfo.h"
14244: #include "nsIAssociatedContentSecurity.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsNSSShutDown.h"
 5220: #include "nsAutoPtr.h"
 5220: #include "nsNSSCertificate.h"
    1: 
    1: class nsIChannel;
    1: class nsSSLThread;
    1: 
    1: /*
    1:  * This class is used to store SSL socket I/O state information,
    1:  * that is not being executed directly, but defered to 
    1:  * the separate SSL thread.
    1:  */
    1: class nsSSLSocketThreadData
    1: {
    1: public:
    1:   nsSSLSocketThreadData();
    1:   ~nsSSLSocketThreadData();
    1: 
    1:   PRBool ensure_buffer_size(PRInt32 amount);
    1:   
    1:   enum ssl_state { 
11676:     ssl_invalid,       // used for initializating, should never occur
    1:     ssl_idle,          // not in use by SSL thread, no activity pending
    1:     ssl_pending_write, // waiting for SSL thread to complete writing
    1:     ssl_pending_read,  // waiting for SSL thread to complete reading
    1:     ssl_writing_done,  // SSL write completed, results are ready
    1:     ssl_reading_done   // SSL read completed, results are ready
    1:   };
    1:   
    1:   ssl_state mSSLState;
    1: 
    1:   // Used to transport I/O error codes between SSL thread
    1:   // and initial caller thread.
    1:   PRErrorCode mPRErrorCode;
    1: 
    1:   // A buffer used to transfer I/O data between threads
    1:   char *mSSLDataBuffer;
    1:   PRInt32 mSSLDataBufferAllocatedSize;
    1: 
    1:   // The amount requested to read or write by the caller.
    1:   PRInt32 mSSLRequestedTransferAmount;
    1: 
    1:   // A pointer into our buffer, to the first byte
    1:   // that has not yet been delivered to the caller.
    1:   // Necessary, as the caller of the read function
    1:   // might request smaller chunks.
    1:   const char *mSSLRemainingReadResultData;
    1:   
    1:   // The caller previously requested to read or write.
    1:   // As the initial request to read or write is defered,
    1:   // the caller might (in theory) request smaller chunks
    1:   // in subsequent calls.
    1:   // This variable stores the amount of bytes successfully
    1:   // transfered, that have not yet been reported to the caller.
    1:   PRInt32 mSSLResultRemainingBytes;
    1: 
    1:   // When defering SSL read/write activity to another thread,
    1:   // we switch the SSL level file descriptor of the original
    1:   // layered file descriptor to a pollable event,
    1:   // so we can wake up the original caller of the I/O function
    1:   // as soon as data is ready.
    1:   // This variable is used to save the SSL level file descriptor,
    1:   // to allow us to restore the original file descriptor layering.
    1:   PRFileDesc *mReplacedSSLFileDesc;
 2237: 
 2237:   PRBool mOneBytePendingFromEarlierWrite;
 2237:   unsigned char mThePendingByte;
 2237:   PRInt32 mOriginalRequestedTransferAmount;
    1: };
    1: 
    1: class nsNSSSocketInfo : public nsITransportSecurityInfo,
    1:                         public nsISSLSocketControl,
    1:                         public nsIInterfaceRequestor,
    1:                         public nsISSLStatusProvider,
 5220:                         public nsIIdentityInfo,
14244:                         public nsIAssociatedContentSecurity,
 8463:                         public nsISerializable,
 8463:                         public nsIClassInfo,
    1:                         public nsNSSShutDownObject,
    1:                         public nsOnPK11LogoutCancelObject
    1: {
    1: public:
    1:   nsNSSSocketInfo();
    1:   virtual ~nsNSSSocketInfo();
    1:   
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSITRANSPORTSECURITYINFO
    1:   NS_DECL_NSISSLSOCKETCONTROL
    1:   NS_DECL_NSIINTERFACEREQUESTOR
    1:   NS_DECL_NSISSLSTATUSPROVIDER
 5220:   NS_DECL_NSIIDENTITYINFO
14244:   NS_DECL_NSIASSOCIATEDCONTENTSECURITY
 8463:   NS_DECL_NSISERIALIZABLE
 8463:   NS_DECL_NSICLASSINFO
    1: 
    1:   nsresult SetSecurityState(PRUint32 aState);
    1:   nsresult SetShortSecurityDescription(const PRUnichar *aText);
    1:   nsresult SetErrorMessage(const PRUnichar *aText);
    1: 
    1:   nsresult SetForSTARTTLS(PRBool aForSTARTTLS);
    1:   nsresult GetForSTARTTLS(PRBool *aForSTARTTLS);
    1: 
    1:   nsresult GetFileDescPtr(PRFileDesc** aFilePtr);
    1:   nsresult SetFileDescPtr(PRFileDesc* aFilePtr);
    1: 
    1:   nsresult GetHandshakePending(PRBool *aHandshakePending);
    1:   nsresult SetHandshakePending(PRBool aHandshakePending);
    1: 
    1:   nsresult GetHostName(char **aHostName);
    1:   nsresult SetHostName(const char *aHostName);
    1: 
    1:   nsresult GetPort(PRInt32 *aPort);
    1:   nsresult SetPort(PRInt32 aPort);
    1: 
10258:   nsresult GetCert(nsIX509Cert** _result);
10258:   nsresult SetCert(nsIX509Cert *aCert);
10258: 
10258:   nsresult GetPreviousCert(nsIX509Cert** _result);
 5220: 
    1:   void SetCanceled(PRBool aCanceled);
    1:   PRBool GetCanceled();
    1:   
    1:   void SetHasCleartextPhase(PRBool aHasCleartextPhase);
    1:   PRBool GetHasCleartextPhase();
    1:   
    1:   void SetHandshakeInProgress(PRBool aIsIn);
    1:   PRBool GetHandshakeInProgress() { return mHandshakeInProgress; }
    1:   PRBool HandshakeTimeout();
    1: 
    1:   void SetAllowTLSIntoleranceTimeout(PRBool aAllow);
    1: 
    1:   nsresult GetExternalErrorReporting(PRBool* state);
    1:   nsresult SetExternalErrorReporting(PRBool aState);
    1: 
    1:   nsresult RememberCAChain(CERTCertList *aCertList);
    1: 
    1:   /* Set SSL Status values */
 8463:   nsresult SetSSLStatus(nsSSLStatus *aSSLStatus);
 8463:   nsSSLStatus* SSLStatus() { return mSSLStatus; }
10258:   PRBool hasCertErrors();
    1:   
    1:   PRStatus CloseSocketAndDestroy();
    1:   
    1: protected:
    1:   nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
    1:   PRFileDesc* mFd;
10258:   nsCOMPtr<nsIX509Cert> mCert;
14244:   nsCOMPtr<nsIX509Cert> mPreviousCert; // DocShellDependent
    1:   enum { 
    1:     blocking_state_unknown, is_nonblocking_socket, is_blocking_socket 
    1:   } mBlockingState;
    1:   PRUint32 mSecurityState;
14244:   PRInt32 mSubRequestsHighSecurity;
14244:   PRInt32 mSubRequestsLowSecurity;
14244:   PRInt32 mSubRequestsBrokenSecurity;
14244:   PRInt32 mSubRequestsNoSecurity;
    1:   nsString mShortDesc;
    1:   nsString mErrorMessage;
14244:   PRPackedBool mDocShellDependentStuffKnown;
14244:   PRPackedBool mExternalErrorReporting; // DocShellDependent
    1:   PRPackedBool mForSTARTTLS;
    1:   PRPackedBool mHandshakePending;
    1:   PRPackedBool mCanceled;
    1:   PRPackedBool mHasCleartextPhase;
    1:   PRPackedBool mHandshakeInProgress;
    1:   PRPackedBool mAllowTLSIntoleranceTimeout;
    1:   PRIntervalTime mHandshakeStartTime;
    1:   PRInt32 mPort;
    1:   nsXPIDLCString mHostName;
    1: 
    1:   /* SSL Status */
 8463:   nsRefPtr<nsSSLStatus> mSSLStatus;
    1: 
    1:   nsresult ActivateSSL();
    1: 
    1:   nsSSLSocketThreadData *mThreadData;
    1: 
14244:   nsresult EnsureDocShellDependentStuffKnown();
14244: 
    1: private:
    1:   virtual void virtualDestroyNSSReference();
    1:   void destructorSafeDestroyNSSReference();
    1: 
    1: friend class nsSSLThread;
    1: };
    1: 
    1: class nsCStringHashSet;
    1: 
    1: class nsSSLIOLayerHelpers
    1: {
    1: public:
    1:   static nsresult Init();
    1:   static void Cleanup();
    1: 
25137:   static PRBool nsSSLIOLayerInitialized;
    1:   static PRDescIdentity nsSSLIOLayerIdentity;
    1:   static PRIOMethods nsSSLIOLayerMethods;
    1: 
    1:   static PRLock *mutex;
    1:   static nsCStringHashSet *mTLSIntolerantSites;
    1:   
    1:   static PRBool rememberPossibleTLSProblemSite(PRFileDesc* fd, nsNSSSocketInfo *socketInfo);
    1: 
    1:   static void addIntolerantSite(const nsCString &str);
    1:   static PRBool isKnownAsIntolerantSite(const nsCString &str);
    1:   
    1:   static PRFileDesc *mSharedPollableEvent;
    1:   static nsNSSSocketInfo *mSocketOwningPollableEvent;
    1:   
    1:   static PRBool mPollableEventCurrentlySet;
    1: };
    1: 
    1: nsresult nsSSLIOLayerNewSocket(PRInt32 family,
    1:                                const char *host,
    1:                                PRInt32 port,
    1:                                const char *proxyHost,
    1:                                PRInt32 proxyPort,
    1:                                PRFileDesc **fd,
    1:                                nsISupports **securityInfo,
25076:                                PRBool forSTARTTLS,
25076:                                PRBool anonymousLoad);
    1: 
    1: nsresult nsSSLIOLayerAddToSocket(PRInt32 family,
    1:                                  const char *host,
    1:                                  PRInt32 port,
    1:                                  const char *proxyHost,
    1:                                  PRInt32 proxyPort,
    1:                                  PRFileDesc *fd,
    1:                                  nsISupports **securityInfo,
25076:                                  PRBool forSTARTTLS,
25076:                                  PRBool anonymousLoad);
    1: 
    1: nsresult nsSSLIOLayerFreeTLSIntolerantSites();
    1: nsresult displayUnknownCertErrorAlert(nsNSSSocketInfo *infoObject, int error);
    1: 
 8463: // 16786594-0296-4471-8096-8f84497ca428
 8463: #define NS_NSSSOCKETINFO_CID \
 8463: { 0x16786594, 0x0296, 0x4471, \
 8463:     { 0x80, 0x96, 0x8f, 0x84, 0x49, 0x7c, 0xa4, 0x28 } }
 8463: 
 8463: 
    1: #endif /* _NSNSSIOLAYER_H */
