     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef nsHTMLEditor_h__
     1: #define nsHTMLEditor_h__
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsCOMArray.h"
     1: #include "nsPlaintextEditor.h"
     1: #include "nsIEditor.h"
     1: #include "nsIHTMLEditor.h"
     1: #include "nsITableEditor.h"
     1: #include "nsIEditorMailSupport.h"
     1: #include "nsIEditorStyleSheets.h"
     1: 
     1: #include "nsEditor.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMEventListener.h"
     1: #include "nsICSSLoaderObserver.h"
     1: 
     1: #include "nsEditRules.h"
     1: 
     1: #include "nsEditProperty.h"
     1: #include "nsHTMLCSSUtils.h"
     1: 
     1: #include "nsHTMLObjectResizer.h"
     1: #include "nsIHTMLAbsPosEditor.h"
     1: #include "nsIHTMLInlineTableEditor.h"
     1: #include "nsIHTMLObjectResizeListener.h"
104487: #include "nsIHTMLObjectResizer.h"
     1: 
     1: #include "nsIDocumentObserver.h"
     1: 
     1: #include "nsPoint.h"
  7883: #include "nsTArray.h"
 42163: #include "nsAutoPtr.h"
 89783: #include "nsAttrName.h"
104487: #include "nsStubMutationObserver.h"
 89783: 
 98809: #include "mozilla/Attributes.h"
 89783: #include "mozilla/dom/Element.h"
     1: 
     1: class nsIDOMKeyEvent;
     1: class nsITransferable;
     1: class nsIDocumentEncoder;
     1: class nsIClipboard;
     1: class TypeInState;
     1: class nsIContentFilter;
     1: class nsIURL;
     1: class nsILinkHandler;
125899: class nsTableOuterFrame;
 27986: struct PropItem;
     1: 
 82843: namespace mozilla {
 82843: namespace widget {
 82843: struct IMEState;
 82843: } // namespace widget
 82843: } // namespace mozilla
 82843: 
     1: /**
     1:  * The HTML editor implementation.<br>
     1:  * Use to edit HTML document represented as a DOM tree. 
     1:  */
     1: class nsHTMLEditor : public nsPlaintextEditor,
     1:                      public nsIHTMLEditor,
     1:                      public nsIHTMLObjectResizer,
     1:                      public nsIHTMLAbsPosEditor,
     1:                      public nsITableEditor,
     1:                      public nsIHTMLInlineTableEditor,
     1:                      public nsIEditorStyleSheets,
 43716:                      public nsICSSLoaderObserver,
 43716:                      public nsStubMutationObserver
     1: {
     1:   typedef enum {eNoOp, eReplaceParent=1, eInsertParent=2} BlockTransformationType;
     1: 
     1: public:
     1: 
     1:   enum ResizingRequestID
     1:   {
     1:     kX      = 0,
     1:     kY      = 1,
     1:     kWidth  = 2,
     1:     kHeight = 3
     1:   };
     1: 
     1:   // see nsIHTMLEditor for documentation
     1: 
     1: //Interfaces for addref and release and queryinterface
     1: //NOTE macro used is for classes that inherit from 
     1: // another class. Only the base class should use NS_DECL_ISUPPORTS
     1:   NS_DECL_ISUPPORTS_INHERITED
 62825:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsHTMLEditor, nsPlaintextEditor)
     1: 
     1: 
     1:            nsHTMLEditor();
     1:   virtual  ~nsHTMLEditor();
     1: 
101070:   bool GetReturnInParagraphCreatesNewParagraph();
101070: 
     1:   /* ------------ nsPlaintextEditor overrides -------------- */
 79445:   NS_IMETHOD GetIsDocumentEditable(bool *aIsDocumentEditable);
 57480:   NS_IMETHOD BeginningOfDocument();
 43438:   virtual nsresult HandleKeyPressEvent(nsIDOMKeyEvent* aKeyEvent);
 56870:   virtual already_AddRefed<nsIContent> GetFocusedContent();
121442:   virtual already_AddRefed<nsIContent> GetFocusedContentForIME();
 79445:   virtual bool IsActiveInDOMWindow();
166499:   virtual already_AddRefed<mozilla::dom::EventTarget> GetDOMEventTarget();
 97988:   virtual mozilla::dom::Element* GetEditorRoot() MOZ_OVERRIDE;
 43843:   virtual already_AddRefed<nsIContent> FindSelectionRoot(nsINode *aNode);
 79445:   virtual bool IsAcceptableInputEvent(nsIDOMEvent* aEvent);
 94119:   virtual already_AddRefed<nsIContent> GetInputEventTargetContent();
 98127:   virtual bool IsEditable(nsIContent *aNode);
 98127:   using nsEditor::IsEditable;
 41886: 
 43716:   /* ------------ nsStubMutationObserver overrides --------- */
 43716:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
 43716:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
 43716:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
 43716: 
 41886:   /* ------------ nsIEditorIMESupport overrides ------------ */
 82843:   NS_IMETHOD GetPreferredIMEState(mozilla::widget::IMEState *aState);
     1: 
     1:   /* ------------ nsIHTMLEditor methods -------------- */
     1: 
     1:   NS_DECL_NSIHTMLEDITOR
     1: 
     1:   /* ------------ nsIHTMLObjectResizer methods -------------- */
     1:   /* -------- Implemented in nsHTMLObjectResizer.cpp -------- */
     1:   NS_DECL_NSIHTMLOBJECTRESIZER
     1: 
     1:   /* ------------ nsIHTMLAbsPosEditor methods -------------- */
     1:   /* -------- Implemented in nsHTMLAbsPosition.cpp --------- */
     1:   NS_DECL_NSIHTMLABSPOSEDITOR
     1: 
     1:   /* ------------ nsIHTMLInlineTableEditor methods -------------- */
     1:   /* ------- Implemented in nsHTMLInlineTableEditor.cpp --------- */
     1:   NS_DECL_NSIHTMLINLINETABLEEDITOR
     1: 
     1:   /* ------------ nsIHTMLEditor methods -------------- */
     1:   NS_IMETHOD CopyLastEditableChildStyles(nsIDOMNode *aPreviousBlock, nsIDOMNode *aNewBlock,
     1:                                          nsIDOMNode **aOutBrNode);
     1: 
     1:   NS_IMETHOD LoadHTML(const nsAString &aInputString);
     1: 
 79445:   nsresult GetCSSBackgroundColorState(bool *aMixed, nsAString &aOutColor,
 79445:                                       bool aBlockLevel);
 79445:   NS_IMETHOD GetHTMLBackgroundColorState(bool *aMixed, nsAString &outColor);
     1: 
     1:   /* ------------ nsIEditorStyleSheets methods -------------- */
     1: 
     1:   NS_IMETHOD AddStyleSheet(const nsAString & aURL);
     1:   NS_IMETHOD ReplaceStyleSheet(const nsAString& aURL);
     1:   NS_IMETHOD RemoveStyleSheet(const nsAString &aURL);
     1: 
     1:   NS_IMETHOD AddOverrideStyleSheet(const nsAString & aURL);
     1:   NS_IMETHOD ReplaceOverrideStyleSheet(const nsAString& aURL);
     1:   NS_IMETHOD RemoveOverrideStyleSheet(const nsAString &aURL);
     1: 
 79445:   NS_IMETHOD EnableStyleSheet(const nsAString& aURL, bool aEnable);
     1: 
     1:   /* ------------ nsIEditorMailSupport methods -------------- */
     1: 
     1:   NS_DECL_NSIEDITORMAILSUPPORT
     1: 
     1:   /* ------------ nsITableEditor methods -------------- */
     1: 
108991:   NS_IMETHOD InsertTableCell(int32_t aNumber, bool aAfter);
108991:   NS_IMETHOD InsertTableColumn(int32_t aNumber, bool aAfter);
108991:   NS_IMETHOD InsertTableRow(int32_t aNumber, bool aAfter);
     1:   NS_IMETHOD DeleteTable();
108991:   NS_IMETHOD DeleteTableCell(int32_t aNumber);
     1:   NS_IMETHOD DeleteTableCellContents();
108991:   NS_IMETHOD DeleteTableColumn(int32_t aNumber);
108991:   NS_IMETHOD DeleteTableRow(int32_t aNumber);
     1:   NS_IMETHOD SelectTableCell();
     1:   NS_IMETHOD SelectBlockOfCells(nsIDOMElement *aStartCell, nsIDOMElement *aEndCell);
     1:   NS_IMETHOD SelectTableRow();
     1:   NS_IMETHOD SelectTableColumn();
     1:   NS_IMETHOD SelectTable();
     1:   NS_IMETHOD SelectAllTableCells();
     1:   NS_IMETHOD SwitchTableCellHeaderType(nsIDOMElement *aSourceCell, nsIDOMElement **aNewCell);
 79445:   NS_IMETHOD JoinTableCells(bool aMergeNonContiguousContents);
     1:   NS_IMETHOD SplitTableCell();
     1:   NS_IMETHOD NormalizeTable(nsIDOMElement *aTable);
     1:   NS_IMETHOD GetCellIndexes(nsIDOMElement *aCell,
108991:                             int32_t* aRowIndex, int32_t* aColIndex);
     1:   NS_IMETHOD GetTableSize(nsIDOMElement *aTable,
108991:                           int32_t* aRowCount, int32_t* aColCount);
108991:   NS_IMETHOD GetCellAt(nsIDOMElement* aTable, int32_t aRowIndex, int32_t aColIndex, nsIDOMElement **aCell);
     1:   NS_IMETHOD GetCellDataAt(nsIDOMElement* aTable,
108991:                            int32_t aRowIndex, int32_t aColIndex,
     1:                            nsIDOMElement **aCell,
108991:                            int32_t* aStartRowIndex, int32_t* aStartColIndex,
108991:                            int32_t* aRowSpan, int32_t* aColSpan, 
108991:                            int32_t* aActualRowSpan, int32_t* aActualColSpan, 
 79445:                            bool* aIsSelected);
     1:   NS_IMETHOD GetFirstRow(nsIDOMElement* aTableElement, nsIDOMNode** aRowNode);
     1:   NS_IMETHOD GetNextRow(nsIDOMNode* aCurrentRowNode, nsIDOMNode** aRowNode);
     1:   NS_IMETHOD GetLastCellInRow(nsIDOMNode* aRowNode, nsIDOMNode** aCellNode);
     1: 
108991:   NS_IMETHOD SetSelectionAfterTableEdit(nsIDOMElement* aTable, int32_t aRow, int32_t aCol, 
108991:                                         int32_t aDirection, bool aSelected);
     1:   NS_IMETHOD GetSelectedOrParentTableElement(nsAString& aTagName,
108991:                                              int32_t *aSelectedCount,
     1:                                              nsIDOMElement** aTableElement);
108991:   NS_IMETHOD GetSelectedCellsType(nsIDOMElement *aElement, uint32_t *aSelectionType);
     1: 
     1:   nsresult GetCellFromRange(nsIDOMRange *aRange, nsIDOMElement **aCell);
     1: 
     1:   // Finds the first selected cell in first range of selection
     1:   // This is in the *order of selection*, not order in the table
     1:   // (i.e., each cell added to selection is added in another range 
     1:   //  in the selection's rangelist, independent of location in table)
     1:   // aRange is optional: returns the range around the cell
     1:   NS_IMETHOD GetFirstSelectedCell(nsIDOMRange **aRange, nsIDOMElement **aCell);
     1:   // Get next cell until no more are found. Always use GetFirstSelected cell first
     1:   // aRange is optional: returns the range around the cell
     1:   NS_IMETHOD GetNextSelectedCell(nsIDOMRange **aRange, nsIDOMElement **aCell);
     1: 
     1:   // Upper-left-most selected cell in table
108991:   NS_IMETHOD GetFirstSelectedCellInTable(int32_t *aRowIndex, int32_t *aColIndex, nsIDOMElement **aCell);
     1:     
     1:   /* miscellaneous */
     1:   // This sets background on the appropriate container element (table, cell,)
     1:   //   or calls into nsTextEditor to set the page background
     1:   NS_IMETHOD SetCSSBackgroundColor(const nsAString& aColor);
     1:   NS_IMETHOD SetHTMLBackgroundColor(const nsAString& aColor);
     1: 
     1:   /* ------------ Block methods moved from nsEditor -------------- */
 75266:   static already_AddRefed<nsIDOMNode> GetBlockNodeParent(nsIDOMNode *aNode);
     1: 
103675:   void IsNextCharInNodeWhitespace(nsIContent* aContent,
108991:                                   int32_t aOffset,
 79445:                                   bool* outIsSpace,
 79445:                                   bool* outIsNBSP,
106838:                                   nsIContent** outNode = nullptr,
108991:                                   int32_t* outOffset = 0);
103675:   void IsPrevCharInNodeWhitespace(nsIContent* aContent,
108991:                                   int32_t aOffset,
 79445:                                   bool* outIsSpace,
 79445:                                   bool* outIsNBSP,
106838:                                   nsIContent** outNode = nullptr,
108991:                                   int32_t* outOffset = 0);
     1: 
     1:   /* ------------ Overrides of nsEditor interface methods -------------- */
     1: 
     1:   nsresult EndUpdateViewBatch();
     1: 
     1:   /** prepare the editor for use */
199522:   NS_IMETHOD Init(nsIDOMDocument *aDoc, nsIContent *aRoot,
199522:                   nsISelectionController *aSelCon, uint32_t aFlags,
199522:                   const nsAString& aValue);
 79445:   NS_IMETHOD PreDestroy(bool aDestroyingFrames);
     1: 
     1:   /** Internal, static version */
103377:   // aElement must not be null.
103377:   static bool NodeIsBlockStatic(const mozilla::dom::Element* aElement);
 79445:   static nsresult NodeIsBlockStatic(nsIDOMNode *aNode, bool *aIsBlock);
103377: protected:
103377:   using nsEditor::IsBlockNode;
103377:   virtual bool IsBlockNode(nsINode *aNode);
     1: 
103377: public:
108991:   NS_IMETHOD SetFlags(uint32_t aFlags);
     1: 
108991:   NS_IMETHOD Paste(int32_t aSelectionType);
108991:   NS_IMETHOD CanPaste(int32_t aSelectionType, bool *aCanPaste);
     1: 
 36983:   NS_IMETHOD PasteTransferable(nsITransferable *aTransferable);
 79445:   NS_IMETHOD CanPasteTransferable(nsITransferable *aTransferable, bool *aCanPaste);
 36983: 
108991:   NS_IMETHOD DebugUnitTests(int32_t *outNumTests, int32_t *outNumTestsFailed);
     1: 
     1:   /** All editor operations which alter the doc should be prefaced
     1:    *  with a call to StartOperation, naming the action and direction */
108165:   NS_IMETHOD StartOperation(EditAction opID,
 97808:                             nsIEditor::EDirection aDirection);
     1: 
     1:   /** All editor operations which alter the doc should be followed
     1:    *  with a call to EndOperation */
     1:   NS_IMETHOD EndOperation();
     1: 
 80486:   /** returns true if aParentTag can contain a child of type aChildTag */
 97376:   virtual bool TagCanContainTag(nsIAtom* aParentTag, nsIAtom* aChildTag);
     1:   
 80486:   /** returns true if aNode is a container */
 79445:   virtual bool IsContainer(nsIDOMNode *aNode);
     1: 
     1:   /** make the given selection span the entire document */
     1:   NS_IMETHOD SelectEntireDocument(nsISelection *aSelection);
     1: 
     1:   NS_IMETHOD SetAttributeOrEquivalent(nsIDOMElement * aElement,
     1:                                       const nsAString & aAttribute,
     1:                                       const nsAString & aValue,
 79445:                                       bool aSuppressTransaction);
     1:   NS_IMETHOD RemoveAttributeOrEquivalent(nsIDOMElement * aElement,
     1:                                          const nsAString & aAttribute,
 79445:                                          bool aSuppressTransaction);
     1: 
 98809:   /** join together any adjacent editable text nodes in the range */
     1:   NS_IMETHOD CollapseAdjacentTextNodes(nsIDOMRange *aInRange);
     1: 
 98809:   virtual bool AreNodesSameType(nsIContent* aNode1, nsIContent* aNode2)
 98809:     MOZ_OVERRIDE;
     1: 
 98852:   NS_IMETHOD DeleteSelectionImpl(EDirection aAction,
 98852:                                  EStripWrappers aStripWrappers);
 98852:   nsresult DeleteNode(nsINode* aNode);
     1:   NS_IMETHODIMP DeleteNode(nsIDOMNode * aNode);
     1:   NS_IMETHODIMP DeleteText(nsIDOMCharacterData *aTextNode,
108991:                            uint32_t             aOffset,
108991:                            uint32_t             aLength);
  2896:   NS_IMETHOD InsertTextImpl(const nsAString& aStringToInsert, 
  2896:                             nsCOMPtr<nsIDOMNode> *aInOutNode, 
108991:                             int32_t *aInOutOffset,
129215:                             nsIDOMDocument *aDoc);
 79445:   NS_IMETHOD_(bool) IsModifiableNode(nsIDOMNode *aNode);
 82861:   virtual bool IsModifiableNode(nsINode *aNode);
  2896: 
102863:   NS_IMETHOD GetIsSelectionEditable(bool* aIsSelectionEditable);
102863: 
  2896:   NS_IMETHOD SelectAll();
     1: 
 43713:   NS_IMETHOD GetRootElement(nsIDOMElement **aRootElement);
 43713: 
     1:   /* ------------ nsICSSLoaderObserver -------------- */
 79445:   NS_IMETHOD StyleSheetLoaded(nsCSSStyleSheet*aSheet, bool aWasAlternate,
     1:                               nsresult aStatus);
     1: 
     1:   /* ------------ Utility Routines, not part of public API -------------- */
 99468:   NS_IMETHOD TypedText(const nsAString& aString, ETypingAction aAction);
     1:   nsresult InsertNodeAtPoint( nsIDOMNode *aNode, 
     1:                               nsCOMPtr<nsIDOMNode> *ioParent, 
108991:                               int32_t *ioOffset, 
 79445:                               bool aNoEmptyNodes);
     1: 
     1:   // Use this to assure that selection is set after attribute nodes when 
     1:   //  trying to collapse selection at begining of a block node
     1:   //  e.g., when setting at beginning of a table cell
     1:   // This will stop at a table, however, since we don't want to
     1:   //  "drill down" into nested tables.
     1:   // aSelection is optional -- if null, we get current seletion
     1:   nsresult CollapseSelectionToDeepestNonTableFirstChild(nsISelection *aSelection, nsIDOMNode *aNode);
     1: 
 97761:   /**
 97761:    * aNode must be a non-null text node.
 97761:    * outIsEmptyNode must be non-null.
 97761:    */
 88027:   nsresult IsVisTextNode(nsIContent* aNode,
 88027:                          bool* outIsEmptyNode,
 88027:                          bool aSafeToAskFrames);
 79445:   nsresult IsEmptyNode(nsIDOMNode *aNode, bool *outIsEmptyBlock, 
 79445:                        bool aMozBRDoesntCount = false,
 79445:                        bool aListOrCellNotEmpty = false,
 79445:                        bool aSafeToAskFrames = false);
 88029:   nsresult IsEmptyNode(nsINode* aNode, bool* outIsEmptyBlock,
 88029:                        bool aMozBRDoesntCount = false,
 88029:                        bool aListOrCellNotEmpty = false,
 88029:                        bool aSafeToAskFrames = false);
 88027:   nsresult IsEmptyNodeImpl(nsINode* aNode,
 79445:                            bool *outIsEmptyBlock, 
 79445:                            bool aMozBRDoesntCount,
 79445:                            bool aListOrCellNotEmpty,
 79445:                            bool aSafeToAskFrames,
 79445:                            bool *aSeenBR);
     1: 
     1:   // Returns TRUE if sheet was loaded, false if it wasn't
 79445:   bool     EnableExistingStyleSheet(const nsAString& aURL);
     1: 
     1:   // Dealing with the internal style sheet lists:
     1:   NS_IMETHOD GetStyleSheetForURL(const nsAString &aURL,
 42163:                                  nsCSSStyleSheet **_retval);
 42163:   NS_IMETHOD GetURLForStyleSheet(nsCSSStyleSheet *aStyleSheet, nsAString &aURL);
     1: 
     1:   // Add a url + known style sheet to the internal lists:
     1:   nsresult AddNewStyleSheetToList(const nsAString &aURL,
 42163:                                   nsCSSStyleSheet *aStyleSheet);
     1: 
     1:   nsresult RemoveStyleSheetFromList(const nsAString &aURL);
     1: 
 89175:   bool IsCSSEnabled()
 89175:   {
 89175:     // TODO: removal of mCSSAware and use only the presence of mHTMLCSSUtils
 89175:     return mCSSAware && mHTMLCSSUtils && mHTMLCSSUtils->IsCSSPrefChecked();
 89175:   }
 89175: 
 89783:   static bool HasAttributes(mozilla::dom::Element* aElement)
 89783:   {
 89783:     MOZ_ASSERT(aElement);
108991:     uint32_t attrCount = aElement->GetAttrCount();
 89783:     return attrCount > 1 ||
 89783:            (1 == attrCount && !aElement->GetAttrNameAt(0)->Equals(nsGkAtoms::mozdirty));
 89783:   }
 89175: 
     1: protected:
     1: 
     1:   NS_IMETHOD  InitRules();
     1: 
     1:   // Create the event listeners for the editor to install
 73869:   virtual void CreateEventListeners();
     1: 
 40987:   virtual nsresult InstallEventListeners();
     1:   virtual void RemoveEventListeners();
     1: 
 79445:   bool ShouldReplaceRootElement();
 43717:   void ResetRootElementAndEventTarget();
 43713:   nsresult GetBodyElement(nsIDOMHTMLElement** aBody);
 48083:   // Get the focused node of this editor.
 48083:   // @return    If the editor has focus, this returns the focused node.
 48083:   //            Otherwise, returns null.
 43717:   already_AddRefed<nsINode> GetFocusedNode();
 43713: 
     1:   // Return TRUE if aElement is a table-related elemet and caret was set
 79445:   bool SetCaretInTableCell(nsIDOMElement* aElement);
     1: 
     1:   // key event helpers
 79445:   NS_IMETHOD TabInTable(bool inIsShift, bool *outHandled);
108991:   NS_IMETHOD CreateBR(nsIDOMNode *aNode, int32_t aOffset, 
     1:                       nsCOMPtr<nsIDOMNode> *outBRNode, nsIEditor::EDirection aSelect = nsIEditor::eNone);
     1: 
     1: // Table Editing (implemented in nsTableEditor.cpp)
     1: 
     1:   // Table utilities
     1: 
     1:   // Insert a new cell after or before supplied aCell. 
     1:   //  Optional: If aNewCell supplied, returns the newly-created cell (addref'd, of course)
     1:   // This doesn't change or use the current selection
108991:   NS_IMETHOD InsertCell(nsIDOMElement *aCell, int32_t aRowSpan, int32_t aColSpan,
 79445:                         bool aAfter, bool aIsHeader, nsIDOMElement **aNewCell);
     1: 
     1:   // Helpers that don't touch the selection or do batch transactions
108991:   NS_IMETHOD DeleteRow(nsIDOMElement *aTable, int32_t aRowIndex);
108991:   NS_IMETHOD DeleteColumn(nsIDOMElement *aTable, int32_t aColIndex);
     1:   NS_IMETHOD DeleteCellContents(nsIDOMElement *aCell);
     1: 
     1:   // Move all contents from aCellToMerge into aTargetCell (append at end)
 79445:   NS_IMETHOD MergeCells(nsCOMPtr<nsIDOMElement> aTargetCell, nsCOMPtr<nsIDOMElement> aCellToMerge, bool aDeleteCellToMerge);
     1: 
     1:   NS_IMETHOD DeleteTable2(nsIDOMElement *aTable, nsISelection *aSelection);
108991:   NS_IMETHOD SetColSpan(nsIDOMElement *aCell, int32_t aColSpan);
108991:   NS_IMETHOD SetRowSpan(nsIDOMElement *aCell, int32_t aRowSpan);
     1: 
125899:   // Helper used to get nsTableOuterFrame for a table.
125899:   nsTableOuterFrame* GetTableFrame(nsIDOMElement* aTable);
     1:   // Needed to do appropriate deleting when last cell or row is about to be deleted
     1:   // This doesn't count cells that don't start in the given row (are spanning from row above)
108991:   int32_t  GetNumberOfCellsInRow(nsIDOMElement* aTable, int32_t rowIndex);
     1:   // Test if all cells in row or column at given index are selected
108991:   bool AllCellsInRowSelected(nsIDOMElement *aTable, int32_t aRowIndex, int32_t aNumberOfColumns);
108991:   bool AllCellsInColumnSelected(nsIDOMElement *aTable, int32_t aColIndex, int32_t aNumberOfRows);
     1: 
101127:   bool IsEmptyCell(mozilla::dom::Element* aCell);
     1: 
     1:   // Most insert methods need to get the same basic context data
     1:   // Any of the pointers may be null if you don't need that datum (for more efficiency)
     1:   // Input: *aCell is a known cell,
     1:   //        if null, cell is obtained from the anchor node of the selection
     1:   // Returns NS_EDITOR_ELEMENT_NOT_FOUND if cell is not found even if aCell is null
     1:   NS_IMETHOD GetCellContext(nsISelection **aSelection,
     1:                             nsIDOMElement   **aTable,
     1:                             nsIDOMElement   **aCell,
108991:                             nsIDOMNode      **aCellParent, int32_t *aCellOffset,
108991:                             int32_t *aRowIndex, int32_t *aColIndex);
     1: 
108991:   NS_IMETHOD GetCellSpansAt(nsIDOMElement* aTable, int32_t aRowIndex, int32_t aColIndex, 
108991:                             int32_t& aActualRowSpan, int32_t& aActualColSpan);
     1: 
108991:   NS_IMETHOD SplitCellIntoColumns(nsIDOMElement *aTable, int32_t aRowIndex, int32_t aColIndex,
108991:                                   int32_t aColSpanLeft, int32_t aColSpanRight, nsIDOMElement **aNewCell);
     1: 
108991:   NS_IMETHOD SplitCellIntoRows(nsIDOMElement *aTable, int32_t aRowIndex, int32_t aColIndex,
108991:                                int32_t aRowSpanAbove, int32_t aRowSpanBelow, nsIDOMElement **aNewCell);
     1: 
     1:   nsresult CopyCellBackgroundColor(nsIDOMElement *destCell, nsIDOMElement *sourceCell);
     1: 
 42587:   // Reduce rowspan/colspan when cells span into nonexistent rows/columns
108991:   NS_IMETHOD FixBadRowSpan(nsIDOMElement *aTable, int32_t aRowIndex, int32_t& aNewRowCount);
108991:   NS_IMETHOD FixBadColSpan(nsIDOMElement *aTable, int32_t aColIndex, int32_t& aNewColCount);
     1: 
     1:   // Fallback method: Call this after using ClearSelection() and you
     1:   //  failed to set selection to some other content in the document
     1:   NS_IMETHOD SetSelectionAtDocumentStart(nsISelection *aSelection);
     1: 
     1: // End of Table Editing utilities
     1:   
     1:   static nsCOMPtr<nsIDOMNode> GetEnclosingTable(nsIDOMNode *aNode);
     1: 
 80486:   /** content-based query returns true if <aProperty aAttribute=aValue> effects aNode
     1:     * If <aProperty aAttribute=aValue> contains aNode, 
     1:     * but <aProperty aAttribute=SomeOtherValue> also contains aNode and the second is
     1:     * more deeply nested than the first, then the first does not effect aNode.
     1:     *
     1:     * @param aNode      The target of the query
     1:     * @param aProperty  The property that we are querying for
     1:     * @param aAttribute The attribute of aProperty, example: color in <FONT color="blue">
     1:     *                   May be null.
     1:     * @param aValue     The value of aAttribute, example: blue in <FONT color="blue">
     1:     *                   May be null.  Ignored if aAttribute is null.
 80486:     * @param aIsSet     [OUT] true if <aProperty aAttribute=aValue> effects aNode.
 97458:     * @param outValue   [OUT] the value of the attribute, if aIsSet is true
100183:     *
100183:     * The nsIContent variant returns aIsSet instead of using an out parameter.
     1:     */
100183:   bool IsTextPropertySetByContent(nsIContent*      aContent,
100183:                                   nsIAtom*         aProperty,
100183:                                   const nsAString* aAttribute,
100183:                                   const nsAString* aValue,
106838:                                   nsAString*       outValue = nullptr);
100183: 
 97458:   void IsTextPropertySetByContent(nsIDOMNode*      aNode,
     1:                                   nsIAtom*         aProperty,
     1:                                   const nsAString* aAttribute,
     1:                                   const nsAString* aValue,
 79445:                                   bool&            aIsSet,
106838:                                   nsAString*       outValue = nullptr);
     1: 
     1:   // Methods for handling plaintext quotations
108991:   NS_IMETHOD PasteAsPlaintextQuotation(int32_t aSelectionType);
     1: 
     1:   /** Insert a string as quoted text,
     1:     * replacing the selected text (if any).
     1:     * @param aQuotedText     The string to insert.
     1:     * @param aAddCites       Whether to prepend extra ">" to each line
     1:     *                        (usually true, unless those characters
     1:     *                        have already been added.)
     1:     * @return aNodeInserted  The node spanning the insertion, if applicable.
     1:     *                        If aAddCites is false, this will be null.
     1:     */
     1:   NS_IMETHOD InsertAsPlaintextQuotation(const nsAString & aQuotedText,
 79445:                                         bool aAddCites,
     1:                                         nsIDOMNode **aNodeInserted);
 90376: 
 90376:   nsresult InsertObject(const char* aType, nsISupports* aObject, bool aIsSafe,
129215:                         nsIDOMDocument *aSourceDoc,
 90376:                         nsIDOMNode *aDestinationNode,
108991:                         int32_t aDestOffset,
 90376:                         bool aDoDeleteSelection);
     1: 
     1:   // factored methods for handling insertion of data from transferables (drag&drop or clipboard)
     1:   NS_IMETHOD PrepareTransferable(nsITransferable **transferable);
 79445:   NS_IMETHOD PrepareHTMLTransferable(nsITransferable **transferable, bool havePrivFlavor);
     1:   NS_IMETHOD InsertFromTransferable(nsITransferable *transferable, 
129215:                                     nsIDOMDocument *aSourceDoc,
     1:                                     const nsAString & aContextStr,
     1:                                     const nsAString & aInfoStr,
     1:                                     nsIDOMNode *aDestinationNode,
108991:                                     int32_t aDestinationOffset,
 79445:                                     bool aDoDeleteSelection);
189243:   nsresult InsertFromDataTransfer(mozilla::dom::DataTransfer *aDataTransfer,
108991:                                   int32_t aIndex,
129215:                                   nsIDOMDocument *aSourceDoc,
 90376:                                   nsIDOMNode *aDestinationNode,
108991:                                   int32_t aDestOffset,
 90376:                                   bool aDoDeleteSelection);
 79445:   bool HavePrivateHTMLFlavor( nsIClipboard *clipboard );
179103:   nsresult   ParseCFHTML(nsCString & aCfhtml, char16_t **aStuffToPaste, char16_t **aCfcontext);
     1:   nsresult   DoContentFilterCallback(const nsAString &aFlavor,
129215:                                      nsIDOMDocument *aSourceDoc,
 79445:                                      bool aWillDeleteSelection,
     1:                                      nsIDOMNode **aFragmentAsNode,      
     1:                                      nsIDOMNode **aFragStartNode,
108991:                                      int32_t *aFragStartOffset,
     1:                                      nsIDOMNode **aFragEndNode,
108991:                                      int32_t *aFragEndOffset,
     1:                                      nsIDOMNode **aTargetNode,       
108991:                                      int32_t *aTargetOffset,   
 79445:                                      bool *aDoContinue);
     1: 
106838:   bool       IsInLink(nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *outLink = nullptr);
 79445:   nsresult   StripFormattingNodes(nsIDOMNode *aNode, bool aOnlyList = false);
     1:   nsresult   CreateDOMFragmentFromPaste(const nsAString & aInputString,
     1:                                         const nsAString & aContextStr,
     1:                                         const nsAString & aInfoStr,
     1:                                         nsCOMPtr<nsIDOMNode> *outFragNode,
     1:                                         nsCOMPtr<nsIDOMNode> *outStartNode,
     1:                                         nsCOMPtr<nsIDOMNode> *outEndNode,
108991:                                         int32_t *outStartOffset,
108991:                                         int32_t *outEndOffset,
 79445:                                         bool aTrustedInput);
 74556:   nsresult   ParseFragment(const nsAString & aStr, nsIAtom* aContextLocalName,
 30162:                            nsIDocument* aTargetDoc,
 54661:                            nsCOMPtr<nsIDOMNode> *outNode,
 79445:                            bool aTrustedInput);
     1:   nsresult   CreateListOfNodesToPaste(nsIDOMNode  *aFragmentAsNode,
     1:                                       nsCOMArray<nsIDOMNode>& outNodeList,
     1:                                       nsIDOMNode *aStartNode,
108991:                                       int32_t aStartOffset,
     1:                                       nsIDOMNode *aEndNode,
108991:                                       int32_t aEndOffset);
 30162:   nsresult CreateTagStack(nsTArray<nsString> &aTagStack,
 30162:                           nsIDOMNode *aNode);
 79445:   nsresult GetListAndTableParents( bool aEnd, 
     1:                                    nsCOMArray<nsIDOMNode>& aListOfNodes,
     1:                                    nsCOMArray<nsIDOMNode>& outArray);
     1:   nsresult DiscoverPartialListsAndTables(nsCOMArray<nsIDOMNode>& aPasteNodes,
     1:                                          nsCOMArray<nsIDOMNode>& aListsAndTables,
108991:                                          int32_t *outHighWaterMark);
 79445:   nsresult ScanForListAndTableStructure(bool aEnd,
     1:                                         nsCOMArray<nsIDOMNode>& aNodes,
     1:                                         nsIDOMNode *aListOrTable,
     1:                                         nsCOMPtr<nsIDOMNode> *outReplaceNode);
 79445:   nsresult ReplaceOrphanedStructure( bool aEnd,
     1:                                      nsCOMArray<nsIDOMNode>& aNodeArray,
     1:                                      nsCOMArray<nsIDOMNode>& aListAndTableArray,
108991:                                      int32_t aHighWaterMark);
 79445:   nsIDOMNode* GetArrayEndpoint(bool aEnd, nsCOMArray<nsIDOMNode>& aNodeArray);
     1: 
     1:   /* small utility routine to test if a break node is visible to user */
 79445:   bool     IsVisBreak(nsIDOMNode *aNode);
     1: 
     1:   /* utility routine to possibly adjust the insertion position when 
     1:      inserting a block level element */
     1:   void NormalizeEOLInsertPosition(nsIDOMNode *firstNodeToInsert,
     1:                                   nsCOMPtr<nsIDOMNode> *insertParentNode,
108991:                                   int32_t *insertOffset);
     1: 
     1:   /* small utility routine to test the eEditorReadonly bit */
 79445:   bool IsModifiable();
     1: 
     1:   /* helpers for block transformations */
     1:   nsresult MakeDefinitionItem(const nsAString & aItemType);
     1:   nsresult InsertBasicBlock(const nsAString & aBlockType);
     1:   
     1:   /* increase/decrease the font size of selection */
108991:   nsresult RelativeFontChange( int32_t aSizeChange);
     1:   
     1:   /* helper routines for font size changing */
108991:   nsresult RelativeFontChangeOnTextNode( int32_t aSizeChange, 
     1:                                          nsIDOMCharacterData *aTextNode, 
108991:                                          int32_t aStartOffset,
108991:                                          int32_t aEndOffset);
108991:   nsresult RelativeFontChangeOnNode(int32_t aSizeChange, nsINode* aNode);
108991:   nsresult RelativeFontChangeHelper(int32_t aSizeChange, nsINode* aNode);
     1: 
     1:   /* helper routines for inline style */
     1:   nsresult SetInlinePropertyOnTextNode( nsIDOMCharacterData *aTextNode, 
108991:                                         int32_t aStartOffset,
108991:                                         int32_t aEndOffset,
     1:                                         nsIAtom *aProperty, 
     1:                                         const nsAString *aAttribute,
     1:                                         const nsAString *aValue);
     1:   nsresult SetInlinePropertyOnNode( nsIDOMNode *aNode,
     1:                                     nsIAtom *aProperty, 
     1:                                     const nsAString *aAttribute,
     1:                                     const nsAString *aValue);
 97760:   nsresult SetInlinePropertyOnNode(nsIContent* aNode,
 97760:                                    nsIAtom* aProperty,
 97760:                                    const nsAString* aAttribute,
 97760:                                    const nsAString* aValue);
     1: 
     1:   nsresult PromoteInlineRange(nsIDOMRange *inRange);
     1:   nsresult PromoteRangeIfStartsOrEndsInNamedAnchor(nsIDOMRange *inRange);
     1:   nsresult SplitStyleAboveRange(nsIDOMRange *aRange, 
     1:                                 nsIAtom *aProperty, 
     1:                                 const nsAString *aAttribute);
     1:   nsresult SplitStyleAbovePoint(nsCOMPtr<nsIDOMNode> *aNode,
108991:                                 int32_t *aOffset,
     1:                                 nsIAtom *aProperty, 
     1:                                 const nsAString *aAttribute,
106838:                                 nsCOMPtr<nsIDOMNode> *outLeftNode = nullptr,
106838:                                 nsCOMPtr<nsIDOMNode> *outRightNode = nullptr);
     1:   nsresult ApplyDefaultProperties();
     1:   nsresult RemoveStyleInside(nsIDOMNode *aNode, 
     1:                              nsIAtom *aProperty, 
     1:                              const nsAString *aAttribute, 
 96729:                              const bool aChildrenOnly = false);
     1:   nsresult RemoveInlinePropertyImpl(nsIAtom *aProperty, const nsAString *aAttribute);
     1: 
 79445:   bool NodeIsProperty(nsIDOMNode *aNode);
 79445:   bool HasAttr(nsIDOMNode *aNode, const nsAString *aAttribute);
108991:   bool IsAtFrontOfNode(nsIDOMNode *aNode, int32_t aOffset);
108991:   bool IsAtEndOfNode(nsIDOMNode *aNode, int32_t aOffset);
 79445:   bool IsOnlyAttribute(nsIDOMNode *aElement, const nsAString *aAttribute);
 97757:   bool IsOnlyAttribute(const nsIContent* aElement, const nsAString& aAttribute);
     1: 
     1:   nsresult RemoveBlockContainer(nsIDOMNode *inNode);
126532: 
 97758:   nsIContent* GetPriorHTMLSibling(nsINode* aNode);
     1:   nsresult GetPriorHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode);
108991:   nsIContent* GetPriorHTMLSibling(nsINode* aParent, int32_t aOffset);
108991:   nsresult GetPriorHTMLSibling(nsIDOMNode *inParent, int32_t inOffset, nsCOMPtr<nsIDOMNode> *outNode);
126532: 
 97758:   nsIContent* GetNextHTMLSibling(nsINode* aNode);
     1:   nsresult GetNextHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode);
108991:   nsIContent* GetNextHTMLSibling(nsINode* aParent, int32_t aOffset);
108991:   nsresult GetNextHTMLSibling(nsIDOMNode *inParent, int32_t inOffset, nsCOMPtr<nsIDOMNode> *outNode);
126532: 
126532:   nsIContent* GetPriorHTMLNode(nsINode* aNode, bool aNoBlockCrossing = false);
 79445:   nsresult GetPriorHTMLNode(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode, bool bNoBlockCrossing = false);
108991:   nsIContent* GetPriorHTMLNode(nsINode* aParent, int32_t aOffset,
103676:                                bool aNoBlockCrossing = false);
126532:   nsresult GetPriorHTMLNode(nsIDOMNode *inParent, int32_t inOffset, nsCOMPtr<nsIDOMNode> *outNode, bool bNoBlockCrossing = false);
126532: 
126533:   nsIContent* GetNextHTMLNode(nsINode* aNode, bool aNoBlockCrossing = false);
 79445:   nsresult GetNextHTMLNode(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode, bool bNoBlockCrossing = false);
108991:   nsIContent* GetNextHTMLNode(nsINode* aParent, int32_t aOffset,
103676:                               bool aNoBlockCrossing = false);
108991:   nsresult GetNextHTMLNode(nsIDOMNode *inParent, int32_t inOffset, nsCOMPtr<nsIDOMNode> *outNode, bool bNoBlockCrossing = false);
     1: 
 79445:   nsresult IsFirstEditableChild( nsIDOMNode *aNode, bool *aOutIsFirst);
 79445:   nsresult IsLastEditableChild( nsIDOMNode *aNode, bool *aOutIsLast);
     1:   nsresult GetFirstEditableChild( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutFirstChild);
     1:   nsresult GetLastEditableChild( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutLastChild);
     1: 
     1:   nsresult GetFirstEditableLeaf( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutFirstLeaf);
     1:   nsresult GetLastEditableLeaf( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutLastLeaf);
     1: 
     1:   nsresult GetInlinePropertyBase(nsIAtom *aProperty, 
     1:                              const nsAString *aAttribute,
     1:                              const nsAString *aValue,
 79445:                              bool *aFirst, 
 79445:                              bool *aAny, 
 79445:                              bool *aAll,
     1:                              nsAString *outValue,
 79445:                              bool aCheckDefaults = true);
 89176:   bool HasStyleOrIdOrClass(mozilla::dom::Element* aElement);
 89176:   nsresult RemoveElementIfNoStyleOrIdOrClass(nsIDOMNode* aElement);
     1: 
 41886:   // Whether the outer window of the DOM event target has focus or not.
 79445:   bool     OurWindowHasFocus();
 41886: 
 54661:   // This function is used to insert a string of HTML input optionally with some
 54661:   // context information into the editable field.  The HTML input either comes
 54661:   // from a transferable object created as part of a drop/paste operation, or from
 54661:   // the InsertHTML method.  We may want the HTML input to be sanitized (for example,
 54661:   // if it's coming from a transferable object), in which case aTrustedInput should
 54661:   // be set to false, otherwise, the caller should set it to true, which means that
 54661:   // the HTML will be inserted in the DOM verbatim.
152207:   //
152207:   // aClearStyle should be set to false if you want the paste to be affected by
152207:   // local style (e.g., for the insertHTML command).
 54661:   nsresult DoInsertHTMLWithContext(const nsAString& aInputString,
 54661:                                    const nsAString& aContextStr,
 54661:                                    const nsAString& aInfoStr,
 54661:                                    const nsAString& aFlavor,
129215:                                    nsIDOMDocument* aSourceDoc,
 54661:                                    nsIDOMNode* aDestNode,
108991:                                    int32_t aDestOffset,
 79445:                                    bool aDeleteSelection,
152207:                                    bool aTrustedInput,
152207:                                    bool aClearStyle = true);
 54661: 
108991:   nsresult ClearStyle(nsCOMPtr<nsIDOMNode>* aNode, int32_t* aOffset,
 98853:                       nsIAtom* aProperty, const nsAString* aAttribute);
 98853: 
     1: // Data members
     1: protected:
     1: 
     1:   nsCOMArray<nsIContentFilter> mContentFilters;
     1: 
 57958:   nsRefPtr<TypeInState>        mTypeInState;
     1: 
 79445:   bool mCRInParagraphCreatesParagraph;
     1: 
 79445:   bool mCSSAware;
 57958:   nsAutoPtr<nsHTMLCSSUtils> mHTMLCSSUtils;
     1: 
     1:   // Used by GetFirstSelectedCell and GetNextSelectedCell
108991:   int32_t  mSelectedCellIndex;
     1: 
     1:   nsString mLastStyleSheetURL;
     1:   nsString mLastOverrideStyleSheetURL;
     1: 
     1:   // Maintain a list of associated style sheets and their urls.
 23904:   nsTArray<nsString> mStyleSheetURLs;
 42163:   nsTArray<nsRefPtr<nsCSSStyleSheet> > mStyleSheets;
     1:   
     1:   // an array for holding default style settings
 27986:   nsTArray<PropItem*> mDefaultStyles;
     1: 
     1: protected:
     1: 
     1:   /* ANONYMOUS UTILS */
     1:   void     RemoveListenerAndDeleteRef(const nsAString& aEvent,
     1:                                       nsIDOMEventListener* aListener,
 79445:                                       bool aUseCapture,
     1:                                       nsIDOMElement* aElement,
     1:                                       nsIContent* aParentContent,
     1:                                       nsIPresShell* aShell);
     1:   void     DeleteRefToAnonymousNode(nsIDOMElement* aElement,
     1:                                     nsIContent * aParentContent,
     1:                                     nsIPresShell* aShell);
 10522: 
 27288:   nsresult ShowResizersInner(nsIDOMElement *aResizedElement);
 27288: 
 10522:   // Returns the offset of an element's frame to its absolute containing block.
108991:   nsresult GetElementOrigin(nsIDOMElement * aElement, int32_t & aX, int32_t & aY);
     1:   nsresult GetPositionAndDimensions(nsIDOMElement * aElement,
108991:                                     int32_t & aX, int32_t & aY,
108991:                                     int32_t & aW, int32_t & aH,
108991:                                     int32_t & aBorderLeft,
108991:                                     int32_t & aBorderTop,
108991:                                     int32_t & aMarginLeft,
108991:                                     int32_t & aMarginTop);
     1: 
     1:   /* PACKED BOOLEANS FOR RESIZING, ABSOLUTE POSITIONING AND */
     1:   /* INLINE TABLE EDITING */
     1: 
     1:   // resizing
 79445:   bool mIsObjectResizingEnabled;
 79445:   bool mIsResizing;
 79445:   bool mPreserveRatio;
 79445:   bool mResizedObjectIsAnImage;
     1: 
     1:   // absolute positioning
 79445:   bool mIsAbsolutelyPositioningEnabled;
 79445:   bool mResizedObjectIsAbsolutelyPositioned;
     1: 
 79445:   bool mGrabberClicked;
 79445:   bool mIsMoving;
     1: 
 79445:   bool mSnapToGridEnabled;
     1: 
     1:   // inline table editing
 79445:   bool mIsInlineTableEditingEnabled;
     1: 
     1:   /* RESIZING */
     1: 
     1:   nsCOMPtr<nsIDOMElement> mTopLeftHandle;
     1:   nsCOMPtr<nsIDOMElement> mTopHandle;
     1:   nsCOMPtr<nsIDOMElement> mTopRightHandle;
     1:   nsCOMPtr<nsIDOMElement> mLeftHandle;
     1:   nsCOMPtr<nsIDOMElement> mRightHandle;
     1:   nsCOMPtr<nsIDOMElement> mBottomLeftHandle;
     1:   nsCOMPtr<nsIDOMElement> mBottomHandle;
     1:   nsCOMPtr<nsIDOMElement> mBottomRightHandle;
     1: 
     1:   nsCOMPtr<nsIDOMElement> mActivatedHandle;
     1: 
     1:   nsCOMPtr<nsIDOMElement> mResizingShadow;
     1:   nsCOMPtr<nsIDOMElement> mResizingInfo;
     1: 
     1:   nsCOMPtr<nsIDOMElement> mResizedObject;
     1: 
     1:   nsCOMPtr<nsIDOMEventListener>  mMouseMotionListenerP;
     1:   nsCOMPtr<nsISelectionListener> mSelectionListenerP;
     1:   nsCOMPtr<nsIDOMEventListener>  mResizeEventListenerP;
     1: 
     1:   nsCOMArray<nsIHTMLObjectResizeListener> objectResizeEventListeners;
     1: 
108991:   int32_t mOriginalX;
108991:   int32_t mOriginalY;
     1: 
108991:   int32_t mResizedObjectX;
108991:   int32_t mResizedObjectY;
108991:   int32_t mResizedObjectWidth;
108991:   int32_t mResizedObjectHeight;
     1: 
108991:   int32_t mResizedObjectMarginLeft;
108991:   int32_t mResizedObjectMarginTop;
108991:   int32_t mResizedObjectBorderLeft;
108991:   int32_t mResizedObjectBorderTop;
     1: 
108991:   int32_t mXIncrementFactor;
108991:   int32_t mYIncrementFactor;
108991:   int32_t mWidthIncrementFactor;
108991:   int32_t mHeightIncrementFactor;
     1: 
108991:   int8_t  mInfoXIncrement;
108991:   int8_t  mInfoYIncrement;
     1: 
     1:   nsresult SetAllResizersPosition();
     1: 
108991:   nsresult CreateResizer(nsIDOMElement ** aReturn, int16_t aLocation, nsIDOMNode * aParentNode);
108991:   void     SetAnonymousElementPosition(int32_t aX, int32_t aY, nsIDOMElement *aResizer);
     1: 
     1:   nsresult CreateShadow(nsIDOMElement ** aReturn, nsIDOMNode * aParentNode,
     1:                         nsIDOMElement * aOriginalObject);
     1:   nsresult SetShadowPosition(nsIDOMElement * aShadow,
     1:                              nsIDOMElement * aOriginalObject,
108991:                              int32_t aOriginalObjectX,
108991:                              int32_t aOriginalObjectY);
     1: 
     1:   nsresult CreateResizingInfo(nsIDOMElement ** aReturn, nsIDOMNode * aParentNode);
108991:   nsresult SetResizingInfoPosition(int32_t aX, int32_t aY,
108991:                                    int32_t aW, int32_t aH);
     1: 
108991:   int32_t  GetNewResizingIncrement(int32_t aX, int32_t aY, int32_t aID);
     1:   nsresult StartResizing(nsIDOMElement * aHandle);
108991:   int32_t  GetNewResizingX(int32_t aX, int32_t aY);
108991:   int32_t  GetNewResizingY(int32_t aX, int32_t aY);
108991:   int32_t  GetNewResizingWidth(int32_t aX, int32_t aY);
108991:   int32_t  GetNewResizingHeight(int32_t aX, int32_t aY);
     1:   void     HideShadowAndInfo();
108991:   void     SetFinalSize(int32_t aX, int32_t aY);
     1:   void     DeleteRefToAnonymousNode(nsIDOMNode * aNode);
108991:   void     SetResizeIncrements(int32_t aX, int32_t aY, int32_t aW, int32_t aH, bool aPreserveRatio);
 62878:   void     HideAnonymousEditingUIs();
     1: 
     1:   /* ABSOLUTE POSITIONING */
     1: 
108991:   int32_t mPositionedObjectX;
108991:   int32_t mPositionedObjectY;
108991:   int32_t mPositionedObjectWidth;
108991:   int32_t mPositionedObjectHeight;
     1: 
108991:   int32_t mPositionedObjectMarginLeft;
108991:   int32_t mPositionedObjectMarginTop;
108991:   int32_t mPositionedObjectBorderLeft;
108991:   int32_t mPositionedObjectBorderTop;
     1: 
     1:   nsCOMPtr<nsIDOMElement> mAbsolutelyPositionedObject;
     1:   nsCOMPtr<nsIDOMElement> mGrabber;
     1:   nsCOMPtr<nsIDOMElement> mPositioningShadow;
     1: 
108991:   int32_t      mGridSize;
     1: 
     1:   nsresult CreateGrabber(nsIDOMNode * aParentNode, nsIDOMElement ** aReturn);
     1:   nsresult StartMoving(nsIDOMElement * aHandle);
108991:   nsresult SetFinalPosition(int32_t aX, int32_t aY);
108991:   void     AddPositioningOffset(int32_t & aX, int32_t & aY);
108991:   void     SnapToGrid(int32_t & newX, int32_t & newY);
     1:   nsresult GrabberClicked();
     1:   nsresult EndMoving();
     1:   nsresult CheckPositionedElementBGandFG(nsIDOMElement * aElement,
     1:                                          nsAString & aReturn);
     1: 
     1:   /* INLINE TABLE EDITING */
     1: 
     1:   nsCOMPtr<nsIDOMElement> mInlineEditedCell;
     1: 
     1:   nsCOMPtr<nsIDOMElement> mAddColumnBeforeButton;
     1:   nsCOMPtr<nsIDOMElement> mRemoveColumnButton;
     1:   nsCOMPtr<nsIDOMElement> mAddColumnAfterButton;
     1: 
     1:   nsCOMPtr<nsIDOMElement> mAddRowBeforeButton;
     1:   nsCOMPtr<nsIDOMElement> mRemoveRowButton;
     1:   nsCOMPtr<nsIDOMElement> mAddRowAfterButton;
     1: 
     1:   void     AddMouseClickListener(nsIDOMElement * aElement);
     1:   void     RemoveMouseClickListener(nsIDOMElement * aElement);
     1: 
     1:   nsCOMPtr<nsILinkHandler> mLinkHandler;
     1: 
     1: public:
     1: 
     1: // friends
     1: friend class nsHTMLEditRules;
     1: friend class nsTextEditRules;
     1: friend class nsWSRunObject;
 95669: friend class nsHTMLEditorEventListener;
     1: 
 96754: private:
100182:   // Helpers
100182:   bool IsSimpleModifiableNode(nsIContent* aContent,
100182:                               nsIAtom* aProperty,
100182:                               const nsAString* aAttribute,
100182:                               const nsAString* aValue);
 97760:   nsresult SetInlinePropertyOnNodeImpl(nsIContent* aNode,
 96754:                                        nsIAtom* aProperty,
 96754:                                        const nsAString* aAttribute,
 96754:                                        const nsAString* aValue);
199534:   typedef enum { eInserted, eAppended } InsertedOrAppended;
199534:   void DoContentInserted(nsIDocument* aDocument, nsIContent* aContainer,
199534:                          nsIContent* aChild, int32_t aIndexInContainer,
199534:                          InsertedOrAppended aInsertedOrAppended);
     1: };
     1: #endif //nsHTMLEditor_h__
     1: 
