     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: // vim:set et cin sw=2 sts=2:
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
  3642:  * A base class implementing nsIObjectLoadingContent for use by
     1:  * various content nodes that want to provide plugin/document/image
     1:  * loading functionality (eg <embed>, <object>, <applet>, etc).
     1:  */
     1: 
     1: // Interface headers
115983: #include "imgLoader.h"
 38026: #include "nsEventDispatcher.h"
     1: #include "nsIContent.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocument.h"
 38026: #include "nsIDOMDataContainerEvent.h"
 70359: #include "nsIDOMDocument.h"
 38026: #include "nsIDOMEventTarget.h"
     1: #include "nsIExternalProtocolHandler.h"
 68780: #include "nsEventStates.h"
     1: #include "nsIObjectFrame.h"
     1: #include "nsIPluginDocument.h"
 95663: #include "nsIPermissionManager.h"
 70007: #include "nsPluginHost.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsIStreamConverterService.h"
     1: #include "nsIURILoader.h"
     1: #include "nsIURL.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIWebNavigationInfo.h"
  8608: #include "nsIScriptChannel.h"
 33384: #include "nsIBlocklistService.h"
 48889: #include "nsIAsyncVerifyRedirectCallback.h"
 89114: #include "nsIAppShell.h"
     1: 
108290: #include "nsError.h"
     1: 
     1: // Util headers
106522: #include "prenv.h"
     1: #include "prlog.h"
     1: 
     1: #include "nsAutoPtr.h"
     1: #include "nsCURILoader.h"
     1: #include "nsContentPolicyUtils.h"
     1: #include "nsContentUtils.h"
     1: #include "nsDocShellCID.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsNetUtil.h"
  4849: #include "nsMimeTypes.h"
 13583: #include "nsStyleUtil.h"
 38026: #include "nsGUIEvent.h"
 62136: #include "nsUnicharUtils.h"
     1: 
     1: // Concrete classes
     1: #include "nsFrameLoader.h"
     1: 
     1: #include "nsObjectLoadingContent.h"
 14228: #include "mozAutoDocUpdate.h"
 41208: #include "nsIContentSecurityPolicy.h"
 41208: #include "nsIChannelPolicy.h"
 41208: #include "nsChannelPolicy.h"
 74131: #include "mozilla/dom/Element.h"
 88104: #include "sampler.h"
 89114: #include "nsObjectFrame.h"
 89114: #include "nsDOMClassInfo.h"
 89114: 
 89114: #include "nsWidgetsCID.h"
 89114: #include "nsContentCID.h"
 89114: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
     1: 
     1: #ifdef PR_LOGGING
     1: static PRLogModuleInfo* gObjectLog = PR_NewLogModule("objlc");
     1: #endif
     1: 
     1: #define LOG(args) PR_LOG(gObjectLog, PR_LOG_DEBUG, args)
     1: #define LOG_ENABLED() PR_LOG_TEST(gObjectLog, PR_LOG_DEBUG)
     1: 
108002: static bool
108002: InActiveDocument(nsIContent *aContent)
108002: {
108002:   if (!aContent->IsInDoc()) {
108002:     return false;
108002:   }
108002:   nsIDocument *doc = aContent->OwnerDoc();
108002:   return (doc && doc->IsActive());
108002: }
108002: 
107578: ///
107578: /// Runnables and helper classes
107578: ///
107578: 
     1: class nsAsyncInstantiateEvent : public nsRunnable {
     1: public:
 89114:   nsAsyncInstantiateEvent(nsObjectLoadingContent *aContent)
107578:   : mContent(aContent) {}
     1: 
107578:   ~nsAsyncInstantiateEvent() {}
     1: 
     1:   NS_IMETHOD Run();
107578: 
107578: private:
107578:   nsCOMPtr<nsIObjectLoadingContent> mContent;
     1: };
     1: 
     1: NS_IMETHODIMP
     1: nsAsyncInstantiateEvent::Run()
     1: {
107578:   nsObjectLoadingContent *objLC =
107578:     static_cast<nsObjectLoadingContent *>(mContent.get());
107578: 
 89114:   // do nothing if we've been revoked
107578:   if (objLC->mPendingInstantiateEvent != this) {
     1:     return NS_OK;
 89114:   }
107578:   objLC->mPendingInstantiateEvent = nullptr;
     1: 
107578:   return objLC->SyncStartPluginInstance();
 77476: }
 77476: 
 89114: // Checks to see if the content for a plugin instance has a parent.
 89114: // The plugin instance is stopped if there is no parent.
 89114: class InDocCheckEvent : public nsRunnable {
 89114: public:
107578:   InDocCheckEvent(nsObjectLoadingContent *aContent)
107578:   : mContent(aContent) {}
 89114: 
107578:   ~InDocCheckEvent() {}
     1: 
 89114:   NS_IMETHOD Run();
107578: 
107578: private:
107578:   nsCOMPtr<nsIObjectLoadingContent> mContent;
 89114: };
 89114: 
 89114: NS_IMETHODIMP
 89114: InDocCheckEvent::Run()
 89114: {
107578:   nsObjectLoadingContent *objLC =
107578:     static_cast<nsObjectLoadingContent *>(mContent.get());
107578: 
107578:   nsCOMPtr<nsIContent> content =
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent *>(objLC));
107578: 
108002:   if (!InActiveDocument(content)) {
107578:     nsObjectLoadingContent *objLC =
107578:       static_cast<nsObjectLoadingContent *>(mContent.get());
107579:     objLC->UnloadObject();
 89114:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /**
  3464:  * A task for firing PluginNotFound and PluginBlocklisted DOM Events.
     1:  */
  3464: class nsPluginErrorEvent : public nsRunnable {
     1: public:
107579:   nsPluginErrorEvent(nsIContent* aContent,
107579:                      nsObjectLoadingContent::FallbackType aFallbackType)
  3464:     : mContent(aContent),
107579:       mFallbackType(aFallbackType) {}
     1: 
  3464:   ~nsPluginErrorEvent() {}
     1: 
     1:   NS_IMETHOD Run();
107579: 
107579: private:
107579:   nsCOMPtr<nsIContent> mContent;
107579:   nsObjectLoadingContent::FallbackType mFallbackType;
     1: };
     1: 
     1: NS_IMETHODIMP
  3464: nsPluginErrorEvent::Run()
     1: {
 19014:   nsString type;
107579:   switch (mFallbackType) {
107579:     case nsObjectLoadingContent::eFallbackVulnerableUpdatable:
107579:       type = NS_LITERAL_STRING("PluginVulnerableUpdatable");
107579:       break;
107579:     case nsObjectLoadingContent::eFallbackVulnerableNoUpdate:
107579:       type = NS_LITERAL_STRING("PluginVulnerableNoUpdate");
107579:       break;
107579:     case nsObjectLoadingContent::eFallbackClickToPlay:
106488:       type = NS_LITERAL_STRING("PluginClickToPlay");
106488:       break;
109451:     case nsObjectLoadingContent::eFallbackPlayPreview:
109451:       type = NS_LITERAL_STRING("PluginPlayPreview");
109451:       break;
107579:     case nsObjectLoadingContent::eFallbackUnsupported:
 19014:       type = NS_LITERAL_STRING("PluginNotFound");
 19014:       break;
107579:     case nsObjectLoadingContent::eFallbackDisabled:
 19014:       type = NS_LITERAL_STRING("PluginDisabled");
 19014:       break;
107579:     case nsObjectLoadingContent::eFallbackBlocklisted:
 19014:       type = NS_LITERAL_STRING("PluginBlocklisted");
 19014:       break;
107579:     case nsObjectLoadingContent::eFallbackOutdated:
 33384:       type = NS_LITERAL_STRING("PluginOutdated");
 33384:       break;
 19014:     default:
 19014:       return NS_OK;
 19014:   }
107579:   LOG(("OBJLC [%p]: nsPluginErrorEvent firing '%s'",
107579:        mContent.get(), NS_ConvertUTF16toUTF8(type).get()));
  3464:   nsContentUtils::DispatchTrustedEvent(mContent->GetDocument(), mContent,
 80486:                                        type, true, true);
  3464: 
     1:   return NS_OK;
     1: }
     1: 
 38026: /**
 38026:  * A task for firing PluginCrashed DOM Events.
 38026:  */
 38026: class nsPluginCrashedEvent : public nsRunnable {
 38026: public:
 38026:   nsCOMPtr<nsIContent> mContent;
 39794:   nsString mPluginDumpID;
 39794:   nsString mBrowserDumpID;
 38026:   nsString mPluginName;
 40610:   nsString mPluginFilename;
 79445:   bool mSubmittedCrashReport;
 38026: 
 38026:   nsPluginCrashedEvent(nsIContent* aContent,
 39794:                        const nsAString& aPluginDumpID,
 39794:                        const nsAString& aBrowserDumpID,
 38026:                        const nsAString& aPluginName,
 40610:                        const nsAString& aPluginFilename,
 79445:                        bool submittedCrashReport)
 38026:     : mContent(aContent),
 39794:       mPluginDumpID(aPluginDumpID),
 39794:       mBrowserDumpID(aBrowserDumpID),
 38026:       mPluginName(aPluginName),
 40610:       mPluginFilename(aPluginFilename),
 38026:       mSubmittedCrashReport(submittedCrashReport)
 38026:   {}
 38026: 
 38026:   ~nsPluginCrashedEvent() {}
 38026: 
 38026:   NS_IMETHOD Run();
 38026: };
 38026: 
 38026: NS_IMETHODIMP
 38026: nsPluginCrashedEvent::Run()
 38026: {
107578:   LOG(("OBJLC [%p]: Firing plugin crashed event\n",
 38026:        mContent.get()));
 38026: 
 70359:   nsCOMPtr<nsIDOMDocument> domDoc =
 38026:     do_QueryInterface(mContent->GetDocument());
 70359:   if (!domDoc) {
 38026:     NS_WARNING("Couldn't get document for PluginCrashed event!");
 38026:     return NS_OK;
 38026:   }
 38026: 
 38026:   nsCOMPtr<nsIDOMEvent> event;
 70359:   domDoc->CreateEvent(NS_LITERAL_STRING("datacontainerevents"),
 38026:                       getter_AddRefs(event));
 38026:   nsCOMPtr<nsIDOMDataContainerEvent> containerEvent(do_QueryInterface(event));
101616:   if (!containerEvent) {
 38026:     NS_WARNING("Couldn't QI event for PluginCrashed event!");
 38026:     return NS_OK;
 38026:   }
 38026: 
 80486:   event->InitEvent(NS_LITERAL_STRING("PluginCrashed"), true, true);
101616:   event->SetTrusted(true);
101616:   event->GetInternalNSEvent()->flags |= NS_EVENT_FLAG_ONLY_CHROME_DISPATCH;
 38026: 
 38026:   nsCOMPtr<nsIWritableVariant> variant;
 38026: 
 39794:   // add a "pluginDumpID" property to this event
 39501:   variant = do_CreateInstance("@mozilla.org/variant;1");
 39501:   if (!variant) {
 39794:     NS_WARNING("Couldn't create pluginDumpID variant for PluginCrashed event!");
 39501:     return NS_OK;
 39501:   }
 39794:   variant->SetAsAString(mPluginDumpID);
 39794:   containerEvent->SetData(NS_LITERAL_STRING("pluginDumpID"), variant);
 39794: 
 39794:   // add a "browserDumpID" property to this event
 39794:   variant = do_CreateInstance("@mozilla.org/variant;1");
 39794:   if (!variant) {
 39794:     NS_WARNING("Couldn't create browserDumpID variant for PluginCrashed event!");
 39794:     return NS_OK;
 39794:   }
 39794:   variant->SetAsAString(mBrowserDumpID);
 39794:   containerEvent->SetData(NS_LITERAL_STRING("browserDumpID"), variant);
 39501: 
 38026:   // add a "pluginName" property to this event
 38026:   variant = do_CreateInstance("@mozilla.org/variant;1");
 38026:   if (!variant) {
 38026:     NS_WARNING("Couldn't create pluginName variant for PluginCrashed event!");
 38026:     return NS_OK;
 38026:   }
 38026:   variant->SetAsAString(mPluginName);
 38026:   containerEvent->SetData(NS_LITERAL_STRING("pluginName"), variant);
 38026: 
 40610:   // add a "pluginFilename" property to this event
 40610:   variant = do_CreateInstance("@mozilla.org/variant;1");
 40610:   if (!variant) {
 40610:     NS_WARNING("Couldn't create pluginFilename variant for PluginCrashed event!");
 40610:     return NS_OK;
 40610:   }
 40610:   variant->SetAsAString(mPluginFilename);
 40610:   containerEvent->SetData(NS_LITERAL_STRING("pluginFilename"), variant);
 40610: 
 38026:   // add a "submittedCrashReport" property to this event
 38026:   variant = do_CreateInstance("@mozilla.org/variant;1");
 38026:   if (!variant) {
 38026:     NS_WARNING("Couldn't create crashSubmit variant for PluginCrashed event!");
 38026:     return NS_OK;
 38026:   }
 38026:   variant->SetAsBool(mSubmittedCrashReport);
 38026:   containerEvent->SetData(NS_LITERAL_STRING("submittedCrashReport"), variant);
 38026: 
106838:   nsEventDispatcher::DispatchDOMEvent(mContent, nullptr, event, nullptr, nullptr);
 38026:   return NS_OK;
 38026: }
 38026: 
 89114: class nsStopPluginRunnable : public nsRunnable, public nsITimerCallback
 89114: {
 89114: public:
 89114:   NS_DECL_ISUPPORTS_INHERITED
 89114: 
 99505:   nsStopPluginRunnable(nsPluginInstanceOwner* aInstanceOwner,
 99505:                        nsObjectLoadingContent* aContent)
 89114:     : mInstanceOwner(aInstanceOwner)
 99505:     , mContent(aContent)
 89114:   {
 89114:     NS_ASSERTION(aInstanceOwner, "need an owner");
 99505:     NS_ASSERTION(aContent, "need a nsObjectLoadingContent");
 89114:   }
 89114: 
 89114:   // nsRunnable
 89114:   NS_IMETHOD Run();
 89114: 
 89114:   // nsITimerCallback
 89114:   NS_IMETHOD Notify(nsITimer *timer);
 89114: 
 89114: private:
 89114:   nsCOMPtr<nsITimer> mTimer;
 89114:   nsRefPtr<nsPluginInstanceOwner> mInstanceOwner;
 99509:   nsCOMPtr<nsIObjectLoadingContent> mContent;
 89114: };
 89114: 
 89114: NS_IMPL_ISUPPORTS_INHERITED1(nsStopPluginRunnable, nsRunnable, nsITimerCallback)
 89114: 
 89114: NS_IMETHODIMP
 89114: nsStopPluginRunnable::Notify(nsITimer *aTimer)
 89114: {
 89114:   return Run();
 89114: }
 89114: 
 89114: NS_IMETHODIMP
 89114: nsStopPluginRunnable::Run()
 89114: {
 89114:   // InitWithCallback calls Release before AddRef so we need to hold a
 89114:   // strong ref on 'this' since we fall through to this scope if it fails.
 89114:   nsCOMPtr<nsITimerCallback> kungFuDeathGrip = this;
 89114:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
 89114:   if (appShell) {
108991:     uint32_t currentLevel = 0;
 89114:     appShell->GetEventloopNestingLevel(&currentLevel);
 89114:     if (currentLevel > mInstanceOwner->GetLastEventloopNestingLevel()) {
 89114:       if (!mTimer)
 89114:         mTimer = do_CreateInstance("@mozilla.org/timer;1");
 89114:       if (mTimer) {
 89114:         // Fire 100ms timer to try to tear down this plugin as quickly as
 89114:         // possible once the nesting level comes back down.
107578:         nsresult rv = mTimer->InitWithCallback(this, 100,
107578:                                                nsITimer::TYPE_ONE_SHOT);
 89114:         if (NS_SUCCEEDED(rv)) {
 89114:           return rv;
 89114:         }
 89114:       }
 89114:       NS_ERROR("Failed to setup a timer to stop the plugin later (at a safe "
 89114:                "time). Stopping the plugin now, this might crash.");
 89114:     }
 89114:   }
 89114: 
106838:   mTimer = nullptr;
 89114: 
 99509:   static_cast<nsObjectLoadingContent*>(mContent.get())->
 99509:     DoStopPlugin(mInstanceOwner, false, true);
 89114: 
 89114:   return NS_OK;
 89114: }
 89114: 
107578: // You can't take the address of bitfield members, so we have two separate
107578: // classes for these :-/
107578: 
107578: // Sets a object's mInstantiating bit to false when destroyed
     1: class AutoSetInstantiatingToFalse {
     1: public:
107578:   AutoSetInstantiatingToFalse(nsObjectLoadingContent *aContent)
107578:     : mContent(aContent) {}
 80486:   ~AutoSetInstantiatingToFalse() { mContent->mInstantiating = false; }
     1: private:
     1:   nsObjectLoadingContent* mContent;
     1: };
     1: 
107578: // Sets a object's mInstantiating bit to false when destroyed
107578: class AutoSetLoadingToFalse {
107578: public:
107578:   AutoSetLoadingToFalse(nsObjectLoadingContent *aContent)
107578:     : mContent(aContent) {}
107578:   ~AutoSetLoadingToFalse() { mContent->mIsLoading = false; }
107578: private:
107578:   nsObjectLoadingContent* mContent;
107578: };
107578: 
107578: ///
107578: /// Helper functions
107578: ///
107578: 
107578: static bool
107578: IsSuccessfulRequest(nsIRequest* aRequest)
107578: {
107578:   nsresult status;
107578:   nsresult rv = aRequest->GetStatus(&status);
107578:   if (NS_FAILED(rv) || NS_FAILED(status)) {
107578:     return false;
107578:   }
107578: 
107578:   // This may still be an error page or somesuch
107578:   nsCOMPtr<nsIHttpChannel> httpChan(do_QueryInterface(aRequest));
107578:   if (httpChan) {
107578:     bool success;
107578:     rv = httpChan->GetRequestSucceeded(&success);
107578:     if (NS_FAILED(rv) || !success) {
107578:       return false;
107578:     }
107578:   }
107578: 
107578:   // Otherwise, the request is successful
107578:   return true;
107578: }
107578: 
107578: static bool
107578: CanHandleURI(nsIURI* aURI)
107578: {
110974:   nsAutoCString scheme;
107578:   if (NS_FAILED(aURI->GetScheme(scheme))) {
107578:     return false;
107578:   }
107578: 
107578:   nsIIOService* ios = nsContentUtils::GetIOService();
107578:   if (!ios)
107578:     return false;
107578: 
107578:   nsCOMPtr<nsIProtocolHandler> handler;
107578:   ios->GetProtocolHandler(scheme.get(), getter_AddRefs(handler));
107578:   if (!handler) {
107578:     return false;
107578:   }
107578: 
107578:   nsCOMPtr<nsIExternalProtocolHandler> extHandler =
107578:     do_QueryInterface(handler);
107578:   // We can handle this URI if its protocol handler is not the external one
107578:   return extHandler == nullptr;
107578: }
107578: 
107578: // Helper for tedious URI equality syntax when one or both arguments may be
107578: // null and URIEquals(null, null) should be true
107578: static bool inline
107578: URIEquals(nsIURI *a, nsIURI *b)
107578: {
107578:   bool equal;
107578:   return (!a && !b) || (a && b && NS_SUCCEEDED(a->Equals(b, &equal)) && equal);
107578: }
107578: 
 79445: static bool
     1: IsSupportedImage(const nsCString& aMimeType)
     1: {
115984:   return imgLoader::SupportImageWithMimeType(aMimeType.get());
     1: }
     1: 
107578: static void
107578: GetExtensionFromURI(nsIURI* uri, nsCString& ext)
106488: {
107578:   nsCOMPtr<nsIURL> url(do_QueryInterface(uri));
107578:   if (url) {
107578:     url->GetFileExtension(ext);
107578:   } else {
107578:     nsCString spec;
107578:     uri->GetSpec(spec);
107578: 
108991:     int32_t offset = spec.RFindChar('.');
107578:     if (offset != kNotFound) {
107578:       ext = Substring(spec, offset + 1, spec.Length());
107578:     }
107578:   }
107578: }
107578: 
107578: /**
107578:  * Checks whether a plugin exists and is enabled for the extension
107578:  * in the given URI. The MIME type is returned in the mimeType out parameter.
107578:  */
107579: bool
107579: IsPluginEnabledByExtension(nsIURI* uri, nsCString& mimeType)
107578: {
110974:   nsAutoCString ext;
107578:   GetExtensionFromURI(uri, ext);
107578: 
107578:   if (ext.IsEmpty()) {
107578:     return false;
107578:   }
107578: 
107578:   nsRefPtr<nsPluginHost> pluginHost =
107578:     already_AddRefed<nsPluginHost>(nsPluginHost::GetInst());
107578: 
106488:   if (!pluginHost) {
107578:     NS_NOTREACHED("No pluginhost");
107578:     return false;
107578:   }
107578: 
107578:   const char* typeFromExt;
107579:   nsresult rv = pluginHost->IsPluginEnabledForExtension(ext.get(), typeFromExt);
107579:   if (NS_SUCCEEDED(rv)) {
107578:     mimeType = typeFromExt;
107579:     return true;
107578:   }
107579:   return false;
107578: }
107578: 
107578: nsresult
107579: IsPluginEnabledForType(const nsCString& aMIMEType)
107578: {
107578:   nsRefPtr<nsPluginHost> pluginHost =
107578:     already_AddRefed<nsPluginHost>(nsPluginHost::GetInst());
107578: 
107578:   if (!pluginHost) {
107578:     NS_NOTREACHED("No pluginhost");
108291:     return NS_ERROR_FAILURE;
106488:   }
106488: 
106488:   nsresult rv = pluginHost->IsPluginEnabledForType(aMIMEType.get());
106488: 
106488:   // Check to see if the plugin is disabled before deciding if it
106488:   // should be in the "click to play" state, since we only want to
106488:   // display "click to play" UI for enabled plugins.
106488:   if (NS_FAILED(rv)) {
106488:     return rv;
106488:   }
106488: 
107579:   return NS_OK;
106488: }
106488: 
107579: ///
107579: /// Member Functions
107579: ///
106488: 
107578: bool
107578: nsObjectLoadingContent::IsSupportedDocument(const nsCString& aMimeType)
     1: {
107578:   nsCOMPtr<nsIContent> thisContent =
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
107578:   NS_ASSERTION(thisContent, "must be a content");
106457: 
107578:   nsCOMPtr<nsIWebNavigationInfo> info(
108003:     do_GetService(NS_WEBNAVIGATION_INFO_CONTRACTID));
108003:   if (!info) {
108003:     return false;
108003:   }
108003: 
107578:   nsCOMPtr<nsIWebNavigation> webNav;
107578:   nsIDocument* currentDoc = thisContent->GetCurrentDoc();
107578:   if (currentDoc) {
107578:     webNav = do_GetInterface(currentDoc->GetScriptGlobalObject());
106457:   }
108003:   
108991:   uint32_t supported;
108003:   nsresult rv = info->IsTypeSupported(aMimeType, webNav, &supported);
108003: 
108003:   if (NS_FAILED(rv)) {
108003:     return false;
106457:   }
106457: 
108003:   if (supported != nsIWebNavigationInfo::UNSUPPORTED) {
108003:     // Don't want to support plugins as documents
108003:     return supported != nsIWebNavigationInfo::PLUGIN;
108003:   }
108003: 
107578:   // Try a stream converter
107578:   // NOTE: We treat any type we can convert from as a supported type. If a
107578:   // type is not actually supported, the URI loader will detect that and
107578:   // return an error, and we'll fallback.
107578:   nsCOMPtr<nsIStreamConverterService> convServ =
107578:     do_GetService("@mozilla.org/streamConverters;1");
107578:   bool canConvert = false;
107578:   if (convServ) {
107578:     rv = convServ->CanConvert(aMimeType.get(), "*/*", &canConvert);
107578:   }
107578:   return NS_SUCCEEDED(rv) && canConvert;
107578: }
106457: 
106457: nsresult
107578: nsObjectLoadingContent::BindToTree(nsIDocument* aDocument,
108321:                                    nsIContent* aParent,
108321:                                    nsIContent* aBindingParent,
108321:                                    bool aCompileEventHandlers)
 94270: {
108321:   nsImageLoadingContent::BindToTree(aDocument, aParent, aBindingParent,
108321:                                     aCompileEventHandlers);
108321: 
 94270:   if (aDocument) {
 94270:     return aDocument->AddPlugin(this);
 94270:   }
 94270:   return NS_OK;
 94270: }
 94270: 
 94270: void
108321: nsObjectLoadingContent::UnbindFromTree(bool aDeep, bool aNullParent)
 94270: {
108321:   nsImageLoadingContent::UnbindFromTree(aDeep, aNullParent);
108321: 
107578:   nsCOMPtr<nsIContent> thisContent =
107578:     do_QueryInterface(static_cast<nsIObjectLoadingContent*>(this));
 94270:   MOZ_ASSERT(thisContent);
 94270:   nsIDocument* ownerDoc = thisContent->OwnerDoc();
 94270:   ownerDoc->RemovePlugin(this);
107578: 
108002:   if (mType == eType_Plugin && mInstanceOwner) {
107578:     // we'll let the plugin continue to run at least until we get back to
107578:     // the event loop. If we get back to the event loop and the node
107578:     // has still not been added back to the document then we tear down the
107578:     // plugin
107578:     nsCOMPtr<nsIRunnable> event = new InDocCheckEvent(this);
107578: 
107578:     nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
107578:     if (appShell) {
107578:       appShell->RunInStableState(event);
107578:     }
108327:   } else if (mType != eType_Image) {
108327:     // nsImageLoadingContent handles the image case.
108002:     // Reset state and clear pending events
107578:     /// XXX(johns): The implementation for GenericFrame notes that ideally we
107578:     ///             would keep the docshell around, but trash the frameloader
107579:     UnloadObject();
107578:   }
107578: 
 94270: }
 94270: 
     1: nsObjectLoadingContent::nsObjectLoadingContent()
106838:   : mPendingInstantiateEvent(nullptr)
106838:   , mChannel(nullptr)
     1:   , mType(eType_Loading)
107579:   , mFallbackType(eFallbackAlternate)
107578:   , mChannelLoaded(false)
 80486:   , mInstantiating(false)
 80486:   , mNetworkCreated(true)
107578:   , mActivated(false)
109451:   , mPlayPreviewCanceled(false)
 99505:   , mIsStopping(false)
107578:   , mIsLoading(false)
107579:   , mSrcStreamLoading(false) {}
     1: 
     1: nsObjectLoadingContent::~nsObjectLoadingContent()
     1: {
107578:   // Should have been unbound from the tree at this point, and InDocCheckEvent
107578:   // keeps us alive
     1:   if (mFrameLoader) {
107578:     NS_NOTREACHED("Should not be tearing down frame loaders at this point");
     1:     mFrameLoader->Destroy();
     1:   }
107578:   if (mInstanceOwner) {
107578:     // This is especially bad as delayed stop will try to hold on to this
107578:     // object...
107578:     NS_NOTREACHED("Should not be tearing down a plugin at this point!");
107578:     StopPluginInstance();
107578:   }
107578:   DestroyImageLoadingContent();
     1: }
     1: 
 89114: nsresult
107578: nsObjectLoadingContent::InstantiatePluginInstance()
 89114: {
111606:   if (mInstanceOwner || mType != eType_Plugin || mIsLoading || mInstantiating) {
107578:     return NS_OK;
107578:   }
107578:   
 89114:   mInstantiating = true;
 89114:   AutoSetInstantiatingToFalse autoInstantiating(this);
 89114: 
111606:   nsCOMPtr<nsIContent> thisContent =
111606:     do_QueryInterface(static_cast<nsIImageLoadingContent *>(this));
111606: 
111606:   nsIDocument* doc = thisContent->GetCurrentDoc();
111606:   if (!doc || !InActiveDocument(thisContent)) {
111606:     NS_ERROR("Shouldn't be calling "
111606:              "InstantiatePluginInstance without an active document");
111606:     return NS_ERROR_FAILURE;
111606:   }
111606: 
 89114:   // Instantiating an instance can result in script execution, which
 89114:   // can destroy this DOM object. Don't allow that for the scope
 89114:   // of this method.
 89114:   nsCOMPtr<nsIObjectLoadingContent> kungFuDeathGrip = this;
 89114: 
111606:   // Flush layout so that the frame is created if possible and the plugin is
111606:   // initialized with the latest information.
111606:   doc->FlushPendingNotifications(Flush_Layout);
111606:   
111606:   if (!thisContent->GetPrimaryFrame()) {
111606:     LOG(("OBJLC [%p]: Not instantiating plugin with no frame", this));
111606:     return NS_OK;
111366:   }
111366:   
 89114:   nsresult rv = NS_ERROR_FAILURE;
107578:   nsRefPtr<nsPluginHost> pluginHost =
107578:     already_AddRefed<nsPluginHost>(nsPluginHost::GetInst());
107578: 
107578:   if (!pluginHost) {
107578:     NS_NOTREACHED("No pluginhost");
108291:     return NS_ERROR_FAILURE;
106488:   }
106457: 
 89114:   // If you add early return(s), be sure to balance this call to
 89114:   // appShell->SuspendNative() with additional call(s) to
 89114:   // appShell->ReturnNative().
 89114:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
 89114:   if (appShell) {
 89114:     appShell->SuspendNative();
 89114:   }
 89114: 
 89114:   nsCOMPtr<nsIPluginDocument> pDoc(do_QueryInterface(doc));
 89114:   bool fullPageMode = false;
 89114:   if (pDoc) {
 89114:     pDoc->GetWillHandleInstantiation(&fullPageMode);
 89114:   }
 89114: 
 89114:   if (fullPageMode) {
 89114:     nsCOMPtr<nsIStreamListener> stream;
107578:     rv = pluginHost->InstantiateFullPagePluginInstance(mContentType.get(),
107578:                                                        mURI.get(), this,
107578:                                                        getter_AddRefs(mInstanceOwner),
107578:                                                        getter_AddRefs(stream));
 89114:     if (NS_SUCCEEDED(rv)) {
 89114:       pDoc->SetStreamListener(stream);
 89114:     }
 89114:   } else {
107578:     rv = pluginHost->InstantiateEmbeddedPluginInstance(mContentType.get(),
107578:                                                        mURI.get(), this,
 95465:                                                        getter_AddRefs(mInstanceOwner));
 89114:   }
 89114: 
 89114:   if (appShell) {
 89114:     appShell->ResumeNative();
 89114:   }
 89114: 
 89114:   if (NS_FAILED(rv)) {
 89114:     return rv;
 89114:   }
 89114: 
 89114:   // Set up scripting interfaces.
 89114:   NotifyContentObjectWrapper();
 89114: 
 89114:   nsRefPtr<nsNPAPIPluginInstance> pluginInstance;
 89114:   GetPluginInstance(getter_AddRefs(pluginInstance));
 89114:   if (pluginInstance) {
 89114:     nsCOMPtr<nsIPluginTag> pluginTag;
107578:     pluginHost->GetPluginTagForInstance(pluginInstance,
107578:                                         getter_AddRefs(pluginTag));
 89114: 
 89114:     nsCOMPtr<nsIBlocklistService> blocklist =
 89114:       do_GetService("@mozilla.org/extensions/blocklist;1");
 89114:     if (blocklist) {
108991:       uint32_t blockState = nsIBlocklistService::STATE_NOT_BLOCKED;
 89114:       blocklist->GetPluginBlocklistState(pluginTag, EmptyString(),
 89114:                                          EmptyString(), &blockState);
 89114:       if (blockState == nsIBlocklistService::STATE_OUTDATED)
107579:         FirePluginError(eFallbackOutdated);
 89114:     }
 89114:   }
 89114: 
 89114:   return NS_OK;
 89114: }
 89114: 
 89114: void
 89114: nsObjectLoadingContent::NotifyOwnerDocumentActivityChanged()
 89114: {
 89114:   if (!mInstanceOwner) {
 89114:     return;
 89114:   }
 89114: 
107578:   nsCOMPtr<nsIContent> thisContent =
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
 89114:   nsIDocument* ownerDoc = thisContent->OwnerDoc();
 89114:   if (!ownerDoc->IsActive()) {
 89114:     StopPluginInstance();
 89114:   }
 89114: }
 89114: 
     1: // nsIRequestObserver
     1: NS_IMETHODIMP
 13648: nsObjectLoadingContent::OnStartRequest(nsIRequest *aRequest,
 13648:                                        nsISupports *aContext)
     1: {
107578:   /// This must call LoadObject, even upon failure, to allow it to either
107578:   /// proceed with the load, or trigger fallback content.
107578: 
 88104:   SAMPLE_LABEL("nsObjectLoadingContent", "OnStartRequest");
 89114: 
107578:   LOG(("OBJLC [%p]: Channel OnStartRequest", this));
107578: 
 81385:   if (aRequest != mChannel || !aRequest) {
107578:     // happens when a new load starts before the previous one got here
     1:     return NS_BINDING_ABORTED;
     1:   }
     1: 
107578:   NS_ASSERTION(!mChannelLoaded, "mChannelLoaded set already?");
107578:   NS_ASSERTION(!mFinalListener, "mFinalListener exists already?");
     1: 
107578:   mChannelLoaded = true;
     1: 
     1:   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
     1:   NS_ASSERTION(chan, "Why is our request not a channel?");
     1: 
107578:   nsCOMPtr<nsIURI> uri;
     1: 
107578:   if (IsSuccessfulRequest(aRequest)) {
107578:     chan->GetURI(getter_AddRefs(uri));
  4849:   }
  4849: 
 96820:   if (!uri) {
107578:     LOG(("OBJLC [%p]: OnStartRequest: Request failed\n", this));
107578:     // If the request fails, we still call LoadObject() to handle fallback
107578:     // content and notifying of failure. (mChannelLoaded && !mChannel) indicates
107578:     // the bad state.
107578:     mChannel = nullptr;
107578:     LoadObject(true, false);
 96820:     return NS_ERROR_FAILURE;
 96820:   }
 13648: 
107578:   return LoadObject(true, false, aRequest);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsObjectLoadingContent::OnStopRequest(nsIRequest *aRequest,
     1:                                       nsISupports *aContext,
     1:                                       nsresult aStatusCode)
     1: {
 81385:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
 81385: 
     1:   if (aRequest != mChannel) {
     1:     return NS_BINDING_ABORTED;
     1:   }
     1: 
106838:   mChannel = nullptr;
     1: 
     1:   if (mFinalListener) {
118862:     // This may re-enter in the case of plugin listeners
118862:     nsCOMPtr<nsIStreamListener> listenerGrip(mFinalListener);
106838:     mFinalListener = nullptr;
118862:     listenerGrip->OnStopRequest(aRequest, aContext, aStatusCode);
     1:   }
     1: 
     1:   // Return value doesn't matter
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // nsIStreamListener
     1: NS_IMETHODIMP
 81385: nsObjectLoadingContent::OnDataAvailable(nsIRequest *aRequest,
 81385:                                         nsISupports *aContext,
 81385:                                         nsIInputStream *aInputStream,
111234:                                         uint64_t aOffset, uint32_t aCount)
     1: {
 81385:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
 81385: 
     1:   if (aRequest != mChannel) {
     1:     return NS_BINDING_ABORTED;
     1:   }
     1: 
     1:   if (mFinalListener) {
118862:     // This may re-enter in the case of plugin listeners
118862:     nsCOMPtr<nsIStreamListener> listenerGrip(mFinalListener);
118862:     return listenerGrip->OnDataAvailable(aRequest, aContext, aInputStream,
107578:                                          aOffset, aCount);
     1:   }
     1: 
107578:   // We shouldn't have a connected channel with no final listener
107578:   NS_NOTREACHED("Got data for channel with no connected final listener");
107578:   mChannel = nullptr;
107578: 
     1:   return NS_ERROR_UNEXPECTED;
     1: }
     1: 
     1: // nsIFrameLoaderOwner
     1: NS_IMETHODIMP
     1: nsObjectLoadingContent::GetFrameLoader(nsIFrameLoader** aFrameLoader)
     1: {
107578:   NS_IF_ADDREF(*aFrameLoader = mFrameLoader);
     1:   return NS_OK;
     1: }
     1: 
 34076: NS_IMETHODIMP_(already_AddRefed<nsFrameLoader>)
 34076: nsObjectLoadingContent::GetFrameLoader()
 34076: {
 34076:   nsFrameLoader* loader = mFrameLoader;
 34076:   NS_IF_ADDREF(loader);
 34076:   return loader;
 34076: }
 34076: 
 16549: NS_IMETHODIMP
 16549: nsObjectLoadingContent::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherLoader)
 16549: {
 16549:   return NS_ERROR_NOT_IMPLEMENTED;
 16549: }
 16549: 
     1: NS_IMETHODIMP
     1: nsObjectLoadingContent::GetActualType(nsACString& aType)
     1: {
     1:   aType = mContentType;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsObjectLoadingContent::GetDisplayedType(uint32_t* aType)
     1: {
     1:   *aType = mType;
     1:   return NS_OK;
     1: }
     1: 
 77476: NS_IMETHODIMP
 89114: nsObjectLoadingContent::HasNewFrame(nsIObjectFrame* aFrame)
 77476: {
107578:   if (mType == eType_Plugin) {
 89114:     if (!mInstanceOwner) {
107578:       // We have successfully set ourselves up in LoadObject, but not spawned an
107578:       // instance due to a lack of a frame.
 89114:       AsyncStartPluginInstance();
 77476:       return NS_OK;
 77476:     }
 77476: 
 89114:     // Disconnect any existing frame
 89114:     DisconnectFrame();
 77476: 
 89114:     // Set up relationship between instance owner and frame.
 89114:     nsObjectFrame *objFrame = static_cast<nsObjectFrame*>(aFrame);
 89114:     mInstanceOwner->SetFrame(objFrame);
 77476: 
 89114:     // Set up new frame to draw.
 89114:     objFrame->FixupWindow(objFrame->GetContentRectRelativeToSelf().Size());
115305:     objFrame->InvalidateFrame();
107578:   }
 15571:   return NS_OK;
 15571: }
 15571: 
 89114: NS_IMETHODIMP
 89114: nsObjectLoadingContent::DisconnectFrame()
 89114: {
 89114:   if (mInstanceOwner) {
106838:     mInstanceOwner->SetFrame(nullptr);
 77476:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 70007: nsObjectLoadingContent::GetPluginInstance(nsNPAPIPluginInstance** aInstance)
 13098: {
106838:   *aInstance = nullptr;
 13098: 
 89114:   if (!mInstanceOwner) {
 13098:     return NS_OK;
 13098:   }
 13098: 
 89114:   return mInstanceOwner->GetInstance(aInstance);
 13098: }
 13098: 
 13098: NS_IMETHODIMP
     1: nsObjectLoadingContent::GetContentTypeForMIMEType(const nsACString& aMIMEType,
108991:                                                   uint32_t* aType)
     1: {
     1:   *aType = GetTypeOfContent(PromiseFlatCString(aMIMEType));
     1:   return NS_OK;
     1: }
     1: 
     1: // nsIInterfaceRequestor
     1: NS_IMETHODIMP
     1: nsObjectLoadingContent::GetInterface(const nsIID & aIID, void **aResult)
     1: {
     1:   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
     1:     nsIChannelEventSink* sink = this;
     1:     *aResult = sink;
     1:     NS_ADDREF(sink);
     1:     return NS_OK;
     1:   }
     1:   return NS_NOINTERFACE;
     1: }
     1: 
     1: // nsIChannelEventSink
     1: NS_IMETHODIMP
 48889: nsObjectLoadingContent::AsyncOnChannelRedirect(nsIChannel *aOldChannel,
     1:                                                nsIChannel *aNewChannel,
108991:                                                uint32_t aFlags,
 48889:                                                nsIAsyncVerifyRedirectCallback *cb)
     1: {
 63181:   // If we're already busy with a new load, or have no load at all,
 63181:   // cancel the redirect.
 63181:   if (!mChannel || aOldChannel != mChannel) {
     1:     return NS_BINDING_ABORTED;
     1:   }
     1: 
     1:   mChannel = aNewChannel;
 48889:   cb->OnRedirectVerifyCallback(NS_OK);
     1:   return NS_OK;
     1: }
     1: 
     1: // <public>
 56168: nsEventStates
     1: nsObjectLoadingContent::ObjectState() const
     1: {
     1:   switch (mType) {
     1:     case eType_Loading:
     1:       return NS_EVENT_STATE_LOADING;
     1:     case eType_Image:
     1:       return ImageState();
     1:     case eType_Plugin:
     1:     case eType_Document:
     1:       // These are OK. If documents start to load successfully, they display
     1:       // something, and are thus not broken in this sense. The same goes for
     1:       // plugins.
 56168:       return nsEventStates();
     1:     case eType_Null:
107579:       switch (mFallbackType) {
107579:         case eFallbackSuppressed:
     1:           return NS_EVENT_STATE_SUPPRESSED;
107579:         case eFallbackUserDisabled:
     1:           return NS_EVENT_STATE_USERDISABLED;
107579:         case eFallbackClickToPlay:
 80300:           return NS_EVENT_STATE_TYPE_CLICK_TO_PLAY;
109451:         case eFallbackPlayPreview:
109451:           return NS_EVENT_STATE_TYPE_PLAY_PREVIEW;
107579:         case eFallbackDisabled:
107579:           return NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_HANDLER_DISABLED;
107579:         case eFallbackBlocklisted:
107579:           return NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_HANDLER_BLOCKED;
107579:         case eFallbackCrashed:
107579:           return NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_HANDLER_CRASHED;
107579:         case eFallbackUnsupported: {
106522:           // Check to see if plugins are blocked on this platform.
106522:           char* pluginsBlocked = PR_GetEnv("MOZ_PLUGINS_BLOCKED");
106522:           if (pluginsBlocked && pluginsBlocked[0] == '1') {
107579:             return NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_TYPE_UNSUPPORTED_PLATFORM;
106522:           } else {
107579:             return NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_TYPE_UNSUPPORTED;
106522:           }
106522:         }
107579:         case eFallbackOutdated:
107579:         case eFallbackAlternate:
107579:           return NS_EVENT_STATE_BROKEN;
107579:         case eFallbackVulnerableUpdatable:
107579:           return NS_EVENT_STATE_VULNERABLE_UPDATABLE;
107579:         case eFallbackVulnerableNoUpdate:
107579:           return NS_EVENT_STATE_VULNERABLE_NO_UPDATE;
     1:       }
     1:   };
     1:   NS_NOTREACHED("unknown type?");
107578:   return NS_EVENT_STATE_LOADING;
106457: }
106457: 
108676: bool
108991: nsObjectLoadingContent::CheckLoadPolicy(int16_t *aContentPolicy)
107578: {
108676:   if (!aContentPolicy || !mURI) {
108676:     NS_NOTREACHED("Doing it wrong");
108676:     return false;
108676:   }
108676: 
107578:   nsCOMPtr<nsIContent> thisContent =
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
107578:   NS_ASSERTION(thisContent, "Must be an instance of content");
107578: 
108676:   nsIDocument* doc = thisContent->OwnerDoc();
107578: 
108676:   *aContentPolicy = nsIContentPolicy::ACCEPT;
108676:   nsresult rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OBJECT,
108676:                                           mURI,
108676:                                           doc->NodePrincipal(),
108676:                                           thisContent,
108676:                                           mContentType,
108676:                                           nullptr, //extra
108676:                                           aContentPolicy,
108676:                                           nsContentUtils::GetContentPolicy(),
108676:                                           nsContentUtils::GetSecurityManager());
108676:   NS_ENSURE_SUCCESS(rv, false);
108676:   if (NS_CP_REJECTED(*aContentPolicy)) {
110974:     nsAutoCString uri;
110974:     nsAutoCString baseUri;
108676:     mURI->GetSpec(uri);
108676:     mURI->GetSpec(baseUri);
108676:     LOG(("OBJLC [%p]: Content policy denied load of %s (base %s)",
108676:          this, uri.get(), baseUri.get()));
107578:     return false;
107578:   }
107578: 
107578:   return true;
107578: }
107578: 
108676: bool
108991: nsObjectLoadingContent::CheckProcessPolicy(int16_t *aContentPolicy)
107578: {
108676:   if (!aContentPolicy) {
108676:     NS_NOTREACHED("Null out variable");
108676:     return false;
108676:   }
107578: 
107578:   nsCOMPtr<nsIContent> thisContent =
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
107578:   NS_ASSERTION(thisContent, "Must be an instance of content");
107578: 
108676:   nsIDocument* doc = thisContent->OwnerDoc();
107578:   
108991:   int32_t objectType;
108676:   switch (mType) {
108676:     case eType_Image:
108676:       objectType = nsIContentPolicy::TYPE_IMAGE;
108676:       break;
108676:     case eType_Document:
108676:       objectType = nsIContentPolicy::TYPE_DOCUMENT;
108676:       break;
108676:     case eType_Plugin:
108676:       objectType = nsIContentPolicy::TYPE_OBJECT;
108676:       break;
108676:     default:
108676:       NS_NOTREACHED("Calling checkProcessPolicy with a unloadable type");
107579:       return false;
107579:   }
107578: 
108676:   *aContentPolicy = nsIContentPolicy::ACCEPT;
108676:   nsresult rv =
108676:     NS_CheckContentProcessPolicy(objectType,
108676:                                  mURI,
107578:                                  doc->NodePrincipal(),
107578:                                  static_cast<nsIImageLoadingContent*>(this),
107578:                                  mContentType,
107578:                                  nullptr, //extra
108676:                                  aContentPolicy,
107578:                                  nsContentUtils::GetContentPolicy(),
108676:                                  nsContentUtils::GetSecurityManager());
107578:   NS_ENSURE_SUCCESS(rv, false);
108676: 
108676:   if (NS_CP_REJECTED(*aContentPolicy)) {
108676:     LOG(("OBJLC [%p]: CheckContentProcessPolicy rejected load", this));
107578:     return false;
107578:   }
108676: 
107578:   return true;
107578: }
107578: 
107578: nsObjectLoadingContent::ParameterUpdateFlags
107578: nsObjectLoadingContent::UpdateObjectParameters()
107578: {
107578:   nsCOMPtr<nsIContent> thisContent =
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
107578:   NS_ASSERTION(thisContent, "Must be an instance of content");
107578: 
108991:   uint32_t caps = GetCapabilities();
107578:   LOG(("OBJLC [%p]: Updating object parameters", this));
107578: 
107578:   nsresult rv;
110974:   nsAutoCString newMime;
107578:   nsCOMPtr<nsIURI> newURI;
107578:   nsCOMPtr<nsIURI> newBaseURI;
107578:   ObjectType newType;
108669:   bool isJava = false;
107578:   // Set if this state can't be used to load anything, forces eType_Null
107578:   bool stateInvalid = false;
107578:   // Indicates what parameters changed.
107578:   // eParamChannelChanged - means parameters that affect channel opening
107578:   //                        decisions changed
107578:   // eParamStateChanged -   means anything that affects what content we load
107578:   //                        changed, even if the channel we'd open remains the
107578:   //                        same.
107578:   //
107578:   // State changes outside of the channel parameters only matter if we've
107578:   // already opened a channel or tried to instantiate content, whereas channel
107578:   // parameter changes require re-opening the channel even if we haven't gotten
107578:   // that far.
107578:   nsObjectLoadingContent::ParameterUpdateFlags retval = eParamNoChange;
107578: 
107578:   ///
107578:   /// Initial MIME Type
107578:   ///
107578:   if (thisContent->NodeInfo()->Equals(nsGkAtoms::applet)) {
107578:     newMime.AssignLiteral("application/x-java-vm");
108669:     isJava = true;
107578:   } else {
107578:     nsAutoString typeAttr;
107578:     thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::type, typeAttr);
107578:     if (!typeAttr.IsEmpty()) {
107578:       CopyUTF16toUTF8(typeAttr, newMime);
108669:       isJava = nsPluginHost::IsJavaMIMEType(newMime.get());
107578:     }
107578:   }
107578: 
107578:   ///
107578:   /// classID
107578:   ///
107578: 
107578:   if (caps & eSupportClassID) {
107578:     nsAutoString classIDAttr;
107578:     thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::classid, classIDAttr);
107578:     if (!classIDAttr.IsEmpty()) {
108669:       // Our classid support is limited to 'java:' ids
108669:       rv = IsPluginEnabledForType(NS_LITERAL_CSTRING("application/x-java-vm"));
108669:       if (NS_SUCCEEDED(rv) &&
108669:           StringBeginsWith(classIDAttr, NS_LITERAL_STRING("java:"))) {
108669:         newMime.Assign("application/x-java-vm");
108669:         isJava = true;
108669:       } else {
107578:         // XXX(johns): Our de-facto behavior since forever was to refuse to load
107578:         // Objects who don't have a classid we support, regardless of other type
107578:         // or uri info leads to a valid plugin.
107578:         newMime.Assign("");
107578:         stateInvalid = true;
107578:       }
107578:     }
107578:   }
107578: 
107578:   ///
107578:   /// Codebase
107578:   ///
107578: 
107578:   nsAutoString codebaseStr;
107578:   nsCOMPtr<nsIURI> docBaseURI = thisContent->GetBaseURI();
107578:   thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::codebase, codebaseStr);
107578:   if (codebaseStr.IsEmpty() && thisContent->NodeInfo()->Equals(nsGkAtoms::applet)) {
107578:     // bug 406541
107578:     // NOTE we send the full absolute URI resolved here to java in
107578:     //      pluginInstanceOwner to avoid disagreements between parsing of
107578:     //      relative URIs. We need to mimic java's quirks here to make that
107578:     //      not break things.
107578:     codebaseStr.AssignLiteral("/"); // Java resolves codebase="" as "/"
107578:     // XXX(johns) This doesn't catch the case of "file:" which java would
107578:     // interpret as "file:///" but we would interpret as this document's URI
107578:     // but with a changed scheme.
107578:   }
107578: 
107578:   if (!codebaseStr.IsEmpty()) {
107578:     rv = nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(newBaseURI),
107578:                                                    codebaseStr,
107578:                                                    thisContent->OwnerDoc(),
107578:                                                    docBaseURI);
107578:     if (NS_SUCCEEDED(rv)) {
107578:       NS_TryToSetImmutable(newBaseURI);
107578:     } else {
107578:       // Malformed URI
107578:       LOG(("OBJLC [%p]: Could not parse plugin's codebase as a URI, "
107578:            "will use document baseURI instead", this));
107578:     }
107578:   }
107578: 
107578:   // Otherwise, use normal document baseURI
107578:   if (!newBaseURI) {
107578:     newBaseURI = docBaseURI;
107578:   }
107578: 
107578:   ///
107578:   /// URI
107578:   ///
107578: 
107578:   nsAutoString uriStr;
107578:   // Different elements keep this in various locations
108669:   if (isJava) {
108669:     // Applet tags and embed/object with explicit java MIMEs have
108669:     // src/data attributes that are not parsed as URIs, so we will
108669:     // act as if URI is null
108669:   } else if (thisContent->NodeInfo()->Equals(nsGkAtoms::object)) {
107578:     thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::data, uriStr);
107578:   } else if (thisContent->NodeInfo()->Equals(nsGkAtoms::embed)) {
107578:     thisContent->GetAttr(kNameSpaceID_None, nsGkAtoms::src, uriStr);
107578:   } else {
108669:     // Applet tags should always have a java MIME type at this point
107578:     NS_NOTREACHED("Unrecognized plugin-loading tag");
107578:   }
107578: 
107578:   // Note that the baseURI changing could affect the newURI, even if uriStr did
107578:   // not change.
107578:   if (!uriStr.IsEmpty()) {
107578:     rv = nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(newURI),
107578:                                                    uriStr,
107578:                                                    thisContent->OwnerDoc(),
107578:                                                    newBaseURI);
107578:     if (NS_SUCCEEDED(rv)) {
107578:       NS_TryToSetImmutable(newURI);
107578:     } else {
107578:       stateInvalid = true;
107578:     }
107578:   }
107578: 
107578:   ///
107578:   /// Check if the original (pre-channel) content-type or URI changed, and
107578:   /// record mOriginal{ContentType,URI}
107578:   ///
107578: 
107578:   if ((mOriginalContentType != newMime) || !URIEquals(mOriginalURI, newURI)) {
107578:     // These parameters changing requires re-opening the channel, so don't
107578:     // consider the currently-open channel below
107578:     // XXX(johns): Changing the mime type might change our decision on whether
107578:     //             or not we load a channel, so we count changes to it as a
107578:     //             channel parameter change for the sake of simplicity.
107578:     retval = (ParameterUpdateFlags)(retval | eParamChannelChanged);
107578:     LOG(("OBJLC [%p]: Channel parameters changed", this));
107578:   }
107578:   mOriginalContentType = newMime;
107578:   mOriginalURI = newURI;
107578: 
107578:   ///
107578:   /// If we have a channel, see if its MIME type should take precendence and
107578:   /// check the final (redirected) URL
107578:   ///
107578: 
107578:   // If we have a loaded channel and channel parameters did not change, use it
107578:   // to determine what we would load.
107578:   bool useChannel = mChannelLoaded && !(retval & eParamChannelChanged);
107578:   if (mChannel && useChannel) {
107578:     nsCString channelType;
107578:     rv = mChannel->GetContentType(channelType);
107578:     if (NS_FAILED(rv)) {
107578:       NS_NOTREACHED("GetContentType failed");
107578:       stateInvalid = true;
107578:       channelType.Assign("");
107578:     }
107578: 
107578:     LOG(("OBJLC [%p]: Channel has a content type of %s", this, channelType.get()));
107578: 
107578:     bool binaryChannelType = false;
107578:     if (channelType.EqualsASCII(APPLICATION_GUESS_FROM_EXT)) {
107578:       channelType = APPLICATION_OCTET_STREAM;
107578:       mChannel->SetContentType(channelType);
107578:       binaryChannelType = true;
107578:     } else if (channelType.EqualsASCII(APPLICATION_OCTET_STREAM)
107578:                || channelType.EqualsASCII(BINARY_OCTET_STREAM)) {
107578:       binaryChannelType = true;
107578:     }
107578: 
107578:     // Channel can change our URI through redirection
107578:     rv = NS_GetFinalChannelURI(mChannel, getter_AddRefs(newURI));
107578:     if (NS_FAILED(rv)) {
107578:       NS_NOTREACHED("NS_GetFinalChannelURI failure");
107578:       stateInvalid = true;
107578:     }
107578: 
107578:     // The channel type overrides the guessed / provided type, except when:
107578:     //
107578:     // 1) If the channel returns a binary stream type, and we have a type hint
107578:     //    for a non-document (we never want to display binary-as-document),
107578:     //    use our type hint instead.
107578:     // 2) Our type hint is a type that we support with a plugin, ignore the
107578:     //    server's type
107578:     //
107578:     //    XXX(johns): HTML5's "typesmustmatch" attribute would need to be
107578:     //                honored here if implemented
107579: 
107579:     ObjectType typeHint = newMime.IsEmpty() ? eType_Null : GetTypeOfContent(newMime);
107578: 
107578:     bool caseOne = binaryChannelType
107578:                    && typeHint != eType_Null
107578:                    && typeHint != eType_Document;
107578:     bool caseTwo = typeHint == eType_Plugin;
107578:     if (caseOne || caseTwo) {
107578:         // Set the type we'll use for dispatch on the channel.  Otherwise we could
107578:         // end up trying to dispatch to a nsFrameLoader, which will complain that
107578:         // it couldn't find a way to handle application/octet-stream
110974:         nsAutoCString typeHint, dummy;
107578:         NS_ParseContentType(newMime, typeHint, dummy);
107578:         if (!typeHint.IsEmpty()) {
107578:           mChannel->SetContentType(typeHint);
107578:         }
107578:     } else if (binaryChannelType
107578:                && IsPluginEnabledByExtension(newURI, newMime)) {
107578:       mChannel->SetContentType(newMime);
107578:     } else {
107578:       newMime = channelType;
108669:       if (nsPluginHost::IsJavaMIMEType(newMime.get())) {
108669:         //   Java does not load with a channel, and being java retroactively changes
107578:         //   how we may have interpreted the codebase to construct this URI above.
107578:         //   Because the behavior here is more or less undefined, play it safe and
107578:         //   reject the load.
108669:         LOG(("OBJLC [%p]: Refusing to load with channel with java MIME",
108669:              this));
108669:         stateInvalid = true;
108669:       }
108669:     }
108669:   }
108669: 
108669:   if (useChannel && !mChannel) {
108669:     // - (useChannel && !mChannel) is true if a channel was opened but
108669:     //   is no longer around, in which case we can't load.
107578:     stateInvalid = true;
107578:   }
107578: 
107578:   ///
107578:   /// Determine final type
107578:   ///
107578:   //  1) If we have attempted channel load, or set stateInvalid above, the type
107578:   //     is always null (fallback)
107578:   //  2) Otherwise, If we have a loaded channel, we grabbed its mimeType above,
107578:   //     use that type.
107578:   //  3) Otherwise, See if we can load this as a plugin without a channel
107578:   //     (image/document types always need a channel).
108669:   //     - If we have indication this is a plugin (mime, extension)
107578:   //       AND:
107578:   //       - We have eAllowPluginSkipChannel OR
108669:   //       - We have no URI in the first place (including java)
107578:   //  3) Otherwise, if we have a URI, set type to loading to indicate
107578:   //     we'd need a channel to proceed.
107578:   //  4) Otherwise, type null to indicate unloadable content (fallback)
107578:   //
107578:   // XXX(johns): <embed> tags both support URIs and have
107578:   //   eAllowPluginSkipChannel, meaning it is possible that we have a URI, but
107578:   //   are not going to open a channel for it. The old objLC code did this (in a
107578:   //   less obviously-intended way), so it's probably best not to change our
107578:   //   behavior at this point.
107578:   //
107578: 
107578:   if (stateInvalid) {
107578:     newType = eType_Null;
109451:     newMime.Truncate();
107578:   } else if (useChannel) {
107578:       // If useChannel is set above, we considered it in setting newMime
107578:       newType = GetTypeOfContent(newMime);
107578:       LOG(("OBJLC [%p]: Using channel type", this));
108669:   } else if (((caps & eAllowPluginSkipChannel) || !newURI) &&
107578:              (GetTypeOfContent(newMime) == eType_Plugin)) {
107578:     newType = eType_Plugin;
107578:     LOG(("OBJLC [%p]: Skipping loading channel, type plugin", this));
107578:   } else if (newURI) {
107578:     // We could potentially load this if we opened a channel on mURI, indicate
107578:     // This by leaving type as loading
107578:     newType = eType_Loading;
107578:   } else {
107578:     // Unloadable - no URI, and no plugin type. Non-plugin types (images,
107578:     // documents) always load with a channel.
107578:     newType = eType_Null;
107578:   }
107578: 
107578:   ///
107578:   /// Update changed values
107578:   ///
107578: 
107578:   if (newType != mType) {
107578:     retval = (ParameterUpdateFlags)(retval | eParamStateChanged);
107578:     LOG(("OBJLC [%p]: Type changed from %u -> %u", this, mType, newType));
107578:     mType = newType;
107578:   }
107578: 
107578:   if (!URIEquals(mBaseURI, newBaseURI)) {
107578:     if (isJava) {
107578:       // Java bases its class loading on the base URI, so we consider the state
107578:       // to have changed if this changes. If the object is using a relative URI,
107578:       // mURI will have changed below regardless
107578:       retval = (ParameterUpdateFlags)(retval | eParamStateChanged);
107578:     }
107578:     LOG(("OBJLC [%p]: Object effective baseURI changed", this));
107578:     mBaseURI = newBaseURI;
107578:   }
107578: 
107578:   if (!URIEquals(newURI, mURI)) {
107578:     retval = (ParameterUpdateFlags)(retval | eParamStateChanged);
107578:     LOG(("OBJLC [%p]: Object effective URI changed", this));
107578:     mURI = newURI;
107578:   }
107578: 
119110:   // We don't update content type when loading, as the type is not final and we
119110:   // don't want to superfluously change between mOriginalContentType ->
119110:   // mContentType when doing |obj.data = obj.data| with a channel and differing
119110:   // type.
119110:   if (mType != eType_Loading && mContentType != newMime) {
107578:     retval = (ParameterUpdateFlags)(retval | eParamStateChanged);
119110:     retval = (ParameterUpdateFlags)(retval | eParamContentTypeChanged);
119110:     LOG(("OBJLC [%p]: Object effective mime type changed (%s -> %s)",
119110:          this, mContentType.get(), newMime.get()));
107578:     mContentType = newMime;
107578:   }
107578: 
107578:   return retval;
107578: }
107578: 
107578: // Only OnStartRequest should be passing the channel parameter
107578: nsresult
107578: nsObjectLoadingContent::LoadObject(bool aNotify,
107578:                                    bool aForceLoad)
107578: {
107578:   return LoadObject(aNotify, aForceLoad, nullptr);
107578: }
107578: 
106488: nsresult
107578: nsObjectLoadingContent::LoadObject(bool aNotify,
107578:                                    bool aForceLoad,
107578:                                    nsIRequest *aLoadingChannel)
106488: {
107578:   nsCOMPtr<nsIContent> thisContent =
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
107578:   NS_ASSERTION(thisContent, "must be a content");
107578:   nsIDocument* doc = thisContent->OwnerDoc();
107579:   nsresult rv = NS_OK;
107578: 
108002:   // Sanity check
108002:   if (!InActiveDocument(thisContent)) {
108002:     NS_NOTREACHED("LoadObject called while not bound to an active document");
108002:     return NS_ERROR_UNEXPECTED;
108002:   }
108002: 
107578:   // XXX(johns): In these cases, we refuse to touch our content and just
107578:   //   remain unloaded, as per legacy behavior. It would make more sense to
107578:   //   load fallback content initially and refuse to ever change state again.
107578:   if (doc->IsBeingUsedAsImage() || doc->IsLoadedAsData()) {
106488:     return NS_OK;
106488:   }
107578: 
107578:   LOG(("OBJLC [%p]: LoadObject called, notify %u, forceload %u, channel %p",
107578:        this, aNotify, aForceLoad, aLoadingChannel));
106488: 
107578:   // We can't re-use an already open channel, but aForceLoad may make us try
107578:   // to load a plugin without any changes in channel state.
107578:   if (aForceLoad && mChannelLoaded) {
107578:     CloseChannel();
107578:     mChannelLoaded = false;
107578:   }
106457: 
107579:   // Save these for NotifyStateChanged();
107579:   nsEventStates oldState = ObjectState();
107579:   ObjectType oldType = mType;
107579: 
107578:   ParameterUpdateFlags stateChange = UpdateObjectParameters();
106457: 
108671:   if (!stateChange && !aForceLoad) {
     1:     return NS_OK;
     1:   }
106457: 
107578:   ///
107578:   /// State has changed, unload existing content and attempt to load new type
107578:   ///
107578:   LOG(("OBJLC [%p]: LoadObject - plugin state changed (%u)",
107578:        this, stateChange));
107578: 
107579:   // Setup fallback info. We may also change type to fallback below in case of
107579:   // sanity/OOM/etc. errors. We default to showing alternate content
107579:   // NOTE LoadFallback can override this in some cases
107579:   FallbackType fallbackType = eFallbackAlternate;
107579: 
107579:   if (mType == eType_Null) {
107579:     nsresult pluginsupport = IsPluginEnabledForType(mContentType);
107579:     if (pluginsupport == NS_ERROR_PLUGIN_DISABLED) {
107579:       fallbackType = eFallbackDisabled;
107579:     } else if (pluginsupport == NS_ERROR_PLUGIN_BLOCKLISTED) {
107579:       fallbackType = eFallbackBlocklisted;
107579:     } else {
107579:       fallbackType = eFallbackUnsupported;
107579:     }
107579:   }
107579: 
119110:   // Explicit user activation should reset if the object changes content types
119110:   if (mActivated && (stateChange & eParamContentTypeChanged)) {
119110:     LOG(("OBJLC [%p]: Content type changed, clearing activation state", this));
119110:     mActivated = false;
119110:   }
119110: 
107578:   // We synchronously start/stop plugin instances below, which may spin the
107578:   // event loop. Re-entering into the load is fine, but at that point the
107578:   // original load call needs to abort when unwinding
107578:   // NOTE this is located *after* the state change check, a subseqent load
107578:   //      with no subsequently changed state will be a no-op.
108980:   if (mIsLoading) {
108980:     LOG(("OBJLC [%p]: Re-entering into LoadObject", this));
108980:   }
107578:   mIsLoading = true;
107578:   AutoSetLoadingToFalse reentryCheck(this);
107578: 
107578:   // Unload existing content, keeping in mind stopping plugins might spin the
107579:   // event loop. Note that we check for still-open channels below
107579:   UnloadObject(false); // Don't reset state
107578:   if (!mIsLoading) {
107578:     // The event loop must've spun and re-entered into LoadObject, which
107578:     // finished the load
108980:     LOG(("OBJLC [%p]: Re-entered into LoadObject, aborting outer load", this));
107578:     return NS_OK;
107578:   }
107578: 
108671:   // Determine what's going on with our channel
107578:   if (stateChange & eParamChannelChanged) {
107578:     // If the channel params changed, throw away the channel, but unset
107578:     // mChannelLoaded so we'll still try to open a new one for this load if
107578:     // necessary
107578:     CloseChannel();
107578:     mChannelLoaded = false;
107578:   } else if (mType == eType_Null && mChannel) {
107578:     // If we opened a channel but then failed to find a loadable state, throw it
107578:     // away. mChannelLoaded will indicate that we tried to load a channel at one
107578:     // point so we wont recurse
107578:     CloseChannel();
108671:   } else if (mType == eType_Loading && mChannel) {
108671:     // We're still waiting on a channel load, already opened one, and
108671:     // channel parameters didn't change
108671:     return NS_OK;
107578:   } else if (mChannelLoaded && mChannel != aLoadingChannel) {
107578:     // The only time we should have a loaded channel with a changed state is
107578:     // when the channel has just opened -- in which case this call should
107578:     // have originated from OnStartRequest
107578:     NS_NOTREACHED("Loading with a channel, but state doesn't make sense");
107578:     return NS_OK;
107578:   }
107578: 
107579:   //
107579:   // Security checks
107579:   //
107578: 
107579:   if (mType != eType_Null) {
108991:     int16_t contentPolicy = nsIContentPolicy::ACCEPT;
107578:     bool allowLoad = false;
108676:     // We check load policy before opening a channel, and process policy before
108676:     // going ahead with any final-type load
108676:     if (mType == eType_Loading) {
108676:       nsCOMPtr<nsIScriptSecurityManager> secMan =
108676:         nsContentUtils::GetSecurityManager();
108676:       if (!secMan) {
108676:         NS_NOTREACHED("No security manager?");
108676:       } else {
108676:         rv = secMan->CheckLoadURIWithPrincipal(thisContent->NodePrincipal(),
108676:                                                mURI, 0);
108676:         allowLoad = NS_SUCCEEDED(rv) && CheckLoadPolicy(&contentPolicy);
107578:       }
108676:     } else {
108676:       allowLoad = CheckProcessPolicy(&contentPolicy);
107578:     }
107578: 
108980:     // Content policy implementations can mutate the DOM, check for re-entry
108980:     if (!mIsLoading) {
108980:       LOG(("OBJLC [%p]: We re-entered in content policy, leaving original load",
108980:            this));
108980:       return NS_OK;
108980:     }
108980:     
107578:     // Load denied, switch to fallback and set disabled/suppressed if applicable
107578:     if (!allowLoad) {
108676:       LOG(("OBJLC [%p]: Load denied by policy", this));
107578:       mType = eType_Null;
107578:       if (contentPolicy == nsIContentPolicy::REJECT_TYPE) {
108676:         // XXX(johns) This is assuming that we were rejected by
108676:         //            nsContentBlocker, which rejects by type if permissions
108676:         //            reject plugins
107579:         fallbackType = eFallbackUserDisabled;
107579:       } else {
107579:         fallbackType = eFallbackSuppressed;
107578:       }
107579:     }
107579:   }
107579: 
109451:   // Items resolved as Image/Document will not be checked for previews, as well
109451:   // as invalid plugins (they will not have the mContentType set).
109451:   if ((mType == eType_Null || mType == eType_Plugin) && ShouldPreview()) {
109451:     // If plugin preview exists, we shall use it
109451:     LOG(("OBJLC [%p]: Using plugin preview", this));
109451:     mType = eType_Null;
109451:     fallbackType = eFallbackPlayPreview;
109451:   }
109451: 
107579:   // If we're a plugin but shouldn't start yet, load fallback with
107579:   // reason click-to-play instead
107579:   FallbackType clickToPlayReason;
107579:   if (mType == eType_Plugin && !ShouldPlay(clickToPlayReason)) {
107579:     LOG(("OBJLC [%p]: Marking plugin as click-to-play", this));
107579:     mType = eType_Null;
107579:     fallbackType = clickToPlayReason;
107578:   }
107578: 
119459:   if (!mActivated && mType == eType_Plugin) {
119110:     // Object passed ShouldPlay and !ShouldPreview, so it should be considered
119110:     // activated until it changes content type
119110:     LOG(("OBJLC [%p]: Object implicitly activated", this));
119110:     mActivated = true;
119110:   }
119110: 
107578:   // Sanity check: We shouldn't have any loaded resources, pending events, or
107578:   // a final listener at this point
107578:   if (mFrameLoader || mPendingInstantiateEvent || mInstanceOwner ||
107578:       mFinalListener)
107578:   {
107578:     NS_NOTREACHED("Trying to load new plugin with existing content");
107578:     rv = NS_ERROR_UNEXPECTED;
107578:     return NS_OK;
107578:   }
107578: 
107578:   // More sanity-checking:
107578:   // If mChannel is set, mChannelLoaded should be set, and vice-versa
107578:   if (mType != eType_Null && !!mChannel != mChannelLoaded) {
107578:     NS_NOTREACHED("Trying to load with bad channel state");
107578:     rv = NS_ERROR_UNEXPECTED;
107578:     return NS_OK;
107578:   }
107578: 
107578:   ///
107578:   /// Attempt to load new type
107578:   ///
108980: 
118862:   // We don't set mFinalListener until OnStartRequest has been called, to
118862:   // prevent re-entry ugliness with CloseChannel()
118862:   nsCOMPtr<nsIStreamListener> finalListener;
107578:   switch (mType) {
107578:     case eType_Image:
107578:       if (!mChannel) {
107578:         // We have a LoadImage() call, but UpdateObjectParameters requires a
107578:         // channel for images, so this is not a valid state.
107578:         NS_NOTREACHED("Attempting to load image without a channel?");
107578:         rv = NS_ERROR_UNEXPECTED;
107579:         break;
107578:       }
118862:       rv = LoadImageWithChannel(mChannel, getter_AddRefs(finalListener));
118862:       // finalListener will receive OnStartRequest below
107578:     break;
107578:     case eType_Plugin:
107578:     {
106488:       if (mChannel) {
107578:         nsRefPtr<nsPluginHost> pluginHost =
107578:           already_AddRefed<nsPluginHost>(nsPluginHost::GetInst());
107578:         if (!pluginHost) {
107578:           NS_NOTREACHED("No pluginHost");
107578:           rv = NS_ERROR_UNEXPECTED;
107578:           break;
107578:         }
107579: 
107579:         // Force a sync state change now, we need the frame created
107579:         NotifyStateChanged(oldType, oldState, true, aNotify);
107579:         oldType = mType;
107579:         oldState = ObjectState();
107579: 
111606:         if (!thisContent->GetPrimaryFrame()) {
111606:           // We're un-rendered, and can't instantiate a plugin. HasNewFrame will
111606:           // re-start us when we can proceed.
111606:           LOG(("OBJLC [%p]: Aborting load - plugin-type, but no frame", this));
111606:           CloseChannel();
111606:           break;
111606:         }
111606:         
107578:         rv = pluginHost->NewEmbeddedPluginStreamListener(mURI, this, nullptr,
118862:                                                          getter_AddRefs(finalListener));
118862:         // finalListener will receive OnStartRequest below
107578:       } else {
107578:         rv = AsyncStartPluginInstance();
107578:       }
107578:     }
107578:     break;
107578:     case eType_Document:
107578:     {
107578:       if (!mChannel) {
107578:         // We could mFrameLoader->LoadURI(mURI), but UpdateObjectParameters
107578:         // requires documents have a channel, so this is not a valid state.
107578:         NS_NOTREACHED("Attempting to load a document without a channel");
107579:         mType = eType_Null;
107579:         break;
107578:       }
107579:       
107578:       mFrameLoader = nsFrameLoader::Create(thisContent->AsElement(),
107578:                                            mNetworkCreated);
107578:       if (!mFrameLoader) {
107579:         NS_NOTREACHED("nsFrameLoader::Create failed");
107579:         mType = eType_Null;
107579:         break;
107578:       }
107578:       
107578:       rv = mFrameLoader->CheckForRecursiveLoad(mURI);
107578:       if (NS_FAILED(rv)) {
107579:         mType = eType_Null;
107579:         break;
107578:       }
107578: 
107578:       // We're loading a document, so we have to set LOAD_DOCUMENT_URI
107578:       // (especially important for firing onload)
107578:       nsLoadFlags flags = 0;
107578:       mChannel->GetLoadFlags(&flags);
107578:       flags |= nsIChannel::LOAD_DOCUMENT_URI;
107578:       mChannel->SetLoadFlags(flags);
107578: 
107578:       nsCOMPtr<nsIDocShell> docShell;
107578:       rv = mFrameLoader->GetDocShell(getter_AddRefs(docShell));
107579:       if (NS_FAILED(rv)) {
107579:         NS_NOTREACHED("Could not get DocShell from mFrameLoader?");
107579:         mType = eType_Null;
107579:         break;
107579:       }
107578: 
107578:       nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(docShell));
107578:       NS_ASSERTION(req, "Docshell must be an ifreq");
107578: 
107578:       nsCOMPtr<nsIURILoader>
107578:         uriLoader(do_GetService(NS_URI_LOADER_CONTRACTID, &rv));
107579:       if (NS_FAILED(rv)) {
107579:         NS_NOTREACHED("Failed to get uriLoader service");
107579:         mType = eType_Null;
107579:         break;
107579:       }
107578:       rv = uriLoader->OpenChannel(mChannel, nsIURILoader::DONT_RETARGET, req,
118862:                                   getter_AddRefs(finalListener));
118862:       // finalListener will receive OnStartRequest below
107578:     }
107578:     break;
107578:     case eType_Loading:
107578:       // If our type remains Loading, we need a channel to proceed
108676:       rv = OpenChannel();
107578:       if (NS_FAILED(rv)) {
107578:         LOG(("OBJLC [%p]: OpenChannel returned failure (%u)", this, rv));
107578:       }
107578:     break;
107579:     case eType_Null:
107579:       // Handled below, silence compiler warnings
107578:     break;
107578:   };
107578: 
118862:   //
118862:   // Loaded, handle notifications and fallback
118862:   //
107579:   if (NS_FAILED(rv)) {
107579:     // If we failed in the loading hunk above, switch to fallback
107579:     LOG(("OBJLC [%p]: Loading failed, switching to fallback", this));
107579:     mType = eType_Null;
107579:   }
107579: 
118862:   // If we didn't load anything, handle switching to fallback state
107579:   if (mType == eType_Null) {
107579:     LOG(("OBJLC [%p]: Loading fallback, type %u", this, fallbackType));
107579:     NS_ASSERTION(!mFrameLoader && !mInstanceOwner,
107579:                  "switched to type null but also loaded something");
107579: 
107579:     if (mChannel) {
107579:       // If we were loading with a channel but then failed over, throw it away
107579:       CloseChannel();
107579:     }
107579: 
107579:     // Don't notify or send events - we'll handle those ourselves
107579:     // (so really this is just setting mFallbackType)
107579:     LoadFallback(fallbackType, false);
107579:   }
107579: 
107579:   // Notify of our final state if we haven't already
107579:   NotifyStateChanged(oldType, oldState, false, aNotify);
107579:   
108448:   if (mType == eType_Null && !mContentType.IsEmpty() &&
108448:       mFallbackType != eFallbackAlternate) {
108448:     // if we have a content type and are not showing alternate
108448:     // content, fire a pluginerror to trigger (we stopped LoadFallback
108448:     // from doing so above, it doesn't know of our old state)
107579:     FirePluginError(mFallbackType);
107579:   }
107579: 
118862:   //
118862:   // Pass load on to finalListener if loading with a channel
118862:   //
118862: 
118862:   // If we re-entered and loaded something else, that load will have cleaned up
118862:   // our our listener.
118862:   if (!mIsLoading) {
118862:     LOG(("OBJLC [%p]: Re-entered before dispatching to final listener", this));
118862:   } else if (finalListener) {
118862:     NS_ASSERTION(mType != eType_Null && mType != eType_Loading,
118862:                  "We should not have a final listener with a non-loaded type");
118862:     // Note that we always enter into LoadObject() from ::OnStartRequest when
118862:     // loading with a channel.
118862:     mSrcStreamLoading = true;
118862:     // Remove blocker on entering into instantiate
118862:     // (this is otherwise unset by the stack class)
118862:     mIsLoading = false;
118862:     mFinalListener = finalListener;
119540:     rv = finalListener->OnStartRequest(mChannel, nullptr);
118862:     mSrcStreamLoading = false;
119540:     if (NS_FAILED(rv)) {
119540:       // Failed to load new content, but since we've already notified of our
119540:       // transition, we can just Unload and call LoadFallback (which will notify
119540:       // again)
119540:       mType = eType_Null;
119540:       // This could *also* technically re-enter if OnStartRequest fails after
119540:       // spawning a plugin.
119540:       mIsLoading = true;
119540:       UnloadObject(false);
119540:       NS_ENSURE_TRUE(mIsLoading, NS_OK);
119540:       LoadFallback(fallbackType, true);
119540:     }
118862:   }
118862: 
107578:   return NS_OK;
107578: }
107578: 
118862: // This call can re-enter when dealing with plugin listeners
107578: nsresult
107578: nsObjectLoadingContent::CloseChannel()
107578: {
107578:   if (mChannel) {
107578:     LOG(("OBJLC [%p]: Closing channel\n", this));
118862:     // Null the values before potentially-reentering, and ensure they survive
118862:     // the call
118862:     nsCOMPtr<nsIChannel> channelGrip(mChannel);
118862:     nsCOMPtr<nsIStreamListener> listenerGrip(mFinalListener);
118862:     mChannel = nullptr;
106838:     mFinalListener = nullptr;
118862:     channelGrip->Cancel(NS_BINDING_ABORTED);
118862:     if (listenerGrip) {
118862:       // mFinalListener is only set by LoadObject after OnStartRequest
118862:       listenerGrip->OnStopRequest(channelGrip, nullptr, NS_BINDING_ABORTED);
     1:     }
     1:   }
  4064:   return NS_OK;
  4064: }
  4064: 
107578: nsresult
108676: nsObjectLoadingContent::OpenChannel()
107578: {
107578:   nsCOMPtr<nsIContent> thisContent = 
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
107578:   NS_ASSERTION(thisContent, "must be a content");
107578:   nsIDocument* doc = thisContent->OwnerDoc();
107578:   NS_ASSERTION(doc, "No owner document?");
107579:   NS_ASSERTION(!mInstanceOwner && !mInstantiating,
107578:                "opening a new channel with already loaded content");
     1: 
107578:   nsresult rv;
107578:   mChannel = nullptr;
     1: 
 12297:   // E.g. mms://
107578:   if (!mURI || !CanHandleURI(mURI)) {
107578:     return NS_ERROR_NOT_AVAILABLE;
     1:   }
     1: 
     1:   nsCOMPtr<nsILoadGroup> group = doc->GetDocumentLoadGroup();
     1:   nsCOMPtr<nsIChannel> chan;
 41208:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
 41208:   nsCOMPtr<nsIContentSecurityPolicy> csp;
 41208:   rv = doc->NodePrincipal()->GetCsp(getter_AddRefs(csp));
 41208:   NS_ENSURE_SUCCESS(rv, rv);
 41208:   if (csp) {
 41208:     channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
 41208:     channelPolicy->SetContentSecurityPolicy(csp);
108676:     channelPolicy->SetLoadType(nsIContentPolicy::TYPE_OBJECT);
 41208:   }
107578:   rv = NS_NewChannel(getter_AddRefs(chan), mURI, nullptr, group, this,
 42552:                      nsIChannel::LOAD_CALL_CONTENT_SNIFFERS |
 42552:                      nsIChannel::LOAD_CLASSIFY_URI,
 41208:                      channelPolicy);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   // Referrer
     1:   nsCOMPtr<nsIHttpChannel> httpChan(do_QueryInterface(chan));
     1:   if (httpChan) {
     1:     httpChan->SetReferrer(doc->GetDocumentURI());
     1:   }
     1: 
  8608:   // Set up the channel's principal and such, like nsDocShell::DoURILoad does
 78531:   nsContentUtils::SetUpChannelOwner(thisContent->NodePrincipal(),
107578:                                     chan, mURI, true);
  8608: 
  8608:   nsCOMPtr<nsIScriptChannel> scriptChannel = do_QueryInterface(chan);
  8608:   if (scriptChannel) {
  8608:     // Allow execution against our context if the principals match
107578:     scriptChannel->SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
  8608:   }
  8608: 
     1:   // AsyncOpen can fail if a file does not exist.
106838:   rv = chan->AsyncOpen(this, nullptr);
107578:   NS_ENSURE_SUCCESS(rv, rv);
107578:   LOG(("OBJLC [%p]: Channel opened", this));
     1:   mChannel = chan;
     1:   return NS_OK;
     1: }
     1: 
108991: uint32_t
     1: nsObjectLoadingContent::GetCapabilities() const
     1: {
     1:   return eSupportImages |
     1:          eSupportPlugins |
 71013:          eSupportDocuments |
 71013:          eSupportSVG;
     1: }
     1: 
     1: void
107578: nsObjectLoadingContent::DestroyContent()
     1: {
     1:   if (mFrameLoader) {
     1:     mFrameLoader->Destroy();
106838:     mFrameLoader = nullptr;
     1:   }
 89114: 
107578:   StopPluginInstance();
     1: }
     1: 
 77323: /* static */
     1: void
 77323: nsObjectLoadingContent::Traverse(nsObjectLoadingContent *tmp,
 77323:                                  nsCycleCollectionTraversalCallback &cb)
     1: {
 77323:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mFrameLoader");
 77323:   cb.NoteXPCOMChild(static_cast<nsIFrameLoader*>(tmp->mFrameLoader));
     1: }
     1: 
     1: void
107579: nsObjectLoadingContent::UnloadObject(bool aResetState)
     1: {
107579:   // Don't notify in CancelImageRequests until we transition to a new loaded
107579:   // state
 80486:   CancelImageRequests(false);
     1:   if (mFrameLoader) {
     1:     mFrameLoader->Destroy();
106838:     mFrameLoader = nullptr;
     1:   }
107579: 
107579:   if (aResetState) {
118862:     if (mType != eType_Plugin) {
118862:       // This can re-enter when dealing with plugins, and StopPluginInstance
118862:       // will handle it
107579:       CloseChannel();
118862:     }
108670:     mChannelLoaded = false;
107579:     mType = eType_Loading;
108670:     mURI = mOriginalURI = mBaseURI = nullptr;
108670:     mContentType.Truncate();
108670:     mOriginalContentType.Truncate();
107579:   }
107579: 
107579:   // This call should be last as it may re-enter
107579:   StopPluginInstance();
     1: }
     1: 
     1: void
     1: nsObjectLoadingContent::NotifyStateChanged(ObjectType aOldType,
 71121:                                            nsEventStates aOldState,
 79445:                                            bool aSync,
 79445:                                            bool aNotify)
     1: {
107579:   LOG(("OBJLC [%p]: Notifying about state change: (%u, %llx) -> (%u, %llx)"
107579:        " (sync %i, notify %i)", this, aOldType, aOldState.GetInternalValue(),
107579:        mType, ObjectState().GetInternalValue(), aSync, aNotify));
     1: 
     1:   nsCOMPtr<nsIContent> thisContent = 
  3233:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
     1:   NS_ASSERTION(thisContent, "must be a content");
     1: 
 71121:   NS_ASSERTION(thisContent->IsElement(), "Not an element?");
 71121: 
107578:   // XXX(johns): A good bit of the code below replicates UpdateState(true)
107578: 
 71121:   // Unfortunately, we do some state changes without notifying
 71121:   // (e.g. in Fallback when canceling image requests), so we have to
 71121:   // manually notify object state changes.
 71121:   thisContent->AsElement()->UpdateState(false);
 71121: 
 71121:   if (!aNotify) {
 71121:     // We're done here
 71121:     return;
 71121:   }
 71121: 
     1:   nsIDocument* doc = thisContent->GetCurrentDoc();
     1:   if (!doc) {
     1:     return; // Nothing to do
     1:   }
     1: 
 56168:   nsEventStates newState = ObjectState();
     1: 
     1:   if (newState != aOldState) {
     1:     // This will trigger frame construction
108002:     NS_ASSERTION(InActiveDocument(thisContent), "Something is confused");
 56168:     nsEventStates changedBits = aOldState ^ newState;
     1: 
     1:     {
 71103:       nsAutoScriptBlocker scriptBlocker;
 64120:       doc->ContentStateChanged(thisContent, changedBits);
     1:     }
     1:     if (aSync) {
 71121:       // Make sure that frames are actually constructed immediately.
     1:       doc->FlushPendingNotifications(Flush_Frames);
     1:     }
     1:   } else if (aOldType != mType) {
     1:     // If our state changed, then we already recreated frames
     1:     // Otherwise, need to do that here
 46225:     nsCOMPtr<nsIPresShell> shell = doc->GetShell();
 36917:     if (shell) {
     1:       shell->RecreateFramesFor(thisContent);
     1:     }
     1:   }
     1: }
     1: 
107578: void
107579: nsObjectLoadingContent::FirePluginError(FallbackType aFallbackType)
     1: {
107578:   nsCOMPtr<nsIContent> thisContent = 
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
107578:   NS_ASSERTION(thisContent, "must be a content");
107578: 
107578:   LOG(("OBJLC [%p]: Dispatching nsPluginErrorEvent for content %p\n",
107578:        this));
106457: 
107579:   nsCOMPtr<nsIRunnable> ev = new nsPluginErrorEvent(thisContent, aFallbackType);
     1:   nsresult rv = NS_DispatchToCurrentThread(ev);
     1:   if (NS_FAILED(rv)) {
  3464:     NS_WARNING("failed to dispatch nsPluginErrorEvent");
     1:   }
     1: }
     1: 
     1: nsObjectLoadingContent::ObjectType
     1: nsObjectLoadingContent::GetTypeOfContent(const nsCString& aMIMEType)
     1: {
107578:   if (aMIMEType.IsEmpty()) {
107578:     return eType_Null;
107578:   }
107578: 
108991:   uint32_t caps = GetCapabilities();
     1: 
     1:   if ((caps & eSupportImages) && IsSupportedImage(aMIMEType)) {
     1:     return eType_Image;
     1:   }
     1: 
107578:   // SVGs load as documents, but are their own capability
 79445:   bool isSVG = aMIMEType.LowerCaseEqualsLiteral("image/svg+xml");
107578:   bool supportType = isSVG ? eSupportSVG : eSupportDocuments;
107578:   if ((caps & supportType) && IsSupportedDocument(aMIMEType)) {
     1:     return eType_Document;
     1:   }
     1: 
 89887:   if ((caps & eSupportPlugins) && NS_SUCCEEDED(IsPluginEnabledForType(aMIMEType))) {
     1:     return eType_Plugin;
     1:   }
     1: 
     1:   return eType_Null;
     1: }
     1: 
 89114: nsObjectFrame*
 89114: nsObjectLoadingContent::GetExistingFrame()
     1: {
 89114:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
 89114:   nsIFrame* frame = thisContent->GetPrimaryFrame();
 23554:   nsIObjectFrame* objFrame = do_QueryFrame(frame);
 89114:   return static_cast<nsObjectFrame*>(objFrame);
     1: }
     1: 
106488: void
 35581: nsObjectLoadingContent::CreateStaticClone(nsObjectLoadingContent* aDest) const
 35581: {
 35581:   nsImageLoadingContent::CreateStaticImageClone(aDest);
 35581: 
 35581:   aDest->mType = mType;
 35581:   nsObjectLoadingContent* thisObj = const_cast<nsObjectLoadingContent*>(this);
 35581:   if (thisObj->mPrintFrame.IsAlive()) {
 35581:     aDest->mPrintFrame = thisObj->mPrintFrame;
 35581:   } else {
 89114:     aDest->mPrintFrame = const_cast<nsObjectLoadingContent*>(this)->GetExistingFrame();
 35581:   }
 35581: 
 35581:   if (mFrameLoader) {
 35581:     nsCOMPtr<nsIContent> content =
 79617:       do_QueryInterface(static_cast<nsIImageLoadingContent*>(aDest));
 80486:     nsFrameLoader* fl = nsFrameLoader::Create(content->AsElement(), false);
 35581:     if (fl) {
 35581:       aDest->mFrameLoader = fl;
 35581:       mFrameLoader->CreateStaticClone(fl);
 35581:     }
 35581:   }
 35581: }
 35581: 
 35581: NS_IMETHODIMP
 35581: nsObjectLoadingContent::GetPrintFrame(nsIFrame** aFrame)
 35581: {
 35581:   *aFrame = mPrintFrame.GetFrame();
 35581:   return NS_OK;
 35581: }
 35581: 
 35171: NS_IMETHODIMP
 39501: nsObjectLoadingContent::PluginCrashed(nsIPluginTag* aPluginTag,
 39794:                                       const nsAString& pluginDumpID,
 39794:                                       const nsAString& browserDumpID,
 79445:                                       bool submittedCrashReport)
 37151: {
107578:   LOG(("OBJLC [%p]: Plugin Crashed, queuing crash event", this));
107578:   NS_ASSERTION(mType == eType_Plugin, "PluginCrashed at non-plugin type");
107578: 
107579:   // Instance is dead, clean up
107579:   mInstanceOwner = nullptr;
107579:   CloseChannel();
107579: 
107579:   // Switch to fallback/crashed state, notify
107579:   LoadFallback(eFallbackCrashed, true);
107579: 
107579:   // send nsPluginCrashedEvent
107579:   nsCOMPtr<nsIContent> thisContent =
107579:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
 39501: 
 39501:   // Note that aPluginTag in invalidated after we're called, so copy 
 39501:   // out any data we need now.
110974:   nsAutoCString pluginName;
 39501:   aPluginTag->GetName(pluginName);
110974:   nsAutoCString pluginFilename;
 40610:   aPluginTag->GetFilename(pluginFilename);
 39501: 
107579:   nsCOMPtr<nsIRunnable> ev =
107579:     new nsPluginCrashedEvent(thisContent,
 39794:                              pluginDumpID,
 39794:                              browserDumpID,
 39501:                              NS_ConvertUTF8toUTF16(pluginName),
 40610:                              NS_ConvertUTF8toUTF16(pluginFilename),
 38026:                              submittedCrashReport);
 38026:   nsresult rv = NS_DispatchToCurrentThread(ev);
 38026:   if (NS_FAILED(rv)) {
 38026:     NS_WARNING("failed to dispatch nsPluginCrashedEvent");
 38026:   }
 37151:   return NS_OK;
 37151: }
 84557: 
 84557: NS_IMETHODIMP
 89114: nsObjectLoadingContent::SyncStartPluginInstance()
 89114: {
 89114:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
 89114:                "Must be able to run script in order to instantiate a plugin instance!");
 89114: 
 89980:   // Don't even attempt to start an instance unless the content is in
108002:   // the document and active
 89980:   nsCOMPtr<nsIContent> thisContent =
 89980:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
108002:   if (!InActiveDocument(thisContent)) {
 89114:     return NS_ERROR_FAILURE;
 89114:   }
 89114: 
 89690:   nsCOMPtr<nsIURI> kungFuURIGrip(mURI);
 89980:   nsCString contentType(mContentType);
107578:   return InstantiatePluginInstance();
 89114: }
 89114: 
 89114: NS_IMETHODIMP
 89114: nsObjectLoadingContent::AsyncStartPluginInstance()
 89114: {
 89114:   // OK to have an instance already.
 89114:   if (mInstanceOwner) {
 89114:     return NS_OK;
 89114:   }
 89114: 
 89114:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
 89114:   nsIDocument* doc = thisContent->OwnerDoc();
 89114:   if (doc->IsStaticDocument() || doc->IsBeingUsedAsImage()) {
 89114:     return NS_OK;
 89114:   }
 89114: 
 89114:   // We always start plugins on a runnable.
 89114:   // We don't want a script blocker on the stack during instantiation.
 89114:   nsCOMPtr<nsIRunnable> event = new nsAsyncInstantiateEvent(this);
 89114:   if (!event) {
 89114:     return NS_ERROR_OUT_OF_MEMORY;
 89114:   }
 89114:   nsresult rv = NS_DispatchToCurrentThread(event);
 89114:   if (NS_SUCCEEDED(rv)) {
 89114:     // Remember this event.  This is a weak reference that will be cleared
 89114:     // when the event runs.
 89114:     mPendingInstantiateEvent = event;
 89114:   }
 89114: 
 89114:   return rv;
 89114: }
 89114: 
 92097: NS_IMETHODIMP
 92097: nsObjectLoadingContent::GetSrcURI(nsIURI** aURI)
 92097: {
 92097:   NS_IF_ADDREF(*aURI = mURI);
 92097:   return NS_OK;
 92097: }
 92097: 
 89114: static bool
 99505: DoDelayedStop(nsPluginInstanceOwner* aInstanceOwner,
 99505:               nsObjectLoadingContent* aContent,
 99505:               bool aDelayedStop)
 89114: {
 89114: #if (MOZ_PLATFORM_MAEMO==5)
 89114:   // Don't delay stop on Maemo/Hildon (bug 530739).
 89114:   if (aDelayedStop && aInstanceOwner->MatchPluginName("Shockwave Flash"))
 89114:     return false;
 89114: #endif
 89114: 
 89114:   // Don't delay stopping QuickTime (bug 425157), Flip4Mac (bug 426524),
 89114:   // XStandard (bug 430219), CMISS Zinc (bug 429604).
 89114:   if (aDelayedStop
 89114: #if !(defined XP_WIN || defined MOZ_X11)
 89114:       && !aInstanceOwner->MatchPluginName("QuickTime")
 89114:       && !aInstanceOwner->MatchPluginName("Flip4Mac")
 89114:       && !aInstanceOwner->MatchPluginName("XStandard plugin")
 89114:       && !aInstanceOwner->MatchPluginName("CMISS Zinc Plugin")
 89114: #endif
 89114:       ) {
 99505:     nsCOMPtr<nsIRunnable> evt =
 99505:       new nsStopPluginRunnable(aInstanceOwner, aContent);
 89114:     NS_DispatchToCurrentThread(evt);
 89114:     return true;
 89114:   }
 89114:   return false;
 89114: }
 89114: 
 89114: void
107579: nsObjectLoadingContent::LoadFallback(FallbackType aType, bool aNotify) {
107579:   nsEventStates oldState = ObjectState();
107579:   ObjectType oldType = mType;
107579: 
107579:   NS_ASSERTION(!mInstanceOwner && !mFrameLoader && !mChannel,
107579:                "LoadFallback called with loaded content");
107579: 
107579:   //
107579:   // Fixup mFallbackType
107579:   //
107579:   nsCOMPtr<nsIContent> thisContent =
107579:   do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
107579:   NS_ASSERTION(thisContent, "must be a content");
107579: 
110577:   if (!thisContent->IsHTML() || mContentType.IsEmpty()) {
110577:     // Don't let custom fallback handlers run outside HTML, tags without a
110577:     // determined type should always just be alternate content
107579:     aType = eFallbackAlternate;
107579:   }
107579: 
111216:   /// XXX(johns): This block is just mimicing legacy behavior, not any spec
111216:   // Check if we have any significant content (excluding param tags) OR a
111216:   // param named 'pluginUrl'
111216:   bool hasAlternateContent = false;
111216:   bool hasPluginUrl = false;
107579:   if (thisContent->Tag() == nsGkAtoms::object &&
107579:       (aType == eFallbackUnsupported ||
107579:        aType == eFallbackDisabled ||
107579:        aType == eFallbackBlocklisted))
107579:   {
107579:     for (nsIContent* child = thisContent->GetFirstChild();
111216:          child; child = child->GetNextSibling())
111216:     {
111216:       if (child->IsHTML(nsGkAtoms::param)) {
111216:         if (child->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
111216:           NS_LITERAL_STRING("pluginurl"), eIgnoreCase)) {
111216:           hasPluginUrl = true;
111216:         }
111216:       } else if (nsStyleUtil::IsSignificantChild(child, true, false)) {
111216:         hasAlternateContent = true;
111216:       }
111216:     }
111216: 
111216:     // Show alternate content if it exists, unless we have a 'pluginurl' param,
111216:     // in which case the missing-plugin fallback handler will want to handle
111216:     // it
111216:     if (hasAlternateContent && !hasPluginUrl) {
111216:       LOG(("OBJLC [%p]: Unsupported/disabled/blocked plugin has alternate "
111216:       "content, showing instead of custom handler", this));
111201:       aType = eFallbackAlternate;
107579:     }
107579:   }
107579: 
107579:   mType = eType_Null;
107579:   mFallbackType = aType;
107579: 
107579:   //
107579:   // Notify & send events
107579:   //
107579:   if (!aNotify) {
107579:     return; // done
107579:   }
107579: 
107579:   NotifyStateChanged(oldType, oldState, false, true);
107579: 
107579:   if (mFallbackType != eFallbackCrashed &&
107579:       mFallbackType != eFallbackAlternate)
107579:   {
107579:     // Alternate content doesn't trigger a pluginError, and nsPluginCrashedEvent
107579:     // is only handled by ::PluginCrashed
107579:     FirePluginError(mFallbackType);
107579:   }
107579: }
107579: 
107579: void
 99505: nsObjectLoadingContent::DoStopPlugin(nsPluginInstanceOwner* aInstanceOwner,
 99505:                                      bool aDelayedStop,
 99505:                                      bool aForcedReentry)
 89114: {
 99505:   // DoStopPlugin can process events and there may be pending InDocCheckEvent
 99505:   // events which can drop in underneath us and destroy the instance we are
107579:   // about to destroy unless we prevent that with the mPluginStopping flag.
 99505:   // (aForcedReentry is only true from the callback of an earlier delayed stop)
 99505:   if (mIsStopping && !aForcedReentry) {
 99505:     return;
 99505:   }
 99505:   mIsStopping = true;
 99505: 
 99864:   nsRefPtr<nsPluginInstanceOwner> kungFuDeathGrip(aInstanceOwner);
 89114:   nsRefPtr<nsNPAPIPluginInstance> inst;
 89114:   aInstanceOwner->GetInstance(getter_AddRefs(inst));
 89114:   if (inst) {
 99505:     if (DoDelayedStop(aInstanceOwner, this, aDelayedStop)) {
 89114:       return;
 89114:     }
 89114: 
 89114: #if defined(XP_MACOSX)
 89114:     aInstanceOwner->HidePluginWindow();
 89114: #endif
 89114: 
107578:     nsRefPtr<nsPluginHost> pluginHost =
107578:       already_AddRefed<nsPluginHost>(nsPluginHost::GetInst());
107578:     NS_ASSERTION(pluginHost, "No plugin host?");
107578:     pluginHost->StopPluginInstance(inst);
 89114:   }
 89114: 
 89114:   aInstanceOwner->Destroy();
108979:   mIsStopping = false;
 89114: }
 89114: 
 89114: NS_IMETHODIMP
 89114: nsObjectLoadingContent::StopPluginInstance()
 89114: {
107578:   // Prevents any pending plugin starts from running
107578:   mPendingInstantiateEvent = nullptr;
107578: 
 89114:   if (!mInstanceOwner) {
 89114:     return NS_OK;
 89114:   }
 89114: 
107578:   if (mChannel) {
107578:     // The plugin has already used data from this channel, we'll need to
107578:     // re-open it to handle instantiating again, even if we don't invalidate
107578:     // our loaded state.
107578:     /// XXX(johns): Except currently, we don't, just leaving re-opening channels
107578:     ///             to plugins...
107578:     LOG(("OBJLC [%p]: StopPluginInstance - Closing used channel", this));
107578:     CloseChannel();
107578:   }
107578: 
 89114:   DisconnectFrame();
 89114: 
 89114:   bool delayedStop = false;
 89114: #ifdef XP_WIN
 89114:   // Force delayed stop for Real plugin only; see bug 420886, 426852.
 89114:   nsRefPtr<nsNPAPIPluginInstance> inst;
 89114:   mInstanceOwner->GetInstance(getter_AddRefs(inst));
 89114:   if (inst) {
106838:     const char* mime = nullptr;
 89114:     if (NS_SUCCEEDED(inst->GetMIMEType(&mime)) && mime) {
 89114:       if (strcmp(mime, "audio/x-pn-realaudio-plugin") == 0) {
 89114:         delayedStop = true;
 89114:       }
 89114:     }
 89114:   }
 89114: #endif
 89114: 
 99504:   DoStopPlugin(mInstanceOwner, delayedStop);
 99504: 
106838:   mInstanceOwner = nullptr;
 99504: 
 89114:   return NS_OK;
 89114: }
 89114: 
 89114: void
 89114: nsObjectLoadingContent::NotifyContentObjectWrapper()
 89114: {
107578:   nsCOMPtr<nsIContent> thisContent =
107578:     do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
 89114: 
 89114:   nsCOMPtr<nsIDocument> doc = thisContent->GetDocument();
 89114:   if (!doc)
 89114:     return;
 89114: 
 89114:   nsIScriptGlobalObject *sgo = doc->GetScopeObject();
 89114:   if (!sgo)
 89114:     return;
 89114: 
 89114:   nsIScriptContext *scx = sgo->GetContext();
 89114:   if (!scx)
 89114:     return;
 89114: 
 89114:   JSContext *cx = scx->GetNativeContext();
 89114: 
 89114:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
 89114:   nsContentUtils::XPConnect()->
 89114:   GetWrappedNativeOfNativeObject(cx, sgo->GetGlobalJSObject(), thisContent,
 89114:                                  NS_GET_IID(nsISupports),
 89114:                                  getter_AddRefs(wrapper));
 89114: 
 89114:   if (!wrapper) {
 89114:     // Nothing to do here if there's no wrapper for mContent. The proto
 89114:     // chain will be fixed appropriately when the wrapper is created.
 89114:     return;
 89114:   }
 89114: 
106838:   JSObject *obj = nullptr;
 89114:   nsresult rv = wrapper->GetJSObject(&obj);
 89114:   if (NS_FAILED(rv))
 89114:     return;
 89114: 
 89114:   nsHTMLPluginObjElementSH::SetupProtoChain(wrapper, cx, obj);
 89114: }
 89114: 
 89114: NS_IMETHODIMP
 84557: nsObjectLoadingContent::PlayPlugin()
 84557: {
 84557:   if (!nsContentUtils::IsCallerChrome())
 84557:     return NS_OK;
 84557: 
119110:   if (!mActivated) {
107579:     mActivated = true;
119110:     LOG(("OBJLC [%p]: Activated by user", this));
119110:   }
119110: 
119110:   // If we're in a click-to-play or play preview state, we need to reload
119110:   // Fallback types >= eFallbackClickToPlay are plugin-replacement types, see
119110:   // header
119110:   if (mType == eType_Null && mFallbackType >= eFallbackClickToPlay) {
107578:     return LoadObject(true, true);
 84557:   }
 94270: 
119110:   return NS_OK;
119110: }
119110: 
 94270: NS_IMETHODIMP
 94270: nsObjectLoadingContent::GetActivated(bool *aActivated)
 94270: {
119110:   *aActivated = mActivated;
 94270:   return NS_OK;
 94270: }
107579: 
108956: NS_IMETHODIMP
108991: nsObjectLoadingContent::GetPluginFallbackType(uint32_t* aPluginFallbackType)
108956: {
108956:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
108956:   *aPluginFallbackType = mFallbackType;
108956:   return NS_OK;
108956: }
108956: 
109451: NS_IMETHODIMP
109451: nsObjectLoadingContent::CancelPlayPreview()
109451: {
109451:   if (!nsContentUtils::IsCallerChrome())
109451:     return NS_ERROR_NOT_AVAILABLE;
109451: 
119110:   mPlayPreviewCanceled = true;
119110:   
119110:   // If we're in play preview state already, reload
119110:   if (mType == eType_Null && mFallbackType == eFallbackPlayPreview) {
119110:     return LoadObject(true, true);
119110:   }
119110: 
109451:   return NS_OK;
109451: }
109451: 
109451: bool
109451: nsObjectLoadingContent::ShouldPreview()
109451: {
109451:   if (mPlayPreviewCanceled || mActivated)
109451:     return false;
109451: 
109451:   nsRefPtr<nsPluginHost> pluginHost =
109451:     already_AddRefed<nsPluginHost>(nsPluginHost::GetInst());
109451: 
109451:   return pluginHost->IsPluginPlayPreviewForType(mContentType.get());
109451: }
109451: 
107579: bool
107579: nsObjectLoadingContent::ShouldPlay(FallbackType &aReason)
107579: {
107579:   // mActivated is true if we've been activated via PlayPlugin() (e.g. user has
107579:   // clicked through). Otherwise, only play if click-to-play is off or if page
107579:   // is whitelisted
107579: 
107579:   nsRefPtr<nsPluginHost> pluginHost =
107579:     already_AddRefed<nsPluginHost>(nsPluginHost::GetInst());
107579: 
107579:   bool isCTP = pluginHost->IsPluginClickToPlayForType(mContentType.get());
107579: 
107579:   if (!isCTP || mActivated) {
107579:     return true;
107579:   }
107579: 
115715:   // set the fallback reason
107579:   aReason = eFallbackClickToPlay;
115715:   // (if it's click-to-play, it might be because of the blocklist)
115715:   uint32_t state;
115715:   nsresult rv = pluginHost->GetBlocklistStateForType(mContentType.get(), &state);
115715:   NS_ENSURE_SUCCESS(rv, false);
115715:   if (state == nsIBlocklistService::STATE_VULNERABLE_UPDATE_AVAILABLE) {
115715:     aReason = eFallbackVulnerableUpdatable;
115715:   }
115715:   else if (state == nsIBlocklistService::STATE_VULNERABLE_NO_UPDATE) {
115715:     aReason = eFallbackVulnerableNoUpdate;
115715:   }
107579: 
107579:   // If plugin type is click-to-play and we have not been explicitly clicked.
107579:   // check if permissions lets this page bypass - (e.g. user selected 'Always
107579:   // play plugins on this page')
107579: 
107579:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(static_cast<nsIObjectLoadingContent*>(this));
107579:   MOZ_ASSERT(thisContent);
107579:   nsIDocument* ownerDoc = thisContent->OwnerDoc();
107579: 
107579:   nsCOMPtr<nsIDOMWindow> window = ownerDoc->GetWindow();
107579:   if (!window) {
107579:     return false;
107579:   }
107579:   nsCOMPtr<nsIDOMWindow> topWindow;
107579:   rv = window->GetTop(getter_AddRefs(topWindow));
107579:   NS_ENSURE_SUCCESS(rv, false);
107579:   nsCOMPtr<nsIDOMDocument> topDocument;
107579:   rv = topWindow->GetDocument(getter_AddRefs(topDocument));
107579:   NS_ENSURE_SUCCESS(rv, false);
107579:   nsCOMPtr<nsIDocument> topDoc = do_QueryInterface(topDocument);
107579: 
107579:   nsCOMPtr<nsIPermissionManager> permissionManager = do_GetService(NS_PERMISSIONMANAGER_CONTRACTID, &rv);
107579:   NS_ENSURE_SUCCESS(rv, false);
107579: 
107579:   bool allowPerm = false;
107579:   // For now we always say that the system principal uses click-to-play since
107579:   // that maintains current behavior and we have tests that expect this.
107579:   // What we really should do is disable plugins entirely in pages that use
107579:   // the system principal, i.e. in chrome pages. That way the click-to-play
107579:   // code here wouldn't matter at all. Bug 775301 is tracking this.
107579:   if (!nsContentUtils::IsSystemPrincipal(topDoc->NodePrincipal())) {
108991:     uint32_t permission;
107579:     rv = permissionManager->TestPermissionFromPrincipal(topDoc->NodePrincipal(),
107579:                                                         "plugins",
107579:                                                         &permission);
107579:     NS_ENSURE_SUCCESS(rv, false);
107579:     allowPerm = permission == nsIPermissionManager::ALLOW_ACTION;
107579:   }
107579: 
107579:   return allowPerm;
107579: }
107579: 
