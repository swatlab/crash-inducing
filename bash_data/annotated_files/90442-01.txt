72428: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
72428:  * ***** BEGIN LICENSE BLOCK *****
72428:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
72428:  *
72428:  * The contents of this file are subject to the Mozilla Public License Version
72428:  * 1.1 (the "License"); you may not use this file except in compliance with
72428:  * the License. You may obtain a copy of the License at
72428:  * http://www.mozilla.org/MPL/
72428:  *
72428:  * Software distributed under the License is distributed on an "AS IS" basis,
72428:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
72428:  * for the specific language governing rights and limitations under the
72428:  * License.
72428:  *
72428:  * The Original Code is Mozilla Corporation code.
72428:  *
72428:  * The Initial Developer of the Original Code is Mozilla Foundation.
72428:  * Portions created by the Initial Developer are Copyright (C) 2011
72428:  * the Initial Developer. All Rights Reserved.
72428:  *
72428:  * Contributor(s):
72428:  *   Bas Schouten <bschouten@mozilla.com>
72428:  *
72428:  * Alternatively, the contents of this file may be used under the terms of
72428:  * either the GNU General Public License Version 2 or later (the "GPL"), or
72428:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
72428:  * in which case the provisions of the GPL or the LGPL are applicable instead
72428:  * of those above. If you wish to allow use of your version of this file only
72428:  * under the terms of either the GPL or the LGPL, and not to allow others to
72428:  * use your version of this file under the terms of the MPL, indicate your
72428:  * decision by deleting the provisions above and replace them with the notice
72428:  * and other provisions required by the GPL or the LGPL. If you do not delete
72428:  * the provisions above, a recipient may use your version of this file under
72428:  * the terms of any one of the MPL, the GPL or the LGPL.
72428:  *
72428:  * ***** END LICENSE BLOCK ***** */
72428: 
72428: #include "base/basictypes.h"
72428: 
72428: #include "nsIDOMXULElement.h"
72428: 
72428: #include "prmem.h"
72428: #include "prenv.h"
72428: 
72428: #include "nsIServiceManager.h"
72428: #include "nsMathUtils.h"
72428: 
72428: #include "nsContentUtils.h"
72428: 
72428: #include "nsIDOMDocument.h"
72428: #include "nsIDocument.h"
72428: #include "nsIDOMCanvasRenderingContext2D.h"
72428: #include "nsICanvasRenderingContextInternal.h"
72428: #include "nsHTMLCanvasElement.h"
72428: #include "nsSVGEffects.h"
72428: #include "nsPresContext.h"
72428: #include "nsIPresShell.h"
72428: #include "nsIVariant.h"
72428: 
72428: #include "nsIInterfaceRequestorUtils.h"
72428: #include "nsIFrame.h"
72428: #include "nsDOMError.h"
72428: #include "nsIScriptError.h"
72428: 
72428: #include "nsCSSParser.h"
72428: #include "mozilla/css/StyleRule.h"
72428: #include "mozilla/css/Declaration.h"
72428: #include "nsComputedDOMStyle.h"
72428: #include "nsStyleSet.h"
72428: 
72428: #include "nsPrintfCString.h"
72428: 
72428: #include "nsReadableUtils.h"
72428: 
72428: #include "nsColor.h"
72428: #include "nsGfxCIID.h"
72428: #include "nsIScriptSecurityManager.h"
72428: #include "nsIDocShell.h"
72428: #include "nsIDOMWindow.h"
72428: #include "nsPIDOMWindow.h"
72428: #include "nsIDocShell.h"
72428: #include "nsIDocShellTreeItem.h"
72428: #include "nsIDocShellTreeNode.h"
72428: #include "nsIXPConnect.h"
72428: #include "jsapi.h"
72428: #include "nsDisplayList.h"
72428: 
72428: #include "nsTArray.h"
72428: 
72428: #include "imgIEncoder.h"
72428: 
72428: #include "gfxContext.h"
72428: #include "gfxASurface.h"
72428: #include "gfxImageSurface.h"
72428: #include "gfxPlatform.h"
72428: #include "gfxFont.h"
72428: #include "gfxBlur.h"
72428: #include "gfxUtils.h"
72428: 
72428: #include "nsFrameManager.h"
72428: #include "nsFrameLoader.h"
73724: #include "nsBidi.h"
72428: #include "nsBidiPresUtils.h"
72428: #include "Layers.h"
72428: #include "CanvasUtils.h"
72428: #include "nsIMemoryReporter.h"
72428: #include "nsStyleUtil.h"
72428: #include "CanvasImageCache.h"
72428: 
72428: #include <algorithm>
72428: #include "mozilla/dom/ContentParent.h"
72428: #include "mozilla/ipc/PDocumentRendererParent.h"
72428: #include "mozilla/dom/PBrowserParent.h"
72428: #include "mozilla/ipc/DocumentRendererParent.h"
72428: 
72428: #include "mozilla/gfx/2D.h"
81282: #include "mozilla/gfx/PathHelpers.h"
82414: #include "mozilla/Preferences.h"
72428: 
72428: #ifdef XP_WIN
72428: #include "gfxWindowsPlatform.h"
72428: #endif
72428: 
72428: // windows.h (included by chromium code) defines this, in its infinite wisdom
72428: #undef DrawText
72428: 
72428: using namespace mozilla;
72739: using namespace mozilla::CanvasUtils;
72739: using namespace mozilla::css;
72428: using namespace mozilla::dom;
72428: using namespace mozilla::gfx;
72428: using namespace mozilla::ipc;
72739: using namespace mozilla::layers;
72428: 
72428: namespace mgfx = mozilla::gfx;
72428: 
72428: static float kDefaultFontSize = 10.0;
72428: static NS_NAMED_LITERAL_STRING(kDefaultFontName, "sans-serif");
72428: static NS_NAMED_LITERAL_STRING(kDefaultFontStyle, "10px sans-serif");
72428: 
72428: /* Memory reporter stuff */
72428: static nsIMemoryReporter *gCanvasAzureMemoryReporter = nsnull;
72428: static PRInt64 gCanvasAzureMemoryUsed = 0;
72428: 
72640: static PRInt64 GetCanvasAzureMemoryUsed() {
72428:   return gCanvasAzureMemoryUsed;
72428: }
72428: 
72640: // This is KIND_OTHER because it's not always clear where in memory the pixels
72640: // of a canvas are stored.  Furthermore, this memory will be tracked by the
72428: // underlying surface implementations.  See bug 655638 for details.
72428: NS_MEMORY_REPORTER_IMPLEMENT(CanvasAzureMemory,
72428:   "canvas-2d-pixel-bytes",
72640:   KIND_OTHER,
72640:   UNITS_BYTES,
72640:   GetCanvasAzureMemoryUsed,
72428:   "Memory used by 2D canvases. Each canvas requires (width * height * 4) "
72640:   "bytes.")
72428: 
72428: /**
72428:  ** nsCanvasGradientAzure
72428:  **/
72428: #define NS_CANVASGRADIENTAZURE_PRIVATE_IID \
72428:     {0x28425a6a, 0x90e0, 0x4d42, {0x9c, 0x75, 0xff, 0x60, 0x09, 0xb3, 0x10, 0xa8}}
72428: class nsCanvasGradientAzure : public nsIDOMCanvasGradient
72428: {
72428: public:
72428:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_CANVASGRADIENTAZURE_PRIVATE_IID)
72428: 
72428:   enum Type
72428:   {
72428:     LINEAR = 0,
72428:     RADIAL
72428:   };
72428: 
72428:   Type GetType()
72428:   {
72428:     return mType;
72428:   }
72428: 
72428: 
72428:   GradientStops *GetGradientStopsForTarget(DrawTarget *aRT)
72428:   {
72428:     if (mStops && mStops->GetBackendType() == aRT->GetType()) {
72428:       return mStops;
72428:     }
72428: 
72428:     mStops = aRT->CreateGradientStops(mRawStops.Elements(), mRawStops.Length());
72428: 
72428:     return mStops;
72428:   }
72428: 
72428:   NS_DECL_ISUPPORTS
72428: 
73619:   /* nsIDOMCanvasGradient */
73619:   NS_IMETHOD AddColorStop (float offset,
73619:                             const nsAString& colorstr)
73619:   {
73619:     if (!FloatValidate(offset) || offset < 0.0 || offset > 1.0) {
73619:       return NS_ERROR_DOM_INDEX_SIZE_ERR;
73619:     }
73619: 
73619:     nscolor color;
73619:     nsCSSParser parser;
73619:     nsresult rv = parser.ParseColorString(nsString(colorstr),
73619:                                           nsnull, 0, &color);
73619:     if (NS_FAILED(rv)) {
73619:       return NS_ERROR_DOM_SYNTAX_ERR;
73619:     }
73619: 
73619:     mStops = nsnull;
73619: 
73619:     GradientStop newStop;
73619: 
73619:     newStop.offset = offset;
73619:     newStop.color = Color::FromABGR(color);
73619: 
73619:     mRawStops.AppendElement(newStop);
73619: 
73619:     return NS_OK;
73619:   }
73619: 
72428: protected:
72428:   nsCanvasGradientAzure(Type aType) : mType(aType)
72428:   {}
72428: 
72428:   nsTArray<GradientStop> mRawStops;
72428:   RefPtr<GradientStops> mStops;
72428:   Type mType;
89346:   virtual ~nsCanvasGradientAzure() {}
72428: };
72428: 
72428: class nsCanvasRadialGradientAzure : public nsCanvasGradientAzure
72428: {
72428: public:
72428:   nsCanvasRadialGradientAzure(const Point &aBeginOrigin, Float aBeginRadius,
72428:                               const Point &aEndOrigin, Float aEndRadius)
72428:     : nsCanvasGradientAzure(RADIAL)
73619:     , mCenter1(aBeginOrigin)
73619:     , mCenter2(aEndOrigin)
73619:     , mRadius1(aBeginRadius)
73619:     , mRadius2(aEndRadius)
72428:   {
73619:   }
73619: 
73619:   Point mCenter1;
73619:   Point mCenter2;
73619:   Float mRadius1;
73619:   Float mRadius2;
72428: };
72428: 
72428: class nsCanvasLinearGradientAzure : public nsCanvasGradientAzure
72428: {
72428: public:
72428:   nsCanvasLinearGradientAzure(const Point &aBegin, const Point &aEnd)
72428:     : nsCanvasGradientAzure(LINEAR)
72428:     , mBegin(aBegin)
72428:     , mEnd(aEnd)
72428:   {
72428:   }
72428: 
72428: protected:
72428:   friend class nsCanvasRenderingContext2DAzure;
72428: 
72428:   // Beginning of linear gradient.
72428:   Point mBegin;
72428:   // End of linear gradient.
72428:   Point mEnd;
72428: };
72428: 
72428: NS_DEFINE_STATIC_IID_ACCESSOR(nsCanvasGradientAzure, NS_CANVASGRADIENTAZURE_PRIVATE_IID)
72428: 
72428: NS_IMPL_ADDREF(nsCanvasGradientAzure)
72428: NS_IMPL_RELEASE(nsCanvasGradientAzure)
72428: 
72428: // XXX
72428: // DOMCI_DATA(CanvasGradient, nsCanvasGradientAzure)
72428: 
72428: NS_INTERFACE_MAP_BEGIN(nsCanvasGradientAzure)
72428:   NS_INTERFACE_MAP_ENTRY(nsCanvasGradientAzure)
72428:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasGradient)
72428:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasGradient)
72428:   NS_INTERFACE_MAP_ENTRY(nsISupports)
72428: NS_INTERFACE_MAP_END
72428: 
72428: /**
72428:  ** nsCanvasPatternAzure
72428:  **/
72428: #define NS_CANVASPATTERNAZURE_PRIVATE_IID \
72428:     {0xc9bacc25, 0x28da, 0x421e, {0x9a, 0x4b, 0xbb, 0xd6, 0x93, 0x05, 0x12, 0xbc}}
89346: class nsCanvasPatternAzure MOZ_FINAL : public nsIDOMCanvasPattern
72428: {
72428: public:
72428:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_CANVASPATTERNAZURE_PRIVATE_IID)
72428: 
72428:   enum RepeatMode
72428:   {
72428:     REPEAT,
72428:     REPEATX,
72428:     REPEATY,
72428:     NOREPEAT
72428:   };
72428: 
72428:   nsCanvasPatternAzure(SourceSurface* aSurface,
72428:                        RepeatMode aRepeat,
72428:                        nsIPrincipal* principalForSecurityCheck,
79445:                        bool forceWriteOnly,
79445:                        bool CORSUsed)
72428:     : mSurface(aSurface)
72428:     , mRepeat(aRepeat)
72428:     , mPrincipal(principalForSecurityCheck)
72428:     , mForceWriteOnly(forceWriteOnly)
78159:     , mCORSUsed(CORSUsed)
72428:   {
72428:   }
72428: 
72428:   NS_DECL_ISUPPORTS
72428: 
72428:   RefPtr<SourceSurface> mSurface;
78159:   const RepeatMode mRepeat;
72428:   nsCOMPtr<nsIPrincipal> mPrincipal;
79445:   const bool mForceWriteOnly;
79445:   const bool mCORSUsed;
72428: };
72428: 
72428: NS_DEFINE_STATIC_IID_ACCESSOR(nsCanvasPatternAzure, NS_CANVASPATTERNAZURE_PRIVATE_IID)
72428: 
72428: NS_IMPL_ADDREF(nsCanvasPatternAzure)
72428: NS_IMPL_RELEASE(nsCanvasPatternAzure)
72428: 
72428: // XXX
72428: // DOMCI_DATA(CanvasPattern, nsCanvasPatternAzure)
72428: 
72428: NS_INTERFACE_MAP_BEGIN(nsCanvasPatternAzure)
72428:   NS_INTERFACE_MAP_ENTRY(nsCanvasPatternAzure)
72428:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasPattern)
72428:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasPattern)
72428:   NS_INTERFACE_MAP_ENTRY(nsISupports)
72428: NS_INTERFACE_MAP_END
72428: 
72428: /**
72428:  ** nsTextMetricsAzure
72428:  **/
72428: #define NS_TEXTMETRICSAZURE_PRIVATE_IID \
72428:   {0x9793f9e7, 0x9dc1, 0x4e9c, {0x81, 0xc8, 0xfc, 0xa7, 0x14, 0xf4, 0x30, 0x79}}
72428: class nsTextMetricsAzure : public nsIDOMTextMetrics
72428: {
72428: public:
72428:   nsTextMetricsAzure(float w) : width(w) { }
72428: 
72428:   virtual ~nsTextMetricsAzure() { }
72428: 
72428:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_TEXTMETRICSAZURE_PRIVATE_IID)
72428: 
72428:   NS_IMETHOD GetWidth(float* w) {
72428:     *w = width;
72428:     return NS_OK;
72428:   }
72428: 
72428:   NS_DECL_ISUPPORTS
72428: 
72428: private:
72428:   float width;
72428: };
72428: 
72428: NS_DEFINE_STATIC_IID_ACCESSOR(nsTextMetricsAzure, NS_TEXTMETRICSAZURE_PRIVATE_IID)
72428: 
72428: NS_IMPL_ADDREF(nsTextMetricsAzure)
72428: NS_IMPL_RELEASE(nsTextMetricsAzure)
72428: 
72428: // XXX
72428: // DOMCI_DATA(TextMetrics, nsTextMetricsAzure)
72428: 
72428: NS_INTERFACE_MAP_BEGIN(nsTextMetricsAzure)
72428:   NS_INTERFACE_MAP_ENTRY(nsTextMetricsAzure)
72428:   NS_INTERFACE_MAP_ENTRY(nsIDOMTextMetrics)
72428:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(TextMetrics)
72428:   NS_INTERFACE_MAP_ENTRY(nsISupports)
72428: NS_INTERFACE_MAP_END
72428: 
72428: struct nsCanvasBidiProcessorAzure;
72428: 
72428: // Cap sigma to avoid overly large temp surfaces.
72428: static const Float SIGMA_MAX = 100;
72428: 
72428: /**
72428:  ** nsCanvasRenderingContext2DAzure
72428:  **/
72428: class nsCanvasRenderingContext2DAzure :
72428:   public nsIDOMCanvasRenderingContext2D,
72428:   public nsICanvasRenderingContextInternal
72428: {
72428: public:
72428:   nsCanvasRenderingContext2DAzure();
72428:   virtual ~nsCanvasRenderingContext2DAzure();
72428: 
72428:   nsresult Redraw();
72428: 
72428:   // nsICanvasRenderingContextInternal
72428:   NS_IMETHOD SetCanvasElement(nsHTMLCanvasElement* aParentCanvas);
72428:   NS_IMETHOD SetDimensions(PRInt32 width, PRInt32 height);
72428:   NS_IMETHOD InitializeWithSurface(nsIDocShell *shell, gfxASurface *surface, PRInt32 width, PRInt32 height)
72428:   { return NS_ERROR_NOT_IMPLEMENTED; }
72428: 
72428:   NS_IMETHOD Render(gfxContext *ctx, gfxPattern::GraphicsFilter aFilter);
72428:   NS_IMETHOD GetInputStream(const char* aMimeType,
72428:                             const PRUnichar* aEncoderOptions,
72428:                             nsIInputStream **aStream);
72428:   NS_IMETHOD GetThebesSurface(gfxASurface **surface);
72428: 
72428:   TemporaryRef<SourceSurface> GetSurfaceSnapshot()
72428:   { return mTarget ? mTarget->Snapshot() : nsnull; }
72428: 
79445:   NS_IMETHOD SetIsOpaque(bool isOpaque);
72428:   NS_IMETHOD Reset();
72428:   already_AddRefed<CanvasLayer> GetCanvasLayer(nsDisplayListBuilder* aBuilder,
72428:                                                 CanvasLayer *aOldLayer,
72428:                                                 LayerManager *aManager);
72428:   void MarkContextClean();
79445:   NS_IMETHOD SetIsIPC(bool isIPC);
72428:   // this rect is in canvas device space
72428:   void Redraw(const mgfx::Rect &r);
72428:   NS_IMETHOD Redraw(const gfxRect &r) { Redraw(ToRect(r)); return NS_OK; }
72428: 
72428:   // this rect is in mTarget's current user space
72428:   nsresult RedrawUser(const gfxRect &r);
72428: 
72428:   // nsISupports interface + CC
72428:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
72428: 
72428:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsCanvasRenderingContext2DAzure, nsIDOMCanvasRenderingContext2D)
72428: 
72428:   // nsIDOMCanvasRenderingContext2D interface
72428:   NS_DECL_NSIDOMCANVASRENDERINGCONTEXT2D
72428: 
72428:   enum Style {
72428:     STYLE_STROKE = 0,
72428:     STYLE_FILL,
72428:     STYLE_MAX
72428:   };
72428:   
81282:   nsresult LineTo(const Point& aPoint);
81282:   nsresult BezierTo(const Point& aCP1, const Point& aCP2, const Point& aCP3);
81282: 
72428: protected:
72428:   nsresult InitializeWithTarget(DrawTarget *surface, PRInt32 width, PRInt32 height);
72428: 
72428:   /**
72428:     * The number of living nsCanvasRenderingContexts.  When this goes down to
72428:     * 0, we free the premultiply and unpremultiply tables, if they exist.
72428:     */
72428:   static PRUint32 sNumLivingContexts;
72428: 
72428:   /**
72428:     * Lookup table used to speed up GetImageData().
72428:     */
72428:   static PRUint8 (*sUnpremultiplyTable)[256];
72428: 
72428:   /**
72428:     * Lookup table used to speed up PutImageData().
72428:     */
72428:   static PRUint8 (*sPremultiplyTable)[256];
72428: 
72428:   // Some helpers.  Doesn't modify a color on failure.
72428:   nsresult SetStyleFromStringOrInterface(const nsAString& aStr, nsISupports *aInterface, Style aWhichStyle);
72428:   nsresult GetStyleAsStringOrInterface(nsAString& aStr, nsISupports **aInterface, PRInt32 *aType, Style aWhichStyle);
72428: 
72428:   void StyleColorToString(const nscolor& aColor, nsAString& aStr);
72428: 
72428:   /**
72428:     * Creates the unpremultiply lookup table, if it doesn't exist.
72428:     */
72428:   void EnsureUnpremultiplyTable();
72428: 
72428:   /**
72428:     * Creates the premultiply lookup table, if it doesn't exist.
72428:     */
72428:   void EnsurePremultiplyTable();
72428: 
72428:   /* This function ensures there is a writable pathbuilder available, this
72428:    * pathbuilder may be working in user space or in device space or
72428:    * device space.
72428:    */
72428:   void EnsureWritablePath();
72428: 
72428:   // Ensures a path in UserSpace is available.
72428:   void EnsureUserSpacePath();
72428: 
72428:   void TransformWillUpdate();
72428: 
72428:   // Report the fillRule has changed.
72428:   void FillRuleChanged();
72428: 
72428:   /**
72428:     * Returns the surface format this canvas should be allocated using. Takes
72428:     * into account mOpaque, platform requirements, etc.
72428:     */
72428:   SurfaceFormat GetSurfaceFormat() const;
72428: 
72428:   nsHTMLCanvasElement *HTMLCanvasElement() {
72428:     return static_cast<nsHTMLCanvasElement*>(mCanvasElement.get());
72428:   }
72428: 
72428:   // Member vars
72428:   PRInt32 mWidth, mHeight;
72428: 
72428:   // This is true when the canvas is valid, false otherwise, this occurs when
72428:   // for some reason initialization of the drawtarget fails. If the canvas
72428:   // is invalid certain behavior is expected.
79445:   bool mValid;
72428:   // This is true when the canvas is valid, but of zero size, this requires
72428:   // specific behavior on some operations.
79445:   bool mZero;
79445: 
79445:   bool mOpaque;
72428: 
72428:   // This is true when the next time our layer is retrieved we need to
72428:   // recreate it (i.e. our backing surface changed)
79445:   bool mResetLayer;
72428:   // This is needed for drawing in drawAsyncXULElement
79445:   bool mIPC;
72428: 
72428:   // the canvas element we're a context of
72428:   nsCOMPtr<nsIDOMHTMLCanvasElement> mCanvasElement;
72428: 
72428:   // If mCanvasElement is not provided, then a docshell is
72428:   nsCOMPtr<nsIDocShell> mDocShell;
72428: 
72428:   // our drawing surfaces, contexts, and layers
72428:   RefPtr<DrawTarget> mTarget;
72428: 
72428:   /**
72428:     * Flag to avoid duplicate calls to InvalidateFrame. Set to true whenever
72428:     * Redraw is called, reset to false when Render is called.
72428:     */
79445:   bool mIsEntireFrameInvalid;
72428:   /**
72428:     * When this is set, the first call to Redraw(gfxRect) should set
72428:     * mIsEntireFrameInvalid since we expect it will be followed by
72428:     * many more Redraw calls.
72428:     */
79445:   bool mPredictManyRedrawCalls;
72428: 
72767:   // This is stored after GetThebesSurface has been called once to avoid
72767:   // excessive ThebesSurface initialization overhead.
72767:   nsRefPtr<gfxASurface> mThebesSurface;
72767: 
72428:   /**
72428:     * We also have a device space pathbuilder. The reason for this is as
72428:     * follows, when a path is being built, but the transform changes, we
72428:     * can no longer keep a single path in userspace, considering there's
72428:     * several 'user spaces' now. We therefore transform the current path
72428:     * into device space, and add all operations to this path in device
72428:     * space.
72428:     *
72428:     * When then finally executing a render, the Azure drawing API expects
72428:     * the path to be in userspace. We could then set an identity transform
72428:     * on the DrawTarget and do all drawing in device space. This is
72428:     * undesirable because it requires transforming patterns, gradients,
72428:     * clips, etc. into device space and it would not work for stroking.
72428:     * What we do instead is convert the path back to user space when it is
72428:     * drawn, and draw it with the current transform. This makes all drawing
72428:     * occur correctly.
72428:     *
72428:     * There's never both a device space path builder and a user space path
72428:     * builder present at the same time. There is also never a path and a
72428:     * path builder present at the same time. When writing proceeds on an
72428:     * existing path the Path is cleared and a new builder is created.
72428:     *
72428:     * mPath is always in user-space.
72428:     */
72428:   RefPtr<Path> mPath;
72428:   RefPtr<PathBuilder> mDSPathBuilder;
72428:   RefPtr<PathBuilder> mPathBuilder;
72428:   bool mPathTransformWillUpdate;
72428:   Matrix mPathToDS;
72428: 
72428:   /**
72428:     * Number of times we've invalidated before calling redraw
72428:     */
72428:   PRUint32 mInvalidateCount;
72428:   static const PRUint32 kCanvasMaxInvalidateCount = 100;
72428: 
72428:   /**
72428:     * Returns true if a shadow should be drawn along with a
72428:     * drawing operation.
72428:     */
79445:   bool NeedToDrawShadow()
72428:   {
72428:     const ContextState& state = CurrentState();
72428: 
72428:     // The spec says we should not draw shadows if the operator is OVER.
72428:     // If it's over and the alpha value is zero, nothing needs to be drawn.
73032:     return NS_GET_A(state.shadowColor) != 0 && 
73032:       (state.shadowBlur != 0 || state.shadowOffset.x != 0 || state.shadowOffset.y != 0);
73032:   }
73032: 
73032:   CompositionOp UsedOperation()
73032:   {
73032:     if (NeedToDrawShadow()) {
73032:       // In this case the shadow rendering will use the operator.
73032:       return OP_OVER;
73032:     }
73032: 
73032:     return CurrentState().op;
72428:   }
72428: 
72428:   /**
72428:     * Gets the pres shell from either the canvas element or the doc shell
72428:     */
72428:   nsIPresShell *GetPresShell() {
77547:     nsCOMPtr<nsIContent> content = do_QueryObject(mCanvasElement);
72428:     if (content) {
80527:       return content->OwnerDoc()->GetShell();
72428:     }
72428:     if (mDocShell) {
72428:       nsCOMPtr<nsIPresShell> shell;
72428:       mDocShell->GetPresShell(getter_AddRefs(shell));
72428:       return shell.get();
72428:     }
72428:     return nsnull;
72428:   }
72428: 
72428:   // text
72428:   enum TextAlign {
72428:     TEXT_ALIGN_START,
72428:     TEXT_ALIGN_END,
72428:     TEXT_ALIGN_LEFT,
72428:     TEXT_ALIGN_RIGHT,
72428:     TEXT_ALIGN_CENTER
72428:   };
72428: 
72428:   enum TextBaseline {
72428:     TEXT_BASELINE_TOP,
72428:     TEXT_BASELINE_HANGING,
72428:     TEXT_BASELINE_MIDDLE,
72428:     TEXT_BASELINE_ALPHABETIC,
72428:     TEXT_BASELINE_IDEOGRAPHIC,
72428:     TEXT_BASELINE_BOTTOM
72428:   };
72428: 
72428:   gfxFontGroup *GetCurrentFontStyle();
72428: 
72428:   enum TextDrawOperation {
72428:     TEXT_DRAW_OPERATION_FILL,
72428:     TEXT_DRAW_OPERATION_STROKE,
72428:     TEXT_DRAW_OPERATION_MEASURE
72428:   };
72428: 
72428:   /*
72428:     * Implementation of the fillText, strokeText, and measure functions with
72428:     * the operation abstracted to a flag.
72428:     */
72428:   nsresult DrawOrMeasureText(const nsAString& text,
72428:                               float x,
72428:                               float y,
72428:                               float maxWidth,
72428:                               TextDrawOperation op,
72428:                               float* aWidth);
72428: 
72428:   // state stack handling
72428:   class ContextState {
72428:   public:
72428:       ContextState() : textAlign(TEXT_ALIGN_START),
72428:                        textBaseline(TEXT_BASELINE_ALPHABETIC),
72428:                        lineWidth(1.0f),
72428:                        miterLimit(10.0f),
72428:                        globalAlpha(1.0f),
72428:                        shadowBlur(0.0),
72744:                        dashOffset(0.0f),
72428:                        op(OP_OVER),
72428:                        fillRule(FILL_WINDING),
72428:                        lineCap(CAP_BUTT),
72428:                        lineJoin(JOIN_MITER_OR_BEVEL),
80486:                        imageSmoothingEnabled(true)
72428:       { }
72428: 
72428:       ContextState(const ContextState& other)
72428:           : fontGroup(other.fontGroup),
72428:             font(other.font),
72428:             textAlign(other.textAlign),
72428:             textBaseline(other.textBaseline),
72428:             shadowColor(other.shadowColor),
72428:             transform(other.transform),
72428:             shadowOffset(other.shadowOffset),
72428:             lineWidth(other.lineWidth),
72428:             miterLimit(other.miterLimit),
72428:             globalAlpha(other.globalAlpha),
72428:             shadowBlur(other.shadowBlur),
72744:             dash(other.dash),
72744:             dashOffset(other.dashOffset),
72428:             op(other.op),
72428:             fillRule(FILL_WINDING),
72428:             lineCap(other.lineCap),
72428:             lineJoin(other.lineJoin),
72428:             imageSmoothingEnabled(other.imageSmoothingEnabled)
72428:       {
72428:           for (int i = 0; i < STYLE_MAX; i++) {
72428:               colorStyles[i] = other.colorStyles[i];
72428:               gradientStyles[i] = other.gradientStyles[i];
72428:               patternStyles[i] = other.patternStyles[i];
72428:           }
72428:       }
72428: 
72428:       void SetColorStyle(Style whichStyle, nscolor color) {
72428:           colorStyles[whichStyle] = color;
72428:           gradientStyles[whichStyle] = nsnull;
72428:           patternStyles[whichStyle] = nsnull;
72428:       }
72428: 
72428:       void SetPatternStyle(Style whichStyle, nsCanvasPatternAzure* pat) {
72428:           gradientStyles[whichStyle] = nsnull;
72428:           patternStyles[whichStyle] = pat;
72428:       }
72428: 
72428:       void SetGradientStyle(Style whichStyle, nsCanvasGradientAzure* grad) {
72428:           gradientStyles[whichStyle] = grad;
72428:           patternStyles[whichStyle] = nsnull;
72428:       }
72428: 
72428:       /**
72428:         * returns true iff the given style is a solid color.
72428:         */
79445:       bool StyleIsColor(Style whichStyle) const
72428:       {
72428:           return !(patternStyles[whichStyle] ||
72428:                     gradientStyles[whichStyle]);
72428:       }
72428: 
72428: 
72428:       std::vector<RefPtr<Path> > clipsPushed;
72428: 
72428:       nsRefPtr<gfxFontGroup> fontGroup;
72428:       nsRefPtr<nsCanvasGradientAzure> gradientStyles[STYLE_MAX];
72428:       nsRefPtr<nsCanvasPatternAzure> patternStyles[STYLE_MAX];
72428: 
72428:       nsString font;
72428:       TextAlign textAlign;
72428:       TextBaseline textBaseline;
72428: 
72428:       nscolor colorStyles[STYLE_MAX];
72428:       nscolor shadowColor;
72428: 
72428:       Matrix transform;
72428:       Point shadowOffset;
72428:       Float lineWidth;
72428:       Float miterLimit;
72428:       Float globalAlpha;
72428:       Float shadowBlur;
72744:       FallibleTArray<Float> dash;
72744:       Float dashOffset;
72428: 
72428:       CompositionOp op;
72428:       FillRule fillRule;
72428:       CapStyle lineCap;
72428:       JoinStyle lineJoin;
72428: 
79445:       bool imageSmoothingEnabled;
72428:   };
72428: 
72428:   class GeneralPattern
72428:   {
72428:   public:
72428:     GeneralPattern() : mPattern(nsnull) {}
72428:     ~GeneralPattern()
72428:     {
72428:       if (mPattern) {
72428:         mPattern->~Pattern();
72428:       }
72428:     }
72428: 
72428:     Pattern& ForStyle(nsCanvasRenderingContext2DAzure *aCtx,
72428:                       Style aStyle,
72428:                       DrawTarget *aRT)
72428:     {
72428:       // This should only be called once or the mPattern destructor will
72428:       // not be executed.
72428:       NS_ASSERTION(!mPattern, "ForStyle() should only be called once on GeneralPattern!");
72428: 
72428:       const nsCanvasRenderingContext2DAzure::ContextState &state = aCtx->CurrentState();
72428: 
72428:       if (state.StyleIsColor(aStyle)) {
72428:         mPattern = new (mColorPattern.addr()) ColorPattern(Color::FromABGR(state.colorStyles[aStyle]));
72428:       } else if (state.gradientStyles[aStyle] &&
72428:                  state.gradientStyles[aStyle]->GetType() == nsCanvasGradientAzure::LINEAR) {
72428:         nsCanvasLinearGradientAzure *gradient =
72428:           static_cast<nsCanvasLinearGradientAzure*>(state.gradientStyles[aStyle].get());
72428: 
72428:         mPattern = new (mLinearGradientPattern.addr())
72428:           LinearGradientPattern(gradient->mBegin, gradient->mEnd,
72428:                                 gradient->GetGradientStopsForTarget(aRT));
72428:       } else if (state.gradientStyles[aStyle] &&
72428:                  state.gradientStyles[aStyle]->GetType() == nsCanvasGradientAzure::RADIAL) {
72428:         nsCanvasRadialGradientAzure *gradient =
72428:           static_cast<nsCanvasRadialGradientAzure*>(state.gradientStyles[aStyle].get());
72428: 
72428:         mPattern = new (mRadialGradientPattern.addr())
73619:           RadialGradientPattern(gradient->mCenter1, gradient->mCenter2, gradient->mRadius1,
73619:                                 gradient->mRadius2, gradient->GetGradientStopsForTarget(aRT));
72428:       } else if (state.patternStyles[aStyle]) {
72428:         if (aCtx->mCanvasElement) {
72428:           CanvasUtils::DoDrawImageSecurityCheck(aCtx->HTMLCanvasElement(),
72428:                                                 state.patternStyles[aStyle]->mPrincipal,
78159:                                                 state.patternStyles[aStyle]->mForceWriteOnly,
78159:                                                 state.patternStyles[aStyle]->mCORSUsed);
72428:         }
72428: 
72428:         ExtendMode mode;
72428:         if (state.patternStyles[aStyle]->mRepeat == nsCanvasPatternAzure::NOREPEAT) {
72428:           mode = EXTEND_CLAMP;
72428:         } else {
86250:           mode = EXTEND_REPEAT;
72428:         }
72428:         mPattern = new (mSurfacePattern.addr())
72428:           SurfacePattern(state.patternStyles[aStyle]->mSurface, mode);
72428:       }
72428: 
72428:       return *mPattern;
72428:     }
72428: 
72428:     union {
72428:       AlignedStorage2<ColorPattern> mColorPattern;
72428:       AlignedStorage2<LinearGradientPattern> mLinearGradientPattern;
72428:       AlignedStorage2<RadialGradientPattern> mRadialGradientPattern;
72428:       AlignedStorage2<SurfacePattern> mSurfacePattern;
72428:     };
72428:     Pattern *mPattern;
72428:   };
72428: 
72428:   /* This is an RAII based class that can be used as a drawtarget for
72428:    * operations that need a shadow drawn. It will automatically provide a
72428:    * temporary target when needed, and if so blend it back with a shadow.
73777:    *
73777:    * aBounds specifies the bounds of the drawing operation that will be
73777:    * drawn to the target, it is given in device space! This function will
73777:    * change aBounds to incorporate shadow bounds. If this is NULL the drawing
73777:    * operation will be assumed to cover an infinite rect.
72428:    */
72428:   class AdjustedTarget
72428:   {
72428:   public:
72428:     AdjustedTarget(nsCanvasRenderingContext2DAzure *ctx,
73777:                    mgfx::Rect *aBounds = nsnull)
72428:       : mCtx(nsnull)
72428:     {
72428:       if (!ctx->NeedToDrawShadow()) {
72428:         mTarget = ctx->mTarget;
72428:         return;
72428:       }
72428:       mCtx = ctx;
72428: 
72428:       const ContextState &state = mCtx->CurrentState();
72428: 
72428:       mSigma = state.shadowBlur / 2.0f;
72428: 
72428:       if (mSigma > SIGMA_MAX) {
72428:         mSigma = SIGMA_MAX;
72428:       }
72428:         
72428:       Matrix transform = mCtx->mTarget->GetTransform();
73777: 
73777:       mTempRect = mgfx::Rect(0, 0, ctx->mWidth, ctx->mHeight);
73777: 
73777:       Float blurRadius = mSigma * 3;
73777: 
73777:       // We need to enlarge and possibly offset our temporary surface
72428:       // so that things outside of the canvas may cast shadows.
73777:       mTempRect.Inflate(Margin(blurRadius + NS_MAX<Float>(state.shadowOffset.x, 0),
73777:                                blurRadius + NS_MAX<Float>(state.shadowOffset.y, 0),
73777:                                blurRadius + NS_MAX<Float>(-state.shadowOffset.x, 0),
73777:                                blurRadius + NS_MAX<Float>(-state.shadowOffset.y, 0)));
73777: 
73777:       if (aBounds) {
73777:         // We actually include the bounds of the shadow blur, this makes it
73777:         // easier to execute the actual blur on hardware, and shouldn't affect
73777:         // the amount of pixels that need to be touched.
73777:         aBounds->Inflate(Margin(blurRadius, blurRadius,
73777:                                 blurRadius, blurRadius));
73777:         mTempRect = mTempRect.Intersect(*aBounds);
73777:       }
73777: 
73777:       mTempRect.ScaleRoundOut(1.0f);
73777: 
73777:       transform._31 -= mTempRect.x;
73777:       transform._32 -= mTempRect.y;
72428:         
72428:       mTarget =
73777:         mCtx->mTarget->CreateSimilarDrawTarget(IntSize(int32_t(mTempRect.width), int32_t(mTempRect.height)),
72428:                                                FORMAT_B8G8R8A8);
72428: 
72428:       if (!mTarget) {
72428:         // XXX - Deal with the situation where our temp size is too big to
72428:         // fit in a texture.
72428:         mTarget = ctx->mTarget;
72428:         mCtx = nsnull;
73777:       } else {
73777:         mTarget->SetTransform(transform);
72428:       }
72428:     }
72428: 
72428:     ~AdjustedTarget()
72428:     {
72428:       if (!mCtx) {
72428:         return;
72428:       }
72428: 
72428:       RefPtr<SourceSurface> snapshot = mTarget->Snapshot();
72428:       
73777:       mCtx->mTarget->DrawSurfaceWithShadow(snapshot, mTempRect.TopLeft(),
72428:                                            Color::FromABGR(mCtx->CurrentState().shadowColor),
73032:                                            mCtx->CurrentState().shadowOffset, mSigma,
73032:                                            mCtx->CurrentState().op);
72428:     }
72428: 
72428:     DrawTarget* operator->()
72428:     {
72428:       return mTarget;
72428:     }
72428: 
72428:   private:
72428:     RefPtr<DrawTarget> mTarget;
72428:     nsCanvasRenderingContext2DAzure *mCtx;
72428:     Float mSigma;
73777:     mgfx::Rect mTempRect;
72428:   };
72428: 
72428:   nsAutoTArray<ContextState, 3> mStyleStack;
72428: 
72428:   inline ContextState& CurrentState() {
72428:     return mStyleStack[mStyleStack.Length() - 1];
72428:   }
72428:     
72428:   // other helpers
72428:   void GetAppUnitsValues(PRUint32 *perDevPixel, PRUint32 *perCSSPixel) {
72428:     // If we don't have a canvas element, we just return something generic.
72428:     PRUint32 devPixel = 60;
72428:     PRUint32 cssPixel = 60;
72428: 
72428:     nsIPresShell *ps = GetPresShell();
72428:     nsPresContext *pc;
72428: 
72428:     if (!ps) goto FINISH;
72428:     pc = ps->GetPresContext();
72428:     if (!pc) goto FINISH;
72428:     devPixel = pc->AppUnitsPerDevPixel();
72428:     cssPixel = pc->AppUnitsPerCSSPixel();
72428: 
72428:   FINISH:
72428:     if (perDevPixel)
72428:       *perDevPixel = devPixel;
72428:     if (perCSSPixel)
72428:       *perCSSPixel = cssPixel;
72428:   }
72428: 
72428:   friend struct nsCanvasBidiProcessorAzure;
72428: };
72428: 
72428: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsCanvasRenderingContext2DAzure)
72428: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsCanvasRenderingContext2DAzure)
72428: 
72428: NS_IMPL_CYCLE_COLLECTION_CLASS(nsCanvasRenderingContext2DAzure)
72428: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsCanvasRenderingContext2DAzure)
72428:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCanvasElement)
72428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
72428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsCanvasRenderingContext2DAzure)
72428:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCanvasElement)
72428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
72428: 
72428: // XXX
72428: // DOMCI_DATA(CanvasRenderingContext2D, nsCanvasRenderingContext2DAzure)
72428: 
72428: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsCanvasRenderingContext2DAzure)
72428:   NS_INTERFACE_MAP_ENTRY(nsIDOMCanvasRenderingContext2D)
72428:   NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextInternal)
72428:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMCanvasRenderingContext2D)
72428:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasRenderingContext2D)
72428: NS_INTERFACE_MAP_END
72428: 
72428: /**
72428:  ** CanvasRenderingContext2D impl
72428:  **/
72428: 
72428: 
72428: // Initialize our static variables.
72428: PRUint32 nsCanvasRenderingContext2DAzure::sNumLivingContexts = 0;
72428: PRUint8 (*nsCanvasRenderingContext2DAzure::sUnpremultiplyTable)[256] = nsnull;
72428: PRUint8 (*nsCanvasRenderingContext2DAzure::sPremultiplyTable)[256] = nsnull;
72428: 
72428: nsresult
72428: NS_NewCanvasRenderingContext2DAzure(nsIDOMCanvasRenderingContext2D** aResult)
72428: {
82173: #ifdef XP_WIN
82414:   if ((gfxWindowsPlatform::GetPlatform()->GetRenderMode() !=
82173:       gfxWindowsPlatform::RENDER_DIRECT2D ||
82414:       !gfxWindowsPlatform::GetPlatform()->DWriteEnabled()) &&
82414:       !Preferences::GetBool("gfx.canvas.azure.prefer-skia", false)) {
82173:     return NS_ERROR_NOT_AVAILABLE;
82173:   }
88607: #elif !defined(XP_MACOSX) && !defined(ANDROID) && !defined(LINUX)
81280:   return NS_ERROR_NOT_AVAILABLE;
81280: #endif
72428: 
72428:   nsRefPtr<nsIDOMCanvasRenderingContext2D> ctx = new nsCanvasRenderingContext2DAzure();
72428:   if (!ctx)
72428:     return NS_ERROR_OUT_OF_MEMORY;
72428: 
72428:   *aResult = ctx.forget().get();
72428:   return NS_OK;
72428: }
72428: 
72428: nsCanvasRenderingContext2DAzure::nsCanvasRenderingContext2DAzure()
80486:   : mValid(false), mZero(false), mOpaque(false), mResetLayer(true)
80486:   , mIPC(false)
72428:   , mCanvasElement(nsnull)
80486:   , mIsEntireFrameInvalid(false)
80486:   , mPredictManyRedrawCalls(false), mPathTransformWillUpdate(false)
72428:   , mInvalidateCount(0)
72428: {
72428:   sNumLivingContexts++;
72428: }
72428: 
72428: nsCanvasRenderingContext2DAzure::~nsCanvasRenderingContext2DAzure()
72428: {
72428:   Reset();
72428:   sNumLivingContexts--;
72428:   if (!sNumLivingContexts) {
72428:     delete[] sUnpremultiplyTable;
72428:     delete[] sPremultiplyTable;
72428:     sUnpremultiplyTable = nsnull;
72428:     sPremultiplyTable = nsnull;
72428:   }
72428: }
72428: 
72428: nsresult
72428: nsCanvasRenderingContext2DAzure::Reset()
72428: {
72428:   if (mCanvasElement) {
72428:     HTMLCanvasElement()->InvalidateCanvas();
72428:   }
72428: 
72428:   // only do this for non-docshell created contexts,
72428:   // since those are the ones that we created a surface for
72428:   if (mValid && !mDocShell) {
72428:     gCanvasAzureMemoryUsed -= mWidth * mHeight * 4;
72428:   }
72428: 
72428:   mTarget = nsnull;
72767: 
72767:   // Since the target changes the backing texture will change, and this will
72767:   // no longer be valid.
72767:   mThebesSurface = nsnull;
80486:   mValid = false;
80486:   mIsEntireFrameInvalid = false;
80486:   mPredictManyRedrawCalls = false;
72767: 
72428:   return NS_OK;
72428: }
72428: 
72428: nsresult
72428: nsCanvasRenderingContext2DAzure::SetStyleFromStringOrInterface(const nsAString& aStr,
72428:                                                                nsISupports *aInterface,
72428:                                                                Style aWhichStyle)
72428: {
72428:   nsresult rv;
72428:   nscolor color;
72428: 
72428:   if (!aStr.IsVoid()) {
72428:     nsIDocument* document = mCanvasElement ?
80526:                             HTMLCanvasElement()->OwnerDoc() : nsnull;
72428: 
72428:     // Pass the CSS Loader object to the parser, to allow parser error
72428:     // reports to include the outer window ID.
72428:     nsCSSParser parser(document ? document->CSSLoader() : nsnull);
72428:     rv = parser.ParseColorString(aStr, nsnull, 0, &color);
72428:     if (NS_FAILED(rv)) {
72428:       // Error reporting happens inside the CSS parser
72428:       return NS_OK;
72428:     }
72428: 
72428:     CurrentState().SetColorStyle(aWhichStyle, color);
72428:     return NS_OK;
72428:   }
72428: 
72428:   if (aInterface) {
72428:     nsCOMPtr<nsCanvasGradientAzure> grad(do_QueryInterface(aInterface));
72428:     if (grad) {
72428:       CurrentState().SetGradientStyle(aWhichStyle, grad);
72428:       return NS_OK;
72428:     }
72428: 
72428:     nsCOMPtr<nsCanvasPatternAzure> pattern(do_QueryInterface(aInterface));
72428:     if (pattern) {
72428:       CurrentState().SetPatternStyle(aWhichStyle, pattern);
72428:       return NS_OK;
72428:     }
72428:   }
72428: 
72428:   nsContentUtils::ReportToConsole(
72428:     nsIScriptError::warningFlag,
72428:     "Canvas",
84636:     mCanvasElement ? HTMLCanvasElement()->OwnerDoc() : nsnull,
84636:     nsContentUtils::eDOM_PROPERTIES,
84636:     "UnexpectedCanvasVariantStyle");
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: nsresult
72428: nsCanvasRenderingContext2DAzure::GetStyleAsStringOrInterface(nsAString& aStr,
72428:                                                              nsISupports **aInterface,
72428:                                                              PRInt32 *aType,
72428:                                                              Style aWhichStyle)
72428: {
72428:   const ContextState &state = CurrentState();
72428: 
72428:   if (state.patternStyles[aWhichStyle]) {
80486:     aStr.SetIsVoid(true);
72428:     NS_ADDREF(*aInterface = state.patternStyles[aWhichStyle]);
72428:     *aType = CMG_STYLE_PATTERN;
72428:   } else if (state.gradientStyles[aWhichStyle]) {
80486:     aStr.SetIsVoid(true);
72428:     NS_ADDREF(*aInterface = state.gradientStyles[aWhichStyle]);
72428:     *aType = CMG_STYLE_GRADIENT;
72428:   } else {
72428:     StyleColorToString(state.colorStyles[aWhichStyle], aStr);
72428:     *aInterface = nsnull;
72428:     *aType = CMG_STYLE_STRING;
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::StyleColorToString(const nscolor& aColor, nsAString& aStr)
72428: {
72428:   // We can't reuse the normal CSS color stringification code,
72428:   // because the spec calls for a different algorithm for canvas.
72428:   if (NS_GET_A(aColor) == 255) {
72428:     CopyUTF8toUTF16(nsPrintfCString(100, "#%02x%02x%02x",
72428:                                     NS_GET_R(aColor),
72428:                                     NS_GET_G(aColor),
72428:                                     NS_GET_B(aColor)),
72428:                     aStr);
72428:   } else {
72428:     CopyUTF8toUTF16(nsPrintfCString(100, "rgba(%d, %d, %d, ",
72428:                                     NS_GET_R(aColor),
72428:                                     NS_GET_G(aColor),
72428:                                     NS_GET_B(aColor)),
72428:                     aStr);
72428:     aStr.AppendFloat(nsStyleUtil::ColorComponentToFloat(NS_GET_A(aColor)));
72428:     aStr.Append(')');
72428:   }
72428: }
72428: 
72428: nsresult
72428: nsCanvasRenderingContext2DAzure::Redraw()
72428: {
72428:   if (mIsEntireFrameInvalid) {
72428:     return NS_OK;
72428:   }
72428: 
80486:   mIsEntireFrameInvalid = true;
72428: 
72428:   if (!mCanvasElement) {
72428:     NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
72428:     return NS_OK;
72428:   }
72428: 
87516:   if (!mThebesSurface)
87516:     mThebesSurface =
87516:       gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mTarget);
86770:   mThebesSurface->MarkDirty();
86770: 
72428:   nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
72428: 
72428:   HTMLCanvasElement()->InvalidateCanvasContent(nsnull);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::Redraw(const mgfx::Rect &r)
72428: {
72428:   ++mInvalidateCount;
72428: 
72428:   if (mIsEntireFrameInvalid) {
72428:     return;
72428:   }
72428: 
72428:   if (mPredictManyRedrawCalls ||
72428:     mInvalidateCount > kCanvasMaxInvalidateCount) {
72428:     Redraw();
72428:     return;
72428:   }
72428: 
72428:   if (!mCanvasElement) {
72428:     NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
72428:     return;
72428:   }
72428: 
87516:   if (!mThebesSurface)
87516:     mThebesSurface =
87516:       gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mTarget);
86770:   mThebesSurface->MarkDirty();
86770: 
72428:   nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
72428: 
86660:   gfxRect tmpR = ThebesRect(r);
72428:   HTMLCanvasElement()->InvalidateCanvasContent(&tmpR);
72428: 
72428:   return;
72428: }
72428: 
72428: nsresult
72428: nsCanvasRenderingContext2DAzure::RedrawUser(const gfxRect& r)
72428: {
72428:   if (mIsEntireFrameInvalid) {
72428:     ++mInvalidateCount;
72428:     return NS_OK;
72428:   }
72428: 
72428:   mgfx::Rect newr =
72428:     mTarget->GetTransform().TransformBounds(ToRect(r));
72428:   Redraw(newr);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetDimensions(PRInt32 width, PRInt32 height)
72428: {
72428:   RefPtr<DrawTarget> target;
72428: 
72428:   // Zero sized surfaces cause issues, so just go with 1x1.
72428:   if (height == 0 || width == 0) {
80486:     mZero = true;
72428:     height = 1;
72428:     width = 1;
73712:   } else {
80486:     mZero = false;
72428:   }
72428: 
72428:   // Check that the dimensions are sane
72428:   IntSize size(width, height);
72428:   if (size.width <= 0xFFFF && size.height <= 0xFFFF &&
72428:       size.width >= 0 && size.height >= 0) {
72428:     SurfaceFormat format = GetSurfaceFormat();
77547:     nsCOMPtr<nsIContent> content = do_QueryObject(mCanvasElement);
72428:     nsIDocument* ownerDoc = nsnull;
72428:     if (content) {
80526:       ownerDoc = content->OwnerDoc();
72428:     }
72428: 
72428:     nsRefPtr<LayerManager> layerManager = nsnull;
72428: 
72428:     if (ownerDoc) {
72428:       layerManager =
72428:         nsContentUtils::PersistentLayerManagerForDocument(ownerDoc);
72428:     }
72428: 
72428:     if (layerManager) {
72428:       target = layerManager->CreateDrawTarget(size, format);
72428:     } else {
81280:       target = gfxPlatform::GetPlatform()->CreateOffscreenDrawTarget(size, format);
72428:     }
72428:   }
72428: 
72428:   if (target) {
72428:     if (gCanvasAzureMemoryReporter == nsnull) {
72428:         gCanvasAzureMemoryReporter = new NS_MEMORY_REPORTER_NAME(CanvasAzureMemory);
72428:       NS_RegisterMemoryReporter(gCanvasAzureMemoryReporter);
72428:     }
72428: 
72428:     gCanvasAzureMemoryUsed += width * height * 4;
80870:     JSContext* context = nsContentUtils::GetCurrentJSContext();
80870:     if (context) {
80870:       JS_updateMallocCounter(context, width * height * 4);
80870:     }
72428:   }
72428: 
72428:   return InitializeWithTarget(target, width, height);
72428: }
72428: 
72428: nsresult
72428: nsCanvasRenderingContext2DAzure::InitializeWithTarget(DrawTarget *target, PRInt32 width, PRInt32 height)
72428: {
72428:   Reset();
72428: 
72428:   NS_ASSERTION(mCanvasElement, "Must have a canvas element!");
72428:   mDocShell = nsnull;
72428: 
72428:   mWidth = width;
72428:   mHeight = height;
72428: 
90442:   // This first time this is called on this object is via
90442:   // nsHTMLCanvasElement::GetContext. If target was non-null then mTarget is
90442:   // non-null, otherwise we'll return an error here and GetContext won't
90442:   // return this context object and we'll never enter this code again.
90442:   // All other times this method is called, if target is null then
90442:   // mTarget won't be changed, i.e. it will remain non-null, or else it
90442:   // will be set to non-null.
90442:   // In all cases, any usable canvas context will have non-null mTarget.
90442: 
90442:   if (target) {
90442:     mValid = true;
72428:     mTarget = target;
90442:   } else {
90442:     mValid = false;
90442:   }
72428: 
80486:   mResetLayer = true;
72428: 
72428:   // set up the initial canvas defaults
72428:   mStyleStack.Clear();
72428:   mPathBuilder = nsnull;
72428:   mPath = nsnull;
72428:   mDSPathBuilder = nsnull;
72428: 
72428:   ContextState *state = mStyleStack.AppendElement();
72428:   state->globalAlpha = 1.0;
72428: 
72428:   state->colorStyles[STYLE_FILL] = NS_RGB(0,0,0);
72428:   state->colorStyles[STYLE_STROKE] = NS_RGB(0,0,0);
72428:   state->shadowColor = NS_RGBA(0,0,0,0);
72428: 
90442:   if (mTarget) {
72428:     mTarget->ClearRect(mgfx::Rect(Point(0, 0), Size(mWidth, mHeight)));
72428:     // always force a redraw, because if the surface dimensions were reset
72428:     // then the surface became cleared, and we need to redraw everything.
72428:     Redraw();
90442:   }
72428: 
72428:   return mValid ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
72428: }
72428: 
72428: NS_IMETHODIMP
79445: nsCanvasRenderingContext2DAzure::SetIsOpaque(bool isOpaque)
72428: {
72428:   if (isOpaque == mOpaque)
72428:     return NS_OK;
72428: 
72428:   mOpaque = isOpaque;
72428: 
72428:   if (mValid) {
72428:     /* If we've already been created, let SetDimensions take care of
72428:       * recreating our surface
72428:       */
72428:     return SetDimensions(mWidth, mHeight);
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
79445: nsCanvasRenderingContext2DAzure::SetIsIPC(bool isIPC)
72428: {
72428:   if (isIPC == mIPC)
72428:       return NS_OK;
72428: 
72428:   mIPC = isIPC;
72428: 
72428:   if (mValid) {
72428:     /* If we've already been created, let SetDimensions take care of
72428:       * recreating our surface
72428:       */
72428:     return SetDimensions(mWidth, mHeight);
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Render(gfxContext *ctx, gfxPattern::GraphicsFilter aFilter)
72428: {
72428:   nsresult rv = NS_OK;
72428: 
72428:   if (!mValid || !mTarget) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsRefPtr<gfxASurface> surface;
72428:   
72428:   if (NS_FAILED(GetThebesSurface(getter_AddRefs(surface)))) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsRefPtr<gfxPattern> pat = new gfxPattern(surface);
72428: 
72428:   pat->SetFilter(aFilter);
72428:   pat->SetExtend(gfxPattern::EXTEND_PAD);
72428: 
72428:   gfxContext::GraphicsOperator op = ctx->CurrentOperator();
72428:   if (mOpaque)
72428:       ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
72428: 
72428:   // XXX I don't want to use PixelSnapped here, but layout doesn't guarantee
72428:   // pixel alignment for this stuff!
72428:   ctx->NewPath();
72428:   ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
72428:   ctx->Fill();
72428: 
72428:   if (mOpaque)
72428:       ctx->SetOperator(op);
72428: 
72428:   return rv;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetInputStream(const char *aMimeType,
72428:                                                 const PRUnichar *aEncoderOptions,
72428:                                                 nsIInputStream **aStream)
72428: {
72428:   if (!mValid || !mTarget) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsRefPtr<gfxASurface> surface;
72428: 
72428:   if (NS_FAILED(GetThebesSurface(getter_AddRefs(surface)))) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsresult rv;
72428:   const char encoderPrefix[] = "@mozilla.org/image/encoder;2?type=";
72428:   nsAutoArrayPtr<char> conid(new (std::nothrow) char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);
72428: 
72428:   if (!conid) {
72428:     return NS_ERROR_OUT_OF_MEMORY;
72428:   }
72428: 
72428:   strcpy(conid, encoderPrefix);
72428:   strcat(conid, aMimeType);
72428: 
72428:   nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);
72428:   if (!encoder) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsAutoArrayPtr<PRUint8> imageBuffer(new (std::nothrow) PRUint8[mWidth * mHeight * 4]);
72428:   if (!imageBuffer) {
72428:     return NS_ERROR_OUT_OF_MEMORY;
72428:   }
72428: 
72428:   nsRefPtr<gfxImageSurface> imgsurf =
72428:     new gfxImageSurface(imageBuffer.get(),
72428:                         gfxIntSize(mWidth, mHeight),
72428:                         mWidth * 4,
72428:                         gfxASurface::ImageFormatARGB32);
72428: 
72428:   if (!imgsurf || imgsurf->CairoStatus()) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsRefPtr<gfxContext> ctx = new gfxContext(imgsurf);
72428: 
72428:   if (!ctx || ctx->HasError()) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
72428:   ctx->SetSource(surface, gfxPoint(0, 0));
72428:   ctx->Paint();
72428: 
72428:   rv = encoder->InitFromData(imageBuffer.get(),
72428:                               mWidth * mHeight * 4, mWidth, mHeight, mWidth * 4,
72428:                               imgIEncoder::INPUT_FORMAT_HOSTARGB,
72428:                               nsDependentString(aEncoderOptions));
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   return CallQueryInterface(encoder, aStream);
72428: }
72428: 
72428: SurfaceFormat
72428: nsCanvasRenderingContext2DAzure::GetSurfaceFormat() const
72428: {
72428:   return mOpaque ? FORMAT_B8G8R8X8 : FORMAT_B8G8R8A8;
72428: }
72428: 
72428: //
72428: // nsCanvasRenderingContext2DAzure impl
72428: //
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetCanvasElement(nsHTMLCanvasElement* aCanvasElement)
72428: {
72428:   mCanvasElement = aCanvasElement;
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetCanvas(nsIDOMHTMLCanvasElement **canvas)
72428: {
72428:   NS_IF_ADDREF(*canvas = mCanvasElement);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: //
72428: // state
72428: //
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Save()
72428: {
72428:   mStyleStack[mStyleStack.Length() - 1].transform = mTarget->GetTransform();
72428:   mStyleStack.SetCapacity(mStyleStack.Length() + 1);
72428:   mStyleStack.AppendElement(CurrentState());
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Restore()
72428: {
72428:   if (mStyleStack.Length() - 1 == 0)
72428:     return NS_OK;
72428: 
72428:   for (PRUint32 i = 0; i < CurrentState().clipsPushed.size(); i++) {
72428:     mTarget->PopClip();
72428:   }
72428: 
72428:   mStyleStack.RemoveElementAt(mStyleStack.Length() - 1);
72428: 
72428:   TransformWillUpdate();
72428: 
72428:   mTarget->SetTransform(CurrentState().transform);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: //
72428: // transformations
72428: //
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Scale(float x, float y)
72428: {
72428:   if (!FloatValidate(x,y))
72428:     return NS_OK;
72428: 
72428:   TransformWillUpdate();
72428: 
72428:   Matrix newMatrix = mTarget->GetTransform();
72428:   mTarget->SetTransform(newMatrix.Scale(x, y));
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Rotate(float angle)
72428: {
72428:   if (!FloatValidate(angle))
72428:     return NS_OK;
72428: 
72428:   TransformWillUpdate();
72428: 
72428:   Matrix rotation = Matrix::Rotation(angle);
72428:   mTarget->SetTransform(rotation * mTarget->GetTransform());
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Translate(float x, float y)
72428: {
72428:   if (!FloatValidate(x,y)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   TransformWillUpdate();
72428: 
72428:   Matrix newMatrix = mTarget->GetTransform();
72428:   mTarget->SetTransform(newMatrix.Translate(x, y));
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Transform(float m11, float m12, float m21, float m22, float dx, float dy)
72428: {
72428:   if (!FloatValidate(m11,m12,m21,m22,dx,dy)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   TransformWillUpdate();
72428: 
72428:   Matrix matrix(m11, m12, m21, m22, dx, dy);
72428:   mTarget->SetTransform(matrix * mTarget->GetTransform());
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetTransform(float m11, float m12, float m21, float m22, float dx, float dy)
72428: {
72428:   if (!FloatValidate(m11,m12,m21,m22,dx,dy)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   TransformWillUpdate();
72428: 
72428:   Matrix matrix(m11, m12, m21, m22, dx, dy);
72428:   mTarget->SetTransform(matrix);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72739: NS_IMETHODIMP
72739: nsCanvasRenderingContext2DAzure::SetMozCurrentTransform(JSContext* cx,
72739:                                                         const jsval& matrix)
72739: {
72739:   nsresult rv;
72739:   Matrix newCTM;
72739: 
72739:   if (!JSValToMatrix(cx, matrix, &newCTM, &rv)) {
72739:     return rv;
72739:   }
72739: 
72739:   mTarget->SetTransform(newCTM);
72739: 
72739:   return NS_OK;
72739: }
72739: 
72739: NS_IMETHODIMP
72739: nsCanvasRenderingContext2DAzure::GetMozCurrentTransform(JSContext* cx,
72739:                                                         jsval* matrix)
72739: {
72739:   return MatrixToJSVal(mTarget->GetTransform(), cx, matrix);
72739: }
72739: 
72739: NS_IMETHODIMP
72739: nsCanvasRenderingContext2DAzure::SetMozCurrentTransformInverse(JSContext* cx,
72739:                                                                const jsval& matrix)
72739: {
72739:   nsresult rv;
72739:   Matrix newCTMInverse;
72739: 
72739:   if (!JSValToMatrix(cx, matrix, &newCTMInverse, &rv)) {
72739:     return rv;
72739:   }
72739: 
72739:   // XXX ERRMSG we need to report an error to developers here! (bug 329026)
72739:   if (newCTMInverse.Invert()) {
72739:     mTarget->SetTransform(newCTMInverse);
72739:   }
72739: 
72739:   return NS_OK;
72739: }
72739: 
72739: NS_IMETHODIMP
72739: nsCanvasRenderingContext2DAzure::GetMozCurrentTransformInverse(JSContext* cx,
72739:                                                                jsval* matrix)
72739: {
72739:   Matrix ctm = mTarget->GetTransform();
72739: 
72739:   if (!ctm.Invert()) {
72739:     double NaN = JSVAL_TO_DOUBLE(JS_GetNaNValue(cx));
72739:     ctm = Matrix(NaN, NaN, NaN, NaN, NaN, NaN);
72739:   }
72739: 
72739:   return MatrixToJSVal(ctm, cx, matrix);
72739: }
72739: 
72428: //
72428: // colors
72428: //
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetGlobalAlpha(float aGlobalAlpha)
72428: {
72428:   if (!FloatValidate(aGlobalAlpha) || aGlobalAlpha < 0.0 || aGlobalAlpha > 1.0) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   CurrentState().globalAlpha = aGlobalAlpha;
72428:     
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetGlobalAlpha(float *aGlobalAlpha)
72428: {
72428:   *aGlobalAlpha = CurrentState().globalAlpha;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetStrokeStyle(nsIVariant *aValue)
72428: {
72428:   if (!aValue)
72428:       return NS_ERROR_FAILURE;
72428: 
72428:   nsString str;
72428: 
72428:   nsresult rv;
72428:   PRUint16 vtype;
72428:   rv = aValue->GetDataType(&vtype);
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   if (vtype == nsIDataType::VTYPE_INTERFACE ||
72428:       vtype == nsIDataType::VTYPE_INTERFACE_IS)
72428:   {
72428:     nsIID *iid;
72428:     nsCOMPtr<nsISupports> sup;
72428:     rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
72428:     NS_ENSURE_SUCCESS(rv, rv);
72428:     if (iid) {
72428:       NS_Free(iid);
72428:     }
72428: 
80486:     str.SetIsVoid(true);
72428:     return SetStrokeStyle_multi(str, sup);
72428:   }
72428: 
72428:   rv = aValue->GetAsAString(str);
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   return SetStrokeStyle_multi(str, nsnull);
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetStrokeStyle(nsIVariant **aResult)
72428: {
72428:   nsCOMPtr<nsIWritableVariant> wv = do_CreateInstance(NS_VARIANT_CONTRACTID);
72428: 
72428:   nsCOMPtr<nsISupports> sup;
72428:   nsString str;
72428:   PRInt32 t;
72428:   nsresult rv = GetStrokeStyle_multi(str, getter_AddRefs(sup), &t);
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   if (t == CMG_STYLE_STRING) {
72428:     rv = wv->SetAsAString(str);
72428:   } else if (t == CMG_STYLE_PATTERN) {
72428:     rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasPattern),
72428:                             sup);
72428:   } else if (t == CMG_STYLE_GRADIENT) {
72428:     rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasGradient),
72428:                             sup);
72428:   } else {
72428:     NS_ERROR("Unknown type from GetStroke/FillStyle_multi!");
72428:     return NS_ERROR_FAILURE;
72428:   }
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   NS_IF_ADDREF(*aResult = wv.get());
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetFillStyle(nsIVariant *aValue)
72428: {
72428:   if (!aValue) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsString str;
72428:   nsresult rv;
72428:   PRUint16 vtype;
72428:   rv = aValue->GetDataType(&vtype);
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   if (vtype == nsIDataType::VTYPE_INTERFACE ||
72428:       vtype == nsIDataType::VTYPE_INTERFACE_IS)
72428:   {
72428:     nsIID *iid;
72428:     nsCOMPtr<nsISupports> sup;
72428:     rv = aValue->GetAsInterface(&iid, getter_AddRefs(sup));
72428:     NS_ENSURE_SUCCESS(rv, rv);
72428: 
80486:     str.SetIsVoid(true);
72428:     return SetFillStyle_multi(str, sup);
72428:   }
72428: 
72428:   rv = aValue->GetAsAString(str);
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   return SetFillStyle_multi(str, nsnull);
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetFillStyle(nsIVariant **aResult)
72428: {
72428:   nsCOMPtr<nsIWritableVariant> wv = do_CreateInstance(NS_VARIANT_CONTRACTID);
72428: 
72428:   nsCOMPtr<nsISupports> sup;
72428:   nsString str;
72428:   PRInt32 t;
72428:   nsresult rv = GetFillStyle_multi(str, getter_AddRefs(sup), &t);
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   if (t == CMG_STYLE_STRING) {
72428:     rv = wv->SetAsAString(str);
72428:   } else if (t == CMG_STYLE_PATTERN) {
72428:     rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasPattern),
72428:                             sup);
72428:   } else if (t == CMG_STYLE_GRADIENT) {
72428:     rv = wv->SetAsInterface(NS_GET_IID(nsIDOMCanvasGradient),
72428:                             sup);
72428:   } else {
72428:     NS_ERROR("Unknown type from GetStroke/FillStyle_multi!");
72428:     return NS_ERROR_FAILURE;
72428:   }
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   NS_IF_ADDREF(*aResult = wv.get());
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetMozFillRule(const nsAString& aString)
72428: {
72428:   FillRule rule;
72428: 
72428:   if (aString.EqualsLiteral("evenodd"))
72428:     rule = FILL_EVEN_ODD;
72428:   else if (aString.EqualsLiteral("nonzero"))
72428:     rule = FILL_WINDING;
72428:   else
72428:     return NS_OK;
72428: 
72428:   CurrentState().fillRule = rule;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetMozFillRule(nsAString& aString)
72428: {
72428:     switch (CurrentState().fillRule) {
72428:     case FILL_WINDING:
72428:         aString.AssignLiteral("nonzero"); break;
72428:     case FILL_EVEN_ODD:
72428:         aString.AssignLiteral("evenodd"); break;
72428:     }
72428: 
72428:     return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetStrokeStyle_multi(const nsAString& aStr, nsISupports *aInterface)
72428: {
72428:     return SetStyleFromStringOrInterface(aStr, aInterface, STYLE_STROKE);
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetStrokeStyle_multi(nsAString& aStr, nsISupports **aInterface, PRInt32 *aType)
72428: {
72428:     return GetStyleAsStringOrInterface(aStr, aInterface, aType, STYLE_STROKE);
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetFillStyle_multi(const nsAString& aStr, nsISupports *aInterface)
72428: {
72428:     return SetStyleFromStringOrInterface(aStr, aInterface, STYLE_FILL);
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetFillStyle_multi(nsAString& aStr, nsISupports **aInterface, PRInt32 *aType)
72428: {
72428:     return GetStyleAsStringOrInterface(aStr, aInterface, aType, STYLE_FILL);
72428: }
72428: 
72428: //
72428: // gradients and patterns
72428: //
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::CreateLinearGradient(float x0, float y0, float x1, float y1,
72428:                                                       nsIDOMCanvasGradient **_retval)
72428: {
72428:   if (!FloatValidate(x0,y0,x1,y1)) {
72428:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
72428:   }
72428: 
72428:   nsRefPtr<nsIDOMCanvasGradient> grad =
72428:     new nsCanvasLinearGradientAzure(Point(x0, y0), Point(x1, y1));
72428: 
72428:   *_retval = grad.forget().get();
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::CreateRadialGradient(float x0, float y0, float r0,
72428:                                                       float x1, float y1, float r1,
72428:                                                       nsIDOMCanvasGradient **_retval)
72428: {
72428:   if (!FloatValidate(x0,y0,r0,x1,y1,r1)) {
72428:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
72428:   }
72428: 
72428:   if (r0 < 0.0 || r1 < 0.0) {
72428:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
72428:   }
72428: 
72428:   nsRefPtr<nsIDOMCanvasGradient> grad =
72428:     new nsCanvasRadialGradientAzure(Point(x0, y0), r0, Point(x1, y1), r1);
72428: 
72428:   *_retval = grad.forget().get();
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::CreatePattern(nsIDOMHTMLElement *image,
72428:                                                const nsAString& repeat,
72428:                                                nsIDOMCanvasPattern **_retval)
72428: {
83345:   nsCOMPtr<nsIContent> content = do_QueryInterface(image);
83345:   if (!content) {
72428:     return NS_ERROR_DOM_TYPE_MISMATCH_ERR;
72428:   }
72428: 
72428:   nsCanvasPatternAzure::RepeatMode repeatMode =
72428:     nsCanvasPatternAzure::NOREPEAT;
72428: 
72428:   if (repeat.IsEmpty() || repeat.EqualsLiteral("repeat")) {
72428:     repeatMode = nsCanvasPatternAzure::REPEAT;
72428:   } else if (repeat.EqualsLiteral("repeat-x")) {
72428:     repeatMode = nsCanvasPatternAzure::REPEATX;
72428:   } else if (repeat.EqualsLiteral("repeat-y")) {
72428:     repeatMode = nsCanvasPatternAzure::REPEATY;
72428:   } else if (repeat.EqualsLiteral("no-repeat")) {
72428:     repeatMode = nsCanvasPatternAzure::NOREPEAT;
72428:   } else {
72428:     return NS_ERROR_DOM_SYNTAX_ERR;
72428:   }
72428: 
72428:   nsHTMLCanvasElement* canvas = nsHTMLCanvasElement::FromContent(content);
72428:   if (canvas) {
72428:     nsIntSize size = canvas->GetSize();
72428:     if (size.width == 0 || size.height == 0) {
72428:       return NS_ERROR_DOM_INVALID_STATE_ERR;
72428:     }
72428: 
72428:     // Special case for Canvas, which could be an Azure canvas!
72428:     nsICanvasRenderingContextInternal *srcCanvas = canvas->GetContextAtIndex(0);
84360:     if (srcCanvas) {
72428:       // This might not be an Azure canvas!
72428:       RefPtr<SourceSurface> srcSurf = srcCanvas->GetSurfaceSnapshot();
72428: 
72428:       nsRefPtr<nsCanvasPatternAzure> pat =
80486:         new nsCanvasPatternAzure(srcSurf, repeatMode, content->NodePrincipal(), canvas->IsWriteOnly(), false);
72428: 
72428:       *_retval = pat.forget().get();
72428:       return NS_OK;
72428:     }
72428:   }
72428: 
72428:   // The canvas spec says that createPattern should use the first frame
72428:   // of animated images
72428:   nsLayoutUtils::SurfaceFromElementResult res =
83345:     nsLayoutUtils::SurfaceFromElement(content->AsElement(),
83345:       nsLayoutUtils::SFE_WANT_FIRST_FRAME | nsLayoutUtils::SFE_WANT_NEW_SURFACE);
72428: 
72428:   if (!res.mSurface) {
72428:     return NS_ERROR_NOT_AVAILABLE;
72428:   }
72428: 
72428:   // Ignore nsnull cairo surfaces! See bug 666312.
72428:   if (!res.mSurface->CairoSurface()) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   RefPtr<SourceSurface> srcSurf =
72428:     gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mTarget, res.mSurface);
72428: 
72428:   nsRefPtr<nsCanvasPatternAzure> pat =
78159:     new nsCanvasPatternAzure(srcSurf, repeatMode, res.mPrincipal,
78159:                              res.mIsWriteOnly, res.mCORSUsed);
72428: 
72428:   *_retval = pat.forget().get();
72428:   return NS_OK;
72428: }
72428: 
72428: //
72428: // shadows
72428: //
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetShadowOffsetX(float x)
72428: {
72428:   if (!FloatValidate(x)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   CurrentState().shadowOffset.x = x;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetShadowOffsetX(float *x)
72428: {
72428:   *x = static_cast<float>(CurrentState().shadowOffset.x);
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetShadowOffsetY(float y)
72428: {
72428:   if (!FloatValidate(y)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   CurrentState().shadowOffset.y = y;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetShadowOffsetY(float *y)
72428: {
72428:   *y = static_cast<float>(CurrentState().shadowOffset.y);
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetShadowBlur(float blur)
72428: {
72428:   if (!FloatValidate(blur) || blur < 0.0) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   CurrentState().shadowBlur = blur;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetShadowBlur(float *blur)
72428: {
72428:   *blur = CurrentState().shadowBlur;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetShadowColor(const nsAString& colorstr)
72428: {
72428:   nsIDocument* document = mCanvasElement ?
80526:                           HTMLCanvasElement()->OwnerDoc() : nsnull;
72428: 
72428:   // Pass the CSS Loader object to the parser, to allow parser error reports
72428:   // to include the outer window ID.
72428:   nsCSSParser parser(document ? document->CSSLoader() : nsnull);
72428:   nscolor color;
72428:   nsresult rv = parser.ParseColorString(colorstr, nsnull, 0, &color);
72428:   if (NS_FAILED(rv)) {
72428:     // Error reporting happens inside the CSS parser
72428:     return NS_OK;
72428:   }
72428:   CurrentState().shadowColor = color;
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetShadowColor(nsAString& color)
72428: {
72428:   StyleColorToString(CurrentState().shadowColor, color);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: //
72428: // rects
72428: //
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::ClearRect(float x, float y, float w, float h)
72428: {
72428:   if (!FloatValidate(x,y,w,h)) {
72428:     return NS_OK;
72428:   }
72428:  
72428:   mTarget->ClearRect(mgfx::Rect(x, y, w, h));
72428: 
72428:   return RedrawUser(gfxRect(x, y, w, h));
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::FillRect(float x, float y, float w, float h)
72428: {
72428:   if (!FloatValidate(x,y,w,h)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   const ContextState &state = CurrentState();
72428: 
72428:   if (state.patternStyles[STYLE_FILL]) {
72428:     nsCanvasPatternAzure::RepeatMode repeat = 
72428:       state.patternStyles[STYLE_FILL]->mRepeat;
72428:     // In the FillRect case repeat modes are easy to deal with.
72428:     bool limitx = repeat == nsCanvasPatternAzure::NOREPEAT || repeat == nsCanvasPatternAzure::REPEATY;
72428:     bool limity = repeat == nsCanvasPatternAzure::NOREPEAT || repeat == nsCanvasPatternAzure::REPEATX;
72428: 
72428:     IntSize patternSize =
72428:       state.patternStyles[STYLE_FILL]->mSurface->GetSize();
72428: 
72428:     // We always need to execute painting for non-over operators, even if
72428:     // we end up with w/h = 0.
72428:     if (limitx) {
72428:       if (x < 0) {
72428:         w += x;
72428:         if (w < 0) {
72428:           w = 0;
72428:         }
72428: 
72428:         x = 0;
72428:       }
72428:       if (x + w > patternSize.width) {
72428:         w = patternSize.width - x;
72428:         if (w < 0) {
72428:           w = 0;
72428:         }
72428:       }
72428:     }
72428:     if (limity) {
72428:       if (y < 0) {
72428:         h += y;
72428:         if (h < 0) {
72428:           h = 0;
72428:         }
72428: 
72428:         y = 0;
72428:       }
72428:       if (y + h > patternSize.height) {
72428:         h = patternSize.height - y;
72428:         if (h < 0) {
72428:           h = 0;
72428:         }
72428:       }
72428:     }
72428:   }
72428: 
73777:   mgfx::Rect bounds;
73777:   
73777:   if (NeedToDrawShadow()) {
73777:     bounds = mgfx::Rect(x, y, w, h);
73777:     bounds = mTarget->GetTransform().TransformBounds(bounds);
73777:   }
73777: 
73777:   AdjustedTarget(this, bounds.IsEmpty() ? nsnull : &bounds)->
73777:     FillRect(mgfx::Rect(x, y, w, h),
72428:              GeneralPattern().ForStyle(this, STYLE_FILL, mTarget),
73032:              DrawOptions(state.globalAlpha, UsedOperation()));
72428: 
72428:   return RedrawUser(gfxRect(x, y, w, h));
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::StrokeRect(float x, float y, float w, float h)
72428: {
72428:   if (!FloatValidate(x,y,w,h)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   const ContextState &state = CurrentState();
72428: 
73777:   mgfx::Rect bounds;
73777:   
73777:   if (NeedToDrawShadow()) {
73777:     bounds = mgfx::Rect(x - state.lineWidth / 2.0f, y - state.lineWidth / 2.0f,
73777:                         w + state.lineWidth, h + state.lineWidth);
73777:     bounds = mTarget->GetTransform().TransformBounds(bounds);
73777:   }
73777: 
72428:   if (!w && !h) {
72428:     return NS_OK;
72428:   } else if (!h) {
72428:     CapStyle cap = CAP_BUTT;
72428:     if (state.lineJoin == JOIN_ROUND) {
72428:       cap = CAP_ROUND;
72428:     }
73777:     AdjustedTarget(this, bounds.IsEmpty() ? nsnull : &bounds)->
72428:       StrokeLine(Point(x, y), Point(x + w, y),
72428:                   GeneralPattern().ForStyle(this, STYLE_STROKE, mTarget),
72428:                   StrokeOptions(state.lineWidth, state.lineJoin,
72744:                                 cap, state.miterLimit,
72744:                                 state.dash.Length(),
72744:                                 state.dash.Elements(),
72744:                                 state.dashOffset),
73032:                   DrawOptions(state.globalAlpha, UsedOperation()));
72428:     return NS_OK;
72428:   } else if (!w) {
72428:     CapStyle cap = CAP_BUTT;
72428:     if (state.lineJoin == JOIN_ROUND) {
72428:       cap = CAP_ROUND;
72428:     }
73777:     AdjustedTarget(this, bounds.IsEmpty() ? nsnull : &bounds)->
72428:       StrokeLine(Point(x, y), Point(x, y + h),
72428:                   GeneralPattern().ForStyle(this, STYLE_STROKE, mTarget),
72428:                   StrokeOptions(state.lineWidth, state.lineJoin,
72744:                                 cap, state.miterLimit,
72744:                                 state.dash.Length(),
72744:                                 state.dash.Elements(),
72744:                                 state.dashOffset),
73032:                   DrawOptions(state.globalAlpha, UsedOperation()));
72428:     return NS_OK;
72428:   }
72428: 
73777:   AdjustedTarget(this, bounds.IsEmpty() ? nsnull : &bounds)->
72428:     StrokeRect(mgfx::Rect(x, y, w, h),
72428:                 GeneralPattern().ForStyle(this, STYLE_STROKE, mTarget),
72428:                 StrokeOptions(state.lineWidth, state.lineJoin,
72744:                               state.lineCap, state.miterLimit,
72744:                               state.dash.Length(),
72744:                               state.dash.Elements(),
72744:                               state.dashOffset),
73032:                 DrawOptions(state.globalAlpha, UsedOperation()));
72428: 
72428:   return Redraw();
72428: }
72428: 
72428: //
72428: // path bits
72428: //
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::BeginPath()
72428: {
72428:   mPath = nsnull;
72428:   mPathBuilder = nsnull;
72428:   mDSPathBuilder = nsnull;
72428:   mPathTransformWillUpdate = false;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::ClosePath()
72428: {
72428:   EnsureWritablePath();
72428: 
72428:   if (mPathBuilder) {
72428:     mPathBuilder->Close();
72428:   } else {
72428:     mDSPathBuilder->Close();
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Fill()
72428: {
72428:   EnsureUserSpacePath();
72428: 
72428:   if (!mPath) {
72428:     return NS_OK;
72428:   }
72428: 
73777:   mgfx::Rect bounds;
73777: 
73777:   if (NeedToDrawShadow()) {
73777:     bounds = mPath->GetBounds(mTarget->GetTransform());
73777:   }
73777: 
73777:   AdjustedTarget(this, bounds.IsEmpty() ? nsnull : &bounds)->
72428:     Fill(mPath, GeneralPattern().ForStyle(this, STYLE_FILL, mTarget),
73032:          DrawOptions(CurrentState().globalAlpha, UsedOperation()));
72428: 
72428:   return Redraw();
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Stroke()
72428: {
72428:   EnsureUserSpacePath();
72428: 
72428:   if (!mPath) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   const ContextState &state = CurrentState();
72428: 
73777:   StrokeOptions strokeOptions(state.lineWidth, state.lineJoin,
73777:                               state.lineCap, state.miterLimit,
73777:                               state.dash.Length(), state.dash.Elements(),
73777:                               state.dashOffset);
73777: 
73777:   mgfx::Rect bounds;
73777:   if (NeedToDrawShadow()) {
73777:     bounds =
73777:       mPath->GetStrokedBounds(strokeOptions, mTarget->GetTransform());
73777:   }
73777: 
73777:   AdjustedTarget(this, bounds.IsEmpty() ? nsnull : &bounds)->
72428:     Stroke(mPath, GeneralPattern().ForStyle(this, STYLE_STROKE, mTarget),
73777:            strokeOptions, DrawOptions(state.globalAlpha, UsedOperation()));
72428: 
72428:   return Redraw();
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Clip()
72428: {
72428:   EnsureUserSpacePath();
72428: 
72428:   if (!mPath) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   mTarget->PushClip(mPath);
72428:   CurrentState().clipsPushed.push_back(mPath);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::MoveTo(float x, float y)
72428: {
72428:   if (!FloatValidate(x,y))
72428:       return NS_OK;
72428: 
72428:   EnsureWritablePath();
72428: 
72428:   if (mPathBuilder) {
72428:     mPathBuilder->MoveTo(Point(x, y));
72428:   } else {
72428:     mDSPathBuilder->MoveTo(mTarget->GetTransform() * Point(x, y));
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::LineTo(float x, float y)
72428: {
72428:   if (!FloatValidate(x,y))
72428:       return NS_OK;
72428: 
72428:   EnsureWritablePath();
72428:     
81282:   return LineTo(Point(x, y));;
81282: }
81282:   
81282: nsresult 
81282: nsCanvasRenderingContext2DAzure::LineTo(const Point& aPoint)
81282: {
72428:   if (mPathBuilder) {
81282:     mPathBuilder->LineTo(aPoint);
72428:   } else {
81282:     mDSPathBuilder->LineTo(mTarget->GetTransform() * aPoint);
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::QuadraticCurveTo(float cpx, float cpy, float x, float y)
72428: {
72428:   if (!FloatValidate(cpx, cpy, x, y)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   EnsureWritablePath();
72428: 
72428:   if (mPathBuilder) {
72428:     mPathBuilder->QuadraticBezierTo(Point(cpx, cpy), Point(x, y));
72428:   } else {
72428:     Matrix transform = mTarget->GetTransform();
80174:     mDSPathBuilder->QuadraticBezierTo(transform * Point(cpx, cpy), transform * Point(x, y));
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::BezierCurveTo(float cp1x, float cp1y,
72428:                                               float cp2x, float cp2y,
72428:                                               float x, float y)
72428: {
72428:   if (!FloatValidate(cp1x, cp1y, cp2x, cp2y, x, y)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   EnsureWritablePath();
72428: 
81282:   return BezierTo(Point(cp1x, cp1y), Point(cp2x, cp2y), Point(x, y));
81282: }
81282: 
81282: nsresult
81282: nsCanvasRenderingContext2DAzure::BezierTo(const Point& aCP1,
81282:                                           const Point& aCP2,
81282:                                           const Point& aCP3)
81282: {
72428:   if (mPathBuilder) {
81282:     mPathBuilder->BezierTo(aCP1, aCP2, aCP3);
72428:   } else {
72428:     Matrix transform = mTarget->GetTransform();
81282:     mDSPathBuilder->BezierTo(transform * aCP1,
81282:                               transform * aCP2,
81282:                               transform * aCP3);
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::ArcTo(float x1, float y1, float x2, float y2, float radius)
72428: {
72428:   if (!FloatValidate(x1, y1, x2, y2, radius)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   if (radius < 0) {
72428:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
72428:   }
72428: 
72428:   EnsureWritablePath();
72428: 
72428:   // Current point in user space!
72428:   Point p0;
72428:   if (mPathBuilder) {
72428:     p0 = mPathBuilder->CurrentPoint();
72428:   } else {
72428:     Matrix invTransform = mTarget->GetTransform();
72428:     if (!invTransform.Invert()) {
72428:       return NS_OK;
72428:     }
72428: 
72428:     p0 = invTransform * mDSPathBuilder->CurrentPoint();
72428:   }
72428: 
72428:   Point p1(x1, y1);
72428:   Point p2(x2, y2);
72428: 
72428:   // Execute these calculations in double precision to avoid cumulative
72428:   // rounding errors.
72428:   double dir, a2, b2, c2, cosx, sinx, d, anx, any,
72428:           bnx, bny, x3, y3, x4, y4, cx, cy, angle0, angle1;
72428:   bool anticlockwise;
72428: 
72428:   if (p0 == p1 || p1 == p2 || radius == 0) {
72428:     LineTo(p1.x, p1.y);
72428:     return NS_OK;
72428:   }
72428: 
72428:   // Check for colinearity
72428:   dir = (p2.x - p1.x) * (p0.y - p1.y) + (p2.y - p1.y) * (p1.x - p0.x);
72428:   if (dir == 0) {
72428:     LineTo(p1.x, p1.y);
72428:     return NS_OK;
72428:   }
72428: 
72428: 
72428:   // XXX - Math for this code was already available from the non-azure code
72428:   // and would be well tested. Perhaps converting to bezier directly might
72428:   // be more efficient longer run.
72428:   a2 = (p0.x-x1)*(p0.x-x1) + (p0.y-y1)*(p0.y-y1);
72428:   b2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
72428:   c2 = (p0.x-x2)*(p0.x-x2) + (p0.y-y2)*(p0.y-y2);
72428:   cosx = (a2+b2-c2)/(2*sqrt(a2*b2));
72428: 
72428:   sinx = sqrt(1 - cosx*cosx);
72428:   d = radius / ((1 - cosx) / sinx);
72428: 
72428:   anx = (x1-p0.x) / sqrt(a2);
72428:   any = (y1-p0.y) / sqrt(a2);
72428:   bnx = (x1-x2) / sqrt(b2);
72428:   bny = (y1-y2) / sqrt(b2);
72428:   x3 = x1 - anx*d;
72428:   y3 = y1 - any*d;
72428:   x4 = x1 - bnx*d;
72428:   y4 = y1 - bny*d;
72428:   anticlockwise = (dir < 0);
72428:   cx = x3 + any*radius*(anticlockwise ? 1 : -1);
72428:   cy = y3 - anx*radius*(anticlockwise ? 1 : -1);
72428:   angle0 = atan2((y3-cy), (x3-cx));
72428:   angle1 = atan2((y4-cy), (x4-cx));
72428: 
72428: 
72428:   LineTo(x3, y3);
72428: 
72428:   Arc(cx, cy, radius, angle0, angle1, anticlockwise);
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Arc(float x, float y,
72428:                                      float r,
72428:                                      float startAngle, float endAngle,
79445:                                      bool ccw)
72428: {
72428:   if (!FloatValidate(x, y, r, startAngle, endAngle)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   if (r < 0.0)
72428:       return NS_ERROR_DOM_INDEX_SIZE_ERR;
72428: 
72428:   EnsureWritablePath();
72428: 
81282:   ArcToBezier(this, Point(x, y), r, startAngle, endAngle, ccw);
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::Rect(float x, float y, float w, float h)
72428: {
72428:   if (!FloatValidate(x, y, w, h)) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   EnsureWritablePath();
72428: 
72428:   if (mPathBuilder) {
72428:     mPathBuilder->MoveTo(Point(x, y));
72428:     mPathBuilder->LineTo(Point(x + w, y));
72428:     mPathBuilder->LineTo(Point(x + w, y + h));
72428:     mPathBuilder->LineTo(Point(x, y + h));
72428:     mPathBuilder->Close();
72428:   } else {
72428:     mDSPathBuilder->MoveTo(mTarget->GetTransform() * Point(x, y));
72428:     mDSPathBuilder->LineTo(mTarget->GetTransform() * Point(x + w, y));
72428:     mDSPathBuilder->LineTo(mTarget->GetTransform() * Point(x + w, y + h));
72428:     mDSPathBuilder->LineTo(mTarget->GetTransform() * Point(x, y + h));
72428:     mDSPathBuilder->Close();
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::EnsureWritablePath()
72428: {
72428:   if (mDSPathBuilder) {
72428:     return;
72428:   }
72428: 
72428:   FillRule fillRule = CurrentState().fillRule;
72428: 
72428:   if (mPathBuilder) {
72428:     if (mPathTransformWillUpdate) {
72428:       mPath = mPathBuilder->Finish();
72428:       mDSPathBuilder =
72428:         mPath->TransformedCopyToBuilder(mPathToDS, fillRule);
72428:       mPath = nsnull;
72428:       mPathBuilder = nsnull;
72428:     }
72428:     return;
72428:   }
72428: 
72428:   if (!mPath) {
72428:     mPathBuilder = mTarget->CreatePathBuilder(fillRule);
72428:   } else if (!mPathTransformWillUpdate) {
72428:     mPathBuilder = mPath->CopyToBuilder(fillRule);
72428:   } else {
72428:     mDSPathBuilder =
72428:       mPath->TransformedCopyToBuilder(mPathToDS, fillRule);
72428:   }
72428: }
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::EnsureUserSpacePath()
72428: {
72428:   FillRule fillRule = CurrentState().fillRule;
72428: 
72428:   if (!mPath && !mPathBuilder && !mDSPathBuilder) {
72428:     mPathBuilder = mTarget->CreatePathBuilder(fillRule);
72428:   }
72428: 
72428:   if (mPathBuilder) {
72428:     mPath = mPathBuilder->Finish();
72428:     mPathBuilder = nsnull;
72428:   }
72428: 
72428:   if (mPath && mPathTransformWillUpdate) {
72428:     mDSPathBuilder =
72428:       mPath->TransformedCopyToBuilder(mPathToDS, fillRule);
72428:     mPath = nsnull;
72428:     mPathTransformWillUpdate = false;
72428:   }
72428: 
72428:   if (mDSPathBuilder) {
72428:     RefPtr<Path> dsPath;
72428:     dsPath = mDSPathBuilder->Finish();
72428:     mDSPathBuilder = nsnull;
72428: 
72428:     Matrix inverse = mTarget->GetTransform();
72428:     if (!inverse.Invert()) {
72428:       return;
72428:     }
72428: 
72428:     mPathBuilder =
72428:       dsPath->TransformedCopyToBuilder(inverse, fillRule);
72428:     mPath = mPathBuilder->Finish();
72428:     mPathBuilder = nsnull;
72428:   }
72428: 
72428:   if (mPath && mPath->GetFillRule() != fillRule) {
72428:     mPathBuilder = mPath->CopyToBuilder(fillRule);
72428:     mPath = mPathBuilder->Finish();
72428:   }
72428: }
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::TransformWillUpdate()
72428: {
72428:   // Store the matrix that would transform the current path to device
72428:   // space.
72428:   if (mPath || mPathBuilder) {
72428:     if (!mPathTransformWillUpdate) {
72428:       // If the transform has already been updated, but a device space builder
72428:       // has not been created yet mPathToDS contains the right transform to
72428:       // transform the current mPath into device space.
72428:       // We should leave it alone.
72428:       mPathToDS = mTarget->GetTransform();
72428:     }
72428:     mPathTransformWillUpdate = true;
72428:   }
72428: }
72428: 
72428: //
72428: // text
72428: //
72428: 
72428: /**
72428:  * Helper function for SetFont that creates a style rule for the given font.
72428:  * @param aFont The CSS font string
72428:  * @param aNode The canvas element
72428:  * @param aResult Pointer in which to place the new style rule.
72428:  * @remark Assumes all pointer arguments are non-null.
72428:  */
72428: static nsresult
72428: CreateFontStyleRule(const nsAString& aFont,
72428:                     nsINode* aNode,
72428:                     StyleRule** aResult)
72428: {
72428:   nsRefPtr<StyleRule> rule;
79445:   bool changed;
72428: 
72428:   nsIPrincipal* principal = aNode->NodePrincipal();
80526:   nsIDocument* document = aNode->OwnerDoc();
72428: 
72428:   nsIURI* docURL = document->GetDocumentURI();
72428:   nsIURI* baseURL = document->GetDocBaseURI();
72428: 
72428:   // Pass the CSS Loader object to the parser, to allow parser error reports
72428:   // to include the outer window ID.
72428:   nsCSSParser parser(document->CSSLoader());
72428: 
72428:   nsresult rv = parser.ParseStyleAttribute(EmptyString(), docURL, baseURL,
72428:                                             principal, getter_AddRefs(rule));
72428:   if (NS_FAILED(rv)) {
72428:     return rv;
72428:   }
72428: 
72428:   rv = parser.ParseProperty(eCSSProperty_font, aFont, docURL, baseURL,
72428:                             principal, rule->GetDeclaration(), &changed,
80486:                             false);
72428:   if (NS_FAILED(rv))
72428:     return rv;
72428: 
72428:   rv = parser.ParseProperty(eCSSProperty_line_height,
72428:                             NS_LITERAL_STRING("normal"), docURL, baseURL,
72428:                             principal, rule->GetDeclaration(), &changed,
80486:                             false);
72428:   if (NS_FAILED(rv)) {
72428:     return rv;
72428:   }
72428: 
72428:   rule->RuleMatched();
72428: 
72428:   rule.forget(aResult);
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetFont(const nsAString& font)
72428: {
72428:   nsresult rv;
72428: 
72428:   /*
72428:     * If font is defined with relative units (e.g. ems) and the parent
72428:     * style context changes in between calls, setting the font to the
72428:     * same value as previous could result in a different computed value,
72428:     * so we cannot have the optimization where we check if the new font
72428:     * string is equal to the old one.
72428:     */
72428: 
72428:   nsCOMPtr<nsIContent> content = do_QueryInterface(mCanvasElement);
72428:   if (!content && !mDocShell) {
72428:       NS_WARNING("Canvas element must be an nsIContent and non-null or a docshell must be provided");
72428:       return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsIPresShell* presShell = GetPresShell();
72428:   if (!presShell) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428:   nsIDocument* document = presShell->GetDocument();
72428: 
72428:   nsCOMArray<nsIStyleRule> rules;
72428: 
72428:   nsRefPtr<css::StyleRule> rule;
72428:   rv = CreateFontStyleRule(font, document, getter_AddRefs(rule));
72428: 
72428:   if (NS_FAILED(rv)) {
72428:     return rv;
72428:   }
72428: 
72428:   css::Declaration *declaration = rule->GetDeclaration();
72428:   // The easiest way to see whether we got a syntax error or whether
72428:   // we got 'inherit' or 'initial' is to look at font-size-adjust,
72428:   // which the shorthand resets to either 'none' or
72428:   // '-moz-system-font'.
72428:   // We know the declaration is not !important, so we can use
72428:   // GetNormalBlock().
72428:   const nsCSSValue *fsaVal =
72428:     declaration->GetNormalBlock()->ValueFor(eCSSProperty_font_size_adjust);
72428:   if (!fsaVal || (fsaVal->GetUnit() != eCSSUnit_None &&
72428:                   fsaVal->GetUnit() != eCSSUnit_System_Font)) {
72428:       // We got an all-property value or a syntax error.  The spec says
72428:       // this value must be ignored.
72428:     return NS_OK;
72428:   }
72428: 
72428:   rules.AppendObject(rule);
72428: 
72428:   nsStyleSet* styleSet = presShell->StyleSet();
72428: 
72428:   // have to get a parent style context for inherit-like relative
72428:   // values (2em, bolder, etc.)
72428:   nsRefPtr<nsStyleContext> parentContext;
72428: 
72428:   if (content && content->IsInDoc()) {
72428:       // inherit from the canvas element
72428:       parentContext = nsComputedDOMStyle::GetStyleContextForElement(
72428:               content->AsElement(),
72428:               nsnull,
72428:               presShell);
72428:   } else {
72428:     // otherwise inherit from default (10px sans-serif)
72428:     nsRefPtr<css::StyleRule> parentRule;
72428:     rv = CreateFontStyleRule(NS_LITERAL_STRING("10px sans-serif"),
72428:                               document,
72428:                               getter_AddRefs(parentRule));
72428: 
72428:     if (NS_FAILED(rv)) {
72428:       return rv;
72428:     }
72428: 
72428:     nsCOMArray<nsIStyleRule> parentRules;
72428:     parentRules.AppendObject(parentRule);
72428:     parentContext = styleSet->ResolveStyleForRules(nsnull, parentRules);
72428:   }
72428: 
72428:   if (!parentContext) {
72428:       return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsRefPtr<nsStyleContext> sc =
72428:       styleSet->ResolveStyleForRules(parentContext, rules);
72428:   if (!sc) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   const nsStyleFont* fontStyle = sc->GetStyleFont();
72428: 
72428:   NS_ASSERTION(fontStyle, "Could not obtain font style");
72428: 
88039:   nsIAtom* language = sc->GetStyleFont()->mLanguage;
72428:   if (!language) {
72428:     language = presShell->GetPresContext()->GetLanguageFromCharset();
72428:   }
72428: 
72428:   // use CSS pixels instead of dev pixels to avoid being affected by page zoom
72428:   const PRUint32 aupcp = nsPresContext::AppUnitsPerCSSPixel();
72428:   // un-zoom the font size to avoid being affected by text-only zoom
88469:   //
88469:   // Purposely ignore the font size that respects the user's minimum
88469:   // font preference (fontStyle->mFont.size) in favor of the computed
88469:   // size (fontStyle->mSize).  See
88469:   // https://bugzilla.mozilla.org/show_bug.cgi?id=698652.
88469:   const nscoord fontSize = nsStyleFont::UnZoomText(parentContext->PresContext(), fontStyle->mSize);
72428: 
79445:   bool printerFont = (presShell->GetPresContext()->Type() == nsPresContext::eContext_PrintPreview ||
72428:                         presShell->GetPresContext()->Type() == nsPresContext::eContext_Print);
72428: 
72428:   gfxFontStyle style(fontStyle->mFont.style,
72428:                       fontStyle->mFont.weight,
72428:                       fontStyle->mFont.stretch,
72428:                       NSAppUnitsToFloatPixels(fontSize, float(aupcp)),
72428:                       language,
72428:                       fontStyle->mFont.sizeAdjust,
72428:                       fontStyle->mFont.systemFont,
72428:                       printerFont,
72428:                       fontStyle->mFont.featureSettings,
72428:                       fontStyle->mFont.languageOverride);
72428: 
72428:   CurrentState().fontGroup =
72428:       gfxPlatform::GetPlatform()->CreateFontGroup(fontStyle->mFont.name,
72428:                                                   &style,
72428:                                                   presShell->GetPresContext()->GetUserFontSet());
72428:   NS_ASSERTION(CurrentState().fontGroup, "Could not get font group");
72428: 
72428:   // The font getter is required to be reserialized based on what we
72428:   // parsed (including having line-height removed).  (Older drafts of
72428:   // the spec required font sizes be converted to pixels, but that no
72428:   // longer seems to be required.)
72428:   declaration->GetValue(eCSSProperty_font, CurrentState().font);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetFont(nsAString& font)
72428: {
72428:   /* will initilize the value if not set, else does nothing */
72428:   GetCurrentFontStyle();
72428: 
72428:   font = CurrentState().font;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetTextAlign(const nsAString& ta)
72428: {
72428:   if (ta.EqualsLiteral("start"))
72428:     CurrentState().textAlign = TEXT_ALIGN_START;
72428:   else if (ta.EqualsLiteral("end"))
72428:     CurrentState().textAlign = TEXT_ALIGN_END;
72428:   else if (ta.EqualsLiteral("left"))
72428:     CurrentState().textAlign = TEXT_ALIGN_LEFT;
72428:   else if (ta.EqualsLiteral("right"))
72428:     CurrentState().textAlign = TEXT_ALIGN_RIGHT;
72428:   else if (ta.EqualsLiteral("center"))
72428:     CurrentState().textAlign = TEXT_ALIGN_CENTER;
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetTextAlign(nsAString& ta)
72428: {
72428:   switch (CurrentState().textAlign)
72428:   {
72428:   case TEXT_ALIGN_START:
72428:     ta.AssignLiteral("start");
72428:     break;
72428:   case TEXT_ALIGN_END:
72428:     ta.AssignLiteral("end");
72428:     break;
72428:   case TEXT_ALIGN_LEFT:
72428:     ta.AssignLiteral("left");
72428:     break;
72428:   case TEXT_ALIGN_RIGHT:
72428:     ta.AssignLiteral("right");
72428:     break;
72428:   case TEXT_ALIGN_CENTER:
72428:     ta.AssignLiteral("center");
72428:     break;
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetTextBaseline(const nsAString& tb)
72428: {
72428:   if (tb.EqualsLiteral("top"))
72428:     CurrentState().textBaseline = TEXT_BASELINE_TOP;
72428:   else if (tb.EqualsLiteral("hanging"))
72428:     CurrentState().textBaseline = TEXT_BASELINE_HANGING;
72428:   else if (tb.EqualsLiteral("middle"))
72428:     CurrentState().textBaseline = TEXT_BASELINE_MIDDLE;
72428:   else if (tb.EqualsLiteral("alphabetic"))
72428:     CurrentState().textBaseline = TEXT_BASELINE_ALPHABETIC;
72428:   else if (tb.EqualsLiteral("ideographic"))
72428:     CurrentState().textBaseline = TEXT_BASELINE_IDEOGRAPHIC;
72428:   else if (tb.EqualsLiteral("bottom"))
72428:     CurrentState().textBaseline = TEXT_BASELINE_BOTTOM;
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetTextBaseline(nsAString& tb)
72428: {
72428:   switch (CurrentState().textBaseline)
72428:   {
72428:   case TEXT_BASELINE_TOP:
72428:     tb.AssignLiteral("top");
72428:     break;
72428:   case TEXT_BASELINE_HANGING:
72428:     tb.AssignLiteral("hanging");
72428:     break;
72428:   case TEXT_BASELINE_MIDDLE:
72428:     tb.AssignLiteral("middle");
72428:     break;
72428:   case TEXT_BASELINE_ALPHABETIC:
72428:     tb.AssignLiteral("alphabetic");
72428:     break;
72428:   case TEXT_BASELINE_IDEOGRAPHIC:
72428:     tb.AssignLiteral("ideographic");
72428:     break;
72428:   case TEXT_BASELINE_BOTTOM:
72428:     tb.AssignLiteral("bottom");
72428:     break;
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: /*
72428:  * Helper function that replaces the whitespace characters in a string
72428:  * with U+0020 SPACE. The whitespace characters are defined as U+0020 SPACE,
72428:  * U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), U+000B LINE
72428:  * TABULATION, U+000C FORM FEED (FF), and U+000D CARRIAGE RETURN (CR).
72428:  * @param str The string whose whitespace characters to replace.
72428:  */
72428: static inline void
72428: TextReplaceWhitespaceCharacters(nsAutoString& str)
72428: {
72428:   str.ReplaceChar("\x09\x0A\x0B\x0C\x0D", PRUnichar(' '));
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::FillText(const nsAString& text, float x, float y, float maxWidth)
72428: {
72428:   return DrawOrMeasureText(text, x, y, maxWidth, TEXT_DRAW_OPERATION_FILL, nsnull);
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::StrokeText(const nsAString& text, float x, float y, float maxWidth)
72428: {
72428:   return DrawOrMeasureText(text, x, y, maxWidth, TEXT_DRAW_OPERATION_STROKE, nsnull);
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::MeasureText(const nsAString& rawText,
72428:                                       nsIDOMTextMetrics** _retval)
72428: {
72428:   float width;
72428: 
72428:   nsresult rv = DrawOrMeasureText(rawText, 0, 0, 0, TEXT_DRAW_OPERATION_MEASURE, &width);
72428: 
72428:   if (NS_FAILED(rv)) {
72428:     return rv;
72428:   }
72428: 
72428:   nsRefPtr<nsIDOMTextMetrics> textMetrics = new nsTextMetricsAzure(width);
72428:   if (!textMetrics.get()) {
72428:     return NS_ERROR_OUT_OF_MEMORY;
72428:   }
72428: 
72428:   *_retval = textMetrics.forget().get();
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: /**
72428:  * Used for nsBidiPresUtils::ProcessText
72428:  */
72428: struct NS_STACK_CLASS nsCanvasBidiProcessorAzure : public nsBidiPresUtils::BidiProcessor
72428: {
72744:   typedef nsCanvasRenderingContext2DAzure::ContextState ContextState;
72744: 
72428:   virtual void SetText(const PRUnichar* text, PRInt32 length, nsBidiDirection direction)
72428:   {
86690:     mTextRun = mFontgrp->MakeTextRun(text,
72428:                                      length,
72428:                                      mThebes,
72428:                                      mAppUnitsPerDevPixel,
72428:                                      direction==NSBIDI_RTL ? gfxTextRunFactory::TEXT_IS_RTL : 0);
72428:   }
72428: 
72428:   virtual nscoord GetWidth()
72428:   {
72428:     gfxTextRun::Metrics textRunMetrics = mTextRun->MeasureText(0,
72428:                                                                mTextRun->GetLength(),
72428:                                                                mDoMeasureBoundingBox ?
72428:                                                                  gfxFont::TIGHT_INK_EXTENTS :
72428:                                                                  gfxFont::LOOSE_INK_EXTENTS,
72428:                                                                mThebes,
72428:                                                                nsnull);
72428: 
72428:     // this only measures the height; the total width is gotten from the
72428:     // the return value of ProcessText.
72428:     if (mDoMeasureBoundingBox) {
72428:       textRunMetrics.mBoundingBox.Scale(1.0 / mAppUnitsPerDevPixel);
72428:       mBoundingBox = mBoundingBox.Union(textRunMetrics.mBoundingBox);
72428:     }
72428: 
72880:     return NSToCoordRound(textRunMetrics.mAdvanceWidth);
72428:   }
72428: 
72428:   virtual void DrawText(nscoord xOffset, nscoord width)
72428:   {
72428:     gfxPoint point = mPt;
84284:     point.x += xOffset;
72428: 
72428:     // offset is given in terms of left side of string
72428:     if (mTextRun->IsRightToLeft()) {
72428:       // Bug 581092 - don't use rounded pixel width to advance to
72428:       // right-hand end of run, because this will cause different
72428:       // glyph positioning for LTR vs RTL drawing of the same
72428:       // glyph string on OS X and DWrite where textrun widths may
72428:       // involve fractional pixels.
72428:       gfxTextRun::Metrics textRunMetrics =
72428:         mTextRun->MeasureText(0,
72428:                               mTextRun->GetLength(),
72428:                               mDoMeasureBoundingBox ?
72428:                                   gfxFont::TIGHT_INK_EXTENTS :
72428:                                   gfxFont::LOOSE_INK_EXTENTS,
72428:                               mThebes,
72428:                               nsnull);
72428:       point.x += textRunMetrics.mAdvanceWidth;
72428:       // old code was:
72428:       //   point.x += width * mAppUnitsPerDevPixel;
72428:       // TODO: restore this if/when we move to fractional coords
72428:       // throughout the text layout process
72428:     }
72428: 
72428:     PRUint32 numRuns;
72428:     const gfxTextRun::GlyphRun *runs = mTextRun->GetGlyphRuns(&numRuns);
72428:     const PRUint32 appUnitsPerDevUnit = mAppUnitsPerDevPixel;
72428:     const double devUnitsPerAppUnit = 1.0/double(appUnitsPerDevUnit);
72428:     Point baselineOrigin =
72428:       Point(point.x * devUnitsPerAppUnit, point.y * devUnitsPerAppUnit);
72428: 
80261:     float advanceSum = 0;
80261: 
72739:     for (PRUint32 c = 0; c < numRuns; c++) {
72428:       gfxFont *font = runs[c].mFont;
72428:       PRUint32 endRun = 0;
72428:       if (c + 1 < numRuns) {
72428:         endRun = runs[c + 1].mCharacterOffset;
72428:       } else {
72428:         endRun = mTextRun->GetLength();
72428:       }
72428: 
72428:       const gfxTextRun::CompressedGlyph *glyphs = mTextRun->GetCharacterGlyphs();
72428: 
72428:       RefPtr<ScaledFont> scaledFont =
72428:         gfxPlatform::GetPlatform()->GetScaledFontForFont(font);
72428: 
89584:       if (!scaledFont) {
89584:         // This can occur when something switched DirectWrite off.
89584:         return;
89584:       }
89584: 
72428:       GlyphBuffer buffer;
72428: 
72428:       std::vector<Glyph> glyphBuf;
72428: 
72739:       for (PRUint32 i = runs[c].mCharacterOffset; i < endRun; i++) {
72428:         Glyph newGlyph;
72428:         if (glyphs[i].IsSimpleGlyph()) {
72428:           newGlyph.mIndex = glyphs[i].GetSimpleGlyph();
72428:           if (mTextRun->IsRightToLeft()) {
72428:             newGlyph.mPosition.x = baselineOrigin.x - advanceSum -
72428:               glyphs[i].GetSimpleAdvance() * devUnitsPerAppUnit;
72428:           } else {
72428:             newGlyph.mPosition.x = baselineOrigin.x + advanceSum;
72428:           }
72428:           newGlyph.mPosition.y = baselineOrigin.y;
72428:           advanceSum += glyphs[i].GetSimpleAdvance() * devUnitsPerAppUnit;
72428:           glyphBuf.push_back(newGlyph);
72428:           continue;
72428:         }
72428: 
72428:         if (!glyphs[i].GetGlyphCount()) {
72428:           continue;
72428:         }
72428: 
72428:         gfxTextRun::DetailedGlyph *detailedGlyphs =
72428:           mTextRun->GetDetailedGlyphs(i);
72428: 
72739:         for (PRUint32 c = 0; c < glyphs[i].GetGlyphCount(); c++) {
72428:           newGlyph.mIndex = detailedGlyphs[c].mGlyphID;
72428:           if (mTextRun->IsRightToLeft()) {
72428:             newGlyph.mPosition.x = baselineOrigin.x + detailedGlyphs[c].mXOffset * devUnitsPerAppUnit -
72428:               advanceSum - detailedGlyphs[c].mAdvance * devUnitsPerAppUnit;
72428:           } else {
72428:             newGlyph.mPosition.x = baselineOrigin.x + detailedGlyphs[c].mXOffset * devUnitsPerAppUnit + advanceSum;
72428:           }
72428:           newGlyph.mPosition.y = baselineOrigin.y + detailedGlyphs[c].mYOffset * devUnitsPerAppUnit;
72428:           glyphBuf.push_back(newGlyph);
72428:           advanceSum += detailedGlyphs[c].mAdvance * devUnitsPerAppUnit;
72428:         }
72428:       }
72428: 
72520:       if (!glyphBuf.size()) {
72520:         // This may happen for glyph runs for a 0 size font.
72520:         continue;
72520:       }
72520: 
72428:       buffer.mGlyphs = &glyphBuf.front();
72428:       buffer.mNumGlyphs = glyphBuf.size();
72428: 
72428:       if (mOp == nsCanvasRenderingContext2DAzure::TEXT_DRAW_OPERATION_FILL) {
72428:         nsCanvasRenderingContext2DAzure::AdjustedTarget(mCtx)->
72428:           FillGlyphs(scaledFont, buffer,
72428:                       nsCanvasRenderingContext2DAzure::GeneralPattern().
72428:                         ForStyle(mCtx, nsCanvasRenderingContext2DAzure::STYLE_FILL, mCtx->mTarget),
73032:                       DrawOptions(mState->globalAlpha, mCtx->UsedOperation()));
72428:       } else if (mOp == nsCanvasRenderingContext2DAzure::TEXT_DRAW_OPERATION_STROKE) {
72428:         RefPtr<Path> path = scaledFont->GetPathForGlyphs(buffer, mCtx->mTarget);
72428: 
72744:         const ContextState& state = *mState;
72428:         nsCanvasRenderingContext2DAzure::AdjustedTarget(mCtx)->
72428:           Stroke(path, nsCanvasRenderingContext2DAzure::GeneralPattern().
72428:                     ForStyle(mCtx, nsCanvasRenderingContext2DAzure::STYLE_STROKE, mCtx->mTarget),
72744:                   StrokeOptions(state.lineWidth, state.lineJoin,
72744:                                 state.lineCap, state.miterLimit,
72744:                                 state.dash.Length(),
72744:                                 state.dash.Elements(),
72744:                                 state.dashOffset),
73032:                   DrawOptions(state.globalAlpha, mCtx->UsedOperation()));
72428: 
72428:       }
72428:     }
72428:   }
72428: 
72428:   // current text run
86690:   nsAutoPtr<gfxTextRun> mTextRun;
72428: 
72428:   // pointer to a screen reference context used to measure text and such
72428:   nsRefPtr<gfxContext> mThebes;
72428: 
72428:   // Pointer to the draw target we should fill our text to
72428:   nsCanvasRenderingContext2DAzure *mCtx;
72428: 
72428:   // position of the left side of the string, alphabetic baseline
72428:   gfxPoint mPt;
72428: 
72428:   // current font
72428:   gfxFontGroup* mFontgrp;
72428: 
72428:   // dev pixel conversion factor
72428:   PRUint32 mAppUnitsPerDevPixel;
72428: 
72428:   // operation (fill or stroke)
72428:   nsCanvasRenderingContext2DAzure::TextDrawOperation mOp;
72428: 
72428:   // context state
72744:   ContextState *mState;
72428: 
72428:   // union of bounding boxes of all runs, needed for shadows
72428:   gfxRect mBoundingBox;
72428: 
72428:   // true iff the bounding box should be measured
79445:   bool mDoMeasureBoundingBox;
72428: };
72428: 
72428: nsresult
72428: nsCanvasRenderingContext2DAzure::DrawOrMeasureText(const nsAString& aRawText,
72428:                                                    float aX,
72428:                                                    float aY,
72428:                                                    float aMaxWidth,
72428:                                                    TextDrawOperation aOp,
72428:                                                    float* aWidth)
72428: {
72428:   nsresult rv;
72428: 
72428:   if (!FloatValidate(aX, aY, aMaxWidth))
72428:       return NS_ERROR_DOM_SYNTAX_ERR;
72428: 
72428:   // spec isn't clear on what should happen if aMaxWidth <= 0, so
72428:   // treat it as an invalid argument
72428:   // technically, 0 should be an invalid value as well, but 0 is the default
72428:   // arg, and there is no way to tell if the default was used
72428:   if (aMaxWidth < 0)
72428:     return NS_ERROR_INVALID_ARG;
72428: 
72428:   nsCOMPtr<nsIContent> content = do_QueryInterface(mCanvasElement);
72428:   if (!content && !mDocShell) {
72428:       NS_WARNING("Canvas element must be an nsIContent and non-null or a docshell must be provided");
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   nsIPresShell* presShell = GetPresShell();
72428:   if (!presShell)
72428:       return NS_ERROR_FAILURE;
72428: 
72428:   nsIDocument* document = presShell->GetDocument();
72428: 
72428:   // replace all the whitespace characters with U+0020 SPACE
72428:   nsAutoString textToDraw(aRawText);
72428:   TextReplaceWhitespaceCharacters(textToDraw);
72428: 
72428:   // for now, default to ltr if not in doc
79445:   bool isRTL = false;
72428: 
72428:   if (content && content->IsInDoc()) {
72428:     // try to find the closest context
72428:     nsRefPtr<nsStyleContext> canvasStyle =
72428:       nsComputedDOMStyle::GetStyleContextForElement(content->AsElement(),
72428:                                                     nsnull,
72428:                                                     presShell);
72428:     if (!canvasStyle) {
72428:       return NS_ERROR_FAILURE;
72428:     }
72428: 
72428:     isRTL = canvasStyle->GetStyleVisibility()->mDirection ==
72428:       NS_STYLE_DIRECTION_RTL;
72428:   } else {
72428:     isRTL = GET_BIDI_OPTION_DIRECTION(document->GetBidiOptions()) == IBMBIDI_TEXTDIRECTION_RTL;
72428:   }
72428: 
72438:   const ContextState &state = CurrentState();
72428: 
72428:   // This is only needed to know if we can know the drawing bounding box easily.
79445:   bool doDrawShadow = aOp == TEXT_DRAW_OPERATION_FILL && NeedToDrawShadow();
72428: 
72428:   nsCanvasBidiProcessorAzure processor;
72428: 
72428:   GetAppUnitsValues(&processor.mAppUnitsPerDevPixel, nsnull);
72428:   processor.mPt = gfxPoint(aX, aY);
72428:   processor.mThebes =
72428:     new gfxContext(gfxPlatform::GetPlatform()->ScreenReferenceSurface());
72428:   Matrix matrix = mTarget->GetTransform();
72428:   processor.mThebes->SetMatrix(gfxMatrix(matrix._11, matrix._12, matrix._21, matrix._22, matrix._31, matrix._32));
72428:   processor.mCtx = this;
72428:   processor.mOp = aOp;
72428:   processor.mBoundingBox = gfxRect(0, 0, 0, 0);
72428:   processor.mDoMeasureBoundingBox = doDrawShadow || !mIsEntireFrameInvalid;
72428:   processor.mState = &CurrentState();
72428:     
72428: 
72428:   processor.mFontgrp = GetCurrentFontStyle();
72428:   NS_ASSERTION(processor.mFontgrp, "font group is null");
72428: 
72880:   nscoord totalWidthCoord;
72428: 
72428:   // calls bidi algo twice since it needs the full text width and the
72428:   // bounding boxes before rendering anything
73724:   nsBidi bidiEngine;
73724:   rv = nsBidiPresUtils::ProcessText(textToDraw.get(),
72428:                                 textToDraw.Length(),
72428:                                 isRTL ? NSBIDI_RTL : NSBIDI_LTR,
72428:                                 presShell->GetPresContext(),
72428:                                 processor,
72428:                                 nsBidiPresUtils::MODE_MEASURE,
72428:                                 nsnull,
72428:                                 0,
73724:                                 &totalWidthCoord,
73724:                                 &bidiEngine);
72428:   if (NS_FAILED(rv)) {
72428:     return rv;
72428:   }
72428: 
72880:   float totalWidth = float(totalWidthCoord) / processor.mAppUnitsPerDevPixel;
72428:   if (aWidth) {
72880:     *aWidth = totalWidth;
72428:   }
72428: 
72428:   // if only measuring, don't need to do any more work
72428:   if (aOp==TEXT_DRAW_OPERATION_MEASURE) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   // offset pt.x based on text align
72428:   gfxFloat anchorX;
72428: 
72428:   if (state.textAlign == TEXT_ALIGN_CENTER) {
72428:     anchorX = .5;
72428:   } else if (state.textAlign == TEXT_ALIGN_LEFT ||
72428:             (!isRTL && state.textAlign == TEXT_ALIGN_START) ||
72428:             (isRTL && state.textAlign == TEXT_ALIGN_END)) {
72428:     anchorX = 0;
72428:   } else {
72428:     anchorX = 1;
72428:   }
72428: 
72428:   processor.mPt.x -= anchorX * totalWidth;
72428: 
72428:   // offset pt.y based on text baseline
72428:   NS_ASSERTION(processor.mFontgrp->FontListLength()>0, "font group contains no fonts");
72428:   const gfxFont::Metrics& fontMetrics = processor.mFontgrp->GetFontAt(0)->GetMetrics();
72428: 
72428:   gfxFloat anchorY;
72428: 
72428:   switch (state.textBaseline)
72428:   {
72428:   case TEXT_BASELINE_HANGING:
72428:       // fall through; best we can do with the information available
72428:   case TEXT_BASELINE_TOP:
72428:     anchorY = fontMetrics.emAscent;
72428:     break;
72428:     break;
72428:   case TEXT_BASELINE_MIDDLE:
72428:     anchorY = (fontMetrics.emAscent - fontMetrics.emDescent) * .5f;
72428:     break;
72428:   case TEXT_BASELINE_IDEOGRAPHIC:
72428:     // fall through; best we can do with the information available
72428:   case TEXT_BASELINE_ALPHABETIC:
72428:     anchorY = 0;
72428:     break;
72428:   case TEXT_BASELINE_BOTTOM:
72428:     anchorY = -fontMetrics.emDescent;
72428:     break;
72428:   }
72428: 
72428:   processor.mPt.y += anchorY;
72428: 
72428:   // correct bounding box to get it to be the correct size/position
72428:   processor.mBoundingBox.width = totalWidth;
72428:   processor.mBoundingBox.MoveBy(processor.mPt);
72428: 
72428:   processor.mPt.x *= processor.mAppUnitsPerDevPixel;
72428:   processor.mPt.y *= processor.mAppUnitsPerDevPixel;
72428: 
72428:   Matrix oldTransform = mTarget->GetTransform();
72428:   // if text is over aMaxWidth, then scale the text horizontally such that its
72428:   // width is precisely aMaxWidth
72428:   if (aMaxWidth > 0 && totalWidth > aMaxWidth) {
72428:     Matrix newTransform = oldTransform;
72428: 
72428:     // Translate so that the anchor point is at 0,0, then scale and then
72428:     // translate back.
72428:     newTransform.Translate(aX, 0);
72428:     newTransform.Scale(aMaxWidth / totalWidth, 1);
72428:     newTransform.Translate(-aX, 0);
72428:     /* we do this to avoid an ICE in the android compiler */
72428:     Matrix androidCompilerBug = newTransform;
72428:     mTarget->SetTransform(androidCompilerBug);
72428:   }
72428: 
72428:   // save the previous bounding box
72428:   gfxRect boundingBox = processor.mBoundingBox;
72428: 
72428:   // don't ever need to measure the bounding box twice
80486:   processor.mDoMeasureBoundingBox = false;
72428: 
73724:   rv = nsBidiPresUtils::ProcessText(textToDraw.get(),
72428:                                     textToDraw.Length(),
72428:                                     isRTL ? NSBIDI_RTL : NSBIDI_LTR,
72428:                                     presShell->GetPresContext(),
72428:                                     processor,
72428:                                     nsBidiPresUtils::MODE_DRAW,
72428:                                     nsnull,
72428:                                     0,
73724:                                     nsnull,
73724:                                     &bidiEngine);
72428: 
72428: 
72428:   mTarget->SetTransform(oldTransform);
72428: 
72428:   if (aOp == nsCanvasRenderingContext2DAzure::TEXT_DRAW_OPERATION_FILL && !doDrawShadow)
72428:     return RedrawUser(boundingBox);
72428: 
72428:   return Redraw();
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetMozTextStyle(const nsAString& textStyle)
72428: {
72428:     // font and mozTextStyle are the same value
72428:     return SetFont(textStyle);
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetMozTextStyle(nsAString& textStyle)
72428: {
72428:     // font and mozTextStyle are the same value
72428:     return GetFont(textStyle);
72428: }
72428: 
72428: gfxFontGroup *nsCanvasRenderingContext2DAzure::GetCurrentFontStyle()
72428: {
72428:   // use lazy initilization for the font group since it's rather expensive
72428:   if (!CurrentState().fontGroup) {
72428:     nsresult rv = SetFont(kDefaultFontStyle);
72428:     if (NS_FAILED(rv)) {
72428:       gfxFontStyle style;
72428:       style.size = kDefaultFontSize;
72428:       CurrentState().fontGroup =
72428:         gfxPlatform::GetPlatform()->CreateFontGroup(kDefaultFontName,
72428:                                                     &style,
72428:                                                     nsnull);
72428:       if (CurrentState().fontGroup) {
72428:         CurrentState().font = kDefaultFontStyle;
72428:         rv = NS_OK;
72428:       } else {
72428:         rv = NS_ERROR_OUT_OF_MEMORY;
72428:       }
72428:     }
72428:             
72428:     NS_ASSERTION(NS_SUCCEEDED(rv), "Default canvas font is invalid");
72428:   }
72428: 
72428:   return CurrentState().fontGroup;
72428: }
72428: 
72428: //
72428: // line caps/joins
72428: //
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetLineWidth(float width)
72428: {
72428:   if (!FloatValidate(width) || width <= 0.0) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   CurrentState().lineWidth = width;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetLineWidth(float *width)
72428: {
72428:   *width = CurrentState().lineWidth;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetLineCap(const nsAString& capstyle)
72428: {
72428:   CapStyle cap;
72428: 
72428:   if (capstyle.EqualsLiteral("butt")) {
72428:     cap = CAP_BUTT;
72428:   } else if (capstyle.EqualsLiteral("round")) {
72428:     cap = CAP_ROUND;
72428:   } else if (capstyle.EqualsLiteral("square")) {
72428:     cap = CAP_SQUARE;
72428:   } else {
72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
72428:     return NS_OK;
72428:   }
72428: 
72428:   CurrentState().lineCap = cap;
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetLineCap(nsAString& capstyle)
72428: {
72428:   switch (CurrentState().lineCap) {
72428:   case CAP_BUTT:
72428:     capstyle.AssignLiteral("butt");
72428:     break;
72428:   case CAP_ROUND:
72428:     capstyle.AssignLiteral("round");
72428:     break;
72428:   case CAP_SQUARE:
72428:     capstyle.AssignLiteral("square");
72428:     break;
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetLineJoin(const nsAString& joinstyle)
72428: {
72428:   JoinStyle j;
72428: 
72428:   if (joinstyle.EqualsLiteral("round")) {
72428:     j = JOIN_ROUND;
72428:   } else if (joinstyle.EqualsLiteral("bevel")) {
72428:     j = JOIN_BEVEL;
72428:   } else if (joinstyle.EqualsLiteral("miter")) {
72428:     j = JOIN_MITER_OR_BEVEL;
72428:   } else {
72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
72428:     return NS_OK;
72428:   }
72428: 
72428:   CurrentState().lineJoin = j;
72428:    
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetLineJoin(nsAString& joinstyle)
72428: {
72428:   switch (CurrentState().lineJoin) {
72428:   case JOIN_ROUND:
72428:     joinstyle.AssignLiteral("round");
72428:     break;
72428:   case JOIN_BEVEL:
72428:     joinstyle.AssignLiteral("bevel");
72428:     break;
72428:   case JOIN_MITER_OR_BEVEL:
72428:     joinstyle.AssignLiteral("miter");
72428:     break;
72428:   default:
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetMiterLimit(float miter)
72428: {
72428:   if (!FloatValidate(miter) || miter <= 0.0)
72428:     return NS_OK;
72428: 
72428:   CurrentState().miterLimit = miter;
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetMiterLimit(float *miter)
72428: {
72428:   *miter = CurrentState().miterLimit;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72744: nsCanvasRenderingContext2DAzure::SetMozDash(JSContext *cx, const jsval& patternArray)
72744: {
72744:   FallibleTArray<Float> dash;
72744:   nsresult rv = JSValToDashArray(cx, patternArray, dash);
72744:   if (NS_SUCCEEDED(rv)) {
72744:     ContextState& state = CurrentState();
72744:     state.dash = dash;
72744:     if (state.dash.IsEmpty()) {
72744:       state.dashOffset = 0;
72744:     }
72744:   }
72744:   return rv;
72744: }
72744: 
72744: NS_IMETHODIMP
72744: nsCanvasRenderingContext2DAzure::GetMozDash(JSContext* cx, jsval* dashArray)
72744: {
72744:   return DashArrayToJSVal(CurrentState().dash, cx, dashArray);
72744: }
72744:  
72744: NS_IMETHODIMP
72744: nsCanvasRenderingContext2DAzure::SetMozDashOffset(float offset)
72744: {
72744:   if (!FloatValidate(offset)) {
72744:     return NS_ERROR_ILLEGAL_VALUE;
72744:   }
72744:   ContextState& state = CurrentState();
72744:   if (!state.dash.IsEmpty()) {
72744:     state.dashOffset = offset;
72744:   }
72744:   return NS_OK;
72744: }
72744:  
72744: NS_IMETHODIMP
72744: nsCanvasRenderingContext2DAzure::GetMozDashOffset(float* offset)
72744: {
72744:   *offset = CurrentState().dashOffset;
72744:   return NS_OK;
72744: }
72744: 
72744: NS_IMETHODIMP
79445: nsCanvasRenderingContext2DAzure::IsPointInPath(float x, float y, bool *retVal)
72428: {
72428:   if (!FloatValidate(x,y)) {
80486:     *retVal = false;
72428:     return NS_OK;
72428:   }
72428: 
72428:   EnsureUserSpacePath();
72428: 
80486:   *retVal = false;
72428: 
72428:   if (mPath) {
72428:     *retVal = mPath->ContainsPoint(Point(x, y), mTarget->GetTransform());
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: //
72428: // image
72428: //
72428: 
72428: // drawImage(in HTMLImageElement image, in float dx, in float dy);
72428: //   -- render image from 0,0 at dx,dy top-left coords
72428: // drawImage(in HTMLImageElement image, in float dx, in float dy, in float sw, in float sh);
72428: //   -- render image from 0,0 at dx,dy top-left coords clipping it to sw,sh
72428: // drawImage(in HTMLImageElement image, in float sx, in float sy, in float sw, in float sh, in float dx, in float dy, in float dw, in float dh);
72428: //   -- render the region defined by (sx,sy,sw,wh) in image-local space into the region (dx,dy,dw,dh) on the canvas
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::DrawImage(nsIDOMElement *imgElt, float a1,
72428:                                            float a2, float a3, float a4, float a5,
72428:                                            float a6, float a7, float a8,
72428:                                            PRUint8 optional_argc)
72428: {
83345:   nsCOMPtr<nsIContent> content = do_QueryInterface(imgElt);
83345:   if (!content) {
72428:     return NS_ERROR_DOM_TYPE_MISMATCH_ERR;
72428:   }
72428: 
72428:   if (optional_argc == 0) {
72428:     if (!FloatValidate(a1, a2)) {
72428:       return NS_OK;
72428:     }
72428:   } else if (optional_argc == 2) {
72428:     if (!FloatValidate(a1, a2, a3, a4)) {
72428:       return NS_OK;
72428:     }
72428:   } else if (optional_argc == 6) {
72428:     if (!FloatValidate(a1, a2, a3, a4, a5, a6) || !FloatValidate(a7, a8)) {
72428:       return NS_OK;
72428:     }
72428:   }
72428: 
72428:   double sx,sy,sw,sh;
72428:   double dx,dy,dw,dh;
72428: 
84360:   RefPtr<SourceSurface> srcSurf;
84360:   gfxIntSize imgSize;
84360: 
72428:   nsHTMLCanvasElement* canvas = nsHTMLCanvasElement::FromContent(content);
72428:   if (canvas) {
72428:     nsIntSize size = canvas->GetSize();
72428:     if (size.width == 0 || size.height == 0) {
72428:       return NS_ERROR_DOM_INVALID_STATE_ERR;
72428:     }
84360: 
84360:     // Special case for Canvas, which could be an Azure canvas!
84360:     nsICanvasRenderingContextInternal *srcCanvas = canvas->GetContextAtIndex(0);
84360:     if (srcCanvas == this) {
72428:       // Self-copy.
72428:       srcSurf = mTarget->Snapshot();
72428:       imgSize = gfxIntSize(mWidth, mHeight);
84360:     } else if (srcCanvas) {
79781:       // This might not be an Azure canvas!
79781:       srcSurf = srcCanvas->GetSurfaceSnapshot();
79781: 
79781:       if (srcSurf && mCanvasElement) {
79781:         // Do security check here.
79781:         CanvasUtils::DoDrawImageSecurityCheck(HTMLCanvasElement(),
79781:                                               content->NodePrincipal(), canvas->IsWriteOnly(),
79781:                                               false);
79781:         imgSize = gfxIntSize(srcSurf->GetSize().width, srcSurf->GetSize().height);
79781:       }
79781:     }
84360:   } else {
84360:     gfxASurface* imgsurf =
84360:       CanvasImageCache::Lookup(imgElt, HTMLCanvasElement(), &imgSize);
84360:     if (imgsurf) {
84360:       srcSurf = gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mTarget, imgsurf);
79781:     }
79781:   }
79781: 
72428:   if (!srcSurf) {
72428:     // The canvas spec says that drawImage should draw the first frame
72428:     // of animated images
72428:     PRUint32 sfeFlags = nsLayoutUtils::SFE_WANT_FIRST_FRAME;
72428:     nsLayoutUtils::SurfaceFromElementResult res =
83345:       nsLayoutUtils::SurfaceFromElement(content->AsElement(), sfeFlags);
72428: 
72428:     if (!res.mSurface) {
72428:       // Spec says to silently do nothing if the element is still loading.
72428:       return res.mIsStillLoading ? NS_OK : NS_ERROR_NOT_AVAILABLE;
72428:     }
72428: 
82454:     // Ignore cairo surfaces that are bad! See bug 666312.
82454:     if (res.mSurface->CairoStatus()) {
72428:       return NS_OK;
72428:     }
72428: 
72428:     imgSize = res.mSize;
72428: 
72428:     if (mCanvasElement) {
72428:       CanvasUtils::DoDrawImageSecurityCheck(HTMLCanvasElement(),
78159:                                             res.mPrincipal, res.mIsWriteOnly,
78159:                                             res.mCORSUsed);
72428:     }
72428: 
72428:     if (res.mImageRequest) {
72428:       CanvasImageCache::NotifyDrawImage(imgElt, HTMLCanvasElement(),
84360:                                         res.mImageRequest, res.mSurface, imgSize);
84360:     }
84360: 
84360:     srcSurf = gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mTarget, res.mSurface);
72428:   }
72428: 
72428:   if (optional_argc == 0) {
72428:     dx = a1;
72428:     dy = a2;
72428:     sx = sy = 0.0;
72428:     dw = sw = (double) imgSize.width;
72428:     dh = sh = (double) imgSize.height;
72428:   } else if (optional_argc == 2) {
72428:     dx = a1;
72428:     dy = a2;
72428:     dw = a3;
72428:     dh = a4;
72428:     sx = sy = 0.0;
72428:     sw = (double) imgSize.width;
72428:     sh = (double) imgSize.height;
72428:   } else if (optional_argc == 6) {
72428:     sx = a1;
72428:     sy = a2;
72428:     sw = a3;
72428:     sh = a4;
72428:     dx = a5;
72428:     dy = a6;
72428:     dw = a7;
72428:     dh = a8;
72428:   } else {
72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
72428:     return NS_ERROR_INVALID_ARG;
72428:   }
72428: 
72428:   if (dw == 0.0 || dh == 0.0) {
72428:     // not really failure, but nothing to do --
72428:     // and noone likes a divide-by-zero
72428:     return NS_OK;
72428:   }
72428: 
74273:   if (sx < 0.0 || sy < 0.0 ||
74273:       sw < 0.0 || sw > (double) imgSize.width ||
74273:       sh < 0.0 || sh > (double) imgSize.height ||
74273:       dw < 0.0 || dh < 0.0) {
74273:     // XXX - Unresolved spec issues here, for now return error.
72428:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
72428:   }
72428: 
72428:   Filter filter;
72428: 
72428:   if (CurrentState().imageSmoothingEnabled)
72428:     filter = mgfx::FILTER_LINEAR;
72428:   else
72428:     filter = mgfx::FILTER_POINT;
72428: 
73777:   mgfx::Rect bounds;
73777:   
73777:   if (NeedToDrawShadow()) {
73777:     bounds = mgfx::Rect(dx, dy, dw, dh);
73777:     bounds = mTarget->GetTransform().TransformBounds(bounds);
73777:   }
73777: 
73777:   AdjustedTarget(this, bounds.IsEmpty() ? nsnull : &bounds)->
72428:     DrawSurface(srcSurf,
72428:                 mgfx::Rect(dx, dy, dw, dh),
72428:                 mgfx::Rect(sx, sy, sw, sh),
72428:                 DrawSurfaceOptions(filter),
73032:                 DrawOptions(CurrentState().globalAlpha, UsedOperation()));
72428: 
72428:   return RedrawUser(gfxRect(dx, dy, dw, dh));
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::SetGlobalCompositeOperation(const nsAString& op)
72428: {
72428:   CompositionOp comp_op;
72428: 
72428: #define CANVAS_OP_TO_GFX_OP(cvsop, op2d) \
72428:   if (op.EqualsLiteral(cvsop))   \
72428:     comp_op = OP_##op2d;
72428: 
72428:   CANVAS_OP_TO_GFX_OP("copy", SOURCE)
72428:   else CANVAS_OP_TO_GFX_OP("source-atop", ATOP)
72428:   else CANVAS_OP_TO_GFX_OP("source-in", IN)
72428:   else CANVAS_OP_TO_GFX_OP("source-out", OUT)
72428:   else CANVAS_OP_TO_GFX_OP("source-over", OVER)
72428:   else CANVAS_OP_TO_GFX_OP("destination-in", DEST_IN)
72428:   else CANVAS_OP_TO_GFX_OP("destination-out", DEST_OUT)
72428:   else CANVAS_OP_TO_GFX_OP("destination-over", DEST_OVER)
72428:   else CANVAS_OP_TO_GFX_OP("destination-atop", DEST_ATOP)
72428:   else CANVAS_OP_TO_GFX_OP("lighter", ADD)
72428:   else CANVAS_OP_TO_GFX_OP("xor", XOR)
72428:   // XXX ERRMSG we need to report an error to developers here! (bug 329026)
72428:   else return NS_OK;
72428: 
72428: #undef CANVAS_OP_TO_GFX_OP
72428:   CurrentState().op = comp_op;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetGlobalCompositeOperation(nsAString& op)
72428: {
72428:   CompositionOp comp_op = CurrentState().op;
72428: 
72428: #define CANVAS_OP_TO_GFX_OP(cvsop, op2d) \
72428:   if (comp_op == OP_##op2d) \
72428:     op.AssignLiteral(cvsop);
72428: 
72428:   CANVAS_OP_TO_GFX_OP("copy", SOURCE)
72428:   else CANVAS_OP_TO_GFX_OP("destination-atop", DEST_ATOP)
72428:   else CANVAS_OP_TO_GFX_OP("destination-in", DEST_IN)
72428:   else CANVAS_OP_TO_GFX_OP("destination-out", DEST_OUT)
72428:   else CANVAS_OP_TO_GFX_OP("destination-over", DEST_OVER)
72428:   else CANVAS_OP_TO_GFX_OP("lighter", ADD)
72428:   else CANVAS_OP_TO_GFX_OP("source-atop", ATOP)
72428:   else CANVAS_OP_TO_GFX_OP("source-in", IN)
72428:   else CANVAS_OP_TO_GFX_OP("source-out", OUT)
72428:   else CANVAS_OP_TO_GFX_OP("source-over", OVER)
72428:   else CANVAS_OP_TO_GFX_OP("xor", XOR)
72428:   else return NS_ERROR_FAILURE;
72428: 
72428: #undef CANVAS_OP_TO_GFX_OP
72428:     
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::DrawWindow(nsIDOMWindow* aWindow, float aX, float aY,
72428:                                             float aW, float aH,
72428:                                             const nsAString& aBGColor,
72428:                                             PRUint32 flags)
72428: {
72428:   NS_ENSURE_ARG(aWindow != nsnull);
72428: 
72428:   // protect against too-large surfaces that will cause allocation
72428:   // or overflow issues
72428:   if (!gfxASurface::CheckSurfaceSize(gfxIntSize(PRInt32(aW), PRInt32(aH)),
72428:                                       0xffff))
72428:     return NS_ERROR_FAILURE;
72428: 
72428:   nsRefPtr<gfxASurface> drawSurf;
72428:   GetThebesSurface(getter_AddRefs(drawSurf));
72428: 
72428:   nsRefPtr<gfxContext> thebes = new gfxContext(drawSurf);
72428: 
72428:   Matrix matrix = mTarget->GetTransform();
72428:   thebes->SetMatrix(gfxMatrix(matrix._11, matrix._12, matrix._21,
72428:                               matrix._22, matrix._31, matrix._32));
72428: 
72428:   // We can't allow web apps to call this until we fix at least the
72428:   // following potential security issues:
72428:   // -- rendering cross-domain IFRAMEs and then extracting the results
72428:   // -- rendering the user's theme and then extracting the results
72428:   // -- rendering native anonymous content (e.g., file input paths;
72428:   // scrollbars should be allowed)
72428:   if (!nsContentUtils::IsCallerTrustedForRead()) {
72428:     // not permitted to use DrawWindow
72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
72428:     return NS_ERROR_DOM_SECURITY_ERR;
72428:   }
72428: 
72428:   // Flush layout updates
72428:   if (!(flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DO_NOT_FLUSH))
72428:       nsContentUtils::FlushLayoutForTree(aWindow);
72428: 
72428:   nsRefPtr<nsPresContext> presContext;
72428:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aWindow);
72428:   if (win) {
72428:     nsIDocShell* docshell = win->GetDocShell();
72428:     if (docshell) {
72428:       docshell->GetPresContext(getter_AddRefs(presContext));
72428:     }
72428:   }
72428:   if (!presContext)
72428:     return NS_ERROR_FAILURE;
72428: 
72428:   nscolor bgColor;
72428: 
72428:   nsIDocument* elementDoc = mCanvasElement ?
80526:                             HTMLCanvasElement()->OwnerDoc() : nsnull;
72428: 
72428:   // Pass the CSS Loader object to the parser, to allow parser error reports
72428:   // to include the outer window ID.
72428:   nsCSSParser parser(elementDoc ? elementDoc->CSSLoader() : nsnull);
72428:   nsresult rv = parser.ParseColorString(PromiseFlatString(aBGColor),
72428:                                         nsnull, 0, &bgColor);
72428:   NS_ENSURE_SUCCESS(rv, rv);
72428: 
72428:   nsIPresShell* presShell = presContext->PresShell();
72428:   NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
72428: 
72428:   nsRect r(nsPresContext::CSSPixelsToAppUnits(aX),
72428:            nsPresContext::CSSPixelsToAppUnits(aY),
72428:            nsPresContext::CSSPixelsToAppUnits(aW),
72428:            nsPresContext::CSSPixelsToAppUnits(aH));
72428:   PRUint32 renderDocFlags = (nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING |
72428:                              nsIPresShell::RENDER_DOCUMENT_RELATIVE);
72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_CARET) {
72428:     renderDocFlags |= nsIPresShell::RENDER_CARET;
72428:   }
72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_VIEW) {
72428:     renderDocFlags &= ~(nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING |
72428:                         nsIPresShell::RENDER_DOCUMENT_RELATIVE);
72428:   }
72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_USE_WIDGET_LAYERS) {
72428:     renderDocFlags |= nsIPresShell::RENDER_USE_WIDGET_LAYERS;
72428:   }
72428:   if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_ASYNC_DECODE_IMAGES) {
72428:     renderDocFlags |= nsIPresShell::RENDER_ASYNC_DECODE_IMAGES;
72428:   }
72428: 
72428:   rv = presShell->RenderDocument(r, renderDocFlags, bgColor, thebes);
72428: 
72428:   // note that aX and aY are coordinates in the document that
72428:   // we're drawing; aX and aY are drawn to 0,0 in current user
72428:   // space.
72428:   RedrawUser(gfxRect(0, 0, aW, aH));
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
73023: nsCanvasRenderingContext2DAzure::AsyncDrawXULElement(nsIDOMXULElement* aElem,
73023:                                                      float aX, float aY,
72428:                                                      float aW, float aH,
72428:                                                      const nsAString& aBGColor,
72428:                                                      PRUint32 flags)
72428: {
72428:     NS_ENSURE_ARG(aElem != nsnull);
72428: 
72428:     // We can't allow web apps to call this until we fix at least the
72428:     // following potential security issues:
72428:     // -- rendering cross-domain IFRAMEs and then extracting the results
72428:     // -- rendering the user's theme and then extracting the results
72428:     // -- rendering native anonymous content (e.g., file input paths;
72428:     // scrollbars should be allowed)
72428:     if (!nsContentUtils::IsCallerTrustedForRead()) {
72428:         // not permitted to use DrawWindow
72428:         // XXX ERRMSG we need to report an error to developers here! (bug 329026)
72428:         return NS_ERROR_DOM_SECURITY_ERR;
72428:     }
72428: 
73023: #if 0
72428:     nsCOMPtr<nsIFrameLoaderOwner> loaderOwner = do_QueryInterface(aElem);
72428:     if (!loaderOwner)
72428:         return NS_ERROR_FAILURE;
72428: 
72428:     nsRefPtr<nsFrameLoader> frameloader = loaderOwner->GetFrameLoader();
72428:     if (!frameloader)
72428:         return NS_ERROR_FAILURE;
72428: 
72428:     PBrowserParent *child = frameloader->GetRemoteBrowser();
72428:     if (!child) {
72428:         nsCOMPtr<nsIDOMWindow> window =
72428:             do_GetInterface(frameloader->GetExistingDocShell());
72428:         if (!window)
72428:             return NS_ERROR_FAILURE;
72428: 
72428:         return DrawWindow(window, aX, aY, aW, aH, aBGColor, flags);
72428:     }
72428: 
72428:     // protect against too-large surfaces that will cause allocation
72428:     // or overflow issues
72428:     if (!gfxASurface::CheckSurfaceSize(gfxIntSize(aW, aH), 0xffff))
72428:         return NS_ERROR_FAILURE;
72428: 
79445:     bool flush =
72428:         (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DO_NOT_FLUSH) == 0;
72428: 
72428:     PRUint32 renderDocFlags = nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
72428:     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_CARET) {
72428:         renderDocFlags |= nsIPresShell::RENDER_CARET;
72428:     }
72428:     if (flags & nsIDOMCanvasRenderingContext2D::DRAWWINDOW_DRAW_VIEW) {
72428:         renderDocFlags &= ~nsIPresShell::RENDER_IGNORE_VIEWPORT_SCROLLING;
72428:     }
72428: 
72428:     nsRect rect(nsPresContext::CSSPixelsToAppUnits(aX),
72428:                 nsPresContext::CSSPixelsToAppUnits(aY),
72428:                 nsPresContext::CSSPixelsToAppUnits(aW),
72428:                 nsPresContext::CSSPixelsToAppUnits(aH));
72428:     if (mIPC) {
72428:         PDocumentRendererParent *pdocrender =
72428:             child->SendPDocumentRendererConstructor(rect,
72428:                                                     mThebes->CurrentMatrix(),
72428:                                                     nsString(aBGColor),
72428:                                                     renderDocFlags, flush,
72428:                                                     nsIntSize(mWidth, mHeight));
72428:         if (!pdocrender)
72428:             return NS_ERROR_FAILURE;
72428: 
72428:         DocumentRendererParent *docrender =
72428:             static_cast<DocumentRendererParent *>(pdocrender);
72428: 
72428:         docrender->SetCanvasContext(this, mThebes);
72428:     }
72428: #endif
72428:     return NS_OK;
72428: }
72428: 
72428: //
72428: // device pixel getting/setting
72428: //
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::EnsureUnpremultiplyTable() {
72428:   if (sUnpremultiplyTable)
72428:     return;
72428: 
72428:   // Infallably alloc the unpremultiply table.
72428:   sUnpremultiplyTable = new PRUint8[256][256];
72428: 
72428:   // It's important that the array be indexed first by alpha and then by rgb
72428:   // value.  When we unpremultiply a pixel, we're guaranteed to do three
72428:   // lookups with the same alpha; indexing by alpha first makes it likely that
72428:   // those three lookups will be close to one another in memory, thus
72428:   // increasing the chance of a cache hit.
72428: 
72428:   // a == 0 case
72428:   for (PRUint32 c = 0; c <= 255; c++) {
72428:     sUnpremultiplyTable[0][c] = c;
72428:   }
72428: 
72428:   for (int a = 1; a <= 255; a++) {
72428:     for (int c = 0; c <= 255; c++) {
72428:       sUnpremultiplyTable[a][c] = (PRUint8)((c * 255) / a);
72428:     }
72428:   }
72428: }
72428: 
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetImageData()
72428: {
72428:   /* Should never be called -- GetImageData_explicit is the QS entry point */
72428:   return NS_ERROR_NOT_IMPLEMENTED;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetImageData_explicit(PRInt32 x, PRInt32 y, PRUint32 w, PRUint32 h,
72428:                                                        PRUint8 *aData, PRUint32 aDataLen)
72428: {
72428:   if (!mValid)
72428:     return NS_ERROR_FAILURE;
72428: 
72428:   if (!mCanvasElement && !mDocShell) {
72428:     NS_ERROR("No canvas element and no docshell in GetImageData!!!");
72428:     return NS_ERROR_DOM_SECURITY_ERR;
72428:   }
72428: 
72428:   // Check only if we have a canvas element; if we were created with a docshell,
72428:   // then it's special internal use.
72428:   if (mCanvasElement &&
72428:       HTMLCanvasElement()->IsWriteOnly() &&
72428:       !nsContentUtils::IsCallerTrustedForRead())
72428:   {
72428:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
72428:     return NS_ERROR_DOM_SECURITY_ERR;
72428:   }
72428: 
72428:   if (w == 0 || h == 0 || aDataLen != w * h * 4)
72428:     return NS_ERROR_DOM_SYNTAX_ERR;
72428: 
72428:   CheckedInt32 rightMost = CheckedInt32(x) + w;
72428:   CheckedInt32 bottomMost = CheckedInt32(y) + h;
72428: 
72428:   if (!rightMost.valid() || !bottomMost.valid())
72428:     return NS_ERROR_DOM_SYNTAX_ERR;
72428: 
72428:   if (mZero) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   IntRect srcRect(0, 0, mWidth, mHeight);
72428:   IntRect destRect(x, y, w, h);
72428: 
72428:   if (!srcRect.Contains(destRect)) {
72428:     // Some data is outside the canvas surface, clear the destination.
72428:     memset(aData, 0, aDataLen);
72428:   }
72428: 
72428:   IntRect srcReadRect = srcRect.Intersect(destRect);
72428:   IntRect dstWriteRect = srcReadRect;
72428:   dstWriteRect.MoveBy(-x, -y);
72428: 
72428:   PRUint8 *src = aData;
72428:   PRUint32 srcStride = w * 4;
72428:   
78290:   RefPtr<DataSourceSurface> readback;
72428:   if (!srcReadRect.IsEmpty()) {
72428:     RefPtr<SourceSurface> snapshot = mTarget->Snapshot();
72428: 
78290:     readback = snapshot->GetDataSurface();
72428: 
72428:     srcStride = readback->Stride();
72428:     src = readback->GetData() + srcReadRect.y * srcStride + srcReadRect.x * 4;
72428:   }
72428: 
72428:   // make sure sUnpremultiplyTable has been created
72428:   EnsureUnpremultiplyTable();
72428: 
72428:   // NOTE! dst is the same as src, and this relies on reading
72428:   // from src and advancing that ptr before writing to dst.
72428:   PRUint8 *dst = aData + dstWriteRect.y * (w * 4) + dstWriteRect.x * 4;
72428: 
72739:   for (int j = 0; j < dstWriteRect.height; j++) {
72739:     for (int i = 0; i < dstWriteRect.width; i++) {
72428:       // XXX Is there some useful swizzle MMX we can use here?
72428: #ifdef IS_LITTLE_ENDIAN
72428:       PRUint8 b = *src++;
72428:       PRUint8 g = *src++;
72428:       PRUint8 r = *src++;
72428:       PRUint8 a = *src++;
72428: #else
72428:       PRUint8 a = *src++;
72428:       PRUint8 r = *src++;
72428:       PRUint8 g = *src++;
72428:       PRUint8 b = *src++;
72428: #endif
72428:       // Convert to non-premultiplied color
72428:       *dst++ = sUnpremultiplyTable[a][r];
72428:       *dst++ = sUnpremultiplyTable[a][g];
72428:       *dst++ = sUnpremultiplyTable[a][b];
72428:       *dst++ = a;
72428:     }
72428:     src += srcStride - (dstWriteRect.width * 4);
72428:     dst += (w * 4) - (dstWriteRect.width * 4);
72428:   }
72428:   return NS_OK;
72428: }
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::EnsurePremultiplyTable() {
72428:   if (sPremultiplyTable)
72428:     return;
72428: 
72428:   // Infallably alloc the premultiply table.
72428:   sPremultiplyTable = new PRUint8[256][256];
72428: 
72428:   // Like the unpremultiply table, it's important that we index the premultiply
72428:   // table with the alpha value as the first index to ensure good cache
72428:   // performance.
72428: 
72428:   for (int a = 0; a <= 255; a++) {
72428:     for (int c = 0; c <= 255; c++) {
72428:       sPremultiplyTable[a][c] = (a * c + 254) / 255;
72428:     }
72428:   }
72428: }
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::FillRuleChanged()
72428: {
72428:   if (mPath) {
72428:     mPathBuilder = mPath->CopyToBuilder(CurrentState().fillRule);
72428:     mPath = nsnull;
72428:   }
72428: }
72428: 
72428: // void putImageData (in ImageData d, in float x, in float y);
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::PutImageData()
72428: {
72428:   /* Should never be called -- PutImageData_explicit is the QS entry point */
72428:   return NS_ERROR_NOT_IMPLEMENTED;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::PutImageData_explicit(PRInt32 x, PRInt32 y, PRUint32 w, PRUint32 h,
72428:                                                        unsigned char *aData, PRUint32 aDataLen,
79445:                                                        bool hasDirtyRect, PRInt32 dirtyX, PRInt32 dirtyY,
72428:                                                        PRInt32 dirtyWidth, PRInt32 dirtyHeight)
72428: {
72428:   if (!mValid) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   if (w == 0 || h == 0) {
72428:     return NS_ERROR_DOM_SYNTAX_ERR;
72428:   }
72428: 
72428:   IntRect dirtyRect;
72428:   IntRect imageDataRect(0, 0, w, h);
72428: 
72428:   if (hasDirtyRect) {
72428:     // fix up negative dimensions
72428:     if (dirtyWidth < 0) {
72428:       NS_ENSURE_TRUE(dirtyWidth != INT_MIN, NS_ERROR_DOM_INDEX_SIZE_ERR);
72428: 
72428:       CheckedInt32 checkedDirtyX = CheckedInt32(dirtyX) + dirtyWidth;
72428: 
72428:       if (!checkedDirtyX.valid())
72428:           return NS_ERROR_DOM_INDEX_SIZE_ERR;
72428: 
72428:       dirtyX = checkedDirtyX.value();
72428:       dirtyWidth = -(int32)dirtyWidth;
72428:     }
72428: 
72428:     if (dirtyHeight < 0) {
72428:       NS_ENSURE_TRUE(dirtyHeight != INT_MIN, NS_ERROR_DOM_INDEX_SIZE_ERR);
72428: 
72428:       CheckedInt32 checkedDirtyY = CheckedInt32(dirtyY) + dirtyHeight;
72428: 
72428:       if (!checkedDirtyY.valid())
72428:           return NS_ERROR_DOM_INDEX_SIZE_ERR;
72428: 
72428:       dirtyY = checkedDirtyY.value();
72428:       dirtyHeight = -(int32)dirtyHeight;
72428:     }
72428: 
72428:     // bound the dirty rect within the imageData rectangle
72428:     dirtyRect = imageDataRect.Intersect(IntRect(dirtyX, dirtyY, dirtyWidth, dirtyHeight));
72428: 
72428:     if (dirtyRect.Width() <= 0 || dirtyRect.Height() <= 0)
72428:         return NS_OK;
72428:   } else {
72428:     dirtyRect = imageDataRect;
72428:   }
72428: 
72428:   dirtyRect.MoveBy(IntPoint(x, y));
72428:   dirtyRect = IntRect(0, 0, mWidth, mHeight).Intersect(dirtyRect);
72428: 
72428:   if (dirtyRect.Width() <= 0 || dirtyRect.Height() <= 0) {
72428:     return NS_OK;
72428:   }
72428: 
72428:   PRUint32 len = w * h * 4;
72428:   if (aDataLen != len) {
72428:     return NS_ERROR_DOM_SYNTAX_ERR;
72428:   }
72428: 
72428:   nsRefPtr<gfxImageSurface> imgsurf = new gfxImageSurface(gfxIntSize(w, h),
72428:                                                           gfxASurface::ImageFormatARGB32);
72428:   if (!imgsurf || imgsurf->CairoStatus()) {
72428:     return NS_ERROR_FAILURE;
72428:   }
72428: 
72428:   // ensure premultiply table has been created
72428:   EnsurePremultiplyTable();
72428: 
72428:   PRUint8 *src = aData;
72428:   PRUint8 *dst = imgsurf->Data();
72428: 
72428:   for (PRUint32 j = 0; j < h; j++) {
72428:     for (PRUint32 i = 0; i < w; i++) {
72428:       PRUint8 r = *src++;
72428:       PRUint8 g = *src++;
72428:       PRUint8 b = *src++;
72428:       PRUint8 a = *src++;
72428: 
72428:       // Convert to premultiplied color (losslessly if the input came from getImageData)
72428: #ifdef IS_LITTLE_ENDIAN
72428:       *dst++ = sPremultiplyTable[a][b];
72428:       *dst++ = sPremultiplyTable[a][g];
72428:       *dst++ = sPremultiplyTable[a][r];
72428:       *dst++ = a;
72428: #else
72428:       *dst++ = a;
72428:       *dst++ = sPremultiplyTable[a][r];
72428:       *dst++ = sPremultiplyTable[a][g];
72428:       *dst++ = sPremultiplyTable[a][b];
72428: #endif
72428:     }
72428:   }
72428: 
72428:   RefPtr<SourceSurface> sourceSurface =
72428:     mTarget->CreateSourceSurfaceFromData(imgsurf->Data(), IntSize(w, h), imgsurf->Stride(), FORMAT_B8G8R8A8);
72428: 
72428: 
72428:   mTarget->CopySurface(sourceSurface,
72428:                        IntRect(dirtyRect.x - x, dirtyRect.y - y,
72428:                                dirtyRect.width, dirtyRect.height),
72428:                        IntPoint(dirtyRect.x, dirtyRect.y));
72428: 
72428:   Redraw(mgfx::Rect(dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height));
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::GetThebesSurface(gfxASurface **surface)
72428: {
72428:   if (!mTarget) {
72428:     nsRefPtr<gfxASurface> tmpSurf =
72428:       gfxPlatform::GetPlatform()->CreateOffscreenSurface(gfxIntSize(1, 1), gfxASurface::CONTENT_COLOR_ALPHA);
72428:     *surface = tmpSurf.forget().get();
72428:     return NS_OK;
72428:   }
72428: 
72767:   if (!mThebesSurface) {
72767:     mThebesSurface =
72428:       gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mTarget);    
72428: 
72767:     if (!mThebesSurface) {
72767:       return NS_ERROR_FAILURE;
72767:     }
72767:   } else {
72767:     // Normally GetThebesSurfaceForDrawTarget will handle the flush, when
72767:     // we're returning a cached ThebesSurface we need to flush here.
72767:     mTarget->Flush();
72767:   }
72767: 
72767:   *surface = mThebesSurface;
78894:   NS_ADDREF(*surface);
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
72428: nsCanvasRenderingContext2DAzure::CreateImageData()
72428: {
72428:   /* Should never be called; handled entirely in the quickstub */
72428:   return NS_ERROR_NOT_IMPLEMENTED;
72428: }
72428: 
72428: NS_IMETHODIMP
79445: nsCanvasRenderingContext2DAzure::GetMozImageSmoothingEnabled(bool *retVal)
72428: {
72428:   *retVal = CurrentState().imageSmoothingEnabled;
72428:   return NS_OK;
72428: }
72428: 
72428: NS_IMETHODIMP
79445: nsCanvasRenderingContext2DAzure::SetMozImageSmoothingEnabled(bool val)
72428: {
72428:   if (val != CurrentState().imageSmoothingEnabled) {
72428:       CurrentState().imageSmoothingEnabled = val;
72428:   }
72428: 
72428:   return NS_OK;
72428: }
72428: 
72428: static PRUint8 g2DContextLayerUserData;
72428: 
72428: class CanvasRenderingContext2DUserData : public LayerUserData {
72428: public:
72428:   CanvasRenderingContext2DUserData(nsHTMLCanvasElement *aContent)
72428:     : mContent(aContent) {}
72428:   static void DidTransactionCallback(void* aData)
72428:   {
72428:     static_cast<CanvasRenderingContext2DUserData*>(aData)->mContent->MarkContextClean();
72428:   }
72428: 
72428: private:
72428:   nsRefPtr<nsHTMLCanvasElement> mContent;
72428: };
72428: 
72428: already_AddRefed<CanvasLayer>
72428: nsCanvasRenderingContext2DAzure::GetCanvasLayer(nsDisplayListBuilder* aBuilder,
72428:                                            CanvasLayer *aOldLayer,
72428:                                            LayerManager *aManager)
72428: {
72428:   if (!mValid) {
72428:     return nsnull;
72428:   }
72428: 
72428:   if (mTarget) {
72428:     mTarget->Flush();
72428:   }
72428: 
72428:   if (!mResetLayer && aOldLayer &&
72428:       aOldLayer->HasUserData(&g2DContextLayerUserData)) {
72428:       NS_ADDREF(aOldLayer);
72428:       return aOldLayer;
72428:   }
72428: 
72428:   nsRefPtr<CanvasLayer> canvasLayer = aManager->CreateCanvasLayer();
72428:   if (!canvasLayer) {
72428:       NS_WARNING("CreateCanvasLayer returned null!");
72428:       return nsnull;
72428:   }
72428:   CanvasRenderingContext2DUserData *userData = nsnull;
72428:   if (aBuilder->IsPaintingToWindow()) {
72428:     // Make the layer tell us whenever a transaction finishes (including
72428:     // the current transaction), so we can clear our invalidation state and
72428:     // start invalidating again. We need to do this for the layer that is
72428:     // being painted to a window (there shouldn't be more than one at a time,
72428:     // and if there is, flushing the invalidation state more often than
72428:     // necessary is harmless).
72428: 
72428:     // The layer will be destroyed when we tear down the presentation
72428:     // (at the latest), at which time this userData will be destroyed,
72428:     // releasing the reference to the element.
72428:     // The userData will receive DidTransactionCallbacks, which flush the
72428:     // the invalidation state to indicate that the canvas is up to date.
72428:     userData = new CanvasRenderingContext2DUserData(HTMLCanvasElement());
72428:     canvasLayer->SetDidTransactionCallback(
72428:             CanvasRenderingContext2DUserData::DidTransactionCallback, userData);
72428:   }
72428:   canvasLayer->SetUserData(&g2DContextLayerUserData, userData);
72428: 
72428:   CanvasLayer::Data data;
72428: 
72428:   data.mDrawTarget = mTarget;
72428:   data.mSize = nsIntSize(mWidth, mHeight);
72428: 
72428:   canvasLayer->Initialize(data);
72428:   PRUint32 flags = mOpaque ? Layer::CONTENT_OPAQUE : 0;
72428:   canvasLayer->SetContentFlags(flags);
72428:   canvasLayer->Updated();
72428: 
80486:   mResetLayer = false;
72428: 
72428:   return canvasLayer.forget();
72428: }
72428: 
72428: void
72428: nsCanvasRenderingContext2DAzure::MarkContextClean()
72428: {
72428:   if (mInvalidateCount > 0) {
72428:     mPredictManyRedrawCalls = mInvalidateCount > kCanvasMaxInvalidateCount;
72428:   }
80486:   mIsEntireFrameInvalid = false;
72428:   mInvalidateCount = 0;
72428: }
72428: 
