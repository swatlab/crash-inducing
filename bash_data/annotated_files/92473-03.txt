    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set sw=2 ts=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Kathleen Brade <brade@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
80467: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsCOMPtr.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsHTMLDocument.h"
    1: #include "nsIHTMLContentSink.h"
    1: #include "nsIXMLContentSink.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsHTMLStyleSheet.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDOMNode.h" // for Find
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsDOMString.h"
    1: #include "nsIStreamListener.h"
    1: #include "nsIURI.h"
    1: #include "nsIIOService.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIContentViewerContainer.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
 3101: #include "nsDocShellLoadTypes.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIWebShellServices.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsContentList.h"
    1: #include "nsDOMError.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsAttrName.h"
    1: #include "nsNodeUtils.h"
    1: 
    1: #include "nsNetCID.h"
    1: #include "nsIIOService.h"
    1: #include "nsICookieService.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsParserCIID.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMHTMLBodyElement.h"
42111: #include "nsIDOMHTMLHeadElement.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsGenericHTMLElement.h"
47937: #include "mozilla/css/Loader.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIFile.h"
72328: #include "nsEventListenerManager.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsISelectionPrivate.h"//for toStringwithformat code
    1: 
    1: #include "nsContentUtils.h"
    1: #include "nsJSUtils.h"
    1: #include "nsIDocumentEncoder.h" //for outputting selection
    1: #include "nsICachingChannel.h"
    1: #include "nsIJSContextStack.h"
80401: #include "nsIContentViewer.h"
    1: #include "nsIWyciwygChannel.h"
    1: #include "nsIScriptElement.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIMutableArray.h"
    1: #include "nsArrayUtils.h"
  803: #include "nsIEffectiveTLDService.h"
    1: 
    1: #include "nsIPrompt.h"
    1: //AHMED 12-2
    1: #include "nsBidiUtils.h"
    1: 
    1: #include "nsIEditingSession.h"
    1: #include "nsIEditor.h"
    1: #include "nsNodeInfoManager.h"
58662: #include "nsIPlaintextEditor.h"
58662: #include "nsIHTMLEditor.h"
 2896: #include "nsIEditorDocShell.h"
 2896: #include "nsIEditorStyleSheets.h"
 2896: #include "nsIInlineSpellChecker.h"
 2896: #include "nsRange.h"
14228: #include "mozAutoDocUpdate.h"
25691: #include "nsCCUncollectableMarker.h"
29805: #include "nsHtml5Module.h"
28615: #include "prprf.h"
41930: #include "mozilla/dom/Element.h"
70976: #include "mozilla/Preferences.h"
81186: #include "nsMimeTypes.h"
88544: #include "nsIRequest.h"
70976: 
70976: using namespace mozilla;
41634: using namespace mozilla::dom;
    1: 
    1: #define NS_MAX_DOCUMENT_WRITE_DEPTH 20
    1: 
    1: #include "prmem.h"
    1: #include "prtime.h"
    1: 
    1: // Find/Search Includes
    1: const PRInt32 kForward  = 0;
    1: const PRInt32 kBackward = 1;
    1: 
    1: //#define DEBUG_charset
    1: 
    1: static NS_DEFINE_CID(kCParserCID, NS_PARSER_CID);
    1: 
    1: PRUint32       nsHTMLDocument::gWyciwygSessionCnt = 0;
    1: 
10248: // this function will return false if the command is not recognized
10248: // inCommandID will be converted as necessary for internal operations
10248: // inParam will be converted as necessary for internal operations
10248: // outParam will be Empty if no parameter is needed or if returning a boolean
10248: // outIsBoolean will determine whether to send param as a boolean or string
10248: // outBooleanParam will not be set unless outIsBoolean
79445: static bool ConvertToMidasInternalCommand(const nsAString & inCommandID,
10248:                                             const nsAString & inParam,
10248:                                             nsACString& outCommandID,
10248:                                             nsACString& outParam,
79445:                                             bool& isBoolean,
79445:                                             bool& boolValue);
79445: 
79445: static bool ConvertToMidasInternalCommand(const nsAString & inCommandID,
10248:                                             nsACString& outCommandID);
    1: 
    1: // ==================================================================
    1: // =
    1: // ==================================================================
51558: static void
51558: ReportUseOfDeprecatedMethod(nsHTMLDocument* aDoc, const char* aWarning)
51558: {
84636:   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
84636:                                   "DOM Events", aDoc,
84636:                                   nsContentUtils::eDOM_PROPERTIES,
84636:                                   aWarning);
51558: }
51558: 
56924: static nsresult
56924: RemoveFromAgentSheets(nsCOMArray<nsIStyleSheet> &aAgentSheets, const nsAString& url)
56924: {
56924:   nsCOMPtr<nsIURI> uri;
56924:   nsresult rv = NS_NewURI(getter_AddRefs(uri), url);
56924:   NS_ENSURE_SUCCESS(rv, rv);
56924: 
56926:   for (PRInt32 i = aAgentSheets.Count() - 1; i >= 0; --i) {
56924:     nsIStyleSheet* sheet = aAgentSheets[i];
56924:     nsIURI* sheetURI = sheet->GetSheetURI();
56924: 
79445:     bool equals = false;
56924:     uri->Equals(sheetURI, &equals);
56924:     if (equals) {
56924:       aAgentSheets.RemoveObjectAt(i);
56924:     }
56924:   }
56924: 
56924:   return NS_OK;
56924: }
56924: 
    1: nsresult
    1: NS_NewHTMLDocument(nsIDocument** aInstancePtrResult)
    1: {
    1:   nsHTMLDocument* doc = new nsHTMLDocument();
    1:   NS_ENSURE_TRUE(doc, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   NS_ADDREF(doc);
    1:   nsresult rv = doc->Init();
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     NS_RELEASE(doc);
    1:   }
    1: 
    1:   *aInstancePtrResult = doc;
    1: 
    1:   return rv;
    1: }
    1: 
    1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
    1: nsHTMLDocument::nsHTMLDocument()
15474:   : nsDocument("text/html")
    1: {
    1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
80486:   mIsRegularHTML = true;
    1:   mDefaultElementType = kNameSpaceID_XHTML;
    1:   mCompatMode = eCompatibility_NavQuirks;
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLDocument)
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLDocument, nsDocument)
30096:   NS_ASSERTION(!nsCCUncollectableMarker::InGeneration(cb, tmp->GetMarkedCCGeneration()),
25691:                "Shouldn't traverse nsHTMLDocument!");
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mImages)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mApplets)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEmbeds)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLinks)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mAnchors)
78151:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScripts)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mForms, nsIDOMNodeList)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mFormControls,
    1:                                                        nsIDOMNodeList)
34060:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mWyciwygChannel)
34060:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mMidasCommandManager)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
34060: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHTMLDocument, nsDocument)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mImages)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mApplets)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mEmbeds)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLinks)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mAnchors)
78151:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mScripts)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mForms)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFormControls)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mWyciwygChannel)
34060:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mMidasCommandManager)
34060: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
34060: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLDocument, nsDocument)
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLDocument, nsDocument)
    1: 
12033: 
48124: DOMCI_NODE_DATA(HTMLDocument, nsHTMLDocument)
40490: 
12033: // QueryInterface implementation for nsHTMLDocument
12033: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLDocument)
21218:   NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsHTMLDocument)
21218:     NS_INTERFACE_TABLE_ENTRY(nsHTMLDocument, nsIHTMLDocument)
21218:     NS_INTERFACE_TABLE_ENTRY(nsHTMLDocument, nsIDOMHTMLDocument)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(HTMLDocument)
12033: NS_INTERFACE_MAP_END_INHERITING(nsDocument)
12033: 
12033: 
    1: nsresult
    1: nsHTMLDocument::Init()
    1: {
    1:   nsresult rv = nsDocument::Init();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
33262:   // Now reset the compatibility mode of the CSSLoader
33262:   // to match our compat mode.
    1:   CSSLoader()->SetCompatibilityMode(mCompatMode);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: void
    1: nsHTMLDocument::Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup)
    1: {
    1:   nsDocument::Reset(aChannel, aLoadGroup);
    1: 
    1:   if (aChannel) {
    1:     aChannel->GetLoadFlags(&mLoadFlags);
    1:   }
    1: }
    1: 
    1: void
    1: nsHTMLDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
    1:                            nsIPrincipal* aPrincipal)
    1: {
    1:   mLoadFlags = nsIRequest::LOAD_NORMAL;
    1: 
    1:   nsDocument::ResetToURI(aURI, aLoadGroup, aPrincipal);
    1: 
    1:   mImages = nsnull;
    1:   mApplets = nsnull;
    1:   mEmbeds = nsnull;
    1:   mLinks = nsnull;
    1:   mAnchors = nsnull;
78151:   mScripts = nsnull;
    1: 
    1:   mForms = nsnull;
    1: 
    1:   NS_ASSERTION(!mWyciwygChannel,
    1:                "nsHTMLDocument::Reset() - Wyciwyg Channel  still exists!");
    1: 
    1:   mWyciwygChannel = nsnull;
    1: 
    1:   // Make the content type default to "text/html", we are a HTML
    1:   // document, after all. Once we start getting data, this may be
    1:   // changed.
46309:   SetContentTypeInternal(nsDependentCString("text/html"));
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::CreateShell(nsPresContext* aContext,
    1:                             nsIViewManager* aViewManager,
    1:                             nsStyleSet* aStyleSet,
    1:                             nsIPresShell** aInstancePtrResult)
    1: {
    1:   return doCreateShell(aContext, aViewManager, aStyleSet, mCompatMode,
    1:                        aInstancePtrResult);
    1: }
    1: 
80486: // The following Try*Charset will return false only if the charset source
    1: // should be considered (ie. aCharsetSource < thisCharsetSource) but we failed
    1: // to get the charset from this source.
    1: 
79445: bool
    1: nsHTMLDocument::TryHintCharset(nsIMarkupDocumentViewer* aMarkupDV,
    1:                                PRInt32& aCharsetSource, nsACString& aCharset)
    1: {
    1:   if (aMarkupDV) {
    1:     PRInt32 requestCharsetSource;
    1:     nsresult rv = aMarkupDV->GetHintCharacterSetSource(&requestCharsetSource);
    1: 
    1:     if(NS_SUCCEEDED(rv) && kCharsetUninitialized != requestCharsetSource) {
    1:       nsCAutoString requestCharset;
    1:       rv = aMarkupDV->GetHintCharacterSet(requestCharset);
    1:       aMarkupDV->SetHintCharacterSetSource((PRInt32)(kCharsetUninitialized));
    1: 
    1:       if(requestCharsetSource <= aCharsetSource)
80486:         return true;
    1: 
    1:       if(NS_SUCCEEDED(rv)) {
    1:         aCharsetSource = requestCharsetSource;
    1:         aCharset = requestCharset;
    1: 
80486:         return true;
80486:       }
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
    1: 
79445: bool
    1: nsHTMLDocument::TryUserForcedCharset(nsIMarkupDocumentViewer* aMarkupDV,
88007:                                      nsIDocShell*  aDocShell,
    1:                                      PRInt32& aCharsetSource,
    1:                                      nsACString& aCharset)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if(kCharsetFromUserForced <= aCharsetSource)
80486:     return true;
    1: 
    1:   nsCAutoString forceCharsetFromDocShell;
    1:   if (aMarkupDV) {
    1:     rv = aMarkupDV->GetForceCharacterSet(forceCharsetFromDocShell);
    1:   }
    1: 
    1:   if(NS_SUCCEEDED(rv) && !forceCharsetFromDocShell.IsEmpty()) {
    1:     aCharset = forceCharsetFromDocShell;
    1:     //TODO: we should define appropriate constant for force charset
    1:     aCharsetSource = kCharsetFromUserForced;
88007:   } else if (aDocShell) {
    1:     nsCOMPtr<nsIAtom> csAtom;
88007:     aDocShell->GetForcedCharset(getter_AddRefs(csAtom));
    1:     if (csAtom) {
    1:       csAtom->ToUTF8String(aCharset);
    1:       aCharsetSource = kCharsetFromUserForced;
88007:       aDocShell->SetForcedCharset(nsnull);
80486:       return true;
80486:     }
80486:   }
80486: 
80486:   return false;
    1: }
    1: 
79445: bool
46915: nsHTMLDocument::TryCacheCharset(nsICachingChannel* aCachingChannel,
    1:                                 PRInt32& aCharsetSource,
    1:                                 nsACString& aCharset)
    1: {
    1:   nsresult rv;
    1: 
    1:   if (kCharsetFromCache <= aCharsetSource) {
80486:     return true;
    1:   }
    1: 
46915:   nsCString cachedCharset;
46915:   rv = aCachingChannel->GetCacheTokenCachedCharset(cachedCharset);
    1:   if (NS_SUCCEEDED(rv) && !cachedCharset.IsEmpty())
    1:   {
    1:     aCharset = cachedCharset;
    1:     aCharsetSource = kCharsetFromCache;
    1: 
80486:     return true;
80486:   }
80486: 
80486:   return false;
    1: }
    1: 
79445: static bool
    1: CheckSameOrigin(nsINode* aNode1, nsINode* aNode2)
    1: {
    1:   NS_PRECONDITION(aNode1, "Null node?");
    1:   NS_PRECONDITION(aNode2, "Null node?");
    1: 
79445:   bool equal;
    1:   return
 3286:     NS_SUCCEEDED(aNode1->NodePrincipal()->
 3286:                    Equals(aNode2->NodePrincipal(), &equal)) &&
 3286:     equal;
    1: }
    1: 
79445: bool
88007: nsHTMLDocument::TryParentCharset(nsIDocShell*  aDocShell,
    1:                                  nsIDocument* aParentDocument,
    1:                                  PRInt32& aCharsetSource,
    1:                                  nsACString& aCharset)
    1: {
88007:   if (aDocShell) {
    1:     PRInt32 source;
    1:     nsCOMPtr<nsIAtom> csAtom;
    1:     PRInt32 parentSource;
88007:     aDocShell->GetParentCharsetSource(&parentSource);
    1:     if (kCharsetFromParentForced <= parentSource)
    1:       source = kCharsetFromParentForced;
    1:     else if (kCharsetFromHintPrevDoc == parentSource) {
    1:       // Make sure that's OK
    1:       if (!aParentDocument || !CheckSameOrigin(this, aParentDocument)) {
80486:         return false;
    1:       }
    1:       
    1:       // if parent is posted doc, set this prevent autodections
    1:       // I'm not sure this makes much sense... but whatever.
    1:       source = kCharsetFromHintPrevDoc;
    1:     }
    1:     else if (kCharsetFromCache <= parentSource) {
    1:       // Make sure that's OK
    1:       if (!aParentDocument || !CheckSameOrigin(this, aParentDocument)) {
80486:         return false;
    1:       }
    1: 
    1:       source = kCharsetFromParentFrame;
    1:     }
    1:     else
80486:       return false;
    1: 
    1:     if (source < aCharsetSource)
80486:       return true;
    1: 
88007:     aDocShell->GetParentCharset(getter_AddRefs(csAtom));
    1:     if (csAtom) {
    1:       csAtom->ToUTF8String(aCharset);
    1:       aCharsetSource = source;
80486:       return true;
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
79445: bool
    1: nsHTMLDocument::UseWeakDocTypeDefault(PRInt32& aCharsetSource,
    1:                                       nsACString& aCharset)
    1: {
    1:   if (kCharsetFromWeakDocTypeDefault <= aCharsetSource)
80486:     return true;
    1:   // fallback value in case docshell return error
    1:   aCharset.AssignLiteral("ISO-8859-1");
    1: 
70976:   const nsAdoptingCString& defCharset =
70976:     Preferences::GetLocalizedCString("intl.charset.default");
    1: 
    1:   if (!defCharset.IsEmpty()) {
70976:     aCharset = defCharset;
    1:     aCharsetSource = kCharsetFromWeakDocTypeDefault;
    1:   }
80486:   return true;
    1: }
    1: 
79445: bool
    1: nsHTMLDocument::TryDefaultCharset( nsIMarkupDocumentViewer* aMarkupDV,
    1:                                    PRInt32& aCharsetSource,
    1:                                    nsACString& aCharset)
    1: {
    1:   if(kCharsetFromUserDefault <= aCharsetSource)
80486:     return true;
    1: 
    1:   nsCAutoString defaultCharsetFromDocShell;
    1:   if (aMarkupDV) {
    1:     nsresult rv =
    1:       aMarkupDV->GetDefaultCharacterSet(defaultCharsetFromDocShell);
    1:     if(NS_SUCCEEDED(rv)) {
    1:       aCharset = defaultCharsetFromDocShell;
    1: 
    1:       aCharsetSource = kCharsetFromUserDefault;
80486:       return true;
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
    1: void
 1300: nsHTMLDocument::SetDocumentCharacterSet(const nsACString& aCharSetID)
 1300: {
 1300:   nsDocument::SetDocumentCharacterSet(aCharSetID);
 1300:   // Make sure to stash this charset on our channel as needed if it's a wyciwyg
 1300:   // channel.
 1300:   nsCOMPtr<nsIWyciwygChannel> wyciwygChannel = do_QueryInterface(mChannel);
 1300:   if (wyciwygChannel) {
 1300:     wyciwygChannel->SetCharsetAndSource(GetDocumentCharacterSetSource(),
 1300:                                         aCharSetID);
 1300:   }
 1300: }
 1300: 
    1: nsresult
    1: nsHTMLDocument::StartDocumentLoad(const char* aCommand,
    1:                                   nsIChannel* aChannel,
    1:                                   nsILoadGroup* aLoadGroup,
    1:                                   nsISupports* aContainer,
    1:                                   nsIStreamListener **aDocListener,
79445:                                   bool aReset,
    1:                                   nsIContentSink* aSink)
    1: {
92473:   if (!aCommand) {
92473:     MOZ_ASSERT(false, "Command is mandatory");
92473:     return NS_ERROR_INVALID_POINTER;
92473:   }
92473:   if (aSink) {
92473:     MOZ_ASSERT(false, "Got a sink override. Should not happen for HTML doc.");
92473:     return NS_ERROR_INVALID_ARG;
92473:   }
92473:   if (!mIsRegularHTML) {
92473:     MOZ_ASSERT(false, "Must not set HTML doc to XHTML mode before load start.");
92473:     return NS_ERROR_DOM_INVALID_STATE_ERR;
92473:   }
92473: 
81186:   nsCAutoString contentType;
81186:   aChannel->GetContentType(contentType);
81186: 
92473:   bool view = !strcmp(aCommand, "view") ||
92473:               !strcmp(aCommand, "external-resource");
92473:   bool viewSource = !strcmp(aCommand, "view-source");
92473:   bool asData = !strcmp(aCommand, kLoadAsData);
92473:   if(!(view || viewSource || asData)) {
92473:     MOZ_ASSERT(false, "Bad parser command");
92473:     return NS_ERROR_INVALID_ARG;
92473:   }
92473: 
92473:   bool html = contentType.EqualsLiteral(TEXT_HTML);
92473:   bool xhtml = !html && contentType.EqualsLiteral(APPLICATION_XHTML_XML);
92473:   bool plainText = !html && !xhtml && (contentType.EqualsLiteral(TEXT_PLAIN) ||
81186:     contentType.EqualsLiteral(TEXT_CSS) ||
81186:     contentType.EqualsLiteral(APPLICATION_JAVASCRIPT) ||
81186:     contentType.EqualsLiteral(APPLICATION_XJAVASCRIPT) ||
81186:     contentType.EqualsLiteral(TEXT_ECMASCRIPT) ||
81186:     contentType.EqualsLiteral(APPLICATION_ECMASCRIPT) ||
92473:     contentType.EqualsLiteral(TEXT_JAVASCRIPT) ||
92473:     contentType.EqualsLiteral(APPLICATION_JSON));
92473:   if (!(html || xhtml || plainText || viewSource)) {
92473:     MOZ_ASSERT(false, "Channel with bad content type.");
92473:     return NS_ERROR_INVALID_ARG;
92473:   }
92473: 
92473:   bool loadAsHtml5 = true;
92473: 
92473:   if (!viewSource && xhtml) {
    1:       // We're parsing XHTML as XML, remember that.
80486:       mIsRegularHTML = false;
    1:       mCompatMode = eCompatibility_FullStandards;
80486:       loadAsHtml5 = false;
29805:   }
37825:   
37825:   // TODO: Proper about:blank treatment is bug 543435
92473:   if (loadAsHtml5 && view) {
37825:     // mDocumentURI hasn't been set, yet, so get the URI from the channel
37825:     nsCOMPtr<nsIURI> uri;
37825:     aChannel->GetOriginalURI(getter_AddRefs(uri));
37825:     // Adapted from nsDocShell:
37825:     // GetSpec can be expensive for some URIs, so check the scheme first.
79445:     bool isAbout = false;
37825:     if (uri && NS_SUCCEEDED(uri->SchemeIs("about", &isAbout)) && isAbout) {
37825:       nsCAutoString str;
37825:       uri->GetSpec(str);
37825:       if (str.EqualsLiteral("about:blank")) {
80486:         loadAsHtml5 = false;    
37825:       }
37825:     }
37825:   }
37825:   
    1:   CSSLoader()->SetCompatibilityMode(mCompatMode);
    1:   
    1:   nsresult rv = nsDocument::StartDocumentLoad(aCommand,
    1:                                               aChannel, aLoadGroup,
    1:                                               aContainer,
    1:                                               aDocListener, aReset);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // Store the security info for future use with wyciwyg channels.
    1:   aChannel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   rv = aChannel->GetURI(getter_AddRefs(uri));
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsICachingChannel> cachingChan = do_QueryInterface(aChannel);
    1: 
29805:   if (loadAsHtml5) {
29805:     mParser = nsHtml5Module::NewHtml5Parser();
81186:     if (plainText) {
83038:       if (viewSource) {
83038:         mParser->MarkAsNotScriptCreated("view-source-plain");
83038:       } else {
81186:         mParser->MarkAsNotScriptCreated("plain-text");
83038:       }
92473:     } else if (viewSource && !html) {
81186:       mParser->MarkAsNotScriptCreated("view-source-xml");
81186:     } else {
81186:       mParser->MarkAsNotScriptCreated(aCommand);
81186:     }
29805:   } else {
    1:     mParser = do_CreateInstance(kCParserCID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   PRInt32 textType = GET_BIDI_OPTION_TEXTTYPE(GetBidiOptions());
    1: 
    1:   // Look for the parent document.  Note that at this point we don't have our
    1:   // content viewer set up yet, and therefore do not have a useful
    1:   // mParentDocument.
    1: 
    1:   // in this block of code, if we get an error result, we return it
    1:   // but if we get a null pointer, that's perfectly legal for parent
    1:   // and parentContentViewer
19869:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(aContainer));
19869: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(docShell));
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
19869:   if (docShellAsItem) {
    1:     docShellAsItem->GetSameTypeParent(getter_AddRefs(parentAsItem));
19869:   }
    1: 
    1:   nsCOMPtr<nsIDocShell> parent(do_QueryInterface(parentAsItem));
    1:   nsCOMPtr<nsIDocument> parentDocument;
    1:   nsCOMPtr<nsIContentViewer> parentContentViewer;
    1:   if (parent) {
    1:     rv = parent->GetContentViewer(getter_AddRefs(parentContentViewer));
    1:     NS_ENSURE_SUCCESS(rv, rv);
37433:     if (parentContentViewer) {
37433:       parentDocument = parentContentViewer->GetDocument();
    1:     }
    1:   }
    1: 
    1:   //
    1:   // The following logic is mirrored in nsWebShell::Embed!
    1:   //
    1:   nsCOMPtr<nsIMarkupDocumentViewer> muCV;
79445:   bool muCVIsParent = false;
    1:   nsCOMPtr<nsIContentViewer> cv;
19869:   if (docShell) {
    1:     docShell->GetContentViewer(getter_AddRefs(cv));
19869:   }
    1:   if (cv) {
    1:      muCV = do_QueryInterface(cv);
    1:   } else {
    1:     muCV = do_QueryInterface(parentContentViewer);
    1:     if (muCV) {
80486:       muCVIsParent = true;
    1:     }
    1:   }
    1: 
    1:   nsCAutoString urlSpec;
    1:   uri->GetSpec(urlSpec);
    1: #ifdef DEBUG_charset
    1:   printf("Determining charset for %s\n", urlSpec.get());
    1: #endif
    1: 
 1300:   // These are the charset source and charset for our document
    1:   PRInt32 charsetSource;
    1:   nsCAutoString charset;
    1: 
 1300:   // These are the charset source and charset for the parser.  This can differ
 1300:   // from that for the document if the channel is a wyciwyg channel.
 1300:   PRInt32 parserCharsetSource;
 1300:   nsCAutoString parserCharset;
 1300: 
 1300:   nsCOMPtr<nsIWyciwygChannel> wyciwygChannel;
 1300:   
82543:   if (!IsHTML() || !docShell) { // no docshell for text/html XHR
82543:     charsetSource = IsHTML() ? kCharsetFromWeakDocTypeDefault
82543:                              : kCharsetFromDocTypeDefault;
    1:     charset.AssignLiteral("UTF-8");
    1:     TryChannelCharset(aChannel, charsetSource, charset);
 1300:     parserCharsetSource = charsetSource;
 1300:     parserCharset = charset;
    1:   } else {
19869:     NS_ASSERTION(docShell && docShellAsItem, "Unexpected null value");
19869: 
    1:     charsetSource = kCharsetUninitialized;
 1300:     wyciwygChannel = do_QueryInterface(aChannel);
    1: 
    1:     // The following charset resolving calls has implied knowledge
    1:     // about charset source priority order. Each try will return true
    1:     // if the source is higher or equal to the source as its name
    1:     // describes. Some try call might change charset source to
    1:     // multiple values, like TryHintCharset and TryParentCharset. It
    1:     // should be always safe to try more sources.
88007:     if (!TryUserForcedCharset(muCV, docShell, charsetSource, charset)) {
    1:       TryHintCharset(muCV, charsetSource, charset);
88007:       TryParentCharset(docShell, parentDocument, charsetSource, charset);
 1300: 
 1300:       // Don't actually get the charset from the channel if this is a
 1300:       // wyciwyg channel; it'll always be UTF-16
 1300:       if (!wyciwygChannel &&
 1300:           TryChannelCharset(aChannel, charsetSource, charset)) {
    1:         // Use the channel's charset (e.g., charset from HTTP
    1:         // "Content-Type" header).
    1:       }
46915:       else if (cachingChan && !urlSpec.IsEmpty() &&
46915:                TryCacheCharset(cachingChan, charsetSource, charset)) {
    1:         // Use the cache's charset.
    1:       }
    1:       else if (TryDefaultCharset(muCV, charsetSource, charset)) {
    1:         // Use the default charset.
    1:         // previous document charset might be inherited as default charset.
    1:       }
    1:       else {
    1:         // Use the weak doc type default charset
    1:         UseWeakDocTypeDefault(charsetSource, charset);
    1:       }
    1:     }
    1: 
79445:     bool isPostPage = false;
    1:     // check if current doc is from POST command
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:     if (httpChannel) {
    1:       nsCAutoString methodStr;
    1:       rv = httpChannel->GetRequestMethod(methodStr);
    1:       isPostPage = (NS_SUCCEEDED(rv) &&
    1:                     methodStr.EqualsLiteral("POST"));
    1:     }
    1: 
    1:     if (isPostPage && muCV && kCharsetFromHintPrevDoc > charsetSource) {
    1:       nsCAutoString requestCharset;
    1:       muCV->GetPrevDocCharacterSet(requestCharset);
    1:       if (!requestCharset.IsEmpty()) {
    1:         charsetSource = kCharsetFromHintPrevDoc;
    1:         charset = requestCharset;
    1:       }
    1:     }
    1: 
 1300:     if (wyciwygChannel) {
 1300:       // We know for sure that the parser needs to be using UTF16.
 1300:       parserCharset = "UTF-16";
 1300:       parserCharsetSource = charsetSource < kCharsetFromChannel ?
 1300:         kCharsetFromChannel : charsetSource;
 1300:         
 1300:       nsCAutoString cachedCharset;
 1300:       PRInt32 cachedSource;
 1300:       rv = wyciwygChannel->GetCharsetAndSource(&cachedSource, cachedCharset);
 1300:       if (NS_SUCCEEDED(rv)) {
 1300:         if (cachedSource > charsetSource) {
 1300:           charsetSource = cachedSource;
 1300:           charset = cachedCharset;
 1300:         }
 1300:       } else {
 1300:         // Don't propagate this error.
 1300:         rv = NS_OK;
 1300:       }
 1300:       
 1300:     } else {
 1300:       parserCharset = charset;
 1300:       parserCharsetSource = charsetSource;
 1300:     }
 1300: 
    1:     // ahmed
    1:     // Check if 864 but in Implicit mode !
    1:     if ((textType == IBMBIDI_TEXTTYPE_LOGICAL) &&
    1:         (charset.LowerCaseEqualsLiteral("ibm864"))) {
    1:       charset.AssignLiteral("IBM864i");
    1:     }
    1:   }
    1: 
 1300:   SetDocumentCharacterSetSource(charsetSource);
    1:   SetDocumentCharacterSet(charset);
    1: 
    1:   // set doc charset to muCV for next document.
    1:   // Don't propagate this back up to the parent document if we have one.
    1:   if (muCV && !muCVIsParent)
    1:     muCV->SetPrevDocCharacterSet(charset);
    1: 
46915:   if (cachingChan) {
 1300:     NS_ASSERTION(charset == parserCharset,
 1300:                  "How did those end up different here?  wyciwyg channels are "
 1300:                  "not nsICachingChannel");
46915:     rv = cachingChan->SetCacheTokenCachedCharset(charset);
71387:     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "cannot SetMetaDataElement");
82543:     rv = NS_OK; // don't propagate error
    1:   }
    1: 
    1:   // Set the parser as the stream listener for the document loader...
82458:   rv = NS_OK;
82297:   nsCOMPtr<nsIStreamListener> listener = mParser->GetStreamListener();
82297:   listener.forget(aDocListener);
    1: 
    1: #ifdef DEBUG_charset
    1:   printf(" charset = %s source %d\n",
    1:         charset.get(), charsetSource);
    1: #endif
 1300:   mParser->SetDocumentCharset(parserCharset, parserCharsetSource);
    1:   mParser->SetCommand(aCommand);
    1: 
31946:   if (!IsHTML()) {
92473:     MOZ_ASSERT(!loadAsHtml5);
    1:     nsCOMPtr<nsIXMLContentSink> xmlsink;
92473:     NS_NewXMLContentSink(getter_AddRefs(xmlsink), this, uri,
    1:                          docShell, aChannel);
92473:     mParser->SetContentSink(xmlsink);
    1:   } else {
29805:     if (loadAsHtml5) {
29805:       nsHtml5Module::Initialize(mParser, this, uri, docShell, aChannel);
29805:     } else {
92473:       // about:blank *only*
    1:       nsCOMPtr<nsIHTMLContentSink> htmlsink;
92473:       NS_NewHTMLContentSink(getter_AddRefs(htmlsink), this, uri,
    1:                             docShell, aChannel);
92473:       mParser->SetContentSink(htmlsink);
92473:     }
92473:   }
92473: 
    1:   // parser the content of the URI
    1:   mParser->Parse(uri, nsnull, (void *)this);
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::StopDocumentLoad()
    1: {
57562:   BlockOnload();
57562: 
57562:   // Remove the wyciwyg channel request from the document load group
87801:   // that we added in Open() if Open() was called on this doc.
57562:   RemoveWyciwygChannel();
57562:   NS_ASSERTION(!mWyciwygChannel, "nsHTMLDocument::StopDocumentLoad(): "
57562:                "nsIWyciwygChannel could not be removed!");
87801: 
57562:   nsDocument::StopDocumentLoad();
80486:   UnblockOnload(false);
57562:   return;
57562: }
    1: 
    1: void
39450: nsHTMLDocument::BeginLoad()
39450: {
39450:   if (IsEditingOn()) {
39450:     // Reset() blows away all event listeners in the document, and our
39450:     // editor relies heavily on those. Midas is turned on, to make it
39450:     // work, re-initialize it to give it a chance to add its event
39450:     // listeners again.
39450: 
39450:     TurnEditingOff();
39450:     EditingStateChanged();
39450:   }
39450:   nsDocument::BeginLoad();
39450: }
39450: 
39450: void
    1: nsHTMLDocument::EndLoad()
    1: {
79445:   bool turnOnEditing =
 2896:     mParser && (HasFlag(NODE_IS_EDITABLE) || mContentEditableCount > 0);
    1:   // Note: nsDocument::EndLoad nulls out mParser.
    1:   nsDocument::EndLoad();
 2896:   if (turnOnEditing) {
 2896:     EditingStateChanged();
 2896:   }
    1: }
    1: 
    1: void
    1: nsHTMLDocument::SetCompatibilityMode(nsCompatibility aMode)
    1: {
31946:   NS_ASSERTION(IsHTML() || aMode == eCompatibility_FullStandards,
    1:                "Bad compat mode for XHTML document!");
    1: 
    1:   mCompatMode = aMode;
    1:   CSSLoader()->SetCompatibilityMode(mCompatMode);
46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
    1:   if (shell) {
    1:     nsPresContext *pc = shell->GetPresContext();
    1:     if (pc) {
    1:       pc->CompatibilityModeChanged();
    1:     }
    1:   }
    1: }
    1: 
    1: //
    1: // nsIDOMHTMLDocument interface implementation
    1: //
    1: void
    1: nsHTMLDocument::GetDomainURI(nsIURI **aURI)
    1: {
    1:   nsIPrincipal *principal = NodePrincipal();
    1: 
    1:   principal->GetDomain(aURI);
    1:   if (!*aURI) {
    1:     principal->GetURI(aURI);
    1:   }
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetDomain(nsAString& aDomain)
    1: {
    1:   nsCOMPtr<nsIURI> uri;
    1:   GetDomainURI(getter_AddRefs(uri));
    1: 
    1:   if (!uri) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCAutoString hostName;
    1: 
    1:   if (NS_SUCCEEDED(uri->GetHost(hostName))) {
    1:     CopyUTF8toUTF16(hostName, aDomain);
    1:   } else {
    1:     // If we can't get the host from the URI (e.g. about:, javascript:,
    1:     // etc), just return an null string.
    1:     SetDOMStringToNull(aDomain);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetDomain(const nsAString& aDomain)
    1: {
    1:   if (aDomain.IsEmpty())
    1:     return NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN;
    1: 
    1:   // Create new URI
    1:   nsCOMPtr<nsIURI> uri;
    1:   GetDomainURI(getter_AddRefs(uri));
    1: 
    1:   if (!uri) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
 9732:   nsCAutoString newURIString;
 9732:   if (NS_FAILED(uri->GetScheme(newURIString)))
 9732:     return NS_ERROR_FAILURE;
 9732:   nsCAutoString path;
 9732:   if (NS_FAILED(uri->GetPath(path)))
 9732:     return NS_ERROR_FAILURE;
 9732:   newURIString.AppendLiteral("://");
 9732:   AppendUTF16toUTF8(aDomain, newURIString);
 9732:   newURIString.Append(path);
 9732: 
    1:   nsCOMPtr<nsIURI> newURI;
 9732:   if (NS_FAILED(NS_NewURI(getter_AddRefs(newURI), newURIString)))
 9732:     return NS_ERROR_FAILURE;
    1: 
 7845:   // Check new domain - must be a superdomain of the current host
 7845:   // For example, a page from foo.bar.com may set domain to bar.com,
 7845:   // but not to ar.com, baz.com, or fi.foo.bar.com.
 7845:   nsCAutoString current, domain;
11364:   if (NS_FAILED(uri->GetAsciiHost(current)))
 7845:     current.Truncate();
11364:   if (NS_FAILED(newURI->GetAsciiHost(domain)))
 7845:     domain.Truncate();
 7845: 
79445:   bool ok = current.Equals(domain);
 7845:   if (current.Length() > domain.Length() &&
 7845:       StringEndsWith(current, domain) &&
 7845:       current.CharAt(current.Length() - domain.Length() - 1) == '.') {
11364:     // We're golden if the new domain is the current page's base domain or a
11364:     // subdomain of it.
 7845:     nsCOMPtr<nsIEffectiveTLDService> tldService =
 7845:       do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID);
 7845:     if (!tldService)
 7845:       return NS_ERROR_NOT_AVAILABLE;
 7845: 
11364:     nsCAutoString currentBaseDomain;
11364:     ok = NS_SUCCEEDED(tldService->GetBaseDomain(uri, 0, currentBaseDomain));
11364:     NS_ASSERTION(StringEndsWith(domain, currentBaseDomain) ==
11364:                  (domain.Length() >= currentBaseDomain.Length()),
11364:                  "uh-oh!  slight optimization wasn't valid somehow!");
11364:     ok = ok && domain.Length() >= currentBaseDomain.Length();
 7845:   }
 7845:   if (!ok) {
 7845:     // Error: illegal domain
 7845:     return NS_ERROR_DOM_BAD_DOCUMENT_DOMAIN;
 7845:   }
 7845: 
    1:   return NodePrincipal()->SetDomain(newURI);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetURL(nsAString& aURL)
    1: {
    1:   nsCAutoString str;
    1: 
    1:   if (mDocumentURI) {
    1:     mDocumentURI->GetSpec(str);
    1:   }
    1: 
    1:   CopyUTF8toUTF16(str, aURL);
    1: 
    1:   return NS_OK;
    1: }
    1: 
42425: nsIContent*
82947: nsHTMLDocument::GetBody()
42425: {
42425:   Element* body = GetBodyElement();
42425: 
42425:   if (body) {
42425:     // There is a body element, return that as the body.
42425:     return body;
42425:   }
42425: 
42425:   // The document is most likely a frameset document so look for the
42425:   // outer most frameset element
46343:   nsRefPtr<nsContentList> nodeList =
63637:     NS_GetContentList(this, kNameSpaceID_XHTML, NS_LITERAL_STRING("frameset"));
42425: 
42425:   return nodeList->GetNodeAt(0);
42425: }
42425: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetBody(nsIDOMHTMLElement** aBody)
    1: {
    1:   *aBody = nsnull;
    1: 
82947:   nsIContent *body = GetBody();
82947: 
82947:   return body ? CallQueryInterface(body, aBody) : NS_OK;
 8938: }
 8938: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetBody(nsIDOMHTMLElement* aBody)
    1: {
 8938:   nsCOMPtr<nsIContent> newBody = do_QueryInterface(aBody);
41634:   Element* root = GetRootElement();
 8938: 
 8938:   // The body element must be either a body tag or a frameset tag. And we must
 8938:   // have a html root tag, otherwise GetBody will not return the newly set
 8938:   // body.
 8938:   if (!newBody || !(newBody->Tag() == nsGkAtoms::body ||
 8938:                     newBody->Tag() == nsGkAtoms::frameset) ||
33329:       !root || !root->IsHTML() ||
 8938:       root->Tag() != nsGkAtoms::html) {
    1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:   }
    1: 
 8938:   nsCOMPtr<nsIDOMElement> rootElem = do_QueryInterface(root);
    1:   nsCOMPtr<nsIDOMNode> tmp;
    1: 
 8938:   // Use DOM methods so that we pass through the appropriate security checks.
41634:   nsCOMPtr<nsIDOMNode> currentBody = do_QueryInterface(GetBodyElement());
 8938:   if (currentBody) {
 8938:     return rootElem->ReplaceChild(aBody, currentBody, getter_AddRefs(tmp));
 8938:   }
 8938: 
 8938:   return rootElem->AppendChild(aBody, getter_AddRefs(tmp));
    1: }
    1: 
    1: NS_IMETHODIMP
42111: nsHTMLDocument::GetHead(nsIDOMHTMLHeadElement** aHead)
42111: {
42111:   *aHead = nsnull;
42111: 
42111:   Element* head = GetHeadElement();
42111: 
42111:   return head ? CallQueryInterface(head, aHead) : NS_OK;
42111: }
42111: 
42111: NS_IMETHODIMP
    1: nsHTMLDocument::GetImages(nsIDOMHTMLCollection** aImages)
    1: {
    1:   if (!mImages) {
53966:     mImages = new nsContentList(this, kNameSpaceID_XHTML, nsGkAtoms::img, nsGkAtoms::img);
    1:   }
    1: 
    1:   *aImages = mImages;
    1:   NS_ADDREF(*aImages);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetApplets(nsIDOMHTMLCollection** aApplets)
    1: {
    1:   if (!mApplets) {
53966:     mApplets = new nsContentList(this, kNameSpaceID_XHTML, nsGkAtoms::applet, nsGkAtoms::applet);
    1:   }
    1: 
    1:   *aApplets = mApplets;
    1:   NS_ADDREF(*aApplets);
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: bool
    1: nsHTMLDocument::MatchLinks(nsIContent *aContent, PRInt32 aNamespaceID,
    1:                            nsIAtom* aAtom, void* aData)
    1: {
    1:   nsIDocument* doc = aContent->GetCurrentDoc();
    1: 
    1:   if (doc) {
    1:     NS_ASSERTION(aContent->IsInDoc(),
    1:                  "This method should never be called on content nodes that "
    1:                  "are not in a document!");
    1: #ifdef DEBUG
    1:     {
    1:       nsCOMPtr<nsIHTMLDocument> htmldoc =
    1:         do_QueryInterface(aContent->GetCurrentDoc());
    1:       NS_ASSERTION(htmldoc,
    1:                    "Huh, how did this happen? This should only be used with "
    1:                    "HTML documents!");
    1:     }
    1: #endif
    1: 
    1:     nsINodeInfo *ni = aContent->NodeInfo();
    1: 
    1:     nsIAtom *localName = ni->NameAtom();
29004:     if (ni->NamespaceID() == kNameSpaceID_XHTML &&
    1:         (localName == nsGkAtoms::a || localName == nsGkAtoms::area)) {
    1:       return aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::href);
    1:     }
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetLinks(nsIDOMHTMLCollection** aLinks)
    1: {
    1:   if (!mLinks) {
    1:     mLinks = new nsContentList(this, MatchLinks, nsnull, nsnull);
    1:   }
    1: 
    1:   *aLinks = mLinks;
    1:   NS_ADDREF(*aLinks);
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: bool
    1: nsHTMLDocument::MatchAnchors(nsIContent *aContent, PRInt32 aNamespaceID,
    1:                              nsIAtom* aAtom, void* aData)
    1: {
    1:   NS_ASSERTION(aContent->IsInDoc(),
    1:                "This method should never be called on content nodes that "
    1:                "are not in a document!");
    1: #ifdef DEBUG
    1:   {
    1:     nsCOMPtr<nsIHTMLDocument> htmldoc =
    1:       do_QueryInterface(aContent->GetCurrentDoc());
    1:     NS_ASSERTION(htmldoc,
    1:                  "Huh, how did this happen? This should only be used with "
    1:                  "HTML documents!");
    1:   }
    1: #endif
    1: 
29004:   if (aContent->NodeInfo()->Equals(nsGkAtoms::a, kNameSpaceID_XHTML)) {
    1:     return aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::name);
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetAnchors(nsIDOMHTMLCollection** aAnchors)
    1: {
    1:   if (!mAnchors) {
    1:     mAnchors = new nsContentList(this, MatchAnchors, nsnull, nsnull);
    1:   }
    1: 
    1:   *aAnchors = mAnchors;
    1:   NS_ADDREF(*aAnchors);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
78151: nsHTMLDocument::GetScripts(nsIDOMHTMLCollection** aScripts)
78151: {
78151:   if (!mScripts) {
78151:     mScripts = new nsContentList(this, kNameSpaceID_XHTML, nsGkAtoms::script, nsGkAtoms::script);
78151:   }
78151: 
78151:   *aScripts = mScripts;
78151:   NS_ADDREF(*aScripts);
78151: 
78151:   return NS_OK;
78151: }
78151: 
78151: NS_IMETHODIMP
    1: nsHTMLDocument::GetCookie(nsAString& aCookie)
    1: {
    1:   aCookie.Truncate(); // clear current cookie in case service fails;
    1:                       // no cookie isn't an error condition.
    1: 
19951:   if (mDisableCookieAccess) {
19951:     return NS_OK;
19951:   }
19951: 
    1:   // not having a cookie service isn't an error
    1:   nsCOMPtr<nsICookieService> service = do_GetService(NS_COOKIESERVICE_CONTRACTID);
    1:   if (service) {
    1:     // Get a URI from the document principal. We use the original
    1:     // codebase in case the codebase was changed by SetDomain
    1:     nsCOMPtr<nsIURI> codebaseURI;
    1:     NodePrincipal()->GetURI(getter_AddRefs(codebaseURI));
    1: 
    1:     if (!codebaseURI) {
    1:       // Document's principal is not a codebase (may be system), so
    1:       // can't set cookies
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsXPIDLCString cookie;
    1:     service->GetCookieString(codebaseURI, mChannel, getter_Copies(cookie));
    1:     CopyASCIItoUTF16(cookie, aCookie);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetCookie(const nsAString& aCookie)
    1: {
19951:   if (mDisableCookieAccess) {
19951:     return NS_OK;
19951:   }
19951: 
    1:   // not having a cookie service isn't an error
    1:   nsCOMPtr<nsICookieService> service = do_GetService(NS_COOKIESERVICE_CONTRACTID);
    1:   if (service && mDocumentURI) {
    1:     nsCOMPtr<nsIPrompt> prompt;
    1:     nsCOMPtr<nsPIDOMWindow> window = GetWindow();
    1:     if (window) {
    1:       window->GetPrompter(getter_AddRefs(prompt));
    1:     }
    1: 
74805:     // The for getting the URI matches nsNavigator::GetCookieEnabled
    1:     nsCOMPtr<nsIURI> codebaseURI;
    1:     NodePrincipal()->GetURI(getter_AddRefs(codebaseURI));
    1: 
    1:     if (!codebaseURI) {
    1:       // Document's principal is not a codebase (may be system), so
    1:       // can't set cookies
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     NS_LossyConvertUTF16toASCII cookie(aCookie);
    1:     service->SetCookieString(codebaseURI, prompt, cookie.get(), mChannel);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
71266: NS_IMETHODIMP
71266: nsHTMLDocument::Open(const nsAString& aContentTypeOrUrl,
71266:                      const nsAString& aReplaceOrName,
71266:                      const nsAString& aFeatures,
71266:                      JSContext* cx, PRUint8 aOptionalArgCount,
71266:                      nsISupports** aReturn)
    1: {
71266:   NS_ASSERTION(nsContentUtils::CanCallerAccess(static_cast<nsIDOMHTMLDocument*>(this)),
71266:                "XOW should have caught this!");
71266: 
71266:   // When called with 3 or more arguments, document.open() calls window.open().
71266:   if (aOptionalArgCount > 2) {
73870:     nsCOMPtr<nsIDOMWindow> window = GetWindowInternal();
71266:     if (!window) {
71266:       return NS_OK;
71266:     }
71266:     nsCOMPtr<nsIDOMWindow> newWindow;
71266:     nsresult rv = window->Open(aContentTypeOrUrl, aReplaceOrName, aFeatures,
71266:                                getter_AddRefs(newWindow));
71266:     *aReturn = newWindow.forget().get();
71266:     return rv;
71266:   }
71266: 
34616:   if (!IsHTML() || mDisableDocWrite) {
    1:     // No calling document.open() on XHTML
40128:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1:   }
    1: 
71266:   nsCAutoString contentType;
71266:   contentType.AssignLiteral("text/html");
71266:   if (aOptionalArgCount > 0) {
71266:     nsAutoString type;
91979:     nsContentUtils::ASCIIToLower(aContentTypeOrUrl, type);
71266:     nsCAutoString actualType, dummy;
71266:     NS_ParseContentType(NS_ConvertUTF16toUTF8(type), actualType, dummy);
71266:     if (!actualType.EqualsLiteral("text/html") &&
71266:         !type.EqualsLiteral("replace")) {
71266:       contentType.AssignLiteral("text/plain");
71266:     }
71266:   }
    1: 
    1:   // If we already have a parser we ignore the document.open call.
    1:   if (mParser) {
    1:     return NS_OK;
    1:   }
    1: 
82205:   // No calling document.open() without a script global object
82205:   if (!mScriptGlobalObject) {
82205:     return NS_OK;
82205:   }
82205: 
82205:   nsPIDOMWindow* outer = GetWindow();
82205:   if (!outer || (GetInnerWindow() != outer->GetCurrentInnerWindow())) {
82205:     return NS_OK;
82205:   }
82205: 
 2400:   // check whether we're in the middle of unload.  If so, ignore this call.
 2400:   nsCOMPtr<nsIDocShell> shell = do_QueryReferent(mDocumentContainer);
15756:   if (!shell) {
15756:     // We won't be able to create a parser anyway.
15756:     return NS_OK;
15756:   }
15756: 
79445:   bool inUnload;
 2400:   shell->GetIsInUnload(&inUnload);
 2400:   if (inUnload) {
 2400:     return NS_OK;
 2400:   }
 2400: 
    1:   // Note: We want to use GetDocumentFromContext here because this document
    1:   // should inherit the security information of the document that's opening us,
24057:   // (since if it's secure, then it's presumably trusted).
    1:   nsCOMPtr<nsIDocument> callerDoc =
    1:     do_QueryInterface(nsContentUtils::GetDocumentFromContext());
22698:   if (!callerDoc) {
22698:     // If we're called from C++ or in some other way without an originating
22698:     // document we can't do a document.open w/o changing the principal of the
22698:     // document to something like about:blank (as that's the only sane thing to
22698:     // do when we don't know the origin of this call), and since we can't
22698:     // change the principals of a document for security reasons we'll have to
22698:     // refuse to go ahead with this call.
22698: 
22698:     return NS_ERROR_DOM_SECURITY_ERR;
22698:   }
    1: 
    1:   // Grab a reference to the calling documents security info (if any)
21811:   // and URIs as they may be lost in the call to Reset().
22698:   nsCOMPtr<nsISupports> securityInfo = callerDoc->GetSecurityInfo();
22698:   nsCOMPtr<nsIURI> uri = callerDoc->GetDocumentURI();
22698:   nsCOMPtr<nsIURI> baseURI = callerDoc->GetBaseURI();
22698:   nsCOMPtr<nsIPrincipal> callerPrincipal = callerDoc->NodePrincipal();
88544:   nsCOMPtr<nsIChannel> callerChannel = callerDoc->GetChannel();
10689: 
10689:   // We're called from script. Make sure the script is from the same
10689:   // origin, not just that the caller can access the document. This is
10689:   // needed to keep document principals from ever changing, which is
10689:   // needed because of the way we use our XOW code, and is a sane
10689:   // thing to do anyways.
10689: 
79445:   bool equals = false;
10689:   if (NS_FAILED(callerPrincipal->Equals(NodePrincipal(), &equals)) ||
10689:       !equals) {
55824: 
55824: #ifdef DEBUG
55824:     nsCOMPtr<nsIURI> callerDocURI = callerDoc->GetDocumentURI();
55824:     nsCOMPtr<nsIURI> thisURI = nsIDocument::GetDocumentURI();
55824:     nsCAutoString callerSpec;
55824:     nsCAutoString thisSpec;
55824:     if (callerDocURI) {
55824:       callerDocURI->GetSpec(callerSpec);
55824:     }
55824:     if (thisURI) {
55824:       thisURI->GetSpec(thisSpec);
55824:     }
71266:     printf("nsHTMLDocument::Open callerDoc %s this %s\n", callerSpec.get(), thisSpec.get());
55824: #endif
55824: 
10689:     return NS_ERROR_DOM_SECURITY_ERR;
10689:   }
    1: 
    1:   // Stop current loads targeted at the window this document is in.
15756:   if (mScriptGlobalObject) {
    1:     nsCOMPtr<nsIContentViewer> cv;
15756:     shell->GetContentViewer(getter_AddRefs(cv));
    1: 
    1:     if (cv) {
79445:       bool okToUnload;
80486:       if (NS_SUCCEEDED(cv->PermitUnload(false, &okToUnload)) && !okToUnload) {
    1:         // We don't want to unload, so stop here, but don't throw an
    1:         // exception.
    1:         return NS_OK;
    1:       }
    1:     }
    1: 
15756:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(shell));
    1:     webnav->Stop(nsIWebNavigation::STOP_NETWORK);
40932: 
40932:     // The Stop call may have cancelled the onload blocker request or prevented
40932:     // it from getting added, so we need to make sure it gets added to the
40932:     // document again otherwise the document could have a non-zero onload block
40932:     // count without the onload blocker request being in the loadgroup.
40932:     EnsureOnloadBlocker();
    1:   }
    1: 
    1:   // The open occurred after the document finished loading.
    1:   // So we reset the document and create a new one.
    1:   nsCOMPtr<nsIChannel> channel;
    1:   nsCOMPtr<nsILoadGroup> group = do_QueryReferent(mDocumentLoadGroup);
    1: 
71266:   nsresult rv = NS_NewChannel(getter_AddRefs(channel), uri, nsnull, group);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
21811:   // We can't depend on channels implementing property bags, so do our
21811:   // base URI manually after reset.
21811: 
    1:   // Set the caller principal, if any, on the channel so that we'll
    1:   // make sure to use it when we reset.
    1:   rv = channel->SetOwner(callerPrincipal);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
88544:   if (callerChannel) {
88544:     nsLoadFlags callerLoadFlags;
88544:     rv = callerChannel->GetLoadFlags(&callerLoadFlags);
88544:     NS_ENSURE_SUCCESS(rv, rv);
88544: 
88544:     nsLoadFlags loadFlags;
88544:     rv = channel->GetLoadFlags(&loadFlags);
88544:     NS_ENSURE_SUCCESS(rv, rv);
88544: 
88544:     loadFlags |= callerLoadFlags & nsIRequest::INHIBIT_PERSISTENT_CACHING;
88544: 
88544:     rv = channel->SetLoadFlags(loadFlags);
88544:     NS_ENSURE_SUCCESS(rv, rv);
88544:   }
88544: 
    1:   // Before we reset the doc notify the globalwindow of the change,
    1:   // but only if we still have a window (i.e. our window object the
    1:   // current inner window in our outer window).
    1: 
    1:   // Hold onto ourselves on the offchance that we're down to one ref
    1:   nsCOMPtr<nsIDOMDocument> kungFuDeathGrip =
    1:     do_QueryInterface((nsIHTMLDocument*)this);
    1: 
    1:   nsPIDOMWindow *window = GetInnerWindow();
    1:   if (window) {
    1:     // Remember the old scope in case the call to SetNewDocument changes it.
    1:     nsCOMPtr<nsIScriptGlobalObject> oldScope(do_QueryReferent(mScopeObject));
    1: 
31428: #ifdef DEBUG
79445:     bool willReparent = mWillReparent;
80486:     mWillReparent = true;
31428: #endif
31428: 
80486:     // Should this pass true for aForceReuseInnerWindow?
80486:     rv = window->SetNewDocument(this, nsnull, false);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
31428: #ifdef DEBUG
31428:     mWillReparent = willReparent;
31428: #endif
31428: 
    1:     // Now make sure we're not flagged as the initial document anymore, now
    1:     // that we've had stuff done to us.  From now on, if anyone tries to
    1:     // document.open() us, they get a new inner window.
80486:     SetIsInitialDocument(false);
    1: 
    1:     nsCOMPtr<nsIScriptGlobalObject> newScope(do_QueryReferent(mScopeObject));
    1:     if (oldScope && newScope != oldScope) {
83207:       rv = nsContentUtils::ReparentContentWrappersInScope(cx, oldScope, newScope);
83207:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
28216:   // Call Reset(), this will now do the full reset
    1:   Reset(channel, group);
21811:   if (baseURI) {
21811:     mDocumentBaseURI = baseURI;
21811:   }
    1: 
    1:   // Store the security info of the caller now that we're done
    1:   // resetting the document.
    1:   mSecurityInfo = securityInfo;
    1: 
92399:   mParserAborted = false;
29805:   mParser = nsHtml5Module::NewHtml5Parser();
92473:   nsHtml5Module::Initialize(mParser, this, uri, shell, channel);
29805:   rv = NS_OK;
    1: 
    1:   // This will be propagated to the parser when someone actually calls write()
71266:   SetContentTypeInternal(contentType);
    1: 
    1:   // Prepare the docshell and the document viewer for the impending
    1:   // out of band document.write()
15756:   shell->PrepareForNewContentModel();
    1: 
    1:   // Now check whether we were opened with a "replace" argument.  If
    1:   // so, we need to tell the docshell to not create a new history
 3101:   // entry for this load. Otherwise, make sure that we're doing a normal load,
 3101:   // not whatever type of load was previously done on this docshell.
71266:   shell->SetLoadType(
71266:     (aOptionalArgCount > 1 && aReplaceOrName.EqualsLiteral("replace"))
71266:     ? LOAD_NORMAL_REPLACE : LOAD_NORMAL);
    1: 
    1:   nsCOMPtr<nsIContentViewer> cv;
15756:   shell->GetContentViewer(getter_AddRefs(cv));
80401:   if (cv) {
80401:     cv->LoadStart(static_cast<nsIHTMLDocument *>(this));
    1:   }
    1: 
    1:   // Add a wyciwyg channel request into the document load group
71266:   NS_ASSERTION(!mWyciwygChannel, "nsHTMLDocument::Open(): wyciwyg "
    1:                "channel already exists!");
    1: 
    1:   // In case the editor is listening and will see the new channel
    1:   // being added, make sure mWriteLevel is non-zero so that the editor
    1:   // knows that document.open/write/close() is being called on this
    1:   // document.
    1:   ++mWriteLevel;
    1: 
    1:   CreateAndAddWyciwygChannel();
    1: 
    1:   --mWriteLevel;
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   return CallQueryInterface(this, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Clear()
    1: {
    1:   // This method has been deprecated
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::Close()
    1: {
31946:   if (!IsHTML()) {
    1:     // No calling document.close() on XHTML!
    1: 
40128:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1:   }
    1: 
87801:   if (!mParser || !mParser->IsScriptCreated()) {
87801:     return NS_OK;
87801:   }
    1: 
    1:   ++mWriteLevel;
87803:   nsresult rv = mParser->Parse(EmptyString(), nsnull,
80486:                                GetContentTypeInternal(), true);
    1:   --mWriteLevel;
    1: 
    1:   // XXX Make sure that all the document.written content is
    1:   // reflowed.  We should remove this call once we change
    1:   // nsHTMLDocument::OpenCommon() so that it completely destroys the
    1:   // earlier document's content and frame hierarchy.  Right now, it
    1:   // re-uses the earlier document's root content object and
    1:   // corresponding frame objects.  These re-used frame objects think
    1:   // that they have already been reflowed, so they drop initial
    1:   // reflows.  For certain cases of document.written content, like a
    1:   // frameset document, the dropping of the initial reflow means
    1:   // that we end up in document.close() without appended any reflow
    1:   // commands to the reflow queue and, consequently, without adding
    1:   // the dummy layout request to the load group.  Since the dummy
    1:   // layout request is not added to the load group, the onload
    1:   // handler of the frameset fires before the frames get reflowed
    1:   // and loaded.  That is the long explanation for why we need this
    1:   // one line of code here!
    1:   // XXXbz as far as I can tell this may not be needed anymore; all
    1:   // the testcases in bug 57636 pass without this line...  Leaving
    1:   // it be for now, though.  In any case, there's no reason to do
    1:   // this if we have no presshell, since in that case none of the
    1:   // above about reusing frames applies.
87801:   //
87801:   // XXXhsivonen keeping this around for bug 577508 / 253951 still :-(
46225:   if (GetShell()) {
    1:     FlushPendingNotifications(Flush_Layout);
    1:   }
    1: 
87801:   // Removing the wyciwygChannel here is wrong when document.close() is
87801:   // called from within the document itself. However, legacy requires the
87801:   // channel to be removed here. Otherwise, the load event never fires.
    1:   NS_ASSERTION(mWyciwygChannel, "nsHTMLDocument::Close(): Trying to remove "
42587:                "nonexistent wyciwyg channel!");
    1:   RemoveWyciwygChannel();
    1:   NS_ASSERTION(!mWyciwygChannel, "nsHTMLDocument::Close(): "
    1:                "nsIWyciwygChannel could not be removed!");
87801:   return rv;
    1: }
    1: 
    1: nsresult
71036: nsHTMLDocument::WriteCommon(JSContext *cx,
71036:                             const nsAString& aText,
79445:                             bool aNewlineTerminate)
    1: {
    1:   mTooDeepWriteRecursion =
    1:     (mWriteLevel > NS_MAX_DOCUMENT_WRITE_DEPTH || mTooDeepWriteRecursion);
    1:   NS_ENSURE_STATE(!mTooDeepWriteRecursion);
    1: 
34616:   if (!IsHTML() || mDisableDocWrite) {
    1:     // No calling document.write*() on XHTML!
    1: 
40128:     return NS_ERROR_DOM_INVALID_STATE_ERR;
    1:   }
    1: 
92399:   if (mParserAborted) {
92399:     // Hixie says aborting the parser doesn't undefine the insertion point.
92399:     // However, since we null out mParser in that case, we track the
92399:     // theoretically defined insertion point using mParserAborted.
92399:     return NS_OK;
92399:   }
92399: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   void *key = GenerateParserKey();
87801:   if (mParser && !mParser->IsInsertionPointDefined()) {
47680:     if (mExternalScriptsBeingEvaluated) {
47680:       // Instead of implying a call to document.open(), ignore the call.
84636:       nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
84636:                                       "DOM Events", this,
84636:                                       nsContentUtils::eDOM_PROPERTIES,
47680:                                       "DocumentWriteIgnored",
47680:                                       nsnull, 0,
84636:                                       mDocumentURI);
47680:       return NS_OK;
47680:     }
    1:     mParser->Terminate();
    1:     NS_ASSERTION(!mParser, "mParser should have been null'd out");
    1:   }
    1: 
    1:   if (!mParser) {
47680:     if (mExternalScriptsBeingEvaluated) {
47680:       // Instead of implying a call to document.open(), ignore the call.
84636:       nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
84636:                                       "DOM Events", this,
84636:                                       nsContentUtils::eDOM_PROPERTIES,
47680:                                       "DocumentWriteIgnored",
47680:                                       nsnull, 0,
84636:                                       mDocumentURI);
47680:       return NS_OK;
47680:     }
71037:     nsCOMPtr<nsISupports> ignored;
71037:     rv = Open(NS_LITERAL_STRING("text/html"), EmptyString(), EmptyString(), cx,
71037:               1, getter_AddRefs(ignored));
    1: 
    1:     // If Open() fails, or if it didn't create a parser (as it won't
    1:     // if the user chose to not discard the current document through
    1:     // onbeforeunload), don't write anything.
    1:     if (NS_FAILED(rv) || !mParser) {
    1:       return rv;
    1:     }
83207:     NS_ABORT_IF_FALSE(!JS_IsExceptionPending(cx),
83207:                       "Open() succeeded but JS exception is pending");
    1:   }
    1: 
    1:   static NS_NAMED_LITERAL_STRING(new_line, "\n");
    1: 
87803:   // Save the data in cache if the write isn't from within the doc
87803:   if (mWyciwygChannel && !key) {
    1:     if (!aText.IsEmpty()) {
    1:       mWyciwygChannel->WriteToCacheEntry(aText);
    1:     }
    1: 
    1:     if (aNewlineTerminate) {
    1:       mWyciwygChannel->WriteToCacheEntry(new_line);
    1:     }
    1:   }
    1: 
    1:   ++mWriteLevel;
    1: 
    1:   // This could be done with less code, but for performance reasons it
    1:   // makes sense to have the code for two separate Parse() calls here
    1:   // since the concatenation of strings costs more than we like. And
    1:   // why pay that price when we don't need to?
    1:   if (aNewlineTerminate) {
    1:     rv = mParser->Parse(aText + new_line,
46309:                         key, GetContentTypeInternal(),
87801:                         false);
    1:   } else {
    1:     rv = mParser->Parse(aText,
46309:                         key, GetContentTypeInternal(),
87801:                         false);
    1:   }
    1: 
    1:   --mWriteLevel;
    1: 
    1:   mTooDeepWriteRecursion = (mWriteLevel != 0 && mTooDeepWriteRecursion);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
71036: nsHTMLDocument::Write(const nsAString& aText, JSContext *cx)
    1: {
80486:   return WriteCommon(cx, aText, false);
    1: }
    1: 
    1: NS_IMETHODIMP
71036: nsHTMLDocument::Writeln(const nsAString& aText, JSContext *cx)
    1: {
80486:   return WriteCommon(cx, aText, true);
    1: }
    1: 
79445: bool
    1: nsHTMLDocument::MatchNameAttribute(nsIContent* aContent, PRInt32 aNamespaceID,
    1:                                    nsIAtom* aAtom, void* aData)
    1: {
    1:   NS_PRECONDITION(aContent, "Must have content node to work with!");
 3233:   nsString* elementName = static_cast<nsString*>(aData);
29405:   return
29405:     aContent->GetNameSpaceID() == kNameSpaceID_XHTML &&
29405:     aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name,
    1:                           *elementName, eCaseMatters);
    1: }
    1: 
43324: /* static */
43324: void*
43324: nsHTMLDocument::UseExistingNameString(nsINode* aRootNode, const nsString* aName)
43324: {
43324:   return const_cast<nsString*>(aName);
43324: }
43324: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetElementsByName(const nsAString& aElementName,
    1:                                   nsIDOMNodeList** aReturn)
    1: {
42425:   nsRefPtr<nsContentList> list = GetElementsByName(aElementName);
42425:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
38013:   // Transfer ownership
42425:   list.forget(aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::AddedForm()
    1: {
    1:   ++mNumForms;
    1: }
    1: 
    1: void
    1: nsHTMLDocument::RemovedForm()
    1: {
    1:   --mNumForms;
    1: }
    1: 
    1: PRInt32
    1: nsHTMLDocument::GetNumFormsSynchronous()
    1: {
    1:   return mNumForms;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetAlinkColor(nsAString& aAlinkColor)
    1: {
    1:   aAlinkColor.Truncate();
    1: 
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->GetALink(aAlinkColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetAlinkColor(const nsAString& aAlinkColor)
    1: {
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->SetALink(aAlinkColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetLinkColor(nsAString& aLinkColor)
    1: {
    1:   aLinkColor.Truncate();
    1: 
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->GetLink(aLinkColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetLinkColor(const nsAString& aLinkColor)
    1: {
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->SetLink(aLinkColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetVlinkColor(nsAString& aVlinkColor)
    1: {
    1:   aVlinkColor.Truncate();
    1: 
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->GetVLink(aVlinkColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetVlinkColor(const nsAString& aVlinkColor)
    1: {
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->SetVLink(aVlinkColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetBgColor(nsAString& aBgColor)
    1: {
    1:   aBgColor.Truncate();
    1: 
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->GetBgColor(aBgColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetBgColor(const nsAString& aBgColor)
    1: {
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->SetBgColor(aBgColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetFgColor(nsAString& aFgColor)
    1: {
    1:   aFgColor.Truncate();
    1: 
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->GetText(aFgColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::SetFgColor(const nsAString& aFgColor)
    1: {
41634:   nsCOMPtr<nsIDOMHTMLBodyElement> body = do_QueryInterface(GetBodyElement());
    1:   if (body) {
    1:     body->SetText(aFgColor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetEmbeds(nsIDOMHTMLCollection** aEmbeds)
    1: {
    1:   if (!mEmbeds) {
53966:     mEmbeds = new nsContentList(this, kNameSpaceID_XHTML, nsGkAtoms::embed, nsGkAtoms::embed);
    1:   }
    1: 
    1:   *aEmbeds = mEmbeds;
    1:   NS_ADDREF(*aEmbeds);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
73541: nsHTMLDocument::GetSelection(nsISelection** aReturn)
    1: {
31585:   nsCOMPtr<nsIDOMWindow> window = do_QueryInterface(GetScopeObject());
31585:   nsCOMPtr<nsPIDOMWindow> pwin = do_QueryInterface(window);
31585:   NS_ENSURE_TRUE(pwin, NS_OK);
31585:   NS_ASSERTION(pwin->IsInnerWindow(), "Should have inner window here!");
31585:   NS_ENSURE_TRUE(pwin->GetOuterWindow() &&
31585:                  pwin->GetOuterWindow()->GetCurrentInnerWindow() == pwin,
31585:                  NS_OK);
    1: 
73541:   return window->GetSelection(aReturn);
73541:   
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::CaptureEvents(PRInt32 aEventFlags)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfCaptureEventsWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::ReleaseEvents(PRInt32 aEventFlags)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfReleaseEventsWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::RouteEvent(nsIDOMEvent* aEvt)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfRouteEventWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: // readonly attribute DOMString compatMode;
    1: // Returns "BackCompat" if we are in quirks mode, "CSS1Compat" if we are
    1: // in almost standards or full standards mode. See bug 105640.  This was
    1: // implemented to match MSIE's compatMode property
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetCompatMode(nsAString& aCompatMode)
    1: {
    1:   NS_ASSERTION(mCompatMode == eCompatibility_NavQuirks ||
    1:                mCompatMode == eCompatibility_AlmostStandards ||
    1:                mCompatMode == eCompatibility_FullStandards,
    1:                "mCompatMode is neither quirks nor strict for this document");
    1: 
    1:   if (mCompatMode == eCompatibility_NavQuirks) {
    1:     aCompatMode.AssignLiteral("BackCompat");
    1:   } else {
    1:     aCompatMode.AssignLiteral("CSS1Compat");
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Mapped to document.embeds for NS4 compatibility
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetPlugins(nsIDOMHTMLCollection** aPlugins)
    1: {
    1:   *aPlugins = nsnull;
    1: 
    1:   return GetEmbeds(aPlugins);
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::ResolveName(const nsAString& aName,
69024:                             nsIContent *aForm,
48170:                             nsISupports **aResult,
48170:                             nsWrapperCache **aCache)
    1: {
    1:   *aResult = nsnull;
48170:   *aCache = nsnull;
    1: 
68823:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(aName);
68823:   if (!entry) {
    1:     return NS_OK;
    1:   }
    1: 
68823:   PRUint32 length = 0;
15474:   nsBaseContentList *list = entry->GetNameContentList();
68823:   if (list) {
    1:     list->GetLength(&length);
68823:   }
    1: 
    1:   if (length > 0) {
    1:     if (length == 1) {
    1:       // Only one element in the list, return the element instead of
    1:       // returning the list
    1: 
48170:       nsIContent *node = list->GetNodeAt(0);
48170:       if (!aForm || nsContentUtils::BelongsInForm(aForm, node)) {
48170:         NS_ADDREF(*aResult = node);
48170:         *aCache = node;
48170:       }
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     // The list contains more than one element, return the whole
    1:     // list, unless...
    1: 
    1:     if (aForm) {
    1:       // ... we're called from a form, in that case we create a
20752:       // nsFormContentList which will filter out the elements in the
    1:       // list that don't belong to aForm
    1: 
    1:       nsFormContentList *fc_list = new nsFormContentList(aForm, *list);
    1:       NS_ENSURE_TRUE(fc_list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       PRUint32 len;
    1:       fc_list->GetLength(&len);
    1: 
    1:       if (len < 2) {
    1:         // After the nsFormContentList is done filtering there's either
    1:         // nothing or one element in the list.  Return that element, or null
    1:         // if there's no element in the list.
    1: 
48170:         nsIContent *node = fc_list->GetNodeAt(0);
    1: 
    1:         NS_IF_ADDREF(*aResult = node);
48170:         *aCache = node;
    1: 
    1:         delete fc_list;
    1: 
    1:         return NS_OK;
    1:       }
    1: 
    1:       list = fc_list;
    1:     }
    1: 
    1:     return CallQueryInterface(list, aResult);
    1:   }
    1: 
    1:   // No named items were found, see if there's one registerd by id for
    1:   // aName. If we get this far, FindNamedItems() will have been called
    1:   // for aName, so we're guaranteed that if there is an element with
    1:   // the id aName, it'll be entry's IdContent.
    1: 
41635:   Element *e = entry->GetIdElement();
    1: 
33329:   if (e && e->IsHTML()) {
    1:     nsIAtom *tag = e->Tag();
    1: 
    1:     if ((tag == nsGkAtoms::embed  ||
    1:          tag == nsGkAtoms::img    ||
    1:          tag == nsGkAtoms::object ||
    1:          tag == nsGkAtoms::applet) &&
    1:         (!aForm || nsContentUtils::BelongsInForm(aForm, e))) {
    1:       NS_ADDREF(*aResult = e);
48170:       *aCache = e;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------
    1: 
    1: // forms related stuff
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetForms(nsIDOMHTMLCollection** aForms)
    1: {
    1:   nsContentList *forms = nsHTMLDocument::GetForms();
    1:   if (!forms)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*aForms = forms);
    1:   return NS_OK;
    1: }
    1: 
    1: nsContentList*
    1: nsHTMLDocument::GetForms()
    1: {
53966:   if (!mForms) {
53966:     mForms = new nsContentList(this, kNameSpaceID_XHTML, nsGkAtoms::form, nsGkAtoms::form);
53966:   }
    1: 
    1:   return mForms;
    1: }
    1: 
79445: static bool MatchFormControls(nsIContent* aContent, PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAtom, void* aData)
    1: {
    1:   return aContent->IsNodeOfType(nsIContent::eHTML_FORM_CONTROL);
    1: }
    1: 
    1: nsContentList*
    1: nsHTMLDocument::GetFormControls()
    1: {
    1:   if (!mFormControls) {
    1:     mFormControls = new nsContentList(this, MatchFormControls, nsnull, nsnull);
    1:   }
    1: 
    1:   return mFormControls;
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::CreateAndAddWyciwygChannel(void)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsCAutoString url, originalSpec;
    1: 
    1:   mDocumentURI->GetSpec(originalSpec);
    1: 
    1:   // Generate the wyciwyg url
    1:   url = NS_LITERAL_CSTRING("wyciwyg://")
    1:       + nsPrintfCString("%d", gWyciwygSessionCnt++)
    1:       + NS_LITERAL_CSTRING("/")
    1:       + originalSpec;
    1: 
    1:   nsCOMPtr<nsIURI> wcwgURI;
    1:   NS_NewURI(getter_AddRefs(wcwgURI), url);
    1: 
    1:   // Create the nsIWyciwygChannel to store out-of-band
    1:   // document.write() script to cache
    1:   nsCOMPtr<nsIChannel> channel;
    1:   // Create a wyciwyg Channel
    1:   rv = NS_NewChannel(getter_AddRefs(channel), wcwgURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mWyciwygChannel = do_QueryInterface(channel);
    1: 
    1:   mWyciwygChannel->SetSecurityInfo(mSecurityInfo);
    1: 
 1300:   // Note: we want to treat this like a "previous document" hint so that,
 1300:   // e.g. a <meta> tag in the document.write content can override it.
 4527:   SetDocumentCharacterSetSource(kCharsetFromHintPrevDoc);
 1300:   mWyciwygChannel->SetCharsetAndSource(kCharsetFromHintPrevDoc,
 1300:                                        GetDocumentCharacterSet());
 1300: 
    1:   // Use our new principal
    1:   channel->SetOwner(NodePrincipal());
    1: 
    1:   // Inherit load flags from the original document's channel
    1:   channel->SetLoadFlags(mLoadFlags);
    1: 
    1:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1: 
    1:   // Use the Parent document's loadgroup to trigger load notifications
    1:   if (loadGroup && channel) {
    1:     rv = channel->SetLoadGroup(loadGroup);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsLoadFlags loadFlags = 0;
    1:     channel->GetLoadFlags(&loadFlags);
    1:     loadFlags |= nsIChannel::LOAD_DOCUMENT_URI;
    1:     channel->SetLoadFlags(loadFlags);
    1: 
    1:     channel->SetOriginalURI(wcwgURI);
    1: 
    1:     rv = loadGroup->AddRequest(mWyciwygChannel, nsnull);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to add request to load group.");
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::RemoveWyciwygChannel(void)
    1: {
    1:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1: 
    1:   // note there can be a write request without a load group if
    1:   // this is a synchronously constructed about:blank document
    1:   if (loadGroup && mWyciwygChannel) {
    1:     mWyciwygChannel->CloseCacheEntry(NS_OK);
    1:     loadGroup->RemoveRequest(mWyciwygChannel, nsnull, NS_OK);
    1:   }
    1: 
    1:   mWyciwygChannel = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void *
    1: nsHTMLDocument::GenerateParserKey(void)
    1: {
    1:   if (!mScriptLoader) {
    1:     // If we don't have a script loader, then the parser probably isn't parsing
    1:     // anything anyway, so just return null.
    1:     return nsnull;
    1:   }
    1: 
    1:   // The script loader provides us with the currently executing script element,
    1:   // which is guaranteed to be unique per script.
57326:   nsIScriptElement* script = mScriptLoader->GetCurrentParserInsertedScript();
34983:   if (script && mParser && mParser->IsScriptCreated()) {
34983:     nsCOMPtr<nsIParser> creatorParser = script->GetCreatorParser();
34983:     if (creatorParser != mParser) {
34983:       // Make scripts that aren't inserted by the active parser of this document
34983:       // participate in the context of the script that document.open()ed
34983:       // this document.
87803:       return nsnull;
34983:     }
34983:   }
34983:   return script;
34983: }
    1: 
    1: /* attribute DOMString designMode; */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::GetDesignMode(nsAString & aDesignMode)
    1: {
 2896:   if (HasFlag(NODE_IS_EDITABLE)) {
    1:     aDesignMode.AssignLiteral("on");
    1:   }
    1:   else {
    1:     aDesignMode.AssignLiteral("off");
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 7199: void
24482: nsHTMLDocument::MaybeEditingStateChanged()
24482: {
37955:   if (mUpdateNestLevel == 0 && (mContentEditableCount > 0) != IsEditingOn()) {
24482:     if (nsContentUtils::IsSafeToRunScript()) {
24482:       EditingStateChanged();
24482:     } else if (!mInDestructor) {
24482:       nsContentUtils::AddScriptRunner(
41361:         NS_NewRunnableMethod(this, &nsHTMLDocument::MaybeEditingStateChanged));
24482:     }
24482:   }
24482: }
24482: 
24482: void
 7199: nsHTMLDocument::EndUpdate(nsUpdateType aUpdateType)
 7199: {
 7199:   nsDocument::EndUpdate(aUpdateType);
 7199: 
24482:   MaybeEditingStateChanged();
 7199: }
 7199: 
47892: 
47892: // Helper class, used below in ChangeContentEditableCount().
47892: class DeferredContentEditableCountChangeEvent : public nsRunnable
47892: {
47892: public:
47892:   DeferredContentEditableCountChangeEvent(nsHTMLDocument *aDoc,
47892:                                           nsIContent *aElement)
47892:     : mDoc(aDoc)
47892:     , mElement(aElement)
47892:   {
47892:   }
47892: 
47892:   NS_IMETHOD Run() {
80526:     if (mElement && mElement->OwnerDoc() == mDoc) {
47892:       mDoc->DeferredContentEditableCountChange(mElement);
47892:     }
47892:     return NS_OK;
47892:   }
47892: 
47892: private:
47892:   nsRefPtr<nsHTMLDocument> mDoc;
47892:   nsCOMPtr<nsIContent> mElement;
47892: };
47892: 
 2896: nsresult
 2896: nsHTMLDocument::ChangeContentEditableCount(nsIContent *aElement,
 2896:                                            PRInt32 aChange)
    1: {
 2896:   NS_ASSERTION(mContentEditableCount + aChange >= 0,
 2896:                "Trying to decrement too much.");
 2896: 
 2896:   mContentEditableCount += aChange;
 2896: 
42453:   nsContentUtils::AddScriptRunner(
42453:     new DeferredContentEditableCountChangeEvent(this, aElement));
42453: 
42453:   return NS_OK;
42453: }
42453: 
42453: void
42453: nsHTMLDocument::DeferredContentEditableCountChange(nsIContent *aElement)
42453: {
 7199:   if (mParser ||
37955:       (mUpdateNestLevel > 0 && (mContentEditableCount > 0) != IsEditingOn())) {
42453:     return;
 2896:   }
 2896: 
 2896:   EditingState oldState = mEditingState;
 2896: 
 2896:   nsresult rv = EditingStateChanged();
42453:   NS_ENSURE_SUCCESS(rv, );
 2896: 
 2896:   if (oldState == mEditingState && mEditingState == eContentEditable) {
 2896:     // We just changed the contentEditable state of a node, we need to reset
 2896:     // the spellchecking state of that node.
 2896:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aElement);
 2896:     if (node) {
 2896:       nsPIDOMWindow *window = GetWindow();
 2896:       if (!window)
42453:         return;
 2896: 
 2896:       nsIDocShell *docshell = window->GetDocShell();
 2896:       if (!docshell)
42453:         return;
 2896: 
 2896:       nsCOMPtr<nsIEditorDocShell> editorDocShell =
 2896:         do_QueryInterface(docshell, &rv);
42453:       NS_ENSURE_SUCCESS(rv, );
 2896: 
 2896:       nsCOMPtr<nsIEditor> editor;
 3605:       editorDocShell->GetEditor(getter_AddRefs(editor));
 3605:       if (editor) {
86939:         nsRefPtr<nsRange> range = new nsRange();
 2896:         rv = range->SelectNode(node);
73978:         if (NS_FAILED(rv)) {
73978:           // The node might be detached from the document at this point,
73978:           // which would cause this call to fail.  In this case, we can
73978:           // safely ignore the contenteditable count change.
73978:           return;
73978:         }
 2896: 
 2896:         nsCOMPtr<nsIInlineSpellChecker> spellChecker;
80486:         rv = editor->GetInlineSpellChecker(false,
 2896:                                            getter_AddRefs(spellChecker));
42453:         NS_ENSURE_SUCCESS(rv, );
 2896: 
 2896:         if (spellChecker) {
 2896:           rv = spellChecker->SpellCheckRange(range);
42453:         }
42453:       }
42453:     }
42453:   }
 2896: }
 2896: 
79445: static bool
 3991: DocAllResultMatch(nsIContent* aContent, PRInt32 aNamespaceID, nsIAtom* aAtom,
 3991:                   void* aData)
 3991: {
 3991:   if (aContent->GetID() == aAtom) {
80486:     return true;
 3991:   }
 3991: 
 3991:   nsGenericHTMLElement* elm = nsGenericHTMLElement::FromContent(aContent);
29004:   if (!elm) {
80486:     return false;
 3991:   }
 3991: 
 3991:   nsIAtom* tag = elm->Tag();
18404:   if (tag != nsGkAtoms::a &&
18404:       tag != nsGkAtoms::applet &&
18404:       tag != nsGkAtoms::button &&
18404:       tag != nsGkAtoms::embed &&
 3991:       tag != nsGkAtoms::form &&
18404:       tag != nsGkAtoms::iframe &&
18404:       tag != nsGkAtoms::img &&
18404:       tag != nsGkAtoms::input &&
18404:       tag != nsGkAtoms::map &&
18404:       tag != nsGkAtoms::meta &&
 3991:       tag != nsGkAtoms::object &&
18404:       tag != nsGkAtoms::select &&
18404:       tag != nsGkAtoms::textarea) {
80486:     return false;
 3991:   }
 3991: 
 3991:   const nsAttrValue* val = elm->GetParsedAttr(nsGkAtoms::name);
 3991:   return val && val->Type() == nsAttrValue::eAtom &&
 3991:          val->GetAtomValue() == aAtom;
 3991: }
 3991: 
 3991: 
48170: nsISupports*
48170: nsHTMLDocument::GetDocumentAllResult(const nsAString& aID,
48170:                                      nsWrapperCache** aCache,
48170:                                      nsresult *aResult)
 3991: {
48170:   *aCache = nsnull;
48170:   *aResult = NS_OK;
 3991: 
43946:   nsIdentifierMapEntry *entry = mIdentifierMap.PutEntry(aID);
48170:   if (!entry) {
48170:     *aResult = NS_ERROR_OUT_OF_MEMORY;
48170: 
48170:     return nsnull;
48170:   }
 3991: 
41634:   Element* root = GetRootElement();
 8938:   if (!root) {
48170:     return nsnull;
 3991:   }
 3991: 
15474:   nsRefPtr<nsContentList> docAllList = entry->GetDocAllList();
15474:   if (!docAllList) {
43946:     nsCOMPtr<nsIAtom> id = do_GetAtom(aID);
43946: 
15474:     docAllList = new nsContentList(root, DocAllResultMatch,
80486:                                    nsnull, nsnull, true, id);
15474:     entry->SetDocAllList(docAllList);
15474:   }
15253: 
 3991:   // Check if there are more than 1 entries. Do this by getting the second one
 3991:   // rather than the length since getting the length always requires walking
 3991:   // the entire document.
 3991: 
80486:   nsIContent* cont = docAllList->Item(1, true);
 3991:   if (cont) {
48170:     *aCache = docAllList;
48170:     return static_cast<nsINodeList*>(docAllList);
 3991:   }
 3991: 
 3991:   // There's only 0 or 1 items. Return the first one or null.
80486:   *aCache = cont = docAllList->Item(0, true);
48170: 
48170:   return cont;
 3991: }
 3991: 
 2896: static void
80674: NotifyEditableStateChange(nsINode *aNode, nsIDocument *aDocument)
 2896: {
78992:   for (nsIContent* child = aNode->GetFirstChild();
78992:        child;
78992:        child = child->GetNextSibling()) {
80674:     if (child->IsElement()) {
71121:       child->AsElement()->UpdateState(true);
 2896:     }
80674:     NotifyEditableStateChange(child, aDocument);
 2896:   }
 2896: }
 2896: 
11925: void
11925: nsHTMLDocument::TearingDownEditor(nsIEditor *aEditor)
11925: {
11925:   if (IsEditingOn()) {
24935:     EditingState oldState = mEditingState;
11925:     mEditingState = eTearingDown;
11925: 
56924:     nsCOMPtr<nsIPresShell> presShell = GetShell();
56924:     if (!presShell)
56924:       return;
56924: 
56924:     nsCOMArray<nsIStyleSheet> agentSheets;
56924:     presShell->GetAgentStyleSheets(agentSheets);
56924: 
56924:     RemoveFromAgentSheets(agentSheets, NS_LITERAL_STRING("resource://gre/res/contenteditable.css"));
24935:     if (oldState == eDesignMode)
56924:       RemoveFromAgentSheets(agentSheets, NS_LITERAL_STRING("resource://gre/res/designmode.css"));
56924: 
56924:     presShell->SetAgentStyleSheets(agentSheets);
56924: 
56924:     presShell->ReconstructStyleData();
11925:   }
11925: }
11925: 
 2896: nsresult
 2896: nsHTMLDocument::TurnEditingOff()
 2896: {
 2896:   NS_ASSERTION(mEditingState != eOff, "Editing is already off.");
 2896: 
 2896:   nsPIDOMWindow *window = GetWindow();
 2896:   if (!window)
 2896:     return NS_ERROR_FAILURE;
 2896: 
 2896:   nsIDocShell *docshell = window->GetDocShell();
 2896:   if (!docshell)
 2896:     return NS_ERROR_FAILURE;
 2896: 
 2896:   nsresult rv;
 2896:   nsCOMPtr<nsIEditingSession> editSession = do_GetInterface(docshell, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   // turn editing off
 7856:   rv = editSession->TearDownEditorOnWindow(window);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   mEditingState = eOff;
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
79445: static bool HasPresShell(nsPIDOMWindow *aWindow)
 7289: {
 7289:   nsIDocShell *docShell = aWindow->GetDocShell();
 7289:   if (!docShell)
80486:     return false;
 7289:   nsCOMPtr<nsIPresShell> presShell;
 7289:   docShell->GetPresShell(getter_AddRefs(presShell));
 7289:   return presShell != nsnull;
 7289: }
 7289: 
 2896: nsresult
14631: nsHTMLDocument::SetEditingState(EditingState aState)
14631: {
14631:   mEditingState = aState;
14631:   return NS_OK;
14631: }
14631: 
14631: nsresult
 2896: nsHTMLDocument::EditingStateChanged()
 2896: {
14887:   if (mRemovedFromDocShell) {
14887:     return NS_OK;
14887:   }
14887: 
11925:   if (mEditingState == eSettingUp || mEditingState == eTearingDown) {
 2896:     // XXX We shouldn't recurse.
 2896:     return NS_OK;
 2896:   }
 2896: 
79445:   bool designMode = HasFlag(NODE_IS_EDITABLE);
 2896:   EditingState newState = designMode ? eDesignMode :
 2896:                           (mContentEditableCount > 0 ? eContentEditable : eOff);
 2896:   if (mEditingState == newState) {
 2896:     // No changes in editing mode.
 2896:     return NS_OK;
 2896:   }
 2896: 
 2896:   if (newState == eOff) {
 2896:     // Editing is being turned off.
80674:     nsAutoScriptBlocker scriptBlocker;
80674:     NotifyEditableStateChange(this, this);
 2896:     return TurnEditingOff();
 2896:   }
 2896: 
50364:   // Flush out style changes on our _parent_ document, if any, so that
50364:   // our check for a presshell won't get stale information.
50364:   if (mParentDocument) {
50364:     mParentDocument->FlushPendingNotifications(Flush_Style);
50364:   }
50364: 
55676:   // get editing session, make sure this is a strong reference so the
55676:   // window can't get deleted during the rest of this call.
55676:   nsCOMPtr<nsPIDOMWindow> window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDocShell *docshell = window->GetDocShell();
    1:   if (!docshell)
    1:     return NS_ERROR_FAILURE;
    1: 
 2896:   nsresult rv;
 2896:   nsCOMPtr<nsIEditingSession> editSession = do_GetInterface(docshell, &rv);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
58662:   nsCOMPtr<nsIEditor> existingEditor;
58662:   editSession->GetEditorForWindow(window, getter_AddRefs(existingEditor));
58662:   if (existingEditor) {
58662:     // We might already have an editor if it was set up for mail, let's see
58662:     // if this is actually the case.
58662:     nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(existingEditor);
58662:     NS_ABORT_IF_FALSE(htmlEditor, "If we have an editor, it must be an HTML editor");
58662:     PRUint32 flags = 0;
58662:     existingEditor->GetFlags(&flags);
58662:     if (flags & nsIPlaintextEditor::eEditorMailMask) {
58662:       // We already have a mail editor, then we should not attempt to create
58662:       // another one.
58662:       return NS_OK;
58662:     }
58662:   }
58662: 
 7350:   if (!HasPresShell(window)) {
 7289:     // We should not make the window editable or setup its editor.
 7289:     // It's probably style=display:none.
 7289:     return NS_OK;
 7289:   }
 7289: 
79445:   bool makeWindowEditable = mEditingState == eOff;
68468:   bool updateState = false;
79445:   bool spellRecheckAll = false;
19360:   nsCOMPtr<nsIEditor> editor;
19360: 
19360:   {
24935:     EditingState oldState = mEditingState;
19360:     nsAutoEditingState push(this, eSettingUp);
19360: 
 7350:     if (makeWindowEditable) {
 2896:       // Editing is being turned on (through designMode or contentEditable)
 2896:       // Turn on editor.
 2896:       // XXX This can cause flushing which can change the editing state, so make
 2896:       //     sure to avoid recursing.
80486:       rv = editSession->MakeWindowEditable(window, "html", false, false,
80486:                                            true);
 2896:       NS_ENSURE_SUCCESS(rv, rv);
 7350:     }
 2896: 
 2896:     // XXX Need to call TearDownEditorOnWindow for all failures.
 2896:     nsCOMPtr<nsIEditorDocShell> editorDocShell =
 2896:       do_QueryInterface(docshell, &rv);
 2896:     NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 3605:     editorDocShell->GetEditor(getter_AddRefs(editor));
 3605:     if (!editor)
 3605:       return NS_ERROR_FAILURE;
 2896: 
56924:     nsCOMPtr<nsIPresShell> presShell = GetShell();
56924:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
56924: 
57276:     // If we're entering the design mode, put the selection at the beginning of
57276:     // the document for compatibility reasons.
60697:     if (designMode && oldState == eOff) {
62326:       editor->BeginningOfDocument();
57276:     }
57276: 
56924:     nsCOMArray<nsIStyleSheet> agentSheets;
56924:     rv = presShell->GetAgentStyleSheets(agentSheets);
 2896:     NS_ENSURE_SUCCESS(rv, rv);
 2896: 
56924:     nsCOMPtr<nsIURI> uri;
56924:     rv = NS_NewURI(getter_AddRefs(uri), NS_LITERAL_STRING("resource://gre/res/contenteditable.css"));
56924:     NS_ENSURE_SUCCESS(rv, rv);
56924: 
56924:     nsRefPtr<nsCSSStyleSheet> sheet;
80486:     rv = LoadChromeSheetSync(uri, true, getter_AddRefs(sheet));
56924:     NS_ENSURE_TRUE(sheet, rv);
56924: 
56924:     rv = agentSheets.AppendObject(sheet);
56924:     NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:     // Should we update the editable state of all the nodes in the document? We
 2896:     // need to do this when the designMode value changes, as that overrides
 2896:     // specific states on the elements.
 2896:     if (designMode) {
 2896:       // designMode is being turned on (overrides contentEditable).
56924:       rv = NS_NewURI(getter_AddRefs(uri), NS_LITERAL_STRING("resource://gre/res/designmode.css"));
56924:       NS_ENSURE_SUCCESS(rv, rv);
56924: 
80486:       rv = LoadChromeSheetSync(uri, true, getter_AddRefs(sheet));
56924:       NS_ENSURE_TRUE(sheet, rv);
56924: 
56924:       rv = agentSheets.AppendObject(sheet);
56924:       NS_ENSURE_SUCCESS(rv, rv);
 2896: 
56925:       // Disable scripting and plugins.
56925:       rv = editSession->DisableJSAndPlugins(window);
56925:       NS_ENSURE_SUCCESS(rv, rv);
56925: 
68468:       updateState = true;
56925:       spellRecheckAll = oldState == eContentEditable;
56925:     }
56925:     else if (oldState == eDesignMode) {
56925:       // designMode is being turned off (contentEditable is still on).
56925:       RemoveFromAgentSheets(agentSheets, NS_LITERAL_STRING("resource://gre/res/designmode.css"));
56925: 
56925:       rv = editSession->RestoreJSAndPlugins(window);
56925:       NS_ENSURE_SUCCESS(rv, rv);
56925: 
68468:       updateState = true;
56925:     }
56925: 
56925:     rv = presShell->SetAgentStyleSheets(agentSheets);
56925:     NS_ENSURE_SUCCESS(rv, rv);
56925: 
56925:     presShell->ReconstructStyleData();
19360:   }
 2896: 
 2896:   mEditingState = newState;
 2896: 
 7350:   if (makeWindowEditable) {
 2896:     // Set the editor to not insert br's on return when in p
 2896:     // elements by default.
 2896:     // XXX Do we only want to do this for designMode?
79445:     bool unused;
80486:     rv = ExecCommand(NS_LITERAL_STRING("insertBrOnReturn"), false,
 2896:                      NS_LITERAL_STRING("false"), &unused);
 2896: 
 2896:     if (NS_FAILED(rv)) {
 2896:       // Editor setup failed. Editing is not on after all.
 2896:       // XXX Should we reset the editable flag on nodes?
 7856:       editSession->TearDownEditorOnWindow(window);
 2896:       mEditingState = eOff;
 2896: 
 2896:       return rv;
 2896:     }
 7350:   }
 2896: 
 2896:   if (updateState) {
71103:     nsAutoScriptBlocker scriptBlocker;
80674:     NotifyEditableStateChange(this, this);
 2896:   }
 2896: 
 2896:   // Resync the editor's spellcheck state.
 2896:   if (spellRecheckAll) {
 2896:     nsCOMPtr<nsISelectionController> selcon;
 2896:     nsresult rv = editor->GetSelectionController(getter_AddRefs(selcon));
 2896:     NS_ENSURE_SUCCESS(rv, rv); 
 2896: 
 2896:     nsCOMPtr<nsISelection> spellCheckSelection;
 2896:     rv = selcon->GetSelection(nsISelectionController::SELECTION_SPELLCHECK,
 2896:                               getter_AddRefs(spellCheckSelection));
 2896:     if (NS_SUCCEEDED(rv)) {
 2896:       spellCheckSelection->RemoveAllRanges();
 2896:     }
 2896:   }
 2896:   editor->SyncRealTimeSpell();
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
 2896: NS_IMETHODIMP
 2896: nsHTMLDocument::SetDesignMode(const nsAString & aDesignMode)
 2896: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
    1:     nsCOMPtr<nsIPrincipal> subject;
    1:     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
    1:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (subject) {
79445:       bool subsumes;
 3286:       rv = subject->Subsumes(NodePrincipal(), &subsumes);
    1:       NS_ENSURE_SUCCESS(rv, rv);
 3286: 
 3286:       NS_ENSURE_TRUE(subsumes, NS_ERROR_DOM_PROP_ACCESS_DENIED);
    1:     }
    1:   }
    1: 
79445:   bool editableMode = HasFlag(NODE_IS_EDITABLE);
 2896:   if (aDesignMode.LowerCaseEqualsASCII(editableMode ? "off" : "on")) {
 2896:     SetEditableFlag(!editableMode);
 2896: 
 2896:     return EditingStateChanged();
 2896:   }
 2896: 
 2896:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLDocument::GetMidasCommandManager(nsICommandManager** aCmdMgr)
    1: {
    1:   // initialize return value
    1:   NS_ENSURE_ARG_POINTER(aCmdMgr);
    1: 
    1:   // check if we have it cached
    1:   if (mMidasCommandManager) {
    1:     NS_ADDREF(*aCmdMgr = mMidasCommandManager);
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aCmdMgr = nsnull;
    1: 
    1:   nsPIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDocShell *docshell = window->GetDocShell();
    1:   if (!docshell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mMidasCommandManager = do_GetInterface(docshell);
    1:   if (!mMidasCommandManager)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   NS_ADDREF(*aCmdMgr = mMidasCommandManager);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: struct MidasCommand {
    1:   const char*  incomingCommandString;
    1:   const char*  internalCommandString;
    1:   const char*  internalParamString;
79445:   bool useNewParam;
79445:   bool convertToBoolean;
    1: };
    1: 
    1: static const struct MidasCommand gMidasCommandTable[] = {
80486:   { "bold",          "cmd_bold",            "", true,  false },
80486:   { "italic",        "cmd_italic",          "", true,  false },
80486:   { "underline",     "cmd_underline",       "", true,  false },
80486:   { "strikethrough", "cmd_strikethrough",   "", true,  false },
80486:   { "subscript",     "cmd_subscript",       "", true,  false },
80486:   { "superscript",   "cmd_superscript",     "", true,  false },
80486:   { "cut",           "cmd_cut",             "", true,  false },
80486:   { "copy",          "cmd_copy",            "", true,  false },
80486:   { "paste",         "cmd_paste",           "", true,  false },
80486:   { "delete",        "cmd_delete",          "", true,  false },
80486:   { "selectall",     "cmd_selectAll",       "", true,  false },
80486:   { "undo",          "cmd_undo",            "", true,  false },
80486:   { "redo",          "cmd_redo",            "", true,  false },
80486:   { "indent",        "cmd_indent",          "", true,  false },
80486:   { "outdent",       "cmd_outdent",         "", true,  false },
80486:   { "backcolor",     "cmd_backgroundColor", "", false, false },
80486:   { "forecolor",     "cmd_fontColor",       "", false, false },
80486:   { "hilitecolor",   "cmd_highlight",       "", false, false },
80486:   { "fontname",      "cmd_fontFace",        "", false, false },
80486:   { "fontsize",      "cmd_fontSize",        "", false, false },
80486:   { "increasefontsize", "cmd_increaseFont", "", false, false },
80486:   { "decreasefontsize", "cmd_decreaseFont", "", false, false },
80486:   { "inserthorizontalrule", "cmd_insertHR", "", true,  false },
80486:   { "createlink",    "cmd_insertLinkNoUI",  "", false, false },
80486:   { "insertimage",   "cmd_insertImageNoUI", "", false, false },
80486:   { "inserthtml",    "cmd_insertHTML",      "", false, false },
80486:   { "gethtml",       "cmd_getContents",     "", false, false },
80486:   { "justifyleft",   "cmd_align",       "left", true,  false },
80486:   { "justifyright",  "cmd_align",      "right", true,  false },
80486:   { "justifycenter", "cmd_align",     "center", true,  false },
80486:   { "justifyfull",   "cmd_align",    "justify", true,  false },
80486:   { "removeformat",  "cmd_removeStyles",    "", true,  false },
80486:   { "unlink",        "cmd_removeLinks",     "", true,  false },
80486:   { "insertorderedlist",   "cmd_ol",        "", true,  false },
80486:   { "insertunorderedlist", "cmd_ul",        "", true,  false },
80486:   { "insertparagraph", "cmd_paragraphState", "p", true, false },
80486:   { "formatblock",   "cmd_paragraphState",  "", false, false },
80486:   { "heading",       "cmd_paragraphState",  "", false, false },
80486:   { "styleWithCSS",  "cmd_setDocumentUseCSS", "", false, true },
80486:   { "contentReadOnly", "cmd_setDocumentReadOnly", "", false, true },
80486:   { "insertBrOnReturn", "cmd_insertBrOnReturn", "", false, true },
80486:   { "enableObjectResizing", "cmd_enableObjectResizing", "", false, true },
80486:   { "enableInlineTableEditing", "cmd_enableInlineTableEditing", "", false, true },
    1: #if 0
    1: // no editor support to remove alignments right now
80486:   { "justifynone",   "cmd_align",           "", true,  false },
    1: 
    1: // the following will need special review before being turned on
80486:   { "saveas",        "cmd_saveAs",          "", true,  false },
80486:   { "print",         "cmd_print",           "", true,  false },
    1: #endif
80486:   { NULL, NULL, NULL, false, false }
    1: };
    1: 
    1: #define MidasCommandCount ((sizeof(gMidasCommandTable) / sizeof(struct MidasCommand)) - 1)
    1: 
 8426: static const char* const gBlocks[] = {
 8426:   "ADDRESS",
 8426:   "BLOCKQUOTE",
 8426:   "DD",
 8426:   "DIV",
 8426:   "DL",
 8426:   "DT",
 8426:   "H1",
 8426:   "H2",
 8426:   "H3",
 8426:   "H4",
 8426:   "H5",
 8426:   "H6",
 8426:   "P",
 8426:   "PRE"
    1: };
    1: 
79445: static bool
10248: ConvertToMidasInternalCommandInner(const nsAString & inCommandID,
    1:                                    const nsAString & inParam,
    1:                                    nsACString& outCommandID,
    1:                                    nsACString& outParam,
79445:                                    bool& outIsBoolean,
79445:                                    bool& outBooleanValue,
79445:                                    bool aIgnoreParams)
    1: {
    1:   NS_ConvertUTF16toUTF8 convertedCommandID(inCommandID);
    1: 
    1:   // Hack to support old boolean commands that were backwards (see bug 301490).
79445:   bool invertBool = false;
    1:   if (convertedCommandID.LowerCaseEqualsLiteral("usecss")) {
    1:     convertedCommandID.Assign("styleWithCSS");
80486:     invertBool = true;
    1:   }
    1:   else if (convertedCommandID.LowerCaseEqualsLiteral("readonly")) {
    1:     convertedCommandID.Assign("contentReadOnly");
80486:     invertBool = true;
    1:   }
    1: 
    1:   PRUint32 i;
79445:   bool found = false;
    1:   for (i = 0; i < MidasCommandCount; ++i) {
    1:     if (convertedCommandID.Equals(gMidasCommandTable[i].incomingCommandString,
    1:                                   nsCaseInsensitiveCStringComparator())) {
80486:       found = true;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   if (found) {
    1:     // set outCommandID (what we use internally)
    1:     outCommandID.Assign(gMidasCommandTable[i].internalCommandString);
    1: 
    1:     // set outParam & outIsBoolean based on flags from the table
    1:     outIsBoolean = gMidasCommandTable[i].convertToBoolean;
    1: 
10248:     if (!aIgnoreParams) {
    1:       if (gMidasCommandTable[i].useNewParam) {
    1:         outParam.Assign(gMidasCommandTable[i].internalParamString);
    1:       }
    1:       else {
    1:         // handle checking of param passed in
    1:         if (outIsBoolean) {
    1:           // if this is a boolean value and it's not explicitly false
    1:           // (e.g. no value) we default to "true". For old backwards commands
    1:           // we invert the check (see bug 301490).
    1:           if (invertBool) {
    1:             outBooleanValue = inParam.LowerCaseEqualsLiteral("false");
    1:           }
    1:           else {
    1:             outBooleanValue = !inParam.LowerCaseEqualsLiteral("false");
    1:           }
    1:           outParam.Truncate();
    1:         }
    1:         else {
    1:           // check to see if we need to convert the parameter
 2896:           if (outCommandID.EqualsLiteral("cmd_paragraphState")) {
 8426:             const PRUnichar *start = inParam.BeginReading();
 8426:             const PRUnichar *end = inParam.EndReading();
 8426:             if (start != end && *start == '<' && *(end - 1) == '>') {
 8426:               ++start;
 8426:               --end;
 8426:             }
 8426: 
 8426:             NS_ConvertUTF16toUTF8 convertedParam(Substring(start, end));
    1:             PRUint32 j;
80467:             for (j = 0; j < ArrayLength(gBlocks); ++j) {
 8426:               if (convertedParam.Equals(gBlocks[j],
    1:                                         nsCaseInsensitiveCStringComparator())) {
 8426:                 outParam.Assign(gBlocks[j]);
    1:                 break;
    1:               }
    1:             }
    1: 
80467:             return j != ArrayLength(gBlocks);
 2896:           }
 2896:           else {
 8426:             CopyUTF16toUTF8(inParam, outParam);
    1:           }
    1:         }
 2896:       }
10248:     }
    1:   } // end else for useNewParam (do convert existing param)
    1:   else {
    1:     // reset results if the command is not found in our table
    1:     outCommandID.SetLength(0);
    1:     outParam.SetLength(0);
80486:     outIsBoolean = false;
    1:   }
    1: 
    1:   return found;
    1: }
    1: 
79445: static bool
10248: ConvertToMidasInternalCommand(const nsAString & inCommandID,
10248:                               const nsAString & inParam,
10248:                               nsACString& outCommandID,
10248:                               nsACString& outParam,
79445:                               bool& outIsBoolean,
79445:                               bool& outBooleanValue)
10248: {
10248:   return ConvertToMidasInternalCommandInner(inCommandID, inParam, outCommandID,
10248:                                             outParam, outIsBoolean,
80486:                                             outBooleanValue, false);
10248: }
10248: 
79445: static bool
10248: ConvertToMidasInternalCommand(const nsAString & inCommandID,
10248:                               nsACString& outCommandID)
10248: {
10248:   nsCAutoString dummyCString;
10248:   nsAutoString dummyString;
79445:   bool dummyBool;
10248:   return ConvertToMidasInternalCommandInner(inCommandID, dummyString,
10248:                                             outCommandID, dummyCString,
80486:                                             dummyBool, dummyBool, true);
10248: }
10248: 
48470: jsid
48470: nsHTMLDocument::sCutCopyInternal_id = JSID_VOID;
48470: jsid
48470: nsHTMLDocument::sPasteInternal_id = JSID_VOID;
    1: 
    1: /* Helper function to check security of clipboard commands. If aPaste is */
    1: /* true, we check paste, else we check cutcopy */
    1: nsresult
79445: nsHTMLDocument::DoClipboardSecurityCheck(bool aPaste)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
    1: 
    1:   if (stack) {
    1:     JSContext *cx = nsnull;
    1:     stack->Peek(&cx);
10022:     if (!cx) {
10022:       return NS_OK;
10022:     }
10022: 
10022:     JSAutoRequest ar(cx);
    1: 
    1:     NS_NAMED_LITERAL_CSTRING(classNameStr, "Clipboard");
    1: 
    1:     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
    1: 
    1:     if (aPaste) {
48470:       if (nsHTMLDocument::sPasteInternal_id == JSID_VOID) {
    1:         nsHTMLDocument::sPasteInternal_id =
70270:           INTERNED_STRING_TO_JSID(cx, ::JS_InternString(cx, "paste"));
    1:       }
    1:       rv = secMan->CheckPropertyAccess(cx, nsnull, classNameStr.get(),
    1:                                        nsHTMLDocument::sPasteInternal_id,
    1:                                        nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
    1:     } else {
48470:       if (nsHTMLDocument::sCutCopyInternal_id == JSID_VOID) {
    1:         nsHTMLDocument::sCutCopyInternal_id =
70270:           INTERNED_STRING_TO_JSID(cx, ::JS_InternString(cx, "cutcopy"));
    1:       }
    1:       rv = secMan->CheckPropertyAccess(cx, nsnull, classNameStr.get(),
    1:                                        nsHTMLDocument::sCutCopyInternal_id,
    1:                                        nsIXPCSecurityManager::ACCESS_GET_PROPERTY);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: /* TODO: don't let this call do anything if the page is not done loading */
    1: /* boolean execCommand(in DOMString commandID, in boolean doShowUI,
    1:                                                in DOMString value); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::ExecCommand(const nsAString & commandID,
79445:                             bool doShowUI,
    1:                             const nsAString & value,
79445:                             bool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1: 
    1:   //  for optional parameters see dom/src/base/nsHistory.cpp: HistoryImpl::Go()
    1:   //  this might add some ugly JS dependencies?
    1: 
80486:   *_retval = false;
    1: 
    1:   // if editing is not on, bail
21072:   if (!IsEditingOnAfterFlush())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // if they are requesting UI from us, let's fail since we have no UI
    1:   if (doShowUI)
 2896:     return NS_OK;
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (commandID.LowerCaseEqualsLiteral("gethtml"))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (commandID.LowerCaseEqualsLiteral("cut") ||
    1:       (commandID.LowerCaseEqualsLiteral("copy"))) {
80486:     rv = DoClipboardSecurityCheck(false);
    1:   } else if (commandID.LowerCaseEqualsLiteral("paste")) {
80486:     rv = DoClipboardSecurityCheck(true);
    1:   }
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramStr;
79445:   bool isBool, boolVal;
    1:   if (!ConvertToMidasInternalCommand(commandID, value,
    1:                                      cmdToDispatch, paramStr, isBool, boolVal))
 2896:     return NS_OK;
    1: 
    1:   if (!isBool && paramStr.IsEmpty()) {
    1:     rv = cmdMgr->DoCommand(cmdToDispatch.get(), nsnull, window);
    1:   } else {
    1:     // we have a command that requires a parameter, create params
    1:     nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
    1:                                             NS_COMMAND_PARAMS_CONTRACTID, &rv);
    1:     if (!cmdParams)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (isBool)
    1:       rv = cmdParams->SetBooleanValue("state_attribute", boolVal);
    1:     else if (cmdToDispatch.Equals("cmd_fontFace"))
    1:       rv = cmdParams->SetStringValue("state_attribute", value);
    1:     else if (cmdToDispatch.Equals("cmd_insertHTML"))
    1:       rv = cmdParams->SetStringValue("state_data", value);
    1:     else
    1:       rv = cmdParams->SetCStringValue("state_attribute", paramStr.get());
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1:     rv = cmdMgr->DoCommand(cmdToDispatch.get(), cmdParams, window);
    1:   }
    1: 
    1:   *_retval = NS_SUCCEEDED(rv);
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* TODO: don't let this call do anything if the page is not done loading */
    1: /* boolean execCommandShowHelp(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::ExecCommandShowHelp(const nsAString & commandID,
79445:                                     bool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
80486:   *_retval = false;
    1: 
    1:   // if editing is not on, bail
21072:   if (!IsEditingOnAfterFlush())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* boolean queryCommandEnabled(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandEnabled(const nsAString & commandID,
79445:                                     bool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
80486:   *_retval = false;
    1: 
    1:   // if editing is not on, bail
21072:   if (!IsEditingOnAfterFlush())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
76725:   nsCAutoString cmdToDispatch;
10248:   if (!ConvertToMidasInternalCommand(commandID, cmdToDispatch))
76725:     return NS_OK; // queryCommandEnabled returns false on unsupported commands
    1: 
    1:   return cmdMgr->IsCommandEnabled(cmdToDispatch.get(), window, _retval);
    1: }
    1: 
    1: /* boolean queryCommandIndeterm (in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandIndeterm(const nsAString & commandID,
79445:                                      bool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
80486:   *_retval = false;
    1: 
    1:   // if editing is not on, bail
21072:   if (!IsEditingOnAfterFlush())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramToCheck;
79445:   bool dummy;
    1:   if (!ConvertToMidasInternalCommand(commandID, commandID,
    1:                                      cmdToDispatch, paramToCheck, dummy, dummy))
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
    1:                                            NS_COMMAND_PARAMS_CONTRACTID, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = cmdMgr->GetCommandState(cmdToDispatch.get(), window, cmdParams);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // if command does not have a state_mixed value, this call fails, so we fail too,
    1:   // which is what is expected
    1:   rv = cmdParams->GetBooleanValue("state_mixed", _retval);
    1:   return rv;
    1: }
    1: 
    1: /* boolean queryCommandState(in DOMString commandID); */
    1: NS_IMETHODIMP
79445: nsHTMLDocument::QueryCommandState(const nsAString & commandID, bool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
80486:   *_retval = false;
    1: 
    1:   // if editing is not on, bail
21072:   if (!IsEditingOnAfterFlush())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramToCheck;
79445:   bool dummy, dummy2;
    1:   if (!ConvertToMidasInternalCommand(commandID, commandID,
    1:                                      cmdToDispatch, paramToCheck, dummy, dummy2))
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
    1:                                            NS_COMMAND_PARAMS_CONTRACTID, &rv);
    1:   if (!cmdParams)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   rv = cmdMgr->GetCommandState(cmdToDispatch.get(), window, cmdParams);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // handle alignment as a special case (possibly other commands too?)
    1:   // Alignment is special because the external api is individual
    1:   // commands but internally we use cmd_align with different
    1:   // parameters.  When getting the state of this command, we need to
    1:   // return the boolean for this particular alignment rather than the
    1:   // string of 'which alignment is this?'
    1:   if (cmdToDispatch.Equals("cmd_align")) {
    1:     char * actualAlignmentType = nsnull;
    1:     rv = cmdParams->GetCStringValue("state_attribute", &actualAlignmentType);
    1:     if (NS_SUCCEEDED(rv) && actualAlignmentType && actualAlignmentType[0]) {
    1:       *_retval = paramToCheck.Equals(actualAlignmentType);
    1:     }
    1:     if (actualAlignmentType)
    1:       nsMemory::Free(actualAlignmentType);
    1:   }
    1:   else {
    1:     rv = cmdParams->GetBooleanValue("state_all", _retval);
    1:     if (NS_FAILED(rv))
80486:       *_retval = false;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /* boolean queryCommandSupported(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandSupported(const nsAString & commandID,
79445:                                       bool *_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
80486:   *_retval = false;
    1: 
    1:   // if editing is not on, bail
21072:   if (!IsEditingOnAfterFlush())
    1:     return NS_ERROR_FAILURE;
    1: 
76725:   // get command manager
76725:   nsCOMPtr<nsICommandManager> cmdMgr;
76725:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
76725:   if (!cmdMgr)
76725:     return NS_ERROR_FAILURE;
76725: 
76725:   // commandID is supported if it can be converted to a Midas command
76725:   nsCAutoString cmdToDispatch;
76725:   if (ConvertToMidasInternalCommand(commandID, cmdToDispatch))
80486:     *_retval = true;
76725: 
76725:   return NS_OK;
    1: }
    1: 
    1: /* DOMString queryCommandText(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandText(const nsAString & commandID,
    1:                                  nsAString & _retval)
    1: {
    1:   _retval.SetLength(0);
    1: 
    1:   // if editing is not on, bail
21072:   if (!IsEditingOnAfterFlush())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* DOMString queryCommandValue(in DOMString commandID); */
    1: NS_IMETHODIMP
    1: nsHTMLDocument::QueryCommandValue(const nsAString & commandID,
    1:                                   nsAString &_retval)
    1: {
    1:   _retval.SetLength(0);
    1: 
    1:   // if editing is not on, bail
21072:   if (!IsEditingOnAfterFlush())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // get command manager and dispatch command to our window if it's acceptable
    1:   nsCOMPtr<nsICommandManager> cmdMgr;
    1:   GetMidasCommandManager(getter_AddRefs(cmdMgr));
    1:   if (!cmdMgr)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMWindow *window = GetWindow();
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString cmdToDispatch, paramStr;
10248:   if (!ConvertToMidasInternalCommand(commandID, cmdToDispatch))
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: 
    1:   // create params
    1:   nsresult rv;
    1:   nsCOMPtr<nsICommandParams> cmdParams = do_CreateInstance(
    1:                                            NS_COMMAND_PARAMS_CONTRACTID, &rv);
    1:   if (!cmdParams)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   // this is a special command since we are calling "DoCommand rather than
    1:   // GetCommandState like the other commands
    1:   if (cmdToDispatch.Equals("cmd_getContents"))
    1:   {
80486:     rv = cmdParams->SetBooleanValue("selection_only", true);
    1:     if (NS_FAILED(rv)) return rv;
    1:     rv = cmdParams->SetCStringValue("format", "text/html");
    1:     if (NS_FAILED(rv)) return rv;
    1:     rv = cmdMgr->DoCommand(cmdToDispatch.get(), cmdParams, window);
    1:     if (NS_FAILED(rv)) return rv;
    1:     return cmdParams->GetStringValue("result", _retval);
    1:   }
    1: 
    1:   rv = cmdParams->SetCStringValue("state_attribute", paramStr.get());
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = cmdMgr->GetCommandState(cmdToDispatch.get(), window, cmdParams);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsXPIDLCString cStringResult;
    1:   rv = cmdParams->GetCStringValue("state_attribute",
    1:                                   getter_Copies(cStringResult));
    1:   CopyUTF8toUTF16(cStringResult, _retval);
    1: 
    1:   return rv;
    1: }
    1: 
19384: nsresult
19384: nsHTMLDocument::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
19384: {
19384:   NS_ASSERTION(aNodeInfo->NodeInfoManager() == mNodeInfoManager,
19384:                "Can't import this document into another document!");
19384: 
19384:   nsRefPtr<nsHTMLDocument> clone = new nsHTMLDocument();
19384:   NS_ENSURE_TRUE(clone, NS_ERROR_OUT_OF_MEMORY);
19384:   nsresult rv = CloneDocHelper(clone.get());
19384:   NS_ENSURE_SUCCESS(rv, rv);
19384: 
19384:   // State from nsHTMLDocument
19384:   clone->mLoadFlags = mLoadFlags;
19384: 
19384:   return CallQueryInterface(clone.get(), aResult);
19384: }
21072: 
79445: bool
21072: nsHTMLDocument::IsEditingOnAfterFlush()
21072: {
21072:   nsIDocument* doc = GetParentDocument();
21072:   if (doc) {
21072:     // Make sure frames are up to date, since that can affect whether
21072:     // we're editable.
21072:     doc->FlushPendingNotifications(Flush_Frames);
21072:   }
21072: 
21072:   return IsEditingOn();
21072: }
25342: 
25342: void
25342: nsHTMLDocument::RemovedFromDocShell()
25342: {
25342:   mEditingState = eOff;
25342:   nsDocument::RemovedFromDocShell();
25342: }
91403: 
91403: /* virtual */ void
91403: nsHTMLDocument::DocSizeOfExcludingThis(nsWindowSizes* aWindowSizes) const
91403: {
91403:   nsDocument::DocSizeOfExcludingThis(aWindowSizes);
91403: 
91403:   // Measurement of the following members may be added later if DMD finds it is
91403:   // worthwhile:
91403:   // - mImages
91403:   // - mApplets
91403:   // - mEmbeds
91403:   // - mLinks
91403:   // - mAnchors
91403:   // - mScripts
91403:   // - mForms
91403:   // - mFormControls
91403:   // - mWyciwygChannel
91403:   // - mMidasCommandManager
91403: }
