68870: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
68870:  *
68870:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Chris Saari <saari@netscape.com>
    1:  *   Conrad Carlen <ccarlen@netscape.com>
    1:  *   Pierre Chanial <p_ch@verizon.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsContextMenuInfo.h"
    1: 
    1: #include "nsIImageLoadingContent.h"
    1: #include "imgILoader.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMHTMLHtmlElement.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLLinkElement.h"
68870: #include "nsIDOMDocumentView.h"
68870: #include "nsIDOMAbstractView.h"
68870: #include "nsIDOMViewCSS.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsIDOMCSSValue.h"
    1: #include "nsIDOMCSSPrimitiveValue.h"
    1: #include "nsNetUtil.h"
    1: #include "nsUnicharUtils.h"
42509: #include "nsIDocument.h"
42509: #include "nsIPrincipal.h"
42509: #include "nsIChannelPolicy.h"
42509: #include "nsIContentSecurityPolicy.h"
42509: #include "nsIContentPolicy.h"
    1: 
    1: //*****************************************************************************
    1: // class nsContextMenuInfo
    1: //*****************************************************************************
    1: 
    1: NS_IMPL_ISUPPORTS1(nsContextMenuInfo, nsIContextMenuInfo)
    1: 
    1: nsContextMenuInfo::nsContextMenuInfo()
    1: {
    1: }
    1: 
    1: nsContextMenuInfo::~nsContextMenuInfo()
    1: {
    1: }
    1: 
    1: /* readonly attribute nsIDOMEvent mouseEvent; */
    1: NS_IMETHODIMP
    1: nsContextMenuInfo::GetMouseEvent(nsIDOMEvent **aEvent)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEvent);
    1:   NS_IF_ADDREF(*aEvent = mMouseEvent);
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIDOMNode targetNode; */
    1: NS_IMETHODIMP
    1: nsContextMenuInfo::GetTargetNode(nsIDOMNode **aNode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNode);
    1:   NS_IF_ADDREF(*aNode = mDOMNode);
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute AString associatedLink; */
    1: NS_IMETHODIMP
    1: nsContextMenuInfo::GetAssociatedLink(nsAString& aHRef)
    1: {
    1:   NS_ENSURE_STATE(mAssociatedLink);
    1:   aHRef.Truncate(0);
    1:     
    1:   nsCOMPtr<nsIDOMElement> content(do_QueryInterface(mAssociatedLink));
    1:   nsAutoString localName;
    1:   if (content)
    1:     content->GetLocalName(localName);
    1: 
    1:   nsCOMPtr<nsIDOMElement> linkContent;
    1:   ToLowerCase(localName);
    1:   if (localName.EqualsLiteral("a") ||
    1:       localName.EqualsLiteral("area") ||
    1:       localName.EqualsLiteral("link")) {
    1:     PRBool hasAttr;
    1:     content->HasAttribute(NS_LITERAL_STRING("href"), &hasAttr);
    1:     if (hasAttr) {
    1:       linkContent = content;
    1:       nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(linkContent));
    1:       if (anchor)
    1:         anchor->GetHref(aHRef);
    1:       else {
    1:         nsCOMPtr<nsIDOMHTMLAreaElement> area(do_QueryInterface(linkContent));
    1:         if (area)
    1:           area->GetHref(aHRef);
    1:         else {
    1:           nsCOMPtr<nsIDOMHTMLLinkElement> link(do_QueryInterface(linkContent));
    1:           if (link)
    1:             link->GetHref(aHRef);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIDOMNode> curr;
    1:     mAssociatedLink->GetParentNode(getter_AddRefs(curr));
    1:     while (curr) {
    1:       content = do_QueryInterface(curr);
    1:       if (!content)
    1:         break;
    1:       content->GetLocalName(localName);
    1:       ToLowerCase(localName);
    1:       if (localName.EqualsLiteral("a")) {
    1:         PRBool hasAttr;
    1:         content->HasAttribute(NS_LITERAL_STRING("href"), &hasAttr);
    1:         if (hasAttr) {
    1:           linkContent = content;
    1:           nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(linkContent));
    1:           if (anchor)
    1:             anchor->GetHref(aHRef);
    1:         }
    1:         else
    1:           linkContent = nsnull; // Links can't be nested.
    1:         break;
    1:       }
    1: 
    1:       nsCOMPtr<nsIDOMNode> temp = curr;
    1:       temp->GetParentNode(getter_AddRefs(curr));
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* readonly attribute imgIContainer imageContainer; */
    1: NS_IMETHODIMP
    1: nsContextMenuInfo::GetImageContainer(imgIContainer **aImageContainer)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aImageContainer);
    1:   NS_ENSURE_STATE(mDOMNode);
    1:   
    1:   nsCOMPtr<imgIRequest> request;
    1:   GetImageRequest(mDOMNode, getter_AddRefs(request));
    1:   if (request)
    1:     return request->GetImage(aImageContainer);
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* readonly attribute nsIURI imageSrc; */
    1: NS_IMETHODIMP
    1: nsContextMenuInfo::GetImageSrc(nsIURI **aURI)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aURI);
    1:   NS_ENSURE_STATE(mDOMNode);
    1:   
    1:   nsCOMPtr<nsIImageLoadingContent> content(do_QueryInterface(mDOMNode));
    1:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
    1:   return content->GetCurrentURI(aURI);
    1: }
    1: 
    1: /* readonly attribute imgIContainer backgroundImageContainer; */
    1: NS_IMETHODIMP
    1: nsContextMenuInfo::GetBackgroundImageContainer(imgIContainer **aImageContainer)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aImageContainer);
    1:   NS_ENSURE_STATE(mDOMNode);
    1:   
    1:   nsCOMPtr<imgIRequest> request;
    1:   GetBackgroundImageRequest(mDOMNode, getter_AddRefs(request));
    1:   if (request)
    1:     return request->GetImage(aImageContainer);
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* readonly attribute nsIURI backgroundImageSrc; */
    1: NS_IMETHODIMP
    1: nsContextMenuInfo::GetBackgroundImageSrc(nsIURI **aURI)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aURI);
    1:   NS_ENSURE_STATE(mDOMNode);
    1:   
    1:   nsCOMPtr<imgIRequest> request;
    1:   GetBackgroundImageRequest(mDOMNode, getter_AddRefs(request));
    1:   if (request)
    1:     return request->GetURI(aURI);
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: //*****************************************************************************
    1: 
    1: nsresult
    1: nsContextMenuInfo::GetImageRequest(nsIDOMNode *aDOMNode, imgIRequest **aRequest)
    1: {
    1:   NS_ENSURE_ARG(aDOMNode);
    1:   NS_ENSURE_ARG_POINTER(aRequest);
    1: 
    1:   // Get content
    1:   nsCOMPtr<nsIImageLoadingContent> content(do_QueryInterface(aDOMNode));
    1:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
    1: 
    1:   return content->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                              aRequest);
    1: }
    1: 
    1: PRBool
    1: nsContextMenuInfo::HasBackgroundImage(nsIDOMNode * aDOMNode)
    1: {
 6895:   NS_ENSURE_TRUE(aDOMNode, PR_FALSE);
    1: 
    1:   nsCOMPtr<imgIRequest> request;
    1:   GetBackgroundImageRequest(aDOMNode, getter_AddRefs(request));
    1:   
    1:   return (request != nsnull);
    1: }
    1: 
    1: nsresult
    1: nsContextMenuInfo::GetBackgroundImageRequest(nsIDOMNode *aDOMNode, imgIRequest **aRequest)
    1: {
    1: 
    1:   NS_ENSURE_ARG(aDOMNode);
    1:   NS_ENSURE_ARG_POINTER(aRequest);
    1: 
    1:   nsCOMPtr<nsIDOMNode> domNode = aDOMNode;
    1: 
    1:   // special case for the <html> element: if it has no background-image
    1:   // we'll defer to <body>
    1:   nsCOMPtr<nsIDOMHTMLHtmlElement> htmlElement = do_QueryInterface(domNode);
    1:   if (htmlElement) {
    1:     nsAutoString nameSpace;
    1:     htmlElement->GetNamespaceURI(nameSpace);
    1:     if (nameSpace.IsEmpty()) {
    1:       nsresult rv = GetBackgroundImageRequestInternal(domNode, aRequest);
    1:       if (NS_SUCCEEDED(rv) && *aRequest)
    1:         return NS_OK;
    1: 
    1:       // no background-image found
    1:       nsCOMPtr<nsIDOMDocument> document;
    1:       domNode->GetOwnerDocument(getter_AddRefs(document));
    1:       nsCOMPtr<nsIDOMHTMLDocument> htmlDocument(do_QueryInterface(document));
    1:       NS_ENSURE_TRUE(htmlDocument, NS_ERROR_FAILURE);
    1: 
    1:       nsCOMPtr<nsIDOMHTMLElement> body;
    1:       htmlDocument->GetBody(getter_AddRefs(body));
    1:       domNode = do_QueryInterface(body);
    1:       NS_ENSURE_TRUE(domNode, NS_ERROR_FAILURE);
    1:     }
    1:   }
    1:   return GetBackgroundImageRequestInternal(domNode, aRequest);
    1: }
    1: 
    1: nsresult
    1: nsContextMenuInfo::GetBackgroundImageRequestInternal(nsIDOMNode *aDOMNode, imgIRequest **aRequest)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDOMNode);
    1: 
    1:   nsCOMPtr<nsIDOMNode> domNode = aDOMNode;
    1:   nsCOMPtr<nsIDOMNode> parentNode;
    1: 
    1:   nsCOMPtr<nsIDOMDocument> document;
    1:   domNode->GetOwnerDocument(getter_AddRefs(document));
68870:   nsCOMPtr<nsIDOMDocumentView> docView(do_QueryInterface(document));
68870:   NS_ENSURE_TRUE(docView, NS_ERROR_FAILURE);
    1: 
68870:   nsCOMPtr<nsIDOMAbstractView> defaultView;
68870:   docView->GetDefaultView(getter_AddRefs(defaultView));
68870:   nsCOMPtr<nsIDOMViewCSS> defaultCSSView(do_QueryInterface(defaultView));
68870:   NS_ENSURE_TRUE(defaultCSSView, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMCSSPrimitiveValue> primitiveValue;
    1:   nsAutoString bgStringValue;
    1: 
42509:   // get Content Security Policy to pass to LoadImage
42509:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(document));
42509:   nsCOMPtr<nsIPrincipal> principal;
42509:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
42509:   nsCOMPtr<nsIContentSecurityPolicy> csp;
42509:   if (doc) {
42509:     principal = doc->NodePrincipal();
42509:     nsresult rv = principal->GetCsp(getter_AddRefs(csp));
42509:     NS_ENSURE_SUCCESS(rv, rv);
42509:     if (csp) {
42509:       channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
42509:       channelPolicy->SetContentSecurityPolicy(csp);
42509:       channelPolicy->SetLoadType(nsIContentPolicy::TYPE_IMAGE);
42509:     }
42509:   }
42509:   
    1:   while (PR_TRUE) {
    1:     nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(domNode));
    1:     // bail for the parent node of the root element or null argument
    1:     if (!domElement)
    1:       break;
    1:     
    1:     nsCOMPtr<nsIDOMCSSStyleDeclaration> computedStyle;
68870:     defaultCSSView->GetComputedStyle(domElement, EmptyString(),
    1:                                      getter_AddRefs(computedStyle));
    1:     if (computedStyle) {
    1:       nsCOMPtr<nsIDOMCSSValue> cssValue;
    1:       computedStyle->GetPropertyCSSValue(NS_LITERAL_STRING("background-image"),
    1:                                          getter_AddRefs(cssValue));
    1:       primitiveValue = do_QueryInterface(cssValue);
    1:       if (primitiveValue) {
    1:         primitiveValue->GetStringValue(bgStringValue);
    1:         if (!bgStringValue.EqualsLiteral("none")) {
    1:           nsCOMPtr<nsIURI> bgUri;
    1:           NS_NewURI(getter_AddRefs(bgUri), bgStringValue);
    1:           NS_ENSURE_TRUE(bgUri, NS_ERROR_FAILURE);
    1: 
    1:           nsCOMPtr<imgILoader> il(do_GetService(
    1:                                     "@mozilla.org/image/loader;1"));
    1:           NS_ENSURE_TRUE(il, NS_ERROR_FAILURE);
    1: 
    1:           return il->LoadImage(bgUri, nsnull, nsnull, nsnull, nsnull, nsnull,
    1:                                nsIRequest::LOAD_NORMAL, nsnull, nsnull,
42509:                                channelPolicy, aRequest);
    1:         }
    1:       }
    1: 
    1:       // bail if we encounter non-transparent background-color
    1:       computedStyle->GetPropertyCSSValue(NS_LITERAL_STRING("background-color"),
    1:                                          getter_AddRefs(cssValue));
    1:       primitiveValue = do_QueryInterface(cssValue);
    1:       if (primitiveValue) {
    1:         primitiveValue->GetStringValue(bgStringValue);
    1:         if (!bgStringValue.EqualsLiteral("transparent"))
    1:           return NS_ERROR_FAILURE;
    1:       }
    1:     }
    1: 
    1:     domNode->GetParentNode(getter_AddRefs(parentNode));
    1:     domNode = parentNode;
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
