 99077: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 61084: #ifdef MOZ_LOGGING
 61084: #define FORCE_PR_LOG /* Allow logging in the release build */
 61084: #endif
104549: 
104549: #include "mozilla/layers/CompositorParent.h"
104622: #include "mozilla/layers/ImageBridgeChild.h"
104549: 
 61084: #include "prlog.h"
104549: #include "prenv.h"
 61084: 
     1: #include "gfxPlatform.h"
     1: 
104549: #include "nsXULAppAPI.h"
104549: 
     1: #if defined(XP_WIN)
     1: #include "gfxWindowsPlatform.h"
 72424: #include "gfxD2DSurface.h"
     1: #elif defined(XP_MACOSX)
     1: #include "gfxPlatformMac.h"
103113: #elif defined(MOZ_WIDGET_GTK)
     1: #include "gfxPlatformGtk.h"
 16758: #elif defined(MOZ_WIDGET_QT)
 16758: #include "gfxQtPlatform.h"
     1: #elif defined(XP_OS2)
     1: #include "gfxOS2Platform.h"
 42153: #elif defined(ANDROID)
 42153: #include "gfxAndroidPlatform.h"
     1: #endif
     1: 
 94515: #include "nsGkAtoms.h"
 31590: #include "gfxPlatformFontList.h"
     1: #include "gfxContext.h"
     1: #include "gfxImageSurface.h"
 19962: #include "gfxUserFontSet.h"
 90890: #include "nsUnicodeProperties.h"
 95828: #include "harfbuzz/hb.h"
 84392: #ifdef MOZ_GRAPHITE
 84392: #include "gfxGraphiteShaper.h"
 84392: #endif
     1: 
 37211: #include "nsUnicodeRange.h"
     1: #include "nsServiceManagerUtils.h"
 23904: #include "nsTArray.h"
 37211: #include "nsUnicharUtilCIID.h"
 37211: #include "nsILocaleService.h"
106543: #include "nsReadableUtils.h"
     1: 
 19003: #include "nsWeakReference.h"
 19003: 
     1: #include "cairo.h"
 27035: #include "qcms.h"
  3787: 
 11086: #include "plstr.h"
 36949: #include "nsCRT.h"
 47967: #include "GLContext.h"
 47967: #include "GLContextProvider.h"
     1: 
106178: #ifdef MOZ_WIDGET_ANDROID
106178: #include "TexturePoolOGL.h"
106178: #endif
106178: 
 41340: #include "mozilla/FunctionTimer.h"
 71640: #include "mozilla/Preferences.h"
 98557: #include "mozilla/Assertions.h"
101898: #include "mozilla/Attributes.h"
 41340: 
 51677: #include "nsIGfxInfo.h"
 51677: 
 71640: using namespace mozilla;
104549: using namespace mozilla::layers;
 71640: 
     1: gfxPlatform *gPlatform = nsnull;
 69151: static bool gEverInitialized = false;
106543: static nsTArray<nsCString>* gBackendList = nsnull;
 15987: 
 15987: // These two may point to the same profile
 27035: static qcms_profile *gCMSOutputProfile = nsnull;
 27035: static qcms_profile *gCMSsRGBProfile = nsnull;
 15987: 
 27035: static qcms_transform *gCMSRGBTransform = nsnull;
 27035: static qcms_transform *gCMSInverseRGBTransform = nsnull;
 27035: static qcms_transform *gCMSRGBATransform = nsnull;
     1: 
 79445: static bool gCMSInitialized = false;
 19003: static eCMSMode gCMSMode = eCMSMode_Off;
 19003: static int gCMSIntent = -2;
 19003: 
 19003: static void ShutdownCMS();
 16571: static void MigratePrefs();
 16571: 
 72424: #include "mozilla/gfx/2D.h"
 72424: using namespace mozilla::gfx;
 61084: 
 61084: // logs shared across gfx
 61084: #ifdef PR_LOGGING
 61084: static PRLogModuleInfo *sFontlistLog = nsnull;
 61084: static PRLogModuleInfo *sFontInitLog = nsnull;
 61084: static PRLogModuleInfo *sTextrunLog = nsnull;
 61084: static PRLogModuleInfo *sTextrunuiLog = nsnull;
 91869: static PRLogModuleInfo *sCmapDataLog = nsnull;
 61084: #endif
 61084: 
 19003: /* Class to listen for pref changes so that chrome code can dynamically
 19003:    force sRGB as an output profile. See Bug #452125. */
101898: class SRGBOverrideObserver MOZ_FINAL : public nsIObserver,
 19003:                                        public nsSupportsWeakReference
 19003: {
 19003: public:
 19003:     NS_DECL_ISUPPORTS
 19003:     NS_DECL_NSIOBSERVER
 19003: };
 19003: 
 19003: NS_IMPL_ISUPPORTS2(SRGBOverrideObserver, nsIObserver, nsISupportsWeakReference)
 19003: 
 19003: NS_IMETHODIMP
 19003: SRGBOverrideObserver::Observe(nsISupports *aSubject,
 19003:                               const char *aTopic,
 19003:                               const PRUnichar *someData)
 19003: {
 19003:     NS_ASSERTION(NS_strcmp(someData,
 19003:                    NS_LITERAL_STRING("gfx.color_mangement.force_srgb").get()),
 19003:                  "Restarting CMS on wrong pref!");
 19003:     ShutdownCMS();
 19003:     return NS_OK;
 19003: }
 19003: 
 42854: #define GFX_DOWNLOADABLE_FONTS_ENABLED "gfx.downloadable_fonts.enabled"
 55084: #define GFX_DOWNLOADABLE_FONTS_SANITIZE "gfx.downloadable_fonts.sanitize"
 42854: 
 67838: #define GFX_PREF_HARFBUZZ_SCRIPTS "gfx.font_rendering.harfbuzz.scripts"
 90890: #define HARFBUZZ_SCRIPTS_DEFAULT  mozilla::unicode::SHAPING_DEFAULT
 91872: #define GFX_PREF_FALLBACK_USE_CMAPS  "gfx.font_rendering.fallback.always_use_cmaps"
 43527: 
 84392: #ifdef MOZ_GRAPHITE
 84392: #define GFX_PREF_GRAPHITE_SHAPING "gfx.font_rendering.graphite.enabled"
 84392: #endif
 84392: 
 86691: #define BIDI_NUMERAL_PREF "bidi.numeral"
 86691: 
 71640: static const char* kObservedPrefs[] = {
 71640:     "gfx.downloadable_fonts.",
 71640:     "gfx.font_rendering.",
 86691:     "bidi.numeral",
 71640:     nsnull
 71640: };
 71640: 
101898: class FontPrefsObserver MOZ_FINAL : public nsIObserver
 42854: {
 42854: public:
 42854:     NS_DECL_ISUPPORTS
 42854:     NS_DECL_NSIOBSERVER
 42854: };
 42854: 
 42854: NS_IMPL_ISUPPORTS1(FontPrefsObserver, nsIObserver)
 42854: 
 42854: NS_IMETHODIMP
 42854: FontPrefsObserver::Observe(nsISupports *aSubject,
 42854:                            const char *aTopic,
 42854:                            const PRUnichar *someData)
 42854: {
 71640:     if (!someData) {
 42854:         NS_ERROR("font pref observer code broken");
 42854:         return NS_ERROR_UNEXPECTED;
 42854:     }
 71640:     NS_ASSERTION(gfxPlatform::GetPlatform(), "the singleton instance has gone");
 71640:     gfxPlatform::GetPlatform()->FontsPrefsChanged(NS_ConvertUTF16toUTF8(someData).get());
 42854: 
 42854:     return NS_OK;
 42854: }
 42854: 
 42854: 
 19003: 
 11086: // this needs to match the list of pref font.default.xx entries listed in all.js!
 11086: // the order *must* match the order in eFontPrefLang
 11086: static const char *gPrefLangNames[] = {
 11086:     "x-western",
 11086:     "x-central-euro",
 11086:     "ja",
 11086:     "zh-TW",
 11086:     "zh-CN",
 11086:     "zh-HK",
 11086:     "ko",
 11086:     "x-cyrillic",
 11086:     "x-baltic",
 11086:     "el",
 11086:     "tr",
 11086:     "th",
 11086:     "he",
 11086:     "ar",
 11086:     "x-devanagari",
 11086:     "x-tamil",
 11086:     "x-armn",
 11086:     "x-beng",
 11086:     "x-cans",
 11086:     "x-ethi",
 11086:     "x-geor",
 11086:     "x-gujr",
 11086:     "x-guru",
 11086:     "x-khmr",
 11086:     "x-mlym",
 13885:     "x-orya",
 13885:     "x-telu",
 13885:     "x-knda",
 13885:     "x-sinh",
 38930:     "x-tibt",
 11086:     "x-unicode",
 11086:     "x-user-def"
 11086: };
 11086: 
 42854: gfxPlatform::gfxPlatform()
106546:   : mAzureCanvasBackendCollector(this, &gfxPlatform::GetAzureCanvasBackendInfo)
 42854: {
 67838:     mUseHarfBuzzScripts = UNINITIALIZED_VALUE;
 42854:     mAllowDownloadableFonts = UNINITIALIZED_VALUE;
 55084:     mDownloadableFontsSanitize = UNINITIALIZED_VALUE;
 91872:     mFallbackUsesCmaps = UNINITIALIZED_VALUE;
 91872: 
 84392: #ifdef MOZ_GRAPHITE
 84392:     mGraphiteShapingEnabled = UNINITIALIZED_VALUE;
 84392: #endif
 86691:     mBidiNumeralOption = UNINITIALIZED_VALUE;
 88510: 
106543:     PRUint32 backendMask = (1 << BACKEND_CAIRO) | (1 << BACKEND_SKIA);
106543:     InitCanvasBackend(backendMask);
 42854: }
 11086: 
     1: gfxPlatform*
     1: gfxPlatform::GetPlatform()
     1: {
 69151:     if (!gPlatform) {
 69151:         Init();
 69151:     }
   218:     return gPlatform;
   218: }
   218: 
 68853: void
   218: gfxPlatform::Init()
   218: {
 69151:     if (gEverInitialized) {
 69151:         NS_RUNTIMEABORT("Already started???");
 69151:     }
 69151:     gEverInitialized = true;
 38493: 
 61084: #ifdef PR_LOGGING
 61084:     sFontlistLog = PR_NewLogModule("fontlist");;
 61084:     sFontInitLog = PR_NewLogModule("fontinit");;
 61084:     sTextrunLog = PR_NewLogModule("textrun");;
 61084:     sTextrunuiLog = PR_NewLogModule("textrunui");;
 91869:     sCmapDataLog = PR_NewLogModule("cmapdata");;
 61084: #endif
 61084: 
104549:     bool useOffMainThreadCompositing = false;
104549: #ifdef MOZ_X11
104549:     // On X11 platforms only use OMTC if firefox was initalized with thread-safe 
104549:     // X11 (else it would crash).
104549:     useOffMainThreadCompositing = (PR_GetEnv("MOZ_USE_OMTC") != NULL);
104549: #else
104549:     useOffMainThreadCompositing = Preferences::GetBool(
104549:           "layers.offmainthreadcomposition.enabled", 
104549:           false);
104549: #endif
104549: 
104549:     if (useOffMainThreadCompositing && (XRE_GetProcessType() == 
104549:                                         GeckoProcessType_Default)) {
104549:         CompositorParent::StartUp();
104622:         if (Preferences::GetBool("layers.async-video.enabled",false)) {
104622:             ImageBridgeChild::StartUp();
104622:         }
104622: 
104549:     }
 61084: 
 51677:     /* Initialize the GfxInfo service.
 51677:      * Note: we can't call functions on GfxInfo that depend
 51677:      * on gPlatform until after it has been initialized
 51677:      * below. GfxInfo initialization annotates our
 51677:      * crash reports so we want to do it before
 51677:      * we try to load any drivers and do device detection
 51677:      * incase that code crashes. See bug #591561. */
 51677:     nsCOMPtr<nsIGfxInfo> gfxInfo;
 51677:     /* this currently will only succeed on Windows */
 51677:     gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
 51677: 
     1: #if defined(XP_WIN)
     1:     gPlatform = new gfxWindowsPlatform;
     1: #elif defined(XP_MACOSX)
     1:     gPlatform = new gfxPlatformMac;
103113: #elif defined(MOZ_WIDGET_GTK)
     1:     gPlatform = new gfxPlatformGtk;
 16758: #elif defined(MOZ_WIDGET_QT)
 16758:     gPlatform = new gfxQtPlatform;
     1: #elif defined(XP_OS2)
     1:     gPlatform = new gfxOS2Platform;
 42153: #elif defined(ANDROID)
 42153:     gPlatform = new gfxAndroidPlatform;
 68665: #else
 68665:     #error "No gfxPlatform implementation available"
     1: #endif
   218: 
 98361: #ifdef DEBUG
 98361:     mozilla::gl::GLContext::StaticInit();
 98361: #endif
 98361: 
   218:     nsresult rv;
   218: 
 48022: #if defined(XP_MACOSX) || defined(XP_WIN) || defined(ANDROID) // temporary, until this is implemented on others
 31590:     rv = gfxPlatformFontList::Init();
   218:     if (NS_FAILED(rv)) {
 68853:         NS_RUNTIMEABORT("Could not initialize gfxPlatformFontList");
   218:     }
   218: #endif
   218: 
 57104:     gPlatform->mScreenReferenceSurface =
 57104:         gPlatform->CreateOffscreenSurface(gfxIntSize(1,1),
 57104:                                           gfxASurface::CONTENT_COLOR_ALPHA);
 57104:     if (!gPlatform->mScreenReferenceSurface) {
 68853:         NS_RUNTIMEABORT("Could not initialize mScreenReferenceSurface");
 57104:     }
 57104: 
   323:     rv = gfxFontCache::Init();
   323:     if (NS_FAILED(rv)) {
 68853:         NS_RUNTIMEABORT("Could not initialize gfxFontCache");
   323:     }
   323: 
 16571:     /* Pref migration hook. */
 16571:     MigratePrefs();
 16571: 
 19003:     /* Create and register our CMS Override observer. */
 71640:     gPlatform->mSRGBOverrideObserver = new SRGBOverrideObserver();
 74461:     Preferences::AddWeakObserver(gPlatform->mSRGBOverrideObserver, "gfx.color_management.force_srgb");
 42854: 
 71640:     gPlatform->mFontPrefsObserver = new FontPrefsObserver();
 71640:     Preferences::AddStrongObservers(gPlatform->mFontPrefsObserver, kObservedPrefs);
 69151: 
 95058:     gPlatform->mWorkAroundDriverBugs = Preferences::GetBool("gfx.work-around-driver-bugs", true);
 95058: 
106178: #ifdef MOZ_WIDGET_ANDROID
106178:     // Texture pool init
106178:     mozilla::gl::TexturePoolOGL::Init();
106178: #endif
106178: 
 69151:     // Force registration of the gfx component, thus arranging for
 69151:     // ::Shutdown to be called.
 69151:     nsCOMPtr<nsISupports> forceReg
 69151:         = do_CreateInstance("@mozilla.org/gfx/init;1");
     1: }
     1: 
     1: void
     1: gfxPlatform::Shutdown()
     1: {
   218:     // These may be called before the corresponding subsystems have actually
   218:     // started up. That's OK, they can handle it.
   323:     gfxFontCache::Shutdown();
 38492:     gfxFontGroup::Shutdown();
 84392: #ifdef MOZ_GRAPHITE
 84392:     gfxGraphiteShaper::Shutdown();
 84392: #endif
 36949: #if defined(XP_MACOSX) || defined(XP_WIN) // temporary, until this is implemented on others
 31590:     gfxPlatformFontList::Shutdown();
   218: #endif
 15987: 
 15987:     // Free the various non-null transforms and loaded profiles
 19003:     ShutdownCMS();
 15987: 
 71640:     // In some cases, gPlatform may not be created but Shutdown() called,
 71640:     // e.g., during xpcshell tests.
 71640:     if (gPlatform) {
 19003:         /* Unregister our CMS Override callback. */
 71640:         NS_ASSERTION(gPlatform->mSRGBOverrideObserver, "mSRGBOverrideObserver has alreay gone");
 74461:         Preferences::RemoveObserver(gPlatform->mSRGBOverrideObserver, "gfx.color_management.force_srgb");
 71640:         gPlatform->mSRGBOverrideObserver = nsnull;
 71640: 
 71640:         NS_ASSERTION(gPlatform->mFontPrefsObserver, "mFontPrefsObserver has alreay gone");
 71640:         Preferences::RemoveObservers(gPlatform->mFontPrefsObserver, kObservedPrefs);
 71640:         gPlatform->mFontPrefsObserver = nsnull;
 71640:     }
 15987: 
106178: #ifdef MOZ_WIDGET_ANDROID
106178:     // Shut down the texture pool
106178:     mozilla::gl::TexturePoolOGL::Shutdown();
106178: #endif
106178: 
 89809:     // Shut down the default GL context provider.
 47967:     mozilla::gl::GLContextProvider::Shutdown();
 89809: 
 89809:     // We always have OSMesa at least potentially available; shut it down too.
 89557:     mozilla::gl::GLContextProviderOSMesa::Shutdown();
 89557: 
 89557: #if defined(XP_WIN)
 89809:     // The above shutdown calls operate on the available context providers on
 89809:     // most platforms.  Windows is a "special snowflake", though, and has three
 89809:     // context providers available, so we have to shut all of them down.
 89809:     // We should only support the default GL provider on Windows; then, this
 89809:     // could go away. Unfortunately, we currently support WGL (the default) for
 89809:     // WebGL on Optimus.
 89557:     mozilla::gl::GLContextProviderEGL::Shutdown();
 89557: #endif
 47967: 
104622:     // This will block this thread untill the ImageBridge protocol is completely
104622:     // deleted.
104622:     ImageBridgeChild::ShutDown();
104622: 
104549:     CompositorParent::ShutDown();
104549: 
106543:     delete gBackendList;
106543:     gBackendList = nsnull;
106543: 
     1:     delete gPlatform;
     1:     gPlatform = nsnull;
     1: }
     1: 
     1: gfxPlatform::~gfxPlatform()
     1: {
 99224:     mScreenReferenceSurface = nsnull;
 99224: 
     1:     // The cairo folks think we should only clean up in debug builds,
     1:     // but we're generally in the habit of trying to shut down as
     1:     // cleanly as possible even in production code, so call this
     1:     // cairo_debug_* function unconditionally.
  7193:     //
  7193:     // because cairo can assert and thus crash on shutdown, don't do this in release builds
 11579: #if MOZ_TREE_CAIRO && (defined(DEBUG) || defined(NS_BUILD_REFCNT_LOGGING) || defined(NS_TRACE_MALLOC))
     1:     cairo_debug_reset_static_data();
  7193: #endif
  6695: 
  6695: #if 0
  6695:     // It would be nice to do this (although it might need to be after
  6695:     // the cairo shutdown that happens in ~gfxPlatform).  It even looks
  6695:     // idempotent.  But it has fatal assertions that fire if stuff is
  6695:     // leaked, and we hit them.
  6695:     FcFini();
  6695: #endif
     1: }
     1: 
     1: already_AddRefed<gfxASurface>
102921: gfxPlatform::CreateOffscreenImageSurface(const gfxIntSize& aSize,
102921:                                          gfxASurface::gfxContentType aContentType)
102921: { 
102921:   nsRefPtr<gfxASurface> newSurface;
102921:   newSurface = new gfxImageSurface(aSize, OptimalFormatForContent(aContentType));
102921: 
102921:   return newSurface.forget();
102921: }
102921: 
102921: already_AddRefed<gfxASurface>
  8368: gfxPlatform::OptimizeImage(gfxImageSurface *aSurface,
  8368:                            gfxASurface::gfxImageFormat format)
     1: {
     1:     const gfxIntSize& surfaceSize = aSurface->GetSize();
     1: 
 38727: #ifdef XP_WIN
 38727:     if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() == 
 38727:         gfxWindowsPlatform::RENDER_DIRECT2D) {
 38727:         return nsnull;
 38727:     }
 38727: #endif
 54253:     nsRefPtr<gfxASurface> optSurface = CreateOffscreenSurface(surfaceSize, gfxASurface::ContentFromFormat(format));
  8368:     if (!optSurface || optSurface->CairoStatus() != 0)
     1:         return nsnull;
     1: 
  9751:     gfxContext tmpCtx(optSurface);
  9751:     tmpCtx.SetOperator(gfxContext::OPERATOR_SOURCE);
  9751:     tmpCtx.SetSource(aSurface);
  9751:     tmpCtx.Paint();
     1: 
     1:     gfxASurface *ret = optSurface;
     1:     NS_ADDREF(ret);
     1:     return ret;
     1: }
     1: 
 72424: cairo_user_data_key_t kDrawTarget;
 72424: 
 72424: RefPtr<DrawTarget>
106527: gfxPlatform::CreateDrawTargetForSurface(gfxASurface *aSurface, const IntSize& aSize)
 72424: {
106527:   RefPtr<DrawTarget> drawTarget = Factory::CreateDrawTargetForCairoSurface(aSurface->CairoSurface(), aSize);
 72424:   aSurface->SetData(&kDrawTarget, drawTarget, NULL);
 72424:   return drawTarget;
 72424: }
 72424: 
 72424: cairo_user_data_key_t kSourceSurface;
 72424: 
 72424: void SourceBufferDestroy(void *srcBuffer)
 72424: {
 72424:   static_cast<SourceSurface*>(srcBuffer)->Release();
 72424: }
 72424: 
 88623: void SourceSnapshotDetached(cairo_surface_t *nullSurf)
 88623: {
 88623:   gfxImageSurface* origSurf =
 88623:     static_cast<gfxImageSurface*>(cairo_surface_get_user_data(nullSurf, &kSourceSurface));
 88623: 
 88623:   origSurf->SetData(&kSourceSurface, NULL, NULL);
 88623: }
 88623: 
 72424: RefPtr<SourceSurface>
 72424: gfxPlatform::GetSourceSurfaceForSurface(DrawTarget *aTarget, gfxASurface *aSurface)
 72424: {
 72424:   void *userData = aSurface->GetData(&kSourceSurface);
 72424: 
 72424:   if (userData) {
 72424:     return static_cast<SourceSurface*>(userData);
 72424:   }
 72424: 
 72424:   SurfaceFormat format;
 72424:   if (aSurface->GetContentType() == gfxASurface::CONTENT_ALPHA) {
 72424:     format = FORMAT_A8;
 72424:   } else if (aSurface->GetContentType() == gfxASurface::CONTENT_COLOR) {
 72424:     format = FORMAT_B8G8R8X8;
 72424:   } else {
 72424:     format = FORMAT_B8G8R8A8;
 72424:   }
 72424: 
 72424:   RefPtr<SourceSurface> srcBuffer;
 72424: 
 72424: #ifdef XP_WIN
 72424:   if (aSurface->GetType() == gfxASurface::SurfaceTypeD2D) {
 72424:     NativeSurface surf;
 72424:     surf.mFormat = format;
 72424:     surf.mType = NATIVE_SURFACE_D3D10_TEXTURE;
 72424:     surf.mSurface = static_cast<gfxD2DSurface*>(aSurface)->GetTexture();
 72424:     mozilla::gfx::DrawTarget *dt = static_cast<mozilla::gfx::DrawTarget*>(aSurface->GetData(&kDrawTarget));
 72424:     if (dt) {
 72424:       dt->Flush();
 72424:     }
 72424:     srcBuffer = aTarget->CreateSourceSurfaceFromNativeSurface(surf);
 72424:   }
 72424: #endif
 72424: 
 72424:   if (!srcBuffer) {
 72424:     nsRefPtr<gfxImageSurface> imgSurface = aSurface->GetAsImageSurface();
 72424: 
106533:     bool isWin32ImageSurf = imgSurface &&
106533:                             aSurface->GetType() == gfxASurface::SurfaceTypeWin32;
 99077: 
 72424:     if (!imgSurface) {
 99511:       imgSurface = new gfxImageSurface(aSurface->GetSize(), OptimalFormatForContent(aSurface->GetContentType()));
 72424:       nsRefPtr<gfxContext> ctx = new gfxContext(imgSurface);
 72424:       ctx->SetSource(aSurface);
 72424:       ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
 72424:       ctx->Paint();
 72424:     }
 72424: 
 81281:     gfxImageFormat cairoFormat = imgSurface->Format();
 81281:     switch(cairoFormat) {
 81281:       case gfxASurface::ImageFormatARGB32:
 81281:         format = FORMAT_B8G8R8A8;
 81281:         break;
 81281:       case gfxASurface::ImageFormatRGB24:
 81281:         format = FORMAT_B8G8R8X8;
 81281:         break;
 81281:       case gfxASurface::ImageFormatA8:
 81281:         format = FORMAT_A8;
 81281:         break;
 81281:       case gfxASurface::ImageFormatRGB16_565:
 81281:         format = FORMAT_R5G6B5;
 81281:         break;
 81281:       default:
 81281:         NS_RUNTIMEABORT("Invalid surface format!");
 81281:     }
 81281: 
 99077:     IntSize size = IntSize(imgSurface->GetSize().width, imgSurface->GetSize().height);
 72424:     srcBuffer = aTarget->CreateSourceSurfaceFromData(imgSurface->Data(),
 99077:                                                      size,
 72424:                                                      imgSurface->Stride(),
 72424:                                                      format);
 88623: 
 99077:     if (!srcBuffer) {
 99077:       // We need to check if our gfxASurface will keep the underlying data
106533:       // alive. This is true if gfxASurface actually -is- an ImageSurface or
106533:       // if it is a gfxWindowsSurface which supports GetAsImageSurface.
 99077:       if (imgSurface != aSurface && !isWin32ImageSurf) {
 99077:         // This shouldn't happen for now, it can be easily supported by making
 99077:         // a copy. For now let's just abort.
 99077:         NS_RUNTIMEABORT("Attempt to create unsupported SourceSurface from"
 99077:             "non-image surface.");
 99077:         return nsnull;
 99077:       }
 99077: 
 99077:       srcBuffer = Factory::CreateWrappingDataSourceSurface(imgSurface->Data(),
 99077:                                                            imgSurface->Stride(),
 99077:                                                            size, format);
 99077: 
 99077:     }
 99077: 
 88623:     cairo_surface_t *nullSurf =
 88623: 	cairo_null_surface_create(CAIRO_CONTENT_COLOR_ALPHA);
 88623:     cairo_surface_set_user_data(nullSurf,
 88623:                                 &kSourceSurface,
 88623:                                 imgSurface,
 88623:                                 NULL);
 88623:     cairo_surface_attach_snapshot(imgSurface->CairoSurface(), nullSurf, SourceSnapshotDetached);
 88623:     cairo_surface_destroy(nullSurf);
 72424:   }
 72424: 
 72424:   srcBuffer->AddRef();
 72424:   aSurface->SetData(&kSourceSurface, srcBuffer, SourceBufferDestroy);
 72424: 
 72424:   return srcBuffer;
 72424: }
 72424: 
 72424: RefPtr<ScaledFont>
106525: gfxPlatform::GetScaledFontForFont(DrawTarget* aTarget, gfxFont *aFont)
 72424: {
 87057:   NativeFont nativeFont;
 87057:   nativeFont.mType = NATIVE_FONT_CAIRO_FONT_FACE;
106536:   nativeFont.mFont = aFont->GetCairoScaledFont();
 87057:   RefPtr<ScaledFont> scaledFont =
 87057:     Factory::CreateScaledFontForNativeFont(nativeFont,
 87057:                                            aFont->GetAdjustedSize());
 87057:   return scaledFont;
 72424: }
 72424: 
106547: cairo_user_data_key_t kDrawSourceSurface;
106547: static void
106547: DataSourceSurfaceDestroy(void *dataSourceSurface)
 87515: {
106547:   static_cast<DataSourceSurface*>(dataSourceSurface)->Release();
106547: }
106547: 
106547: cairo_user_data_key_t kDrawTargetForSurface;
106547: static void
106547: DataDrawTargetDestroy(void *aTarget)
106547: {
106547:   static_cast<DrawTarget*>(aTarget)->Release();
 87515: }
 87515: 
 72424: already_AddRefed<gfxASurface>
 72424: gfxPlatform::GetThebesSurfaceForDrawTarget(DrawTarget *aTarget)
 72424: {
 88429:   if (aTarget->GetType() == BACKEND_CAIRO) {
 88429:     cairo_surface_t* csurf =
 88429:       static_cast<cairo_surface_t*>(aTarget->GetNativeSurface(NATIVE_SURFACE_CAIRO_SURFACE));
106547:     return gfxASurface::Wrap(csurf);
106547:   }
106547: 
 88429:   // The semantics of this part of the function are sort of weird. If we
 88429:   // don't have direct support for the backend, we snapshot the first time
 88429:   // and then return the snapshotted surface for the lifetime of the draw
 88429:   // target. Sometimes it seems like this works out, but it seems like it
 88429:   // might result in no updates ever.
 81280:   RefPtr<SourceSurface> source = aTarget->Snapshot();
 81280:   RefPtr<DataSourceSurface> data = source->GetDataSurface();
 81280: 
 81280:   if (!data) {
 81280:     return NULL;
 81280:   }
 81280: 
 81280:   IntSize size = data->GetSize();
 99511:   gfxASurface::gfxImageFormat format = OptimalFormatForContent(ContentForFormat(data->GetFormat()));
 81280: 
 82405: 
106547:   nsRefPtr<gfxASurface> surf =
106547:     new gfxImageSurface(data->GetData(), gfxIntSize(size.width, size.height),
106547:                         data->Stride(), format);
 87515: 
106547:   surf->SetData(&kDrawSourceSurface, data.forget().drop(), DataSourceSurfaceDestroy);
106547:   // keep the draw target alive as long as we need its data
106547:   aTarget->AddRef();
106547:   surf->SetData(&kDrawTargetForSurface, aTarget, DataDrawTargetDestroy);
 87515: 
 87515:   return surf.forget();
 81280: }
 81280: 
 81280: RefPtr<DrawTarget>
106543: gfxPlatform::CreateDrawTargetForBackend(BackendType aBackend, const IntSize& aSize, SurfaceFormat aFormat)
 81280: {
 82417:   BackendType backend;
106546:   if (!SupportsAzureCanvas(backend)) {
 72424:     return NULL;
 72424:   }
 88429: 
 88429:   // There is a bunch of knowledge in the gfxPlatform heirarchy about how to
 88429:   // create the best offscreen surface for the current system and situation. We
 88429:   // can easily take advantage of this for the Cairo backend, so that's what we
 88429:   // do.
 88429:   // mozilla::gfx::Factory can get away without having all this knowledge for
 88429:   // now, but this might need to change in the future (using
 88429:   // CreateOffscreenSurface() and CreateDrawTargetForSurface() for all
 88429:   // backends).
106543:   if (aBackend == BACKEND_CAIRO) {
 88429:     nsRefPtr<gfxASurface> surf = CreateOffscreenSurface(ThebesIntSize(aSize),
 88429:                                                         ContentForFormat(aFormat));
106534:     if (!surf) {
106534:       return NULL;
106534:     }
 88429: 
106527:     return CreateDrawTargetForSurface(surf, aSize);
 88429:   } else {
106543:     return Factory::CreateDrawTarget(aBackend, aSize, aFormat);
 82417:   }
 88429: }
 72424: 
 94602: RefPtr<DrawTarget>
106543: gfxPlatform::CreateOffscreenDrawTarget(const IntSize& aSize, SurfaceFormat aFormat)
106543: {
106543:   BackendType backend;
106546:   if (!SupportsAzureCanvas(backend)) {
106543:     return NULL;
106543:   }
106543: 
106543:   RefPtr<DrawTarget> target = CreateDrawTargetForBackend(backend, aSize, aFormat);
106543:   if (target ||
106543:       mFallbackCanvasBackend == BACKEND_NONE) {
106543:     return target;
106543:   }
106543: 
106543:   return CreateDrawTargetForBackend(mFallbackCanvasBackend, aSize, aFormat);
106543: }
106543: 
106543: 
106543: RefPtr<DrawTarget>
 94602: gfxPlatform::CreateDrawTargetForData(unsigned char* aData, const IntSize& aSize, int32_t aStride, SurfaceFormat aFormat)
 94602: {
 94602:   BackendType backend;
106546:   if (!SupportsAzureCanvas(backend)) {
 94602:     return NULL;
 94602:   }
 94602:   return Factory::CreateDrawTargetForData(backend, aData, aSize, aStride, aFormat); 
 94602: }
 94602: 
106543: bool
106546: gfxPlatform::SupportsAzureCanvas(BackendType& aBackend)
106543: {
106546:   NS_ASSERTION(mFallbackCanvasBackend == BACKEND_NONE || mPreferredCanvasBackend != BACKEND_NONE,
106546:                "fallback backend with no preferred backend");
106543:   aBackend = mPreferredCanvasBackend;
106546:   return mPreferredCanvasBackend != BACKEND_NONE;
106543: }
106543: 
106543: /* static */ BackendType
106543: gfxPlatform::BackendTypeForName(const nsCString& aName)
106543: {
106543:   if (aName.EqualsLiteral("cairo"))
106543:     return BACKEND_CAIRO;
106543:   if (aName.EqualsLiteral("skia"))
106543:     return BACKEND_SKIA;
106543:   if (aName.EqualsLiteral("direct2d"))
106543:     return BACKEND_DIRECT2D;
106543:   if (aName.EqualsLiteral("cg"))
106543:     return BACKEND_COREGRAPHICS;
106543:   return BACKEND_NONE;
106543: }
106543: 
     1: nsresult
 38493: gfxPlatform::GetFontList(nsIAtom *aLangGroup,
     1:                          const nsACString& aGenericFamily,
 23904:                          nsTArray<nsString>& aListOfFonts)
     1: {
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: nsresult
     1: gfxPlatform::UpdateFontList()
     1: {
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
 79445: bool
 19962: gfxPlatform::DownloadableFontsEnabled()
 19962: {
 42854:     if (mAllowDownloadableFonts == UNINITIALIZED_VALUE) {
 55084:         mAllowDownloadableFonts =
 79445:             Preferences::GetBool(GFX_DOWNLOADABLE_FONTS_ENABLED, false);
 19962:     }
 19962: 
 42854:     return mAllowDownloadableFonts;
 19962: }
 19962: 
 79445: bool
 55084: gfxPlatform::SanitizeDownloadedFonts()
 55084: {
 55084:     if (mDownloadableFontsSanitize == UNINITIALIZED_VALUE) {
 55084:         mDownloadableFontsSanitize =
 79445:             Preferences::GetBool(GFX_DOWNLOADABLE_FONTS_SANITIZE, true);
 55084:     }
 55084: 
 55084:     return mDownloadableFontsSanitize;
 55084: }
 55084: 
 91872: bool
 91872: gfxPlatform::UseCmapsDuringSystemFallback()
 91872: {
 91872:     if (mFallbackUsesCmaps == UNINITIALIZED_VALUE) {
 91872:         mFallbackUsesCmaps =
 91872:             Preferences::GetBool(GFX_PREF_FALLBACK_USE_CMAPS, false);
 91872:     }
 91872: 
 91872:     return mFallbackUsesCmaps;
 91872: }
 91872: 
 84392: #ifdef MOZ_GRAPHITE
 84392: bool
 84392: gfxPlatform::UseGraphiteShaping()
 84392: {
 84392:     if (mGraphiteShapingEnabled == UNINITIALIZED_VALUE) {
 84392:         mGraphiteShapingEnabled =
 84392:             Preferences::GetBool(GFX_PREF_GRAPHITE_SHAPING, false);
 84392:     }
 84392: 
 84392:     return mGraphiteShapingEnabled;
 84392: }
 84392: #endif
 84392: 
 79445: bool
 67838: gfxPlatform::UseHarfBuzzForScript(PRInt32 aScriptCode)
 43527: {
 67838:     if (mUseHarfBuzzScripts == UNINITIALIZED_VALUE) {
 71640:         mUseHarfBuzzScripts = Preferences::GetInt(GFX_PREF_HARFBUZZ_SCRIPTS, HARFBUZZ_SCRIPTS_DEFAULT);
 43527:     }
 43527: 
 90890:     PRInt32 shapingType = mozilla::unicode::ScriptShapingType(aScriptCode);
 67838: 
 67838:     return (mUseHarfBuzzScripts & shapingType) != 0;
 43527: }
 43527: 
 32808: gfxFontEntry*
 32808: gfxPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
 32808:                               const PRUint8 *aFontData,
 32808:                               PRUint32 aLength)
 32808: {
 32808:     // Default implementation does not handle activating downloaded fonts;
 32808:     // just free the data and return.
 32808:     // Platforms that support @font-face must override this,
 32808:     // using the data to instantiate the font, and taking responsibility
 32808:     // for freeing it when no longer required.
 32808:     if (aFontData) {
 32808:         NS_Free((void*)aFontData);
 32808:     }
 32808:     return nsnull;
 32808: }
 19962: 
     1: static void
 38493: AppendGenericFontFromPref(nsString& aFonts, nsIAtom *aLangGroup, const char *aGenericName)
     1: {
 71640:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), );
     1: 
 38493:     nsCAutoString prefName, langGroupString;
     1: 
 38493:     aLangGroup->ToUTF8String(langGroupString);
 38493: 
 26915:     nsCAutoString genericDotLang;
     1:     if (aGenericName) {
 26915:         genericDotLang.Assign(aGenericName);
     1:     } else {
     1:         prefName.AssignLiteral("font.default.");
 38493:         prefName.Append(langGroupString);
 71640:         genericDotLang = Preferences::GetCString(prefName.get());
     1:     }
     1: 
     1:     genericDotLang.AppendLiteral(".");
 38493:     genericDotLang.Append(langGroupString);
     1: 
  9699:     // fetch font.name.xxx value                   
     1:     prefName.AssignLiteral("font.name.");
     1:     prefName.Append(genericDotLang);
 71640:     nsAdoptingString nameValue = Preferences::GetString(prefName.get());
 71640:     if (nameValue) {
     1:         if (!aFonts.IsEmpty())
     1:             aFonts.AppendLiteral(", ");
 71640:         aFonts += nameValue;
     1:     }
     1: 
  9699:     // fetch font.name-list.xxx value                   
     1:     prefName.AssignLiteral("font.name-list.");
     1:     prefName.Append(genericDotLang);
 71640:     nsAdoptingString nameListValue = Preferences::GetString(prefName.get());
 71640:     if (nameListValue && !nameListValue.Equals(nameValue)) {
     1:         if (!aFonts.IsEmpty())
     1:             aFonts.AppendLiteral(", ");
 71640:         aFonts += nameListValue;
     1:     }
     1: }
     1: 
     1: void
 79445: gfxPlatform::GetPrefFonts(nsIAtom *aLanguage, nsString& aFonts, bool aAppendUnicode)
     1: {
     1:     aFonts.Truncate();
     1: 
 38492:     AppendGenericFontFromPref(aFonts, aLanguage, nsnull);
  3609:     if (aAppendUnicode)
 94515:         AppendGenericFontFromPref(aFonts, nsGkAtoms::Unicode, nsnull);
     1: }
     1: 
 79445: bool gfxPlatform::ForEachPrefFont(eFontPrefLang aLangArray[], PRUint32 aLangArrayLen, PrefFontCallback aCallback,
 11086:                                     void *aClosure)
 11086: {
 80486:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), false);
 11086: 
 11086:     PRUint32    i;
 11086:     for (i = 0; i < aLangArrayLen; i++) {
 11086:         eFontPrefLang prefLang = aLangArray[i];
 11086:         const char *langGroup = GetPrefLangName(prefLang);
 11086:         
 11086:         nsCAutoString prefName;
 11086:     
 11086:         prefName.AssignLiteral("font.default.");
 11086:         prefName.Append(langGroup);
 71640:         nsAdoptingCString genericDotLang = Preferences::GetCString(prefName.get());
 11086:     
 11086:         genericDotLang.AppendLiteral(".");
 11086:         genericDotLang.Append(langGroup);
 11086:     
 11086:         // fetch font.name.xxx value                   
 11086:         prefName.AssignLiteral("font.name.");
 11086:         prefName.Append(genericDotLang);
 71640:         nsAdoptingCString nameValue = Preferences::GetCString(prefName.get());
 71640:         if (nameValue) {
 26915:             if (!aCallback(prefLang, NS_ConvertUTF8toUTF16(nameValue), aClosure))
 80486:                 return false;
 11086:         }
 11086:     
 11086:         // fetch font.name-list.xxx value                   
 11086:         prefName.AssignLiteral("font.name-list.");
 11086:         prefName.Append(genericDotLang);
 71640:         nsAdoptingCString nameListValue = Preferences::GetCString(prefName.get());
 71640:         if (nameListValue && !nameListValue.Equals(nameValue)) {
 36949:             const char kComma = ',';
 36949:             const char *p, *p_end;
 36949:             nsCAutoString list(nameListValue);
 36949:             list.BeginReading(p);
 36949:             list.EndReading(p_end);
 36949:             while (p < p_end) {
 36949:                 while (nsCRT::IsAsciiSpace(*p)) {
 36949:                     if (++p == p_end)
 36949:                         break;
 36949:                 }
 36949:                 if (p == p_end)
 36949:                     break;
 36949:                 const char *start = p;
 36949:                 while (++p != p_end && *p != kComma)
 36949:                     /* nothing */ ;
 36949:                 nsCAutoString fontName(Substring(start, p));
 80486:                 fontName.CompressWhitespace(false, true);
 36949:                 if (!aCallback(prefLang, NS_ConvertUTF8toUTF16(fontName), aClosure))
 80486:                     return false;
 36949:                 p++;
 36949:             }
 11086:         }
 11086:     }
 11086: 
 80486:     return true;
 11086: }
 11086: 
 11086: eFontPrefLang
 11086: gfxPlatform::GetFontPrefLangFor(const char* aLang)
 11086: {
 11086:     if (!aLang || !aLang[0])
 11086:         return eFontPrefLang_Others;
 11086:     for (PRUint32 i = 0; i < PRUint32(eFontPrefLang_LangCount); ++i) {
 11086:         if (!PL_strcasecmp(gPrefLangNames[i], aLang))
 11086:             return eFontPrefLang(i);
 11086:     }
 11086:     return eFontPrefLang_Others;
 11086: }
 11086: 
 38493: eFontPrefLang
 38493: gfxPlatform::GetFontPrefLangFor(nsIAtom *aLang)
 38493: {
 38493:     if (!aLang)
 38493:         return eFontPrefLang_Others;
 38493:     nsCAutoString lang;
 38493:     aLang->ToUTF8String(lang);
 38493:     return GetFontPrefLangFor(lang.get());
 38493: }
 38493: 
 11086: const char*
 11086: gfxPlatform::GetPrefLangName(eFontPrefLang aLang)
 11086: {
 11086:     if (PRUint32(aLang) < PRUint32(eFontPrefLang_AllCount))
 11086:         return gPrefLangNames[PRUint32(aLang)];
 11086:     return nsnull;
 11086: }
 11086: 
 37211: eFontPrefLang
 37211: gfxPlatform::GetFontPrefLangFor(PRUint8 aUnicodeRange)
 37211: {
 37211:     switch (aUnicodeRange) {
 37211:         case kRangeSetLatin:   return eFontPrefLang_Western;
 37211:         case kRangeCyrillic:   return eFontPrefLang_Cyrillic;
 37211:         case kRangeGreek:      return eFontPrefLang_Greek;
 37211:         case kRangeTurkish:    return eFontPrefLang_Turkish;
 37211:         case kRangeHebrew:     return eFontPrefLang_Hebrew;
 37211:         case kRangeArabic:     return eFontPrefLang_Arabic;
 37211:         case kRangeBaltic:     return eFontPrefLang_Baltic;
 37211:         case kRangeThai:       return eFontPrefLang_Thai;
 37211:         case kRangeKorean:     return eFontPrefLang_Korean;
 37211:         case kRangeJapanese:   return eFontPrefLang_Japanese;
 37211:         case kRangeSChinese:   return eFontPrefLang_ChineseCN;
 37211:         case kRangeTChinese:   return eFontPrefLang_ChineseTW;
 37211:         case kRangeDevanagari: return eFontPrefLang_Devanagari;
 37211:         case kRangeTamil:      return eFontPrefLang_Tamil;
 37211:         case kRangeArmenian:   return eFontPrefLang_Armenian;
 37211:         case kRangeBengali:    return eFontPrefLang_Bengali;
 37211:         case kRangeCanadian:   return eFontPrefLang_Canadian;
 37211:         case kRangeEthiopic:   return eFontPrefLang_Ethiopic;
 37211:         case kRangeGeorgian:   return eFontPrefLang_Georgian;
 37211:         case kRangeGujarati:   return eFontPrefLang_Gujarati;
 37211:         case kRangeGurmukhi:   return eFontPrefLang_Gurmukhi;
 37211:         case kRangeKhmer:      return eFontPrefLang_Khmer;
 37211:         case kRangeMalayalam:  return eFontPrefLang_Malayalam;
 64505:         case kRangeOriya:      return eFontPrefLang_Oriya;
 64505:         case kRangeTelugu:     return eFontPrefLang_Telugu;
 64505:         case kRangeKannada:    return eFontPrefLang_Kannada;
 64505:         case kRangeSinhala:    return eFontPrefLang_Sinhala;
 64505:         case kRangeTibetan:    return eFontPrefLang_Tibetan;
 37211:         case kRangeSetCJK:     return eFontPrefLang_CJKSet;
 37211:         default:               return eFontPrefLang_Others;
 37211:     }
 37211: }
 37211: 
 79445: bool 
 11086: gfxPlatform::IsLangCJK(eFontPrefLang aLang)
 11086: {
 39063:     switch (aLang) {
 39063:         case eFontPrefLang_Japanese:
 39063:         case eFontPrefLang_ChineseTW:
 39063:         case eFontPrefLang_ChineseCN:
 39063:         case eFontPrefLang_ChineseHK:
 39063:         case eFontPrefLang_Korean:
 39063:         case eFontPrefLang_CJKSet:
 80486:             return true;
 39063:         default:
 80486:             return false;
 39063:     }
 11086: }
 11086: 
 11086: void 
 37211: gfxPlatform::GetLangPrefs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, eFontPrefLang aCharLang, eFontPrefLang aPageLang)
 37211: {
 37211:     if (IsLangCJK(aCharLang)) {
 37211:         AppendCJKPrefLangs(aPrefLangs, aLen, aCharLang, aPageLang);
 37211:     } else {
 37211:         AppendPrefLang(aPrefLangs, aLen, aCharLang);
 37211:     }
 37211: 
 37211:     AppendPrefLang(aPrefLangs, aLen, eFontPrefLang_Others);
 37211: }
 37211: 
 37211: void
 37211: gfxPlatform::AppendCJKPrefLangs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, eFontPrefLang aCharLang, eFontPrefLang aPageLang)
 37211: {
 37211:     // prefer the lang specified by the page *if* CJK
 37211:     if (IsLangCJK(aPageLang)) {
 37211:         AppendPrefLang(aPrefLangs, aLen, aPageLang);
 37211:     }
 37211:     
 37211:     // if not set up, set up the default CJK order, based on accept lang settings and locale
 37211:     if (mCJKPrefLangs.Length() == 0) {
 37211:     
 37211:         // temp array
 37211:         eFontPrefLang tempPrefLangs[kMaxLenPrefLangList];
 37211:         PRUint32 tempLen = 0;
 37211:         
 37211:         // Add the CJK pref fonts from accept languages, the order should be same order
 71640:         nsAdoptingCString list = Preferences::GetLocalizedCString("intl.accept_languages");
 39467:         if (!list.IsEmpty()) {
 37211:             const char kComma = ',';
 37211:             const char *p, *p_end;
 37211:             list.BeginReading(p);
 37211:             list.EndReading(p_end);
 37211:             while (p < p_end) {
 37211:                 while (nsCRT::IsAsciiSpace(*p)) {
 37211:                     if (++p == p_end)
 37211:                         break;
 37211:                 }
 37211:                 if (p == p_end)
 37211:                     break;
 37211:                 const char *start = p;
 37211:                 while (++p != p_end && *p != kComma)
 37211:                     /* nothing */ ;
 37211:                 nsCAutoString lang(Substring(start, p));
 80486:                 lang.CompressWhitespace(false, true);
 37211:                 eFontPrefLang fpl = gfxPlatform::GetFontPrefLangFor(lang.get());
 37211:                 switch (fpl) {
 37211:                     case eFontPrefLang_Japanese:
 37211:                     case eFontPrefLang_Korean:
 37211:                     case eFontPrefLang_ChineseCN:
 37211:                     case eFontPrefLang_ChineseHK:
 37211:                     case eFontPrefLang_ChineseTW:
 37211:                         AppendPrefLang(tempPrefLangs, tempLen, fpl);
 37211:                         break;
 37211:                     default:
 37211:                         break;
 37211:                 }
 37211:                 p++;
 37211:             }
 37211:         }
 37211: 
 37211:         do { // to allow 'break' to abort this block if a call fails
 37211:             nsresult rv;
 37211:             nsCOMPtr<nsILocaleService> ls =
 37211:                 do_GetService(NS_LOCALESERVICE_CONTRACTID, &rv);
 37211:             if (NS_FAILED(rv))
 37211:                 break;
 37211: 
 37211:             nsCOMPtr<nsILocale> appLocale;
 37211:             rv = ls->GetApplicationLocale(getter_AddRefs(appLocale));
 37211:             if (NS_FAILED(rv))
 37211:                 break;
 37211: 
 37211:             nsString localeStr;
 37211:             rv = appLocale->
 37211:                 GetCategory(NS_LITERAL_STRING(NSILOCALE_MESSAGE), localeStr);
 37211:             if (NS_FAILED(rv))
 37211:                 break;
 37211: 
 37211:             const nsAString& lang = Substring(localeStr, 0, 2);
 37211:             if (lang.EqualsLiteral("ja")) {
 37211:                 AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Japanese);
 37211:             } else if (lang.EqualsLiteral("zh")) {
 37211:                 const nsAString& region = Substring(localeStr, 3, 2);
 37211:                 if (region.EqualsLiteral("CN")) {
 37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseCN);
 37211:                 } else if (region.EqualsLiteral("TW")) {
 37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseTW);
 37211:                 } else if (region.EqualsLiteral("HK")) {
 37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseHK);
 37211:                 }
 37211:             } else if (lang.EqualsLiteral("ko")) {
 37211:                 AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Korean);
 37211:             }
 37211:         } while (0);
 37211: 
 37211:         // last resort... (the order is same as old gfx.)
 37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Japanese);
 37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Korean);
 37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseCN);
 37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseHK);
 37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseTW);
 37211:         
 37211:         // copy into the cached array
 37211:         PRUint32 j;
 37211:         for (j = 0; j < tempLen; j++) {
 37211:             mCJKPrefLangs.AppendElement(tempPrefLangs[j]);
 37211:         }
 37211:     }
 37211:     
 37211:     // append in cached CJK langs
 37211:     PRUint32  i, numCJKlangs = mCJKPrefLangs.Length();
 37211:     
 37211:     for (i = 0; i < numCJKlangs; i++) {
 37211:         AppendPrefLang(aPrefLangs, aLen, (eFontPrefLang) (mCJKPrefLangs[i]));
 37211:     }
 37211:         
 37211: }
 37211: 
 37211: void 
 11086: gfxPlatform::AppendPrefLang(eFontPrefLang aPrefLangs[], PRUint32& aLen, eFontPrefLang aAddLang)
 11086: {
 11086:     if (aLen >= kMaxLenPrefLangList) return;
 11086:     
 11086:     // make sure
 11086:     PRUint32  i = 0;
 11086:     while (i < aLen && aPrefLangs[i] != aAddLang) {
 11086:         i++;
 11086:     }
 11086:     
 11086:     if (i == aLen) {
 11086:         aPrefLangs[aLen] = aAddLang;
 11086:         aLen++;
 11086:     }
 11086: }
 11086: 
106543: void
106543: gfxPlatform::InitCanvasBackend(PRUint32 aBackendBitmask)
106543: {
106546:     if (!Preferences::GetBool("gfx.canvas.azure.enabled", false)) {
106546:         mPreferredCanvasBackend = BACKEND_NONE;
106546:         mFallbackCanvasBackend = BACKEND_NONE;
106546:         return;
106546:     }
106546: 
106543:     mPreferredCanvasBackend = GetCanvasBackendPref(aBackendBitmask);
106543:     mFallbackCanvasBackend = GetCanvasBackendPref(aBackendBitmask & ~(1 << mPreferredCanvasBackend));
106543: }
106543: 
106543: /* static */ BackendType
106543: gfxPlatform::GetCanvasBackendPref(PRUint32 aBackendBitmask)
106543: {
106543:     if (!gBackendList) {
106543:         gBackendList = new nsTArray<nsCString>();
106543:         nsCString prefString;
106543:         if (NS_SUCCEEDED(Preferences::GetCString("gfx.canvas.azure.backends", &prefString))) {
106543:             ParseString(prefString, ',', *gBackendList);
106543:         }
106543:     }
106543: 
106543:     for (PRUint32 i = 0; i < gBackendList->Length(); ++i) {
106543:         BackendType result = BackendTypeForName((*gBackendList)[i]);
106543:         if ((1 << result) & aBackendBitmask) {
106543:             return result;
106543:         }
106543:     }
106543:     return BACKEND_NONE;
106543: }
106543: 
 86671: bool
103934: gfxPlatform::UseProgressiveTilePainting()
103934: {
103934:     static bool sUseProgressiveTilePainting;
103934:     static bool sUseProgressiveTilePaintingPrefCached = false;
103934: 
103934:     if (!sUseProgressiveTilePaintingPrefCached) {
103934:         sUseProgressiveTilePaintingPrefCached = true;
103934:         mozilla::Preferences::AddBoolVarCache(&sUseProgressiveTilePainting,
103934:                                               "layers.progressive-paint",
103935:                                               false);
103934:     }
103934: 
103934:     return sUseProgressiveTilePainting;
103934: }
103934: 
103934: bool
 86671: gfxPlatform::UseAzureContentDrawing()
 86671: {
 86671:   static bool sAzureContentDrawingEnabled;
 86671:   static bool sAzureContentDrawingPrefCached = false;
 86671: 
 86671:   if (!sAzureContentDrawingPrefCached) {
 86671:     sAzureContentDrawingPrefCached = true;
 86671:     mozilla::Preferences::AddBoolVarCache(&sAzureContentDrawingEnabled,
 86671:                                           "gfx.content.azure.enabled");
 86671:   }
 86671: 
 86671:   return sAzureContentDrawingEnabled;
 86671: }
 86671: 
 16571: eCMSMode
 16571: gfxPlatform::GetCMSMode()
  3787: {
 80486:     if (gCMSInitialized == false) {
 80486:         gCMSInitialized = true;
 74461:         nsresult rv;
 74461: 
 16571:         PRInt32 mode;
 74461:         rv = Preferences::GetInt("gfx.color_management.mode", &mode);
 16571:         if (NS_SUCCEEDED(rv) && (mode >= 0) && (mode < eCMSMode_AllCount)) {
 19003:             gCMSMode = static_cast<eCMSMode>(mode);
  3787:         }
 74461: 
 79445:         bool enableV4;
 74468:         rv = Preferences::GetBool("gfx.color_management.enablev4", &enableV4);
 74468:         if (NS_SUCCEEDED(rv) && enableV4) {
 74461:             qcms_enable_iccv4();
 74461:         }
  3787:     }
 19003:     return gCMSMode;
  3787: }
  3787: 
 16152: /* Chris Murphy (CM consultant) suggests this as a default in the event that we
 16152: cannot reproduce relative + Black Point Compensation.  BPC brings an
 16152: unacceptable performance overhead, so we go with perceptual. */
 27035: #define INTENT_DEFAULT QCMS_INTENT_PERCEPTUAL
 27035: #define INTENT_MIN 0
 27035: #define INTENT_MAX 3
 16152: 
 74431: int
 16152: gfxPlatform::GetRenderingIntent()
 16152: {
 19003:     if (gCMSIntent == -2) {
 16152: 
 16152:         /* Try to query the pref system for a rendering intent. */
 16152:         PRInt32 pIntent;
 74461:         if (NS_SUCCEEDED(Preferences::GetInt("gfx.color_management.rendering_intent", &pIntent))) {
 16152:             /* If the pref is within range, use it as an override. */
 71640:             if ((pIntent >= INTENT_MIN) && (pIntent <= INTENT_MAX)) {
 19003:                 gCMSIntent = pIntent;
 71640:             }
 16152:             /* If the pref is out of range, use embedded profile. */
 71640:             else {
 19003:                 gCMSIntent = -1;
 16152:             }
 16152:         }
 16152:         /* If we didn't get a valid intent from prefs, use the default. */
 71640:         else {
 19003:             gCMSIntent = INTENT_DEFAULT;
 16152:         }
 71640:     }
 19003:     return gCMSIntent;
 16152: }
 16152: 
 19127: void 
 27035: gfxPlatform::TransformPixel(const gfxRGBA& in, gfxRGBA& out, qcms_transform *transform)
 19127: {
 19127: 
 19127:     if (transform) {
 27035:         /* we want the bytes in RGB order */
 19127: #ifdef IS_LITTLE_ENDIAN
 27035:         /* ABGR puts the bytes in |RGBA| order on little endian */
 19127:         PRUint32 packed = in.Packed(gfxRGBA::PACKED_ABGR);
 27035:         qcms_transform_data(transform,
 19127:                        (PRUint8 *)&packed, (PRUint8 *)&packed,
 19127:                        1);
 19127:         out.~gfxRGBA();
 19127:         new (&out) gfxRGBA(packed, gfxRGBA::PACKED_ABGR);
 19127: #else
 27035:         /* ARGB puts the bytes in |ARGB| order on big endian */
 19127:         PRUint32 packed = in.Packed(gfxRGBA::PACKED_ARGB);
 27035:         /* add one to move past the alpha byte */
 27035:         qcms_transform_data(transform,
 19127:                        (PRUint8 *)&packed + 1, (PRUint8 *)&packed + 1,
 19127:                        1);
 19127:         out.~gfxRGBA();
 19127:         new (&out) gfxRGBA(packed, gfxRGBA::PACKED_ARGB);
 19127: #endif
 19127:     }
 19127: 
 19127:     else if (&out != &in)
 19127:         out = in;
 19127: }
 16152: 
 27035: qcms_profile *
  3787: gfxPlatform::GetPlatformCMSOutputProfile()
  3787: {
  3787:     return nsnull;
  3787: }
  3787: 
 27035: qcms_profile *
  3787: gfxPlatform::GetCMSOutputProfile()
  3787: {
  3787:     if (!gCMSOutputProfile) {
 41340:         NS_TIME_FUNCTION;
  3787: 
 19003:         /* Determine if we're using the internal override to force sRGB as
 61192:            an output profile for reftests. See Bug 452125.
 61192: 
 61192:            Note that we don't normally (outside of tests) set a
 71640:            default value of this preference, which means nsIPrefBranch::GetBoolPref
 61192:            will typically throw (and leave its out-param untouched).
 61192:          */
 79445:         if (Preferences::GetBool("gfx.color_management.force_srgb", false)) {
 19003:             gCMSOutputProfile = GetCMSsRGBProfile();
 71640:         }
 19003: 
 19003:         if (!gCMSOutputProfile) {
 74461:             nsAdoptingCString fname = Preferences::GetCString("gfx.color_management.display_profile");
 71640:             if (!fname.IsEmpty()) {
 27035:                 gCMSOutputProfile = qcms_profile_from_path(fname);
 19003:             }
  3787:         }
  3787: 
  3787:         if (!gCMSOutputProfile) {
  3787:             gCMSOutputProfile =
  3787:                 gfxPlatform::GetPlatform()->GetPlatformCMSOutputProfile();
  3787:         }
  3787: 
 22446:         /* Determine if the profile looks bogus. If so, close the profile
 22446:          * and use sRGB instead. See bug 460629, */
 27035:         if (gCMSOutputProfile && qcms_profile_is_bogus(gCMSOutputProfile)) {
 22446:             NS_ASSERTION(gCMSOutputProfile != GetCMSsRGBProfile(),
 22446:                          "Builtin sRGB profile tagged as bogus!!!");
 27035:             qcms_profile_release(gCMSOutputProfile);
 22446:             gCMSOutputProfile = nsnull;
 22446:         }
 22446: 
  3787:         if (!gCMSOutputProfile) {
 15987:             gCMSOutputProfile = GetCMSsRGBProfile();
  3787:         }
 16720:         /* Precache the LUT16 Interpolations for the output profile. See 
 16720:            bug 444661 for details. */
 27035:         qcms_profile_precache_output_transform(gCMSOutputProfile);
  3787:     }
  3787: 
  3787:     return gCMSOutputProfile;
  3787: }
  3787: 
 27035: qcms_profile *
 15987: gfxPlatform::GetCMSsRGBProfile()
 15987: {
 16720:     if (!gCMSsRGBProfile) {
 16720: 
 32801:         /* Create the profile using qcms. */
 27035:         gCMSsRGBProfile = qcms_profile_sRGB();
 16720:     }
 15987:     return gCMSsRGBProfile;
 15987: }
 15987: 
 27035: qcms_transform *
  3787: gfxPlatform::GetCMSRGBTransform()
  3787: {
  3787:     if (!gCMSRGBTransform) {
 27035:         qcms_profile *inProfile, *outProfile;
  3787:         outProfile = GetCMSOutputProfile();
 15987:         inProfile = GetCMSsRGBProfile();
  3787: 
  3787:         if (!inProfile || !outProfile)
  3787:             return nsnull;
  3787: 
 27035:         gCMSRGBTransform = qcms_transform_create(inProfile, QCMS_DATA_RGB_8,
 27035:                                               outProfile, QCMS_DATA_RGB_8,
 27035:                                              QCMS_INTENT_PERCEPTUAL);
  3787:     }
  3787: 
  3787:     return gCMSRGBTransform;
  3787: }
  3787: 
 27035: qcms_transform *
  5465: gfxPlatform::GetCMSInverseRGBTransform()
  5465: {
  5465:     if (!gCMSInverseRGBTransform) {
 27035:         qcms_profile *inProfile, *outProfile;
  5465:         inProfile = GetCMSOutputProfile();
 15987:         outProfile = GetCMSsRGBProfile();
  5465: 
  5465:         if (!inProfile || !outProfile)
  5465:             return nsnull;
  5465: 
 27035:         gCMSInverseRGBTransform = qcms_transform_create(inProfile, QCMS_DATA_RGB_8,
 27035:                                                      outProfile, QCMS_DATA_RGB_8,
 27035:                                                      QCMS_INTENT_PERCEPTUAL);
  5465:     }
  5465: 
  5465:     return gCMSInverseRGBTransform;
  5465: }
  5465: 
 27035: qcms_transform *
  3787: gfxPlatform::GetCMSRGBATransform()
  3787: {
  3787:     if (!gCMSRGBATransform) {
 27035:         qcms_profile *inProfile, *outProfile;
  3787:         outProfile = GetCMSOutputProfile();
 15987:         inProfile = GetCMSsRGBProfile();
  3787: 
  3787:         if (!inProfile || !outProfile)
  3787:             return nsnull;
  3787: 
 27035:         gCMSRGBATransform = qcms_transform_create(inProfile, QCMS_DATA_RGBA_8,
 27035:                                                outProfile, QCMS_DATA_RGBA_8,
 27035:                                                QCMS_INTENT_PERCEPTUAL);
  3787:     }
  3787: 
  3787:     return gCMSRGBATransform;
  3787: }
 16571: 
 19003: /* Shuts down various transforms and profiles for CMS. */
 19003: static void ShutdownCMS()
 19003: {
 19003: 
 19003:     if (gCMSRGBTransform) {
 27035:         qcms_transform_release(gCMSRGBTransform);
 19003:         gCMSRGBTransform = nsnull;
 19003:     }
 19003:     if (gCMSInverseRGBTransform) {
 27035:         qcms_transform_release(gCMSInverseRGBTransform);
 19003:         gCMSInverseRGBTransform = nsnull;
 19003:     }
 19003:     if (gCMSRGBATransform) {
 27035:         qcms_transform_release(gCMSRGBATransform);
 19003:         gCMSRGBATransform = nsnull;
 19003:     }
 19003:     if (gCMSOutputProfile) {
 27035:         qcms_profile_release(gCMSOutputProfile);
 19003: 
 19003:         // handle the aliased case
 19003:         if (gCMSsRGBProfile == gCMSOutputProfile)
 19003:             gCMSsRGBProfile = nsnull;
 19003:         gCMSOutputProfile = nsnull;
 19003:     }
 19003:     if (gCMSsRGBProfile) {
 27035:         qcms_profile_release(gCMSsRGBProfile);
 19003:         gCMSsRGBProfile = nsnull;
 19003:     }
 19003: 
 19003:     // Reset the state variables
 19003:     gCMSIntent = -2;
 19003:     gCMSMode = eCMSMode_Off;
 80486:     gCMSInitialized = false;
 19003: }
 19003: 
 16571: static void MigratePrefs()
 16571: {
 16571:     /* Migrate from the boolean color_management.enabled pref - we now use
 16571:        color_management.mode. */
 74461:     if (Preferences::HasUserValue("gfx.color_management.enabled")) {
 79445:         if (Preferences::GetBool("gfx.color_management.enabled", false)) {
 74461:             Preferences::SetInt("gfx.color_management.mode", static_cast<PRInt32>(eCMSMode_All));
 16571:         }
 74461:         Preferences::ClearUser("gfx.color_management.enabled");
 71640:     }
 16571: }
 32950: 
 37211: // default SetupClusterBoundaries, based on Unicode properties;
 37211: // platform subclasses may override if they wish
 37211: void
 37211: gfxPlatform::SetupClusterBoundaries(gfxTextRun *aTextRun, const PRUnichar *aString)
 37211: {
 37211:     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT) {
 37211:         // 8-bit text doesn't have clusters.
 37211:         // XXX is this true in all languages???
 37211:         // behdad: don't think so.  Czech for example IIRC has a
 37211:         // 'ch' grapheme.
 58936:         // jfkthame: but that's not expected to behave as a grapheme cluster
 58936:         // for selection/editing/etc.
 37211:         return;
 37211:     }
 37211: 
 86691:     gfxShapedWord::SetupClusterBoundaries(aTextRun->GetCharacterGlyphs(),
 86691:                                           aString, aTextRun->GetLength());
 37211: }
 58936: 
 86691: PRInt32
 86691: gfxPlatform::GetBidiNumeralOption()
 58936: {
 86691:     if (mBidiNumeralOption == UNINITIALIZED_VALUE) {
 86691:         mBidiNumeralOption = Preferences::GetInt(BIDI_NUMERAL_PREF, 0);
 37211:     }
 86691:     return mBidiNumeralOption;
 37211: }
 42854: 
 42854: void
 71640: gfxPlatform::FontsPrefsChanged(const char *aPref)
 42854: {
 43527:     NS_ASSERTION(aPref != nsnull, "null preference");
 42854:     if (!strcmp(GFX_DOWNLOADABLE_FONTS_ENABLED, aPref)) {
 42854:         mAllowDownloadableFonts = UNINITIALIZED_VALUE;
 55084:     } else if (!strcmp(GFX_DOWNLOADABLE_FONTS_SANITIZE, aPref)) {
 55084:         mDownloadableFontsSanitize = UNINITIALIZED_VALUE;
 91872:     } else if (!strcmp(GFX_PREF_FALLBACK_USE_CMAPS, aPref)) {
 91872:         mFallbackUsesCmaps = UNINITIALIZED_VALUE;
 84392: #ifdef MOZ_GRAPHITE
 84392:     } else if (!strcmp(GFX_PREF_GRAPHITE_SHAPING, aPref)) {
 84392:         mGraphiteShapingEnabled = UNINITIALIZED_VALUE;
 90310:         gfxFontCache *fontCache = gfxFontCache::GetCache();
 90310:         if (fontCache) {
 90310:             fontCache->AgeAllGenerations();
 90310:             fontCache->FlushShapedWordCaches();
 90310:         }
 84392: #endif
 67838:     } else if (!strcmp(GFX_PREF_HARFBUZZ_SCRIPTS, aPref)) {
 67838:         mUseHarfBuzzScripts = UNINITIALIZED_VALUE;
 90310:         gfxFontCache *fontCache = gfxFontCache::GetCache();
 90310:         if (fontCache) {
 90310:             fontCache->AgeAllGenerations();
 90310:             fontCache->FlushShapedWordCaches();
 90310:         }
 86691:     } else if (!strcmp(BIDI_NUMERAL_PREF, aPref)) {
 86691:         mBidiNumeralOption = UNINITIALIZED_VALUE;
 42854:     }
 42854: }
 61084: 
 61084: 
 61084: PRLogModuleInfo*
 61084: gfxPlatform::GetLog(eGfxLog aWhichLog)
 61084: {
 61084: #ifdef PR_LOGGING
 61084:     switch (aWhichLog) {
 61084:     case eGfxLog_fontlist:
 61084:         return sFontlistLog;
 61084:         break;
 61084:     case eGfxLog_fontinit:
 61084:         return sFontInitLog;
 61084:         break;
 61084:     case eGfxLog_textrun:
 61084:         return sTextrunLog;
 61084:         break;
 61084:     case eGfxLog_textrunui:
 61084:         return sTextrunuiLog;
 61084:         break;
 91869:     case eGfxLog_cmapdata:
 91869:         return sCmapDataLog;
 91869:         break;
 61084:     default:
 61084:         break;
 61084:     }
 61084: 
 61084:     return nsnull;
 61084: #else
 61084:     return nsnull;
 61084: #endif
 61084: }
 98557: 
 98557: int
 98557: gfxPlatform::GetScreenDepth() const
 98557: {
105610:     NS_WARNING("GetScreenDepth not implemented on this platform -- returning 0!");
 98557:     return 0;
 98557: }
 99511: 
 99511: mozilla::gfx::SurfaceFormat
 99511: gfxPlatform::Optimal2DFormatForContent(gfxASurface::gfxContentType aContent)
 99511: {
 99511:   switch (aContent) {
 99511:   case gfxASurface::CONTENT_COLOR:
102379:     switch (GetOffscreenFormat()) {
102379:     case gfxASurface::ImageFormatARGB32:
102379:       return mozilla::gfx::FORMAT_B8G8R8A8;
102379:     case gfxASurface::ImageFormatRGB24:
 99511:       return mozilla::gfx::FORMAT_B8G8R8X8;
102379:     case gfxASurface::ImageFormatRGB16_565:
102379:       return mozilla::gfx::FORMAT_R5G6B5;
102379:     default:
102379:       NS_NOTREACHED("unknown gfxImageFormat for CONTENT_COLOR");
102379:       return mozilla::gfx::FORMAT_B8G8R8A8;
102379:     }
 99511:   case gfxASurface::CONTENT_ALPHA:
 99511:     return mozilla::gfx::FORMAT_A8;
 99511:   case gfxASurface::CONTENT_COLOR_ALPHA:
 99511:     return mozilla::gfx::FORMAT_B8G8R8A8;
 99511:   default:
 99511:     NS_NOTREACHED("unknown gfxContentType");
 99511:     return mozilla::gfx::FORMAT_B8G8R8A8;
 99511:   }
 99511: }
 99511: 
 99511: gfxImageFormat
 99511: gfxPlatform::OptimalFormatForContent(gfxASurface::gfxContentType aContent)
 99511: {
 99511:   switch (aContent) {
 99511:   case gfxASurface::CONTENT_COLOR:
 99511:     return GetOffscreenFormat();
 99511:   case gfxASurface::CONTENT_ALPHA:
 99511:     return gfxASurface::ImageFormatA8;
 99511:   case gfxASurface::CONTENT_COLOR_ALPHA:
 99511:     return gfxASurface::ImageFormatARGB32;
 99511:   default:
 99511:     NS_NOTREACHED("unknown gfxContentType");
 99511:     return gfxASurface::ImageFormatARGB32;
 99511:   }
 99511: }
