    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Alex Fritze <alex.fritze@crocodile-clips.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsSVGElement.h"
    1: #include "nsSVGSVGElement.h"
15895: #include "nsSVGSwitchElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsRange.h"
    1: #include "nsIDOMAttr.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsMutationEvent.h"
 8335: #include "nsXBLPrototypeBinding.h"
    1: #include "nsBindingManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsDOMError.h"
    1: #include "nsIPresShell.h"
68870: #include "nsIDOMViewCSS.h"
68870: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIXBLService.h"
    1: #include "nsGkAtoms.h"
63693: #include "mozilla/css/StyleRule.h"
    1: #include "nsRuleWalker.h"
47937: #include "mozilla/css/Declaration.h"
    1: #include "nsCSSProps.h"
38849: #include "nsCSSParser.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsSVGUtils.h"
    1: #include "nsSVGLength2.h"
    1: #include "nsSVGNumber2.h"
 6045: #include "nsSVGInteger.h"
 6788: #include "nsSVGAngle.h"
 6325: #include "nsSVGBoolean.h"
 5347: #include "nsSVGEnum.h"
24554: #include "nsSVGViewBox.h"
15353: #include "nsSVGString.h"
64109: #include "nsSVGClass.h"
58554: #include "SVGAnimatedNumberList.h"
47840: #include "SVGAnimatedLengthList.h"
58893: #include "SVGAnimatedPointList.h"
57113: #include "SVGAnimatedPathSegList.h"
 5347: #include "nsIDOMSVGUnitTypes.h"
 5729: #include "nsIDOMSVGPointList.h"
 5729: #include "nsIDOMSVGAnimatedPoints.h"
 5729: #include "nsIDOMSVGTransformList.h"
 5729: #include "nsIDOMSVGAnimTransformList.h"
 5729: #include "nsIDOMSVGAnimatedRect.h"
42893: #include "nsIDOMSVGGradientElement.h"
42893: #include "nsIDOMSVGPatternElement.h"
 5729: #include "nsSVGRect.h"
23697: #include "nsIFrame.h"
 6944: #include "prdtoa.h"
    1: #include <stdarg.h>
23697: #ifdef MOZ_SMIL
39488: #include "nsSMILMappedAttribute.h"
23931: #include "nsSVGTransformSMILAttr.h"
23931: #include "nsSVGAnimatedTransformList.h"
41504: #include "SVGMotionSMILAttr.h"
23697: #include "nsIDOMSVGTransformable.h"
23697: #endif // MOZ_SMIL
    1: 
48193: using namespace mozilla;
48193: 
40718: // This is needed to ensure correct handling of calls to the
40718: // vararg-list methods in this file:
40718: //   nsSVGElement::GetAnimated{Length,Number,Integer}Values
40718: // See bug 547964 for details:
40718: PR_STATIC_ASSERT(sizeof(void*) == sizeof(nsnull));
40718: 
40718: 
 5347: nsSVGEnumMapping nsSVGElement::sSVGUnitTypesMap[] = {
 5347:   {&nsGkAtoms::userSpaceOnUse, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_USERSPACEONUSE},
 5347:   {&nsGkAtoms::objectBoundingBox, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX},
 5347:   {nsnull, 0}
 5347: };
 5347: 
48124: nsSVGElement::nsSVGElement(already_AddRefed<nsINodeInfo> aNodeInfo)
11169:   : nsSVGElementBase(aNodeInfo), mSuppressNotification(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsresult
    1: nsSVGElement::Init()
    1: {
    1:   // Set up length attributes - can't do this in the constructor
    1:   // because we can't do a virtual call at that point
    1: 
    1:   LengthAttributesInfo lengthInfo = GetLengthInfo();
    1: 
    1:   PRUint32 i;
    1:   for (i = 0; i < lengthInfo.mLengthCount; i++) {
 8288:     lengthInfo.Reset(i);
    1:   }
    1: 
    1:   NumberAttributesInfo numberInfo = GetNumberInfo();
    1: 
    1:   for (i = 0; i < numberInfo.mNumberCount; i++) {
 8288:     numberInfo.Reset(i);
    1:   }
    1: 
 6045:   IntegerAttributesInfo integerInfo = GetIntegerInfo();
 6045: 
 6045:   for (i = 0; i < integerInfo.mIntegerCount; i++) {
 8288:     integerInfo.Reset(i);
 6045:   }
 6045: 
 6788:   AngleAttributesInfo angleInfo = GetAngleInfo();
 6788: 
 6788:   for (i = 0; i < angleInfo.mAngleCount; i++) {
 8288:     angleInfo.Reset(i);
 6788:   }
 6788: 
 6325:   BooleanAttributesInfo booleanInfo = GetBooleanInfo();
 6325: 
 6325:   for (i = 0; i < booleanInfo.mBooleanCount; i++) {
 8288:     booleanInfo.Reset(i);
 6325:   }
 6325: 
 5347:   EnumAttributesInfo enumInfo = GetEnumInfo();
 5347: 
 5347:   for (i = 0; i < enumInfo.mEnumCount; i++) {
 8288:     enumInfo.Reset(i);
 5347:   }
 5347: 
24554:   nsSVGViewBox *viewBox = GetViewBox();
24554: 
24554:   if (viewBox) {
24554:     viewBox->Init();
24554:   }
24554: 
59470:   SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
23313:     GetPreserveAspectRatio();
23313: 
23313:   if (preserveAspectRatio) {
23313:     preserveAspectRatio->Init();
23313:   }
23313: 
47840:   LengthListAttributesInfo lengthListInfo = GetLengthListInfo();
47840: 
47840:   for (i = 0; i < lengthListInfo.mLengthListCount; i++) {
47840:     lengthListInfo.Reset(i);
47840:   }
47840: 
58554:   NumberListAttributesInfo numberListInfo = GetNumberListInfo();
58554: 
58554:   for (i = 0; i < numberListInfo.mNumberListCount; i++) {
58554:     numberListInfo.Reset(i);
58554:   }
58554: 
58893:   // No need to reset SVGPointList since the default value is always the same
58893:   // (an empty list).
58893: 
58893:   // No need to reset SVGPathData since the default value is always the same
57113:   // (an empty list).
57113: 
15353:   StringAttributesInfo stringInfo = GetStringInfo();
15353: 
15353:   for (i = 0; i < stringInfo.mStringCount; i++) {
15353:     stringInfo.Reset(i);
15353:   }
15353: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsSVGElement::~nsSVGElement()
    1: {
    1:   PRUint32 i, count = mMappedAttributes.AttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     mMappedAttributes.AttrAt(i)->GetSVGValue()->RemoveObserver(this);
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISupports methods
    1: 
 4306: NS_IMPL_ADDREF_INHERITED(nsSVGElement, nsSVGElementBase)
 4306: NS_IMPL_RELEASE_INHERITED(nsSVGElement, nsSVGElementBase)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsSVGElement)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:   NS_INTERFACE_MAP_ENTRY(nsISVGValueObserver)
    1: // provided by nsGenericElement:
    1: //  NS_INTERFACE_MAP_ENTRY(nsIContent)
 4306: NS_INTERFACE_MAP_END_INHERITING(nsSVGElementBase)
    1: 
    1: //----------------------------------------------------------------------
    1: // Implementation
    1:   
    1: //----------------------------------------------------------------------
    1: // nsIContent methods
    1: 
    1: nsresult
 9755: nsSVGElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
 9755:                          nsIContent* aBindingParent,
 9755:                          PRBool aCompileEventHandlers)
 9755: {
 9755:   nsresult rv = nsSVGElementBase::BindToTree(aDocument, aParent,
 9755:                                              aBindingParent,
 9755:                                              aCompileEventHandlers);
 9755:   NS_ENSURE_SUCCESS(rv, rv);
 9755: 
67608:   if (!MayHaveStyle()) {
 9755:     return NS_OK;
 9755:   }
 9755:   const nsAttrValue* oldVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 9755: 
 9755:   if (oldVal && oldVal->Type() == nsAttrValue::eCSSStyleRule) {
 9755:     // we need to force a reparse because the baseURI of the document
38452:     // may have changed, and in particular because we may be clones of
38452:     // XBL anonymous content now being bound to the document we should
38452:     // render in and due to the hacky way in which we implement the
38452:     // interaction of XBL and SVG resources.  Once we have a sane
38452:     // ownerDocument on XBL anonymous content, this can all go away.
 9755:     nsAttrValue attrValue;
 9755:     nsAutoString stringValue;
 9755:     oldVal->ToString(stringValue);
11871:     // Force in data doc, since we already have a style rule
38452:     ParseStyleAttribute(stringValue, attrValue, PR_TRUE);
 9755:     // Don't bother going through SetInlineStyleRule, we don't want to fire off
 9755:     // mutation events or document notifications anyway
 9755:     rv = mAttrsAndChildren.SetAndTakeAttr(nsGkAtoms::style, attrValue);
 9755:     NS_ENSURE_SUCCESS(rv, rv);
 9755:   }
 9755: 
 9755:   return NS_OK;
 9755: }
 9755: 
 9755: nsresult
32412: nsSVGElement::AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                            const nsAString* aValue, PRBool aNotify)
    1: {  
    1:   // If this is an svg presentation attribute we need to map it into
    1:   // the content stylerule.
    1:   // XXX For some reason incremental mapping doesn't work, so for now
    1:   // just delete the style rule and lazily reconstruct it in
    1:   // GetContentStyleRule()
    1:   if (aNamespaceID == kNameSpaceID_None && IsAttributeMapped(aName)) {
    1:     mContentStyleRule = nsnull;
    1:   }
    1: 
    1:   if (IsEventName(aName) && aValue) {
    1:     nsresult rv = AddScriptEventListener(GetEventNameForAttr(aName), *aValue);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
15895:   if (aNamespaceID == kNameSpaceID_None &&
15895:       (aName == nsGkAtoms::requiredFeatures ||
15895:        aName == nsGkAtoms::requiredExtensions ||
15895:        aName == nsGkAtoms::systemLanguage)) {
15895: 
67658:     nsIContent* parent = GetFlattenedTreeParent();
15895:   
15895:     if (parent &&
15895:         parent->NodeInfo()->Equals(nsGkAtoms::svgSwitch, kNameSpaceID_SVG)) {
15895:       static_cast<nsSVGSwitchElement*>(parent)->MaybeInvalidate();
15895:     }
15895:   }
15895: 
 4306:   return nsSVGElementBase::AfterSetAttr(aNamespaceID, aName, aValue, aNotify);
    1: }
    1: 
    1: PRBool
    1: nsSVGElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                              nsIAtom* aAttribute,
    1:                              const nsAString& aValue,
    1:                              nsAttrValue& aResult)
    1: {
    1:   // Parse value
    1:   nsCOMPtr<nsISVGValue> svg_value;
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aAttribute, aNamespaceID);
    1:   if (val) {
    1:     // Found the attr in the list.
    1:     if (val->Type() == nsAttrValue::eSVGValue) {
    1:       svg_value = val->GetSVGValue();
    1:     }
    1:   }
    1:   else {
    1:     // Could be a mapped attribute.
    1:     svg_value = GetMappedAttribute(aNamespaceID, aAttribute);
    1:   }
    1:   
    1:   if (svg_value) {
    1:     // We want to prevent DidModifySVGObservable from running if we
    1:     // come in this route, otherwise AttributeChanged() gets called
    1:     // twice (once through DidMOdifySVGObservable, once through SetAttr).
    1:     mSuppressNotification = PR_TRUE;
    1: 
    1:     if (NS_FAILED(svg_value->SetValueString(aValue))) {
    1:       // The value was rejected. This happens e.g. in a XUL template
    1:       // when trying to set a value like "?x" on a value object that
    1:       // expects a length.
16188:       // To accommodate this "erroneous" value, we'll insert a proxy
    1:       // object between ourselves and the actual value object:
    1:       ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
    1:       nsCOMPtr<nsISVGValue> proxy;
    1:       nsresult rv =
    1:         NS_CreateSVGStringProxyValue(svg_value, getter_AddRefs(proxy));
    1:       // Failure means we'll store this attr as a string, not an SVGValue, but
    1:       // that's the best we can do short of throwing outright.
    1:       NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:       svg_value->RemoveObserver(this);
 8288:       ResetOldStyleBaseType(svg_value);
    1:       proxy->SetValueString(aValue);
    1:       proxy->AddObserver(this);
    1:       aResult.SetTo(proxy);
    1:     }
    1:     else {
    1:       aResult.SetTo(svg_value);
    1:     }
    1:     mSuppressNotification = PR_FALSE;
    1:     return PR_TRUE;
    1:   }
    1: 
23133:   nsresult rv = NS_OK;
15353:   PRBool foundMatch = PR_FALSE;
    1:   if (aNamespaceID == kNameSpaceID_None) {
 5347: 
    1:     // Check for nsSVGLength2 attribute
    1:     LengthAttributesInfo lengthInfo = GetLengthInfo();
 6788: 
 6788:     PRUint32 i;
15353:     for (i = 0; i < lengthInfo.mLengthCount; i++) {
    1:       if (aAttribute == *lengthInfo.mLengthInfo[i].mName) {
 5347:         rv = lengthInfo.mLengths[i].SetBaseValueString(aValue, this, PR_FALSE);
 8288:         if (NS_FAILED(rv)) {
 8288:           lengthInfo.Reset(i);
 8288:         }
 5347:         foundMatch = PR_TRUE;
15353:         break;
 5347:       }
 5347:     }
 5347: 
15353:     if (!foundMatch) {
47840:       // Check for SVGAnimatedLengthList attribute
47840:       LengthListAttributesInfo lengthListInfo = GetLengthListInfo();
47840:       for (i = 0; i < lengthListInfo.mLengthListCount; i++) {
47840:         if (aAttribute == *lengthListInfo.mLengthListInfo[i].mName) {
47840:           rv = lengthListInfo.mLengthLists[i].SetBaseValueString(aValue);
47840:           if (NS_FAILED(rv)) {
58554:             ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
47840:             lengthListInfo.Reset(i);
47840:           }
47840:           foundMatch = PR_TRUE;
47840:           break;
47840:         }
47840:       }
47840:     }
47840: 
47840:     if (!foundMatch) {
58554:       // Check for SVGAnimatedNumberList attribute
58554:       NumberListAttributesInfo numberListInfo = GetNumberListInfo();
58554:       for (i = 0; i < numberListInfo.mNumberListCount; i++) {
58554:         if (aAttribute == *numberListInfo.mNumberListInfo[i].mName) {
58554:           rv = numberListInfo.mNumberLists[i].SetBaseValueString(aValue);
58554:           if (NS_FAILED(rv)) {
58554:             ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
58554:             numberListInfo.Reset(i);
58554:           }
58554:           foundMatch = PR_TRUE;
58554:           break;
58554:         }
58554:       }
58554:     }
58554: 
58554:     if (!foundMatch) {
58893:       // Check for SVGAnimatedPointList attribute
58893:       if (GetPointListAttrName() == aAttribute) {
58893:         SVGAnimatedPointList* pointList = GetAnimatedPointList();
58893:         if (pointList) {
58893:           rv = pointList->SetBaseValueString(aValue);
58893:           if (NS_FAILED(rv)) {
58893:             ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
58893:             // The spec says we parse everything up to the failure, so we don't
58893:             // call pointList->ClearBaseValue()
58893:           }
58893:           foundMatch = PR_TRUE;
58893:         }
58893:       }
58893:     }
58893: 
58893:     if (!foundMatch) {
57113:       // Check for SVGAnimatedPathSegList attribute
57113:       if (GetPathDataAttrName() == aAttribute) {
57113:         SVGAnimatedPathSegList* segList = GetAnimPathSegList();
57113:         if (segList) {
57113:           rv = segList->SetBaseValueString(aValue);
57113:           if (NS_FAILED(rv)) {
57113:             ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
57113:             // The spec says we parse everything up to the failure, so we don't
57113:             // call segList->ClearBaseValue()
57113:           }
57113:           foundMatch = PR_TRUE;
57113:         }
57113:       }
57113:     }
57113: 
57113:     if (!foundMatch) {
 5347:       // Check for nsSVGNumber2 attribute
 5347:       NumberAttributesInfo numberInfo = GetNumberInfo();
15353:       for (i = 0; i < numberInfo.mNumberCount; i++) {
 5347:         if (aAttribute == *numberInfo.mNumberInfo[i].mName) {
15523:           if (i + 1 < numberInfo.mNumberCount &&
15523:               aAttribute == *numberInfo.mNumberInfo[i + 1].mName) {
15523:             rv = ParseNumberOptionalNumber(aValue, i, i + 1);
15523:             if (NS_FAILED(rv)) {
15523:               numberInfo.Reset(i + 1);
15523:             }
15523:           } else {
 5347:             rv = numberInfo.mNumbers[i].SetBaseValueString(aValue, this, PR_FALSE);
15523:           }
 8288:           if (NS_FAILED(rv)) {
 8288:             numberInfo.Reset(i);
 8288:           }
 5347:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 5347:       }
 5347:     }
 5347: 
15353:     if (!foundMatch) {
 6045:       // Check for nsSVGInteger attribute
 6045:       IntegerAttributesInfo integerInfo = GetIntegerInfo();
15353:       for (i = 0; i < integerInfo.mIntegerCount; i++) {
 6045:         if (aAttribute == *integerInfo.mIntegerInfo[i].mName) {
15523:           if (i + 1 < integerInfo.mIntegerCount &&
15523:               aAttribute == *integerInfo.mIntegerInfo[i + 1].mName) {
15523:             rv = ParseIntegerOptionalInteger(aValue, i, i + 1);
15523:             if (NS_FAILED(rv)) {
15523:               integerInfo.Reset(i + 1);
15523:             }
15523:           } else {
 6045:             rv = integerInfo.mIntegers[i].SetBaseValueString(aValue, this, PR_FALSE);
15523:           }
 8288:           if (NS_FAILED(rv)) {
 8288:             integerInfo.Reset(i);
 8288:           }
 6045:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 6045:       }
 6045:     }
 6045: 
15353:     if (!foundMatch) {
 6788:       // Check for nsSVGAngle attribute
 6788:       AngleAttributesInfo angleInfo = GetAngleInfo();
15353:       for (i = 0; i < angleInfo.mAngleCount; i++) {
 6788:         if (aAttribute == *angleInfo.mAngleInfo[i].mName) {
 6788:           rv = angleInfo.mAngles[i].SetBaseValueString(aValue, this, PR_FALSE);
 8288:           if (NS_FAILED(rv)) {
 8288:             angleInfo.Reset(i);
 8288:           }
 6788:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 6788:       }
 6788:     }
 6788: 
15353:     if (!foundMatch) {
 6325:       // Check for nsSVGBoolean attribute
 6325:       BooleanAttributesInfo booleanInfo = GetBooleanInfo();
15353:       for (i = 0; i < booleanInfo.mBooleanCount; i++) {
 6325:         if (aAttribute == *booleanInfo.mBooleanInfo[i].mName) {
 6325:           rv = booleanInfo.mBooleans[i].SetBaseValueString(aValue, this, PR_FALSE);
 8288:           if (NS_FAILED(rv)) {
 8288:             booleanInfo.Reset(i);
 8288:           }
 6325:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 6325:       }
 6325:     }
 6325: 
15353:     if (!foundMatch) {
 5347:       // Check for nsSVGEnum attribute
 5347:       EnumAttributesInfo enumInfo = GetEnumInfo();
15353:       for (i = 0; i < enumInfo.mEnumCount; i++) {
 5347:         if (aAttribute == *enumInfo.mEnumInfo[i].mName) {
 5347:           rv = enumInfo.mEnums[i].SetBaseValueString(aValue, this, PR_FALSE);
 8288:           if (NS_FAILED(rv)) {
 8288:             enumInfo.Reset(i);
 8288:           }
 5347:           foundMatch = PR_TRUE;
15353:           break;
15353:         }
 5347:       }
 5347:     }
23313: 
24554:     if (!foundMatch) {
24554:       // Check for nsSVGViewBox attribute
24554:       if (aAttribute == nsGkAtoms::viewBox) {
24554:         nsSVGViewBox* viewBox = GetViewBox();
24554:         if (viewBox) {
24554:           rv = viewBox->SetBaseValueString(aValue, this, PR_FALSE);
24554:           if (NS_FAILED(rv)) {
24554:             viewBox->Init();
24554:           }
24554:           foundMatch = PR_TRUE;
24554:         }
59470:       // Check for SVGAnimatedPreserveAspectRatio attribute
24554:       } else if (aAttribute == nsGkAtoms::preserveAspectRatio) {
59470:         SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
23313:           GetPreserveAspectRatio();
23313:         if (preserveAspectRatio) {
23313:           rv = preserveAspectRatio->SetBaseValueString(aValue, this, PR_FALSE);
23313:           if (NS_FAILED(rv)) {
23313:             preserveAspectRatio->Init();
23313:           }
23313:           foundMatch = PR_TRUE;
23313:         }
64109:       // Check for class attribute
64109:       } else if (aAttribute == nsGkAtoms::_class) {
64109:         nsSVGClass *svgClass = GetClass();
64109:         if (svgClass) {
64109:           svgClass->SetBaseValue(aValue, this, PR_FALSE);
64109:           aResult.ParseAtomArray(aValue);
64109:           return PR_TRUE;
64109:         }
23313:       }
    1:     }
24554:   }
    1: 
15353:   if (!foundMatch) {
15353:     // Check for nsSVGString attribute
15353:     StringAttributesInfo stringInfo = GetStringInfo();
15353:     for (PRUint32 i = 0; i < stringInfo.mStringCount; i++) {
15353:       if (aNamespaceID == stringInfo.mStringInfo[i].mNamespaceID &&
15353:           aAttribute == *stringInfo.mStringInfo[i].mName) {
15353:         stringInfo.mStrings[i].SetBaseValue(aValue, this, PR_FALSE);
15353:         foundMatch = PR_TRUE;
15353:         break;
15353:       }
15353:     }
15353:   }
15353: 
23133:   if (foundMatch) {
23133:     if (NS_FAILED(rv)) {
23133:       ReportAttributeParseFailure(GetOwnerDoc(), aAttribute, aValue);
23133:       return PR_FALSE;
23133:     }
23133:     aResult.SetTo(aValue);
23133:     return PR_TRUE;
23133:   }
23133: 
 4306:   return nsSVGElementBase::ParseAttribute(aNamespaceID, aAttribute, aValue,
    1:                                           aResult);
    1: }
    1: 
    1: nsresult
    1: nsSVGElement::UnsetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                         PRBool aNotify)
    1: {
38454:   // XXXbz there's a bunch of redundancy here with AfterSetAttr.
38454:   // Maybe consolidate?
38454:   nsresult rv = nsSVGElementBase::UnsetAttr(aNamespaceID, aName, aNotify);
38454: 
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     // If this is an svg presentation attribute, remove rule to force an update
    1:     if (IsAttributeMapped(aName))
    1:       mContentStyleRule = nsnull;
    1: 
    1:     if (IsEventName(aName)) {
29474:       nsIEventListenerManager* manager = GetListenerManager(PR_FALSE);
    1:       if (manager) {
    1:         nsIAtom* eventName = GetEventNameForAttr(aName);
    1:         manager->RemoveScriptEventListener(eventName);
    1:       }
64109:       return rv;
15353:     }
15353:     
    1:     // Check if this is a length attribute going away
    1:     LengthAttributesInfo lenInfo = GetLengthInfo();
    1: 
15353:     for (PRUint32 i = 0; i < lenInfo.mLengthCount; i++) {
    1:       if (aName == *lenInfo.mLengthInfo[i].mName) {
 8288:         lenInfo.Reset(i);
    1:         DidChangeLength(i, PR_FALSE);
64109:         return rv;
    1:       }
15353:     }
15353: 
47840:     // Check if this is a length list attribute going away
47840:     LengthListAttributesInfo lengthListInfo = GetLengthListInfo();
47840: 
47840:     for (PRUint32 i = 0; i < lengthListInfo.mLengthListCount; i++) {
47840:       if (aName == *lengthListInfo.mLengthListInfo[i].mName) {
47840:         lengthListInfo.Reset(i);
47840:         DidChangeLengthList(i, PR_FALSE);
64109:         return rv;
47840:       }
47840:     }
47840: 
58554:     // Check if this is a number list attribute going away
58554:     NumberListAttributesInfo numberListInfo = GetNumberListInfo();
58554: 
58554:     for (PRUint32 i = 0; i < numberListInfo.mNumberListCount; i++) {
58554:       if (aName == *numberListInfo.mNumberListInfo[i].mName) {
58554:         numberListInfo.Reset(i);
58554:         DidChangeNumberList(i, PR_FALSE);
64109:         return rv;
58554:       }
58554:     }
58554: 
58893:     // Check if this is a point list attribute going away
58893:     if (GetPointListAttrName() == aName) {
58893:       SVGAnimatedPointList *pointList = GetAnimatedPointList();
58893:       if (pointList) {
58893:         pointList->ClearBaseValue();
64109:         return rv;
58893:       }
58893:     }
58893: 
57113:     // Check if this is a path segment list attribute going away
57113:     if (GetPathDataAttrName() == aName) {
57113:       SVGAnimatedPathSegList *segList = GetAnimPathSegList();
57113:       if (segList) {
57113:         segList->ClearBaseValue();
57113:         DidChangePathSegList(PR_FALSE);
64109:         return rv;
57113:       }
57113:     }
57113: 
    1:     // Check if this is a number attribute going away
    1:     NumberAttributesInfo numInfo = GetNumberInfo();
    1: 
15353:     for (PRUint32 i = 0; i < numInfo.mNumberCount; i++) {
    1:       if (aName == *numInfo.mNumberInfo[i].mName) {
15523:         if (i + 1 < numInfo.mNumberCount &&
15523:             aName == *numInfo.mNumberInfo[i + 1].mName) {
15523:           // found a number-optional-number
15523:           numInfo.Reset(i + 1);
15523:           DidChangeNumber(i + 1, PR_FALSE);
15523:         }
 8288:         numInfo.Reset(i);
    1:         DidChangeNumber(i, PR_FALSE);
64109:         return rv;
    1:       }
    1:     }
 5347: 
 6045:     // Check if this is an integer attribute going away
 6045:     IntegerAttributesInfo intInfo = GetIntegerInfo();
 6045: 
15353:     for (PRUint32 i = 0; i < intInfo.mIntegerCount; i++) {
 6045:       if (aName == *intInfo.mIntegerInfo[i].mName) {
15523:         if (i + 1 < intInfo.mIntegerCount &&
15523:             aName == *intInfo.mIntegerInfo[i + 1].mName) {
15523:           // found a number-optional-number
15523:           intInfo.Reset(i + 1);
15523:           DidChangeNumber(i + 1, PR_FALSE);
15523:         }
 8288:         intInfo.Reset(i);
 6045:         DidChangeInteger(i, PR_FALSE);
64109:         return rv;
 6045:       }
 6045:     }
 6045: 
 6788:     // Check if this is an angle attribute going away
 6788:     AngleAttributesInfo angleInfo = GetAngleInfo();
 6788: 
15353:     for (PRUint32 i = 0; i < angleInfo.mAngleCount; i++) {
 6788:       if (aName == *angleInfo.mAngleInfo[i].mName) {
 8288:         angleInfo.Reset(i);
 6788:         DidChangeAngle(i, PR_FALSE);
64109:         return rv;
 6788:       }
 6788:     }
 6788: 
 6325:     // Check if this is a boolean attribute going away
 6325:     BooleanAttributesInfo boolInfo = GetBooleanInfo();
 6325: 
15353:     for (PRUint32 i = 0; i < boolInfo.mBooleanCount; i++) {
 6325:       if (aName == *boolInfo.mBooleanInfo[i].mName) {
 8288:         boolInfo.Reset(i);
 6325:         DidChangeBoolean(i, PR_FALSE);
64109:         return rv;
 6325:       }
 6325:     }
 6325: 
 6045:     // Check if this is an enum attribute going away
 5347:     EnumAttributesInfo enumInfo = GetEnumInfo();
 5347: 
15353:     for (PRUint32 i = 0; i < enumInfo.mEnumCount; i++) {
 5347:       if (aName == *enumInfo.mEnumInfo[i].mName) {
 8288:         enumInfo.Reset(i);
 5347:         DidChangeEnum(i, PR_FALSE);
64109:         return rv;
15353:       }
 5347:     }
23313: 
24554:     // Check if this is a nsViewBox attribute going away
24554:     if (aName == nsGkAtoms::viewBox) {
24554:       nsSVGViewBox* viewBox = GetViewBox();
24554:       if (viewBox) {
24554:         viewBox->Init();
24554:         DidChangeViewBox(PR_FALSE);
64109:         return rv;
64109:       }
24554:     }
23313:     // Check if this is a preserveAspectRatio attribute going away
64109:     if (aName == nsGkAtoms::preserveAspectRatio) {
59470:       SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
23313:         GetPreserveAspectRatio();
23313: 
23313:       if (preserveAspectRatio) {
23313:         preserveAspectRatio->Init();
23313:         DidChangePreserveAspectRatio(PR_FALSE);
64109:         return rv;
23313:       }
23313:     }
64109:     // Check if this is a class attribute going away
64109:     if (aName == nsGkAtoms::_class) {
64109:       nsSVGClass *svgClass = GetClass();
64109: 
64109:       if (svgClass) {
64109:         svgClass->Init();
64109:         return rv;
64109:       }
 5347:     }
24554:   }
 5729: 
15353:   // Check if this is a string attribute going away
15353:   StringAttributesInfo stringInfo = GetStringInfo();
15353: 
15353:   for (PRUint32 i = 0; i < stringInfo.mStringCount; i++) {
15353:     if (aNamespaceID == stringInfo.mStringInfo[i].mNamespaceID &&
15353:         aName == *stringInfo.mStringInfo[i].mName) {
15353:       stringInfo.Reset(i);
24028:       DidChangeString(i);
64109:       return rv;
15353:     }
15353:   }
15353: 
 5729:   // Now check for one of the old style basetypes going away
 5729:   nsCOMPtr<nsISVGValue> svg_value = GetMappedAttribute(aNamespaceID, aName);
 5729: 
 5729:   if (svg_value) {
23132:     mSuppressNotification = PR_TRUE;
 8288:     ResetOldStyleBaseType(svg_value);
23132:     mSuppressNotification = PR_FALSE;
 8288:   }
 8288: 
38454:   return rv;
 8288: }
 8288: 
 8288: void
 8288: nsSVGElement::ResetOldStyleBaseType(nsISVGValue *svg_value)
 8288: {
 5729:   nsCOMPtr<nsIDOMSVGAnimatedTransformList> tl = do_QueryInterface(svg_value);
 5729:   if (tl) {
 6538:     nsCOMPtr<nsIDOMSVGTransformList> transform;
 6538:     tl->GetBaseVal(getter_AddRefs(transform));
 5729:     transform->Clear();
 5729:   }
 5729: }
    1: 
16389: nsChangeHint
16389: nsSVGElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
16389:                                      PRInt32 aModType) const
16389: {
16389:   nsChangeHint retval =
16389:     nsSVGElementBase::GetAttributeChangeHint(aAttribute, aModType);
16389: 
16389:   if (aAttribute == nsGkAtoms::requiredFeatures ||
16389:       aAttribute == nsGkAtoms::requiredExtensions ||
16389:       aAttribute == nsGkAtoms::systemLanguage) {
16389:     // It would be nice to only reconstruct the frame if the value returned by
16389:     // NS_SVG_PassesConditionalProcessingTests has changed, but we don't know
16389:     // that
16389:     NS_UpdateHint(retval, nsChangeHint_ReconstructFrame);
16389:   }
16389:   return retval;
16389: }
16389: 
    1: PRBool
    1: nsSVGElement::IsNodeOfType(PRUint32 aFlags) const
    1: {
41646:   return !(aFlags & ~(eCONTENT | eSVG));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
    1: {
    1: #ifdef DEBUG
    1: //  printf("nsSVGElement(%p)::WalkContentStyleRules()\n", this);
    1: #endif
    1:   if (!mContentStyleRule)
    1:     UpdateContentStyleRule();
    1: 
35577:   if (mContentStyleRule) {
35577:     mContentStyleRule->RuleMatched();
    1:     aRuleWalker->Forward(mContentStyleRule);
35577:   }
    1: 
39488: #ifdef MOZ_SMIL
39488:   // Update & walk the animated content style rule, to include style from
39488:   // animated mapped attributes.  But first, get nsPresContext to check
39488:   // whether this is a "no-animation restyle". (This should match the check
39488:   // in nsHTMLCSSStyleSheet::RulesMatching(), where we determine whether to
39488:   // apply the SMILOverrideStyle.)
39488:   nsIDocument* doc = GetOwnerDoc();
39488:   NS_ASSERTION(doc, "SVG element without doc");
39488:   if (doc) {
46225:     nsIPresShell* shell = doc->GetShell();
39488:     nsPresContext* context = shell ? shell->GetPresContext() : nsnull;
39488:     if (context && context->IsProcessingRestyles() &&
39488:         !context->IsProcessingAnimationStyleChange()) {
39488:       // Any style changes right now could trigger CSS Transitions. We don't
39488:       // want that to happen from SMIL-animated value of mapped attrs, so
39488:       // ignore animated value for now, and request an animation restyle to
39488:       // get our animated value noticed.
46468:       shell->RestyleForAnimation(this, eRestyle_Self);
39488:     } else {
39488:       // Ok, this is an animation restyle -- go ahead and update/walk the
39488:       // animated content style rule.
63693:       css::StyleRule* animContentStyleRule = GetAnimatedContentStyleRule();
39488:       if (!animContentStyleRule) {
39488:         UpdateAnimatedContentStyleRule();
39488:         animContentStyleRule = GetAnimatedContentStyleRule();
39488:       }
39488:       if (animContentStyleRule) {
39488:         animContentStyleRule->RuleMatched();
39488:         aRuleWalker->Forward(animContentStyleRule);
39488:       }
39488:     }
39488:   }
39488: #endif // MOZ_SMIL
39488: 
    1:   return NS_OK;
    1: }
    1: 
    1: // PresentationAttributes-FillStroke
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFillStrokeMap[] = {
    1:   { &nsGkAtoms::fill },
    1:   { &nsGkAtoms::fill_opacity },
    1:   { &nsGkAtoms::fill_rule },
    1:   { &nsGkAtoms::stroke },
    1:   { &nsGkAtoms::stroke_dasharray },
    1:   { &nsGkAtoms::stroke_dashoffset },
    1:   { &nsGkAtoms::stroke_linecap },
    1:   { &nsGkAtoms::stroke_linejoin },
    1:   { &nsGkAtoms::stroke_miterlimit },
    1:   { &nsGkAtoms::stroke_opacity },
    1:   { &nsGkAtoms::stroke_width },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Graphics
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sGraphicsMap[] = {
    1:   { &nsGkAtoms::clip_path },
    1:   { &nsGkAtoms::clip_rule },
    1:   { &nsGkAtoms::colorInterpolation },
    1:   { &nsGkAtoms::cursor },
    1:   { &nsGkAtoms::display },
    1:   { &nsGkAtoms::filter },
    1:   { &nsGkAtoms::image_rendering },
    1:   { &nsGkAtoms::mask },
    1:   { &nsGkAtoms::opacity },
    1:   { &nsGkAtoms::pointer_events },
    1:   { &nsGkAtoms::shape_rendering },
    1:   { &nsGkAtoms::text_rendering },
    1:   { &nsGkAtoms::visibility },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-TextContentElements
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sTextContentElementsMap[] = {
    1:   { &nsGkAtoms::alignment_baseline },
    1:   { &nsGkAtoms::baseline_shift },
    1:   { &nsGkAtoms::direction },
    1:   { &nsGkAtoms::dominant_baseline },
    1:   { &nsGkAtoms::glyph_orientation_horizontal },
    1:   { &nsGkAtoms::glyph_orientation_vertical },
    1:   { &nsGkAtoms::kerning },
    1:   { &nsGkAtoms::letter_spacing },
    1:   { &nsGkAtoms::text_anchor },
    1:   { &nsGkAtoms::text_decoration },
    1:   { &nsGkAtoms::unicode_bidi },
    1:   { &nsGkAtoms::word_spacing },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-FontSpecification
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFontSpecificationMap[] = {
    1:   { &nsGkAtoms::font_family },
    1:   { &nsGkAtoms::font_size },
    1:   { &nsGkAtoms::font_size_adjust },
    1:   { &nsGkAtoms::font_stretch },
    1:   { &nsGkAtoms::font_style },
    1:   { &nsGkAtoms::font_variant },
    1:   { &nsGkAtoms::fontWeight },  
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-GradientStop
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sGradientStopMap[] = {
    1:   { &nsGkAtoms::stop_color },
    1:   { &nsGkAtoms::stop_opacity },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Viewports
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sViewportsMap[] = {
    1:   { &nsGkAtoms::overflow },
    1:   { &nsGkAtoms::clip },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Makers
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sMarkersMap[] = {
    1:   { &nsGkAtoms::marker_end },
    1:   { &nsGkAtoms::marker_mid },
    1:   { &nsGkAtoms::marker_start },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Color
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sColorMap[] = {
    1:   { &nsGkAtoms::color },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Filters
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFiltersMap[] = {
    1:   { &nsGkAtoms::colorInterpolationFilters },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-feFlood
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFEFloodMap[] = {
    1:   { &nsGkAtoms::flood_color },
    1:   { &nsGkAtoms::flood_opacity },
    1:   { nsnull }
    1: };
    1: 
 4029: // PresentationAttributes-LightingEffects
 4029: /* static */ const nsGenericElement::MappedAttributeEntry
 4029: nsSVGElement::sLightingEffectsMap[] = {
 4029:   { &nsGkAtoms::lighting_color },
 4029:   { nsnull }
 4029: };
 4029: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMNode methods
    1: 
    1: NS_IMETHODIMP
    1: nsSVGElement::IsSupported(const nsAString& aFeature, const nsAString& aVersion, PRBool* aReturn)
    1: {
33633:   return nsGenericElement::IsSupported(aFeature, aVersion, aReturn); 
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMElement methods
    1: 
    1: // forwarded to nsGenericElement implementations
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMSVGElement methods
    1: 
    1: /* attribute DOMString id; */
    1: NS_IMETHODIMP nsSVGElement::GetId(nsAString & aId)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::id, aId);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSVGElement::SetId(const nsAString & aId)
    1: {
    1:   return SetAttr(kNameSpaceID_None, nsGkAtoms::id, aId, PR_TRUE);
    1: }
    1: 
    1: /* readonly attribute nsIDOMSVGSVGElement ownerSVGElement; */
    1: NS_IMETHODIMP
    1: nsSVGElement::GetOwnerSVGElement(nsIDOMSVGSVGElement * *aOwnerSVGElement)
    1: {
64140:   NS_IF_ADDREF(*aOwnerSVGElement = GetCtx());
    1: 
64140:   if (*aOwnerSVGElement || Tag() == nsGkAtoms::svg) {
64140:     // If we found something or we're the outermost SVG element, that's OK.
10072:     return NS_OK;
10072:   }
64140:   // Otherwise, we've got an invalid structure
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* readonly attribute nsIDOMSVGElement viewportElement; */
    1: NS_IMETHODIMP
    1: nsSVGElement::GetViewportElement(nsIDOMSVGElement * *aViewportElement)
    1: {
30596:   *aViewportElement = nsSVGUtils::GetNearestViewportElement(this).get();
30596:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISVGValueObserver methods:
38453: nsSVGElement::ObservableModificationData
38453: nsSVGElement::GetModificationDataForObservable(nsISVGValue* aObservable,
    1:                                                nsISVGValue::modificationType aModType)
    1: {
    1:   // Return without setting DOM attributes as markup attributes if the
    1:   // attribute's element is being inserted into an SVG document fragment,
    1:   // which provides a context which percentage lengths are relative to.
    1:   // Bug 274886
    1:   if (aModType == nsISVGValue::mod_context)
38453:     return ObservableModificationData(nsnull, 0);
    1: 
    1:   // Return without setting DOM attribute 
    1:   if (mSuppressNotification)
38453:     return ObservableModificationData(nsnull, 0);
    1: 
    1:   PRUint32 i, count = mMappedAttributes.AttrCount();
    1:   const nsAttrValue* attrValue = nsnull;
    1:   for (i = 0; i < count; ++i) {
    1:     attrValue = mMappedAttributes.AttrAt(i);
    1:     if (attrValue->GetSVGValue() == aObservable) {
    1:       break;
    1:     }
    1:   }
    1: 
    1:   if (i == count) {
    1:     NS_NOTREACHED("unknown nsISVGValue");
    1: 
38453:     return ObservableModificationData(nsnull, 1);
    1:   }
    1:   
    1:   const nsAttrName* attrName = mMappedAttributes.AttrNameAt(i);
38453:   PRBool modification = !!mAttrsAndChildren.GetAttr(attrName->LocalName(),
38453:                                                     attrName->NamespaceID());
38453: 
38453:   PRUint8 modType = modification ?
38453:     static_cast<PRUint8>(nsIDOMMutationEvent::MODIFICATION) :
38453:     static_cast<PRUint8>(nsIDOMMutationEvent::ADDITION);
38453: 
38453:   return ObservableModificationData(attrName, modType);
38453: }
38453: 
38453: 
38453: NS_IMETHODIMP
38453: nsSVGElement::WillModifySVGObservable(nsISVGValue* aObservable,
38453:                                       nsISVGValue::modificationType aModType)
38453: {
38453:   ObservableModificationData data =
38453:     GetModificationDataForObservable(aObservable, aModType);
38453:   const nsAttrName* attrName = data.name;
38453:   if (!attrName) {
38453:     return data.modType ? NS_ERROR_UNEXPECTED : NS_OK;
38453:   }
38453: 
38453:   nsNodeUtils::AttributeWillChange(this, attrName->NamespaceID(),
38453:                                    attrName->LocalName(), data.modType);
38453:   return NS_OK;
38453: }
38453: 
38453: 
38453: NS_IMETHODIMP
38453: nsSVGElement::DidModifySVGObservable(nsISVGValue* aObservable,
38453:                                      nsISVGValue::modificationType aModType)
38453: {
38453:   ObservableModificationData data =
38453:     GetModificationDataForObservable(aObservable, aModType);
38453:   const nsAttrName* attrName = data.name;
38453:   if (!attrName) {
38453:     return data.modType ? NS_ERROR_UNEXPECTED : NS_OK;
38453:   }
38453: 
    1:   PRBool hasListeners =
    1:     nsContentUtils::HasMutationListeners(this,
 3137:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
 3137:                                          this);
    1: 
    1: 
    1:   nsAttrValue newValue(aObservable);
    1:   return SetAttrAndNotify(attrName->NamespaceID(), attrName->LocalName(),
    1:                           attrName->GetPrefix(), EmptyString(), newValue,
38453:                           data.modType, hasListeners, PR_TRUE, nsnull);
    1: }
    1: 
39487: //------------------------------------------------------------------------
39487: // Helper class: MappedAttrParser, for parsing values of mapped attributes
47936: 
47936: namespace {
47936: 
39487: class MappedAttrParser {
39487: public:
47936:   MappedAttrParser(css::Loader* aLoader,
39487:                    nsIURI* aDocURI,
39487:                    already_AddRefed<nsIURI> aBaseURI,
39487:                    nsIPrincipal* aNodePrincipal);
39487:   ~MappedAttrParser();
39487: 
39487:   // Parses a mapped attribute value.
39487:   void ParseMappedAttrValue(nsIAtom* aMappedAttrName,
39487:                             nsAString& aMappedAttrValue);
39487: 
39487:   // If we've parsed any values for mapped attributes, this method returns
63693:   // a new already_AddRefed css::StyleRule that incorporates the parsed
39487:   // values. Otherwise, this method returns null.
63693:   already_AddRefed<css::StyleRule> CreateStyleRule();
39487: 
39487: private:
39487:   // MEMBER DATA
39487:   // -----------
39487:   nsCSSParser       mParser;
39487: 
39487:   // Arguments for nsCSSParser::ParseProperty
39487:   nsIURI*           mDocURI;
39487:   nsCOMPtr<nsIURI>  mBaseURI;
39487:   nsIPrincipal*     mNodePrincipal;
39487: 
39487:   // Declaration for storing parsed values (lazily initialized)
47936:   css::Declaration* mDecl;
39487: };
39487: 
47936: MappedAttrParser::MappedAttrParser(css::Loader* aLoader,
39487:                                    nsIURI* aDocURI,
39487:                                    already_AddRefed<nsIURI> aBaseURI,
39487:                                    nsIPrincipal* aNodePrincipal)
39487:   : mParser(aLoader), mDocURI(aDocURI), mBaseURI(aBaseURI),
39487:     mNodePrincipal(aNodePrincipal), mDecl(nsnull)
39487: {
39487:   // SVG and CSS differ slightly in their interpretation of some of
39487:   // the attributes.  SVG allows attributes of the form: font-size="5"
39487:   // (style="font-size: 5" if using a style attribute)
39487:   // where CSS requires units: font-size="5pt" (style="font-size: 5pt")
39487:   // Set a flag to pass information to the parser so that we can use
39487:   // the CSS parser to parse the font-size attribute.  Note that this
39487:   // does *not* affect the use of CSS stylesheets, which will still
39487:   // require units.
39487:   mParser.SetSVGMode(PR_TRUE);
39487: }
39487: 
39487: MappedAttrParser::~MappedAttrParser()
39487: {
39487:   NS_ABORT_IF_FALSE(!mDecl,
39487:                     "If mDecl was initialized, it should have been converted "
39487:                     "into a style rule (and had its pointer cleared)");
39487: }
39487: 
39487: void
39487: MappedAttrParser::ParseMappedAttrValue(nsIAtom* aMappedAttrName,
39487:                                        nsAString& aMappedAttrValue)
39487: {
39487:   if (!mDecl) {
47936:     mDecl = new css::Declaration();
39487:     mDecl->InitializeEmpty();
39487:   }
39487: 
39487:   // Get the nsCSSProperty ID for our mapped attribute.
39487:   nsCSSProperty propertyID =
52031:     nsCSSProps::LookupProperty(nsDependentAtomString(aMappedAttrName));
39487:   PRBool changed; // outparam for ParseProperty. (ignored)
39487:   mParser.ParseProperty(propertyID, aMappedAttrValue, mDocURI, mBaseURI,
40135:                         mNodePrincipal, mDecl, &changed, PR_FALSE);
39487: }
39487: 
63693: already_AddRefed<css::StyleRule>
39487: MappedAttrParser::CreateStyleRule()
39487: {
39487:   if (!mDecl) {
39487:     return nsnull; // No mapped attributes were parsed
39487:   }
39487: 
64685:   nsRefPtr<css::StyleRule> rule = new css::StyleRule(nsnull, mDecl);
39487:   mDecl = nsnull; // We no longer own the declaration -- drop our pointer to it
39487:   return rule.forget();
39487: }
39487: 
47936: } // anonymous namespace
47936: 
    1: //----------------------------------------------------------------------
    1: // Implementation Helpers:
    1: 
    1: PRBool
    1: nsSVGElement::IsEventName(nsIAtom* aName)
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsSVGElement::UpdateContentStyleRule()
    1: {
    1:   NS_ASSERTION(!mContentStyleRule, "we already have a content style rule");
    1: 
38849:   PRUint32 attrCount = mAttrsAndChildren.AttrCount();
38849:   if (!attrCount) {
38849:     // nothing to do
38849:     return;
38849:   }
38849: 
    1:   nsIDocument* doc = GetOwnerDoc();
    1:   if (!doc) {
    1:     NS_ERROR("SVG element without owner document");
    1:     return;
    1:   }
    1: 
39487:   MappedAttrParser mappedAttrParser(doc->CSSLoader(), doc->GetDocumentURI(),
39487:                                     GetBaseURI(), NodePrincipal());
38849: 
38849:   for (PRUint32 i = 0; i < attrCount; ++i) {
38849:     const nsAttrName* attrName = mAttrsAndChildren.AttrNameAt(i);
38849:     if (!attrName->IsAtom() || !IsAttributeMapped(attrName->Atom()))
38849:       continue;
38849: 
    1:     nsAutoString value;
    1:     mAttrsAndChildren.AttrAt(i)->ToString(value);
39487:     mappedAttrParser.ParseMappedAttrValue(attrName->Atom(), value);
    1:   }
39487:   mContentStyleRule = mappedAttrParser.CreateStyleRule();
    1: }
    1: 
39488: #ifdef MOZ_SMIL
39488: static void
39488: ParseMappedAttrAnimValueCallback(void*    aObject,
39488:                                  nsIAtom* aPropertyName,
39488:                                  void*    aPropertyValue,
39488:                                  void*    aData)
39488: {
39488:   NS_ABORT_IF_FALSE(aPropertyName != SMIL_MAPPED_ATTR_STYLERULE_ATOM,
39488:                     "animated content style rule should have been removed "
39488:                     "from properties table already (we're rebuilding it now)");
39488: 
39488:   MappedAttrParser* mappedAttrParser =
39488:     static_cast<MappedAttrParser*>(aData);
39488: 
39488:   nsStringBuffer* valueBuf = static_cast<nsStringBuffer*>(aPropertyValue);
39488:   nsAutoString value;
39488:   PRUint32 len = NS_strlen(static_cast<PRUnichar*>(valueBuf->Data()));
39488:   valueBuf->ToString(len, value);
39488: 
39488:   mappedAttrParser->ParseMappedAttrValue(aPropertyName, value);
39488: }
39488: 
39488: // Callback for freeing animated content style rule, in property table.
39488: static void
39488: ReleaseStyleRule(void*    aObject,       /* unused */
39488:                  nsIAtom* aPropertyName,
39488:                  void*    aPropertyValue,
39488:                  void*    aData          /* unused */)
39488: {
39488:   NS_ABORT_IF_FALSE(aPropertyName == SMIL_MAPPED_ATTR_STYLERULE_ATOM,
39488:                     "unexpected property name, for "
39488:                     "animated content style rule");
63693:   css::StyleRule* styleRule = static_cast<css::StyleRule*>(aPropertyValue);
39488:   NS_ABORT_IF_FALSE(styleRule, "unexpected null style rule");
39488:   styleRule->Release();
39488: }
39488: 
39488: void
39488: nsSVGElement::UpdateAnimatedContentStyleRule()
39488: {
39488:   NS_ABORT_IF_FALSE(!GetAnimatedContentStyleRule(),
39488:                     "Animated content style rule already set");
39488: 
39488:   nsIDocument* doc = GetOwnerDoc();
39488:   if (!doc) {
39488:     NS_ERROR("SVG element without owner document");
39488:     return;
39488:   }
39488: 
39488:   MappedAttrParser mappedAttrParser(doc->CSSLoader(), doc->GetDocumentURI(),
39488:                                     GetBaseURI(), NodePrincipal());
41182:   doc->PropertyTable(SMIL_MAPPED_ATTR_ANIMVAL)->
41182:     Enumerate(this, ParseMappedAttrAnimValueCallback, &mappedAttrParser);
39488:  
63693:   nsRefPtr<css::StyleRule>
39488:     animContentStyleRule(mappedAttrParser.CreateStyleRule());
39488: 
39488:   if (animContentStyleRule) {
58643: #ifdef DEBUG
58643:     nsresult rv =
58643: #endif
58643:       SetProperty(SMIL_MAPPED_ATTR_ANIMVAL,
39488:                   SMIL_MAPPED_ATTR_STYLERULE_ATOM,
58643:                   animContentStyleRule.get(),
58643:                   ReleaseStyleRule);
39488:     animContentStyleRule.forget();
39488:     NS_ABORT_IF_FALSE(rv == NS_OK,
39488:                       "SetProperty failed (or overwrote something)");
39488:   }
39488: }
39488: 
63693: css::StyleRule*
39488: nsSVGElement::GetAnimatedContentStyleRule()
39488: {
39488:   return
63693:     static_cast<css::StyleRule*>(GetProperty(SMIL_MAPPED_ATTR_ANIMVAL,
39488:                                              SMIL_MAPPED_ATTR_STYLERULE_ATOM,
39488:                                              nsnull));
39488: }
39488: #endif // MOZ_SMIL
39488: 
    1: nsISVGValue*
    1: nsSVGElement::GetMappedAttribute(PRInt32 aNamespaceID, nsIAtom* aName)
    1: {
    1:   const nsAttrValue* attrVal = mMappedAttributes.GetAttr(aName, aNamespaceID);
    1:   if (!attrVal)
    1:     return nsnull;
    1: 
    1:   return attrVal->GetSVGValue();
    1: }
    1: 
    1: nsresult
    1: nsSVGElement::AddMappedSVGValue(nsIAtom* aName, nsISupports* aValue,
    1:                                 PRInt32 aNamespaceID)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsISVGValue> svg_value = do_QueryInterface(aValue);
    1:   svg_value->AddObserver(this);
    1:   nsAttrValue attrVal(svg_value);
    1: 
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     rv = mMappedAttributes.SetAndTakeAttr(aName, attrVal);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   else {
    1:     nsCOMPtr<nsINodeInfo> ni;
19197:     ni = mNodeInfo->NodeInfoManager()->GetNodeInfo(aName, nsnull,
19197:                                                    aNamespaceID);
19747:     NS_ENSURE_TRUE(ni, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     rv = mMappedAttributes.SetAndTakeAttr(ni, attrVal);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsIAtom* nsSVGElement::GetEventNameForAttr(nsIAtom* aAttr)
    1: {
    1:   if (aAttr == nsGkAtoms::onload)
    1:     return nsGkAtoms::onSVGLoad;
    1:   if (aAttr == nsGkAtoms::onunload)
    1:     return nsGkAtoms::onSVGUnload;
    1:   if (aAttr == nsGkAtoms::onabort)
    1:     return nsGkAtoms::onSVGAbort;
    1:   if (aAttr == nsGkAtoms::onerror)
    1:     return nsGkAtoms::onSVGError;
    1:   if (aAttr == nsGkAtoms::onresize)
    1:     return nsGkAtoms::onSVGResize;
    1:   if (aAttr == nsGkAtoms::onscroll)
    1:     return nsGkAtoms::onSVGScroll;
    1:   if (aAttr == nsGkAtoms::onzoom)
    1:     return nsGkAtoms::onSVGZoom;
48450: #ifdef MOZ_SMIL
48450:   if (aAttr == nsGkAtoms::onbegin)
48450:     return nsGkAtoms::onbeginEvent;
48450:   if (aAttr == nsGkAtoms::onrepeat)
48450:     return nsGkAtoms::onrepeatEvent;
48450:   if (aAttr == nsGkAtoms::onend)
48450:     return nsGkAtoms::onendEvent;
48450: #endif // MOZ_SMIL
    1: 
    1:   return aAttr;
    1: }
    1: 
    1: nsSVGSVGElement *
    1: nsSVGElement::GetCtx()
    1: {
67658:   nsIContent* ancestor = GetFlattenedTreeParent();
64140: 
64140:   while (ancestor && ancestor->GetNameSpaceID() == kNameSpaceID_SVG) {
64140:     nsIAtom* tag = ancestor->Tag();
64140:     if (tag == nsGkAtoms::foreignObject) {
64140:       return nsnull;
64140:     }
64140:     if (tag == nsGkAtoms::svg) {
64140:       return static_cast<nsSVGSVGElement*>(ancestor);
64140:     }
67658:     ancestor = ancestor->GetFlattenedTreeParent();
64140:   }
64140: 
64140:   // we don't have an ancestor <svg> element...
64140:   return nsnull;
    1: }
    1: 
27899: /* virtual */ gfxMatrix
27899: nsSVGElement::PrependLocalTransformTo(const gfxMatrix &aMatrix)
27899: {
27899:   return aMatrix;
27899: }
27899: 
    1: nsSVGElement::LengthAttributesInfo
    1: nsSVGElement::GetLengthInfo()
    1: {
    1:   return LengthAttributesInfo(nsnull, nsnull, 0);
    1: }
    1: 
 8288: void nsSVGElement::LengthAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mLengths[aAttrEnum].Init(mLengthInfo[aAttrEnum].mCtxType,
 8288:                            aAttrEnum,
 8288:                            mLengthInfo[aAttrEnum].mDefaultValue,
 8288:                            mLengthInfo[aAttrEnum].mDefaultUnitType);
 8288: }
 8288: 
    1: void
    1: nsSVGElement::DidChangeLength(PRUint8 aAttrEnum, PRBool aDoSetAttr)
    1: {
    1:   if (!aDoSetAttr)
    1:     return;
    1: 
    1:   LengthAttributesInfo info = GetLengthInfo();
    1: 
    1:   NS_ASSERTION(info.mLengthCount > 0,
    1:                "DidChangeLength on element with no length attribs");
    1: 
    1:   NS_ASSERTION(aAttrEnum < info.mLengthCount, "aAttrEnum out of range");
    1: 
61741:   nsAutoString serializedValue;
61741:   info.mLengths[aAttrEnum].GetBaseValueString(serializedValue);
    1: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, *info.mLengthInfo[aAttrEnum].mName, nsnull,
61741:                 attrValue, PR_TRUE);
    1: }
    1: 
    1: void
23697: nsSVGElement::DidAnimateLength(PRUint8 aAttrEnum)
23697: {
23697:   nsIFrame* frame = GetPrimaryFrame();
23697: 
23697:   if (frame) {
23697:     LengthAttributesInfo info = GetLengthInfo();
23697:     frame->AttributeChanged(kNameSpaceID_None,
23697:                             *info.mLengthInfo[aAttrEnum].mName,
23697:                             nsIDOMMutationEvent::MODIFICATION);
23697:   }
23697: }
23697: 
23697: void
    1: nsSVGElement::GetAnimatedLengthValues(float *aFirst, ...)
    1: {
    1:   LengthAttributesInfo info = GetLengthInfo();
    1: 
    1:   NS_ASSERTION(info.mLengthCount > 0,
    1:                "GetAnimatedLengthValues on element with no length attribs");
    1: 
    1:   nsSVGSVGElement *ctx = nsnull;
    1: 
    1:   float *f = aFirst;
    1:   PRUint32 i = 0;
    1: 
    1:   va_list args;
    1:   va_start(args, aFirst);
    1: 
    1:   while (f && i < info.mLengthCount) {
 2755:     PRUint8 type = info.mLengths[i].GetSpecifiedUnitType();
    1:     if (!ctx) {
    1:       if (type != nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER &&
    1:           type != nsIDOMSVGLength::SVG_LENGTHTYPE_PX)
    1:         ctx = GetCtx();
    1:     }
 2755:     if (type == nsIDOMSVGLength::SVG_LENGTHTYPE_EMS ||
 2755:         type == nsIDOMSVGLength::SVG_LENGTHTYPE_EXS)
 2755:       *f = info.mLengths[i++].GetAnimValue(this);
 2755:     else
    1:       *f = info.mLengths[i++].GetAnimValue(ctx);
    1:     f = va_arg(args, float*);
    1:   }
    1: 
    1:   va_end(args);
    1: }
    1: 
47840: nsSVGElement::LengthListAttributesInfo
47840: nsSVGElement::GetLengthListInfo()
47840: {
47840:   return LengthListAttributesInfo(nsnull, nsnull, 0);
47840: }
47840: 
47840: void
47840: nsSVGElement::LengthListAttributesInfo::Reset(PRUint8 aAttrEnum)
47840: {
47840:   mLengthLists[aAttrEnum].ClearBaseValue(aAttrEnum);
47840:   // caller notifies
47840: }
47840: 
47840: void
47840: nsSVGElement::DidChangeLengthList(PRUint8 aAttrEnum, PRBool aDoSetAttr)
47840: {
47840:   if (!aDoSetAttr)
47840:     return;
47840: 
47840:   LengthListAttributesInfo info = GetLengthListInfo();
47840: 
47840:   NS_ASSERTION(info.mLengthListCount > 0,
47840:                "DidChangeLengthList on element with no length list attribs");
47840:   NS_ASSERTION(aAttrEnum < info.mLengthListCount, "aAttrEnum out of range");
47840: 
61741:   nsAutoString serializedValue;
61741:   info.mLengthLists[aAttrEnum].GetBaseValue().GetValueAsString(serializedValue);
47840: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, *info.mLengthListInfo[aAttrEnum].mName,
61741:                 nsnull, attrValue, PR_TRUE);
47840: }
47840: 
47840: void
47840: nsSVGElement::DidAnimateLengthList(PRUint8 aAttrEnum)
47840: {
47840:   nsIFrame* frame = GetPrimaryFrame();
47840: 
47840:   if (frame) {
47840:     LengthListAttributesInfo info = GetLengthListInfo();
47840:     frame->AttributeChanged(kNameSpaceID_None,
47840:                             *info.mLengthListInfo[aAttrEnum].mName,
47840:                             nsIDOMMutationEvent::MODIFICATION);
47840:   }
47840: }
47840: 
47840: void
47840: nsSVGElement::GetAnimatedLengthListValues(SVGUserUnitList *aFirst, ...)
47840: {
47840:   LengthListAttributesInfo info = GetLengthListInfo();
47840: 
47840:   NS_ASSERTION(info.mLengthListCount > 0,
47840:                "GetAnimatedLengthListValues on element with no length list attribs");
47840: 
47840:   SVGUserUnitList *list = aFirst;
47840:   PRUint32 i = 0;
47840: 
47840:   va_list args;
47840:   va_start(args, aFirst);
47840: 
47840:   while (list && i < info.mLengthListCount) {
47840:     list->Init(&(info.mLengthLists[i].GetAnimValue()), this, info.mLengthListInfo[i].mAxis);
47840:     ++i;
47840:     list = va_arg(args, SVGUserUnitList*);
47840:   }
47840: 
47840:   va_end(args);
47840: }
47840: 
47840: SVGAnimatedLengthList*
47840: nsSVGElement::GetAnimatedLengthList(PRUint8 aAttrEnum)
47840: {
47840:   LengthListAttributesInfo info = GetLengthListInfo();
47840:   if (aAttrEnum < info.mLengthListCount) {
47840:     return &(info.mLengthLists[aAttrEnum]);
47840:   }
47840:   NS_NOTREACHED("Bad attrEnum");
47840:   return nsnull;
47840: }
47840: 
57113: 
58554: nsSVGElement::NumberListAttributesInfo
58554: nsSVGElement::GetNumberListInfo()
58554: {
58554:   return NumberListAttributesInfo(nsnull, nsnull, 0);
58554: }
58554: 
58554: void
58554: nsSVGElement::NumberListAttributesInfo::Reset(PRUint8 aAttrEnum)
58554: {
58554:   NS_ABORT_IF_FALSE(aAttrEnum < mNumberListCount, "Bad attr enum");
58554:   mNumberLists[aAttrEnum].ClearBaseValue(aAttrEnum);
58554:   // caller notifies
58554: }
58554: 
58554: void
58554: nsSVGElement::DidChangeNumberList(PRUint8 aAttrEnum, PRBool aDoSetAttr)
58554: {
58554:   if (!aDoSetAttr)
58554:     return;
58554: 
58554:   NumberListAttributesInfo info = GetNumberListInfo();
58554: 
58554:   NS_ABORT_IF_FALSE(info.mNumberListCount > 0,
58554:                     "DidChangeNumberList on element with no number list attribs");
58554:   NS_ABORT_IF_FALSE(aAttrEnum < info.mNumberListCount, "aAttrEnum out of range");
58554: 
61741:   nsAutoString serializedValue;
61741:   info.mNumberLists[aAttrEnum].GetBaseValue().GetValueAsString(serializedValue);
58554: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, *info.mNumberListInfo[aAttrEnum].mName,
61741:                 nsnull, attrValue, PR_TRUE);
58554: }
58554: 
58554: void
58554: nsSVGElement::DidAnimateNumberList(PRUint8 aAttrEnum)
58554: {
58554:   nsIFrame* frame = GetPrimaryFrame();
58554: 
58554:   if (frame) {
58554:     NumberListAttributesInfo info = GetNumberListInfo();
58554:     NS_ABORT_IF_FALSE(aAttrEnum < info.mNumberListCount, "aAttrEnum out of range");
58554: 
58554:     frame->AttributeChanged(kNameSpaceID_None,
58554:                             *info.mNumberListInfo[aAttrEnum].mName,
58554:                             nsIDOMMutationEvent::MODIFICATION);
58554:   }
58554: }
58554: 
58554: SVGAnimatedNumberList*
58554: nsSVGElement::GetAnimatedNumberList(PRUint8 aAttrEnum)
58554: {
58554:   NumberListAttributesInfo info = GetNumberListInfo();
58554:   if (aAttrEnum < info.mNumberListCount) {
58554:     return &(info.mNumberLists[aAttrEnum]);
58554:   }
58554:   NS_ABORT_IF_FALSE(PR_FALSE, "Bad attrEnum");
58554:   return nsnull;
58554: }
58554: 
58554: SVGAnimatedNumberList*
58554: nsSVGElement::GetAnimatedNumberList(nsIAtom *aAttrName)
58554: {
58554:   NumberListAttributesInfo info = GetNumberListInfo();
58554:   for (PRUint32 i = 0; i < info.mNumberListCount; i++) {
58554:     if (aAttrName == *info.mNumberListInfo[i].mName) {
58554:       return &info.mNumberLists[i];
58554:     }
58554:   }
58554:   NS_ABORT_IF_FALSE(PR_FALSE, "Bad caller");
58554:   return nsnull;
58554: }
58554: 
57113: void
58893: nsSVGElement::DidChangePointList(PRBool aDoSetAttr)
58893: {
58893:   NS_ABORT_IF_FALSE(GetPointListAttrName(), "Changing non-existent point list?");
58893: 
58893:   if (!aDoSetAttr)
58893:     return;
58893: 
61741:   nsAutoString serializedValue;
61741:   GetAnimatedPointList()->GetBaseValue().GetValueAsString(serializedValue);
58893: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, GetPointListAttrName(), nsnull,
61741:                 attrValue, PR_TRUE);
58893: }
58893: 
58893: void
58893: nsSVGElement::DidAnimatePointList()
58893: {
58893:   NS_ABORT_IF_FALSE(GetPointListAttrName(),
58893:                     "Animating non-existent path data?");
58893: 
58893:   nsIFrame* frame = GetPrimaryFrame();
58893: 
58893:   if (frame) {
58893:     frame->AttributeChanged(kNameSpaceID_None,
58893:                             GetPointListAttrName(),
58893:                             nsIDOMMutationEvent::MODIFICATION);
58893:   }
58893: }
58893: 
58893: void
57113: nsSVGElement::DidChangePathSegList(PRBool aDoSetAttr)
57113: {
57113:   if (!aDoSetAttr)
57113:     return;
57113: 
61740:   nsAutoString serializedValue;
61740:   GetAnimPathSegList()->GetBaseValue().GetValueAsString(serializedValue);
57113: 
61740:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, GetPathDataAttrName(), nsnull,
61741:                 attrValue, PR_TRUE);
57113: }
57113: 
57113: void
57113: nsSVGElement::DidAnimatePathSegList()
57113: {
57113:   NS_ABORT_IF_FALSE(GetPathDataAttrName(),
58893:                     "Animating non-existent path data?");
57113: 
57113:   nsIFrame* frame = GetPrimaryFrame();
57113: 
57113:   if (frame) {
57113:     frame->AttributeChanged(kNameSpaceID_None,
57113:                             GetPathDataAttrName(),
57113:                             nsIDOMMutationEvent::MODIFICATION);
57113:   }
57113: }
57113: 
    1: nsSVGElement::NumberAttributesInfo
    1: nsSVGElement::GetNumberInfo()
    1: {
    1:   return NumberAttributesInfo(nsnull, nsnull, 0);
    1: }
    1: 
 8288: void nsSVGElement::NumberAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mNumbers[aAttrEnum].Init(aAttrEnum,
 8288:                            mNumberInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
    1: void
    1: nsSVGElement::DidChangeNumber(PRUint8 aAttrEnum, PRBool aDoSetAttr)
    1: {
    1:   if (!aDoSetAttr)
    1:     return;
    1: 
    1:   NumberAttributesInfo info = GetNumberInfo();
    1: 
    1:   NS_ASSERTION(info.mNumberCount > 0,
    1:                "DidChangeNumber on element with no number attribs");
    1: 
    1:   NS_ASSERTION(aAttrEnum < info.mNumberCount, "aAttrEnum out of range");
    1: 
61741:   nsAutoString serializedValue;
61741:   info.mNumbers[aAttrEnum].GetBaseValueString(serializedValue);
    1: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, *info.mNumberInfo[aAttrEnum].mName, nsnull,
61741:                 attrValue, PR_TRUE);
    1: }
    1: 
    1: void
37220: nsSVGElement::DidAnimateNumber(PRUint8 aAttrEnum)
37220: {
37220:   nsIFrame* frame = GetPrimaryFrame();
37220: 
37220:   if (frame) {
37220:     NumberAttributesInfo info = GetNumberInfo();
37220:     frame->AttributeChanged(kNameSpaceID_None,
37220:                             *info.mNumberInfo[aAttrEnum].mName,
37220:                             nsIDOMMutationEvent::MODIFICATION);
37220:   }
37220: }
37220: 
37220: void
    1: nsSVGElement::GetAnimatedNumberValues(float *aFirst, ...)
    1: {
    1:   NumberAttributesInfo info = GetNumberInfo();
    1: 
    1:   NS_ASSERTION(info.mNumberCount > 0,
    1:                "GetAnimatedNumberValues on element with no number attribs");
    1: 
    1:   float *f = aFirst;
    1:   PRUint32 i = 0;
    1: 
    1:   va_list args;
    1:   va_start(args, aFirst);
    1: 
    1:   while (f && i < info.mNumberCount) {
38700:     *f = info.mNumbers[i++].GetAnimValue();
    1:     f = va_arg(args, float*);
    1:   }
    1:   va_end(args);
    1: }
    1: 
 6045: nsSVGElement::IntegerAttributesInfo
 6045: nsSVGElement::GetIntegerInfo()
 6045: {
 6045:   return IntegerAttributesInfo(nsnull, nsnull, 0);
 6045: }
 6045: 
 8288: void nsSVGElement::IntegerAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mIntegers[aAttrEnum].Init(aAttrEnum,
 8288:                             mIntegerInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 6045: void
 6045: nsSVGElement::DidChangeInteger(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 6045: {
 6045:   if (!aDoSetAttr)
 6045:     return;
 6045: 
 6045:   IntegerAttributesInfo info = GetIntegerInfo();
 6045: 
 6045:   NS_ASSERTION(info.mIntegerCount > 0,
 6045:                "DidChangeInteger on element with no integer attribs");
 6045: 
 6045:   NS_ASSERTION(aAttrEnum < info.mIntegerCount, "aAttrEnum out of range");
 6045: 
61741:   nsAutoString serializedValue;
61741:   info.mIntegers[aAttrEnum].GetBaseValueString(serializedValue);
 6045: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, *info.mIntegerInfo[aAttrEnum].mName, nsnull,
61741:                 attrValue, PR_TRUE);
 6045: }
 6045: 
 6045: void
38297: nsSVGElement::DidAnimateInteger(PRUint8 aAttrEnum)
38297: {
38297:   nsIFrame* frame = GetPrimaryFrame();
38297:   
38297:   if (frame) {
38297:     IntegerAttributesInfo info = GetIntegerInfo();
38297:     frame->AttributeChanged(kNameSpaceID_None,
38297:                             *info.mIntegerInfo[aAttrEnum].mName,
38297:                             nsIDOMMutationEvent::MODIFICATION);
38297:   }
38297: }
38297: 
38297: void
 6045: nsSVGElement::GetAnimatedIntegerValues(PRInt32 *aFirst, ...)
 6045: {
 6045:   IntegerAttributesInfo info = GetIntegerInfo();
 6045: 
 6045:   NS_ASSERTION(info.mIntegerCount > 0,
 6045:                "GetAnimatedIntegerValues on element with no integer attribs");
 6045: 
 6045:   PRInt32 *n = aFirst;
 6045:   PRUint32 i = 0;
 6045: 
 6045:   va_list args;
 6045:   va_start(args, aFirst);
 6045: 
 6045:   while (n && i < info.mIntegerCount) {
38700:     *n = info.mIntegers[i++].GetAnimValue();
 6045:     n = va_arg(args, PRInt32*);
 6045:   }
 6045:   va_end(args);
 6045: }
 6045: 
 6788: nsSVGElement::AngleAttributesInfo
 6788: nsSVGElement::GetAngleInfo()
 6788: {
 6788:   return AngleAttributesInfo(nsnull, nsnull, 0);
 6788: }
 6788: 
 8288: void nsSVGElement::AngleAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mAngles[aAttrEnum].Init(aAttrEnum, 
 8288:                           mAngleInfo[aAttrEnum].mDefaultValue,
 8288:                           mAngleInfo[aAttrEnum].mDefaultUnitType);
 8288: }
 8288: 
 6788: void
 6788: nsSVGElement::DidChangeAngle(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 6788: {
 6788:   if (!aDoSetAttr)
 6788:     return;
 6788: 
 6788:   AngleAttributesInfo info = GetAngleInfo();
 6788: 
 6788:   NS_ASSERTION(info.mAngleCount > 0,
 6788:                "DidChangeAngle on element with no angle attribs");
 6788: 
 6788:   NS_ASSERTION(aAttrEnum < info.mAngleCount, "aAttrEnum out of range");
 6788: 
61741:   nsAutoString serializedValue;
61741:   info.mAngles[aAttrEnum].GetBaseValueString(serializedValue);
 6788: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, *info.mAngleInfo[aAttrEnum].mName, nsnull,
61741:                 attrValue, PR_TRUE);
 6788: }
 6788: 
38295: void
38295: nsSVGElement::DidAnimateAngle(PRUint8 aAttrEnum)
38295: {
38295:   nsIFrame* frame = GetPrimaryFrame();
38295: 
38295:   if (frame) {
38295:     AngleAttributesInfo info = GetAngleInfo();
38295:     frame->AttributeChanged(kNameSpaceID_None,
38295:                             *info.mAngleInfo[aAttrEnum].mName,
38295:                             nsIDOMMutationEvent::MODIFICATION);
38295:   }
38295: }
38295: 
 6325: nsSVGElement::BooleanAttributesInfo
 6325: nsSVGElement::GetBooleanInfo()
 6325: {
 6325:   return BooleanAttributesInfo(nsnull, nsnull, 0);
 6325: }
 6325: 
 8288: void nsSVGElement::BooleanAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mBooleans[aAttrEnum].Init(aAttrEnum,
 8288:                             mBooleanInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 6325: void
 6325: nsSVGElement::DidChangeBoolean(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 6325: {
 6325:   if (!aDoSetAttr)
 6325:     return;
 6325: 
 6325:   BooleanAttributesInfo info = GetBooleanInfo();
 6325: 
 6325:   NS_ASSERTION(info.mBooleanCount > 0,
 6788:                "DidChangeBoolean on element with no boolean attribs");
 6325: 
 6325:   NS_ASSERTION(aAttrEnum < info.mBooleanCount, "aAttrEnum out of range");
 6325: 
61741:   nsAutoString serializedValue;
61741:   info.mBooleans[aAttrEnum].GetBaseValueString(serializedValue);
 6325: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, *info.mBooleanInfo[aAttrEnum].mName, nsnull,
61741:                 attrValue, PR_TRUE);
 6325: }
 6325: 
37456: void
37456: nsSVGElement::DidAnimateBoolean(PRUint8 aAttrEnum)
37456: {
37456:   nsIFrame* frame = GetPrimaryFrame();
37456:   
37456:   if (frame) {
37456:     BooleanAttributesInfo info = GetBooleanInfo();
37456:     frame->AttributeChanged(kNameSpaceID_None,
37456:                             *info.mBooleanInfo[aAttrEnum].mName,
37456:                             nsIDOMMutationEvent::MODIFICATION);
37456:   }
37456: }
37456: 
 5347: nsSVGElement::EnumAttributesInfo
 5347: nsSVGElement::GetEnumInfo()
 5347: {
 5347:   return EnumAttributesInfo(nsnull, nsnull, 0);
 5347: }
 5347: 
 8288: void nsSVGElement::EnumAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mEnums[aAttrEnum].Init(aAttrEnum,
 8288:                          mEnumInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 5347: void
 5347: nsSVGElement::DidChangeEnum(PRUint8 aAttrEnum, PRBool aDoSetAttr)
 5347: {
 5347:   if (!aDoSetAttr)
 5347:     return;
 5347: 
 5347:   EnumAttributesInfo info = GetEnumInfo();
 5347: 
 5347:   NS_ASSERTION(info.mEnumCount > 0,
 6045:                "DidChangeEnum on element with no enum attribs");
 5347: 
 5347:   NS_ASSERTION(aAttrEnum < info.mEnumCount, "aAttrEnum out of range");
 5347: 
61741:   nsAutoString serializedValue;
61741:   info.mEnums[aAttrEnum].GetBaseValueString(serializedValue, this);
 5347: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, *info.mEnumInfo[aAttrEnum].mName, nsnull,
61741:                 attrValue, PR_TRUE);
 5347: }
 5347: 
37442: void
37442: nsSVGElement::DidAnimateEnum(PRUint8 aAttrEnum)
37442: {
37442:   nsIFrame* frame = GetPrimaryFrame();
37442: 
37442:   if (frame) {
37442:     EnumAttributesInfo info = GetEnumInfo();
37442:     frame->AttributeChanged(kNameSpaceID_None,
37442:                             *info.mEnumInfo[aAttrEnum].mName,
37442:                             nsIDOMMutationEvent::MODIFICATION);
37442:   }
37442: }
37442: 
24554: nsSVGViewBox *
24554: nsSVGElement::GetViewBox()
24554: {
24554:   return nsnull;
24554: }
24554: 
24554: void
24554: nsSVGElement::DidChangeViewBox(PRBool aDoSetAttr)
24554: {
24554:   if (!aDoSetAttr)
24554:     return;
24554: 
24554:   nsSVGViewBox *viewBox = GetViewBox();
24554: 
24554:   NS_ASSERTION(viewBox, "DidChangeViewBox on element with no viewBox attrib");
24554: 
61741:   nsAutoString serializedValue;
61741:   viewBox->GetBaseValueString(serializedValue);
24554: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, nsGkAtoms::viewBox, nsnull,
61741:                 attrValue, PR_TRUE);
24554: }
24554: 
38296: void
38296: nsSVGElement::DidAnimateViewBox()
38296: {
38296:   nsIFrame* frame = GetPrimaryFrame();
38296:   
38296:   if (frame) {
38296:     frame->AttributeChanged(kNameSpaceID_None,
38296:                             nsGkAtoms::viewBox,
38296:                             nsIDOMMutationEvent::MODIFICATION);
38296:   }
38296: }
38296: 
59470: SVGAnimatedPreserveAspectRatio *
23313: nsSVGElement::GetPreserveAspectRatio()
23313: {
23313:   return nsnull;
23313: }
23313: 
23313: void
23313: nsSVGElement::DidChangePreserveAspectRatio(PRBool aDoSetAttr)
23313: {
23313:   if (!aDoSetAttr)
23313:     return;
23313: 
59470:   SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
59470:     GetPreserveAspectRatio();
23313: 
23313:   NS_ASSERTION(preserveAspectRatio,
23313:                "DidChangePreserveAspectRatio on element with no preserveAspectRatio attrib");
23313: 
61741:   nsAutoString serializedValue;
61741:   preserveAspectRatio->GetBaseValueString(serializedValue);
23313: 
61741:   nsAttrValue attrValue(serializedValue);
61741:   SetParsedAttr(kNameSpaceID_None, nsGkAtoms::preserveAspectRatio, nsnull,
61741:                 attrValue, PR_TRUE);
23313: }
23313: 
37974: void
37974: nsSVGElement::DidAnimatePreserveAspectRatio()
37974: {
37974:   nsIFrame* frame = GetPrimaryFrame();
37974:   
37974:   if (frame) {
37974:     frame->AttributeChanged(kNameSpaceID_None,
37974:                             nsGkAtoms::preserveAspectRatio,
37974:                             nsIDOMMutationEvent::MODIFICATION);
37974:   }
37974: }
37974: 
38843: void
38843: nsSVGElement::DidAnimateTransform()
38843: {
38843:   nsIFrame* frame = GetPrimaryFrame();
38843:   
38843:   if (frame) {
38843:     frame->AttributeChanged(kNameSpaceID_None,
38843:                             nsGkAtoms::transform,
38843:                             nsIDOMMutationEvent::MODIFICATION);
38843:   }
38843: }
38843: 
15353: nsSVGElement::StringAttributesInfo
15353: nsSVGElement::GetStringInfo()
15353: {
15353:   return StringAttributesInfo(nsnull, nsnull, 0);
15353: }
15353: 
15353: void nsSVGElement::StringAttributesInfo::Reset(PRUint8 aAttrEnum)
15353: {
15353:   mStrings[aAttrEnum].Init(aAttrEnum);
15353: }
15353: 
24028: void nsSVGElement::GetStringBaseValue(PRUint8 aAttrEnum, nsAString& aResult) const
15353: {
24028:   nsSVGElement::StringAttributesInfo info = const_cast<nsSVGElement*>(this)->GetStringInfo();
15353: 
15353:   NS_ASSERTION(info.mStringCount > 0,
24028:                "GetBaseValue on element with no string attribs");
24028: 
24028:   NS_ASSERTION(aAttrEnum < info.mStringCount, "aAttrEnum out of range");
24028: 
24028:   GetAttr(info.mStringInfo[aAttrEnum].mNamespaceID,
24028:           *info.mStringInfo[aAttrEnum].mName, aResult);
24028: }
24028: 
24028: void nsSVGElement::SetStringBaseValue(PRUint8 aAttrEnum, const nsAString& aValue)
24028: {
24028:   nsSVGElement::StringAttributesInfo info = GetStringInfo();
24028: 
24028:   NS_ASSERTION(info.mStringCount > 0,
24028:                "SetBaseValue on element with no string attribs");
15353: 
15353:   NS_ASSERTION(aAttrEnum < info.mStringCount, "aAttrEnum out of range");
15353: 
15353:   SetAttr(info.mStringInfo[aAttrEnum].mNamespaceID,
24028:           *info.mStringInfo[aAttrEnum].mName, aValue, PR_TRUE);
15353: }
15353: 
55139: void
55139: nsSVGElement::DidAnimateString(PRUint8 aAttrEnum)
55139: {
55139:   nsIFrame* frame = GetPrimaryFrame();
55139: 
55139:   if (frame) {
55139:     StringAttributesInfo info = GetStringInfo();
55139:     frame->AttributeChanged(info.mStringInfo[aAttrEnum].mNamespaceID,
55139:                             *info.mStringInfo[aAttrEnum].mName,
55139:                             nsIDOMMutationEvent::MODIFICATION);
55139:   }
55139: }
55139: 
64109: nsSVGClass *
64109: nsSVGElement::GetClass()
64109: {
64109:   return nsnull;
64109: }
64109: 
64109: void
64109: nsSVGElement::DidAnimateClass()
64109: {
64109:   nsIFrame* frame = GetPrimaryFrame();
64109: 
64109:   if (frame) {
64109:     frame->AttributeChanged(kNameSpaceID_None, nsGkAtoms::_class,
64109:                             nsIDOMMutationEvent::MODIFICATION);
64109:   }
64109: }
64109: 
15523: nsresult
15523: nsSVGElement::ParseNumberOptionalNumber(const nsAString& aValue,
15523:                                         PRUint32 aIndex1, PRUint32 aIndex2)
 6944: {
 6944:   NS_ConvertUTF16toUTF8 value(aValue);
 6944:   const char *str = value.get();
 6944: 
15523:   if (NS_IsAsciiWhitespace(*str))
15523:     return NS_ERROR_FAILURE;
 6944: 
 6944:   char *rest;
15523:   float x = float(PR_strtod(str, &rest));
15523:   float y = x;
 6944: 
29309:   if (str == rest || !NS_FloatIsFinite(x)) {
 6944:     //first value was illformed
15523:     return NS_ERROR_FAILURE;
15523:   }
15523:   
15523:   if (*rest != '\0') {
 6944:     while (NS_IsAsciiWhitespace(*rest)) {
 6944:       ++rest;
 6944:     }
 6944:     if (*rest == ',') {
 6944:       ++rest;
 6944:     }
 6944: 
 6944:     y = float(PR_strtod(rest, &rest));
29309:     if (*rest != '\0' || !NS_FloatIsFinite(y)) {
 6944:       //second value was illformed or there was trailing content
15523:       return NS_ERROR_FAILURE;
 6944:     }
 6944:   }
 6944: 
 6944:   NumberAttributesInfo numberInfo = GetNumberInfo();
 6944: 
15523:   numberInfo.mNumbers[aIndex1].SetBaseValue(x, this, PR_FALSE);
15523:   numberInfo.mNumbers[aIndex2].SetBaseValue(y, this, PR_FALSE);
15523:   return NS_OK;
 6944: }
 6944: 
15523: nsresult
15523: nsSVGElement::ParseIntegerOptionalInteger(const nsAString& aValue,
15523:                                           PRUint32 aIndex1, PRUint32 aIndex2)
 6944: {
 6944:   NS_ConvertUTF16toUTF8 value(aValue);
 6944:   const char *str = value.get();
 6944: 
15523:   if (NS_IsAsciiWhitespace(*str))
15523:     return NS_ERROR_FAILURE;
 6944: 
 6944:   char *rest;
15523:   PRInt32 x = strtol(str, &rest, 10);
15523:   PRInt32 y = x;
 6944: 
 6944:   if (str == rest) {
 6944:     //first value was illformed
15523:     return NS_ERROR_FAILURE;
15523:   }
15523:   
15523:   if (*rest != '\0') {
 6944:     while (NS_IsAsciiWhitespace(*rest)) {
 6944:       ++rest;
 6944:     }
 6944:     if (*rest == ',') {
 6944:       ++rest;
 6944:     }
 6944: 
 6944:     y = strtol(rest, &rest, 10);
 6944:     if (*rest != '\0') {
 6944:       //second value was illformed or there was trailing content
15523:       return NS_ERROR_FAILURE;
 6944:     }
 6944:   }
 6944: 
 6944:   IntegerAttributesInfo integerInfo = GetIntegerInfo();
 6944: 
 6944:   integerInfo.mIntegers[aIndex1].SetBaseValue(x, this, PR_FALSE);
 6944:   integerInfo.mIntegers[aIndex2].SetBaseValue(y, this, PR_FALSE);
 6944: 
15523:   return NS_OK;
 6944: }
 6944: 
    1: nsresult
    1: nsSVGElement::ReportAttributeParseFailure(nsIDocument* aDocument,
    1:                                           nsIAtom* aAttribute,
    1:                                           const nsAString& aValue)
    1: {
    1:   const nsAFlatString& attributeValue = PromiseFlatString(aValue);
39101:   const PRUnichar *strings[] = { aAttribute->GetUTF16String(),
39101:                                  attributeValue.get() };
    1:   return nsSVGUtils::ReportToConsole(aDocument,
    1:                                      "AttributeParseWarning",
    1:                                      strings, NS_ARRAY_LENGTH(strings));
    1: }
    1: 
    1: void
    1: nsSVGElement::RecompileScriptEventListeners()
    1: {
    1:   PRInt32 i, count = mAttrsAndChildren.AttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
    1: 
    1:     // Eventlistenener-attributes are always in the null namespace
    1:     if (!name->IsAtom()) {
    1:         continue;
    1:     }
    1: 
    1:     nsIAtom *attr = name->Atom();
    1:     if (!IsEventName(attr)) {
    1:       continue;
    1:     }
    1: 
    1:     nsAutoString value;
    1:     GetAttr(kNameSpaceID_None, attr, value);
    1:     AddScriptEventListener(GetEventNameForAttr(attr), value, PR_TRUE);
    1:   }
    1: }
23697: 
23697: #ifdef MOZ_SMIL
23697: nsISMILAttr*
55139: nsSVGElement::GetAnimatedAttr(PRInt32 aNamespaceID, nsIAtom* aName)
23697: {
55139:   if (aNamespaceID == kNameSpaceID_None) {
23931:     // Transforms:
42893:     nsCOMPtr<nsIDOMSVGAnimatedTransformList> transformList;
23931:     if (aName == nsGkAtoms::transform) {
23931:       nsCOMPtr<nsIDOMSVGTransformable> transformable(
23931:               do_QueryInterface(static_cast<nsIContent*>(this)));
23931:       if (!transformable)
23931:         return nsnull;
23931:       nsresult rv = transformable->GetTransform(getter_AddRefs(transformList));
23931:       NS_ENSURE_SUCCESS(rv, nsnull);
42893:     }
42893:     if (aName == nsGkAtoms::gradientTransform) {
42893:       nsCOMPtr<nsIDOMSVGGradientElement> gradientElement(
42893:               do_QueryInterface(static_cast<nsIContent*>(this)));
47333:       if (!gradientElement)
47333:         return nsnull;
42893: 
42893:       nsresult rv = gradientElement->GetGradientTransform(getter_AddRefs(transformList));
42893:       NS_ENSURE_SUCCESS(rv, nsnull);
42893:     }
42893:     if (aName == nsGkAtoms::patternTransform) {
42893:       nsCOMPtr<nsIDOMSVGPatternElement> patternElement(
42893:               do_QueryInterface(static_cast<nsIContent*>(this)));
47333:       if (!patternElement)
47333:         return nsnull;
42893: 
42893:       nsresult rv = patternElement->GetPatternTransform(getter_AddRefs(transformList));
42893:       NS_ENSURE_SUCCESS(rv, nsnull);
42893:     }
42893:     if (transformList) {
23931:       nsSVGAnimatedTransformList* list
23931:         = static_cast<nsSVGAnimatedTransformList*>(transformList.get());
23931:       NS_ENSURE_TRUE(list, nsnull);
23931: 
38843:       return new nsSVGTransformSMILAttr(list, this);
23931:     }
23931: 
41504:     // Motion (fake 'attribute' for animateMotion)
41504:     if (aName == nsGkAtoms::mozAnimateMotionDummyAttr) {
48193:       return new SVGMotionSMILAttr(this);
41504:     }
41504: 
23697:     // Lengths:
23697:     LengthAttributesInfo info = GetLengthInfo();
23697:     for (PRUint32 i = 0; i < info.mLengthCount; i++) {
23697:       if (aName == *info.mLengthInfo[i].mName) {
23697:         return info.mLengths[i].ToSMILAttr(this);
23697:       }
23697:     }
23697: 
37220:     // Numbers:
37220:     {
37220:       NumberAttributesInfo info = GetNumberInfo();
37220:       for (PRUint32 i = 0; i < info.mNumberCount; i++) {
37220:         // XXX this isn't valid for either of the two properties corresponding to
37220:         // attributes of type <number-optional-number> - see filter,
37220:         // feConvolveMatrix, feDiffuseLighting, feGaussianBlur, feMorphology and
37220:         // feTurbulence.
37220:         // The way to fix this is probably to handle them as 2-item number lists
37220:         // once we implement number list animation, and put the number list loop
37220:         // *above* this one at that time to catch those properties before we get
37220:         // here. The separate properties should then point into the list.
37220:         if (aName == *info.mNumberInfo[i].mName) {
37220:           return info.mNumbers[i].ToSMILAttr(this);
37220:         }
37220:       }
37220:     }
37220: 
38297:     // Integers:
38297:     {
38297:       IntegerAttributesInfo info = GetIntegerInfo();
38297:       for (PRUint32 i = 0; i < info.mIntegerCount; i++) {
38297:         if (aName == *info.mIntegerInfo[i].mName) {
38297:           return info.mIntegers[i].ToSMILAttr(this);
38297:         }
38297:       }
38297:     }
38297: 
37442:     // Enumerations:
37442:     {
37442:       EnumAttributesInfo info = GetEnumInfo();
37442:       for (PRUint32 i = 0; i < info.mEnumCount; i++) {
37442:         if (aName == *info.mEnumInfo[i].mName) {
37442:           return info.mEnums[i].ToSMILAttr(this);
37442:         }
37442:       }
37442:     }
37442: 
37456:     // Booleans:
37456:     {
37456:       BooleanAttributesInfo info = GetBooleanInfo();
37456:       for (PRUint32 i = 0; i < info.mBooleanCount; i++) {
37456:         if (aName == *info.mBooleanInfo[i].mName) {
37456:           return info.mBooleans[i].ToSMILAttr(this);
37456:         }
37456:       }
37456:     }
37456: 
38295:     // Angles:
38295:     {
38295:       AngleAttributesInfo info = GetAngleInfo();
38295:       for (PRUint32 i = 0; i < info.mAngleCount; i++) {
38295:         if (aName == *info.mAngleInfo[i].mName) {
38295:           return info.mAngles[i].ToSMILAttr(this);
38295:         }
38295:       }
38295:     }
38295: 
38296:     // viewBox:
38296:     if (aName == nsGkAtoms::viewBox) {
38296:       nsSVGViewBox *viewBox = GetViewBox();
38296:       return viewBox ? viewBox->ToSMILAttr(this) : nsnull;
38296:     }
38296: 
37974:     // preserveAspectRatio:
37974:     if (aName == nsGkAtoms::preserveAspectRatio) {
59470:       SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
59470:         GetPreserveAspectRatio();
59470:       return preserveAspectRatio ?
59470:         preserveAspectRatio->ToSMILAttr(this) : nsnull;
37974:     }
37974: 
64109:     if (aName == nsGkAtoms::_class) {
64109:       nsSVGClass *svgClass = GetClass();
64109:       return svgClass ? svgClass->ToSMILAttr(this) : nsnull;
64109:     }
64109: 
58554:     // NumberLists:
58554:     {
58554:       NumberListAttributesInfo info = GetNumberListInfo();
58554:       for (PRUint32 i = 0; i < info.mNumberListCount; i++) {
58554:         if (aName == *info.mNumberListInfo[i].mName) {
58554:           NS_ABORT_IF_FALSE(i <= UCHAR_MAX, "Too many attributes");
58554:           return info.mNumberLists[i].ToSMILAttr(this, PRUint8(i));
58554:         }
58554:       }
58554:     }
58554: 
47840:     // LengthLists:
47840:     {
47840:       LengthListAttributesInfo info = GetLengthListInfo();
47840:       for (PRUint32 i = 0; i < info.mLengthListCount; i++) {
47840:         if (aName == *info.mLengthListInfo[i].mName) {
47840:           NS_ABORT_IF_FALSE(i <= UCHAR_MAX, "Too many attributes");
47840:           return info.mLengthLists[i].ToSMILAttr(this,
47840:                                                  PRUint8(i),
47840:                                                  info.mLengthListInfo[i].mAxis,
47840:                                                  info.mLengthListInfo[i].mCouldZeroPadList);
47840:         }
47840:       }
47840:     }
47840: 
58893:     // PointLists:
58893:     {
58893:       if (GetPointListAttrName() == aName) {
58893:         SVGAnimatedPointList *pointList = GetAnimatedPointList();
58893:         if (pointList) {
58893:           return pointList->ToSMILAttr(this);
58893:         }
58893:       }
58893:     }
58893: 
57113:     // PathSegLists:
57113:     {
57113:       if (GetPathDataAttrName() == aName) {
57113:         SVGAnimatedPathSegList *segList = GetAnimPathSegList();
57113:         if (segList) {
57113:           return segList->ToSMILAttr(this);
57113:         }
57113:       }
57113:     }
57113: 
39488:     // Mapped attributes:
39488:     if (IsAttributeMapped(aName)) {
52031:       nsCSSProperty prop =
52031:         nsCSSProps::LookupProperty(nsDependentAtomString(aName));
39488:       // Check IsPropertyAnimatable to avoid attributes that...
39488:       //  - map to explicitly unanimatable properties (e.g. 'direction')
39488:       //  - map to unsupported attributes (e.g. 'glyph-orientation-horizontal')
39488:       if (nsSMILCSSProperty::IsPropertyAnimatable(prop)) {
39488:         return new nsSMILMappedAttribute(prop, this);
39488:       }
39488:     }
64109:   }
64109: 
64109:   // Strings
64109:   {
64109:     StringAttributesInfo info = GetStringInfo();
64109:     for (PRUint32 i = 0; i < info.mStringCount; i++) {
64109:       if (aNamespaceID == info.mStringInfo[i].mNamespaceID &&
64109:           aName == *info.mStringInfo[i].mName) {
64109:         return info.mStrings[i].ToSMILAttr(this);
64109:       }
64109:     }
64109:   }
39488: 
23697:   return nsnull;
23697: }
24029: 
24029: void
24029: nsSVGElement::AnimationNeedsResample()
24029: {
24029:   nsIDocument* doc = GetCurrentDoc();
38869:   if (doc && doc->HasAnimationController()) {
38869:     doc->GetAnimationController()->SetResampleNeeded();
24029:   }
24029: }
24029: 
24029: void
24029: nsSVGElement::FlushAnimations()
24029: {
24029:   nsIDocument* doc = GetCurrentDoc();
38869:   if (doc && doc->HasAnimationController()) {
38869:     doc->GetAnimationController()->FlushResampleRequests();
24029:   }
24029: }
23697: #endif // MOZ_SMIL
