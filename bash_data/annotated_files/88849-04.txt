42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2009
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Bas Schouten <bschouten@mozilla.com>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
42611: #include "LayerManagerD3D9.h"
42611: 
42611: #include "ThebesLayerD3D9.h"
42611: #include "ContainerLayerD3D9.h"
42611: #include "ImageLayerD3D9.h"
42611: #include "ColorLayerD3D9.h"
42611: #include "CanvasLayerD3D9.h"
62701: #include "ReadbackLayerD3D9.h"
52175: #include "gfxWindowsPlatform.h"
54215: #include "nsIGfxInfo.h"
59598: #include "nsServiceManagerUtils.h"
62254: #include "gfxFailure.h"
71640: #include "mozilla/Preferences.h"
54215: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
53980: DeviceManagerD3D9 *LayerManagerD3D9::mDefaultDeviceManager = nsnull;
42611: 
42611: LayerManagerD3D9::LayerManagerD3D9(nsIWidget *aWidget)
60858:   : mWidget(aWidget)
60858:   , mDeviceResetCount(0)
42611: {
42611:   mCurrentCallbackInfo.Callback = NULL;
42611:   mCurrentCallbackInfo.CallbackData = NULL;
42611: }
42611: 
42611: LayerManagerD3D9::~LayerManagerD3D9()
42611: {
53979:   Destroy();
49316: }
42611: 
79445: bool
88849: LayerManagerD3D9::Initialize(bool force)
42611: {
88849:   ScopedGfxFeatureReporter reporter("D3D9 Layers", force);
63285: 
60833:   /* XXX: this preference and blacklist code should move out of the layer manager */
79445:   bool forceAccelerate =
79445:     Preferences::GetBool("layers.acceleration.force-enabled", false);
60324: 
54215:   nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
54215:   if (gfxInfo) {
54215:     PRInt32 status;
54215:     if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS, &status))) {
60324:       if (status != nsIGfxInfo::FEATURE_NO_INFO && !forceAccelerate)
54215:       {
54215:         NS_WARNING("Direct3D 9-accelerated layers are not supported on this system.");
80486:         return false;
54215:       }
54215:     }
54215:   }
54215: 
53980:   if (!mDefaultDeviceManager) {
49316:     mDeviceManager = new DeviceManagerD3D9;
49316: 
49316:     if (!mDeviceManager->Init()) {
49316:       mDeviceManager = nsnull;
80486:       return false;
42611:     }
53980: 
53980:     mDefaultDeviceManager = mDeviceManager;
51996:   } else {
53980:     mDeviceManager = mDefaultDeviceManager;
42611:   }
42611: 
49316:   mSwapChain = mDeviceManager->
49316:     CreateSwapChain((HWND)mWidget->GetNativeData(NS_NATIVE_WINDOW));
42611: 
49316:   if (!mSwapChain) {
80486:     return false;
42611:   }
42611: 
63285:   reporter.SetSuccessful();
80486:   return true;
42611: }
42611: 
42611: void
42611: LayerManagerD3D9::SetClippingRegion(const nsIntRegion &aClippingRegion)
42611: {
42611:   mClippingRegion = aClippingRegion;
42611: }
42611: 
42611: void
53979: LayerManagerD3D9::Destroy()
53979: {
53979:   if (!IsDestroyed()) {
53979:     if (mRoot) {
53979:       static_cast<LayerD3D9*>(mRoot->ImplData())->LayerManagerDestroyed();
53979:     }
53979:     /* Important to release this first since it also holds a reference to the
53979:      * device manager
53979:      */
53979:     mSwapChain = nsnull;
53979:     mDeviceManager = nsnull;
53979:   }
53979:   LayerManager::Destroy();
53979: }
53979: 
53979: void
42611: LayerManagerD3D9::BeginTransaction()
42611: {
42611: }
42611: 
42611: void
42611: LayerManagerD3D9::BeginTransactionWithTarget(gfxContext *aTarget)
42611: {
42611:   mTarget = aTarget;
42611: }
42611: 
42611: void
42611: LayerManagerD3D9::EndConstruction()
42611: {
42611: }
42611: 
60858: bool
60858: LayerManagerD3D9::EndEmptyTransaction()
60858: {
60858:   // If the device reset count from our last EndTransaction doesn't match
60858:   // the current device reset count, the device must have been reset one or
60858:   // more times since our last transaction. In that case, an empty transaction
60858:   // is not possible, because layers may need to be rerendered.
60858:   if (!mRoot || mDeviceResetCount != mDeviceManager->GetDeviceResetCount())
60858:     return false;
60858: 
60858:   EndTransaction(nsnull, nsnull);
60858:   return true;
60858: }
60858: 
59171: void
42611: LayerManagerD3D9::EndTransaction(DrawThebesLayerCallback aCallback,
78887:                                  void* aCallbackData,
78887:                                  EndTransactionFlags aFlags)
42611: {
60858:   mDeviceResetCount = mDeviceManager->GetDeviceResetCount();
60858: 
78887:   if (mRoot && !(aFlags & END_NO_IMMEDIATE_REDRAW)) {
42611:     mCurrentCallbackInfo.Callback = aCallback;
42611:     mCurrentCallbackInfo.CallbackData = aCallbackData;
57097: 
57097:     // The results of our drawing always go directly into a pixel buffer,
57097:     // so we don't need to pass any global transform here.
57097:     mRoot->ComputeEffectiveTransforms(gfx3DMatrix());
57097: 
42611:     Render();
42611:     /* Clean this out for sanity */
42611:     mCurrentCallbackInfo.Callback = NULL;
42611:     mCurrentCallbackInfo.CallbackData = NULL;
62292:   }
62292: 
47365:   // Clear mTarget, next transaction could have no target
47365:   mTarget = NULL;
42611: }
42611: 
42611: void
42611: LayerManagerD3D9::SetRoot(Layer *aLayer)
42611: {
51960:   mRoot = aLayer;
42611: }
42611: 
42611: already_AddRefed<ThebesLayer>
42611: LayerManagerD3D9::CreateThebesLayer()
42611: {
42611:   nsRefPtr<ThebesLayer> layer = new ThebesLayerD3D9(this);
42611:   return layer.forget();
42611: }
42611: 
42611: already_AddRefed<ContainerLayer>
42611: LayerManagerD3D9::CreateContainerLayer()
42611: {
42611:   nsRefPtr<ContainerLayer> layer = new ContainerLayerD3D9(this);
42611:   return layer.forget();
42611: }
42611: 
42611: already_AddRefed<ImageLayer>
42611: LayerManagerD3D9::CreateImageLayer()
42611: {
42611:   nsRefPtr<ImageLayer> layer = new ImageLayerD3D9(this);
42611:   return layer.forget();
42611: }
42611: 
42611: already_AddRefed<ColorLayer>
42611: LayerManagerD3D9::CreateColorLayer()
42611: {
42611:   nsRefPtr<ColorLayer> layer = new ColorLayerD3D9(this);
42611:   return layer.forget();
42611: }
42611: 
42611: already_AddRefed<CanvasLayer>
42611: LayerManagerD3D9::CreateCanvasLayer()
42611: {
42611:   nsRefPtr<CanvasLayer> layer = new CanvasLayerD3D9(this);
42611:   return layer.forget();
42611: }
42611: 
62701: already_AddRefed<ReadbackLayer>
62701: LayerManagerD3D9::CreateReadbackLayer()
62701: {
62701:   nsRefPtr<ReadbackLayer> layer = new ReadbackLayerD3D9(this);
62701:   return layer.forget();
62701: }
62701: 
42611: already_AddRefed<ImageContainer>
42611: LayerManagerD3D9::CreateImageContainer()
42611: {
59719:   nsRefPtr<ImageContainer> container = new ImageContainerD3D9(device());
42611:   return container.forget();
42611: }
42611: 
72995: already_AddRefed<ShadowThebesLayer>
72995: LayerManagerD3D9::CreateShadowThebesLayer()
72995: {
72995:   if (LayerManagerD3D9::mDestroyed) {
72995:     NS_WARNING("Call on destroyed layer manager");
72995:     return nsnull;
72995:   }
72995:   return nsRefPtr<ShadowThebesLayerD3D9>(new ShadowThebesLayerD3D9(this)).forget();
72995: }
72995: 
72995: already_AddRefed<ShadowContainerLayer>
72995: LayerManagerD3D9::CreateShadowContainerLayer()
72995: {
72995:   if (LayerManagerD3D9::mDestroyed) {
72995:     NS_WARNING("Call on destroyed layer manager");
72995:     return nsnull;
72995:   }
72995:   return nsRefPtr<ShadowContainerLayerD3D9>(new ShadowContainerLayerD3D9(this)).forget();
72995: }
72995: 
72995: already_AddRefed<ShadowImageLayer>
72995: LayerManagerD3D9::CreateShadowImageLayer()
72995: {
72995:   if (LayerManagerD3D9::mDestroyed) {
72995:     NS_WARNING("Call on destroyed layer manager");
72995:     return nsnull;
72995:   }
72995:   return nsRefPtr<ShadowImageLayerD3D9>(new ShadowImageLayerD3D9(this)).forget();
72995: }
72995: 
72995: already_AddRefed<ShadowColorLayer>
72995: LayerManagerD3D9::CreateShadowColorLayer()
72995: {
72995:   if (LayerManagerD3D9::mDestroyed) {
72995:     NS_WARNING("Call on destroyed layer manager");
72995:     return nsnull;
72995:   }
72995:   return nsRefPtr<ShadowColorLayerD3D9>(new ShadowColorLayerD3D9(this)).forget();
72995: }
72995: 
72995: already_AddRefed<ShadowCanvasLayer>
72995: LayerManagerD3D9::CreateShadowCanvasLayer()
72995: {
72995:   if (LayerManagerD3D9::mDestroyed) {
72995:     NS_WARNING("Call on destroyed layer manager");
72995:     return nsnull;
72995:   }
72995:   return nsRefPtr<ShadowCanvasLayerD3D9>(new ShadowCanvasLayerD3D9(this)).forget();
72995: }
72995: 
52175: void ReleaseTexture(void *texture)
52175: {
52175:   static_cast<IDirect3DTexture9*>(texture)->Release();
52175: }
52175: 
42611: void
55203: LayerManagerD3D9::ReportFailure(const nsACString &aMsg, HRESULT aCode)
55203: {
55203:   // We could choose to abort here when hr == E_OUTOFMEMORY.
55203:   nsCString msg;
55203:   msg.Append(aMsg);
55203:   msg.AppendLiteral(" Error code: ");
57015:   msg.AppendInt(PRUint32(aCode));
55203:   NS_WARNING(msg.BeginReading());
62254: 
62254:   gfx::LogFailure(msg);
55203: }
55203: 
55203: void
42611: LayerManagerD3D9::Render()
42611: {
49316:   if (!mSwapChain->PrepareForRendering()) {
42611:     return;
42611:   }
49316:   deviceManager()->SetupRenderState();
49316: 
42611:   SetupPipeline();
42611:   nsIntRect rect;
47364:   mWidget->GetClientBounds(rect);
42611: 
49316:   device()->Clear(0, NULL, D3DCLEAR_TARGET, 0x00000000, 0, 0);
42611: 
49316:   device()->BeginScene();
42611: 
51960:   const nsIntRect *clipRect = mRoot->GetClipRect();
42611:   RECT r;
42611:   if (clipRect) {
42611:     r.left = (LONG)clipRect->x;
42611:     r.top = (LONG)clipRect->y;
42611:     r.right = (LONG)(clipRect->x + clipRect->width);
42611:     r.bottom = (LONG)(clipRect->y + clipRect->height);
42611:   } else {
42611:     r.left = r.top = 0;
42611:     r.right = rect.width;
42611:     r.bottom = rect.height;
42611:   }
49316:   device()->SetScissorRect(&r);
42611: 
57097:   static_cast<LayerD3D9*>(mRoot->ImplData())->RenderLayer();
42611: 
49316:   device()->EndScene();
42611: 
42611:   if (!mTarget) {
42611:     const nsIntRect *r;
42611:     for (nsIntRegionRectIterator iter(mClippingRegion);
42611:          (r = iter.Next()) != nsnull;) {
49316:       mSwapChain->Present(*r);
42611:     }
86724:     LayerManager::PostPresent();
42611:   } else {
42611:     PaintToTarget();
42611:   }
42611: }
42611: 
42611: void
42611: LayerManagerD3D9::SetupPipeline()
42611: {
42611:   nsIntRect rect;
47364:   mWidget->GetClientBounds(rect);
42611: 
54880:   gfx3DMatrix viewMatrix;
42611:   /*
42611:    * Matrix to transform to viewport space ( <-1.0, 1.0> topleft,
42611:    * <1.0, -1.0> bottomright)
42611:    */
54880:   viewMatrix._11 = 2.0f / rect.width;
54880:   viewMatrix._22 = -2.0f / rect.height;
74750:   viewMatrix._33 = 0.0f;
54880:   viewMatrix._41 = -1.0f;
54880:   viewMatrix._42 = 1.0f;
42611: 
54880:   HRESULT hr = device()->SetVertexShaderConstantF(CBmProjection,
54880:                                                   &viewMatrix._11, 4);
42611: 
42611:   if (FAILED(hr)) {
42611:     NS_WARNING("Failed to set projection shader constant!");
42611:   }
52176: 
54880:   hr = device()->SetVertexShaderConstantF(CBvTextureCoords,
54880:                                           ShaderConstantRect(0, 0, 1.0f, 1.0f),
54880:                                           1);
52176: 
52176:   if (FAILED(hr)) {
52176:     NS_WARNING("Failed to set texCoords shader constant!");
52176:   }
54881: 
54881:   float offset[] = { 0, 0, 0, 0 };
54881:   hr = device()->SetVertexShaderConstantF(CBvRenderTargetOffset, offset, 1);
54881: 
54881:   if (FAILED(hr)) {
54881:     NS_WARNING("Failed to set RenderTargetOffset shader constant!");
54881:   }
42611: }
42611: 
42611: void
42611: LayerManagerD3D9::PaintToTarget()
42611: {
42611:   nsRefPtr<IDirect3DSurface9> backBuff;
42611:   nsRefPtr<IDirect3DSurface9> destSurf;
51313:   device()->GetRenderTarget(0, getter_AddRefs(backBuff));
42611: 
42611:   D3DSURFACE_DESC desc;
42611:   backBuff->GetDesc(&desc);
42611: 
49316:   device()->CreateOffscreenPlainSurface(desc.Width, desc.Height,
42611:                                        D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM,
42611:                                        getter_AddRefs(destSurf), NULL);
42611: 
49316:   device()->GetRenderTargetData(backBuff, destSurf);
42611: 
42611:   D3DLOCKED_RECT rect;
42611:   destSurf->LockRect(&rect, NULL, D3DLOCK_READONLY);
42611: 
42611:   nsRefPtr<gfxImageSurface> imageSurface =
42611:     new gfxImageSurface((unsigned char*)rect.pBits,
42611:                         gfxIntSize(desc.Width, desc.Height),
42611:                         rect.Pitch,
42611:                         gfxASurface::ImageFormatARGB32);
42611: 
42611:   mTarget->SetSource(imageSurface);
42611:   mTarget->SetOperator(gfxContext::OPERATOR_OVER);
42611:   mTarget->Paint();
42611:   destSurf->UnlockRect();
42611: }
42611: 
42611: LayerD3D9::LayerD3D9(LayerManagerD3D9 *aManager)
42611:   : mD3DManager(aManager)
42611: {
42611: }
42611: 
42611: } /* namespace layers */
42611: } /* namespace mozilla */
