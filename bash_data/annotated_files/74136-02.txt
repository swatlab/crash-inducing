29805: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
29805: /* vim: set ts=2 sw=2 et tw=78: */
29805: /* ***** BEGIN LICENSE BLOCK *****
29805:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29805:  *
29805:  * The contents of this file are subject to the Mozilla Public License Version
29805:  * 1.1 (the "License"); you may not use this file except in compliance with
29805:  * the License. You may obtain a copy of the License at
29805:  * http://www.mozilla.org/MPL/
29805:  *
29805:  * Software distributed under the License is distributed on an "AS IS" basis,
29805:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29805:  * for the specific language governing rights and limitations under the
29805:  * License.
29805:  *
29805:  * The Original Code is Mozilla Communicator client code.
29805:  *
29805:  * The Initial Developer of the Original Code is
29805:  * Netscape Communications Corporation.
29805:  * Portions created by the Initial Developer are Copyright (C) 1998
29805:  * the Initial Developer. All Rights Reserved.
29805:  *
29805:  * Contributor(s):
29805:  *   Pierre Phaneuf <pp@ludusdesign.com>
29805:  *   Henri Sivonen <hsivonen@iki.fi>
29805:  *
29805:  * Alternatively, the contents of this file may be used under the terms of
29805:  * either of the GNU General Public License Version 2 or later (the "GPL"),
29805:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29805:  * in which case the provisions of the GPL or the LGPL are applicable instead
29805:  * of those above. If you wish to allow use of your version of this file only
29805:  * under the terms of either the GPL or the LGPL, and not to allow others to
29805:  * use your version of this file under the terms of the MPL, indicate your
29805:  * decision by deleting the provisions above and replace them with the notice
29805:  * and other provisions required by the GPL or the LGPL. If you do not delete
29805:  * the provisions above, a recipient may use your version of this file under
29805:  * the terms of any one of the MPL, the GPL or the LGPL.
29805:  *
29805:  * ***** END LICENSE BLOCK ***** */
29805: 
29805: #include "nsHtml5TreeOperation.h"
31420: #include "nsContentUtils.h"
29805: #include "nsNodeUtils.h"
29805: #include "nsAttrName.h"
29805: #include "nsHtml5TreeBuilder.h"
31420: #include "nsIDOMMutationEvent.h"
31420: #include "mozAutoDocUpdate.h"
31420: #include "nsBindingManager.h"
31420: #include "nsXBLBinding.h"
32917: #include "nsHtml5DocumentMode.h"
34978: #include "nsHtml5HtmlAttributes.h"
34978: #include "nsContentCreatorFunctions.h"
34978: #include "nsIScriptElement.h"
34978: #include "nsIDTD.h"
34978: #include "nsTraceRefcnt.h"
34978: #include "nsIDOMHTMLFormElement.h"
34978: #include "nsIFormControl.h"
34978: #include "nsIStyleSheetLinkingElement.h"
34978: #include "nsIDOMDocumentType.h"
51669: #include "nsIObserverService.h"
51669: #include "mozilla/Services.h"
35600: #include "nsIMutationObserver.h"
38730: #include "nsIFormProcessor.h"
38730: #include "nsIServiceManager.h"
48406: #include "nsEscape.h"
51351: #include "mozilla/dom/Element.h"
47894: #include "nsHtml5SVGLoadDispatcher.h"
47894: 
51351: namespace dom = mozilla::dom;
51351: 
38730: static NS_DEFINE_CID(kFormProcessorCID, NS_FORMPROCESSOR_CID);
29805: 
35591: /**
35591:  * Helper class that opens a notification batch if the current doc
35591:  * is different from the executor doc.
35591:  */
35591: class NS_STACK_CLASS nsHtml5OtherDocUpdate {
35591:   public:
35591:     nsHtml5OtherDocUpdate(nsIDocument* aCurrentDoc, nsIDocument* aExecutorDoc)
35591:     {
35591:       NS_PRECONDITION(aCurrentDoc, "Node has no doc?");
35591:       NS_PRECONDITION(aExecutorDoc, "Executor has no doc?");
35591:       if (NS_LIKELY(aCurrentDoc == aExecutorDoc)) {
35591:         mDocument = nsnull;
35591:       } else {
35591:         mDocument = aCurrentDoc;
35591:         aCurrentDoc->BeginUpdate(UPDATE_CONTENT_MODEL);        
35591:       }
35591:     }
35591: 
35591:     ~nsHtml5OtherDocUpdate()
35591:     {
35591:       if (NS_UNLIKELY(mDocument)) {
35591:         mDocument->EndUpdate(UPDATE_CONTENT_MODEL);
35591:       }
35591:     }
35591:   private:
35591:     nsIDocument* mDocument;
35591: };
35591: 
29805: nsHtml5TreeOperation::nsHtml5TreeOperation()
34979: #ifdef DEBUG
34979:  : mOpCode(eTreeOpUninitialized)
34979: #endif
29805: {
29805:   MOZ_COUNT_CTOR(nsHtml5TreeOperation);
29805: }
29805: 
29805: nsHtml5TreeOperation::~nsHtml5TreeOperation()
29805: {
29805:   MOZ_COUNT_DTOR(nsHtml5TreeOperation);
34979:   NS_ASSERTION(mOpCode != eTreeOpUninitialized, "Uninitialized tree op.");
34978:   switch(mOpCode) {
34978:     case eTreeOpAddAttributes:
34978:       delete mTwo.attributes;
34978:       break;
43386:     case eTreeOpCreateElementNetwork:
43386:     case eTreeOpCreateElementNotNetwork:
34978:       delete mThree.attributes;
34978:       break;
35600:     case eTreeOpAppendDoctypeToDocument:
34978:       delete mTwo.stringPair;
34978:       break;
35600:     case eTreeOpFosterParentText:
35600:     case eTreeOpAppendText:
35600:     case eTreeOpAppendComment:
35600:     case eTreeOpAppendCommentToDocument:
34978:       delete[] mTwo.unicharPtr;
34978:       break;
34979:     case eTreeOpSetDocumentCharset:
34979:     case eTreeOpNeedsCharsetSwitchTo:
34979:       delete[] mOne.charPtr;
34979:       break;
38132:     case eTreeOpProcessOfflineManifest:
38132:       nsMemory::Free(mOne.unicharPtr);
38132:       break;
34978:     default: // keep the compiler happy
34978:       break;
34978:   }
29805: }
29805: 
29805: nsresult
44175: nsHtml5TreeOperation::AppendTextToTextNode(const PRUnichar* aBuffer,
35600:                                            PRInt32 aLength,
35600:                                            nsIContent* aTextNode,
35600:                                            nsHtml5TreeOpExecutor* aBuilder)
35600: {
35600:   NS_PRECONDITION(aTextNode, "Got null text node.");
35600: 
35600:   if (aBuilder->HaveNotified(aTextNode)) {
35600:     // This text node has already been notified on, so it's necessary to
35600:     // notify on the append
35600:     nsresult rv = NS_OK;
35600:     PRUint32 oldLength = aTextNode->TextLength();
35600:     CharacterDataChangeInfo info = {
35600:       PR_TRUE,
35600:       oldLength,
35600:       oldLength,
35600:       aLength
35600:     };
35600:     nsNodeUtils::CharacterDataWillChange(aTextNode, &info);
35600: 
35600:     rv = aTextNode->AppendText(aBuffer, aLength, PR_FALSE);
35600:     NS_ENSURE_SUCCESS(rv, rv);
35600: 
35600:     nsNodeUtils::CharacterDataChanged(aTextNode, &info);
35600:     return rv;
35600:   }
35600: 
35600:   return aTextNode->AppendText(aBuffer, aLength, PR_FALSE);
35600: }
35600: 
35600: 
35600: nsresult
44175: nsHtml5TreeOperation::AppendText(const PRUnichar* aBuffer,
35600:                                  PRInt32 aLength,
35600:                                  nsIContent* aParent,
35600:                                  nsHtml5TreeOpExecutor* aBuilder)
35600: {
35600:   nsresult rv = NS_OK;
35600:   nsIContent* lastChild = aParent->GetLastChild();
35600:   if (lastChild && lastChild->IsNodeOfType(nsINode::eTEXT)) {
35600:     nsHtml5OtherDocUpdate update(aParent->GetOwnerDoc(),
35600:                                  aBuilder->GetDocument());
35600:     return AppendTextToTextNode(aBuffer, 
35600:                                 aLength, 
35600:                                 lastChild, 
35600:                                 aBuilder);
35600:   }
35600: 
35600:   nsCOMPtr<nsIContent> text;
35600:   NS_NewTextNode(getter_AddRefs(text), aBuilder->GetNodeInfoManager());
35600:   NS_ASSERTION(text, "Infallible malloc failed?");
35600:   rv = text->SetText(aBuffer, aLength, PR_FALSE);
35600:   NS_ENSURE_SUCCESS(rv, rv);
35600: 
35600:   return Append(text, aParent, aBuilder);
35600: }
35600: 
35600: nsresult
35600: nsHtml5TreeOperation::Append(nsIContent* aNode,
35600:                              nsIContent* aParent,
35600:                              nsHtml5TreeOpExecutor* aBuilder)
35600: {
35600:   nsresult rv = NS_OK;
35600:   nsIDocument* executorDoc = aBuilder->GetDocument();
35600:   NS_ASSERTION(executorDoc, "Null doc on executor");
35600:   nsIDocument* parentDoc = aParent->GetOwnerDoc();
35600:   NS_ASSERTION(parentDoc, "Null owner doc on old node.");
35600: 
35600:   if (NS_LIKELY(executorDoc == parentDoc)) {
35600:     // the usual case. the parent is in the parser's doc
74136:     rv = aParent->AppendChildTo(aNode, PR_FALSE);
74136:     if (NS_SUCCEEDED(rv)) {
35600:       aBuilder->PostPendingAppendNotification(aParent, aNode);
74136:     }
35600:     return rv;
35600:   }
35600: 
35600:   // The parent has been moved to another doc
35600:   parentDoc->BeginUpdate(UPDATE_CONTENT_MODEL);
35600: 
35600:   PRUint32 childCount = aParent->GetChildCount();
35600:   rv = aParent->AppendChildTo(aNode, PR_FALSE);
74136:   if (NS_SUCCEEDED(rv)) {
42107:     nsNodeUtils::ContentAppended(aParent, aNode, childCount);
74136:   }
35600:   parentDoc->EndUpdate(UPDATE_CONTENT_MODEL);
35600:   return rv;
35600: }
35600: 
51669: class nsDocElementCreatedNotificationRunner : public nsRunnable
51669: {
51669: public:
51669:   nsDocElementCreatedNotificationRunner(nsIDocument* aDoc)
51669:     : mDoc(aDoc)
51669:   {
51669:   }
51669: 
51669:   NS_IMETHOD Run()
51669:   {
51669:     nsContentSink::NotifyDocElementCreated(mDoc);
51669:     return NS_OK;
51669:   }
51669: 
51669:   nsCOMPtr<nsIDocument> mDoc;
51669: };
51669: 
35600: nsresult
35600: nsHtml5TreeOperation::AppendToDocument(nsIContent* aNode,
35600:                                        nsHtml5TreeOpExecutor* aBuilder)
35600: {
35600:   nsresult rv = NS_OK;
35600:   aBuilder->FlushPendingAppendNotifications();
35600:   nsIDocument* doc = aBuilder->GetDocument();
35600:   PRUint32 childCount = doc->GetChildCount();
35600:   rv = doc->AppendChildTo(aNode, PR_FALSE);
35600:   NS_ENSURE_SUCCESS(rv, rv);
35600:   nsNodeUtils::ContentInserted(doc, aNode, childCount);
51669: 
51669:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
51669:                "Someone forgot to block scripts");
67662:   if (aNode->IsElement()) {
51669:     nsContentUtils::AddScriptRunner(
51669:         new nsDocElementCreatedNotificationRunner(doc));
67662:   }
35600:   return rv;
35600: }
35600: 
35600: nsresult
35590: nsHtml5TreeOperation::Perform(nsHtml5TreeOpExecutor* aBuilder,
35590:                               nsIContent** aScriptElement)
29805: {
29805:   nsresult rv = NS_OK;
29805:   switch(mOpCode) {
29805:     case eTreeOpAppend: {
34978:       nsIContent* node = *(mOne.node);
34978:       nsIContent* parent = *(mTwo.node);
35600:       return Append(node, parent, aBuilder);
35591:     }
29805:     case eTreeOpDetach: {
34978:       nsIContent* node = *(mOne.node);
29805:       aBuilder->FlushPendingAppendNotifications();
34978:       nsIContent* parent = node->GetParent();
29805:       if (parent) {
35591:         nsHtml5OtherDocUpdate update(parent->GetOwnerDoc(),
35591:                                      aBuilder->GetDocument());
34978:         PRUint32 pos = parent->IndexOf(node);
29805:         NS_ASSERTION((pos >= 0), "Element not found as child of its parent");
70878:         rv = parent->RemoveChildAt(pos, PR_TRUE);
29805:         NS_ENSURE_SUCCESS(rv, rv);
29805:       }
29805:       return rv;
29805:     }
29805:     case eTreeOpAppendChildrenToNewParent: {
34978:       nsIContent* node = *(mOne.node);
34978:       nsIContent* parent = *(mTwo.node);
29805:       aBuilder->FlushPendingAppendNotifications();
35591: 
35591:       nsHtml5OtherDocUpdate update(parent->GetOwnerDoc(),
35591:                                    aBuilder->GetDocument());
35591: 
34978:       PRUint32 childCount = parent->GetChildCount();
29805:       PRBool didAppend = PR_FALSE;
34978:       while (node->GetChildCount()) {
34978:         nsCOMPtr<nsIContent> child = node->GetChildAt(0);
70878:         rv = node->RemoveChildAt(0, PR_TRUE);
29805:         NS_ENSURE_SUCCESS(rv, rv);
34978:         rv = parent->AppendChildTo(child, PR_FALSE);
29805:         NS_ENSURE_SUCCESS(rv, rv);
29805:         didAppend = PR_TRUE;
29805:       }
29805:       if (didAppend) {
42107:         nsNodeUtils::ContentAppended(parent, parent->GetChildAt(childCount),
42107:                                      childCount);
29805:       }
29805:       return rv;
29805:     }
29805:     case eTreeOpFosterParent: {
34978:       nsIContent* node = *(mOne.node);
34978:       nsIContent* parent = *(mTwo.node);
34978:       nsIContent* table = *(mThree.node);
34978:       nsIContent* foster = table->GetParent();
35591: 
41645:       if (foster && foster->IsElement()) {
29805:         aBuilder->FlushPendingAppendNotifications();
35591: 
35591:         nsHtml5OtherDocUpdate update(foster->GetOwnerDoc(),
35591:                                      aBuilder->GetDocument());
35591: 
34978:         PRUint32 pos = foster->IndexOf(table);
34978:         rv = foster->InsertChildAt(node, pos, PR_FALSE);
29805:         NS_ENSURE_SUCCESS(rv, rv);
34978:         nsNodeUtils::ContentInserted(foster, node, pos);
35591:         return rv;
35591:       }
35591: 
35600:       return Append(node, parent, aBuilder);
29805:     }
29805:     case eTreeOpAppendToDocument: {
34978:       nsIContent* node = *(mOne.node);
35600:       return AppendToDocument(node, aBuilder);
29805:     }
29805:     case eTreeOpAddAttributes: {
51351:       dom::Element* node = (*(mOne.node))->AsElement();
34978:       nsHtml5HtmlAttributes* attributes = mTwo.attributes;
31420: 
35591:       nsHtml5OtherDocUpdate update(node->GetOwnerDoc(),
35591:                                    aBuilder->GetDocument());
35591: 
34978:       PRInt32 len = attributes->getLength();
37467:       for (PRInt32 i = len; i > 0;) {
37467:         --i;
34978:         // prefix doesn't need regetting. it is always null or a static atom
34978:         // local name is never null
34978:         nsCOMPtr<nsIAtom> localName = Reget(attributes->getLocalName(i));
34978:         PRInt32 nsuri = attributes->getURI(i);
34978:         if (!node->HasAttr(nsuri, localName)) {
34978:           // prefix doesn't need regetting. it is always null or a static atom
34978:           // local name is never null
70878:           node->SetAttr(nsuri, localName, attributes->getPrefix(i), *(attributes->getValue(i)), PR_TRUE);
34978:           // XXX what to do with nsresult?
29805:         }
29805:       }
34978:       
34978:       return rv;
34978:     }
43386:     case eTreeOpCreateElementNetwork:
43386:     case eTreeOpCreateElementNotNetwork: {
34978:       nsIContent** target = mOne.node;
34978:       PRInt32 ns = mInt;
34978:       nsCOMPtr<nsIAtom> name = Reget(mTwo.atom);
34978:       nsHtml5HtmlAttributes* attributes = mThree.attributes;
34978:       
38730:       PRBool isKeygen = (name == nsHtml5Atoms::keygen && ns == kNameSpaceID_XHTML);
38730:       if (NS_UNLIKELY(isKeygen)) {
38730:         name = nsHtml5Atoms::select;
38730:       }
38730:       
34978:       nsCOMPtr<nsIContent> newContent;
71770:       nsCOMPtr<nsINodeInfo> nodeInfo = aBuilder->GetNodeInfoManager()->
71770:         GetNodeInfo(name, nsnull, ns, nsIDOMNode::ELEMENT_NODE);
34978:       NS_ASSERTION(nodeInfo, "Got null nodeinfo.");
43386:       NS_NewElement(getter_AddRefs(newContent),
48124:                     ns, nodeInfo.forget(),
43386:                     (mOpCode == eTreeOpCreateElementNetwork ?
56805:                      dom::FROM_PARSER_NETWORK
43386:                      : (aBuilder->IsFragmentMode() ?
56805:                         dom::FROM_PARSER_FRAGMENT :
56805:                         dom::FROM_PARSER_DOCUMENT_WRITE)));
34978:       NS_ASSERTION(newContent, "Element creation created null pointer.");
34978: 
34978:       aBuilder->HoldElement(*target = newContent);      
34978: 
34991:       if (NS_UNLIKELY(name == nsHtml5Atoms::style || name == nsHtml5Atoms::link)) {
34991:         nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(newContent));
34991:         if (ssle) {
34991:           ssle->InitStyleLinkElement(PR_FALSE);
34991:           ssle->SetEnableUpdates(PR_FALSE);
34991:         }
38730:       } else if (NS_UNLIKELY(isKeygen)) {
38730:         // Adapted from CNavDTD
38730:         nsCOMPtr<nsIFormProcessor> theFormProcessor =
38730:           do_GetService(kFormProcessorCID, &rv);
38730:         NS_ENSURE_SUCCESS(rv, rv);
38730:         
38730:         nsTArray<nsString> theContent;
38730:         nsAutoString theAttribute;
38730:          
38730:         (void) theFormProcessor->ProvideContent(NS_LITERAL_STRING("select"),
38730:                                                 theContent,
38730:                                                 theAttribute);
38730: 
38730:         newContent->SetAttr(kNameSpaceID_None, 
38730:                             nsGkAtoms::moztype, 
38730:                             nsnull, 
38730:                             theAttribute,
38730:                             PR_FALSE);
38730: 
38730:         nsCOMPtr<nsINodeInfo> optionNodeInfo = 
38730:           aBuilder->GetNodeInfoManager()->GetNodeInfo(nsHtml5Atoms::option, 
38730:                                                       nsnull, 
71770:                                                       kNameSpaceID_XHTML,
71770:                                                       nsIDOMNode::ELEMENT_NODE);
38730:                                                       
38730:         for (PRUint32 i = 0; i < theContent.Length(); ++i) {
38730:           nsCOMPtr<nsIContent> optionElt;
48124:           nsCOMPtr<nsINodeInfo> ni = optionNodeInfo;
38730:           NS_NewElement(getter_AddRefs(optionElt), 
38730:                         optionNodeInfo->NamespaceID(), 
48124:                         ni.forget(),
56805:                         (mOpCode == eTreeOpCreateElementNetwork ?
56805:                          dom::FROM_PARSER_NETWORK
56805:                          : (aBuilder->IsFragmentMode() ?
56805:                             dom::FROM_PARSER_FRAGMENT :
56805:                             dom::FROM_PARSER_DOCUMENT_WRITE)));
38730:           nsCOMPtr<nsIContent> optionText;
38730:           NS_NewTextNode(getter_AddRefs(optionText), 
38730:                          aBuilder->GetNodeInfoManager());
38730:           (void) optionText->SetText(theContent[i], PR_FALSE);
38730:           optionElt->AppendChildTo(optionText, PR_FALSE);
38730:           newContent->AppendChildTo(optionElt, PR_FALSE);
38730:           newContent->DoneAddingChildren(PR_FALSE);
38730:         }
39513:       } else if (name == nsHtml5Atoms::frameset && ns == kNameSpaceID_XHTML) {
39513:         nsIDocument* doc = aBuilder->GetDocument();
39513:         nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(doc);
39513:         if (htmlDocument) {
39513:           // It seems harmless to call this multiple times, since this 
39513:           // is a simple field setter
39513:           htmlDocument->SetIsFrameset(PR_TRUE);
39513:         }
34991:       }
34991: 
34978:       if (!attributes) {
34978:         return rv;
34978:       }
34978: 
34978:       PRInt32 len = attributes->getLength();
37467:       for (PRInt32 i = len; i > 0;) {
37467:         --i;
34978:         // prefix doesn't need regetting. it is always null or a static atom
34978:         // local name is never null
34978:         nsCOMPtr<nsIAtom> localName = Reget(attributes->getLocalName(i));
48406:         if (ns == kNameSpaceID_XHTML &&
48406:             nsHtml5Atoms::a == name &&
48406:             nsHtml5Atoms::name == localName) {
48406:           // This is an HTML5-incompliant Geckoism.
48406:           // Remove when fixing bug 582361
48406:           NS_ConvertUTF16toUTF8 cname(*(attributes->getValue(i)));
48406:           NS_ConvertUTF8toUTF16 uv(nsUnescape(cname.BeginWriting()));
48406:           newContent->SetAttr(attributes->getURI(i), localName,
48406:               attributes->getPrefix(i), uv, PR_FALSE);
48406:         } else {
48406:           newContent->SetAttr(attributes->getURI(i), localName,
48406:               attributes->getPrefix(i), *(attributes->getValue(i)), PR_FALSE);
48406:         }
34978:       }
38730: 
34978:       return rv;
34978:     }
34978:     case eTreeOpSetFormElement: {
34978:       nsIContent* node = *(mOne.node);
34978:       nsIContent* parent = *(mTwo.node);
34978:       nsCOMPtr<nsIFormControl> formControl(do_QueryInterface(node));
34988:       // NS_ASSERTION(formControl, "Form-associated element did not implement nsIFormControl.");
51301:       // TODO: uncomment the above line when <keygen> (bug 101019) is supported by Gecko
34978:       nsCOMPtr<nsIDOMHTMLFormElement> formElement(do_QueryInterface(parent));
34978:       NS_ASSERTION(formElement, "The form element doesn't implement nsIDOMHTMLFormElement.");
51301:       // avoid crashing on <keygen>
51301:       if (formControl &&
51301:           !node->HasAttr(kNameSpaceID_None, nsGkAtoms::form)) {
34978:         formControl->SetForm(formElement);
34978:       }
34978:       return rv;
34978:     }
35600:     case eTreeOpAppendText: {
35600:       nsIContent* parent = *mOne.node;
34978:       PRUnichar* buffer = mTwo.unicharPtr;
34978:       PRInt32 length = mInt;
35600:       return AppendText(buffer, length, parent, aBuilder);
35600:     }
44175:     case eTreeOpAppendIsindexPrompt: {
44175:       nsIContent* parent = *mOne.node;
44175:       nsXPIDLString prompt;
44175:       nsresult rv =
44175:           nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
44175:                                              "IsIndexPromptWithSpace", prompt);
44175:       PRUint32 len = prompt.Length();
44175:       if (NS_FAILED(rv)) {
44175:         return rv;
44175:       }
44175:       if (!len) {
44175:         // Don't bother appending a zero-length text node.
44175:         return NS_OK;
44175:       }
44175:       return AppendText(prompt.BeginReading(), len, parent, aBuilder);
44175:     }
35600:     case eTreeOpFosterParentText: {
35600:       nsIContent* stackParent = *mOne.node;
35600:       PRUnichar* buffer = mTwo.unicharPtr;
35600:       PRInt32 length = mInt;
35600:       nsIContent* table = *mThree.node;
35600:       
35600:       nsIContent* foster = table->GetParent();
35600: 
41645:       if (foster && foster->IsElement()) {
35600:         aBuilder->FlushPendingAppendNotifications();
35600: 
35600:         nsHtml5OtherDocUpdate update(foster->GetOwnerDoc(),
35600:                                      aBuilder->GetDocument());
35600: 
35600:         PRUint32 pos = foster->IndexOf(table);
35600:         
35600:         nsIContent* previousSibling = foster->GetChildAt(pos - 1);
35600:         if (previousSibling && previousSibling->IsNodeOfType(nsINode::eTEXT)) {
35600:           return AppendTextToTextNode(buffer, 
35600:                                       length, 
35600:                                       previousSibling, 
35600:                                       aBuilder);
35600:         }
34978:         
34978:         nsCOMPtr<nsIContent> text;
34978:         NS_NewTextNode(getter_AddRefs(text), aBuilder->GetNodeInfoManager());
35600:         NS_ASSERTION(text, "Infallible malloc failed?");
35600:         rv = text->SetText(buffer, length, PR_FALSE);
35600:         NS_ENSURE_SUCCESS(rv, rv);
34978:         
35600:         rv = foster->InsertChildAt(text, pos, PR_FALSE);
35600:         NS_ENSURE_SUCCESS(rv, rv);
35600:         nsNodeUtils::ContentInserted(foster, text, pos);
34978:         return rv;
34978:       }
35600:       
35600:       return AppendText(buffer, length, stackParent, aBuilder);
35600:     }
35600:     case eTreeOpAppendComment: {
35600:       nsIContent* parent = *mOne.node;
34978:       PRUnichar* buffer = mTwo.unicharPtr;
34978:       PRInt32 length = mInt;
34978:       
34978:       nsCOMPtr<nsIContent> comment;
34978:       NS_NewCommentNode(getter_AddRefs(comment), aBuilder->GetNodeInfoManager());
35600:       NS_ASSERTION(comment, "Infallible malloc failed?");
35600:       rv = comment->SetText(buffer, length, PR_FALSE);
35600:       NS_ENSURE_SUCCESS(rv, rv);
34978:       
35600:       return Append(comment, parent, aBuilder);
34978:     }
35600:     case eTreeOpAppendCommentToDocument: {
35600:       PRUnichar* buffer = mTwo.unicharPtr;
35600:       PRInt32 length = mInt;
35600:       
35600:       nsCOMPtr<nsIContent> comment;
35600:       NS_NewCommentNode(getter_AddRefs(comment), aBuilder->GetNodeInfoManager());
35600:       NS_ASSERTION(comment, "Infallible malloc failed?");
35600:       rv = comment->SetText(buffer, length, PR_FALSE);
35600:       NS_ENSURE_SUCCESS(rv, rv);
35600:       
35600:       return AppendToDocument(comment, aBuilder);
35600:     }
35600:     case eTreeOpAppendDoctypeToDocument: {
34978:       nsCOMPtr<nsIAtom> name = Reget(mOne.atom);
34978:       nsHtml5TreeOperationStringPair* pair = mTwo.stringPair;
34978:       nsString publicId;
34978:       nsString systemId;
34978:       pair->Get(publicId, systemId);
34978:       
34978:       // Adapted from nsXMLContentSink
34978:       // Create a new doctype node
34978:       nsCOMPtr<nsIDOMDocumentType> docType;
34978:       nsAutoString voidString;
34978:       voidString.SetIsVoid(PR_TRUE);
34978:       NS_NewDOMDocumentType(getter_AddRefs(docType),
34978:                             aBuilder->GetNodeInfoManager(),
34978:                             nsnull,
34978:                             name,
34978:                             publicId,
34978:                             systemId,
34978:                             voidString);
34978:       NS_ASSERTION(docType, "Doctype creation failed.");
34978:       nsCOMPtr<nsIContent> asContent = do_QueryInterface(docType);
35600:       return AppendToDocument(asContent, aBuilder);
34978:     }
34978:     case eTreeOpRunScript: {
34978:       nsIContent* node = *(mOne.node);
34979:       nsAHtml5TreeBuilderState* snapshot = mTwo.state;
34979:       if (snapshot) {
35294:         aBuilder->InitializeDocWriteParserState(snapshot, mInt);
34979:       }
35590:       *aScriptElement = node;
29805:       return rv;
29805:     }
35727:     case eTreeOpRunScriptAsyncDefer: {
35727:       nsIContent* node = *(mOne.node);
35727:       aBuilder->RunScript(node);
35727:       return rv;
35727:     }
29805:     case eTreeOpDoneAddingChildren: {
34978:       nsIContent* node = *(mOne.node);
34978:       node->DoneAddingChildren(aBuilder->HaveNotified(node));
29805:       return rv;
29805:     }
29805:     case eTreeOpDoneCreatingElement: {
34978:       nsIContent* node = *(mOne.node);
34978:       node->DoneCreatingElement();
29805:       return rv;
29805:     }
35590:     case eTreeOpFlushPendingAppendNotifications: {
35590:       aBuilder->FlushPendingAppendNotifications();
35590:       return rv;
35590:     }
34979:     case eTreeOpSetDocumentCharset: {
34979:       char* str = mOne.charPtr;
39511:       PRInt32 charsetSource = mInt;
34979:       nsDependentCString dependentString(str);
39511:       aBuilder->SetDocumentCharsetAndSource(dependentString, charsetSource);
34979:       return rv;
34979:     }
34979:     case eTreeOpNeedsCharsetSwitchTo: {
34979:       char* str = mOne.charPtr;
62346:       PRInt32 charsetSource = mInt;
62346:       aBuilder->NeedsCharsetSwitchTo(str, charsetSource);
34979:       return rv;    
34979:     }
29805:     case eTreeOpUpdateStyleSheet: {
34978:       nsIContent* node = *(mOne.node);
34991:       aBuilder->FlushPendingAppendNotifications();
34978:       aBuilder->UpdateStyleSheet(node);
29805:       return rv;
29805:     }
29805:     case eTreeOpProcessMeta: {
34978:       nsIContent* node = *(mOne.node);
34978:       rv = aBuilder->ProcessMETATag(node);
29805:       return rv;
29805:     }
29805:     case eTreeOpProcessOfflineManifest: {
38132:       PRUnichar* str = mOne.unicharPtr;
38132:       nsDependentString dependentString(str);
38132:       aBuilder->ProcessOfflineManifest(dependentString);
34978:       return rv;
34978:     }
34978:     case eTreeOpMarkMalformedIfScript: {
34978:       nsIContent* node = *(mOne.node);
34978:       nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(node);
34978:       if (sele) {
34978:         // Make sure to serialize this script correctly, for nice round tripping.
34978:         sele->SetIsMalformed();
34978:       }
29805:       return rv;
29805:     }
34979:     case eTreeOpStreamEnded: {
35590:       aBuilder->DidBuildModel(PR_FALSE); // this causes a notifications flush anyway
34979:       return rv;
34979:     }
29805:     case eTreeOpStartLayout: {
35590:       aBuilder->StartLayout(); // this causes a notification flush anyway
29805:       return rv;
29805:     }
32917:     case eTreeOpDocumentMode: {
40913:       aBuilder->SetDocumentMode(mOne.mode);
32917:       return rv;
32917:     }
35294:     case eTreeOpSetStyleLineNumber: {
35294:       nsIContent* node = *(mOne.node);
35294:       nsCOMPtr<nsIStyleSheetLinkingElement> ssle = do_QueryInterface(node);
35294:       NS_ASSERTION(ssle, "Node didn't QI to style.");
35294:       ssle->SetLineNumber(mInt);
35294:       return rv;
35294:     }
35606:     case eTreeOpSetScriptLineNumberAndFreeze: {
35294:       nsIContent* node = *(mOne.node);
35294:       nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(node);
35294:       NS_ASSERTION(sele, "Node didn't QI to script.");
35294:       sele->SetScriptLineNumber(mInt);
35606:       sele->FreezeUriAsyncDefer();
35294:       return rv;
35294:     }
47894:     case eTreeOpSvgLoad: {
47894:       nsIContent* node = *(mOne.node);
47894:       nsCOMPtr<nsIRunnable> event = new nsHtml5SVGLoadDispatcher(node);
47894:       if (NS_FAILED(NS_DispatchToMainThread(event))) {
47894:         NS_WARNING("failed to dispatch svg load dispatcher");
47894:       }
47894:       return rv;
47894:     }
29805:     default: {
29805:       NS_NOTREACHED("Bogus tree op");
29805:     }
29805:   }
29805:   return rv; // keep compiler happy
29805: }
