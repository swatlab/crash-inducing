    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Joe Hewitt <hewitt@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "inDOMView.h"
    1: #include "inIDOMUtils.h"
    1: 
    1: #include "inLayoutUtils.h"
    1: 
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsISupportsArray.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMNodeFilter.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMNamedNodeMap.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsBindingManager.h"
 2298: #include "nsINameSpaceManager.h"
    1: #include "nsIDocument.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsITreeColumns.h"
    1: 
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessible.h"
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: // inDOMViewNode
    1: 
    1: class inDOMViewNode
    1: {
    1: public:
  731:   inDOMViewNode() {}
    1:   inDOMViewNode(nsIDOMNode* aNode);
    1:   ~inDOMViewNode();
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1: 
    1:   inDOMViewNode* parent;
    1:   inDOMViewNode* next;
    1:   inDOMViewNode* previous;
    1: 
    1:   PRInt32 level;
    1:   PRBool isOpen;
    1:   PRBool isContainer;
    1:   PRBool hasAnonymous;
    1:   PRBool hasSubDocument;
    1: };
    1: 
    1: inDOMViewNode::inDOMViewNode(nsIDOMNode* aNode) :
    1:   node(aNode),
    1:   parent(nsnull),
    1:   next(nsnull),
    1:   previous(nsnull),
    1:   level(0),
    1:   isOpen(PR_FALSE),
    1:   isContainer(PR_FALSE),
    1:   hasAnonymous(PR_FALSE),
    1:   hasSubDocument(PR_FALSE)
    1: {
    1: 
    1: }
    1: 
    1: inDOMViewNode::~inDOMViewNode()
    1: {
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: 
    1: inDOMView::inDOMView() :
    1:   mShowAnonymous(PR_FALSE),
    1:   mShowSubDocuments(PR_FALSE),
    1:   mShowWhitespaceNodes(PR_TRUE),
    1:   mShowAccessibleNodes(PR_FALSE),
    1:   mWhatToShow(nsIDOMNodeFilter::SHOW_ALL)
    1: {
    1: }
    1: 
    1: inDOMView::~inDOMView()
    1: {
    1:   SetRootNode(nsnull);
    1: }
    1: 
39099: #define DOMVIEW_ATOM(name_, value_) nsIAtom* inDOMView::name_ = nsnull;
39099: #include "inDOMViewAtomList.h"
39099: #undef DOMVIEW_ATOM
39099: 
39099: #define DOMVIEW_ATOM(name_, value_) NS_STATIC_ATOM_BUFFER(name_##_buffer, value_)
39099: #include "inDOMViewAtomList.h"
39099: #undef DOMVIEW_ATOM
39099: 
    1: /* static */ const nsStaticAtom inDOMView::Atoms_info[] = {
39099: #define DOMVIEW_ATOM(name_, value_) NS_STATIC_ATOM(name_##_buffer, &inDOMView::name_),
39099: #include "inDOMViewAtomList.h"
39099: #undef DOMVIEW_ATOM
    1: };
    1: 
    1: /* static */ void
    1: inDOMView::InitAtoms()
    1: {
    1:   NS_RegisterStaticAtoms(Atoms_info, NS_ARRAY_LENGTH(Atoms_info));
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: // nsISupports
    1: 
    1: NS_IMPL_ISUPPORTS3(inDOMView,
    1:                    inIDOMView,
    1:                    nsITreeView,
    1:                    nsIMutationObserver)
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: // inIDOMView
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetRootNode(nsIDOMNode** aNode)
    1: {
    1:   *aNode = mRootNode;
    1:   NS_IF_ADDREF(*aNode);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetRootNode(nsIDOMNode* aNode)
    1: {
    1:   if (mTree)
    1:     mTree->BeginUpdateBatch();
    1: 
    1:   if (mRootDocument) {
    1:     // remove previous document observer
    1:     nsCOMPtr<nsINode> doc(do_QueryInterface(mRootDocument));
    1:     if (doc)
    1:       doc->RemoveMutationObserver(this);
    1:   }
    1: 
    1:   RemoveAllNodes();
    1: 
    1:   mRootNode = aNode;
    1: 
    1:   if (aNode) {
    1:     // If we are able to show element nodes, then start with the root node
    1:     // as the first node in the buffer
    1:     if (mWhatToShow & nsIDOMNodeFilter::SHOW_ELEMENT) {
    1:       // allocate new node array
    1:       AppendNode(CreateNode(aNode, nsnull));
    1:     } else {
    1:       // place only the children of the root node in the buffer
    1:       ExpandNode(-1);
    1:     }
    1: 
    1:     // store an owning reference to document so that it isn't
    1:     // destroyed before we are
    1:     mRootDocument = do_QueryInterface(aNode);
    1:     if (!mRootDocument) {
    1:       aNode->GetOwnerDocument(getter_AddRefs(mRootDocument));
    1:     }
    1: 
    1:     // add document observer
    1:     nsCOMPtr<nsINode> doc(do_QueryInterface(mRootDocument));
    1:     if (doc)
    1:       doc->AddMutationObserver(this);
    1:   } else {
    1:     mRootDocument = nsnull;
    1:   }
    1: 
    1:   if (mTree)
    1:     mTree->EndUpdateBatch();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetNodeFromRowIndex(PRInt32 rowIndex, nsIDOMNode **_retval)
    1: {
    1:   inDOMViewNode* viewNode = nsnull;
    1:   RowToNode(rowIndex, &viewNode);
    1:   if (!viewNode) return NS_ERROR_FAILURE;
    1:   *_retval = viewNode->node;
    1:   NS_IF_ADDREF(*_retval);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetRowIndexFromNode(nsIDOMNode *node, PRInt32 *_retval)
    1: {
    1:   NodeToRow(node, _retval);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetShowAnonymousContent(PRBool *aShowAnonymousContent)
    1: {
    1:   *aShowAnonymousContent = mShowAnonymous;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetShowAnonymousContent(PRBool aShowAnonymousContent)
    1: {
    1:   mShowAnonymous = aShowAnonymousContent;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetShowSubDocuments(PRBool *aShowSubDocuments)
    1: {
    1:   *aShowSubDocuments = mShowSubDocuments;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetShowSubDocuments(PRBool aShowSubDocuments)
    1: {
    1:   mShowSubDocuments = aShowSubDocuments;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetShowWhitespaceNodes(PRBool *aShowWhitespaceNodes)
    1: {
    1:   *aShowWhitespaceNodes = mShowWhitespaceNodes;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetShowWhitespaceNodes(PRBool aShowWhitespaceNodes)
    1: {
    1:   mShowWhitespaceNodes = aShowWhitespaceNodes;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetShowAccessibleNodes(PRBool *aShowAccessibleNodes)
    1: {
    1:   *aShowAccessibleNodes = mShowAccessibleNodes;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetShowAccessibleNodes(PRBool aShowAccessibleNodes)
    1: {
    1:   mShowAccessibleNodes = aShowAccessibleNodes;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetWhatToShow(PRUint32 *aWhatToShow)
    1: {
    1:   *aWhatToShow = mWhatToShow;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetWhatToShow(PRUint32 aWhatToShow)
    1: {
    1:   mWhatToShow = aWhatToShow;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::Rebuild()
    1: {
    1:   nsCOMPtr<nsIDOMNode> root;
    1:   GetRootNode(getter_AddRefs(root));
    1:   SetRootNode(root);
    1:   return NS_OK;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: // nsITreeView
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetRowCount(PRInt32 *aRowCount)
    1: {
    1:   *aRowCount = GetRowCount();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetRowProperties(PRInt32 index, nsISupportsArray *properties)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetCellProperties(PRInt32 row, nsITreeColumn* col, nsISupportsArray *properties)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(row, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(node->node);
16126:   if (content && content->IsInAnonymousSubtree()) {
    1:     properties->AppendElement(kAnonymousAtom);
    1:   }
    1: 
    1:   PRUint16 nodeType;
    1:   node->node->GetNodeType(&nodeType);
    1:   switch (nodeType) {
    1:     case nsIDOMNode::ELEMENT_NODE:
    1:       properties->AppendElement(kElementNodeAtom);
    1:       break;
    1:     case nsIDOMNode::ATTRIBUTE_NODE:
    1:       properties->AppendElement(kAttributeNodeAtom);
    1:       break;
    1:     case nsIDOMNode::TEXT_NODE:
    1:       properties->AppendElement(kTextNodeAtom);
    1:       break;
    1:     case nsIDOMNode::CDATA_SECTION_NODE:
    1:       properties->AppendElement(kCDataSectionNodeAtom);
    1:       break;
    1:     case nsIDOMNode::ENTITY_REFERENCE_NODE:
    1:       properties->AppendElement(kEntityReferenceNodeAtom);
    1:       break;
    1:     case nsIDOMNode::ENTITY_NODE:
    1:       properties->AppendElement(kEntityNodeAtom);
    1:       break;
    1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
    1:       properties->AppendElement(kProcessingInstructionNodeAtom);
    1:       break;
    1:     case nsIDOMNode::COMMENT_NODE:
    1:       properties->AppendElement(kCommentNodeAtom);
    1:       break;
    1:     case nsIDOMNode::DOCUMENT_NODE:
    1:       properties->AppendElement(kDocumentNodeAtom);
    1:       break;
    1:     case nsIDOMNode::DOCUMENT_TYPE_NODE:
    1:       properties->AppendElement(kDocumentTypeNodeAtom);
    1:       break;
    1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
    1:       properties->AppendElement(kDocumentFragmentNodeAtom);
    1:       break;
    1:     case nsIDOMNode::NOTATION_NODE:
    1:       properties->AppendElement(kNotationNodeAtom);
    1:       break;
    1:   }
    1: 
    1: #ifdef ACCESSIBILITY
    1:   if (mShowAccessibleNodes) {
    1:     nsCOMPtr<nsIAccessibilityService> accService(
    1:       do_GetService("@mozilla.org/accessibilityService;1"));
    1:     NS_ENSURE_TRUE(accService, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIAccessible> accessible;
    1:     nsresult rv =
    1:       accService->GetAttachedAccessibleFor(node->node,
    1:                                            getter_AddRefs(accessible));
    1:     if (NS_SUCCEEDED(rv) && accessible)
    1:       properties->AppendElement(kAccessibleNodeAtom);
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetColumnProperties(nsITreeColumn* col, nsISupportsArray *properties)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetImageSrc(PRInt32 row, nsITreeColumn* col, nsAString& _retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetProgressMode(PRInt32 row, nsITreeColumn* col, PRInt32* _retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetCellValue(PRInt32 row, nsITreeColumn* col, nsAString& _retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetCellText(PRInt32 row, nsITreeColumn* col, nsAString& _retval)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(row, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   nsIDOMNode* domNode = node->node;
    1: 
    1:   nsAutoString colID;
    1:   col->GetId(colID);
    1:   if (colID.EqualsLiteral("colNodeName"))
    1:     domNode->GetNodeName(_retval);
    1:   else if (colID.EqualsLiteral("colLocalName"))
    1:     domNode->GetLocalName(_retval);
    1:   else if (colID.EqualsLiteral("colPrefix"))
    1:     domNode->GetPrefix(_retval);
    1:   else if (colID.EqualsLiteral("colNamespaceURI"))
    1:     domNode->GetNamespaceURI(_retval);
    1:   else if (colID.EqualsLiteral("colNodeType")) {
    1:     PRUint16 nodeType;
    1:     domNode->GetNodeType(&nodeType);
    1:     nsAutoString temp;
    1:     temp.AppendInt(PRInt32(nodeType));
    1:     _retval = temp;
    1:   } else if (colID.EqualsLiteral("colNodeValue"))
    1:     domNode->GetNodeValue(_retval);
    1:   else {
    1:     if (StringBeginsWith(colID, NS_LITERAL_STRING("col@"))) {
    1:       nsCOMPtr<nsIDOMElement> el = do_QueryInterface(node->node);
    1:       if (el) {
    1:         nsAutoString attr;
    1:         colID.Right(attr, colID.Length()-4); // have to use this because Substring is crashing on me!
    1:         el->GetAttribute(attr, _retval);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::IsContainer(PRInt32 index, PRBool *_retval)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(index, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   *_retval = node->isContainer;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::IsContainerOpen(PRInt32 index, PRBool *_retval)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(index, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   *_retval = node->isOpen;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::IsContainerEmpty(PRInt32 index, PRBool *_retval)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(index, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   *_retval = node->isContainer ? PR_FALSE : PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetLevel(PRInt32 index, PRInt32 *_retval)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(index, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   *_retval = node->level;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetParentIndex(PRInt32 rowIndex, PRInt32 *_retval)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(rowIndex, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   // GetParentIndex returns -1 if there is no parent  
    1:   *_retval = -1;
    1:   
    1:   inDOMViewNode* checkNode = nsnull;
    1:   PRInt32 i = rowIndex - 1;
    1:   do {
    1:     nsresult rv = RowToNode(i, &checkNode);
    1:     if (NS_FAILED(rv)) {
    1:       // No parent. Just break out.
    1:       break;
    1:     }
    1:     
    1:     if (checkNode == node->parent) {
    1:       *_retval = i;
    1:       return NS_OK;
    1:     }
    1:     --i;
    1:   } while (checkNode);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::HasNextSibling(PRInt32 rowIndex, PRInt32 afterIndex, PRBool *_retval)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(rowIndex, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   *_retval = node->next != nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::ToggleOpenState(PRInt32 index)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(index, &node);
    1:   if (!node) return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 oldCount = GetRowCount();
    1:   if (node->isOpen)
    1:     CollapseNode(index);
    1:   else
    1:     ExpandNode(index);
    1: 
    1:   // Update the twisty.
    1:   mTree->InvalidateRow(index);
    1: 
    1:   mTree->RowCountChanged(index+1, GetRowCount() - oldCount);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetTree(nsITreeBoxObject *tree)
    1: {
    1:   mTree = tree;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::GetSelection(nsITreeSelection * *aSelection)
    1: {
    1:   *aSelection = mSelection;
    1:   NS_IF_ADDREF(*aSelection);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP inDOMView::SetSelection(nsITreeSelection * aSelection)
    1: {
    1:   mSelection = aSelection;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SelectionChanged()
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetCellValue(PRInt32 row, nsITreeColumn* col, const nsAString& value)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::SetCellText(PRInt32 row, nsITreeColumn* col, const nsAString& value)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::CycleHeader(nsITreeColumn* col)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::CycleCell(PRInt32 row, nsITreeColumn* col)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::IsEditable(PRInt32 row, nsITreeColumn* col, PRBool *_retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::IsSelectable(PRInt32 row, nsITreeColumn* col, PRBool *_retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::IsSeparator(PRInt32 index, PRBool *_retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::IsSorted(PRBool *_retval)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29545: inDOMView::CanDrop(PRInt32 index, PRInt32 orientation,
29545:                    nsIDOMDataTransfer* aDataTransfer, PRBool *_retval)
    1: {
    1:   *_retval = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29545: inDOMView::Drop(PRInt32 row, PRInt32 orientation, nsIDOMDataTransfer* aDataTransfer)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::PerformAction(const PRUnichar *action)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::PerformActionOnRow(const PRUnichar *action, PRInt32 row)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: inDOMView::PerformActionOnCell(const PRUnichar* action, PRInt32 row, nsITreeColumn* col)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////
    1: // nsIMutationObserver
    1: 
    1: void
    1: inDOMView::NodeWillBeDestroyed(const nsINode* aNode)
    1: {
    1:   NS_NOTREACHED("Document destroyed while we're holding a strong ref to it");
    1: }
    1: 
    1: void
    1: inDOMView::AttributeChanged(nsIDocument *aDocument, nsIContent* aContent,
    1:                             PRInt32 aNameSpaceID, nsIAtom* aAttribute,
35535:                             PRInt32 aModType)
    1: {
    1:   if (!mTree) {
    1:     return;
    1:   }
    1: 
    1:   if (!(mWhatToShow & nsIDOMNodeFilter::SHOW_ATTRIBUTE)) {
    1:     return;
    1:   }
    1: 
    1:   // get the dom attribute node, if there is any
    1:   nsCOMPtr<nsIDOMNode> content(do_QueryInterface(aContent));
    1:   nsCOMPtr<nsIDOMElement> el(do_QueryInterface(aContent));
    1:   nsCOMPtr<nsIDOMAttr> domAttr;
39101:   nsDependentAtomString attrStr(aAttribute);
 2298:   if (aNameSpaceID) {
 2298:     nsCOMPtr<nsINameSpaceManager> nsm =
 2298:       do_GetService(NS_NAMESPACEMANAGER_CONTRACTID);
 2298:     if (!nsm) {
 2298:       // we can't find out which attribute we want :(
 2298:       return;
 2298:     }
 2298:     nsString attrNS;
 2298:     nsresult rv = nsm->GetNameSpaceURI(aNameSpaceID, attrNS);
 2298:     if (NS_FAILED(rv)) {
 2298:       return;
 2298:     }
 2298:     (void)el->GetAttributeNodeNS(attrNS, attrStr, getter_AddRefs(domAttr));
 2298:   } else {
 2298:     (void)el->GetAttributeNode(attrStr, getter_AddRefs(domAttr));
 2298:   }
    1: 
    1:   if (aModType == nsIDOMMutationEvent::MODIFICATION) {
    1:     // No fancy stuff here, just invalidate the changed row
 2298:     if (!domAttr) {
 2298:       return;
 2298:     }
    1:     PRInt32 row = 0;
    1:     NodeToRow(domAttr, &row);
    1:     mTree->InvalidateRange(row, row);
    1:   } else if (aModType == nsIDOMMutationEvent::ADDITION) {
 2298:     if (!domAttr) {
 2298:       return;
 2298:     }
    1:     // get the number of attributes on this content node
    1:     nsCOMPtr<nsIDOMNamedNodeMap> attrs;
    1:     content->GetAttributes(getter_AddRefs(attrs));
    1:     PRUint32 attrCount;
    1:     attrs->GetLength(&attrCount);
    1: 
    1:     inDOMViewNode* contentNode = nsnull;
    1:     PRInt32 contentRow;
    1:     PRInt32 attrRow;
    1:     if (mRootNode == content &&
    1:         !(mWhatToShow & nsIDOMNodeFilter::SHOW_ELEMENT)) {
    1:       // if this view has a root node but is not displaying it,
    1:       // it is ok to act as if the changed attribute is on the root.
    1:       attrRow = attrCount - 1;
    1:     } else {
    1:       if (NS_FAILED(NodeToRow(content, &contentRow))) {
    1:         return;
    1:       }
    1:       RowToNode(contentRow, &contentNode);
    1:       if (!contentNode->isOpen) {
    1:         return;
    1:       }
    1:       attrRow = contentRow + attrCount;
    1:     }
    1: 
    1:     inDOMViewNode* newNode = CreateNode(domAttr, contentNode);
    1:     inDOMViewNode* insertNode = nsnull;
    1:     RowToNode(attrRow, &insertNode);
    1:     if (insertNode) {
46311:       if (contentNode &&
46311:           insertNode->level <= contentNode->level) {
    1:         RowToNode(attrRow-1, &insertNode);
    1:         InsertLinkAfter(newNode, insertNode);
    1:       } else
    1:         InsertLinkBefore(newNode, insertNode);
    1:     }
    1:     InsertNode(newNode, attrRow);
    1:     mTree->RowCountChanged(attrRow, 1);
    1:   } else if (aModType == nsIDOMMutationEvent::REMOVAL) {
    1:     // At this point, the attribute is already gone from the DOM, but is still represented
    1:     // in our mRows array.  Search through the content node's children for the corresponding
    1:     // node and remove it.
    1: 
    1:     // get the row of the content node
    1:     inDOMViewNode* contentNode = nsnull;
    1:     PRInt32 contentRow;
    1:     PRInt32 baseLevel;
    1:     if (NS_SUCCEEDED(NodeToRow(content, &contentRow))) {
    1:       RowToNode(contentRow, &contentNode);
    1:       baseLevel = contentNode->level;
    1:     } else {
    1:       if (mRootNode == content) {
    1:         contentRow = -1;
    1:         baseLevel = -1;
    1:       } else
    1:         return;
    1:     }
    1: 
    1:     // search for the attribute node that was removed
    1:     inDOMViewNode* checkNode = nsnull;
    1:     PRInt32 row = 0;
    1:     for (row = contentRow+1; row < GetRowCount(); ++row) {
    1:       checkNode = GetNodeAt(row);
    1:       if (checkNode->level == baseLevel+1) {
    1:         domAttr = do_QueryInterface(checkNode->node);
    1:         if (domAttr) {
    1:           nsAutoString attrName;
    1:           domAttr->GetNodeName(attrName);
    1:           if (attrName.Equals(attrStr)) {
    1:             // we have found the row for the attribute that was removed
    1:             RemoveLink(checkNode);
    1:             RemoveNode(row);
    1:             mTree->RowCountChanged(row, -1);
    1:             break;
    1:           }
    1:         }
    1:       }
    1:       if (checkNode->level <= baseLevel)
    1:         break;
    1:     }
    1: 
    1:  }
    1: }
    1: 
    1: void
    1: inDOMView::ContentAppended(nsIDocument *aDocument,
    1:                            nsIContent* aContainer,
42107:                            nsIContent* aFirstNewContent,
42107:                            PRInt32 /* unused */)
    1: {
    1:   if (!mTree) {
    1:     return;
    1:   }
    1: 
42107:   for (nsIContent* cur = aFirstNewContent; cur; cur = cur->GetNextSibling()) {
42107:     // Our ContentInserted impl doesn't use the index
42107:     ContentInserted(aDocument, aContainer, cur, 0);
    1:   }
    1: }
    1: 
    1: void
    1: inDOMView::ContentInserted(nsIDocument *aDocument, nsIContent* aContainer,
42107:                            nsIContent* aChild, PRInt32 /* unused */)
    1: {
    1:   if (!mTree)
    1:     return;
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIDOMNode> childDOMNode(do_QueryInterface(aChild));
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   if (!mDOMUtils) {
    1:     mDOMUtils = do_GetService("@mozilla.org/inspector/dom-utils;1");
    1:     if (!mDOMUtils) {
    1:       return;
    1:     }
    1:   }
    1:   mDOMUtils->GetParentForNode(childDOMNode, mShowAnonymous,
    1:                               getter_AddRefs(parent));
    1: 
    1:   // find the inDOMViewNode for the parent of the inserted content
    1:   PRInt32 parentRow = 0;
    1:   if (NS_FAILED(rv = NodeToRow(parent, &parentRow)))
    1:     return;
    1:   inDOMViewNode* parentNode = nsnull;
    1:   if (NS_FAILED(rv = RowToNode(parentRow, &parentNode)))
    1:     return;
    1: 
    1:   if (!parentNode->isOpen) {
    1:     // Parent is not open, so don't bother creating tree rows for the
    1:     // kids.  But do indicate that it's now a container, if needed.
    1:     if (!parentNode->isContainer) {
    1:       parentNode->isContainer = PR_TRUE;
    1:       mTree->InvalidateRow(parentRow);
    1:     }
    1:     return;
    1:   }
    1: 
    1:   // get the previous sibling of the inserted content
    1:   nsCOMPtr<nsIDOMNode> previous;
    1:   GetRealPreviousSibling(childDOMNode, parent, getter_AddRefs(previous));
    1:   inDOMViewNode* previousNode = nsnull;
    1: 
    1:   PRInt32 row = 0;
    1:   if (previous) {
    1:     // find the inDOMViewNode for the previous sibling of the inserted content
    1:     PRInt32 previousRow = 0;
    1:     if (NS_FAILED(rv = NodeToRow(previous, &previousRow)))
    1:       return;
    1:     if (NS_FAILED(rv = RowToNode(previousRow, &previousNode)))
    1:       return;
    1: 
    1:     // get the last descendant of the previous row, which is the row
    1:     // after which to insert this new row
    1:     GetLastDescendantOf(previousNode, previousRow, &row);
    1:     ++row;
    1:   } else {
    1:     // there is no previous sibling, so the new row will be inserted after the parent
    1:     row = parentRow+1;
    1:   }
    1: 
    1:   inDOMViewNode* newNode = CreateNode(childDOMNode, parentNode);
    1: 
    1:   if (previous) {
    1:     InsertLinkAfter(newNode, previousNode);
    1:   } else {
    1:     PRInt32 firstChildRow;
    1:     if (NS_SUCCEEDED(GetFirstDescendantOf(parentNode, parentRow, &firstChildRow))) {
    1:       inDOMViewNode* firstChild;
    1:       RowToNode(firstChildRow, &firstChild);
    1:       InsertLinkBefore(newNode, firstChild);
    1:     }
    1:   }
    1: 
    1:   // insert new node
    1:   InsertNode(newNode, row);
    1: 
    1:   mTree->RowCountChanged(row, 1);
    1: }
    1: 
    1: void
    1: inDOMView::ContentRemoved(nsIDocument *aDocument, nsIContent* aContainer, nsIContent* aChild, PRInt32 aIndexInContainer)
    1: {
    1:   if (!mTree)
    1:     return;
    1: 
    1:   nsresult rv;
    1: 
    1:   // find the inDOMViewNode for the old child
    1:   nsCOMPtr<nsIDOMNode> oldDOMNode(do_QueryInterface(aChild));
    1:   PRInt32 row = 0;
    1:   if (NS_FAILED(rv = NodeToRow(oldDOMNode, &row)))
    1:     return;
    1:   inDOMViewNode* oldNode;
    1:   if (NS_FAILED(rv = RowToNode(row, &oldNode)))
    1:     return;
    1: 
    1:   // The parent may no longer be a container.  Note that we don't want
    1:   // to access oldNode after calling RemoveNode, so do this now.
    1:   inDOMViewNode* parentNode = oldNode->parent;
43455:   PRBool isOnlyChild = oldNode->previous == nsnull && oldNode->next == nsnull;
    1:   
    1:   // Keep track of how many rows we are removing.  It's at least one,
    1:   // but if we're open it's more.
    1:   PRInt32 oldCount = GetRowCount();
    1:   
    1:   if (oldNode->isOpen)
    1:     CollapseNode(row);
    1: 
    1:   RemoveLink(oldNode);
    1:   RemoveNode(row);
    1: 
43455:   if (isOnlyChild) {
    1:     // Fix up the parent
    1:     parentNode->isContainer = PR_FALSE;
    1:     parentNode->isOpen = PR_FALSE;
    1:     mTree->InvalidateRow(NodeToRow(parentNode));
    1:   }
    1:     
    1:   mTree->RowCountChanged(row, GetRowCount() - oldCount);
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////
    1: // inDOMView
    1: 
    1: //////// NODE MANAGEMENT
    1: 
    1: inDOMViewNode*
    1: inDOMView::GetNodeAt(PRInt32 aRow)
    1: {
24551:   return mNodes.ElementAt(aRow);
    1: }
    1: 
    1: PRInt32
    1: inDOMView::GetRowCount()
    1: {
24551:   return mNodes.Length();
    1: }
    1: 
    1: PRInt32
    1: inDOMView::NodeToRow(inDOMViewNode* aNode)
    1: {
    1:   return mNodes.IndexOf(aNode);
    1: }
    1: 
    1: inDOMViewNode*
    1: inDOMView::CreateNode(nsIDOMNode* aNode, inDOMViewNode* aParent)
    1: {
    1:   inDOMViewNode* viewNode = new inDOMViewNode(aNode);
    1:   viewNode->level = aParent ? aParent->level+1 : 0;
    1:   viewNode->parent = aParent;
    1: 
    1:   nsCOMArray<nsIDOMNode> grandKids;
    1:   GetChildNodesFor(aNode, grandKids);
    1:   viewNode->isContainer = (grandKids.Count() > 0);
    1:   return viewNode;
    1: }
    1: 
    1: PRBool
    1: inDOMView::RowOutOfBounds(PRInt32 aRow, PRInt32 aCount)
    1: {
    1:   return aRow < 0 || aRow >= GetRowCount() || aCount+aRow > GetRowCount();
    1: }
    1: 
    1: void
    1: inDOMView::AppendNode(inDOMViewNode* aNode)
    1: {
    1:   mNodes.AppendElement(aNode);
    1: }
    1: 
    1: void
    1: inDOMView::InsertNode(inDOMViewNode* aNode, PRInt32 aRow)
    1: {
    1:   if (RowOutOfBounds(aRow, 1))
    1:     AppendNode(aNode);
    1:   else
24551:     mNodes.InsertElementAt(aRow, aNode);
    1: }
    1: 
    1: void
    1: inDOMView::RemoveNode(PRInt32 aRow)
    1: {
    1:   if (RowOutOfBounds(aRow, 1))
    1:     return;
    1: 
    1:   delete GetNodeAt(aRow);
    1:   mNodes.RemoveElementAt(aRow);
    1: }
    1: 
    1: void
    1: inDOMView::ReplaceNode(inDOMViewNode* aNode, PRInt32 aRow)
    1: {
    1:   if (RowOutOfBounds(aRow, 1))
    1:     return;
    1: 
    1:   delete GetNodeAt(aRow);
24674:   mNodes.ElementAt(aRow) = aNode;
    1: }
    1: 
    1: void
24551: inDOMView::InsertNodes(nsTArray<inDOMViewNode*>& aNodes, PRInt32 aRow)
    1: {
    1:   if (aRow < 0 || aRow > GetRowCount())
    1:     return;
    1: 
24551:   mNodes.InsertElementsAt(aRow, aNodes);
    1: }
    1: 
    1: void
    1: inDOMView::RemoveNodes(PRInt32 aRow, PRInt32 aCount)
    1: {
    1:   if (aRow < 0)
    1:     return;
    1: 
    1:   PRInt32 rowCount = GetRowCount();
    1:   for (PRInt32 i = aRow; i < aRow+aCount && i < rowCount; ++i) {
    1:     delete GetNodeAt(i);
    1:   }
    1: 
    1:   mNodes.RemoveElementsAt(aRow, aCount);
    1: }
    1: 
    1: void
    1: inDOMView::RemoveAllNodes()
    1: {
    1:   PRInt32 rowCount = GetRowCount();
    1:   for (PRInt32 i = 0; i < rowCount; ++i) {
    1:     delete GetNodeAt(i);
    1:   }
    1: 
    1:   mNodes.Clear();
    1: }
    1: 
    1: void
    1: inDOMView::ExpandNode(PRInt32 aRow)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   RowToNode(aRow, &node);
    1: 
    1:   nsCOMArray<nsIDOMNode> kids;
    1:   GetChildNodesFor(node ? node->node : mRootNode,
    1:                    kids);
    1:   PRInt32 kidCount = kids.Count();
    1: 
24551:   nsTArray<inDOMViewNode*> list(kidCount);
    1: 
    1:   inDOMViewNode* newNode = nsnull;
    1:   inDOMViewNode* prevNode = nsnull;
    1: 
    1:   for (PRInt32 i = 0; i < kidCount; ++i) {
    1:     newNode = CreateNode(kids[i], node);
24674:     list.AppendElement(newNode);
    1: 
    1:     if (prevNode)
    1:       prevNode->next = newNode;
    1:     newNode->previous = prevNode;
    1:     prevNode = newNode;
    1:   }
    1: 
    1:   InsertNodes(list, aRow+1);
    1: 
    1:   if (node)
    1:     node->isOpen = PR_TRUE;
    1: }
    1: 
    1: void
    1: inDOMView::CollapseNode(PRInt32 aRow)
    1: {
    1:   inDOMViewNode* node = nsnull;
    1:   nsresult rv = RowToNode(aRow, &node);
    1:   if (NS_FAILED(rv)) {
    1:     return;
    1:   }
    1: 
    1:   PRInt32 row = 0;
    1:   GetLastDescendantOf(node, aRow, &row);
    1: 
    1:   RemoveNodes(aRow+1, row-aRow);
    1: 
    1:   node->isOpen = PR_FALSE;
    1: }
    1: 
    1: //////// NODE AND ROW CONVERSION
    1: 
    1: nsresult
    1: inDOMView::RowToNode(PRInt32 aRow, inDOMViewNode** aNode)
    1: {
    1:   if (aRow < 0 || aRow >= GetRowCount())
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   *aNode = GetNodeAt(aRow);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: inDOMView::NodeToRow(nsIDOMNode* aNode, PRInt32* aRow)
    1: {
    1:   PRInt32 rowCount = GetRowCount();
    1:   for (PRInt32 i = 0; i < rowCount; ++i) {
    1:     if (GetNodeAt(i)->node == aNode) {
    1:       *aRow = i;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   *aRow = -1;
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: //////// NODE HIERARCHY MUTATION
    1: 
    1: void
    1: inDOMView::InsertLinkAfter(inDOMViewNode* aNode, inDOMViewNode* aInsertAfter)
    1: {
    1:   if (aInsertAfter->next)
    1:     aInsertAfter->next->previous = aNode;
    1:   aNode->next = aInsertAfter->next;
    1:   aInsertAfter->next = aNode;
    1:   aNode->previous = aInsertAfter;
    1: }
    1: 
    1: void
    1: inDOMView::InsertLinkBefore(inDOMViewNode* aNode, inDOMViewNode* aInsertBefore)
    1: {
    1:   if (aInsertBefore->previous)
    1:     aInsertBefore->previous->next = aNode;
    1:   aNode->previous = aInsertBefore->previous;
    1:   aInsertBefore->previous = aNode;
    1:   aNode->next = aInsertBefore;
    1: }
    1: 
    1: void
    1: inDOMView::RemoveLink(inDOMViewNode* aNode)
    1: {
    1:   if (aNode->previous)
    1:     aNode->previous->next = aNode->next;
    1:   if (aNode->next)
    1:     aNode->next->previous = aNode->previous;
    1: }
    1: 
    1: void
    1: inDOMView::ReplaceLink(inDOMViewNode* aNewNode, inDOMViewNode* aOldNode)
    1: {
    1:   if (aOldNode->previous)
    1:     aOldNode->previous->next = aNewNode;
    1:   if (aOldNode->next)
    1:     aOldNode->next->previous = aNewNode;
    1:   aNewNode->next = aOldNode->next;
    1:   aNewNode->previous = aOldNode->previous;
    1: }
    1: 
    1: //////// NODE HIERARCHY UTILITIES
    1: 
    1: nsresult
    1: inDOMView::GetFirstDescendantOf(inDOMViewNode* aNode, PRInt32 aRow, PRInt32* aResult)
    1: {
    1:   // get the first node that is a descendant of the previous sibling
    1:   PRInt32 row = 0;
    1:   inDOMViewNode* node;
    1:   for (row = aRow+1; row < GetRowCount(); ++row) {
    1:     node = GetNodeAt(row);
    1:     if (node->parent == aNode) {
    1:       *aResult = row;
    1:       return NS_OK;
    1:     }
    1:     if (node->level <= aNode->level)
    1:       break;
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult
    1: inDOMView::GetLastDescendantOf(inDOMViewNode* aNode, PRInt32 aRow, PRInt32* aResult)
    1: {
    1:   // get the last node that is a descendant of the previous sibling
    1:   PRInt32 row = 0;
    1:   for (row = aRow+1; row < GetRowCount(); ++row) {
    1:     if (GetNodeAt(row)->level <= aNode->level)
    1:       break;
    1:   }
    1:   *aResult = row-1;
    1:   return NS_OK;
    1: }
    1: 
    1: //////// DOM UTILITIES
    1: 
    1: nsresult
    1: inDOMView::GetChildNodesFor(nsIDOMNode* aNode, nsCOMArray<nsIDOMNode>& aResult)
    1: {
 2298:   NS_ENSURE_ARG(aNode);
    1:   // Need to do this test to prevent unfortunate NYI assertion
    1:   // on nsXULAttribute::GetChildNodes
    1:   nsCOMPtr<nsIDOMAttr> attr = do_QueryInterface(aNode);
    1:   if (!attr) {
    1:     // attribute nodes
    1:     if (mWhatToShow & nsIDOMNodeFilter::SHOW_ATTRIBUTE) {
    1:       nsCOMPtr<nsIDOMNamedNodeMap> attrs;
    1:       aNode->GetAttributes(getter_AddRefs(attrs));
    1:       if (attrs) {
    1:         AppendAttrsToArray(attrs, aResult);
    1:       }
    1:     }
    1: 
    1:     if (mWhatToShow & nsIDOMNodeFilter::SHOW_ELEMENT) {
    1:       // try to get the anonymous content
    1:       nsCOMPtr<nsIDOMNodeList> kids;
    1:       if (mShowAnonymous) {
    1:         nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:         if (content) {
    1:           nsRefPtr<nsBindingManager> bindingManager = inLayoutUtils::GetBindingManagerFor(aNode);
    1:           if (bindingManager) {
    1:             bindingManager->GetAnonymousNodesFor(content, getter_AddRefs(kids));
    1:             if (!kids) {
    1:               bindingManager->GetContentListFor(content, getter_AddRefs(kids));
    1:             }
    1:           }
    1:         }
    1:       }
    1: 
    1:       if (!kids) {
    1:         aNode->GetChildNodes(getter_AddRefs(kids));
    1:       }
    1:       if (kids) {
    1:         AppendKidsToArray(kids, aResult);
    1:       }
    1:     }
    1: 
    1:     if (mShowSubDocuments) {
    1:       nsCOMPtr<nsIDOMNode> domdoc =
    1:         do_QueryInterface(inLayoutUtils::GetSubDocumentFor(aNode));
    1:       if (domdoc) {
    1:         aResult.AppendObject(domdoc);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: inDOMView::GetRealPreviousSibling(nsIDOMNode* aNode, nsIDOMNode* aRealParent, nsIDOMNode** aSibling)
    1: {
    1:   // XXXjrh: This won't work for some cases during some situations where XBL insertion points
    1:   // are involved.  Fix me!
    1:   aNode->GetPreviousSibling(aSibling);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: inDOMView::AppendKidsToArray(nsIDOMNodeList* aKids,
    1:                              nsCOMArray<nsIDOMNode>& aArray)
    1: {
    1:   PRUint32 l = 0;
    1:   aKids->GetLength(&l);
    1:   nsCOMPtr<nsIDOMNode> kid;
    1:   PRUint16 nodeType = 0;
    1: 
    1:   // Try and get DOM Utils in case we don't have one yet.
    1:   if (!mShowWhitespaceNodes && !mDOMUtils) {
    1:     mDOMUtils = do_CreateInstance("@mozilla.org/inspector/dom-utils;1");
    1:   }
    1: 
    1:   for (PRUint32 i = 0; i < l; ++i) {
    1:     aKids->Item(i, getter_AddRefs(kid));
    1:     kid->GetNodeType(&nodeType);
    1: 
    1:     NS_ASSERTION(nodeType && nodeType <= nsIDOMNode::NOTATION_NODE,
    1:                  "Unknown node type. "
    1:                  "Were new types added to the spec?");
    1:     // As of DOM Level 2 Core and Traversal, each NodeFilter constant
    1:     // is defined as the lower nth bit in the NodeFilter bitmask,
    1:     // where n is the numeric constant of the nodeType it represents.
    1:     // If this invariant ever changes, we will need to update the
    1:     // following line.
    1:     PRUint32 filterForNodeType = 1 << (nodeType - 1);
    1: 
    1:     if (mWhatToShow & filterForNodeType) {
    1:       if ((nodeType == nsIDOMNode::TEXT_NODE ||
    1:            nodeType == nsIDOMNode::COMMENT_NODE) &&
    1:           !mShowWhitespaceNodes && mDOMUtils) {
    1:         nsCOMPtr<nsIDOMCharacterData> data = do_QueryInterface(kid);
    1:         NS_ASSERTION(data, "Does not implement nsIDOMCharacterData!");
    1:         PRBool ignore;
    1:         mDOMUtils->IsIgnorableWhitespace(data, &ignore);
    1:         if (ignore) {
    1:           continue;
    1:         }
    1:       }
    1: 
    1:       aArray.AppendObject(kid);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: inDOMView::AppendAttrsToArray(nsIDOMNamedNodeMap* aKids,
    1:                               nsCOMArray<nsIDOMNode>& aArray)
    1: {
    1:   PRUint32 l = 0;
    1:   aKids->GetLength(&l);
    1:   nsCOMPtr<nsIDOMNode> kid;
    1:   for (PRUint32 i = 0; i < l; ++i) {
    1:     aKids->Item(i, getter_AddRefs(kid));
    1:     aArray.AppendObject(kid);
    1:   }
    1:   return NS_OK;
    1: }
