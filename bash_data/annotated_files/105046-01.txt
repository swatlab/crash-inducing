     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 19246: #include "nsNPAPIPlugin.h"
 19246: #include "nsNPAPIPluginInstance.h"
     1: #include "nsIMemory.h"
     1: #include "nsPluginsDir.h"
     1: #include "nsPluginsDirUtils.h"
     1: #include "prmem.h"
     1: #include "prenv.h"
     1: #include "prerror.h"
     1: #include <sys/stat.h>
     1: #include "nsString.h"
101111: #include "nsIFile.h"
     1: #include "nsIPrefBranch.h"
     1: #include "nsIPrefService.h"
     1: 
     1: #define LOCAL_PLUGIN_DLL_SUFFIX ".so"
     1: #if defined(__hpux)
     1: #define DEFAULT_X11_PATH "/usr/lib/X11R6/"
     1: #undef LOCAL_PLUGIN_DLL_SUFFIX
     1: #define LOCAL_PLUGIN_DLL_SUFFIX ".sl"
     1: #define LOCAL_PLUGIN_DLL_ALT_SUFFIX ".so"
     1: #elif defined(_AIX)
     1: #define DEFAULT_X11_PATH "/usr/lib"
     1: #define LOCAL_PLUGIN_DLL_ALT_SUFFIX ".a"
     1: #elif defined(SOLARIS)
     1: #define DEFAULT_X11_PATH "/usr/openwin/lib/"
     1: #elif defined(LINUX)
     1: #define DEFAULT_X11_PATH "/usr/X11R6/lib/"
 27524: #elif defined(__APPLE__)
 27524: #define DEFAULT_X11_PATH "/usr/X11R6/lib"
 27524: #undef LOCAL_PLUGIN_DLL_SUFFIX
 27524: #define LOCAL_PLUGIN_DLL_SUFFIX ".dylib"
 27524: #define LOCAL_PLUGIN_DLL_ALT_SUFFIX ".so"
     1: #else
     1: #define DEFAULT_X11_PATH ""
     1: #endif
     1: 
   944: #if defined(MOZ_WIDGET_GTK2)
     1: 
     1: #define PLUGIN_MAX_LEN_OF_TMP_ARR 512
     1: 
     1: static void DisplayPR_LoadLibraryErrorMessage(const char *libName)
     1: {
     1:     char errorMsg[PLUGIN_MAX_LEN_OF_TMP_ARR] = "Cannot get error from NSPR.";
     1:     if (PR_GetErrorTextLength() < (int) sizeof(errorMsg))
     1:         PR_GetErrorText(errorMsg);
     1: 
     1:     fprintf(stderr, "LoadPlugin: failed to initialize shared library %s [%s]\n",
     1:         libName, errorMsg);
     1: }
     1: 
     1: static void SearchForSoname(const char* name, char** soname)
     1: {
     1:     if (!(name && soname))
     1:         return;
     1:     PRDir *fdDir = PR_OpenDir(DEFAULT_X11_PATH);
     1:     if (!fdDir)
     1:         return;       
     1: 
     1:     int n = PL_strlen(name);
     1:     PRDirEntry *dirEntry;
     1:     while ((dirEntry = PR_ReadDir(fdDir, PR_SKIP_BOTH))) {
     1:         if (!PL_strncmp(dirEntry->name, name, n)) {
     1:             if (dirEntry->name[n] == '.' && dirEntry->name[n+1] && !dirEntry->name[n+2]) {
     1:                 // name.N, wild guess this is what we need
     1:                 char out[PLUGIN_MAX_LEN_OF_TMP_ARR] = DEFAULT_X11_PATH;
     1:                 PL_strcat(out, dirEntry->name);
     1:                 *soname = PL_strdup(out);
     1:                break;
     1:             }
     1:         }
     1:     }
     1: 
     1:     PR_CloseDir(fdDir);
     1: }
     1: 
 79445: static bool LoadExtraSharedLib(const char *name, char **soname, bool tryToGetSoname)
     1: {
 79445:     bool ret = true;
     1:     PRLibSpec tempSpec;
     1:     PRLibrary *handle;
     1:     tempSpec.type = PR_LibSpec_Pathname;
     1:     tempSpec.value.pathname = name;
     1:     handle = PR_LoadLibraryWithFlags(tempSpec, PR_LD_NOW|PR_LD_GLOBAL);
     1:     if (!handle) {
 79533:         ret = false;
     1:         DisplayPR_LoadLibraryErrorMessage(name);
     1:         if (tryToGetSoname) {
     1:             SearchForSoname(name, soname);
     1:             if (*soname) {
 79533:                 ret = LoadExtraSharedLib((const char *) *soname, NULL, false);
     1:             }
     1:         }
     1:     }
     1:     return ret;
     1: }
     1: 
     1: #define PLUGIN_MAX_NUMBER_OF_EXTRA_LIBS 32
     1: #define PREF_PLUGINS_SONAME "plugin.soname.list"
     1: #if defined(SOLARIS) || defined(HPUX)
     1: #define DEFAULT_EXTRA_LIBS_LIST "libXt" LOCAL_PLUGIN_DLL_SUFFIX ":libXext" LOCAL_PLUGIN_DLL_SUFFIX ":libXm" LOCAL_PLUGIN_DLL_SUFFIX
     1: #else
     1: #define DEFAULT_EXTRA_LIBS_LIST "libXt" LOCAL_PLUGIN_DLL_SUFFIX ":libXext" LOCAL_PLUGIN_DLL_SUFFIX
     1: #endif
     1: /*
     1:  this function looks for
     1:  user_pref("plugin.soname.list", "/usr/X11R6/lib/libXt.so.6:libXext.so");
     1:  in user's pref.js
     1:  and loads all libs in specified order
     1: */
     1: 
     1: static void LoadExtraSharedLibs()
     1: {
     1:     // check out if user's prefs.js has libs name
     1:     nsresult res;
     1:     nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID, &res));
     1:     if (NS_SUCCEEDED(res) && (prefs != nsnull)) {
     1:         char *sonameList = NULL;
 79445:         bool prefSonameListIsSet = true;
 29050:         res = prefs->GetCharPref(PREF_PLUGINS_SONAME, &sonameList);
     1:         if (!sonameList) {
     1:             // pref is not set, lets use hardcoded list
 79533:             prefSonameListIsSet = false;
     1:             sonameList = PL_strdup(DEFAULT_EXTRA_LIBS_LIST);
     1:         }
     1:         if (sonameList) {
     1:             char *arrayOfLibs[PLUGIN_MAX_NUMBER_OF_EXTRA_LIBS] = {0};
     1:             int numOfLibs = 0;
     1:             char *nextToken;
     1:             char *p = nsCRT::strtok(sonameList,":",&nextToken);
     1:             if (p) {
     1:                 while (p && numOfLibs < PLUGIN_MAX_NUMBER_OF_EXTRA_LIBS) {
     1:                     arrayOfLibs[numOfLibs++] = p;
     1:                     p = nsCRT::strtok(nextToken,":",&nextToken);
     1:                 }
     1:             } else // there is just one lib
     1:                 arrayOfLibs[numOfLibs++] = sonameList;
     1: 
     1:             char sonameListToSave[PLUGIN_MAX_LEN_OF_TMP_ARR] = "";
     1:             for (int i=0; i<numOfLibs; i++) {
     1:                 // trim out head/tail white spaces (just in case)
 79445:                 bool head = true;
     1:                 p = arrayOfLibs[i];
     1:                 while (*p) {
     1:                     if (*p == ' ' || *p == '\t') {
     1:                         if (head) {
     1:                             arrayOfLibs[i] = ++p;
     1:                         } else {
     1:                             *p = 0;
     1:                         }
     1:                     } else {
 79533:                         head = false;
     1:                         p++;
     1:                     }
     1:                 }
     1:                 if (!arrayOfLibs[i][0]) {
     1:                     continue; // null string
     1:                 }
 79445:                 bool tryToGetSoname = true;
     1:                 if (PL_strchr(arrayOfLibs[i], '/')) {
     1:                     //assuming it's real name, try to stat it
     1:                     struct stat st;
     1:                     if (stat((const char*) arrayOfLibs[i], &st)) {
     1:                         //get just a file name
     1:                         arrayOfLibs[i] = PL_strrchr(arrayOfLibs[i], '/') + 1;
     1:                     } else
 79533:                         tryToGetSoname = false;
     1:                 }
     1:                 char *soname = NULL;
     1:                 if (LoadExtraSharedLib(arrayOfLibs[i], &soname, tryToGetSoname)) {
     1:                     //construct soname's list to save in prefs
     1:                     p = soname ? soname : arrayOfLibs[i];
     1:                     int n = PLUGIN_MAX_LEN_OF_TMP_ARR -
     1:                         (PL_strlen(sonameListToSave) + PL_strlen(p));
     1:                     if (n > 0) {
     1:                         PL_strcat(sonameListToSave, p);
     1:                         PL_strcat(sonameListToSave,":");
     1:                     }
     1:                     if (soname) {
     1:                         PL_strfree(soname); // it's from strdup
     1:                     }
     1:                     if (numOfLibs > 1)
     1:                         arrayOfLibs[i][PL_strlen(arrayOfLibs[i])] = ':'; //restore ":" in sonameList
     1:                 }
     1:             }
     1: 
     1:             // Check whether sonameListToSave is a empty String, Bug: 329205
     1:             if (sonameListToSave[0]) 
     1:                 for (p = &sonameListToSave[PL_strlen(sonameListToSave) - 1]; *p == ':'; p--)
     1:                     *p = 0; //delete tail ":" delimiters
     1: 
     1:             if (!prefSonameListIsSet || PL_strcmp(sonameList, sonameListToSave)) {
     1:                 // if user specified some bogus soname I overwrite it here,
     1:                 // otherwise it'll decrease performance by calling popen() in SearchForSoname
     1:                 // every time for each bogus name
 29050:                 prefs->SetCharPref(PREF_PLUGINS_SONAME, (const char *)sonameListToSave);
     1:             }
     1:             PL_strfree(sonameList);
     1:         }
     1:     }
     1: }
   944: #endif //MOZ_WIDGET_GTK2
     1: 
     1: /* nsPluginsDir implementation */
     1: 
 79445: bool nsPluginsDir::IsPluginFile(nsIFile* file)
     1: {
     1:     nsCAutoString filename;
     1:     if (NS_FAILED(file->GetNativeLeafName(filename)))
 79533:         return false;
     1: 
 78424: #ifdef ANDROID
 78424:     // It appears that if you load
 78424:     // 'libstagefright_honeycomb.so' on froyo, or
 78424:     // 'libstagefright_froyo.so' on honeycomb, we will abort.
 78424:     // Since these are just helper libs, we can ignore.
 78424:     const char *cFile = filename.get();
 78424:     if (strstr(cFile, "libstagefright") != NULL)
 79533:         return false;
 78424: #endif
 78424: 
     1:     NS_NAMED_LITERAL_CSTRING(dllSuffix, LOCAL_PLUGIN_DLL_SUFFIX);
     1:     if (filename.Length() > dllSuffix.Length() &&
     1:         StringEndsWith(filename, dllSuffix))
 79533:         return true;
     1:     
     1: #ifdef LOCAL_PLUGIN_DLL_ALT_SUFFIX
     1:     NS_NAMED_LITERAL_CSTRING(dllAltSuffix, LOCAL_PLUGIN_DLL_ALT_SUFFIX);
     1:     if (filename.Length() > dllAltSuffix.Length() &&
     1:         StringEndsWith(filename, dllAltSuffix))
 79533:         return true;
     1: #endif
 79533:     return false;
     1: }
     1: 
     1: /* nsPluginFile implementation */
     1: 
     1: nsPluginFile::nsPluginFile(nsIFile* file)
     1: : mPlugin(file)
     1: {
     1: }
     1: 
     1: nsPluginFile::~nsPluginFile()
     1: {
     1: }
     1: 
 50781: nsresult nsPluginFile::LoadPlugin(PRLibrary **outLibrary)
     1: {
     1:     PRLibSpec libSpec;
     1:     libSpec.type = PR_LibSpec_Pathname;
 79445:     bool exists = false;
     1:     mPlugin->Exists(&exists);
     1:     if (!exists)
     1:         return NS_ERROR_FILE_NOT_FOUND;
     1: 
     1:     nsresult rv;
     1:     nsCAutoString path;
     1:     rv = mPlugin->GetNativePath(path);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     libSpec.value.pathname = path.get();
     1: 
   944: #if defined(MOZ_WIDGET_GTK2)
     1: 
     1:     // Normally, Mozilla isn't linked against libXt and libXext
     1:     // since it's a Gtk/Gdk application.  On the other hand,
     1:     // legacy plug-ins expect the libXt and libXext symbols
     1:     // to already exist in the global name space.  This plug-in
     1:     // wrapper is linked against libXt and libXext, but since
     1:     // we never call on any of these libraries, plug-ins still
     1:     // fail to resolve Xt symbols when trying to do a dlopen
     1:     // at runtime.  Explicitly opening Xt/Xext into the global
     1:     // namespace before attempting to load the plug-in seems to
     1:     // work fine.
     1: 
     1: 
     1: #if defined(SOLARIS) || defined(HPUX)
     1:     // Acrobat/libXm: Lazy resolving might cause crash later (bug 211587)
 50781:     *outLibrary = PR_LoadLibraryWithFlags(libSpec, PR_LD_NOW);
 50781:     pLibrary = *outLibrary;
     1: #else
     1:     // Some dlopen() doesn't recover from a failed PR_LD_NOW (bug 223744)
 50781:     *outLibrary = PR_LoadLibraryWithFlags(libSpec, 0);
 50781:     pLibrary = *outLibrary;
     1: #endif
     1:     if (!pLibrary) {
     1:         LoadExtraSharedLibs();
     1:         // try reload plugin once more
 50781:         *outLibrary = PR_LoadLibraryWithFlags(libSpec, 0);
 50781:         pLibrary = *outLibrary;
 50781:         if (!pLibrary) {
     1:             DisplayPR_LoadLibraryErrorMessage(libSpec.value.pathname);
 50781:             return NS_ERROR_FAILURE;
 50781:         }
     1:     }
     1: #else
 50781:     *outLibrary = PR_LoadLibraryWithFlags(libSpec, 0);
 50781:     pLibrary = *outLibrary;
   944: #endif  // MOZ_WIDGET_GTK2
     1: 
102909: #ifdef DEBUG
     1:     printf("LoadPlugin() %s returned %lx\n", 
     1:            libSpec.value.pathname, (unsigned long)pLibrary);
     1: #endif
     1: 
105046:     if (!pLibrary) {
105046:         return NS_ERROR_FAILURE;
105046:     }
105046:     
     1:     return NS_OK;
     1: }
     1: 
 50781: nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info, PRLibrary **outLibrary)
     1: {
 50781:     *outLibrary = nsnull;
 50781: 
 29981:     info.fVersion = nsnull;
     1: 
 50781:     // Sadly we have to load the library for this to work.
 50781:     nsresult rv = LoadPlugin(outLibrary);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1:   
 15947:     const char* (*npGetPluginVersion)() =
 15947:         (const char* (*)()) PR_FindFunctionSymbol(pLibrary, "NP_GetPluginVersion");
 50781:     if (npGetPluginVersion) {
 15947:         info.fVersion = PL_strdup(npGetPluginVersion());
 50781:     }
 15947: 
 50781:     const char* (*npGetMIMEDescription)() =
 50781:         (const char* (*)()) PR_FindFunctionSymbol(pLibrary, "NP_GetMIMEDescription");
 50781:     if (!npGetMIMEDescription) {
 50781:         return NS_ERROR_FAILURE;
 50781:     }
 50781: 
 50781:     const char* mimedescr = npGetMIMEDescription();
 50781:     if (!mimedescr) {
 50781:         return NS_ERROR_FAILURE;
 50781:     }
 50781: 
 50781:     rv = ParsePluginMimeDescription(mimedescr, info);
 50781:     if (NS_FAILED(rv)) {
     1:         return rv;
 50781:     }
 29020: 
 64609:     nsCAutoString path;
 64609:     if (NS_FAILED(rv = mPlugin->GetNativePath(path)))
     1:         return rv;
 64609:     info.fFullPath = PL_strdup(path.get());
 29020: 
 29020:     nsCAutoString fileName;
 29020:     if (NS_FAILED(rv = mPlugin->GetNativeLeafName(fileName)))
 29020:         return rv;
 29020:     info.fFileName = PL_strdup(fileName.get());
 29020: 
 50781:     NP_GetValueFunc npGetValue = (NP_GetValueFunc)PR_FindFunctionSymbol(pLibrary, "NP_GetValue");
 50781:     if (!npGetValue) {
 50781:         return NS_ERROR_FAILURE;
 50781:     }
 50781: 
 29020:     const char *name = NULL;
 89491:     npGetValue(NULL, NPPVpluginNameString, &name);
 50781:     if (name) {
     1:         info.fName = PL_strdup(name);
 50781:     }
 50781:     else {
 29020:         info.fName = PL_strdup(fileName.get());
 50781:     }
     1: 
 29020:     const char *description = NULL;
 89491:     npGetValue(NULL, NPPVpluginDescriptionString, &description);
 50781:     if (description) {
     1:         info.fDescription = PL_strdup(description);
     1:     }
 50781:     else {
 51750:         info.fDescription = PL_strdup("");
 50781:     }
 50781: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info)
     1: {
     1:     if (info.fName != nsnull)
     1:         PL_strfree(info.fName);
     1: 
     1:     if (info.fDescription != nsnull)
     1:         PL_strfree(info.fDescription);
     1: 
     1:     for (PRUint32 i = 0; i < info.fVariantCount; i++) {
     1:         if (info.fMimeTypeArray[i] != nsnull)
     1:             PL_strfree(info.fMimeTypeArray[i]);
     1: 
     1:         if (info.fMimeDescriptionArray[i] != nsnull)
     1:             PL_strfree(info.fMimeDescriptionArray[i]);
     1: 
     1:         if (info.fExtensionArray[i] != nsnull)
     1:             PL_strfree(info.fExtensionArray[i]);
     1:     }
     1: 
     1:     PR_FREEIF(info.fMimeTypeArray);
     1:     PR_FREEIF(info.fMimeDescriptionArray);
     1:     PR_FREEIF(info.fExtensionArray);
     1: 
 64609:     if (info.fFullPath != nsnull)
 64609:         PL_strfree(info.fFullPath);
 29020: 
     1:     if (info.fFileName != nsnull)
     1:         PL_strfree(info.fFileName);
     1: 
 15947:     if (info.fVersion != nsnull)
 15947:         PL_strfree(info.fVersion);
 15947: 
     1:     return NS_OK;
     1: }
