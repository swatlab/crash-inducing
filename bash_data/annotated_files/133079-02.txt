     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsTimerImpl.h"
     1: #include "TimerThread.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsThreadManager.h"
     1: #include "nsThreadUtils.h"
 84290: #include "sampler.h"
 92122: #include NEW_H
 92122: #include "nsFixedSizeAllocator.h"
     1: 
 48031: using mozilla::TimeDuration;
 48031: using mozilla::TimeStamp;
 48031: 
108991: static int32_t          gGenerator = 0;
106838: static TimerThread*     gThread = nullptr;
     1: 
     1: #ifdef DEBUG_TIMERS
120415: 
120415: PRLogModuleInfo*
120415: GetTimerLog()
120415: {
120415:   static PRLogModuleInfo *sLog;
120415:   if (!sLog)
120415:     sLog = PR_NewLogModule("nsTimerImpl");
120415:   return sLog;
120415: }
120415: 
     1: #include <math.h>
     1: 
     1: double nsTimerImpl::sDeltaSumSquared = 0;
     1: double nsTimerImpl::sDeltaSum = 0;
     1: double nsTimerImpl::sDeltaNum = 0;
     1: 
     1: static void
     1: myNS_MeanAndStdDev(double n, double sumOfValues, double sumOfSquaredValues,
     1:                    double *meanResult, double *stdDevResult)
     1: {
     1:   double mean = 0.0, var = 0.0, stdDev = 0.0;
     1:   if (n > 0.0 && sumOfValues >= 0) {
     1:     mean = sumOfValues / n;
     1:     double temp = (n * sumOfSquaredValues) - (sumOfValues * sumOfValues);
     1:     if (temp < 0.0 || n <= 1)
     1:       var = 0.0;
     1:     else
     1:       var = temp / (n * (n - 1));
     1:     // for some reason, Windows says sqrt(0.0) is "-1.#J" (?!) so do this:
     1:     stdDev = var != 0.0 ? sqrt(var) : 0.0;
     1:   }
     1:   *meanResult = mean;
     1:   *stdDevResult = stdDev;
     1: }
     1: #endif
     1: 
 92122: namespace {
 92122: 
 92122: // TimerEventAllocator is a fixed size allocator class which is used in order
 92122: // to avoid the default allocator lock contention when firing timer events.
 92122: // It is a thread-safe wrapper around nsFixedSizeAllocator.  The thread-safety
 92122: // is required because nsTimerEvent objects are allocated on the timer thread,
132954: // and freed on another thread.  Since this is a TimerEventAllocator specific
 92122: // lock, the lock contention issue is only limited to the allocation and
 92122: // deallocation of nsTimerEvent objects.
 92122: class TimerEventAllocator : public nsFixedSizeAllocator {
 92122: public:
 92122:     TimerEventAllocator() :
 92122:       mMonitor("TimerEventAllocator")
 92122:   {
 92122:   }
 92122: 
 92122:   void* Alloc(size_t aSize)
 92122:   {
 92122:     mozilla::MonitorAutoLock lock(mMonitor);
 92122:     return nsFixedSizeAllocator::Alloc(aSize);
 92122:   }
 92122:   void Free(void* aPtr, size_t aSize)
 92122:   {
 92122:     mozilla::MonitorAutoLock lock(mMonitor);
 92122:     nsFixedSizeAllocator::Free(aPtr, aSize);
 92122:   }
 92122: 
 92122: private:
 92122:   mozilla::Monitor mMonitor;
 92122: };
 92122: 
 92122: }
 92122: 
 92122: class nsTimerEvent : public nsRunnable {
 92122: public:
 92122:   NS_IMETHOD Run();
 92122: 
108991:   nsTimerEvent(nsTimerImpl *timer, int32_t generation)
 92122:     : mTimer(timer), mGeneration(generation) {
 92122:     // timer is already addref'd for us
 92122:     MOZ_COUNT_CTOR(nsTimerEvent);
133079: 
133079:     MOZ_ASSERT(gThread->IsOnTimerThread(),
133079:                "nsTimer must always be allocated on the timer thread");
133079: 
133079:     PR_ATOMIC_INCREMENT(&sAllocatorUsers);
 92122:   }
 92122: 
 92122: #ifdef DEBUG_TIMERS
 92122:   TimeStamp mInitTime;
 92122: #endif
 92122: 
 92122:   static void Init();
 92122:   static void Shutdown();
133079:   static void DeleteAllocatorIfNeeded();
 92122: 
 92122:   static void* operator new(size_t size) CPP_THROW_NEW {
 92122:     return sAllocator->Alloc(size);
 92122:   }
 92122:   void operator delete(void* p) {
 92122:     sAllocator->Free(p, sizeof(nsTimerEvent));
133079:     DeleteAllocatorIfNeeded();
 92122:   }
 92122: 
 92122: private:
133079:   nsTimerEvent(); // Not implemented
 92122:   ~nsTimerEvent() {
 92122: #ifdef DEBUG
 92122:     if (mTimer)
 92122:       NS_WARNING("leaking reference to nsTimerImpl");
 92122: #endif
 92122:     MOZ_COUNT_DTOR(nsTimerEvent);
133079: 
133079:     MOZ_ASSERT(!sCanDeleteAllocator || sAllocatorUsers > 0,
133079:                "This will result in us attempting to deallocate the nsTimerEvent allocator twice");
133079:     PR_ATOMIC_DECREMENT(&sAllocatorUsers);
 92122:   }
 92122: 
 92122:   nsTimerImpl *mTimer;
108991:   int32_t      mGeneration;
 92122: 
 92122:   static TimerEventAllocator* sAllocator;
133079:   static int32_t sAllocatorUsers;
133079:   static bool sCanDeleteAllocator;
 92122: };
 92122: 
106838: TimerEventAllocator* nsTimerEvent::sAllocator = nullptr;
133079: int32_t nsTimerEvent::sAllocatorUsers = 0;
133079: bool nsTimerEvent::sCanDeleteAllocator = false;
 92122: 
     1: NS_IMPL_THREADSAFE_QUERY_INTERFACE1(nsTimerImpl, nsITimer)
     1: NS_IMPL_THREADSAFE_ADDREF(nsTimerImpl)
     1: 
     1: NS_IMETHODIMP_(nsrefcnt) nsTimerImpl::Release(void)
     1: {
     1:   nsrefcnt count;
     1: 
132195:   MOZ_ASSERT(int32_t(mRefCnt) > 0, "dup release");
 64101:   count = NS_AtomicDecrementRefcnt(mRefCnt);
     1:   NS_LOG_RELEASE(this, count, "nsTimerImpl");
     1:   if (count == 0) {
     1:     mRefCnt = 1; /* stabilize */
     1: 
     1:     /* enable this to find non-threadsafe destructors: */
     1:     /* NS_ASSERT_OWNINGTHREAD(nsTimerImpl); */
 47223:     delete this;
     1:     return 0;
     1:   }
     1: 
     1:   // If only one reference remains, and mArmed is set, then the ref must be
     1:   // from the TimerThread::mTimers array, so we Cancel this timer to remove
     1:   // the mTimers element, and return 0 if Cancel in fact disarmed the timer.
     1:   //
     1:   // We use an inlined version of nsTimerImpl::Cancel here to check for the
     1:   // NS_ERROR_NOT_AVAILABLE code returned by gThread->RemoveTimer when this
     1:   // timer is not found in the mTimers array -- i.e., when the timer was not
     1:   // in fact armed once we acquired TimerThread::mLock, in spite of mArmed
     1:   // being true here.  That can happen if the armed timer is being fired by
     1:   // TimerThread::Run as we race and test mArmed just before it is cleared by
     1:   // the timer thread.  If the RemoveTimer call below doesn't find this timer
     1:   // in the mTimers array, then the last ref to this timer is held manually
     1:   // and temporarily by the TimerThread, so we should fall through to the
     1:   // final return and return 1, not 0.
     1:   //
     1:   // The original version of this thread-based timer code kept weak refs from
     1:   // TimerThread::mTimers, removing this timer's weak ref in the destructor,
     1:   // but that leads to double-destructions in the race described above, and
     1:   // adding mArmed doesn't help, because destructors can't be deferred, once
     1:   // begun.  But by combining reference-counting and a specialized Release
     1:   // method with "is this timer still in the mTimers array once we acquire
     1:   // the TimerThread's lock" testing, we defer destruction until we're sure
     1:   // that only one thread has its hot little hands on this timer.
     1:   //
     1:   // Note that both approaches preclude a timer creator, and everyone else
     1:   // except the TimerThread who might have a strong ref, from dropping all
     1:   // their strong refs without implicitly canceling the timer.  Timers need
     1:   // non-mTimers-element strong refs to stay alive.
     1: 
     1:   if (count == 1 && mArmed) {
 80486:     mCanceled = true;
     1: 
132196:     MOZ_ASSERT(gThread, "Armed timer exists after the thread timer stopped.");
     1:     if (NS_SUCCEEDED(gThread->RemoveTimer(this)))
     1:       return 0;
     1:   }
     1: 
     1:   return count;
     1: }
     1: 
     1: nsTimerImpl::nsTimerImpl() :
106838:   mClosure(nullptr),
     1:   mCallbackType(CALLBACK_TYPE_UNKNOWN),
 80486:   mFiring(false),
 80486:   mArmed(false),
 80486:   mCanceled(false),
     1:   mGeneration(0),
 48031:   mDelay(0)
     1: {
     1:   // XXXbsmedberg: shouldn't this be in Init()?
 16177:   mEventTarget = static_cast<nsIEventTarget*>(NS_GetCurrentThread());
     1: 
106838:   mCallback.c = nullptr;
     1: }
     1: 
     1: nsTimerImpl::~nsTimerImpl()
     1: {
     1:   ReleaseCallback();
     1: }
     1: 
     1: //static
     1: nsresult
     1: nsTimerImpl::Startup()
     1: {
     1:   nsresult rv;
     1: 
 92122:   nsTimerEvent::Init();
 92122: 
     1:   gThread = new TimerThread();
     1:   if (!gThread) return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   NS_ADDREF(gThread);
     1:   rv = gThread->InitLocks();
     1: 
     1:   if (NS_FAILED(rv)) {
     1:     NS_RELEASE(gThread);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: void nsTimerImpl::Shutdown()
     1: {
     1: #ifdef DEBUG_TIMERS
120415:   if (PR_LOG_TEST(GetTimerLog(), PR_LOG_DEBUG)) {
     1:     double mean = 0, stddev = 0;
     1:     myNS_MeanAndStdDev(sDeltaNum, sDeltaSum, sDeltaSumSquared, &mean, &stddev);
     1: 
120415:     PR_LOG(GetTimerLog(), PR_LOG_DEBUG, ("sDeltaNum = %f, sDeltaSum = %f, sDeltaSumSquared = %f\n", sDeltaNum, sDeltaSum, sDeltaSumSquared));
120415:     PR_LOG(GetTimerLog(), PR_LOG_DEBUG, ("mean: %fms, stddev: %fms\n", mean, stddev));
     1:   }
     1: #endif
     1: 
     1:   if (!gThread)
     1:     return;
     1: 
     1:   gThread->Shutdown();
     1:   NS_RELEASE(gThread);
 92122: 
 92122:   nsTimerEvent::Shutdown();
     1: }
     1: 
     1: 
108991: nsresult nsTimerImpl::InitCommon(uint32_t aType, uint32_t aDelay)
     1: {
     1:   nsresult rv;
     1: 
     1:   NS_ENSURE_TRUE(gThread, NS_ERROR_NOT_INITIALIZED);
     1: 
     1:   rv = gThread->Init();
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   /**
     1:    * In case of re-Init, both with and without a preceding Cancel, clear the
     1:    * mCanceled flag and assign a new mGeneration.  But first, remove any armed
     1:    * timer from the timer thread's list.
     1:    *
     1:    * If we are racing with the timer thread to remove this timer and we lose,
     1:    * the RemoveTimer call made here will fail to find this timer in the timer
     1:    * thread's list, and will return false harmlessly.  We test mArmed here to
     1:    * avoid the small overhead in RemoveTimer of locking the timer thread and
     1:    * checking its list for this timer.  It's safe to test mArmed even though
     1:    * it might be cleared on another thread in the next cycle (or even already
     1:    * be cleared by another CPU whose store hasn't reached our CPU's cache),
     1:    * because RemoveTimer is idempotent.
     1:    */
     1:   if (mArmed)
     1:     gThread->RemoveTimer(this);
 80486:   mCanceled = false;
 81298:   mTimeout = TimeStamp();
 64101:   mGeneration = PR_ATOMIC_INCREMENT(&gGenerator);
     1: 
108991:   mType = (uint8_t)aType;
     1:   SetDelayInternal(aDelay);
     1: 
     1:   return gThread->AddTimer(this);
     1: }
     1: 
     1: NS_IMETHODIMP nsTimerImpl::InitWithFuncCallback(nsTimerCallbackFunc aFunc,
     1:                                                 void *aClosure,
108991:                                                 uint32_t aDelay,
108991:                                                 uint32_t aType)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aFunc);
     1:   
     1:   ReleaseCallback();
     1:   mCallbackType = CALLBACK_TYPE_FUNC;
     1:   mCallback.c = aFunc;
     1:   mClosure = aClosure;
     1: 
     1:   return InitCommon(aType, aDelay);
     1: }
     1: 
     1: NS_IMETHODIMP nsTimerImpl::InitWithCallback(nsITimerCallback *aCallback,
108991:                                             uint32_t aDelay,
108991:                                             uint32_t aType)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aCallback);
     1: 
     1:   ReleaseCallback();
     1:   mCallbackType = CALLBACK_TYPE_INTERFACE;
     1:   mCallback.i = aCallback;
     1:   NS_ADDREF(mCallback.i);
     1: 
     1:   return InitCommon(aType, aDelay);
     1: }
     1: 
     1: NS_IMETHODIMP nsTimerImpl::Init(nsIObserver *aObserver,
108991:                                 uint32_t aDelay,
108991:                                 uint32_t aType)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aObserver);
     1: 
     1:   ReleaseCallback();
     1:   mCallbackType = CALLBACK_TYPE_OBSERVER;
     1:   mCallback.o = aObserver;
     1:   NS_ADDREF(mCallback.o);
     1: 
     1:   return InitCommon(aType, aDelay);
     1: }
     1: 
     1: NS_IMETHODIMP nsTimerImpl::Cancel()
     1: {
 80486:   mCanceled = true;
     1: 
     1:   if (gThread)
     1:     gThread->RemoveTimer(this);
     1: 
  7133:   ReleaseCallback();
  7133: 
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsTimerImpl::SetDelay(uint32_t aDelay)
     1: {
 24552:   if (mCallbackType == CALLBACK_TYPE_UNKNOWN && mType == TYPE_ONE_SHOT) {
 24552:     // This may happen if someone tries to re-use a one-shot timer
 24552:     // by re-setting delay instead of reinitializing the timer.
 24552:     NS_ERROR("nsITimer->SetDelay() called when the "
 24552:              "one-shot timer is not set up.");
 24552:     return NS_ERROR_NOT_INITIALIZED;
 24552:   }
 24552: 
     1:   // If we're already repeating precisely, update mTimeout now so that the
     1:   // new delay takes effect in the future.
 48031:   if (!mTimeout.IsNull() && mType == TYPE_REPEATING_PRECISE)
 48031:     mTimeout = TimeStamp::Now();
     1: 
     1:   SetDelayInternal(aDelay);
     1: 
     1:   if (!mFiring && gThread)
     1:     gThread->TimerDelayChanged(this);
     1: 
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsTimerImpl::GetDelay(uint32_t* aDelay)
     1: {
     1:   *aDelay = mDelay;
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsTimerImpl::SetType(uint32_t aType)
     1: {
108991:   mType = (uint8_t)aType;
     1:   // XXX if this is called, we should change the actual type.. this could effect
     1:   // repeating timers.  we need to ensure in Fire() that if mType has changed
     1:   // during the callback that we don't end up with the timer in the queue twice.
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsTimerImpl::GetType(uint32_t* aType)
     1: {
     1:   *aType = mType;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsTimerImpl::GetClosure(void** aClosure)
     1: {
     1:   *aClosure = mClosure;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP nsTimerImpl::GetCallback(nsITimerCallback **aCallback)
     1: {
     1:   if (mCallbackType == CALLBACK_TYPE_INTERFACE)
     1:     NS_IF_ADDREF(*aCallback = mCallback.i);
  7246:   else if (mTimerCallbackWhileFiring)
  7246:     NS_ADDREF(*aCallback = mTimerCallbackWhileFiring);
     1:   else
106838:     *aCallback = nullptr;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
 16177: NS_IMETHODIMP nsTimerImpl::GetTarget(nsIEventTarget** aTarget)
 16177: {
 16177:   NS_IF_ADDREF(*aTarget = mEventTarget);
 16177:   return NS_OK;
 16177: }
 16177: 
 16177: 
 16177: NS_IMETHODIMP nsTimerImpl::SetTarget(nsIEventTarget* aTarget)
 16177: {
 16177:   NS_ENSURE_TRUE(mCallbackType == CALLBACK_TYPE_UNKNOWN,
 16177:                  NS_ERROR_ALREADY_INITIALIZED);
 16177: 
 16177:   if (aTarget)
 16177:     mEventTarget = aTarget;
 16177:   else
 16177:     mEventTarget = static_cast<nsIEventTarget*>(NS_GetCurrentThread());
 16177:   return NS_OK;
 16177: }
 16177: 
 16177: 
     1: void nsTimerImpl::Fire()
     1: {
     1:   if (mCanceled)
     1:     return;
     1: 
 84290:   SAMPLE_LABEL("Timer", "Fire");
 84290: 
 48031:   TimeStamp now = TimeStamp::Now();
     1: #ifdef DEBUG_TIMERS
120415:   if (PR_LOG_TEST(GetTimerLog(), PR_LOG_DEBUG)) {
 48031:     TimeDuration   a = now - mStart; // actual delay in intervals
 48031:     TimeDuration   b = TimeDuration::FromMilliseconds(mDelay); // expected delay in intervals
 48031:     TimeDuration   delta = (a > b) ? a - b : b - a;
108991:     uint32_t       d = delta.ToMilliseconds(); // delta in ms
     1:     sDeltaSum += d;
     1:     sDeltaSumSquared += double(d) * double(d);
     1:     sDeltaNum++;
     1: 
120415:     PR_LOG(GetTimerLog(), PR_LOG_DEBUG, ("[this=%p] expected delay time %4ums\n", this, mDelay));
120415:     PR_LOG(GetTimerLog(), PR_LOG_DEBUG, ("[this=%p] actual delay time   %fms\n", this, a.ToMilliseconds()));
120415:     PR_LOG(GetTimerLog(), PR_LOG_DEBUG, ("[this=%p] (mType is %d)       -------\n", this, mType));
120415:     PR_LOG(GetTimerLog(), PR_LOG_DEBUG, ("[this=%p]     delta           %4dms\n", this, (a > b) ? (int32_t)d : -(int32_t)d));
     1: 
     1:     mStart = mStart2;
 48082:     mStart2 = TimeStamp();
     1:   }
     1: #endif
     1: 
 48031:   TimeStamp timeout = mTimeout;
 69095:   if (IsRepeatingPrecisely()) {
     1:     // Precise repeating timers advance mTimeout by mDelay without fail before
     1:     // calling Fire().
 48031:     timeout -= TimeDuration::FromMilliseconds(mDelay);
     1:   }
 51588:   if (gThread)
 51588:     gThread->UpdateFilter(mDelay, timeout, now);
     1: 
  7246:   if (mCallbackType == CALLBACK_TYPE_INTERFACE)
  7246:     mTimerCallbackWhileFiring = mCallback.i;
 80486:   mFiring = true;
     1:   
  7133:   // Handle callbacks that re-init the timer, but avoid leaking.
  7133:   // See bug 330128.
  7133:   CallbackUnion callback = mCallback;
108991:   unsigned callbackType = mCallbackType;
  7133:   if (callbackType == CALLBACK_TYPE_INTERFACE)
  7133:     NS_ADDREF(callback.i);
  7133:   else if (callbackType == CALLBACK_TYPE_OBSERVER)
  7133:     NS_ADDREF(callback.o);
  7133:   ReleaseCallback();
  7133: 
  7133:   switch (callbackType) {
     1:     case CALLBACK_TYPE_FUNC:
  7133:       callback.c(this, mClosure);
     1:       break;
     1:     case CALLBACK_TYPE_INTERFACE:
  7133:       callback.i->Notify(this);
     1:       break;
     1:     case CALLBACK_TYPE_OBSERVER:
  7133:       callback.o->Observe(static_cast<nsITimer*>(this),
     1:                           NS_TIMER_CALLBACK_TOPIC,
106838:                           nullptr);
     1:       break;
     1:     default:;
     1:   }
     1: 
  7133:   // If the callback didn't re-init the timer, and it's not a one-shot timer,
  7133:   // restore the callback state.
 10566:   if (mCallbackType == CALLBACK_TYPE_UNKNOWN &&
 10566:       mType != TYPE_ONE_SHOT && !mCanceled) {
  7133:     mCallback = callback;
  7133:     mCallbackType = callbackType;
  7133:   } else {
  7133:     // The timer was a one-shot, or the callback was reinitialized.
  7133:     if (callbackType == CALLBACK_TYPE_INTERFACE)
  7133:       NS_RELEASE(callback.i);
  7133:     else if (callbackType == CALLBACK_TYPE_OBSERVER)
  7133:       NS_RELEASE(callback.o);
  7133:   }
  7133: 
 80486:   mFiring = false;
106838:   mTimerCallbackWhileFiring = nullptr;
     1: 
     1: #ifdef DEBUG_TIMERS
120415:   if (PR_LOG_TEST(GetTimerLog(), PR_LOG_DEBUG)) {
120415:     PR_LOG(GetTimerLog(), PR_LOG_DEBUG,
 48031:            ("[this=%p] Took %fms to fire timer callback\n",
 48031:             this, (TimeStamp::Now() - now).ToMilliseconds()));
     1:   }
     1: #endif
     1: 
 69095:   // Reschedule repeating timers, except REPEATING_PRECISE which already did
 69095:   // that in PostTimerEvent, but make sure that we aren't armed already (which
 69095:   // can happen if the callback reinitialized the timer).
 69095:   if (IsRepeating() && mType != TYPE_REPEATING_PRECISE && !mArmed) {
 69095:     if (mType == TYPE_REPEATING_SLACK)
 69095:       SetDelayInternal(mDelay); // force mTimeout to be recomputed.  For
 69095:                                 // REPEATING_PRECISE_CAN_SKIP timers this has
 69095:                                 // already happened.
     1:     if (gThread)
     1:       gThread->AddTimer(this);
     1:   }
     1: }
     1: 
 92122: void nsTimerEvent::Init()
 92122: {
 92122:   sAllocator = new TimerEventAllocator();
 92122:   static const size_t kBucketSizes[] = {sizeof(nsTimerEvent)};
108991:   static const int32_t kNumBuckets = mozilla::ArrayLength(kBucketSizes);
108991:   static const int32_t kInitialPoolSize = 1024 * sizeof(nsTimerEvent);
 92122:   sAllocator->Init("TimerEventPool", kBucketSizes, kNumBuckets, kInitialPoolSize);
     1: }
     1: 
 92122: void nsTimerEvent::Shutdown()
 92122: {
133079:   sCanDeleteAllocator = true;
133079:   DeleteAllocatorIfNeeded();
133079: }
133079: 
133079: void nsTimerEvent::DeleteAllocatorIfNeeded()
133079: {
133079:   if (sCanDeleteAllocator && sAllocatorUsers == 0) {
 92122:     delete sAllocator;
106838:     sAllocator = nullptr;
     1:   }
133079: }
     1: 
     1: NS_IMETHODIMP nsTimerEvent::Run()
     1: {
     1:   nsRefPtr<nsTimerImpl> timer;
     1:   timer.swap(mTimer);
     1: 
     1:   if (mGeneration != timer->GetGeneration())
     1:     return NS_OK;
     1: 
     1: #ifdef DEBUG_TIMERS
120415:   if (PR_LOG_TEST(GetTimerLog(), PR_LOG_DEBUG)) {
 48031:     TimeStamp now = TimeStamp::Now();
120415:     PR_LOG(GetTimerLog(), PR_LOG_DEBUG,
 48031:            ("[this=%p] time between PostTimerEvent() and Fire(): %fms\n",
 48031:             this, (now - mInitTime).ToMilliseconds()));
     1:   }
     1: #endif
     1: 
     1:   timer->Fire();
     1: 
     1:   return NS_OK;
     1: }
     1: 
 12852: nsresult nsTimerImpl::PostTimerEvent()
     1: {
     1:   // XXX we may want to reuse this nsTimerEvent in the case of repeating timers.
     1: 
     1:   // Since TimerThread addref'd 'this' for us, we don't need to addref here.
     1:   // We will release in destroyMyEvent.  We need to copy the generation number
     1:   // from this timer into the event, so we can avoid firing a timer that was
     1:   // re-initialized after being canceled.
     1: 
 12852:   nsRefPtr<nsTimerEvent> event = new nsTimerEvent(this, mGeneration);
     1:   if (!event)
 12852:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1: #ifdef DEBUG_TIMERS
120415:   if (PR_LOG_TEST(GetTimerLog(), PR_LOG_DEBUG)) {
 48031:     event->mInitTime = TimeStamp::Now();
     1:   }
     1: #endif
     1: 
     1:   // If this is a repeating precise timer, we need to calculate the time for
     1:   // the next timer to fire before we make the callback.
 69095:   if (IsRepeatingPrecisely()) {
     1:     SetDelayInternal(mDelay);
 69095: 
 69095:     // But only re-arm REPEATING_PRECISE timers.
 69095:     if (gThread && mType == TYPE_REPEATING_PRECISE) {
 12852:       nsresult rv = gThread->AddTimer(this);
 12852:       if (NS_FAILED(rv))
 12852:         return rv;
 12852:     }
     1:   }
     1: 
 16177:   nsresult rv = mEventTarget->Dispatch(event, NS_DISPATCH_NORMAL);
 12852:   if (NS_FAILED(rv) && gThread)
 12852:     gThread->RemoveTimer(this);
 12852:   return rv;
     1: }
     1: 
108991: void nsTimerImpl::SetDelayInternal(uint32_t aDelay)
     1: {
 48031:   TimeDuration delayInterval = TimeDuration::FromMilliseconds(aDelay);
     1: 
     1:   mDelay = aDelay;
     1: 
 48031:   TimeStamp now = TimeStamp::Now();
 48031:   if (mTimeout.IsNull() || mType != TYPE_REPEATING_PRECISE)
     1:     mTimeout = now;
     1: 
     1:   mTimeout += delayInterval;
     1: 
     1: #ifdef DEBUG_TIMERS
120415:   if (PR_LOG_TEST(GetTimerLog(), PR_LOG_DEBUG)) {
 48031:     if (mStart.IsNull())
     1:       mStart = now;
     1:     else
     1:       mStart2 = now;
     1:   }
     1: #endif
     1: }
     1: 
     1: // NOT FOR PUBLIC CONSUMPTION!
     1: nsresult
     1: NS_NewTimer(nsITimer* *aResult, nsTimerCallbackFunc aCallback, void *aClosure,
108991:             uint32_t aDelay, uint32_t aType)
     1: {
     1:     nsTimerImpl* timer = new nsTimerImpl();
106838:     if (timer == nullptr)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     NS_ADDREF(timer);
     1: 
     1:     nsresult rv = timer->InitWithFuncCallback(aCallback, aClosure, 
     1:                                               aDelay, aType);
     1:     if (NS_FAILED(rv)) {
     1:         NS_RELEASE(timer);
     1:         return rv;
     1:     }
     1: 
     1:     *aResult = timer;
     1:     return NS_OK;
     1: }
