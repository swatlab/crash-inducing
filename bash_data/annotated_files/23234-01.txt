    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set sw=4 ts=8 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS regular expressions, after Perl.
    1:  */
    1: #include "jsstddef.h"
    1: #include <stdlib.h>
    1: #include <string.h>
   22: #include <stdarg.h>
    1: #include "jstypes.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
20896: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsregexp.h"
    1: #include "jsscan.h"
12581: #include "jsscope.h"
    1: #include "jsstr.h"
    1: 
21497: #ifdef JS_TRACER
21491: #include "jstracer.h"
21491: using namespace avmplus;
21491: using namespace nanojit;
21498: 
21509: /* 
21509:  * FIXME  Duplicated with jstracer.cpp, doing it this way for now
21509:  *        to keep it private to files that need it. 
21509:  */
21498: #ifdef JS_JIT_SPEW
21498: static bool verbose_debug = getenv("TRACEMONKEY") && strstr(getenv("TRACEMONKEY"), "verbose");
21498: #define debug_only_v(x) if (verbose_debug) { x; }
21498: #else
21498: #define debug_only_v(x)
21498: #endif
21497: #endif
21491: 
    1: typedef enum REOp {
   22: #define REOP_DEF(opcode, name) opcode,
   22: #include "jsreops.tbl"
   22: #undef REOP_DEF
 6663:     REOP_LIMIT /* META: no operator >= to this */
    1: } REOp;
    1: 
 3164: #define REOP_IS_SIMPLE(op)  ((op) <= REOP_NCLASS)
    1: 
  170: #ifdef REGEXP_DEBUG
   22: const char *reop_names[] = {
   22: #define REOP_DEF(opcode, name) name,
   22: #include "jsreops.tbl"
   22: #undef REOP_DEF
   22:     NULL
   22: };
   22: #endif
   22: 
   22: #ifdef __GNUC__
   22: static int
   22: re_debug(const char *fmt, ...) __attribute__ ((format(printf, 1, 2)));
   22: #endif
   22: 
   22: #ifdef REGEXP_DEBUG
   22: static int
   22: re_debug(const char *fmt, ...)
   22: {
   22:     va_list ap;
   22:     int retval;
   22: 
   22:     va_start(ap, fmt);
   22:     retval = vprintf(fmt, ap);
   22:     va_end(ap);
   22:     return retval;
   22: }
   22: 
   22: static void
   22: re_debug_chars(const jschar *chrs, size_t length)
   22: {
   22:     int i = 0;
   22: 
   22:     printf(" \"");
   22:     while (*chrs && i++ < length) {
   22:         putchar((char)*chrs++);
   22:     }
   22:     printf("\"");
   22: }
   22: #else  /* !REGEXP_DEBUG */
   22: /* This should be optimized to a no-op by our tier-1 compilers. */
   22: static int
   22: re_debug(const char *fmt, ...)
   22: {
   22:     return 0;
   22: }
   22: 
   22: static void
   22: re_debug_chars(const jschar *chrs, size_t length)
   22: {
   22: }
   22: #endif /* !REGEXP_DEBUG */
   22: 
    1: struct RENode {
    1:     REOp            op;         /* r.e. op bytecode */
    1:     RENode          *next;      /* next in concatenation order */
    1:     void            *kid;       /* first operand */
    1:     union {
    1:         void        *kid2;      /* second operand */
    1:         jsint       num;        /* could be a number */
    1:         size_t      parenIndex; /* or a parenthesis index */
    1:         struct {                /* or a quantifier range */
    1:             uintN  min;
    1:             uintN  max;
    1:             JSPackedBool greedy;
    1:         } range;
    1:         struct {                /* or a character class */
    1:             size_t  startIndex;
    1:             size_t  kidlen;     /* length of string at kid, in jschars */
    1:             size_t  index;      /* index into class list */
    1:             uint16  bmsize;     /* bitmap size, based on max char code */
    1:             JSPackedBool sense;
    1:         } ucclass;
    1:         struct {                /* or a literal sequence */
    1:             jschar  chr;        /* of one character */
    1:             size_t  length;     /* or many (via the kid) */
    1:         } flat;
    1:         struct {
    1:             RENode  *kid2;      /* second operand from ALT */
    1:             jschar  ch1;        /* match char for ALTPREREQ */
    1:             jschar  ch2;        /* ditto, or class index for ALTPREREQ2 */
    1:         } altprereq;
    1:     } u;
    1: };
    1: 
    1: #define RE_IS_LETTER(c)     (((c >= 'A') && (c <= 'Z')) ||                    \
    1:                              ((c >= 'a') && (c <= 'z')) )
    1: #define RE_IS_LINE_TERM(c)  ((c == '\n') || (c == '\r') ||                    \
    1:                              (c == LINE_SEPARATOR) || (c == PARA_SEPARATOR))
    1: 
    1: #define CLASS_CACHE_SIZE    4
    1: 
    1: typedef struct CompilerState {
    1:     JSContext       *context;
    1:     JSTokenStream   *tokenStream; /* For reporting errors */
    1:     const jschar    *cpbegin;
    1:     const jschar    *cpend;
    1:     const jschar    *cp;
    1:     size_t          parenCount;
    1:     size_t          classCount;   /* number of [] encountered */
    1:     size_t          treeDepth;    /* maximum depth of parse tree */
    1:     size_t          progLength;   /* estimated bytecode length */
    1:     RENode          *result;
    1:     size_t          classBitmapsMem; /* memory to hold all class bitmaps */
    1:     struct {
    1:         const jschar *start;        /* small cache of class strings */
    1:         size_t length;              /* since they're often the same */
    1:         size_t index;
    1:     } classCache[CLASS_CACHE_SIZE];
    1:     uint16          flags;
    1: } CompilerState;
    1: 
    1: typedef struct EmitStateStackEntry {
    1:     jsbytecode      *altHead;       /* start of REOP_ALT* opcode */
    1:     jsbytecode      *nextAltFixup;  /* fixup pointer to next-alt offset */
    1:     jsbytecode      *nextTermFixup; /* fixup ptr. to REOP_JUMP offset */
    1:     jsbytecode      *endTermFixup;  /* fixup ptr. to REOPT_ALTPREREQ* offset */
    1:     RENode          *continueNode;  /* original REOP_ALT* node being stacked */
    1:     jsbytecode      continueOp;     /* REOP_JUMP or REOP_ENDALT continuation */
    1:     JSPackedBool    jumpToJumpFlag; /* true if we've patched jump-to-jump to
    1:                                        avoid 16-bit unsigned offset overflow */
    1: } EmitStateStackEntry;
    1: 
    1: /*
    1:  * Immediate operand sizes and getter/setters.  Unlike the ones in jsopcode.h,
    1:  * the getters and setters take the pc of the offset, not of the opcode before
    1:  * the offset.
    1:  */
    1: #define ARG_LEN             2
    1: #define GET_ARG(pc)         ((uint16)(((pc)[0] << 8) | (pc)[1]))
    1: #define SET_ARG(pc, arg)    ((pc)[0] = (jsbytecode) ((arg) >> 8),       \
    1:                              (pc)[1] = (jsbytecode) (arg))
    1: 
    1: #define OFFSET_LEN          ARG_LEN
    1: #define OFFSET_MAX          (JS_BIT(ARG_LEN * 8) - 1)
    1: #define GET_OFFSET(pc)      GET_ARG(pc)
    1: 
    1: /*
    1:  * Maximum supported tree depth is maximum size of EmitStateStackEntry stack.
    1:  * For sanity, we limit it to 2^24 bytes.
    1:  */
    1: #define TREE_DEPTH_MAX  (JS_BIT(24) / sizeof(EmitStateStackEntry))
    1: 
    1: /*
    1:  * The maximum memory that can be allocated for class bitmaps.
    1:  * For sanity, we limit it to 2^24 bytes.
    1:  */
    1: #define CLASS_BITMAPS_MEM_LIMIT JS_BIT(24)
    1: 
    1: /*
    1:  * Functions to get size and write/read bytecode that represent small indexes
    1:  * compactly.
    1:  * Each byte in the code represent 7-bit chunk of the index. 8th bit when set
    1:  * indicates that the following byte brings more bits to the index. Otherwise
    1:  * this is the last byte in the index bytecode representing highest index bits.
    1:  */
    1: static size_t
    1: GetCompactIndexWidth(size_t index)
    1: {
    1:     size_t width;
    1: 
    1:     for (width = 1; (index >>= 7) != 0; ++width) { }
    1:     return width;
    1: }
    1: 
16284: static JS_ALWAYS_INLINE jsbytecode *
    1: WriteCompactIndex(jsbytecode *pc, size_t index)
    1: {
    1:     size_t next;
    1: 
    1:     while ((next = index >> 7) != 0) {
    1:         *pc++ = (jsbytecode)(index | 0x80);
    1:         index = next;
    1:     }
    1:     *pc++ = (jsbytecode)index;
    1:     return pc;
    1: }
    1: 
16284: static JS_ALWAYS_INLINE jsbytecode *
    1: ReadCompactIndex(jsbytecode *pc, size_t *result)
    1: {
    1:     size_t nextByte;
    1: 
    1:     nextByte = *pc++;
    1:     if ((nextByte & 0x80) == 0) {
    1:         /*
    1:          * Short-circuit the most common case when compact index <= 127.
    1:          */
    1:         *result = nextByte;
    1:     } else {
    1:         size_t shift = 7;
    1:         *result = 0x7F & nextByte;
    1:         do {
    1:             nextByte = *pc++;
    1:             *result |= (nextByte & 0x7F) << shift;
    1:             shift += 7;
    1:         } while ((nextByte & 0x80) != 0);
    1:     }
    1:     return pc;
    1: }
    1: 
    1: typedef struct RECapture {
    1:     ptrdiff_t index;           /* start of contents, -1 for empty  */
    1:     size_t length;             /* length of capture */
    1: } RECapture;
    1: 
    1: typedef struct REMatchState {
    1:     const jschar *cp;
    1:     RECapture parens[1];      /* first of 're->parenCount' captures,
    1:                                  allocated at end of this struct */
    1: } REMatchState;
    1: 
    1: struct REBackTrackData;
    1: 
    1: typedef struct REProgState {
    1:     jsbytecode *continue_pc;        /* current continuation data */
    1:     jsbytecode continue_op;
    1:     ptrdiff_t index;                /* progress in text */
    1:     size_t parenSoFar;              /* highest indexed paren started */
    1:     union {
    1:         struct {
    1:             uintN min;             /* current quantifier limits */
    1:             uintN max;
    1:         } quantifier;
    1:         struct {
    1:             size_t top;             /* backtrack stack state */
    1:             size_t sz;
    1:         } assertion;
    1:     } u;
    1: } REProgState;
    1: 
    1: typedef struct REBackTrackData {
    1:     size_t sz;                      /* size of previous stack entry */
    1:     jsbytecode *backtrack_pc;       /* where to backtrack to */
    1:     jsbytecode backtrack_op;
    1:     const jschar *cp;               /* index in text of match at backtrack */
    1:     size_t parenIndex;              /* start index of saved paren contents */
    1:     size_t parenCount;              /* # of saved paren contents */
    1:     size_t saveStateStackTop;       /* number of parent states */
    1:     /* saved parent states follow */
    1:     /* saved paren contents follow */
    1: } REBackTrackData;
    1: 
    1: #define INITIAL_STATESTACK  100
    1: #define INITIAL_BACKTRACK   8000
    1: 
    1: typedef struct REGlobalData {
    1:     JSContext *cx;
    1:     JSRegExp *regexp;               /* the RE in execution */
    1:     JSBool ok;                      /* runtime error (out_of_memory only?) */
    1:     size_t start;                   /* offset to start at */
    1:     ptrdiff_t skipped;              /* chars skipped anchoring this r.e. */
    1:     const jschar    *cpbegin;       /* text base address */
    1:     const jschar    *cpend;         /* text limit address */
    1: 
    1:     REProgState *stateStack;        /* stack of state of current parents */
    1:     size_t stateStackTop;
    1:     size_t stateStackLimit;
    1: 
    1:     REBackTrackData *backTrackStack;/* stack of matched-so-far positions */
    1:     REBackTrackData *backTrackSP;
    1:     size_t backTrackStackSize;
    1:     size_t cursz;                   /* size of current stack entry */
    1:     size_t backTrackCount;          /* how many times we've backtracked */
    1:     size_t backTrackLimit;          /* upper limit on backtrack states */
    1: } REGlobalData;
    1: 
    1: /*
    1:  * 1. If IgnoreCase is false, return ch.
    1:  * 2. Let u be ch converted to upper case as if by calling
    1:  *    String.prototype.toUpperCase on the one-character string ch.
    1:  * 3. If u does not consist of a single character, return ch.
    1:  * 4. Let cu be u's character.
    1:  * 5. If ch's code point value is greater than or equal to decimal 128 and cu's
    1:  *    code point value is less than decimal 128, then return ch.
    1:  * 6. Return cu.
    1:  */
16284: static JS_ALWAYS_INLINE uintN
10332: upcase(uintN ch)
    1: {
10332:     uintN cu;
10332: 
10332:     JS_ASSERT((uintN) (jschar) ch == ch);
10332:     if (ch < 128) {
10332:         if (ch - (uintN) 'a' <= (uintN) ('z' - 'a'))
10332:             ch -= (uintN) ('a' - 'A');
    1:         return ch;
10332:     }
10332: 
10332:     cu = JS_TOUPPER(ch);
10332:     return (cu < 128) ? ch : cu;
10332: }
10332: 
16284: static JS_ALWAYS_INLINE uintN
10332: downcase(uintN ch)
    1: {
10332:     JS_ASSERT((uintN) (jschar) ch == ch);
10332:     if (ch < 128) {
10332:         if (ch - (uintN) 'A' <= (uintN) ('Z' - 'A'))
10332:             ch += (uintN) ('a' - 'A');
    1:         return ch;
10332:     }
10332: 
10332:     return JS_TOLOWER(ch);
    1: }
    1: 
    1: /* Construct and initialize an RENode, returning NULL for out-of-memory */
    1: static RENode *
    1: NewRENode(CompilerState *state, REOp op)
    1: {
    1:     JSContext *cx;
    1:     RENode *ren;
    1: 
    1:     cx = state->context;
    1:     JS_ARENA_ALLOCATE_CAST(ren, RENode *, &cx->tempPool, sizeof *ren);
    1:     if (!ren) {
 8296:         js_ReportOutOfScriptQuota(cx);
    1:         return NULL;
    1:     }
    1:     ren->op = op;
    1:     ren->next = NULL;
    1:     ren->kid = NULL;
    1:     return ren;
    1: }
    1: 
    1: /*
    1:  * Validates and converts hex ascii value.
    1:  */
    1: static JSBool
    1: isASCIIHexDigit(jschar c, uintN *digit)
    1: {
    1:     uintN cv = c;
    1: 
    1:     if (cv < '0')
    1:         return JS_FALSE;
    1:     if (cv <= '9') {
    1:         *digit = cv - '0';
    1:         return JS_TRUE;
    1:     }
    1:     cv |= 0x20;
    1:     if (cv >= 'a' && cv <= 'f') {
    1:         *digit = cv - 'a' + 10;
    1:         return JS_TRUE;
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: 
    1: typedef struct {
    1:     REOp op;
    1:     const jschar *errPos;
    1:     size_t parenIndex;
    1: } REOpData;
    1: 
 7984: static JSBool
 7984: ReportRegExpErrorHelper(CompilerState *state, uintN flags, uintN errorNumber,
 7984:                         const jschar *arg)
 7984: {
 7984:     if (state->tokenStream) {
 7984:         return js_ReportCompileErrorNumber(state->context, state->tokenStream,
 7984:                                            NULL, JSREPORT_UC | flags,
 7984:                                            errorNumber, arg);
 7984:     }
 7984:     return JS_ReportErrorFlagsAndNumberUC(state->context, flags,
 7984:                                           js_GetErrorMessage, NULL,
 7984:                                           errorNumber, arg);
 7984: }
 7984: 
 7984: static JSBool
 7984: ReportRegExpError(CompilerState *state, uintN flags, uintN errorNumber)
 7984: {
 7984:     return ReportRegExpErrorHelper(state, flags, errorNumber, NULL);
 7984: }
    1: 
    1: /*
    1:  * Process the op against the two top operands, reducing them to a single
    1:  * operand in the penultimate slot. Update progLength and treeDepth.
    1:  */
    1: static JSBool
    1: ProcessOp(CompilerState *state, REOpData *opData, RENode **operandStack,
    1:           intN operandSP)
    1: {
    1:     RENode *result;
    1: 
    1:     switch (opData->op) {
    1:       case REOP_ALT:
    1:         result = NewRENode(state, REOP_ALT);
    1:         if (!result)
    1:             return JS_FALSE;
    1:         result->kid = operandStack[operandSP - 2];
    1:         result->u.kid2 = operandStack[operandSP - 1];
    1:         operandStack[operandSP - 2] = result;
    1: 
    1:         if (state->treeDepth == TREE_DEPTH_MAX) {
 7984:             ReportRegExpError(state, JSREPORT_ERROR, JSMSG_REGEXP_TOO_COMPLEX);
    1:             return JS_FALSE;
    1:         }
    1:         ++state->treeDepth;
    1: 
    1:         /*
    1:          * Look at both alternates to see if there's a FLAT or a CLASS at
    1:          * the start of each. If so, use a prerequisite match.
    1:          */
    1:         if (((RENode *) result->kid)->op == REOP_FLAT &&
    1:             ((RENode *) result->u.kid2)->op == REOP_FLAT &&
    1:             (state->flags & JSREG_FOLD) == 0) {
    1:             result->op = REOP_ALTPREREQ;
    1:             result->u.altprereq.ch1 = ((RENode *) result->kid)->u.flat.chr;
    1:             result->u.altprereq.ch2 = ((RENode *) result->u.kid2)->u.flat.chr;
    1:             /* ALTPREREQ, <end>, uch1, uch2, <next>, ...,
    1:                                             JUMP, <end> ... ENDALT */
    1:             state->progLength += 13;
    1:         }
    1:         else
    1:         if (((RENode *) result->kid)->op == REOP_CLASS &&
    1:             ((RENode *) result->kid)->u.ucclass.index < 256 &&
    1:             ((RENode *) result->u.kid2)->op == REOP_FLAT &&
    1:             (state->flags & JSREG_FOLD) == 0) {
    1:             result->op = REOP_ALTPREREQ2;
    1:             result->u.altprereq.ch1 = ((RENode *) result->u.kid2)->u.flat.chr;
    1:             result->u.altprereq.ch2 = ((RENode *) result->kid)->u.ucclass.index;
    1:             /* ALTPREREQ2, <end>, uch1, uch2, <next>, ...,
    1:                                             JUMP, <end> ... ENDALT */
    1:             state->progLength += 13;
    1:         }
    1:         else
    1:         if (((RENode *) result->kid)->op == REOP_FLAT &&
    1:             ((RENode *) result->u.kid2)->op == REOP_CLASS &&
    1:             ((RENode *) result->u.kid2)->u.ucclass.index < 256 &&
    1:             (state->flags & JSREG_FOLD) == 0) {
    1:             result->op = REOP_ALTPREREQ2;
    1:             result->u.altprereq.ch1 = ((RENode *) result->kid)->u.flat.chr;
    1:             result->u.altprereq.ch2 =
    1:                 ((RENode *) result->u.kid2)->u.ucclass.index;
    1:             /* ALTPREREQ2, <end>, uch1, uch2, <next>, ...,
    1:                                           JUMP, <end> ... ENDALT */
    1:             state->progLength += 13;
    1:         }
    1:         else {
    1:             /* ALT, <next>, ..., JUMP, <end> ... ENDALT */
    1:             state->progLength += 7;
    1:         }
    1:         break;
    1: 
    1:       case REOP_CONCAT:
    1:         result = operandStack[operandSP - 2];
    1:         while (result->next)
    1:             result = result->next;
    1:         result->next = operandStack[operandSP - 1];
    1:         break;
    1: 
    1:       case REOP_ASSERT:
    1:       case REOP_ASSERT_NOT:
    1:       case REOP_LPARENNON:
    1:       case REOP_LPAREN:
    1:         /* These should have been processed by a close paren. */
 7984:         ReportRegExpErrorHelper(state, JSREPORT_ERROR, JSMSG_MISSING_PAREN,
 7984:                                 opData->errPos);
    1:         return JS_FALSE;
    1: 
    1:       default:;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Parser forward declarations.
    1:  */
    1: static JSBool ParseTerm(CompilerState *state);
    1: static JSBool ParseQuantifier(CompilerState *state);
    1: static intN ParseMinMaxQuantifier(CompilerState *state, JSBool ignoreValues);
    1: 
    1: /*
    1:  * Top-down regular expression grammar, based closely on Perl4.
    1:  *
    1:  *  regexp:     altern                  A regular expression is one or more
    1:  *              altern '|' regexp       alternatives separated by vertical bar.
    1:  */
    1: #define INITIAL_STACK_SIZE  128
    1: 
    1: static JSBool
    1: ParseRegExp(CompilerState *state)
    1: {
    1:     size_t parenIndex;
    1:     RENode *operand;
    1:     REOpData *operatorStack;
    1:     RENode **operandStack;
    1:     REOp op;
    1:     intN i;
    1:     JSBool result = JS_FALSE;
    1: 
    1:     intN operatorSP = 0, operatorStackSize = INITIAL_STACK_SIZE;
    1:     intN operandSP = 0, operandStackSize = INITIAL_STACK_SIZE;
    1: 
    1:     /* Watch out for empty regexp */
    1:     if (state->cp == state->cpend) {
    1:         state->result = NewRENode(state, REOP_EMPTY);
    1:         return (state->result != NULL);
    1:     }
    1: 
    1:     operatorStack = (REOpData *)
    1:         JS_malloc(state->context, sizeof(REOpData) * operatorStackSize);
    1:     if (!operatorStack)
    1:         return JS_FALSE;
    1: 
    1:     operandStack = (RENode **)
    1:         JS_malloc(state->context, sizeof(RENode *) * operandStackSize);
    1:     if (!operandStack)
    1:         goto out;
    1: 
    1:     for (;;) {
    1:         parenIndex = state->parenCount;
    1:         if (state->cp == state->cpend) {
    1:             /*
    1:              * If we are at the end of the regexp and we're short one or more
    1:              * operands, the regexp must have the form /x|/ or some such, with
    1:              * left parentheses making us short more than one operand.
    1:              */
    1:             if (operatorSP >= operandSP) {
    1:                 operand = NewRENode(state, REOP_EMPTY);
    1:                 if (!operand)
    1:                     goto out;
    1:                 goto pushOperand;
    1:             }
    1:         } else {
    1:             switch (*state->cp) {
    1:               case '(':
    1:                 ++state->cp;
    1:                 if (state->cp + 1 < state->cpend &&
    1:                     *state->cp == '?' &&
    1:                     (state->cp[1] == '=' ||
    1:                      state->cp[1] == '!' ||
    1:                      state->cp[1] == ':')) {
    1:                     switch (state->cp[1]) {
    1:                       case '=':
    1:                         op = REOP_ASSERT;
    1:                         /* ASSERT, <next>, ... ASSERTTEST */
    1:                         state->progLength += 4;
    1:                         break;
    1:                       case '!':
    1:                         op = REOP_ASSERT_NOT;
    1:                         /* ASSERTNOT, <next>, ... ASSERTNOTTEST */
    1:                         state->progLength += 4;
    1:                         break;
    1:                       default:
    1:                         op = REOP_LPARENNON;
    1:                         break;
    1:                     }
    1:                     state->cp += 2;
    1:                 } else {
    1:                     op = REOP_LPAREN;
    1:                     /* LPAREN, <index>, ... RPAREN, <index> */
    1:                     state->progLength
    1:                         += 2 * (1 + GetCompactIndexWidth(parenIndex));
    1:                     state->parenCount++;
    1:                     if (state->parenCount == 65535) {
 7984:                         ReportRegExpError(state, JSREPORT_ERROR,
    1:                                           JSMSG_TOO_MANY_PARENS);
    1:                         goto out;
    1:                     }
    1:                 }
    1:                 goto pushOperator;
    1: 
    1:               case ')':
    1:                 /*
    1:                  * If there's no stacked open parenthesis, throw syntax error.
    1:                  */
    1:                 for (i = operatorSP - 1; ; i--) {
    1:                     if (i < 0) {
 7984:                         ReportRegExpError(state, JSREPORT_ERROR,
    1:                                           JSMSG_UNMATCHED_RIGHT_PAREN);
    1:                         goto out;
    1:                     }
    1:                     if (operatorStack[i].op == REOP_ASSERT ||
    1:                         operatorStack[i].op == REOP_ASSERT_NOT ||
    1:                         operatorStack[i].op == REOP_LPARENNON ||
    1:                         operatorStack[i].op == REOP_LPAREN) {
    1:                         break;
    1:                     }
    1:                 }
    1:                 /* FALL THROUGH */
    1: 
    1:               case '|':
    1:                 /* Expected an operand before these, so make an empty one */
    1:                 operand = NewRENode(state, REOP_EMPTY);
    1:                 if (!operand)
    1:                     goto out;
    1:                 goto pushOperand;
    1: 
    1:               default:
    1:                 if (!ParseTerm(state))
    1:                     goto out;
    1:                 operand = state->result;
    1: pushOperand:
    1:                 if (operandSP == operandStackSize) {
 2034:                     RENode **tmp;
    1:                     operandStackSize += operandStackSize;
 2034:                     tmp = (RENode **)
    1:                         JS_realloc(state->context, operandStack,
    1:                                    sizeof(RENode *) * operandStackSize);
 2034:                     if (!tmp)
    1:                         goto out;
 2034:                     operandStack = tmp;
    1:                 }
    1:                 operandStack[operandSP++] = operand;
    1:                 break;
    1:             }
    1:         }
    1: 
    1:         /* At the end; process remaining operators. */
    1: restartOperator:
    1:         if (state->cp == state->cpend) {
    1:             while (operatorSP) {
    1:                 --operatorSP;
    1:                 if (!ProcessOp(state, &operatorStack[operatorSP],
    1:                                operandStack, operandSP))
    1:                     goto out;
    1:                 --operandSP;
    1:             }
    1:             JS_ASSERT(operandSP == 1);
    1:             state->result = operandStack[0];
    1:             result = JS_TRUE;
    1:             goto out;
    1:         }
    1: 
    1:         switch (*state->cp) {
    1:           case '|':
    1:             /* Process any stacked 'concat' operators */
    1:             ++state->cp;
    1:             while (operatorSP &&
    1:                    operatorStack[operatorSP - 1].op == REOP_CONCAT) {
    1:                 --operatorSP;
    1:                 if (!ProcessOp(state, &operatorStack[operatorSP],
    1:                                operandStack, operandSP)) {
    1:                     goto out;
    1:                 }
    1:                 --operandSP;
    1:             }
    1:             op = REOP_ALT;
    1:             goto pushOperator;
    1: 
    1:           case ')':
    1:             /*
    1:              * If there's no stacked open parenthesis, throw syntax error.
    1:              */
    1:             for (i = operatorSP - 1; ; i--) {
    1:                 if (i < 0) {
 7984:                     ReportRegExpError(state, JSREPORT_ERROR,
    1:                                       JSMSG_UNMATCHED_RIGHT_PAREN);
    1:                     goto out;
    1:                 }
    1:                 if (operatorStack[i].op == REOP_ASSERT ||
    1:                     operatorStack[i].op == REOP_ASSERT_NOT ||
    1:                     operatorStack[i].op == REOP_LPARENNON ||
    1:                     operatorStack[i].op == REOP_LPAREN) {
    1:                     break;
    1:                 }
    1:             }
    1:             ++state->cp;
    1: 
    1:             /* Process everything on the stack until the open parenthesis. */
    1:             for (;;) {
    1:                 JS_ASSERT(operatorSP);
    1:                 --operatorSP;
    1:                 switch (operatorStack[operatorSP].op) {
    1:                   case REOP_ASSERT:
    1:                   case REOP_ASSERT_NOT:
    1:                   case REOP_LPAREN:
    1:                     operand = NewRENode(state, operatorStack[operatorSP].op);
    1:                     if (!operand)
    1:                         goto out;
    1:                     operand->u.parenIndex =
    1:                         operatorStack[operatorSP].parenIndex;
    1:                     JS_ASSERT(operandSP);
    1:                     operand->kid = operandStack[operandSP - 1];
    1:                     operandStack[operandSP - 1] = operand;
    1:                     if (state->treeDepth == TREE_DEPTH_MAX) {
 7984:                         ReportRegExpError(state, JSREPORT_ERROR,
    1:                                           JSMSG_REGEXP_TOO_COMPLEX);
    1:                         goto out;
    1:                     }
    1:                     ++state->treeDepth;
    1:                     /* FALL THROUGH */
    1: 
    1:                   case REOP_LPARENNON:
    1:                     state->result = operandStack[operandSP - 1];
    1:                     if (!ParseQuantifier(state))
    1:                         goto out;
    1:                     operandStack[operandSP - 1] = state->result;
    1:                     goto restartOperator;
    1:                   default:
    1:                     if (!ProcessOp(state, &operatorStack[operatorSP],
    1:                                    operandStack, operandSP))
    1:                         goto out;
    1:                     --operandSP;
    1:                     break;
    1:                 }
    1:             }
    1:             break;
    1: 
    1:           case '{':
    1:           {
    1:             const jschar *errp = state->cp;
    1: 
    1:             if (ParseMinMaxQuantifier(state, JS_TRUE) < 0) {
    1:                 /*
    1:                  * This didn't even scan correctly as a quantifier, so we should
    1:                  * treat it as flat.
    1:                  */
    1:                 op = REOP_CONCAT;
    1:                 goto pushOperator;
    1:             }
    1: 
    1:             state->cp = errp;
    1:             /* FALL THROUGH */
    1:           }
    1: 
    1:           case '+':
    1:           case '*':
    1:           case '?':
 7984:             ReportRegExpErrorHelper(state, JSREPORT_ERROR, JSMSG_BAD_QUANTIFIER,
 7984:                                     state->cp);
    1:             result = JS_FALSE;
    1:             goto out;
    1: 
    1:           default:
    1:             /* Anything else is the start of the next term. */
    1:             op = REOP_CONCAT;
    1: pushOperator:
    1:             if (operatorSP == operatorStackSize) {
 2034:                 REOpData *tmp;
    1:                 operatorStackSize += operatorStackSize;
 2034:                 tmp = (REOpData *)
    1:                     JS_realloc(state->context, operatorStack,
    1:                                sizeof(REOpData) * operatorStackSize);
 2034:                 if (!tmp)
    1:                     goto out;
 2034:                 operatorStack = tmp;
    1:             }
    1:             operatorStack[operatorSP].op = op;
    1:             operatorStack[operatorSP].errPos = state->cp;
    1:             operatorStack[operatorSP++].parenIndex = parenIndex;
    1:             break;
    1:         }
    1:     }
    1: out:
    1:     if (operatorStack)
    1:         JS_free(state->context, operatorStack);
    1:     if (operandStack)
    1:         JS_free(state->context, operandStack);
    1:     return result;
    1: }
    1: 
    1: /*
    1:  * Hack two bits in CompilerState.flags, for use within FindParenCount to flag
    1:  * its being on the stack, and to propagate errors to its callers.
    1:  */
    1: #define JSREG_FIND_PAREN_COUNT  0x8000
    1: #define JSREG_FIND_PAREN_ERROR  0x4000
    1: 
    1: /*
    1:  * Magic return value from FindParenCount and GetDecimalValue, to indicate
    1:  * overflow beyond GetDecimalValue's max parameter, or a computed maximum if
    1:  * its findMax parameter is non-null.
    1:  */
    1: #define OVERFLOW_VALUE          ((uintN)-1)
    1: 
    1: static uintN
    1: FindParenCount(CompilerState *state)
    1: {
    1:     CompilerState temp;
    1:     int i;
    1: 
    1:     if (state->flags & JSREG_FIND_PAREN_COUNT)
    1:         return OVERFLOW_VALUE;
    1: 
    1:     /*
    1:      * Copy state into temp, flag it so we never report an invalid backref,
    1:      * and reset its members to parse the entire regexp.  This is obviously
    1:      * suboptimal, but GetDecimalValue calls us only if a backref appears to
    1:      * refer to a forward parenthetical, which is rare.
    1:      */
    1:     temp = *state;
    1:     temp.flags |= JSREG_FIND_PAREN_COUNT;
    1:     temp.cp = temp.cpbegin;
    1:     temp.parenCount = 0;
    1:     temp.classCount = 0;
    1:     temp.progLength = 0;
    1:     temp.treeDepth = 0;
    1:     temp.classBitmapsMem = 0;
    1:     for (i = 0; i < CLASS_CACHE_SIZE; i++)
    1:         temp.classCache[i].start = NULL;
    1: 
    1:     if (!ParseRegExp(&temp)) {
    1:         state->flags |= JSREG_FIND_PAREN_ERROR;
    1:         return OVERFLOW_VALUE;
    1:     }
    1:     return temp.parenCount;
    1: }
    1: 
    1: /*
    1:  * Extract and return a decimal value at state->cp.  The initial character c
    1:  * has already been read.  Return OVERFLOW_VALUE if the result exceeds max.
    1:  * Callers who pass a non-null findMax should test JSREG_FIND_PAREN_ERROR in
    1:  * state->flags to discover whether an error occurred under findMax.
    1:  */
    1: static uintN
    1: GetDecimalValue(jschar c, uintN max, uintN (*findMax)(CompilerState *state),
    1:                 CompilerState *state)
    1: {
    1:     uintN value = JS7_UNDEC(c);
    1:     JSBool overflow = (value > max && (!findMax || value > findMax(state)));
    1: 
    1:     /* The following restriction allows simpler overflow checks. */
    1:     JS_ASSERT(max <= ((uintN)-1 - 9) / 10);
    1:     while (state->cp < state->cpend) {
    1:         c = *state->cp;
    1:         if (!JS7_ISDEC(c))
    1:             break;
    1:         value = 10 * value + JS7_UNDEC(c);
    1:         if (!overflow && value > max && (!findMax || value > findMax(state)))
    1:             overflow = JS_TRUE;
    1:         ++state->cp;
    1:     }
    1:     return overflow ? OVERFLOW_VALUE : value;
    1: }
    1: 
    1: /*
    1:  * Calculate the total size of the bitmap required for a class expression.
    1:  */
    1: static JSBool
    1: CalculateBitmapSize(CompilerState *state, RENode *target, const jschar *src,
    1:                     const jschar *end)
    1: {
    1:     uintN max = 0;
    1:     JSBool inRange = JS_FALSE;
    1:     jschar c, rangeStart = 0;
    1:     uintN n, digit, nDigits, i;
    1: 
    1:     target->u.ucclass.bmsize = 0;
    1:     target->u.ucclass.sense = JS_TRUE;
    1: 
    1:     if (src == end)
    1:         return JS_TRUE;
    1: 
    1:     if (*src == '^') {
    1:         ++src;
    1:         target->u.ucclass.sense = JS_FALSE;
    1:     }
    1: 
    1:     while (src != end) {
 8911:         JSBool canStartRange = JS_TRUE;
    1:         uintN localMax = 0;
 8911: 
    1:         switch (*src) {
    1:           case '\\':
    1:             ++src;
    1:             c = *src++;
    1:             switch (c) {
    1:               case 'b':
    1:                 localMax = 0x8;
    1:                 break;
    1:               case 'f':
    1:                 localMax = 0xC;
    1:                 break;
    1:               case 'n':
    1:                 localMax = 0xA;
    1:                 break;
    1:               case 'r':
    1:                 localMax = 0xD;
    1:                 break;
    1:               case 't':
    1:                 localMax = 0x9;
    1:                 break;
    1:               case 'v':
    1:                 localMax = 0xB;
    1:                 break;
    1:               case 'c':
    1:                 if (src < end && RE_IS_LETTER(*src)) {
10332:                     localMax = (uintN) (*src++) & 0x1F;
    1:                 } else {
    1:                     --src;
    1:                     localMax = '\\';
    1:                 }
    1:                 break;
    1:               case 'x':
    1:                 nDigits = 2;
    1:                 goto lexHex;
    1:               case 'u':
    1:                 nDigits = 4;
    1: lexHex:
    1:                 n = 0;
    1:                 for (i = 0; (i < nDigits) && (src < end); i++) {
    1:                     c = *src++;
    1:                     if (!isASCIIHexDigit(c, &digit)) {
    1:                         /*
    1:                          * Back off to accepting the original
    1:                          *'\' as a literal.
    1:                          */
    1:                         src -= i + 1;
    1:                         n = '\\';
    1:                         break;
    1:                     }
    1:                     n = (n << 4) | digit;
    1:                 }
    1:                 localMax = n;
    1:                 break;
    1:               case 'd':
 8911:                 canStartRange = JS_FALSE;
    1:                 if (inRange) {
    1:                     JS_ReportErrorNumber(state->context,
    1:                                          js_GetErrorMessage, NULL,
    1:                                          JSMSG_BAD_CLASS_RANGE);
    1:                     return JS_FALSE;
    1:                 }
    1:                 localMax = '9';
    1:                 break;
    1:               case 'D':
    1:               case 's':
    1:               case 'S':
    1:               case 'w':
    1:               case 'W':
 8911:                 canStartRange = JS_FALSE;
    1:                 if (inRange) {
    1:                     JS_ReportErrorNumber(state->context,
    1:                                          js_GetErrorMessage, NULL,
    1:                                          JSMSG_BAD_CLASS_RANGE);
    1:                     return JS_FALSE;
    1:                 }
 1802:                 max = 65535;
 1802: 
 1802:                 /*
 1802:                  * If this is the start of a range, ensure that it's less than
 1802:                  * the end.
 1802:                  */
 1802:                 localMax = 0;
 1802:                 break;
    1:               case '0':
    1:               case '1':
    1:               case '2':
    1:               case '3':
    1:               case '4':
    1:               case '5':
    1:               case '6':
    1:               case '7':
    1:                 /*
    1:                  *  This is a non-ECMA extension - decimal escapes (in this
    1:                  *  case, octal!) are supposed to be an error inside class
    1:                  *  ranges, but supported here for backwards compatibility.
    1:                  *
    1:                  */
    1:                 n = JS7_UNDEC(c);
    1:                 c = *src;
    1:                 if ('0' <= c && c <= '7') {
    1:                     src++;
    1:                     n = 8 * n + JS7_UNDEC(c);
    1:                     c = *src;
    1:                     if ('0' <= c && c <= '7') {
    1:                         src++;
    1:                         i = 8 * n + JS7_UNDEC(c);
    1:                         if (i <= 0377)
    1:                             n = i;
    1:                         else
    1:                             src--;
    1:                     }
    1:                 }
    1:                 localMax = n;
    1:                 break;
    1: 
    1:               default:
    1:                 localMax = c;
    1:                 break;
    1:             }
    1:             break;
    1:           default:
    1:             localMax = *src++;
    1:             break;
    1:         }
14539: 
    1:         if (inRange) {
13377:             /* Throw a SyntaxError here, per ECMA-262, 15.10.2.15. */
    1:             if (rangeStart > localMax) {
    1:                 JS_ReportErrorNumber(state->context,
    1:                                      js_GetErrorMessage, NULL,
    1:                                      JSMSG_BAD_CLASS_RANGE);
    1:                 return JS_FALSE;
    1:             }
    1:             inRange = JS_FALSE;
    1:         } else {
 8911:             if (canStartRange && src < end - 1) {
    1:                 if (*src == '-') {
    1:                     ++src;
    1:                     inRange = JS_TRUE;
    1:                     rangeStart = (jschar)localMax;
    1:                     continue;
    1:                 }
    1:             }
14539:             if (state->flags & JSREG_FOLD)
14539:                 rangeStart = localMax;   /* one run of the uc/dc loop below */
14539:         }
14539: 
14539:         if (state->flags & JSREG_FOLD) {
14539:             jschar maxch = localMax;
14539: 
14539:             for (i = rangeStart; i <= localMax; i++) {
14539:                 jschar uch, dch;
14539: 
14539:                 uch = upcase(i);
14539:                 dch = downcase(i);
14539:                 maxch = JS_MAX(maxch, uch);
14539:                 maxch = JS_MAX(maxch, dch);
14539:             }
14539:             localMax = maxch;
14539:         }
14539: 
    1:         if (localMax > max)
    1:             max = localMax;
    1:     }
    1:     target->u.ucclass.bmsize = max;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  *  item:       assertion               An item is either an assertion or
    1:  *              quantatom               a quantified atom.
    1:  *
    1:  *  assertion:  '^'                     Assertions match beginning of string
    1:  *                                      (or line if the class static property
    1:  *                                      RegExp.multiline is true).
    1:  *              '$'                     End of string (or line if the class
    1:  *                                      static property RegExp.multiline is
    1:  *                                      true).
    1:  *              '\b'                    Word boundary (between \w and \W).
    1:  *              '\B'                    Word non-boundary.
    1:  *
    1:  *  quantatom:  atom                    An unquantified atom.
    1:  *              quantatom '{' n ',' m '}'
    1:  *                                      Atom must occur between n and m times.
    1:  *              quantatom '{' n ',' '}' Atom must occur at least n times.
    1:  *              quantatom '{' n '}'     Atom must occur exactly n times.
    1:  *              quantatom '*'           Zero or more times (same as {0,}).
    1:  *              quantatom '+'           One or more times (same as {1,}).
    1:  *              quantatom '?'           Zero or one time (same as {0,1}).
    1:  *
    1:  *              any of which can be optionally followed by '?' for ungreedy
    1:  *
    1:  *  atom:       '(' regexp ')'          A parenthesized regexp (what matched
    1:  *                                      can be addressed using a backreference,
    1:  *                                      see '\' n below).
    1:  *              '.'                     Matches any char except '\n'.
    1:  *              '[' classlist ']'       A character class.
    1:  *              '[' '^' classlist ']'   A negated character class.
    1:  *              '\f'                    Form Feed.
    1:  *              '\n'                    Newline (Line Feed).
    1:  *              '\r'                    Carriage Return.
    1:  *              '\t'                    Horizontal Tab.
    1:  *              '\v'                    Vertical Tab.
    1:  *              '\d'                    A digit (same as [0-9]).
    1:  *              '\D'                    A non-digit.
    1:  *              '\w'                    A word character, [0-9a-z_A-Z].
    1:  *              '\W'                    A non-word character.
    1:  *              '\s'                    A whitespace character, [ \b\f\n\r\t\v].
    1:  *              '\S'                    A non-whitespace character.
    1:  *              '\' n                   A backreference to the nth (n decimal
    1:  *                                      and positive) parenthesized expression.
    1:  *              '\' octal               An octal escape sequence (octal must be
    1:  *                                      two or three digits long, unless it is
    1:  *                                      0 for the null character).
    1:  *              '\x' hex                A hex escape (hex must be two digits).
    1:  *              '\u' unicode            A unicode escape (must be four digits).
    1:  *              '\c' ctrl               A control character, ctrl is a letter.
    1:  *              '\' literalatomchar     Any character except one of the above
    1:  *                                      that follow '\' in an atom.
    1:  *              otheratomchar           Any character not first among the other
    1:  *                                      atom right-hand sides.
    1:  */
    1: static JSBool
    1: ParseTerm(CompilerState *state)
    1: {
    1:     jschar c = *state->cp++;
    1:     uintN nDigits;
    1:     uintN num, tmp, n, i;
    1:     const jschar *termStart;
    1: 
    1:     switch (c) {
    1:     /* assertions and atoms */
    1:       case '^':
    1:         state->result = NewRENode(state, REOP_BOL);
    1:         if (!state->result)
    1:             return JS_FALSE;
    1:         state->progLength++;
    1:         return JS_TRUE;
    1:       case '$':
    1:         state->result = NewRENode(state, REOP_EOL);
    1:         if (!state->result)
    1:             return JS_FALSE;
    1:         state->progLength++;
    1:         return JS_TRUE;
    1:       case '\\':
    1:         if (state->cp >= state->cpend) {
    1:             /* a trailing '\' is an error */
 7984:             ReportRegExpError(state, JSREPORT_ERROR, JSMSG_TRAILING_SLASH);
    1:             return JS_FALSE;
    1:         }
    1:         c = *state->cp++;
    1:         switch (c) {
    1:         /* assertion escapes */
    1:           case 'b' :
    1:             state->result = NewRENode(state, REOP_WBDRY);
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->progLength++;
    1:             return JS_TRUE;
    1:           case 'B':
    1:             state->result = NewRENode(state, REOP_WNONBDRY);
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->progLength++;
    1:             return JS_TRUE;
    1:           /* Decimal escape */
    1:           case '0':
    1:             /* Give a strict warning. See also the note below. */
 7984:             if (!ReportRegExpError(state, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                    JSMSG_INVALID_BACKREF)) {
    1:                 return JS_FALSE;
    1:             }
    1:      doOctal:
    1:             num = 0;
    1:             while (state->cp < state->cpend) {
    1:                 c = *state->cp;
    1:                 if (c < '0' || '7' < c)
    1:                     break;
    1:                 state->cp++;
    1:                 tmp = 8 * num + (uintN)JS7_UNDEC(c);
    1:                 if (tmp > 0377)
    1:                     break;
    1:                 num = tmp;
    1:             }
    1:             c = (jschar)num;
    1:     doFlat:
    1:             state->result = NewRENode(state, REOP_FLAT);
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->result->u.flat.chr = c;
    1:             state->result->u.flat.length = 1;
    1:             state->progLength += 3;
    1:             break;
    1:           case '1':
    1:           case '2':
    1:           case '3':
    1:           case '4':
    1:           case '5':
    1:           case '6':
    1:           case '7':
    1:           case '8':
    1:           case '9':
    1:             termStart = state->cp - 1;
    1:             num = GetDecimalValue(c, state->parenCount, FindParenCount, state);
    1:             if (state->flags & JSREG_FIND_PAREN_ERROR)
    1:                 return JS_FALSE;
    1:             if (num == OVERFLOW_VALUE) {
    1:                 /* Give a strict mode warning. */
 7984:                 if (!ReportRegExpError(state,
 7984:                                        JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                        (c >= '8')
    1:                                        ? JSMSG_INVALID_BACKREF
    1:                                        : JSMSG_BAD_BACKREF)) {
    1:                     return JS_FALSE;
    1:                 }
    1: 
    1:                 /*
    1:                  * Note: ECMA 262, 15.10.2.9 says that we should throw a syntax
    1:                  * error here. However, for compatibility with IE, we treat the
    1:                  * whole backref as flat if the first character in it is not a
    1:                  * valid octal character, and as an octal escape otherwise.
    1:                  */
    1:                 state->cp = termStart;
    1:                 if (c >= '8') {
    1:                     /* Treat this as flat. termStart - 1 is the \. */
    1:                     c = '\\';
    1:                     goto asFlat;
    1:                 }
    1: 
    1:                 /* Treat this as an octal escape. */
    1:                 goto doOctal;
    1:             }
    1:             JS_ASSERT(1 <= num && num <= 0x10000);
    1:             state->result = NewRENode(state, REOP_BACKREF);
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->result->u.parenIndex = num - 1;
    1:             state->progLength
    1:                 += 1 + GetCompactIndexWidth(state->result->u.parenIndex);
    1:             break;
    1:           /* Control escape */
    1:           case 'f':
    1:             c = 0xC;
    1:             goto doFlat;
    1:           case 'n':
    1:             c = 0xA;
    1:             goto doFlat;
    1:           case 'r':
    1:             c = 0xD;
    1:             goto doFlat;
    1:           case 't':
    1:             c = 0x9;
    1:             goto doFlat;
    1:           case 'v':
    1:             c = 0xB;
    1:             goto doFlat;
    1:           /* Control letter */
    1:           case 'c':
    1:             if (state->cp < state->cpend && RE_IS_LETTER(*state->cp)) {
    1:                 c = (jschar) (*state->cp++ & 0x1F);
    1:             } else {
    1:                 /* back off to accepting the original '\' as a literal */
    1:                 --state->cp;
    1:                 c = '\\';
    1:             }
    1:             goto doFlat;
    1:           /* HexEscapeSequence */
    1:           case 'x':
    1:             nDigits = 2;
    1:             goto lexHex;
    1:           /* UnicodeEscapeSequence */
    1:           case 'u':
    1:             nDigits = 4;
    1: lexHex:
    1:             n = 0;
    1:             for (i = 0; i < nDigits && state->cp < state->cpend; i++) {
    1:                 uintN digit;
    1:                 c = *state->cp++;
    1:                 if (!isASCIIHexDigit(c, &digit)) {
    1:                     /*
    1:                      * Back off to accepting the original 'u' or 'x' as a
    1:                      * literal.
    1:                      */
    1:                     state->cp -= i + 2;
    1:                     n = *state->cp++;
    1:                     break;
    1:                 }
    1:                 n = (n << 4) | digit;
    1:             }
    1:             c = (jschar) n;
    1:             goto doFlat;
    1:           /* Character class escapes */
    1:           case 'd':
    1:             state->result = NewRENode(state, REOP_DIGIT);
    1: doSimple:
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->progLength++;
    1:             break;
    1:           case 'D':
    1:             state->result = NewRENode(state, REOP_NONDIGIT);
    1:             goto doSimple;
    1:           case 's':
    1:             state->result = NewRENode(state, REOP_SPACE);
    1:             goto doSimple;
    1:           case 'S':
    1:             state->result = NewRENode(state, REOP_NONSPACE);
    1:             goto doSimple;
    1:           case 'w':
    1:             state->result = NewRENode(state, REOP_ALNUM);
    1:             goto doSimple;
    1:           case 'W':
    1:             state->result = NewRENode(state, REOP_NONALNUM);
    1:             goto doSimple;
    1:           /* IdentityEscape */
    1:           default:
    1:             state->result = NewRENode(state, REOP_FLAT);
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->result->u.flat.chr = c;
    1:             state->result->u.flat.length = 1;
    1:             state->result->kid = (void *) (state->cp - 1);
    1:             state->progLength += 3;
    1:             break;
    1:         }
    1:         break;
    1:       case '[':
    1:         state->result = NewRENode(state, REOP_CLASS);
    1:         if (!state->result)
    1:             return JS_FALSE;
    1:         termStart = state->cp;
    1:         state->result->u.ucclass.startIndex = termStart - state->cpbegin;
    1:         for (;;) {
    1:             if (state->cp == state->cpend) {
 7984:                 ReportRegExpErrorHelper(state, JSREPORT_ERROR,
    1:                                         JSMSG_UNTERM_CLASS, termStart);
    1: 
    1:                 return JS_FALSE;
    1:             }
    1:             if (*state->cp == '\\') {
    1:                 state->cp++;
    1:                 if (state->cp != state->cpend)
    1:                     state->cp++;
    1:                 continue;
    1:             }
    1:             if (*state->cp == ']') {
    1:                 state->result->u.ucclass.kidlen = state->cp - termStart;
    1:                 break;
    1:             }
    1:             state->cp++;
    1:         }
    1:         for (i = 0; i < CLASS_CACHE_SIZE; i++) {
    1:             if (!state->classCache[i].start) {
    1:                 state->classCache[i].start = termStart;
    1:                 state->classCache[i].length = state->result->u.ucclass.kidlen;
    1:                 state->classCache[i].index = state->classCount;
    1:                 break;
    1:             }
    1:             if (state->classCache[i].length ==
    1:                 state->result->u.ucclass.kidlen) {
    1:                 for (n = 0; ; n++) {
    1:                     if (n == state->classCache[i].length) {
    1:                         state->result->u.ucclass.index
    1:                             = state->classCache[i].index;
    1:                         goto claim;
    1:                     }
    1:                     if (state->classCache[i].start[n] != termStart[n])
    1:                         break;
    1:                 }
    1:             }
    1:         }
    1:         state->result->u.ucclass.index = state->classCount++;
    1: 
    1:     claim:
    1:         /*
    1:          * Call CalculateBitmapSize now as we want any errors it finds
    1:          * to be reported during the parse phase, not at execution.
    1:          */
    1:         if (!CalculateBitmapSize(state, state->result, termStart, state->cp++))
    1:             return JS_FALSE;
    1:         /*
    1:          * Update classBitmapsMem with number of bytes to hold bmsize bits,
    1:          * which is (bitsCount + 7) / 8 or (highest_bit + 1 + 7) / 8
    1:          * or highest_bit / 8 + 1 where highest_bit is u.ucclass.bmsize.
    1:          */
    1:         n = (state->result->u.ucclass.bmsize >> 3) + 1;
    1:         if (n > CLASS_BITMAPS_MEM_LIMIT - state->classBitmapsMem) {
 7984:             ReportRegExpError(state, JSREPORT_ERROR, JSMSG_REGEXP_TOO_COMPLEX);
    1:             return JS_FALSE;
    1:         }
    1:         state->classBitmapsMem += n;
    1:         /* CLASS, <index> */
    1:         state->progLength
    1:             += 1 + GetCompactIndexWidth(state->result->u.ucclass.index);
    1:         break;
    1: 
    1:       case '.':
    1:         state->result = NewRENode(state, REOP_DOT);
    1:         goto doSimple;
    1: 
    1:       case '{':
    1:       {
    1:         const jschar *errp = state->cp--;
    1:         intN err;
    1: 
    1:         err = ParseMinMaxQuantifier(state, JS_TRUE);
    1:         state->cp = errp;
    1: 
    1:         if (err < 0)
    1:             goto asFlat;
    1: 
    1:         /* FALL THROUGH */
    1:       }
    1:       case '*':
    1:       case '+':
    1:       case '?':
 7984:         ReportRegExpErrorHelper(state, JSREPORT_ERROR,
    1:                                 JSMSG_BAD_QUANTIFIER, state->cp - 1);
    1:         return JS_FALSE;
    1:       default:
    1: asFlat:
    1:         state->result = NewRENode(state, REOP_FLAT);
    1:         if (!state->result)
    1:             return JS_FALSE;
    1:         state->result->u.flat.chr = c;
    1:         state->result->u.flat.length = 1;
    1:         state->result->kid = (void *) (state->cp - 1);
    1:         state->progLength += 3;
    1:         break;
    1:     }
    1:     return ParseQuantifier(state);
    1: }
    1: 
    1: static JSBool
    1: ParseQuantifier(CompilerState *state)
    1: {
    1:     RENode *term;
    1:     term = state->result;
    1:     if (state->cp < state->cpend) {
    1:         switch (*state->cp) {
    1:           case '+':
    1:             state->result = NewRENode(state, REOP_QUANT);
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->result->u.range.min = 1;
    1:             state->result->u.range.max = (uintN)-1;
    1:             /* <PLUS>, <next> ... <ENDCHILD> */
    1:             state->progLength += 4;
    1:             goto quantifier;
    1:           case '*':
    1:             state->result = NewRENode(state, REOP_QUANT);
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->result->u.range.min = 0;
    1:             state->result->u.range.max = (uintN)-1;
    1:             /* <STAR>, <next> ... <ENDCHILD> */
    1:             state->progLength += 4;
    1:             goto quantifier;
    1:           case '?':
    1:             state->result = NewRENode(state, REOP_QUANT);
    1:             if (!state->result)
    1:                 return JS_FALSE;
    1:             state->result->u.range.min = 0;
    1:             state->result->u.range.max = 1;
    1:             /* <OPT>, <next> ... <ENDCHILD> */
    1:             state->progLength += 4;
    1:             goto quantifier;
    1:           case '{':       /* balance '}' */
    1:           {
    1:             intN err;
    1:             const jschar *errp = state->cp;
    1: 
    1:             err = ParseMinMaxQuantifier(state, JS_FALSE);
    1:             if (err == 0)
    1:                 goto quantifier;
    1:             if (err == -1)
    1:                 return JS_TRUE;
    1: 
 7984:             ReportRegExpErrorHelper(state, JSREPORT_ERROR, err, errp);
    1:             return JS_FALSE;
    1:           }
    1:           default:;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: 
    1: quantifier:
    1:     if (state->treeDepth == TREE_DEPTH_MAX) {
 7984:         ReportRegExpError(state, JSREPORT_ERROR, JSMSG_REGEXP_TOO_COMPLEX);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     ++state->treeDepth;
    1:     ++state->cp;
    1:     state->result->kid = term;
    1:     if (state->cp < state->cpend && *state->cp == '?') {
    1:         ++state->cp;
    1:         state->result->u.range.greedy = JS_FALSE;
    1:     } else {
    1:         state->result->u.range.greedy = JS_TRUE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static intN
    1: ParseMinMaxQuantifier(CompilerState *state, JSBool ignoreValues)
    1: {
    1:     uintN min, max;
    1:     jschar c;
    1:     const jschar *errp = state->cp++;
    1: 
    1:     c = *state->cp;
    1:     if (JS7_ISDEC(c)) {
    1:         ++state->cp;
    1:         min = GetDecimalValue(c, 0xFFFF, NULL, state);
    1:         c = *state->cp;
    1: 
    1:         if (!ignoreValues && min == OVERFLOW_VALUE)
    1:             return JSMSG_MIN_TOO_BIG;
    1: 
    1:         if (c == ',') {
    1:             c = *++state->cp;
    1:             if (JS7_ISDEC(c)) {
    1:                 ++state->cp;
    1:                 max = GetDecimalValue(c, 0xFFFF, NULL, state);
    1:                 c = *state->cp;
    1:                 if (!ignoreValues && max == OVERFLOW_VALUE)
    1:                     return JSMSG_MAX_TOO_BIG;
    1:                 if (!ignoreValues && min > max)
    1:                     return JSMSG_OUT_OF_ORDER;
    1:             } else {
    1:                 max = (uintN)-1;
    1:             }
    1:         } else {
    1:             max = min;
    1:         }
    1:         if (c == '}') {
    1:             state->result = NewRENode(state, REOP_QUANT);
    1:             if (!state->result)
 2034:                 return JSMSG_OUT_OF_MEMORY;
    1:             state->result->u.range.min = min;
    1:             state->result->u.range.max = max;
    1:             /*
    1:              * QUANT, <min>, <max>, <next> ... <ENDCHILD>
    1:              * where <max> is written as compact(max+1) to make
    1:              * (uintN)-1 sentinel to occupy 1 byte, not width_of(max)+1.
    1:              */
    1:             state->progLength += (1 + GetCompactIndexWidth(min)
    1:                                   + GetCompactIndexWidth(max + 1)
    1:                                   +3);
    1:             return 0;
    1:         }
    1:     }
    1: 
    1:     state->cp = errp;
    1:     return -1;
    1: }
    1: 
    1: static JSBool
    1: SetForwardJumpOffset(jsbytecode *jump, jsbytecode *target)
    1: {
    1:     ptrdiff_t offset = target - jump;
    1: 
    1:     /* Check that target really points forward. */
    1:     JS_ASSERT(offset >= 2);
    1:     if ((size_t)offset > OFFSET_MAX)
    1:         return JS_FALSE;
    1: 
    1:     jump[0] = JUMP_OFFSET_HI(offset);
    1:     jump[1] = JUMP_OFFSET_LO(offset);
    1:     return JS_TRUE;
    1: }
    1: 
21491: /* Copy the charset data from a character class node to the charset list
21491:  * in the regexp object. */
21491: static JS_ALWAYS_INLINE RECharSet *
21491: InitNodeCharSet(JSRegExp *re, RENode *node)
21491: {
21491:     RECharSet *charSet = &re->classList[node->u.ucclass.index];
21491:     charSet->converted = JS_FALSE;
21491:     charSet->length = node->u.ucclass.bmsize;
21491:     charSet->u.src.startIndex = node->u.ucclass.startIndex;
21491:     charSet->u.src.length = node->u.ucclass.kidlen;
21491:     charSet->sense = node->u.ucclass.sense;
21491:     return charSet;
21491: }
21491: 
    1: /*
    1:  * Generate bytecode for the tree rooted at t using an explicit stack instead
    1:  * of recursion.
    1:  */
    1: static jsbytecode *
    1: EmitREBytecode(CompilerState *state, JSRegExp *re, size_t treeDepth,
    1:                jsbytecode *pc, RENode *t)
    1: {
    1:     EmitStateStackEntry *emitStateSP, *emitStateStack;
    1:     REOp op;
    1: 
    1:     if (treeDepth == 0) {
    1:         emitStateStack = NULL;
    1:     } else {
    1:         emitStateStack =
    1:             (EmitStateStackEntry *)JS_malloc(state->context,
    1:                                              sizeof(EmitStateStackEntry) *
    1:                                              treeDepth);
    1:         if (!emitStateStack)
    1:             return NULL;
    1:     }
    1:     emitStateSP = emitStateStack;
    1:     op = t->op;
    1:     JS_ASSERT(op < REOP_LIMIT);
    1: 
    1:     for (;;) {
    1:         *pc++ = op;
    1:         switch (op) {
    1:           case REOP_EMPTY:
    1:             --pc;
    1:             break;
    1: 
    1:           case REOP_ALTPREREQ2:
    1:           case REOP_ALTPREREQ:
    1:             JS_ASSERT(emitStateSP);
    1:             emitStateSP->altHead = pc - 1;
    1:             emitStateSP->endTermFixup = pc;
    1:             pc += OFFSET_LEN;
    1:             SET_ARG(pc, t->u.altprereq.ch1);
    1:             pc += ARG_LEN;
    1:             SET_ARG(pc, t->u.altprereq.ch2);
    1:             pc += ARG_LEN;
    1: 
    1:             emitStateSP->nextAltFixup = pc;    /* offset to next alternate */
    1:             pc += OFFSET_LEN;
    1: 
    1:             emitStateSP->continueNode = t;
    1:             emitStateSP->continueOp = REOP_JUMP;
    1:             emitStateSP->jumpToJumpFlag = JS_FALSE;
    1:             ++emitStateSP;
    1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
    1:             t = (RENode *) t->kid;
    1:             op = t->op;
    1:             JS_ASSERT(op < REOP_LIMIT);
    1:             continue;
    1: 
    1:           case REOP_JUMP:
    1:             emitStateSP->nextTermFixup = pc;    /* offset to following term */
    1:             pc += OFFSET_LEN;
    1:             if (!SetForwardJumpOffset(emitStateSP->nextAltFixup, pc))
    1:                 goto jump_too_big;
    1:             emitStateSP->continueOp = REOP_ENDALT;
    1:             ++emitStateSP;
    1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
 3164:             t = (RENode *) t->u.kid2;
    1:             op = t->op;
    1:             JS_ASSERT(op < REOP_LIMIT);
    1:             continue;
    1: 
    1:           case REOP_ENDALT:
    1:             /*
    1:              * If we already patched emitStateSP->nextTermFixup to jump to
    1:              * a nearer jump, to avoid 16-bit immediate offset overflow, we
    1:              * are done here.
    1:              */
    1:             if (emitStateSP->jumpToJumpFlag)
    1:                 break;
    1: 
    1:             /*
    1:              * Fix up the REOP_JUMP offset to go to the op after REOP_ENDALT.
    1:              * REOP_ENDALT is executed only on successful match of the last
    1:              * alternate in a group.
    1:              */
    1:             if (!SetForwardJumpOffset(emitStateSP->nextTermFixup, pc))
    1:                 goto jump_too_big;
    1:             if (t->op != REOP_ALT) {
    1:                 if (!SetForwardJumpOffset(emitStateSP->endTermFixup, pc))
    1:                     goto jump_too_big;
    1:             }
    1: 
    1:             /*
    1:              * If the program is bigger than the REOP_JUMP offset range, then
    1:              * we must check for alternates before this one that are part of
    1:              * the same group, and fix up their jump offsets to target jumps
    1:              * close enough to fit in a 16-bit unsigned offset immediate.
    1:              */
    1:             if ((size_t)(pc - re->program) > OFFSET_MAX &&
    1:                 emitStateSP > emitStateStack) {
    1:                 EmitStateStackEntry *esp, *esp2;
    1:                 jsbytecode *alt, *jump;
    1:                 ptrdiff_t span, header;
    1: 
    1:                 esp2 = emitStateSP;
    1:                 alt = esp2->altHead;
    1:                 for (esp = esp2 - 1; esp >= emitStateStack; --esp) {
    1:                     if (esp->continueOp == REOP_ENDALT &&
    1:                         !esp->jumpToJumpFlag &&
    1:                         esp->nextTermFixup + OFFSET_LEN == alt &&
    1:                         (size_t)(pc - ((esp->continueNode->op != REOP_ALT)
    1:                                        ? esp->endTermFixup
    1:                                        : esp->nextTermFixup)) > OFFSET_MAX) {
    1:                         alt = esp->altHead;
    1:                         jump = esp->nextTermFixup;
    1: 
    1:                         /*
    1:                          * The span must be 1 less than the distance from
    1:                          * jump offset to jump offset, so we actually jump
    1:                          * to a REOP_JUMP bytecode, not to its offset!
    1:                          */
    1:                         for (;;) {
    1:                             JS_ASSERT(jump < esp2->nextTermFixup);
    1:                             span = esp2->nextTermFixup - jump - 1;
    1:                             if ((size_t)span <= OFFSET_MAX)
    1:                                 break;
    1:                             do {
    1:                                 if (--esp2 == esp)
    1:                                     goto jump_too_big;
    1:                             } while (esp2->continueOp != REOP_ENDALT);
    1:                         }
    1: 
    1:                         jump[0] = JUMP_OFFSET_HI(span);
    1:                         jump[1] = JUMP_OFFSET_LO(span);
    1: 
    1:                         if (esp->continueNode->op != REOP_ALT) {
    1:                             /*
    1:                              * We must patch the offset at esp->endTermFixup
    1:                              * as well, for the REOP_ALTPREREQ{,2} opcodes.
    1:                              * If we're unlucky and endTermFixup is more than
    1:                              * OFFSET_MAX bytes from its target, we cheat by
    1:                              * jumping 6 bytes to the jump whose offset is at
    1:                              * esp->nextTermFixup, which has the same target.
    1:                              */
    1:                             jump = esp->endTermFixup;
    1:                             header = esp->nextTermFixup - jump;
    1:                             span += header;
    1:                             if ((size_t)span > OFFSET_MAX)
    1:                                 span = header;
    1: 
    1:                             jump[0] = JUMP_OFFSET_HI(span);
    1:                             jump[1] = JUMP_OFFSET_LO(span);
    1:                         }
    1: 
    1:                         esp->jumpToJumpFlag = JS_TRUE;
    1:                     }
    1:                 }
    1:             }
    1:             break;
    1: 
    1:           case REOP_ALT:
    1:             JS_ASSERT(emitStateSP);
    1:             emitStateSP->altHead = pc - 1;
    1:             emitStateSP->nextAltFixup = pc;     /* offset to next alternate */
    1:             pc += OFFSET_LEN;
    1:             emitStateSP->continueNode = t;
    1:             emitStateSP->continueOp = REOP_JUMP;
    1:             emitStateSP->jumpToJumpFlag = JS_FALSE;
    1:             ++emitStateSP;
    1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
 3164:             t = (RENode *) t->kid;
    1:             op = t->op;
    1:             JS_ASSERT(op < REOP_LIMIT);
    1:             continue;
    1: 
    1:           case REOP_FLAT:
    1:             /*
    1:              * Coalesce FLATs if possible and if it would not increase bytecode
    1:              * beyond preallocated limit. The latter happens only when bytecode
    1:              * size for coalesced string with offset p and length 2 exceeds 6
    1:              * bytes preallocated for 2 single char nodes, i.e. when
    1:              * 1 + GetCompactIndexWidth(p) + GetCompactIndexWidth(2) > 6 or
    1:              * GetCompactIndexWidth(p) > 4.
    1:              * Since when GetCompactIndexWidth(p) <= 4 coalescing of 3 or more
    1:              * nodes strictly decreases bytecode size, the check has to be
    1:              * done only for the first coalescing.
    1:              */
    1:             if (t->kid &&
    1:                 GetCompactIndexWidth((jschar *)t->kid - state->cpbegin) <= 4)
    1:             {
    1:                 while (t->next &&
    1:                        t->next->op == REOP_FLAT &&
    1:                        (jschar*)t->kid + t->u.flat.length ==
    1:                        (jschar*)t->next->kid) {
    1:                     t->u.flat.length += t->next->u.flat.length;
    1:                     t->next = t->next->next;
    1:                 }
    1:             }
    1:             if (t->kid && t->u.flat.length > 1) {
    1:                 pc[-1] = (state->flags & JSREG_FOLD) ? REOP_FLATi : REOP_FLAT;
    1:                 pc = WriteCompactIndex(pc, (jschar *)t->kid - state->cpbegin);
    1:                 pc = WriteCompactIndex(pc, t->u.flat.length);
    1:             } else if (t->u.flat.chr < 256) {
    1:                 pc[-1] = (state->flags & JSREG_FOLD) ? REOP_FLAT1i : REOP_FLAT1;
    1:                 *pc++ = (jsbytecode) t->u.flat.chr;
    1:             } else {
    1:                 pc[-1] = (state->flags & JSREG_FOLD)
    1:                          ? REOP_UCFLAT1i
    1:                          : REOP_UCFLAT1;
    1:                 SET_ARG(pc, t->u.flat.chr);
    1:                 pc += ARG_LEN;
    1:             }
    1:             break;
    1: 
    1:           case REOP_LPAREN:
    1:             JS_ASSERT(emitStateSP);
    1:             pc = WriteCompactIndex(pc, t->u.parenIndex);
    1:             emitStateSP->continueNode = t;
    1:             emitStateSP->continueOp = REOP_RPAREN;
    1:             ++emitStateSP;
    1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
    1:             t = (RENode *) t->kid;
    1:             op = t->op;
    1:             continue;
    1: 
    1:           case REOP_RPAREN:
    1:             pc = WriteCompactIndex(pc, t->u.parenIndex);
    1:             break;
    1: 
    1:           case REOP_BACKREF:
    1:             pc = WriteCompactIndex(pc, t->u.parenIndex);
    1:             break;
    1: 
    1:           case REOP_ASSERT:
    1:             JS_ASSERT(emitStateSP);
    1:             emitStateSP->nextTermFixup = pc;
    1:             pc += OFFSET_LEN;
    1:             emitStateSP->continueNode = t;
    1:             emitStateSP->continueOp = REOP_ASSERTTEST;
    1:             ++emitStateSP;
    1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
    1:             t = (RENode *) t->kid;
    1:             op = t->op;
    1:             continue;
    1: 
    1:           case REOP_ASSERTTEST:
    1:           case REOP_ASSERTNOTTEST:
    1:             if (!SetForwardJumpOffset(emitStateSP->nextTermFixup, pc))
    1:                 goto jump_too_big;
    1:             break;
    1: 
    1:           case REOP_ASSERT_NOT:
    1:             JS_ASSERT(emitStateSP);
    1:             emitStateSP->nextTermFixup = pc;
    1:             pc += OFFSET_LEN;
    1:             emitStateSP->continueNode = t;
    1:             emitStateSP->continueOp = REOP_ASSERTNOTTEST;
    1:             ++emitStateSP;
    1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
    1:             t = (RENode *) t->kid;
    1:             op = t->op;
    1:             continue;
    1: 
    1:           case REOP_QUANT:
    1:             JS_ASSERT(emitStateSP);
    1:             if (t->u.range.min == 0 && t->u.range.max == (uintN)-1) {
    1:                 pc[-1] = (t->u.range.greedy) ? REOP_STAR : REOP_MINIMALSTAR;
    1:             } else if (t->u.range.min == 0 && t->u.range.max == 1) {
    1:                 pc[-1] = (t->u.range.greedy) ? REOP_OPT : REOP_MINIMALOPT;
    1:             } else if (t->u.range.min == 1 && t->u.range.max == (uintN) -1) {
    1:                 pc[-1] = (t->u.range.greedy) ? REOP_PLUS : REOP_MINIMALPLUS;
    1:             } else {
    1:                 if (!t->u.range.greedy)
    1:                     pc[-1] = REOP_MINIMALQUANT;
    1:                 pc = WriteCompactIndex(pc, t->u.range.min);
    1:                 /*
    1:                  * Write max + 1 to avoid using size_t(max) + 1 bytes
    1:                  * for (uintN)-1 sentinel.
    1:                  */
    1:                 pc = WriteCompactIndex(pc, t->u.range.max + 1);
    1:             }
    1:             emitStateSP->nextTermFixup = pc;
    1:             pc += OFFSET_LEN;
    1:             emitStateSP->continueNode = t;
    1:             emitStateSP->continueOp = REOP_ENDCHILD;
    1:             ++emitStateSP;
    1:             JS_ASSERT((size_t)(emitStateSP - emitStateStack) <= treeDepth);
    1:             t = (RENode *) t->kid;
    1:             op = t->op;
    1:             continue;
    1: 
    1:           case REOP_ENDCHILD:
    1:             if (!SetForwardJumpOffset(emitStateSP->nextTermFixup, pc))
    1:                 goto jump_too_big;
    1:             break;
    1: 
    1:           case REOP_CLASS:
    1:             if (!t->u.ucclass.sense)
    1:                 pc[-1] = REOP_NCLASS;
    1:             pc = WriteCompactIndex(pc, t->u.ucclass.index);
21491:             InitNodeCharSet(re, t);
    1:             break;
    1: 
    1:           default:
    1:             break;
    1:         }
    1: 
    1:         t = t->next;
    1:         if (t) {
    1:             op = t->op;
    1:         } else {
    1:             if (emitStateSP == emitStateStack)
    1:                 break;
    1:             --emitStateSP;
    1:             t = emitStateSP->continueNode;
 3164:             op = (REOp) emitStateSP->continueOp;
    1:         }
    1:     }
    1: 
    1:   cleanup:
    1:     if (emitStateStack)
    1:         JS_free(state->context, emitStateStack);
    1:     return pc;
    1: 
    1:   jump_too_big:
 7984:     ReportRegExpError(state, JSREPORT_ERROR, JSMSG_REGEXP_TOO_COMPLEX);
    1:     pc = NULL;
    1:     goto cleanup;
    1: }
    1: 
22611: static JSBool
22611: CompileRegExpToAST(JSContext* cx, JSTokenStream* ts,
22611:                    JSString* str, uintN flags, CompilerState& state)
22611: {
22611:     uintN i;
22611:     size_t len;
22611: 
22611:     len = JSSTRING_LENGTH(str);
22611: 
22611:     state.context = cx;
22611:     state.tokenStream = ts;
22611:     state.cp = js_UndependString(cx, str);
22611:     if (!state.cp)
22611:         return JS_FALSE;
22611:     state.cpbegin = state.cp;
22611:     state.cpend = state.cp + len;
22611:     state.flags = flags;
22611:     state.parenCount = 0;
22611:     state.classCount = 0;
22611:     state.progLength = 0;
22611:     state.treeDepth = 0;
22611:     state.classBitmapsMem = 0;
22611:     for (i = 0; i < CLASS_CACHE_SIZE; i++)
22611:         state.classCache[i].start = NULL;
22611: 
22611:     if (len != 0 && (flags & JSREG_FLAT)) {
22611:         state.result = NewRENode(&state, REOP_FLAT);
22611:         if (!state.result)
22611:             return JS_FALSE;
22611:         state.result->u.flat.chr = *state.cpbegin;
22611:         state.result->u.flat.length = len;
22611:         state.result->kid = (void *) state.cpbegin;
22611:         /* Flat bytecode: REOP_FLAT compact(string_offset) compact(len). */
22611:         state.progLength += 1 + GetCompactIndexWidth(0)
22611:                           + GetCompactIndexWidth(len);
22611:         return JS_TRUE;
22611:     }
22611:     
22611:     return ParseRegExp(&state);
22611: }
22611: 
21497: #ifdef JS_TRACER
21491: typedef List<LIns*, LIST_NonGCObjects> LInsList;
21491: 
21491: /* Dummy GC for nanojit placement new. */
21491: static GC gc;
21491: 
22605: static void*
22605: HashRegExp(uint16 flags, jschar* s, size_t n)
22605: {
22605:     uint32 h;
22605: 
22605:     for (h = 0; n; s++, n--)
22605:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
22605:     return (void*)(h + flags);
22605: }
22605: 
22605: struct RESideExit : public SideExit {
22605:     size_t re_length;
22605:     uint16 re_flags;
22605:     jschar re_chars[1];
22605: };
22605: 
22611: /* Return the cached fragment for the given regexp, or NULL. */
22605: static Fragment* 
22611: LookupNativeRegExp(JSContext* cx, void* hash, uint16 re_flags, 
22611:                    jschar* re_chars, size_t re_length)
22605: {
22605:     Fragmento* fragmento = JS_TRACE_MONITOR(cx).reFragmento;
22605:     Fragment* fragment = fragmento->getLoop(hash);
22605:     while (fragment) {
22605:         if (fragment->lastIns) {
22605:             RESideExit* exit = (RESideExit*)fragment->lastIns->record()->exit;
22605:             if (exit->re_flags == re_flags && 
22605:                 exit->re_length == re_length &&
22605:                 !memcmp(exit->re_chars, re_chars, re_length)) {
22605:                 return fragment;
22605:             }
22605:         }
22605:         fragment = fragment->peer;
22605:     }
22605:     return NULL;
22605: }
22605: 
22605: static JSBool
22605: ProcessCharSet(JSContext *cx, JSRegExp *re, RECharSet *charSet);
22605: 
21491: class RegExpNativeCompiler {
21491:  private:
22605:     JSContext*       cx;
22605:     JSRegExp*        re;
21491:     CompilerState*   cs;            /* RegExp to compile */
21491:     Fragment*        fragment;
21491:     LirWriter*       lir;
22605:     LirBufWriter*    lirBufWriter;  /* for skip */
21491: 
21491:     LIns*            state;
21491:     LIns*            gdata;
21491:     LIns*            cpend;
21491: 
21509:     JSBool isCaseInsensitive() const { return cs->flags & JSREG_FOLD; }
21509: 
23234:     JSBool targetCurrentPoint(LIns* ins) 
21509:     {
23234:         if (fragment->lirbuf->outOMem()) 
23234:             return JS_FALSE;
23234:         ins->target(lir->ins0(LIR_label)); 
23234:         return JS_TRUE;
23234:     }
23234: 
23234:     JSBool targetCurrentPoint(LInsList& fails) 
23234:     {
23234:         if (fragment->lirbuf->outOMem()) 
23234:             return JS_FALSE;
21491:         LIns* fail = lir->ins0(LIR_label);
21491:         for (size_t i = 0; i < fails.size(); ++i) {
21491:             fails[i]->target(fail);
21491:         }
21491:         fails.clear();
23234:         return JS_TRUE;
21491:     }
21491: 
21637:     /* 
21637:      * These functions return the new position after their match operation,
21637:      * or NULL if there was an error.
21637:      */
21637:     LIns* compileEmpty(RENode* node, LIns* pos, LInsList& fails) 
21509:     {
21637:         return pos;
21637:     }
21637: 
22605:     LIns* compileFlatSingleChar(jschar ch, LIns* pos, LInsList& fails) 
21509:     {
21509:         /* 
21509:          * Fast case-insensitive test for ASCII letters: convert text
21509:          * char to lower case by bit-or-ing in 32 and compare.
21509:          */
21491:         JSBool useFastCI = JS_FALSE;
21491:         jschar ch2 = ch;              /* 2nd char to test for if ci */
21491:         if (cs->flags & JSREG_FOLD) {
22604:             if ((L'A' <= ch && ch <= L'Z') || (L'a' <= ch && ch <= L'z')) {
21491:                 ch |= 32;
21491:                 ch2 = ch;
21491:                 useFastCI = JS_TRUE;
21491:             } else if (JS_TOLOWER(ch) != ch) {
21491:                 ch2 = JS_TOLOWER(ch);
21491:                 ch = JS_TOUPPER(ch);
21491:             }
21491:         }
21491: 
21491:         LIns* to_fail = lir->insBranch(LIR_jf, lir->ins2(LIR_lt, pos, cpend), 0);
21491:         fails.add(to_fail);
21491:         LIns* text_ch = lir->insLoad(LIR_ldcs, pos, lir->insImm(0));
21491:         LIns* comp_ch = useFastCI ? 
21491:             lir->ins2(LIR_or, text_ch, lir->insImm(32)) : 
21491:             text_ch;
21491:         if (ch == ch2) {
21491:             fails.add(lir->insBranch(LIR_jf, lir->ins2(LIR_eq, comp_ch, lir->insImm(ch)), 0));
21491:         } else {
21491:             LIns* to_ok = lir->insBranch(LIR_jt, lir->ins2(LIR_eq, comp_ch, lir->insImm(ch)), 0);
21491:             fails.add(lir->insBranch(LIR_jf, lir->ins2(LIR_eq, comp_ch, lir->insImm(ch2)), 0));
23234:             if (!targetCurrentPoint(to_ok))
23234:                 return NULL;
21491:         }
21491: 
21637:         return lir->ins2(LIR_piadd, pos, lir->insImm(2));
21637:     }
21637: 
21637:     LIns* compileClass(RENode* node, LIns* pos, LInsList& fails) 
21509:     {
21509:         if (!node->u.ucclass.sense)
21509:             return JS_FALSE;
22605:         /* 
22605:          * If we share generated native code, we need to make a copy
22605:          * of the bitmap because the original regexp's copy is destroyed
22605:          * when that regexp is. 
22605:          */
22605:         RECharSet *charSet = &re->classList[node->u.ucclass.index];
22605:         size_t bitmapLen = (charSet->length >> 3) + 1;
22605:         /* skip() can't hold large data blocks. */
22605:         if (bitmapLen > 1024)
22605:             return NULL;
22605:         /* The following line allocates charSet.u.bits if successful. */
22605:         if (!charSet->converted && !ProcessCharSet(cx, re, charSet))
22605:             return NULL;
22605:         LIns* skip = lirBufWriter->skip(bitmapLen);
22662:         if (fragment->lirbuf->outOMem())
22605:             return NULL;
22605:         void* bitmapData = skip->payload();
22605:         memcpy(bitmapData, charSet->u.bits, bitmapLen);
22605: 
21491:         LIns* to_fail = lir->insBranch(LIR_jf, lir->ins2(LIR_lt, pos, cpend), 0);
21491:         fails.add(to_fail);
21491:         LIns* text_ch = lir->insLoad(LIR_ldcs, pos, lir->insImm(0));
21491:         fails.add(lir->insBranch(LIR_jf, lir->ins2(LIR_le, text_ch, lir->insImm(charSet->length)), 0));
21491:         LIns* byteIndex = lir->ins2(LIR_rsh, text_ch, lir->insImm(3));
22605:         LIns* bitmap = lir->insImmPtr(bitmapData);
21491:         LIns* byte = lir->insLoad(LIR_ldcb, lir->ins2(LIR_piadd, bitmap, byteIndex), (int) 0);
21491:         LIns* bitMask = lir->ins2(LIR_lsh, lir->insImm(1),
21491:                                lir->ins2(LIR_and, text_ch, lir->insImm(0x7)));
21491:         LIns* test = lir->ins2(LIR_eq, lir->ins2(LIR_and, byte, bitMask), lir->insImm(0));
21491:         
21491:         LIns* to_next = lir->insBranch(LIR_jt, test, 0);
21491:         fails.add(to_next);
21637:         return lir->ins2(LIR_piadd, pos, lir->insImm(2));
21637:     }
21637: 
21637:     LIns* compileAlt(RENode* node, LIns* pos, LInsList& fails) 
21509:     {
21491:         LInsList kidFails(NULL);
21509:         if (!compileNode((RENode *) node->kid, pos, kidFails)) 
23234:             return NULL;
21509:         if (!compileNode(node->next, pos, kidFails)) 
23234:             return NULL;
23234: 
23234:         if (!targetCurrentPoint(kidFails))
23234:             return NULL;
21509:         if (!compileNode(node->u.altprereq.kid2, pos, fails)) 
23234:             return NULL;
21509:         /* 
21509:          * Disable compilation for any regexp where something follows an
21491:          * alternation. To make this work, we need to redesign to either
21491:          * (a) pass around continuations so we know the right place to go
21491:          * when we logically return, or (b) generate explicit backtracking
21509:          * code. 
21509:          */
21509:         if (node->next) 
23234:             return NULL;
21637:         return pos;
21491:     }
21491: 
21509:     JSBool compileNode(RENode* node, LIns* pos, LInsList& fails) 
21509:     {
21637:         for (; node; node = node->next) {
22662:             if (fragment->lirbuf->outOMem()) 
21509:                 return JS_FALSE;
21505: 
21637:             switch (node->op) {
21637:             case REOP_EMPTY:
21637:                 pos = compileEmpty(node, pos, fails);
21637:                 break;
21637:             case REOP_FLAT:
22605:                 if (node->u.flat.length == 1) {
22605:                     pos = compileFlatSingleChar(node->u.flat.chr, pos, fails);
22605:                 } else {
22605:                     for (size_t i = 0; i < node->u.flat.length; ++i) {
22605:                         pos = compileFlatSingleChar(((jschar*) node->kid)[i], pos, fails);
22605:                         if (!pos) break;
22605:                     }
22605:                 }
21637:                 break;
21637:             case REOP_ALT:
21637:             case REOP_ALTPREREQ:
21637:                 pos = compileAlt(node, pos, fails);
21637:                 break;
21637:             case REOP_CLASS:
21637:                 pos = compileClass(node, pos, fails);
21637:                 break;
21637:             default:
21637:                 return JS_FALSE;
21637:             }
21637:             if (!pos) 
21637:                 return JS_FALSE;
21637:         }
21637: 
21491:         lir->insStorei(pos, state, (int) offsetof(REMatchState, cp));
21491:         lir->ins1(LIR_ret, state);
21491:         return JS_TRUE;
21491:     }
21491: 
21509:     JSBool compileSticky(RENode* root, LIns* start) 
21509:     {
21491:         LInsList fails(NULL);
21509:         if (!compileNode(root, start, fails)) 
21509:             return JS_FALSE;
23234:         if (!targetCurrentPoint(fails))
23234:             return JS_FALSE;
21491:         lir->ins1(LIR_ret, lir->insImm(0));
21491:         return JS_TRUE;
21491:     }
21491: 
21509:     JSBool compileAnchoring(RENode* root, LIns* start) 
21509:     {
21491:         /* Even at the end, the empty regexp would match. */
21491:         LIns* to_next = lir->insBranch(LIR_jf, 
21491:                                        lir->ins2(LIR_le, start, cpend), 0);
21491:         LInsList fails(NULL);
21509:         if (!compileNode(root, start, fails)) 
21509:             return JS_FALSE;
21491: 
23234:         if (!targetCurrentPoint(to_next))
23234:             return JS_FALSE;
21491:         lir->ins1(LIR_ret, lir->insImm(0));
21491:         
23234:         if (!targetCurrentPoint(fails))
23234:             return JS_FALSE;
21491:         lir->insStorei(lir->ins2(LIR_piadd, start, lir->insImm(2)), gdata, 
21491:                        (int) offsetof(REGlobalData, skipped));
21491:         
21491:         return JS_TRUE;
21491:     }
21491: 
21491:     inline LIns*
21491:     addName(LirBuffer* lirbuf, LIns* ins, const char* name)
21491:     {
22704: #ifdef NJ_VERBOSE
21498:         debug_only_v(lirbuf->names->addName(ins, name);)
22704: #endif
21491:         return ins;
21491:     }
21491: 
22611:     /*
22611:      * Insert the side exit and guard record for a compiled regexp. Most
22611:      * of the fields are not used. The important part is the regexp source
22611:      * and flags, which we use as the fragment lookup key.
22611:      */
22611:     GuardRecord* insertGuard(jschar* re_chars, size_t re_length)
21509:     {
22611:         LIns* skip = lirBufWriter->skip(sizeof(GuardRecord) + 
22605:                                         sizeof(RESideExit) + 
22605:                                         re_length - sizeof(jschar));
22611:         GuardRecord* guard = (GuardRecord *) skip->payload();
21491:         memset(guard, 0, sizeof(*guard));
22611:         RESideExit* exit = (RESideExit*)(guard+1);
22605:         guard->exit = exit;
21512:         guard->exit->target = fragment;
22605:         exit->re_flags = re->flags;
22605:         exit->re_length = re_length;
22605:         memcpy(exit->re_chars, re_chars, re_length);
21491:         fragment->lastIns = lir->insGuard(LIR_loop, lir->insImm(1), skip);
22611:         return guard;
22611:     }
22611: 
22611:  public:
22611:  RegExpNativeCompiler(JSRegExp* re, CompilerState* cs, Fragment* fragment) 
22611:         : re(re), cs(cs), fragment(fragment), lir(NULL), lirBufWriter(NULL) {  }
22611: 
22611:     JSBool compile(JSContext* cx) 
22611:     {
22611:         GuardRecord* guard = NULL;
22611:         LIns* start;
22611:         bool oom = false;
22611:         jschar* re_chars;
22611:         size_t re_length;
22611:         Fragmento* fragmento = JS_TRACE_MONITOR(cx).reFragmento;
22611: 
22611:         JSSTRING_CHARS_AND_LENGTH(re->source, re_chars, re_length);
22611:         /* 
22611:          * If the regexp is too long nanojit will assert when we
22611:          * try to insert the guard record.
22611:          */
22611:         if (re_length > 1024)
22611:             return JS_FALSE;
22611: 
22611:         this->cx = cx;
22611:         /* At this point we have an empty fragment. */
22611:         LirBuffer* lirbuf = fragment->lirbuf;
22662:         if (lirbuf->outOMem()) 
22611:             goto fail;
22611:         /* FIXME Use bug 463260 smart pointer when available. */
22611:         lir = lirBufWriter = new (&gc) LirBufWriter(lirbuf);
22611: 
22611:         /* FIXME Use bug 463260 smart pointer when available. */
22704: #ifdef NJ_VERBOSE
22611:         debug_only_v(fragment->lirbuf->names = new (&gc) LirNameMap(&gc, NULL, fragmento->labels);)
22704: #endif
22611:         /* FIXME Use bug 463260 smart pointer when available. */
22704: #ifdef NJ_VERBOSE
22611:         debug_only_v(lir = new (&gc) VerboseWriter(&gc, lir, lirbuf->names);)
22704: #endif
22611: 
22611:         lir->ins0(LIR_start);
22611:         lirbuf->state = state = addName(lirbuf, lir->insParam(0, 0), "state");
22611:         lirbuf->param1 = gdata = addName(lirbuf, lir->insParam(1, 0), "gdata");
22611:         start = addName(lirbuf, lir->insLoad(LIR_ldp, lirbuf->param1, (int) offsetof(REGlobalData, skipped)), "start");
22611:         cpend = addName(lirbuf, lir->insLoad(LIR_ldp, lirbuf->param1, offsetof(REGlobalData, cpend)), "cpend");
22611: 
22611:         if (cs->flags & JSREG_STICKY) {
22611:             if (!compileSticky(cs->result, start)) 
22611:                 goto fail;
22611:         } else {
22611:             if (!compileAnchoring(cs->result, start)) 
22611:                 goto fail;
22611:         }
22611: 
22611:         guard = insertGuard(re_chars, re_length);
21491: 
22662:         if (lirbuf->outOMem()) 
22617:             goto fail;
21491:         ::compile(fragmento->assm(), fragment);
21515:         if (fragmento->assm()->error() != nanojit::None) {
21515:             oom = fragmento->assm()->error() == nanojit::OutOMem;
21505:             goto fail;
21515:         }
21491: 
22605:         delete lirBufWriter;
22704: #ifdef NJ_VERBOSE
21498:         debug_only_v(delete lir;)
22704: #endif
21491:         return JS_TRUE;
21491:     fail:
22662:         if (lirbuf->outOMem() || oom) {
21515:             fragmento->clearFrags();
22605:         } else {
22611:             if (!guard) insertGuard(re_chars, re_length);
22605:             fragment->blacklist();
22605:         }
22611:         delete lirBufWriter;
22704: #ifdef NJ_VERBOSE
22611:         debug_only_v(delete lir;)
22704: #endif
21491:         return JS_FALSE;
21491:     }
21491: };
21491: 
22611: /*
22611:  * Compile a regexp to native code in the given fragment.
22611:  */
21491: static inline JSBool
22611: CompileRegExpToNative(JSContext* cx, JSRegExp* re, Fragment* fragment)
21491: {
22611:     JSBool rv = JS_FALSE;
22611:     void* mark;
22611:     CompilerState state;
22611:     RegExpNativeCompiler rc(re, &state, fragment);
22611: 
22611:     JS_ASSERT(!fragment->code());
22611:     JS_ASSERT(!fragment->isBlacklisted());
22611: 
22611:     mark = JS_ARENA_MARK(&cx->tempPool);
22611:     if (!CompileRegExpToAST(cx, NULL, re->source, re->flags, state)) {
22611:         goto out;
22611:     }
22611:     rv = rc.compile(cx);
22611:  out:
22611:     JS_ARENA_RELEASE(&cx->tempPool, mark);
22611:     return rv;
22611: }
22611: 
22611: /* Function type for a compiled native regexp. */
22611: typedef REMatchState* (FASTCALL *NativeRegExp)(REMatchState*, REGlobalData*);
22611: 
22611: /*
22611:  * Return a compiled native regexp if one already exists or can be created
22611:  * now, or NULL otherwise.
22611:  */
22611: static NativeRegExp
22611: GetNativeRegExp(JSContext* cx, JSRegExp* re)
22611: {
22611:     Fragment *fragment;
22611:     jschar* re_chars;
22611:     size_t re_length;
22611:     Fragmento* fragmento = JS_TRACE_MONITOR(cx).reFragmento;
22611: 
22611:     JSSTRING_CHARS_AND_LENGTH(re->source, re_chars, re_length);
22611:     void* hash = HashRegExp(re->flags, re_chars, re_length);
22611:     fragment = LookupNativeRegExp(cx, hash, re->flags, re_chars, re_length);
22611:     if (fragment) {
22611:         if (fragment->code())
22611:             goto ok;
22611:         if (fragment->isBlacklisted())
22611:             return NULL;
22611:     } else {
22611:         fragment = fragmento->getAnchor(hash);
22611:         fragment->lirbuf = new (&gc) LirBuffer(fragmento, NULL);
22611:         /* required to have the onDestroy method delete the lirbuf. */
22611:         fragment->root = fragment;
22611:     }
22611:         
22611:     if (!CompileRegExpToNative(cx, re, fragment))
22611:         return NULL;
22611:  ok:
22611:     union { NIns *code; NativeRegExp func; } u;
22611:     u.code = fragment->code();
22611:     return u.func;
21491: }
21497: #endif
    1: 
    1: JSRegExp *
    1: js_NewRegExp(JSContext *cx, JSTokenStream *ts,
    1:              JSString *str, uintN flags, JSBool flat)
    1: {
    1:     JSRegExp *re;
    1:     void *mark;
    1:     CompilerState state;
    1:     size_t resize;
    1:     jsbytecode *endPC;
    1:     uintN i;
    1: 
    1:     re = NULL;
    1:     mark = JS_ARENA_MARK(&cx->tempPool);
22611: 
22611:     /*
22611:      * Parsing the string as flat is now expressed internally using
22611:      * a flag, so that we keep this information in the JSRegExp, but
22611:      * we keep the 'flat' parameter for now for compatibility.
22611:      */
22611:     if (flat) flags |= JSREG_FLAT;
22611:     if (!CompileRegExpToAST(cx, ts, str, flags, state))
    1:         goto out;
21491: 
    1:     resize = offsetof(JSRegExp, program) + state.progLength + 1;
    1:     re = (JSRegExp *) JS_malloc(cx, resize);
    1:     if (!re)
    1:         goto out;
    1: 
    1:     re->nrefs = 1;
    1:     JS_ASSERT(state.classBitmapsMem <= CLASS_BITMAPS_MEM_LIMIT);
    1:     re->classCount = state.classCount;
    1:     if (re->classCount) {
    1:         re->classList = (RECharSet *)
    1:             JS_malloc(cx, re->classCount * sizeof(RECharSet));
    1:         if (!re->classList) {
    1:             js_DestroyRegExp(cx, re);
    1:             re = NULL;
    1:             goto out;
    1:         }
    1:         for (i = 0; i < re->classCount; i++)
    1:             re->classList[i].converted = JS_FALSE;
    1:     } else {
    1:         re->classList = NULL;
    1:     }
21491: 
21491:     /* Compile the bytecode version. */
    1:     endPC = EmitREBytecode(&state, re, state.treeDepth, re->program, state.result);
    1:     if (!endPC) {
    1:         js_DestroyRegExp(cx, re);
    1:         re = NULL;
    1:         goto out;
    1:     }
    1:     *endPC++ = REOP_END;
    1:     /*
    1:      * Check whether size was overestimated and shrink using realloc.
    1:      * This is safe since no pointers to newly parsed regexp or its parts
    1:      * besides re exist here.
    1:      */
    1:     if ((size_t)(endPC - re->program) != state.progLength + 1) {
    1:         JSRegExp *tmp;
    1:         JS_ASSERT((size_t)(endPC - re->program) < state.progLength + 1);
    1:         resize = offsetof(JSRegExp, program) + (endPC - re->program);
    1:         tmp = (JSRegExp *) JS_realloc(cx, re, resize);
    1:         if (tmp)
    1:             re = tmp;
    1:     }
    1: 
    1:     re->flags = flags;
    1:     re->parenCount = state.parenCount;
    1:     re->source = str;
    1: 
    1: out:
    1:     JS_ARENA_RELEASE(&cx->tempPool, mark);
    1:     return re;
    1: }
    1: 
    1: JSRegExp *
 7984: js_NewRegExpOpt(JSContext *cx, JSString *str, JSString *opt, JSBool flat)
    1: {
    1:     uintN flags;
    1:     jschar *s;
    1:     size_t i, n;
    1:     char charBuf[2];
    1: 
    1:     flags = 0;
    1:     if (opt) {
 4718:         JSSTRING_CHARS_AND_LENGTH(opt, s, n);
 4718:         for (i = 0; i < n; i++) {
    1:             switch (s[i]) {
    1:               case 'g':
    1:                 flags |= JSREG_GLOB;
    1:                 break;
    1:               case 'i':
    1:                 flags |= JSREG_FOLD;
    1:                 break;
    1:               case 'm':
    1:                 flags |= JSREG_MULTILINE;
    1:                 break;
    1:               case 'y':
    1:                 flags |= JSREG_STICKY;
    1:                 break;
    1:               default:
    1:                 charBuf[0] = (char)s[i];
    1:                 charBuf[1] = '\0';
 7984:                 JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
 7984:                                              js_GetErrorMessage, NULL,
    1:                                              JSMSG_BAD_FLAG, charBuf);
    1:                 return NULL;
    1:             }
    1:         }
    1:     }
 7984:     return js_NewRegExp(cx, NULL, str, flags, flat);
    1: }
    1: 
    1: /*
    1:  * Save the current state of the match - the position in the input
    1:  * text as well as the position in the bytecode. The state of any
    1:  * parent expressions is also saved (preceding state).
    1:  * Contents of parenCount parentheses from parenIndex are also saved.
    1:  */
    1: static REBackTrackData *
    1: PushBackTrackState(REGlobalData *gData, REOp op,
    1:                    jsbytecode *target, REMatchState *x, const jschar *cp,
    1:                    size_t parenIndex, size_t parenCount)
    1: {
    1:     size_t i;
    1:     REBackTrackData *result =
    1:         (REBackTrackData *) ((char *)gData->backTrackSP + gData->cursz);
    1: 
    1:     size_t sz = sizeof(REBackTrackData) +
    1:                 gData->stateStackTop * sizeof(REProgState) +
    1:                 parenCount * sizeof(RECapture);
    1: 
    1:     ptrdiff_t btsize = gData->backTrackStackSize;
    1:     ptrdiff_t btincr = ((char *)result + sz) -
    1:                        ((char *)gData->backTrackStack + btsize);
    1: 
  211:     re_debug("\tBT_Push: %lu,%lu",
  211:              (unsigned long) parenIndex, (unsigned long) parenCount);
   22: 
    1:     JS_COUNT_OPERATION(gData->cx, JSOW_JUMP * (1 + parenCount));
    1:     if (btincr > 0) {
    1:         ptrdiff_t offset = (char *)result - (char *)gData->backTrackStack;
    1: 
    1:         JS_COUNT_OPERATION(gData->cx, JSOW_ALLOCATION);
    1:         btincr = JS_ROUNDUP(btincr, btsize);
    1:         JS_ARENA_GROW_CAST(gData->backTrackStack, REBackTrackData *,
19196:                            &gData->cx->regexpPool, btsize, btincr);
    1:         if (!gData->backTrackStack) {
 8296:             js_ReportOutOfScriptQuota(gData->cx);
    1:             gData->ok = JS_FALSE;
    1:             return NULL;
    1:         }
    1:         gData->backTrackStackSize = btsize + btincr;
    1:         result = (REBackTrackData *) ((char *)gData->backTrackStack + offset);
    1:     }
    1:     gData->backTrackSP = result;
    1:     result->sz = gData->cursz;
    1:     gData->cursz = sz;
    1: 
    1:     result->backtrack_op = op;
    1:     result->backtrack_pc = target;
    1:     result->cp = cp;
    1:     result->parenCount = parenCount;
   22:     result->parenIndex = parenIndex;
    1: 
    1:     result->saveStateStackTop = gData->stateStackTop;
    1:     JS_ASSERT(gData->stateStackTop);
    1:     memcpy(result + 1, gData->stateStack,
    1:            sizeof(REProgState) * result->saveStateStackTop);
    1: 
    1:     if (parenCount != 0) {
    1:         memcpy((char *)(result + 1) +
    1:                sizeof(REProgState) * result->saveStateStackTop,
    1:                &x->parens[parenIndex],
    1:                sizeof(RECapture) * parenCount);
    1:         for (i = 0; i != parenCount; i++)
    1:             x->parens[parenIndex + i].index = -1;
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
    1: 
    1: /*
    1:  *   Consecutive literal characters.
    1:  */
    1: #if 0
    1: static REMatchState *
    1: FlatNMatcher(REGlobalData *gData, REMatchState *x, jschar *matchChars,
    1:              size_t length)
    1: {
    1:     size_t i;
    1:     if (length > gData->cpend - x->cp)
    1:         return NULL;
    1:     for (i = 0; i != length; i++) {
    1:         if (matchChars[i] != x->cp[i])
    1:             return NULL;
    1:     }
    1:     x->cp += length;
    1:     return x;
    1: }
    1: #endif
    1: 
16284: static JS_ALWAYS_INLINE REMatchState *
    1: FlatNIMatcher(REGlobalData *gData, REMatchState *x, jschar *matchChars,
    1:               size_t length)
    1: {
    1:     size_t i;
    1:     JS_ASSERT(gData->cpend >= x->cp);
    1:     if (length > (size_t)(gData->cpend - x->cp))
    1:         return NULL;
    1:     for (i = 0; i != length; i++) {
    1:         if (upcase(matchChars[i]) != upcase(x->cp[i]))
    1:             return NULL;
    1:     }
    1:     x->cp += length;
    1:     return x;
    1: }
    1: 
    1: /*
    1:  * 1. Evaluate DecimalEscape to obtain an EscapeValue E.
    1:  * 2. If E is not a character then go to step 6.
    1:  * 3. Let ch be E's character.
    1:  * 4. Let A be a one-element RECharSet containing the character ch.
    1:  * 5. Call CharacterSetMatcher(A, false) and return its Matcher result.
    1:  * 6. E must be an integer. Let n be that integer.
    1:  * 7. If n=0 or n>NCapturingParens then throw a SyntaxError exception.
    1:  * 8. Return an internal Matcher closure that takes two arguments, a State x
    1:  *    and a Continuation c, and performs the following:
    1:  *     1. Let cap be x's captures internal array.
    1:  *     2. Let s be cap[n].
    1:  *     3. If s is undefined, then call c(x) and return its result.
    1:  *     4. Let e be x's endIndex.
    1:  *     5. Let len be s's length.
    1:  *     6. Let f be e+len.
    1:  *     7. If f>InputLength, return failure.
    1:  *     8. If there exists an integer i between 0 (inclusive) and len (exclusive)
    1:  *        such that Canonicalize(s[i]) is not the same character as
    1:  *        Canonicalize(Input [e+i]), then return failure.
    1:  *     9. Let y be the State (f, cap).
    1:  *     10. Call c(y) and return its result.
    1:  */
    1: static REMatchState *
    1: BackrefMatcher(REGlobalData *gData, REMatchState *x, size_t parenIndex)
    1: {
    1:     size_t len, i;
    1:     const jschar *parenContent;
    1:     RECapture *cap = &x->parens[parenIndex];
    1: 
    1:     if (cap->index == -1)
    1:         return x;
    1: 
    1:     len = cap->length;
    1:     if (x->cp + len > gData->cpend)
    1:         return NULL;
    1: 
    1:     parenContent = &gData->cpbegin[cap->index];
    1:     if (gData->regexp->flags & JSREG_FOLD) {
    1:         for (i = 0; i < len; i++) {
    1:             if (upcase(parenContent[i]) != upcase(x->cp[i]))
    1:                 return NULL;
    1:         }
    1:     } else {
    1:         for (i = 0; i < len; i++) {
    1:             if (parenContent[i] != x->cp[i])
    1:                 return NULL;
    1:         }
    1:     }
    1:     x->cp += len;
    1:     return x;
    1: }
    1: 
    1: 
    1: /* Add a single character to the RECharSet */
    1: static void
    1: AddCharacterToCharSet(RECharSet *cs, jschar c)
    1: {
    1:     uintN byteIndex = (uintN)(c >> 3);
    1:     JS_ASSERT(c <= cs->length);
    1:     cs->u.bits[byteIndex] |= 1 << (c & 0x7);
    1: }
    1: 
    1: 
    1: /* Add a character range, c1 to c2 (inclusive) to the RECharSet */
    1: static void
10332: AddCharacterRangeToCharSet(RECharSet *cs, uintN c1, uintN c2)
    1: {
    1:     uintN i;
    1: 
10332:     uintN byteIndex1 = c1 >> 3;
10332:     uintN byteIndex2 = c2 >> 3;
    1: 
14539:     JS_ASSERT(c2 <= cs->length && c1 <= c2);
    1: 
    1:     c1 &= 0x7;
    1:     c2 &= 0x7;
    1: 
    1:     if (byteIndex1 == byteIndex2) {
    1:         cs->u.bits[byteIndex1] |= ((uint8)0xFF >> (7 - (c2 - c1))) << c1;
    1:     } else {
    1:         cs->u.bits[byteIndex1] |= 0xFF << c1;
    1:         for (i = byteIndex1 + 1; i < byteIndex2; i++)
    1:             cs->u.bits[i] = 0xFF;
    1:         cs->u.bits[byteIndex2] |= (uint8)0xFF >> (7 - c2);
    1:     }
    1: }
    1: 
18859: struct CharacterRange {
18859:     jschar start;
18859:     jschar end;
18859: };
18859: 
18859: /*
18859:  * The following characters are taken from the ECMA-262 standard, section 7.2
18859:  * and 7.3, and the Unicode 3 standard, Table 6-1.
18859:  */
18859: static const CharacterRange WhiteSpaceRanges[] = {
18859:     /* TAB, LF, VT, FF, CR */
18859:     { 0x0009, 0x000D },
18859:     /* SPACE */
18859:     { 0x0020, 0x0020 },
18859:     /* NO-BREAK SPACE */
18859:     { 0x00A0, 0x00A0 },
18859:     /*
18859:      * EN QUAD, EM QUAD, EN SPACE, EM SPACE, THREE-PER-EM SPACE, FOUR-PER-EM
18859:      * SPACE, SIX-PER-EM SPACE, FIGURE SPACE, PUNCTUATION SPACE, THIN SPACE,
18859:      * HAIR SPACE, ZERO WIDTH SPACE
18859:      */
18859:     { 0x2000, 0x200B },
18859:     /* LS, PS */
18859:     { 0x2028, 0x2029 },
18859:     /* NARROW NO-BREAK SPACE */
18859:     { 0x202F, 0x202F },
18859:     /* IDEOGRAPHIC SPACE */
18859:     { 0x3000, 0x3000 }
18859: };
18859: 
18859: /* ECMA-262 standard, section 15.10.2.6. */
18859: static const CharacterRange WordRanges[] = {
18859:     { jschar('0'), jschar('9') },
18859:     { jschar('A'), jschar('Z') },
18859:     { jschar('_'), jschar('_') },
18859:     { jschar('a'), jschar('z') }
18859: };
18859: 
18859: static void
18859: AddCharacterRanges(RECharSet *charSet,
18859:                    const CharacterRange *range,
18859:                    const CharacterRange *end)
18859: {
18859:     for (; range < end; ++range)
18859:         AddCharacterRangeToCharSet(charSet, range->start, range->end);
18859: }
18859: 
18859: static void
18859: AddInvertedCharacterRanges(RECharSet *charSet,
18859:                            const CharacterRange *range,
18859:                            const CharacterRange *end)
18859: {
18859:     uint16 previous = 0;
18859:     for (; range < end; ++range) {
18859:         AddCharacterRangeToCharSet(charSet, previous, range->start - 1);
18859:         previous = range->end + 1;
18859:     }
18859:     AddCharacterRangeToCharSet(charSet, previous, charSet->length);
18859: }
18859:     
    1: /* Compile the source of the class into a RECharSet */
    1: static JSBool
22605: ProcessCharSet(JSContext *cx, JSRegExp *re, RECharSet *charSet)
    1: {
    1:     const jschar *src, *end;
    1:     JSBool inRange = JS_FALSE;
    1:     jschar rangeStart = 0;
    1:     uintN byteLength, n;
    1:     jschar c, thisCh;
    1:     intN nDigits, i;
    1: 
    1:     JS_ASSERT(!charSet->converted);
    1:     /*
    1:      * Assert that startIndex and length points to chars inside [] inside
    1:      * source string.
    1:      */
    1:     JS_ASSERT(1 <= charSet->u.src.startIndex);
    1:     JS_ASSERT(charSet->u.src.startIndex
22605:               < JSSTRING_LENGTH(re->source));
22605:     JS_ASSERT(charSet->u.src.length <= JSSTRING_LENGTH(re->source)
    1:                                        - 1 - charSet->u.src.startIndex);
    1: 
    1:     charSet->converted = JS_TRUE;
22605:     src = JSSTRING_CHARS(re->source) + charSet->u.src.startIndex;
    1:     end = src + charSet->u.src.length;
    1:     JS_ASSERT(src[-1] == '[');
    1:     JS_ASSERT(end[0] == ']');
    1: 
    1:     byteLength = (charSet->length >> 3) + 1;
22605:     charSet->u.bits = (uint8 *)JS_malloc(cx, byteLength);
    1:     if (!charSet->u.bits) {
22605:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
    1:     memset(charSet->u.bits, 0, byteLength);
    1: 
    1:     if (src == end)
    1:         return JS_TRUE;
    1: 
    1:     if (*src == '^') {
    1:         JS_ASSERT(charSet->sense == JS_FALSE);
    1:         ++src;
    1:     } else {
    1:         JS_ASSERT(charSet->sense == JS_TRUE);
    1:     }
    1: 
    1:     while (src != end) {
    1:         switch (*src) {
    1:           case '\\':
    1:             ++src;
    1:             c = *src++;
    1:             switch (c) {
    1:               case 'b':
    1:                 thisCh = 0x8;
    1:                 break;
    1:               case 'f':
    1:                 thisCh = 0xC;
    1:                 break;
    1:               case 'n':
    1:                 thisCh = 0xA;
    1:                 break;
    1:               case 'r':
    1:                 thisCh = 0xD;
    1:                 break;
    1:               case 't':
    1:                 thisCh = 0x9;
    1:                 break;
    1:               case 'v':
    1:                 thisCh = 0xB;
    1:                 break;
    1:               case 'c':
    1:                 if (src < end && JS_ISWORD(*src)) {
    1:                     thisCh = (jschar)(*src++ & 0x1F);
    1:                 } else {
    1:                     --src;
    1:                     thisCh = '\\';
    1:                 }
    1:                 break;
    1:               case 'x':
    1:                 nDigits = 2;
    1:                 goto lexHex;
    1:               case 'u':
    1:                 nDigits = 4;
    1:             lexHex:
    1:                 n = 0;
    1:                 for (i = 0; (i < nDigits) && (src < end); i++) {
    1:                     uintN digit;
    1:                     c = *src++;
    1:                     if (!isASCIIHexDigit(c, &digit)) {
    1:                         /*
    1:                          * Back off to accepting the original '\'
    1:                          * as a literal
    1:                          */
    1:                         src -= i + 1;
    1:                         n = '\\';
    1:                         break;
    1:                     }
    1:                     n = (n << 4) | digit;
    1:                 }
    1:                 thisCh = (jschar)n;
    1:                 break;
    1:               case '0':
    1:               case '1':
    1:               case '2':
    1:               case '3':
    1:               case '4':
    1:               case '5':
    1:               case '6':
    1:               case '7':
    1:                 /*
    1:                  *  This is a non-ECMA extension - decimal escapes (in this
    1:                  *  case, octal!) are supposed to be an error inside class
    1:                  *  ranges, but supported here for backwards compatibility.
    1:                  */
    1:                 n = JS7_UNDEC(c);
    1:                 c = *src;
    1:                 if ('0' <= c && c <= '7') {
    1:                     src++;
    1:                     n = 8 * n + JS7_UNDEC(c);
    1:                     c = *src;
    1:                     if ('0' <= c && c <= '7') {
    1:                         src++;
    1:                         i = 8 * n + JS7_UNDEC(c);
    1:                         if (i <= 0377)
    1:                             n = i;
    1:                         else
    1:                             src--;
    1:                     }
    1:                 }
    1:                 thisCh = (jschar)n;
    1:                 break;
    1: 
    1:               case 'd':
    1:                 AddCharacterRangeToCharSet(charSet, '0', '9');
    1:                 continue;   /* don't need range processing */
    1:               case 'D':
    1:                 AddCharacterRangeToCharSet(charSet, 0, '0' - 1);
    1:                 AddCharacterRangeToCharSet(charSet,
    1:                                            (jschar)('9' + 1),
    1:                                            (jschar)charSet->length);
    1:                 continue;
    1:               case 's':
18859:                 AddCharacterRanges(charSet, WhiteSpaceRanges,
18859:                                    WhiteSpaceRanges + JS_ARRAY_LENGTH(WhiteSpaceRanges));
    1:                 continue;
    1:               case 'S':
18859:                 AddInvertedCharacterRanges(charSet, WhiteSpaceRanges,
18859:                                            WhiteSpaceRanges + JS_ARRAY_LENGTH(WhiteSpaceRanges));
    1:                 continue;
    1:               case 'w':
18859:                 AddCharacterRanges(charSet, WordRanges,
18859:                                    WordRanges + JS_ARRAY_LENGTH(WordRanges));
    1:                 continue;
    1:               case 'W':
18859:                 AddInvertedCharacterRanges(charSet, WordRanges,
18859:                                            WordRanges + JS_ARRAY_LENGTH(WordRanges));
    1:                 continue;
    1:               default:
    1:                 thisCh = c;
    1:                 break;
    1: 
    1:             }
    1:             break;
    1: 
    1:           default:
    1:             thisCh = *src++;
    1:             break;
    1: 
    1:         }
    1:         if (inRange) {
22605:             if (re->flags & JSREG_FOLD) {
14539:                 int i;
14539: 
14539:                 JS_ASSERT(rangeStart <= thisCh);
14539:                 for (i = rangeStart; i <= thisCh; i++) {
14539:                     jschar uch, dch;
14539: 
14539:                     AddCharacterToCharSet(charSet, i);
14539:                     uch = upcase(i);
14539:                     dch = downcase(i);
14539:                     if (i != uch)
14539:                         AddCharacterToCharSet(charSet, uch);
14539:                     if (i != dch)
14539:                         AddCharacterToCharSet(charSet, dch);
  968:                 }
    1:             } else {
    1:                 AddCharacterRangeToCharSet(charSet, rangeStart, thisCh);
    1:             }
    1:             inRange = JS_FALSE;
    1:         } else {
22605:             if (re->flags & JSREG_FOLD) {
    1:                 AddCharacterToCharSet(charSet, upcase(thisCh));
    1:                 AddCharacterToCharSet(charSet, downcase(thisCh));
    1:             } else {
    1:                 AddCharacterToCharSet(charSet, thisCh);
    1:             }
    1:             if (src < end - 1) {
    1:                 if (*src == '-') {
    1:                     ++src;
    1:                     inRange = JS_TRUE;
    1:                     rangeStart = thisCh;
    1:                 }
    1:             }
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
22605: static inline JSBool
22605: MatcherProcessCharSet(REGlobalData *gData, RECharSet *charSet) {
22605:     JSBool rv = ProcessCharSet(gData->cx, gData->regexp, charSet);
22605:     if (!rv) gData->ok = JS_FALSE;
22605:     return rv;
22605: }
22605: 
    1: void
    1: js_DestroyRegExp(JSContext *cx, JSRegExp *re)
    1: {
    1:     if (JS_ATOMIC_DECREMENT(&re->nrefs) == 0) {
    1:         if (re->classList) {
    1:             uintN i;
    1:             for (i = 0; i < re->classCount; i++) {
    1:                 if (re->classList[i].converted)
    1:                     JS_free(cx, re->classList[i].u.bits);
    1:                 re->classList[i].u.bits = NULL;
    1:             }
    1:             JS_free(cx, re->classList);
    1:         }
    1:         JS_free(cx, re);
    1:     }
    1: }
    1: 
    1: static JSBool
    1: ReallocStateStack(REGlobalData *gData)
    1: {
    1:     size_t limit = gData->stateStackLimit;
    1:     size_t sz = sizeof(REProgState) * limit;
    1: 
19196:     JS_ARENA_GROW_CAST(gData->stateStack, REProgState *,
19196:                        &gData->cx->regexpPool, sz, sz);
    1:     if (!gData->stateStack) {
 8296:         js_ReportOutOfScriptQuota(gData->cx);
    1:         gData->ok = JS_FALSE;
    1:         return JS_FALSE;
    1:     }
    1:     gData->stateStackLimit = limit + limit;
    1:     return JS_TRUE;
    1: }
    1: 
    1: #define PUSH_STATE_STACK(data)                                                \
    1:     JS_BEGIN_MACRO                                                            \
    1:         ++(data)->stateStackTop;                                              \
    1:         if ((data)->stateStackTop == (data)->stateStackLimit &&               \
    1:             !ReallocStateStack((data))) {                                     \
    1:             return NULL;                                                      \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: /*
    1:  * Apply the current op against the given input to see if it's going to match
    1:  * or fail. Return false if we don't get a match, true if we do. If updatecp is
    1:  * true, then update the current state's cp. Always update startpc to the next
    1:  * op.
    1:  */
16284: static JS_ALWAYS_INLINE REMatchState *
    1: SimpleMatch(REGlobalData *gData, REMatchState *x, REOp op,
    1:             jsbytecode **startpc, JSBool updatecp)
    1: {
    1:     REMatchState *result = NULL;
    1:     jschar matchCh;
    1:     size_t parenIndex;
    1:     size_t offset, length, index;
    1:     jsbytecode *pc = *startpc;  /* pc has already been incremented past op */
    1:     jschar *source;
    1:     const jschar *startcp = x->cp;
    1:     jschar ch;
    1:     RECharSet *charSet;
    1: 
   22: #ifdef REGEXP_DEBUG
   22:     const char *opname = reop_names[op];
   22:     re_debug("\n%06d: %*s%s", pc - gData->regexp->program,
   22:              gData->stateStackTop * 2, "", opname);
   22: #endif
    1:     switch (op) {
    1:       case REOP_EMPTY:
    1:         result = x;
    1:         break;
    1:       case REOP_BOL:
    1:         if (x->cp != gData->cpbegin) {
    1:             if (!gData->cx->regExpStatics.multiline &&
    1:                 !(gData->regexp->flags & JSREG_MULTILINE)) {
    1:                 break;
    1:             }
    1:             if (!RE_IS_LINE_TERM(x->cp[-1]))
    1:                 break;
    1:         }
    1:         result = x;
    1:         break;
    1:       case REOP_EOL:
    1:         if (x->cp != gData->cpend) {
    1:             if (!gData->cx->regExpStatics.multiline &&
    1:                 !(gData->regexp->flags & JSREG_MULTILINE)) {
    1:                 break;
    1:             }
    1:             if (!RE_IS_LINE_TERM(*x->cp))
    1:                 break;
    1:         }
    1:         result = x;
    1:         break;
    1:       case REOP_WBDRY:
    1:         if ((x->cp == gData->cpbegin || !JS_ISWORD(x->cp[-1])) ^
    1:             !(x->cp != gData->cpend && JS_ISWORD(*x->cp))) {
    1:             result = x;
    1:         }
    1:         break;
    1:       case REOP_WNONBDRY:
    1:         if ((x->cp == gData->cpbegin || !JS_ISWORD(x->cp[-1])) ^
    1:             (x->cp != gData->cpend && JS_ISWORD(*x->cp))) {
    1:             result = x;
    1:         }
    1:         break;
    1:       case REOP_DOT:
    1:         if (x->cp != gData->cpend && !RE_IS_LINE_TERM(*x->cp)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_DIGIT:
  899:         if (x->cp != gData->cpend && JS7_ISDEC(*x->cp)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_NONDIGIT:
  899:         if (x->cp != gData->cpend && !JS7_ISDEC(*x->cp)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_ALNUM:
    1:         if (x->cp != gData->cpend && JS_ISWORD(*x->cp)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_NONALNUM:
    1:         if (x->cp != gData->cpend && !JS_ISWORD(*x->cp)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_SPACE:
    1:         if (x->cp != gData->cpend && JS_ISSPACE(*x->cp)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_NONSPACE:
    1:         if (x->cp != gData->cpend && !JS_ISSPACE(*x->cp)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_BACKREF:
    1:         pc = ReadCompactIndex(pc, &parenIndex);
    1:         JS_ASSERT(parenIndex < gData->regexp->parenCount);
    1:         result = BackrefMatcher(gData, x, parenIndex);
    1:         break;
    1:       case REOP_FLAT:
    1:         pc = ReadCompactIndex(pc, &offset);
    1:         JS_ASSERT(offset < JSSTRING_LENGTH(gData->regexp->source));
    1:         pc = ReadCompactIndex(pc, &length);
    1:         JS_ASSERT(1 <= length);
    1:         JS_ASSERT(length <= JSSTRING_LENGTH(gData->regexp->source) - offset);
    1:         if (length <= (size_t)(gData->cpend - x->cp)) {
    1:             source = JSSTRING_CHARS(gData->regexp->source) + offset;
   22:             re_debug_chars(source, length);
    1:             for (index = 0; index != length; index++) {
    1:                 if (source[index] != x->cp[index])
    1:                     return NULL;
    1:             }
    1:             x->cp += length;
    1:             result = x;
    1:         }
    1:         break;
    1:       case REOP_FLAT1:
    1:         matchCh = *pc++;
   22:         re_debug(" '%c' == '%c'", (char)matchCh, (char)*x->cp);
    1:         if (x->cp != gData->cpend && *x->cp == matchCh) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_FLATi:
    1:         pc = ReadCompactIndex(pc, &offset);
    1:         JS_ASSERT(offset < JSSTRING_LENGTH(gData->regexp->source));
    1:         pc = ReadCompactIndex(pc, &length);
    1:         JS_ASSERT(1 <= length);
    1:         JS_ASSERT(length <= JSSTRING_LENGTH(gData->regexp->source) - offset);
    1:         source = JSSTRING_CHARS(gData->regexp->source);
    1:         result = FlatNIMatcher(gData, x, source + offset, length);
    1:         break;
    1:       case REOP_FLAT1i:
    1:         matchCh = *pc++;
    1:         if (x->cp != gData->cpend && upcase(*x->cp) == upcase(matchCh)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_UCFLAT1:
    1:         matchCh = GET_ARG(pc);
   22:         re_debug(" '%c' == '%c'", (char)matchCh, (char)*x->cp);
    1:         pc += ARG_LEN;
    1:         if (x->cp != gData->cpend && *x->cp == matchCh) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_UCFLAT1i:
    1:         matchCh = GET_ARG(pc);
    1:         pc += ARG_LEN;
    1:         if (x->cp != gData->cpend && upcase(*x->cp) == upcase(matchCh)) {
    1:             result = x;
    1:             result->cp++;
    1:         }
    1:         break;
    1:       case REOP_CLASS:
    1:         pc = ReadCompactIndex(pc, &index);
    1:         JS_ASSERT(index < gData->regexp->classCount);
    1:         if (x->cp != gData->cpend) {
    1:             charSet = &gData->regexp->classList[index];
    1:             JS_ASSERT(charSet->converted);
    1:             ch = *x->cp;
    1:             index = ch >> 3;
    1:             if (charSet->length != 0 &&
    1:                 ch <= charSet->length &&
    1:                 (charSet->u.bits[index] & (1 << (ch & 0x7)))) {
    1:                 result = x;
    1:                 result->cp++;
    1:             }
    1:         }
    1:         break;
    1:       case REOP_NCLASS:
    1:         pc = ReadCompactIndex(pc, &index);
    1:         JS_ASSERT(index < gData->regexp->classCount);
    1:         if (x->cp != gData->cpend) {
    1:             charSet = &gData->regexp->classList[index];
    1:             JS_ASSERT(charSet->converted);
    1:             ch = *x->cp;
    1:             index = ch >> 3;
    1:             if (charSet->length == 0 ||
    1:                 ch > charSet->length ||
    1:                 !(charSet->u.bits[index] & (1 << (ch & 0x7)))) {
    1:                 result = x;
    1:                 result->cp++;
    1:             }
    1:         }
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(JS_FALSE);
    1:     }
    1:     if (result) {
    1:         if (!updatecp)
    1:             x->cp = startcp;
    1:         *startpc = pc;
   22:         re_debug(" * ");
    1:         return result;
    1:     }
    1:     x->cp = startcp;
    1:     return NULL;
    1: }
    1: 
16284: static JS_ALWAYS_INLINE REMatchState *
    1: ExecuteREBytecode(REGlobalData *gData, REMatchState *x)
    1: {
    1:     REMatchState *result = NULL;
    1:     REBackTrackData *backTrackData;
    1:     jsbytecode *nextpc, *testpc;
    1:     REOp nextop;
    1:     RECapture *cap;
    1:     REProgState *curState;
    1:     const jschar *startcp;
    1:     size_t parenIndex, k;
    1:     size_t parenSoFar = 0;
    1: 
    1:     jschar matchCh1, matchCh2;
    1:     RECharSet *charSet;
    1: 
    1:     JSBool anchor;
    1:     jsbytecode *pc = gData->regexp->program;
    1:     REOp op = (REOp) *pc++;
    1: 
    1:     /*
    1:      * If the first node is a simple match, step the index into the string
    1:      * until that match is made, or fail if it can't be found at all.
    1:      */
    1:     if (REOP_IS_SIMPLE(op) && !(gData->regexp->flags & JSREG_STICKY)) {
    1:         anchor = JS_FALSE;
    1:         while (x->cp <= gData->cpend) {
    1:             nextpc = pc;    /* reset back to start each time */
    1:             result = SimpleMatch(gData, x, op, &nextpc, JS_TRUE);
    1:             if (result) {
    1:                 anchor = JS_TRUE;
    1:                 x = result;
    1:                 pc = nextpc;    /* accept skip to next opcode */
    1:                 op = (REOp) *pc++;
    1:                 JS_ASSERT(op < REOP_LIMIT);
    1:                 break;
    1:             }
    1:             gData->skipped++;
    1:             x->cp++;
    1:         }
    1:         if (!anchor)
   22:             goto bad;
    1:     }
    1: 
    1:     for (;;) {
   22: #ifdef REGEXP_DEBUG
   22:         const char *opname = reop_names[op];
   22:         re_debug("\n%06d: %*s%s", pc - gData->regexp->program,
   22:                  gData->stateStackTop * 2, "", opname);
   22: #endif
    1:         if (REOP_IS_SIMPLE(op)) {
    1:             result = SimpleMatch(gData, x, op, &pc, JS_TRUE);
    1:         } else {
    1:             curState = &gData->stateStack[gData->stateStackTop];
    1:             switch (op) {
    1:               case REOP_END:
   22:                 goto good;
    1:               case REOP_ALTPREREQ2:
    1:                 nextpc = pc + GET_OFFSET(pc);   /* start of next op */
    1:                 pc += ARG_LEN;
    1:                 matchCh2 = GET_ARG(pc);
    1:                 pc += ARG_LEN;
    1:                 k = GET_ARG(pc);
    1:                 pc += ARG_LEN;
    1: 
    1:                 if (x->cp != gData->cpend) {
    1:                     if (*x->cp == matchCh2)
    1:                         goto doAlt;
    1: 
    1:                     charSet = &gData->regexp->classList[k];
22605:                     if (!charSet->converted && !MatcherProcessCharSet(gData, charSet))
   22:                         goto bad;
    1:                     matchCh1 = *x->cp;
    1:                     k = matchCh1 >> 3;
    1:                     if ((charSet->length == 0 ||
    1:                          matchCh1 > charSet->length ||
    1:                          !(charSet->u.bits[k] & (1 << (matchCh1 & 0x7)))) ^
    1:                         charSet->sense) {
    1:                         goto doAlt;
    1:                     }
    1:                 }
    1:                 result = NULL;
    1:                 break;
    1: 
    1:               case REOP_ALTPREREQ:
    1:                 nextpc = pc + GET_OFFSET(pc);   /* start of next op */
    1:                 pc += ARG_LEN;
    1:                 matchCh1 = GET_ARG(pc);
    1:                 pc += ARG_LEN;
    1:                 matchCh2 = GET_ARG(pc);
    1:                 pc += ARG_LEN;
    1:                 if (x->cp == gData->cpend ||
    1:                     (*x->cp != matchCh1 && *x->cp != matchCh2)) {
    1:                     result = NULL;
    1:                     break;
    1:                 }
    1:                 /* else false thru... */
    1: 
    1:               case REOP_ALT:
    1:               doAlt:
    1:                 nextpc = pc + GET_OFFSET(pc);   /* start of next alternate */
    1:                 pc += ARG_LEN;                  /* start of this alternate */
    1:                 curState->parenSoFar = parenSoFar;
    1:                 PUSH_STATE_STACK(gData);
    1:                 op = (REOp) *pc++;
    1:                 startcp = x->cp;
    1:                 if (REOP_IS_SIMPLE(op)) {
    1:                     if (!SimpleMatch(gData, x, op, &pc, JS_TRUE)) {
    1:                         op = (REOp) *nextpc++;
    1:                         pc = nextpc;
    1:                         continue;
    1:                     }
    1:                     result = x;
    1:                     op = (REOp) *pc++;
    1:                 }
    1:                 nextop = (REOp) *nextpc++;
    1:                 if (!PushBackTrackState(gData, nextop, nextpc, x, startcp, 0, 0))
   22:                     goto bad;
    1:                 continue;
    1: 
    1:               /*
    1:                * Occurs at (successful) end of REOP_ALT,
    1:                */
    1:               case REOP_JUMP:
    1:                 /*
    1:                  * If we have not gotten a result here, it is because of an
    1:                  * empty match.  Do the same thing REOP_EMPTY would do.
    1:                  */
    1:                 if (!result)
    1:                     result = x;
    1: 
    1:                 --gData->stateStackTop;
    1:                 pc += GET_OFFSET(pc);
    1:                 op = (REOp) *pc++;
    1:                 continue;
    1: 
    1:               /*
    1:                * Occurs at last (successful) end of REOP_ALT,
    1:                */
    1:               case REOP_ENDALT:
    1:                 /*
    1:                  * If we have not gotten a result here, it is because of an
    1:                  * empty match.  Do the same thing REOP_EMPTY would do.
    1:                  */
    1:                 if (!result)
    1:                     result = x;
    1: 
    1:                 --gData->stateStackTop;
    1:                 op = (REOp) *pc++;
    1:                 continue;
    1: 
    1:               case REOP_LPAREN:
    1:                 pc = ReadCompactIndex(pc, &parenIndex);
  211:                 re_debug("[ %lu ]", (unsigned long) parenIndex);
    1:                 JS_ASSERT(parenIndex < gData->regexp->parenCount);
    1:                 if (parenIndex + 1 > parenSoFar)
    1:                     parenSoFar = parenIndex + 1;
    1:                 x->parens[parenIndex].index = x->cp - gData->cpbegin;
    1:                 x->parens[parenIndex].length = 0;
    1:                 op = (REOp) *pc++;
    1:                 continue;
    1: 
    1:               case REOP_RPAREN:
 5754:               {
 5754:                 ptrdiff_t delta;
 5754: 
    1:                 pc = ReadCompactIndex(pc, &parenIndex);
    1:                 JS_ASSERT(parenIndex < gData->regexp->parenCount);
    1:                 cap = &x->parens[parenIndex];
 5754:                 delta = x->cp - (gData->cpbegin + cap->index);
 5754:                 cap->length = (delta < 0) ? 0 : (size_t) delta;
    1:                 op = (REOp) *pc++;
   38: 
   38:                 if (!result)
   38:                     result = x;
    1:                 continue;
 5754:               }
    1:               case REOP_ASSERT:
    1:                 nextpc = pc + GET_OFFSET(pc);  /* start of term after ASSERT */
    1:                 pc += ARG_LEN;                 /* start of ASSERT child */
    1:                 op = (REOp) *pc++;
    1:                 testpc = pc;
    1:                 if (REOP_IS_SIMPLE(op) &&
    1:                     !SimpleMatch(gData, x, op, &testpc, JS_FALSE)) {
    1:                     result = NULL;
    1:                     break;
    1:                 }
    1:                 curState->u.assertion.top =
    1:                     (char *)gData->backTrackSP - (char *)gData->backTrackStack;
    1:                 curState->u.assertion.sz = gData->cursz;
    1:                 curState->index = x->cp - gData->cpbegin;
    1:                 curState->parenSoFar = parenSoFar;
    1:                 PUSH_STATE_STACK(gData);
    1:                 if (!PushBackTrackState(gData, REOP_ASSERTTEST,
    1:                                         nextpc, x, x->cp, 0, 0)) {
   22:                     goto bad;
    1:                 }
    1:                 continue;
    1: 
    1:               case REOP_ASSERT_NOT:
    1:                 nextpc = pc + GET_OFFSET(pc);
    1:                 pc += ARG_LEN;
    1:                 op = (REOp) *pc++;
    1:                 testpc = pc;
    1:                 if (REOP_IS_SIMPLE(op) /* Note - fail to fail! */ &&
    1:                     SimpleMatch(gData, x, op, &testpc, JS_FALSE) &&
    1:                     *testpc == REOP_ASSERTNOTTEST) {
    1:                     result = NULL;
    1:                     break;
    1:                 }
    1:                 curState->u.assertion.top
    1:                     = (char *)gData->backTrackSP -
    1:                       (char *)gData->backTrackStack;
    1:                 curState->u.assertion.sz = gData->cursz;
    1:                 curState->index = x->cp - gData->cpbegin;
    1:                 curState->parenSoFar = parenSoFar;
    1:                 PUSH_STATE_STACK(gData);
    1:                 if (!PushBackTrackState(gData, REOP_ASSERTNOTTEST,
    1:                                         nextpc, x, x->cp, 0, 0)) {
   22:                     goto bad;
    1:                 }
    1:                 continue;
    1: 
    1:               case REOP_ASSERTTEST:
    1:                 --gData->stateStackTop;
    1:                 --curState;
    1:                 x->cp = gData->cpbegin + curState->index;
    1:                 gData->backTrackSP =
    1:                     (REBackTrackData *) ((char *)gData->backTrackStack +
    1:                                          curState->u.assertion.top);
    1:                 gData->cursz = curState->u.assertion.sz;
    1:                 if (result)
    1:                     result = x;
    1:                 break;
    1: 
    1:               case REOP_ASSERTNOTTEST:
    1:                 --gData->stateStackTop;
    1:                 --curState;
    1:                 x->cp = gData->cpbegin + curState->index;
    1:                 gData->backTrackSP =
    1:                     (REBackTrackData *) ((char *)gData->backTrackStack +
    1:                                          curState->u.assertion.top);
    1:                 gData->cursz = curState->u.assertion.sz;
    1:                 result = (!result) ? x : NULL;
    1:                 break;
    1:               case REOP_STAR:
    1:                 curState->u.quantifier.min = 0;
    1:                 curState->u.quantifier.max = (uintN)-1;
    1:                 goto quantcommon;
    1:               case REOP_PLUS:
    1:                 curState->u.quantifier.min = 1;
    1:                 curState->u.quantifier.max = (uintN)-1;
    1:                 goto quantcommon;
    1:               case REOP_OPT:
    1:                 curState->u.quantifier.min = 0;
    1:                 curState->u.quantifier.max = 1;
    1:                 goto quantcommon;
    1:               case REOP_QUANT:
    1:                 pc = ReadCompactIndex(pc, &k);
    1:                 curState->u.quantifier.min = k;
    1:                 pc = ReadCompactIndex(pc, &k);
    1:                 /* max is k - 1 to use one byte for (uintN)-1 sentinel. */
    1:                 curState->u.quantifier.max = k - 1;
    1:                 JS_ASSERT(curState->u.quantifier.min
    1:                           <= curState->u.quantifier.max);
    1:               quantcommon:
    1:                 if (curState->u.quantifier.max == 0) {
    1:                     pc = pc + GET_OFFSET(pc);
    1:                     op = (REOp) *pc++;
    1:                     result = x;
    1:                     continue;
    1:                 }
    1:                 /* Step over <next> */
    1:                 nextpc = pc + ARG_LEN;
    1:                 op = (REOp) *nextpc++;
    1:                 startcp = x->cp;
    1:                 if (REOP_IS_SIMPLE(op)) {
    1:                     if (!SimpleMatch(gData, x, op, &nextpc, JS_TRUE)) {
    1:                         if (curState->u.quantifier.min == 0)
    1:                             result = x;
    1:                         else
    1:                             result = NULL;
    1:                         pc = pc + GET_OFFSET(pc);
    1:                         break;
    1:                     }
    1:                     op = (REOp) *nextpc++;
    1:                     result = x;
    1:                 }
    1:                 curState->index = startcp - gData->cpbegin;
    1:                 curState->continue_op = REOP_REPEAT;
    1:                 curState->continue_pc = pc;
    1:                 curState->parenSoFar = parenSoFar;
    1:                 PUSH_STATE_STACK(gData);
    1:                 if (curState->u.quantifier.min == 0 &&
    1:                     !PushBackTrackState(gData, REOP_REPEAT, pc, x, startcp,
    1:                                         0, 0)) {
   22:                     goto bad;
    1:                 }
    1:                 pc = nextpc;
    1:                 continue;
    1: 
    1:               case REOP_ENDCHILD: /* marks the end of a quantifier child */
    1:                 pc = curState[-1].continue_pc;
 3164:                 op = (REOp) curState[-1].continue_op;
  527: 
  527:                 if (!result)
  527:                     result = x;
    1:                 continue;
    1: 
    1:               case REOP_REPEAT:
    1:                 --curState;
    1:                 do {
    1:                     --gData->stateStackTop;
    1:                     if (!result) {
    1:                         /* Failed, see if we have enough children. */
    1:                         if (curState->u.quantifier.min == 0)
    1:                             goto repeatDone;
    1:                         goto break_switch;
    1:                     }
    1:                     if (curState->u.quantifier.min == 0 &&
    1:                         x->cp == gData->cpbegin + curState->index) {
    1:                         /* matched an empty string, that'll get us nowhere */
    1:                         result = NULL;
    1:                         goto break_switch;
    1:                     }
    1:                     if (curState->u.quantifier.min != 0)
    1:                         curState->u.quantifier.min--;
    1:                     if (curState->u.quantifier.max != (uintN) -1)
    1:                         curState->u.quantifier.max--;
    1:                     if (curState->u.quantifier.max == 0)
    1:                         goto repeatDone;
    1:                     nextpc = pc + ARG_LEN;
    1:                     nextop = (REOp) *nextpc;
    1:                     startcp = x->cp;
    1:                     if (REOP_IS_SIMPLE(nextop)) {
    1:                         nextpc++;
    1:                         if (!SimpleMatch(gData, x, nextop, &nextpc, JS_TRUE)) {
    1:                             if (curState->u.quantifier.min == 0)
    1:                                 goto repeatDone;
    1:                             result = NULL;
    1:                             goto break_switch;
    1:                         }
    1:                         result = x;
    1:                     }
    1:                     curState->index = startcp - gData->cpbegin;
    1:                     PUSH_STATE_STACK(gData);
    1:                     if (curState->u.quantifier.min == 0 &&
    1:                         !PushBackTrackState(gData, REOP_REPEAT,
    1:                                             pc, x, startcp,
    1:                                             curState->parenSoFar,
    1:                                             parenSoFar -
    1:                                             curState->parenSoFar)) {
   22:                         goto bad;
    1:                     }
    1:                 } while (*nextpc == REOP_ENDCHILD);
    1:                 pc = nextpc;
    1:                 op = (REOp) *pc++;
    1:                 parenSoFar = curState->parenSoFar;
    1:                 continue;
    1: 
    1:               repeatDone:
    1:                 result = x;
    1:                 pc += GET_OFFSET(pc);
    1:                 goto break_switch;
    1: 
    1:               case REOP_MINIMALSTAR:
    1:                 curState->u.quantifier.min = 0;
    1:                 curState->u.quantifier.max = (uintN)-1;
    1:                 goto minimalquantcommon;
    1:               case REOP_MINIMALPLUS:
    1:                 curState->u.quantifier.min = 1;
    1:                 curState->u.quantifier.max = (uintN)-1;
    1:                 goto minimalquantcommon;
    1:               case REOP_MINIMALOPT:
    1:                 curState->u.quantifier.min = 0;
    1:                 curState->u.quantifier.max = 1;
    1:                 goto minimalquantcommon;
    1:               case REOP_MINIMALQUANT:
    1:                 pc = ReadCompactIndex(pc, &k);
    1:                 curState->u.quantifier.min = k;
    1:                 pc = ReadCompactIndex(pc, &k);
    1:                 /* See REOP_QUANT comments about k - 1. */
    1:                 curState->u.quantifier.max = k - 1;
    1:                 JS_ASSERT(curState->u.quantifier.min
    1:                           <= curState->u.quantifier.max);
    1:               minimalquantcommon:
    1:                 curState->index = x->cp - gData->cpbegin;
    1:                 curState->parenSoFar = parenSoFar;
    1:                 PUSH_STATE_STACK(gData);
    1:                 if (curState->u.quantifier.min != 0) {
    1:                     curState->continue_op = REOP_MINIMALREPEAT;
    1:                     curState->continue_pc = pc;
    1:                     /* step over <next> */
    1:                     pc += OFFSET_LEN;
    1:                     op = (REOp) *pc++;
    1:                 } else {
    1:                     if (!PushBackTrackState(gData, REOP_MINIMALREPEAT,
    1:                                             pc, x, x->cp, 0, 0)) {
   22:                         goto bad;
    1:                     }
    1:                     --gData->stateStackTop;
    1:                     pc = pc + GET_OFFSET(pc);
    1:                     op = (REOp) *pc++;
    1:                 }
    1:                 continue;
    1: 
    1:               case REOP_MINIMALREPEAT:
    1:                 --gData->stateStackTop;
    1:                 --curState;
    1: 
   22:                 re_debug("{%d,%d}", curState->u.quantifier.min,
   22:                          curState->u.quantifier.max);
   22: #define PREPARE_REPEAT()                                                      \
   22:     JS_BEGIN_MACRO                                                            \
   22:         curState->index = x->cp - gData->cpbegin;                             \
   22:         curState->continue_op = REOP_MINIMALREPEAT;                           \
   22:         curState->continue_pc = pc;                                           \
   22:         pc += ARG_LEN;                                                        \
   22:         for (k = curState->parenSoFar; k < parenSoFar; k++)                   \
   22:             x->parens[k].index = -1;                                          \
   22:         PUSH_STATE_STACK(gData);                                              \
   22:         op = (REOp) *pc++;                                                    \
   22:         JS_ASSERT(op < REOP_LIMIT);                                           \
   22:     JS_END_MACRO
   22: 
    1:                 if (!result) {
   22:                     re_debug(" - ");
    1:                     /*
    1:                      * Non-greedy failure - try to consume another child.
    1:                      */
    1:                     if (curState->u.quantifier.max == (uintN) -1 ||
    1:                         curState->u.quantifier.max > 0) {
   22:                         PREPARE_REPEAT();
    1:                         continue;
    1:                     }
    1:                     /* Don't need to adjust pc since we're going to pop. */
    1:                     break;
    1:                 }
    1:                 if (curState->u.quantifier.min == 0 &&
    1:                     x->cp == gData->cpbegin + curState->index) {
    1:                     /* Matched an empty string, that'll get us nowhere. */
    1:                     result = NULL;
    1:                     break;
    1:                 }
    1:                 if (curState->u.quantifier.min != 0)
    1:                     curState->u.quantifier.min--;
    1:                 if (curState->u.quantifier.max != (uintN) -1)
    1:                     curState->u.quantifier.max--;
    1:                 if (curState->u.quantifier.min != 0) {
   22:                     PREPARE_REPEAT();
    1:                     continue;
    1:                 }
    1:                 curState->index = x->cp - gData->cpbegin;
    1:                 curState->parenSoFar = parenSoFar;
    1:                 PUSH_STATE_STACK(gData);
    1:                 if (!PushBackTrackState(gData, REOP_MINIMALREPEAT,
    1:                                         pc, x, x->cp,
    1:                                         curState->parenSoFar,
    1:                                         parenSoFar - curState->parenSoFar)) {
   22:                     goto bad;
    1:                 }
    1:                 --gData->stateStackTop;
    1:                 pc = pc + GET_OFFSET(pc);
    1:                 op = (REOp) *pc++;
    1:                 JS_ASSERT(op < REOP_LIMIT);
    1:                 continue;
    1:               default:
    1:                 JS_ASSERT(JS_FALSE);
    1:                 result = NULL;
    1:             }
    1:           break_switch:;
    1:         }
    1: 
    1:         /*
    1:          *  If the match failed and there's a backtrack option, take it.
    1:          *  Otherwise this is a complete and utter failure.
    1:          */
    1:         if (!result) {
    1:             if (gData->cursz == 0)
    1:                 return NULL;
    1:             if (!JS_CHECK_OPERATION_LIMIT(gData->cx, JSOW_JUMP)) {
    1:                 gData->ok = JS_FALSE;
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Potentially detect explosive regex here. */
    1:             gData->backTrackCount++;
    1:             if (gData->backTrackLimit &&
    1:                 gData->backTrackCount >= gData->backTrackLimit) {
    1:                 JS_ReportErrorNumber(gData->cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_REGEXP_TOO_COMPLEX);
    1:                 gData->ok = JS_FALSE;
    1:                 return NULL;
    1:             }
    1: 
    1:             backTrackData = gData->backTrackSP;
    1:             gData->cursz = backTrackData->sz;
    1:             gData->backTrackSP =
    1:                 (REBackTrackData *) ((char *)backTrackData - backTrackData->sz);
    1:             x->cp = backTrackData->cp;
    1:             pc = backTrackData->backtrack_pc;
 3164:             op = (REOp) backTrackData->backtrack_op;
    1:             JS_ASSERT(op < REOP_LIMIT);
    1:             gData->stateStackTop = backTrackData->saveStateStackTop;
    1:             JS_ASSERT(gData->stateStackTop);
    1: 
    1:             memcpy(gData->stateStack, backTrackData + 1,
    1:                    sizeof(REProgState) * backTrackData->saveStateStackTop);
    1:             curState = &gData->stateStack[gData->stateStackTop - 1];
    1: 
    1:             if (backTrackData->parenCount) {
    1:                 memcpy(&x->parens[backTrackData->parenIndex],
    1:                        (char *)(backTrackData + 1) +
    1:                        sizeof(REProgState) * backTrackData->saveStateStackTop,
    1:                        sizeof(RECapture) * backTrackData->parenCount);
    1:                 parenSoFar = backTrackData->parenIndex + backTrackData->parenCount;
    1:             } else {
    1:                 for (k = curState->parenSoFar; k < parenSoFar; k++)
    1:                     x->parens[k].index = -1;
    1:                 parenSoFar = curState->parenSoFar;
    1:             }
   22: 
  211:             re_debug("\tBT_Pop: %ld,%ld",
  211:                      (unsigned long) backTrackData->parenIndex,
  211:                      (unsigned long) backTrackData->parenCount);
    1:             continue;
    1:         }
    1:         x = result;
    1: 
    1:         /*
    1:          *  Continue with the expression.
    1:          */
    1:         op = (REOp)*pc++;
    1:         JS_ASSERT(op < REOP_LIMIT);
    1:     }
   22: 
   22: bad:
   22:     re_debug("\n");
    1:     return NULL;
   22: 
   22: good:
   22:     re_debug("\n");
   22:     return x;
    1: }
    1: 
    1: static REMatchState *
    1: MatchRegExp(REGlobalData *gData, REMatchState *x)
    1: {
    1:     REMatchState *result;
    1:     const jschar *cp = x->cp;
    1:     const jschar *cp2;
    1:     uintN j;
21497: #ifdef JS_TRACER
22611:     NativeRegExp native;
21491: 
21491:     /* Run with native regexp if possible. */
22611:     if (TRACING_ENABLED(gData->cx) && 
22611:         (native = GetNativeRegExp(gData->cx, gData->regexp))) {
21491:         gData->skipped = (ptrdiff_t) x->cp;
21547: 
21547:         debug_only_v(printf("entering REGEXP trace at %s:%u@%u, code: %p\n",
21547:                             gData->cx->fp->script->filename,
21685:                             js_FramePCToLineNumber(gData->cx, gData->cx->fp),
21685:                             FramePCOffset(gData->cx->fp),
22611:                             native););
21547: 
21491: #if defined(JS_NO_FASTCALL) && defined(NANOJIT_IA32)
22611:         SIMULATE_FASTCALL(result, x, gData, native);
21491: #else
22611:         result = native(x, gData);
21491: #endif
21547: 
21547:         debug_only_v(printf("leaving REGEXP trace\n"));
21547: 
21491:         gData->skipped = ((const jschar *) gData->skipped) - cp;
22611:         return result;
21491:     }
21497: #endif
    1:     /*
    1:      * Have to include the position beyond the last character
    1:      * in order to detect end-of-input/line condition.
    1:      */
    1:     for (cp2 = cp; cp2 <= gData->cpend; cp2++) {
    1:         gData->skipped = cp2 - cp;
    1:         x->cp = cp2;
    1:         for (j = 0; j < gData->regexp->parenCount; j++)
    1:             x->parens[j].index = -1;
    1:         result = ExecuteREBytecode(gData, x);
    1:         if (!gData->ok || result || (gData->regexp->flags & JSREG_STICKY))
    1:             return result;
    1:         gData->backTrackSP = gData->backTrackStack;
    1:         gData->cursz = 0;
    1:         gData->stateStackTop = 0;
    1:         cp2 = cp + gData->skipped;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: #define MIN_BACKTRACK_LIMIT 400000
    1: 
    1: static REMatchState *
    1: InitMatch(JSContext *cx, REGlobalData *gData, JSRegExp *re, size_t length)
    1: {
    1:     REMatchState *result;
    1:     uintN i;
    1: 
    1:     gData->backTrackStackSize = INITIAL_BACKTRACK;
    1:     JS_ARENA_ALLOCATE_CAST(gData->backTrackStack, REBackTrackData *,
19196:                            &cx->regexpPool,
    1:                            INITIAL_BACKTRACK);
    1:     if (!gData->backTrackStack)
    1:         goto bad;
    1: 
    1:     gData->backTrackSP = gData->backTrackStack;
    1:     gData->cursz = 0;
    1:     gData->backTrackCount = 0;
    1:     gData->backTrackLimit = 0;
    1:     if (JS_GetOptions(cx) & JSOPTION_RELIMIT) {
    1:         gData->backTrackLimit = length * length * length; /* O(n^3) */
    1:         if (gData->backTrackLimit < MIN_BACKTRACK_LIMIT)
    1:             gData->backTrackLimit = MIN_BACKTRACK_LIMIT;
    1:     }
    1: 
    1:     gData->stateStackLimit = INITIAL_STATESTACK;
    1:     JS_ARENA_ALLOCATE_CAST(gData->stateStack, REProgState *,
19196:                            &cx->regexpPool,
    1:                            sizeof(REProgState) * INITIAL_STATESTACK);
    1:     if (!gData->stateStack)
    1:         goto bad;
    1: 
    1:     gData->stateStackTop = 0;
    1:     gData->cx = cx;
    1:     gData->regexp = re;
    1:     gData->ok = JS_TRUE;
    1: 
    1:     JS_ARENA_ALLOCATE_CAST(result, REMatchState *,
19196:                            &cx->regexpPool,
    1:                            offsetof(REMatchState, parens)
    1:                            + re->parenCount * sizeof(RECapture));
    1:     if (!result)
    1:         goto bad;
    1: 
    1:     for (i = 0; i < re->classCount; i++) {
    1:         if (!re->classList[i].converted &&
22605:             !MatcherProcessCharSet(gData, &re->classList[i])) {
    1:             return NULL;
    1:         }
    1:     }
    1: 
    1:     return result;
    1: 
    1: bad:
 8296:     js_ReportOutOfScriptQuota(cx);
    1:     gData->ok = JS_FALSE;
    1:     return NULL;
    1: }
    1: 
    1: JSBool
    1: js_ExecuteRegExp(JSContext *cx, JSRegExp *re, JSString *str, size_t *indexp,
    1:                  JSBool test, jsval *rval)
    1: {
    1:     REGlobalData gData;
    1:     REMatchState *x, *result;
    1: 
    1:     const jschar *cp, *ep;
    1:     size_t i, length, start;
    1:     JSSubString *morepar;
    1:     JSBool ok;
    1:     JSRegExpStatics *res;
    1:     ptrdiff_t matchlen;
    1:     uintN num, morenum;
    1:     JSString *parstr, *matchstr;
    1:     JSObject *obj;
    1: 
    1:     RECapture *parsub = NULL;
19196:     void *mark;
19196:     int64 *timestamp;
    1: 
    1:     /*
    1:      * It's safe to load from cp because JSStrings have a zero at the end,
    1:      * and we never let cp get beyond cpend.
    1:      */
    1:     start = *indexp;
 4718:     JSSTRING_CHARS_AND_LENGTH(str, cp, length);
    1:     if (start > length)
    1:         start = length;
    1:     gData.cpbegin = cp;
    1:     gData.cpend = cp + length;
    1:     cp += start;
    1:     gData.start = start;
    1:     gData.skipped = 0;
    1: 
19196:     if (!cx->regexpPool.first.next) {
 8993:         /*
19196:          * The first arena in the regexpPool must have a timestamp at its base.
 8993:          */
19196:         JS_ARENA_ALLOCATE_CAST(timestamp, int64 *,
19196:                                &cx->regexpPool, sizeof *timestamp);
19196:         if (!timestamp)
19196:             return JS_FALSE;
19196:         *timestamp = JS_Now();
19196:     }
19196:     mark = JS_ARENA_MARK(&cx->regexpPool);
19196: 
    1:     x = InitMatch(cx, &gData, re, length);
    1: 
    1:     if (!x) {
    1:         ok = JS_FALSE;
    1:         goto out;
    1:     }
    1:     x->cp = cp;
    1: 
    1:     /*
    1:      * Call the recursive matcher to do the real work.  Return null on mismatch
    1:      * whether testing or not.  On match, return an extended Array object.
    1:      */
    1:     result = MatchRegExp(&gData, x);
    1:     ok = gData.ok;
    1:     if (!ok)
    1:         goto out;
    1:     if (!result) {
    1:         *rval = JSVAL_NULL;
    1:         goto out;
    1:     }
    1:     cp = result->cp;
    1:     i = cp - gData.cpbegin;
    1:     *indexp = i;
    1:     matchlen = i - (start + gData.skipped);
    1:     ep = cp;
    1:     cp -= matchlen;
    1: 
    1:     if (test) {
    1:         /*
    1:          * Testing for a match and updating cx->regExpStatics: don't allocate
    1:          * an array object, do return true.
    1:          */
    1:         *rval = JSVAL_TRUE;
    1: 
    1:         /* Avoid warning.  (gcc doesn't detect that obj is needed iff !test); */
    1:         obj = NULL;
    1:     } else {
    1:         /*
    1:          * The array returned on match has element 0 bound to the matched
    1:          * string, elements 1 through state.parenCount bound to the paren
    1:          * matches, an index property telling the length of the left context,
    1:          * and an input property referring to the input string.
    1:          */
11835:         obj = js_NewSlowArrayObject(cx);
    1:         if (!obj) {
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
    1:         *rval = OBJECT_TO_JSVAL(obj);
    1: 
    1: #define DEFVAL(val, id) {                                                     \
    1:     ok = js_DefineProperty(cx, obj, id, val,                                  \
    1:                            JS_PropertyStub, JS_PropertyStub,                  \
    1:                            JSPROP_ENUMERATE, NULL);                           \
    1:     if (!ok) {                                                                \
    1:         cx->weakRoots.newborn[GCX_OBJECT] = NULL;                             \
    1:         cx->weakRoots.newborn[GCX_STRING] = NULL;                             \
    1:         goto out;                                                             \
    1:     }                                                                         \
    1: }
    1: 
 4076:         matchstr = js_NewStringCopyN(cx, cp, matchlen);
    1:         if (!matchstr) {
    1:             cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
    1:         DEFVAL(STRING_TO_JSVAL(matchstr), INT_TO_JSID(0));
    1:     }
    1: 
    1:     res = &cx->regExpStatics;
    1:     res->input = str;
    1:     res->parenCount = re->parenCount;
    1:     if (re->parenCount == 0) {
    1:         res->lastParen = js_EmptySubString;
    1:     } else {
    1:         for (num = 0; num < re->parenCount; num++) {
    1:             parsub = &result->parens[num];
    1:             if (num < 9) {
    1:                 if (parsub->index == -1) {
    1:                     res->parens[num].chars = NULL;
    1:                     res->parens[num].length = 0;
    1:                 } else {
    1:                     res->parens[num].chars = gData.cpbegin + parsub->index;
    1:                     res->parens[num].length = parsub->length;
    1:                 }
    1:             } else {
    1:                 morenum = num - 9;
    1:                 morepar = res->moreParens;
    1:                 if (!morepar) {
    1:                     res->moreLength = 10;
    1:                     morepar = (JSSubString*)
    1:                         JS_malloc(cx, 10 * sizeof(JSSubString));
    1:                 } else if (morenum >= res->moreLength) {
    1:                     res->moreLength += 10;
    1:                     morepar = (JSSubString*)
    1:                         JS_realloc(cx, morepar,
    1:                                    res->moreLength * sizeof(JSSubString));
    1:                 }
    1:                 if (!morepar) {
    1:                     cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:                     cx->weakRoots.newborn[GCX_STRING] = NULL;
    1:                     ok = JS_FALSE;
    1:                     goto out;
    1:                 }
    1:                 res->moreParens = morepar;
    1:                 if (parsub->index == -1) {
    1:                     morepar[morenum].chars = NULL;
    1:                     morepar[morenum].length = 0;
    1:                 } else {
    1:                     morepar[morenum].chars = gData.cpbegin + parsub->index;
    1:                     morepar[morenum].length = parsub->length;
    1:                 }
    1:             }
    1:             if (test)
    1:                 continue;
    1:             if (parsub->index == -1) {
    1:                 ok = js_DefineProperty(cx, obj, INT_TO_JSID(num + 1),
    1:                                        JSVAL_VOID, NULL, NULL,
    1:                                        JSPROP_ENUMERATE, NULL);
    1:             } else {
    1:                 parstr = js_NewStringCopyN(cx, gData.cpbegin + parsub->index,
 4076:                                            parsub->length);
    1:                 if (!parstr) {
    1:                     cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:                     cx->weakRoots.newborn[GCX_STRING] = NULL;
    1:                     ok = JS_FALSE;
    1:                     goto out;
    1:                 }
    1:                 ok = js_DefineProperty(cx, obj, INT_TO_JSID(num + 1),
    1:                                        STRING_TO_JSVAL(parstr), NULL, NULL,
    1:                                        JSPROP_ENUMERATE, NULL);
    1:             }
    1:             if (!ok) {
    1:                 cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:                 cx->weakRoots.newborn[GCX_STRING] = NULL;
    1:                 goto out;
    1:             }
    1:         }
    1:         if (parsub->index == -1) {
    1:             res->lastParen = js_EmptySubString;
    1:         } else {
    1:             res->lastParen.chars = gData.cpbegin + parsub->index;
    1:             res->lastParen.length = parsub->length;
    1:         }
    1:     }
    1: 
    1:     if (!test) {
    1:         /*
    1:          * Define the index and input properties last for better for/in loop
    1:          * order (so they come after the elements).
    1:          */
    1:         DEFVAL(INT_TO_JSVAL(start + gData.skipped),
    1:                ATOM_TO_JSID(cx->runtime->atomState.indexAtom));
    1:         DEFVAL(STRING_TO_JSVAL(str),
    1:                ATOM_TO_JSID(cx->runtime->atomState.inputAtom));
    1:     }
    1: 
    1: #undef DEFVAL
    1: 
    1:     res->lastMatch.chars = cp;
    1:     res->lastMatch.length = matchlen;
    1: 
    1:     /*
    1:      * For JS1.3 and ECMAv2, emulate Perl5 exactly:
    1:      *
    1:      * js1.3        "hi", "hi there"            "hihitherehi therebye"
    1:      */
    1:     res->leftContext.chars = JSSTRING_CHARS(str);
    1:     res->leftContext.length = start + gData.skipped;
    1:     res->rightContext.chars = ep;
    1:     res->rightContext.length = gData.cpend - ep;
    1: 
    1: out:
19196:     JS_ARENA_RELEASE(&cx->regexpPool, mark);
    1:     return ok;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: #define REGEXP_PROP_ATTRS     (JSPROP_PERMANENT | JSPROP_SHARED)
 2560: #define RO_REGEXP_PROP_ATTRS  (REGEXP_PROP_ATTRS | JSPROP_READONLY)
    1: 
    1: static JSPropertySpec regexp_props[] = {
 2560:     {"source",     REGEXP_SOURCE,      RO_REGEXP_PROP_ATTRS,0,0},
 2560:     {"global",     REGEXP_GLOBAL,      RO_REGEXP_PROP_ATTRS,0,0},
 2560:     {"ignoreCase", REGEXP_IGNORE_CASE, RO_REGEXP_PROP_ATTRS,0,0},
    1:     {"lastIndex",  REGEXP_LAST_INDEX,  REGEXP_PROP_ATTRS,0,0},
 2560:     {"multiline",  REGEXP_MULTILINE,   RO_REGEXP_PROP_ATTRS,0,0},
 2560:     {"sticky",     REGEXP_STICKY,      RO_REGEXP_PROP_ATTRS,0,0},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: static JSBool
    1: regexp_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsint slot;
    1:     JSRegExp *re;
    1: 
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
15692:     while (OBJ_GET_CLASS(cx, obj) != &js_RegExpClass) {
15692:         obj = OBJ_GET_PROTO(cx, obj);
15692:         if (!obj)
15692:             return JS_TRUE;
15692:     }
    1:     slot = JSVAL_TO_INT(id);
    1:     if (slot == REGEXP_LAST_INDEX)
    1:         return JS_GetReservedSlot(cx, obj, 0, vp);
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
15692:     re = (JSRegExp *) JS_GetPrivate(cx, obj);
    1:     if (re) {
    1:         switch (slot) {
    1:           case REGEXP_SOURCE:
    1:             *vp = STRING_TO_JSVAL(re->source);
    1:             break;
    1:           case REGEXP_GLOBAL:
    1:             *vp = BOOLEAN_TO_JSVAL((re->flags & JSREG_GLOB) != 0);
    1:             break;
    1:           case REGEXP_IGNORE_CASE:
    1:             *vp = BOOLEAN_TO_JSVAL((re->flags & JSREG_FOLD) != 0);
    1:             break;
    1:           case REGEXP_MULTILINE:
    1:             *vp = BOOLEAN_TO_JSVAL((re->flags & JSREG_MULTILINE) != 0);
    1:             break;
    1:           case REGEXP_STICKY:
    1:             *vp = BOOLEAN_TO_JSVAL((re->flags & JSREG_STICKY) != 0);
    1:             break;
    1:         }
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: regexp_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSBool ok;
    1:     jsint slot;
    1:     jsdouble lastIndex;
    1: 
    1:     ok = JS_TRUE;
    1:     if (!JSVAL_IS_INT(id))
    1:         return ok;
15692:     while (OBJ_GET_CLASS(cx, obj) != &js_RegExpClass) {
15692:         obj = OBJ_GET_PROTO(cx, obj);
15692:         if (!obj)
15692:             return JS_TRUE;
15692:     }
    1:     slot = JSVAL_TO_INT(id);
    1:     if (slot == REGEXP_LAST_INDEX) {
12694:         if (!JS_ValueToNumber(cx, *vp, &lastIndex))
    1:             return JS_FALSE;
    1:         lastIndex = js_DoubleToInteger(lastIndex);
12850:         ok = JS_NewNumberValue(cx, lastIndex, vp) &&
    1:              JS_SetReservedSlot(cx, obj, 0, *vp);
    1:     }
    1:     return ok;
    1: }
    1: 
    1: /*
    1:  * RegExp class static properties and their Perl counterparts:
    1:  *
    1:  *  RegExp.input                $_
    1:  *  RegExp.multiline            $*
    1:  *  RegExp.lastMatch            $&
    1:  *  RegExp.lastParen            $+
    1:  *  RegExp.leftContext          $`
    1:  *  RegExp.rightContext         $'
    1:  */
    1: enum regexp_static_tinyid {
    1:     REGEXP_STATIC_INPUT         = -1,
    1:     REGEXP_STATIC_MULTILINE     = -2,
    1:     REGEXP_STATIC_LAST_MATCH    = -3,
    1:     REGEXP_STATIC_LAST_PAREN    = -4,
    1:     REGEXP_STATIC_LEFT_CONTEXT  = -5,
    1:     REGEXP_STATIC_RIGHT_CONTEXT = -6
    1: };
    1: 
23094: void
23094: js_InitRegExpStatics(JSContext *cx)
    1: {
23094:     /*
23094:      * To avoid multiple allocations in InitMatch(), the arena size parameter
23094:      * should be at least as big as:
23094:      *   INITIAL_BACKTRACK
23094:      *   + (sizeof(REProgState) * INITIAL_STATESTACK)
23094:      *   + (offsetof(REMatchState, parens) + avgParanSize * sizeof(RECapture))
23094:      */
23094:     JS_INIT_ARENA_POOL(&cx->regexpPool, "regexp",
23094:                        12 * 1024 - 40,  /* FIXME: bug 421435 */
23094:                        sizeof(void *), &cx->scriptStackQuota);
23094: 
    1:     JS_ClearRegExpStatics(cx);
    1: }
    1: 
    1: void
23094: js_TraceRegExpStatics(JSTracer *trc, JSContext *acx)
    1: {
23094:     JSRegExpStatics *res = &acx->regExpStatics;
23094: 
23094:     if (res->input)
23094:         JS_CALL_STRING_TRACER(trc, res->input, "res->input");
23094: }
23094: 
23094: void
23094: js_FreeRegExpStatics(JSContext *cx)
23094: {
23094:     JSRegExpStatics *res = &cx->regExpStatics;
23094: 
    1:     if (res->moreParens) {
    1:         JS_free(cx, res->moreParens);
    1:         res->moreParens = NULL;
    1:     }
23094:     JS_FinishArenaPool(&cx->regexpPool);
    1: }
    1: 
    1: static JSBool
    1: regexp_static_getProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     jsint slot;
    1:     JSRegExpStatics *res;
    1:     JSString *str;
    1:     JSSubString *sub;
    1: 
    1:     res = &cx->regExpStatics;
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
    1:     slot = JSVAL_TO_INT(id);
    1:     switch (slot) {
    1:       case REGEXP_STATIC_INPUT:
    1:         *vp = res->input ? STRING_TO_JSVAL(res->input)
    1:                          : JS_GetEmptyStringValue(cx);
    1:         return JS_TRUE;
    1:       case REGEXP_STATIC_MULTILINE:
    1:         *vp = BOOLEAN_TO_JSVAL(res->multiline);
    1:         return JS_TRUE;
    1:       case REGEXP_STATIC_LAST_MATCH:
    1:         sub = &res->lastMatch;
    1:         break;
    1:       case REGEXP_STATIC_LAST_PAREN:
    1:         sub = &res->lastParen;
    1:         break;
    1:       case REGEXP_STATIC_LEFT_CONTEXT:
    1:         sub = &res->leftContext;
    1:         break;
    1:       case REGEXP_STATIC_RIGHT_CONTEXT:
    1:         sub = &res->rightContext;
    1:         break;
    1:       default:
    1:         sub = REGEXP_PAREN_SUBSTRING(res, slot);
    1:         break;
    1:     }
 4076:     str = js_NewStringCopyN(cx, sub->chars, sub->length);
    1:     if (!str)
    1:         return JS_FALSE;
    1:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: regexp_static_setProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSRegExpStatics *res;
    1: 
    1:     if (!JSVAL_IS_INT(id))
    1:         return JS_TRUE;
    1:     res = &cx->regExpStatics;
    1:     /* XXX use if-else rather than switch to keep MSVC1.52 from crashing */
    1:     if (JSVAL_TO_INT(id) == REGEXP_STATIC_INPUT) {
    1:         if (!JSVAL_IS_STRING(*vp) &&
    1:             !JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp)) {
    1:             return JS_FALSE;
    1:         }
    1:         res->input = JSVAL_TO_STRING(*vp);
    1:     } else if (JSVAL_TO_INT(id) == REGEXP_STATIC_MULTILINE) {
    1:         if (!JSVAL_IS_BOOLEAN(*vp) &&
    1:             !JS_ConvertValue(cx, *vp, JSTYPE_BOOLEAN, vp)) {
    1:             return JS_FALSE;
    1:         }
    1:         res->multiline = JSVAL_TO_BOOLEAN(*vp);
    1:     }
    1:     return JS_TRUE;
    1: }
 2560: #define REGEXP_STATIC_PROP_ATTRS    (REGEXP_PROP_ATTRS | JSPROP_ENUMERATE)
 2560: #define RO_REGEXP_STATIC_PROP_ATTRS (REGEXP_STATIC_PROP_ATTRS | JSPROP_READONLY)
    1: 
    1: static JSPropertySpec regexp_static_props[] = {
    1:     {"input",
    1:      REGEXP_STATIC_INPUT,
 2560:      REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_setProperty},
    1:     {"multiline",
    1:      REGEXP_STATIC_MULTILINE,
 2560:      REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_setProperty},
    1:     {"lastMatch",
    1:      REGEXP_STATIC_LAST_MATCH,
 2560:      RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
    1:     {"lastParen",
    1:      REGEXP_STATIC_LAST_PAREN,
 2560:      RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
    1:     {"leftContext",
    1:      REGEXP_STATIC_LEFT_CONTEXT,
 2560:      RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
    1:     {"rightContext",
    1:      REGEXP_STATIC_RIGHT_CONTEXT,
 2560:      RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
    1: 
    1:     /* XXX should have block scope and local $1, etc. */
 2560:     {"$1", 0, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
 2560:     {"$2", 1, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
 2560:     {"$3", 2, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
 2560:     {"$4", 3, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
 2560:     {"$5", 4, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
 2560:     {"$6", 5, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
 2560:     {"$7", 6, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
 2560:     {"$8", 7, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
 2560:     {"$9", 8, RO_REGEXP_STATIC_PROP_ATTRS,
    1:      regexp_static_getProperty,    regexp_static_getProperty},
    1: 
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: static void
    1: regexp_finalize(JSContext *cx, JSObject *obj)
    1: {
    1:     JSRegExp *re;
    1: 
    1:     re = (JSRegExp *) JS_GetPrivate(cx, obj);
    1:     if (!re)
    1:         return;
    1:     js_DestroyRegExp(cx, re);
    1: }
    1: 
    1: /* Forward static prototype. */
    1: static JSBool
 4127: regexp_exec_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
 4127:                 JSBool test, jsval *rval);
    1: 
    1: static JSBool
    1: regexp_call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
 4127:     return regexp_exec_sub(cx, JSVAL_TO_OBJECT(argv[-2]), argc, argv,
 4127:                            JS_FALSE, rval);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: #include "jsxdrapi.h"
    1: 
    1: static JSBool
    1: regexp_xdrObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSRegExp *re;
    1:     JSString *source;
    1:     uint32 flagsword;
    1:     JSObject *obj;
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         re = (JSRegExp *) JS_GetPrivate(xdr->cx, *objp);
    1:         if (!re)
    1:             return JS_FALSE;
    1:         source = re->source;
 3235:         flagsword = (uint32)re->flags;
    1:     }
    1:     if (!JS_XDRString(xdr, &source) ||
    1:         !JS_XDRUint32(xdr, &flagsword)) {
    1:         return JS_FALSE;
    1:     }
    1:     if (xdr->mode == JSXDR_DECODE) {
13427:         obj = js_NewObject(xdr->cx, &js_RegExpClass, NULL, NULL, 0);
    1:         if (!obj)
    1:             return JS_FALSE;
16069:         STOBJ_CLEAR_PARENT(obj);
16069:         STOBJ_CLEAR_PROTO(obj);
 3235:         re = js_NewRegExp(xdr->cx, NULL, source, (uint8)flagsword, JS_FALSE);
    1:         if (!re)
    1:             return JS_FALSE;
    1:         if (!JS_SetPrivate(xdr->cx, obj, re) ||
    1:             !js_SetLastIndex(xdr->cx, obj, 0)) {
    1:             js_DestroyRegExp(xdr->cx, re);
    1:             return JS_FALSE;
    1:         }
    1:         *objp = obj;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: #else  /* !JS_HAS_XDR */
    1: 
    1: #define regexp_xdrObject NULL
    1: 
    1: #endif /* !JS_HAS_XDR */
    1: 
  583: static void
  583: regexp_trace(JSTracer *trc, JSObject *obj)
    1: {
  583:     JSRegExp *re;
  583: 
  583:     re = (JSRegExp *) JS_GetPrivate(trc->context, obj);
  583:     if (re && re->source)
  583:         JS_CALL_STRING_TRACER(trc, re->source, "source");
    1: }
    1: 
    1: JSClass js_RegExpClass = {
    1:     js_RegExp_str,
    1:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_RegExp),
    1:     JS_PropertyStub,    JS_PropertyStub,
    1:     regexp_getProperty, regexp_setProperty,
    1:     JS_EnumerateStub,   JS_ResolveStub,
    1:     JS_ConvertStub,     regexp_finalize,
    1:     NULL,               NULL,
    1:     regexp_call,        NULL,
    1:     regexp_xdrObject,   NULL,
  583:     JS_CLASS_TRACE(regexp_trace), 0
    1: };
    1: 
    1: static const jschar empty_regexp_ucstr[] = {'(', '?', ':', ')', 0};
    1: 
    1: JSBool
 4127: js_regexp_toString(JSContext *cx, JSObject *obj, jsval *vp)
    1: {
    1:     JSRegExp *re;
    1:     const jschar *source;
    1:     jschar *chars;
    1:     size_t length, nflags;
    1:     uintN flags;
    1:     JSString *str;
    1: 
 4127:     if (!JS_InstanceOf(cx, obj, &js_RegExpClass, vp + 2))
    1:         return JS_FALSE;
    1:     JS_LOCK_OBJ(cx, obj);
    1:     re = (JSRegExp *) JS_GetPrivate(cx, obj);
    1:     if (!re) {
    1:         JS_UNLOCK_OBJ(cx, obj);
 4127:         *vp = STRING_TO_JSVAL(cx->runtime->emptyString);
    1:         return JS_TRUE;
    1:     }
    1: 
 4718:     JSSTRING_CHARS_AND_LENGTH(re->source, source, length);
    1:     if (length == 0) {
    1:         source = empty_regexp_ucstr;
 8336:         length = JS_ARRAY_LENGTH(empty_regexp_ucstr) - 1;
    1:     }
    1:     length += 2;
    1:     nflags = 0;
    1:     for (flags = re->flags; flags != 0; flags &= flags - 1)
    1:         nflags++;
    1:     chars = (jschar*) JS_malloc(cx, (length + nflags + 1) * sizeof(jschar));
    1:     if (!chars) {
    1:         JS_UNLOCK_OBJ(cx, obj);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     chars[0] = '/';
    1:     js_strncpy(&chars[1], source, length - 2);
    1:     chars[length-1] = '/';
    1:     if (nflags) {
    1:         if (re->flags & JSREG_GLOB)
    1:             chars[length++] = 'g';
    1:         if (re->flags & JSREG_FOLD)
    1:             chars[length++] = 'i';
    1:         if (re->flags & JSREG_MULTILINE)
    1:             chars[length++] = 'm';
    1:         if (re->flags & JSREG_STICKY)
    1:             chars[length++] = 'y';
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     chars[length] = 0;
    1: 
 4718:     str = js_NewString(cx, chars, length);
    1:     if (!str) {
    1:         JS_free(cx, chars);
    1:         return JS_FALSE;
    1:     }
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: regexp_toString(JSContext *cx, uintN argc, jsval *vp)
 4127: {
11809:     JSObject *obj;
11809: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     return obj && js_regexp_toString(cx, obj, vp);
 4127: }
 4127: 
 4127: static JSBool
 4127: regexp_compile_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                    jsval *rval)
    1: {
    1:     JSString *opt, *str;
    1:     JSRegExp *oldre, *re;
    1:     JSBool ok, ok2;
    1:     JSObject *obj2;
    1:     size_t length, nbytes;
    1:     const jschar *cp, *start, *end;
    1:     jschar *nstart, *ncp, *tmp;
    1: 
    1:     if (!JS_InstanceOf(cx, obj, &js_RegExpClass, argv))
    1:         return JS_FALSE;
    1:     opt = NULL;
    1:     if (argc == 0) {
    1:         str = cx->runtime->emptyString;
    1:     } else {
    1:         if (JSVAL_IS_OBJECT(argv[0])) {
    1:             /*
    1:              * If we get passed in a RegExp object we construct a new
    1:              * RegExp that is a duplicate of it by re-compiling the
    1:              * original source code. ECMA requires that it be an error
    1:              * here if the flags are specified. (We must use the flags
    1:              * from the original RegExp also).
    1:              */
    1:             obj2 = JSVAL_TO_OBJECT(argv[0]);
    1:             if (obj2 && OBJ_GET_CLASS(cx, obj2) == &js_RegExpClass) {
    1:                 if (argc >= 2 && !JSVAL_IS_VOID(argv[1])) { /* 'flags' passed */
    1:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                          JSMSG_NEWREGEXP_FLAGGED);
    1:                     return JS_FALSE;
    1:                 }
    1:                 JS_LOCK_OBJ(cx, obj2);
    1:                 re = (JSRegExp *) JS_GetPrivate(cx, obj2);
    1:                 if (!re) {
    1:                     JS_UNLOCK_OBJ(cx, obj2);
    1:                     return JS_FALSE;
    1:                 }
    1:                 re = js_NewRegExp(cx, NULL, re->source, re->flags, JS_FALSE);
    1:                 JS_UNLOCK_OBJ(cx, obj2);
    1:                 goto created;
    1:             }
    1:         }
    1:         str = js_ValueToString(cx, argv[0]);
    1:         if (!str)
    1:             return JS_FALSE;
    1:         argv[0] = STRING_TO_JSVAL(str);
    1:         if (argc > 1) {
    1:             if (JSVAL_IS_VOID(argv[1])) {
    1:                 opt = NULL;
    1:             } else {
    1:                 opt = js_ValueToString(cx, argv[1]);
    1:                 if (!opt)
    1:                     return JS_FALSE;
    1:                 argv[1] = STRING_TO_JSVAL(opt);
    1:             }
    1:         }
    1: 
    1:         /* Escape any naked slashes in the regexp source. */
 4718:         JSSTRING_CHARS_AND_LENGTH(str, start, length);
    1:         end = start + length;
    1:         nstart = ncp = NULL;
    1:         for (cp = start; cp < end; cp++) {
    1:             if (*cp == '/' && (cp == start || cp[-1] != '\\')) {
    1:                 nbytes = (++length + 1) * sizeof(jschar);
    1:                 if (!nstart) {
    1:                     nstart = (jschar *) JS_malloc(cx, nbytes);
    1:                     if (!nstart)
    1:                         return JS_FALSE;
    1:                     ncp = nstart + (cp - start);
    1:                     js_strncpy(nstart, start, cp - start);
    1:                 } else {
    1:                     tmp = (jschar *) JS_realloc(cx, nstart, nbytes);
    1:                     if (!tmp) {
    1:                         JS_free(cx, nstart);
    1:                         return JS_FALSE;
    1:                     }
    1:                     ncp = tmp + (ncp - nstart);
    1:                     nstart = tmp;
    1:                 }
    1:                 *ncp++ = '\\';
    1:             }
    1:             if (nstart)
    1:                 *ncp++ = *cp;
    1:         }
    1: 
    1:         if (nstart) {
    1:             /* Don't forget to store the backstop after the new string. */
    1:             JS_ASSERT((size_t)(ncp - nstart) == length);
    1:             *ncp = 0;
 4718:             str = js_NewString(cx, nstart, length);
    1:             if (!str) {
    1:                 JS_free(cx, nstart);
    1:                 return JS_FALSE;
    1:             }
    1:             argv[0] = STRING_TO_JSVAL(str);
    1:         }
    1:     }
    1: 
 7984:     re = js_NewRegExpOpt(cx, str, opt, JS_FALSE);
    1: created:
    1:     if (!re)
    1:         return JS_FALSE;
    1:     JS_LOCK_OBJ(cx, obj);
    1:     oldre = (JSRegExp *) JS_GetPrivate(cx, obj);
    1:     ok = JS_SetPrivate(cx, obj, re);
    1:     ok2 = js_SetLastIndex(cx, obj, 0);
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     if (!ok) {
    1:         js_DestroyRegExp(cx, re);
    1:         return JS_FALSE;
    1:     }
    1:     if (oldre)
    1:         js_DestroyRegExp(cx, oldre);
    1:     *rval = OBJECT_TO_JSVAL(obj);
    1:     return ok2;
    1: }
    1: 
    1: static JSBool
 4127: regexp_compile(JSContext *cx, uintN argc, jsval *vp)
 4127: {
11809:     JSObject *obj;
11809: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
11809:     return obj && regexp_compile_sub(cx, obj, argc, vp + 2, vp);
 4127: }
 4127: 
 4127: static JSBool
    1: regexp_exec_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                 JSBool test, jsval *rval)
    1: {
    1:     JSBool ok, sticky;
    1:     JSRegExp *re;
    1:     jsdouble lastIndex;
    1:     JSString *str;
    1:     size_t i;
    1: 
    1:     ok = JS_InstanceOf(cx, obj, &js_RegExpClass, argv);
    1:     if (!ok)
    1:         return JS_FALSE;
    1:     JS_LOCK_OBJ(cx, obj);
    1:     re = (JSRegExp *) JS_GetPrivate(cx, obj);
    1:     if (!re) {
    1:         JS_UNLOCK_OBJ(cx, obj);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /* NB: we must reach out: after this paragraph, in order to drop re. */
    1:     HOLD_REGEXP(cx, re);
    1:     sticky = (re->flags & JSREG_STICKY) != 0;
    1:     if (re->flags & (JSREG_GLOB | JSREG_STICKY)) {
    1:         ok = js_GetLastIndex(cx, obj, &lastIndex);
    1:     } else {
    1:         lastIndex = 0;
    1:     }
    1:     JS_UNLOCK_OBJ(cx, obj);
    1:     if (!ok)
    1:         goto out;
    1: 
    1:     /* Now that obj is unlocked, it's safe to (potentially) grab the GC lock. */
    1:     if (argc == 0) {
    1:         str = cx->regExpStatics.input;
    1:         if (!str) {
    1:             const char *bytes = js_GetStringBytes(cx, re->source);
    1: 
    1:             if (bytes) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_NO_INPUT,
    1:                                      bytes,
    1:                                      (re->flags & JSREG_GLOB) ? "g" : "",
    1:                                      (re->flags & JSREG_FOLD) ? "i" : "",
    1:                                      (re->flags & JSREG_MULTILINE) ? "m" : "",
    1:                                      (re->flags & JSREG_STICKY) ? "y" : "");
    1:             }
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
    1:     } else {
    1:         str = js_ValueToString(cx, argv[0]);
    1:         if (!str) {
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
    1:         argv[0] = STRING_TO_JSVAL(str);
    1:     }
    1: 
    1:     if (lastIndex < 0 || JSSTRING_LENGTH(str) < lastIndex) {
    1:         ok = js_SetLastIndex(cx, obj, 0);
    1:         *rval = JSVAL_NULL;
    1:     } else {
    1:         i = (size_t) lastIndex;
    1:         ok = js_ExecuteRegExp(cx, re, str, &i, test, rval);
    1:         if (ok &&
    1:             ((re->flags & JSREG_GLOB) || (*rval != JSVAL_NULL && sticky))) {
    1:             ok = js_SetLastIndex(cx, obj, (*rval == JSVAL_NULL) ? 0 : i);
    1:         }
    1:     }
    1: 
    1: out:
    1:     DROP_REGEXP(cx, re);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: regexp_exec(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     return regexp_exec_sub(cx, JS_THIS_OBJECT(cx, vp), argc, vp + 2, JS_FALSE,
 4127:                            vp);
    1: }
    1: 
    1: static JSBool
 4127: regexp_test(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     if (!regexp_exec_sub(cx, JS_THIS_OBJECT(cx, vp), argc, vp + 2, JS_TRUE, vp))
    1:         return JS_FALSE;
 4127:     if (*vp != JSVAL_TRUE)
 4127:         *vp = JSVAL_FALSE;
    1:     return JS_TRUE;
    1: }
    1: 
20896: #ifdef JS_TRACER
20915: static jsint FASTCALL
20915: Regexp_p_test(JSContext* cx, JSObject* regexp, JSString* str)
20896: {
20896:     jsval vp[3] = { JSVAL_NULL, OBJECT_TO_JSVAL(regexp), STRING_TO_JSVAL(str) };
20896:     if (!regexp_exec_sub(cx, regexp, 1, vp + 2, JS_TRUE, vp))
20896:         return JSVAL_TO_BOOLEAN(JSVAL_VOID);
20896:     return *vp == JSVAL_TRUE;
20896: }
20896: 
20930: JS_DEFINE_TRCINFO_1(regexp_test,
20930:     (3, (static, BOOL_FAIL, Regexp_p_test, CONTEXT, THIS, STRING,  1, 1)))
20930: 
20898: #endif
20896: 
    1: static JSFunctionSpec regexp_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,  regexp_toString,    0,0),
    1: #endif
16519:     JS_FN(js_toString_str,  regexp_toString,    0,0),
16519:     JS_FN("compile",        regexp_compile,     2,0),
16519:     JS_FN("exec",           regexp_exec,        1,0),
20896:     JS_TN("test",           regexp_test,        1,0, regexp_test_trcinfo),
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSBool
    1: RegExp(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
22652:     if (!JS_IsConstructing(cx)) {
    1:         /*
    1:          * If first arg is regexp and no flags are given, just return the arg.
 4127:          * (regexp_compile_sub detects the regexp + flags case and throws a
    1:          * TypeError.)  See 10.15.3.1.
    1:          */
    1:         if ((argc < 2 || JSVAL_IS_VOID(argv[1])) &&
    1:             !JSVAL_IS_PRIMITIVE(argv[0]) &&
    1:             OBJ_GET_CLASS(cx, JSVAL_TO_OBJECT(argv[0])) == &js_RegExpClass) {
    1:             *rval = argv[0];
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         /* Otherwise, replace obj with a new RegExp object. */
13427:         obj = js_NewObject(cx, &js_RegExpClass, NULL, NULL, 0);
    1:         if (!obj)
    1:             return JS_FALSE;
    1: 
    1:         /*
 4127:          * regexp_compile_sub does not use rval to root its temporaries so we
 4127:          * can use it to root obj.
    1:          */
    1:         *rval = OBJECT_TO_JSVAL(obj);
    1:     }
 4127:     return regexp_compile_sub(cx, obj, argc, argv, rval);
    1: }
    1: 
    1: JSObject *
    1: js_InitRegExpClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto, *ctor;
    1:     jsval rval;
    1: 
    1:     proto = JS_InitClass(cx, obj, NULL, &js_RegExpClass, RegExp, 1,
    1:                          regexp_props, regexp_methods,
    1:                          regexp_static_props, NULL);
    1: 
    1:     if (!proto || !(ctor = JS_GetConstructor(cx, proto)))
    1:         return NULL;
    1:     if (!JS_AliasProperty(cx, ctor, "input",        "$_") ||
    1:         !JS_AliasProperty(cx, ctor, "multiline",    "$*") ||
    1:         !JS_AliasProperty(cx, ctor, "lastMatch",    "$&") ||
    1:         !JS_AliasProperty(cx, ctor, "lastParen",    "$+") ||
    1:         !JS_AliasProperty(cx, ctor, "leftContext",  "$`") ||
    1:         !JS_AliasProperty(cx, ctor, "rightContext", "$'")) {
    1:         goto bad;
    1:     }
    1: 
    1:     /* Give RegExp.prototype private data so it matches the empty string. */
 4127:     if (!regexp_compile_sub(cx, proto, 0, NULL, &rval))
    1:         goto bad;
    1:     return proto;
    1: 
    1: bad:
    1:     JS_DeleteProperty(cx, obj, js_RegExpClass.name);
    1:     return NULL;
    1: }
    1: 
    1: JSObject *
    1: js_NewRegExpObject(JSContext *cx, JSTokenStream *ts,
    1:                    jschar *chars, size_t length, uintN flags)
    1: {
    1:     JSString *str;
    1:     JSObject *obj;
    1:     JSRegExp *re;
    1:     JSTempValueRooter tvr;
    1: 
 4076:     str = js_NewStringCopyN(cx, chars, length);
    1:     if (!str)
    1:         return NULL;
    1:     re = js_NewRegExp(cx, ts,  str, flags, JS_FALSE);
    1:     if (!re)
    1:         return NULL;
    1:     JS_PUSH_TEMP_ROOT_STRING(cx, str, &tvr);
13427:     obj = js_NewObject(cx, &js_RegExpClass, NULL, NULL, 0);
    1:     if (!obj || !JS_SetPrivate(cx, obj, re)) {
    1:         js_DestroyRegExp(cx, re);
    1:         obj = NULL;
    1:     }
    1:     if (obj && !js_SetLastIndex(cx, obj, 0))
    1:         obj = NULL;
    1:     JS_POP_TEMP_ROOT(cx, &tvr);
    1:     return obj;
    1: }
    1: 
    1: JSObject *
    1: js_CloneRegExpObject(JSContext *cx, JSObject *obj, JSObject *parent)
    1: {
    1:     JSObject *clone;
    1:     JSRegExp *re;
    1: 
    1:     JS_ASSERT(OBJ_GET_CLASS(cx, obj) == &js_RegExpClass);
13427:     clone = js_NewObject(cx, &js_RegExpClass, NULL, parent, 0);
    1:     if (!clone)
    1:         return NULL;
 3164:     re = (JSRegExp *) JS_GetPrivate(cx, obj);
    1:     if (!JS_SetPrivate(cx, clone, re) || !js_SetLastIndex(cx, clone, 0)) {
    1:         cx->weakRoots.newborn[GCX_OBJECT] = NULL;
    1:         return NULL;
    1:     }
    1:     HOLD_REGEXP(cx, re);
    1:     return clone;
    1: }
    1: 
    1: JSBool
    1: js_GetLastIndex(JSContext *cx, JSObject *obj, jsdouble *lastIndex)
    1: {
    1:     jsval v;
    1: 
    1:     return JS_GetReservedSlot(cx, obj, 0, &v) &&
12694:            JS_ValueToNumber(cx, v, lastIndex);
    1: }
    1: 
    1: JSBool
    1: js_SetLastIndex(JSContext *cx, JSObject *obj, jsdouble lastIndex)
    1: {
    1:     jsval v;
    1: 
12850:     return JS_NewNumberValue(cx, lastIndex, &v) &&
    1:            JS_SetReservedSlot(cx, obj, 0, v);
    1: }
   22: 
