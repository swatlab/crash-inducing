 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 30959: 
 30959: /**
 30959:  * Checks that restoring the last browser window in session is actually
 30959:  * working:
 30959:  *  1.1) Open a new browser window
 30959:  *  1.2) Add some tabs
 30959:  *  1.3) Close that window
 30959:  *  1.4) Opening another window
 30959:  *  --> State is restored
 30959:  *
 30959:  *  2.1) Open a new browser window
 30959:  *  2.2) Add some tabs
 30959:  *  2.3) Enter private browsing mode
 30959:  *  2.4) Close the window while still in private browsing mode
 30959:  *  2.5) Opening a new window
 30959:  *  --> State is not restored, because private browsing mode is still active
 30959:  *  2.6) Leaving private browsing mode
 30959:  *  2.7) Open another window
 30959:  *  --> State (that was before entering PBM) is restored
 30959:  *
 30959:  *  3.1) Open a new browser window
 30959:  *  3.2) Add some tabs
 30959:  *  3.4) Open some popups
 30959:  *  3.5) Add another tab to one popup (so that it gets stored) and close it again
 30959:  *  3.5) Close the browser window
 30959:  *  3.6) Open another browser window
 30959:  *  --> State of the closed browser window, but not of the popup, is restored
 30959:  *
 30959:  *  4.1) Open a popup
 30959:  *  4.2) Add another tab to the popup (so that it gets stored) and close it again
 30959:  *  4.3) Open a window
 30959:  *  --> Nothing at all should be restored
 30959:  *
 30959:  *  5.1) Open two browser windows and close them again
 30959:  *  5.2) undoCloseWindow() one
 30959:  *  5.3) Open another browser window
 30959:  *  --> Nothing at all should be restored
 30959:  *
 30959:  * Checks the new notifications are correctly posted and processed, that is
 30959:  * for each successful -requested a -granted is received, but omitted if
 30959:  *  -requested was cnceled
 30959:  * Said notifications are:
 30959:  *  - browser-lastwindow-close-requested
 30959:  *  - browser-lastwindow-close-granted
 30959:  * Tests are:
 30959:  *  6) Cancel closing when first observe a -requested
 30959:  *  --> Window is kept open
 30959:  *  7) Count the number of notifications
 30959:  *  --> count(-requested) == count(-granted) + 1
 30959:  *  --> (The first -requested was canceled, so off-by-one)
 30959:  *  8) (Mac only) Mac version of Test 5 additionally preparing Test 6
 30959:  *
 30959:  * @see https://bugzilla.mozilla.org/show_bug.cgi?id=354894
 30959:  * @note It is implicitly tested that restoring the last window works when
 30959:  * non-browser windows are around. The "Run Tests" window as well as the main
 30959:  * browser window (wherein the test code gets executed) won't be considered
 30959:  * browser windows. To achiveve this said main browser window has it's windowtype
 30959:  * attribute modified so that it's not considered a browser window any longer.
 30959:  * This is crucial, because otherwise there would be two browser windows around,
 30959:  * said main test window and the one opened by the tests, and hence the new
 30959:  * logic wouldn't be executed at all.
 30959:  * @note Mac only tests the new notifications, as restoring the last window is
 30959:  * not enabled on that platform (platform shim; the application is kept running
 30959:  * although there are no windows left)
 30959:  * @note There is a difference when closing a browser window with
 30959:  * BrowserTryToCloseWindow() as opposed to close(). The former will make
 30959:  * nsSessionStore restore a window next time it gets a chance and will post
 30959:  * notifications. The latter won't.
 30959:  */
 34974: 
 35682: function browserWindowsCount(expected, msg) {
 35714:   if (typeof expected == "number")
 35714:     expected = [expected, expected];
 34974:   let count = 0;
 40141:   let e = Services.wm.getEnumerator("navigator:browser");
 34974:   while (e.hasMoreElements()) {
 34974:     if (!e.getNext().closed)
 34974:       ++count;
 34974:   }
 35714:   is(count, expected[0], msg + " (nsIWindowMediator)");
 72485:   let state = ss.getBrowserState();
 35714:   is(JSON.parse(state).windows.length, expected[1], msg + " (getBrowserState)");
 34974: }
 34974: 
 30959: function test() {
 35682:   browserWindowsCount(1, "Only one browser window should be open initially");
 34974: 
 30959:   waitForExplicitFinish();
 37627:   // This test takes some time to run, and it could timeout randomly.
 37627:   // So we require a longer timeout. See bug 528219.
 37627:   requestLongerTimeout(2);
 30959: 
 30959:   // Some urls that might be opened in tabs and/or popups
 30959:   // Do not use about:blank:
 30959:   // That one is reserved for special purposes in the tests
 30959:   const TEST_URLS = ["about:mozilla", "about:buildconfig"];
 30959: 
 30959:   // Number of -request notifications to except
 30959:   // remember to adjust when adding new tests
 30959:   const NOTIFICATIONS_EXPECTED = 6;
 30959: 
 30959:   // Window features of popup windows
 30959:   const POPUP_FEATURES = "toolbar=no,resizable=no,status=no";
 30959: 
 30959:   // Window features of browser windows
 30959:   const CHROME_FEATURES = "chrome,all,dialog=no";
 30959: 
 30959:   // Store the old window type for cleanup
 30959:   let oldWinType = "";
 30959:   // Store the old tabs.warnOnClose pref so that we may reset it during
 30959:   // cleanup
 30959:   let oldWarnTabsOnClose = gPrefService.getBoolPref("browser.tabs.warnOnClose");
 30959: 
 30959:   // Observe these, and also use to count the number of hits
 30959:   let observing = {
 30959:     "browser-lastwindow-close-requested": 0,
 30959:     "browser-lastwindow-close-granted": 0
 30959:   };
 30959: 
 30959:   /**
 30959:    * Helper: Will observe and handle the notifications for us
 30959:    */
 37936:   let hitCount = 0;
 37936:   function observer(aCancel, aTopic, aData) {
 30959:     // count so that we later may compare
 30959:     observing[aTopic]++;
 30959: 
 30959:     // handle some tests
 37936:     if (++hitCount == 1) {
 30959:       // Test 6
 30959:       aCancel.QueryInterface(Ci.nsISupportsPRBool).data = true;
 30959:     }
 30959:   }
 30959: 
 30959:   /**
 30959:    * Helper: Sets prefs as the testsuite requires
 30959:    * @note Will be reset in cleanTestSuite just before finishing the tests
 30959:    */
 30959:   function setPrefs() {
 30959:     gPrefService.setIntPref("browser.startup.page", 3);
 30959:     gPrefService.setBoolPref(
 30959:       "browser.privatebrowsing.keep_current_session",
 30959:       true
 30959:     );
 30959:     gPrefService.setBoolPref("browser.tabs.warnOnClose", false);
 30959:   }
 30959: 
 30959:   /**
 30959:    * Helper: Sets up this testsuite
 30959:    */
 30959:   function setupTestsuite(testFn) {
 30959:     // Register our observers
 37936:     for (let o in observing)
 40141:       Services.obs.addObserver(observer, o, false);
 30959: 
 30959:     // Make the main test window not count as a browser window any longer
 30959:     oldWinType = document.documentElement.getAttribute("windowtype");
 30959:     document.documentElement.setAttribute("windowtype", "navigator:testrunner");
 30959:   }
 30959: 
 30959:   /**
 30959:    * Helper: Cleans up behind the testsuite
 30959:    */
 30959:   function cleanupTestsuite(callback) {
 30959:     // Finally remove observers again
 37936:     for (let o in observing)
 40141:       Services.obs.removeObserver(observer, o, false);
 37936: 
 30959:     // Reset the prefs we touched
 37936:     [
 30959:       "browser.startup.page",
 30959:       "browser.privatebrowsing.keep_current_session"
 37936:     ].forEach(function (pref) {
 37936:       if (gPrefService.prefHasUserValue(pref))
 30959:         gPrefService.clearUserPref(pref);
 37936:     });
 30959:     gPrefService.setBoolPref("browser.tabs.warnOnClose", oldWarnTabsOnClose);
 30959: 
 30959:     // Reset the window type
 30959:     document.documentElement.setAttribute("windowtype", oldWinType);
 30959:   }
 30959: 
 30959:   /**
 30959:    * Helper: sets the prefs and a new window with our test tabs
 30959:    */
124655:   function setupTestAndRun(testFn) {
 30959:     // Prepare the prefs
 30959:     setPrefs();
 30959: 
 30959:     // Prepare a window; open it and add more tabs
124655:     let newWin = openDialog(location, "_blank", CHROME_FEATURES, "about:config");
 30959:     newWin.addEventListener("load", function(aEvent) {
 30959:       newWin.removeEventListener("load", arguments.callee, false);
 30959:       newWin.gBrowser.addEventListener("load", function(aEvent) {
 30959:         newWin.gBrowser.removeEventListener("load", arguments.callee, true);
 34974:         TEST_URLS.forEach(function (url) {
 30959:           newWin.gBrowser.addTab(url);
 34974:         });
 30959: 
 30959:         executeSoon(function() testFn(newWin));
 30959:       }, true);
 30959:     }, false);
 30959:   }
 30959: 
 30959:   /**
 30959:    * Test 1: Normal in-session restore
 30959:    * @note: Non-Mac only
 30959:    */
 30959:   function testOpenCloseNormal(nextFn) {
124655:     setupTestAndRun(function(newWin) {
 30959:       // Close the window
 30959:       // window.close doesn't push any close events,
 30959:       // so use BrowserTryToCloseWindow
 30959:       newWin.BrowserTryToCloseWindow();
 30959: 
 30959:       // The first request to close is denied by our observer (Test 6)
 30959:       ok(!newWin.closed, "First close request was denied");
 30959:       if (!newWin.closed) {
 30959:         newWin.BrowserTryToCloseWindow();
 30959:         ok(newWin.closed, "Second close request was granted");
 30959:       }
 30959: 
 30959:       // Open a new window
 30959:       // The previously closed window should be restored
124655:       newWin = openDialog(location, "_blank", CHROME_FEATURES);
 30959:       newWin.addEventListener("load", function() {
 33794:         this.removeEventListener("load", arguments.callee, true);
 30959:         executeSoon(function() {
 30959:           is(newWin.gBrowser.browsers.length, TEST_URLS.length + 1,
 30959:              "Restored window in-session with otherpopup windows around");
 30959: 
 30959:           // Cleanup
 30959:           newWin.close();
 30959: 
 30959:           // Next please
 30959:           executeSoon(nextFn);
 30959:         });
 30959:       }, true);
 30959:     });
 30959:   }
 30959: 
 30959:   /**
 30959:    * Test 2: PrivateBrowsing in-session restore
 30959:    * @note: Non-Mac only
 30959:    */
 30959:   function testOpenClosePrivateBrowsing(nextFn) {
124655:     setupTestAndRun(function(newWin) {
124655:       let pb = Cc["@mozilla.org/privatebrowsing;1"].
124655:                getService(Ci.nsIPrivateBrowsingService);
124655: 
 30959:       // Close the window
 30959:       newWin.BrowserTryToCloseWindow();
 30959: 
 30959:       // Enter private browsing mode
124655:       pb.privateBrowsingEnabled = true;
124655: 
 30959:       // Open a new window.
 30959:       // The previously closed window should NOT be restored
124655:       newWin = openDialog(location, "_blank", CHROME_FEATURES);
 30959:       newWin.addEventListener("load", function() {
 33794:         this.removeEventListener("load", arguments.callee, true);
 30959:         executeSoon(function() {
 30959:           is(newWin.gBrowser.browsers.length, 1,
 30959:              "Did not restore in private browing mode");
 30959: 
 30959:           // Cleanup
 30959:           newWin.BrowserTryToCloseWindow();
 30959: 
 30959:           // Exit private browsing mode again
124655:           pb.privateBrowsingEnabled = false;
124655: 
124655:           newWin = openDialog(location, "_blank", CHROME_FEATURES);
 30959:           newWin.addEventListener("load", function() {
 33794:             this.removeEventListener("load", arguments.callee, true);
 30959:             executeSoon(function() {
 30959:               is(newWin.gBrowser.browsers.length, TEST_URLS.length + 1,
 30959:                  "Restored after leaving private browsing again");
 30959: 
 30959:               newWin.close();
 30959: 
 30959:               // Next please
 30959:               executeSoon(nextFn);
 30959:             });
 30959:           }, true);
 30959:         });
 30959:       }, true);
 30959:     });
 30959:   }
 30959: 
 30959:   /**
 30959:    * Test 3: Open some popup windows to check those aren't restored, but
 30959:    *         the browser window is
 30959:    * @note: Non-Mac only
 30959:    */
 30959:   function testOpenCloseWindowAndPopup(nextFn) {
124655:     setupTestAndRun(function(newWin) {
 30959:       // open some popups
 30959:       let popup = openDialog(location, "popup", POPUP_FEATURES, TEST_URLS[0]);
 30959:       let popup2 = openDialog(location, "popup2", POPUP_FEATURES, TEST_URLS[1]);
 30959:       popup2.addEventListener("load", function() {
 30959:         popup2.removeEventListener("load", arguments.callee, false);
 30959:         popup2.gBrowser.addEventListener("load", function() {
 30959:           popup2.gBrowser.removeEventListener("load", arguments.callee, true);
 30959:           popup2.gBrowser.addTab(TEST_URLS[0]);
 30959:           // close the window
 30959:           newWin.BrowserTryToCloseWindow();
 30959: 
 30959:           // Close the popup window
 30959:           // The test is successful when not this popup window is restored
 30959:           // but instead newWin
 30959:           popup2.close();
 30959: 
 30959:           // open a new window the previously closed window should be restored to
124655:           newWin = openDialog(location, "_blank", CHROME_FEATURES);
 30959:           newWin.addEventListener("load", function() {
 33794:             this.removeEventListener("load", arguments.callee, true);
 30959:             executeSoon(function() {
 30959:               is(newWin.gBrowser.browsers.length, TEST_URLS.length + 1,
 30959:                  "Restored window and associated tabs in session");
 30959: 
 30959:               // Cleanup
 30959:               newWin.close();
 30959:               popup.close();
 30959: 
 30959:               // Next please
 30959:               executeSoon(nextFn);
 30959:             });
 30959:           }, true);
 30959:         }, true);
 30959:       }, false);
 30959:     });
 30959:   }
 30959: 
 30959:   /**
 30959:    * Test 4: Open some popup window to check it isn't restored.
 30959:    *         Instead nothing at all should be restored
 30959:    * @note: Non-Mac only
 30959:    */
 30959:   function testOpenCloseOnlyPopup(nextFn) {
 30959:     // prepare the prefs
 30959:     setPrefs();
 30959: 
 30959:     // This will cause nsSessionStore to restore a window the next time it
 30959:     // gets a chance.
 30959:     let popup = openDialog(location, "popup", POPUP_FEATURES, TEST_URLS[1]);
 30959:     popup.addEventListener("load", function() {
 33794:       this.removeEventListener("load", arguments.callee, true);
 30959:       is(popup.gBrowser.browsers.length, 1,
 30959:          "Did not restore the popup window (1)");
 30959:       popup.BrowserTryToCloseWindow();
 30959: 
 30959:       // Real tests
 30959:       popup = openDialog(location, "popup", POPUP_FEATURES, TEST_URLS[1]);
 30959:       popup.addEventListener("load", function() {
 30959:         popup.removeEventListener("load", arguments.callee, false);
 30959:         popup.gBrowser.addEventListener("load", function() {
 30959:           popup.gBrowser.removeEventListener("load", arguments.callee, true);
 30959:           popup.gBrowser.addTab(TEST_URLS[0]);
 30959: 
 30959:           is(popup.gBrowser.browsers.length, 2,
 30959:              "Did not restore to the popup window (2)");
 30959: 
 30959:           // Close the popup window
 30959:           // The test is successful when not this popup window is restored
 30959:           // but instead a new window is opened without restoring anything
 30959:           popup.close();
 30959: 
124655:           let newWin = openDialog(location, "_blank", CHROME_FEATURES, "about:blank");
 30959:           newWin.addEventListener("load", function() {
 30959:             newWin.removeEventListener("load", arguments.callee, true);
 30959:             executeSoon(function() {
 30959:               isnot(newWin.gBrowser.browsers.length, 2,
 30959:                     "Did not restore the popup window");
 30959:               is(TEST_URLS.indexOf(newWin.gBrowser.browsers[0].currentURI.spec), -1,
 30959:                  "Did not restore the popup window (2)");
 30959: 
 30959:               // Cleanup
 30959:               newWin.close();
 30959: 
 30959:               // Next please
 30959:               executeSoon(nextFn);
 30959:             });
 30959:           }, true);
 30959:         }, true);
 30959:       }, false);
 30959:     }, true);
 30959:   }
 30959: 
 30959:     /**
 30959:    * Test 5: Open some windows and do undoCloseWindow. This should prevent any
 30959:    *         restoring later in the test
 30959:    * @note: Non-Mac only
 30959:    */
 30959:   function testOpenCloseRestoreFromPopup(nextFn) {
124655:     setupTestAndRun(function(newWin) {
124655:       setupTestAndRun(function(newWin2) {
 30959:         newWin.BrowserTryToCloseWindow();
 30959:         newWin2.BrowserTryToCloseWindow();
 30959: 
 36206:         browserWindowsCount([0, 1], "browser windows while running testOpenCloseRestoreFromPopup");
 36206: 
 30959:         newWin = undoCloseWindow(0);
 30959: 
124655:         newWin2 = openDialog(location, "_blank", CHROME_FEATURES);
 30959:         newWin2.addEventListener("load", function() {
 30959:           newWin2.removeEventListener("load", arguments.callee, true);
 30959:           executeSoon(function() {
 30959:             is(newWin2.gBrowser.browsers.length, 1,
 30959:                "Did not restore, as undoCloseWindow() was last called");
 30959:             is(TEST_URLS.indexOf(newWin2.gBrowser.browsers[0].currentURI.spec), -1,
 30959:                "Did not restore, as undoCloseWindow() was last called (2)");
 30959: 
 36214:             browserWindowsCount([2, 3], "browser windows while running testOpenCloseRestoreFromPopup");
 36214: 
 30959:             // Cleanup
 30959:             newWin.close();
 30959:             newWin2.close();
 30959: 
 36214:             browserWindowsCount([0, 1], "browser windows while running testOpenCloseRestoreFromPopup");
 36214: 
 30959:             // Next please
 30959:             executeSoon(nextFn);
 30959:           });
 30959:         }, true);
 30959:       });
 30959:     });
 30959:   }
 30959: 
 30959:   /**
 30959:    * Test 7: Check whether the right number of notifications was received during
 30959:    *         the tests
 30959:    */
 30959:   function testNotificationCount(nextFn) {
 30959:     is(observing["browser-lastwindow-close-requested"], NOTIFICATIONS_EXPECTED,
 30959:        "browser-lastwindow-close-requested notifications observed");
 30959: 
 30959:     // -request must be one more as we cancel the first one we hit,
 30959:     // and hence won't produce a corresponding -grant
 30959:     // @see observer.observe
 30959:     is(observing["browser-lastwindow-close-requested"],
 30959:        observing["browser-lastwindow-close-granted"] + 1,
 30959:        "Notification count for -request and -grant matches");
 30959: 
 30959:     executeSoon(nextFn);
 30959:   }
 30959: 
 30959:   /**
 30959:    * Test 8: Test if closing can be denied on Mac
 51017:    *         Futhermore prepares the testNotificationCount test (Test 7)
 30959:    * @note: Mac only
 30959:    */
 30959:   function testMacNotifications(nextFn, iteration) {
 30959:     iteration = iteration || 1;
124655:     setupTestAndRun(function(newWin) {
 30959:       // close the window
 30959:       // window.close doesn't push any close events,
 30959:       // so use BrowserTryToCloseWindow
 30959:       newWin.BrowserTryToCloseWindow();
 30959:       if (iteration == 1) {
 30959:         ok(!newWin.closed, "First close attempt denied");
 30959:         if (!newWin.closed) {
 30959:           newWin.BrowserTryToCloseWindow();
 30959:           ok(newWin.closed, "Second close attempt granted");
 30959:         }
 30959:       }
 30959: 
 30959:       if (iteration < NOTIFICATIONS_EXPECTED - 1) {
 30959:         executeSoon(function() testMacNotifications(nextFn, ++iteration));
 30959:       }
 30959:       else {
 30959:         executeSoon(nextFn);
 30959:       }
 30959:     });
 30959:   }
 30959: 
 30959:   // Execution starts here
 30959: 
 30959:   setupTestsuite();
 30959:   if (navigator.platform.match(/Mac/)) {
 30959:     // Mac tests
 35682:     testMacNotifications(function () {
 35682:       testNotificationCount(function () {
 34974:         cleanupTestsuite();
 35682:         browserWindowsCount(1, "Only one browser window should be open eventually");
 34974:         finish();
 35682:       });
 35682:     });
 30959:   }
 30959:   else {
 30959:     // Non-Mac Tests
 35682:     testOpenCloseNormal(function () {
 35714:       browserWindowsCount([0, 1], "browser windows after testOpenCloseNormal");
 35682:       testOpenClosePrivateBrowsing(function () {
 35714:         browserWindowsCount([0, 1], "browser windows after testOpenClosePrivateBrowsing");
 35682:         testOpenCloseWindowAndPopup(function () {
 35714:           browserWindowsCount([0, 1], "browser windows after testOpenCloseWindowAndPopup");
 35682:           testOpenCloseOnlyPopup(function () {
 35714:             browserWindowsCount([0, 1], "browser windows after testOpenCloseOnlyPopup");
 35682:             testOpenCloseRestoreFromPopup(function () {
 35714:               browserWindowsCount([0, 1], "browser windows after testOpenCloseRestoreFromPopup");
 35682:               testNotificationCount(function () {
 34974:                 cleanupTestsuite();
 35714:                 browserWindowsCount(1, "browser windows after testNotificationCount");
 34974:                 finish();
 35682:               });
 35682:             });
 35682:           });
 35682:         });
 35682:       });
 35682:     });
 34974:   }
 30959: }
