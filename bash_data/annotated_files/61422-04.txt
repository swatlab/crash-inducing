31590: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
31590:  * ***** BEGIN LICENSE BLOCK *****
31590:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
31590:  *
31590:  * The contents of this file are subject to the Mozilla Public License Version
31590:  * 1.1 (the "License"); you may not use this file except in compliance with
31590:  * the License. You may obtain a copy of the License at
31590:  * http://www.mozilla.org/MPL/
31590:  *
31590:  * Software distributed under the License is distributed on an "AS IS" basis,
31590:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
31590:  * for the specific language governing rights and limitations under the
31590:  * License.
31590:  *
31590:  * The Original Code is Mozilla Corporation code.
31590:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation.
31590:  * Portions created by the Initial Developer are Copyright (C) 2006-2009
31590:  * the Initial Developer. All Rights Reserved.
31590:  *
31590:  * Contributor(s):
31590:  *   Jonathan Kew <jfkthame@gmail.com>
31590:  *
31590:  * Alternatively, the contents of this file may be used under the terms of
31590:  * either the GNU General Public License Version 2 or later (the "GPL"), or
31590:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
31590:  * in which case the provisions of the GPL or the LGPL are applicable instead
31590:  * of those above. If you wish to allow use of your version of this file only
31590:  * under the terms of either the GPL or the LGPL, and not to allow others to
31590:  * use your version of this file under the terms of the MPL, indicate your
31590:  * decision by deleting the provisions above and replace them with the notice
31590:  * and other provisions required by the GPL or the LGPL. If you do not delete
31590:  * the provisions above, a recipient may use your version of this file under
31590:  * the terms of any one of the MPL, the GPL or the LGPL.
31590:  *
31590:  * Based in part on sample code provided by Apple Computer, Inc.,
31590:  * under the following license:
31590:  *
31590:  * Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
31590:  *
31590:  * Redistribution and use in source and binary forms, with or without
31590:  * modification, are permitted provided that the following conditions
31590:  * are met:
31590:  *
31590:  * 1.  Redistributions of source code must retain the above copyright
31590:  *     notice, this list of conditions and the following disclaimer.
31590:  * 2.  Redistributions in binary form must reproduce the above copyright
31590:  *     notice, this list of conditions and the following disclaimer in the
31590:  *     documentation and/or other materials provided with the distribution.
31590:  * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
31590:  *     its contributors may be used to endorse or promote products derived
31590:  *     from this software without specific prior written permission.
31590:  *
31590:  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
31590:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
31590:  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
31590:  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
31590:  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
31590:  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
31590:  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
31590:  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
31590:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
31590:  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
31590:  *
31590:  * ***** END LICENSE BLOCK ***** */
31590: 
61084: #ifdef MOZ_LOGGING
61084: #define FORCE_PR_LOG /* Allow logging in the release build */
61084: #endif
61084: #include "prlog.h"
61084: 
31590: #include "gfxPlatformFontList.h"
43527: #include "gfxTextRunWordCache.h"
31590: 
31590: #include "nsIPrefService.h"
31590: #include "nsIPrefBranch2.h"  // for pref changes callback notification
31590: #include "nsServiceManagerUtils.h"
31590: #include "nsUnicharUtils.h"
61084: #include "nsUnicodeRange.h"
61084: #include "gfxUnicodeProperties.h"
31590: 
31590: // font info loader constants
31590: static const PRUint32 kDelayBeforeLoadingCmaps = 8 * 1000; // 8secs
31590: static const PRUint32 kIntervalBetweenLoadingCmaps = 150; // 150ms
31590: static const PRUint32 kNumFontsPerSlice = 10; // read in info 10 fonts at a time
31590: 
61084: #ifdef PR_LOGGING
31590: 
61084: #define LOG_FONTLIST(args) PR_LOG(gfxPlatform::GetLog(eGfxLog_fontlist), \
61084:                                PR_LOG_DEBUG, args)
61084: #define LOG_FONTLIST_ENABLED() PR_LOG_TEST( \
61084:                                    gfxPlatform::GetLog(eGfxLog_fontlist), \
61084:                                    PR_LOG_DEBUG)
61084: 
61084: #endif // PR_LOGGING
31590: 
31590: gfxPlatformFontList *gfxPlatformFontList::sPlatformFontList = nsnull;
31590: 
31590: 
31590: class gfxFontListPrefObserver : public nsIObserver {
31590: public:
31590:     NS_DECL_ISUPPORTS
31590:     NS_DECL_NSIOBSERVER
31590: };
31590: 
31590: NS_IMPL_ISUPPORTS1(gfxFontListPrefObserver, nsIObserver)
31590: 
31590: NS_IMETHODIMP
31590: gfxFontListPrefObserver::Observe(nsISupports     *aSubject,
31590:                                  const char      *aTopic,
31590:                                  const PRUnichar *aData)
31590: {
31590:     NS_ASSERTION(!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID), "invalid topic");
31590:     // XXX this could be made to only clear out the cache for the prefs that were changed
31590:     // but it probably isn't that big a deal.
31590:     gfxPlatformFontList::PlatformFontList()->ClearPrefFonts();
43527:     gfxFontCache::GetCache()->AgeAllGenerations();
31590:     return NS_OK;
31590: }
31590: 
31590: 
37618: gfxPlatformFontList::gfxPlatformFontList(PRBool aNeedFullnamePostscriptNames)
37618:     : mNeedFullnamePostscriptNames(aNeedFullnamePostscriptNames),
37618:       mStartIndex(0), mIncrement(kNumFontsPerSlice), mNumFamilies(0)
31590: {
31590:     mFontFamilies.Init(100);
31590:     mOtherFamilyNames.Init(30);
31590:     mOtherFamilyNamesInitialized = PR_FALSE;
37618: 
37618:     if (mNeedFullnamePostscriptNames) {
37618:         mFullnames.Init(100);
37618:         mPostscriptNames.Init(100);
37618:     }
37618:     mFaceNamesInitialized = PR_FALSE;
37618: 
31590:     mPrefFonts.Init(10);
31590: 
37599:     mBadUnderlineFamilyNames.Init(10);
37599:     LoadBadUnderlineList();
37599: 
31590:     // pref changes notification setup
31590:     gfxFontListPrefObserver *observer = new gfxFontListPrefObserver();
31590:     if (observer) {
31590:         nsCOMPtr<nsIPrefBranch2> pref = do_GetService(NS_PREFSERVICE_CONTRACTID);
31590:         if (pref) {
31590:             pref->AddObserver("font.", observer, PR_FALSE);
31590:             pref->AddObserver("font.name-list.", observer, PR_FALSE);
31590:             pref->AddObserver("intl.accept_languages", observer, PR_FALSE);  // hmmmm...
31590:         } else {
31590:             delete observer;
31590:         }
31590:     }
31590: }
31590: 
57104: nsresult
37618: gfxPlatformFontList::InitFontList()
37618: {
37618:     mFontFamilies.Clear();
37618:     mOtherFamilyNames.Clear();
37618:     mOtherFamilyNamesInitialized = PR_FALSE;
37618:     if (mNeedFullnamePostscriptNames) {
37618:         mFullnames.Clear();
37618:         mPostscriptNames.Clear();
37618:     }
37618:     mFaceNamesInitialized = PR_FALSE;
37618:     mPrefFonts.Clear();
37618:     CancelLoader();
37618: 
37618:     // initialize ranges of characters for which system-wide font search should be skipped
37618:     mCodepointsWithNoFonts.reset();
37618:     mCodepointsWithNoFonts.SetRange(0,0x1f);     // C0 controls
37618:     mCodepointsWithNoFonts.SetRange(0x7f,0x9f);  // C1 controls
57104: 
57104:     sPlatformFontList = this;
57104: 
57104:     return NS_OK;
37618: }
37618: 
37618: void
31590: gfxPlatformFontList::GenerateFontListKey(const nsAString& aKeyName, nsAString& aResult)
31590: {
31590:     aResult = aKeyName;
31590:     ToLowerCase(aResult);
31590: }
31590: 
31590: void 
31590: gfxPlatformFontList::InitOtherFamilyNames()
31590: {
31590:     mOtherFamilyNamesInitialized = PR_TRUE;
31590: 
31590:     // iterate over all font families and read in other family names
31590:     mFontFamilies.Enumerate(gfxPlatformFontList::InitOtherFamilyNamesProc, this);
31590: }
31590:                                                          
31590: PLDHashOperator PR_CALLBACK
31590: gfxPlatformFontList::InitOtherFamilyNamesProc(nsStringHashKey::KeyType aKey,
31590:                                               nsRefPtr<gfxFontFamily>& aFamilyEntry,
31590:                                               void* userArg)
31590: {
31590:     gfxPlatformFontList *fc = static_cast<gfxPlatformFontList*>(userArg);
37618:     aFamilyEntry->ReadOtherFamilyNames(fc);
31590:     return PL_DHASH_NEXT;
31590: }
31590: 
31590: void
37618: gfxPlatformFontList::InitFaceNameLists()
31590: {
37618:     mFaceNamesInitialized = PR_TRUE;
31590: 
37618:     // iterate over all font families and read in other family names
37618:     mFontFamilies.Enumerate(gfxPlatformFontList::InitFaceNameListsProc, this);
31590: }
37618: 
37618: PLDHashOperator PR_CALLBACK
37618: gfxPlatformFontList::InitFaceNameListsProc(nsStringHashKey::KeyType aKey,
37618:                                            nsRefPtr<gfxFontFamily>& aFamilyEntry,
37618:                                            void* userArg)
37618: {
37618:     gfxPlatformFontList *fc = static_cast<gfxPlatformFontList*>(userArg);
37618:     aFamilyEntry->ReadFaceNames(fc, fc->NeedFullnamePostscriptNames());
37618:     return PL_DHASH_NEXT;
31590: }
31590: 
31590: void
31590: gfxPlatformFontList::PreloadNamesList()
31590: {
31590:     nsAutoTArray<nsString, 10> preloadFonts;
31590:     gfxFontUtils::GetPrefsFontList("font.preload-names-list", preloadFonts);
31590: 
31590:     PRUint32 numFonts = preloadFonts.Length();
31590:     for (PRUint32 i = 0; i < numFonts; i++) {
31590:         PRBool found;
31590:         nsAutoString key;
31590:         GenerateFontListKey(preloadFonts[i], key);
31590:         
31590:         // only search canonical names!
31590:         gfxFontFamily *familyEntry = mFontFamilies.GetWeak(key, &found);
31590:         if (familyEntry) {
37618:             familyEntry->ReadOtherFamilyNames(this);
31590:         }
31590:     }
31590: 
31590: }
31590: 
31590: void 
31590: gfxPlatformFontList::SetFixedPitch(const nsAString& aFamilyName)
31590: {
31590:     gfxFontFamily *family = FindFamily(aFamilyName);
31590:     if (!family) return;
31590: 
35525:     family->FindStyleVariations();
31590:     nsTArray<nsRefPtr<gfxFontEntry> >& fontlist = family->GetFontList();
31590: 
31590:     PRUint32 i, numFonts = fontlist.Length();
31590: 
31590:     for (i = 0; i < numFonts; i++) {
31590:         fontlist[i]->mFixedPitch = 1;
31590:     }
31590: }
31590: 
31590: void
37599: gfxPlatformFontList::LoadBadUnderlineList()
31590: {
31590:     nsAutoTArray<nsString, 10> blacklist;
31590:     gfxFontUtils::GetPrefsFontList("font.blacklist.underline_offset", blacklist);
31590:     PRUint32 numFonts = blacklist.Length();
31590:     for (PRUint32 i = 0; i < numFonts; i++) {
31590:         nsAutoString key;
31590:         GenerateFontListKey(blacklist[i], key);
38060:         mBadUnderlineFamilyNames.Put(key);
31590:     }
31590: }
31590: 
31590: PRBool 
31590: gfxPlatformFontList::ResolveFontName(const nsAString& aFontName, nsAString& aResolvedFontName)
31590: {
31590:     gfxFontFamily *family = FindFamily(aFontName);
31590:     if (family) {
31590:         aResolvedFontName = family->Name();
31590:         return PR_TRUE;
31590:     }
31590:     return PR_FALSE;
31590: }
31590: 
31590: struct FontListData {
38493:     FontListData(nsIAtom *aLangGroup,
31590:                  const nsACString& aGenericFamily,
31590:                  nsTArray<nsString>& aListOfFonts) :
31590:         mLangGroup(aLangGroup), mGenericFamily(aGenericFamily),
31590:         mListOfFonts(aListOfFonts) {}
38493:     nsIAtom *mLangGroup;
31590:     const nsACString& mGenericFamily;
31590:     nsTArray<nsString>& mListOfFonts;
31590: };
31590: 
31590: PLDHashOperator PR_CALLBACK
31590: gfxPlatformFontList::HashEnumFuncForFamilies(nsStringHashKey::KeyType aKey,
31590:                                              nsRefPtr<gfxFontFamily>& aFamilyEntry,
31590:                                              void *aUserArg)
31590: {
31590:     FontListData *data = static_cast<FontListData*>(aUserArg);
31590: 
36949:     // use the first variation for now.  This data should be the same
36949:     // for all the variations and should probably be moved up to
36949:     // the Family
36949:     gfxFontStyle style;
38492:     style.language = data->mLangGroup;
36949:     PRBool needsBold;
36949:     nsRefPtr<gfxFontEntry> aFontEntry = aFamilyEntry->FindFontForStyle(style, needsBold);
36949:     NS_ASSERTION(aFontEntry, "couldn't find any font entry in family");
36949:     if (!aFontEntry)
36949:         return PL_DHASH_NEXT;
36949: 
36949:     /* skip symbol fonts */
36949:     if (aFontEntry->IsSymbolFont())
36949:         return PL_DHASH_NEXT;
36949: 
36949:     if (aFontEntry->SupportsLangGroup(data->mLangGroup) &&
36949:         aFontEntry->MatchesGenericFamily(data->mGenericFamily)) {
31590:         nsAutoString localizedFamilyName;
31590:         aFamilyEntry->LocalizedName(localizedFamilyName);
31590:         data->mListOfFonts.AppendElement(localizedFamilyName);
36949:     }
36949: 
31590:     return PL_DHASH_NEXT;
31590: }
31590: 
31590: void
38493: gfxPlatformFontList::GetFontList(nsIAtom *aLangGroup,
31590:                                  const nsACString& aGenericFamily,
31590:                                  nsTArray<nsString>& aListOfFonts)
31590: {
31590:     FontListData data(aLangGroup, aGenericFamily, aListOfFonts);
31590: 
31590:     mFontFamilies.Enumerate(gfxPlatformFontList::HashEnumFuncForFamilies, &data);
31590: 
31590:     aListOfFonts.Sort();
31590:     aListOfFonts.Compact();
31590: }
31590: 
31590: struct FontFamilyListData {
31590:     FontFamilyListData(nsTArray<nsRefPtr<gfxFontFamily> >& aFamilyArray) 
31590:         : mFamilyArray(aFamilyArray)
31590:     {}
31590: 
31590:     static PLDHashOperator PR_CALLBACK AppendFamily(nsStringHashKey::KeyType aKey,
31590:                                                     nsRefPtr<gfxFontFamily>& aFamilyEntry,
31590:                                                     void *aUserArg)
31590:     {
31590:         FontFamilyListData *data = static_cast<FontFamilyListData*>(aUserArg);
31590:         data->mFamilyArray.AppendElement(aFamilyEntry);
31590:         return PL_DHASH_NEXT;
31590:     }
31590: 
31590:     nsTArray<nsRefPtr<gfxFontFamily> >& mFamilyArray;
31590: };
31590: 
31590: void
31590: gfxPlatformFontList::GetFontFamilyList(nsTArray<nsRefPtr<gfxFontFamily> >& aFamilyArray)
31590: {
31590:     FontFamilyListData data(aFamilyArray);
31590:     mFontFamilies.Enumerate(FontFamilyListData::AppendFamily, &data);
31590: }
31590: 
31590: gfxFontEntry*  
31590: gfxPlatformFontList::FindFontForChar(const PRUint32 aCh, gfxFont *aPrevFont)
31590: {
31590:     // is codepoint with no matching font? return null immediately
31590:     if (mCodepointsWithNoFonts.test(aCh)) {
31590:         return nsnull;
31590:     }
31590: 
31590:     // TODO: optimize fallback e.g. by caching lists of fonts to try for a given
31590:     // unicode range or script
31590: 
31590:     // try to short-circuit font fallback for U+FFFD, used to represent encoding errors:
31590:     // just use a platform-specific fallback system font that is guaranteed (or at least
31590:     // highly likely) to be around, or a cached family from last time U+FFFD was seen.
31590:     // this helps speed up pages with lots of encoding errors, binary-as-text, etc.
31590:     if (aCh == 0xFFFD && mReplacementCharFallbackFamily.Length() > 0) {
31590:         gfxFontEntry* fontEntry = nsnull;
31590:         PRBool needsBold;  // ignored in the system fallback case
31590: 
31590:         if (aPrevFont) {
31590:             fontEntry = FindFontForFamily(mReplacementCharFallbackFamily, aPrevFont->GetStyle(), needsBold);
31590:         } else {
31590:             gfxFontStyle normalStyle;
31590:             fontEntry = FindFontForFamily(mReplacementCharFallbackFamily, &normalStyle, needsBold);
31590:         }
31590: 
31590:         if (fontEntry && fontEntry->TestCharacterMap(aCh))
31590:             return fontEntry;
31590:     }
31590: 
31590:     FontSearch data(aCh, aPrevFont);
31590: 
31590:     // iterate over all font families to find a font that support the character
31590:     mFontFamilies.Enumerate(gfxPlatformFontList::FindFontForCharProc, &data);
31590: 
61084: #ifdef PR_LOGGING
61084:     PRLogModuleInfo *log = gfxPlatform::GetLog(eGfxLog_textrun);
61084: 
61084:     if (NS_UNLIKELY(log)) {
61084:         PRUint32 charRange = gfxFontUtils::CharRangeBit(aCh);
61084:         PRUint32 unicodeRange = FindCharUnicodeRange(aCh);
61084:         PRUint32 hbscript = gfxUnicodeProperties::GetScriptCode(aCh);
61084:         PR_LOG(log, PR_LOG_DEBUG,\
61084:                ("(textrun-systemfallback) char: u+%6.6x "
61084:                 "char-range: %d unicode-range: %d script: %d match: [%s] count: %d\n",
61084:                 aCh,
61084:                 charRange, unicodeRange, hbscript,
61084:                 (data.mBestMatch ?
61084:                  NS_ConvertUTF16toUTF8(data.mBestMatch->Name()).get() :
61084:                  "<none>"),
61084:                 data.mCount));
61084:     }
61084: #endif
61084: 
31590:     // no match? add to set of non-matching codepoints
31590:     if (!data.mBestMatch) {
31590:         mCodepointsWithNoFonts.set(aCh);
31590:     } else if (aCh == 0xFFFD) {
31590:         mReplacementCharFallbackFamily = data.mBestMatch->FamilyName();
31590:     }
31590: 
31590:     return data.mBestMatch;
31590: }
31590: 
31590: PLDHashOperator PR_CALLBACK 
31590: gfxPlatformFontList::FindFontForCharProc(nsStringHashKey::KeyType aKey, nsRefPtr<gfxFontFamily>& aFamilyEntry,
31590:      void *userArg)
31590: {
31590:     FontSearch *data = static_cast<FontSearch*>(userArg);
31590: 
31590:     // evaluate all fonts in this family for a match
31590:     aFamilyEntry->FindFontForChar(data);
31590:     return PL_DHASH_NEXT;
31590: }
31590: 
61085: #ifdef XP_WIN
61085: #include <windows.h>
61085: 
61085: // crude hack for using when monitoring process
61085: static void LogRegistryEvent(const wchar_t *msg)
61085: {
61085:   HKEY dummyKey;
61085:   HRESULT hr;
61085:   wchar_t buf[512];
61085: 
61085:   wsprintfW(buf, L" log %s", msg);
61085:   hr = RegOpenKeyExW(HKEY_LOCAL_MACHINE, buf, 0, KEY_READ, &dummyKey);
61085:   if (SUCCEEDED(hr)) {
61085:     RegCloseKey(dummyKey);
61085:   }
61085: }
61085: #endif
61085: 
31590: gfxFontFamily* 
31590: gfxPlatformFontList::FindFamily(const nsAString& aFamily)
31590: {
31590:     nsAutoString key;
31590:     gfxFontFamily *familyEntry;
31590:     PRBool found;
31590:     GenerateFontListKey(aFamily, key);
31590: 
61422:     NS_ASSERTION(mFontFamilies.Count() != 0, "system font list was not initialized correctly");
61422: 
31590:     // lookup in canonical (i.e. English) family name list
31590:     if ((familyEntry = mFontFamilies.GetWeak(key, &found))) {
31590:         return familyEntry;
31590:     }
31590: 
31590:     // lookup in other family names list (mostly localized names)
60116:     if ((familyEntry = mOtherFamilyNames.GetWeak(key, &found)) != nsnull) {
31590:         return familyEntry;
31590:     }
31590: 
31590:     // name not found and other family names not yet fully initialized so
31590:     // initialize the rest of the list and try again.  this is done lazily
60116:     // since reading name table entries is expensive.
60116:     // although ASCII localized family names are possible they don't occur
60116:     // in practice so avoid pulling in names at startup
60116:     if (!mOtherFamilyNamesInitialized && !IsASCII(aFamily)) {
31590:         InitOtherFamilyNames();
60116:         if ((familyEntry = mOtherFamilyNames.GetWeak(key, &found)) != nsnull) {
31590:             return familyEntry;
31590:         }
31590:     }
31590: 
31590:     return nsnull;
31590: }
31590: 
31590: gfxFontEntry*
31590: gfxPlatformFontList::FindFontForFamily(const nsAString& aFamily, const gfxFontStyle* aStyle, PRBool& aNeedsBold)
31590: {
31590:     gfxFontFamily *familyEntry = FindFamily(aFamily);
31590: 
31590:     aNeedsBold = PR_FALSE;
31590: 
31590:     if (familyEntry)
31590:         return familyEntry->FindFontForStyle(*aStyle, aNeedsBold);
31590: 
31590:     return nsnull;
31590: }
31590: 
31590: PRBool
31590: gfxPlatformFontList::GetPrefFontFamilyEntries(eFontPrefLang aLangGroup, nsTArray<nsRefPtr<gfxFontFamily> > *array)
31590: {
31590:     return mPrefFonts.Get(PRUint32(aLangGroup), array);
31590: }
31590: 
31590: void
31590: gfxPlatformFontList::SetPrefFontFamilyEntries(eFontPrefLang aLangGroup, nsTArray<nsRefPtr<gfxFontFamily> >& array)
31590: {
31590:     mPrefFonts.Put(PRUint32(aLangGroup), array);
31590: }
31590: 
31590: void 
31590: gfxPlatformFontList::AddOtherFamilyName(gfxFontFamily *aFamilyEntry, nsAString& aOtherFamilyName)
31590: {
31590:     nsAutoString key;
31590:     PRBool found;
31590:     GenerateFontListKey(aOtherFamilyName, key);
31590: 
31590:     if (!mOtherFamilyNames.GetWeak(key, &found)) {
31590:         mOtherFamilyNames.Put(key, aFamilyEntry);
61084: #ifdef PR_LOGGING
61084:         LOG_FONTLIST(("(fontlist-otherfamily) canonical family: %s, "
61084:                       "other family: %s\n",
31590:                       NS_ConvertUTF16toUTF8(aFamilyEntry->Name()).get(),
31590:                       NS_ConvertUTF16toUTF8(aOtherFamilyName).get()));
61084: #endif
38060:         if (mBadUnderlineFamilyNames.Contains(key))
37599:             aFamilyEntry->SetBadUnderlineFamily();
31590:     }
31590: }
31590: 
37618: void
37618: gfxPlatformFontList::AddFullname(gfxFontEntry *aFontEntry, nsAString& aFullname)
37618: {
37618:     PRBool found;
37618: 
37618:     if (!mFullnames.GetWeak(aFullname, &found)) {
37618:         mFullnames.Put(aFullname, aFontEntry);
61084: #ifdef PR_LOGGING
61084:         LOG_FONTLIST(("(fontlist-fullname) name: %s, fullname: %s\n",
37618:                       NS_ConvertUTF16toUTF8(aFontEntry->Name()).get(),
37618:                       NS_ConvertUTF16toUTF8(aFullname).get()));
61084: #endif
37618:     }
37618: }
37618: 
37618: void
37618: gfxPlatformFontList::AddPostscriptName(gfxFontEntry *aFontEntry, nsAString& aPostscriptName)
37618: {
37618:     PRBool found;
37618: 
37618:     if (!mPostscriptNames.GetWeak(aPostscriptName, &found)) {
37618:         mPostscriptNames.Put(aPostscriptName, aFontEntry);
61084: #ifdef PR_LOGGING
61084:         LOG_FONTLIST(("(fontlist-postscript) name: %s, psname: %s\n",
37618:                       NS_ConvertUTF16toUTF8(aFontEntry->Name()).get(),
37618:                       NS_ConvertUTF16toUTF8(aPostscriptName).get()));
61084: #endif
37618:     }
37618: }
37618: 
36949: PRBool
36949: gfxPlatformFontList::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
36949: {
36949:     aFamilyName.Truncate();
36949:     ResolveFontName(aFontName, aFamilyName);
36949:     return !aFamilyName.IsEmpty();
36949: }
36949: 
31590: void 
31590: gfxPlatformFontList::InitLoader()
31590: {
31590:     GetFontFamilyList(mFontFamiliesToLoad);
31590:     mStartIndex = 0;
31590:     mNumFamilies = mFontFamiliesToLoad.Length();
31590: }
31590: 
31590: PRBool 
31590: gfxPlatformFontList::RunLoader()
31590: {
31590:     PRUint32 i, endIndex = (mStartIndex + mIncrement < mNumFamilies ? mStartIndex + mIncrement : mNumFamilies);
31590: 
31590:     // for each font family, load in various font info
31590:     for (i = mStartIndex; i < endIndex; i++) {
35525:         gfxFontFamily* familyEntry = mFontFamiliesToLoad[i];
31590: 
35525:         // find all faces that are members of this family
35525:         familyEntry->FindStyleVariations();
38059:         if (familyEntry->GetFontList().Length() == 0) {
38059:             // failed to load any faces for this family, so discard it
38059:             nsAutoString key;
38059:             GenerateFontListKey(familyEntry->Name(), key);
38059:             mFontFamilies.Remove(key);
38059:             continue;
38059:         }
35525: 
35525:         // load the cmaps
35525:         familyEntry->ReadCMAP();
31590: 
37618:         // read in face names
37618:         familyEntry->ReadFaceNames(this, mNeedFullnamePostscriptNames);
31590: 
31590:         // check whether the family can be considered "simple" for style matching
35525:         familyEntry->CheckForSimpleFamily();
31590:     }
31590: 
38059:     mStartIndex = endIndex;
38059: 
38059:     return (mStartIndex >= mNumFamilies);
31590: }
31590: 
31590: void 
31590: gfxPlatformFontList::FinishLoader()
31590: {
31590:     mFontFamiliesToLoad.Clear();
31590:     mNumFamilies = 0;
31590: }
