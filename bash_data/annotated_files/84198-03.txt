29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43532:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
74581:  *   Nick Fitzgerald <nfitzgerald@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS debugging API.
    1:  */
    1: #include <string.h>
76358: #include <stdarg.h>
62057: #include "jsprvtd.h"
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
    1: #include "jsclist.h"
    1: #include "jsapi.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
74472: #include "jswatchpoint.h"
56704: #include "jswrapper.h"
80202: 
80964: #include "frontend/BytecodeEmitter.h"
80506: #include "frontend/Parser.h"
76244: #include "vm/Debugger.h"
    1: 
30283: #include "jsatominlines.h"
77343: #include "jsinferinlines.h"
69223: #include "jsobjinlines.h"
53840: #include "jsinterpinlines.h"
35453: #include "jsscopeinlines.h"
59968: #include "jsscriptinlines.h"
30283: 
69223: #include "vm/Stack-inl.h"
69223: 
15453: #include "jsautooplen.h"
15453: 
76358: #ifdef __APPLE__
76358: #include "sharkctl.h"
76358: #endif
76358: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
53391: JS_PUBLIC_API(JSBool)
53391: JS_GetDebugMode(JSContext *cx)
53391: {
75489:     return cx->compartment->debugMode();
53391: }
53391: 
62057: JS_PUBLIC_API(JSBool)
62057: JS_SetDebugMode(JSContext *cx, JSBool debug)
53391: {
62057:     return JS_SetDebugModeForCompartment(cx, cx->compartment, debug);
53391: }
53391: 
56783: JS_PUBLIC_API(void)
56783: JS_SetRuntimeDebugMode(JSRuntime *rt, JSBool debug)
56783: {
75489:     rt->debugMode = !!debug;
56783: }
56783: 
64363: namespace js {
64363: 
84070: JSTrapStatus
69223: ScriptDebugPrologue(JSContext *cx, StackFrame *fp)
64363: {
75523:     JS_ASSERT(fp == cx->fp());
75523: 
64363:     if (fp->isFramePushedByExecute()) {
64363:         if (JSInterpreterHook hook = cx->debugHooks->executeHook)
69223:             fp->setHookData(hook(cx, Jsvalify(fp), true, 0, cx->debugHooks->executeHookData));
64363:     } else {
64363:         if (JSInterpreterHook hook = cx->debugHooks->callHook)
69223:             fp->setHookData(hook(cx, Jsvalify(fp), true, 0, cx->debugHooks->callHookData));
64363:     }
84070: 
84070:     Value rval;
84070:     JSTrapStatus status = Debugger::onEnterFrame(cx, &rval);
84070:     switch (status) {
84070:       case JSTRAP_CONTINUE:
84070:         break;
84070:       case JSTRAP_THROW:
84070:         cx->setPendingException(rval);
84070:         break;
84070:       case JSTRAP_ERROR:
84070:         cx->clearPendingException();
84070:         break;
84070:       case JSTRAP_RETURN:
84070:         fp->setReturnValue(rval);
84070:         break;
84070:       default:
84070:         JS_NOT_REACHED("bad Debugger::onEnterFrame JSTrapStatus value");
84070:     }
84070:     return status;
64363: }
64363: 
64363: bool
69223: ScriptDebugEpilogue(JSContext *cx, StackFrame *fp, bool okArg)
64363: {
75413:     JS_ASSERT(fp == cx->fp());
64363:     JSBool ok = okArg;
64363: 
64363:     if (void *hookData = fp->maybeHookData()) {
64363:         if (fp->isFramePushedByExecute()) {
64363:             if (JSInterpreterHook hook = cx->debugHooks->executeHook)
69223:                 hook(cx, Jsvalify(fp), false, &ok, hookData);
64363:         } else {
64363:             if (JSInterpreterHook hook = cx->debugHooks->callHook)
69223:                 hook(cx, Jsvalify(fp), false, &ok, hookData);
64363:         }
64363:     }
75523:     Debugger::onLeaveFrame(cx);
64363: 
64363:     return ok;
64363: }
64363: 
64363: } /* namespace js */
64363: 
62779: JS_FRIEND_API(JSBool)
62779: JS_SetDebugModeForCompartment(JSContext *cx, JSCompartment *comp, JSBool debug)
62779: {
75489:     return comp->setDebugModeFromC(cx, !!debug);
53391: }
53391: 
53391: static JSBool
53391: CheckDebugMode(JSContext *cx)
53391: {
53391:     JSBool debugMode = JS_GetDebugMode(cx);
53391:     /*
53391:      * :TODO:
53391:      * This probably should be an assertion, since it's indicative of a severe
53391:      * API misuse.
53391:      */
53391:     if (!debugMode) {
53391:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage,
53391:                                      NULL, JSMSG_NEED_DEBUG_MODE);
53391:     }
53391:     return debugMode;
53391: }
53391: 
59882: JS_PUBLIC_API(JSBool)
59882: JS_SetSingleStepMode(JSContext *cx, JSScript *script, JSBool singleStep)
59882: {
64192:     assertSameCompartment(cx, script);
59882:     if (!CheckDebugMode(cx))
59882:         return JS_FALSE;
59882: 
77169:     return script->setStepModeFlag(cx, singleStep);
59882: }
59882: 
    1: JS_PUBLIC_API(JSBool)
75506: JS_SetTrap(JSContext *cx, JSScript *script, jsbytecode *pc, JSTrapHandler handler, jsval closure)
    1: {
84195:     assertSameCompartment(cx, script, closure);
84195: 
75506:     if (!CheckDebugMode(cx))
75506:         return false;
    1: 
84195:     BreakpointSite *site = script->getOrCreateBreakpointSite(cx, pc, NULL);
75506:     if (!site)
75506:         return false;
78614:     site->setTrap(cx, handler, closure);
75506:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
41863:              JSTrapHandler *handlerp, jsval *closurep)
    1: {
84195:     if (BreakpointSite *site = script->getBreakpointSite(pc)) {
84195:         site->clearTrap(cx, handlerp, closurep);
75506:     } else {
    1:         if (handlerp)
75506:             *handlerp = NULL;
    1:         if (closurep)
75506:             *closurep = JSVAL_VOID;
53168:     }
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearScriptTraps(JSContext *cx, JSScript *script)
    1: {
84195:     script->clearTraps(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
75506: JS_ClearAllTrapsForCompartment(JSContext *cx)
    1: {
84195:     cx->compartment->clearTraps(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
41863: JS_SetInterrupt(JSRuntime *rt, JSInterruptHook hook, void *closure)
    1: {
41863:     rt->globalDebugHooks.interruptHook = hook;
41863:     rt->globalDebugHooks.interruptHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
41863: JS_ClearInterrupt(JSRuntime *rt, JSInterruptHook *hoop, void **closurep)
    1: {
41863:     if (hoop)
41863:         *hoop = rt->globalDebugHooks.interruptHook;
    1:     if (closurep)
41863:         *closurep = rt->globalDebugHooks.interruptHookData;
41863:     rt->globalDebugHooks.interruptHook = 0;
41863:     rt->globalDebugHooks.interruptHookData = 0;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_SetWatchPoint(JSContext *cx, JSObject *obj, jsid id,
51134:                  JSWatchPointHandler handler, JSObject *closure)
    1: {
64192:     assertSameCompartment(cx, obj);
74472:     id = js_CheckForStringIndex(id);
64192: 
35046:     JSObject *origobj;
48470:     Value v;
35046:     uintN attrs;
    1:     jsid propid;
    1: 
35046:     origobj = obj;
35046:     OBJ_TO_INNER_OBJECT(cx, obj);
35046:     if (!obj)
64199:         return false;
    1: 
43203:     AutoValueRooter idroot(cx);
48470:     if (JSID_IS_INT(id)) {
48470:         propid = id;
80787:     } else if (JSID_IS_OBJECT(id)) {
80787:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_WATCH_PROP);
80787:         return false;
24284:     } else {
48470:         if (!js_ValueToStringId(cx, IdToValue(id), &propid))
64199:             return false;
30270:         propid = js_CheckForStringIndex(propid);
48470:         idroot.set(IdToValue(propid));
24284:     }
    1: 
35046:     /*
35046:      * If, by unwrapping and innerizing, we changed the object, check
35046:      * again to make sure that we're allowed to set a watch point.
35046:      */
47455:     if (origobj != obj && !CheckAccess(cx, obj, propid, JSACC_WATCH, &v, &attrs))
64199:         return false;
35046: 
40430:     if (!obj->isNative()) {
35046:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_WATCH,
40826:                              obj->getClass()->name);
64199:         return false;
35046:     }
35046: 
77353:     types::MarkTypePropertyConfigured(cx, obj, propid);
77343: 
74472:     WatchpointMap *wpmap = cx->compartment->watchpointMap;
74472:     if (!wpmap) {
74472:         wpmap = cx->runtime->new_<WatchpointMap>();
74472:         if (!wpmap || !wpmap->init()) {
74472:             js_ReportOutOfMemory(cx);
64199:             return false;
    1:         }
74472:         cx->compartment->watchpointMap = wpmap;
64199:     }
80787:     return wpmap->watch(cx, obj, propid, handler, closure);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48470: JS_ClearWatchPoint(JSContext *cx, JSObject *obj, jsid id,
51134:                    JSWatchPointHandler *handlerp, JSObject **closurep)
    1: {
74472:     assertSameCompartment(cx, obj, id);
64192: 
74472:     id = js_CheckForStringIndex(id);
74472:     if (WatchpointMap *wpmap = cx->compartment->watchpointMap)
74472:         wpmap->unwatch(obj, id, handlerp, closurep);
74472:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ClearWatchPointsForObject(JSContext *cx, JSObject *obj)
    1: {
64192:     assertSameCompartment(cx, obj);
64192: 
74472:     if (WatchpointMap *wpmap = cx->compartment->watchpointMap)
74472:         wpmap->unwatchObject(obj);
74472:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ClearAllWatchPoints(JSContext *cx)
    1: {
74472:     if (JSCompartment *comp = cx->compartment) {
74472:         if (WatchpointMap *wpmap = comp->watchpointMap)
74472:             wpmap->clear();
    1:     }
74472:     return true;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
    1:     return js_PCToLineNumber(cx, script, pc);
    1: }
    1: 
    1: JS_PUBLIC_API(jsbytecode *)
    1: JS_LineNumberToPC(JSContext *cx, JSScript *script, uintN lineno)
    1: {
    1:     return js_LineNumberToPC(script, lineno);
    1: }
    1: 
55561: JS_PUBLIC_API(jsbytecode *)
55561: JS_EndPC(JSContext *cx, JSScript *script)
55561: {
55561:     return script->code + script->length;
55561: }
55561: 
71318: JS_PUBLIC_API(JSBool)
71318: JS_GetLinePCs(JSContext *cx, JSScript *script,
71318:               uintN startLine, uintN maxLines,
71318:               uintN* count, uintN** retLines, jsbytecode*** retPCs)
71318: {
71318:     uintN* lines;
71318:     jsbytecode** pcs;
71318:     size_t len = (script->length > maxLines ? maxLines : script->length);
71318:     lines = (uintN*) cx->malloc_(len * sizeof(uintN));
71318:     if (!lines)
71318:         return JS_FALSE;
71318: 
71318:     pcs = (jsbytecode**) cx->malloc_(len * sizeof(jsbytecode*));
71318:     if (!pcs) {
71318:         cx->free_(lines);
71318:         return JS_FALSE;
71318:     }
71318: 
71318:     uintN lineno = script->lineno;
71318:     uintN offset = 0;
71318:     uintN i = 0;
71318:     for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
71318:         offset += SN_DELTA(sn);
80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
71318:         if (type == SRC_SETLINE || type == SRC_NEWLINE) {
71318:             if (type == SRC_SETLINE)
71318:                 lineno = (uintN) js_GetSrcNoteOffset(sn, 0);
71318:             else
71318:                 lineno++;
71318: 
71318:             if (lineno >= startLine) {
71318:                 lines[i] = lineno;
71318:                 pcs[i] = script->code + offset;
71318:                 if (++i >= maxLines)
71318:                     break;
71318:             }
71318:         }
71318:     }
71318: 
71318:     *count = i;
71318:     if (retLines)
71318:         *retLines = lines;
71318:     else
71318:         cx->free_(lines);
71318: 
71318:     if (retPCs)
71318:         *retPCs = pcs;
71318:     else
71318:         cx->free_(pcs);
71318: 
71318:     return JS_TRUE;
71318: }
71318: 
48470: JS_PUBLIC_API(uintN)
48470: JS_GetFunctionArgumentCount(JSContext *cx, JSFunction *fun)
48470: {
48470:     return fun->nargs;
48470: }
48470: 
48470: JS_PUBLIC_API(JSBool)
48470: JS_FunctionHasLocalNames(JSContext *cx, JSFunction *fun)
48470: {
59968:     return fun->script()->bindings.hasLocalNames();
48470: }
48470: 
48470: extern JS_PUBLIC_API(jsuword *)
48470: JS_GetFunctionLocalNameArray(JSContext *cx, JSFunction *fun, void **markp)
48470: {
73058:     Vector<JSAtom *> localNames(cx);
73058:     if (!fun->script()->bindings.getLocalNameArray(cx, &localNames))
73058:         return NULL;
73058: 
73058:     /* Munge data into the API this method implements.  Avert your eyes! */
79410:     *markp = cx->tempLifoAlloc().mark();
73058: 
79410:     jsuword *names = cx->tempLifoAlloc().newArray<jsuword>(localNames.length());
73058:     if (!names) {
73058:         js_ReportOutOfMemory(cx);
73058:         return NULL;
73058:     }
73058: 
73058:     memcpy(names, localNames.begin(), localNames.length() * sizeof(jsuword));
73058:     return names;
48470: }
48470: 
48470: extern JS_PUBLIC_API(JSAtom *)
48470: JS_LocalNameToAtom(jsuword w)
48470: {
48470:     return JS_LOCAL_NAME_TO_ATOM(w);
48470: }
48470: 
48470: extern JS_PUBLIC_API(JSString *)
48470: JS_AtomKey(JSAtom *atom)
48470: {
64345:     return atom;
48470: }
48470: 
48470: extern JS_PUBLIC_API(void)
48470: JS_ReleaseFunctionLocalNameArray(JSContext *cx, void *mark)
48470: {
79410:     cx->tempLifoAlloc().release(mark);
48470: }
48470: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_GetFunctionScript(JSContext *cx, JSFunction *fun)
    1: {
76812:     return fun->maybeScript();
    1: }
    1: 
    1: JS_PUBLIC_API(JSNative)
    1: JS_GetFunctionNative(JSContext *cx, JSFunction *fun)
    1: {
78614:     return fun->maybeNative();
 4127: }
 4127: 
    1: JS_PUBLIC_API(JSPrincipals *)
    1: JS_GetScriptPrincipals(JSContext *cx, JSScript *script)
    1: {
    1:     return script->principals;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  *  Stack Frame Iterator
    1:  */
    1: JS_PUBLIC_API(JSStackFrame *)
    1: JS_FrameIterator(JSContext *cx, JSStackFrame **iteratorp)
    1: {
69223:     StackFrame *fp = Valueify(*iteratorp);
77343:     *iteratorp = Jsvalify((fp == NULL) ? js_GetTopStackFrame(cx, FRAME_EXPAND_ALL) : fp->prev());
    1:     return *iteratorp;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_GetFrameScript(JSContext *cx, JSStackFrame *fp)
    1: {
69223:     return Valueify(fp)->maybeScript();
    1: }
    1: 
    1: JS_PUBLIC_API(jsbytecode *)
    1: JS_GetFramePC(JSContext *cx, JSStackFrame *fp)
    1: {
77343:     return Valueify(fp)->pcQuadratic(cx->stack);
    1: }
    1: 
    1: JS_PUBLIC_API(JSStackFrame *)
    1: JS_GetScriptedCaller(JSContext *cx, JSStackFrame *fp)
    1: {
69223:     return Jsvalify(js_GetScriptedCaller(cx, Valueify(fp)));
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
69223: JS_GetFrameAnnotation(JSContext *cx, JSStackFrame *fpArg)
    1: {
69223:     StackFrame *fp = Valueify(fpArg);
53840:     if (fp->annotation() && fp->isScriptFrame()) {
69223:         JSPrincipals *principals = fp->scopeChain().principals(cx);
    1: 
    1:         if (principals && principals->globalPrivilegesEnabled(cx, principals)) {
    1:             /*
    1:              * Give out an annotation only if privileges have not been revoked
    1:              * or disabled globally.
    1:              */
53840:             return fp->annotation();
    1:         }
    1:     }
    1: 
    1:     return NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetFrameAnnotation(JSContext *cx, JSStackFrame *fp, void *annotation)
    1: {
69223:     Valueify(fp)->setAnnotation(annotation);
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetFramePrincipalArray(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     JSPrincipals *principals;
    1: 
69223:     principals = Valueify(fp)->scopeChain().principals(cx);
    1:     if (!principals)
    1:         return NULL;
    1:     return principals->getPrincipalArray(cx, principals);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
53557: JS_IsScriptFrame(JSContext *cx, JSStackFrame *fp)
    1: {
69223:     return !Valueify(fp)->isDummyFrame();
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
69223: JS_GetFrameScopeChain(JSContext *cx, JSStackFrame *fpArg)
    1: {
69223:     StackFrame *fp = Valueify(fpArg);
71697:     JS_ASSERT(cx->stack.containsSlow(fp));
42714: 
56704:     js::AutoCompartment ac(cx, &fp->scopeChain());
56704:     if (!ac.enter())
56704:         return NULL;
56704: 
    1:     /* Force creation of argument and call objects if not yet created */
69223:     (void) JS_GetFrameCallObject(cx, Jsvalify(fp));
56729:     return GetScopeChain(cx, fp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
69223: JS_GetFrameCallObject(JSContext *cx, JSStackFrame *fpArg)
    1: {
69223:     StackFrame *fp = Valueify(fpArg);
71697:     JS_ASSERT(cx->stack.containsSlow(fp));
42714: 
53840:     if (!fp->isFunctionFrame())
    1:         return NULL;
    1: 
56704:     js::AutoCompartment ac(cx, &fp->scopeChain());
56704:     if (!ac.enter())
56704:         return NULL;
56704: 
    1:     /*
    1:      * XXX ill-defined: null return here means error was reported, unlike a
    1:      *     null returned above or in the #else
    1:      */
64364:     if (!fp->hasCallObj() && fp->isNonEvalFunctionFrame())
64364:         return CreateFunCallObject(cx, fp);
64364:     return &fp->callObj();
    1: }
    1: 
55713: JS_PUBLIC_API(JSBool)
69223: JS_GetFrameThis(JSContext *cx, JSStackFrame *fpArg, jsval *thisv)
    1: {
69223:     StackFrame *fp = Valueify(fpArg);
50484:     if (fp->isDummyFrame())
55713:         return false;
56704: 
56704:     js::AutoCompartment ac(cx, &fp->scopeChain());
56704:     if (!ac.enter())
56704:         return false;
56704: 
68904:     if (!ComputeThis(cx, fp))
55713:         return false;
78614:     *thisv = fp->thisValue();
55713:     return true;
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_GetFrameFunction(JSContext *cx, JSStackFrame *fp)
    1: {
83474:     return Valueify(fp)->maybeScriptFunction();
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
69223: JS_GetFrameFunctionObject(JSContext *cx, JSStackFrame *fpArg)
    1: {
69223:     StackFrame *fp = Valueify(fpArg);
53840:     if (!fp->isFunctionFrame())
18955:         return NULL;
18572: 
53840:     JS_ASSERT(fp->callee().isFunction());
53840:     return &fp->callee();
    1: }
    1: 
84198: JS_PUBLIC_API(JSFunction *)
84198: JS_GetScriptFunction(JSContext *cx, JSScript *script)
84198: {
84198:     return script->function();
84198: }
84198: 
83331: JS_PUBLIC_API(JSObject *)
83331: JS_GetParentOrScopeChain(JSContext *cx, JSObject *obj)
83331: {
83331:     return obj->scopeChain();
83331: }
83331: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsConstructorFrame(JSContext *cx, JSStackFrame *fp)
    1: {
69223:     return Valueify(fp)->isConstructing();
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCalleeObject(JSContext *cx, JSStackFrame *fp)
    1: {
71695:     return Valueify(fp)->maybeCalleev().toObjectOrNull();
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
48676: JS_GetValidFrameCalleeObject(JSContext *cx, JSStackFrame *fp, jsval *vp)
48676: {
48676:     Value v;
48676: 
69223:     if (!Valueify(fp)->getValidCalleeObject(cx, &v))
48676:         return false;
78614:     *vp = v.isObject() ? v : JSVAL_VOID;
78614:     *vp = v;
48676:     return true;
48676: }
48676: 
48676: JS_PUBLIC_API(JSBool)
    1: JS_IsDebuggerFrame(JSContext *cx, JSStackFrame *fp)
    1: {
69223:     return Valueify(fp)->isDebuggerFrame();
    1: }
    1: 
69704: JS_PUBLIC_API(JSBool)
69704: JS_IsGlobalFrame(JSContext *cx, JSStackFrame *fp)
69704: {
69704:     return Valueify(fp)->isGlobalFrame();
69704: }
69704: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetFrameReturnValue(JSContext *cx, JSStackFrame *fp)
    1: {
78614:     return Valueify(fp)->returnValue();
    1: }
    1: 
    1: JS_PUBLIC_API(void)
69223: JS_SetFrameReturnValue(JSContext *cx, JSStackFrame *fpArg, jsval rval)
    1: {
69223:     StackFrame *fp = Valueify(fpArg);
57727: #ifdef JS_METHODJIT
57727:     JS_ASSERT_IF(fp->isScriptFrame(), fp->script()->debugMode);
57727: #endif
56704:     assertSameCompartment(cx, fp, rval);
78614:     fp->setReturnValue(rval);
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetScriptFilename(JSContext *cx, JSScript *script)
    1: {
    1:     return script->filename;
    1: }
    1: 
74581: JS_PUBLIC_API(const jschar *)
74581: JS_GetScriptSourceMap(JSContext *cx, JSScript *script)
74581: {
74581:     return script->sourceMap;
74581: }
74581: 
    1: JS_PUBLIC_API(uintN)
    1: JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script)
    1: {
    1:     return script->lineno;
    1: }
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_GetScriptLineExtent(JSContext *cx, JSScript *script)
    1: {
    1:     return js_GetScriptLineExtent(script);
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
    1: JS_GetScriptVersion(JSContext *cx, JSScript *script)
    1: {
53848:     return VersionNumber(script->getVersion());
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetNewScriptHook(JSRuntime *rt, JSNewScriptHook hook, void *callerdata)
    1: {
 2433:     rt->globalDebugHooks.newScriptHook = hook;
 2433:     rt->globalDebugHooks.newScriptHookData = callerdata;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetDestroyScriptHook(JSRuntime *rt, JSDestroyScriptHook hook,
    1:                         void *callerdata)
    1: {
 2433:     rt->globalDebugHooks.destroyScriptHook = hook;
 2433:     rt->globalDebugHooks.destroyScriptHookData = callerdata;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
69223: JS_EvaluateUCInStackFrame(JSContext *cx, JSStackFrame *fpArg,
    1:                           const jschar *chars, uintN length,
    1:                           const char *filename, uintN lineno,
    1:                           jsval *rval)
    1: {
53391:     if (!CheckDebugMode(cx))
58070:         return false;
53391: 
69223:     JSObject *scobj = JS_GetFrameScopeChain(cx, fpArg);
    1:     if (!scobj)
48582:         return false;
    1: 
56704:     js::AutoCompartment ac(cx, scobj);
56704:     if (!ac.enter())
58070:         return false;
56704: 
69223:     StackFrame *fp = Valueify(fpArg);
78614:     return EvaluateInScope(cx, scobj, fp, chars, length, filename, lineno, rval);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                         const char *bytes, uintN length,
    1:                         const char *filename, uintN lineno,
    1:                         jsval *rval)
    1: {
    1:     jschar *chars;
    1:     JSBool ok;
    1:     size_t len = length;
    1: 
53391:     if (!CheckDebugMode(cx))
53391:         return JS_FALSE;
53391: 
71337:     chars = InflateString(cx, bytes, &len);
    1:     if (!chars)
    1:         return JS_FALSE;
    1:     length = (uintN) len;
    1:     ok = JS_EvaluateUCInStackFrame(cx, fp, chars, length, filename, lineno,
    1:                                    rval);
64560:     cx->free_(chars);
    1: 
    1:     return ok;
    1: }
    1: 
    1: /************************************************************************/
    1: 
52503: /* This all should be reworked to avoid requiring JSScopeProperty types. */
    1: 
    1: JS_PUBLIC_API(JSScopeProperty *)
    1: JS_PropertyIterator(JSObject *obj, JSScopeProperty **iteratorp)
    1: {
52503:     const Shape *shape;
    1: 
52503:     /* The caller passes null in *iteratorp to get things started. */
52503:     shape = (Shape *) *iteratorp;
79526:     if (!shape)
52503:         shape = obj->lastProperty();
79526:     else
52503:         shape = shape->previous();
79526: 
52503:     if (!shape->previous()) {
83225:         JS_ASSERT(shape->isEmptyShape());
52503:         shape = NULL;
52503:     }
    1: 
52503:     return *iteratorp = reinterpret_cast<JSScopeProperty *>(const_cast<Shape *>(shape));
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDesc(JSContext *cx, JSObject *obj, JSScopeProperty *sprop,
    1:                    JSPropertyDesc *pd)
    1: {
56704:     assertSameCompartment(cx, obj);
52503:     Shape *shape = (Shape *) sprop;
83221:     pd->id = IdToJsval(shape->propid());
    1: 
60211:     JSBool wasThrowing = cx->isExceptionPending();
60211:     Value lastException = UndefinedValue();
60211:     if (wasThrowing)
60211:         lastException = cx->getPendingException();
60211:     cx->clearPendingException();
    1: 
83221:     if (!js_GetProperty(cx, obj, shape->propid(), &pd->value)) {
60211:         if (!cx->isExceptionPending()) {
    1:             pd->flags = JSPD_ERROR;
    1:             pd->value = JSVAL_VOID;
    1:         } else {
    1:             pd->flags = JSPD_EXCEPTION;
78614:             pd->value = cx->getPendingException();
    1:         }
    1:     } else {
    1:         pd->flags = 0;
    1:     }
    1: 
35076:     if (wasThrowing)
60211:         cx->setPendingException(lastException);
    1: 
52503:     pd->flags |= (shape->enumerable() ? JSPD_ENUMERATE : 0)
52503:               |  (!shape->writable()  ? JSPD_READONLY  : 0)
52503:               |  (!shape->configurable() ? JSPD_PERMANENT : 0);
13706:     pd->spare = 0;
58293:     if (shape->getter() == GetCallArg) {
83221:         pd->slot = shape->shortid();
13706:         pd->flags |= JSPD_ARGUMENT;
58293:     } else if (shape->getter() == GetCallVar) {
83221:         pd->slot = shape->shortid();
13706:         pd->flags |= JSPD_VARIABLE;
13706:     } else {
13706:         pd->slot = 0;
    1:     }
    1:     pd->alias = JSVAL_VOID;
35076: 
83221:     if (obj->containsSlot(shape->slot())) {
52503:         for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront()) {
52503:             const Shape &aprop = r.front();
83221:             if (&aprop != shape && aprop.slot() == shape->slot()) {
83221:                 pd->alias = IdToJsval(aprop.propid());
    1:                 break;
    1:             }
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDescArray(JSContext *cx, JSObject *obj, JSPropertyDescArray *pda)
    1: {
56704:     assertSameCompartment(cx, obj);
48470:     Class *clasp = obj->getClass();
40430:     if (!obj->isNative() || (clasp->flags & JSCLASS_NEW_ENUMERATE)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_DESCRIBE_PROPS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     if (!clasp->enumerate(cx, obj))
    1:         return JS_FALSE;
    1: 
52503:     /* Return an empty pda early if obj has no own properties. */
52503:     if (obj->nativeEmpty()) {
    1:         pda->length = 0;
    1:         pda->array = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
52503:     uint32 n = obj->propertyCount();
64560:     JSPropertyDesc *pd = (JSPropertyDesc *) cx->malloc_(size_t(n) * sizeof(JSPropertyDesc));
    1:     if (!pd)
    1:         return JS_FALSE;
52503:     uint32 i = 0;
52503:     for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront()) {
78614:         if (!js_AddRoot(cx, &pd[i].id, NULL))
    1:             goto bad;
78614:         if (!js_AddRoot(cx, &pd[i].value, NULL))
    1:             goto bad;
52503:         Shape *shape = const_cast<Shape *>(&r.front());
52503:         if (!JS_GetPropertyDesc(cx, obj, reinterpret_cast<JSScopeProperty *>(shape), &pd[i]))
    1:             goto bad;
78614:         if ((pd[i].flags & JSPD_ALIAS) && !js_AddRoot(cx, &pd[i].alias, NULL))
    1:             goto bad;
    1:         if (++i == n)
    1:             break;
    1:     }
    1:     pda->length = i;
    1:     pda->array = pd;
    1:     return JS_TRUE;
    1: 
    1: bad:
    1:     pda->length = i + 1;
    1:     pda->array = pd;
    1:     JS_PutPropertyDescArray(cx, pda);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_PutPropertyDescArray(JSContext *cx, JSPropertyDescArray *pda)
    1: {
    1:     JSPropertyDesc *pd;
    1:     uint32 i;
    1: 
    1:     pd = pda->array;
    1:     for (i = 0; i < pda->length; i++) {
    1:         js_RemoveRoot(cx->runtime, &pd[i].id);
    1:         js_RemoveRoot(cx->runtime, &pd[i].value);
    1:         if (pd[i].flags & JSPD_ALIAS)
    1:             js_RemoveRoot(cx->runtime, &pd[i].alias);
    1:     }
64560:     cx->free_(pd);
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
41863: JS_SetDebuggerHandler(JSRuntime *rt, JSDebuggerHandler handler, void *closure)
    1: {
 2433:     rt->globalDebugHooks.debuggerHandler = handler;
 2433:     rt->globalDebugHooks.debuggerHandlerData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetSourceHandler(JSRuntime *rt, JSSourceHandler handler, void *closure)
    1: {
 2433:     rt->globalDebugHooks.sourceHandler = handler;
 2433:     rt->globalDebugHooks.sourceHandlerData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetExecuteHook(JSRuntime *rt, JSInterpreterHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.executeHook = hook;
 2433:     rt->globalDebugHooks.executeHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetCallHook(JSRuntime *rt, JSInterpreterHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.callHook = hook;
 2433:     rt->globalDebugHooks.callHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
41863: JS_SetThrowHook(JSRuntime *rt, JSThrowHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.throwHook = hook;
 2433:     rt->globalDebugHooks.throwHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetDebugErrorHook(JSRuntime *rt, JSDebugErrorHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.debugErrorHook = hook;
 2433:     rt->globalDebugHooks.debugErrorHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetObjectTotalSize(JSContext *cx, JSObject *obj)
    1: {
55746:     return obj->slotsAndStructSize();
    1: }
    1: 
    1: static size_t
    1: GetAtomTotalSize(JSContext *cx, JSAtom *atom)
    1: {
    1:     size_t nbytes;
    1: 
 4529:     nbytes = sizeof(JSAtom *) + sizeof(JSDHashEntryStub);
    1:     nbytes += sizeof(JSString);
64345:     nbytes += (atom->length() + 1) * sizeof(jschar);
    1:     return nbytes;
    1: }
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetFunctionTotalSize(JSContext *cx, JSFunction *fun)
    1: {
    1:     size_t nbytes;
    1: 
    1:     nbytes = sizeof *fun;
76812:     nbytes += JS_GetObjectTotalSize(cx, fun);
76812:     if (fun->isInterpreted())
70311:         nbytes += JS_GetScriptTotalSize(cx, fun->script());
    1:     if (fun->atom)
    1:         nbytes += GetAtomTotalSize(cx, fun->atom);
    1:     return nbytes;
    1: }
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetScriptTotalSize(JSContext *cx, JSScript *script)
    1: {
    1:     size_t nbytes, pbytes;
    1:     jssrcnote *sn, *notes;
 3235:     JSObjectArray *objarray;
    1:     JSPrincipals *principals;
    1: 
    1:     nbytes = sizeof *script;
    1:     nbytes += script->length * sizeof script->code[0];
77659:     nbytes += script->natoms * sizeof script->atoms[0];
77659:     for (size_t i = 0; i < script->natoms; i++)
77659:         nbytes += GetAtomTotalSize(cx, script->atoms[i]);
    1: 
    1:     if (script->filename)
    1:         nbytes += strlen(script->filename) + 1;
    1: 
32723:     notes = script->notes();
    1:     for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
    1:         continue;
    1:     nbytes += (sn - notes + 1) * sizeof *sn;
    1: 
59221:     if (JSScript::isValidOffset(script->objectsOffset)) {
32723:         objarray = script->objects();
72579:         size_t i = objarray->length;
 3235:         nbytes += sizeof *objarray + i * sizeof objarray->vector[0];
 3235:         do {
 3235:             nbytes += JS_GetObjectTotalSize(cx, objarray->vector[--i]);
 3235:         } while (i != 0);
 3235:     }
 3235: 
59221:     if (JSScript::isValidOffset(script->regexpsOffset)) {
32723:         objarray = script->regexps();
72579:         size_t i = objarray->length;
 3235:         nbytes += sizeof *objarray + i * sizeof objarray->vector[0];
 3235:         do {
 3235:             nbytes += JS_GetObjectTotalSize(cx, objarray->vector[--i]);
 3235:         } while (i != 0);
 3235:     }
 3235: 
59221:     if (JSScript::isValidOffset(script->trynotesOffset)) {
 3235:         nbytes += sizeof(JSTryNoteArray) +
32723:             script->trynotes()->length * sizeof(JSTryNote);
    1:     }
    1: 
    1:     principals = script->principals;
    1:     if (principals) {
    1:         JS_ASSERT(principals->refcount);
    1:         pbytes = sizeof *principals;
    1:         if (principals->refcount > 1)
    1:             pbytes = JS_HOWMANY(pbytes, principals->refcount);
    1:         nbytes += pbytes;
    1:     }
    1: 
    1:     return nbytes;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsSystemObject(JSContext *cx, JSObject *obj)
    1: {
32603:     return obj->isSystem();
    1: }
    1: 
43286: JS_PUBLIC_API(JSBool)
43286: JS_MakeSystemObject(JSContext *cx, JSObject *obj)
    1: {
83248:     return obj->setSystem(cx);
    1: }
 2433: 
 2433: /************************************************************************/
 2433: 
53848: JS_FRIEND_API(void)
53848: js_RevertVersion(JSContext *cx)
53848: {
53848:     cx->clearVersionOverride();
53848: }
53848: 
35331: JS_PUBLIC_API(const JSDebugHooks *)
 2433: JS_GetGlobalDebugHooks(JSRuntime *rt)
 2433: {
 2433:     return &rt->globalDebugHooks;
 2433: }
 2433: 
37717: const JSDebugHooks js_NullDebugHooks = {};
37717: 
 2433: JS_PUBLIC_API(JSDebugHooks *)
35331: JS_SetContextDebugHooks(JSContext *cx, const JSDebugHooks *hooks)
 2433: {
35331:     JS_ASSERT(hooks);
 2433: 
35331:     JSDebugHooks *old = const_cast<JSDebugHooks *>(cx->debugHooks);
 2433:     cx->debugHooks = hooks;
 2433:     return old;
 2433: }
10339: 
37717: JS_PUBLIC_API(JSDebugHooks *)
37717: JS_ClearContextDebugHooks(JSContext *cx)
37717: {
37717:     return JS_SetContextDebugHooks(cx, &js_NullDebugHooks);
37717: }
37717: 
76358: /************************************************************************/
76358: 
76358: /* Profiling-related API */
76358: 
76358: /* Thread-unsafe error management */
76358: 
76358: static char gLastError[2000];
76358: 
76358: static void
76711: #ifdef __GNUC__
76358: __attribute__((unused,format(printf,1,2)))
76358: #endif
76358: UnsafeError(const char *format, ...)
60787: {
76358:     va_list args;
76358:     va_start(args, format);
76358:     (void) vsnprintf(gLastError, sizeof(gLastError), format, args);
76358:     va_end(args);
76358: 
76358:     gLastError[sizeof(gLastError) - 1] = '\0';
60787: }
10339: 
76358: JS_PUBLIC_API(const char *)
76358: JS_UnsafeGetLastProfilingError()
60787: {
76358:     return gLastError;
76358: }
76358: 
76358: JS_PUBLIC_API(JSBool)
76358: JS_StartProfiling(const char *profileName)
76358: {
76358:     JSBool ok = JS_TRUE;
76358: #if defined(MOZ_SHARK) && defined(__APPLE__)
76358:     if (!Shark::Start()) {
76358:         UnsafeError("Failed to start Shark for %s", profileName);
76358:         ok = JS_FALSE;
76358:     }
76358: #endif
76358: #ifdef MOZ_VTUNE
76358:     if (!js_StartVtune(profileName))
76358:         ok = JS_FALSE;
76358: #endif
76358:     return ok;
76358: }
76358: 
76358: JS_PUBLIC_API(JSBool)
76358: JS_StopProfiling(const char *profileName)
76358: {
76358:     JSBool ok = JS_TRUE;
76358: #if defined(MOZ_SHARK) && defined(__APPLE__)
76358:     Shark::Stop();
76358: #endif
76358: #ifdef MOZ_VTUNE
76358:     if (!js_StopVtune())
76358:         ok = JS_FALSE;
76358: #endif
76358:     return ok;
76358: }
76358: 
76358: /*
76358:  * Start or stop whatever platform- and configuration-specific profiling
76358:  * backends are available.
76358:  */
76358: static JSBool
76358: ControlProfilers(bool toState)
76358: {
76358:     JSBool ok = JS_TRUE;
76358: 
76358:     if (! Probes::ProfilingActive && toState) {
76358: #if defined(MOZ_SHARK) && defined(__APPLE__)
76358:         if (!Shark::Start()) {
76358:             UnsafeError("Failed to start Shark");
76358:             ok = JS_FALSE;
76358:         }
76358: #endif
76358: #ifdef MOZ_CALLGRIND
76358:         if (! js_StartCallgrind()) {
76358:             UnsafeError("Failed to start Callgrind");
76358:             ok = JS_FALSE;
76358:         }
76358: #endif
76358: #ifdef MOZ_VTUNE
76358:         if (! js_ResumeVtune())
76358:             ok = JS_FALSE;
76358: #endif
76358:     } else if (Probes::ProfilingActive && ! toState) {
76358: #if defined(MOZ_SHARK) && defined(__APPLE__)
76358:         Shark::Stop();
76358: #endif
76358: #ifdef MOZ_CALLGRIND
76358:         if (! js_StopCallgrind()) {
76358:             UnsafeError("failed to stop Callgrind");
76358:             ok = JS_FALSE;
76358:         }
76358: #endif
76358: #ifdef MOZ_VTUNE
76358:         if (! js_PauseVtune())
76358:             ok = JS_FALSE;
76358: #endif
76358:     }
76358: 
76358:     Probes::ProfilingActive = toState;
76358: 
76358:     return ok;
76358: }
76358: 
76358: /*
76358:  * Pause/resume whatever profiling mechanism is currently compiled
76358:  * in, if applicable. This will not affect things like dtrace.
76358:  *
76358:  * Do not mix calls to these APIs with calls to the individual
76358:  * profilers' pause/resume functions, because only overall state is
76358:  * tracked, not the state of each profiler.
76358:  */
76358: JS_PUBLIC_API(JSBool)
76358: JS_PauseProfilers(const char *profileName)
76358: {
76358:     return ControlProfilers(false);
76358: }
76358: 
76358: JS_PUBLIC_API(JSBool)
76358: JS_ResumeProfilers(const char *profileName)
76358: {
76358:     return ControlProfilers(true);
76358: }
76358: 
76358: JS_PUBLIC_API(JSBool)
76358: JS_DumpProfile(const char *outfile, const char *profileName)
76358: {
76358:     JSBool ok = JS_TRUE;
76358: #ifdef MOZ_CALLGRIND
76358:     js_DumpCallgrind(outfile);
76358: #endif
76358:     return ok;
60787: }
60787: 
60787: #ifdef MOZ_PROFILING
60787: 
76358: struct RequiredStringArg {
76358:     JSContext *mCx;
76358:     char *mBytes;
76358:     RequiredStringArg(JSContext *cx, uintN argc, jsval *vp, size_t argi, const char *caller)
76358:         : mCx(cx), mBytes(NULL)
76358:     {
76358:         if (argc <= argi) {
76358:             JS_ReportError(cx, "%s: not enough arguments", caller);
76358:         } else if (!JSVAL_IS_STRING(JS_ARGV(cx, vp)[argi])) {
76358:             JS_ReportError(cx, "%s: invalid arguments (string expected)", caller);
76358:         } else {
76358:             mBytes = JS_EncodeString(cx, JSVAL_TO_STRING(JS_ARGV(cx, vp)[argi]));
76358:         }
76358:     }
76358:     operator void*() {
76358:         return (void*) mBytes;
76358:     }
76358:     ~RequiredStringArg() {
76358:         if (mBytes)
76358:             mCx->free_(mBytes);
76358:     }
76358: };
76358: 
60787: static JSBool
60787: StartProfiling(JSContext *cx, uintN argc, jsval *vp)
60787: {
76358:     if (argc == 0) {
76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StartProfiling(NULL)));
76358:         return JS_TRUE;
76358:     }
76358: 
76358:     RequiredStringArg profileName(cx, argc, vp, 0, "startProfiling");
76358:     if (!profileName)
76358:         return JS_FALSE;
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StartProfiling(profileName.mBytes)));
76358:     return JS_TRUE;
60787: }
60787: 
60787: static JSBool
60787: StopProfiling(JSContext *cx, uintN argc, jsval *vp)
60787: {
76358:     if (argc == 0) {
76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StopProfiling(NULL)));
76358:         return JS_TRUE;
76358:     }
76358: 
76358:     RequiredStringArg profileName(cx, argc, vp, 0, "stopProfiling");
76358:     if (!profileName)
76358:         return JS_FALSE;
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_StopProfiling(profileName.mBytes)));
76358:     return JS_TRUE;
76358: }
76358: 
76358: static JSBool
76358: PauseProfilers(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     if (argc == 0) {
76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_PauseProfilers(NULL)));
76358:         return JS_TRUE;
76358:     }
76358: 
76358:     RequiredStringArg profileName(cx, argc, vp, 0, "pauseProfiling");
76358:     if (!profileName)
76358:         return JS_FALSE;
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_PauseProfilers(profileName.mBytes)));
76358:     return JS_TRUE;
76358: }
76358: 
76358: static JSBool
76358: ResumeProfilers(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     if (argc == 0) {
76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_ResumeProfilers(NULL)));
76358:         return JS_TRUE;
76358:     }
76358: 
76358:     RequiredStringArg profileName(cx, argc, vp, 0, "resumeProfiling");
76358:     if (!profileName)
76358:         return JS_FALSE;
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(JS_ResumeProfilers(profileName.mBytes)));
76358:     return JS_TRUE;
76358: }
76358: 
76358: /* Usage: DumpProfile([filename[, profileName]]) */
76358: static JSBool
76358: DumpProfile(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     bool ret;
76358:     if (argc == 0) {
76358:         ret = JS_DumpProfile(NULL, NULL);
76358:     } else {
76358:         RequiredStringArg filename(cx, argc, vp, 0, "dumpProfile");
76358:         if (!filename)
76358:             return JS_FALSE;
76358: 
76358:         if (argc == 1) {
76358:             ret = JS_DumpProfile(filename.mBytes, NULL);
76358:         } else {
76358:             RequiredStringArg profileName(cx, argc, vp, 1, "dumpProfile");
76358:             if (!profileName)
76358:                 return JS_FALSE;
76358: 
76358:             ret = JS_DumpProfile(filename.mBytes, profileName.mBytes);
76358:         }
76358:     }
76358: 
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret));
60787:     return true;
60787: }
60787: 
60791: #ifdef MOZ_SHARK
60791: 
60791: static JSBool
60791: IgnoreAndReturnTrue(JSContext *cx, uintN argc, jsval *vp)
60791: {
60791:     JS_SET_RVAL(cx, vp, JSVAL_TRUE);
60791:     return true;
60791: }
60791: 
60791: #endif
60791: 
76358: #ifdef MOZ_CALLGRIND
76358: static JSBool
76358: StartCallgrind(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_StartCallgrind()));
76358:     return JS_TRUE;
76358: }
76358: 
76358: static JSBool
76358: StopCallgrind(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_StopCallgrind()));
76358:     return JS_TRUE;
76358: }
76358: 
76358: static JSBool
76358: DumpCallgrind(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     if (argc == 0) {
76358:         JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_DumpCallgrind(NULL)));
76358:         return JS_TRUE;
76358:     }
76358: 
76358:     RequiredStringArg outFile(cx, argc, vp, 0, "dumpCallgrind");
76358:     if (!outFile)
76358:         return JS_FALSE;
76358: 
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_DumpCallgrind(outFile.mBytes)));
76358:     return JS_TRUE;
76358: }    
76358: #endif
76358: 
76358: #ifdef MOZ_VTUNE
76358: static JSBool
76358: StartVtune(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     RequiredStringArg profileName(cx, argc, vp, 0, "startVtune");
76358:     if (!profileName)
76358:         return JS_FALSE;
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_StartVtune(profileName.mBytes)));
76358:     return JS_TRUE;
76358: }
76358: 
76358: static JSBool
76358: StopVtune(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_StopVtune()));
76358:     return JS_TRUE;
76358: }
76358: 
76358: static JSBool
76358: PauseVtune(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_PauseVtune()));
76358:     return JS_TRUE;
76358: }
76358: 
76358: static JSBool
76358: ResumeVtune(JSContext *cx, uintN argc, jsval *vp)
76358: {
76358:     JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(js_ResumeVtune()));
76358:     return JS_TRUE;
76358: }
76358: #endif
76358: 
60787: static JSFunctionSpec profiling_functions[] = {
76358:     JS_FN("startProfiling",  StartProfiling,      1,0),
76358:     JS_FN("stopProfiling",   StopProfiling,       1,0),
76358:     JS_FN("pauseProfilers",  PauseProfilers,      1,0),
76358:     JS_FN("resumeProfilers", ResumeProfilers,     1,0),
76358:     JS_FN("dumpProfile",     DumpProfile,         2,0),
60791: #ifdef MOZ_SHARK
60791:     /* Keep users of the old shark API happy. */
60791:     JS_FN("connectShark",    IgnoreAndReturnTrue, 0,0),
60791:     JS_FN("disconnectShark", IgnoreAndReturnTrue, 0,0),
60791:     JS_FN("startShark",      StartProfiling,      0,0),
60791:     JS_FN("stopShark",       StopProfiling,       0,0),
60791: #endif
76358: #ifdef MOZ_CALLGRIND
76358:     JS_FN("startCallgrind", StartCallgrind,       0,0),
76358:     JS_FN("stopCallgrind",  StopCallgrind,        0,0),
76358:     JS_FN("dumpCallgrind",  DumpCallgrind,        1,0),
76358: #endif
76358: #ifdef MOZ_VTUNE
76358:     JS_FN("startVtune",     js_StartVtune,        1,0),
76358:     JS_FN("stopVtune",      js_StopVtune,         0,0),
76358:     JS_FN("pauseVtune",     js_PauseVtune,        0,0),
76358:     JS_FN("resumeVtune",    js_ResumeVtune,       0,0),
76358: #endif
60787:     JS_FS_END
60787: };
60787: 
60787: #endif
13496: 
10447: JS_PUBLIC_API(JSBool)
60787: JS_DefineProfilingFunctions(JSContext *cx, JSObject *obj)
10339: {
64192:     assertSameCompartment(cx, obj);
60787: #ifdef MOZ_PROFILING
60787:     return JS_DefineFunctions(cx, obj, profiling_functions);
60787: #else
60787:     return true;
60787: #endif
10339: }
10339: 
15763: #ifdef MOZ_CALLGRIND
15763: 
15763: #include <valgrind/callgrind.h>
15763: 
84106: /*
84106:  * Wrapper for callgrind macros to stop warnings coming from their expansions.
84106:  */ 
84106: #if (__GNUC__ >= 5) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
84106: # define WRAP_CALLGRIND(call)                                                 \
84106:     JS_BEGIN_MACRO                                                            \
84106:         _Pragma("GCC diagnostic push")                                        \
84106:         _Pragma("GCC diagnostic ignored \"-Wunused-but-set-variable\"")       \
84106:         call;                                                                 \
84106:         _Pragma("GCC diagnostic pop")                                         \
84106:     JS_END_MACRO
84106: #else
84106: # define WRAP_CALLGRIND(call)                                                 \
84106:     JS_BEGIN_MACRO                                                            \
84106:         call;                                                                 \
84106:     JS_END_MACRO
84106: #endif
84106: 
15763: JS_FRIEND_API(JSBool)
76358: js_StartCallgrind()
15763: {
84106:     WRAP_CALLGRIND(CALLGRIND_START_INSTRUMENTATION);
84106:     WRAP_CALLGRIND(CALLGRIND_ZERO_STATS);
76358:     return true;
15763: }
15763: 
15763: JS_FRIEND_API(JSBool)
76358: js_StopCallgrind()
15763: {
84106:     WRAP_CALLGRIND(CALLGRIND_STOP_INSTRUMENTATION);
76358:     return true;
15763: }
15763: 
15763: JS_FRIEND_API(JSBool)
76358: js_DumpCallgrind(const char *outfile)
15763: {
76358:     if (outfile) {
84106:         WRAP_CALLGRIND(CALLGRIND_DUMP_STATS_AT(outfile));
76358:     } else {
84106:         WRAP_CALLGRIND(CALLGRIND_DUMP_STATS);
76358:     }
75388: 
76358:     return true;
15763: }
15763: 
15763: #endif /* MOZ_CALLGRIND */
16288: 
16288: #ifdef MOZ_VTUNE
16288: #include <VTuneApi.h>
16288: 
16288: static const char *vtuneErrorMessages[] = {
16288:   "unknown, error #0",
16288:   "invalid 'max samples' field",
16288:   "invalid 'samples per buffer' field",
16288:   "invalid 'sample interval' field",
16288:   "invalid path",
16288:   "sample file in use",
16288:   "invalid 'number of events' field",
16288:   "unknown, error #7",
16288:   "internal error",
16288:   "bad event name",
16288:   "VTStopSampling called without calling VTStartSampling",
16288:   "no events selected for event-based sampling",
16288:   "events selected cannot be run together",
16288:   "no sampling parameters",
16288:   "sample database already exists",
16288:   "sampling already started",
16288:   "time-based sampling not supported",
16288:   "invalid 'sampling parameters size' field",
16288:   "invalid 'event size' field",
16288:   "sampling file already bound",
16288:   "invalid event path",
16288:   "invalid license",
16288:   "invalid 'global options' field",
16288: 
16288: };
16288: 
76358: bool
76358: js_StartVtune(const char *profileName)
16288: {
16288:     VTUNE_EVENT events[] = {
16288:         { 1000000, 0, 0, 0, "CPU_CLK_UNHALTED.CORE" },
16288:         { 1000000, 0, 0, 0, "INST_RETIRED.ANY" },
16288:     };
16288: 
16288:     U32 n_events = sizeof(events) / sizeof(VTUNE_EVENT);
16288:     char *default_filename = "mozilla-vtune.tb5";
16288:     JSString *str;
16288:     U32 status;
16288: 
54568:     VTUNE_SAMPLING_PARAMS params = {
16288:         sizeof(VTUNE_SAMPLING_PARAMS),
16288:         sizeof(VTUNE_EVENT),
16288:         0, 0, /* Reserved fields */
16288:         1,    /* Initialize in "paused" state */
16288:         0,    /* Max samples, or 0 for "continuous" */
16288:         4096, /* Samples per buffer */
16288:         0.1,  /* Sampling interval in ms */
16288:         1,    /* 1 for event-based sampling, 0 for time-based */
16288: 
16288:         n_events,
16288:         events,
16288:         default_filename,
16288:     };
16288: 
76358:     if (profileName) {
76358:         char filename[strlen(profileName) + strlen("-vtune.tb5") + 1];
76358:         snprintf(filename, sizeof(filename), "%s-vtune.tb5", profileName);
76358:         params.tb5Filename = filename;
16288:     }
16288: 
16288:     status = VTStartSampling(&params);
16288: 
16288:     if (params.tb5Filename != default_filename)
76358:         Foreground::free_(params.tb5Filename);
16288: 
16288:     if (status != 0) {
16288:         if (status == VTAPI_MULTIPLE_RUNS)
16288:             VTStopSampling(0);
16288:         if (status < sizeof(vtuneErrorMessages))
76358:             UnsafeError("Vtune setup error: %s", vtuneErrorMessages[status]);
16288:         else
76358:             UnsafeError("Vtune setup error: %d", status);
54568:         return false;
16288:     }
54568:     return true;
16288: }
16288: 
76358: bool
76358: js_StopVtune()
16288: {
16288:     U32 status = VTStopSampling(1);
16288:     if (status) {
16288:         if (status < sizeof(vtuneErrorMessages))
76358:             UnsafeError("Vtune shutdown error: %s", vtuneErrorMessages[status]);
16288:         else
76358:             UnsafeError("Vtune shutdown error: %d", status);
54568:         return false;
16288:     }
54568:     return true;
16288: }
16288: 
76358: bool
76358: js_PauseVtune()
16288: {
16288:     VTPause();
54568:     return true;
16288: }
16288: 
76358: bool
76358: js_ResumeVtune()
16288: {
16288:     VTResume();
54568:     return true;
16288: }
16288: 
16288: #endif /* MOZ_VTUNE */
31063: 
71700: JS_PUBLIC_API(void)
76358: JS_DumpBytecode(JSContext *cx, JSScript *script)
71700: {
71700: #if defined(DEBUG)
79410:     LifoAlloc lifoAlloc(1024);
71700:     Sprinter sprinter;
79410:     INIT_SPRINTER(cx, &sprinter, &lifoAlloc, 0);
71700: 
76358:     fprintf(stdout, "--- SCRIPT %s:%d ---\n", script->filename, script->lineno);
71700:     js_Disassemble(cx, script, true, &sprinter);
76892:     fputs(sprinter.base, stdout);
76358:     fprintf(stdout, "--- END SCRIPT %s:%d ---\n", script->filename, script->lineno);
71700: #endif
71700: }
71700: 
82134: extern JS_PUBLIC_API(void)
82134: JS_DumpPCCounts(JSContext *cx, JSScript *script)
82134: {
82134: #if defined(DEBUG)
82134:     JS_ASSERT(script->pcCounters);
82134: 
82134:     LifoAlloc lifoAlloc(1024);
82134:     Sprinter sprinter;
82134:     INIT_SPRINTER(cx, &sprinter, &lifoAlloc, 0);
82134: 
82134:     fprintf(stdout, "--- SCRIPT %s:%d ---\n", script->filename, script->lineno);
82134:     js_DumpPCCounts(cx, script, &sprinter);
82134:     fputs(sprinter.base, stdout);
82134:     fprintf(stdout, "--- END SCRIPT %s:%d ---\n", script->filename, script->lineno);
82134: #endif
82134: }
82134: 
77659: static void
77659: DumpBytecodeScriptCallback(JSContext *cx, void *data, void *thing,
77659:                            JSGCTraceKind traceKind, size_t thingSize)
77659: {
77659:     JS_ASSERT(traceKind == JSTRACE_SCRIPT);
77659:     JS_ASSERT(!data);
77659:     JSScript *script = static_cast<JSScript *>(thing);
77659:     JS_DumpBytecode(cx, script);
77659: }
77659: 
71700: JS_PUBLIC_API(void)
76358: JS_DumpCompartmentBytecode(JSContext *cx)
71700: {
77659:     IterateCells(cx, cx->compartment, gc::FINALIZE_SCRIPT, NULL, DumpBytecodeScriptCallback);
71700: }
79734: 
82134: static void
82134: DumpPCCountsScriptCallback(JSContext *cx, void *data, void *thing,
82134:                            JSGCTraceKind traceKind, size_t thingSize)
82134: {
82134:     JS_ASSERT(traceKind == JSTRACE_SCRIPT);
82134:     JS_ASSERT(!data);
82134:     JSScript *script = static_cast<JSScript *>(thing);
82134:     if (script->pcCounters)
82134:         JS_DumpPCCounts(cx, script);
82134: }
82134: 
82134: JS_PUBLIC_API(void)
82134: JS_DumpCompartmentPCCounts(JSContext *cx)
82134: {
82134:     IterateCells(cx, cx->compartment, gc::FINALIZE_SCRIPT, NULL, DumpPCCountsScriptCallback);
82134: }
82134: 
79734: JS_PUBLIC_API(JSObject *)
79734: JS_UnwrapObject(JSObject *obj)
79734: {
79734:     return UnwrapObject(obj);
79734: }
