 42877: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 42402: 
104368: #include "ipc/AutoOpenSurface.h"
 72995: #include "mozilla/layers/PLayers.h"
 72995: #include "mozilla/layers/ShadowLayers.h"
 72995: 
 55453: #include "gfxSharedImageSurface.h"
 55453: 
 42402: #include "CanvasLayerOGL.h"
 42402: 
 42402: #include "gfxImageSurface.h"
 42402: #include "gfxContext.h"
 46144: #include "GLContextProvider.h"
 81280: #include "gfxPlatform.h"
 42402: 
 42402: #ifdef XP_WIN
 42402: #include "gfxWindowsSurface.h"
 42402: #include "WGLLibrary.h"
 42402: #endif
 42402: 
 42402: #ifdef XP_MACOSX
 42402: #include <OpenGL/OpenGL.h>
 42402: #endif
 42402: 
 69106: #ifdef MOZ_X11
 69106: #include "gfxXlibSurface.h"
 69106: #endif
 69106: 
 42402: using namespace mozilla;
 42402: using namespace mozilla::layers;
 42402: using namespace mozilla::gl;
 42402: 
104652: static void
104652: MakeTextureIfNeeded(GLContext* gl, GLuint& aTexture)
104652: {
104652:   if (aTexture != 0)
104652:     return;
104652: 
104652:   gl->fGenTextures(1, &aTexture);
104652: 
104652:   gl->fActiveTexture(LOCAL_GL_TEXTURE0);
104652:   gl->fBindTexture(LOCAL_GL_TEXTURE_2D, aTexture);
104652: 
104652:   gl->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER, LOCAL_GL_LINEAR);
104652:   gl->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER, LOCAL_GL_LINEAR);
104652:   gl->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S, LOCAL_GL_CLAMP_TO_EDGE);
104652:   gl->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T, LOCAL_GL_CLAMP_TO_EDGE);
104652: }
104652: 
 49072: void
 49072: CanvasLayerOGL::Destroy()
 42402: {
 49072:   if (!mDestroyed) {
 87402:     CleanupResources();
 80486:     mDestroyed = true;
 42402:   }
 43775: }
 42402: 
 42402: void
 42402: CanvasLayerOGL::Initialize(const Data& aData)
 42402: {
 42791:   NS_ASSERTION(mCanvasSurface == nsnull, "BasicCanvasLayer::Initialize called twice!");
 42402: 
 47909:   if (aData.mGLContext != nsnull &&
 47909:       aData.mSurface != nsnull)
 47909:   {
 47909:     NS_WARNING("CanvasLayerOGL can't have both surface and GLContext");
 47909:     return;
 47909:   }
 47909: 
 67634:   mOGLManager->MakeCurrent();
 67634: 
 81280:   if (aData.mDrawTarget) {
 81280:     mDrawTarget = aData.mDrawTarget;
106547:     mCanvasSurface = gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(mDrawTarget);
 81280:     mNeedsYFlip = false;
 81280:   } else if (aData.mSurface) {
 42791:     mCanvasSurface = aData.mSurface;
 80486:     mNeedsYFlip = false;
 67634: #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
 74902:     if (aData.mSurface->GetType() == gfxASurface::SurfaceTypeXlib) {
 74902:         gfxXlibSurface *xsurf = static_cast<gfxXlibSurface*>(aData.mSurface);
 74902:         mPixmap = xsurf->GetGLXPixmap();
 67634:         if (mPixmap) {
 67634:             if (aData.mSurface->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA) {
 67634:                 mLayerProgram = gl::RGBALayerProgramType;
 67634:             } else {
 67634:                 mLayerProgram = gl::RGBXLayerProgramType;
 67634:             }
104652:             MakeTextureIfNeeded(gl(), mTexture);
 67634:         }
 74902:     }
 67634: #endif
 42402:   } else if (aData.mGLContext) {
 47909:     if (!aData.mGLContext->IsOffscreen()) {
 47909:       NS_WARNING("CanvasLayerOGL with a non-offscreen GL context given");
 42402:       return;
 42402:     }
 42402: 
 42791:     mCanvasGLContext = aData.mGLContext;
 42402:     mGLBufferIsPremultiplied = aData.mGLBufferIsPremultiplied;
 47909: 
 94110:     mNeedsYFlip = mCanvasGLContext->GetOffscreenTexture() != 0;
 42402:   } else {
 42402:     NS_WARNING("CanvasLayerOGL::Initialize called without surface or GL context!");
 42402:     return;
 42402:   }
 42402: 
 42402:   mBounds.SetRect(0, 0, aData.mSize.width, aData.mSize.height);
 59435:       
 59435:   // Check the maximum texture size supported by GL. glTexImage2D supports
 59435:   // images of up to 2 + GL_MAX_TEXTURE_SIZE
 59435:   GLint texSize = gl()->GetMaxTextureSize();
 59435:   if (mBounds.width > (2 + texSize) || mBounds.height > (2 + texSize)) {
 80486:     mDelayedUpdates = true;
104652:     MakeTextureIfNeeded(gl(), mTexture);
 59435:     // This should only ever occur with 2d canvas, WebGL can't already have a texture
 59435:     // of this size can it?
 81280:     NS_ABORT_IF_FALSE(mCanvasSurface || mDrawTarget, 
 59435:                       "Invalid texture size when WebGL surface already exists at that size?");
 59435:   }
 42402: }
 42402: 
 85045: /**
 85045:  * Following UpdateSurface(), mTexture on context this->gl() should contain the data we want,
 85045:  * unless mDelayedUpdates is true because of a too-large surface.
 85045:  */
 47909: void
 64540: CanvasLayerOGL::UpdateSurface()
 42402: {
 64540:   if (!mDirty)
 64540:     return;
 80486:   mDirty = false;
 64540: 
 59435:   if (mDestroyed || mDelayedUpdates) {
 49072:     return;
 49072:   }
 49072: 
 67634: #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
 67634:   if (mPixmap) {
 67634:     return;
 67634:   }
 67634: #endif
 67634: 
 49079:   if (mCanvasGLContext &&
 49079:       mCanvasGLContext->GetContextType() == gl()->GetContextType())
 49079:   {
 94020:     DiscardTempSurface();
 94020: 
 85045:     // Can texture share, just make sure it's resolved first
 85045:     mCanvasGLContext->MakeCurrent();
 85045:     mCanvasGLContext->GuaranteeResolve();
 85045: 
 47909:     if (gl()->BindOffscreenNeedsTexture(mCanvasGLContext) &&
 47909:         mTexture == 0)
 47909:     {
 85045:       mOGLManager->MakeCurrent();
104652:       MakeTextureIfNeeded(gl(), mTexture);
 46144:     }
 49079:   } else {
 59438:     nsRefPtr<gfxASurface> updatedAreaSurface;
 94020: 
106547:     if (mCanvasSurface) {
 59438:       updatedAreaSurface = mCanvasSurface;
 49079:     } else if (mCanvasGLContext) {
 94020:       gfxIntSize size(mBounds.width, mBounds.height);
 59438:       nsRefPtr<gfxImageSurface> updatedAreaImageSurface =
 94020:         GetTempSurface(size, gfxASurface::ImageFormatARGB32);
 94020: 
 64540:       mCanvasGLContext->ReadPixelsIntoImageSurface(0, 0,
 64540:                                                    mBounds.width,
 64540:                                                    mBounds.height,
 49079:                                                    updatedAreaImageSurface);
 94020: 
 59438:       updatedAreaSurface = updatedAreaImageSurface;
 49079:     }
 42402: 
 85045:     mOGLManager->MakeCurrent();
 94020:     mLayerProgram = gl()->UploadSurfaceToTexture(updatedAreaSurface,
 64540:                                                  mBounds,
 59438:                                                  mTexture,
 59438:                                                  false,
 64540:                                                  nsIntPoint(0, 0));
 42402:   }
 42402: }
 42402: 
 42402: void
 42593: CanvasLayerOGL::RenderLayer(int aPreviousDestination,
 57097:                             const nsIntPoint& aOffset)
 42402: {
 64540:   UpdateSurface();
 64541:   FireDidTransactionCallback();
 64540: 
 42791:   mOGLManager->MakeCurrent();
 42402: 
 42402:   // XXX We're going to need a different program depending on if
 42402:   // mGLBufferIsPremultiplied is TRUE or not.  The RGBLayerProgram
 42402:   // assumes that it's true.
 42403: 
 42791:   gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
 47909: 
 47909:   if (mTexture) {
 42791:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
 47909:   }
 42402: 
 97428:   ShaderProgramOGL *program = nsnull;
 59438: 
 49079:   bool useGLContext = mCanvasGLContext &&
 49079:     mCanvasGLContext->GetContextType() == gl()->GetContextType();
 49079: 
 59435:   nsIntRect drawRect = mBounds;
 59435: 
 49079:   if (useGLContext) {
 47909:     gl()->BindTex2DOffscreen(mCanvasGLContext);
 97446:     program = mOGLManager->GetBasicLayerProgram(CanUseOpaqueSurface(),
 97446:                                                 true,
 97446:                                                 GetMaskLayer() ? Mask2d : MaskNone);
 59435:   } else if (mDelayedUpdates) {
 87418:     NS_ABORT_IF_FALSE(mCanvasSurface || mDrawTarget, "WebGL canvases should always be using full texture upload");
 59435:     
 59435:     drawRect.IntersectRect(drawRect, GetEffectiveVisibleRegion().GetBounds());
 59435: 
 59438:     mLayerProgram =
106547:       gl()->UploadSurfaceToTexture(mCanvasSurface,
 62567:                                    nsIntRect(0, 0, drawRect.width, drawRect.height),
 59438:                                    mTexture,
 62567:                                    true,
 62567:                                    drawRect.TopLeft());
 42402:   }
 85045: 
 59438:   if (!program) {
 97446:     program = mOGLManager->GetProgram(mLayerProgram, GetMaskLayer());
 59438:   }
 42402: 
 67634: #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
 67634:   if (mPixmap && !mDelayedUpdates) {
 67634:     sGLXLibrary.BindTexImage(mPixmap);
 67634:   }
 67634: #endif
 67634: 
 80477:   gl()->ApplyFilterToBoundTexture(mFilter);
 80477: 
 42791:   program->Activate();
 59435:   program->SetLayerQuadRect(drawRect);
 57097:   program->SetLayerTransform(GetEffectiveTransform());
 57097:   program->SetLayerOpacity(GetEffectiveOpacity());
 42791:   program->SetRenderOffset(aOffset);
 42791:   program->SetTextureUnit(0);
 97446:   program->LoadMask(GetMaskLayer());
 42402: 
 92920:   if (gl()->CanUploadNonPowerOfTwo()) {
 42791:     mOGLManager->BindAndDrawQuad(program, mNeedsYFlip ? true : false);
 92920:   } else {
 92920:     mOGLManager->BindAndDrawQuadWithTextureRect(program, drawRect, drawRect.Size());
 92920:   }
 42402: 
 67634: #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
 67634:   if (mPixmap && !mDelayedUpdates) {
 67634:     sGLXLibrary.ReleaseTexImage(mPixmap);
 67634:   }
 67634: #endif
 67634: 
 49079:   if (useGLContext) {
 47909:     gl()->UnbindTex2DOffscreen(mCanvasGLContext);
 43775:   }
 42402: }
 55453: 
 87402: void
 87402: CanvasLayerOGL::CleanupResources()
 87402: {
 87402:   if (mTexture) {
 93768:     gl()->MakeCurrent();
 93768:     gl()->fDeleteTextures(1, &mTexture);
 87402:   }
 87402: }
 87402: 
104652: static bool
104652: IsValidSharedTexDescriptor(const SurfaceDescriptor& aDescriptor)
104652: {
104652:   return aDescriptor.type() == SurfaceDescriptor::TSharedTextureDescriptor;
104652: }
 55453: 
 55453: ShadowCanvasLayerOGL::ShadowCanvasLayerOGL(LayerManagerOGL* aManager)
 55453:   : ShadowCanvasLayer(aManager, nsnull)
 55453:   , LayerOGL(aManager)
 80486:   , mNeedsYFlip(false)
104652:   , mTexture(0)
 55453: {
 55453:   mImplData = static_cast<LayerOGL*>(this);
 55453: }
 55453:  
 55453: ShadowCanvasLayerOGL::~ShadowCanvasLayerOGL()
 55453: {}
 55453: 
 55453: void
 55453: ShadowCanvasLayerOGL::Initialize(const Data& aData)
 55453: {
 69106:   NS_RUNTIMEABORT("Incompatibe surface type");
 69106: }
 69106: 
 69106: void
 79426: ShadowCanvasLayerOGL::Init(const CanvasSurface& aNewFront, bool needYFlip)
 69106: {
104368:   AutoOpenSurface autoSurf(OPEN_READ_ONLY, aNewFront);
 69106: 
 98144:   mNeedsYFlip = needYFlip;
 98144: 
104368:   mTexImage = gl()->CreateTextureImage(autoSurf.Size(),
104368:                                        autoSurf.ContentType(),
 98144:                                        LOCAL_GL_CLAMP_TO_EDGE,
 98144:                                        mNeedsYFlip ? TextureImage::NeedsYFlip : TextureImage::NoFlags);
 55453: }
 55453: 
 69106: void
 79426: ShadowCanvasLayerOGL::Swap(const CanvasSurface& aNewFront,
 79426:                            bool needYFlip,
 79426:                            CanvasSurface* aNewBack)
 55453: {
104652:   if (mDestroyed) {
104652:     *aNewBack = aNewFront;
104652:     return;
104652:   }
104652: 
104652:   if (IsValidSharedTexDescriptor(aNewFront)) {
104652:     MakeTextureIfNeeded(gl(), mTexture);
104652:     if (!IsValidSharedTexDescriptor(mFrontBufferDescriptor)) {
106178:       mFrontBufferDescriptor = SharedTextureDescriptor(TextureImage::ThreadShared, 0, nsIntSize(0, 0), false);
104652:     }
104652:     *aNewBack = mFrontBufferDescriptor;
104652:     mFrontBufferDescriptor = aNewFront;
104652:     mNeedsYFlip = needYFlip;
104652:   } else {
104368:     AutoOpenSurface autoSurf(OPEN_READ_ONLY, aNewFront);
104368:     gfxIntSize sz = autoSurf.Size();
 80708:     if (!mTexImage || mTexImage->GetSize() != sz ||
104368:         mTexImage->GetContentType() != autoSurf.ContentType()) {
 79426:       Init(aNewFront, needYFlip);
 79426:     }
 55453:     nsIntRegion updateRegion(nsIntRect(0, 0, sz.width, sz.height));
104368:     mTexImage->DirectUpdate(autoSurf.Get(), updateRegion);
104652:     *aNewBack = aNewFront;
104112:   }
 55453: }
 55453: 
 55453: void
 55453: ShadowCanvasLayerOGL::DestroyFrontBuffer()
 55453: {
 55453:   mTexImage = nsnull;
104652:   if (mTexture) {
104652:     gl()->MakeCurrent();
104652:     gl()->fDeleteTextures(1, &mTexture);
104652:   }
104652:   if (IsValidSharedTexDescriptor(mFrontBufferDescriptor)) {
104652:     SharedTextureDescriptor texDescriptor = mFrontBufferDescriptor.get_SharedTextureDescriptor();
104652:     gl()->ReleaseSharedHandle(texDescriptor.shareType(), texDescriptor.handle());
104652:     mFrontBufferDescriptor = SurfaceDescriptor();
104652:   }
 55453: }
 55453: 
 55453: void
 60065: ShadowCanvasLayerOGL::Disconnect()
 60065: {
 60065:   Destroy();
 60065: }
 60065: 
 60065: void
 55453: ShadowCanvasLayerOGL::Destroy()
 55453: {
 55453:   if (!mDestroyed) {
 80486:     mDestroyed = true;
104652:     DestroyFrontBuffer();
 55453:   }
 55453: }
 55453: 
 55453: Layer*
 55453: ShadowCanvasLayerOGL::GetLayer()
 55453: {
 55453:   return this;
 55453: }
 55453: 
 55453: void
 55453: ShadowCanvasLayerOGL::RenderLayer(int aPreviousFrameBuffer,
 57097:                                   const nsIntPoint& aOffset)
 55453: {
104652:   if (!mTexImage && !IsValidSharedTexDescriptor(mFrontBufferDescriptor)) {
104368:     return;
104368:   }
104368: 
 55453:   mOGLManager->MakeCurrent();
 55453: 
 80472:   gfx3DMatrix effectiveTransform = GetEffectiveTransform();
104651:   gfxPattern::GraphicsFilter filter = mFilter;
 80472: #ifdef ANDROID
 80472:   // Bug 691354
 80472:   // Using the LINEAR filter we get unexplained artifacts.
 80472:   // Use NEAREST when no scaling is required.
 80472:   gfxMatrix matrix;
 80472:   bool is2D = GetEffectiveTransform().Is2D(&matrix);
 80472:   if (is2D && !matrix.HasNonTranslationOrFlip()) {
104651:     filter = gfxPattern::FILTER_NEAREST;
 80472:   }
 80472: #endif
 80472: 
104652:   ShaderProgramOGL *program;
104652:   if (IsValidSharedTexDescriptor(mFrontBufferDescriptor)) {
104652:     program = mOGLManager->GetBasicLayerProgram(CanUseOpaqueSurface(),
104652:                                                 true,
104652:                                                 GetMaskLayer() ? Mask2d : MaskNone);
104652:   } else {
104652:     program = mOGLManager->GetProgram(mTexImage->GetShaderProgramType(),
104652:                                       GetMaskLayer());
104652:   }
104652: 
 55453:   program->Activate();
 80472:   program->SetLayerTransform(effectiveTransform);
 57097:   program->SetLayerOpacity(GetEffectiveOpacity());
 55453:   program->SetRenderOffset(aOffset);
 55453:   program->SetTextureUnit(0);
 97448:   program->LoadMask(GetMaskLayer());
 55453: 
104652:   if (IsValidSharedTexDescriptor(mFrontBufferDescriptor)) {
104652:     // Shared texture handle rendering path, single texture rendering
104652:     SharedTextureDescriptor texDescriptor = mFrontBufferDescriptor.get_SharedTextureDescriptor();
104652:     gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
104652:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, mTexture);
104652:     if (!gl()->AttachSharedHandle(texDescriptor.shareType(), texDescriptor.handle())) {
104652:       NS_ERROR("Failed to attach shared texture handle");
104652:       return;
104652:     }
104652:     gl()->ApplyFilterToBoundTexture(filter);
104652:     program->SetLayerQuadRect(nsIntRect(nsIntPoint(0, 0), texDescriptor.size()));
104652:     mOGLManager->BindAndDrawQuad(program, mNeedsYFlip);
104652:     gl()->DetachSharedHandle(texDescriptor.shareType(), texDescriptor.handle());
104652:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, 0);
104652:   } else {
104652:     // Tiled texture image rendering path
104651:     mTexImage->SetFilter(filter);
 73465:     mTexImage->BeginTileIteration();
 92920:     if (gl()->CanUploadNonPowerOfTwo()) {
 73465:       do {
 79815:         TextureImage::ScopedBindTextureAndApplyFilter texBind(mTexImage, LOCAL_GL_TEXTURE0);
 73465:         program->SetLayerQuadRect(mTexImage->GetTileRect());
 73465:         mOGLManager->BindAndDrawQuad(program, mNeedsYFlip); // FIXME flip order of tiles?
 73465:       } while (mTexImage->NextTile());
 92920:     } else {
 92920:       do {
 92920:         TextureImage::ScopedBindTextureAndApplyFilter texBind(mTexImage, LOCAL_GL_TEXTURE0);
 92920:         program->SetLayerQuadRect(mTexImage->GetTileRect());
 92920:         // We can't use BindAndDrawQuad because that always uploads the whole texture from 0.0f -> 1.0f
 92920:         // in x and y. We use BindAndDrawQuadWithTextureRect to actually draw a subrect of the texture
 92920:         // We need to reset the origin to 0,0 from the tile rect because the tile originates at 0,0 in the
 92920:         // actual texture, even though its origin in the composed (tiled) texture is not 0,0
 92920:         // FIXME: we need to handle mNeedsYFlip, Bug #728625
 92920:         mOGLManager->BindAndDrawQuadWithTextureRect(program,
 92920:                                                     nsIntRect(0, 0, mTexImage->GetTileRect().width,
 92920:                                                                     mTexImage->GetTileRect().height),
 93025:                                                     mTexImage->GetTileRect().Size(),
 93025:                                                     mTexImage->GetWrapMode(),
 93025:                                                     mNeedsYFlip);
 92920:       } while (mTexImage->NextTile());
 92920:     }
 55453:   }
104652: }
 87402: 
 87402: void
 87402: ShadowCanvasLayerOGL::CleanupResources()
 87402: {
 87402:   DestroyFrontBuffer();
 87402: }
