 84764: /* -*- Mode: javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 84764: /* vim: set ts=2 et sw=2 tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 84764: "use strict";
 84764: 
 84764: const Cc = Components.classes;
 84764: const Ci = Components.interfaces;
 84764: const Cu = Components.utils;
 84764: 
 84764: Cu.import("resource://gre/modules/Services.jsm");
 84764: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 88394: Cu.import("resource:///modules/devtools/LayoutHelpers.jsm");
 84764: 
 84764: let EXPORTED_SYMBOLS = ["TiltUtils"];
 84764: 
 84764: /**
 84764:  * Module containing various helper functions used throughout Tilt.
 84764:  */
 84764: let TiltUtils = {};
 84764: 
 84764: /**
 84764:  * Various console/prompt output functions required by the engine.
 84764:  */
 84764: TiltUtils.Output = {
 84764: 
 84764:   /**
 84764:    * Logs a message to the console.
 84764:    *
 84764:    * @param {String} aMessage
 84764:    *                 the message to be logged
 84764:    */
 84764:   log: function TUO_log(aMessage)
 84764:   {
100193:     if (this.suppressLogs) {
100193:       return;
100193:     }
 84764:     // get the console service
 84764:     let consoleService = Cc["@mozilla.org/consoleservice;1"]
 84764:       .getService(Ci.nsIConsoleService);
 84764: 
 84764:     // log the message
 84764:     consoleService.logStringMessage(aMessage);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Logs an error to the console.
 84764:    *
 84764:    * @param {String} aMessage
 84764:    *                 the message to be logged
 84764:    * @param {Object} aProperties
 84764:    *                 and object containing script error initialization details
 84764:    */
 84764:   error: function TUO_error(aMessage, aProperties)
 84764:   {
100193:     if (this.suppressErrors) {
100193:       return;
100193:     }
 84764:     // make sure the properties parameter is a valid object
 84764:     aProperties = aProperties || {};
 84764: 
 84764:     // get the console service
 84764:     let consoleService = Cc["@mozilla.org/consoleservice;1"]
 84764:       .getService(Ci.nsIConsoleService);
 84764: 
 84764:     // get the script error service
 84764:     let scriptError = Cc["@mozilla.org/scripterror;1"]
 84764:       .createInstance(Ci.nsIScriptError);
 84764: 
 84764:     // initialize a script error
 84764:     scriptError.init(aMessage,
 84764:       aProperties.sourceName || "",
 84764:       aProperties.sourceLine || "",
 84764:       aProperties.lineNumber || 0,
 84764:       aProperties.columnNumber || 0,
 84764:       aProperties.flags || 0,
 84764:       aProperties.category || "");
 84764: 
 84764:     // log the error
 84764:     consoleService.logMessage(scriptError);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Shows a modal alert message popup.
 84764:    *
 84764:    * @param {String} aTitle
 84764:    *                 the title of the popup
 84764:    * @param {String} aMessage
 84764:    *                 the message to be logged
 84764:    */
 84764:   alert: function TUO_alert(aTitle, aMessage)
 84764:   {
100193:     if (this.suppressAlerts) {
100193:       return;
100193:     }
 84764:     if (!aMessage) {
 84764:       aMessage = aTitle;
 84764:       aTitle = "";
 84764:     }
 84764: 
 84764:     // get the prompt service
 84764:     let prompt = Cc["@mozilla.org/embedcomp/prompt-service;1"]
 84764:       .getService(Ci.nsIPromptService);
 84764: 
 84764:     // show the alert message
 84764:     prompt.alert(null, aTitle, aMessage);
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Helper functions for managing preferences.
 84764:  */
 84764: TiltUtils.Preferences = {
 84764: 
 84764:   /**
 84764:    * Gets a custom Tilt preference.
 84764:    * If the preference does not exist, undefined is returned. If it does exist,
 84764:    * but the type is not correctly specified, null is returned.
 84764:    *
 84764:    * @param {String} aPref
 84764:    *                 the preference name
 84764:    * @param {String} aType
 84764:    *                 either "boolean", "string" or "integer"
 84764:    *
 84764:    * @return {Boolean | String | Number} the requested preference
 84764:    */
 84764:   get: function TUP_get(aPref, aType)
 84764:   {
 84764:     if (!aPref || !aType) {
 84764:       return;
 84764:     }
 84764: 
 84764:     try {
 84764:       let prefs = this._branch;
 84764: 
 84764:       switch(aType) {
 84764:         case "boolean":
 84764:           return prefs.getBoolPref(aPref);
 84764:         case "string":
 84764:           return prefs.getCharPref(aPref);
 84764:         case "integer":
 84764:           return prefs.getIntPref(aPref);
 84764:       }
 84764:       return null;
 84764: 
 84764:     } catch(e) {
 84764:       // handle any unexpected exceptions
 84764:       TiltUtils.Output.error(e.message);
 84764:       return undefined;
 84764:     }
 84764:   },
 84764: 
 84764:   /**
 84764:    * Sets a custom Tilt preference.
 84764:    * If the preference already exists, it is overwritten.
 84764:    *
 84764:    * @param {String} aPref
 84764:    *                 the preference name
 84764:    * @param {String} aType
 84764:    *                 either "boolean", "string" or "integer"
 84764:    * @param {String} aValue
 84764:    *                 a new preference value
 84764:    *
 84764:    * @return {Boolean} true if the preference was set successfully
 84764:    */
 84764:   set: function TUP_set(aPref, aType, aValue)
 84764:   {
 84764:     if (!aPref || !aType || aValue === undefined || aValue === null) {
 84764:       return;
 84764:     }
 84764: 
 84764:     try {
 84764:       let prefs = this._branch;
 84764: 
 84764:       switch(aType) {
 84764:         case "boolean":
 84764:           return prefs.setBoolPref(aPref, aValue);
 84764:         case "string":
 84764:           return prefs.setCharPref(aPref, aValue);
 84764:         case "integer":
 84764:           return prefs.setIntPref(aPref, aValue);
 84764:       }
 84764:     } catch(e) {
 84764:       // handle any unexpected exceptions
 84764:       TiltUtils.Output.error(e.message);
 84764:     }
 84764:     return false;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Creates a custom Tilt preference.
 84764:    * If the preference already exists, it is left unchanged.
 84764:    *
 84764:    * @param {String} aPref
 84764:    *                 the preference name
 84764:    * @param {String} aType
 84764:    *                 either "boolean", "string" or "integer"
 84764:    * @param {String} aValue
 84764:    *                 the initial preference value
 84764:    *
 84764:    * @return {Boolean} true if the preference was initialized successfully
 84764:    */
 84764:   create: function TUP_create(aPref, aType, aValue)
 84764:   {
 84764:     if (!aPref || !aType || aValue === undefined || aValue === null) {
 84764:       return;
 84764:     }
 84764: 
 84764:     try {
 84764:       let prefs = this._branch;
 84764: 
 84764:       if (!prefs.prefHasUserValue(aPref)) {
 84764:         switch(aType) {
 84764:           case "boolean":
 84764:             return prefs.setBoolPref(aPref, aValue);
 84764:           case "string":
 84764:             return prefs.setCharPref(aPref, aValue);
 84764:           case "integer":
 84764:             return prefs.setIntPref(aPref, aValue);
 84764:         }
 84764:       }
 84764:     } catch(e) {
 84764:       // handle any unexpected exceptions
 84764:       TiltUtils.Output.error(e.message);
 84764:     }
 84764:     return false;
 84764:   },
 84764: 
 84764:   /**
 84764:    * The preferences branch for this extension.
 84764:    */
 84764:   _branch: (function(aBranch) {
 84764:     return Cc["@mozilla.org/preferences-service;1"]
 84764:       .getService(Ci.nsIPrefService)
 84764:       .getBranch(aBranch);
 84764: 
 84764:   }("devtools.tilt."))
 84764: };
 84764: 
 84764: /**
 84764:  * Easy way to access the string bundle.
 84764:  */
 84764: TiltUtils.L10n = {
 84764: 
 84764:   /**
 84764:    * The string bundle element.
 84764:    */
 84764:   stringBundle: null,
 84764: 
 84764:   /**
 84764:    * Returns a string in the string bundle.
 84764:    * If the string bundle is not found, null is returned.
 84764:    *
 84764:    * @param {String} aName
 84764:    *                 the string name in the bundle
 84764:    *
 84764:    * @return {String} the equivalent string from the bundle
 84764:    */
 84764:   get: function TUL_get(aName)
 84764:   {
 84764:     // check to see if the parent string bundle document element is valid
 84764:     if (!this.stringBundle || !aName) {
 84764:       return null;
 84764:     }
 84764:     return this.stringBundle.GetStringFromName(aName);
 84764:   },
 84764: 
 84764:   /**
 84764:    * Returns a formatted string using the string bundle.
 84764:    * If the string bundle is not found, null is returned.
 84764:    *
 84764:    * @param {String} aName
 84764:    *                 the string name in the bundle
 84764:    * @param {Array} aArgs
 84764:    *                an array of arguments for the formatted string
 84764:    *
 84764:    * @return {String} the equivalent formatted string from the bundle
 84764:    */
 84764:   format: function TUL_format(aName, aArgs)
 84764:   {
 84764:     // check to see if the parent string bundle document element is valid
 84764:     if (!this.stringBundle || !aName || !aArgs) {
 84764:       return null;
 84764:     }
 84764:     return this.stringBundle.formatStringFromName(aName, aArgs, aArgs.length);
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Utilities for accessing and manipulating a document.
 84764:  */
 84764: TiltUtils.DOM = {
 84764: 
 84764:   /**
 84764:    * Current parent node object used when creating canvas elements.
 84764:    */
 84764:   parentNode: null,
 84764: 
 84764:   /**
 84764:    * Helper method, allowing to easily create and manage a canvas element.
 84764:    * If the width and height params are falsy, they default to the parent node
 84764:    * client width and height.
 84764:    *
 84764:    * @param {Document} aParentNode
 84764:    *                   the parent node used to create the canvas
 84764:    *                   if not specified, it will be reused from the cache
 84764:    * @param {Object} aProperties
 84764:    *                 optional, object containing some of the following props:
 84764:    *       {Boolean} focusable
 84764:    *                 optional, true to make the canvas focusable
 84764:    *       {Boolean} append
 84764:    *                 optional, true to append the canvas to the parent node
 84764:    *        {Number} width
 84764:    *                 optional, specifies the width of the canvas
 84764:    *        {Number} height
 84764:    *                 optional, specifies the height of the canvas
 84764:    *        {String} id
 84764:    *                 optional, id for the created canvas element
 84764:    *
 84764:    * @return {HTMLCanvasElement} the newly created canvas element
 84764:    */
 84764:   initCanvas: function TUD_initCanvas(aParentNode, aProperties)
 84764:   {
 84764:     // check to see if the parent node element is valid
 84764:     if (!(aParentNode = aParentNode || this.parentNode)) {
 84764:       return null;
 84764:     }
 84764: 
 84764:     // make sure the properties parameter is a valid object
 84764:     aProperties = aProperties || {};
 84764: 
 84764:     // cache this parent node so that it can be reused
 84764:     this.parentNode = aParentNode;
 84764: 
 84764:     // create the canvas element
 84764:     let canvas = aParentNode.ownerDocument.
 84764:       createElementNS("http://www.w3.org/1999/xhtml", "canvas");
 84764: 
 84764:     let width = aProperties.width || aParentNode.clientWidth;
 84764:     let height = aProperties.height || aParentNode.clientHeight;
 84764:     let id = aProperties.id || null;
 84764: 
 84764:     canvas.setAttribute("style", "min-width: 1px; min-height: 1px;");
 84764:     canvas.setAttribute("width", width);
 84764:     canvas.setAttribute("height", height);
 84764:     canvas.setAttribute("id", id);
 84764: 
 84764:     // the canvas is unfocusable by default, we may require otherwise
 84764:     if (aProperties.focusable) {
 84764:       canvas.setAttribute("tabindex", "1");
 84764:       canvas.style.outline = "none";
 84764:     }
 84764: 
 84764:     // append the canvas element to the current parent node, if specified
 84764:     if (aProperties.append) {
 84764:       aParentNode.appendChild(canvas);
 84764:     }
 84764: 
 84764:     return canvas;
 84764:   },
 84764: 
 84764:   /**
 84764:    * Gets the full webpage dimensions (width and height).
 84764:    *
 84764:    * @param {Window} aContentWindow
 84764:    *                 the content window holding the document
 84764:    *
 84764:    * @return {Object} an object containing the width and height coords
 84764:    */
 84764:   getContentWindowDimensions: function TUD_getContentWindowDimensions(
 84764:     aContentWindow)
 84764:   {
 84764:     return {
 84764:       width: aContentWindow.innerWidth + aContentWindow.scrollMaxX,
 84764:       height: aContentWindow.innerHeight + aContentWindow.scrollMaxY
 84764:     };
 84764:   },
 84764: 
 84764:   /**
 84764:    * Traverses a document object model & calculates useful info for each node.
 84764:    *
 84764:    * @param {Window} aContentWindow
 84764:    *                 the window content holding the document
 84764:    * @param {Object} aProperties
 84764:    *                 optional, an object containing the following properties:
 84764:    *        {Object} invisibleElements
 84764:    *                 elements which should be ignored
 84764:    *        {Number} minSize
 84764:    *                 the minimum dimensions needed for a node to be traversed
 84764:    *        {Number} maxX
 84764:    *                 the maximum left position of an element
 84764:    *        {Number} maxY
 84764:    *                 the maximum top position of an element
 84764:    *
 84764:    * @return {Array} list containing nodes depths, coordinates and local names
 84764:    */
 84764:   traverse: function TUD_traverse(aContentWindow, aProperties)
 84764:   {
 84764:     // make sure the properties parameter is a valid object
 84764:     aProperties = aProperties || {};
 84764: 
 84764:     let aInvisibleElements = aProperties.invisibleElements || {};
 84764:     let aMinSize = aProperties.minSize || -1;
 84764:     let aMaxX = aProperties.maxX || Number.MAX_VALUE;
 84764:     let aMaxY = aProperties.maxY || Number.MAX_VALUE;
 84764: 
 84764:     let nodes = aContentWindow.document.childNodes;
 84764:     let store = { info: [], nodes: [] };
 84764:     let depth = 0;
 84764: 
 84764:     while (nodes.length) {
 84764:       let queue = [];
 84764: 
 84764:       for (let i = 0, len = nodes.length; i < len; i++) {
 84764:         let node = nodes[i];
 84764: 
 84764:         // skip some nodes to avoid visualization meshes that are too bloated
 84764:         let name = node.localName;
 84764:         if (!name || aInvisibleElements[name]) {
 84764:           continue;
 84764:         }
 84764: 
 84764:         // get the x, y, width and height coordinates of the node
 88394:         let coord = LayoutHelpers.getRect(node, aContentWindow);
 84764:         if (!coord) {
 84764:           continue;
 84764:         }
 84764: 
 84764:         // the maximum size slices the traversal where needed
 84764:         if (coord.left > aMaxX || coord.top > aMaxY) {
 84764:           continue;
 84764:         }
 84764: 
 84764:         // use this node only if it actually has visible dimensions
 84764:         if (coord.width > aMinSize && coord.height > aMinSize) {
 84764: 
 84764:           // save the necessary details into a list to be returned later
 84764:           store.info.push({ depth: depth, coord: coord, name: name });
 84764:           store.nodes.push(node);
 84764:         }
 84764: 
 84764:         // prepare the queue array
 84764:         Array.prototype.push.apply(queue, name === "iframe" ?
 84764:                                           node.contentDocument.childNodes :
 84764:                                           node.childNodes);
 84764:       }
 84764:       nodes = queue;
 84764:       depth++;
 84764:     }
 84764: 
 84764:     return store;
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Binds a new owner object to the child functions.
 84764:  * If the new parent is not specified, it will default to the passed scope.
 84764:  *
 84764:  * @param {Object} aScope
 84764:  *                 the object from which all functions will be rebound
 84764:  * @param {String} aRegex
 84764:  *                 a regular expression to identify certain functions
 84764:  * @param {Object} aParent
 84764:  *                 the new parent for the object's functions
 84764:  */
 84764: TiltUtils.bindObjectFunc = function TU_bindObjectFunc(aScope, aRegex, aParent)
 84764: {
 84764:   if (!aScope) {
 84764:     return;
 84764:   }
 84764: 
 84764:   for (let i in aScope) {
 84764:     try {
 84764:       if ("function" === typeof aScope[i] && (aRegex ? i.match(aRegex) : 1)) {
 84764:         aScope[i] = aScope[i].bind(aParent || aScope);
 84764:       }
 84764:     } catch(e) {
 84764:       TiltUtils.Output.error(e);
 84764:     }
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Destroys an object and deletes all members.
 84764:  *
 84764:  * @param {Object} aScope
 84764:  *                 the object from which all children will be destroyed
 84764:  */
 84764: TiltUtils.destroyObject = function TU_destroyObject(aScope)
 84764: {
 84764:   if (!aScope) {
 84764:     return;
 84764:   }
 84764: 
 84764:   // objects in Tilt usually use a function to handle internal destruction
 91042:   if ("function" === typeof aScope._finalize) {
 91042:     aScope._finalize();
 84764:   }
 84764:   for (let i in aScope) {
 84764:     if (aScope.hasOwnProperty(i)) {
 84764:       delete aScope[i];
 84764:     }
 84764:   }
 84764: };
 84764: 
 84764: /**
 84764:  * Retrieve the unique ID of a window object.
 84764:  *
 84764:  * @param {Window} aWindow
 84764:  *                 the window to get the ID from
 84764:  *
 84764:  * @return {Number} the window ID
 84764:  */
 84764: TiltUtils.getWindowId = function TU_getWindowId(aWindow)
 84764: {
 84764:   if (!aWindow) {
 84764:     return;
 84764:   }
 84764: 
 84764:   return aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
 84764:                 .getInterface(Ci.nsIDOMWindowUtils)
 84764:                 .currentInnerWindowID;
 84764: };
 84764: 
 84764: /**
 88192:  * Sets the markup document viewer zoom for the currently selected browser.
 88192:  *
 88395:  * @param {Window} aChromeWindow
 88395:  *                 the top-level browser window
 88395:  *
 88192:  * @param {Number} the zoom ammount
 88192:  */
 88395: TiltUtils.setDocumentZoom = function TU_setDocumentZoom(aChromeWindow, aZoom) {
 88395:   aChromeWindow.gBrowser.selectedBrowser.markupDocumentViewer.fullZoom = aZoom;
 88192: };
 88192: 
 88192: /**
 84764:  * Performs a garbage collection.
 88395:  *
 88395:  * @param {Window} aChromeWindow
 88395:  *                 the top-level browser window
 84764:  */
 88395: TiltUtils.gc = function TU_gc(aChromeWindow)
 84764: {
 88395:   aChromeWindow.QueryInterface(Ci.nsIInterfaceRequestor)
 84764:                .getInterface(Ci.nsIDOMWindowUtils)
 84764:                .garbageCollect();
 84764: };
 84764: 
 84764: /**
 84764:  * Clears the cache and sets all the variables to null.
 84764:  */
 84764: TiltUtils.clearCache = function TU_clearCache()
 84764: {
 84764:   TiltUtils.DOM.parentNode = null;
 84764: };
 84764: 
 84764: // bind the owner object to the necessary functions
 84764: TiltUtils.bindObjectFunc(TiltUtils.Output);
 84764: TiltUtils.bindObjectFunc(TiltUtils.Preferences);
 84764: TiltUtils.bindObjectFunc(TiltUtils.L10n);
 84764: TiltUtils.bindObjectFunc(TiltUtils.DOM);
 84764: 
 84764: // set the necessary string bundle
 84764: XPCOMUtils.defineLazyGetter(TiltUtils.L10n, "stringBundle", function() {
 84764:   return Services.strings.createBundle(
 84764:     "chrome://browser/locale/devtools/tilt.properties");
 84764: });
