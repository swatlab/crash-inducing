    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* 
    1: */
    1: 
    1: #ifndef nsDocLoader_h__
    1: #define nsDocLoader_h__
    1: 
    1: #include "nsIDocumentLoader.h"
    1: #include "nsIWebProgress.h"
    1: #include "nsIWebProgressListener.h"
    1: #include "nsIRequestObserver.h"
    1: #include "nsWeakReference.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsCOMArray.h"
29263: #include "nsVoidArray.h"
    1: #include "nsString.h"
    1: #include "nsIChannel.h"
    1: #include "nsIProgressEventSink.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIChannelEventSink.h"
    1: #include "nsISecurityEventSink.h"
    1: #include "nsISupportsPriority.h"
    1: #include "nsCOMPtr.h"
    1: #include "pldhash.h"
    1: 
    1: struct nsRequestInfo;
29263: struct nsListenerInfo;
    1: 
    1: /****************************************************************************
    1:  * nsDocLoader implementation...
    1:  ****************************************************************************/
    1: 
    1: #define NS_THIS_DOCLOADER_IMPL_CID                    \
54823:  { /* b4ec8387-98aa-4c08-93b6-6d23069c06f2 */         \
54823:      0xb4ec8387,                                      \
54823:      0x98aa,                                          \
54823:      0x4c08,                                          \
54823:      {0x93, 0xb6, 0x6d, 0x23, 0x06, 0x9c, 0x06, 0xf2} \
    1:  }
    1: 
    1: class nsDocLoader : public nsIDocumentLoader, 
    1:                     public nsIRequestObserver,
    1:                     public nsSupportsWeakReference,
    1:                     public nsIProgressEventSink,
    1:                     public nsIWebProgress,
    1:                     public nsIInterfaceRequestor,
    1:                     public nsIChannelEventSink,
    1:                     public nsISecurityEventSink,
    1:                     public nsISupportsPriority
    1: {
    1: public:
    1:     NS_DECLARE_STATIC_IID_ACCESSOR(NS_THIS_DOCLOADER_IMPL_CID)
    1: 
    1:     nsDocLoader();
    1: 
    1:     virtual nsresult Init();
    1: 
    1:     static already_AddRefed<nsDocLoader> GetAsDocLoader(nsISupports* aSupports);
    1:     // Needed to deal with ambiguous inheritance from nsISupports...
    1:     static nsISupports* GetAsSupports(nsDocLoader* aDocLoader) {
 3233:         return static_cast<nsIDocumentLoader*>(aDocLoader);
    1:     }
    1: 
    1:     // Add aDocLoader as a child to the docloader service.
    1:     static nsresult AddDocLoaderAsChildOfRoot(nsDocLoader* aDocLoader);
    1: 
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIDOCUMENTLOADER
    1:     
    1:     // nsIProgressEventSink
    1:     NS_DECL_NSIPROGRESSEVENTSINK
    1: 
    1:     NS_DECL_NSISECURITYEVENTSINK
    1: 
    1:     // nsIRequestObserver methods: (for observing the load group)
    1:     NS_DECL_NSIREQUESTOBSERVER
    1:     NS_DECL_NSIWEBPROGRESS
    1: 
    1:     NS_DECL_NSIINTERFACEREQUESTOR
    1:     NS_DECL_NSICHANNELEVENTSINK
    1:     NS_DECL_NSISUPPORTSPRIORITY
    1: 
    1:     // Implementation specific methods...
    1: 
    1:     // Remove aChild from our childlist.  This nulls out the child's mParent
    1:     // pointer.
    1:     nsresult RemoveChildLoader(nsDocLoader *aChild);
    1:     // Add aChild to our child list.  This will set aChild's mParent pointer to
    1:     // |this|.
    1:     nsresult AddChildLoader(nsDocLoader* aChild);
    1:     nsDocLoader* GetParent() const { return mParent; }
    1: 
    1: protected:
    1:     virtual ~nsDocLoader();
    1: 
    1:     virtual nsresult SetDocLoaderParent(nsDocLoader * aLoader);
    1: 
    1:     PRBool IsBusy();
    1: 
    1:     void Destroy();
    1:     virtual void DestroyChildren();
    1: 
29263:     nsIDocumentLoader* ChildAt(PRInt32 i) {
29263:         return static_cast<nsDocLoader*>(mChildList[i]);
29263:     }
29263: 
29263:     nsIDocumentLoader* SafeChildAt(PRInt32 i) {
29263:         return static_cast<nsDocLoader*>(mChildList.SafeElementAt(i));
29263:     }
29263: 
    1:     void FireOnProgressChange(nsDocLoader* aLoadInitiator,
    1:                               nsIRequest *request,
    1:                               PRInt64 aProgress,
    1:                               PRInt64 aProgressMax,
    1:                               PRInt64 aProgressDelta,
    1:                               PRInt64 aTotalProgress,
    1:                               PRInt64 aMaxTotalProgress);
    1: 
    1:     void FireOnStateChange(nsIWebProgress *aProgress,
    1:                            nsIRequest* request,
    1:                            PRInt32 aStateFlags,
    1:                            nsresult aStatus);
    1: 
    1:     void FireOnStatusChange(nsIWebProgress *aWebProgress,
    1:                             nsIRequest *aRequest,
    1:                             nsresult aStatus,
    1:                             const PRUnichar* aMessage);
    1: 
    1:     void FireOnLocationChange(nsIWebProgress* aWebProgress,
    1:                               nsIRequest* aRequest,
71723:                               nsIURI *aUri);
    1: 
    1:     PRBool RefreshAttempted(nsIWebProgress* aWebProgress,
    1:                             nsIURI *aURI,
    1:                             PRInt32 aDelay,
    1:                             PRBool aSameURI);
    1: 
    1:     // this function is overridden by the docshell, it is provided so that we
    1:     // can pass more information about redirect state (the normal OnStateChange
    1:     // doesn't get the new channel).
    1:     // @param aRedirectFlags The flags being sent to OnStateChange that
    1:     //                       indicate the type of redirect.
    1:     // @param aStateFlags    The channel flags normally sent to OnStateChange.
54823:     virtual void OnRedirectStateChange(nsIChannel* aOldChannel,
    1:                                        nsIChannel* aNewChannel,
    1:                                        PRUint32 aRedirectFlags,
54823:                                        PRUint32 aStateFlags) {}
    1: 
    1:     void doStartDocumentLoad();
    1:     void doStartURLLoad(nsIRequest *request);
    1:     void doStopURLLoad(nsIRequest *request, nsresult aStatus);
    1:     void doStopDocumentLoad(nsIRequest *request, nsresult aStatus);
    1: 
    1:     // Inform a parent docloader that aChild is about to call its onload
    1:     // handler.
    1:     PRBool ChildEnteringOnload(nsIDocumentLoader* aChild) {
    1:         // It's ok if we're already in the list -- we'll just be in there twice
    1:         // and then the RemoveObject calls from ChildDoneWithOnload will remove
    1:         // us.
    1:         return mChildrenInOnload.AppendObject(aChild);
    1:     }
    1: 
    1:     // Inform a parent docloader that aChild is done calling its onload
    1:     // handler.
    1:     void ChildDoneWithOnload(nsIDocumentLoader* aChild) {
    1:         mChildrenInOnload.RemoveObject(aChild);
25008:         DocLoaderIsEmpty(PR_TRUE);
    1:     }        
    1: 
    1: protected:
    1:     // IMPORTANT: The ownership implicit in the following member
    1:     // variables has been explicitly checked and set using nsCOMPtr
    1:     // for owning pointers and raw COM interface pointers for weak
    1:     // (ie, non owning) references. If you add any members to this
    1:     // class, please make the ownership explicit (pinkerton, scc).
    1:   
    1:     nsCOMPtr<nsIRequest>       mDocumentRequest;       // [OWNER] ???compare with document
    1: 
    1:     nsDocLoader*               mParent;                // [WEAK]
    1: 
29263:     nsVoidArray                mListenerInfoList;
    1: 
    1:     nsCOMPtr<nsILoadGroup>        mLoadGroup;
    1:     // We hold weak refs to all our kids
29263:     nsVoidArray                   mChildList;
    1: 
    1:     // The following member variables are related to the new nsIWebProgress 
    1:     // feedback interfaces that travis cooked up.
    1:     PRInt32 mProgressStateFlags;
    1: 
64617:     PRInt64 mCurrentSelfProgress;
64617:     PRInt64 mMaxSelfProgress;
    1: 
64617:     PRInt64 mCurrentTotalProgress;
64617:     PRInt64 mMaxTotalProgress;
    1: 
    1:     PLDHashTable mRequestInfoHash;
64617:     PRInt64 mCompletedTotalProgress;
    1: 
25008:     /*
25008:      * This flag indicates that the loader is loading a document.  It is set
25008:      * from the call to LoadDocument(...) until the OnConnectionsComplete(...)
25008:      * notification is fired...
25008:      */
25008:     PRPackedBool mIsLoadingDocument;
25008: 
    1:     /* Flag to indicate that we're in the process of restoring a document. */
25008:     PRPackedBool mIsRestoringDocument;
25008: 
25008:     /* Flag to indicate that we're in the process of flushing layout
40679:        under DocLoaderIsEmpty() and should not do another flush. */
40679:     PRPackedBool mDontFlushLayout;
40679: 
40679:     /* Flag to indicate whether we should consider ourselves as currently
40679:        flushing layout for the purposes of IsBusy. For example, if Stop has
40679:        been called then IsBusy should return false even if we are still
40679:        flushing. */
25008:     PRPackedBool mIsFlushingLayout;
    1: 
    1: private:
    1:     // A list of kids that are in the middle of their onload calls and will let
    1:     // us know once they're done.  We don't want to fire onload for "normal"
    1:     // DocLoaderIsEmpty calls (those coming from requests finishing in our
    1:     // loadgroup) unless this is empty.
    1:     nsCOMArray<nsIDocumentLoader> mChildrenInOnload;
    1:     
    1:     // DocLoaderIsEmpty should be called whenever the docloader may be empty.
    1:     // This method is idempotent and does nothing if the docloader is not in
25008:     // fact empty.  This method _does_ make sure that layout is flushed if our
25008:     // loadgroup has no active requests before checking for "real" emptiness if
25008:     // aFlushLayout is true.
25008:     void DocLoaderIsEmpty(PRBool aFlushLayout);
    1: 
29263:     nsListenerInfo *GetListenerInfo(nsIWebProgressListener* aListener);
29263: 
    1:     PRInt64 GetMaxTotalProgress();
    1: 
    1:     nsresult AddRequestInfo(nsIRequest* aRequest);
27070:     void RemoveRequestInfo(nsIRequest* aRequest);
    1:     nsRequestInfo *GetRequestInfo(nsIRequest* aRequest);
    1:     void ClearRequestInfoHash();
    1:     PRInt64 CalculateMaxProgress();
    1: ///    void DumpChannelInfo(void);
    1: 
    1:     // used to clear our internal progress state between loads...
    1:     void ClearInternalProgress(); 
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(nsDocLoader, NS_THIS_DOCLOADER_IMPL_CID)
    1: 
    1: #endif /* nsDocLoader_h__ */
