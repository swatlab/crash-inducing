   1: //* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Url Classifier code
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Google Inc.
   1:  * Portions created by the Initial Developer are Copyright (C) 2006
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Tony Chang <tony@ponderer.org> (original author)
   1:  *   Brett Wilson <brettw@gmail.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "mozIStorageService.h"
   1: #include "mozIStorageConnection.h"
   1: #include "mozIStorageStatement.h"
   1: #include "mozStorageCID.h"
   1: #include "nsAppDirectoryServiceDefs.h"
   1: #include "nsAutoLock.h"
   1: #include "nsCOMPtr.h"
   1: #include "nsCRT.h"
   1: #include "nsIDirectoryService.h"
   1: #include "nsIObserverService.h"
   1: #include "nsIProperties.h"
   1: #include "nsIProxyObjectManager.h"
   1: #include "nsToolkitCompsCID.h"
   1: #include "nsUrlClassifierDBService.h"
   1: #include "nsString.h"
   1: #include "nsTArray.h"
   1: #include "nsThreadUtils.h"
   1: #include "nsXPCOMStrings.h"
   1: #include "prlog.h"
   1: #include "prprf.h"
   1: 
   1: // NSPR_LOG_MODULES=UrlClassifierDbService:5
   1: #if defined(PR_LOGGING)
   1: static const PRLogModuleInfo *gUrlClassifierDbServiceLog = nsnull;
   1: #define LOG(args) PR_LOG(gUrlClassifierDbServiceLog, PR_LOG_DEBUG, args)
   1: #else
   1: #define LOG(args)
   1: #endif
   1: 
   1: // Change filename each time we change the db schema.
   1: #define DATABASE_FILENAME "urlclassifier2.sqlite"
   1: 
   1: // Singleton instance.
   1: static nsUrlClassifierDBService* sUrlClassifierDBService;
   1: 
   1: // Thread that we do the updates on.
   1: static nsIThread* gDbBackgroundThread = nsnull;
   1: 
 762: // Once we've committed to shutting down, don't do work in the background
 762: // thread.
 762: static PRBool gShuttingDownThread = PR_FALSE;
 762: 
   1: static const char* kNEW_TABLE_SUFFIX = "_new";
   1: 
   1: // This maps A-M to N-Z and N-Z to A-M.  All other characters are left alone.
   1: // Copied from mailnews/mime/src/mimetext.cpp
   1: static const unsigned char kRot13Table[256] = {
   1:   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
   1:   21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
   1:   40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
   1:   59, 60, 61, 62, 63, 64, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
   1:   65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 91, 92, 93, 94, 95, 96,
   1:   110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 97, 98,
   1:   99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 123, 124, 125, 126,
   1:   127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141,
   1:   142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156,
   1:   157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
   1:   172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186,
   1:   187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201,
   1:   202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216,
   1:   217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231,
   1:   232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246,
   1:   247, 248, 249, 250, 251, 252, 253, 254, 255 };
   1: 
   1: // Does an in place rotation of the line
   1: static void
   1: Rot13Line(nsCString &line)
   1: {
   1:   nsCString::iterator start, end;
   1:   line.BeginWriting(start);
   1:   line.EndWriting(end);
   1:   while (start != end) {
3233:     *start = kRot13Table[static_cast<PRInt32>(*start)];
   1:     ++start;
   1:   }
   1: }
   1: 
   1: 
   1: // -------------------------------------------------------------------------
   1: // Actual worker implemenatation
   1: class nsUrlClassifierDBServiceWorker : public nsIUrlClassifierDBServiceWorker
   1: {
   1: public:
   1:   nsUrlClassifierDBServiceWorker();
   1: 
   1:   NS_DECL_ISUPPORTS
   1:   NS_DECL_NSIURLCLASSIFIERDBSERVICE
   1:   NS_DECL_NSIURLCLASSIFIERDBSERVICEWORKER
   1: 
   1: private:
   1:   // No subclassing
   1:   ~nsUrlClassifierDBServiceWorker();
   1: 
   1:   // Disallow copy constructor
   1:   nsUrlClassifierDBServiceWorker(nsUrlClassifierDBServiceWorker&);
   1: 
   1:   // Table names have hyphens in them, which SQL doesn't allow,
   1:   // so we convert them to underscores.
   1:   void GetDbTableName(const nsACString& aTableName, nsCString* aDbTableName);
   1: 
   1:   // Try to open the db, DATABASE_FILENAME.
   1:   nsresult OpenDb();
   1: 
   1:   // Create a table in the db if it doesn't exist.
   1:   nsresult MaybeCreateTable(const nsCString& aTableName);
   1: 
   1:   // Drop a table if it exists.
   1:   nsresult MaybeDropTable(const nsCString& aTableName);
   1: 
   1:   // If this is not an update request, swap the new table
   1:   // in for the old table.
   1:   nsresult MaybeSwapTables(const nsCString& aVersionLine);
   1: 
   1:   // Parse a version string of the form [table-name #.###] or
   1:   // [table-name #.### update] and return the table name and
   1:   // whether or not it's an update.
   1:   nsresult ParseVersionString(const nsCSubstring& aLine,
   1:                               nsCString* aTableName,
   1:                               PRBool* aIsUpdate);
   1: 
   1:   // Handle a new table line of the form [table-name #.####].  We create the
   1:   // table if it doesn't exist and set the aTableName, aUpdateStatement,
   1:   // and aDeleteStatement.
   1:   nsresult ProcessNewTable(const nsCSubstring& aLine,
   1:                            nsCString* aTableName,
   1:                            mozIStorageStatement** aUpdateStatement,
   1:                            mozIStorageStatement** aDeleteStatement);
   1: 
   1:   // Handle an add or remove line.  We execute additional update or delete
   1:   // statements.
   1:   nsresult ProcessUpdateTable(const nsCSubstring& aLine,
   1:                               const nsCString& aTableName,
   1:                               mozIStorageStatement* aUpdateStatement,
   1:                               mozIStorageStatement* aDeleteStatement);
   1: 
   1:   // Holds a connection to the Db.  We lazily initialize this because it has
   1:   // to be created in the background thread (currently mozStorageConnection
   1:   // isn't thread safe).
   1:   mozIStorageConnection* mConnection;
   1: 
   1:   // True if we're in the middle of a streaming update.
   1:   PRBool mHasPendingUpdate;
   1: 
   1:   // For incremental updates, keep track of tables that have been updated.
   1:   // When finish() is called, we go ahead and pass these update lines to
   1:   // the callback.
   1:   nsTArray<nsCString> mTableUpdateLines;
   1: 
   1:   // We receive data in small chunks that may be broken in the middle of
   1:   // a line.  So we save the last partial line here.
   1:   nsCString mPendingStreamUpdate;
   1: };
   1: 
   1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsUrlClassifierDBServiceWorker,
   1:                               nsIUrlClassifierDBServiceWorker)
   1: 
   1: nsUrlClassifierDBServiceWorker::nsUrlClassifierDBServiceWorker()
   1:   : mConnection(nsnull), mHasPendingUpdate(PR_FALSE), mTableUpdateLines()
   1: {
   1: }
   1: nsUrlClassifierDBServiceWorker::~nsUrlClassifierDBServiceWorker()
   1: {
   1:   NS_ASSERTION(mConnection == nsnull,
   1:                "Db connection not closed, leaking memory!  Call CloseDb "
   1:                "to close the connection.");
   1: }
   1: 
   1: 
   1: // Lookup a key in the db.
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBServiceWorker::Exists(const nsACString& tableName,
   1:                                        const nsACString& key,
   1:                                        nsIUrlClassifierCallback *c)
   1: {
 762:   if (gShuttingDownThread)
 762:     return NS_ERROR_NOT_INITIALIZED;
 762: 
   1:   nsresult rv = OpenDb();
   1:   if (NS_FAILED(rv)) {
   1:     NS_ERROR("Unable to open database");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCAutoString dbTableName;
   1:   GetDbTableName(tableName, &dbTableName);
   1: 
   1:   nsCOMPtr<mozIStorageStatement> selectStatement;
   1:   nsCAutoString statement;
   1:   statement.AssignLiteral("SELECT value FROM ");
   1:   statement.Append(dbTableName);
   1:   statement.AppendLiteral(" WHERE key = ?1");
   1: 
   1:   rv = mConnection->CreateStatement(statement,
   1:                                     getter_AddRefs(selectStatement));
   1: 
   1:   nsAutoString value;
   1:   // If CreateStatment failed, this probably means the table doesn't exist.
   1:   // That's ok, we just return an emptry string.
   1:   if (NS_SUCCEEDED(rv)) {
   1:     nsCString keyROT13(key);
   1:     Rot13Line(keyROT13);
   1:     rv = selectStatement->BindUTF8StringParameter(0, keyROT13);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     PRBool hasMore = PR_FALSE;
   1:     rv = selectStatement->ExecuteStep(&hasMore);
   1:     // If the table has any columns, take the first value.
   1:     if (NS_SUCCEEDED(rv) && hasMore) {
   1:       selectStatement->GetString(0, value);
   1:     }
   1:   }
   1: 
   1:   c->HandleEvent(NS_ConvertUTF16toUTF8(value));
   1:   return NS_OK;
   1: }
   1: 
   1: // We get a comma separated list of table names.  For each table that doesn't
   1: // exist, we return it in a comma separated list via the callback.
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBServiceWorker::CheckTables(const nsACString & tableNames,
   1:                                             nsIUrlClassifierCallback *c)
   1: {
 762:   if (gShuttingDownThread)
 762:     return NS_ERROR_NOT_INITIALIZED;
 762: 
   1:   nsresult rv = OpenDb();
   1:   if (NS_FAILED(rv)) {
   1:     NS_ERROR("Unable to open database");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCAutoString changedTables;
   1: 
   1:   // tablesNames is a comma separated list, so get each table name out for
   1:   // checking.
   1:   PRUint32 cur = 0;
   1:   PRInt32 next;
   1:   while (cur < tableNames.Length()) {
   1:     next = tableNames.FindChar(',', cur);
   1:     if (kNotFound == next) {
   1:       next = tableNames.Length();
   1:     }
   1:     const nsCSubstring &tableName = Substring(tableNames, cur, next - cur);
   1:     cur = next + 1;
   1: 
   1:     nsCString dbTableName;
   1:     GetDbTableName(tableName, &dbTableName);
   1:     PRBool exists;
   1:     nsresult rv = mConnection->TableExists(dbTableName, &exists);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     if (!exists) {
   1:       if (changedTables.Length() > 0)
   1:         changedTables.Append(",");
   1:       changedTables.Append(tableName);
   1:     }
   1:   }
   1: 
   1:   c->HandleEvent(changedTables);
   1:   return NS_OK;
   1: }
   1: 
   1: // Do a batch update of the database.  After we complete processing a table,
   1: // we call the callback with the table line.
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBServiceWorker::UpdateTables(const nsACString& updateString,
   1:                                              nsIUrlClassifierCallback *c)
   1: {
 762:   if (gShuttingDownThread)
 762:     return NS_ERROR_NOT_INITIALIZED;
 762: 
   1:   LOG(("Updating tables\n"));
   1: 
   1:   nsresult rv = OpenDb();
   1:   if (NS_FAILED(rv)) {
   1:     NS_ERROR("Unable to open database");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   rv = mConnection->BeginTransaction();
   1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Unable to begin transaction");
   1: 
   1:   // Split the update string into lines
   1:   PRUint32 cur = 0;
   1:   PRInt32 next;
   1:   PRInt32 count = 0;
   1:   nsCAutoString dbTableName;
   1:   nsCAutoString lastTableLine;
   1:   nsCOMPtr<mozIStorageStatement> updateStatement;
   1:   nsCOMPtr<mozIStorageStatement> deleteStatement;
   1:   while(cur < updateString.Length() &&
   1:         (next = updateString.FindChar('\n', cur)) != kNotFound) {
   1:     const nsCSubstring &line = Substring(updateString, cur, next - cur);
   1:     cur = next + 1; // prepare for next run
   1: 
   1:     // Skip blank lines
   1:     if (line.Length() == 0)
   1:       continue;
   1: 
   1:     count++;
   1: 
   1:     if ('[' == line[0]) {
   1:       rv = ProcessNewTable(line, &dbTableName,
   1:                            getter_AddRefs(updateStatement),
   1:                            getter_AddRefs(deleteStatement));
   1:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "malformed table line");
   1:       if (NS_SUCCEEDED(rv)) {
   1:         // If it's a new table, we may have completed a table.
   1:         // Go ahead and post the completion to the UI thread and db.
   1:         if (lastTableLine.Length() > 0) {
   1:           // If it was a new table, we need to swap in the new table.
   1:           rv = MaybeSwapTables(lastTableLine);
   1:           if (NS_SUCCEEDED(rv)) {
   1:             mConnection->CommitTransaction();
   1:             c->HandleEvent(lastTableLine);
   1:           } else {
   1:             // failed to swap, rollback
   1:             mConnection->RollbackTransaction();
   1:           }
   1:           mConnection->BeginTransaction();
   1:         }
   1:         lastTableLine.Assign(line);
   1:       }
   1:     } else {
   1:       rv = ProcessUpdateTable(line, dbTableName, updateStatement,
   1:                               deleteStatement);
   1:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "malformed update line");
   1:     }
   1:   }
   1:   LOG(("Num update lines: %d\n", count));
   1: 
   1:   rv = MaybeSwapTables(lastTableLine);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     mConnection->CommitTransaction();
   1:     c->HandleEvent(lastTableLine);
   1:   } else {
   1:     // failed to swap, rollback
   1:     mConnection->RollbackTransaction();
   1:   }
   1: 
   1:   LOG(("Finishing table update\n"));
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBServiceWorker::Update(const nsACString& chunk)
   1: {
   1:   LOG(("Update from Stream."));
   1:   nsresult rv = OpenDb();
   1:   if (NS_FAILED(rv)) {
   1:     NS_ERROR("Unable to open database");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1: 
   1:   nsCAutoString updateString(mPendingStreamUpdate);
   1:   updateString.Append(chunk);
   1:   
   1:   nsCOMPtr<mozIStorageStatement> updateStatement;
   1:   nsCOMPtr<mozIStorageStatement> deleteStatement;
   1:   nsCAutoString dbTableName;
   1: 
   1:   // If we're not in the middle of an update, we start a new transaction.
   1:   // Otherwise, we need to pick up where we left off.
   1:   if (!mHasPendingUpdate) {
   1:     mConnection->BeginTransaction();
   1:     mHasPendingUpdate = PR_TRUE;
   1:   } else {
   1:     PRUint32 numTables = mTableUpdateLines.Length();
   1:     if (numTables > 0) {
   1:       const nsCSubstring &line = Substring(
   1:               mTableUpdateLines[numTables - 1], 0);
   1: 
   1:       rv = ProcessNewTable(line, &dbTableName,
   1:                            getter_AddRefs(updateStatement),
   1:                            getter_AddRefs(deleteStatement));
   1:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "malformed table line");
   1:     }
   1:   }
   1: 
   1:   PRUint32 cur = 0;
   1:   PRInt32 next;
   1:   while(cur < updateString.Length() &&
   1:         (next = updateString.FindChar('\n', cur)) != kNotFound) {
   1:     const nsCSubstring &line = Substring(updateString, cur, next - cur);
   1:     cur = next + 1; // prepare for next run
   1: 
   1:     // Skip blank lines
   1:     if (line.Length() == 0)
   1:       continue;
   1: 
   1:     if ('[' == line[0]) {
   1:       rv = ProcessNewTable(line, &dbTableName,
   1:                            getter_AddRefs(updateStatement),
   1:                            getter_AddRefs(deleteStatement));
   1:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "malformed table line");
   1:       if (NS_SUCCEEDED(rv)) {
   1:         // Add the line to our array of table lines.
   1:         mTableUpdateLines.AppendElement(line);
   1:       }
   1:     } else {
   1:       rv = ProcessUpdateTable(line, dbTableName, updateStatement,
   1:                               deleteStatement);
   1:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "malformed update line");
   1:     }
   1:   }
   1:   // Save the remaining string fragment.
   1:   mPendingStreamUpdate = Substring(updateString, cur);
   1:   LOG(("pending stream update: %s", mPendingStreamUpdate.get()));
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBServiceWorker::Finish(nsIUrlClassifierCallback *c)
   1: {
   1:   if (!mHasPendingUpdate)
   1:     return NS_OK;
   1: 
 762:   if (gShuttingDownThread) {
 762:     mConnection->RollbackTransaction();
 762:     return NS_ERROR_NOT_INITIALIZED;
 762:   }
 762: 
   1:   nsresult rv = NS_OK;
   1:   for (PRUint32 i = 0; i < mTableUpdateLines.Length(); ++i) {
   1:     rv = MaybeSwapTables(mTableUpdateLines[i]);
   1:     if (NS_FAILED(rv)) {
   1:       break;
   1:     }
   1:   }
   1:   
   1:   if (NS_SUCCEEDED(rv)) {
   1:     LOG(("Finish, committing transaction"));
   1:     mConnection->CommitTransaction();
   1: 
   1:     // Send update information to main thread.
   1:     for (PRUint32 i = 0; i < mTableUpdateLines.Length(); ++i) {
   1:       c->HandleEvent(mTableUpdateLines[i]);
   1:     }
   1:   } else {
   1:     LOG(("Finish failed (swap table error?), rolling back transaction"));
   1:     mConnection->RollbackTransaction();
   1:   }
   1: 
   1:   mTableUpdateLines.Clear();
   1:   mPendingStreamUpdate.Truncate();
   1:   mHasPendingUpdate = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBServiceWorker::CancelStream()
   1: {
   1:   if (!mHasPendingUpdate)
   1:     return NS_OK;
   1: 
   1:   LOG(("CancelStream, rolling back transaction"));
   1:   mConnection->RollbackTransaction();
   1: 
   1:   mTableUpdateLines.Clear();
   1:   mPendingStreamUpdate.Truncate();
   1:   mHasPendingUpdate = PR_FALSE;
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: // Allows the main thread to delete the connection which may be in
   1: // a background thread.
   1: // XXX This could be turned into a single shutdown event so the logic
   1: // is simpler in nsUrlClassifierDBService::Shutdown.
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBServiceWorker::CloseDb()
   1: {
   1:   if (mConnection != nsnull) {
   1:     NS_RELEASE(mConnection);
   1:     LOG(("urlclassifier db closed\n"));
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsUrlClassifierDBServiceWorker::ProcessNewTable(
   1:                                     const nsCSubstring& aLine,
   1:                                     nsCString* aDbTableName,
   1:                                     mozIStorageStatement** aUpdateStatement,
   1:                                     mozIStorageStatement** aDeleteStatement)
   1: {
   1:   // The line format is "[table-name #.####]" or "[table-name #.#### update]"
   1:   // The additional "update" in the header means that this is a diff.
   1:   // Otherwise, we should blow away the old table and start afresh.
   1:   PRBool isUpdate = PR_FALSE;
   1: 
   1:   // If the version string is bad, give up.
   1:   nsresult rv = ParseVersionString(aLine, aDbTableName, &isUpdate);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   
   1:   // If it's not an update, we dump the values into a new table.  Once we're
   1:   // done with the table, we drop the original table and copy over the values
   1:   // from the old table into the new table.
   1:   if (!isUpdate)
   1:     aDbTableName->Append(kNEW_TABLE_SUFFIX);
   1: 
   1:   // Create the table
   1:   rv = MaybeCreateTable(*aDbTableName);
   1:   if (NS_FAILED(rv))
   1:     return rv;
   1: 
   1:   // insert statement
   1:   nsCAutoString statement;
   1:   statement.AssignLiteral("INSERT OR REPLACE INTO ");
   1:   statement.Append(*aDbTableName);
   1:   statement.AppendLiteral(" VALUES (?1, ?2)");
   1:   rv = mConnection->CreateStatement(statement, aUpdateStatement);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // delete statement
   1:   statement.AssignLiteral("DELETE FROM ");
   1:   statement.Append(*aDbTableName);
   1:   statement.AppendLiteral(" WHERE key = ?1");
   1:   rv = mConnection->CreateStatement(statement, aDeleteStatement);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsUrlClassifierDBServiceWorker::ProcessUpdateTable(
   1:                                    const nsCSubstring& aLine,
   1:                                    const nsCString& aTableName,
   1:                                    mozIStorageStatement* aUpdateStatement,
   1:                                    mozIStorageStatement* aDeleteStatement)
   1: {
   1:   // We should have seen a table name line by now.
   1:   if (aTableName.Length() == 0)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   if (!aUpdateStatement || !aDeleteStatement) {
   1:     NS_NOTREACHED("Statements NULL but table is not");
   1:     return NS_ERROR_FAILURE;
   1:   }
   1:   // There should at least be an op char and a key
   1:   if (aLine.Length() < 2)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   char op = aLine[0];
   1:   PRInt32 spacePos = aLine.FindChar('\t');
   1:   nsresult rv = NS_ERROR_FAILURE;
   1: 
   1:   if ('+' == op && spacePos != kNotFound) {
   1:     // Insert operation of the form "+KEY\tVALUE"
   1:     const nsCSubstring &key = Substring(aLine, 1, spacePos - 1);
   1:     const nsCSubstring &value = Substring(aLine, spacePos + 1);
   1: 
   1:     // We use ROT13 versions of keys to avoid antivirus utilities from
   1:     // flagging us as a virus.
   1:     nsCString keyROT13(key);
   1:     Rot13Line(keyROT13);
   1:     
   1:     aUpdateStatement->BindUTF8StringParameter(0, keyROT13);
   1:     aUpdateStatement->BindUTF8StringParameter(1, value);
   1: 
   1:     rv = aUpdateStatement->Execute();
   1:     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Failed to update");
   1:   } else if ('-' == op) {
   1:     // Remove operation of the form "-KEY"
   1:     nsCString keyROT13;
   1:     if (spacePos == kNotFound) {
   1:       // No trailing tab
   1:       const nsCSubstring &key = Substring(aLine, 1);
   1:       keyROT13.Assign(key);
   1:     } else {
   1:       // With trailing tab
   1:       const nsCSubstring &key = Substring(aLine, 1, spacePos - 1);
   1:       keyROT13.Assign(key);
   1:     }
   1:     Rot13Line(keyROT13);
   1:     aDeleteStatement->BindUTF8StringParameter(0, keyROT13);
   1: 
   1:     rv = aDeleteStatement->Execute();
   1:     NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Failed to delete");
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsUrlClassifierDBServiceWorker::OpenDb()
   1: {
   1:   // Connection already open, don't do anything.
   1:   if (mConnection != nsnull)
   1:     return NS_OK;
   1: 
   1:   LOG(("Opening db\n"));
   1:   // Compute database filename
   1:   nsCOMPtr<nsIFile> dbFile;
   1: 
   1:   nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
   1:                                        getter_AddRefs(dbFile));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   rv = dbFile->Append(NS_LITERAL_STRING(DATABASE_FILENAME));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // open the connection
   1:   nsCOMPtr<mozIStorageService> storageService =
   1:     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID, &rv);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1:   rv = storageService->OpenDatabase(dbFile, &mConnection);
   1:   if (rv == NS_ERROR_FILE_CORRUPTED) {
   1:     // delete the db and try opening again
   1:     rv = dbFile->Remove(PR_FALSE);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     rv = storageService->OpenDatabase(dbFile, &mConnection);
   1:   }
   1:   return rv;
   1: }
   1: 
   1: nsresult
   1: nsUrlClassifierDBServiceWorker::MaybeCreateTable(const nsCString& aTableName)
   1: {
   1:   LOG(("MaybeCreateTable %s\n", aTableName.get()));
   1: 
   1:   nsCOMPtr<mozIStorageStatement> createStatement;
   1:   nsCString statement;
   1:   statement.Assign("CREATE TABLE IF NOT EXISTS ");
   1:   statement.Append(aTableName);
   1:   statement.Append(" (key TEXT PRIMARY KEY, value TEXT)");
   1:   nsresult rv = mConnection->CreateStatement(statement,
   1:                                              getter_AddRefs(createStatement));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return createStatement->Execute();
   1: }
   1: 
   1: nsresult
   1: nsUrlClassifierDBServiceWorker::MaybeDropTable(const nsCString& aTableName)
   1: {
   1:   LOG(("MaybeDropTable %s\n", aTableName.get()));
   1:   nsCAutoString statement("DROP TABLE IF EXISTS ");
   1:   statement.Append(aTableName);
   1:   return mConnection->ExecuteSimpleSQL(statement);
   1: }
   1: 
   1: nsresult
   1: nsUrlClassifierDBServiceWorker::MaybeSwapTables(const nsCString& aVersionLine)
   1: {
   1:   if (aVersionLine.Length() == 0)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   // Check to see if this was a full table update or not.
   1:   nsCAutoString tableName;
   1:   PRBool isUpdate;
   1:   nsresult rv = ParseVersionString(aVersionLine, &tableName, &isUpdate);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // Updates don't require any fancy logic.
   1:   if (isUpdate)
   1:     return NS_OK;
   1: 
   1:   // Not an update, so we need to swap tables by dropping the original table
   1:   // and copying in the values from the new table.
   1:   rv = MaybeDropTable(tableName);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCAutoString newTableName(tableName);
   1:   newTableName.Append(kNEW_TABLE_SUFFIX);
   1: 
   1:   // Bring over new table
   1:   nsCAutoString sql("ALTER TABLE ");
   1:   sql.Append(newTableName);
   1:   sql.Append(" RENAME TO ");
   1:   sql.Append(tableName);
   1:   rv = mConnection->ExecuteSimpleSQL(sql);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   LOG(("tables swapped (%s)\n", tableName.get()));
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // The line format is "[table-name #.####]" or "[table-name #.#### update]".
   1: nsresult
   1: nsUrlClassifierDBServiceWorker::ParseVersionString(const nsCSubstring& aLine,
   1:                                                    nsCString* aTableName,
   1:                                                    PRBool* aIsUpdate)
   1: {
   1:   // Blank lines are not valid
   1:   if (aLine.Length() == 0)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   // Max size for an update line (so we don't buffer overflow when sscanf'ing).
   1:   const PRUint32 MAX_LENGTH = 2048;
   1:   if (aLine.Length() > MAX_LENGTH)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsCAutoString lineData(aLine);
   1:   char tableNameBuf[MAX_LENGTH], endChar = ' ';
   1:   PRInt32 majorVersion, minorVersion, numConverted;
   1:   // Use trailing endChar to make sure the update token gets parsed.
   1:   numConverted = PR_sscanf(lineData.get(), "[%s %d.%d update%c", tableNameBuf,
   1:                            &majorVersion, &minorVersion, &endChar);
   1:   if (numConverted != 4 || endChar != ']') {
   1:     // Check to see if it's not an update request
   1:     numConverted = PR_sscanf(lineData.get(), "[%s %d.%d%c", tableNameBuf,
   1:                              &majorVersion, &minorVersion, &endChar);
   1:     if (numConverted != 4 || endChar != ']')
   1:       return NS_ERROR_FAILURE;
   1:     *aIsUpdate = PR_FALSE;
   1:   } else {
   1:     // First sscanf worked, so it's an update string.
   1:     *aIsUpdate = PR_TRUE;
   1:   }
   1: 
   1:   LOG(("Is update? %d\n", *aIsUpdate));
   1: 
   1:   // Table header looks valid, go ahead and copy over the table name into the
   1:   // return variable.
   1:   GetDbTableName(nsCAutoString(tableNameBuf), aTableName);
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsUrlClassifierDBServiceWorker::GetDbTableName(const nsACString& aTableName,
   1:                                                nsCString* aDbTableName)
   1: {
   1:   aDbTableName->Assign(aTableName);
   1:   aDbTableName->ReplaceChar('-', '_');
   1: }
   1: 
   1: // -------------------------------------------------------------------------
   1: // Proxy class implementation
   1: 
   1: NS_IMPL_THREADSAFE_ISUPPORTS2(nsUrlClassifierDBService,
   1:                               nsIUrlClassifierDBService,
   1:                               nsIObserver)
   1: 
   1: /* static */ nsUrlClassifierDBService*
   1: nsUrlClassifierDBService::GetInstance()
   1: {
   1:   if (!sUrlClassifierDBService) {
   1:     sUrlClassifierDBService = new nsUrlClassifierDBService();
   1:     if (!sUrlClassifierDBService)
   1:       return nsnull;
   1: 
   1:     NS_ADDREF(sUrlClassifierDBService);   // addref the global
   1: 
   1:     if (NS_FAILED(sUrlClassifierDBService->Init())) {
   1:       NS_RELEASE(sUrlClassifierDBService);
   1:       return nsnull;
   1:     }
   1:   } else {
   1:     // Already exists, just add a ref
   1:     NS_ADDREF(sUrlClassifierDBService);   // addref the return result
   1:   }
   1:   return sUrlClassifierDBService;
   1: }
   1: 
   1: 
   1: nsUrlClassifierDBService::nsUrlClassifierDBService()
   1: {
   1: }
   1: 
   1: nsUrlClassifierDBService::~nsUrlClassifierDBService()
   1: {
   1:   sUrlClassifierDBService = nsnull;
   1: }
   1: 
   1: nsresult
   1: nsUrlClassifierDBService::Init()
   1: {
   1: #if defined(PR_LOGGING)
   1:   if (!gUrlClassifierDbServiceLog)
   1:     gUrlClassifierDbServiceLog = PR_NewLogModule("UrlClassifierDbService");
   1: #endif
   1: 
   1:   // Force the storage service to be created on the main thread.
   1:   nsresult rv;
   1:   nsCOMPtr<mozIStorageService> storageService =
   1:     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID, &rv);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // Start the background thread.
   1:   rv = NS_NewThread(&gDbBackgroundThread);
   1:   if (NS_FAILED(rv))
   1:     return rv;
   1: 
   1:   mWorker = new nsUrlClassifierDBServiceWorker();
   1:   if (!mWorker)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   // Add an observer for shutdown
   1:   nsCOMPtr<nsIObserverService> observerService =
   1:       do_GetService("@mozilla.org/observer-service;1");
   1:   if (!observerService)
   1:     return NS_ERROR_FAILURE;
   1: 
3338:   observerService->AddObserver(this, "profile-before-change", PR_FALSE);
3338:   observerService->AddObserver(this, "xpcom-shutdown-threads", PR_FALSE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBService::Exists(const nsACString& tableName,
   1:                                  const nsACString& key,
   1:                                  nsIUrlClassifierCallback *c)
   1: {
   1:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
   1: 
   1:   nsresult rv;
   1:   // The proxy callback uses the current thread.
   1:   nsCOMPtr<nsIUrlClassifierCallback> proxyCallback;
   1:   rv = NS_GetProxyForObject(NS_PROXY_TO_CURRENT_THREAD,
   1:                             NS_GET_IID(nsIUrlClassifierCallback),
   1:                             c,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxyCallback));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // The actual worker uses the background thread.
   1:   nsCOMPtr<nsIUrlClassifierDBServiceWorker> proxy;
   1:   rv = NS_GetProxyForObject(gDbBackgroundThread,
   1:                             NS_GET_IID(nsIUrlClassifierDBServiceWorker),
   1:                             mWorker,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxy));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return proxy->Exists(tableName, key, proxyCallback);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBService::CheckTables(const nsACString & tableNames,
   1:                                       nsIUrlClassifierCallback *c)
   1: {
   1:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
   1: 
   1:   nsresult rv;
   1:   // The proxy callback uses the current thread.
   1:   nsCOMPtr<nsIUrlClassifierCallback> proxyCallback;
   1:   rv = NS_GetProxyForObject(NS_PROXY_TO_CURRENT_THREAD,
   1:                             NS_GET_IID(nsIUrlClassifierCallback),
   1:                             c,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxyCallback));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // The actual worker uses the background thread.
   1:   nsCOMPtr<nsIUrlClassifierDBServiceWorker> proxy;
   1:   rv = NS_GetProxyForObject(gDbBackgroundThread,
   1:                             NS_GET_IID(nsIUrlClassifierDBServiceWorker),
   1:                             mWorker,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxy));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return proxy->CheckTables(tableNames, proxyCallback);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBService::UpdateTables(const nsACString& updateString,
   1:                                        nsIUrlClassifierCallback *c)
   1: {
   1:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
   1: 
   1:   nsresult rv;
   1:   // The proxy callback uses the current thread.
   1:   nsCOMPtr<nsIUrlClassifierCallback> proxyCallback;
   1:   rv = NS_GetProxyForObject(NS_PROXY_TO_CURRENT_THREAD,
   1:                             NS_GET_IID(nsIUrlClassifierCallback),
   1:                             c,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxyCallback));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // The actual worker uses the background thread.
   1:   nsCOMPtr<nsIUrlClassifierDBServiceWorker> proxy;
   1:   rv = NS_GetProxyForObject(gDbBackgroundThread,
   1:                             NS_GET_IID(nsIUrlClassifierDBServiceWorker),
   1:                             mWorker,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxy));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return proxy->UpdateTables(updateString, proxyCallback);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBService::Update(const nsACString& aUpdateChunk)
   1: {
   1:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
   1: 
   1:   nsresult rv;
   1: 
   1:   // The actual worker uses the background thread.
   1:   nsCOMPtr<nsIUrlClassifierDBServiceWorker> proxy;
   1:   rv = NS_GetProxyForObject(gDbBackgroundThread,
   1:                             NS_GET_IID(nsIUrlClassifierDBServiceWorker),
   1:                             mWorker,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxy));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return proxy->Update(aUpdateChunk);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBService::Finish(nsIUrlClassifierCallback *c)
   1: {
   1:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
   1: 
   1:   nsresult rv;
   1:   // The proxy callback uses the current thread.
   1:   nsCOMPtr<nsIUrlClassifierCallback> proxyCallback;
   1:   rv = NS_GetProxyForObject(NS_PROXY_TO_CURRENT_THREAD,
   1:                             NS_GET_IID(nsIUrlClassifierCallback),
   1:                             c,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxyCallback));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // The actual worker uses the background thread.
   1:   nsCOMPtr<nsIUrlClassifierDBServiceWorker> proxy;
   1:   rv = NS_GetProxyForObject(gDbBackgroundThread,
   1:                             NS_GET_IID(nsIUrlClassifierDBServiceWorker),
   1:                             mWorker,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxy));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return proxy->Finish(proxyCallback);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBService::CancelStream()
   1: {
   1:   NS_ENSURE_TRUE(gDbBackgroundThread, NS_ERROR_NOT_INITIALIZED);
   1: 
   1:   nsresult rv;
   1: 
   1:   // The actual worker uses the background thread.
   1:   nsCOMPtr<nsIUrlClassifierDBServiceWorker> proxy;
   1:   rv = NS_GetProxyForObject(gDbBackgroundThread,
   1:                             NS_GET_IID(nsIUrlClassifierDBServiceWorker),
   1:                             mWorker,
   1:                             NS_PROXY_ASYNC,
   1:                             getter_AddRefs(proxy));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   return proxy->CancelStream();
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsUrlClassifierDBService::Observe(nsISupports *aSubject, const char *aTopic,
   1:                                   const PRUnichar *aData)
   1: {
3338:   NS_ASSERTION(strcmp(aTopic, "profile-before-change") == 0 ||
3338:                strcmp(aTopic, "xpcom-shutdown-threads") == 0,
3338:                "Unexpected observer topic");
3338: 
   1:   Shutdown();
3338: 
   1:   return NS_OK;
   1: }
   1: 
   1: // Join the background thread if it exists.
   1: nsresult
   1: nsUrlClassifierDBService::Shutdown()
   1: {
3338:   LOG(("shutting down db service\n"));
3338: 
   1:   if (!gDbBackgroundThread)
   1:     return NS_OK;
   1: 
   1:   nsresult rv;
   1:   // First close the db connection.
   1:   if (mWorker) {
   1:     nsCOMPtr<nsIUrlClassifierDBServiceWorker> proxy;
   1:     rv = NS_GetProxyForObject(gDbBackgroundThread,
   1:                               NS_GET_IID(nsIUrlClassifierDBServiceWorker),
   1:                               mWorker,
   1:                               NS_PROXY_ASYNC,
   1:                               getter_AddRefs(proxy));
 762:     if (NS_SUCCEEDED(rv)) {
 762:       rv = proxy->CloseDb();
 762:       NS_ASSERTION(NS_SUCCEEDED(rv), "failed to post close db event");
 762:     }
   1:   }
   1:   LOG(("joining background thread"));
   1: 
 762:   gShuttingDownThread = PR_TRUE;
   1:   gDbBackgroundThread->Shutdown();
   1:   NS_RELEASE(gDbBackgroundThread);
   1: 
   1:   return NS_OK;
   1: }
