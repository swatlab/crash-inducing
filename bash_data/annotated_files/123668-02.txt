     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * Implementation of the DOM nsIDOMRange object.
     1:  */
     1: 
     1: #ifndef nsRange_h___
     1: #define nsRange_h___
     1: 
     1: #include "nsIDOMRange.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsIDOMDocumentFragment.h"
103385: #include "nsINode.h"
     1: #include "nsIDOMNode.h"
     1: #include "prmon.h"
     1: #include "nsStubMutationObserver.h"
     1: 
 86939: class nsRange : public nsIDOMRange,
     1:                 public nsStubMutationObserver
     1: {
     1: public:
 86939:   nsRange()
106838:     : mRoot(nullptr)
 86939:     , mStartOffset(0)
 86939:     , mEndOffset(0)
 86939:     , mIsPositioned(false)
 86939:     , mIsDetached(false)
 86939:     , mMaySpanAnonymousSubtrees(false)
 86939:     , mInSelection(false)
123668:     , mStartOffsetWasIncremented(false)
123668:     , mEndOffsetWasIncremented(false)
123668: #ifdef DEBUG
123668:     , mAssertNextInsertOrAppendIndex(-1)
123668:     , mAssertNextInsertOrAppendNode(nullptr)
123668: #endif
 86939:   {}
     1:   virtual ~nsRange();
     1: 
108991:   static nsresult CreateRange(nsIDOMNode* aStartParent, int32_t aStartOffset,
108991:                               nsIDOMNode* aEndParent, int32_t aEndOffset,
 87303:                               nsRange** aRange);
108991:   static nsresult CreateRange(nsIDOMNode* aStartParent, int32_t aStartOffset,
108991:                               nsIDOMNode* aEndParent, int32_t aEndOffset,
 87303:                               nsIDOMRange** aRange);
 87303: 
 22215:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 86939:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsRange, nsIDOMRange)
     1: 
     1:   // nsIDOMRange interface
     1:   NS_DECL_NSIDOMRANGE
     1:   
 86939:   nsINode* GetRoot() const
 86939:   {
 86939:     return mRoot;
 86939:   }
 86939: 
 86939:   nsINode* GetStartParent() const
 86939:   {
 86939:     return mStartParent;
 86939:   }
 86939: 
 86939:   nsINode* GetEndParent() const
 86939:   {
 86939:     return mEndParent;
 86939:   }
 86939: 
108991:   int32_t StartOffset() const
 86939:   {
 86939:     return mStartOffset;
 86939:   }
 86939: 
108991:   int32_t EndOffset() const
 86939:   {
 86939:     return mEndOffset;
 86939:   }
 86939:   
 86939:   bool IsPositioned() const
 86939:   {
 86939:     return mIsPositioned;
 86939:   }
 86939: 
 86939:   bool Collapsed() const
 86939:   {
 86939:     return mIsPositioned && mStartParent == mEndParent &&
 86939:            mStartOffset == mEndOffset;
 86939:   }
 86939: 
 86939:   void SetMaySpanAnonymousSubtrees(bool aMaySpanAnonymousSubtrees)
 86939:   {
 86939:     mMaySpanAnonymousSubtrees = aMaySpanAnonymousSubtrees;
 86939:   }
 86939:   
 86939:   /**
 86939:    * Return true iff this range is part of at least one Selection object
 86939:    * and isn't detached.
 86939:    */
 86939:   bool IsInSelection() const
 86939:   {
 86939:     return mInSelection;
 86939:   }
 86939: 
 86939:   /**
 86939:    * Called when the range is added/removed from a Selection.
 86939:    */
 86939:   void SetInSelection(bool aInSelection)
 86939:   {
 96921:     if (mInSelection == aInSelection) {
 86939:       return;
 86939:     }
 86939:     mInSelection = aInSelection;
 86939:     nsINode* commonAncestor = GetCommonAncestor();
 86939:     NS_ASSERTION(commonAncestor, "unexpected disconnected nodes");
 86939:     if (mInSelection) {
 86939:       RegisterCommonAncestor(commonAncestor);
 86939:     } else {
 86939:       UnregisterCommonAncestor(commonAncestor);
 86939:     }
 86939:   }
 86939: 
 86939:   nsINode* GetCommonAncestor() const;
 86939:   void Reset();
108991:   nsresult SetStart(nsINode* aParent, int32_t aOffset);
108991:   nsresult SetEnd(nsINode* aParent, int32_t aOffset);
103057:   already_AddRefed<nsRange> CloneRange() const;
     1: 
108991:   nsresult Set(nsINode* aStartParent, int32_t aStartOffset,
108991:                nsINode* aEndParent, int32_t aEndOffset)
 81387:   {
 81387:     // If this starts being hot, we may be able to optimize this a bit,
 81387:     // but for now just set start and end separately.
 81387:     nsresult rv = SetStart(aStartParent, aStartOffset);
 81387:     NS_ENSURE_SUCCESS(rv, rv);
 81387: 
 81387:     return SetEnd(aEndParent, aEndOffset);
 81387:   }
 81387: 
 71908:   NS_IMETHOD GetUsedFontFaces(nsIDOMFontFaceList** aResult);
 71908: 
     1:   // nsIMutationObserver methods
 48038:   NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
 48038:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
 48038:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
 48038:   NS_DECL_NSIMUTATIONOBSERVER_PARENTCHAINCHANGED
 85101:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
     1: 
     1: private:
     1:   // no copy's or assigns
     1:   nsRange(const nsRange&);
     1:   nsRange& operator=(const nsRange&);
     1: 
 16205:   /**
 16205:    * Cut or delete the range's contents.
 16205:    *
 16205:    * @param aFragment nsIDOMDocumentFragment containing the nodes.
 16205:    *                  May be null to indicate the caller doesn't want a fragment.
 16205:    */
 16205:   nsresult CutContents(nsIDOMDocumentFragment** frag);
 16205: 
 20321:   static nsresult CloneParentsBetween(nsIDOMNode *aAncestor,
 20321:                                       nsIDOMNode *aNode,
 20321:                                       nsIDOMNode **aClosestAncestor,
 20321:                                       nsIDOMNode **aFarthestAncestor);
 16205: 
     1: public:
     1: /******************************************************************************
     1:  *  Utility routine to detect if a content node starts before a range and/or 
     1:  *  ends after a range.  If neither it is contained inside the range.
     1:  *  
     1:  *  XXX - callers responsibility to ensure node in same doc as range!
     1:  *
     1:  *****************************************************************************/
 86939:   static nsresult CompareNodeToRange(nsINode* aNode, nsRange* aRange,
 79445:                                      bool *outNodeBefore,
 79445:                                      bool *outNodeAfter);
     1: 
108991:   static bool IsNodeSelected(nsINode* aNode, uint32_t aStartOffset,
108991:                              uint32_t aEndOffset);
 85101: 
 86939:   typedef nsTHashtable<nsPtrHashKey<nsRange> > RangeHashTable;
     1: protected:
 86939:   void RegisterCommonAncestor(nsINode* aNode);
 86939:   void UnregisterCommonAncestor(nsINode* aNode);
 86939:   nsINode* IsValidBoundary(nsINode* aNode);
 86939: 
 85101:   // CharacterDataChanged set aNotInsertedYet to true to disable an assertion
 85101:   // and suppress re-registering a range common ancestor node since
 85101:   // the new text node of a splitText hasn't been inserted yet.
 85101:   // CharacterDataChanged does the re-registering when needed.
108991:   void DoSetRange(nsINode* aStartN, int32_t aStartOffset,
108991:                   nsINode* aEndN, int32_t aEndOffset,
 85101:                   nsINode* aRoot, bool aNotInsertedYet = false);
 86160: 
 86160:   /**
 86160:    * For a range for which IsInSelection() is true, return the common
 86160:    * ancestor for the range.  This method uses the selection bits and
 86160:    * nsGkAtoms::range property on the nodes to quickly find the ancestor.
 86160:    * That is, it's a faster version of GetCommonAncestor that only works
 86160:    * for ranges in a Selection.  The method will assert and the behavior
 86160:    * is undefined if called on a range where IsInSelection() is false.
 86160:    */
 86160:   nsINode* GetRegisteredCommonAncestor();
 86160: 
 86160:   struct NS_STACK_CLASS AutoInvalidateSelection
 86160:   {
 86160:     AutoInvalidateSelection(nsRange* aRange) : mRange(aRange)
 86160:     {
 86160: #ifdef DEBUG
 86160:       mWasInSelection = mRange->IsInSelection();
 86160: #endif
 86160:       if (!mRange->IsInSelection() || mIsNested) {
 86160:         return;
 86160:       }
 86160:       mIsNested = true;
 86160:       mCommonAncestor = mRange->GetRegisteredCommonAncestor();
 86160:     }
 86160:     ~AutoInvalidateSelection();
 86160:     nsRange* mRange;
 86160:     nsRefPtr<nsINode> mCommonAncestor;
 86160: #ifdef DEBUG
 86160:     bool mWasInSelection;
 86160: #endif
 86160:     static bool mIsNested;
 86160:   };
 86160:   
 86939:   nsCOMPtr<nsINode> mRoot;
 86939:   nsCOMPtr<nsINode> mStartParent;
 86939:   nsCOMPtr<nsINode> mEndParent;
108991:   int32_t mStartOffset;
108991:   int32_t mEndOffset;
 86939: 
 86939:   bool mIsPositioned;
 86939:   bool mIsDetached;
 86939:   bool mMaySpanAnonymousSubtrees;
 86939:   bool mInSelection;
123668:   bool mStartOffsetWasIncremented;
123668:   bool mEndOffsetWasIncremented;
123668: #ifdef DEBUG
123668:   int32_t  mAssertNextInsertOrAppendIndex;
123668:   nsINode* mAssertNextInsertOrAppendNode;
123668: #endif
     1: };
     1: 
     1: #endif /* nsRange_h___ */
