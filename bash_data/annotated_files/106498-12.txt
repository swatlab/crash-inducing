     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 99901: #ifndef mozilla_a11y_HyperTextAccessible_h__
 99901: #define mozilla_a11y_HyperTextAccessible_h__
     1: 
     1: #include "nsIAccessibleText.h"
     1: #include "nsIAccessibleHyperText.h"
     1: #include "nsIAccessibleEditableText.h"
 43888: 
 99648: #include "AccessibleWrap.h"
 16001: 
     1: #include "nsFrameSelection.h"
     1: #include "nsISelectionController.h"
     1: 
103399: namespace mozilla {
103399: namespace a11y {
103399: struct DOMPoint {
103399:   nsINode* node;
103399:   PRInt32 idx;
103399: };
103399: }
103399: }
103399: 
     1: enum EGetTextType { eGetBefore=-1, eGetAt=0, eGetAfter=1 };
     1: 
     1: // This character marks where in the text returned via nsIAccessibleText(),
     1: // that embedded object characters exist
     1: const PRUnichar kEmbeddedObjectChar = 0xfffc;
  8105: const PRUnichar kImaginaryEmbeddedObjectChar = ' ';
     1: const PRUnichar kForcedNewLineChar = '\n';
     1: 
     1: /**
     1:   * Special Accessible that knows how contain both text and embedded objects
     1:   */
 99901: class HyperTextAccessible : public AccessibleWrap,
     1:                             public nsIAccessibleText,
     1:                             public nsIAccessibleHyperText,
  3950:                             public nsIAccessibleEditableText
     1: {
     1: public:
 99901:   HyperTextAccessible(nsIContent* aContent, DocAccessible* aDoc);
 99901:   virtual ~HyperTextAccessible() { }
 89799: 
     1:   NS_DECL_ISUPPORTS_INHERITED
     1:   NS_DECL_NSIACCESSIBLETEXT
     1:   NS_DECL_NSIACCESSIBLEHYPERTEXT
     1:   NS_DECL_NSIACCESSIBLEEDITABLETEXT
     1: 
 99648:   // Accessible
 36879:   virtual PRInt32 GetLevelInternal();
   401:   virtual nsresult GetAttributesInternal(nsIPersistentProperties *aAttributes);
 82720:   virtual nsresult GetNameInternal(nsAString& aName);
 87094:   virtual mozilla::a11y::role NativeRole();
 67790:   virtual PRUint64 NativeState();
     1: 
 43888:   virtual void InvalidateChildren();
 99648:   virtual bool RemoveChild(Accessible* aAccessible);
 43888: 
 99901:   // HyperTextAccessible (static helper method)
 43888: 
  4261:   // Convert content offset to rendered text offset  
  4261:   static nsresult ContentToRenderedOffset(nsIFrame *aFrame, PRInt32 aContentOffset,
  4261:                                           PRUint32 *aRenderedOffset);
  4261:   
  4261:   // Convert rendered text offset to content offset
  4261:   static nsresult RenderedToContentOffset(nsIFrame *aFrame, PRUint32 aRenderedOffset,
  4261:                                           PRInt32 *aContentOffset);
  4261: 
 61202:   //////////////////////////////////////////////////////////////////////////////
 61202:   // HyperLinkAccessible
 61202: 
  3950:   /**
 43888:    * Return link count within this hypertext accessible.
 43888:    */
 99648:   PRUint32 GetLinkCount()
 43888:   {
 99463:     return EmbeddedChildCount();
 43888:   }
 43888: 
 43888:   /**
 43888:    * Return link accessible at the given index.
 43888:    */
 99648:   Accessible* GetLinkAt(PRUint32 aIndex)
 43888:   {
 50622:     return GetEmbeddedChildAt(aIndex);
 43888:   }
 43888: 
 43888:   /**
 43888:    * Return index for the given link accessible.
 43888:    */
 99648:   PRInt32 GetLinkIndex(Accessible* aLink)
 43888:   {
 50622:     return GetIndexOfEmbeddedChild(aLink);
 50622:   }
 50622: 
 50622:   /**
 50622:    * Return link accessible at the given text offset.
 50622:    */
 99648:   PRInt32 GetLinkIndexAtOffset(PRUint32 aOffset)
 50622:   {
 99648:     Accessible* child = GetChildAtOffset(aOffset);
 51379:     return child ? GetLinkIndex(child) : -1;
 43888:   }
 43888: 
 61202:   //////////////////////////////////////////////////////////////////////////////
 99901:   // HyperTextAccessible: DOM point to text offset conversions.
 61202: 
 43888:   /**
  3950:     * Turn a DOM Node and offset into a character offset into this hypertext.
  3950:     * Will look for closest match when the DOM node does not have an accessible
  3950:     * object associated with it. Will return an offset for the end of
  3950:     * the string if the node is not found.
  3950:     *
  3950:     * @param aNode - the node to look for
  3950:     * @param aNodeOffset - the offset to look for
  5395:     *                      if -1 just look directly for the node
  5395:     *                      if >=0 and aNode is text, this represents a char offset
  5395:     *                      if >=0 and aNode is not text, this represents a child node offset
  3950:     * @param aResultOffset - the character offset into the current
 99901:     *                        HyperTextAccessible
 80486:     * @param aIsEndOffset - if true, then then this offset is not inclusive. The character
  6072:     *                       indicated by the offset returned is at [offset - 1]. This means
  6072:     *                       if the passed-in offset is really in a descendant, then the offset returned
  6072:     *                       will come just after the relevant embedded object characer.
 80486:     *                       If false, then the offset is inclusive. The character indicated
  6072:     *                       by the offset returned is at [offset]. If the passed-in offset in inside a
  6072:     *                       descendant, then the returned offset will be on the relevant embedded object char.
 42377:     *
 42377:     * @return               the accessible child which contained the offset, if
 99901:     *                       it is within the current HyperTextAccessible,
 42377:     *                       otherwise nsnull
  3950:     */
 99648:   Accessible* DOMPointToHypertextOffset(nsINode *aNode,
 42377:                                         PRInt32 aNodeOffset,
  4261:                                         PRInt32* aHypertextOffset,
 79445:                                         bool aIsEndOffset = false);
  3950: 
  6286:   /**
  6286:    * Turn a start and end hypertext offsets into DOM range.
  6286:    *
  6286:    * @param  aStartHTOffset  [in] the given start hypertext offset
  6286:    * @param  aEndHTOffset    [in] the given end hypertext offset
103399:    * @param  aRange      [out] the range whose bounds to set
  6286:    */
  6286:   nsresult HypertextOffsetsToDOMRange(PRInt32 aStartHTOffset,
  6286:                                       PRInt32 aEndHTOffset,
103399:                                       nsRange* aRange);
  6286: 
 95393:   /**
 95393:    * Return true if the used ARIA role (if any) allows the hypertext accessible
 95393:    * to expose text interfaces.
 95393:    */
 95393:   bool IsTextRole();
 95393: 
 61202:   //////////////////////////////////////////////////////////////////////////////
 61202:   // TextAccessible
 61202: 
 61202:   /**
 61202:    * Return character count within the hypertext accessible.
 61202:    */
 99648:   PRUint32 CharacterCount()
 61202:   {
 99463:     return GetChildOffset(ChildCount());
 61202:   }
 61202: 
 47107:   /**
 61843:    * Get a character before/at/after the given offset.
 61843:    *
 61843:    * @param aOffset       [in] the given offset
 61843:    * @param aShift        [in] specifies whether to get a char before/at/after
 61843:    *                        offset
 61843:    * @param aChar         [out] the character
 61843:    * @param aStartOffset  [out, optional] the start offset of the character
 61843:    * @param aEndOffset    [out, optional] the end offset of the character
 61843:    * @return               false if offset at the given shift is out of range
 61843:    */
 61843:   bool GetCharAt(PRInt32 aOffset, EGetTextType aShift, nsAString& aChar,
 61843:                  PRInt32* aStartOffset = nsnull, PRInt32* aEndOffset = nsnull);
 61843: 
 61843:   /**
 50622:    * Return text offset of the given child accessible within hypertext
 50622:    * accessible.
 47107:    *
 47107:    * @param  aChild           [in] accessible child to get text offset for
 47107:    * @param  aInvalidateAfter [in, optional] indicates whether invalidate
 47107:    *                           cached offsets for next siblings of the child
 47107:    */
 99648:   PRInt32 GetChildOffset(Accessible* aChild,
 79445:                          bool aInvalidateAfter = false)
 50622:   {
 50622:     PRInt32 index = GetIndexOf(aChild);
 50622:     return index == -1 ? -1 : GetChildOffset(index, aInvalidateAfter);
 50622:   }
 50622: 
 50622:   /**
 50622:    * Return text offset for the child accessible index.
 50622:    */
 50622:   PRInt32 GetChildOffset(PRUint32 aChildIndex,
 79445:                          bool aInvalidateAfter = false);
 47107: 
 50622:   /**
 50622:    * Return child accessible at the given text offset.
 50622:    *
 50622:    * @param  aOffset  [in] the given text offset
 50622:    */
 50622:   PRInt32 GetChildIndexAtOffset(PRUint32 aOffset);
 50622: 
 50622:   /**
 50622:    * Return child accessible at the given text offset.
 50622:    *
 50622:    * @param  aOffset  [in] the given text offset
 50622:    */
 99648:   Accessible* GetChildAtOffset(PRUint32 aOffset)
 50622:   {
 50622:     return GetChildAt(GetChildIndexAtOffset(aOffset));
 50622:   }
 50622: 
 93927:   /**
 93927:    * Return the bounds of the text between given start and end offset.
 93927:    */
 93927:   nsIntRect GetTextBounds(PRInt32 aStartOffset, PRInt32 aEndOffset)
 93927:   {
 93927:     nsIntRect bounds;
 93927:     GetPosAndText(aStartOffset, aEndOffset, nsnull, nsnull, &bounds);
 93927:     return bounds;
 93927:   }
 93927: 
 93927:   /**
 93927:    * Provide the line number for the caret.
 93927:    * @return 1-based index for the line number with the caret
 93927:    */
 93927:   PRInt32 CaretLineNumber();
 93927: 
 91761:   //////////////////////////////////////////////////////////////////////////////
 91761:   // EditableTextAccessible
 91761: 
 91761:   /**
 91761:    * Return the editor associated with the accessible.
 91761:    */
 91761:   virtual already_AddRefed<nsIEditor> GetEditor() const;
 91761: 
     1: protected:
 99901:   // HyperTextAccessible
 35523: 
 61843:   /**
 61843:    * Transform magic offset into text offset.
 61843:    */
 99648:   PRInt32 ConvertMagicOffset(PRInt32 aOffset)
 61843:   {
 61843:     if (aOffset == nsIAccessibleText::TEXT_OFFSET_END_OF_TEXT)
 61843:       return CharacterCount();
 61843: 
 61843:     if (aOffset == nsIAccessibleText::TEXT_OFFSET_CARET) {
 61843:       PRInt32 caretOffset = -1;
 61843:       GetCaretOffset(&caretOffset);
 61843:       return caretOffset;
 61843:     }
 61843: 
 61843:     return aOffset;
 61843:   }
 61843: 
     1:   /*
     1:    * This does the work for nsIAccessibleText::GetText[At|Before|After]Offset
     1:    * @param aType, eGetBefore, eGetAt, eGetAfter
     1:    * @param aBoundaryType, char/word-start/word-end/line-start/line-end/paragraph/attribute
     1:    * @param aOffset, offset into the hypertext to start from
     1:    * @param *aStartOffset, the resulting start offset for the returned substring
     1:    * @param *aEndOffset, the resulting end offset for the returned substring
     1:    * @param aText, the resulting substring
     1:    * @return success/failure code
     1:    */
 99648:   nsresult GetTextHelper(EGetTextType aType, AccessibleTextBoundary aBoundaryType,
     1:                          PRInt32 aOffset, PRInt32 *aStartOffset, PRInt32 *aEndOffset,
     1:                          nsAString & aText);
     1: 
     1:   /**
  5418:     * Used by GetTextHelper() to move backward/forward from a given point
  5418:     * by word/line/etc.
  5418:     *
  5418:     * @param  aPresShell       the current presshell we're moving in
  5418:     * @param  aFromFrame       the starting frame we're moving from
  5418:     * @param  aFromOffset      the starting offset we're moving from
  5418:     * @param  aFromAccessible  the starting accessible we're moving from
  5418:     * @param  aAmount          how much are we moving (word/line/etc.) ?
  5418:     * @param  aDirection       forward or backward?
  5418:     * @param  aNeedsStart      for word and line cases, are we basing this on
  5418:     *                          the start or end?
  5418:     * @return                  the resulting offset into this hypertext
     1:     */
  5418:   PRInt32 GetRelativeOffset(nsIPresShell *aPresShell, nsIFrame *aFromFrame,
 99648:                             PRInt32 aFromOffset, Accessible* aFromAccessible,
  5418:                             nsSelectionAmount aAmount, nsDirection aDirection,
 79445:                             bool aNeedsStart);
  5245: 
     1:   /**
  5245:     * Provides information for substring that is defined by the given start
  5245:     * and end offsets for this hyper text.
  5245:     *
  5245:     * @param  aStartOffset  [inout] the start offset into the hyper text. This
  5245:     *                       is also an out parameter used to return the offset
  5245:     *                       into the start frame's rendered text content
  5245:     *                       (start frame is the @return)
  5245:     *
  5245:     * @param  aEndOffset    [inout] the end offset into the hyper text. This is
  5245:     *                       also an out parameter used to return
  5245:     *                       the offset into the end frame's rendered
  5245:     *                       text content.
  5245:     *
  5245:     * @param  aText         [out, optional] return the substring's text
  5245:     * @param  aEndFrame     [out, optional] return the end frame for this
  5245:     *                       substring
  5245:     * @param  aBoundsRect   [out, optional] return the bounds rectangle for this
  5245:     *                       substring
  5245:     * @param  aStartAcc     [out, optional] return the start accessible for this
  5245:     *                       substring
  5245:     * @param  aEndAcc       [out, optional] return the end accessible for this
  5245:     *                       substring
     1:     * @return               the start frame for this substring
     1:     */
  5245:   nsIFrame* GetPosAndText(PRInt32& aStartOffset, PRInt32& aEndOffset,
  5245:                           nsAString *aText = nsnull,
  5245:                           nsIFrame **aEndFrame = nsnull,
  5245:                           nsIntRect *aBoundsRect = nsnull,
 99648:                           Accessible** aStartAcc = nsnull,
 99648:                           Accessible** aEndAcc = nsnull);
  3950: 
  4468:   nsIntRect GetBoundsForString(nsIFrame *aFrame, PRUint32 aStartRenderedOffset, PRUint32 aEndRenderedOffset);
     1: 
     1:   // Selection helpers
  6072: 
  6072:   /**
 80262:    * Return frame selection object for the accessible.
  6072:    */
 80262:   virtual already_AddRefed<nsFrameSelection> FrameSelection();
 80262: 
 80262:   /**
 80262:    * Return selection ranges within the accessible subtree.
 80262:    */
 86939:   void GetSelectionDOMRanges(PRInt16 aType, nsTArray<nsRange*>* aRanges);
 16001: 
     1:   nsresult SetSelectionRange(PRInt32 aStartPos, PRInt32 aEndPos);
  6286: 
  6286:   // Helpers
  6286:   nsresult GetDOMPointByFrameOffset(nsIFrame* aFrame, PRInt32 aOffset,
 99648:                                     Accessible* aAccessible,
103399:                                     mozilla::a11y::DOMPoint* aPoint);
 16001: 
 16001:   
 16001:   /**
 16001:    * Return hyper text offset for the specified bound of the given DOM range.
 16001:    * If the bound is outside of the hyper text then offset value is either
 16001:    * 0 or number of characters of hyper text, it depends on type of requested
 16001:    * offset. The method is a wrapper for DOMPointToHypertextOffset.
 16001:    *
 16001:    * @param aRange          [in] the given range
 16001:    * @param aIsStartBound   [in] specifies whether the required range bound is
 16001:    *                        start bound
 16001:    * @param aIsStartOffset  [in] the offset type, used when the range bound is
 16001:    *                        outside of hyper text
 16001:    * @param aHTOffset       [out] the result offset
 16001:    */
 86939:   nsresult RangeBoundToHypertextOffset(nsRange *aRange,
 79445:                                        bool aIsStartBound,
 79445:                                        bool aIsStartOffset,
 16001:                                        PRInt32 *aHTOffset);
 16001: 
 16001:   /**
 16001:    * Set 'misspelled' text attribute and return range offsets where the
 16001:    * attibute is stretched. If the text is not misspelled at the given offset
 16001:    * then we expose only range offsets where text is not misspelled. The method
 16001:    * is used by GetTextAttributes() method.
 16001:    *
 16001:    * @param aIncludeDefAttrs  [in] points whether text attributes having default
 16001:    *                          values of attributes should be included
 16001:    * @param aSourceNode       [in] the node we start to traverse from
 16001:    * @param aStartOffset      [in, out] the start offset
 16001:    * @param aEndOffset        [in, out] the end offset
 16173:    * @param aAttributes       [out, optional] result attributes
 16001:    */
 91653:   nsresult GetSpellTextAttribute(nsINode* aNode, PRInt32 aNodeOffset,
 16001:                                  PRInt32 *aStartOffset,
 16001:                                  PRInt32 *aEndOffset,
 16001:                                  nsIPersistentProperties *aAttributes);
 43888: 
 43888: private:
 47107:   /**
 47107:    * End text offsets array.
 47107:    */
 47107:   nsTArray<PRUint32> mOffsets;
   582: };
     1: 
 61467: 
 61467: ////////////////////////////////////////////////////////////////////////////////
 99648: // Accessible downcasting method
 61467: 
 99901: inline HyperTextAccessible*
 99648: Accessible::AsHyperText()
 61467: {
 61467:   return mFlags & eHyperTextAccessible ?
 99901:     static_cast<HyperTextAccessible*>(this) : nsnull;
 61467: }
 61467: 
 99901: #endif
  3950: 
