    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
59512:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Mike Shaver <shaver@mozilla.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Data conversion between native and JavaScript types. */
    1: 
    1: #include "xpcprivate.h"
    1: #include "nsString.h"
    1: #include "nsIAtom.h"
 4042: #include "XPCWrapper.h"
20762: #include "nsJSPrincipals.h"
21618: #include "nsWrapperCache.h"
55617: #include "WrapperFactory.h"
55700: #include "AccessCheck.h"
59512: #include "nsJSUtils.h"
    1: 
    1: //#define STRICT_CHECK_OF_UNICODE
    1: #ifdef STRICT_CHECK_OF_UNICODE
    1: #define ILLEGAL_RANGE(c) (0!=((c) & 0xFF80))
    1: #else // STRICT_CHECK_OF_UNICODE
    1: #define ILLEGAL_RANGE(c) (0!=((c) & 0xFF00))
    1: #endif // STRICT_CHECK_OF_UNICODE
    1: 
    1: #define ILLEGAL_CHAR_RANGE(c) (0!=((c) & 0x80))
    1: /*
    1: * This is a table driven scheme to determine if the types of the params of the
    1: * given method exclude that method from being reflected via XPConnect.
    1: *
    1: * The table can be appended and modified as requirements change. However...
    1: *
    1: * The table ASSUMES that all the type idenetifiers are contiguous starting
    1: * at ZERO. And, it also ASSUMES that the additional criteria of whether or
    1: * not a give type is reflectable are its use as a pointer and/or 'out' type.
    1: *
    1: * The table has a row for each type and columns for the combinations of
    1: * that type being used as a pointer type and/or as an 'out' param.
    1: */
    1: 
    1: #define XPC_MK_BIT(p,o) (1 << (((p)?1:0)+((o)?2:0)))
    1: #define XPC_IS_REFLECTABLE(f, p, o) ((f) & XPC_MK_BIT((p),(o)))
    1: #define XPC_MK_FLAG(np_no,p_no,np_o,p_o) \
    1:         ((uint8)((np_no) | ((p_no) << 1) | ((np_o) << 2) | ((p_o) << 3)))
    1: 
    1: /***********************************************************/
    1: // xpt uses 5 bits for this info. We deal with the possibility that
    1: // some new types might exist that we don't know about.
    1: 
    1: #define XPC_FLAG_COUNT (1 << 5)
    1: 
    1: /* '1' means 'reflectable'. '0' means 'not reflectable'.        */
    1: static uint8 xpc_reflectable_flags[XPC_FLAG_COUNT] = {
    1:     /* 'p' stands for 'pointer' and 'o' stands for 'out'        */
    1:     /*          !p&!o, p&!o, !p&o, p&o                          */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_I8                */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_I16               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_I32               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_I64               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_U8                */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_U16               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_U32               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_U64               */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_FLOAT             */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_DOUBLE            */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_BOOL              */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_CHAR              */
    1:     XPC_MK_FLAG(  1  ,  1  ,   1 ,  0 ), /* T_WCHAR             */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* T_VOID              */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_IID               */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  0 ), /* T_DOMSTRING         */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_CHAR_STR          */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_WCHAR_STR         */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_INTERFACE         */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_INTERFACE_IS      */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_ARRAY             */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_PSTRING_SIZE_IS   */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  1 ), /* T_PWSTRING_SIZE_IS  */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  0 ), /* T_UTF8STRING        */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  0 ), /* T_CSTRING           */
    1:     XPC_MK_FLAG(  0  ,  1  ,   0 ,  0 ), /* T_ASTRING           */
46230:     XPC_MK_FLAG(  1  ,  0  ,   1 ,  0 ), /* T_JSVAL             */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 27 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 28 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 29 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 ), /* 30 - reserved       */
    1:     XPC_MK_FLAG(  0  ,  0  ,   0 ,  0 )  /* 31 - reserved       */
    1:     };
    1: 
    1: static intN sXPCOMUCStringFinalizerIndex = -1;
    1: 
    1: /***********************************************************/
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::IsMethodReflectable(const XPTMethodDescriptor& info)
    1: {
    1:     if(XPT_MD_IS_NOTXPCOM(info.flags) || XPT_MD_IS_HIDDEN(info.flags))
    1:         return JS_FALSE;
    1: 
    1:     for(int i = info.num_args-1; i >= 0; i--)
    1:     {
    1:         const nsXPTParamInfo& param = info.params[i];
    1:         const nsXPTType& type = param.GetType();
    1: 
    1:         uint8 base_type = type.TagPart();
    1:         NS_ASSERTION(base_type < XPC_FLAG_COUNT, "BAD TYPE");
    1: 
    1:         if(!XPC_IS_REFLECTABLE(xpc_reflectable_flags[base_type],
    1:                                type.IsPointer(), param.IsOut()))
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
32833: // static
32833: JSBool
32833: XPCConvert::GetISupportsFromJSObject(JSObject* obj, nsISupports** iface)
32833: {
48470:     JSClass* jsclass = obj->getJSClass();
32833:     NS_ASSERTION(jsclass, "obj has no class");
32833:     if(jsclass &&
32833:        (jsclass->flags & JSCLASS_HAS_PRIVATE) &&
32833:        (jsclass->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS))
32833:     {
32833:         *iface = (nsISupports*) xpc_GetJSPrivate(obj);
32833:         return JS_TRUE;
32833:     }
32833:     return JS_FALSE;
32833: }
32833: 
32833: /***************************************************************************/
32833: 
18907: static void
    1: FinalizeXPCOMUCString(JSContext *cx, JSString *str)
    1: {
    1:     NS_ASSERTION(sXPCOMUCStringFinalizerIndex != -1,
    1:                  "XPCConvert: XPCOM Unicode string finalizer called uninitialized!");
    1: 
59889:     jschar* buffer = const_cast<jschar *>(JS_GetStringCharsZ(cx, str));
59889:     NS_ASSERTION(buffer, "How could this OOM if we allocated the memory?");
    1:     nsMemory::Free(buffer);
    1: }
    1: 
    1: 
    1: static JSBool
    1: AddXPCOMUCStringFinalizer()
    1: {
    1: 
    1:     sXPCOMUCStringFinalizerIndex =
    1:         JS_AddExternalStringFinalizer(FinalizeXPCOMUCString);
    1: 
    1:     if(sXPCOMUCStringFinalizerIndex == -1)
    1:     {        
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: //static
    1: void
    1: XPCConvert::RemoveXPCOMUCStringFinalizer()
    1: {
    1:     JS_RemoveExternalStringFinalizer(FinalizeXPCOMUCString);
    1:     sXPCOMUCStringFinalizerIndex = -1;
    1: }
    1: 
18752: 
48470: #define FIT_U32(i)     ((i) <= JSVAL_INT_MAX      \
48470:                         ? INT_TO_JSVAL(i)         \
48470:                         : DOUBLE_TO_JSVAL(i))
18752: 
18752: /*
18752:  * Support for 64 bit conversions where 'long long' not supported.
18752:  * (from John Fairhurst <mjf35@cam.ac.uk>)
18752:  */
18752: 
18752: #ifdef HAVE_LONG_LONG
18752: 
18752: #define INT64_TO_DOUBLE(i)      ((jsdouble) (i))
18752: // Win32 can't handle uint64 to double conversion
18752: #define UINT64_TO_DOUBLE(u)     ((jsdouble) (int64) (u))
18752: 
18752: #else
18752: 
18752: inline jsdouble
18752: INT64_TO_DOUBLE(const int64 &v)
18752: {
18752:     jsdouble d;
18752:     LL_L2D(d, v);
18752:     return d;
18752: }
18752: 
18752: // if !HAVE_LONG_LONG, then uint64 is a typedef of int64
18752: #define UINT64_TO_DOUBLE INT64_TO_DOUBLE
18752: 
18752: #endif
18752: 
    1: // static
    1: JSBool
31395: XPCConvert::NativeData2JS(XPCLazyCallContext& lccx, jsval* d, const void* s,
62405:                           const nsXPTType& type, const nsID* iid, nsresult* pErr)
    1: {
    1:     NS_PRECONDITION(s, "bad param");
    1:     NS_PRECONDITION(d, "bad param");
    1: 
31395:    JSContext* cx = lccx.GetJSContext();
    1: 
62405:     // Allow wrong compartment or unset ScopeForNewObject when the caller knows
62405:     // the value is primitive (viz., XPCNativeMember::GetConstantValue).
62405:     NS_ABORT_IF_FALSE(type.IsArithmetic() ||
62405:                       cx->compartment == lccx.GetScopeForNewJSObjects()->compartment(),
62405:                       "bad scope for new JSObjects");
62405: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1:     switch(type.TagPart())
    1:     {
    1:     case nsXPTType::T_I8    : *d = INT_TO_JSVAL((int32)*((int8*)s));                 break;
    1:     case nsXPTType::T_I16   : *d = INT_TO_JSVAL((int32)*((int16*)s));                break;
48470:     case nsXPTType::T_I32   : *d = INT_TO_JSVAL(*((int32*)s));                       break;
48470:     case nsXPTType::T_I64   : *d = DOUBLE_TO_JSVAL(INT64_TO_DOUBLE(*((int64*)s)));   break;
    1:     case nsXPTType::T_U8    : *d = INT_TO_JSVAL((int32)*((uint8*)s));                break;
    1:     case nsXPTType::T_U16   : *d = INT_TO_JSVAL((int32)*((uint16*)s));               break;
48470:     case nsXPTType::T_U32   : *d = FIT_U32(*((uint32*)s));                           break;
48470:     case nsXPTType::T_U64   : *d = DOUBLE_TO_JSVAL(UINT64_TO_DOUBLE(*((uint64*)s))); break;
48470:     case nsXPTType::T_FLOAT : *d = DOUBLE_TO_JSVAL(*((float*)s));                    break;
48470:     case nsXPTType::T_DOUBLE: *d = DOUBLE_TO_JSVAL(*((double*)s));                   break;
48470:     case nsXPTType::T_BOOL  : *d = BOOLEAN_TO_JSVAL(*((PRBool*)s));                  break;
    1:     case nsXPTType::T_CHAR  :
    1:         {
    1:             char* p = (char*)s;
    1:             if(!p)
    1:                 return JS_FALSE;
    1: 
    1: #ifdef STRICT_CHECK_OF_UNICODE
    1:             NS_ASSERTION(! ILLEGAL_CHAR_RANGE(p) , "passing non ASCII data");
    1: #endif // STRICT_CHECK_OF_UNICODE
    1: 
    1:             JSString* str;
    1:             if(!(str = JS_NewStringCopyN(cx, p, 1)))
    1:                 return JS_FALSE;
    1:             *d = STRING_TO_JSVAL(str);
    1:             break;
    1:         }
    1:     case nsXPTType::T_WCHAR :
    1:         {
    1:             jschar* p = (jschar*)s;
    1:             if(!p)
    1:                 return JS_FALSE;
    1:             JSString* str;
    1:             if(!(str = JS_NewUCStringCopyN(cx, p, 1)))
    1:                 return JS_FALSE;
    1:             *d = STRING_TO_JSVAL(str);
    1:             break;
    1:         }
46230: 
46230:     case nsXPTType::T_JSVAL :
55664:         {
57417:             *d = *((jsval*)s);
55643:             if(!JS_WrapValue(cx, d))
55643:                 return JS_FALSE;
46230:             break;
55664:         }
46230: 
    1:     default:
    1:         if(!type.IsPointer())
    1:         {
    1:             XPC_LOG_ERROR(("XPCConvert::NativeData2JS : unsupported type"));
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         // set the default result
    1:         *d = JSVAL_NULL;
    1: 
    1:         switch(type.TagPart())
    1:         {
    1:         case nsXPTType::T_VOID:
    1:             XPC_LOG_ERROR(("XPCConvert::NativeData2JS : void* params not supported"));
    1:             return JS_FALSE;
    1: 
    1:         case nsXPTType::T_IID:
    1:             {
    1:                 nsID* iid2 = *((nsID**)s);
    1:                 if(!iid2)
    1:                     break;
    1:                 JSObject* obj;
62405:                 if(!(obj = xpc_NewIDObject(cx, lccx.GetScopeForNewJSObjects(), *iid2)))
    1:                     return JS_FALSE;
    1:                 *d = OBJECT_TO_JSVAL(obj);
    1:                 break;
    1:             }
    1: 
    1:         case nsXPTType::T_ASTRING:
    1:             // Fall through to T_DOMSTRING case
    1: 
    1:         case nsXPTType::T_DOMSTRING:
    1:             {
    1:                 const nsAString* p = *((const nsAString**)s);
    1:                 if(!p)
    1:                     break;
    1: 
    1:                 if(!p->IsVoid()) {
49065:                     nsStringBuffer* buf;
49065:                     jsval str = XPCStringConvert::ReadableToJSVal(cx, *p, &buf);
48470:                     if(JSVAL_IS_NULL(str))
    1:                         return JS_FALSE;
49065:                     if(buf)
49065:                         buf->AddRef();
    1: 
30306:                     *d = str;
    1:                 }
    1: 
    1:                 // *d is defaulted to JSVAL_NULL so no need to set it
    1:                 // again if p is a "void" string
    1: 
    1:                 break;
    1:             }
    1: 
    1:         case nsXPTType::T_CHAR_STR:
    1:             {
    1:                 char* p = *((char**)s);
    1:                 if(!p)
    1:                     break;
    1: 
    1: #ifdef STRICT_CHECK_OF_UNICODE
    1:                 PRBool isAscii = PR_TRUE;
    1:                 char* t;
    1:                 for(t=p; *t && isAscii ; t++) {
    1:                   if(ILLEGAL_CHAR_RANGE(*t))
    1:                       isAscii = PR_FALSE;
    1:                 }
    1:                 NS_ASSERTION(isAscii, "passing non ASCII data");
    1: #endif // STRICT_CHECK_OF_UNICODE
    1:                 JSString* str;
    1:                 if(!(str = JS_NewStringCopyZ(cx, p)))
    1:                     return JS_FALSE;
    1:                 *d = STRING_TO_JSVAL(str);
    1:                 break;
    1:             }
    1: 
    1:         case nsXPTType::T_WCHAR_STR:
    1:             {
    1:                 jschar* p = *((jschar**)s);
    1:                 if(!p)
    1:                     break;
    1:                 JSString* str;
    1:                 if(!(str = JS_NewUCStringCopyZ(cx, p)))
    1:                     return JS_FALSE;
    1:                 *d = STRING_TO_JSVAL(str);
    1:                 break;
    1:             }
    1:         case nsXPTType::T_UTF8STRING:
    1:             {                          
    1:                 const nsACString* cString = *((const nsACString**)s);
    1: 
    1:                 if(!cString)
    1:                     break;
    1:                 
    1:                 if(!cString->IsVoid()) 
    1:                 {
    1:                     PRUint32 len;
    1:                     jschar *p = (jschar *)UTF8ToNewUnicode(*cString, &len);
    1: 
    1:                     if(!p)
    1:                         return JS_FALSE;
    1: 
    1:                     if(sXPCOMUCStringFinalizerIndex == -1 && 
    1:                        !AddXPCOMUCStringFinalizer())
    1:                         return JS_FALSE;
    1: 
    1:                     JSString* jsString =
    1:                         JS_NewExternalString(cx, p, len,
    1:                                              sXPCOMUCStringFinalizerIndex);
    1: 
    1:                     if(!jsString) {
    1:                         nsMemory::Free(p); 
    1:                         return JS_FALSE; 
    1:                     }
    1: 
    1:                     *d = STRING_TO_JSVAL(jsString);
    1:                 }
    1: 
    1:                 break;
    1: 
    1:             }
    1:         case nsXPTType::T_CSTRING:
    1:             {                          
    1:                 const nsACString* cString = *((const nsACString**)s);
    1: 
    1:                 if(!cString)
    1:                     break;
    1:                 
    1:                 if(!cString->IsVoid()) 
    1:                 {
    1:                     PRUnichar* unicodeString = ToNewUnicode(*cString);
    1:                     if(!unicodeString)
    1:                         return JS_FALSE;
    1: 
    1:                     if(sXPCOMUCStringFinalizerIndex == -1 && 
    1:                        !AddXPCOMUCStringFinalizer())
    1:                         return JS_FALSE;
    1: 
    1:                     JSString* jsString = JS_NewExternalString(cx,
    1:                                              (jschar*)unicodeString,
    1:                                              cString->Length(),
    1:                                              sXPCOMUCStringFinalizerIndex);
    1: 
    1:                     if(!jsString)
    1:                     {
    1:                         nsMemory::Free(unicodeString);
    1:                         return JS_FALSE;
    1:                     }
    1: 
    1:                     *d = STRING_TO_JSVAL(jsString);
    1:                 }
    1: 
    1:                 break;
    1:             }
    1: 
    1:         case nsXPTType::T_INTERFACE:
    1:         case nsXPTType::T_INTERFACE_IS:
    1:             {
    1:                 nsISupports* iface = *((nsISupports**)s);
    1:                 if(iface)
    1:                 {
    1:                     if(iid->Equals(NS_GET_IID(nsIVariant)))
    1:                     {
    1:                         nsCOMPtr<nsIVariant> variant = do_QueryInterface(iface);
    1:                         if(!variant)
    1:                             return JS_FALSE;
    1: 
31395:                         return XPCVariant::VariantDataToJS(lccx, variant, 
62405:                                                            pErr, d);
    1:                     }
    1:                     // else...
    1:                     
    1:                     // XXX The OBJ_IS_NOT_GLOBAL here is not really right. In
    1:                     // fact, this code is depending on the fact that the
    1:                     // global object will not have been collected, and
    1:                     // therefore this NativeInterface2JSObject will not end up
    1:                     // creating a new XPCNativeScriptableShared.
51515:                     xpcObjectHelper helper(iface);
51515:                     if(!NativeInterface2JSObject(lccx, d, nsnull, helper, iid,
62405:                                                  nsnull, PR_TRUE,
22115:                                                  OBJ_IS_NOT_GLOBAL, pErr))
    1:                         return JS_FALSE;
    1: 
22363: #ifdef DEBUG
22841:                     JSObject* jsobj = JSVAL_TO_OBJECT(*d);
39930:                     if(jsobj && !jsobj->getParent())
40410:                         NS_ASSERTION(jsobj->getClass()->flags & JSCLASS_IS_GLOBAL,
    1:                                      "Why did we recreate this wrapper?");
22363: #endif
    1:                 }
    1:                 break;
    1:             }
46230: 
    1:         default:
31561:             NS_ERROR("bad type");
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::JSData2Native(XPCCallContext& ccx, void* d, jsval s,
    1:                           const nsXPTType& type,
    1:                           JSBool useAllocator, const nsID* iid,
    1:                           nsresult* pErr)
    1: {
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     int32    ti;
    1:     uint32   tu;
    1:     jsdouble td;
    1:     JSBool isDOMString = JS_TRUE;
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
    1: 
    1:     switch(type.TagPart())
    1:     {
    1:     case nsXPTType::T_I8     :
    1:         if(!JS_ValueToECMAInt32(cx, s, &ti))
    1:             return JS_FALSE;
    1:         *((int8*)d)  = (int8) ti;
    1:         break;
    1:     case nsXPTType::T_I16    :
    1:         if(!JS_ValueToECMAInt32(cx, s, &ti))
    1:             return JS_FALSE;
    1:         *((int16*)d)  = (int16) ti;
    1:         break;
    1:     case nsXPTType::T_I32    :
    1:         if(!JS_ValueToECMAInt32(cx, s, (int32*)d))
    1:             return JS_FALSE;
    1:         break;
    1:     case nsXPTType::T_I64    :
    1:         if(JSVAL_IS_INT(s))
    1:         {
    1:             if(!JS_ValueToECMAInt32(cx, s, &ti))
    1:                 return JS_FALSE;
    1:             LL_I2L(*((int64*)d),ti);
    1: 
    1:         }
    1:         else
    1:         {
    1:             if(!JS_ValueToNumber(cx, s, &td))
    1:                 return JS_FALSE;
    1:             LL_D2L(*((int64*)d),td);
    1:         }
    1:         break;
    1:     case nsXPTType::T_U8     :
    1:         if(!JS_ValueToECMAUint32(cx, s, &tu))
    1:             return JS_FALSE;
    1:         *((uint8*)d)  = (uint8) tu;
    1:         break;
    1:     case nsXPTType::T_U16    :
    1:         if(!JS_ValueToECMAUint32(cx, s, &tu))
    1:             return JS_FALSE;
    1:         *((uint16*)d)  = (uint16) tu;
    1:         break;
    1:     case nsXPTType::T_U32    :
    1:         if(!JS_ValueToECMAUint32(cx, s, (uint32*)d))
    1:             return JS_FALSE;
    1:         break;
    1:     case nsXPTType::T_U64    :
    1:         if(JSVAL_IS_INT(s))
    1:         {
    1:             if(!JS_ValueToECMAUint32(cx, s, &tu))
    1:                 return JS_FALSE;
    1:             LL_UI2L(*((int64*)d),tu);
    1:         }
    1:         else
    1:         {
    1:             if(!JS_ValueToNumber(cx, s, &td))
    1:                 return JS_FALSE;
    1: #ifdef XP_WIN
    1:             // Note: Win32 can't handle double to uint64 directly
    1:             *((uint64*)d) = (uint64)((int64) td);
    1: #else
    1:             LL_D2L(*((uint64*)d),td);
    1: #endif
    1:         }
    1:         break;
    1:     case nsXPTType::T_FLOAT  :
    1:         if(!JS_ValueToNumber(cx, s, &td))
    1:             return JS_FALSE;
    1:         *((float*)d) = (float) td;
    1:         break;
    1:     case nsXPTType::T_DOUBLE :
    1:         if(!JS_ValueToNumber(cx, s, (double*)d))
    1:             return JS_FALSE;
    1:         break;
    1:     case nsXPTType::T_BOOL   :
30581:         JS_ValueToBoolean(cx, s, (JSBool*)d);
    1:         break;
    1:     case nsXPTType::T_CHAR   :
    1:         {
57721:             JSString* str = JS_ValueToString(cx, s);
57815:             if(!str)
    1:             {
    1:                 return JS_FALSE;
    1:             }
59889:             size_t length;
59889:             const jschar* chars = JS_GetStringCharsAndLength(cx, str, &length);
59889:             if (!chars)
59889:             {
59889:                 return JS_FALSE;
59889:             }
59889:             jschar ch = length ? chars[0] : 0;
57721:             NS_ASSERTION(!ILLEGAL_RANGE(ch), "U+0080/U+0100 - U+FFFF data lost");
57721:             *((char*)d) = char(ch);
    1:             break;
    1:         }
    1:     case nsXPTType::T_WCHAR  :
    1:         {
    1:             JSString* str;
48534:             if(!(str = JS_ValueToString(cx, s)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
59889:             size_t length;
59889:             const jschar* chars = JS_GetStringCharsAndLength(cx, str, &length);
59889:             if (!chars)
59889:             {
59889:                 return JS_FALSE;
59889:             }
59889:             if(length == 0)
48533:             {
48533:                 *((uint16*)d) = 0;
48533:                 break;
48533:             }
    1:             *((uint16*)d) = (uint16) chars[0];
    1:             break;
    1:         }
46230:     case nsXPTType::T_JSVAL :
48470:         {
51073:             if (useAllocator) {
48470:                 // The C++ type is (const jsval &), which here means (jsval *).
48470:                 jsval *buf = new jsval(s);
48470:                 if(!buf)
48470:                     return JS_FALSE;
48470:                 *((jsval**)d) = buf;
51073:             } else {
52510:                 *((jsval*)d) = s;
51073:             }
46230:             break;
48470:         }
    1:     default:
    1:         if(!type.IsPointer())
    1:         {
31561:             NS_ERROR("unsupported type");
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         switch(type.TagPart())
    1:         {
    1:         case nsXPTType::T_VOID:
    1:             XPC_LOG_ERROR(("XPCConvert::JSData2Native : void* params not supported"));
31561:             NS_ERROR("void* params not supported");
    1:             return JS_FALSE;
    1:         case nsXPTType::T_IID:
    1:         {
    1:             NS_ASSERTION(useAllocator,"trying to convert a JSID to nsID without allocator : this would leak");
    1: 
    1:             JSObject* obj;
    1:             const nsID* pid=nsnull;
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 // else ...
    1:                 *((const nsID**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             if(!JSVAL_IS_OBJECT(s) ||
    1:                (!(obj = JSVAL_TO_OBJECT(s))) ||
10204:                (!(pid = xpc_JSObjectToID(cx, obj))) ||
10204:                (!(pid = (const nsID*) nsMemory::Clone(pid, sizeof(nsID)))))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1:             *((const nsID**)d) = pid;
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_ASTRING:        
    1:         {            
    1:             isDOMString = JS_FALSE;
    1:             // Fall through to T_DOMSTRING case.
    1:         }
    1:         case nsXPTType::T_DOMSTRING:
    1:         {
    1:             static const PRUnichar EMPTY_STRING[] = { '\0' };
    1:             static const PRUnichar VOID_STRING[] = { 'u', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', '\0' };
    1: 
    1:             const PRUnichar* chars;
    1:             JSString* str = nsnull;
    1:             JSBool isNewString = JS_FALSE;
    1:             PRUint32 length;
    1: 
    1:             if(JSVAL_IS_VOID(s))
    1:             {
    1:                 if(isDOMString) 
    1:                 {
    1:                     chars  = VOID_STRING;
    1:                     length = NS_ARRAY_LENGTH(VOID_STRING) - 1;
    1:                 }
    1:                 else
    1:                 {
    1:                     chars = EMPTY_STRING;
    1:                     length = 0;
    1:                 }
    1:             }
    1:             else if(!JSVAL_IS_NULL(s))
    1:             {
    1:                 str = JS_ValueToString(cx, s);
    1:                 if(!str)
    1:                     return JS_FALSE;
    1: 
    1:                 length = (PRUint32) JS_GetStringLength(str);
    1:                 if(length)
    1:                 {
59889:                     chars = JS_GetStringCharsZ(cx, str);
    1:                     if(!chars)
    1:                         return JS_FALSE;
    1:                     if(STRING_TO_JSVAL(str) != s)
    1:                         isNewString = JS_TRUE;
    1:                 }
    1:                 else
    1:                 {
    1:                     str = nsnull;
    1:                     chars = EMPTY_STRING;
    1:                 }
    1:             }
    1: 
    1:             if(useAllocator)
    1:             {
    1:                 // XXX extra string copy when isNewString
    1:                 if(str && !isNewString)
    1:                 {
59889:                     size_t strLength;
59889:                     const jschar *strChars = JS_GetStringCharsZAndLength(cx, str, &strLength);
59889:                     if (!strChars)
59889:                         return JS_FALSE;
59889: 
    1:                     XPCReadableJSStringWrapper *wrapper =
59889:                         ccx.NewStringWrapper(strChars, strLength);
    1:                     if(!wrapper)
    1:                         return JS_FALSE;
    1: 
    1:                     *((const nsAString**)d) = wrapper;
    1:                 }
    1:                 else if(JSVAL_IS_NULL(s))
    1:                 {
    1:                     XPCReadableJSStringWrapper *wrapper =
    1:                         new XPCReadableJSStringWrapper();
    1:                     if(!wrapper)
    1:                         return JS_FALSE;
    1: 
    1:                     *((const nsAString**)d) = wrapper;
    1:                 }
    1:                 else
    1:                 {
    1:                     // use nsString to encourage sharing
    1:                     const nsAString *rs = new nsString(chars, length);
    1:                     if(!rs)
    1:                         return JS_FALSE;
    1:                     *((const nsAString**)d) = rs;
    1:                 }
    1:             }
    1:             else
    1:             {
    1:                 nsAString* ws = *((nsAString**)d);
    1: 
    1:                 if(JSVAL_IS_NULL(s) || (!isDOMString && JSVAL_IS_VOID(s)))
    1:                 {
    1:                     ws->Truncate();
    1:                     ws->SetIsVoid(PR_TRUE);
    1:                 }
    1:                 else
    1:                     ws->Assign(chars, length);
    1:             }
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_CHAR_STR:
    1:         {
57814:             NS_ASSERTION(useAllocator,"cannot convert a JSString to char * without allocator");
57814:             if(!useAllocator)
57814:             {
57814:                 NS_ERROR("bad type");
57814:                 return JS_FALSE;
57814:             }
    1:             
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 // else ...
    1:                 *((char**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
57814:             JSString* str = JS_ValueToString(cx, s);
57814:             if(!str)
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: #ifdef DEBUG
59889:             const jschar* chars=nsnull;
59889:             if(nsnull != (chars = JS_GetStringCharsZ(cx, str)))
    1:             {
    1:                 PRBool legalRange = PR_TRUE;
    1:                 int len = JS_GetStringLength(str);
59889:                 const jschar* t;
    1:                 PRInt32 i=0;
    1:                 for(t=chars; (i< len) && legalRange ; i++,t++) {
    1:                   if(ILLEGAL_RANGE(*t))
    1:                       legalRange = PR_FALSE;
    1:                 }
    1:                 NS_ASSERTION(legalRange,"U+0080/U+0100 - U+FFFF data lost");
    1:             }
    1: #endif // DEBUG
57814:             size_t length = JS_GetStringEncodingLength(cx, str);
57814:             if(length == size_t(-1))
    1:             {
    1:                 return JS_FALSE;
    1:             }
57814:             char *buffer = static_cast<char *>(nsMemory::Alloc(length + 1));
57814:             if(!buffer)
57814:             {
57814:                 return JS_FALSE;
    1:             }
57814:             JS_EncodeStringToBuffer(str, buffer, length);
57814:             buffer[length] = '\0';
57814:             *((void**)d) = buffer;
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_WCHAR_STR:
    1:         {
48533:             const jschar* chars=nsnull;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 // else ...
    1:                 *((jschar**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
48533:             if(!(str = JS_ValueToString(cx, s)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1:             if(useAllocator)
    1:             {
59889:                 if(!(chars = JS_GetStringCharsZ(cx, str)))
48533:                 {
48533:                     return JS_FALSE;
48533:                 }
48533:                 int len = JS_GetStringLength(str);
48533:                 int byte_len = (len+1)*sizeof(jschar);
    1:                 if(!(*((void**)d) = nsMemory::Alloc(byte_len)))
    1:                 {
    1:                     // XXX should report error
    1:                     return JS_FALSE;
    1:                 }
48533:                 jschar* destchars = *((jschar**)d);
48533:                 memcpy(destchars, chars, byte_len);
48533:                 destchars[len] = 0;
    1:             }
    1:             else
48533:             {
48533:                 if(!(chars = JS_GetStringCharsZ(cx, str)))
48533:                 {
48533:                     return JS_FALSE;
48533:                 }
48533:                 *((const jschar**)d) = chars;
48533:             }
    1: 
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_UTF8STRING:            
    1:         {
59889:             const jschar* chars;
    1:             PRUint32 length;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_NULL(s) || JSVAL_IS_VOID(s))
    1:             {
    1:                 if(useAllocator) 
    1:                 {
    1:                     nsACString *rs = new nsCString();
    1:                     if(!rs) 
    1:                         return JS_FALSE;
    1: 
    1:                     rs->SetIsVoid(PR_TRUE);
    1:                     *((nsACString**)d) = rs;
    1:                 }
    1:                 else
    1:                 {
    1:                     nsCString* rs = *((nsCString**)d);
    1:                     rs->Truncate();
    1:                     rs->SetIsVoid(PR_TRUE);
    1:                 }
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             // The JS val is neither null nor void...
    1: 
    1:             if(!(str = JS_ValueToString(cx, s))||
59889:                !(chars = JS_GetStringCharsZ(cx, str)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             length = JS_GetStringLength(str);
    1: 
    1:             nsCString *rs;
    1:             if(useAllocator)
    1:             {                
    1:                 // Use nsCString to enable sharing
    1:                 rs = new nsCString();
    1:                 if(!rs)
    1:                     return JS_FALSE;
    1: 
    1:                 *((const nsCString**)d) = rs;
    1:             }
    1:             else
    1:             {
    1:                 rs = *((nsCString**)d);
    1:             }
48533:             const PRUnichar* start = (const PRUnichar*)chars;
48533:             const PRUnichar* end = start + length;
48533:             CopyUTF16toUTF8(nsDependentSubstring(start, end), *rs);
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_CSTRING:
    1:         {
    1:             if(JSVAL_IS_NULL(s) || JSVAL_IS_VOID(s))
    1:             {
    1:                 if(useAllocator)
    1:                 {
    1:                     nsACString *rs = new nsCString();
    1:                     if(!rs) 
    1:                         return JS_FALSE;
    1: 
    1:                     rs->SetIsVoid(PR_TRUE);
    1:                     *((nsACString**)d) = rs;
    1:                 }
    1:                 else
    1:                 {
    1:                     nsACString* rs = *((nsACString**)d);
    1:                     rs->Truncate();
    1:                     rs->SetIsVoid(PR_TRUE);
    1:                 }
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             // The JS val is neither null nor void...
57814:             JSString* str = JS_ValueToString(cx, s);
57814:             if(!str)
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: 
57814:             size_t length = JS_GetStringEncodingLength(cx, str);
57814:             if(length == size_t(-1))
57814:             {
57814:                 return JS_FALSE;
57814:             }
    1: 
57814:             nsACString *rs;
    1:             if(useAllocator)
    1:             {
57814:                 rs = new nsCString();
    1:                 if(!rs)
    1:                     return JS_FALSE;
    1:                 *((const nsACString**)d) = rs;
    1:             }
    1:             else
    1:             {
57814:                 rs = *((nsACString**)d);
57814:             }
    1: 
57814:             rs->SetLength(PRUint32(length));
57818:             if(rs->Length() != PRUint32(length))
57818:             {
57818:                 return JS_FALSE;
    1:             }
57814:             JS_EncodeStringToBuffer(str, rs->BeginWriting(), length);
56353: 
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_INTERFACE:
    1:         case nsXPTType::T_INTERFACE_IS:
    1:         {
    1:             JSObject* obj;
    1:             NS_ASSERTION(iid,"can't do interface conversions without iid");
    1: 
    1:             if(iid->Equals(NS_GET_IID(nsIVariant)))
    1:             {
    1:                 XPCVariant* variant = XPCVariant::newVariant(ccx, s);
    1:                 if(!variant)
    1:                     return JS_FALSE;
 3233:                 *((nsISupports**)d) = static_cast<nsIVariant*>(variant);
    1:                 return JS_TRUE;
    1:             }
    1:             else if(iid->Equals(NS_GET_IID(nsIAtom)) &&
    1:                     JSVAL_IS_STRING(s))
    1:             {
    1:                 // We're trying to pass a string as an nsIAtom.  Let's atomize!
    1:                 JSString* str = JSVAL_TO_STRING(s);
59889:                 const PRUnichar* chars = JS_GetStringCharsZ(cx, str);
    1:                 if (!chars) {
    1:                     if (pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 PRUint32 length = JS_GetStringLength(str);
48533:                 nsIAtom* atom = NS_NewAtom(nsDependentSubstring(chars,
48533:                                              chars + length));
    1:                 if (!atom && pErr)
    1:                     *pErr = NS_ERROR_OUT_OF_MEMORY;
    1:                 *((nsISupports**)d) = atom;
    1:                 return atom != nsnull;                
    1:             }
    1:             //else ...
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1:                 // else ...
    1:                 *((nsISupports**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             // only wrap JSObjects
    1:             if(!JSVAL_IS_OBJECT(s) || !(obj = JSVAL_TO_OBJECT(s)))
    1:             {
    1:                 if(pErr && JSVAL_IS_INT(s) && 0 == JSVAL_TO_INT(s))
    1:                     *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_ZERO_ISNOT_NULL;
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             return JSObject2NativeInterface(ccx, (void**)d, obj, iid,
 5491:                                             nsnull, pErr);
    1:         }
    1:         default:
31561:             NS_ERROR("bad type");
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
22841: inline JSBool
22841: CreateHolderIfNeeded(XPCCallContext& ccx, JSObject* obj, jsval* d,
22147:                      nsIXPConnectJSObjectHolder** dest)
22147: {
22841:     if(dest)
22841:     {
22147:         XPCJSObjectHolder* objHolder = XPCJSObjectHolder::newHolder(ccx, obj);
22147:         if(!objHolder)
22147:             return JS_FALSE;
22147: 
22147:         NS_ADDREF(*dest = objHolder);
22841:     }
22841: 
22841:     *d = OBJECT_TO_JSVAL(obj);
22147: 
22147:     return JS_TRUE;
22147: }
22147: 
    1: /***************************************************************************/
    1: // static
    1: JSBool
31395: XPCConvert::NativeInterface2JSObject(XPCLazyCallContext& lccx,
22841:                                      jsval* d,
    1:                                      nsIXPConnectJSObjectHolder** dest,
51515:                                      xpcObjectHelper& aHelper,
    1:                                      const nsID* iid,
31395:                                      XPCNativeInterface** Interface,
    1:                                      PRBool allowNativeWrapper,
    1:                                      PRBool isGlobal,
51515:                                      nsresult* pErr)
    1: {
31395:     NS_ASSERTION(!Interface || iid,
31395:                  "Need the iid if you pass in an XPCNativeInterface cache.");
    1: 
22841:     *d = JSVAL_NULL;
22841:     if(dest)
    1:         *dest = nsnull;
51515:     nsISupports *src = aHelper.Object();
    1:     if(!src)
    1:         return JS_TRUE;
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
55577:     // We used to have code here that unwrapped and simply exposed the
55577:     // underlying JSObject. That caused anomolies when JSComponents were
55577:     // accessed from other JS code - they didn't act like other xpconnect
55577:     // wrapped components. So, instead, we create "double wrapped" objects
55577:     // (that means an XPCWrappedNative around an nsXPCWrappedJS). This isn't
55577:     // optimal -- we could detect this and roll the functionality into a
55577:     // single wrapper, but the current solution is good enough for now.
31395:     JSContext* cx = lccx.GetJSContext();
62405:     NS_ABORT_IF_FALSE(lccx.GetScopeForNewJSObjects()->compartment() == cx->compartment,
62405:                       "bad scope for new JSObjects");
31395: 
62405:     JSObject *jsscope = lccx.GetScopeForNewJSObjects();
    1:     XPCWrappedNativeScope* xpcscope =
62405:         XPCWrappedNativeScope::FindInJSObjectScope(cx, jsscope);
    1:     if(!xpcscope)
    1:         return JS_FALSE;
    1: 
55577:     // First, see if this object supports the wrapper cache.
55577:     // Note: If |cache->IsProxy()| is true, then it means that the object
55577:     // implementing it doesn't want a wrapped native as its JS Object, but
55577:     // instead it provides its own proxy object. In that case, the object
55577:     // to use is found as cache->GetWrapper(). If that is null, then the
55577:     // object will create (and fill the cache) from its PreCreate call.
51515:     nsWrapperCache *cache = aHelper.GetWrapperCache();
31395: 
31395:     PRBool tryConstructSlimWrapper = PR_FALSE;
30001:     JSObject *flat;
30001:     if(cache)
30001:     {
30001:         flat = cache->GetWrapper();
55573:         if(cache->IsProxy())
55573:         {
55573:             XPCCallContext &ccx = lccx.GetXPCCallContext();
55573:             if(!ccx.IsValid())
55573:                 return JS_FALSE;
55573: 
55577:             if(!flat)
55577:                 flat = ConstructProxyObject(ccx, aHelper, xpcscope);
55577: 
55600:             if(!JS_WrapObject(ccx, &flat))
55573:                 return JS_FALSE;
55573: 
55573:             return CreateHolderIfNeeded(ccx, flat, d, dest);
55573:         }
55573: 
30001:         if(!dest)
30001:         {
30001:             if(!flat)
30001:             {
31395:                 tryConstructSlimWrapper = PR_TRUE;
30001:             }
33785:             else if(IS_SLIM_WRAPPER_OBJECT(flat))
30001:             {
56353:                 if(flat->compartment() == cx->compartment)
30001:                 {
30001:                     *d = OBJECT_TO_JSVAL(flat);
30001:                     return JS_TRUE;
30001:                 }
30001:             }
30001:         }
30001:     }
30001:     else
30001:     {
30001:         flat = nsnull;
30001:     }
30001: 
55577:     // If we're not handing this wrapper to an nsIXPConnectJSObjectHolder, and
55577:     // the object supports slim wrappers, try to create one here.
31395:     if(tryConstructSlimWrapper)
31395:     {
31395:         XPCCallContext &ccx = lccx.GetXPCCallContext();
31395:         if(!ccx.IsValid())
31395:             return JS_FALSE;
31395: 
31395:         jsval slim;
51515:         if(ConstructSlimWrapper(ccx, aHelper, xpcscope, &slim))
31395:         {
31395:             *d = slim;
31395:             return JS_TRUE;
31395:         }
31395: 
31395:         // Even if ConstructSlimWrapper returns JS_FALSE it might have created a
31395:         // wrapper (while calling the PreCreate hook). In that case we need to
31395:         // fall through because we either have a slim wrapper that needs to be
55577:         // morphed or an XPCWrappedNative.
31395:         flat = cache->GetWrapper();
31395:     }
31395: 
55577:     // We can't simply construct a slim wrapper. Go ahead and create an
55577:     // XPCWrappedNative for this object. At this point, |flat| could be
55577:     // non-null, meaning that either we already have a wrapped native from
55577:     // the cache (which might need to be QI'd to the new interface) or that
55577:     // we found a slim wrapper that we'll have to morph.
31395:     AutoMarkingNativeInterfacePtr iface;
31395:     if(iid)
31395:     {
31395:         XPCCallContext &ccx = lccx.GetXPCCallContext();
31395:         if(!ccx.IsValid())
31395:             return JS_FALSE;
31395: 
31395:         iface.Init(ccx);
31395: 
31395:         if(Interface)
31395:             iface = *Interface;
31395: 
31395:         if(!iface)
22842:         {
    1:             iface = XPCNativeInterface::GetNewOrUsed(ccx, iid);
    1:             if(!iface)
    1:                 return JS_FALSE;
31395: 
31395:             if(Interface)
31395:                 *Interface = iface;
31395:         }
22842:     }
    1: 
55577:     NS_ASSERTION(!flat || IS_WRAPPER_CLASS(flat->getClass()),
33785:                  "What kind of wrapper is this?");
33785: 
21618:     nsresult rv;
    1:     XPCWrappedNative* wrapper;
22841:     nsRefPtr<XPCWrappedNative> strongWrapper;
30001:     if(!flat)
21618:     {
31395:         XPCCallContext &ccx = lccx.GetXPCCallContext();
31395:         if(!ccx.IsValid())
31395:             return JS_FALSE;
31395: 
51515:         rv = XPCWrappedNative::GetNewOrUsed(ccx, aHelper, xpcscope, iface,
51515:                                             isGlobal,
30001:                                             getter_AddRefs(strongWrapper));
30001: 
30001:         wrapper = strongWrapper;
30001:     }
33785:     else if(IS_WN_WRAPPER_OBJECT(flat))
30001:     {
30001:         wrapper = static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat));
30001: 
22841:         // If asked to return the wrapper we'll return a strong reference,
30001:         // otherwise we'll just return its JSObject in d (which should be
22841:         // rooted in that case).
22841:         if(dest)
22841:             strongWrapper = wrapper;
31395:         // If iface is not null we know lccx.GetXPCCallContext() returns
31395:         // a valid XPCCallContext because we checked when calling Init on
31395:         // iface.
22842:         if(iface)
31395:             wrapper->FindTearOff(lccx.GetXPCCallContext(), iface, JS_FALSE,
31395:                                  &rv);
22842:         else
22842:             rv = NS_OK;
21618:     }
55577:     else
21618:     {
30001:         NS_ASSERTION(IS_SLIM_WRAPPER(flat),
30001:                      "What kind of wrapper is this?");
31395: 
31395:         XPCCallContext &ccx = lccx.GetXPCCallContext();
31395:         if(!ccx.IsValid())
31395:             return JS_FALSE;
31395: 
30001:         SLIM_LOG(("***** morphing from XPCConvert::NativeInterface2JSObject"
30001:                   "(%p)\n",
30001:                   static_cast<nsISupports*>(xpc_GetJSPrivate(flat))));
30001: 
30001:         rv = XPCWrappedNative::Morph(ccx, flat, iface, cache,
22841:                                      getter_AddRefs(strongWrapper));
22841:         wrapper = strongWrapper;
21618:     }
21618: 
    1:     if(pErr)
    1:         *pErr = rv;
55577: 
55577:     // If creating the wrapped native failed, then return early.
55577:     if(NS_FAILED(rv) || !wrapper)
55577:         return JS_FALSE;
55577: 
55577:     // If we're not creating security wrappers, we can return the
55577:     // XPCWrappedNative as-is here.
62690:     flat = wrapper->GetFlatJSObject();
55577:     jsval v = OBJECT_TO_JSVAL(flat);
55577:     if(!XPCPerThreadData::IsMainThread(lccx.GetJSContext()) ||
55577:        !allowNativeWrapper)
    1:     {
55577:         *d = v;
55577:         if(dest)
55577:             *dest = strongWrapper.forget().get();
55577:         return JS_TRUE;
55577:     }
55577: 
31395:     XPCCallContext &ccx = lccx.GetXPCCallContext();
31395:     if(!ccx.IsValid())
31395:         return JS_FALSE;
31395: 
55600:     JSObject *original = flat;
55600:     if(!JS_WrapObject(ccx, &flat))
55577:         return JS_FALSE;
55617: 
55617:     // If the object was not wrapped, we are same compartment and don't need
55617:     // to enforce any cross origin policies, except in case of the location
55617:     // object, which always needs a wrapper in between.
55617:     if(original == flat)
55617:     {
55617:         if(xpc::WrapperFactory::IsLocationObject(flat))
55617:         {
55617:             JSObject *locationWrapper = wrapper->GetWrapper();
55617:             if(!locationWrapper)
55617:             {
55617:                 locationWrapper = xpc::WrapperFactory::WrapLocationObject(cx, flat);
55617:                 if(!locationWrapper)
55617:                     return JS_FALSE;
55617: 
55617:                 // Cache the location wrapper to ensure that we maintain
55617:                 // the identity of window/document.location.
55617:                 wrapper->SetWrapper(locationWrapper);
55617:             }
55617: 
55617:             flat = locationWrapper;
55617:         }
55700:         else if(wrapper->NeedsSOW() &&
55700:                 !xpc::AccessCheck::isChrome(cx->compartment))
55700:         {
55700:             JSObject *sowWrapper = wrapper->GetWrapper();
55700:             if(!sowWrapper)
55700:             {
55700:                 sowWrapper = xpc::WrapperFactory::WrapSOWObject(cx, flat);
55700:                 if(!sowWrapper)
55700:                     return JS_FALSE;
55700: 
55700:                 // Cache the sow wrapper to ensure that we maintain
55700:                 // the identity of this node.
55700:                 wrapper->SetWrapper(sowWrapper);
55700:             }
55700: 
55700:             flat = sowWrapper;
55700:         }
55693:         else
55693:         {
55693:             OBJ_TO_OUTER_OBJECT(cx, flat);
55693:             NS_ASSERTION(flat, "bad outer object hook!");
61451:             NS_ASSERTION(flat->compartment() == cx->compartment,
55693:                          "bad compartment");
55693:         }
55617:     }
55617: 
55600:     *d = OBJECT_TO_JSVAL(flat);
55577: 
55577:     if(dest)
    1:     {
55577:         // The strongWrapper still holds the original flat object.
55600:         if(flat == original)
12584:         {
55577:             *dest = strongWrapper.forget().get();
20762:         }
20762:         else
20762:         {
55577:             nsRefPtr<XPCJSObjectHolder> objHolder =
55600:                 XPCJSObjectHolder::newHolder(ccx, flat);
55577:             if(!objHolder)
55577:                 return JS_FALSE;
55577: 
55577:             *dest = objHolder.forget().get();
20762:         }
20762:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::JSObject2NativeInterface(XPCCallContext& ccx,
    1:                                      void** dest, JSObject* src,
    1:                                      const nsID* iid,
    1:                                      nsISupports* aOuter,
    1:                                      nsresult* pErr)
    1: {
    1:     NS_ASSERTION(dest, "bad param");
    1:     NS_ASSERTION(src, "bad param");
    1:     NS_ASSERTION(iid, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
55601:     JSAutoEnterCompartment ac;
55601: 
55601:     if(!ac.enter(cx, src))
55601:     {
55601:        if(pErr)
55601:            *pErr = NS_ERROR_UNEXPECTED;
55601:        return PR_FALSE;
55601:     }
55601: 
    1:     *dest = nsnull;
    1:      if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
    1: 
    1:     nsISupports* iface;
    1: 
    1:     if(!aOuter)
    1:     {
    1:         // Note that if we have a non-null aOuter then it means that we are
    1:         // forcing the creation of a wrapper even if the object *is* a 
    1:         // wrappedNative or other wise has 'nsISupportness'. 
    1:         // This allows wrapJSAggregatedToNative to work.
    1: 
33306:         // If we're looking at a security wrapper, see now if we're allowed to
33306:         // pass it to C++. If we are, then fall through to the code below. If
33306:         // we aren't, throw an exception eagerly.
33306:         JSObject* inner = nsnull;
33306:         if(XPCWrapper::IsSecurityWrapper(src))
33306:         {
33306:             inner = XPCWrapper::Unwrap(cx, src);
33306:             if(!inner)
33306:             {
33306:                 if(pErr)
33306:                     *pErr = NS_ERROR_XPC_SECURITY_MANAGER_VETO;
33306:                 return JS_FALSE;
33306:             }
33306:         }
33306: 
    1:         // Is this really a native xpcom object with a wrapper?
    1:         XPCWrappedNative* wrappedNative =
33306:                     XPCWrappedNative::GetWrappedNativeOfJSObject(cx,
33306:                                                                  inner
33306:                                                                  ? inner
33306:                                                                  : src);
    1:         if(wrappedNative)
    1:         {
    1:             iface = wrappedNative->GetIdentityObject();
    1:             return NS_SUCCEEDED(iface->QueryInterface(*iid, dest));
    1:         }
    1:         // else...
    1: 
    1:         // XXX E4X breaks the world. Don't try wrapping E4X objects!
    1:         // This hack can be removed (or changed accordingly) when the
    1:         // DOM <-> E4X bindings are complete, see bug 270553
    1:         if(JS_TypeOfValue(cx, OBJECT_TO_JSVAL(src)) == JSTYPE_XML)
    1:             return JS_FALSE;
32833: 
33306:         // Deal with slim wrappers here.
32833:         if(GetISupportsFromJSObject(src, &iface))
32833:         {
32833:             if(iface)
32833:                 return NS_SUCCEEDED(iface->QueryInterface(*iid, dest));
32833: 
32833:             return JS_FALSE;
32833:         }
    1:     }
    1: 
    1:     // else...
    1: 
    1:     nsXPCWrappedJS* wrapper;
 5491:     nsresult rv = nsXPCWrappedJS::GetNewOrUsed(ccx, src, *iid, aOuter, &wrapper);
    1:     if(pErr)
    1:         *pErr = rv;
    1:     if(NS_SUCCEEDED(rv) && wrapper)
    1:     {
    1:         // We need to go through the QueryInterface logic to make this return
    1:         // the right thing for the various 'special' interfaces; e.g. 
    1:         // nsIPropertyBag. We must use AggregatedQueryInterface in cases where 
    1:         // there is an outer to avoid nasty recursion.
    1:         rv = aOuter ? wrapper->AggregatedQueryInterface(*iid, dest) :
    1:                       wrapper->QueryInterface(*iid, dest);
    1:         if(pErr)
    1:             *pErr = rv;
    1:         NS_RELEASE(wrapper);
    1:         return NS_SUCCEEDED(rv);        
    1:     }
    1: 
    1:     // else...
    1:     return JS_FALSE;
    1: }
    1: 
    1: /***************************************************************************/
    1: /***************************************************************************/
    1: 
    1: // static
    1: nsresult
    1: XPCConvert::ConstructException(nsresult rv, const char* message,
    1:                                const char* ifaceName, const char* methodName,
    1:                                nsISupports* data,
19303:                                nsIException** exceptn,
21377:                                JSContext* cx,
21377:                                jsval* jsExceptionPtr)
    1: {
21377:     NS_ASSERTION(!cx == !jsExceptionPtr, "Expected cx and jsExceptionPtr to cooccur.");
21377: 
    1:     static const char format[] = "\'%s\' when calling method: [%s::%s]";
    1:     const char * msg = message;
    1:     char* sz = nsnull;
    1:     nsXPIDLString xmsg;
    1:     nsCAutoString sxmsg;
    1: 
    1:     nsCOMPtr<nsIScriptError> errorObject = do_QueryInterface(data);
    1:     if(errorObject) {
11566:         if (NS_SUCCEEDED(errorObject->GetMessageMoz(getter_Copies(xmsg)))) {
    1:             CopyUTF16toUTF8(xmsg, sxmsg);
    1:             msg = sxmsg.get();
    1:         }
    1:     }
    1:     if(!msg)
    1:         if(!nsXPCException::NameAndFormatForNSResult(rv, nsnull, &msg) || ! msg)
    1:             msg = "<error>";
    1:     if(ifaceName && methodName)
    1:         msg = sz = JS_smprintf(format, msg, ifaceName, methodName);
    1: 
    1:     nsresult res = nsXPCException::NewException(msg, rv, nsnull, data, exceptn);
    1: 
21377:     if(NS_SUCCEEDED(res) && cx && jsExceptionPtr && *exceptn)
19303:     {
27587:         nsCOMPtr<nsIXPCException> xpcEx = do_QueryInterface(*exceptn);
19303:         if(xpcEx)
27587:             xpcEx->StowJSVal(cx, *jsExceptionPtr);
19303:     }
19303: 
    1:     if(sz)
    1:         JS_smprintf_free(sz);
    1:     return res;
    1: }
    1: 
    1: /********************************/
    1: 
40402: class AutoExceptionRestorer
20444: {
20444: public:
20444:     AutoExceptionRestorer(JSContext *cx, jsval v)
40402:         : mContext(cx), tvr(cx, v)
20444:     {
20444:         JS_ClearPendingException(mContext);
20444:     }
20444: 
20444:     ~AutoExceptionRestorer()
20444:     {
48470:         JS_SetPendingException(mContext, tvr.jsval_value());
20444:     }
20444: 
20444: private:
40402:     JSContext * const mContext;
40402:     js::AutoValueRooter tvr;
20444: };
20444: 
    1: // static
    1: nsresult
    1: XPCConvert::JSValToXPCException(XPCCallContext& ccx,
    1:                                 jsval s,
    1:                                 const char* ifaceName,
    1:                                 const char* methodName,
    1:                                 nsIException** exceptn)
    1: {
    1:     JSContext* cx = ccx.GetJSContext();
20444:     AutoExceptionRestorer aer(cx, s);
    1: 
    1:     if(!JSVAL_IS_PRIMITIVE(s))
    1:     {
    1:         // we have a JSObject
    1:         JSObject* obj = JSVAL_TO_OBJECT(s);
    1: 
    1:         if(!obj)
    1:         {
31561:             NS_ERROR("when is an object not an object?");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         // is this really a native xpcom object with a wrapper?
    1:         XPCWrappedNative* wrapper;
    1:         if(nsnull != (wrapper =
    1:            XPCWrappedNative::GetWrappedNativeOfJSObject(cx,obj)))
    1:         {
    1:             nsISupports* supports = wrapper->GetIdentityObject();
    1:             nsCOMPtr<nsIException> iface = do_QueryInterface(supports);
    1:             if(iface)
    1:             {
    1:                 // just pass through the exception (with extra ref and all)
    1:                 nsIException* temp = iface;
    1:                 NS_ADDREF(temp);
    1:                 *exceptn = temp;
    1:                 return NS_OK;
    1:             }
    1:             else
    1:             {
    1:                 // it is a wrapped native, but not an exception!
    1:                 return ConstructException(NS_ERROR_XPC_JS_THREW_NATIVE_OBJECT,
    1:                                           nsnull, ifaceName, methodName, supports,
21377:                                           exceptn, nsnull, nsnull);
    1:             }
    1:         }
    1:         else
    1:         {
    1:             // It is a JSObject, but not a wrapped native...
    1: 
    1:             // If it is an engine Error with an error report then let's
    1:             // extract the report and build an xpcexception from that
    1:             const JSErrorReport* report;
    1:             if(nsnull != (report = JS_ErrorFromException(cx, s)))
    1:             {
57812:                 JSAutoByteString message;
    1:                 JSString* str;
    1:                 if(nsnull != (str = JS_ValueToString(cx, s)))
57812:                     message.encode(cx, str);
57812:                 return JSErrorToXPCException(ccx, message.ptr(), ifaceName,
    1:                                              methodName, report, exceptn);
    1:             }
    1: 
    1: 
    1:             uintN ignored;
    1:             JSBool found;
    1: 
    1:             // heuristic to see if it might be usable as an xpcexception
67694:             if(!JS_GetPropertyAttributes(cx, obj, "message", &ignored, &found))
67694:                return NS_ERROR_FAILURE;
67694: 
67694:             if(found && !JS_GetPropertyAttributes(cx, obj, "result", &ignored, &found))
67694:                 return NS_ERROR_FAILURE;
67694: 
67694:             if(found)
    1:             {
    1:                 // lets try to build a wrapper around the JSObject
    1:                 nsXPCWrappedJS* jswrapper;
    1:                 nsresult rv =
    1:                     nsXPCWrappedJS::GetNewOrUsed(ccx, obj,
    1:                                                  NS_GET_IID(nsIException),
    1:                                                  nsnull, &jswrapper);
    1:                 if(NS_FAILED(rv))
    1:                     return rv;
67694: 
67694:                 *exceptn = static_cast<nsIException *>(jswrapper->GetXPTCStub());
    1:                 return NS_OK;
    1:             }
    1: 
    1: 
    1:             // XXX we should do a check against 'js_ErrorClass' here and
    1:             // do the right thing - even though it has no JSErrorReport,
    1:             // The fact that it is a JSError exceptions means we can extract
    1:             // particular info and our 'result' should reflect that.
    1: 
    1:             // otherwise we'll just try to convert it to a string
    1: 
    1:             JSString* str = JS_ValueToString(cx, s);
    1:             if(!str)
    1:                 return NS_ERROR_FAILURE;
    1: 
57812:             JSAutoByteString strBytes(cx, str);
57812:             if (!strBytes)
57812:                 return NS_ERROR_FAILURE;
57812: 
    1:             return ConstructException(NS_ERROR_XPC_JS_THREW_JS_OBJECT,
57812:                                       strBytes.ptr(), ifaceName, methodName,
57812:                                       nsnull, exceptn, cx, &s);
    1:         }
    1:     }
    1: 
    1:     if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:     {
    1:         return ConstructException(NS_ERROR_XPC_JS_THREW_NULL,
    1:                                   nsnull, ifaceName, methodName, nsnull,
21377:                                   exceptn, cx, &s);
    1:     }
    1: 
    1:     if(JSVAL_IS_NUMBER(s))
    1:     {
    1:         // lets see if it looks like an nsresult
    1:         nsresult rv;
    1:         double number;
    1:         JSBool isResult = JS_FALSE;
    1: 
    1:         if(JSVAL_IS_INT(s))
    1:         {
    1:             rv = (nsresult) JSVAL_TO_INT(s);
    1:             if(NS_FAILED(rv))
    1:                 isResult = JS_TRUE;
    1:             else
    1:                 number = (double) JSVAL_TO_INT(s);
    1:         }
    1:         else
    1:         {
48470:             number = JSVAL_TO_DOUBLE(s);
    1:             if(number > 0.0 &&
    1:                number < (double)0xffffffff &&
    1:                0.0 == fmod(number,1))
    1:             {
    1:                 rv = (nsresult) number;
    1:                 if(NS_FAILED(rv))
    1:                     isResult = JS_TRUE;
    1:             }
    1:         }
    1: 
    1:         if(isResult)
    1:             return ConstructException(rv, nsnull, ifaceName, methodName,
21377:                                       nsnull, exceptn, cx, &s);
    1:         else
    1:         {
19303:             // XXX all this nsISupportsDouble code seems a little redundant
19303:             // now that we're storing the jsval in the exception...
    1:             nsISupportsDouble* data;
    1:             nsCOMPtr<nsIComponentManager> cm;
    1:             if(NS_FAILED(NS_GetComponentManager(getter_AddRefs(cm))) || !cm ||
    1:                NS_FAILED(cm->CreateInstanceByContractID(
    1:                                 NS_SUPPORTS_DOUBLE_CONTRACTID,
    1:                                 nsnull,
    1:                                 NS_GET_IID(nsISupportsDouble),
    1:                                 (void**)&data)))
    1:                 return NS_ERROR_FAILURE;
    1:             data->SetData(number);
    1:             rv = ConstructException(NS_ERROR_XPC_JS_THREW_NUMBER, nsnull,
21377:                                     ifaceName, methodName, data, exceptn, cx, &s);
    1:             NS_RELEASE(data);
    1:             return rv;
    1:         }
    1:     }
    1: 
    1:     // otherwise we'll just try to convert it to a string
19303:     // Note: e.g., JSBools get converted to JSStrings by this code.
    1: 
    1:     JSString* str = JS_ValueToString(cx, s);
    1:     if(str)
57812:     {
57812:         JSAutoByteString strBytes(cx, str);
57812:         if(!!strBytes)
57812:         {
    1:             return ConstructException(NS_ERROR_XPC_JS_THREW_STRING,
57812:                                       strBytes.ptr(), ifaceName, methodName,
57812:                                       nsnull, exceptn, cx, &s);
57812:         }
57812:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /********************************/
    1: 
    1: // static
    1: nsresult
    1: XPCConvert::JSErrorToXPCException(XPCCallContext& ccx,
    1:                                   const char* message,
    1:                                   const char* ifaceName,
    1:                                   const char* methodName,
    1:                                   const JSErrorReport* report,
    1:                                   nsIException** exceptn)
    1: {
    1:     nsresult rv = NS_ERROR_FAILURE;
59512:     nsRefPtr<nsScriptError> data;
    1:     if(report)
    1:     {
    1:         nsAutoString bestMessage;
    1:         if(report && report->ucmessage)
    1:         {
    1:             bestMessage = (const PRUnichar *)report->ucmessage;
    1:         }
    1:         else if(message)
    1:         {
    1:             bestMessage.AssignWithConversion(message);
    1:         }
    1:         else
    1:         {
    1:             bestMessage.AssignLiteral("JavaScript Error");
    1:         }
    1: 
    1:         data = new nsScriptError();
    1:         if(!data)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
59512: 
59512:         data->InitWithWindowID(bestMessage.get(),
    1:                                NS_ConvertASCIItoUTF16(report->filename).get(),
    1:                                (const PRUnichar *)report->uclinebuf, report->lineno,
    1:                                report->uctokenptr - report->uclinebuf, report->flags,
59512:                                "XPConnect JavaScript",
59512:                                nsJSUtils::GetCurrentlyRunningCodeWindowID(ccx.GetJSContext()));
    1:     }
    1: 
    1:     if(data)
    1:     {
    1:         nsCAutoString formattedMsg;
    1:         data->ToString(formattedMsg);
    1: 
    1:         rv = ConstructException(NS_ERROR_XPC_JAVASCRIPT_ERROR_WITH_DETAILS,
56273:                                 formattedMsg.get(), ifaceName, methodName,
59512:                                 static_cast<nsIScriptError*>(data.get()),
21377:                                 exceptn, nsnull, nsnull);
    1:     }
    1:     else
    1:     {
    1:         rv = ConstructException(NS_ERROR_XPC_JAVASCRIPT_ERROR,
    1:                                 nsnull, ifaceName, methodName, nsnull,
21377:                                 exceptn, nsnull, nsnull);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: /***************************************************************************/
    1: 
    1: /*
    1: ** Note: on some platforms va_list is defined as an array,
    1: ** and requires array notation.
    1: */
    1: #ifdef HAVE_VA_COPY
    1: #define VARARGS_ASSIGN(foo, bar)	VA_COPY(foo,bar)
    1: #elif defined(HAVE_VA_LIST_AS_ARRAY)
    1: #define VARARGS_ASSIGN(foo, bar)	foo[0] = bar[0]
    1: #else
    1: #define VARARGS_ASSIGN(foo, bar)	(foo) = (bar)
    1: #endif
    1: 
    1: // We assert below that these formats all begin with "%i".
    1: const char* XPC_ARG_FORMATTER_FORMAT_STRINGS[] = {"%ip", "%iv", "%is", nsnull};
    1: 
18907: JSBool
    1: XPC_JSArgumentFormatter(JSContext *cx, const char *format,
    1:                         JSBool fromJS, jsval **vpp, va_list *app)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, cx);
    1:     if(!ccx.IsValid())
    1:         return JS_FALSE;
    1: 
    1:     jsval *vp;
    1:     va_list ap;
    1: 
    1:     vp = *vpp;
    1:     VARARGS_ASSIGN(ap, *app);
    1: 
    1:     nsXPTType type;
    1:     const nsIID* iid;
    1:     void* p;
    1: 
    1:     NS_ASSERTION(format[0] == '%' && format[1] == 'i', "bad format!");
    1:     char which = format[2];
    1: 
    1:     if(fromJS)
    1:     {
    1:         switch(which)
    1:         {
    1:             case 'p':
    1:                 type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));                
    1:                 iid = &NS_GET_IID(nsISupports);
    1:                 break;
    1:             case 'v':
    1:                 type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));                
    1:                 iid = &NS_GET_IID(nsIVariant);
    1:                 break;
    1:             case 's':
    1:                 type = nsXPTType((uint8)(TD_DOMSTRING | XPT_TDP_POINTER));                
    1:                 iid = nsnull;
    1:                 p = va_arg(ap, void *);
    1:                 break;
    1:             default:
    1:                 NS_ERROR("bad format!");
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         if(!XPCConvert::JSData2Native(ccx, &p, vp[0], type, JS_FALSE,
    1:                                       iid, nsnull))
    1:             return JS_FALSE;
    1:         
    1:         if(which != 's')
    1:             *va_arg(ap, void **) = p;
    1:     }
    1:     else
    1:     {
    1:         switch(which)
    1:         {
    1:             case 'p':
    1:                 type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));                
    1:                 iid  = va_arg(ap, const nsIID*);
    1:                 break;
    1:             case 'v':
    1:                 type = nsXPTType((uint8)(TD_INTERFACE_TYPE | XPT_TDP_POINTER));                
    1:                 iid = &NS_GET_IID(nsIVariant);
    1:                 break;
    1:             case 's':
    1:                 type = nsXPTType((uint8)(TD_DOMSTRING | XPT_TDP_POINTER));                
    1:                 iid = nsnull;
    1:                 break;
    1:             default:
    1:                 NS_ERROR("bad format!");
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         // NOTE: MUST be retrieved *after* the iid in the 'p' case above.
    1:         p = va_arg(ap, void *);
    1: 
62405:         ccx.SetScopeForNewJSObjects(JS_GetGlobalForScopeChain(cx));
62405:         if(!XPCConvert::NativeData2JS(ccx, &vp[0], &p, type, iid, nsnull))
    1:             return JS_FALSE;
    1:     }
    1:     *vpp = vp + 1;
    1:     VARARGS_ASSIGN(*app, ap);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: // array fun...
    1: 
    1: #ifdef POPULATE
    1: #undef POPULATE
    1: #endif
    1: 
    1: // static
    1: JSBool
31395: XPCConvert::NativeArray2JS(XPCLazyCallContext& lccx,
    1:                            jsval* d, const void** s,
    1:                            const nsXPTType& type, const nsID* iid,
62405:                            JSUint32 count, nsresult* pErr)
    1: {
    1:     NS_PRECONDITION(s, "bad param");
    1:     NS_PRECONDITION(d, "bad param");
    1: 
31395:     XPCCallContext& ccx = lccx.GetXPCCallContext();
31395:     if(!ccx.IsValid())
31395:         return JS_FALSE;
31395: 
    1:     JSContext* cx = ccx.GetJSContext();
62405:     NS_ABORT_IF_FALSE(lccx.GetScopeForNewJSObjects()->compartment() == cx->compartment,
62405:                       "bad scope for new JSObjects");
    1: 
    1:     // XXX add support for putting chars in a string rather than an array
    1: 
    1:     // XXX add support to indicate *which* array element was not convertable
    1: 
    1:     JSObject *array = JS_NewArrayObject(cx, count, nsnull);
    1: 
    1:     if(!array)
    1:         return JS_FALSE;
    1: 
    1:     // root this early
    1:     *d = OBJECT_TO_JSVAL(array);
    1:     AUTO_MARK_JSVAL(ccx, d);
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1:     JSUint32 i;
    1:     jsval current = JSVAL_NULL;
    1:     AUTO_MARK_JSVAL(ccx, &current);
    1: 
    1: #define POPULATE(_t)                                                         \
    1:     PR_BEGIN_MACRO                                                           \
    1:         for(i = 0; i < count; i++)                                           \
    1:         {                                                                    \
62405:             if(!NativeData2JS(ccx, &current, ((_t*)*s)+i, type, iid, pErr) ||\
    1:                !JS_SetElement(cx, array, i, &current))                       \
    1:                 goto failure;                                                \
    1:         }                                                                    \
    1:     PR_END_MACRO
    1: 
    1:     // XXX check IsPtr - esp. to handle array of nsID (as opposed to nsID*)
    1: 
    1:     switch(type.TagPart())
    1:     {
    1:     case nsXPTType::T_I8            : POPULATE(int8);           break;
    1:     case nsXPTType::T_I16           : POPULATE(int16);          break;
    1:     case nsXPTType::T_I32           : POPULATE(int32);          break;
    1:     case nsXPTType::T_I64           : POPULATE(int64);          break;
    1:     case nsXPTType::T_U8            : POPULATE(uint8);          break;
    1:     case nsXPTType::T_U16           : POPULATE(uint16);         break;
    1:     case nsXPTType::T_U32           : POPULATE(uint32);         break;
    1:     case nsXPTType::T_U64           : POPULATE(uint64);         break;
    1:     case nsXPTType::T_FLOAT         : POPULATE(float);          break;
    1:     case nsXPTType::T_DOUBLE        : POPULATE(double);         break;
    1:     case nsXPTType::T_BOOL          : POPULATE(PRBool);         break;
    1:     case nsXPTType::T_CHAR          : POPULATE(char);           break;
    1:     case nsXPTType::T_WCHAR         : POPULATE(jschar);         break;
31561:     case nsXPTType::T_VOID          : NS_ERROR("bad type"); goto failure;
    1:     case nsXPTType::T_IID           : POPULATE(nsID*);          break;
31561:     case nsXPTType::T_DOMSTRING     : NS_ERROR("bad type"); goto failure;
    1:     case nsXPTType::T_CHAR_STR      : POPULATE(char*);          break;
    1:     case nsXPTType::T_WCHAR_STR     : POPULATE(jschar*);        break;
    1:     case nsXPTType::T_INTERFACE     : POPULATE(nsISupports*);   break;
    1:     case nsXPTType::T_INTERFACE_IS  : POPULATE(nsISupports*);   break;
31561:     case nsXPTType::T_UTF8STRING    : NS_ERROR("bad type"); goto failure;
31561:     case nsXPTType::T_CSTRING       : NS_ERROR("bad type"); goto failure;
31561:     case nsXPTType::T_ASTRING       : NS_ERROR("bad type"); goto failure;
31561:     default                         : NS_ERROR("bad type"); goto failure;
    1:     }
    1: 
    1:     if(pErr)
    1:         *pErr = NS_OK;
    1:     return JS_TRUE;
    1: 
    1: failure:
    1:     return JS_FALSE;
    1: 
    1: #undef POPULATE
    1: }
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::JSArray2Native(XPCCallContext& ccx, void** d, jsval s,
    1:                            JSUint32 count, JSUint32 capacity,
    1:                            const nsXPTType& type,
    1:                            JSBool useAllocator, const nsID* iid,
    1:                            uintN* pErr)
    1: {
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     // No Action, FRee memory, RElease object
    1:     enum CleanupMode {na, fr, re};
    1: 
    1:     CleanupMode cleanupMode;
    1: 
    1:     JSObject* jsarray = nsnull;
    1:     void* array = nsnull;
    1:     JSUint32 initedCount;
    1:     jsval current;
    1: 
    1:     // XXX add support for getting chars from strings
    1: 
    1:     // XXX add support to indicate *which* array element was not convertable
    1: 
    1:     if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:     {
    1:         if(0 != count)
    1:         {
    1:             if(pErr)
    1:                 *pErr = NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY;
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         // If a non-zero capacity was indicated then we build an
    1:         // empty array rather than return nsnull.
    1:         if(0 != capacity)
    1:             goto fill_array;
    1: 
    1:         *d = nsnull;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     if(!JSVAL_IS_OBJECT(s))
    1:     {
    1:         if(pErr)
    1:             *pErr = NS_ERROR_XPC_CANT_CONVERT_PRIMITIVE_TO_ARRAY;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     jsarray = JSVAL_TO_OBJECT(s);
    1:     if(!JS_IsArrayObject(cx, jsarray))
    1:     {
    1:         if(pErr)
    1:             *pErr = NS_ERROR_XPC_CANT_CONVERT_OBJECT_TO_ARRAY;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     jsuint len;
    1:     if(!JS_GetArrayLength(cx, jsarray, &len) || len < count || capacity < count)
    1:     {
    1:         if(pErr)
    1:             *pErr = NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS;
    1: 
    1: #define POPULATE(_mode, _t)                                                  \
    1:     PR_BEGIN_MACRO                                                           \
    1:         cleanupMode = _mode;                                                 \
39337:         if (capacity > PR_UINT32_MAX / sizeof(_t) ||                         \
    1:             nsnull == (array = nsMemory::Alloc(capacity * sizeof(_t))))      \
    1:         {                                                                    \
    1:             if(pErr)                                                         \
    1:                 *pErr = NS_ERROR_OUT_OF_MEMORY;                              \
    1:             goto failure;                                                    \
    1:         }                                                                    \
    1:         for(initedCount = 0; initedCount < count; initedCount++)             \
    1:         {                                                                    \
    1:             if(!JS_GetElement(cx, jsarray, initedCount, &current) ||         \
    1:                !JSData2Native(ccx, ((_t*)array)+initedCount, current, type,  \
    1:                               useAllocator, iid, pErr))                      \
    1:                 goto failure;                                                \
    1:         }                                                                    \
    1:     PR_END_MACRO
    1: 
    1: 
    1:     // XXX check IsPtr - esp. to handle array of nsID (as opposed to nsID*)
    1: 
    1:     // XXX make extra space at end of char* and wchar* and null termintate
    1: 
    1: fill_array:
    1:     switch(type.TagPart())
    1:     {
    1:     case nsXPTType::T_I8            : POPULATE(na, int8);           break;
    1:     case nsXPTType::T_I16           : POPULATE(na, int16);          break;
    1:     case nsXPTType::T_I32           : POPULATE(na, int32);          break;
    1:     case nsXPTType::T_I64           : POPULATE(na, int64);          break;
    1:     case nsXPTType::T_U8            : POPULATE(na, uint8);          break;
    1:     case nsXPTType::T_U16           : POPULATE(na, uint16);         break;
    1:     case nsXPTType::T_U32           : POPULATE(na, uint32);         break;
    1:     case nsXPTType::T_U64           : POPULATE(na, uint64);         break;
    1:     case nsXPTType::T_FLOAT         : POPULATE(na, float);          break;
    1:     case nsXPTType::T_DOUBLE        : POPULATE(na, double);         break;
    1:     case nsXPTType::T_BOOL          : POPULATE(na, PRBool);         break;
    1:     case nsXPTType::T_CHAR          : POPULATE(na, char);           break;
    1:     case nsXPTType::T_WCHAR         : POPULATE(na, jschar);         break;
31561:     case nsXPTType::T_VOID          : NS_ERROR("bad type"); goto failure;
    1:     case nsXPTType::T_IID           : POPULATE(fr, nsID*);          break;
31561:     case nsXPTType::T_DOMSTRING     : NS_ERROR("bad type"); goto failure;
    1:     case nsXPTType::T_CHAR_STR      : POPULATE(fr, char*);          break;
    1:     case nsXPTType::T_WCHAR_STR     : POPULATE(fr, jschar*);        break;
    1:     case nsXPTType::T_INTERFACE     : POPULATE(re, nsISupports*);   break;
    1:     case nsXPTType::T_INTERFACE_IS  : POPULATE(re, nsISupports*);   break;
31561:     case nsXPTType::T_UTF8STRING    : NS_ERROR("bad type"); goto failure;
31561:     case nsXPTType::T_CSTRING       : NS_ERROR("bad type"); goto failure;
31561:     case nsXPTType::T_ASTRING       : NS_ERROR("bad type"); goto failure;
31561:     default                         : NS_ERROR("bad type"); goto failure;
    1:     }
    1: 
    1:     *d = array;
    1:     if(pErr)
    1:         *pErr = NS_OK;
    1:     return JS_TRUE;
    1: 
    1: failure:
    1:     // we may need to cleanup the partially filled array of converted stuff
    1:     if(array)
    1:     {
    1:         if(cleanupMode == re)
    1:         {
    1:             nsISupports** a = (nsISupports**) array;
    1:             for(PRUint32 i = 0; i < initedCount; i++)
    1:             {
    1:                 nsISupports* p = a[i];
    1:                 NS_IF_RELEASE(p);
    1:             }
    1:         }
    1:         else if(cleanupMode == fr && useAllocator)
    1:         {
    1:             void** a = (void**) array;
    1:             for(PRUint32 i = 0; i < initedCount; i++)
    1:             {
    1:                 void* p = a[i];
    1:                 if(p) nsMemory::Free(p);
    1:             }
    1:         }
    1:         nsMemory::Free(array);
    1:     }
    1: 
    1:     return JS_FALSE;
    1: 
    1: #undef POPULATE
    1: }
    1: 
    1: // static
    1: JSBool
31395: XPCConvert::NativeStringWithSize2JS(JSContext* cx,
    1:                                     jsval* d, const void* s,
    1:                                     const nsXPTType& type,
    1:                                     JSUint32 count,
    1:                                     nsresult* pErr)
    1: {
    1:     NS_PRECONDITION(s, "bad param");
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1:     if(!type.IsPointer())
    1:     {
    1:         XPC_LOG_ERROR(("XPCConvert::NativeStringWithSize2JS : unsupported type"));
    1:         return JS_FALSE;
    1:     }
    1:     switch(type.TagPart())
    1:     {
    1:         case nsXPTType::T_PSTRING_SIZE_IS:
    1:         {
    1:             char* p = *((char**)s);
    1:             if(!p)
    1:                 break;
    1:             JSString* str;
    1:             if(!(str = JS_NewStringCopyN(cx, p, count)))
    1:                 return JS_FALSE;
    1:             *d = STRING_TO_JSVAL(str);
    1:             break;
    1:         }
    1:         case nsXPTType::T_PWSTRING_SIZE_IS:
    1:         {
    1:             jschar* p = *((jschar**)s);
    1:             if(!p)
    1:                 break;
    1:             JSString* str;
    1:             if(!(str = JS_NewUCStringCopyN(cx, p, count)))
    1:                 return JS_FALSE;
    1:             *d = STRING_TO_JSVAL(str);
    1:             break;
    1:         }
    1:         default:
    1:             XPC_LOG_ERROR(("XPCConvert::NativeStringWithSize2JS : unsupported type"));
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: // static
    1: JSBool
    1: XPCConvert::JSStringWithSize2Native(XPCCallContext& ccx, void* d, jsval s,
    1:                                     JSUint32 count, JSUint32 capacity,
    1:                                     const nsXPTType& type,
    1:                                     JSBool useAllocator,
    1:                                     uintN* pErr)
    1: {
48470:     NS_PRECONDITION(!JSVAL_IS_NULL(s), "bad param");
    1:     NS_PRECONDITION(d, "bad param");
    1: 
    1:     JSContext* cx = ccx.GetJSContext();
    1: 
    1:     JSUint32 len;
    1: 
    1:     if(pErr)
    1:         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
    1: 
    1:     if(capacity < count)
    1:     {
    1:         if(pErr)
    1:             *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if(!type.IsPointer())
    1:     {
    1:         XPC_LOG_ERROR(("XPCConvert::JSStringWithSize2Native : unsupported type"));
    1:         return JS_FALSE;
    1:     }
    1:     switch(type.TagPart())
    1:     {
    1:         case nsXPTType::T_PSTRING_SIZE_IS:
    1:         {
57814:             NS_ASSERTION(useAllocator,"cannot convert a JSString to char * without allocator");
57814:             if(!useAllocator)
57814:             {
57814:                 XPC_LOG_ERROR(("XPCConvert::JSStringWithSize2Native : unsupported type"));
57814:                 return JS_FALSE;
57814:             }
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(0 != count)
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:                     return JS_FALSE;
    1:                 }
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1: 
57814:                 if(0 != capacity)
    1:                 {
    1:                     len = (capacity + 1) * sizeof(char);
    1:                     if(!(*((void**)d) = nsMemory::Alloc(len)))
    1:                         return JS_FALSE;
    1:                     return JS_TRUE;
    1:                 }
    1:                 // else ...
    1: 
    1:                 *((char**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
57814:             JSString* str = JS_ValueToString(cx, s);
57814:             if(!str)
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: 
57814:             size_t length = JS_GetStringEncodingLength(cx, str);
57814:             if (length == size_t(-1))
57814:             {
57814:                 return JS_FALSE;
57814:             }
57814:             if(length > count)
    1:             {
    1:                 if(pErr)
    1:                     *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:                 return JS_FALSE;
    1:             }
57814:             len = PRUint32(length);
    1: 
    1:             if(len < capacity)
    1:                 len = capacity;
    1: 
    1:             JSUint32 alloc_len = (len + 1) * sizeof(char);
57814:             char *buffer = static_cast<char *>(nsMemory::Alloc(alloc_len));
57814:             if(!buffer)
    1:             {
    1:                 return JS_FALSE;
    1:             }
57814:             JS_EncodeStringToBuffer(str, buffer, len);
57814:             buffer[len] = '\0';
57814:             *((char**)d) = buffer;
    1: 
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         case nsXPTType::T_PWSTRING_SIZE_IS:
    1:         {
48533:             const jschar* chars=nsnull;
    1:             JSString* str;
    1: 
    1:             if(JSVAL_IS_VOID(s) || JSVAL_IS_NULL(s))
    1:             {
    1:                 if(0 != count)
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:                     return JS_FALSE;
    1:                 }
    1:                 if(type.IsReference())
    1:                 {
    1:                     if(pErr)
    1:                         *pErr = NS_ERROR_XPC_BAD_CONVERT_JS_NULL_REF;
    1:                     return JS_FALSE;
    1:                 }
    1: 
    1:                 if(useAllocator && 0 != capacity)
    1:                 {
    1:                     len = (capacity + 1) * sizeof(jschar);
    1:                     if(!(*((void**)d) = nsMemory::Alloc(len)))
    1:                         return JS_FALSE;
    1:                     return JS_TRUE;
    1:                 }
    1: 
    1:                 // else ...
48533:                 *((const jschar**)d) = nsnull;
    1:                 return JS_TRUE;
    1:             }
    1: 
48533:             if(!(str = JS_ValueToString(cx, s)))
    1:             {
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             len = JS_GetStringLength(str);
    1:             if(len > count)
    1:             {
    1:                 if(pErr)
    1:                     *pErr = NS_ERROR_XPC_NOT_ENOUGH_CHARS_IN_STRING;
    1:                 return JS_FALSE;
    1:             }
    1:             if(len < capacity)
    1:                 len = capacity;
    1: 
    1:             if(useAllocator)
    1:             {
59889:                 if(!(chars = JS_GetStringCharsZ(cx, str)))
48533:                 {
48533:                     return JS_FALSE;
48533:                 }
    1:                 JSUint32 alloc_len = (len + 1) * sizeof(jschar);
    1:                 if(!(*((void**)d) = nsMemory::Alloc(alloc_len)))
    1:                 {
    1:                     // XXX should report error
    1:                     return JS_FALSE;
    1:                 }
    1:                 memcpy(*((jschar**)d), chars, alloc_len);
    1:                 (*((jschar**)d))[count] = 0;
    1:             }
    1:             else
48533:             {
48533:                 if(!(chars = JS_GetStringCharsZ(cx, str)))
48533:                 {
48533:                     return JS_FALSE;
48533:                 }
48533:                 *((const jschar**)d) = chars;
48533:             }
    1: 
    1:             return JS_TRUE;
    1:         }
    1:         default:
    1:             XPC_LOG_ERROR(("XPCConvert::JSStringWithSize2Native : unsupported type"));
    1:             return JS_FALSE;
    1:     }
    1: }
    1: 
