28493: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
28493: /* ***** BEGIN LICENSE BLOCK *****
28493:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
28493:  *
28493:  * The contents of this file are subject to the Mozilla Public License Version
28493:  * 1.1 (the "License"); you may not use this file except in compliance with
28493:  * the License. You may obtain a copy of the License at
28493:  * http://www.mozilla.org/MPL/
28493:  *
28493:  * Software distributed under the License is distributed on an "AS IS" basis,
28493:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
28493:  * for the specific language governing rights and limitations under the
28493:  * License.
28493:  *
28493:  * The Original Code is mozilla.org code.
28493:  *
28493:  * The Initial Developer of the Original Code is
63247:  * Mozilla Foundation.
28493:  * Portions created by the Initial Developer are Copyright (C) 2009
28493:  * the Initial Developer. All Rights Reserved.
28493:  *
28493:  * Contributor(s):
28493:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
28493:  *
28493:  * Alternatively, the contents of this file may be used under the terms of
28493:  * either of the GNU General Public License Version 2 or later (the "GPL"),
28493:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
28493:  * in which case the provisions of the GPL or the LGPL are applicable instead
28493:  * of those above. If you wish to allow use of your version of this file only
28493:  * under the terms of either the GPL or the LGPL, and not to allow others to
28493:  * use your version of this file under the terms of the MPL, indicate your
28493:  * decision by deleting the provisions above and replace them with the notice
28493:  * and other provisions required by the GPL or the LGPL. If you do not delete
28493:  * the provisions above, a recipient may use your version of this file under
28493:  * the terms of any one of the MPL, the GPL or the LGPL.
28493:  *
28493:  * ***** END LICENSE BLOCK ***** */
28493: 
28493: #include "nsARIAGridAccessible.h"
28493: 
43888: #include "AccIterator.h"
43888: #include "nsAccUtils.h"
67790: #include "States.h"
41384: 
41384: #include "nsIMutableArray.h"
32381: #include "nsComponentManagerUtils.h"
28493: 
74618: using namespace mozilla::a11y;
74618: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // nsARIAGridAccessible
28493: ////////////////////////////////////////////////////////////////////////////////
28493: 
28493: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // Constructor
28493: 
43504: nsARIAGridAccessible::
43504:   nsARIAGridAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessibleWrap(aContent, aShell)
28493: {
28493: }
28493: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // nsISupports
28493: 
28493: NS_IMPL_ISUPPORTS_INHERITED1(nsARIAGridAccessible,
28493:                              nsAccessible,
28493:                              nsIAccessibleTable)
28493: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // nsIAccessibleTable
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::GetCaption(nsIAccessible **aCaption)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aCaption);
28493:   *aCaption = nsnull;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
28493:   // XXX: should be pointed by aria-labelledby on grid?
28493:   return NS_ERROR_NOT_IMPLEMENTED;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::GetSummary(nsAString &aSummary)
28493: {
28493:   aSummary.Truncate();
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
28493:   // XXX: should be pointed by aria-describedby on grid?
28493:   return NS_ERROR_NOT_IMPLEMENTED;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetColumnCount(PRInt32 *acolumnCount)
28493: {
32381:   NS_ENSURE_ARG_POINTER(acolumnCount);
32381:   *acolumnCount = 0;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494:   nsAccessible* row = rowIter.GetNext();
74916:   if (!row)
74916:     return NS_OK;
42494: 
43888:   AccIterator cellIter(row, filters::GetCell);
42494:   nsAccessible *cell = nsnull;
42494: 
42494:   while ((cell = cellIter.GetNext()))
32381:     (*acolumnCount)++;
28493: 
28493:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetRowCount(PRInt32 *arowCount)
28493: {
32381:   NS_ENSURE_ARG_POINTER(arowCount);
32381:   *arowCount = 0;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494:   while (rowIter.GetNext())
32381:     (*arowCount)++;
28493: 
28493:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetCellAt(PRInt32 aRowIndex, PRInt32 aColumnIndex,
28493:                                 nsIAccessible **aAccessible)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aAccessible);
28493:   *aAccessible = nsnull;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
42494:   nsAccessible *row = GetRowAt(aRowIndex);
29126:   NS_ENSURE_ARG(row);
28493: 
42494:   nsAccessible *cell = GetCellInRowAt(row, aColumnIndex);
29126:   NS_ENSURE_ARG(cell);
28493: 
28493:   NS_ADDREF(*aAccessible = cell);
28493:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetCellIndexAt(PRInt32 aRowIndex, PRInt32 aColumnIndex,
32381:                                      PRInt32 *aCellIndex)
28493: {
32381:   NS_ENSURE_ARG_POINTER(aCellIndex);
32381:   *aCellIndex = -1;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
32381:   NS_ENSURE_ARG(aRowIndex >= 0 && aColumnIndex >= 0);
28493: 
28493:   PRInt32 rowCount = 0;
32381:   GetRowCount(&rowCount);
32381:   NS_ENSURE_ARG(aRowIndex < rowCount);
28493: 
32381:   PRInt32 colsCount = 0;
32381:   GetColumnCount(&colsCount);
32381:   NS_ENSURE_ARG(aColumnIndex < colsCount);
28493: 
32381:   *aCellIndex = colsCount * aRowIndex + aColumnIndex;
28493:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetColumnIndexAt(PRInt32 aCellIndex,
32381:                                        PRInt32 *aColumnIndex)
28493: {
32381:   NS_ENSURE_ARG_POINTER(aColumnIndex);
32381:   *aColumnIndex = -1;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
32381:   NS_ENSURE_ARG(aCellIndex >= 0);
28493: 
28493:   PRInt32 rowCount = 0;
32381:   GetRowCount(&rowCount);
28493: 
32381:   PRInt32 colsCount = 0;
32381:   GetColumnCount(&colsCount);
28493: 
32381:   NS_ENSURE_ARG(aCellIndex < rowCount * colsCount);
28493: 
32381:   *aColumnIndex = aCellIndex % colsCount;
28493:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetRowIndexAt(PRInt32 aCellIndex, PRInt32 *aRowIndex)
28493: {
32381:   NS_ENSURE_ARG_POINTER(aRowIndex);
32381:   *aRowIndex = -1;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
32381:   NS_ENSURE_ARG(aCellIndex >= 0);
28493: 
28493:   PRInt32 rowCount = 0;
32381:   GetRowCount(&rowCount);
28493: 
32381:   PRInt32 colsCount = 0;
32381:   GetColumnCount(&colsCount);
28493: 
32381:   NS_ENSURE_ARG(aCellIndex < rowCount * colsCount);
28493: 
32381:   *aRowIndex = aCellIndex / colsCount;
28493:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
47173: nsARIAGridAccessible::GetRowAndColumnIndicesAt(PRInt32 aCellIndex,
47173:                                                PRInt32* aRowIndex,
47173:                                                PRInt32* aColumnIndex)
47173: {
47173:   NS_ENSURE_ARG_POINTER(aRowIndex);
47173:   *aRowIndex = -1;
47173:   NS_ENSURE_ARG_POINTER(aColumnIndex);
47173:   *aColumnIndex = -1;
47173: 
47173:   if (IsDefunct())
47173:     return NS_ERROR_FAILURE;
47173: 
47173:   NS_ENSURE_ARG(aCellIndex >= 0);
47173: 
47173:   PRInt32 rowCount = 0;
47173:   GetRowCount(&rowCount);
47173: 
47173:   PRInt32 colsCount = 0;
47173:   GetColumnCount(&colsCount);
47173: 
47173:   NS_ENSURE_ARG(aCellIndex < rowCount * colsCount);
47173: 
47173:   *aColumnIndex = aCellIndex % colsCount;
47173:   *aRowIndex = aCellIndex / colsCount;
47173:   return NS_OK;
47173: }
47173: 
47173: NS_IMETHODIMP
28493: nsARIAGridAccessible::GetColumnExtentAt(PRInt32 aRow, PRInt32 aColumn,
28493:                                         PRInt32 *aExtentCount)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aExtentCount);
28493:   *aExtentCount = 0;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
28493:   NS_ENSURE_ARG(IsValidRowNColumn(aRow, aColumn));
28493: 
28493:   *aExtentCount = 1;
28493:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::GetRowExtentAt(PRInt32 aRow, PRInt32 aColumn,
28493:                                       PRInt32 *aExtentCount)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aExtentCount);
28493:   *aExtentCount = 0;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
28493:   NS_ENSURE_ARG(IsValidRowNColumn(aRow, aColumn));
28493: 
28493:   *aExtentCount = 1;
28493:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::GetColumnDescription(PRInt32 aColumn,
28493:                                            nsAString& aDescription)
28493: {
28493:   aDescription.Truncate();
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
28493:   NS_ENSURE_ARG(IsValidColumn(aColumn));
28493: 
28493:   // XXX: not implemented
28493:   return NS_ERROR_NOT_IMPLEMENTED;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::GetRowDescription(PRInt32 aRow, nsAString& aDescription)
28493: {
28493:   aDescription.Truncate();
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
28493:   NS_ENSURE_ARG(IsValidRow(aRow));
28493: 
28493:   // XXX: not implemented
28493:   return NS_ERROR_NOT_IMPLEMENTED;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::IsColumnSelected(PRInt32 aColumn, PRBool *aIsSelected)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aIsSelected);
28493:   *aIsSelected = PR_FALSE;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
28493:   NS_ENSURE_ARG(IsValidColumn(aColumn));
28493: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494:   nsAccessible *row = rowIter.GetNext();
29126:   if (!row)
29126:     return NS_OK;
29126: 
29126:   do {
32381:     if (!nsAccUtils::IsARIASelected(row)) {
42494:       nsAccessible *cell = GetCellInRowAt(row, aColumn);
29126:       if (!cell) // Do not fail due to wrong markup
29126:         return NS_OK;
29126:       
32381:       if (!nsAccUtils::IsARIASelected(cell))
29126:         return NS_OK;
29126:     }
42494:   } while ((row = rowIter.GetNext()));
29126: 
29126:   *aIsSelected = PR_TRUE;
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::IsRowSelected(PRInt32 aRow, PRBool *aIsSelected)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aIsSelected);
28493:   *aIsSelected = PR_FALSE;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
42494:   nsAccessible *row = GetRowAt(aRow);
29126:   NS_ENSURE_ARG(row);
28493: 
32381:   if (!nsAccUtils::IsARIASelected(row)) {
43888:     AccIterator cellIter(row, filters::GetCell);
42494:     nsAccessible *cell = nsnull;
42494:     while ((cell = cellIter.GetNext())) {
32381:       if (!nsAccUtils::IsARIASelected(cell))
29126:         return NS_OK;
29126:     }
29126:   }
29126: 
29126:   *aIsSelected = PR_TRUE;
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::IsCellSelected(PRInt32 aRow, PRInt32 aColumn,
28493:                                      PRBool *aIsSelected)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aIsSelected);
28493:   *aIsSelected = PR_FALSE;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
42494:   nsAccessible *row = GetRowAt(aRow);
29126:   NS_ENSURE_ARG(row);
28493: 
32381:   if (!nsAccUtils::IsARIASelected(row)) {
42494:     nsAccessible *cell = GetCellInRowAt(row, aColumn);
29126:     NS_ENSURE_ARG(cell);
29126: 
32381:     if (!nsAccUtils::IsARIASelected(cell))
29126:       return NS_OK;
29126:   }
29126: 
29126:   *aIsSelected = PR_TRUE;
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetSelectedCellCount(PRUint32* aCount)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aCount);
28493:   *aCount = 0;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
29126:   PRInt32 colCount = 0;
32381:   GetColumnCount(&colCount);
29126: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = nsnull;
42494:   while ((row = rowIter.GetNext())) {
32381:     if (nsAccUtils::IsARIASelected(row)) {
29126:       (*aCount) += colCount;
29126:       continue;
29126:     }
29126: 
43888:     AccIterator cellIter(row, filters::GetCell);
42494:     nsAccessible *cell = nsnull;
42494: 
42494:     while ((cell = cellIter.GetNext())) {
32381:       if (nsAccUtils::IsARIASelected(cell))
29126:         (*aCount)++;
29126:     }
29126:   }
29126: 
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetSelectedColumnCount(PRUint32* aCount)
28493: {
29126:   return GetSelectedColumnsArray(aCount);
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetSelectedRowCount(PRUint32* aCount)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aCount);
28493:   *aCount = 0;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = nsnull;
42494:   while ((row = rowIter.GetNext())) {
32381:     if (nsAccUtils::IsARIASelected(row)) {
29126:       (*aCount)++;
29126:       continue;
29126:     }
29126: 
43888:     AccIterator cellIter(row, filters::GetCell);
42494:     nsAccessible *cell = cellIter.GetNext();
29126:     if (!cell)
29126:       continue;
29126: 
29126:     PRBool isRowSelected = PR_TRUE;
29126:     do {
32381:       if (!nsAccUtils::IsARIASelected(cell)) {
29126:         isRowSelected = PR_FALSE;
29126:         break;
29126:       }
42494:     } while ((cell = cellIter.GetNext()));
29126: 
29126:     if (isRowSelected)
29126:       (*aCount)++;
29126:   }
29126: 
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetSelectedCells(nsIArray **aCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aCells);
32381:   *aCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsresult rv = NS_OK;
32381:   nsCOMPtr<nsIMutableArray> selCells =
32381:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
32381:   NS_ENSURE_SUCCESS(rv, rv);
32381: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = nsnull;
47804:   while ((row = rowIter.GetNext())) {
43888:     AccIterator cellIter(row, filters::GetCell);
43539:     nsAccessible *cell = nsnull;
42494: 
32381:     if (nsAccUtils::IsARIASelected(row)) {
47804:       while ((cell = cellIter.GetNext()))
43539:         selCells->AppendElement(static_cast<nsIAccessible *>(cell), PR_FALSE);
32381: 
32381:       continue;
32381:     }
32381: 
47804:     while ((cell = cellIter.GetNext())) {
32381:       if (nsAccUtils::IsARIASelected(cell))
43539:         selCells->AppendElement(static_cast<nsIAccessible *>(cell), PR_FALSE);
32381:     }
32381:   }
32381: 
32381:   NS_ADDREF(*aCells = selCells);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetSelectedCellIndices(PRUint32 *aCellsCount,
32381:                                              PRInt32 **aCells)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aCellsCount);
28493:   *aCellsCount = 0;
28493:   NS_ENSURE_ARG_POINTER(aCells);
28493:   *aCells = nsnull;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
29126:   PRInt32 rowCount = 0;
32381:   GetRowCount(&rowCount);
29126: 
29126:   PRInt32 colCount = 0;
32381:   GetColumnCount(&colCount);
29126: 
29126:   nsTArray<PRInt32> selCells(rowCount * colCount);
29126: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = nsnull;
47804:   for (PRInt32 rowIdx = 0; (row = rowIter.GetNext()); rowIdx++) {
32381:     if (nsAccUtils::IsARIASelected(row)) {
29126:       for (PRInt32 colIdx = 0; colIdx < colCount; colIdx++)
29126:         selCells.AppendElement(rowIdx * colCount + colIdx);
29126: 
29126:       continue;
29126:     }
29126: 
43888:     AccIterator cellIter(row, filters::GetCell);
42494:     nsAccessible *cell = nsnull;
42494: 
47804:     for (PRInt32 colIdx = 0; (cell = cellIter.GetNext()); colIdx++) {
32381:       if (nsAccUtils::IsARIASelected(cell))
29126:         selCells.AppendElement(rowIdx * colCount + colIdx);
29126:     }
29126:   }
29126: 
29126:   PRUint32 selCellsCount = selCells.Length();
29126:   if (!selCellsCount)
29126:     return NS_OK;
29126: 
29126:   *aCells = static_cast<PRInt32*>(
29126:     nsMemory::Clone(selCells.Elements(), selCellsCount * sizeof(PRInt32)));
29126:   NS_ENSURE_TRUE(*aCells, NS_ERROR_OUT_OF_MEMORY);
29126: 
29126:   *aCellsCount = selCellsCount;
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetSelectedColumnIndices(PRUint32 *acolumnCount,
28493:                                                PRInt32 **aColumns)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aColumns);
28493: 
32381:   return GetSelectedColumnsArray(acolumnCount, aColumns);
28493: }
28493: 
28493: NS_IMETHODIMP
32381: nsARIAGridAccessible::GetSelectedRowIndices(PRUint32 *arowCount,
32381:                                             PRInt32 **aRows)
28493: {
32381:   NS_ENSURE_ARG_POINTER(arowCount);
32381:   *arowCount = 0;
28493:   NS_ENSURE_ARG_POINTER(aRows);
28493:   *aRows = nsnull;
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
29126:   PRInt32 rowCount = 0;
32381:   GetRowCount(&rowCount);
29126:   if (!rowCount)
29126:     return NS_OK;
29126: 
29126:   nsTArray<PRInt32> selRows(rowCount);
29126: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = nsnull;
47804:   for (PRInt32 rowIdx = 0; (row = rowIter.GetNext()); rowIdx++) {
32381:     if (nsAccUtils::IsARIASelected(row)) {
29126:       selRows.AppendElement(rowIdx);
29126:       continue;
29126:     }
29126: 
43888:     AccIterator cellIter(row, filters::GetCell);
42494:     nsAccessible *cell = cellIter.GetNext();
29126:     if (!cell)
29126:       continue;
29126: 
29126:     PRBool isRowSelected = PR_TRUE;
29126:     do {
32381:       if (!nsAccUtils::IsARIASelected(cell)) {
29126:         isRowSelected = PR_FALSE;
29126:         break;
29126:       }
42494:     } while ((cell = cellIter.GetNext()));
29126: 
29126:     if (isRowSelected)
29126:       selRows.AppendElement(rowIdx);
29126:   }
29126: 
32381:   PRUint32 selrowCount = selRows.Length();
32381:   if (!selrowCount)
29126:     return NS_OK;
29126: 
29126:   *aRows = static_cast<PRInt32*>(
32381:     nsMemory::Clone(selRows.Elements(), selrowCount * sizeof(PRInt32)));
29126:   NS_ENSURE_TRUE(*aRows, NS_ERROR_OUT_OF_MEMORY);
29126: 
32381:   *arowCount = selrowCount;
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::SelectRow(PRInt32 aRow)
28493: {
28493:   NS_ENSURE_ARG(IsValidRow(aRow));
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = nsnull;
47804:   for (PRInt32 rowIdx = 0; (row = rowIter.GetNext()); rowIdx++) {
29126:     nsresult rv = SetARIASelected(row, rowIdx == aRow);
29126:     NS_ENSURE_SUCCESS(rv, rv);
29126:   }
29126: 
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::SelectColumn(PRInt32 aColumn)
28493: {
28493:   NS_ENSURE_ARG(IsValidColumn(aColumn));
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = nsnull;
42494:   while ((row = rowIter.GetNext())) {
29126:     // Unselect all cells in the row.
29126:     nsresult rv = SetARIASelected(row, PR_FALSE);
29126:     NS_ENSURE_SUCCESS(rv, rv);
29126: 
29126:     // Select cell at the column index.
42494:     nsAccessible *cell = GetCellInRowAt(row, aColumn);
29126:     if (cell) {
29126:       rv = SetARIASelected(cell, PR_TRUE);
29126:       NS_ENSURE_SUCCESS(rv, rv);
29126:     }
29126:   }
29126: 
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::UnselectRow(PRInt32 aRow)
28493: {
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
42494:   nsAccessible *row = GetRowAt(aRow);
29126:   NS_ENSURE_ARG(row);
29126: 
29126:   return SetARIASelected(row, PR_FALSE);
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::UnselectColumn(PRInt32 aColumn)
28493: {
28493:   NS_ENSURE_ARG(IsValidColumn(aColumn));
28493: 
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = nsnull;
42494:   while ((row = rowIter.GetNext())) {
42494:     nsAccessible *cell = GetCellInRowAt(row, aColumn);
29126:     if (cell) {
29126:       nsresult rv = SetARIASelected(cell, PR_FALSE);
29126:       NS_ENSURE_SUCCESS(rv, rv);
29126:     }
29126:   }
29126: 
29126:   return NS_OK;
28493: }
28493: 
28493: NS_IMETHODIMP
28493: nsARIAGridAccessible::IsProbablyForLayout(PRBool *aIsProbablyForLayout)
28493: {
28493:   NS_ENSURE_ARG_POINTER(aIsProbablyForLayout);
28493:   *aIsProbablyForLayout = PR_FALSE;
28493: 
28493:   return NS_OK;
28493: }
28493: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // Protected
28493: 
28493: PRBool
28493: nsARIAGridAccessible::IsValidRow(PRInt32 aRow)
28493: {
28493:   if (aRow < 0)
28493:     return PR_FALSE;
28493:   
28493:   PRInt32 rowCount = 0;
32381:   GetRowCount(&rowCount);
28493:   return aRow < rowCount;
28493: }
28493: 
28493: PRBool
28493: nsARIAGridAccessible::IsValidColumn(PRInt32 aColumn)
28493: {
28493:   if (aColumn < 0)
28493:     return PR_FALSE;
28493: 
28493:   PRInt32 colCount = 0;
32381:   GetColumnCount(&colCount);
28493:   return aColumn < colCount;
28493: }
28493: 
28493: PRBool
28493: nsARIAGridAccessible::IsValidRowNColumn(PRInt32 aRow, PRInt32 aColumn)
28493: {
28493:   if (aRow < 0 || aColumn < 0)
28493:     return PR_FALSE;
28493:   
28493:   PRInt32 rowCount = 0;
32381:   GetRowCount(&rowCount);
28493:   if (aRow >= rowCount)
28493:     return PR_FALSE;
28493: 
28493:   PRInt32 colCount = 0;
32381:   GetColumnCount(&colCount);
28493:   return aColumn < colCount;
28493: }
28493: 
42494: nsAccessible*
29126: nsARIAGridAccessible::GetRowAt(PRInt32 aRow)
29126: {
29126:   PRInt32 rowIdx = aRow;
42494: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494: 
42494:   nsAccessible *row = rowIter.GetNext();
42494:   while (rowIdx != 0 && (row = rowIter.GetNext()))
29126:     rowIdx--;
29126: 
42494:   return row;
29126: }
29126: 
42494: nsAccessible*
42494: nsARIAGridAccessible::GetCellInRowAt(nsAccessible *aRow, PRInt32 aColumn)
29126: {
29126:   PRInt32 colIdx = aColumn;
42494: 
43888:   AccIterator cellIter(aRow, filters::GetCell);
42494:   nsAccessible *cell = cellIter.GetNext();
42494:   while (colIdx != 0 && (cell = cellIter.GetNext()))
29126:     colIdx--;
29126: 
42494:   return cell;
29126: }
29126: 
29126: nsresult
42494: nsARIAGridAccessible::SetARIASelected(nsAccessible *aAccessible,
29126:                                       PRBool aIsSelected, PRBool aNotify)
29126: {
43504:   nsIContent *content = aAccessible->GetContent();
42494:   NS_ENSURE_STATE(content);
29126: 
29126:   nsresult rv = NS_OK;
29126:   if (aIsSelected)
29126:     rv = content->SetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_selected,
29126:                           NS_LITERAL_STRING("true"), aNotify);
29126:   else
29126:     rv = content->UnsetAttr(kNameSpaceID_None,
29126:                             nsAccessibilityAtoms::aria_selected, aNotify);
29126: 
29126:   NS_ENSURE_SUCCESS(rv, rv);
29126: 
29126:   // No "smart" select/unselect for internal call.
29126:   if (!aNotify)
29126:     return NS_OK;
29126: 
29126:   // If row or cell accessible was selected then we're able to not bother about
29126:   // selection of its cells or its row because our algorithm is row oriented,
29126:   // i.e. we check selection on row firstly and then on cells.
29126:   if (aIsSelected)
29126:     return NS_OK;
29126: 
52089:   PRUint32 role = aAccessible->Role();
29126: 
29126:   // If the given accessible is row that was unselected then remove
29126:   // aria-selected from cell accessible.
29126:   if (role == nsIAccessibleRole::ROLE_ROW) {
43888:     AccIterator cellIter(aAccessible, filters::GetCell);
42494:     nsAccessible *cell = nsnull;
42494: 
42494:     while ((cell = cellIter.GetNext())) {
29126:       rv = SetARIASelected(cell, PR_FALSE, PR_FALSE);
29126:       NS_ENSURE_SUCCESS(rv, rv);
29126:     }
29126:     return NS_OK;
29126:   }
29126: 
29126:   // If the given accessible is cell that was unselected and its row is selected
29126:   // then remove aria-selected from row and put aria-selected on
29126:   // siblings cells.
29126:   if (role == nsIAccessibleRole::ROLE_GRID_CELL ||
29126:       role == nsIAccessibleRole::ROLE_ROWHEADER ||
29126:       role == nsIAccessibleRole::ROLE_COLUMNHEADER) {
74545:     nsAccessible* row = aAccessible->Parent();
29126: 
52089:     if (row && row->Role() == nsIAccessibleRole::ROLE_ROW &&
32381:         nsAccUtils::IsARIASelected(row)) {
29126:       rv = SetARIASelected(row, PR_FALSE, PR_FALSE);
29126:       NS_ENSURE_SUCCESS(rv, rv);
29126: 
43888:       AccIterator cellIter(row, filters::GetCell);
42494:       nsAccessible *cell = nsnull;
42494:       while ((cell = cellIter.GetNext())) {
29126:         if (cell != aAccessible) {
29126:           rv = SetARIASelected(cell, PR_TRUE, PR_FALSE);
29126:           NS_ENSURE_SUCCESS(rv, rv);
29126:         }
29126:       }
29126:     }
29126:   }
29126: 
29126:   return NS_OK;
29126: }
29126: 
29126: nsresult
32381: nsARIAGridAccessible::GetSelectedColumnsArray(PRUint32 *acolumnCount,
29126:                                               PRInt32 **aColumns)
29126: {
32381:   NS_ENSURE_ARG_POINTER(acolumnCount);
32381:   *acolumnCount = 0;
29126:   if (aColumns)
29126:     *aColumns = nsnull;
29126: 
29126:   if (IsDefunct())
29126:     return NS_ERROR_FAILURE;
29126: 
43888:   AccIterator rowIter(this, filters::GetRow);
42494:   nsAccessible *row = rowIter.GetNext();
29126:   if (!row)
29126:     return NS_OK;
29126: 
29126:   PRInt32 colCount = 0;
32381:   GetColumnCount(&colCount);
29126:   if (!colCount)
29126:     return NS_OK;
29126: 
29126:   PRInt32 selColCount = colCount;
29126: 
29126:   nsTArray<PRBool> isColSelArray(selColCount);
29126:   isColSelArray.AppendElements(selColCount);
29126:   for (PRInt32 i = 0; i < selColCount; i++)
29126:     isColSelArray[i] = PR_TRUE;
29126: 
29126:   do {
32381:     if (nsAccUtils::IsARIASelected(row))
29126:       continue;
29126: 
29126:     PRInt32 colIdx = 0;
42494: 
43888:     AccIterator cellIter(row, filters::GetCell);
42494:     nsAccessible *cell = nsnull;
47804:     for (colIdx = 0; (cell = cellIter.GetNext()); colIdx++) {
29126:       if (isColSelArray.SafeElementAt(colIdx, PR_FALSE) &&
32381:           !nsAccUtils::IsARIASelected(cell)) {
29126:         isColSelArray[colIdx] = PR_FALSE;
29126:         selColCount--;
29126:       }
29126:     }
42494:   } while ((row = rowIter.GetNext()));
29126: 
29126:   if (!selColCount)
29126:     return NS_OK;
29126: 
29126:   if (!aColumns) {
32381:     *acolumnCount = selColCount;
29126:     return NS_OK;
29126:   }
29126: 
29126:   *aColumns = static_cast<PRInt32*>(
29126:     nsMemory::Alloc(selColCount * sizeof(PRInt32)));
29126:   NS_ENSURE_TRUE(*aColumns, NS_ERROR_OUT_OF_MEMORY);
29126: 
32381:   *acolumnCount = selColCount;
29126:   for (PRInt32 colIdx = 0, idx = 0; colIdx < colCount; colIdx++) {
29126:     if (isColSelArray[colIdx])
29126:       (*aColumns)[idx++] = colIdx;
29126:   }
29126: 
29126:   return NS_OK;
29126: }
29126: 
28493: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // nsARIAGridCellAccessible
28493: ////////////////////////////////////////////////////////////////////////////////
28493: 
28493: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // Constructor
28493: 
43504: nsARIAGridCellAccessible::
43504:   nsARIAGridCellAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsHyperTextAccessibleWrap(aContent, aShell)
28493: {
28493: }
28493: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // nsISupports
28493: 
32381: NS_IMPL_ISUPPORTS_INHERITED1(nsARIAGridCellAccessible,
32381:                              nsHyperTextAccessible,
32381:                              nsIAccessibleTableCell)
32381: 
32381: ////////////////////////////////////////////////////////////////////////////////
32381: // nsIAccessibleTableCell
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridCellAccessible::GetTable(nsIAccessibleTable **aTable)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aTable);
32381:   *aTable = nsnull;
32381: 
74545:   nsAccessible* thisRow = Parent();
52089:   if (!thisRow || thisRow->Role() != nsIAccessibleRole::ROLE_ROW)
32381:     return NS_OK;
32381: 
74545:   nsAccessible* table = thisRow->Parent();
52089:   if (!table)
52089:     return NS_OK;
52089: 
52089:   PRUint32 tableRole = table->Role();
52089:   if (tableRole != nsIAccessibleRole::ROLE_TABLE &&
52089:       tableRole != nsIAccessibleRole::ROLE_TREE_TABLE)
32381:     return NS_OK;
32381: 
32381:   CallQueryInterface(table, aTable);
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridCellAccessible::GetColumnIndex(PRInt32 *aColumnIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aColumnIndex);
32381:   *aColumnIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
74545:   nsAccessible* row = Parent();
52089:   if (!row)
52089:     return NS_OK;
52089: 
32381:   *aColumnIndex = 0;
32381: 
72476:   PRInt32 indexInRow = IndexInParent();
52089:   for (PRInt32 idx = 0; idx < indexInRow; idx++) {
52089:     nsAccessible* cell = row->GetChildAt(idx);
52089:     PRUint32 role = cell->Role();
32381:     if (role == nsIAccessibleRole::ROLE_GRID_CELL ||
32381:         role == nsIAccessibleRole::ROLE_ROWHEADER ||
32381:         role == nsIAccessibleRole::ROLE_COLUMNHEADER)
32381:       (*aColumnIndex)++;
32381:   }
32381: 
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridCellAccessible::GetRowIndex(PRInt32 *aRowIndex)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aRowIndex);
32381:   *aRowIndex = -1;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
74545:   nsAccessible* row = Parent();
52089:   if (!row)
52089:     return NS_OK;
32381: 
74545:   nsAccessible* table = row->Parent();
52089:   if (!table)
52089:     return NS_OK;
52089: 
52089:   *aRowIndex = 0;
52089: 
72476:   PRInt32 indexInTable = row->IndexInParent();
52089:   for (PRInt32 idx = 0; idx < indexInTable; idx++) {
52089:     row = table->GetChildAt(idx);
52089:     if (row->Role() == nsIAccessibleRole::ROLE_ROW)
32381:       (*aRowIndex)++;
32381:   }
32381: 
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridCellAccessible::GetColumnExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 0;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   *aExtentCount = 1;
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridCellAccessible::GetRowExtent(PRInt32 *aExtentCount)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aExtentCount);
32381:   *aExtentCount = 0;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   *aExtentCount = 1;
32381:   return NS_OK;
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridCellAccessible::GetColumnHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table;
32381:   GetTable(getter_AddRefs(table));
32381:   if (!table)
32381:     return NS_OK;
32381: 
32381:   return nsAccUtils::GetHeaderCellsFor(table, this,
32381:                                        nsAccUtils::eColumnHeaderCells,
32381:                                        aHeaderCells);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridCellAccessible::GetRowHeaderCells(nsIArray **aHeaderCells)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aHeaderCells);
32381:   *aHeaderCells = nsnull;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
32381:   nsCOMPtr<nsIAccessibleTable> table;
32381:   GetTable(getter_AddRefs(table));
32381:   if (!table)
32381:     return NS_OK;
32381: 
32381:   return nsAccUtils::GetHeaderCellsFor(table, this,
32381:                                        nsAccUtils::eRowHeaderCells,
32381:                                        aHeaderCells);
32381: }
32381: 
32381: NS_IMETHODIMP
32381: nsARIAGridCellAccessible::IsSelected(PRBool *aIsSelected)
32381: {
32381:   NS_ENSURE_ARG_POINTER(aIsSelected);
32381:   *aIsSelected = PR_FALSE;
32381: 
32381:   if (IsDefunct())
32381:     return NS_ERROR_FAILURE;
32381: 
74545:   nsAccessible* row = Parent();
52089:   if (!row || row->Role() != nsIAccessibleRole::ROLE_ROW)
32381:     return NS_OK;
32381: 
32381:   if (!nsAccUtils::IsARIASelected(row) && !nsAccUtils::IsARIASelected(this))
32381:     return NS_OK;
32381: 
32381:   *aIsSelected = PR_TRUE;
32381:   return NS_OK;
32381: }
28493: 
28493: ////////////////////////////////////////////////////////////////////////////////
28493: // nsAccessible
28493: 
67790: void
67790: nsARIAGridCellAccessible::ApplyARIAState(PRUint64* aState)
29929: {
67790:   nsHyperTextAccessibleWrap::ApplyARIAState(aState);
29929: 
29929:   // Return if the gridcell has aria-selected="true".
67790:   if (*aState & states::SELECTED)
67790:     return;
29929: 
29929:   // Check aria-selected="true" on the row.
74545:   nsAccessible* row = Parent();
52089:   if (!row || row->Role() != nsIAccessibleRole::ROLE_ROW)
67790:     return;
29929: 
43539:   nsIContent *rowContent = row->GetContent();
29929:   if (nsAccUtils::HasDefinedARIAToken(rowContent,
29929:                                       nsAccessibilityAtoms::aria_selected) &&
29929:       !rowContent->AttrValueIs(kNameSpaceID_None,
29929:                                nsAccessibilityAtoms::aria_selected,
67790:                                nsAccessibilityAtoms::_false, eCaseMatters))
67790:     *aState |= states::SELECTABLE | states::SELECTED;
29929: }
29929: 
29929: nsresult
28493: nsARIAGridCellAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
28493: {
28493:   if (IsDefunct())
28493:     return NS_ERROR_FAILURE;
28493:   
28493:   nsresult rv = nsHyperTextAccessibleWrap::GetAttributesInternal(aAttributes);
28493:   NS_ENSURE_SUCCESS(rv, rv);
28493: 
28493:   // Expose "table-cell-index" attribute.
28493: 
74545:   nsAccessible* thisRow = Parent();
52089:   if (!thisRow || thisRow->Role() != nsIAccessibleRole::ROLE_ROW)
28493:     return NS_OK;
28493: 
28493:   PRInt32 colIdx = 0, colCount = 0;
42415:   PRInt32 childCount = thisRow->GetChildCount();
42415:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
42415:     nsAccessible *child = thisRow->GetChildAt(childIdx);
28493:     if (child == this)
28493:       colIdx = colCount;
28493: 
52089:     PRUint32 role = child->Role();
28493:     if (role == nsIAccessibleRole::ROLE_GRID_CELL ||
28493:         role == nsIAccessibleRole::ROLE_ROWHEADER ||
28493:         role == nsIAccessibleRole::ROLE_COLUMNHEADER)
28493:       colCount++;
28493:   }
28493: 
74545:   nsAccessible* table = thisRow->Parent();
52089:   if (!table)
52089:     return NS_OK;
52089: 
52089:   PRUint32 tableRole = table->Role();
52089:   if (tableRole != nsIAccessibleRole::ROLE_TABLE &&
52089:       tableRole != nsIAccessibleRole::ROLE_TREE_TABLE)
28493:     return NS_OK;
28493: 
28493:   PRInt32 rowIdx = 0;
42415:   childCount = table->GetChildCount();
42415:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
42415:     nsAccessible *child = table->GetChildAt(childIdx);
42415:     if (child == thisRow)
42415:       break;
42415: 
52089:     if (child->Role() == nsIAccessibleRole::ROLE_ROW)
28493:       rowIdx++;
28493:   }
28493: 
28493:   PRInt32 idx = rowIdx * colCount + colIdx;
28493: 
28493:   nsAutoString stringIdx;
28493:   stringIdx.AppendInt(idx);
28493:   nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::tableCellIndex,
28493:                          stringIdx);
28493: 
28493:   return NS_OK;
28493: }
