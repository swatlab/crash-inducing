    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Jerry.Kirk@Nexwarecorp.com
    1:  *   Dale.Stansberry@Nexwarecorop.com
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: 
    1: #include <Pt.h>
    1: #include <photon/PtServer.h>
    1: #include "PtRawDrawContainer.h"
    1: #include "nsCRT.h"
    1: 
    1: #include "nsWindow.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsFont.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIRegion.h"
    1: #include "nsRect.h"
    1: #include "nsTransform2D.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsToolkit.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: 
    1: #include "nsClipboard.h"
    1: #include "nsIRollupListener.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIAppShell.h"
    1: #include "nsIDocShell.h"
    1: 
    1: #include "nsIViewManager.h"
    1: #include "nsIXULWindow.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIWindowMediator.h"
    1: #include "nsIPresShell.h"
    1: #include "nsReadableUtils.h"
    1: 
    1: static PhTile_t *GetWindowClipping( PtWidget_t *aWidget );
    1: 
    1: nsIRollupListener *nsWindow::gRollupListener = nsnull;
    1: nsIWidget         *nsWindow::gRollupWidget = nsnull;
    1: static PtWidget_t	*gMenuRegion;
    1: 
    1: /* avoid making a costly PhWindowQueryVisible call */
    1: static PhRect_t gConsoleRect;
    1: static PRBool gConsoleRectValid = PR_FALSE;
    1: #define QueryVisible( )	{\
    1: 													if( gConsoleRectValid == PR_FALSE ) { \
    1: 															PhWindowQueryVisible( Ph_QUERY_IG_POINTER, 0, 1, &gConsoleRect ); \
    1: 															gConsoleRectValid = PR_TRUE;\
    1: 															} \
    1: 													}
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // nsWindow constructor
    1: //
    1: //-------------------------------------------------------------------------
    1: nsWindow::nsWindow() 
    1: {
    1:   mClientWidget    = nsnull;
    1:   mIsTooSmall      = PR_FALSE;
27505:   mIsDestroying    = PR_FALSE;
    1:   mBorderStyle     = eBorderStyle_default;
    1:   mWindowType      = eWindowType_child;
    1: 	mLastMenu				 = nsnull;
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // nsWindow destructor
    1: //
    1: //-------------------------------------------------------------------------
    1: nsWindow::~nsWindow()
    1: {
    1: 	nsWindow *p = (nsWindow*)mParent;
    1: 	if( p && p->mLastMenu == mWidget ) p->mLastMenu = nsnull;
    1: 
    1:   // always call destroy.  if it's already been called, there's no harm
    1:   // since it keeps track of when it's already been called.
    1:   Destroy();
    1: }
    1: 
    1: PRBool nsWindow::IsChild() const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::WidgetToScreen( const nsRect& aOldRect, nsRect& aNewRect ) {
    1: 
    1: 	PhPoint_t pos, offset;
    1: 	PtWidget_t *disjoint = PtFindDisjoint( mWidget );
    1: 
    1: 	QueryVisible( );
    1: 
    1: 	PtGetAbsPosition( disjoint, &pos.x, &pos.y );
    1: 	PtWidgetOffset( mWidget, &offset );
    1: 	aNewRect.x = pos.x + offset.x + aOldRect.x - gConsoleRect.ul.x;
    1: 	aNewRect.y = pos.y + offset.y + aOldRect.y - gConsoleRect.ul.y;
    1: 
    1: 	aNewRect.width = aOldRect.width;
    1: 	aNewRect.height = aOldRect.height;
    1: 
    1:   return NS_OK;
    1: 	}
    1: 
    1: void nsWindow::DestroyNative(void)
    1: {
    1:   if ( mClientWidget )
    1:   {
    1:     PtDestroyWidget(mClientWidget );  
    1:     mClientWidget = nsnull;
    1:   }
    1:   // destroy all of the children that are nsWindow() classes
    1:   // preempting the gdk destroy system.
    1:   if( mWidget ) DestroyNativeChildren();
    1: 
    1:   // Call the base class to actually PtDestroy mWidget.
    1:   nsWidget::DestroyNative();
    1: }
    1: 
    1: // this function will walk the list of children and destroy them.
    1: // the reason why this is here is that because of the superwin code
    1: // it's very likely that we will never get notification of the
    1: // the destruction of the child windows.  so, we have to beat the
    1: // layout engine to the punch.  CB 
    1: 
    1: void nsWindow::DestroyNativeChildren(void)
    1: {
    1:   for(PtWidget_t *w=PtWidgetChildFront( mWidget ); w; w=PtWidgetBrotherBehind( w )) 
    1:   {
    1: 	  if( w->flags & Pt_DESTROYED ) continue;
 3233: 	  nsWindow *childWindow = static_cast<nsWindow *>(GetInstance(w));
    1: 		if( childWindow && !childWindow->mIsDestroying) childWindow->Destroy();
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::CaptureRollupEvents( nsIRollupListener * aListener, PRBool aDoCapture, PRBool aConsumeRollupEvent ) {
    1:   PtWidget_t *grabWidget;
    1:   grabWidget = mWidget;
    1: 
    1:   if (aDoCapture) {
    1:     NS_IF_RELEASE(gRollupListener);
    1:     NS_IF_RELEASE(gRollupWidget);
    1:     gRollupListener = aListener;
    1:     NS_ADDREF(aListener);
    1:     gRollupWidget = this;
    1:     NS_ADDREF(this);
    1: 	
    1: 		/* Realize the gMenuRegion to capture events outside of the application's canvas when menus are displayed */
    1: 		/* Menus+submenus have the same parent. If the parent has mLastMenu set and realized, then use its region as "infront" */
    1: 		/* If not, then this widget ( mWidget ) becomes the mLastMenu and gets recorded into the parent */
    1: 		/* Different windows have different mLastMenu's */
    1: 		if( mWindowType == eWindowType_popup && !( PtWidgetFlags( gMenuRegion ) & Pt_REALIZED ) && mParent ) {
    1: 
    1: 			PtWidget_t *pw = ((nsWindow*)mParent)->mLastMenu;
    1: 
    1: 			if( pw && ( PtWidgetFlags( pw ) & Pt_REALIZED ) && PtWidgetRid( pw ) > 0 )
    1: 				PtSetResource( gMenuRegion, Pt_ARG_REGION_INFRONT, PtWidgetRid( pw ), 0 );
    1: 			else {
    1: 				if( !PtWidgetIsRealized( mWidget ) ) PtRealizeWidget( mWidget );
    1: 				PtSetResource( gMenuRegion, Pt_ARG_REGION_INFRONT, PtWidgetRid( mWidget ), 0 );
    1: 				((nsWindow*)mParent)->mLastMenu = mWidget;
    1: 				}
    1: 
    1: 			PtRealizeWidget( gMenuRegion );
    1: 			}
    1:   	}
    1: 	else {
    1:     NS_IF_RELEASE(gRollupListener);
    1:     gRollupListener = nsnull;
    1:     NS_IF_RELEASE(gRollupWidget);
    1: 		gRollupWidget = nsnull;
    1: 
    1: 		if( mWindowType == eWindowType_popup && ( PtWidgetFlags( gMenuRegion ) & Pt_REALIZED ) )
    1: 			PtUnrealizeWidget( gMenuRegion );
    1:   	}
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_METHOD nsWindow::PreCreateWidget( nsWidgetInitData *aInitData ) {
    1:   if (nsnull != aInitData) {
    1:     SetWindowType( aInitData->mWindowType );
    1:     SetBorderStyle( aInitData->mBorderStyle );
    1:     return NS_OK;
    1:   	}
    1:   return NS_ERROR_FAILURE;
    1: 	}
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Create the native widget
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::CreateNative( PtWidget_t *parentWidget ) {
    1:   PtArg_t   arg[25];
    1:   int       arg_count = 0;
    1:   PhPoint_t pos;
    1:   PhDim_t   dim;
    1:   unsigned  long render_flags;
    1:   nsresult  result = NS_ERROR_FAILURE;
    1: 
    1:   pos.x = mBounds.x;
    1:   pos.y = mBounds.y;
    1:   dim.w = mBounds.width;
    1:   dim.h = mBounds.height;
    1: 
    1:   switch( mWindowType )
    1:   {
    1:   case eWindowType_popup :
    1:     mIsToplevel = PR_TRUE;
    1:     break;
    1:   case eWindowType_toplevel :
    1:   case eWindowType_invisible :
    1:     mIsToplevel = PR_TRUE;
    1:     break;
    1:   case eWindowType_dialog :
    1:     mIsToplevel = PR_TRUE;
    1:     break;
    1:   case eWindowType_child :
    1:     mIsToplevel = PR_FALSE;
    1:     break;
    1:   }
    1: 	
    1:   if ( mWindowType == eWindowType_child )
    1:   {
    1: 	arg_count = 0;
    1:     PtSetArg( &arg[arg_count++], Pt_ARG_POS, &pos, 0 );
    1:     PtSetArg( &arg[arg_count++], Pt_ARG_DIM, &dim, 0 );
    1:     PtSetArg( &arg[arg_count++], Pt_ARG_RESIZE_FLAGS, 0, Pt_RESIZE_XY_BITS );
    1:     PtSetArg( &arg[arg_count++], Pt_ARG_FLAGS, 0 , Pt_HIGHLIGHTED|Pt_GETS_FOCUS );
    1:     PtSetArg( &arg[arg_count++], Pt_ARG_BORDER_WIDTH, 0, 0 );
    1:     PtSetArg( &arg[arg_count++], Pt_ARG_FILL_COLOR, Pg_RED, 0 );
    1:     PtSetArg( &arg[arg_count++], RDC_DRAW_FUNC, RawDrawFunc, 0 );
    1:     mWidget = PtCreateWidget( PtRawDrawContainer, parentWidget, arg_count, arg );
    1:   }
    1:   else
    1:   {
    1:     // No border or decorations is the default
    1:     render_flags = 0; // Ph_WM_RENDER_RESIZE;
    1: 
    1:     if( mWindowType != eWindowType_popup ) {
    1: 
    1:       #define PH_BORDER_STYLE_ALL  \
    1:         Ph_WM_RENDER_TITLE | \
    1:         Ph_WM_RENDER_CLOSE | \
    1:         Ph_WM_RENDER_BORDER | \
    1:         Ph_WM_RENDER_RESIZE | \
    1:         Ph_WM_RENDER_MAX | \
    1:         Ph_WM_RENDER_MIN | \
    1:         Ph_WM_RENDER_MENU
    1: 
    1: 
    1:       if( mBorderStyle & eBorderStyle_all )	render_flags |= PH_BORDER_STYLE_ALL;
    1:       else
    1:       {
    1:         if( mBorderStyle & eBorderStyle_border )		render_flags |= Ph_WM_RENDER_BORDER;
    1:         if( mBorderStyle & eBorderStyle_title )			render_flags |= ( Ph_WM_RENDER_TITLE | Ph_WM_RENDER_BORDER );
    1:         if( mBorderStyle & eBorderStyle_close )			render_flags |= Ph_WM_RENDER_CLOSE;
    1:         if( mBorderStyle & eBorderStyle_menu )			render_flags |= Ph_WM_RENDER_MENU;
    1:         if( mBorderStyle & eBorderStyle_resizeh )		render_flags |= Ph_WM_RENDER_RESIZE;
    1:         if( mBorderStyle & eBorderStyle_minimize )		render_flags |= Ph_WM_RENDER_MIN;
    1:         if( mBorderStyle & eBorderStyle_maximize )		render_flags |= Ph_WM_RENDER_MAX;
    1:       }
    1:     }
    1: 	arg_count = 0;
    1:     if (mWindowType == eWindowType_dialog)
    1:     {
    1:     	// center on parent
    1:     	if (parentWidget)
    1:     	{
    1:     		PtCalcAbsPosition(parentWidget, NULL, &dim, &pos);
    1: 	    	PtSetArg( &arg[arg_count++], Pt_ARG_POS, &pos, 0 );
    1:     	}
    1: 	}
    1:     else if ((mWindowType == eWindowType_toplevel) && parentWidget)
    1:     {
    1: 			QueryVisible( );
    1:       pos.x += gConsoleRect.ul.x;
    1:       pos.y += gConsoleRect.ul.y;
    1:     	PtSetArg( &arg[arg_count++], Pt_ARG_POS, &pos, 0 );
    1:     }
    1: 
    1:     PtSetArg( &arg[arg_count++], Pt_ARG_DIM, &dim, 0 );
    1:     PtSetArg( &arg[arg_count++], Pt_ARG_RESIZE_FLAGS, 0, Pt_RESIZE_XY_BITS );
    1: 
    1:     /* Create Pop-up Menus as a PtRegion */
    1: 
    1:     if (!parentWidget)
    1:       PtSetParentWidget( nsnull );
    1: 		
    1:     if( mWindowType == eWindowType_popup ) {
    1: 
    1: 			/* the gMenuRegion is used to capture events outside of the application's canvas when menus are displayed */
    1: 			if( !gMenuRegion ) {
    1: 				PtArg_t args[10];
    1: 				PtSetParentWidget( NULL );
    1: 				PtSetArg( &args[0], Pt_ARG_REGION_PARENT, 0, 0 );
    1: 	  		PtSetArg( &args[1], Pt_ARG_FILL_COLOR, Pg_TRANSPARENT, 0);
    1: 				PhArea_t area = { { 0, 0 }, { SHRT_MAX, SHRT_MAX } };
    1: 				PtSetArg( &args[2], Pt_ARG_AREA, &area, 0 );
    1: 				PtSetArg( &args[3], Pt_ARG_REGION_SENSE, Ph_EV_BUT_PRESS, Ph_EV_BUT_PRESS );
    1: 				PtSetArg( &args[4], Pt_ARG_REGION_FLAGS, Ph_FORCE_BOUNDARY, Ph_FORCE_BOUNDARY );
    1: 				PtSetArg( &args[5], Pt_ARG_CURSOR_TYPE, Ph_CURSOR_POINTER, 0 );
    1: 				gMenuRegion = PtCreateWidget( PtRegion, NULL, 6, args );
    1: 				PtAddEventHandler( gMenuRegion, Ph_EV_BUT_PRESS, MenuRegionCallback, this );
    1: 				}
    1: 
    1: 	  	int	fields = Ph_REGION_PARENT|Ph_REGION_HANDLE| Ph_REGION_FLAGS|Ph_REGION_ORIGIN|Ph_REGION_EV_SENSE|Ph_REGION_EV_OPAQUE|Ph_REGION_RECT;
    1: 	  	int sense =  Ph_EV_BUT_PRESS | Ph_EV_BUT_RELEASE | Ph_EV_BUT_REPEAT;
    1: 			PtCallback_t cb_destroyed = { MenuRegionDestroyed, NULL };
    1: 
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_REGION_FIELDS,   fields, fields );
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_REGION_PARENT,   Ph_ROOT_RID, 0 );
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_REGION_SENSE,    sense | Ph_EV_DRAG|Ph_EV_EXPOSE, sense | Ph_EV_DRAG|Ph_EV_EXPOSE);
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_REGION_OPAQUE,   sense | Ph_EV_DRAG|Ph_EV_EXPOSE|Ph_EV_DRAW|Ph_EV_BLIT, sense |Ph_EV_DRAG|Ph_EV_EXPOSE|Ph_EV_DRAW|Ph_EV_BLIT);
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_FLAGS, Pt_DELAY_REALIZE, Pt_GETS_FOCUS | Pt_DELAY_REALIZE);
    1: 			PtSetArg( &arg[arg_count++], Pt_CB_DESTROYED, &cb_destroyed, 0 );
    1:       mWidget = PtCreateWidget( PtRegion, parentWidget, arg_count, arg);
    1: 
    1:     	// Must also create the client-area widget
    1:       arg_count = 0;
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_ANCHOR_FLAGS, Pt_ANCHOR_ALL, ~0 );
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_BORDER_WIDTH, 0 , 0 );
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_MARGIN_WIDTH, 0 , 0 );
    1:       PhRect_t anch_offset = {{0, 0},{0, 0}};
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_ANCHOR_OFFSETS, &anch_offset, 0 );
    1: 
    1:       PtSetArg( &arg[arg_count++], RDC_DRAW_FUNC, RawDrawFunc, 0 );
    1:       PtSetArg( &arg[arg_count++], Pt_ARG_FLAGS, 0, (Pt_HIGHLIGHTED | Pt_GETS_FOCUS));
    1:       mClientWidget = PtCreateWidget( PtRawDrawContainer, mWidget, arg_count, arg );
    1:      }
    1: 	else {
    1: 		/* Dialog and TopLevel Windows */
    1: 		PtSetArg( &arg[arg_count++], Pt_ARG_FLAGS, Pt_DELAY_REALIZE, Pt_DELAY_REALIZE);
    1: 		PtSetArg( &arg[arg_count++], Pt_ARG_WINDOW_RENDER_FLAGS, render_flags, -1 );
    1: 		PtSetArg( &arg[arg_count++], Pt_ARG_WINDOW_MANAGED_FLAGS, 0, Ph_WM_CLOSE );
    1: 		PtSetArg( &arg[arg_count++], Pt_ARG_WINDOW_NOTIFY_FLAGS, Ph_WM_CLOSE|Ph_WM_CONSWITCH|Ph_WM_FOCUS, ~0 );
    1: 		PtSetArg( &arg[arg_count++], Pt_ARG_FILL_COLOR, Pg_TRANSPARENT, 0 );
    1: 
    1: 		PtRawCallback_t cb_raw = { Ph_EV_INFO, EvInfo, NULL };
    1: 		PtCallback_t cb_resize = { ResizeHandler, NULL };
    1: 		PtCallback_t cb_window = { WindowWMHandler, this };
    1: 
    1: 		PtSetArg( &arg[arg_count++], Pt_CB_RESIZE, &cb_resize, NULL );
    1: 		PtSetArg( &arg[arg_count++], Pt_CB_RAW, &cb_raw, NULL );
    1: 		PtSetArg( &arg[arg_count++], Pt_CB_WINDOW, &cb_window, 0 );
    1: 		mWidget = PtCreateWidget( PtWindow, parentWidget, arg_count, arg );
    1: 		}
    1:   }
    1: 
    1:   if( mWidget ) {
    1: 	  SetInstance( mWidget, this );
    1: 	  if( mClientWidget ) SetInstance( mClientWidget, this );
    1: 	  if( mWindowType == eWindowType_child ) {
    1:       	PtAddCallback(mWidget, Pt_CB_RESIZE, ResizeHandler, nsnull ); 
    1:       	PtAddEventHandler( mWidget,
    1:       	  Ph_EV_PTR_MOTION_BUTTON | Ph_EV_PTR_MOTION_NOBUTTON |
    1:       	  Ph_EV_BUT_PRESS | Ph_EV_BUT_RELEASE |Ph_EV_BOUNDARY|Ph_EV_DRAG
    1:       	  , RawEventHandler, this );
    1: 	
    1:     		PtArg_t arg;
    1:     		PtRawCallback_t callback;
    1: 		
    1: 				callback.event_mask = ( Ph_EV_KEY ) ;
    1: 				callback.event_f = RawEventHandler;
    1: 				callback.data = this;
    1: 				PtSetArg( &arg, Pt_CB_FILTER, &callback, 0 );
    1: 				PtSetResources( mWidget, 1, &arg );
    1:     		}
    1:     else if( mWindowType == eWindowType_popup ) {
    1:       		PtAddEventHandler( mClientWidget,
    1:       			 	Ph_EV_PTR_MOTION_BUTTON | Ph_EV_PTR_MOTION_NOBUTTON | 
    1:       		  	Ph_EV_BUT_PRESS | Ph_EV_BUT_RELEASE |Ph_EV_BOUNDARY,
    1:       			  RawEventHandler, this );
    1: 
    1:       		PtAddEventHandler( mWidget, Ph_EV_DRAG, RawEventHandler, this );
    1: 
    1:       		PtArg_t arg;
    1:       		PtRawCallback_t callback;
    1: 		
    1: 					callback.event_mask = ( Ph_EV_KEY ) ;
    1: 					callback.event_f = RawEventHandler;
    1: 					callback.data = this;
    1: 					PtSetArg( &arg, Pt_CB_FILTER, &callback, 0 );
    1: 					PtSetResources( mClientWidget, 1, &arg );
    1: 			
    1:     		  PtAddCallback(mClientWidget, Pt_CB_RESIZE, ResizeHandler, nsnull ); 
    1: 					}
    1:     else if( !parentWidget ) {
    1:        if( mClientWidget ) PtAddCallback(mClientWidget, Pt_CB_RESIZE, ResizeHandler, nsnull );
    1:     	}
    1: 
    1:     // call the event callback to notify about creation
    1:     DispatchStandardEvent( NS_CREATE );
    1: 
    1:     result = NS_OK;
    1:   	}
    1: 
    1:   /* force SetCursor to actually set the cursor, even though our internal state indicates that we already
    1:      have the standard cursor */
    1:   mCursor = eCursor_wait;
    1:   SetCursor( mCursor );
    1: 
    1:   return result;
    1: 	}
    1: 
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Return some native data according to aDataType
    1: //
    1: //-------------------------------------------------------------------------
    1: void *nsWindow::GetNativeData(PRUint32 aDataType)
    1: {
    1:   switch(aDataType)
    1:   {
    1:   case NS_NATIVE_WINDOW:
    1:     if( !mWidget )	return (void *)mWidget;
    1: 
    1:   case NS_NATIVE_WIDGET:
    1: 		if (mClientWidget)	return (void *) mClientWidget;
    1: 		else	return (void *) mWidget;
    1:   }
    1:   	  	
    1:   return nsWidget::GetNativeData(aDataType);
    1: }
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Scroll the bits of a window
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Scroll( PRInt32 aDx, PRInt32 aDy, nsRect *aClipRect ) {
    1: 	PtWidget_t  *widget = (PtWidget_t *)GetNativeData(NS_NATIVE_WIDGET);
    1: 
    1: 	/* If aDx and aDy are 0 then skip it or if widget == null */
    1: 	if( ( !aDx && !aDy ) || (!widget )) return NS_OK;
    1: 
    1: 	PtStartFlux( widget );
    1: 
    1: 	PtWidget_t *w;
    1: 	for( w=PtWidgetChildFront( widget ); w; w=PtWidgetBrotherBehind( w )) {
    1: 		PtArg_t arg;
    1: 		PhPoint_t  p;
    1: 		p.x = w->area.pos.x + aDx;
    1: 		p.y = w->area.pos.y + aDy;
    1: 
    1: 		PtSetArg( &arg, Pt_ARG_POS, &p, 0 );
    1: 		PtSetResources( w, 1, &arg ) ;
    1: 
    1: 		nsWindow *pWin = (nsWindow *) GetInstance(w);
    1: 		if (pWin) {
    1: 			pWin->mBounds.x += aDx;
    1: 			pWin->mBounds.y += aDy;
    1: 			}
    1: 		}
    1: 
    1: 	PtEndFlux( widget);
    1: 
    1: 	PhRect_t source = {{widget->area.pos.x, widget->area.pos.y},{widget->area.pos.x+ widget->area.size.w-1, widget->area.pos.y + widget->area.size.h-1}};
    1: 	PhPoint_t point = { aDx, aDy };
    1: 
    1: 	if( !widget->damage_list )
    1: 		PtBlit( widget, &source, &point );
    1: 	else {
    1: 		/* first noticed as a scrolling problem in netscape email */
    1: 		/* the scrolling should be clipped out by the rectangles given by Invalidate(). These are accumulated in widget->damage_list */
    1: 		PhTile_t original = { source, NULL }, *clip;
    1: 
    1: 		clip = PhGetTile();
    1: 		clip->rect = source;
    1: 		clip->next = NULL;
    1: 		clip = PhClipTilings( clip, widget->damage_list, NULL );
    1: 
    1: 		if( clip ) {
    1: 			PtClippedBlit( widget, &original, &point, clip );
    1: 			PhFreeTiles( clip );
    1: 			}
    1: 		}
    1:   
    1: 	return NS_OK;
    1: 	}
    1: 
    1: NS_METHOD nsWindow::ScrollWidgets( PRInt32 aDx, PRInt32 aDy ) {
    1: 	PtWidget_t  *widget = (PtWidget_t *)GetNativeData(NS_NATIVE_WIDGET);
    1: 
    1: 	if( ( !aDx && !aDy ) || (!widget )) return NS_OK;
    1: 
    1: 	PtStartFlux( widget );
    1: 
    1: 	PtWidget_t *w;
    1: 	for( w=PtWidgetChildFront( widget ); w; w=PtWidgetBrotherBehind( w )) {
    1: 		PtArg_t arg;
    1: 		PhPoint_t  p;
    1: 		p.x = w->area.pos.x + aDx;
    1: 		p.y = w->area.pos.y + aDy;
    1: 		PtSetArg( &arg, Pt_ARG_POS, &p, 0 );
    1: 		PtSetResources( w, 1, &arg ) ;
    1: 
    1: 		nsWindow *pWin = (nsWindow *) GetInstance(w);
    1: 		if (pWin) {
    1: 			pWin->mBounds.x += aDx;
    1: 			pWin->mBounds.y += aDy;
    1: 			}
    1: 		}
    1: 
    1: 	PtEndFlux( widget);
    1: 	return NS_OK;    
    1: 	}
    1: 
    1: NS_METHOD nsWindow::SetTitle( const nsAString& aTitle ) {
    1:   if( mWidget ) {
    1:   	char * title = ToNewUTF8String(aTitle);
    1:     PtSetResource( mWidget, Pt_ARG_WINDOW_TITLE, title, 0 );
    1:   	if (title) nsCRT::free(title);
    1: 		}
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsWindow::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
    1: {
    1: 	PRBool nNeedToShow = PR_FALSE;
    1: 	
    1: 	if( aWidth == mBounds.width && aHeight == mBounds.height ) return NS_OK;
    1: 	
    1: 	mBounds.width  = aWidth;
    1: 	mBounds.height = aHeight;
    1: 	
    1: 	// code to keep the window from showing before it has been moved or resized
    1: 	// if we are resized to 1x1 or less, we will hide the window.  Show(TRUE) will be ignored until a larger resize has happened
    1: 	if( aWidth <= 1 || aHeight <= 1 ) {
    1: 		aWidth = aHeight = 1;
    1: 		mIsTooSmall = PR_TRUE;
    1: 		}
    1: 	else {
    1: 		if( mIsTooSmall ) {
    1: 			// if we are not shown, we don't want to force a show here, so check and see if Show(TRUE) has been called
    1: 			nNeedToShow = mShown;
    1: 			mIsTooSmall = PR_FALSE;
    1: 			}
    1: 		}
    1: 	
    1: 	PhDim_t  dim = { aWidth, aHeight };
    1: 	
    1: 	if( mWidget ) {
    1: 		// center the dialog
    1: 		if( mWindowType == eWindowType_dialog ) {
    1: 			PhPoint_t p;
    1: 			QueryVisible( );
    1: 			PtCalcAbsPosition( NULL, NULL, &dim, &p );
    1: 			p.x -= gConsoleRect.ul.x;
    1: 			p.y -= gConsoleRect.ul.y;
    1: 			Move(p.x, p.y); // the move should be in coordinates assuming the console is 0, 0
    1: 			}
    1: 		if( aRepaint == PR_FALSE )  PtStartFlux(mWidget);
    1: 		PtSetResource( mWidget, Pt_ARG_DIM, &dim, 0 );
    1: 		if( aRepaint == PR_FALSE ) PtEndFlux(mWidget);
    1: 
    1: 		/* ATENTIE Remove when wojtek fixes PR:22930 in the photon library */
    1: 		if( PtWidgetClass( mWidget ) == PtRegion ) PtSetResource( mWidget, Pt_ARG_REGION_OPAQUE, 0, Ph_EV_KEY );
    1: 		}
    1: 
    1: 	if( mIsToplevel || mListenForResizes ) {
    1: 		nsSizeEvent sevent(PR_TRUE, 0, nsnull);
    1: 		sevent.message = NS_SIZE;
    1: 		sevent.widget = this;
    1: 		
    1: 		sevent.windowSize = new nsRect (0, 0, aWidth, aHeight); 	
    1: 		
    1: 		sevent.refPoint.x = 0;
    1: 		sevent.refPoint.y = 0;
    1: 		sevent.mWinWidth = aWidth;
    1: 		sevent.mWinHeight = aHeight;
    1: 		// XXX fix this
    1: 		sevent.time = 0;
    1: 		AddRef();
    1: 		DispatchWindowEvent(&sevent);
    1: 		Release();
    1: 		delete sevent.windowSize;
    1: 		}
    1: 	if( nNeedToShow ) Show(PR_TRUE);
    1: 	return NS_OK;
    1: }
    1: 
    1: int nsWindow::WindowWMHandler( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo ) 
    1: {
    1: 	PhWindowEvent_t *we = (PhWindowEvent_t *) cbinfo->cbdata;
    1: 	switch( we->event_f ) {
    1: 		case Ph_WM_CLOSE:
    1: 		  {
    1: 				nsWindow * win = (nsWindow*) data;
    1: 			  NS_ADDREF(win);
    1: 			  
    1: 			  // dispatch an "onclose" event. to delete immediately, call win->Destroy()
    1: 			  nsGUIEvent event(PR_TRUE, 0, nsnull);
    1: 			  nsEventStatus status;
    1: 			  
    1: 			  event.message = NS_XUL_CLOSE;
    1: 			  event.widget  = win;
    1: 			  
    1: 			  event.time = 0;
    1: 			  event.refPoint.x = 0;
    1: 			  event.refPoint.y = 0;
    1: 			  
    1: 			  win->DispatchEvent(&event, status);
    1: 			  
    1: 			  NS_RELEASE(win);
    1: 		  }
    1: 		break;
    1: 
    1: 		case Ph_WM_CONSWITCH:
    1: 			gConsoleRectValid = PR_FALSE; /* force a call tp PhWindowQueryVisible() next time, since we might have moved this window into a different console */
    1:       /* rollup the menus */
 8591:       if( gRollupWidget && gRollupListener ) gRollupListener->Rollup(nsnull);
    1: 			break;
    1: 
    1: 		case Ph_WM_FOCUS:
    1: 			if( we->event_state == Ph_WM_EVSTATE_FOCUSLOST ) {
    1:       	/* rollup the menus */
 8591:       	if( gRollupWidget && gRollupListener ) gRollupListener->Rollup(nsnull);
    1: 
    1: 				if( sFocusWidget ) sFocusWidget->DispatchStandardEvent(NS_DEACTIVATE);
    1: 				}
    1: 			break;
    1: 	}
    1: 	
    1: 	return Pt_CONTINUE;
    1: }
    1: 
    1: void nsWindow::RawDrawFunc( PtWidget_t * pWidget, PhTile_t * damage )
    1: {
    1:   nsWindow  * pWin = (nsWindow*) GetInstance( pWidget );
    1:   nsresult    result;
    1:   PhTile_t  * dmg = NULL;
    1:   nsPaintEvent pev(PR_TRUE, 0, nsnull);
    1:   PhRect_t   extent;
    1: 
    1:   if( !pWin || !pWin->mContext ) return;
    1: 
    1: 	if ( pWin->mEventCallback ) {
    1: 		PhPoint_t  offset;
    1: 		nsRect     nsDmg;
    1: 
    1: 		// Ok...  The damage rect is in window coordinates and is not neccessarily clipped to
    1: 		// the widgets canvas. Mozilla wants the paint coords relative to the parent widget, not the window.
    1: 		PtWidgetExtent(pWidget, &extent);
    1: 		PtWidgetOffset(pWidget, &offset);
    1: 		/* Build a List of Tiles that might be in front of me.... */
    1: 		PhTile_t *new_damage, *clip_tiles, *intersect;
    1: 		/* Intersect the Damage tile list w/ the clipped out list and see what's left! */
    1: 		new_damage = PhRectsToTiles(&damage->rect, 1);
    1: 		PhDeTranslateTiles(new_damage, &offset);
    1: 		clip_tiles = GetWindowClipping( pWidget );
    1: 		if (clip_tiles) {
    1: 			new_damage = PhClipTilings( new_damage, clip_tiles, NULL);
    1: 			PhFreeTiles(clip_tiles);
    1: 		}
    1: 		clip_tiles = PhRectsToTiles(&extent, 1);
    1: 		intersect = PhIntersectTilings( new_damage, clip_tiles, NULL);
    1: 		if ( intersect == NULL ) return;
    1: 		PhDeTranslateTiles(intersect, &extent.ul);
    1: 		PhFreeTiles(clip_tiles);
    1: 		PhFreeTiles(new_damage);
    1: 		new_damage = intersect;
    1: 		
    1: 		pWin->InitEvent(pev, NS_PAINT);
    1: 		pev.region = nsnull;
    1: 		pev.renderingContext = nsnull;
    1: 		pev.renderingContext = pWin->GetRenderingContext();
    1: 		for( dmg = new_damage; dmg; dmg = dmg->next ) {
    1: 			nsDmg.x = dmg->rect.ul.x;
    1: 			nsDmg.y = dmg->rect.ul.y;
    1: 			nsDmg.width = dmg->rect.lr.x - dmg->rect.ul.x + 1;
    1: 			nsDmg.height = dmg->rect.lr.y - dmg->rect.ul.y + 1;
    1: 
    1: 			if( (nsDmg.width <= 0 ) || (nsDmg.height <= 0 ) ) /* Move to the next Damage Tile */
    1: 				continue;
    1: 
    1: 			/* Re-Setup Paint Event */
    1: 			pWin->InitEvent(pev, NS_PAINT);
    1: 			pev.refPoint.x = nsDmg.x;
    1: 			pev.refPoint.y = nsDmg.y;
    1: 			pev.rect = &nsDmg;
    1: 			pev.region = nsnull;
    1: 
    1: 			if( pev.renderingContext ) {
    1: 				nsIRegion *ClipRegion = pWin->GetRegion( );
    1: 				ClipRegion->SetTo( nsDmg.x, nsDmg.y, nsDmg.width, nsDmg.height );
 3233: 				pev.renderingContext->SetClipRegion( static_cast<const nsIRegion &>(*(ClipRegion)), nsClipCombine_kReplace );
    1: 
    1: 				NS_RELEASE( ClipRegion );
    1: 				
    1: 				/* You can turn off most drawing if you take this out */
    1: 				result = pWin->DispatchWindowEvent(&pev);
    1: 			}
    1: 		}
    1: 		NS_RELEASE(pev.renderingContext);
    1: 		PhFreeTiles( new_damage );
    1: 	}
    1: }
    1: 
    1: static PhTile_t *GetWindowClipping( PtWidget_t *aWidget ) {
    1: 	PtWidget_t *w;
    1: 	PhTile_t *clip_tiles = NULL, *last = NULL;
    1: 	PhRect_t w_extent;
    1: 
    1: 	PtWidgetExtent( aWidget, &w_extent);
    1: 	
    1: 	for( w = PtWidgetChildFront( aWidget ); w; w=PtWidgetBrotherBehind( w ) ) {
    1: 		long flags = PtWidgetFlags( w );
    1: 		if( (flags & Pt_REALIZED) && (flags & Pt_OPAQUE) && !PtIsDisjoint(w) ) {
    1: 			PhTile_t *tile = PhGetTile( );
    1: 			if( !tile ) return NULL;
    1: 
    1: 			tile->rect.ul.x = w->area.pos.x + w_extent.ul.x;
    1: 			tile->rect.ul.y = w->area.pos.y + w_extent.ul.y;
    1: 			tile->rect.lr.x = tile->rect.ul.x + w->area.size.w - 1;
    1: 			tile->rect.lr.y = tile->rect.ul.y + w->area.size.h - 1;
    1: 
    1: 			tile->next = NULL;
    1: 			if( !clip_tiles ) clip_tiles = tile;
    1: 			if( last ) last->next = tile;
    1: 			last = tile;
    1: 			}
    1: 		}
    1: 	return clip_tiles;
    1: 	}
    1: 
    1: int nsWindow::ResizeHandler( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo )
    1: {
    1:   nsWindow *someWindow = (nsWindow *) GetInstance(widget);
    1:   if( someWindow ) {
    1:   	PtContainerCallback_t *cb = (PtContainerCallback_t *) cbinfo->cbdata;
    1:   	PhRect_t *extents = &cb->new_size;
    1:   	nsRect rect;
    1: 		rect.x = extents->ul.x;
    1:     rect.y = extents->ul.y;
    1:     rect.width = extents->lr.x - rect.x + 1;
    1:     rect.height = extents->lr.y - rect.y + 1;
    1: 
    1:     if( someWindow->mBounds.width == rect.width && someWindow->mBounds.height == rect.height )
    1: 		  return Pt_CONTINUE;
    1: 
    1:     someWindow->mBounds.width  = rect.width;
    1:     someWindow->mBounds.height = rect.height;
    1: 
    1:     /* This enables the resize holdoff */
    1:     if( PtWidgetIsRealized( widget ) ) someWindow->OnResize( rect );
    1:   	}
    1: 	return Pt_CONTINUE;
    1: }
    1: 
    1: 
    1: /* catch an Ph_EV_INFO event when the graphics mode has changed */
    1: int nsWindow::EvInfo( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo ) {
    1: 
    1: 	if( cbinfo->event && cbinfo->event->type == Ph_EV_INFO && cbinfo->event->subtype == Ph_OFFSCREEN_INVALID ) {
    1: 		nsresult rv;
    1: 		
    1: 		nsCOMPtr<nsIPrefBranch> pPrefs = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
    1: 		if (NS_SUCCEEDED(rv)) {
    1: 			 PRBool displayInternalChange = PR_FALSE;
    1: 			 pPrefs->GetBoolPref("browser.display.internaluse.graphics_changed", &displayInternalChange);
    1: 			 pPrefs->SetBoolPref("browser.display.internaluse.graphics_changed", !displayInternalChange);
    1: 		}
    1: 		nsCOMPtr<nsIWindowMediator> windowMediator(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
    1: 		NS_ENSURE_TRUE(windowMediator, NS_ERROR_FAILURE);
    1: 
    1: 		nsCOMPtr<nsISimpleEnumerator> windowEnumerator;
    1: 		NS_ENSURE_SUCCESS(windowMediator->GetXULWindowEnumerator(nsnull, getter_AddRefs(windowEnumerator)), NS_ERROR_FAILURE);
    1: 
    1: 		PRBool more;
    1: 		windowEnumerator->HasMoreElements(&more);
    1: 		while(more) {
    1: 			nsCOMPtr<nsISupports> nextWindow = nsnull;
    1: 			windowEnumerator->GetNext(getter_AddRefs(nextWindow));
    1: 			nsCOMPtr<nsIXULWindow> xulWindow(do_QueryInterface(nextWindow));
    1: 			NS_ENSURE_TRUE(xulWindow, NS_ERROR_FAILURE);
    1: 	
    1: 			nsCOMPtr<nsIDocShell> docShell;
    1: 			xulWindow->GetDocShell(getter_AddRefs(docShell));
    1: 
    1: 			nsCOMPtr<nsIPresShell> presShell;
    1: 			docShell->GetPresShell( getter_AddRefs(presShell) );
    1: 
    1: 			nsIViewManager* viewManager = presShell->GetViewManager();
    1: 			NS_ENSURE_TRUE(viewManager, NS_ERROR_FAILURE);
    1: 
    1: 			windowEnumerator->HasMoreElements(&more);
    1: 			}
    1: 
    1: 		PtDamageWidget( widget );
    1: 		}
    1: 	return Pt_CONTINUE;
    1: 	}
    1: 
    1: //-------------------------------------------------------------------------
    1: //
    1: // Move this component
    1: //
    1: //-------------------------------------------------------------------------
    1: NS_METHOD nsWindow::Move( PRInt32 aX, PRInt32 aY ) {
    1: 
    1: 	if( mWindowType != eWindowType_popup && (mBounds.x == aX) && (mBounds.y == aY) )
    1: 		return NS_OK;
    1: 
    1: 	mBounds.x = aX;
    1: 	mBounds.y = aY;
    1: 
    1: 	switch( mWindowType ) {
    1: 		case eWindowType_popup:
    1: 			{
    1: 			PhPoint_t offset, total_offset = { 0, 0 };
    1:     
    1: 			PtWidget_t *parent, *disjoint = PtFindDisjoint( mWidget->parent );
    1: 
    1: 			while( disjoint ) {
    1: 				PtGetAbsPosition( disjoint, &offset.x, &offset.y );
    1: 				total_offset.x += offset.x;
    1: 				total_offset.y += offset.y;
    1: 				if( PtWidgetIsClass( disjoint, PtWindow ) || PtWidgetIsClass( disjoint, PtServer ) ) break; /* Stop at the first PtWindow */
    1: 				parent = PtWidgetParent(disjoint);
    1: 				if( parent ) disjoint = PtFindDisjoint( parent );
    1: 				else {
    1: 					disjoint = parent;
    1: 					break;
    1: 					}           
    1: 				}
    1: 
    1: 			aX += total_offset.x;
    1: 			aY += total_offset.y;
    1: 
    1: 			/* Add the Offset if the widget is offset from its parent.. */
    1: 			PtWidgetOffset( mWidget->parent, &offset );
    1: 			aX += offset.x;
    1: 			aY += offset.y;
    1: 			}
    1: 			break;
    1: 
    1: 		case eWindowType_dialog:
    1: 		case eWindowType_toplevel:
    1: 			/* Offset to the current virtual console */
    1: 			QueryVisible( );
    1: 			aX += gConsoleRect.ul.x;
    1: 			aY += gConsoleRect.ul.y;
    1: 			break;
    1: 		}
    1: 
    1:   if( mWidget ) {
    1:     if(( mWidget->area.pos.x != aX ) || ( mWidget->area.pos.y != aY )) {
    1:       PhPoint_t pos = { aX, aY };
    1:       PtSetResource( mWidget, Pt_ARG_POS, &pos, 0 );
    1: 
    1: 			/* ATENTIE Remove when wojtek fixes PR:22930 in the photon library */
    1: 			if( PtWidgetClass( mWidget ) == PtRegion ) PtSetResource( mWidget, Pt_ARG_REGION_OPAQUE, 0, Ph_EV_KEY );
    1:     	}
    1:   	}
    1: 
    1: 	return NS_OK;
    1: 	}
    1: 
    1: int nsWindow::MenuRegionCallback( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo ) {
    1: 	if( gRollupWidget && gRollupListener ) {
    1: 		/* rollup the menu */
 8591: 		gRollupListener->Rollup(nsnull);
    1: 		}
    1: 	return Pt_CONTINUE;
    1: 	}
    1: 
    1: NS_IMETHODIMP nsWindow::SetModal( PRBool aModal ) {
    1:   nsresult res = NS_ERROR_FAILURE;
    1:  
    1:   if (!mWidget)
    1: 	return NS_ERROR_FAILURE;
    1: 
    1:   PtWidget_t *toplevel = PtFindDisjoint(mWidget);
    1:   if( !toplevel ) return NS_ERROR_FAILURE;
    1: 
    1:   if( aModal ) {
    1: 	  PtModalStart();
    1: 	  res = NS_OK;
    1:   	}
    1:   else {
    1: 		PtModalEnd();
    1:     res = NS_OK;
    1:   	}
    1: 
    1:   return res;
    1: 	}
    1: 
    1: 
    1: inline nsIRegion *nsWindow::GetRegion()
    1: {
    1:   nsIRegion *region = NULL;
    1:   nsresult res;
    1: 
    1:   static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
    1: 
    1:   res = CallCreateInstance( kRegionCID, &region );
    1:   if (NS_SUCCEEDED(res)) region->Init();
    1: 
    1:   NS_ASSERTION(NULL != region, "Null region context");
    1:   
    1:   return region;  
    1: }
    1: 
    1: /*
    1: 	widget is a PtRegion representing the native widget for a menu - reset the mParent->mLastMenu
    1: 	since it points to an widget being destroyed
    1: */
    1: int nsWindow::MenuRegionDestroyed( PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo )
    1: {
    1: 	nsWindow *pWin = (nsWindow *) GetInstance( widget );
    1: 	if( pWin ) {
    1: 		nsWindow *parent = ( nsWindow * ) pWin->mParent;
    1: 		if( parent && parent->mLastMenu == widget )
    1: 			parent->mLastMenu = nsnull;
    1: 		}
    1: 	return Pt_CONTINUE;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::SetFocus(PRBool aRaise)
    1: {
    1: 	sFocusWidget = this;
    1: 
    1: 	if( PtIsFocused( mWidget ) == 2 ) return NS_OK;
    1: 
    1: 	if( mWidget ) {
    1: 		PtWidget_t *disjoint;
    1: 		disjoint = PtFindDisjoint( mWidget );
    1: 		if( PtWidgetIsClass( disjoint, PtWindow ) ) {
    1: 			if( !( PtWindowGetState( disjoint ) & Ph_WM_STATE_ISFOCUS ) ) {
    1: 				nsWindow *pWin = (nsWindow *) GetInstance( disjoint );
    1: 				pWin->GetAttention( -1 );
    1: 				}
    1: 			}
    1: 		PtContainerGiveFocus( mWidget, NULL );
    1: 		}
    1: 	return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsWindow::MakeFullScreen(PRBool aFullScreen)
    1: {
    1: 	/* we can use static data here because there can be only one full-screen window at a time */
    1: 	static unsigned short old_render_flags;
    1: 	static PhPoint_t old_pos;
    1: 
    1: 	PtArg_t args[3];
    1: 
    1: 	if( aFullScreen ) {
    1: 		unsigned short p, *pflags;
    1: 		PhArea_t area;
    1: 
    1: 		PtSetArg( &args[0], Pt_ARG_WINDOW_RENDER_FLAGS, &pflags, 0 );
    1: 		PtGetResources( mWidget, 1, args );
    1: 		p = old_render_flags = *pflags; // save the render flags
    1: 		p &= ~(Ph_WM_RENDER_TITLE|Ph_WM_RENDER_BORDER);
    1: 
    1: 		PtWidgetArea( mWidget, &area );
    1: 		old_pos = area.pos;
    1: 
    1: 		QueryVisible( );
    1: 		PtSetArg( &args[0], Pt_ARG_POS, &gConsoleRect.ul, 0 );
    1: 		PtSetArg( &args[1], Pt_ARG_WINDOW_RENDER_FLAGS, p, -1 );
    1: 		PtSetArg( &args[2], Pt_ARG_WINDOW_STATE, Ph_WM_STATE_ISFRONT, Ph_WM_STATE_ISFRONT );
    1: 		PtSetResources( mWidget, 3, args );
    1: 		}
    1: 	else {
    1: 		PtSetArg( &args[0], Pt_ARG_POS, &old_pos, 0 );
    1: 		PtSetArg( &args[1], Pt_ARG_WINDOW_RENDER_FLAGS, old_render_flags, -1 ); /* restore the render flags to the previous value */
    1: 		PtSetArg( &args[2], Pt_ARG_WINDOW_STATE, Ph_WM_STATE_ISNORMAL, Ph_WM_STATE_ISFRONT|Ph_WM_STATE_ISNORMAL );
    1: 		PtSetResources( mWidget, 3, args );
    1: 		}
    1: 
    1: 	return nsBaseWidget::MakeFullScreen( aFullScreen );
    1: }
