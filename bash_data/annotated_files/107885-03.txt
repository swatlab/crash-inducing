 72423: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 72423: 
 72423: #ifndef MOZILLA_GFX_HELPERSD2D_H_
 72423: #define MOZILLA_GFX_HELPERSD2D_H_
 72423: 
 77056: #include <d2d1.h>
 98510: #include <dwrite.h>
 72423: #include "2D.h"
 72423: 
 98510: #include "ScaledFontDWrite.h"
 98510: 
 72423: namespace mozilla {
 72423: namespace gfx {
 72423: 
 72423: static inline D2D1_POINT_2F D2DPoint(const Point &aPoint)
 72423: {
 72423:   return D2D1::Point2F(aPoint.x, aPoint.y);
 72423: }
 72423: 
 72423: static inline D2D1_SIZE_U D2DIntSize(const IntSize &aSize)
 72423: {
 72423:   return D2D1::SizeU(aSize.width, aSize.height);
 72423: }
 72423: 
 72423: static inline D2D1_RECT_F D2DRect(const Rect &aRect)
 72423: {
 72423:   return D2D1::RectF(aRect.x, aRect.y, aRect.XMost(), aRect.YMost());
 72423: }
 72423: 
 86250: static inline D2D1_EXTEND_MODE D2DExtend(ExtendMode aExtendMode)
 86250: {
101053:   D2D1_EXTEND_MODE extend;
 86250:   switch (aExtendMode) {
 86250:   case EXTEND_REPEAT:
 86250:     extend = D2D1_EXTEND_MODE_WRAP;
 86250:     break;
 86250:   case EXTEND_REFLECT:
 86250:     extend = D2D1_EXTEND_MODE_MIRROR;
 86250:     break;
101053:   default:
101053:     extend = D2D1_EXTEND_MODE_CLAMP;
 86250:   }
 86250: 
 86250:   return extend;
 86250: }
 86250: 
 72423: static inline D2D1_BITMAP_INTERPOLATION_MODE D2DFilter(const Filter &aFilter)
 72423: {
 72423:   switch (aFilter) {
 72423:   case FILTER_POINT:
 72423:     return D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR;
101053:   default:
101053:     return D2D1_BITMAP_INTERPOLATION_MODE_LINEAR;
 99911:   }
 72423: }
 72423: 
 86250: static inline D2D1_ANTIALIAS_MODE D2DAAMode(AntialiasMode aMode)
 72423: {
 72423:   switch (aMode) {
 72423:   case AA_NONE:
 86250:     return D2D1_ANTIALIAS_MODE_ALIASED;
101053:   default:
101053:     return D2D1_ANTIALIAS_MODE_PER_PRIMITIVE;
 99911:   }
 72423: }
 72423: 
 72423: static inline D2D1_MATRIX_3X2_F D2DMatrix(const Matrix &aTransform)
 72423: {
 72423:   return D2D1::Matrix3x2F(aTransform._11, aTransform._12,
 72423:                           aTransform._21, aTransform._22,
 72423:                           aTransform._31, aTransform._32);
 72423: }
 72423: 
 72423: static inline D2D1_COLOR_F D2DColor(const Color &aColor)
 72423: {
 72423:   return D2D1::ColorF(aColor.r, aColor.g, aColor.b, aColor.a);
 72423: }
 72423: 
 72423: static inline IntSize ToIntSize(const D2D1_SIZE_U &aSize)
 72423: {
 72423:   return IntSize(aSize.width, aSize.height);
 72423: }
 72423: 
 72423: static inline SurfaceFormat ToPixelFormat(const D2D1_PIXEL_FORMAT &aFormat)
 72423: {
 72423:   switch(aFormat.format) {
 72423:   case DXGI_FORMAT_A8_UNORM:
 72423:     return FORMAT_A8;
 72423:   case DXGI_FORMAT_B8G8R8A8_UNORM:
 72423:     if (aFormat.alphaMode == D2D1_ALPHA_MODE_IGNORE) {
 72423:       return FORMAT_B8G8R8X8;
 72423:     } else {
 72423:       return FORMAT_B8G8R8A8;
 72423:     }
101053:   default:
101053:     return FORMAT_B8G8R8A8;
 99911:   }
 72423: }
 72423: 
 72423: static inline Rect ToRect(const D2D1_RECT_F &aRect)
 72423: {
 72423:   return Rect(aRect.left, aRect.top, aRect.right - aRect.left, aRect.bottom - aRect.top);
 72423: }
 72423: 
 72423: static inline DXGI_FORMAT DXGIFormat(SurfaceFormat aFormat)
 72423: {
 72423:   switch (aFormat) {
 72423:   case FORMAT_B8G8R8A8:
 72423:     return DXGI_FORMAT_B8G8R8A8_UNORM;
 72423:   case FORMAT_B8G8R8X8:
 72423:     return DXGI_FORMAT_B8G8R8A8_UNORM;
 72423:   case FORMAT_A8:
 72423:     return DXGI_FORMAT_A8_UNORM;
101053:   default:
101053:     return DXGI_FORMAT_UNKNOWN;
 99911:   }
 72423: }
 72423: 
 72423: static inline D2D1_ALPHA_MODE AlphaMode(SurfaceFormat aFormat)
 72423: {
 72423:   switch (aFormat) {
 72423:   case FORMAT_B8G8R8X8:
 72423:     return D2D1_ALPHA_MODE_IGNORE;
101053:   default:
101053:     return D2D1_ALPHA_MODE_PREMULTIPLIED;
 99911:   }
 72423: }
 72423: 
 86250: static inline D2D1_PIXEL_FORMAT D2DPixelFormat(SurfaceFormat aFormat)
 86250: {
 86250:   return D2D1::PixelFormat(DXGIFormat(aFormat), AlphaMode(aFormat));
 86250: }
 86250: 
101053: static inline bool IsPatternSupportedByD2D(const Pattern &aPattern)
 73619: {
 73619:   if (aPattern.GetType() != PATTERN_RADIAL_GRADIENT) {
 73619:     return false;
 73619:   }
 73619: 
 73619:   const RadialGradientPattern *pat =
 73619:     static_cast<const RadialGradientPattern*>(&aPattern);
 73619:   
 73619:   if (pat->mRadius1 != 0) {
 73619:     return true;
 73619:   }
 73619: 
 73619:   Point diff = pat->mCenter2 - pat->mCenter1;
 73619: 
 73619:   if (sqrt(diff.x * diff.x + diff.y * diff.y) >= pat->mRadius2) {
 73619:     // Inner point lies outside the circle.
 73619:     return true;
 73619:   }
 73619: 
 73619:   return false;
 73619: }
 73619: 
 72423: /**
 72423:  * This structure is used to pass rectangles to our shader constant. We can use
 72423:  * this for passing rectangular areas to SetVertexShaderConstant. In the format
 72423:  * of a 4 component float(x,y,width,height). Our vertex shader can then use
 72423:  * this to construct rectangular positions from the 0,0-1,1 quad that we source
 72423:  * it with.
 72423:  */
 72423: struct ShaderConstantRectD3D10
 72423: {
 72423:   float mX, mY, mWidth, mHeight;
 72423:   ShaderConstantRectD3D10(float aX, float aY, float aWidth, float aHeight)
 72423:     : mX(aX), mY(aY), mWidth(aWidth), mHeight(aHeight)
 72423:   { }
 72423: 
 72423:   // For easy passing to SetVertexShaderConstantF.
 72423:   operator float* () { return &mX; }
 72423: };
 72423: 
101053: static inline DWRITE_MATRIX
 98510: DWriteMatrixFromMatrix(Matrix &aMatrix)
 98510: {
 98510:   DWRITE_MATRIX mat;
 98510:   mat.m11 = aMatrix._11;
 98510:   mat.m12 = aMatrix._12;
 98510:   mat.m21 = aMatrix._21;
 98510:   mat.m22 = aMatrix._22;
 98510:   mat.dx = aMatrix._31;
 98510:   mat.dy = aMatrix._32;
 98510:   return mat;
 98510: }
 98510: 
 98510: class AutoDWriteGlyphRun : public DWRITE_GLYPH_RUN
 98510: {
101053:     static const unsigned kNumAutoGlyphs = 256;
 98510: 
 98510: public:
 98510:     AutoDWriteGlyphRun() {
 98510:         glyphCount = 0;
 98510:     }
 98510: 
 98510:     ~AutoDWriteGlyphRun() {
 98510:         if (glyphCount > kNumAutoGlyphs) {
 98510:             delete[] glyphIndices;
 98510:             delete[] glyphAdvances;
 98510:             delete[] glyphOffsets;
 98510:         }
 98510:     }
 98510: 
101053:     void allocate(unsigned aNumGlyphs) {
 98510:         glyphCount = aNumGlyphs;
 98510:         if (aNumGlyphs <= kNumAutoGlyphs) {
 98510:             glyphIndices = &mAutoIndices[0];
 98510:             glyphAdvances = &mAutoAdvances[0];
 98510:             glyphOffsets = &mAutoOffsets[0];
 98510:         } else {
 98510:             glyphIndices = new UINT16[aNumGlyphs];
 98510:             glyphAdvances = new FLOAT[aNumGlyphs];
 98510:             glyphOffsets = new DWRITE_GLYPH_OFFSET[aNumGlyphs];
 98510:         }
 98510:     }
 98510: 
 98510: private:
 98510:     DWRITE_GLYPH_OFFSET mAutoOffsets[kNumAutoGlyphs];
 98510:     FLOAT               mAutoAdvances[kNumAutoGlyphs];
 98510:     UINT16              mAutoIndices[kNumAutoGlyphs];
 98510: };
 98510: 
101053: static inline void
 98510: DWriteGlyphRunFromGlyphs(const GlyphBuffer &aGlyphs, ScaledFontDWrite *aFont, AutoDWriteGlyphRun *run)
 98510: {
 98510:   run->allocate(aGlyphs.mNumGlyphs);
 98510: 
 98510:   FLOAT *advances = const_cast<FLOAT*>(run->glyphAdvances);
 98510:   UINT16 *indices = const_cast<UINT16*>(run->glyphIndices);
 98510:   DWRITE_GLYPH_OFFSET *offsets = const_cast<DWRITE_GLYPH_OFFSET*>(run->glyphOffsets);
 98510: 
 98510:   memset(advances, 0, sizeof(FLOAT) * aGlyphs.mNumGlyphs);
 98510:   for (unsigned int i = 0; i < aGlyphs.mNumGlyphs; i++) {
 98510:     indices[i] = aGlyphs.mGlyphs[i].mIndex;
 98510:     offsets[i].advanceOffset = aGlyphs.mGlyphs[i].mPosition.x;
 98510:     offsets[i].ascenderOffset = -aGlyphs.mGlyphs[i].mPosition.y;
 98510:   }
 98510:     
 98510:   run->bidiLevel = 0;
 98510:   run->fontFace = aFont->mFontFace;
107885:   run->fontEmSize = aFont->GetSize();
 98510:   run->glyphCount = aGlyphs.mNumGlyphs;
 98510:   run->isSideways = FALSE;
 98510: }
 98510: 
 72423: }
 72423: }
 72423: 
 72423: #endif /* MOZILLA_GFX_HELPERSD2D_H_ */
