    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
    1:  *   Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessible.h"
39503: 
39503: #include "nsIXBLAccessible.h"
39503: 
47172: #include "AccGroupInfo.h"
43888: #include "AccIterator.h"
41384: #include "nsAccUtils.h"
41384: #include "nsDocAccessible.h"
41384: #include "nsEventShell.h"
41384: 
51377: #include "nsAccEvent.h"
41384: #include "nsAccessibilityService.h"
39503: #include "nsAccTreeWalker.h"
41384: #include "nsRelUtils.h"
41384: #include "nsTextEquivUtils.h"
 4451: 
 4451: #include "nsIDOMElement.h"
 4451: #include "nsIDOMDocument.h"
 4451: #include "nsIDOMDocumentXBL.h"
 4451: #include "nsIDOMDocumentTraversal.h"
 4451: #include "nsIDOMHTMLDocument.h"
 4451: #include "nsIDOMHTMLFormElement.h"
 4451: #include "nsIDOMNodeFilter.h"
 1253: #include "nsIDOMNSHTMLElement.h"
 4451: #include "nsIDOMTreeWalker.h"
 4451: #include "nsIDOMXULButtonElement.h"
 4451: #include "nsIDOMXULDocument.h"
 4451: #include "nsIDOMXULElement.h"
 4451: #include "nsIDOMXULLabelElement.h"
 4451: #include "nsIDOMXULSelectCntrlEl.h"
 4451: #include "nsIDOMXULSelectCntrlItemEl.h"
 4451: #include "nsPIDOMWindow.h"
 4451: 
 4451: #include "nsIDocument.h"
 4451: #include "nsIContent.h"
 4451: #include "nsIForm.h"
 4451: #include "nsIFormControl.h"
 4451: 
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIFrame.h"
37073: #include "nsIView.h"
 4451: #include "nsIDocShellTreeItem.h"
12642: #include "nsIScrollableFrame.h"
29018: #include "nsFocusManager.h"
 4451: 
    1: #include "nsXPIDLString.h"
    1: #include "nsUnicharUtils.h"
 6279: #include "nsReadableUtils.h"
    1: #include "prdtoa.h"
    1: #include "nsIAtom.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIURI.h"
24822: #include "nsArrayUtils.h"
    1: #include "nsIMutableArray.h"
  511: #include "nsIObserverService.h"
 4451: #include "nsIServiceManager.h"
 7830: #include "nsWhitespaceTokenizer.h"
13012: #include "nsAttrName.h"
13757: #include "nsNetUtil.h"
55425: #include "nsIEventStateManager.h"
    1: 
    1: #ifdef NS_DEBUG
    1: #include "nsIDOMCharacterData.h"
    1: #endif
    1: 
50861: #include "mozilla/unused.h"
50861: 
    1: 
16428: ////////////////////////////////////////////////////////////////////////////////
16428: // nsAccessible. nsISupports
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_CLASS(nsAccessible)
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsAccessible, nsAccessNode)
36989:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mParent");
36989:   cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mParent.get()));
36989: 
36989:   PRUint32 i, length = tmp->mChildren.Length();
36989:   for (i = 0; i < length; ++i) {
36989:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
36989:     cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mChildren[i].get()));
36989:   }
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsAccessible, nsAccessNode)
16428:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParent)
36989:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mChildren)
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16428: 
    1: NS_IMPL_ADDREF_INHERITED(nsAccessible, nsAccessNode)
    1: NS_IMPL_RELEASE_INHERITED(nsAccessible, nsAccessNode)
    1: 
    1: nsresult nsAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   // Custom-built QueryInterface() knows when we support nsIAccessibleSelectable
 8937:   // based on role attribute and aria-multiselectable
    1:   *aInstancePtr = nsnull;
    1: 
16428:   if (aIID.Equals(NS_GET_IID(nsXPCOMCycleCollectionParticipant))) {
16428:     *aInstancePtr = &NS_CYCLE_COLLECTION_NAME(nsAccessible);
16428:     return NS_OK;
16428:   }
16428: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessible))) {
 3233:     *aInstancePtr = static_cast<nsIAccessible*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   }
    1: 
20246:   if (aIID.Equals(NS_GET_IID(nsAccessible))) {
20246:     *aInstancePtr = static_cast<nsAccessible*>(this);
20246:     NS_ADDREF_THIS();
20246:     return NS_OK;
20246:   }
20246: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleSelectable))) {
51865:     if (IsSelect()) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleSelectable*>(this);
    1:       NS_ADDREF_THIS();
 4648:       return NS_OK;
    1:     }
51865:     return NS_ERROR_NO_INTERFACE;
    1:   }
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleValue))) {
    1:     if (mRoleMapEntry && mRoleMapEntry->valueRule != eNoValue) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleValue*>(this);
    1:       NS_ADDREF_THIS();
 4648:       return NS_OK;
    1:     }
    1:   }                       
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperLink))) {
51810:     if (IsHyperLink()) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleHyperLink*>(this);
    1:       NS_ADDREF_THIS();
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_NO_INTERFACE;
    1:   }
    1: 
 4470:   return nsAccessNodeWrap::QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
43504: nsAccessible::nsAccessible(nsIContent *aContent, nsIWeakReference *aShell) :
43504:   nsAccessNodeWrap(aContent, aShell),
61466:   mParent(nsnull), mIndexInParent(-1), mFlags(eChildrenUninitialized),
50622:   mIndexOfEmbeddedChild(-1), mRoleMapEntry(nsnull)
    1: {
    1: #ifdef NS_DEBUG_X
    1:    {
    1:      nsCOMPtr<nsIPresShell> shell(do_QueryReferent(aShell));
  732:      printf(">>> %p Created Acc - DOM: %p  PS: %p", 
 3233:             (void*)static_cast<nsIAccessible*>(this), (void*)aNode,
  732:             (void*)shell.get());
  732:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
  732:     if (content) {
  732:       nsAutoString buf;
  732:       if (content->NodeInfo())
  732:         content->NodeInfo()->GetQualifiedName(buf);
  732:       printf(" Con: %s@%p", NS_ConvertUTF16toUTF8(buf).get(), (void *)content.get());
  732:       if (NS_SUCCEEDED(GetName(buf))) {
  732:         printf(" Name:[%s]", NS_ConvertUTF16toUTF8(buf).get());
    1:        }
    1:      }
    1:      printf("\n");
    1:    }
    1: #endif
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // destruction
    1: //-----------------------------------------------------
    1: nsAccessible::~nsAccessible()
    1: {
    1: }
    1: 
29320: void
29320: nsAccessible::SetRoleMapEntry(nsRoleMapEntry* aRoleMapEntry)
 7830: {
 7830:   mRoleMapEntry = aRoleMapEntry;
 7830: }
 7830: 
20246: NS_IMETHODIMP
20246: nsAccessible::GetName(nsAString& aName)
    1: {
    1:   aName.Truncate();
20246: 
20246:   if (IsDefunct())
20246:     return NS_ERROR_FAILURE;
20246: 
20246:   GetARIAName(aName);
20246:   if (!aName.IsEmpty())
    1:     return NS_OK;
20246: 
43504:   nsCOMPtr<nsIXBLAccessible> xblAccessible(do_QueryInterface(mContent));
28315:   if (xblAccessible) {
29559:     xblAccessible->GetAccessibleName(aName);
28315:     if (!aName.IsEmpty())
28315:       return NS_OK;
28315:   }
28315: 
22205:   nsresult rv = GetNameInternal(aName);
22205:   NS_ENSURE_SUCCESS(rv, rv);
22205: 
22205:   if (!aName.IsEmpty())
22205:     return NS_OK;
22205: 
22205:   // In the end get the name from tooltip.
22205:   nsIAtom *tooltipAttr = nsnull;
22205: 
43504:   if (mContent->IsHTML())
22205:     tooltipAttr = nsAccessibilityAtoms::title;
43504:   else if (mContent->IsXUL())
22205:     tooltipAttr = nsAccessibilityAtoms::tooltiptext;
22205:   else
22205:     return NS_OK;
22205: 
22205:   // XXX: if CompressWhiteSpace worked on nsAString we could avoid a copy.
22205:   nsAutoString name;
43504:   if (mContent->GetAttr(kNameSpaceID_None, tooltipAttr, name)) {
22205:     name.CompressWhitespace();
22205:     aName = name;
25591:     return NS_OK_NAME_FROM_TOOLTIP;
25591:   }
25591: 
25591:   if (rv != NS_OK_EMPTY_NAME)
22205:     aName.SetIsVoid(PR_TRUE);
22205: 
22205:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::GetDescription(nsAString& aDescription)
    1: {
27711:   if (IsDefunct())
27711:     return NS_ERROR_FAILURE;
27711: 
    1:   // There are 4 conditions that make an accessible have no accDescription:
    1:   // 1. it's a text node; or
    1:   // 2. It has no DHTML describedby property
    1:   // 3. it doesn't have an accName; or
    1:   // 4. its title attribute already equals to its accName nsAutoString name; 
43504: 
43504:   if (!mContent->IsNodeOfType(nsINode::eTEXT)) {
    1:     nsAutoString description;
25175:     nsresult rv = nsTextEquivUtils::
25175:       GetTextEquivFromIDRefs(this, nsAccessibilityAtoms::aria_describedby,
25175:                              description);
27711:     NS_ENSURE_SUCCESS(rv, rv);
27711: 
27711:     if (description.IsEmpty()) {
43504:       PRBool isXUL = mContent->IsXUL();
    1:       if (isXUL) {
    1:         // Try XUL <description control="[id]">description text</description>
57932:         XULDescriptionIterator iter(GetDocAccessible(), mContent);
57932:         nsAccessible* descr = nsnull;
57932:         while ((descr = iter.Next())) {
25175:           nsTextEquivUtils::
57932:             AppendTextEquivFromContent(this, descr->GetContent(), &description);
    1:         }
    1:       }
    1:       if (description.IsEmpty()) {
    1:         nsIAtom *descAtom = isXUL ? nsAccessibilityAtoms::tooltiptext :
    1:                                     nsAccessibilityAtoms::title;
43504:         if (mContent->GetAttr(kNameSpaceID_None, descAtom, description)) {
    1:           nsAutoString name;
    1:           GetName(name);
    1:           if (name.IsEmpty() || description == name) {
    1:             // Don't use tooltip for a description if this object
    1:             // has no name or the tooltip is the same as the name
    1:             description.Truncate();
    1:           }
    1:         }
    1:       }
    1:     }
    1:     description.CompressWhitespace();
    1:     aDescription = description;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // mask values for ui.key.chromeAccess and ui.key.contentAccess
    1: #define NS_MODIFIER_SHIFT    1
    1: #define NS_MODIFIER_CONTROL  2
    1: #define NS_MODIFIER_ALT      4
    1: #define NS_MODIFIER_META     8
    1: 
    1: // returns the accesskey modifier mask used in the given node's context
    1: // (i.e. chrome or content), or 0 if an error occurs
    1: static PRInt32
 5414: GetAccessModifierMask(nsIContent* aContent)
    1: {
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:   if (!prefBranch)
    1:     return 0;
    1: 
    1:   // use ui.key.generalAccessKey (unless it is -1)
    1:   PRInt32 accessKey;
    1:   nsresult rv = prefBranch->GetIntPref("ui.key.generalAccessKey", &accessKey);
    1:   if (NS_SUCCEEDED(rv) && accessKey != -1) {
    1:     switch (accessKey) {
    1:       case nsIDOMKeyEvent::DOM_VK_SHIFT:   return NS_MODIFIER_SHIFT;
    1:       case nsIDOMKeyEvent::DOM_VK_CONTROL: return NS_MODIFIER_CONTROL;
    1:       case nsIDOMKeyEvent::DOM_VK_ALT:     return NS_MODIFIER_ALT;
    1:       case nsIDOMKeyEvent::DOM_VK_META:    return NS_MODIFIER_META;
    1:       default:                             return 0;
    1:     }
    1:   }
    1: 
    1:   // get the docShell to this DOMNode, return 0 on failure
 5414:   nsCOMPtr<nsIDocument> document = aContent->GetCurrentDoc();
    1:   if (!document)
    1:     return 0;
    1:   nsCOMPtr<nsISupports> container = document->GetContainer();
    1:   if (!container)
    1:     return 0;
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
    1:   if (!treeItem)
    1:     return 0;
    1: 
    1:   // determine the access modifier used in this context
    1:   PRInt32 itemType, accessModifierMask = 0;
    1:   treeItem->GetItemType(&itemType);
    1:   switch (itemType) {
    1: 
    1:   case nsIDocShellTreeItem::typeChrome:
    1:     rv = prefBranch->GetIntPref("ui.key.chromeAccess", &accessModifierMask);
    1:     break;
    1: 
    1:   case nsIDocShellTreeItem::typeContent:
    1:     rv = prefBranch->GetIntPref("ui.key.contentAccess", &accessModifierMask);
    1:     break;
    1:   }
    1: 
    1:   return NS_SUCCEEDED(rv) ? accessModifierMask : 0;
    1: }
    1: 
 5414: NS_IMETHODIMP
 5414: nsAccessible::GetKeyboardShortcut(nsAString& aAccessKey)
    1: {
 5414:   aAccessKey.Truncate();
 5414: 
43504:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
 5414: 
43504:   PRUint32 key = nsCoreUtils::GetAccessKeyFor(mContent);
43504:   if (!key && mContent->IsElement()) {
57932:     nsAccessible* label = nsnull;
57932: 
57932:     // Copy access key from label node.
57932:     if (mContent->IsHTML()) {
57932:       // Unless it is labeled via an ancestor <label>, in which case that would
57932:       // be redundant.
57932:       HTMLLabelIterator iter(GetDocAccessible(), mContent,
57932:                              HTMLLabelIterator::eSkipAncestorLabel);
57932:       label = iter.Next();
57932: 
57932:     } else if (mContent->IsXUL()) {
57932:       XULLabelIterator iter(GetDocAccessible(), mContent);
57932:       label = iter.Next();
57932:     }
57932: 
57932:     if (label)
57932:       key = nsCoreUtils::GetAccessKeyFor(label->GetContent());
 5414:   }
 5414: 
 5414:   if (!key)
 5414:     return NS_OK;
 5414: 
 5414:   nsAutoString accesskey(key);
 5414: 
 5414:   // Append the modifiers in reverse order, result: Control+Alt+Shift+Meta+<key>
    1:   nsAutoString propertyKey;
43504:   PRInt32 modifierMask = GetAccessModifierMask(mContent);
    1:   if (modifierMask & NS_MODIFIER_META) {
    1:     propertyKey.AssignLiteral("VK_META");
    1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
    1:   }
    1:   if (modifierMask & NS_MODIFIER_SHIFT) {
    1:     propertyKey.AssignLiteral("VK_SHIFT");
    1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
    1:   }
    1:   if (modifierMask & NS_MODIFIER_ALT) {
    1:     propertyKey.AssignLiteral("VK_ALT");
    1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
    1:   }
    1:   if (modifierMask & NS_MODIFIER_CONTROL) {
    1:     propertyKey.AssignLiteral("VK_CONTROL");
    1:     nsAccessible::GetFullKeyName(propertyKey, accesskey, accesskey);
    1:   }
 5414: 
 5414:   aAccessKey = accesskey;
    1:   return NS_OK;
    1: }
    1: 
29320: NS_IMETHODIMP
29320: nsAccessible::GetParent(nsIAccessible **aParent)
29320: {
35523:   NS_ENSURE_ARG_POINTER(aParent);
35523: 
35523:   NS_IF_ADDREF(*aParent = GetParent());
35523:   return *aParent ? NS_OK : NS_ERROR_FAILURE;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible nextSibling; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetNextSibling(nsIAccessible **aNextSibling) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aNextSibling);
35523: 
35523:   nsresult rv = NS_OK;
35523:   NS_IF_ADDREF(*aNextSibling = GetSiblingAtOffset(1, &rv));
35523:   return rv;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible previousSibling; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetPreviousSibling(nsIAccessible * *aPreviousSibling) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aPreviousSibling);
35523: 
35523:   nsresult rv = NS_OK;
35523:   NS_IF_ADDREF(*aPreviousSibling = GetSiblingAtOffset(-1, &rv));
35523:   return rv;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible firstChild; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetFirstChild(nsIAccessible **aFirstChild) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aFirstChild);
35523:   *aFirstChild = nsnull;
35523: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   if (childCount > 0)
35523:     NS_ADDREF(*aFirstChild = GetChildAt(0));
35523: 
35136:   return NS_OK;
35136: }
35136: 
35523:   /* readonly attribute nsIAccessible lastChild; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetLastChild(nsIAccessible **aLastChild)
35136: {
35523:   NS_ENSURE_ARG_POINTER(aLastChild);
35523:   *aLastChild = nsnull;
35523: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   NS_IF_ADDREF(*aLastChild = GetChildAt(childCount - 1));
35523:   return NS_OK;
35523: }
35523: 
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildAt(PRInt32 aChildIndex, nsIAccessible **aChild)
35136: {
35523:   NS_ENSURE_ARG_POINTER(aChild);
35523:   *aChild = nsnull;
35523: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   // If child index is negative, then return last child.
35523:   // XXX: do we really need this?
35523:   if (aChildIndex < 0)
35523:     aChildIndex = childCount - 1;
35523: 
36989:   nsAccessible* child = GetChildAt(aChildIndex);
35523:   if (!child)
35523:     return NS_ERROR_INVALID_ARG;
35523: 
35523:   NS_ADDREF(*aChild = child);
35523:   return NS_OK;
35523: }
35523: 
35523: // readonly attribute nsIArray children;
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildren(nsIArray **aOutChildren)
35133: {
35523:   NS_ENSURE_ARG_POINTER(aOutChildren);
10871:   *aOutChildren = nsnull;
35523: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   nsresult rv = NS_OK;
35523:   nsCOMPtr<nsIMutableArray> children =
35523:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
35523:   NS_ENSURE_SUCCESS(rv, rv);
35523: 
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
35523:     nsIAccessible* child = GetChildAt(childIdx);
35523:     children->AppendElement(child, PR_FALSE);
    1:   }
    1: 
    1:   NS_ADDREF(*aOutChildren = children);
    1:   return NS_OK;
    1: }
    1: 
29320: PRBool
29320: nsAccessible::GetAllowsAnonChildAccessibles()
    1: {
29320:   return PR_TRUE;
    1: }
    1: 
    1: /* readonly attribute long childCount; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildCount(PRInt32 *aChildCount) 
    1: {
35523:   NS_ENSURE_ARG_POINTER(aChildCount);
35523: 
35523:   *aChildCount = GetChildCount();
35523:   return *aChildCount != -1 ? NS_OK : NS_ERROR_FAILURE;  
    1: }
    1: 
    1: /* readonly attribute long indexInParent; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetIndexInParent(PRInt32 *aIndexInParent)
    1: {
35523:   NS_ENSURE_ARG_POINTER(aIndexInParent);
35523: 
35523:   *aIndexInParent = GetIndexInParent();
35523:   return *aIndexInParent != -1 ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult nsAccessible::GetTranslatedString(const nsAString& aKey, nsAString& aStringOut)
    1: {
    1:   nsXPIDLString xsValue;
    1: 
    1:   if (!gStringBundle || 
    1:     NS_FAILED(gStringBundle->GetStringFromName(PromiseFlatString(aKey).get(), getter_Copies(xsValue)))) 
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   aStringOut.Assign(xsValue);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsAccessible::GetFullKeyName(const nsAString& aModifierName, const nsAString& aKeyName, nsAString& aStringOut)
    1: {
    1:   nsXPIDLString modifierName, separator;
    1: 
    1:   if (!gKeyStringBundle ||
    1:       NS_FAILED(gKeyStringBundle->GetStringFromName(PromiseFlatString(aModifierName).get(), 
    1:                                                     getter_Copies(modifierName))) ||
    1:       NS_FAILED(gKeyStringBundle->GetStringFromName(PromiseFlatString(NS_LITERAL_STRING("MODIFIER_SEPARATOR")).get(), 
    1:                                                     getter_Copies(separator)))) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   aStringOut = modifierName + separator + aKeyName; 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool nsAccessible::IsVisible(PRBool *aIsOffscreen) 
    1: {
    1:   // We need to know if at least a kMinPixels around the object is visible
    1:   // Otherwise it will be marked nsIAccessibleStates::STATE_OFFSCREEN
    1:   // The STATE_INVISIBLE flag is for elements which are programmatically hidden
    1:   
  733:   *aIsOffscreen = PR_TRUE;
43504:   if (IsDefunct())
43504:     return PR_FALSE;
    1: 
    1:   const PRUint16 kMinPixels  = 12;
    1:    // Set up the variables we need, return false if we can't get at them all
    1:   nsCOMPtr<nsIPresShell> shell(GetPresShell());
    1:   if (!shell) 
    1:     return PR_FALSE;
    1: 
    1:   nsIFrame *frame = GetFrame();
    1:   if (!frame) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // If visibility:hidden or visibility:collapsed then mark with STATE_INVISIBLE
    1:   if (!frame->GetStyleVisibility()->IsVisible())
    1:   {
    1:       return PR_FALSE;
    1:   }
    1: 
    1:   // We don't use the more accurate GetBoundsRect, because that is more expensive
    1:   // and the STATE_OFFSCREEN flag that this is used for only needs to be a rough
    1:   // indicator
37073:   nsSize frameSize = frame->GetSize();
37073:   nsRectVisibility rectVisibility =
37073:     shell->GetRectVisibility(frame, nsRect(nsPoint(0,0), frameSize),
37073:                              nsPresContext::CSSPixelsToAppUnits(kMinPixels));
37073: 
37073:   if (frame->GetRect().IsEmpty()) {
37073:     PRBool isEmpty = PR_TRUE;
37073: 
 9480:     nsIAtom *frameType = frame->GetType();
 9480:     if (frameType == nsAccessibilityAtoms::textFrame) {
    1:       // Zero area rects can occur in the first frame of a multi-frame text flow,
 9480:       // in which case the rendered text is not empty and the frame should not be marked invisible
 9480:       nsAutoString renderedText;
 9480:       frame->GetRenderedText (&renderedText, nsnull, nsnull, 0, 1);
37073:       isEmpty = renderedText.IsEmpty();
 9480:     }
 9480:     else if (frameType == nsAccessibilityAtoms::inlineFrame) {
    1:       // Yuck. Unfortunately inline frames can contain larger frames inside of them,
    1:       // so we can't really believe this is a zero area rect without checking more deeply.
    1:       // GetBounds() will do that for us.
    1:       PRInt32 x, y, width, height;
    1:       GetBounds(&x, &y, &width, &height);
37073:       isEmpty = width == 0 || height == 0;
37073:     }
37073: 
37073:     if (isEmpty && !(frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
37073:       // Consider zero area objects hidden unless they are absolutely positioned
 7763:       // or floating and may have descendants that have a non-zero size
 7763:       return PR_FALSE;
  733:     }
37073:   }
37073: 
37073:   // The frame intersects the viewport, but we need to check the parent view chain :(
43504:   nsIDocument* doc = mContent->GetOwnerDoc();
  733:   if (!doc)  {
  673:     return PR_FALSE;
    1:   }
    1: 
37074:   nsIFrame* frameWithView =
37074:     frame->HasView() ? frame : frame->GetAncestorWithViewExternal();
37074:   nsIView* view = frameWithView->GetViewExternal();
37074:   PRBool isVisible = CheckVisibilityInParentChain(doc, view);
  733:   if (isVisible && rectVisibility == nsRectVisibility_kVisible) {
  733:     *aIsOffscreen = PR_FALSE;
  733:   }
  733:   return isVisible;
  733: }
  733: 
 5424: nsresult
21256: nsAccessible::GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
    1:   *aState = 0;
    1: 
21984:   if (IsDefunct()) {
21984:     if (aExtraState)
 8052:       *aExtraState = nsIAccessibleStates::EXT_STATE_DEFUNCT;
21984: 
21984:     return NS_OK_DEFUNCT_OBJECT;
 8052:   }
 8052: 
  262:   if (aExtraState)
  262:     *aExtraState = 0;
  262: 
56168:   nsEventStates intrinsicState = mContent->IntrinsicState();
56168: 
56168:   if (intrinsicState.HasState(NS_EVENT_STATE_INVALID))
55426:     *aState |= nsIAccessibleStates::STATE_INVALID;
55426: 
56168:   if (intrinsicState.HasState(NS_EVENT_STATE_REQUIRED))
55425:     *aState |= nsIAccessibleStates::STATE_REQUIRED;
55425: 
55425:   PRBool disabled = mContent->IsHTML() ? 
56168:     (intrinsicState.HasState(NS_EVENT_STATE_DISABLED)) :
55425:     (mContent->AttrValueIs(kNameSpaceID_None,
    1:                            nsAccessibilityAtoms::disabled,
    1:                            nsAccessibilityAtoms::_true,
55425:                            eCaseMatters));
55425: 
55425:   // Set unavailable state based on disabled state, otherwise set focus states
55425:   if (disabled) {
    1:     *aState |= nsIAccessibleStates::STATE_UNAVAILABLE;
    1:   }
43504:   else if (mContent->IsElement()) {
    1:     nsIFrame *frame = GetFrame();
    1:     if (frame && frame->IsFocusable()) {
    1:       *aState |= nsIAccessibleStates::STATE_FOCUSABLE;
    1:     }
    1: 
43504:     if (gLastFocusedNode == mContent) {
    1:       *aState |= nsIAccessibleStates::STATE_FOCUSED;
    1:     }
    1:   }
    1: 
    1:   // Check if nsIAccessibleStates::STATE_INVISIBLE and
    1:   // STATE_OFFSCREEN flags should be turned on for this object.
    1:   PRBool isOffscreen;
    1:   if (!IsVisible(&isOffscreen)) {
    1:     *aState |= nsIAccessibleStates::STATE_INVISIBLE;
    1:   }
    1:   if (isOffscreen) {
    1:     *aState |= nsIAccessibleStates::STATE_OFFSCREEN;
    1:   }
    1: 
 5707:   nsIFrame *frame = GetFrame();
 5707:   if (frame && (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW))
 5707:     *aState |= nsIAccessibleStates::STATE_FLOATING;
 5707: 
31782:   // Check if a XUL element has the popup attribute (an attached popup menu).
43504:   if (mContent->IsXUL())
43504:     if (mContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::popup))
31782:       *aState |= nsIAccessibleStates::STATE_HASPOPUP;
31782: 
13757:   // Add 'linked' state for simple xlink.
43504:   if (nsCoreUtils::IsXLink(mContent))
13757:     *aState |= nsIAccessibleStates::STATE_LINKED;
13757: 
    1:   return NS_OK;
    1: }
    1: 
    1:   /* readonly attribute boolean focusedChild; */
43504: NS_IMETHODIMP
43504: nsAccessible::GetFocusedChild(nsIAccessible **aFocusedChild) 
    1: { 
43504:   nsAccessible *focusedChild = nsnull;
43504:   if (gLastFocusedNode == mContent) {
    1:     focusedChild = this;
    1:   }
    1:   else if (gLastFocusedNode) {
43504:     focusedChild = GetAccService()->GetAccessible(gLastFocusedNode);
43504:     if (focusedChild && focusedChild->GetParent() != this)
    1:       focusedChild = nsnull;
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aFocusedChild = focusedChild);
    1:   return NS_OK;
    1: }
    1: 
28197: // nsAccessible::GetChildAtPoint()
28197: nsresult
28197: nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY, PRBool aDeepestChild,
28197:                               nsIAccessible **aChild)
    1: {
 6068:   // If we can't find the point in a child, we will return the fallback answer:
28197:   // we return |this| if the point is within it, otherwise nsnull.
28197:   PRInt32 x = 0, y = 0, width = 0, height = 0;
28197:   nsresult rv = GetBounds(&x, &y, &width, &height);
28197:   NS_ENSURE_SUCCESS(rv, rv);
28197: 
 6068:   nsCOMPtr<nsIAccessible> fallbackAnswer;
28197:   if (aX >= x && aX < x + width && aY >= y && aY < y + height)
 6068:     fallbackAnswer = this;
28197: 
20566:   if (nsAccUtils::MustPrune(this)) {  // Do not dig any further
28197:     NS_IF_ADDREF(*aChild = fallbackAnswer);
 6068:     return NS_OK;
 6068:   }
 6068: 
 5680:   // Search an accessible at the given point starting from accessible document
 5680:   // because containing block (see CSS2) for out of flow element (for example,
 5680:   // absolutely positioned element) may be different from its DOM parent and
 5680:   // therefore accessible for containing block may be different from accessible
 5680:   // for DOM parent but GetFrameForPoint() should be called for containing block
 5680:   // to get an out of flow element.
39601:   nsDocAccessible *accDocument = GetDocAccessible();
 6068:   NS_ENSURE_TRUE(accDocument, NS_ERROR_FAILURE);
 5680: 
39601:   nsIFrame *frame = accDocument->GetFrame();
 5680:   NS_ENSURE_STATE(frame);
 5680: 
 5680:   nsPresContext *presContext = frame->PresContext();
 5680: 
 5680:   nsIntRect screenRect = frame->GetScreenRectExternal();
 5680:   nsPoint offset(presContext->DevPixelsToAppUnits(aX - screenRect.x),
 5680:                  presContext->DevPixelsToAppUnits(aY - screenRect.y));
 5680: 
 5680:   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
 5680:   nsIFrame *foundFrame = presShell->GetFrameForPoint(frame, offset);
28197: 
28197:   nsIContent* content = nsnull;
 6068:   if (!foundFrame || !(content = foundFrame->GetContent())) {
28197:     NS_IF_ADDREF(*aChild = fallbackAnswer);
    1:     return NS_OK;
 6068:   }
 5680: 
46469:   // Get accessible for the node with the point or the first accessible in
46469:   // the DOM parent chain.
46469:   nsAccessible* accessible =
46469:    GetAccService()->GetAccessibleOrContainer(content, mWeakShell);
 6068:   if (!accessible) {
28197:     NS_IF_ADDREF(*aChild = fallbackAnswer);
 5680:     return NS_OK;
 6068:   }
 6068: 
 6068:   if (accessible == this) {
28197:     // Manually walk through accessible children and see if the are within this
28197:     // point. Skip offscreen or invisible accessibles. This takes care of cases
28197:     // where layout won't walk into things for us, such as image map areas and
28197:     // sub documents (XXX: subdocuments should be handled by methods of
28197:     // nsOuterDocAccessibles).
40990:     PRInt32 childCount = GetChildCount();
40990:     for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
40990:       nsAccessible *child = GetChildAt(childIdx);
40990: 
 6068:       PRInt32 childX, childY, childWidth, childHeight;
 6068:       child->GetBounds(&childX, &childY, &childWidth, &childHeight);
 6068:       if (aX >= childX && aX < childX + childWidth &&
 6068:           aY >= childY && aY < childY + childHeight &&
20566:           (nsAccUtils::State(child) & nsIAccessibleStates::STATE_INVISIBLE) == 0) {
28197: 
28197:         if (aDeepestChild)
28197:           return child->GetDeepestChildAtPoint(aX, aY, aChild);
28197: 
28197:         NS_IF_ADDREF(*aChild = child);
 6068:         return NS_OK;
 6068:       }
 6068:     }
28197: 
28197:     // The point is in this accessible but not in a child. We are allowed to
28197:     // return |this| as the answer.
28197:     NS_IF_ADDREF(*aChild = accessible);
28197:     return NS_OK;
28197:   }
28197: 
28197:   // Since DOM node of obtained accessible may be out of flow then we should
28197:   // ensure obtained accessible is a child of this accessible.
28197:   nsCOMPtr<nsIAccessible> parent, child(accessible);
28197:   while (PR_TRUE) {
28197:     child->GetParent(getter_AddRefs(parent));
28197:     if (!parent) {
28197:       // Reached the top of the hierarchy. These bounds were inside an
28197:       // accessible that is not a descendant of this one.
28197:       NS_IF_ADDREF(*aChild = fallbackAnswer);      
28197:       return NS_OK;
28197:     }
28197: 
28197:     if (parent == this) {
28197:       NS_ADDREF(*aChild = (aDeepestChild ? accessible : child));
28197:       return NS_OK;
28197:     }
28197:     child.swap(parent);
28197:   }
28197: 
19323:   return NS_OK;
19323: }
19323: 
19323: // nsIAccessible getChildAtPoint(in long x, in long y)
19323: NS_IMETHODIMP
19323: nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,
19323:                               nsIAccessible **aAccessible)
19323: {
28197:   NS_ENSURE_ARG_POINTER(aAccessible);
28197:   *aAccessible = nsnull;
28197: 
28197:   if (IsDefunct())
28197:     return NS_ERROR_FAILURE;
28197: 
28197:   return GetChildAtPoint(aX, aY, PR_FALSE, aAccessible);
28197: }
28197: 
28197: // nsIAccessible getDeepestChildAtPoint(in long x, in long y)
28197: NS_IMETHODIMP
28197: nsAccessible::GetDeepestChildAtPoint(PRInt32 aX, PRInt32 aY,
28197:                                      nsIAccessible **aAccessible)
28197: {
28197:   NS_ENSURE_ARG_POINTER(aAccessible);
28197:   *aAccessible = nsnull;
28197: 
28197:   if (IsDefunct())
28197:     return NS_ERROR_FAILURE;
28197: 
28197:   return GetChildAtPoint(aX, aY, PR_TRUE, aAccessible);
    1: }
    1: 
    1: void nsAccessible::GetBoundsRect(nsRect& aTotalBounds, nsIFrame** aBoundingFrame)
    1: {
    1: /*
    1:  * This method is used to determine the bounds of a content node.
    1:  * Because HTML wraps and links are not always rectangular, this
    1:  * method uses the following algorithm:
    1:  *
    1:  * 1) Start with an empty rectangle
    1:  * 2) Add the rect for the primary frame from for the DOM node.
    1:  * 3) For each next frame at the same depth with the same DOM node, add that rect to total
    1:  * 4) If that frame is an inline frame, search deeper at that point in the tree, adding all rects
    1:  */
    1: 
    1:   // Initialization area
    1:   *aBoundingFrame = nsnull;
    1:   nsIFrame *firstFrame = GetBoundsFrame();
    1:   if (!firstFrame)
    1:     return;
    1: 
    1:   // Find common relative parent
    1:   // This is an ancestor frame that will incompass all frames for this content node.
    1:   // We need the relative parent so we can get absolute screen coordinates
    1:   nsIFrame *ancestorFrame = firstFrame;
    1: 
    1:   while (ancestorFrame) {  
    1:     *aBoundingFrame = ancestorFrame;
    1:     // If any other frame type, we only need to deal with the primary frame
    1:     // Otherwise, there may be more frames attached to the same content node
20566:     if (!nsCoreUtils::IsCorrectFrameType(ancestorFrame,
20566:                                          nsAccessibilityAtoms::inlineFrame) &&
20566:         !nsCoreUtils::IsCorrectFrameType(ancestorFrame,
20566:                                          nsAccessibilityAtoms::textFrame))
    1:       break;
    1:     ancestorFrame = ancestorFrame->GetParent();
    1:   }
    1: 
    1:   nsIFrame *iterFrame = firstFrame;
43504:   nsCOMPtr<nsIContent> firstContent(mContent);
    1:   nsIContent* iterContent = firstContent;
    1:   PRInt32 depth = 0;
    1: 
    1:   // Look only at frames below this depth, or at this depth (if we're still on the content node we started with)
    1:   while (iterContent == firstContent || depth > 0) {
    1:     // Coordinates will come back relative to parent frame
    1:     nsRect currFrameBounds = iterFrame->GetRect();
    1:     
    1:     // Make this frame's bounds relative to common parent frame
    1:     currFrameBounds +=
    1:       iterFrame->GetParent()->GetOffsetToExternal(*aBoundingFrame);
    1: 
    1:     // Add this frame's bounds to total
    1:     aTotalBounds.UnionRect(aTotalBounds, currFrameBounds);
    1: 
    1:     nsIFrame *iterNextFrame = nsnull;
    1: 
20566:     if (nsCoreUtils::IsCorrectFrameType(iterFrame,
20566:                                         nsAccessibilityAtoms::inlineFrame)) {
    1:       // Only do deeper bounds search if we're on an inline frame
    1:       // Inline frames can contain larger frames inside of them
    1:       iterNextFrame = iterFrame->GetFirstChild(nsnull);
    1:     }
    1: 
    1:     if (iterNextFrame) 
    1:       ++depth;  // Child was found in code above this: We are going deeper in this iteration of the loop
    1:     else {  
    1:       // Use next sibling if it exists, or go back up the tree to get the first next-in-flow or next-sibling 
    1:       // within our search
    1:       while (iterFrame) {
    1:         iterNextFrame = iterFrame->GetNextContinuation();
    1:         if (!iterNextFrame)
    1:           iterNextFrame = iterFrame->GetNextSibling();
    1:         if (iterNextFrame || --depth < 0) 
    1:           break;
    1:         iterFrame = iterFrame->GetParent();
    1:       }
    1:     }
    1: 
    1:     // Get ready for the next round of our loop
    1:     iterFrame = iterNextFrame;
    1:     if (iterFrame == nsnull)
    1:       break;
    1:     iterContent = nsnull;
    1:     if (depth == 0)
    1:       iterContent = iterFrame->GetContent();
    1:   }
    1: }
    1: 
    1: 
    1: /* void getBounds (out long x, out long y, out long width, out long height); */
55772: NS_IMETHODIMP
55772: nsAccessible::GetBounds(PRInt32* aX, PRInt32* aY,
55772:                         PRInt32* aWidth, PRInt32* aHeight)
    1: {
55772:   NS_ENSURE_ARG_POINTER(aX);
55772:   *aX = 0;
55772:   NS_ENSURE_ARG_POINTER(aY);
55772:   *aY = 0;
55772:   NS_ENSURE_ARG_POINTER(aWidth);
55772:   *aWidth = 0;
55772:   NS_ENSURE_ARG_POINTER(aHeight);
55772:   *aHeight = 0;
55772: 
55772:   if (IsDefunct())
55772:     return NS_ERROR_FAILURE;
55772: 
55772:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
55772: 
55772:   // This routine will get the entire rectangle for all the frames in this node.
    1:   // -------------------------------------------------------------------------
    1:   //      Primary Frame for node
    1:   //  Another frame, same node                <- Example
    1:   //  Another frame, same node
    1: 
    1:   nsRect unionRectTwips;
55772:   nsIFrame* boundingFrame = nsnull;
55772:   GetBoundsRect(unionRectTwips, &boundingFrame);   // Unions up all primary frames for this node and all siblings after it
55772:   NS_ENSURE_STATE(boundingFrame);
55772: 
55772:   nsPresContext* presContext = presShell->GetPresContext();
55772:   *aX = presContext->AppUnitsToDevPixels(unionRectTwips.x);
55772:   *aY = presContext->AppUnitsToDevPixels(unionRectTwips.y);
55772:   *aWidth = presContext->AppUnitsToDevPixels(unionRectTwips.width);
55772:   *aHeight = presContext->AppUnitsToDevPixels(unionRectTwips.height);
    1: 
    1:   // We have the union of the rectangle, now we need to put it in absolute screen coords
55772:   nsIntRect orgRectPixels = boundingFrame->GetScreenRectExternal();
55772:   *aX += orgRectPixels.x;
55772:   *aY += orgRectPixels.y;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // helpers
    1: 
    1: nsIFrame* nsAccessible::GetBoundsFrame()
    1: {
    1:   return GetFrame();
    1: }
    1: 
    1: /* void removeSelection (); */
    1: NS_IMETHODIMP nsAccessible::SetSelected(PRBool aSelect)
    1: {
    1:   // Add or remove selection
43504:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
    1: 
20566:   PRUint32 state = nsAccUtils::State(this);
    1:   if (state & nsIAccessibleStates::STATE_SELECTABLE) {
20566:     nsCOMPtr<nsIAccessible> multiSelect =
43504:       nsAccUtils::GetMultiSelectableContainer(mContent);
    1:     if (!multiSelect) {
    1:       return aSelect ? TakeFocus() : NS_ERROR_FAILURE;
    1:     }
    1: 
 6279:     if (mRoleMapEntry) {
    1:       if (aSelect) {
43504:         return mContent->SetAttr(kNameSpaceID_None,
43504:                                  nsAccessibilityAtoms::aria_selected,
 6279:                                  NS_LITERAL_STRING("true"), PR_TRUE);
 6279:       }
43504:       return mContent->UnsetAttr(kNameSpaceID_None,
43504:                                  nsAccessibilityAtoms::aria_selected, PR_TRUE);
43504:     }
43504:   }
43504: 
43504:   return NS_OK;
    1: }
    1: 
    1: /* void takeSelection (); */
    1: NS_IMETHODIMP nsAccessible::TakeSelection()
    1: {
    1:   // Select only this item
43504:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
    1: 
20566:   PRUint32 state = nsAccUtils::State(this);
    1:   if (state & nsIAccessibleStates::STATE_SELECTABLE) {
20566:     nsCOMPtr<nsIAccessible> multiSelect =
43504:       nsAccUtils::GetMultiSelectableContainer(mContent);
    1:     if (multiSelect) {
    1:       nsCOMPtr<nsIAccessibleSelectable> selectable = do_QueryInterface(multiSelect);
    1:       selectable->ClearSelection();
    1:     }
    1:     return SetSelected(PR_TRUE);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* void takeFocus (); */
14605: NS_IMETHODIMP
14605: nsAccessible::TakeFocus()
    1: {
14605:   if (IsDefunct())
14605:     return NS_ERROR_FAILURE;
14605: 
14605:   nsIFrame *frame = GetFrame();
14605:   NS_ENSURE_STATE(frame);
14605: 
43504:   nsIContent* focusContent = mContent;
43504: 
14605:   // If the current element can't take real DOM focus and if it has an ID and
50641:   // an ancestor with an aria-activedescendant attribute present, then set DOM
14605:   // focus to that ancestor and set aria-activedescendant on the ancestor to
14605:   // the ID of the desired element.
14605:   if (!frame->IsFocusable()) {
14605:     nsAutoString id;
43504:     if (nsCoreUtils::GetID(mContent, id)) {
43504: 
43504:       nsIContent* ancestorContent = mContent;
14605:       while ((ancestorContent = ancestorContent->GetParent()) &&
14605:              !ancestorContent->HasAttr(kNameSpaceID_None,
14605:                                        nsAccessibilityAtoms::aria_activedescendant));
14605: 
14605:       if (ancestorContent) {
14605:         nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
14605:         if (presShell) {
36654:           nsIFrame *frame = ancestorContent->GetPrimaryFrame();
14605:           if (frame && frame->IsFocusable()) {
43504:             focusContent = ancestorContent;
43504:             focusContent->SetAttr(kNameSpaceID_None,
14605:                                   nsAccessibilityAtoms::aria_activedescendant,
14605:                                   id, PR_TRUE);
14605:           }
14605:         }
14605:       }
14605:     }
14605:   }
14605: 
43504:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(focusContent));
29018:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:   if (fm)
29018:     fm->SetFocus(element, 0);
29018: 
    1:   return NS_OK;
    1: }
    1: 
22204: nsresult
22204: nsAccessible::GetHTMLName(nsAString& aLabel)
    1: {
20246:   nsAutoString label;
57932: 
57932:   nsAccessible* labelAcc = nsnull;
57932:   HTMLLabelIterator iter(GetDocAccessible(), mContent);
57932:   while ((labelAcc = iter.Next())) {
57932:     nsresult rv = nsTextEquivUtils::
57932:       AppendTextEquivFromContent(this, labelAcc->GetContent(), &label);
20362:     NS_ENSURE_SUCCESS(rv, rv);
20362: 
    1:     label.CompressWhitespace();
57932:   }
57932: 
57932:   if (label.IsEmpty())
57932:     return nsTextEquivUtils::GetNameFromSubtree(this, aLabel);
57932: 
    1:   aLabel = label;
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * 3 main cases for XUL Controls to be labeled
    1:   *   1 - control contains label="foo"
    1:   *   2 - control has, as a child, a label element
    1:   *        - label has either value="foo" or children
    1:   *   3 - non-child label contains control="controlID"
    1:   *        - label has either value="foo" or children
    1:   * Once a label is found, the search is discontinued, so a control
    1:   *  that has a label child as well as having a label external to
    1:   *  the control that uses the control="controlID" syntax will use
    1:   *  the child label for its Name.
    1:   */
22204: nsresult
22204: nsAccessible::GetXULName(nsAString& aLabel)
    1: {
20246:   // CASE #1 (via label attribute) -- great majority of the cases
20246:   nsresult rv = NS_OK;
20246: 
    1:   nsAutoString label;
43504:   nsCOMPtr<nsIDOMXULLabeledControlElement> labeledEl(do_QueryInterface(mContent));
    1:   if (labeledEl) {
    1:     rv = labeledEl->GetLabel(label);
    1:   }
    1:   else {
43504:     nsCOMPtr<nsIDOMXULSelectControlItemElement> itemEl(do_QueryInterface(mContent));
    1:     if (itemEl) {
    1:       rv = itemEl->GetLabel(label);
    1:     }
    1:     else {
43504:       nsCOMPtr<nsIDOMXULSelectControlElement> select(do_QueryInterface(mContent));
    1:       // Use label if this is not a select control element which 
    1:       // uses label attribute to indicate which option is selected
    1:       if (!select) {
43504:         nsCOMPtr<nsIDOMXULElement> xulEl(do_QueryInterface(mContent));
    1:         if (xulEl) {
    1:           rv = xulEl->GetAttribute(NS_LITERAL_STRING("label"), label);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // CASES #2 and #3 ------ label as a child or <label control="id" ... > </label>
    1:   if (NS_FAILED(rv) || label.IsEmpty()) {
    1:     label.Truncate();
57932: 
57932:     nsAccessible* labelAcc = nsnull;
57932:     XULLabelIterator iter(GetDocAccessible(), mContent);
57932:     while ((labelAcc = iter.Next())) {
57932:       nsCOMPtr<nsIDOMXULLabelElement> xulLabel =
57932:         do_QueryInterface(labelAcc->GetContent());
    1:       // Check if label's value attribute is used
    1:       if (xulLabel && NS_SUCCEEDED(xulLabel->GetValue(label)) && label.IsEmpty()) {
    1:         // If no value attribute, a non-empty label must contain
20072:         // children that define its text -- possibly using HTML
57932:         nsTextEquivUtils::
57932:           AppendTextEquivFromContent(this, labelAcc->GetContent(), &label);
57932:       }
    1:     }
    1:   }
    1: 
    1:   // XXX If CompressWhiteSpace worked on nsAString we could avoid a copy
    1:   label.CompressWhitespace();
    1:   if (!label.IsEmpty()) {
    1:     aLabel = label;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Can get text from title of <toolbaritem> if we're a child of a <toolbaritem>
43504:   nsIContent *bindingParent = mContent->GetBindingParent();
    1:   nsIContent *parent = bindingParent? bindingParent->GetParent() :
43504:                                       mContent->GetParent();
    1:   while (parent) {
    1:     if (parent->Tag() == nsAccessibilityAtoms::toolbaritem &&
    1:         parent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::title, label)) {
    1:       label.CompressWhitespace();
    1:       aLabel = label;
    1:       return NS_OK;
    1:     }
    1:     parent = parent->GetParent();
    1:   }
    1: 
25175:   return nsTextEquivUtils::GetNameFromSubtree(this, aLabel);
    1: }
    1: 
29320: nsresult
51377: nsAccessible::HandleAccEvent(AccEvent* aEvent)
  511: {
  763:   NS_ENSURE_ARG_POINTER(aEvent);
  763: 
  511:   nsCOMPtr<nsIObserverService> obsService =
41540:     mozilla::services::GetObserverService();
  511:   NS_ENSURE_TRUE(obsService, NS_ERROR_FAILURE);
  511: 
51377:   nsCOMPtr<nsISimpleEnumerator> observers;
51377:   obsService->EnumerateObservers(NS_ACCESSIBLE_EVENT_TOPIC,
51377:                                  getter_AddRefs(observers));
51377: 
51377:   NS_ENSURE_STATE(observers);
51377: 
51377:   PRBool hasObservers = PR_FALSE;
51377:   observers->HasMoreElements(&hasObservers);
51377:   if (hasObservers) {
51377:     nsRefPtr<nsAccEvent> evnt(aEvent->CreateXPCOMObject());
51377:     return obsService->NotifyObservers(evnt, NS_ACCESSIBLE_EVENT_TOPIC, nsnull);
51377:   }
51377: 
51377:   return NS_OK;
    1: }
    1: 
25822: NS_IMETHODIMP
25822: nsAccessible::GetRole(PRUint32 *aRole)
    1: {
 4850:   NS_ENSURE_ARG_POINTER(aRole);
 4850:   *aRole = nsIAccessibleRole::ROLE_NOTHING;
 4850: 
29085:   if (IsDefunct())
29085:     return NS_ERROR_FAILURE;
29085: 
52053:   *aRole = Role();
52027:   return NS_OK;
    1: }
    1: 
  401: NS_IMETHODIMP
  401: nsAccessible::GetAttributes(nsIPersistentProperties **aAttributes)
    1: {
13094:   NS_ENSURE_ARG_POINTER(aAttributes);  // In/out param. Created if necessary.
 8937:   
15511:   if (IsDefunct())
15511:     return NS_ERROR_FAILURE;
15511: 
13094:   nsCOMPtr<nsIPersistentProperties> attributes = *aAttributes;
13094:   if (!attributes) {
13094:     // Create only if an array wasn't already passed in
13094:     attributes = do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
    1:     NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
13094:     NS_ADDREF(*aAttributes = attributes);
13094:   }
 4516:  
  401:   nsresult rv = GetAttributesInternal(attributes);
  401:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString id;
 6844:   nsAutoString oldValueUnused;
43504:   if (nsCoreUtils::GetID(mContent, id)) {
13094:     // Expose ID. If an <iframe id> exists override the one on the <body> of the source doc,
13094:     // because the specific instance is what makes the ID useful for scripts
    1:     attributes->SetStringProperty(NS_LITERAL_CSTRING("id"), id, oldValueUnused);
 6844:   }
 6844:   
 8937:   nsAutoString xmlRoles;
43504:   if (mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, xmlRoles)) {
 8937:     attributes->SetStringProperty(NS_LITERAL_CSTRING("xml-roles"),  xmlRoles, oldValueUnused);          
    1:   }
    1: 
11394:   nsCOMPtr<nsIAccessibleValue> supportsValue = do_QueryInterface(static_cast<nsIAccessible*>(this));
11394:   if (supportsValue) {
11394:     // We support values, so expose the string value as well, via the valuetext object attribute
11394:     // We test for the value interface because we don't want to expose traditional get_accValue()
11394:     // information such as URL's on links and documents, or text in an input
11394:     nsAutoString valuetext;
11394:     GetValue(valuetext);
11394:     attributes->SetStringProperty(NS_LITERAL_CSTRING("valuetext"), valuetext, oldValueUnused);
11394:   }
11394: 
25348:   // Expose checkable object attribute if the accessible has checkable state
25348:   if (nsAccUtils::State(this) & nsIAccessibleStates::STATE_CHECKABLE)
25348:     nsAccUtils::SetAccAttr(attributes, nsAccessibilityAtoms::checkable, NS_LITERAL_STRING("true"));
13012: 
23326:   // Group attributes (level/setsize/posinset)
36879:   PRInt32 level = 0, posInSet = 0, setSize = 0;
36879:   rv = GroupPosition(&level, &setSize, &posInSet);
36879:   if (NS_SUCCEEDED(rv))
36879:     nsAccUtils::SetAccGroupAttrs(attributes, level, setSize, posInSet);
  401: 
25174:   // Expose object attributes from ARIA attributes.
43504:   PRUint32 numAttrs = mContent->GetAttrCount();
13012:   for (PRUint32 count = 0; count < numAttrs; count ++) {
43504:     const nsAttrName *attr = mContent->GetAttrNameAt(count);
13012:     if (attr && attr->NamespaceEquals(kNameSpaceID_None)) {
13012:       nsIAtom *attrAtom = attr->Atom();
39100:       nsDependentAtomString attrStr(attrAtom);
39100:       if (!StringBeginsWith(attrStr, NS_LITERAL_STRING("aria-"))) 
13012:         continue; // Not ARIA
24997:       PRUint8 attrFlags = nsAccUtils::GetAttributeCharacteristics(attrAtom);
25997:       if (attrFlags & ATTR_BYPASSOBJ)
25997:         continue; // No need to handle exposing as obj attribute here
24997:       if ((attrFlags & ATTR_VALTOKEN) &&
43504:           !nsAccUtils::HasDefinedARIAToken(mContent, attrAtom))
24997:         continue; // only expose token based attributes if they are defined
13012:       nsAutoString value;
43504:       if (mContent->GetAttr(kNameSpaceID_None, attrAtom, value)) {
39100:         attributes->SetStringProperty(NS_ConvertUTF16toUTF8(Substring(attrStr, 5)), value, oldValueUnused);
13012:       }
13012:     }
13012:   }
13012: 
25174:   // If there is no aria-live attribute then expose default value of 'live'
25174:   // object attribute used for ARIA role of this accessible.
25174:   if (mRoleMapEntry) {
25174:     nsAutoString live;
25174:     nsAccUtils::GetAccAttr(attributes, nsAccessibilityAtoms::live, live);
25174:     if (live.IsEmpty()) {
32053:       if (nsAccUtils::GetLiveAttrValue(mRoleMapEntry->liveAttRule, live))
25174:         nsAccUtils::SetAccAttr(attributes, nsAccessibilityAtoms::live, live);
25174:     }
25174:   }
25174: 
    1:   return NS_OK;
    1: }
    1: 
  401: nsresult
  401: nsAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
  401: {
13094:   // Attributes set by this method will not be used to override attributes on a sub-document accessible
13094:   // when there is a <frame>/<iframe> element that spawned the sub-document
43504:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(mContent));
  401: 
  401:   nsAutoString tagName;
  401:   element->GetTagName(tagName);
  401:   if (!tagName.IsEmpty()) {
  401:     nsAutoString oldValueUnused;
  401:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("tag"), tagName,
  401:                                    oldValueUnused);
  401:   }
  401: 
43504:   nsEventShell::GetEventAttributes(GetNode(), aAttributes);
13094:  
13094:   // Expose class because it may have useful microformat information
13094:   // Let the class from an iframe's document be exposed, don't override from <iframe class>
13094:   nsAutoString _class;
43504:   if (mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::_class, _class))
20536:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::_class, _class);
13094: 
13094:   // Get container-foo computed live region properties based on the closest container with
13094:   // the live region attribute. 
13094:   // Inner nodes override outer nodes within the same document --
13094:   //   The inner nodes can be used to override live region behavior on more general outer nodes
13094:   // However, nodes in outer documents override nodes in inner documents:
13094:   //   Outer doc author may want to override properties on a widget they used in an iframe
43504:   nsIContent *startContent = mContent;
13094:   while (PR_TRUE) {
13094:     NS_ENSURE_STATE(startContent);
13094:     nsIDocument *doc = startContent->GetDocument();
43504:     nsIContent* rootContent = nsCoreUtils::GetRoleContent(doc);
43504:     NS_ENSURE_STATE(rootContent);
20536:     nsAccUtils::SetLiveContainerAttributes(aAttributes, startContent,
43504:                                            rootContent);
21169: 
13094:     // Allow ARIA live region markup from outer documents to override
13094:     nsCOMPtr<nsISupports> container = doc->GetContainer(); 
21169:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
21169:       do_QueryInterface(container);
13351:     if (!docShellTreeItem)
13351:       break;
21169: 
21169:     nsCOMPtr<nsIDocShellTreeItem> sameTypeParent;
21169:     docShellTreeItem->GetSameTypeParent(getter_AddRefs(sameTypeParent));
13094:     if (!sameTypeParent || sameTypeParent == docShellTreeItem)
13094:       break;
21169: 
13094:     nsIDocument *parentDoc = doc->GetParentDocument();
13408:     if (!parentDoc)
13408:       break;
21169: 
13094:     startContent = parentDoc->FindContentForSubDocument(doc);      
13094:   }
13094: 
15645:   // Expose 'display' attribute.
21002:   nsAutoString value;
15645:   nsresult rv = GetComputedStyleValue(EmptyString(),
15645:                                       NS_LITERAL_STRING("display"),
21002:                                       value);
15645:   if (NS_SUCCEEDED(rv))
20536:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::display,
21002:                            value);
21002: 
21002:   // Expose 'text-align' attribute.
21002:   rv = GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("text-align"),
21002:                              value);
21002:   if (NS_SUCCEEDED(rv))
21002:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::textAlign,
21002:                            value);
21002: 
21002:   // Expose 'text-indent' attribute.
21002:   rv = GetComputedStyleValue(EmptyString(), NS_LITERAL_STRING("text-indent"),
21002:                              value);
21002:   if (NS_SUCCEEDED(rv))
21002:     nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::textIndent,
21002:                            value);
21002: 
29397:   // Expose draggable object attribute?
43504:   nsCOMPtr<nsIDOMNSHTMLElement> htmlElement = do_QueryInterface(mContent);
29397:   if (htmlElement) {
29397:     PRBool draggable = PR_FALSE;
29397:     htmlElement->GetDraggable(&draggable);
29397:     if (draggable) {
29397:       nsAccUtils::SetAccAttr(aAttributes, nsAccessibilityAtoms::draggable,
29397:                              NS_LITERAL_STRING("true"));
29397:     }
29397:   }
29397: 
  401:   return NS_OK;
  401: }
  401: 
  144: NS_IMETHODIMP
  144: nsAccessible::GroupPosition(PRInt32 *aGroupLevel,
  144:                             PRInt32 *aSimilarItemsInGroup,
  144:                             PRInt32 *aPositionInGroup)
  144: {
  144:   NS_ENSURE_ARG_POINTER(aGroupLevel);
36879:   *aGroupLevel = 0;
36879: 
  144:   NS_ENSURE_ARG_POINTER(aSimilarItemsInGroup);
36879:   *aSimilarItemsInGroup = 0;
36879: 
  144:   NS_ENSURE_ARG_POINTER(aPositionInGroup);
  144:   *aPositionInGroup = 0;
  144: 
36879:   if (IsDefunct())
  757:     return NS_ERROR_FAILURE;
36879: 
36879:   // Get group position from ARIA attributes.
43504:   nsCoreUtils::GetUIntAttr(mContent, nsAccessibilityAtoms::aria_level,
37109:                            aGroupLevel);
43504:   nsCoreUtils::GetUIntAttr(mContent, nsAccessibilityAtoms::aria_posinset,
37109:                            aPositionInGroup);
43504:   nsCoreUtils::GetUIntAttr(mContent, nsAccessibilityAtoms::aria_setsize,
37109:                            aSimilarItemsInGroup);
36879: 
36879:   // If ARIA is missed and the accessible is visible then calculate group
36879:   // position from hierarchy.
36879:   if (nsAccUtils::State(this) & nsIAccessibleStates::STATE_INVISIBLE)
36879:     return NS_OK;
36879: 
36879:   // Calculate group level if ARIA is missed.
36879:   if (*aGroupLevel == 0) {
36879:     PRInt32 level = GetLevelInternal();
36879:     if (level != 0)
36879:       *aGroupLevel = level;
36879:   }
36879: 
36879:   // Calculate position in group and group size if ARIA is missed.
36879:   if (*aSimilarItemsInGroup == 0 || *aPositionInGroup == 0) {
36879:     PRInt32 posInSet = 0, setSize = 0;
36879:     GetPositionAndSizeInternal(&posInSet, &setSize);
36879:     if (posInSet != 0 && setSize != 0) {
36879:       if (*aPositionInGroup == 0)
36879:         *aPositionInGroup = posInSet;
36879: 
36879:       if (*aSimilarItemsInGroup == 0)
 7888:         *aSimilarItemsInGroup = setSize;
36879:     }
36879:   }
  144: 
  144:   return NS_OK;
  144: }
  144: 
  262: NS_IMETHODIMP
21256: nsAccessible::GetState(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
  262:   NS_ENSURE_ARG_POINTER(aState);
  262: 
21256:   nsresult rv = GetStateInternal(aState, aExtraState);
21984:   NS_ENSURE_A11Y_SUCCESS(rv, rv);
  262: 
 4381:   // Apply ARIA states to be sure accessible states will be overriden.
29565:   GetARIAState(aState, aExtraState);
 4381: 
 6596:   if (mRoleMapEntry && mRoleMapEntry->role == nsIAccessibleRole::ROLE_PAGETAB) {
 6596:     if (*aState & nsIAccessibleStates::STATE_FOCUSED) {
 6596:       *aState |= nsIAccessibleStates::STATE_SELECTED;
 6596:     } else {
 6596:       // Expose 'selected' state on ARIA tab if the focus is on internal element
 6596:       // of related tabpanel.
24822:       nsCOMPtr<nsIAccessible> tabPanel = nsRelUtils::
24822:         GetRelatedAccessible(this, nsIAccessibleRelation::RELATION_LABEL_FOR);
 6596: 
20566:       if (nsAccUtils::Role(tabPanel) == nsIAccessibleRole::ROLE_PROPERTYPAGE) {
43504:         nsRefPtr<nsAccessible> tabPanelAcc(do_QueryObject(tabPanel));
43504:         nsINode *tabPanelNode = tabPanelAcc->GetNode();
43504:         if (nsCoreUtils::IsAncestorOf(tabPanelNode, gLastFocusedNode))
 6596:           *aState |= nsIAccessibleStates::STATE_SELECTED;
 6596:       }
 6596:     }
 6596:   }
 6596: 
20128:   const PRUint32 kExpandCollapseStates =
20128:     nsIAccessibleStates::STATE_COLLAPSED | nsIAccessibleStates::STATE_EXPANDED;
20128:   if ((*aState & kExpandCollapseStates) == kExpandCollapseStates) {
20128:     // Cannot be both expanded and collapsed -- this happens in ARIA expanded
20128:     // combobox because of limitation of nsARIAMap.
20128:     // XXX: Perhaps we will be able to make this less hacky if we support
20128:     // extended states in nsARIAMap, e.g. derive COLLAPSED from
20128:     // EXPANDABLE && !EXPANDED.
20128:     *aState &= ~nsIAccessibleStates::STATE_COLLAPSED;
20128:   }
20128: 
 3465:   // Set additional states which presence depends on another states.
 6172:   if (!aExtraState)
 6172:     return NS_OK;
 6172: 
 3465:   if (!(*aState & nsIAccessibleStates::STATE_UNAVAILABLE)) {
 3465:     *aExtraState |= nsIAccessibleStates::EXT_STATE_ENABLED |
 3465:                     nsIAccessibleStates::EXT_STATE_SENSITIVE;
 3465:   }
 3465: 
20128:   if ((*aState & nsIAccessibleStates::STATE_COLLAPSED) ||
20128:       (*aState & nsIAccessibleStates::STATE_EXPANDED))
 3465:     *aExtraState |= nsIAccessibleStates::EXT_STATE_EXPANDABLE;
 6172: 
 8862:   if (mRoleMapEntry) {
 8862:     // If an object has an ancestor with the activedescendant property
 8862:     // pointing at it, we mark it as ACTIVE even if it's not currently focused.
 8862:     // This allows screen reader virtual buffer modes to know which descendant
 8862:     // is the current one that would get focus if the user navigates to the container widget.
 8862:     nsAutoString id;
43504:     if (nsCoreUtils::GetID(mContent, id)) {
43504:       nsIContent *ancestorContent = mContent;
 8862:       nsAutoString activeID;
 8862:       while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
 8862:         if (ancestorContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_activedescendant, activeID)) {
 8862:           if (id == activeID) {
 8862:             *aExtraState |= nsIAccessibleStates::EXT_STATE_ACTIVE;
 8862:           }
 8862:           break;
 8862:         }
 8862:       }
 8862:     }
 8862:   }
 8862: 
 6172:   // For some reasons DOM node may have not a frame. We tract such accessibles
 6172:   // as invisible.
 5424:   nsIFrame *frame = GetFrame();
 6172:   if (!frame)
 6172:     return NS_OK;
 6172: 
 5424:   const nsStyleDisplay* display = frame->GetStyleDisplay();
 5424:   if (display && display->mOpacity == 1.0f &&
 5424:       !(*aState & nsIAccessibleStates::STATE_INVISIBLE)) {
 5424:     *aExtraState |= nsIAccessibleStates::EXT_STATE_OPAQUE;
 5424:   }
 5424: 
 5424:   const nsStyleXUL *xulStyle = frame->GetStyleXUL();
 5424:   if (xulStyle) {
 5424:     // In XUL all boxes are either vertical or horizontal
 5424:     if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL) {
 5424:       *aExtraState |= nsIAccessibleStates::EXT_STATE_VERTICAL;
 5424:     }
 5424:     else {
 5424:       *aExtraState |= nsIAccessibleStates::EXT_STATE_HORIZONTAL;
 5424:     }
 5424:   }
 3465:   
25066:   // If we are editable, force readonly bit off
25066:   if (*aExtraState & nsIAccessibleStates::EXT_STATE_EDITABLE)
25066:     *aState &= ~nsIAccessibleStates::STATE_READONLY;
25066:  
 4381:   return NS_OK;
  262: }
  262: 
13094: nsresult
29565: nsAccessible::GetARIAState(PRUint32 *aState, PRUint32 *aExtraState)
  262: {
    1:   // Test for universal states first
 2136:   PRUint32 index = 0;
43504:   while (nsStateMapEntry::MapToStates(mContent, aState, aExtraState,
29565:                                       nsARIAMap::gWAIUnivStateMap[index])) {
 2136:     ++ index;
  262:   }
  262: 
15374:   if (mRoleMapEntry) {
32104: 
32104:     // We only force the readonly bit off if we have a real mapping for the aria
32104:     // role. This preserves the ability for screen readers to use readonly
32104:     // (primarily on the document) as the hint for creating a virtual buffer.
32104:     if (mRoleMapEntry->role != nsIAccessibleRole::ROLE_NOTHING)
13715:       *aState &= ~nsIAccessibleStates::STATE_READONLY;
13715: 
43504:     if (mContent->HasAttr(kNameSpaceID_None, mContent->GetIDAttributeName())) {
13716:       // If has a role & ID and aria-activedescendant on the container, assume focusable
43504:       nsIContent *ancestorContent = mContent;
13716:       while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
13716:         if (ancestorContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_activedescendant)) {
13716:             // ancestor has activedescendant property, this content could be active
13716:           *aState |= nsIAccessibleStates::STATE_FOCUSABLE;
13716:           break;
13716:         }
13716:       }
13716:     }
15374:   }
15374: 
15374:   if (*aState & nsIAccessibleStates::STATE_FOCUSABLE) {
15374:     // Special case: aria-disabled propagates from ancestors down to any focusable descendant
43504:     nsIContent *ancestorContent = mContent;
15374:     while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
15374:       if (ancestorContent->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::aria_disabled,
15374:                                        nsAccessibilityAtoms::_true, eCaseMatters)) {
15374:           // ancestor has aria-disabled property, this is disabled
15374:         *aState |= nsIAccessibleStates::STATE_UNAVAILABLE;
15374:         break;
15374:       }
15374:     }    
15374:   }
15374: 
15374:   if (!mRoleMapEntry)
15374:     return NS_OK;
13716: 
25066:   // Note: the readonly bitflag will be overridden later if content is editable
13715:   *aState |= mRoleMapEntry->state;
43504:   if (nsStateMapEntry::MapToStates(mContent, aState, aExtraState,
29565:                                    mRoleMapEntry->attributeMap1) &&
43504:       nsStateMapEntry::MapToStates(mContent, aState, aExtraState,
29565:                                    mRoleMapEntry->attributeMap2)) {
43504:     nsStateMapEntry::MapToStates(mContent, aState, aExtraState,
29565:                                  mRoleMapEntry->attributeMap3);
13094:   }
13094: 
13094:   return NS_OK;
    1: }
    1: 
    1: // Not implemented by this class
    1: 
    1: /* DOMString getValue (); */
13757: NS_IMETHODIMP
13757: nsAccessible::GetValue(nsAString& aValue)
    1: {
13757:   if (IsDefunct())
13757:     return NS_ERROR_FAILURE;
13757: 
    1:   if (mRoleMapEntry) {
    1:     if (mRoleMapEntry->valueRule == eNoValue) {
    1:       return NS_OK;
    1:     }
13757: 
11394:     // aria-valuenow is a number, and aria-valuetext is the optional text equivalent
11394:     // For the string value, we will try the optional text equivalent first
43504:     if (!mContent->GetAttr(kNameSpaceID_None,
43504:                            nsAccessibilityAtoms::aria_valuetext, aValue)) {
43504:       mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_valuenow,
43504:                         aValue);
    1:     }
    1:   }
13757: 
13757:   if (!aValue.IsEmpty())
13757:     return NS_OK;
13757: 
20072:   // Check if it's a simple xlink.
43504:   if (nsCoreUtils::IsXLink(mContent)) {
13757:     nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
43504:     if (presShell) {
43504:       nsCOMPtr<nsIDOMNode> DOMNode(do_QueryInterface(mContent));
43504:       return presShell->GetLinkLocation(DOMNode, aValue);
43504:     }
13757:   }
13757: 
    1:   return NS_OK;
    1: }
    1: 
 4274: // nsIAccessibleValue
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMaximumValue(double *aMaximumValue)
    1: {
 8937:   return GetAttrValue(nsAccessibilityAtoms::aria_valuemax, aMaximumValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMinimumValue(double *aMinimumValue)
 4274: {
 8937:   return GetAttrValue(nsAccessibilityAtoms::aria_valuemin, aMinimumValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMinimumIncrement(double *aMinIncrement)
 4274: {
 4274:   NS_ENSURE_ARG_POINTER(aMinIncrement);
 4274:   *aMinIncrement = 0;
 4274: 
 4274:   // No mimimum increment in dynamic content spec right now
 4274:   return NS_OK_NO_ARIA_VALUE;
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetCurrentValue(double *aValue)
 4274: {
 8937:   return GetAttrValue(nsAccessibilityAtoms::aria_valuenow, aValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::SetCurrentValue(double aValue)
 4274: {
43504:   if (IsDefunct())
43504:     return NS_ERROR_FAILURE;
 4274: 
 4274:   if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
 4274:     return NS_OK_NO_ARIA_VALUE;
 4274: 
    1:   const PRUint32 kValueCannotChange = nsIAccessibleStates::STATE_READONLY |
    1:                                       nsIAccessibleStates::STATE_UNAVAILABLE;
    1: 
20566:   if (nsAccUtils::State(this) & kValueCannotChange)
    1:     return NS_ERROR_FAILURE;
 4274: 
 4274:   double minValue = 0;
 4274:   if (NS_SUCCEEDED(GetMinimumValue(&minValue)) && aValue < minValue)
    1:     return NS_ERROR_INVALID_ARG;
 4274: 
 4274:   double maxValue = 0;
 4274:   if (NS_SUCCEEDED(GetMaximumValue(&maxValue)) && aValue > maxValue)
    1:     return NS_ERROR_INVALID_ARG;
 4274: 
    1:   nsAutoString newValue;
    1:   newValue.AppendFloat(aValue);
43504:   return mContent->SetAttr(kNameSpaceID_None,
43504:                            nsAccessibilityAtoms::aria_valuenow, newValue,
43504:                            PR_TRUE);
 6279: }
    1: 
    1: /* void setName (in DOMString name); */
    1: NS_IMETHODIMP nsAccessible::SetName(const nsAString& name)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessible::GetDefaultKeyBinding(nsAString& aKeyBinding)
    1: {
    1:   aKeyBinding.Truncate();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessible::GetKeyBindings(PRUint8 aActionIndex,
    1:                              nsIDOMDOMStringList **aKeyBindings)
    1: {
    1:   // Currently we support only unique key binding on element for default action.
    1:   NS_ENSURE_TRUE(aActionIndex == 0, NS_ERROR_INVALID_ARG);
    1: 
    1:   nsAccessibleDOMStringList *keyBindings = new nsAccessibleDOMStringList();
    1:   NS_ENSURE_TRUE(keyBindings, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsAutoString defaultKey;
    1:   nsresult rv = GetDefaultKeyBinding(defaultKey);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!defaultKey.IsEmpty())
    1:     keyBindings->Add(defaultKey);
    1: 
    1:   NS_ADDREF(*aKeyBindings = keyBindings);
    1:   return NS_OK;
    1: }
    1: 
52027: PRUint32
58433: nsAccessible::ARIARoleInternal()
52053: {
58433:   NS_PRECONDITION(mRoleMapEntry && mRoleMapEntry->roleRule == kUseMapRole,
58433:                   "ARIARoleInternal should only be called when ARIA role overrides!");
52053: 
52053:   // XXX: these unfortunate exceptions don't fit into the ARIA table. This is
52053:   // where the accessible role depends on both the role and ARIA state.
52053:   if (mRoleMapEntry->role == nsIAccessibleRole::ROLE_PUSHBUTTON) {
52053:     if (nsAccUtils::HasDefinedARIAToken(mContent,
52053:                                         nsAccessibilityAtoms::aria_pressed)) {
52053:       // For simplicity, any existing pressed attribute except "" or "undefined"
52053:       // indicates a toggle.
52053:       return nsIAccessibleRole::ROLE_TOGGLE_BUTTON;
52053:     }
52053: 
52053:     if (mContent->AttrValueIs(kNameSpaceID_None,
52053:                               nsAccessibilityAtoms::aria_haspopup,
52053:                               nsAccessibilityAtoms::_true,
52053:                               eCaseMatters)) {
52053:       // For button with aria-haspopup="true".
52053:       return nsIAccessibleRole::ROLE_BUTTONMENU;
52053:     }
52053: 
52053:   } else if (mRoleMapEntry->role == nsIAccessibleRole::ROLE_LISTBOX) {
52053:     // A listbox inside of a combobox needs a special role because of ATK
52053:     // mapping to menu.
52089:     if (mParent && mParent->Role() == nsIAccessibleRole::ROLE_COMBOBOX) {
52053:       return nsIAccessibleRole::ROLE_COMBOBOX_LIST;
52053: 
52053:       nsCOMPtr<nsIAccessible> possibleCombo =
52053:         nsRelUtils::GetRelatedAccessible(this,
52053:                                          nsIAccessibleRelation::RELATION_NODE_CHILD_OF);
52053:       if (nsAccUtils::Role(possibleCombo) == nsIAccessibleRole::ROLE_COMBOBOX)
52053:         return nsIAccessibleRole::ROLE_COMBOBOX_LIST;
52053:     }
52053: 
52053:   } else if (mRoleMapEntry->role == nsIAccessibleRole::ROLE_OPTION) {
52089:     if (mParent && mParent->Role() == nsIAccessibleRole::ROLE_COMBOBOX_LIST)
52053:       return nsIAccessibleRole::ROLE_COMBOBOX_OPTION;
52053:   }
52053: 
52053:   return mRoleMapEntry->role;
52053: }
52053: 
52053: PRUint32
52027: nsAccessible::NativeRole()
    1: {
52027:   return nsCoreUtils::IsXLink(mContent) ?
52027:     nsIAccessibleRole::ROLE_LINK : nsIAccessibleRole::ROLE_NOTHING;
    1: }
    1: 
20140: // readonly attribute PRUint8 numActions
13129: NS_IMETHODIMP
13129: nsAccessible::GetNumActions(PRUint8 *aNumActions)
    1: {
13129:   NS_ENSURE_ARG_POINTER(aNumActions);
    1:   *aNumActions = 0;
13129: 
13129:   if (IsDefunct())
13129:     return NS_ERROR_FAILURE;
13129: 
20566:   PRUint32 actionRule = GetActionRule(nsAccUtils::State(this));
20140:   if (actionRule == eNoAction)
15309:     return NS_OK;
15309: 
13757:   *aNumActions = 1;
13757:   return NS_OK;
13757: }
13757: 
    1: /* DOMString getAccActionName (in PRUint8 index); */
13129: NS_IMETHODIMP
13129: nsAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
13129:   aName.Truncate();
13129: 
13129:   if (aIndex != 0)
13129:     return NS_ERROR_INVALID_ARG;
13129: 
13129:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
13129: 
20566:   PRUint32 states = nsAccUtils::State(this);
20140:   PRUint32 actionRule = GetActionRule(states);
20140: 
20140:  switch (actionRule) {
20140:    case eActivateAction:
20140:      aName.AssignLiteral("activate");
20140:      return NS_OK;
20140: 
20140:    case eClickAction:
20140:      aName.AssignLiteral("click");
20140:      return NS_OK;
20140: 
20140:    case eCheckUncheckAction:
25968:      if (states & nsIAccessibleStates::STATE_CHECKED)
25968:        aName.AssignLiteral("uncheck");
25968:      else if (states & nsIAccessibleStates::STATE_MIXED)
25871:        aName.AssignLiteral("cycle");
20140:      else
20140:        aName.AssignLiteral("check");
20140:      return NS_OK;
20140: 
20140:    case eJumpAction:
13757:      aName.AssignLiteral("jump");
13757:      return NS_OK;
20140: 
20140:    case eOpenCloseAction:
20140:      if (states & nsIAccessibleStates::STATE_COLLAPSED)
20140:        aName.AssignLiteral("open");
20140:      else
20140:        aName.AssignLiteral("close");
13129:      return NS_OK;
20140: 
20140:    case eSelectAction:
20140:      aName.AssignLiteral("select");
20140:      return NS_OK;
20140: 
20140:    case eSwitchAction:
20140:      aName.AssignLiteral("switch");
20140:      return NS_OK;
27511:      
27511:    case eSortAction:
27511:      aName.AssignLiteral("sort");
27511:      return NS_OK;
27511:    
27511:    case eExpandAction:
27511:      if (states & nsIAccessibleStates::STATE_COLLAPSED)
27511:        aName.AssignLiteral("expand");
27511:      else
27511:        aName.AssignLiteral("collapse");
27511:      return NS_OK;
13129:   }
13129: 
13129:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
20140: // AString getActionDescription(in PRUint8 index)
13129: NS_IMETHODIMP
13129: nsAccessible::GetActionDescription(PRUint8 aIndex, nsAString& aDescription)
    1: {
    1:   // default to localized action name.
    1:   nsAutoString name;
    1:   nsresult rv = GetActionName(aIndex, name);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return GetTranslatedString(name, aDescription);
    1: }
    1: 
20140: // void doAction(in PRUint8 index)
13129: NS_IMETHODIMP
13129: nsAccessible::DoAction(PRUint8 aIndex)
    1: {
13129:   if (aIndex != 0)
13129:     return NS_ERROR_INVALID_ARG;
13129: 
13129:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
13129: 
20566:   if (GetActionRule(nsAccUtils::State(this)) != eNoAction) {
37481:     DoCommand();
37481:     return NS_OK;
20140:   }
13129: 
13129:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: /* DOMString getHelp (); */
    1: NS_IMETHODIMP nsAccessible::GetHelp(nsAString& _retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsIAccessible getAccessibleToRight(); */
    1: NS_IMETHODIMP nsAccessible::GetAccessibleToRight(nsIAccessible **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsIAccessible getAccessibleToLeft(); */
    1: NS_IMETHODIMP nsAccessible::GetAccessibleToLeft(nsIAccessible **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsIAccessible getAccessibleAbove(); */
    1: NS_IMETHODIMP nsAccessible::GetAccessibleAbove(nsIAccessible **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsIAccessible getAccessibleBelow(); */
    1: NS_IMETHODIMP nsAccessible::GetAccessibleBelow(nsIAccessible **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
 6066: nsIDOMNode* nsAccessible::GetAtomicRegion()
 6066: {
43504:   nsIContent *loopContent = mContent;
 6066:   nsAutoString atomic;
 8937:   while (loopContent && !loopContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_atomic, atomic)) {
 6066:     loopContent = loopContent->GetParent();
 6066:   }
 6066: 
 6066:   nsCOMPtr<nsIDOMNode> atomicRegion;
 6066:   if (atomic.EqualsLiteral("true")) {
 6066:     atomicRegion = do_QueryInterface(loopContent);
 6066:   }
 6066:   return atomicRegion;
 6066: }
    1: 
24822: // nsIAccessible getRelationByType()
24822: NS_IMETHODIMP
24822: nsAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                 nsIAccessibleRelation **aRelation)
    1: {
24822:   NS_ENSURE_ARG_POINTER(aRelation);
24822:   *aRelation = nsnull;
24822: 
24822:   if (IsDefunct())
24822:     return NS_ERROR_FAILURE;
24822: 
24822:   // Relationships are defined on the same content node that the role would be
24822:   // defined on.
57845:   nsresult rv = NS_OK_NO_RELATION_TARGET;
    1:   switch (aRelationType)
    1:   {
 1628:   case nsIAccessibleRelation::RELATION_LABEL_FOR:
    1:     {
57845:       RelatedAccIterator iter(GetDocAccessible(), mContent,
57845:                               nsAccessibilityAtoms::aria_labelledby);
57845: 
57845:       nsAccessible* related = nsnull;
57845:       while ((related = iter.Next())) {
57845:         rv = nsRelUtils::AddTarget(aRelationType, aRelation, related);
57845:         NS_ENSURE_SUCCESS(rv, rv);
57845:       }
57845: 
43504:       if (mContent->Tag() == nsAccessibilityAtoms::label) {
43504:         nsIAtom *IDAttr = mContent->IsHTML() ?
    1:           nsAccessibilityAtoms::_for : nsAccessibilityAtoms::control;
24822:         rv = nsRelUtils::
43504:           AddTargetFromIDRefAttr(aRelationType, aRelation, mContent, IDAttr);
24822:         NS_ENSURE_SUCCESS(rv, rv);
57845:       }
57845:       return rv;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_LABELLED_BY:
    1:     {
24822:       rv = nsRelUtils::
43504:         AddTargetFromIDRefsAttr(aRelationType, aRelation, mContent,
24822:                                 nsAccessibilityAtoms::aria_labelledby);
24822:       NS_ENSURE_SUCCESS(rv, rv);
24822: 
57932:       nsAccessible* label = nsnull;
57932:       if (mContent->IsHTML()) {
57932:         HTMLLabelIterator iter(GetDocAccessible(), mContent);
57932:         while ((label = iter.Next())) {
57932:           rv = nsRelUtils::AddTarget(aRelationType, aRelation, label);
57932:           NS_ENSURE_SUCCESS(rv, rv);
57932:         }
57932:         return rv;
57932:       }
57932: 
57932:       if (mContent->IsXUL()) {
57932:         XULLabelIterator iter(GetDocAccessible(), mContent);
57932:         while ((label = iter.Next())) {
57932:           rv = nsRelUtils::AddTarget(aRelationType, aRelation, label);
57932:           NS_ENSURE_SUCCESS(rv, rv);
57932:         }
57932:       }
57932:       return rv;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_DESCRIBED_BY:
    1:     {
24822:       rv = nsRelUtils::
43504:         AddTargetFromIDRefsAttr(aRelationType, aRelation, mContent,
24822:                                 nsAccessibilityAtoms::aria_describedby);
24822:       NS_ENSURE_SUCCESS(rv, rv);
24822: 
57932:       if (mContent->IsXUL()) {
57932:         XULDescriptionIterator iter(GetDocAccessible(), mContent);
57932:         nsAccessible* descr = nsnull;
57932:         while ((descr = iter.Next())) {
57932:           rv = nsRelUtils::AddTarget(aRelationType, aRelation, descr);
57932:           NS_ENSURE_SUCCESS(rv, rv);
57932:         }
57932:       }
57932: 
57932:       return rv;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_DESCRIPTION_FOR:
    1:     {
57845:       RelatedAccIterator iter(GetDocAccessible(), mContent,
24822:                               nsAccessibilityAtoms::aria_describedby);
57845: 
57845:       nsAccessible* related = nsnull;
57845:       while ((related = iter.Next())) {
57845:         rv = nsRelUtils::AddTarget(aRelationType, aRelation, related);
24822:         NS_ENSURE_SUCCESS(rv, rv);
57845:       }
24822: 
43504:       if (mContent->Tag() == nsAccessibilityAtoms::description &&
43504:           mContent->IsXUL()) {
    1:         // This affectively adds an optional control attribute to xul:description,
    1:         // which only affects accessibility, by allowing the description to be
    1:         // tied to a control.
24822:         return nsRelUtils::
43504:           AddTargetFromIDRefAttr(aRelationType, aRelation, mContent,
24822:                                  nsAccessibilityAtoms::control);
24822:       }
24822: 
57845:       return rv;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_NODE_CHILD_OF:
    1:     {
57845:       RelatedAccIterator iter(GetDocAccessible(), mContent,
24822:                               nsAccessibilityAtoms::aria_owns);
57845: 
57845:       nsAccessible* related = nsnull;
57845:       while ((related = iter.Next())) {
57845:         rv = nsRelUtils::AddTarget(aRelationType, aRelation, related);
24822:         NS_ENSURE_SUCCESS(rv, rv);
57845:       }
57845: 
57845:       // Got relation from aria-owns, don't calculate it from native markup.
24822:       if (rv != NS_OK_NO_RELATION_TARGET)
57845:         return NS_OK;
24822: 
34028:       // This is an ARIA tree or treegrid that doesn't use owns, so we need to
34028:       // get the parent the hard way.
24822:       if (mRoleMapEntry &&
34028:           (mRoleMapEntry->role == nsIAccessibleRole::ROLE_OUTLINEITEM ||
34028:            mRoleMapEntry->role == nsIAccessibleRole::ROLE_ROW)) {
34028: 
47172:         AccGroupInfo* groupInfo = GetGroupInfo();
47172:         if (!groupInfo)
47172:           return NS_OK_NO_RELATION_TARGET;
47172: 
47172:         return nsRelUtils::AddTarget(aRelationType, aRelation,
47172:                                      groupInfo->GetConceptualParent());
24822:       }
24822: 
30527:       // If accessible is in its own Window, or is the root of a document,
30527:       // then we should provide NODE_CHILD_OF relation so that MSAA clients
30527:       // can easily get to true parent instead of getting to oleacc's
30527:       // ROLE_WINDOW accessible which will prevent us from going up further
30527:       // (because it is system generated and has no idea about the hierarchy
30527:       // above it).
12642:       nsIFrame *frame = GetFrame();
12642:       if (frame) {
12642:         nsIView *view = frame->GetViewExternal();
12642:         if (view) {
23554:           nsIScrollableFrame *scrollFrame = do_QueryFrame(frame);
30527:           if (scrollFrame || view->GetWidget() || !frame->GetParent()) {
36989:             return nsRelUtils::AddTarget(aRelationType, aRelation, GetParent());
24822:           }
24822:         }
24822:       }
24822: 
57845:       return rv;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_CONTROLLED_BY:
    1:     {
57845:       RelatedAccIterator iter(GetDocAccessible(), mContent,
24822:                               nsAccessibilityAtoms::aria_controls);
57845: 
57845:       nsAccessible* related = nsnull;
57845:       while ((related = iter.Next())) {
57845:         rv = nsRelUtils::AddTarget(aRelationType, aRelation, related);
57845:         NS_ENSURE_SUCCESS(rv, rv);
57845:       }
57845:       return rv;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_CONTROLLER_FOR:
    1:     {
54466:       nsresult rv = nsRelUtils::
43504:         AddTargetFromIDRefsAttr(aRelationType, aRelation, mContent,
24822:                                 nsAccessibilityAtoms::aria_controls);
54466:       NS_ENSURE_SUCCESS(rv,rv);
54466: 
57932:       HTMLOutputIterator iter(GetDocAccessible(), mContent);
57932:       nsAccessible* related = nsnull;
57932:       while ((related = iter.Next())) {
57932:         rv = nsRelUtils::AddTarget(aRelationType, aRelation, related);
57932:         NS_ENSURE_SUCCESS(rv, rv);
57932:       }
57932: 
57932:       return rv;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_FLOWS_TO:
    1:     {
24822:       return nsRelUtils::
43504:         AddTargetFromIDRefsAttr(aRelationType, aRelation, mContent,
24822:                                 nsAccessibilityAtoms::aria_flowto);
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_FLOWS_FROM:
    1:     {
57845:       RelatedAccIterator iter(GetDocAccessible(), mContent,
24822:                               nsAccessibilityAtoms::aria_flowto);
57845: 
57845:       nsAccessible* related = nsnull;
57845:       while ((related = iter.Next())) {
57845:         rv = nsRelUtils::AddTarget(aRelationType, aRelation, related);
57845:         NS_ENSURE_SUCCESS(rv, rv);
57845:       }
57845:       return rv;
24822:     }
24822: 
 1628:   case nsIAccessibleRelation::RELATION_DEFAULT_BUTTON:
    1:     {
43504:       if (mContent->IsHTML()) {
 4451:         // HTML form controls implements nsIFormControl interface.
43504:         nsCOMPtr<nsIFormControl> control(do_QueryInterface(mContent));
 4451:         if (control) {
47802:           nsCOMPtr<nsIForm> form(do_QueryInterface(control->GetFormElement()));
24822:           if (form) {
24822:             nsCOMPtr<nsIContent> formContent =
24822:               do_QueryInterface(form->GetDefaultSubmitElement());
24822:             return nsRelUtils::AddTargetFromContent(aRelationType, aRelation,
24822:                                                     formContent);
24822:           }
    1:         }
    1:       }
    1:       else {
    1:         // In XUL, use first <button default="true" .../> in the document
43504:         nsCOMPtr<nsIDOMXULDocument> xulDoc =
43504:           do_QueryInterface(mContent->GetOwnerDoc());
    1:         nsCOMPtr<nsIDOMXULButtonElement> buttonEl;
    1:         if (xulDoc) {
    1:           nsCOMPtr<nsIDOMNodeList> possibleDefaultButtons;
    1:           xulDoc->GetElementsByAttribute(NS_LITERAL_STRING("default"),
    1:                                          NS_LITERAL_STRING("true"),
    1:                                          getter_AddRefs(possibleDefaultButtons));
    1:           if (possibleDefaultButtons) {
    1:             PRUint32 length;
    1:             possibleDefaultButtons->GetLength(&length);
    1:             nsCOMPtr<nsIDOMNode> possibleButton;
    1:             // Check for button in list of default="true" elements
    1:             for (PRUint32 count = 0; count < length && !buttonEl; count ++) {
    1:               possibleDefaultButtons->Item(count, getter_AddRefs(possibleButton));
    1:               buttonEl = do_QueryInterface(possibleButton);
    1:             }
    1:           }
    1:           if (!buttonEl) { // Check for anonymous accept button in <dialog>
    1:             nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(xulDoc));
    1:             if (xblDoc) {
    1:               nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(xulDoc);
    1:               NS_ASSERTION(domDoc, "No DOM document");
    1:               nsCOMPtr<nsIDOMElement> rootEl;
    1:               domDoc->GetDocumentElement(getter_AddRefs(rootEl));
    1:               if (rootEl) {
    1:                 nsCOMPtr<nsIDOMElement> possibleButtonEl;
    1:                 xblDoc->GetAnonymousElementByAttribute(rootEl,
    1:                                                       NS_LITERAL_STRING("default"),
    1:                                                       NS_LITERAL_STRING("true"),
    1:                                                       getter_AddRefs(possibleButtonEl));
    1:                 buttonEl = do_QueryInterface(possibleButtonEl);
    1:               }
    1:             }
    1:           }
24822:           nsCOMPtr<nsIContent> relatedContent(do_QueryInterface(buttonEl));
24822:           return nsRelUtils::AddTargetFromContent(aRelationType, aRelation,
24822:                                                   relatedContent);
24822:         }
24822:       }
24822:       return NS_OK;
24822:     }
24822: 
 4516:   case nsIAccessibleRelation::RELATION_MEMBER_OF:
 4516:     {
24822:       nsCOMPtr<nsIContent> regionContent = do_QueryInterface(GetAtomicRegion());
24822:       return nsRelUtils::
24822:         AddTargetFromContent(aRelationType, aRelation, regionContent);
24822:     }
24822: 
28489:   case nsIAccessibleRelation::RELATION_SUBWINDOW_OF:
28489:   case nsIAccessibleRelation::RELATION_EMBEDS:
28489:   case nsIAccessibleRelation::RELATION_EMBEDDED_BY:
28489:   case nsIAccessibleRelation::RELATION_POPUP_FOR:
28489:   case nsIAccessibleRelation::RELATION_PARENT_WINDOW_OF:
28489:     {
28489:       return NS_OK_NO_RELATION_TARGET;
28489:     }
28489: 
    1:   default:
24822:     return NS_ERROR_INVALID_ARG;
24822:   }
    1: }
    1: 
 1628: NS_IMETHODIMP
 1628: nsAccessible::GetRelationsCount(PRUint32 *aCount)
 1628: {
 1628:   NS_ENSURE_ARG_POINTER(aCount);
 1628:   *aCount = 0;
 1628: 
 1628:   nsCOMPtr<nsIArray> relations;
 1628:   nsresult rv = GetRelations(getter_AddRefs(relations));
 1628:   NS_ENSURE_SUCCESS(rv, rv);
 1628: 
 1628:   return relations->GetLength(aCount);
 1628: }
 1628: 
 1628: NS_IMETHODIMP
 1628: nsAccessible::GetRelation(PRUint32 aIndex, nsIAccessibleRelation **aRelation)
 1628: {
 1628:   NS_ENSURE_ARG_POINTER(aRelation);
 1628:   *aRelation = nsnull;
 1628: 
 1628:   nsCOMPtr<nsIArray> relations;
 1628:   nsresult rv = GetRelations(getter_AddRefs(relations));
 1628:   NS_ENSURE_SUCCESS(rv, rv);
 1628: 
 1628:   nsCOMPtr<nsIAccessibleRelation> relation;
 1628:   rv = relations->QueryElementAt(aIndex, NS_GET_IID(nsIAccessibleRelation),
 1628:                                  getter_AddRefs(relation));
13730: 
13730:   // nsIArray::QueryElementAt() returns NS_ERROR_ILLEGAL_VALUE on invalid index.
13730:   if (rv == NS_ERROR_ILLEGAL_VALUE)
13730:     return NS_ERROR_INVALID_ARG;
13730: 
 1628:   NS_ENSURE_SUCCESS(rv, rv);
 1628: 
 1628:   NS_IF_ADDREF(*aRelation = relation);
13730:   return NS_OK;
 1628: }
 1628: 
 1628: NS_IMETHODIMP
 1628: nsAccessible::GetRelations(nsIArray **aRelations)
 1628: {
 1628:   NS_ENSURE_ARG_POINTER(aRelations);
 1628: 
 1628:   nsCOMPtr<nsIMutableArray> relations = do_CreateInstance(NS_ARRAY_CONTRACTID);
 1628:   NS_ENSURE_TRUE(relations, NS_ERROR_OUT_OF_MEMORY);
 1628: 
 5475:   for (PRUint32 relType = nsIAccessibleRelation::RELATION_FIRST;
 5475:        relType < nsIAccessibleRelation::RELATION_LAST;
 5475:        ++relType) {
24822: 
24822:     nsCOMPtr<nsIAccessibleRelation> relation;
24822:     nsresult rv = GetRelationByType(relType, getter_AddRefs(relation));
24822: 
24822:     if (NS_SUCCEEDED(rv) && relation)
 1628:       relations->AppendElement(relation, PR_FALSE);
 1628:   }
 1628: 
 1628:   NS_ADDREF(*aRelations = relations);
 1628:   return NS_OK;
 1628: }
 1628: 
    1: /* void extendSelection (); */
    1: NS_IMETHODIMP nsAccessible::ExtendSelection()
    1: {
    1:   // XXX Should be implemented, but not high priority
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* [noscript] void getNativeInterface(out voidPtr aOutAccessible); */
    1: NS_IMETHODIMP nsAccessible::GetNativeInterface(void **aOutAccessible)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
37481: void
31673: nsAccessible::DoCommand(nsIContent *aContent, PRUint32 aActionIndex)
31673: {
43504:   nsIContent* content = aContent ? aContent : mContent.get();
43504:   NS_DISPATCH_RUNNABLEMETHOD_ARG2(DispatchClickEvent, this, content,
43504:                                   aActionIndex);
31673: }
31673: 
31673: void
31673: nsAccessible::DispatchClickEvent(nsIContent *aContent, PRUint32 aActionIndex)
31673: {
31673:   if (IsDefunct())
    1:     return;
16427: 
31673:   nsCOMPtr<nsIPresShell> presShell = GetPresShell();
16427: 
16427:   // Scroll into view.
31673:   presShell->ScrollContentIntoView(aContent, NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                    NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                    nsIPresShell::SCROLL_OVERFLOW_HIDDEN);
16427: 
16427:   // Fire mouse down and mouse up events.
20521:   PRBool res = nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, presShell,
31673:                                                aContent);
16427:   if (!res)
16427:     return;
16427: 
31673:   nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_UP, presShell, aContent);
    1: }
    1: 
    1: // nsIAccessibleSelectable
    1: NS_IMETHODIMP nsAccessible::GetSelectedChildren(nsIArray **aSelectedAccessibles)
    1: {
51865:   NS_ENSURE_ARG_POINTER(aSelectedAccessibles);
    1:   *aSelectedAccessibles = nsnull;
    1: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   nsCOMPtr<nsIArray> items = SelectedItems();
51865:   if (items) {
    1:     PRUint32 length = 0;
51865:     items->GetLength(&length);
51865:     if (length)
51865:       items.swap(*aSelectedAccessibles);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // return the nth selected descendant nsIAccessible object
    1: NS_IMETHODIMP nsAccessible::RefSelection(PRInt32 aIndex, nsIAccessible **aSelected)
    1: {
42494:   NS_ENSURE_ARG_POINTER(aSelected);
    1:   *aSelected = nsnull;
42494: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
    1:   if (aIndex < 0) {
42494:     return NS_ERROR_INVALID_ARG;
42494:   }
42494: 
51865:   *aSelected = GetSelectedItem(aIndex);
51865:   if (*aSelected) {
51865:     NS_ADDREF(*aSelected);
51865:     return NS_OK;
51865:   }
51865: 
42494:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
    1: {
42494:   NS_ENSURE_ARG_POINTER(aSelectionCount);
    1:   *aSelectionCount = 0;
42494: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   *aSelectionCount = SelectedItemCount();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::AddChildToSelection(PRInt32 aIndex)
    1: {
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   return aIndex >= 0 && AddItemToSelection(aIndex) ?
51865:     NS_OK : NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::RemoveChildFromSelection(PRInt32 aIndex)
    1: {
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   return aIndex >=0 && RemoveItemFromSelection(aIndex) ?
51865:     NS_OK : NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::IsChildSelected(PRInt32 aIndex, PRBool *aIsSelected)
    1: {
51865:   NS_ENSURE_ARG_POINTER(aIsSelected);
    1:   *aIsSelected = PR_FALSE;
51865: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
    1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
    1: 
51865:   *aIsSelected = IsItemSelected(aIndex);
    1:   return NS_OK;
    1: }
    1: 
42494: NS_IMETHODIMP
42494: nsAccessible::ClearSelection()
    1: {
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   UnselectAll();
    1:   return NS_OK;
    1: }
    1: 
51865: NS_IMETHODIMP
51865: nsAccessible::SelectAllSelection(PRBool* aIsMultiSelect)
    1: {
51865:   NS_ENSURE_ARG_POINTER(aIsMultiSelect);
51865:   *aIsMultiSelect = PR_FALSE;
51865: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   *aIsMultiSelect = SelectAll();
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIAccessibleHyperLink
    1: // Because of new-atk design, any embedded object in text can implement
    1: // nsIAccessibleHyperLink, which helps determine where it is located
    1: // within containing text
    1: 
14223: // readonly attribute long nsIAccessibleHyperLink::anchorCount
13749: NS_IMETHODIMP
14223: nsAccessible::GetAnchorCount(PRInt32 *aAnchorCount)
    1: {
14223:   NS_ENSURE_ARG_POINTER(aAnchorCount);
51810:   *aAnchorCount = 0;
51810: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
51810:   *aAnchorCount = AnchorCount();
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute long nsIAccessibleHyperLink::startIndex
13749: NS_IMETHODIMP
13749: nsAccessible::GetStartIndex(PRInt32 *aStartIndex)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aStartIndex);
    1:   *aStartIndex = 0;
42376: 
42376:   if (IsDefunct())
42376:     return NS_ERROR_FAILURE;
42376: 
51810:   *aStartIndex = StartOffset();
51810:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute long nsIAccessibleHyperLink::endIndex
13749: NS_IMETHODIMP
13749: nsAccessible::GetEndIndex(PRInt32 *aEndIndex)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aEndIndex);
    1:   *aEndIndex = 0;
42376: 
42376:   if (IsDefunct())
42376:     return NS_ERROR_FAILURE;
42376: 
51810:   *aEndIndex = EndOffset();
51810:   return NS_OK;
    1: }
    1: 
13749: NS_IMETHODIMP
13757: nsAccessible::GetURI(PRInt32 aIndex, nsIURI **aURI)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aURI);
51810: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
51810:   if (aIndex < 0 || aIndex >= static_cast<PRInt32>(AnchorCount()))
13757:     return NS_ERROR_INVALID_ARG;
13757: 
51810:   *aURI = GetAnchorURI(aIndex).get();
13757:   return NS_OK;
13757: }
13757: 
    1: 
13749: NS_IMETHODIMP
51810: nsAccessible::GetAnchor(PRInt32 aIndex, nsIAccessible** aAccessible)
    1: {
13730:   NS_ENSURE_ARG_POINTER(aAccessible);
    1:   *aAccessible = nsnull;
13730: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
51810:   if (aIndex < 0 || aIndex >= static_cast<PRInt32>(AnchorCount()))
13730:     return NS_ERROR_INVALID_ARG;
13730: 
51810:   NS_IF_ADDREF(*aAccessible = GetAnchor(aIndex));
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute boolean nsIAccessibleHyperLink::valid
13749: NS_IMETHODIMP
13749: nsAccessible::GetValid(PRBool *aValid)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aValid);
51810:   *aValid = PR_FALSE;
51810: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
51810:   *aValid = IsValid();
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute boolean nsIAccessibleHyperLink::selected
13749: NS_IMETHODIMP
13749: nsAccessible::GetSelected(PRBool *aSelected)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aSelected);
51810:   *aSelected = PR_FALSE;
51810: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
51810:   *aSelected = IsSelected();
    1:   return NS_OK;
51810: 
    1: }
    1: 
61682: void
61682: nsAccessible::AppendTextTo(nsAString& aText, PRUint32 aStartOffset,
61682:                            PRUint32 aLength)
  460: {
43441:   // Return text representation of non-text accessible within hypertext
43441:   // accessible. Text accessible overrides this method to return enclosed text.
61682:   if (aStartOffset != 0 || aLength == 0)
61682:     return;
43441: 
43441:   nsIFrame *frame = GetFrame();
61682:   if (!frame)
61682:     return;
43441: 
43441:   if (frame->GetType() == nsAccessibilityAtoms::brFrame) {
43441:     aText += kForcedNewLineChar;
61842:   } else if (nsAccUtils::MustPrune(GetParent())) {
61842:     // Expose the embedded object accessible as imaginary embedded object
61842:     // character if its parent hypertext accessible doesn't expose children to
61842:     // AT.
43441:     aText += kImaginaryEmbeddedObjectChar;
43441:   } else {
43441:     aText += kEmbeddedObjectChar;
43441:   }
    1: }
    1: 
20246: ////////////////////////////////////////////////////////////////////////////////
43538: // nsAccessNode public methods
43538: 
43538: void
43538: nsAccessible::Shutdown()
43538: {
43538:   // Invalidate the child count and pointers to other accessibles, also make
43538:   // sure none of its children point to this parent
43538:   InvalidateChildren();
56292:   if (mParent)
56292:     mParent->RemoveChild(this);
43538: 
43538:   nsAccessNodeWrap::Shutdown();
43538: }
43538: 
43538: ////////////////////////////////////////////////////////////////////////////////
20246: // nsAccessible public methods
20246: 
20246: nsresult
20246: nsAccessible::GetARIAName(nsAString& aName)
20246: {
20246:   nsAutoString label;
49044: 
49044:   // aria-labelledby now takes precedence over aria-label
25175:   nsresult rv = nsTextEquivUtils::
25175:     GetTextEquivFromIDRefs(this, nsAccessibilityAtoms::aria_labelledby, label);
25175:   if (NS_SUCCEEDED(rv)) {
25175:     label.CompressWhitespace();
20246:     aName = label;
25175:   }
20246: 
49044:   if (label.IsEmpty() &&
49044:       mContent->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::aria_label,
49044:                         label)) {
49044:     label.CompressWhitespace();
49044:     aName = label;
49044:   }
49044:   
49044:   return NS_OK;
20246: }
20246: 
20246: nsresult
20246: nsAccessible::GetNameInternal(nsAString& aName)
20246: {
43504:   if (mContent->IsHTML())
22204:     return GetHTMLName(aName);
20246: 
43504:   if (mContent->IsXUL())
22204:     return GetXULName(aName);
20246: 
20246:   return NS_OK;
20246: }
20246: 
47105: // nsAccessible protected
35523: void
47105: nsAccessible::BindToParent(nsAccessible* aParent, PRUint32 aIndexInParent)
35523: {
35523:   NS_PRECONDITION(aParent, "This method isn't used to set null parent!");
35523: 
56292:   if (mParent) {
56292:     if (mParent != aParent) {
56292:       NS_ERROR("Adopting child!");
36989:       mParent->InvalidateChildren();
56292:     } else {
56292:       NS_ERROR("Binding to the same parent!");
56292:       return;
56292:     }
35523:   }
35523: 
35523:   mParent = aParent;
47105:   mIndexInParent = aIndexInParent;
35523: }
35523: 
35523: void
47803: nsAccessible::UnbindFromParent()
47803: {
47803:   mParent = nsnull;
47803:   mIndexInParent = -1;
50622:   mIndexOfEmbeddedChild = -1;
47803:   mGroupInfo = nsnull;
47803: }
47803: 
47803: void
35523: nsAccessible::InvalidateChildren()
35523: {
36989:   PRInt32 childCount = mChildren.Length();
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
36989:     nsAccessible* child = mChildren.ElementAt(childIdx);
47105:     child->UnbindFromParent();
35523:   }
35523: 
50622:   mEmbeddedObjCollector = nsnull;
35523:   mChildren.Clear();
61466:   SetChildrenFlag(eChildrenUninitialized);
35523: }
35523: 
47105: PRBool
47105: nsAccessible::AppendChild(nsAccessible* aChild)
47105: {
57147:   if (!aChild)
57152:     return PR_FALSE;
57147: 
47105:   if (!mChildren.AppendElement(aChild))
47105:     return PR_FALSE;
47105: 
54948:   if (!nsAccUtils::IsEmbeddedObject(aChild))
61466:     SetChildrenFlag(eMixedChildren);
50622: 
47105:   aChild->BindToParent(this, mChildren.Length() - 1);
47105:   return PR_TRUE;
47105: }
47105: 
47105: PRBool
47105: nsAccessible::InsertChildAt(PRUint32 aIndex, nsAccessible* aChild)
47105: {
57147:   if (!aChild)
57152:     return PR_FALSE;
57147: 
47105:   if (!mChildren.InsertElementAt(aIndex, aChild))
47105:     return PR_FALSE;
47105: 
57147:   for (PRUint32 idx = aIndex + 1; idx < mChildren.Length(); idx++) {
57147:     NS_ASSERTION(mChildren[idx]->mIndexInParent == idx - 1, "Accessible child index doesn't match");
57147:     mChildren[idx]->mIndexInParent = idx;
57147:   }
47105: 
50622:   if (nsAccUtils::IsText(aChild))
61466:     SetChildrenFlag(eMixedChildren);
50622: 
50622:   mEmbeddedObjCollector = nsnull;
50622: 
47105:   aChild->BindToParent(this, aIndex);
47105:   return PR_TRUE;
47105: }
47105: 
47105: PRBool
47105: nsAccessible::RemoveChild(nsAccessible* aChild)
47105: {
57147:   if (!aChild)
57152:     return PR_FALSE;
57147: 
57147:   PRInt32 index = aChild->mIndexInParent;
57147:   if (aChild->mParent != this || index == -1)
47105:     return PR_FALSE;
47105: 
57147:   if (index >= mChildren.Length() || mChildren[index] != aChild) {
56426:     NS_ERROR("Child is bound to parent but parent hasn't this child at its index!");
56426:     aChild->UnbindFromParent();
56426:     return PR_FALSE;
56426:   }
56426: 
57147:   for (PRUint32 idx = index + 1; idx < mChildren.Length(); idx++) {
57147:     NS_ASSERTION(mChildren[idx]->mIndexInParent == idx, "Accessible child index doesn't match");
57147:     mChildren[idx]->mIndexInParent = idx - 1;
57147:   }
57147: 
57147:   aChild->UnbindFromParent();
57147:   mChildren.RemoveElementAt(index);
50622:   mEmbeddedObjCollector = nsnull;
50622: 
47105:   return PR_TRUE;
47105: }
47105: 
36989: nsAccessible*
35523: nsAccessible::GetChildAt(PRUint32 aIndex)
35523: {
35523:   if (EnsureChildren())
35523:     return nsnull;
35523: 
36989:   nsAccessible *child = mChildren.SafeElementAt(aIndex, nsnull);
35523:   if (!child)
35523:     return nsnull;
35523: 
35523: #ifdef DEBUG
36989:   nsAccessible* realParent = child->mParent;
35523:   NS_ASSERTION(!realParent || realParent == this,
35523:                "Two accessibles have the same first child accessible!");
35523: #endif
35523: 
35523:   return child;
35523: }
35523: 
35523: PRInt32
35523: nsAccessible::GetChildCount()
35523: {
36989:   return EnsureChildren() ? -1 : mChildren.Length();
35523: }
35523: 
35523: PRInt32
47105: nsAccessible::GetIndexOf(nsAccessible* aChild)
35523: {
47105:   return EnsureChildren() || (aChild->mParent != this) ?
47105:     -1 : aChild->GetIndexInParent();
35523: }
35523: 
35523: PRInt32
61639: nsAccessible::GetIndexInParent() const
35523: {
47105:   return mIndexInParent;
36989: }
36989: 
50622: PRInt32
50622: nsAccessible::GetEmbeddedChildCount()
50622: {
50622:   if (EnsureChildren())
50622:     return -1;
50622: 
61466:   if (IsChildrenFlag(eMixedChildren)) {
50622:     if (!mEmbeddedObjCollector)
50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
50622:     return mEmbeddedObjCollector ? mEmbeddedObjCollector->Count() : -1;
50622:   }
50622: 
50622:   return GetChildCount();
50622: }
50622: 
50622: nsAccessible*
50622: nsAccessible::GetEmbeddedChildAt(PRUint32 aIndex)
50622: {
50622:   if (EnsureChildren())
50622:     return nsnull;
50622: 
61466:   if (IsChildrenFlag(eMixedChildren)) {
50622:     if (!mEmbeddedObjCollector)
50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
50622:     return mEmbeddedObjCollector ?
50622:       mEmbeddedObjCollector->GetAccessibleAt(aIndex) : nsnull;
50622:   }
50622: 
50622:   return GetChildAt(aIndex);
50622: }
50622: 
50622: PRInt32
50622: nsAccessible::GetIndexOfEmbeddedChild(nsAccessible* aChild)
50622: {
50622:   if (EnsureChildren())
50622:     return -1;
50622: 
61466:   if (IsChildrenFlag(eMixedChildren)) {
50622:     if (!mEmbeddedObjCollector)
50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
50622:     return mEmbeddedObjCollector ?
50622:       mEmbeddedObjCollector->GetIndexAt(aChild) : -1;
50622:   }
50622: 
50622:   return GetIndexOf(aChild);
50622: }
50622: 
20246: ////////////////////////////////////////////////////////////////////////////////
51810: // HyperLinkAccessible methods
51810: 
51810: bool
51810: nsAccessible::IsHyperLink()
51810: {
51810:   // Every embedded accessible within hypertext accessible implements
51810:   // hyperlink interface.
61468:   return mParent && mParent->IsHyperText() && nsAccUtils::IsEmbeddedObject(this);
51810: }
51810: 
51810: PRUint32
51810: nsAccessible::StartOffset()
51810: {
51810:   NS_PRECONDITION(IsHyperLink(), "StartOffset is called not on hyper link!");
51810: 
61468:   nsHyperTextAccessible* hyperText = mParent ? mParent->AsHyperText() : nsnull;
51810:   return hyperText ? hyperText->GetChildOffset(this) : 0;
51810: }
51810: 
51810: PRUint32
51810: nsAccessible::EndOffset()
51810: {
51810:   NS_PRECONDITION(IsHyperLink(), "EndOffset is called on not hyper link!");
51810: 
61468:   nsHyperTextAccessible* hyperText = mParent ? mParent->AsHyperText() : nsnull;
51810:   return hyperText ? (hyperText->GetChildOffset(this) + 1) : 0;
51810: }
51810: 
51810: bool
51810: nsAccessible::IsValid()
51810: {
51810:   NS_PRECONDITION(IsHyperLink(), "IsValid is called on not hyper link!");
51810: 
51810:   PRUint32 state = nsAccUtils::State(this);
51810:   return (0 == (state & nsIAccessibleStates::STATE_INVALID));
51810:   // XXX In order to implement this we would need to follow every link
51810:   // Perhaps we can get information about invalid links from the cache
51810:   // In the mean time authors can use role="link" aria-invalid="true"
51810:   // to force it for links they internally know to be invalid
51810: }
51810: 
51810: bool
51810: nsAccessible::IsSelected()
51810: {
51810:   NS_PRECONDITION(IsHyperLink(), "IsSelected is called on not hyper link!");
51810:   return (gLastFocusedNode == GetNode());
51810: }
51810: 
51810: PRUint32
51810: nsAccessible::AnchorCount()
51810: {
51810:   NS_PRECONDITION(IsHyperLink(), "AnchorCount is called on not hyper link!");
51810:   return 1;
51810: }
51810: 
51810: nsAccessible*
51810: nsAccessible::GetAnchor(PRUint32 aAnchorIndex)
51810: {
51810:   NS_PRECONDITION(IsHyperLink(), "GetAnchor is called on not hyper link!");
51810:   return aAnchorIndex == 0 ? this : nsnull;
51810: }
51810: 
51810: already_AddRefed<nsIURI>
51810: nsAccessible::GetAnchorURI(PRUint32 aAnchorIndex)
51810: {
51810:   NS_PRECONDITION(IsHyperLink(), "GetAnchorURI is called on not hyper link!");
51810: 
51810:   if (aAnchorIndex != 0)
51810:     return nsnull;
51810: 
51810:   // Check if it's a simple xlink.
51810:   if (nsCoreUtils::IsXLink(mContent)) {
51810:     nsAutoString href;
51810:     mContent->GetAttr(kNameSpaceID_XLink, nsAccessibilityAtoms::href, href);
51810: 
51810:     nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
51810:     nsCOMPtr<nsIDocument> document = mContent->GetOwnerDoc();
51810:     nsIURI* anchorURI = nsnull;
51810:     NS_NewURI(&anchorURI, href,
51810:               document ? document->GetDocumentCharacterSet().get() : nsnull,
51810:               baseURI);
51810:     return anchorURI;
51810:   }
51810: 
51810:   return nsnull;
51810: }
51810: 
51865: 
51865: ////////////////////////////////////////////////////////////////////////////////
51865: // SelectAccessible
51865: 
51865: bool
51865: nsAccessible::IsSelect()
51865: {
51865:   // If we have an ARIA role attribute present and the role allows multi
51865:   // selectable state, then we need to support SelectAccessible interface. If
51865:   // either attribute (role or multiselectable) change, then we'll destroy this
51865:   // accessible so that we can follow COM identity rules.
51865: 
51865:   return mRoleMapEntry &&
51865:     (mRoleMapEntry->attributeMap1 == eARIAMultiSelectable ||
51865:      mRoleMapEntry->attributeMap2 == eARIAMultiSelectable ||
51865:      mRoleMapEntry->attributeMap3 == eARIAMultiSelectable);
51865: }
51865: 
51865: already_AddRefed<nsIArray>
51865: nsAccessible::SelectedItems()
51865: {
51865:   nsCOMPtr<nsIMutableArray> selectedItems = do_CreateInstance(NS_ARRAY_CONTRACTID);
51865:   if (!selectedItems)
51865:     return nsnull;
51865: 
51865:   AccIterator iter(this, filters::GetSelected, AccIterator::eTreeNav);
51865:   nsIAccessible* selected = nsnull;
51865:   while ((selected = iter.GetNext()))
51865:     selectedItems->AppendElement(selected, PR_FALSE);
51865: 
51865:   nsIMutableArray* items = nsnull;
51865:   selectedItems.forget(&items);
51865:   return items;
51865: }
51865: 
51865: PRUint32
51865: nsAccessible::SelectedItemCount()
51865: {
51865:   PRUint32 count = 0;
51865:   AccIterator iter(this, filters::GetSelected, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
51865:   while ((selected = iter.GetNext()))
51865:     ++count;
51865: 
51865:   return count;
51865: }
51865: 
51865: nsAccessible*
51865: nsAccessible::GetSelectedItem(PRUint32 aIndex)
51865: {
51865:   AccIterator iter(this, filters::GetSelected, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
51865: 
51865:   PRUint32 index = 0;
51865:   while ((selected = iter.GetNext()) && index < aIndex)
51865:     index++;
51865: 
51865:   return selected;
51865: }
51865: 
51865: bool
51865: nsAccessible::IsItemSelected(PRUint32 aIndex)
51865: {
51865:   PRUint32 index = 0;
51865:   AccIterator iter(this, filters::GetSelectable, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
51865:   while ((selected = iter.GetNext()) && index < aIndex)
51865:     index++;
51865: 
51865:   return selected &&
51865:     nsAccUtils::State(selected) & nsIAccessibleStates::STATE_SELECTED;
51865: }
51865: 
51865: bool
51865: nsAccessible::AddItemToSelection(PRUint32 aIndex)
51865: {
51865:   PRUint32 index = 0;
51865:   AccIterator iter(this, filters::GetSelectable, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
51865:   while ((selected = iter.GetNext()) && index < aIndex)
51865:     index++;
51865: 
51865:   if (selected)
51865:     selected->SetSelected(PR_TRUE);
51865: 
51865:   return static_cast<bool>(selected);
51865: }
51865: 
51865: bool
51865: nsAccessible::RemoveItemFromSelection(PRUint32 aIndex)
51865: {
51865:   PRUint32 index = 0;
51865:   AccIterator iter(this, filters::GetSelectable, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
51865:   while ((selected = iter.GetNext()) && index < aIndex)
51865:     index++;
51865: 
51865:   if (selected)
51865:     selected->SetSelected(PR_FALSE);
51865: 
51865:   return static_cast<bool>(selected);
51865: }
51865: 
51865: bool
51865: nsAccessible::SelectAll()
51865: {
51865:   bool success = false;
51865:   nsAccessible* selectable = nsnull;
51865: 
51865:   AccIterator iter(this, filters::GetSelectable, AccIterator::eTreeNav);
51865:   while((selectable = iter.GetNext())) {
51865:     success = true;
51865:     selectable->SetSelected(PR_TRUE);
51865:   }
51865:   return success;
51865: }
51865: 
51865: bool
51865: nsAccessible::UnselectAll()
51865: {
51865:   bool success = false;
51865:   nsAccessible* selected = nsnull;
51865: 
51865:   AccIterator iter(this, filters::GetSelected, AccIterator::eTreeNav);
51865:   while ((selected = iter.GetNext())) {
51865:     success = true;
51865:     selected->SetSelected(PR_FALSE);
51865:   }
51865:   return success;
51865: }
51865: 
51865: 
51810: ////////////////////////////////////////////////////////////////////////////////
35523: // nsAccessible protected methods
35523: 
35523: void
35523: nsAccessible::CacheChildren()
35523: {
43504:   nsAccTreeWalker walker(mWeakShell, mContent, GetAllowsAnonChildAccessibles());
38358: 
38359:   nsRefPtr<nsAccessible> child;
47105:   while ((child = walker.GetNextChild()) && AppendChild(child));
35523: }
35523: 
35523: void
61461: nsAccessible::TestChildCache(nsAccessible* aCachedChild) const
35523: {
38000: #ifdef DEBUG
40990:   PRInt32 childCount = mChildren.Length();
35523:   if (childCount == 0) {
61466:     NS_ASSERTION(IsChildrenFlag(eChildrenUninitialized),
50622:                  "No children but initialized!");
35523:     return;
35523:   }
35523: 
39144:   nsAccessible *child = nsnull;
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
39144:     child = mChildren[childIdx];
35523:     if (child == aCachedChild)
35523:       break;
35523:   }
35523: 
35523:   NS_ASSERTION(child == aCachedChild,
35523:                "[TestChildCache] cached accessible wasn't found. Wrong accessible tree!");  
35523: #endif
35523: }
35523: 
40575: // nsAccessible public
61463: bool
35523: nsAccessible::EnsureChildren()
35523: {
35523:   if (IsDefunct()) {
61466:     SetChildrenFlag(eChildrenUninitialized);
61463:     return true;
35523:   }
35523: 
61466:   if (!IsChildrenFlag(eChildrenUninitialized))
61463:     return false;
35523: 
50622:   // State is embedded children until text leaf accessible is appended.
61466:   SetChildrenFlag(eEmbeddedChildren); // Prevent reentry
57890: 
57890:   // Notify the document about caching status.
57890:   nsDocAccessible* document = GetDocAccessible();
57890:   if (document)
57890:     document->NotifyOfCachingStart(this);
57890: 
35523:   CacheChildren();
35523: 
57890:   if (document)
57890:     document->NotifyOfCachingEnd(this);
57890: 
61463:   return false;
35523: }
35523: 
39191: nsAccessible*
35523: nsAccessible::GetSiblingAtOffset(PRInt32 aOffset, nsresult* aError)
35523: {
35523:   if (IsDefunct()) {
35523:     if (aError)
35523:       *aError = NS_ERROR_FAILURE;
35523: 
35523:     return nsnull;
35523:   }
35523: 
36989:   nsAccessible *parent = GetParent();
35523:   if (!parent) {
35523:     if (aError)
35523:       *aError = NS_ERROR_UNEXPECTED;
35523: 
35523:     return nsnull;
35523:   }
35523: 
47105:   if (mIndexInParent == -1) {
35523:     if (aError)
35523:       *aError = NS_ERROR_UNEXPECTED;
35523: 
35523:     return nsnull;
35523:   }
35523: 
35523:   if (aError) {
36989:     PRInt32 childCount = parent->GetChildCount();
47105:     if (mIndexInParent + aOffset >= childCount) {
35523:       *aError = NS_OK; // fail peacefully
35523:       return nsnull;
35523:     }
35523:   }
35523: 
47105:   nsAccessible* child = parent->GetChildAt(mIndexInParent + aOffset);
35523:   if (aError && !child)
35523:     *aError = NS_ERROR_UNEXPECTED;
35523: 
35523:   return child;
35523: }
20246: 
42795: nsAccessible *
43504: nsAccessible::GetFirstAvailableAccessible(nsINode *aStartNode) const
    1: {
42795:   nsAccessible *accessible =
43504:     GetAccService()->GetAccessibleInWeakShell(aStartNode, mWeakShell);
34455:   if (accessible)
42795:     return accessible;
34455: 
43504:   nsIContent *content = nsCoreUtils::GetRoleContent(aStartNode);
43504:   nsAccTreeWalker walker(mWeakShell, content, PR_FALSE);
43504:   nsRefPtr<nsAccessible> childAccessible = walker.GetNextChild();
43504:   return childAccessible;
    1: }
    1: 
    1: PRBool nsAccessible::CheckVisibilityInParentChain(nsIDocument* aDocument, nsIView* aView)
    1: {
    1:   nsIDocument* document = aDocument;
    1:   nsIView* view = aView;
    1:   // both view chain and widget chain are broken between chrome and content
    1:   while (document != nsnull) {
    1:     while (view != nsnull) {
    1:       if (view->GetVisibility() == nsViewVisibility_kHide) {
    1:         return PR_FALSE;
    1:       }
    1:       view = view->GetParent();
    1:     }
    1: 
    1:     nsIDocument* parentDoc = document->GetParentDocument();
    1:     if (parentDoc != nsnull) {
    1:       nsIContent* content = parentDoc->FindContentForSubDocument(document);
    1:       if (content != nsnull) {
46225:         nsIPresShell* shell = parentDoc->GetShell();
 7889:         if (!shell) {
 7889:           return PR_FALSE;
 7889:         }
36654:         nsIFrame* frame = content->GetPrimaryFrame();
    1:         while (frame != nsnull && !frame->HasView()) {
    1:           frame = frame->GetParent();
    1:         }
    1: 
    1:         if (frame != nsnull) {
    1:           view = frame->GetViewExternal();
    1:         }
    1:       }
    1:     }
    1: 
    1:     document = parentDoc;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
 4274: 
 4274: nsresult
 8937: nsAccessible::GetAttrValue(nsIAtom *aProperty, double *aValue)
 4274: {
 4274:   NS_ENSURE_ARG_POINTER(aValue);
 4274:   *aValue = 0;
 4274: 
28024:   if (IsDefunct())
 4274:     return NS_ERROR_FAILURE;  // Node already shut down
 4274: 
 4274:  if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
 4274:     return NS_OK_NO_ARIA_VALUE;
 4274: 
28024:   nsAutoString attrValue;
43504:   mContent->GetAttr(kNameSpaceID_None, aProperty, attrValue);
28024: 
28024:   // Return zero value if there is no attribute or its value is empty.
28024:   if (attrValue.IsEmpty())
28024:     return NS_OK;
28024: 
28024:   PRInt32 error = NS_OK;
28024:   double value = attrValue.ToFloat(&error);
28024:   if (NS_SUCCEEDED(error))
28024:     *aValue = value;
28024: 
28024:   return NS_OK;
 4274: }
 4274: 
20140: PRUint32
20140: nsAccessible::GetActionRule(PRUint32 aStates)
20140: {
20140:   if (aStates & nsIAccessibleStates::STATE_UNAVAILABLE)
20140:     return eNoAction;
20140:   
20140:   // Check if it's simple xlink.
43504:   if (nsCoreUtils::IsXLink(mContent))
20140:     return eJumpAction;
20140: 
31782:   // Return "click" action on elements that have an attached popup menu.
43504:   if (mContent->IsXUL())
43504:     if (mContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::popup))
31782:       return eClickAction;
31782: 
20140:   // Has registered 'click' event handler.
43504:   PRBool isOnclick = nsCoreUtils::HasClickListener(mContent);
20140: 
20140:   if (isOnclick)
20140:     return eClickAction;
20140:   
20140:   // Get an action based on ARIA role.
27511:   if (mRoleMapEntry &&
27511:       mRoleMapEntry->actionRule != eNoAction)
20140:     return mRoleMapEntry->actionRule;
20140: 
27511:   // Get an action based on ARIA attribute.
43504:   if (nsAccUtils::HasDefinedARIAToken(mContent,
27511:                                       nsAccessibilityAtoms::aria_expanded))
27511:     return eExpandAction;
27511: 
20140:   return eNoAction;
20140: }
23326: 
47172: AccGroupInfo*
47172: nsAccessible::GetGroupInfo()
47172: {
47172:   if (mGroupInfo)
47172:     return mGroupInfo;
47172: 
47172:   mGroupInfo = AccGroupInfo::CreateGroupInfo(this);
47172:   return mGroupInfo;
47172: }
47172: 
36879: void
36879: nsAccessible::GetPositionAndSizeInternal(PRInt32 *aPosInSet, PRInt32 *aSetSize)
23326: {
47172:   AccGroupInfo* groupInfo = GetGroupInfo();
47172:   if (groupInfo) {
47172:     *aPosInSet = groupInfo->PosInSet();
47172:     *aSetSize = groupInfo->SetSize();
47172:   }
36879: }
36879: 
36879: PRInt32
36879: nsAccessible::GetLevelInternal()
36879: {
37109:   PRInt32 level = nsAccUtils::GetDefaultLevel(this);
37109: 
52089:   PRUint32 role = Role();
36989:   nsAccessible* parent = GetParent();
36879: 
36879:   if (role == nsIAccessibleRole::ROLE_OUTLINEITEM) {
23326:     // Always expose 'level' attribute for 'outlineitem' accessible. The number
23326:     // of nested 'grouping' accessibles containing 'outlineitem' accessible is
23326:     // its level.
37109:     level = 1;
37109: 
23326:     while (parent) {
52089:       PRUint32 parentRole = parent->Role();
23326: 
23326:       if (parentRole == nsIAccessibleRole::ROLE_OUTLINE)
23326:         break;
23326:       if (parentRole == nsIAccessibleRole::ROLE_GROUPING)
36879:         ++ level;
23326: 
36989:       parent = parent->GetParent();
23326:     }
36879: 
37109:   } else if (role == nsIAccessibleRole::ROLE_LISTITEM) {
23326:     // Expose 'level' attribute on nested lists. We assume nested list is a last
23326:     // child of listitem of parent list. We don't handle the case when nested
23326:     // lists have more complex structure, for example when there are accessibles
23326:     // between parent listitem and nested list.
23326: 
23326:     // Calculate 'level' attribute based on number of parent listitems.
37109:     level = 0;
36879: 
23326:     while (parent) {
52089:       PRUint32 parentRole = parent->Role();
23326: 
23326:       if (parentRole == nsIAccessibleRole::ROLE_LISTITEM)
36879:         ++ level;
23326:       else if (parentRole != nsIAccessibleRole::ROLE_LIST)
23326:         break;
23326: 
36989:       parent = parent->GetParent();
23326:     }
23326: 
36879:     if (level == 0) {
23326:       // If this listitem is on top of nested lists then expose 'level'
23326:       // attribute.
36989:       nsAccessible* parent(GetParent());
36989:       PRInt32 siblingCount = parent->GetChildCount();
36989:       for (PRInt32 siblingIdx = 0; siblingIdx < siblingCount; siblingIdx++) {
36989:         nsAccessible* sibling = parent->GetChildAt(siblingIdx);
36989: 
23326:         nsCOMPtr<nsIAccessible> siblingChild;
23326:         sibling->GetLastChild(getter_AddRefs(siblingChild));
23326:         if (nsAccUtils::Role(siblingChild) == nsIAccessibleRole::ROLE_LIST) {
36879:           level = 1;
23326:           break;
23326:         }
23326:       }
36879:     } else {
36879:       ++ level; // level is 1-index based
36879:     }
37109:   }
36879: 
36879:   return level;
36879: }
