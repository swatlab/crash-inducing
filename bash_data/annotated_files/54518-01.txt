    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
    1:  *   Michael Lowe <michael.lowe@bigfoot.com>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsGkAtoms.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsMenuFrame.h"
    1: #include "nsBoxFrame.h"
    1: #include "nsIContent.h"
    1: #include "prtypes.h"
    1: #include "nsIAtom.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsStyleContext.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsMenuPopupFrame.h"
    1: #include "nsMenuBarFrame.h"
    1: #include "nsIView.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMText.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsIViewManager.h"
    1: #include "nsBindingManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsIDOMKeyEvent.h"
 3129: #include "nsEventDispatcher.h"
 3129: #include "nsIPrivateDOMEvent.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDisplayList.h"
    1: #include "nsIReflowCallback.h"
34005: #include "nsISound.h"
41073: #include "nsEventStateManager.h"
41073: #include "nsIDOMXULMenuListElement.h"
42314: #include "mozilla/Services.h"
    1: 
    1: #define NS_MENU_POPUP_LIST_INDEX 0
    1: 
    1: #if defined(XP_WIN) || defined(XP_OS2)
    1: #define NSCONTEXTMENUISMOUSEUP 1
    1: #endif
    1: 
    1: static PRInt32 gEatMouseMove = PR_FALSE;
    1: 
    1: static NS_DEFINE_IID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
    1: 
    1: nsrefcnt nsMenuFrame::gRefCnt = 0;
    1: nsString *nsMenuFrame::gShiftText = nsnull;
    1: nsString *nsMenuFrame::gControlText = nsnull;
    1: nsString *nsMenuFrame::gMetaText = nsnull;
    1: nsString *nsMenuFrame::gAltText = nsnull;
    1: nsString *nsMenuFrame::gModifierSeparator = nsnull;
41073: const PRInt32 kBlinkDelay = 67; // milliseconds
    1: 
 4009: // this class is used for dispatching menu activation events asynchronously.
 4009: class nsMenuActivateEvent : public nsRunnable
 4009: {
 4009: public:
 4009:   nsMenuActivateEvent(nsIContent *aMenu,
 4009:                       nsPresContext* aPresContext,
 4009:                       PRBool aIsActivate)
 4009:     : mMenu(aMenu), mPresContext(aPresContext), mIsActivate(aIsActivate)
 4009:   {
 4009:   }
 4009: 
 4009:   NS_IMETHOD Run()
 4009:   {
 4009:     nsAutoString domEventToFire;
 4009: 
 4009:     if (mIsActivate) {
 4009:       // Highlight the menu.
 4009:       mMenu->SetAttr(kNameSpaceID_None, nsGkAtoms::menuactive,
 4009:                      NS_LITERAL_STRING("true"), PR_TRUE);
 4009:       // The menuactivated event is used by accessibility to track the user's
 4009:       // movements through menus
 4009:       domEventToFire.AssignLiteral("DOMMenuItemActive");
 4009:     }
 4009:     else {
 4009:       // Unhighlight the menu.
 4009:       mMenu->UnsetAttr(kNameSpaceID_None, nsGkAtoms::menuactive, PR_TRUE);
 4009:       domEventToFire.AssignLiteral("DOMMenuItemInactive");
 4009:     }
 4009: 
 4009:     nsCOMPtr<nsIDOMEvent> event;
 4009:     if (NS_SUCCEEDED(nsEventDispatcher::CreateEvent(mPresContext, nsnull,
 4009:                                                     NS_LITERAL_STRING("Events"),
 4009:                                                     getter_AddRefs(event)))) {
 4009:       event->InitEvent(domEventToFire, PR_TRUE, PR_TRUE);
 4009: 
 4009:       nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
 4009:       privateEvent->SetTrusted(PR_TRUE);
 4009: 
 4009:       nsEventDispatcher::DispatchDOMEvent(mMenu, nsnull, event,
 4009:                                           mPresContext, nsnull);
 4009:     }
 4009: 
 4009:     return NS_OK;
 4009:   }
 4009: 
 4009: private:
 4009:   nsCOMPtr<nsIContent> mMenu;
39823:   nsRefPtr<nsPresContext> mPresContext;
 4009:   PRBool mIsActivate;
 4009: };
 4009: 
49692: class nsMenuAttributeChangedEvent : public nsRunnable
49692: {
49692: public:
49692:   nsMenuAttributeChangedEvent(nsIFrame* aFrame, nsIAtom* aAttr)
49692:   : mFrame(aFrame), mAttr(aAttr)
49692:   {
49692:   }
49692: 
49692:   NS_IMETHOD Run()
49692:   {
49692:     nsMenuFrame* frame = static_cast<nsMenuFrame*>(mFrame.GetFrame());
49692:     NS_ENSURE_STATE(frame);
49692:     if (mAttr == nsGkAtoms::checked) {
49692:       frame->UpdateMenuSpecialState(frame->PresContext());
49692:     } else if (mAttr == nsGkAtoms::acceltext) {
49692:       // someone reset the accelText attribute,
49692:       // so clear the bit that says *we* set it
49692:       frame->AddStateBits(NS_STATE_ACCELTEXT_IS_DERIVED);
49692:       frame->BuildAcceleratorText();
49692:     } else if (mAttr == nsGkAtoms::key) {
49692:       frame->BuildAcceleratorText();
49692:     } else if (mAttr == nsGkAtoms::type || mAttr == nsGkAtoms::name) {
49692:       frame->UpdateMenuType(frame->PresContext());
49692:     }
49692:     return NS_OK;
49692:   }
49692: protected:
49692:   nsWeakFrame       mFrame;
49692:   nsCOMPtr<nsIAtom> mAttr;
49692: };
49692: 
    1: //
23947: // NS_NewMenuFrame and NS_NewMenuItemFrame
    1: //
23947: // Wrappers for creating a new menu popup container
    1: //
    1: nsIFrame*
23947: NS_NewMenuFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   nsMenuFrame* it = new (aPresShell) nsMenuFrame (aPresShell, aContext);
    1:   
23947:   if (it)
    1:     it->SetIsMenu(PR_TRUE);
    1: 
    1:   return it;
    1: }
    1: 
23947: nsIFrame*
23947: NS_NewMenuItemFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
23947: {
23947:   nsMenuFrame* it = new (aPresShell) nsMenuFrame (aPresShell, aContext);
23947: 
23947:   if (it)
23947:     it->SetIsMenu(PR_FALSE);
23947: 
23947:   return it;
23947: }
23947: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsMenuFrame)
32423: 
23554: NS_QUERYFRAME_HEAD(nsMenuFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIMenuFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsBoxFrame)
    1: 
    1: //
    1: // nsMenuFrame cntr
    1: //
    1: nsMenuFrame::nsMenuFrame(nsIPresShell* aShell, nsStyleContext* aContext):
    1:   nsBoxFrame(aShell, aContext),
    1:     mIsMenu(PR_FALSE),
    1:     mChecked(PR_FALSE),
    1:     mType(eMenuType_Normal),
    1:     mMenuParent(nsnull),
41073:     mPopupFrame(nsnull),
41073:     mBlinkState(0)
    1: {
    1: 
    1: } // cntr
    1: 
51752: void
51752: nsMenuFrame::SetParent(nsIFrame* aParent)
    1: {
    1:   nsBoxFrame::SetParent(aParent);
51752:   InitMenuParent(aParent);
    1: }
    1: 
 3129: void
 3129: nsMenuFrame::InitMenuParent(nsIFrame* aParent)
 3129: {
 3129:   while (aParent) {
 3129:     nsIAtom* type = aParent->GetType();
 3129:     if (type == nsGkAtoms::menuPopupFrame) {
 3233:       mMenuParent = static_cast<nsMenuPopupFrame *>(aParent);
 3129:       break;
 3129:     }
 3129:     else if (type == nsGkAtoms::menuBarFrame) {
 3233:       mMenuParent = static_cast<nsMenuBarFrame *>(aParent);
 3129:       break;
 3129:     }
 3129:     aParent = aParent->GetParent();
 3129:   }
    1: }
    1: 
    1: class nsASyncMenuInitialization : public nsIReflowCallback
    1: {
    1: public:
    1:   nsASyncMenuInitialization(nsIFrame* aFrame)
    1:     : mWeakFrame(aFrame)
    1:   {
    1:   }
    1: 
 8509:   virtual PRBool ReflowFinished()
 8509:   {
    1:     PRBool shouldFlush = PR_FALSE;
    1:     if (mWeakFrame.IsAlive()) {
 3129:       if (mWeakFrame.GetFrame()->GetType() == nsGkAtoms::menuFrame) {
 3233:         nsMenuFrame* menu = static_cast<nsMenuFrame*>(mWeakFrame.GetFrame());
  238:         menu->UpdateMenuType(menu->PresContext());
    1:         shouldFlush = PR_TRUE;
    1:       }
    1:     }
    1:     delete this;
    1:     return shouldFlush;
    1:   }
    1: 
 8509:   virtual void ReflowCallbackCanceled()
 8509:   {
 8509:     delete this;
 8509:   }
 8509: 
    1:   nsWeakFrame mWeakFrame;
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::Init(nsIContent*      aContent,
    1:                   nsIFrame*        aParent,
    1:                   nsIFrame*        aPrevInFlow)
    1: {
    1:   nsresult  rv = nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
    1: 
    1:   // Set up a mediator which can be used for callbacks on this frame.
    1:   mTimerMediator = new nsMenuTimerMediator(this);
    1:   if (NS_UNLIKELY(!mTimerMediator))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
 3129:   InitMenuParent(aParent);
    1: 
    1:   //load the display strings for the keyboard accelerators, but only once
    1:   if (gRefCnt++ == 0) {
42314:     nsCOMPtr<nsIStringBundleService> bundleService =
42314:       mozilla::services::GetStringBundleService();
    1:     nsCOMPtr<nsIStringBundle> bundle;
42314:     if (bundleService) {
    1:       rv = bundleService->CreateBundle( "chrome://global-platform/locale/platformKeys.properties",
    1:                                         getter_AddRefs(bundle));
    1:     }
    1:     
    1:     NS_ASSERTION(NS_SUCCEEDED(rv) && bundle, "chrome://global/locale/platformKeys.properties could not be loaded");
    1:     nsXPIDLString shiftModifier;
    1:     nsXPIDLString metaModifier;
    1:     nsXPIDLString altModifier;
    1:     nsXPIDLString controlModifier;
    1:     nsXPIDLString modifierSeparator;
    1:     if (NS_SUCCEEDED(rv) && bundle) {
    1:       //macs use symbols for each modifier key, so fetch each from the bundle, which also covers i18n
    1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("VK_SHIFT").get(), getter_Copies(shiftModifier));
    1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("VK_META").get(), getter_Copies(metaModifier));
    1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("VK_ALT").get(), getter_Copies(altModifier));
    1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("VK_CONTROL").get(), getter_Copies(controlModifier));
    1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("MODIFIER_SEPARATOR").get(), getter_Copies(modifierSeparator));
    1:     } else {
    1:       rv = NS_ERROR_NOT_AVAILABLE;
    1:     }
    1:     //if any of these don't exist, we get  an empty string
    1:     gShiftText = new nsString(shiftModifier);
    1:     gMetaText = new nsString(metaModifier);
    1:     gAltText = new nsString(altModifier);
    1:     gControlText = new nsString(controlModifier);
    1:     gModifierSeparator = new nsString(modifierSeparator);    
    1:   }
    1: 
    1:   BuildAcceleratorText();
    1:   nsIReflowCallback* cb = new nsASyncMenuInitialization(this);
    1:   NS_ENSURE_TRUE(cb, NS_ERROR_OUT_OF_MEMORY);
  238:   PresContext()->PresShell()->PostReflowCallback(cb);
    1:   return rv;
    1: }
    1: 
    1: nsMenuFrame::~nsMenuFrame()
    1: {
    1:   // Clean up shared statics
    1:   if (--gRefCnt == 0) {
    1:     delete gShiftText;
    1:     gShiftText = nsnull;
    1:     delete gControlText;  
    1:     gControlText = nsnull;
    1:     delete gMetaText;  
    1:     gMetaText = nsnull;
    1:     delete gAltText;  
    1:     gAltText = nsnull;
    1:     delete gModifierSeparator;
    1:     gModifierSeparator = nsnull;
    1:   }
    1: }
    1: 
    1: // The following methods are all overridden to ensure that the menupopup frame
    1: // is placed in the appropriate list.
30783: nsFrameList
30783: nsMenuFrame::GetChildList(nsIAtom* aListName) const
    1: {
    1:   if (nsGkAtoms::popupList == aListName) {
32846:     return nsFrameList(mPopupFrame, mPopupFrame);
    1:   }
30783:   return nsBoxFrame::GetChildList(aListName);
    1: }
    1: 
30790: void
30790: nsMenuFrame::SetPopupFrame(nsFrameList& aFrameList)
30790: {
30790:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30790:     if (e.get()->GetType() == nsGkAtoms::menuPopupFrame) {
 3129:       // Remove this frame from the list and set it as mPopupFrame
30790:       mPopupFrame = (nsMenuPopupFrame *)e.get();
30790:       aFrameList.RemoveFrame(e.get());
 3129:       break;
    1:     }
    1:   }
 8127: }
 8127: 
 8127: NS_IMETHODIMP
 8127: nsMenuFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                  nsFrameList&    aChildList)
 8127: {
 8127:   NS_ASSERTION(!mPopupFrame, "already have a popup frame set");
 8127:   if (!aListName || aListName == nsGkAtoms::popupList)
30790:     SetPopupFrame(aChildList);
 3129:   return nsBoxFrame::SetInitialChildList(aListName, aChildList);
    1: }
    1: 
    1: nsIAtom*
    1: nsMenuFrame::GetAdditionalChildListName(PRInt32 aIndex) const
    1: {
    1:   if (NS_MENU_POPUP_LIST_INDEX == aIndex) {
    1:     return nsGkAtoms::popupList;
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: void
36647: nsMenuFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   // Kill our timer if one is active. This is not strictly necessary as
    1:   // the pointer to this frame will be cleared from the mediator, but
    1:   // this is done for added safety.
    1:   if (mOpenTimer) {
    1:     mOpenTimer->Cancel();
    1:   }
    1: 
41073:   StopBlinking();
41073: 
    1:   // Null out the pointer to this frame in the mediator wrapper so that it 
    1:   // doesn't try to interact with a deallocated frame.
    1:   mTimerMediator->ClearFrame();
    1: 
11051:   // if the menu content is just being hidden, it may be made visible again
11051:   // later, so make sure to clear the highlighting.
11051:   mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::menuactive, PR_FALSE);
11051: 
    1:   // are we our menu parent's current menu item?
 3129:   if (mMenuParent && mMenuParent->GetCurrentMenuItem() == this) {
    1:     // yes; tell it that we're going away
 3129:     mMenuParent->CurrentMenuIsBeingDestroyed();
    1:   }
    1: 
 3129:   if (mPopupFrame)
36647:     mPopupFrame->DestroyFrom(aDestructRoot);
 3129: 
36647:   nsBoxFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
    1:                                          const nsRect&           aDirtyRect,
    1:                                          const nsDisplayListSet& aLists)
    1: {
    1:   if (!aBuilder->IsForEventDelivery())
    1:     return nsBoxFrame::BuildDisplayListForChildren(aBuilder, aDirtyRect, aLists);
    1:     
    1:   nsDisplayListCollection set;
    1:   nsresult rv = nsBoxFrame::BuildDisplayListForChildren(aBuilder, aDirtyRect, set);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   return WrapListsInRedirector(aBuilder, set, aLists);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::HandleEvent(nsPresContext* aPresContext, 
    1:                          nsGUIEvent*     aEvent,
    1:                          nsEventStatus*  aEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
41073:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus ||
41073:       (mMenuParent && mMenuParent->IsMenuLocked())) {
25590:     return NS_OK;
25590:   }
25590: 
    1:   nsWeakFrame weakFrame(this);
    1:   if (*aEventStatus == nsEventStatus_eIgnore)
    1:     *aEventStatus = nsEventStatus_eConsumeDoDefault;
    1: 
 3129:   PRBool onmenu = IsOnMenu();
 3129: 
    1:   if (aEvent->message == NS_KEY_PRESS && !IsDisabled()) {
    1:     nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
    1:     PRUint32 keyCode = keyEvent->keyCode;
    1: #ifdef XP_MACOSX
    1:     // On mac, open menulist on either up/down arrow or space (w/o Cmd pressed)
    1:     if (!IsOpen() && ((keyEvent->charCode == NS_VK_SPACE && !keyEvent->isMeta) ||
27928:         (keyCode == NS_VK_UP || keyCode == NS_VK_DOWN))) {
27928:       *aEventStatus = nsEventStatus_eConsumeNoDefault;
 3129:       OpenMenu(PR_FALSE);
27928:     }
    1: #else
    1:     // On other platforms, toggle menulist on unmodified F4 or Alt arrow
    1:     if ((keyCode == NS_VK_F4 && !keyEvent->isAlt) ||
27928:         ((keyCode == NS_VK_UP || keyCode == NS_VK_DOWN) && keyEvent->isAlt)) {
27928:       *aEventStatus = nsEventStatus_eConsumeNoDefault;
 3129:       ToggleMenuState();
27928:     }
    1: #endif
    1:   }
    1:   else if (aEvent->eventStructType == NS_MOUSE_EVENT &&
    1:            aEvent->message == NS_MOUSE_BUTTON_DOWN &&
 3233:            static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton &&
    1:            !IsDisabled() && IsMenu()) {
    1:     // The menu item was selected. Bring up the menu.
    1:     // We have children.
28929:     // Don't prevent the default action here, since that will also cancel
28929:     // potential drag starts.
 3129:     if (!mMenuParent || mMenuParent->IsMenuBar()) {
    1:       ToggleMenuState();
    1:     }
 3129:     else {
27928:       if (!IsOpen()) {
 3129:         OpenMenu(PR_FALSE);
    1:       }
    1:     }
27928:   }
    1:   else if (
    1: #ifndef NSCONTEXTMENUISMOUSEUP
    1:            (aEvent->eventStructType == NS_MOUSE_EVENT &&
    1:             aEvent->message == NS_MOUSE_BUTTON_UP &&
 3233:             static_cast<nsMouseEvent*>(aEvent)->button ==
    1:               nsMouseEvent::eRightButton) &&
    1: #else
    1:             aEvent->message == NS_CONTEXTMENU &&
    1: #endif
 3129:             onmenu && !IsMenu() && !IsDisabled()) {
    1:     // if this menu is a context menu it accepts right-clicks...fire away!
    1:     // Make sure we cancel default processing of the context menu event so
    1:     // that it doesn't bubble and get seen again by the popuplistener and show
    1:     // another context menu.
    1:     //
    1:     // Furthermore (there's always more, isn't there?), on some platforms (win32
    1:     // being one of them) we get the context menu event on a mouse up while
    1:     // on others we get it on a mouse down. For the ones where we get it on a
    1:     // mouse down, we must continue listening for the right button up event to
    1:     // dismiss the menu.
 3129:     if (mMenuParent->IsContextMenu()) {
    1:       *aEventStatus = nsEventStatus_eConsumeNoDefault;
    1:       Execute(aEvent);
    1:     }
    1:   }
    1:   else if (aEvent->eventStructType == NS_MOUSE_EVENT &&
    1:            aEvent->message == NS_MOUSE_BUTTON_UP &&
 3233:            static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton &&
 3129:            !IsMenu() && !IsDisabled()) {
    1:     // Execute the execute event handler.
27928:     *aEventStatus = nsEventStatus_eConsumeNoDefault;
    1:     Execute(aEvent);
    1:   }
    1:   else if (aEvent->message == NS_MOUSE_EXIT_SYNTH) {
    1:     // Kill our timer if one is active.
    1:     if (mOpenTimer) {
    1:       mOpenTimer->Cancel();
    1:       mOpenTimer = nsnull;
    1:     }
    1: 
    1:     // Deactivate the menu.
    1:     if (mMenuParent) {
 3129:       PRBool onmenubar = mMenuParent->IsMenuBar();
 3129:       if (!(onmenubar && mMenuParent->IsActive())) {
 3129:         if (IsMenu() && !onmenubar && IsOpen()) {
    1:           // Submenus don't get closed up immediately.
    1:         }
 6530:         else if (this == mMenuParent->GetCurrentMenuItem()) {
 3129:           mMenuParent->ChangeMenuItem(nsnull, PR_FALSE);
    1:         }
    1:       }
    1:     }
 6530:   }
 3129:   else if (aEvent->message == NS_MOUSE_MOVE &&
 3129:            (onmenu || (mMenuParent && mMenuParent->IsMenuBar()))) {
    1:     if (gEatMouseMove) {
    1:       gEatMouseMove = PR_FALSE;
    1:       return NS_OK;
    1:     }
    1: 
    1:     // Let the menu parent know we're the new item.
 3129:     mMenuParent->ChangeMenuItem(this, PR_FALSE);
    1:     NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
    1:     NS_ENSURE_TRUE(mMenuParent, NS_OK);
    1: 
    1:     // we need to check if we really became the current menu
    1:     // item or not
 3129:     nsMenuFrame *realCurrentItem = mMenuParent->GetCurrentMenuItem();
    1:     if (realCurrentItem != this) {
    1:       // we didn't (presumably because a context menu was active)
    1:       return NS_OK;
    1:     }
    1: 
 3129:     // Hovering over a menu in a popup should open it without a need for a click.
 3129:     // A timer is used so that it doesn't open if the user moves the mouse quickly
 3129:     // past the menu. This conditional check ensures that only menus have this
 3129:     // behaviour
 3129:     if (!IsDisabled() && IsMenu() && !IsOpen() && !mOpenTimer && !mMenuParent->IsMenuBar()) {
    1:       PRInt32 menuDelay = 300;   // ms
    1: 
    1:       nsCOMPtr<nsILookAndFeel> lookAndFeel(do_GetService(kLookAndFeelCID));
    1:       if (lookAndFeel)
    1:         lookAndFeel->GetMetric(nsILookAndFeel::eMetric_SubmenuDelay, menuDelay);
    1: 
    1:       // We're a menu, we're built, we're closed, and no timer has been kicked off.
    1:       mOpenTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:       mOpenTimer->InitWithCallback(mTimerMediator, menuDelay, nsITimer::TYPE_ONE_SHOT);
    1:     }
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
 3129: void
    1: nsMenuFrame::ToggleMenuState()
    1: {
 3129:   if (IsOpen())
 3129:     CloseMenu(PR_FALSE);
 8591:   else
 3129:     OpenMenu(PR_FALSE);
 3129: }
 3129: 
 3129: void
 3129: nsMenuFrame::PopupOpened()
 3129: {
 2946:   nsWeakFrame weakFrame(this);
 3129:   mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::open,
 3129:                     NS_LITERAL_STRING("true"), PR_TRUE);
 3129:   if (!weakFrame.IsAlive())
 3129:     return;
 3129: 
 2946:   if (mMenuParent) {
 2946:     mMenuParent->SetActive(PR_TRUE);
    1:     // Make sure the current menu which is being toggled on
    1:     // the menubar is highlighted
    1:     mMenuParent->SetCurrentMenuItem(this);
 3129:   }
 3129: }
 3129: 
 3129: void
 3129: nsMenuFrame::PopupClosed(PRBool aDeselectMenu)
 3129: {
 3129:   nsWeakFrame weakFrame(this);
22224:   nsContentUtils::AddScriptRunner(
22224:     new nsUnsetAttrRunnable(mContent, nsGkAtoms::open));
 3129:   if (!weakFrame.IsAlive())
 3129:     return;
 3129: 
 3129:   // if the popup is for a menu on a menubar, inform menubar to deactivate
 3129:   if (mMenuParent && mMenuParent->MenuClosed()) {
 4009:     if (aDeselectMenu) {
 3129:       SelectMenu(PR_FALSE);
 4009:     } else {
 4009:       // We are not deselecting the parent menu while closing the popup, so send
 4009:       // a DOMMenuItemActive event to the menu to indicate that the menu is
 4009:       // becoming active again.
 4009:       nsMenuFrame *current = mMenuParent->GetCurrentMenuItem();
 4009:       if (current) {
 4009:         nsCOMPtr<nsIRunnable> event =
 4009:           new nsMenuActivateEvent(current->GetContent(),
 4009:                                   PresContext(), PR_TRUE);
 4009:         NS_DispatchToCurrentThread(event);
 3129:       }
 3129:     }
 3129:   }
 3129: }
 3129: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::SelectMenu(PRBool aActivateFlag)
    1: {
 3129:   if (mContent) {
 3332:     // When a menu opens a submenu, the mouse will often be moved onto a
 3332:     // sibling before moving onto an item within the submenu, causing the
 3332:     // parent to become deselected. We need to ensure that the parent menu
 3332:     // is reselected when an item in the submenu is selected, so navigate up
 3332:     // from the item to its popup, and then to the popup above that.
 3332:     if (aActivateFlag) {
 3332:       nsIFrame* parent = GetParent();
 3332:       while (parent) {
 3332:         if (parent->GetType() == nsGkAtoms::menuPopupFrame) {
 3332:           // a menu is always the direct parent of a menupopup
 3332:           parent = parent->GetParent();
 3332:           if (parent && parent->GetType() == nsGkAtoms::menuFrame) {
 3332:             // a popup however is not necessarily the direct parent of a menu
 3332:             nsIFrame* popupParent = parent->GetParent();
 3332:             while (popupParent) {
 3332:               if (popupParent->GetType() == nsGkAtoms::menuPopupFrame) {
 3332:                 nsMenuPopupFrame* popup = static_cast<nsMenuPopupFrame *>(popupParent);
 3332:                 popup->SetCurrentMenuItem(static_cast<nsMenuFrame *>(parent));
 3332:                 break;
 3332:               }
 3332:               popupParent = popupParent->GetParent();
 3332:             }
 3332:           }
 3332:           break;
 3332:         }
 3332:         parent = parent->GetParent();
 3332:       }
 3332:     }
 3332: 
 3332:     // cancel the close timer if selecting a menu within the popup to be closed
 3332:     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3332:     if (pm)
 3332:       pm->CancelMenuTimer(mMenuParent);
 3332: 
 3129:     nsCOMPtr<nsIRunnable> event =
 3129:       new nsMenuActivateEvent(mContent, PresContext(), aActivateFlag);
 3129:     NS_DispatchToCurrentThread(event);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::AttributeChanged(PRInt32 aNameSpaceID,
    1:                               nsIAtom* aAttribute,
    1:                               PRInt32 aModType)
    1: {
    1: 
49692:   if (aAttribute == nsGkAtoms::checked ||
49692:       aAttribute == nsGkAtoms::acceltext ||
49692:       aAttribute == nsGkAtoms::key ||
49692:       aAttribute == nsGkAtoms::type ||
49692:       aAttribute == nsGkAtoms::name) {
49692:     nsCOMPtr<nsIRunnable> event =
49692:       new nsMenuAttributeChangedEvent(this, aAttribute);
49692:     nsContentUtils::AddScriptRunner(event);
49692:   }
    1:   return NS_OK;
    1: }
    1: 
 3129: void
 3129: nsMenuFrame::OpenMenu(PRBool aSelectFirstItem)
    1: {
    1:   if (!mContent)
 3129:     return;
    1: 
 3129:   gEatMouseMove = PR_TRUE;
    1: 
 3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:   if (pm) {
 3129:     pm->KillMenuTimer();
 3129:     // This opens the menu asynchronously
 3129:     pm->ShowMenu(mContent, aSelectFirstItem, PR_TRUE);
    1:   }
    1: }
    1: 
    1: void
 3129: nsMenuFrame::CloseMenu(PRBool aDeselectMenu)
    1: {
    1:   gEatMouseMove = PR_TRUE;
    1: 
 3129:   // Close the menu asynchronously
 3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:   if (pm && mPopupFrame)
 3129:     pm->HidePopup(mPopupFrame->GetContent(), PR_FALSE, aDeselectMenu, PR_TRUE);
    1: }
    1: 
    1: PRBool
    1: nsMenuFrame::IsSizedToPopup(nsIContent* aContent, PRBool aRequireAlways)
    1: {
    1:   PRBool sizeToPopup;
    1:   if (aContent->Tag() == nsGkAtoms::select)
    1:     sizeToPopup = PR_TRUE;
    1:   else {
    1:     nsAutoString sizedToPopup;
    1:     aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::sizetopopup, sizedToPopup);
    1:     sizeToPopup = sizedToPopup.EqualsLiteral("always") ||
19264:                   (!aRequireAlways && sizedToPopup.EqualsLiteral("pref"));
    1:   }
    1:   
    1:   return sizeToPopup;
    1: }
    1: 
    1: nsSize
    1: nsMenuFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:   nsSize size = nsBoxFrame::GetMinSize(aBoxLayoutState);
    1:   DISPLAY_MIN_SIZE(this, size);
    1: 
    1:   if (IsSizedToPopup(mContent, PR_TRUE))
    1:     SizeToPopup(aBoxLayoutState, size);
    1: 
    1:   return size;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::DoLayout(nsBoxLayoutState& aState)
    1: {
    1:   // lay us out
    1:   nsresult rv = nsBoxFrame::DoLayout(aState);
    1: 
 3129:   if (mPopupFrame) {
    1:     PRBool sizeToPopup = IsSizedToPopup(mContent, PR_FALSE);
42267:     mPopupFrame->LayoutPopup(aState, this, sizeToPopup);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef DEBUG_LAYOUT
    1: NS_IMETHODIMP
    1: nsMenuFrame::SetDebug(nsBoxLayoutState& aState, PRBool aDebug)
    1: {
    1:   // see if our state matches the given debug state
    1:   PRBool debugSet = mState & NS_STATE_CURRENTLY_IN_DEBUG;
    1:   PRBool debugChanged = (!aDebug && debugSet) || (aDebug && !debugSet);
    1: 
    1:   // if it doesn't then tell each child below us the new debug state
    1:   if (debugChanged)
    1:   {
    1:       nsBoxFrame::SetDebug(aState, aDebug);
 3129:       if (mPopupFrame)
 3129:         SetDebug(aState, mPopupFrame, aDebug);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsMenuFrame::SetDebug(nsBoxLayoutState& aState, nsIFrame* aList, PRBool aDebug)
    1: {
    1:       if (!aList)
    1:           return NS_OK;
    1: 
    1:       while (aList) {
    1:         if (aList->IsBoxFrame())
    1:           aList->SetDebug(aState, aDebug);
    1: 
    1:         aList = aList->GetNextSibling();
    1:       }
    1: 
    1:       return NS_OK;
    1: }
    1: #endif
    1: 
    1: //
    1: // Enter
    1: //
    1: // Called when the user hits the <Enter>/<Return> keys or presses the
    1: // shortcut key. If this is a leaf item, the item's action will be executed.
    1: // In either case, do nothing if the item is disabled.
    1: //
 3129: nsMenuFrame*
    1: nsMenuFrame::Enter()
    1: {
    1:   if (IsDisabled()) {
    1: #ifdef XP_WIN
    1:     // behavior on Windows - close the popup chain
 3129:     if (mMenuParent) {
 3129:       nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 6051:       if (pm) {
 6051:         nsIFrame* popup = pm->GetTopPopup(ePopupTypeAny);
 6051:         if (popup)
 6051:           pm->HidePopup(popup->GetContent(), PR_TRUE, PR_TRUE, PR_TRUE);
 6051:       }
 3129:     }
    1: #endif   // #ifdef XP_WIN
    1:     // this menu item was disabled - exit
 3129:     return nsnull;
    1:   }
    1: 
 3129:   if (!IsOpen()) {
    1:     // The enter key press applies to us.
    1:     if (!IsMenu() && mMenuParent)
    1:       Execute(0);          // Execute our event handler
 3129:     else
 3129:       return this;
    1:   }
    1: 
 3129:   return nsnull;
    1: }
    1: 
 3129: PRBool
 3129: nsMenuFrame::IsOpen()
    1: {
 3129:   return mPopupFrame && mPopupFrame->IsOpen();
    1: }
    1: 
    1: PRBool
    1: nsMenuFrame::IsMenu()
    1: {
    1:   return mIsMenu;
    1: }
    1: 
    1: nsresult
    1: nsMenuFrame::Notify(nsITimer* aTimer)
    1: {
    1:   // Our timer has fired.
    1:   if (aTimer == mOpenTimer.get()) {
 3129:     mOpenTimer = nsnull;
 3129: 
 3129:     if (!IsOpen() && mMenuParent) {
    1:       // make sure we didn't open a context menu in the meantime
    1:       // (i.e. the user right-clicked while hovering over a submenu).
 3129:       nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 3129:       if (pm) {
 3129:         if ((!pm->HasContextMenu(nsnull) || mMenuParent->IsContextMenu()) &&
 3129:             mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menuactive,
    1:                                   nsGkAtoms::_true, eCaseMatters)) {
 3129:           OpenMenu(PR_FALSE);
    1:         }
    1:       }
    1:     }
41073:   } else if (aTimer == mBlinkTimer) {
41073:     switch (mBlinkState++) {
41073:       case 0:
41073:         NS_ASSERTION(false, "Blink timer fired while not blinking");
41073:         StopBlinking();
41073:         break;
41073:       case 1:
41073:         {
41073:           // Turn the highlight back on and wait for a while before closing the menu.
41073:           nsWeakFrame weakFrame(this);
41073:           mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::menuactive,
41073:                             NS_LITERAL_STRING("true"), PR_TRUE);
41073:           if (weakFrame.IsAlive()) {
41073:             aTimer->InitWithCallback(mTimerMediator, kBlinkDelay, nsITimer::TYPE_ONE_SHOT);
41073:           }
41073:         }
41073:         break;
41073:       default:
41073:         if (mMenuParent) {
41073:           mMenuParent->LockMenuUntilClosed(PR_FALSE);
41073:         }
41073:         PassMenuCommandEventToPopupManager();
41073:         StopBlinking();
41073:         break;
41073:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool 
    1: nsMenuFrame::IsDisabled()
    1: {
    1:   return mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
    1:                                nsGkAtoms::_true, eCaseMatters);
    1: }
    1: 
    1: void
    1: nsMenuFrame::UpdateMenuType(nsPresContext* aPresContext)
    1: {
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::checkbox, &nsGkAtoms::radio, nsnull};
    1:   switch (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::type,
    1:                                     strings, eCaseMatters)) {
    1:     case 0: mType = eMenuType_Checkbox; break;
    1:     case 1:
    1:       mType = eMenuType_Radio;
    1:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::name, mGroupName);
    1:       break;
    1: 
    1:     default:
    1:       if (mType != eMenuType_Normal) {
    1:         nsWeakFrame weakFrame(this);
    1:         mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::checked,
    1:                             PR_TRUE);
    1:         ENSURE_TRUE(weakFrame.IsAlive());
    1:       }
    1:       mType = eMenuType_Normal;
    1:       break;
    1:   }
    1:   UpdateMenuSpecialState(aPresContext);
    1: }
    1: 
    1: /* update checked-ness for type="checkbox" and type="radio" */
    1: void
 3129: nsMenuFrame::UpdateMenuSpecialState(nsPresContext* aPresContext)
 3129: {
    1:   PRBool newChecked =
    1:     mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::checked,
    1:                           nsGkAtoms::_true, eCaseMatters); 
    1:   if (newChecked == mChecked) {
    1:     /* checked state didn't change */
    1: 
    1:     if (mType != eMenuType_Radio)
    1:       return; // only Radio possibly cares about other kinds of change
    1: 
    1:     if (!mChecked || mGroupName.IsEmpty())
    1:       return;                   // no interesting change
    1:   } else { 
    1:     mChecked = newChecked;
    1:     if (mType != eMenuType_Radio || !mChecked)
    1:       /*
    1:        * Unchecking something requires no further changes, and only
    1:        * menuRadio has to do additional work when checked.
    1:        */
    1:       return;
    1:   }
    1: 
    1:   /*
    1:    * If we get this far, we're type=radio, and:
    1:    * - our name= changed, or
    1:    * - we went from checked="false" to checked="true"
    1:    */
    1: 
    1:   /*
    1:    * Behavioural note:
    1:    * If we're checked and renamed _into_ an existing radio group, we are
    1:    * made the new checked item, and we unselect the previous one.
    1:    *
    1:    * The only other reasonable behaviour would be to check for another selected
    1:    * item in that group.  If found, unselect ourselves, otherwise we're the
    1:    * selected item.  That, however, would be a lot more work, and I don't think
    1:    * it's better at all.
    1:    */
    1: 
    1:   /* walk siblings, looking for the other checked item with the same name */
    1:   // get the first sibling in this menu popup. This frame may be it, and if we're
    1:   // being called at creation time, this frame isn't yet in the parent's child list.
    1:   // All I'm saying is that this may fail, but it's most likely alright.
    1:   nsIFrame* sib = GetParent()->GetFirstChild(nsnull);
    1: 
 3129:   while (sib) {
 3129:     if (sib != this && sib->GetType() == nsGkAtoms::menuFrame) {
 3233:       nsMenuFrame* menu = static_cast<nsMenuFrame*>(sib);
 3129:       if (menu->GetMenuType() == eMenuType_Radio &&
 3129:           menu->IsChecked() &&
 3129:           (menu->GetRadioGroupName() == mGroupName)) {      
    1:         /* uncheck the old item */
    1:         sib->GetContent()->UnsetAttr(kNameSpaceID_None, nsGkAtoms::checked,
    1:                                      PR_TRUE);
    1:         /* XXX in DEBUG, check to make sure that there aren't two checked items */
    1:         return;
    1:       }
 3129:     }
    1: 
 3129:     sib = sib->GetNextSibling();
 3129:   } 
    1: }
    1: 
    1: void 
    1: nsMenuFrame::BuildAcceleratorText()
    1: {
    1:   nsAutoString accelText;
    1: 
    1:   if ((GetStateBits() & NS_STATE_ACCELTEXT_IS_DERIVED) == 0) {
    1:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::acceltext, accelText);
    1:     if (!accelText.IsEmpty())
    1:       return;
    1:   }
    1:   // accelText is definitely empty here.
    1: 
    1:   // Now we're going to compute the accelerator text, so remember that we did.
    1:   AddStateBits(NS_STATE_ACCELTEXT_IS_DERIVED);
    1: 
    1:   // If anything below fails, just leave the accelerator text blank.
    1:   nsWeakFrame weakFrame(this);
    1:   mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::acceltext, PR_FALSE);
    1:   ENSURE_TRUE(weakFrame.IsAlive());
    1: 
    1:   // See if we have a key node and use that instead.
    1:   nsAutoString keyValue;
    1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::key, keyValue);
    1:   if (keyValue.IsEmpty())
    1:     return;
    1: 
    1:   // Turn the document into a DOM document so we can use getElementById
44209:   nsIDocument *document = mContent->GetDocument();
44209:   if (!document)
    1:     return;
    1: 
44209:   nsIContent *keyElement = document->GetElementById(keyValue);
44209:   if (!keyElement) {
    1: #ifdef DEBUG
    1:     nsAutoString label;
    1:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, label);
    1:     nsAutoString msg = NS_LITERAL_STRING("Key '") +
    1:                        keyValue +
    1:                        NS_LITERAL_STRING("' of menu item '") +
    1:                        label +
    1:                        NS_LITERAL_STRING("' could not be found");
    1:     NS_WARNING(NS_ConvertUTF16toUTF8(msg).get());
    1: #endif
    1:     return;
    1:   }
    1: 
    1:   // get the string to display as accelerator text
    1:   // check the key element's attributes in this order:
    1:   // |keytext|, |key|, |keycode|
    1:   nsAutoString accelString;
    1:   keyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::keytext, accelString);
    1: 
    1:   if (accelString.IsEmpty()) {
    1:     keyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::key, accelString);
    1: 
    1:     if (!accelString.IsEmpty()) {
    1:       ToUpperCase(accelString);
    1:     } else {
    1:       nsAutoString keyCode;
    1:       keyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::keycode, keyCode);
    1:       ToUpperCase(keyCode);
    1: 
    1:       nsresult rv;
42314:       nsCOMPtr<nsIStringBundleService> bundleService =
42314:         mozilla::services::GetStringBundleService();
42314:       if (bundleService) {
    1:         nsCOMPtr<nsIStringBundle> bundle;
    1:         rv = bundleService->CreateBundle("chrome://global/locale/keys.properties",
    1:                                          getter_AddRefs(bundle));
    1: 
    1:         if (NS_SUCCEEDED(rv) && bundle) {
    1:           nsXPIDLString keyName;
    1:           rv = bundle->GetStringFromName(keyCode.get(), getter_Copies(keyName));
    1:           if (keyName)
    1:             accelString = keyName;
    1:         }
    1:       }
    1: 
    1:       // nothing usable found, bail
    1:       if (accelString.IsEmpty())
    1:         return;
    1:     }
    1:   }
    1: 
    1:   static PRInt32 accelKey = 0;
    1: 
    1:   if (!accelKey)
    1:   {
    1:     // Compiled-in defaults, in case we can't get LookAndFeel --
    1:     // command for mac, control for all other platforms.
 6499: #ifdef XP_MACOSX
    1:     accelKey = nsIDOMKeyEvent::DOM_VK_META;
    1: #else
    1:     accelKey = nsIDOMKeyEvent::DOM_VK_CONTROL;
    1: #endif
    1: 
    1:     // Get the accelerator key value from prefs, overriding the default:
    1:     accelKey = nsContentUtils::GetIntPref("ui.key.accelKey", accelKey);
    1:   }
    1: 
    1:   nsAutoString modifiers;
    1:   keyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::modifiers, modifiers);
    1:   
    1:   char* str = ToNewCString(modifiers);
    1:   char* newStr;
    1:   char* token = nsCRT::strtok(str, ", \t", &newStr);
    1:   while (token) {
    1:       
    1:     if (PL_strcmp(token, "shift") == 0)
    1:       accelText += *gShiftText;
    1:     else if (PL_strcmp(token, "alt") == 0) 
    1:       accelText += *gAltText; 
    1:     else if (PL_strcmp(token, "meta") == 0) 
    1:       accelText += *gMetaText; 
    1:     else if (PL_strcmp(token, "control") == 0) 
    1:       accelText += *gControlText; 
    1:     else if (PL_strcmp(token, "accel") == 0) {
    1:       switch (accelKey)
    1:       {
    1:         case nsIDOMKeyEvent::DOM_VK_META:
    1:           accelText += *gMetaText;
    1:           break;
    1: 
    1:         case nsIDOMKeyEvent::DOM_VK_ALT:
    1:           accelText += *gAltText;
    1:           break;
    1: 
    1:         case nsIDOMKeyEvent::DOM_VK_CONTROL:
    1:         default:
    1:           accelText += *gControlText;
    1:           break;
    1:       }
    1:     }
    1:     
    1:     accelText += *gModifierSeparator;
    1: 
    1:     token = nsCRT::strtok(newStr, ", \t", &newStr);
    1:   }
    1: 
    1:   nsMemory::Free(str);
    1: 
    1:   accelText += accelString;
    1:   
    1:   mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::acceltext, accelText, PR_FALSE);
    1: }
    1: 
    1: void
    1: nsMenuFrame::Execute(nsGUIEvent *aEvent)
    1: {
    1:   // flip "checked" state if we're a checkbox menu, or an un-checked radio menu
41073:   PRBool needToFlipChecked = PR_FALSE;
    1:   if (mType == eMenuType_Checkbox || (mType == eMenuType_Radio && !mChecked)) {
41073:     needToFlipChecked = !mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::autocheck,
41073:                                                nsGkAtoms::_false, eCaseMatters);
    1:   }
    1: 
34005:   nsCOMPtr<nsISound> sound(do_CreateInstance("@mozilla.org/sound;1"));
34005:   if (sound)
34005:     sound->PlayEventSound(nsISound::EVENT_MENU_EXECUTE);
22575: 
41073:   StartBlinking(aEvent, needToFlipChecked);
41073: }
41073: 
41073: PRBool
41073: nsMenuFrame::ShouldBlink()
41073: {
41073:   PRInt32 shouldBlink = 0;
41073:   nsCOMPtr<nsILookAndFeel> lookAndFeel(do_GetService(kLookAndFeelCID));
41073:   if (lookAndFeel) {
41073:     lookAndFeel->GetMetric(nsILookAndFeel::eMetric_ChosenMenuItemsShouldBlink, shouldBlink);
41073:   }
41073:   if (!shouldBlink)
41073:     return PR_FALSE;
41073: 
41073:   // Don't blink in editable menulists.
41073:   if (mMenuParent && mMenuParent->IsMenu()) {
41073:     nsMenuPopupFrame* popupFrame = static_cast<nsMenuPopupFrame*>(mMenuParent);
41073:     nsIFrame* parentMenu = popupFrame->GetParent();
41073:     if (parentMenu) {
41073:       nsCOMPtr<nsIDOMXULMenuListElement> menulist = do_QueryInterface(parentMenu->GetContent());
41073:       if (menulist) {
41073:         PRBool isEditable = PR_FALSE;
41073:         menulist->GetEditable(&isEditable);
41073:         return !isEditable;
41073:       }
41073:     }
41073:   }
41073:   return PR_TRUE;
41073: }
41073: 
41073: void
41073: nsMenuFrame::StartBlinking(nsGUIEvent *aEvent, PRBool aFlipChecked)
41073: {
41073:   StopBlinking();
41073:   CreateMenuCommandEvent(aEvent, aFlipChecked);
41073: 
41073:   if (!ShouldBlink()) {
41073:     PassMenuCommandEventToPopupManager();
41073:     return;
41073:   }
41073: 
41073:   // Blink off.
41073:   nsWeakFrame weakFrame(this);
41073:   mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::menuactive, PR_TRUE);
41073:   if (!weakFrame.IsAlive())
41073:     return;
41073: 
41073:   if (mMenuParent) {
41073:     // Make this menu ignore events from now on.
41073:     mMenuParent->LockMenuUntilClosed(PR_TRUE);
41073:   }
41073: 
41073:   // Set up a timer to blink back on.
41073:   mBlinkTimer = do_CreateInstance("@mozilla.org/timer;1");
41073:   mBlinkTimer->InitWithCallback(mTimerMediator, kBlinkDelay, nsITimer::TYPE_ONE_SHOT);
41073:   mBlinkState = 1;
41073: }
41073: 
41073: void
41073: nsMenuFrame::StopBlinking()
41073: {
41073:   mBlinkState = 0;
41073:   if (mBlinkTimer) {
41073:     mBlinkTimer->Cancel();
41073:     mBlinkTimer = nsnull;
41073:   }
41073:   mDelayedMenuCommandEvent = nsnull;
41073: }
41073: 
41073: void
41073: nsMenuFrame::CreateMenuCommandEvent(nsGUIEvent *aEvent, PRBool aFlipChecked)
41073: {
41073:   // Create a trusted event if the triggering event was trusted, or if
41073:   // we're called from chrome code (since at least one of our caller
41073:   // passes in a null event).
41073:   PRBool isTrusted = aEvent ? NS_IS_TRUSTED_EVENT(aEvent) :
41073:                               nsContentUtils::IsCallerChrome();
41073: 
41073:   PRBool shift = PR_FALSE, control = PR_FALSE, alt = PR_FALSE, meta = PR_FALSE;
41073:   if (aEvent && (aEvent->eventStructType == NS_MOUSE_EVENT ||
54518:                  aEvent->eventStructType == NS_KEY_EVENT)) {
41073:     shift = static_cast<nsInputEvent *>(aEvent)->isShift;
41073:     control = static_cast<nsInputEvent *>(aEvent)->isControl;
41073:     alt = static_cast<nsInputEvent *>(aEvent)->isAlt;
41073:     meta = static_cast<nsInputEvent *>(aEvent)->isMeta;
41073:   }
41073: 
41073:   // Because the command event is firing asynchronously, a flag is needed to
41073:   // indicate whether user input is being handled. This ensures that a popup
41073:   // window won't get blocked.
41073:   PRBool userinput = nsEventStateManager::IsHandlingUserInput();
41073: 
41073:   mDelayedMenuCommandEvent =
41073:     new nsXULMenuCommandEvent(mContent, isTrusted, shift, control, alt, meta,
41073:                               userinput, aFlipChecked);
41073: }
41073: 
41073: void
41073: nsMenuFrame::PassMenuCommandEventToPopupManager()
41073: {
 3129:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
41073:   if (pm && mMenuParent && mDelayedMenuCommandEvent) {
41073:     pm->ExecuteMenu(mContent, mDelayedMenuCommandEvent);
41073:   }
41073:   mDelayedMenuCommandEvent = nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::RemoveFrame(nsIAtom*        aListName,
    1:                          nsIFrame*       aOldFrame)
    1: {
 3129:   nsresult rv =  NS_OK;
    1: 
 3129:   if (mPopupFrame == aOldFrame) {
    1:     // Go ahead and remove this frame.
 3129:     mPopupFrame->Destroy();
 3129:     mPopupFrame = nsnull;
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                        NS_FRAME_HAS_DIRTY_CHILDREN);
    1:     rv = NS_OK;
    1:   } else {
    1:     rv = nsBoxFrame::RemoveFrame(aListName, aOldFrame);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::InsertFrames(nsIAtom*        aListName,
    1:                           nsIFrame*       aPrevFrame,
30941:                           nsFrameList&    aFrameList)
    1: {
 8127:   if (!mPopupFrame && (!aListName || aListName == nsGkAtoms::popupList)) {
30941:     SetPopupFrame(aFrameList);
 8127:     if (mPopupFrame) {
    1: #ifdef DEBUG_LAYOUT
 3129:       nsBoxLayoutState state(PresContext());
    1:       SetDebug(state, aFrameList, mState & NS_STATE_CURRENTLY_IN_DEBUG);
    1: #endif
 8127: 
  238:       PresContext()->PresShell()->
 1158:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                          NS_FRAME_HAS_DIRTY_CHILDREN);
 8127:     }
 8127:   }
 8127: 
30941:   if (aFrameList.IsEmpty())
 8127:     return NS_OK;
 8127: 
 7067:   if (NS_UNLIKELY(aPrevFrame == mPopupFrame)) {
 7067:     aPrevFrame = nsnull;
 7067:   }
    1: 
 8127:   return nsBoxFrame::InsertFrames(aListName, aPrevFrame, aFrameList);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::AppendFrames(nsIAtom*        aListName,
30941:                           nsFrameList&    aFrameList)
    1: {
 8127:   if (!mPopupFrame && (!aListName || aListName == nsGkAtoms::popupList)) {
30941:     SetPopupFrame(aFrameList);
 8127:     if (mPopupFrame) {
    1: 
    1: #ifdef DEBUG_LAYOUT
 3129:       nsBoxLayoutState state(PresContext());
    1:       SetDebug(state, aFrameList, mState & NS_STATE_CURRENTLY_IN_DEBUG);
    1: #endif
  238:       PresContext()->PresShell()->
 1158:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                          NS_FRAME_HAS_DIRTY_CHILDREN);
 8127:     }
    1:   }
    1: 
30941:   if (aFrameList.IsEmpty())
 8127:     return NS_OK;
 8127: 
 8127:   return nsBoxFrame::AppendFrames(aListName, aFrameList); 
    1: }
    1: 
    1: PRBool
    1: nsMenuFrame::SizeToPopup(nsBoxLayoutState& aState, nsSize& aSize)
    1: {
    1:   if (!IsCollapsed(aState)) {
39604:     PRBool widthSet, heightSet;
    1:     nsSize tmpSize(-1, 0);
39604:     nsIBox::AddCSSPrefSize(this, tmpSize, widthSet, heightSet);
39604:     if (!widthSet && GetFlex(aState) == 0) {
 3129:       if (!mPopupFrame)
    1:         return PR_FALSE;
 3129:       tmpSize = mPopupFrame->GetPrefSize(aState);
    1:       aSize.width = tmpSize.width;
53932: 
53932:       // if there is a scroll frame, add the desired width of the scrollbar as well
53932:       nsIScrollableFrame* scrollFrame = do_QueryFrame(mPopupFrame->GetFirstChild(nsnull));
53932:       if (scrollFrame) {
53932:         aSize.width += scrollFrame->GetDesiredScrollbarSizes(&aState).LeftRight();
53932:       }
53932: 
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsSize
    1: nsMenuFrame::GetPrefSize(nsBoxLayoutState& aState)
    1: {
    1:   nsSize size = nsBoxFrame::GetPrefSize(aState);
    1:   DISPLAY_PREF_SIZE(this, size);
    1: 
    1:   // If we are using sizetopopup="always" then
    1:   // nsBoxFrame will already have enforced the minimum size
    1:   if (!IsSizedToPopup(mContent, PR_TRUE) &&
    1:       IsSizedToPopup(mContent, PR_FALSE) &&
    1:       SizeToPopup(aState, size)) {
    1:     // We now need to ensure that size is within the min - max range.
    1:     nsSize minSize = nsBoxFrame::GetMinSize(aState);
    1:     nsSize maxSize = GetMaxSize(aState);
 9862:     size = BoundsCheck(minSize, size, maxSize);
    1:   }
    1: 
    1:   return size;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::GetActiveChild(nsIDOMElement** aResult)
    1: {
 3129:   if (!mPopupFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
 3129:   nsMenuFrame* menuFrame = mPopupFrame->GetCurrentMenuItem();
    1:   if (!menuFrame) {
    1:     *aResult = nsnull;
    1:   }
    1:   else {
 3129:     nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(menuFrame->GetContent()));
    1:     *aResult = elt;
    1:     NS_IF_ADDREF(*aResult);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsMenuFrame::SetActiveChild(nsIDOMElement* aChild)
    1: {
 3129:   if (!mPopupFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!aChild) {
    1:     // Remove the current selection
 3129:     mPopupFrame->ChangeMenuItem(nsnull, PR_FALSE);
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> child(do_QueryInterface(aChild));
    1: 
36656:   nsIFrame* kid = child->GetPrimaryFrame();
 3129:   if (kid && kid->GetType() == nsGkAtoms::menuFrame)
 3233:     mPopupFrame->ChangeMenuItem(static_cast<nsMenuFrame *>(kid), PR_FALSE);
    1:   return NS_OK;
    1: }
    1: 
37056: nsIScrollableFrame* nsMenuFrame::GetScrollTargetFrame()
37056: {
37056:   if (!mPopupFrame)
37056:     return nsnull;
37056:   nsIFrame* childFrame = mPopupFrame->GetFirstChild(nsnull);
37056:   if (childFrame)
37056:     return mPopupFrame->GetScrollFrame(childFrame);
37056:   return nsnull;
37056: }
37056: 
    1: // nsMenuTimerMediator implementation.
    1: NS_IMPL_ISUPPORTS1(nsMenuTimerMediator, nsITimerCallback)
    1: 
    1: /**
    1:  * Constructs a wrapper around an nsMenuFrame.
    1:  * @param aFrame nsMenuFrame to create a wrapper around.
    1:  */
    1: nsMenuTimerMediator::nsMenuTimerMediator(nsMenuFrame *aFrame) :
    1:   mFrame(aFrame)
    1: {
    1:   NS_ASSERTION(mFrame, "Must have frame");
    1: }
    1: 
    1: nsMenuTimerMediator::~nsMenuTimerMediator()
    1: {
    1: }
    1: 
    1: /**
    1:  * Delegates the notification to the contained frame if it has not been destroyed.
    1:  * @param aTimer Timer which initiated the callback.
    1:  * @return NS_ERROR_FAILURE if the frame has been destroyed.
    1:  */
    1: NS_IMETHODIMP nsMenuTimerMediator::Notify(nsITimer* aTimer)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->Notify(aTimer);
    1: }
    1: 
    1: /**
    1:  * Clear the pointer to the contained nsMenuFrame. This should be called
    1:  * when the contained nsMenuFrame is destroyed.
    1:  */
    1: void nsMenuTimerMediator::ClearFrame()
    1: {
    1:   mFrame = nsnull;
    1: }
