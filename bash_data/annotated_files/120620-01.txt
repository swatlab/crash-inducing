110507: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
110507: /* vim:set expandtab ts=4 sw=4 sts=4 cin: */
110507: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 43113: #include "nspr.h"
105983: #include "private/pprio.h"
 43113: #include "nsString.h"
 43113: #include "nsCRT.h"
 43113: 
 43113: #include "nsIServiceManager.h"
 43113: #include "nsIDNSService.h"
 43113: #include "nsIDNSRecord.h"
 43113: #include "nsISOCKSSocketInfo.h"
 43113: #include "nsISocketProvider.h"
 43113: #include "nsSOCKSIOLayer.h"
 43113: #include "nsNetCID.h"
103193: #include "nsIDNSListener.h"
103193: #include "nsICancelable.h"
103193: #include "nsThreadUtils.h"
 43113: 
 43113: static PRDescIdentity	nsSOCKSIOLayerIdentity;
 43113: static PRIOMethods	nsSOCKSIOLayerMethods;
 79445: static bool firstTime = true;
105983: static bool ipv6Supported = true;
 43113: 
 43113: #if defined(PR_LOGGING)
 43113: static PRLogModuleInfo *gSOCKSLog;
 43113: #define LOGDEBUG(args) PR_LOG(gSOCKSLog, PR_LOG_DEBUG, args)
 43113: #define LOGERROR(args) PR_LOG(gSOCKSLog, PR_LOG_ERROR , args)
 43113: 
 43113: #else
 43113: #define LOGDEBUG(args)
 43113: #define LOGERROR(args)
 43113: #endif
 43113: 
 43113: class nsSOCKSSocketInfo : public nsISOCKSSocketInfo
103193:                         , public nsIDNSListener
 43113: {
 64493:     enum State {
 64493:         SOCKS_INITIAL,
103193:         SOCKS_DNS_IN_PROGRESS,
103193:         SOCKS_DNS_COMPLETE,
 64493:         SOCKS_CONNECTING_TO_PROXY,
 64493:         SOCKS4_WRITE_CONNECT_REQUEST,
 64493:         SOCKS4_READ_CONNECT_RESPONSE,
 64493:         SOCKS5_WRITE_AUTH_REQUEST,
 64493:         SOCKS5_READ_AUTH_RESPONSE,
 64493:         SOCKS5_WRITE_CONNECT_REQUEST,
 64493:         SOCKS5_READ_CONNECT_RESPONSE_TOP,
 64493:         SOCKS5_READ_CONNECT_RESPONSE_BOTTOM,
 64493:         SOCKS_CONNECTED,
 64493:         SOCKS_FAILED
 64493:     };
 64493: 
 64493:     // A buffer of 262 bytes should be enough for any request and response
 64493:     // in case of SOCKS4 as well as SOCKS5
108991:     static const uint32_t BUFFER_SIZE = 262;
108991:     static const uint32_t MAX_HOSTNAME_LEN = 255;
 64493: 
 43113: public:
 43113:     nsSOCKSSocketInfo();
 64493:     virtual ~nsSOCKSSocketInfo() { HandshakeFinished(); }
 43113: 
 43113:     NS_DECL_ISUPPORTS
 43113:     NS_DECL_NSISOCKSSOCKETINFO
103193:     NS_DECL_NSIDNSLISTENER
 43113: 
108991:     void Init(int32_t version,
108991:               int32_t family,
 43113:               const char *proxyHost,
108991:               int32_t proxyPort,
 43113:               const char *destinationHost,
108991:               uint32_t flags);
 43113: 
 64493:     void SetConnectTimeout(PRIntervalTime to);
108991:     PRStatus DoHandshake(PRFileDesc *fd, int16_t oflags = -1);
108991:     int16_t GetPollFlags() const;
 64493:     bool IsConnected() const { return mState == SOCKS_CONNECTED; }
120620:     void ForgetFD() { mFD = nullptr; }
 43113: 
 43113: private:
 64493:     void HandshakeFinished(PRErrorCode err = 0);
103193:     PRStatus StartDNS(PRFileDesc *fd);
 64493:     PRStatus ConnectToProxy(PRFileDesc *fd);
105983:     void FixupAddressFamily(PRFileDesc *fd, PRNetAddr *proxy);
108991:     PRStatus ContinueConnectingToProxy(PRFileDesc *fd, int16_t oflags);
 64493:     PRStatus WriteV4ConnectRequest();
 64493:     PRStatus ReadV4ConnectResponse();
 64493:     PRStatus WriteV5AuthRequest();
 64493:     PRStatus ReadV5AuthResponse();
 64493:     PRStatus WriteV5ConnectRequest();
108991:     PRStatus ReadV5AddrTypeAndLength(uint8_t *type, uint32_t *len);
 64493:     PRStatus ReadV5ConnectResponseTop();
 64493:     PRStatus ReadV5ConnectResponseBottom();
 64493: 
108991:     void WriteUint8(uint8_t d);
108991:     void WriteUint16(uint16_t d);
108991:     void WriteUint32(uint32_t d);
 64493:     void WriteNetAddr(const PRNetAddr *addr);
 64493:     void WriteNetPort(const PRNetAddr *addr);
 64493:     void WriteString(const nsACString &str);
 64493: 
108991:     uint8_t ReadUint8();
108991:     uint16_t ReadUint16();
108991:     uint32_t ReadUint32();
108991:     void ReadNetAddr(PRNetAddr *addr, uint16_t fam);
 64493:     void ReadNetPort(PRNetAddr *addr);
 64493: 
108991:     void WantRead(uint32_t sz);
 64493:     PRStatus ReadFromSocket(PRFileDesc *fd);
 64493:     PRStatus WriteToSocket(PRFileDesc *fd);
 64493: 
 64493: private:
 64493:     State     mState;
108991:     uint8_t * mData;
108991:     uint8_t * mDataIoPtr;
108991:     uint32_t  mDataLength;
108991:     uint32_t  mReadOffset;
108991:     uint32_t  mAmountToRead;
 64493:     nsCOMPtr<nsIDNSRecord>  mDnsRec;
103193:     nsCOMPtr<nsICancelable> mLookup;
103193:     nsresult                mLookupStatus;
103193:     PRFileDesc             *mFD;
 64493: 
 43113:     nsCString mDestinationHost;
 43113:     nsCString mProxyHost;
108991:     int32_t   mProxyPort;
108991:     int32_t   mVersion;   // SOCKS version 4 or 5
108991:     int32_t   mDestinationFamily;
108991:     uint32_t  mFlags;
 43113:     PRNetAddr mInternalProxyAddr;
 43113:     PRNetAddr mExternalProxyAddr;
 43113:     PRNetAddr mDestinationAddr;
 64493:     PRIntervalTime mTimeout;
 43113: };
 43113: 
 43113: nsSOCKSSocketInfo::nsSOCKSSocketInfo()
 64493:     : mState(SOCKS_INITIAL)
106838:     , mDataIoPtr(nullptr)
 64493:     , mDataLength(0)
 64493:     , mReadOffset(0)
 64493:     , mAmountToRead(0)
 64493:     , mProxyPort(-1)
 43113:     , mVersion(-1)
105983:     , mDestinationFamily(PR_AF_INET)
 43113:     , mFlags(0)
 64493:     , mTimeout(PR_INTERVAL_NO_TIMEOUT)
 43113: {
108991:     mData = new uint8_t[BUFFER_SIZE];
 43113:     PR_InitializeNetAddr(PR_IpAddrAny, 0, &mInternalProxyAddr);
 43113:     PR_InitializeNetAddr(PR_IpAddrAny, 0, &mExternalProxyAddr);
 43113:     PR_InitializeNetAddr(PR_IpAddrAny, 0, &mDestinationAddr);
 43113: }
 43113: 
 43113: void
108991: nsSOCKSSocketInfo::Init(int32_t version, int32_t family, const char *proxyHost, int32_t proxyPort, const char *host, uint32_t flags)
 43113: {
 43113:     mVersion         = version;
105983:     mDestinationFamily = family;
 43113:     mProxyHost       = proxyHost;
 43113:     mProxyPort       = proxyPort;
 43113:     mDestinationHost = host;
 43113:     mFlags           = flags;
 43113: }
 43113: 
103193: NS_IMPL_THREADSAFE_ISUPPORTS2(nsSOCKSSocketInfo, nsISOCKSSocketInfo, nsIDNSListener)
 43113: 
 43113: NS_IMETHODIMP 
 43113: nsSOCKSSocketInfo::GetExternalProxyAddr(PRNetAddr * *aExternalProxyAddr)
 43113: {
 43113:     memcpy(*aExternalProxyAddr, &mExternalProxyAddr, sizeof(PRNetAddr));
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP 
 43113: nsSOCKSSocketInfo::SetExternalProxyAddr(PRNetAddr *aExternalProxyAddr)
 43113: {
 43113:     memcpy(&mExternalProxyAddr, aExternalProxyAddr, sizeof(PRNetAddr));
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP 
 43113: nsSOCKSSocketInfo::GetDestinationAddr(PRNetAddr * *aDestinationAddr)
 43113: {
 43113:     memcpy(*aDestinationAddr, &mDestinationAddr, sizeof(PRNetAddr));
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP 
 43113: nsSOCKSSocketInfo::SetDestinationAddr(PRNetAddr *aDestinationAddr)
 43113: {
 43113:     memcpy(&mDestinationAddr, aDestinationAddr, sizeof(PRNetAddr));
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP 
 43113: nsSOCKSSocketInfo::GetInternalProxyAddr(PRNetAddr * *aInternalProxyAddr)
 43113: {
 43113:     memcpy(*aInternalProxyAddr, &mInternalProxyAddr, sizeof(PRNetAddr));
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP 
 43113: nsSOCKSSocketInfo::SetInternalProxyAddr(PRNetAddr *aInternalProxyAddr)
 43113: {
 43113:     memcpy(&mInternalProxyAddr, aInternalProxyAddr, sizeof(PRNetAddr));
 43113:     return NS_OK;
 43113: }
 43113: 
 64493: // There needs to be a means of distinguishing between connection errors
 64493: // that the SOCKS server reports when it rejects a connection request, and
 64493: // connection errors that happen while attempting to connect to the SOCKS
 64493: // server. Otherwise, Firefox will report incorrectly that the proxy server
 64493: // is refusing connections when a SOCKS request is rejected by the proxy.
 64493: // When a SOCKS handshake failure occurs, the PR error is set to
 64493: // PR_UNKNOWN_ERROR, and the real error code is returned via the OS error.
 64493: void
 64493: nsSOCKSSocketInfo::HandshakeFinished(PRErrorCode err)
 43113: {
 64493:     if (err == 0) {
 64493:         mState = SOCKS_CONNECTED;
 43113:     } else {
 64493:         mState = SOCKS_FAILED;
 64493:         PR_SetError(PR_UNKNOWN_ERROR, err);
 43113:     }
 43113: 
 64493:     // We don't need the buffer any longer, so free it.
 64493:     delete [] mData;
106838:     mData = nullptr;
106838:     mDataIoPtr = nullptr;
 64493:     mDataLength = 0;
 64493:     mReadOffset = 0;
 64493:     mAmountToRead = 0;
103193:     if (mLookup) {
103193:         mLookup->Cancel(NS_ERROR_FAILURE);
106838:         mLookup = nullptr;
103193:     }
103193: }
103193: 
103193: PRStatus
103193: nsSOCKSSocketInfo::StartDNS(PRFileDesc *fd)
103193: {
103193:     NS_ABORT_IF_FALSE(!mDnsRec && mState == SOCKS_INITIAL,
103193:                       "Must be in initial state to make DNS Lookup");
103193: 
103193:     nsCOMPtr<nsIDNSService> dns = do_GetService(NS_DNSSERVICE_CONTRACTID);
103193:     if (!dns)
103193:         return PR_FAILURE;
103193: 
103193:     mFD  = fd;
103193:     nsresult rv = dns->AsyncResolve(mProxyHost, 0, this,
103193:                                     NS_GetCurrentThread(),
103193:                                     getter_AddRefs(mLookup));
103193: 
103193:     if (NS_FAILED(rv)) {
103193:         LOGERROR(("socks: DNS lookup for SOCKS proxy %s failed",
103193:                   mProxyHost.get()));
103193:         return PR_FAILURE;
103193:     }
103193:     mState = SOCKS_DNS_IN_PROGRESS;
103193:     PR_SetError(PR_IN_PROGRESS_ERROR, 0);
103193:     return PR_FAILURE;
103193: }
103193: 
103193: NS_IMETHODIMP
103193: nsSOCKSSocketInfo::OnLookupComplete(nsICancelable *aRequest,
103193:                                     nsIDNSRecord *aRecord,
103193:                                     nsresult aStatus)
103193: {
103193:     NS_ABORT_IF_FALSE(aRequest == mLookup, "wrong DNS query");
106838:     mLookup = nullptr;
103193:     mLookupStatus = aStatus;
103193:     mDnsRec = aRecord;
103193:     mState = SOCKS_DNS_COMPLETE;
120620:     if (mFD) {
103193:       ConnectToProxy(mFD);
120620:       ForgetFD();
120620:     }
103193:     return NS_OK;
 43113: }
 43113: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::ConnectToProxy(PRFileDesc *fd)
 64493: {
 64493:     PRStatus status;
 64493:     nsresult rv;
 64493: 
103193:     NS_ABORT_IF_FALSE(mState == SOCKS_DNS_COMPLETE,
103193:                       "Must have DNS to make connection!");
 64493: 
103193:     if (NS_FAILED(mLookupStatus)) {
103193:         PR_SetError(PR_BAD_ADDRESS_ERROR, 0);
 64493:         return PR_FAILURE;
 43113:     }
 43113: 
105983:     // Try socks5 if the destination addrress is IPv6
105983:     if (mVersion == 4 &&
105983:         PR_NetAddrFamily(&mDestinationAddr) == PR_AF_INET6) {
105983:         mVersion = 5;
105983:     }
105983: 
108991:     int32_t addresses = 0;
 64493:     do {
 74203:         if (addresses++)
 74203:             mDnsRec->ReportUnusable(mProxyPort);
 74203:         
 64493:         rv = mDnsRec->GetNextAddr(mProxyPort, &mInternalProxyAddr);
 64493:         // No more addresses to try? If so, we'll need to bail
 64493:         if (NS_FAILED(rv)) {
 64493:             LOGERROR(("socks: unable to connect to SOCKS proxy, %s",
 64493:                      mProxyHost.get()));
 64493:             return PR_FAILURE;
 43113:         }
 43113: 
 64493: #if defined(PR_LOGGING)
 64493:         char buf[64];
 64493:         PR_NetAddrToString(&mInternalProxyAddr, buf, sizeof(buf));
 64493:         LOGDEBUG(("socks: trying proxy server, %s:%hu",
 64493:                  buf, PR_ntohs(PR_NetAddrInetPort(&mInternalProxyAddr))));
 64493: #endif
105983:         PRNetAddr proxy = mInternalProxyAddr;
105983:         FixupAddressFamily(fd, &proxy);
105983:         status = fd->lower->methods->connect(fd->lower, &proxy, mTimeout);
 64493:         if (status != PR_SUCCESS) {
 64493:             PRErrorCode c = PR_GetError();
 64493:             // If EINPROGRESS, return now and check back later after polling
 64493:             if (c == PR_WOULD_BLOCK_ERROR || c == PR_IN_PROGRESS_ERROR) {
 64493:                 mState = SOCKS_CONNECTING_TO_PROXY;
 64493:                 return status;
 64493:             }
 64493:         }
 64493:     } while (status != PR_SUCCESS);
 64493: 
 64493:     // Connected now, start SOCKS
 64493:     if (mVersion == 4)
 64493:         return WriteV4ConnectRequest();
 64493:     return WriteV5AuthRequest();
 43113: }
 43113: 
105983: void
105983: nsSOCKSSocketInfo::FixupAddressFamily(PRFileDesc *fd, PRNetAddr *proxy)
105983: {
108991:     int32_t proxyFamily = PR_NetAddrFamily(&mInternalProxyAddr);
105983:     // Do nothing if the address family is already matched
105983:     if (proxyFamily == mDestinationFamily) {
105983:         return;
105983:     }
105983:     // If the system does not support IPv6 and the proxy address is IPv6,
105983:     // We can do nothing here.
105983:     if (proxyFamily == PR_AF_INET6 && !ipv6Supported) {
105983:         return;
105983:     }
105983:     // If the system does not support IPv6 and the destination address is
105983:     // IPv6, convert IPv4 address to IPv4-mapped IPv6 address to satisfy
105983:     // the emulation layer
105983:     if (mDestinationFamily == PR_AF_INET6 && !ipv6Supported) {
105983:         proxy->ipv6.family = PR_AF_INET6;
105983:         proxy->ipv6.port = mInternalProxyAddr.inet.port;
108991:         uint8_t *proxyp = proxy->ipv6.ip.pr_s6_addr;
105983:         memset(proxyp, 0, 10);
105983:         memset(proxyp + 10, 0xff, 2);
105983:         memcpy(proxyp + 12,(char *) &mInternalProxyAddr.inet.ip, 4);
105983:         // mDestinationFamily should not be updated
105983:         return;
105983:     }
105983:     // Get an OS native handle from a specified FileDesc
105983:     PROsfd osfd = PR_FileDesc2NativeHandle(fd);
105983:     if (osfd == -1) {
105983:         return;
105983:     }
105983:     // Create a new FileDesc with a specified family
105983:     PRFileDesc *tmpfd = PR_OpenTCPSocket(proxyFamily);
105983:     if (!tmpfd) {
105983:         return;
105983:     }
105983:     PROsfd newsd = PR_FileDesc2NativeHandle(tmpfd);
105983:     if (newsd == -1) {
105983:         PR_Close(tmpfd);
105983:         return;
105983:     }
105983:     // Must succeed because PR_FileDesc2NativeHandle succeeded
105983:     fd = PR_GetIdentitiesLayer(fd, PR_NSPR_IO_LAYER);
105983:     MOZ_ASSERT(fd);
105983:     // Swap OS native handles
105983:     PR_ChangeFileDescNativeHandle(fd, newsd);
105983:     PR_ChangeFileDescNativeHandle(tmpfd, osfd);
105983:     // Close temporary FileDesc which is now associated with
105983:     // old OS native handle
105983:     PR_Close(tmpfd);
105983:     mDestinationFamily = proxyFamily;
105983: }
105983: 
 64493: PRStatus
108991: nsSOCKSSocketInfo::ContinueConnectingToProxy(PRFileDesc *fd, int16_t oflags)
 64493: {
 64493:     PRStatus status;
 64493: 
 64493:     NS_ABORT_IF_FALSE(mState == SOCKS_CONNECTING_TO_PROXY,
 64493:                       "Continuing connection in wrong state!");
 64493: 
 64493:     LOGDEBUG(("socks: continuing connection to proxy"));
 64493: 
 64493:     status = fd->lower->methods->connectcontinue(fd->lower, oflags);
 64493:     if (status != PR_SUCCESS) {
 64493:         PRErrorCode c = PR_GetError();
 64493:         if (c != PR_WOULD_BLOCK_ERROR && c != PR_IN_PROGRESS_ERROR) {
 64493:             // A connection failure occured, try another address
103193:             mState = SOCKS_DNS_COMPLETE;
 64493:             return ConnectToProxy(fd);
 43113:         }
 43113: 
 64493:         // We're still connecting
 64493:         return PR_FAILURE;
 43113:     }
 43113: 
 64493:     // Connected now, start SOCKS
 64493:     if (mVersion == 4)
 64493:         return WriteV4ConnectRequest();
 64493:     return WriteV5AuthRequest();
 43113: }
 43113: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::WriteV4ConnectRequest()
 64493: {
 64493:     PRNetAddr *addr = &mDestinationAddr;
108991:     int32_t proxy_resolve;
 64493: 
 64493:     NS_ABORT_IF_FALSE(mState == SOCKS_CONNECTING_TO_PROXY,
 64493:                       "Invalid state!");
 64493:     
 64493:     proxy_resolve = mFlags & nsISocketProvider::PROXY_RESOLVES_HOST;
 64493: 
 64493:     mDataLength = 0;
 64493:     mState = SOCKS4_WRITE_CONNECT_REQUEST;
 64493: 
 64493:     LOGDEBUG(("socks4: sending connection request (socks4a resolve? %s)",
 64493:              proxy_resolve? "yes" : "no"));
 64493: 
 64493:     // Send a SOCKS 4 connect request.
 64493:     WriteUint8(0x04); // version -- 4
 64493:     WriteUint8(0x01); // command -- connect
 64493:     WriteNetPort(addr);
 64493:     if (proxy_resolve) {
 64493:         // Add the full name, null-terminated, to the request
 64493:         // according to SOCKS 4a. A fake IP address, with the first
 64493:         // four bytes set to 0 and the last byte set to something other
 64493:         // than 0, is used to notify the proxy that this is a SOCKS 4a
 64493:         // request. This request type works for Tor and perhaps others.
 64493:         WriteUint32(PR_htonl(0x00000001)); // Fake IP
 64493:         WriteUint8(0x00); // Send an emtpy username
 64493:         if (mDestinationHost.Length() > MAX_HOSTNAME_LEN) {
 64493:             LOGERROR(("socks4: destination host name is too long!"));
 64493:             HandshakeFinished(PR_BAD_ADDRESS_ERROR);
 64493:             return PR_FAILURE;
 43113:         }
 64493:         WriteString(mDestinationHost); // Hostname
 64493:         WriteUint8(0x00);
 64493:     } else if (PR_NetAddrFamily(addr) == PR_AF_INET) {
 64493:         WriteNetAddr(addr); // Add the IPv4 address
 64493:         WriteUint8(0x00); // Send an emtpy username
 64493:     } else if (PR_NetAddrFamily(addr) == PR_AF_INET6) {
 64493:         LOGERROR(("socks: SOCKS 4 can't handle IPv6 addresses!"));
 64493:         HandshakeFinished(PR_BAD_ADDRESS_ERROR);
 64493:         return PR_FAILURE;
 43113:     }
 43113: 
 64493:     return PR_SUCCESS;
 43113: }
 43113: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::ReadV4ConnectResponse()
 64493: {
 64493:     NS_ABORT_IF_FALSE(mState == SOCKS4_READ_CONNECT_RESPONSE,
 64493:                       "Handling SOCKS 4 connection reply in wrong state!");
 64493:     NS_ABORT_IF_FALSE(mDataLength == 8,
 64493:                       "SOCKS 4 connection reply must be 8 bytes!");
 64493: 
 64493:     LOGDEBUG(("socks4: checking connection reply"));
 64493: 
 64493:     if (ReadUint8() != 0x00) {
 64493:         LOGERROR(("socks4: wrong connection reply"));
 64493:         HandshakeFinished(PR_CONNECT_REFUSED_ERROR);
 64493:         return PR_FAILURE;
 43113:     }
 43113: 
 64493:     // See if our connection request was granted
 64493:     if (ReadUint8() == 90) {
 64493:         LOGDEBUG(("socks4: connection successful!"));
 64493:         HandshakeFinished();
 64493:         return PR_SUCCESS;
 43113:     }
 43113: 
 64493:     LOGERROR(("socks4: unable to connect"));
 64493:     HandshakeFinished(PR_CONNECT_REFUSED_ERROR);
 64493:     return PR_FAILURE;
 43113: }
 43113: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::WriteV5AuthRequest()
 64493: {
 64493:     NS_ABORT_IF_FALSE(mVersion == 5, "SOCKS version must be 5!");
 64493: 
 64493:     mState = SOCKS5_WRITE_AUTH_REQUEST;
 64493: 
 64493:     // Send an initial SOCKS 5 greeting
 64493:     LOGDEBUG(("socks5: sending auth methods"));
 64493:     WriteUint8(0x05); // version -- 5
 64493:     WriteUint8(0x01); // # auth methods -- 1
 64493:     WriteUint8(0x00); // we don't support authentication
 64493: 
 64493:     return PR_SUCCESS;
 43113: }
 43113: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::ReadV5AuthResponse()
 64493: {
 64493:     NS_ABORT_IF_FALSE(mState == SOCKS5_READ_AUTH_RESPONSE,
 64493:                       "Handling SOCKS 5 auth method reply in wrong state!");
 64493:     NS_ABORT_IF_FALSE(mDataLength == 2,
 64493:                       "SOCKS 5 auth method reply must be 2 bytes!");
 64493: 
 64493:     LOGDEBUG(("socks5: checking auth method reply"));
 64493: 
 64493:     // Check version number
 64493:     if (ReadUint8() != 0x05) {
 64493:         LOGERROR(("socks5: unexpected version in the reply"));
 64493:         HandshakeFinished(PR_CONNECT_REFUSED_ERROR);
 64493:         return PR_FAILURE;
 43113:     }
 43113: 
 64493:     // Make sure our authentication choice was accepted
 64493:     if (ReadUint8() != 0x00) {
 64493:         LOGERROR(("socks5: server did not accept our authentication method"));
 64493:         HandshakeFinished(PR_CONNECT_REFUSED_ERROR);
 64493:         return PR_FAILURE;
 43113:     }
 43113: 
 64493:     return WriteV5ConnectRequest();
 64493: }
 64493: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::WriteV5ConnectRequest()
 64493: {
 64493:     // Send SOCKS 5 connect request
 64493:     PRNetAddr *addr = &mDestinationAddr;
108991:     int32_t proxy_resolve;
 64493:     proxy_resolve = mFlags & nsISocketProvider::PROXY_RESOLVES_HOST;
 64493: 
 64493:     LOGDEBUG(("socks5: sending connection request (socks5 resolve? %s)",
 64493:              proxy_resolve? "yes" : "no"));
 64493: 
 64493:     mDataLength = 0;
 64493:     mState = SOCKS5_WRITE_CONNECT_REQUEST;
 64493: 
 64493:     WriteUint8(0x05); // version -- 5
 64493:     WriteUint8(0x01); // command -- connect
 64493:     WriteUint8(0x00); // reserved
 64493:    
 64493:     // Add the address to the SOCKS 5 request. SOCKS 5 supports several
 64493:     // address types, so we pick the one that works best for us.
 64493:     if (proxy_resolve) {
 64493:         // Add the host name. Only a single byte is used to store the length,
 64493:         // so we must prevent long names from being used.
 64493:         if (mDestinationHost.Length() > MAX_HOSTNAME_LEN) {
 64493:             LOGERROR(("socks5: destination host name is too long!"));
 64493:             HandshakeFinished(PR_BAD_ADDRESS_ERROR);
 64493:             return PR_FAILURE;
 64493:         }
 64493:         WriteUint8(0x03); // addr type -- domainname
 64493:         WriteUint8(mDestinationHost.Length()); // name length
 64493:         WriteString(mDestinationHost);
 64493:     } else if (PR_NetAddrFamily(addr) == PR_AF_INET) {
 64493:         WriteUint8(0x01); // addr type -- IPv4
 64493:         WriteNetAddr(addr);
 64493:     } else if (PR_NetAddrFamily(addr) == PR_AF_INET6) {
 64493:         WriteUint8(0x04); // addr type -- IPv6
 64493:         WriteNetAddr(addr);
 64493:     } else {
 64493:         LOGERROR(("socks5: destination address of unknown type!"));
 64493:         HandshakeFinished(PR_BAD_ADDRESS_ERROR);
 64493:         return PR_FAILURE;
 64493:     }
 64493: 
 64493:     WriteNetPort(addr); // port
 64493: 
 64493:     return PR_SUCCESS;
 64493: }
 64493: 
 64493: PRStatus
108991: nsSOCKSSocketInfo::ReadV5AddrTypeAndLength(uint8_t *type, uint32_t *len)
 64493: {
 64493:     NS_ABORT_IF_FALSE(mState == SOCKS5_READ_CONNECT_RESPONSE_TOP ||
 64493:                       mState == SOCKS5_READ_CONNECT_RESPONSE_BOTTOM,
 64493:                       "Invalid state!");
 64493:     NS_ABORT_IF_FALSE(mDataLength >= 5,
 64493:                       "SOCKS 5 connection reply must be at least 5 bytes!");
 64493:  
 64493:     // Seek to the address location 
 64493:     mReadOffset = 3;
 64493:    
 64493:     *type = ReadUint8();
 64493: 
 64493:     switch (*type) {
 64493:         case 0x01: // ipv4
 64493:             *len = 4 - 1;
 63804:             break;
 64493:         case 0x04: // ipv6
 64493:             *len = 16 - 1;
 63804:             break;
 64493:         case 0x03: // fqdn
 64493:             *len = ReadUint8();
 63804:             break;
 64493:         default:   // wrong address type
 64493:             LOGERROR(("socks5: wrong address type in connection reply!"));
 64493:             return PR_FAILURE;
 64493:     }
 64493: 
 64493:     return PR_SUCCESS;
 64493: }
 64493: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::ReadV5ConnectResponseTop()
 64493: {
108991:     uint8_t res;
108991:     uint32_t len;
 64493: 
 64493:     NS_ABORT_IF_FALSE(mState == SOCKS5_READ_CONNECT_RESPONSE_TOP,
 64493:                       "Invalid state!");
 64493:     NS_ABORT_IF_FALSE(mDataLength == 5,
 64493:                       "SOCKS 5 connection reply must be exactly 5 bytes!");
 64493: 
 64493:     LOGDEBUG(("socks5: checking connection reply"));
 64493: 
 64493:     // Check version number
 64493:     if (ReadUint8() != 0x05) {
 64493:         LOGERROR(("socks5: unexpected version in the reply"));
 64493:         HandshakeFinished(PR_CONNECT_REFUSED_ERROR);
 64493:         return PR_FAILURE;
 64493:     }
 64493: 
 64493:     // Check response
 64493:     res = ReadUint8();
 64493:     if (res != 0x00) {
 64493:         PRErrorCode c = PR_CONNECT_REFUSED_ERROR;
 64493: 
 64493:         switch (res) {
 64493:             case 0x01:
 64493:                 LOGERROR(("socks5: connect failed: "
 64493:                           "01, General SOCKS server failure."));
 64493:                 break;
 64493:             case 0x02:
 64493:                 LOGERROR(("socks5: connect failed: "
 64493:                           "02, Connection not allowed by ruleset."));
 64493:                 break;
 64493:             case 0x03:
 64493:                 LOGERROR(("socks5: connect failed: 03, Network unreachable."));
 64493:                 c = PR_NETWORK_UNREACHABLE_ERROR;
 64493:                 break;
 64493:             case 0x04:
 64493:                 LOGERROR(("socks5: connect failed: 04, Host unreachable."));
 64493:                 break;
 64493:             case 0x05:
 64493:                 LOGERROR(("socks5: connect failed: 05, Connection refused."));
 64493:                 break;
 64493:             case 0x06:  
 64493:                 LOGERROR(("socks5: connect failed: 06, TTL expired."));
 64493:                 c = PR_CONNECT_TIMEOUT_ERROR;
 64493:                 break;
 64493:             case 0x07:
 64493:                 LOGERROR(("socks5: connect failed: "
 64493:                           "07, Command not supported."));
 64493:                 break;
 64493:             case 0x08:
 64493:                 LOGERROR(("socks5: connect failed: "
 64493:                           "08, Address type not supported."));
 64493:                 c = PR_BAD_ADDRESS_ERROR;
 64493:                 break;
 64493:             default:
 64493:                 LOGERROR(("socks5: connect failed."));
 63804:                 break;
 63804:         }
 64493: 
 64493:         HandshakeFinished(c);
 64493:         return PR_FAILURE;
 63804:     }
 63804: 
 64493:     if (ReadV5AddrTypeAndLength(&res, &len) != PR_SUCCESS) {
 64493:         HandshakeFinished(PR_BAD_ADDRESS_ERROR);
 64493:         return PR_FAILURE;
 64493:     }
 63804: 
 64493:     mState = SOCKS5_READ_CONNECT_RESPONSE_BOTTOM;
 64493:     WantRead(len + 2);
 63804: 
 64493:     return PR_SUCCESS;
 64493: }
 63804: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::ReadV5ConnectResponseBottom()
 64493: {
108991:     uint8_t type;
108991:     uint32_t len;
 63804: 
 64493:     NS_ABORT_IF_FALSE(mState == SOCKS5_READ_CONNECT_RESPONSE_BOTTOM,
 64493:                       "Invalid state!");
 63804: 
 64493:     if (ReadV5AddrTypeAndLength(&type, &len) != PR_SUCCESS) {
 64493:         HandshakeFinished(PR_BAD_ADDRESS_ERROR);
 64493:         return PR_FAILURE;
 64493:     }
 64493: 
 64493:     NS_ABORT_IF_FALSE(mDataLength == 7+len,
 64493:                       "SOCKS 5 unexpected length of connection reply!");
 64493: 
 64493:     LOGDEBUG(("socks5: loading source addr and port"));
 64493:     // Read what the proxy says is our source address
 64493:     switch (type) {
 64493:         case 0x01: // ipv4
 64493:             ReadNetAddr(&mExternalProxyAddr, PR_AF_INET);
 63804:             break;
 64493:         case 0x04: // ipv6
 64493:             ReadNetAddr(&mExternalProxyAddr, PR_AF_INET6);
 63804:             break;
 64493:         case 0x03: // fqdn (skip)
 64493:             mReadOffset += len;
 64493:             mExternalProxyAddr.raw.family = PR_AF_INET;
 63804:             break;
 63804:     }
 64493: 
 64493:     ReadNetPort(&mExternalProxyAddr);
 64493: 
 64493:     LOGDEBUG(("socks5: connected!"));
 64493:     HandshakeFinished();
 64493: 
 64493:     return PR_SUCCESS;
 63796: }
 63796: 
 64493: void
 64493: nsSOCKSSocketInfo::SetConnectTimeout(PRIntervalTime to)
 63796: {
 64493:     mTimeout = to;
 64493: }
 63796: 
 64493: PRStatus
108991: nsSOCKSSocketInfo::DoHandshake(PRFileDesc *fd, int16_t oflags)
 64493: {
 64493:     LOGDEBUG(("socks: DoHandshake(), state = %d", mState));
 63796: 
 64493:     switch (mState) {
 64493:         case SOCKS_INITIAL:
103193:             return StartDNS(fd);
103193:         case SOCKS_DNS_IN_PROGRESS:
103193:             PR_SetError(PR_IN_PROGRESS_ERROR, 0);
103193:             return PR_FAILURE;
103193:         case SOCKS_DNS_COMPLETE:
 64493:             return ConnectToProxy(fd);
 64493:         case SOCKS_CONNECTING_TO_PROXY:
 64493:             return ContinueConnectingToProxy(fd, oflags);
 64493:         case SOCKS4_WRITE_CONNECT_REQUEST:
 64493:             if (WriteToSocket(fd) != PR_SUCCESS)
 64493:                 return PR_FAILURE;
 64493:             WantRead(8);
 64493:             mState = SOCKS4_READ_CONNECT_RESPONSE;
 64493:             return PR_SUCCESS;
 64493:         case SOCKS4_READ_CONNECT_RESPONSE:
 64493:             if (ReadFromSocket(fd) != PR_SUCCESS)
 64493:                 return PR_FAILURE;
 64493:             return ReadV4ConnectResponse();
 63796: 
 64493:         case SOCKS5_WRITE_AUTH_REQUEST:
 64493:             if (WriteToSocket(fd) != PR_SUCCESS)
 64493:                 return PR_FAILURE;
 64493:             WantRead(2);
 64493:             mState = SOCKS5_READ_AUTH_RESPONSE;
 64493:             return PR_SUCCESS;
 64493:         case SOCKS5_READ_AUTH_RESPONSE:
 64493:             if (ReadFromSocket(fd) != PR_SUCCESS)
 64493:                 return PR_FAILURE;
 64493:             return ReadV5AuthResponse();
 64493:         case SOCKS5_WRITE_CONNECT_REQUEST:
 64493:             if (WriteToSocket(fd) != PR_SUCCESS)
 64493:                 return PR_FAILURE;
 63796: 
 64493:             // The SOCKS 5 response to the connection request is variable
 64493:             // length. First, we'll read enough to tell how long the response
 64493:             // is, and will read the rest later.
 64493:             WantRead(5);
 64493:             mState = SOCKS5_READ_CONNECT_RESPONSE_TOP;
 64493:             return PR_SUCCESS;
 64493:         case SOCKS5_READ_CONNECT_RESPONSE_TOP:
 64493:             if (ReadFromSocket(fd) != PR_SUCCESS)
 64493:                 return PR_FAILURE;
 64493:             return ReadV5ConnectResponseTop();
 64493:         case SOCKS5_READ_CONNECT_RESPONSE_BOTTOM:
 64493:             if (ReadFromSocket(fd) != PR_SUCCESS)
 64493:                 return PR_FAILURE;
 64493:             return ReadV5ConnectResponseBottom();
 63804: 
 64493:         case SOCKS_CONNECTED:
 64493:             LOGERROR(("socks: already connected"));
 64493:             HandshakeFinished(PR_IS_CONNECTED_ERROR);
 64493:             return PR_FAILURE;
 64493:         case SOCKS_FAILED:
 64493:             LOGERROR(("socks: already failed"));
 64493:             return PR_FAILURE;
 64493:     }
 63804: 
 64493:     LOGERROR(("socks: executing handshake in invalid state, %d", mState));
 64493:     HandshakeFinished(PR_INVALID_STATE_ERROR);
 63804: 
 64493:     return PR_FAILURE;
 64493: }
 64493: 
108991: int16_t
 64493: nsSOCKSSocketInfo::GetPollFlags() const
 64493: {
 64493:     switch (mState) {
103193:         case SOCKS_DNS_IN_PROGRESS:
103193:         case SOCKS_DNS_COMPLETE:
 64493:         case SOCKS_CONNECTING_TO_PROXY:
 64493:             return PR_POLL_EXCEPT | PR_POLL_WRITE;
 64493:         case SOCKS4_WRITE_CONNECT_REQUEST:
 64493:         case SOCKS5_WRITE_AUTH_REQUEST:
 64493:         case SOCKS5_WRITE_CONNECT_REQUEST:
 64493:             return PR_POLL_WRITE;
 64493:         case SOCKS4_READ_CONNECT_RESPONSE:
 64493:         case SOCKS5_READ_AUTH_RESPONSE:
 64493:         case SOCKS5_READ_CONNECT_RESPONSE_TOP:
 64493:         case SOCKS5_READ_CONNECT_RESPONSE_BOTTOM:
 64493:             return PR_POLL_READ;
 64493:         default:
 64493:             break;
 64493:     }
 64493: 
 64493:     return 0;
 64493: }
 64493: 
 64493: inline void
108991: nsSOCKSSocketInfo::WriteUint8(uint8_t v)
 64493: {
 64493:     NS_ABORT_IF_FALSE(mDataLength + sizeof(v) <= BUFFER_SIZE,
 64493:                       "Can't write that much data!");
 64493:     mData[mDataLength] = v;
 64493:     mDataLength += sizeof(v);
 64493: }
 64493: 
 64493: inline void
108991: nsSOCKSSocketInfo::WriteUint16(uint16_t v)
 64493: {
 64493:     NS_ABORT_IF_FALSE(mDataLength + sizeof(v) <= BUFFER_SIZE,
 64493:                       "Can't write that much data!");
 64493:     memcpy(mData + mDataLength, &v, sizeof(v));
 64493:     mDataLength += sizeof(v);
 64493: }
 64493: 
 64493: inline void
108991: nsSOCKSSocketInfo::WriteUint32(uint32_t v)
 64493: {
 64493:     NS_ABORT_IF_FALSE(mDataLength + sizeof(v) <= BUFFER_SIZE,
 64493:                       "Can't write that much data!");
 64493:     memcpy(mData + mDataLength, &v, sizeof(v));
 64493:     mDataLength += sizeof(v);
 64493: }
 64493: 
 64493: void
 64493: nsSOCKSSocketInfo::WriteNetAddr(const PRNetAddr *addr)
 64493: {
 64493:     const char *ip = NULL;
108991:     uint32_t len = 0;
 64493: 
 64493:     if (PR_NetAddrFamily(addr) == PR_AF_INET) {
 64493:         ip = (const char*)&addr->inet.ip;
 64493:         len = sizeof(addr->inet.ip);
 64493:     } else if (PR_NetAddrFamily(addr) == PR_AF_INET6) {
 64493:         ip = (const char*)addr->ipv6.ip.pr_s6_addr;
 64493:         len = sizeof(addr->ipv6.ip.pr_s6_addr);
 64493:     }
 64493: 
 64493:     NS_ABORT_IF_FALSE(ip != NULL, "Unknown address");
 64493:     NS_ABORT_IF_FALSE(mDataLength + len <= BUFFER_SIZE,
 64493:                       "Can't write that much data!");
 64493:  
 64493:     memcpy(mData + mDataLength, ip, len);
 64493:     mDataLength += len;
 64493: }
 64493: 
 64493: void
 64493: nsSOCKSSocketInfo::WriteNetPort(const PRNetAddr *addr)
 64493: {
 64493:     WriteUint16(PR_NetAddrInetPort(addr));
 64493: }
 64493: 
 64493: void
 64493: nsSOCKSSocketInfo::WriteString(const nsACString &str)
 64493: {
 64493:     NS_ABORT_IF_FALSE(mDataLength + str.Length() <= BUFFER_SIZE,
 64493:                       "Can't write that much data!");
 64493:     memcpy(mData + mDataLength, str.Data(), str.Length());
 64493:     mDataLength += str.Length();
 64493: }
 64493: 
108991: inline uint8_t
 64493: nsSOCKSSocketInfo::ReadUint8()
 64493: {
108991:     uint8_t rv;
 64493:     NS_ABORT_IF_FALSE(mReadOffset + sizeof(rv) <= mDataLength,
119362:                       "Not enough space to pop a uint8_t!");
 64493:     rv = mData[mReadOffset];
 64493:     mReadOffset += sizeof(rv);
 64493:     return rv;
 64493: }
 64493: 
108991: inline uint16_t
 64493: nsSOCKSSocketInfo::ReadUint16()
 64493: {
108991:     uint16_t rv;
 64493:     NS_ABORT_IF_FALSE(mReadOffset + sizeof(rv) <= mDataLength,
119362:                       "Not enough space to pop a uint16_t!");
 64493:     memcpy(&rv, mData + mReadOffset, sizeof(rv));
 64493:     mReadOffset += sizeof(rv);
 64493:     return rv;
 64493: }
 64493: 
108991: inline uint32_t
 64493: nsSOCKSSocketInfo::ReadUint32()
 64493: {
108991:     uint32_t rv;
 64493:     NS_ABORT_IF_FALSE(mReadOffset + sizeof(rv) <= mDataLength,
119362:                       "Not enough space to pop a uint32_t!");
 64493:     memcpy(&rv, mData + mReadOffset, sizeof(rv));
 64493:     mReadOffset += sizeof(rv);
 64493:     return rv;
 64493: }
 64493: 
 64493: void
108991: nsSOCKSSocketInfo::ReadNetAddr(PRNetAddr *addr, uint16_t fam)
 64493: {
110507:     uint32_t amt = 0;
108991:     const uint8_t *ip = mData + mReadOffset;
 64493: 
 64493:     addr->raw.family = fam;
 64493:     if (fam == PR_AF_INET) {
 64493:         amt = sizeof(addr->inet.ip);
 64493:         NS_ABORT_IF_FALSE(mReadOffset + amt <= mDataLength,
 64493:                           "Not enough space to pop an ipv4 addr!");
 64493:         memcpy(&addr->inet.ip, ip, amt);
 64493:     } else if (fam == PR_AF_INET6) {
 64493:         amt = sizeof(addr->ipv6.ip.pr_s6_addr);
 64493:         NS_ABORT_IF_FALSE(mReadOffset + amt <= mDataLength,
 64493:                           "Not enough space to pop an ipv6 addr!");
 64493:         memcpy(addr->ipv6.ip.pr_s6_addr, ip, amt);
 64493:     }
 64493: 
 64493:     mReadOffset += amt;
 64493: }
 64493: 
 64493: void
 64493: nsSOCKSSocketInfo::ReadNetPort(PRNetAddr *addr)
 64493: {
 64493:     addr->inet.port = ReadUint16();
 64493: }
 64493: 
 64493: void
108991: nsSOCKSSocketInfo::WantRead(uint32_t sz)
 64493: {
 64493:     NS_ABORT_IF_FALSE(mDataIoPtr == NULL,
 64493:                       "WantRead() called while I/O already in progress!");
 64493:     NS_ABORT_IF_FALSE(mDataLength + sz <= BUFFER_SIZE,
 64493:                       "Can't read that much data!");
 64493:     mAmountToRead = sz;
 64493: }
 64493: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::ReadFromSocket(PRFileDesc *fd)
 64493: {
108991:     int32_t rc;
108991:     const uint8_t *end;
 64493: 
 64493:     if (!mAmountToRead) {
 64493:         LOGDEBUG(("socks: ReadFromSocket(), nothing to do"));
 64493:         return PR_SUCCESS;
 64493:     }
 64493: 
 64493:     if (!mDataIoPtr) {
 64493:         mDataIoPtr = mData + mDataLength;
 64493:         mDataLength += mAmountToRead;
 64493:     }
 64493: 
 64493:     end = mData + mDataLength;
 64493: 
 64493:     while (mDataIoPtr < end) {
 64493:         rc = PR_Read(fd, mDataIoPtr, end - mDataIoPtr);
 64493:         if (rc <= 0) {
 64493:             if (rc == 0) {
 64493:                 LOGERROR(("socks: proxy server closed connection"));
 64493:                 HandshakeFinished(PR_CONNECT_REFUSED_ERROR);
 64493:                 return PR_FAILURE;
 64493:             } else if (PR_GetError() == PR_WOULD_BLOCK_ERROR) {
 64493:                 LOGDEBUG(("socks: ReadFromSocket(), want read"));
 64493:             }
 64493:             break;
 64493:         }
 64493: 
 64493:         mDataIoPtr += rc;
 64493:     }
 64493: 
 64493:     LOGDEBUG(("socks: ReadFromSocket(), have %u bytes total",
 64493:              unsigned(mDataIoPtr - mData)));
 64493:     if (mDataIoPtr == end) {
106838:         mDataIoPtr = nullptr;
 64493:         mAmountToRead = 0;
 64493:         mReadOffset = 0;
 64493:         return PR_SUCCESS;
 64493:     }
 64493: 
 64493:     return PR_FAILURE;
 64493: }
 64493: 
 64493: PRStatus
 64493: nsSOCKSSocketInfo::WriteToSocket(PRFileDesc *fd)
 64493: {
108991:     int32_t rc;
108991:     const uint8_t *end;
 64493: 
 64493:     if (!mDataLength) {
 64493:         LOGDEBUG(("socks: WriteToSocket(), nothing to do"));
 64493:         return PR_SUCCESS;
 64493:     }
 64493: 
 64493:     if (!mDataIoPtr)
 64493:         mDataIoPtr = mData;
 64493: 
 64493:     end = mData + mDataLength;
 64493: 
 64493:     while (mDataIoPtr < end) {
 64493:         rc = PR_Write(fd, mDataIoPtr, end - mDataIoPtr);
 64493:         if (rc < 0) {
 64493:             if (PR_GetError() == PR_WOULD_BLOCK_ERROR) {
 64493:                 LOGDEBUG(("socks: WriteToSocket(), want write"));
 64493:             }
 64493:             break;
 64493:         }
 64493:         
 64493:         mDataIoPtr += rc;
 64493:     }
 64493: 
 64493:     if (mDataIoPtr == end) {
106838:         mDataIoPtr = nullptr;
 64493:         mDataLength = 0;
 64493:         mReadOffset = 0;
 64493:         return PR_SUCCESS;
 64493:     }
 64493:     
 64493:     return PR_FAILURE;
 64493: }
 64493: 
 64493: static PRStatus
 64493: nsSOCKSIOLayerConnect(PRFileDesc *fd, const PRNetAddr *addr, PRIntervalTime to)
 64493: {
 64493:     PRStatus status;
 64493:     PRNetAddr dst;
 63804: 
 63804:     nsSOCKSSocketInfo * info = (nsSOCKSSocketInfo*) fd->secret;
 64493:     if (info == NULL) return PR_FAILURE;
 63804: 
 64493:     if (PR_NetAddrFamily(addr) == PR_AF_INET6 &&
 64493:         PR_IsNetAddrType(addr, PR_IpAddrV4Mapped)) {
108991:         const uint8_t *srcp;
 63804: 
 64493:         LOGDEBUG(("socks: converting ipv4-mapped ipv6 address to ipv4"));
 63804: 
 64493:         // copied from _PR_ConvertToIpv4NetAddr()
 64493:         PR_InitializeNetAddr(PR_IpAddrAny, 0, &dst);
 64493:         srcp = addr->ipv6.ip.pr_s6_addr;
 64493:         memcpy(&dst.inet.ip, srcp + 12, 4);
 64493:         dst.inet.family = PR_AF_INET;
 64493:         dst.inet.port = addr->ipv6.port;
 64493:     } else {
 64493:         memcpy(&dst, addr, sizeof(dst));
 63796:     }
 63796: 
 64493:     info->SetDestinationAddr(&dst);
 64493:     info->SetConnectTimeout(to);
 63796: 
 64493:     do {
 64493:         status = info->DoHandshake(fd, -1);
 64493:     } while (status == PR_SUCCESS && !info->IsConnected());
 64493: 
 64493:     return status;
 63796: }
 63796: 
 63796: static PRStatus
108991: nsSOCKSIOLayerConnectContinue(PRFileDesc *fd, int16_t oflags)
 63796: {
 43113:     PRStatus status;
 43113: 
 43113:     nsSOCKSSocketInfo * info = (nsSOCKSSocketInfo*) fd->secret;
 43113:     if (info == NULL) return PR_FAILURE;
 43113: 
 64493:     do { 
 64493:         status = info->DoHandshake(fd, oflags);
 64493:     } while (status == PR_SUCCESS && !info->IsConnected());
 43113: 
 43113:     return status;
 43113: }
 43113: 
108991: static int16_t
108991: nsSOCKSIOLayerPoll(PRFileDesc *fd, int16_t in_flags, int16_t *out_flags)
 64493: {
 64493:     nsSOCKSSocketInfo * info = (nsSOCKSSocketInfo*) fd->secret;
 64493:     if (info == NULL) return PR_FAILURE;
 43113: 
 64493:     if (!info->IsConnected()) {
 64493:         *out_flags = 0;
 64493:         return info->GetPollFlags();
 43113:     }
 43113: 
 64493:     return fd->lower->methods->poll(fd->lower, in_flags, out_flags);
 43113: }
 43113: 
 43113: static PRStatus
 43113: nsSOCKSIOLayerClose(PRFileDesc *fd)
 43113: {
 43113:     nsSOCKSSocketInfo * info = (nsSOCKSSocketInfo*) fd->secret;
 43113:     PRDescIdentity id = PR_GetLayersIdentity(fd);
 43113: 
 43113:     if (info && id == nsSOCKSIOLayerIdentity)
 43113:     {
120620:         info->ForgetFD();
 43113:         NS_RELEASE(info);
 43113:         fd->identity = PR_INVALID_IO_LAYER;
 43113:     }
 43113: 
 43113:     return fd->lower->methods->close(fd->lower);
 43113: }
 43113: 
 43113: static PRFileDesc*
 43113: nsSOCKSIOLayerAccept(PRFileDesc *fd, PRNetAddr *addr, PRIntervalTime timeout)
 43113: {
 43113:     // TODO: implement SOCKS support for accept
 43113:     return fd->lower->methods->accept(fd->lower, addr, timeout);
 43113: }
 43113: 
108991: static int32_t
108991: nsSOCKSIOLayerAcceptRead(PRFileDesc *sd, PRFileDesc **nd, PRNetAddr **raddr, void *buf, int32_t amount, PRIntervalTime timeout)
 43113: {
 43113:     // TODO: implement SOCKS support for accept, then read from it
 43113:     return sd->lower->methods->acceptread(sd->lower, nd, raddr, buf, amount, timeout);
 43113: }
 43113: 
 43113: static PRStatus
 43113: nsSOCKSIOLayerBind(PRFileDesc *fd, const PRNetAddr *addr)
 43113: {
 43113:     // TODO: implement SOCKS support for bind (very similar to connect)
 43113:     return fd->lower->methods->bind(fd->lower, addr);
 43113: }
 43113: 
 43113: static PRStatus
 43113: nsSOCKSIOLayerGetName(PRFileDesc *fd, PRNetAddr *addr)
 43113: {
 43113:     nsSOCKSSocketInfo * info = (nsSOCKSSocketInfo*) fd->secret;
 43113:     
 43113:     if (info != NULL && addr != NULL) {
 43113:         if (info->GetExternalProxyAddr(&addr) == NS_OK)
 43113:             return PR_SUCCESS;
 43113:     }
 43113: 
 43113:     return PR_FAILURE;
 43113: }
 43113: 
 43113: static PRStatus
 43113: nsSOCKSIOLayerGetPeerName(PRFileDesc *fd, PRNetAddr *addr)
 43113: {
 43113:     nsSOCKSSocketInfo * info = (nsSOCKSSocketInfo*) fd->secret;
 43113: 
 43113:     if (info != NULL && addr != NULL) {
 43113:         if (info->GetDestinationAddr(&addr) == NS_OK)
 43113:             return PR_SUCCESS;
 43113:     }
 43113: 
 43113:     return PR_FAILURE;
 43113: }
 43113: 
 43113: static PRStatus
107846: nsSOCKSIOLayerListen(PRFileDesc *fd, int backlog)
 43113: {
 43113:     // TODO: implement SOCKS support for listen
 43113:     return fd->lower->methods->listen(fd->lower, backlog);
 43113: }
 43113: 
 43113: // add SOCKS IO layer to an existing socket
 43113: nsresult
108991: nsSOCKSIOLayerAddToSocket(int32_t family,
 43113:                           const char *host, 
108991:                           int32_t port,
 43113:                           const char *proxyHost,
108991:                           int32_t proxyPort,
108991:                           int32_t socksVersion,
108991:                           uint32_t flags,
 43113:                           PRFileDesc *fd, 
 43113:                           nsISupports** info)
 43113: {
 43113:     NS_ENSURE_TRUE((socksVersion == 4) || (socksVersion == 5), NS_ERROR_NOT_INITIALIZED);
 43113: 
 43113: 
 43113:     if (firstTime)
 43113:     {
105983:         //XXX hack until NSPR provides an official way to detect system IPv6
105983:         // support (bug 388519)
105983:         PRFileDesc *tmpfd = PR_OpenTCPSocket(PR_AF_INET6);
105983:         if (!tmpfd) {
105983:             ipv6Supported = false;
105983:         } else {
105983:             // If the system does not support IPv6, NSPR will push
105983:             // IPv6-to-IPv4 emulation layer onto the native layer
105983:             ipv6Supported = PR_GetIdentitiesLayer(tmpfd, PR_NSPR_IO_LAYER) == tmpfd;
105983:             PR_Close(tmpfd);
105983:         }
105983: 
 43113:         nsSOCKSIOLayerIdentity		= PR_GetUniqueIdentity("SOCKS layer");
 43113:         nsSOCKSIOLayerMethods		= *PR_GetDefaultIOMethods();
 43113: 
 43113:         nsSOCKSIOLayerMethods.connect	= nsSOCKSIOLayerConnect;
 64493:         nsSOCKSIOLayerMethods.connectcontinue	= nsSOCKSIOLayerConnectContinue;
 64493:         nsSOCKSIOLayerMethods.poll	= nsSOCKSIOLayerPoll;
 43113:         nsSOCKSIOLayerMethods.bind	= nsSOCKSIOLayerBind;
 43113:         nsSOCKSIOLayerMethods.acceptread = nsSOCKSIOLayerAcceptRead;
 43113:         nsSOCKSIOLayerMethods.getsockname = nsSOCKSIOLayerGetName;
 43113:         nsSOCKSIOLayerMethods.getpeername = nsSOCKSIOLayerGetPeerName;
 43113:         nsSOCKSIOLayerMethods.accept	= nsSOCKSIOLayerAccept;
 43113:         nsSOCKSIOLayerMethods.listen	= nsSOCKSIOLayerListen;
 43113:         nsSOCKSIOLayerMethods.close	= nsSOCKSIOLayerClose;
 43113: 
 80486:         firstTime			= false;
 43113: 
 43113: #if defined(PR_LOGGING)
 43113:         gSOCKSLog = PR_NewLogModule("SOCKS");
 43113: #endif
 43113: 
 43113:     }
 43113: 
 43113:     LOGDEBUG(("Entering nsSOCKSIOLayerAddToSocket()."));
 43113: 
 43113:     PRFileDesc *	layer;
 43113:     PRStatus	rv;
 43113: 
 43113:     layer = PR_CreateIOLayerStub(nsSOCKSIOLayerIdentity, &nsSOCKSIOLayerMethods);
 43113:     if (! layer)
 43113:     {
 43113:         LOGERROR(("PR_CreateIOLayerStub() failed."));
 43113:         return NS_ERROR_FAILURE;
 43113:     }
 43113: 
 43113:     nsSOCKSSocketInfo * infoObject = new nsSOCKSSocketInfo();
 43113:     if (!infoObject)
 43113:     {
 43113:         // clean up IOLayerStub
 43113:         LOGERROR(("Failed to create nsSOCKSSocketInfo()."));
 43113:         PR_DELETE(layer);
 43113:         return NS_ERROR_FAILURE;
 43113:     }
 43113: 
 43113:     NS_ADDREF(infoObject);
105983:     infoObject->Init(socksVersion, family, proxyHost, proxyPort, host, flags);
 43113:     layer->secret = (PRFilePrivate*) infoObject;
 43113:     rv = PR_PushIOLayer(fd, PR_GetLayersIdentity(fd), layer);
 43113: 
108419:     if (rv == PR_FAILURE) {
 43113:         LOGERROR(("PR_PushIOLayer() failed. rv = %x.", rv));
 43113:         NS_RELEASE(infoObject);
 43113:         PR_DELETE(layer);
 43113:         return NS_ERROR_FAILURE;
 43113:     }
 43113: 
103193:     *info = static_cast<nsISOCKSSocketInfo*>(infoObject);
 43113:     NS_ADDREF(*info);
 43113:     return NS_OK;
 43113: }
