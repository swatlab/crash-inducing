    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:   nsPluginsDirWin.cpp
    1:   
    1:   Windows implementation of the nsPluginsDir/nsPluginsFile classes.
    1:   
    1:   by Alex Musil
    1:  */
    1: 
    1: #include "nsPluginsDir.h"
    1: #include "prlink.h"
    1: #include "plstr.h"
    1: #include "prmem.h"
    1: #include "prprf.h"
    1: 
    1: #include "windows.h"
    1: #include "winbase.h"
    1: 
    1: #include "nsString.h"
    1: 
    1: /* Local helper functions */
    1: 
25861: static char* GetKeyValue(TCHAR* verbuf, TCHAR* key)
    1: {
25861:   TCHAR *buf = NULL;
    1:   UINT blen;
    1: 
27322:   ::VerQueryValue(verbuf, key, (void **)&buf, &blen);
    1: 
27322:   if (buf) {
25861: #ifdef UNICODE
25861:     // the return value needs to always be a char *, regardless
25861:     // of whether we're UNICODE or not
25861:     return PL_strdup(NS_ConvertUTF16toUTF8(buf).get());
12902: #else
12902:     return PL_strdup(buf);
12902: #endif
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
25861: static char* GetVersion(TCHAR* verbuf)
15947: {
15947:   VS_FIXEDFILEINFO *fileInfo;
15947:   UINT fileInfoLen;
15947: 
27322:   ::VerQueryValue(verbuf, TEXT("\\"), (void **)&fileInfo, &fileInfoLen);
15947: 
27322:   if (fileInfo) {
15947:     return PR_smprintf("%ld.%ld.%ld.%ld",
15947:                        HIWORD(fileInfo->dwFileVersionMS),
15947:                        LOWORD(fileInfo->dwFileVersionMS),
15947:                        HIWORD(fileInfo->dwFileVersionLS),
15947:                        LOWORD(fileInfo->dwFileVersionLS));
15947:   }
15947: 
15947:   return nsnull;
15947: }
15947: 
    1: static PRUint32 CalculateVariantCount(char* mimeTypes)
    1: {
    1:   PRUint32 variants = 1;
    1: 
27322:   if (!mimeTypes)
    1:     return 0;
    1: 
    1:   char* index = mimeTypes;
27322:   while (*index) {
    1:     if (*index == '|')
    1:       variants++;
    1: 
    1:     ++index;
    1:   }
    1:   return variants;
    1: }
    1: 
    1: static char** MakeStringArray(PRUint32 variants, char* data)
    1: {
    1:   // The number of variants has been calculated based on the mime
    1:   // type array. Plugins are not explicitely required to match
    1:   // this number in two other arrays: file extention array and mime
    1:   // description array, and some of them actually don't. 
    1:   // We should handle such situations gracefully
    1: 
27322:   if ((variants <= 0) || !data)
    1:     return NULL;
    1: 
    1:   char ** array = (char **)PR_Calloc(variants, sizeof(char *));
27322:   if (!array)
    1:     return NULL;
    1: 
    1:   char * start = data;
    1: 
27322:   for (PRUint32 i = 0; i < variants; i++) {
    1:     char * p = PL_strchr(start, '|');
27322:     if (p)
    1:       *p = 0;
    1: 
    1:     array[i] = PL_strdup(start);
    1: 
27322:     if (!p) {
    1:       // nothing more to look for, fill everything left 
    1:       // with empty strings and break
    1:       while(++i < variants)
    1:         array[i] = PL_strdup("");
    1: 
    1:       break;
    1:     }
    1: 
    1:     start = ++p;
    1:   }
    1:   return array;
    1: }
    1: 
    1: static void FreeStringArray(PRUint32 variants, char ** array)
    1: {
27322:   if ((variants == 0) || !array)
    1:     return;
    1: 
27322:   for (PRUint32 i = 0; i < variants; i++) {
27322:     if (array[i]) {
    1:       PL_strfree(array[i]);
    1:       array[i] = NULL;
    1:     }
    1:   }
    1:   PR_Free(array);
    1: }
    1: 
    1: /* nsPluginsDir implementation */
    1: 
34818: // The file name must be in the form "np*.dll"
    1: PRBool nsPluginsDir::IsPluginFile(nsIFile* file)
    1: {
    1:   nsCAutoString path;
    1:   if (NS_FAILED(file->GetNativePath(path)))
    1:     return PR_FALSE;
    1: 
34818:   const char *cPath = path.get();
34818: 
    1:   // this is most likely a path, so skip to the filename
34818:   const char* filename = PL_strrchr(cPath, '\\');
    1:   if (filename)
    1:     ++filename;
    1:   else
34818:     filename = cPath;
    1: 
34818:   char* extension = PL_strrchr(filename, '.');
    1:   if (extension)
    1:     ++extension;
    1: 
34818:   PRUint32 fullLength = PL_strlen(filename);
34818:   PRUint32 extLength = PL_strlen(extension);
34818:   if (fullLength >= 7 && extLength == 3) {
34818:     if (!PL_strncasecmp(filename, "np", 2) && !PL_strncasecmp(extension, "dll", 3)) {
29079:       // don't load OJI-based Java plugins
34818:       if (!PL_strncasecmp(filename, "npoji", 5) ||
34818:           !PL_strncasecmp(filename, "npjava", 6))
29079:         return PR_FALSE;
    1:       return PR_TRUE;
    1:     }
29079:   }
34818: 
34818:   return PR_FALSE;
    1: }
    1: 
    1: /* nsPluginFile implementation */
    1: 
    1: nsPluginFile::nsPluginFile(nsIFile* file)
    1: : mPlugin(file)
    1: {
    1:   // nada
    1: }
    1: 
    1: nsPluginFile::~nsPluginFile()
    1: {
    1:   // nada
    1: }
    1: 
    1: /**
    1:  * Loads the plugin into memory using NSPR's shared-library loading
    1:  * mechanism. Handles platform differences in loading shared libraries.
    1:  */
    1: nsresult nsPluginFile::LoadPlugin(PRLibrary* &outLibrary)
    1: {
    1:   // How can we convert to a full path names for using with NSPR?
    1:   if (!mPlugin)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
12902:   nsCAutoString temp;
12902:   mPlugin->GetNativePath(temp);
    1: 
25861: #ifndef WINCE
12902:   char* index;
12902:   char* pluginFolderPath = PL_strdup(temp.get());
    1: 
12902:   index = PL_strrchr(pluginFolderPath, '\\');
28647:   if (!index) {
28647:     PL_strfree(pluginFolderPath);
28647:     return NS_ERROR_FILE_INVALID_PATH;
28647:   }
    1:   *index = 0;
    1: 
    1:   BOOL restoreOrigDir = FALSE;
12902:   char aOrigDir[MAX_PATH + 1];
12902:   DWORD dwCheck = ::GetCurrentDirectory(sizeof(aOrigDir), aOrigDir);
    1:   NS_ASSERTION(dwCheck <= MAX_PATH + 1, "Error in Loading plugin");
    1: 
27322:   if (dwCheck <= MAX_PATH + 1) {
12902:     restoreOrigDir = ::SetCurrentDirectory(pluginFolderPath);
    1:     NS_ASSERTION(restoreOrigDir, "Error in Loading plugin");
    1:   }
25861: #endif
    1: 
12902:   outLibrary = PR_LoadLibrary(temp.get());
    1: 
25861: #ifndef WINCE    
27322:   if (restoreOrigDir) {
12902:     BOOL bCheck = ::SetCurrentDirectory(aOrigDir);
    1:     NS_ASSERTION(bCheck, "Error in Loading plugin");
    1:   }
    1: 
12902:   PL_strfree(pluginFolderPath);
25861: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * Obtains all of the information currently available for this plugin.
    1:  */
    1: nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info)
    1: {
29020:   nsresult rv = NS_OK;
    1:   DWORD zerome, versionsize;
25861:   TCHAR* verbuf = nsnull;
    1: 
25861:   const TCHAR* path;
    1: 
    1:   if (!mPlugin)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
29020:   nsCAutoString fullPath;
29020:   if (NS_FAILED(rv = mPlugin->GetNativePath(fullPath)))
29020:     return rv;
29020: 
29020:   nsCAutoString fileName;
29020:   if (NS_FAILED(rv = mPlugin->GetNativeLeafName(fileName)))
29020:     return rv;
25861: 
25861: #ifdef UNICODE
29020:   NS_ConvertASCIItoUTF16 utf16Path(fullPath);
29020:   path = utf16Path.get();
25861:   versionsize = ::GetFileVersionInfoSizeW((TCHAR*)path, &zerome);
25861: #else
29020:   path = fullPath.get();
25861:   versionsize = ::GetFileVersionInfoSize((TCHAR*)path, &zerome);
25861: #endif
    1: 
    1:   if (versionsize > 0)
25861:     verbuf = (TCHAR*)PR_Malloc(versionsize);
    1:   if (!verbuf)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
25861: #ifdef UNICODE
25861:   if (::GetFileVersionInfoW((LPWSTR)path, NULL, versionsize, verbuf))
25861: #else
25861:   if (::GetFileVersionInfo(path, NULL, versionsize, verbuf))
25861: #endif
    1:   {
25861:     info.fName = GetKeyValue(verbuf, TEXT("\\StringFileInfo\\040904E4\\ProductName"));
25861:     info.fDescription = GetKeyValue(verbuf, TEXT("\\StringFileInfo\\040904E4\\FileDescription"));
    1: 
25861:     char *mimeType = GetKeyValue(verbuf, TEXT("\\StringFileInfo\\040904E4\\MIMEType"));
25861:     char *mimeDescription = GetKeyValue(verbuf, TEXT("\\StringFileInfo\\040904E4\\FileOpenName"));
25861:     char *extensions = GetKeyValue(verbuf, TEXT("\\StringFileInfo\\040904E4\\FileExtents"));
    1: 
    1:     info.fVariantCount = CalculateVariantCount(mimeType);
    1:     info.fMimeTypeArray = MakeStringArray(info.fVariantCount, mimeType);
    1:     info.fMimeDescriptionArray = MakeStringArray(info.fVariantCount, mimeDescription);
    1:     info.fExtensionArray = MakeStringArray(info.fVariantCount, extensions);
29020:     info.fFullPath = PL_strdup(fullPath.get());
29020:     info.fFileName = PL_strdup(fileName.get());
15947:     info.fVersion = GetVersion(verbuf);
    1: 
    1:     PL_strfree(mimeType);
    1:     PL_strfree(mimeDescription);
    1:     PL_strfree(extensions);
    1:   }
27322:   else {
29020:     rv = NS_ERROR_FAILURE;
27322:   }
    1: 
    1:   PR_Free(verbuf);
    1: 
29020:   return rv;
    1: }
    1: 
    1: nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info)
    1: {
27322:   if (info.fName)
    1:     PL_strfree(info.fName);
    1: 
27322:   if (info.fDescription)
    1:     PL_strfree(info.fDescription);
    1: 
27322:   if (info.fMimeTypeArray)
    1:     FreeStringArray(info.fVariantCount, info.fMimeTypeArray);
    1: 
27322:   if (info.fMimeDescriptionArray)
    1:     FreeStringArray(info.fVariantCount, info.fMimeDescriptionArray);
    1: 
27322:   if (info.fExtensionArray)
    1:     FreeStringArray(info.fVariantCount, info.fExtensionArray);
    1: 
29020:   if (info.fFullPath)
29020:     PL_strfree(info.fFullPath);
29020: 
27322:   if (info.fFileName)
    1:     PL_strfree(info.fFileName);
    1: 
27322:   if (info.fVersion)
27025:     PR_smprintf_free(info.fVersion);
15947: 
    1:   ZeroMemory((void *)&info, sizeof(info));
    1: 
    1:   return NS_OK;
    1: }
