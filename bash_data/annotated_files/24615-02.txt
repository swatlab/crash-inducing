    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
17755:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS bytecode generation.
    1:  */
    1: #include "jsstddef.h"
    1: #ifdef HAVE_MEMORY_H
    1: #include <memory.h>
    1: #endif
    1: #include <string.h>
    1: #include "jstypes.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsbit.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsatom.h"
 8817: #include "jsbool.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsnum.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsregexp.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
15453: #include "jsautooplen.h"
18989: #include "jsstaticcheck.h"
15453: 
    1: /* Allocation chunk counts, must be powers of two in general. */
    1: #define BYTECODE_CHUNK  256     /* code allocation increment */
    1: #define SRCNOTE_CHUNK   64      /* initial srcnote allocation increment */
    1: #define TRYNOTE_CHUNK   64      /* trynote allocation increment */
    1: 
    1: /* Macros to compute byte sizes from typed element counts. */
    1: #define BYTECODE_SIZE(n)        ((n) * sizeof(jsbytecode))
    1: #define SRCNOTE_SIZE(n)         ((n) * sizeof(jssrcnote))
    1: #define TRYNOTE_SIZE(n)         ((n) * sizeof(JSTryNote))
    1: 
 3025: static JSBool
 3025: NewTryNote(JSContext *cx, JSCodeGenerator *cg, JSTryNoteKind kind,
 3025:            uintN stackDepth, size_t start, size_t end);
 3025: 
 6561: JS_FRIEND_API(void)
 3235: js_InitCodeGenerator(JSContext *cx, JSCodeGenerator *cg, JSParseContext *pc,
    1:                      JSArenaPool *codePool, JSArenaPool *notePool,
 6561:                      uintN lineno)
    1: {
    1:     memset(cg, 0, sizeof *cg);
 3235:     TREE_CONTEXT_INIT(&cg->treeContext, pc);
    1:     cg->codePool = codePool;
    1:     cg->notePool = notePool;
    1:     cg->codeMark = JS_ARENA_MARK(codePool);
    1:     cg->noteMark = JS_ARENA_MARK(notePool);
    1:     cg->current = &cg->main;
    1:     cg->firstLine = cg->prolog.currentLine = cg->main.currentLine = lineno;
    1:     ATOM_LIST_INIT(&cg->atomList);
    1:     cg->prolog.noteMask = cg->main.noteMask = SRCNOTE_CHUNK - 1;
    1:     ATOM_LIST_INIT(&cg->constList);
18308:     ATOM_LIST_INIT(&cg->upvarList);
    1: }
    1: 
    1: JS_FRIEND_API(void)
    1: js_FinishCodeGenerator(JSContext *cx, JSCodeGenerator *cg)
    1: {
16072:     TREE_CONTEXT_FINISH(cx, &cg->treeContext);
    1:     JS_ARENA_RELEASE(cg->codePool, cg->codeMark);
    1:     JS_ARENA_RELEASE(cg->notePool, cg->noteMark);
18308: 
18308:     /* NB: non-null only after OOM. */
18308:     if (cg->spanDeps)
11836:         JS_free(cx, cg->spanDeps);
18308: 
18308:     if (cg->upvarMap.vector)
18308:         JS_free(cx, cg->upvarMap.vector);
    1: }
    1: 
    1: static ptrdiff_t
    1: EmitCheck(JSContext *cx, JSCodeGenerator *cg, JSOp op, ptrdiff_t delta)
    1: {
    1:     jsbytecode *base, *limit, *next;
    1:     ptrdiff_t offset, length;
    1:     size_t incr, size;
    1: 
    1:     base = CG_BASE(cg);
    1:     next = CG_NEXT(cg);
    1:     limit = CG_LIMIT(cg);
    1:     offset = PTRDIFF(next, base, jsbytecode);
    1:     if (next + delta > limit) {
    1:         length = offset + delta;
    1:         length = (length <= BYTECODE_CHUNK)
    1:                  ? BYTECODE_CHUNK
    1:                  : JS_BIT(JS_CeilingLog2(length));
    1:         incr = BYTECODE_SIZE(length);
    1:         if (!base) {
    1:             JS_ARENA_ALLOCATE_CAST(base, jsbytecode *, cg->codePool, incr);
    1:         } else {
    1:             size = BYTECODE_SIZE(PTRDIFF(limit, base, jsbytecode));
    1:             incr -= size;
    1:             JS_ARENA_GROW_CAST(base, jsbytecode *, cg->codePool, size, incr);
    1:         }
    1:         if (!base) {
 8296:             js_ReportOutOfScriptQuota(cx);
    1:             return -1;
    1:         }
    1:         CG_BASE(cg) = base;
    1:         CG_LIMIT(cg) = base + length;
    1:         CG_NEXT(cg) = base + offset;
    1:     }
    1:     return offset;
    1: }
    1: 
    1: static void
    1: UpdateDepth(JSContext *cx, JSCodeGenerator *cg, ptrdiff_t target)
    1: {
    1:     jsbytecode *pc;
 1227:     JSOp op;
    1:     const JSCodeSpec *cs;
23075:     uintN extra, depth;
18567:     intN nuses, ndefs;
    1: 
    1:     pc = CG_CODE(cg, target);
 1227:     op = (JSOp) *pc;
 1227:     cs = &js_CodeSpec[op];
23075: #ifdef JS_TRACER
23075:     extern uint8 js_opcode2extra[];
23075:     extra = js_opcode2extra[op];
23075: #else
23075:     extra = 0;
23075: #endif
23075:     if ((cs->format & JOF_TMPSLOT_MASK) || extra) {
12611:         depth = (uintN) cg->stackDepth +
23075:                 ((cs->format & JOF_TMPSLOT_MASK) >> JOF_TMPSLOT_SHIFT) +
23075:                 extra;
12611:         if (depth > cg->maxStackDepth)
12611:             cg->maxStackDepth = depth;
 2126:     }
23075: 
    1:     nuses = cs->nuses;
18567:     if (nuses < 0)
18567:         nuses = js_GetVariableStackUseLength(op, pc);
    1:     cg->stackDepth -= nuses;
    1:     JS_ASSERT(cg->stackDepth >= 0);
    1:     if (cg->stackDepth < 0) {
    1:         char numBuf[12];
 6561:         JSTokenStream *ts;
 6561: 
    1:         JS_snprintf(numBuf, sizeof numBuf, "%d", target);
 6561:         ts = &cg->treeContext.parseContext->tokenStream;
    1:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING,
    1:                                      js_GetErrorMessage, NULL,
    1:                                      JSMSG_STACK_UNDERFLOW,
 6561:                                      ts->filename ? ts->filename : "stdin",
    1:                                      numBuf);
    1:     }
18567:     ndefs = cs->ndefs;
18567:     if (ndefs < 0) {
18567:         JSObject *blockObj;
18567: 
18567:         /* We just executed IndexParsedObject */
18567:         JS_ASSERT(op == JSOP_ENTERBLOCK);
18567:         JS_ASSERT(nuses == 0);
18567:         blockObj = cg->objectList.lastPob->object;
18567:         JS_ASSERT(STOBJ_GET_CLASS(blockObj) == &js_BlockClass);
18567:         JS_ASSERT(JSVAL_IS_VOID(blockObj->fslots[JSSLOT_BLOCK_DEPTH]));
18567: 
18567:         OBJ_SET_BLOCK_DEPTH(cx, blockObj, cg->stackDepth);
18567:         ndefs = OBJ_BLOCK_COUNT(cx, blockObj);
18567:     }
18567:     cg->stackDepth += ndefs;
 2126:     if ((uintN)cg->stackDepth > cg->maxStackDepth)
 2126:         cg->maxStackDepth = cg->stackDepth;
    1: }
    1: 
    1: ptrdiff_t
    1: js_Emit1(JSContext *cx, JSCodeGenerator *cg, JSOp op)
    1: {
    1:     ptrdiff_t offset = EmitCheck(cx, cg, op, 1);
    1: 
    1:     if (offset >= 0) {
    1:         *CG_NEXT(cg)++ = (jsbytecode)op;
    1:         UpdateDepth(cx, cg, offset);
    1:     }
    1:     return offset;
    1: }
    1: 
    1: ptrdiff_t
    1: js_Emit2(JSContext *cx, JSCodeGenerator *cg, JSOp op, jsbytecode op1)
    1: {
    1:     ptrdiff_t offset = EmitCheck(cx, cg, op, 2);
    1: 
    1:     if (offset >= 0) {
    1:         jsbytecode *next = CG_NEXT(cg);
    1:         next[0] = (jsbytecode)op;
    1:         next[1] = op1;
    1:         CG_NEXT(cg) = next + 2;
    1:         UpdateDepth(cx, cg, offset);
    1:     }
    1:     return offset;
    1: }
    1: 
    1: ptrdiff_t
    1: js_Emit3(JSContext *cx, JSCodeGenerator *cg, JSOp op, jsbytecode op1,
    1:          jsbytecode op2)
    1: {
    1:     ptrdiff_t offset = EmitCheck(cx, cg, op, 3);
    1: 
    1:     if (offset >= 0) {
    1:         jsbytecode *next = CG_NEXT(cg);
    1:         next[0] = (jsbytecode)op;
    1:         next[1] = op1;
    1:         next[2] = op2;
    1:         CG_NEXT(cg) = next + 3;
    1:         UpdateDepth(cx, cg, offset);
    1:     }
    1:     return offset;
    1: }
    1: 
    1: ptrdiff_t
    1: js_EmitN(JSContext *cx, JSCodeGenerator *cg, JSOp op, size_t extra)
    1: {
    1:     ptrdiff_t length = 1 + (ptrdiff_t)extra;
    1:     ptrdiff_t offset = EmitCheck(cx, cg, op, length);
    1: 
    1:     if (offset >= 0) {
    1:         jsbytecode *next = CG_NEXT(cg);
    1:         *next = (jsbytecode)op;
    1:         memset(next + 1, 0, BYTECODE_SIZE(extra));
    1:         CG_NEXT(cg) = next + length;
15279: 
15279:         /*
15279:          * Don't UpdateDepth if op's use-count comes from the immediate
15279:          * operand yet to be stored in the extra bytes after op.
15279:          */
15279:         if (js_CodeSpec[op].nuses >= 0)
    1:             UpdateDepth(cx, cg, offset);
    1:     }
    1:     return offset;
    1: }
    1: 
    1: /* XXX too many "... statement" L10N gaffes below -- fix via js.msg! */
    1: const char js_with_statement_str[] = "with statement";
    1: const char js_finally_block_str[]  = "finally block";
    1: const char js_script_str[]         = "script";
    1: 
    1: static const char *statementName[] = {
    1:     "label statement",       /* LABEL */
    1:     "if statement",          /* IF */
    1:     "else statement",        /* ELSE */
11672:     "destructuring body",    /* BODY */
    1:     "switch statement",      /* SWITCH */
    1:     "block",                 /* BLOCK */
    1:     js_with_statement_str,   /* WITH */
    1:     "catch block",           /* CATCH */
    1:     "try block",             /* TRY */
    1:     js_finally_block_str,    /* FINALLY */
    1:     js_finally_block_str,    /* SUBROUTINE */
    1:     "do loop",               /* DO_LOOP */
    1:     "for loop",              /* FOR_LOOP */
    1:     "for/in loop",           /* FOR_IN_LOOP */
    1:     "while loop",            /* WHILE_LOOP */
    1: };
    1: 
11672: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(statementName) == STMT_LIMIT);
11672: 
    1: static const char *
    1: StatementName(JSCodeGenerator *cg)
    1: {
    1:     if (!cg->treeContext.topStmt)
    1:         return js_script_str;
    1:     return statementName[cg->treeContext.topStmt->type];
    1: }
    1: 
    1: static void
    1: ReportStatementTooLarge(JSContext *cx, JSCodeGenerator *cg)
    1: {
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NEED_DIET,
    1:                          StatementName(cg));
    1: }
    1: 
    1: /**
    1:   Span-dependent instructions in JS bytecode consist of the jump (JOF_JUMP)
    1:   and switch (JOF_LOOKUPSWITCH, JOF_TABLESWITCH) format opcodes, subdivided
    1:   into unconditional (gotos and gosubs), and conditional jumps or branches
    1:   (which pop a value, test it, and jump depending on its value).  Most jumps
    1:   have just one immediate operand, a signed offset from the jump opcode's pc
    1:   to the target bytecode.  The lookup and table switch opcodes may contain
    1:   many jump offsets.
    1: 
    1:   Mozilla bug #80981 (http://bugzilla.mozilla.org/show_bug.cgi?id=80981) was
    1:   fixed by adding extended "X" counterparts to the opcodes/formats (NB: X is
    1:   suffixed to prefer JSOP_ORX thereby avoiding a JSOP_XOR name collision for
    1:   the extended form of the JSOP_OR branch opcode).  The unextended or short
    1:   formats have 16-bit signed immediate offset operands, the extended or long
    1:   formats have 32-bit signed immediates.  The span-dependency problem consists
    1:   of selecting as few long instructions as possible, or about as few -- since
    1:   jumps can span other jumps, extending one jump may cause another to need to
    1:   be extended.
    1: 
    1:   Most JS scripts are short, so need no extended jumps.  We optimize for this
    1:   case by generating short jumps until we know a long jump is needed.  After
    1:   that point, we keep generating short jumps, but each jump's 16-bit immediate
    1:   offset operand is actually an unsigned index into cg->spanDeps, an array of
    1:   JSSpanDep structs.  Each struct tells the top offset in the script of the
    1:   opcode, the "before" offset of the jump (which will be the same as top for
    1:   simplex jumps, but which will index further into the bytecode array for a
    1:   non-initial jump offset in a lookup or table switch), the after "offset"
    1:   adjusted during span-dependent instruction selection (initially the same
    1:   value as the "before" offset), and the jump target (more below).
    1: 
    1:   Since we generate cg->spanDeps lazily, from within js_SetJumpOffset, we must
    1:   ensure that all bytecode generated so far can be inspected to discover where
    1:   the jump offset immediate operands lie within CG_CODE(cg).  But the bonus is
    1:   that we generate span-dependency records sorted by their offsets, so we can
    1:   binary-search when trying to find a JSSpanDep for a given bytecode offset,
    1:   or the nearest JSSpanDep at or above a given pc.
    1: 
    1:   To avoid limiting scripts to 64K jumps, if the cg->spanDeps index overflows
    1:   65534, we store SPANDEP_INDEX_HUGE in the jump's immediate operand.  This
    1:   tells us that we need to binary-search for the cg->spanDeps entry by the
    1:   jump opcode's bytecode offset (sd->before).
    1: 
    1:   Jump targets need to be maintained in a data structure that lets us look
    1:   up an already-known target by its address (jumps may have a common target),
    1:   and that also lets us update the addresses (script-relative, a.k.a. absolute
    1:   offsets) of targets that come after a jump target (for when a jump below
    1:   that target needs to be extended).  We use an AVL tree, implemented using
    1:   recursion, but with some tricky optimizations to its height-balancing code
    1:   (see http://www.cmcrossroads.com/bradapp/ftp/src/libs/C++/AvlTrees.html).
    1: 
    1:   A final wrinkle: backpatch chains are linked by jump-to-jump offsets with
    1:   positive sign, even though they link "backward" (i.e., toward lower bytecode
    1:   address).  We don't want to waste space and search time in the AVL tree for
    1:   such temporary backpatch deltas, so we use a single-bit wildcard scheme to
    1:   tag true JSJumpTarget pointers and encode untagged, signed (positive) deltas
    1:   in JSSpanDep.target pointers, depending on whether the JSSpanDep has a known
    1:   target, or is still awaiting backpatching.
    1: 
    1:   Note that backpatch chains would present a problem for BuildSpanDepTable,
    1:   which inspects bytecode to build cg->spanDeps on demand, when the first
    1:   short jump offset overflows.  To solve this temporary problem, we emit a
    1:   proxy bytecode (JSOP_BACKPATCH; JSOP_BACKPATCH_POP for branch ops) whose
    1:   nuses/ndefs counts help keep the stack balanced, but whose opcode format
    1:   distinguishes its backpatch delta immediate operand from a normal jump
    1:   offset.
    1:  */
    1: static int
    1: BalanceJumpTargets(JSJumpTarget **jtp)
    1: {
    1:     JSJumpTarget *jt, *jt2, *root;
    1:     int dir, otherDir, heightChanged;
    1:     JSBool doubleRotate;
    1: 
    1:     jt = *jtp;
    1:     JS_ASSERT(jt->balance != 0);
    1: 
    1:     if (jt->balance < -1) {
    1:         dir = JT_RIGHT;
    1:         doubleRotate = (jt->kids[JT_LEFT]->balance > 0);
    1:     } else if (jt->balance > 1) {
    1:         dir = JT_LEFT;
    1:         doubleRotate = (jt->kids[JT_RIGHT]->balance < 0);
    1:     } else {
    1:         return 0;
    1:     }
    1: 
    1:     otherDir = JT_OTHER_DIR(dir);
    1:     if (doubleRotate) {
    1:         jt2 = jt->kids[otherDir];
    1:         *jtp = root = jt2->kids[dir];
    1: 
    1:         jt->kids[otherDir] = root->kids[dir];
    1:         root->kids[dir] = jt;
    1: 
    1:         jt2->kids[dir] = root->kids[otherDir];
    1:         root->kids[otherDir] = jt2;
    1: 
    1:         heightChanged = 1;
    1:         root->kids[JT_LEFT]->balance = -JS_MAX(root->balance, 0);
    1:         root->kids[JT_RIGHT]->balance = -JS_MIN(root->balance, 0);
    1:         root->balance = 0;
    1:     } else {
    1:         *jtp = root = jt->kids[otherDir];
    1:         jt->kids[otherDir] = root->kids[dir];
    1:         root->kids[dir] = jt;
    1: 
    1:         heightChanged = (root->balance != 0);
    1:         jt->balance = -((dir == JT_LEFT) ? --root->balance : ++root->balance);
    1:     }
    1: 
    1:     return heightChanged;
    1: }
    1: 
    1: typedef struct AddJumpTargetArgs {
    1:     JSContext           *cx;
    1:     JSCodeGenerator     *cg;
    1:     ptrdiff_t           offset;
    1:     JSJumpTarget        *node;
    1: } AddJumpTargetArgs;
    1: 
    1: static int
    1: AddJumpTarget(AddJumpTargetArgs *args, JSJumpTarget **jtp)
    1: {
    1:     JSJumpTarget *jt;
    1:     int balanceDelta;
    1: 
    1:     jt = *jtp;
    1:     if (!jt) {
    1:         JSCodeGenerator *cg = args->cg;
    1: 
    1:         jt = cg->jtFreeList;
    1:         if (jt) {
    1:             cg->jtFreeList = jt->kids[JT_LEFT];
    1:         } else {
    1:             JS_ARENA_ALLOCATE_CAST(jt, JSJumpTarget *, &args->cx->tempPool,
    1:                                    sizeof *jt);
    1:             if (!jt) {
 8296:                 js_ReportOutOfScriptQuota(args->cx);
    1:                 return 0;
    1:             }
    1:         }
    1:         jt->offset = args->offset;
    1:         jt->balance = 0;
    1:         jt->kids[JT_LEFT] = jt->kids[JT_RIGHT] = NULL;
    1:         cg->numJumpTargets++;
    1:         args->node = jt;
    1:         *jtp = jt;
    1:         return 1;
    1:     }
    1: 
    1:     if (jt->offset == args->offset) {
    1:         args->node = jt;
    1:         return 0;
    1:     }
    1: 
    1:     if (args->offset < jt->offset)
    1:         balanceDelta = -AddJumpTarget(args, &jt->kids[JT_LEFT]);
    1:     else
    1:         balanceDelta = AddJumpTarget(args, &jt->kids[JT_RIGHT]);
    1:     if (!args->node)
    1:         return 0;
    1: 
    1:     jt->balance += balanceDelta;
    1:     return (balanceDelta && jt->balance)
    1:            ? 1 - BalanceJumpTargets(jtp)
    1:            : 0;
    1: }
    1: 
    1: #ifdef DEBUG_brendan
    1: static int AVLCheck(JSJumpTarget *jt)
    1: {
    1:     int lh, rh;
    1: 
    1:     if (!jt) return 0;
    1:     JS_ASSERT(-1 <= jt->balance && jt->balance <= 1);
    1:     lh = AVLCheck(jt->kids[JT_LEFT]);
    1:     rh = AVLCheck(jt->kids[JT_RIGHT]);
    1:     JS_ASSERT(jt->balance == rh - lh);
    1:     return 1 + JS_MAX(lh, rh);
    1: }
    1: #endif
    1: 
    1: static JSBool
    1: SetSpanDepTarget(JSContext *cx, JSCodeGenerator *cg, JSSpanDep *sd,
    1:                  ptrdiff_t off)
    1: {
    1:     AddJumpTargetArgs args;
    1: 
    1:     if (off < JUMPX_OFFSET_MIN || JUMPX_OFFSET_MAX < off) {
    1:         ReportStatementTooLarge(cx, cg);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     args.cx = cx;
    1:     args.cg = cg;
    1:     args.offset = sd->top + off;
    1:     args.node = NULL;
    1:     AddJumpTarget(&args, &cg->jumpTargets);
    1:     if (!args.node)
    1:         return JS_FALSE;
    1: 
    1: #ifdef DEBUG_brendan
    1:     AVLCheck(cg->jumpTargets);
    1: #endif
    1: 
    1:     SD_SET_TARGET(sd, args.node);
    1:     return JS_TRUE;
    1: }
    1: 
    1: #define SPANDEPS_MIN            256
    1: #define SPANDEPS_SIZE(n)        ((n) * sizeof(JSSpanDep))
    1: #define SPANDEPS_SIZE_MIN       SPANDEPS_SIZE(SPANDEPS_MIN)
    1: 
    1: static JSBool
    1: AddSpanDep(JSContext *cx, JSCodeGenerator *cg, jsbytecode *pc, jsbytecode *pc2,
    1:            ptrdiff_t off)
    1: {
    1:     uintN index;
    1:     JSSpanDep *sdbase, *sd;
    1:     size_t size;
    1: 
    1:     index = cg->numSpanDeps;
    1:     if (index + 1 == 0) {
    1:         ReportStatementTooLarge(cx, cg);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if ((index & (index - 1)) == 0 &&
    1:         (!(sdbase = cg->spanDeps) || index >= SPANDEPS_MIN)) {
11836:         size = sdbase ? SPANDEPS_SIZE(index) : SPANDEPS_SIZE_MIN / 2;
11836:         sdbase = (JSSpanDep *) JS_realloc(cx, sdbase, size + size);
    1:         if (!sdbase)
    1:             return JS_FALSE;
    1:         cg->spanDeps = sdbase;
    1:     }
    1: 
    1:     cg->numSpanDeps = index + 1;
    1:     sd = cg->spanDeps + index;
    1:     sd->top = PTRDIFF(pc, CG_BASE(cg), jsbytecode);
    1:     sd->offset = sd->before = PTRDIFF(pc2, CG_BASE(cg), jsbytecode);
    1: 
    1:     if (js_CodeSpec[*pc].format & JOF_BACKPATCH) {
    1:         /* Jump offset will be backpatched if off is a non-zero "bpdelta". */
    1:         if (off != 0) {
    1:             JS_ASSERT(off >= 1 + JUMP_OFFSET_LEN);
    1:             if (off > BPDELTA_MAX) {
    1:                 ReportStatementTooLarge(cx, cg);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         SD_SET_BPDELTA(sd, off);
    1:     } else if (off == 0) {
    1:         /* Jump offset will be patched directly, without backpatch chaining. */
16069:         SD_SET_TARGET(sd, 0);
    1:     } else {
    1:         /* The jump offset in off is non-zero, therefore it's already known. */
    1:         if (!SetSpanDepTarget(cx, cg, sd, off))
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     if (index > SPANDEP_INDEX_MAX)
    1:         index = SPANDEP_INDEX_HUGE;
    1:     SET_SPANDEP_INDEX(pc2, index);
    1:     return JS_TRUE;
    1: }
    1: 
 7365: static jsbytecode *
 7365: AddSwitchSpanDeps(JSContext *cx, JSCodeGenerator *cg, jsbytecode *pc)
 7365: {
 7365:     JSOp op;
 7365:     jsbytecode *pc2;
 7365:     ptrdiff_t off;
 7365:     jsint low, high;
 7365:     uintN njumps, indexlen;
 7365: 
 7365:     op = (JSOp) *pc;
 7365:     JS_ASSERT(op == JSOP_TABLESWITCH || op == JSOP_LOOKUPSWITCH);
 7365:     pc2 = pc;
 7365:     off = GET_JUMP_OFFSET(pc2);
 7365:     if (!AddSpanDep(cx, cg, pc, pc2, off))
 7365:         return NULL;
 7365:     pc2 += JUMP_OFFSET_LEN;
 7365:     if (op == JSOP_TABLESWITCH) {
 7365:         low = GET_JUMP_OFFSET(pc2);
 7365:         pc2 += JUMP_OFFSET_LEN;
 7365:         high = GET_JUMP_OFFSET(pc2);
 7365:         pc2 += JUMP_OFFSET_LEN;
 7365:         njumps = (uintN) (high - low + 1);
 7365:         indexlen = 0;
 7365:     } else {
 7365:         njumps = GET_UINT16(pc2);
 7365:         pc2 += UINT16_LEN;
 7365:         indexlen = INDEX_LEN;
 7365:     }
 7365:     while (njumps) {
 7365:         --njumps;
 7365:         pc2 += indexlen;
 7365:         off = GET_JUMP_OFFSET(pc2);
 7365:         if (!AddSpanDep(cx, cg, pc, pc2, off))
 7365:             return NULL;
 7365:         pc2 += JUMP_OFFSET_LEN;
 7365:     }
 7365:     return 1 + pc2;
 7365: }
 7365: 
    1: static JSBool
    1: BuildSpanDepTable(JSContext *cx, JSCodeGenerator *cg)
    1: {
    1:     jsbytecode *pc, *end;
    1:     JSOp op;
    1:     const JSCodeSpec *cs;
 7365:     ptrdiff_t off;
    1: 
    1:     pc = CG_BASE(cg) + cg->spanDepTodo;
    1:     end = CG_NEXT(cg);
 7365:     while (pc != end) {
 7365:         JS_ASSERT(pc < end);
    1:         op = (JSOp)*pc;
    1:         cs = &js_CodeSpec[op];
    1: 
11377:         switch (JOF_TYPE(cs->format)) {
 7365:           case JOF_TABLESWITCH:
 7365:           case JOF_LOOKUPSWITCH:
 7365:             pc = AddSwitchSpanDeps(cx, cg, pc);
 7365:             if (!pc)
 7365:                 return JS_FALSE;
 7365:             break;
 7365: 
    1:           case JOF_JUMP:
    1:             off = GET_JUMP_OFFSET(pc);
    1:             if (!AddSpanDep(cx, cg, pc, pc, off))
    1:                 return JS_FALSE;
 7365:             /* FALL THROUGH */
 7365:           default:
 7365:             pc += cs->length;
 7365:             break;
 7365:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSSpanDep *
    1: GetSpanDep(JSCodeGenerator *cg, jsbytecode *pc)
    1: {
    1:     uintN index;
    1:     ptrdiff_t offset;
    1:     int lo, hi, mid;
    1:     JSSpanDep *sd;
    1: 
    1:     index = GET_SPANDEP_INDEX(pc);
    1:     if (index != SPANDEP_INDEX_HUGE)
    1:         return cg->spanDeps + index;
    1: 
    1:     offset = PTRDIFF(pc, CG_BASE(cg), jsbytecode);
    1:     lo = 0;
    1:     hi = cg->numSpanDeps - 1;
    1:     while (lo <= hi) {
    1:         mid = (lo + hi) / 2;
    1:         sd = cg->spanDeps + mid;
    1:         if (sd->before == offset)
    1:             return sd;
    1:         if (sd->before < offset)
    1:             lo = mid + 1;
    1:         else
    1:             hi = mid - 1;
    1:     }
    1: 
    1:     JS_ASSERT(0);
    1:     return NULL;
    1: }
    1: 
    1: static JSBool
    1: SetBackPatchDelta(JSContext *cx, JSCodeGenerator *cg, jsbytecode *pc,
    1:                   ptrdiff_t delta)
    1: {
    1:     JSSpanDep *sd;
    1: 
    1:     JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
    1:     if (!cg->spanDeps && delta < JUMP_OFFSET_MAX) {
    1:         SET_JUMP_OFFSET(pc, delta);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     if (delta > BPDELTA_MAX) {
    1:         ReportStatementTooLarge(cx, cg);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     if (!cg->spanDeps && !BuildSpanDepTable(cx, cg))
    1:         return JS_FALSE;
    1: 
    1:     sd = GetSpanDep(cg, pc);
    1:     JS_ASSERT(SD_GET_BPDELTA(sd) == 0);
    1:     SD_SET_BPDELTA(sd, delta);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static void
    1: UpdateJumpTargets(JSJumpTarget *jt, ptrdiff_t pivot, ptrdiff_t delta)
    1: {
    1:     if (jt->offset > pivot) {
    1:         jt->offset += delta;
    1:         if (jt->kids[JT_LEFT])
    1:             UpdateJumpTargets(jt->kids[JT_LEFT], pivot, delta);
    1:     }
    1:     if (jt->kids[JT_RIGHT])
    1:         UpdateJumpTargets(jt->kids[JT_RIGHT], pivot, delta);
    1: }
    1: 
    1: static JSSpanDep *
    1: FindNearestSpanDep(JSCodeGenerator *cg, ptrdiff_t offset, int lo,
    1:                    JSSpanDep *guard)
    1: {
    1:     int num, hi, mid;
    1:     JSSpanDep *sdbase, *sd;
    1: 
    1:     num = cg->numSpanDeps;
    1:     JS_ASSERT(num > 0);
    1:     hi = num - 1;
    1:     sdbase = cg->spanDeps;
    1:     while (lo <= hi) {
    1:         mid = (lo + hi) / 2;
    1:         sd = sdbase + mid;
    1:         if (sd->before == offset)
    1:             return sd;
    1:         if (sd->before < offset)
    1:             lo = mid + 1;
    1:         else
    1:             hi = mid - 1;
    1:     }
    1:     if (lo == num)
    1:         return guard;
    1:     sd = sdbase + lo;
    1:     JS_ASSERT(sd->before >= offset && (lo == 0 || sd[-1].before < offset));
    1:     return sd;
    1: }
    1: 
    1: static void
    1: FreeJumpTargets(JSCodeGenerator *cg, JSJumpTarget *jt)
    1: {
    1:     if (jt->kids[JT_LEFT])
    1:         FreeJumpTargets(cg, jt->kids[JT_LEFT]);
    1:     if (jt->kids[JT_RIGHT])
    1:         FreeJumpTargets(cg, jt->kids[JT_RIGHT]);
    1:     jt->kids[JT_LEFT] = cg->jtFreeList;
    1:     cg->jtFreeList = jt;
    1: }
    1: 
    1: static JSBool
    1: OptimizeSpanDeps(JSContext *cx, JSCodeGenerator *cg)
    1: {
    1:     jsbytecode *pc, *oldpc, *base, *limit, *next;
    1:     JSSpanDep *sd, *sd2, *sdbase, *sdlimit, *sdtop, guard;
    1:     ptrdiff_t offset, growth, delta, top, pivot, span, length, target;
    1:     JSBool done;
    1:     JSOp op;
    1:     uint32 type;
    1:     size_t size, incr;
    1:     jssrcnote *sn, *snlimit;
    1:     JSSrcNoteSpec *spec;
    1:     uintN i, n, noteIndex;
 3025:     JSTryNode *tryNode;
    1: #ifdef DEBUG_brendan
    1:     int passes = 0;
    1: #endif
    1: 
    1:     base = CG_BASE(cg);
    1:     sdbase = cg->spanDeps;
    1:     sdlimit = sdbase + cg->numSpanDeps;
    1:     offset = CG_OFFSET(cg);
    1:     growth = 0;
    1: 
    1:     do {
    1:         done = JS_TRUE;
    1:         delta = 0;
    1:         top = pivot = -1;
    1:         sdtop = NULL;
    1:         pc = NULL;
    1:         op = JSOP_NOP;
    1:         type = 0;
    1: #ifdef DEBUG_brendan
    1:         passes++;
    1: #endif
    1: 
    1:         for (sd = sdbase; sd < sdlimit; sd++) {
    1:             JS_ASSERT(JT_HAS_TAG(sd->target));
    1:             sd->offset += delta;
    1: 
    1:             if (sd->top != top) {
    1:                 sdtop = sd;
    1:                 top = sd->top;
    1:                 JS_ASSERT(top == sd->before);
    1:                 pivot = sd->offset;
    1:                 pc = base + top;
    1:                 op = (JSOp) *pc;
11377:                 type = JOF_OPTYPE(op);
    1:                 if (JOF_TYPE_IS_EXTENDED_JUMP(type)) {
    1:                     /*
    1:                      * We already extended all the jump offset operands for
    1:                      * the opcode at sd->top.  Jumps and branches have only
    1:                      * one jump offset operand, but switches have many, all
    1:                      * of which are adjacent in cg->spanDeps.
    1:                      */
    1:                     continue;
    1:                 }
    1: 
    1:                 JS_ASSERT(type == JOF_JUMP ||
    1:                           type == JOF_TABLESWITCH ||
    1:                           type == JOF_LOOKUPSWITCH);
    1:             }
    1: 
    1:             if (!JOF_TYPE_IS_EXTENDED_JUMP(type)) {
    1:                 span = SD_SPAN(sd, pivot);
    1:                 if (span < JUMP_OFFSET_MIN || JUMP_OFFSET_MAX < span) {
    1:                     ptrdiff_t deltaFromTop = 0;
    1: 
    1:                     done = JS_FALSE;
    1: 
    1:                     switch (op) {
    1:                       case JSOP_GOTO:         op = JSOP_GOTOX; break;
    1:                       case JSOP_IFEQ:         op = JSOP_IFEQX; break;
    1:                       case JSOP_IFNE:         op = JSOP_IFNEX; break;
    1:                       case JSOP_OR:           op = JSOP_ORX; break;
    1:                       case JSOP_AND:          op = JSOP_ANDX; break;
    1:                       case JSOP_GOSUB:        op = JSOP_GOSUBX; break;
    1:                       case JSOP_CASE:         op = JSOP_CASEX; break;
    1:                       case JSOP_DEFAULT:      op = JSOP_DEFAULTX; break;
    1:                       case JSOP_TABLESWITCH:  op = JSOP_TABLESWITCHX; break;
    1:                       case JSOP_LOOKUPSWITCH: op = JSOP_LOOKUPSWITCHX; break;
    1:                       default:
    1:                         ReportStatementTooLarge(cx, cg);
    1:                         return JS_FALSE;
    1:                     }
    1:                     *pc = (jsbytecode) op;
    1: 
    1:                     for (sd2 = sdtop; sd2 < sdlimit && sd2->top == top; sd2++) {
    1:                         if (sd2 <= sd) {
    1:                             /*
    1:                              * sd2->offset already includes delta as it stood
    1:                              * before we entered this loop, but it must also
    1:                              * include the delta relative to top due to all the
    1:                              * extended jump offset immediates for the opcode
    1:                              * starting at top, which we extend in this loop.
    1:                              *
    1:                              * If there is only one extended jump offset, then
    1:                              * sd2->offset won't change and this for loop will
    1:                              * iterate once only.
    1:                              */
    1:                             sd2->offset += deltaFromTop;
    1:                             deltaFromTop += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
    1:                         } else {
    1:                             /*
    1:                              * sd2 comes after sd, and won't be revisited by
    1:                              * the outer for loop, so we have to increase its
    1:                              * offset by delta, not merely by deltaFromTop.
    1:                              */
    1:                             sd2->offset += delta;
    1:                         }
    1: 
    1:                         delta += JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN;
    1:                         UpdateJumpTargets(cg->jumpTargets, sd2->offset,
    1:                                           JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
    1:                     }
    1:                     sd = sd2 - 1;
    1:                 }
    1:             }
    1:         }
    1: 
    1:         growth += delta;
    1:     } while (!done);
    1: 
    1:     if (growth) {
    1: #ifdef DEBUG_brendan
10217:         JSTokenStream *ts = &cg->treeContext.parseContext->tokenStream;
10217: 
    1:         printf("%s:%u: %u/%u jumps extended in %d passes (%d=%d+%d)\n",
10217:                ts->filename ? ts->filename : "stdin", cg->firstLine,
    1:                growth / (JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN), cg->numSpanDeps,
    1:                passes, offset + growth, offset, growth);
    1: #endif
    1: 
    1:         /*
    1:          * Ensure that we have room for the extended jumps, but don't round up
    1:          * to a power of two -- we're done generating code, so we cut to fit.
    1:          */
    1:         limit = CG_LIMIT(cg);
    1:         length = offset + growth;
    1:         next = base + length;
    1:         if (next > limit) {
    1:             JS_ASSERT(length > BYTECODE_CHUNK);
    1:             size = BYTECODE_SIZE(PTRDIFF(limit, base, jsbytecode));
    1:             incr = BYTECODE_SIZE(length) - size;
    1:             JS_ARENA_GROW_CAST(base, jsbytecode *, cg->codePool, size, incr);
    1:             if (!base) {
 8296:                 js_ReportOutOfScriptQuota(cx);
    1:                 return JS_FALSE;
    1:             }
    1:             CG_BASE(cg) = base;
    1:             CG_LIMIT(cg) = next = base + length;
    1:         }
    1:         CG_NEXT(cg) = next;
    1: 
    1:         /*
    1:          * Set up a fake span dependency record to guard the end of the code
    1:          * being generated.  This guard record is returned as a fencepost by
    1:          * FindNearestSpanDep if there is no real spandep at or above a given
    1:          * unextended code offset.
    1:          */
    1:         guard.top = -1;
    1:         guard.offset = offset + growth;
    1:         guard.before = offset;
    1:         guard.target = NULL;
    1:     }
    1: 
    1:     /*
    1:      * Now work backwards through the span dependencies, copying chunks of
    1:      * bytecode between each extended jump toward the end of the grown code
    1:      * space, and restoring immediate offset operands for all jump bytecodes.
    1:      * The first chunk of bytecodes, starting at base and ending at the first
    1:      * extended jump offset (NB: this chunk includes the operation bytecode
    1:      * just before that immediate jump offset), doesn't need to be copied.
    1:      */
    1:     JS_ASSERT(sd == sdlimit);
    1:     top = -1;
    1:     while (--sd >= sdbase) {
    1:         if (sd->top != top) {
    1:             top = sd->top;
    1:             op = (JSOp) base[top];
11377:             type = JOF_OPTYPE(op);
    1: 
    1:             for (sd2 = sd - 1; sd2 >= sdbase && sd2->top == top; sd2--)
    1:                 continue;
    1:             sd2++;
    1:             pivot = sd2->offset;
    1:             JS_ASSERT(top == sd2->before);
    1:         }
    1: 
    1:         oldpc = base + sd->before;
    1:         span = SD_SPAN(sd, pivot);
    1: 
    1:         /*
    1:          * If this jump didn't need to be extended, restore its span immediate
    1:          * offset operand now, overwriting the index of sd within cg->spanDeps
    1:          * that was stored temporarily after *pc when BuildSpanDepTable ran.
    1:          *
    1:          * Note that span might fit in 16 bits even for an extended jump op,
    1:          * if the op has multiple span operands, not all of which overflowed
    1:          * (e.g. JSOP_LOOKUPSWITCH or JSOP_TABLESWITCH where some cases are in
    1:          * range for a short jump, but others are not).
    1:          */
    1:         if (!JOF_TYPE_IS_EXTENDED_JUMP(type)) {
    1:             JS_ASSERT(JUMP_OFFSET_MIN <= span && span <= JUMP_OFFSET_MAX);
    1:             SET_JUMP_OFFSET(oldpc, span);
    1:             continue;
    1:         }
    1: 
    1:         /*
    1:          * Set up parameters needed to copy the next run of bytecode starting
    1:          * at offset (which is a cursor into the unextended, original bytecode
    1:          * vector), down to sd->before (a cursor of the same scale as offset,
    1:          * it's the index of the original jump pc).  Reuse delta to count the
    1:          * nominal number of bytes to copy.
    1:          */
    1:         pc = base + sd->offset;
    1:         delta = offset - sd->before;
    1:         JS_ASSERT(delta >= 1 + JUMP_OFFSET_LEN);
    1: 
    1:         /*
    1:          * Don't bother copying the jump offset we're about to reset, but do
    1:          * copy the bytecode at oldpc (which comes just before its immediate
    1:          * jump offset operand), on the next iteration through the loop, by
    1:          * including it in offset's new value.
    1:          */
    1:         offset = sd->before + 1;
    1:         size = BYTECODE_SIZE(delta - (1 + JUMP_OFFSET_LEN));
    1:         if (size) {
    1:             memmove(pc + 1 + JUMPX_OFFSET_LEN,
    1:                     oldpc + 1 + JUMP_OFFSET_LEN,
    1:                     size);
    1:         }
    1: 
    1:         SET_JUMPX_OFFSET(pc, span);
    1:     }
    1: 
    1:     if (growth) {
    1:         /*
    1:          * Fix source note deltas.  Don't hardwire the delta fixup adjustment,
    1:          * even though currently it must be JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN
    1:          * at each sd that moved.  The future may bring different offset sizes
    1:          * for span-dependent instruction operands.  However, we fix only main
    1:          * notes here, not prolog notes -- we know that prolog opcodes are not
    1:          * span-dependent, and aren't likely ever to be.
    1:          */
    1:         offset = growth = 0;
    1:         sd = sdbase;
    1:         for (sn = cg->main.notes, snlimit = sn + cg->main.noteCount;
    1:              sn < snlimit;
    1:              sn = SN_NEXT(sn)) {
    1:             /*
    1:              * Recall that the offset of a given note includes its delta, and
    1:              * tells the offset of the annotated bytecode from the main entry
    1:              * point of the script.
    1:              */
    1:             offset += SN_DELTA(sn);
    1:             while (sd < sdlimit && sd->before < offset) {
    1:                 /*
    1:                  * To compute the delta to add to sn, we need to look at the
    1:                  * spandep after sd, whose offset - (before + growth) tells by
    1:                  * how many bytes sd's instruction grew.
    1:                  */
    1:                 sd2 = sd + 1;
    1:                 if (sd2 == sdlimit)
    1:                     sd2 = &guard;
    1:                 delta = sd2->offset - (sd2->before + growth);
    1:                 if (delta > 0) {
    1:                     JS_ASSERT(delta == JUMPX_OFFSET_LEN - JUMP_OFFSET_LEN);
    1:                     sn = js_AddToSrcNoteDelta(cx, cg, sn, delta);
    1:                     if (!sn)
    1:                         return JS_FALSE;
    1:                     snlimit = cg->main.notes + cg->main.noteCount;
    1:                     growth += delta;
    1:                 }
    1:                 sd++;
    1:             }
    1: 
    1:             /*
    1:              * If sn has span-dependent offset operands, check whether each
    1:              * covers further span-dependencies, and increase those operands
    1:              * accordingly.  Some source notes measure offset not from the
    1:              * annotated pc, but from that pc plus some small bias.  NB: we
    1:              * assume that spec->offsetBias can't itself span span-dependent
    1:              * instructions!
    1:              */
    1:             spec = &js_SrcNoteSpec[SN_TYPE(sn)];
    1:             if (spec->isSpanDep) {
    1:                 pivot = offset + spec->offsetBias;
    1:                 n = spec->arity;
    1:                 for (i = 0; i < n; i++) {
    1:                     span = js_GetSrcNoteOffset(sn, i);
    1:                     if (span == 0)
    1:                         continue;
    1:                     target = pivot + span * spec->isSpanDep;
    1:                     sd2 = FindNearestSpanDep(cg, target,
    1:                                              (target >= pivot)
    1:                                              ? sd - sdbase
    1:                                              : 0,
    1:                                              &guard);
    1: 
    1:                     /*
    1:                      * Increase target by sd2's before-vs-after offset delta,
    1:                      * which is absolute (i.e., relative to start of script,
    1:                      * as is target).  Recompute the span by subtracting its
    1:                      * adjusted pivot from target.
    1:                      */
    1:                     target += sd2->offset - sd2->before;
    1:                     span = target - (pivot + growth);
    1:                     span *= spec->isSpanDep;
    1:                     noteIndex = sn - cg->main.notes;
    1:                     if (!js_SetSrcNoteOffset(cx, cg, noteIndex, i, span))
    1:                         return JS_FALSE;
    1:                     sn = cg->main.notes + noteIndex;
    1:                     snlimit = cg->main.notes + cg->main.noteCount;
    1:                 }
    1:             }
    1:         }
    1:         cg->main.lastNoteOffset += growth;
    1: 
    1:         /*
    1:          * Fix try/catch notes (O(numTryNotes * log2(numSpanDeps)), but it's
    1:          * not clear how we can beat that).
    1:          */
 3025:         for (tryNode = cg->lastTryNode; tryNode; tryNode = tryNode->prev) {
    1:             /*
    1:              * First, look for the nearest span dependency at/above tn->start.
    1:              * There may not be any such spandep, in which case the guard will
    1:              * be returned.
    1:              */
 3025:             offset = tryNode->note.start;
    1:             sd = FindNearestSpanDep(cg, offset, 0, &guard);
    1:             delta = sd->offset - sd->before;
 3025:             tryNode->note.start = offset + delta;
    1: 
    1:             /*
    1:              * Next, find the nearest spandep at/above tn->start + tn->length.
    1:              * Use its delta minus tn->start's delta to increase tn->length.
    1:              */
 3025:             length = tryNode->note.length;
    1:             sd2 = FindNearestSpanDep(cg, offset + length, sd - sdbase, &guard);
 3025:             if (sd2 != sd) {
 3025:                 tryNode->note.length =
 3025:                     length + sd2->offset - sd2->before - delta;
 3025:             }
    1:         }
    1:     }
    1: 
    1: #ifdef DEBUG_brendan
    1:   {
    1:     uintN bigspans = 0;
    1:     top = -1;
    1:     for (sd = sdbase; sd < sdlimit; sd++) {
    1:         offset = sd->offset;
    1: 
    1:         /* NB: sd->top cursors into the original, unextended bytecode vector. */
    1:         if (sd->top != top) {
    1:             JS_ASSERT(top == -1 ||
    1:                       !JOF_TYPE_IS_EXTENDED_JUMP(type) ||
    1:                       bigspans != 0);
    1:             bigspans = 0;
    1:             top = sd->top;
    1:             JS_ASSERT(top == sd->before);
    1:             op = (JSOp) base[offset];
11377:             type = JOF_OPTYPE(op);
    1:             JS_ASSERT(type == JOF_JUMP ||
    1:                       type == JOF_JUMPX ||
    1:                       type == JOF_TABLESWITCH ||
    1:                       type == JOF_TABLESWITCHX ||
    1:                       type == JOF_LOOKUPSWITCH ||
    1:                       type == JOF_LOOKUPSWITCHX);
    1:             pivot = offset;
    1:         }
    1: 
    1:         pc = base + offset;
    1:         if (JOF_TYPE_IS_EXTENDED_JUMP(type)) {
    1:             span = GET_JUMPX_OFFSET(pc);
    1:             if (span < JUMP_OFFSET_MIN || JUMP_OFFSET_MAX < span) {
    1:                 bigspans++;
    1:             } else {
    1:                 JS_ASSERT(type == JOF_TABLESWITCHX ||
    1:                           type == JOF_LOOKUPSWITCHX);
    1:             }
    1:         } else {
    1:             span = GET_JUMP_OFFSET(pc);
    1:         }
    1:         JS_ASSERT(SD_SPAN(sd, pivot) == span);
    1:     }
    1:     JS_ASSERT(!JOF_TYPE_IS_EXTENDED_JUMP(type) || bigspans != 0);
    1:   }
    1: #endif
    1: 
    1:     /*
    1:      * Reset so we optimize at most once -- cg may be used for further code
    1:      * generation of successive, independent, top-level statements.  No jump
    1:      * can span top-level statements, because JS lacks goto.
    1:      */
    1:     size = SPANDEPS_SIZE(JS_BIT(JS_CeilingLog2(cg->numSpanDeps)));
11836:     JS_free(cx, cg->spanDeps);
    1:     cg->spanDeps = NULL;
    1:     FreeJumpTargets(cg, cg->jumpTargets);
    1:     cg->jumpTargets = NULL;
    1:     cg->numSpanDeps = cg->numJumpTargets = 0;
    1:     cg->spanDepTodo = CG_OFFSET(cg);
    1:     return JS_TRUE;
    1: }
    1: 
18998: static ptrdiff_t
    1: EmitJump(JSContext *cx, JSCodeGenerator *cg, JSOp op, ptrdiff_t off)
    1: {
    1:     JSBool extend;
    1:     ptrdiff_t jmp;
    1:     jsbytecode *pc;
    1: 
    1:     extend = off < JUMP_OFFSET_MIN || JUMP_OFFSET_MAX < off;
    1:     if (extend && !cg->spanDeps && !BuildSpanDepTable(cx, cg))
18998:         return -1;
    1: 
    1:     jmp = js_Emit3(cx, cg, op, JUMP_OFFSET_HI(off), JUMP_OFFSET_LO(off));
    1:     if (jmp >= 0 && (extend || cg->spanDeps)) {
    1:         pc = CG_CODE(cg, jmp);
    1:         if (!AddSpanDep(cx, cg, pc, pc, off))
18998:             return -1;
    1:     }
    1:     return jmp;
    1: }
    1: 
    1: static ptrdiff_t
    1: GetJumpOffset(JSCodeGenerator *cg, jsbytecode *pc)
    1: {
    1:     JSSpanDep *sd;
    1:     JSJumpTarget *jt;
    1:     ptrdiff_t top;
    1: 
    1:     if (!cg->spanDeps)
    1:         return GET_JUMP_OFFSET(pc);
    1: 
    1:     sd = GetSpanDep(cg, pc);
    1:     jt = sd->target;
    1:     if (!JT_HAS_TAG(jt))
    1:         return JT_TO_BPDELTA(jt);
    1: 
    1:     top = sd->top;
    1:     while (--sd >= cg->spanDeps && sd->top == top)
    1:         continue;
    1:     sd++;
    1:     return JT_CLR_TAG(jt)->offset - sd->offset;
    1: }
    1: 
    1: JSBool
    1: js_SetJumpOffset(JSContext *cx, JSCodeGenerator *cg, jsbytecode *pc,
    1:                  ptrdiff_t off)
    1: {
    1:     if (!cg->spanDeps) {
    1:         if (JUMP_OFFSET_MIN <= off && off <= JUMP_OFFSET_MAX) {
    1:             SET_JUMP_OFFSET(pc, off);
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         if (!BuildSpanDepTable(cx, cg))
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     return SetSpanDepTarget(cx, cg, GetSpanDep(cg, pc), off);
    1: }
    1: 
    1: JSBool
    1: js_InStatement(JSTreeContext *tc, JSStmtType type)
    1: {
    1:     JSStmtInfo *stmt;
    1: 
    1:     for (stmt = tc->topStmt; stmt; stmt = stmt->down) {
    1:         if (stmt->type == type)
    1:             return JS_TRUE;
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: void
    1: js_PushStatement(JSTreeContext *tc, JSStmtInfo *stmt, JSStmtType type,
    1:                  ptrdiff_t top)
    1: {
    1:     stmt->type = type;
    1:     stmt->flags = 0;
    1:     SET_STATEMENT_TOP(stmt, top);
 3235:     stmt->u.label = NULL;
 3235:     JS_ASSERT(!stmt->u.blockObj);
    1:     stmt->down = tc->topStmt;
    1:     tc->topStmt = stmt;
    1:     if (STMT_LINKS_SCOPE(stmt)) {
    1:         stmt->downScope = tc->topScopeStmt;
    1:         tc->topScopeStmt = stmt;
    1:     } else {
    1:         stmt->downScope = NULL;
    1:     }
    1: }
    1: 
    1: void
 3235: js_PushBlockScope(JSTreeContext *tc, JSStmtInfo *stmt, JSObject *blockObj,
    1:                   ptrdiff_t top)
    1: {
    1: 
    1:     js_PushStatement(tc, stmt, STMT_BLOCK, top);
    1:     stmt->flags |= SIF_SCOPE;
    1:     STOBJ_SET_PARENT(blockObj, tc->blockChain);
    1:     stmt->downScope = tc->topScopeStmt;
    1:     tc->topScopeStmt = stmt;
    1:     tc->blockChain = blockObj;
 3235:     stmt->u.blockObj = blockObj;
    1: }
    1: 
    1: /*
    1:  * Emit a backpatch op with offset pointing to the previous jump of this type,
    1:  * so that we can walk back up the chain fixing up the op and jump offset.
    1:  */
    1: static ptrdiff_t
    1: EmitBackPatchOp(JSContext *cx, JSCodeGenerator *cg, JSOp op, ptrdiff_t *lastp)
    1: {
    1:     ptrdiff_t offset, delta;
    1: 
    1:     offset = CG_OFFSET(cg);
    1:     delta = offset - *lastp;
    1:     *lastp = offset;
    1:     JS_ASSERT(delta > 0);
    1:     return EmitJump(cx, cg, op, delta);
    1: }
    1: 
    1: /*
    1:  * Macro to emit a bytecode followed by a uint16 immediate operand stored in
    1:  * big-endian order, used for arg and var numbers as well as for atomIndexes.
    1:  * NB: We use cx and cg from our caller's lexical environment, and return
    1:  * false on error.
    1:  */
    1: #define EMIT_UINT16_IMM_OP(op, i)                                             \
    1:     JS_BEGIN_MACRO                                                            \
 3383:         if (js_Emit3(cx, cg, op, UINT16_HI(i), UINT16_LO(i)) < 0)             \
    1:             return JS_FALSE;                                                  \
    1:     JS_END_MACRO
    1: 
 1227: static JSBool
 1227: FlushPops(JSContext *cx, JSCodeGenerator *cg, intN *npops)
 1227: {
 1227:     JS_ASSERT(*npops != 0);
 1227:     if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
 1227:         return JS_FALSE;
 1227:     EMIT_UINT16_IMM_OP(JSOP_POPN, *npops);
 1227:     *npops = 0;
 1227:     return JS_TRUE;
 1227: }
 1227: 
 1227: /*
 1227:  * Emit additional bytecode(s) for non-local jumps.
 1227:  */
    1: static JSBool
11758: EmitNonLocalJumpFixup(JSContext *cx, JSCodeGenerator *cg, JSStmtInfo *toStmt)
    1: {
 1227:     intN depth, npops;
    1:     JSStmtInfo *stmt;
    1: 
    1:     /*
    1:      * The non-local jump fixup we emit will unbalance cg->stackDepth, because
    1:      * the fixup replicates balanced code such as JSOP_LEAVEWITH emitted at the
    1:      * end of a with statement, so we save cg->stackDepth here and restore it
    1:      * just before a successful return.
    1:      */
    1:     depth = cg->stackDepth;
 1227:     npops = 0;
 1227: 
 1227: #define FLUSH_POPS() if (npops && !FlushPops(cx, cg, &npops)) return JS_FALSE
 1227: 
    1:     for (stmt = cg->treeContext.topStmt; stmt != toStmt; stmt = stmt->down) {
    1:         switch (stmt->type) {
    1:           case STMT_FINALLY:
 1227:             FLUSH_POPS();
    1:             if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
    1:                 return JS_FALSE;
11758:             if (EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &GOSUBS(*stmt)) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case STMT_WITH:
    1:             /* There's a With object on the stack that we need to pop. */
 1227:             FLUSH_POPS();
    1:             if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_LEAVEWITH) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case STMT_FOR_IN_LOOP:
    1:             /*
    1:              * The iterator and the object being iterated need to be popped.
    1:              */
 1227:             FLUSH_POPS();
    1:             if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_ENDITER) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case STMT_SUBROUTINE:
    1:             /*
    1:              * There's a [exception or hole, retsub pc-index] pair on the
    1:              * stack that we need to pop.
    1:              */
 1227:             npops += 2;
    1:             break;
    1: 
    1:           default:;
    1:         }
    1: 
    1:         if (stmt->flags & SIF_SCOPE) {
    1:             uintN i;
    1: 
    1:             /* There is a Block object with locals on the stack to pop. */
 1227:             FLUSH_POPS();
    1:             if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
    1:                 return JS_FALSE;
 3235:             i = OBJ_BLOCK_COUNT(cx, stmt->u.blockObj);
    1:             EMIT_UINT16_IMM_OP(JSOP_LEAVEBLOCK, i);
    1:         }
    1:     }
    1: 
 1227:     FLUSH_POPS();
    1:     cg->stackDepth = depth;
    1:     return JS_TRUE;
 1227: 
 1227: #undef FLUSH_POPS
    1: }
    1: 
    1: static ptrdiff_t
    1: EmitGoto(JSContext *cx, JSCodeGenerator *cg, JSStmtInfo *toStmt,
    1:          ptrdiff_t *lastp, JSAtomListElement *label, JSSrcNoteType noteType)
    1: {
    1:     intN index;
    1: 
11758:     if (!EmitNonLocalJumpFixup(cx, cg, toStmt))
    1:         return -1;
    1: 
    1:     if (label)
    1:         index = js_NewSrcNote2(cx, cg, noteType, (ptrdiff_t) ALE_INDEX(label));
    1:     else if (noteType != SRC_NULL)
    1:         index = js_NewSrcNote(cx, cg, noteType);
    1:     else
    1:         index = 0;
    1:     if (index < 0)
    1:         return -1;
    1: 
    1:     return EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, lastp);
    1: }
    1: 
    1: static JSBool
    1: BackPatch(JSContext *cx, JSCodeGenerator *cg, ptrdiff_t last,
    1:           jsbytecode *target, jsbytecode op)
    1: {
    1:     jsbytecode *pc, *stop;
    1:     ptrdiff_t delta, span;
    1: 
    1:     pc = CG_CODE(cg, last);
    1:     stop = CG_CODE(cg, -1);
    1:     while (pc != stop) {
    1:         delta = GetJumpOffset(cg, pc);
    1:         span = PTRDIFF(target, pc, jsbytecode);
    1:         CHECK_AND_SET_JUMP_OFFSET(cx, cg, pc, span);
    1: 
    1:         /*
    1:          * Set *pc after jump offset in case bpdelta didn't overflow, but span
    1:          * does (if so, CHECK_AND_SET_JUMP_OFFSET might call BuildSpanDepTable
    1:          * and need to see the JSOP_BACKPATCH* op at *pc).
    1:          */
    1:         *pc = op;
    1:         pc -= delta;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: void
    1: js_PopStatement(JSTreeContext *tc)
    1: {
    1:     JSStmtInfo *stmt;
    1: 
    1:     stmt = tc->topStmt;
    1:     tc->topStmt = stmt->down;
    1:     if (STMT_LINKS_SCOPE(stmt)) {
    1:         tc->topScopeStmt = stmt->downScope;
10217:         if (stmt->flags & SIF_SCOPE) {
 3235:             tc->blockChain = STOBJ_GET_PARENT(stmt->u.blockObj);
16072:             JS_SCOPE_DEPTH_METERING(--tc->scopeDepth);
10217:         }
    1:     }
    1: }
    1: 
    1: JSBool
    1: js_PopStatementCG(JSContext *cx, JSCodeGenerator *cg)
    1: {
    1:     JSStmtInfo *stmt;
    1: 
    1:     stmt = cg->treeContext.topStmt;
    1:     if (!STMT_IS_TRYING(stmt) &&
    1:         (!BackPatch(cx, cg, stmt->breaks, CG_NEXT(cg), JSOP_GOTO) ||
    1:          !BackPatch(cx, cg, stmt->continues, CG_CODE(cg, stmt->update),
    1:                     JSOP_GOTO))) {
    1:         return JS_FALSE;
    1:     }
    1:     js_PopStatement(&cg->treeContext);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_DefineCompileTimeConstant(JSContext *cx, JSCodeGenerator *cg, JSAtom *atom,
    1:                              JSParseNode *pn)
    1: {
    1:     jsdouble dval;
    1:     jsint ival;
    1:     JSAtom *valueAtom;
 3328:     jsval v;
    1:     JSAtomListElement *ale;
    1: 
    1:     /* XXX just do numbers for now */
    1:     if (pn->pn_type == TOK_NUMBER) {
    1:         dval = pn->pn_dval;
 3328:         if (JSDOUBLE_IS_INT(dval, ival) && INT_FITS_IN_JSVAL(ival)) {
 3328:             v = INT_TO_JSVAL(ival);
 3328:         } else {
 3328:             /*
 3328:              * We atomize double to root a jsdouble instance that we wrap as
 3328:              * jsval and store in cg->constList. This works because atoms are
 3328:              * protected from GC during compilation.
 3328:              */
 3328:             valueAtom = js_AtomizeDouble(cx, dval);
    1:             if (!valueAtom)
    1:                 return JS_FALSE;
 3328:             v = ATOM_KEY(valueAtom);
 3328:         }
    1:         ale = js_IndexAtom(cx, atom, &cg->constList);
    1:         if (!ale)
    1:             return JS_FALSE;
18308:         ALE_SET_VALUE(ale, v);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSStmtInfo *
16378: js_LexicalLookup(JSTreeContext *tc, JSAtom *atom, jsint *slotp)
    1: {
    1:     JSStmtInfo *stmt;
    1:     JSObject *obj;
    1:     JSScope *scope;
    1:     JSScopeProperty *sprop;
    1: 
    1:     for (stmt = tc->topScopeStmt; stmt; stmt = stmt->downScope) {
16378:         if (stmt->type == STMT_WITH)
16378:             break;
    1: 
    1:         /* Skip "maybe scope" statements that don't contain let bindings. */
    1:         if (!(stmt->flags & SIF_SCOPE))
    1:             continue;
    1: 
 3235:         obj = stmt->u.blockObj;
    1:         JS_ASSERT(LOCKED_OBJ_GET_CLASS(obj) == &js_BlockClass);
    1:         scope = OBJ_SCOPE(obj);
    1:         sprop = SCOPE_GET_PROPERTY(scope, ATOM_TO_JSID(atom));
    1:         if (sprop) {
    1:             JS_ASSERT(sprop->flags & SPROP_HAS_SHORTID);
    1: 
    1:             if (slotp) {
18567:                 JS_ASSERT(JSVAL_IS_INT(obj->fslots[JSSLOT_BLOCK_DEPTH]));
18567:                 *slotp = JSVAL_TO_INT(obj->fslots[JSSLOT_BLOCK_DEPTH]) +
18567:                          sprop->shortid;
    1:             }
    1:             return stmt;
    1:         }
    1:     }
    1: 
    1:     if (slotp)
    1:         *slotp = -1;
    1:     return stmt;
    1: }
    1: 
 8817: /*
 8817:  * Check if the attributes describe a property holding a compile-time constant
 8817:  * or a permanent, read-only property without a getter.
 8817:  */
 8817: #define IS_CONSTANT_PROPERTY(attrs)                                           \
 8817:     (((attrs) & (JSPROP_READONLY | JSPROP_PERMANENT | JSPROP_GETTER)) ==      \
 8817:      (JSPROP_READONLY | JSPROP_PERMANENT))
 8817: 
 8817: /*
 8817:  * The function sets vp to JSVAL_HOLE when the atom does not corresponds to a
 8817:  * name defining a constant.
 8817:  */
 8817: static JSBool
 8817: LookupCompileTimeConstant(JSContext *cx, JSCodeGenerator *cg, JSAtom *atom,
    1:                           jsval *vp)
    1: {
    1:     JSBool ok;
    1:     JSStmtInfo *stmt;
    1:     JSAtomListElement *ale;
    1:     JSObject *obj, *pobj;
    1:     JSProperty *prop;
    1:     uintN attrs;
    1: 
    1:     /*
 8444:      * Chase down the cg stack, but only until we reach the outermost cg.
    1:      * This enables propagating consts from top-level into switch cases in a
 8444:      * function compiled along with the top-level script.
    1:      */
 8817:     *vp = JSVAL_HOLE;
    1:     do {
18955:         if (cg->treeContext.flags & (TCF_IN_FUNCTION | TCF_COMPILE_N_GO)) {
    1:             /* XXX this will need revising when 'let const' is added. */
16378:             stmt = js_LexicalLookup(&cg->treeContext, atom, NULL);
    1:             if (stmt)
    1:                 return JS_TRUE;
    1: 
    1:             ATOM_LIST_SEARCH(ale, &cg->constList, atom);
    1:             if (ale) {
 8817:                 JS_ASSERT(ALE_VALUE(ale) != JSVAL_HOLE);
    1:                 *vp = ALE_VALUE(ale);
    1:                 return JS_TRUE;
    1:             }
    1: 
    1:             /*
    1:              * Try looking in the variable object for a direct property that
    1:              * is readonly and permanent.  We know such a property can't be
    1:              * shadowed by another property on obj's prototype chain, or a
    1:              * with object or catch variable; nor can prop's value be changed,
    1:              * nor can prop be deleted.
    1:              */
 8444:             if (cg->treeContext.flags & TCF_IN_FUNCTION) {
18955:                 if (js_LookupLocal(cx, cg->treeContext.u.fun, atom, NULL) !=
13691:                     JSLOCAL_NONE) {
 8179:                     break;
    1:                 }
18955:             } else {
18955:                 JS_ASSERT(cg->treeContext.flags & TCF_COMPILE_N_GO);
18955:                 obj = cg->treeContext.u.scopeChain;
 8444:                 ok = OBJ_LOOKUP_PROPERTY(cx, obj, ATOM_TO_JSID(atom), &pobj,
 8444:                                          &prop);
    1:                 if (!ok)
 8444:                     return JS_FALSE;
 8444:                 if (pobj == obj) {
    1:                     /*
    1:                      * We're compiling code that will be executed immediately,
    1:                      * not re-executed against a different scope chain and/or
    1:                      * variable object.  Therefore we can get constant values
    1:                      * from our variable object here.
    1:                      */
    1:                     ok = OBJ_GET_ATTRIBUTES(cx, obj, ATOM_TO_JSID(atom), prop,
    1:                                             &attrs);
 8817:                     if (ok && IS_CONSTANT_PROPERTY(attrs)) {
    1:                         ok = OBJ_GET_PROPERTY(cx, obj, ATOM_TO_JSID(atom), vp);
 8817:                         JS_ASSERT_IF(ok, *vp != JSVAL_HOLE);
 8817:                     }
    1:                 }
    1:                 if (prop)
    1:                     OBJ_DROP_PROPERTY(cx, pobj, prop);
 8444:                 if (!ok)
 8444:                     return JS_FALSE;
 8444:                 if (prop)
    1:                     break;
    1:             }
 8444:         }
    1:     } while ((cg = cg->parent) != NULL);
 8444:     return JS_TRUE;
    1: }
    1: 
    1: /*
 3235:  * Return JSOP_NOP to indicate that index fits 2 bytes and no index segment
 3235:  * reset instruction is necessary, JSOP_FALSE to indicate an error or either
 3235:  * JSOP_RESETBASE0 or JSOP_RESETBASE1 to indicate the reset bytecode to issue
 3235:  * after the main bytecode sequence.
 3235:  */
 3235: static JSOp
 3235: EmitBigIndexPrefix(JSContext *cx, JSCodeGenerator *cg, uintN index)
    1: {
 3235:     uintN indexBase;
 3235: 
 3235:     /*
 3235:      * We have max 3 bytes for indexes and check for INDEX_LIMIT overflow only
 3235:      * for big indexes.
 3235:      */
 3235:     JS_STATIC_ASSERT(INDEX_LIMIT <= JS_BIT(24));
 3235:     JS_STATIC_ASSERT(INDEX_LIMIT >=
 3235:                      (JSOP_INDEXBASE3 - JSOP_INDEXBASE1 + 2) << 16);
 3235: 
 3235:     if (index < JS_BIT(16))
    1:         return JSOP_NOP;
 3235:     indexBase = index >> 16;
 3235:     if (indexBase <= JSOP_INDEXBASE3 - JSOP_INDEXBASE1 + 1) {
 3383:         if (js_Emit1(cx, cg, (JSOp)(JSOP_INDEXBASE1 + indexBase - 1)) < 0)
 3182:             return JSOP_FALSE;
    1:         return JSOP_RESETBASE0;
    1:     }
 3235: 
 3235:     if (index >= INDEX_LIMIT) {
 3235:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 3235:                              JSMSG_TOO_MANY_LITERALS);
 3235:         return JSOP_FALSE;
 3235:     }
 3235: 
 3235:     if (js_Emit2(cx, cg, JSOP_INDEXBASE, (JSOp)indexBase) < 0)
 3182:         return JSOP_FALSE;
    1:     return JSOP_RESETBASE;
    1: }
    1: 
    1: /*
 3235:  * Emit a bytecode and its 2-byte constant index immediate operand. If the
 3235:  * index requires more than 2 bytes, emit a prefix op whose 8-bit immediate
 3235:  * operand effectively extends the 16-bit immediate of the prefixed opcode,
 3235:  * by changing index "segment" (see jsinterp.c). We optimize segments 1-3
 3235:  * with single-byte JSOP_INDEXBASE[123] codes.
    1:  *
    1:  * Such prefixing currently requires a suffix to restore the "zero segment"
    1:  * register setting, but this could be optimized further.
    1:  */
    1: static JSBool
 3235: EmitIndexOp(JSContext *cx, JSOp op, uintN index, JSCodeGenerator *cg)
    1: {
 3164:     JSOp bigSuffix;
    1: 
 3235:     bigSuffix = EmitBigIndexPrefix(cx, cg, index);
 3182:     if (bigSuffix == JSOP_FALSE)
    1:         return JS_FALSE;
 3235:     EMIT_UINT16_IMM_OP(op, index);
 3383:     return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
 3235: }
 3235: 
 3235: /*
 3235:  * Slight sugar for EmitIndexOp, again accessing cx and cg from the macro
    1:  * caller's lexical environment, and embedding a false return on error.
    1:  */
 3235: #define EMIT_INDEX_OP(op, index)                                              \
    1:     JS_BEGIN_MACRO                                                            \
 3235:         if (!EmitIndexOp(cx, op, index, cg))                                  \
    1:             return JS_FALSE;                                                  \
    1:     JS_END_MACRO
    1: 
24488: 
    1: static JSBool
    1: EmitAtomOp(JSContext *cx, JSParseNode *pn, JSOp op, JSCodeGenerator *cg)
    1: {
    1:     JSAtomListElement *ale;
    1: 
11377:     JS_ASSERT(JOF_OPTYPE(op) == JOF_ATOM);
11377:     if (op == JSOP_GETPROP &&
11377:         pn->pn_atom == cx->runtime->atomState.lengthAtom) {
11377:         return js_Emit1(cx, cg, JSOP_LENGTH) >= 0;
11377:     }
    1:     ale = js_IndexAtom(cx, pn->pn_atom, &cg->atomList);
    1:     if (!ale)
    1:         return JS_FALSE;
 3235:     return EmitIndexOp(cx, op, ALE_INDEX(ale), cg);
 3235: }
 3235: 
 3235: static uintN
 3235: IndexParsedObject(JSParsedObjectBox *pob, JSEmittedObjectList *list);
 3235: 
 3235: static JSBool
 3235: EmitObjectOp(JSContext *cx, JSParsedObjectBox *pob, JSOp op,
 3235:              JSCodeGenerator *cg)
 3235: {
11377:     JS_ASSERT(JOF_OPTYPE(op) == JOF_OBJECT);
 3235:     return EmitIndexOp(cx, op, IndexParsedObject(pob, &cg->objectList), cg);
    1: }
    1: 
    1: /*
16072:  * What good are ARGNO_LEN and SLOTNO_LEN, you ask?  The answer is that, apart
 4380:  * from EmitSlotIndexOp, they abstract out the detail that both are 2, and in
    1:  * other parts of the code there's no necessary relationship between the two.
 4380:  * The abstraction cracks here in order to share EmitSlotIndexOp code among
    1:  * the JSOP_DEFLOCALFUN and JSOP_GET{ARG,VAR,LOCAL}PROP cases.
    1:  */
    1: JS_STATIC_ASSERT(ARGNO_LEN == 2);
16072: JS_STATIC_ASSERT(SLOTNO_LEN == 2);
    1: 
    1: static JSBool
 4380: EmitSlotIndexOp(JSContext *cx, JSOp op, uintN slot, uintN index,
    1:                  JSCodeGenerator *cg)
    1: {
 3164:     JSOp bigSuffix;
    1:     ptrdiff_t off;
    1:     jsbytecode *pc;
    1: 
11377:     JS_ASSERT(JOF_OPTYPE(op) == JOF_SLOTATOM ||
11377:               JOF_OPTYPE(op) == JOF_SLOTOBJECT);
 3235:     bigSuffix = EmitBigIndexPrefix(cx, cg, index);
 3182:     if (bigSuffix == JSOP_FALSE)
    1:         return JS_FALSE;
    1: 
 3235:     /* Emit [op, slot, index]. */
 3235:     off = js_EmitN(cx, cg, op, 2 + INDEX_LEN);
    1:     if (off < 0)
    1:         return JS_FALSE;
    1:     pc = CG_CODE(cg, off);
    1:     SET_UINT16(pc, slot);
    1:     pc += 2;
 3235:     SET_INDEX(pc, index);
 3164:     return bigSuffix == JSOP_NOP || js_Emit1(cx, cg, bigSuffix) >= 0;
    1: }
    1: 
    1: /*
16072:  * Adjust the slot for a block local to account for the number of variables
16072:  * that share the same index space with locals. Due to the incremental code
16072:  * generation for top-level script, we do the adjustment via code patching in
16072:  * js_CompileScript; see comments there.
16072:  *
16072:  * The function returns -1 on failures.
16072:  */
16072: static jsint
16072: AdjustBlockSlot(JSContext *cx, JSCodeGenerator *cg, jsint slot)
16072: {
16072:     JS_ASSERT((jsuint) slot < cg->maxStackDepth);
16072:     if (cg->treeContext.flags & TCF_IN_FUNCTION) {
18955:         slot += cg->treeContext.u.fun->u.i.nvars;
16072:         if ((uintN) slot >= SLOTNO_LIMIT) {
16072:             js_ReportCompileErrorNumber(cx, CG_TS(cg), NULL,
16072:                                         JSREPORT_ERROR,
16072:                                         JSMSG_TOO_MANY_LOCALS);
16072:             slot = -1;
16072:         }
16072:     }
16072:     return slot;
16072: }
16072: 
16072: /*
    1:  * This routine tries to optimize name gets and sets to stack slot loads and
    1:  * stores, given the variables object and scope chain in cx's top frame, the
    1:  * compile-time context in tc, and a TOK_NAME node pn.  It returns false on
    1:  * error, true on success.
    1:  *
    1:  * The caller can inspect pn->pn_slot for a non-negative slot number to tell
    1:  * whether optimization occurred, in which case BindNameToSlot also updated
    1:  * pn->pn_op.  If pn->pn_slot is still -1 on return, pn->pn_op nevertheless
    1:  * may have been optimized, e.g., from JSOP_NAME to JSOP_ARGUMENTS.  Whether
    1:  * or not pn->pn_op was modified, if this function finds an argument or local
 8179:  * variable name, pn->pn_const will be true for const properties after a
    1:  * successful return.
    1:  *
    1:  * NB: if you add more opcodes specialized from JSOP_NAME, etc., don't forget
    1:  * to update the TOK_FOR (for-in) and TOK_ASSIGN (op=, e.g. +=) special cases
    1:  * in js_EmitTree.
    1:  */
    1: static JSBool
16378: BindNameToSlot(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn)
    1: {
 9604:     JSTreeContext *tc;
    1:     JSAtom *atom;
    1:     JSStmtInfo *stmt;
    1:     jsint slot;
    1:     JSOp op;
 8179:     JSLocalKind localKind;
 8179:     uintN index;
    1:     JSAtomListElement *ale;
 8837:     JSBool constOp;
    1: 
    1:     JS_ASSERT(pn->pn_type == TOK_NAME);
    1:     if (pn->pn_slot >= 0 || pn->pn_op == JSOP_ARGUMENTS)
    1:         return JS_TRUE;
    1: 
    1:     /* QNAME references can never be optimized to use arg/var storage. */
    1:     if (pn->pn_op == JSOP_QNAMEPART)
    1:         return JS_TRUE;
    1: 
    1:     /*
    1:      * We can't optimize if we are compiling a with statement and its body,
    1:      * or we're in a catch block whose exception variable has the same name
    1:      * as this node.  FIXME: we should be able to optimize catch vars to be
    1:      * block-locals.
    1:      */
 9604:     tc = &cg->treeContext;
    1:     atom = pn->pn_atom;
18084:     stmt = js_LexicalLookup(tc, atom, &slot);
18084:     if (stmt) {
    1:         if (stmt->type == STMT_WITH)
    1:             return JS_TRUE;
    1: 
    1:         JS_ASSERT(stmt->flags & SIF_SCOPE);
    1:         JS_ASSERT(slot >= 0);
 3164:         op = PN_OP(pn);
    1:         switch (op) {
    1:           case JSOP_NAME:     op = JSOP_GETLOCAL; break;
    1:           case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
    1:           case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
    1:           case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
    1:           case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
    1:           case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
    1:           case JSOP_FORNAME:  op = JSOP_FORLOCAL; break;
    1:           case JSOP_DELNAME:  op = JSOP_FALSE; break;
    1:           default: JS_ASSERT(0);
    1:         }
    1:         if (op != pn->pn_op) {
16072:             slot = AdjustBlockSlot(cx, cg, slot);
16072:             if (slot < 0)
16072:                 return JS_FALSE;
    1:             pn->pn_op = op;
    1:             pn->pn_slot = slot;
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * We can't optimize if var and closure (a local function not in a larger
    1:      * expression and not at top-level within another's body) collide.
    1:      * XXX suboptimal: keep track of colliding names and deoptimize only those
    1:      */
    1:     if (tc->flags & TCF_FUN_CLOSURE_VS_VAR)
    1:         return JS_TRUE;
    1: 
23122:     if (!(tc->flags & TCF_IN_FUNCTION)) {
18955:         JSStackFrame *caller;
18955: 
18955:         caller = tc->parseContext->callerFrame;
18955:         if (caller) {
18955:             JS_ASSERT(tc->flags & TCF_COMPILE_N_GO);
18955:             JS_ASSERT(caller->script);
18955:             if (!caller->fun || caller->varobj != tc->u.scopeChain)
18955:                 return JS_TRUE;
18955: 
18955:             /*
18955:              * We are compiling eval or debug script inside a function frame
18955:              * and the scope chain matches function's variable object.
18955:              * Optimize access to function's arguments and variable and the
18955:              * arguments object.
18955:              */
24615:             if (PN_OP(pn) != JSOP_NAME || cg->staticDepth > JS_DISPLAY_SIZE)
18955:                 goto arguments_check;
18955:             localKind = js_LookupLocal(cx, caller->fun, atom, &index);
18955:             if (localKind == JSLOCAL_NONE)
18955:                 goto arguments_check;
18955: 
23122:             /*
23122:              * Don't generate upvars on the left side of a for loop. See
23122:              * bug 470758.
23122:              */
23122:             if (tc->flags & TCF_IN_FOR_INIT)
23122:                 goto arguments_check;
23122: 
18308:             ATOM_LIST_SEARCH(ale, &cg->upvarList, atom);
18308:             if (!ale) {
21188:                 uint32 length, *vector;
18308: 
18308:                 ale = js_IndexAtom(cx, atom, &cg->upvarList);
18308:                 if (!ale)
18308:                     return JS_FALSE;
18308:                 JS_ASSERT(ALE_INDEX(ale) == cg->upvarList.count - 1);
18308: 
18308:                 length = cg->upvarMap.length;
18308:                 JS_ASSERT(ALE_INDEX(ale) <= length);
18308:                 if (ALE_INDEX(ale) == length) {
18308:                     length = 2 * JS_MAX(2, length);
18308:                     vector = (uint32 *)
18308:                              JS_realloc(cx, cg->upvarMap.vector,
18308:                                         length * sizeof *vector);
18308:                     if (!vector)
18308:                         return JS_FALSE;
18308:                     cg->upvarMap.vector = vector;
18308:                     cg->upvarMap.length = length;
18308:                 }
18308: 
18308:                 if (localKind != JSLOCAL_ARG)
18955:                     index += caller->fun->nargs;
18308:                 if (index >= JS_BIT(16)) {
18308:                     cg->treeContext.flags |= TCF_FUN_USES_NONLOCALS;
18308:                     return JS_TRUE;
18308:                 }
18308: 
21188:                 JS_ASSERT(cg->staticDepth > caller->fun->u.i.script->staticDepth);
21188:                 uintN skip = cg->staticDepth - caller->fun->u.i.script->staticDepth;
21188:                 cg->upvarMap.vector[ALE_INDEX(ale)] = MAKE_UPVAR_COOKIE(skip, index);
18308:             }
18308: 
18308:             pn->pn_op = JSOP_GETUPVAR;
18308:             pn->pn_slot = ALE_INDEX(ale);
18308:             return JS_TRUE;
18308:         }
    1: 
    1:         /*
11377:          * We are optimizing global variables and there may be no pre-existing
    1:          * global property named atom.  If atom was declared via const or var,
11377:          * optimize pn to access fp->vars using the appropriate JSOP_*GVAR op.
    1:          */
    1:         ATOM_LIST_SEARCH(ale, &tc->decls, atom);
    1:         if (!ale) {
    1:             /* Use precedes declaration, or name is never declared. */
    1:             return JS_TRUE;
    1:         }
 8837:         constOp = (ALE_JSOP(ale) == JSOP_DEFCONST);
    1: 
    1:         /* Index atom so we can map fast global number to name. */
 9604:         ale = js_IndexAtom(cx, atom, &cg->atomList);
    1:         if (!ale)
    1:             return JS_FALSE;
    1: 
 3235:         /* Defend against tc->ngvars 16-bit overflow. */
    1:         slot = ALE_INDEX(ale);
    1:         if ((slot + 1) >> 16)
    1:             return JS_TRUE;
    1: 
 3235:         if ((uint16)(slot + 1) > tc->ngvars)
 3235:             tc->ngvars = (uint16)(slot + 1);
 8179: 
 8179:         op = PN_OP(pn);
    1:         switch (op) {
    1:           case JSOP_NAME:     op = JSOP_GETGVAR; break;
    1:           case JSOP_SETNAME:  op = JSOP_SETGVAR; break;
    1:           case JSOP_SETCONST: /* NB: no change */ break;
    1:           case JSOP_INCNAME:  op = JSOP_INCGVAR; break;
    1:           case JSOP_NAMEINC:  op = JSOP_GVARINC; break;
    1:           case JSOP_DECNAME:  op = JSOP_DECGVAR; break;
    1:           case JSOP_NAMEDEC:  op = JSOP_GVARDEC; break;
    1:           case JSOP_FORNAME:  /* NB: no change */ break;
    1:           case JSOP_DELNAME:  /* NB: no change */ break;
18308:           default: JS_NOT_REACHED("gvar");
    1:         }
 8837:         pn->pn_const = constOp;
 8179:         if (op != pn->pn_op) {
 8179:             pn->pn_op = op;
 8179:             pn->pn_slot = slot;
 8179:         }
 8179:         return JS_TRUE;
 8179:     }
 8179: 
 8444:     if (tc->flags & TCF_IN_FUNCTION) {
 8179:         /*
 8179:          * We are compiling a function body and may be able to optimize name
 8179:          * to stack slot. Look for an argument or variable in the function and
 8179:          * rewrite pn_op and update pn accordingly.
 8179:          */
18955:         localKind = js_LookupLocal(cx, tc->u.fun, atom, &index);
 8179:         if (localKind != JSLOCAL_NONE) {
 8179:             op = PN_OP(pn);
 8179:             if (localKind == JSLOCAL_ARG) {
 8179:                 switch (op) {
 8179:                   case JSOP_NAME:     op = JSOP_GETARG; break;
 8179:                   case JSOP_SETNAME:  op = JSOP_SETARG; break;
 8179:                   case JSOP_INCNAME:  op = JSOP_INCARG; break;
 8179:                   case JSOP_NAMEINC:  op = JSOP_ARGINC; break;
 8179:                   case JSOP_DECNAME:  op = JSOP_DECARG; break;
 8179:                   case JSOP_NAMEDEC:  op = JSOP_ARGDEC; break;
 8179:                   case JSOP_FORNAME:  op = JSOP_FORARG; break;
 8179:                   case JSOP_DELNAME:  op = JSOP_FALSE; break;
18308:                   default: JS_NOT_REACHED("arg");
 8179:                 }
 8179:                 pn->pn_const = JS_FALSE;
 8179:             } else {
 8179:                 JS_ASSERT(localKind == JSLOCAL_VAR ||
 8179:                           localKind == JSLOCAL_CONST);
    1:                 switch (op) {
16429:                   case JSOP_NAME:     op = JSOP_GETLOCAL; break;
16429:                   case JSOP_SETNAME:  op = JSOP_SETLOCAL; break;
16429:                   case JSOP_SETCONST: op = JSOP_SETLOCAL; break;
16429:                   case JSOP_INCNAME:  op = JSOP_INCLOCAL; break;
16429:                   case JSOP_NAMEINC:  op = JSOP_LOCALINC; break;
16429:                   case JSOP_DECNAME:  op = JSOP_DECLOCAL; break;
16429:                   case JSOP_NAMEDEC:  op = JSOP_LOCALDEC; break;
16429:                   case JSOP_FORNAME:  op = JSOP_FORLOCAL; break;
    1:                   case JSOP_DELNAME:  op = JSOP_FALSE; break;
18308:                   default: JS_NOT_REACHED("local");
    1:                 }
 8179:                 pn->pn_const = (localKind == JSLOCAL_CONST);
 8179:             }
    1:             pn->pn_op = op;
 8179:             pn->pn_slot = index;
 8179:             return JS_TRUE;
 8179:         }
 8444:         tc->flags |= TCF_FUN_USES_NONLOCALS;
 8179:     }
 8179: 
18955:   arguments_check:
18955:     /*
18955:      * Here we either compiling a function body or an eval or debug script
18955:      * inside a function and couldn't optimize pn, so it's not a global or
18955:      * local slot name. We are also outside of any with blocks. Check if we
18955:      * can optimize the predefined arguments variable.
18955:      */
18955:     JS_ASSERT((tc->flags & TCF_IN_FUNCTION) ||
18955:               (tc->parseContext->callerFrame &&
18955:                tc->parseContext->callerFrame->fun &&
18955:                tc->parseContext->callerFrame->varobj == tc->u.scopeChain));
    1:     if (pn->pn_op == JSOP_NAME &&
    1:         atom == cx->runtime->atomState.argumentsAtom) {
    1:         pn->pn_op = JSOP_ARGUMENTS;
    1:         return JS_TRUE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * If pn contains a useful expression, return true with *answer set to true.
    1:  * If pn contains a useless expression, return true with *answer set to false.
    1:  * Return false on error.
    1:  *
    1:  * The caller should initialize *answer to false and invoke this function on
    1:  * an expression statement or similar subtree to decide whether the tree could
    1:  * produce code that has any side effects.  For an expression statement, we
    1:  * define useless code as code with no side effects, because the main effect,
    1:  * the value left on the stack after the code executes, will be discarded by a
    1:  * pop bytecode.
    1:  */
    1: static JSBool
 9604: CheckSideEffects(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn,
    1:                  JSBool *answer)
    1: {
    1:     JSBool ok;
    1:     JSFunction *fun;
    1:     JSParseNode *pn2;
    1: 
    1:     ok = JS_TRUE;
    1:     if (!pn || *answer)
    1:         return ok;
    1: 
    1:     switch (pn->pn_arity) {
    1:       case PN_FUNC:
    1:         /*
    1:          * A named function is presumed useful: we can't yet know that it is
    1:          * not called.  The side effects are the creation of a scope object
    1:          * to parent this function object, and the binding of the function's
    1:          * name in that scope object.  See comments at case JSOP_NAMEDFUNOBJ:
    1:          * in jsinterp.c.
    1:          */
13824:         fun = (JSFunction *) pn->pn_funpob->object;
    1:         if (fun->atom)
    1:             *answer = JS_TRUE;
    1:         break;
    1: 
    1:       case PN_LIST:
20902:         if (pn->pn_op == JSOP_NOP ||
20902:             pn->pn_op == JSOP_OR || pn->pn_op == JSOP_AND ||
20902:             pn->pn_op == JSOP_STRICTEQ || pn->pn_op == JSOP_STRICTNE) {
20902:             /*
20902:              * Non-operators along with ||, &&, ===, and !== never invoke
20902:              * toString or valueOf.
20902:              */
20902:             for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next)
20902:                 ok &= CheckSideEffects(cx, cg, pn2, answer);
20902:         } else {
    1:             /*
    1:              * All invocation operations (construct: TOK_NEW, call: TOK_LP)
    1:              * are presumed to be useful, because they may have side effects
    1:              * even if their main effect (their return value) is discarded.
    1:              *
    1:              * TOK_LB binary trees of 3 or more nodes are flattened into lists
    1:              * to avoid too much recursion.  All such lists must be presumed
    1:              * to be useful because each index operation could invoke a getter
    1:              * (the JSOP_ARGUMENTS special case below, in the PN_BINARY case,
    1:              * does not apply here: arguments[i][j] might invoke a getter).
    1:              *
20902:              * Likewise, array and object initialisers may call prototype
20902:              * setters (the __defineSetter__ built-in, and writable __proto__
20902:              * on Array.prototype create this hazard). Initialiser list nodes
20902:              * have JSOP_NEWINIT in their pn_op.
    1:              */
    1:             *answer = JS_TRUE;
    1:         }
    1:         break;
    1: 
    1:       case PN_TERNARY:
 9604:         ok = CheckSideEffects(cx, cg, pn->pn_kid1, answer) &&
 9604:              CheckSideEffects(cx, cg, pn->pn_kid2, answer) &&
 9604:              CheckSideEffects(cx, cg, pn->pn_kid3, answer);
    1:         break;
    1: 
    1:       case PN_BINARY:
    1:         if (pn->pn_type == TOK_ASSIGN) {
    1:             /*
    1:              * Assignment is presumed to be useful, even if the next operation
    1:              * is another assignment overwriting this one's ostensible effect,
    1:              * because the left operand may be a property with a setter that
    1:              * has side effects.
    1:              *
    1:              * The only exception is assignment of a useless value to a const
    1:              * declared in the function currently being compiled.
    1:              */
    1:             pn2 = pn->pn_left;
    1:             if (pn2->pn_type != TOK_NAME) {
    1:                 *answer = JS_TRUE;
    1:             } else {
16378:                 if (!BindNameToSlot(cx, cg, pn2))
 9604:                     return JS_FALSE;
 9604:                 if (!CheckSideEffects(cx, cg, pn->pn_right, answer))
    1:                     return JS_FALSE;
    1:                 if (!*answer &&
 2285:                     (pn->pn_op != JSOP_NOP ||
 2285:                      pn2->pn_slot < 0 ||
 8179:                      !pn2->pn_const)) {
    1:                     *answer = JS_TRUE;
    1:                 }
    1:             }
    1:         } else {
20902:             if (pn->pn_op == JSOP_OR || pn->pn_op == JSOP_AND ||
20902:                 pn->pn_op == JSOP_STRICTEQ || pn->pn_op == JSOP_STRICTNE) {
20902:                 /*
20902:                  * ||, &&, ===, and !== do not convert their operands via
20902:                  * toString or valueOf method calls.
20902:                  */
20902:                 ok = CheckSideEffects(cx, cg, pn->pn_left, answer) &&
20902:                      CheckSideEffects(cx, cg, pn->pn_right, answer);
20902:             } else {
 2285:                 /*
 2285:                  * We can't easily prove that neither operand ever denotes an
 2285:                  * object with a toString or valueOf method.
    1:                  */
    1:                 *answer = JS_TRUE;
    1:             }
20902:         }
    1:         break;
    1: 
    1:       case PN_UNARY:
 2477:         switch (pn->pn_type) {
 2477:           case TOK_RP:
 9604:             ok = CheckSideEffects(cx, cg, pn->pn_kid, answer);
 2477:             break;
 2477: 
 2477:           case TOK_DELETE:
    1:             pn2 = pn->pn_kid;
    1:             switch (pn2->pn_type) {
    1:               case TOK_NAME:
    1:               case TOK_DOT:
    1: #if JS_HAS_XML_SUPPORT
    1:               case TOK_DBLDOT:
    1: #endif
    1: #if JS_HAS_LVALUE_RETURN
    1:               case TOK_LP:
    1: #endif
    1:               case TOK_LB:
    1:                 /* All these delete addressing modes have effects too. */
    1:                 *answer = JS_TRUE;
    1:                 break;
    1:               default:
 9604:                 ok = CheckSideEffects(cx, cg, pn2, answer);
    1:                 break;
    1:             }
 2477:             break;
 2477: 
20902:           case TOK_UNARYOP:
20902:             if (pn->pn_op == JSOP_NOT) {
20902:                 /* ! does not convert its operand via toString or valueOf. */
20902:                 ok = CheckSideEffects(cx, cg, pn->pn_kid, answer);
20902:                 break;
20902:             }
20902:             /* FALL THROUGH */
20902: 
 2477:           default:
 2477:             /*
 2477:              * All of TOK_INC, TOK_DEC, TOK_THROW, TOK_YIELD, and TOK_DEFSHARP
 2477:              * have direct effects. Of the remaining unary-arity node types,
 2477:              * we can't easily prove that the operand never denotes an object
 2285:              * with a toString or valueOf method.
 2285:              */
 2285:             *answer = JS_TRUE;
 2477:             break;
    1:         }
    1:         break;
    1: 
    1:       case PN_NAME:
    1:         /*
    1:          * Take care to avoid trying to bind a label name (labels, both for
    1:          * statements and property values in object initialisers, have pn_op
    1:          * defaulted to JSOP_NOP).
    1:          */
    1:         if (pn->pn_type == TOK_NAME && pn->pn_op != JSOP_NOP) {
16378:             if (!BindNameToSlot(cx, cg, pn))
    1:                 return JS_FALSE;
    1:             if (pn->pn_slot < 0 && pn->pn_op != JSOP_ARGUMENTS) {
    1:                 /*
    1:                  * Not an argument or local variable use, so this expression
    1:                  * could invoke a getter that has side effects.
    1:                  */
    1:                 *answer = JS_TRUE;
    1:             }
    1:         }
    1:         pn2 = pn->pn_expr;
    1:         if (pn->pn_type == TOK_DOT) {
16378:             if (pn2->pn_type == TOK_NAME && !BindNameToSlot(cx, cg, pn2))
 9604:                 return JS_FALSE;
    1:             if (!(pn2->pn_op == JSOP_ARGUMENTS &&
    1:                   pn->pn_atom == cx->runtime->atomState.lengthAtom)) {
    1:                 /*
    1:                  * Any dotted property reference could call a getter, except
    1:                  * for arguments.length where arguments is unambiguous.
    1:                  */
    1:                 *answer = JS_TRUE;
    1:             }
    1:         }
 9604:         ok = CheckSideEffects(cx, cg, pn2, answer);
    1:         break;
    1: 
    1:       case PN_NULLARY:
    1:         if (pn->pn_type == TOK_DEBUGGER)
    1:             *answer = JS_TRUE;
    1:         break;
    1:     }
    1:     return ok;
    1: }
    1: 
    1: static JSBool
    1: EmitNameOp(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn,
    1:            JSBool callContext)
    1: {
    1:     JSOp op;
    1: 
16378:     if (!BindNameToSlot(cx, cg, pn))
    1:         return JS_FALSE;
 3164:     op = PN_OP(pn);
    1: 
    1:     if (callContext) {
    1:         switch (op) {
    1:           case JSOP_NAME:
    1:             op = JSOP_CALLNAME;
    1:             break;
    1:           case JSOP_GETGVAR:
    1:             op = JSOP_CALLGVAR;
    1:             break;
    1:           case JSOP_GETARG:
    1:             op = JSOP_CALLARG;
    1:             break;
    1:           case JSOP_GETLOCAL:
    1:             op = JSOP_CALLLOCAL;
    1:             break;
18308:           case JSOP_GETUPVAR:
18308:             op = JSOP_CALLUPVAR;
18308:             break;
    1:           default:
    1:             JS_ASSERT(op == JSOP_ARGUMENTS);
    1:             break;
    1:         }
    1:     }
    1: 
    1:     if (op == JSOP_ARGUMENTS) {
    1:         if (js_Emit1(cx, cg, op) < 0)
    1:             return JS_FALSE;
    1:         if (callContext && js_Emit1(cx, cg, JSOP_NULL) < 0)
    1:             return JS_FALSE;
    1:     } else {
    1:         if (pn->pn_slot >= 0) {
    1:             EMIT_UINT16_IMM_OP(op, pn->pn_slot);
    1:         } else {
    1:             if (!EmitAtomOp(cx, pn, op, cg))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: static JSBool
    1: EmitXMLName(JSContext *cx, JSParseNode *pn, JSOp op, JSCodeGenerator *cg)
    1: {
    1:     JSParseNode *pn2;
    1:     uintN oldflags;
    1: 
    1:     JS_ASSERT(pn->pn_type == TOK_UNARYOP);
    1:     JS_ASSERT(pn->pn_op == JSOP_XMLNAME);
    1:     JS_ASSERT(op == JSOP_XMLNAME || op == JSOP_CALLXMLNAME);
    1: 
    1:     pn2 = pn->pn_kid;
    1:     oldflags = cg->treeContext.flags;
    1:     cg->treeContext.flags &= ~TCF_IN_FOR_INIT;
    1:     if (!js_EmitTree(cx, cg, pn2))
    1:         return JS_FALSE;
    1:     cg->treeContext.flags |= oldflags & TCF_IN_FOR_INIT;
    1:     if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
    1:                        CG_OFFSET(cg) - pn2->pn_offset) < 0) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return js_Emit1(cx, cg, op) >= 0;
    1: }
    1: #endif
    1: 
    1: static JSBool
    1: EmitPropOp(JSContext *cx, JSParseNode *pn, JSOp op, JSCodeGenerator *cg,
    1:            JSBool callContext)
    1: {
    1:     JSParseNode *pn2, *pndot, *pnup, *pndown;
    1:     ptrdiff_t top;
    1: 
    1:     pn2 = pn->pn_expr;
    1:     if (callContext) {
    1:         JS_ASSERT(pn->pn_type == TOK_DOT);
    1:         JS_ASSERT(op == JSOP_GETPROP);
    1:         op = JSOP_CALLPROP;
    1:     } else if (op == JSOP_GETPROP && pn->pn_type == TOK_DOT) {
    1:         if (pn2->pn_op == JSOP_THIS) {
18012:             if (pn->pn_atom != cx->runtime->atomState.lengthAtom) {
    1:                 /* Fast path for gets of |this.foo|. */
    1:                 return EmitAtomOp(cx, pn, JSOP_GETTHISPROP, cg);
    1:             }
18012:         } else if (pn2->pn_type == TOK_NAME) {
    1:             /*
    1:              * Try to optimize:
    1:              *  - arguments.length into JSOP_ARGCNT
    1:              *  - argname.prop into JSOP_GETARGPROP
    1:              *  - localname.prop into JSOP_GETLOCALPROP
18012:              * but don't do this if the property is 'length' -- prefer to emit
18012:              * JSOP_GETARG, etc., and then JSOP_LENGTH.
    1:              */
16378:             if (!BindNameToSlot(cx, cg, pn2))
    1:                 return JS_FALSE;
18012:             if (pn->pn_atom == cx->runtime->atomState.lengthAtom) {
18012:                 if (pn2->pn_op == JSOP_ARGUMENTS)
18012:                     return js_Emit1(cx, cg, JSOP_ARGCNT) >= 0;
18012:             } else {
    1:                 switch (pn2->pn_op) {
    1:                   case JSOP_GETARG:
    1:                     op = JSOP_GETARGPROP;
    1:                     goto do_indexconst;
    1:                   case JSOP_GETLOCAL:
    1:                     op = JSOP_GETLOCALPROP;
    1:                   do_indexconst: {
    1:                         JSAtomListElement *ale;
    1:                         jsatomid atomIndex;
    1: 
    1:                         ale = js_IndexAtom(cx, pn->pn_atom, &cg->atomList);
    1:                         if (!ale)
    1:                             return JS_FALSE;
    1:                         atomIndex = ALE_INDEX(ale);
 4380:                         return EmitSlotIndexOp(cx, op, pn2->pn_slot, atomIndex, cg);
    1:                     }
    1: 
    1:                   default:;
    1:                 }
    1:             }
    1:         }
18012:     }
    1: 
    1:     /*
    1:      * If the object operand is also a dotted property reference, reverse the
    1:      * list linked via pn_expr temporarily so we can iterate over it from the
    1:      * bottom up (reversing again as we go), to avoid excessive recursion.
    1:      */
    1:     if (pn2->pn_type == TOK_DOT) {
    1:         pndot = pn2;
    1:         pnup = NULL;
    1:         top = CG_OFFSET(cg);
    1:         for (;;) {
    1:             /* Reverse pndot->pn_expr to point up, not down. */
    1:             pndot->pn_offset = top;
    1:             pndown = pndot->pn_expr;
    1:             pndot->pn_expr = pnup;
    1:             if (pndown->pn_type != TOK_DOT)
    1:                 break;
    1:             pnup = pndot;
    1:             pndot = pndown;
    1:         }
    1: 
    1:         /* pndown is a primary expression, not a dotted property reference. */
    1:         if (!js_EmitTree(cx, cg, pndown))
    1:             return JS_FALSE;
    1: 
    1:         do {
    1:             /* Walk back up the list, emitting annotated name ops. */
    1:             if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
    1:                                CG_OFFSET(cg) - pndown->pn_offset) < 0) {
    1:                 return JS_FALSE;
    1:             }
 3164:             if (!EmitAtomOp(cx, pndot, PN_OP(pndot), cg))
    1:                 return JS_FALSE;
    1: 
    1:             /* Reverse the pn_expr link again. */
    1:             pnup = pndot->pn_expr;
    1:             pndot->pn_expr = pndown;
    1:             pndown = pndot;
    1:         } while ((pndot = pnup) != NULL);
    1:     } else {
    1:         if (!js_EmitTree(cx, cg, pn2))
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
    1:                        CG_OFFSET(cg) - pn2->pn_offset) < 0) {
    1:         return JS_FALSE;
    1:     }
16489: 
16489:     return EmitAtomOp(cx, pn, op, cg);
    1: }
    1: 
    1: static JSBool
    1: EmitElemOp(JSContext *cx, JSParseNode *pn, JSOp op, JSCodeGenerator *cg)
    1: {
    1:     ptrdiff_t top;
    1:     JSParseNode *left, *right, *next, ltmp, rtmp;
    1:     jsint slot;
    1: 
    1:     top = CG_OFFSET(cg);
    1:     if (pn->pn_arity == PN_LIST) {
    1:         /* Left-associative operator chain to avoid too much recursion. */
16489:         JS_ASSERT(pn->pn_op == JSOP_GETELEM);
    1:         JS_ASSERT(pn->pn_count >= 3);
    1:         left = pn->pn_head;
    1:         right = PN_LAST(pn);
    1:         next = left->pn_next;
    1:         JS_ASSERT(next != right);
    1: 
    1:         /*
    1:          * Try to optimize arguments[0][j]... into JSOP_ARGSUB<0> followed by
    1:          * one or more index expression and JSOP_GETELEM op pairs.
    1:          */
    1:         if (left->pn_type == TOK_NAME && next->pn_type == TOK_NUMBER) {
16378:             if (!BindNameToSlot(cx, cg, left))
    1:                 return JS_FALSE;
    1:             if (left->pn_op == JSOP_ARGUMENTS &&
    1:                 JSDOUBLE_IS_INT(next->pn_dval, slot) &&
    1:                 (jsuint)slot < JS_BIT(16)) {
    1:                 /*
    1:                  * arguments[i]() requires arguments object as "this".
    1:                  * Check that we never generates list for that usage.
    1:                  */
    1:                 JS_ASSERT(op != JSOP_CALLELEM || next->pn_next);
    1:                 left->pn_offset = next->pn_offset = top;
    1:                 EMIT_UINT16_IMM_OP(JSOP_ARGSUB, (jsatomid)slot);
    1:                 left = next;
    1:                 next = left->pn_next;
    1:             }
    1:         }
    1: 
    1:         /*
    1:          * Check whether we generated JSOP_ARGSUB, just above, and have only
    1:          * one more index expression to emit.  Given arguments[0][j], we must
    1:          * skip the while loop altogether, falling through to emit code for j
    1:          * (in the subtree referenced by right), followed by the annotated op,
    1:          * at the bottom of this function.
    1:          */
    1:         JS_ASSERT(next != right || pn->pn_count == 3);
    1:         if (left == pn->pn_head) {
    1:             if (!js_EmitTree(cx, cg, left))
    1:                 return JS_FALSE;
    1:         }
    1:         while (next != right) {
    1:             if (!js_EmitTree(cx, cg, next))
    1:                 return JS_FALSE;
    1:             if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_GETELEM) < 0)
    1:                 return JS_FALSE;
    1:             next = next->pn_next;
    1:         }
    1:     } else {
    1:         if (pn->pn_arity == PN_NAME) {
    1:             /*
    1:              * Set left and right so pn appears to be a TOK_LB node, instead
    1:              * of a TOK_DOT node.  See the TOK_FOR/IN case in js_EmitTree, and
    1:              * EmitDestructuringOps nearer below.  In the destructuring case,
    1:              * the base expression (pn_expr) of the name may be null, which
    1:              * means we have to emit a JSOP_BINDNAME.
    1:              */
    1:             left = pn->pn_expr;
    1:             if (!left) {
    1:                 left = &ltmp;
 3235:                 left->pn_type = TOK_STRING;
    1:                 left->pn_op = JSOP_BINDNAME;
    1:                 left->pn_arity = PN_NULLARY;
    1:                 left->pn_pos = pn->pn_pos;
    1:                 left->pn_atom = pn->pn_atom;
    1:             }
    1:             right = &rtmp;
    1:             right->pn_type = TOK_STRING;
    1:             JS_ASSERT(ATOM_IS_STRING(pn->pn_atom));
    1:             right->pn_op = js_IsIdentifier(ATOM_TO_STRING(pn->pn_atom))
    1:                            ? JSOP_QNAMEPART
    1:                            : JSOP_STRING;
    1:             right->pn_arity = PN_NULLARY;
    1:             right->pn_pos = pn->pn_pos;
    1:             right->pn_atom = pn->pn_atom;
    1:         } else {
    1:             JS_ASSERT(pn->pn_arity == PN_BINARY);
    1:             left = pn->pn_left;
    1:             right = pn->pn_right;
    1:         }
    1: 
    1:         /* Try to optimize arguments[0] (e.g.) into JSOP_ARGSUB<0>. */
    1:         if (op == JSOP_GETELEM &&
    1:             left->pn_type == TOK_NAME &&
    1:             right->pn_type == TOK_NUMBER) {
16378:             if (!BindNameToSlot(cx, cg, left))
    1:                 return JS_FALSE;
    1:             if (left->pn_op == JSOP_ARGUMENTS &&
    1:                 JSDOUBLE_IS_INT(right->pn_dval, slot) &&
    1:                 (jsuint)slot < JS_BIT(16)) {
    1:                 left->pn_offset = right->pn_offset = top;
    1:                 EMIT_UINT16_IMM_OP(JSOP_ARGSUB, (jsatomid)slot);
    1:                 return JS_TRUE;
    1:             }
    1:         }
    1: 
    1:         if (!js_EmitTree(cx, cg, left))
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     /* The right side of the descendant operator is implicitly quoted. */
    1:     JS_ASSERT(op != JSOP_DESCENDANTS || right->pn_type != TOK_STRING ||
    1:               right->pn_op == JSOP_QNAMEPART);
    1:     if (!js_EmitTree(cx, cg, right))
    1:         return JS_FALSE;
    1:     if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
    1:         return JS_FALSE;
    1:     return js_Emit1(cx, cg, op) >= 0;
    1: }
    1: 
    1: static JSBool
    1: EmitNumberOp(JSContext *cx, jsdouble dval, JSCodeGenerator *cg)
    1: {
    1:     jsint ival;
 3328:     uint32 u;
    1:     ptrdiff_t off;
    1:     jsbytecode *pc;
    1:     JSAtom *atom;
    1:     JSAtomListElement *ale;
    1: 
    1:     if (JSDOUBLE_IS_INT(dval, ival) && INT_FITS_IN_JSVAL(ival)) {
    1:         if (ival == 0)
    1:             return js_Emit1(cx, cg, JSOP_ZERO) >= 0;
    1:         if (ival == 1)
    1:             return js_Emit1(cx, cg, JSOP_ONE) >= 0;
 3328:         if ((jsint)(int8)ival == ival)
 3328:             return js_Emit2(cx, cg, JSOP_INT8, (jsbytecode)(int8)ival) >= 0;
 3328: 
 3328:         u = (uint32)ival;
 3328:         if (u < JS_BIT(16)) {
 3328:             EMIT_UINT16_IMM_OP(JSOP_UINT16, u);
 3328:         } else if (u < JS_BIT(24)) {
    1:             off = js_EmitN(cx, cg, JSOP_UINT24, 3);
    1:             if (off < 0)
    1:                 return JS_FALSE;
    1:             pc = CG_CODE(cg, off);
 3328:             SET_UINT24(pc, u);
 3328:         } else {
 3328:             off = js_EmitN(cx, cg, JSOP_INT32, 4);
 3328:             if (off < 0)
 3328:                 return JS_FALSE;
 3328:             pc = CG_CODE(cg, off);
 3328:             SET_INT32(pc, ival);
 3328:         }
    1:         return JS_TRUE;
    1:     }
    1: 
 3328:     atom = js_AtomizeDouble(cx, dval);
    1:     if (!atom)
    1:         return JS_FALSE;
    1: 
    1:     ale = js_IndexAtom(cx, atom, &cg->atomList);
    1:     if (!ale)
    1:         return JS_FALSE;
 3328:     return EmitIndexOp(cx, JSOP_DOUBLE, ALE_INDEX(ale), cg);
    1: }
    1: 
    1: static JSBool
    1: EmitSwitch(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn,
    1:            JSStmtInfo *stmtInfo)
    1: {
    1:     JSOp switchOp;
    1:     JSBool ok, hasDefault, constPropagated;
    1:     ptrdiff_t top, off, defaultOffset;
    1:     JSParseNode *pn2, *pn3, *pn4;
    1:     uint32 caseCount, tableLength;
    1:     JSParseNode **table;
    1:     jsdouble d;
    1:     jsint i, low, high;
    1:     jsval v;
    1:     JSAtom *atom;
    1:     JSAtomListElement *ale;
    1:     intN noteIndex;
    1:     size_t switchSize, tableSize;
    1:     jsbytecode *pc, *savepc;
    1: #if JS_HAS_BLOCK_SCOPE
    1:     jsint count;
    1: #endif
    1: 
    1:     /* Try for most optimal, fall back if not dense ints, and per ECMAv2. */
    1:     switchOp = JSOP_TABLESWITCH;
    1:     ok = JS_TRUE;
    1:     hasDefault = constPropagated = JS_FALSE;
    1:     defaultOffset = -1;
    1: 
    1:     /*
    1:      * If the switch contains let variables scoped by its body, model the
    1:      * resulting block on the stack first, before emitting the discriminant's
    1:      * bytecode (in case the discriminant contains a stack-model dependency
    1:      * such as a let expression).
    1:      */
    1:     pn2 = pn->pn_right;
    1: #if JS_HAS_BLOCK_SCOPE
    1:     if (pn2->pn_type == TOK_LEXICALSCOPE) {
    1:         /*
    1:          * Push the body's block scope before discriminant code-gen for proper
    1:          * static block scope linkage in case the discriminant contains a let
    1:          * expression.  The block's locals must lie under the discriminant on
    1:          * the stack so that case-dispatch bytecodes can find the discriminant
    1:          * on top of stack.
    1:          */
18567:         count = OBJ_BLOCK_COUNT(cx, pn2->pn_pob->object);
18567:         js_PushBlockScope(&cg->treeContext, stmtInfo, pn2->pn_pob->object, -1);
    1:         stmtInfo->type = STMT_SWITCH;
    1: 
    1:         /* Emit JSOP_ENTERBLOCK before code to evaluate the discriminant. */
18567:         if (!EmitObjectOp(cx, pn2->pn_pob, JSOP_ENTERBLOCK, cg))
 3235:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Pop the switch's statement info around discriminant code-gen.  Note
    1:          * how this leaves cg->treeContext.blockChain referencing the switch's
    1:          * block scope object, which is necessary for correct block parenting
    1:          * in the case where the discriminant contains a let expression.
    1:          */
    1:         cg->treeContext.topStmt = stmtInfo->down;
    1:         cg->treeContext.topScopeStmt = stmtInfo->downScope;
    1:     }
    1: #ifdef __GNUC__
    1:     else {
18567:         count = 0;
    1:     }
    1: #endif
    1: #endif
    1: 
    1:     /*
    1:      * Emit code for the discriminant first (or nearly first, in the case of a
    1:      * switch whose body is a block scope).
    1:      */
    1:     if (!js_EmitTree(cx, cg, pn->pn_left))
    1:         return JS_FALSE;
    1: 
    1:     /* Switch bytecodes run from here till end of final case. */
    1:     top = CG_OFFSET(cg);
    1: #if !JS_HAS_BLOCK_SCOPE
    1:     js_PushStatement(&cg->treeContext, stmtInfo, STMT_SWITCH, top);
    1: #else
    1:     if (pn2->pn_type == TOK_LC) {
    1:         js_PushStatement(&cg->treeContext, stmtInfo, STMT_SWITCH, top);
    1:     } else {
    1:         /* Re-push the switch's statement info record. */
    1:         cg->treeContext.topStmt = cg->treeContext.topScopeStmt = stmtInfo;
    1: 
    1:         /* Set the statement info record's idea of top. */
    1:         stmtInfo->update = top;
    1: 
    1:         /* Advance pn2 to refer to the switch case list. */
    1:         pn2 = pn2->pn_expr;
    1:     }
    1: #endif
    1: 
    1:     caseCount = pn2->pn_count;
    1:     tableLength = 0;
    1:     table = NULL;
    1: 
    1:     if (caseCount == 0 ||
    1:         (caseCount == 1 &&
    1:          (hasDefault = (pn2->pn_head->pn_type == TOK_DEFAULT)))) {
    1:         caseCount = 0;
    1:         low = 0;
    1:         high = -1;
    1:     } else {
    1: #define INTMAP_LENGTH   256
    1:         jsbitmap intmap_space[INTMAP_LENGTH];
    1:         jsbitmap *intmap = NULL;
    1:         int32 intmap_bitlen = 0;
    1: 
    1:         low  = JSVAL_INT_MAX;
    1:         high = JSVAL_INT_MIN;
    1: 
    1:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
    1:             if (pn3->pn_type == TOK_DEFAULT) {
    1:                 hasDefault = JS_TRUE;
    1:                 caseCount--;    /* one of the "cases" was the default */
    1:                 continue;
    1:             }
    1: 
    1:             JS_ASSERT(pn3->pn_type == TOK_CASE);
    1:             if (switchOp == JSOP_CONDSWITCH)
    1:                 continue;
    1: 
    1:             pn4 = pn3->pn_left;
23445:             while (pn4->pn_type == TOK_RP)
23445:                 pn4 = pn4->pn_kid;
    1:             switch (pn4->pn_type) {
    1:               case TOK_NUMBER:
    1:                 d = pn4->pn_dval;
    1:                 if (JSDOUBLE_IS_INT(d, i) && INT_FITS_IN_JSVAL(i)) {
    1:                     pn3->pn_val = INT_TO_JSVAL(i);
    1:                 } else {
 3328:                     atom = js_AtomizeDouble(cx, d);
    1:                     if (!atom) {
    1:                         ok = JS_FALSE;
    1:                         goto release;
    1:                     }
    1:                     pn3->pn_val = ATOM_KEY(atom);
    1:                 }
    1:                 break;
    1:               case TOK_STRING:
    1:                 pn3->pn_val = ATOM_KEY(pn4->pn_atom);
    1:                 break;
    1:               case TOK_NAME:
    1:                 if (!pn4->pn_expr) {
 8817:                     ok = LookupCompileTimeConstant(cx, cg, pn4->pn_atom, &v);
    1:                     if (!ok)
    1:                         goto release;
 8817:                     if (v != JSVAL_HOLE) {
 8817:                         if (!JSVAL_IS_PRIMITIVE(v)) {
 8817:                             /*
 8817:                              * XXX JSOP_LOOKUPSWITCH does not support const-
 8817:                              * propagated object values, see bug 407186.
 8817:                              */
 8817:                             switchOp = JSOP_CONDSWITCH;
 8817:                             continue;
 8817:                         }
    1:                         pn3->pn_val = v;
    1:                         constPropagated = JS_TRUE;
    1:                         break;
    1:                     }
    1:                 }
    1:                 /* FALL THROUGH */
    1:               case TOK_PRIMARY:
    1:                 if (pn4->pn_op == JSOP_TRUE) {
    1:                     pn3->pn_val = JSVAL_TRUE;
    1:                     break;
    1:                 }
    1:                 if (pn4->pn_op == JSOP_FALSE) {
    1:                     pn3->pn_val = JSVAL_FALSE;
    1:                     break;
    1:                 }
    1:                 /* FALL THROUGH */
    1:               default:
    1:                 switchOp = JSOP_CONDSWITCH;
    1:                 continue;
    1:             }
    1: 
 8817:             JS_ASSERT(JSVAL_IS_PRIMITIVE(pn3->pn_val));
    1: 
    1:             if (switchOp != JSOP_TABLESWITCH)
    1:                 continue;
    1:             if (!JSVAL_IS_INT(pn3->pn_val)) {
    1:                 switchOp = JSOP_LOOKUPSWITCH;
    1:                 continue;
    1:             }
    1:             i = JSVAL_TO_INT(pn3->pn_val);
    1:             if ((jsuint)(i + (jsint)JS_BIT(15)) >= (jsuint)JS_BIT(16)) {
    1:                 switchOp = JSOP_LOOKUPSWITCH;
    1:                 continue;
    1:             }
    1:             if (i < low)
    1:                 low = i;
    1:             if (high < i)
    1:                 high = i;
    1: 
    1:             /*
    1:              * Check for duplicates, which require a JSOP_LOOKUPSWITCH.
    1:              * We bias i by 65536 if it's negative, and hope that's a rare
    1:              * case (because it requires a malloc'd bitmap).
    1:              */
    1:             if (i < 0)
    1:                 i += JS_BIT(16);
    1:             if (i >= intmap_bitlen) {
    1:                 if (!intmap &&
    1:                     i < (INTMAP_LENGTH << JS_BITS_PER_WORD_LOG2)) {
    1:                     intmap = intmap_space;
    1:                     intmap_bitlen = INTMAP_LENGTH << JS_BITS_PER_WORD_LOG2;
    1:                 } else {
    1:                     /* Just grab 8K for the worst-case bitmap. */
    1:                     intmap_bitlen = JS_BIT(16);
    1:                     intmap = (jsbitmap *)
    1:                         JS_malloc(cx,
    1:                                   (JS_BIT(16) >> JS_BITS_PER_WORD_LOG2)
    1:                                   * sizeof(jsbitmap));
    1:                     if (!intmap) {
    1:                         JS_ReportOutOfMemory(cx);
    1:                         return JS_FALSE;
    1:                     }
    1:                 }
    1:                 memset(intmap, 0, intmap_bitlen >> JS_BITS_PER_BYTE_LOG2);
    1:             }
    1:             if (JS_TEST_BIT(intmap, i)) {
    1:                 switchOp = JSOP_LOOKUPSWITCH;
    1:                 continue;
    1:             }
    1:             JS_SET_BIT(intmap, i);
    1:         }
    1: 
    1:       release:
    1:         if (intmap && intmap != intmap_space)
    1:             JS_free(cx, intmap);
    1:         if (!ok)
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Compute table length and select lookup instead if overlarge or
    1:          * more than half-sparse.
    1:          */
    1:         if (switchOp == JSOP_TABLESWITCH) {
    1:             tableLength = (uint32)(high - low + 1);
    1:             if (tableLength >= JS_BIT(16) || tableLength > 2 * caseCount)
    1:                 switchOp = JSOP_LOOKUPSWITCH;
    1:         } else if (switchOp == JSOP_LOOKUPSWITCH) {
    1:             /*
  601:              * Lookup switch supports only atom indexes below 64K limit.
    1:              * Conservatively estimate the maximum possible index during
    1:              * switch generation and use conditional switch if it exceeds
    1:              * the limit.
    1:              */
    1:             if (caseCount + cg->atomList.count > JS_BIT(16))
    1:                 switchOp = JSOP_CONDSWITCH;
    1:         }
    1:     }
    1: 
    1:     /*
    1:      * Emit a note with two offsets: first tells total switch code length,
    1:      * second tells offset to first JSOP_CASE if condswitch.
    1:      */
    1:     noteIndex = js_NewSrcNote3(cx, cg, SRC_SWITCH, 0, 0);
    1:     if (noteIndex < 0)
    1:         return JS_FALSE;
    1: 
    1:     if (switchOp == JSOP_CONDSWITCH) {
    1:         /*
    1:          * 0 bytes of immediate for unoptimized ECMAv2 switch.
    1:          */
    1:         switchSize = 0;
    1:     } else if (switchOp == JSOP_TABLESWITCH) {
    1:         /*
    1:          * 3 offsets (len, low, high) before the table, 1 per entry.
    1:          */
    1:         switchSize = (size_t)(JUMP_OFFSET_LEN * (3 + tableLength));
    1:     } else {
    1:         /*
    1:          * JSOP_LOOKUPSWITCH:
    1:          * 1 offset (len) and 1 atom index (npairs) before the table,
    1:          * 1 atom index and 1 jump offset per entry.
    1:          */
 3235:         switchSize = (size_t)(JUMP_OFFSET_LEN + INDEX_LEN +
 3235:                               (INDEX_LEN + JUMP_OFFSET_LEN) * caseCount);
    1:     }
    1: 
    1:     /*
    1:      * Emit switchOp followed by switchSize bytes of jump or lookup table.
    1:      *
    1:      * If switchOp is JSOP_LOOKUPSWITCH or JSOP_TABLESWITCH, it is crucial
    1:      * to emit the immediate operand(s) by which bytecode readers such as
    1:      * BuildSpanDepTable discover the length of the switch opcode *before*
    1:      * calling js_SetJumpOffset (which may call BuildSpanDepTable).  It's
    1:      * also important to zero all unknown jump offset immediate operands,
    1:      * so they can be converted to span dependencies with null targets to
    1:      * be computed later (js_EmitN zeros switchSize bytes after switchOp).
    1:      */
    1:     if (js_EmitN(cx, cg, switchOp, switchSize) < 0)
    1:         return JS_FALSE;
    1: 
    1:     off = -1;
    1:     if (switchOp == JSOP_CONDSWITCH) {
    1:         intN caseNoteIndex = -1;
    1:         JSBool beforeCases = JS_TRUE;
    1: 
    1:         /* Emit code for evaluating cases and jumping to case statements. */
    1:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
    1:             pn4 = pn3->pn_left;
    1:             if (pn4 && !js_EmitTree(cx, cg, pn4))
    1:                 return JS_FALSE;
    1:             if (caseNoteIndex >= 0) {
    1:                 /* off is the previous JSOP_CASE's bytecode offset. */
    1:                 if (!js_SetSrcNoteOffset(cx, cg, (uintN)caseNoteIndex, 0,
    1:                                          CG_OFFSET(cg) - off)) {
    1:                     return JS_FALSE;
    1:                 }
    1:             }
    1:             if (!pn4) {
    1:                 JS_ASSERT(pn3->pn_type == TOK_DEFAULT);
    1:                 continue;
    1:             }
    1:             caseNoteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
    1:             if (caseNoteIndex < 0)
    1:                 return JS_FALSE;
    1:             off = EmitJump(cx, cg, JSOP_CASE, 0);
    1:             if (off < 0)
    1:                 return JS_FALSE;
    1:             pn3->pn_offset = off;
    1:             if (beforeCases) {
    1:                 uintN noteCount, noteCountDelta;
    1: 
    1:                 /* Switch note's second offset is to first JSOP_CASE. */
    1:                 noteCount = CG_NOTE_COUNT(cg);
    1:                 if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 1,
    1:                                          off - top)) {
    1:                     return JS_FALSE;
    1:                 }
    1:                 noteCountDelta = CG_NOTE_COUNT(cg) - noteCount;
    1:                 if (noteCountDelta != 0)
    1:                     caseNoteIndex += noteCountDelta;
    1:                 beforeCases = JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         /*
    1:          * If we didn't have an explicit default (which could fall in between
    1:          * cases, preventing us from fusing this js_SetSrcNoteOffset with the
    1:          * call in the loop above), link the last case to the implicit default
    1:          * for the decompiler.
    1:          */
    1:         if (!hasDefault &&
    1:             caseNoteIndex >= 0 &&
    1:             !js_SetSrcNoteOffset(cx, cg, (uintN)caseNoteIndex, 0,
    1:                                  CG_OFFSET(cg) - off)) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /* Emit default even if no explicit default statement. */
    1:         defaultOffset = EmitJump(cx, cg, JSOP_DEFAULT, 0);
    1:         if (defaultOffset < 0)
    1:             return JS_FALSE;
    1:     } else {
    1:         pc = CG_CODE(cg, top + JUMP_OFFSET_LEN);
    1: 
    1:         if (switchOp == JSOP_TABLESWITCH) {
    1:             /* Fill in switch bounds, which we know fit in 16-bit offsets. */
    1:             SET_JUMP_OFFSET(pc, low);
    1:             pc += JUMP_OFFSET_LEN;
    1:             SET_JUMP_OFFSET(pc, high);
    1:             pc += JUMP_OFFSET_LEN;
    1: 
    1:             /*
    1:              * Use malloc to avoid arena bloat for programs with many switches.
    1:              * We free table if non-null at label out, so all control flow must
    1:              * exit this function through goto out or goto bad.
    1:              */
    1:             if (tableLength != 0) {
    1:                 tableSize = (size_t)tableLength * sizeof *table;
    1:                 table = (JSParseNode **) JS_malloc(cx, tableSize);
    1:                 if (!table)
    1:                     return JS_FALSE;
    1:                 memset(table, 0, tableSize);
    1:                 for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
    1:                     if (pn3->pn_type == TOK_DEFAULT)
    1:                         continue;
    1:                     i = JSVAL_TO_INT(pn3->pn_val);
    1:                     i -= low;
    1:                     JS_ASSERT((uint32)i < tableLength);
    1:                     table[i] = pn3;
    1:                 }
    1:             }
    1:         } else {
    1:             JS_ASSERT(switchOp == JSOP_LOOKUPSWITCH);
    1: 
    1:             /* Fill in the number of cases. */
 3235:             SET_INDEX(pc, caseCount);
 3235:             pc += INDEX_LEN;
    1:         }
    1: 
    1:         /*
    1:          * After this point, all control flow involving JSOP_TABLESWITCH
    1:          * must set ok and goto out to exit this function.  To keep things
    1:          * simple, all switchOp cases exit that way.
    1:          */
18989:         MUST_FLOW_THROUGH("out");
 7365:         if (cg->spanDeps) {
 7365:             /*
 7365:              * We have already generated at least one big jump so we must
 7365:              * explicitly add span dependencies for the switch jumps. When
 7365:              * called below, js_SetJumpOffset can only do it when patching
 7365:              * the first big jump or when cg->spanDeps is null.
 7365:              */
 7365:             if (!AddSwitchSpanDeps(cx, cg, CG_CODE(cg, top)))
 7365:                 goto bad;
 7365:         }
 7365: 
    1:         if (constPropagated) {
    1:             /*
    1:              * Skip switchOp, as we are not setting jump offsets in the two
    1:              * for loops below.  We'll restore CG_NEXT(cg) from savepc after,
    1:              * unless there was an error.
    1:              */
    1:             savepc = CG_NEXT(cg);
    1:             CG_NEXT(cg) = pc + 1;
    1:             if (switchOp == JSOP_TABLESWITCH) {
    1:                 for (i = 0; i < (jsint)tableLength; i++) {
    1:                     pn3 = table[i];
    1:                     if (pn3 &&
    1:                         (pn4 = pn3->pn_left) != NULL &&
    1:                         pn4->pn_type == TOK_NAME) {
    1:                         /* Note a propagated constant with the const's name. */
    1:                         JS_ASSERT(!pn4->pn_expr);
    1:                         ale = js_IndexAtom(cx, pn4->pn_atom, &cg->atomList);
    1:                         if (!ale)
    1:                             goto bad;
    1:                         CG_NEXT(cg) = pc;
    1:                         if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
    1:                                            ALE_INDEX(ale)) < 0) {
    1:                             goto bad;
    1:                         }
    1:                     }
    1:                     pc += JUMP_OFFSET_LEN;
    1:                 }
    1:             } else {
    1:                 for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
    1:                     pn4 = pn3->pn_left;
    1:                     if (pn4 && pn4->pn_type == TOK_NAME) {
    1:                         /* Note a propagated constant with the const's name. */
    1:                         JS_ASSERT(!pn4->pn_expr);
    1:                         ale = js_IndexAtom(cx, pn4->pn_atom, &cg->atomList);
    1:                         if (!ale)
    1:                             goto bad;
    1:                         CG_NEXT(cg) = pc;
    1:                         if (js_NewSrcNote2(cx, cg, SRC_LABEL, (ptrdiff_t)
    1:                                            ALE_INDEX(ale)) < 0) {
    1:                             goto bad;
    1:                         }
    1:                     }
 3235:                     pc += INDEX_LEN + JUMP_OFFSET_LEN;
    1:                 }
    1:             }
    1:             CG_NEXT(cg) = savepc;
    1:         }
    1:     }
    1: 
    1:     /* Emit code for each case's statements, copying pn_offset up to pn3. */
    1:     for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
    1:         if (switchOp == JSOP_CONDSWITCH && pn3->pn_type != TOK_DEFAULT)
18729:             CHECK_AND_SET_JUMP_OFFSET_AT_CUSTOM(cx, cg, pn3->pn_offset, goto bad);
    1:         pn4 = pn3->pn_right;
    1:         ok = js_EmitTree(cx, cg, pn4);
    1:         if (!ok)
    1:             goto out;
    1:         pn3->pn_offset = pn4->pn_offset;
    1:         if (pn3->pn_type == TOK_DEFAULT)
    1:             off = pn3->pn_offset - top;
    1:     }
    1: 
    1:     if (!hasDefault) {
    1:         /* If no default case, offset for default is to end of switch. */
    1:         off = CG_OFFSET(cg) - top;
    1:     }
    1: 
    1:     /* We better have set "off" by now. */
    1:     JS_ASSERT(off != -1);
    1: 
    1:     /* Set the default offset (to end of switch if no default). */
    1:     if (switchOp == JSOP_CONDSWITCH) {
    1:         pc = NULL;
    1:         JS_ASSERT(defaultOffset != -1);
    1:         ok = js_SetJumpOffset(cx, cg, CG_CODE(cg, defaultOffset),
    1:                               off - (defaultOffset - top));
    1:         if (!ok)
    1:             goto out;
    1:     } else {
    1:         pc = CG_CODE(cg, top);
    1:         ok = js_SetJumpOffset(cx, cg, pc, off);
    1:         if (!ok)
    1:             goto out;
    1:         pc += JUMP_OFFSET_LEN;
    1:     }
    1: 
    1:     /* Set the SRC_SWITCH note's offset operand to tell end of switch. */
    1:     off = CG_OFFSET(cg) - top;
    1:     ok = js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, off);
    1:     if (!ok)
    1:         goto out;
    1: 
    1:     if (switchOp == JSOP_TABLESWITCH) {
    1:         /* Skip over the already-initialized switch bounds. */
    1:         pc += 2 * JUMP_OFFSET_LEN;
    1: 
    1:         /* Fill in the jump table, if there is one. */
    1:         for (i = 0; i < (jsint)tableLength; i++) {
    1:             pn3 = table[i];
    1:             off = pn3 ? pn3->pn_offset - top : 0;
    1:             ok = js_SetJumpOffset(cx, cg, pc, off);
    1:             if (!ok)
    1:                 goto out;
    1:             pc += JUMP_OFFSET_LEN;
    1:         }
    1:     } else if (switchOp == JSOP_LOOKUPSWITCH) {
    1:         /* Skip over the already-initialized number of cases. */
 3235:         pc += INDEX_LEN;
    1: 
    1:         for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
    1:             if (pn3->pn_type == TOK_DEFAULT)
    1:                 continue;
 4529:             if (!js_AtomizePrimitiveValue(cx, pn3->pn_val, &atom))
    1:                 goto bad;
    1:             ale = js_IndexAtom(cx, atom, &cg->atomList);
    1:             if (!ale)
    1:                 goto bad;
 3235:             SET_INDEX(pc, ALE_INDEX(ale));
 3235:             pc += INDEX_LEN;
    1: 
    1:             off = pn3->pn_offset - top;
    1:             ok = js_SetJumpOffset(cx, cg, pc, off);
    1:             if (!ok)
    1:                 goto out;
    1:             pc += JUMP_OFFSET_LEN;
    1:         }
    1:     }
    1: 
    1: out:
    1:     if (table)
    1:         JS_free(cx, table);
    1:     if (ok) {
    1:         ok = js_PopStatementCG(cx, cg);
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
18567:         if (ok && pn->pn_right->pn_type == TOK_LEXICALSCOPE)
    1:             EMIT_UINT16_IMM_OP(JSOP_LEAVEBLOCK, count);
    1: #endif
    1:     }
    1:     return ok;
    1: 
    1: bad:
    1:     ok = JS_FALSE;
    1:     goto out;
    1: }
    1: 
    1: JSBool
 9786: js_EmitFunctionScript(JSContext *cx, JSCodeGenerator *cg, JSParseNode *body)
    1: {
    1:     if (cg->treeContext.flags & TCF_FUN_IS_GENERATOR) {
 3457:         /* JSOP_GENERATOR must be the first instruction. */
 3457:         CG_SWITCH_TO_PROLOG(cg);
 3457:         JS_ASSERT(CG_NEXT(cg) == CG_BASE(cg));
    1:         if (js_Emit1(cx, cg, JSOP_GENERATOR) < 0)
    1:             return JS_FALSE;
 3457:         CG_SWITCH_TO_MAIN(cg);
    1:     }
    1: 
    1:     return js_EmitTree(cx, cg, body) &&
 9786:            js_Emit1(cx, cg, JSOP_STOP) >= 0 &&
 9786:            js_NewScriptFromCG(cx, cg);
    1: }
    1: 
    1: /* A macro for inlining at the top of js_EmitTree (whence it came). */
    1: #define UPDATE_LINE_NUMBER_NOTES(cx, cg, pn)                                  \
    1:     JS_BEGIN_MACRO                                                            \
    1:         uintN line_ = (pn)->pn_pos.begin.lineno;                              \
    1:         uintN delta_ = line_ - CG_CURRENT_LINE(cg);                           \
    1:         if (delta_ != 0) {                                                    \
    1:             /*                                                                \
    1:              * Encode any change in the current source line number by using   \
    1:              * either several SRC_NEWLINE notes or just one SRC_SETLINE note, \
    1:              * whichever consumes less space.                                 \
    1:              *                                                                \
    1:              * NB: We handle backward line number deltas (possible with for   \
    1:              * loops where the update part is emitted after the body, but its \
    1:              * line number is <= any line number in the body) here by letting \
    1:              * unsigned delta_ wrap to a very large number, which triggers a  \
    1:              * SRC_SETLINE.                                                   \
    1:              */                                                               \
    1:             CG_CURRENT_LINE(cg) = line_;                                      \
    1:             if (delta_ >= (uintN)(2 + ((line_ > SN_3BYTE_OFFSET_MASK)<<1))) { \
    1:                 if (js_NewSrcNote2(cx, cg, SRC_SETLINE, (ptrdiff_t)line_) < 0)\
    1:                     return JS_FALSE;                                          \
    1:             } else {                                                          \
    1:                 do {                                                          \
    1:                     if (js_NewSrcNote(cx, cg, SRC_NEWLINE) < 0)               \
    1:                         return JS_FALSE;                                      \
    1:                 } while (--delta_ != 0);                                      \
    1:             }                                                                 \
    1:         }                                                                     \
    1:     JS_END_MACRO
    1: 
    1: /* A function, so that we avoid macro-bloating all the other callsites. */
    1: static JSBool
    1: UpdateLineNumberNotes(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn)
    1: {
    1:     UPDATE_LINE_NUMBER_NOTES(cx, cg, pn);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: MaybeEmitVarDecl(JSContext *cx, JSCodeGenerator *cg, JSOp prologOp,
    1:                  JSParseNode *pn, jsatomid *result)
    1: {
    1:     jsatomid atomIndex;
    1:     JSAtomListElement *ale;
    1: 
    1:     if (pn->pn_slot >= 0) {
    1:         atomIndex = (jsatomid) pn->pn_slot;
    1:     } else {
    1:         ale = js_IndexAtom(cx, pn->pn_atom, &cg->atomList);
    1:         if (!ale)
    1:             return JS_FALSE;
    1:         atomIndex = ALE_INDEX(ale);
    1:     }
    1: 
11377:     if (JOF_OPTYPE(pn->pn_op) == JOF_ATOM &&
    1:         (!(cg->treeContext.flags & TCF_IN_FUNCTION) ||
    1:          (cg->treeContext.flags & TCF_FUN_HEAVYWEIGHT))) {
    1:         /* Emit a prolog bytecode to predefine the variable. */
    1:         CG_SWITCH_TO_PROLOG(cg);
    1:         if (!UpdateLineNumberNotes(cx, cg, pn))
    1:             return JS_FALSE;
 3235:         EMIT_INDEX_OP(prologOp, atomIndex);
    1:         CG_SWITCH_TO_MAIN(cg);
    1:     }
    1: 
    1:     if (result)
    1:         *result = atomIndex;
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: 
    1: typedef JSBool
    1: (*DestructuringDeclEmitter)(JSContext *cx, JSCodeGenerator *cg, JSOp prologOp,
    1:                             JSParseNode *pn);
    1: 
    1: static JSBool
    1: EmitDestructuringDecl(JSContext *cx, JSCodeGenerator *cg, JSOp prologOp,
    1:                       JSParseNode *pn)
    1: {
    1:     JS_ASSERT(pn->pn_type == TOK_NAME);
16378:     if (!BindNameToSlot(cx, cg, pn))
 9604:         return JS_FALSE;
    1: 
    1:     JS_ASSERT(pn->pn_op != JSOP_ARGUMENTS);
    1:     return MaybeEmitVarDecl(cx, cg, prologOp, pn, NULL);
    1: }
    1: 
    1: static JSBool
    1: EmitDestructuringDecls(JSContext *cx, JSCodeGenerator *cg, JSOp prologOp,
    1:                        JSParseNode *pn)
    1: {
    1:     JSParseNode *pn2, *pn3;
    1:     DestructuringDeclEmitter emitter;
    1: 
    1:     if (pn->pn_type == TOK_RB) {
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             if (pn2->pn_type == TOK_COMMA)
    1:                 continue;
    1:             emitter = (pn2->pn_type == TOK_NAME)
    1:                       ? EmitDestructuringDecl
    1:                       : EmitDestructuringDecls;
    1:             if (!emitter(cx, cg, prologOp, pn2))
    1:                 return JS_FALSE;
    1:         }
    1:     } else {
    1:         JS_ASSERT(pn->pn_type == TOK_RC);
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             pn3 = pn2->pn_right;
    1:             emitter = (pn3->pn_type == TOK_NAME)
    1:                       ? EmitDestructuringDecl
    1:                       : EmitDestructuringDecls;
    1:             if (!emitter(cx, cg, prologOp, pn3))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: EmitDestructuringOpsHelper(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn);
    1: 
    1: static JSBool
 1289: EmitDestructuringLHS(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn)
    1: {
    1:     jsuint slot;
    1: 
    1:     /* Skip any parenthesization. */
    1:     while (pn->pn_type == TOK_RP)
    1:         pn = pn->pn_kid;
    1: 
    1:     /*
    1:      * Now emit the lvalue opcode sequence.  If the lvalue is a nested
    1:      * destructuring initialiser-form, call ourselves to handle it, then
    1:      * pop the matched value.  Otherwise emit an lvalue bytecode sequence
    1:      * ending with a JSOP_ENUMELEM or equivalent op.
    1:      */
    1:     if (pn->pn_type == TOK_RB || pn->pn_type == TOK_RC) {
    1:         if (!EmitDestructuringOpsHelper(cx, cg, pn))
    1:             return JS_FALSE;
 1289:         if (js_Emit1(cx, cg, JSOP_POP) < 0)
    1:             return JS_FALSE;
    1:     } else {
16378:         if (pn->pn_type == TOK_NAME && !BindNameToSlot(cx, cg, pn))
 9604:             return JS_FALSE;
    1: 
    1:         switch (pn->pn_op) {
    1:           case JSOP_SETNAME:
    1:             /*
    1:              * NB: pn is a PN_NAME node, not a PN_BINARY.  Nevertheless,
    1:              * we want to emit JSOP_ENUMELEM, which has format JOF_ELEM.
    1:              * So here and for JSOP_ENUMCONSTELEM, we use EmitElemOp.
    1:              */
    1:             if (!EmitElemOp(cx, pn, JSOP_ENUMELEM, cg))
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case JSOP_SETCONST:
    1:             if (!EmitElemOp(cx, pn, JSOP_ENUMCONSTELEM, cg))
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           case JSOP_SETLOCAL:
    1:             slot = (jsuint) pn->pn_slot;
    1:             EMIT_UINT16_IMM_OP(JSOP_SETLOCALPOP, slot);
    1:             break;
    1: 
    1:           case JSOP_SETARG:
    1:           case JSOP_SETGVAR:
    1:             slot = (jsuint) pn->pn_slot;
 3383:             EMIT_UINT16_IMM_OP(PN_OP(pn), slot);
 1289:             if (js_Emit1(cx, cg, JSOP_POP) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: 
    1:           default:
    1: #if JS_HAS_LVALUE_RETURN || JS_HAS_XML_SUPPORT
    1:           {
    1:             ptrdiff_t top;
    1: 
    1:             top = CG_OFFSET(cg);
    1:             if (!js_EmitTree(cx, cg, pn))
    1:                 return JS_FALSE;
    1:             if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_ENUMELEM) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1:           }
    1: #endif
    1:           case JSOP_ENUMELEM:
    1:             JS_ASSERT(0);
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Recursive helper for EmitDestructuringOps.
    1:  *
    1:  * Given a value to destructure on the stack, walk over an object or array
    1:  * initialiser at pn, emitting bytecodes to match property values and store
    1:  * them in the lvalues identified by the matched property names.
    1:  */
    1: static JSBool
    1: EmitDestructuringOpsHelper(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn)
    1: {
    1:     jsuint index;
    1:     JSParseNode *pn2, *pn3;
    1:     JSBool doElemOp;
    1: 
    1: #ifdef DEBUG
    1:     intN stackDepth = cg->stackDepth;
    1:     JS_ASSERT(stackDepth != 0);
    1:     JS_ASSERT(pn->pn_arity == PN_LIST);
    1:     JS_ASSERT(pn->pn_type == TOK_RB || pn->pn_type == TOK_RC);
    1: #endif
    1: 
    1:     if (pn->pn_count == 0) {
    1:         /* Emit a DUP;POP sequence for the decompiler. */
    1:         return js_Emit1(cx, cg, JSOP_DUP) >= 0 &&
    1:                js_Emit1(cx, cg, JSOP_POP) >= 0;
    1:     }
    1: 
    1:     index = 0;
    1:     for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:         /*
    1:          * Duplicate the value being destructured to use as a reference base.
    1:          */
    1:         if (js_Emit1(cx, cg, JSOP_DUP) < 0)
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Now push the property name currently being matched, which is either
    1:          * the array initialiser's current index, or the current property name
    1:          * "label" on the left of a colon in the object initialiser.  Set pn3
    1:          * to the lvalue node, which is in the value-initializing position.
    1:          */
    1:         doElemOp = JS_TRUE;
    1:         if (pn->pn_type == TOK_RB) {
    1:             if (!EmitNumberOp(cx, index, cg))
    1:                 return JS_FALSE;
    1:             pn3 = pn2;
    1:         } else {
    1:             JS_ASSERT(pn->pn_type == TOK_RC);
    1:             JS_ASSERT(pn2->pn_type == TOK_COLON);
    1:             pn3 = pn2->pn_left;
    1:             if (pn3->pn_type == TOK_NUMBER) {
    1:                 /*
    1:                  * If we are emitting an object destructuring initialiser,
    1:                  * annotate the index op with SRC_INITPROP so we know we are
    1:                  * not decompiling an array initialiser.
    1:                  */
    1:                 if (js_NewSrcNote(cx, cg, SRC_INITPROP) < 0)
    1:                     return JS_FALSE;
    1:                 if (!EmitNumberOp(cx, pn3->pn_dval, cg))
    1:                     return JS_FALSE;
    1:             } else {
    1:                 JS_ASSERT(pn3->pn_type == TOK_STRING ||
    1:                           pn3->pn_type == TOK_NAME);
    1:                 if (!EmitAtomOp(cx, pn3, JSOP_GETPROP, cg))
    1:                     return JS_FALSE;
    1:                 doElemOp = JS_FALSE;
    1:             }
    1:             pn3 = pn2->pn_right;
    1:         }
    1: 
    1:         if (doElemOp) {
    1:             /*
    1:              * Ok, get the value of the matching property name.  This leaves
    1:              * that value on top of the value being destructured, so the stack
    1:              * is one deeper than when we started.
    1:              */
    1:             if (js_Emit1(cx, cg, JSOP_GETELEM) < 0)
    1:                 return JS_FALSE;
    1:             JS_ASSERT(cg->stackDepth == stackDepth + 1);
    1:         }
    1: 
    1:         /* Nullary comma node makes a hole in the array destructurer. */
    1:         if (pn3->pn_type == TOK_COMMA && pn3->pn_arity == PN_NULLARY) {
    1:             JS_ASSERT(pn->pn_type == TOK_RB);
    1:             JS_ASSERT(pn2 == pn3);
    1:             if (js_Emit1(cx, cg, JSOP_POP) < 0)
    1:                 return JS_FALSE;
    1:         } else {
 1289:             if (!EmitDestructuringLHS(cx, cg, pn3))
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         JS_ASSERT(cg->stackDepth == stackDepth);
    1:         ++index;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: static ptrdiff_t
    1: OpToDeclType(JSOp op)
    1: {
    1:     switch (op) {
    1:       case JSOP_NOP:
    1:         return SRC_DECL_LET;
    1:       case JSOP_DEFCONST:
    1:         return SRC_DECL_CONST;
    1:       case JSOP_DEFVAR:
    1:         return SRC_DECL_VAR;
    1:       default:
    1:         return SRC_DECL_NONE;
    1:     }
    1: }
    1: 
    1: static JSBool
    1: EmitDestructuringOps(JSContext *cx, JSCodeGenerator *cg, JSOp declOp,
    1:                      JSParseNode *pn)
    1: {
    1:     /*
    1:      * If we're called from a variable declaration, help the decompiler by
    1:      * annotating the first JSOP_DUP that EmitDestructuringOpsHelper emits.
    1:      * If the destructuring initialiser is empty, our helper will emit a
    1:      * JSOP_DUP followed by a JSOP_POP for the decompiler.
    1:      */
    1:     if (js_NewSrcNote2(cx, cg, SRC_DESTRUCT, OpToDeclType(declOp)) < 0)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Call our recursive helper to emit the destructuring assignments and
    1:      * related stack manipulations.
    1:      */
    1:     return EmitDestructuringOpsHelper(cx, cg, pn);
    1: }
    1: 
    1: static JSBool
    1: EmitGroupAssignment(JSContext *cx, JSCodeGenerator *cg, JSOp declOp,
    1:                     JSParseNode *lhs, JSParseNode *rhs)
    1: {
16072:     jsuint depth, limit, i, nslots;
    1:     JSParseNode *pn;
    1: 
    1:     depth = limit = (uintN) cg->stackDepth;
    1:     for (pn = rhs->pn_head; pn; pn = pn->pn_next) {
    1:         if (limit == JS_BIT(16)) {
 7984:             js_ReportCompileErrorNumber(cx, CG_TS(cg), rhs, JSREPORT_ERROR,
    1:                                         JSMSG_ARRAY_INIT_TOO_BIG);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         if (pn->pn_type == TOK_COMMA) {
    1:             if (js_Emit1(cx, cg, JSOP_PUSH) < 0)
    1:                 return JS_FALSE;
    1:         } else {
    1:             JS_ASSERT(pn->pn_type != TOK_DEFSHARP);
    1:             if (!js_EmitTree(cx, cg, pn))
    1:                 return JS_FALSE;
    1:         }
    1:         ++limit;
    1:     }
    1: 
    1:     if (js_NewSrcNote2(cx, cg, SRC_GROUPASSIGN, OpToDeclType(declOp)) < 0)
    1:         return JS_FALSE;
    1: 
16072:     i = depth;
16072:     for (pn = lhs->pn_head; pn; pn = pn->pn_next, ++i) {
16072:         if (i < limit) {
16072:             jsint slot;
16072: 
16072:             slot = AdjustBlockSlot(cx, cg, i);
16072:             if (slot < 0)
16072:                 return JS_FALSE;
    1:             EMIT_UINT16_IMM_OP(JSOP_GETLOCAL, slot);
    1:         } else {
    1:             if (js_Emit1(cx, cg, JSOP_PUSH) < 0)
    1:                 return JS_FALSE;
    1:         }
    1:         if (pn->pn_type == TOK_COMMA && pn->pn_arity == PN_NULLARY) {
    1:             if (js_Emit1(cx, cg, JSOP_POP) < 0)
    1:                 return JS_FALSE;
    1:         } else {
 1289:             if (!EmitDestructuringLHS(cx, cg, pn))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1: 
 1227:     nslots = limit - depth;
 1227:     EMIT_UINT16_IMM_OP(JSOP_POPN, nslots);
    1:     cg->stackDepth = (uintN) depth;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Helper called with pop out param initialized to a JSOP_POP* opcode.  If we
    1:  * can emit a group assignment sequence, which results in 0 stack depth delta,
    1:  * we set *pop to JSOP_NOP so callers can veto emitting pn followed by a pop.
    1:  */
    1: static JSBool
    1: MaybeEmitGroupAssignment(JSContext *cx, JSCodeGenerator *cg, JSOp declOp,
    1:                          JSParseNode *pn, JSOp *pop)
    1: {
    1:     JSParseNode *lhs, *rhs;
    1: 
    1:     JS_ASSERT(pn->pn_type == TOK_ASSIGN);
    1:     JS_ASSERT(*pop == JSOP_POP || *pop == JSOP_POPV);
    1:     lhs = pn->pn_left;
    1:     rhs = pn->pn_right;
    1:     if (lhs->pn_type == TOK_RB && rhs->pn_type == TOK_RB &&
    1:         lhs->pn_count <= rhs->pn_count &&
    1:         (rhs->pn_count == 0 ||
    1:          rhs->pn_head->pn_type != TOK_DEFSHARP)) {
    1:         if (!EmitGroupAssignment(cx, cg, declOp, lhs, rhs))
    1:             return JS_FALSE;
    1:         *pop = JSOP_NOP;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1: static JSBool
    1: EmitVariables(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn,
    1:               JSBool inLetHead, ptrdiff_t *headNoteIndex)
    1: {
    1:     JSTreeContext *tc;
    1:     JSBool let, forInVar;
    1: #if JS_HAS_BLOCK_SCOPE
    1:     JSBool forInLet, popScope;
    1:     JSStmtInfo *stmt, *scopeStmt;
    1: #endif
    1:     ptrdiff_t off, noteIndex, tmp;
    1:     JSParseNode *pn2, *pn3;
    1:     JSOp op;
    1:     jsatomid atomIndex;
    1:     uintN oldflags;
    1: 
    1:     /* Default in case of JS_HAS_BLOCK_SCOPE early return, below. */
    1:     *headNoteIndex = -1;
    1: 
    1:     /*
    1:      * Let blocks and expressions have a parenthesized head in which the new
    1:      * scope is not yet open. Initializer evaluation uses the parent node's
    1:      * lexical scope. If popScope is true below, then we hide the top lexical
    1:      * block from any calls to BindNameToSlot hiding in pn2->pn_expr so that
    1:      * it won't find any names in the new let block.
    1:      *
    1:      * The same goes for let declarations in the head of any kind of for loop.
    1:      * Unlike a let declaration 'let x = i' within a block, where x is hoisted
    1:      * to the start of the block, a 'for (let x = i...) ...' loop evaluates i
    1:      * in the containing scope, and puts x in the loop body's scope.
    1:      */
    1:     tc = &cg->treeContext;
    1:     let = (pn->pn_op == JSOP_NOP);
    1:     forInVar = (pn->pn_extra & PNX_FORINVAR) != 0;
    1: #if JS_HAS_BLOCK_SCOPE
    1:     forInLet = let && forInVar;
    1:     popScope = (inLetHead || (let && (tc->flags & TCF_IN_FOR_INIT)));
    1:     JS_ASSERT(!popScope || let);
    1: #endif
    1: 
    1:     off = noteIndex = -1;
    1:     for (pn2 = pn->pn_head; ; pn2 = pn2->pn_next) {
    1: #if JS_HAS_DESTRUCTURING
    1:         if (pn2->pn_type != TOK_NAME) {
    1:             if (pn2->pn_type == TOK_RB || pn2->pn_type == TOK_RC) {
    1:                 /*
    1:                  * Emit variable binding ops, but not destructuring ops.
    1:                  * The parser (see Variables, jsparse.c) has ensured that
    1:                  * our caller will be the TOK_FOR/TOK_IN case in js_EmitTree,
    1:                  * and that case will emit the destructuring code only after
    1:                  * emitting an enumerating opcode and a branch that tests
    1:                  * whether the enumeration ended.
    1:                  */
    1:                 JS_ASSERT(forInVar);
    1:                 JS_ASSERT(pn->pn_count == 1);
 3164:                 if (!EmitDestructuringDecls(cx, cg, PN_OP(pn), pn2))
    1:                     return JS_FALSE;
    1:                 break;
    1:             }
    1: 
    1:             /*
20413:              * A destructuring initialiser assignment preceded by var will
20413:              * never occur to the left of 'in' in a for-in loop.  As with 'for
20413:              * (var x = i in o)...', this will cause the entire 'var [a, b] =
20413:              * i' to be hoisted out of the loop.
    1:              */
    1:             JS_ASSERT(pn2->pn_type == TOK_ASSIGN);
20413:             JS_ASSERT(!forInVar);
20413:             if (pn->pn_count == 1) {
    1:                 /*
    1:                  * If this is the only destructuring assignment in the list,
    1:                  * try to optimize to a group assignment.  If we're in a let
    1:                  * head, pass JSOP_POP rather than the pseudo-prolog JSOP_NOP
    1:                  * in pn->pn_op, to suppress a second (and misplaced) 'let'.
    1:                  */
    1:                 JS_ASSERT(noteIndex < 0 && !pn2->pn_next);
    1:                 op = JSOP_POP;
    1:                 if (!MaybeEmitGroupAssignment(cx, cg,
20943:                                               inLetHead ? JSOP_POP : PN_OP(pn),
    1:                                               pn2, &op)) {
    1:                     return JS_FALSE;
    1:                 }
    1:                 if (op == JSOP_NOP) {
    1:                     pn->pn_extra = (pn->pn_extra & ~PNX_POPVAR) | PNX_GROUPINIT;
    1:                     break;
    1:                 }
    1:             }
    1: 
    1:             pn3 = pn2->pn_left;
 3164:             if (!EmitDestructuringDecls(cx, cg, PN_OP(pn), pn3))
    1:                 return JS_FALSE;
    1: 
    1:             if (!js_EmitTree(cx, cg, pn2->pn_right))
    1:                 return JS_FALSE;
    1: 
    1:             /*
    1:              * Veto pn->pn_op if inLetHead to avoid emitting a SRC_DESTRUCT
    1:              * that's redundant with respect to the SRC_DECL/SRC_DECL_LET that
    1:              * we will emit at the bottom of this function.
    1:              */
    1:             if (!EmitDestructuringOps(cx, cg,
 3164:                                       inLetHead ? JSOP_POP : PN_OP(pn),
    1:                                       pn3)) {
    1:                 return JS_FALSE;
    1:             }
    1:             goto emit_note_pop;
    1:         }
    1: #else
    1:         JS_ASSERT(pn2->pn_type == TOK_NAME);
    1: #endif
    1: 
16378:         if (!BindNameToSlot(cx, cg, pn2))
    1:             return JS_FALSE;
    1:         JS_ASSERT(pn2->pn_slot >= 0 || !let);
    1: 
 3164:         op = PN_OP(pn2);
    1:         if (op == JSOP_ARGUMENTS) {
    1:             /* JSOP_ARGUMENTS => no initializer */
    1:             JS_ASSERT(!pn2->pn_expr && !let);
    1:             pn3 = NULL;
    1: #ifdef __GNUC__
    1:             atomIndex = 0;            /* quell GCC overwarning */
    1: #endif
    1:         } else {
 3164:             if (!MaybeEmitVarDecl(cx, cg, PN_OP(pn), pn2, &atomIndex))
    1:                 return JS_FALSE;
    1: 
    1:             pn3 = pn2->pn_expr;
    1:             if (pn3) {
20413:                 JS_ASSERT(!forInVar);
    1:                 if (op == JSOP_SETNAME) {
    1:                     JS_ASSERT(!let);
 3235:                     EMIT_INDEX_OP(JSOP_BINDNAME, atomIndex);
    1:                 }
    1:                 if (pn->pn_op == JSOP_DEFCONST &&
    1:                     !js_DefineCompileTimeConstant(cx, cg, pn2->pn_atom,
    1:                                                   pn3)) {
    1:                     return JS_FALSE;
    1:                 }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:                 /* Evaluate expr in the outer lexical scope if requested. */
    1:                 if (popScope) {
    1:                     stmt = tc->topStmt;
    1:                     scopeStmt = tc->topScopeStmt;
    1: 
    1:                     tc->topStmt = stmt->down;
    1:                     tc->topScopeStmt = scopeStmt->downScope;
    1:                 }
    1: # ifdef __GNUC__
20413:                 else stmt = scopeStmt = NULL;   /* quell GCC overwarning */
    1: # endif
    1: #endif
    1: 
    1:                 oldflags = cg->treeContext.flags;
    1:                 cg->treeContext.flags &= ~TCF_IN_FOR_INIT;
    1:                 if (!js_EmitTree(cx, cg, pn3))
    1:                     return JS_FALSE;
    1:                 cg->treeContext.flags |= oldflags & TCF_IN_FOR_INIT;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:                 if (popScope) {
    1:                     tc->topStmt = stmt;
    1:                     tc->topScopeStmt = scopeStmt;
    1:                 }
    1: #endif
    1:             }
    1:         }
    1: 
    1:         /*
20413:          * The parser rewrites 'for (var x = i in o)' to hoist 'var x = i' --
20413:          * likewise 'for (let x = i in o)' becomes 'i; for (let x in o)' using
20413:          * a TOK_SEQ node to make the two statements appear as one. Therefore
20413:          * if this declaration is part of a for-in loop head, we do not need to
20413:          * emit op or any source note. Our caller, the TOK_FOR/TOK_IN case in
20413:          * js_EmitTree, will annotate appropriately.
    1:          */
    1:         JS_ASSERT(pn3 == pn2->pn_expr);
20413:         if (forInVar) {
    1:             JS_ASSERT(pn->pn_count == 1);
20413:             JS_ASSERT(!pn3);
    1:             break;
    1:         }
    1: 
    1:         if (pn2 == pn->pn_head &&
    1:             !inLetHead &&
    1:             js_NewSrcNote2(cx, cg, SRC_DECL,
    1:                            (pn->pn_op == JSOP_DEFCONST)
    1:                            ? SRC_DECL_CONST
    1:                            : (pn->pn_op == JSOP_DEFVAR)
    1:                            ? SRC_DECL_VAR
    1:                            : SRC_DECL_LET) < 0) {
    1:             return JS_FALSE;
    1:         }
    1:         if (op == JSOP_ARGUMENTS) {
    1:             if (js_Emit1(cx, cg, op) < 0)
    1:                 return JS_FALSE;
    1:         } else if (pn2->pn_slot >= 0) {
    1:             EMIT_UINT16_IMM_OP(op, atomIndex);
    1:         } else {
 3235:             EMIT_INDEX_OP(op, atomIndex);
    1:         }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:     emit_note_pop:
    1: #endif
    1:         tmp = CG_OFFSET(cg);
    1:         if (noteIndex >= 0) {
    1:             if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, tmp-off))
    1:                 return JS_FALSE;
    1:         }
    1:         if (!pn2->pn_next)
    1:             break;
    1:         off = tmp;
    1:         noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
    1:         if (noteIndex < 0 || js_Emit1(cx, cg, JSOP_POP) < 0)
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     /* If this is a let head, emit and return a srcnote on the pop. */
    1:     if (inLetHead) {
    1:         *headNoteIndex = js_NewSrcNote(cx, cg, SRC_DECL);
    1:         if (*headNoteIndex < 0)
    1:             return JS_FALSE;
    1:         if (!(pn->pn_extra & PNX_POPVAR))
    1:             return js_Emit1(cx, cg, JSOP_NOP) >= 0;
    1:     }
    1: 
    1:     return !(pn->pn_extra & PNX_POPVAR) || js_Emit1(cx, cg, JSOP_POP) >= 0;
    1: }
    1: 
10217: #if defined DEBUG_brendanXXX || defined DEBUG_mrbkap
    1: static JSBool
    1: GettableNoteForNextOp(JSCodeGenerator *cg)
    1: {
    1:     ptrdiff_t offset, target;
    1:     jssrcnote *sn, *end;
    1: 
    1:     offset = 0;
    1:     target = CG_OFFSET(cg);
    1:     for (sn = CG_NOTES(cg), end = sn + CG_NOTE_COUNT(cg); sn < end;
    1:          sn = SN_NEXT(sn)) {
    1:         if (offset == target && SN_IS_GETTABLE(sn))
    1:             return JS_TRUE;
    1:         offset += SN_DELTA(sn);
    1:     }
    1:     return JS_FALSE;
    1: }
    1: #endif
    1: 
10466: /* Top-level named functions need a nop for decompilation. */
10466: static JSBool
10466: EmitFunctionDefNop(JSContext *cx, JSCodeGenerator *cg, uintN index)
10466: {
10466:     return js_NewSrcNote2(cx, cg, SRC_FUNCDEF, (ptrdiff_t)index) >= 0 &&
10466:            js_Emit1(cx, cg, JSOP_NOP) >= 0;
10466: }
10466: 
21520: /* See the SRC_FOR source note offsetBias comments later in this file. */
21520: JS_STATIC_ASSERT(JSOP_NOP_LENGTH == 1);
21520: JS_STATIC_ASSERT(JSOP_POP_LENGTH == 1);
21520: 
    1: JSBool
    1: js_EmitTree(JSContext *cx, JSCodeGenerator *cg, JSParseNode *pn)
    1: {
    1:     JSBool ok, useful, wantval;
    1:     JSStmtInfo *stmt, stmtInfo;
    1:     ptrdiff_t top, off, tmp, beq, jmp;
    1:     JSParseNode *pn2, *pn3;
    1:     JSAtom *atom;
    1:     JSAtomListElement *ale;
    1:     jsatomid atomIndex;
 3235:     uintN index;
    1:     ptrdiff_t noteIndex;
    1:     JSSrcNoteType noteType;
    1:     jsbytecode *pc;
    1:     JSOp op;
    1:     JSTokenType type;
    1:     uint32 argc;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     ok = JS_TRUE;
    1:     cg->emitLevel++;
    1:     pn->pn_offset = top = CG_OFFSET(cg);
    1: 
    1:     /* Emit notes to tell the current bytecode's source line number. */
    1:     UPDATE_LINE_NUMBER_NOTES(cx, cg, pn);
    1: 
    1:     switch (pn->pn_type) {
    1:       case TOK_FUNCTION:
    1:       {
13702:         JSFunction *fun;
    1:         void *cg2mark;
    1:         JSCodeGenerator *cg2;
 5884:         uintN slot;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:         if (pn->pn_arity == PN_NULLARY) {
    1:             if (js_Emit1(cx, cg, JSOP_GETFUNNS) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1:         }
    1: #endif
    1: 
13824:         fun = (JSFunction *) pn->pn_funpob->object;
13702:         if (fun->u.i.script) {
10466:             /*
10466:              * This second pass is needed to emit JSOP_NOP with a source note
16051:              * for the already-emitted function definition prolog opcode. See
16051:              * comments in the TOK_LC case.
10466:              */
10466:             JS_ASSERT(pn->pn_op == JSOP_NOP);
10466:             JS_ASSERT(cg->treeContext.flags & TCF_IN_FUNCTION);
10466:             JS_ASSERT(pn->pn_index != (uint32) -1);
10466:             if (!EmitFunctionDefNop(cx, cg, pn->pn_index))
10466:                 return JS_FALSE;
10466:             break;
10466:         }
10466: 
18308:         /*
18308:          * Limit static nesting depth to fit in 16 bits. See cg2->staticDepth
18308:          * assignment below.
18308:          */
18308:         if (cg->staticDepth == JS_BITMASK(16)) {
18308:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_TOO_DEEP,
18308:                                  js_function_str);
18308:             return JS_FALSE;
18308:         }
18308: 
    1:         /* Generate code for the function's body. */
11534:         cg2mark = JS_ARENA_MARK(cg->codePool);
11534:         JS_ARENA_ALLOCATE_TYPE(cg2, JSCodeGenerator, cg->codePool);
    1:         if (!cg2) {
 8296:             js_ReportOutOfScriptQuota(cx);
    1:             return JS_FALSE;
    1:         }
 6561:         js_InitCodeGenerator(cx, cg2, cg->treeContext.parseContext,
 3235:                              cg->codePool, cg->notePool,
 6561:                              pn->pn_pos.begin.lineno);
    1:         cg2->treeContext.flags = (uint16) (pn->pn_flags | TCF_IN_FUNCTION);
18955:         cg2->treeContext.u.fun = fun;
18308:         cg2->staticDepth = cg->staticDepth + 1;
    1:         cg2->parent = cg;
16072: 
16072:         /* We metered the max scope depth when parsed the function. */
16072:         JS_SCOPE_DEPTH_METERING(cg2->treeContext.maxScopeDepth = (uintN) -1);
 9786:         if (!js_EmitFunctionScript(cx, cg2, pn->pn_body)) {
 9786:             pn = NULL;
 9786:         } else {
    1:             /*
    1:              * We need an activation object if an inner peeks out, or if such
    1:              * inner-peeking caused one of our inners to become heavyweight.
    1:              */
    1:             if (cg2->treeContext.flags &
    1:                 (TCF_FUN_USES_NONLOCALS | TCF_FUN_HEAVYWEIGHT)) {
    1:                 cg->treeContext.flags |= TCF_FUN_HEAVYWEIGHT;
    1:             }
 9786:         }
18308: 
    1:         js_FinishCodeGenerator(cx, cg2);
11534:         JS_ARENA_RELEASE(cg->codePool, cg2mark);
11534:         cg2 = NULL;
 9786:         if (!pn)
 9786:             return JS_FALSE;
    1: 
    1:         /* Make the function object a literal in the outer script's pool. */
 3235:         index = IndexParsedObject(pn->pn_funpob, &cg->objectList);
    1: 
    1:         /* Emit a bytecode pointing to the closure object in its immediate. */
    1:         if (pn->pn_op != JSOP_NOP) {
 1577:             if ((pn->pn_flags & TCF_GENEXP_LAMBDA) &&
 1577:                 js_NewSrcNote(cx, cg, SRC_GENEXP) < 0) {
 1577:                 return JS_FALSE;
 1577:             }
 3235:             EMIT_INDEX_OP(PN_OP(pn), index);
    1:             break;
    1:         }
    1: 
10466:         /*
10466:          * For a script we emit the code as we parse. Thus the bytecode for
10466:          * top-level functions should go in the prolog to predefine their
10466:          * names in the variable object before the already-generated main code
10466:          * is executed. This extra work for top-level scripts is not necessary
10466:          * when we emit the code for a function. It is fully parsed prior to
10466:          * invocation of the emitter and calls to js_EmitTree for function
10466:          * definitions can be scheduled before generating the rest of code.
10466:          */
10466:         if (!(cg->treeContext.flags & TCF_IN_FUNCTION)) {
18965:             JS_ASSERT(!cg->treeContext.topStmt);
    1:             CG_SWITCH_TO_PROLOG(cg);
18965:             EMIT_INDEX_OP(JSOP_DEFFUN, index);
10466:             CG_SWITCH_TO_MAIN(cg);
10466: 
10466:             /* Emit NOP for the decompiler. */
10466:             if (!EmitFunctionDefNop(cx, cg, index))
    1:                 return JS_FALSE;
    1:         } else {
 8899: #ifdef DEBUG
 8899:             JSLocalKind localKind =
 5884: #endif
18955:                 js_LookupLocal(cx, cg->treeContext.u.fun, fun->atom, &slot);
 8899:             JS_ASSERT(localKind == JSLOCAL_VAR || localKind == JSLOCAL_CONST);
10466:             JS_ASSERT(pn->pn_index == (uint32) -1);
10466:             pn->pn_index = index;
 8899:             if (!EmitSlotIndexOp(cx, JSOP_DEFLOCALFUN, slot, index, cg))
 8899:                 return JS_FALSE;
 8899:         }
    1:         break;
    1:       }
    1: 
    1: 
    1:       case TOK_IF:
    1:         /* Initialize so we can detect else-if chains and avoid recursion. */
    1:         stmtInfo.type = STMT_IF;
    1:         beq = jmp = -1;
    1:         noteIndex = -1;
    1: 
    1:       if_again:
    1:         /* Emit code for the condition before pushing stmtInfo. */
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid1))
    1:             return JS_FALSE;
    1:         top = CG_OFFSET(cg);
    1:         if (stmtInfo.type == STMT_IF) {
    1:             js_PushStatement(&cg->treeContext, &stmtInfo, STMT_IF, top);
    1:         } else {
    1:             /*
    1:              * We came here from the goto further below that detects else-if
    1:              * chains, so we must mutate stmtInfo back into a STMT_IF record.
    1:              * Also (see below for why) we need a note offset for SRC_IF_ELSE
    1:              * to help the decompiler.  Actually, we need two offsets, one for
    1:              * decompiling any else clause and the second for decompiling an
    1:              * else-if chain without bracing, overindenting, or incorrectly
    1:              * scoping let declarations.
    1:              */
    1:             JS_ASSERT(stmtInfo.type == STMT_ELSE);
    1:             stmtInfo.type = STMT_IF;
    1:             stmtInfo.update = top;
    1:             if (!js_SetSrcNoteOffset(cx, cg, noteIndex, 0, jmp - beq))
    1:                 return JS_FALSE;
    1:             if (!js_SetSrcNoteOffset(cx, cg, noteIndex, 1, top - jmp))
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         /* Emit an annotated branch-if-false around the then part. */
    1:         pn3 = pn->pn_kid3;
    1:         noteIndex = js_NewSrcNote(cx, cg, pn3 ? SRC_IF_ELSE : SRC_IF);
    1:         if (noteIndex < 0)
    1:             return JS_FALSE;
    1:         beq = EmitJump(cx, cg, JSOP_IFEQ, 0);
    1:         if (beq < 0)
    1:             return JS_FALSE;
    1: 
    1:         /* Emit code for the then and optional else parts. */
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid2))
    1:             return JS_FALSE;
    1:         if (pn3) {
    1:             /* Modify stmtInfo so we know we're in the else part. */
    1:             stmtInfo.type = STMT_ELSE;
    1: 
    1:             /*
    1:              * Emit a JSOP_BACKPATCH op to jump from the end of our then part
    1:              * around the else part.  The js_PopStatementCG call at the bottom
    1:              * of this switch case will fix up the backpatch chain linked from
    1:              * stmtInfo.breaks.
    1:              */
    1:             jmp = EmitGoto(cx, cg, &stmtInfo, &stmtInfo.breaks, NULL, SRC_NULL);
    1:             if (jmp < 0)
    1:                 return JS_FALSE;
    1: 
    1:             /* Ensure the branch-if-false comes here, then emit the else. */
    1:             CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, beq);
    1:             if (pn3->pn_type == TOK_IF) {
    1:                 pn = pn3;
    1:                 goto if_again;
    1:             }
    1: 
    1:             if (!js_EmitTree(cx, cg, pn3))
    1:                 return JS_FALSE;
    1: 
    1:             /*
    1:              * Annotate SRC_IF_ELSE with the offset from branch to jump, for
    1:              * the decompiler's benefit.  We can't just "back up" from the pc
    1:              * of the else clause, because we don't know whether an extended
    1:              * jump was required to leap from the end of the then clause over
    1:              * the else clause.
    1:              */
    1:             if (!js_SetSrcNoteOffset(cx, cg, noteIndex, 0, jmp - beq))
    1:                 return JS_FALSE;
    1:         } else {
    1:             /* No else part, fixup the branch-if-false to come here. */
    1:             CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, beq);
    1:         }
    1:         ok = js_PopStatementCG(cx, cg);
    1:         break;
    1: 
    1:       case TOK_SWITCH:
    1:         /* Out of line to avoid bloating js_EmitTree's stack frame size. */
    1:         ok = EmitSwitch(cx, cg, pn, &stmtInfo);
    1:         break;
    1: 
    1:       case TOK_WHILE:
    1:         /*
    1:          * Minimize bytecodes issued for one or more iterations by jumping to
    1:          * the condition below the body and closing the loop if the condition
    1:          * is true with a backward branch. For iteration count i:
    1:          *
    1:          *  i    test at the top                 test at the bottom
    1:          *  =    ===============                 ==================
    1:          *  0    ifeq-pass                       goto; ifne-fail
    1:          *  1    ifeq-fail; goto; ifne-pass      goto; ifne-pass; ifne-fail
    1:          *  2    2*(ifeq-fail; goto); ifeq-pass  goto; 2*ifne-pass; ifne-fail
    1:          *  . . .
    1:          *  N    N*(ifeq-fail; goto); ifeq-pass  goto; N*ifne-pass; ifne-fail
    1:          *
    1:          * SpiderMonkey, pre-mozilla.org, emitted while parsing and so used
    1:          * test at the top. When JSParseNode trees were added during the ES3
    1:          * work (1998-9), the code generation scheme was not optimized, and
    1:          * the decompiler continued to take advantage of the branch and jump
    1:          * that bracketed the body. But given the SRC_WHILE note, it is easy
    1:          * to support the more efficient scheme.
    1:          */
    1:         js_PushStatement(&cg->treeContext, &stmtInfo, STMT_WHILE_LOOP, top);
    1:         noteIndex = js_NewSrcNote(cx, cg, SRC_WHILE);
    1:         if (noteIndex < 0)
    1:             return JS_FALSE;
    1:         jmp = EmitJump(cx, cg, JSOP_GOTO, 0);
    1:         if (jmp < 0)
    1:             return JS_FALSE;
    1:         top = CG_OFFSET(cg);
    1:         if (!js_EmitTree(cx, cg, pn->pn_right))
    1:             return JS_FALSE;
    1:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, jmp);
    1:         if (!js_EmitTree(cx, cg, pn->pn_left))
    1:             return JS_FALSE;
    1:         beq = EmitJump(cx, cg, JSOP_IFNE, top - CG_OFFSET(cg));
    1:         if (beq < 0)
    1:             return JS_FALSE;
    1:         if (!js_SetSrcNoteOffset(cx, cg, noteIndex, 0, beq - jmp))
    1:             return JS_FALSE;
    1:         ok = js_PopStatementCG(cx, cg);
    1:         break;
    1: 
    1:       case TOK_DO:
    1:         /* Emit an annotated nop so we know to decompile a 'do' keyword. */
    1:         noteIndex = js_NewSrcNote(cx, cg, SRC_WHILE);
    1:         if (noteIndex < 0 || js_Emit1(cx, cg, JSOP_NOP) < 0)
    1:             return JS_FALSE;
    1: 
    1:         /* Compile the loop body. */
    1:         top = CG_OFFSET(cg);
    1:         js_PushStatement(&cg->treeContext, &stmtInfo, STMT_DO_LOOP, top);
    1:         if (!js_EmitTree(cx, cg, pn->pn_left))
    1:             return JS_FALSE;
    1: 
    1:         /* Set loop and enclosing label update offsets, for continue. */
    1:         stmt = &stmtInfo;
    1:         do {
    1:             stmt->update = CG_OFFSET(cg);
    1:         } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
    1: 
    1:         /* Compile the loop condition, now that continues know where to go. */
    1:         if (!js_EmitTree(cx, cg, pn->pn_right))
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Since we use JSOP_IFNE for other purposes as well as for do-while
    1:          * loops, we must store 1 + (beq - top) in the SRC_WHILE note offset,
    1:          * and the decompiler must get that delta and decompile recursively.
    1:          */
    1:         beq = EmitJump(cx, cg, JSOP_IFNE, top - CG_OFFSET(cg));
    1:         if (beq < 0)
    1:             return JS_FALSE;
    1:         if (!js_SetSrcNoteOffset(cx, cg, noteIndex, 0, 1 + (beq - top)))
    1:             return JS_FALSE;
    1:         ok = js_PopStatementCG(cx, cg);
    1:         break;
    1: 
    1:       case TOK_FOR:
    1:         beq = 0;                /* suppress gcc warnings */
15556:         jmp = -1;
    1:         pn2 = pn->pn_left;
    1:         js_PushStatement(&cg->treeContext, &stmtInfo, STMT_FOR_LOOP, top);
    1: 
    1:         if (pn2->pn_type == TOK_IN) {
    1:             /* Set stmtInfo type for later testing. */
    1:             stmtInfo.type = STMT_FOR_IN_LOOP;
    1: 
    1:             /*
    1:              * If the left part is 'var x', emit code to define x if necessary
    1:              * using a prolog opcode, but do not emit a pop.  If the left part
    1:              * is 'var x = i', emit prolog code to define x if necessary; then
    1:              * emit code to evaluate i, assign the result to x, and pop the
    1:              * result off the stack.
    1:              *
    1:              * All the logic to do this is implemented in the outer switch's
    1:              * TOK_VAR case, conditioned on pn_extra flags set by the parser.
    1:              *
    1:              * In the 'for (var x = i in o) ...' case, the js_EmitTree(...pn3)
    1:              * called here will generate the proper note for the assignment
    1:              * op that sets x = i, hoisting the initialized var declaration
    1:              * out of the loop: 'var x = i; for (x in o) ...'.
    1:              *
    1:              * In the 'for (var x in o) ...' case, nothing but the prolog op
    1:              * (if needed) should be generated here, we must emit the note
    1:              * just before the JSOP_FOR* opcode in the switch on pn3->pn_type
    1:              * a bit below, so nothing is hoisted: 'for (var x in o) ...'.
    1:              *
    1:              * A 'for (let x = i in o)' loop must not be hoisted, since in
    1:              * this form the let variable is scoped by the loop body (but not
    1:              * the head).  The initializer expression i must be evaluated for
    1:              * any side effects.  So we hoist only i in the let case.
    1:              */
    1:             pn3 = pn2->pn_left;
 3164:             type = PN_TYPE(pn3);
    1:             cg->treeContext.flags |= TCF_IN_FOR_INIT;
    1:             if (TOKEN_TYPE_IS_DECL(type) && !js_EmitTree(cx, cg, pn3))
    1:                 return JS_FALSE;
    1:             cg->treeContext.flags &= ~TCF_IN_FOR_INIT;
    1: 
    1:             /* Compile the object expression to the right of 'in'. */
    1:             if (!js_EmitTree(cx, cg, pn2->pn_right))
    1:                 return JS_FALSE;
    1: 
    1:             /*
    1:              * Emit a bytecode to convert top of stack value to the iterator
    1:              * object depending on the loop variant (for-in, for-each-in, or
    1:              * destructuring for-in).
    1:              */
15613:             JS_ASSERT(pn->pn_op == JSOP_ITER);
21441:             if (js_Emit2(cx, cg, JSOP_ITER, (uint8) pn->pn_iflags) < 0)
    1:                 return JS_FALSE;
    1: 
20943:             /* Annotate so the decompiler can find the loop-closing jump. */
20943:             noteIndex = js_NewSrcNote(cx, cg, SRC_FOR_IN);
20943:             if (noteIndex < 0)
20943:                 return JS_FALSE;
20943: 
20943:             /*
20943:              * Jump down to the loop condition to minimize overhead assuming at
20943:              * least one iteration, as the other loop forms do.
20943:              */
20943:             jmp = EmitJump(cx, cg, JSOP_GOTO, 0);
20943:             if (jmp < 0)
20943:                 return JS_FALSE;
20943: 
    1:             top = CG_OFFSET(cg);
    1:             SET_STATEMENT_TOP(&stmtInfo, top);
    1: 
21441: #ifdef DEBUG
21441:             intN loopDepth = cg->stackDepth;
21441: #endif
21441: 
    1:             /*
    1:              * Compile a JSOP_FOR* bytecode based on the left hand side.
    1:              *
    1:              * Initialize op to JSOP_SETNAME in case of |for ([a, b] in o)...|
    1:              * or similar, to signify assignment, rather than declaration, to
    1:              * the decompiler.  EmitDestructuringOps takes a prolog bytecode
    1:              * parameter and emits the appropriate source note, defaulting to
    1:              * assignment, so JSOP_SETNAME is not critical here; many similar
    1:              * ops could be used -- just not JSOP_NOP (which means 'let').
    1:              */
    1:             op = JSOP_SETNAME;
    1:             switch (type) {
    1: #if JS_HAS_BLOCK_SCOPE
    1:               case TOK_LET:
    1: #endif
    1:               case TOK_VAR:
    1:                 JS_ASSERT(pn3->pn_arity == PN_LIST && pn3->pn_count == 1);
    1:                 pn3 = pn3->pn_head;
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (pn3->pn_type == TOK_ASSIGN) {
    1:                     pn3 = pn3->pn_left;
    1:                     JS_ASSERT(pn3->pn_type == TOK_RB || pn3->pn_type == TOK_RC);
    1:                 }
    1:                 if (pn3->pn_type == TOK_RB || pn3->pn_type == TOK_RC) {
 3164:                     op = PN_OP(pn2->pn_left);
    1:                     goto destructuring_for;
    1:                 }
    1: #else
    1:                 JS_ASSERT(pn3->pn_type == TOK_NAME);
    1: #endif
20943:                 /* FALL THROUGH */
20943: 
20943:               case TOK_NAME:
    1:                 /*
    1:                  * Always annotate JSOP_FORLOCAL if given input of the form
    1:                  * 'for (let x in * o)' -- the decompiler must not hoist the
    1:                  * 'let x' out of the loop head, or x will be bound in the
    1:                  * wrong scope.  Likewise, but in this case only for the sake
    1:                  * of higher decompilation fidelity only, do not hoist 'var x'
20943:                  * when given 'for (var x in o)'.
    1:                  */
    1:                 if ((
    1: #if JS_HAS_BLOCK_SCOPE
    1:                      type == TOK_LET ||
    1: #endif
20943:                      (type == TOK_VAR && !pn3->pn_expr)) &&
    1:                     js_NewSrcNote2(cx, cg, SRC_DECL,
21520:                                    (type == TOK_VAR)
    1:                                    ? SRC_DECL_VAR
    1:                                    : SRC_DECL_LET) < 0) {
    1:                     return JS_FALSE;
    1:                 }
    1:                 if (pn3->pn_slot >= 0) {
 3164:                     op = PN_OP(pn3);
    1:                     switch (op) {
    1:                       case JSOP_GETARG:   /* FALL THROUGH */
    1:                       case JSOP_SETARG:   op = JSOP_FORARG; break;
    1:                       case JSOP_GETGVAR:  /* FALL THROUGH */
    1:                       case JSOP_SETGVAR:  op = JSOP_FORNAME; break;
    1:                       case JSOP_GETLOCAL: /* FALL THROUGH */
    1:                       case JSOP_SETLOCAL: op = JSOP_FORLOCAL; break;
    1:                       default:            JS_ASSERT(0);
    1:                     }
    1:                 } else {
    1:                     pn3->pn_op = JSOP_FORNAME;
16378:                     if (!BindNameToSlot(cx, cg, pn3))
    1:                         return JS_FALSE;
 3164:                     op = PN_OP(pn3);
    1:                 }
    1:                 if (pn3->pn_slot >= 0) {
 8179:                     if (pn3->pn_const) {
16429:                         JS_ASSERT(op == JSOP_FORLOCAL);
21441:                         js_ReportCompileErrorNumber(cx, CG_TS(cg), pn3, JSREPORT_ERROR,
21441:                                                     JSMSG_BAD_FOR_LEFTSIDE);
21441:                         return JS_FALSE;
    1:                     }
    1:                     atomIndex = (jsatomid) pn3->pn_slot;
    1:                     EMIT_UINT16_IMM_OP(op, atomIndex);
    1:                 } else {
    1:                     if (!EmitAtomOp(cx, pn3, op, cg))
    1:                         return JS_FALSE;
    1:                 }
    1:                 break;
    1: 
    1:               case TOK_DOT:
20943:                 /*
20943:                  * 'for (o.p in q)' can use JSOP_FORPROP only if evaluating 'o'
20943:                  * has no side effects.
20943:                  */
    1:                 useful = JS_FALSE;
 9604:                 if (!CheckSideEffects(cx, cg, pn3->pn_expr, &useful))
 9604:                     return JS_FALSE;
    1:                 if (!useful) {
    1:                     if (!EmitPropOp(cx, pn3, JSOP_FORPROP, cg, JS_FALSE))
    1:                         return JS_FALSE;
    1:                     break;
    1:                 }
    1:                 /* FALL THROUGH */
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1:               destructuring_for:
    1: #endif
20943:               default:
21441:                 if (js_Emit1(cx, cg, JSOP_FORELEM) < 0)
21441:                     return JS_FALSE;
21441:                 JS_ASSERT(cg->stackDepth >= 3);
21441: 
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (pn3->pn_type == TOK_RB || pn3->pn_type == TOK_RC) {
    1:                     if (!EmitDestructuringOps(cx, cg, op, pn3))
    1:                         return JS_FALSE;
    1:                     if (js_Emit1(cx, cg, JSOP_POP) < 0)
    1:                         return JS_FALSE;
20943:                 } else
    1: #endif
    1: #if JS_HAS_LVALUE_RETURN
    1:                 if (pn3->pn_type == TOK_LP) {
    1:                     JS_ASSERT(pn3->pn_op == JSOP_SETCALL);
    1:                     if (!js_EmitTree(cx, cg, pn3))
    1:                         return JS_FALSE;
15428:                     if (js_Emit1(cx, cg, JSOP_ENUMELEM) < 0)
    1:                         return JS_FALSE;
20943:                 } else
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:                 if (pn3->pn_type == TOK_UNARYOP) {
    1:                     JS_ASSERT(pn3->pn_op == JSOP_BINDXMLNAME);
    1:                     if (!js_EmitTree(cx, cg, pn3))
    1:                         return JS_FALSE;
15428:                     if (js_Emit1(cx, cg, JSOP_ENUMELEM) < 0)
    1:                         return JS_FALSE;
20943:                 } else
20943: #endif
20943:                 if (!EmitElemOp(cx, pn3, JSOP_ENUMELEM, cg))
20943:                     return JS_FALSE;
    1:                 break;
    1:             }
    1: 
21441:             /* The stack should be balanced around the JSOP_FOR* opcode sequence. */
21441:             JS_ASSERT(cg->stackDepth == loopDepth);
21441: 
21441:             /* Set the first srcnote offset so we can find the start of the loop body. */
21441:             if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, CG_OFFSET(cg) - jmp))
21441:                 return JS_FALSE;
21441: 
21441:             /* Emit code for the loop body. */
21441:             if (!js_EmitTree(cx, cg, pn->pn_right))
21441:                 return JS_FALSE;
21441: 
21441:             /* Set loop and enclosing "update" offsets, for continue. */
21441:             stmt = &stmtInfo;
21441:             do {
21441:                 stmt->update = CG_OFFSET(cg);
21441:             } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
21441: 
21441:             /*
21441:              * Fixup the goto that starts the loop to jump down to JSOP_NEXTITER.
21441:              */
21441:             CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, jmp);
21441:             if (js_Emit1(cx, cg, JSOP_NEXTITER) < 0)
21441:                 return JS_FALSE;
20943:             beq = EmitJump(cx, cg, JSOP_IFNE, top - CG_OFFSET(cg));
    1:             if (beq < 0)
    1:                 return JS_FALSE;
20943: 
20943:             /* Set the second srcnote offset so we can find the closing jump. */
20943:             if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 1, beq - jmp))
15556:                 return JS_FALSE;
    1:         } else {
15556:             /* C-style for (init; cond; update) ... loop. */
    1:             op = JSOP_POP;
10779:             pn3 = pn2->pn_kid1;
10779:             if (!pn3) {
    1:                 /* No initializer: emit an annotated nop for the decompiler. */
    1:                 op = JSOP_NOP;
    1:             } else {
    1:                 cg->treeContext.flags |= TCF_IN_FOR_INIT;
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (pn3->pn_type == TOK_ASSIGN &&
    1:                     !MaybeEmitGroupAssignment(cx, cg, op, pn3, &op)) {
    1:                     return JS_FALSE;
    1:                 }
    1: #endif
    1:                 if (op == JSOP_POP) {
    1:                     if (!js_EmitTree(cx, cg, pn3))
    1:                         return JS_FALSE;
    1:                     if (TOKEN_TYPE_IS_DECL(pn3->pn_type)) {
    1:                         /*
    1:                          * Check whether a destructuring-initialized var decl
    1:                          * was optimized to a group assignment.  If so, we do
    1:                          * not need to emit a pop below, so switch to a nop,
    1:                          * just for the decompiler.
    1:                          */
    1:                         JS_ASSERT(pn3->pn_arity == PN_LIST);
    1:                         if (pn3->pn_extra & PNX_GROUPINIT)
    1:                             op = JSOP_NOP;
    1:                     }
    1:                 }
    1:                 cg->treeContext.flags &= ~TCF_IN_FOR_INIT;
    1:             }
21520: 
21520:             /*
21520:              * NB: the SRC_FOR note has offsetBias 1 (JSOP_{NOP,POP}_LENGTH).
21520:              * Use tmp to hold the biased srcnote "top" offset, which differs
21520:              * from the top local variable by the length of the JSOP_GOTO{,X}
21520:              * emitted in between tmp and top if this loop has a condition.
21520:              */
    1:             noteIndex = js_NewSrcNote(cx, cg, SRC_FOR);
21520:             if (noteIndex < 0 || js_Emit1(cx, cg, op) < 0)
21520:                 return JS_FALSE;
21520:             tmp = CG_OFFSET(cg);
    1: 
15556:             if (pn2->pn_kid2) {
15556:                 /* Goto the loop condition, which branches back to iterate. */
15556:                 jmp = EmitJump(cx, cg, JSOP_GOTO, 0);
15556:                 if (jmp < 0)
15556:                     return JS_FALSE;
15556:             }
21520: 
    1:             top = CG_OFFSET(cg);
    1:             SET_STATEMENT_TOP(&stmtInfo, top);
    1: 
    1:             /* Emit code for the loop body. */
    1:             if (!js_EmitTree(cx, cg, pn->pn_right))
    1:                 return JS_FALSE;
    1: 
    1:             /* Set the second note offset so we can find the update part. */
    1:             JS_ASSERT(noteIndex != -1);
    1:             if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 1,
21520:                                      CG_OFFSET(cg) - tmp)) {
    1:                 return JS_FALSE;
    1:             }
    1: 
    1:             /* Set loop and enclosing "update" offsets, for continue. */
    1:             stmt = &stmtInfo;
    1:             do {
    1:                 stmt->update = CG_OFFSET(cg);
15556:             } while ((stmt = stmt->down) != NULL && stmt->type == STMT_LABEL);
15556: 
15556:             /* Check for update code to do before the condition (if any). */
15556:             pn3 = pn2->pn_kid3;
15556:             if (pn3) {
    1:                 op = JSOP_POP;
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (pn3->pn_type == TOK_ASSIGN &&
    1:                     !MaybeEmitGroupAssignment(cx, cg, op, pn3, &op)) {
    1:                     return JS_FALSE;
    1:                 }
    1: #endif
21520:                 if (op == JSOP_POP && !js_EmitTree(cx, cg, pn3))
21520:                     return JS_FALSE;
21520: 
21520:                 /* Always emit the POP or NOP, to help the decompiler. */
    1:                 if (js_Emit1(cx, cg, op) < 0)
    1:                     return JS_FALSE;
    1: 
    1:                 /* Restore the absolute line number for source note readers. */
    1:                 off = (ptrdiff_t) pn->pn_pos.end.lineno;
    1:                 if (CG_CURRENT_LINE(cg) != (uintN) off) {
    1:                     if (js_NewSrcNote2(cx, cg, SRC_SETLINE, off) < 0)
    1:                         return JS_FALSE;
    1:                     CG_CURRENT_LINE(cg) = (uintN) off;
    1:                 }
    1:             }
    1: 
15556:             /* Set the first note offset so we can find the loop condition. */
15556:             if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0,
21520:                                      CG_OFFSET(cg) - tmp)) {
15556:                 return JS_FALSE;
15556:             }
15556: 
15556:             if (pn2->pn_kid2) {
15556:                 /* Fix up the goto from top to target the loop condition. */
15556:                 JS_ASSERT(jmp >= 0);
15556:                 CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, jmp);
15556: 
15556:                 if (!js_EmitTree(cx, cg, pn2->pn_kid2))
15556:                     return JS_FALSE;
15556:             }
15556: 
    1:             /* The third note offset helps us find the loop-closing jump. */
    1:             if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 2,
21520:                                      CG_OFFSET(cg) - tmp)) {
    1:                 return JS_FALSE;
    1:             }
15556: 
15556:             if (pn2->pn_kid2) {
15556:                 beq = EmitJump(cx, cg, JSOP_IFNE, top - CG_OFFSET(cg));
15556:                 if (beq < 0)
15556:                     return JS_FALSE;
15556:             } else {
15556:                 /* No loop condition -- emit the loop-closing jump. */
    1:                 jmp = EmitJump(cx, cg, JSOP_GOTO, top - CG_OFFSET(cg));
    1:                 if (jmp < 0)
    1:                     return JS_FALSE;
15556:             }
    1:         }
    1: 
    1:         /* Now fixup all breaks and continues (before for/in's JSOP_ENDITER). */
    1:         if (!js_PopStatementCG(cx, cg))
    1:             return JS_FALSE;
    1: 
    1:         if (pn2->pn_type == TOK_IN) {
 3025:             /*
21441:              * JSOP_ENDITER must have a slot to save an exception thrown from
21441:              * the body of for-in loop when closing the iterator object, and
21441:              * fortunately it does: the slot that was set by JSOP_NEXTITER to
21441:              * the return value of iterator.next().
21441:              */
21441:             JS_ASSERT(js_CodeSpec[JSOP_ENDITER].nuses == 2);
21441:             if (!NewTryNote(cx, cg, JSTRY_ITER, cg->stackDepth, top, CG_OFFSET(cg)) ||
 3025:                 js_Emit1(cx, cg, JSOP_ENDITER) < 0) {
 3025:                 return JS_FALSE;
 3025:             }
    1:         }
    1:         break;
    1: 
    1:       case TOK_BREAK:
    1:         stmt = cg->treeContext.topStmt;
    1:         atom = pn->pn_atom;
    1:         if (atom) {
    1:             ale = js_IndexAtom(cx, atom, &cg->atomList);
    1:             if (!ale)
    1:                 return JS_FALSE;
 3235:             while (stmt->type != STMT_LABEL || stmt->u.label != atom)
    1:                 stmt = stmt->down;
    1:             noteType = SRC_BREAK2LABEL;
    1:         } else {
    1:             ale = NULL;
    1:             while (!STMT_IS_LOOP(stmt) && stmt->type != STMT_SWITCH)
    1:                 stmt = stmt->down;
19659:             noteType = (stmt->type == STMT_SWITCH) ? SRC_NULL : SRC_BREAK;
    1:         }
    1: 
    1:         if (EmitGoto(cx, cg, stmt, &stmt->breaks, ale, noteType) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case TOK_CONTINUE:
    1:         stmt = cg->treeContext.topStmt;
    1:         atom = pn->pn_atom;
    1:         if (atom) {
    1:             /* Find the loop statement enclosed by the matching label. */
    1:             JSStmtInfo *loop = NULL;
    1:             ale = js_IndexAtom(cx, atom, &cg->atomList);
    1:             if (!ale)
    1:                 return JS_FALSE;
 3235:             while (stmt->type != STMT_LABEL || stmt->u.label != atom) {
    1:                 if (STMT_IS_LOOP(stmt))
    1:                     loop = stmt;
    1:                 stmt = stmt->down;
    1:             }
    1:             stmt = loop;
    1:             noteType = SRC_CONT2LABEL;
    1:         } else {
    1:             ale = NULL;
    1:             while (!STMT_IS_LOOP(stmt))
    1:                 stmt = stmt->down;
    1:             noteType = SRC_CONTINUE;
    1:         }
    1: 
    1:         if (EmitGoto(cx, cg, stmt, &stmt->continues, ale, noteType) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case TOK_WITH:
    1:         if (!js_EmitTree(cx, cg, pn->pn_left))
    1:             return JS_FALSE;
    1:         js_PushStatement(&cg->treeContext, &stmtInfo, STMT_WITH, CG_OFFSET(cg));
    1:         if (js_Emit1(cx, cg, JSOP_ENTERWITH) < 0)
    1:             return JS_FALSE;
    1:         if (!js_EmitTree(cx, cg, pn->pn_right))
    1:             return JS_FALSE;
    1:         if (js_Emit1(cx, cg, JSOP_LEAVEWITH) < 0)
    1:             return JS_FALSE;
    1:         ok = js_PopStatementCG(cx, cg);
    1:         break;
    1: 
    1:       case TOK_TRY:
    1:       {
 1825:         ptrdiff_t tryStart, tryEnd, catchJump, finallyStart;
    1:         intN depth;
    1:         JSParseNode *lastCatch;
    1: 
 1825:         catchJump = -1;
    1: 
    1:         /*
    1:          * Push stmtInfo to track jumps-over-catches and gosubs-to-finally
    1:          * for later fixup.
    1:          *
    1:          * When a finally block is 'active' (STMT_FINALLY on the treeContext),
    1:          * non-local jumps (including jumps-over-catches) result in a GOSUB
    1:          * being written into the bytecode stream and fixed-up later (c.f.
    1:          * EmitBackPatchOp and BackPatch).
    1:          */
    1:         js_PushStatement(&cg->treeContext, &stmtInfo,
    1:                          pn->pn_kid3 ? STMT_FINALLY : STMT_TRY,
    1:                          CG_OFFSET(cg));
    1: 
    1:         /*
 1825:          * Since an exception can be thrown at any place inside the try block,
 1825:          * we need to restore the stack and the scope chain before we transfer
 1825:          * the control to the exception handler.
    1:          *
 1825:          * For that we store in a try note associated with the catch or
 1825:          * finally block the stack depth upon the try entry. The interpreter
 1825:          * uses this depth to properly unwind the stack and the scope chain.
    1:          */
    1:         depth = cg->stackDepth;
    1: 
    1:         /* Mark try location for decompilation, then emit try block. */
    1:         if (js_Emit1(cx, cg, JSOP_TRY) < 0)
    1:             return JS_FALSE;
 1825:         tryStart = CG_OFFSET(cg);
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid1))
    1:             return JS_FALSE;
18567:         JS_ASSERT(depth == cg->stackDepth);
    1: 
    1:         /* GOSUB to finally, if present. */
    1:         if (pn->pn_kid3) {
    1:             if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
    1:                 return JS_FALSE;
    1:             jmp = EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &GOSUBS(stmtInfo));
    1:             if (jmp < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         /* Emit (hidden) jump over catch and/or finally. */
    1:         if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
    1:             return JS_FALSE;
    1:         jmp = EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &catchJump);
    1:         if (jmp < 0)
    1:             return JS_FALSE;
    1: 
 1825:         tryEnd = CG_OFFSET(cg);
    1: 
    1:         /* If this try has a catch block, emit it. */
    1:         pn2 = pn->pn_kid2;
    1:         lastCatch = NULL;
    1:         if (pn2) {
    1:             jsint count = 0;    /* previous catch block's population */
    1: 
    1:             /*
    1:              * The emitted code for a catch block looks like:
    1:              *
    1:              * [throwing]                          only if 2nd+ catch block
    1:              * [leaveblock]                        only if 2nd+ catch block
    1:              * enterblock                          with SRC_CATCH
    1:              * exception
    1:              * [dup]                               only if catchguard
    1:              * setlocalpop <slot>                  or destructuring code
    1:              * [< catchguard code >]               if there's a catchguard
    1:              * [ifeq <offset to next catch block>]         " "
    1:              * [pop]                               only if catchguard
    1:              * < catch block contents >
    1:              * leaveblock
    1:              * goto <end of catch blocks>          non-local; finally applies
    1:              *
    1:              * If there's no catch block without a catchguard, the last
    1:              * <offset to next catch block> points to rethrow code.  This
    1:              * code will [gosub] to the finally code if appropriate, and is
    1:              * also used for the catch-all trynote for capturing exceptions
    1:              * thrown from catch{} blocks.
    1:              */
    1:             for (pn3 = pn2->pn_head; pn3; pn3 = pn3->pn_next) {
    1:                 ptrdiff_t guardJump, catchNote;
    1: 
 1825:                 JS_ASSERT(cg->stackDepth == depth);
    1:                 guardJump = GUARDJUMP(stmtInfo);
 1825:                 if (guardJump != -1) {
    1:                     /* Fix up and clean up previous catch block. */
    1:                     CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, guardJump);
    1: 
    1:                     /*
18567:                      * Account for JSOP_ENTERBLOCK (whose block object count
18567:                      * is saved below) and pushed exception object that we
18567:                      * still have after the jumping from the previous guard.
18567:                      */
18567:                     cg->stackDepth = depth + count + 1;
    1: 
    1:                     /*
    1:                      * Move exception back to cx->exception to prepare for
  190:                      * the next catch. We hide [throwing] from the decompiler
  190:                      * since it compensates for the hidden JSOP_DUP at the
  190:                      * start of the previous guarded catch.
  190:                      */
  190:                     if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0 ||
  190:                         js_Emit1(cx, cg, JSOP_THROWING) < 0) {
  190:                         return JS_FALSE;
  190:                     }
    1:                     if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
    1:                         return JS_FALSE;
    1:                     EMIT_UINT16_IMM_OP(JSOP_LEAVEBLOCK, count);
18567:                     JS_ASSERT(cg->stackDepth == depth);
    1:                 }
    1: 
    1:                 /*
    1:                  * Annotate the JSOP_ENTERBLOCK that's about to be generated
    1:                  * by the call to js_EmitTree immediately below.  Save this
    1:                  * source note's index in stmtInfo for use by the TOK_CATCH:
    1:                  * case, where the length of the catch guard is set as the
    1:                  * note's offset.
    1:                  */
    1:                 catchNote = js_NewSrcNote2(cx, cg, SRC_CATCH, 0);
    1:                 if (catchNote < 0)
    1:                     return JS_FALSE;
    1:                 CATCHNOTE(stmtInfo) = catchNote;
    1: 
    1:                 /*
    1:                  * Emit the lexical scope and catch body.  Save the catch's
    1:                  * block object population via count, for use when targeting
    1:                  * guardJump at the next catch (the guard mismatch case).
    1:                  */
    1:                 JS_ASSERT(pn3->pn_type == TOK_LEXICALSCOPE);
 3235:                 count = OBJ_BLOCK_COUNT(cx, pn3->pn_pob->object);
    1:                 if (!js_EmitTree(cx, cg, pn3))
    1:                     return JS_FALSE;
    1: 
    1:                 /* gosub <finally>, if required */
    1:                 if (pn->pn_kid3) {
    1:                     jmp = EmitBackPatchOp(cx, cg, JSOP_BACKPATCH,
    1:                                           &GOSUBS(stmtInfo));
    1:                     if (jmp < 0)
    1:                         return JS_FALSE;
    1:                     JS_ASSERT(cg->stackDepth == depth);
    1:                 }
    1: 
    1:                 /*
    1:                  * Jump over the remaining catch blocks.  This will get fixed
    1:                  * up to jump to after catch/finally.
    1:                  */
    1:                 if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
    1:                     return JS_FALSE;
    1:                 jmp = EmitBackPatchOp(cx, cg, JSOP_BACKPATCH, &catchJump);
    1:                 if (jmp < 0)
    1:                     return JS_FALSE;
    1: 
    1:                 /*
    1:                  * Save a pointer to the last catch node to handle try-finally
    1:                  * and try-catch(guard)-finally special cases.
    1:                  */
    1:                 lastCatch = pn3->pn_expr;
    1:             }
    1:         }
    1: 
    1:         /*
    1:          * Last catch guard jumps to the rethrow code sequence if none of the
    1:          * guards match. Target guardJump at the beginning of the rethrow
    1:          * sequence, just in case a guard expression throws and leaves the
    1:          * stack unbalanced.
    1:          */
    1:         if (lastCatch && lastCatch->pn_kid2) {
    1:             CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, GUARDJUMP(stmtInfo));
    1: 
    1:             /* Sync the stack to take into account pushed exception. */
    1:             JS_ASSERT(cg->stackDepth == depth);
    1:             cg->stackDepth = depth + 1;
    1: 
    1:             /*
    1:              * Rethrow the exception, delegating executing of finally if any
    1:              * to the exception handler.
    1:              */
    1:             if (js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0 ||
    1:                 js_Emit1(cx, cg, JSOP_THROW) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         JS_ASSERT(cg->stackDepth == depth);
    1: 
    1:         /* Emit finally handler if any. */
 1825:         finallyStart = 0;   /* to quell GCC uninitialized warnings */
    1:         if (pn->pn_kid3) {
    1:             /*
 1825:              * Fix up the gosubs that might have been emitted before non-local
 1825:              * jumps to the finally code.
 1825:              */
 1825:             if (!BackPatch(cx, cg, GOSUBS(stmtInfo), CG_NEXT(cg), JSOP_GOSUB))
 1825:                 return JS_FALSE;
 1825: 
 1825:             finallyStart = CG_OFFSET(cg);
 1825: 
18567:             /* Indicate that we're emitting a subroutine body. */
    1:             stmtInfo.type = STMT_SUBROUTINE;
    1:             if (!UpdateLineNumberNotes(cx, cg, pn->pn_kid3))
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_FINALLY) < 0 ||
    1:                 !js_EmitTree(cx, cg, pn->pn_kid3) ||
    1:                 js_Emit1(cx, cg, JSOP_RETSUB) < 0) {
    1:                 return JS_FALSE;
    1:             }
18567:             JS_ASSERT(cg->stackDepth == depth);
    1:         }
    1:         if (!js_PopStatementCG(cx, cg))
    1:             return JS_FALSE;
    1: 
    1:         if (js_NewSrcNote(cx, cg, SRC_ENDBRACE) < 0 ||
    1:             js_Emit1(cx, cg, JSOP_NOP) < 0) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /* Fix up the end-of-try/catch jumps to come here. */
    1:         if (!BackPatch(cx, cg, catchJump, CG_NEXT(cg), JSOP_GOTO))
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Add the try note last, to let post-order give us the right ordering
    1:          * (first to last for a given nesting level, inner to outer by level).
    1:          */
 1825:         if (pn->pn_kid2 &&
20420:             !NewTryNote(cx, cg, JSTRY_CATCH, depth, tryStart, tryEnd)) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * If we've got a finally, mark try+catch region with additional
    1:          * trynote to catch exceptions (re)thrown from a catch block or
    1:          * for the try{}finally{} case.
    1:          */
 1825:         if (pn->pn_kid3 &&
20420:             !NewTryNote(cx, cg, JSTRY_FINALLY, depth, tryStart, finallyStart)) {
    1:             return JS_FALSE;
    1:         }
    1:         break;
    1:       }
    1: 
    1:       case TOK_CATCH:
    1:       {
    1:         ptrdiff_t catchStart, guardJump;
 3235:         JSObject *blockObj;
    1: 
    1:         /*
    1:          * Morph STMT_BLOCK to STMT_CATCH, note the block entry code offset,
    1:          * and save the block object atom.
    1:          */
    1:         stmt = cg->treeContext.topStmt;
    1:         JS_ASSERT(stmt->type == STMT_BLOCK && (stmt->flags & SIF_SCOPE));
    1:         stmt->type = STMT_CATCH;
    1:         catchStart = stmt->update;
 3235:         blockObj = stmt->u.blockObj;
    1: 
    1:         /* Go up one statement info record to the TRY or FINALLY record. */
    1:         stmt = stmt->down;
    1:         JS_ASSERT(stmt->type == STMT_TRY || stmt->type == STMT_FINALLY);
    1: 
    1:         /* Pick up the pending exception and bind it to the catch variable. */
    1:         if (js_Emit1(cx, cg, JSOP_EXCEPTION) < 0)
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Dup the exception object if there is a guard for rethrowing to use
    1:          * it later when rethrowing or in other catches.
    1:          */
  990:         if (pn->pn_kid2 && js_Emit1(cx, cg, JSOP_DUP) < 0)
  990:             return JS_FALSE;
    1: 
    1:         pn2 = pn->pn_kid1;
    1:         switch (pn2->pn_type) {
    1: #if JS_HAS_DESTRUCTURING
    1:           case TOK_RB:
    1:           case TOK_RC:
    1:             if (!EmitDestructuringOps(cx, cg, JSOP_NOP, pn2))
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_POP) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
    1: 
    1:           case TOK_NAME:
16072:             /* Inline BindNameToSlot for pn2. */
16072:             JS_ASSERT(pn2->pn_slot == -1);
16072:             pn2->pn_slot = AdjustBlockSlot(cx, cg,
16072:                                            OBJ_BLOCK_DEPTH(cx, blockObj));
16072:             if (pn2->pn_slot < 0)
16072:                 return JS_FALSE;
    1:             EMIT_UINT16_IMM_OP(JSOP_SETLOCALPOP, pn2->pn_slot);
    1:             break;
    1: 
    1:           default:
    1:             JS_ASSERT(0);
    1:         }
    1: 
    1:         /* Emit the guard expression, if there is one. */
    1:         if (pn->pn_kid2) {
    1:             if (!js_EmitTree(cx, cg, pn->pn_kid2))
    1:                 return JS_FALSE;
    1:             if (!js_SetSrcNoteOffset(cx, cg, CATCHNOTE(*stmt), 0,
    1:                                      CG_OFFSET(cg) - catchStart)) {
    1:                 return JS_FALSE;
    1:             }
    1:             /* ifeq <next block> */
    1:             guardJump = EmitJump(cx, cg, JSOP_IFEQ, 0);
    1:             if (guardJump < 0)
    1:                 return JS_FALSE;
    1:             GUARDJUMP(*stmt) = guardJump;
    1: 
    1:             /* Pop duplicated exception object as we no longer need it. */
 1151:             if (js_Emit1(cx, cg, JSOP_POP) < 0)
 1151:                 return JS_FALSE;
    1:         }
    1: 
    1:         /* Emit the catch body. */
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid3))
    1:             return JS_FALSE;
    1: 
    1:         /*
    1:          * Annotate the JSOP_LEAVEBLOCK that will be emitted as we unwind via
    1:          * our TOK_LEXICALSCOPE parent, so the decompiler knows to pop.
    1:          */
    1:         off = cg->stackDepth;
    1:         if (js_NewSrcNote2(cx, cg, SRC_CATCH, off) < 0)
    1:             return JS_FALSE;
    1:         break;
    1:       }
    1: 
    1:       case TOK_VAR:
    1:         if (!EmitVariables(cx, cg, pn, JS_FALSE, &noteIndex))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case TOK_RETURN:
    1:         /* Push a return value */
    1:         pn2 = pn->pn_kid;
    1:         if (pn2) {
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:         } else {
    1:             if (js_Emit1(cx, cg, JSOP_PUSH) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         /*
11758:          * EmitNonLocalJumpFixup may add fixup bytecode to close open try
11758:          * blocks having finally clauses and to exit intermingled let blocks.
    1:          * We can't simply transfer control flow to our caller in that case,
11758:          * because we must gosub to those finally clauses from inner to outer,
11758:          * with the correct stack pointer (i.e., after popping any with,
11758:          * for/in, etc., slots nested inside the finally's try).
11758:          *
11758:          * In this case we mutate JSOP_RETURN into JSOP_SETRVAL and add an
11758:          * extra JSOP_RETRVAL after the fixups.
11758:          */
11758:         top = CG_OFFSET(cg);
11758:         if (js_Emit1(cx, cg, JSOP_RETURN) < 0)
11758:             return JS_FALSE;
11758:         if (!EmitNonLocalJumpFixup(cx, cg, NULL))
11758:             return JS_FALSE;
11758:         if (top + JSOP_RETURN_LENGTH != CG_OFFSET(cg)) {
11758:             CG_BASE(cg)[top] = JSOP_SETRVAL;
11758:             if (js_Emit1(cx, cg, JSOP_RETRVAL) < 0)
11758:                 return JS_FALSE;
11758:         }
    1:         break;
    1: 
    1: #if JS_HAS_GENERATORS
    1:       case TOK_YIELD:
 1577:         if (!(cg->treeContext.flags & TCF_IN_FUNCTION)) {
 7984:             js_ReportCompileErrorNumber(cx, CG_TS(cg), pn, JSREPORT_ERROR,
 1577:                                         JSMSG_BAD_RETURN_OR_YIELD,
 1577:                                         js_yield_str);
 1577:             return JS_FALSE;
 1577:         }
    1:         if (pn->pn_kid) {
    1:             if (!js_EmitTree(cx, cg, pn->pn_kid))
    1:                 return JS_FALSE;
    1:         } else {
    1:             if (js_Emit1(cx, cg, JSOP_PUSH) < 0)
    1:                 return JS_FALSE;
    1:         }
 1577:         if (pn->pn_hidden && js_NewSrcNote(cx, cg, SRC_HIDDEN) < 0)
 1577:             return JS_FALSE;
    1:         if (js_Emit1(cx, cg, JSOP_YIELD) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: #endif
    1: 
    1:       case TOK_LC:
    1: #if JS_HAS_XML_SUPPORT
    1:         if (pn->pn_arity == PN_UNARY) {
    1:             if (!js_EmitTree(cx, cg, pn->pn_kid))
    1:                 return JS_FALSE;
 3164:             if (js_Emit1(cx, cg, PN_OP(pn)) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1:         }
    1: #endif
    1: 
    1:         JS_ASSERT(pn->pn_arity == PN_LIST);
    1: 
    1:         noteIndex = -1;
    1:         tmp = CG_OFFSET(cg);
    1:         if (pn->pn_extra & PNX_NEEDBRACES) {
    1:             noteIndex = js_NewSrcNote2(cx, cg, SRC_BRACE, 0);
    1:             if (noteIndex < 0 || js_Emit1(cx, cg, JSOP_NOP) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         js_PushStatement(&cg->treeContext, &stmtInfo, STMT_BLOCK, top);
10466:         if (pn->pn_extra & PNX_FUNCDEFS) {
10466:             /*
10466:              * This block contains top-level function definitions. To ensure
10466:              * that we emit the bytecode defining them prior the rest of code
10466:              * in the block we use a separate pass over functions. During the
10466:              * main pass later the emitter will add JSOP_NOP with source notes
10466:              * for the function to preserve the original functions position
10466:              * when decompiling.
10466:              *
10466:              * Currently this is used only for functions, as compile-as-we go
10466:              * mode for scripts does not allow separate emitter passes.
10466:              */
10466:             JS_ASSERT(cg->treeContext.flags & TCF_IN_FUNCTION);
10466:             for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
10466:                 if (pn2->pn_type == TOK_FUNCTION) {
14332:                     if (pn2->pn_op == JSOP_NOP) {
10466:                         if (!js_EmitTree(cx, cg, pn2))
10466:                             return JS_FALSE;
14332:                     } else {
14332:                         /*
18965:                          * JSOP_DEFFUN in a top-level block with function
14332:                          * definitions appears, for example, when "if (true)"
14332:                          * is optimized away from "if (true) function x() {}".
14332:                          * See bug 428424.
14332:                          */
18965:                         JS_ASSERT(pn2->pn_op == JSOP_DEFFUN);
14332:                     }
10466:                 }
10466:             }
10466:         }
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         if (noteIndex >= 0 &&
    1:             !js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0,
    1:                                  CG_OFFSET(cg) - tmp)) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         ok = js_PopStatementCG(cx, cg);
    1:         break;
    1: 
20413:       case TOK_SEQ:
    1:         JS_ASSERT(pn->pn_arity == PN_LIST);
20413:         js_PushStatement(&cg->treeContext, &stmtInfo, STMT_SEQ, top);
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:         }
    1:         ok = js_PopStatementCG(cx, cg);
    1:         break;
    1: 
    1:       case TOK_SEMI:
    1:         pn2 = pn->pn_kid;
    1:         if (pn2) {
    1:             /*
    1:              * Top-level or called-from-a-native JS_Execute/EvaluateScript,
    1:              * debugger, and eval frames may need the value of the ultimate
    1:              * expression statement as the script's result, despite the fact
    1:              * that it appears useless to the compiler.
17828:              *
17828:              * API users may also set the JSOPTION_NO_SCRIPT_RVAL option when
17838:              * calling JS_Compile* to suppress JSOP_POPV.
17828:              */
17828:             useful = wantval =
17828:                 !(cg->treeContext.flags & (TCF_IN_FUNCTION | TCF_NO_SCRIPT_RVAL));
    1:             if (!useful) {
 9604:                 if (!CheckSideEffects(cx, cg, pn2, &useful))
    1:                     return JS_FALSE;
    1:             }
    1: 
    1:             /*
    1:              * Don't eliminate apparently useless expressions if they are
    1:              * labeled expression statements.  The tc->topStmt->update test
    1:              * catches the case where we are nesting in js_EmitTree for a
    1:              * labeled compound statement.
    1:              */
    1:             if (!useful &&
    1:                 (!cg->treeContext.topStmt ||
    1:                  cg->treeContext.topStmt->type != STMT_LABEL ||
    1:                  cg->treeContext.topStmt->update < CG_OFFSET(cg))) {
    1:                 CG_CURRENT_LINE(cg) = pn2->pn_pos.begin.lineno;
 7984:                 if (!js_ReportCompileErrorNumber(cx, CG_TS(cg), pn2,
    1:                                                  JSREPORT_WARNING |
    1:                                                  JSREPORT_STRICT,
    1:                                                  JSMSG_USELESS_EXPR)) {
    1:                     return JS_FALSE;
    1:                 }
    1:             } else {
    1:                 op = wantval ? JSOP_POPV : JSOP_POP;
    1: #if JS_HAS_DESTRUCTURING
    1:                 if (!wantval &&
    1:                     pn2->pn_type == TOK_ASSIGN &&
    1:                     !MaybeEmitGroupAssignment(cx, cg, op, pn2, &op)) {
    1:                     return JS_FALSE;
    1:                 }
    1: #endif
    1:                 if (op != JSOP_NOP) {
    1:                     if (!js_EmitTree(cx, cg, pn2))
    1:                         return JS_FALSE;
    1:                     if (js_Emit1(cx, cg, op) < 0)
    1:                         return JS_FALSE;
    1:                 }
    1:             }
    1:         }
    1:         break;
    1: 
    1:       case TOK_COLON:
    1:         /* Emit an annotated nop so we know to decompile a label. */
    1:         atom = pn->pn_atom;
    1:         ale = js_IndexAtom(cx, atom, &cg->atomList);
    1:         if (!ale)
    1:             return JS_FALSE;
    1:         pn2 = pn->pn_expr;
    1:         noteType = (pn2->pn_type == TOK_LC ||
    1:                     (pn2->pn_type == TOK_LEXICALSCOPE &&
    1:                      pn2->pn_expr->pn_type == TOK_LC))
    1:                    ? SRC_LABELBRACE
    1:                    : SRC_LABEL;
    1:         noteIndex = js_NewSrcNote2(cx, cg, noteType,
    1:                                    (ptrdiff_t) ALE_INDEX(ale));
    1:         if (noteIndex < 0 ||
    1:             js_Emit1(cx, cg, JSOP_NOP) < 0) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /* Emit code for the labeled statement. */
    1:         js_PushStatement(&cg->treeContext, &stmtInfo, STMT_LABEL,
    1:                          CG_OFFSET(cg));
 3235:         stmtInfo.u.label = atom;
    1:         if (!js_EmitTree(cx, cg, pn2))
    1:             return JS_FALSE;
    1:         if (!js_PopStatementCG(cx, cg))
    1:             return JS_FALSE;
    1: 
    1:         /* If the statement was compound, emit a note for the end brace. */
    1:         if (noteType == SRC_LABELBRACE) {
    1:             if (js_NewSrcNote(cx, cg, SRC_ENDBRACE) < 0 ||
    1:                 js_Emit1(cx, cg, JSOP_NOP) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
    1:       case TOK_COMMA:
    1:         /*
    1:          * Emit SRC_PCDELTA notes on each JSOP_POP between comma operands.
    1:          * These notes help the decompiler bracket the bytecodes generated
    1:          * from each sub-expression that follows a comma.
    1:          */
    1:         off = noteIndex = -1;
    1:         for (pn2 = pn->pn_head; ; pn2 = pn2->pn_next) {
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:             tmp = CG_OFFSET(cg);
    1:             if (noteIndex >= 0) {
    1:                 if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, tmp-off))
    1:                     return JS_FALSE;
    1:             }
    1:             if (!pn2->pn_next)
    1:                 break;
    1:             off = tmp;
    1:             noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
    1:             if (noteIndex < 0 ||
    1:                 js_Emit1(cx, cg, JSOP_POP) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
    1:       case TOK_ASSIGN:
    1:         /*
    1:          * Check left operand type and generate specialized code for it.
    1:          * Specialize to avoid ECMA "reference type" values on the operand
    1:          * stack, which impose pervasive runtime "GetValue" costs.
    1:          */
    1:         pn2 = pn->pn_left;
    1:         JS_ASSERT(pn2->pn_type != TOK_RP);
    1:         atomIndex = (jsatomid) -1;              /* quell GCC overwarning */
    1:         switch (pn2->pn_type) {
    1:           case TOK_NAME:
16378:             if (!BindNameToSlot(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:             if (pn2->pn_slot >= 0) {
    1:                 atomIndex = (jsatomid) pn2->pn_slot;
    1:             } else {
    1:                 ale = js_IndexAtom(cx, pn2->pn_atom, &cg->atomList);
    1:                 if (!ale)
    1:                     return JS_FALSE;
    1:                 atomIndex = ALE_INDEX(ale);
 3235:                 EMIT_INDEX_OP(JSOP_BINDNAME, atomIndex);
    1:             }
    1:             break;
    1:           case TOK_DOT:
    1:             if (!js_EmitTree(cx, cg, pn2->pn_expr))
    1:                 return JS_FALSE;
    1:             ale = js_IndexAtom(cx, pn2->pn_atom, &cg->atomList);
    1:             if (!ale)
    1:                 return JS_FALSE;
    1:             atomIndex = ALE_INDEX(ale);
    1:             break;
    1:           case TOK_LB:
    1:             JS_ASSERT(pn2->pn_arity == PN_BINARY);
    1:             if (!js_EmitTree(cx, cg, pn2->pn_left))
    1:                 return JS_FALSE;
    1:             if (!js_EmitTree(cx, cg, pn2->pn_right))
    1:                 return JS_FALSE;
    1:             break;
    1: #if JS_HAS_DESTRUCTURING
    1:           case TOK_RB:
    1:           case TOK_RC:
    1:             break;
    1: #endif
    1: #if JS_HAS_LVALUE_RETURN
    1:           case TOK_LP:
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:           case TOK_UNARYOP:
    1:             JS_ASSERT(pn2->pn_op == JSOP_SETXMLNAME);
    1:             if (!js_EmitTree(cx, cg, pn2->pn_kid))
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_BINDXMLNAME) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
    1:           default:
    1:             JS_ASSERT(0);
    1:         }
    1: 
 3164:         op = PN_OP(pn);
    1: #if JS_HAS_GETTER_SETTER
    1:         if (op == JSOP_GETTER || op == JSOP_SETTER) {
13502:             if (pn2->pn_type == TOK_NAME && PN_OP(pn2) != JSOP_SETNAME) {
13502:                 /*
13502:                  * x getter = y where x is a local or let variable is not
13502:                  * supported.
13502:                  */
13502:                 js_ReportCompileErrorNumber(cx,
13502:                                             TS(cg->treeContext.parseContext),
13502:                                             pn2, JSREPORT_ERROR,
13502:                                             JSMSG_BAD_GETTER_OR_SETTER,
13502:                                             (op == JSOP_GETTER)
13502:                                             ? js_getter_str
13502:                                             : js_setter_str);
13502:                 return JS_FALSE;
13502:             }
13502: 
    1:             /* We'll emit these prefix bytecodes after emitting the r.h.s. */
    1:         } else
    1: #endif
    1:         /* If += or similar, dup the left operand and get its value. */
    1:         if (op != JSOP_NOP) {
    1:             switch (pn2->pn_type) {
    1:               case TOK_NAME:
    1:                 if (pn2->pn_op != JSOP_SETNAME) {
    1:                     EMIT_UINT16_IMM_OP((pn2->pn_op == JSOP_SETGVAR)
    1:                                        ? JSOP_GETGVAR
    1:                                        : (pn2->pn_op == JSOP_SETARG)
    1:                                        ? JSOP_GETARG
16429:                                        : JSOP_GETLOCAL,
    1:                                        atomIndex);
    1:                     break;
    1:                 }
11377:                 if (js_Emit1(cx, cg, JSOP_DUP) < 0)
11377:                     return JS_FALSE;
11377:                 EMIT_INDEX_OP(JSOP_GETXPROP, atomIndex);
11377:                 break;
    1:               case TOK_DOT:
    1:                 if (js_Emit1(cx, cg, JSOP_DUP) < 0)
    1:                     return JS_FALSE;
11377:                 if (pn2->pn_atom == cx->runtime->atomState.lengthAtom) {
11377:                     if (js_Emit1(cx, cg, JSOP_LENGTH) < 0)
11377:                         return JS_FALSE;
11377:                 } else {
11377:                     EMIT_INDEX_OP(JSOP_GETPROP, atomIndex);
11377:                 }
    1:                 break;
    1:               case TOK_LB:
    1: #if JS_HAS_LVALUE_RETURN
    1:               case TOK_LP:
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:               case TOK_UNARYOP:
    1: #endif
    1:                 if (js_Emit1(cx, cg, JSOP_DUP2) < 0)
    1:                     return JS_FALSE;
    1:                 if (js_Emit1(cx, cg, JSOP_GETELEM) < 0)
    1:                     return JS_FALSE;
    1:                 break;
    1:               default:;
    1:             }
    1:         }
    1: 
    1:         /* Now emit the right operand (it may affect the namespace). */
    1:         if (!js_EmitTree(cx, cg, pn->pn_right))
    1:             return JS_FALSE;
    1: 
    1:         /* If += etc., emit the binary operator with a decompiler note. */
    1:         if (op != JSOP_NOP) {
    1:             /*
    1:              * Take care to avoid SRC_ASSIGNOP if the left-hand side is a
    1:              * const declared in a function (i.e., with non-negative pn_slot
 8179:              * and when pn_const is true), as in this case (just a bit further
 8179:              * below) we will avoid emitting the assignment op.
    1:              */
    1:             if (pn2->pn_type != TOK_NAME ||
    1:                 pn2->pn_slot < 0 ||
 8179:                 !pn2->pn_const) {
    1:                 if (js_NewSrcNote(cx, cg, SRC_ASSIGNOP) < 0)
    1:                     return JS_FALSE;
    1:             }
    1:             if (js_Emit1(cx, cg, op) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         /* Left parts such as a.b.c and a[b].c need a decompiler note. */
    1:         if (pn2->pn_type != TOK_NAME &&
    1: #if JS_HAS_DESTRUCTURING
    1:             pn2->pn_type != TOK_RB &&
    1:             pn2->pn_type != TOK_RC &&
    1: #endif
    1:             js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0) {
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /* Finally, emit the specialized assignment bytecode. */
    1:         switch (pn2->pn_type) {
    1:           case TOK_NAME:
    1:             if (pn2->pn_slot >= 0) {
13502:                 if (!pn2->pn_const)
 3383:                     EMIT_UINT16_IMM_OP(PN_OP(pn2), atomIndex);
13502:                 break;
13502:             }
13675:             /* FALL THROUGH */
    1:           case TOK_DOT:
 3383:             EMIT_INDEX_OP(PN_OP(pn2), atomIndex);
    1:             break;
    1:           case TOK_LB:
    1: #if JS_HAS_LVALUE_RETURN
    1:           case TOK_LP:
    1: #endif
    1:             if (js_Emit1(cx, cg, JSOP_SETELEM) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: #if JS_HAS_DESTRUCTURING
    1:           case TOK_RB:
    1:           case TOK_RC:
    1:             if (!EmitDestructuringOps(cx, cg, JSOP_SETNAME, pn2))
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:           case TOK_UNARYOP:
    1:             if (js_Emit1(cx, cg, JSOP_SETXMLNAME) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
    1:           default:
    1:             JS_ASSERT(0);
    1:         }
    1:         break;
    1: 
    1:       case TOK_HOOK:
    1:         /* Emit the condition, then branch if false to the else part. */
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid1))
    1:             return JS_FALSE;
    1:         noteIndex = js_NewSrcNote(cx, cg, SRC_COND);
    1:         if (noteIndex < 0)
    1:             return JS_FALSE;
    1:         beq = EmitJump(cx, cg, JSOP_IFEQ, 0);
    1:         if (beq < 0 || !js_EmitTree(cx, cg, pn->pn_kid2))
    1:             return JS_FALSE;
    1: 
    1:         /* Jump around else, fixup the branch, emit else, fixup jump. */
    1:         jmp = EmitJump(cx, cg, JSOP_GOTO, 0);
    1:         if (jmp < 0)
    1:             return JS_FALSE;
    1:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, beq);
    1: 
    1:         /*
    1:          * Because each branch pushes a single value, but our stack budgeting
    1:          * analysis ignores branches, we now have to adjust cg->stackDepth to
    1:          * ignore the value pushed by the first branch.  Execution will follow
    1:          * only one path, so we must decrement cg->stackDepth.
    1:          *
    1:          * Failing to do this will foil code, such as the try/catch/finally
    1:          * exception handling code generator, that samples cg->stackDepth for
    1:          * use at runtime (JSOP_SETSP), or in let expression and block code
    1:          * generation, which must use the stack depth to compute local stack
    1:          * indexes correctly.
    1:          */
    1:         JS_ASSERT(cg->stackDepth > 0);
    1:         cg->stackDepth--;
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid3))
    1:             return JS_FALSE;
    1:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, jmp);
    1:         if (!js_SetSrcNoteOffset(cx, cg, noteIndex, 0, jmp - beq))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       case TOK_OR:
    1:       case TOK_AND:
    1:         /*
    1:          * JSOP_OR converts the operand on the stack to boolean, and if true,
    1:          * leaves the original operand value on the stack and jumps; otherwise
    1:          * it pops and falls into the next bytecode, which evaluates the right
    1:          * operand.  The jump goes around the right operand evaluation.
    1:          *
    1:          * JSOP_AND converts the operand on the stack to boolean, and if false,
    1:          * leaves the original operand value on the stack and jumps; otherwise
    1:          * it pops and falls into the right operand's bytecode.
 6116:          */
 6116:         if (pn->pn_arity == PN_BINARY) {
    1:             if (!js_EmitTree(cx, cg, pn->pn_left))
    1:                 return JS_FALSE;
    1:             top = EmitJump(cx, cg, JSOP_BACKPATCH_POP, 0);
    1:             if (top < 0)
    1:                 return JS_FALSE;
 6116:             if (!js_EmitTree(cx, cg, pn->pn_right))
 6116:                 return JS_FALSE;
 6116:             off = CG_OFFSET(cg);
 6116:             pc = CG_CODE(cg, top);
 6116:             CHECK_AND_SET_JUMP_OFFSET(cx, cg, pc, off - top);
 6116:             *pc = pn->pn_op;
 6116:         } else {
 6116:             JS_ASSERT(pn->pn_arity == PN_LIST);
 6116:             JS_ASSERT(pn->pn_head->pn_next->pn_next);
 6116: 
 6116:             /* Left-associative operator chain: avoid too much recursion. */
 6116:             pn2 = pn->pn_head;
 6116:             if (!js_EmitTree(cx, cg, pn2))
 6116:                 return JS_FALSE;
 6116:             top = EmitJump(cx, cg, JSOP_BACKPATCH_POP, 0);
 6116:             if (top < 0)
 6116:                 return JS_FALSE;
 6116: 
 6116:             /* Emit nodes between the head and the tail. */
    1:             jmp = top;
 6116:             while ((pn2 = pn2->pn_next)->pn_next) {
 6116:                 if (!js_EmitTree(cx, cg, pn2))
    1:                     return JS_FALSE;
    1:                 off = EmitJump(cx, cg, JSOP_BACKPATCH_POP, 0);
    1:                 if (off < 0)
    1:                     return JS_FALSE;
    1:                 if (!SetBackPatchDelta(cx, cg, CG_CODE(cg, jmp), off - jmp))
    1:                     return JS_FALSE;
    1:                 jmp = off;
 6116: 
    1:             }
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
 6116: 
 6116:             pn2 = pn->pn_head;
    1:             off = CG_OFFSET(cg);
    1:             do {
    1:                 pc = CG_CODE(cg, top);
    1:                 tmp = GetJumpOffset(cg, pc);
    1:                 CHECK_AND_SET_JUMP_OFFSET(cx, cg, pc, off - top);
 6116:                 *pc = pn->pn_op;
    1:                 top += tmp;
 6116:             } while ((pn2 = pn2->pn_next)->pn_next);
 6116:         }
    1:         break;
    1: 
    1:       case TOK_BITOR:
    1:       case TOK_BITXOR:
    1:       case TOK_BITAND:
    1:       case TOK_EQOP:
    1:       case TOK_RELOP:
    1:       case TOK_IN:
    1:       case TOK_INSTANCEOF:
    1:       case TOK_SHOP:
    1:       case TOK_PLUS:
    1:       case TOK_MINUS:
    1:       case TOK_STAR:
    1:       case TOK_DIVOP:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             /* Left-associative operator chain: avoid too much recursion. */
    1:             pn2 = pn->pn_head;
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
 3164:             op = PN_OP(pn);
    1:             while ((pn2 = pn2->pn_next) != NULL) {
    1:                 if (!js_EmitTree(cx, cg, pn2))
    1:                     return JS_FALSE;
    1:                 if (js_Emit1(cx, cg, op) < 0)
    1:                     return JS_FALSE;
    1:             }
    1:         } else {
    1: #if JS_HAS_XML_SUPPORT
    1:             uintN oldflags;
    1: 
    1:       case TOK_DBLCOLON:
    1:             if (pn->pn_arity == PN_NAME) {
    1:                 if (!js_EmitTree(cx, cg, pn->pn_expr))
    1:                     return JS_FALSE;
 3164:                 if (!EmitAtomOp(cx, pn, PN_OP(pn), cg))
    1:                     return JS_FALSE;
    1:                 break;
    1:             }
    1: 
    1:             /*
    1:              * Binary :: has a right operand that brackets arbitrary code,
    1:              * possibly including a let (a = b) ... expression.  We must clear
    1:              * TCF_IN_FOR_INIT to avoid mis-compiling such beasts.
    1:              */
    1:             oldflags = cg->treeContext.flags;
    1:             cg->treeContext.flags &= ~TCF_IN_FOR_INIT;
    1: #endif
    1: 
    1:             /* Binary operators that evaluate both operands unconditionally. */
    1:             if (!js_EmitTree(cx, cg, pn->pn_left))
    1:                 return JS_FALSE;
    1:             if (!js_EmitTree(cx, cg, pn->pn_right))
    1:                 return JS_FALSE;
    1: #if JS_HAS_XML_SUPPORT
    1:             cg->treeContext.flags |= oldflags & TCF_IN_FOR_INIT;
    1: #endif
 3164:             if (js_Emit1(cx, cg, PN_OP(pn)) < 0)
    1:                 return JS_FALSE;
    1:         }
    1:         break;
    1: 
    1:       case TOK_THROW:
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_AT:
    1:       case TOK_DEFAULT:
    1:         JS_ASSERT(pn->pn_arity == PN_UNARY);
    1:         /* FALL THROUGH */
    1: #endif
    1:       case TOK_UNARYOP:
    1:       {
    1:         uintN oldflags;
    1: 
    1:         /* Unary op, including unary +/-. */
 3164:         op = PN_OP(pn);
    1: #if JS_HAS_XML_SUPPORT
    1:         if (op == JSOP_XMLNAME) {
    1:             if (!EmitXMLName(cx, pn, op, cg))
    1:                 return JS_FALSE;
    1:             break;
    1:         }
    1: #endif
    1:         pn2 = pn->pn_kid;
    1:         if (op == JSOP_TYPEOF) {
    1:             for (pn3 = pn2; pn3->pn_type == TOK_RP; pn3 = pn3->pn_kid)
    1:                 continue;
    1:             if (pn3->pn_type != TOK_NAME)
    1:                 op = JSOP_TYPEOFEXPR;
    1:         }
    1:         oldflags = cg->treeContext.flags;
    1:         cg->treeContext.flags &= ~TCF_IN_FOR_INIT;
    1:         if (!js_EmitTree(cx, cg, pn2))
    1:             return JS_FALSE;
    1:         cg->treeContext.flags |= oldflags & TCF_IN_FOR_INIT;
    1:         if (js_Emit1(cx, cg, op) < 0)
    1:             return JS_FALSE;
    1:         break;
    1:       }
    1: 
    1:       case TOK_INC:
    1:       case TOK_DEC:
    1:         /* Emit lvalue-specialized code for ++/-- operators. */
    1:         pn2 = pn->pn_kid;
    1:         JS_ASSERT(pn2->pn_type != TOK_RP);
 3164:         op = PN_OP(pn);
    1:         switch (pn2->pn_type) {
12611:           default:
12611:             JS_ASSERT(pn2->pn_type == TOK_NAME);
    1:             pn2->pn_op = op;
16378:             if (!BindNameToSlot(cx, cg, pn2))
    1:                 return JS_FALSE;
 3164:             op = PN_OP(pn2);
    1:             if (pn2->pn_slot >= 0) {
 8179:                 if (pn2->pn_const) {
    1:                     /* Incrementing a declared const: just get its value. */
11377:                     op = (JOF_OPTYPE(op) == JOF_ATOM)
    1:                          ? JSOP_GETGVAR
16429:                          : JSOP_GETLOCAL;
    1:                 }
    1:                 atomIndex = (jsatomid) pn2->pn_slot;
    1:                 EMIT_UINT16_IMM_OP(op, atomIndex);
    1:             } else {
    1:                 if (!EmitAtomOp(cx, pn2, op, cg))
    1:                     return JS_FALSE;
    1:             }
    1:             break;
    1:           case TOK_DOT:
    1:             if (!EmitPropOp(cx, pn2, op, cg, JS_FALSE))
    1:                 return JS_FALSE;
    1:             break;
    1:           case TOK_LB:
    1:             if (!EmitElemOp(cx, pn2, op, cg))
    1:                 return JS_FALSE;
    1:             break;
    1: #if JS_HAS_LVALUE_RETURN
    1:           case TOK_LP:
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:             if (js_NewSrcNote2(cx, cg, SRC_PCBASE,
    1:                                CG_OFFSET(cg) - pn2->pn_offset) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (js_Emit1(cx, cg, op) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
    1: #if JS_HAS_XML_SUPPORT
    1:           case TOK_UNARYOP:
    1:             JS_ASSERT(pn2->pn_op == JSOP_SETXMLNAME);
    1:             if (!js_EmitTree(cx, cg, pn2->pn_kid))
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_BINDXMLNAME) < 0)
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, op) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
12611:         }
    1:         break;
    1: 
    1:       case TOK_DELETE:
    1:         /*
    1:          * Under ECMA 3, deleting a non-reference returns true -- but alas we
    1:          * must evaluate the operand if it appears it might have side effects.
    1:          */
    1:         pn2 = pn->pn_kid;
    1:         switch (pn2->pn_type) {
    1:           case TOK_NAME:
    1:             pn2->pn_op = JSOP_DELNAME;
16378:             if (!BindNameToSlot(cx, cg, pn2))
    1:                 return JS_FALSE;
 3164:             op = PN_OP(pn2);
    1:             if (op == JSOP_FALSE) {
    1:                 if (js_Emit1(cx, cg, op) < 0)
    1:                     return JS_FALSE;
    1:             } else {
    1:                 if (!EmitAtomOp(cx, pn2, op, cg))
    1:                     return JS_FALSE;
    1:             }
    1:             break;
    1:           case TOK_DOT:
    1:             if (!EmitPropOp(cx, pn2, JSOP_DELPROP, cg, JS_FALSE))
    1:                 return JS_FALSE;
    1:             break;
    1: #if JS_HAS_XML_SUPPORT
    1:           case TOK_DBLDOT:
    1:             if (!EmitElemOp(cx, pn2, JSOP_DELDESC, cg))
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
    1: #if JS_HAS_LVALUE_RETURN
    1:           case TOK_LP:
    1:             top = CG_OFFSET(cg);
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:             if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
    1:                 return JS_FALSE;
    1:             if (js_Emit1(cx, cg, JSOP_DELELEM) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1: #endif
    1:           case TOK_LB:
    1:             if (!EmitElemOp(cx, pn2, JSOP_DELELEM, cg))
    1:                 return JS_FALSE;
    1:             break;
    1:           default:
    1:             /*
    1:              * If useless, just emit JSOP_TRUE; otherwise convert delete foo()
20928:              * to foo(), true (a comma expression, requiring SRC_PCDELTA).
    1:              */
    1:             useful = JS_FALSE;
 9604:             if (!CheckSideEffects(cx, cg, pn2, &useful))
    1:                 return JS_FALSE;
    1:             if (!useful) {
    1:                 off = noteIndex = -1;
    1:             } else {
    1:                 if (!js_EmitTree(cx, cg, pn2))
    1:                     return JS_FALSE;
    1:                 off = CG_OFFSET(cg);
    1:                 noteIndex = js_NewSrcNote2(cx, cg, SRC_PCDELTA, 0);
    1:                 if (noteIndex < 0 || js_Emit1(cx, cg, JSOP_POP) < 0)
    1:                     return JS_FALSE;
    1:             }
    1:             if (js_Emit1(cx, cg, JSOP_TRUE) < 0)
    1:                 return JS_FALSE;
    1:             if (noteIndex >= 0) {
    1:                 tmp = CG_OFFSET(cg);
    1:                 if (!js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0, tmp-off))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_FILTER:
    1:         if (!js_EmitTree(cx, cg, pn->pn_left))
    1:             return JS_FALSE;
    1:         jmp = js_Emit3(cx, cg, JSOP_FILTER, 0, 0);
    1:         if (jmp < 0)
    1:             return JS_FALSE;
11672:         top = CG_OFFSET(cg);
    1:         if (!js_EmitTree(cx, cg, pn->pn_right))
    1:             return JS_FALSE;
    1:         CHECK_AND_SET_JUMP_OFFSET_AT(cx, cg, jmp);
11672:         if (EmitJump(cx, cg, JSOP_ENDFILTER, top - CG_OFFSET(cg)) < 0)
11672:             return JS_FALSE;
    1:         break;
    1: #endif
    1: 
    1:       case TOK_DOT:
    1:         /*
    1:          * Pop a stack operand, convert it to object, get a property named by
    1:          * this bytecode's immediate-indexed atom operand, and push its value
    1:          * (not a reference to it).
    1:          */
 3164:         ok = EmitPropOp(cx, pn, PN_OP(pn), cg, JS_FALSE);
    1:         break;
    1: 
    1:       case TOK_LB:
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_DBLDOT:
    1: #endif
    1:         /*
    1:          * Pop two operands, convert the left one to object and the right one
    1:          * to property name (atom or tagged int), get the named property, and
    1:          * push its value.  Set the "obj" register to the result of ToObject
    1:          * on the left operand.
    1:          */
 3164:         ok = EmitElemOp(cx, pn, PN_OP(pn), cg);
    1:         break;
    1: 
    1:       case TOK_NEW:
    1:       case TOK_LP:
    1:       {
    1:         uintN oldflags;
    1: 
    1:         /*
    1:          * Emit function call or operator new (constructor call) code.
    1:          * First, emit code for the left operand to evaluate the callable or
    1:          * constructable object expression.
    1:          */
    1:         pn2 = pn->pn_head;
    1:         switch (pn2->pn_type) {
    1:           case TOK_NAME:
    1:             if (!EmitNameOp(cx, cg, pn2, JS_TRUE))
    1:                 return JS_FALSE;
    1:             break;
    1:           case TOK_DOT:
 3164:             if (!EmitPropOp(cx, pn2, PN_OP(pn2), cg, JS_TRUE))
    1:                 return JS_FALSE;
    1:             break;
    1:           case TOK_LB:
    1:             JS_ASSERT(pn2->pn_op == JSOP_GETELEM);
    1:             if (!EmitElemOp(cx, pn2, JSOP_CALLELEM, cg))
    1:                 return JS_FALSE;
    1:             break;
    1:           case TOK_UNARYOP:
    1: #if JS_HAS_XML_SUPPORT
    1:             if (pn2->pn_op == JSOP_XMLNAME) {
    1:                 if (!EmitXMLName(cx, pn2, JSOP_CALLXMLNAME, cg))
    1:                     return JS_FALSE;
    1:                 break;
    1:             }
    1: #endif
    1:             /* FALL THROUGH */
    1:           default:
    1:             /*
11774:              * Push null as a placeholder for the global object, per ECMA-262
18031:              * 11.2.3 step 6. We use JSOP_NULLTHIS to distinguish this opcode
18031:              * from JSOP_NULL (see jstracer.cpp for one use-case).
18031:              */
18031:             if (!js_EmitTree(cx, cg, pn2))
18031:                 return JS_FALSE;
18031:             if (js_Emit1(cx, cg, JSOP_NULLTHIS) < 0)
11774:                 return JS_FALSE;
    1:         }
    1: 
    1:         /* Remember start of callable-object bytecode for decompilation hint. */
    1:         off = top;
    1: 
    1:         /*
    1:          * Emit code for each argument in order, then emit the JSOP_*CALL or
    1:          * JSOP_NEW bytecode with a two-byte immediate telling how many args
    1:          * were pushed on the operand stack.
    1:          */
    1:         oldflags = cg->treeContext.flags;
    1:         cg->treeContext.flags &= ~TCF_IN_FOR_INIT;
 4127:         for (pn3 = pn2->pn_next; pn3; pn3 = pn3->pn_next) {
 4127:             if (!js_EmitTree(cx, cg, pn3))
    1:                 return JS_FALSE;
    1:         }
    1:         cg->treeContext.flags |= oldflags & TCF_IN_FOR_INIT;
    1:         if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - off) < 0)
    1:             return JS_FALSE;
    1: 
    1:         argc = pn->pn_count - 1;
 3164:         if (js_Emit3(cx, cg, PN_OP(pn), ARGC_HI(argc), ARGC_LO(argc)) < 0)
    1:             return JS_FALSE;
20005:         if (PN_OP(pn) == JSOP_EVAL)
13504:             EMIT_UINT16_IMM_OP(JSOP_LINENO, pn->pn_pos.begin.lineno);
    1:         break;
    1:       }
    1: 
    1:       case TOK_LEXICALSCOPE:
    1:       {
18567:         JSParsedObjectBox *pob;
18567:         uintN count;
18567: 
18567:         pob = pn->pn_pob;
18567:         js_PushBlockScope(&cg->treeContext, &stmtInfo, pob->object,
18567:                           CG_OFFSET(cg));
    1: 
    1:         /*
    1:          * If this lexical scope is not for a catch block, let block or let
    1:          * expression, or any kind of for loop (where the scope starts in the
    1:          * head after the first part if for (;;), else in the body if for-in);
    1:          * and if our container is top-level but not a function body, or else
    1:          * a block statement; then emit a SRC_BRACE note.  All other container
    1:          * statements get braces by default from the decompiler.
    1:          */
    1:         noteIndex = -1;
 3164:         type = PN_TYPE(pn->pn_expr);
    1:         if (type != TOK_CATCH && type != TOK_LET && type != TOK_FOR &&
    1:             (!(stmt = stmtInfo.down)
    1:              ? !(cg->treeContext.flags & TCF_IN_FUNCTION)
    1:              : stmt->type == STMT_BLOCK)) {
10217: #if defined DEBUG_brendanXXX || defined DEBUG_mrbkap
    1:             /* There must be no source note already output for the next op. */
    1:             JS_ASSERT(CG_NOTE_COUNT(cg) == 0 ||
    1:                       CG_LAST_NOTE_OFFSET(cg) != CG_OFFSET(cg) ||
    1:                       !GettableNoteForNextOp(cg));
    1: #endif
    1:             noteIndex = js_NewSrcNote2(cx, cg, SRC_BRACE, 0);
    1:             if (noteIndex < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         JS_ASSERT(CG_OFFSET(cg) == top);
18567:         if (!EmitObjectOp(cx, pob, JSOP_ENTERBLOCK, cg))
 3235:             return JS_FALSE;
    1: 
    1:         if (!js_EmitTree(cx, cg, pn->pn_expr))
    1:             return JS_FALSE;
    1: 
 3164:         op = PN_OP(pn);
    1:         if (op == JSOP_LEAVEBLOCKEXPR) {
    1:             if (js_NewSrcNote2(cx, cg, SRC_PCBASE, CG_OFFSET(cg) - top) < 0)
    1:                 return JS_FALSE;
    1:         } else {
    1:             if (noteIndex >= 0 &&
    1:                 !js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0,
    1:                                      CG_OFFSET(cg) - top)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         /* Emit the JSOP_LEAVEBLOCK or JSOP_LEAVEBLOCKEXPR opcode. */
18567:         count = OBJ_BLOCK_COUNT(cx, pob->object);
    1:         EMIT_UINT16_IMM_OP(op, count);
    1: 
    1:         ok = js_PopStatementCG(cx, cg);
    1:         break;
    1:       }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:       case TOK_LET:
    1:         /* Let statements have their variable declarations on the left. */
    1:         if (pn->pn_arity == PN_BINARY) {
    1:             pn2 = pn->pn_right;
    1:             pn = pn->pn_left;
    1:         } else {
    1:             pn2 = NULL;
    1:         }
    1: 
    1:         /* Non-null pn2 means that pn is the variable list from a let head. */
    1:         JS_ASSERT(pn->pn_arity == PN_LIST);
    1:         if (!EmitVariables(cx, cg, pn, pn2 != NULL, &noteIndex))
    1:             return JS_FALSE;
    1: 
    1:         /* Thus non-null pn2 is the body of the let block or expression. */
    1:         tmp = CG_OFFSET(cg);
    1:         if (pn2 && !js_EmitTree(cx, cg, pn2))
    1:             return JS_FALSE;
    1: 
    1:         if (noteIndex >= 0 &&
    1:             !js_SetSrcNoteOffset(cx, cg, (uintN)noteIndex, 0,
    1:                                  CG_OFFSET(cg) - tmp)) {
    1:             return JS_FALSE;
    1:         }
    1:         break;
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
    1: #if JS_HAS_GENERATORS
16072:       case TOK_ARRAYPUSH: {
16072:         jsint slot;
16072: 
16072:         /*
16072:          * The array object's stack index is in cg->arrayCompDepth. See below
    1:          * under the array initialiser code generator for array comprehension
    1:          * special casing.
    1:          */
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid))
    1:             return JS_FALSE;
16072:         slot = cg->arrayCompDepth;
16072:         slot = AdjustBlockSlot(cx, cg, slot);
16072:         if (slot < 0)
16072:             return JS_FALSE;
16072:         EMIT_UINT16_IMM_OP(PN_OP(pn), slot);
16072:         break;
16072:       }
    1: #endif
    1: 
    1:       case TOK_RB:
    1: #if JS_HAS_GENERATORS
    1:       case TOK_ARRAYCOMP:
    1: #endif
    1:         /*
    1:          * Emit code for [a, b, c] of the form:
15279:          *
    1:          *   t = new Array; t[0] = a; t[1] = b; t[2] = c; t;
15279:          *
15279:          * but use a stack slot for t and avoid dup'ing and popping it using
    1:          * the JSOP_NEWINIT and JSOP_INITELEM bytecodes.
15279:          *
15279:          * If no sharp variable is defined and the initialiser is not for an
15279:          * array comprehension, use JSOP_NEWARRAY.
15279:          */
    1:         pn2 = pn->pn_head;
23708:         op = JSOP_NEWARRAY;
15279: 
15279: #if JS_HAS_SHARP_VARS
15279:         if (pn2 && pn2->pn_type == TOK_DEFSHARP)
15279:             op = JSOP_NEWINIT;
15279: #endif
15279: #if JS_HAS_GENERATORS
15279:         if (pn->pn_type == TOK_ARRAYCOMP)
15279:             op = JSOP_NEWINIT;
15279: #endif
15279: 
15279:         if (op == JSOP_NEWINIT &&
15279:             js_Emit2(cx, cg, op, (jsbytecode) JSProto_Array) < 0) {
15279:             return JS_FALSE;
15279:         }
15279: 
    1: #if JS_HAS_SHARP_VARS
    1:         if (pn2 && pn2->pn_type == TOK_DEFSHARP) {
    1:             EMIT_UINT16_IMM_OP(JSOP_DEFSHARP, (jsatomid)pn2->pn_num);
    1:             pn2 = pn2->pn_next;
    1:         }
    1: #endif
    1: 
    1: #if JS_HAS_GENERATORS
    1:         if (pn->pn_type == TOK_ARRAYCOMP) {
16072:             uintN saveDepth;
    1: 
    1:             /*
    1:              * Pass the new array's stack index to the TOK_ARRAYPUSH case by
    1:              * storing it in pn->pn_extra, then simply traverse the TOK_FOR
    1:              * node and its kids under pn2 to generate this comprehension.
    1:              */
    1:             JS_ASSERT(cg->stackDepth > 0);
16072:             saveDepth = cg->arrayCompDepth;
16072:             cg->arrayCompDepth = (uint32) (cg->stackDepth - 1);
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
16072:             cg->arrayCompDepth = saveDepth;
    1: 
    1:             /* Emit the usual op needed for decompilation. */
    1:             if (js_Emit1(cx, cg, JSOP_ENDINIT) < 0)
    1:                 return JS_FALSE;
    1:             break;
    1:         }
    1: #endif /* JS_HAS_GENERATORS */
    1: 
    1:         for (atomIndex = 0; pn2; atomIndex++, pn2 = pn2->pn_next) {
15279:             if (op == JSOP_NEWINIT && !EmitNumberOp(cx, atomIndex, cg))
15279:                 return JS_FALSE;
15279: 
    1:             if (pn2->pn_type == TOK_COMMA) {
15279:                 if (js_Emit1(cx, cg, JSOP_HOLE) < 0)
    1:                     return JS_FALSE;
    1:             } else {
    1:                 if (!js_EmitTree(cx, cg, pn2))
    1:                     return JS_FALSE;
    1:             }
    1: 
15279:             if (op == JSOP_NEWINIT && js_Emit1(cx, cg, JSOP_INITELEM) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         if (pn->pn_extra & PNX_ENDCOMMA) {
    1:             /* Emit a source note so we know to decompile an extra comma. */
    1:             if (js_NewSrcNote(cx, cg, SRC_CONTINUE) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
15279:         if (op == JSOP_NEWARRAY) {
15279:             JS_ASSERT(atomIndex == pn->pn_count);
15279:             off = js_EmitN(cx, cg, op, 3);
15279:             if (off < 0)
15279:                 return JS_FALSE;
15279:             pc = CG_CODE(cg, off);
15279:             SET_UINT24(pc, atomIndex);
15279:             UpdateDepth(cx, cg, off);
15279:         } else {
    1:             /* Emit an op for sharp array cleanup and decompilation. */
    1:             if (js_Emit1(cx, cg, JSOP_ENDINIT) < 0)
    1:                 return JS_FALSE;
15279:         }
    1:         break;
    1: 
    1:       case TOK_RC:
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:         if (pn->pn_extra & PNX_SHORTHAND) {
11039:             js_ReportCompileErrorNumber(cx, CG_TS(cg), pn, JSREPORT_ERROR,
11039:                                         JSMSG_BAD_OBJECT_INIT);
11039:             return JS_FALSE;
11039:         }
11039: #endif
    1:         /*
    1:          * Emit code for {p:a, '%q':b, 2:c} of the form:
15279:          *
    1:          *   t = new Object; t.p = a; t['%q'] = b; t[2] = c; t;
15279:          *
    1:          * but use a stack slot for t and avoid dup'ing and popping it via
15279:          * the JSOP_NEWINIT and JSOP_INITELEM/JSOP_INITPROP bytecodes.
    1:          */
 8633:         if (js_Emit2(cx, cg, JSOP_NEWINIT, (jsbytecode) JSProto_Object) < 0)
    1:             return JS_FALSE;
    1: 
    1:         pn2 = pn->pn_head;
    1: #if JS_HAS_SHARP_VARS
    1:         if (pn2 && pn2->pn_type == TOK_DEFSHARP) {
    1:             EMIT_UINT16_IMM_OP(JSOP_DEFSHARP, (jsatomid)pn2->pn_num);
    1:             pn2 = pn2->pn_next;
    1:         }
    1: #endif
    1: 
    1:         for (; pn2; pn2 = pn2->pn_next) {
    1:             /* Emit an index for t[2], else map an atom for t.p or t['%q']. */
    1:             pn3 = pn2->pn_left;
 8790:             if (pn3->pn_type == TOK_NUMBER) {
 8790: #ifdef __GNUC__
 8790:                 ale = NULL;     /* quell GCC overwarning */
 8790: #endif
    1:                 if (!EmitNumberOp(cx, pn3->pn_dval, cg))
    1:                     return JS_FALSE;
 8790:             } else {
 8790:                 JS_ASSERT(pn3->pn_type == TOK_NAME ||
 8790:                           pn3->pn_type == TOK_STRING);
    1:                 ale = js_IndexAtom(cx, pn3->pn_atom, &cg->atomList);
    1:                 if (!ale)
    1:                     return JS_FALSE;
    1:             }
    1: 
    1:             /* Emit code for the property initializer. */
    1:             if (!js_EmitTree(cx, cg, pn2->pn_right))
    1:                 return JS_FALSE;
    1: 
    1: #if JS_HAS_GETTER_SETTER
 3164:             op = PN_OP(pn2);
    1:             if (op == JSOP_GETTER || op == JSOP_SETTER) {
    1:                 if (js_Emit1(cx, cg, op) < 0)
    1:                     return JS_FALSE;
    1:             }
    1: #endif
    1:             /* Annotate JSOP_INITELEM so we decompile 2:c and not just c. */
    1:             if (pn3->pn_type == TOK_NUMBER) {
    1:                 if (js_NewSrcNote(cx, cg, SRC_INITPROP) < 0)
    1:                     return JS_FALSE;
    1:                 if (js_Emit1(cx, cg, JSOP_INITELEM) < 0)
    1:                     return JS_FALSE;
    1:             } else {
 3235:                 EMIT_INDEX_OP(JSOP_INITPROP, ALE_INDEX(ale));
    1:             }
    1:         }
    1: 
    1:         /* Emit an op for sharpArray cleanup and decompilation. */
    1:         if (js_Emit1(cx, cg, JSOP_ENDINIT) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: 
    1: #if JS_HAS_SHARP_VARS
    1:       case TOK_DEFSHARP:
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid))
    1:             return JS_FALSE;
    1:         EMIT_UINT16_IMM_OP(JSOP_DEFSHARP, (jsatomid) pn->pn_num);
    1:         break;
    1: 
    1:       case TOK_USESHARP:
    1:         EMIT_UINT16_IMM_OP(JSOP_USESHARP, (jsatomid) pn->pn_num);
    1:         break;
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1:       case TOK_RP:
    1:       {
    1:         uintN oldflags;
    1: 
    1:         /*
    1:          * The node for (e) has e as its kid, enabling users who want to nest
    1:          * assignment expressions in conditions to avoid the error correction
    1:          * done by Condition (from x = y to x == y) by double-parenthesizing.
    1:          */
    1:         oldflags = cg->treeContext.flags;
    1:         cg->treeContext.flags &= ~TCF_IN_FOR_INIT;
    1:         if (!js_EmitTree(cx, cg, pn->pn_kid))
    1:             return JS_FALSE;
    1:         cg->treeContext.flags |= oldflags & TCF_IN_FOR_INIT;
    1:         break;
    1:       }
    1: 
    1:       case TOK_NAME:
    1:         if (!EmitNameOp(cx, cg, pn, JS_FALSE))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLATTR:
    1:       case TOK_XMLSPACE:
    1:       case TOK_XMLTEXT:
    1:       case TOK_XMLCDATA:
    1:       case TOK_XMLCOMMENT:
    1: #endif
    1:       case TOK_STRING:
 3164:         ok = EmitAtomOp(cx, pn, PN_OP(pn), cg);
    1:         break;
    1: 
    1:       case TOK_NUMBER:
    1:         ok = EmitNumberOp(cx, pn->pn_dval, cg);
    1:         break;
    1: 
 6561:       case TOK_REGEXP:
 6561:         /*
 6561:          * If the regexp's script is one-shot, we can avoid the extra
 6561:          * fork-on-exec costs of JSOP_REGEXP by selecting JSOP_OBJECT.
 6561:          * Otherwise, to avoid incorrect proto, parent, and lastIndex
 6561:          * sharing among threads and sequentially across re-execution,
 6561:          * select JSOP_REGEXP.
 6561:          */
 6561:         JS_ASSERT(pn->pn_op == JSOP_REGEXP);
 8444:         if (cg->treeContext.flags & TCF_COMPILE_N_GO) {
 6561:             ok = EmitObjectOp(cx, pn->pn_pob, JSOP_OBJECT, cg);
 6561:         } else {
 6561:             ok = EmitIndexOp(cx, JSOP_REGEXP,
 3235:                              IndexParsedObject(pn->pn_pob, &cg->regexpList),
 3235:                              cg);
 3235:         }
 3235:         break;
 3235: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_ANYNAME:
    1: #endif
    1:       case TOK_PRIMARY:
 3164:         if (js_Emit1(cx, cg, PN_OP(pn)) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: 
    1: #if JS_HAS_DEBUGGER_KEYWORD
    1:       case TOK_DEBUGGER:
    1:         if (js_Emit1(cx, cg, JSOP_DEBUGGER) < 0)
    1:             return JS_FALSE;
    1:         break;
    1: #endif /* JS_HAS_DEBUGGER_KEYWORD */
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLELEM:
    1:       case TOK_XMLLIST:
    1:         if (pn->pn_op == JSOP_XMLOBJECT) {
 3235:             ok = EmitObjectOp(cx, pn->pn_pob, PN_OP(pn), cg);
    1:             break;
    1:         }
    1: 
    1:         JS_ASSERT(pn->pn_type == TOK_XMLLIST || pn->pn_count != 0);
    1:         switch (pn->pn_head ? pn->pn_head->pn_type : TOK_XMLLIST) {
    1:           case TOK_XMLETAGO:
    1:             JS_ASSERT(0);
    1:             /* FALL THROUGH */
    1:           case TOK_XMLPTAGC:
    1:           case TOK_XMLSTAGO:
    1:             break;
    1:           default:
    1:             if (js_Emit1(cx, cg, JSOP_STARTXML) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             if (pn2->pn_type == TOK_LC &&
    1:                 js_Emit1(cx, cg, JSOP_STARTXMLEXPR) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:             if (pn2 != pn->pn_head && js_Emit1(cx, cg, JSOP_ADD) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: 
    1:         if (pn->pn_extra & PNX_XMLROOT) {
    1:             if (pn->pn_count == 0) {
    1:                 JS_ASSERT(pn->pn_type == TOK_XMLLIST);
    1:                 atom = cx->runtime->atomState.emptyAtom;
    1:                 ale = js_IndexAtom(cx, atom, &cg->atomList);
    1:                 if (!ale)
    1:                     return JS_FALSE;
 3235:                 EMIT_INDEX_OP(JSOP_STRING, ALE_INDEX(ale));
    1:             }
 3164:             if (js_Emit1(cx, cg, PN_OP(pn)) < 0)
    1:                 return JS_FALSE;
    1:         }
    1: #ifdef DEBUG
    1:         else
    1:             JS_ASSERT(pn->pn_count != 0);
    1: #endif
    1:         break;
    1: 
    1:       case TOK_XMLPTAGC:
    1:         if (pn->pn_op == JSOP_XMLOBJECT) {
 3235:             ok = EmitObjectOp(cx, pn->pn_pob, PN_OP(pn), cg);
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: 
    1:       case TOK_XMLSTAGO:
    1:       case TOK_XMLETAGO:
    1:       {
    1:         uint32 i;
    1: 
    1:         if (js_Emit1(cx, cg, JSOP_STARTXML) < 0)
    1:             return JS_FALSE;
    1: 
    1:         ale = js_IndexAtom(cx,
    1:                            (pn->pn_type == TOK_XMLETAGO)
    1:                            ? cx->runtime->atomState.etagoAtom
    1:                            : cx->runtime->atomState.stagoAtom,
    1:                            &cg->atomList);
    1:         if (!ale)
    1:             return JS_FALSE;
 3235:         EMIT_INDEX_OP(JSOP_STRING, ALE_INDEX(ale));
    1: 
    1:         JS_ASSERT(pn->pn_count != 0);
    1:         pn2 = pn->pn_head;
    1:         if (pn2->pn_type == TOK_LC && js_Emit1(cx, cg, JSOP_STARTXMLEXPR) < 0)
    1:             return JS_FALSE;
    1:         if (!js_EmitTree(cx, cg, pn2))
    1:             return JS_FALSE;
    1:         if (js_Emit1(cx, cg, JSOP_ADD) < 0)
    1:             return JS_FALSE;
    1: 
    1:         for (pn2 = pn2->pn_next, i = 0; pn2; pn2 = pn2->pn_next, i++) {
    1:             if (pn2->pn_type == TOK_LC &&
    1:                 js_Emit1(cx, cg, JSOP_STARTXMLEXPR) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:             if (!js_EmitTree(cx, cg, pn2))
    1:                 return JS_FALSE;
    1:             if ((i & 1) && pn2->pn_type == TOK_LC) {
    1:                 if (js_Emit1(cx, cg, JSOP_TOATTRVAL) < 0)
    1:                     return JS_FALSE;
    1:             }
    1:             if (js_Emit1(cx, cg,
    1:                          (i & 1) ? JSOP_ADDATTRVAL : JSOP_ADDATTRNAME) < 0) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         ale = js_IndexAtom(cx,
    1:                            (pn->pn_type == TOK_XMLPTAGC)
    1:                            ? cx->runtime->atomState.ptagcAtom
    1:                            : cx->runtime->atomState.tagcAtom,
    1:                            &cg->atomList);
    1:         if (!ale)
    1:             return JS_FALSE;
 3235:         EMIT_INDEX_OP(JSOP_STRING, ALE_INDEX(ale));
    1:         if (js_Emit1(cx, cg, JSOP_ADD) < 0)
    1:             return JS_FALSE;
    1: 
 3164:         if ((pn->pn_extra & PNX_XMLROOT) && js_Emit1(cx, cg, PN_OP(pn)) < 0)
    1:             return JS_FALSE;
    1:         break;
    1:       }
    1: 
    1:       case TOK_XMLNAME:
    1:         if (pn->pn_arity == PN_LIST) {
    1:             JS_ASSERT(pn->pn_count != 0);
    1:             for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:                 if (!js_EmitTree(cx, cg, pn2))
    1:                     return JS_FALSE;
    1:                 if (pn2 != pn->pn_head && js_Emit1(cx, cg, JSOP_ADD) < 0)
    1:                     return JS_FALSE;
    1:             }
    1:         } else {
    1:             JS_ASSERT(pn->pn_arity == PN_NULLARY);
 3235:             ok = (pn->pn_op == JSOP_OBJECT)
 3235:                  ? EmitObjectOp(cx, pn->pn_pob, PN_OP(pn), cg)
 3235:                  : EmitAtomOp(cx, pn, PN_OP(pn), cg);
    1:         }
    1:         break;
    1: 
    1:       case TOK_XMLPI:
    1:         ale = js_IndexAtom(cx, pn->pn_atom2, &cg->atomList);
    1:         if (!ale)
    1:             return JS_FALSE;
 3235:         if (!EmitIndexOp(cx, JSOP_QNAMEPART, ALE_INDEX(ale), cg))
    1:             return JS_FALSE;
    1:         if (!EmitAtomOp(cx, pn, JSOP_XMLPI, cg))
    1:             return JS_FALSE;
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:       default:
    1:         JS_ASSERT(0);
    1:     }
    1: 
    1:     if (ok && --cg->emitLevel == 0 && cg->spanDeps)
    1:         ok = OptimizeSpanDeps(cx, cg);
    1: 
    1:     return ok;
    1: }
    1: 
21520: /*
21520:  * We should try to get rid of offsetBias (always 0 or 1, where 1 is
21520:  * JSOP_{NOP,POP}_LENGTH), which is used only by SRC_FOR and SRC_DECL.
21520:  */
    1: JS_FRIEND_DATA(JSSrcNoteSpec) js_SrcNoteSpec[] = {
    1:     {"null",            0,      0,      0},
    1:     {"if",              0,      0,      0},
    1:     {"if-else",         2,      0,      1},
20943:     {"for",             3,      1,      1},
    1:     {"while",           1,      0,      1},
    1:     {"continue",        0,      0,      0},
    1:     {"decl",            1,      1,      1},
    1:     {"pcdelta",         1,      0,      1},
    1:     {"assignop",        0,      0,      0},
    1:     {"cond",            1,      0,      1},
    1:     {"brace",           1,      0,      1},
    1:     {"hidden",          0,      0,      0},
    1:     {"pcbase",          1,      0,     -1},
    1:     {"label",           1,      0,      0},
    1:     {"labelbrace",      1,      0,      0},
    1:     {"endbrace",        0,      0,      0},
    1:     {"break2label",     1,      0,      0},
    1:     {"cont2label",      1,      0,      0},
    1:     {"switch",          2,      0,      1},
    1:     {"funcdef",         1,      0,      0},
    1:     {"catch",           1,      0,      1},
    1:     {"extended",       -1,      0,      0},
    1:     {"newline",         0,      0,      0},
    1:     {"setline",         1,      0,      0},
    1:     {"xdelta",          0,      0,      0},
    1: };
    1: 
    1: static intN
    1: AllocSrcNote(JSContext *cx, JSCodeGenerator *cg)
    1: {
    1:     intN index;
    1:     JSArenaPool *pool;
    1:     size_t size;
    1: 
    1:     index = CG_NOTE_COUNT(cg);
    1:     if (((uintN)index & CG_NOTE_MASK(cg)) == 0) {
    1:         pool = cg->notePool;
    1:         size = SRCNOTE_SIZE(CG_NOTE_MASK(cg) + 1);
    1:         if (!CG_NOTES(cg)) {
    1:             /* Allocate the first note array lazily; leave noteMask alone. */
    1:             JS_ARENA_ALLOCATE_CAST(CG_NOTES(cg), jssrcnote *, pool, size);
    1:         } else {
    1:             /* Grow by doubling note array size; update noteMask on success. */
    1:             JS_ARENA_GROW_CAST(CG_NOTES(cg), jssrcnote *, pool, size, size);
    1:             if (CG_NOTES(cg))
    1:                 CG_NOTE_MASK(cg) = (CG_NOTE_MASK(cg) << 1) | 1;
    1:         }
    1:         if (!CG_NOTES(cg)) {
 8296:             js_ReportOutOfScriptQuota(cx);
    1:             return -1;
    1:         }
    1:     }
    1: 
    1:     CG_NOTE_COUNT(cg) = index + 1;
    1:     return index;
    1: }
    1: 
    1: intN
    1: js_NewSrcNote(JSContext *cx, JSCodeGenerator *cg, JSSrcNoteType type)
    1: {
    1:     intN index, n;
    1:     jssrcnote *sn;
    1:     ptrdiff_t offset, delta, xdelta;
    1: 
    1:     /*
    1:      * Claim a note slot in CG_NOTES(cg) by growing it if necessary and then
    1:      * incrementing CG_NOTE_COUNT(cg).
    1:      */
    1:     index = AllocSrcNote(cx, cg);
    1:     if (index < 0)
    1:         return -1;
    1:     sn = &CG_NOTES(cg)[index];
    1: 
    1:     /*
    1:      * Compute delta from the last annotated bytecode's offset.  If it's too
    1:      * big to fit in sn, allocate one or more xdelta notes and reset sn.
    1:      */
    1:     offset = CG_OFFSET(cg);
    1:     delta = offset - CG_LAST_NOTE_OFFSET(cg);
    1:     CG_LAST_NOTE_OFFSET(cg) = offset;
    1:     if (delta >= SN_DELTA_LIMIT) {
    1:         do {
    1:             xdelta = JS_MIN(delta, SN_XDELTA_MASK);
    1:             SN_MAKE_XDELTA(sn, xdelta);
    1:             delta -= xdelta;
    1:             index = AllocSrcNote(cx, cg);
    1:             if (index < 0)
    1:                 return -1;
    1:             sn = &CG_NOTES(cg)[index];
    1:         } while (delta >= SN_DELTA_LIMIT);
    1:     }
    1: 
    1:     /*
    1:      * Initialize type and delta, then allocate the minimum number of notes
    1:      * needed for type's arity.  Usually, we won't need more, but if an offset
    1:      * does take two bytes, js_SetSrcNoteOffset will grow CG_NOTES(cg).
    1:      */
    1:     SN_MAKE_NOTE(sn, type, delta);
    1:     for (n = (intN)js_SrcNoteSpec[type].arity; n > 0; n--) {
    1:         if (js_NewSrcNote(cx, cg, SRC_NULL) < 0)
    1:             return -1;
    1:     }
    1:     return index;
    1: }
    1: 
    1: intN
    1: js_NewSrcNote2(JSContext *cx, JSCodeGenerator *cg, JSSrcNoteType type,
    1:                ptrdiff_t offset)
    1: {
    1:     intN index;
    1: 
    1:     index = js_NewSrcNote(cx, cg, type);
    1:     if (index >= 0) {
    1:         if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset))
    1:             return -1;
    1:     }
    1:     return index;
    1: }
    1: 
    1: intN
    1: js_NewSrcNote3(JSContext *cx, JSCodeGenerator *cg, JSSrcNoteType type,
    1:                ptrdiff_t offset1, ptrdiff_t offset2)
    1: {
    1:     intN index;
    1: 
    1:     index = js_NewSrcNote(cx, cg, type);
    1:     if (index >= 0) {
    1:         if (!js_SetSrcNoteOffset(cx, cg, index, 0, offset1))
    1:             return -1;
    1:         if (!js_SetSrcNoteOffset(cx, cg, index, 1, offset2))
    1:             return -1;
    1:     }
    1:     return index;
    1: }
    1: 
    1: static JSBool
    1: GrowSrcNotes(JSContext *cx, JSCodeGenerator *cg)
    1: {
    1:     JSArenaPool *pool;
    1:     size_t size;
    1: 
    1:     /* Grow by doubling note array size; update noteMask on success. */
    1:     pool = cg->notePool;
    1:     size = SRCNOTE_SIZE(CG_NOTE_MASK(cg) + 1);
    1:     JS_ARENA_GROW_CAST(CG_NOTES(cg), jssrcnote *, pool, size, size);
    1:     if (!CG_NOTES(cg)) {
 8296:         js_ReportOutOfScriptQuota(cx);
    1:         return JS_FALSE;
    1:     }
    1:     CG_NOTE_MASK(cg) = (CG_NOTE_MASK(cg) << 1) | 1;
    1:     return JS_TRUE;
    1: }
    1: 
    1: jssrcnote *
    1: js_AddToSrcNoteDelta(JSContext *cx, JSCodeGenerator *cg, jssrcnote *sn,
    1:                      ptrdiff_t delta)
    1: {
    1:     ptrdiff_t base, limit, newdelta, diff;
    1:     intN index;
    1: 
    1:     /*
    1:      * Called only from OptimizeSpanDeps and js_FinishTakingSrcNotes to add to
    1:      * main script note deltas, and only by a small positive amount.
    1:      */
    1:     JS_ASSERT(cg->current == &cg->main);
    1:     JS_ASSERT((unsigned) delta < (unsigned) SN_XDELTA_LIMIT);
    1: 
    1:     base = SN_DELTA(sn);
    1:     limit = SN_IS_XDELTA(sn) ? SN_XDELTA_LIMIT : SN_DELTA_LIMIT;
    1:     newdelta = base + delta;
    1:     if (newdelta < limit) {
    1:         SN_SET_DELTA(sn, newdelta);
    1:     } else {
    1:         index = sn - cg->main.notes;
    1:         if ((cg->main.noteCount & cg->main.noteMask) == 0) {
    1:             if (!GrowSrcNotes(cx, cg))
    1:                 return NULL;
    1:             sn = cg->main.notes + index;
    1:         }
    1:         diff = cg->main.noteCount - index;
    1:         cg->main.noteCount++;
    1:         memmove(sn + 1, sn, SRCNOTE_SIZE(diff));
    1:         SN_MAKE_XDELTA(sn, delta);
    1:         sn++;
    1:     }
    1:     return sn;
    1: }
    1: 
    1: JS_FRIEND_API(uintN)
    1: js_SrcNoteLength(jssrcnote *sn)
    1: {
    1:     uintN arity;
    1:     jssrcnote *base;
    1: 
    1:     arity = (intN)js_SrcNoteSpec[SN_TYPE(sn)].arity;
    1:     for (base = sn++; arity; sn++, arity--) {
    1:         if (*sn & SN_3BYTE_OFFSET_FLAG)
    1:             sn += 2;
    1:     }
    1:     return sn - base;
    1: }
    1: 
    1: JS_FRIEND_API(ptrdiff_t)
    1: js_GetSrcNoteOffset(jssrcnote *sn, uintN which)
    1: {
    1:     /* Find the offset numbered which (i.e., skip exactly which offsets). */
    1:     JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
15428:     JS_ASSERT((intN) which < js_SrcNoteSpec[SN_TYPE(sn)].arity);
    1:     for (sn++; which; sn++, which--) {
    1:         if (*sn & SN_3BYTE_OFFSET_FLAG)
    1:             sn += 2;
    1:     }
    1:     if (*sn & SN_3BYTE_OFFSET_FLAG) {
    1:         return (ptrdiff_t)(((uint32)(sn[0] & SN_3BYTE_OFFSET_MASK) << 16)
    1:                            | (sn[1] << 8)
    1:                            | sn[2]);
    1:     }
    1:     return (ptrdiff_t)*sn;
    1: }
    1: 
    1: JSBool
    1: js_SetSrcNoteOffset(JSContext *cx, JSCodeGenerator *cg, uintN index,
    1:                     uintN which, ptrdiff_t offset)
    1: {
    1:     jssrcnote *sn;
    1:     ptrdiff_t diff;
    1: 
    1:     if ((jsuword)offset >= (jsuword)((ptrdiff_t)SN_3BYTE_OFFSET_FLAG << 16)) {
    1:         ReportStatementTooLarge(cx, cg);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Find the offset numbered which (i.e., skip exactly which offsets). */
    1:     sn = &CG_NOTES(cg)[index];
    1:     JS_ASSERT(SN_TYPE(sn) != SRC_XDELTA);
15428:     JS_ASSERT((intN) which < js_SrcNoteSpec[SN_TYPE(sn)].arity);
    1:     for (sn++; which; sn++, which--) {
    1:         if (*sn & SN_3BYTE_OFFSET_FLAG)
    1:             sn += 2;
    1:     }
    1: 
    1:     /* See if the new offset requires three bytes. */
    1:     if (offset > (ptrdiff_t)SN_3BYTE_OFFSET_MASK) {
    1:         /* Maybe this offset was already set to a three-byte value. */
    1:         if (!(*sn & SN_3BYTE_OFFSET_FLAG)) {
    1:             /* Losing, need to insert another two bytes for this offset. */
    1:             index = PTRDIFF(sn, CG_NOTES(cg), jssrcnote);
    1: 
    1:             /*
    1:              * Simultaneously test to see if the source note array must grow to
23709:              * accommodate either the first or second byte of additional storage
    1:              * required by this 3-byte offset.
    1:              */
    1:             if (((CG_NOTE_COUNT(cg) + 1) & CG_NOTE_MASK(cg)) <= 1) {
    1:                 if (!GrowSrcNotes(cx, cg))
    1:                     return JS_FALSE;
    1:                 sn = CG_NOTES(cg) + index;
    1:             }
    1:             CG_NOTE_COUNT(cg) += 2;
    1: 
    1:             diff = CG_NOTE_COUNT(cg) - (index + 3);
    1:             JS_ASSERT(diff >= 0);
    1:             if (diff > 0)
    1:                 memmove(sn + 3, sn + 1, SRCNOTE_SIZE(diff));
    1:         }
    1:         *sn++ = (jssrcnote)(SN_3BYTE_OFFSET_FLAG | (offset >> 16));
    1:         *sn++ = (jssrcnote)(offset >> 8);
    1:     }
    1:     *sn = (jssrcnote)offset;
    1:     return JS_TRUE;
    1: }
    1: 
    1: #ifdef DEBUG_notme
    1: #define DEBUG_srcnotesize
    1: #endif
    1: 
    1: #ifdef DEBUG_srcnotesize
    1: #define NBINS 10
    1: static uint32 hist[NBINS];
    1: 
    1: void DumpSrcNoteSizeHist()
    1: {
    1:     static FILE *fp;
    1:     int i, n;
    1: 
    1:     if (!fp) {
    1:         fp = fopen("/tmp/srcnotes.hist", "w");
    1:         if (!fp)
    1:             return;
    1:         setvbuf(fp, NULL, _IONBF, 0);
    1:     }
    1:     fprintf(fp, "SrcNote size histogram:\n");
    1:     for (i = 0; i < NBINS; i++) {
    1:         fprintf(fp, "%4u %4u ", JS_BIT(i), hist[i]);
    1:         for (n = (int) JS_HOWMANY(hist[i], 10); n > 0; --n)
    1:             fputc('*', fp);
    1:         fputc('\n', fp);
    1:     }
    1:     fputc('\n', fp);
    1: }
    1: #endif
    1: 
    1: /*
    1:  * Fill in the storage at notes with prolog and main srcnotes; the space at
    1:  * notes was allocated using the CG_COUNT_FINAL_SRCNOTES macro from jsemit.h.
    1:  * SO DON'T CHANGE THIS FUNCTION WITHOUT AT LEAST CHECKING WHETHER jsemit.h's
    1:  * CG_COUNT_FINAL_SRCNOTES MACRO NEEDS CORRESPONDING CHANGES!
    1:  */
    1: JSBool
    1: js_FinishTakingSrcNotes(JSContext *cx, JSCodeGenerator *cg, jssrcnote *notes)
    1: {
    1:     uintN prologCount, mainCount, totalCount;
    1:     ptrdiff_t offset, delta;
    1:     jssrcnote *sn;
    1: 
    1:     JS_ASSERT(cg->current == &cg->main);
    1: 
    1:     prologCount = cg->prolog.noteCount;
    1:     if (prologCount && cg->prolog.currentLine != cg->firstLine) {
    1:         CG_SWITCH_TO_PROLOG(cg);
    1:         if (js_NewSrcNote2(cx, cg, SRC_SETLINE, (ptrdiff_t)cg->firstLine) < 0)
    1:             return JS_FALSE;
    1:         prologCount = cg->prolog.noteCount;
    1:         CG_SWITCH_TO_MAIN(cg);
    1:     } else {
    1:         /*
    1:          * Either no prolog srcnotes, or no line number change over prolog.
    1:          * We don't need a SRC_SETLINE, but we may need to adjust the offset
    1:          * of the first main note, by adding to its delta and possibly even
    1:          * prepending SRC_XDELTA notes to it to account for prolog bytecodes
    1:          * that came at and after the last annotated bytecode.
    1:          */
    1:         offset = CG_PROLOG_OFFSET(cg) - cg->prolog.lastNoteOffset;
    1:         JS_ASSERT(offset >= 0);
 3457:         if (offset > 0 && cg->main.noteCount != 0) {
    1:             /* NB: Use as much of the first main note's delta as we can. */
    1:             sn = cg->main.notes;
    1:             delta = SN_IS_XDELTA(sn)
    1:                     ? SN_XDELTA_MASK - (*sn & SN_XDELTA_MASK)
    1:                     : SN_DELTA_MASK - (*sn & SN_DELTA_MASK);
    1:             if (offset < delta)
    1:                 delta = offset;
    1:             for (;;) {
    1:                 if (!js_AddToSrcNoteDelta(cx, cg, sn, delta))
    1:                     return JS_FALSE;
    1:                 offset -= delta;
    1:                 if (offset == 0)
    1:                     break;
    1:                 delta = JS_MIN(offset, SN_XDELTA_MASK);
    1:                 sn = cg->main.notes;
    1:             }
    1:         }
    1:     }
    1: 
    1:     mainCount = cg->main.noteCount;
    1:     totalCount = prologCount + mainCount;
    1:     if (prologCount)
    1:         memcpy(notes, cg->prolog.notes, SRCNOTE_SIZE(prologCount));
    1:     memcpy(notes + prologCount, cg->main.notes, SRCNOTE_SIZE(mainCount));
    1:     SN_MAKE_TERMINATOR(&notes[totalCount]);
    1: 
    1: #ifdef DEBUG_notme
    1:   { int bin = JS_CeilingLog2(totalCount);
    1:     if (bin >= NBINS)
    1:         bin = NBINS - 1;
    1:     ++hist[bin];
    1:   }
    1: #endif
    1:     return JS_TRUE;
    1: }
    1: 
 3025: static JSBool
 3025: NewTryNote(JSContext *cx, JSCodeGenerator *cg, JSTryNoteKind kind,
 1825:            uintN stackDepth, size_t start, size_t end)
    1: {
 3025:     JSTryNode *tryNode;
 3025: 
 1825:     JS_ASSERT((uintN)(uint16)stackDepth == stackDepth);
 1825:     JS_ASSERT(start <= end);
 1825:     JS_ASSERT((size_t)(uint32)start == start);
 1825:     JS_ASSERT((size_t)(uint32)end == end);
 3025: 
 3025:     JS_ARENA_ALLOCATE_TYPE(tryNode, JSTryNode, &cx->tempPool);
 8296:     if (!tryNode) {
 8296:         js_ReportOutOfScriptQuota(cx);
 8296:         return JS_FALSE;
 8296:     }
 3025: 
 3025:     tryNode->note.kind = kind;
 3025:     tryNode->note.stackDepth = (uint16)stackDepth;
 3025:     tryNode->note.start = (uint32)start;
 3025:     tryNode->note.length = (uint32)(end - start);
 3025:     tryNode->prev = cg->lastTryNode;
 3025:     cg->lastTryNode = tryNode;
 3025:     cg->ntrynotes++;
 3025:     return JS_TRUE;
    1: }
    1: 
    1: void
 3235: js_FinishTakingTryNotes(JSCodeGenerator *cg, JSTryNoteArray *array)
    1: {
 3025:     JSTryNode *tryNode;
 3025:     JSTryNote *tn;
 3025: 
 3025:     JS_ASSERT(array->length > 0 && array->length == cg->ntrynotes);
 3235:     tn = array->vector + array->length;
 3025:     tryNode = cg->lastTryNode;
 3025:     do {
 3025:         *--tn = tryNode->note;
 3025:     } while ((tryNode = tryNode->prev) != NULL);
 3235:     JS_ASSERT(tn == array->vector);
 3235: }
 3235: 
 3235: /*
 3235:  * Find the index of the given object for code generator.
 3235:  *
 3235:  * Since the emitter refers to each parsed object only once, for the index we
 3235:  * use the number of already indexes objects. We also add the object to a list
 3235:  * to convert the list to a fixed-size array when we complete code generation,
 3235:  * see FinishParsedObjects bellow.
 3235:  *
 3235:  * Most of the objects go to JSCodeGenerator.objectList but for regexp we use
 3235:  * a separated JSCodeGenerator.regexpList. In this way the emitted index can
 3235:  * be directly used to store and fetch a reference to a cloned RegExp object
 3235:  * that shares the same JSRegExp private data created for the object literal
 3235:  * in pob. We need clones to hold lastIndex and other direct properties that
 3235:  * should not be shared among threads sharing a precompiled function or
 3235:  * script.
 3235:  *
 3235:  * If the code being compiled is function code, allocate a reserved slot in
 3235:  * the cloned function object that shares its precompiled script with other
 3235:  * cloned function objects and with the compiler-created clone-parent. There
18308:  * are nregexps = JS_SCRIPT_REGEXPS(script)->length such reserved slots in each
18308:  * function object cloned from fun->object. NB: during compilation, a funobj
18308:  * slots element must never be allocated, because js_AllocSlot could hand out
18308:  * one of the slots that should be given to a regexp clone.
 3235:  *
 3235:  * If the code being compiled is global code, the cloned regexp are stored in
 3235:  * fp->vars slot after cg->treeContext.ngvars and to protect regexp slots from
 3235:  * GC we set fp->nvars to ngvars + nregexps.
 3235:  *
 3235:  * The slots initially contain undefined or null. We populate them lazily when
 3235:  * JSOP_REGEXP is executed for the first time.
 3235:  *
 3235:  * Why clone regexp objects?  ECMA specifies that when a regular expression
 3235:  * literal is scanned, a RegExp object is created.  In the spec, compilation
 3235:  * and execution happen indivisibly, but in this implementation and many of
 3235:  * its embeddings, code is precompiled early and re-executed in multiple
 3235:  * threads, or using multiple global objects, or both, for efficiency.
 3235:  *
 3235:  * In such cases, naively following ECMA leads to wrongful sharing of RegExp
 3235:  * objects, which makes for collisions on the lastIndex property (especially
 3235:  * for global regexps) and on any ad-hoc properties.  Also, __proto__ and
 3235:  * __parent__ refer to the pre-compilation prototype and global objects, a
 3235:  * pigeon-hole problem for instanceof tests.
 3235:  */
 3235: static uintN
 3235: IndexParsedObject(JSParsedObjectBox *pob, JSEmittedObjectList *list)
 3235: {
 3235:     JS_ASSERT(!pob->emitLink);
 3235:     pob->emitLink = list->lastPob;
 3235:     list->lastPob = pob;
 3235:     return list->length++;
 3235: }
 3235: 
 3235: void
 3235: FinishParsedObjects(JSEmittedObjectList *emittedList, JSObjectArray *array)
 3235: {
 3235:     JSObject **cursor;
 3235:     JSParsedObjectBox *pob;
 3235: 
 3235:     JS_ASSERT(emittedList->length <= INDEX_LIMIT);
 3235:     JS_ASSERT(emittedList->length == array->length);
 3235: 
 3235:     cursor = array->vector + array->length;
 3235:     pob = emittedList->lastPob;
 3235:     do {
 3235:         --cursor;
 3235:         JS_ASSERT(!*cursor);
 3235:         *cursor = pob->object;
 3235:     } while ((pob = pob->emitLink) != NULL);
 3235:     JS_ASSERT(cursor == array->vector);
 3235: }
