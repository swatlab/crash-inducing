    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   David W. Hyatt (hyatt@netscape.com) (Original Author)
    1:  *   Joe Hewitt (hewitt@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsPIListBoxObject.h"
    1: #include "nsBoxObject.h"
    1: #include "nsIFrame.h"
    1: #include "nsIDocument.h"
    1: #include "nsBindingManager.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIScrollableFrame.h"
18344: #include "nsListBoxBodyFrame.h"
    1: 
    1: class nsListBoxObject : public nsPIListBoxObject, public nsBoxObject
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS_INHERITED
    1:   NS_DECL_NSILISTBOXOBJECT
    1: 
    1:   // nsPIListBoxObject
20990:   virtual nsListBoxBodyFrame* GetListBoxBody(PRBool aFlush);
    1: 
    1:   nsListBoxObject();
    1: 
    1:   // nsPIBoxObject
    1:   virtual void Clear();
    1:   virtual void ClearCachedValues();
    1:   
    1: protected:
20990:   nsListBoxBodyFrame *mListBoxBody;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS_INHERITED2(nsListBoxObject, nsBoxObject, nsIListBoxObject,
    1:                              nsPIListBoxObject)
    1: 
    1: nsListBoxObject::nsListBoxObject()
    1:   : mListBoxBody(nsnull)
    1: {
    1: }
    1: 
    1: //////////////////////////////////////////////////////////////////////////
    1: //// nsIListBoxObject
    1: 
    1: NS_IMETHODIMP
    1: nsListBoxObject::GetRowCount(PRInt32 *aResult)
    1: {
20990:   nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
    1:   if (body)
    1:     return body->GetRowCount(aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsListBoxObject::GetNumberOfVisibleRows(PRInt32 *aResult)
    1: {
20990:   nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
    1:   if (body)
    1:     return body->GetNumberOfVisibleRows(aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsListBoxObject::GetIndexOfFirstVisibleRow(PRInt32 *aResult)
    1: {
20990:   nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
    1:   if (body)
    1:     return body->GetIndexOfFirstVisibleRow(aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsListBoxObject::EnsureIndexIsVisible(PRInt32 aRowIndex)
    1: {
20990:   nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
    1:   if (body)
    1:     return body->EnsureIndexIsVisible(aRowIndex);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsListBoxObject::ScrollToIndex(PRInt32 aRowIndex)
    1: {
20990:   nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
    1:   if (body)
    1:     return body->ScrollToIndex(aRowIndex);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsListBoxObject::ScrollByLines(PRInt32 aNumLines)
    1: {
20990:   nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
    1:   if (body)
    1:     return body->ScrollByLines(aNumLines);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsListBoxObject::GetItemAtIndex(PRInt32 index, nsIDOMElement **_retval)
    1: {
20990:   nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
    1:   if (body)
    1:     return body->GetItemAtIndex(index, _retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsListBoxObject::GetIndexOfItem(nsIDOMElement* aElement, PRInt32 *aResult)
    1: {
    1:   *aResult = 0;
    1: 
20990:   nsListBoxBodyFrame* body = GetListBoxBody(PR_TRUE);
    1:   if (body)
    1:     return body->GetIndexOfItem(aElement, aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: //////////////////////
    1: 
    1: static void
    1: FindBodyContent(nsIContent* aParent, nsIContent** aResult)
    1: {
    1:   if (aParent->Tag() == nsGkAtoms::listboxbody) {
    1:     *aResult = aParent;
    1:     NS_IF_ADDREF(*aResult);
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIDOMNodeList> kids;
37147:     aParent->GetOwnerDoc()->BindingManager()->GetXBLChildNodesFor(aParent, getter_AddRefs(kids));
    1:     if (!kids) return;
    1: 
    1:     PRUint32 i;
    1:     kids->GetLength(&i);
    1:     // start from the end, cuz we're smart and we know the listboxbody is probably at the end
    1:     while (i > 0) {
    1:       nsCOMPtr<nsIDOMNode> childNode;
    1:       kids->Item(--i, getter_AddRefs(childNode));
    1:       nsCOMPtr<nsIContent> childContent(do_QueryInterface(childNode));
    1:       FindBodyContent(childContent, aResult);
    1:       if (*aResult)
    1:         break;
    1:     }
    1:   }
    1: }
    1: 
20990: nsListBoxBodyFrame*
 6699: nsListBoxObject::GetListBoxBody(PRBool aFlush)
    1: {
    1:   if (mListBoxBody) {
    1:     return mListBoxBody;
    1:   }
    1: 
    1:   nsIPresShell* shell = GetPresShell(PR_FALSE);
    1:   if (!shell) {
    1:     return nsnull;
    1:   }
    1: 
 6699:   nsIFrame* frame = aFlush ? 
 6699:                       GetFrame(PR_FALSE) /* does Flush_Frames */ :
36656:                       mContent->GetPrimaryFrame();
 6699:   if (!frame)
 6699:     return nsnull;
 6699: 
    1:   // Iterate over our content model children looking for the body.
    1:   nsCOMPtr<nsIContent> content;
    1:   FindBodyContent(frame->GetContent(), getter_AddRefs(content));
    1: 
36716:   if (!content)
36716:     return nsnull;
36716: 
    1:   // this frame will be a nsGFXScrollFrame
36656:   frame = content->GetPrimaryFrame();
    1:   if (!frame)
    1:      return nsnull;
23554:   nsIScrollableFrame* scrollFrame = do_QueryFrame(frame);
    1:   if (!scrollFrame)
    1:     return nsnull;
    1: 
    1:   // this frame will be the one we want
    1:   nsIFrame* yeahBaby = scrollFrame->GetScrolledFrame();
    1:   if (!yeahBaby)
    1:      return nsnull;
    1: 
    1:   // It's a frame. Refcounts are irrelevant.
23554:   nsListBoxBodyFrame* listBoxBody = do_QueryFrame(yeahBaby);
18344:   NS_ENSURE_TRUE(listBoxBody &&
20990:                  listBoxBody->SetBoxObject(this),
18344:                  nsnull);
18344:   mListBoxBody = listBoxBody;
    1:   return mListBoxBody;
    1: }
    1: 
    1: void
    1: nsListBoxObject::Clear()
    1: {
    1:   ClearCachedValues();
    1: 
    1:   nsBoxObject::Clear();
    1: }
    1: 
    1: void
    1: nsListBoxObject::ClearCachedValues()
    1: {
    1:   mListBoxBody = nsnull;
    1: }
    1: 
    1: // Creation Routine ///////////////////////////////////////////////////////////////////////
    1: 
    1: nsresult
    1: NS_NewListBoxObject(nsIBoxObject** aResult)
    1: {
    1:   *aResult = new nsListBoxObject;
    1:   if (!*aResult)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
