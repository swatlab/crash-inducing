    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Jonas Sicking <jonas@sicking.cc> (Original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1:  
    1: #include "nsXMLPrettyPrinter.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsIDOMDocumentXBL.h"
    1: #include "nsIObserver.h"
    1: #include "nsIXSLTProcessor.h"
    1: #include "nsSyncLoadService.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsNetUtil.h"
51350: #include "mozilla/dom/Element.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsBindingManager.h"
51667: #include "nsIScriptSecurityManager.h"
70840: #include "mozilla/Preferences.h"
    1: 
70840: using namespace mozilla;
51350: using namespace mozilla::dom;
51350: 
    1: NS_IMPL_ISUPPORTS2(nsXMLPrettyPrinter,
    1:                    nsIDocumentObserver,
    1:                    nsIMutationObserver)
    1: 
    1: nsXMLPrettyPrinter::nsXMLPrettyPrinter() : mDocument(nsnull),
    1:                                            mUpdateDepth(0),
    1:                                            mUnhookPending(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsXMLPrettyPrinter::~nsXMLPrettyPrinter()
    1: {
    1:     NS_ASSERTION(!mDocument, "we shouldn't be referencing the document still");
    1: }
    1: 
    1: nsresult
 2026: nsXMLPrettyPrinter::PrettyPrint(nsIDocument* aDocument,
79445:                                 bool* aDidPrettyPrint)
    1: {
 2026:     *aDidPrettyPrint = PR_FALSE;
 2026:     
    1:     // Check for iframe with display:none. Such iframes don't have presshells
46225:     if (!aDocument->GetShell()) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // check if we're in an invisible iframe
    1:     nsPIDOMWindow *internalWin = aDocument->GetWindow();
    1:     nsCOMPtr<nsIDOMElement> frameElem;
    1:     if (internalWin) {
    1:         internalWin->GetFrameElement(getter_AddRefs(frameElem));
    1:     }
    1: 
    1:     if (frameElem) {
    1:         nsCOMPtr<nsIDOMCSSStyleDeclaration> computedStyle;
    1:         nsCOMPtr<nsIDOMDocument> frameOwnerDoc;
    1:         frameElem->GetOwnerDocument(getter_AddRefs(frameOwnerDoc));
69169:         if (frameOwnerDoc) {
69169:             nsCOMPtr<nsIDOMWindow> window;
69169:             frameOwnerDoc->GetDefaultView(getter_AddRefs(window));
69169:             if (window) {
69169:                 window->GetComputedStyle(frameElem,
    1:                                          EmptyString(),
    1:                                          getter_AddRefs(computedStyle));
    1:             }
    1:         }
    1: 
    1:         if (computedStyle) {
    1:             nsAutoString visibility;
    1:             computedStyle->GetPropertyValue(NS_LITERAL_STRING("visibility"),
    1:                                             visibility);
    1:             if (!visibility.EqualsLiteral("visible")) {
    1: 
    1:                 return NS_OK;
    1:             }
    1:         }
    1:     }
    1: 
    1:     // check the pref
79445:     if (!Preferences::GetBool("layout.xml.prettyprint", true)) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Ok, we should prettyprint. Let's do it!
 2026:     *aDidPrettyPrint = PR_TRUE;
    1:     nsresult rv = NS_OK;
    1: 
    1:     // Load the XSLT
    1:     nsCOMPtr<nsIURI> xslUri;
    1:     rv = NS_NewURI(getter_AddRefs(xslUri),
    1:                    NS_LITERAL_CSTRING("chrome://global/content/xml/XMLPrettyPrint.xsl"));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIDOMDocument> xslDocument;
    1:     rv = nsSyncLoadService::LoadDocument(xslUri, nsnull, nsnull, PR_TRUE,
    1:                                          getter_AddRefs(xslDocument));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Transform the document
    1:     nsCOMPtr<nsIXSLTProcessor> transformer =
    1:         do_CreateInstance("@mozilla.org/document-transformer;1?type=xslt", &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = transformer->ImportStylesheet(xslDocument);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIDOMDocumentFragment> resultFragment;
    1:     nsCOMPtr<nsIDOMDocument> sourceDocument = do_QueryInterface(aDocument);
    1:     rv = transformer->TransformToFragment(sourceDocument, sourceDocument,
    1:                                           getter_AddRefs(resultFragment));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Add the binding
    1:     nsCOMPtr<nsIDOMDocumentXBL> xblDoc = do_QueryInterface(aDocument);
    1:     NS_ASSERTION(xblDoc, "xml document doesn't implement nsIDOMDocumentXBL");
    1:     NS_ENSURE_TRUE(xblDoc, NS_ERROR_FAILURE);
    1: 
51667:     nsCOMPtr<nsIURI> bindingUri;
51667:     rv = NS_NewURI(getter_AddRefs(bindingUri),
51667:         NS_LITERAL_STRING("chrome://global/content/xml/XMLPrettyPrint.xml#prettyprint"));
51667:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
51667:     nsCOMPtr<nsIPrincipal> sysPrincipal;
51667:     nsContentUtils::GetSecurityManager()->
51667:         GetSystemPrincipal(getter_AddRefs(sysPrincipal));
51667:     aDocument->BindingManager()->LoadBindingDocument(aDocument, bindingUri,
51667:                                                      sysPrincipal);
    1: 
51667:     nsCOMPtr<nsIContent> rootCont = aDocument->GetRootElement();
51667:     NS_ENSURE_TRUE(rootCont, NS_ERROR_UNEXPECTED);
51667: 
51667:     rv = aDocument->BindingManager()->AddLayeredBinding(rootCont, bindingUri,
51667:                                                         sysPrincipal);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Hand the result document to the binding
    1:     nsCOMPtr<nsIObserver> binding;
    1:     aDocument->BindingManager()->GetBindingImplementation(rootCont,
    1:                                               NS_GET_IID(nsIObserver),
    1:                                               (void**)getter_AddRefs(binding));
    1:     NS_ASSERTION(binding, "Prettyprint binding doesn't implement nsIObserver");
    1:     NS_ENSURE_TRUE(binding, NS_ERROR_UNEXPECTED);
    1:     
    1:     rv = binding->Observe(resultFragment, "prettyprint-dom-created",
    1:                           EmptyString().get());
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Observe the document so we know when to switch to "normal" view
    1:     aDocument->AddObserver(this);
    1:     mDocument = aDocument;
    1: 
    1:     NS_ADDREF_THIS();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsXMLPrettyPrinter::MaybeUnhook(nsIContent* aContent)
    1: {
    1:     // If there either aContent is null (the document-node was modified) or
    1:     // there isn't a binding parent we know it's non-anonymous content.
79650:     if ((!aContent || !aContent->GetBindingParent()) && !mUnhookPending) {
71102:         // Can't blindly to mUnhookPending after AddScriptRunner,
71102:         // since AddScriptRunner _could_ in theory run us
71102:         // synchronously
    1:         mUnhookPending = PR_TRUE;
71102:         nsContentUtils::AddScriptRunner(
71102:           NS_NewRunnableMethod(this, &nsXMLPrettyPrinter::Unhook));
    1:     }
    1: }
    1: 
    1: void
71102: nsXMLPrettyPrinter::Unhook()
    1: {
    1:     mDocument->RemoveObserver(this);
    1:     nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(mDocument);
    1:     nsCOMPtr<nsIDOMElement> rootElem;
    1:     document->GetDocumentElement(getter_AddRefs(rootElem));
    1: 
    1:     if (rootElem) {
    1:         nsCOMPtr<nsIDOMDocumentXBL> xblDoc = do_QueryInterface(mDocument);
    1:         xblDoc->RemoveBinding(rootElem,
    1:                               NS_LITERAL_STRING("chrome://global/content/xml/XMLPrettyPrint.xml#prettyprint"));
    1:     }
    1: 
    1:     mDocument = nsnull;
    1: 
    1:     NS_RELEASE_THIS();
    1: }
    1: 
    1: void
    1: nsXMLPrettyPrinter::AttributeChanged(nsIDocument* aDocument,
51350:                                      Element* aElement,
    1:                                      PRInt32 aNameSpaceID,
    1:                                      nsIAtom* aAttribute,
35535:                                      PRInt32 aModType)
    1: {
51350:     MaybeUnhook(aElement);
    1: }
    1: 
    1: void
    1: nsXMLPrettyPrinter::ContentAppended(nsIDocument* aDocument,
    1:                                     nsIContent* aContainer,
42107:                                     nsIContent* aFirstNewContent,
    1:                                     PRInt32 aNewIndexInContainer)
    1: {
    1:     MaybeUnhook(aContainer);
    1: }
    1: 
    1: void
    1: nsXMLPrettyPrinter::ContentInserted(nsIDocument* aDocument,
    1:                                     nsIContent* aContainer,
    1:                                     nsIContent* aChild,
    1:                                     PRInt32 aIndexInContainer)
    1: {
    1:     MaybeUnhook(aContainer);
    1: }
    1: 
    1: void
    1: nsXMLPrettyPrinter::ContentRemoved(nsIDocument* aDocument,
    1:                                    nsIContent* aContainer,
    1:                                    nsIContent* aChild,
48038:                                    PRInt32 aIndexInContainer,
48038:                                    nsIContent* aPreviousSibling)
    1: {
    1:     MaybeUnhook(aContainer);
    1: }
    1: 
    1: void
    1: nsXMLPrettyPrinter::NodeWillBeDestroyed(const nsINode* aNode)
    1: {
    1:     mDocument = nsnull;
    1:     NS_RELEASE_THIS();
    1: }
    1: 
    1: 
    1: nsresult NS_NewXMLPrettyPrinter(nsXMLPrettyPrinter** aPrinter)
    1: {
    1:     *aPrinter = new nsXMLPrettyPrinter;
    1:     NS_ENSURE_TRUE(*aPrinter, NS_ERROR_OUT_OF_MEMORY);
    1:     NS_ADDREF(*aPrinter);
    1:     return NS_OK;
    1: }
