 43788: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43788: 
 43788: /**
 43788:  * A class which manages pending restyles.  This handles keeping track
 43788:  * of what nodes restyles need to happen on and so forth.
 43788:  */
 43788: 
 43819: #ifndef mozilla_css_RestyleTracker_h
 43819: #define mozilla_css_RestyleTracker_h
 43819: 
 43788: #include "mozilla/dom/Element.h"
 43788: #include "nsDataHashtable.h"
 43792: #include "nsIFrame.h"
 43788: 
 43788: class nsCSSFrameConstructor;
 43788: 
 43788: namespace mozilla {
 43788: namespace css {
 43788: 
 43788: class RestyleTracker {
 43788: public:
 43788:   typedef mozilla::dom::Element Element;
 43788: 
108991:   RestyleTracker(uint32_t aRestyleBits,
 43788:                  nsCSSFrameConstructor* aFrameConstructor) :
 43792:     mRestyleBits(aRestyleBits), mFrameConstructor(aFrameConstructor),
 80486:     mHaveLaterSiblingRestyles(false)
 43788:   {
 43788:     NS_PRECONDITION((mRestyleBits & ~ELEMENT_ALL_RESTYLE_FLAGS) == 0,
 43788:                     "Why do we have these bits set?");
 43788:     NS_PRECONDITION((mRestyleBits & ELEMENT_PENDING_RESTYLE_FLAGS) != 0,
 43788:                     "Must have a restyle flag");
 43788:     NS_PRECONDITION((mRestyleBits & ELEMENT_PENDING_RESTYLE_FLAGS) !=
 43788:                       ELEMENT_PENDING_RESTYLE_FLAGS,
 43788:                     "Shouldn't have both restyle flags set");
 43788:     NS_PRECONDITION((mRestyleBits & ~ELEMENT_PENDING_RESTYLE_FLAGS) != 0,
 43788:                     "Must have root flag");
 43788:     NS_PRECONDITION((mRestyleBits & ~ELEMENT_PENDING_RESTYLE_FLAGS) !=
 43788:                     (ELEMENT_ALL_RESTYLE_FLAGS & ~ELEMENT_PENDING_RESTYLE_FLAGS),
 43788:                     "Shouldn't have both root flags");
 43788:   }
 43788: 
 98908:   void Init() {
 98908:     mPendingRestyles.Init();
 43788:   }
 43788: 
108991:   uint32_t Count() const {
 43788:     return mPendingRestyles.Count();
 43788:   }
 43788: 
 43788:   /**
 43792:    * Add a restyle for the given element to the tracker.  Returns true
 43792:    * if the element already had eRestyle_LaterSiblings set on it.
 43788:    */
 79445:   bool AddPendingRestyle(Element* aElement, nsRestyleHint aRestyleHint,
 43792:                            nsChangeHint aMinChangeHint);
 43788: 
 43788:   /**
 43788:    * Process the restyles we've been tracking.
 43788:    */
 84595:   void ProcessRestyles() {
 84595:     // Fast-path the common case (esp. for the animation restyle
 84595:     // tracker) of not having anything to do.
 84595:     if (mPendingRestyles.Count()) {
 84595:       DoProcessRestyles();
 84595:     }
 84595:   }
 43788: 
 43792:   // Return our ELEMENT_HAS_PENDING_(ANIMATION_)RESTYLE bit
108991:   uint32_t RestyleBit() const {
 43792:     return mRestyleBits & ELEMENT_PENDING_RESTYLE_FLAGS;
 43792:   }
 43792: 
 43792:   // Return our ELEMENT_IS_POTENTIAL_(ANIMATION_)RESTYLE_ROOT bit
108991:   uint32_t RootBit() const {
 43792:     return mRestyleBits & ~ELEMENT_PENDING_RESTYLE_FLAGS;
 43792:   }
 43792:   
 43788:   struct RestyleData {
 43788:     nsRestyleHint mRestyleHint;  // What we want to restyle
 43788:     nsChangeHint  mChangeHint;   // The minimal change hint for "self"
 43788:   };
 43788: 
 43792:   /**
 43792:    * If the given Element has a restyle pending for it, return the
 43792:    * relevant restyle data.  This function will clear everything other
 43792:    * than a possible eRestyle_LaterSiblings hint for aElement out of
 43792:    * our hashtable.  The returned aData will never have an
 43792:    * eRestyle_LaterSiblings hint in it.
 43792:    *
 43792:    * The return value indicates whether any restyle data was found for
 43792:    * the element.  If false is returned, then the state of *aData is
 43792:    * undefined.
 43792:    */
 79445:   bool GetRestyleData(Element* aElement, RestyleData* aData);
 43792: 
 43792:   /**
 43792:    * The document we're associated with.
 43792:    */
 43792:   inline nsIDocument* Document() const;
 43792: 
 43788:   struct RestyleEnumerateData : public RestyleData {
 48449:     nsRefPtr<Element> mElement;
 43788:   };
 43788: 
 43788: private:
 43791:   /**
 43792:    * Handle a single mPendingRestyles entry.  aRestyleHint must not
 43792:    * include eRestyle_LaterSiblings; that needs to be dealt with
 43792:    * before calling this function.
 43791:    */
 43789:   inline void ProcessOneRestyle(Element* aElement,
 43789:                                 nsRestyleHint aRestyleHint,
123378:                                 nsChangeHint aChangeHint);
 43789: 
 84595:   /**
 84595:    * The guts of our restyle processing.
 84595:    */
 84595:   void DoProcessRestyles();
 84595: 
 43788:   typedef nsDataHashtable<nsISupportsHashKey, RestyleData> PendingRestyleTable;
 43792:   typedef nsAutoTArray< nsRefPtr<Element>, 32> RestyleRootArray;
 43788:   // Our restyle bits.  These will be a subset of ELEMENT_ALL_RESTYLE_FLAGS, and
 43788:   // will include one flag from ELEMENT_PENDING_RESTYLE_FLAGS and one flag
 43788:   // that's not in ELEMENT_PENDING_RESTYLE_FLAGS.
108991:   uint32_t mRestyleBits;
 43788:   nsCSSFrameConstructor* mFrameConstructor; // Owns us
 43792:   // A hashtable that maps elements to RestyleData structs.  The
 43792:   // values only make sense if the element's current document is our
 43792:   // document and it has our RestyleBit() flag set.  In particular,
 43792:   // said bit might not be set if the element had a restyle posted and
 43792:   // then was moved around in the DOM.
 43788:   PendingRestyleTable mPendingRestyles;
 43792:   // An array that keeps track of our possible restyle roots.  This
 43792:   // maintains the invariant that if A and B are both restyle roots
 43792:   // and A is an ancestor of B then A will come after B in the array.
 43792:   // We maintain this invariant by checking whether an element has an
 43792:   // ancestor with the restyle root bit set before appending it to the
 43792:   // array.
 43792:   RestyleRootArray mRestyleRoots;
 43792:   // True if we have some entries with the eRestyle_LaterSiblings
 43792:   // flag.  We need this to avoid enumerating the hashtable looking
 43792:   // for such entries when we can't possibly have any.
 79445:   bool mHaveLaterSiblingRestyles;
 43788: };
 43788: 
 79445: inline bool RestyleTracker::AddPendingRestyle(Element* aElement,
 43788:                                                 nsRestyleHint aRestyleHint,
 43788:                                                 nsChangeHint aMinChangeHint)
 43788: {
 43788:   RestyleData existingData;
 43788:   existingData.mRestyleHint = nsRestyleHint(0);
 43788:   existingData.mChangeHint = NS_STYLE_HINT_NONE;
 43788: 
 43792:   // Check the RestyleBit() flag before doing the hashtable Get, since
 43792:   // it's possible that the data in the hashtable isn't actually
 43792:   // relevant anymore (if the flag is not set).
 43792:   if (aElement->HasFlag(RestyleBit())) {
 43788:     mPendingRestyles.Get(aElement, &existingData);
 43792:   } else {
 43792:     aElement->SetFlags(RestyleBit());
 43792:   }
 43788: 
 79445:   bool hadRestyleLaterSiblings =
 43792:     (existingData.mRestyleHint & eRestyle_LaterSiblings) != 0;
 43788:   existingData.mRestyleHint =
 43792:     nsRestyleHint(existingData.mRestyleHint | aRestyleHint);
 43788:   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
 43788: 
 43788:   mPendingRestyles.Put(aElement, existingData);
 43792: 
 43792:   // We can only treat this element as a restyle root if we would
 43792:   // actually restyle its descendants (so either call
 43792:   // ReResolveStyleContext on it or just reframe it).
 43794:   if ((aRestyleHint & (eRestyle_Self | eRestyle_Subtree)) ||
 43792:       (aMinChangeHint & nsChangeHint_ReconstructFrame)) {
 43792:     for (const Element* cur = aElement; !cur->HasFlag(RootBit()); ) {
 43792:       nsIContent* parent = cur->GetFlattenedTreeParent();
 43792:       // Stop if we have no parent or the parent is not an element or
 43792:       // we're part of the viewport scrollbars (because those are not
 43792:       // frametree descendants of the primary frame of the root
 43792:       // element).
 43792:       // XXXbz maybe the primary frame of the root should be the root scrollframe?
 43792:       if (!parent || !parent->IsElement() ||
 43792:           // If we've hit the root via a native anonymous kid and that
 43792:           // this native anonymous kid is not obviously a descendant
 43792:           // of the root's primary frame, assume we're under the root
 43792:           // scrollbars.  Since those don't get reresolved when
 43792:           // reresolving the root, we need to make sure to add the
 43792:           // element to mRestyleRoots.
 43792:           (cur->IsInNativeAnonymousSubtree() && !parent->GetParent() &&
 43792:            cur->GetPrimaryFrame() &&
 43792:            cur->GetPrimaryFrame()->GetParent() != parent->GetPrimaryFrame())) {
 43792:         mRestyleRoots.AppendElement(aElement);
 43792:         break;
 43792:       }
 43792:       cur = parent->AsElement();
 43792:     }
 43792:     // At this point some ancestor of aElement (possibly aElement
 43792:     // itself) is in mRestyleRoots.  Set the root bit on aElement, to
 43792:     // speed up searching for an existing root on its descendants.
 43792:     aElement->SetFlags(RootBit());
 43792:   }
 43792: 
 43792:   mHaveLaterSiblingRestyles =
 43792:     mHaveLaterSiblingRestyles || (aRestyleHint & eRestyle_LaterSiblings) != 0;
 43792:   return hadRestyleLaterSiblings;
 43788: }
 43788: 
 43788: } // namespace css
 43815: } // namespace mozilla
 43788: 
 43788: #endif /* mozilla_css_RestyleTracker_h */
