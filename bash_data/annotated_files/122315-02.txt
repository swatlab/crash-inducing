     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* utility functions for drawing borders and backgrounds */
     1: 
     1: #ifndef nsCSSRendering_h___
     1: #define nsCSSRendering_h___
     1: 
 11780: #include "nsStyleConsts.h"
 19732: #include "gfxBlur.h"
  4302: #include "gfxContext.h"
 15339: #include "gfxImageSurface.h"
 97536: #include "nsLayoutUtils.h"
 19732: 
     1: struct nsPoint;
     1: class nsStyleContext;
     1: class nsPresContext;
 68487: class nsRenderingContext;
     1: 
 97536: /**
 97536:  * This is a small wrapper class to encapsulate image drawing that can draw an
 97536:  * nsStyleImage image, which may internally be a real image, a sub image, or a
 97536:  * CSS gradient.
 97536:  *
 97536:  * @note Always call the member functions in the order of PrepareImage(),
 97536:  * ComputeSize(), and Draw().
 97536:  */
 97536: class nsImageRenderer {
 97536: public:
 97536:   typedef mozilla::layers::ImageContainer ImageContainer;
 97536: 
 97536:   enum {
 97536:     FLAG_SYNC_DECODE_IMAGES = 0x01
 97536:   };
108991:   nsImageRenderer(nsIFrame* aForFrame, const nsStyleImage* aImage, uint32_t aFlags);
 97536:   ~nsImageRenderer();
 97536:   /**
 97536:    * Populates member variables to get ready for rendering.
 97536:    * @return true iff the image is ready, and there is at least a pixel to
 97536:    * draw.
 97536:    */
 97536:   bool PrepareImage();
 97536:   /**
 97536:    * @return the image size in appunits when rendered, after accounting for the
 97536:    * background positioning area, background-size, and the image's intrinsic
 97536:    * dimensions (if any).
 97536:    */
 97536:   nsSize ComputeSize(const nsStyleBackground::Size& aLayerSize,
 97536:                      const nsSize& aBgPositioningArea);
 97536:   /**
 97536:    * Draws the image to the target rendering context.
 97536:    * @see nsLayoutUtils::DrawImage() for other parameters
 97536:    */
 97536:   void Draw(nsPresContext*       aPresContext,
 97536:             nsRenderingContext& aRenderingContext,
 97536:             const nsRect&        aDest,
 97536:             const nsRect&        aFill,
 97536:             const nsPoint&       aAnchor,
 97536:             const nsRect&        aDirty);
 97536: 
 97536: 
 97536:   bool IsRasterImage();
 97536:   already_AddRefed<ImageContainer> GetContainer();
 97536: private:
 97536:   /*
 97536:    * Compute the "unscaled" dimensions of the image in aUnscaled{Width,Height}
 97536:    * and aRatio.  Whether the image has a height and width are indicated by
 97536:    * aHaveWidth and aHaveHeight.  If the image doesn't have a ratio, aRatio will
 97536:    * be (0, 0).
 97536:    */
 97536:   void ComputeUnscaledDimensions(const nsSize& aBgPositioningArea,
 97536:                                  nscoord& aUnscaledWidth, bool& aHaveWidth,
 97536:                                  nscoord& aUnscaledHeight, bool& aHaveHeight,
 97536:                                  nsSize& aRatio);
 97536: 
 97536:   /*
 97536:    * Using the previously-computed unscaled width and height (if each are
 97536:    * valid, as indicated by aHaveWidth/aHaveHeight), compute the size at which
 97536:    * the image should actually render.
 97536:    */
 97536:   nsSize
 97536:   ComputeDrawnSize(const nsStyleBackground::Size& aLayerSize,
 97536:                    const nsSize& aBgPositioningArea,
 97536:                    nscoord aUnscaledWidth, bool aHaveWidth,
 97536:                    nscoord aUnscaledHeight, bool aHaveHeight,
 97536:                    const nsSize& aIntrinsicRatio);
 97536: 
 97536:   nsIFrame*                 mForFrame;
 97536:   const nsStyleImage*       mImage;
 97536:   nsStyleImageType          mType;
 97536:   nsCOMPtr<imgIContainer>   mImageContainer;
 97536:   nsRefPtr<nsStyleGradient> mGradientData;
 97536:   nsIFrame*                 mPaintServerFrame;
 97536:   nsLayoutUtils::SurfaceFromElementResult mImageElementSurface;
 97536:   bool                      mIsReady;
 97536:   nsSize                    mSize; // unscaled size of the image, in app units
108991:   uint32_t                  mFlags;
 97536: };
 97536: 
 97536: /**
 97536:  * A struct representing all the information needed to paint a background
 97536:  * image to some target, taking into account all CSS background-* properties.
 97536:  * See PrepareBackgroundLayer.
 97536:  */
 97536: struct nsBackgroundLayerState {
 97536:   /**
 97536:    * @param aFlags some combination of nsCSSRendering::PAINTBG_* flags
 97536:    */
108991:   nsBackgroundLayerState(nsIFrame* aForFrame, const nsStyleImage* aImage, uint32_t aFlags)
 97536:     : mImageRenderer(aForFrame, aImage, aFlags) {}
 97536: 
 97536:   /**
 97536:    * The nsImageRenderer that will be used to draw the background.
 97536:    */
 97536:   nsImageRenderer mImageRenderer;
 97536:   /**
 97536:    * A rectangle that one copy of the image tile is mapped onto. Same
 97536:    * coordinate system as aBorderArea/aBGClipRect passed into
 97536:    * PrepareBackgroundLayer.
 97536:    */
 97536:   nsRect mDestArea;
 97536:   /**
 97536:    * The actual rectangle that should be filled with (complete or partial)
 97536:    * image tiles. Same coordinate system as aBorderArea/aBGClipRect passed into
 97536:    * PrepareBackgroundLayer.
 97536:    */
 97536:   nsRect mFillArea;
 97536:   /**
 97536:    * The anchor point that should be snapped to a pixel corner. Same
 97536:    * coordinate system as aBorderArea/aBGClipRect passed into
 97536:    * PrepareBackgroundLayer.
 97536:    */
 97536:   nsPoint mAnchor;
 97536: };
 97536: 
 19707: struct nsCSSRendering {
     1:   /**
     1:    * Initialize any static variables used by nsCSSRendering.
     1:    */
 71172:   static void Init();
     1:   
     1:   /**
     1:    * Clean up any static variables used by nsCSSRendering.
     1:    */
     1:   static void Shutdown();
     1:   
 24818:   static void PaintBoxShadowInner(nsPresContext* aPresContext,
 68481:                                   nsRenderingContext& aRenderingContext,
 15700:                                   nsIFrame* aForFrame,
 24818:                                   const nsRect& aFrameArea,
 24818:                                   const nsRect& aDirtyRect);
 24818: 
 24818:   static void PaintBoxShadowOuter(nsPresContext* aPresContext,
 68481:                                   nsRenderingContext& aRenderingContext,
 24818:                                   nsIFrame* aForFrame,
 24818:                                   const nsRect& aFrameArea,
 22183:                                   const nsRect& aDirtyRect);
 15700: 
 52134:   static void ComputePixelRadii(const nscoord *aAppUnitsRadii,
 52134:                                 nscoord aAppUnitsPerPixel,
 52134:                                 gfxCornerSizes *oBorderRadii);
 52134: 
     1:   /**
     1:    * Render the border for an element using css rendering rules
     1:    * for borders. aSkipSides is a bitmask of the sides to skip
     1:    * when rendering. If 0 then no sides are skipped.
     1:    */
     1:   static void PaintBorder(nsPresContext* aPresContext,
 68481:                           nsRenderingContext& aRenderingContext,
     1:                           nsIFrame* aForFrame,
     1:                           const nsRect& aDirtyRect,
     1:                           const nsRect& aBorderArea,
 40180:                           nsStyleContext* aStyleContext,
107846:                           int aSkipSides = 0);
 40180: 
 40180:   /**
 40180:    * Like PaintBorder, but taking an nsStyleBorder argument instead of
 40180:    * getting it from aStyleContext.
 40180:    */
 40180:   static void PaintBorderWithStyleBorder(nsPresContext* aPresContext,
 68481:                                          nsRenderingContext& aRenderingContext,
 40180:                                          nsIFrame* aForFrame,
 40180:                                          const nsRect& aDirtyRect,
 40180:                                          const nsRect& aBorderArea,
     1:                                          const nsStyleBorder& aBorderStyle,
     1:                                          nsStyleContext* aStyleContext,
107846:                                          int aSkipSides = 0);
     1: 
 40180: 
     1:   /**
     1:    * Render the outline for an element using css rendering rules
     1:    * for borders. aSkipSides is a bitmask of the sides to skip
     1:    * when rendering. If 0 then no sides are skipped.
     1:    */
     1:   static void PaintOutline(nsPresContext* aPresContext,
 68481:                           nsRenderingContext& aRenderingContext,
     1:                           nsIFrame* aForFrame,
     1:                           const nsRect& aDirtyRect,
     1:                           const nsRect& aBorderArea,
 16424:                           nsStyleContext* aStyleContext);
 16424: 
 16424:   /**
 16424:    * Render keyboard focus on an element.
 16424:    * |aFocusRect| is the outer rectangle of the focused element.
 16424:    * Uses a fixed style equivalent to "1px dotted |aColor|".
 16424:    * Not used for controls, because the native theme may differ.
 16424:    */
 16424:   static void PaintFocus(nsPresContext* aPresContext,
 68481:                          nsRenderingContext& aRenderingContext,
 16424:                          const nsRect& aFocusRect,
 16424:                          nscolor aColor);
     1: 
     1:   /**
 30993:    * Render a gradient for an element.
 30993:    */
 30993:   static void PaintGradient(nsPresContext* aPresContext,
 68481:                             nsRenderingContext& aRenderingContext,
 30993:                             nsStyleGradient* aGradient,
 30993:                             const nsRect& aDirtyRect,
 30993:                             const nsRect& aOneCellArea,
 34476:                             const nsRect& aFillArea);
 30993: 
 30993:   /**
 35300:    * Find the frame whose background style should be used to draw the
 35300:    * canvas background. aForFrame must be the frame for the root element
 35300:    * whose background style should be used. This function will return
 35300:    * aForFrame unless the <body> background should be propagated, in
 35300:    * which case we return the frame associated with the <body>'s background.
 27185:    */
 35300:   static nsIFrame* FindBackgroundStyleFrame(nsIFrame* aForFrame);
 27185: 
 27185:   /**
 80486:    * @return true if |aFrame| is a canvas frame, in the CSS sense.
 25022:    */
 79445:   static bool IsCanvasFrame(nsIFrame* aFrame);
 25022: 
 25022:   /**
 40177:    * Fill in an aBackgroundSC to be used to paint the background
 25022:    * for an element.  This applies the rules for propagating
     1:    * backgrounds between BODY, the root element, and the canvas.
 80486:    * @return true if there is some meaningful background.
     1:    */
 79445:   static bool FindBackground(nsPresContext* aPresContext,
     1:                                nsIFrame* aForFrame,
 40177:                                nsStyleContext** aBackgroundSC);
 25022: 
 25022:   /**
 25022:    * As FindBackground, but the passed-in frame is known to be a root frame
 25022:    * (returned from nsCSSFrameConstructor::GetRootElementStyleFrame())
 25022:    * and there is always some meaningful background returned.
 25022:    */
 40177:   static nsStyleContext* FindRootFrameBackground(nsIFrame* aForFrame);
     1: 
     1:   /**
 34422:    * Returns background style information for the canvas.
 34422:    *
 34422:    * @param aForFrame
 34422:    *   the frame used to represent the canvas, in the CSS sense (i.e.
 34422:    *   nsCSSRendering::IsCanvasFrame(aForFrame) must be true)
 34422:    * @param aRootElementFrame
 34422:    *   the frame representing the root element of the document
 34422:    * @param aBackground
 34422:    *   contains background style information for the canvas on return
 34422:    */
 40177:   static nsStyleContext*
 34422:   FindCanvasBackground(nsIFrame* aForFrame, nsIFrame* aRootElementFrame)
 34422:   {
 34422:     NS_ABORT_IF_FALSE(IsCanvasFrame(aForFrame), "not a canvas frame");
 34422:     if (aRootElementFrame)
 34422:       return FindRootFrameBackground(aRootElementFrame);
 34422: 
 34422:     // This should always give transparent, so we'll fill it in with the
 34422:     // default color if needed.  This seems to happen a bit while a page is
 34422:     // being loaded.
 40177:     return aForFrame->GetStyleContext();
 34422:   }
 34422: 
 34422:   /**
 40588:    * Find a frame which draws a non-transparent background,
 23494:    * for various table-related and HR-related backwards-compatibility hacks.
 40588:    * This function will also stop if it finds themed frame which might draw
 40588:    * background.
 23494:    *
 23494:    * Be very hesitant if you're considering calling this function -- it's
 23494:    * usually not what you want.
     1:    */
 40588:   static nsIFrame*
 40588:   FindNonTransparentBackgroundFrame(nsIFrame* aFrame,
 79445:                                     bool aStartAtParent = false);
     1: 
     1:   /**
 29987:    * Determine the background color to draw taking into account print settings.
 29987:    */
 29987:   static nscolor
 29987:   DetermineBackgroundColor(nsPresContext* aPresContext,
 40177:                            nsStyleContext* aStyleContext,
 97536:                            nsIFrame* aFrame,
 97536:                            bool& aDrawBackgroundImage,
 97536:                            bool& aDrawBackgroundColor);
 97536: 
122080:   static nsRect
122080:   ComputeBackgroundPositioningArea(nsPresContext* aPresContext,
122080:                                    nsIFrame* aForFrame,
122080:                                    const nsRect& aBorderArea,
122080:                                    const nsStyleBackground& aBackground,
122080:                                    const nsStyleBackground::Layer& aLayer,
122080:                                    nsIFrame** aAttachedToFrame);
122080: 
 97536:   static nsBackgroundLayerState
 97536:   PrepareBackgroundLayer(nsPresContext* aPresContext,
 97536:                          nsIFrame* aForFrame,
108991:                          uint32_t aFlags,
 97536:                          const nsRect& aBorderArea,
 97536:                          const nsRect& aBGClipRect,
 97536:                          const nsStyleBackground& aBackground,
 97536:                          const nsStyleBackground::Layer& aLayer);
 29987: 
 29987:   /**
     1:    * Render the background for an element using css rendering rules
     1:    * for backgrounds.
     1:    */
 28800:   enum {
 28800:     /**
 28800:      * When this flag is passed, the element's nsDisplayBorder will be
 28800:      * painted immediately on top of this background.
 28800:      */
 32425:     PAINTBG_WILL_PAINT_BORDER = 0x01,
 32425:     /**
 56434:      * When this flag is passed, images are synchronously decoded.
 56434:      */
 56434:     PAINTBG_SYNC_DECODE_IMAGES = 0x02,
 56434:     /**
 56434:      * When this flag is passed, painting will go to the screen so we can
 56434:      * take advantage of the fact that it will be clipped to the viewport.
 56434:      */
 56434:     PAINTBG_TO_WINDOW = 0x04
 28800:   };
     1:   static void PaintBackground(nsPresContext* aPresContext,
 68481:                               nsRenderingContext& aRenderingContext,
     1:                               nsIFrame* aForFrame,
     1:                               const nsRect& aDirtyRect,
     1:                               const nsRect& aBorderArea,
108991:                               uint32_t aFlags,
113850:                               nsRect* aBGClipRect = nullptr,
113850:                               int32_t aLayer = -1);
     1:  
121099:   static void PaintBackgroundColor(nsPresContext* aPresContext,
121099:                                    nsRenderingContext& aRenderingContext,
121099:                                    nsIFrame* aForFrame,
121099:                                    const nsRect& aDirtyRect,
121099:                                    const nsRect& aBorderArea,
121099:                                    uint32_t aFlags);
121099: 
     1:   /**
 19614:    * Same as |PaintBackground|, except using the provided style structs.
 19614:    * This short-circuits the code that ensures that the root element's
     1:    * background is drawn on the canvas.
113850:    * The aLayer parameter allows you to paint a single layer of the background.
113850:    * The default value for aLayer, -1, means that all layers will be painted.
113850:    * The background color will only be painted if the back-most layer is also
113850:    * being painted.
     1:    */
     1:   static void PaintBackgroundWithSC(nsPresContext* aPresContext,
 68481:                                     nsRenderingContext& aRenderingContext,
     1:                                     nsIFrame* aForFrame,
     1:                                     const nsRect& aDirtyRect,
     1:                                     const nsRect& aBorderArea,
 40177:                                     nsStyleContext *aStyleContext,
     1:                                     const nsStyleBorder& aBorder,
108991:                                     uint32_t aFlags,
113850:                                     nsRect* aBGClipRect = nullptr,
113850:                                     int32_t aLayer = -1);
     1: 
121099:   static void PaintBackgroundColorWithSC(nsPresContext* aPresContext,
121099:                                          nsRenderingContext& aRenderingContext,
121099:                                          nsIFrame* aForFrame,
121099:                                          const nsRect& aDirtyRect,
121099:                                          const nsRect& aBorderArea,
121099:                                          nsStyleContext *aStyleContext,
121099:                                          const nsStyleBorder& aBorder,
121099:                                          uint32_t aFlags);
     1:   /**
 59780:    * Returns the rectangle covered by the given background layer image, taking
 59780:    * into account background positioning, sizing, and repetition, but not
 59780:    * clipping.
 59780:    */
 59780:   static nsRect GetBackgroundLayerRect(nsPresContext* aPresContext,
 59780:                                        nsIFrame* aForFrame,
 59780:                                        const nsRect& aBorderArea,
 59780:                                        const nsStyleBackground& aBackground,
 59780:                                        const nsStyleBackground::Layer& aLayer);
 59780: 
 59780:   /**
122315:    * Called when we start creating a display list. The frame tree will not
122315:    * change until a matching EndFrameTreeLocked is called.
     1:    */
122315:   static void BeginFrameTreesLocked();
122315:   /**
122315:    * Called when we've finished using a display list. When all
122315:    * BeginFrameTreeLocked calls have been balanced by an EndFrameTreeLocked,
122315:    * the frame tree may start changing again.
122315:    */
122315:   static void EndFrameTreesLocked();
     1: 
 19707:   // Draw a border segment in the table collapsing border model without
 19707:   // beveling corners
 68481:   static void DrawTableBorderSegment(nsRenderingContext& aContext,
108991:                                      uint8_t              aBorderStyle,  
     1:                                      nscolor              aBorderColor,
     1:                                      const nsStyleBackground* aBGColor,
     1:                                      const nsRect&        aBorderRect,
108991:                                      int32_t              aAppUnitsPerCSSPixel,
108991:                                      uint8_t              aStartBevelSide = 0,
     1:                                      nscoord              aStartBevelOffset = 0,
108991:                                      uint8_t              aEndBevelSide = 0,
     1:                                      nscoord              aEndBevelOffset = 0);
     1: 
  4302:   /**
  4302:    * Function for painting the decoration lines for the text.
 11780:    * NOTE: aPt, aLineSize, aAscent and aOffset are non-rounded device pixels,
 11780:    *       not app units.
  4302:    *   input:
103580:    *     @param aFrame            the frame which needs the decoration line
  4302:    *     @param aGfxContext
 78406:    *     @param aDirtyRect        no need to paint outside this rect
  4302:    *     @param aColor            the color of the decoration line
  4302:    *     @param aPt               the top/left edge of the text
103580:    *     @param aXInFrame         the distance between aPt.x and left edge of
103580:    *                              aFrame.  If the decoration line is for shadow,
103580:    *                              set the distance between the left edge of
103580:    *                              the aFrame and the position of the text as
103580:    *                              positioned without offset of the shadow.
  4302:    *     @param aLineSize         the width and the height of the decoration
  4302:    *                              line
  4302:    *     @param aAscent           the ascent of the text
  4302:    *     @param aOffset           the offset of the decoration line from
  4302:    *                              the baseline of the text (if the value is
  4302:    *                              positive, the line is lifted up)
  4302:    *     @param aDecoration       which line will be painted. The value can be
 68819:    *                              NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE or
 68819:    *                              NS_STYLE_TEXT_DECORATION_LINE_OVERLINE or
 68819:    *                              NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH.
 64457:    *     @param aStyle            the style of the decoration line such as
 64457:    *                              NS_STYLE_TEXT_DECORATION_STYLE_*.
 26988:    *     @param aDescentLimit     If aDescentLimit is zero or larger and the
 26988:    *                              underline overflows from the descent space,
 26988:    *                              the underline should be lifted up as far as
 26988:    *                              possible.  Note that this does not mean the
 26988:    *                              underline never overflows from this
 26988:    *                              limitation.  Because if the underline is
 26988:    *                              positioned to the baseline or upper, it causes
 26988:    *                              unreadability.  Note that if this is zero
 26988:    *                              or larger, the underline rect may be shrunken
 26988:    *                              if it's possible.  Therefore, this value is
 26988:    *                              used for strikeout line and overline too.
  4302:    */
103580:   static void PaintDecorationLine(nsIFrame* aFrame,
103580:                                   gfxContext* aGfxContext,
 78406:                                   const gfxRect& aDirtyRect,
  4302:                                   const nscolor aColor,
  4302:                                   const gfxPoint& aPt,
103580:                                   const gfxFloat aXInFrame,
  4302:                                   const gfxSize& aLineSize,
  4302:                                   const gfxFloat aAscent,
  4302:                                   const gfxFloat aOffset,
108991:                                   const uint8_t aDecoration,
108991:                                   const uint8_t aStyle,
 26988:                                   const gfxFloat aDescentLimit = -1.0);
  4302: 
 11780:   /**
107803:    * Adds a path corresponding to the outline of the decoration line to
107803:    * the specified context.  Arguments have the same meaning as for
107803:    * PaintDecorationLine.  Currently this only works for solid
107803:    * decorations; for other decoration styles, an empty path is added
107803:    * to the context.
107803:    */
107803:   static void DecorationLineToPath(nsIFrame* aFrame,
107803:                                    gfxContext* aGfxContext,
107803:                                    const gfxRect& aDirtyRect,
107803:                                    const nscolor aColor,
107803:                                    const gfxPoint& aPt,
107803:                                    const gfxFloat aXInFrame,
107803:                                    const gfxSize& aLineSize,
107803:                                    const gfxFloat aAscent,
107803:                                    const gfxFloat aOffset,
108991:                                    const uint8_t aDecoration,
108991:                                    const uint8_t aStyle,
107803:                                    const gfxFloat aDescentLimit = -1.0);
107803: 
107803:   /**
 11780:    * Function for getting the decoration line rect for the text.
 11780:    * NOTE: aLineSize, aAscent and aOffset are non-rounded device pixels,
 11780:    *       not app units.
 11780:    *   input:
 11780:    *     @param aPresContext
 11780:    *     @param aLineSize         the width and the height of the decoration
 11780:    *                              line
 11780:    *     @param aAscent           the ascent of the text
 11780:    *     @param aOffset           the offset of the decoration line from
 11780:    *                              the baseline of the text (if the value is
 11780:    *                              positive, the line is lifted up)
 11780:    *     @param aDecoration       which line will be painted. The value can be
 68819:    *                              NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE or
 68819:    *                              NS_STYLE_TEXT_DECORATION_LINE_OVERLINE or
 68819:    *                              NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH.
 64457:    *     @param aStyle            the style of the decoration line such as
 64457:    *                              NS_STYLE_TEXT_DECORATION_STYLE_*.
 26988:    *     @param aDescentLimit     If aDescentLimit is zero or larger and the
 26988:    *                              underline overflows from the descent space,
 26988:    *                              the underline should be lifted up as far as
 26988:    *                              possible.  Note that this does not mean the
 26988:    *                              underline never overflows from this
 26988:    *                              limitation.  Because if the underline is
 26988:    *                              positioned to the baseline or upper, it causes
 26988:    *                              unreadability.  Note that if this is zero
 26988:    *                              or larger, the underline rect may be shrunken
 26988:    *                              if it's possible.  Therefore, this value is
 26988:    *                              used for strikeout line and overline too.
 11780:    *   output:
 11780:    *     @return                  the decoration line rect for the input,
 11780:    *                              the each values are app units.
 11780:    */
 11780:   static nsRect GetTextDecorationRect(nsPresContext* aPresContext,
 11780:                                       const gfxSize& aLineSize,
 11780:                                       const gfxFloat aAscent,
 11780:                                       const gfxFloat aOffset,
108991:                                       const uint8_t aDecoration,
108991:                                       const uint8_t aStyle,
 26988:                                       const gfxFloat aDescentLimit = -1.0);
 26883: 
 26883: protected:
 26883:   static gfxRect GetTextDecorationRectInternal(const gfxPoint& aPt,
 26883:                                                const gfxSize& aLineSize,
 26883:                                                const gfxFloat aAscent,
 26883:                                                const gfxFloat aOffset,
108991:                                                const uint8_t aDecoration,
108991:                                                const uint8_t aStyle,
 26988:                                                const gfxFloat aDscentLimit);
103580: 
103580:   /**
103580:    * Returns inflated rect for painting a decoration line.
103580:    * Complex style decoration lines should be painted from leftmost of nearest
103580:    * ancestor block box because that makes better look of connection of lines
103580:    * for different nodes.  ExpandPaintingRectForDecorationLine() returns
103580:    * a rect for actual painting rect for the clipped rect.
103580:    *
103580:    * input:
103580:    *     @param aFrame            the frame which needs the decoration line.
103580:    *     @param aStyle            the style of the complex decoration line
103580:    *                              NS_STYLE_TEXT_DECORATION_STYLE_DOTTED or
103580:    *                              NS_STYLE_TEXT_DECORATION_STYLE_DASHED or
103580:    *                              NS_STYLE_TEXT_DECORATION_STYLE_WAVY.
103580:    *     @param aClippedRect      the clipped rect for the decoration line.
103580:    *                              in other words, visible area of the line.
103580:    *     @param aXInFrame         the distance between left edge of aFrame and
103580:    *                              aClippedRect.pos.x.
103580:    *     @param aCycleLength      the width of one cycle of the line style.
103580:    */
103580:   static gfxRect ExpandPaintingRectForDecorationLine(
103580:                    nsIFrame* aFrame,
108991:                    const uint8_t aStyle,
103580:                    const gfxRect &aClippedRect,
103580:                    const gfxFloat aXInFrame,
103580:                    const gfxFloat aCycleLength);
     1: };
     1: 
 15339: /*
 15339:  * nsContextBoxBlur
 15339:  * Creates an 8-bit alpha channel context for callers to draw in, blurs the
 15339:  * contents of that context and applies it as a 1-color mask on a
 19732:  * different existing context. Uses gfxAlphaBoxBlur as its back end.
 15339:  *
 19707:  * You must call Init() first to create a suitable temporary surface to draw
 19707:  * on.  You must then draw any desired content onto the given context, then
 19707:  * call DoPaint() to apply the blurred content as a single-color mask. You
 19707:  * can only call Init() once, so objects cannot be reused.
 15339:  *
 15339:  * This is very useful for creating drop shadows or silhouettes.
 15339:  */
 15339: class nsContextBoxBlur {
 15339: public:
 51264:   enum {
 51264:     FORCE_MASK = 0x01
 51264:   };
 15339:   /**
 19707:    * Prepares a gfxContext to draw on. Do not call this twice; if you want
 19707:    * to get the gfxContext again use GetContext().
 15339:    *
 15339:    * @param aRect                The coordinates of the surface to create.
 15339:    *                             All coordinates must be in app units.
 19707:    *                             This must not include the blur radius, pass
 19707:    *                             it as the second parameter and everything
 19707:    *                             is taken care of.
 15339:    *
 15339:    * @param aBlurRadius          The blur radius in app units.
 15339:    *
 19707:    * @param aAppUnitsPerDevPixel The number of app units in a device pixel,
 19707:    *                             for conversion.  Most of the time you'll
 19707:    *                             pass this from the current PresContext if
 19707:    *                             available.
 15339:    *
 19707:    * @param aDestinationCtx      The graphics context to apply the blurred
 19707:    *                             mask to when you call DoPaint(). Make sure
 19707:    *                             it is not destroyed before you call
 19707:    *                             DoPaint(). To set the color of the
 19707:    *                             resulting blurred graphic mask, you must
 19707:    *                             set the color on this context before
 19707:    *                             calling Init().
 15339:    *
 22183:    * @param aDirtyRect           The absolute dirty rect in app units. Used to
 22183:    *                             optimize the temporary surface size and speed up blur.
 22183:    *
 40965:    * @param aSkipRect            An area in device pixels (NOT app units!) to avoid
 40965:    *                             blurring over, to prevent unnecessary work.
 40965:    *                             
 51264:    * @param aFlags               FORCE_MASK to ensure that the content drawn to the
 51264:    *                             returned gfxContext is used as a mask, and not
 51264:    *                             drawn directly to aDestinationCtx.
 51264:    *
 19707:    * @return            A blank 8-bit alpha-channel-only graphics context to
 19707:    *                    draw on, or null on error. Must not be freed. The
 19707:    *                    context has a device offset applied to it given by
 19707:    *                    aRect. This means you can use coordinates as if it
 19707:    *                    were at the desired position at aRect and you don't
 19707:    *                    need to worry about translating any coordinates to
 19707:    *                    draw on this temporary surface.
 15339:    *
 19707:    * If aBlurRadius is 0, the returned context is aDestinationCtx and
 19707:    * DoPaint() does nothing, because no blurring is required. Therefore, you
 19707:    * should prepare the destination context as if you were going to draw
 19707:    * directly on it instead of any temporary surface created in this class.
 15339:    */
 51264:   gfxContext* Init(const nsRect& aRect, nscoord aSpreadRadius,
 51264:                    nscoord aBlurRadius,
108991:                    int32_t aAppUnitsPerDevPixel, gfxContext* aDestinationCtx,
 51264:                    const nsRect& aDirtyRect, const gfxRect* aSkipRect,
108991:                    uint32_t aFlags = 0);
 51264: 
 51264:   /**
 51264:    * Does the actual blurring/spreading. Users of this object *must*
 51264:    * have called Init() first, then have drawn whatever they want to be
 51264:    * blurred onto the internal gfxContext before calling this.
 51264:    */
 51264:   void DoEffects();
 15339:   
 15339:   /**
 15339:    * Does the actual blurring and mask applying. Users of this object *must*
 15339:    * have called Init() first, then have drawn whatever they want to be
 15339:    * blurred onto the internal gfxContext before calling this.
 15339:    */
 15339:   void DoPaint();
 15339: 
 15339:   /**
 19707:    * Gets the internal gfxContext at any time. Must not be freed. Avoid
 19707:    * calling this before calling Init() since the context would not be
 19707:    * constructed at that point.
 15339:    */
 15339:   gfxContext* GetContext();
 15339: 
 52476: 
 52476:   /**
 52476:    * Get the margin associated with the given blur radius, i.e., the
 52476:    * additional area that might be painted as a result of it.  (The
 52476:    * margin for a spread radius is itself, on all sides.)
 52476:    */
 52476:   static nsMargin GetBlurRadiusMargin(nscoord aBlurRadius,
108991:                                       int32_t aAppUnitsPerDevPixel);
 52476: 
 15339: protected:
 19732:   gfxAlphaBoxBlur blur;
 15339:   nsRefPtr<gfxContext> mContext;
 15339:   gfxContext* mDestinationCtx;
 15339: 
 98901:   /* This is true if the blur already has it's content transformed
 98901:    * by mDestinationCtx's transform */
 98901:   bool mPreTransformed;
 98901: 
 15339: };
     1: 
     1: #endif /* nsCSSRendering_h___ */
