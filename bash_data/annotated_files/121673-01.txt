     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsCOMPtr.h" 
     1: #include "nsReadableUtils.h"
     1: #include "nsSimplePageSequence.h"
     1: #include "nsPresContext.h"
 14016: #include "gfxContext.h"
 68481: #include "nsRenderingContext.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIPrintSettings.h"
     1: #include "nsPageFrame.h"
111090: #include "nsSubDocumentFrame.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsRegion.h"
     1: #include "nsCSSFrameConstructor.h"
     1: #include "nsContentUtils.h"
     1: #include "nsDisplayList.h"
 70842: #include "mozilla/Preferences.h"
111090: #include "nsHTMLCanvasFrame.h"
111090: #include "nsHTMLCanvasElement.h"
111090: #include "nsICanvasRenderingContextInternal.h"
     1: 
     1: // DateTime Includes
     1: #include "nsDateTimeFormatCID.h"
     1: 
     1: #define OFFSET_NOT_SET -1
     1: 
     1: // Print Options
     1: #include "nsIPrintOptions.h"
     1: #include "nsGfxCIID.h"
     1: #include "nsIServiceManager.h"
     1: 
 70842: using namespace mozilla;
 70842: 
     1: static const char sPrintOptionsContractID[] = "@mozilla.org/gfx/printsettings-service;1";
     1: 
     1: //
     1: 
     1: #include "prlog.h"
     1: #ifdef PR_LOGGING 
120415: PRLogModuleInfo *
120415: GetLayoutPrintingLog()
120415: {
120415:   static PRLogModuleInfo *sLog;
120415:   if (!sLog)
120415:     sLog = PR_NewLogModule("printing-layout");
120415:   return sLog;
120415: }
120415: #define PR_PL(_p1)  PR_LOG(GetLayoutPrintingLog(), PR_LOG_DEBUG, _p1)
     1: #else
     1: #define PR_PL(_p1)
     1: #endif
     1: 
     1: // This object a shared by all the nsPageFrames 
     1: // parented to a SimplePageSequenceFrame
     1: nsSharedPageData::nsSharedPageData() :
106838:   mDateTimeStr(nullptr),
106838:   mHeadFootFont(nullptr),
106838:   mPageNumFormat(nullptr),
106838:   mPageNumAndTotalsFormat(nullptr),
106838:   mDocTitle(nullptr),
106838:   mDocURL(nullptr),
     1:   mReflowSize(0,0),
     1:   mReflowMargin(0,0,0,0),
     1:   mExtraMargin(0,0,0,0),
     1:   mEdgePaperMargin(0,0,0,0),
     1:   mPageContentXMost(0),
     1:   mPageContentSize(0)
     1: {
     1: }
     1: 
     1: nsSharedPageData::~nsSharedPageData()
     1: {
     1:   nsMemory::Free(mDateTimeStr);
 70018:   delete mHeadFootFont;
     1:   nsMemory::Free(mPageNumFormat);
     1:   nsMemory::Free(mPageNumAndTotalsFormat);
     1:   if (mDocTitle) nsMemory::Free(mDocTitle);
     1:   if (mDocURL) nsMemory::Free(mDocURL);
     1: }
     1: 
     1: nsIFrame*
     1: NS_NewSimplePageSequenceFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsSimplePageSequenceFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsSimplePageSequenceFrame)
 32423: 
     1: nsSimplePageSequenceFrame::nsSimplePageSequenceFrame(nsStyleContext* aContext) :
     1:   nsContainerFrame(aContext),
     1:   mTotalPages(-1),
     1:   mSelectionHeight(-1),
111090:   mYSelOffset(0),
118484:   mCalledBeginPage(false),
118484:   mCurrentCanvasListSetup(false)
     1: {
 50791:   nscoord halfInch = PresContext()->CSSTwipsToAppUnits(NS_INCHES_TO_TWIPS(0.5));
     1:   mMargin.SizeTo(halfInch, halfInch, halfInch, halfInch);
     1: 
     1:   // XXX Unsafe to assume successful allocation
     1:   mPageData = new nsSharedPageData();
 90439:   mPageData->mHeadFootFont =
 90439:     new nsFont(*PresContext()->GetDefaultFont(kGenericFont_serif,
 90439:                                               aContext->GetStyleFont()->mLanguage));
 50791:   mPageData->mHeadFootFont->size = nsPresContext::CSSPointsToAppUnits(10);
     1: 
     1:   nsresult rv;
     1:   mPageData->mPrintOptions = do_GetService(sPrintOptionsContractID, &rv);
     1: 
     1:   // Doing this here so we only have to go get these formats once
 80486:   SetPageNumberFormat("pagenumber",  "%1$d", true);
 80486:   SetPageNumberFormat("pageofpages", "%1$d of %2$d", false);
     1: }
     1: 
     1: nsSimplePageSequenceFrame::~nsSimplePageSequenceFrame()
     1: {
 70018:   delete mPageData;
115858:   ResetPrintCanvasList();
     1: }
     1: 
 23554: NS_QUERYFRAME_HEAD(nsSimplePageSequenceFrame)
 23554:   NS_QUERYFRAME_ENTRY(nsIPageSequenceFrame)
 23554: NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)
     1: 
     1: //----------------------------------------------------------------------
     1: 
 71581: void
 71581: nsSimplePageSequenceFrame::SetDesiredSize(nsHTMLReflowMetrics& aDesiredSize,
 71581:                                           const nsHTMLReflowState& aReflowState,
 71581:                                           nscoord aWidth,
 71581:                                           nscoord aHeight)
 71581: {
 71581:     // Aim to fill the whole size of the document, not only so we
 71581:     // can act as a background in print preview but also handle overflow
 71581:     // in child page frames correctly.
 71581:     // Use availableWidth so we don't cause a needless horizontal scrollbar.
 71581:     aDesiredSize.width = NS_MAX(aReflowState.availableWidth,
 71581:                                 nscoord(aWidth * PresContext()->GetPrintPreviewScale()));
 71581:     aDesiredSize.height = NS_MAX(aReflowState.ComputedHeight(),
 71581:                                  nscoord(aHeight * PresContext()->GetPrintPreviewScale()));
 71581: }
 71581: 
     1: NS_IMETHODIMP
     1: nsSimplePageSequenceFrame::Reflow(nsPresContext*          aPresContext,
     1:                                   nsHTMLReflowMetrics&     aDesiredSize,
     1:                                   const nsHTMLReflowState& aReflowState,
     1:                                   nsReflowStatus&          aStatus)
     1: {
     1:   NS_PRECONDITION(aPresContext->IsRootPaginatedDocument(),
     1:                   "A Page Sequence is only for real pages");
     1:   DO_GLOBAL_REFLOW_COUNT("nsSimplePageSequenceFrame");
     1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
     1:   NS_FRAME_TRACE_REFLOW_IN("nsSimplePageSequenceFrame::Reflow");
     1: 
     1:   aStatus = NS_FRAME_COMPLETE;  // we're always complete
     1: 
   827:   // Don't do incremental reflow until we've taught tables how to do
   827:   // it right in paginated mode.
   827:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
     1:     // Return our desired size
 71581:     SetDesiredSize(aDesiredSize, aReflowState, mSize.width, mSize.height);
 55039:     aDesiredSize.SetOverflowAreasToDesiredBounds();
     1:     FinishAndStoreOverflow(&aDesiredSize);
     1:     return NS_OK;
     1:   }
     1: 
     1:   // See if we can get a Print Settings from the Context
     1:   if (!mPageData->mPrintSettings &&
     1:       aPresContext->Medium() == nsGkAtoms::print) {
     1:       mPageData->mPrintSettings = aPresContext->GetPrintSettings();
     1:   }
     1: 
  8247:   // now get out margins & edges
     1:   if (mPageData->mPrintSettings) {
 23738:     nsIntMargin unwriteableTwips;
 13309:     mPageData->mPrintSettings->GetUnwriteableMarginInTwips(unwriteableTwips);
 13309:     NS_ASSERTION(unwriteableTwips.left  >= 0 && unwriteableTwips.top >= 0 &&
 13309:                  unwriteableTwips.right >= 0 && unwriteableTwips.bottom >= 0,
 13309:                  "Unwriteable twips should be non-negative");
 13309: 
 23738:     nsIntMargin marginTwips;
     1:     mPageData->mPrintSettings->GetMarginInTwips(marginTwips);
 50791:     mMargin = aPresContext->CSSTwipsToAppUnits(marginTwips + unwriteableTwips);
 13309: 
108991:     int16_t printType;
     1:     mPageData->mPrintSettings->GetPrintRange(&printType);
     1:     mPrintRangeType = printType;
  8247: 
 23738:     nsIntMargin edgeTwips;
  8247:     mPageData->mPrintSettings->GetEdgeInTwips(edgeTwips);
  8247: 
 10894:     // sanity check the values. three inches are sometimes needed
108991:     int32_t inchInTwips = NS_INCHES_TO_INT_TWIPS(3.0);
 81029:     edgeTwips.top    = clamped(edgeTwips.top,    0, inchInTwips);
 81029:     edgeTwips.bottom = clamped(edgeTwips.bottom, 0, inchInTwips);
 81029:     edgeTwips.left   = clamped(edgeTwips.left,   0, inchInTwips);
 81029:     edgeTwips.right  = clamped(edgeTwips.right,  0, inchInTwips);
  8247: 
  8247:     mPageData->mEdgePaperMargin =
 50791:       aPresContext->CSSTwipsToAppUnits(edgeTwips + unwriteableTwips);
     1:   }
     1: 
     1:   // *** Special Override ***
     1:   // If this is a sub-sdoc (meaning it doesn't take the whole page)
     1:   // and if this Document is in the upper left hand corner
     1:   // we need to suppress the top margin or it will reflow too small
     1: 
     1:   nsSize pageSize = aPresContext->GetPageSize();
     1: 
     1:   mPageData->mReflowSize = pageSize;
 14531:   // If we're printing a selection, we need to reflow with
 14531:   // unconstrained height, to make sure we'll get to the selection
 14531:   // even if it's beyond the first page of content.
 14531:   if (nsIPrintSettings::kRangeSelection == mPrintRangeType) {
 14531:     mPageData->mReflowSize.height = NS_UNCONSTRAINEDSIZE;
 14531:   }
     1:   mPageData->mReflowMargin = mMargin;
     1: 
     1:   // Compute the size of each page and the x coordinate that each page will
     1:   // be placed at
 32531:   nscoord extraThreshold = NS_MAX(pageSize.width, pageSize.height)/10;
108991:   int32_t gapInTwips = Preferences::GetInt("print.print_extra_margin");
 32531:   gapInTwips = NS_MAX(0, gapInTwips);
     1: 
 50791:   nscoord extraGap = aPresContext->CSSTwipsToAppUnits(gapInTwips);
 32531:   extraGap = NS_MIN(extraGap, extraThreshold); // clamp to 1/10 of the largest dim of the page
     1: 
 71581:   nsMargin extraMargin(0,0,0,0);
 71581:   if (aPresContext->IsScreen()) {
 71581:     extraMargin.SizeTo(extraGap, extraGap, extraGap, extraGap);
  8247:   }
     1: 
     1:   mPageData->mExtraMargin = extraMargin;
     1: 
 71581:   // We use the CSS "margin" property on the -moz-page pseudoelement
 71581:   // to determine the space between each page in print preview.
 71581:   // Keep a running y-offset for each page.
 71581:   nscoord y = 0;
 71581:   nscoord maxXMost = 0;
     1: 
 71581:   nsSize availSize(pageSize.width + extraMargin.LeftRight(),
 71581:                    pageSize.height + extraMargin.TopBottom());
     1: 
     1:   // Tile the pages vertically
     1:   nsHTMLReflowMetrics kidSize;
106838:   for (nsIFrame* kidFrame = mFrames.FirstChild(); nullptr != kidFrame; ) {
 11441:     // Set the shared data into the page frame before reflow
 11441:     nsPageFrame * pf = static_cast<nsPageFrame*>(kidFrame);
 11441:     pf->SetSharedPageData(mPageData);
 11441: 
     1:     // Reflow the page
     1:     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, kidFrame,
     1:                                      availSize);
     1:     nsReflowStatus  status;
     1: 
     1:     kidReflowState.SetComputedWidth(kidReflowState.availableWidth);
  4166:     //kidReflowState.SetComputedHeight(kidReflowState.availableHeight);
     1:     PR_PL(("AV W: %d   H: %d\n", kidReflowState.availableWidth, kidReflowState.availableHeight));
     1: 
 71581:     nsMargin pageCSSMargin = kidReflowState.mComputedMargin;
 71581:     y += pageCSSMargin.top;
 71581:     const nscoord x = pageCSSMargin.left;
 71581: 
     1:     // Place and size the page. If the page is narrower than our
     1:     // max width then center it horizontally
     1:     ReflowChild(kidFrame, aPresContext, kidSize, kidReflowState, x, y, 0, status);
     1: 
106838:     FinishReflowChild(kidFrame, aPresContext, nullptr, kidSize, x, y, 0);
     1:     y += kidSize.height;
 71581:     y += pageCSSMargin.bottom;
     1: 
 71581:     maxXMost = NS_MAX(maxXMost, x + kidSize.width + pageCSSMargin.right);
     1: 
     1:     // Is the page complete?
     1:     nsIFrame* kidNextInFlow = kidFrame->GetNextInFlow();
     1: 
  6521:     if (NS_FRAME_IS_FULLY_COMPLETE(status)) {
 32841:       NS_ASSERTION(!kidNextInFlow, "bad child flow list");
 32841:     } else if (!kidNextInFlow) {
     1:       // The page isn't complete and it doesn't have a next-in-flow, so
 32841:       // create a continuing page.
     1:       nsIFrame* continuingPage;
 32841:       nsresult rv = aPresContext->PresShell()->FrameConstructor()->
 32841:         CreateContinuingFrame(aPresContext, kidFrame, this, &continuingPage);
     1:       if (NS_FAILED(rv)) {
     1:         break;
     1:       }
     1: 
     1:       // Add it to our child list
106838:       mFrames.InsertFrame(nullptr, kidFrame, continuingPage);
     1:     }
     1: 
     1:     // Get the next page
     1:     kidFrame = kidFrame->GetNextSibling();
     1:   }
     1: 
     1:   // Get Total Page Count
     1:   nsIFrame* page;
108991:   int32_t pageTot = 0;
     1:   for (page = mFrames.FirstChild(); page; page = page->GetNextSibling()) {
     1:     pageTot++;
     1:   }
     1: 
     1:   // Set Page Number Info
108991:   int32_t pageNum = 1;
     1:   for (page = mFrames.FirstChild(); page; page = page->GetNextSibling()) {
  3233:     nsPageFrame * pf = static_cast<nsPageFrame*>(page);
106838:     if (pf != nullptr) {
     1:       pf->SetPageNumInfo(pageNum, pageTot);
     1:     }
     1:     pageNum++;
     1:   }
     1: 
     1:   // Create current Date/Time String
     1:   if (!mDateFormatter)
     1:     mDateFormatter = do_CreateInstance(NS_DATETIMEFORMAT_CONTRACTID);
 20187: 
     1:   NS_ENSURE_TRUE(mDateFormatter, NS_ERROR_FAILURE);
     1: 
     1:   nsAutoString formattedDateString;
     1:   time_t ltime;
     1:   time( &ltime );
106838:   if (NS_SUCCEEDED(mDateFormatter->FormatTime(nullptr /* nsILocale* locale */,
     1:                                               kDateFormatShort,
     1:                                               kTimeFormatNoSeconds,
     1:                                               ltime,
     1:                                               formattedDateString))) {
     1:     PRUnichar * uStr = ToNewUnicode(formattedDateString);
     1:     SetDateTimeStr(uStr); // memory will be freed
     1:   }
     1: 
     1:   // Return our desired size
 71581:   // Adjust the reflow size by PrintPreviewScale so the scrollbars end up the
     1:   // correct size
 71581:   SetDesiredSize(aDesiredSize, aReflowState, maxXMost, y);
     1: 
 55039:   aDesiredSize.SetOverflowAreasToDesiredBounds();
     1:   FinishAndStoreOverflow(&aDesiredSize);
     1: 
     1:   // cache the size so we can set the desired size 
     1:   // for the other reflows that happen
 71581:   mSize.width  = maxXMost;
 25840:   mSize.height = y;
     1: 
     1:   NS_FRAME_TRACE_REFLOW_OUT("nsSimplePageSequeceFrame::Reflow", aStatus);
     1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsSimplePageSequenceFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("SimplePageSequence"), aResult);
     1: }
     1: #endif
     1: 
     1: //====================================================================
     1: //== Asynch Printing
     1: //====================================================================
     1: NS_IMETHODIMP
108991: nsSimplePageSequenceFrame::GetCurrentPageNum(int32_t* aPageNum)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPageNum);
     1: 
     1:   *aPageNum = mPageNum;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsSimplePageSequenceFrame::GetNumPages(int32_t* aNumPages)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aNumPages);
     1: 
     1:   *aNumPages = mTotalPages;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsSimplePageSequenceFrame::IsDoingPrintRange(bool* aDoing)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aDoing);
     1: 
     1:   *aDoing = mDoingPageRange;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsSimplePageSequenceFrame::GetPrintRange(int32_t* aFromPage, int32_t* aToPage)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aFromPage);
     1:   NS_ENSURE_ARG_POINTER(aToPage);
     1: 
     1:   *aFromPage = mFromPageNum;
     1:   *aToPage   = mToPageNum;
     1:   return NS_OK;
     1: }
     1: 
     1: // Helper Function
     1: void 
 79445: nsSimplePageSequenceFrame::SetPageNumberFormat(const char* aPropName, const char* aDefPropVal, bool aPageNumOnly)
     1: {
     1:   // Doing this here so we only have to go get these formats once
     1:   nsXPIDLString pageNumberFormat;
     1:   // Now go get the Localized Page Formating String
     1:   nsresult rv =
     1:     nsContentUtils::GetLocalizedString(nsContentUtils::ePRINTING_PROPERTIES,
     1:                                        aPropName, pageNumberFormat);
     1:   if (NS_FAILED(rv)) { // back stop formatting
     1:     pageNumberFormat.AssignASCII(aDefPropVal);
     1:   }
     1: 
     1:   // Sets the format into a static data member which will own the memory and free it
     1:   PRUnichar* uStr = ToNewUnicode(pageNumberFormat);
106838:   if (uStr != nullptr) {
     1:     SetPageNumberFormat(uStr, aPageNumOnly); // nsPageFrame will own the memory
     1:   }
     1: 
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsSimplePageSequenceFrame::StartPrint(nsPresContext*   aPresContext,
     1:                                       nsIPrintSettings* aPrintSettings,
     1:                                       PRUnichar*        aDocTitle,
     1:                                       PRUnichar*        aDocURL)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPresContext);
     1:   NS_ENSURE_ARG_POINTER(aPrintSettings);
     1: 
     1:   if (!mPageData->mPrintSettings) {
     1:     mPageData->mPrintSettings = aPrintSettings;
     1:   }
     1: 
     1:   // Only set them if they are not null
     1:   if (aDocTitle) mPageData->mDocTitle = aDocTitle;
     1:   if (aDocURL) mPageData->mDocURL   = aDocURL;
     1: 
     1:   aPrintSettings->GetStartPageRange(&mFromPageNum);
     1:   aPrintSettings->GetEndPageRange(&mToPageNum);
 84138:   aPrintSettings->GetPageRanges(mPageRanges);
     1: 
     1:   mDoingPageRange = nsIPrintSettings::kRangeSpecifiedPageRange == mPrintRangeType ||
     1:                     nsIPrintSettings::kRangeSelection == mPrintRangeType;
     1: 
     1:   // If printing a range of pages make sure at least the starting page
     1:   // number is valid
108991:   int32_t totalPages = mFrames.GetLength();
     1: 
     1:   if (mDoingPageRange) {
     1:     if (mFromPageNum > totalPages) {
     1:       return NS_ERROR_INVALID_ARG;
     1:     }
     1:   }
     1: 
     1:   // Begin printing of the document
     1:   nsresult rv = NS_OK;
     1: 
     1:   // Determine if we are rendering only the selection
     1:   aPresContext->SetIsRenderingOnlySelection(nsIPrintSettings::kRangeSelection == mPrintRangeType);
     1: 
     1: 
     1:   if (mDoingPageRange) {
     1:     // XXX because of the hack for making the selection all print on one page
     1:     // we must make sure that the page is sized correctly before printing.
  8247:     nscoord height = aPresContext->GetPageSize().height;
     1: 
108991:     int32_t pageNum = 1;
     1:     nscoord y = 0;//mMargin.top;
     1: 
     1:     for (nsIFrame* page = mFrames.FirstChild(); page;
     1:          page = page->GetNextSibling()) {
     1:       if (pageNum >= mFromPageNum && pageNum <= mToPageNum) {
     1:         nsRect rect = page->GetRect();
     1:         rect.y = y;
     1:         rect.height = height;
     1:         page->SetRect(rect);
     1:         y += rect.height + mMargin.top + mMargin.bottom;
     1:       }
     1:       pageNum++;
     1:     }
     1: 
     1:     // adjust total number of pages
     1:     if (nsIPrintSettings::kRangeSelection != mPrintRangeType) {
     1:       totalPages = pageNum - 1;
     1:     }
     1:   }
     1: 
     1:   mPageNum          = 1;
     1:   mCurrentPageFrame = mFrames.FirstChild();
     1: 
     1:   if (mTotalPages == -1) {
     1:     mTotalPages = totalPages;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
111090: void
111090: GetPrintCanvasElementsInFrame(nsIFrame* aFrame, nsTArray<nsRefPtr<nsHTMLCanvasElement> >* aArr)
111090: {
111107:   if (!aFrame) {
111107:     return;
111107:   }
111090:   for (nsIFrame::ChildListIterator childLists(aFrame);
111090:     !childLists.IsDone(); childLists.Next()) {
111090: 
111090:     nsFrameList children = childLists.CurrentList();
111090:     for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
111090:       nsIFrame* child = e.get();
111090: 
111090:       // Check if child is a nsHTMLCanvasFrame.
111090:       nsHTMLCanvasFrame* canvasFrame = do_QueryFrame(child);
111090: 
111090:       // If there is a canvasFrame, try to get actual canvas element.
111090:       if (canvasFrame) {
111090:         nsHTMLCanvasElement* canvas =
121673:           nsHTMLCanvasElement::FromContentOrNull(canvasFrame->GetContent());
111090:         nsCOMPtr<nsIPrintCallback> printCallback;
111090:         if (canvas &&
111090:             NS_SUCCEEDED(canvas->GetMozPrintCallback(getter_AddRefs(printCallback))) &&
111090:             printCallback) {
111090:           aArr->AppendElement(canvas);
111090:           continue;
111090:         }
111090:       }
111090: 
111090:       if (!child->GetFirstPrincipalChild()) {
111090:         nsSubDocumentFrame* subdocumentFrame = do_QueryFrame(child);
111090:         if (subdocumentFrame) {
111090:           // Descend into the subdocument
111090:           nsIFrame* root = subdocumentFrame->GetSubdocumentRootFrame();
111090:           child = root;
111090:         }
111090:       }
111090:       // The current child is not a nsHTMLCanvasFrame OR it is but there is
111090:       // no nsHTMLCanvasElement on it. Check if children of `child` might
111090:       // contain a nsHTMLCanvasElement.
111090:       GetPrintCanvasElementsInFrame(child, aArr);
111090:     }
111090:   }
111090: }
111090: 
111090: void
111090: nsSimplePageSequenceFrame::DetermineWhetherToPrintPage()
111090: {
111090:   // See whether we should print this page
111090:   mPrintThisPage = true;
111090:   bool printEvenPages, printOddPages;
111090:   mPageData->mPrintSettings->GetPrintOptions(nsIPrintSettings::kPrintEvenPages, &printEvenPages);
111090:   mPageData->mPrintSettings->GetPrintOptions(nsIPrintSettings::kPrintOddPages, &printOddPages);
111090: 
111090:   // If printing a range of pages check whether the page number is in the
111090:   // range of pages to print
111090:   if (mDoingPageRange) {
111090:     if (mPageNum < mFromPageNum) {
111090:       mPrintThisPage = false;
111090:     } else if (mPageNum > mToPageNum) {
111090:       mPageNum++;
111090:       mCurrentPageFrame = nullptr;
111090:       mPrintThisPage = false;
111090:       return;
111090:     } else {
111090:       int32_t length = mPageRanges.Length();
111090:     
111090:       // Page ranges are pairs (start, end)
111090:       if (length && (length % 2 == 0)) {
111090:         mPrintThisPage = false;
111090:       
111090:         int32_t i;
111090:         for (i = 0; i < length; i += 2) {          
111090:           if (mPageRanges[i] <= mPageNum && mPageNum <= mPageRanges[i+1]) {
111090:             mPrintThisPage = true;
111090:             break;
111090:           }
111090:         }
111090:       }
111090:     }
111090:   }
111090: 
111090:   // Check for printing of odd and even pages
111090:   if (mPageNum & 0x1) {
111090:     if (!printOddPages) {
111090:       mPrintThisPage = false;  // don't print odd numbered page
111090:     }
111090:   } else {
111090:     if (!printEvenPages) {
111090:       mPrintThisPage = false;  // don't print even numbered page
111090:     }
111090:   }
111090:   
111090:   if (nsIPrintSettings::kRangeSelection == mPrintRangeType) {
111090:     mPrintThisPage = true;
111090:   }
111090: }
111090: 
111090: NS_IMETHODIMP
111090: nsSimplePageSequenceFrame::PrePrintNextPage(nsITimerCallback* aCallback, bool* aDone)
111090: {
111090:   if (!mCurrentPageFrame) {
111090:     *aDone = true;
111090:     return NS_ERROR_FAILURE;
111090:   }
111090:   
111090:   DetermineWhetherToPrintPage();
111090:   // Nothing to do if the current page doesn't get printed OR rendering to
111090:   // preview. For preview, the `CallPrintCallback` is called from within the
111090:   // nsHTMLCanvasElement::HandlePrintCallback.
111090:   if (!mPrintThisPage || !PresContext()->IsRootPaginatedDocument()) {
111090:     *aDone = true;
111090:     return NS_OK;
111090:   }
111090: 
111090:   // If the canvasList is null, then generate it and start the render
111090:   // process for all the canvas.
111090:   if (!mCurrentCanvasListSetup) {
111090:     mCurrentCanvasListSetup = true;
111090:     GetPrintCanvasElementsInFrame(mCurrentPageFrame, &mCurrentCanvasList);
111090: 
111090:     if (mCurrentCanvasList.Length() != 0) {
111090:       nsresult rv = NS_OK;
111090: 
111090:       // Begin printing of the document
111090:       nsDeviceContext *dc = PresContext()->DeviceContext();
111090:       PR_PL(("\n"));
111090:       PR_PL(("***************** BeginPage *****************\n"));
111090:       rv = dc->BeginPage();
111090:       NS_ENSURE_SUCCESS(rv, rv);
111090: 
111090:       mCalledBeginPage = true;
111090:       
111090:       nsRefPtr<nsRenderingContext> renderingContext;
111090:       dc->CreateRenderingContext(*getter_AddRefs(renderingContext));
111090:       NS_ENSURE_TRUE(renderingContext, NS_ERROR_OUT_OF_MEMORY);
111090: 
111090:       nsRefPtr<gfxASurface> renderingSurface =
111090:           renderingContext->ThebesContext()->CurrentSurface();
111090:       NS_ENSURE_TRUE(renderingSurface, NS_ERROR_OUT_OF_MEMORY);
111090: 
111335:       for (int32_t i = mCurrentCanvasList.Length() - 1; i >= 0 ; i--) {
111090:         nsHTMLCanvasElement* canvas = mCurrentCanvasList[i];
111090:         nsIntSize size = canvas->GetSize();
111090: 
111090:         nsRefPtr<gfxASurface> printSurface = renderingSurface->
111090:            CreateSimilarSurface(
111090:              gfxASurface::CONTENT_COLOR_ALPHA,
111090:              size
111090:            );
111090: 
111090:         nsICanvasRenderingContextInternal* ctx = canvas->GetContextAtIndex(0);
111090: 
111090:         if (!ctx) {
111090:           continue;
111090:         }
111090: 
111090:           // Initialize the context with the new printSurface.
111090:         ctx->InitializeWithSurface(NULL, printSurface, size.width, size.height);
111090: 
111090:         // Start the rendering process.
111090:         nsWeakFrame weakFrame = this;
111090:         canvas->DispatchPrintCallback(aCallback);
111090:         NS_ENSURE_STATE(weakFrame.IsAlive());
111090:       }
111090:     }
111090:   }
118634:   uint32_t doneCounter = 0;
111335:   for (int32_t i = mCurrentCanvasList.Length() - 1; i >= 0 ; i--) {
111090:     nsHTMLCanvasElement* canvas = mCurrentCanvasList[i];
111090: 
111090:     if (canvas->IsPrintCallbackDone()) {
111090:       doneCounter++;
111090:     }
111090:   }
111090:   // If all canvas have finished rendering, return true, otherwise false.
111090:   *aDone = doneCounter == mCurrentCanvasList.Length();
111090: 
111090:   return NS_OK;
111090: }
111090: 
111090: NS_IMETHODIMP
111090: nsSimplePageSequenceFrame::ResetPrintCanvasList()
111090: {
111335:   for (int32_t i = mCurrentCanvasList.Length() - 1; i >= 0 ; i--) {
111090:     nsHTMLCanvasElement* canvas = mCurrentCanvasList[i];
111090:     canvas->ResetPrintCallback();
111090:   }
111090: 
111090:   mCurrentCanvasList.Clear();
111090:   mCurrentCanvasListSetup = false; 
111090:   return NS_OK;
111090: } 
111090: 
     1: NS_IMETHODIMP
     1: nsSimplePageSequenceFrame::PrintNextPage()
     1: {
     1:   // Print each specified page
     1:   // pageNum keeps track of the current page and what pages are printing
     1:   //
     1:   // printedPageNum keeps track of the current page number to be printed
     1:   // Note: When print al the pages or a page range the printed page shows the
     1:   // actual page number, when printing selection it prints the page number starting
     1:   // with the first page of the selection. For example if the user has a 
     1:   // selection that starts on page 2 and ends on page 3, the page numbers when
     1:   // print are 1 and then two (which is different than printing a page range, where
     1:   // the page numbers would have been 2 and then 3)
     1: 
111090:   if (!mCurrentPageFrame) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
111090:   nsresult rv = NS_OK;
     1: 
111090:   DetermineWhetherToPrintPage();
111090: 
111090:   if (mPrintThisPage) {
     1:     // Begin printing of the document
 68668:     nsDeviceContext* dc = PresContext()->DeviceContext();
     1: 
     1:     // XXX This is temporary fix for printing more than one page of a selection
     1:     // This does a poor man's "dump" pagination (see Bug 89353)
     1:     // It has laid out as one long page and now we are just moving or view up/down 
     1:     // one page at a time and printing the contents of what is exposed by the rect.
     1:     // currently this does not work for IFrames
     1:     // I will soon improve this to work with IFrames 
 79445:     bool    continuePrinting = true;
  8247:     nscoord width, height;
   238:     width = PresContext()->GetPageSize().width;
   238:     height = PresContext()->GetPageSize().height;
     1:     height -= mMargin.top + mMargin.bottom;
     1:     width  -= mMargin.left + mMargin.right;
     1:     nscoord selectionY = height;
 77154:     nsIFrame* conFrame = mCurrentPageFrame->GetFirstPrincipalChild();
  8247:     if (mSelectionHeight >= 0) {
     1:       conFrame->SetPosition(conFrame->GetPosition() + nsPoint(0, -mYSelOffset));
 14745:       nsContainerFrame::PositionChildViews(conFrame);
     1:     }
     1: 
     1:     // cast the frame to be a page frame
  3233:     nsPageFrame * pf = static_cast<nsPageFrame*>(mCurrentPageFrame);
     1:     pf->SetPageNumInfo(mPageNum, mTotalPages);
     1:     pf->SetSharedPageData(mPageData);
     1: 
108991:     int32_t printedPageNum = 1;
     1:     while (continuePrinting) {
   238:       if (PresContext()->IsRootPaginatedDocument()) {
111090:         if (!mCalledBeginPage) {
     1:           PR_PL(("\n"));
     1:           PR_PL(("***************** BeginPage *****************\n"));
     1:           rv = dc->BeginPage();
     1:           NS_ENSURE_SUCCESS(rv, rv);
111090:         } else {
111090:           mCalledBeginPage = false;
111090:         }
     1:       }
     1: 
 33368:       PR_PL(("SeqFr::PrintNextPage -> %p PageNo: %d", pf, mPageNum));
     1: 
 68481:       nsRefPtr<nsRenderingContext> renderingContext;
 51038:       dc->CreateRenderingContext(*getter_AddRefs(renderingContext));
 51038:       NS_ENSURE_TRUE(renderingContext, NS_ERROR_OUT_OF_MEMORY);
 14016: 
     1:       nsRect drawingRect(nsPoint(0, 0),
     1:                          mCurrentPageFrame->GetSize());
     1:       nsRegion drawingRegion(drawingRect);
     1:       nsLayoutUtils::PaintFrame(renderingContext, mCurrentPageFrame,
 32424:                                 drawingRegion, NS_RGBA(0,0,0,0),
 32424:                                 nsLayoutUtils::PAINT_SYNC_DECODE_IMAGES);
     1: 
  8247:       if (mSelectionHeight >= 0 && selectionY < mSelectionHeight) {
     1:         selectionY += height;
     1:         printedPageNum++;
     1:         pf->SetPageNumInfo(printedPageNum, mTotalPages);
     1:         conFrame->SetPosition(conFrame->GetPosition() + nsPoint(0, -height));
 15498:         nsContainerFrame::PositionChildViews(conFrame);
     1: 
     1:         PR_PL(("***************** End Page (PrintNextPage) *****************\n"));
     1:         rv = dc->EndPage();
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:       } else {
 80486:         continuePrinting = false;
     1:       }
     1:     }
     1:   }
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsSimplePageSequenceFrame::DoPageEnd()
     1: {
     1:   nsresult rv = NS_OK;
   238:   if (PresContext()->IsRootPaginatedDocument() && mPrintThisPage) {
     1:     PR_PL(("***************** End Page (DoPageEnd) *****************\n"));
   238:     rv = PresContext()->DeviceContext()->EndPage();
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
111090:   ResetPrintCanvasList();
111090: 
     1:   mPageNum++;
     1: 
     1:   if (mCurrentPageFrame) {
     1:     mCurrentPageFrame = mCurrentPageFrame->GetNextSibling();
     1:   }
     1:   
     1:   return rv;
     1: }
     1: 
114845: static gfx3DMatrix
114845: ComputePageSequenceTransform(nsIFrame* aFrame, float aAppUnitsPerPixel)
     1: {
114845:   float scale = aFrame->PresContext()->GetPrintPreviewScale();
114845:   return gfx3DMatrix::ScalingMatrix(scale, scale, 1);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsSimplePageSequenceFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                             const nsRect&           aDirtyRect,
     1:                                             const nsDisplayListSet& aLists)
     1: {
     1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
114845:   nsDisplayList content;
114845:   nsIFrame* child = GetFirstPrincipalChild();
114845:   while (child) {
116172:     rv = child->BuildDisplayListForStackingContext(aBuilder,
116172:         child->GetVisualOverflowRectRelativeToSelf(), &content);
114845:     NS_ENSURE_SUCCESS(rv, rv);
114845:     child = child->GetNextSibling();
114845:   }
114845: 
116172:   rv = content.AppendNewToTop(new (aBuilder)
116172:       nsDisplayTransform(aBuilder, this, &content, ::ComputePageSequenceTransform));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
114845:   aLists.Content()->AppendToTop(&content);
     1:   return NS_OK;
     1: }
     1: 
     1: nsIAtom*
     1: nsSimplePageSequenceFrame::GetType() const
     1: {
     1:   return nsGkAtoms::sequenceFrame; 
     1: }
     1: 
     1: //------------------------------------------------------------------------------
     1: void
 79445: nsSimplePageSequenceFrame::SetPageNumberFormat(PRUnichar * aFormatStr, bool aForPageNumOnly)
     1: { 
106838:   NS_ASSERTION(aFormatStr != nullptr, "Format string cannot be null!");
106838:   NS_ASSERTION(mPageData != nullptr, "mPageData string cannot be null!");
     1: 
     1:   if (aForPageNumOnly) {
106838:     if (mPageData->mPageNumFormat != nullptr) {
     1:       nsMemory::Free(mPageData->mPageNumFormat);
     1:     }
     1:     mPageData->mPageNumFormat = aFormatStr;
     1:   } else {
106838:     if (mPageData->mPageNumAndTotalsFormat != nullptr) {
     1:       nsMemory::Free(mPageData->mPageNumAndTotalsFormat);
     1:     }
     1:     mPageData->mPageNumAndTotalsFormat = aFormatStr;
     1:   }
     1: }
     1: 
     1: //------------------------------------------------------------------------------
     1: void
     1: nsSimplePageSequenceFrame::SetDateTimeStr(PRUnichar * aDateTimeStr)
     1: { 
106838:   NS_ASSERTION(aDateTimeStr != nullptr, "DateTime string cannot be null!");
106838:   NS_ASSERTION(mPageData != nullptr, "mPageData string cannot be null!");
     1: 
106838:   if (mPageData->mDateTimeStr != nullptr) {
     1:     nsMemory::Free(mPageData->mDateTimeStr);
     1:   }
     1:   mPageData->mDateTimeStr = aDateTimeStr;
     1: }
     1: 
     1: //------------------------------------------------------------------------------
     1: // For Shrink To Fit
     1: //
     1: // Return the percentage that the page needs to shrink to 
     1: //
     1: NS_IMETHODIMP
     1: nsSimplePageSequenceFrame::GetSTFPercent(float& aSTFPercent)
     1: {
     1:   NS_ENSURE_TRUE(mPageData, NS_ERROR_UNEXPECTED);
     1:   aSTFPercent = 1.0f;
     1:   if (mPageData && (mPageData->mPageContentXMost > mPageData->mPageContentSize)) {
     1:     aSTFPercent = float(mPageData->mPageContentSize) / float(mPageData->mPageContentXMost);
     1:   }
     1:   return NS_OK;
     1: }
