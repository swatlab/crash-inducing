    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim: ft=cpp tw=78 sw=2 et ts=2
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Boris Zbarsky <bzbarsky@mit.edu>.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Christian Biesinger <cbiesinger@web.de>
48452:  *   Bobby Holley <bobbyholley@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * A base class which implements nsIImageLoadingContent and can be
    1:  * subclassed by various content nodes that want to provide image
    1:  * loading functionality (eg <img>, <object>, etc).
    1:  */
    1: 
    1: #include "nsImageLoadingContent.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsContentErrors.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsIURI.h"
    1: #include "nsILoadGroup.h"
    1: #include "imgIContainer.h"
    1: #include "imgILoader.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNetUtil.h"
38663: #include "nsPLDOMEvent.h"
    1: 
    1: #include "nsIPresShell.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsGUIEvent.h"
    1: 
    1: #include "nsIChannel.h"
    1: #include "nsIStreamListener.h"
    1: 
    1: #include "nsIFrame.h"
    1: #include "nsIDOMNode.h"
    1: 
    1: #include "nsContentUtils.h"
    1: #include "nsIContentPolicy.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsDOMClassInfo.h"
50430: #ifdef MOZ_SVG
50430: #include "nsSVGEffects.h"
50430: #endif
    1: 
14228: #include "mozAutoDocUpdate.h"
14228: 
    1: #ifdef DEBUG_chb
    1: static void PrintReqURL(imgIRequest* req) {
    1:   if (!req) {
    1:     printf("(null req)\n");
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   req->GetURI(getter_AddRefs(uri));
    1:   if (!uri) {
    1:     printf("(null uri)\n");
    1:     return;
    1:   }
    1: 
    1:   nsCAutoString spec;
    1:   uri->GetSpec(spec);
    1:   printf("spec='%s'\n", spec.get());
    1: }
    1: #endif /* DEBUG_chb */
    1: 
    1: 
    1: nsImageLoadingContent::nsImageLoadingContent()
    1:   : mObserverList(nsnull),
    1:     mImageBlockingStatus(nsIContentPolicy::ACCEPT),
    1:     mLoadingEnabled(PR_TRUE),
32426:     mIsImageStateForced(PR_FALSE),
    1:     mLoading(PR_FALSE),
    1:     // mBroken starts out true, since an image without a URI is broken....
    1:     mBroken(PR_TRUE),
    1:     mUserDisabled(PR_FALSE),
29590:     mSuppressed(PR_FALSE),
48452:     mBlockingOnload(PR_FALSE),
61327:     mNewRequestsWillNeedAnimationReset(PR_FALSE),
61327:     mPendingRequestNeedsResetAnimation(PR_FALSE),
61327:     mCurrentRequestNeedsResetAnimation(PR_FALSE),
48452:     mStateChangerDepth(0)
    1: {
    1:   if (!nsContentUtils::GetImgLoader()) {
    1:     mLoadingEnabled = PR_FALSE;
    1:   }
    1: }
    1: 
    1: void
    1: nsImageLoadingContent::DestroyImageLoadingContent()
    1: {
    1:   // Cancel our requests so they won't hold stale refs to us
48452:   ClearCurrentRequest(NS_BINDING_ABORTED);
48452:   ClearPendingRequest(NS_BINDING_ABORTED);
    1: }
    1: 
    1: nsImageLoadingContent::~nsImageLoadingContent()
    1: {
    1:   NS_ASSERTION(!mCurrentRequest && !mPendingRequest,
    1:                "DestroyImageLoadingContent not called");
    1:   NS_ASSERTION(!mObserverList.mObserver && !mObserverList.mNext,
    1:                "Observers still registered?");
    1: }
    1: 
    1: // Macro to call some func on each observer.  This handles observers
    1: // removing themselves.
    1: #define LOOP_OVER_OBSERVERS(func_)                                       \
    1:   PR_BEGIN_MACRO                                                         \
    1:     for (ImageObserver* observer = &mObserverList, *next; observer;      \
    1:          observer = next) {                                              \
    1:       next = observer->mNext;                                            \
    1:       if (observer->mObserver) {                                         \
    1:         observer->mObserver->func_;                                      \
    1:       }                                                                  \
    1:     }                                                                    \
    1:   PR_END_MACRO
    1: 
    1: 
    1: /*
    1:  * imgIContainerObserver impl
    1:  */
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::FrameChanged(imgIContainer* aContainer,
50544:                                     const nsIntRect* aDirtyRect)
    1: {
30479:   LOOP_OVER_OBSERVERS(FrameChanged(aContainer, aDirtyRect));
    1:   return NS_OK;
    1: }
    1:             
    1: /*
    1:  * imgIDecoderObserver impl
    1:  */
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnStartRequest(imgIRequest* aRequest)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   LOOP_OVER_OBSERVERS(OnStartRequest(aRequest));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnStartDecode(imgIRequest* aRequest)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
46992: 
46992:   // Onload blocking. This only applies for the current request.
32426:   if (aRequest == mCurrentRequest) {
46992: 
46992:     // Determine whether this is a background request (this can be the case
46992:     // with multipart/x-mixed-replace images, for example).
46992:     PRUint32 loadFlags;
61720:     nsresult rv = aRequest->GetLoadFlags(&loadFlags);
46992:     PRBool background =
46992:       (NS_SUCCEEDED(rv) && (loadFlags & nsIRequest::LOAD_BACKGROUND));
46992: 
46992:     // Block onload for non-background requests
46992:     if (!background) {
32426:       NS_ABORT_IF_FALSE(!mBlockingOnload, "Shouldn't already be blocking");
32426:       SetBlockingOnload(PR_TRUE);
32426:     }
46992:   }
32426: 
    1:   LOOP_OVER_OBSERVERS(OnStartDecode(aRequest));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnStartContainer(imgIRequest* aRequest,
    1:                                         imgIContainer* aContainer)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   LOOP_OVER_OBSERVERS(OnStartContainer(aRequest, aContainer));
    1: 
    1:   // Have to check for state changes here, since we might have been in
    1:   // the LOADING state before.
    1:   UpdateImageState(PR_TRUE);
    1:   return NS_OK;    
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnStartFrame(imgIRequest* aRequest,
30479:                                     PRUint32 aFrame)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   LOOP_OVER_OBSERVERS(OnStartFrame(aRequest, aFrame));
    1:   return NS_OK;    
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnDataAvailable(imgIRequest* aRequest,
30479:                                        PRBool aCurrentFrame,
23738:                                        const nsIntRect* aRect)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
30479:   LOOP_OVER_OBSERVERS(OnDataAvailable(aRequest, aCurrentFrame, aRect));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnStopFrame(imgIRequest* aRequest,
30479:                                    PRUint32 aFrame)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
32426:   // If we're blocking a load, one frame is enough
32426:   if (aRequest == mCurrentRequest)
32426:     SetBlockingOnload(PR_FALSE);
32426: 
    1:   LOOP_OVER_OBSERVERS(OnStopFrame(aRequest, aFrame));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnStopContainer(imgIRequest* aRequest,
    1:                                        imgIContainer* aContainer)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
32426:   // This is really hacky. We need to handle the case where we start decoding,
32426:   // block onload, but then hit an error before we get to our first frame. In
32426:   // theory we would just hook in at OnStopDecode, but OnStopDecode is broken
32426:   // until we fix bug 505385. OnStopContainer is actually going away at that
32426:   // point. So for now we take advantage of the fact that OnStopContainer is
32426:   // always fired in the decoders at the same time as OnStopDecode.
32426:   if (aRequest == mCurrentRequest)
32426:     SetBlockingOnload(PR_FALSE);
32426: 
    1:   LOOP_OVER_OBSERVERS(OnStopContainer(aRequest, aContainer));
    1:   return NS_OK;
    1: }
    1: 
48452: // Warning - This isn't actually fired when decode is complete. Rather, it's
48452: // fired when load is complete. See bug 505385, and in the mean time use
48452: // OnStopContainer.
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnStopDecode(imgIRequest* aRequest,
    1:                                     nsresult aStatus,
    1:                                     const PRUnichar* aStatusArg)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
32426:   // We should definitely have a request here
32426:   NS_ABORT_IF_FALSE(aRequest, "no request?");
32426: 
    1:   NS_PRECONDITION(aRequest == mCurrentRequest || aRequest == mPendingRequest,
    1:                   "Unknown request");
    1:   LOOP_OVER_OBSERVERS(OnStopDecode(aRequest, aStatus, aStatusArg));
    1: 
48452:   // XXXbholley - When we fix bug 505385,  everything here should go in
48452:   // OnStopRequest.
48452: 
48452:   // Our state may change. Watch it.
48452:   AutoStateChanger changer(this, PR_TRUE);
48452: 
48452:   // If the pending request is loaded, switch to it.
    1:   if (aRequest == mPendingRequest) {
48452:     PrepareCurrentRequest() = mPendingRequest;
    1:     mPendingRequest = nsnull;
61327:     mCurrentRequestNeedsResetAnimation = mPendingRequestNeedsResetAnimation;
61327:     mPendingRequestNeedsResetAnimation = PR_FALSE;
    1:   }
48452:   NS_ABORT_IF_FALSE(aRequest == mCurrentRequest,
48452:                     "One way or another, we should be current by now");
    1: 
61327:   if (mCurrentRequestNeedsResetAnimation) {
61327:     nsCOMPtr<imgIContainer> container;
61327:     mCurrentRequest->GetImage(getter_AddRefs(container));
61327:     if (container)
61327:       container->ResetAnimation();
61327:     mCurrentRequestNeedsResetAnimation = PR_FALSE;
61327:   }
61327: 
32426:   // We just loaded all the data we're going to get. If we haven't done an
32426:   // initial paint, we want to make sure the image starts decoding for 2
32426:   // reasons:
32426:   //
32426:   // 1) This image is sitting idle but might need to be decoded as soon as we
32426:   // start painting, in which case we've wasted time.
32426:   //
32426:   // 2) We want to block onload until all visible images are decoded. We do this
32426:   // by blocking onload until all in progress decodes get at least one frame
32426:   // decoded. However, if all the data comes in while painting is suppressed
32426:   // (ie, before the initial paint delay is finished), we fire onload without
32426:   // doing a paint first. This means that decode-on-draw images don't start
32426:   // decoding, so we can't wait for them to finish. See bug 512435.
32426: 
32426:   // We can only do this if we have a presshell
32539:   nsIDocument* doc = GetOurDocument();
46225:   nsIPresShell* shell = doc ? doc->GetShell() : nsnull;
32426:   if (shell) {
32426: 
32426:     // We need to figure out whether to kick off decoding
32426:     PRBool doRequestDecode = PR_FALSE;
32426: 
32426:     // If we haven't got the initial reflow yet, IsPaintingSuppressed actually
32426:     // returns false
32426:     if (!shell->DidInitialReflow())
32426:       doRequestDecode = PR_TRUE;
32426: 
32426:     // Figure out if painting is suppressed. Note that it's possible for painting
32426:     // to be suppressed for reasons other than the initial paint delay (for
32426:     // example - being in the bfcache), but we probably aren't loading images in
32426:     // those situations.
40049:     if (shell->IsPaintingSuppressed())
32426:       doRequestDecode = PR_TRUE;
32426: 
32426:     // If we're requesting a decode, do it
32426:     if (doRequestDecode)
48452:       mCurrentRequest->RequestDecode();
32426:   }
32426: 
48452:   // Fire the appropriate DOM event.
    1:   if (NS_SUCCEEDED(aStatus)) {
    1:     FireEvent(NS_LITERAL_STRING("load"));
    1:   } else {
    1:     FireEvent(NS_LITERAL_STRING("error"));
    1:   }
    1: 
50430: #ifdef MOZ_SVG
50430:   nsCOMPtr<nsINode> thisNode = do_QueryInterface(this);
50430:   nsSVGEffects::InvalidateDirectRenderingObservers(thisNode->AsElement());
50430: #endif
50430: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::OnStopRequest(imgIRequest* aRequest, PRBool aLastPart)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   LOOP_OVER_OBSERVERS(OnStopRequest(aRequest, aLastPart));
    1: 
    1:   return NS_OK;
    1: }
    1: 
32424: NS_IMETHODIMP
32424: nsImageLoadingContent::OnDiscard(imgIRequest *aRequest)
32424: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
32424:   LOOP_OVER_OBSERVERS(OnDiscard(aRequest));
32424: 
32424:   return NS_OK;
32424: }
32424: 
    1: /*
    1:  * nsIImageLoadingContent impl
    1:  */
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::GetLoadingEnabled(PRBool *aLoadingEnabled)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   *aLoadingEnabled = mLoadingEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::SetLoadingEnabled(PRBool aLoadingEnabled)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   if (nsContentUtils::GetImgLoader()) {
    1:     mLoadingEnabled = aLoadingEnabled;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::GetImageBlockingStatus(PRInt16* aStatus)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   NS_PRECONDITION(aStatus, "Null out param");
    1:   *aStatus = mImageBlockingStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::AddObserver(imgIDecoderObserver* aObserver)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   NS_ENSURE_ARG_POINTER(aObserver);
    1: 
    1:   if (!mObserverList.mObserver) {
    1:     mObserverList.mObserver = aObserver;
    1:     // Don't touch the linking of the list!
    1:     return NS_OK;
    1:   }
    1: 
    1:   // otherwise we have to create a new entry
    1: 
    1:   ImageObserver* observer = &mObserverList;
    1:   while (observer->mNext) {
    1:     observer = observer->mNext;
    1:   }
    1: 
    1:   observer->mNext = new ImageObserver(aObserver);
    1:   if (! observer->mNext) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::RemoveObserver(imgIDecoderObserver* aObserver)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   NS_ENSURE_ARG_POINTER(aObserver);
    1: 
    1:   if (mObserverList.mObserver == aObserver) {
    1:     mObserverList.mObserver = nsnull;
    1:     // Don't touch the linking of the list!
    1:     return NS_OK;
    1:   }
    1: 
    1:   // otherwise have to find it and splice it out
    1:   ImageObserver* observer = &mObserverList;
    1:   while (observer->mNext && observer->mNext->mObserver != aObserver) {
    1:     observer = observer->mNext;
    1:   }
    1: 
    1:   // At this point, we are pointing to the list element whose mNext is
    1:   // the right observer (assuming of course that mNext is not null)
    1:   if (observer->mNext) {
    1:     // splice it out
    1:     ImageObserver* oldObserver = observer->mNext;
    1:     observer->mNext = oldObserver->mNext;
    1:     oldObserver->mNext = nsnull;  // so we don't destroy them all
    1:     delete oldObserver;
    1:   }
    1: #ifdef DEBUG
    1:   else {
42587:     NS_WARNING("Asked to remove nonexistent observer");
    1:   }
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::GetRequest(PRInt32 aRequestType,
    1:                                   imgIRequest** aRequest)
    1: {
    1:   switch(aRequestType) {
    1:   case CURRENT_REQUEST:
    1:     *aRequest = mCurrentRequest;
    1:     break;
    1:   case PENDING_REQUEST:
    1:     *aRequest = mPendingRequest;
    1:     break;
    1:   default:
    1:     NS_ERROR("Unknown request type");
    1:     *aRequest = nsnull;
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1:   
    1:   NS_IF_ADDREF(*aRequest);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::GetRequestType(imgIRequest* aRequest,
    1:                                       PRInt32* aRequestType)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   NS_PRECONDITION(aRequestType, "Null out param");
    1:   
    1:   if (aRequest == mCurrentRequest) {
    1:     *aRequestType = CURRENT_REQUEST;
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (aRequest == mPendingRequest) {
    1:     *aRequestType = PENDING_REQUEST;
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aRequestType = UNKNOWN_REQUEST;
    1:   NS_ERROR("Unknown request");
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::GetCurrentURI(nsIURI** aURI)
    1: {
    1:   if (mCurrentRequest) {
    1:     return mCurrentRequest->GetURI(aURI);
    1:   }
    1: 
    1:   if (!mCurrentURI) {
    1:     *aURI = nsnull;
    1:     return NS_OK;
    1:   }
    1:   
    1:   return NS_EnsureSafeToReturn(mCurrentURI, aURI);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageLoadingContent::LoadImageWithChannel(nsIChannel* aChannel,
    1:                                             nsIStreamListener** aListener)
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   if (!nsContentUtils::GetImgLoader()) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocument> doc = GetOurDocument();
    1:   if (!doc) {
    1:     // Don't bother
    1:     return NS_OK;
    1:   }
    1: 
48452:   // XXX what should we do with content policies here, if anything?
48452:   // Shouldn't that be done before the start of the load?
48452:   // XXX what about shouldProcess?
    1: 
48452:   // Our state might change. Watch it.
48452:   AutoStateChanger changer(this, PR_TRUE);
    1: 
48452:   // Do the load.
50815:   nsCOMPtr<imgIRequest>& req = PrepareNextRequest();
    1:   nsresult rv = nsContentUtils::GetImgLoader()->
48452:     LoadImageWithChannel(aChannel, this, doc, aListener,
50815:                          getter_AddRefs(req));
50815:   if (NS_SUCCEEDED(rv)) {
50815:     TrackImage(req);
50815:   } else {
48452:     // If we don't have a current URI, we might as well store this URI so people
48452:     // know what we tried (and failed) to load.
48452:     if (!mCurrentRequest)
48452:       aChannel->GetURI(getter_AddRefs(mCurrentURI));
48452:     FireEvent(NS_LITERAL_STRING("error"));
    1:     return rv;
    1:   }
48452:   return NS_OK;;
48452: }
    1: 
    1: NS_IMETHODIMP nsImageLoadingContent::ForceReload()
    1: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
    1:   nsCOMPtr<nsIURI> currentURI;
    1:   GetCurrentURI(getter_AddRefs(currentURI));
    1:   if (!currentURI) {
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   return LoadImage(currentURI, PR_TRUE, PR_TRUE, nsnull, nsIRequest::VALIDATE_ALWAYS);
    1: }
    1: 
    1: /*
    1:  * Non-interface methods
    1:  */
    1: 
51587: void
51587: nsImageLoadingContent::NotifyOwnerDocumentChanged(nsIDocument *aOldDoc)
51587: {
51587:   // If we had a document before, unregister ourselves with it.
51587:   if (aOldDoc) {
51587:     if (mCurrentRequest)
51587:       aOldDoc->RemoveImage(mCurrentRequest);
51587:     if (mPendingRequest)
51587:       aOldDoc->RemoveImage(mPendingRequest);
51587:   }
51587: 
51587:   // Re-track the images
51587:   TrackImage(mCurrentRequest);
51587:   TrackImage(mPendingRequest);
51587: }
51587: 
    1: nsresult
    1: nsImageLoadingContent::LoadImage(const nsAString& aNewURI,
    1:                                  PRBool aForce,
    1:                                  PRBool aNotify)
    1: {
    1:   // First, get a document (needed for security checks and the like)
    1:   nsIDocument* doc = GetOurDocument();
    1:   if (!doc) {
    1:     // No reason to bother, I think...
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> imageURI;
    1:   nsresult rv = StringToURI(aNewURI, doc, getter_AddRefs(imageURI));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // XXXbiesi fire onerror if that failed?
    1: 
16505:   PRBool equal;
16505: 
16505:   if (aNewURI.IsEmpty() &&
16505:       doc->GetDocumentURI() &&
16505:       NS_SUCCEEDED(doc->GetDocumentURI()->Equals(imageURI, &equal)) && 
16505:       equal)  {
16505: 
16505:     // Loading an embedded img from the same URI as the document URI will not work
16505:     // as a resource cannot recursively embed itself. Attempting to do so generally
16505:     // results in having to pre-emptively close down an in-flight HTTP transaction 
16505:     // and then incurring the significant cost of establishing a new TCP channel.
16505:     // This is generally triggered from <img src=""> 
16505:     // In light of that, just skip loading it..
22743:     // Do make sure to drop our existing image, if any
22743:     CancelImageRequests(aNotify);
16505:     return NS_OK;
16505:   }
16505: 
    1:   NS_TryToSetImmutable(imageURI);
    1: 
    1:   return LoadImage(imageURI, aForce, aNotify, doc);
    1: }
    1: 
    1: nsresult
    1: nsImageLoadingContent::LoadImage(nsIURI* aNewURI,
    1:                                  PRBool aForce,
    1:                                  PRBool aNotify,
    1:                                  nsIDocument* aDocument,
    1:                                  nsLoadFlags aLoadFlags)
    1: {
    1:   if (!mLoadingEnabled) {
35156:     // XXX Why fire an error here? seems like the callers to SetLoadingEnabled
35156:     // don't want/need it.
    1:     FireEvent(NS_LITERAL_STRING("error"));
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ASSERTION(!aDocument || aDocument == GetOurDocument(),
    1:                "Bogus document passed in");
    1:   // First, get a document (needed for security checks and the like)
    1:   if (!aDocument) {
    1:     aDocument = GetOurDocument();
    1:     if (!aDocument) {
    1:       // No reason to bother, I think...
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
48452:   // URI equality check.
48452:   //
48452:   // We skip the equality check if our current image was blocked, since in that
48452:   // case we really do want to try loading again.
    1:   if (!aForce && NS_CP_ACCEPTED(mImageBlockingStatus)) {
    1:     nsCOMPtr<nsIURI> currentURI;
    1:     GetCurrentURI(getter_AddRefs(currentURI));
    1:     PRBool equal;
    1:     if (currentURI &&
    1:         NS_SUCCEEDED(currentURI->Equals(aNewURI, &equal)) &&
    1:         equal) {
    1:       // Nothing to do here.
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
48452:   // From this point on, our image state could change. Watch it.
    1:   AutoStateChanger changer(this, aNotify);
    1: 
48452:   // Sanity check.
48452:   //
48452:   // We use the principal of aDocument to avoid having to QI |this| an extra
48452:   // time. It should always be the same as the principal of this node.
 3088: #ifdef DEBUG
 3088:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(this);
48452:   NS_ABORT_IF_FALSE(thisContent &&
 3088:                     thisContent->NodePrincipal() == aDocument->NodePrincipal(),
 3088:                     "Principal mismatch?");
 3088: #endif
 3088: 
48452:   // Are we blocked?
48452:   PRInt16 cpDecision = nsIContentPolicy::REJECT_REQUEST;
48452:   nsContentUtils::CanLoadImage(aNewURI, this, aDocument,
48452:                                aDocument->NodePrincipal(), &cpDecision);
48452:   if (!NS_CP_ACCEPTED(cpDecision)) {
    1:     FireEvent(NS_LITERAL_STRING("error"));
48452:     SetBlockedRequest(aNewURI, cpDecision);
    1:     return NS_OK;
    1:   }
    1: 
48452:   // Not blocked. Do the load.
50815:   nsCOMPtr<imgIRequest>& req = PrepareNextRequest();
48452:   nsresult rv;
    1:   rv = nsContentUtils::LoadImage(aNewURI, aDocument,
 3088:                                  aDocument->NodePrincipal(),
    1:                                  aDocument->GetDocumentURI(),
    1:                                  this, aLoadFlags,
50815:                                  getter_AddRefs(req));
50815:   if (NS_SUCCEEDED(rv)) {
50815:     TrackImage(req);
50815:   } else {
48452:     // If we don't have a current URI, we might as well store this URI so people
48452:     // know what we tried (and failed) to load.
48452:     if (!mCurrentRequest)
48452:       mCurrentURI = aNewURI;
    1:     FireEvent(NS_LITERAL_STRING("error"));
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
29590: nsresult
56168: nsImageLoadingContent::ForceImageState(PRBool aForce, nsEventStates::InternalType aState)
29590: {
61720:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
61720: 
29590:   mIsImageStateForced = aForce;
56168:   mForcedImageState = nsEventStates(aState);
29590:   return NS_OK;
29590: }
29590: 
56168: nsEventStates
    1: nsImageLoadingContent::ImageState() const
    1: {
56168:   if (mIsImageStateForced) {
56168:     return mForcedImageState;
56168:   }
56168: 
56168:   nsEventStates states;
56168: 
56168:   if (mBroken) {
56168:     states |= NS_EVENT_STATE_BROKEN;
56168:   }
56168:   if (mUserDisabled) {
56168:     states |= NS_EVENT_STATE_USERDISABLED;
56168:   }
56168:   if (mSuppressed) {
56168:     states |= NS_EVENT_STATE_SUPPRESSED;
56168:   }
56168:   if (mLoading) {
56168:     states |= NS_EVENT_STATE_LOADING;
56168:   }
56168: 
56168:   return states;
    1: }
    1: 
    1: void
    1: nsImageLoadingContent::UpdateImageState(PRBool aNotify)
    1: {
48452:   if (mStateChangerDepth > 0) {
48452:     // Ignore this call; we'll update our state when the outermost state
48452:     // changer is destroyed. Need this to work around the fact that some libpr0n
48452:     // stuff is actually sync and hence we can get OnStopDecode called while
48452:     // we're still under LoadImage, and OnStopDecode doesn't know anything about
48452:     // aNotify.
48452:     // XXX - This machinery should be removed after bug 521604.
    1:     return;
    1:   }
    1:   
    1:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(this);
    1:   if (!thisContent) {
    1:     return;
    1:   }
    1: 
56168:   nsEventStates oldState = ImageState();
    1: 
    1:   mLoading = mBroken = mUserDisabled = mSuppressed = PR_FALSE;
    1:   
    1:   // If we were blocked by server-based content policy, we claim to be
    1:   // suppressed.  If we were blocked by type-based content policy, we claim to
    1:   // be user-disabled.  Otherwise, claim to be broken.
    1:   if (mImageBlockingStatus == nsIContentPolicy::REJECT_SERVER) {
    1:     mSuppressed = PR_TRUE;
    1:   } else if (mImageBlockingStatus == nsIContentPolicy::REJECT_TYPE) {
    1:     mUserDisabled = PR_TRUE;
    1:   } else if (!mCurrentRequest) {
    1:     // No current request means error, since we weren't disabled or suppressed
    1:     mBroken = PR_TRUE;
    1:   } else {
    1:     PRUint32 currentLoadStatus;
    1:     nsresult rv = mCurrentRequest->GetImageStatus(&currentLoadStatus);
    1:     if (NS_FAILED(rv) || (currentLoadStatus & imgIRequest::STATUS_ERROR)) {
    1:       mBroken = PR_TRUE;
    1:     } else if (!(currentLoadStatus & imgIRequest::STATUS_SIZE_AVAILABLE)) {
    1:       mLoading = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   if (aNotify) {
    1:     nsIDocument* doc = thisContent->GetCurrentDoc();
    1:     if (doc) {
    1:       NS_ASSERTION(thisContent->IsInDoc(), "Something is confused");
56168:       nsEventStates changedBits = oldState ^ ImageState();
56168:       if (!changedBits.IsEmpty()) {
    1:         mozAutoDocUpdate upd(doc, UPDATE_CONTENT_STATE, PR_TRUE);
    1:         doc->ContentStatesChanged(thisContent, nsnull, changedBits);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsImageLoadingContent::CancelImageRequests(PRBool aNotify)
    1: {
22743:   AutoStateChanger changer(this, aNotify);
48452:   ClearPendingRequest(NS_BINDING_ABORTED);
48452:   ClearCurrentRequest(NS_BINDING_ABORTED);
    1: }
    1: 
    1: nsresult
    1: nsImageLoadingContent::UseAsPrimaryRequest(imgIRequest* aRequest,
    1:                                            PRBool aNotify)
    1: {
48452:   // Our state will change. Watch it.
    1:   AutoStateChanger changer(this, aNotify);
    1: 
48452:   // Get rid if our existing images
48452:   ClearPendingRequest(NS_BINDING_ABORTED);
48452:   ClearCurrentRequest(NS_BINDING_ABORTED);
    1: 
48452:   // Clone the request we were given.
50815:   nsCOMPtr<imgIRequest>& req = PrepareNextRequest();;
50815:   nsresult rv = aRequest->Clone(this, getter_AddRefs(req));
50815:   if (NS_SUCCEEDED(rv))
50815:     TrackImage(req);
50815:   else
50815:     return rv;
48452: 
48452:   return NS_OK;
    1: }
    1: 
    1: nsIDocument*
    1: nsImageLoadingContent::GetOurDocument()
    1: {
    1:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(this);
    1:   NS_ENSURE_TRUE(thisContent, nsnull);
    1: 
    1:   return thisContent->GetOwnerDoc();
    1: }
    1: 
    1: nsresult
    1: nsImageLoadingContent::StringToURI(const nsAString& aSpec,
    1:                                    nsIDocument* aDocument,
    1:                                    nsIURI** aURI)
    1: {
    1:   NS_PRECONDITION(aDocument, "Must have a document");
    1:   NS_PRECONDITION(aURI, "Null out param");
    1: 
    1:   // (1) Get the base URI
    1:   nsCOMPtr<nsIContent> thisContent = do_QueryInterface(this);
    1:   NS_ASSERTION(thisContent, "An image loading content must be an nsIContent");
    1:   nsCOMPtr<nsIURI> baseURL = thisContent->GetBaseURI();
    1: 
    1:   // (2) Get the charset
    1:   const nsAFlatCString &charset = aDocument->GetDocumentCharacterSet();
    1: 
    1:   // (3) Construct the silly thing
    1:   return NS_NewURI(aURI,
    1:                    aSpec,
    1:                    charset.IsEmpty() ? nsnull : charset.get(),
    1:                    baseURL,
    1:                    nsContentUtils::GetIOService());
    1: }
    1: 
    1: nsresult
    1: nsImageLoadingContent::FireEvent(const nsAString& aEventType)
    1: {
    1:   // We have to fire the event asynchronously so that we won't go into infinite
    1:   // loops in cases when onLoad handlers reset the src and the new src is in
    1:   // cache.
    1: 
38663:   nsCOMPtr<nsINode> thisNode = do_QueryInterface(this);
38663: 
38663:   nsRefPtr<nsPLDOMEvent> event =
38663:     new nsLoadBlockingPLDOMEvent(thisNode, aEventType, PR_FALSE, PR_FALSE);
38663:   event->PostDOMEvent();
38663:   
    1:   return NS_OK;
    1: }
    1: 
48452: nsCOMPtr<imgIRequest>&
48452: nsImageLoadingContent::PrepareNextRequest()
48452: {
48452:   // If we don't have a usable current request, get rid of any half-baked
48452:   // request that might be sitting there and make this one current.
48452:   if (!HaveSize(mCurrentRequest))
48452:     return PrepareCurrentRequest();
48452: 
48452:   // Otherwise, make it pending.
48452:   return PreparePendingRequest();
48452: }
48452: 
48452: void
48452: nsImageLoadingContent::SetBlockedRequest(nsIURI* aURI, PRInt16 aContentDecision)
48452: {
48452:   // Sanity
48452:   NS_ABORT_IF_FALSE(!NS_CP_ACCEPTED(aContentDecision), "Blocked but not?");
48452: 
48452:   // We do some slightly illogical stuff here to maintain consistency with
48452:   // old behavior that people probably depend on. Even in the case where the
48452:   // new image is blocked, the old one should really be canceled with the
48452:   // reason "image source changed". However, apparently there's some abuse
48452:   // over in nsImageFrame where the displaying of the "broken" icon for the
48452:   // next image depends on the cancel reason of the previous image. ugh.
48452:   ClearPendingRequest(NS_ERROR_IMAGE_BLOCKED);
48452: 
48452:   // For the blocked case, we only want to cancel the existing current request
48452:   // if size is not available. bz says the web depends on this behavior.
48452:   if (!HaveSize(mCurrentRequest)) {
48452: 
48452:     mImageBlockingStatus = aContentDecision;
48452:     ClearCurrentRequest(NS_ERROR_IMAGE_BLOCKED);
48452: 
48452:     // We still want to remember what URI we were despite not having an actual
48452:     // request.
48452:     mCurrentURI = aURI;
48452:   }
48452: }
48452: 
48452: nsCOMPtr<imgIRequest>&
48452: nsImageLoadingContent::PrepareCurrentRequest()
48452: {
48452:   // Blocked images go through SetBlockedRequest, which is a separate path. For
48452:   // everything else, we're unblocked.
48452:   mImageBlockingStatus = nsIContentPolicy::ACCEPT;
48452: 
48452:   // Get rid of anything that was there previously.
48452:   ClearCurrentRequest(NS_ERROR_IMAGE_SRC_CHANGED);
48452: 
61327:   mCurrentRequestNeedsResetAnimation = mNewRequestsWillNeedAnimationReset;
61327: 
48452:   // Return a reference.
48452:   return mCurrentRequest;
48452: }
48452: 
48452: nsCOMPtr<imgIRequest>&
48452: nsImageLoadingContent::PreparePendingRequest()
48452: {
48452:   // Get rid of anything that was there previously.
48452:   ClearPendingRequest(NS_ERROR_IMAGE_SRC_CHANGED);
48452: 
61327:   mPendingRequestNeedsResetAnimation = mNewRequestsWillNeedAnimationReset;
61327: 
48452:   // Return a reference.
48452:   return mPendingRequest;
48452: }
48452: 
48452: void
48452: nsImageLoadingContent::ClearCurrentRequest(nsresult aReason)
48452: {
48452:   if (!mCurrentRequest) {
48452:     // Even if we didn't have a current request, we might have been keeping
48452:     // a URI as a placeholder for a failed load. Clear that now.
48452:     mCurrentURI = nsnull;
48452:     return;
48452:   }
48452:   NS_ABORT_IF_FALSE(!mCurrentURI,
48452:                     "Shouldn't have both mCurrentRequest and mCurrentURI!");
48452: 
48452:   // Clean up the request.
50815:   UntrackImage(mCurrentRequest);
48452:   mCurrentRequest->CancelAndForgetObserver(aReason);
48452:   mCurrentRequest = nsnull;
61327:   mCurrentRequestNeedsResetAnimation = PR_FALSE;
48452: 
48452:   // We only block onload during the decoding of "current" images. This one is
48452:   // going away, so we should unblock unconditionally here.
48452:   SetBlockingOnload(PR_FALSE);
48452: }
48452: 
48452: void
48452: nsImageLoadingContent::ClearPendingRequest(nsresult aReason)
48452: {
48452:   if (!mPendingRequest)
48452:     return;
61720: 
61720:   // Push a null JSContext on the stack so that code that runs within
61720:   // the below code doesn't think it's being called by JS. See bug
61720:   // 604262.
61720:   nsCxPusher pusher;
61720:   pusher.PushNull();
61720: 
50815:   UntrackImage(mPendingRequest);
48452:   mPendingRequest->CancelAndForgetObserver(aReason);
48452:   mPendingRequest = nsnull;
61327:   mPendingRequestNeedsResetAnimation = PR_FALSE;
48452: }
48452: 
48452: bool
48452: nsImageLoadingContent::HaveSize(imgIRequest *aImage)
48452: {
48452:   // Handle the null case
48452:   if (!aImage)
48452:     return false;
48452: 
48452:   // Query the image
48452:   PRUint32 status;
48452:   nsresult rv = aImage->GetImageStatus(&status);
48452:   return (NS_SUCCEEDED(rv) && (status & imgIRequest::STATUS_SIZE_AVAILABLE));
48452: }
48452: 
32426: void
32426: nsImageLoadingContent::SetBlockingOnload(PRBool aBlocking)
32426: {
32426:   // If we're already in the desired state, we have nothing to do
32426:   if (mBlockingOnload == aBlocking)
32426:     return;
32426: 
32426:   // Get the document
32426:   nsIDocument* doc = GetOurDocument();
32426: 
32426:   if (doc) {
32426:     // Take the appropriate action
32426:     if (aBlocking)
32426:       doc->BlockOnload();
32426:     else
32426:       doc->UnblockOnload(PR_FALSE);
32426: 
32426:     // Update our state
32426:     mBlockingOnload = aBlocking;
32426:   }
32426: }
35581: 
50815: nsresult
50815: nsImageLoadingContent::TrackImage(imgIRequest* aImage)
50815: {
51807:   if (!aImage)
51807:     return NS_OK;
51807: 
50815:   nsIDocument* doc = GetOurDocument();
50815:   if (doc)
50815:     return doc->AddImage(aImage);
50815:   return NS_OK;
50815: }
50815: 
50815: nsresult
50815: nsImageLoadingContent::UntrackImage(imgIRequest* aImage)
50815: {
51807:   if (!aImage)
51807:     return NS_OK;
51807: 
50815:   // If GetOurDocument() returns null here, we've outlived our document.
50815:   // That's fine, because the document empties out the tracker and unlocks
50815:   // all locked images on destruction.
50815:   nsIDocument* doc = GetOurDocument();
50815:   if (doc)
50815:     return doc->RemoveImage(aImage);
50815:   return NS_OK;
50815: }
50815: 
50815: 
35581: void
35581: nsImageLoadingContent::CreateStaticImageClone(nsImageLoadingContent* aDest) const
35581: {
35581:   aDest->mCurrentRequest = nsContentUtils::GetStaticRequest(mCurrentRequest);
51807:   aDest->TrackImage(aDest->mCurrentRequest);
35581:   aDest->mForcedImageState = mForcedImageState;
35581:   aDest->mImageBlockingStatus = mImageBlockingStatus;
35581:   aDest->mLoadingEnabled = mLoadingEnabled;
48452:   aDest->mStateChangerDepth = mStateChangerDepth;
35581:   aDest->mIsImageStateForced = mIsImageStateForced;
35581:   aDest->mLoading = mLoading;
35581:   aDest->mBroken = mBroken;
35581:   aDest->mUserDisabled = mUserDisabled;
35581:   aDest->mSuppressed = mSuppressed;
35581: }
35581: 
