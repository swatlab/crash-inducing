42410: /* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 8; -*- */
42410: /* vim: set sw=4 ts=8 et tw=80 : */
42410: /* ***** BEGIN LICENSE BLOCK *****
42410:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42410:  *
42410:  * The contents of this file are subject to the Mozilla Public License Version
42410:  * 1.1 (the "License"); you may not use this file except in compliance with
42410:  * the License. You may obtain a copy of the License at
42410:  * http://www.mozilla.org/MPL/
42410:  *
42410:  * Software distributed under the License is distributed on an "AS IS" basis,
42410:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42410:  * for the specific language governing rights and limitations under the
42410:  * License.
42410:  *
42410:  * The Original Code is Mozilla Content App.
42410:  *
42410:  * The Initial Developer of the Original Code is
42410:  *   The Mozilla Foundation.
42410:  * Portions created by the Initial Developer are Copyright (C) 2010
42410:  * the Initial Developer. All Rights Reserved.
42410:  *
42410:  * Contributor(s):
42410:  *
42410:  * Alternatively, the contents of this file may be used under the terms of
42410:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42410:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42410:  * in which case the provisions of the GPL or the LGPL are applicable instead
42410:  * of those above. If you wish to allow use of your version of this file only
42410:  * under the terms of either the GPL or the LGPL, and not to allow others to
42410:  * use your version of this file under the terms of the MPL, indicate your
42410:  * decision by deleting the provisions above and replace them with the notice
42410:  * and other provisions required by the GPL or the LGPL. If you do not delete
42410:  * the provisions above, a recipient may use your version of this file under
42410:  * the terms of any one of the MPL, the GPL or the LGPL.
42410:  *
42410:  * ***** END LICENSE BLOCK ***** */
42410: 
42410: #include "nsInProcessTabChildGlobal.h"
42410: #include "nsContentUtils.h"
42410: #include "nsIScriptSecurityManager.h"
42410: #include "nsIInterfaceRequestorUtils.h"
42410: #include "nsEventDispatcher.h"
42410: #include "nsIComponentManager.h"
42410: #include "nsIServiceManager.h"
42410: #include "nsIJSRuntimeService.h"
42410: #include "nsComponentManagerUtils.h"
42410: #include "nsNetUtil.h"
42410: #include "nsScriptLoader.h"
42410: #include "nsIJSContextStack.h"
42410: #include "nsFrameLoader.h"
42410: 
42410: bool SendSyncMessageToParent(void* aCallbackData,
42410:                              const nsAString& aMessage,
42410:                              const nsAString& aJSON,
42410:                              nsTArray<nsString>* aJSONRetVal)
42410: {
42410:   nsInProcessTabChildGlobal* tabChild =
42410:     static_cast<nsInProcessTabChildGlobal*>(aCallbackData);
43507:   nsCOMPtr<nsIContent> owner = tabChild->mOwner;
43507:   nsTArray<nsCOMPtr<nsIRunnable> > asyncMessages;
43507:   asyncMessages.SwapElements(tabChild->mASyncMessages);
43507:   PRUint32 len = asyncMessages.Length();
47868:   for (PRUint32 i = 0; i < len; ++i) {
43507:     nsCOMPtr<nsIRunnable> async = asyncMessages[i];
42410:     async->Run();
42410:   }
42410:   if (tabChild->mChromeMessageManager) {
43507:     tabChild->mChromeMessageManager->ReceiveMessage(owner, aMessage, PR_TRUE,
42410:                                                     aJSON, nsnull, aJSONRetVal);
42410:   }
42410:   return true;
42410: }
42410: 
42410: class nsAsyncMessageToParent : public nsRunnable
42410: {
42410: public:
42410:   nsAsyncMessageToParent(nsInProcessTabChildGlobal* aTabChild,
42410:                          const nsAString& aMessage, const nsAString& aJSON)
42410:     : mTabChild(aTabChild), mMessage(aMessage), mJSON(aJSON) {}
42410: 
42410:   NS_IMETHOD Run()
42410:   {
43507:     mTabChild->mASyncMessages.RemoveElement(this);
42410:     if (mTabChild->mChromeMessageManager) {
42410:       mTabChild->mChromeMessageManager->ReceiveMessage(mTabChild->mOwner, mMessage,
42410:                                                        PR_FALSE,
42410:                                                        mJSON, nsnull, nsnull);
42410:     }
42410:     return NS_OK;
42410:   }
42410:   nsRefPtr<nsInProcessTabChildGlobal> mTabChild;
42410:   nsString mMessage;
42410:   nsString mJSON;
42410: };
42410: 
42410: bool SendAsyncMessageToParent(void* aCallbackData,
42410:                               const nsAString& aMessage,
42410:                               const nsAString& aJSON)
42410: {
42410:   nsInProcessTabChildGlobal* tabChild =
42410:     static_cast<nsInProcessTabChildGlobal*>(aCallbackData);
43507:   nsCOMPtr<nsIRunnable> ev =
43507:     new nsAsyncMessageToParent(tabChild, aMessage, aJSON);
43507:   tabChild->mASyncMessages.AppendElement(ev);
42410:   NS_DispatchToCurrentThread(ev);
42410:   return true;
42410: }
42410: 
42410: nsInProcessTabChildGlobal::nsInProcessTabChildGlobal(nsIDocShell* aShell,
42410:                                                      nsIContent* aOwner,
42410:                                                      nsFrameMessageManager* aChrome)
42410: : mCx(nsnull), mDocShell(aShell), mInitialized(PR_FALSE), mLoadingScript(PR_FALSE),
42410:   mDelayedDisconnect(PR_FALSE), mOwner(aOwner), mChromeMessageManager(aChrome)
42410: {
42410: }
42410: 
42410: nsInProcessTabChildGlobal::~nsInProcessTabChildGlobal()
42410: {
42410:   Disconnect();
42410:   NS_ASSERTION(!mCx, "Couldn't release JSContext?!?");
42410: }
42410: 
42410: nsresult
42410: nsInProcessTabChildGlobal::Init()
42410: {
42410:   nsresult rv = InitTabChildGlobal();
42410:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv),
42410:                    "Couldn't initialize nsInProcessTabChildGlobal");
42410:   mMessageManager = new nsFrameMessageManager(PR_FALSE,
42410:                                               SendSyncMessageToParent,
42410:                                               SendAsyncMessageToParent,
42410:                                               nsnull,
42410:                                               this,
42410:                                               nsnull,
42410:                                               mCx);
42410:   return NS_OK;
42410: }
42410: 
42410: NS_IMPL_CYCLE_COLLECTION_CLASS(nsInProcessTabChildGlobal)
42410: 
42410: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsInProcessTabChildGlobal,
42410:                                                 nsDOMEventTargetHelper)
42410:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mMessageManager)
42410:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mGlobal)
42410: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
42410: 
42410: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsInProcessTabChildGlobal,
42410:                                                   nsDOMEventTargetHelper)
42410:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mMessageManager)
42410:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mGlobal)
42410: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
42410: 
42410: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsInProcessTabChildGlobal)
42410:   NS_INTERFACE_MAP_ENTRY(nsIFrameMessageManager)
42410:   NS_INTERFACE_MAP_ENTRY(nsIContentFrameMessageManager)
42410:   NS_INTERFACE_MAP_ENTRY(nsIInProcessContentFrameMessageManager)
42410:   NS_INTERFACE_MAP_ENTRY(nsIScriptContextPrincipal)
42410:   NS_INTERFACE_MAP_ENTRY(nsIScriptObjectPrincipal)
42410:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ContentFrameMessageManager)
42410: NS_INTERFACE_MAP_END_INHERITING(nsDOMEventTargetHelper)
42410: 
42410: NS_IMPL_ADDREF_INHERITED(nsInProcessTabChildGlobal, nsDOMEventTargetHelper)
42410: NS_IMPL_RELEASE_INHERITED(nsInProcessTabChildGlobal, nsDOMEventTargetHelper)
42410: 
42410: NS_IMETHODIMP
42410: nsInProcessTabChildGlobal::GetContent(nsIDOMWindow** aContent)
42410: {
42410:   *aContent = nsnull;
42410:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(mDocShell);
42410:   window.swap(*aContent);
42410:   return NS_OK;
42410: }
42410: 
42410: NS_IMETHODIMP
42410: nsInProcessTabChildGlobal::GetDocShell(nsIDocShell** aDocShell)
42410: {
42410:   NS_IF_ADDREF(*aDocShell = mDocShell);
42410:   return NS_OK;
42410: }
42410: 
42410: void
42410: nsInProcessTabChildGlobal::Disconnect()
42410: {
43679:   nsCOMPtr<nsIDOMWindow> win = do_GetInterface(mDocShell);
43679:   nsCOMPtr<nsPIDOMWindow> pwin = do_QueryInterface(win);
43679:   if (pwin) {
43679:     pwin->SetChromeEventHandler(pwin->GetChromeEventHandler());
43679:   }
42410:   mDocShell = nsnull;
42410:   mOwner = nsnull;
42410:   mChromeMessageManager = nsnull;
42410:   if (mMessageManager) {
42410:     static_cast<nsFrameMessageManager*>(mMessageManager.get())->Disconnect();
42410:     mMessageManager = nsnull;
42410:   }
42410:   if (!mLoadingScript) {
42410:     if (mCx) {
42410:       JS_DestroyContext(mCx);
42410:       mCx = nsnull;
42410:     }
42410:   } else {
42410:     mDelayedDisconnect = PR_TRUE;
42410:   }
42410: }
42410: 
42410: NS_IMETHODIMP_(nsIContent *)
42410: nsInProcessTabChildGlobal::GetOwnerContent()
42410: {
42410:   return mOwner;
42410: }
42410: 
42410: nsresult
42410: nsInProcessTabChildGlobal::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
42410: {
42410:   aVisitor.mCanHandle = PR_TRUE;
42410:   aVisitor.mParentTarget = mOwner;
42410: 
42410: #ifdef DEBUG
42410:   if (mOwner) {
42410:     nsCOMPtr<nsIFrameLoaderOwner> owner = do_QueryInterface(mOwner);
42410:     nsRefPtr<nsFrameLoader> fl = owner->GetFrameLoader();
42410:     if (fl) {
42410:       NS_ASSERTION(this == fl->GetTabChildGlobalAsEventTarget(),
42410:                    "Wrong event target!");
42410:       NS_ASSERTION(fl->mMessageManager == mChromeMessageManager,
42410:                    "Wrong message manager!");
42410:     }
42410:   }
42410: #endif
42410: 
42410:   return NS_OK;
42410: }
42410: 
42410: nsresult
42410: nsInProcessTabChildGlobal::InitTabChildGlobal()
42410: {
42410:   nsCOMPtr<nsIJSRuntimeService> runtimeSvc = 
42410:     do_GetService("@mozilla.org/js/xpc/RuntimeService;1");
42410:   NS_ENSURE_STATE(runtimeSvc);
42410: 
42410:   JSRuntime* rt = nsnull;
42410:   runtimeSvc->GetRuntime(&rt);
42410:   NS_ENSURE_STATE(rt);
42410: 
42410:   JSContext* cx = JS_NewContext(rt, 8192);
42410:   NS_ENSURE_STATE(cx);
42410: 
42410:   mCx = cx;
42410: 
42410:   nsContentUtils::XPConnect()->SetSecurityManagerForJSContext(cx, nsContentUtils::GetSecurityManager(), 0);
42410:   nsContentUtils::GetSecurityManager()->GetSystemPrincipal(getter_AddRefs(mPrincipal));
42410: 
42410:   PRUint32 stackDummy;
42410:   jsuword stackLimit, currentStackAddr = (jsuword)&stackDummy;
42410: 
42410:   // 256k stack space.
42410:   const jsuword kStackSize = 0x40000;
42410: 
42410: #if JS_STACK_GROWTH_DIRECTION < 0
42410:   stackLimit = (currentStackAddr > kStackSize) ?
42410:                currentStackAddr - kStackSize :
42410:                0;
42410: #else
42410:   stackLimit = (currentStackAddr + kStackSize > currentStackAddr) ?
42410:                currentStackAddr + kStackSize :
42410:                (jsuword) -1;
42410: #endif
42410: 
42410:   JS_SetThreadStackLimit(cx, stackLimit);
42410:   JS_SetScriptStackQuota(cx, 100*1024*1024);
42410: 
42410:   JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_JIT | JSOPTION_ANONFUNFIX | JSOPTION_PRIVATE_IS_NSISUPPORTS);
42410:   JS_SetVersion(cx, JSVERSION_LATEST);
42410:   JS_SetGCParameterForThread(cx, JSGC_MAX_CODE_CACHE_BYTES, 1 * 1024 * 1024);
42410: 
42410:   JSAutoRequest ar(cx);
42410:   nsIXPConnect* xpc = nsContentUtils::XPConnect();
42410:   const PRUint32 flags = nsIXPConnect::INIT_JS_STANDARD_CLASSES |
42410:                          /*nsIXPConnect::OMIT_COMPONENTS_OBJECT ?  |*/
42410:                          nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT;
42410: 
42410:   nsISupports* scopeSupports =
42410:     NS_ISUPPORTS_CAST(nsPIDOMEventTarget*, this);
42410:   JS_SetContextPrivate(cx, scopeSupports);
42410: 
42410:   nsresult rv =
42410:     xpc->InitClassesWithNewWrappedGlobal(cx, scopeSupports,
48503:                                          NS_GET_IID(nsISupports),
48503:                                          GetPrincipal(), EmptyCString(),
48503:                                          flags, getter_AddRefs(mGlobal));
42410:   NS_ENSURE_SUCCESS(rv, false);
42410: 
42410:   JSObject* global = nsnull;
42410:   rv = mGlobal->GetJSObject(&global);
42410:   NS_ENSURE_SUCCESS(rv, false);
42410: 
42410:   JS_SetGlobalObject(cx, global);
42410: 
42410:   return NS_OK;
42410: }
42410: 
42410: void
42410: nsInProcessTabChildGlobal::LoadFrameScript(const nsAString& aURL)
42410: {
42410:   if (!mInitialized) {
42410:     mInitialized = PR_TRUE;
42410:     Init();
42410:   }
42410:   if (!mGlobal || !mCx) {
42410:     return;
42410:   }
42410: 
42410:   nsCString url = NS_ConvertUTF16toUTF8(aURL);
42410:   nsCOMPtr<nsIURI> uri;
42410:   nsresult rv = NS_NewURI(getter_AddRefs(uri), url);
42410:   if (NS_FAILED(rv)) {
42410:     return;
42410:   }
42410:   nsCOMPtr<nsIChannel> channel;
42410:   NS_NewChannel(getter_AddRefs(channel), uri);
42410:   if (!channel) {
42410:     return;
42410:   }
42410: 
42410:   nsCOMPtr<nsIInputStream> input;
42410:   channel->Open(getter_AddRefs(input));
42410:   nsString dataString;
42410:   if (input) {
42410:     const PRUint32 bufferSize = 256;
42410:     char buffer[bufferSize];
42410:     nsCString data;
42410:     PRUint32 avail = 0;
42410:     input->Available(&avail);
42410:     PRUint32 read = 0;
42410:     if (avail) {
42410:       while (NS_SUCCEEDED(input->Read(buffer, bufferSize, &read)) && read) {
42410:         data.Append(buffer, read);
42410:         read = 0;
42410:       }
42410:     }
42410:     nsScriptLoader::ConvertToUTF16(channel, (PRUint8*)data.get(), data.Length(),
42410:                                    EmptyString(), nsnull, dataString);
42410:   }
42410: 
42410:   if (!dataString.IsEmpty()) {
48941:     nsContentUtils::ThreadJSContextStack()->Push(mCx);
48941:     {
48941:       // Need to scope JSAutoRequest to happen after Push but before Pop,
48941:       // at least for now. See bug 584673.
42410:       JSAutoRequest ar(mCx);
42410:       jsval retval;
42410:       JSObject* global = nsnull;
42410:       mGlobal->GetJSObject(&global);
48941:       if (global) {
42410:         JSPrincipals* jsprin = nsnull;
42410:         mPrincipal->GetJSPrincipals(mCx, &jsprin);
42410:         nsContentUtils::XPConnect()->FlagSystemFilenamePrefix(url.get(), PR_TRUE);
42410:         PRBool tmp = mLoadingScript;
42410:         mLoadingScript = PR_TRUE;
42410:         JS_EvaluateUCScriptForPrincipals(mCx, global, jsprin,
42410:                                          (jschar*)dataString.get(),
42410:                                          dataString.Length(),
42410:                                          url.get(), 1, &retval);
42410:         //XXX Argh, JSPrincipals are manually refcounted!
42410:         JSPRINCIPALS_DROP(mCx, jsprin);
42410:         mLoadingScript = tmp;
48941:       }
48941:     } 
42410:     JSContext* unused;
42410:     nsContentUtils::ThreadJSContextStack()->Pop(&unused);
42410:   }
42410:   if (!mLoadingScript && mDelayedDisconnect) {
42410:     mDelayedDisconnect = PR_FALSE;
42410:     Disconnect();
42410:   }
42410: }
