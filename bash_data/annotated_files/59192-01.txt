    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessibilityService.h"
31732: #include "nsApplicationAccessibleWrap.h"
41384: #include "nsAccUtils.h"
41384: #include "nsCoreUtils.h"
41384: #include "nsRelUtils.h"
31732: 
43504: #include "mozilla/dom/Element.h"
    1: #include "nsHTMLSelectAccessible.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeNode.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMEventListener.h"
    1: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsIDOMHTMLSelectElement.h"
 8868: #include "nsIDOMDataContainerEvent.h"
31733: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsIDOMXULMenuListElement.h"
    1: #include "nsIDOMXULMultSelectCntrlEl.h"
    1: #include "nsIDOMXULSelectCntrlItemEl.h"
    1: #include "nsIDOMXULPopupElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsIFrame.h"
 3129: #include "nsIMenuFrame.h"
  403: #include "nsIHTMLDocument.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsRootAccessible.h"
    1: #include "nsIDOMNSEventTarget.h"
    1: #include "nsIDOMDocumentEvent.h"
44176: #include "nsIPrivateDOMEvent.h"
29018: #include "nsFocusManager.h"
41930: #include "mozilla/dom/Element.h"
41634: 
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsXULTreeAccessible.h"
    1: #include "nsIXULDocument.h"
    1: #include "nsIXULWindow.h"
    1: #endif
    1: 
41930: using namespace mozilla;
41634: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsISupports
35523: 
    1: // Expanded version of NS_IMPL_ISUPPORTS_INHERITED2 
    1: // so we can QI directly to concrete nsRootAccessible
    1: NS_IMPL_QUERY_HEAD(nsRootAccessible)
    1: NS_IMPL_QUERY_BODY(nsIDOMEventListener)
    1: if (aIID.Equals(NS_GET_IID(nsRootAccessible)))
 3233:   foundInterface = reinterpret_cast<nsISupports*>(this);
    1: else
    1: NS_IMPL_QUERY_TAIL_INHERITING(nsDocAccessible)
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsRootAccessible, nsDocAccessible) 
    1: NS_IMPL_RELEASE_INHERITED(nsRootAccessible, nsDocAccessible)
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // Constructor/desctructor
35523: 
43504: nsRootAccessible::
43504:   nsRootAccessible(nsIDocument *aDocument, nsIContent *aRootContent,
43504:                    nsIWeakReference *aShell) :
43504:   nsDocAccessibleWrap(aDocument, aRootContent, aShell)
    1: {
    1: }
    1: 
    1: nsRootAccessible::~nsRootAccessible()
    1: {
    1: }
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsIAccessible
35523: 
    1: /* readonly attribute AString name; */
18347: NS_IMETHODIMP
18347: nsRootAccessible::GetName(nsAString& aName)
    1: {
18347:   aName.Truncate();
18347: 
    1:   if (!mDocument) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (mRoleMapEntry) {
    1:     nsAccessible::GetName(aName);
    1:     if (!aName.IsEmpty()) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
31733:   nsCOMPtr<nsIDOMNSDocument> document(do_QueryInterface(mDocument));
31733:   return document->GetTitle(aName);
    1: }
    1: 
52027: PRUint32
52027: nsRootAccessible::NativeRole()
    1: {
    1:   // If it's a <dialog> or <wizard>, use nsIAccessibleRole::ROLE_DIALOG instead
41930:   dom::Element *root = mDocument->GetRootElement();
41634:   if (root) {
41634:     nsCOMPtr<nsIDOMElement> rootElement(do_QueryInterface(root));
    1:     if (rootElement) {
    1:       nsAutoString name;
    1:       rootElement->GetLocalName(name);
    1:       if (name.EqualsLiteral("dialog") || name.EqualsLiteral("wizard")) {
52027:         return nsIAccessibleRole::ROLE_DIALOG; // Always at the root
    1:       }
    1:     }
    1:   }
    1: 
52027:   return nsDocAccessibleWrap::NativeRole();
    1: }
    1: 
35523: // nsRootAccessible protected member
    1: #ifdef MOZ_XUL
    1: PRUint32 nsRootAccessible::GetChromeFlags()
    1: {
    1:   // Return the flag set for the top level window as defined 
    1:   // by nsIWebBrowserChrome::CHROME_WINDOW_[FLAGNAME]
    1:   // Not simple: nsIXULWindow is not just a QI from nsIDOMWindow
 5679:   nsCOMPtr<nsIDocShellTreeItem> treeItem =
43504:     nsCoreUtils::GetDocShellTreeItemFor(mDocument);
    1:   NS_ENSURE_TRUE(treeItem, 0);
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   treeItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   NS_ENSURE_TRUE(treeOwner, 0);
    1:   nsCOMPtr<nsIXULWindow> xulWin(do_GetInterface(treeOwner));
    1:   if (!xulWin) {
    1:     return 0;
    1:   }
    1:   PRUint32 chromeFlags;
    1:   xulWin->GetChromeFlags(&chromeFlags);
    1:   return chromeFlags;
    1: }
    1: #endif
    1: 
21256: nsresult
21256: nsRootAccessible::GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState)
    1: {
21256:   nsresult rv = nsDocAccessibleWrap::GetStateInternal(aState, aExtraState);
21984:   NS_ENSURE_A11Y_SUCCESS(rv, rv);
    1: 
    1: #ifdef MOZ_XUL
    1:   PRUint32 chromeFlags = GetChromeFlags();
    1:   if (chromeFlags & nsIWebBrowserChrome::CHROME_WINDOW_RESIZE) {
    1:     *aState |= nsIAccessibleStates::STATE_SIZEABLE;
    1:   }
    1:   if (chromeFlags & nsIWebBrowserChrome::CHROME_TITLEBAR) {
    1:     // If it has a titlebar it's movable
    1:     // XXX unless it's minimized or maximized, but not sure
    1:     //     how to detect that
    1:     *aState |= nsIAccessibleStates::STATE_MOVEABLE;
    1:   }
    1: #endif
    1: 
  262:   if (!aExtraState)
    1:     return NS_OK;
    1: 
42496:   nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
42496:   if (fm) {
42496:     nsCOMPtr<nsIDOMWindow> rootWindow;
42496:     GetWindow(getter_AddRefs(rootWindow));
29018: 
29018:     nsCOMPtr<nsIDOMWindow> activeWindow;
29018:     fm->GetActiveWindow(getter_AddRefs(activeWindow));
29018:     if (activeWindow == rootWindow)
  262:       *aExtraState |= nsIAccessibleStates::EXT_STATE_ACTIVE;
    1:   }
42496: 
    1: #ifdef MOZ_XUL
    1:   if (GetChromeFlags() & nsIWebBrowserChrome::CHROME_MODAL) {
  262:     *aExtraState |= nsIAccessibleStates::EXT_STATE_MODAL;
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: const char* const docEvents[] = {
58455: #ifdef DEBUG_DRAGDROPSTART
 8862:   // Capture mouse over events and fire fake DRAGDROPSTART event to simplify
 8862:   // debugging a11y objects with event viewers
 8862:   "mouseover",
 8862: #endif
39381:   // capture DOM focus and DOM blur events 
    1:   "focus",
39381:   "blur",
    1:   // capture Form change events 
    1:   "select",
    1:   // capture ValueChange events (fired whenever value changes, immediately after, whether focus moves or not)
    1:   "ValueChange",
    1:   // capture AlertActive events (fired whenever alert pops up)
    1:   "AlertActive",
    1:   // add ourself as a TreeViewChanged listener (custom event fired in nsTreeBodyFrame.cpp)
    1:   "TreeViewChanged",
 8868:   "TreeRowCountChanged",
11389:   "TreeInvalidated",
    1:   // add ourself as a OpenStateChange listener (custom event fired in tree.xml)
    1:   "OpenStateChange",
    1:   // add ourself as a CheckboxStateChange listener (custom event fired in nsHTMLInputElement.cpp)
    1:   "CheckboxStateChange",
    1:   // add ourself as a RadioStateChange Listener ( custom event fired in in nsHTMLInputElement.cpp  & radio.xml)
    1:   "RadioStateChange",
    1:   "popupshown",
    1:   "popuphiding",
    1:   "DOMMenuInactive",
    1:   "DOMMenuItemActive",
    1:   "DOMMenuBarActive",
43310:   "DOMMenuBarInactive"
    1: };
    1: 
    1: nsresult nsRootAccessible::AddEventListeners()
    1: {
    1:   // nsIDOMNSEventTarget interface allows to register event listeners to
    1:   // receive untrusted events (synthetic events generated by untrusted code).
    1:   // For example, XBL bindings implementations for elements that are hosted in
    1:   // non chrome document fire untrusted events.
    1:   nsCOMPtr<nsIDOMNSEventTarget> nstarget(do_QueryInterface(mDocument));
    1: 
    1:   if (nstarget) {
    1:     for (const char* const* e = docEvents,
    1:                    * const* e_end = docEvents + NS_ARRAY_LENGTH(docEvents);
    1:          e < e_end; ++e) {
    1:       nsresult rv = nstarget->AddEventListener(NS_ConvertASCIItoUTF16(*e),
37183:                                                this, PR_TRUE, PR_TRUE, 1);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
    1:   if (!mCaretAccessible) {
 2395:     mCaretAccessible = new nsCaretAccessible(this);
    1:   }
    1: 
    1:   return nsDocAccessible::AddEventListeners();
    1: }
    1: 
    1: nsresult nsRootAccessible::RemoveEventListeners()
    1: {
    1:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mDocument));
    1:   if (target) { 
    1:     for (const char* const* e = docEvents,
    1:                    * const* e_end = docEvents + NS_ARRAY_LENGTH(docEvents);
    1:          e < e_end; ++e) {
    1:       nsresult rv = target->RemoveEventListener(NS_ConvertASCIItoUTF16(*e), this, PR_TRUE);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
 8373:   // Do this before removing clearing caret accessible, so that it can use
 8373:   // shutdown the caret accessible's selection listener
 8373:   nsDocAccessible::RemoveEventListeners();
 8373: 
 2395:   if (mCaretAccessible) {
 2395:     mCaretAccessible->Shutdown();
    1:     mCaretAccessible = nsnull;
    1:   }
    1: 
 8373:   return NS_OK;
    1: }
    1: 
 2401: nsCaretAccessible*
 2395: nsRootAccessible::GetCaretAccessible()
    1: {
 2401:   return mCaretAccessible;
    1: }
    1: 
59126: void
59126: nsRootAccessible::FireAccessibleFocusEvent(nsAccessible* aFocusAccessible,
59126:                                            nsIContent* aRealFocusContent,
 4516:                                            PRBool aForceEvent,
37339:                                            EIsFromUserInput aIsFromUserInput)
    1: {
43636:   // Implementors: only fire delayed/async events from this method.
43636: 
59126:   // Set selection listener for focused element.
59126:   if (mCaretAccessible && aRealFocusContent)
59126:     mCaretAccessible->SetControlSelectionListener(aRealFocusContent);
59126: 
59126:   nsAccessible* focusAccessible = aFocusAccessible;
59126: 
59126:   // Check for aria-activedescendant, which changes which element has focus.
59126:   // For activedescendant, the ARIA spec does not require that the user agent
59126:   // checks whether pointed node is actually a DOM descendant of the element
59126:   // with the aria-activedescendant attribute.
59126:   nsIContent* content = focusAccessible->GetContent();
59126:   if (content) {
59126:     nsAutoString id;
59126:     if (content->GetAttr(kNameSpaceID_None,
59126:                          nsAccessibilityAtoms::aria_activedescendant, id)) {
59126:       nsIDocument* DOMDoc = content->GetOwnerDoc();
59126:       nsIContent* activeDescendantContent = DOMDoc->GetElementById(id);
59126: 
59126:       // If aria-activedescendant is set to nonexistant ID, then treat as focus
59126:       // on the activedescendant container (which has real DOM focus).
59126:       if (activeDescendantContent) {
59192:         nsAccessible* activeDescendant = 
59126:           GetAccService()->GetAccessible(activeDescendantContent);
59192:         if (activeDescendant) {
59192:           focusAccessible = activeDescendant;
59192:         }
    1:       }
    1:     }
    1:   }
    1: 
59126:   // Fire focus only if it changes, but always fire focus events when
59126:   // aForceEvent == PR_TRUE
59126:   nsINode* focusNode = focusAccessible->GetNode();
59126:   if (gLastFocusedNode == focusNode && !aForceEvent)
59126:     return;
20566: 
59161:   nsDocAccessible* focusDocument = focusAccessible->GetDocAccessible();
59161:   NS_ASSERTION(focusDocument, "No document while accessible is in document?!");
59161: 
59126:   gLastFocusedAccessiblesState = nsAccUtils::State(focusAccessible);
12641: 
59126:   // Fire menu start/end events for ARIA menus.
59126:   if (focusAccessible->ARIARole() == nsIAccessibleRole::ROLE_MENUITEM) {
59126:     // The focus is inside a menu.
59126:     if (!mCurrentARIAMenubar) {
59126:       // Entering ARIA menu. Fire menu start event.
43504:       nsAccessible* menuBarAccessible =
59126:         nsAccUtils::GetAncestorWithRole(focusAccessible,
20521:                                         nsIAccessibleRole::ROLE_MENUBAR);
43504:       if (menuBarAccessible) {
43504:         mCurrentARIAMenubar = menuBarAccessible->GetNode();
 4846:         if (mCurrentARIAMenubar) {
51377:           nsRefPtr<AccEvent> menuStartEvent =
51377:             new AccEvent(nsIAccessibleEvent::EVENT_MENU_START,
56292:                          menuBarAccessible, aIsFromUserInput,
51377:                          AccEvent::eAllowDupes);
59126:           if (menuStartEvent)
59161:             focusDocument->FireDelayedAccessibleEvent(menuStartEvent);
43636:         }
 7760:       }
    1:     }
    1:   }
 4846:   else if (mCurrentARIAMenubar) {
59126:     // Focus left a menu. Fire menu end event.
51377:     nsRefPtr<AccEvent> menuEndEvent =
51377:       new AccEvent(nsIAccessibleEvent::EVENT_MENU_END, mCurrentARIAMenubar,
56292:                    aIsFromUserInput, AccEvent::eAllowDupes);
 4846:     if (menuEndEvent) {
59161:       focusDocument->FireDelayedAccessibleEvent(menuEndEvent);
 4846:     }
 4846:     mCurrentARIAMenubar = nsnull;
    1:   }
    1: 
    1:   NS_IF_RELEASE(gLastFocusedNode);
59126:   gLastFocusedNode = focusNode;
    1:   NS_IF_ADDREF(gLastFocusedNode);
    1: 
39509:   // Coalesce focus events from the same document, because DOM focus event might
39509:   // be fired for the document node and then for the focused DOM element.
59161:   focusDocument->FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_FOCUS,
59161:                                             focusNode,
59161:                                             AccEvent::eCoalesceFromSameDocument,
56292:                                             aIsFromUserInput);
    1: }
    1: 
37480: void
37480: nsRootAccessible::FireCurrentFocusEvent()
    1: {
37480:   if (IsDefunct())
37480:     return;
37480: 
46469:   // Simulate a focus event so that we can reuse code that fires focus for
46469:   // container children like treeitems.
43504:   nsCOMPtr<nsINode> focusedNode = GetCurrentFocus();
  488:   if (!focusedNode) {
  488:     return; // No current focus
  488:   }
    1: 
    1:   nsCOMPtr<nsIDOMDocumentEvent> docEvent = do_QueryInterface(mDocument);
    1:   if (docEvent) {
    1:     nsCOMPtr<nsIDOMEvent> event;
    1:     if (NS_SUCCEEDED(docEvent->CreateEvent(NS_LITERAL_STRING("Events"),
    1:                                            getter_AddRefs(event))) &&
    1:         NS_SUCCEEDED(event->InitEvent(NS_LITERAL_STRING("focus"), PR_TRUE, PR_TRUE))) {
39566: 
44176:       nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
44176:       nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(focusedNode));
44176:       privateEvent->SetTarget(target);
46469:       HandleEvent(event);
    1:     }
    1:   }
    1: }
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsIDOMEventListener
    1: 
46469: NS_IMETHODIMP
46469: nsRootAccessible::HandleEvent(nsIDOMEvent* aEvent)
    1: {
46469:   nsCOMPtr<nsIDOMNSEvent> nsevent(do_QueryInterface(aEvent));
46469:   NS_ENSURE_STATE(nsevent);
    1: 
46469:   nsCOMPtr<nsIDOMEventTarget> domEventTarget;
46469:   nsevent->GetOriginalTarget(getter_AddRefs(domEventTarget));
46469:   nsCOMPtr<nsINode> origTarget(do_QueryInterface(domEventTarget));
46469:   NS_ENSURE_STATE(origTarget);
    1: 
    1:   nsAutoString eventType;
    1:   aEvent->GetType(eventType);
    1: 
43504:   nsCOMPtr<nsIWeakReference> weakShell =
46469:     nsCoreUtils::GetWeakShellFor(origTarget);
43504:   if (!weakShell)
 8471:     return NS_OK;
 8471: 
42313:   nsAccessible* accessible =
46469:     GetAccService()->GetAccessibleOrContainer(origTarget, weakShell);
22209: 
22209:   if (eventType.EqualsLiteral("popuphiding"))
46469:     return HandlePopupHidingEvent(origTarget, accessible);
22209: 
42313:   if (!accessible)
    1:     return NS_OK;
    1: 
59161:   nsDocAccessible* targetDocument = accessible->GetDocAccessible();
59161:   NS_ASSERTION(targetDocument, "No document while accessible is in document?!");
59161: 
46469:   nsINode* targetNode = accessible->GetNode();
46469:   nsIContent* targetContent = targetNode->IsElement() ?
46469:     targetNode->AsElement() : nsnull;
10594: #ifdef MOZ_XUL
46469:   PRBool isTree = targetContent ?
46469:     targetContent->NodeInfo()->Equals(nsAccessibilityAtoms::tree,
46469:                                       kNameSpaceID_XUL) : PR_FALSE;
46469: 
15375:   if (isTree) {
41373:     nsRefPtr<nsXULTreeAccessible> treeAcc = do_QueryObject(accessible);
15375:     NS_ASSERTION(treeAcc,
29825:                  "Accessible for xul:tree isn't nsXULTreeAccessible.");
15375: 
15375:     if (treeAcc) {
29825:       if (eventType.EqualsLiteral("TreeViewChanged")) {
29825:         treeAcc->TreeViewChanged();
29825:         return NS_OK;
29825:       }
15375: 
11389:       if (eventType.EqualsLiteral("TreeRowCountChanged"))
15375:         return HandleTreeRowCountChangedEvent(aEvent, treeAcc);
 8868:       
11389:       if (eventType.EqualsLiteral("TreeInvalidated"))
15375:         return HandleTreeInvalidatedEvent(aEvent, treeAcc);
15375:     }
15375:   }
10594: #endif
 8868: 
  589:   if (eventType.EqualsLiteral("RadioStateChange")) {
20566:     PRUint32 state = nsAccUtils::State(accessible);
 1510: 
 1510:     // radiogroup in prefWindow is exposed as a list,
 1510:     // and panebutton is exposed as XULListitem in A11y.
21256:     // nsXULListitemAccessible::GetStateInternal uses STATE_SELECTED in this case,
 1510:     // so we need to check nsIAccessibleStates::STATE_SELECTED also.
 1510:     PRBool isEnabled = (state & (nsIAccessibleStates::STATE_CHECKED |
 1510:                         nsIAccessibleStates::STATE_SELECTED)) != 0;
  589: 
51377:     nsRefPtr<AccEvent> accEvent =
51377:       new AccStateChangeEvent(accessible, nsIAccessibleStates::STATE_CHECKED,
  589:                               PR_FALSE, isEnabled);
37282:     nsEventShell::FireEvent(accEvent);
  589: 
  589:     if (isEnabled)
59126:       FireAccessibleFocusEvent(accessible, targetContent);
  589: 
  589:     return NS_OK;
  589:   }
  589: 
  589:   if (eventType.EqualsLiteral("CheckboxStateChange")) {
20566:     PRUint32 state = nsAccUtils::State(accessible);
  589: 
 6667:     PRBool isEnabled = !!(state & nsIAccessibleStates::STATE_CHECKED);
  589: 
51377:     nsRefPtr<AccEvent> accEvent =
51377:       new AccStateChangeEvent(accessible, nsIAccessibleStates::STATE_CHECKED,
  589:                               PR_FALSE, isEnabled);
  589: 
37282:     nsEventShell::FireEvent(accEvent);
37282:     return NS_OK;
  589:   }
  589: 
42313:   nsAccessible *treeItemAccessible = nsnull;
    1: #ifdef MOZ_XUL
    1:   // If it's a tree element, need the currently selected item
10594:   if (isTree) {
    1:     nsCOMPtr<nsIDOMXULMultiSelectControlElement> multiSelect =
46469:       do_QueryInterface(targetNode);
    1:     if (multiSelect) {
    1:       PRInt32 treeIndex = -1;
    1:       multiSelect->GetCurrentIndex(&treeIndex);
    1:       if (treeIndex >= 0) {
41373:         nsRefPtr<nsXULTreeAccessible> treeAcc = do_QueryObject(accessible);
31673:         if (treeAcc) {
39191:           treeItemAccessible = treeAcc->GetTreeItemAccessible(treeIndex);
29825:           if (treeItemAccessible)
29825:             accessible = treeItemAccessible;
    1:         }
    1:       }
    1:     }
    1:   }
    1: #endif
    1: 
  589: #ifdef MOZ_XUL
  589:   if (treeItemAccessible && eventType.EqualsLiteral("OpenStateChange")) {
20566:     PRUint32 state = nsAccUtils::State(accessible); // collapsed/expanded changed
  589:     PRBool isEnabled = (state & nsIAccessibleStates::STATE_EXPANDED) != 0;
    1: 
51377:     nsRefPtr<AccEvent> accEvent =
51377:       new AccStateChangeEvent(accessible, nsIAccessibleStates::STATE_EXPANDED,
  589:                               PR_FALSE, isEnabled);
37282:     nsEventShell::FireEvent(accEvent);
37282:     return NS_OK;
    1:   }
  589: 
  589:   if (treeItemAccessible && eventType.EqualsLiteral("select")) {
    1:     // If multiselect tree, we should fire selectionadd or selection removed
46469:     if (gLastFocusedNode == targetNode) {
    1:       nsCOMPtr<nsIDOMXULMultiSelectControlElement> multiSel =
46469:         do_QueryInterface(targetNode);
    1:       nsAutoString selType;
    1:       multiSel->GetSelType(selType);
    1:       if (selType.IsEmpty() || !selType.EqualsLiteral("single")) {
  431:         // XXX: We need to fire EVENT_SELECTION_ADD and EVENT_SELECTION_REMOVE
  431:         // for each tree item. Perhaps each tree item will need to cache its
  431:         // selection state and fire an event after a DOM "select" event when
  431:         // that state changes. nsXULTreeAccessible::UpdateTreeSelection();
37281:         nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SELECTION_WITHIN,
 3152:                                 accessible);
37281:         return NS_OK;
    1:       }
  431: 
37281:       nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SELECTION,
 3152:                               treeItemAccessible);
37281:       return NS_OK;
    1:     }
    1:   }
    1:   else
    1: #endif
  431:   if (eventType.EqualsLiteral("focus")) {
    1:     // Keep a reference to the target node. We might want to change
    1:     // it to the individual radio button or selected item, and send
    1:     // the focus event to that.
46469:     nsCOMPtr<nsINode> focusedItem = targetNode;
  431:     if (!treeItemAccessible) {
  431:       nsCOMPtr<nsIDOMXULSelectControlElement> selectControl =
46469:         do_QueryInterface(targetNode);
    1:       if (selectControl) {
    1:         nsCOMPtr<nsIDOMXULMenuListElement> menuList =
46469:           do_QueryInterface(targetNode);
    1:         if (!menuList) {
    1:           // Don't do this for menu lists, the items only get focused
    1:           // when the list is open, based on DOMMenuitemActive events
    1:           nsCOMPtr<nsIDOMXULSelectControlItemElement> selectedItem;
    1:           selectControl->GetSelectedItem(getter_AddRefs(selectedItem));
  431:           if (selectedItem)
    1:             focusedItem = do_QueryInterface(selectedItem);
    1: 
    1:           if (!focusedItem)
    1:             return NS_OK;
    1: 
46469:           accessible = GetAccService()->GetAccessibleInWeakShell(focusedItem,
43504:                                                                  weakShell);
    1:           if (!accessible)
    1:             return NS_OK;
    1:         }
    1:       }
  431:     }
59126:     FireAccessibleFocusEvent(accessible, targetContent);
    1:   }
39381:   else if (eventType.EqualsLiteral("blur")) {
39385:     NS_IF_RELEASE(gLastFocusedNode);
39381:     gLastFocusedAccessiblesState = 0;
39381:   }
    1:   else if (eventType.EqualsLiteral("AlertActive")) { 
37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_ALERT, accessible);
    1:   }
 1937:   else if (eventType.EqualsLiteral("popupshown")) {
22209:     HandlePopupShownEvent(accessible);
 1671:   }
    1:   else if (eventType.EqualsLiteral("DOMMenuInactive")) {
52089:     if (accessible->Role() == nsIAccessibleRole::ROLE_MENUPOPUP) {
37281:       nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_END,
 3152:                               accessible);
    1:     }
    1:   }
  431:   else if (eventType.EqualsLiteral("DOMMenuItemActive")) {
12366:     PRBool fireFocus = PR_FALSE;
  431:     if (!treeItemAccessible) {
10594: #ifdef MOZ_XUL
10594:       if (isTree) {
10594:         return NS_OK; // Tree with nothing selected
10594:       }
10594: #endif
42313:       nsIFrame* menuFrame = accessible->GetFrame();
 3129:       NS_ENSURE_TRUE(menuFrame, NS_ERROR_FAILURE);
21169: 
23554:       nsIMenuFrame* imenuFrame = do_QueryFrame(menuFrame);
12366:       if (imenuFrame)
12366:         fireFocus = PR_TRUE;
 3768:       // QI failed for nsIMenuFrame means it's not on menu bar
 3768:       if (imenuFrame && imenuFrame->IsOnMenuBar() &&
 3768:                        !imenuFrame->IsOnActiveMenuBar()) {
 1087:         // It is a top level menuitem. Only fire a focus event when the menu bar
  431:         // is active.
    1:         return NS_OK;
  431:       } else {
42313:         nsAccessible *containerAccessible = accessible->GetParent();
 3129:         NS_ENSURE_TRUE(containerAccessible, NS_ERROR_FAILURE);
    1:         // It is not top level menuitem
    1:         // Only fire focus event if it is not inside collapsed popup
 7195:         // and not a listitem of a combo box
20566:         if (nsAccUtils::State(containerAccessible) & nsIAccessibleStates::STATE_COLLAPSED) {
42313:           nsAccessible *containerParent = containerAccessible->GetParent();
 7195:           NS_ENSURE_TRUE(containerParent, NS_ERROR_FAILURE);
52089:           if (containerParent->Role() != nsIAccessibleRole::ROLE_COMBOBOX) {
    1:             return NS_OK;
    1:           }
  431:         }
 7195:       }
 7195:     }
12366:     if (!fireFocus) {
43504:       nsCOMPtr<nsINode> realFocusedNode = GetCurrentFocus();
51378:       nsIContent* realFocusedContent =
51378:         realFocusedNode->IsElement() ? realFocusedNode->AsElement() : nsnull;
12366:       nsIContent* containerContent = targetContent;
12366:       while (containerContent) {
12366:         nsCOMPtr<nsIDOMXULPopupElement> popup = do_QueryInterface(containerContent);
12366:         if (popup || containerContent == realFocusedContent) { 
12366:           // If we're inside the focus or a popup we can fire focus events
12366:           // for the changed active item
12366:           fireFocus = PR_TRUE;
12366:           break;
12366:         }
12366:         containerContent = containerContent->GetParent();
12366:       }
12366:     }
12366:     if (fireFocus) {
37339:       // Always asynch, always from user input.
59126:       FireAccessibleFocusEvent(accessible, targetContent, PR_TRUE,
56292:                                eFromUserInput);
    1:     }
12366:   }
56292:   else if (eventType.EqualsLiteral("DOMMenuBarActive")) {  // Always from user input
37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_MENU_START,
56292:                             accessible, eFromUserInput);
    1:   }
56292:   else if (eventType.EqualsLiteral("DOMMenuBarInactive")) {  // Always from user input
37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_MENU_END,
56292:                             accessible, eFromUserInput);
    1:     FireCurrentFocusEvent();
    1:   }
    1:   else if (eventType.EqualsLiteral("ValueChange")) {
59161:     targetDocument->
32196:       FireDelayedAccessibleEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE,
51377:                                  targetNode, AccEvent::eRemoveDupes);
    1:   }
58455: #ifdef DEBUG_DRAGDROPSTART
 8862:   else if (eventType.EqualsLiteral("mouseover")) {
37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_DRAGDROP_START,
20521:                             accessible);
 8862:   }
 8862: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // nsAccessNode
35523: 
43538: void
21169: nsRootAccessible::Shutdown()
    1: {
 6794:   // Called manually or by nsAccessNode::LastRelease()
43538:   if (!mWeakShell)
43538:     return;  // Already shutdown
 6794: 
 4846:   mCurrentARIAMenubar = nsnull;
 4846: 
43538:   nsDocAccessibleWrap::Shutdown();
    1: }
    1: 
35523: // nsRootAccessible protected member
    1: already_AddRefed<nsIDocShellTreeItem>
    1: nsRootAccessible::GetContentDocShell(nsIDocShellTreeItem *aStart)
    1: {
    1:   if (!aStart) {
    1:     return nsnull;
    1:   }
    1: 
    1:   PRInt32 itemType;
    1:   aStart->GetItemType(&itemType);
    1:   if (itemType == nsIDocShellTreeItem::typeContent) {
43310:     nsDocAccessible *accDoc = nsAccUtils::GetDocAccessibleFor(aStart);
25589: 
25589:     // Hidden documents don't have accessibles (like SeaMonkey's sidebar),
25589:     // they are of no interest for a11y.
25589:     if (!accDoc)
25589:       return nsnull;
25589: 
    1:     // If ancestor chain of accessibles is not completely visible,
    1:     // don't use this one. This happens for example if it's inside
    1:     // a background tab (tabbed browsing)
43310:     nsAccessible *parent = accDoc->GetParent();
43310:     while (parent) {
43310:       if (nsAccUtils::State(parent) & nsIAccessibleStates::STATE_INVISIBLE)
    1:         return nsnull;
20566: 
43310:       if (parent == this)
 5448:         break; // Don't check past original root accessible we started with
43310: 
43310:       parent = parent->GetParent();
    1:     }
    1: 
    1:     NS_ADDREF(aStart);
    1:     return aStart;
    1:   }
    1:   nsCOMPtr<nsIDocShellTreeNode> treeNode(do_QueryInterface(aStart));
    1:   if (treeNode) {
    1:     PRInt32 subDocuments;
    1:     treeNode->GetChildCount(&subDocuments);
    1:     for (PRInt32 count = 0; count < subDocuments; count ++) {
    1:       nsCOMPtr<nsIDocShellTreeItem> treeItemChild, contentTreeItem;
    1:       treeNode->GetChildAt(count, getter_AddRefs(treeItemChild));
    1:       NS_ENSURE_TRUE(treeItemChild, nsnull);
    1:       contentTreeItem = GetContentDocShell(treeItemChild);
    1:       if (contentTreeItem) {
    1:         NS_ADDREF(aStart = contentTreeItem);
    1:         return aStart;
    1:       }
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
35523: // nsIAccessible method
24822: NS_IMETHODIMP
24822: nsRootAccessible::GetRelationByType(PRUint32 aRelationType,
24822:                                     nsIAccessibleRelation **aRelation)
    1: {
24822:   NS_ENSURE_ARG_POINTER(aRelation);
24822:   *aRelation = nsnull;
    1: 
43504:   if (!mDocument || aRelationType != nsIAccessibleRelation::RELATION_EMBEDS) {
24822:     return nsDocAccessibleWrap::GetRelationByType(aRelationType, aRelation);
    1:   }
    1: 
 5679:   nsCOMPtr<nsIDocShellTreeItem> treeItem =
43504:     nsCoreUtils::GetDocShellTreeItemFor(mDocument);
    1:   nsCOMPtr<nsIDocShellTreeItem> contentTreeItem = GetContentDocShell(treeItem);
    1:   // there may be no content area, so we need a null check
    1:   if (contentTreeItem) {
43310:     nsDocAccessible *accDoc = nsAccUtils::GetDocAccessibleFor(contentTreeItem);
43310:     return nsRelUtils::AddTarget(aRelationType, aRelation, accDoc);
    1:   }
24822: 
    1:   return NS_OK;
    1: }
    1: 
35523: ////////////////////////////////////////////////////////////////////////////////
35523: // Protected members
35523: 
22209: nsresult
43504: nsRootAccessible::HandlePopupShownEvent(nsAccessible *aAccessible)
22209: {
52089:   PRUint32 role = aAccessible->Role();
22209: 
22209:   if (role == nsIAccessibleRole::ROLE_MENUPOPUP) {
22209:     // Don't fire menupopup events for combobox and autocomplete lists.
37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_MENUPOPUP_START,
22209:                             aAccessible);
37281:     return NS_OK;
22209:   }
22209: 
22209:   if (role == nsIAccessibleRole::ROLE_TOOLTIP) {
22209:     // There is a single <xul:tooltip> node which Mozilla moves around.
22209:     // The accessible for it stays the same no matter where it moves. 
22209:     // AT's expect to get an EVENT_SHOW for the tooltip. 
22209:     // In event callback the tooltip's accessible will be ready.
37281:     nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SHOW, aAccessible);
37281:     return NS_OK;
22209:   }
22209: 
22209:   if (role == nsIAccessibleRole::ROLE_COMBOBOX_LIST) {
22209:     // Fire expanded state change event for comboboxes and autocompeletes.
52089:     nsAccessible* combobox = aAccessible->GetParent();
52089:     NS_ENSURE_STATE(combobox);
52089: 
52089:     PRUint32 comboboxRole = combobox->Role();
22209:     if (comboboxRole == nsIAccessibleRole::ROLE_COMBOBOX ||
22209:         comboboxRole == nsIAccessibleRole::ROLE_AUTOCOMPLETE) {
51377:       nsRefPtr<AccEvent> event =
52089:         new AccStateChangeEvent(combobox,
22209:                                 nsIAccessibleStates::STATE_EXPANDED,
22209:                                 PR_FALSE, PR_TRUE);
22209:       NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
22209: 
37282:       nsEventShell::FireEvent(event);
37282:       return NS_OK;
22209:     }
22209:   }
22209: 
22209:   return NS_OK;
22209: }
22209: 
22209: nsresult
43504: nsRootAccessible::HandlePopupHidingEvent(nsINode *aNode,
43504:                                          nsAccessible *aAccessible)
22209: {
22209:   // If accessible focus was on or inside popup that closes, then restore it
22209:   // to true current focus. This is the case when we've been getting
22209:   // DOMMenuItemActive events inside of a combo box that closes. The real focus
22209:   // is on the combo box. It's also the case when a popup gets focus in ATK --
22209:   // when it closes we need to fire an event to restore focus to where it was.
37539: 
22209:   if (gLastFocusedNode &&
43504:       nsCoreUtils::IsAncestorOf(aNode, gLastFocusedNode)) {
22209:     // Focus was on or inside of a popup that's being hidden
22209:     FireCurrentFocusEvent();
22209:   }
22209: 
22209:   // Fire expanded state change event for comboboxes and autocompletes.
22209:   if (!aAccessible)
22209:     return NS_OK;
22209: 
52089:   if (aAccessible->Role() != nsIAccessibleRole::ROLE_COMBOBOX_LIST)
22209:     return NS_OK;
22209: 
52089:   nsAccessible* combobox = aAccessible->GetParent();
52089:   NS_ENSURE_STATE(combobox);
52089: 
52089:   PRUint32 comboboxRole = combobox->Role();
22209:   if (comboboxRole == nsIAccessibleRole::ROLE_COMBOBOX ||
22209:       comboboxRole == nsIAccessibleRole::ROLE_AUTOCOMPLETE) {
51377:     nsRefPtr<AccEvent> event =
52089:       new AccStateChangeEvent(combobox,
22209:                               nsIAccessibleStates::STATE_EXPANDED,
22209:                               PR_FALSE, PR_FALSE);
22209:     NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
22209: 
37282:     nsEventShell::FireEvent(event);
37282:     return NS_OK;
22209:   }
22209: 
22209:   return NS_OK;
22209: }
22209: 
18844: #ifdef MOZ_XUL
11389: nsresult
11389: nsRootAccessible::HandleTreeRowCountChangedEvent(nsIDOMEvent *aEvent,
29825:                                                  nsXULTreeAccessible *aAccessible)
11389: {
11389:   nsCOMPtr<nsIDOMDataContainerEvent> dataEvent(do_QueryInterface(aEvent));
11389:   if (!dataEvent)
11389:     return NS_OK;
11389: 
11389:   nsCOMPtr<nsIVariant> indexVariant;
11389:   dataEvent->GetData(NS_LITERAL_STRING("index"),
11389:                      getter_AddRefs(indexVariant));
11389:   if (!indexVariant)
11389:     return NS_OK;
11389: 
11389:   nsCOMPtr<nsIVariant> countVariant;
11389:   dataEvent->GetData(NS_LITERAL_STRING("count"),
11389:                      getter_AddRefs(countVariant));
11389:   if (!countVariant)
11389:     return NS_OK;
11389: 
11389:   PRInt32 index, count;
11389:   indexVariant->GetAsInt32(&index);
11389:   countVariant->GetAsInt32(&count);
11389: 
29825:   aAccessible->InvalidateCache(index, count);
29825:   return NS_OK;
11389: }
11389: 
11389: nsresult
11389: nsRootAccessible::HandleTreeInvalidatedEvent(nsIDOMEvent *aEvent,
29825:                                              nsXULTreeAccessible *aAccessible)
11389: {
11389:   nsCOMPtr<nsIDOMDataContainerEvent> dataEvent(do_QueryInterface(aEvent));
11389:   if (!dataEvent)
11389:     return NS_OK;
11389: 
11389:   PRInt32 startRow = 0, endRow = -1, startCol = 0, endCol = -1;
11389: 
11389:   nsCOMPtr<nsIVariant> startRowVariant;
11389:   dataEvent->GetData(NS_LITERAL_STRING("startrow"),
11389:                      getter_AddRefs(startRowVariant));
11389:   if (startRowVariant)
11389:     startRowVariant->GetAsInt32(&startRow);
11389: 
11389:   nsCOMPtr<nsIVariant> endRowVariant;
11389:   dataEvent->GetData(NS_LITERAL_STRING("endrow"),
11389:                      getter_AddRefs(endRowVariant));
11389:   if (endRowVariant)
11389:     endRowVariant->GetAsInt32(&endRow);
11389: 
11389:   nsCOMPtr<nsIVariant> startColVariant;
11389:   dataEvent->GetData(NS_LITERAL_STRING("startcolumn"),
11389:                      getter_AddRefs(startColVariant));
11389:   if (startColVariant)
11389:     startColVariant->GetAsInt32(&startCol);
11389: 
11389:   nsCOMPtr<nsIVariant> endColVariant;
11389:   dataEvent->GetData(NS_LITERAL_STRING("endcolumn"),
11389:                      getter_AddRefs(endColVariant));
11389:   if (endColVariant)
11389:     endColVariant->GetAsInt32(&endCol);
11389: 
29825:   aAccessible->TreeViewInvalidated(startRow, endRow, startCol, endCol);
29825:   return NS_OK;
11389: }
18844: #endif
11389: 
