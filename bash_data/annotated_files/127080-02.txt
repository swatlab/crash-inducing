     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 99568: #ifndef mozilla_a11y_DocAccessible_h__
 99568: #define mozilla_a11y_DocAccessible_h__
     1: 
 89309: #include "nsIAccessibleCursorable.h"
 43310: #include "nsIAccessibleDocument.h"
 89309: #include "nsIAccessiblePivot.h"
 43310: 
106800: #include "AccEvent.h"
 99901: #include "HyperTextAccessibleWrap.h"
 41384: 
 57845: #include "nsClassHashtable.h"
 57845: #include "nsDataHashtable.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDocumentObserver.h"
     1: #include "nsIEditor.h"
     1: #include "nsIObserver.h"
     1: #include "nsIScrollPositionListener.h"
     1: #include "nsITimer.h"
     1: #include "nsIWeakReference.h"
     1: #include "nsIDocShellTreeNode.h"
     1: 
122283: class nsAccessiblePivot;
100057: 
     1: class nsIScrollableView;
     1: 
108991: const uint32_t kDefaultCacheSize = 256;
     1: 
110522: namespace mozilla {
110522: namespace a11y {
110522: 
123625: class DocManager;
122283: class NotificationController;
110522: class RelatedAccIterator;
122283: template<class Class, class Arg>
122283: class TNotification;
110522: 
 99901: class DocAccessible : public HyperTextAccessibleWrap,
     1:                       public nsIAccessibleDocument,
     1:                       public nsIDocumentObserver,
     1:                       public nsIObserver,
     1:                       public nsIScrollPositionListener,
 89309:                       public nsSupportsWeakReference,
 89309:                       public nsIAccessibleCursorable,
 89309:                       public nsIAccessiblePivotObserver
     1: {
     1:   NS_DECL_ISUPPORTS_INHERITED
 99648:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(DocAccessible, Accessible)
 16428: 
     1:   NS_DECL_NSIACCESSIBLEDOCUMENT
 29564: 
     1:   NS_DECL_NSIOBSERVER
     1: 
 89309:   NS_DECL_NSIACCESSIBLECURSORABLE
 89309: 
 89309:   NS_DECL_NSIACCESSIBLEPIVOTOBSERVER
 89309: 
     1: public:
 50861: 
 99568:   DocAccessible(nsIDocument* aDocument, nsIContent* aRootContent,
 89801:                 nsIPresShell* aPresShell);
 99568:   virtual ~DocAccessible();
     1: 
 25822:   // nsIAccessible
     1:   NS_IMETHOD TakeFocus(void);
     1: 
 29564:   // nsIScrollPositionListener
 37871:   virtual void ScrollPositionWillChange(nscoord aX, nscoord aY) {}
 37871:   virtual void ScrollPositionDidChange(nscoord aX, nscoord aY);
     1: 
     1:   // nsIDocumentObserver
     1:   NS_DECL_NSIDOCUMENTOBSERVER
     1: 
 21169:   // nsAccessNode
123601:   virtual void Init();
 43538:   virtual void Shutdown();
 62920:   virtual nsIFrame* GetFrame() const;
123924:   virtual nsINode* GetNode() const { return mDocumentNode; }
123924:   nsIDocument* DocumentNode() const { return mDocumentNode; }
     1: 
 99648:   // Accessible
 97369:   virtual mozilla::a11y::ENameValueFlag Name(nsString& aName);
 69342:   virtual void Description(nsString& aDescription);
 99648:   virtual Accessible* FocusedChild();
 87094:   virtual mozilla::a11y::role NativeRole();
108991:   virtual uint64_t NativeState();
108991:   virtual uint64_t NativeInteractiveState() const;
100246:   virtual bool NativelyUnavailable() const;
108991:   virtual void ApplyARIAState(uint64_t* aState) const;
119399:   virtual already_AddRefed<nsIPersistentProperties> Attributes();
 35523: 
116102: #ifdef A11Y_LOG
 99203:   virtual nsresult HandleAccEvent(AccEvent* aEvent);
 43310: #endif
 43310: 
 97942:   virtual void GetBoundsRect(nsRect& aRect, nsIFrame** aRelativeFrame);
 97942: 
 99901:   // HyperTextAccessible
 91761:   virtual already_AddRefed<nsIEditor> GetEditor() const;
  4625: 
 99568:   // DocAccessible
 29564: 
 43310:   /**
 89799:    * Return presentation shell for this document accessible.
 89799:    */
 89799:   nsIPresShell* PresShell() const { return mPresShell; }
 89799: 
 89799:   /**
 95120:    * Return the presentation shell's context.
 95120:    */
 95120:   nsPresContext* PresContext() const { return mPresShell->GetPresContext(); }
 95120:     
 95120:   /**
 43310:    * Return true if associated DOM document was loaded and isn't unloading.
 43310:    */
 79445:   bool IsContentLoaded() const
 43310:   {
 75013:     // eDOMLoaded flag check is used for error pages as workaround to make this
 75013:     // method return correct result since error pages do not receive 'pageshow'
 75013:     // event and as consequence nsIDocument::IsShowing() returns false.
123924:     return mDocumentNode && mDocumentNode->IsVisible() &&
123924:       (mDocumentNode->IsShowing() || HasLoadState(eDOMLoaded));
 43310:   }
 43310: 
 43310:   /**
 75013:    * Document load states.
 43310:    */
 75013:   enum LoadState {
 75013:     // initial tree construction is pending
 75013:     eTreeConstructionPending = 0,
 75013:     // initial tree construction done
 75013:     eTreeConstructed = 1,
 75013:     // DOM document is loaded.
 75013:     eDOMLoaded = 1 << 1,
 75013:     // document is ready
 75013:     eReady = eTreeConstructed | eDOMLoaded,
 75013:     // document and all its subdocuments are ready
 75013:     eCompletelyLoaded = eReady | 1 << 2
 75013:   };
 75013: 
 75013:   /**
 75013:    * Return true if the document has given document state.
 75013:    */
 75013:   bool HasLoadState(LoadState aState) const
108991:     { return (mLoadState & static_cast<uint32_t>(aState)) == 
108991:         static_cast<uint32_t>(aState); }
 43310: 
  4516:   /**
 54220:    * Return a native window handler or pointer depending on platform.
 54220:    */
 54220:   virtual void* GetNativeWindow() const;
 54220: 
 54220:   /**
 52279:    * Return the parent document.
 52279:    */
100122:   DocAccessible* ParentDocument() const
106838:     { return mParent ? mParent->Document() : nullptr; }
 52279: 
 52279:   /**
 52279:    * Return the child document count.
 52279:    */
108991:   uint32_t ChildDocumentCount() const
 52279:     { return mChildDocuments.Length(); }
 52279: 
 52279:   /**
 52279:    * Return the child document at the given index.
 52279:    */
108991:   DocAccessible* GetChildDocumentAt(uint32_t aIndex) const
106838:     { return mChildDocuments.SafeElementAt(aIndex, nullptr); }
 52279: 
 52279:   /**
123609:    * Fire accessible event asynchronously.
  4516:    */
123609:   void FireDelayedEvent(AccEvent* aEvent);
123609:   void FireDelayedEvent(uint32_t aEventType, Accessible* aTarget);
   577: 
 29564:   /**
 83075:    * Fire value change event on the given accessible if applicable.
 83075:    */
106800:   void MaybeNotifyOfValueChange(Accessible* aAccessible);
 83075: 
 83075:   /**
 80036:    * Get/set the anchor jump.
 61201:    */
 99648:   Accessible* AnchorJump()
 80036:     { return GetAccessibleOrContainer(mAnchorJumpElm); }
 80036: 
 99648:   void SetAnchorJump(nsIContent* aTargetNode)
 80036:     { mAnchorJumpElm = aTargetNode; }
 61201: 
 61201:   /**
 61317:    * Bind the child document to the tree.
 61317:    */
100057:   void BindChildDocument(DocAccessible* aDocument);
 61317: 
 61317:   /**
 60746:    * Process the generic notification.
 60746:    *
 60746:    * @note  The caller must guarantee that the given instance still exists when
 60746:    *          notification is processed.
 60746:    * @see   NotificationController::HandleNotification
 60746:    */
 60746:   template<class Class, class Arg>
 99648:   void HandleNotification(Class* aInstance,
 60746:                           typename TNotification<Class, Arg>::Callback aMethod,
100057:                           Arg* aArg);
 60746: 
 60746:   /**
 56292:    * Return the cached accessible by the given DOM node if it's in subtree of
 38062:    * this document accessible or the document accessible itself, otherwise null.
 38062:    *
 43538:    * @return the accessible object
 38062:    */
 99648:   Accessible* GetAccessible(nsINode* aNode) const;
 61461: 
 61461:   /**
 61461:    * Return whether the given DOM node has an accessible or not.
 61461:    */
 99648:   bool HasAccessible(nsINode* aNode) const
 74867:     { return GetAccessible(aNode); }
 74867: 
 74867:   /**
 56292:    * Return the cached accessible by the given unique ID within this document.
 56292:    *
 56292:    * @note   the unique ID matches with the uniqueID() of nsAccessNode
 56292:    *
 56292:    * @param  aUniqueID  [in] the unique ID used to cache the node.
 56292:    */
 99648:   Accessible* GetAccessibleByUniqueID(void* aUniqueID)
 56292:   {
 56292:     return UniqueID() == aUniqueID ?
 56292:       this : mAccessibleCache.GetWeak(aUniqueID);
 56292:   }
 38062: 
 38062:   /**
 52279:    * Return the cached accessible by the given unique ID looking through
 52279:    * this and nested documents.
 52279:    */
 99648:   Accessible* GetAccessibleByUniqueIDInSubtree(void* aUniqueID);
 52279: 
 52279:   /**
 61462:    * Return an accessible for the given DOM node or container accessible if
 61462:    * the node is not accessible.
 61462:    */
 99648:   Accessible* GetAccessibleOrContainer(nsINode* aNode);
 61462: 
 61462:   /**
 61462:    * Return a container accessible for the given DOM node.
 61462:    */
 99648:   Accessible* GetContainerAccessible(nsINode* aNode)
 61462:   {
119415:     return aNode ? GetAccessibleOrContainer(aNode->GetParentNode()) : nullptr;
 61462:   }
 61462: 
 61462:   /**
 57890:    * Return true if the given ID is referred by relation attribute.
 57890:    *
 57890:    * @note Different elements may share the same ID if they are hosted inside
 57890:    *       XBL bindings. Be careful the result of this method may be  senseless
 57890:    *       while it's called for XUL elements (where XBL is used widely).
 57890:    */
 79445:   bool IsDependentID(const nsAString& aID) const
106838:     { return mDependentIDsHash.Get(aID, nullptr); }
 57890: 
 57890:   /**
 57413:    * Initialize the newly created accessible and put it into document caches.
 29564:    *
 57413:    * @param  aAccessible    [in] created accessible
106838:    * @param  aRoleMapEntry  [in] the role map entry role the ARIA role or nullptr
 57413:    *                          if none
 29564:    */
 99648:   bool BindToDocument(Accessible* aAccessible, nsRoleMapEntry* aRoleMapEntry);
 29564: 
 29564:   /**
 57414:    * Remove from document and shutdown the given accessible.
 31673:    */
 99648:   void UnbindFromDocument(Accessible* aAccessible);
 31673: 
 31673:   /**
 60746:    * Notify the document accessible that content was inserted.
 29564:    */
 60746:   void ContentInserted(nsIContent* aContainerNode,
 60746:                        nsIContent* aStartChildNode,
 60746:                        nsIContent* aEndChildNode);
 29564: 
 56292:   /**
 60746:    * Notify the document accessible that content was removed.
 56292:    */
 60746:   void ContentRemoved(nsIContent* aContainerNode, nsIContent* aChildNode);
 56292: 
 56292:   /**
 61516:    * Updates accessible tree when rendered text is changed.
 61516:    */
100057:   void UpdateText(nsIContent* aTextNode);
 61516: 
 61516:   /**
 56292:    * Recreate an accessible, results in hide/show events pair.
 56292:    */
 61681:   void RecreateAccessible(nsIContent* aContent);
 56292: 
 29564: protected:
     1: 
 89799:   void LastRelease();
 89799: 
 99648:   // Accessible
 57964:   virtual void CacheChildren();
 57964: 
 99568:   // DocAccessible
123601:   virtual nsresult AddEventListeners();
     1:   virtual nsresult RemoveEventListeners();
 63261: 
 63261:   /**
 75013:    * Marks this document as loaded or loading.
 75013:    */
122246:   void NotifyOfLoad(uint32_t aLoadEventType);
 75013:   void NotifyOfLoading(bool aIsReloading);
 75013: 
123625:   friend class DocManager;
 75013: 
 75013:   /**
 75013:    * Perform initial update (create accessible tree).
 63261:    * Can be overridden by wrappers to prepare initialization work.
 63261:    */
 75013:   virtual void DoInitialUpdate();
 75013: 
 75013:   /**
 75013:    * Process document load notification, fire document load and state busy
 75013:    * events if applicable.
 75013:    */
 75013:   void ProcessLoad();
 63261: 
126945:   /**
126945:    * Add/remove scroll listeners, @see nsIScrollPositionListener interface.
126945:    */
     1:   void AddScrollListener();
     1:   void RemoveScrollListener();
 11165: 
 11165:   /**
 52279:    * Append the given document accessible to this document's child document
 52279:    * accessibles.
 52279:    */
 99568:   bool AppendChildDocument(DocAccessible* aChildDocument)
 52279:   {
 52279:     return mChildDocuments.AppendElement(aChildDocument);
 52279:   }
 52279: 
 52279:   /**
 52279:    * Remove the given document accessible from this document's child document
 52279:    * accessibles.
 52279:    */
 99568:   void RemoveChildDocument(DocAccessible* aChildDocument)
 52279:   {
 52279:     mChildDocuments.RemoveElement(aChildDocument);
 52279:   }
 52279: 
 57845:   /**
 57845:    * Add dependent IDs pointed by accessible element by relation attribute to
 57845:    * cache. If the relation attribute is missed then all relation attributes
 57845:    * are checked.
 57845:    *
 57845:    * @param aRelProvider [in] accessible that element has relation attribute
 57845:    * @param aRelAttr     [in, optional] relation attribute
 57845:    */
 99648:   void AddDependentIDsFor(Accessible* aRelProvider,
106838:                           nsIAtom* aRelAttr = nullptr);
 57845: 
 57845:   /**
 57845:    * Remove dependent IDs pointed by accessible element by relation attribute
 57845:    * from cache. If the relation attribute is absent then all relation
 57845:    * attributes are checked.
 57845:    *
 57845:    * @param aRelProvider [in] accessible that element has relation attribute
 57845:    * @param aRelAttr     [in, optional] relation attribute
 57845:    */
 99648:   void RemoveDependentIDsFor(Accessible* aRelProvider,
106838:                              nsIAtom* aRelAttr = nullptr);
 57845: 
 59464:   /**
 59464:    * Update or recreate an accessible depending on a changed attribute.
 59464:    *
 59464:    * @param aElement   [in] the element the attribute was changed on
 59464:    * @param aAttribute [in] the changed attribute
 59464:    * @return            true if an action was taken on the attribute change
 59464:    */
 59464:   bool UpdateAccessibleOnAttrChange(mozilla::dom::Element* aElement,
 59464:                                     nsIAtom* aAttribute);
     1: 
   577:   /**
123609:    * Fire accessible events when attribute is changed.
  6065:    *
123609:    * @param aAccessible   [in] accessible the DOM attribute is changed for
123609:    * @param aNameSpaceID  [in] namespace of changed attribute
123609:    * @param aAttribute    [in] changed attribute
  6065:    */
123609:   void AttributeChangedImpl(Accessible* aAccessible,
123609:                             int32_t aNameSpaceID, nsIAtom* aAttribute);
  6065: 
  6065:   /**
123609:    * Fire accessible events when ARIA attribute is changed.
   577:    *
123609:    * @param aAccessible  [in] accesislbe the DOM attribute is changed for
123609:    * @param aAttribute   [in] changed attribute
   577:    */
123609:   void ARIAAttributeChanged(Accessible* aAccessible, nsIAtom* aAttribute);
   577: 
  3950:   /**
 79384:    * Process ARIA active-descendant attribute change.
 79384:    */
123609:   void ARIAActiveDescendantChanged(Accessible* aAccessible);
 79384: 
 79384:   /**
 60746:    * Update the accessible tree for inserted content.
 60746:    */
 99648:   void ProcessContentInserted(Accessible* aContainer,
 60746:                               const nsTArray<nsCOMPtr<nsIContent> >* aInsertedContent);
 60746: 
 60746:   /**
 74257:    * Used to notify the document to make it process the invalidation list.
 74257:    *
 74257:    * While children are cached we may encounter the case there's no accessible
 74257:    * for referred content by related accessible. Store these related nodes to
 74257:    * invalidate their containers later.
 74257:    */
 74257:   void ProcessInvalidationList();
 74257: 
 74257:   /**
 60746:    * Update the accessible tree for content insertion or removal.
 60746:    */
 99648:   void UpdateTree(Accessible* aContainer, nsIContent* aChildNode,
 67625:                   bool aIsInsert);
 60746: 
 60746:   /**
 56292:    * Helper for UpdateTree() method. Go down to DOM subtree and updates
 56292:    * accessible tree. Return one of these flags.
 56292:    */
 56292:   enum EUpdateTreeFlags {
 56292:     eNoAccessible = 0,
 56292:     eAccessible = 1,
 56292:     eAlertAccessible = 2
 56292:   };
 56292: 
121710:   uint32_t UpdateTreeInternal(Accessible* aChild, bool aIsInsert,
121710:                               AccReorderEvent* aReorderEvent);
 56292: 
 56292:   /**
 60921:    * Create accessible tree.
 60921:    */
 99648:   void CacheChildrenInSubtree(Accessible* aRoot);
 60921: 
 60921:   /**
 56292:    * Remove accessibles in subtree from node to accessible map.
 56292:    */
 99648:   void UncacheChildrenInSubtree(Accessible* aRoot);
 56292: 
 56292:   /**
 56292:    * Shutdown any cached accessible in the subtree.
 56292:    *
 56292:    * @param aAccessible  [in] the root of the subrtee to invalidate accessible
 56292:    *                      child/parent refs in
 56292:    */
 99648:   void ShutdownChildrenInSubtree(Accessible* aAccessible);
 56292: 
 56292:   /**
 99735:    * Return true if the document is a target of document loading events
 99735:    * (for example, state busy change or document reload events).
 75013:    *
 99735:    * Rules: The root chrome document accessible is never an event target
 99735:    * (for example, Firefox UI window). If the sub document is loaded within its
 99735:    * parent document then the parent document is a target only (aka events
 99735:    * coalescence).
 75013:    */
 75013:   bool IsLoadEventTarget() const;
 75013: 
 75013:   /**
 59464:    * Used to fire scrolling end event after page scroll.
 59464:    *
 59464:    * @param aTimer    [in] the timer object
 59464:    * @param aClosure  [in] the document accessible where scrolling happens
 59464:    */
 59464:   static void ScrollTimerCallback(nsITimer* aTimer, void* aClosure);
 59464: 
 75013: protected:
 75013: 
 59464:   /**
126945:    * State and property flags, kept by mDocFlags.
126945:    */
126945:   enum {
126945:     // Whether scroll listeners were added.
126945:     eScrollInitialized = 1 << 0,
126945: 
126945:     // Whether we support nsIAccessibleCursorable.
127080:     eCursorable = 1 << 1,
127080: 
127080:     // Whether the document is a tab document.
127080:     eTabDocument = 1 << 2
126945:   };
126945: 
126945:   /**
 43538:    * Cache of accessibles within this document accessible.
 43538:    */
 99648:   AccessibleHashtable mAccessibleCache;
 99648:   nsDataHashtable<nsPtrHashKey<const nsINode>, Accessible*>
 57845:     mNodeToAccessibleMap;
 43538: 
123924:     nsCOMPtr<nsIDocument> mDocumentNode;
     1:     nsCOMPtr<nsITimer> mScrollWatchTimer;
108991:     uint16_t mScrollPositionChangedTicks; // Used for tracking scroll events
     1: 
 75013:   /**
 75013:    * Bit mask of document load states (@see LoadState).
 75013:    */
126945:   uint32_t mLoadState : 3;
126945: 
126945:   /**
126945:    * Bit mask of other states and props.
126945:    */
126945:   uint32_t mDocFlags : 28;
 32285: 
 43310:   /**
 75013:    * Type of document load event fired after the document is loaded completely.
 43310:    */
108991:   uint32_t mLoadEventType;
 43310: 
 75278:   /**
 80036:    * Reference to anchor jump element.
 80036:    */
 80036:   nsCOMPtr<nsIContent> mAnchorJumpElm;
 80036: 
 80036:   /**
 75278:    * Keep the ARIA attribute old value that is initialized by
 75278:    * AttributeWillChange and used by AttributeChanged notifications.
 75278:    */
 75278:   nsIAtom* mARIAAttrOldValue;
 52279: 
 99568:   nsTArray<nsRefPtr<DocAccessible> > mChildDocuments;
 57845: 
 57845:   /**
 89309:    * The virtual cursor of the document when it supports nsIAccessibleCursorable.
 89309:    */
 89309:   nsRefPtr<nsAccessiblePivot> mVirtualCursor;
 89309: 
 89309:   /**
 57845:    * A storage class for pairing content with one of its relation attributes.
 57845:    */
 57845:   class AttrRelProvider
 57845:   {
 57845:   public:
 57845:     AttrRelProvider(nsIAtom* aRelAttr, nsIContent* aContent) :
 57845:       mRelAttr(aRelAttr), mContent(aContent) { }
 57845: 
 57845:     nsIAtom* mRelAttr;
 57991:     nsCOMPtr<nsIContent> mContent;
 57845: 
 57845:   private:
 57845:     AttrRelProvider();
 57845:     AttrRelProvider(const AttrRelProvider&);
 57845:     AttrRelProvider& operator =(const AttrRelProvider&);
 57845:   };
 57845: 
 57845:   /**
 57845:    * The cache of IDs pointed by relation attributes.
 57845:    */
 57845:   typedef nsTArray<nsAutoPtr<AttrRelProvider> > AttrRelProviderArray;
 57845:   nsClassHashtable<nsStringHashKey, AttrRelProviderArray> mDependentIDsHash;
 57845: 
122283:   friend class RelatedAccIterator;
 57890: 
 57890:   /**
 74257:    * Used for our caching algorithm. We store the list of nodes that should be
 74257:    * invalidated.
 57890:    *
 74257:    * @see ProcessInvalidationList
 57890:    */
 57890:   nsTArray<nsIContent*> mInvalidationList;
 60746: 
 60746:   /**
 60746:    * Used to process notification from core and accessible events.
 60746:    */
 60746:   nsRefPtr<NotificationController> mNotificationController;
 60746:   friend class NotificationController;
 89799: 
 89799: private:
 89799: 
 89799:   nsIPresShell* mPresShell;
     1: };
     1: 
 99568: inline DocAccessible*
 99648: Accessible::AsDoc()
 70092: {
126240:   return IsDoc() ? static_cast<DocAccessible*>(this) : nullptr;
 70092: }
 70092: 
122283: } // namespace a11y
122283: } // namespace mozilla
122283: 
     1: #endif
