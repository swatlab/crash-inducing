16299: /*
16299:    Copyright (C) 2003 Commonwealth Scientific and Industrial Research
16299:    Organisation (CSIRO) Australia
16299: 
16299:    Redistribution and use in source and binary forms, with or without
16299:    modification, are permitted provided that the following conditions
16299:    are met:
16299: 
16299:    - Redistributions of source code must retain the above copyright
16299:    notice, this list of conditions and the following disclaimer.
16299: 
16299:    - Redistributions in binary form must reproduce the above copyright
16299:    notice, this list of conditions and the following disclaimer in the
16299:    documentation and/or other materials provided with the distribution.
16299: 
16299:    - Neither the name of CSIRO Australia nor the names of its
16299:    contributors may be used to endorse or promote products derived from
16299:    this software without specific prior written permission.
16299: 
16299:    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
16299:    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
16299:    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
16299:    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ORGANISATION OR
16299:    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
16299:    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
16299:    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
16299:    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
16299:    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
16299:    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
16299:    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
16299: */
16299: 
16299: /*
16299:  * oggplay_query.c
16299:  *
16299:  * Shane Stephens <shane.stephens@annodex.net>
16299:  */
16299: 
16299: #include "oggplay_private.h"
16299: 
16299: int
16299: oggplay_get_num_tracks (OggPlay * me) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->reader == NULL) {
16299:     return E_OGGPLAY_BAD_READER;
16299:   }
16299: 
16299:   if (me->all_tracks_initialised == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   return me->num_tracks;
16299: 
16299: }
16299: 
16299: OggzStreamContent
16299: oggplay_get_track_type (OggPlay * me, int track_num) {
16299: 
16299:   if (me == NULL) {
16299:     return (OggzStreamContent)E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->reader == NULL) {
16299:     return (OggzStreamContent)E_OGGPLAY_BAD_READER;
16299:   }
16299: 
16299:   if (me->all_tracks_initialised == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   if (track_num < 0 || track_num >= me->num_tracks) {
16299:     return (OggzStreamContent)E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   return (OggzStreamContent)me->decode_data[track_num]->content_type;
16299: }
16299: 
16299: const char *
16299: oggplay_get_track_typename (OggPlay * me, int track_num) {
16299: 
16299:   if (me == NULL) {
16299:     return NULL;
16299:   }
16299: 
16299:   if (me->reader == NULL) {
16299:     return NULL;
16299:   }
16299: 
16299:   if (me->all_tracks_initialised == 0) {
16299:     return NULL;
16299:   }
16299: 
16299:   if (track_num < 0 || track_num >= me->num_tracks) {
16299:     return NULL;
16299:   }
16299: 
16299:   return me->decode_data[track_num]->content_type_name;
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_set_track_active(OggPlay *me, int track_num) {
16299: 
16299:   ogg_int64_t p;
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->reader == NULL) {
16299:     return E_OGGPLAY_BAD_READER;
16299:   }
16299: 
16299:   if (me->all_tracks_initialised == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   if (track_num < 0 || track_num >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   /*
16299:    * Skeleton tracks should not be set active - data in them should be queried
16299:    * using alternative mechanisms (there is no concept of time-synced data
16299:    * in a skeleton track)
16299:    */
16299:   if (me->decode_data[track_num]->content_type == OGGZ_CONTENT_SKELETON) {
16299:     return E_OGGPLAY_TRACK_IS_SKELETON;
16299:   }
16299: 
28360:   if (me->decode_data[track_num]->content_type == OGGZ_CONTENT_UNKNOWN) {
28360:     return E_OGGPLAY_TRACK_IS_UNKNOWN;
28360:   }
28360: 
16299:   if ((p = me->decode_data[track_num]->final_granulepos) != -1) {
16299:     if (p * me->decode_data[track_num]->granuleperiod > me->target) {
16299:       return E_OGGPLAY_TRACK_IS_OVER;
16299:     }
16299:   }
16299: 
16299:   if (me->decode_data[track_num]->active == 0) {
16299:     me->decode_data[track_num]->active = 1;
16299: 
16299:     /*
16299:      * CMML tracks aren't counted when deciding whether we've read enough data
16299:      * from the stream.  This is because CMML data is not continuous, and
16299:      * determining that we've read enough data from each other stream is enough
16299:      * to determing that we've read any CMML data that is available.
16299:      * This also applies to Kate streams.
16299:      */
16608:     if (me->decode_data[track_num]->content_type != OGGZ_CONTENT_CMML && me->decode_data[track_num]->content_type != OGGZ_CONTENT_KATE) {
16299:       me->active_tracks ++;
16299:     }
16299:   }
16299: 
16299:   return E_OGGPLAY_OK;
16299: 
16299: }
16299: 
16299: OggPlayErrorCode
16299: oggplay_set_track_inactive(OggPlay *me, int track_num) {
16299: 
16299:   if (me == NULL) {
16299:     return E_OGGPLAY_BAD_OGGPLAY;
16299:   }
16299: 
16299:   if (me->reader == NULL) {
16299:     return E_OGGPLAY_BAD_READER;
16299:   }
16299: 
16299:   if (me->all_tracks_initialised == 0) {
16299:     return E_OGGPLAY_UNINITIALISED;
16299:   }
16299: 
16299:   if (track_num < 0 || track_num >= me->num_tracks) {
16299:     return E_OGGPLAY_BAD_TRACK;
16299:   }
16299: 
16299:   if (me->decode_data[track_num]->content_type == OGGZ_CONTENT_SKELETON) {
16299:     return E_OGGPLAY_TRACK_IS_SKELETON;
16299:   }
16299: 
28360:   if (me->decode_data[track_num]->content_type == OGGZ_CONTENT_UNKNOWN) {
28360:     return E_OGGPLAY_TRACK_IS_UNKNOWN;
28360:   }
28360: 
16299:   if (me->decode_data[track_num]->active == 1) {
16299:     me->decode_data[track_num]->active = 0;
16299: 
16299:     /*
16299:      * see above comment in oggplay_set_track_active
16299:      */
16608:     if (me->decode_data[track_num]->content_type != OGGZ_CONTENT_CMML && me->decode_data[track_num]->content_type != OGGZ_CONTENT_KATE) {
16299:       me->active_tracks --;
16299:     }
16299:   }
16299: 
16299:   return E_OGGPLAY_OK;
16299: }
