    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Chris Saari <saari@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
 2759: /*
 2759: The Graphics Interchange Format(c) is the copyright property of CompuServe
 2759: Incorporated. Only CompuServe Incorporated is authorized to define, redefine,
 2759: enhance, alter, modify or change in any way the definition of the format.
    1: 
 2759: CompuServe Incorporated hereby grants a limited, non-exclusive, royalty-free
 2759: license for the use of the Graphics Interchange Format(sm) in computer
 2759: software; computer software utilizing GIF(sm) must acknowledge ownership of the
 2759: Graphics Interchange Format and its Service Mark by CompuServe Incorporated, in
 2759: User and Technical Documentation. Computer software utilizing GIF, which is
 2759: distributed or may be distributed without User or Technical Documentation must
 2759: display to the screen or printer a message acknowledging ownership of the
 2759: Graphics Interchange Format and the Service Mark by CompuServe Incorporated; in
 2759: this case, the acknowledgement may be displayed in an opening screen or leading
 2759: banner, or a closing screen or trailing banner. A message such as the following
 2759: may be used:
 2759: 
 2759:     "The Graphics Interchange Format(c) is the Copyright property of
 2759:     CompuServe Incorporated. GIF(sm) is a Service Mark property of
 2759:     CompuServe Incorporated."
 2759: 
 2759: For further information, please contact :
 2759: 
 2759:     CompuServe Incorporated
 2759:     Graphics Technology Department
 2759:     5000 Arlington Center Boulevard
 2759:     Columbus, Ohio  43220
 2759:     U. S. A.
 2759: 
 2759: CompuServe Incorporated maintains a mailing list with all those individuals and
 2759: organizations who wish to receive copies of this document when it is corrected
 2759: or revised. This service is offered free of charge; please provide us with your
 2759: mailing address.
 2759: */
 2759: 
 2759: #include <stddef.h>
    1: #include "prmem.h"
    1: 
 4753: #include "nsIInterfaceRequestorUtils.h"
 4753: 
    1: #include "nsGIFDecoder2.h"
    1: #include "nsIInputStream.h"
    1: #include "nsIComponentManager.h"
    1: #include "imgIContainerObserver.h"
    1: 
    1: #include "imgILoad.h"
    1: 
 5296: #include "gfxColor.h"
 3787: #include "gfxPlatform.h"
27035: #include "qcms.h"
 3787: 
 2759: /*
 2759:  * GETN(n, s) requests at least 'n' bytes available from 'q', at start of state 's'
    1:  *
 2759:  * Note, the hold will never need to be bigger than 256 bytes to gather up in the hold,
 2759:  * as each GIF block (except colormaps) can never be bigger than 256 bytes.
 7671:  * Colormaps are directly copied in the resp. global_colormap or the local_colormap of the PAL image frame
 2759:  * So a fixed buffer in gif_struct is good enough.
 2759:  * This buffer is only needed to copy left-over data from one GifWrite call to the next
    1:  */
 2759: #define GETN(n,s)                      \
 2759:   PR_BEGIN_MACRO                       \
 2759:     mGIFStruct.bytes_to_consume = (n); \
 2759:     mGIFStruct.state = (s);            \
 2759:   PR_END_MACRO
    1: 
 2759: /* Get a 16-bit value stored in little-endian format */
 2759: #define GETINT16(p)   ((p)[1]<<8|(p)[0])
    1: 
    1: 
    1: //////////////////////////////////////////////////////////////////////
    1: // GIF Decoder Implementation
    1: // This is an adaptor between GIF2 and imgIDecoder
    1: 
    1: NS_IMPL_ISUPPORTS1(nsGIFDecoder2, imgIDecoder)
    1: 
    1: nsGIFDecoder2::nsGIFDecoder2()
    1:   : mCurrentRow(-1)
    1:   , mLastFlushedRow(-1)
 5296:   , mImageData(nsnull)
11852:   , mOldColor(0)
30545:   , mCurrentFrame(-1)
    1:   , mCurrentPass(0)
    1:   , mLastFlushedPass(0)
    1:   , mGIFOpen(PR_FALSE)
 8368:   , mSawTransparency(PR_FALSE)
    1: {
 2759:   // Clear out the structure, excluding the arrays
 2759:   memset(&mGIFStruct, 0, sizeof(mGIFStruct));
    1: }
    1: 
 2759: nsGIFDecoder2::~nsGIFDecoder2()
    1: {
    1:   Close();
    1: }
    1: 
    1: //******************************************************************************
    1: /** imgIDecoder methods **/
    1: //******************************************************************************
    1: 
    1: //******************************************************************************
    1: /* void init (in imgILoad aLoad); */
    1: NS_IMETHODIMP nsGIFDecoder2::Init(imgILoad *aLoad)
    1: {
    1:   mObserver = do_QueryInterface(aLoad);
    1: 
30479:   mImageContainer = do_CreateInstance("@mozilla.org/image/container;2");
    1:   aLoad->SetImage(mImageContainer);
    1:   
 2759:   // Start with the version (GIF89a|GIF87a)
 2759:   mGIFStruct.state = gif_type;
 2759:   mGIFStruct.bytes_to_consume = 6;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //******************************************************************************
    1: /** nsIOutputStream methods **/
    1: //******************************************************************************
    1: 
    1: //******************************************************************************
    1: /* void close (); */
    1: NS_IMETHODIMP nsGIFDecoder2::Close()
    1: {
30545:   if (mCurrentFrame == mGIFStruct.images_decoded)
 2759:     EndImageFrame();
 2759:   EndGIF();
    1: 
 2759:   PR_FREEIF(mGIFStruct.local_colormap);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* void flush (); */
    1: NS_IMETHODIMP nsGIFDecoder2::Flush()
    1: {
18578:     return NS_OK;
    1: }
    1: 
    1: //******************************************************************************
    1: /* static callback from nsIInputStream::ReadSegments */
    1: static NS_METHOD ReadDataOut(nsIInputStream* in,
    1:                              void* closure,
    1:                              const char* fromRawSegment,
    1:                              PRUint32 toOffset,
    1:                              PRUint32 count,
    1:                              PRUint32 *writeCount)
    1: {
 3233:   nsGIFDecoder2 *decoder = static_cast<nsGIFDecoder2*>(closure);
13737:   nsresult rv = decoder->ProcessData((unsigned char*)fromRawSegment, count, writeCount);
    1:   if (NS_FAILED(rv)) {
    1:     *writeCount = 0;
    1:     return rv;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Push any new rows according to mCurrentPass/mLastFlushedPass and
    1: // mCurrentRow/mLastFlushedRow.  Note: caller is responsible for
    1: // updating mlastFlushed{Row,Pass}.
19117: nsresult
 5296: nsGIFDecoder2::FlushImageData(PRUint32 fromRow, PRUint32 rows)
 5296: {
28299:   nsIntRect r(0, fromRow, mGIFStruct.width, rows);
 5296: 
 5296:   // Update image  
30479:   nsresult rv = mImageContainer->FrameUpdated(mGIFStruct.images_decoded, r);
19117:   if (NS_FAILED(rv)) {
19117:     return rv;
19117:   }
 5296: 
 5296:   // Offset to the frame position
 5296:   // Only notify observer(s) for first frame
 5296:   if (!mGIFStruct.images_decoded && mObserver) {
30479:     PRUint32 imgCurFrame;
30479:     mImageContainer->GetCurrentFrameIndex(&imgCurFrame);
 5296:     r.y += mGIFStruct.y_offset;
30479:     mObserver->OnDataAvailable(nsnull, imgCurFrame == PRUint32(mGIFStruct.images_decoded), &r);
 5296:   }
19117:   return NS_OK;
 5296: }
 5296: 
19117: nsresult
    1: nsGIFDecoder2::FlushImageData()
    1: {
19117:   nsresult rv = NS_OK;
19117: 
    1:   switch (mCurrentPass - mLastFlushedPass) {
 5296:     case 0:  // same pass
 5296:       if (mCurrentRow - mLastFlushedRow)
19117:         rv = FlushImageData(mLastFlushedRow + 1, mCurrentRow - mLastFlushedRow);
    1:       break;
    1:   
 5296:     case 1:  // one pass on - need to handle bottom & top rects
19117:       rv = FlushImageData(0, mCurrentRow + 1);
19117:       rv |= FlushImageData(mLastFlushedRow + 1, mGIFStruct.height - (mLastFlushedRow + 1));
    1:       break;
    1: 
 5296:     default:   // more than one pass on - push the whole frame
19117:       rv = FlushImageData(0, mGIFStruct.height);
    1:   }
19117:   return rv;
    1: }
    1: 
    1: //******************************************************************************
13737: nsresult nsGIFDecoder2::ProcessData(unsigned char *data, PRUint32 count, PRUint32 *_retval)
    1: {
13737:   // Push the data to the GIF decoder
13661:   
13737:   nsresult rv = GifWrite(data, count);
 2759:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 7671:   // Flushing is only needed for first frame
30479:   if (!mGIFStruct.images_decoded) {
19117:     rv = FlushImageData();
    1:     mLastFlushedRow = mCurrentRow;
    1:     mLastFlushedPass = mCurrentPass;
    1:   }
    1: 
    1:   *_retval = count;
    1: 
19117:   return rv;
    1: }
    1: 
    1: //******************************************************************************
    1: /* unsigned long writeFrom (in nsIInputStream inStr, in unsigned long count); */
    1: NS_IMETHODIMP nsGIFDecoder2::WriteFrom(nsIInputStream *inStr, PRUint32 count, PRUint32 *_retval)
    1: {
    1:   nsresult rv = inStr->ReadSegments(ReadDataOut, this,  count, _retval);
    1: 
    1:   /* necko doesn't propagate the errors from ReadDataOut - take matters
    1:      into our own hands.  if we have at least one frame of an animated
    1:      gif, then return success so we keep displaying as much as possible. */
10758:   if (mGIFStruct.state == gif_error || mGIFStruct.state == gif_oom) {
    1:     PRUint32 numFrames = 0;
    1:     if (mImageContainer)
    1:       mImageContainer->GetNumFrames(&numFrames);
10758:     if (numFrames <= 1)
10758:       rv = NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: //******************************************************************************
    1: // GIF decoder callback methods. Part of public API for GIF2
    1: //******************************************************************************
    1: 
    1: //******************************************************************************
 2759: void nsGIFDecoder2::BeginGIF()
    1: {
 5296:   if (mGIFOpen)
 2759:     return;
    1:     
 2759:   if (mObserver)
 2759:     mObserver->OnStartDecode(nsnull);
    1: 
 2759:   mImageContainer->Init(mGIFStruct.screen_width, mGIFStruct.screen_height, mObserver);
    1: 
 2759:   if (mObserver)
 2759:     mObserver->OnStartContainer(nsnull, mImageContainer);
    1: 
 2759:   mGIFOpen = PR_TRUE;
    1: }
    1: 
    1: //******************************************************************************
 2759: void nsGIFDecoder2::EndGIF()
    1: {
 2759:   if (!mGIFOpen)
 2759:     return;
    1: 
 2759:   if (mObserver) {
 2759:     mObserver->OnStopContainer(nsnull, mImageContainer);
 2759:     mObserver->OnStopDecode(nsnull, NS_OK, nsnull);
    1:   }
    1:   
 2759:   mImageContainer->SetLoopCount(mGIFStruct.loop_count);
 2759:   mImageContainer->DecodingComplete();
    1: 
 2759:   mGIFOpen = PR_FALSE;
    1: }
    1: 
    1: //******************************************************************************
 7671: void nsGIFDecoder2::BeginImageFrame(gfx_depth aDepth)
    1: {
 2759:   if (!mGIFStruct.images_decoded) {
    1:     // Send a onetime OnDataAvailable (Display Refresh) for the first frame
    1:     // if it has a y-axis offset.  Otherwise, the area may never be refreshed
    1:     // and the placeholder will remain on the screen. (Bug 37589)
 2759:     if (mGIFStruct.y_offset > 0) {
    1:       PRInt32 imgWidth;
 2759:       mImageContainer->GetWidth(&imgWidth);
30479:       PRUint32 imgCurFrame;
30479:       mImageContainer->GetCurrentFrameIndex(&imgCurFrame);
 2759:       nsIntRect r(0, 0, imgWidth, mGIFStruct.y_offset);
30479:       mObserver->OnDataAvailable(nsnull, imgCurFrame == PRUint32(mGIFStruct.images_decoded), &r);
    1:     }
    1:   }
    1: 
30479:   PRUint32 imageDataLength;
30479:   nsresult rv;
30479:   gfxASurface::gfxImageFormat format;
30479:   if (mGIFStruct.is_transparent)
30479:     format = gfxASurface::ImageFormatARGB32;
30479:   else
30479:     format = gfxASurface::ImageFormatRGB24;
30479: 
 7671:   // Use correct format, RGB for first frame, PAL for following frames
 7671:   // and include transparency to allow for optimization of opaque images
 7671:   if (mGIFStruct.images_decoded) {
 7671:     // Image data is stored with original depth and palette
30479:     rv = mImageContainer->AppendPalettedFrame(mGIFStruct.x_offset, mGIFStruct.y_offset,
30479:                                               mGIFStruct.width, mGIFStruct.height,
30479:                                               format, aDepth, &mImageData, &imageDataLength,
30479:                                               &mColormap, &mColormapSize);
30479: 
30479: 
 7671:   } else {
 7671:     // Regardless of depth of input, image is decoded into 24bit RGB
30479:     rv = mImageContainer->AppendFrame(mGIFStruct.x_offset, mGIFStruct.y_offset,
30479:                                       mGIFStruct.width, mGIFStruct.height,
30479:                                       format, &mImageData, &imageDataLength);
    1:   }
    1: 
30479:   if (NS_FAILED(rv))
 2759:     return;
    1: 
30479:   mImageContainer->SetFrameDisposalMethod(mGIFStruct.images_decoded,
30479:                                           mGIFStruct.disposal_method);
    1: 
 2759:   if (mObserver)
30479:     mObserver->OnStartFrame(nsnull, mGIFStruct.images_decoded);
30545: 
30545:   mCurrentFrame = mGIFStruct.images_decoded;
    1: }
    1: 
 5296: 
 5296: //******************************************************************************
 5296: void nsGIFDecoder2::EndImageFrame()
 5296: {
 5296:   // First flush all pending image data 
 7671:   if (!mGIFStruct.images_decoded) {
 7671:     // Only need to flush first frame
19117:     (void) FlushImageData();
 5296: 
 5296:     // If the first frame is smaller in height than the entire image, send a
 5296:     // OnDataAvailable (Display Refresh) for the area it does not have data for.
 5296:     // This will clear the remaining bits of the placeholder. (Bug 37589)
 5296:     const PRUint32 realFrameHeight = mGIFStruct.height + mGIFStruct.y_offset;
 5296:     if (realFrameHeight < mGIFStruct.screen_height) {
30479:       PRUint32 imgCurFrame;
30479:       mImageContainer->GetCurrentFrameIndex(&imgCurFrame);
 5296:       nsIntRect r(0, realFrameHeight, 
 5296:                   mGIFStruct.screen_width, 
 5296: 				  mGIFStruct.screen_height - realFrameHeight);
30479:       mObserver->OnDataAvailable(nsnull, imgCurFrame == PRUint32(mGIFStruct.images_decoded), &r);
 5296:     }
 8368:     // This transparency check is only valid for first frame
 8368:     if (mGIFStruct.is_transparent && !mSawTransparency) {
30479:       mImageContainer->SetFrameHasNoAlpha(mGIFStruct.images_decoded);
 8368:     }
    1:   }
 7671:   mCurrentRow = mLastFlushedRow = -1;
 7671:   mCurrentPass = mLastFlushedPass = 0;
    1: 
30479:   PRUint32 curframe = mGIFStruct.images_decoded;
30479: 
10019:   // Only add frame if we have any rows at all
10019:   if (mGIFStruct.rows_remaining != mGIFStruct.height) {
10019:     if (mGIFStruct.rows_remaining && mGIFStruct.images_decoded) {
10019:       // Clear the remaining rows (only needed for the animation frames)
10433:       PRUint8 *rowp = mImageData + ((mGIFStruct.height - mGIFStruct.rows_remaining) * mGIFStruct.width);
10019:       memset(rowp, 0, mGIFStruct.rows_remaining * mGIFStruct.width);
10019:     }
    1: 
 5296:     // We actually have the timeout information before we get the lzw encoded 
 5296:     // image data, at least according to the spec, but we delay in setting the 
 5296:     // timeout for the image until here to help ensure that we have the whole 
 5296:     // image frame decoded before we go off and try to display another frame.
30479:     mImageContainer->SetFrameTimeout(mGIFStruct.images_decoded, mGIFStruct.delay_time);
26936:     mImageContainer->EndFrameDecode(mGIFStruct.images_decoded);
30479: 
10019:     mGIFStruct.images_decoded++;
28362:   }
    1: 
 5296:   if (mObserver)
30479:     mObserver->OnStopFrame(nsnull, curframe);
    1: 
 5296:   // Reset the transparent pixel
 5296:   if (mOldColor) {
 5296:     mColormap[mGIFStruct.tpixel] = mOldColor;
 5296:     mOldColor = 0;
 2759:   }
30545: 
30545:   mCurrentFrame = -1;
    1: }
    1: 
 2759: 
 2759: //******************************************************************************
 2759: // Send the data to the display front-end.
 2759: PRUint32 nsGIFDecoder2::OutputRow()
 2759: {
 5296:   int drow_start, drow_end;
 2759:   drow_start = drow_end = mGIFStruct.irow;
 2759: 
 7671:   /* Protect against too much image data */
 7671:   if ((PRUintn)drow_start >= mGIFStruct.height) {
 7671:     NS_WARNING("GIF2.cpp::OutputRow - too much image data");
 7671:     return 0;
 7671:   }
 7671: 
 7671:   if (!mGIFStruct.images_decoded) {
 2759:     /*
 2759:      * Haeberli-inspired hack for interlaced GIFs: Replicate lines while
 2759:      * displaying to diminish the "venetian-blind" effect as the image is
 2759:      * loaded. Adjust pixel vertical positions to avoid the appearance of the
 2759:      * image crawling up the screen as successive passes are drawn.
 2759:      */
 2759:     if (mGIFStruct.progressive_display && mGIFStruct.interlaced && (mGIFStruct.ipass < 4)) {
 2759:       /* ipass = 1,2,3 results in resp. row_dup = 7,3,1 and row_shift = 3,1,0 */
 2759:       const PRUint32 row_dup = 15 >> mGIFStruct.ipass;
 2759:       const PRUint32 row_shift = row_dup >> 1;
 2759:   
 2759:       drow_start -= row_shift;
 2759:       drow_end = drow_start + row_dup;
 2759:   
 2759:       /* Extend if bottom edge isn't covered because of the shift upward. */
 2759:       if (((mGIFStruct.height - 1) - drow_end) <= row_shift)
 2759:         drow_end = mGIFStruct.height - 1;
 2759:   
 2759:       /* Clamp first and last rows to upper and lower edge of image. */
 2759:       if (drow_start < 0)
 2759:         drow_start = 0;
 2759:       if ((PRUintn)drow_end >= mGIFStruct.height)
 2759:         drow_end = mGIFStruct.height - 1;
 2759:     }
 2759: 
 7671:     // Row to process
 7671:     const PRUint32 bpr = sizeof(PRUint32) * mGIFStruct.width; 
 7671:     PRUint8 *rowp = mImageData + (mGIFStruct.irow * bpr);
 7671: 
 7671:     // Convert color indices to Cairo pixels
 7671:     PRUint8 *from = rowp + mGIFStruct.width;
 7671:     PRUint32 *to = ((PRUint32*)rowp) + mGIFStruct.width;
 7671:     PRUint32 *cmap = mColormap;
 7671:     for (PRUint32 c = mGIFStruct.width; c > 0; c--) {
 7671:       *--to = cmap[*--from];
    1:     }
 2759:   
 8368:     // check for alpha (only for first frame)
 8368:     if (mGIFStruct.is_transparent && !mSawTransparency) {
 8368:       const PRUint32 *rgb = (PRUint32*)rowp;
 8368:       for (PRUint32 i = mGIFStruct.width; i > 0; i--) {
 8368:         if (*rgb++ == 0) {
 8368:           mSawTransparency = PR_TRUE;
 8368:           break;
 8368:         }
 8368:       }
 8368:     }
 8368: 
 5296:     // Duplicate rows
 5296:     if (drow_end > drow_start) {
 5296:       // irow is the current row filled
 5296:       for (int r = drow_start; r <= drow_end; r++) {
30479:         if (r != int(mGIFStruct.irow)) {
 7671:           memcpy(mImageData + (r * bpr), rowp, bpr);
 7671:         }
 5296:       }
 5296:     }
 2759:   }
 2759: 
 5296:   mCurrentRow = drow_end;
 5296:   mCurrentPass = mGIFStruct.ipass;
 5296:   if (mGIFStruct.ipass == 1)
 5296:     mLastFlushedPass = mGIFStruct.ipass;   // interlaced starts at 1
 5296: 
 2759:   if (!mGIFStruct.interlaced) {
 2759:     mGIFStruct.irow++;
 2759:   } else {
 2759:     static const PRUint8 kjump[5] = { 1, 8, 8, 4, 2 };
 2759:     do {
 2759:       // Row increments resp. per 8,8,4,2 rows
 2759:       mGIFStruct.irow += kjump[mGIFStruct.ipass];
 2759:       if (mGIFStruct.irow >= mGIFStruct.height) {
 2759:         // Next pass starts resp. at row 4,2,1,0
 2759:         mGIFStruct.irow = 8 >> mGIFStruct.ipass;
 2759:         mGIFStruct.ipass++;
 2759:       }
 2759:     } while (mGIFStruct.irow >= mGIFStruct.height);
 2759:   }
 2759: 
 2759:   return --mGIFStruct.rows_remaining;
 2759: }
 2759: 
 2759: //******************************************************************************
 2759: /* Perform Lempel-Ziv-Welch decoding */
 2759: PRBool
 2759: nsGIFDecoder2::DoLzw(const PRUint8 *q)
 2759: {
 5839:   if (!mGIFStruct.rows_remaining)
 5839:     return PR_TRUE;
 5839: 
 2759:   /* Copy all the decoder state variables into locals so the compiler
 2759:    * won't worry about them being aliased.  The locals will be homed
 2759:    * back into the GIF decoder structure when we exit.
 2759:    */
 2759:   int avail       = mGIFStruct.avail;
 2759:   int bits        = mGIFStruct.bits;
 2759:   int codesize    = mGIFStruct.codesize;
 2759:   int codemask    = mGIFStruct.codemask;
 2759:   int count       = mGIFStruct.count;
 2759:   int oldcode     = mGIFStruct.oldcode;
 2759:   const int clear_code = ClearCode();
 2759:   PRUint8 firstchar = mGIFStruct.firstchar;
 2759:   PRInt32 datum     = mGIFStruct.datum;
 2759:   PRUint16 *prefix  = mGIFStruct.prefix;
 2759:   PRUint8 *stackp   = mGIFStruct.stackp;
 2759:   PRUint8 *suffix   = mGIFStruct.suffix;
 2759:   PRUint8 *stack    = mGIFStruct.stack;
 7671:   PRUint8 *rowp     = mGIFStruct.rowp;
 7671: 
 7671:   PRUint32 bpr = mGIFStruct.width;
 7671:   if (!mGIFStruct.images_decoded) 
 7671:     bpr *= sizeof(PRUint32);
 7671:   PRUint8 *rowend   = mImageData + (bpr * mGIFStruct.irow) + mGIFStruct.width;
 7671: 
 2759: #define OUTPUT_ROW()                                        \
 2759:   PR_BEGIN_MACRO                                            \
 2759:     if (!OutputRow())                                       \
 2759:       goto END;                                             \
 7671:     rowp = mImageData + mGIFStruct.irow * bpr;              \
 5296:     rowend = rowp + mGIFStruct.width;                       \
 2759:   PR_END_MACRO
 2759: 
 2759:   for (const PRUint8* ch = q; count-- > 0; ch++)
 2759:   {
 2759:     /* Feed the next byte into the decoder's 32-bit input buffer. */
 2759:     datum += ((int32) *ch) << bits;
 2759:     bits += 8;
 2759: 
 2759:     /* Check for underflow of decoder's 32-bit input buffer. */
 2759:     while (bits >= codesize)
 2759:     {
 2759:       /* Get the leading variable-length symbol from the data stream */
 2759:       int code = datum & codemask;
 2759:       datum >>= codesize;
 2759:       bits -= codesize;
 2759: 
 2759:       /* Reset the dictionary to its original state, if requested */
 2759:       if (code == clear_code) {
 2759:         codesize = mGIFStruct.datasize + 1;
 2759:         codemask = (1 << codesize) - 1;
 2759:         avail = clear_code + 2;
 2759:         oldcode = -1;
 2759:         continue;
 2759:       }
 2759: 
 2759:       /* Check for explicit end-of-stream code */
 2759:       if (code == (clear_code + 1)) {
 2759:         /* end-of-stream should only appear after all image data */
 2759:         return (mGIFStruct.rows_remaining == 0);
 2759:       }
 2759: 
 2759:       if (oldcode == -1) {
10619:         if (code >= MAX_BITS)
10619:           return PR_FALSE;
 7671:         *rowp++ = suffix[code];
 2759:         if (rowp == rowend)
 2759:           OUTPUT_ROW();
 2759: 
 2759:         firstchar = oldcode = code;
 2759:         continue;
 2759:       }
 2759: 
 2759:       int incode = code;
 2759:       if (code >= avail) {
 2759:         *stackp++ = firstchar;
 2759:         code = oldcode;
 2759: 
10758:         if (stackp >= stack + MAX_BITS)
 2759:           return PR_FALSE;
 2759:       }
 2759: 
 2759:       while (code >= clear_code)
 2759:       {
10758:         if ((code >= MAX_BITS) || (code == prefix[code]))
 2759:           return PR_FALSE;
 2759: 
 2759:         *stackp++ = suffix[code];
 2759:         code = prefix[code];
 2759: 
 2759:         if (stackp == stack + MAX_BITS)
 2759:           return PR_FALSE;
 2759:       }
 2759: 
 2759:       *stackp++ = firstchar = suffix[code];
 2759: 
 2759:       /* Define a new codeword in the dictionary. */
 2759:       if (avail < 4096) {
 2759:         prefix[avail] = oldcode;
 2759:         suffix[avail] = firstchar;
 2759:         avail++;
 2759: 
 2759:         /* If we've used up all the codewords of a given length
 2759:          * increase the length of codewords by one bit, but don't
 2759:          * exceed the specified maximum codeword size of 12 bits.
 2759:          */
 2759:         if (((avail & codemask) == 0) && (avail < 4096)) {
 2759:           codesize++;
 2759:           codemask += avail;
 2759:         }
 2759:       }
 2759:       oldcode = incode;
 2759: 
 2759:       /* Copy the decoded data out to the scanline buffer. */
 2759:       do {
 7671:         *rowp++ = *--stackp;
 2759:         if (rowp == rowend)
 2759:           OUTPUT_ROW();
 2759:       } while (stackp > stack);
 2759:     }
 2759:   }
 2759: 
 2759:   END:
 2759: 
 2759:   /* Home the local copies of the GIF decoder state variables */
 2759:   mGIFStruct.avail = avail;
 2759:   mGIFStruct.bits = bits;
 2759:   mGIFStruct.codesize = codesize;
 2759:   mGIFStruct.codemask = codemask;
 2759:   mGIFStruct.count = count;
 2759:   mGIFStruct.oldcode = oldcode;
 2759:   mGIFStruct.firstchar = firstchar;
 2759:   mGIFStruct.datum = datum;
 2759:   mGIFStruct.stackp = stackp;
 2759:   mGIFStruct.rowp = rowp;
 2759: 
 2759:   return PR_TRUE;
 2759: }
 2759: 
 5296: /** 
 5296:  * Expand the colormap from RGB to Packed ARGB as needed by Cairo.
 5296:  * And apply any LCMS transformation.
 5296:  */
 5296: static void ConvertColormap(PRUint32 *aColormap, PRUint32 aColors)
 5296: {
 5296:   // Apply CMS transformation if enabled and available
16571:   if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
27035:     qcms_transform *transform = gfxPlatform::GetCMSRGBTransform();
 5296:     if (transform)
27035:       qcms_transform_data(transform, aColormap, aColormap, aColors);
 5296:   }
 5296:   // Convert from the GIF's RGB format to the Cairo format.
 5296:   // Work from end to begin, because of the in-place expansion
 5296:   PRUint8 *from = ((PRUint8 *)aColormap) + 3 * aColors;
 5296:   PRUint32 *to = aColormap + aColors;
 5296: 
 5296:   // Convert color entries to Cairo format
 9582: 
 9582:   // set up for loops below
 9582:   if (!aColors) return;
 9582:   PRUint32 c = aColors;
 9582: 
11038:   // copy as bytes until source pointer is 32-bit-aligned
11038:   // NB: can't use 32-bit reads, they might read off the end of the buffer
11087:   for (; (NS_PTR_TO_UINT32(from) & 0x3) && c; --c) {
11038:     from -= 3;
11038:     *--to = GFX_PACKED_PIXEL(0xFF, from[0], from[1], from[2]);
11038:   }
 9582: 
 9582:   // bulk copy of pixels.
 9582:   while (c >= 4) {
 9582:     from -= 12;
 9582:     to   -=  4;
 9582:     c    -=  4;
11038:     GFX_BLOCK_RGB_TO_FRGB(from,to);
 9582:   }
 9582: 
 9582:   // copy remaining pixel(s)
11038:   // NB: can't use 32-bit reads, they might read off the end of the buffer
 9582:   while (c--) {
 5296:     from -= 3;
11038:     *--to = GFX_PACKED_PIXEL(0xFF, from[0], from[1], from[2]);
 5296:   }
 5296: }
 5296: 
 2759: /******************************************************************************/
 2759: /*
 2759:  * process data arriving from the stream for the gif decoder
 2759:  */
 2759: 
 2759: nsresult nsGIFDecoder2::GifWrite(const PRUint8 *buf, PRUint32 len)
 2759: {
 2759:   if (!buf || !len)
 2759:     return NS_ERROR_FAILURE;
 2759: 
 2759:   const PRUint8 *q = buf;
 2759: 
 2759:   // Add what we have sofar to the block
 2759:   // If previous call to me left something in the hold first complete current block
 2759:   // Or if we are filling the colormaps, first complete the colormap
 5296:   PRUint8* p = (mGIFStruct.state == gif_global_colormap) ? (PRUint8*)mGIFStruct.global_colormap :
 7671:                (mGIFStruct.state == gif_image_colormap) ? (PRUint8*)mColormap :
 2759:                (mGIFStruct.bytes_in_hold) ? mGIFStruct.hold : nsnull;
 2759:   if (p) {
 2759:     // Add what we have sofar to the block
 2759:     PRUint32 l = PR_MIN(len, mGIFStruct.bytes_to_consume);
 2759:     memcpy(p+mGIFStruct.bytes_in_hold, buf, l);
 2759: 
 2759:     if (l < mGIFStruct.bytes_to_consume) {
 2759:       // Not enough in 'buf' to complete current block, get more
 2759:       mGIFStruct.bytes_in_hold += l;
 2759:       mGIFStruct.bytes_to_consume -= l;
 2759:       return NS_OK;
 2759:     }
 2759:     // Reset hold buffer count
 2759:     mGIFStruct.bytes_in_hold = 0;
 2759:     // Point 'q' to complete block in hold (or in colormap)
 2759:     q = p;
 2759:   }
 2759: 
 2759:   // Invariant:
 2759:   //    'q' is start of current to be processed block (hold, colormap or buf)
 2759:   //    'bytes_to_consume' is number of bytes to consume from 'buf'
 2759:   //    'buf' points to the bytes to be consumed from the input buffer
 2759:   //    'len' is number of bytes left in input buffer from position 'buf'.
 2759:   //    At entrance of the for loop will 'buf' will be moved 'bytes_to_consume'
 2759:   //    to point to next buffer, 'len' is adjusted accordingly.
 2759:   //    So that next round in for loop, q gets pointed to the next buffer.
 2759: 
 2759:   for (;len >= mGIFStruct.bytes_to_consume; q=buf) {
 2759:     // Eat the current block from the buffer, q keeps pointed at current block
 2759:     buf += mGIFStruct.bytes_to_consume;
 2759:     len -= mGIFStruct.bytes_to_consume;
 2759: 
 2759:     switch (mGIFStruct.state)
 2759:     {
 2759:     case gif_lzw:
 2759:       if (!DoLzw(q)) {
 2759:         mGIFStruct.state = gif_error;
 2759:         break;
 2759:       }
 2759:       GETN(1, gif_sub_block);
 2759:       break;
 2759: 
 2759:     case gif_lzw_start:
 2759:     {
 5296:       // Make sure the transparent pixel is transparent in the colormap
 5296:       if (mGIFStruct.is_transparent) {
 7671:         // Save old value so we can restore it later
 7671:         if (mColormap == mGIFStruct.global_colormap)
 5296:             mOldColor = mColormap[mGIFStruct.tpixel];
 5296:         mColormap[mGIFStruct.tpixel] = 0;
 5296:       }
 5296: 
 2759:       /* Initialize LZW parser/decoder */
 2759:       mGIFStruct.datasize = *q;
 2759:       const int clear_code = ClearCode();
 2759:       if (mGIFStruct.datasize > MAX_LZW_BITS ||
 2759:           clear_code >= MAX_BITS) {
 2759:         mGIFStruct.state = gif_error;
 2759:         break;
 2759:       }
 2759: 
 2759:       mGIFStruct.avail = clear_code + 2;
 2759:       mGIFStruct.oldcode = -1;
 2759:       mGIFStruct.codesize = mGIFStruct.datasize + 1;
 2759:       mGIFStruct.codemask = (1 << mGIFStruct.codesize) - 1;
 2759:       mGIFStruct.datum = mGIFStruct.bits = 0;
 2759: 
 2759:       /* init the tables */
 2759:       for (int i = 0; i < clear_code; i++)
 2759:         mGIFStruct.suffix[i] = i;
 2759: 
 2759:       mGIFStruct.stackp = mGIFStruct.stack;
 2759: 
 2759:       GETN(1, gif_sub_block);
 2759:     }
 2759:     break;
 2759: 
 2759:     /* All GIF files begin with "GIF87a" or "GIF89a" */
 2759:     case gif_type:
 2759:       if (!strncmp((char*)q, "GIF89a", 6)) {
 2759:         mGIFStruct.version = 89;
 2759:       } else if (!strncmp((char*)q, "GIF87a", 6)) {
 2759:         mGIFStruct.version = 87;
 2759:       } else {
 2759:         mGIFStruct.state = gif_error;
 2759:         break;
 2759:       }
 2759:       GETN(7, gif_global_header);
 2759:       break;
 2759: 
 2759:     case gif_global_header:
 2759:       /* This is the height and width of the "screen" or
 2759:        * frame into which images are rendered.  The
 2759:        * individual images can be smaller than the
 2759:        * screen size and located with an origin anywhere
 2759:        * within the screen.
 2759:        */
 2759: 
 2759:       mGIFStruct.screen_width = GETINT16(q);
 2759:       mGIFStruct.screen_height = GETINT16(q + 2);
 7671:       mGIFStruct.global_colormap_depth = (q[4]&0x07) + 1;
 2759: 
 2759:       // screen_bgcolor is not used
 2759:       //mGIFStruct.screen_bgcolor = q[5];
 2759:       // q[6] = Pixel Aspect Ratio
 2759:       //   Not used
 2759:       //   float aspect = (float)((q[6] + 15) / 64.0);
 2759: 
 2759:       if (q[4] & 0x80) { /* global map */
 2759:         // Get the global colormap
 7671:         const PRUint32 size = (3 << mGIFStruct.global_colormap_depth);
 2759:         if (len < size) {
 2759:           // Use 'hold' pattern to get the global colormap
 2759:           GETN(size, gif_global_colormap);
 2759:           break;
 2759:         }
 3787:         // Copy everything, go to colormap state to do CMS correction
 2759:         memcpy(mGIFStruct.global_colormap, buf, size);
 2759:         buf += size;
 2759:         len -= size;
 3787:         GETN(0, gif_global_colormap);
 3787:         break;
 2759:       }
 2759: 
 2759:       GETN(1, gif_image_start);
 2759:       break;
 2759: 
 2759:     case gif_global_colormap:
 2759:       // Everything is already copied into global_colormap
 5296:       // Convert into Cairo colors including CMS transformation
 7671:       ConvertColormap(mGIFStruct.global_colormap, 1<<mGIFStruct.global_colormap_depth);
 2759:       GETN(1, gif_image_start);
 2759:       break;
 2759: 
 2759:     case gif_image_start:
 2759:       switch (*q) {
 5839:         case GIF_TRAILER:
 2759:           mGIFStruct.state = gif_done;
 2759:           break;
 2759: 
 5839:         case GIF_EXTENSION_INTRODUCER:
 2759:           GETN(2, gif_extension);
 2759:           break;
 2759: 
 5839:         case GIF_IMAGE_SEPARATOR:
 2759:           GETN(9, gif_image_header);
 2759:           break;
 2759: 
 2759:         default:
 5839:           /* If we get anything other than GIF_IMAGE_SEPARATOR, 
 5839:            * GIF_EXTENSION_INTRODUCER, or GIF_TRAILER, there is extraneous data
 2759:            * between blocks. The GIF87a spec tells us to keep reading
 2759:            * until we find an image separator, but GIF89a says such
 2759:            * a file is corrupt. We follow GIF89a and bail out. */
 2759:           if (mGIFStruct.images_decoded > 0) {
 2759:             /* The file is corrupt, but one or more images have
 2759:              * been decoded correctly. In this case, we proceed
 2759:              * as if the file were correctly terminated and set
 2759:              * the state to gif_done, so the GIF will display.
 2759:              */
 2759:             mGIFStruct.state = gif_done;
 2759:           } else {
 2759:             /* No images decoded, there is nothing to display. */
 2759:             mGIFStruct.state = gif_error;
 2759:           }
 2759:       }
 2759:       break;
 2759: 
 2759:     case gif_extension:
 2759:       mGIFStruct.bytes_to_consume = q[1];
 2759:       if (mGIFStruct.bytes_to_consume) {
 2759:         switch (*q) {
 5839:         case GIF_GRAPHIC_CONTROL_LABEL:
 2759:           mGIFStruct.state = gif_control_extension;
 2759:           break;
 2759:   
 5839:         case GIF_APPLICATION_EXTENSION_LABEL:
 2759:           mGIFStruct.state = gif_application_extension;
 2759:           break;
 2759:   
 5839:         case GIF_COMMENT_LABEL:
 2759:           mGIFStruct.state = gif_consume_comment;
 2759:           break;
 2759:   
 2759:         default:
 2759:           mGIFStruct.state = gif_skip_block;
 2759:         }
 2759:       } else {
 2759:         GETN(1, gif_image_start);
 2759:       }
 2759:       break;
 2759: 
 2759:     case gif_consume_block:
 2759:       if (!*q)
 2759:         GETN(1, gif_image_start);
 2759:       else
 2759:         GETN(*q, gif_skip_block);
 2759:       break;
 2759: 
 2759:     case gif_skip_block:
 2759:       GETN(1, gif_consume_block);
 2759:       break;
 2759: 
 2759:     case gif_control_extension:
 2759:       mGIFStruct.is_transparent = *q & 0x1;
 2759:       mGIFStruct.tpixel = q[3];
 2759:       mGIFStruct.disposal_method = ((*q) >> 2) & 0x7;
 2759:       // Some specs say 3rd bit (value 4), other specs say value 3
 2759:       // Let's choose 3 (the more popular)
 2759:       if (mGIFStruct.disposal_method == 4)
 2759:         mGIFStruct.disposal_method = 3;
 2759:       mGIFStruct.delay_time = GETINT16(q + 1) * 10;
 2759:       GETN(1, gif_consume_block);
 2759:       break;
 2759: 
 2759:     case gif_comment_extension:
 2759:       if (*q)
 2759:         GETN(*q, gif_consume_comment);
 2759:       else
 2759:         GETN(1, gif_image_start);
 2759:       break;
 2759: 
 2759:     case gif_consume_comment:
 2759:       GETN(1, gif_comment_extension);
 2759:       break;
 2759: 
 2759:     case gif_application_extension:
 2759:       /* Check for netscape application extension */
 2759:       if (!strncmp((char*)q, "NETSCAPE2.0", 11) ||
 2759:         !strncmp((char*)q, "ANIMEXTS1.0", 11))
 2759:         GETN(1, gif_netscape_extension_block);
 2759:       else
 2759:         GETN(1, gif_consume_block);
 2759:       break;
 2759: 
 2759:     /* Netscape-specific GIF extension: animation looping */
 2759:     case gif_netscape_extension_block:
 2759:       if (*q)
 2759:         GETN(*q, gif_consume_netscape_extension);
 2759:       else
 2759:         GETN(1, gif_image_start);
 2759:       break;
 2759: 
 2759:     /* Parse netscape-specific application extensions */
 2759:     case gif_consume_netscape_extension:
 2759:       switch (q[0] & 7) {
 2759:         case 1:
 2759:           /* Loop entire animation specified # of times.  Only read the
 2759:              loop count during the first iteration. */
 2759:           mGIFStruct.loop_count = GETINT16(q + 1);
 2759:   
 2759:           /* Zero loop count is infinite animation loop request */
 2759:           if (mGIFStruct.loop_count == 0)
 2759:             mGIFStruct.loop_count = -1;
 2759:   
 2759:           GETN(1, gif_netscape_extension_block);
 2759:           break;
 2759:         
 2759:         case 2:
 2759:           /* Wait for specified # of bytes to enter buffer */
 2759:           // Don't do this, this extension doesn't exist (isn't used at all) 
 2759:           // and doesn't do anything, as our streaming/buffering takes care of it all...
 2759:           // See: http://semmix.pl/color/exgraf/eeg24.htm
 2759:           GETN(1, gif_netscape_extension_block);
 2759:           break;
 2759:   
 2759:         default:
 2759:           // 0,3-7 are yet to be defined netscape extension codes
 2759:           mGIFStruct.state = gif_error;
 2759:       }
 2759:       break;
 2759: 
 2759:     case gif_image_header:
 7671:     {
 2759:       /* Get image offsets, with respect to the screen origin */
 2759:       mGIFStruct.x_offset = GETINT16(q);
 2759:       mGIFStruct.y_offset = GETINT16(q + 2);
 2759: 
 2759:       /* Get image width and height. */
 2759:       mGIFStruct.width  = GETINT16(q + 4);
 2759:       mGIFStruct.height = GETINT16(q + 6);
 2759: 
 5296:       if (!mGIFStruct.images_decoded) {
 2759:         /* Work around broken GIF files where the logical screen
 2759:          * size has weird width or height.  We assume that GIF87a
 2759:          * files don't contain animations.
 2759:          */
 5296:         if ((mGIFStruct.screen_height < mGIFStruct.height) ||
 2759:             (mGIFStruct.screen_width < mGIFStruct.width) ||
 5296:             (mGIFStruct.version == 87)) {
 2759:           mGIFStruct.screen_height = mGIFStruct.height;
 2759:           mGIFStruct.screen_width = mGIFStruct.width;
 2759:           mGIFStruct.x_offset = 0;
 2759:           mGIFStruct.y_offset = 0;
 5296:         }    
 5296:         // Create the image container with the right size.
 2759:         BeginGIF();
 2759:       }
 2759: 
 2759:       /* Work around more broken GIF files that have zero image
 2759:          width or height */
 2759:       if (!mGIFStruct.height || !mGIFStruct.width) {
 2759:         mGIFStruct.height = mGIFStruct.screen_height;
 2759:         mGIFStruct.width = mGIFStruct.screen_width;
 2759:         if (!mGIFStruct.height || !mGIFStruct.width) {
 2759:           mGIFStruct.state = gif_error;
 2759:           break;
 2759:         }
 2759:       }
 2759: 
 7671:       /* Depth of colors is determined by colormap */
 7671:       /* (q[8] & 0x80) indicates local colormap */
 7671:       /* bits per pixel is (q[8]&0x07 + 1) when local colormap is set */
 7671:       PRUint32 depth = mGIFStruct.global_colormap_depth;
 7671:       if (q[8] & 0x80)
 7671:         depth = (q[8]&0x07) + 1;
 8960:       // Make sure the transparent pixel is within colormap space
 8960:       PRUint32 realDepth = depth;
 8960:       while (mGIFStruct.tpixel >= (1 << realDepth) && (realDepth < 8)) {
 8960:         realDepth++;
 8960:       } 
 8960:       BeginImageFrame(realDepth);
 2759:       
 7123:       // handle allocation error
30479:       if (!mImageData) {
 7123:         mGIFStruct.state = gif_error;
 7123:         break;
 7123:       }
 7123: 
 2759:       if (q[8] & 0x40) {
 2759:         mGIFStruct.interlaced = PR_TRUE;
 2759:         mGIFStruct.ipass = 1;
 2759:       } else {
 2759:         mGIFStruct.interlaced = PR_FALSE;
 2759:         mGIFStruct.ipass = 0;
 2759:       }
 2759: 
 2759:       /* Only apply the Haeberli display hack on the first frame */
 2759:       mGIFStruct.progressive_display = (mGIFStruct.images_decoded == 0);
 2759: 
 2759:       /* Clear state from last image */
 2759:       mGIFStruct.irow = 0;
 2759:       mGIFStruct.rows_remaining = mGIFStruct.height;
 5296:       mGIFStruct.rowp = mImageData;
 2759: 
 2759:       /* bits per pixel is q[8]&0x07 */
 2759: 
 2759:       if (q[8] & 0x80) /* has a local colormap? */
 2759:       {
 7671:         mGIFStruct.local_colormap_size = 1 << depth;
30479:         if (!mGIFStruct.images_decoded) {
 7671:           // First frame has local colormap, allocate space for it
 7671:           // as the image frame doesn't have its own palette
30479:           mColormapSize = sizeof(PRUint32) << realDepth;
 5296:           if (!mGIFStruct.local_colormap) {
30479:             mGIFStruct.local_colormap = (PRUint32*)PR_MALLOC(mColormapSize);
 5296:             if (!mGIFStruct.local_colormap) {
 2759:               mGIFStruct.state = gif_oom;
 2759:               break;
 2759:             }
 2759:           }
 5296:           mColormap = mGIFStruct.local_colormap;
 7671:         }
 7671:         const PRUint32 size = 3 << depth;
30479:         if (mColormapSize > size) {
 8960:           // Clear the notfilled part of the colormap
30479:           memset(((PRUint8*)mColormap) + size, 0, mColormapSize - size);
 8960:         }
 2759:         if (len < size) {
 2759:           // Use 'hold' pattern to get the image colormap
 2759:           GETN(size, gif_image_colormap);
 2759:           break;
 2759:         }
 3787:         // Copy everything, go to colormap state to do CMS correction
 7671:         memcpy(mColormap, buf, size);
 2759:         buf += size;
 2759:         len -= size;
 3787:         GETN(0, gif_image_colormap);
 3787:         break;
 2759:       } else {
 2759:         /* Switch back to the global palette */
 7671:         if (mGIFStruct.images_decoded) {
 7671:           // Copy global colormap into the palette of current frame
30479:           memcpy(mColormap, mGIFStruct.global_colormap, mColormapSize);
30479:         } else {
30479:           mColormap = mGIFStruct.global_colormap;
 7671:         }
 2759:       }
 2759:       GETN(1, gif_lzw_start);
 7671:     }
 2759:     break;
 2759: 
 2759:     case gif_image_colormap:
 2759:       // Everything is already copied into local_colormap
 5296:       // Convert into Cairo colors including CMS transformation
 7671:       ConvertColormap(mColormap, mGIFStruct.local_colormap_size);
 2759:       GETN(1, gif_lzw_start);
 2759:       break;
 2759: 
 2759:     case gif_sub_block:
 2759:       mGIFStruct.count = *q;
 2759:       if (mGIFStruct.count) {
 2759:         /* Still working on the same image: Process next LZW data block */
 2759:         /* Make sure there are still rows left. If the GIF data */
 2759:         /* is corrupt, we may not get an explicit terminator.   */
 2759:         if (!mGIFStruct.rows_remaining) {
 2759: #ifdef DONT_TOLERATE_BROKEN_GIFS
 2759:           mGIFStruct.state = gif_error;
 4349:           break;
 2759: #else
 2759:           /* This is an illegal GIF, but we remain tolerant. */
 2759:           GETN(1, gif_sub_block);
 2759: #endif
 5839:           if (mGIFStruct.count == GIF_TRAILER) {
 5839:             /* Found a terminator anyway, so consider the image done */
 5839:             GETN(1, gif_done);
 5839:             break;
 5839:           }
 2759:         }
 2759:         GETN(mGIFStruct.count, gif_lzw);
 2759:       } else {
 2759:         /* See if there are any more images in this sequence. */
 2759:         EndImageFrame();
 2759:         GETN(1, gif_image_start);
 2759:       }
 2759:       break;
 2759: 
 2759:     case gif_done:
 7123:       EndGIF();
 7123:       return NS_OK;
 7123:       break;
 7123: 
 2759:     case gif_error:
 2759:       EndGIF();
 7123:       return NS_ERROR_FAILURE;
 2759:       break;
 2759: 
 2759:     // Handle out of memory errors
 2759:     case gif_oom:
 2759:       return NS_ERROR_OUT_OF_MEMORY;
 2759: 
 2759:     // We shouldn't ever get here.
 2759:     default:
 2759:       break;
 2759:     }
 2759:   }
 2759: 
 7123:   // if an error state is set but no data remains, code flow reaches here
 7123:   if (mGIFStruct.state == gif_error) {
 7123:       EndGIF();
 7123:       return NS_ERROR_FAILURE;
 7123:   }
 7123:   
 2759:   // Copy the leftover into mGIFStruct.hold
 2759:   mGIFStruct.bytes_in_hold = len;
 2759:   if (len) {
 2759:     // Add what we have sofar to the block
 5296:     PRUint8* p = (mGIFStruct.state == gif_global_colormap) ? (PRUint8*)mGIFStruct.global_colormap :
 7671:                  (mGIFStruct.state == gif_image_colormap) ? (PRUint8*)mColormap :
 2759:                  mGIFStruct.hold;
 2759:     memcpy(p, buf, len);
 2759:     mGIFStruct.bytes_to_consume -= len;
 2759:   }
 2759: 
 2759:   return NS_OK;
 2759: }
