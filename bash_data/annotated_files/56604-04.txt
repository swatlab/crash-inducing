29366: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
32658:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript bytecode interpreter.
    1:  */
    1: #include <stdio.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsarena.h"
55477: #include "jsutil.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
    1: #include "jscntxt.h"
25087: #include "jsdate.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
40359: #include "jspropertycache.h"
    1: #include "jsscan.h"
54855: #include "jsemit.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
17584: #include "jstracer.h"
30268: #include "jslibmath.h"
32581: #include "jsvector.h"
52558: #include "methodjit/MethodJIT.h"
52558: #include "methodjit/Logging.h"
34349: 
34349: #include "jsatominlines.h"
42714: #include "jscntxtinlines.h"
53840: #include "jsinterpinlines.h"
42714: #include "jsobjinlines.h"
56556: #include "jsprobes.h"
40359: #include "jspropertycacheinlines.h"
34349: #include "jsscopeinlines.h"
34349: #include "jsscriptinlines.h"
32607: #include "jsstrinlines.h"
54855: #include "jsopcodeinlines.h"
 7058: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
15453: #include "jsautooplen.h"
15453: 
54832: #if defined(JS_METHODJIT) && defined(JS_MONOIC)
54832: #include "methodjit/MonoIC.h"
54832: #endif
54832: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
15996: /* jsinvoke_cpp___ indicates inclusion from jsinvoke.cpp. */
15996: #if !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___
12551: 
42717: #ifdef DEBUG
53840: JSObject *const JSStackFrame::sInvalidScopeChain = (JSObject *)0xbeef;
42717: #endif
    1: 
54832: jsbytecode *
54832: JSStackFrame::pc(JSContext *cx, JSStackFrame *next)
54832: {
54832:     JS_ASSERT_IF(next, next->prev_ == this);
54832:     JS_ASSERT(cx->containingSegment(this) != NULL);
54832: 
54832:     JSFrameRegs *regs;
54832:     if (cx->regs) {
54832:         regs = cx->regs;
54832:     } else {
54832:         StackSegment *segment = cx->getCurrentSegment();
54832:         regs = segment->getSuspendedRegs();
54832:     }
54832: 
54832:     if (this == regs->fp)
54832:         return regs->pc;
54832: 
54832:     if (!next)
54832:         next = cx->computeNextFrame(this);
54832: 
54832:     if (next->flags_ & JSFRAME_HAS_PREVPC)
54832:         return next->prevpc_;
54832: 
54832: #if defined(JS_METHODJIT) && defined(JS_MONOIC)
54832:     JSScript *script = this->script();
55503:     js::mjit::JITScript *jit = script->getJIT(isConstructing());
54832:     size_t low = 0;
55503:     size_t high = jit->nCallICs;
54832:     while (high > low + 1) {
54832:         /* Could overflow here on a script with 2 billion calls. Oh well. */
54832:         size_t mid = (high + low) / 2;
55503:         void *entry = jit->callICs[mid].funGuard.executableAddress();
54832: 
54832:         /*
54832:          * Use >= here as the return address of the call is likely to be
54832:          * the start address of the next (possibly IC'ed) operation.
54832:          */
54832:         if (entry >= next->ncode_)
54832:             high = mid;
54832:         else
54832:             low = mid;
54832:     }
54832: 
55503:     js::mjit::ic::CallICInfo &callIC = jit->callICs[low];
54832: 
54832:     JS_ASSERT((uint8*)callIC.funGuard.executableAddress() + callIC.joinPointOffset == next->ncode_);
54832:     return callIC.pc;
54832: #else
54832:     JS_NOT_REACHED("Unknown PC for frame");
54832:     return NULL;
54832: #endif
54832: }
54832: 
53840: /*
54855:  * This computes the blockChain by iterating through the bytecode
54855:  * of the current script until it reaches the PC. Each time it sees
54855:  * an ENTERBLOCK or LEAVEBLOCK instruction, it records the new
54855:  * blockChain. A faster variant of this function that doesn't
54855:  * require bytecode scanning appears below.
54855:  */
54855: JSObject *
54855: js_GetBlockChain(JSContext *cx, JSStackFrame *fp)
54855: {
54855:     if (!fp->isScriptFrame())
54855:         return NULL;
54855: 
54855:     JSScript *script = fp->script();
55467:     jsbytecode *start = script->code;
54855:     /* Assume that imacros don't affect blockChain */
54855:     jsbytecode *pc = fp->hasImacropc() ? fp->imacropc() : fp->pc(cx);
54855: 
54855:     JS_ASSERT(pc >= start && pc < script->code + script->length);
54855: 
55526:     JSObject *blockChain = NULL;
55526:     if (*pc == JSOP_BLOCKCHAIN) {
55526:         blockChain = script->getObject(GET_INDEX(pc));
55526:     } else if (*pc == JSOP_NULLBLOCKCHAIN) {
55526:         blockChain = NULL;
55526:     } else {
54855:         ptrdiff_t oplen;
54855:         for (jsbytecode *p = start; p < pc; p += oplen) {
54855:             JSOp op = js_GetOpcode(cx, script, p);
54855:             const JSCodeSpec *cs = &js_CodeSpec[op];
54855:             oplen = cs->length;
54855:             if (oplen < 0)
54855:                 oplen = js_GetVariableBytecodeLength(p);
54855: 
55526:             if (op == JSOP_ENTERBLOCK)
54855:                 blockChain = script->getObject(GET_INDEX(p));
55526:             else if (op == JSOP_LEAVEBLOCK || op == JSOP_LEAVEBLOCKEXPR)
54855:                 blockChain = blockChain->getParent();
55526:             else if (op == JSOP_BLOCKCHAIN)
55526:                 blockChain = script->getObject(GET_INDEX(p));
55526:             else if (op == JSOP_NULLBLOCKCHAIN)
55526:                 blockChain = NULL;
54855:         }
54855:     }
54855: 
54855:     return blockChain;
54855: }
54855: 
54855: /*
54855:  * This function computes the current blockChain, but only in
54855:  * the special case where a BLOCKCHAIN or NULLBLOCKCHAIN
54855:  * instruction appears immediately after the current PC.
54855:  * We ensure this happens for a few important ops like DEFFUN.
54855:  * |oplen| is the length of opcode at the current PC.
54855:  */
54855: JSObject *
54855: js_GetBlockChainFast(JSContext *cx, JSStackFrame *fp, JSOp op, size_t oplen)
54855: {
54855:     /* Assume that we're in a script frame. */
54855:     jsbytecode *pc = fp->pc(cx);
54855: 
54855:     /* The fast path. */
54855:     if (pc[oplen] == JSOP_NULLBLOCKCHAIN) {
54855:         JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == op);
54855:         return NULL;
54855:     }
54855: 
54855:     JSScript *script = fp->script();
54855: 
54855:     JS_ASSERT(js_GetOpcode(cx, script, pc) == op);
54855: 
54855:     JSObject *blockChain;
54855:     JSOp opNext = js_GetOpcode(cx, script, pc + oplen);
54855:     if (opNext == JSOP_BLOCKCHAIN) {
54855:         blockChain = script->getObject(GET_INDEX(pc + oplen));
54855:     } else if (opNext == JSOP_NULLBLOCKCHAIN) {
54855:         blockChain = NULL;
54855:     } else {
54855:         blockChain = NULL; /* appease gcc */
54855:         JS_NOT_REACHED("invalid opcode for fast block chain access");
54855:     }
54855: 
54855:     return blockChain;
54855: }
54855: 
54855: /*
53840:  * We can't determine in advance which local variables can live on the stack and
53840:  * be freed when their dynamic scope ends, and which will be closed over and
53840:  * need to live in the heap.  So we place variables on the stack initially, note
53840:  * when they are closed over, and copy those that are out to the heap when we
53840:  * leave their dynamic scope.
53840:  *
53840:  * The bytecode compiler produces a tree of block objects accompanying each
53840:  * JSScript representing those lexical blocks in the script that have let-bound
53840:  * variables associated with them.  These block objects are never modified, and
53840:  * never become part of any function's scope chain.  Their parent slots point to
53840:  * the innermost block that encloses them, or are NULL in the outermost blocks
53840:  * within a function or in eval or global code.
53840:  *
53840:  * When we are in the static scope of such a block, blockChain points to its
53840:  * compiler-allocated block object; otherwise, it is NULL.
53840:  *
53840:  * scopeChain is the current scope chain, including 'call' and 'block' objects
53840:  * for those function calls and lexical blocks whose static scope we are
53840:  * currently executing in, and 'with' objects for with statements; the chain is
53840:  * typically terminated by a global object.  However, as an optimization, the
53840:  * young end of the chain omits block objects we have not yet cloned.  To create
53840:  * a closure, we clone the missing blocks from blockChain (which is always
53840:  * current), place them at the head of scopeChain, and use that for the
53840:  * closure's scope chain.  If we never close over a lexical block, we never
53840:  * place a mutable clone of it on scopeChain.
53840:  *
53840:  * This lazy cloning is implemented in js_GetScopeChain, which is also used in
53840:  * some other cases --- entering 'with' blocks, for example.
53840:  */
54855: static JSObject *
54855: js_GetScopeChainFull(JSContext *cx, JSStackFrame *fp, JSObject *blockChain)
54855: {
54855:     JSObject *sharedBlock = blockChain;
26238: 
26238:     if (!sharedBlock) {
    1:         /*
    1:          * Don't force a call object for a lightweight function call, but do
    1:          * insist that there is a call object for a heavyweight function call.
    1:          */
53840:         JS_ASSERT_IF(fp->isFunctionFrame() && fp->fun()->isHeavyweight(),
50510:                      fp->hasCallObj());
53840:         return &fp->scopeChain();
    1:     }
    1: 
26238:     /* We don't handle cloning blocks on trace.  */
37741:     LeaveTrace(cx);
26238: 
    1:     /*
    1:      * We have one or more lexical scopes to reflect into fp->scopeChain, so
    1:      * make sure there's a call object at the current head of the scope chain,
    1:      * if this frame is a call frame.
26238:      *
26238:      * Also, identify the innermost compiler-allocated block we needn't clone.
26238:      */
26238:     JSObject *limitBlock, *limitClone;
53840:     if (fp->isFunctionFrame() && !fp->hasCallObj()) {
53840:         JS_ASSERT_IF(fp->scopeChain().isClonedBlock(),
53840:                      fp->scopeChain().getPrivate() != js_FloatingFrameIfGenerator(cx, fp));
25217:         if (!js_GetCallObject(cx, fp))
    1:             return NULL;
26238: 
26238:         /* We know we must clone everything on blockChain. */
26238:         limitBlock = limitClone = NULL;
26238:     } else {
26238:         /*
26238:          * scopeChain includes all blocks whose static scope we're within that
26238:          * have already been cloned.  Find the innermost such block.  Its
26238:          * prototype should appear on blockChain; we'll clone blockChain up
26238:          * to, but not including, that prototype.
26238:          */
53840:         limitClone = &fp->scopeChain();
40826:         while (limitClone->getClass() == &js_WithClass)
39930:             limitClone = limitClone->getParent();
26238:         JS_ASSERT(limitClone);
26238: 
26238:         /*
26238:          * It may seem like we don't know enough about limitClone to be able
26238:          * to just grab its prototype as we do here, but it's actually okay.
26238:          *
26238:          * If limitClone is a block object belonging to this frame, then its
26238:          * prototype is the innermost entry in blockChain that we have already
26238:          * cloned, and is thus the place to stop when we clone below.
26238:          *
26238:          * Otherwise, there are no blocks for this frame on scopeChain, and we
26238:          * need to clone the whole blockChain.  In this case, limitBlock can
26238:          * point to any object known not to be on blockChain, since we simply
26238:          * loop until we hit limitBlock or NULL.  If limitClone is a block, it
26238:          * isn't a block from this function, since blocks can't be nested
26238:          * within themselves on scopeChain (recursion is dynamic nesting, not
26238:          * static nesting).  If limitClone isn't a block, its prototype won't
26238:          * be a block either.  So we can just grab limitClone's prototype here
26238:          * regardless of its type or which frame it belongs to.
26238:          */
39928:         limitBlock = limitClone->getProto();
26238: 
26238:         /* If the innermost block has already been cloned, we are done. */
26238:         if (limitBlock == sharedBlock)
53840:             return &fp->scopeChain();
26238:     }
26238: 
26238:     /*
26238:      * Special-case cloning the innermost block; this doesn't have enough in
26238:      * common with subsequent steps to include in the loop.
26238:      *
30645:      * js_CloneBlockObject leaves the clone's parent slot uninitialized. We
30645:      * populate it below.
30645:      */
30645:     JSObject *innermostNewChild = js_CloneBlockObject(cx, sharedBlock, fp);
26238:     if (!innermostNewChild)
26238:         return NULL;
48470:     AutoObjectRooter tvr(cx, innermostNewChild);
26238: 
26238:     /*
26238:      * Clone our way towards outer scopes until we reach the innermost
26238:      * enclosing function, or the innermost block we've already cloned.
26238:      */
26238:     JSObject *newChild = innermostNewChild;
26186:     for (;;) {
39928:         JS_ASSERT(newChild->getProto() == sharedBlock);
39930:         sharedBlock = sharedBlock->getParent();
26238: 
26238:         /* Sometimes limitBlock will be NULL, so check that first.  */
26238:         if (sharedBlock == limitBlock || !sharedBlock)
26238:             break;
26238: 
26238:         /* As in the call above, we don't know the real parent yet.  */
48470:         JSObject *clone = js_CloneBlockObject(cx, sharedBlock, fp);
26238:         if (!clone)
26186:             return NULL;
26238: 
39930:         newChild->setParent(clone);
26238:         newChild = clone;
26238:     }
53840:     newChild->setParent(&fp->scopeChain());
30645: 
26238: 
26238:     /*
26238:      * If we found a limit block belonging to this frame, then we should have
26238:      * found it in blockChain.
26238:      */
26238:     JS_ASSERT_IF(limitBlock &&
53650:                  limitBlock->isBlock() &&
42714:                  limitClone->getPrivate() == js_FloatingFrameIfGenerator(cx, fp),
26238:                  sharedBlock);
26238: 
26238:     /* Place our newly cloned blocks at the head of the scope chain.  */
53840:     fp->setScopeChainNoCallObj(*innermostNewChild);
48470:     return innermostNewChild;
    1: }
    1: 
54855: JSObject *
54855: js_GetScopeChain(JSContext *cx, JSStackFrame *fp)
54855: {
54855:     return js_GetScopeChainFull(cx, fp, js_GetBlockChain(cx, fp));
54855: }
54855: 
54855: JSObject *
54855: js_GetScopeChainFast(JSContext *cx, JSStackFrame *fp, JSOp op, size_t oplen)
54855: {
54855:     return js_GetScopeChainFull(cx, fp, js_GetBlockChainFast(cx, fp, op, oplen));
54855: }
54855: 
47405: /* Some objects (e.g., With) delegate 'this' to another object. */
47405: static inline JSObject *
48470: CallThisObjectHook(JSContext *cx, JSObject *obj, Value *argv)
47405: {
47405:     JSObject *thisp = obj->thisObject(cx);
47405:     if (!thisp)
47405:         return NULL;
48470:     argv[-1].setObject(*thisp);
47405:     return thisp;
47405: }
47405: 
    1: /*
 4127:  * ECMA requires "the global object", but in embeddings such as the browser,
 4127:  * which have multiple top-level objects (windows, frames, etc. in the DOM),
 4127:  * we prefer fun's parent.  An example that causes this code to run:
    1:  *
    1:  *   // in window w1
    1:  *   function f() { return this }
    1:  *   function g() { return f }
    1:  *
    1:  *   // in window w2
    1:  *   var h = w1.g()
    1:  *   alert(h() == w1)
    1:  *
    1:  * The alert should display "true".
    1:  */
53081: JS_STATIC_INTERPRET bool
48470: ComputeGlobalThis(JSContext *cx, Value *argv)
 4127: {
53081:     JSObject *thisp = argv[-2].toObject().getGlobal()->thisObject(cx);
53004:     if (!thisp)
53004:         return false;
53004:     argv[-1].setObject(*thisp);
53004:     return true;
53076: }
53076: 
48470: namespace js {
48470: 
55750: void
55711: ReportIncompatibleMethod(JSContext *cx, Value *vp, Class *clasp)
55711: {
55711:     Value &thisv = vp[1];
55711: 
55711: #ifdef DEBUG
55711:     if (thisv.isObject()) {
55711:         JS_ASSERT(thisv.toObject().getClass() != clasp);
55711:     } else if (thisv.isString()) {
55711:         JS_ASSERT(clasp != &js_StringClass);
55711:     } else if (thisv.isNumber()) {
55711:         JS_ASSERT(clasp != &js_NumberClass);
55711:     } else if (thisv.isBoolean()) {
55711:         JS_ASSERT(clasp != &js_BooleanClass);
55711:     } else {
55711:         JS_ASSERT(thisv.isUndefined() || thisv.isNull());
55711:     }
55711: #endif
55711: 
55711:     if (JSFunction *fun = js_ValueToFunction(cx, &vp[0], 0)) {
55711:         const char *name = thisv.isObject()
55711:                            ? thisv.toObject().getClass()->name
55711:                            : thisv.isString()
55711:                            ? "string"
55711:                            : thisv.isNumber()
55711:                            ? "number"
55711:                            : thisv.isBoolean()
55711:                            ? "boolean"
55711:                            : thisv.isNull()
55711:                            ? js_null_str
55711:                            : thisv.isUndefined()
55711:                            ? js_undefined_str
55711:                            : "value";
55711:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
55711:                              JSMSG_INCOMPATIBLE_PROTO,
55711:                              clasp->name, JS_GetFunctionName(fun),
55711:                              name);
55711:     }
55711: }
55711: 
55711: bool
48470: ComputeThisFromArgv(JSContext *cx, Value *argv)
48470: {
50489:     /*
50489:      * Check for SynthesizeFrame poisoning and fast constructors which
50489:      * didn't check their vp properly.
50489:      */
50489:     JS_ASSERT(!argv[-1].isMagic());
50489: 
55712:     if (argv[-1].isNullOrUndefined())
48470:         return ComputeGlobalThis(cx, argv);
47449: 
53004:     if (!argv[-1].isObject())
53004:         return !!js_PrimitiveToObject(cx, &argv[-1]);
53076: 
53081:     JS_ASSERT(IsSaneThisObject(argv[-1].toObject()));
53004:     return true;
47405: }
47405: 
48470: }
48470: 
    1: #if JS_HAS_NO_SUCH_METHOD
    1: 
55746: const uint32 JSSLOT_FOUND_FUNCTION  = 0;
55746: const uint32 JSSLOT_SAVED_ID        = 1;
14789: 
48470: Class js_NoSuchMethodClass = {
12579:     "NoSuchMethod",
28093:     JSCLASS_HAS_RESERVED_SLOTS(2) | JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
12579: };
12579: 
12579: /*
12579:  * When JSOP_CALLPROP or JSOP_CALLELEM does not find the method property of
12579:  * the base object, we search for the __noSuchMethod__ method in the base.
12579:  * If it exists, we store the method and the property's id into an object of
12579:  * NoSuchMethod class and store this object into the callee's stack slot.
12579:  * Later, js_Invoke will recognise such an object and transfer control to
12579:  * NoSuchMethod that invokes the method like:
12579:  *
12579:  *   this.__noSuchMethod__(id, args)
12579:  *
12579:  * where id is the name of the method that this invocation attempted to
12579:  * call by name, and args is an Array containing this invocation's actual
12579:  * parameters.
12579:  */
53114: JSBool
48470: js_OnUnknownMethod(JSContext *cx, Value *vp)
48470: {
48470:     JS_ASSERT(!vp[1].isPrimitive());
48470: 
48470:     JSObject *obj = &vp[1].toObject();
33178:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.noSuchMethodAtom);
48470:     AutoValueRooter tvr(cx);
33178:     if (!js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, tvr.addr()))
33178:         return false;
48470:     if (tvr.value().isPrimitive()) {
33178:         vp[0] = tvr.value();
12579:     } else {
    1: #if JS_HAS_XML_SUPPORT
12610:         /* Extract the function name from function::name qname. */
48470:         if (vp[0].isObject()) {
48470:             obj = &vp[0].toObject();
33178:             if (!js_IsFunctionQName(cx, obj, &id))
33178:                 return false;
48470:             if (!JSID_IS_VOID(id))
48470:                 vp[0] = IdToValue(id);
12610:         }
    1: #endif
55746:         obj = js_NewGCObject(cx, FINALIZE_OBJECT2);
33178:         if (!obj)
33178:             return false;
47497: 
47497:         /*
47497:          * Null map to cause prompt and safe crash if this object were to
47497:          * escape due to a bug. This will make the object appear to be a
47497:          * stillborn instance that needs no finalization, which is sound:
47497:          * NoSuchMethod helper objects own no manually allocated resources.
47497:          */
47497:         obj->map = NULL;
55746:         obj->init(cx, &js_NoSuchMethodClass, NULL, NULL, NULL, false);
55746:         obj->setSlot(JSSLOT_FOUND_FUNCTION, tvr.value());
55746:         obj->setSlot(JSSLOT_SAVED_ID, vp[0]);
48470:         vp[0].setObject(*obj);
12579:     }
33178:     return true;
12579: }
12579: 
24499: static JS_REQUIRES_STACK JSBool
48470: NoSuchMethod(JSContext *cx, uintN argc, Value *vp, uint32 flags)
    1: {
42714:     InvokeArgsGuard args;
53840:     if (!cx->stack().pushInvokeArgs(cx, 2, &args))
14789:         return JS_FALSE;
12579: 
48470:     JS_ASSERT(vp[0].isObject());
48470:     JS_ASSERT(vp[1].isObject());
48470:     JSObject *obj = &vp[0].toObject();
40410:     JS_ASSERT(obj->getClass() == &js_NoSuchMethodClass);
14789: 
55746:     args.callee() = obj->getSlot(JSSLOT_FOUND_FUNCTION);
50468:     args.thisv() = vp[1];
55746:     args[0] = obj->getSlot(JSSLOT_SAVED_ID);
42714:     JSObject *argsobj = js_NewArrayObject(cx, argc, vp + 2);
42714:     if (!argsobj)
42714:         return JS_FALSE;
50468:     args[1].setObject(*argsobj);
42714:     JSBool ok = (flags & JSINVOKE_CONSTRUCT)
48470:                 ? InvokeConstructor(cx, args)
48470:                 : Invoke(cx, args, flags);
50468:     vp[0] = args.rval();
  348:     return ok;
    1: }
    1: 
    1: #endif /* JS_HAS_NO_SUCH_METHOD */
    1: 
48470: namespace js {
    1: 
52558: JS_REQUIRES_STACK bool
55503: RunScript(JSContext *cx, JSScript *script, JSStackFrame *fp)
52558: {
52558:     JS_ASSERT(script);
52558: 
52579: #ifdef JS_METHODJIT_SPEW
52558:     JMCheckLogging();
52579: #endif
52558: 
52558:     AutoInterpPreparer prepareInterp(cx, script);
52558: 
55503:     JS_ASSERT(fp == cx->fp());
55503:     JS_ASSERT(fp->script() == script);
55503: 
52558: #ifdef JS_METHODJIT
55503:     mjit::CompileStatus status = mjit::CanMethodJIT(cx, script, fp);
52558:     if (status == mjit::Compile_Error)
52558:         return JS_FALSE;
52558: 
52558:     if (status == mjit::Compile_Okay)
52558:         return mjit::JaegerShot(cx);
52558: #endif
52558: 
55503:     return Interpret(cx, fp);
52558: }
52558: 
53557: /*
53557:  * Find a function reference and its 'this' value implicit first parameter
53557:  * under argc arguments on cx's stack, and call the function.  Push missing
53557:  * required arguments, allocate declared local variables, and pop everything
53557:  * when done.  Then push the return value.
53557:  */
53557: JS_REQUIRES_STACK bool
53840: Invoke(JSContext *cx, const CallArgs &argsRef, uint32 flags)
53557: {
55565:     /* N.B. Must be kept in sync with InvokeSessionGuard::start/invoke */
55565: 
53557:     CallArgs args = argsRef;
53557:     JS_ASSERT(args.argc() <= JS_ARGS_LENGTH_MAX);
53557: 
53557:     if (args.callee().isPrimitive()) {
53557:         js_ReportIsNotFunction(cx, &args.callee(), flags & JSINVOKE_FUNFLAGS);
53557:         return false;
53557:     }
53557: 
53840:     JSObject &callee = args.callee().toObject();
53840:     Class *clasp = callee.getClass();
53557: 
53557:     /* Invoke non-functions. */
53557:     if (JS_UNLIKELY(clasp != &js_FunctionClass)) {
53557: #if JS_HAS_NO_SUCH_METHOD
53557:         if (JS_UNLIKELY(clasp == &js_NoSuchMethodClass))
53557:             return NoSuchMethod(cx, args.argc(), args.base(), 0);
53557: #endif
53557:         JS_ASSERT_IF(flags & JSINVOKE_CONSTRUCT, !clasp->construct);
53557:         if (!clasp->call) {
53557:             js_ReportIsNotFunction(cx, &args.callee(), flags);
53557:             return false;
53557:         }
53557:         return CallJSNative(cx, clasp->call, args.argc(), args.base());
53557:     }
53557: 
53557:     /* Invoke native functions. */
53840:     JSFunction *fun = callee.getFunctionPrivate();
53557:     JS_ASSERT_IF(flags & JSINVOKE_CONSTRUCT, !fun->isConstructor());
55713:     if (fun->isNative())
53557:         return CallJSNative(cx, fun->u.n.native, args.argc(), args.base());
53557: 
53557:     /* Handle the empty-script special case. */
55565:     JSScript *script = fun->script();
53557:     if (JS_UNLIKELY(script->isEmpty())) {
53557:         if (flags & JSINVOKE_CONSTRUCT) {
55503:             JSObject *obj = js_CreateThisForFunction(cx, &callee);
55503:             if (!obj)
55503:                 return false;
55503:             args.rval().setObject(*obj);
53557:         } else {
53557:             args.rval().setUndefined();
53557:         }
47495:         return true;
47495:     }
53557: 
53840:     /* Get pointer to new frame/slots, prepare arguments. */
42714:     InvokeFrameGuard frame;
53840:     if (JS_UNLIKELY(!cx->stack().getInvokeFrame(cx, args, fun, script, &flags, &frame)))
42714:         return false;
53840: 
53840:     /* Initialize frame, locals. */
53840:     JSStackFrame *fp = frame.fp();
53840:     fp->initCallFrame(cx, callee, fun, args.argc(), flags);
53840:     SetValueRangeToUndefined(fp->slots(), script->nfixed);
53557: 
53557:     /* Officially push fp. frame's destructor pops. */
53840:     cx->stack().pushInvokeFrame(cx, args, &frame);
53840: 
53840:     /* Now that the new frame is rooted, maybe create a call object. */
42714:     if (fun->isHeavyweight() && !js_GetCallObject(cx, fp))
42714:         return false;
26728: 
53004:     /*
55565:      * FIXME bug 592992: hoist to ExternalInvoke
55565:      *
53004:      * Compute |this|. Currently, this must happen after the frame is pushed
53004:      * and fp->scopeChain is correct because the thisObject hook may call
53004:      * JS_GetScopeChain.
53004:      */
55503:     if (!(flags & JSINVOKE_CONSTRUCT)) {
53840:         Value &thisv = fp->functionThis();
55503:         if (thisv.isObject()) {
53004:             /*
53004:              * We must call the thisObject hook in case we are not called from the
53004:              * interpreter, where a prior bytecode has computed an appropriate
53004:              * |this| already.
53004:              */
53840:             JSObject *thisp = thisv.toObject().thisObject(cx);
53004:             if (!thisp)
53004:                  return false;
53840:             JS_ASSERT(IsSaneThisObject(*thisp));
53840:             thisv.setObject(*thisp);
53840:         }
55503:     }
53004: 
53840:     /* Run function until JSOP_STOP, JSOP_RETURN or error. */
53557:     JSBool ok;
53557:     {
53557:         AutoPreserveEnumerators preserve(cx);
55503:         ok = RunScript(cx, script, fp);
56201:     }
53840: 
53840:     args.rval() = fp->returnValue();
55528:     JS_ASSERT_IF(ok && (flags & JSINVOKE_CONSTRUCT), !args.rval().isPrimitive());
55503: 
    1:     return ok;
    1: }
    1: 
53557: bool
55565: InvokeSessionGuard::start(JSContext *cx, const Value &calleev, const Value &thisv, uintN argc)
55565: {
55565: #ifdef JS_TRACER
55565:     if (TRACE_RECORDER(cx))
55565:         AbortRecording(cx, "attempt to reenter VM while recording");
55565:     LeaveTrace(cx);
55565: #endif
55565: 
55565:     /* Always push arguments, regardless of optimized/normal invoke. */
55565:     StackSpace &stack = cx->stack();
55565:     if (!stack.pushInvokeArgs(cx, argc, &args_))
55565:         return false;
55565: 
55565:     do {
55565:         /* Hoist dynamic checks from scripted Invoke. */
55565:         if (!calleev.isObject())
55565:             break;
55565:         JSObject &callee = calleev.toObject();
55565:         if (callee.getClass() != &js_FunctionClass)
55565:             break;
55565:         JSFunction *fun = callee.getFunctionPrivate();
55565:         if (fun->isNative())
55565:             break;
55565:         script_ = fun->script();
55565:         if (fun->isHeavyweight() || script_->isEmpty() || cx->compartment->debugMode)
55565:             break;
55565: 
55565:         /* Set (callee, this) once for the session (before args are duped). */
55565:         args_.callee().setObject(callee);
55565:         args_.thisv() = thisv;
55565: 
55565:         /* Push the stack frame once for the session. */
55565:         uint32 flags = 0;
55565:         if (!stack.getInvokeFrame(cx, args_, fun, script_, &flags, &frame_))
55565:             return false;
55565:         JSStackFrame *fp = frame_.fp();
55565:         fp->initCallFrame(cx, calleev.toObject(), fun, argc, flags);
55565:         stack.pushInvokeFrame(cx, args_, &frame_);
55565: 
55565:         // FIXME bug 592992: hoist thisObject hook to ExternalInvoke
55565:         if (thisv.isObject()) {
55565:             JSObject *thisp = thisv.toObject().thisObject(cx);
55565:             if (!thisp)
55565:                 return false;
55565:             JS_ASSERT(IsSaneThisObject(*thisp));
55565:             fp->functionThis().setObject(*thisp);
55565:         }
55565: 
55565: #ifdef JS_METHODJIT
55565:         /* Hoist dynamic checks from RunScript. */
55565:         mjit::CompileStatus status = mjit::CanMethodJIT(cx, script_, fp);
55565:         if (status == mjit::Compile_Error)
55565:             return false;
55565:         if (status != mjit::Compile_Okay)
55565:             break;
55565:         code_ = script_->getJIT(fp->isConstructing())->invokeEntry;
55565: 
55565:         /* Hoist dynamic checks from CheckStackAndEnterMethodJIT. */
55565:         JS_CHECK_RECURSION(cx, return JS_FALSE);
55565:         stackLimit_ = stack.getStackLimit(cx);
55565:         if (!stackLimit_)
55565:             return false;
55565: 
55565:         stop_ = script_->code + script_->length - 1;
55565:         JS_ASSERT(*stop_ == JSOP_STOP);
55565: #endif
55565: 
55565:         /* Cached to avoid canonicalActualArg in InvokeSessionGuard::operator[]. */
55565:         nformals_ = fp->numFormalArgs();
55565:         formals_ = fp->formalArgs();
55565:         actuals_ = args_.argv();
55565:         JS_ASSERT(actuals_ == fp->actualArgs());
55565:         return true;
55565:     } while (0);
55565: 
55565:     /*
55565:      * Use the normal invoke path.
55565:      *
55565:      * The callee slot gets overwritten during an unoptimized Invoke, so we
55565:      * cache it here and restore it before every Invoke call. The 'this' value
55565:      * does not get overwritten, so we can fill it here once.
55565:      */
55565:     if (frame_.pushed())
55565:         frame_.pop();
55565:     args_.thisv() = thisv;
55565:     savedCallee_ = calleev;
55565:     formals_ = actuals_ = args_.argv();
55565:     nformals_ = (unsigned)-1;
55565:     return true;
55565: }
55565: 
55565: bool
53557: ExternalInvoke(JSContext *cx, const Value &thisv, const Value &fval,
48470:                uintN argc, Value *argv, Value *rval)
    1: {
42714:     LeaveTrace(cx);
    1: 
42714:     InvokeArgsGuard args;
53840:     if (!cx->stack().pushInvokeArgs(cx, argc, &args))
 6040:         return JS_FALSE;
 6040: 
50468:     args.callee() = fval;
50468:     args.thisv() = thisv;
50468:     memcpy(args.argv(), argv, argc * sizeof(Value));
48470: 
53557:     if (!Invoke(cx, args, 0))
42714:         return JS_FALSE;
42714: 
50468:     *rval = args.rval();
    1: 
42714:     return JS_TRUE;
    1: }
    1: 
48470: bool
53557: ExternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, const Value &fval,
48470:                  JSAccessMode mode, uintN argc, Value *argv, Value *rval)
    1: {
37741:     LeaveTrace(cx);
24499: 
    1:     /*
53557:      * ExternalInvoke could result in another try to get or set the same id
    1:      * again, see bug 355497.
    1:      */
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
53557:     return ExternalInvoke(cx, obj, fval, argc, argv, rval);
48470: }
48470: 
48470: bool
48470: Execute(JSContext *cx, JSObject *chain, JSScript *script,
53840:         JSStackFrame *prev, uintN flags, Value *result)
53840: {
53840:     JS_ASSERT(chain);
53840:     JS_ASSERT_IF(prev, !prev->isDummyFrame());
53840: 
34290:     if (script->isEmpty()) {
34290:         if (result)
48470:             result->setUndefined();
34290:         return JS_TRUE;
34290:     }
34290: 
37741:     LeaveTrace(cx);
28134: 
42714:     /*
42714:      * Get a pointer to new frame/slots. This memory is not "claimed", so the
42714:      * code before pushExecuteFrame must not reenter the interpreter.
42714:      */
53840:     ExecuteFrameGuard frame;
53840:     if (!cx->stack().getExecuteFrame(cx, script, &frame))
42714:         return false;
53840: 
53840:     /* Initialize frame and locals. */
53840:     JSObject *initialVarObj;
53840:     if (prev) {
53840:         JS_ASSERT(chain == &prev->scopeChain());
55517:         frame.fp()->initEvalFrame(cx, script, prev, flags);
53840: 
53840:         /*
53840:          * We want to call |prev->varobj()|, but this requires knowing the
53840:          * CallStackSegment of |prev|. If |prev == cx->fp()|, the callstack is
53840:          * simply the context's active callstack, so we can use
53840:          * |prev->varobj(cx)|.  When |prev != cx->fp()|, we need to do a slow
53840:          * linear search. Luckily, this only happens with EvaluateInFrame.
53840:          */
53840:         initialVarObj = (prev == cx->maybefp())
53840:                         ? &prev->varobj(cx)
53840:                         : &prev->varobj(cx->containingSegment(prev));
53840:     } else {
53840:         /* The scope chain could be anything, so innerize just in case. */
53840:         JSObject *innerizedChain = chain;
53840:         OBJ_TO_INNER_OBJECT(cx, innerizedChain);
53840:         if (!innerizedChain)
53840:             return false;
53840: 
53840:         /* Initialize frame. */
53840:         frame.fp()->initGlobalFrame(script, *innerizedChain, flags);
53840: 
53840:         /* Compute 'this'. */
53840:         JSObject *thisp = chain->thisObject(cx);
53840:         if (!thisp)
53840:             return false;
53840:         frame.fp()->globalThis().setObject(*thisp);
53840: 
53840:         initialVarObj = (cx->options & JSOPTION_VAROBJFIX)
53840:                         ? chain->getGlobal()
53840:                         : chain;
53840:     }
53840:     JS_ASSERT(!initialVarObj->getOps()->defineProperty);
53840: 
53840:     /* Initialize fixed slots (GVAR ops expect NULL). */
53840:     SetValueRangeToNull(frame.fp()->slots(), script->nfixed);
42714: 
42714: #if JS_HAS_SHARP_VARS
42714:     JS_STATIC_ASSERT(SHARP_NSLOTS == 2);
42714:     if (script->hasSharps) {
42714:         JS_ASSERT(script->nfixed >= SHARP_NSLOTS);
53840:         Value *sharps = &frame.fp()->slots()[script->nfixed - SHARP_NSLOTS];
53840:         if (prev && prev->script()->hasSharps) {
53840:             JS_ASSERT(prev->numFixed() >= SHARP_NSLOTS);
53840:             int base = (prev->isFunctionFrame() && !prev->isEvalOrDebuggerFrame())
53840:                        ? prev->fun()->sharpSlotBase(cx)
53840:                        : prev->numFixed() - SHARP_NSLOTS;
42714:             if (base < 0)
42714:                 return false;
53840:             sharps[0] = prev->slots()[base];
53840:             sharps[1] = prev->slots()[base + 1];
42714:         } else {
48470:             sharps[0].setUndefined();
48470:             sharps[1].setUndefined();
42714:         }
42714:     }
42714: #endif
42714: 
42714:     /* Officially push |fp|. |frame|'s destructor pops. */
53840:     cx->stack().pushExecuteFrame(cx, initialVarObj, &frame);
42714: 
42714:     /* Now that the frame has been pushed, we can call the thisObject hook. */
53840:     if (!prev) {
42714:         JSObject *thisp = chain->thisObject(cx);
42714:         if (!thisp)
42714:             return false;
53840:         frame.fp()->globalThis().setObject(*thisp);
16072:     }
21685: 
53555:     Probes::startExecution(cx, script);
53555: 
42714:     void *hookData = NULL;
42714:     if (JSInterpreterHook hook = cx->debugHooks->executeHook)
53840:         hookData = hook(cx, frame.fp(), JS_TRUE, 0, cx->debugHooks->executeHookData);
53840: 
53840:     /* Run script until JSOP_STOP or error. */
43281:     AutoPreserveEnumerators preserve(cx);
55503:     JSBool ok = RunScript(cx, script, frame.fp());
17828:     if (result)
53840:         *result = frame.fp()->returnValue();
    1: 
    1:     if (hookData) {
42714:         if (JSInterpreterHook hook = cx->debugHooks->executeHook)
53840:             hook(cx, frame.fp(), JS_FALSE, &ok, hookData);
    1:     }
15584: 
53555:     Probes::stopExecution(cx, script);
53555: 
48470:     return !!ok;
48470: }
48470: 
48470: bool
48470: CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
    1:                    JSObject **objp, JSProperty **propp)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
    1:     uintN oldAttrs, report;
30258:     bool isFunction;
    1:     const char *type, *name;
    1: 
24592:     /*
24592:      * Both objp and propp must be either null or given. When given, *propp
24592:      * must be null. This way we avoid an extra "if (propp) *propp = NULL" for
42587:      * the common case of a nonexistent property.
24592:      */
24592:     JS_ASSERT(!objp == !propp);
24592:     JS_ASSERT_IF(propp, !*propp);
24592: 
24592:     /* The JSPROP_INITIALIZER case below may generate a warning. Since we must
24592:      * drop the property before reporting it, we insists on !propp to avoid
24592:      * looking up the property again after the reporting is done.
24592:      */
24592:     JS_ASSERT_IF(attrs & JSPROP_INITIALIZER, attrs == JSPROP_INITIALIZER);
24592:     JS_ASSERT_IF(attrs == JSPROP_INITIALIZER, !propp);
24592: 
31501:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
43290:         return false;
    1:     if (!prop)
43290:         return true;
43290:     if (obj2->isNative()) {
52503:         oldAttrs = ((Shape *) prop)->attributes();
43290:     } else {
43290:         if (!obj2->getAttributes(cx, id, &oldAttrs))
43290:             return false;
    1:     }
    1: 
    1:     if (!propp) {
    1:         prop = NULL;
24592:     } else {
24592:         *objp = obj2;
24592:         *propp = prop;
    1:     }
    1: 
    1:     if (attrs == JSPROP_INITIALIZER) {
    1:         /* Allow the new object to override properties. */
    1:         if (obj2 != obj)
    1:             return JS_TRUE;
24592: 
24592:         /* The property must be dropped already. */
24592:         JS_ASSERT(!prop);
    1:         report = JSREPORT_WARNING | JSREPORT_STRICT;
30258: 
30258: #ifdef __GNUC__
30258:         isFunction = false;     /* suppress bogus gcc warnings */
30258: #endif
    1:     } else {
    1:         /* We allow redeclaring some non-readonly properties. */
    1:         if (((oldAttrs | attrs) & JSPROP_READONLY) == 0) {
24592:             /* Allow redeclaration of variables and functions. */
    1:             if (!(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
    1:                 return JS_TRUE;
24592: 
24592:             /*
24592:              * Allow adding a getter only if a property already has a setter
24592:              * but no getter and similarly for adding a setter. That is, we
24592:              * allow only the following transitions:
24592:              *
24592:              *   no-property --> getter --> getter + setter
24592:              *   no-property --> setter --> getter + setter
24592:              */
    1:             if ((~(oldAttrs ^ attrs) & (JSPROP_GETTER | JSPROP_SETTER)) == 0)
    1:                 return JS_TRUE;
24592: 
24592:             /*
24592:              * Allow redeclaration of an impermanent property (in which case
24592:              * anyone could delete it and redefine it, willy-nilly).
24592:              */
    1:             if (!(oldAttrs & JSPROP_PERMANENT))
    1:                 return JS_TRUE;
    1:         }
    1: 
    1:         report = JSREPORT_ERROR;
    1:         isFunction = (oldAttrs & (JSPROP_GETTER | JSPROP_SETTER)) != 0;
    1:         if (!isFunction) {
48470:             Value value;
31501:             if (!obj->getProperty(cx, id, &value))
24592:                 return JS_FALSE;
48470:             isFunction = IsFunctionObject(value);
    1:         }
    1:     }
    1: 
    1:     type = (attrs == JSPROP_INITIALIZER)
    1:            ? "property"
    1:            : (oldAttrs & attrs & JSPROP_GETTER)
    1:            ? js_getter_str
    1:            : (oldAttrs & attrs & JSPROP_SETTER)
    1:            ? js_setter_str
    1:            : (oldAttrs & JSPROP_READONLY)
    1:            ? js_const_str
    1:            : isFunction
    1:            ? js_function_str
    1:            : js_var_str;
48470:     name = js_ValueToPrintableString(cx, IdToValue(id));
    1:     if (!name)
24592:         return JS_FALSE;
48470:     return !!JS_ReportErrorFlagsAndNumber(cx, report,
    1:                                           js_GetErrorMessage, NULL,
    1:                                           JSMSG_REDECLARED_VAR,
    1:                                           type, name);
    1: }
    1: 
48529: JSBool
48547: HasInstance(JSContext *cx, JSObject *obj, const Value *v, JSBool *bp)
48529: {
48529:     Class *clasp = obj->getClass();
48529:     if (clasp->hasInstance)
48529:         return clasp->hasInstance(cx, obj, v, bp);
48529:     js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
48529:                         JSDVG_SEARCH_STACK, ObjectValue(*obj), NULL);
48529:     return JS_FALSE;
48529: }
48529: 
48470: static JS_ALWAYS_INLINE bool
48470: EqualObjects(JSContext *cx, JSObject *lobj, JSObject *robj)
48470: {
56565:     return lobj == robj;
48470: }
48470: 
48470: bool
48470: StrictlyEqual(JSContext *cx, const Value &lref, const Value &rref)
48470: {
48470:     Value lval = lref, rval = rref;
48470:     if (SameType(lval, rval)) {
48470:         if (lval.isString())
48470:             return js_EqualStrings(lval.toString(), rval.toString());
48470:         if (lval.isDouble())
48470:             return JSDOUBLE_COMPARE(lval.toDouble(), ==, rval.toDouble(), JS_FALSE);
48470:         if (lval.isObject())
48470:             return EqualObjects(cx, &lval.toObject(), &rval.toObject());
53418:         if (lval.isUndefined())
53418:                 return true;
48470:         return lval.payloadAsRawUint32() == rval.payloadAsRawUint32();
48470:     }
48470: 
48470:     if (lval.isDouble() && rval.isInt32()) {
48470:         double ld = lval.toDouble();
48470:         double rd = rval.toInt32();
    1:         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:     }
48470:     if (lval.isInt32() && rval.isDouble()) {
48470:         double ld = lval.toInt32();
48470:         double rd = rval.toDouble();
    1:         return JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
    1:     }
48470: 
48470:     return false;
    1: }
    1: 
32760: static inline bool
48470: IsNegativeZero(const Value &v)
48470: {
48470:     return v.isDouble() && JSDOUBLE_IS_NEGZERO(v.toDouble());
32760: }
32760: 
32760: static inline bool
48470: IsNaN(const Value &v)
48470: {
48470:     return v.isDouble() && JSDOUBLE_IS_NaN(v.toDouble());
48470: }
48470: 
48470: bool
48470: SameValue(const Value &v1, const Value &v2, JSContext *cx)
32760: {
32760:     if (IsNegativeZero(v1))
32760:         return IsNegativeZero(v2);
32760:     if (IsNegativeZero(v2))
48470:         return false;
32760:     if (IsNaN(v1) && IsNaN(v2))
48470:         return true;
48470:     return StrictlyEqual(cx, v1, v2);
48470: }
48470: 
48470: JSType
48470: TypeOfValue(JSContext *cx, const Value &vref)
48470: {
48470:     Value v = vref;
48470:     if (v.isNumber())
48470:         return JSTYPE_NUMBER;
48470:     if (v.isString())
48470:         return JSTYPE_STRING;
48470:     if (v.isNull())
48470:         return JSTYPE_OBJECT;
48470:     if (v.isUndefined())
48470:         return JSTYPE_VOID;
48470:     if (v.isObject())
48622:         return v.toObject().typeOf(cx);
48470:     JS_ASSERT(v.isBoolean());
48470:     return JSTYPE_BOOLEAN;
48470: }
48470: 
48470: bool
48470: InstanceOfSlow(JSContext *cx, JSObject *obj, Class *clasp, Value *argv)
48470: {
48470:     JS_ASSERT(!obj || obj->getClass() != clasp);
48470:     if (argv) {
48470:         JSFunction *fun = js_ValueToFunction(cx, &argv[-2], 0);
48470:         if (fun) {
48470:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
48470:                                  JSMSG_INCOMPATIBLE_PROTO,
48470:                                  clasp->name, JS_GetFunctionName(fun),
48470:                                  obj
48470:                                  ? obj->getClass()->name
48470:                                  : js_null_str);
48470:         }
48470:     }
48470:     return false;
48470: }
48470: 
48470: JS_REQUIRES_STACK bool
50468: InvokeConstructor(JSContext *cx, const CallArgs &argsRef)
    1: {
48529:     JS_ASSERT(!js_FunctionClass.construct);
50468:     CallArgs args = argsRef;
50468: 
53557:     JSObject *callee;
53557:     if (args.callee().isPrimitive() || !(callee = &args.callee().toObject())->getParent()) {
53557:         js_ReportIsNotFunction(cx, &args.callee(), JSV2F_CONSTRUCT);
48529:         return false;
48529:     }
48529: 
53557:     /* Handle the fast-constructors cases before falling into the general case . */
53557:     Class *clasp = callee->getClass();
55503:     JSFunction *fun = NULL;
53557:     if (clasp == &js_FunctionClass) {
55503:         fun = callee->getFunctionPrivate();
53557:         if (fun->isConstructor()) {
53557:             args.thisv().setMagicWithObjectOrNullPayload(NULL);
53557:             return CallJSNativeConstructor(cx, fun->u.n.native, args.argc(), args.base());
53557:         }
53557:     } else if (clasp->construct) {
53557:         args.thisv().setMagicWithObjectOrNullPayload(NULL);
53557:         return CallJSNativeConstructor(cx, clasp->construct, args.argc(), args.base());
53557:     }
53557: 
55503:     /* Scripts create their own |this| in JSOP_BEGIN */
55503:     if (!fun || !fun->isInterpreted()) {
55503:         JSObject *obj = js_CreateThis(cx, callee);
53557:         if (!obj)
48529:             return false;
50468:         args.thisv().setObject(*obj);
55503:     }
53557: 
48470:     if (!Invoke(cx, args, JSINVOKE_CONSTRUCT))
53557:         return false;
    1: 
50468:     if (args.rval().isPrimitive()) {
55503:         if (clasp != &js_FunctionClass) {
    1:             /* native [[Construct]] returning primitive is error */
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_NEW_RESULT,
50468:                                  js_ValueToPrintableString(cx, args.rval()));
53557:             return false;
53557:         }
55503: 
55503:         /* The interpreter fixes rval for us. */
55503:         JS_ASSERT(!fun->isInterpreted());
55503: 
55503:         args.rval() = args.thisv();
53557:     }
53557: 
53557:     JS_RUNTIME_METER(cx->runtime, constructs);
53557:     return true;
53557: }
53557: 
53557: bool
53557: InvokeConstructorWithGivenThis(JSContext *cx, JSObject *thisobj, const Value &fval,
53557:                                uintN argc, Value *argv, Value *rval)
53557: {
53557:     LeaveTrace(cx);
53557: 
53557:     InvokeArgsGuard args;
53840:     if (!cx->stack().pushInvokeArgs(cx, argc, &args))
    1:         return JS_FALSE;
53557: 
53557:     args.callee() = fval;
53557:     /* Initialize args.thisv on all paths below. */
53557:     memcpy(args.argv(), argv, argc * sizeof(Value));
53557: 
53557:     /* Handle the fast-constructor cases before calling the general case. */
53557:     JSObject &callee = fval.toObject();
53557:     Class *clasp = callee.getClass();
53557:     JSFunction *fun;
53557:     bool ok;
53557:     if (clasp == &js_FunctionClass && (fun = callee.getFunctionPrivate())->isConstructor()) {
53557:         args.thisv().setMagicWithObjectOrNullPayload(thisobj);
53557:         ok = CallJSNativeConstructor(cx, fun->u.n.native, args.argc(), args.base());
53557:     } else if (clasp->construct) {
53557:         args.thisv().setMagicWithObjectOrNullPayload(thisobj);
53557:         ok = CallJSNativeConstructor(cx, clasp->construct, args.argc(), args.base());
53557:     } else {
53557:         args.thisv().setObjectOrNull(thisobj);
53557:         ok = Invoke(cx, args, JSINVOKE_CONSTRUCT);
53557:     }
53557: 
53557:     *rval = args.rval();
53557:     return ok;
    1: }
    1: 
48470: bool
48470: ValueToId(JSContext *cx, const Value &v, jsid *idp)
48470: {
48470:     int32_t i;
48470:     if (ValueFitsInInt32(v, &i) && INT_FITS_IN_JSID(i)) {
48470:         *idp = INT_TO_JSID(i);
48470:         return true;
48470:     }
    1: 
    1: #if JS_HAS_XML_SUPPORT
48470:     if (v.isObject()) {
48470:         JSObject *obj = &v.toObject();
48591:         if (obj->isXMLId()) {
48470:             *idp = OBJECT_TO_JSID(obj);
    1:             return JS_TRUE;
    1:         }
    1:     }
    1: #endif
    1: 
48470:     return js_ValueToStringId(cx, v, idp);
48470: }
48470: 
48470: } /* namespace js */
    1: 
    1: /*
11672:  * Enter the new with scope using an object at sp[-1] and associate the depth
11672:  * of the with block with sp + stackIndex.
11672:  */
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK JSBool
55527: js_EnterWith(JSContext *cx, jsint stackIndex, JSOp op, size_t oplen)
11672: {
51446:     JSStackFrame *fp = cx->fp();
48470:     Value *sp = cx->regs->sp;
11672:     JS_ASSERT(stackIndex < 0);
48470:     JS_ASSERT(fp->base() <= sp + stackIndex);
48470: 
48470:     JSObject *obj;
48470:     if (sp[-1].isObject()) {
48470:         obj = &sp[-1].toObject();
11672:     } else {
11672:         obj = js_ValueToNonNullObject(cx, sp[-1]);
11672:         if (!obj)
    1:             return JS_FALSE;
48470:         sp[-1].setObject(*obj);
48470:     }
48470: 
55527:     JSObject *parent = js_GetScopeChainFast(cx, fp, op, oplen);
11672:     if (!parent)
11672:         return JS_FALSE;
11672: 
11672:     OBJ_TO_INNER_OBJECT(cx, obj);
11672:     if (!obj)
11672:         return JS_FALSE;
11672: 
48470:     JSObject *withobj = js_NewWithObject(cx, obj, parent,
48470:                                          sp + stackIndex - fp->base());
11672:     if (!withobj)
11672:         return JS_FALSE;
11672: 
53840:     fp->setScopeChainNoCallObj(*withobj);
    1:     return JS_TRUE;
    1: }
    1: 
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK void
12551: js_LeaveWith(JSContext *cx)
11672: {
11672:     JSObject *withobj;
11672: 
53840:     withobj = &cx->fp()->scopeChain();
40826:     JS_ASSERT(withobj->getClass() == &js_WithClass);
51446:     JS_ASSERT(withobj->getPrivate() == js_FloatingFrameIfGenerator(cx, cx->fp()));
11758:     JS_ASSERT(OBJ_BLOCK_DEPTH(cx, withobj) >= 0);
31452:     withobj->setPrivate(NULL);
53840:     cx->fp()->setScopeChainNoCallObj(*withobj->getParent());
11672: }
11672: 
48470: JS_REQUIRES_STACK Class *
12551: js_IsActiveWithOrBlock(JSContext *cx, JSObject *obj, int stackDepth)
11758: {
48470:     Class *clasp;
11758: 
40826:     clasp = obj->getClass();
11758:     if ((clasp == &js_WithClass || clasp == &js_BlockClass) &&
51446:         obj->getPrivate() == js_FloatingFrameIfGenerator(cx, cx->fp()) &&
11758:         OBJ_BLOCK_DEPTH(cx, obj) >= stackDepth) {
11758:         return clasp;
11758:     }
11758:     return NULL;
11758: }
11758: 
11758: /*
11758:  * Unwind block and scope chains to match the given depth. The function sets
11758:  * fp->sp on return to stackDepth.
11758:  */
53114: JS_REQUIRES_STACK JSBool
42717: js_UnwindScope(JSContext *cx, jsint stackDepth, JSBool normalUnwind)
11758: {
48470:     Class *clasp;
11758: 
11758:     JS_ASSERT(stackDepth >= 0);
51446:     JS_ASSERT(cx->fp()->base() + stackDepth <= cx->regs->sp);
51446: 
51446:     JSStackFrame *fp = cx->fp();
11758:     for (;;) {
53840:         clasp = js_IsActiveWithOrBlock(cx, &fp->scopeChain(), stackDepth);
11758:         if (!clasp)
11758:             break;
11758:         if (clasp == &js_BlockClass) {
11758:             /* Don't fail until after we've updated all stacks. */
11859:             normalUnwind &= js_PutBlockObject(cx, normalUnwind);
11758:         } else {
12551:             js_LeaveWith(cx);
11758:         }
11758:     }
11758: 
48470:     cx->regs->sp = fp->base() + stackDepth;
11758:     return normalUnwind;
11758: }
11758: 
15996: JS_STATIC_INTERPRET JSBool
48470: js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, Value *vp, Value *vp2)
12611: {
40828:     if (cs->format & JOF_POST) {
40828:         double d;
48470:         if (!ValueToNumber(cx, *vp, &d))
12611:             return JS_FALSE;
48470:         vp->setNumber(d);
40828:         (cs->format & JOF_INC) ? ++d : --d;
48470:         vp2->setNumber(d);
48470:         return JS_TRUE;
40828:     }
40828: 
40828:     double d;
40828:     if (!ValueToNumber(cx, *vp, &d))
12611:         return JS_FALSE;
40828:     (cs->format & JOF_INC) ? ++d : --d;
48470:     vp->setNumber(d);
48470:     *vp2 = *vp;
12611:     return JS_TRUE;
12611: }
12611: 
48470: const Value &
48582: js::GetUpvar(JSContext *cx, uintN closureLevel, UpvarCookie cookie)
48582: {
48582:     JS_ASSERT(closureLevel >= cookie.level() && cookie.level() > 0);
48582:     const uintN targetLevel = closureLevel - cookie.level();
48582:     JS_ASSERT(targetLevel < UpvarCookie::UPVAR_LEVEL_LIMIT);
48582: 
48582:     JSStackFrame *fp = cx->findFrameAtLevel(targetLevel);
47573:     uintN slot = cookie.slot();
48470:     Value *vp;
27168: 
53840:     if (!fp->isFunctionFrame() || fp->isEvalFrame()) {
53840:         vp = fp->slots() + fp->numFixed();
51120:     } else if (slot < fp->numFormalArgs()) {
53840:         vp = fp->formalArgs();
47573:     } else if (slot == UpvarCookie::CALLEE_SLOT) {
53840:         vp = &fp->calleeValue();
27168:         slot = 0;
27168:     } else {
51120:         slot -= fp->numFormalArgs();
53840:         JS_ASSERT(slot < fp->numSlots());
42714:         vp = fp->slots();
27168:     }
27168: 
27168:     return vp[slot];
27168: }
27168: 
15453: #ifdef DEBUG
15453: 
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK void
56604: js_LogOpcode(JSContext *cx)
56604: {
56604:     FILE *logfp;
15453:     JSStackFrame *fp;
15453:     JSFrameRegs *regs;
15453:     intN ndefs, n, nuses;
15453:     JSString *str;
15453:     JSOp op;
15453: 
56604:     logfp = (FILE *) cx->logfp;
56604:     JS_ASSERT(logfp);
51446:     fp = cx->fp();
42717:     regs = cx->regs;
26954: 
26954:     /*
26954:      * Operations in prologues don't produce interesting values, and
26954:      * js_DecompileValueGenerator isn't set up to handle them anyway.
26954:      */
56604:     if (cx->logPrevPc && regs->pc >= fp->script()->main) {
56604:         JSOp logPrevOp = JSOp(*cx->logPrevPc);
56604:         ndefs = js_GetStackDefs(cx, &js_CodeSpec[logPrevOp], logPrevOp,
56604:                                 fp->script(), cx->logPrevPc);
26954: 
26954:         /*
32658:          * If there aren't that many elements on the stack, then we have
32658:          * probably entered a new frame, and printing output would just be
32658:          * misleading.
26954:          */
26954:         if (ndefs != 0 &&
42714:             ndefs < regs->sp - fp->slots()) {
15453:             for (n = -ndefs; n < 0; n++) {
48470:                 char *bytes = DecompileValueGenerator(cx, n, regs->sp[n], NULL);
15453:                 if (bytes) {
56604:                     fprintf(logfp, "%s %s",
15453:                             (n == -ndefs) ? "  output:" : ",",
15453:                             bytes);
30851:                     cx->free(bytes);
41965:                 } else {
41965:                     JS_ClearPendingException(cx);
15453:                 }
15453:             }
56604:             fprintf(logfp, " @ %u\n", (uintN) (regs->sp - fp->base()));
56604:         }
56604:         fprintf(logfp, "  stack: ");
48470:         for (Value *siter = fp->base(); siter < regs->sp; siter++) {
56604:             if (siter->isObject() && siter->toObject().getClass() == &js_CallClass) {
56604:                 /*
56604:                  * Call objects have NULL convert ops so that we catch cases
56604:                  * where they escape. So js_ValueToString doesn't work on them.
56604:                  */
56604:                 fputs("<call>", logfp);
56604:             } else {
15453:                 str = js_ValueToString(cx, *siter);
41965:                 if (!str) {
56604:                     fputs("<null>", logfp);
41965:                 } else {
41965:                     JS_ClearPendingException(cx);
56604:                     js_FileEscapedString(logfp, str, 0);
56604:                 }
56604:             }
56604:             fputc(' ', logfp);
56604:         }
56604:         fputc('\n', logfp);
56604:     }
56604: 
56604:     fprintf(logfp, "%4u: ",
53840:             js_PCToLineNumber(cx, fp->script(),
53840:                               fp->hasImacropc() ? fp->imacropc() : regs->pc));
53840:     js_Disassemble1(cx, fp->script(), regs->pc,
53840:                     regs->pc - fp->script()->code,
56604:                     JS_FALSE, logfp);
15453:     op = (JSOp) *regs->pc;
26955:     nuses = js_GetStackUses(&js_CodeSpec[op], op, regs->pc);
15453:     if (nuses != 0) {
15453:         for (n = -nuses; n < 0; n++) {
48470:             char *bytes = DecompileValueGenerator(cx, n, regs->sp[n], NULL);
15453:             if (bytes) {
56604:                 fprintf(logfp, "%s %s",
15453:                         (n == -nuses) ? "  inputs:" : ",",
15453:                         bytes);
30851:                 cx->free(bytes);
41965:             } else {
41965:                 JS_ClearPendingException(cx);
15453:             }
15453:         }
56604:         fprintf(logfp, " @ %u\n", (uintN) (regs->sp - fp->base()));
56604:     }
56604:     cx->logPrevPc = regs->pc;
56604: 
56604:     /* It's nice to have complete logs when debugging a crash.  */
56604:     fflush(logfp);
15453: }
15453: 
15453: #endif /* DEBUG */
15453: 
12551: #ifdef JS_OPMETER
    1: 
    1: # include <stdlib.h>
    1: 
12551: # define HIST_NSLOTS            8
12551: 
    1: /*
    1:  * The second dimension is hardcoded at 256 because we know that many bits fit
    1:  * in a byte, and mainly to optimize away multiplying by JSOP_LIMIT to address
    1:  * any particular row.
    1:  */
    1: static uint32 succeeds[JSOP_LIMIT][256];
    1: static uint32 slot_ops[JSOP_LIMIT][HIST_NSLOTS];
    1: 
15996: JS_STATIC_INTERPRET void
12551: js_MeterOpcodePair(JSOp op1, JSOp op2)
12551: {
12551:     if (op1 != JSOP_STOP)
12551:         ++succeeds[op1][op2];
12551: }
12551: 
15996: JS_STATIC_INTERPRET void
12551: js_MeterSlotOpcode(JSOp op, uint32 slot)
12551: {
12551:     if (slot < HIST_NSLOTS)
12551:         ++slot_ops[op][slot];
12551: }
12551: 
    1: typedef struct Edge {
    1:     const char  *from;
    1:     const char  *to;
    1:     uint32      count;
    1: } Edge;
    1: 
    1: static int
    1: compare_edges(const void *a, const void *b)
    1: {
    1:     const Edge *ea = (const Edge *) a;
    1:     const Edge *eb = (const Edge *) b;
    1: 
    1:     return (int32)eb->count - (int32)ea->count;
    1: }
    1: 
    1: void
    1: js_DumpOpMeters()
    1: {
    1:     const char *name, *from, *style;
    1:     FILE *fp;
    1:     uint32 total, count;
    1:     uint32 i, j, nedges;
    1:     Edge *graph;
    1: 
    1:     name = getenv("JS_OPMETER_FILE");
    1:     if (!name)
    1:         name = "/tmp/ops.dot";
    1:     fp = fopen(name, "w");
    1:     if (!fp) {
    1:         perror(name);
    1:         return;
    1:     }
    1: 
    1:     total = nedges = 0;
    1:     for (i = 0; i < JSOP_LIMIT; i++) {
    1:         for (j = 0; j < JSOP_LIMIT; j++) {
    1:             count = succeeds[i][j];
    1:             if (count != 0) {
    1:                 total += count;
    1:                 ++nedges;
    1:             }
    1:         }
    1:     }
    1: 
    1: # define SIGNIFICANT(count,total) (200. * (count) >= (total))
    1: 
30851:     graph = (Edge *) js_calloc(nedges * sizeof graph[0]);
56017:     if (!graph)
56017:         return;
    1:     for (i = nedges = 0; i < JSOP_LIMIT; i++) {
12410:         from = js_CodeName[i];
    1:         for (j = 0; j < JSOP_LIMIT; j++) {
    1:             count = succeeds[i][j];
    1:             if (count != 0 && SIGNIFICANT(count, total)) {
    1:                 graph[nedges].from = from;
12410:                 graph[nedges].to = js_CodeName[j];
    1:                 graph[nedges].count = count;
    1:                 ++nedges;
    1:             }
    1:         }
    1:     }
    1:     qsort(graph, nedges, sizeof(Edge), compare_edges);
    1: 
    1: # undef SIGNIFICANT
    1: 
    1:     fputs("digraph {\n", fp);
    1:     for (i = 0, style = NULL; i < nedges; i++) {
    1:         JS_ASSERT(i == 0 || graph[i-1].count >= graph[i].count);
    1:         if (!style || graph[i-1].count != graph[i].count) {
    1:             style = (i > nedges * .75) ? "dotted" :
    1:                     (i > nedges * .50) ? "dashed" :
    1:                     (i > nedges * .25) ? "solid" : "bold";
    1:         }
    1:         fprintf(fp, "  %s -> %s [label=\"%lu\" style=%s]\n",
    1:                 graph[i].from, graph[i].to,
    1:                 (unsigned long)graph[i].count, style);
    1:     }
30851:     js_free(graph);
    1:     fputs("}\n", fp);
    1:     fclose(fp);
    1: 
    1:     name = getenv("JS_OPMETER_HIST");
    1:     if (!name)
    1:         name = "/tmp/ops.hist";
    1:     fp = fopen(name, "w");
    1:     if (!fp) {
    1:         perror(name);
    1:         return;
    1:     }
    1:     fputs("bytecode", fp);
    1:     for (j = 0; j < HIST_NSLOTS; j++)
    1:         fprintf(fp, "  slot %1u", (unsigned)j);
    1:     putc('\n', fp);
    1:     fputs("========", fp);
    1:     for (j = 0; j < HIST_NSLOTS; j++)
    1:         fputs(" =======", fp);
    1:     putc('\n', fp);
    1:     for (i = 0; i < JSOP_LIMIT; i++) {
    1:         for (j = 0; j < HIST_NSLOTS; j++) {
    1:             if (slot_ops[i][j] != 0) {
    1:                 /* Reuse j in the next loop, since we break after. */
12410:                 fprintf(fp, "%-8.8s", js_CodeName[i]);
    1:                 for (j = 0; j < HIST_NSLOTS; j++)
    1:                     fprintf(fp, " %7lu", (unsigned long)slot_ops[i][j]);
    1:                 putc('\n', fp);
    1:                 break;
    1:             }
    1:         }
    1:     }
    1:     fclose(fp);
    1: }
    1: 
    1: #endif /* JS_OPSMETER */
    1: 
15996: #endif /* !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___ */
15996: 
15996: #ifndef  jsinvoke_cpp___
12551: 
39932: #ifdef JS_REPRMETER
39932: // jsval representation metering: this measures the kinds of jsvals that
39932: // are used as inputs to each JSOp.
39932: namespace reprmeter {
39932:     enum Repr {
39932:         NONE,
39932:         INT,
39932:         DOUBLE,
39932:         BOOLEAN_PROPER,
39932:         BOOLEAN_OTHER,
39932:         STRING,
39932:         OBJECT_NULL,
39932:         OBJECT_PLAIN,
39932:         FUNCTION_INTERPRETED,
39932:         FUNCTION_FASTNATIVE,
39932:         ARRAY_SLOW,
39932:         ARRAY_DENSE
39932:     };
39932: 
39932:     // Return the |repr| value giving the representation of the given jsval.
39932:     static Repr
39932:     GetRepr(jsval v)
39932:     {
39932:         if (JSVAL_IS_INT(v))
39932:             return INT;
39932:         if (JSVAL_IS_DOUBLE(v))
39932:             return DOUBLE;
39932:         if (JSVAL_IS_SPECIAL(v)) {
39932:             return (v == JSVAL_TRUE || v == JSVAL_FALSE)
39932:                    ? BOOLEAN_PROPER
39932:                    : BOOLEAN_OTHER;
39932:         }
39932:         if (JSVAL_IS_STRING(v))
39932:             return STRING;
39932: 
39932:         JS_ASSERT(JSVAL_IS_OBJECT(v));
39932: 
39932:         JSObject *obj = JSVAL_TO_OBJECT(v);
39932:         if (VALUE_IS_FUNCTION(cx, v)) {
53840:             JSFunction *fun = obj->getFunctionPrivate();
39932:             if (FUN_INTERPRETED(fun))
39932:                 return FUNCTION_INTERPRETED;
39932:             return FUNCTION_FASTNATIVE;
39932:         }
39932:         // This must come before the general array test, because that
39932:         // one subsumes this one.
39932:         if (!obj)
39932:             return OBJECT_NULL;
39932:         if (obj->isDenseArray())
39932:             return ARRAY_DENSE;
39932:         if (obj->isArray())
39932:             return ARRAY_SLOW;
39932:         return OBJECT_PLAIN;
39932:     }
39932: 
39932:     static const char *reprName[] = { "invalid", "int", "double", "bool", "special",
39932:                                       "string", "null", "object",
53557:                                       "fun:interp", "fun:native"
39932:                                       "array:slow", "array:dense" };
39932: 
39932:     // Logically, a tuple of (JSOp, repr_1, ..., repr_n) where repr_i is
39932:     // the |repr| of the ith input to the JSOp.
39932:     struct OpInput {
39932:         enum { max_uses = 16 };
39932: 
39932:         JSOp op;
39932:         Repr uses[max_uses];
39932: 
39932:         OpInput() : op(JSOp(255)) {
39932:             for (int i = 0; i < max_uses; ++i)
39932:                 uses[i] = NONE;
39932:         }
39932: 
39932:         OpInput(JSOp op) : op(op) {
39932:             for (int i = 0; i < max_uses; ++i)
39932:                 uses[i] = NONE;
39932:         }
39932: 
39932:         // Hash function
39932:         operator uint32() const {
39932:             uint32 h = op;
39932:             for (int i = 0; i < max_uses; ++i)
39932:                 h = h * 7 + uses[i] * 13;
39932:             return h;
39932:         }
39932: 
39932:         bool operator==(const OpInput &opinput) const {
39932:             if (op != opinput.op)
39932:                 return false;
39932:             for (int i = 0; i < max_uses; ++i) {
39932:                 if (uses[i] != opinput.uses[i])
39932:                     return false;
39932:             }
39932:             return true;
39932:         }
39932: 
39932:         OpInput &operator=(const OpInput &opinput) {
39932:             op = opinput.op;
39932:             for (int i = 0; i < max_uses; ++i)
39932:                 uses[i] = opinput.uses[i];
39932:             return *this;
39932:         }
39932:     };
39932: 
39932:     typedef HashMap<OpInput, uint64, DefaultHasher<OpInput>, SystemAllocPolicy> OpInputHistogram;
39932: 
39932:     OpInputHistogram opinputs;
39932:     bool             opinputsInitialized = false;
39932: 
39932:     // Record an OpInput for the current op. This should be called just
39932:     // before executing the op.
39932:     static void
42748:     MeterRepr(JSContext *cx)
39932:     {
39932:         // Note that we simply ignore the possibility of errors (OOMs)
39932:         // using the hash map, since this is only metering code.
39932: 
39932:         if (!opinputsInitialized) {
39932:             opinputs.init();
39932:             opinputsInitialized = true;
39932:         }
39932: 
42748:         JSOp op = JSOp(*cx->regs->pc);
42748:         int nuses = js_GetStackUses(&js_CodeSpec[op], op, cx->regs->pc);
39932: 
39932:         // Build the OpInput.
39932:         OpInput opinput(op);
42748:         for (int i = 0; i < nuses; ++i) {
42748:             jsval v = cx->regs->sp[-nuses+i];
39932:             opinput.uses[i] = GetRepr(v);
39932:         }
39932: 
39932:         OpInputHistogram::AddPtr p = opinputs.lookupForAdd(opinput);
39932:         if (p)
39932:             ++p->value;
39932:         else
39932:             opinputs.add(p, opinput, 1);
39932:     }
39932: 
39932:     void
39932:     js_DumpReprMeter()
39932:     {
39932:         FILE *f = fopen("/tmp/reprmeter.txt", "w");
39932:         JS_ASSERT(f);
39932:         for (OpInputHistogram::Range r = opinputs.all(); !r.empty(); r.popFront()) {
39932:             const OpInput &o = r.front().key;
39932:             uint64 c = r.front().value;
39932:             fprintf(f, "%3d,%s", o.op, js_CodeName[o.op]);
39932:             for (int i = 0; i < OpInput::max_uses && o.uses[i] != NONE; ++i)
39932:                 fprintf(f, ",%s", reprName[o.uses[i]]);
39932:             fprintf(f, ",%llu\n", c);
39932:         }
39932:         fclose(f);
39932:     }
39932: }
39932: #endif /* JS_REPRMETER */
39932: 
55638: #define PUSH_COPY(v)             do { *regs.sp++ = v; assertSameCompartment(cx, regs.sp[-1]); } while (0)
48470: #define PUSH_NULL()              regs.sp++->setNull()
48470: #define PUSH_UNDEFINED()         regs.sp++->setUndefined()
48470: #define PUSH_BOOLEAN(b)          regs.sp++->setBoolean(b)
48470: #define PUSH_DOUBLE(d)           regs.sp++->setDouble(d)
48470: #define PUSH_INT32(i)            regs.sp++->setInt32(i)
55638: #define PUSH_STRING(s)           do { regs.sp++->setString(s); assertSameCompartment(cx, regs.sp[-1]); } while (0)
55638: #define PUSH_OBJECT(obj)         do { regs.sp++->setObject(obj); assertSameCompartment(cx, regs.sp[-1]); } while (0)
55638: #define PUSH_OBJECT_OR_NULL(obj) do { regs.sp++->setObjectOrNull(obj); assertSameCompartment(cx, regs.sp[-1]); } while (0)
48470: #define PUSH_HOLE()              regs.sp++->setMagic(JS_ARRAY_HOLE)
48470: #define POP_COPY_TO(v)           v = *--regs.sp
53840: #define POP_RETURN_VALUE()       regs.fp->setReturnValue(*--regs.sp)
48470: 
48470: #define POP_BOOLEAN(cx, vp, b)                                                \
12551:     JS_BEGIN_MACRO                                                            \
48470:         vp = &regs.sp[-1];                                                    \
48470:         if (vp->isNull()) {                                                   \
48470:             b = false;                                                        \
48470:         } else if (vp->isBoolean()) {                                         \
48470:             b = vp->toBoolean();                                              \
12551:         } else {                                                              \
48470:             b = !!js_ValueToBoolean(*vp);                                     \
12551:         }                                                                     \
13168:         regs.sp--;                                                            \
12551:     JS_END_MACRO
12551: 
48470: #define VALUE_TO_OBJECT(cx, vp, obj)                                          \
12551:     JS_BEGIN_MACRO                                                            \
48470:         if ((vp)->isObject()) {                                               \
48470:             obj = &(vp)->toObject();                                          \
12551:         } else {                                                              \
48470:             obj = js_ValueToNonNullObject(cx, *(vp));                         \
12551:             if (!obj)                                                         \
12551:                 goto error;                                                   \
48470:             (vp)->setObject(*obj);                                            \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
48470: #define FETCH_OBJECT(cx, n, obj)                                              \
12551:     JS_BEGIN_MACRO                                                            \
48470:         Value *vp_ = &regs.sp[n];                                             \
48470:         VALUE_TO_OBJECT(cx, vp_, obj);                                        \
12551:     JS_END_MACRO
12551: 
12551: #define DEFAULT_VALUE(cx, n, hint, v)                                         \
12551:     JS_BEGIN_MACRO                                                            \
48470:         JS_ASSERT(v.isObject());                                              \
13168:         JS_ASSERT(v == regs.sp[n]);                                           \
48470:         if (!DefaultValue(cx, &v.toObject(), hint, &regs.sp[n]))              \
12551:             goto error;                                                       \
13168:         v = regs.sp[n];                                                       \
12551:     JS_END_MACRO
12551: 
48470: /* Test whether v is an int in the range [-2^31 + 1, 2^31 - 2] */
48470: static JS_ALWAYS_INLINE bool
48470: CanIncDecWithoutOverflow(int32_t i)
48470: {
48470:     return (i > JSVAL_INT_MIN) && (i < JSVAL_INT_MAX);
48470: }
12611: 
12611: /*
12551:  * Define JS_OPMETER to instrument bytecode succession, generating a .dot file
12551:  * on shutdown that shows the graph of significant predecessor/successor pairs
12551:  * executed, where the edge labels give the succession counts.  The .dot file
12551:  * is named by the JS_OPMETER_FILE envariable, and defaults to /tmp/ops.dot.
12551:  *
12551:  * Bonus feature: JS_OPMETER also enables counters for stack-addressing ops
16429:  * such as JSOP_GETLOCAL, JSOP_INCARG, via METER_SLOT_OP. The resulting counts
12551:  * are written to JS_OPMETER_HIST, defaulting to /tmp/ops.hist.
12551:  */
12551: #ifndef JS_OPMETER
12551: # define METER_OP_INIT(op)      /* nothing */
12551: # define METER_OP_PAIR(op1,op2) /* nothing */
12551: # define METER_SLOT_OP(op,slot) /* nothing */
12551: #else
12551: 
12551: /*
12551:  * The second dimension is hardcoded at 256 because we know that many bits fit
12551:  * in a byte, and mainly to optimize away multiplying by JSOP_LIMIT to address
12551:  * any particular row.
12551:  */
12551: # define METER_OP_INIT(op)      ((op) = JSOP_STOP)
12551: # define METER_OP_PAIR(op1,op2) (js_MeterOpcodePair(op1, op2))
12551: # define METER_SLOT_OP(op,slot) (js_MeterSlotOpcode(op, slot))
12551: 
    1: #endif
    1: 
39932: #ifdef JS_REPRMETER
42748: # define METER_REPR(cx)         (reprmeter::MeterRepr(cx))
39932: #else
42748: # define METER_REPR(cx)         ((void) 0)
39932: #endif /* JS_REPRMETER */
39932: 
    1: /*
    1:  * Threaded interpretation via computed goto appears to be well-supported by
    1:  * GCC 3 and higher.  IBM's C compiler when run with the right options (e.g.,
    1:  * -qlanglvl=extended) also supports threading.  Ditto the SunPro C compiler.
    1:  * Currently it's broken for JS_VERSION < 160, though this isn't worth fixing.
    1:  * Add your compiler support macros here.
    1:  */
    1: #ifndef JS_THREADED_INTERP
    1: # if JS_VERSION >= 160 && (                                                   \
    1:     __GNUC__ >= 3 ||                                                          \
    1:     (__IBMC__ >= 700 && defined __IBM_COMPUTED_GOTO) ||                       \
    1:     __SUNPRO_C >= 0x570)
    1: #  define JS_THREADED_INTERP 1
    1: # else
    1: #  define JS_THREADED_INTERP 0
    1: # endif
    1: #endif
    1: 
15453: /*
27164:  * Deadlocks or else bad races are likely if JS_THREADSAFE, so we must rely on
27164:  * single-thread DEBUG js shell testing to verify property cache hits.
27164:  */
27164: #if defined DEBUG && !defined JS_THREADSAFE
27164: 
27164: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry)                \
27164:     JS_BEGIN_MACRO                                                            \
27164:         if (!AssertValidPropertyCacheHit(cx, script, regs, pcoff, obj, pobj,  \
27164:                                          entry)) {                            \
27164:             goto error;                                                       \
27164:         }                                                                     \
27164:     JS_END_MACRO
27164: 
27164: static bool
27164: AssertValidPropertyCacheHit(JSContext *cx, JSScript *script, JSFrameRegs& regs,
27164:                             ptrdiff_t pcoff, JSObject *start, JSObject *found,
40362:                             PropertyCacheEntry *entry)
27164: {
27164:     uint32 sample = cx->runtime->gcNumber;
27164: 
27164:     JSAtom *atom;
27164:     if (pcoff >= 0)
27164:         GET_ATOM_FROM_BYTECODE(script, regs.pc, pcoff, atom);
27164:     else
27164:         atom = cx->runtime->atomState.lengthAtom;
27164: 
27164:     JSObject *obj, *pobj;
27164:     JSProperty *prop;
33166:     JSBool ok;
27164: 
27164:     if (JOF_OPMODE(*regs.pc) == JOF_NAME) {
27164:         ok = js_FindProperty(cx, ATOM_TO_JSID(atom), &obj, &pobj, &prop);
27164:     } else {
27164:         obj = start;
27164:         ok = js_LookupProperty(cx, obj, ATOM_TO_JSID(atom), &pobj, &prop);
27164:     }
27164:     if (!ok)
27164:         return false;
56567:     if (cx->runtime->gcNumber != sample || entry->vshape() != pobj->shape())
27164:         return true;
27164:     JS_ASSERT(prop);
27164:     JS_ASSERT(pobj == found);
27164: 
52503:     const Shape *shape = (Shape *) prop;
40374:     if (entry->vword.isSlot()) {
52503:         JS_ASSERT(entry->vword.toSlot() == shape->slot);
52503:         JS_ASSERT(!shape->isMethod());
52503:     } else if (entry->vword.isShape()) {
52503:         JS_ASSERT(entry->vword.toShape() == shape);
52503:         JS_ASSERT_IF(shape->isMethod(),
56567:                      &shape->methodObject() == &pobj->nativeGetSlot(shape->slot).toObject());
27164:     } else {
48470:         Value v;
48470:         JS_ASSERT(entry->vword.isFunObj());
40374:         JS_ASSERT(!entry->vword.isNull());
52503:         JS_ASSERT(pobj->brandedOrHasMethodBarrier());
52503:         JS_ASSERT(shape->hasDefaultGetterOrIsMethod());
52503:         JS_ASSERT(pobj->containsSlot(shape->slot));
56567:         v = pobj->nativeGetSlot(shape->slot);
48470:         JS_ASSERT(&entry->vword.toFunObj() == &v.toObject());
32658: 
52503:         if (shape->isMethod()) {
32658:             JS_ASSERT(js_CodeSpec[*regs.pc].format & JOF_CALLOP);
52503:             JS_ASSERT(&shape->methodObject() == &v.toObject());
32658:         }
27164:     }
27164: 
27164:     return true;
27164: }
27164: 
27164: #else
27164: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry) ((void) 0)
27164: #endif
27164: 
27164: /*
    1:  * Ensure that the intrepreter switch can close call-bytecode cases in the
    1:  * same way as non-call bytecodes.
    1:  */
    1: JS_STATIC_ASSERT(JSOP_NAME_LENGTH == JSOP_CALLNAME_LENGTH);
18308: JS_STATIC_ASSERT(JSOP_GETUPVAR_LENGTH == JSOP_CALLUPVAR_LENGTH);
28952: JS_STATIC_ASSERT(JSOP_GETUPVAR_DBG_LENGTH == JSOP_CALLUPVAR_DBG_LENGTH);
28952: JS_STATIC_ASSERT(JSOP_GETUPVAR_DBG_LENGTH == JSOP_GETUPVAR_LENGTH);
52503: JS_STATIC_ASSERT(JSOP_GETFCSLOT_LENGTH == JSOP_CALLFCSLOT_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETARG_LENGTH == JSOP_CALLARG_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETLOCAL_LENGTH == JSOP_CALLLOCAL_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_XMLNAME_LENGTH == JSOP_CALLXMLNAME_LENGTH);
    1: 
11377: /*
28952:  * Same for debuggable flat closures defined at top level in another function
28952:  * or program fragment.
28952:  */
28952: JS_STATIC_ASSERT(JSOP_DEFFUN_FC_LENGTH == JSOP_DEFFUN_DBGFC_LENGTH);
28952: 
28952: /*
11377:  * Same for JSOP_SETNAME and JSOP_SETPROP, which differ only slightly but
32658:  * remain distinct for the decompiler. Likewise for JSOP_INIT{PROP,METHOD}.
11377:  */
11377: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
32658: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETMETHOD_LENGTH);
32658: JS_STATIC_ASSERT(JSOP_INITPROP_LENGTH == JSOP_INITMETHOD_LENGTH);
11377: 
15464: /* See TRY_BRANCH_AFTER_COND. */
15464: JS_STATIC_ASSERT(JSOP_IFNE_LENGTH == JSOP_IFEQ_LENGTH);
15464: JS_STATIC_ASSERT(JSOP_IFNE == JSOP_IFEQ + 1);
15464: 
16051: /* For the fastest case inder JSOP_INCNAME, etc. */
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_DECNAME_LENGTH);
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEINC_LENGTH);
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEDEC_LENGTH);
16051: 
27479: #ifdef JS_TRACER
27479: # define ABORT_RECORDING(cx, reason)                                          \
27479:     JS_BEGIN_MACRO                                                            \
27479:         if (TRACE_RECORDER(cx))                                               \
37741:             AbortRecording(cx, reason);                                       \
27479:     JS_END_MACRO
27479: #else
27464: # define ABORT_RECORDING(cx, reason)    ((void) 0)
27479: #endif
27479: 
42641: /*
42641:  * Inline fast paths for iteration. js_IteratorMore and js_IteratorNext handle
42641:  * all cases, but we inline the most frequently taken paths here.
42641:  */
42641: static inline bool
48470: IteratorMore(JSContext *cx, JSObject *iterobj, bool *cond, Value *rval)
42641: {
48622:     if (iterobj->getClass() == &js_IteratorClass) {
42641:         NativeIterator *ni = (NativeIterator *) iterobj->getPrivate();
42641:         *cond = (ni->props_cursor < ni->props_end);
42641:     } else {
42641:         if (!js_IteratorMore(cx, iterobj, rval))
42641:             return false;
48470:         *cond = rval->isTrue();
42641:     }
42641:     return true;
42641: }
42641: 
42641: static inline bool
48470: IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
42641: {
48622:     if (iterobj->getClass() == &js_IteratorClass) {
42641:         NativeIterator *ni = (NativeIterator *) iterobj->getPrivate();
42641:         JS_ASSERT(ni->props_cursor < ni->props_end);
48470:         if (ni->isKeyIter()) {
48470:             jsid id = *ni->currentKey();
48470:             if (JSID_IS_ATOM(id)) {
48470:                 rval->setString(JSID_TO_STRING(id));
48470:                 ni->incKeyCursor();
42641:                 return true;
42641:             }
42641:             /* Take the slow path if we have to stringify a numeric property name. */
48470:         } else {
48470:             *rval = *ni->currentValue();
48470:             ni->incValueCursor();
48470:             return true;
48470:         }
42641:     }
42641:     return js_IteratorNext(cx, iterobj, rval);
42641: }
42641: 
56201: static inline bool
56201: ScriptPrologue(JSContext *cx, JSStackFrame *fp)
56201: {
56201:     if (fp->isConstructing()) {
56201:         JSObject *obj = js_CreateThisForFunction(cx, &fp->callee());
56201:         if (!obj)
56201:             return false;
56201:         fp->functionThis().setObject(*obj);
56201:     }
56201:     JSInterpreterHook hook = cx->debugHooks->callHook;
56201:     if (JS_UNLIKELY(hook != NULL) && !fp->isExecuteFrame())
56201:         fp->setHookData(hook(cx, fp, JS_TRUE, 0, cx->debugHooks->callHookData));
56201: 
56201:     Probes::enterJSFun(cx, fp->maybeFun());
56201: 
56201:     return true;
56201: }
48470: 
48470: namespace js {
48470: 
54407: JS_REQUIRES_STACK JS_NEVER_INLINE bool
56201: Interpret(JSContext *cx, JSStackFrame *entryFrame, uintN inlineCallCount, JSInterpMode interpMode)
    1: {
29368: #ifdef MOZ_TRACEVIS
31063:     TraceVisStateObj tvso(cx, S_INTERP);
29368: #endif
19712:     JSAutoResolveFlags rf(cx, JSRESOLVE_INFER);
    1: 
26954: # ifdef DEBUG
26954:     /*
26954:      * We call this macro from BEGIN_CASE in threaded interpreters,
26954:      * and before entering the switch in non-threaded interpreters.
26954:      * However, reaching such points doesn't mean we've actually
26954:      * fetched an OP from the instruction stream: some opcodes use
26954:      * 'op=x; DO_OP()' to let another opcode's implementation finish
26954:      * their work, and many opcodes share entry points with a run of
26954:      * consecutive BEGIN_CASEs.
26954:      *
26954:      * Take care to trace OP only when it is the opcode fetched from
26954:      * the instruction stream, so the trace matches what one would
26954:      * expect from looking at the code.  (We do omit POPs after SETs;
26954:      * unfortunate, but not worth fixing.)
26954:      */
56604: #  define LOG_OPCODE(OP)    JS_BEGIN_MACRO                                      \
56604:                                 if (JS_UNLIKELY(cx->logfp != NULL) &&       \
26954:                                     (OP) == *regs.pc)                         \
56604:                                     js_LogOpcode(cx);                         \
26954:                             JS_END_MACRO
26954: # else
56604: #  define LOG_OPCODE(OP)    ((void) 0)
26954: # endif
26954: 
48470:     /*
48470:      * Macros for threaded interpreter loop
48470:      */
    1: #if JS_THREADED_INTERP
15510:     static void *const normalJumpTable[] = {
    1: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
    1:         JS_EXTENSION &&L_##op,
    1: # include "jsopcode.tbl"
    1: # undef OPDEF
    1:     };
    1: 
23111:     static void *const interruptJumpTable[] = {
17408: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)              \
23111:         JS_EXTENSION &&interrupt,
17408: # include "jsopcode.tbl"
17408: # undef OPDEF
17408:     };
23111: 
23111:     register void * const *jumpTable = normalJumpTable;
    1: 
    1:     METER_OP_INIT(op);      /* to nullify first METER_OP_PAIR */
    1: 
23111: # define ENABLE_INTERRUPTS() ((void) (jumpTable = interruptJumpTable))
23111: 
18171: # ifdef JS_TRACER
23111: #  define CHECK_RECORDER()                                                    \
23111:     JS_ASSERT_IF(TRACE_RECORDER(cx), jumpTable == interruptJumpTable)
18171: # else
18171: #  define CHECK_RECORDER()  ((void)0)
18171: # endif
18171: 
18171: # define DO_OP()            JS_BEGIN_MACRO                                    \
18171:                                 CHECK_RECORDER();                             \
18161:                                 JS_EXTENSION_(goto *jumpTable[op]);           \
18161:                             JS_END_MACRO
15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
39923:                                 METER_OP_PAIR(op, JSOp(regs.pc[n]));          \
13168:                                 op = (JSOp) *(regs.pc += (n));                \
42748:                                 METER_REPR(cx);                               \
15453:                                 DO_OP();                                      \
15453:                             JS_END_MACRO
15453: 
56604: # define BEGIN_CASE(OP)     L_##OP: LOG_OPCODE(OP); CHECK_RECORDER();
    1: # define END_CASE(OP)       DO_NEXT_OP(OP##_LENGTH);
    1: # define END_VARLEN_CASE    DO_NEXT_OP(len);
15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)                                    \
15453:                                 JS_ASSERT(js_CodeSpec[OP].length == 1);       \
15453:                                 op = (JSOp) *++regs.pc;                       \
15453:                                 DO_OP();
15453: 
15453: # define END_EMPTY_CASES
15453: 
15453: #else /* !JS_THREADED_INTERP */
15453: 
23111:     register intN switchMask = 0;
23111:     intN switchOp;
23111: 
23111: # define ENABLE_INTERRUPTS() ((void) (switchMask = -1))
23111: 
23111: # ifdef JS_TRACER
23111: #  define CHECK_RECORDER()                                                    \
23111:     JS_ASSERT_IF(TRACE_RECORDER(cx), switchMask == -1)
23111: # else
23111: #  define CHECK_RECORDER()  ((void)0)
23111: # endif
23111: 
    1: # define DO_OP()            goto do_op
15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
15453:                                 JS_ASSERT((n) == len);                        \
15453:                                 goto advance_pc;                              \
15453:                             JS_END_MACRO
15453: 
23111: # define BEGIN_CASE(OP)     case OP: CHECK_RECORDER();
15453: # define END_CASE(OP)       END_CASE_LEN(OP##_LENGTH)
15453: # define END_CASE_LEN(n)    END_CASE_LENX(n)
15453: # define END_CASE_LENX(n)   END_CASE_LEN##n
15453: 
15453: /*
15453:  * To share the code for all len == 1 cases we use the specialized label with
15453:  * code that falls through to advance_pc: .
15453:  */
15453: # define END_CASE_LEN1      goto advance_pc_by_one;
15453: # define END_CASE_LEN2      len = 2; goto advance_pc;
15453: # define END_CASE_LEN3      len = 3; goto advance_pc;
15453: # define END_CASE_LEN4      len = 4; goto advance_pc;
15453: # define END_CASE_LEN5      len = 5; goto advance_pc;
15453: # define END_VARLEN_CASE    goto advance_pc;
15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)
15453: # define END_EMPTY_CASES    goto advance_pc_by_one;
15453: 
18617: #endif /* !JS_THREADED_INTERP */
18617: 
15453:     /* Check for too deep of a native thread stack. */
53133: #ifdef JS_TRACER
53133:     JS_CHECK_RECURSION(cx, do {
53133:             if (TRACE_RECORDER(cx))
53133:                 AbortRecording(cx, "too much recursion");
53133:             return JS_FALSE;
53133:         } while (0););
53133: #else
11758:     JS_CHECK_RECURSION(cx, return JS_FALSE);
53133: #endif
11758: 
48470: #define LOAD_ATOM(PCOFF, atom)                                                \
 3235:     JS_BEGIN_MACRO                                                            \
53840:         JS_ASSERT(regs.fp->hasImacropc()                                      \
21685:                   ? atoms == COMMON_ATOMS_START(&rt->atomState) &&            \
21685:                     GET_INDEX(regs.pc + PCOFF) < js_common_atom_count         \
21685:                   : (size_t)(atoms - script->atomMap.vector) <                \
13168:                     (size_t)(script->atomMap.length -                         \
13168:                              GET_INDEX(regs.pc + PCOFF)));                    \
13168:         atom = atoms[GET_INDEX(regs.pc + PCOFF)];                             \
 3235:     JS_END_MACRO
 3235: 
 3235: #define GET_FULL_INDEX(PCOFF)                                                 \
54855:     (atoms - script->atomMap.vector + GET_INDEX(regs.pc + (PCOFF)))
 3235: 
48470: #define LOAD_OBJECT(PCOFF, obj)                                               \
32723:     (obj = script->getObject(GET_FULL_INDEX(PCOFF)))
 3235: 
 3235: #define LOAD_FUNCTION(PCOFF)                                                  \
32723:     (fun = script->getFunction(GET_FULL_INDEX(PCOFF)))
    1: 
48470: #define LOAD_DOUBLE(PCOFF, dbl)                                               \
48470:     (dbl = script->getConst(GET_FULL_INDEX(PCOFF)).toDouble())
48470: 
17598: #ifdef JS_TRACER
17598: 
29368: #ifdef MOZ_TRACEVIS
31063: #if JS_THREADED_INTERP
29368: #define MONITOR_BRANCH_TRACEVIS                                               \
29368:     JS_BEGIN_MACRO                                                            \
29368:         if (jumpTable != interruptJumpTable)                                  \
38585:             EnterTraceVisState(cx, S_RECORD, R_NONE);                         \
29368:     JS_END_MACRO
31063: #else /* !JS_THREADED_INTERP */
31063: #define MONITOR_BRANCH_TRACEVIS                                               \
31063:     JS_BEGIN_MACRO                                                            \
38585:         EnterTraceVisState(cx, S_RECORD, R_NONE);                             \
31063:     JS_END_MACRO
31063: #endif
29368: #else
29368: #define MONITOR_BRANCH_TRACEVIS
29368: #endif
29368: 
33564: #define RESTORE_INTERP_VARS()                                                 \
17410:     JS_BEGIN_MACRO                                                            \
53840:         script = regs.fp->script();                                           \
53840:         argv = regs.fp->maybeFormalArgs();                                    \
53840:         atoms = FrameAtomBase(cx, regs.fp);                                   \
42717:         JS_ASSERT(cx->regs == &regs);                                         \
48470:         if (cx->throwing)                                                     \
48470:             goto error;                                                       \
33564:     JS_END_MACRO
33564: 
53524: #define MONITOR_BRANCH()                                                      \
33564:     JS_BEGIN_MACRO                                                            \
33564:         if (TRACING_ENABLED(cx)) {                                            \
53524:             MonitorResult r = MonitorLoopEdge(cx, inlineCallCount);           \
41777:             if (r == MONITOR_RECORDING) {                                     \
33564:                 JS_ASSERT(TRACE_RECORDER(cx));                                \
33564:                 MONITOR_BRANCH_TRACEVIS;                                      \
33564:                 ENABLE_INTERRUPTS();                                          \
53589:                 CLEAR_LEAVE_ON_TRACE_POINT();                                 \
33564:             }                                                                 \
33564:             RESTORE_INTERP_VARS();                                            \
41777:             JS_ASSERT_IF(cx->throwing, r == MONITOR_ERROR);                   \
41777:             if (r == MONITOR_ERROR)                                           \
41777:                 goto error;                                                   \
17923:         }                                                                     \
17410:     JS_END_MACRO
17410: 
17598: #else /* !JS_TRACER */
17598: 
53524: #define MONITOR_BRANCH() ((void) 0)
17598: 
17598: #endif /* !JS_TRACER */
17598: 
    1:     /*
11758:      * Prepare to call a user-supplied branch handler, and abort the script
11758:      * if it returns false.
11758:      */
17410: #define CHECK_BRANCH()                                                        \
 3235:     JS_BEGIN_MACRO                                                            \
53161:         if (JS_THREAD_DATA(cx)->interruptFlags && !js_HandleExecutionInterrupt(cx)) \
11859:             goto error;                                                       \
 3235:     JS_END_MACRO
23442: 
27038: #ifndef TRACE_RECORDER
27038: #define TRACE_RECORDER(cx) (false)
56551: #define TRACE_PROFILER(cx) (false)
27038: #endif
27038: 
54560: #if defined(JS_TRACER) && defined(JS_METHODJIT)
53626: # define LEAVE_ON_SAFE_POINT()                                                \
53133:     do {                                                                      \
53626:         JS_ASSERT_IF(leaveOnSafePoint, !TRACE_RECORDER(cx));                  \
53840:         if (leaveOnSafePoint && !regs.fp->hasImacropc() &&                    \
55520:             script->maybeNativeCodeForPC(regs.fp->isConstructing(), regs.pc)) { \
53626:             JS_ASSERT(!TRACE_RECORDER(cx));                                   \
53133:             interpReturnOK = true;                                            \
56201:             goto leave_on_safe_point;                                         \
53133:         }                                                                     \
53133:     } while (0)
53145: #else
53626: # define LEAVE_ON_SAFE_POINT() /* nop */
53145: #endif
53133: 
17410: #define BRANCH(n)                                                             \
17410:     JS_BEGIN_MACRO                                                            \
25627:         regs.pc += (n);                                                       \
25627:         op = (JSOp) *regs.pc;                                                 \
26375:         if ((n) <= 0) {                                                       \
26375:             CHECK_BRANCH();                                                   \
56217:             if (op == JSOP_NOTRACE) {                                         \
56551:                 if (TRACE_RECORDER(cx) || TRACE_PROFILER(cx)) {               \
53524:                     MONITOR_BRANCH();                                         \
27038:                     op = (JSOp) *regs.pc;                                     \
27038:                 }                                                             \
32776:             } else if (op == JSOP_TRACE) {                                    \
53524:                 MONITOR_BRANCH();                                             \
25627:                 op = (JSOp) *regs.pc;                                         \
17410:             }                                                                 \
26375:         }                                                                     \
53626:         LEAVE_ON_SAFE_POINT();                                                \
17611:         DO_OP();                                                              \
17410:     JS_END_MACRO
16072: 
53840: #define CHECK_INTERRUPT_HANDLER()                                             \
53840:     JS_BEGIN_MACRO                                                            \
53840:         if (cx->debugHooks->interruptHook)                                    \
53840:             ENABLE_INTERRUPTS();                                              \
53840:     JS_END_MACRO
53840: 
53840:     /* Check for too deep of a native thread stack. */
53840:     JS_CHECK_RECURSION(cx, return JS_FALSE);
53840: 
56201:     JSFrameRegs regs = *cx->regs;
56201: 
56201:     /* Repoint cx->regs to a local variable for faster access. */
56201:     struct InterpExitGuard {
56201:         JSContext *cx;
56201:         const JSFrameRegs &regs;
56201:         JSFrameRegs *prevContextRegs;
56201:         InterpExitGuard(JSContext *cx, JSFrameRegs &regs)
56201:           : cx(cx), regs(regs), prevContextRegs(cx->regs) {
56201:             cx->setCurrentRegs(&regs);
56033:             ++cx->interpLevel;
56201:         }
56201:         ~InterpExitGuard() {
56201:             --cx->interpLevel;
56201:             JS_ASSERT(cx->regs == &regs);
56201:             *prevContextRegs = regs;
56201:             cx->setCurrentRegs(prevContextRegs);
56201:         }
56201:     } interpGuard(cx, regs);
53840: 
53840:     /* Copy in hot values that change infrequently. */
53840:     JSRuntime *const rt = cx->runtime;
53840:     JSScript *script = regs.fp->script();
53840:     Value *argv = regs.fp->maybeFormalArgs();
53840:     CHECK_INTERRUPT_HANDLER();
53840: 
53840:     JS_ASSERT(!script->isEmpty());
56203:     JS_ASSERT(script->length >= 1);
53133: 
53626: #if defined(JS_TRACER) && defined(JS_METHODJIT)
56201:     bool leaveOnSafePoint = (interpMode == JSINTERP_SAFEPOINT);
53840: # define CLEAR_LEAVE_ON_TRACE_POINT() ((void) (leaveOnSafePoint = false))
53840: #else
53840: # define CLEAR_LEAVE_ON_TRACE_POINT() ((void) 0)
53840: #endif
53840: 
53840:     if (!entryFrame)
53840:         entryFrame = regs.fp;
18308: 
53631:     /*
53840:      * Initialize the index segment register used by LOAD_ATOM and
53840:      * GET_FULL_INDEX macros below. As a register we use a pointer based on
53840:      * the atom map to turn frequently executed LOAD_ATOM into simple array
53840:      * access. For less frequent object and regexp loads we have to recover
53840:      * the segment from atoms pointer first.
    1:      */
53840:     JSAtom **atoms = script->atomMap.vector;
42717: 
20908: #if JS_HAS_GENERATORS
53840:     if (JS_UNLIKELY(regs.fp->isGeneratorFrame())) {
56201:         JS_ASSERT(interpGuard.prevContextRegs == &cx->generatorFor(regs.fp)->regs);
13168:         JS_ASSERT((size_t) (regs.pc - script->code) <= script->length);
53840:         JS_ASSERT((size_t) (regs.sp - regs.fp->base()) <= StackDepth(script));
    1: 
    1:         /*
11758:          * To support generator_throw and to catch ignored exceptions,
11758:          * fail if cx->throwing is set.
    1:          */
53557:         if (cx->throwing)
53557:             goto error;
    1:     }
42717: #endif
    1: 
33546: #ifdef JS_TRACER
53133:     /*
53133:      * The method JIT may have already initiated a recording, in which case
53133:      * there should already be a valid recorder. Otherwise...
53133:      * we cannot reenter the interpreter while recording.
53133:      */
56201:     if (interpMode == JSINTERP_RECORD) {
53133:         JS_ASSERT(TRACE_RECORDER(cx));
53133:         ENABLE_INTERRUPTS();
56551:     } else if (interpMode == JSINTERP_PROFILE) {
56551:         ENABLE_INTERRUPTS();
53133:     } else if (TRACE_RECORDER(cx)) {
37741:         AbortRecording(cx, "attempt to reenter interpreter while recording");
53133:     }
53133: 
53840:     if (regs.fp->hasImacropc())
53133:         atoms = COMMON_ATOMS_START(&rt->atomState);
33546: #endif
33546: 
56201:     /* Don't call the script prologue if executing between Method and Trace JIT. */
56201:     if (interpMode == JSINTERP_NORMAL) {
56201:         JS_ASSERT_IF(!regs.fp->isGeneratorFrame(), regs.pc == script->code);
56201:         if (!ScriptPrologue(cx, regs.fp))
56201:             goto error;
56201:     }
56201: 
56201:     CHECK_INTERRUPT_HANDLER();
56201: 
48470:     /* State communicated between non-local jumps: */
48470:     JSBool interpReturnOK;
48470:     JSAtom *atomNotDefined;
48470: 
15453:     /*
15453:      * It is important that "op" be initialized before calling DO_OP because
15453:      * it is possible for "op" to be specially assigned during the normal
15453:      * processing of an opcode while looping. We rely on DO_NEXT_OP to manage
15453:      * "op" correctly in all other cases.
15453:      */
48470:     JSOp op;
48470:     jsint len;
15453:     len = 0;
48470: #if JS_THREADED_INTERP
15453:     DO_NEXT_OP(len);
48470: #else
48470:     DO_NEXT_OP(len);
48470: #endif
15453: 
    1: #if JS_THREADED_INTERP
    1:     /*
    1:      * This is a loop, but it does not look like a loop. The loop-closing
15453:      * jump is distributed throughout goto *jumpTable[op] inside of DO_OP.
15453:      * When interrupts are enabled, jumpTable is set to interruptJumpTable
23111:      * where all jumps point to the interrupt label. The latter, after
15453:      * calling the interrupt handler, dispatches through normalJumpTable to
15453:      * continue the normal bytecode processing.
15453:      */
31481: 
23111: #else /* !JS_THREADED_INTERP */
15453:     for (;;) {
15453:       advance_pc_by_one:
15453:         JS_ASSERT(js_CodeSpec[op].length == 1);
15453:         len = 1;
15453:       advance_pc:
15453:         regs.pc += len;
13168:         op = (JSOp) *regs.pc;
15453: 
15453:       do_op:
23111:         CHECK_RECORDER();
56604:         LOG_OPCODE(op);
23111:         switchOp = intN(op) | switchMask;
15453:       do_switch:
15453:         switch (switchOp) {
27490: #endif
31481: 
48470: #if JS_THREADED_INTERP
48470:   interrupt:
48470: #else /* !JS_THREADED_INTERP */
48470:   case -1:
48470:     JS_ASSERT(switchMask == -1);
48470: #endif /* !JS_THREADED_INTERP */
48470:     {
48470:         bool moreInterrupts = false;
48470:         JSInterruptHook hook = cx->debugHooks->interruptHook;
48470:         if (hook) {
48470: #ifdef JS_TRACER
48470:             if (TRACE_RECORDER(cx))
48470:                 AbortRecording(cx, "interrupt hook");
48470: #endif
48470:             Value rval;
48470:             switch (hook(cx, script, regs.pc, Jsvalify(&rval),
48470:                          cx->debugHooks->interruptHookData)) {
48470:               case JSTRAP_ERROR:
48470:                 goto error;
48470:               case JSTRAP_CONTINUE:
48470:                 break;
48470:               case JSTRAP_RETURN:
53840:                 regs.fp->setReturnValue(rval);
48470:                 interpReturnOK = JS_TRUE;
48470:                 goto forced_return;
48470:               case JSTRAP_THROW:
48470:                 cx->throwing = JS_TRUE;
48470:                 cx->exception = rval;
48470:                 goto error;
48470:               default:;
48470:             }
48470:             moreInterrupts = true;
48470:         }
48470: 
48470: #ifdef JS_TRACER
56551: #ifdef JS_METHODJIT
56551:         if (LoopProfile *prof = TRACE_PROFILER(cx)) {
56551:             LoopProfile::ProfileAction act = prof->profileOperation(cx, op);
56551:             switch (act) {
56551:                 case LoopProfile::ProfComplete:
56551:                     leaveOnSafePoint = true;
56551:                     LEAVE_ON_SAFE_POINT();
56551:                     break;
56551:                 default:
56551:                     moreInterrupts = true;
56551:                     break;
56551:             }
56551:         }
56551: #endif
48470:         if (TraceRecorder* tr = TRACE_RECORDER(cx)) {
48470:             AbortableRecordingStatus status = tr->monitorRecording(op);
48470:             JS_ASSERT_IF(cx->throwing, status == ARECORD_ERROR);
53626: 
56201:             if (interpMode != JSINTERP_NORMAL) {
56201:                 JS_ASSERT(interpMode == JSINTERP_RECORD || JSINTERP_SAFEPOINT);
53626:                 switch (status) {
53626:                   case ARECORD_IMACRO_ABORTED:
53626:                   case ARECORD_ABORTED:
53626:                   case ARECORD_COMPLETED:
53626:                   case ARECORD_STOP:
54560: #ifdef JS_METHODJIT
53626:                     leaveOnSafePoint = true;
53626:                     LEAVE_ON_SAFE_POINT();
54560: #endif
53626:                     break;
53626:                   default:
53626:                     break;
53626:                 }
53626:             }
53626: 
48470:             switch (status) {
48470:               case ARECORD_CONTINUE:
48470:                 moreInterrupts = true;
48470:                 break;
48470:               case ARECORD_IMACRO:
48470:               case ARECORD_IMACRO_ABORTED:
48470:                 atoms = COMMON_ATOMS_START(&rt->atomState);
48470:                 op = JSOp(*regs.pc);
53589:                 CLEAR_LEAVE_ON_TRACE_POINT();
48470:                 if (status == ARECORD_IMACRO)
48470:                     DO_OP();    /* keep interrupting for op. */
48470:                 break;
48470:               case ARECORD_ERROR:
48470:                 // The code at 'error:' aborts the recording.
48470:                 goto error;
48470:               case ARECORD_ABORTED:
48470:               case ARECORD_COMPLETED:
48470:                 break;
48470:               case ARECORD_STOP:
48470:                 /* A 'stop' error should have already aborted recording. */
48470:               default:
48470:                 JS_NOT_REACHED("Bad recording status");
48470:             }
48470:         }
48470: #endif /* !JS_TRACER */
48470: 
48470: #if JS_THREADED_INTERP
48470: #ifdef MOZ_TRACEVIS
48470:         if (!moreInterrupts)
48470:             ExitTraceVisState(cx, R_ABORT);
48470: #endif
48470:         jumpTable = moreInterrupts ? interruptJumpTable : normalJumpTable;
48470:         JS_EXTENSION_(goto *normalJumpTable[op]);
48470: #else
48470:         switchMask = moreInterrupts ? -1 : 0;
48470:         switchOp = intN(op);
48470:         goto do_switch;
48470: #endif
48470:     }
48470: 
48470: /* No-ops for ease of decompilation. */
48470: ADD_EMPTY_CASE(JSOP_NOP)
48470: ADD_EMPTY_CASE(JSOP_CONDSWITCH)
48470: ADD_EMPTY_CASE(JSOP_TRY)
48470: #if JS_HAS_XML_SUPPORT
48470: ADD_EMPTY_CASE(JSOP_STARTXML)
48470: ADD_EMPTY_CASE(JSOP_STARTXMLEXPR)
48470: #endif
54855: ADD_EMPTY_CASE(JSOP_NULLBLOCKCHAIN)
48470: END_EMPTY_CASES
48470: 
53133: BEGIN_CASE(JSOP_TRACE)
56217: BEGIN_CASE(JSOP_NOTRACE)
53626:     LEAVE_ON_SAFE_POINT();
53133: END_CASE(JSOP_TRACE)
53133: 
48470: /* ADD_EMPTY_CASE is not used here as JSOP_LINENO_LENGTH == 3. */
48470: BEGIN_CASE(JSOP_LINENO)
54840: END_CASE(JSOP_LINENO)
48470: 
54855: BEGIN_CASE(JSOP_BLOCKCHAIN)
54855: END_CASE(JSOP_BLOCKCHAIN)
54855: 
48470: BEGIN_CASE(JSOP_PUSH)
48470:     PUSH_UNDEFINED();
48470: END_CASE(JSOP_PUSH)
48470: 
48470: BEGIN_CASE(JSOP_POP)
48470:     regs.sp--;
48470: END_CASE(JSOP_POP)
48470: 
48470: BEGIN_CASE(JSOP_POPN)
48470: {
48470:     regs.sp -= GET_UINT16(regs.pc);
48470: #ifdef DEBUG
53840:     JS_ASSERT(regs.fp->base() <= regs.sp);
54855:     JSObject *obj = js_GetBlockChain(cx, regs.fp);
48470:     JS_ASSERT_IF(obj,
48470:                  OBJ_BLOCK_DEPTH(cx, obj) + OBJ_BLOCK_COUNT(cx, obj)
53840:                  <= (size_t) (regs.sp - regs.fp->base()));
53840:     for (obj = &regs.fp->scopeChain(); obj; obj = obj->getParent()) {
48470:         Class *clasp = obj->getClass();
48470:         if (clasp != &js_BlockClass && clasp != &js_WithClass)
48470:             continue;
53840:         if (obj->getPrivate() != js_FloatingFrameIfGenerator(cx, regs.fp))
48470:             break;
53840:         JS_ASSERT(regs.fp->base() + OBJ_BLOCK_DEPTH(cx, obj)
48470:                              + ((clasp == &js_BlockClass)
48470:                                 ? OBJ_BLOCK_COUNT(cx, obj)
48470:                                 : 1)
48470:                   <= regs.sp);
48470:     }
48470: #endif
48470: }
48470: END_CASE(JSOP_POPN)
48470: 
48470: BEGIN_CASE(JSOP_SETRVAL)
48470: BEGIN_CASE(JSOP_POPV)
51056:     POP_RETURN_VALUE();
48470: END_CASE(JSOP_POPV)
48470: 
48470: BEGIN_CASE(JSOP_ENTERWITH)
55527:     if (!js_EnterWith(cx, -1, JSOP_ENTERWITH, JSOP_ENTERWITH_LENGTH))
48470:         goto error;
48470: 
48470:     /*
48470:      * We must ensure that different "with" blocks have different stack depth
48470:      * associated with them. This allows the try handler search to properly
48470:      * recover the scope chain. Thus we must keep the stack at least at the
48470:      * current level.
48470:      *
48470:      * We set sp[-1] to the current "with" object to help asserting the
48470:      * enter/leave balance in [leavewith].
48470:      */
53840:     regs.sp[-1].setObject(regs.fp->scopeChain());
48470: END_CASE(JSOP_ENTERWITH)
48470: 
48470: BEGIN_CASE(JSOP_LEAVEWITH)
53840:     JS_ASSERT(&regs.sp[-1].toObject() == &regs.fp->scopeChain());
48470:     regs.sp--;
48470:     js_LeaveWith(cx);
48470: END_CASE(JSOP_LEAVEWITH)
48470: 
48470: BEGIN_CASE(JSOP_RETURN)
51056:     POP_RETURN_VALUE();
48470:     /* FALL THROUGH */
48470: 
51056: BEGIN_CASE(JSOP_RETRVAL)    /* fp return value already set */
48470: BEGIN_CASE(JSOP_STOP)
48470: {
48470:     /*
48470:      * When the inlined frame exits with an exception or an error, ok will be
48470:      * false after the inline_return label.
48470:      */
48470:     CHECK_BRANCH();
48470: 
53133: #ifdef JS_TRACER
53840:     if (regs.fp->hasImacropc()) {
48470:         /*
48470:          * If we are at the end of an imacro, return to its caller in the
48470:          * current frame.
48470:          */
48470:         JS_ASSERT(op == JSOP_STOP);
53840:         JS_ASSERT((uintN)(regs.sp - regs.fp->slots()) <= script->nslots);
53840:         jsbytecode *imacpc = regs.fp->imacropc();
51055:         regs.pc = imacpc + js_CodeSpec[*imacpc].length;
53840:         regs.fp->clearImacropc();
53626:         LEAVE_ON_SAFE_POINT();
48470:         atoms = script->atomMap.vector;
48470:         op = JSOp(*regs.pc);
48470:         DO_OP();
48470:     }
53133: #endif
48470: 
48470:     interpReturnOK = true;
53840:     if (entryFrame != regs.fp)
48470:   inline_return:
48470:     {
53840:         JS_ASSERT(!js_IsActiveWithOrBlock(cx, &regs.fp->scopeChain(), 0));
56201:         interpReturnOK = ScriptEpilogue(cx, regs.fp, interpReturnOK);
48470:         CHECK_INTERRUPT_HANDLER();
56201: 
56201:         /* The JIT inlines ScriptEpilogue. */
56201:   jit_return:
53840:         Value *newsp = regs.fp->actualArgs() - 1;
53840:         newsp[-1] = regs.fp->returnValue();
53840:         cx->stack().popInlineFrame(cx, regs.fp->prev(), newsp);
48470: 
48470:         /* Sync interpreter registers. */
53840:         script = regs.fp->script();
53840:         argv = regs.fp->maybeFormalArgs();
53840:         atoms = FrameAtomBase(cx, regs.fp);
48470: 
48470:         /* Resume execution in the calling frame. */
53133:         JS_ASSERT(inlineCallCount);
48470:         inlineCallCount--;
48470:         if (JS_LIKELY(interpReturnOK)) {
48470:             JS_ASSERT(js_CodeSpec[js_GetOpcode(cx, script, regs.pc)].length
48470:                       == JSOP_CALL_LENGTH);
48470:             TRACE_0(LeaveFrame);
51682:             len = JSOP_CALL_LENGTH;
51682:             DO_NEXT_OP(len);
51682:         }
51682:         goto error;
48470:     } else {
53840:         JS_ASSERT(regs.sp == regs.fp->base());
48470:     }
48470:     interpReturnOK = true;
48470:     goto exit;
48470: }
48470: 
48470: BEGIN_CASE(JSOP_DEFAULT)
48470:     regs.sp--;
48470:     /* FALL THROUGH */
48470: BEGIN_CASE(JSOP_GOTO)
48470: {
48470:     len = GET_JUMP_OFFSET(regs.pc);
48470:     BRANCH(len);
48470: }
48470: END_CASE(JSOP_GOTO)
48470: 
48470: BEGIN_CASE(JSOP_IFEQ)
48470: {
48470:     bool cond;
48470:     Value *_;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     if (cond == false) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_IFEQ)
48470: 
48470: BEGIN_CASE(JSOP_IFNE)
48470: {
48470:     bool cond;
48470:     Value *_;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     if (cond != false) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_IFNE)
48470: 
48470: BEGIN_CASE(JSOP_OR)
48470: {
48470:     bool cond;
48470:     Value *vp;
48470:     POP_BOOLEAN(cx, vp, cond);
48470:     if (cond == true) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         PUSH_COPY(*vp);
48470:         DO_NEXT_OP(len);
48470:     }
48470: }
48470: END_CASE(JSOP_OR)
48470: 
48470: BEGIN_CASE(JSOP_AND)
48470: {
48470:     bool cond;
48470:     Value *vp;
48470:     POP_BOOLEAN(cx, vp, cond);
48470:     if (cond == false) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         PUSH_COPY(*vp);
48470:         DO_NEXT_OP(len);
48470:     }
48470: }
48470: END_CASE(JSOP_AND)
48470: 
48470: BEGIN_CASE(JSOP_DEFAULTX)
48470:     regs.sp--;
48470:     /* FALL THROUGH */
48470: BEGIN_CASE(JSOP_GOTOX)
48470: {
48470:     len = GET_JUMPX_OFFSET(regs.pc);
48470:     BRANCH(len);
48470: }
48470: END_CASE(JSOP_GOTOX);
48470: 
48470: BEGIN_CASE(JSOP_IFEQX)
48470: {
48470:     bool cond;
48470:     Value *_;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     if (cond == false) {
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_IFEQX)
48470: 
48470: BEGIN_CASE(JSOP_IFNEX)
48470: {
48470:     bool cond;
48470:     Value *_;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     if (cond != false) {
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_IFNEX)
48470: 
48470: BEGIN_CASE(JSOP_ORX)
48470: {
48470:     bool cond;
48470:     Value *vp;
48470:     POP_BOOLEAN(cx, vp, cond);
48470:     if (cond == true) {
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         PUSH_COPY(*vp);
48470:         DO_NEXT_OP(len);
48470:     }
48470: }
48470: END_CASE(JSOP_ORX)
48470: 
48470: BEGIN_CASE(JSOP_ANDX)
48470: {
48470:     bool cond;
48470:     Value *vp;
48470:     POP_BOOLEAN(cx, vp, cond);
48470:     if (cond == JS_FALSE) {
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         PUSH_COPY(*vp);
48470:         DO_NEXT_OP(len);
48470:     }
48470: }
48470: END_CASE(JSOP_ANDX)
48470: 
48470: /*
48470:  * If the index value at sp[n] is not an int that fits in a jsval, it could
48470:  * be an object (an XML QName, AttributeName, or AnyName), but only if we are
48470:  * compiling with JS_HAS_XML_SUPPORT.  Otherwise convert the index value to a
48470:  * string atom id.
48470:  */
48470: #define FETCH_ELEMENT_ID(obj, n, id)                                          \
48470:     JS_BEGIN_MACRO                                                            \
48470:         const Value &idval_ = regs.sp[n];                                     \
48470:         int32_t i_;                                                           \
48470:         if (ValueFitsInInt32(idval_, &i_) && INT_FITS_IN_JSID(i_)) {          \
48470:             id = INT_TO_JSID(i_);                                             \
48470:         } else {                                                              \
48470:             if (!js_InternNonIntElementId(cx, obj, idval_, &id, &regs.sp[n])) \
48470:                 goto error;                                                   \
48470:         }                                                                     \
48470:     JS_END_MACRO
48470: 
48470: #define TRY_BRANCH_AFTER_COND(cond,spdec)                                     \
48470:     JS_BEGIN_MACRO                                                            \
48470:         JS_ASSERT(js_CodeSpec[op].length == 1);                               \
48470:         uintN diff_ = (uintN) regs.pc[1] - (uintN) JSOP_IFEQ;                 \
48470:         if (diff_ <= 1) {                                                     \
48470:             regs.sp -= spdec;                                                 \
48470:             if (cond == (diff_ != 0)) {                                       \
48470:                 ++regs.pc;                                                    \
48470:                 len = GET_JUMP_OFFSET(regs.pc);                               \
48470:                 BRANCH(len);                                                  \
48470:             }                                                                 \
48470:             len = 1 + JSOP_IFEQ_LENGTH;                                       \
48470:             DO_NEXT_OP(len);                                                  \
48470:         }                                                                     \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_IN)
48470: {
48470:     const Value &rref = regs.sp[-1];
48470:     if (!rref.isObject()) {
48470:         js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rref, NULL);
48470:         goto error;
48470:     }
48470:     JSObject *obj = &rref.toObject();
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -2, id);
48470:     JSObject *obj2;
48470:     JSProperty *prop;
48470:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
48470:         goto error;
48470:     bool cond = prop != NULL;
48470:     TRY_BRANCH_AFTER_COND(cond, 2);
48470:     regs.sp--;
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_IN)
48470: 
48470: BEGIN_CASE(JSOP_ITER)
48470: {
53840:     JS_ASSERT(regs.sp > regs.fp->base());
48470:     uintN flags = regs.pc[1];
48470:     if (!js_ValueToIterator(cx, flags, &regs.sp[-1]))
48470:         goto error;
48470:     CHECK_INTERRUPT_HANDLER();
48470:     JS_ASSERT(!regs.sp[-1].isPrimitive());
48470: }
48470: END_CASE(JSOP_ITER)
48470: 
48470: BEGIN_CASE(JSOP_MOREITER)
48470: {
53840:     JS_ASSERT(regs.sp - 1 >= regs.fp->base());
48470:     JS_ASSERT(regs.sp[-1].isObject());
48470:     PUSH_NULL();
48470:     bool cond;
48470:     if (!IteratorMore(cx, &regs.sp[-2].toObject(), &cond, &regs.sp[-1]))
48470:         goto error;
48470:     CHECK_INTERRUPT_HANDLER();
48470:     TRY_BRANCH_AFTER_COND(cond, 1);
48470:     JS_ASSERT(regs.pc[1] == JSOP_IFNEX);
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_MOREITER)
48470: 
48470: BEGIN_CASE(JSOP_ENDITER)
48470: {
53840:     JS_ASSERT(regs.sp - 1 >= regs.fp->base());
48470:     bool ok = !!js_CloseIterator(cx, &regs.sp[-1].toObject());
48470:     regs.sp--;
48470:     if (!ok)
48470:         goto error;
48470: }
48470: END_CASE(JSOP_ENDITER)
48470: 
48470: BEGIN_CASE(JSOP_FORARG)
48470: {
53840:     JS_ASSERT(regs.sp - 1 >= regs.fp->base());
48470:     uintN slot = GET_ARGNO(regs.pc);
53840:     JS_ASSERT(slot < regs.fp->numFormalArgs());
48470:     JS_ASSERT(regs.sp[-1].isObject());
53840:     if (!IteratorNext(cx, &regs.sp[-1].toObject(), &argv[slot]))
48470:         goto error;
48470: }
48470: END_CASE(JSOP_FORARG)
48470: 
48470: BEGIN_CASE(JSOP_FORLOCAL)
48470: {
53840:     JS_ASSERT(regs.sp - 1 >= regs.fp->base());
48470:     uintN slot = GET_SLOTNO(regs.pc);
53840:     JS_ASSERT(slot < regs.fp->numSlots());
48470:     JS_ASSERT(regs.sp[-1].isObject());
53840:     if (!IteratorNext(cx, &regs.sp[-1].toObject(), &regs.fp->slots()[slot]))
48470:         goto error;
48470: }
48470: END_CASE(JSOP_FORLOCAL)
48470: 
48470: BEGIN_CASE(JSOP_FORNAME)
48470: {
53840:     JS_ASSERT(regs.sp - 1 >= regs.fp->base());
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     jsid id = ATOM_TO_JSID(atom);
48470:     JSObject *obj, *obj2;
48470:     JSProperty *prop;
48470:     if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
48470:         goto error;
56567: 
48470:     {
48470:         AutoValueRooter tvr(cx);
48470:         JS_ASSERT(regs.sp[-1].isObject());
48470:         if (!IteratorNext(cx, &regs.sp[-1].toObject(), tvr.addr()))
48470:             goto error;
54169:         if (!obj->setProperty(cx, id, tvr.addr(), script->strictModeCode))
48470:             goto error;
48470:     }
48470: }
48470: END_CASE(JSOP_FORNAME)
48470: 
48470: BEGIN_CASE(JSOP_FORPROP)
48470: {
53840:     JS_ASSERT(regs.sp - 2 >= regs.fp->base());
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     jsid id = ATOM_TO_JSID(atom);
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -1, obj);
48470:     {
48470:         AutoValueRooter tvr(cx);
48470:         JS_ASSERT(regs.sp[-2].isObject());
48470:         if (!IteratorNext(cx, &regs.sp[-2].toObject(), tvr.addr()))
48470:             goto error;
54169:         if (!obj->setProperty(cx, id, tvr.addr(), script->strictModeCode))
48470:             goto error;
48470:     }
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_FORPROP)
48470: 
48470: BEGIN_CASE(JSOP_FORELEM)
48470:     /*
48470:      * JSOP_FORELEM simply dups the property identifier at top of stack and
48470:      * lets the subsequent JSOP_ENUMELEM opcode sequence handle the left-hand
48470:      * side expression evaluation and assignment. This opcode exists solely to
48470:      * help the decompiler.
48470:      */
53840:     JS_ASSERT(regs.sp - 1 >= regs.fp->base());
48470:     JS_ASSERT(regs.sp[-1].isObject());
48470:     PUSH_NULL();
48470:     if (!IteratorNext(cx, &regs.sp[-2].toObject(), &regs.sp[-1]))
48470:         goto error;
48470: END_CASE(JSOP_FORELEM)
48470: 
48470: BEGIN_CASE(JSOP_DUP)
48470: {
53840:     JS_ASSERT(regs.sp > regs.fp->base());
48470:     const Value &rref = regs.sp[-1];
48470:     PUSH_COPY(rref);
48470: }
48470: END_CASE(JSOP_DUP)
48470: 
48470: BEGIN_CASE(JSOP_DUP2)
48470: {
53840:     JS_ASSERT(regs.sp - 2 >= regs.fp->base());
48470:     const Value &lref = regs.sp[-2];
48470:     const Value &rref = regs.sp[-1];
48470:     PUSH_COPY(lref);
48470:     PUSH_COPY(rref);
48470: }
48470: END_CASE(JSOP_DUP2)
48470: 
48470: BEGIN_CASE(JSOP_SWAP)
48470: {
53840:     JS_ASSERT(regs.sp - 2 >= regs.fp->base());
48470:     Value &lref = regs.sp[-2];
48470:     Value &rref = regs.sp[-1];
48470:     lref.swap(rref);
48470: }
48470: END_CASE(JSOP_SWAP)
48470: 
48470: BEGIN_CASE(JSOP_PICK)
48470: {
48470:     jsint i = regs.pc[1];
53840:     JS_ASSERT(regs.sp - (i+1) >= regs.fp->base());
48470:     Value lval = regs.sp[-(i+1)];
48470:     memmove(regs.sp - (i+1), regs.sp - i, sizeof(Value)*i);
48470:     regs.sp[-1] = lval;
48470: }
48470: END_CASE(JSOP_PICK)
48470: 
52503: #define NATIVE_GET(cx,obj,pobj,shape,getHow,vp)                               \
48470:     JS_BEGIN_MACRO                                                            \
54861:         if (shape->isDataDescriptor() && shape->hasDefaultGetter()) {         \
48470:             /* Fast path for Object instance properties. */                   \
52503:             JS_ASSERT((shape)->slot != SHAPE_INVALID_SLOT ||                  \
52503:                       !shape->hasDefaultSetter());                            \
52503:             if (((shape)->slot != SHAPE_INVALID_SLOT))                        \
56567:                 *(vp) = (pobj)->nativeGetSlot((shape)->slot);                 \
48470:             else                                                              \
48470:                 (vp)->setUndefined();                                         \
48470:         } else {                                                              \
52503:             if (!js_NativeGet(cx, obj, pobj, shape, getHow, vp))              \
48470:                 goto error;                                                   \
48470:         }                                                                     \
48470:     JS_END_MACRO
48470: 
52503: #define NATIVE_SET(cx,obj,shape,entry,vp)                                     \
48470:     JS_BEGIN_MACRO                                                            \
52503:         TRACE_2(SetPropHit, entry, shape);                                    \
52503:         if (shape->hasDefaultSetter() &&                                      \
52503:             (shape)->slot != SHAPE_INVALID_SLOT &&                            \
52503:             !(obj)->brandedOrHasMethodBarrier()) {                            \
48470:             /* Fast path for, e.g., plain Object instance properties. */      \
56567:             (obj)->nativeSetSlot((shape)->slot, *vp);                         \
48470:         } else {                                                              \
52503:             if (!js_NativeSet(cx, obj, shape, false, vp))                     \
48470:                 goto error;                                                   \
48470:         }                                                                     \
48470:     JS_END_MACRO
48470: 
48470: /*
48470:  * Skip the JSOP_POP typically found after a JSOP_SET* opcode, where oplen is
48470:  * the constant length of the SET opcode sequence, and spdec is the constant
48470:  * by which to decrease the stack pointer to pop all of the SET op's operands.
48470:  *
48470:  * NB: unlike macros that could conceivably be replaced by functions (ignoring
48470:  * goto error), where a call should not have to be braced in order to expand
48470:  * correctly (e.g., in if (cond) FOO(); else BAR()), these three macros lack
48470:  * JS_{BEGIN,END}_MACRO brackets. They are also indented so as to align with
48470:  * nearby opcode code.
48470:  */
48470: #define SKIP_POP_AFTER_SET(oplen,spdec)                                       \
48470:             if (regs.pc[oplen] == JSOP_POP) {                                 \
48470:                 regs.sp -= spdec;                                             \
48470:                 regs.pc += oplen + JSOP_POP_LENGTH;                           \
48470:                 op = (JSOp) *regs.pc;                                         \
48470:                 DO_OP();                                                      \
48470:             }
48470: 
48470: #define END_SET_CASE(OP)                                                      \
48470:             SKIP_POP_AFTER_SET(OP##_LENGTH, 1);                               \
48470:           END_CASE(OP)
48470: 
48470: #define END_SET_CASE_STORE_RVAL(OP,spdec)                                     \
48470:             SKIP_POP_AFTER_SET(OP##_LENGTH, spdec);                           \
48470:             {                                                                 \
48470:                 Value *newsp = regs.sp - ((spdec) - 1);                       \
48470:                 newsp[-1] = regs.sp[-1];                                      \
48470:                 regs.sp = newsp;                                              \
48470:             }                                                                 \
48470:           END_CASE(OP)
48470: 
48470: BEGIN_CASE(JSOP_SETCONST)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
53840:     JSObject &obj = regs.fp->varobj(cx);
48470:     const Value &ref = regs.sp[-1];
53840:     if (!obj.defineProperty(cx, ATOM_TO_JSID(atom), ref,
48470:                             PropertyStub, PropertyStub,
48470:                             JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
48470:         goto error;
48470:     }
48470: }
48470: END_SET_CASE(JSOP_SETCONST);
48470: 
48470: #if JS_HAS_DESTRUCTURING
48470: BEGIN_CASE(JSOP_ENUMCONSTELEM)
48470: {
48470:     const Value &ref = regs.sp[-3];
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -2, obj);
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -1, id);
48470:     if (!obj->defineProperty(cx, id, ref,
48470:                              PropertyStub, PropertyStub,
48470:                              JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
48470:         goto error;
48470:     }
48470:     regs.sp -= 3;
48470: }
48470: END_CASE(JSOP_ENUMCONSTELEM)
48470: #endif
48470: 
53092: BEGIN_CASE(JSOP_BINDGNAME)
53840:     PUSH_OBJECT(*regs.fp->scopeChain().getGlobal());
53092: END_CASE(JSOP_BINDGNAME)
53092: 
48470: BEGIN_CASE(JSOP_BINDNAME)
48470: {
48470:     JSObject *obj;
48470:     do {
48470:         /*
48470:          * We can skip the property lookup for the global object. If the
48470:          * property does not exist anywhere on the scope chain, JSOP_SETNAME
48470:          * adds the property to the global.
48470:          *
48470:          * As a consequence of this optimization for the global object we run
48470:          * its JSRESOLVE_ASSIGNING-tolerant resolve hooks only in JSOP_SETNAME,
48470:          * after the interpreter evaluates the right- hand-side of the
48470:          * assignment, and not here.
48470:          *
48470:          * This should be transparent to the hooks because the script, instead
48470:          * of name = rhs, could have used global.name = rhs given a global
48470:          * object reference, which also calls the hooks only after evaluating
48470:          * the rhs. We desire such resolve hook equivalence between the two
48470:          * forms.
48470:          */
53840:         obj = &regs.fp->scopeChain();
48470:         if (!obj->getParent())
48470:             break;
48470: 
48470:         PropertyCacheEntry *entry;
48470:         JSObject *obj2;
48470:         JSAtom *atom;
48470:         JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
48470:         if (!atom) {
48470:             ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
48470:             break;
48470:         }
48470: 
48470:         jsid id = ATOM_TO_JSID(atom);
53840:         obj = js_FindIdentifierBase(cx, &regs.fp->scopeChain(), id);
48470:         if (!obj)
48470:             goto error;
48470:     } while (0);
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_BINDNAME)
48470: 
48470: BEGIN_CASE(JSOP_IMACOP)
53840:     JS_ASSERT(JS_UPTRDIFF(regs.fp->imacropc(), script->code) < script->length);
53840:     op = JSOp(*regs.fp->imacropc());
48470:     DO_OP();
48470: 
48470: #define BITWISE_OP(OP)                                                        \
48470:     JS_BEGIN_MACRO                                                            \
48470:         int32_t i, j;                                                         \
48470:         if (!ValueToECMAInt32(cx, regs.sp[-2], &i))                           \
48470:             goto error;                                                       \
48470:         if (!ValueToECMAInt32(cx, regs.sp[-1], &j))                           \
48470:             goto error;                                                       \
48470:         i = i OP j;                                                           \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setInt32(i);                                              \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_BITOR)
48470:     BITWISE_OP(|);
48470: END_CASE(JSOP_BITOR)
48470: 
48470: BEGIN_CASE(JSOP_BITXOR)
48470:     BITWISE_OP(^);
48470: END_CASE(JSOP_BITXOR)
48470: 
48470: BEGIN_CASE(JSOP_BITAND)
48470:     BITWISE_OP(&);
48470: END_CASE(JSOP_BITAND)
48470: 
48470: #undef BITWISE_OP
48470: 
48470: /*
48470:  * NB: These macros can't use JS_BEGIN_MACRO/JS_END_MACRO around their bodies
48470:  * because they begin if/else chains, so callers must not put semicolons after
48470:  * the call expressions!
48470:  */
48470: #if JS_HAS_XML_SUPPORT
48470: #define XML_EQUALITY_OP(OP)                                                   \
48470:     if ((lval.isObject() && lval.toObject().isXML()) ||                       \
48470:         (rval.isObject() && rval.toObject().isXML())) {                       \
48470:         if (!js_TestXMLEquality(cx, lval, rval, &cond))                       \
48470:             goto error;                                                       \
48470:         cond = cond OP JS_TRUE;                                               \
48470:     } else
48470: 
48470: #define EXTENDED_EQUALITY_OP(OP)                                              \
48622:     if (EqualityOp eq = l->getClass()->ext.equality) {                        \
48622:         if (!eq(cx, l, &rval, &cond))                                         \
48470:             goto error;                                                       \
48470:         cond = cond OP JS_TRUE;                                               \
48470:     } else
48470: #else
48470: #define XML_EQUALITY_OP(OP)             /* nothing */
48470: #define EXTENDED_EQUALITY_OP(OP)        /* nothing */
48470: #endif
48470: 
48470: #define EQUALITY_OP(OP, IFNAN)                                                \
48470:     JS_BEGIN_MACRO                                                            \
48470:         JSBool cond;                                                          \
48470:         Value rval = regs.sp[-1];                                             \
48470:         Value lval = regs.sp[-2];                                             \
48470:         XML_EQUALITY_OP(OP)                                                   \
48470:         if (SameType(lval, rval)) {                                           \
48470:             if (lval.isString()) {                                            \
48470:                 JSString *l = lval.toString(), *r = rval.toString();          \
48470:                 cond = js_EqualStrings(l, r) OP JS_TRUE;                      \
48470:             } else if (lval.isDouble()) {                                     \
48470:                 double l = lval.toDouble(), r = rval.toDouble();              \
48470:                 cond = JSDOUBLE_COMPARE(l, OP, r, IFNAN);                     \
48470:             } else if (lval.isObject()) {                                     \
48470:                 JSObject *l = &lval.toObject(), *r = &rval.toObject();        \
48470:                 EXTENDED_EQUALITY_OP(OP)                                      \
48470:                 cond = l OP r;                                                \
48470:             } else {                                                          \
48470:                 cond = lval.payloadAsRawUint32() OP rval.payloadAsRawUint32();\
48470:             }                                                                 \
48470:         } else {                                                              \
48470:             if (lval.isNullOrUndefined()) {                                   \
48470:                 cond = rval.isNullOrUndefined() OP true;                      \
48470:             } else if (rval.isNullOrUndefined()) {                            \
48470:                 cond = true OP false;                                         \
48470:             } else {                                                          \
48470:                 if (lval.isObject())                                          \
48470:                     DEFAULT_VALUE(cx, -2, JSTYPE_VOID, lval);                 \
48470:                 if (rval.isObject())                                          \
48470:                     DEFAULT_VALUE(cx, -1, JSTYPE_VOID, rval);                 \
48470:                 if (lval.isString() && rval.isString()) {                     \
48470:                     JSString *l = lval.toString(), *r = rval.toString();      \
48470:                     cond = js_EqualStrings(l, r) OP JS_TRUE;                  \
48470:                 } else {                                                      \
48470:                     double l, r;                                              \
48470:                     if (!ValueToNumber(cx, lval, &l) ||                       \
48470:                         !ValueToNumber(cx, rval, &r)) {                       \
48470:                         goto error;                                           \
48470:                     }                                                         \
48470:                     cond = JSDOUBLE_COMPARE(l, OP, r, IFNAN);                 \
48470:                 }                                                             \
48470:             }                                                                 \
48470:         }                                                                     \
48470:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setBoolean(cond);                                         \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_EQ)
48470:     EQUALITY_OP(==, false);
48470: END_CASE(JSOP_EQ)
48470: 
48470: BEGIN_CASE(JSOP_NE)
48470:     EQUALITY_OP(!=, true);
48470: END_CASE(JSOP_NE)
48470: 
48470: #undef EQUALITY_OP
48470: #undef XML_EQUALITY_OP
48470: #undef EXTENDED_EQUALITY_OP
48470: 
48470: #define STRICT_EQUALITY_OP(OP, COND)                                          \
48470:     JS_BEGIN_MACRO                                                            \
48470:         const Value &rref = regs.sp[-1];                                      \
48470:         const Value &lref = regs.sp[-2];                                      \
48470:         COND = StrictlyEqual(cx, lref, rref) OP true;                         \
48470:         regs.sp--;                                                            \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_STRICTEQ)
48470: {
48470:     bool cond;
48470:     STRICT_EQUALITY_OP(==, cond);
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_STRICTEQ)
48470: 
48470: BEGIN_CASE(JSOP_STRICTNE)
48470: {
48470:     bool cond;
48470:     STRICT_EQUALITY_OP(!=, cond);
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_STRICTNE)
48470: 
48470: BEGIN_CASE(JSOP_CASE)
48470: {
48470:     bool cond;
48470:     STRICT_EQUALITY_OP(==, cond);
48470:     if (cond) {
48470:         regs.sp--;
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_CASE)
48470: 
48470: BEGIN_CASE(JSOP_CASEX)
48470: {
48470:     bool cond;
48470:     STRICT_EQUALITY_OP(==, cond);
48470:     if (cond) {
48470:         regs.sp--;
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_CASEX)
48470: 
48470: #undef STRICT_EQUALITY_OP
48470: 
48470: #define RELATIONAL_OP(OP)                                                     \
48470:     JS_BEGIN_MACRO                                                            \
48470:         Value rval = regs.sp[-1];                                             \
48470:         Value lval = regs.sp[-2];                                             \
48470:         bool cond;                                                            \
48470:         /* Optimize for two int-tagged operands (typical loop control). */    \
48470:         if (lval.isInt32() && rval.isInt32()) {                               \
48470:             cond = lval.toInt32() OP rval.toInt32();                          \
48470:         } else {                                                              \
48470:             if (lval.isObject())                                              \
48470:                 DEFAULT_VALUE(cx, -2, JSTYPE_NUMBER, lval);                   \
48470:             if (rval.isObject())                                              \
48470:                 DEFAULT_VALUE(cx, -1, JSTYPE_NUMBER, rval);                   \
48470:             if (lval.isString() && rval.isString()) {                         \
48470:                 JSString *l = lval.toString(), *r = rval.toString();          \
48470:                 cond = js_CompareStrings(l, r) OP 0;                          \
48470:             } else {                                                          \
48470:                 double l, r;                                                  \
48470:                 if (!ValueToNumber(cx, lval, &l) ||                           \
48470:                     !ValueToNumber(cx, rval, &r)) {                           \
48470:                     goto error;                                               \
48470:                 }                                                             \
48470:                 cond = JSDOUBLE_COMPARE(l, OP, r, false);                     \
48470:             }                                                                 \
48470:         }                                                                     \
48470:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setBoolean(cond);                                         \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_LT)
48470:     RELATIONAL_OP(<);
48470: END_CASE(JSOP_LT)
48470: 
48470: BEGIN_CASE(JSOP_LE)
48470:     RELATIONAL_OP(<=);
48470: END_CASE(JSOP_LE)
48470: 
48470: BEGIN_CASE(JSOP_GT)
48470:     RELATIONAL_OP(>);
48470: END_CASE(JSOP_GT)
48470: 
48470: BEGIN_CASE(JSOP_GE)
48470:     RELATIONAL_OP(>=);
48470: END_CASE(JSOP_GE)
48470: 
48470: #undef RELATIONAL_OP
48470: 
48470: #define SIGNED_SHIFT_OP(OP)                                                   \
48470:     JS_BEGIN_MACRO                                                            \
48470:         int32_t i, j;                                                         \
48470:         if (!ValueToECMAInt32(cx, regs.sp[-2], &i))                           \
48470:             goto error;                                                       \
48470:         if (!ValueToECMAInt32(cx, regs.sp[-1], &j))                           \
48470:             goto error;                                                       \
48470:         i = i OP (j & 31);                                                    \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setInt32(i);                                              \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_LSH)
48470:     SIGNED_SHIFT_OP(<<);
48470: END_CASE(JSOP_LSH)
48470: 
48470: BEGIN_CASE(JSOP_RSH)
48470:     SIGNED_SHIFT_OP(>>);
48470: END_CASE(JSOP_RSH)
48470: 
48470: #undef SIGNED_SHIFT_OP
48470: 
48470: BEGIN_CASE(JSOP_URSH)
48470: {
48470:     uint32_t u;
48470:     if (!ValueToECMAUint32(cx, regs.sp[-2], &u))
48470:         goto error;
48470:     int32_t j;
48470:     if (!ValueToECMAInt32(cx, regs.sp[-1], &j))
48470:         goto error;
48470: 
48470:     u >>= (j & 31);
48470: 
48470:     regs.sp--;
48470:     regs.sp[-1].setNumber(uint32(u));
48470: }
48470: END_CASE(JSOP_URSH)
48470: 
48470: BEGIN_CASE(JSOP_ADD)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     Value lval = regs.sp[-2];
48470: 
48470:     if (lval.isInt32() && rval.isInt32()) {
48470:         int32_t l = lval.toInt32(), r = rval.toInt32();
48470:         int32_t sum = l + r;
48470:         regs.sp--;
48470:         if (JS_UNLIKELY(bool((l ^ sum) & (r ^ sum) & 0x80000000)))
48470:             regs.sp[-1].setDouble(double(l) + double(r));
48470:         else
48470:             regs.sp[-1].setInt32(sum);
48470:     } else
48470: #if JS_HAS_XML_SUPPORT
48470:     if (IsXML(lval) && IsXML(rval)) {
48470:         if (!js_ConcatenateXML(cx, &lval.toObject(), &rval.toObject(), &rval))
48470:             goto error;
48470:         regs.sp--;
48470:         regs.sp[-1] = rval;
48470:     } else
48470: #endif
48470:     {
48470:         if (lval.isObject())
48470:             DEFAULT_VALUE(cx, -2, JSTYPE_VOID, lval);
48470:         if (rval.isObject())
48470:             DEFAULT_VALUE(cx, -1, JSTYPE_VOID, rval);
48470:         bool lIsString, rIsString;
48470:         if ((lIsString = lval.isString()) | (rIsString = rval.isString())) {
48470:             JSString *lstr, *rstr;
48470:             if (lIsString) {
48470:                 lstr = lval.toString();
48470:             } else {
48470:                 lstr = js_ValueToString(cx, lval);
48470:                 if (!lstr)
48470:                     goto error;
48470:                 regs.sp[-2].setString(lstr);
48470:             }
48470:             if (rIsString) {
48470:                 rstr = rval.toString();
48470:             } else {
48470:                 rstr = js_ValueToString(cx, rval);
48470:                 if (!rstr)
48470:                     goto error;
48470:                 regs.sp[-1].setString(rstr);
48470:             }
48470:             JSString *str = js_ConcatStrings(cx, lstr, rstr);
48470:             if (!str)
48470:                 goto error;
48470:             regs.sp--;
48470:             regs.sp[-1].setString(str);
48470:         } else {
48470:             double l, r;
48470:             if (!ValueToNumber(cx, lval, &l) || !ValueToNumber(cx, rval, &r))
48470:                 goto error;
48470:             l += r;
48470:             regs.sp--;
48470:             regs.sp[-1].setNumber(l);
48470:         }
48470:     }
48470: }
48470: END_CASE(JSOP_ADD)
48470: 
48470: #define BINARY_OP(OP)                                                         \
48470:     JS_BEGIN_MACRO                                                            \
48470:         double d1, d2;                                                        \
48470:         if (!ValueToNumber(cx, regs.sp[-2], &d1) ||                           \
48470:             !ValueToNumber(cx, regs.sp[-1], &d2)) {                           \
48470:             goto error;                                                       \
48470:         }                                                                     \
48470:         double d = d1 OP d2;                                                  \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setNumber(d);                                             \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_SUB)
48470:     BINARY_OP(-);
48470: END_CASE(JSOP_SUB)
48470: 
48470: BEGIN_CASE(JSOP_MUL)
48470:     BINARY_OP(*);
48470: END_CASE(JSOP_MUL)
48470: 
48470: #undef BINARY_OP
48470: 
48470: BEGIN_CASE(JSOP_DIV)
48470: {
48470:     double d1, d2;
48470:     if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
48470:         !ValueToNumber(cx, regs.sp[-1], &d2)) {
48470:         goto error;
48470:     }
48470:     regs.sp--;
48470:     if (d2 == 0) {
48470:         const Value *vp;
48470: #ifdef XP_WIN
48470:         /* XXX MSVC miscompiles such that (NaN == 0) */
48470:         if (JSDOUBLE_IS_NaN(d2))
48470:             vp = &rt->NaNValue;
48470:         else
48470: #endif
48470:         if (d1 == 0 || JSDOUBLE_IS_NaN(d1))
48470:             vp = &rt->NaNValue;
48470:         else if (JSDOUBLE_IS_NEG(d1) != JSDOUBLE_IS_NEG(d2))
48470:             vp = &rt->negativeInfinityValue;
48470:         else
48470:             vp = &rt->positiveInfinityValue;
48470:         regs.sp[-1] = *vp;
48470:     } else {
48470:         d1 /= d2;
48470:         regs.sp[-1].setNumber(d1);
48470:     }
48470: }
48470: END_CASE(JSOP_DIV)
48470: 
48470: BEGIN_CASE(JSOP_MOD)
48470: {
48470:     Value &lref = regs.sp[-2];
48470:     Value &rref = regs.sp[-1];
48470:     int32_t l, r;
48470:     if (lref.isInt32() && rref.isInt32() &&
48470:         (l = lref.toInt32()) >= 0 && (r = rref.toInt32()) > 0) {
48470:         int32_t mod = l % r;
48470:         regs.sp--;
48470:         regs.sp[-1].setInt32(mod);
48470:     } else {
48470:         double d1, d2;
48470:         if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
48470:             !ValueToNumber(cx, regs.sp[-1], &d2)) {
48470:             goto error;
48470:         }
48470:         regs.sp--;
48470:         if (d2 == 0) {
48470:             regs.sp[-1].setDouble(js_NaN);
48470:         } else {
48470:             d1 = js_fmod(d1, d2);
48470:             regs.sp[-1].setDouble(d1);
48470:         }
48470:     }
48470: }
48470: END_CASE(JSOP_MOD)
48470: 
48470: BEGIN_CASE(JSOP_NOT)
48470: {
48470:     Value *_;
48470:     bool cond;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     PUSH_BOOLEAN(!cond);
48470: }
48470: END_CASE(JSOP_NOT)
48470: 
48470: BEGIN_CASE(JSOP_BITNOT)
48470: {
48470:     int32_t i;
48470:     if (!ValueToECMAInt32(cx, regs.sp[-1], &i))
48470:         goto error;
48470:     i = ~i;
48470:     regs.sp[-1].setInt32(i);
48470: }
48470: END_CASE(JSOP_BITNOT)
48470: 
48470: BEGIN_CASE(JSOP_NEG)
48470: {
48470:     /*
48470:      * When the operand is int jsval, INT32_FITS_IN_JSVAL(i) implies
48470:      * INT32_FITS_IN_JSVAL(-i) unless i is 0 or INT32_MIN when the
48470:      * results, -0.0 or INT32_MAX + 1, are jsdouble values.
48470:      */
48470:     const Value &ref = regs.sp[-1];
48470:     int32_t i;
48470:     if (ref.isInt32() && (i = ref.toInt32()) != 0 && i != INT32_MIN) {
48470:         i = -i;
48470:         regs.sp[-1].setInt32(i);
48470:     } else {
48470:         double d;
48470:         if (!ValueToNumber(cx, regs.sp[-1], &d))
48470:             goto error;
48470:         d = -d;
48470:         regs.sp[-1].setDouble(d);
48470:     }
48470: }
48470: END_CASE(JSOP_NEG)
48470: 
48470: BEGIN_CASE(JSOP_POS)
48470:     if (!ValueToNumber(cx, &regs.sp[-1]))
48470:         goto error;
48470: END_CASE(JSOP_POS)
48470: 
48470: BEGIN_CASE(JSOP_DELNAME)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     jsid id = ATOM_TO_JSID(atom);
48470:     JSObject *obj, *obj2;
48470:     JSProperty *prop;
48470:     if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
48470:         goto error;
48470: 
54169:     /* Strict mode code should never contain JSOP_DELNAME opcodes. */
54169:     JS_ASSERT(!script->strictModeCode);
54169: 
48470:     /* ECMA says to return true if name is undefined or inherited. */
48470:     PUSH_BOOLEAN(true);
48470:     if (prop) {
54169:         if (!obj->deleteProperty(cx, id, &regs.sp[-1], false))
48470:             goto error;
48470:     }
48470: }
48470: END_CASE(JSOP_DELNAME)
48470: 
48470: BEGIN_CASE(JSOP_DELPROP)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     jsid id = ATOM_TO_JSID(atom);
48470: 
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -1, obj);
48470: 
48470:     Value rval;
54169:     if (!obj->deleteProperty(cx, id, &rval, script->strictModeCode))
48470:         goto error;
48470: 
48470:     regs.sp[-1] = rval;
48470: }
48470: END_CASE(JSOP_DELPROP)
48470: 
48470: BEGIN_CASE(JSOP_DELELEM)
48470: {
48470:     /* Fetch the left part and resolve it to a non-null object. */
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -2, obj);
48470: 
48470:     /* Fetch index and convert it to id suitable for use with obj. */
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -1, id);
48470: 
48470:     /* Get or set the element. */
54169:     if (!obj->deleteProperty(cx, id, &regs.sp[-2], script->strictModeCode))
48470:         goto error;
48470: 
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_DELELEM)
48470: 
48470: BEGIN_CASE(JSOP_TYPEOFEXPR)
48470: BEGIN_CASE(JSOP_TYPEOF)
48470: {
48470:     const Value &ref = regs.sp[-1];
48470:     JSType type = JS_TypeOfValue(cx, Jsvalify(ref));
48470:     JSAtom *atom = rt->atomState.typeAtoms[type];
48470:     regs.sp[-1].setString(ATOM_TO_STRING(atom));
48470: }
48470: END_CASE(JSOP_TYPEOF)
48470: 
48470: BEGIN_CASE(JSOP_VOID)
48470:     regs.sp[-1].setUndefined();
48470: END_CASE(JSOP_VOID)
48470: 
48470: {
48470:     JSObject *obj;
48470:     JSAtom *atom;
48470:     jsid id;
48470:     jsint i;
48470: 
48470: BEGIN_CASE(JSOP_INCELEM)
48470: BEGIN_CASE(JSOP_DECELEM)
48470: BEGIN_CASE(JSOP_ELEMINC)
48470: BEGIN_CASE(JSOP_ELEMDEC)
48470: 
48470:     /*
48470:      * Delay fetching of id until we have the object to ensure the proper
48470:      * evaluation order. See bug 372331.
48470:      */
48470:     id = JSID_VOID;
48470:     i = -2;
48470:     goto fetch_incop_obj;
48470: 
48470: BEGIN_CASE(JSOP_INCPROP)
48470: BEGIN_CASE(JSOP_DECPROP)
48470: BEGIN_CASE(JSOP_PROPINC)
48470: BEGIN_CASE(JSOP_PROPDEC)
48470:     LOAD_ATOM(0, atom);
48470:     id = ATOM_TO_JSID(atom);
48470:     i = -1;
48470: 
48470:   fetch_incop_obj:
48470:     FETCH_OBJECT(cx, i, obj);
48470:     if (JSID_IS_VOID(id))
48470:         FETCH_ELEMENT_ID(obj, -1, id);
48470:     goto do_incop;
48470: 
48470: BEGIN_CASE(JSOP_INCNAME)
48470: BEGIN_CASE(JSOP_DECNAME)
48470: BEGIN_CASE(JSOP_NAMEINC)
48470: BEGIN_CASE(JSOP_NAMEDEC)
53092: BEGIN_CASE(JSOP_INCGNAME)
53092: BEGIN_CASE(JSOP_DECGNAME)
53092: BEGIN_CASE(JSOP_GNAMEINC)
53092: BEGIN_CASE(JSOP_GNAMEDEC)
48470: {
53840:     obj = &regs.fp->scopeChain();
53092:     if (js_CodeSpec[op].format & JOF_GNAME)
53092:         obj = obj->getGlobal();
48470: 
48470:     JSObject *obj2;
48470:     PropertyCacheEntry *entry;
48470:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
48470:     if (!atom) {
48470:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
48470:         if (obj == obj2 && entry->vword.isSlot()) {
48470:             uint32 slot = entry->vword.toSlot();
56567:             Value &rref = obj->nativeGetSlotRef(slot);
48470:             int32_t tmp;
48470:             if (JS_LIKELY(rref.isInt32() && CanIncDecWithoutOverflow(tmp = rref.toInt32()))) {
48470:                 int32_t inc = tmp + ((js_CodeSpec[op].format & JOF_INC) ? 1 : -1);
48470:                 if (!(js_CodeSpec[op].format & JOF_POST))
48470:                     tmp = inc;
48470:                 rref.getInt32Ref() = inc;
48470:                 PUSH_INT32(tmp);
48470:                 len = JSOP_INCNAME_LENGTH;
48470:                 DO_NEXT_OP(len);
48470:             }
48470:         }
48470:         LOAD_ATOM(0, atom);
48470:     }
48470: 
48470:     id = ATOM_TO_JSID(atom);
48470:     JSProperty *prop;
48470:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
48470:         goto error;
48470:     if (!prop) {
48470:         atomNotDefined = atom;
48470:         goto atom_not_defined;
48470:     }
48470: }
48470: 
48470: do_incop:
48470: {
48470:     /*
48470:      * We need a root to store the value to leave on the stack until
48470:      * we have done with obj->setProperty.
48470:      */
48470:     PUSH_NULL();
48470:     if (!obj->getProperty(cx, id, &regs.sp[-1]))
48470:         goto error;
48470: 
48470:     const JSCodeSpec *cs = &js_CodeSpec[op];
48470:     JS_ASSERT(cs->ndefs == 1);
53092:     JS_ASSERT((cs->format & JOF_TMPSLOT_MASK) >= JOF_TMPSLOT2);
48470:     Value &ref = regs.sp[-1];
48470:     int32_t tmp;
48470:     if (JS_LIKELY(ref.isInt32() && CanIncDecWithoutOverflow(tmp = ref.toInt32()))) {
48470:         int incr = (cs->format & JOF_INC) ? 1 : -1;
48470:         if (cs->format & JOF_POST)
48470:             ref.getInt32Ref() = tmp + incr;
48470:         else
48470:             ref.getInt32Ref() = tmp += incr;
53840:         regs.fp->setAssigning();
54169:         JSBool ok = obj->setProperty(cx, id, &ref, script->strictModeCode);
53840:         regs.fp->clearAssigning();
48470:         if (!ok)
48470:             goto error;
48470: 
48470:         /*
48470:          * We must set regs.sp[-1] to tmp for both post and pre increments
48470:          * as the setter overwrites regs.sp[-1].
48470:          */
48470:         ref.setInt32(tmp);
48470:     } else {
48470:         /* We need an extra root for the result. */
48470:         PUSH_NULL();
48470:         if (!js_DoIncDec(cx, cs, &regs.sp[-2], &regs.sp[-1]))
48470:             goto error;
53840:         regs.fp->setAssigning();
54169:         JSBool ok = obj->setProperty(cx, id, &regs.sp[-1], script->strictModeCode);
53840:         regs.fp->clearAssigning();
48470:         if (!ok)
48470:             goto error;
48470:         regs.sp--;
48470:     }
48470: 
48470:     if (cs->nuses == 0) {
48470:         /* regs.sp[-1] already contains the result of name increment. */
48470:     } else {
48470:         regs.sp[-1 - cs->nuses] = regs.sp[-1];
48470:         regs.sp -= cs->nuses;
48470:     }
48470:     len = cs->length;
48470:     DO_NEXT_OP(len);
48470: }
48470: }
48470: 
48470: {
48470:     int incr, incr2;
48470:     Value *vp;
48470: 
53092: BEGIN_CASE(JSOP_INCGLOBAL)
53092:     incr =  1; incr2 =  1; goto do_bound_global_incop;
53092: BEGIN_CASE(JSOP_DECGLOBAL)
53092:     incr = -1; incr2 = -1; goto do_bound_global_incop;
53092: BEGIN_CASE(JSOP_GLOBALINC)
53092:     incr =  1; incr2 =  0; goto do_bound_global_incop;
53092: BEGIN_CASE(JSOP_GLOBALDEC)
53092:     incr = -1; incr2 =  0; goto do_bound_global_incop;
53092: 
53092:   do_bound_global_incop:
53092:     uint32 slot;
53092:     slot = GET_SLOTNO(regs.pc);
53092:     slot = script->getGlobalSlot(slot);
53092:     JSObject *obj;
53840:     obj = regs.fp->scopeChain().getGlobal();
53092:     vp = &obj->getSlotRef(slot);
53092:     goto do_int_fast_incop;
53092: END_CASE(JSOP_INCGLOBAL)
53092: 
48470:     /* Position cases so the most frequent i++ does not need a jump. */
48470: BEGIN_CASE(JSOP_DECARG)
48470:     incr = -1; incr2 = -1; goto do_arg_incop;
48470: BEGIN_CASE(JSOP_ARGDEC)
48470:     incr = -1; incr2 =  0; goto do_arg_incop;
48470: BEGIN_CASE(JSOP_INCARG)
48470:     incr =  1; incr2 =  1; goto do_arg_incop;
48470: BEGIN_CASE(JSOP_ARGINC)
48470:     incr =  1; incr2 =  0;
48470: 
48470:   do_arg_incop:
48470:     // If we initialize in the declaration, MSVC complains that the labels skip init.
48470:     slot = GET_ARGNO(regs.pc);
53840:     JS_ASSERT(slot < regs.fp->numFormalArgs());
48470:     METER_SLOT_OP(op, slot);
53840:     vp = argv + slot;
48470:     goto do_int_fast_incop;
48470: 
48470: BEGIN_CASE(JSOP_DECLOCAL)
48470:     incr = -1; incr2 = -1; goto do_local_incop;
48470: BEGIN_CASE(JSOP_LOCALDEC)
48470:     incr = -1; incr2 =  0; goto do_local_incop;
48470: BEGIN_CASE(JSOP_INCLOCAL)
48470:     incr =  1; incr2 =  1; goto do_local_incop;
48470: BEGIN_CASE(JSOP_LOCALINC)
48470:     incr =  1; incr2 =  0;
48470: 
48470:   /*
48470:    * do_local_incop comes right before do_int_fast_incop as we want to
48470:    * avoid an extra jump for variable cases as local++ is more frequent
48470:    * than arg++.
48470:    */
48470:   do_local_incop:
48470:     slot = GET_SLOTNO(regs.pc);
53840:     JS_ASSERT(slot < regs.fp->numSlots());
48470:     METER_SLOT_OP(op, slot);
53840:     vp = regs.fp->slots() + slot;
48470: 
48470:   do_int_fast_incop:
48470:     int32_t tmp;
48470:     if (JS_LIKELY(vp->isInt32() && CanIncDecWithoutOverflow(tmp = vp->toInt32()))) {
48470:         vp->getInt32Ref() = tmp + incr;
48470:         JS_ASSERT(JSOP_INCARG_LENGTH == js_CodeSpec[op].length);
48470:         SKIP_POP_AFTER_SET(JSOP_INCARG_LENGTH, 0);
48470:         PUSH_INT32(tmp + incr2);
48470:     } else {
48470:         PUSH_COPY(*vp);
48470:         if (!js_DoIncDec(cx, &js_CodeSpec[op], &regs.sp[-1], vp))
48470:             goto error;
48470:     }
48470:     len = JSOP_INCARG_LENGTH;
48470:     JS_ASSERT(len == js_CodeSpec[op].length);
48470:     DO_NEXT_OP(len);
48470: }
48470: 
48470: BEGIN_CASE(JSOP_THIS)
55713:     if (!regs.fp->computeThis(cx))
53840:         goto error;
53840:     PUSH_COPY(regs.fp->thisValue());
48470: END_CASE(JSOP_THIS)
48470: 
48470: BEGIN_CASE(JSOP_UNBRANDTHIS)
48470: {
55713:     if (!regs.fp->computeThis(cx))
55713:         goto error;
55713:     Value &thisv = regs.fp->thisValue();
55713:     if (thisv.isObject()) {
55713:         JSObject *obj = &thisv.toObject();
52503:         if (obj->isNative() && !obj->unbrand(cx))
48470:             goto error;
48470:     }
55713: }
48470: END_CASE(JSOP_UNBRANDTHIS)
48470: 
48470: {
48470:     JSObject *obj;
48470:     Value *vp;
48470:     jsint i;
48470: 
48470: BEGIN_CASE(JSOP_GETTHISPROP)
55713:     if (!regs.fp->computeThis(cx))
48470:         goto error;
48470:     i = 0;
55713:     PUSH_COPY(regs.fp->thisValue());
55713:     goto do_getprop_body;
48470: 
48470: BEGIN_CASE(JSOP_GETARGPROP)
48470: {
48470:     i = ARGNO_LEN;
48470:     uint32 slot = GET_ARGNO(regs.pc);
53840:     JS_ASSERT(slot < regs.fp->numFormalArgs());
53840:     PUSH_COPY(argv[slot]);
48470:     goto do_getprop_body;
48470: }
48470: 
48470: BEGIN_CASE(JSOP_GETLOCALPROP)
48470: {
48470:     i = SLOTNO_LEN;
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     JS_ASSERT(slot < script->nslots);
53840:     PUSH_COPY(regs.fp->slots()[slot]);
48470:     goto do_getprop_body;
48470: }
48470: 
48470: BEGIN_CASE(JSOP_GETPROP)
48470: BEGIN_CASE(JSOP_GETXPROP)
48470:     i = 0;
48470: 
48470:   do_getprop_body:
48470:     vp = &regs.sp[-1];
48470: 
48470:   do_getprop_with_lval:
48470:     VALUE_TO_OBJECT(cx, vp, obj);
48470: 
48470:     {
48470:         Value rval;
48470:         do {
48470:             /*
48470:              * We do not impose the method read barrier if in an imacro,
48470:              * assuming any property gets it does (e.g., for 'toString'
48470:              * from JSOP_NEW) will not be leaked to the calling script.
48470:              */
48470:             JSObject *aobj = js_GetProtoIfDenseArray(obj);
48470: 
48470:             PropertyCacheEntry *entry;
48470:             JSObject *obj2;
48470:             JSAtom *atom;
48470:             JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
48470:             if (!atom) {
48470:                 ASSERT_VALID_PROPERTY_CACHE_HIT(i, aobj, obj2, entry);
48470:                 if (entry->vword.isFunObj()) {
48470:                     rval.setObject(entry->vword.toFunObj());
48470:                 } else if (entry->vword.isSlot()) {
48470:                     uint32 slot = entry->vword.toSlot();
56567:                     rval = obj2->nativeGetSlot(slot);
48470:                 } else {
52503:                     JS_ASSERT(entry->vword.isShape());
52503:                     const Shape *shape = entry->vword.toShape();
52503:                     NATIVE_GET(cx, obj, obj2, shape,
53840:                                regs.fp->hasImacropc() ? JSGET_NO_METHOD_BARRIER : JSGET_METHOD_BARRIER,
48470:                                &rval);
48470:                 }
48470:                 break;
48470:             }
48470: 
48470:             jsid id = ATOM_TO_JSID(atom);
48622:             if (JS_LIKELY(!aobj->getOps()->getProperty)
48470:                 ? !js_GetPropertyHelper(cx, obj, id,
53840:                                         (regs.fp->hasImacropc() ||
48676:                                          regs.pc[JSOP_GETPROP_LENGTH + i] == JSOP_IFEQ)
48470:                                         ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
48470:                                         : JSGET_CACHE_RESULT | JSGET_METHOD_BARRIER,
48470:                                         &rval)
48470:                 : !obj->getProperty(cx, id, &rval)) {
48470:                 goto error;
48470:             }
48470:         } while (0);
48470: 
48470:         regs.sp[-1] = rval;
55638:         assertSameCompartment(cx, regs.sp[-1]);
48470:         JS_ASSERT(JSOP_GETPROP_LENGTH + i == js_CodeSpec[op].length);
48470:         len = JSOP_GETPROP_LENGTH + i;
48470:     }
48470: END_VARLEN_CASE
48470: 
48470: BEGIN_CASE(JSOP_LENGTH)
48470:     vp = &regs.sp[-1];
48470:     if (vp->isString()) {
48470:         vp->setInt32(vp->toString()->length());
48470:     } else if (vp->isObject()) {
48470:         JSObject *obj = &vp->toObject();
48470:         if (obj->isArray()) {
48470:             jsuint length = obj->getArrayLength();
48470:             regs.sp[-1].setNumber(length);
48470:         } else if (obj->isArguments() && !obj->isArgsLengthOverridden()) {
51091:             uint32 length = obj->getArgsInitialLength();
48470:             JS_ASSERT(length < INT32_MAX);
48470:             regs.sp[-1].setInt32(int32_t(length));
48470:         } else {
48470:             i = -2;
48470:             goto do_getprop_with_lval;
48470:         }
48470:     } else {
48470:         i = -2;
48470:         goto do_getprop_with_lval;
48470:     }
48470: END_CASE(JSOP_LENGTH)
48470: 
48470: }
48470: 
48470: BEGIN_CASE(JSOP_CALLPROP)
48470: {
48470:     Value lval = regs.sp[-1];
48470: 
48470:     Value objv;
48470:     if (lval.isObject()) {
48470:         objv = lval;
48470:     } else {
48470:         JSProtoKey protoKey;
48470:         if (lval.isString()) {
48470:             protoKey = JSProto_String;
48470:         } else if (lval.isNumber()) {
48470:             protoKey = JSProto_Number;
48470:         } else if (lval.isBoolean()) {
48470:             protoKey = JSProto_Boolean;
48470:         } else {
48470:             JS_ASSERT(lval.isNull() || lval.isUndefined());
48470:             js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
48470:             goto error;
48470:         }
48470:         JSObject *pobj;
48470:         if (!js_GetClassPrototype(cx, NULL, protoKey, &pobj))
48470:             goto error;
48470:         objv.setObject(*pobj);
48470:     }
48470: 
48470:     JSObject *aobj = js_GetProtoIfDenseArray(&objv.toObject());
48470:     Value rval;
48470: 
48470:     PropertyCacheEntry *entry;
48470:     JSObject *obj2;
48470:     JSAtom *atom;
48470:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
48470:     if (!atom) {
48470:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, aobj, obj2, entry);
48470:         if (entry->vword.isFunObj()) {
48470:             rval.setObject(entry->vword.toFunObj());
48470:         } else if (entry->vword.isSlot()) {
48470:             uint32 slot = entry->vword.toSlot();
56567:             rval = obj2->nativeGetSlot(slot);
48470:         } else {
52503:             JS_ASSERT(entry->vword.isShape());
52503:             const Shape *shape = entry->vword.toShape();
52503:             NATIVE_GET(cx, &objv.toObject(), obj2, shape, JSGET_NO_METHOD_BARRIER, &rval);
48470:         }
48470:         regs.sp[-1] = rval;
55638:         assertSameCompartment(cx, regs.sp[-1]);
48470:         PUSH_COPY(lval);
55713:     } else {
48470:         /*
48470:          * Cache miss: use the immediate atom that was loaded for us under
48470:          * PropertyCache::test.
48470:          */
48470:         jsid id;
48470:         id = ATOM_TO_JSID(atom);
48470: 
48470:         PUSH_NULL();
48470:         if (lval.isObject()) {
48470:             if (!js_GetMethod(cx, &objv.toObject(), id,
48622:                               JS_LIKELY(!aobj->getOps()->getProperty)
48470:                               ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
48470:                               : JSGET_NO_METHOD_BARRIER,
48470:                               &rval)) {
48470:                 goto error;
48470:             }
48470:             regs.sp[-1] = objv;
48470:             regs.sp[-2] = rval;
55638:             assertSameCompartment(cx, regs.sp[-1], regs.sp[-2]);
48470:         } else {
48622:             JS_ASSERT(!objv.toObject().getOps()->getProperty);
48470:             if (!js_GetPropertyHelper(cx, &objv.toObject(), id,
48470:                                       JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER,
48470:                                       &rval)) {
48470:                 goto error;
48470:             }
48470:             regs.sp[-1] = lval;
48470:             regs.sp[-2] = rval;
55638:             assertSameCompartment(cx, regs.sp[-1], regs.sp[-2]);
48470:         }
48470:     }
48470: #if JS_HAS_NO_SUCH_METHOD
55713:     if (JS_UNLIKELY(rval.isUndefined()) && regs.sp[-1].isObject()) {
48470:         LOAD_ATOM(0, atom);
48470:         regs.sp[-2].setString(ATOM_TO_STRING(atom));
48470:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
48470:             goto error;
48470:     }
48470: #endif
48470: }
48470: END_CASE(JSOP_CALLPROP)
48470: 
48470: BEGIN_CASE(JSOP_UNBRAND)
53840:     JS_ASSERT(regs.sp - regs.fp->slots() >= 1);
48470:     if (!regs.sp[-1].toObject().unbrand(cx))
48470:         goto error;
48470: END_CASE(JSOP_UNBRAND)
48470: 
53092: BEGIN_CASE(JSOP_SETGNAME)
48470: BEGIN_CASE(JSOP_SETNAME)
48470: BEGIN_CASE(JSOP_SETPROP)
48470: BEGIN_CASE(JSOP_SETMETHOD)
48470: {
48600:     Value rval = regs.sp[-1];
48600:     JS_ASSERT_IF(op == JSOP_SETMETHOD, IsFunctionObject(rval));
48470:     Value &lref = regs.sp[-2];
48470:     JS_ASSERT_IF(op == JSOP_SETNAME, lref.isObject());
48470:     JSObject *obj;
48470:     VALUE_TO_OBJECT(cx, &lref, obj);
48470: 
53840:     JS_ASSERT_IF(op == JSOP_SETGNAME, obj == regs.fp->scopeChain().getGlobal());
53092: 
48470:     do {
48470:         PropertyCache *cache = &JS_PROPERTY_CACHE(cx);
48470: 
48470:         /*
48470:          * Probe the property cache, specializing for two important
48470:          * set-property cases. First:
48470:          *
48470:          *   function f(a, b, c) {
48470:          *     var o = {p:a, q:b, r:c};
48470:          *     return o;
48470:          *   }
48470:          *
48470:          * or similar real-world cases, which evolve a newborn native
48470:          * object predicatably through some bounded number of property
48470:          * additions. And second:
48470:          *
48470:          *   o.p = x;
48470:          *
48470:          * in a frequently executed method or loop body, where p will
48470:          * (possibly after the first iteration) always exist in native
48470:          * object o.
48470:          */
48470:         PropertyCacheEntry *entry;
48470:         JSObject *obj2;
48470:         JSAtom *atom;
48470:         if (cache->testForSet(cx, regs.pc, obj, &entry, &obj2, &atom)) {
48470:             /*
56012:              * Fast property cache hit, only partially confirmed by
56012:              * testForSet. We know that the entry applies to regs.pc and
56012:              * that obj's shape matches.
48470:              *
56012:              * The entry predicts either a new property to be added
56012:              * directly to obj by this set, or on an existing "own"
56012:              * property, or on a prototype property that has a setter.
48470:              */
52503:             const Shape *shape = entry->vword.toShape();
52503:             JS_ASSERT_IF(shape->isDataDescriptor(), shape->writable());
52503:             JS_ASSERT_IF(shape->hasSlot(), entry->vcapTag() == 0);
48470: 
48470:             /*
52503:              * Fastest path: check whether obj already has the cached shape and
52503:              * call NATIVE_SET and break to get out of the do-while(0). But we
52503:              * can call NATIVE_SET only for a direct or proto-setter hit.
48470:              */
52503:             if (!entry->adding()) {
48470:                 if (entry->vcapTag() == 0 ||
52506:                     ((obj2 = obj->getProto()) && obj2->shape() == entry->vshape()))
52503:                 {
52503: #ifdef DEBUG
52503:                     if (entry->directHit()) {
52503:                         JS_ASSERT(obj->nativeContains(*shape));
52503:                     } else {
52503:                         JS_ASSERT(obj2->nativeContains(*shape));
52503:                         JS_ASSERT(entry->vcapTag() == 1);
52503:                         JS_ASSERT(entry->kshape != entry->vshape());
52503:                         JS_ASSERT(!shape->hasSlot());
52503:                     }
52503: #endif
52503: 
48470:                     PCMETER(cache->pchits++);
48470:                     PCMETER(cache->setpchits++);
52503:                     NATIVE_SET(cx, obj, shape, entry, &rval);
48470:                     break;
48470:                 }
48470:             } else {
56008:                 JS_ASSERT(obj->isExtensible());
56008: 
52503:                 if (obj->nativeEmpty()) {
56567:                     if (!obj->ensureClassReservedSlotsForEmptyObject(cx))
52503:                         goto error;
48470:                 }
48470: 
48470:                 uint32 slot;
52503:                 if (shape->previous() == obj->lastProperty() &&
48470:                     entry->vshape() == rt->protoHazardShape &&
52503:                     shape->hasDefaultSetter()) {
52503:                     slot = shape->slot;
53652:                     JS_ASSERT(slot == obj->slotSpan());
52503: 
48470:                     /*
52503:                      * Fast path: adding a plain old property that was once at
52503:                      * the frontier of the property tree, whose slot is next to
52503:                      * claim among the already-allocated slots in obj, where
52503:                      * shape->table has not been created yet.
48470:                      */
48470:                     PCMETER(cache->pchits++);
48470:                     PCMETER(cache->addpchits++);
48470: 
48470:                     if (slot < obj->numSlots()) {
52503:                         JS_ASSERT(obj->getSlot(slot).isUndefined());
48470:                     } else {
52503:                         if (!obj->allocSlot(cx, &slot))
52503:                             goto error;
52503:                         JS_ASSERT(slot == shape->slot);
52503:                     }
52503: 
52503:                     /* Simply extend obj's property tree path with shape! */
52503:                     obj->extend(cx, shape);
48470: 
48470:                     /*
52503:                      * No method change check here because here we are adding a
52503:                      * new property, not updating an existing slot's value that
52503:                      * might contain a method of a branded shape.
48470:                      */
52503:                     TRACE_2(SetPropHit, entry, shape);
56567:                     obj->nativeSetSlot(slot, rval);
48470: 
48470:                     /*
48470:                      * Purge the property cache of the id we may have just
52503:                      * shadowed in obj's scope and proto chains.
48470:                      */
52503:                     js_PurgeScopeChain(cx, obj, shape->id);
48470:                     break;
48470:                 }
52503:             }
48470:             PCMETER(cache->setpcmisses++);
56012:             atom = NULL;
56012:         } else if (!atom) {
56012:             /*
56012:              * Slower property cache hit, fully confirmed by testForSet (in the
56012:              * slow path, via fullTest).
56012:              */
56012:             ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
56012:             const Shape *shape = NULL;
56012:             if (obj == obj2) {
56012:                 shape = entry->vword.toShape();
56012:                 JS_ASSERT(shape->writable());
56012:                 JS_ASSERT(obj2->isExtensible());
56012:                 NATIVE_SET(cx, obj, shape, entry, &rval);
56012:             }
56012:             if (shape)
56012:                 break;
56012:         }
56012: 
56012:         if (!atom)
48470:             LOAD_ATOM(0, atom);
48470:         jsid id = ATOM_TO_JSID(atom);
48622:         if (entry && JS_LIKELY(!obj->getOps()->setProperty)) {
48470:             uintN defineHow;
48470:             if (op == JSOP_SETMETHOD)
48470:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_SET_METHOD;
48470:             else if (op == JSOP_SETNAME)
48470:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_UNQUALIFIED;
48470:             else
48470:                 defineHow = JSDNP_CACHE_RESULT;
54169:             if (!js_SetPropertyHelper(cx, obj, id, defineHow, &rval, script->strictModeCode))
48470:                 goto error;
48470:         } else {
54169:             if (!obj->setProperty(cx, id, &rval, script->strictModeCode))
48470:                 goto error;
48470:             ABORT_RECORDING(cx, "Non-native set");
48470:         }
48470:     } while (0);
48470: }
48470: END_SET_CASE_STORE_RVAL(JSOP_SETPROP, 2);
48470: 
48470: BEGIN_CASE(JSOP_GETELEM)
48470: {
48470:     Value &lref = regs.sp[-2];
48470:     Value &rref = regs.sp[-1];
48470:     if (lref.isString() && rref.isInt32()) {
48470:         JSString *str = lref.toString();
48470:         int32_t i = rref.toInt32();
48470:         if (size_t(i) < str->length()) {
48470:             str = JSString::getUnitString(cx, str, size_t(i));
48470:             if (!str)
48470:                 goto error;
48470:             regs.sp--;
48470:             regs.sp[-1].setString(str);
48470:             len = JSOP_GETELEM_LENGTH;
48470:             DO_NEXT_OP(len);
48470:         }
48470:     }
48470: 
48470:     JSObject *obj;
48470:     VALUE_TO_OBJECT(cx, &lref, obj);
48470: 
48470:     const Value *copyFrom;
48470:     Value rval;
48470:     jsid id;
48470:     if (rref.isInt32()) {
48470:         int32_t i = rref.toInt32();
48470:         if (obj->isDenseArray()) {
48470:             jsuint idx = jsuint(i);
48470: 
48537:             if (idx < obj->getDenseArrayCapacity()) {
48470:                 copyFrom = obj->addressOfDenseArrayElement(idx);
48470:                 if (!copyFrom->isMagic())
48470:                     goto end_getelem;
48470:             }
49124:         } else if (obj->isArguments()) {
48470:             uint32 arg = uint32(i);
48470: 
51091:             if (arg < obj->getArgsInitialLength()) {
55525:                 copyFrom = obj->addressOfArgsElement(arg);
55525:                 if (!copyFrom->isMagic(JS_ARGS_HOLE)) {
55525:                     if (JSStackFrame *afp = (JSStackFrame *) obj->getPrivate())
53840:                         copyFrom = &afp->canonicalActualArg(arg);
48470:                     goto end_getelem;
48470:                 }
48470:             }
48470:         }
48470:         if (JS_LIKELY(INT_FITS_IN_JSID(i)))
48470:             id = INT_TO_JSID(i);
48470:         else
48470:             goto intern_big_int;
48470:     } else {
48470:       intern_big_int:
48470:         if (!js_InternNonIntElementId(cx, obj, rref, &id))
48470:             goto error;
48470:     }
48470: 
48470:     if (!obj->getProperty(cx, id, &rval))
48470:         goto error;
48470:     copyFrom = &rval;
48470: 
48470:   end_getelem:
48470:     regs.sp--;
48470:     regs.sp[-1] = *copyFrom;
55638:     assertSameCompartment(cx, regs.sp[-1]);
48470: }
48470: END_CASE(JSOP_GETELEM)
48470: 
48470: BEGIN_CASE(JSOP_CALLELEM)
48470: {
55713:     /* Find the object on which to look for |this|'s properties. */
55713:     Value thisv = regs.sp[-2];
55713:     JSObject *thisObj = ValuePropertyBearer(cx, thisv, -2);
55713:     if (!thisObj)
55713:         goto error;
48470: 
48470:     /* Fetch index and convert it to id suitable for use with obj. */
48470:     jsid id;
55713:     FETCH_ELEMENT_ID(thisObj, -1, id);
55713: 
55713:     /* Get the method. */
55713:     if (!js_GetMethod(cx, thisObj, id, JSGET_NO_METHOD_BARRIER, &regs.sp[-2]))
48470:         goto error;
48470: 
48470: #if JS_HAS_NO_SUCH_METHOD
55713:     if (JS_UNLIKELY(regs.sp[-2].isUndefined()) && thisv.isObject()) {
55713:         /* For js_OnUnknownMethod, sp[-2] is the index, and sp[-1] is the object missing it. */
48470:         regs.sp[-2] = regs.sp[-1];
55713:         regs.sp[-1].setObject(*thisObj);
48470:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
48470:             goto error;
48470:     } else
48470: #endif
48470:     {
55713:         regs.sp[-1] = thisv;
48470:     }
48470: }
48470: END_CASE(JSOP_CALLELEM)
48470: 
48470: BEGIN_CASE(JSOP_SETELEM)
48470: {
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -3, obj);
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -2, id);
48600:     Value rval;
48470:     do {
48470:         if (obj->isDenseArray() && JSID_IS_INT(id)) {
48470:             jsuint length = obj->getDenseArrayCapacity();
48470:             jsint i = JSID_TO_INT(id);
48470:             if ((jsuint)i < length) {
48470:                 if (obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE)) {
48470:                     if (js_PrototypeHasIndexedProperties(cx, obj))
48470:                         break;
48470:                     if ((jsuint)i >= obj->getArrayLength())
48537:                         obj->setArrayLength(i + 1);
48470:                 }
48470:                 obj->setDenseArrayElement(i, regs.sp[-1]);
48470:                 goto end_setelem;
48470:             }
48470:         }
48470:     } while (0);
48600:     rval = regs.sp[-1];
54169:     if (!obj->setProperty(cx, id, &rval, script->strictModeCode))
48470:         goto error;
48470:   end_setelem:;
48470: }
48470: END_SET_CASE_STORE_RVAL(JSOP_SETELEM, 3)
48470: 
48470: BEGIN_CASE(JSOP_ENUMELEM)
48470: {
48470:     /* Funky: the value to set is under the [obj, id] pair. */
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -2, obj);
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -1, id);
48600:     Value rval = regs.sp[-3];
54169:     if (!obj->setProperty(cx, id, &rval, script->strictModeCode))
48470:         goto error;
48470:     regs.sp -= 3;
48470: }
48470: END_CASE(JSOP_ENUMELEM)
48470: 
56556: { // begin block around calling opcodes
53840:     JSFunction *newfun;
53840:     JSObject *callee;
53840:     uint32 flags;
48470:     uintN argc;
48470:     Value *vp;
48470: 
48470: BEGIN_CASE(JSOP_NEW)
48470: {
48470:     /* Get immediate argc and find the constructor function. */
48470:     argc = GET_ARGC(regs.pc);
48470:     vp = regs.sp - (2 + argc);
53840:     JS_ASSERT(vp >= regs.fp->base());
48470: 
48470:     /*
53840:      * Assign lval, callee, and newfun exactly as the code at inline_call: expects to
48470:      * find them, to avoid nesting a js_Interpret call via js_InvokeConstructor.
48470:      */
53840:     if (IsFunctionObject(vp[0], &callee)) {
53840:         newfun = callee->getFunctionPrivate();
53840:         if (newfun->isInterpreted()) {
55503:             if (newfun->u.i.script->isEmpty()) {
55503:                 JSObject *obj2 = js_CreateThisForFunction(cx, callee);
55490:                 if (!obj2)
55490:                     goto error;
48470:                 vp[0].setObject(*obj2);
48470:                 regs.sp = vp + 1;
48470:                 goto end_new;
48470:             }
48470: 
48470:             flags = JSFRAME_CONSTRUCTING;
48470:             goto inline_call;
48470:         }
48470:     }
48470: 
50468:     if (!InvokeConstructor(cx, InvokeArgsAlreadyOnTheStack(vp, argc)))
48470:         goto error;
48470:     regs.sp = vp + 1;
48470:     CHECK_INTERRUPT_HANDLER();
48470:     TRACE_0(NativeCallComplete);
48470: 
48470:   end_new:;
48470: }
48470: END_CASE(JSOP_NEW)
48470: 
48470: BEGIN_CASE(JSOP_EVAL)
48470: {
48470:     argc = GET_ARGC(regs.pc);
48470:     vp = regs.sp - (argc + 2);
48470: 
56556:     if (!IsFunctionObject(*vp, &callee))
56556:         goto call_using_invoke;
56556: 
56556:     newfun = callee->getFunctionPrivate();
56556:     if (!IsBuiltinEvalFunction(newfun))
56556:         goto not_direct_eval;
56556: 
56556:     Probes::enterJSFun(cx, newfun);
56556:     JSBool ok = CallJSNative(cx, newfun->u.n.native, argc, vp);
56556:     Probes::exitJSFun(cx, newfun);
56556:     regs.sp = vp + 1;
56556:     if (!ok)
56556:         goto error;
56556: }
56556: END_CASE(JSOP_EVAL)
56556: 
56556: BEGIN_CASE(JSOP_CALL)
56556: BEGIN_CASE(JSOP_APPLY)
56556: {
56556:     argc = GET_ARGC(regs.pc);
56556:     vp = regs.sp - (argc + 2);
56556: 
53840:     if (IsFunctionObject(*vp, &callee)) {
53840:         newfun = callee->getFunctionPrivate();
48470: 
56556:       not_direct_eval:
48470:         /* Clear frame flags since this is not a constructor call. */
48470:         flags = 0;
53840:         if (newfun->isInterpreted())
48470:       inline_call:
48470:         {
53840:             JSScript *newscript = newfun->u.i.script;
48470:             if (JS_UNLIKELY(newscript->isEmpty())) {
48470:                 vp->setUndefined();
48470:                 regs.sp = vp + 1;
48470:                 goto end_call;
48470:             }
48470: 
48470:             /* Restrict recursion of lightweight functions. */
48470:             if (JS_UNLIKELY(inlineCallCount >= JS_MAX_INLINE_CALL_COUNT)) {
48470:                 js_ReportOverRecursed(cx);
48470:                 goto error;
48470:             }
48470: 
53840:             /* Get pointer to new frame/slots, prepare arguments. */
48470:             StackSpace &stack = cx->stack();
53840:             JSStackFrame *newfp = stack.getInlineFrame(cx, regs.sp, argc, newfun,
53840:                                                        newscript, &flags);
53840:             if (JS_UNLIKELY(!newfp))
53840:                 goto error;
53092:             JS_ASSERT_IF(!vp[1].isPrimitive(), IsSaneThisObject(vp[1].toObject()));
53840: 
53840:             /* Initialize frame, locals. */
53840:             newfp->initCallFrame(cx, *callee, newfun, argc, flags);
53840:             SetValueRangeToUndefined(newfp->slots(), newscript->nfixed);
48470: 
53840:             /* Officially push the frame. */
53840:             stack.pushInlineFrame(cx, newscript, newfp, &regs);
53840: 
53840:             /* Refresh interpreter locals. */
53840:             JS_ASSERT(newfp == regs.fp);
48470:             script = newscript;
53840:             argv = regs.fp->formalArgsEnd() - newfun->nargs;
48470:             atoms = script->atomMap.vector;
48470: 
48470:             /* Now that the new frame is rooted, maybe create a call object. */
53840:             if (newfun->isHeavyweight() && !js_GetCallObject(cx, regs.fp))
48470:                 goto error;
48470: 
48470:             inlineCallCount++;
56201:             JS_RUNTIME_METER(rt, inlineCalls);
48470: 
53524:             TRACE_0(EnterFrame);
48482: 
56201:             CHECK_INTERRUPT_HANDLER();
56201: 
56201: #ifdef JS_METHODJIT
56201:             /* Try to ensure methods are method JIT'd.  */
56201:             mjit::CompileStatus status = mjit::CanMethodJIT(cx, script, regs.fp);
56201:             if (status == mjit::Compile_Error)
56201:                 goto error;
56551:             if (!TRACE_RECORDER(cx) && !TRACE_PROFILER(cx) && status == mjit::Compile_Okay) {
56201:                 interpReturnOK = mjit::JaegerShot(cx);
56201:                 CHECK_INTERRUPT_HANDLER();
56201:                 goto jit_return;
56201:             }
56201: #endif
56201: 
56201:             if (!ScriptPrologue(cx, regs.fp))
56201:                 goto error;
56201: 
56201:             CHECK_INTERRUPT_HANDLER();
56201: 
48470:             /* Load first op and dispatch it (safe since JSOP_STOP). */
48470:             op = (JSOp) *regs.pc;
48470:             DO_OP();
48470:         }
48470: 
53840:         Probes::enterJSFun(cx, newfun);
55657:         JSBool ok = CallJSNative(cx, newfun->u.n.native, argc, vp);
53840:         Probes::exitJSFun(cx, newfun);
48470:         regs.sp = vp + 1;
48470:         if (!ok)
48470:             goto error;
48470:         TRACE_0(NativeCallComplete);
48470:         goto end_call;
48470:     }
48470: 
56556:   call_using_invoke:
48470:     bool ok;
50468:     ok = Invoke(cx, InvokeArgsAlreadyOnTheStack(vp, argc), 0);
48470:     regs.sp = vp + 1;
48470:     CHECK_INTERRUPT_HANDLER();
48470:     if (!ok)
48470:         goto error;
48470:     JS_RUNTIME_METER(rt, nonInlineCalls);
48470:     TRACE_0(NativeCallComplete);
48470: 
48470:   end_call:;
48470: }
48470: END_CASE(JSOP_CALL)
56556: 
56556: } // end block around calling opcodes
48470: 
48470: BEGIN_CASE(JSOP_SETCALL)
48470: {
48470:     uintN argc = GET_ARGC(regs.pc);
48470:     Value *vp = regs.sp - argc - 2;
50468:     JSBool ok = Invoke(cx, InvokeArgsAlreadyOnTheStack(vp, argc), 0);
48470:     if (ok)
48470:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_LEFTSIDE_OF_ASS);
48470:     goto error;
48470: }
48470: END_CASE(JSOP_SETCALL)
48470: 
53092: #define SLOW_PUSH_THISV(cx, obj)                                            \
53092:     JS_BEGIN_MACRO                                                          \
53092:         Class *clasp;                                                       \
53092:         JSObject *thisp = obj;                                              \
53092:         if (!thisp->getParent() ||                                          \
53092:             (clasp = thisp->getClass()) == &js_CallClass ||                 \
53092:             clasp == &js_BlockClass ||                                      \
53092:             clasp == &js_DeclEnvClass) {                                    \
55712:             /* Push the ImplicitThisValue for the Environment Record */     \
55712:             /* associated with obj. See ES5 sections 10.2.1.1.6 and  */     \
55712:             /* 10.2.1.2.6 (ImplicitThisValue) and section 11.2.3     */     \
55712:             /* (Function Calls). */                                         \
55712:             PUSH_UNDEFINED();                                               \
53092:         } else {                                                            \
53092:             thisp = thisp->thisObject(cx);                                  \
53092:             if (!thisp)                                                     \
53092:                 goto error;                                                 \
55712:             PUSH_OBJECT(*thisp);                                            \
53092:         }                                                                   \
53092:     JS_END_MACRO
53100: 
53092: BEGIN_CASE(JSOP_GETGNAME)
53092: BEGIN_CASE(JSOP_CALLGNAME)
48470: BEGIN_CASE(JSOP_NAME)
48470: BEGIN_CASE(JSOP_CALLNAME)
48470: {
53840:     JSObject *obj = &regs.fp->scopeChain();
48470: 
52503:     const Shape *shape;
48470:     Value rval;
48470: 
48470:     PropertyCacheEntry *entry;
48470:     JSObject *obj2;
48470:     JSAtom *atom;
48470:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
48470:     if (!atom) {
48470:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
48470:         if (entry->vword.isFunObj()) {
48470:             PUSH_OBJECT(entry->vword.toFunObj());
53092:         } else if (entry->vword.isSlot()) {
48470:             uintN slot = entry->vword.toSlot();
56567:             PUSH_COPY(obj2->nativeGetSlot(slot));
53092:         } else {
52503:             JS_ASSERT(entry->vword.isShape());
52503:             shape = entry->vword.toShape();
53531:             NATIVE_GET(cx, obj, obj2, shape, JSGET_METHOD_BARRIER, &rval);
53092:             PUSH_COPY(rval);
53092:         }
53092: 
53092:         /*
53092:          * Push results, the same as below, but with a prop$ hit there
53092:          * is no need to test for the unusual and uncacheable case where
53092:          * the caller determines |this|.
53092:          */
53092: #if DEBUG
53092:         Class *clasp;
53092:         JS_ASSERT(!obj->getParent() ||
53092:                   (clasp = obj->getClass()) == &js_CallClass ||
53092:                   clasp == &js_BlockClass ||
53092:                   clasp == &js_DeclEnvClass);
53092: #endif
53092:         if (op == JSOP_CALLNAME || op == JSOP_CALLGNAME)
55712:             PUSH_UNDEFINED();
53092:         len = JSOP_NAME_LENGTH;
53092:         DO_NEXT_OP(len);
48470:     }
48470: 
48470:     jsid id;
48470:     id = ATOM_TO_JSID(atom);
48470:     JSProperty *prop;
48470:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
48470:         goto error;
48470:     if (!prop) {
48470:         /* Kludge to allow (typeof foo == "undefined") tests. */
48470:         JSOp op2 = js_GetOpcode(cx, script, regs.pc + JSOP_NAME_LENGTH);
48470:         if (op2 == JSOP_TYPEOF) {
48470:             PUSH_UNDEFINED();
48470:             len = JSOP_NAME_LENGTH;
48470:             DO_NEXT_OP(len);
48470:         }
48470:         atomNotDefined = atom;
48470:         goto atom_not_defined;
48470:     }
48470: 
48470:     /* Take the slow path if prop was not found in a native object. */
48470:     if (!obj->isNative() || !obj2->isNative()) {
48470:         if (!obj->getProperty(cx, id, &rval))
48470:             goto error;
48470:     } else {
52503:         shape = (Shape *)prop;
53343:         JSObject *normalized = obj;
53531:         if (normalized->getClass() == &js_WithClass && !shape->hasDefaultGetter())
53343:             normalized = js_UnwrapWithObject(cx, normalized);
53531:         NATIVE_GET(cx, normalized, obj2, shape, JSGET_METHOD_BARRIER, &rval);
48470:     }
48470: 
48470:     PUSH_COPY(rval);
48470: 
48470:     /* obj must be on the scope chain, thus not a function. */
53092:     if (op == JSOP_CALLNAME || op == JSOP_CALLGNAME)
53092:         SLOW_PUSH_THISV(cx, obj);
48470: }
48470: END_CASE(JSOP_NAME)
48470: 
48470: BEGIN_CASE(JSOP_UINT16)
48470:     PUSH_INT32((int32_t) GET_UINT16(regs.pc));
48470: END_CASE(JSOP_UINT16)
48470: 
48470: BEGIN_CASE(JSOP_UINT24)
48470:     PUSH_INT32((int32_t) GET_UINT24(regs.pc));
48470: END_CASE(JSOP_UINT24)
48470: 
48470: BEGIN_CASE(JSOP_INT8)
48470:     PUSH_INT32(GET_INT8(regs.pc));
48470: END_CASE(JSOP_INT8)
48470: 
48470: BEGIN_CASE(JSOP_INT32)
48470:     PUSH_INT32(GET_INT32(regs.pc));
48470: END_CASE(JSOP_INT32)
48470: 
48470: BEGIN_CASE(JSOP_INDEXBASE)
48470:     /*
48470:      * Here atoms can exceed script->atomMap.length as we use atoms as a
48470:      * segment register for object literals as well.
48470:      */
48470:     atoms += GET_INDEXBASE(regs.pc);
48470: END_CASE(JSOP_INDEXBASE)
48470: 
48470: BEGIN_CASE(JSOP_INDEXBASE1)
48470: BEGIN_CASE(JSOP_INDEXBASE2)
48470: BEGIN_CASE(JSOP_INDEXBASE3)
48470:     atoms += (op - JSOP_INDEXBASE1 + 1) << 16;
48470: END_CASE(JSOP_INDEXBASE3)
48470: 
48470: BEGIN_CASE(JSOP_RESETBASE0)
48470: BEGIN_CASE(JSOP_RESETBASE)
48470:     atoms = script->atomMap.vector;
48470: END_CASE(JSOP_RESETBASE)
48470: 
48470: BEGIN_CASE(JSOP_DOUBLE)
48470: {
53840:     JS_ASSERT(!regs.fp->hasImacropc());
48470:     JS_ASSERT(size_t(atoms - script->atomMap.vector) <= script->atomMap.length);
48470:     double dbl;
48470:     LOAD_DOUBLE(0, dbl);
48470:     PUSH_DOUBLE(dbl);
48470: }
48470: END_CASE(JSOP_DOUBLE)
48470: 
48470: BEGIN_CASE(JSOP_STRING)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     PUSH_STRING(ATOM_TO_STRING(atom));
48470: }
48470: END_CASE(JSOP_STRING)
48470: 
48470: BEGIN_CASE(JSOP_OBJECT)
48470: {
48470:     JSObject *obj;
48470:     LOAD_OBJECT(0, obj);
48470:     /* Only XML and RegExp objects are emitted. */
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_OBJECT)
48470: 
48470: BEGIN_CASE(JSOP_REGEXP)
48470: {
48470:     /*
48470:      * Push a regexp object cloned from the regexp literal object mapped by the
48470:      * bytecode at pc. ES5 finally fixed this bad old ES3 design flaw which was
48470:      * flouted by many browser-based implementations.
48470:      *
48470:      * We avoid the js_GetScopeChain call here and pass fp->scopeChain as
48470:      * js_GetClassPrototype uses the latter only to locate the global.
48470:      */
48470:     jsatomid index = GET_FULL_INDEX(0);
48470:     JSObject *proto;
53840:     if (!js_GetClassPrototype(cx, &regs.fp->scopeChain(), JSProto_RegExp, &proto))
48470:         goto error;
48470:     JS_ASSERT(proto);
48470:     JSObject *obj = js_CloneRegExpObject(cx, script->getRegExp(index), proto);
48470:     if (!obj)
48470:         goto error;
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_REGEXP)
48470: 
48470: BEGIN_CASE(JSOP_ZERO)
48470:     PUSH_INT32(0);
48470: END_CASE(JSOP_ZERO)
48470: 
48470: BEGIN_CASE(JSOP_ONE)
48470:     PUSH_INT32(1);
48470: END_CASE(JSOP_ONE)
48470: 
48470: BEGIN_CASE(JSOP_NULL)
48470:     PUSH_NULL();
48470: END_CASE(JSOP_NULL)
48470: 
48470: BEGIN_CASE(JSOP_FALSE)
48470:     PUSH_BOOLEAN(false);
48470: END_CASE(JSOP_FALSE)
48470: 
48470: BEGIN_CASE(JSOP_TRUE)
48470:     PUSH_BOOLEAN(true);
48470: END_CASE(JSOP_TRUE)
48470: 
48470: {
48470: BEGIN_CASE(JSOP_TABLESWITCH)
48470: {
48470:     jsbytecode *pc2 = regs.pc;
48470:     len = GET_JUMP_OFFSET(pc2);
48470: 
48470:     /*
48470:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
48470:      * default case if the discriminant isn't already an int jsval.  (This
48470:      * opcode is emitted only for dense jsint-domain switches.)
48470:      */
48470:     const Value &rref = *--regs.sp;
48470:     int32_t i;
48470:     if (rref.isInt32()) {
48470:         i = rref.toInt32();
48470:     } else {
48518:         double d;
48518:         /* Don't use JSDOUBLE_IS_INT32; treat -0 (double) as 0. */
48518:         if (!rref.isDouble() || (d = rref.toDouble()) != (i = int32_t(rref.toDouble())))
48470:             DO_NEXT_OP(len);
48470:     }
48470: 
48470:     pc2 += JUMP_OFFSET_LEN;
48470:     jsint low = GET_JUMP_OFFSET(pc2);
48470:     pc2 += JUMP_OFFSET_LEN;
48470:     jsint high = GET_JUMP_OFFSET(pc2);
48470: 
48470:     i -= low;
48470:     if ((jsuint)i < (jsuint)(high - low + 1)) {
48470:         pc2 += JUMP_OFFSET_LEN + JUMP_OFFSET_LEN * i;
48470:         jsint off = (jsint) GET_JUMP_OFFSET(pc2);
48470:         if (off)
48470:             len = off;
48470:     }
48470: }
48470: END_VARLEN_CASE
48470: }
48470: 
48470: {
48470: BEGIN_CASE(JSOP_TABLESWITCHX)
48470: {
48470:     jsbytecode *pc2 = regs.pc;
48470:     len = GET_JUMPX_OFFSET(pc2);
48470: 
48470:     /*
48470:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
48470:      * default case if the discriminant isn't already an int jsval.  (This
48470:      * opcode is emitted only for dense jsint-domain switches.)
48470:      */
48470:     const Value &rref = *--regs.sp;
48470:     int32_t i;
48470:     if (rref.isInt32()) {
48470:         i = rref.toInt32();
48470:     } else if (rref.isDouble() && rref.toDouble() == 0) {
48470:         /* Treat -0 (double) as 0. */
48470:         i = 0;
48470:     } else {
48470:         DO_NEXT_OP(len);
48470:     }
48470: 
48470:     pc2 += JUMPX_OFFSET_LEN;
48470:     jsint low = GET_JUMP_OFFSET(pc2);
48470:     pc2 += JUMP_OFFSET_LEN;
48470:     jsint high = GET_JUMP_OFFSET(pc2);
48470: 
48470:     i -= low;
48470:     if ((jsuint)i < (jsuint)(high - low + 1)) {
48470:         pc2 += JUMP_OFFSET_LEN + JUMPX_OFFSET_LEN * i;
48470:         jsint off = (jsint) GET_JUMPX_OFFSET(pc2);
48470:         if (off)
48470:             len = off;
48470:     }
48470: }
48470: END_VARLEN_CASE
48470: }
48470: 
48470: {
48470: BEGIN_CASE(JSOP_LOOKUPSWITCHX)
48470: {
48470:     jsint off;
48470:     off = JUMPX_OFFSET_LEN;
48470:     goto do_lookup_switch;
48470: 
48470: BEGIN_CASE(JSOP_LOOKUPSWITCH)
48470:     off = JUMP_OFFSET_LEN;
48470: 
48470:   do_lookup_switch:
48470:     /*
48470:      * JSOP_LOOKUPSWITCH and JSOP_LOOKUPSWITCHX are never used if any atom
48470:      * index in it would exceed 64K limit.
48470:      */
53840:     JS_ASSERT(!regs.fp->hasImacropc());
48470:     JS_ASSERT(atoms == script->atomMap.vector);
48470:     jsbytecode *pc2 = regs.pc;
48470: 
48470:     Value lval = regs.sp[-1];
48470:     regs.sp--;
48470: 
48470:     if (!lval.isPrimitive())
48470:         goto end_lookup_switch;
48470: 
48470:     pc2 += off;
48470:     jsint npairs;
48470:     npairs = (jsint) GET_UINT16(pc2);
48470:     pc2 += UINT16_LEN;
48470:     JS_ASSERT(npairs);  /* empty switch uses JSOP_TABLESWITCH */
48470: 
48470:     bool match;
48470: #define SEARCH_PAIRS(MATCH_CODE)                                              \
48470:     for (;;) {                                                                \
48470:         Value rval = script->getConst(GET_INDEX(pc2));                        \
48470:         MATCH_CODE                                                            \
48470:         pc2 += INDEX_LEN;                                                     \
48470:         if (match)                                                            \
48470:             break;                                                            \
48470:         pc2 += off;                                                           \
48470:         if (--npairs == 0) {                                                  \
48470:             pc2 = regs.pc;                                                    \
48470:             break;                                                            \
48470:         }                                                                     \
48470:     }
48470: 
48470:     if (lval.isString()) {
48470:         JSString *str = lval.toString();
48470:         JSString *str2;
48470:         SEARCH_PAIRS(
48470:             match = (rval.isString() &&
48470:                      ((str2 = rval.toString()) == str ||
48470:                       js_EqualStrings(str2, str)));
48470:         )
48470:     } else if (lval.isNumber()) {
48470:         double ldbl = lval.toNumber();
48470:         SEARCH_PAIRS(
48470:             match = rval.isNumber() && ldbl == rval.toNumber();
48470:         )
48470:     } else {
48470:         SEARCH_PAIRS(
48470:             match = (lval == rval);
48470:         )
48470:     }
48470: #undef SEARCH_PAIRS
48470: 
48470:   end_lookup_switch:
48470:     len = (op == JSOP_LOOKUPSWITCH)
48470:           ? GET_JUMP_OFFSET(pc2)
48470:           : GET_JUMPX_OFFSET(pc2);
48470: }
48470: END_VARLEN_CASE
48470: }
48470: 
48470: BEGIN_CASE(JSOP_TRAP)
48470: {
48470:     Value rval;
48470:     JSTrapStatus status = JS_HandleTrap(cx, script, regs.pc, Jsvalify(&rval));
48470:     switch (status) {
48470:       case JSTRAP_ERROR:
48470:         goto error;
48470:       case JSTRAP_RETURN:
53840:         regs.fp->setReturnValue(rval);
48470:         interpReturnOK = JS_TRUE;
48470:         goto forced_return;
48470:       case JSTRAP_THROW:
48470:         cx->throwing = JS_TRUE;
48470:         cx->exception = rval;
48470:         goto error;
48470:       default:
48470:         break;
48470:     }
48470:     JS_ASSERT(status == JSTRAP_CONTINUE);
48470:     CHECK_INTERRUPT_HANDLER();
48470:     JS_ASSERT(rval.isInt32());
48470:     op = (JSOp) rval.toInt32();
48470:     JS_ASSERT((uintN)op < (uintN)JSOP_LIMIT);
48470:     DO_OP();
48470: }
48470: 
48470: BEGIN_CASE(JSOP_ARGUMENTS)
48470: {
48470:     Value rval;
53840:     if (!js_GetArgsValue(cx, regs.fp, &rval))
48470:         goto error;
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_ARGUMENTS)
48470: 
48470: BEGIN_CASE(JSOP_ARGSUB)
48470: {
48470:     jsid id = INT_TO_JSID(GET_ARGNO(regs.pc));
48470:     Value rval;
53840:     if (!js_GetArgsProperty(cx, regs.fp, id, &rval))
48470:         goto error;
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_ARGSUB)
48470: 
48470: BEGIN_CASE(JSOP_ARGCNT)
48470: {
48470:     jsid id = ATOM_TO_JSID(rt->atomState.lengthAtom);
48470:     Value rval;
53840:     if (!js_GetArgsProperty(cx, regs.fp, id, &rval))
48470:         goto error;
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_ARGCNT)
48470: 
48470: BEGIN_CASE(JSOP_GETARG)
48470: BEGIN_CASE(JSOP_CALLARG)
48470: {
48470:     uint32 slot = GET_ARGNO(regs.pc);
53840:     JS_ASSERT(slot < regs.fp->numFormalArgs());
48470:     METER_SLOT_OP(op, slot);
53840:     PUSH_COPY(argv[slot]);
48470:     if (op == JSOP_CALLARG)
55712:         PUSH_UNDEFINED();
48470: }
48470: END_CASE(JSOP_GETARG)
48470: 
48470: BEGIN_CASE(JSOP_SETARG)
48470: {
48470:     uint32 slot = GET_ARGNO(regs.pc);
53840:     JS_ASSERT(slot < regs.fp->numFormalArgs());
48470:     METER_SLOT_OP(op, slot);
53840:     argv[slot] = regs.sp[-1];
48470: }
48470: END_SET_CASE(JSOP_SETARG)
48470: 
48470: BEGIN_CASE(JSOP_GETLOCAL)
48470: {
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     JS_ASSERT(slot < script->nslots);
53840:     PUSH_COPY(regs.fp->slots()[slot]);
48470: }
48470: END_CASE(JSOP_GETLOCAL)
48470: 
48470: BEGIN_CASE(JSOP_CALLLOCAL)
48470: {
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     JS_ASSERT(slot < script->nslots);
53840:     PUSH_COPY(regs.fp->slots()[slot]);
55712:     PUSH_UNDEFINED();
48470: }
48470: END_CASE(JSOP_CALLLOCAL)
48470: 
48470: BEGIN_CASE(JSOP_SETLOCAL)
48470: {
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     JS_ASSERT(slot < script->nslots);
53840:     regs.fp->slots()[slot] = regs.sp[-1];
48470: }
48470: END_SET_CASE(JSOP_SETLOCAL)
48470: 
48470: BEGIN_CASE(JSOP_GETUPVAR)
48470: BEGIN_CASE(JSOP_CALLUPVAR)
48470: {
48470:     JSUpvarArray *uva = script->upvars();
48470: 
48470:     uintN index = GET_UINT16(regs.pc);
48470:     JS_ASSERT(index < uva->length);
48470: 
48582:     const Value &rval = GetUpvar(cx, script->staticLevel, uva->vector[index]);
48470:     PUSH_COPY(rval);
48470: 
48470:     if (op == JSOP_CALLUPVAR)
55712:         PUSH_UNDEFINED();
48470: }
48470: END_CASE(JSOP_GETUPVAR)
48470: 
48470: BEGIN_CASE(JSOP_GETUPVAR_DBG)
48470: BEGIN_CASE(JSOP_CALLUPVAR_DBG)
48470: {
53840:     JSFunction *fun = regs.fp->fun();
48470:     JS_ASSERT(FUN_KIND(fun) == JSFUN_INTERPRETED);
48470:     JS_ASSERT(fun->u.i.wrapper);
48470: 
48470:     /* Scope for tempPool mark and local names allocation in it. */
48470:     JSObject *obj, *obj2;
48470:     JSProperty *prop;
48470:     jsid id;
48470:     JSAtom *atom;
48470:     {
52503:         AutoLocalNameArray names(cx, fun);
48470:         if (!names)
48470:             goto error;
48470: 
48470:         uintN index = fun->countArgsAndVars() + GET_UINT16(regs.pc);
48470:         atom = JS_LOCAL_NAME_TO_ATOM(names[index]);
48470:         id = ATOM_TO_JSID(atom);
48470: 
52503:         if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
48470:             goto error;
48470:     }
48470: 
48470:     if (!prop) {
48470:         atomNotDefined = atom;
48470:         goto atom_not_defined;
48470:     }
48470: 
48470:     /* Minimize footprint with generic code instead of NATIVE_GET. */
48470:     Value *vp = regs.sp;
48470:     PUSH_NULL();
48470:     if (!obj->getProperty(cx, id, vp))
48470:         goto error;
48470: 
48470:     if (op == JSOP_CALLUPVAR_DBG)
55712:         PUSH_UNDEFINED();
48470: }
48470: END_CASE(JSOP_GETUPVAR_DBG)
48470: 
52503: BEGIN_CASE(JSOP_GETFCSLOT)
52503: BEGIN_CASE(JSOP_CALLFCSLOT)
48470: {
53840:     JS_ASSERT(regs.fp->isFunctionFrame() && !regs.fp->isEvalFrame());
52503:     uintN index = GET_UINT16(regs.pc);
53840:     JSObject *obj = &argv[-2].toObject();
52503: 
52503:     JS_ASSERT(index < obj->getFunctionPrivate()->u.i.nupvars);
52503:     PUSH_COPY(obj->getFlatClosureUpvar(index));
52503:     if (op == JSOP_CALLFCSLOT)
55712:         PUSH_UNDEFINED();
48470: }
52503: END_CASE(JSOP_GETFCSLOT)
48470: 
53092: BEGIN_CASE(JSOP_GETGLOBAL)
53092: BEGIN_CASE(JSOP_CALLGLOBAL)
48470: {
48470:     uint32 slot = GET_SLOTNO(regs.pc);
53092:     slot = script->getGlobalSlot(slot);
53840:     JSObject *obj = regs.fp->scopeChain().getGlobal();
53650:     JS_ASSERT(obj->containsSlot(slot));
53092:     PUSH_COPY(obj->getSlot(slot));
53092:     if (op == JSOP_CALLGLOBAL)
55712:         PUSH_UNDEFINED();
48470: }
53092: END_CASE(JSOP_GETGLOBAL)
53092: 
53092: BEGIN_CASE(JSOP_FORGLOBAL)
53092: {
53092:     Value rval;
53092:     if (!IteratorNext(cx, &regs.sp[-1].toObject(), &rval))
53092:         goto error;
53092:     PUSH_COPY(rval);
56567:     uint32 slot = script->getGlobalSlot(GET_SLOTNO(regs.pc));
53840:     JSObject *obj = regs.fp->scopeChain().getGlobal();
56567:     if (!obj->methodWriteBarrier(cx, slot, rval))
56567:         goto error;
56567:     obj->nativeSetSlot(slot, rval);
53092:     regs.sp--;
53092: }
53092: END_CASE(JSOP_FORGLOBAL)
53092: 
53092: BEGIN_CASE(JSOP_SETGLOBAL)
53092: {
56567:     uint32 slot = script->getGlobalSlot(GET_SLOTNO(regs.pc));
53840:     JSObject *obj = regs.fp->scopeChain().getGlobal();
56567:     if (!obj->methodWriteBarrier(cx, slot, regs.sp[-1]))
56567:         goto error;
56567:     obj->nativeSetSlot(slot, regs.sp[-1]);
51682: }
53092: END_SET_CASE(JSOP_SETGLOBAL)
48470: 
48470: BEGIN_CASE(JSOP_DEFCONST)
48470: BEGIN_CASE(JSOP_DEFVAR)
48470: {
48470:     uint32 index = GET_INDEX(regs.pc);
48470:     JSAtom *atom = atoms[index];
48470: 
53840:     JSObject *obj = &regs.fp->varobj(cx);
48622:     JS_ASSERT(!obj->getOps()->defineProperty);
48470:     uintN attrs = JSPROP_ENUMERATE;
53840:     if (!regs.fp->isEvalFrame())
48470:         attrs |= JSPROP_PERMANENT;
48470:     if (op == JSOP_DEFCONST)
48470:         attrs |= JSPROP_READONLY;
48470: 
48470:     /* Lookup id in order to check for redeclaration problems. */
48470:     jsid id = ATOM_TO_JSID(atom);
48470:     JSProperty *prop = NULL;
48470:     JSObject *obj2;
48470:     if (op == JSOP_DEFVAR) {
48470:         /*
48470:          * Redundant declaration of a |var|, even one for a non-writable
48470:          * property like |undefined| in ES5, does nothing.
48470:          */
48470:         if (!obj->lookupProperty(cx, id, &obj2, &prop))
48470:             goto error;
48470:     } else {
48470:         if (!CheckRedeclaration(cx, obj, id, attrs, &obj2, &prop))
48470:             goto error;
48470:     }
48470: 
48470:     /* Bind a variable only if it's not yet defined. */
48470:     if (!prop) {
48470:         if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(), PropertyStub, PropertyStub,
48470:                                      attrs, 0, 0, &prop)) {
48470:             goto error;
48470:         }
48470:         JS_ASSERT(prop);
48470:         obj2 = obj;
48470:     }
48470: }
48470: END_CASE(JSOP_DEFVAR)
48470: 
48470: BEGIN_CASE(JSOP_DEFFUN)
48470: {
48470:     /*
48470:      * A top-level function defined in Global or Eval code (see ECMA-262
48470:      * Ed. 3), or else a SpiderMonkey extension: a named function statement in
48470:      * a compound statement (not at the top statement level of global code, or
48470:      * at the top level of a function body).
48470:      */
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470:     JSObject *obj = FUN_OBJECT(fun);
48470: 
48470:     JSObject *obj2;
48470:     if (FUN_NULL_CLOSURE(fun)) {
48470:         /*
48470:          * Even a null closure needs a parent for principals finding.
48470:          * FIXME: bug 476950, although debugger users may also demand some kind
48470:          * of scope link for debugger-assisted eval-in-frame.
48470:          */
53840:         obj2 = &regs.fp->scopeChain();
48470:     } else {
48470:         JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
48470: 
54855:         obj2 = js_GetScopeChainFast(cx, regs.fp, JSOP_DEFFUN, JSOP_DEFFUN_LENGTH);
48470:         if (!obj2)
48470:             goto error;
48470:     }
48470: 
48470:     /*
48470:      * If static link is not current scope, clone fun's object to link to the
48470:      * current scope via parent. We do this to enable sharing of compiled
48470:      * functions among multiple equivalent scopes, amortizing the cost of
48470:      * compilation over a number of executions.  Examples include XUL scripts
48470:      * and event handlers shared among Firefox or other Mozilla app chrome
48470:      * windows, and user-defined JS functions precompiled and then shared among
48470:      * requests in server-side JS.
48470:      */
48470:     if (obj->getParent() != obj2) {
48470:         obj = CloneFunctionObject(cx, fun, obj2);
48470:         if (!obj)
48470:             goto error;
48470:     }
48470: 
48470: 
48470:     /*
48470:      * ECMA requires functions defined when entering Eval code to be
48470:      * impermanent.
48470:      */
53840:     uintN attrs = regs.fp->isEvalFrame()
48470:                   ? JSPROP_ENUMERATE
48470:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
48470: 
48470:     /*
48470:      * We define the function as a property of the variable object and not the
48470:      * current scope chain even for the case of function expression statements
48470:      * and functions defined by eval inside let or with blocks.
48470:      */
53840:     JSObject *parent = &regs.fp->varobj(cx);
48605: 
48470:     /*
48470:      * Check for a const property of the same name -- or any kind of property
48470:      * if executing with the strict option.  We check here at runtime as well
48470:      * as at compile-time, to handle eval as well as multiple HTML script tags.
48470:      */
48470:     jsid id = ATOM_TO_JSID(fun->atom);
48605:     JSProperty *prop = NULL;
48605:     JSObject *pobj;
48470:     JSBool ok = CheckRedeclaration(cx, parent, id, attrs, &pobj, &prop);
48470:     if (!ok)
53840:         goto error;
48470: 
48470:     /*
55563:      * We deviate from ES3 10.1.3, ES5 10.5, by using JSObject::setProperty not
55563:      * JSObject::defineProperty for a function declaration in eval code whose
55563:      * id is already bound to a JSPROP_PERMANENT property, to ensure that such
55563:      * properties can't be deleted.
48470:      *
48470:      * We also use JSObject::setProperty for the existing properties of Call
55563:      * objects with matching attributes to preserve the internal (JSPropertyOp)
55563:      * getters and setters that update the value of the property in the stack
55563:      * frame. See bug 467495.
48470:      */
55544:     bool doSet = false;
55544:     if (prop) {
55563:         JS_ASSERT(!(attrs & ~(JSPROP_ENUMERATE | JSPROP_PERMANENT)));
55544:         JS_ASSERT((attrs == JSPROP_ENUMERATE) == regs.fp->isEvalFrame());
55563: 
55563:         if (attrs == JSPROP_ENUMERATE) {
55563:             /* In eval code: assign rather than (re-)define, always. */
55563:             doSet = true;
55563:         } else if (parent->isCall()) {
55563:             JS_ASSERT(parent == pobj);
55563: 
55563:             uintN oldAttrs = ((Shape *) prop)->attributes();
55563:             JS_ASSERT(!(oldAttrs & (JSPROP_READONLY | JSPROP_GETTER | JSPROP_SETTER)));
55563: 
48470:             /*
55563:              * We may be processing a function sub-statement or declaration in
55563:              * function code: we assign rather than redefine if the essential
55563:              * JSPROP_PERMANENT (not [[Configurable]] in ES5 terms) attribute
55563:              * is not changing (note that JSPROP_ENUMERATE is set for all Call
55563:              * object properties).
48470:              */
55563:             JS_ASSERT(oldAttrs & attrs & JSPROP_ENUMERATE);
55563:             if (oldAttrs & JSPROP_PERMANENT)
48605:                 doSet = true;
48470:         }
48470:     }
55563: 
53840:     Value rval = ObjectValue(*obj);
48470:     ok = doSet
54169:          ? parent->setProperty(cx, id, &rval, script->strictModeCode)
48605:          : parent->defineProperty(cx, id, rval, PropertyStub, PropertyStub, attrs);
48470:     if (!ok)
48470:         goto error;
48470: }
48470: END_CASE(JSOP_DEFFUN)
48470: 
48470: BEGIN_CASE(JSOP_DEFFUN_FC)
48470: BEGIN_CASE(JSOP_DEFFUN_DBGFC)
48470: {
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470: 
48470:     JSObject *obj = (op == JSOP_DEFFUN_FC)
55527:                     ? js_NewFlatClosure(cx, fun, JSOP_DEFFUN_FC, JSOP_DEFFUN_FC_LENGTH)
48470:                     : js_NewDebuggableFlatClosure(cx, fun);
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     Value rval = ObjectValue(*obj);
48470: 
53840:     uintN attrs = regs.fp->isEvalFrame()
48470:                   ? JSPROP_ENUMERATE
48470:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
48470: 
53840:     JSObject &parent = regs.fp->varobj(cx);
48470: 
48470:     jsid id = ATOM_TO_JSID(fun->atom);
53840:     if (!CheckRedeclaration(cx, &parent, id, attrs, NULL, NULL))
48605:         goto error;
48605: 
48605:     if ((attrs == JSPROP_ENUMERATE)
54169:         ? !parent.setProperty(cx, id, &rval, script->strictModeCode)
53840:         : !parent.defineProperty(cx, id, rval, PropertyStub, PropertyStub, attrs)) {
48605:         goto error;
48605:     }
48470: }
48470: END_CASE(JSOP_DEFFUN_FC)
48470: 
48470: BEGIN_CASE(JSOP_DEFLOCALFUN)
48470: {
48470:     /*
48470:      * Define a local function (i.e., one nested at the top level of another
48470:      * function), parented by the current scope chain, stored in a local
48470:      * variable slot that the compiler allocated.  This is an optimization over
48470:      * JSOP_DEFFUN that avoids requiring a call object for the outer function's
48470:      * activation.
48470:      */
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(SLOTNO_LEN);
48470:     JS_ASSERT(fun->isInterpreted());
48470:     JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
48470:     JSObject *obj = FUN_OBJECT(fun);
48470: 
48470:     if (FUN_NULL_CLOSURE(fun)) {
53840:         obj = CloneFunctionObject(cx, fun, &regs.fp->scopeChain());
48470:         if (!obj)
48470:             goto error;
48470:     } else {
54855:         JSObject *parent = js_GetScopeChainFast(cx, regs.fp, JSOP_DEFLOCALFUN,
54855:                                                 JSOP_DEFLOCALFUN_LENGTH);
48470:         if (!parent)
48470:             goto error;
48470: 
48470:         if (obj->getParent() != parent) {
48470: #ifdef JS_TRACER
48470:             if (TRACE_RECORDER(cx))
48470:                 AbortRecording(cx, "DEFLOCALFUN for closure");
48470: #endif
48470:             obj = CloneFunctionObject(cx, fun, parent);
48470:             if (!obj)
48470:                 goto error;
48470:         }
48470:     }
48470: 
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     TRACE_2(DefLocalFunSetSlot, slot, obj);
48470: 
53840:     regs.fp->slots()[slot].setObject(*obj);
48470: }
48470: END_CASE(JSOP_DEFLOCALFUN)
48470: 
48470: BEGIN_CASE(JSOP_DEFLOCALFUN_FC)
48470: {
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(SLOTNO_LEN);
48470: 
55527:     JSObject *obj = js_NewFlatClosure(cx, fun, JSOP_DEFLOCALFUN_FC, JSOP_DEFLOCALFUN_FC_LENGTH);
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     TRACE_2(DefLocalFunSetSlot, slot, obj);
48470: 
53840:     regs.fp->slots()[slot].setObject(*obj);
48470: }
48470: END_CASE(JSOP_DEFLOCALFUN_FC)
48470: 
48470: BEGIN_CASE(JSOP_DEFLOCALFUN_DBGFC)
48470: {
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(SLOTNO_LEN);
48470: 
48470:     JSObject *obj = js_NewDebuggableFlatClosure(cx, fun);
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     uint32 slot = GET_SLOTNO(regs.pc);
53840:     regs.fp->slots()[slot].setObject(*obj);
48470: }
48470: END_CASE(JSOP_DEFLOCALFUN_DBGFC)
48470: 
48470: BEGIN_CASE(JSOP_LAMBDA)
48470: {
48470:     /* Load the specified function object literal. */
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470:     JSObject *obj = FUN_OBJECT(fun);
48470: 
48470:     /* do-while(0) so we can break instead of using a goto. */
48470:     do {
48470:         JSObject *parent;
48470:         if (FUN_NULL_CLOSURE(fun)) {
53840:             parent = &regs.fp->scopeChain();
48470: 
48470:             if (obj->getParent() == parent) {
54855:                 jsbytecode *pc2 = js_AdvanceOverBlockchain(regs.pc + JSOP_LAMBDA_LENGTH);
48676:                 JSOp op2 = JSOp(*pc2);
48470: 
48470:                 /*
48676:                  * Optimize var obj = {method: function () { ... }, ...},
48676:                  * this.method = function () { ... }; and other significant
48676:                  * single-use-of-null-closure bytecode sequences.
48676:                  *
48676:                  * WARNING: code in TraceRecorder::record_JSOP_LAMBDA must
48676:                  * match the optimization cases in the following code that
48676:                  * break from the outer do-while(0).
48470:                  */
48676:                 if (op2 == JSOP_INITMETHOD) {
55527: #ifdef DEBUG
55527:                     const Value &lref = regs.sp[-1];
55527:                     JS_ASSERT(lref.isObject());
55527:                     JSObject *obj2 = &lref.toObject();
55527:                     JS_ASSERT(obj2->getClass() == &js_ObjectClass);
55527: #endif
55527: 
54855:                     fun->setMethodAtom(script->getAtom(GET_FULL_INDEX(pc2 - regs.pc)));
48676:                     JS_FUNCTION_METER(cx, joinedinitmethod);
48470:                     break;
48470:                 }
48676: 
48676:                 if (op2 == JSOP_SETMETHOD) {
55527: #ifdef DEBUG
55527:                     op2 = JSOp(pc2[JSOP_SETMETHOD_LENGTH]);
55527:                     JS_ASSERT(op2 == JSOP_POP || op2 == JSOP_POPV);
55527: #endif
48676:                     const Value &lref = regs.sp[-1];
48676:                     if (lref.isObject() && lref.toObject().canHaveMethodBarrier()) {
54855:                         fun->setMethodAtom(script->getAtom(GET_FULL_INDEX(pc2 - regs.pc)));
48676:                         JS_FUNCTION_METER(cx, joinedsetmethod);
48676:                         break;
48676:                     }
48676:                 } else if (fun->joinable()) {
48676:                     if (op2 == JSOP_CALL) {
48676:                         /*
48676:                          * Array.prototype.sort and String.prototype.replace are
48676:                          * optimized as if they are special form. We know that they
48676:                          * won't leak the joined function object in obj, therefore
48676:                          * we don't need to clone that compiler- created function
48676:                          * object for identity/mutation reasons.
48676:                          */
48676:                         int iargc = GET_ARGC(pc2);
48676: 
48676:                         /*
48676:                          * Note that we have not yet pushed obj as the final argument,
48676:                          * so regs.sp[1 - (iargc + 2)], and not regs.sp[-(iargc + 2)],
48676:                          * is the callee for this JSOP_CALL.
48676:                          */
48676:                         const Value &cref = regs.sp[1 - (iargc + 2)];
48676:                         JSObject *callee;
48676: 
48676:                         if (IsFunctionObject(cref, &callee)) {
48676:                             JSFunction *calleeFun = GET_FUNCTION_PRIVATE(cx, callee);
53557:                             if (Native native = calleeFun->maybeNative()) {
53557:                                 if (iargc == 1 && native == array_sort) {
48676:                                     JS_FUNCTION_METER(cx, joinedsort);
48676:                                     break;
48676:                                 }
53557:                                 if (iargc == 2 && native == str_replace) {
48676:                                     JS_FUNCTION_METER(cx, joinedreplace);
48676:                                     break;
48676:                                 }
48676:                             }
48676:                         }
48676:                     } else if (op2 == JSOP_NULL) {
48676:                         pc2 += JSOP_NULL_LENGTH;
48676:                         op2 = JSOp(*pc2);
48676: 
48676:                         if (op2 == JSOP_CALL && GET_ARGC(pc2) == 0) {
48676:                             JS_FUNCTION_METER(cx, joinedmodulepat);
48676:                             break;
48676:                         }
48676:                     }
48676:                 }
48676:             }
48676: 
48676: #ifdef DEBUG
48676:             if (rt->functionMeterFilename) {
48676:                 // No locking, this is mainly for js shell testing.
48676:                 ++rt->functionMeter.unjoined;
48676: 
48676:                 typedef JSRuntime::FunctionCountMap HM;
48676:                 HM &h = rt->unjoinedFunctionCountMap;
48676:                 HM::AddPtr p = h.lookupForAdd(fun);
48676:                 if (!p) {
48676:                     h.add(p, fun, 1);
48676:                 } else {
48676:                     JS_ASSERT(p->key == fun);
48676:                     ++p->value;
48676:                 }
48676:             }
48676: #endif
48470:         } else {
54855:             parent = js_GetScopeChainFast(cx, regs.fp, JSOP_LAMBDA, JSOP_LAMBDA_LENGTH);
48470:             if (!parent)
48470:                 goto error;
48470:         }
48470: 
48470:         obj = CloneFunctionObject(cx, fun, parent);
48470:         if (!obj)
48470:             goto error;
48470:     } while (0);
48470: 
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_LAMBDA)
48470: 
48470: BEGIN_CASE(JSOP_LAMBDA_FC)
48470: {
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470: 
55527:     JSObject *obj = js_NewFlatClosure(cx, fun, JSOP_LAMBDA_FC, JSOP_LAMBDA_FC_LENGTH);
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_LAMBDA_FC)
48470: 
48470: BEGIN_CASE(JSOP_LAMBDA_DBGFC)
48470: {
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470: 
48470:     JSObject *obj = js_NewDebuggableFlatClosure(cx, fun);
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_LAMBDA_DBGFC)
48470: 
48470: BEGIN_CASE(JSOP_CALLEE)
53840:     JS_ASSERT(regs.fp->isFunctionFrame() && !regs.fp->isEvalFrame());
53840:     PUSH_COPY(argv[-2]);
48470: END_CASE(JSOP_CALLEE)
48470: 
48470: BEGIN_CASE(JSOP_GETTER)
48470: BEGIN_CASE(JSOP_SETTER)
48470: {
48470:   do_getter_setter:
48470:     JSOp op2 = (JSOp) *++regs.pc;
48470:     jsid id;
48470:     Value rval;
48470:     jsint i;
48470:     JSObject *obj;
48470:     switch (op2) {
48470:       case JSOP_INDEXBASE:
48470:         atoms += GET_INDEXBASE(regs.pc);
48470:         regs.pc += JSOP_INDEXBASE_LENGTH - 1;
48470:         goto do_getter_setter;
48470:       case JSOP_INDEXBASE1:
48470:       case JSOP_INDEXBASE2:
48470:       case JSOP_INDEXBASE3:
48470:         atoms += (op2 - JSOP_INDEXBASE1 + 1) << 16;
48470:         goto do_getter_setter;
48470: 
48470:       case JSOP_SETNAME:
48470:       case JSOP_SETPROP:
48470:       {
48470:         JSAtom *atom;
48470:         LOAD_ATOM(0, atom);
48470:         id = ATOM_TO_JSID(atom);
48470:         rval = regs.sp[-1];
48470:         i = -1;
48470:         goto gs_pop_lval;
48470:       }
48470:       case JSOP_SETELEM:
48470:         rval = regs.sp[-1];
48470:         id = JSID_VOID;
48470:         i = -2;
48470:       gs_pop_lval:
48470:         FETCH_OBJECT(cx, i - 1, obj);
48470:         break;
48470: 
48470:       case JSOP_INITPROP:
48470:       {
53840:         JS_ASSERT(regs.sp - regs.fp->base() >= 2);
48470:         rval = regs.sp[-1];
48470:         i = -1;
48470:         JSAtom *atom;
48470:         LOAD_ATOM(0, atom);
48470:         id = ATOM_TO_JSID(atom);
48470:         goto gs_get_lval;
48470:       }
48470:       default:
48470:         JS_ASSERT(op2 == JSOP_INITELEM);
48470: 
53840:         JS_ASSERT(regs.sp - regs.fp->base() >= 3);
48470:         rval = regs.sp[-1];
48470:         id = JSID_VOID;
48470:         i = -2;
48470:       gs_get_lval:
48470:       {
48470:         const Value &lref = regs.sp[i-1];
48470:         JS_ASSERT(lref.isObject());
48470:         obj = &lref.toObject();
48470:         break;
48470:       }
48470:     }
48470: 
48470:     /* Ensure that id has a type suitable for use with obj. */
48470:     if (JSID_IS_VOID(id))
48470:         FETCH_ELEMENT_ID(obj, i, id);
48470: 
48470:     if (!js_IsCallable(rval)) {
48470:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
48470:                              JSMSG_BAD_GETTER_OR_SETTER,
48470:                              (op == JSOP_GETTER)
48470:                              ? js_getter_str
48470:                              : js_setter_str);
48470:         goto error;
48470:     }
48470: 
50518:     /*
50518:      * Getters and setters are just like watchpoints from an access control
50518:      * point of view.
50518:      */
48470:     Value rtmp;
48470:     uintN attrs;
50518:     if (!CheckAccess(cx, obj, id, JSACC_WATCH, &rtmp, &attrs))
50518:         goto error;
48470: 
48470:     PropertyOp getter, setter;
48470:     if (op == JSOP_GETTER) {
48470:         getter = CastAsPropertyOp(&rval.toObject());
48470:         setter = PropertyStub;
48470:         attrs = JSPROP_GETTER;
48470:     } else {
48470:         getter = PropertyStub;
48470:         setter = CastAsPropertyOp(&rval.toObject());
48470:         attrs = JSPROP_SETTER;
48470:     }
48470:     attrs |= JSPROP_ENUMERATE | JSPROP_SHARED;
48470: 
48470:     /* Check for a readonly or permanent property of the same name. */
48470:     if (!CheckRedeclaration(cx, obj, id, attrs, NULL, NULL))
48470:         goto error;
48470: 
48470:     if (!obj->defineProperty(cx, id, UndefinedValue(), getter, setter, attrs))
48470:         goto error;
48470: 
48470:     regs.sp += i;
48470:     if (js_CodeSpec[op2].ndefs > js_CodeSpec[op2].nuses) {
48470:         JS_ASSERT(js_CodeSpec[op2].ndefs == js_CodeSpec[op2].nuses + 1);
48470:         regs.sp[-1] = rval;
55638:         assertSameCompartment(cx, regs.sp[-1]);
48470:     }
48470:     len = js_CodeSpec[op2].length;
48470:     DO_NEXT_OP(len);
48470: }
48470: 
48470: BEGIN_CASE(JSOP_HOLE)
48470:     PUSH_HOLE();
48470: END_CASE(JSOP_HOLE)
48470: 
48470: BEGIN_CASE(JSOP_NEWARRAY)
48470: {
48470:     len = GET_UINT16(regs.pc);
48470:     cx->assertValidStackDepth(len);
48537:     JSObject *obj = js_NewArrayObject(cx, len, regs.sp - len);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp -= len - 1;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_NEWARRAY)
48470: 
48470: BEGIN_CASE(JSOP_NEWINIT)
48470: {
55746:     jsint i = GET_UINT16(regs.pc);
55746:     jsint count = GET_UINT16(regs.pc + UINT16_LEN);
55746: 
48470:     JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
48470:     JSObject *obj;
55746: 
55746:     gc::FinalizeKind kind = GuessObjectGCKind(count, i == JSProto_Array);
55746: 
48470:     if (i == JSProto_Array) {
55746:         obj = NewArrayWithKind(cx, kind);
48470:         if (!obj)
48470:             goto error;
48470:     } else {
55746:         obj = NewBuiltinClassInstance(cx, &js_ObjectClass, kind);
48470:         if (!obj)
48470:             goto error;
48470:     }
48470: 
48470:     PUSH_OBJECT(*obj);
48470:     CHECK_INTERRUPT_HANDLER();
48470: }
48470: END_CASE(JSOP_NEWINIT)
48470: 
48470: BEGIN_CASE(JSOP_ENDINIT)
48470: {
51109:     /* FIXME remove JSOP_ENDINIT bug 588522 */
53840:     JS_ASSERT(regs.sp - regs.fp->base() >= 1);
51109:     JS_ASSERT(regs.sp[-1].isObject());
48470: }
48470: END_CASE(JSOP_ENDINIT)
48470: 
48470: BEGIN_CASE(JSOP_INITPROP)
48470: BEGIN_CASE(JSOP_INITMETHOD)
48470: {
48470:     /* Load the property's initial value into rval. */
53840:     JS_ASSERT(regs.sp - regs.fp->base() >= 2);
48470:     Value rval = regs.sp[-1];
48470: 
48470:     /* Load the object being initialized into lval/obj. */
48470:     JSObject *obj = &regs.sp[-2].toObject();
48470:     JS_ASSERT(obj->isNative());
48470: 
48470:     /*
48470:      * Probe the property cache.
48470:      *
48470:      * We can not assume that the object created by JSOP_NEWINIT is still
48470:      * single-threaded as the debugger can access it from other threads.
48470:      * So check first.
48470:      *
52503:      * On a hit, if the cached shape has a non-default setter, it must be
52503:      * __proto__. If shape->previous() != obj->lastProperty(), there must be a
48470:      * repeated property name. The fast path does not handle these two cases.
48470:      */
48470:     PropertyCacheEntry *entry;
52503:     const Shape *shape;
56567:     if (JS_PROPERTY_CACHE(cx).testForInit(rt, regs.pc, obj, &shape, &entry) &&
52503:         shape->hasDefaultSetter() &&
52503:         shape->previous() == obj->lastProperty())
48470:     {
48470:         /* Fast path. Property cache hit. */
52503:         uint32 slot = shape->slot;
52503: 
53652:         JS_ASSERT(slot == obj->slotSpan());
52503:         JS_ASSERT(slot >= JSSLOT_FREE(obj->getClass()));
48470:         if (slot < obj->numSlots()) {
52503:             JS_ASSERT(obj->getSlot(slot).isUndefined());
48470:         } else {
52503:             if (!obj->allocSlot(cx, &slot))
52503:                 goto error;
52503:             JS_ASSERT(slot == shape->slot);
52503:         }
52503: 
52503:         /* A new object, or one we just extended in a recent initprop op. */
52503:         JS_ASSERT(!obj->lastProperty() ||
52503:                   obj->shape() == obj->lastProperty()->shape);
52503:         obj->extend(cx, shape);
48470: 
48470:         /*
48470:          * No method change check here because here we are adding a new
48470:          * property, not updating an existing slot's value that might
52503:          * contain a method of a branded shape.
48470:          */
52503:         TRACE_2(SetPropHit, entry, shape);
56567:         obj->nativeSetSlot(slot, rval);
48470:     } else {
48470:         PCMETER(JS_PROPERTY_CACHE(cx).inipcmisses++);
48470: 
48470:         /* Get the immediate property name into id. */
48470:         JSAtom *atom;
48470:         LOAD_ATOM(0, atom);
48470:         jsid id = ATOM_TO_JSID(atom);
48470: 
51059:         /* No need to check for duplicate property; the compiler already did. */
48470: 
48470:         uintN defineHow = (op == JSOP_INITMETHOD)
48470:                           ? JSDNP_CACHE_RESULT | JSDNP_SET_METHOD
48470:                           : JSDNP_CACHE_RESULT;
48470:         if (!(JS_UNLIKELY(atom == cx->runtime->atomState.protoAtom)
54169:               ? js_SetPropertyHelper(cx, obj, id, defineHow, &rval, script->strictModeCode)
48470:               : js_DefineNativeProperty(cx, obj, id, rval, NULL, NULL,
48470:                                         JSPROP_ENUMERATE, 0, 0, NULL,
48470:                                         defineHow))) {
48470:             goto error;
48470:         }
48470:     }
48470: 
48470:     /* Common tail for property cache hit and miss cases. */
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_INITPROP);
48470: 
48470: BEGIN_CASE(JSOP_INITELEM)
48470: {
48470:     /* Pop the element's value into rval. */
53840:     JS_ASSERT(regs.sp - regs.fp->base() >= 3);
48470:     const Value &rref = regs.sp[-1];
48470: 
48470:     /* Find the object being initialized at top of stack. */
48470:     const Value &lref = regs.sp[-3];
48470:     JS_ASSERT(lref.isObject());
48470:     JSObject *obj = &lref.toObject();
48470: 
48470:     /* Fetch id now that we have obj. */
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -2, id);
48470: 
51059:     /* No need to check for duplicate property; the compiler already did. */
48470: 
48470:     /*
48470:      * If rref is a hole, do not call JSObject::defineProperty. In this case,
48470:      * obj must be an array, so if the current op is the last element
48470:      * initialiser, set the array length to one greater than id.
48470:      */
48470:     if (rref.isMagic(JS_ARRAY_HOLE)) {
48470:         JS_ASSERT(obj->isArray());
48470:         JS_ASSERT(JSID_IS_INT(id));
48470:         JS_ASSERT(jsuint(JSID_TO_INT(id)) < JS_ARGS_LENGTH_MAX);
48470:         if (js_GetOpcode(cx, script, regs.pc + JSOP_INITELEM_LENGTH) == JSOP_ENDINIT &&
48470:             !js_SetLengthProperty(cx, obj, (jsuint) (JSID_TO_INT(id) + 1))) {
48470:             goto error;
48470:         }
48470:     } else {
48470:         if (!obj->defineProperty(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
48470:             goto error;
48470:     }
48470:     regs.sp -= 2;
48470: }
48470: END_CASE(JSOP_INITELEM)
48470: 
48470: #if JS_HAS_SHARP_VARS
48470: 
48470: BEGIN_CASE(JSOP_DEFSHARP)
48470: {
48470:     uint32 slot = GET_UINT16(regs.pc);
53840:     JS_ASSERT(slot + 1 < regs.fp->numFixed());
53840:     const Value &lref = regs.fp->slots()[slot];
48470:     JSObject *obj;
48470:     if (lref.isObject()) {
48470:         obj = &lref.toObject();
48470:     } else {
48470:         JS_ASSERT(lref.isUndefined());
48470:         obj = js_NewArrayObject(cx, 0, NULL);
48470:         if (!obj)
48470:             goto error;
53840:         regs.fp->slots()[slot].setObject(*obj);
48470:     }
48470:     jsint i = (jsint) GET_UINT16(regs.pc + UINT16_LEN);
48470:     jsid id = INT_TO_JSID(i);
48470:     const Value &rref = regs.sp[-1];
48470:     if (rref.isPrimitive()) {
48470:         char numBuf[12];
48470:         JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
48470:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
48470:                              JSMSG_BAD_SHARP_DEF, numBuf);
48470:         goto error;
48470:     }
48470:     if (!obj->defineProperty(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
48470:         goto error;
48470: }
48470: END_CASE(JSOP_DEFSHARP)
48470: 
48470: BEGIN_CASE(JSOP_USESHARP)
48470: {
48470:     uint32 slot = GET_UINT16(regs.pc);
53840:     JS_ASSERT(slot + 1 < regs.fp->numFixed());
53840:     const Value &lref = regs.fp->slots()[slot];
48470:     jsint i = (jsint) GET_UINT16(regs.pc + UINT16_LEN);
48470:     Value rval;
48470:     if (lref.isUndefined()) {
48470:         rval.setUndefined();
48470:     } else {
53840:         JSObject *obj = &regs.fp->slots()[slot].toObject();
48470:         jsid id = INT_TO_JSID(i);
48470:         if (!obj->getProperty(cx, id, &rval))
48470:             goto error;
48470:     }
48470:     if (!rval.isObjectOrNull()) {
48470:         char numBuf[12];
48470: 
48470:         JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
48470:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
48470:                              JSMSG_BAD_SHARP_USE, numBuf);
48470:         goto error;
48470:     }
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_USESHARP)
48470: 
48470: BEGIN_CASE(JSOP_SHARPINIT)
48470: {
48470:     uint32 slot = GET_UINT16(regs.pc);
53840:     JS_ASSERT(slot + 1 < regs.fp->numFixed());
53840:     Value *vp = &regs.fp->slots()[slot];
48470:     Value rval = vp[1];
48470: 
48470:     /*
48470:      * We peek ahead safely here because empty initialisers get zero
48470:      * JSOP_SHARPINIT ops, and non-empty ones get two: the first comes
48470:      * immediately after JSOP_NEWINIT followed by one or more property
48470:      * initialisers; and the second comes directly before JSOP_ENDINIT.
48470:      */
48470:     if (regs.pc[JSOP_SHARPINIT_LENGTH] != JSOP_ENDINIT) {
48470:         rval.setInt32(rval.isUndefined() ? 1 : rval.toInt32() + 1);
48470:     } else {
48470:         JS_ASSERT(rval.isInt32());
48470:         rval.getInt32Ref() -= 1;
48470:         if (rval.toInt32() == 0)
48470:             vp[0].setUndefined();
48470:     }
48470:     vp[1] = rval;
48470: }
48470: END_CASE(JSOP_SHARPINIT)
48470: 
48470: #endif /* JS_HAS_SHARP_VARS */
48470: 
48470: {
48470: BEGIN_CASE(JSOP_GOSUB)
48470:     PUSH_BOOLEAN(false);
48470:     jsint i = (regs.pc - script->main) + JSOP_GOSUB_LENGTH;
48470:     PUSH_INT32(i);
48470:     len = GET_JUMP_OFFSET(regs.pc);
48470: END_VARLEN_CASE
48470: }
48470: 
48470: {
48470: BEGIN_CASE(JSOP_GOSUBX)
48470:     PUSH_BOOLEAN(false);
48470:     jsint i = (regs.pc - script->main) + JSOP_GOSUBX_LENGTH;
48470:     len = GET_JUMPX_OFFSET(regs.pc);
48470:     PUSH_INT32(i);
48470: END_VARLEN_CASE
48470: }
48470: 
48470: {
48470: BEGIN_CASE(JSOP_RETSUB)
48470:     /* Pop [exception or hole, retsub pc-index]. */
48470:     Value rval, lval;
48470:     POP_COPY_TO(rval);
48470:     POP_COPY_TO(lval);
48470:     JS_ASSERT(lval.isBoolean());
48470:     if (lval.toBoolean()) {
48470:         /*
48470:          * Exception was pending during finally, throw it *before* we adjust
48470:          * pc, because pc indexes into script->trynotes.  This turns out not to
48470:          * be necessary, but it seems clearer.  And it points out a FIXME:
48470:          * 350509, due to Igor Bukanov.
48470:          */
48470:         cx->throwing = JS_TRUE;
48470:         cx->exception = rval;
48470:         goto error;
48470:     }
48470:     JS_ASSERT(rval.isInt32());
48470:     len = rval.toInt32();
48470:     regs.pc = script->main;
48470: END_VARLEN_CASE
48470: }
48470: 
48470: BEGIN_CASE(JSOP_EXCEPTION)
48470:     JS_ASSERT(cx->throwing);
48470:     PUSH_COPY(cx->exception);
48470:     cx->throwing = JS_FALSE;
56551: #if defined(JS_TRACER) && defined(JS_METHODJIT)
56551:     if (interpMode == JSINTERP_PROFILE) {
56551:         leaveOnSafePoint = true;
56551:         LEAVE_ON_SAFE_POINT();
56551:     }
56551: #endif
48470:     CHECK_BRANCH();
48470: END_CASE(JSOP_EXCEPTION)
48470: 
48470: BEGIN_CASE(JSOP_FINALLY)
48470:     CHECK_BRANCH();
48470: END_CASE(JSOP_FINALLY)
48470: 
48470: BEGIN_CASE(JSOP_THROWING)
48470:     JS_ASSERT(!cx->throwing);
48470:     cx->throwing = JS_TRUE;
48470:     POP_COPY_TO(cx->exception);
48470: END_CASE(JSOP_THROWING)
48470: 
48470: BEGIN_CASE(JSOP_THROW)
48470:     JS_ASSERT(!cx->throwing);
48470:     CHECK_BRANCH();
48470:     cx->throwing = JS_TRUE;
48470:     POP_COPY_TO(cx->exception);
48470:     /* let the code at error try to catch the exception. */
48470:     goto error;
48470: 
48470: BEGIN_CASE(JSOP_SETLOCALPOP)
48470: {
48470:     /*
48470:      * The stack must have a block with at least one local slot below the
48470:      * exception object.
48470:      */
53840:     JS_ASSERT((size_t) (regs.sp - regs.fp->base()) >= 2);
48470:     uint32 slot = GET_UINT16(regs.pc);
48470:     JS_ASSERT(slot + 1 < script->nslots);
53840:     POP_COPY_TO(regs.fp->slots()[slot]);
48470: }
48470: END_CASE(JSOP_SETLOCALPOP)
48470: 
48470: BEGIN_CASE(JSOP_IFPRIMTOP)
48470:     /*
48470:      * If the top of stack is of primitive type, jump to our target. Otherwise
48470:      * advance to the next opcode.
48470:      */
53840:     JS_ASSERT(regs.sp > regs.fp->base());
48470:     if (regs.sp[-1].isPrimitive()) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: END_CASE(JSOP_IFPRIMTOP)
48470: 
48470: BEGIN_CASE(JSOP_PRIMTOP)
53840:     JS_ASSERT(regs.sp > regs.fp->base());
48470:     if (regs.sp[-1].isObject()) {
48470:         jsint i = GET_INT8(regs.pc);
48470:         js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO, -2, regs.sp[-2], NULL,
48470:                              (i == JSTYPE_VOID) ? "primitive type" : JS_TYPE_STR(i));
48470:         goto error;
48470:     }
48470: END_CASE(JSOP_PRIMTOP)
48470: 
48470: BEGIN_CASE(JSOP_OBJTOP)
48470:     if (regs.sp[-1].isPrimitive()) {
48470:         js_ReportValueError(cx, GET_UINT16(regs.pc), -1, regs.sp[-1], NULL);
48470:         goto error;
48470:     }
48470: END_CASE(JSOP_OBJTOP)
48470: 
48470: BEGIN_CASE(JSOP_INSTANCEOF)
48470: {
48470:     const Value &rref = regs.sp[-1];
48529:     if (rref.isPrimitive()) {
48529:         js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS, -1, rref, NULL);
48529:         goto error;
48529:     }
48529:     JSObject *obj = &rref.toObject();
48470:     const Value &lref = regs.sp[-2];
48470:     JSBool cond = JS_FALSE;
48547:     if (!HasInstance(cx, obj, &lref, &cond))
48470:         goto error;
48470:     regs.sp--;
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_INSTANCEOF)
48470: 
48470: #if JS_HAS_DEBUGGER_KEYWORD
48470: BEGIN_CASE(JSOP_DEBUGGER)
48470: {
48470:     JSDebuggerHandler handler = cx->debugHooks->debuggerHandler;
48470:     if (handler) {
48470:         Value rval;
48470:         switch (handler(cx, script, regs.pc, Jsvalify(&rval), cx->debugHooks->debuggerHandlerData)) {
48470:         case JSTRAP_ERROR:
48470:             goto error;
48470:         case JSTRAP_CONTINUE:
48470:             break;
48470:         case JSTRAP_RETURN:
53840:             regs.fp->setReturnValue(rval);
48470:             interpReturnOK = JS_TRUE;
48470:             goto forced_return;
48470:         case JSTRAP_THROW:
48470:             cx->throwing = JS_TRUE;
48470:             cx->exception = rval;
48470:             goto error;
48470:         default:;
48470:         }
48470:         CHECK_INTERRUPT_HANDLER();
48470:     }
48470: }
48470: END_CASE(JSOP_DEBUGGER)
48470: #endif /* JS_HAS_DEBUGGER_KEYWORD */
48470: 
48470: #if JS_HAS_XML_SUPPORT
48470: BEGIN_CASE(JSOP_DEFXMLNS)
48470: {
53568:     if (!js_SetDefaultXMLNamespace(cx, regs.sp[-1]))
53568:         goto error;
53568:     regs.sp--;
48470: }
48470: END_CASE(JSOP_DEFXMLNS)
48470: 
48470: BEGIN_CASE(JSOP_ANYNAME)
48470: {
48470:     jsid id;
48470:     if (!js_GetAnyName(cx, &id))
48470:         goto error;
48470:     PUSH_COPY(IdToValue(id));
48470: }
48470: END_CASE(JSOP_ANYNAME)
48470: 
48470: BEGIN_CASE(JSOP_QNAMEPART)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     PUSH_STRING(ATOM_TO_STRING(atom));
48470: }
48470: END_CASE(JSOP_QNAMEPART)
48470: 
48470: BEGIN_CASE(JSOP_QNAMECONST)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     Value rval = StringValue(ATOM_TO_STRING(atom));
48470:     Value lval = regs.sp[-1];
48470:     JSObject *obj = js_ConstructXMLQNameObject(cx, lval, rval);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_QNAMECONST)
48470: 
48470: BEGIN_CASE(JSOP_QNAME)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     Value lval = regs.sp[-2];
48470:     JSObject *obj = js_ConstructXMLQNameObject(cx, lval, rval);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp--;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_QNAME)
48470: 
48470: BEGIN_CASE(JSOP_TOATTRNAME)
48470: {
48470:     Value rval;
48470:     rval = regs.sp[-1];
48470:     if (!js_ToAttributeName(cx, &rval))
48470:         goto error;
48470:     regs.sp[-1] = rval;
48470: }
48470: END_CASE(JSOP_TOATTRNAME)
48470: 
48470: BEGIN_CASE(JSOP_TOATTRVAL)
48470: {
48470:     Value rval;
48470:     rval = regs.sp[-1];
48470:     JS_ASSERT(rval.isString());
48470:     JSString *str = js_EscapeAttributeValue(cx, rval.toString(), JS_FALSE);
48470:     if (!str)
48470:         goto error;
48470:     regs.sp[-1].setString(str);
48470: }
48470: END_CASE(JSOP_TOATTRVAL)
48470: 
48470: BEGIN_CASE(JSOP_ADDATTRNAME)
48470: BEGIN_CASE(JSOP_ADDATTRVAL)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     Value lval = regs.sp[-2];
48470:     JSString *str = lval.toString();
48470:     JSString *str2 = rval.toString();
48470:     str = js_AddAttributePart(cx, op == JSOP_ADDATTRNAME, str, str2);
48470:     if (!str)
48470:         goto error;
48470:     regs.sp--;
48470:     regs.sp[-1].setString(str);
48470: }
48470: END_CASE(JSOP_ADDATTRNAME)
48470: 
48470: BEGIN_CASE(JSOP_BINDXMLNAME)
48470: {
48470:     Value lval;
48470:     lval = regs.sp[-1];
48470:     JSObject *obj;
48470:     jsid id;
48470:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
48470:         goto error;
48470:     regs.sp[-1].setObjectOrNull(obj);
48470:     PUSH_COPY(IdToValue(id));
48470: }
48470: END_CASE(JSOP_BINDXMLNAME)
48470: 
48470: BEGIN_CASE(JSOP_SETXMLNAME)
48470: {
48470:     JSObject *obj = &regs.sp[-3].toObject();
48470:     Value rval = regs.sp[-1];
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -2, id);
54169:     if (!obj->setProperty(cx, id, &rval, script->strictModeCode))
48470:         goto error;
48470:     rval = regs.sp[-1];
48470:     regs.sp -= 2;
48470:     regs.sp[-1] = rval;
48470: }
48470: END_CASE(JSOP_SETXMLNAME)
48470: 
48470: BEGIN_CASE(JSOP_CALLXMLNAME)
48470: BEGIN_CASE(JSOP_XMLNAME)
48470: {
48470:     Value lval = regs.sp[-1];
48470:     JSObject *obj;
48470:     jsid id;
48470:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
48470:         goto error;
48470:     Value rval;
48470:     if (!obj->getProperty(cx, id, &rval))
48470:         goto error;
48470:     regs.sp[-1] = rval;
48470:     if (op == JSOP_CALLXMLNAME)
53606:         SLOW_PUSH_THISV(cx, obj);
48470: }
48470: END_CASE(JSOP_XMLNAME)
48470: 
48470: BEGIN_CASE(JSOP_DESCENDANTS)
48470: BEGIN_CASE(JSOP_DELDESC)
48470: {
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -2, obj);
48470:     jsval rval = Jsvalify(regs.sp[-1]);
48470:     if (!js_GetXMLDescendants(cx, obj, rval, &rval))
48470:         goto error;
48470: 
48470:     if (op == JSOP_DELDESC) {
48470:         regs.sp[-1] = Valueify(rval);   /* set local root */
48470:         if (!js_DeleteXMLListElements(cx, JSVAL_TO_OBJECT(rval)))
48470:             goto error;
48470:         rval = JSVAL_TRUE;                  /* always succeed */
48470:     }
48470: 
48470:     regs.sp--;
48470:     regs.sp[-1] = Valueify(rval);
48470: }
48470: END_CASE(JSOP_DESCENDANTS)
48470: 
48470: {
48470: BEGIN_CASE(JSOP_FILTER)
48470:     /*
48470:      * We push the hole value before jumping to [enditer] so we can detect the
48470:      * first iteration and direct js_StepXMLListFilter to initialize filter's
48470:      * state.
48470:      */
48470:     PUSH_HOLE();
48470:     len = GET_JUMP_OFFSET(regs.pc);
48470:     JS_ASSERT(len > 0);
48470: END_VARLEN_CASE
48470: }
48470: 
48470: BEGIN_CASE(JSOP_ENDFILTER)
48470: {
48470:     bool cond = !regs.sp[-1].isMagic();
48470:     if (cond) {
48470:         /* Exit the "with" block left from the previous iteration. */
48470:         js_LeaveWith(cx);
48470:     }
48470:     if (!js_StepXMLListFilter(cx, cond))
48470:         goto error;
48470:     if (!regs.sp[-1].isNull()) {
48470:         /*
48470:          * Decrease sp after EnterWith returns as we use sp[-1] there to root
48470:          * temporaries.
48470:          */
48470:         JS_ASSERT(IsXML(regs.sp[-1]));
55527:         if (!js_EnterWith(cx, -2, JSOP_ENDFILTER, JSOP_ENDFILTER_LENGTH))
48470:             goto error;
48470:         regs.sp--;
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         JS_ASSERT(len < 0);
48470:         BRANCH(len);
48470:     }
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_ENDFILTER);
48470: 
48470: BEGIN_CASE(JSOP_TOXML)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     JSObject *obj = js_ValueToXMLObject(cx, rval);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_TOXML)
48470: 
48470: BEGIN_CASE(JSOP_TOXMLLIST)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     JSObject *obj = js_ValueToXMLListObject(cx, rval);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_TOXMLLIST)
48470: 
48470: BEGIN_CASE(JSOP_XMLTAGEXPR)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     JSString *str = js_ValueToString(cx, rval);
48470:     if (!str)
48470:         goto error;
48470:     regs.sp[-1].setString(str);
48470: }
48470: END_CASE(JSOP_XMLTAGEXPR)
48470: 
48470: BEGIN_CASE(JSOP_XMLELTEXPR)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     JSString *str;
48470:     if (IsXML(rval)) {
48470:         str = js_ValueToXMLString(cx, rval);
48470:     } else {
48470:         str = js_ValueToString(cx, rval);
48470:         if (str)
48470:             str = js_EscapeElementValue(cx, str);
48470:     }
48470:     if (!str)
48470:         goto error;
48470:     regs.sp[-1].setString(str);
48470: }
48470: END_CASE(JSOP_XMLELTEXPR)
48470: 
48470: BEGIN_CASE(JSOP_XMLCDATA)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     JSString *str = ATOM_TO_STRING(atom);
48470:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_TEXT, NULL, str);
48470:     if (!obj)
48470:         goto error;
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_XMLCDATA)
48470: 
48470: BEGIN_CASE(JSOP_XMLCOMMENT)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     JSString *str = ATOM_TO_STRING(atom);
48470:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_COMMENT, NULL, str);
48470:     if (!obj)
48470:         goto error;
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_XMLCOMMENT)
48470: 
48470: BEGIN_CASE(JSOP_XMLPI)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     JSString *str = ATOM_TO_STRING(atom);
48470:     Value rval = regs.sp[-1];
48470:     JSString *str2 = rval.toString();
48470:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_PROCESSING_INSTRUCTION, str, str2);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_XMLPI)
48470: 
48470: BEGIN_CASE(JSOP_GETFUNNS)
48470: {
48470:     Value rval;
48470:     if (!js_GetFunctionNamespace(cx, &rval))
48470:         goto error;
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_GETFUNNS)
48470: #endif /* JS_HAS_XML_SUPPORT */
48470: 
48470: BEGIN_CASE(JSOP_ENTERBLOCK)
48470: {
48470:     JSObject *obj;
48470:     LOAD_OBJECT(0, obj);
53650:     JS_ASSERT(obj->isStaticBlock());
53840:     JS_ASSERT(regs.fp->base() + OBJ_BLOCK_DEPTH(cx, obj) == regs.sp);
48470:     Value *vp = regs.sp + OBJ_BLOCK_COUNT(cx, obj);
48470:     JS_ASSERT(regs.sp < vp);
53840:     JS_ASSERT(vp <= regs.fp->slots() + script->nslots);
48470:     SetValueRangeToUndefined(regs.sp, vp);
48470:     regs.sp = vp;
48470: 
48470: #ifdef DEBUG
48470:     /*
48470:      * The young end of fp->scopeChain may omit blocks if we haven't closed
48470:      * over them, but if there are any closure blocks on fp->scopeChain, they'd
48470:      * better be (clones of) ancestors of the block we're entering now;
48470:      * anything else we should have popped off fp->scopeChain when we left its
48470:      * static scope.
48470:      */
53840:     JSObject *obj2 = &regs.fp->scopeChain();
48470:     Class *clasp;
48470:     while ((clasp = obj2->getClass()) == &js_WithClass)
48470:         obj2 = obj2->getParent();
48470:     if (clasp == &js_BlockClass &&
53840:         obj2->getPrivate() == js_FloatingFrameIfGenerator(cx, regs.fp)) {
48470:         JSObject *youngestProto = obj2->getProto();
53650:         JS_ASSERT(youngestProto->isStaticBlock());
48470:         JSObject *parent = obj;
48470:         while ((parent = parent->getParent()) != youngestProto)
48470:             JS_ASSERT(parent);
48470:     }
48470: #endif
48470: }
48470: END_CASE(JSOP_ENTERBLOCK)
48470: 
48470: BEGIN_CASE(JSOP_LEAVEBLOCKEXPR)
48470: BEGIN_CASE(JSOP_LEAVEBLOCK)
48470: {
54855:     JSObject *blockChain;
54855:     LOAD_OBJECT(UINT16_LEN, blockChain);
48470: #ifdef DEBUG
54855:     JS_ASSERT(blockChain->isStaticBlock());
54855:     uintN blockDepth = OBJ_BLOCK_DEPTH(cx, blockChain);
48470:     JS_ASSERT(blockDepth <= StackDepth(script));
48470: #endif
48470:     /*
48470:      * If we're about to leave the dynamic scope of a block that has been
48470:      * cloned onto fp->scopeChain, clear its private data, move its locals from
48470:      * the stack into the clone, and pop it off the chain.
48470:      */
53840:     JSObject &obj = regs.fp->scopeChain();
54855:     if (obj.getProto() == blockChain) {
53840:         JS_ASSERT(obj.isClonedBlock());
48470:         if (!js_PutBlockObject(cx, JS_TRUE))
48470:             goto error;
48470:     }
48470: 
48470:     /* Move the result of the expression to the new topmost stack slot. */
48470:     Value *vp = NULL;  /* silence GCC warnings */
48470:     if (op == JSOP_LEAVEBLOCKEXPR)
48470:         vp = &regs.sp[-1];
48470:     regs.sp -= GET_UINT16(regs.pc);
48470:     if (op == JSOP_LEAVEBLOCKEXPR) {
53840:         JS_ASSERT(regs.fp->base() + blockDepth == regs.sp - 1);
48470:         regs.sp[-1] = *vp;
48470:     } else {
53840:         JS_ASSERT(regs.fp->base() + blockDepth == regs.sp);
48470:     }
48470: }
48470: END_CASE(JSOP_LEAVEBLOCK)
48470: 
48470: #if JS_HAS_GENERATORS
48470: BEGIN_CASE(JSOP_GENERATOR)
48470: {
53557:     JS_ASSERT(!cx->throwing);
48470:     regs.pc += JSOP_GENERATOR_LENGTH;
48470:     JSObject *obj = js_NewGenerator(cx);
48470:     if (!obj)
48470:         goto error;
53840:     JS_ASSERT(!regs.fp->hasCallObj() && !regs.fp->hasArgsObj());
53840:     regs.fp->setReturnValue(ObjectValue(*obj));
48470:     interpReturnOK = true;
53840:     if (entryFrame != regs.fp)
48470:         goto inline_return;
48470:     goto exit;
48470: }
48470: 
48470: BEGIN_CASE(JSOP_YIELD)
53557:     JS_ASSERT(!cx->throwing);
53840:     JS_ASSERT(regs.fp->isFunctionFrame() && !regs.fp->isEvalFrame());
53840:     if (cx->generatorFor(regs.fp)->state == JSGEN_CLOSING) {
48470:         js_ReportValueError(cx, JSMSG_BAD_GENERATOR_YIELD,
53840:                             JSDVG_SEARCH_STACK, argv[-2], NULL);
53840:         goto error;
53840:     }
53840:     regs.fp->setReturnValue(regs.sp[-1]);
53840:     regs.fp->setYielding();
48470:     regs.pc += JSOP_YIELD_LENGTH;
48470:     interpReturnOK = JS_TRUE;
48470:     goto exit;
48470: 
48470: BEGIN_CASE(JSOP_ARRAYPUSH)
48470: {
48470:     uint32 slot = GET_UINT16(regs.pc);
48470:     JS_ASSERT(script->nfixed <= slot);
48470:     JS_ASSERT(slot < script->nslots);
53840:     JSObject *obj = &regs.fp->slots()[slot].toObject();
48470:     if (!js_ArrayCompPush(cx, obj, regs.sp[-1]))
48470:         goto error;
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_ARRAYPUSH)
48470: #endif /* JS_HAS_GENERATORS */
48470: 
48470: #if JS_THREADED_INTERP
48470:   L_JSOP_BACKPATCH:
48470:   L_JSOP_BACKPATCH_POP:
48470: 
48470: # if !JS_HAS_GENERATORS
48470:   L_JSOP_GENERATOR:
48470:   L_JSOP_YIELD:
48470:   L_JSOP_ARRAYPUSH:
48470: # endif
48470: 
48470: # if !JS_HAS_SHARP_VARS
48470:   L_JSOP_DEFSHARP:
48470:   L_JSOP_USESHARP:
48470:   L_JSOP_SHARPINIT:
48470: # endif
48470: 
48470: # if !JS_HAS_DESTRUCTURING
48470:   L_JSOP_ENUMCONSTELEM:
48470: # endif
48470: 
48470: # if !JS_HAS_XML_SUPPORT
48470:   L_JSOP_CALLXMLNAME:
48470:   L_JSOP_STARTXMLEXPR:
48470:   L_JSOP_STARTXML:
48470:   L_JSOP_DELDESC:
48470:   L_JSOP_GETFUNNS:
48470:   L_JSOP_XMLPI:
48470:   L_JSOP_XMLCOMMENT:
48470:   L_JSOP_XMLCDATA:
48470:   L_JSOP_XMLELTEXPR:
48470:   L_JSOP_XMLTAGEXPR:
48470:   L_JSOP_TOXMLLIST:
48470:   L_JSOP_TOXML:
48470:   L_JSOP_ENDFILTER:
48470:   L_JSOP_FILTER:
48470:   L_JSOP_DESCENDANTS:
48470:   L_JSOP_XMLNAME:
48470:   L_JSOP_SETXMLNAME:
48470:   L_JSOP_BINDXMLNAME:
48470:   L_JSOP_ADDATTRVAL:
48470:   L_JSOP_ADDATTRNAME:
48470:   L_JSOP_TOATTRVAL:
48470:   L_JSOP_TOATTRNAME:
48470:   L_JSOP_QNAME:
48470:   L_JSOP_QNAMECONST:
48470:   L_JSOP_QNAMEPART:
48470:   L_JSOP_ANYNAME:
48470:   L_JSOP_DEFXMLNS:
48470: # endif
48470: 
48470: #endif /* !JS_THREADED_INTERP */
31481: #if !JS_THREADED_INTERP
    1:           default:
    1: #endif
    1:           {
    1:             char numBuf[12];
    1:             JS_snprintf(numBuf, sizeof numBuf, "%d", op);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_BYTECODE, numBuf);
11859:             goto error;
    1:           }
    1: 
    1: #if !JS_THREADED_INTERP
    1:         } /* switch (op) */
23111:     } /* for (;;) */
    1: #endif /* !JS_THREADED_INTERP */
    1: 
11859:   error:
42717:     JS_ASSERT(cx->regs == &regs);
39895: #ifdef JS_TRACER
53840:     if (regs.fp->hasImacropc() && cx->throwing) {
54736:         // Handle exceptions as if they came from the imacro-calling pc.
53840:         regs.pc = regs.fp->imacropc();
53840:         regs.fp->clearImacropc();
21685:         atoms = script->atomMap.vector;
21685:     }
39895: #endif
21685: 
53840:     JS_ASSERT(size_t((regs.fp->hasImacropc() ? regs.fp->imacropc() : regs.pc) - script->code) <
51055:               script->length);
24245: 
27490: #ifdef JS_TRACER
24245:     /*
24245:      * This abort could be weakened to permit tracing through exceptions that
24245:      * are thrown and caught within a loop, with the co-operation of the tracer.
24245:      * For now just bail on any sign of trouble.
24245:      */
27490:     if (TRACE_RECORDER(cx))
37741:         AbortRecording(cx, "error or exception while recording");
56551: # ifdef JS_METHODJIT
56551:     if (TRACE_PROFILER(cx))
56551:         AbortProfiling(cx);
56551: # endif
27490: #endif
24245: 
11859:     if (!cx->throwing) {
11859:         /* This is an error, not a catchable exception, quit the frame ASAP. */
48470:         interpReturnOK = JS_FALSE;
11859:     } else {
41863:         JSThrowHook handler;
 1825:         JSTryNote *tn, *tnlimit;
 1825:         uint32 offset;
 1825: 
11758:         /* Call debugger throw hook if set. */
 2433:         handler = cx->debugHooks->throwHook;
    1:         if (handler) {
48470:             Value rval;
48470:             switch (handler(cx, script, regs.pc, Jsvalify(&rval),
 2433:                             cx->debugHooks->throwHookData)) {
    1:               case JSTRAP_ERROR:
    1:                 cx->throwing = JS_FALSE;
11859:                 goto error;
    1:               case JSTRAP_RETURN:
    1:                 cx->throwing = JS_FALSE;
53840:                 regs.fp->setReturnValue(rval);
48470:                 interpReturnOK = JS_TRUE;
11758:                 goto forced_return;
    1:               case JSTRAP_THROW:
    1:                 cx->exception = rval;
    1:               case JSTRAP_CONTINUE:
    1:               default:;
    1:             }
23111:             CHECK_INTERRUPT_HANDLER();
    1:         }
    1: 
    1:         /*
    1:          * Look for a try block in script that can catch this exception.
    1:          */
 3235:         if (script->trynotesOffset == 0)
 1825:             goto no_catch;
 1825: 
13168:         offset = (uint32)(regs.pc - script->main);
32723:         tn = script->trynotes()->vector;
32723:         tnlimit = tn + script->trynotes()->length;
 3025:         do {
 3025:             if (offset - tn->start >= tn->length)
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * We have a note that covers the exception pc but we must check
 3025:              * whether the interpreter has already executed the corresponding
 3025:              * handler. This is possible when the executed bytecode
 3025:              * implements break or return from inside a for-in loop.
 3025:              *
 3025:              * In this case the emitter generates additional [enditer] and
 3025:              * [gosub] opcodes to close all outstanding iterators and execute
 3025:              * the finally blocks. If such an [enditer] throws an exception,
 3025:              * its pc can still be inside several nested for-in loops and
 3025:              * try-finally statements even if we have already closed the
 3025:              * corresponding iterators and invoked the finally blocks.
 3025:              *
 3025:              * To address this, we make [enditer] always decrease the stack
 3025:              * even when its implementation throws an exception. Thus already
 3025:              * executed [enditer] and [gosub] opcodes will have try notes
 3025:              * with the stack depth exceeding the current one and this
 3025:              * condition is what we use to filter them out.
 3025:              */
53840:             if (tn->stackDepth > regs.sp - regs.fp->base())
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * Set pc to the first bytecode after the the try note to point
 3025:              * to the beginning of catch or finally or to [enditer] closing
 3025:              * the for-in loop.
 1825:              */
13168:             regs.pc = (script)->main + tn->start + tn->length;
13168: 
48470:             JSBool ok = js_UnwindScope(cx, tn->stackDepth, JS_TRUE);
53840:             JS_ASSERT(regs.sp == regs.fp->base() + tn->stackDepth);
11758:             if (!ok) {
11758:                 /*
11758:                  * Restart the handler search with updated pc and stack depth
11758:                  * to properly notify the debugger.
11758:                  */
11859:                 goto error;
11758:             }
 1825: 
 3025:             switch (tn->kind) {
20420:               case JSTRY_CATCH:
 3025: #if JS_HAS_GENERATORS
 3025:                 /* Catch cannot intercept the closing of a generator. */
48470:                 if (JS_UNLIKELY(cx->exception.isMagic(JS_GENERATOR_CLOSING)))
 3025:                     break;
 3025: #endif
 3025: 
 1825:                 /*
 3025:                  * Don't clear cx->throwing to save cx->exception from GC
 3025:                  * until it is pushed to the stack via [exception] in the
 3025:                  * catch block.
 3025:                  */
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
20420:               case JSTRY_FINALLY:
 3025:                 /*
 3025:                  * Push (true, exception) pair for finally to indicate that
 1825:                  * [retsub] should rethrow the exception.
 1825:                  */
48470:                 PUSH_BOOLEAN(true);
48470:                 PUSH_COPY(cx->exception);
 1825:                 cx->throwing = JS_FALSE;
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
42641:               case JSTRY_ITER: {
42641:                 /* This is similar to JSOP_ENDITER in the interpreter loop. */
53840:                 JS_ASSERT(js_GetOpcode(cx, regs.fp->script(), regs.pc) == JSOP_ENDITER);
42641:                 AutoValueRooter tvr(cx, cx->exception);
42641:                 cx->throwing = false;
48470:                 ok = js_CloseIterator(cx, &regs.sp[-1].toObject());
42641:                 regs.sp -= 1;
11859:                 if (!ok)
11859:                     goto error;
42641:                 cx->throwing = true;
42641:                 cx->exception = tvr.value();
42641:               }
11859:            }
11859:         } while (++tn != tnlimit);
11859: 
11859:       no_catch:
 3025:         /*
11859:          * Propagate the exception or error to the caller unless the exception
11859:          * is an asynchronous return from a generator.
 3025:          */
48470:         interpReturnOK = JS_FALSE;
 1969: #if JS_HAS_GENERATORS
48470:         if (JS_UNLIKELY(cx->throwing &&
48470:                         cx->exception.isMagic(JS_GENERATOR_CLOSING))) {
 1969:             cx->throwing = JS_FALSE;
48470:             interpReturnOK = JS_TRUE;
53840:             regs.fp->clearReturnValue();
 1969:         }
 1969: #endif
    1:     }
    1: 
11758:   forced_return:
    1:     /*
48470:      * Unwind the scope making sure that interpReturnOK stays false even when
48470:      * js_UnwindScope returns true.
11859:      *
48470:      * When a trap handler returns JSTRAP_RETURN, we jump here with
48470:      * interpReturnOK set to true bypassing any finally blocks.
    1:      */
48470:     interpReturnOK &= js_UnwindScope(cx, 0, interpReturnOK || cx->throwing);
53840:     JS_ASSERT(regs.sp == regs.fp->base());
11758: 
27233: #ifdef DEBUG
56604:     cx->logPrevPc = NULL;
27233: #endif
27233: 
53840:     if (entryFrame != regs.fp)
    1:         goto inline_return;
    1: 
11758:   exit:
56201:     interpReturnOK = ScriptEpilogue(cx, regs.fp, interpReturnOK);
56201:     regs.fp->setFinishedInInterpreter();
56201: 
    1:     /*
11377:      * At this point we are inevitably leaving an interpreted function or a
11377:      * top-level script, and returning to one of:
11758:      * (a) an "out of line" call made through js_Invoke;
11758:      * (b) a js_Execute activation;
11758:      * (c) a generator (SendToGenerator, jsiter.c).
11758:      *
11859:      * We must not be in an inline frame. The check above ensures that for the
11859:      * error case and for a normal return, the code jumps directly to parent's
11859:      * frame pc.
    1:      */
53840:     JS_ASSERT(entryFrame == regs.fp);
42717: 
18181: #ifdef JS_TRACER
56201:     JS_ASSERT_IF(interpReturnOK && interpMode == JSINTERP_RECORD, !TRACE_RECORDER(cx));
19093:     if (TRACE_RECORDER(cx))
48470:         AbortRecording(cx, "recording out of Interpret");
56551: # ifdef JS_METHODJIT
56551:     if (TRACE_PROFILER(cx))
56551:         AbortProfiling(cx);
56551: # endif
18181: #endif
13168: 
53840:     JS_ASSERT_IF(!regs.fp->isGeneratorFrame(), !js_IsActiveWithOrBlock(cx, &regs.fp->scopeChain(), 0));
16072: 
48470:     return interpReturnOK;
    1: 
    1:   atom_not_defined:
    1:     {
11720:         const char *printable;
11720: 
48470:         printable = js_AtomToPrintableString(cx, atomNotDefined);
    1:         if (printable)
    1:             js_ReportIsNotDefined(cx, printable);
11859:         goto error;
11859:     }
53133: 
56201:     /*
56201:      * This path is used when it's guaranteed the method can be finished
56201:      * inside the JIT.
56201:      */
54560: #if defined(JS_TRACER) && defined(JS_METHODJIT)
56201:   leave_on_safe_point:
53145: #endif
53133:     return interpReturnOK;
11859: }
12551: 
48470: } /* namespace js */
48470: 
15996: #endif /* !defined jsinvoke_cpp___ */
