22840: /* ***** BEGIN LICENSE BLOCK *****
22840:  * 
22840:  * Copyright (c) 2008, Mozilla Corporation
22840:  * All rights reserved.
22840:  * 
22840:  * Redistribution and use in source and binary forms, with or without
22840:  * modification, are permitted provided that the following conditions are met:
22840:  * 
22840:  * * Redistributions of source code must retain the above copyright notice, this
22840:  *   list of conditions and the following disclaimer.
22840:  * * Redistributions in binary form must reproduce the above copyright notice,
22840:  *   this list of conditions and the following disclaimer in the documentation
22840:  *   and/or other materials provided with the distribution.
22840:  * * Neither the name of the Mozilla Corporation nor the names of its
22840:  *   contributors may be used to endorse or promote products derived from this
22840:  *   software without specific prior written permission.
22840:  * 
22840:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
22840:  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
22840:  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
22840:  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
22840:  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
22840:  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
22840:  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
22840:  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
22840:  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
22840:  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
22840:  * 
22840:  * Contributor(s):
22840:  *   Josh Aas <josh@mozilla.com>
22840:  * 
22840:  * ***** END LICENSE BLOCK ***** */
22840: 
22840: #include "nptest_platform.h"
22840: #include <CoreServices/CoreServices.h>
22840: 
33639: using namespace std;
33639: 
26802: bool
26802: pluginSupportsWindowMode()
26802: {
26802:   return false;
26802: }
26802: 
26802: bool
26802: pluginSupportsWindowlessMode()
26802: {
26802:   return true;
26802: }
26802: 
22840: NPError
22840: pluginInstanceInit(InstanceData* instanceData)
22840: {
22840:   NPP npp = instanceData->npp;
32019: 
22840:   NPBool supportsCoreGraphics = false;
32019:   if ((NPN_GetValue(npp, NPNVsupportsCoreGraphicsBool, &supportsCoreGraphics) == NPERR_NO_ERROR) &&
32019:       supportsCoreGraphics) {
22840:     NPN_SetValue(npp, NPPVpluginDrawingModel, (void*)NPDrawingModelCoreGraphics);
22840:   } else {
22840:     printf("CoreGraphics drawing model not supported, can't create a plugin instance.\n");
22840:     return NPERR_INCOMPATIBLE_VERSION_ERROR;
22840:   }
32019: 
40774: #ifndef NP_NO_CARBON
40772:   // The test plugin will test using Carbon NPAPI if it is available. This
40772:   // is simply because we want to test Gecko's Carbon NPAPI support. You can
40772:   // override this behavior with an environment variable.
40772:   if (!getenv("TEST_COCOA_NPAPI")) {
40772:     NPBool supportsCarbonEvents = false;
40772:     if ((NPN_GetValue(npp, NPNVsupportsCarbonBool, &supportsCarbonEvents) == NPERR_NO_ERROR) &&
40772:         supportsCarbonEvents) {
41061:       instanceData->eventModel = NPEventModelCarbon;
41061:       return NPERR_NO_ERROR;
40772:     }
40772:   }
40774: #endif
40772: 
32019:   NPBool supportsCocoaEvents = false;
32019:   if ((NPN_GetValue(npp, NPNVsupportsCocoaBool, &supportsCocoaEvents) == NPERR_NO_ERROR) &&
32019:       supportsCocoaEvents) {
32019:     NPN_SetValue(npp, NPPVpluginEventModel, (void*)NPEventModelCocoa);
41061:     instanceData->eventModel = NPEventModelCocoa;
32019:   } else {
32019:     printf("Cocoa event model not supported, can't create a plugin instance.\n");
32019:     return NPERR_INCOMPATIBLE_VERSION_ERROR;
32019:   }
32019: 
22840:   return NPERR_NO_ERROR;
22840: }
22840: 
26802: void
26802: pluginInstanceShutdown(InstanceData* instanceData)
22840: {
22840: }
26802: 
26942: static bool
26942: RectEquals(const NPRect& r1, const NPRect& r2)
26942: {
26942:   return r1.left == r2.left && r1.top == r2.top &&
26942:          r1.right == r2.right && r1.bottom == r2.bottom;
26942: }
26942: 
26942: void
26942: pluginDoSetWindow(InstanceData* instanceData, NPWindow* newWindow)
26942: {
26942:   // Ugh. Due to a terrible Gecko bug, we have to ignore position changes
26942:   // when the clip rect doesn't change; the position can be wrong
26942:   // when set by a path other than nsObjectFrame::FixUpPluginWindow.
26942:   int32_t oldX = instanceData->window.x;
26942:   int32_t oldY = instanceData->window.y;
26942:   bool clipChanged =
26942:     !RectEquals(instanceData->window.clipRect, newWindow->clipRect);
26942:   instanceData->window = *newWindow;
26942:   if (!clipChanged) {
26942:     instanceData->window.x = oldX;
26942:     instanceData->window.y = oldY;
26942:   }
26942: }
26942: 
26802: void
26802: pluginWidgetInit(InstanceData* instanceData, void* oldWindow)
26802: {
26802:   // Should never be called since we don't support window mode
22840: }
22840: 
23823: static void 
23823: GetColorsFromRGBA(PRUint32 rgba, float* r, float* g, float* b, float* a)
23823: {
23823:   *b = (rgba & 0xFF) / 255.0;
23823:   *g = ((rgba & 0xFF00) >> 8) / 255.0;
23823:   *r = ((rgba & 0xFF0000) >> 16) / 255.0;
23823:   *a = ((rgba & 0xFF000000) >> 24) / 255.0;
23823: }
23823: 
26802: static void
32019: pluginDraw(InstanceData* instanceData, NPCocoaEvent* event)
22840: {
22840:   if (!instanceData)
22840:     return;
22840: 
22840:   NPP npp = instanceData->npp;
22840:   if (!npp)
22840:     return;
22840:   
22840:   const char* uaString = NPN_UserAgent(npp);
22840:   if (!uaString)
22840:     return;
22840: 
22840:   NPWindow window = instanceData->window;
32019: 
40772:   CGContextRef cgContext = NULL;
40772: #ifndef NP_NO_CARBON
41061:   if (instanceData->eventModel == NPEventModelCocoa) {
40772:     cgContext = event->data.draw.context;
40772:   } else {
40772:     cgContext = ((NP_CGContext*)(window.window))->context;
40772:   }
32019: #else
40772:   cgContext = event->data.draw.context;
32019: #endif
22840: 
22840:   float windowWidth = window.width;
22840:   float windowHeight = window.height;
22840: 
23823:   switch(instanceData->scriptableObject->drawMode) {
23823:   case DM_DEFAULT: {
23823:     CFStringRef uaCFString = CFStringCreateWithCString(kCFAllocatorDefault, uaString, kCFStringEncodingASCII);
22840:     // save the cgcontext gstate
22840:     CGContextSaveGState(cgContext);
22840: 
22840:     // we get a flipped context
22840:     CGContextTranslateCTM(cgContext, 0.0, windowHeight);
22840:     CGContextScaleCTM(cgContext, 1.0, -1.0);
22840: 
22840:     // draw a gray background for the plugin
22840:     CGContextAddRect(cgContext, CGRectMake(0, 0, windowWidth, windowHeight));
22840:     CGContextSetGrayFillColor(cgContext, 0.5, 1.0);
22840:     CGContextDrawPath(cgContext, kCGPathFill);
22840: 
22840:     // draw a black frame around the plugin
22840:     CGContextAddRect(cgContext, CGRectMake(0, 0, windowWidth, windowHeight));
22840:     CGContextSetGrayStrokeColor(cgContext, 0.0, 1.0);
22840:     CGContextSetLineWidth(cgContext, 6.0);
22840:     CGContextStrokePath(cgContext);
22840: 
40551:     // draw the UA string using Core Text
32019:     CGContextSetTextMatrix(cgContext, CGAffineTransformIdentity);
32019: 
32019:     // Initialize a rectangular path.
32019:     CGMutablePathRef path = CGPathCreateMutable();
43407:     CGRect bounds = CGRectMake(10.0, 10.0, PR_MAX(0.0, windowWidth - 20.0),
43407:                                PR_MAX(0.0, windowHeight - 20.0));
32019:     CGPathAddRect(path, NULL, bounds);
32019: 
32019:     // Initialize an attributed string.
32019:     CFMutableAttributedStringRef attrString = CFAttributedStringCreateMutable(kCFAllocatorDefault, 0);
32019:     CFAttributedStringReplaceString(attrString, CFRangeMake(0, 0), uaCFString);
32019: 
32019:     // Create a color and add it as an attribute to the string.
32019:     CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();
32019:     CGFloat components[] = { 0.0, 0.0, 0.0, 1.0 };
32019:     CGColorRef red = CGColorCreate(rgbColorSpace, components);    
32019:     CGColorSpaceRelease(rgbColorSpace);
32019:     CFAttributedStringSetAttribute(attrString, CFRangeMake(0, 50), kCTForegroundColorAttributeName, red);
32019: 
32019:     // Create the framesetter with the attributed string.
32019:     CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString(attrString);
32019:     CFRelease(attrString);
32019: 
32019:     // Create the frame and draw it into the graphics context
32019:     CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL);
32019:     CFRelease(framesetter);
43407:     if (frame) {
32019:       CTFrameDraw(frame, cgContext);
32019:       CFRelease(frame);
43407:     }
22840: 
22840:     // restore the cgcontext gstate
22840:     CGContextRestoreGState(cgContext);
34501:     break;
22840:   }
23823:   case DM_SOLID_COLOR: {
23823:     // save the cgcontext gstate
23823:     CGContextSaveGState(cgContext);
23823: 
23823:     // we get a flipped context
23823:     CGContextTranslateCTM(cgContext, 0.0, windowHeight);
23823:     CGContextScaleCTM(cgContext, 1.0, -1.0);
23823: 
23823:     // draw a solid background for the plugin
23823:     CGContextAddRect(cgContext, CGRectMake(0, 0, windowWidth, windowHeight));
23823: 
23823:     float r,g,b,a;
23823:     GetColorsFromRGBA(instanceData->scriptableObject->drawColor, &r, &g, &b, &a);
23823:     CGContextSetRGBFillColor(cgContext, r, g, b, a);
23823:     CGContextDrawPath(cgContext, kCGPathFill);
23823: 
23823:     // restore the cgcontext gstate
23823:     CGContextRestoreGState(cgContext);
23823:     break;
23823:   }
23823:   }
53945: 
53945:   notifyDidPaint(instanceData);
23823: }
26802: 
26802: int16_t
26802: pluginHandleEvent(InstanceData* instanceData, void* event)
26802: {
40772: #ifndef NP_NO_CARBON
41061:   if (instanceData->eventModel == NPEventModelCarbon) {
26802:     EventRecord* carbonEvent = (EventRecord*)event;
31130:     if (!carbonEvent)
41955:       return kNPEventNotHandled;
31130: 
31130:     NPWindow* w = &instanceData->window;
31130:     switch (carbonEvent->what) {
31130:       case updateEvt:
40772:         pluginDraw(instanceData, NULL);
41955:         break;
31130:       case mouseDown:
31130:       case mouseUp:
31130:       case osEvt:
38846:       {
38846:         Rect globalBounds = {0};
38846:         WindowRef nativeWindow = static_cast<WindowRef>(static_cast<NP_CGContext*>(w->window)->window);
38846:         if (nativeWindow)
38846:           ::GetWindowBounds(nativeWindow, kWindowStructureRgn, &globalBounds);
38846:         instanceData->lastMouseX = carbonEvent->where.h - w->x - globalBounds.left;
38846:         instanceData->lastMouseY = carbonEvent->where.v - w->y - globalBounds.top;
41955:         break;
38846:       }
31130:       default:
41955:         return kNPEventNotHandled;
40772:     }
41955: 
41955:     return kNPEventHandled;
26802:   }
32019: #endif
40772: 
40772:   NPCocoaEvent* cocoaEvent = (NPCocoaEvent*)event;
40772:   if (!cocoaEvent)
41955:     return kNPEventNotHandled;
40772: 
40772:   switch (cocoaEvent->type) {
40772:     case NPCocoaEventDrawRect:
40772:       pluginDraw(instanceData, cocoaEvent);
41955:       break;
40772:     case NPCocoaEventMouseDown:
40772:     case NPCocoaEventMouseUp:
40772:     case NPCocoaEventMouseMoved:
40772:       instanceData->lastMouseX = (int32_t)cocoaEvent->data.mouse.pluginX;
40772:       instanceData->lastMouseY = (int32_t)cocoaEvent->data.mouse.pluginY;
41955:       break;
41061:     case NPCocoaEventWindowFocusChanged:
41061:       instanceData->topLevelWindowActivationState = cocoaEvent->data.focus.hasFocus ?
41061:         ACTIVATION_STATE_ACTIVATED : ACTIVATION_STATE_DEACTIVATED;
41061:       instanceData->topLevelWindowActivationEventCount = instanceData->topLevelWindowActivationEventCount + 1;
41955:       break;
41321:     case NPCocoaEventFocusChanged:
41321:       instanceData->focusState = cocoaEvent->data.focus.hasFocus ?
41321:       ACTIVATION_STATE_ACTIVATED : ACTIVATION_STATE_DEACTIVATED;
41321:       instanceData->focusEventCount = instanceData->focusEventCount + 1;
41955:       break;
40772:     default:
41955:       return kNPEventNotHandled;
40772:   }
40772: 
41955:   return kNPEventHandled;
26802: }
26942: 
26942: int32_t pluginGetEdge(InstanceData* instanceData, RectEdge edge)
26942: {
26942:   NPWindow* w = &instanceData->window;
26942:   switch (edge) {
26942:   case EDGE_LEFT:
26942:     return w->x;
26942:   case EDGE_TOP:
26942:     return w->y;
26942:   case EDGE_RIGHT:
26942:     return w->x + w->width;
26942:   case EDGE_BOTTOM:
26942:     return w->y + w->height;
26942:   }
26942:   return NPTEST_INT32_ERROR;
26942: }
26942: 
26942: int32_t pluginGetClipRegionRectCount(InstanceData* instanceData)
26942: {
26942:   return 1;
26942: }
26942: 
26942: int32_t pluginGetClipRegionRectEdge(InstanceData* instanceData, 
26942:     int32_t rectIndex, RectEdge edge)
26942: {
26942:   if (rectIndex != 0)
26942:     return NPTEST_INT32_ERROR;
26942: 
26942:   // We have to add the Cocoa titlebar height here since the clip rect
26942:   // is being returned relative to that
26942:   static const int COCOA_TITLEBAR_HEIGHT = 22;
26942: 
26942:   NPWindow* w = &instanceData->window;
26942:   switch (edge) {
26942:   case EDGE_LEFT:
26942:     return w->clipRect.left;
26942:   case EDGE_TOP:
26942:     return w->clipRect.top + COCOA_TITLEBAR_HEIGHT;
26942:   case EDGE_RIGHT:
26942:     return w->clipRect.right;
26942:   case EDGE_BOTTOM:
26942:     return w->clipRect.bottom + COCOA_TITLEBAR_HEIGHT;
26942:   }
26942:   return NPTEST_INT32_ERROR;
26942: }
33358: 
33358: void pluginDoInternalConsistencyCheck(InstanceData* instanceData, string& error)
33358: {
33358: }
