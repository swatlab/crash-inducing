 83577: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 83577: 
 83577: package org.mozilla.gecko;
 83577: 
107696: import org.mozilla.gecko.util.GeckoEventResponder;
114270: import org.mozilla.gecko.widget.DateTimePicker;
107125: 
107125: import org.json.JSONArray;
107125: import org.json.JSONObject;
107125: 
 83577: import android.app.AlertDialog;
 83664: import android.content.Context;
 83577: import android.content.DialogInterface;
107125: import android.content.DialogInterface.OnCancelListener;
 88111: import android.content.DialogInterface.OnClickListener;
 88111: import android.content.res.Resources;
 93495: import android.graphics.Bitmap;
 93495: import android.graphics.drawable.BitmapDrawable;
 93495: import android.graphics.drawable.Drawable;
 88111: import android.text.InputType;
129619: import android.text.TextUtils;
120987: import android.text.format.DateFormat;
107125: import android.util.Log;
116169: import android.view.inputmethod.InputMethodManager;
107125: import android.view.LayoutInflater;
 83577: import android.view.View;
 83664: import android.view.ViewGroup;
 83622: import android.view.ViewGroup.LayoutParams;
 83664: import android.widget.AdapterView;
 83664: import android.widget.AdapterView.OnItemClickListener;
107125: import android.widget.ArrayAdapter;
 83577: import android.widget.CheckBox;
 83664: import android.widget.CheckedTextView;
114270: import android.widget.DatePicker;
 83577: import android.widget.EditText;
 83577: import android.widget.LinearLayout;
107125: import android.widget.ListView;
130454: import android.widget.ScrollView;
 83577: import android.widget.Spinner;
107125: import android.widget.TextView;
114270: import android.widget.TimePicker;
107125: 
114270: import java.text.SimpleDateFormat;
107125: import java.util.concurrent.SynchronousQueue;
107125: import java.util.concurrent.TimeUnit;
114270: import java.util.Calendar;
114270: import java.util.GregorianCalendar;
 83577: 
105609: public class PromptService implements OnClickListener, OnCancelListener, OnItemClickListener, GeckoEventResponder {
 83868:     private static final String LOGTAG = "GeckoPromptService";
 83868: 
129618:     private static LayoutInflater sInflater;
129618:     private static SynchronousQueue<String> sPromptQueue = new SynchronousQueue<String>();
129618: 
114270:     private String[] mButtons;
 83577:     private PromptInput[] mInputs;
129618:     private boolean[] mSelected;
111357:     private AlertDialog mDialog;
 93495: 
129618:     private final int mGroupPaddingSize;
129618:     private final int mLeftRightTextWithIconPadding;
129618:     private final int mTopBottomTextWithIconPadding;
129618:     private final int mIconTextPadding;
129618:     private final int mIconSize;
130454:     private final int mInputPaddingSize;
 84315: 
 84315:     PromptService() {
129618:         sInflater = LayoutInflater.from(GeckoApp.mAppContext);
106807: 
 88111:         Resources res = GeckoApp.mAppContext.getResources();
106807:         mGroupPaddingSize = (int) (res.getDimension(R.dimen.prompt_service_group_padding_size));
106807:         mLeftRightTextWithIconPadding = (int) (res.getDimension(R.dimen.prompt_service_left_right_text_with_icon_padding));
106807:         mTopBottomTextWithIconPadding = (int) (res.getDimension(R.dimen.prompt_service_top_bottom_text_with_icon_padding));
106807:         mIconTextPadding = (int) (res.getDimension(R.dimen.prompt_service_icon_text_padding));
106807:         mIconSize = (int) (res.getDimension(R.dimen.prompt_service_icon_size));
130454:         mInputPaddingSize = (int) (res.getDimension(R.dimen.prompt_service_inputs_padding));
101921: 
108130:         GeckoAppShell.getEventDispatcher().registerEventListener("Prompt:Show", this);
 84315:     }
 83577: 
104477:     void destroy() {
108130:         GeckoAppShell.getEventDispatcher().unregisterEventListener("Prompt:Show", this);
104477:     }
104477: 
114270:     private static String formatDateString(String dateFormat, Calendar calendar) {
114270:         return new SimpleDateFormat(dateFormat).format(calendar.getTime());
114270:     }
114270: 
105609:     private class PromptInput {
129618:         private final JSONObject mJSONInput;
129618: 
129618:         private final String mLabel;
129618:         private final String mType;
129620:         private final String mId;
129618:         private final String mHint;
129618:         private final boolean mAutofocus;
129618:         private final String mValue;
129618: 
129618:         private View mView;
 83577: 
 83577:         public PromptInput(JSONObject aJSONInput) {
 83577:             mJSONInput = aJSONInput;
129618:             mLabel = getSafeString(aJSONInput, "label");
129618:             mType = getSafeString(aJSONInput, "type");
129620:             String id = getSafeString(aJSONInput, "id");
129620:             mId = TextUtils.isEmpty(id) ? mType : id;
129618:             mHint = getSafeString(aJSONInput, "hint");
129618:             mValue = getSafeString(aJSONInput, "value");
129618:             mAutofocus = getSafeBool(aJSONInput, "autofocus");
 83577:         }
 83577: 
114270:         public View getView() throws UnsupportedOperationException {
129618:             if (mType.equals("checkbox")) {
 83622:                 CheckBox checkbox = new CheckBox(GeckoApp.mAppContext);
 83622:                 checkbox.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));
129618:                 checkbox.setText(mLabel);
129617:                 checkbox.setChecked(getSafeBool(mJSONInput, "checked"));
129618:                 mView = (View)checkbox;
129618:             } else if (mType.equals("date")) {
114270:                 try {
129618:                     DateTimePicker input = new DateTimePicker(GeckoApp.mAppContext, "yyyy-MM-dd", mValue,
114270:                                                               DateTimePicker.pickersState.DATE);
114270:                     input.toggleCalendar(true);
129618:                     mView = (View)input;
114270:                 } catch (UnsupportedOperationException ex) {
114270:                     // We can't use our custom version of the DatePicker widget because the sdk is too old.
114270:                     // But we can fallback on the native one.
114270:                     DatePicker input = new DatePicker(GeckoApp.mAppContext);
114270:                     try {
129619:                         if (!TextUtils.isEmpty(mValue)) {
114270:                             GregorianCalendar calendar = new GregorianCalendar();
129618:                             calendar.setTime(new SimpleDateFormat("yyyy-MM-dd").parse(mValue));
114270:                             input.updateDate(calendar.get(Calendar.YEAR),
114270:                                              calendar.get(Calendar.MONTH),
114270:                                              calendar.get(Calendar.DAY_OF_MONTH));
114270:                         }
114270:                     } catch (Exception e) {
114270:                         Log.e(LOGTAG, "error parsing format string: " + e);
114270:                     }
129618:                     mView = (View)input;
114270:                 }
129618:             } else if (mType.equals("week")) {
129618:                 DateTimePicker input = new DateTimePicker(GeckoApp.mAppContext, "yyyy-'W'ww", mValue,
114270:                                                           DateTimePicker.pickersState.WEEK);
129618:                 mView = (View)input;
129618:             } else if (mType.equals("time")) {
114270:                 TimePicker input = new TimePicker(GeckoApp.mAppContext);
120987:                 input.setIs24HourView(DateFormat.is24HourFormat(GeckoApp.mAppContext));
128961: 
128961:                 GregorianCalendar calendar = new GregorianCalendar();
129619:                 if (!TextUtils.isEmpty(mValue)) {
114270:                     try {
129618:                         calendar.setTime(new SimpleDateFormat("kk:mm").parse(mValue));
128961:                     } catch (Exception e) { }
128961:                 }
114270:                 input.setCurrentHour(calendar.get(GregorianCalendar.HOUR_OF_DAY));
114270:                 input.setCurrentMinute(calendar.get(GregorianCalendar.MINUTE));
129618:                 mView = (View)input;
129618:             } else if (mType.equals("datetime-local") || mType.equals("datetime")) {
129618:                 DateTimePicker input = new DateTimePicker(GeckoApp.mAppContext, "yyyy-MM-dd kk:mm", mValue,
114270:                                                           DateTimePicker.pickersState.DATETIME);
114270:                 input.toggleCalendar(true);
129618:                 mView = (View)input;
129618:             } else if (mType.equals("month")) {
129618:                 DateTimePicker input = new DateTimePicker(GeckoApp.mAppContext, "yyyy-MM", mValue,
114270:                                                           DateTimePicker.pickersState.MONTH);
129618:                 mView = (View)input;
129618:             } else if (mType.equals("textbox") || mType.equals("password")) {
 83577:                 EditText input = new EditText(GeckoApp.mAppContext);
 83577:                 int inputtype = InputType.TYPE_CLASS_TEXT;
129618:                 if (mType.equals("password")) {
 83577:                     inputtype |= InputType.TYPE_TEXT_VARIATION_PASSWORD | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
 83577:                 }
 83577:                 input.setInputType(inputtype);
129618:                 input.setText(mValue);
 83577: 
129619:                 if (!TextUtils.isEmpty(mHint)) {
129618:                     input.setHint(mHint);
 83577:                 }
116169: 
129618:                 if (mAutofocus) {
116169:                     input.setOnFocusChangeListener(new View.OnFocusChangeListener() {
116169:                         public void onFocusChange(View v, boolean hasFocus) {
116169:                             if (hasFocus) {
116169:                                 ((InputMethodManager) GeckoApp.mAppContext.getSystemService(Context.INPUT_METHOD_SERVICE)).showSoftInput(v, 0);
116169:                             }
116169:                         }
116169:                     });
116169:                     input.requestFocus();
116169:                 }
116169: 
129618:                 mView = (View)input;
129618:             } else if (mType.equals("menulist")) {
 83577:                 Spinner spinner = new Spinner(GeckoApp.mAppContext);
 83577:                 try {
 83577:                     String[] listitems = getStringArray(mJSONInput, "values");
 83577:                     if (listitems.length > 0) {
 83577:                         ArrayAdapter<String> adapter = new ArrayAdapter<String>(GeckoApp.mAppContext, android.R.layout.simple_dropdown_item_1line, listitems);
 83577:                         spinner.setAdapter(adapter);
 83577:                     }
 83577:                 } catch(Exception ex) { }
129618:                 mView = (View)spinner;
 83577:             }
129618:             return mView;
 83577:         }
 83577: 
129620:         public String getId() {
129620:             return mId;
 83577:         }
 83577: 
 83577:         public String getValue() {
129618:             if (mType.equals("checkbox")) {
129618:                 CheckBox checkbox = (CheckBox)mView;
 83577:                 return checkbox.isChecked() ? "true" : "false";
129618:             } else if (mType.equals("textbox") || mType.equals("password")) {
129618:                 EditText edit = (EditText)mView;
 83577:                 return edit.getText().toString();
129618:             } else if (mType.equals("menulist")) {
129618:                 Spinner spinner = (Spinner)mView;
 83577:                 return Integer.toString(spinner.getSelectedItemPosition());
129618:             } else if (mType.equals("time")) {
129618:                 TimePicker tp = (TimePicker)mView;
114270:                 GregorianCalendar calendar =
114270:                     new GregorianCalendar(0,0,0,tp.getCurrentHour(),tp.getCurrentMinute());
114270:                 return formatDateString("kk:mm",calendar);
129618:             } else if (android.os.Build.VERSION.SDK_INT < 11 && mType.equals("date")) {
114270:                 // We can't use the custom DateTimePicker with a sdk older than 11.
114270:                 // Fallback on the native DatePicker.
129618:                 DatePicker dp = (DatePicker)mView;
114270:                 GregorianCalendar calendar =
114270:                     new GregorianCalendar(dp.getYear(),dp.getMonth(),dp.getDayOfMonth());
114270:                 return formatDateString("yyyy-MM-dd",calendar);
114270:             } else {
129618:                 DateTimePicker dp = (DateTimePicker)mView;
114270:                 GregorianCalendar calendar = new GregorianCalendar();
114270:                 calendar.setTimeInMillis(dp.getTimeInMillis());
129618:                 if (mType.equals("date")) {
114270:                     return formatDateString("yyyy-MM-dd",calendar);
129618:                 } else if (mType.equals("week")) {
114270:                     return formatDateString("yyyy-'W'ww",calendar);
129618:                 } else if (mType.equals("datetime-local")) {
114270:                     return formatDateString("yyyy-MM-dd kk:mm",calendar);
129618:                 } else if (mType.equals("datetime")) {
114270:                     calendar.set(GregorianCalendar.ZONE_OFFSET,0);
114270:                     calendar.setTimeInMillis(dp.getTimeInMillis());
114270:                     return formatDateString("yyyy-MM-dd kk:mm",calendar);
129618:                 } else if (mType.equals("month")) {
114270:                     return formatDateString("yyyy-MM",calendar);
114270:                 }
 83577:             }
 83577:             return "";
 83577:         }
 83577:     }
 83577: 
101921:     // GeckoEventListener implementation
101921:     public void handleMessage(String event, final JSONObject message) {
114191:         // The dialog must be created on the UI thread.
114191:         GeckoAppShell.getMainHandler().post(new Runnable() {
101921:             public void run() {
101921:                 processMessage(message);
101921:             }
101921:         });
101921:     }
101921: 
101921:     // GeckoEventResponder implementation
101921:     public String getResponse() {
101921:         // we only handle one kind of message in handleMessage, and this is the
101921:         // response we provide for that message
101921:         String promptServiceResult = "";
101921:         try {
101921:             promptServiceResult = waitForReturn();
114270:         } catch (InterruptedException e) { }
101921:         return promptServiceResult;
101921:     }
101921: 
130454:     private View applyInputStyle(View view) {
130454:         view.setPadding(mInputPaddingSize, 0, mInputPaddingSize, 0);
130454:         return view;
130454:     }
130454: 
114270:     public void show(String aTitle, String aText, PromptListItem[] aMenuList, boolean aMultipleSelection) {
114191:         GeckoApp.assertOnUiThread();
114191: 
105725:         // treat actions that show a dialog as if preventDefault by content to prevent panning
129619:         GeckoApp.mAppContext.getLayerView().abortPanning();
105725: 
129619:         AlertDialog.Builder builder = new AlertDialog.Builder(GeckoApp.mAppContext);
129619:         if (!TextUtils.isEmpty(aTitle)) {
 83577:             builder.setTitle(aTitle);
 83577:         }
 83577: 
129619:         if (!TextUtils.isEmpty(aText)) {
 83577:             builder.setMessage(aText);
 83577:         }
 83577: 
 93495:         int length = mInputs == null ? 0 : mInputs.length;
 93495:         if (aMenuList != null && aMenuList.length > 0) {
129117:             int resourceId = android.R.layout.simple_list_item_1;
 83710:             if (mSelected != null && mSelected.length > 0) {
 83664:                 if (aMultipleSelection) {
115849:                     resourceId = R.layout.select_dialog_multichoice;
 83664:                 } else {
 83664:                     resourceId = android.R.layout.select_dialog_singlechoice;
 83664:                 }
 83664:             }
 83664:             PromptListAdapter adapter = new PromptListAdapter(GeckoApp.mAppContext, resourceId, aMenuList);
 83710:             if (mSelected != null && mSelected.length > 0) {
 83664:                 if (aMultipleSelection) {
129618:                     adapter.listView = (ListView) sInflater.inflate(R.layout.select_dialog_list, null);
 83664:                     adapter.listView.setOnItemClickListener(this);
 83664:                     builder.setInverseBackgroundForced(true);
 83664:                     adapter.listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
 83664:                     adapter.listView.setAdapter(adapter);
 83664:                     builder.setView(adapter.listView);
 83664:                 } else {
 83664:                     int selectedIndex = -1;
 83664:                     for (int i = 0; i < mSelected.length; i++) {
 83664:                         if (mSelected[i]) {
 83664:                             selectedIndex = i;
 83664:                             break;
 83664:                         }
 83664:                     }
 83664:                     mSelected = null;
 83664:                     builder.setSingleChoiceItems(adapter, selectedIndex, this);
 83664:                 }
 83664:             } else {
 83664:                 builder.setAdapter(adapter, this);
 83710:                 mSelected = null;
 83664:             }
 83664:         } else if (length == 1) {
114270:             try {
130454:                 builder.setView(applyInputStyle(mInputs[0].getView()));
114270:             } catch(UnsupportedOperationException ex) {
114270:                 // We cannot display these input widgets with this sdk version,
114270:                 // do not display any dialog and finish the prompt now.
114270:                 finishDialog("{\"button\": -1}");
114270:                 return;
114270:             }
 83577:         } else if (length > 1) {
 83577:             LinearLayout linearLayout = new LinearLayout(GeckoApp.mAppContext);
 83577:             linearLayout.setOrientation(LinearLayout.VERTICAL);
114270:             try {
 83577:                 for (int i = 0; i < length; i++) {
 83577:                     View content = mInputs[i].getView();
 83577:                     linearLayout.addView(content);
 83577:                 }
114270:             } catch(UnsupportedOperationException ex) {
114270:                 // We cannot display these input widgets with this sdk version,
114270:                 // do not display any dialog and finish the prompt now.
114270:                 finishDialog("{\"button\": -1}");
114270:                 return;
114270:             }
130454:             ScrollView view = new ScrollView(GeckoApp.mAppContext);
130454:             view.addView(linearLayout);
130454:             builder.setView(applyInputStyle(view));
 83577:         }
 83577: 
114270:         length = mButtons == null ? 0 : mButtons.length;
 83577:         if (length > 0) {
114272:             builder.setPositiveButton(mButtons[0], this);
 83577:             if (length > 1) {
114272:                 builder.setNeutralButton(mButtons[1], this);
 83577:                 if (length > 2) {
114272:                     builder.setNegativeButton(mButtons[2], this);
 83577:                 }
111358:             }
111358:         }
 83577: 
 83577:         mDialog = builder.create();
111106:         mDialog.setOnCancelListener(PromptService.this);
 83577:         mDialog.show();
 83577:     }
 83577: 
 83577:     public void onClick(DialogInterface aDialog, int aWhich) {
111357:         GeckoApp.assertOnUiThread();
 83577:         JSONObject ret = new JSONObject();
 83577:         try {
 83577:             int button = -1;
 83664:             ListView list = mDialog.getListView();
 83664:             if (list != null || mSelected != null) {
 83577:                 button = aWhich;
 83664:                 if (mSelected != null) {
 83664:                     JSONArray selected = new JSONArray();
 83664:                     for (int i = 0; i < mSelected.length; i++) {
 83664:                         selected.put(mSelected[i]);
 83664:                     }
 83664:                     ret.put("button", selected);
 83664:                 } else {
 83664:                     ret.put("button", button);
 83664:                 }
 83577:             } else {
 83577:                 switch(aWhich) {
 83577:                     case DialogInterface.BUTTON_POSITIVE : button = 0; break;
 83577:                     case DialogInterface.BUTTON_NEUTRAL  : button = 1; break;
 83577:                     case DialogInterface.BUTTON_NEGATIVE : button = 2; break;
 83577:                 }
 83664:                 ret.put("button", button);
 83577:             }
 83577:             if (mInputs != null) {
 83577:                 for (int i = 0; i < mInputs.length; i++) {
129620:                     ret.put(mInputs[i].getId(), mInputs[i].getValue());
 83577:                 }
 83577:             }
 83577:         } catch(Exception ex) {
 83868:             Log.i(LOGTAG, "Error building return: " + ex);
 83577:         }
 83664: 
 83664:         if (mDialog != null) {
 83664:             mDialog.dismiss();
 83664:         }
 83664: 
 83577:         finishDialog(ret.toString());
 83577:     }
 83577: 
 83664:     public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
111357:         GeckoApp.assertOnUiThread();
 83664:         mSelected[position] = !mSelected[position];
 83664:     }
 83664: 
 83577:     public void onCancel(DialogInterface aDialog) {
111357:         GeckoApp.assertOnUiThread();
 83688:         JSONObject ret = new JSONObject();
 83688:         try {
 83688:             ret.put("button", -1);
 83688:         } catch(Exception ex) { }
 83688:         finishDialog(ret.toString());
 83577:     }
 83577: 
129618:     public static String waitForReturn() throws InterruptedException {
 93495:         String value;
 93495: 
129618:         while (null == (value = sPromptQueue.poll(1, TimeUnit.MILLISECONDS))) {
 93495:             GeckoAppShell.processNextNativeEvent();
 93495:         }
 93495: 
 93495:         return value;
 93495:     }
 93495: 
 83577:     public void finishDialog(String aReturn) {
 83577:         mInputs = null;
114270:         mButtons = null;
 83577:         mDialog = null;
 83664:         mSelected = null;
 83577:         try {
129618:             sPromptQueue.put(aReturn);
114270:         } catch(Exception ex) {
129618:             Log.d(LOGTAG, "sPromptQueue not ready yet");
114270:         }
 83577:     }
 83577: 
101921:     private void processMessage(JSONObject geckoObject) {
129617:         String title = getSafeString(geckoObject, "title");
129617:         String text = getSafeString(geckoObject, "text");
 83577: 
129616:         mButtons = getStringArray(geckoObject, "buttons");
 83577: 
129617:         JSONArray inputs = getSafeArray(geckoObject, "inputs");
129617:         mInputs = new PromptInput[inputs.length()];
129617:         for (int i = 0; i < mInputs.length; i++) {
 83577:             try {
 83577:                 mInputs[i] = new PromptInput(inputs.getJSONObject(i));
 83577:             } catch(Exception ex) { }
 83577:         }
 83577: 
 83664:         PromptListItem[] menuitems = getListItemArray(geckoObject, "listitems");
 83664:         mSelected = getBooleanArray(geckoObject, "selected");
129617:         boolean multiple = getSafeBool(geckoObject, "multiple");
114270:         show(title, text, menuitems, multiple);
 83577:     }
 83577: 
129617:     private static String getSafeString(JSONObject json, String key) {
129617:         try {
129617:             return json.getString(key);
129617:         } catch (Exception e) {
129617:             return "";
129617:         }
129617:     }
129617: 
129617:     private static JSONArray getSafeArray(JSONObject json, String key) {
129617:         try {
129617:             return json.getJSONArray(key);
129617:         } catch (Exception e) {
129617:             return new JSONArray();
129617:         }
129617:     }
129617: 
129617:     private static boolean getSafeBool(JSONObject json, String key) {
129617:         try {
129617:             return json.getBoolean(key);
129617:         } catch (Exception e) {
129617:             return false;
129617:         }
129617:     }
129617: 
129617:     private static int getSafeInt(JSONObject json, String key ) {
129617:         try {
129617:             return json.getInt(key);
129617:         } catch (Exception e) {
129617:             return 0;
129617:         }
129617:     }
129617: 
 83577:     private String[] getStringArray(JSONObject aObject, String aName) {
129617:         JSONArray items = getSafeArray(aObject, aName);
 83577:         int length = items.length();
 83577:         String[] list = new String[length];
 83577:         for (int i = 0; i < length; i++) {
 83577:             try {
 83577:                 list[i] = items.getString(i);
 83577:             } catch(Exception ex) { }
 83577:         }
 83577:         return list;
 83577:     }
 83664: 
 83664:     private boolean[] getBooleanArray(JSONObject aObject, String aName) {
 83664:         JSONArray items = new JSONArray();
 83664:         try {
 83664:             items = aObject.getJSONArray(aName);
 83688:         } catch(Exception ex) { return null; }
 83664:         int length = items.length();
 83664:         boolean[] list = new boolean[length];
 83664:         for (int i = 0; i < length; i++) {
 83664:             try {
 83664:                 list[i] = items.getBoolean(i);
 83664:             } catch(Exception ex) { }
 83577:         }
 83664:         return list;
 83664:     }
 83664: 
 83664:     private PromptListItem[] getListItemArray(JSONObject aObject, String aName) {
129617:         JSONArray items = getSafeArray(aObject, aName);
 83664:         int length = items.length();
 83664:         PromptListItem[] list = new PromptListItem[length];
 83664:         for (int i = 0; i < length; i++) {
 83664:             try {
 83664:                 list[i] = new PromptListItem(items.getJSONObject(i));
 83664:             } catch(Exception ex) { }
 83664:         }
 83664:         return list;
 83664:     }
 83664: 
129618:     public static class PromptListItem {
129618:         public final String label;
129618:         public final boolean isGroup;
129618:         public final boolean inGroup;
129618:         public final boolean disabled;
129618:         public final int id;
129618:         public final boolean isParent;
 93495: 
 93495:         // This member can't be accessible from JS, see bug 733749.
129618:         public Drawable icon;
 93495: 
 83664:         PromptListItem(JSONObject aObject) {
129617:             label = getSafeString(aObject, "label");
129617:             isGroup = getSafeBool(aObject, "isGroup");
129617:             inGroup = getSafeBool(aObject, "inGroup");
129617:             disabled = getSafeBool(aObject, "disabled");
129617:             id = getSafeInt(aObject, "id");
129617:             isParent = getSafeBool(aObject, "isParent");
 83664:         }
 93495: 
 93495:         public PromptListItem(String aLabel) {
 93495:             label = aLabel;
129618:             isGroup = false;
129618:             inGroup = false;
129618:             disabled = false;
129618:             id = 0;
129618:             isParent = false;
 93495:         }
 83664:     }
 83664: 
105609:     public class PromptListAdapter extends ArrayAdapter<PromptListItem> {
 94475:         private static final int VIEW_TYPE_ITEM = 0;
 94475:         private static final int VIEW_TYPE_GROUP = 1;
 94475:         private static final int VIEW_TYPE_COUNT = 2;
 94475: 
129618:         public ListView listView;
 83664:         private int mResourceId = -1;
129618: 
 83664:         PromptListAdapter(Context context, int textViewResourceId, PromptListItem[] objects) {
 83664:             super(context, textViewResourceId, objects);
 83664:             mResourceId = textViewResourceId;
 83664:         }
 83664: 
 94475:         @Override
 94475:         public int getItemViewType(int position) {
 94475:             PromptListItem item = getItem(position);
 94475:             return (item.isGroup ? VIEW_TYPE_GROUP : VIEW_TYPE_ITEM);
 94475:         }
 94475: 
 94475:         @Override
 94475:         public int getViewTypeCount() {
 94475:             return VIEW_TYPE_COUNT;
 94475:         }
 94475: 
 94476:         private void maybeUpdateIcon(PromptListItem item, TextView t) {
127520:             if (item.icon == null && !item.isParent) {
127520:                 t.setCompoundDrawablesWithIntrinsicBounds(null, null, null, null);
 94476:                 return;
127520:             }
 94476: 
127520:             Drawable d = null;
 94476:             Resources res = GeckoApp.mAppContext.getResources();
127520:             // Set the padding between the icon and the text.
127520:             t.setCompoundDrawablePadding(mIconTextPadding);
127520:             if (item.icon != null) {
 94476:                 // Set padding inside the item.
 94476:                 t.setPadding(item.inGroup ? mLeftRightTextWithIconPadding + mGroupPaddingSize :
 94476:                                             mLeftRightTextWithIconPadding,
 94476:                              mTopBottomTextWithIconPadding,
 94476:                              mLeftRightTextWithIconPadding,
 94476:                              mTopBottomTextWithIconPadding);
 94476:                 // We want the icon to be of a specific size. Some do not
 94476:                 // follow this rule so we have to resize them.
 94476:                 Bitmap bitmap = ((BitmapDrawable) item.icon).getBitmap();
127520:                 d = new BitmapDrawable(Bitmap.createScaledBitmap(bitmap, mIconSize, mIconSize, true));
127520:             }
 94476: 
127520:             Drawable moreDrawable = null;
127520:             if (item.isParent) {
127520:                 moreDrawable = res.getDrawable(android.R.drawable.ic_menu_more);
127520:             }
127520: 
127520:             if (d != null || moreDrawable != null) {
127520:                 t.setCompoundDrawablesWithIntrinsicBounds(d, null, moreDrawable, null);
127520:             }
 94476:         }
 94476: 
 94477:         private void maybeUpdateCheckedState(int position, PromptListItem item, ViewHolder viewHolder) {
127520:             viewHolder.textView.setPadding((item.inGroup ? mGroupPaddingSize : viewHolder.paddingLeft),
127520:                                             viewHolder.paddingTop,
127520:                                             viewHolder.paddingRight,
127520:                                             viewHolder.paddingBottom);
127520: 
127520:             viewHolder.textView.setEnabled(!item.disabled && !item.isGroup);
127520:             viewHolder.textView.setClickable(item.isGroup || item.disabled);
127520: 
127520:             if (mSelected == null)
 94477:                 return;
 94477: 
 94477:             CheckedTextView ct;
 94477:             try {
 94477:                 ct = (CheckedTextView) viewHolder.textView;
 94477:                 // Apparently just using ct.setChecked(true) doesn't work, so this
 94477:                 // is stolen from the android source code as a way to set the checked
 94477:                 // state of these items
 94477:                 if (listView != null)
 94477:                     listView.setItemChecked(position, mSelected[position]);
127520:             } catch (Exception e) {
127520:                 return;
127520:             }
 94477: 
 94477:         }
 94477: 
106672:         @Override
 83664:         public View getView(int position, View convertView, ViewGroup parent) {
 83664:             PromptListItem item = getItem(position);
 94475:             ViewHolder viewHolder = null;
 94475: 
 94475:             if (convertView == null) {
 83664:                 int resourceId = mResourceId;
 83664:                 if (item.isGroup) {
 83664:                     resourceId = R.layout.list_item_header;
 83664:                 }
 94475: 
129618:                 convertView = sInflater.inflate(resourceId, null);
 94475: 
129618:                 TextView tv = (TextView) convertView.findViewById(android.R.id.text1);
129618:                 viewHolder = new ViewHolder(tv, tv.getPaddingLeft(), tv.getPaddingRight(),
129618:                                             tv.getPaddingTop(), tv.getPaddingBottom());
 94475: 
 94475:                 convertView.setTag(viewHolder);
 94475:             } else {
 94475:                 viewHolder = (ViewHolder) convertView.getTag();
 94475:             }
 94475: 
 94476:             viewHolder.textView.setText(item.label);
 94477:             maybeUpdateCheckedState(position, item, viewHolder);
 94476:             maybeUpdateIcon(item, viewHolder.textView);
 83664: 
 94475:             return convertView;
 83664:         }
 94475: 
105609:         private class ViewHolder {
129618:             public final TextView textView;
129618:             public final int paddingLeft;
129618:             public final int paddingRight;
129618:             public final int paddingTop;
129618:             public final int paddingBottom;
129618: 
129618:             ViewHolder(TextView aTextView, int aLeft, int aRight, int aTop, int aBottom) {
129618:                 textView = aTextView;
129618:                 paddingLeft = aLeft;
129618:                 paddingRight = aRight;
129618:                 paddingTop = aTop;
129618:                 paddingBottom = aBottom;
 83664:             }
 83664:         }
 94475:     }
129618: }
