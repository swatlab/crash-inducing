111706: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
111706:  * vim: set ts=4 sw=4 et tw=79:
111706:  *
111706:  * ***** BEGIN LICENSE BLOCK *****
111706:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
111706:  *
111706:  * The contents of this file are subject to the Mozilla Public License Version
111706:  * 1.1 (the "License"); you may not use this file except in compliance with
111706:  * the License. You may obtain a copy of the License at
111706:  * http://www.mozilla.org/MPL/
111706:  *
111706:  * Software distributed under the License is distributed on an "AS IS" basis,
111706:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
111706:  * for the specific language governing rights and limitations under the
111706:  * License.
111706:  *
111706:  * The Original Code is Mozilla Communicator client code, released
111706:  * March 31, 1998.
111706:  *
111706:  * The Initial Developer of the Original Code is
111706:  * Netscape Communications Corporation.
111706:  * Portions created by the Initial Developer are Copyright (C) 1998
111706:  * the Initial Developer. All Rights Reserved.
111706:  *
111706:  * Contributor(s):
111706:  *   David Anderson <danderson@mozilla.com>
111706:  *
111706:  * Alternatively, the contents of this file may be used under the terms of
111706:  * either of the GNU General Public License Version 2 or later (the "GPL"),
111706:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
111706:  * in which case the provisions of the GPL or the LGPL are applicable instead
111706:  * of those above. If you wish to allow use of your version of this file only
111706:  * under the terms of either the GPL or the LGPL, and not to allow others to
111706:  * use your version of this file under the terms of the MPL, indicate your
111706:  * decision by deleting the provisions above and replace them with the notice
111706:  * and other provisions required by the GPL or the LGPL. If you do not delete
111706:  * the provisions above, a recipient may use your version of this file under
111706:  * the terms of any one of the MPL, the GPL or the LGPL.
111706:  *
111706:  * ***** END LICENSE BLOCK ***** */
111706: 
111706: #include "ion/MIR.h"
111706: #include "Lowering-x64.h"
111768: #include "Assembler-x64.h"
111962: #include "ion/shared/Lowering-shared-inl.h"
111706: 
111706: using namespace js;
111706: using namespace js::ion;
111706: 
111706: bool
111795: LIRGeneratorX64::fillBoxUses(LInstruction *lir, size_t n, MDefinition *mir)
111721: {
111721:     lir->setOperand(n, useRegister(mir));
111721:     return true;
111721: }
111721: 
111721: bool
111706: LIRGeneratorX64::visitConstant(MConstant *ins)
111706: {
111838:     if (!ins->isEmittedAtUses())
111706:         return emitAtUses(ins);
111706: 
111962:     if (ins->type() == MIRType_Double) {
111962:         LDouble *lir = new LDouble(ins->value().toDouble(), temp(LDefinition::DOUBLE));
111962:         return define(lir, ins);
111962:     }
111962: 
111962:     return LIRGeneratorShared::visitConstant(ins);
111706: }
111706: 
111706: bool
111706: LIRGeneratorX64::visitBox(MBox *box)
111706: {
111795:     MDefinition *opd = box->getOperand(0);
111706: 
111706:     // If the operand is a constant, emit near its uses.
111838:     if (opd->isConstant() && !box->isEmittedAtUses())
111706:         return emitAtUses(box);
111706: 
111768:     if (opd->isConstant())
111768:         return define(new LValue(opd->toConstant()->value()), box, LDefinition(LDefinition::BOX));
111768: 
111768:     LBox *ins = new LBox(opd->type(), useRegister(opd));
111706:     return define(ins, box, LDefinition(LDefinition::BOX));
111706: }
111706: 
111706: bool
111707: LIRGeneratorX64::visitUnbox(MUnbox *unbox)
111707: {
111795:     MDefinition *box = unbox->getOperand(0);
111707: 
111710:     switch (unbox->type()) {
111707:       // Integers, booleans, and strings both need two outputs: the payload
111707:       // and the type, the type of which is temporary and thrown away.
111711:       case MIRType_Boolean: {
111711:         LUnboxBoolean *ins = new LUnboxBoolean(useRegister(box), temp(LDefinition::INTEGER));
111711:         return define(ins, unbox) && assignSnapshot(ins);
111711:       }
111711:       case MIRType_Int32: {
111769:         LUnboxInteger *ins = new LUnboxInteger(useRegister(box));
111711:         return define(ins, unbox) && assignSnapshot(ins);
111711:       }
111711:       case MIRType_String: {
111711:         LUnboxString *ins = new LUnboxString(useRegister(box), temp(LDefinition::INTEGER));
111711:         return define(ins, unbox) && assignSnapshot(ins);
111711:       }
111711:       case MIRType_Object: {
111707:         // Objects don't need a temporary.
111732:         LDefinition out(LDefinition::POINTER);
111711:         LUnboxObject *ins = new LUnboxObject(useRegister(box));
111711:         return define(ins, unbox, out) && assignSnapshot(ins);
111707:       }
111711:       case MIRType_Double: {
111707:         // Doubles don't need a temporary.
111920:         LUnboxDouble *ins = new LUnboxDouble(useRegister(box), temp(LDefinition::INTEGER));
111711:         return define(ins, unbox) && assignSnapshot(ins);
111707:       }
111707:       default:
111707:         JS_NOT_REACHED("cannot unbox a value with no payload");
111707:     }
111707: 
111707:     return false;
111707: }
111707: 
111707: bool
111706: LIRGeneratorX64::visitReturn(MReturn *ret)
111706: {
111795:     MDefinition *opd = ret->getOperand(0);
111706:     JS_ASSERT(opd->type() == MIRType_Value);
111706: 
111706:     LReturn *ins = new LReturn;
111706:     ins->setOperand(0, useFixed(opd, JSReturnReg));
111706:     return add(ins);
111706: }
111706: 
111720: bool
111720: LIRGeneratorX64::preparePhi(MPhi *phi)
111720: {
111732:     uint32 vreg = getVirtualRegister();
111720:     if (vreg >= MAX_VIRTUAL_REGISTERS)
111720:         return false;
111720: 
111720:     phi->setId(vreg);
111720:     return true;
111720: }
111720: 
111962: bool
111962: LIRGeneratorX64::assignSnapshot(LInstruction *ins)
111711: {
111962:     LSnapshot *snapshot = LSnapshot::New(gen, last_snapshot_);
111962:     if (!snapshot)
111962:         return false;
111962: 
111711:     MSnapshot *mir = snapshot->mir();
111711:     for (size_t i = 0; i < mir->numOperands(); i++) {
111795:         MDefinition *ins = mir->getOperand(i);
111711:         LAllocation *a = snapshot->getEntry(i);
111764:         *a = useKeepaliveOrConstant(ins);
111711:     }
111962: 
111962:     ins->assignSnapshot(snapshot);
111962:     return true;
111711: }
111711: 
111722: bool
111962: LIRGeneratorX64::lowerForALU(LInstructionHelper<1, 2, 0> *ins, MDefinition *mir, MDefinition *lhs, MDefinition *rhs)
111722: {
111722:     ins->setOperand(0, useRegister(lhs));
111722:     ins->setOperand(1, useOrConstant(rhs));
111722:     return defineReuseInput(ins, mir);
111722: }
111722: 
111920: bool
111920: LIRGeneratorX64::lowerForFPU(LMathD *ins, MDefinition *mir, MDefinition *lhs, MDefinition *rhs)
111920: {
111920:     ins->setOperand(0, useRegister(lhs));
111920:     ins->setOperand(1, useRegister(rhs));
111920:     return defineReuseInput(ins, mir);
111920: }
111920: 
