   1: 
   1: /* pngrutil.c - utilities to read a PNG file
   1:  *
 499:  * Last changed in libpng 1.2.15 January 5, 2007
   1:  * For conditions of distribution and use, see copyright notice in png.h
 499:  * Copyright (c) 1998-2007 Glenn Randers-Pehrson
   1:  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
   1:  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
   1:  *
   1:  * This file contains routines that are only called from within
   1:  * libpng itself during the course of reading an image.
   1:  */
   1: 
   1: #define PNG_INTERNAL
   1: #include "png.h"
   1: 
   1: #if defined(PNG_READ_SUPPORTED)
   1: 
 499: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1: #  if defined(_WIN32_WCE)
   1: /* strtod() function is not supported on WindowsCE */
 499: __inline double png_strtod(png_structp png_ptr, const char *nptr, char **endptr)
   1: {
   1:    double result = 0;
   1:    int len;
   1:    wchar_t *str, *end;
   1: 
   1:    len = MultiByteToWideChar(CP_ACP, 0, nptr, -1, NULL, 0);
 499:    str = (wchar_t *)png_malloc(png_ptr, len * sizeof(wchar_t));
   1:    if ( NULL != str )
   1:    {
   1:       MultiByteToWideChar(CP_ACP, 0, nptr, -1, str, len);
   1:       result = wcstod(str, &end);
   1:       len = WideCharToMultiByte(CP_ACP, 0, end, -1, NULL, 0, NULL, NULL);
   1:       *endptr = (char *)nptr + (png_strlen(nptr) - len + 1);
 499:       png_free(str);
   1:    }
   1:    return result;
   1: }
 499: #  else
 499: #    define png_strtod(p,a,b) strtod(a,b)
   1: #  endif
   1: #endif
   1: 
   1: png_uint_32 PNGAPI
   1: png_get_uint_31(png_structp png_ptr, png_bytep buf)
   1: {
   1:    png_uint_32 i = png_get_uint_32(buf);
   1:    if (i > PNG_UINT_31_MAX)
   1:      png_error(png_ptr, "PNG unsigned integer out of range.");
   1:    return (i);
   1: }
   1: #ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
   1: /* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
   1: png_uint_32 PNGAPI
   1: png_get_uint_32(png_bytep buf)
   1: {
   1:    png_uint_32 i = ((png_uint_32)(*buf) << 24) +
   1:       ((png_uint_32)(*(buf + 1)) << 16) +
   1:       ((png_uint_32)(*(buf + 2)) << 8) +
   1:       (png_uint_32)(*(buf + 3));
   1: 
   1:    return (i);
   1: }
   1: 
   1: /* Grab a signed 32-bit integer from a buffer in big-endian format.  The
   1:  * data is stored in the PNG file in two's complement format, and it is
   1:  * assumed that the machine format for signed integers is the same. */
   1: png_int_32 PNGAPI
   1: png_get_int_32(png_bytep buf)
   1: {
   1:    png_int_32 i = ((png_int_32)(*buf) << 24) +
   1:       ((png_int_32)(*(buf + 1)) << 16) +
   1:       ((png_int_32)(*(buf + 2)) << 8) +
   1:       (png_int_32)(*(buf + 3));
   1: 
   1:    return (i);
   1: }
   1: 
   1: /* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
   1: png_uint_16 PNGAPI
   1: png_get_uint_16(png_bytep buf)
   1: {
   1:    png_uint_16 i = (png_uint_16)(((png_uint_16)(*buf) << 8) +
   1:       (png_uint_16)(*(buf + 1)));
   1: 
   1:    return (i);
   1: }
   1: #endif /* PNG_READ_BIG_ENDIAN_SUPPORTED */
   1: 
   1: /* Read data, and (optionally) run it through the CRC. */
   1: void /* PRIVATE */
   1: png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
   1: {
 499:    if(png_ptr == NULL) return;
   1:    png_read_data(png_ptr, buf, length);
   1:    png_calculate_crc(png_ptr, buf, length);
   1: }
   1: 
   1: /* Optionally skip data and then check the CRC.  Depending on whether we
   1:    are reading a ancillary or critical chunk, and how the program has set
   1:    things up, we may calculate the CRC on the data and print a message.
   1:    Returns '1' if there was a CRC error, '0' otherwise. */
   1: int /* PRIVATE */
   1: png_crc_finish(png_structp png_ptr, png_uint_32 skip)
   1: {
   1:    png_size_t i;
   1:    png_size_t istop = png_ptr->zbuf_size;
   1: 
   1:    for (i = (png_size_t)skip; i > istop; i -= istop)
   1:    {
   1:       png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
   1:    }
   1:    if (i)
   1:    {
   1:       png_crc_read(png_ptr, png_ptr->zbuf, i);
   1:    }
   1: 
   1:    if (png_crc_error(png_ptr))
   1:    {
   1:       if (((png_ptr->chunk_name[0] & 0x20) &&                /* Ancillary */
   1:            !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
   1:           (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */
   1:           (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE)))
   1:       {
   1:          png_chunk_warning(png_ptr, "CRC error");
   1:       }
   1:       else
   1:       {
   1:          png_chunk_error(png_ptr, "CRC error");
   1:       }
   1:       return (1);
   1:    }
   1: 
   1:    return (0);
   1: }
   1: 
   1: /* Compare the CRC stored in the PNG file with that calculated by libpng from
   1:    the data it has read thus far. */
   1: int /* PRIVATE */
   1: png_crc_error(png_structp png_ptr)
   1: {
   1:    png_byte crc_bytes[4];
   1:    png_uint_32 crc;
   1:    int need_crc = 1;
   1: 
   1:    if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
   1:    {
   1:       if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
   1:           (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
   1:          need_crc = 0;
   1:    }
   1:    else                                                    /* critical */
   1:    {
   1:       if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
   1:          need_crc = 0;
   1:    }
   1: 
   1:    png_read_data(png_ptr, crc_bytes, 4);
   1: 
   1:    if (need_crc)
   1:    {
   1:       crc = png_get_uint_32(crc_bytes);
   1:       return ((int)(crc != png_ptr->crc));
   1:    }
   1:    else
   1:       return (0);
   1: }
   1: 
   1: #if defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) || \
   1:     defined(PNG_READ_iCCP_SUPPORTED)
   1: /*
   1:  * Decompress trailing data in a chunk.  The assumption is that chunkdata
   1:  * points at an allocated area holding the contents of a chunk with a
   1:  * trailing compressed part.  What we get back is an allocated area
   1:  * holding the original prefix part and an uncompressed version of the
   1:  * trailing part (the malloc area passed in is freed).
   1:  */
   1: png_charp /* PRIVATE */
   1: png_decompress_chunk(png_structp png_ptr, int comp_type,
   1:                               png_charp chunkdata, png_size_t chunklength,
   1:                               png_size_t prefix_size, png_size_t *newlength)
   1: {
   1:    static char msg[] = "Error decoding compressed text";
   1:    png_charp text;
   1:    png_size_t text_size;
   1: 
   1:    if (comp_type == PNG_COMPRESSION_TYPE_BASE)
   1:    {
   1:       int ret = Z_OK;
   1:       png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);
   1:       png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);
   1:       png_ptr->zstream.next_out = png_ptr->zbuf;
   1:       png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   1: 
   1:       text_size = 0;
   1:       text = NULL;
   1: 
   1:       while (png_ptr->zstream.avail_in)
   1:       {
   1:          ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
   1:          if (ret != Z_OK && ret != Z_STREAM_END)
   1:          {
   1:             if (png_ptr->zstream.msg != NULL)
   1:                png_warning(png_ptr, png_ptr->zstream.msg);
   1:             else
   1:                png_warning(png_ptr, msg);
   1:             inflateReset(&png_ptr->zstream);
   1:             png_ptr->zstream.avail_in = 0;
   1: 
   1:             if (text ==  NULL)
   1:             {
   1:                text_size = prefix_size + png_sizeof(msg) + 1;
   1:                text = (png_charp)png_malloc_warn(png_ptr, text_size);
   1:                if (text ==  NULL)
   1:                  {
   1:                     png_free(png_ptr,chunkdata);
   1:                     png_error(png_ptr,"Not enough memory to decompress chunk");
   1:                  }
   1:                png_memcpy(text, chunkdata, prefix_size);
   1:             }
   1: 
   1:             text[text_size - 1] = 0x00;
   1: 
   1:             /* Copy what we can of the error message into the text chunk */
   1:             text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);
   1:             text_size = png_sizeof(msg) > text_size ? text_size :
   1:                png_sizeof(msg);
   1:             png_memcpy(text + prefix_size, msg, text_size + 1);
   1:             break;
   1:          }
   1:          if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)
   1:          {
   1:             if (text == NULL)
   1:             {
   1:                text_size = prefix_size +
   1:                    png_ptr->zbuf_size - png_ptr->zstream.avail_out;
   1:                text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);
   1:                if (text ==  NULL)
   1:                  {
   1:                     png_free(png_ptr,chunkdata);
   1:                     png_error(png_ptr,"Not enough memory to decompress chunk.");
   1:                  }
   1:                png_memcpy(text + prefix_size, png_ptr->zbuf,
   1:                     text_size - prefix_size);
   1:                png_memcpy(text, chunkdata, prefix_size);
   1:                *(text + text_size) = 0x00;
   1:             }
   1:             else
   1:             {
   1:                png_charp tmp;
   1: 
   1:                tmp = text;
   1:                text = (png_charp)png_malloc_warn(png_ptr,
   1:                   (png_uint_32)(text_size +
   1:                   png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));
   1:                if (text == NULL)
   1:                {
   1:                   png_free(png_ptr, tmp);
   1:                   png_free(png_ptr, chunkdata);
   1:                   png_error(png_ptr,"Not enough memory to decompress chunk..");
   1:                }
   1:                png_memcpy(text, tmp, text_size);
   1:                png_free(png_ptr, tmp);
   1:                png_memcpy(text + text_size, png_ptr->zbuf,
   1:                   (png_ptr->zbuf_size - png_ptr->zstream.avail_out));
   1:                text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
   1:                *(text + text_size) = 0x00;
   1:             }
   1:             if (ret == Z_STREAM_END)
   1:                break;
   1:             else
   1:             {
   1:                png_ptr->zstream.next_out = png_ptr->zbuf;
   1:                png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   1:             }
   1:          }
   1:       }
   1:       if (ret != Z_STREAM_END)
   1:       {
   1: #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
   1:          char umsg[52];
   1: 
   1:          if (ret == Z_BUF_ERROR)
   1:             sprintf(umsg,"Buffer error in compressed datastream in %s chunk",
   1:                 png_ptr->chunk_name);
   1:          else if (ret == Z_DATA_ERROR)
   1:             sprintf(umsg,"Data error in compressed datastream in %s chunk",
   1:                 png_ptr->chunk_name);
   1:          else
   1:             sprintf(umsg,"Incomplete compressed datastream in %s chunk",
   1:                 png_ptr->chunk_name);
   1:          png_warning(png_ptr, umsg);
   1: #else
   1:          png_warning(png_ptr,
   1:             "Incomplete compressed datastream in chunk other than IDAT");
   1: #endif
   1:          text_size=prefix_size;
   1:          if (text ==  NULL)
   1:          {
   1:             text = (png_charp)png_malloc_warn(png_ptr, text_size+1);
   1:             if (text == NULL)
   1:               {
   1:                 png_free(png_ptr, chunkdata);
   1:                 png_error(png_ptr,"Not enough memory for text.");
   1:               }
   1:             png_memcpy(text, chunkdata, prefix_size);
   1:          }
   1:          *(text + text_size) = 0x00;
   1:       }
   1: 
   1:       inflateReset(&png_ptr->zstream);
   1:       png_ptr->zstream.avail_in = 0;
   1: 
   1:       png_free(png_ptr, chunkdata);
   1:       chunkdata = text;
   1:       *newlength=text_size;
   1:    }
   1:    else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
   1:    {
   1: #if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
   1:       char umsg[50];
   1: 
   1:       sprintf(umsg, "Unknown zTXt compression type %d", comp_type);
   1:       png_warning(png_ptr, umsg);
   1: #else
   1:       png_warning(png_ptr, "Unknown zTXt compression type");
   1: #endif
   1: 
   1:       *(chunkdata + prefix_size) = 0x00;
   1:       *newlength=prefix_size;
   1:    }
   1: 
   1:    return chunkdata;
   1: }
   1: #endif
   1: 
   1: /* read and check the IDHR chunk */
   1: void /* PRIVATE */
   1: png_handle_IHDR(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_byte buf[13];
   1:    png_uint_32 width, height;
   1:    int bit_depth, color_type, compression_type, filter_type;
   1:    int interlace_type;
   1: 
   1:    png_debug(1, "in png_handle_IHDR\n");
   1: 
   1:    if (png_ptr->mode & PNG_HAVE_IHDR)
   1:       png_error(png_ptr, "Out of place IHDR");
   1: 
   1:    /* check the length */
   1:    if (length != 13)
   1:       png_error(png_ptr, "Invalid IHDR chunk");
   1: 
   1:    png_ptr->mode |= PNG_HAVE_IHDR;
   1: 
   1:    png_crc_read(png_ptr, buf, 13);
   1:    png_crc_finish(png_ptr, 0);
   1: 
   1:    width = png_get_uint_31(png_ptr, buf);
   1:    height = png_get_uint_31(png_ptr, buf + 4);
   1:    bit_depth = buf[8];
   1:    color_type = buf[9];
   1:    compression_type = buf[10];
   1:    filter_type = buf[11];
   1:    interlace_type = buf[12];
   1: 
   1: #if defined(PNG_READ_APNG_SUPPORTED)
   1:    png_ptr->first_frame_width = width;
   1:    png_ptr->first_frame_height = height;
   1: #endif
   1: 
   1:    /* set internal variables */
   1:    png_ptr->width = width;
   1:    png_ptr->height = height;
   1:    png_ptr->bit_depth = (png_byte)bit_depth;
   1:    png_ptr->interlaced = (png_byte)interlace_type;
   1:    png_ptr->color_type = (png_byte)color_type;
   1: #if defined(PNG_MNG_FEATURES_SUPPORTED)
   1:    png_ptr->filter_type = (png_byte)filter_type;
   1: #endif
   1:    png_ptr->compression_type = (png_byte)compression_type;
   1: 
   1:    /* find number of channels */
   1:    switch (png_ptr->color_type)
   1:    {
   1:       case PNG_COLOR_TYPE_GRAY:
   1:       case PNG_COLOR_TYPE_PALETTE:
   1:          png_ptr->channels = 1;
   1:          break;
   1:       case PNG_COLOR_TYPE_RGB:
   1:          png_ptr->channels = 3;
   1:          break;
   1:       case PNG_COLOR_TYPE_GRAY_ALPHA:
   1:          png_ptr->channels = 2;
   1:          break;
   1:       case PNG_COLOR_TYPE_RGB_ALPHA:
   1:          png_ptr->channels = 4;
   1:          break;
   1:    }
   1: 
   1:    /* set up other useful info */
   1:    png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *
   1:    png_ptr->channels);
   1:    png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->width);
   1:    png_debug1(3,"bit_depth = %d\n", png_ptr->bit_depth);
   1:    png_debug1(3,"channels = %d\n", png_ptr->channels);
   1:    png_debug1(3,"rowbytes = %lu\n", png_ptr->rowbytes);
   1:    png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
   1:       color_type, interlace_type, compression_type, filter_type);
   1: }
   1: 
   1: /* read and check the palette */
   1: void /* PRIVATE */
   1: png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_color palette[PNG_MAX_PALETTE_LENGTH];
   1:    int num, i;
   1: #ifndef PNG_NO_POINTER_INDEXING
   1:    png_colorp pal_ptr;
   1: #endif
   1: 
   1:    png_debug(1, "in png_handle_PLTE\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before PLTE");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid PLTE after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (png_ptr->mode & PNG_HAVE_PLTE)
   1:       png_error(png_ptr, "Duplicate PLTE chunk");
   1: 
   1:    png_ptr->mode |= PNG_HAVE_PLTE;
   1: 
   1:    if (!(png_ptr->color_type&PNG_COLOR_MASK_COLOR))
   1:    {
   1:       png_warning(png_ptr,
   1:         "Ignoring PLTE chunk in grayscale PNG");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: #if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   1:    if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
   1:    {
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: #endif
   1: 
   1:    if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)
   1:    {
   1:       if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
   1:       {
   1:          png_warning(png_ptr, "Invalid palette chunk");
   1:          png_crc_finish(png_ptr, length);
   1:          return;
   1:       }
   1:       else
   1:       {
   1:          png_error(png_ptr, "Invalid palette chunk");
   1:       }
   1:    }
   1: 
   1:    num = (int)length / 3;
   1: 
   1: #ifndef PNG_NO_POINTER_INDEXING
   1:    for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)
   1:    {
   1:       png_byte buf[3];
   1: 
   1:       png_crc_read(png_ptr, buf, 3);
   1:       pal_ptr->red = buf[0];
   1:       pal_ptr->green = buf[1];
   1:       pal_ptr->blue = buf[2];
   1:    }
   1: #else
   1:    for (i = 0; i < num; i++)
   1:    {
   1:       png_byte buf[3];
   1: 
   1:       png_crc_read(png_ptr, buf, 3);
   1:       /* don't depend upon png_color being any order */
   1:       palette[i].red = buf[0];
   1:       palette[i].green = buf[1];
   1:       palette[i].blue = buf[2];
   1:    }
   1: #endif
   1: 
   1:    /* If we actually NEED the PLTE chunk (ie for a paletted image), we do
   1:       whatever the normal CRC configuration tells us.  However, if we
   1:       have an RGB image, the PLTE can be considered ancillary, so
   1:       we will act as though it is. */
   1: #if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   1:    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   1: #endif
   1:    {
   1:       png_crc_finish(png_ptr, 0);
   1:    }
   1: #if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   1:    else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */
   1:    {
   1:       /* If we don't want to use the data from an ancillary chunk,
   1:          we have two options: an error abort, or a warning and we
   1:          ignore the data in this chunk (which should be OK, since
   1:          it's considered ancillary for a RGB or RGBA image). */
   1:       if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE))
   1:       {
   1:          if (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)
   1:          {
   1:             png_chunk_error(png_ptr, "CRC error");
   1:          }
   1:          else
   1:          {
   1:             png_chunk_warning(png_ptr, "CRC error");
   1:             return;
   1:          }
   1:       }
   1:       /* Otherwise, we (optionally) emit a warning and use the chunk. */
   1:       else if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN))
   1:       {
   1:          png_chunk_warning(png_ptr, "CRC error");
   1:       }
   1:    }
   1: #endif
   1: 
   1:    png_set_PLTE(png_ptr, info_ptr, palette, num);
   1: 
   1: #if defined(PNG_READ_tRNS_SUPPORTED)
   1:    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   1:    {
   1:       if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
   1:       {
   1:          if (png_ptr->num_trans > (png_uint_16)num)
   1:          {
   1:             png_warning(png_ptr, "Truncating incorrect tRNS chunk length");
   1:             png_ptr->num_trans = (png_uint_16)num;
   1:          }
   1:          if (info_ptr->num_trans > (png_uint_16)num)
   1:          {
   1:             png_warning(png_ptr, "Truncating incorrect info tRNS chunk length");
   1:             info_ptr->num_trans = (png_uint_16)num;
   1:          }
   1:       }
   1:    }
   1: #endif
   1: 
   1: }
   1: 
   1: void /* PRIVATE */
   1: png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_debug(1, "in png_handle_IEND\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))
   1:    {
   1:       png_error(png_ptr, "No image in file");
   1:    }
   1: 
   1:    png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);
   1: 
   1:    if (length != 0)
   1:    {
   1:       png_warning(png_ptr, "Incorrect IEND chunk length");
   1:    }
   1:    png_crc_finish(png_ptr, length);
   1: 
   1:    if (&info_ptr == NULL) /* quiet compiler warnings about unused info_ptr */
   1:       return;
   1: }
   1: 
   1: #if defined(PNG_READ_gAMA_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_fixed_point igamma;
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:    float file_gamma;
   1: #endif
   1:    png_byte buf[4];
   1: 
   1:    png_debug(1, "in png_handle_gAMA\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before gAMA");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid gAMA after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (png_ptr->mode & PNG_HAVE_PLTE)
   1:       /* Should be an error, but we can cope with it */
   1:       png_warning(png_ptr, "Out of place gAMA chunk");
   1: 
   1:    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
   1: #if defined(PNG_READ_sRGB_SUPPORTED)
   1:       && !(info_ptr->valid & PNG_INFO_sRGB)
   1: #endif
   1:       )
   1:    {
   1:       png_warning(png_ptr, "Duplicate gAMA chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (length != 4)
   1:    {
   1:       png_warning(png_ptr, "Incorrect gAMA chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: 
   1:    igamma = (png_fixed_point)png_get_uint_32(buf);
   1:    /* check for zero gamma */
   1:    if (igamma == 0)
   1:       {
   1:          png_warning(png_ptr,
   1:            "Ignoring gAMA chunk with gamma=0");
   1:          return;
   1:       }
   1: 
   1: #if defined(PNG_READ_sRGB_SUPPORTED)
   1:    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
   1:       if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
   1:       {
   1:          png_warning(png_ptr,
   1:            "Ignoring incorrect gAMA value when sRGB is also present");
   1: #ifndef PNG_NO_CONSOLE_IO
   1:          fprintf(stderr, "gamma = (%d/100000)\n", (int)igamma);
   1: #endif
   1:          return;
   1:       }
   1: #endif /* PNG_READ_sRGB_SUPPORTED */
   1: 
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:    file_gamma = (float)igamma / (float)100000.0;
   1: #  ifdef PNG_READ_GAMMA_SUPPORTED
   1:      png_ptr->gamma = file_gamma;
   1: #  endif
   1:      png_set_gAMA(png_ptr, info_ptr, file_gamma);
   1: #endif
   1: #ifdef PNG_FIXED_POINT_SUPPORTED
   1:    png_set_gAMA_fixed(png_ptr, info_ptr, igamma);
   1: #endif
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_sBIT_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_size_t truelen;
   1:    png_byte buf[4];
   1: 
   1:    png_debug(1, "in png_handle_sBIT\n");
   1: 
   1:    buf[0] = buf[1] = buf[2] = buf[3] = 0;
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before sBIT");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid sBIT after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (png_ptr->mode & PNG_HAVE_PLTE)
   1:    {
   1:       /* Should be an error, but we can cope with it */
   1:       png_warning(png_ptr, "Out of place sBIT chunk");
   1:    }
   1:    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
   1:    {
   1:       png_warning(png_ptr, "Duplicate sBIT chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   1:       truelen = 3;
   1:    else
   1:       truelen = (png_size_t)png_ptr->channels;
   1: 
   1:    if (length != truelen || length > 4)
   1:    {
   1:       png_warning(png_ptr, "Incorrect sBIT chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_crc_read(png_ptr, buf, truelen);
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: 
   1:    if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
   1:    {
   1:       png_ptr->sig_bit.red = buf[0];
   1:       png_ptr->sig_bit.green = buf[1];
   1:       png_ptr->sig_bit.blue = buf[2];
   1:       png_ptr->sig_bit.alpha = buf[3];
   1:    }
   1:    else
   1:    {
   1:       png_ptr->sig_bit.gray = buf[0];
   1:       png_ptr->sig_bit.red = buf[0];
   1:       png_ptr->sig_bit.green = buf[0];
   1:       png_ptr->sig_bit.blue = buf[0];
   1:       png_ptr->sig_bit.alpha = buf[1];
   1:    }
   1:    png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_cHRM_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_byte buf[4];
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:    float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
   1: #endif
   1:    png_fixed_point int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
   1:       int_y_green, int_x_blue, int_y_blue;
   1: 
   1:    png_uint_32 uint_x, uint_y;
   1: 
   1:    png_debug(1, "in png_handle_cHRM\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before cHRM");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid cHRM after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (png_ptr->mode & PNG_HAVE_PLTE)
   1:       /* Should be an error, but we can cope with it */
   1:       png_warning(png_ptr, "Missing PLTE before cHRM");
   1: 
   1:    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
   1: #if defined(PNG_READ_sRGB_SUPPORTED)
   1:       && !(info_ptr->valid & PNG_INFO_sRGB)
   1: #endif
   1:       )
   1:    {
   1:       png_warning(png_ptr, "Duplicate cHRM chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (length != 32)
   1:    {
   1:       png_warning(png_ptr, "Incorrect cHRM chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    uint_x = png_get_uint_32(buf);
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    uint_y = png_get_uint_32(buf);
   1: 
   1:    if (uint_x > 80000L || uint_y > 80000L ||
   1:       uint_x + uint_y > 100000L)
   1:    {
   1:       png_warning(png_ptr, "Invalid cHRM white point");
   1:       png_crc_finish(png_ptr, 24);
   1:       return;
   1:    }
   1:    int_x_white = (png_fixed_point)uint_x;
   1:    int_y_white = (png_fixed_point)uint_y;
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    uint_x = png_get_uint_32(buf);
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    uint_y = png_get_uint_32(buf);
   1: 
   1:    if (uint_x + uint_y > 100000L)
   1:    {
   1:       png_warning(png_ptr, "Invalid cHRM red point");
   1:       png_crc_finish(png_ptr, 16);
   1:       return;
   1:    }
   1:    int_x_red = (png_fixed_point)uint_x;
   1:    int_y_red = (png_fixed_point)uint_y;
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    uint_x = png_get_uint_32(buf);
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    uint_y = png_get_uint_32(buf);
   1: 
   1:    if (uint_x + uint_y > 100000L)
   1:    {
   1:       png_warning(png_ptr, "Invalid cHRM green point");
   1:       png_crc_finish(png_ptr, 8);
   1:       return;
   1:    }
   1:    int_x_green = (png_fixed_point)uint_x;
   1:    int_y_green = (png_fixed_point)uint_y;
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    uint_x = png_get_uint_32(buf);
   1: 
   1:    png_crc_read(png_ptr, buf, 4);
   1:    uint_y = png_get_uint_32(buf);
   1: 
   1:    if (uint_x + uint_y > 100000L)
   1:    {
   1:       png_warning(png_ptr, "Invalid cHRM blue point");
   1:       png_crc_finish(png_ptr, 0);
   1:       return;
   1:    }
   1:    int_x_blue = (png_fixed_point)uint_x;
   1:    int_y_blue = (png_fixed_point)uint_y;
   1: 
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:    white_x = (float)int_x_white / (float)100000.0;
   1:    white_y = (float)int_y_white / (float)100000.0;
   1:    red_x   = (float)int_x_red   / (float)100000.0;
   1:    red_y   = (float)int_y_red   / (float)100000.0;
   1:    green_x = (float)int_x_green / (float)100000.0;
   1:    green_y = (float)int_y_green / (float)100000.0;
   1:    blue_x  = (float)int_x_blue  / (float)100000.0;
   1:    blue_y  = (float)int_y_blue  / (float)100000.0;
   1: #endif
   1: 
   1: #if defined(PNG_READ_sRGB_SUPPORTED)
   1:    if ((info_ptr != NULL) && (info_ptr->valid & PNG_INFO_sRGB))
   1:       {
   1:       if (PNG_OUT_OF_RANGE(int_x_white, 31270,  1000) ||
   1:           PNG_OUT_OF_RANGE(int_y_white, 32900,  1000) ||
   1:           PNG_OUT_OF_RANGE(int_x_red,   64000L, 1000) ||
   1:           PNG_OUT_OF_RANGE(int_y_red,   33000,  1000) ||
   1:           PNG_OUT_OF_RANGE(int_x_green, 30000,  1000) ||
   1:           PNG_OUT_OF_RANGE(int_y_green, 60000L, 1000) ||
   1:           PNG_OUT_OF_RANGE(int_x_blue,  15000,  1000) ||
   1:           PNG_OUT_OF_RANGE(int_y_blue,   6000,  1000))
   1:          {
   1:             png_warning(png_ptr,
   1:               "Ignoring incorrect cHRM value when sRGB is also present");
   1: #ifndef PNG_NO_CONSOLE_IO
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:             fprintf(stderr,"wx=%f, wy=%f, rx=%f, ry=%f\n",
   1:                white_x, white_y, red_x, red_y);
   1:             fprintf(stderr,"gx=%f, gy=%f, bx=%f, by=%f\n",
   1:                green_x, green_y, blue_x, blue_y);
   1: #else
   1:             fprintf(stderr,"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
   1:                int_x_white, int_y_white, int_x_red, int_y_red);
   1:             fprintf(stderr,"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
   1:                int_x_green, int_y_green, int_x_blue, int_y_blue);
   1: #endif
   1: #endif /* PNG_NO_CONSOLE_IO */
   1:          }
   1:          png_crc_finish(png_ptr, 0);
   1:          return;
   1:       }
   1: #endif /* PNG_READ_sRGB_SUPPORTED */
   1: 
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:    png_set_cHRM(png_ptr, info_ptr,
   1:       white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
   1: #endif
   1: #ifdef PNG_FIXED_POINT_SUPPORTED
   1:    png_set_cHRM_fixed(png_ptr, info_ptr,
   1:       int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
   1:       int_y_green, int_x_blue, int_y_blue);
   1: #endif
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_sRGB_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    int intent;
   1:    png_byte buf[1];
   1: 
   1:    png_debug(1, "in png_handle_sRGB\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before sRGB");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid sRGB after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (png_ptr->mode & PNG_HAVE_PLTE)
   1:       /* Should be an error, but we can cope with it */
   1:       png_warning(png_ptr, "Out of place sRGB chunk");
   1: 
   1:    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
   1:    {
   1:       png_warning(png_ptr, "Duplicate sRGB chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (length != 1)
   1:    {
   1:       png_warning(png_ptr, "Incorrect sRGB chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_crc_read(png_ptr, buf, 1);
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: 
   1:    intent = buf[0];
   1:    /* check for bad intent */
   1:    if (intent >= PNG_sRGB_INTENT_LAST)
   1:    {
   1:       png_warning(png_ptr, "Unknown sRGB intent");
   1:       return;
   1:    }
   1: 
   1: #if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
   1:    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA))
   1:    {
   1:    png_fixed_point igamma;
   1: #ifdef PNG_FIXED_POINT_SUPPORTED
   1:       igamma=info_ptr->int_gamma;
   1: #else
   1: #  ifdef PNG_FLOATING_POINT_SUPPORTED
   1:       igamma=(png_fixed_point)(info_ptr->gamma * 100000.);
   1: #  endif
   1: #endif
   1:       if (PNG_OUT_OF_RANGE(igamma, 45500L, 500))
   1:       {
   1:          png_warning(png_ptr,
   1:            "Ignoring incorrect gAMA value when sRGB is also present");
   1: #ifndef PNG_NO_CONSOLE_IO
   1: #  ifdef PNG_FIXED_POINT_SUPPORTED
   1:          fprintf(stderr,"incorrect gamma=(%d/100000)\n",(int)png_ptr->int_gamma);
   1: #  else
   1: #    ifdef PNG_FLOATING_POINT_SUPPORTED
   1:          fprintf(stderr,"incorrect gamma=%f\n",png_ptr->gamma);
   1: #    endif
   1: #  endif
   1: #endif
   1:       }
   1:    }
   1: #endif /* PNG_READ_gAMA_SUPPORTED */
   1: 
   1: #ifdef PNG_READ_cHRM_SUPPORTED
   1: #ifdef PNG_FIXED_POINT_SUPPORTED
   1:    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM))
   1:       if (PNG_OUT_OF_RANGE(info_ptr->int_x_white, 31270,  1000) ||
   1:           PNG_OUT_OF_RANGE(info_ptr->int_y_white, 32900,  1000) ||
   1:           PNG_OUT_OF_RANGE(info_ptr->int_x_red,   64000L, 1000) ||
   1:           PNG_OUT_OF_RANGE(info_ptr->int_y_red,   33000,  1000) ||
   1:           PNG_OUT_OF_RANGE(info_ptr->int_x_green, 30000,  1000) ||
   1:           PNG_OUT_OF_RANGE(info_ptr->int_y_green, 60000L, 1000) ||
   1:           PNG_OUT_OF_RANGE(info_ptr->int_x_blue,  15000,  1000) ||
   1:           PNG_OUT_OF_RANGE(info_ptr->int_y_blue,   6000,  1000))
   1:          {
   1:             png_warning(png_ptr,
   1:               "Ignoring incorrect cHRM value when sRGB is also present");
   1:          }
   1: #endif /* PNG_FIXED_POINT_SUPPORTED */
   1: #endif /* PNG_READ_cHRM_SUPPORTED */
   1: 
   1:    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
   1: }
   1: #endif /* PNG_READ_sRGB_SUPPORTED */
   1: 
   1: #if defined(PNG_READ_iCCP_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: /* Note: this does not properly handle chunks that are > 64K under DOS */
   1: {
   1:    png_charp chunkdata;
   1:    png_byte compression_type;
   1:    png_bytep pC;
   1:    png_charp profile;
   1:    png_uint_32 skip = 0;
   1:    png_uint_32 profile_size, profile_length;
   1:    png_size_t slength, prefix_length, data_length;
   1: 
   1:    png_debug(1, "in png_handle_iCCP\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before iCCP");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid iCCP after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (png_ptr->mode & PNG_HAVE_PLTE)
   1:       /* Should be an error, but we can cope with it */
   1:       png_warning(png_ptr, "Out of place iCCP chunk");
   1: 
   1:    if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
   1:    {
   1:       png_warning(png_ptr, "Duplicate iCCP chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1: #ifdef PNG_MAX_MALLOC_64K
   1:    if (length > (png_uint_32)65535L)
   1:    {
   1:       png_warning(png_ptr, "iCCP chunk too large to fit in memory");
   1:       skip = length - (png_uint_32)65535L;
   1:       length = (png_uint_32)65535L;
   1:    }
   1: #endif
   1: 
   1:    chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
   1:    slength = (png_size_t)length;
   1:    png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
   1: 
   1:    if (png_crc_finish(png_ptr, skip))
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       return;
   1:    }
   1: 
   1:    chunkdata[slength] = 0x00;
   1: 
   1:    for (profile = chunkdata; *profile; profile++)
   1:       /* empty loop to find end of name */ ;
   1: 
   1:    ++profile;
   1: 
   1:    /* there should be at least one zero (the compression type byte)
   1:       following the separator, and we should be on it  */
   1:    if ( profile >= chunkdata + slength)
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       png_warning(png_ptr, "Malformed iCCP chunk");
   1:       return;
   1:    }
   1: 
   1:    /* compression_type should always be zero */
   1:    compression_type = *profile++;
   1:    if (compression_type)
   1:    {
   1:       png_warning(png_ptr, "Ignoring nonzero compression type in iCCP chunk");
   1:       compression_type=0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
   1:                                  wrote nonzero) */
   1:    }
   1: 
   1:    prefix_length = profile - chunkdata;
   1:    chunkdata = png_decompress_chunk(png_ptr, compression_type, chunkdata,
   1:                                     slength, prefix_length, &data_length);
   1: 
   1:    profile_length = data_length - prefix_length;
   1: 
   1:    if ( prefix_length > data_length || profile_length < 4)
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       png_warning(png_ptr, "Profile size field missing from iCCP chunk");
   1:       return;
   1:    }
   1: 
   1:    /* Check the profile_size recorded in the first 32 bits of the ICC profile */
   1:    pC = (png_bytep)(chunkdata+prefix_length);
   1:    profile_size = ((*(pC  ))<<24) |
   1:                   ((*(pC+1))<<16) |
   1:                   ((*(pC+2))<< 8) |
   1:                   ((*(pC+3))    );
   1: 
   1:    if(profile_size < profile_length)
   1:       profile_length = profile_size;
   1: 
   1:    if(profile_size > profile_length)
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       png_warning(png_ptr, "Ignoring truncated iCCP profile.");
   1:       return;
   1:    }
   1: 
   1:    png_set_iCCP(png_ptr, info_ptr, chunkdata, compression_type,
   1:                 chunkdata + prefix_length, profile_length);
   1:    png_free(png_ptr, chunkdata);
   1: }
   1: #endif /* PNG_READ_iCCP_SUPPORTED */
   1: 
   1: #if defined(PNG_READ_sPLT_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: /* Note: this does not properly handle chunks that are > 64K under DOS */
   1: {
   1:    png_bytep chunkdata;
   1:    png_bytep entry_start;
   1:    png_sPLT_t new_palette;
   1: #ifdef PNG_NO_POINTER_INDEXING
   1:    png_sPLT_entryp pp;
   1: #endif
   1:    int data_length, entry_size, i;
   1:    png_uint_32 skip = 0;
   1:    png_size_t slength;
   1: 
   1:    png_debug(1, "in png_handle_sPLT\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before sPLT");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid sPLT after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1: #ifdef PNG_MAX_MALLOC_64K
   1:    if (length > (png_uint_32)65535L)
   1:    {
   1:       png_warning(png_ptr, "sPLT chunk too large to fit in memory");
   1:       skip = length - (png_uint_32)65535L;
   1:       length = (png_uint_32)65535L;
   1:    }
   1: #endif
   1: 
   1:    chunkdata = (png_bytep)png_malloc(png_ptr, length + 1);
   1:    slength = (png_size_t)length;
   1:    png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
   1: 
   1:    if (png_crc_finish(png_ptr, skip))
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       return;
   1:    }
   1: 
   1:    chunkdata[slength] = 0x00;
   1: 
   1:    for (entry_start = chunkdata; *entry_start; entry_start++)
   1:       /* empty loop to find end of name */ ;
   1:    ++entry_start;
   1: 
   1:    /* a sample depth should follow the separator, and we should be on it  */
   1:    if (entry_start > chunkdata + slength)
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       png_warning(png_ptr, "malformed sPLT chunk");
   1:       return;
   1:    }
   1: 
   1:    new_palette.depth = *entry_start++;
   1:    entry_size = (new_palette.depth == 8 ? 6 : 10);
   1:    data_length = (slength - (entry_start - chunkdata));
   1: 
   1:    /* integrity-check the data length */
   1:    if (data_length % entry_size)
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       png_warning(png_ptr, "sPLT chunk has bad length");
   1:       return;
   1:    }
   1: 
   1:    new_palette.nentries = (png_int_32) ( data_length / entry_size);
   1:    if ((png_uint_32) new_palette.nentries > (png_uint_32) (PNG_SIZE_MAX /
   1:        png_sizeof(png_sPLT_entry)))
   1:    {
   1:        png_warning(png_ptr, "sPLT chunk too long");
   1:        return;
   1:    }
   1:    new_palette.entries = (png_sPLT_entryp)png_malloc_warn(
   1:        png_ptr, new_palette.nentries * png_sizeof(png_sPLT_entry));
   1:    if (new_palette.entries == NULL)
   1:    {
   1:        png_warning(png_ptr, "sPLT chunk requires too much memory");
   1:        return;
   1:    }
   1: 
   1: #ifndef PNG_NO_POINTER_INDEXING
   1:    for (i = 0; i < new_palette.nentries; i++)
   1:    {
   1:       png_sPLT_entryp pp = new_palette.entries + i;
   1: 
   1:       if (new_palette.depth == 8)
   1:       {
   1:           pp->red = *entry_start++;
   1:           pp->green = *entry_start++;
   1:           pp->blue = *entry_start++;
   1:           pp->alpha = *entry_start++;
   1:       }
   1:       else
   1:       {
   1:           pp->red   = png_get_uint_16(entry_start); entry_start += 2;
   1:           pp->green = png_get_uint_16(entry_start); entry_start += 2;
   1:           pp->blue  = png_get_uint_16(entry_start); entry_start += 2;
   1:           pp->alpha = png_get_uint_16(entry_start); entry_start += 2;
   1:       }
   1:       pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
   1:    }
   1: #else
   1:    pp = new_palette.entries;
   1:    for (i = 0; i < new_palette.nentries; i++)
   1:    {
   1: 
   1:       if (new_palette.depth == 8)
   1:       {
   1:           pp[i].red   = *entry_start++;
   1:           pp[i].green = *entry_start++;
   1:           pp[i].blue  = *entry_start++;
   1:           pp[i].alpha = *entry_start++;
   1:       }
   1:       else
   1:       {
   1:           pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;
   1:           pp[i].green = png_get_uint_16(entry_start); entry_start += 2;
   1:           pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;
   1:           pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;
   1:       }
   1:       pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
   1:    }
   1: #endif
   1: 
   1:    /* discard all chunk data except the name and stash that */
   1:    new_palette.name = (png_charp)chunkdata;
   1: 
   1:    png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);
   1: 
   1:    png_free(png_ptr, chunkdata);
   1:    png_free(png_ptr, new_palette.entries);
   1: }
   1: #endif /* PNG_READ_sPLT_SUPPORTED */
   1: 
   1: #if defined(PNG_READ_tRNS_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_byte readbuf[PNG_MAX_PALETTE_LENGTH];
   1: 
   1:    png_debug(1, "in png_handle_tRNS\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before tRNS");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid tRNS after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
   1:    {
   1:       png_warning(png_ptr, "Duplicate tRNS chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
   1:    {
   1:       png_byte buf[2];
   1: 
   1:       if (length != 2)
   1:       {
   1:          png_warning(png_ptr, "Incorrect tRNS chunk length");
   1:          png_crc_finish(png_ptr, length);
   1:          return;
   1:       }
   1: 
   1:       png_crc_read(png_ptr, buf, 2);
   1:       png_ptr->num_trans = 1;
   1:       png_ptr->trans_values.gray = png_get_uint_16(buf);
   1:    }
   1:    else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   1:    {
   1:       png_byte buf[6];
   1: 
   1:       if (length != 6)
   1:       {
   1:          png_warning(png_ptr, "Incorrect tRNS chunk length");
   1:          png_crc_finish(png_ptr, length);
   1:          return;
   1:       }
   1:       png_crc_read(png_ptr, buf, (png_size_t)length);
   1:       png_ptr->num_trans = 1;
   1:       png_ptr->trans_values.red = png_get_uint_16(buf);
   1:       png_ptr->trans_values.green = png_get_uint_16(buf + 2);
   1:       png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
   1:    }
   1:    else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   1:    {
   1:       if (!(png_ptr->mode & PNG_HAVE_PLTE))
   1:       {
   1:          /* Should be an error, but we can cope with it. */
   1:          png_warning(png_ptr, "Missing PLTE before tRNS");
   1:       }
   1:       if (length > (png_uint_32)png_ptr->num_palette ||
   1:           length > PNG_MAX_PALETTE_LENGTH)
   1:       {
   1:          png_warning(png_ptr, "Incorrect tRNS chunk length");
   1:          png_crc_finish(png_ptr, length);
   1:          return;
   1:       }
   1:       if (length == 0)
   1:       {
   1:          png_warning(png_ptr, "Zero length tRNS chunk");
   1:          png_crc_finish(png_ptr, length);
   1:          return;
   1:       }
   1:       png_crc_read(png_ptr, readbuf, (png_size_t)length);
   1:       png_ptr->num_trans = (png_uint_16)length;
   1:    }
   1:    else
   1:    {
   1:       png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (png_crc_finish(png_ptr, 0))
3425:    {
3425:       png_ptr->num_trans = 0;
   1:       return;
3425:    }
   1: 
   1:    png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
   1:       &(png_ptr->trans_values));
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_bKGD_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_size_t truelen;
   1:    png_byte buf[6];
   1: 
   1:    png_debug(1, "in png_handle_bKGD\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before bKGD");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid bKGD after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
   1:             !(png_ptr->mode & PNG_HAVE_PLTE))
   1:    {
   1:       png_warning(png_ptr, "Missing PLTE before bKGD");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD))
   1:    {
   1:       png_warning(png_ptr, "Duplicate bKGD chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   1:       truelen = 1;
   1:    else if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
   1:       truelen = 6;
   1:    else
   1:       truelen = 2;
   1: 
   1:    if (length != truelen)
   1:    {
   1:       png_warning(png_ptr, "Incorrect bKGD chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_crc_read(png_ptr, buf, truelen);
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: 
   1:    /* We convert the index value into RGB components so that we can allow
   1:     * arbitrary RGB values for background when we have transparency, and
   1:     * so it is easy to determine the RGB values of the background color
   1:     * from the info_ptr struct. */
   1:    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   1:    {
   1:       png_ptr->background.index = buf[0];
   1:       if(info_ptr->num_palette)
   1:       {
   1:           if(buf[0] > info_ptr->num_palette)
   1:           {
   1:              png_warning(png_ptr, "Incorrect bKGD chunk index value");
   1:              return;
   1:           }
   1:           png_ptr->background.red =
   1:              (png_uint_16)png_ptr->palette[buf[0]].red;
   1:           png_ptr->background.green =
   1:              (png_uint_16)png_ptr->palette[buf[0]].green;
   1:           png_ptr->background.blue =
   1:              (png_uint_16)png_ptr->palette[buf[0]].blue;
   1:       }
   1:    }
   1:    else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */
   1:    {
   1:       png_ptr->background.red =
   1:       png_ptr->background.green =
   1:       png_ptr->background.blue =
   1:       png_ptr->background.gray = png_get_uint_16(buf);
   1:    }
   1:    else
   1:    {
   1:       png_ptr->background.red = png_get_uint_16(buf);
   1:       png_ptr->background.green = png_get_uint_16(buf + 2);
   1:       png_ptr->background.blue = png_get_uint_16(buf + 4);
   1:    }
   1: 
   1:    png_set_bKGD(png_ptr, info_ptr, &(png_ptr->background));
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_hIST_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    unsigned int num, i;
   1:    png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];
   1: 
   1:    png_debug(1, "in png_handle_hIST\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before hIST");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid hIST after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (!(png_ptr->mode & PNG_HAVE_PLTE))
   1:    {
   1:       png_warning(png_ptr, "Missing PLTE before hIST");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST))
   1:    {
   1:       png_warning(png_ptr, "Duplicate hIST chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    num = length / 2 ;
   1:    if (num != (unsigned int) png_ptr->num_palette || num >
   1:       (unsigned int) PNG_MAX_PALETTE_LENGTH)
   1:    {
   1:       png_warning(png_ptr, "Incorrect hIST chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    for (i = 0; i < num; i++)
   1:    {
   1:       png_byte buf[2];
   1: 
   1:       png_crc_read(png_ptr, buf, 2);
   1:       readbuf[i] = png_get_uint_16(buf);
   1:    }
   1: 
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: 
   1:    png_set_hIST(png_ptr, info_ptr, readbuf);
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_pHYs_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_pHYs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_byte buf[9];
   1:    png_uint_32 res_x, res_y;
   1:    int unit_type;
   1: 
   1:    png_debug(1, "in png_handle_pHYs\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before pHYs");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid pHYs after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
   1:    {
   1:       png_warning(png_ptr, "Duplicate pHYs chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (length != 9)
   1:    {
   1:       png_warning(png_ptr, "Incorrect pHYs chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_crc_read(png_ptr, buf, 9);
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: 
   1:    res_x = png_get_uint_32(buf);
   1:    res_y = png_get_uint_32(buf + 4);
   1:    unit_type = buf[8];
   1:    png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_oFFs_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_oFFs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_byte buf[9];
   1:    png_int_32 offset_x, offset_y;
   1:    int unit_type;
   1: 
   1:    png_debug(1, "in png_handle_oFFs\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before oFFs");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid oFFs after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
   1:    {
   1:       png_warning(png_ptr, "Duplicate oFFs chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (length != 9)
   1:    {
   1:       png_warning(png_ptr, "Incorrect oFFs chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_crc_read(png_ptr, buf, 9);
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: 
   1:    offset_x = png_get_int_32(buf);
   1:    offset_y = png_get_int_32(buf + 4);
   1:    unit_type = buf[8];
   1:    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_pCAL_SUPPORTED)
   1: /* read the pCAL chunk (described in the PNG Extensions document) */
   1: void /* PRIVATE */
   1: png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_charp purpose;
   1:    png_int_32 X0, X1;
   1:    png_byte type, nparams;
   1:    png_charp buf, units, endptr;
   1:    png_charpp params;
   1:    png_size_t slength;
   1:    int i;
   1: 
   1:    png_debug(1, "in png_handle_pCAL\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before pCAL");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid pCAL after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))
   1:    {
   1:       png_warning(png_ptr, "Duplicate pCAL chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)\n",
   1:       length + 1);
   1:    purpose = (png_charp)png_malloc_warn(png_ptr, length + 1);
   1:    if (purpose == NULL)
   1:      {
   1:        png_warning(png_ptr, "No memory for pCAL purpose.");
   1:        return;
   1:      }
   1:    slength = (png_size_t)length;
   1:    png_crc_read(png_ptr, (png_bytep)purpose, slength);
   1: 
   1:    if (png_crc_finish(png_ptr, 0))
   1:    {
   1:       png_free(png_ptr, purpose);
   1:       return;
   1:    }
   1: 
   1:    purpose[slength] = 0x00; /* null terminate the last string */
   1: 
   1:    png_debug(3, "Finding end of pCAL purpose string\n");
   1:    for (buf = purpose; *buf; buf++)
   1:       /* empty loop */ ;
   1: 
   1:    endptr = purpose + slength;
   1: 
   1:    /* We need to have at least 12 bytes after the purpose string
   1:       in order to get the parameter information. */
   1:    if (endptr <= buf + 12)
   1:    {
   1:       png_warning(png_ptr, "Invalid pCAL data");
   1:       png_free(png_ptr, purpose);
   1:       return;
   1:    }
   1: 
   1:    png_debug(3, "Reading pCAL X0, X1, type, nparams, and units\n");
   1:    X0 = png_get_int_32((png_bytep)buf+1);
   1:    X1 = png_get_int_32((png_bytep)buf+5);
   1:    type = buf[9];
   1:    nparams = buf[10];
   1:    units = buf + 11;
   1: 
   1:    png_debug(3, "Checking pCAL equation type and number of parameters\n");
   1:    /* Check that we have the right number of parameters for known
   1:       equation types. */
   1:    if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
   1:        (type == PNG_EQUATION_BASE_E && nparams != 3) ||
   1:        (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||
   1:        (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
   1:    {
   1:       png_warning(png_ptr, "Invalid pCAL parameters for equation type");
   1:       png_free(png_ptr, purpose);
   1:       return;
   1:    }
   1:    else if (type >= PNG_EQUATION_LAST)
   1:    {
   1:       png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
   1:    }
   1: 
   1:    for (buf = units; *buf; buf++)
   1:       /* Empty loop to move past the units string. */ ;
   1: 
   1:    png_debug(3, "Allocating pCAL parameters array\n");
   1:    params = (png_charpp)png_malloc_warn(png_ptr, (png_uint_32)(nparams
   1:       *png_sizeof(png_charp))) ;
   1:    if (params == NULL)
   1:      {
   1:        png_free(png_ptr, purpose);
   1:        png_warning(png_ptr, "No memory for pCAL params.");
   1:        return;
   1:      }
   1: 
   1:    /* Get pointers to the start of each parameter string. */
   1:    for (i = 0; i < (int)nparams; i++)
   1:    {
   1:       buf++; /* Skip the null string terminator from previous parameter. */
   1: 
   1:       png_debug1(3, "Reading pCAL parameter %d\n", i);
   1:       for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++)
   1:          /* Empty loop to move past each parameter string */ ;
   1: 
   1:       /* Make sure we haven't run out of data yet */
   1:       if (buf > endptr)
   1:       {
   1:          png_warning(png_ptr, "Invalid pCAL data");
   1:          png_free(png_ptr, purpose);
   1:          png_free(png_ptr, params);
   1:          return;
   1:       }
   1:    }
   1: 
   1:    png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams,
   1:       units, params);
   1: 
   1:    png_free(png_ptr, purpose);
   1:    png_free(png_ptr, params);
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_sCAL_SUPPORTED)
   1: /* read the sCAL chunk */
   1: void /* PRIVATE */
   1: png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_charp buffer, ep;
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:    double width, height;
   1:    png_charp vp;
   1: #else
   1: #ifdef PNG_FIXED_POINT_SUPPORTED
   1:    png_charp swidth, sheight;
   1: #endif
   1: #endif
   1:    png_size_t slength;
   1: 
   1:    png_debug(1, "in png_handle_sCAL\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before sCAL");
   1:    else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1:       png_warning(png_ptr, "Invalid sCAL after IDAT");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1:    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))
   1:    {
   1:       png_warning(png_ptr, "Duplicate sCAL chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)\n",
   1:       length + 1);
   1:    buffer = (png_charp)png_malloc_warn(png_ptr, length + 1);
   1:    if (buffer == NULL)
   1:      {
   1:        png_warning(png_ptr, "Out of memory while processing sCAL chunk");
   1:        return;
   1:      }
   1:    slength = (png_size_t)length;
   1:    png_crc_read(png_ptr, (png_bytep)buffer, slength);
   1: 
   1:    if (png_crc_finish(png_ptr, 0))
   1:    {
   1:       png_free(png_ptr, buffer);
   1:       return;
   1:    }
   1: 
   1:    buffer[slength] = 0x00; /* null terminate the last string */
   1: 
   1:    ep = buffer + 1;        /* skip unit byte */
   1: 
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
 499:    width = png_strtod(png_ptr, ep, &vp);
   1:    if (*vp)
   1:    {
   1:        png_warning(png_ptr, "malformed width string in sCAL chunk");
   1:        return;
   1:    }
   1: #else
   1: #ifdef PNG_FIXED_POINT_SUPPORTED
   1:    swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
   1:    if (swidth == NULL)
   1:      {
   1:        png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
   1:        return;
   1:      }
   1:    png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));
   1: #endif
   1: #endif
   1: 
   1:    for (ep = buffer; *ep; ep++)
   1:       /* empty loop */ ;
   1:    ep++;
   1: 
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
 499:    height = png_strtod(png_ptr, ep, &vp);
   1:    if (*vp)
   1:    {
   1:        png_warning(png_ptr, "malformed height string in sCAL chunk");
   1:        return;
   1:    }
   1: #else
   1: #ifdef PNG_FIXED_POINT_SUPPORTED
   1:    sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
   1:    if (swidth == NULL)
   1:      {
   1:        png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
   1:        return;
   1:      }
   1:    png_memcpy(sheight, ep, (png_size_t)png_strlen(ep));
   1: #endif
   1: #endif
   1: 
   1:    if (buffer + slength < ep
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:       || width <= 0. || height <= 0.
   1: #endif
   1:       )
   1:    {
   1:       png_warning(png_ptr, "Invalid sCAL data");
   1:       png_free(png_ptr, buffer);
   1: #if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
   1:       png_free(png_ptr, swidth);
   1:       png_free(png_ptr, sheight);
   1: #endif
   1:       return;
   1:    }
   1: 
   1: 
   1: #ifdef PNG_FLOATING_POINT_SUPPORTED
   1:    png_set_sCAL(png_ptr, info_ptr, buffer[0], width, height);
   1: #else
   1: #ifdef PNG_FIXED_POINT_SUPPORTED
   1:    png_set_sCAL_s(png_ptr, info_ptr, buffer[0], swidth, sheight);
   1: #endif
   1: #endif
   1: 
   1:    png_free(png_ptr, buffer);
   1: #if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
   1:    png_free(png_ptr, swidth);
   1:    png_free(png_ptr, sheight);
   1: #endif
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_tIME_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_tIME(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_byte buf[7];
   1:    png_time mod_time;
   1: 
   1:    png_debug(1, "in png_handle_tIME\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Out of place tIME chunk");
   1:    else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME))
   1:    {
   1:       png_warning(png_ptr, "Duplicate tIME chunk");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    if (png_ptr->mode & PNG_HAVE_IDAT)
   1:       png_ptr->mode |= PNG_AFTER_IDAT;
   1: 
   1:    if (length != 7)
   1:    {
   1:       png_warning(png_ptr, "Incorrect tIME chunk length");
   1:       png_crc_finish(png_ptr, length);
   1:       return;
   1:    }
   1: 
   1:    png_crc_read(png_ptr, buf, 7);
   1:    if (png_crc_finish(png_ptr, 0))
   1:       return;
   1: 
   1:    mod_time.second = buf[6];
   1:    mod_time.minute = buf[5];
   1:    mod_time.hour = buf[4];
   1:    mod_time.day = buf[3];
   1:    mod_time.month = buf[2];
   1:    mod_time.year = png_get_uint_16(buf);
   1: 
   1:    png_set_tIME(png_ptr, info_ptr, &mod_time);
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_tEXt_SUPPORTED)
   1: /* Note: this does not properly handle chunks that are > 64K under DOS */
   1: void /* PRIVATE */
   1: png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_textp text_ptr;
   1:    png_charp key;
   1:    png_charp text;
   1:    png_uint_32 skip = 0;
   1:    png_size_t slength;
   1:    int ret;
   1: 
   1:    png_debug(1, "in png_handle_tEXt\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before tEXt");
   1: 
   1:    if (png_ptr->mode & PNG_HAVE_IDAT)
   1:       png_ptr->mode |= PNG_AFTER_IDAT;
   1: 
   1: #ifdef PNG_MAX_MALLOC_64K
   1:    if (length > (png_uint_32)65535L)
   1:    {
   1:       png_warning(png_ptr, "tEXt chunk too large to fit in memory");
   1:       skip = length - (png_uint_32)65535L;
   1:       length = (png_uint_32)65535L;
   1:    }
   1: #endif
   1: 
   1:    key = (png_charp)png_malloc_warn(png_ptr, length + 1);
   1:    if (key == NULL)
   1:    {
   1:      png_warning(png_ptr, "No memory to process text chunk.");
   1:      return;
   1:    }
   1:    slength = (png_size_t)length;
   1:    png_crc_read(png_ptr, (png_bytep)key, slength);
   1: 
   1:    if (png_crc_finish(png_ptr, skip))
   1:    {
   1:       png_free(png_ptr, key);
   1:       return;
   1:    }
   1: 
   1:    key[slength] = 0x00;
   1: 
   1:    for (text = key; *text; text++)
   1:       /* empty loop to find end of key */ ;
   1: 
   1:    if (text != key + slength)
   1:       text++;
   1: 
   1:    text_ptr = (png_textp)png_malloc_warn(png_ptr,
   1:       (png_uint_32)png_sizeof(png_text));
   1:    if (text_ptr == NULL)
   1:    {
   1:      png_warning(png_ptr, "Not enough memory to process text chunk.");
   1:      png_free(png_ptr, key);
   1:      return;
   1:    }
   1:    text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
   1:    text_ptr->key = key;
   1: #ifdef PNG_iTXt_SUPPORTED
   1:    text_ptr->lang = NULL;
   1:    text_ptr->lang_key = NULL;
   1:    text_ptr->itxt_length = 0;
   1: #endif
   1:    text_ptr->text = text;
   1:    text_ptr->text_length = png_strlen(text);
   1: 
   1:    ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
   1: 
   1:    png_free(png_ptr, key);
   1:    png_free(png_ptr, text_ptr);
   1:    if (ret)
   1:      png_warning(png_ptr, "Insufficient memory to process text chunk.");
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_zTXt_SUPPORTED)
   1: /* note: this does not correctly handle chunks that are > 64K under DOS */
   1: void /* PRIVATE */
   1: png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_textp text_ptr;
   1:    png_charp chunkdata;
   1:    png_charp text;
   1:    int comp_type;
   1:    int ret;
   1:    png_size_t slength, prefix_len, data_len;
   1: 
   1:    png_debug(1, "in png_handle_zTXt\n");
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before zTXt");
   1: 
   1:    if (png_ptr->mode & PNG_HAVE_IDAT)
   1:       png_ptr->mode |= PNG_AFTER_IDAT;
   1: 
   1: #ifdef PNG_MAX_MALLOC_64K
   1:    /* We will no doubt have problems with chunks even half this size, but
   1:       there is no hard and fast rule to tell us where to stop. */
   1:    if (length > (png_uint_32)65535L)
   1:    {
   1:      png_warning(png_ptr,"zTXt chunk too large to fit in memory");
   1:      png_crc_finish(png_ptr, length);
   1:      return;
   1:    }
   1: #endif
   1: 
   1:    chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   1:    if (chunkdata == NULL)
   1:    {
   1:      png_warning(png_ptr,"Out of memory processing zTXt chunk.");
   1:      return;
   1:    }
   1:    slength = (png_size_t)length;
   1:    png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
   1:    if (png_crc_finish(png_ptr, 0))
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       return;
   1:    }
   1: 
   1:    chunkdata[slength] = 0x00;
   1: 
   1:    for (text = chunkdata; *text; text++)
   1:       /* empty loop */ ;
   1: 
   1:    /* zTXt must have some text after the chunkdataword */
   1:    if (text == chunkdata + slength)
   1:    {
   1:       comp_type = PNG_TEXT_COMPRESSION_NONE;
   1:       png_warning(png_ptr, "Zero length zTXt chunk");
   1:    }
   1:    else
   1:    {
   1:        comp_type = *(++text);
   1:        if (comp_type != PNG_TEXT_COMPRESSION_zTXt)
   1:        {
   1:           png_warning(png_ptr, "Unknown compression type in zTXt chunk");
   1:           comp_type = PNG_TEXT_COMPRESSION_zTXt;
   1:        }
   1:        text++;        /* skip the compression_method byte */
   1:    }
   1:    prefix_len = text - chunkdata;
   1: 
   1:    chunkdata = (png_charp)png_decompress_chunk(png_ptr, comp_type, chunkdata,
   1:                                     (png_size_t)length, prefix_len, &data_len);
   1: 
   1:    text_ptr = (png_textp)png_malloc_warn(png_ptr,
   1:      (png_uint_32)png_sizeof(png_text));
   1:    if (text_ptr == NULL)
   1:    {
   1:      png_warning(png_ptr,"Not enough memory to process zTXt chunk.");
   1:      png_free(png_ptr, chunkdata);
   1:      return;
   1:    }
   1:    text_ptr->compression = comp_type;
   1:    text_ptr->key = chunkdata;
   1: #ifdef PNG_iTXt_SUPPORTED
   1:    text_ptr->lang = NULL;
   1:    text_ptr->lang_key = NULL;
   1:    text_ptr->itxt_length = 0;
   1: #endif
   1:    text_ptr->text = chunkdata + prefix_len;
   1:    text_ptr->text_length = data_len;
   1: 
   1:    ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
   1: 
   1:    png_free(png_ptr, text_ptr);
   1:    png_free(png_ptr, chunkdata);
   1:    if (ret)
   1:      png_error(png_ptr, "Insufficient memory to store zTXt chunk.");
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_iTXt_SUPPORTED)
   1: /* note: this does not correctly handle chunks that are > 64K under DOS */
   1: void /* PRIVATE */
   1: png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_textp text_ptr;
   1:    png_charp chunkdata;
   1:    png_charp key, lang, text, lang_key;
   1:    int comp_flag;
   1:    int comp_type = 0;
   1:    int ret;
   1:    png_size_t slength, prefix_len, data_len;
   1: 
   1:    png_debug(1, "in png_handle_iTXt\n");
   1: 
   1:    if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:       png_error(png_ptr, "Missing IHDR before iTXt");
   1: 
   1:    if (png_ptr->mode & PNG_HAVE_IDAT)
   1:       png_ptr->mode |= PNG_AFTER_IDAT;
   1: 
   1: #ifdef PNG_MAX_MALLOC_64K
   1:    /* We will no doubt have problems with chunks even half this size, but
   1:       there is no hard and fast rule to tell us where to stop. */
   1:    if (length > (png_uint_32)65535L)
   1:    {
   1:      png_warning(png_ptr,"iTXt chunk too large to fit in memory");
   1:      png_crc_finish(png_ptr, length);
   1:      return;
   1:    }
   1: #endif
   1: 
   1:    chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
   1:    if (chunkdata == NULL)
   1:    {
   1:      png_warning(png_ptr, "No memory to process iTXt chunk.");
   1:      return;
   1:    }
   1:    slength = (png_size_t)length;
   1:    png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
   1:    if (png_crc_finish(png_ptr, 0))
   1:    {
   1:       png_free(png_ptr, chunkdata);
   1:       return;
   1:    }
   1: 
   1:    chunkdata[slength] = 0x00;
   1: 
   1:    for (lang = chunkdata; *lang; lang++)
   1:       /* empty loop */ ;
   1:    lang++;        /* skip NUL separator */
   1: 
   1:    /* iTXt must have a language tag (possibly empty), two compression bytes,
   1:       translated keyword (possibly empty), and possibly some text after the
   1:       keyword */
   1: 
   1:    if (lang >= chunkdata + slength)
   1:    {
   1:       comp_flag = PNG_TEXT_COMPRESSION_NONE;
   1:       png_warning(png_ptr, "Zero length iTXt chunk");
   1:    }
   1:    else
   1:    {
   1:        comp_flag = *lang++;
   1:        comp_type = *lang++;
   1:    }
   1: 
   1:    for (lang_key = lang; *lang_key; lang_key++)
   1:       /* empty loop */ ;
   1:    lang_key++;        /* skip NUL separator */
   1: 
   1:    for (text = lang_key; *text; text++)
   1:       /* empty loop */ ;
   1:    text++;        /* skip NUL separator */
   1: 
   1:    prefix_len = text - chunkdata;
   1: 
   1:    key=chunkdata;
   1:    if (comp_flag)
   1:        chunkdata = png_decompress_chunk(png_ptr, comp_type, chunkdata,
   1:           (size_t)length, prefix_len, &data_len);
   1:    else
   1:        data_len=png_strlen(chunkdata + prefix_len);
   1:    text_ptr = (png_textp)png_malloc_warn(png_ptr,
   1:       (png_uint_32)png_sizeof(png_text));
   1:    if (text_ptr == NULL)
   1:    {
   1:      png_warning(png_ptr,"Not enough memory to process iTXt chunk.");
   1:      png_free(png_ptr, chunkdata);
   1:      return;
   1:    }
   1:    text_ptr->compression = (int)comp_flag + 1;
   1:    text_ptr->lang_key = chunkdata+(lang_key-key);
   1:    text_ptr->lang = chunkdata+(lang-key);
   1:    text_ptr->itxt_length = data_len;
   1:    text_ptr->text_length = 0;
   1:    text_ptr->key = chunkdata;
   1:    text_ptr->text = chunkdata + prefix_len;
   1: 
   1:    ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
   1: 
   1:    png_free(png_ptr, text_ptr);
   1:    png_free(png_ptr, chunkdata);
   1:    if (ret)
   1:      png_error(png_ptr, "Insufficient memory to store iTXt chunk.");
   1: }
   1: #endif
   1: 
   1: #if defined(PNG_READ_APNG_SUPPORTED)
   1: void /* PRIVATE */
   1: png_handle_acTL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:     png_byte data[8];
   1:     png_uint_32 num_frames;
 658:     png_uint_32 num_plays;
   1:     png_uint_32 didSet;
   1:     
   1:     png_debug(1, "in png_handle_acTL\n");
   1: 
   1:     if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:     {
   1:         png_error(png_ptr, "Missing IHDR before acTL");
   1:     }
   1:     else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:     {
   1:         png_warning(png_ptr, "Invalid acTL after IDAT skipped");
   1:         png_crc_finish(png_ptr, length);
   1:         return;
   1:     }
   1:     else if (png_ptr->mode & PNG_HAVE_acTL)
   1:     {
   1:         png_warning(png_ptr, "Duplicate acTL skipped");
   1:         png_crc_finish(png_ptr, length);
   1:         return;
   1:     }
   1:     else if (length != 8)
   1:     {
   1:         png_warning(png_ptr, "acTL with invalid length skipped");
   1:         png_crc_finish(png_ptr, length);
   1:         return;
   1:     }
   1:     
   1:     png_crc_read(png_ptr, data, 8);
   1:     png_crc_finish(png_ptr, 0);
   1:     
   1:     num_frames = png_get_uint_31(png_ptr, data);
 658:     num_plays = png_get_uint_31(png_ptr, data + 4);
   1:     
   1:     /* the set function will do error checking on num_frames */
 658:     didSet = png_set_acTL(png_ptr, info_ptr, num_frames, num_plays);
   1:     if(didSet)
   1:         png_ptr->mode |= PNG_HAVE_acTL;
   1: }
   1: 
   1: void /* PRIVATE */
   1: png_handle_fcTL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
  11:     png_byte data[22];
   1:     png_uint_32 width;
   1:     png_uint_32 height;
   1:     png_uint_32 x_offset;
   1:     png_uint_32 y_offset;
   1:     png_uint_16 delay_num;
   1:     png_uint_16 delay_den;
  11:     png_byte dispose_op;
  11:     png_byte blend_op;
   1:     
   1:     png_debug(1, "in png_handle_fcTL\n");
   1:     
   1:     if (!(png_ptr->mode & PNG_HAVE_IHDR))
   1:     {
   1:         png_error(png_ptr, "Missing IHDR before fcTL");
   1:     }
   1:     else if (png_ptr->mode & PNG_HAVE_IDAT)
   1:     {
   1:         /* for any frames other then the first this message may be misleading,
   1:         * but correct. PNG_HAVE_IDAT is unset before the frame head is read
   1:         * i can't think of a better message */
   1:         png_warning(png_ptr, "Invalid fcTL after IDAT skipped");
   1:         png_crc_finish(png_ptr, length);
   1:         return;
   1:     }
   1:     else if (png_ptr->mode & PNG_HAVE_fcTL)
   1:     {
   1:         png_warning(png_ptr, "Duplicate fcTL within one frame skipped");
   1:         png_crc_finish(png_ptr, length);
   1:         return;
   1:     }
  11:     else if (length != 26)
   1:     {
   1:         png_warning(png_ptr, "fcTL with invalid length skipped");
   1:         png_crc_finish(png_ptr, length);
   1:         return;
   1:     }
   1:     
   1:     png_ensure_sequence_number(png_ptr, length);
   1:     
  11:     png_crc_read(png_ptr, data, 22);
   1:     png_crc_finish(png_ptr, 0);
   1:     
   1:     width = png_get_uint_31(png_ptr, data);
   1:     height = png_get_uint_31(png_ptr, data + 4);
   1:     x_offset = png_get_uint_31(png_ptr, data + 8);
   1:     y_offset = png_get_uint_31(png_ptr, data + 12);
   1:     delay_num = png_get_uint_16(data + 16);
   1:     delay_den = png_get_uint_16(data + 18);
  11:     dispose_op = data[20];
  11:     blend_op = data[21];
   1:     
   1:     if (png_ptr->num_frames_read == 0 && (x_offset != 0 || y_offset != 0))
   1:         png_error(png_ptr, "fcTL for the first frame must have zero offset");
   1:     if (png_ptr->num_frames_read == 0 && 
   1:         (width != info_ptr->width || height != info_ptr->height))
   1:         png_error(png_ptr, "size in first frame's fcTL must match "
   1:                            "the size in IHDR");
   1:     
   1:     /* the set function will do more error checking */
   1:     png_set_next_frame_fcTL(png_ptr, info_ptr, width, height, 
   1:                             x_offset, y_offset, delay_num, delay_den,
  11:                             dispose_op, blend_op);
   1:     
   1:     png_read_reinit(png_ptr, info_ptr);
   1:     
   1:     png_ptr->mode |= PNG_HAVE_fcTL;
 658: }
 658: 
 658: void /* PRIVATE */
 658: png_have_info(png_structp png_ptr, png_infop info_ptr)
 658: {
 658:     if((info_ptr->valid & PNG_INFO_acTL) && !(info_ptr->valid & PNG_INFO_fcTL))
 658:     {
 658:         png_ptr->apng_flags |= PNG_FIRST_FRAME_HIDDEN;
 658:         info_ptr->num_frames++;
 658:     }
   1: }
   1: 
   1: void /* PRIVATE */
   1: png_handle_fdAT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:     png_ensure_sequence_number(png_ptr, length);
   1:     
   1:     /* This function is only called from png_read_end(), png_read_info(), 
   1:     * and png_push_read_chunk() which means that:
   1:     * - the user doesn't want to read this frame
   1:     * - or this is an out-of-place fdAT
   1:     * in either case it is safe to ignore the chunk with a warning */
   1:     png_warning(png_ptr, "ignoring fdAT chunk");
   1:     png_crc_finish(png_ptr, length - 4);
   1: }
   1: 
   1: void /* PRIVATE */
   1: png_ensure_sequence_number(png_structp png_ptr, png_uint_32 length)
   1: {
   1:     png_byte data[4];
   1:     png_uint_32 sequence_number;
   1:     
   1:     if (length < 4)
   1:         png_error(png_ptr, "invalid fcTL or fdAT chunk found");
   1:     
   1:     png_crc_read(png_ptr, data, 4);
   1:     sequence_number = png_get_uint_31(png_ptr, data);
   1:     
   1:     if (sequence_number != png_ptr->next_seq_num)
   1:         png_error(png_ptr, "fcTL or fdAT chunk with out-of-order sequence "
   1:                            "number found");
   1:     
   1:     png_ptr->next_seq_num++;
   1: }
   1: #endif /* PNG_READ_APNG_SUPPORTED */
   1: 
   1: /* This function is called when we haven't found a handler for a
   1:    chunk.  If there isn't a problem with the chunk itself (ie bad
   1:    chunk name, CRC, or a critical chunk), the chunk is silently ignored
   1:    -- unless the PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flag is on in which
   1:    case it will be saved away to be written out later. */
   1: void /* PRIVATE */
   1: png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
   1: {
   1:    png_uint_32 skip = 0;
   1: 
   1:    png_debug(1, "in png_handle_unknown\n");
   1: 
   1:    if (png_ptr->mode & PNG_HAVE_IDAT)
   1:    {
   1: #ifdef PNG_USE_LOCAL_ARRAYS
   1:       PNG_IDAT;
   1: #endif
   1:       if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* not an IDAT */
   1:          png_ptr->mode |= PNG_AFTER_IDAT;
   1:    }
   1: 
   1:    png_check_chunk_name(png_ptr, png_ptr->chunk_name);
   1: 
   1:    if (!(png_ptr->chunk_name[0] & 0x20))
   1:    {
   1: #if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   1:       if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
   1:            PNG_HANDLE_CHUNK_ALWAYS
   1: #if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
   1:            && png_ptr->read_user_chunk_fn == NULL
   1: #endif
   1:         )
   1: #endif
   1:           png_chunk_error(png_ptr, "unknown critical chunk");
   1:    }
   1: 
   1: #if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   1:    if ((png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS) ||
   1:        (png_ptr->read_user_chunk_fn != NULL))
   1:    {
   1:        png_unknown_chunk chunk;
   1: 
   1: #ifdef PNG_MAX_MALLOC_64K
   1:        if (length > (png_uint_32)65535L)
   1:        {
   1:            png_warning(png_ptr, "unknown chunk too large to fit in memory");
   1:            skip = length - (png_uint_32)65535L;
   1:            length = (png_uint_32)65535L;
   1:        }
   1: #endif
   1:        png_strcpy((png_charp)chunk.name, (png_charp)png_ptr->chunk_name);
   1:        chunk.data = (png_bytep)png_malloc(png_ptr, length);
   1:        chunk.size = (png_size_t)length;
   1:        png_crc_read(png_ptr, (png_bytep)chunk.data, length);
   1: #if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
   1:        if(png_ptr->read_user_chunk_fn != NULL)
   1:        {
   1:           /* callback to user unknown chunk handler */
   1:           if ((*(png_ptr->read_user_chunk_fn)) (png_ptr, &chunk) <= 0)
   1:           {
   1:              if (!(png_ptr->chunk_name[0] & 0x20))
   1:                 if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
   1:                      PNG_HANDLE_CHUNK_ALWAYS)
   1:                  {
   1:                    png_free(png_ptr, chunk.data);
   1:                    png_chunk_error(png_ptr, "unknown critical chunk");
   1:                  }
   1:              png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
   1:           }
   1:        }
   1:        else
   1: #endif
   1:           png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
   1:        png_free(png_ptr, chunk.data);
   1:    }
   1:    else
   1: #endif
   1:       skip = length;
   1: 
   1:    png_crc_finish(png_ptr, skip);
   1: 
   1: #if !defined(PNG_READ_USER_CHUNKS_SUPPORTED)
   1:    if (&info_ptr == NULL) /* quiet compiler warnings about unused info_ptr */
   1:       return;
   1: #endif
   1: }
   1: 
   1: /* This function is called to verify that a chunk name is valid.
   1:    This function can't have the "critical chunk check" incorporated
   1:    into it, since in the future we will need to be able to call user
   1:    functions to handle unknown critical chunks after we check that
   1:    the chunk name itself is valid. */
   1: 
   1: #define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
   1: 
   1: void /* PRIVATE */
   1: png_check_chunk_name(png_structp png_ptr, png_bytep chunk_name)
   1: {
   1:    png_debug(1, "in png_check_chunk_name\n");
   1:    if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||
   1:        isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))
   1:    {
   1:       png_chunk_error(png_ptr, "invalid chunk type");
   1:    }
   1: }
   1: 
   1: /* Combines the row recently read in with the existing pixels in the
   1:    row.  This routine takes care of alpha and transparency if requested.
   1:    This routine also handles the two methods of progressive display
   1:    of interlaced images, depending on the mask value.
   1:    The mask value describes which pixels are to be combined with
   1:    the row.  The pattern always repeats every 8 pixels, so just 8
   1:    bits are needed.  A one indicates the pixel is to be combined,
   1:    a zero indicates the pixel is to be skipped.  This is in addition
   1:    to any alpha or transparency value associated with the pixel.  If
   1:    you want all pixels to be combined, pass 0xff (255) in mask.  */
 499: #ifndef PNG_HAVE_MMX_COMBINE_ROW
   1: void /* PRIVATE */
   1: png_combine_row(png_structp png_ptr, png_bytep row, int mask)
   1: {
   1:    png_debug(1,"in png_combine_row\n");
   1:    if (mask == 0xff)
   1:    {
   1:       png_memcpy(row, png_ptr->row_buf + 1,
   1:          PNG_ROWBYTES(png_ptr->row_info.pixel_depth, png_ptr->width));
   1:    }
   1:    else
   1:    {
   1:       switch (png_ptr->row_info.pixel_depth)
   1:       {
   1:          case 1:
   1:          {
   1:             png_bytep sp = png_ptr->row_buf + 1;
   1:             png_bytep dp = row;
   1:             int s_inc, s_start, s_end;
   1:             int m = 0x80;
   1:             int shift;
   1:             png_uint_32 i;
   1:             png_uint_32 row_width = png_ptr->width;
   1: 
   1: #if defined(PNG_READ_PACKSWAP_SUPPORTED)
   1:             if (png_ptr->transformations & PNG_PACKSWAP)
   1:             {
   1:                 s_start = 0;
   1:                 s_end = 7;
   1:                 s_inc = 1;
   1:             }
   1:             else
   1: #endif
   1:             {
   1:                 s_start = 7;
   1:                 s_end = 0;
   1:                 s_inc = -1;
   1:             }
   1: 
   1:             shift = s_start;
   1: 
   1:             for (i = 0; i < row_width; i++)
   1:             {
   1:                if (m & mask)
   1:                {
   1:                   int value;
   1: 
   1:                   value = (*sp >> shift) & 0x01;
   1:                   *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
   1:                   *dp |= (png_byte)(value << shift);
   1:                }
   1: 
   1:                if (shift == s_end)
   1:                {
   1:                   shift = s_start;
   1:                   sp++;
   1:                   dp++;
   1:                }
   1:                else
   1:                   shift += s_inc;
   1: 
   1:                if (m == 1)
   1:                   m = 0x80;
   1:                else
   1:                   m >>= 1;
   1:             }
   1:             break;
   1:          }
   1:          case 2:
   1:          {
   1:             png_bytep sp = png_ptr->row_buf + 1;
   1:             png_bytep dp = row;
   1:             int s_start, s_end, s_inc;
   1:             int m = 0x80;
   1:             int shift;
   1:             png_uint_32 i;
   1:             png_uint_32 row_width = png_ptr->width;
   1:             int value;
   1: 
   1: #if defined(PNG_READ_PACKSWAP_SUPPORTED)
   1:             if (png_ptr->transformations & PNG_PACKSWAP)
   1:             {
   1:                s_start = 0;
   1:                s_end = 6;
   1:                s_inc = 2;
   1:             }
   1:             else
   1: #endif
   1:             {
   1:                s_start = 6;
   1:                s_end = 0;
   1:                s_inc = -2;
   1:             }
   1: 
   1:             shift = s_start;
   1: 
   1:             for (i = 0; i < row_width; i++)
   1:             {
   1:                if (m & mask)
   1:                {
   1:                   value = (*sp >> shift) & 0x03;
   1:                   *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
   1:                   *dp |= (png_byte)(value << shift);
   1:                }
   1: 
   1:                if (shift == s_end)
   1:                {
   1:                   shift = s_start;
   1:                   sp++;
   1:                   dp++;
   1:                }
   1:                else
   1:                   shift += s_inc;
   1:                if (m == 1)
   1:                   m = 0x80;
   1:                else
   1:                   m >>= 1;
   1:             }
   1:             break;
   1:          }
   1:          case 4:
   1:          {
   1:             png_bytep sp = png_ptr->row_buf + 1;
   1:             png_bytep dp = row;
   1:             int s_start, s_end, s_inc;
   1:             int m = 0x80;
   1:             int shift;
   1:             png_uint_32 i;
   1:             png_uint_32 row_width = png_ptr->width;
   1:             int value;
   1: 
   1: #if defined(PNG_READ_PACKSWAP_SUPPORTED)
   1:             if (png_ptr->transformations & PNG_PACKSWAP)
   1:             {
   1:                s_start = 0;
   1:                s_end = 4;
   1:                s_inc = 4;
   1:             }
   1:             else
   1: #endif
   1:             {
   1:                s_start = 4;
   1:                s_end = 0;
   1:                s_inc = -4;
   1:             }
   1:             shift = s_start;
   1: 
   1:             for (i = 0; i < row_width; i++)
   1:             {
   1:                if (m & mask)
   1:                {
   1:                   value = (*sp >> shift) & 0xf;
   1:                   *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
   1:                   *dp |= (png_byte)(value << shift);
   1:                }
   1: 
   1:                if (shift == s_end)
   1:                {
   1:                   shift = s_start;
   1:                   sp++;
   1:                   dp++;
   1:                }
   1:                else
   1:                   shift += s_inc;
   1:                if (m == 1)
   1:                   m = 0x80;
   1:                else
   1:                   m >>= 1;
   1:             }
   1:             break;
   1:          }
   1:          default:
   1:          {
   1:             png_bytep sp = png_ptr->row_buf + 1;
   1:             png_bytep dp = row;
   1:             png_size_t pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
   1:             png_uint_32 i;
   1:             png_uint_32 row_width = png_ptr->width;
   1:             png_byte m = 0x80;
   1: 
   1: 
   1:             for (i = 0; i < row_width; i++)
   1:             {
   1:                if (m & mask)
   1:                {
   1:                   png_memcpy(dp, sp, pixel_bytes);
   1:                }
   1: 
   1:                sp += pixel_bytes;
   1:                dp += pixel_bytes;
   1: 
   1:                if (m == 1)
   1:                   m = 0x80;
   1:                else
   1:                   m >>= 1;
   1:             }
   1:             break;
   1:          }
   1:       }
   1:    }
   1: }
 499: #endif /* !PNG_HAVE_MMX_COMBINE_ROW */
   1: 
   1: #ifdef PNG_READ_INTERLACING_SUPPORTED
 499: #ifndef PNG_HAVE_MMX_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
   1: /* OLD pre-1.0.9 interface:
   1: void png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
   1:    png_uint_32 transformations)
   1:  */
   1: void /* PRIVATE */
   1: png_do_read_interlace(png_structp png_ptr)
   1: {
   1:    png_row_infop row_info = &(png_ptr->row_info);
   1:    png_bytep row = png_ptr->row_buf + 1;
   1:    int pass = png_ptr->pass;
   1:    png_uint_32 transformations = png_ptr->transformations;
   1: #ifdef PNG_USE_LOCAL_ARRAYS
   1:    /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   1:    /* offset to next interlace block */
   1:    const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
   1: #endif
   1: 
   1:    png_debug(1,"in png_do_read_interlace (stock C version)\n");
   1:    if (row != NULL && row_info != NULL)
   1:    {
   1:       png_uint_32 final_width;
   1: 
   1:       final_width = row_info->width * png_pass_inc[pass];
   1: 
   1:       switch (row_info->pixel_depth)
   1:       {
   1:          case 1:
   1:          {
   1:             png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
   1:             png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
   1:             int sshift, dshift;
   1:             int s_start, s_end, s_inc;
   1:             int jstop = png_pass_inc[pass];
   1:             png_byte v;
   1:             png_uint_32 i;
   1:             int j;
   1: 
   1: #if defined(PNG_READ_PACKSWAP_SUPPORTED)
   1:             if (transformations & PNG_PACKSWAP)
   1:             {
   1:                 sshift = (int)((row_info->width + 7) & 0x07);
   1:                 dshift = (int)((final_width + 7) & 0x07);
   1:                 s_start = 7;
   1:                 s_end = 0;
   1:                 s_inc = -1;
   1:             }
   1:             else
   1: #endif
   1:             {
   1:                 sshift = 7 - (int)((row_info->width + 7) & 0x07);
   1:                 dshift = 7 - (int)((final_width + 7) & 0x07);
   1:                 s_start = 0;
   1:                 s_end = 7;
   1:                 s_inc = 1;
   1:             }
   1: 
   1:             for (i = 0; i < row_info->width; i++)
   1:             {
   1:                v = (png_byte)((*sp >> sshift) & 0x01);
   1:                for (j = 0; j < jstop; j++)
   1:                {
   1:                   *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
   1:                   *dp |= (png_byte)(v << dshift);
   1:                   if (dshift == s_end)
   1:                   {
   1:                      dshift = s_start;
   1:                      dp--;
   1:                   }
   1:                   else
   1:                      dshift += s_inc;
   1:                }
   1:                if (sshift == s_end)
   1:                {
   1:                   sshift = s_start;
   1:                   sp--;
   1:                }
   1:                else
   1:                   sshift += s_inc;
   1:             }
   1:             break;
   1:          }
   1:          case 2:
   1:          {
   1:             png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
   1:             png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
   1:             int sshift, dshift;
   1:             int s_start, s_end, s_inc;
   1:             int jstop = png_pass_inc[pass];
   1:             png_uint_32 i;
   1: 
   1: #if defined(PNG_READ_PACKSWAP_SUPPORTED)
   1:             if (transformations & PNG_PACKSWAP)
   1:             {
   1:                sshift = (int)(((row_info->width + 3) & 0x03) << 1);
   1:                dshift = (int)(((final_width + 3) & 0x03) << 1);
   1:                s_start = 6;
   1:                s_end = 0;
   1:                s_inc = -2;
   1:             }
   1:             else
   1: #endif
   1:             {
   1:                sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
   1:                dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);
   1:                s_start = 0;
   1:                s_end = 6;
   1:                s_inc = 2;
   1:             }
   1: 
   1:             for (i = 0; i < row_info->width; i++)
   1:             {
   1:                png_byte v;
   1:                int j;
   1: 
   1:                v = (png_byte)((*sp >> sshift) & 0x03);
   1:                for (j = 0; j < jstop; j++)
   1:                {
   1:                   *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
   1:                   *dp |= (png_byte)(v << dshift);
   1:                   if (dshift == s_end)
   1:                   {
   1:                      dshift = s_start;
   1:                      dp--;
   1:                   }
   1:                   else
   1:                      dshift += s_inc;
   1:                }
   1:                if (sshift == s_end)
   1:                {
   1:                   sshift = s_start;
   1:                   sp--;
   1:                }
   1:                else
   1:                   sshift += s_inc;
   1:             }
   1:             break;
   1:          }
   1:          case 4:
   1:          {
   1:             png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
   1:             png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
   1:             int sshift, dshift;
   1:             int s_start, s_end, s_inc;
   1:             png_uint_32 i;
   1:             int jstop = png_pass_inc[pass];
   1: 
   1: #if defined(PNG_READ_PACKSWAP_SUPPORTED)
   1:             if (transformations & PNG_PACKSWAP)
   1:             {
   1:                sshift = (int)(((row_info->width + 1) & 0x01) << 2);
   1:                dshift = (int)(((final_width + 1) & 0x01) << 2);
   1:                s_start = 4;
   1:                s_end = 0;
   1:                s_inc = -4;
   1:             }
   1:             else
   1: #endif
   1:             {
   1:                sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
   1:                dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);
   1:                s_start = 0;
   1:                s_end = 4;
   1:                s_inc = 4;
   1:             }
   1: 
   1:             for (i = 0; i < row_info->width; i++)
   1:             {
   1:                png_byte v = (png_byte)((*sp >> sshift) & 0xf);
   1:                int j;
   1: 
   1:                for (j = 0; j < jstop; j++)
   1:                {
   1:                   *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
   1:                   *dp |= (png_byte)(v << dshift);
   1:                   if (dshift == s_end)
   1:                   {
   1:                      dshift = s_start;
   1:                      dp--;
   1:                   }
   1:                   else
   1:                      dshift += s_inc;
   1:                }
   1:                if (sshift == s_end)
   1:                {
   1:                   sshift = s_start;
   1:                   sp--;
   1:                }
   1:                else
   1:                   sshift += s_inc;
   1:             }
   1:             break;
   1:          }
   1:          default:
   1:          {
   1:             png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
   1:             png_bytep sp = row + (png_size_t)(row_info->width - 1) * pixel_bytes;
   1:             png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;
   1: 
   1:             int jstop = png_pass_inc[pass];
   1:             png_uint_32 i;
   1: 
   1:             for (i = 0; i < row_info->width; i++)
   1:             {
   1:                png_byte v[8];
   1:                int j;
   1: 
   1:                png_memcpy(v, sp, pixel_bytes);
   1:                for (j = 0; j < jstop; j++)
   1:                {
   1:                   png_memcpy(dp, v, pixel_bytes);
   1:                   dp -= pixel_bytes;
   1:                }
   1:                sp -= pixel_bytes;
   1:             }
   1:             break;
   1:          }
   1:       }
   1:       row_info->width = final_width;
   1:       row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,final_width);
   1:    }
   1: #if !defined(PNG_READ_PACKSWAP_SUPPORTED)
   1:    if (&transformations == NULL) /* silence compiler warning */
   1:       return;
   1: #endif
   1: }
 499: #endif /* !PNG_HAVE_MMX_READ_INTERLACE */
   1: #endif /* PNG_READ_INTERLACING_SUPPORTED */
   1: 
 499: #ifndef PNG_HAVE_MMX_READ_FILTER_ROW
   1: void /* PRIVATE */
   1: png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
   1:    png_bytep prev_row, int filter)
   1: {
   1:    png_debug(1, "in png_read_filter_row\n");
   1:    png_debug2(2,"row = %lu, filter = %d\n", png_ptr->row_number, filter);
   1:    switch (filter)
   1:    {
   1:       case PNG_FILTER_VALUE_NONE:
   1:          break;
   1:       case PNG_FILTER_VALUE_SUB:
   1:       {
   1:          png_uint_32 i;
   1:          png_uint_32 istop = row_info->rowbytes;
   1:          png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
   1:          png_bytep rp = row + bpp;
   1:          png_bytep lp = row;
   1: 
   1:          for (i = bpp; i < istop; i++)
   1:          {
   1:             *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
   1:             rp++;
   1:          }
   1:          break;
   1:       }
   1:       case PNG_FILTER_VALUE_UP:
   1:       {
   1:          png_uint_32 i;
   1:          png_uint_32 istop = row_info->rowbytes;
   1:          png_bytep rp = row;
   1:          png_bytep pp = prev_row;
   1: 
   1:          for (i = 0; i < istop; i++)
   1:          {
   1:             *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
   1:             rp++;
   1:          }
   1:          break;
   1:       }
   1:       case PNG_FILTER_VALUE_AVG:
   1:       {
   1:          png_uint_32 i;
   1:          png_bytep rp = row;
   1:          png_bytep pp = prev_row;
   1:          png_bytep lp = row;
   1:          png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
   1:          png_uint_32 istop = row_info->rowbytes - bpp;
   1: 
   1:          for (i = 0; i < bpp; i++)
   1:          {
   1:             *rp = (png_byte)(((int)(*rp) +
   1:                ((int)(*pp++) / 2 )) & 0xff);
   1:             rp++;
   1:          }
   1: 
   1:          for (i = 0; i < istop; i++)
   1:          {
   1:             *rp = (png_byte)(((int)(*rp) +
   1:                (int)(*pp++ + *lp++) / 2 ) & 0xff);
   1:             rp++;
   1:          }
   1:          break;
   1:       }
   1:       case PNG_FILTER_VALUE_PAETH:
   1:       {
   1:          png_uint_32 i;
   1:          png_bytep rp = row;
   1:          png_bytep pp = prev_row;
   1:          png_bytep lp = row;
   1:          png_bytep cp = prev_row;
   1:          png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
   1:          png_uint_32 istop=row_info->rowbytes - bpp;
   1: 
   1:          for (i = 0; i < bpp; i++)
   1:          {
   1:             *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
   1:             rp++;
   1:          }
   1: 
   1:          for (i = 0; i < istop; i++)   /* use leftover rp,pp */
   1:          {
   1:             int a, b, c, pa, pb, pc, p;
   1: 
   1:             a = *lp++;
   1:             b = *pp++;
   1:             c = *cp++;
   1: 
   1:             p = b - c;
   1:             pc = a - c;
   1: 
   1: #ifdef PNG_USE_ABS
   1:             pa = abs(p);
   1:             pb = abs(pc);
   1:             pc = abs(p + pc);
   1: #else
   1:             pa = p < 0 ? -p : p;
   1:             pb = pc < 0 ? -pc : pc;
   1:             pc = (p + pc) < 0 ? -(p + pc) : p + pc;
   1: #endif
   1: 
   1:             /*
   1:                if (pa <= pb && pa <= pc)
   1:                   p = a;
   1:                else if (pb <= pc)
   1:                   p = b;
   1:                else
   1:                   p = c;
   1:              */
   1: 
   1:             p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
   1: 
   1:             *rp = (png_byte)(((int)(*rp) + p) & 0xff);
   1:             rp++;
   1:          }
   1:          break;
   1:       }
   1:       default:
   1:          png_warning(png_ptr, "Ignoring bad adaptive filter type");
   1:          *row=0;
   1:          break;
   1:    }
   1: }
 499: #endif /* !PNG_HAVE_MMX_READ_FILTER_ROW */
   1: 
   1: void /* PRIVATE */
   1: png_read_finish_row(png_structp png_ptr)
   1: {
   1: #ifdef PNG_USE_LOCAL_ARRAYS
   1:    /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   1: 
   1:    /* start of interlace block */
   1:    const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
   1: 
   1:    /* offset to next interlace block */
   1:    const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
   1: 
   1:    /* start of interlace block in the y direction */
   1:    const int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
   1: 
   1:    /* offset to next interlace block in the y direction */
   1:    const int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
   1: #endif
   1: 
   1:    png_debug(1, "in png_read_finish_row\n");
   1:    png_ptr->row_number++;
   1:    if (png_ptr->row_number < png_ptr->num_rows)
   1:       return;
   1: 
   1:    if (png_ptr->interlaced)
   1:    {
   1:       png_ptr->row_number = 0;
   1:       png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
   1:       do
   1:       {
   1:          png_ptr->pass++;
   1:          if (png_ptr->pass >= 7)
   1:             break;
   1:          png_ptr->iwidth = (png_ptr->width +
   1:             png_pass_inc[png_ptr->pass] - 1 -
   1:             png_pass_start[png_ptr->pass]) /
   1:             png_pass_inc[png_ptr->pass];
   1: 
   1:          png_ptr->irowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,
   1:             png_ptr->iwidth) + 1;
   1: 
   1:          if (!(png_ptr->transformations & PNG_INTERLACE))
   1:          {
   1:             png_ptr->num_rows = (png_ptr->height +
   1:                png_pass_yinc[png_ptr->pass] - 1 -
   1:                png_pass_ystart[png_ptr->pass]) /
   1:                png_pass_yinc[png_ptr->pass];
   1:             if (!(png_ptr->num_rows))
   1:                continue;
   1:          }
   1:          else  /* if (png_ptr->transformations & PNG_INTERLACE) */
   1:             break;
   1:       } while (png_ptr->iwidth == 0);
   1: 
   1:       if (png_ptr->pass < 7)
   1:          return;
   1:    }
   1: 
   1:    if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
   1:    {
   1: #ifdef PNG_USE_LOCAL_ARRAYS
   1:       PNG_IDAT;
   1: #endif
   1:       char extra;
   1:       int ret;
   1: 
   1:       png_ptr->zstream.next_out = (Byte *)&extra;
   1:       png_ptr->zstream.avail_out = (uInt)1;
   1:       for(;;)
   1:       {
   1:          if (!(png_ptr->zstream.avail_in))
   1:          {
   1:             while (!png_ptr->idat_size)
   1:             {
   1:                png_byte chunk_length[4];
   1: 
   1:                png_crc_finish(png_ptr, 0);
   1: 
   1:                png_read_data(png_ptr, chunk_length, 4);
   1:                png_ptr->idat_size = png_get_uint_31(png_ptr, chunk_length);
   1:                png_reset_crc(png_ptr);
   1:                png_crc_read(png_ptr, png_ptr->chunk_name, 4);
   1:                if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
   1:                   png_error(png_ptr, "Not enough image data");
   1: 
   1:             }
   1:             png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
   1:             png_ptr->zstream.next_in = png_ptr->zbuf;
   1:             if (png_ptr->zbuf_size > png_ptr->idat_size)
   1:                png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
   1:             png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zstream.avail_in);
   1:             png_ptr->idat_size -= png_ptr->zstream.avail_in;
   1:          }
   1:          ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
   1:          if (ret == Z_STREAM_END)
   1:          {
   1:             if (!(png_ptr->zstream.avail_out) || png_ptr->zstream.avail_in ||
   1:                png_ptr->idat_size)
   1:                png_warning(png_ptr, "Extra compressed data");
   1:             png_ptr->mode |= PNG_AFTER_IDAT;
   1:             png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
   1:             break;
   1:          }
   1:          if (ret != Z_OK)
   1:             png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
   1:                       "Decompression Error");
   1: 
   1:          if (!(png_ptr->zstream.avail_out))
   1:          {
   1:             png_warning(png_ptr, "Extra compressed data.");
   1:             png_ptr->mode |= PNG_AFTER_IDAT;
   1:             png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
   1:             break;
   1:          }
   1: 
   1:       }
   1:       png_ptr->zstream.avail_out = 0;
   1:    }
   1: 
   1:    if (png_ptr->idat_size || png_ptr->zstream.avail_in)
   1:       png_warning(png_ptr, "Extra compression data");
   1: 
   1:    inflateReset(&png_ptr->zstream);
   1: 
   1:    png_ptr->mode |= PNG_AFTER_IDAT;
   1: }
   1: 
   1: void /* PRIVATE */
   1: png_read_start_row(png_structp png_ptr)
   1: {
   1: #ifdef PNG_USE_LOCAL_ARRAYS
   1:    /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   1: 
   1:    /* start of interlace block */
   1:    const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
   1: 
   1:    /* offset to next interlace block */
   1:    const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
   1: 
   1:    /* start of interlace block in the y direction */
   1:    const int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
   1: 
   1:    /* offset to next interlace block in the y direction */
   1:    const int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
   1: #endif
   1: 
   1:    int max_pixel_depth;
   1:    png_uint_32 row_bytes;
   1: 
   1:    png_debug(1, "in png_read_start_row\n");
   1:    png_ptr->zstream.avail_in = 0;
   1:    png_init_read_transformations(png_ptr);
   1:    if (png_ptr->interlaced)
   1:    {
   1:       if (!(png_ptr->transformations & PNG_INTERLACE))
   1:          png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
   1:             png_pass_ystart[0]) / png_pass_yinc[0];
   1:       else
   1:          png_ptr->num_rows = png_ptr->height;
   1: 
   1:       png_ptr->iwidth = (png_ptr->width +
   1:          png_pass_inc[png_ptr->pass] - 1 -
   1:          png_pass_start[png_ptr->pass]) /
   1:          png_pass_inc[png_ptr->pass];
   1: 
   1:          row_bytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->iwidth) + 1;
   1: 
   1:          png_ptr->irowbytes = (png_size_t)row_bytes;
   1:          if((png_uint_32)png_ptr->irowbytes != row_bytes)
   1:             png_error(png_ptr, "Rowbytes overflow in png_read_start_row");
   1:    }
   1:    else
   1:    {
   1:       png_ptr->num_rows = png_ptr->height;
   1:       png_ptr->iwidth = png_ptr->width;
   1:       png_ptr->irowbytes = png_ptr->rowbytes + 1;
   1:    }
   1:    max_pixel_depth = png_ptr->pixel_depth;
   1: 
   1: #if defined(PNG_READ_PACK_SUPPORTED)
   1:    if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)
   1:       max_pixel_depth = 8;
   1: #endif
   1: 
   1: #if defined(PNG_READ_EXPAND_SUPPORTED)
   1:    if (png_ptr->transformations & PNG_EXPAND)
   1:    {
   1:       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   1:       {
   1:          if (png_ptr->num_trans)
   1:             max_pixel_depth = 32;
   1:          else
   1:             max_pixel_depth = 24;
   1:       }
   1:       else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
   1:       {
   1:          if (max_pixel_depth < 8)
   1:             max_pixel_depth = 8;
   1:          if (png_ptr->num_trans)
   1:             max_pixel_depth *= 2;
   1:       }
   1:       else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   1:       {
   1:          if (png_ptr->num_trans)
   1:          {
   1:             max_pixel_depth *= 4;
   1:             max_pixel_depth /= 3;
   1:          }
   1:       }
   1:    }
   1: #endif
   1: 
   1: #if defined(PNG_READ_FILLER_SUPPORTED)
   1:    if (png_ptr->transformations & (PNG_FILLER))
   1:    {
   1:       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   1:          max_pixel_depth = 32;
   1:       else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
   1:       {
   1:          if (max_pixel_depth <= 8)
   1:             max_pixel_depth = 16;
   1:          else
   1:             max_pixel_depth = 32;
   1:       }
   1:       else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   1:       {
   1:          if (max_pixel_depth <= 32)
   1:             max_pixel_depth = 32;
   1:          else
   1:             max_pixel_depth = 64;
   1:       }
   1:    }
   1: #endif
   1: 
   1: #if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   1:    if (png_ptr->transformations & PNG_GRAY_TO_RGB)
   1:    {
   1:       if (
   1: #if defined(PNG_READ_EXPAND_SUPPORTED)
   1:         (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND)) ||
   1: #endif
   1: #if defined(PNG_READ_FILLER_SUPPORTED)
   1:         (png_ptr->transformations & (PNG_FILLER)) ||
   1: #endif
   1:         png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
   1:       {
   1:          if (max_pixel_depth <= 16)
   1:             max_pixel_depth = 32;
   1:          else
   1:             max_pixel_depth = 64;
   1:       }
   1:       else
   1:       {
   1:          if (max_pixel_depth <= 8)
   1:            {
   1:              if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
   1:                max_pixel_depth = 32;
   1:              else
   1:                max_pixel_depth = 24;
   1:            }
   1:          else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
   1:             max_pixel_depth = 64;
   1:          else
   1:             max_pixel_depth = 48;
   1:       }
   1:    }
   1: #endif
   1: 
   1: #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
   1: defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
   1:    if(png_ptr->transformations & PNG_USER_TRANSFORM)
   1:      {
   1:        int user_pixel_depth=png_ptr->user_transform_depth*
   1:          png_ptr->user_transform_channels;
   1:        if(user_pixel_depth > max_pixel_depth)
   1:          max_pixel_depth=user_pixel_depth;
   1:      }
   1: #endif
   1: 
   1:    /* align the width on the next larger 8 pixels.  Mainly used
   1:       for interlacing */
   1:    row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
   1:    /* calculate the maximum bytes needed, adding a byte and a pixel
   1:       for safety's sake */
   1:    row_bytes = PNG_ROWBYTES(max_pixel_depth,row_bytes) +
   1:       1 + ((max_pixel_depth + 7) >> 3);
   1: #ifdef PNG_MAX_MALLOC_64K
   1:    if (row_bytes > (png_uint_32)65536L)
   1:       png_error(png_ptr, "This image requires a row greater than 64KB");
   1: #endif
   1:    if (png_ptr->big_row_buf == NULL)
   1:       png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes+64);
   1:    if (png_ptr->row_buf == NULL)
   1:       png_ptr->row_buf = png_ptr->big_row_buf+32;
   1: #if defined(PNG_DEBUG) && defined(PNG_USE_PNGGCCRD)
   1:    png_ptr->row_buf_size = row_bytes;
   1: #endif
   1: 
   1: #ifdef PNG_MAX_MALLOC_64K
   1:    if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
   1:       png_error(png_ptr, "This image requires a row greater than 64KB");
   1: #endif
 499:    if ((png_uint_32)png_ptr->rowbytes > (png_uint_32)(PNG_SIZE_MAX - 1))
   1:       png_error(png_ptr, "Row has too many bytes to allocate in memory.");
   1:    png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
   1:       png_ptr->rowbytes + 1));
   1: 
   1:    png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
   1: 
   1:    png_debug1(3, "width = %lu,\n", png_ptr->width);
   1:    png_debug1(3, "height = %lu,\n", png_ptr->height);
   1:    png_debug1(3, "iwidth = %lu,\n", png_ptr->iwidth);
   1:    png_debug1(3, "num_rows = %lu\n", png_ptr->num_rows);
   1:    png_debug1(3, "rowbytes = %lu,\n", png_ptr->rowbytes);
   1:    png_debug1(3, "irowbytes = %lu,\n", png_ptr->irowbytes);
   1: 
   1:    png_ptr->flags |= PNG_FLAG_ROW_INIT;
   1: }
   1: 
   1: #if defined(PNG_READ_APNG_SUPPORTED)
   1: /* This function is to be called after the main IDAT set has been read and
   1:  * before a new IDAT is read. It resets some parts of png_ptr
   1:  * to make them usable by the read functions again */
   1: void /* PRIVATE */
   1: png_read_reset(png_structp png_ptr)
   1: {
   1:     png_ptr->mode &= ~PNG_HAVE_IDAT;
   1:     png_ptr->mode &= ~PNG_AFTER_IDAT;
   1:     png_ptr->row_number = 0;
   1:     png_ptr->pass = 0;
   1:     png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
   1: }
   1: 
   1: void /* PRIVATE */
   1: png_read_reinit(png_structp png_ptr, png_infop info_ptr)
   1: {
   1:     png_ptr->width = info_ptr->next_frame_width;
   1:     png_ptr->height = info_ptr->next_frame_height;
   1:     png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->width);
   1: }
   1: 
   1: /* same as png_read_reset() but for the progressive reader */
   1: void /* PRIVATE */
   1: png_progressive_read_reset(png_structp png_ptr)
   1: {
   1: #ifdef PNG_USE_LOCAL_ARRAYS
   1:     /* start of interlace block */
   1:     const int FARDATA png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
   1: 
   1:     /* offset to next interlace block */
   1:     const int FARDATA png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
   1: 
   1:     /* start of interlace block in the y direction */
   1:     const int FARDATA png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
   1: 
   1:     /* offset to next interlace block in the y direction */
   1:     const int FARDATA png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
   1: #endif
   1:     png_uint_32 row_bytes;
   1:     
   1:     if (png_ptr->interlaced)
   1:     {
   1:         if (!(png_ptr->transformations & PNG_INTERLACE))
   1:             png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
   1:                                 png_pass_ystart[0]) / png_pass_yinc[0];
   1:         else
   1:            png_ptr->num_rows = png_ptr->height;
   1: 
   1:         png_ptr->iwidth = (png_ptr->width +
   1:                            png_pass_inc[png_ptr->pass] - 1 -
   1:                            png_pass_start[png_ptr->pass]) /
   1:                            png_pass_inc[png_ptr->pass];
   1: 
   1:         row_bytes = PNG_ROWBYTES(png_ptr->pixel_depth,png_ptr->iwidth) + 1;
   1: 
   1:         png_ptr->irowbytes = (png_size_t)row_bytes;
   1:         if((png_uint_32)png_ptr->irowbytes != row_bytes)
   1:             png_error(png_ptr, "png_progressive_read_reset(): Rowbytes "
   1:                                "overflow");
   1:     }
   1:     else
   1:     {
   1:         png_ptr->num_rows = png_ptr->height;
   1:         png_ptr->iwidth = png_ptr->width;
   1:         png_ptr->irowbytes = png_ptr->rowbytes + 1;
   1:     }
   1:     
   1:     png_ptr->flags &= ~PNG_FLAG_ZLIB_FINISHED;
   1:     if (inflateReset(&(png_ptr->zstream)) != Z_OK)
   1:         png_error(png_ptr, "inflateReset failed");
   1:     png_ptr->zstream.avail_in = 0;
   1:     png_ptr->zstream.next_in = 0;
   1:     png_ptr->zstream.next_out = png_ptr->row_buf;
   1:     png_ptr->zstream.avail_out = (uInt)png_ptr->irowbytes;
   1: }
   1: #endif /* PNG_READ_APNG_SUPPORTED */
   1: #endif /* PNG_READ_SUPPORTED */
