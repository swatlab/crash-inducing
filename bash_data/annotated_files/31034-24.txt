16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: bitrate tracking and management
31034:  last mod: $Id: bitrate.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: #include <stdlib.h>
16295: #include <string.h>
16295: #include <math.h>
16295: #include <ogg/ogg.h>
16295: #include "vorbis/codec.h"
16295: #include "codec_internal.h"
16295: #include "os.h"
16295: #include "misc.h"
16295: #include "bitrate.h"
16295: 
16295: /* compute bitrate tracking setup  */
16295: void vorbis_bitrate_init(vorbis_info *vi,bitrate_manager_state *bm){
16295:   codec_setup_info *ci=vi->codec_setup;
16295:   bitrate_manager_info *bi=&ci->bi;
16295: 
16295:   memset(bm,0,sizeof(*bm));
16295: 
16295:   if(bi && (bi->reservoir_bits>0)){
16295:     long ratesamples=vi->rate;
16295:     int  halfsamples=ci->blocksizes[0]>>1;
16295: 
16295:     bm->short_per_long=ci->blocksizes[1]/ci->blocksizes[0];
16295:     bm->managed=1;
16295: 
16295:     bm->avg_bitsper= rint(1.*bi->avg_rate*halfsamples/ratesamples);
16295:     bm->min_bitsper= rint(1.*bi->min_rate*halfsamples/ratesamples);
16295:     bm->max_bitsper= rint(1.*bi->max_rate*halfsamples/ratesamples);
16295: 
16295:     bm->avgfloat=PACKETBLOBS/2;
16295: 
16295:     /* not a necessary fix, but one that leads to a more balanced
16295:        typical initialization */
16295:     {
16295:       long desired_fill=bi->reservoir_bits*bi->reservoir_bias;
16295:       bm->minmax_reservoir=desired_fill;
16295:       bm->avg_reservoir=desired_fill;
16295:     }
16295: 
16295:   }
16295: }
16295: 
16295: void vorbis_bitrate_clear(bitrate_manager_state *bm){
16295:   memset(bm,0,sizeof(*bm));
16295:   return;
16295: }
16295: 
16295: int vorbis_bitrate_managed(vorbis_block *vb){
16295:   vorbis_dsp_state      *vd=vb->vd;
16295:   private_state         *b=vd->backend_state;
16295:   bitrate_manager_state *bm=&b->bms;
16295: 
16295:   if(bm && bm->managed)return(1);
16295:   return(0);
16295: }
16295: 
16295: /* finish taking in the block we just processed */
16295: int vorbis_bitrate_addblock(vorbis_block *vb){
16295:   vorbis_block_internal *vbi=vb->internal;
16295:   vorbis_dsp_state      *vd=vb->vd;
16295:   private_state         *b=vd->backend_state;
16295:   bitrate_manager_state *bm=&b->bms;
16295:   vorbis_info           *vi=vd->vi;
16295:   codec_setup_info      *ci=vi->codec_setup;
16295:   bitrate_manager_info  *bi=&ci->bi;
16295: 
16295:   int  choice=rint(bm->avgfloat);
16295:   long this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
16295:   long min_target_bits=(vb->W?bm->min_bitsper*bm->short_per_long:bm->min_bitsper);
16295:   long max_target_bits=(vb->W?bm->max_bitsper*bm->short_per_long:bm->max_bitsper);
16295:   int  samples=ci->blocksizes[vb->W]>>1;
16295:   long desired_fill=bi->reservoir_bits*bi->reservoir_bias;
16295:   if(!bm->managed){
16295:     /* not a bitrate managed stream, but for API simplicity, we'll
16295:        buffer the packet to keep the code path clean */
16295: 
16295:     if(bm->vb)return(-1); /* one has been submitted without
16295:                              being claimed */
16295:     bm->vb=vb;
16295:     return(0);
16295:   }
16295: 
16295:   bm->vb=vb;
16295: 
16295:   /* look ahead for avg floater */
16295:   if(bm->avg_bitsper>0){
16295:     double slew=0.;
16295:     long avg_target_bits=(vb->W?bm->avg_bitsper*bm->short_per_long:bm->avg_bitsper);
16295:     double slewlimit= 15./bi->slew_damp;
16295: 
16295:     /* choosing a new floater:
16295:        if we're over target, we slew down
16295:        if we're under target, we slew up
16295: 
16295:        choose slew as follows: look through packetblobs of this frame
16295:        and set slew as the first in the appropriate direction that
16295:        gives us the slew we want.  This may mean no slew if delta is
16295:        already favorable.
16295: 
16295:        Then limit slew to slew max */
16295: 
16295:     if(bm->avg_reservoir+(this_bits-avg_target_bits)>desired_fill){
16295:       while(choice>0 && this_bits>avg_target_bits &&
16295:             bm->avg_reservoir+(this_bits-avg_target_bits)>desired_fill){
16295:         choice--;
16295:         this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
16295:       }
16295:     }else if(bm->avg_reservoir+(this_bits-avg_target_bits)<desired_fill){
16295:       while(choice+1<PACKETBLOBS && this_bits<avg_target_bits &&
16295:             bm->avg_reservoir+(this_bits-avg_target_bits)<desired_fill){
16295:         choice++;
16295:         this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
16295:       }
16295:     }
16295: 
16295:     slew=rint(choice-bm->avgfloat)/samples*vi->rate;
16295:     if(slew<-slewlimit)slew=-slewlimit;
16295:     if(slew>slewlimit)slew=slewlimit;
16295:     choice=rint(bm->avgfloat+= slew/vi->rate*samples);
16295:     this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
16295:   }
16295: 
16295: 
16295: 
16295:   /* enforce min(if used) on the current floater (if used) */
16295:   if(bm->min_bitsper>0){
16295:     /* do we need to force the bitrate up? */
16295:     if(this_bits<min_target_bits){
16295:       while(bm->minmax_reservoir-(min_target_bits-this_bits)<0){
16295:         choice++;
16295:         if(choice>=PACKETBLOBS)break;
16295:         this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
16295:       }
16295:     }
16295:   }
16295: 
16295:   /* enforce max (if used) on the current floater (if used) */
16295:   if(bm->max_bitsper>0){
16295:     /* do we need to force the bitrate down? */
16295:     if(this_bits>max_target_bits){
16295:       while(bm->minmax_reservoir+(this_bits-max_target_bits)>bi->reservoir_bits){
16295:         choice--;
16295:         if(choice<0)break;
16295:         this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
16295:       }
16295:     }
16295:   }
16295: 
16295:   /* Choice of packetblobs now made based on floater, and min/max
16295:      requirements. Now boundary check extreme choices */
16295: 
16295:   if(choice<0){
16295:     /* choosing a smaller packetblob is insufficient to trim bitrate.
16295:        frame will need to be truncated */
16295:     long maxsize=(max_target_bits+(bi->reservoir_bits-bm->minmax_reservoir))/8;
16295:     bm->choice=choice=0;
16295: 
16295:     if(oggpack_bytes(vbi->packetblob[choice])>maxsize){
16295: 
16295:       oggpack_writetrunc(vbi->packetblob[choice],maxsize*8);
16295:       this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
16295:     }
16295:   }else{
16295:     long minsize=(min_target_bits-bm->minmax_reservoir+7)/8;
16295:     if(choice>=PACKETBLOBS)
16295:       choice=PACKETBLOBS-1;
16295: 
16295:     bm->choice=choice;
16295: 
16295:     /* prop up bitrate according to demand. pad this frame out with zeroes */
16295:     minsize-=oggpack_bytes(vbi->packetblob[choice]);
16295:     while(minsize-->0)oggpack_write(vbi->packetblob[choice],0,8);
16295:     this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
16295: 
16295:   }
16295: 
16295:   /* now we have the final packet and the final packet size.  Update statistics */
16295:   /* min and max reservoir */
16295:   if(bm->min_bitsper>0 || bm->max_bitsper>0){
16295: 
16295:     if(max_target_bits>0 && this_bits>max_target_bits){
16295:       bm->minmax_reservoir+=(this_bits-max_target_bits);
16295:     }else if(min_target_bits>0 && this_bits<min_target_bits){
16295:       bm->minmax_reservoir+=(this_bits-min_target_bits);
16295:     }else{
16295:       /* inbetween; we want to take reservoir toward but not past desired_fill */
16295:       if(bm->minmax_reservoir>desired_fill){
16295:         if(max_target_bits>0){ /* logical bulletproofing against initialization state */
16295:           bm->minmax_reservoir+=(this_bits-max_target_bits);
16295:           if(bm->minmax_reservoir<desired_fill)bm->minmax_reservoir=desired_fill;
16295:         }else{
16295:           bm->minmax_reservoir=desired_fill;
16295:         }
16295:       }else{
16295:         if(min_target_bits>0){ /* logical bulletproofing against initialization state */
16295:           bm->minmax_reservoir+=(this_bits-min_target_bits);
16295:           if(bm->minmax_reservoir>desired_fill)bm->minmax_reservoir=desired_fill;
16295:         }else{
16295:           bm->minmax_reservoir=desired_fill;
16295:         }
16295:       }
16295:     }
16295:   }
16295: 
16295:   /* avg reservoir */
16295:   if(bm->avg_bitsper>0){
16295:     long avg_target_bits=(vb->W?bm->avg_bitsper*bm->short_per_long:bm->avg_bitsper);
16295:     bm->avg_reservoir+=this_bits-avg_target_bits;
16295:   }
16295: 
16295:   return(0);
16295: }
16295: 
16295: int vorbis_bitrate_flushpacket(vorbis_dsp_state *vd,ogg_packet *op){
16295:   private_state         *b=vd->backend_state;
16295:   bitrate_manager_state *bm=&b->bms;
16295:   vorbis_block          *vb=bm->vb;
16295:   int                    choice=PACKETBLOBS/2;
16295:   if(!vb)return 0;
16295: 
16295:   if(op){
16295:     vorbis_block_internal *vbi=vb->internal;
16295: 
16295:     if(vorbis_bitrate_managed(vb))
16295:       choice=bm->choice;
16295: 
16295:     op->packet=oggpack_get_buffer(vbi->packetblob[choice]);
16295:     op->bytes=oggpack_bytes(vbi->packetblob[choice]);
16295:     op->b_o_s=0;
16295:     op->e_o_s=vb->eofflag;
16295:     op->granulepos=vb->granulepos;
16295:     op->packetno=vb->sequence; /* for sake of completeness */
16295:   }
16295: 
16295:   bm->vb=0;
16295:   return(1);
16295: }
