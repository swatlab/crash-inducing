47562: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
47562:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
47562:  *
47562:  * ***** BEGIN LICENSE BLOCK *****
47562:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47562:  *
47562:  * The contents of this file are subject to the Mozilla Public License Version
47562:  * 1.1 (the "License"); you may not use this file except in compliance with
47562:  * the License. You may obtain a copy of the License at
47562:  * http://www.mozilla.org/MPL/
47562:  *
47562:  * Software distributed under the License is distributed on an "AS IS" basis,
47562:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47562:  * for the specific language governing rights and limitations under the
47562:  * License.
47562:  *
47562:  * The Original Code is mozilla.org code, released
47562:  * June 24, 2010.
47562:  *
47562:  * The Initial Developer of the Original Code is
47562:  *    The Mozilla Foundation
47562:  *
47562:  * Contributor(s):
47562:  *    Andreas Gal <gal@mozilla.com>
47562:  *
47562:  * Alternatively, the contents of this file may be used under the terms of
47562:  * either of the GNU General Public License Version 2 or later (the "GPL"),
47562:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47562:  * in which case the provisions of the GPL or the LGPL are applicable instead
47562:  * of those above. If you wish to allow use of your version of this file only
47562:  * under the terms of either the GPL or the LGPL, and not to allow others to
47562:  * use your version of this file under the terms of the MPL, indicate your
47562:  * decision by deleting the provisions above and replace them with the notice
47562:  * and other provisions required by the GPL or the LGPL. If you do not delete
47562:  * the provisions above, a recipient may use your version of this file under
47562:  * the terms of any one of the MPL, the GPL or the LGPL.
47562:  *
47562:  * ***** END LICENSE BLOCK ***** */
47562: 
47562: #include "XrayWrapper.h"
47562: #include "AccessCheck.h"
47562: #include "FilteringWrapper.h"
47562: #include "CrossOriginWrapper.h"
47562: #include "WrapperFactory.h"
47562: 
47562: #include "jscntxt.h"
55632: #include "jsiter.h"
47562: 
47562: #include "XPCWrapper.h"
47562: #include "xpcprivate.h"
47562: 
47562: namespace xpc {
47562: 
47562: using namespace js;
47562: 
55746: static const uint32 JSSLOT_WN_OBJ = 0;
55746: static const uint32 JSSLOT_RESOLVING = 1;
55746: static const uint32 JSSLOT_EXPANDO = 2;
55602: 
55602: class ResolvingId
55602: {
55602:   public:
55602:     ResolvingId(JSObject *holder, jsid id)
55602:       : mId(id),
55602:         mPrev(getResolvingId(holder)),
55602:         mHolder(holder)
55602:     {
55602:         holder->setSlot(JSSLOT_RESOLVING, PrivateValue(this));
55602:     }
55602: 
55602:     ~ResolvingId() {
55602:         NS_ASSERTION(getResolvingId(mHolder) == this, "unbalanced ResolvingIds");
55602:         mHolder->setSlot(JSSLOT_RESOLVING, PrivateValue(mPrev));
55602:     }
55602: 
55602:     static ResolvingId *getResolvingId(JSObject *holder) {
55602:         return (ResolvingId *)holder->getSlot(JSSLOT_RESOLVING).toPrivate();
55602:     }
55602: 
55602:     jsid mId;
55602:     ResolvingId *mPrev;
55602: 
55602:   private:
55602:     JSObject *mHolder;
55602: };
55602: 
55602: static bool
55602: IsResolving(JSObject *holder, jsid id)
55602: {
55602:     for (ResolvingId *cur = ResolvingId::getResolvingId(holder); cur; cur = cur->mPrev) {
55602:         if (cur->mId == id)
55602:             return true;
55602:     }
55602: 
55602:     return false;
55602: }
47562: 
47562: static JSBool
47562: holder_get(JSContext *cx, JSObject *holder, jsid id, jsval *vp);
47562: 
47562: static JSBool
47562: holder_set(JSContext *cx, JSObject *holder, jsid id, jsval *vp);
47562: 
55602: namespace XrayUtils {
55602: 
47562: JSClass HolderClass = {
47562:     "NativePropertyHolder",
55702:     JSCLASS_HAS_RESERVED_SLOTS(3),
47562:     JS_PropertyStub,        JS_PropertyStub, holder_get,      holder_set,
55702:     JS_EnumerateStub,       JS_ResolveStub,  JS_ConvertStub,  NULL,
47562:     NULL,                   NULL,            NULL,            NULL,
47562:     NULL,                   NULL,            NULL,            NULL
47562: };
47562: 
55602: }
55602: 
55602: using namespace XrayUtils;
55602: 
55602: static JSObject *
55602: GetHolder(JSObject *obj)
55602: {
55602:     return &obj->getProxyExtra().toObject();
55602: }
55602: 
47562: static XPCWrappedNative *
47562: GetWrappedNative(JSObject *obj)
47562: {
47562:     NS_ASSERTION(IS_WN_WRAPPER_OBJECT(obj), "expected a wrapped native here");
47562:     return static_cast<XPCWrappedNative *>(obj->getPrivate());
47562: }
47562: 
47562: static JSObject *
55582: GetWrappedNativeObjectFromHolder(JSContext *cx, JSObject *holder)
47562: {
48470:     NS_ASSERTION(holder->getJSClass() == &HolderClass, "expected a native property holder object");
55582:     JSObject *wrappedObj = &holder->getSlot(JSSLOT_WN_OBJ).toObject();
55582:     OBJ_TO_INNER_OBJECT(cx, wrappedObj);
55582:     return wrappedObj;
47562: }
47562: 
55702: static JSObject *
55702: GetExpandoObject(JSContext *cx, JSObject *holder)
55702: {
55702:     JSObject *expando = holder->getSlot(JSSLOT_EXPANDO).toObjectOrNull();
55702:     if (!expando) {
55702:         expando =  JS_NewObjectWithGivenProto(cx, nsnull, nsnull, holder->getParent());
55702:         holder->setSlot(JSSLOT_EXPANDO, ObjectValue(*expando));
55702:     }
55702:     return expando;
55702: }
55702: 
47562: // Some DOM objects have shared properties that don't have an explicit
47562: // getter/setter and rely on the class getter/setter. We install a
47562: // class getter/setter on the holder object to trigger them.
47562: static JSBool
55602: holder_get(JSContext *cx, JSObject *wrapper, jsid id, jsval *vp)
47562: {
55602:     NS_ASSERTION(wrapper->isProxy(), "bad this object in get");
55602:     JSObject *holder = GetHolder(wrapper);
55582: 
55602:     JSObject *wnObject = GetWrappedNativeObjectFromHolder(cx, holder);
47562:     XPCWrappedNative *wn = GetWrappedNative(wnObject);
47562:     if (NATIVE_HAS_FLAG(wn, WantGetProperty)) {
55640:         JSAutoEnterCompartment ac;
55640:         if (!ac.enter(cx, holder))
55640:             return false;
47562:         JSBool retval = true;
55602:         nsresult rv = wn->GetScriptableCallback()->GetProperty(wn, cx, wrapper, id, vp, &retval);
47562:         if (NS_FAILED(rv)) {
55602:             if (retval)
47562:                 XPCThrower::Throw(rv, cx);
47562:             return false;
47562:         }
47562:     }
47562:     return true;
47562: }
47562: 
47562: static JSBool
55602: holder_set(JSContext *cx, JSObject *wrapper, jsid id, jsval *vp)
47562: {
55602:     NS_ASSERTION(wrapper->isProxy(), "bad this object in set");
55602:     JSObject *holder = GetHolder(wrapper);
55649:     if (IsResolving(holder, id)) {
55649:         return true;
55649:     }
55649: 
55602:     JSObject *wnObject = GetWrappedNativeObjectFromHolder(cx, holder);
55602: 
47562:     XPCWrappedNative *wn = GetWrappedNative(wnObject);
47562:     if (NATIVE_HAS_FLAG(wn, WantSetProperty)) {
55640:         JSAutoEnterCompartment ac;
55640:         if (!ac.enter(cx, holder))
55640:             return false;
47562:         JSBool retval = true;
55602:         nsresult rv = wn->GetScriptableCallback()->SetProperty(wn, cx, wrapper, id, vp, &retval);
47562:         if (NS_FAILED(rv)) {
55602:             if (retval)
47562:                 XPCThrower::Throw(rv, cx);
47562:             return false;
47562:         }
47562:     }
47562:     return true;
47562: }
47562: 
47562: static bool
55602: ResolveNativeProperty(JSContext *cx, JSObject *wrapper, JSObject *holder, jsid id, bool set,
55599:                       JSPropertyDescriptor *desc)
47562: {
47562:     desc->obj = NULL;
47562: 
48470:     NS_ASSERTION(holder->getJSClass() == &HolderClass, "expected a native property holder object");
55582:     JSObject *wnObject = GetWrappedNativeObjectFromHolder(cx, holder);
47562:     XPCWrappedNative *wn = GetWrappedNative(wnObject);
47562: 
47562:     // This will do verification and the method lookup for us.
55582:     XPCCallContext ccx(JS_CALLER, cx, wnObject, nsnull, id);
47562: 
47562:     // Run the resolve hook of the wrapped native.
55582:     if (NATIVE_HAS_FLAG(wn, WantNewResolve)) {
55601:         JSAutoEnterCompartment ac;
55601:         if (!ac.enter(cx, holder))
55601:             return false;
55601: 
47562:         JSBool retval = true;
47562:         JSObject *pobj = NULL;
55603:         uintN flags = (set ? JSRESOLVE_ASSIGNING : 0) | JSRESOLVE_QUALIFIED;
55602:         nsresult rv = wn->GetScriptableInfo()->GetCallback()->NewResolve(wn, cx, wrapper, id,
55602:                                                                          flags, &pobj, &retval);
47562:         if (NS_FAILED(rv)) {
47562:             if (retval) {
47562:                 XPCThrower::Throw(rv, cx);
47562:             }
47562:             return false;
47562:         }
47562: 
55702:         if (pobj) {
55702: #ifdef DEBUG
55702:             JSBool hasProp;
55702:             NS_ASSERTION(JS_HasPropertyById(cx, holder, id, &hasProp) &&
55702:                          hasProp, "id got defined somewhere else?");
55702: #endif
55702:             return JS_GetPropertyDescriptorById(cx, holder, id, flags, desc);
55702:         }
47562:     }
47562: 
47562:     // There are no native numeric properties, so we can shortcut here. We will not
47562:     // find the property.
47562:     if (!JSID_IS_ATOM(id)) {
47562:         /* Not found */
47562:         return true;
47562:     }
47562: 
47562:     XPCNativeInterface *iface;
47562:     XPCNativeMember *member;
47562:     if (ccx.GetWrapper() != wn ||
47562:         !wn->IsValid()  ||
47562:         !(iface = ccx.GetInterface()) ||
47562:         !(member = ccx.GetMember())) {
47562:         /* Not found */
47562:         return true;
47562:     }
47562: 
47562:     desc->obj = holder;
47562:     desc->attrs = JSPROP_ENUMERATE;
47562:     desc->getter = NULL;
47562:     desc->setter = NULL;
47562:     desc->shortid = NULL;
47562:     desc->value = JSVAL_VOID;
47562: 
55599:     jsval fval = JSVAL_VOID;
47562:     if (member->IsConstant()) {
47562:         if (!member->GetConstantValue(ccx, iface, &desc->value)) {
47562:             JS_ReportError(cx, "Failed to convert constant native property to JS value");
47562:             return false;
47562:         }
47562:     } else if (member->IsAttribute()) {
47562:         // This is a getter/setter. Clone a function for it.
55680: 
55680:         JSAutoEnterCompartment ac;
55680:         if (!ac.enter(cx, wnObject))
55680:             return false;
55680: 
47562:         if (!member->NewFunctionObject(ccx, iface, wnObject, &fval)) {
47562:             JS_ReportError(cx, "Failed to clone function object for native getter/setter");
47562:             return false;
47562:         }
55599: 
47562:         desc->attrs |= JSPROP_GETTER;
55599:         if (member->IsWritableAttribute())
47562:             desc->attrs |= JSPROP_SETTER;
47562: 
47562:         // Make the property shared on the holder so no slot is allocated
47562:         // for it. This avoids keeping garbage alive through that slot.
47562:         desc->attrs |= JSPROP_SHARED;
47562:     } else {
55680:         JSAutoEnterCompartment ac;
55680:         if (!ac.enter(cx, wnObject))
55680:             return false;
55680: 
47562:         // This is a method. Clone a function for it.
47562:         if (!member->NewFunctionObject(ccx, iface, wnObject, &desc->value)) {
47562:             JS_ReportError(cx, "Failed to clone function object for native function");
47562:             return false;
47562:         }
47562: 
47562:         // Without a wrapper the function would live on the prototype. Since we
47562:         // don't have one, we have to avoid calling the scriptable helper's
47562:         // GetProperty method for this property, so stub out the getter and
47562:         // setter here explicitly.
47562:         desc->getter = desc->setter = JS_PropertyStub;
47562:     }
47562: 
55599:     JSAutoEnterCompartment ac;
55599:     if (!ac.enter(cx, holder))
55599:         return false;
55599: 
55599:     if (!JS_WrapValue(cx, &desc->value) || !JS_WrapValue(cx, &fval))
55599:         return false;
55599: 
55599:     if (desc->attrs & JSPROP_GETTER)
55599:         desc->getter = CastAsJSPropertyOp(JSVAL_TO_OBJECT(fval));
55599:     if (desc->attrs & JSPROP_SETTER)
55599:         desc->setter = desc->getter;
55599: 
47562:     // Define the property.
47562:     return JS_DefinePropertyById(cx, holder, id, desc->value,
47562:                                  desc->getter, desc->setter, desc->attrs);
47562: }
47562: 
47562: static JSBool
55696: wrappedJSObject_getter(JSContext *cx, JSObject *wrapper, jsid id, jsval *vp)
47562: {
55696:     *vp = OBJECT_TO_JSVAL(wrapper);
55584: 
55696:     return WrapperFactory::WaiveXrayAndWrap(cx, vp);
47562: }
47562: 
55626: static JSBool
55626: XrayToString(JSContext *cx, uintN argc, jsval *vp)
55626: {
55626:     JSObject *wrapper = JS_THIS_OBJECT(cx, vp);
55626:     if (!wrapper->isWrapper() || !WrapperFactory::IsXrayWrapper(wrapper)) {
55626:         JS_ReportError(cx, "XrayToString called on an incompatible object");
55626:         return false;
55626:     }
55626:     JSObject *holder = GetHolder(wrapper);
55626:     JSObject *wrappednative = GetWrappedNativeObjectFromHolder(cx, holder);
55626:     XPCWrappedNative *wn = GetWrappedNative(wrappednative);
55626: 
55626:     XPCCallContext ccx(JS_CALLER, cx, wrappednative);
55626:     char *wrapperStr = wn->ToString(ccx);
55626:     if (!wrapperStr) {
55626:         JS_ReportOutOfMemory(cx);
55626:         return false;
55626:     }
55626: 
55626:     nsAutoString result(NS_LITERAL_STRING("[object XrayWrapper "));
55626:     result.AppendASCII(wrapperStr);
55626:     JS_smprintf_free(wrapperStr);
55626:     result.Append(']');
55626: 
55626:     JSString *str = JS_NewUCStringCopyN(cx, reinterpret_cast<const jschar *>(result.get()),
55626:                                         result.Length());
55626:     if (!str)
55626:         return false;
55626: 
55626:     *vp = STRING_TO_JSVAL(str);
55626:     return true;
55626: }
55626: 
55599: template <typename Base, typename Policy>
55624: XrayWrapper<Base, Policy>::XrayWrapper(uintN flags)
55624:   : Base(flags | WrapperFactory::IS_XRAY_WRAPPER_FLAG)
55582: {
55582: }
55582: 
55599: template <typename Base, typename Policy>
55599: XrayWrapper<Base, Policy>::~XrayWrapper()
55582: {
55582: }
55582: 
55599: template <typename Base, typename Policy>
55617: class AutoLeaveHelper
55617: {
55617:   public:
55617:     AutoLeaveHelper(XrayWrapper<Base, Policy> &xray, JSContext *cx, JSObject *wrapper)
55617:       : xray(xray), cx(cx), wrapper(wrapper)
55617:     {
55617:     }
55617:     ~AutoLeaveHelper()
55617:     {
55617:         xray.leave(cx, wrapper);
55617:     }
55617: 
55617:   private:
55617:     XrayWrapper<Base, Policy> &xray;
55617:     JSContext *cx;
55617:     JSObject *wrapper;
55617: };
55617: 
55654: static bool
55667: Transparent(JSContext *cx, JSObject *wrapper)
55654: {
55691:     if (WrapperFactory::HasWaiveXrayFlag(wrapper))
55691:         return true;
55691: 
55667:     if (!WrapperFactory::IsPartiallyTransparent(wrapper))
55667:         return false;
55667: 
55654:     // Redirect access straight to the wrapper if UniversalXPConnect is enabled.
55654:     nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
55654:     if (ssm) {
55654:         PRBool privileged;
55654:         if (NS_SUCCEEDED(ssm->IsCapabilityEnabled("UniversalXPConnect", &privileged)) && privileged)
55654:             return true;
55654:     }
55667: 
56042:     return AccessCheck::documentDomainMakesSameOrigin(cx, wrapper->unwrap());
55654: }
55654: 
55703: namespace XrayUtils {
55703: 
55703: bool
55703: IsTransparent(JSContext *cx, JSObject *wrapper)
55703: {
55703:     return Transparent(cx, wrapper);
55703: }
55703: 
55703: }
55703: 
55617: template <typename Base, typename Policy>
55582: bool
55702: XrayWrapper<Base, Policy>::resolveWrappedJSObject(JSContext *cx, JSObject *wrapper,
55702:                                                   jsid id, bool set,
55702:                                                   PropertyDescriptor *desc_in)
47562: {
55649:     JSPropertyDescriptor *desc = Jsvalify(desc_in);
55649: 
55649:     if (id == nsXPConnect::GetRuntimeInstance()->GetStringID(XPCJSRuntime::IDX_WRAPPED_JSOBJECT)) {
55617:         if (!this->enter(cx, wrapper, id, set ? JSWrapper::SET : JSWrapper::GET))
55617:             return false;
55617: 
55617:         AutoLeaveHelper<Base, Policy> helper(*this, cx, wrapper);
55617: 
47562:         desc->obj = wrapper;
47562:         desc->attrs = JSPROP_ENUMERATE|JSPROP_SHARED;
47562:         desc->getter = wrappedJSObject_getter;
47562:         desc->setter = NULL;
55626:         desc->shortid = 0;
47562:         desc->value = JSVAL_VOID;
47562:         return true;
47562:     }
55599: 
55702:     desc->obj = NULL;
55702:     return true;
55702: }
55702: 
55702: template <typename Base, typename Policy>
55702: bool
55702: XrayWrapper<Base, Policy>::getPropertyDescriptor(JSContext *cx, JSObject *wrapper, jsid id,
55702:                                                  bool set, PropertyDescriptor *desc_in)
55702: {
55702:     JSPropertyDescriptor *desc = Jsvalify(desc_in);
55702: 
55702:     if (!resolveWrappedJSObject(cx, wrapper, id, set, desc_in))
55702:         return false;
55702: 
55702:     if (desc->obj)
55702:         return true;
55702: 
55602:     JSObject *holder = GetHolder(wrapper);
55602:     if (IsResolving(holder, id)) {
55602:         desc->obj = NULL;
55602:         return true;
55602:     }
55602: 
55649:     if (!this->enter(cx, wrapper, id, set ? JSWrapper::SET : JSWrapper::GET))
55649:         return false;
55649: 
55649:     AutoLeaveHelper<Base, Policy> helper(*this, cx, wrapper);
55649: 
55602:     ResolvingId resolving(holder, id);
55602: 
55599:     void *priv;
55599:     if (!Policy::enter(cx, wrapper, &id, set ? JSWrapper::SET : JSWrapper::GET, &priv))
47562:         return false;
55599: 
55691:     // Redirect access straight to the wrapper if we should be transparent.
55681:     if (Transparent(cx, wrapper)) {
55681:         Policy::leave(cx, wrapper, priv);
55681: 
55681:         JSObject *wnObject = GetWrappedNativeObjectFromHolder(cx, holder);
55681: 
55681:         {
55681:             JSAutoEnterCompartment ac;
55681:             if (!ac.enter(cx, wnObject))
55681:                 return false;
55681: 
55681:             if (!JS_GetPropertyDescriptorById(cx, wnObject, id,
55681:                                               (set ? JSRESOLVE_ASSIGNING : 0) | JSRESOLVE_QUALIFIED,
55681:                                               desc))
55681:                 return false;
55681:         }
55681: 
55681:         desc->obj = wrapper;
55681:         return cx->compartment->wrap(cx, desc_in);
55681:     }
55681: 
55602:     bool ok = ResolveNativeProperty(cx, wrapper, holder, id, false, desc);
55602:     Policy::leave(cx, wrapper, priv);
55602:     if (!ok || desc->obj)
55602:         return ok;
55599: 
55626:     if (id == nsXPConnect::GetRuntimeInstance()->GetStringID(XPCJSRuntime::IDX_TO_STRING)) {
55626:         desc->obj = wrapper;
55626:         desc->attrs = 0;
55626:         desc->getter = NULL;
55626:         desc->setter = NULL;
55626:         desc->shortid = 0;
55626: 
55626:         JSObject *toString = JS_NewFunction(cx, XrayToString, 0, 0, holder, "toString");
55626:         if (!toString)
55626:             return false;
55626:         desc->value = OBJECT_TO_JSVAL(toString);
55626:         return true;
55626:     }
55626: 
55702:     return getOwnPropertyDescriptor(cx, wrapper, id, set, desc_in);
55702: 
47562: }
47562: 
55599: template <typename Base, typename Policy>
47562: bool
55599: XrayWrapper<Base, Policy>::getOwnPropertyDescriptor(JSContext *cx, JSObject *wrapper, jsid id,
55702:                                                     bool set, PropertyDescriptor *desc_in)
47562: {
55702:     JSPropertyDescriptor *desc = Jsvalify(desc_in);
55702: 
55702:     if (!resolveWrappedJSObject(cx, wrapper, id, false, desc_in))
55702:         return false;
55702: 
55702:     if (desc->obj)
55702:         return true;
55702: 
55702:     JSObject *holder = GetHolder(wrapper);
55702:     JSObject *expando = GetExpandoObject(cx, holder);
55702:     if (!expando)
55702:         return false;
55702: 
55702:     return JS_GetPropertyDescriptorById(cx, expando, id,
55702:                                         (set ? JSRESOLVE_ASSIGNING : 0) | JSRESOLVE_QUALIFIED,
55702:                                         desc);
47562: }
47562: 
55599: template <typename Base, typename Policy>
47562: bool
55599: XrayWrapper<Base, Policy>::defineProperty(JSContext *cx, JSObject *wrapper, jsid id,
55599:                                           js::PropertyDescriptor *desc)
47562: {
55602:     JSObject *holder = GetHolder(wrapper);
55654:     JSPropertyDescriptor *jsdesc = Jsvalify(desc);
55654: 
55691:     // Redirect access straight to the wrapper if we should be transparent.
55667:     if (Transparent(cx, wrapper)) {
55654:         JSObject *wnObject = GetWrappedNativeObjectFromHolder(cx, holder);
55654: 
55654:         JSAutoEnterCompartment ac;
55654:         if (!ac.enter(cx, wnObject))
55654:             return false;
55654: 
55654:         if (!cx->compartment->wrap(cx, desc))
55654:             return false;
55654: 
55654:         return JS_DefinePropertyById(cx, wnObject, id, jsdesc->value, jsdesc->getter, jsdesc->setter,
55654:                                      jsdesc->attrs);
55654:     }
55654: 
55602:     PropertyDescriptor existing_desc;
55602:     if (!getOwnPropertyDescriptor(cx, wrapper, id, true, &existing_desc))
55602:         return false;
55602: 
55603:     if (existing_desc.obj && (existing_desc.attrs & JSPROP_PERMANENT))
55632:         return true; // silently ignore attempt to overwrite native property
55602: 
55702:     if (IsResolving(holder, id)) {
55602:         if (!(jsdesc->attrs & (JSPROP_GETTER | JSPROP_SETTER))) {
55602:             if (!desc->getter)
55602:                 jsdesc->getter = holder_get;
55602:             if (!desc->setter)
55602:                 jsdesc->setter = holder_set;
55602:         }
55602: 
55602:         return JS_DefinePropertyById(cx, holder, id, jsdesc->value, jsdesc->getter, jsdesc->setter,
55602:                                      jsdesc->attrs);
55599:     }
55599: 
55702:     JSObject *expando = GetExpandoObject(cx, holder);
55702:     if (!expando)
55702:         return false;
55702: 
55702:     return JS_DefinePropertyById(cx, expando, id, jsdesc->value, jsdesc->getter, jsdesc->setter,
55702:                                  jsdesc->attrs);
55702: }
55702: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::getOwnPropertyNames(JSContext *cx, JSObject *wrapper,
55599:                                                js::AutoIdVector &props)
55599: {
55632:     JSObject *holder = GetHolder(wrapper);
55654: 
55691:     // Redirect access straight to the wrapper if we should be transparent.
55667:     if (Transparent(cx, wrapper)) {
55654:         JSObject *wnObject = GetWrappedNativeObjectFromHolder(cx, holder);
55654: 
55654:         JSAutoEnterCompartment ac;
55654:         if (!ac.enter(cx, wnObject))
55654:             return false;
55654: 
55654:         return js::GetPropertyNames(cx, wnObject, JSITER_OWNONLY | JSITER_HIDDEN, &props);
55654:     }
55654: 
55702:     JSObject *expando = GetExpandoObject(cx, holder);
55702:     if (!expando)
55702:         return false;
55702: 
55702:     return js::GetPropertyNames(cx, expando, JSITER_OWNONLY | JSITER_HIDDEN, &props);
55599: }
55599: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::delete_(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
55599: {
55632:     JSObject *holder = GetHolder(wrapper);
55632:     jsval v;
55632:     JSBool b;
55654: 
55667:     // Redirect access straight to the wrapper if we should be transparent.
55667:     if (Transparent(cx, wrapper)) {
55654:         JSObject *wnObject = GetWrappedNativeObjectFromHolder(cx, holder);
55654: 
55654:         JSAutoEnterCompartment ac;
55654:         if (!ac.enter(cx, wnObject))
55654:             return false;
55654: 
55654:         if (!JS_DeletePropertyById2(cx, wnObject, id, &v) || !JS_ValueToBoolean(cx, v, &b))
55654:             return false;
55654:         *bp = !!b;
55654:         return true;
55654:     }
55654: 
55702:     JSObject *expando = GetExpandoObject(cx, holder);
55702:     if (!expando)
55702:         return false;
55702: 
55702:     if (!JS_DeletePropertyById2(cx, expando, id, &v) || !JS_ValueToBoolean(cx, v, &b))
55632:         return false;
55632:     *bp = !!b;
55599:     return true;
55599: }
55599: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::enumerate(JSContext *cx, JSObject *wrapper, js::AutoIdVector &props)
55599: {
55632:     JSObject *holder = GetHolder(wrapper);
55654: 
55702:     JSObject *wnObject = GetWrappedNativeObjectFromHolder(cx, holder);
55702: 
55691:     // Redirect access straight to the wrapper if we should be transparent.
55667:     if (Transparent(cx, wrapper)) {
55654:         JSAutoEnterCompartment ac;
55654:         if (!ac.enter(cx, wnObject))
55654:             return false;
55654: 
55654:         return js::GetPropertyNames(cx, wnObject, 0, &props);
55654:     }
55654: 
55702:     // Enumerate expando properties first.
55702:     JSObject *expando = GetExpandoObject(cx, holder);
55702:     if (!expando)
55702:         return false;
55702: 
55702:     if (!js::GetPropertyNames(cx, expando, JSITER_OWNONLY, &props))
55702:         return false;
55702: 
55702:     // Force all native properties to be materialized onto the wrapped native.
55702:     js::AutoIdVector wnProps(cx);
55702:     {
55702:         JSAutoEnterCompartment ac;
55702:         if (!ac.enter(cx, wnObject))
55702:             return false;
55702:         if (!js::GetPropertyNames(cx, wnObject, 0, &wnProps))
55702:             return false;
55702:     }
55702: 
55702:     // Go through the properties we got and enumerate all native ones.
55702:     for (size_t n = 0; n < wnProps.length(); ++n) {
55702:         jsid id = wnProps[n];
56040:         JSBool hasProp;
56040:         if (!JS_HasPropertyById(cx, wrapper, id, &hasProp))
55702:             return false;
56040:         if (hasProp)
55702:             props.append(id);
55702:     }
55702:     return true;
55599: }
55599: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::fix(JSContext *cx, JSObject *proxy, js::Value *vp)
55599: {
55599:     vp->setUndefined();
55599:     return true;
55599: }
55599: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::get(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id,
55599:                                js::Value *vp)
55599: {
55599:     // Skip our Base if it isn't already JSProxyHandler.
56848:     // NB: None of the functions we call are prepared for the receiver not
56848:     // being the wrapper, so ignore the receiver here.
56848:     return JSProxyHandler::get(cx, wrapper, wrapper, id, vp);
55599: }
55599: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::set(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id,
55599:                                js::Value *vp)
55599: {
55599:     // Skip our Base if it isn't already JSProxyHandler.
56848:     // NB: None of the functions we call are prepared for the receiver not
56848:     // being the wrapper, so ignore the receiver here.
56848:     return JSProxyHandler::set(cx, wrapper, wrapper, id, vp);
55599: }
55599: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::has(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
55599: {
55599:     // Skip our Base if it isn't already JSProxyHandler.
47562:     return JSProxyHandler::has(cx, wrapper, id, bp);
47562: }
47562: 
55599: template <typename Base, typename Policy>
47562: bool
55599: XrayWrapper<Base, Policy>::hasOwn(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
47562: {
55599:     // Skip our Base if it isn't already JSProxyHandler.
47562:     return JSProxyHandler::hasOwn(cx, wrapper, id, bp);
47562: }
47562: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::enumerateOwn(JSContext *cx, JSObject *wrapper, js::AutoIdVector &props)
55599: {
55599:     // Skip our Base if it isn't already JSProxyHandler.
55599:     return JSProxyHandler::enumerateOwn(cx, wrapper, props);
55599: }
55599: 
55599: template <typename Base, typename Policy>
55599: bool
55599: XrayWrapper<Base, Policy>::iterate(JSContext *cx, JSObject *wrapper, uintN flags, js::Value *vp)
55599: {
55599:     // Skip our Base if it isn't already JSProxyHandler.
55599:     return JSProxyHandler::iterate(cx, wrapper, flags, vp);
55599: }
55599: 
55599: template <typename Base, typename Policy>
55582: JSObject *
55599: XrayWrapper<Base, Policy>::createHolder(JSContext *cx, JSObject *wrappedNative, JSObject *parent)
55582: {
55582:     JSObject *holder = JS_NewObjectWithGivenProto(cx, &HolderClass, nsnull, parent);
55582:     if (!holder)
55582:         return nsnull;
55582: 
55680:     JS_ASSERT(IS_WN_WRAPPER(wrappedNative) ||
55680:               wrappedNative->getClass()->ext.innerObject);
55582:     holder->setSlot(JSSLOT_WN_OBJ, ObjectValue(*wrappedNative));
55602:     holder->setSlot(JSSLOT_RESOLVING, PrivateValue(NULL));
55702:     holder->setSlot(JSSLOT_EXPANDO, NullValue());
55582:     return holder;
55582: }
55582: 
55599: bool
55599: CrossCompartmentXray::enter(JSContext *cx, JSObject *wrapper, jsid *idp,
55599:                             JSWrapper::Action act, void **priv)
55582: {
55599:     JSObject *target = wrapper->unwrap();
55599:     JSCrossCompartmentCall *call = JS_EnterCrossCompartmentCall(cx, target);
55599:     if (!call)
55599:         return false;
55599: 
55599:     *priv = call;
55599:     return true;
55582: }
55582: 
55599: void
55599: CrossCompartmentXray::leave(JSContext *cx, JSObject *wrapper, void *priv)
55599: {
55599:     JS_LeaveCrossCompartmentCall(static_cast<JSCrossCompartmentCall *>(priv));
55599: }
47562: 
55599: #define XPCNW XrayWrapper<JSCrossCompartmentWrapper, CrossCompartmentXray>
55617: #define SCNW XrayWrapper<JSWrapper, SameCompartmentXray>
47562: 
55599: template <> XPCNW XPCNW::singleton(0);
55599: template <> SCNW SCNW::singleton(0);
55599: 
55599: template class XPCNW;
55599: template class SCNW;
47562: 
47562: }
