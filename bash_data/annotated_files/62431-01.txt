54814: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
54814:  * ***** BEGIN LICENSE BLOCK *****
54814:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54814:  *
54814:  * The contents of this file are subject to the Mozilla Public License Version
54814:  * 1.1 (the "License"); you may not use this file except in compliance with
54814:  * the License. You may obtain a copy of the License at
54814:  * http://www.mozilla.org/MPL/
54814:  *
54814:  * Software distributed under the License is distributed on an "AS IS" basis,
54814:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54814:  * for the specific language governing rights and limitations under the
54814:  * License.
54814:  *
54814:  * The Original Code is Mozilla Corporation code.
54814:  *
54814:  * The Initial Developer of the Original Code is Mozilla Foundation.
54814:  * Portions created by the Initial Developer are Copyright (C) 2010
54814:  * the Initial Developer. All Rights Reserved.
54814:  *
54814:  * Contributor(s):
54814:  *   Vladimir Vukicevic <vladimir@pobox.com>
54814:  *   Bas Schouten <bschouten@mozilla.com>
54814:  *
54814:  * Alternatively, the contents of this file may be used under the terms of
54814:  * either the GNU General Public License Version 2 or later (the "GPL"), or
54814:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54814:  * in which case the provisions of the GPL or the LGPL are applicable instead
54814:  * of those above. If you wish to allow use of your version of this file only
54814:  * under the terms of either the GPL or the LGPL, and not to allow others to
54814:  * use your version of this file under the terms of the MPL, indicate your
54814:  * decision by deleting the provisions above and replace them with the notice
54814:  * and other provisions required by the GPL or the LGPL. If you do not delete
54814:  * the provisions above, a recipient may use your version of this file under
54814:  * the terms of any one of the MPL, the GPL or the LGPL.
54814:  *
54814:  * ***** END LICENSE BLOCK ***** */
54814: 
54814: #include "CanvasLayerD3D10.h"
54814: 
54814: #include "gfxImageSurface.h"
54814: #include "gfxWindowsSurface.h"
54814: #include "gfxWindowsPlatform.h"
54814: 
54814: namespace mozilla {
54814: namespace layers {
54814: 
54814: CanvasLayerD3D10::~CanvasLayerD3D10()
54814: {
54814: }
54814: 
54814: void
54814: CanvasLayerD3D10::Initialize(const Data& aData)
54814: {
54814:   NS_ASSERTION(mSurface == nsnull, "BasicCanvasLayer::Initialize called twice!");
54814: 
54814:   if (aData.mSurface) {
54814:     mSurface = aData.mSurface;
54814:     NS_ASSERTION(aData.mGLContext == nsnull,
54814:                  "CanvasLayer can't have both surface and GLContext");
54814:     mNeedsYFlip = PR_FALSE;
54814:     mDataIsPremultiplied = PR_TRUE;
54814:   } else if (aData.mGLContext) {
54814:     NS_ASSERTION(aData.mGLContext->IsOffscreen(), "canvas gl context isn't offscreen");
54814:     mGLContext = aData.mGLContext;
54814:     mCanvasFramebuffer = mGLContext->GetOffscreenFBO();
54814:     mDataIsPremultiplied = aData.mGLBufferIsPremultiplied;
54814:     mNeedsYFlip = PR_TRUE;
54814:   } else {
54814:     NS_ERROR("CanvasLayer created without mSurface or mGLContext?");
54814:   }
54814: 
54814:   mBounds.SetRect(0, 0, aData.mSize.width, aData.mSize.height);
54814: 
54814:   if (mSurface && mSurface->GetType() == gfxASurface::SurfaceTypeD2D) {
54814:     void *data = mSurface->GetData(&gKeyD3D10Texture);
54814:     if (data) {
54814:       mTexture = static_cast<ID3D10Texture2D*>(data);
60089:       mIsD2DTexture = PR_TRUE;
54814:       device()->CreateShaderResourceView(mTexture, NULL, getter_AddRefs(mSRView));
62431:       mHasAlpha =
62431:         mSurface->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA;
54814:       return;
54814:     }
54814:   }
54814: 
60089:   mIsD2DTexture = PR_FALSE;
60089:   mUsingSharedTexture = PR_FALSE;
54814: 
60089:   HANDLE shareHandle = mGLContext ? mGLContext->GetD3DShareHandle() : nsnull;
60089:   if (shareHandle) {
60089:     HRESULT hr = device()->OpenSharedResource(shareHandle, __uuidof(ID3D10Texture2D), getter_AddRefs(mTexture));
61660:     if (SUCCEEDED(hr)) {
60089:       mUsingSharedTexture = PR_TRUE;
61660:       // XXX for ANGLE, it's already the right-way up.  If we start using NV GL-D3D interop
61660:       // however, we'll need to do the right thing.
61660:       mNeedsYFlip = PR_FALSE;
61660:     }
60089:   }
60089: 
60089:   if (!mUsingSharedTexture) {
54814:     CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, mBounds.width, mBounds.height, 1, 1);
54814:     desc.Usage = D3D10_USAGE_DYNAMIC;
54814:     desc.CPUAccessFlags = D3D10_CPU_ACCESS_WRITE;
54814: 
54814:     HRESULT hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(mTexture));
54814:     if (FAILED(hr)) {
54814:       NS_WARNING("Failed to create texture for CanvasLayer!");
54814:       return;
54814:     }
60089:   }
60089: 
54814:   device()->CreateShaderResourceView(mTexture, NULL, getter_AddRefs(mSRView));
54814: }
54814: 
54814: void
54814: CanvasLayerD3D10::Updated(const nsIntRect& aRect)
54814: {
54814:   if (mIsD2DTexture) {
54814:     mSurface->Flush();
54814:     return;
54814:   }
54814: 
60089:   if (mUsingSharedTexture) {
60089:     // need to sync on the d3d9 device
60089:     if (mGLContext) {
60089:       mGLContext->MakeCurrent();
60089:       mGLContext->fFinish();
60089:     }
60089:     return;
60089:   }
60089: 
54814:   if (mGLContext) {
54814:     // WebGL reads entire surface.
54814:     D3D10_MAPPED_TEXTURE2D map;
54814:     
54814:     HRESULT hr = mTexture->Map(0, D3D10_MAP_WRITE_DISCARD, 0, &map);
54814: 
54814:     if (FAILED(hr)) {
54814:       NS_WARNING("Failed to map CanvasLayer texture.");
54814:       return;
54814:     }
54814: 
54814:     PRUint8 *destination;
54814:     if (map.RowPitch != mBounds.width * 4) {
54814:       destination = new PRUint8[mBounds.width * mBounds.height * 4];
54814:     } else {
54814:       destination = (PRUint8*)map.pData;
54814:     }
54814: 
54814:     // We have to flush to ensure that any buffered GL operations are
54814:     // in the framebuffer before we read.
54814:     mGLContext->fFlush();
54814: 
54814:     PRUint32 currentFramebuffer = 0;
54814: 
54814:     mGLContext->fGetIntegerv(LOCAL_GL_FRAMEBUFFER_BINDING, (GLint*)&currentFramebuffer);
54814: 
54814:     // Make sure that we read pixels from the correct framebuffer, regardless
54814:     // of what's currently bound.
54814:     if (currentFramebuffer != mCanvasFramebuffer)
54814:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, mCanvasFramebuffer);
54814: 
54814:     // For simplicity, we read the entire framebuffer for now -- in
54814:     // the future we should use aRect, though with WebGL we don't
54814:     // have an easy way to generate one.
54814:     nsRefPtr<gfxImageSurface> tmpSurface =
54814:       new gfxImageSurface(destination,
54814:                           gfxIntSize(mBounds.width, mBounds.height),
54814:                           mBounds.width * 4,
54814:                           gfxASurface::ImageFormatARGB32);
54814:     mGLContext->ReadPixelsIntoImageSurface(0, 0,
54814:                                            mBounds.width, mBounds.height,
54814:                                            tmpSurface);
54814:     tmpSurface = nsnull;
54814: 
54814:     // Put back the previous framebuffer binding.
54814:     if (currentFramebuffer != mCanvasFramebuffer)
54814:       mGLContext->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, currentFramebuffer);
54814: 
54814:     if (map.RowPitch != mBounds.width * 4) {
54814:       for (int y = 0; y < mBounds.height; y++) {
54814:         memcpy((PRUint8*)map.pData + map.RowPitch * y,
54814:                destination + mBounds.width * 4 * y,
54814:                mBounds.width * 4);
54814:       }
54814:       delete [] destination;
54814:     }
54814:     mTexture->Unmap(0);
54814:   } else if (mSurface) {
54814:     RECT r;
54814:     r.left = aRect.x;
54814:     r.top = aRect.y;
54814:     r.right = aRect.XMost();
54814:     r.bottom = aRect.YMost();
54814: 
54814:     D3D10_MAPPED_TEXTURE2D map;
54814:     HRESULT hr = mTexture->Map(0, D3D10_MAP_WRITE_DISCARD, 0, &map);
54814: 
54814:     if (FAILED(hr)) {
54814:       NS_WARNING("Failed to lock CanvasLayer texture.");
54814:       return;
54814:     }
54814: 
54814:     PRUint8 *startBits;
54814:     PRUint32 sourceStride;
54814: 
54814:     nsRefPtr<gfxImageSurface> dstSurface;
54814: 
54814:     dstSurface = new gfxImageSurface((unsigned char*)map.pData,
54814:                                      gfxIntSize(aRect.width, aRect.height),
54814:                                      map.RowPitch,
54814:                                      gfxASurface::ImageFormatARGB32);
54814:     nsRefPtr<gfxContext> ctx = new gfxContext(dstSurface);
54814:     ctx->Translate(gfxPoint(-aRect.x, -aRect.y));
54814:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
54814:     ctx->SetSource(mSurface);
54814:     ctx->Paint();
54814:     
54814:     mTexture->Unmap(0);
54814:   }
54814: }
54814: 
54814: Layer*
54814: CanvasLayerD3D10::GetLayer()
54814: {
54814:   return this;
54814: }
54814: 
54814: void
57097: CanvasLayerD3D10::RenderLayer()
54814: {
54814:   if (!mTexture) {
54814:     return;
54814:   }
54814: 
54814:   nsIntRect visibleRect = mVisibleRegion.GetBounds();
54814: 
57097:   SetEffectTransformAndOpacity();
54814: 
54814:   ID3D10EffectTechnique *technique;
54814: 
54814:   if (mDataIsPremultiplied) {
62302:     if (!mHasAlpha) {
54814:       if (mFilter == gfxPattern::FILTER_NEAREST) {
54814:         technique = effect()->GetTechniqueByName("RenderRGBLayerPremulPoint");
54814:       } else {
54814:         technique = effect()->GetTechniqueByName("RenderRGBLayerPremul");
54814:       }
54814:     } else {
54814:       if (mFilter == gfxPattern::FILTER_NEAREST) {
54814:         technique = effect()->GetTechniqueByName("RenderRGBALayerPremulPoint");
54814:       } else {
54814:         technique = effect()->GetTechniqueByName("RenderRGBALayerPremul");
54814:       }
54814:     }
54814:   } else {
54814:     if (mFilter == gfxPattern::FILTER_NEAREST) {
54814:       technique = effect()->GetTechniqueByName("RenderRGBALayerNonPremulPoint");
54814:     } else {
54814:       technique = effect()->GetTechniqueByName("RenderRGBALayerNonPremul");
54814:     }
54814:   }
54814: 
54814:   if (mSRView) {
54814:     effect()->GetVariableByName("tRGB")->AsShaderResource()->SetResource(mSRView);
54814:   }
54814: 
54814:   effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
54814:     ShaderConstantRectD3D10(
54814:       (float)mBounds.x,
54814:       (float)mBounds.y,
54814:       (float)mBounds.width,
54814:       (float)mBounds.height)
54814:     );
54814: 
54814:   if (mNeedsYFlip) {
54814:     effect()->GetVariableByName("vTextureCoords")->AsVector()->SetFloatVector(
54814:       ShaderConstantRectD3D10(
54814:         0,
54814:         1.0f,
54814:         1.0f,
54814:         -1.0f)
54814:       );
54814:   }
54814: 
54814:   technique->GetPassByIndex(0)->Apply(0);
54814:   device()->Draw(4, 0);
54814: 
54814:   if (mNeedsYFlip) {
54814:     effect()->GetVariableByName("vTextureCoords")->AsVector()->
54814:       SetFloatVector(ShaderConstantRectD3D10(0, 0, 1.0f, 1.0f));
54814:   }
54814: }
54814: 
54814: } /* namespace layers */
54814: } /* namespace mozilla */
