 91662: /* This Source Code Form is subject to the terms of the Mozilla Public
 91662:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 91662:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 82881: 
103434: "use strict";
103434: 
 82881: const Cu = Components.utils;
 82881: const Cc = Components.classes;
 82881: const Ci = Components.interfaces;
104255: const Cr = Components.results;
 82881: 
 82881: let EXPORTED_SYMBOLS = ["DOMApplicationRegistry", "DOMApplicationManifest"];
 82881: 
 82881: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 82881: Cu.import("resource://gre/modules/Services.jsm");
 83476: Cu.import("resource://gre/modules/FileUtils.jsm");
105921: Cu.import('resource://gre/modules/ActivitiesService.jsm');
 82881: 
 95600: const WEBAPP_RUNTIME = Services.appinfo.ID == "webapprt@mozilla.org";
 95600: 
 82881: XPCOMUtils.defineLazyGetter(this, "NetUtil", function() {
 82881:   Cu.import("resource://gre/modules/NetUtil.jsm");
 82881:   return NetUtil;
 82881: });
 82881: 
 94956: XPCOMUtils.defineLazyGetter(this, "ppmm", function() {
104255:   return Cc["@mozilla.org/parentprocessmessagemanager;1"]
104255:          .getService(Ci.nsIFrameMessageManager);
 94956: });
 94956: 
105921: XPCOMUtils.defineLazyServiceGetter(this, "cpmm",
105921:                                    "@mozilla.org/childprocessmessagemanager;1",
105921:                                    "nsIFrameMessageManager");
105921: 
103434: XPCOMUtils.defineLazyGetter(this, "msgmgr", function() {
104255:   return Cc["@mozilla.org/system-message-internal;1"]
104255:          .getService(Ci.nsISystemMessagesInternal);
103434: });
103434: 
 93873: #ifdef MOZ_WIDGET_GONK
 93873:   const DIRECTORY_NAME = "webappsDir";
108471: #elifdef ANDROID
108471:   const DIRECTORY_NAME = "webappsDir";
 93873: #else
 95600:   // If we're executing in the context of the webapp runtime, the data files
 95600:   // are in a different directory (currently the Firefox profile that installed
 95600:   // the webapp); otherwise, they're in the current profile.
 95600:   const DIRECTORY_NAME = WEBAPP_RUNTIME ? "WebappRegD" : "ProfD";
 93873: #endif
 93873: 
 82881: let DOMApplicationRegistry = {
 82881:   appsFile: null,
 82881:   webapps: { },
103266:   allAppsLaunchable: false,
 82881: 
 82881:   init: function() {
 92151:     this.messages = ["Webapps:Install", "Webapps:Uninstall",
103268:                     "Webapps:GetSelf",
103268:                     "Webapps:GetInstalled", "Webapps:GetNotInstalled",
104255:                     "Webapps:Launch", "Webapps:GetAll",
106582:                     "Webapps:InstallPackage", "Webapps:GetBasePath",
107824:                     "WebApps:GetAppByManifestURL", "WebApps:GetAppLocalIdByManifestURL",
108466:                     "WebApps:GetAppByLocalId", "WebApps:GetManifestURLByLocalId"];
 82881: 
 92151:     this.messages.forEach((function(msgName) {
 94956:       ppmm.addMessageListener(msgName, this);
 82881:     }).bind(this));
 82881: 
 92151:     Services.obs.addObserver(this, "xpcom-shutdown", false);
 92151: 
104255:     this.appsFile = FileUtils.getFile(DIRECTORY_NAME,
104255:                                       ["webapps", "webapps.json"], true);
 83476: 
 95827:     if (this.appsFile.exists()) {
103434:       this._loadJSONAsync(this.appsFile, (function(aData) {
103434:         this.webapps = aData;
104000:         for (let id in this.webapps) {
103434: #ifdef MOZ_SYS_MSG
105921:           this._processManifestForId(id);
104000: #endif
104000:           if (!this.webapps[id].localId) {
104000:             this.webapps[id].localId = this._nextLocalId();
104000:           }
103434:         };
103434:       }).bind(this));
 95827:     }
 84659: 
 84659:     try {
 95827:       let hosts = Services.prefs.getCharPref("dom.mozApps.whitelist");
 84659:       hosts.split(",").forEach(function(aHost) {
104255:         Services.perms.add(Services.io.newURI(aHost, null, null),
104255:                            "webapps-manage",
 84659:                            Ci.nsIPermissionManager.ALLOW_ACTION);
 84659:       });
 84659:     } catch(e) { }
 83473:   },
 83473: 
103434: #ifdef MOZ_SYS_MSG
103434:   _registerSystemMessages: function(aManifest, aApp) {
104255:     if (aManifest.messages && Array.isArray(aManifest.messages) &&
104255:         aManifest.messages.length > 0) {
103434:       let manifest = new DOMApplicationManifest(aManifest, aApp.origin);
103434:       let launchPath = Services.io.newURI(manifest.fullLaunchPath(), null, null);
103434:       let manifestURL = Services.io.newURI(aApp.manifestURL, null, null);
103434:       aManifest.messages.forEach(function registerPages(aMessage) {
103434:         msgmgr.registerPage(aMessage, launchPath, manifestURL);
103434:       });
103434:     }
103434:   },
103434: 
105921:   _registerActivities: function(aManifest, aApp) {
105921:     if (!aManifest.activities) {
105921:       return;
105921:     }
105921: 
105921:     let manifest = new DOMApplicationManifest(aManifest, aApp.origin);
105921:     for (let activity in aManifest.activities) {
105921:       let description = aManifest.activities[activity];
108431:       if (!description.href) {
108431:         description.href = manifest.launch_path;
108431:       }
108431:       description.href = manifest.resolveFromOrigin(description.href);
105921:       let json = {
105921:         "manifest": aApp.manifestURL,
105921:         "name": activity,
105921:         "title": manifest.name,
105921:         "icon": manifest.iconURLForSize(128),
105921:         "description": description
105921:       }
105921:       cpmm.sendAsyncMessage("Activities:Register", json);
105921: 
105921:       let launchPath =
107967:         Services.io.newURI(manifest.resolveFromOrigin(description.href), null, null);
105921:       let manifestURL = Services.io.newURI(aApp.manifestURL, null, null);
105921:       msgmgr.registerPage("activity", launchPath, manifestURL);
105921:     }
105921:   },
105921: 
105921:   _unregisterActivities: function(aManifest, aApp) {
105921:     if (!aManifest.activities) {
105921:       return;
105921:     }
105921: 
105921:     for (let activity in aManifest.activities) {
105921:       let description = aManifest.activities[activity];
105921:       let json = {
105921:         "manifest": aApp.manifestURL,
105921:         "name": activity
105921:       }
105921:       cpmm.sendAsyncMessage("Activities:Unregister", json);
105921:     }
105921:   },
105921: 
105921:   _processManifestForId: function(aId) {
103434:     let app = this.webapps[aId];
103434:     this._readManifests([{ id: aId }], (function registerManifest(aResult) {
105921:       let manifest = aResult[0].manifest;
105921:       this._registerSystemMessages(manifest, app);
105921:       this._registerActivities(manifest, app);
103434:     }).bind(this));
103434:   },
103434: #endif
103434: 
 92151:   observe: function(aSubject, aTopic, aData) {
 92151:     if (aTopic == "xpcom-shutdown") {
 92151:       this.messages.forEach((function(msgName) {
 94956:         ppmm.removeMessageListener(msgName, this);
 92151:       }).bind(this));
 92151:       Services.obs.removeObserver(this, "xpcom-shutdown");
 94956:       ppmm = null;
 92151:     }
 92151:   },
 92151: 
 83473:   _loadJSONAsync: function(aFile, aCallback) {
 82881:     try {
 83473:       let channel = NetUtil.newChannel(aFile);
 82881:       channel.contentType = "application/json";
 82881:       NetUtil.asyncFetch(channel, function(aStream, aResult) {
 82881:         if (!Components.isSuccessCode(aResult)) {
104255:           Cu.reportError("DOMApplicationRegistry: Could not read from json file "
104255:                          + aFile.path);
 83473:           if (aCallback)
 83473:             aCallback(null);
 82881:           return;
 82881:         }
 82881: 
 82881:         // Read json file into a string
 82881:         let data = null;
 82881:         try {
106963:           // Obtain a converter to read from a UTF-8 encoded input stream.
106963:           let converter = Cc["@mozilla.org/intl/scriptableunicodeconverter"]
106963:                           .createInstance(Ci.nsIScriptableUnicodeConverter);
106963:           converter.charset = "UTF-8";
106963: 
106963:           data = JSON.parse(converter.ConvertToUnicode(NetUtil.readInputStreamToString(aStream,
106963:                                                             aStream.available()) || ""));
 82881:           aStream.close();
 83473:           if (aCallback)
 83473:             aCallback(data);
 82881:         } catch (ex) {
 82881:           Cu.reportError("DOMApplicationRegistry: Could not parse JSON: " + ex);
 83473:           if (aCallback)
 83473:             aCallback(null);
 82881:         }
 82881:       });
 82881:     } catch (ex) {
104255:       Cu.reportError("DOMApplicationRegistry: Could not read from " +
104255:                      aFile.path + " : " + ex);
 83473:       if (aCallback)
 83473:         aCallback(null);
 82881:     }
 82881:   },
 82881: 
 82881:   receiveMessage: function(aMessage) {
103970:     // nsIPrefBranch throws if pref does not exist, faster to simply write
103970:     // the pref instead of first checking if it is false.
103970:     Services.prefs.setBoolPref("dom.mozApps.used", true);
103970: 
 82881:     let msg = aMessage.json;
 82881: 
 82881:     switch (aMessage.name) {
 82881:       case "Webapps:Install":
 82881:         // always ask for UI to install
 82881:         Services.obs.notifyObservers(this, "webapps-ask-install", JSON.stringify(msg));
 82881:         break;
 91662:       case "Webapps:GetSelf":
 91662:         this.getSelf(msg);
 91662:         break;
 82881:       case "Webapps:Uninstall":
107915:         Services.obs.notifyObservers(this, "webapps-uninstall", JSON.stringify(msg));
 82881:         this.uninstall(msg);
 82881:         break;
 82881:       case "Webapps:Launch":
105412:         Services.obs.notifyObservers(this, "webapps-launch", JSON.stringify(msg));
 82881:         break;
 91662:       case "Webapps:GetInstalled":
 91662:         this.getInstalled(msg);
 82881:         break;
103268:       case "Webapps:GetNotInstalled":
103268:         this.getNotInstalled(msg);
103268:         break;
 91662:       case "Webapps:GetAll":
 91662:         if (msg.hasPrivileges)
 91662:           this.getAll(msg);
 91662:         else
 94956:           ppmm.sendAsyncMessage("Webapps:GetAll:Return:KO", msg);
 84659:         break;
104255:       case "Webapps:InstallPackage":
104255:         this.installPackage(msg);
104255:         break;
104256:       case "Webapps:GetBasePath":
104256:         return FileUtils.getFile(DIRECTORY_NAME, ["webapps"], true).path;
104256:         break;
106582:       case "WebApps:GetAppByManifestURL":
106582:         return this.getAppByManifestURL(msg.url);
106582:         break;
106582:       case "WebApps:GetAppLocalIdByManifestURL":
106582:         return { id: this.getAppLocalIdByManifestURL(msg.url) };
106582:         break;
107824:       case "WebApps:GetAppByLocalId":
107824:         return this.getAppByLocalId(msg.id);
107824:         break;
107824:       case "WebApps:GetManifestURLByLocalId":
107824:         return this.getManifestURLByLocalId(msg.id);
107824:         break;
 82881:     }
 82881:   },
 82881: 
 82881:   _writeFile: function ss_writeFile(aFile, aData, aCallbak) {
 82881:     // Initialize the file output stream.
 83476:     let ostream = FileUtils.openSafeFileOutputStream(aFile);
 82881: 
 82881:     // Obtain a converter to convert our data to a UTF-8 encoded input stream.
104255:     let converter = Cc["@mozilla.org/intl/scriptableunicodeconverter"]
104255:                     .createInstance(Ci.nsIScriptableUnicodeConverter);
 82881:     converter.charset = "UTF-8";
 82881: 
 82881:     // Asynchronously copy the data to the file.
 82881:     let istream = converter.convertToInputStream(aData);
 82881:     NetUtil.asyncCopy(istream, ostream, function(rc) {
 82881:       if (aCallbak)
 82881:         aCallbak();
 82881:     });
 82881:   },
 82881: 
 82881:   // clones a app object, without the manifest
 82881:   _cloneAppObject: function(aApp) {
 82881:     let clone = {
 82881:       installOrigin: aApp.installOrigin,
 82881:       origin: aApp.origin,
107742:       receipts: aApp.receipts ? JSON.parse(JSON.stringify(aApp.receipts)) : null,
 91662:       installTime: aApp.installTime,
102594:       manifestURL: aApp.manifestURL,
102594:       progress: aApp.progress || 0.0,
102594:       status: aApp.status || "installed"
 82881:     };
 82881:     return clone;
 82881:   },
 82881: 
 82881:   denyInstall: function(aData) {
104255:     let packageId = aData.app.packageId;
104255:     if (packageId) {
104255:       let dir = FileUtils.getDir("TmpD", ["webapps", packageId],
104255:                                  true, true);
104255:       try {
104255:         dir.remove(true);
104255:       } catch(e) {
104255:       }
104255:     }
 94956:     ppmm.sendAsyncMessage("Webapps:Install:Return:KO", aData);
 82881:   },
 82881: 
102594:   confirmInstall: function(aData, aFromSync, aProfileDir, aOfflineCacheObserver) {
 82881:     let app = aData.app;
 84971:     let id = app.syncId || this._appId(app.origin);
104000:     let localId = this.getAppLocalIdByManifestURL(app.manifestURL);
 82881: 
104255:     // Installing an application again is considered as an update.
 82881:     if (id) {
 93873:       let dir = FileUtils.getDir(DIRECTORY_NAME, ["webapps", id], true, true);
 82881:       try {
 82881:         dir.remove(true);
 82881:       } catch(e) {
 82881:       }
 97976:     } else {
 97976:       id = this.makeAppId();
104000:       localId = this._nextLocalId();
 82881:     }
 82881: 
104255:     if (app.packageId) {
104255:       // Override the origin with the correct id.
104255:       app.origin = "app://" + id;
104255:     }
104255: 
 97976:     let appObject = this._cloneAppObject(app);
102252:     appObject.installTime = app.installTime = Date.now();
 97976:     let appNote = JSON.stringify(appObject);
 97976:     appNote.id = id;
 97976: 
104000:     appObject.localId = localId;
104000: 
 93873:     let dir = FileUtils.getDir(DIRECTORY_NAME, ["webapps", id], true, true);
 82881:     let manFile = dir.clone();
 99133:     manFile.append("manifest.webapp");
104255:     this._writeFile(manFile, JSON.stringify(app.manifest), function() {
104255:       // If this a packaged app, move the zip file from the temp directory,
104255:       // and delete the temp directory.
104255:       if (app.packageId) {
104255:         let appFile = FileUtils.getFile("TmpD", ["webapps", app.packageId, "application.zip"], 
104255:                                         true, true);
104255:         appFile.moveTo(dir, "application.zip");
104255:         let tmpDir = FileUtils.getDir("TmpD", ["webapps", app.packageId], 
104255:                                         true, true);
104255:         try {
104255:           tmpDir.remove(true);
104255:         } catch(e) {
104255:         }
104255:       }
104255:     });
 97976:     this.webapps[id] = appObject;
 84971: 
102594:     appObject.status = "installed";
102594:     
102594:     let manifest = new DOMApplicationManifest(app.manifest, app.origin);
102594: 
 84971:     if (!aFromSync)
 84971:       this._saveApps((function() {
 94956:         ppmm.sendAsyncMessage("Webapps:Install:Return:OK", aData);
 97976:         Services.obs.notifyObservers(this, "webapps-sync-install", appNote);
 82881:       }).bind(this));
102594: 
103434: #ifdef MOZ_SYS_MSG
103434:     this._registerSystemMessages(id, app);
103434: #endif
103434: 
102594:     // if the manifest has an appcache_path property, use it to populate the appcache
102594:     if (manifest.appcache_path) {
102594:       let appcacheURI = Services.io.newURI(manifest.fullAppcachePath(), null, null);
102594:       let updateService = Cc["@mozilla.org/offlinecacheupdate-service;1"]
102594:                             .getService(Ci.nsIOfflineCacheUpdateService);
102594:       let docURI = Services.io.newURI(manifest.fullLaunchPath(), null, null);
102594:       let cacheUpdate = aProfileDir ? updateService.scheduleCustomProfileUpdate(appcacheURI, docURI, aProfileDir)
102594:                                     : updateService.scheduleUpdate(appcacheURI, docURI, null);
102594:       cacheUpdate.addObserver(new AppcacheObserver(appObject), false);
102594:       if (aOfflineCacheObserver) {
102594:         cacheUpdate.addObserver(aOfflineCacheObserver, false);
102594:       }
102594:     }
 82881:   },
 82881: 
104000:   _nextLocalId: function() {
105847:     let maxLocalId = Ci.nsIScriptSecurityManager.NO_APP_ID;
105847: 
104000:     for (let id in this.webapps) {
104000:       if (this.webapps[id].localId > maxLocalId) {
104000:         maxLocalId = this.webapps[id].localId;
104000:       }
104000:     }
104000: 
104000:     return maxLocalId + 1;
104000:   },
104000: 
 82881:   _appId: function(aURI) {
 82881:     for (let id in this.webapps) {
 82881:       if (this.webapps[id].origin == aURI)
 82881:         return id;
 82881:     }
 82881:     return null;
 82881:   },
 82881: 
 97976:   makeAppId: function() {
 97976:     let uuidGenerator = Cc["@mozilla.org/uuid-generator;1"].getService(Ci.nsIUUIDGenerator);
 97976:     return uuidGenerator.generateUUID().toString();
 97976:   },
 97976: 
 84971:   _saveApps: function(aCallback) {
 84971:     this._writeFile(this.appsFile, JSON.stringify(this.webapps), function() {
 84971:       if (aCallback)
 84971:         aCallback();
 84971:     });
 84971:   },
 84971: 
 83473:   /**
 83473:     * Asynchronously reads a list of manifests
 83473:     */
 83473:   _readManifests: function(aData, aFinalCallback, aIndex) {
 84659:     if (!aData.length) {
 84659:       aFinalCallback(aData);
 84659:       return;
 84659:     }
 84659: 
 83473:     let index = aIndex || 0;
 83473:     let id = aData[index].id;
 99133: 
 99133:     // the manifest file used to be named manifest.json, so fallback on this.
 99133:     let file = FileUtils.getFile(DIRECTORY_NAME, ["webapps", id, "manifest.webapp"], true);
 99133:     if (!file.exists()) {
 99133:       file = FileUtils.getFile(DIRECTORY_NAME, ["webapps", id, "manifest.json"], true);
 99133:     }
 99133: 
 83473:     this._loadJSONAsync(file, (function(aJSON) {
 83473:       aData[index].manifest = aJSON;
 83473:       if (index == aData.length - 1)
 83473:         aFinalCallback(aData);
 83473:       else
 83473:         this._readManifests(aData, aFinalCallback, index + 1);
 83473:     }).bind(this));
 82881:   },
 82881: 
104255:   installPackage: function(aData) {
104255:     // Here are the steps when installing a package:
104255:     // - create a temp directory where to store the app.
104255:     // - download the zip in this directory.
104255:     // - extract the manifest from the zip and check it.
104255:     // - ask confirmation to the user.
104255:     // - add the new app to the registry.
104255:     // If we fail at any step, we backout the previous ones and return an error.
104255: 
104255:     let id;
104255:     let manifestURL = "jar:" + aData.url + "!manifest.webapp";
104255:     // Check if we reinstall a known application.
104255:     for (let appId in this.webapps) {
104255:       if (this.webapps[appId].manifestURL == manifestURL) {
104255:         id = appId;
104255:       }
104255:     }
104255: 
104255:     // New application.
104255:     if (!id) {
104255:       id = this.makeAppId();
104255:     }
104255: 
104255:     let dir = FileUtils.getDir("TmpD", ["webapps", id], true, true);
104255: 
104255:     /** from https://developer.mozilla.org/en/OpenWebApps/The_Manifest
104255:      * only the name property is mandatory
104255:      */
104255:     function checkManifest(aManifest) {
104255:       if (aManifest.name == undefined)
104255:         return false;
104255: 
104255:       if (aManifest.installs_allowed_from) {
104255:         return aManifest.installs_allowed_from.some(function(aOrigin) {
104255:           return aOrigin == "*" || aOrigin == aData.installOrigin;
104255:         });
104255:       }
104255:       return true;
104255:     }
104255: 
104255:     // Removes the directory we created, and sends an error to the DOM side.
104255:     function cleanup(aError) {
104255:       try {
104255:         dir.remove(true);
104255:       } catch (e) { }
104255:       ppmm.sendAsyncMessage("Webapps:Install:Return:KO",
104255:                             { oid: aData.oid,
104255:                               requestID: aData.requestID,
104255:                               error: aError });
104255:     }
104255: 
104255:     NetUtil.asyncFetch(aData.url, function(aInput, aResult, aRequest) {
104255:       if (!Components.isSuccessCode(aResult)) {
104255:         // We failed to fetch the zip.
104255:         cleanup("NETWORK_ERROR");
104255:         return;
104255:       }
104255:       // Copy the zip on disk.
104255:       let zipFile = FileUtils.getFile("TmpD",
104255:                                       ["webapps", id, "application.zip"], true);
104255:       let ostream = FileUtils.openSafeFileOutputStream(zipFile);
104255:       NetUtil.asyncCopy(aInput, ostream, function (aResult) {
104255:         if (!Components.isSuccessCode(aResult)) {
104255:           // We failed to save the zip.
104255:           cleanup("DOWNLOAD_ERROR");
104255:           return;
104255:         }
104255:         // Build a data structure to call the webapps confirmation dialog :
104255:         // - load the manifest from the zip
107614:         // - set data.app.(origin, install_origin, manifestURL, manifest, receipts, categories)
104255:         // - call notifyObservers(this, "webapps-ask-install", JSON.stringify(msg));
104255:         let msg = {
104255:           from: aData.from,
104255:           oid: aData.oid,
104255:           requestId: aData.requestId,
104255:           app: {
104255:             packageId: id,
104255:             installOrigin: aData.installOrigin,
104255:             origin: "app://" + id,
104255:             manifestURL: manifestURL,
107614:             receipts: aData.receipts,
107614:             categories: aData.categories
104255:           }
104255:         }
104255:         let zipReader = Cc["@mozilla.org/libjar/zip-reader;1"]
104255:                         .createInstance(Ci.nsIZipReader);
104255:         try {
104255:           zipReader.open(zipFile);
104255:           if (!zipReader.hasEntry("manifest.webapp")) {
104255:             throw "No manifest.webapp found.";
104255:           }
104255: 
104255:           let istream = zipReader.getInputStream("manifest.webapp");
104255:           msg.app.manifest = JSON.parse(NetUtil.readInputStreamToString(istream,
104255:                                         istream.available()) || "");
104255:           if (!checkManifest(msg.app.manifest)) {
104255:             throw "Invalid manifest";
104255:           }
104255: 
104255:           Services.obs.notifyObservers(this, "webapps-ask-install",
104255:                                              JSON.stringify(msg));
104255:         } catch (e) {
104255:           // XXX we may need new error messages.
104255:           cleanup("INVALID_MANIFEST");
104255:         } finally {
104255:           zipReader.close();
104255:         }
104255:       });
104255:     });
104255:   },
104255: 
 82881:   uninstall: function(aData) {
 91662:     let found = false;
 82881:     for (let id in this.webapps) {
 82881:       let app = this.webapps[id];
105921:       if (app.origin != aData.origin) {
105921:         continue;
105921:       }
105921: 
 91662:       found = true;
 97976:       let appNote = JSON.stringify(this._cloneAppObject(app));
 97976:       appNote.id = id;
 97976: 
105921:       this._readManifests([{ id: id }], (function unregisterManifest(aResult) {
105921: #ifdef MOZ_SYS_MSG
105921:         this._unregisterActivities(aResult[0].manifest, app);
105921: #endif
105921:       }).bind(this));
105921: 
 93873:       let dir = FileUtils.getDir(DIRECTORY_NAME, ["webapps", id], true, true);
 82881:       try {
 82881:         dir.remove(true);
105921:       } catch (e) {}
105921: 
105921:       delete this.webapps[id];
 97976: 
 84971:       this._saveApps((function() {
 94956:         ppmm.sendAsyncMessage("Webapps:Uninstall:Return:OK", aData);
 97976:         Services.obs.notifyObservers(this, "webapps-sync-uninstall", appNote);
 84971:       }).bind(this));
 82881:     }
105921: 
105921:     if (!found) {
105921:       ppmm.sendAsyncMessage("Webapps:Uninstall:Return:KO", aData);
 82881:     }
 82881:   },
 82881: 
 91662:   getSelf: function(aData) {
 82881:     aData.apps = [];
 83473:     let tmp = [];
 91662:     let id = this._appId(aData.origin);
 82881: 
103420:     if (id && this._isLaunchable(this.webapps[id].origin)) {
 82881:       let app = this._cloneAppObject(this.webapps[id]);
 82881:       aData.apps.push(app);
 83473:       tmp.push({ id: id });
 82881:     }
 82881: 
 83473:     this._readManifests(tmp, (function(aResult) {
 83473:       for (let i = 0; i < aResult.length; i++)
 83473:         aData.apps[i].manifest = aResult[i].manifest;
 94956:       ppmm.sendAsyncMessage("Webapps:GetSelf:Return:OK", aData);
 83473:     }).bind(this));
 82881:   },
 82881: 
 91662:   getInstalled: function(aData) {
 91662:     aData.apps = [];
 91662:     let tmp = [];
 91662: 
103267:     for (let id in this.webapps) {
103267:       if (this.webapps[id].installOrigin == aData.origin &&
103420:           this._isLaunchable(this.webapps[id].origin)) {
 91662:         aData.apps.push(this._cloneAppObject(this.webapps[id]));
 91662:         tmp.push({ id: id });
 91662:       }
 91662:     }
 91662: 
 91662:     this._readManifests(tmp, (function(aResult) {
 91662:       for (let i = 0; i < aResult.length; i++)
 91662:         aData.apps[i].manifest = aResult[i].manifest;
 94956:       ppmm.sendAsyncMessage("Webapps:GetInstalled:Return:OK", aData);
 91662:     }).bind(this));
 82881:   },
 82881: 
103268:   getNotInstalled: function(aData) {
103268:     aData.apps = [];
103268:     let tmp = [];
103268: 
103268:     for (let id in this.webapps) {
103268:       if (this.webapps[id].installOrigin == aData.origin &&
103420:           !this._isLaunchable(this.webapps[id].origin)) {
103268:         aData.apps.push(this._cloneAppObject(this.webapps[id]));
103268:         tmp.push({ id: id });
103268:       }
103268:     }
103268: 
103268:     this._readManifests(tmp, (function(aResult) {
103268:       for (let i = 0; i < aResult.length; i++)
103268:         aData.apps[i].manifest = aResult[i].manifest;
103268:       ppmm.sendAsyncMessage("Webapps:GetNotInstalled:Return:OK", aData);
103268:     }).bind(this));
103268:   },
103268: 
 91662:   getAll: function(aData) {
 82881:     aData.apps = [];
 83473:     let tmp = [];
 82881: 
 97976:     for (let id in this.webapps) {
 82881:       let app = this._cloneAppObject(this.webapps[id]);
103420:       if (!this._isLaunchable(app.origin))
103267:         continue;
103267: 
 82881:       aData.apps.push(app);
 83473:       tmp.push({ id: id });
 82881:     }
 82881: 
 83473:     this._readManifests(tmp, (function(aResult) {
 83473:       for (let i = 0; i < aResult.length; i++)
 83473:         aData.apps[i].manifest = aResult[i].manifest;
 94956:       ppmm.sendAsyncMessage("Webapps:GetAll:Return:OK", aData);
 83473:     }).bind(this));
 82881:   },
 82881: 
 83473:   getManifestFor: function(aOrigin, aCallback) {
 83473:     if (!aCallback)
 83473:       return;
 83473: 
 82881:     let id = this._appId(aOrigin);
 83473:     if (!id) {
 83473:       aCallback(null);
 83473:       return;
 83473:     }
 83473: 
 83473:     this._readManifests([{ id: id }], function(aResult) {
 83473:       aCallback(aResult[0].manifest);
 83473:     });
 84971:   },
 84971: 
 97976:   /** Added to support AITC and classic sync */
 97976:   itemExists: function(aId) {
 97976:     return !!this.webapps[aId];
 97976:   },
 84971: 
 84971:   getAppById: function(aId) {
 84971:     if (!this.webapps[aId])
 84971:       return null;
 84971: 
 84971:     let app = this._cloneAppObject(this.webapps[aId]);
 84971:     return app;
 84971:   },
 84971: 
 98631:   getAppByManifestURL: function(aManifestURL) {
 98631:     // This could be O(1) if |webapps| was a dictionary indexed on manifestURL
 98631:     // which should be the unique app identifier.
 98631:     // It's currently O(n).
 98631:     for (let id in this.webapps) {
 98631:       let app = this.webapps[id];
 98631:       if (app.manifestURL == aManifestURL) {
107919:         let res = this._cloneAppObject(app);
107919:         res.hasPermission = function(permission) {
107919:           let localId = DOMApplicationRegistry.getAppLocalIdByManifestURL(
107919:             this.manifestURL);
107919:           let uri = Services.io.newURI(this.manifestURL, null, null);
107919:           let secMan = Cc["@mozilla.org/scriptsecuritymanager;1"]
107919:                        .getService(Ci.nsIScriptSecurityManager);
107919:           // XXX for the purposes of permissions checking, this helper
107919:           // should always be called on !isBrowser frames, so we
107919:           // assume false here.
107919:           let principal = secMan.getAppCodebasePrincipal(uri, localId,
107919:                                                          /*mozbrowser*/false);
107919:           let perm = Services.perms.testExactPermissionFromPrincipal(principal,
107919:                                                                      permission);
107919:           return (perm === Ci.nsIPermissionManager.ALLOW_ACTION);
107919:         };
107919:         res.QueryInterface = XPCOMUtils.generateQI([Ci.mozIDOMApplication,
107919:                                                     Ci.mozIApplication]);
107919:         return res;
 98631:       }
 98631:     }
 98631: 
 98631:     return null;
 98631:   },
 98631: 
107824:   getAppByLocalId: function(aLocalId) {
107824:     for (let id in this.webapps) {
107824:       let app = this.webapps[id];
107824:       if (app.localId == aLocalId) {
107824:         return this._cloneAppObject(app);
107824:       }
107824:     }
107824: 
107824:     return null;
107824:   },
107824: 
107824:   getManifestURLByLocalId: function(aLocalId) {
107824:     for (let id in this.webapps) {
107824:       let app = this.webapps[id];
107824:       if (app.localId == aLocalId) {
107824:         return app.manifestURL;
107824:       }
107824:     }
107824: 
107824:     return null;
107824:   },
107824: 
104000:   getAppLocalIdByManifestURL: function(aManifestURL) {
104000:     for (let id in this.webapps) {
104000:       if (this.webapps[id].manifestURL == aManifestURL) {
104000:         return this.webapps[id].localId;
104000:       }
104000:     }
104000: 
105847:     return Ci.nsIScriptSecurityManager.NO_APP_ID;
104000:   },
104000: 
 97976:   getAllWithoutManifests: function(aCallback) {
 97976:     let result = {};
 97976:     for (let id in this.webapps) {
 97976:       let app = this._cloneAppObject(this.webapps[id]);
 97976:       result[id] = app;
 97976:     }
 97976:     aCallback(result);
 84971:   },
 84971: 
 84971:   updateApps: function(aRecords, aCallback) {
 84971:     for (let i = 0; i < aRecords.length; i++) {
 84971:       let record = aRecords[i];
102971:       if (record.hidden) {
 84971:         if (!this.webapps[record.id])
 84971:           continue;
 84971:         let origin = this.webapps[record.id].origin;
 84971:         delete this.webapps[record.id];
 93873:         let dir = FileUtils.getDir(DIRECTORY_NAME, ["webapps", record.id], true, true);
 84971:         try {
 84971:           dir.remove(true);
 84971:         } catch (e) {
 84971:         }
 94956:         ppmm.sendAsyncMessage("Webapps:Uninstall:Return:OK", { origin: origin });
 84971:       } else {
 97976:         if (this.webapps[record.id]) {
 84971:           this.webapps[record.id] = record.value;
 84971:           delete this.webapps[record.id].manifest;
 97976:         } else {
 84971:           let data = { app: record.value };
 84971:           this.confirmInstall(data, true);
 94956:           ppmm.sendAsyncMessage("Webapps:Install:Return:OK", data);
 84971:         }
 84971:       }
 84971:     }
 84971:     this._saveApps(aCallback);
 84971:   },
 84971: 
 84971:   getAllIDs: function() {
 84971:     let apps = {};
 84971:     for (let id in this.webapps) {
 84971:       // only sync http and https apps
 84971:       if (this.webapps[id].origin.indexOf("http") == 0)
 84971:         apps[id] = true;
 84971:     }
 84971:     return apps;
 84971:   },
 84971: 
 84971:   wipe: function(aCallback) {
 84971:     let ids = this.getAllIDs();
 84971:     for (let id in ids) {
 84971:       delete this.webapps[id];
 93873:       let dir = FileUtils.getDir(DIRECTORY_NAME, ["webapps", id], true, true);
 84971:       try {
 84971:         dir.remove(true);
 84971:       } catch (e) {
 84971:       }
 84971:     }
 84971:     this._saveApps(aCallback);
103266:   },
103266: 
103266:   _isLaunchable: function(aOrigin) {
103266:     if (this.allAppsLaunchable)
103266:       return true;
103266: 
103266: #ifdef XP_WIN
103266:     let uninstallKey = Cc["@mozilla.org/windows-registry-key;1"]
103266:                          .createInstance(Ci.nsIWindowsRegKey);
103266:     try {
103266:       uninstallKey.open(uninstallKey.ROOT_KEY_CURRENT_USER,
103266:                         "SOFTWARE\\Microsoft\\Windows\\" +
103266:                         "CurrentVersion\\Uninstall\\" +
103266:                         aOrigin,
103266:                         uninstallKey.ACCESS_READ);
103266:       uninstallKey.close();
103266:       return true;
103266:     } catch (ex) {
103266:       return false;
103266:     }
103266: #elifdef XP_MACOSX
103266:     let mwaUtils = Cc["@mozilla.org/widget/mac-web-app-utils;1"]
103266:                      .createInstance(Ci.nsIMacWebAppUtils);
103266: 
103266:     return !!mwaUtils.pathForAppWithIdentifier(aOrigin);
103266: #elifdef XP_UNIX
103266:     let env = Cc["@mozilla.org/process/environment;1"]
103266:                 .getService(Ci.nsIEnvironment);
103266:     let xdg_data_home_env = env.get("XDG_DATA_HOME");
103266: 
103266:     let desktopINI;
103266:     if (xdg_data_home_env != "") {
103266:       desktopINI = Cc["@mozilla.org/file/local;1"]
103266:                      .createInstance(Ci.nsIFile);
103266:       desktopINI.initWithPath(xdg_data_home_env);
103266:     }
103266:     else {
103266:       desktopINI = Services.dirsvc.get("Home", Ci.nsIFile);
103266:       desktopINI.append(".local");
103266:       desktopINI.append("share");
103266:     }
103266:     desktopINI.append("applications");
103266: 
103266:     let origin = Services.io.newURI(aOrigin, null, null);
103266:     let uniqueName = origin.scheme + ";" +
103266:                      origin.host +
103266:                      (origin.port != -1 ? ";" + origin.port : "");
103266: 
103266:     desktopINI.append("owa-" + uniqueName + ".desktop");
103266: 
103266:     return desktopINI.exists();
103266: #else
103266:     return true;
103266: #endif
103266: 
 82881:   }
 82881: };
 82881: 
 82881: /**
102594:  * Appcache download observer
102594:  */
103434: let AppcacheObserver = function(aApp) {
102594:   this.app = aApp;
102594: };
102594: 
102594: AppcacheObserver.prototype = {
102594:   // nsIOfflineCacheUpdateObserver implementation
102594:   updateStateChanged: function appObs_Update(aUpdate, aState) {
102594:     let mustSave = false;
102594:     let app = this.app;
102594: 
102594:     let setStatus = function appObs_setStatus(aStatus) {
102594:       mustSave = (app.status != aStatus);
102594:       app.status = aStatus;
102594:       ppmm.sendAsyncMessage("Webapps:OfflineCache", { manifest: app.manifestURL, status: aStatus });
102594:     }
102594: 
102594:     switch (aState) {
102594:       case Ci.nsIOfflineCacheUpdateObserver.STATE_ERROR:
102594:         aUpdate.removeObserver(this);
102594:         setStatus("cache-error");
102594:         break;
102594:       case Ci.nsIOfflineCacheUpdateObserver.STATE_NOUPDATE:
102594:       case Ci.nsIOfflineCacheUpdateObserver.STATE_FINISHED:
102594:         aUpdate.removeObserver(this);
102594:         setStatus("cached");
102594:         break;
102594:       case Ci.nsIOfflineCacheUpdateObserver.STATE_DOWNLOADING:
102594:       case Ci.nsIOfflineCacheUpdateObserver.STATE_ITEMSTARTED:
102594:       case Ci.nsIOfflineCacheUpdateObserver.STATE_ITEMPROGRESS:
102594:         setStatus("downloading")
102594:         break;
102594:     }
102594: 
102594:     // Status changed, update the stored version.
102594:     if (mustSave) {
102594:       DOMApplicationRegistry._saveApps();
102594:     }
102594:   },
102594: 
102594:   applicationCacheAvailable: function appObs_CacheAvail(aApplicationCache) {
102594:     // Nothing to do.
102594:   }
102594: };
102594: 
102594: /**
 82881:  * Helper object to access manifest information with locale support
 82881:  */
103434: let DOMApplicationManifest = function(aManifest, aOrigin) {
 82881:   this._origin = Services.io.newURI(aOrigin, null, null);
 82881:   this._manifest = aManifest;
 82881:   let chrome = Cc["@mozilla.org/chrome/chrome-registry;1"].getService(Ci.nsIXULChromeRegistry)
 82881:                                                           .QueryInterface(Ci.nsIToolkitChromeRegistry);
 82881:   let locale = chrome.getSelectedLocale("browser").toLowerCase();
 82881:   this._localeRoot = this._manifest;
 82881: 
 82881:   if (this._manifest.locales && this._manifest.locales[locale]) {
 82881:     this._localeRoot = this._manifest.locales[locale];
 82881:   }
 82881:   else if (this._manifest.locales) {
 82881:     // try with the language part of the locale ("en" for en-GB) only
 82881:     let lang = locale.split('-')[0];
 93752:     if (lang != locale && this._manifest.locales[lang])
 82881:       this._localeRoot = this._manifest.locales[lang];
 82881:   }
 97976: };
 82881: 
 82881: DOMApplicationManifest.prototype = {
 82881:   _localeProp: function(aProp) {
 82881:     if (this._localeRoot[aProp] != undefined)
 82881:       return this._localeRoot[aProp];
 82881:     return this._manifest[aProp];
 82881:   },
 82881: 
 82881:   get name() {
 82881:     return this._localeProp("name");
 82881:   },
 82881: 
 82881:   get description() {
 82881:     return this._localeProp("description");
 82881:   },
 82881: 
 82881:   get version() {
 82881:     return this._localeProp("version");
 82881:   },
 82881: 
 82881:   get launch_path() {
 82881:     return this._localeProp("launch_path");
 82881:   },
 82881: 
 82881:   get developer() {
 82881:     return this._localeProp("developer");
 82881:   },
 82881: 
 82881:   get icons() {
 82881:     return this._localeProp("icons");
 82881:   },
 82881: 
102594:   get appcache_path() {
102594:     return this._localeProp("appcache_path");
102594:   },
102594: 
107876:   get orientation() {
107876:     return this._localeProp("orientation");
107876:   },
107876: 
 82881:   iconURLForSize: function(aSize) {
 82881:     let icons = this._localeProp("icons");
 82881:     if (!icons)
 82881:       return null;
 82881:     let dist = 100000;
 82881:     let icon = null;
 82881:     for (let size in icons) {
 82881:       let iSize = parseInt(size);
 82881:       if (Math.abs(iSize - aSize) < dist) {
 82881:         icon = this._origin.resolve(icons[size]);
 82881:         dist = Math.abs(iSize - aSize);
 82881:       }
 82881:     }
 82881:     return icon;
 82881:   },
 82881: 
 97706:   fullLaunchPath: function(aStartPoint) {
 98017:     let startPoint = aStartPoint || "";
 97706:     let launchPath = this._localeProp("launch_path") || "";
 98017:     return this._origin.resolve(launchPath + startPoint);
102594:   },
102594: 
107967:   resolveFromOrigin: function(aURI) {
107967:     return this._origin.resolve(aURI);
107967:   },
107967: 
102594:   fullAppcachePath: function() {
102594:     let appcachePath = this._localeProp("appcache_path");
102594:     return this._origin.resolve(appcachePath ? appcachePath : "");
 82881:   }
 97976: };
 82881: 
 82881: DOMApplicationRegistry.init();
