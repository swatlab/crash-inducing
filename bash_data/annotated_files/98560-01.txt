42791: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
39997:  * ***** BEGIN LICENSE BLOCK *****
39997:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39997:  *
39997:  * The contents of this file are subject to the Mozilla Public License Version
39997:  * 1.1 (the "License"); you may not use this file except in compliance with
39997:  * the License. You may obtain a copy of the License at
39997:  * http://www.mozilla.org/MPL/
39997:  *
39997:  * Software distributed under the License is distributed on an "AS IS" basis,
39997:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39997:  * for the specific language governing rights and limitations under the
39997:  * License.
39997:  *
39997:  * The Original Code is Mozilla Corporation code.
39997:  *
39997:  * The Initial Developer of the Original Code is Mozilla Foundation.
39997:  * Portions created by the Initial Developer are Copyright (C) 2009
39997:  * the Initial Developer. All Rights Reserved.
39997:  *
39997:  * Contributor(s):
39997:  *   Bas Schouten <bschouten@mozilla.org>
42791:  *   Vladimir Vukicevic <vladimir@pobox.com>
39997:  *
39997:  * Alternatively, the contents of this file may be used under the terms of
39997:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39997:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39997:  * in which case the provisions of the GPL or the LGPL are applicable instead
39997:  * of those above. If you wish to allow use of your version of this file only
39997:  * under the terms of either the GPL or the LGPL, and not to allow others to
39997:  * use your version of this file under the terms of the MPL, indicate your
39997:  * decision by deleting the provisions above and replace them with the notice
39997:  * and other provisions required by the GPL or the LGPL. If you do not delete
39997:  * the provisions above, a recipient may use your version of this file under
39997:  * the terms of any one of the MPL, the GPL or the LGPL.
39997:  *
39997:  * ***** END LICENSE BLOCK ***** */
39997: 
55454: #include "gfxSharedImageSurface.h"
55454: 
39997: #include "ImageLayerOGL.h"
39997: #include "gfxImageSurface.h"
92920: #include "gfxUtils.h"
51999: #include "yuv_convert.h"
46145: #include "GLContextProvider.h"
67637: #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
67637: # include "GLXLibrary.h"
67637: # include "mozilla/X11Util.h"
67637: #endif
39997: 
92920: using namespace mozilla::gfx;
42441: using namespace mozilla::gl;
42441: 
39997: namespace mozilla {
39997: namespace layers {
39997: 
42441: /**
42441:  * This is an event used to unref a GLContext on the main thread and
42441:  * optionally delete a texture associated with that context.
42441:  */
42441: class TextureDeleter : public nsRunnable {
42441: public:
42441:   TextureDeleter(already_AddRefed<GLContext> aContext,
42441:                  GLuint aTexture)
42441:       : mContext(aContext), mTexture(aTexture)
42441:   {
49072:     NS_ASSERTION(aTexture, "TextureDeleter instantiated with nothing to do");
42441:   }
49072: 
42441:   NS_IMETHOD Run() {
49072:     mContext->MakeCurrent();
49072:     mContext->fDeleteTextures(1, &mTexture);
49072: 
42441:     // Ensure context is released on the main thread
42441:     mContext = nsnull;
42441:     return NS_OK;
42441:   }
42441: 
42441:   nsRefPtr<GLContext> mContext;
42441:   GLuint mTexture;
42441: };
42441: 
42441: void
42441: GLTexture::Allocate(GLContext *aContext)
42441: {
95097:   NS_ASSERTION(aContext->IsGlobalSharedContext() || aContext->IsOwningThreadCurrent(),
95097:                "Can only allocate texture on context's owning thread or with cx sharing");
42441: 
42441:   Release();
42441: 
42441:   mContext = aContext;
49072: 
49072:   mContext->MakeCurrent();
49072:   mContext->fGenTextures(1, &mTexture);
42441: }
42441: 
42441: void
42441: GLTexture::TakeFrom(GLTexture *aOther)
42441: {
42441:   Release();
42441: 
42441:   mContext = aOther->mContext.forget();
42441:   mTexture = aOther->mTexture;
42441:   aOther->mTexture = 0;
42441: }
42441: 
42441: void
42441: GLTexture::Release()
42441: {
42441:   if (!mContext) {
42441:     NS_ASSERTION(!mTexture, "Can't delete texture without a context");
42441:     return;
42441:   }
42441: 
74905:   if (mContext->IsDestroyed() && !mContext->IsGlobalSharedContext()) {
74905:     mContext = mContext->GetSharedContext();
74905:     if (!mContext) {
74905:       NS_ASSERTION(!mTexture, 
74905:                    "Context has been destroyed and couldn't find a shared context!");
74905:       return;
74905:     }
74905:   }
74905: 
42441:   if (mTexture) {
95097:     if (mContext->IsOwningThreadCurrent() || mContext->IsGlobalSharedContext()) {
49072:       mContext->MakeCurrent();
49072:       mContext->fDeleteTextures(1, &mTexture);
49072:     } else {
42441:       nsCOMPtr<nsIRunnable> runnable =
95097:         new TextureDeleter(mContext.get(), mTexture);
95097:       mContext->DispatchToOwningThread(runnable);
95097:       mContext.forget();
49072:     }
49072: 
42441:     mTexture = 0;
42441:   }
42441: 
49072:   mContext = nsnull;
49072: }
49072: 
89204: TextureRecycleBin::TextureRecycleBin()
89204:   : mLock("mozilla.layers.TextureRecycleBin.mLock")
42442: {
42442: }
42442: 
42442: void
89204: TextureRecycleBin::RecycleTexture(GLTexture *aTexture, TextureType aType,
42443:                            const gfxIntSize& aSize)
42443: {
55379:   MutexAutoLock lock(mLock);
55379: 
42443:   if (!aTexture->IsAllocated())
42443:     return;
42443: 
42443:   if (!mRecycledTextures[aType].IsEmpty() && aSize != mRecycledTextureSizes[aType]) {
42443:     mRecycledTextures[aType].Clear();
42443:   }
42443:   mRecycledTextureSizes[aType] = aSize;
42443:   mRecycledTextures[aType].AppendElement()->TakeFrom(aTexture);
42443: }
42443: 
42443: void
89204: TextureRecycleBin::GetTexture(TextureType aType, const gfxIntSize& aSize,
42443:                        GLContext *aContext, GLTexture *aOutTexture)
42443: {
42443:   MutexAutoLock lock(mLock);
42443: 
42443:   if (mRecycledTextures[aType].IsEmpty() || mRecycledTextureSizes[aType] != aSize) {
42443:     aOutTexture->Allocate(aContext);
42443:     return;
42443:   }
42443:   PRUint32 last = mRecycledTextures[aType].Length() - 1;
42443:   aOutTexture->TakeFrom(&mRecycledTextures[aType].ElementAt(last));
42443:   mRecycledTextures[aType].RemoveElementAt(last);
42443: }
42443: 
89204: struct THEBES_API MacIOSurfaceImageOGLBackendData : public ImageBackendData
40576: {
89204:   GLTexture mTexture;
89204: };
40576: 
89204: #ifdef XP_MACOSX
89204: void
89204: AllocateTextureIOSurface(MacIOSurfaceImage *aIOImage, mozilla::gl::GLContext* aGL)
49072: {
89204:   nsAutoPtr<MacIOSurfaceImageOGLBackendData> backendData(
89204:     new MacIOSurfaceImageOGLBackendData);
49072: 
89204:   backendData->mTexture.Allocate(aGL);
89204:   aGL->fBindTexture(LOCAL_GL_TEXTURE_RECTANGLE_ARB, backendData->mTexture.GetTextureID());
89204:   aGL->fTexParameteri(LOCAL_GL_TEXTURE_RECTANGLE_ARB,
89204:                      LOCAL_GL_TEXTURE_MIN_FILTER,
89204:                      LOCAL_GL_NEAREST);
89204:   aGL->fTexParameteri(LOCAL_GL_TEXTURE_RECTANGLE_ARB,
89204:                      LOCAL_GL_TEXTURE_MAG_FILTER,
89204:                      LOCAL_GL_NEAREST);
49072: 
89204:   void *nativeCtx = aGL->GetNativeData(GLContext::NativeGLContext);
89204: 
89358:   aIOImage->GetIOSurface()->CGLTexImageIOSurface2D(nativeCtx,
89204:                                      LOCAL_GL_RGBA, LOCAL_GL_BGRA,
89204:                                      LOCAL_GL_UNSIGNED_INT_8_8_8_8_REV, 0);
89204: 
89204:   aGL->fBindTexture(LOCAL_GL_TEXTURE_RECTANGLE_ARB, 0);
89204: 
89204:   aIOImage->SetBackendData(LayerManager::LAYERS_OPENGL, backendData.forget());
62472: }
62472: #endif
62472: 
39997: Layer*
39997: ImageLayerOGL::GetLayer()
39997: {
39997:   return this;
39997: }
39997: 
39997: void
42791: ImageLayerOGL::RenderLayer(int,
57097:                            const nsIntPoint& aOffset)
39997: {
91346:   nsRefPtr<ImageContainer> container = GetContainer();
91346: 
91346:   if (!container)
39997:     return;
39997: 
42791:   mOGLManager->MakeCurrent();
39997: 
91346:   AutoLockImage autoLock(container);
91346: 
91346:   Image *image = autoLock.GetImage();
60860:   if (!image) {
60860:     return;
60860:   }
39997: 
91346:   NS_ASSERTION(image->GetFormat() != Image::REMOTE_IMAGE_BITMAP,
91346:     "Remote images aren't handled yet in OGL layers!");
92162:   NS_ASSERTION(mScaleMode == SCALE_NONE,
92162:     "Scale modes other than none not handled yet in OGL layers!");
91346: 
39997:   if (image->GetFormat() == Image::PLANAR_YCBCR) {
89204:     PlanarYCbCrImage *yuvImage =
91346:       static_cast<PlanarYCbCrImage*>(image);
39997: 
89204:     if (!yuvImage->mBufferSize) {
39997:       return;
49072:     }
39997: 
89204:     PlanarYCbCrOGLBackendData *data =
89204:       static_cast<PlanarYCbCrOGLBackendData*>(yuvImage->GetBackendData(LayerManager::LAYERS_OPENGL));
39997: 
93768:     if (data && data->mTextures->GetGLContext() != gl()) {
93768:       // If these textures were allocated by another layer manager,
93768:       // clear them out and re-allocate below.
93768:       data = nsnull;
93768:       yuvImage->SetBackendData(LayerManager::LAYERS_OPENGL, nsnull);
93768:     }
93768: 
93768:     if (!data) {
93768:       AllocateTexturesYCbCr(yuvImage);
93768:       data = static_cast<PlanarYCbCrOGLBackendData*>(yuvImage->GetBackendData(LayerManager::LAYERS_OPENGL));
93768:     }
93768: 
93768:     if (!data || data->mTextures->GetGLContext() != gl()) {
89204:       // XXX - Can this ever happen? If so I need to fix this!
89204:       return;
89204:     }
89204: 
89204:     gl()->MakeCurrent();
97321:     gl()->fActiveTexture(LOCAL_GL_TEXTURE2);
97321:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, data->mTextures[2].GetTextureID());
79815:     gl()->ApplyFilterToBoundTexture(mFilter);
41370:     gl()->fActiveTexture(LOCAL_GL_TEXTURE1);
89204:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, data->mTextures[1].GetTextureID());
79815:     gl()->ApplyFilterToBoundTexture(mFilter);
97321:     gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
97321:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, data->mTextures[0].GetTextureID());
79815:     gl()->ApplyFilterToBoundTexture(mFilter);
39997:     
97446:     ShaderProgramOGL *program = mOGLManager->GetProgram(YCbCrLayerProgramType,
97446:                                                         GetMaskLayer());
42791: 
42791:     program->Activate();
42791:     program->SetLayerQuadRect(nsIntRect(0, 0,
42791:                                         yuvImage->mSize.width,
42791:                                         yuvImage->mSize.height));
57097:     program->SetLayerTransform(GetEffectiveTransform());
57097:     program->SetLayerOpacity(GetEffectiveOpacity());
42791:     program->SetRenderOffset(aOffset);
42791:     program->SetYCbCrTextureUnits(0, 1, 2);
97446:     program->LoadMask(GetMaskLayer());
39997: 
73014:     mOGLManager->BindAndDrawQuadWithTextureRect(program,
73014:                                                 yuvImage->mData.GetPictureRect(),
73014:                                                 nsIntSize(yuvImage->mData.mYSize.width,
73014:                                                           yuvImage->mData.mYSize.height));
42791: 
42791:     // We shouldn't need to do this, but do it anyway just in case
42791:     // someone else forgets.
41370:     gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
39997:   } else if (image->GetFormat() == Image::CAIRO_SURFACE) {
89204:     CairoImage *cairoImage =
91346:       static_cast<CairoImage*>(image);
39997: 
89204:     if (!cairoImage->mSurface) {
89204:       return;
89204:     }
89204: 
89204:     CairoOGLBackendData *data =
89204:       static_cast<CairoOGLBackendData*>(cairoImage->GetBackendData(LayerManager::LAYERS_OPENGL));
89204: 
93768:     if (data && data->mTexture.GetGLContext() != gl()) {
93768:       // If this texture was allocated by another layer manager, clear
93768:       // it out and re-allocate below.
93768:       data = nsnull;
93768:       cairoImage->SetBackendData(LayerManager::LAYERS_OPENGL, nsnull);
93768:     }
93768: 
93768:     if (!data) {
93768:       AllocateTexturesCairo(cairoImage);
93768:       data = static_cast<CairoOGLBackendData*>(cairoImage->GetBackendData(LayerManager::LAYERS_OPENGL));
93768:     }
93768: 
93768:     if (!data || data->mTexture.GetGLContext() != gl()) {
89204:       // XXX - Can this ever happen? If so I need to fix this!
89204:       return;
89204:     }
89204: 
70073:     gl()->MakeCurrent();
70073:     unsigned int iwidth  = cairoImage->mSize.width;
70073:     unsigned int iheight = cairoImage->mSize.height;
70073: 
42791:     gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
89204:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, data->mTexture.GetTextureID());
39997: 
67637: #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
67637:     GLXPixmap pixmap;
67637: 
67637:     if (cairoImage->mSurface) {
67637:         pixmap = sGLXLibrary.CreatePixmap(cairoImage->mSurface);
73893:         NS_ASSERTION(pixmap, "Failed to create pixmap!");
73893:         if (pixmap) {
67637:             sGLXLibrary.BindTexImage(pixmap);
67637:         }
73893:     }
67637: #endif
67637: 
97428:     ShaderProgramOGL *program = 
97446:       mOGLManager->GetProgram(data->mLayerProgram, GetMaskLayer());
39997: 
79815:     gl()->ApplyFilterToBoundTexture(mFilter);
54468: 
39997:     program->Activate();
70073:     // The following uniform controls the scaling of the vertex coords.
70073:     // Instead of setting the scale here and using coords in the range [0,1], we
70073:     // set an identity transform and use pixel coordinates below
70073:     program->SetLayerQuadRect(nsIntRect(0, 0, 1, 1));
57097:     program->SetLayerTransform(GetEffectiveTransform());
57097:     program->SetLayerOpacity(GetEffectiveOpacity());
42791:     program->SetRenderOffset(aOffset);
42791:     program->SetTextureUnit(0);
97446:     program->LoadMask(GetMaskLayer());
39997: 
70073:     nsIntRect rect = GetVisibleRegion().GetBounds();
67637: 
93424:     GLContext::RectTriangles triangleBuffer;
93420: 
93424:     float tex_offset_u = float(rect.x % iwidth) / iwidth;
93424:     float tex_offset_v = float(rect.y % iheight) / iheight;
70073:     triangleBuffer.addRect(rect.x, rect.y,
70073:                            rect.x + rect.width, rect.y + rect.height,
70073:                            tex_offset_u, tex_offset_v,
93424:                            tex_offset_u + float(rect.width) / float(iwidth),
93424:                            tex_offset_v + float(rect.height) / float(iheight));
70073: 
70073:     GLuint vertAttribIndex =
97428:         program->AttribLocation(ShaderProgramOGL::VertexCoordAttrib);
70073:     GLuint texCoordAttribIndex =
97428:         program->AttribLocation(ShaderProgramOGL::TexCoordAttrib);
70073:     NS_ASSERTION(texCoordAttribIndex != GLuint(-1), "no texture coords?");
70073: 
70073:     gl()->fBindBuffer(LOCAL_GL_ARRAY_BUFFER, 0);
70073:     gl()->fVertexAttribPointer(vertAttribIndex, 2,
70073:                                LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
70073:                                triangleBuffer.vertexPointer());
70073: 
70073:     gl()->fVertexAttribPointer(texCoordAttribIndex, 2,
70073:                                LOCAL_GL_FLOAT, LOCAL_GL_FALSE, 0,
70073:                                triangleBuffer.texCoordPointer());
70073:     {
70073:         gl()->fEnableVertexAttribArray(texCoordAttribIndex);
70073:         {
70073:             gl()->fEnableVertexAttribArray(vertAttribIndex);
70073:             gl()->fDrawArrays(LOCAL_GL_TRIANGLES, 0, triangleBuffer.elements());
70073:             gl()->fDisableVertexAttribArray(vertAttribIndex);
70073:         }
70073:         gl()->fDisableVertexAttribArray(texCoordAttribIndex);
70073:     }
67637: #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
73893:     if (cairoImage->mSurface && pixmap) {
67637:         sGLXLibrary.ReleaseTexImage(pixmap);
67637:         sGLXLibrary.DestroyPixmap(pixmap);
67637:     }
67637: #endif
62472: #ifdef XP_MACOSX
62472:   } else if (image->GetFormat() == Image::MAC_IO_SURFACE) {
89204:      MacIOSurfaceImage *ioImage =
91346:        static_cast<MacIOSurfaceImage*>(image);
62472: 
62724:      if (!mOGLManager->GetThebesLayerCallback()) {
62724:        // If its an empty transaction we still need to update
62724:        // the plugin IO Surface and make sure we grab the
62724:        // new image
62724:        ioImage->Update(GetContainer());
91346:        image = nsnull;
91346:        autoLock.Refresh();
91346:        image = autoLock.GetImage();
62724:        gl()->MakeCurrent();
91346:        ioImage = static_cast<MacIOSurfaceImage*>(image);
62724:      }
62724: 
72998:      if (!ioImage) {
72998:        return;
72998:      }
72998: 
63188:      gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
89204: 
89204:      if (!ioImage->GetBackendData(LayerManager::LAYERS_OPENGL)) {
89204:        AllocateTextureIOSurface(ioImage, gl());
89204:      }
89204: 
89204:      MacIOSurfaceImageOGLBackendData *data =
89204:       static_cast<MacIOSurfaceImageOGLBackendData*>(ioImage->GetBackendData(LayerManager::LAYERS_OPENGL));
89204: 
89204:      gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
89204:      gl()->fBindTexture(LOCAL_GL_TEXTURE_RECTANGLE_ARB, data->mTexture.GetTextureID());
62472: 
97446:      ShaderProgramOGL *program =
97446:        mOGLManager->GetProgram(gl::RGBARectLayerProgramType, GetMaskLayer());
62472:      
62472:      program->Activate();
62472:      if (program->GetTexCoordMultiplierUniformLocation() != -1) {
62472:        // 2DRect case, get the multiplier right for a sampler2DRect
97428:        program->SetTexCoordMultiplier(ioImage->GetSize().width, ioImage->GetSize().height);
62472:      } else {
62472:        NS_ASSERTION(0, "no rects?");
62472:      }
62472:      
62472:      program->SetLayerQuadRect(nsIntRect(0, 0, 
89204:                                          ioImage->GetSize().width, 
89204:                                          ioImage->GetSize().height));
62472:      program->SetLayerTransform(GetEffectiveTransform());
62472:      program->SetLayerOpacity(GetEffectiveOpacity());
62472:      program->SetRenderOffset(aOffset);
62472:      program->SetTextureUnit(0);
97446:      program->LoadMask(GetMaskLayer());
62472:     
62472:      mOGLManager->BindAndDrawQuad(program);
62472:      gl()->fBindTexture(LOCAL_GL_TEXTURE_RECTANGLE_ARB, 0);
62472: #endif
42791:   }
63615:   GetContainer()->NotifyPaintedImage(image);
39997: }
39997: 
49072: static void
93806: SetClamping(GLContext* aGL, GLuint aTexture)
49072: {
49072:   aGL->fBindTexture(LOCAL_GL_TEXTURE_2D, aTexture);
49072:   aGL->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S, LOCAL_GL_CLAMP_TO_EDGE);
49072:   aGL->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T, LOCAL_GL_CLAMP_TO_EDGE);
49072: }
49072: 
69765: static void
69765: UploadYUVToTexture(GLContext* gl, const PlanarYCbCrImage::Data& aData, 
69765:                    GLTexture* aYTexture,
69765:                    GLTexture* aUTexture,
69765:                    GLTexture* aVTexture)
39997: {
73014:   nsIntRect size(0, 0, aData.mYSize.width, aData.mYSize.height);
73014:   GLuint texture = aYTexture->GetTextureID();
73014:   nsRefPtr<gfxASurface> surf = new gfxImageSurface(aData.mYChannel,
73014:                                                    aData.mYSize,
73014:                                                    aData.mYStride,
73014:                                                    gfxASurface::ImageFormatA8);
88504:   gl->UploadSurfaceToTexture(surf, size, texture, true);
40117:   
73014:   size = nsIntRect(0, 0, aData.mCbCrSize.width, aData.mCbCrSize.height);
73014:   texture = aUTexture->GetTextureID();
73014:   surf = new gfxImageSurface(aData.mCbChannel,
73014:                              aData.mCbCrSize,
73014:                              aData.mCbCrStride,
73014:                              gfxASurface::ImageFormatA8);
88504:   gl->UploadSurfaceToTexture(surf, size, texture, true);
40117: 
73014:   texture = aVTexture->GetTextureID();
73014:   surf = new gfxImageSurface(aData.mCrChannel,
73014:                              aData.mCbCrSize,
73014:                              aData.mCbCrStride,
73014:                              gfxASurface::ImageFormatA8);
88504:   gl->UploadSurfaceToTexture(surf, size, texture, true);
39997: }
39997: 
89204: ImageLayerOGL::ImageLayerOGL(LayerManagerOGL *aManager)
89204:   : ImageLayer(aManager, NULL)
89204:   , LayerOGL(aManager)
89204:   , mTextureRecycleBin(new TextureRecycleBin())
69765: { 
89204:   mImplData = static_cast<LayerOGL*>(this);
39997: }
39997: 
39997: void
89204: ImageLayerOGL::AllocateTexturesYCbCr(PlanarYCbCrImage *aImage)
39997: {
89204:   if (!aImage->mBufferSize)
42441:     return;
42441: 
89204:   nsAutoPtr<PlanarYCbCrOGLBackendData> backendData(
89204:     new PlanarYCbCrOGLBackendData);
89204: 
89204:   PlanarYCbCrImage::Data &data = aImage->mData;
89204: 
93768:   gl()->MakeCurrent();
89204:  
93768:   mTextureRecycleBin->GetTexture(TextureRecycleBin::TEXTURE_Y, data.mYSize, gl(), &backendData->mTextures[0]);
93806:   SetClamping(gl(), backendData->mTextures[0].GetTextureID());
42441: 
93768:   mTextureRecycleBin->GetTexture(TextureRecycleBin::TEXTURE_C, data.mCbCrSize, gl(), &backendData->mTextures[1]);
93806:   SetClamping(gl(), backendData->mTextures[1].GetTextureID());
89204: 
93768:   mTextureRecycleBin->GetTexture(TextureRecycleBin::TEXTURE_C, data.mCbCrSize, gl(), &backendData->mTextures[2]);
93806:   SetClamping(gl(), backendData->mTextures[2].GetTextureID());
89204: 
93768:   UploadYUVToTexture(gl(), aImage->mData,
89204:                      &backendData->mTextures[0],
89204:                      &backendData->mTextures[1],
89204:                      &backendData->mTextures[2]);
89204: 
89204:   backendData->mYSize = aImage->mData.mYSize;
89204:   backendData->mCbCrSize = aImage->mData.mCbCrSize;
89204:   backendData->mTextureRecycleBin = mTextureRecycleBin;
89204: 
89204:   aImage->SetBackendData(LayerManager::LAYERS_OPENGL, backendData.forget());
89204: }
89204: 
89204: void
89204: ImageLayerOGL::AllocateTexturesCairo(CairoImage *aImage)
89204: {
89204:   nsAutoPtr<CairoOGLBackendData> backendData(
89204:     new CairoOGLBackendData);
89204: 
89204:   GLTexture &texture = backendData->mTexture;
89204: 
93768:   texture.Allocate(gl());
89204: 
89204:   if (!texture.IsAllocated()) {
89204:     return;
89204:   }
89204: 
89204:   mozilla::gl::GLContext *gl = texture.GetGLContext();
89204:   gl->MakeCurrent();
89204: 
89204:   GLuint tex = texture.GetTextureID();
67637:   gl->fActiveTexture(LOCAL_GL_TEXTURE0);
59437: 
93807:   SetClamping(gl, tex);
93807: 
67637: #if defined(MOZ_WIDGET_GTK2) && !defined(MOZ_PLATFORM_MAEMO)
89204:   if (sGLXLibrary.SupportsTextureFromPixmap(aImage->mSurface)) {
89204:     if (aImage->mSurface->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA) {
89204:       backendData->mLayerProgram = gl::RGBALayerProgramType;
67637:     } else {
89204:       backendData->mLayerProgram = gl::RGBXLayerProgramType;
67637:     }
89204: 
89204:     aImage->SetBackendData(LayerManager::LAYERS_OPENGL, backendData.forget());
67637:     return;
67637:   }
67637: #endif
89204:   backendData->mLayerProgram =
89204:     gl->UploadSurfaceToTexture(aImage->mSurface,
89204:                                nsIntRect(0,0, aImage->mSize.width, aImage->mSize.height),
89204:                                tex, true);
67637: 
89204:   aImage->SetBackendData(LayerManager::LAYERS_OPENGL, backendData.forget());
39997: }
39997: 
97445: /*
97445:  * Returns a size that is larger than and closest to aSize where both
97445:  * width and height are powers of two.
97445:  * If the OpenGL setup is capable of using non-POT textures, then it
97445:  * will just return aSize.
97445:  */
97445: gfxIntSize CalculatePOTSize(const gfxIntSize& aSize, GLContext* gl)
97445: {
97445:   if (gl->CanUploadNonPowerOfTwo())
97445:     return aSize;
97445: 
97445:   return gfxIntSize(NextPowerOfTwo(aSize.width), NextPowerOfTwo(aSize.height));
97445: }
97445: 
97445: bool
97445: ImageLayerOGL::LoadAsTexture(GLuint aTextureUnit, gfxIntSize* aSize)
97445: {
97445:   // this method shares a lot of code with RenderLayer, but it doesn't seem
97445:   // to be possible to factor it out into a helper method
97445: 
97445:   if (!GetContainer()) {
97445:     return false;
97445:   }
97445: 
97445:   AutoLockImage autoLock(GetContainer());
97445: 
97445:   Image *image = autoLock.GetImage();
97445:   if (!image) {
97445:     return false;
97445:   }
97445: 
97445:   if (image->GetFormat() != Image::CAIRO_SURFACE) {
97445:     return false;
97445:   }
97445: 
97445:   CairoImage* cairoImage = static_cast<CairoImage*>(image);
97445: 
97445:   if (!cairoImage->mSurface) {
97445:     return false;
97445:   }
97445: 
97445:   CairoOGLBackendData *data = static_cast<CairoOGLBackendData*>(
97445:     cairoImage->GetBackendData(LayerManager::LAYERS_OPENGL));
97445: 
97445:   if (!data) {
97445:     // allocate a new texture and save the details in the backend data
97445:     data = new CairoOGLBackendData;
97445:     data->mTextureSize = CalculatePOTSize(cairoImage->mSize, gl());
97445: 
97445:     GLTexture &texture = data->mTexture;
97445:     texture.Allocate(mOGLManager->gl());
97445: 
97445:     if (!texture.IsAllocated()) {
97445:       return false;
97445:     }
97445: 
97445:     mozilla::gl::GLContext *texGL = texture.GetGLContext();
97445:     texGL->MakeCurrent();
97445: 
97445:     GLuint texID = texture.GetTextureID();
97445: 
97445:     data->mLayerProgram =
97445:       texGL->UploadSurfaceToTexture(cairoImage->mSurface,
97445:                                     nsIntRect(0,0,
97445:                                               data->mTextureSize.width,
97445:                                               data->mTextureSize.height),
97445:                                     texID, true, nsIntPoint(0,0), false,
97445:                                     aTextureUnit);
97445: 
97445:     cairoImage->SetBackendData(LayerManager::LAYERS_OPENGL, data);
97445: 
97445:     gl()->MakeCurrent();
97445:     gl()->fActiveTexture(aTextureUnit);
97445:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, texID);
97445:     gl()->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MIN_FILTER,
97445:                          LOCAL_GL_LINEAR);
97445:     gl()->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_MAG_FILTER,
97445:                          LOCAL_GL_LINEAR);
97445:     gl()->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_S,
97445:                          LOCAL_GL_CLAMP_TO_EDGE);
97445:     gl()->fTexParameteri(LOCAL_GL_TEXTURE_2D, LOCAL_GL_TEXTURE_WRAP_T,
97445:                          LOCAL_GL_CLAMP_TO_EDGE);
97445:   } else {
97445:     gl()->fActiveTexture(aTextureUnit);
97445:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, data->mTexture.GetTextureID());
97445:   }
97445: 
97445:   *aSize = data->mTextureSize;
97445:   return true;
97445: }
97445: 
55454: ShadowImageLayerOGL::ShadowImageLayerOGL(LayerManagerOGL* aManager)
55454:   : ShadowImageLayer(aManager, nsnull)
55454:   , LayerOGL(aManager)
55454: {
55454:   mImplData = static_cast<LayerOGL*>(this);
55454: }
55454: 
55454: ShadowImageLayerOGL::~ShadowImageLayerOGL()
55454: {}
55454: 
79445: bool
79425: ShadowImageLayerOGL::Init(const SharedImage& aFront)
55454: {
69765:   if (aFront.type() == SharedImage::TSurfaceDescriptor) {
69765:     SurfaceDescriptor desc = aFront.get_SurfaceDescriptor();
69764:     nsRefPtr<gfxASurface> surf =
69765:       ShadowLayerForwarder::OpenDescriptor(desc);
79425:     mSize = surf->GetSize();
79425:     mTexImage = gl()->CreateTextureImage(nsIntSize(mSize.width, mSize.height),
69106:                                          surf->GetContentType(),
55454:                                          LOCAL_GL_CLAMP_TO_EDGE);
80486:     return true;
69765:   } else {
69765:     YUVImage yuv = aFront.get_YUVImage();
69765: 
69765:     nsRefPtr<gfxSharedImageSurface> surfY =
69765:       gfxSharedImageSurface::Open(yuv.Ydata());
69765:     nsRefPtr<gfxSharedImageSurface> surfU =
69765:       gfxSharedImageSurface::Open(yuv.Udata());
69765:     nsRefPtr<gfxSharedImageSurface> surfV =
69765:       gfxSharedImageSurface::Open(yuv.Vdata());
69765: 
79425:     mSize = surfY->GetSize();
79425:     mCbCrSize = surfU->GetSize();
69765: 
69765:     if (!mYUVTexture[0].IsAllocated()) {
93768:       mYUVTexture[0].Allocate(gl());
93768:       mYUVTexture[1].Allocate(gl());
93768:       mYUVTexture[2].Allocate(gl());
69765:     }
69765: 
69765:     NS_ASSERTION(mYUVTexture[0].IsAllocated() &&
69765:                  mYUVTexture[1].IsAllocated() &&
69765:                  mYUVTexture[2].IsAllocated(),
69765:                  "Texture allocation failed!");
69765: 
69765:     gl()->MakeCurrent();
93806:     SetClamping(gl(), mYUVTexture[0].GetTextureID());
93806:     SetClamping(gl(), mYUVTexture[1].GetTextureID());
93806:     SetClamping(gl(), mYUVTexture[2].GetTextureID());
80486:     return true;
69765:   }
80486:   return false;
55454: }
55454: 
69106: void
79425: ShadowImageLayerOGL::Swap(const SharedImage& aNewFront,
79425:                           SharedImage* aNewBack)
55454: {
69765:   if (!mDestroyed) {
69765:     if (aNewFront.type() == SharedImage::TSurfaceDescriptor) {
69764:       nsRefPtr<gfxASurface> surf =
69764:         ShadowLayerForwarder::OpenDescriptor(aNewFront.get_SurfaceDescriptor());
79425:       gfxIntSize size = surf->GetSize();
80708:       if (mSize != size || !mTexImage ||
80708:           mTexImage->GetContentType() != surf->GetContentType()) {
79425:         Init(aNewFront);
79425:       }
55454:       // XXX this is always just ridiculously slow
79425:       nsIntRegion updateRegion(nsIntRect(0, 0, size.width, size.height));
69106:       mTexImage->DirectUpdate(surf, updateRegion);
69765:     } else {
69765:       const YUVImage& yuv = aNewFront.get_YUVImage();
69765: 
69765:       nsRefPtr<gfxSharedImageSurface> surfY =
69765:         gfxSharedImageSurface::Open(yuv.Ydata());
69765:       nsRefPtr<gfxSharedImageSurface> surfU =
69765:         gfxSharedImageSurface::Open(yuv.Udata());
69765:       nsRefPtr<gfxSharedImageSurface> surfV =
69765:         gfxSharedImageSurface::Open(yuv.Vdata());
79425:       mPictureRect = yuv.picture();
69765: 
79425:       gfxIntSize size = surfY->GetSize();
79425:       gfxIntSize CbCrSize = surfU->GetSize();
79425:       if (size != mSize || mCbCrSize != CbCrSize || !mYUVTexture[0].IsAllocated()) {
79425:         Init(aNewFront);
79425:       }
73014: 
69765:       PlanarYCbCrImage::Data data;
69765:       data.mYChannel = surfY->Data();
69765:       data.mYStride = surfY->Stride();
69765:       data.mYSize = surfY->GetSize();
69765:       data.mCbChannel = surfU->Data();
69765:       data.mCrChannel = surfV->Data();
69765:       data.mCbCrStride = surfU->Stride();
69765:       data.mCbCrSize = surfU->GetSize();
69765: 
69765:       UploadYUVToTexture(gl(), data, &mYUVTexture[0], &mYUVTexture[1], &mYUVTexture[2]);
69765:     }
55454:   }
55454: 
69106:   *aNewBack = aNewFront;
55454: }
55454: 
55454: void
60065: ShadowImageLayerOGL::Disconnect()
60065: {
60065:   Destroy();
60065: }
60065: 
60065: void
55454: ShadowImageLayerOGL::Destroy()
55454: {
55454:   if (!mDestroyed) {
80486:     mDestroyed = true;
87402:     CleanupResources();
55454:   }
55454: }
55454: 
55454: Layer*
55454: ShadowImageLayerOGL::GetLayer()
55454: {
55454:   return this;
55454: }
55454: 
55454: void
55454: ShadowImageLayerOGL::RenderLayer(int aPreviousFrameBuffer,
57097:                                  const nsIntPoint& aOffset)
55454: {
55454:   mOGLManager->MakeCurrent();
55454: 
69765:   if (mTexImage) {
97428:     ShaderProgramOGL *colorProgram =
97448:       mOGLManager->GetProgram(mTexImage->GetShaderProgramType(), GetMaskLayer());
55454: 
69765:     colorProgram->Activate();
69765:     colorProgram->SetTextureUnit(0);
73948:     colorProgram->SetLayerTransform(GetEffectiveTransform());
73948:     colorProgram->SetLayerOpacity(GetEffectiveOpacity());
73948:     colorProgram->SetRenderOffset(aOffset);
97448:     colorProgram->LoadMask(GetMaskLayer());
73465: 
79815:     mTexImage->SetFilter(mFilter);
73465:     mTexImage->BeginTileIteration();
92920: 
92920:     if (gl()->CanUploadNonPowerOfTwo()) {
73465:       do {
79815:         TextureImage::ScopedBindTextureAndApplyFilter texBind(mTexImage, LOCAL_GL_TEXTURE0);
73465:         colorProgram->SetLayerQuadRect(mTexImage->GetTileRect());
73465:         mOGLManager->BindAndDrawQuad(colorProgram);
73465:       } while (mTexImage->NextTile());
69765:     } else {
92920:       do {
92920:         TextureImage::ScopedBindTextureAndApplyFilter texBind(mTexImage, LOCAL_GL_TEXTURE0);
92920:         colorProgram->SetLayerQuadRect(mTexImage->GetTileRect());
92920:         // We can't use BindAndDrawQuad because that always uploads the whole texture from 0.0f -> 1.0f
92920:         // in x and y. We use BindAndDrawQuadWithTextureRect to actually draw a subrect of the texture
92920:         mOGLManager->BindAndDrawQuadWithTextureRect(colorProgram,
92920:                                                     nsIntRect(0, 0, mTexImage->GetTileRect().width,
92920:                                                                     mTexImage->GetTileRect().height),
92920:                                                     mTexImage->GetTileRect().Size());
92920:       } while (mTexImage->NextTile());
92920:     }
92920: 
92920:   } else {
69765:     gl()->fActiveTexture(LOCAL_GL_TEXTURE0);
69765:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, mYUVTexture[0].GetTextureID());
79815:     gl()->ApplyFilterToBoundTexture(mFilter);
69765:     gl()->fActiveTexture(LOCAL_GL_TEXTURE1);
69765:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, mYUVTexture[1].GetTextureID());
79815:     gl()->ApplyFilterToBoundTexture(mFilter);
69765:     gl()->fActiveTexture(LOCAL_GL_TEXTURE2);
69765:     gl()->fBindTexture(LOCAL_GL_TEXTURE_2D, mYUVTexture[2].GetTextureID());
79815:     gl()->ApplyFilterToBoundTexture(mFilter);
69765: 
97448:     ShaderProgramOGL *yuvProgram = mOGLManager->GetProgram(YCbCrLayerProgramType, GetMaskLayer());
69765: 
69765:     yuvProgram->Activate();
69765:     yuvProgram->SetLayerQuadRect(nsIntRect(0, 0,
73014:                                            mPictureRect.width,
73014:                                            mPictureRect.height));
69765:     yuvProgram->SetYCbCrTextureUnits(0, 1, 2);
73465:     yuvProgram->SetLayerTransform(GetEffectiveTransform());
73465:     yuvProgram->SetLayerOpacity(GetEffectiveOpacity());
73465:     yuvProgram->SetRenderOffset(aOffset);
97448:     yuvProgram->LoadMask(GetMaskLayer());
69765: 
73465:     mOGLManager->BindAndDrawQuadWithTextureRect(yuvProgram,
73014:                                                 mPictureRect,
73014:                                                 nsIntSize(mSize.width, mSize.height));
69765:  }
55454: }
55454: 
97448: bool
97448: ShadowImageLayerOGL::LoadAsTexture(GLuint aTextureUnit, gfxIntSize* aSize)
97448: {
97448:   if (!mTexImage) {
97448:     return false;
97448:   }
97448: 
97448:   mTexImage->BindTextureAndApplyFilter(aTextureUnit);
97448: 
97448:   *aSize = mTexImage->GetSize();
97448:   return true;
97448: }
97448: 
87402: void
87402: ShadowImageLayerOGL::CleanupResources()
87402: {
98560:   mYUVTexture[0].Release();
98560:   mYUVTexture[1].Release();
98560:   mYUVTexture[2].Release();
87402:   mTexImage = nsnull;
87402: }
55454: 
39997: } /* layers */
39997: } /* mozilla */
