    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* vim:set expandtab ts=4 sw=4 sts=4 cin: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Darin Fisher <darin@meer.net> (original author)
    1:  *   Christian Biesinger <cbiesinger@web.de>
    1:  *   Google Inc.
18377:  *   Jan Wrobel <wrobel@blues.ath.cx>
18377:  *   Jan Odvarko <odvarko@gmail.com>
19925:  *   Dave Camp <dcamp@mozilla.com>
19925:  *   Honza Bambas <honzab@firemni.cz>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsHttpChannel.h"
    1: #include "nsHttpTransaction.h"
    1: #include "nsHttpConnection.h"
    1: #include "nsHttpHandler.h"
    1: #include "nsHttpAuthCache.h"
    1: #include "nsHttpResponseHead.h"
    1: #include "nsHttp.h"
    1: #include "nsIHttpAuthenticator.h"
18430: #include "nsIApplicationCacheService.h"
21311: #include "nsIApplicationCacheContainer.h"
    1: #include "nsIAuthInformation.h"
    1: #include "nsIAuthPrompt2.h"
    1: #include "nsIAuthPromptProvider.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsIURL.h"
    1: #include "nsIIDNService.h"
    1: #include "nsIStreamListenerTee.h"
    1: #include "nsISeekableStream.h"
    1: #include "nsMimeTypes.h"
    1: #include "nsNetUtil.h"
    1: #include "nsString.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsAutoPtr.h"
    1: #include "plstr.h"
    1: #include "prprf.h"
    1: #include "nsEscape.h"
    1: #include "nsICookieService.h"
    1: #include "nsIResumableChannel.h"
    1: #include "nsInt64.h"
    1: #include "nsIVariant.h"
    1: #include "nsChannelProperties.h"
    1: #include "nsStreamUtils.h"
    1: #include "nsIOService.h"
    1: #include "nsAuthInformationHolder.h"
 3947: #include "nsICacheService.h"
21577: #include "nsDNSPrefetch.h"
30469: #include "nsNetSegmentUtils.h"
    1: 
    1: // True if the local cache should be bypassed when processing a request.
    1: #define BYPASS_LOCAL_CACHE(loadFlags) \
    1:         (loadFlags & (nsIRequest::LOAD_BYPASS_CACHE | \
    1:                       nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE))
    1: 
    1: static NS_DEFINE_CID(kStreamListenerTeeCID, NS_STREAMLISTENERTEE_CID);
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel <public>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsHttpChannel::nsHttpChannel()
    1:     : mResponseHead(nsnull)
    1:     , mTransaction(nsnull)
    1:     , mConnectionInfo(nsnull)
    1:     , mLoadFlags(LOAD_NORMAL)
    1:     , mStatus(NS_OK)
    1:     , mLogicalOffset(0)
    1:     , mCaps(0)
    1:     , mPriority(PRIORITY_NORMAL)
    1:     , mCachedResponseHead(nsnull)
    1:     , mCacheAccess(0)
    1:     , mPostID(0)
    1:     , mRequestTime(0)
    1:     , mProxyAuthContinuationState(nsnull)
    1:     , mAuthContinuationState(nsnull)
    1:     , mStartPos(LL_MAXUINT)
 5208:     , mPendingAsyncCallOnResume(nsnull)
 5208:     , mSuspendCount(0)
    1:     , mRedirectionLimit(gHttpHandler->RedirectionLimit())
    1:     , mIsPending(PR_FALSE)
   51:     , mWasOpened(PR_FALSE)
    1:     , mApplyConversion(PR_TRUE)
    1:     , mAllowPipelining(PR_TRUE)
    1:     , mCachedContentIsValid(PR_FALSE)
    1:     , mCachedContentIsPartial(PR_FALSE)
    1:     , mResponseHeadersModified(PR_FALSE)
    1:     , mCanceled(PR_FALSE)
    1:     , mTransactionReplaced(PR_FALSE)
    1:     , mUploadStreamHasHeaders(PR_FALSE)
    1:     , mAuthRetryPending(PR_FALSE)
30469:     , mProxyAuth(PR_FALSE)
    1:     , mSuppressDefensiveAuth(PR_FALSE)
    1:     , mResuming(PR_FALSE)
    1:     , mInitedCacheEntry(PR_FALSE)
    1:     , mCacheForOfflineUse(PR_FALSE)
19925:     , mCachingOpportunistically(PR_FALSE)
19925:     , mFallbackChannel(PR_FALSE)
21311:     , mInheritApplicationCache(PR_TRUE)
21311:     , mChooseApplicationCache(PR_FALSE)
21367:     , mLoadedFromApplicationCache(PR_FALSE)
18377:     , mTracingEnabled(PR_TRUE)
29288:     , mForceAllowThirdPartyCookie(PR_FALSE)
34058:     , mCustomConditionalRequest(PR_FALSE)
    1: {
    1:     LOG(("Creating nsHttpChannel @%x\n", this));
    1: 
    1:     // grab a reference to the handler to ensure that it doesn't go away.
    1:     nsHttpHandler *handler = gHttpHandler;
    1:     NS_ADDREF(handler);
    1: }
    1: 
    1: nsHttpChannel::~nsHttpChannel()
    1: {
    1:     LOG(("Destroying nsHttpChannel @%x\n", this));
    1: 
    1:     NS_IF_RELEASE(mConnectionInfo);
    1:     NS_IF_RELEASE(mTransaction);
    1: 
    1:     NS_IF_RELEASE(mProxyAuthContinuationState);
    1:     NS_IF_RELEASE(mAuthContinuationState);
    1: 
    1:     delete mResponseHead;
    1:     delete mCachedResponseHead;
    1: 
    1:     // release our reference to the handler
    1:     nsHttpHandler *handler = gHttpHandler;
    1:     NS_RELEASE(handler);
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::Init(nsIURI *uri,
    1:                     PRUint8 caps,
    1:                     nsProxyInfo *proxyInfo)
    1: {
    1:     LOG(("nsHttpChannel::Init [this=%x]\n", this));
    1: 
    1:     NS_PRECONDITION(uri, "null uri");
    1: 
    1:     nsresult rv = nsHashPropertyBag::Init();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     mURI = uri;
    1:     mOriginalURI = uri;
    1:     mDocumentURI = nsnull;
    1:     mCaps = caps;
    1: 
    1:     //
    1:     // Construct connection info object
    1:     //
    1:     nsCAutoString host;
    1:     PRInt32 port = -1;
    1:     PRBool usingSSL = PR_FALSE;
    1:     
    1:     rv = mURI->SchemeIs("https", &usingSSL);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = mURI->GetAsciiHost(host);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // reject the URL if it doesn't specify a host
    1:     if (host.IsEmpty())
    1:         return NS_ERROR_MALFORMED_URI;
    1: 
    1:     rv = mURI->GetPort(&port);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     LOG(("host=%s port=%d\n", host.get(), port));
    1: 
    1:     rv = mURI->GetAsciiSpec(mSpec);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     LOG(("uri=%s\n", mSpec.get()));
    1: 
    1:     mConnectionInfo = new nsHttpConnectionInfo(host, port,
    1:                                                proxyInfo, usingSSL);
    1:     if (!mConnectionInfo)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(mConnectionInfo);
    1: 
    1:     // Set default request method
    1:     mRequestHead.SetMethod(nsHttp::Get);
    1: 
    1:     //
    1:     // Set request headers
    1:     //
    1:     nsCAutoString hostLine;
    1:     if (strchr(host.get(), ':')) {
    1:         // host is an IPv6 address literal and must be encapsulated in []'s
    1:         hostLine.Assign('[');
22421:         // scope id is not needed for Host header.
22421:         int scopeIdPos = host.FindChar('%');
22421:         if (scopeIdPos == kNotFound)
    1:             hostLine.Append(host);
22421:         else if (scopeIdPos > 0)
22421:             hostLine.Append(Substring(host, 0, scopeIdPos));
22421:         else
22421:           return NS_ERROR_MALFORMED_URI;
    1:         hostLine.Append(']');
    1:     }
    1:     else
    1:         hostLine.Assign(host);
    1:     if (port != -1) {
    1:         hostLine.Append(':');
    1:         hostLine.AppendInt(port);
    1:     }
    1: 
    1:     rv = mRequestHead.SetHeader(nsHttp::Host, hostLine);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = gHttpHandler->
    1:         AddStandardRequestHeaders(&mRequestHead.Headers(), caps,
    1:                                   !mConnectionInfo->UsingSSL() &&
    1:                                   mConnectionInfo->UsingHttpProxy());
    1: 
    1:     return rv;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel <private>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsresult
24936: nsHttpChannel::AsyncCall(nsAsyncCallback funcPtr,
24936:                          nsRunnableMethod<nsHttpChannel> **retval)
    1: {
24936:     nsresult rv;
24936: 
24936:     nsRefPtr<nsRunnableMethod<nsHttpChannel> > event =
    1:             new nsRunnableMethod<nsHttpChannel>(this, funcPtr);
24936:     rv = NS_DispatchToCurrentThread(event);
24936:     if (NS_SUCCEEDED(rv) && retval) {
24936:         *retval = event;
24936:     }
24936: 
24936:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::Connect(PRBool firstTime)
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("nsHttpChannel::Connect [this=%x]\n", this));
    1: 
    1:     // ensure that we are using a valid hostname
    1:     if (!net_IsValidHostName(nsDependentCString(mConnectionInfo->Host())))
    1:         return NS_ERROR_UNKNOWN_HOST;
    1: 
    1:     // true when called from AsyncOpen
    1:     if (firstTime) {
    1:         PRBool delayed = PR_FALSE;
    1: 
    1:         // are we offline?
    1:         PRBool offline = gIOService->IsOffline();
    1:         if (offline)
18430:             mLoadFlags |= LOAD_ONLY_FROM_CACHE;
    1:         else if (PL_strcmp(mConnectionInfo->ProxyType(), "unknown") == 0)
    1:             return ResolveProxy();  // Lazily resolve proxy info
    1: 
    1:         // Don't allow resuming when cache must be used
    1:         if (mResuming && (mLoadFlags & LOAD_ONLY_FROM_CACHE)) {
    1:             LOG(("Resuming from cache is not supported yet"));
    1:             return NS_ERROR_DOCUMENT_NOT_CACHED;
    1:         }
    1: 
    1:         // open a cache entry for this channel...
    1:         rv = OpenCacheEntry(offline, &delayed);
    1: 
    1:         if (NS_FAILED(rv)) {
    1:             LOG(("OpenCacheEntry failed [rv=%x]\n", rv));
    1:             // if this channel is only allowed to pull from the cache, then
    1:             // we must fail if we were unable to open a cache entry.
19925:             if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
19925:                 // If we have a fallback URI (and we're not already
19925:                 // falling back), process the fallback asynchronously.
19925:                 if (!mFallbackChannel && !mFallbackKey.IsEmpty()) {
19925:                     return AsyncCall(&nsHttpChannel::HandleAsyncFallback);
19925:                 }
19930:                 return NS_ERROR_DOCUMENT_NOT_CACHED;
19925:             }
    1:             // otherwise, let's just proceed without using the cache.
    1:         }
    1: 
    1:         // if cacheForOfflineUse has been set, open up an offline cache
    1:         // entry to update
    1:         if (mCacheForOfflineUse) {
    1:             rv = OpenOfflineCacheEntryForWriting();
    1:             if (NS_FAILED(rv)) return rv;
    1:         }
    1: 
    1:         if (NS_SUCCEEDED(rv) && delayed)
    1:             return NS_OK;
    1:     }
    1: 
    1:     // we may or may not have a cache entry at this point
    1:     if (mCacheEntry) {
    1:         // inspect the cache entry to determine whether or not we need to go
    1:         // out to net to validate it.  this call sets mCachedContentIsValid
    1:         // and may set request headers as required for cache validation.
    1:         rv = CheckCache();
    1:         if (NS_FAILED(rv))
    1:             NS_WARNING("cache check failed");
    1: 
    1:         // read straight from the cache if possible...
    1:         if (mCachedContentIsValid) {
24936:             nsRunnableMethod<nsHttpChannel> *event = nsnull;
24936:             if (!mCachedContentIsPartial) {
24936:                 AsyncCall(&nsHttpChannel::AsyncOnExamineCachedResponse, &event);
24936:             }
24936:             rv = ReadFromCache();
24936:             if (NS_FAILED(rv) && event) {
24936:                 event->Revoke();
24936:             }
24936:             return rv;
    1:         }
    1:         else if (mLoadFlags & LOAD_ONLY_FROM_CACHE) {
    1:             // the cache contains the requested resource, but it must be 
    1:             // validated before we can reuse it.  since we are not allowed
    1:             // to hit the net, there's nothing more to do.  the document
    1:             // is effectively not in the cache.
    1:             return NS_ERROR_DOCUMENT_NOT_CACHED;
    1:         }
    1:     }
    1: 
    1:     // check to see if authorization headers should be included
    1:     AddAuthorizationHeaders();
    1: 
 3239:     if (mLoadFlags & LOAD_NO_NETWORK_IO) {
 4063:         return NS_ERROR_DOCUMENT_NOT_CACHED;
 3239:     }
 3239: 
    1:     // hit the net...
    1:     rv = SetupTransaction();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = gHttpHandler->InitiateTransaction(mTransaction, mPriority);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return mTransactionPump->AsyncRead(this, nsnull);
    1: }
    1: 
    1: // called when Connect fails
    1: nsresult
    1: nsHttpChannel::AsyncAbort(nsresult status)
    1: {
    1:     LOG(("nsHttpChannel::AsyncAbort [this=%x status=%x]\n", this, status));
    1: 
    1:     mStatus = status;
    1:     mIsPending = PR_FALSE;
    1: 
 5208:     nsresult rv = AsyncCall(&nsHttpChannel::HandleAsyncNotifyListener);
 5208:     // And if that fails?  Callers ignore our return value anyway....
    1:     
    1:     // finally remove ourselves from the load group.
    1:     if (mLoadGroup)
    1:         mLoadGroup->RemoveRequest(this, nsnull, status);
    1: 
 5208:     return rv;
 5208: }
 5208: 
 5208: void
 5208: nsHttpChannel::HandleAsyncNotifyListener()
 5208: {
 5208:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
 5208:     
 5208:     if (mSuspendCount) {
 5208:         LOG(("Waiting until resume to do async notification [this=%p]\n",
 5208:              this));
 5208:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncNotifyListener;
 5208:         return;
 5208:     }
 5208: 
 5208:     DoNotifyListener();
 5208: }
 5208: 
 5208: void
 5208: nsHttpChannel::DoNotifyListener()
 5208: {
 5208:     if (mListener) {
 5208:         mListener->OnStartRequest(this, mListenerContext);
 5208:         mListener->OnStopRequest(this, mListenerContext, mStatus);
 5208:         mListener = 0;
 5208:         mListenerContext = 0;
 5208:     }
 5516:     // We have to make sure to drop the reference to the callbacks too
 5516:     mCallbacks = nsnull;
 5516:     mProgressSink = nsnull;
    1: }
    1: 
    1: void
    1: nsHttpChannel::HandleAsyncRedirect()
    1: {
 5208:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
 5208:     
 5208:     if (mSuspendCount) {
 5208:         LOG(("Waiting until resume to do async redirect [this=%p]\n", this));
 5208:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncRedirect;
 5208:         return;
 5208:     }
 5208: 
    1:     nsresult rv = NS_OK;
    1: 
    1:     LOG(("nsHttpChannel::HandleAsyncRedirect [this=%p]\n", this));
    1: 
    1:     // since this event is handled asynchronously, it is possible that this
    1:     // channel could have been canceled, in which case there would be no point
    1:     // in processing the redirect.
    1:     if (NS_SUCCEEDED(mStatus)) {
    1:         rv = ProcessRedirection(mResponseHead->Status());
    1:         if (NS_FAILED(rv)) {
    1:             // If ProcessRedirection fails, then we have to send out the
    1:             // OnStart/OnStop notifications.
    1:             LOG(("ProcessRedirection failed [rv=%x]\n", rv));
    1:             mStatus = rv;
 5208:             DoNotifyListener();
    1:         }
    1:     }
    1: 
    1:     // close the cache entry.  Blow it away if we couldn't process the redirect
    1:     // for some reason (the cache entry might be corrupt).
    1:     if (mCacheEntry) {
    1:         if (NS_FAILED(rv))
    1:             mCacheEntry->Doom();
19028:         CloseCacheEntry(PR_FALSE);
    1:     }
    1: 
    1:     mIsPending = PR_FALSE;
    1: 
    1:     if (mLoadGroup)
    1:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
    1: }
    1: 
    1: void
    1: nsHttpChannel::HandleAsyncNotModified()
    1: {
 5208:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
 5208:     
 5208:     if (mSuspendCount) {
 5208:         LOG(("Waiting until resume to do async not-modified [this=%p]\n",
 5208:              this));
 5208:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncNotModified;
 5208:         return;
 5208:     }
 5208:     
    1:     LOG(("nsHttpChannel::HandleAsyncNotModified [this=%p]\n", this));
    1: 
 5208:     DoNotifyListener();
    1: 
19028:     CloseCacheEntry(PR_TRUE);
    1: 
    1:     mIsPending = PR_FALSE;
    1: 
    1:     if (mLoadGroup)
    1:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
    1: }
    1: 
19925: void
19925: nsHttpChannel::HandleAsyncFallback()
19925: {
19925:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
19925: 
19925:     if (mSuspendCount) {
19925:         LOG(("Waiting until resume to do async fallback [this=%p]\n", this));
19925:         mPendingAsyncCallOnResume = &nsHttpChannel::HandleAsyncFallback;
19925:         return;
19925:     }
19925: 
19925:     nsresult rv = NS_OK;
19925: 
19925:     LOG(("nsHttpChannel::HandleAsyncFallback [this=%p]\n", this));
19925: 
19925:     // since this event is handled asynchronously, it is possible that this
19925:     // channel could have been canceled, in which case there would be no point
19925:     // in processing the fallback.
19925:     if (!mCanceled) {
19925:         PRBool fallingBack;
19925:         rv = ProcessFallback(&fallingBack);
19925:         if (NS_FAILED(rv) || !fallingBack) {
19925:             // If ProcessFallback fails, then we have to send out the
19925:             // OnStart/OnStop notifications.
19925:             LOG(("ProcessFallback failed [rv=%x, %d]\n", rv, fallingBack));
19925:             mStatus = NS_FAILED(rv) ? rv : NS_ERROR_DOCUMENT_NOT_CACHED;
19925:             DoNotifyListener();
19925:         }
19925:     }
19925: 
19925:     mIsPending = PR_FALSE;
19925: 
19925:     if (mLoadGroup)
19925:         mLoadGroup->RemoveRequest(this, nsnull, mStatus);
19925: }
19925: 
    1: nsresult
    1: nsHttpChannel::SetupTransaction()
    1: {
    1:     LOG(("nsHttpChannel::SetupTransaction [this=%x]\n", this));
    1: 
    1:     NS_ENSURE_TRUE(!mTransaction, NS_ERROR_ALREADY_INITIALIZED);
    1: 
    1:     nsresult rv;
    1: 
    1:     if (mCaps & NS_HTTP_ALLOW_PIPELINING) {
    1:         //
    1:         // disable pipelining if:
    1:         //   (1) pipelining has been explicitly disabled
    1:         //   (2) request corresponds to a top-level document load (link click)
    1:         //   (3) request method is non-idempotent
    1:         //
    1:         // XXX does the toplevel document check really belong here?  or, should
    1:         //     we push it out entirely to necko consumers?
    1:         //
    1:         if (!mAllowPipelining || (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI) ||
    1:             !(mRequestHead.Method() == nsHttp::Get ||
    1:               mRequestHead.Method() == nsHttp::Head ||
    1:               mRequestHead.Method() == nsHttp::Propfind ||
    1:               mRequestHead.Method() == nsHttp::Proppatch)) {
    1:             LOG(("  pipelining disallowed\n"));
    1:             mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
    1:         }
    1:     }
    1: 
    1:     // use the URI path if not proxying (transparent proxying such as SSL proxy
    1:     // does not count here). also, figure out what version we should be speaking.
    1:     nsCAutoString buf, path;
    1:     nsCString* requestURI;
    1:     if (mConnectionInfo->UsingSSL() || !mConnectionInfo->UsingHttpProxy()) {
    1:         rv = mURI->GetPath(path);
    1:         if (NS_FAILED(rv)) return rv;
    1:         // path may contain UTF-8 characters, so ensure that they're escaped.
    1:         if (NS_EscapeURL(path.get(), path.Length(), esc_OnlyNonASCII, buf))
    1:             requestURI = &buf;
    1:         else
    1:             requestURI = &path;
    1:         mRequestHead.SetVersion(gHttpHandler->HttpVersion());
    1:     }
    1:     else {
    1:         rv = mURI->GetUserPass(buf);
    1:         if (NS_FAILED(rv)) return rv;
    1:         if (!buf.IsEmpty() && ((strncmp(mSpec.get(), "http:", 5) == 0) ||
    1:                                 strncmp(mSpec.get(), "https:", 6) == 0)) {
    1:             nsCOMPtr<nsIURI> tempURI;
    1:             rv = mURI->Clone(getter_AddRefs(tempURI));
    1:             if (NS_FAILED(rv)) return rv;
    1:             rv = tempURI->SetUserPass(EmptyCString());
    1:             if (NS_FAILED(rv)) return rv;
    1:             rv = tempURI->GetAsciiSpec(path);
    1:             if (NS_FAILED(rv)) return rv;
    1:             requestURI = &path;
    1:         }
    1:         else
    1:             requestURI = &mSpec;
    1:         mRequestHead.SetVersion(gHttpHandler->ProxyHttpVersion());
    1:     }
    1: 
    1:     // trim off the #ref portion if any...
    1:     PRInt32 ref = requestURI->FindChar('#');
    1:     if (ref != kNotFound)
    1:         requestURI->SetLength(ref);
    1: 
    1:     mRequestHead.SetRequestURI(*requestURI);
    1: 
    1:     // set the request time for cache expiration calculations
    1:     mRequestTime = NowInSeconds();
    1: 
    1:     // if doing a reload, force end-to-end
    1:     if (mLoadFlags & LOAD_BYPASS_CACHE) {
    1:         // We need to send 'Pragma:no-cache' to inhibit proxy caching even if
    1:         // no proxy is configured since we might be talking with a transparent
    1:         // proxy, i.e. one that operates at the network level.  See bug #14772.
    1:         mRequestHead.SetHeader(nsHttp::Pragma, NS_LITERAL_CSTRING("no-cache"), PR_TRUE);
    1:         // If we're configured to speak HTTP/1.1 then also send 'Cache-control:
    1:         // no-cache'
    1:         if (mRequestHead.Version() >= NS_HTTP_VERSION_1_1)
    1:             mRequestHead.SetHeader(nsHttp::Cache_Control, NS_LITERAL_CSTRING("no-cache"), PR_TRUE);
    1:     }
    1:     else if ((mLoadFlags & VALIDATE_ALWAYS) && (mCacheAccess & nsICache::ACCESS_READ)) {
    1:         // We need to send 'Cache-Control: max-age=0' to force each cache along
    1:         // the path to the origin server to revalidate its own entry, if any,
    1:         // with the next cache or server.  See bug #84847.
    1:         //
    1:         // If we're configured to speak HTTP/1.0 then just send 'Pragma: no-cache'
    1:         if (mRequestHead.Version() >= NS_HTTP_VERSION_1_1)
    1:             mRequestHead.SetHeader(nsHttp::Cache_Control, NS_LITERAL_CSTRING("max-age=0"), PR_TRUE);
    1:         else
    1:             mRequestHead.SetHeader(nsHttp::Pragma, NS_LITERAL_CSTRING("no-cache"), PR_TRUE);
    1:     }
    1: 
    1:     if (mResuming) {
    1:         char byteRange[32];
    1:         PR_snprintf(byteRange, sizeof(byteRange), "bytes=%llu-", mStartPos);
    1:         mRequestHead.SetHeader(nsHttp::Range, nsDependentCString(byteRange));
    1: 
    1:         if (!mEntityID.IsEmpty()) {
    1:             // Also, we want an error if this resource changed in the meantime
    1:             // Format of the entity id is: escaped_etag/size/lastmod
    1:             nsCString::const_iterator start, end, slash;
    1:             mEntityID.BeginReading(start);
    1:             mEntityID.EndReading(end);
    1:             mEntityID.BeginReading(slash);
    1: 
    1:             if (FindCharInReadable('/', slash, end)) {
    1:                 nsCAutoString ifMatch;
    1:                 mRequestHead.SetHeader(nsHttp::If_Match,
    1:                         NS_UnescapeURL(Substring(start, slash), 0, ifMatch));
    1: 
    1:                 ++slash; // Incrementing, so that searching for '/' won't find
    1:                          // the same slash again
    1:             }
    1: 
    1:             if (FindCharInReadable('/', slash, end)) {
    1:                 mRequestHead.SetHeader(nsHttp::If_Unmodified_Since,
    1:                         Substring(++slash, end));
    1:             }
    1:         }
    1:     }
    1: 
    1:     // create wrapper for this channel's notification callbacks
    1:     nsCOMPtr<nsIInterfaceRequestor> callbacks;
    1:     NS_NewNotificationCallbacksAggregation(mCallbacks, mLoadGroup,
    1:                                            getter_AddRefs(callbacks));
    1:     if (!callbacks)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // create the transaction object
    1:     mTransaction = new nsHttpTransaction();
    1:     if (!mTransaction)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(mTransaction);
    1: 
25076:     // See bug #466080. Transfer LOAD_ANONYMOUS flag to socket-layer.
25076:     if (mLoadFlags & LOAD_ANONYMOUS) {
25076:         mCaps |= NS_HTTP_LOAD_ANONYMOUS;
25556:         mConnectionInfo->SetAnonymous();
25076:     }
25076: 
    1:     nsCOMPtr<nsIAsyncInputStream> responseStream;
    1:     rv = mTransaction->Init(mCaps, mConnectionInfo, &mRequestHead,
    1:                             mUploadStream, mUploadStreamHasHeaders,
    1:                             NS_GetCurrentThread(), callbacks, this,
    1:                             getter_AddRefs(responseStream));
12940:     if (NS_FAILED(rv)) {
12940:         NS_RELEASE(mTransaction);
12940:         return rv;
12940:     }
    1: 
    1:     rv = nsInputStreamPump::Create(getter_AddRefs(mTransactionPump),
    1:                                    responseStream);
    1:     return rv;
    1: }
    1: 
    1: void
    1: nsHttpChannel::AddCookiesToRequest()
    1: {
19954:     if (mLoadFlags & LOAD_ANONYMOUS) {
19954:       return;
19954:     }
19954: 
    1:     nsXPIDLCString cookie;
    1: 
    1:     nsICookieService *cs = gHttpHandler->GetCookieService();
    1:     if (cs)
    1:         cs->GetCookieStringFromHttp(mURI,
    1:                                     mDocumentURI ? mDocumentURI : mOriginalURI,
    1:                                     this,
    1:                                     getter_Copies(cookie));
    1:     if (cookie.IsEmpty())
    1:         cookie = mUserSetCookieHeader;
    1:     else if (!mUserSetCookieHeader.IsEmpty())
    1:         cookie.Append(NS_LITERAL_CSTRING("; ") + mUserSetCookieHeader);
    1: 
    1:     // overwrite any existing cookie headers.  be sure to clear any
    1:     // existing cookies if we have no cookies to set or if the cookie
    1:     // service is unavailable.
    1:     mRequestHead.SetHeader(nsHttp::Cookie, cookie, PR_FALSE);
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::ApplyContentConversions()
    1: {
    1:     if (!mResponseHead)
    1:         return NS_OK;
    1: 
    1:     LOG(("nsHttpChannel::ApplyContentConversions [this=%x]\n", this));
    1: 
    1:     if (!mApplyConversion) {
    1:         LOG(("not applying conversion per mApplyConversion\n"));
    1:         return NS_OK;
    1:     }
    1: 
    1:     const char *val = mResponseHead->PeekHeader(nsHttp::Content_Encoding);
    1:     if (gHttpHandler->IsAcceptableEncoding(val)) {
    1:         nsCOMPtr<nsIStreamConverterService> serv;
    1:         nsresult rv = gHttpHandler->
    1:                 GetStreamConverterService(getter_AddRefs(serv));
    1:         // we won't fail to load the page just because we couldn't load the
    1:         // stream converter service.. carry on..
    1:         if (NS_SUCCEEDED(rv)) {
    1:             nsCOMPtr<nsIStreamListener> converter;
    1:             nsCAutoString from(val);
    1:             ToLowerCase(from);
    1:             rv = serv->AsyncConvertData(from.get(),
    1:                                         "uncompressed",
    1:                                         mListener,
    1:                                         mListenerContext,
    1:                                         getter_AddRefs(converter));
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 LOG(("converter installed from \'%s\' to \'uncompressed\'\n", val));
    1:                 mListener = converter;
    1:             }
    1:         }
    1:     } else if (val != nsnull) {
    1:         LOG(("Unknown content encoding '%s', ignoring\n", val));
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // NOTE: This function duplicates code from nsBaseChannel. This will go away
    1: // once HTTP uses nsBaseChannel (part of bug 312760)
    1: static void
    1: CallTypeSniffers(void *aClosure, const PRUint8 *aData, PRUint32 aCount)
    1: {
 3233:   nsIChannel *chan = static_cast<nsIChannel*>(aClosure);
    1: 
    1:   const nsCOMArray<nsIContentSniffer>& sniffers =
    1:     gIOService->GetContentSniffers();
    1:   PRUint32 length = sniffers.Count();
    1:   for (PRUint32 i = 0; i < length; ++i) {
    1:     nsCAutoString newType;
    1:     nsresult rv =
    1:       sniffers[i]->GetMIMETypeFromContent(chan, aData, aCount, newType);
    1:     if (NS_SUCCEEDED(rv) && !newType.IsEmpty()) {
    1:       chan->SetContentType(newType);
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::CallOnStartRequest()
    1: {
18377:     mTracingEnabled = PR_FALSE;
18377: 
    1:     if (mResponseHead && mResponseHead->ContentType().IsEmpty()) {
    1:         if (!mContentTypeHint.IsEmpty())
    1:             mResponseHead->SetContentType(mContentTypeHint);
    1:         else {
    1:             // Uh-oh.  We had better find out what type we are!
    1: 
    1:             // XXX This does not work with content-encodings...  but
    1:             // neither does applying the conversion from the URILoader
    1: 
    1:             nsCOMPtr<nsIStreamConverterService> serv;
    1:             nsresult rv = gHttpHandler->
    1:                 GetStreamConverterService(getter_AddRefs(serv));
    1:             // If we failed, we just fall through to the "normal" case
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 nsCOMPtr<nsIStreamListener> converter;
    1:                 rv = serv->AsyncConvertData(UNKNOWN_CONTENT_TYPE,
    1:                                             "*/*",
    1:                                             mListener,
    1:                                             mListenerContext,
    1:                                             getter_AddRefs(converter));
    1:                 if (NS_SUCCEEDED(rv)) {
    1:                     mListener = converter;
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (mResponseHead && mResponseHead->ContentCharset().IsEmpty())
    1:         mResponseHead->SetContentCharset(mContentCharsetHint);
    1: 
    1:     if (mResponseHead)
    1:         SetPropertyAsInt64(NS_CHANNEL_PROP_CONTENT_LENGTH,
    1:                            mResponseHead->ContentLength());
    1: 
    1:     // Allow consumers to override our content type
    1:     if ((mLoadFlags & LOAD_CALL_CONTENT_SNIFFERS) &&
    1:         gIOService->GetContentSniffers().Count() != 0) {
    1:         // NOTE: We can have both a txn pump and a cache pump when the cache
    1:         // content is partial. In that case, we need to read from the cache,
 3040:         // because that's the one that has the initial contents. If that fails
 3040:         // then give the transaction pump a shot.
 3040: 
 3233:         nsIChannel* thisChannel = static_cast<nsIChannel*>(this);
 3040: 
 3040:         PRBool typeSniffersCalled = PR_FALSE;
 3040:         if (mCachePump) {
 3040:           typeSniffersCalled =
 3040:             NS_SUCCEEDED(mCachePump->PeekStream(CallTypeSniffers, thisChannel));
 3040:         }
 3040:         
 3040:         if (!typeSniffersCalled && mTransactionPump) {
 3040:           mTransactionPump->PeekStream(CallTypeSniffers, thisChannel);
 3040:         }
    1:     }
    1: 
    1:     LOG(("  calling mListener->OnStartRequest\n"));
    1:     nsresult rv = mListener->OnStartRequest(this, mListenerContext);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // install stream converter if required
    1:     rv = ApplyContentConversions();
30464:     if (NS_FAILED(rv)) return rv;
30464: 
30464:     if (!mCanceled) {
30464:         // create offline cache entry if offline caching was requested
30464:         if (mCacheForOfflineUse) {
30464:             PRBool shouldCacheForOfflineUse;
30464:             rv = ShouldUpdateOfflineCacheEntry(&shouldCacheForOfflineUse);
30464:             if (NS_FAILED(rv)) return rv;
30464:             
30464:             if (shouldCacheForOfflineUse) {
30464:                 LOG(("writing to the offline cache"));
30464:                 rv = InitOfflineCacheEntry();
30464:                 if (NS_FAILED(rv)) return rv;
30464:                 
30464:                 if (mOfflineCacheEntry) {
30464:                   rv = InstallOfflineCacheListener();
30464:                   if (NS_FAILED(rv)) return rv;
30464:                 }
30464:             } else {
30464:                 LOG(("offline cache is up to date, not updating"));
30464:                 CloseOfflineCacheEntry();
30464:             }
30464:         }
30464:     }
30464: 
30464:     return NS_OK;
    1: }
    1: 
    1: nsresult
27685: nsHttpChannel::ProcessFailedSSLConnect(PRUint32 httpStatus)
27685: {
27685:     // Failure to set up SSL proxy tunnel means one of the following:
27685:     // 1) Proxy wants authorization, or forbids.
27685:     // 2) DNS at proxy couldn't resolve target URL.
27685:     // 3) Proxy connection to target failed or timed out.
27685:     // 4) Eve noticed our proxy CONNECT, and is replying with malicious HTML.
27685:     // 
27685:     // Our current architecture will parse response content with the
27685:     // permission of the target URL!  Given #4, we must avoid rendering the
27685:     // body of the reply, and instead give the user a (hopefully helpful) 
27685:     // boilerplate error page, based on just the HTTP status of the reply.
27685: 
27685:     NS_ABORT_IF_FALSE(mConnectionInfo->UsingSSL(),
27685:                       "SSL connect failed but not using SSL?");
27685:     nsresult rv;
27685:     switch (httpStatus) 
27685:     {
28464:     case 300: case 301: case 302: case 303: case 307:
28464:         // Bad redirect: not top-level, or it's a POST, bad/missing Location,
28464:         // or ProcessRedirect() failed for some other reason.  Legal
28464:         // redirects that fail because site not available, etc., are handled
28464:         // elsewhere, in the regular codepath.
28464:         rv = NS_ERROR_CONNECTION_REFUSED;
28464:         break;
27685:     case 403: // HTTP/1.1: "Forbidden"
27685:     case 407: // ProcessAuthentication() failed
27685:     case 501: // HTTP/1.1: "Not Implemented"
27685:         // user sees boilerplate Mozilla "Proxy Refused Connection" page.
27685:         rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
27685:         break;
27685:     // Squid sends 404 if DNS fails (regular 404 from target is tunneled)
27685:     case 404: // HTTP/1.1: "Not Found"
27685:     // RFC 2616: "some deployed proxies are known to return 400 or 500 when
27685:     // DNS lookups time out."  (Squid uses 500 if it runs out of sockets: so
27685:     // we have a conflict here).
27685:     case 400: // HTTP/1.1 "Bad Request"
27685:     case 500: // HTTP/1.1: "Internal Server Error"
27685:         /* User sees: "Address Not Found: Firefox can't find the server at
27685:          * www.foo.com."
27685:          */
27685:         rv = NS_ERROR_UNKNOWN_HOST; 
27685:         break;
27685:     case 502: // HTTP/1.1: "Bad Gateway" (invalid resp from target server)
27685:     // Squid returns 503 if target request fails for anything but DNS.
27685:     case 503: // HTTP/1.1: "Service Unavailable"
27685:         /* User sees: "Failed to Connect:
27685:          *  Firefox can't establish a connection to the server at
27685:          *  www.foo.com.  Though the site seems valid, the browser
27685:          *  was unable to establish a connection."
27685:          */
27685:         rv = NS_ERROR_CONNECTION_REFUSED;
27685:         break;
27685:     // RFC 2616 uses 504 for both DNS and target timeout, so not clear what to
27685:     // do here: picking target timeout, as DNS covered by 400/404/500
27685:     case 504: // HTTP/1.1: "Gateway Timeout" 
27685:         // user sees: "Network Timeout: The server at www.foo.com
27685:         //              is taking too long to respond."
27685:         rv = NS_ERROR_NET_TIMEOUT;
27685:         break;
27685:     // Confused proxy server or malicious response
27685:     default:
27685:         rv = NS_ERROR_PROXY_CONNECTION_REFUSED; 
27685:         break;
27685:     }
27685:     LOG(("Cancelling failed SSL proxy connection [this=%x httpStatus=%u]\n",
27685:          this, httpStatus)); 
27685:     Cancel(rv);
27685:     return rv;
27685: }
27685: 
28464: PRBool
28464: nsHttpChannel::ShouldSSLProxyResponseContinue(PRUint32 httpStatus)
28464: {
28464:     // When SSL connect has failed, allow proxy reply to continue only if it's
28464:     // an auth request, or a redirect of a non-POST top-level document load.
28464:     switch (httpStatus) {
28464:     case 407:
28464:         return PR_TRUE;
28464:     case 300: case 301: case 302: case 303: case 307:
28464:       {
28464:         return ( (mLoadFlags & nsIChannel::LOAD_DOCUMENT_URI) &&
28464:                  mURI == mDocumentURI &&
28464:                  mRequestHead.Method() != nsHttp::Post);
28464:       }
28464:     }
28464:     return PR_FALSE;
28464: }
28464: 
27685: nsresult
    1: nsHttpChannel::ProcessResponse()
    1: {
    1:     nsresult rv;
    1:     PRUint32 httpStatus = mResponseHead->Status();
    1: 
    1:     LOG(("nsHttpChannel::ProcessResponse [this=%x httpStatus=%u]\n",
    1:         this, httpStatus));
    1: 
28464:     if (mTransaction->SSLConnectFailed() &&
28464:         !ShouldSSLProxyResponseContinue(httpStatus))
27685:         return ProcessFailedSSLConnect(httpStatus);
27685: 
    1:     // notify "http-on-examine-response" observers
    1:     gHttpHandler->OnExamineResponse(this);
    1: 
    1:     // set cookies, if any exist; done after OnExamineResponse to allow those
    1:     // observers to modify the cookie response headers
    1:     SetCookie(mResponseHead->PeekHeader(nsHttp::Set_Cookie));
    1: 
    1:     // handle unused username and password in url (see bug 232567)
    1:     if (httpStatus != 401 && httpStatus != 407) {
    1:         CheckForSuperfluousAuth();
    1:         if (mCanceled)
    1:             return CallOnStartRequest();
    1: 
    1:         if (mAuthContinuationState) {
    1:             // reset the current continuation state because our last
    1:             // authentication attempt has been completed successfully
    1:             NS_RELEASE(mAuthContinuationState);
    1:             LOG(("  continuation state has been reset"));
    1:         }
    1:     }
    1: 
    1:     // handle different server response categories.  Note that we handle
    1:     // caching or not caching of error pages in
    1:     // nsHttpResponseHead::MustValidate; if you change this switch, update that
    1:     // one
    1:     switch (httpStatus) {
    1:     case 200:
    1:     case 203:
    1:         // Per RFC 2616, 14.35.2, "A server MAY ignore the Range header".
    1:         // So if a server does that and sends 200 instead of 206 that we
    1:         // expect, notify our caller.
 6914:         // However, if we wanted to start from the beginning, let it go through
 6914:         if (mResuming && mStartPos != 0) {
 5258:             LOG(("Server ignored our Range header, cancelling [this=%p]\n", this));
    1:             Cancel(NS_ERROR_NOT_RESUMABLE);
    1:             rv = CallOnStartRequest();
    1:             break;
    1:         }
    1:         // these can normally be cached
    1:         rv = ProcessNormal();
20265:         MaybeInvalidateCacheEntryForSubsequentGet();
    1:         break;
    1:     case 206:
    1:         if (mCachedContentIsPartial) // an internal byte range request...
    1:             rv = ProcessPartialContent();
    1:         else
    1:             rv = ProcessNormal();
    1:         break;
    1:     case 300:
    1:     case 301:
    1:     case 302:
    1:     case 307:
    1:     case 303:
    1: #if 0
    1:     case 305: // disabled as a security measure (see bug 187996).
    1: #endif
    1:         // don't store the response body for redirects
20265:         MaybeInvalidateCacheEntryForSubsequentGet();
    1:         rv = ProcessRedirection(httpStatus);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             InitCacheEntry();
19028:             CloseCacheEntry(PR_FALSE);
    1: 
    1:             if (mCacheForOfflineUse) {
    1:                 // Store response in the offline cache
    1:                 InitOfflineCacheEntry();
    1:                 CloseOfflineCacheEntry();
    1:             }
    1:         }    
    1:         else {
    1:             LOG(("ProcessRedirection failed [rv=%x]\n", rv));
28464:             if (mTransaction->SSLConnectFailed())
28464:                 return ProcessFailedSSLConnect(httpStatus);
    1:             rv = ProcessNormal();
    1:         }
    1:         break;
    1:     case 304:
    1:         rv = ProcessNotModified();
    1:         if (NS_FAILED(rv)) {
    1:             LOG(("ProcessNotModified failed [rv=%x]\n", rv));
    1:             rv = ProcessNormal();
    1:         }
    1:         break;
    1:     case 401:
    1:     case 407:
    1:         rv = ProcessAuthentication(httpStatus);
    1:         if (NS_FAILED(rv)) {
    1:             LOG(("ProcessAuthentication failed [rv=%x]\n", rv));
27685:             if (mTransaction->SSLConnectFailed())
27685:                 return ProcessFailedSSLConnect(httpStatus);
    1:             CheckForSuperfluousAuth();
    1:             rv = ProcessNormal();
    1:         }
    1:         break;
    1:     default:
    1:         rv = ProcessNormal();
20265:         MaybeInvalidateCacheEntryForSubsequentGet();
    1:         break;
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::ProcessNormal()
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("nsHttpChannel::ProcessNormal [this=%x]\n", this));
    1: 
19925:     PRBool succeeded;
19925:     rv = GetRequestSucceeded(&succeeded);
19925:     if (NS_SUCCEEDED(rv) && !succeeded) {
19925:         PRBool fallingBack;
19925:         rv = ProcessFallback(&fallingBack);
19925:         if (NS_FAILED(rv)) {
19925:             DoNotifyListener();
19925:             return rv;
19925:         }
19925: 
19925:         if (fallingBack) {
19925:             // Do not continue with normal processing, fallback is in
19925:             // progress now.
19925:             return NS_OK;
19925:         }
19925:     }
19925: 
    1:     // if we're here, then any byte-range requests failed to result in a partial
    1:     // response.  we must clear this flag to prevent BufferPartialContent from
    1:     // being called inside our OnDataAvailable (see bug 136678).
    1:     mCachedContentIsPartial = PR_FALSE;
    1: 
16322:     ClearBogusContentEncodingIfNeeded();
    1: 
    1:     // this must be called before firing OnStartRequest, since http clients,
    1:     // such as imagelib, expect our cache entry to already have the correct
    1:     // expiration time (bug 87710).
    1:     if (mCacheEntry) {
    1:         rv = InitCacheEntry();
    1:         if (NS_FAILED(rv))
19028:             CloseCacheEntry(PR_TRUE);
    1:     }
    1: 
    1:     // Check that the server sent us what we were asking for
    1:     if (mResuming) {
    1:         // Create an entity id from the response
    1:         nsCAutoString id;
    1:         rv = GetEntityID(id);
    1:         if (NS_FAILED(rv)) {
    1:             // If creating an entity id is not possible -> error
    1:             Cancel(NS_ERROR_NOT_RESUMABLE);
    1:         }
 6914:         else if (mResponseHead->Status() != 206 &&
 6914:                  mResponseHead->Status() != 200) {
 5264:             // Probably 404 Not Found, 412 Precondition Failed or
 5264:             // 416 Invalid Range -> error
 5264:             LOG(("Unexpected response status while resuming, aborting [this=%p]\n",
 5264:                  this));
 5264:             Cancel(NS_ERROR_ENTITY_CHANGED);
 5264:         }
    1:         // If we were passed an entity id, verify it's equal to the server's
    1:         else if (!mEntityID.IsEmpty()) {
 5258:             if (!mEntityID.Equals(id)) {
 5258:                 LOG(("Entity mismatch, expected '%s', got '%s', aborting [this=%p]",
 5258:                      mEntityID.get(), id.get(), this));
    1:                 Cancel(NS_ERROR_ENTITY_CHANGED);
    1:             }
    1:         }
 5258:     }
    1: 
    1:     rv = CallOnStartRequest();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // install cache listener if we still have a cache entry open
    1:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE)) {
    1:         rv = InstallCacheListener();
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
30464: 
30464:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::PromptTempRedirect()
    1: {
25455:     if (!gHttpHandler->PromptTempRedirect()) {
25455:         return NS_OK;
25455:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsIStringBundleService> bundleService =
    1:             do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsCOMPtr<nsIStringBundle> stringBundle;
    1:     rv = bundleService->CreateBundle(NECKO_MSGS_URL, getter_AddRefs(stringBundle));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsXPIDLString messageString;
    1:     rv = stringBundle->GetStringFromName(NS_LITERAL_STRING("RepostFormData").get(), getter_Copies(messageString));
    1:     // GetStringFromName can return NS_OK and NULL messageString.
    1:     if (NS_SUCCEEDED(rv) && messageString) {
    1:         PRBool repost = PR_FALSE;
    1: 
    1:         nsCOMPtr<nsIPrompt> prompt;
    1:         GetCallback(prompt);
    1:         if (!prompt)
    1:             return NS_ERROR_NO_INTERFACE;
    1: 
    1:         prompt->Confirm(nsnull, messageString, &repost);
    1:         if (!repost)
    1:             return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::ProxyFailover()
    1: {
    1:     LOG(("nsHttpChannel::ProxyFailover [this=%x]\n", this));
    1: 
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIProtocolProxyService> pps =
    1:             do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCOMPtr<nsIProxyInfo> pi;
    1:     rv = pps->GetFailoverForProxy(mConnectionInfo->ProxyInfo(), mURI, mStatus,
    1:                                   getter_AddRefs(pi));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
 5208:     // XXXbz so where does this codepath remove us from the loadgroup,
 5208:     // exactly?
 5208:     return DoReplaceWithProxy(pi);
 5208: }
 5208: 
 5208: void
 5208: nsHttpChannel::HandleAsyncReplaceWithProxy()
 5208: {
 5208:     NS_PRECONDITION(!mPendingAsyncCallOnResume, "How did that happen?");
 5208: 
 5208:     if (mSuspendCount) {
 5208:         LOG(("Waiting until resume to do async proxy replacement [this=%p]\n",
 5208:              this));
 5208:         mPendingAsyncCallOnResume =
 5208:             &nsHttpChannel::HandleAsyncReplaceWithProxy;
 5208:         return;
 5208:     }
 5208: 
 5208:     nsresult status = mStatus;
 5208:     
 5208:     nsCOMPtr<nsIProxyInfo> pi;
 5208:     pi.swap(mTargetProxyInfo);
 5208:     if (!mCanceled) {
 5208:         status = DoReplaceWithProxy(pi);
 5208:         if (mLoadGroup && NS_SUCCEEDED(status)) {
 5208:             mLoadGroup->RemoveRequest(this, nsnull, mStatus);
 5208:         }
 5208:     }
 5208: 
 5208:     if (NS_FAILED(status)) {
 5208:         AsyncAbort(status);
 5208:     }
    1: }
    1: 
    1: nsresult
 5208: nsHttpChannel::DoReplaceWithProxy(nsIProxyInfo* pi)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIChannel> newChannel;
    1:     rv = gHttpHandler->NewProxiedChannel(mURI, pi, getter_AddRefs(newChannel));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
14455:     rv = SetupReplacementChannel(mURI, newChannel, PR_TRUE);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Inform consumers about this fake redirect
    1:     PRUint32 flags = nsIChannelEventSink::REDIRECT_INTERNAL;
    1:     rv = gHttpHandler->OnChannelRedirect(this, newChannel, flags);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
21937:     // Make sure to do this _after_ calling OnChannelRedirect
21937:     newChannel->SetOriginalURI(mOriginalURI);
21937: 
    1:     // open new channel
    1:     rv = newChannel->AsyncOpen(mListener, mListenerContext);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     mStatus = NS_BINDING_REDIRECTED;
31432: 
31432:     // disconnect from the old listeners...
    1:     mListener = nsnull;
    1:     mListenerContext = nsnull;
31432: 
31432:     // ...and the old callbacks
31432:     mCallbacks = nsnull;
31432:     mProgressSink = nsnull;
31432: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::ResolveProxy()
    1: {
    1:     LOG(("nsHttpChannel::ResolveProxy [this=%x]\n", this));
    1: 
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIProtocolProxyService> pps =
    1:             do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return pps->AsyncResolve(mURI, 0, this, getter_AddRefs(mProxyRequest));
    1: }
    1: 
    1: PRBool
    1: nsHttpChannel::ResponseWouldVary()
    1: {
    1:     PRBool result = PR_FALSE;
    1:     nsCAutoString buf, metaKey;
    1:     mCachedResponseHead->GetHeader(nsHttp::Vary, buf);
    1:     if (!buf.IsEmpty()) {
    1:         NS_NAMED_LITERAL_CSTRING(prefix, "request-");
    1: 
    1:         // enumerate the elements of the Vary header...
    1:         char *val = buf.BeginWriting(); // going to munge buf
    1:         char *token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
    1:         while (token) {
    1:             //
    1:             // if "*", then assume response would vary.  technically speaking,
    1:             // "Vary: header, *" is not permitted, but we allow it anyways.
    1:             //
    1:             // if the response depends on the value of the "Cookie" header, then
    1:             // bail since we do not store cookies in the cache.  this is done
    1:             // for the following reasons:
    1:             //
    1:             //   1- cookies can be very large in size
    1:             //
    1:             //   2- cookies may contain sensitive information.  (for parity with
    1:             //      out policy of not storing Set-cookie headers in the cache
    1:             //      meta data, we likewise do not want to store cookie headers
    1:             //      here.)
    1:             //
    1:             // this implementation is obviously not fully standards compliant, but
    1:             // it is perhaps most prudent given the above issues.
    1:             //
    1:             if ((*token == '*') || (PL_strcasecmp(token, "cookie") == 0)) {
    1:                 result = PR_TRUE;
    1:                 break;
    1:             }
    1:             else {
    1:                 // build cache meta data key...
    1:                 metaKey = prefix + nsDependentCString(token);
    1: 
    1:                 // check the last value of the given request header to see if it has
    1:                 // since changed.  if so, then indeed the cached response is invalid.
    1:                 nsXPIDLCString lastVal;
    1:                 mCacheEntry->GetMetaDataElement(metaKey.get(), getter_Copies(lastVal));
    1:                 if (lastVal) {
    1:                     nsHttpAtom atom = nsHttp::ResolveAtom(token);
    1:                     const char *newVal = mRequestHead.PeekHeader(atom);
    1:                     if (newVal && (strcmp(newVal, lastVal) != 0)) {
    1:                         result = PR_TRUE; // yes, response would vary
    1:                         break;
    1:                     }
    1:                 }
    1:                 
    1:                 // next token...
    1:                 token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
    1:             }
    1:         }
    1:     }
    1:     return result;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel <byte-range>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsHttpChannel::SetupByteRangeRequest(PRUint32 partialLen)
    1: {
    1:     // cached content has been found to be partial, add necessary request
    1:     // headers to complete cache entry.
    1: 
    1:     // use strongest validator available...
    1:     const char *val = mCachedResponseHead->PeekHeader(nsHttp::ETag);
    1:     if (!val)
    1:         val = mCachedResponseHead->PeekHeader(nsHttp::Last_Modified);
    1:     if (!val) {
    1:         // if we hit this code it means mCachedResponseHead->IsResumable() is
    1:         // either broken or not being called.
    1:         NS_NOTREACHED("no cache validator");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     char buf[32];
    1:     PR_snprintf(buf, sizeof(buf), "bytes=%u-", partialLen);
    1: 
    1:     mRequestHead.SetHeader(nsHttp::Range, nsDependentCString(buf));
    1:     mRequestHead.SetHeader(nsHttp::If_Range, nsDependentCString(val));
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::ProcessPartialContent()
    1: {
    1:     // ok, we've just received a 206
    1:     //
    1:     // we need to stream whatever data is in the cache out first, and then
    1:     // pick up whatever data is on the wire, writing it into the cache.
    1: 
    1:     LOG(("nsHttpChannel::ProcessPartialContent [this=%x]\n", this)); 
    1: 
    1:     NS_ENSURE_TRUE(mCachedResponseHead, NS_ERROR_NOT_INITIALIZED);
    1:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_INITIALIZED);
    1: 
16322:     // Make sure to clear bogus content-encodings before looking at the header
16322:     ClearBogusContentEncodingIfNeeded();
16322:     
    1:     // Check if the content-encoding we now got is different from the one we
    1:     // got before
    1:     if (PL_strcasecmp(mResponseHead->PeekHeader(nsHttp::Content_Encoding),
    1:                       mCachedResponseHead->PeekHeader(nsHttp::Content_Encoding))
    1:                       != 0) {
    1:         Cancel(NS_ERROR_INVALID_CONTENT_ENCODING);
    1:         return CallOnStartRequest();
    1:     }
    1: 
    1: 
    1:     // suspend the current transaction
    1:     nsresult rv = mTransactionPump->Suspend();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // merge any new headers with the cached response headers
    1:     rv = mCachedResponseHead->UpdateHeaders(mResponseHead->Headers());
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // update the cached response head
    1:     nsCAutoString head;
    1:     mCachedResponseHead->Flatten(head, PR_TRUE);
    1:     rv = mCacheEntry->SetMetaDataElement("response-head", head.get());
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // make the cached response be the current response
    1:     delete mResponseHead;
    1:     mResponseHead = mCachedResponseHead;
    1:     mCachedResponseHead = 0;
    1: 
    1:     rv = UpdateExpirationTime();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // notify observers interested in looking at a response that has been
    1:     // merged with any cached headers (http-on-examine-merged-response).
    1:     gHttpHandler->OnExamineMergedResponse(this);
    1: 
    1:     // the cached content is valid, although incomplete.
    1:     mCachedContentIsValid = PR_TRUE;
    1:     return ReadFromCache();
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::OnDoneReadingPartialCacheEntry(PRBool *streamDone)
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("nsHttpChannel::OnDoneReadingPartialCacheEntry [this=%x]", this));
    1: 
    1:     // by default, assume we would have streamed all data or failed...
    1:     *streamDone = PR_TRUE;
    1: 
    1:     // setup cache listener to append to cache entry
    1:     PRUint32 size;
    1:     rv = mCacheEntry->GetDataSize(&size);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = InstallCacheListener(size);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // need to track the logical offset of the data being sent to our listener
    1:     mLogicalOffset = size;
    1: 
    1:     // we're now completing the cached content, so we can clear this flag.
    1:     // this puts us in the state of a regular download.
    1:     mCachedContentIsPartial = PR_FALSE;
    1: 
    1:     // resume the transaction if it exists, otherwise the pipe contained the
    1:     // remaining part of the document and we've now streamed all of the data.
    1:     if (mTransactionPump) {
    1:         rv = mTransactionPump->Resume();
    1:         if (NS_SUCCEEDED(rv))
    1:             *streamDone = PR_FALSE;
    1:     }
    1:     else
    1:         NS_NOTREACHED("no transaction");
    1:     return rv;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel <cache>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsHttpChannel::ProcessNotModified()
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("nsHttpChannel::ProcessNotModified [this=%x]\n", this)); 
    1: 
34074:     if (mCustomConditionalRequest) {
34074:         LOG(("Bypassing ProcessNotModified due to custom conditional headers")); 
34058:         return NS_ERROR_FAILURE;
34074:     }
34058: 
    1:     NS_ENSURE_TRUE(mCachedResponseHead, NS_ERROR_NOT_INITIALIZED);
    1:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     // merge any new headers with the cached response headers
    1:     rv = mCachedResponseHead->UpdateHeaders(mResponseHead->Headers());
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // update the cached response head
    1:     nsCAutoString head;
    1:     mCachedResponseHead->Flatten(head, PR_TRUE);
    1:     rv = mCacheEntry->SetMetaDataElement("response-head", head.get());
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // make the cached response be the current response
    1:     delete mResponseHead;
    1:     mResponseHead = mCachedResponseHead;
    1:     mCachedResponseHead = 0;
    1: 
    1:     rv = UpdateExpirationTime();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // notify observers interested in looking at a reponse that has been
    1:     // merged with any cached headers
    1:     gHttpHandler->OnExamineMergedResponse(this);
    1: 
    1:     mCachedContentIsValid = PR_TRUE;
    1:     rv = ReadFromCache();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     mTransactionReplaced = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
19925: nsHttpChannel::ProcessFallback(PRBool *fallingBack)
19925: {
19925:     LOG(("nsHttpChannel::ProcessFallback [this=%x]\n", this));
19925:     nsresult rv;
19925: 
19925:     *fallingBack = PR_FALSE;
19925: 
19925:     // At this point a load has failed (either due to network problems
19925:     // or an error returned on the server).  Perform an application
19925:     // cache fallback if we have a URI to fall back to.
19925:     if (!mApplicationCache || mFallbackKey.IsEmpty() || mFallbackChannel) {
19925:         LOG(("  choosing not to fallback [%p,%s,%d]",
19925:              mApplicationCache.get(), mFallbackKey.get(), mFallbackChannel));
19925:         return NS_OK;
19925:     }
19925: 
19925:     // Make sure the fallback entry hasn't been marked as a foreign
19925:     // entry.
19925:     PRUint32 fallbackEntryType;
19925:     rv = mApplicationCache->GetTypes(mFallbackKey, &fallbackEntryType);
19925:     NS_ENSURE_SUCCESS(rv, rv);
19925: 
19925:     if (fallbackEntryType & nsIApplicationCache::ITEM_FOREIGN) {
19925:         // This cache points to a fallback that refers to a different
19925:         // manifest.  Refuse to fall back.
19925:         return NS_OK;
19925:     }
19925: 
19925:     NS_ASSERTION(fallbackEntryType & nsIApplicationCache::ITEM_FALLBACK,
19925:                  "Fallback entry not marked correctly!");
19925: 
19925:     // Kill any opportunistic cache entry, and disable opportunistic
19925:     // caching for the fallback.
19925:     if (mOfflineCacheEntry) {
19925:         mOfflineCacheEntry->Doom();
19925:         mOfflineCacheEntry = 0;
19925:         mOfflineCacheAccess = 0;
19925:     }
19925: 
19925:     mCacheForOfflineUse = PR_FALSE;
19925:     mCachingOpportunistically = PR_FALSE;
19925:     mOfflineCacheClientID.Truncate();
19925:     mOfflineCacheEntry = 0;
19925:     mOfflineCacheAccess = 0;
19925: 
19925:     // Close the current cache entry.
19925:     if (mCacheEntry)
19925:         CloseCacheEntry(PR_TRUE);
19925: 
19925:     // Create a new channel to load the fallback entry.
19925:     nsRefPtr<nsIChannel> newChannel;
19925:     rv = gHttpHandler->NewChannel(mURI, getter_AddRefs(newChannel));
19925:     NS_ENSURE_SUCCESS(rv, rv);
19925: 
19925:     rv = SetupReplacementChannel(mURI, newChannel, PR_TRUE);
19925:     NS_ENSURE_SUCCESS(rv, rv);
19925: 
19925:     // Make sure the new channel loads from the fallback key.
19925:     nsCOMPtr<nsIHttpChannelInternal> httpInternal =
19925:         do_QueryInterface(newChannel, &rv);
19925:     NS_ENSURE_SUCCESS(rv, rv);
19925: 
19925:     rv = httpInternal->SetupFallbackChannel(mFallbackKey.get());
19925:     NS_ENSURE_SUCCESS(rv, rv);
19925: 
19925:     // ... and fallbacks should only load from the cache.
19925:     PRUint32 newLoadFlags = mLoadFlags | LOAD_REPLACE | LOAD_ONLY_FROM_CACHE;
19925:     rv = newChannel->SetLoadFlags(newLoadFlags);
19925: 
19925:     // Inform consumers about this fake redirect
19925:     PRUint32 redirectFlags = nsIChannelEventSink::REDIRECT_INTERNAL;
19925:     rv = gHttpHandler->OnChannelRedirect(this, newChannel, redirectFlags);
19925:     if (NS_FAILED(rv))
19925:         return rv;
19925: 
21937:     // Make sure to do this _after_ calling OnChannelRedirect
21937:     newChannel->SetOriginalURI(mOriginalURI);
21937:     
19925:     rv = newChannel->AsyncOpen(mListener, mListenerContext);
19925:     NS_ENSURE_SUCCESS(rv, rv);
19925: 
19925:     // close down this channel
19925:     Cancel(NS_BINDING_REDIRECTED);
19925: 
19925:     // disconnect from our listener
19925:     mListener = 0;
19925:     mListenerContext = 0;
19925:     // and from our callbacks
19925:     mCallbacks = nsnull;
19925:     mProgressSink = nsnull;
19925: 
19925:     *fallingBack = PR_TRUE;
19925: 
19925:     return NS_OK;
19925: }
19925: 
23860: // Determines if a request is a byte range request for a subrange,
23860: // i.e. is a byte range request, but not a 0- byte range request.
23860: static PRBool
23860: IsSubRangeRequest(nsHttpRequestHead &aRequestHead)
23860: {
23860:     if (!aRequestHead.PeekHeader(nsHttp::Range))
23860:         return PR_FALSE;
23860:     nsCAutoString byteRange;
23860:     aRequestHead.GetHeader(nsHttp::Range, byteRange);
23860:     return !byteRange.EqualsLiteral("bytes=0-");
23860: }
23860: 
19925: nsresult
    1: nsHttpChannel::OpenCacheEntry(PRBool offline, PRBool *delayed)
    1: {
    1:     nsresult rv;
    1: 
    1:     *delayed = PR_FALSE;
21367:     mLoadedFromApplicationCache = PR_FALSE;
    1: 
    1:     LOG(("nsHttpChannel::OpenCacheEntry [this=%x]", this));
    1: 
    1:     // make sure we're not abusing this function
    1:     NS_PRECONDITION(!mCacheEntry, "cache entry already open");
    1: 
    1:     nsCAutoString cacheKey;
    1: 
    1:     if (mRequestHead.Method() == nsHttp::Post) {
    1:         // If the post id is already set then this is an attempt to replay
    1:         // a post transaction via the cache.  Otherwise, we need a unique
    1:         // post id for this transaction.
    1:         if (mPostID == 0)
    1:             mPostID = gHttpHandler->GenerateUniqueID();
    1:     }
    1:     else if ((mRequestHead.Method() != nsHttp::Get) &&
    1:              (mRequestHead.Method() != nsHttp::Head)) {
    1:         // don't use the cache for other types of requests
    1:         return NS_OK;
    1:     }
    1: 
23860:     if (mResuming) {
23860:         // We don't support caching for requests initiated
23860:         // via nsIResumableChannel.
    1:         return NS_OK;
    1:     }
    1: 
23860:     // Don't cache byte range requests which are subranges, only cache 0-
23860:     // byte range requests.
23860:     if (IsSubRangeRequest(mRequestHead))
23860:         return NS_OK;
23860: 
20265:     GenerateCacheKey(mPostID, cacheKey);
    1: 
    1:     // Get a cache session with appropriate storage policy
20265:     nsCacheStoragePolicy storagePolicy = DetermineStoragePolicy();
    1: 
    1:     // Set the desired cache access mode accordingly...
    1:     nsCacheAccessMode accessRequested;
22721:     if (offline || (mLoadFlags & INHIBIT_CACHING)) {
    1:         // If we have been asked to bypass the cache and not write to the
 3239:         // cache, then don't use the cache at all.  Unless we're actually
 3239:         // offline, which takes precedence over BYPASS_LOCAL_CACHE.
    1:         if (BYPASS_LOCAL_CACHE(mLoadFlags) && !offline)
    1:             return NS_ERROR_NOT_AVAILABLE;
    1:         accessRequested = nsICache::ACCESS_READ;
    1:     }
    1:     else if (BYPASS_LOCAL_CACHE(mLoadFlags))
    1:         accessRequested = nsICache::ACCESS_WRITE; // replace cache entry
    1:     else
    1:         accessRequested = nsICache::ACCESS_READ_WRITE; // normal browsing
    1: 
21311:     if (!mApplicationCache && mInheritApplicationCache) {
21311:         // Pick up an application cache from the notification
21311:         // callbacks if available
18430:         nsCOMPtr<nsIApplicationCacheContainer> appCacheContainer;
18430:         GetCallback(appCacheContainer);
18430: 
18430:         if (appCacheContainer) {
18430:             appCacheContainer->GetApplicationCache(getter_AddRefs(mApplicationCache));
18430:         }
21311:     }
21311: 
21311:     if (!mApplicationCache &&
21311:         (mChooseApplicationCache || (mLoadFlags & LOAD_CHECK_OFFLINE_CACHE))) {
18430:         // We're supposed to load from an application cache, but
18430:         // one was not supplied by the load group.  Ask the
18430:         // application cache service to choose one for us.
18430:         nsCOMPtr<nsIApplicationCacheService> appCacheService =
18430:             do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
18430:         if (appCacheService) {
18430:             nsresult rv = appCacheService->ChooseApplicationCache
18430:                 (cacheKey, getter_AddRefs(mApplicationCache));
18430:             NS_ENSURE_SUCCESS(rv, rv);
18430:         }
18430:     }
18430: 
    1:     nsCOMPtr<nsICacheSession> session;
18430: 
19925:     // Will be set to true if we've found the right session, but need
19925:     // to open the cache entry asynchronously.
19925:     PRBool waitingForValidation = PR_FALSE;
19925: 
18430:     // If we have an application cache, we check it first.
18430:     if (mApplicationCache) {
18430:         nsCAutoString appCacheClientID;
18430:         mApplicationCache->GetClientID(appCacheClientID);
18430: 
18430:         nsCOMPtr<nsICacheService> serv =
18430:             do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
18430:         NS_ENSURE_SUCCESS(rv, rv);
18430: 
18430:         rv = serv->CreateSession(appCacheClientID.get(),
18430:                                  nsICache::STORE_OFFLINE,
18430:                                  nsICache::STREAM_BASED,
    1:                                  getter_AddRefs(session));
18430:         NS_ENSURE_SUCCESS(rv, rv);
18430: 
18430:         // we'll try to synchronously open the cache entry... however,
18430:         // it may be in use and not yet validated, in which case we'll
18430:         // try asynchronously opening the cache entry.
10900:         //
19925:         // We open with ACCESS_READ only, because we don't want to
19925:         // overwrite the offline cache entry non-atomically.
19925:         // ACCESS_READ will prevent us from writing to the offline
19925:         // cache as a normal cache entry.
18430:         rv = session->OpenCacheEntry(cacheKey,
18430:                                      nsICache::ACCESS_READ, PR_FALSE,
    1:                                      getter_AddRefs(mCacheEntry));
19925:         if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
19925:             accessRequested = nsICache::ACCESS_READ;
19925:             waitingForValidation = PR_TRUE;
19925:             rv = NS_OK;
19925:         }
19925: 
19925:         if (NS_FAILED(rv) && !mCacheForOfflineUse && !mFallbackChannel) {
19925:             // Check for namespace match.
19925:             nsCOMPtr<nsIApplicationCacheNamespace> namespaceEntry;
19925:             rv = mApplicationCache->GetMatchingNamespace
19925:                 (cacheKey, getter_AddRefs(namespaceEntry));
19925:             NS_ENSURE_SUCCESS(rv, rv);
19925: 
19925:             PRUint32 namespaceType = 0;
19925:             if (!namespaceEntry ||
19925:                 NS_FAILED(namespaceEntry->GetItemType(&namespaceType)) ||
19925:                 (namespaceType &
19925:                  (nsIApplicationCacheNamespace::NAMESPACE_FALLBACK |
19925:                   nsIApplicationCacheNamespace::NAMESPACE_OPPORTUNISTIC |
19925:                   nsIApplicationCacheNamespace::NAMESPACE_BYPASS)) == 0) {
19925:                 // When loading from an application cache, only items
19925:                 // on the whitelist or matching a
19925:                 // fallback/opportunistic namespace should hit the
19925:                 // network...
19925:                 mLoadFlags |= LOAD_ONLY_FROM_CACHE;
19925: 
19925:                 // ... and if there were an application cache entry,
19925:                 // we would have found it earlier.
19925:                 return NS_ERROR_CACHE_KEY_NOT_FOUND;
19925:             }
19925: 
19925:             if (namespaceType &
19925:                 nsIApplicationCacheNamespace::NAMESPACE_FALLBACK) {
19925:                 rv = namespaceEntry->GetData(mFallbackKey);
19925:                 NS_ENSURE_SUCCESS(rv, rv);
19925:             }
19925: 
19925:             if ((namespaceType &
19925:                  nsIApplicationCacheNamespace::NAMESPACE_OPPORTUNISTIC) &&
19925:                 mLoadFlags & LOAD_DOCUMENT_URI) {
19925:                 // Document loads for items in an opportunistic namespace
19925:                 // should be placed in the offline cache.
19925:                 nsCString clientID;
19925:                 mApplicationCache->GetClientID(clientID);
19925: 
19925:                 mCacheForOfflineUse = !clientID.IsEmpty();
19925:                 SetOfflineCacheClientID(clientID);
19925:                 mCachingOpportunistically = PR_TRUE;
19925:             }
19925:         }
21367:         else if (NS_SUCCEEDED(rv)) {
21367:             // We successfully opened an offline cache session and the entry,
21367:             // now indiciate we load from the offline cache.
21367:             mLoadedFromApplicationCache = PR_TRUE;
21367:         }
19925:     }
19925: 
19925:     if (!mCacheEntry && !waitingForValidation) {
    1:         rv = gHttpHandler->GetCacheSession(storagePolicy,
    1:                                            getter_AddRefs(session));
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         rv = session->OpenCacheEntry(cacheKey, accessRequested, PR_FALSE,
    1:                                      getter_AddRefs(mCacheEntry));
    1:         if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
19925:             waitingForValidation = PR_TRUE;
19925:             rv = NS_OK;
19925:         }
19925:         if (NS_FAILED(rv)) return rv;
19925:     }
19925: 
19925:     if (waitingForValidation) {
19925:         // access to the cache entry has been denied (because the
19925:         // cache entry is probably in use by another channel).
    1:         if (mLoadFlags & LOAD_BYPASS_LOCAL_CACHE_IF_BUSY) {
    1:             LOG(("bypassing local cache since it is busy\n"));
    1:             return NS_ERROR_NOT_AVAILABLE;
    1:         }
    1:         rv = session->AsyncOpenCacheEntry(cacheKey, accessRequested, this);
    1:         if (NS_FAILED(rv)) return rv;
    1:         // we'll have to wait for the cache entry
    1:         *delayed = PR_TRUE;
    1:     }
    1:     else if (NS_SUCCEEDED(rv)) {
    1:         mCacheEntry->GetAccessGranted(&mCacheAccess);
29268:         LOG(("nsHttpChannel::OpenCacheEntry [this=%x grantedAccess=%d]", this, mCacheAccess));
    1:     }
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHttpChannel::OpenOfflineCacheEntryForWriting()
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("nsHttpChannel::OpenOfflineCacheEntryForWriting [this=%x]", this));
    1: 
    1:     // make sure we're not abusing this function
    1:     NS_PRECONDITION(!mOfflineCacheEntry, "cache entry already open");
    1: 
    1:     PRBool offline = gIOService->IsOffline();
    1:     if (offline) {
    1:         // only put things in the offline cache while online
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (mRequestHead.Method() != nsHttp::Get) {
    1:         // only cache complete documents offline
    1:         return NS_OK;
    1:     }
    1: 
23860:     // Don't cache byte range requests which are subranges, only cache 0-
23860:     // byte range requests.
23860:     if (IsSubRangeRequest(mRequestHead))
    1:         return NS_OK;
    1: 
    1:     nsCAutoString cacheKey;
20265:     GenerateCacheKey(mPostID, cacheKey);
    1: 
18430:     NS_ENSURE_TRUE(!mOfflineCacheClientID.IsEmpty(),
18430:                    NS_ERROR_NOT_AVAILABLE);
18430: 
    1:     nsCOMPtr<nsICacheSession> session;
 3947:     nsCOMPtr<nsICacheService> serv =
 3947:         do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
 3947:     if (NS_FAILED(rv)) return rv;
 3947: 
 3947:     rv = serv->CreateSession(mOfflineCacheClientID.get(),
 3947:                              nsICache::STORE_OFFLINE,
 3947:                              nsICache::STREAM_BASED,
 3947:                              getter_AddRefs(session));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = session->OpenCacheEntry(cacheKey, nsICache::ACCESS_READ_WRITE,
    1:                                  PR_FALSE, getter_AddRefs(mOfflineCacheEntry));
    1: 
    1:     if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION) {
    1:         // access to the cache entry has been denied (because the cache entry
    1:         // is probably in use by another channel).  Either the cache is being
    1:         // read from (we're offline) or it's being updated elsewhere.
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:         mOfflineCacheEntry->GetAccessGranted(&mOfflineCacheAccess);
    1:         LOG(("got offline cache entry [access=%x]\n", mOfflineCacheAccess));
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
20265: nsHttpChannel::GenerateCacheKey(PRUint32 postID, nsACString &cacheKey)
    1: {
19954:     cacheKey.Truncate();
19954: 
19954:     if (mLoadFlags & LOAD_ANONYMOUS) {
19954:       cacheKey.AssignLiteral("anon&");
19954:     }
19954: 
20265:     if (postID) {
    1:         char buf[32];
20265:         PR_snprintf(buf, sizeof(buf), "id=%x&", postID);
19954:         cacheKey.Append(buf);
19954:     }
19954: 
19954:     if (!cacheKey.IsEmpty()) {
19954:       cacheKey.AppendLiteral("uri=");
19954:     }
    1: 
    1:     // Strip any trailing #ref from the URL before using it as the key
19925:     const char *spec = mFallbackChannel ? mFallbackKey.get() : mSpec.get();
    1:     const char *p = strchr(spec, '#');
    1:     if (p)
    1:         cacheKey.Append(spec, p - spec);
    1:     else
    1:         cacheKey.Append(spec);
    1:     return NS_OK;
    1: }
    1: 
    1: // UpdateExpirationTime is called when a new response comes in from the server.
    1: // It updates the stored response-time and sets the expiration time on the
    1: // cache entry.  
    1: //
    1: // From section 13.2.4 of RFC2616, we compute expiration time as follows:
    1: //
    1: //    timeRemaining = freshnessLifetime - currentAge
    1: //    expirationTime = now + timeRemaining
    1: // 
    1: nsresult
    1: nsHttpChannel::UpdateExpirationTime()
    1: {
    1:     NS_ENSURE_TRUE(mResponseHead, NS_ERROR_FAILURE);
    1: 
14110:     nsresult rv;
14110: 
    1:     PRUint32 expirationTime = 0;
    1:     if (!mResponseHead->MustValidate()) {
    1:         PRUint32 freshnessLifetime = 0;
    1: 
    1:         rv = mResponseHead->ComputeFreshnessLifetime(&freshnessLifetime);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         if (freshnessLifetime > 0) {
    1:             PRUint32 now = NowInSeconds(), currentAge = 0;
    1: 
    1:             rv = mResponseHead->ComputeCurrentAge(now, mRequestTime, &currentAge); 
    1:             if (NS_FAILED(rv)) return rv;
    1: 
    1:             LOG(("freshnessLifetime = %u, currentAge = %u\n",
    1:                 freshnessLifetime, currentAge));
    1: 
    1:             if (freshnessLifetime > currentAge) {
    1:                 PRUint32 timeRemaining = freshnessLifetime - currentAge;
    1:                 // be careful... now + timeRemaining may overflow
    1:                 if (now + timeRemaining < now)
    1:                     expirationTime = PRUint32(-1);
    1:                 else
    1:                     expirationTime = now + timeRemaining;
    1:             }
    1:             else
    1:                 expirationTime = now;
    1:         }
    1:     }
14110: 
14110:     rv = mCacheEntry->SetExpirationTime(expirationTime);
14110:     NS_ENSURE_SUCCESS(rv, rv);
14110: 
14110:     if (mOfflineCacheEntry) {
14110:         rv = mOfflineCacheEntry->SetExpirationTime(expirationTime);
14110:         NS_ENSURE_SUCCESS(rv, rv);
14110:     }
14110: 
14110:     return NS_OK;
    1: }
    1: 
    1: // CheckCache is called from Connect after a cache entry has been opened for
    1: // this URL but before going out to net.  It's purpose is to set or clear the 
    1: // mCachedContentIsValid flag, and to configure an If-Modified-Since request
    1: // if validation is required.
    1: nsresult
    1: nsHttpChannel::CheckCache()
    1: {
    1:     nsresult rv = NS_OK;
    1: 
29268:     LOG(("nsHTTPChannel::CheckCache enter [this=%x entry=%x access=%d]",
29268:         this, mCacheEntry.get(), mCacheAccess));
    1:     
    1:     // Be pessimistic: assume the cache entry has no useful data.
    1:     mCachedContentIsValid = PR_FALSE;
    1: 
    1:     // Don't proceed unless we have opened a cache entry for reading.
    1:     if (!mCacheEntry || !(mCacheAccess & nsICache::ACCESS_READ))
    1:         return NS_OK;
    1: 
    1:     nsXPIDLCString buf;
    1: 
    1:     // Get the method that was used to generate the cached response
    1:     rv = mCacheEntry->GetMetaDataElement("request-method", getter_Copies(buf));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsHttpAtom method = nsHttp::ResolveAtom(buf);
    1:     if (method == nsHttp::Head) {
    1:         // The cached response does not contain an entity.  We can only reuse
    1:         // the response if the current request is also HEAD.
    1:         if (mRequestHead.Method() != nsHttp::Head)
    1:             return NS_OK;
    1:     }
    1:     buf.Adopt(0);
    1: 
    1:     // We'll need this value in later computations...
    1:     PRUint32 lastModifiedTime;
    1:     rv = mCacheEntry->GetLastModified(&lastModifiedTime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Determine if this is the first time that this cache entry
    1:     // has been accessed during this session.
    1:     PRBool fromPreviousSession =
    1:             (gHttpHandler->SessionStartTime() > lastModifiedTime);
    1: 
    1:     // Get the cached HTTP response headers
    1:     rv = mCacheEntry->GetMetaDataElement("response-head", getter_Copies(buf));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Parse the cached HTTP response headers
    1:     NS_ASSERTION(!mCachedResponseHead, "memory leak detected");
    1:     mCachedResponseHead = new nsHttpResponseHead();
    1:     if (!mCachedResponseHead)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     rv = mCachedResponseHead->Parse((char *) buf.get());
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     buf.Adopt(0);
    1: 
 3239:     // Don't bother to validate items that are read-only,
14110:     // unless they are read-only because of INHIBIT_CACHING or because
14110:     // we're updating the offline cache.
19925:     // Don't bother to validate if this is a fallback entry.
22721:     if (!mCacheForOfflineUse &&
22721:         (mLoadedFromApplicationCache ||
 3239:          (mCacheAccess == nsICache::ACCESS_READ &&
22721:           !(mLoadFlags & INHIBIT_CACHING)) ||
22721:          mFallbackChannel)) {
    1:         mCachedContentIsValid = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     PRUint16 isCachedRedirect = mCachedResponseHead->Status()/100 == 3;
    1: 
    1:     if (method != nsHttp::Head && !isCachedRedirect) {
    1:         // If the cached content-length is set and it does not match the data
    1:         // size of the cached content, then the cached response is partial...
    1:         // either we need to issue a byte range request or we need to refetch
    1:         // the entire document.
    1:         nsInt64 contentLength = mCachedResponseHead->ContentLength();
    1:         if (contentLength != nsInt64(-1)) {
    1:             PRUint32 size;
    1:             rv = mCacheEntry->GetDataSize(&size);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             if (nsInt64(size) != contentLength) {
    1:                 LOG(("Cached data size does not match the Content-Length header "
    1:                      "[content-length=%lld size=%u]\n", PRInt64(contentLength), size));
    1:                 if ((nsInt64(size) < contentLength) && mCachedResponseHead->IsResumable()) {
    1:                     // looks like a partial entry.
    1:                     rv = SetupByteRangeRequest(size);
    1:                     NS_ENSURE_SUCCESS(rv, rv);
    1:                     mCachedContentIsPartial = PR_TRUE;
    1:                 }
    1:                 return NS_OK;
    1:             }
    1:         }
    1:     }
    1: 
    1:     PRBool doValidation = PR_FALSE;
31786:     PRBool canAddImsHeader = PR_TRUE;
    1: 
34058:     mCustomConditionalRequest = 
34058:         mRequestHead.PeekHeader(nsHttp::If_Modified_Since) ||
34058:         mRequestHead.PeekHeader(nsHttp::If_None_Match) ||
34058:         mRequestHead.PeekHeader(nsHttp::If_Unmodified_Since) ||
34058:         mRequestHead.PeekHeader(nsHttp::If_Match) ||
34058:         mRequestHead.PeekHeader(nsHttp::If_Range);
    1: 
    1:     // If the LOAD_FROM_CACHE flag is set, any cached data can simply be used.
    1:     if (mLoadFlags & LOAD_FROM_CACHE) {
    1:         LOG(("NOT validating based on LOAD_FROM_CACHE load flag\n"));
    1:         doValidation = PR_FALSE;
    1:     }
    1:     // If the VALIDATE_ALWAYS flag is set, any cached data won't be used until
    1:     // it's revalidated with the server.
    1:     else if (mLoadFlags & VALIDATE_ALWAYS) {
    1:         LOG(("Validating based on VALIDATE_ALWAYS load flag\n"));
    1:         doValidation = PR_TRUE;
    1:     }
    1:     // Even if the VALIDATE_NEVER flag is set, there are still some cases in
    1:     // which we must validate the cached response with the server.
    1:     else if (mLoadFlags & VALIDATE_NEVER) {
    1:         LOG(("VALIDATE_NEVER set\n"));
    1:         // if no-store or if no-cache and ssl, validate cached response (see
    1:         // bug 112564 for an explanation of this logic)
    1:         if (mCachedResponseHead->NoStore() ||
    1:            (mCachedResponseHead->NoCache() && mConnectionInfo->UsingSSL())) {
    1:             LOG(("Validating based on (no-store || (no-cache && ssl)) logic\n"));
    1:             doValidation = PR_TRUE;
    1:         }
    1:         else {
    1:             LOG(("NOT validating based on VALIDATE_NEVER load flag\n"));
    1:             doValidation = PR_FALSE;
    1:         }
    1:     }
    1:     // check if validation is strictly required...
    1:     else if (mCachedResponseHead->MustValidate()) {
    1:         LOG(("Validating based on MustValidate() returning TRUE\n"));
    1:         doValidation = PR_TRUE;
    1:     }
    1: 
    1:     else if (ResponseWouldVary()) {
    1:         LOG(("Validating based on Vary headers returning TRUE\n"));
31786:         canAddImsHeader = PR_FALSE;
    1:         doValidation = PR_TRUE;
    1:     }
29268:     
29268:     else if (MustValidateBasedOnQueryUrl()) {
29268:         LOG(("Validating based on RFC 2616 section 13.9 "
29268:              "(query-url w/o explicit expiration-time)\n"));
29268:         doValidation = PR_TRUE;
29268:     }
    1:     // Check if the cache entry has expired...
    1:     else {
    1:         PRUint32 time = 0; // a temporary variable for storing time values...
    1: 
    1:         rv = mCacheEntry->GetExpirationTime(&time);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         if (NowInSeconds() <= time)
    1:             doValidation = PR_FALSE;
    1:         else if (mCachedResponseHead->MustValidateIfExpired())
    1:             doValidation = PR_TRUE;
    1:         else if (mLoadFlags & VALIDATE_ONCE_PER_SESSION) {
    1:             // If the cached response does not include expiration infor-
    1:             // mation, then we must validate the response, despite whether
    1:             // or not this is the first access this session.  This behavior
    1:             // is consistent with existing browsers and is generally expected
    1:             // by web authors.
    1:             rv = mCachedResponseHead->ComputeFreshnessLifetime(&time);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             if (time == 0)
    1:                 doValidation = PR_TRUE;
    1:             else
    1:                 doValidation = fromPreviousSession;
    1:         }
    1:         else
    1:             doValidation = PR_TRUE;
    1: 
    1:         LOG(("%salidating based on expiration time\n", doValidation ? "V" : "Not v"));
    1:     }
    1: 
34058:     if (!doValidation && mRequestHead.PeekHeader(nsHttp::If_Match) &&
34058:         (method == nsHttp::Get || method == nsHttp::Head)) {
34058:         const char *requestedETag, *cachedETag;
34058:         cachedETag = mCachedResponseHead->PeekHeader(nsHttp::ETag);
34058:         requestedETag = mRequestHead.PeekHeader(nsHttp::If_Match);
34058:         if (cachedETag && (!strncmp(cachedETag, "W/", 2) ||
34058:             strcmp(requestedETag, cachedETag))) {
34058:             // User has defined If-Match header, if the cached entry is not 
34058:             // matching the provided header value or the cached ETag is weak,
34058:             // force validation.
34058:             doValidation = PR_TRUE;
34058:         }
34058:     }
34058: 
    1:     if (!doValidation) {
    1:         //
    1:         // Check the authorization headers used to generate the cache entry.
    1:         // We must validate the cache entry if:
    1:         //
    1:         // 1) the cache entry was generated prior to this session w/
    1:         //    credentials (see bug 103402).
    1:         // 2) the cache entry was generated w/o credentials, but would now
    1:         //    require credentials (see bug 96705).
    1:         //
    1:         // NOTE: this does not apply to proxy authentication.
    1:         //
    1:         mCacheEntry->GetMetaDataElement("auth", getter_Copies(buf));
    1:         doValidation =
    1:             (fromPreviousSession && !buf.IsEmpty()) ||
    1:             (buf.IsEmpty() && mRequestHead.PeekHeader(nsHttp::Authorization));
    1:     }
    1: 
    1:     if (!doValidation) {
    1:         // Sites redirect back to the original URI after setting a session/tracking
    1:         // cookie. In such cases, force revalidation so that we hit the net and do not
    1:         // cycle thru cached responses.
    1:         if (isCachedRedirect && mRequestHead.PeekHeader(nsHttp::Cookie))
    1:             doValidation = PR_TRUE;
    1:     }
    1: 
    1:     mCachedContentIsValid = !doValidation;
    1: 
    1:     if (doValidation) {
    1:         //
    1:         // now, we are definitely going to issue a HTTP request to the server.
    1:         // make it conditional if possible.
    1:         //
    1:         // do not attempt to validate no-store content, since servers will not
    1:         // expect it to be cached.  (we only keep it in our cache for the
    1:         // purposes of back/forward, etc.)
    1:         //
    1:         // the request method MUST be either GET or HEAD (see bug 175641).
    1:         //
34058:         // do not override conditional headers when consumer has defined its own
    1:         if (!mCachedResponseHead->NoStore() &&
    1:             (mRequestHead.Method() == nsHttp::Get ||
34058:              mRequestHead.Method() == nsHttp::Head) &&
34058:              !mCustomConditionalRequest) {
    1:             const char *val;
    1:             // Add If-Modified-Since header if a Last-Modified was given
31786:             // and we are allowed to do this (see bugs 510359 and 269303)
31786:             if (canAddImsHeader) {
    1:                 val = mCachedResponseHead->PeekHeader(nsHttp::Last_Modified);
    1:                 if (val)
    1:                     mRequestHead.SetHeader(nsHttp::If_Modified_Since,
    1:                                            nsDependentCString(val));
31786:             }
    1:             // Add If-None-Match header if an ETag was given in the response
    1:             val = mCachedResponseHead->PeekHeader(nsHttp::ETag);
    1:             if (val)
    1:                 mRequestHead.SetHeader(nsHttp::If_None_Match,
    1:                                        nsDependentCString(val));
    1:         }
    1:     }
    1: 
29268:     LOG(("nsHTTPChannel::CheckCache exit [this=%x doValidation=%d]\n", this, doValidation));
    1:     return NS_OK;
    1: }
    1: 
29268: PRBool
29268: nsHttpChannel::MustValidateBasedOnQueryUrl()
29268: {
29268:     // RFC 2616, section 13.9 states that GET-requests with a query-url
29268:     // MUST NOT be treated as fresh unless the server explicitly provides
29268:     // an expiration-time in the response. See bug #468594
29268:     // Section 13.2.1 (6th paragraph) defines "explicit expiration time"
29268:     if (mRequestHead.Method() == nsHttp::Get)
29268:     {
29268:         nsCAutoString query;
29268:         nsCOMPtr<nsIURL> url = do_QueryInterface(mURI);
29268:         nsresult rv = url->GetQuery(query);
29268:         if (NS_SUCCEEDED(rv) && !query.IsEmpty()) {
29268:             PRUint32 tmp; // we don't need the value, just whether it's set
29268:             rv = mCachedResponseHead->GetExpiresValue(&tmp);
29268:             if (NS_FAILED(rv)) {
29268:                 rv = mCachedResponseHead->GetMaxAgeValue(&tmp);
29268:                 if (NS_FAILED(rv)) {
29268:                     return PR_TRUE;
29268:                 }
29268:             }
29268:         }
29268:     }
29268:     return PR_FALSE;
29268: }
29268: 
    1: 
    1: nsresult
    1: nsHttpChannel::ShouldUpdateOfflineCacheEntry(PRBool *shouldCacheForOfflineUse)
    1: {
    1:     *shouldCacheForOfflineUse = PR_FALSE;
    1: 
    1:     if (!mOfflineCacheEntry) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // if we're updating the cache entry, update the offline cache entry too
    1:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE)) {
    1:         *shouldCacheForOfflineUse = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     // if there's nothing in the offline cache, add it
    1:     if (mOfflineCacheEntry && (mOfflineCacheAccess == nsICache::ACCESS_WRITE)) {
    1:         *shouldCacheForOfflineUse = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     // if the document is newer than the offline entry, update it
    1:     PRUint32 docLastModifiedTime;
    1:     nsresult rv = mResponseHead->GetLastModifiedValue(&docLastModifiedTime);
    1:     if (NS_FAILED(rv)) {
    1:         *shouldCacheForOfflineUse = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     PRUint32 offlineLastModifiedTime;
    1:     rv = mOfflineCacheEntry->GetLastModified(&offlineLastModifiedTime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (docLastModifiedTime > offlineLastModifiedTime) {
    1:         *shouldCacheForOfflineUse = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // If the data in the cache hasn't expired, then there's no need to
    1: // talk with the server, not even to do an if-modified-since.  This
    1: // method creates a stream from the cache, synthesizing all the various
    1: // channel-related events.
    1: nsresult
    1: nsHttpChannel::ReadFromCache()
    1: {
    1:     nsresult rv;
    1: 
    1:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_FAILURE);
    1:     NS_ENSURE_TRUE(mCachedContentIsValid, NS_ERROR_FAILURE);
    1: 
    1:     LOG(("nsHttpChannel::ReadFromCache [this=%x] "
    1:          "Using cached copy of: %s\n", this, mSpec.get()));
    1: 
    1:     if (mCachedResponseHead) {
    1:         NS_ASSERTION(!mResponseHead, "memory leak");
    1:         mResponseHead = mCachedResponseHead;
    1:         mCachedResponseHead = 0;
    1:     }
    1: 
    1:     // if we don't already have security info, try to get it from the cache 
    1:     // entry. there are two cases to consider here: 1) we are just reading
    1:     // from the cache, or 2) this may be due to a 304 not modified response,
    1:     // in which case we could have security info from a socket transport.
    1:     if (!mSecurityInfo)
    1:         mCacheEntry->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
    1: 
    1:     if ((mCacheAccess & nsICache::ACCESS_WRITE) && !mCachedContentIsPartial) {
    1:         // We have write access to the cache, but we don't need to go to the
    1:         // server to validate at this time, so just mark the cache entry as
    1:         // valid in order to allow others access to this cache entry.
    1:         mCacheEntry->MarkValid();
    1:     }
    1: 
    1:     // if this is a cached redirect, we must process the redirect asynchronously
    1:     // since AsyncOpen may not have returned yet.  Make sure there is a Location
    1:     // header, otherwise we'll have to treat this like a normal 200 response.
    1:     if (mResponseHead && (mResponseHead->Status() / 100 == 3) 
    1:                       && (mResponseHead->PeekHeader(nsHttp::Location)))
    1:         return AsyncCall(&nsHttpChannel::HandleAsyncRedirect);
    1: 
    1:     // have we been configured to skip reading from the cache?
    1:     if ((mLoadFlags & LOAD_ONLY_IF_MODIFIED) && !mCachedContentIsPartial) {
    1:         // if offline caching has been requested and the offline cache needs
    1:         // updating, complete the call even if the main cache entry is
    1:         // up-to-date
    1:         PRBool shouldUpdateOffline;
    1:         if (!mCacheForOfflineUse ||
    1:             NS_FAILED(ShouldUpdateOfflineCacheEntry(&shouldUpdateOffline)) ||
    1:             !shouldUpdateOffline) {
    1: 
    1:             LOG(("skipping read from cache based on LOAD_ONLY_IF_MODIFIED "
    1:                  "load flag\n"));
    1:             return AsyncCall(&nsHttpChannel::HandleAsyncNotModified);
    1:         }
    1:     }
    1: 
    1:     // open input stream for reading...
    1:     nsCOMPtr<nsIInputStream> stream;
    1:     rv = mCacheEntry->OpenInputStream(0, getter_AddRefs(stream));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = nsInputStreamPump::Create(getter_AddRefs(mCachePump),
    1:                                    stream, nsInt64(-1), nsInt64(-1), 0, 0,
    1:                                    PR_TRUE);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return mCachePump->AsyncRead(this, mListenerContext);
    1: }
    1: 
    1: void
19028: nsHttpChannel::CloseCacheEntry(PRBool doomOnFailure)
    1: {
    1:     if (!mCacheEntry)
    1:         return;
    1: 
    1:     LOG(("nsHttpChannel::CloseCacheEntry [this=%x]", this));
    1: 
    1:     // If we have begun to create or replace a cache entry, and that cache
    1:     // entry is not complete and not resumable, then it needs to be doomed.
    1:     // Otherwise, CheckCache will make the mistake of thinking that the
    1:     // partial cache entry is complete.
    1: 
    1:     PRBool doom = PR_FALSE;
    1:     if (mInitedCacheEntry) {
    1:         NS_ASSERTION(mResponseHead, "oops");
19028:         if (NS_FAILED(mStatus) && doomOnFailure &&
19028:             (mCacheAccess & nsICache::ACCESS_WRITE) &&
    1:             !mResponseHead->IsResumable())
    1:             doom = PR_TRUE;
    1:     }
    1:     else if (mCacheAccess == nsICache::ACCESS_WRITE)
    1:         doom = PR_TRUE;
    1: 
    1:     if (doom) {
    1:         LOG(("  dooming cache entry!!"));
    1:         mCacheEntry->Doom();
    1:     }
    1: 
    1:     if (mCachedResponseHead) {
    1:         delete mCachedResponseHead;
    1:         mCachedResponseHead = 0;
    1:     }
    1: 
    1:     mCachePump = 0;
    1:     mCacheEntry = 0;
    1:     mCacheAccess = 0;
    1:     mInitedCacheEntry = PR_FALSE;
    1: }
    1: 
    1: 
    1: void
    1: nsHttpChannel::CloseOfflineCacheEntry()
    1: {
    1:     if (!mOfflineCacheEntry)
    1:         return;
    1: 
    1:     LOG(("nsHttpChannel::CloseOfflineCacheEntry [this=%x]", this));
    1: 
    1:     if (NS_FAILED(mStatus)) {
    1:         mOfflineCacheEntry->Doom();
    1:     }
19925:     else {
19925:         PRBool succeeded;
19925:         if (NS_SUCCEEDED(GetRequestSucceeded(&succeeded)) && !succeeded)
19925:             mOfflineCacheEntry->Doom();
19925:     }
    1: 
    1:     mOfflineCacheEntry = 0;
    1:     mOfflineCacheAccess = 0;
19925: 
19925:     if (mCachingOpportunistically) {
19925:         nsCOMPtr<nsIApplicationCacheService> appCacheService =
19925:             do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
19925:         if (appCacheService) {
19925:             nsCAutoString cacheKey;
20265:             GenerateCacheKey(mPostID, cacheKey);
19925:             appCacheService->CacheOpportunistically(mApplicationCache,
19925:                                                     cacheKey);
19925:         }
19925:     }
    1: }
    1: 
    1: 
    1: // Initialize the cache entry for writing.
    1: //  - finalize storage policy
    1: //  - store security info
    1: //  - update expiration time
    1: //  - store headers and other meta data
    1: nsresult
    1: nsHttpChannel::InitCacheEntry()
    1: {
    1:     nsresult rv;
    1: 
    1:     NS_ENSURE_TRUE(mCacheEntry, NS_ERROR_UNEXPECTED);
    1:     // if only reading, nothing to be done here.
    1:     if (mCacheAccess == nsICache::ACCESS_READ)
    1:         return NS_OK;
    1: 
    1:     // Don't cache the response again if already cached...
    1:     if (mCachedContentIsValid)
    1:         return NS_OK;
    1: 
    1:     LOG(("nsHttpChannel::InitCacheEntry [this=%x entry=%x]\n",
    1:         this, mCacheEntry.get()));
    1: 
    1:     // The no-store directive within the 'Cache-Control:' header indicates
    1:     // that we must not store the response in a persistent cache.
    1:     if (mResponseHead->NoStore())
    1:         mLoadFlags |= INHIBIT_PERSISTENT_CACHING;
    1: 
 8464:     // Only cache SSL content on disk if the server sent a
 8464:     // Cache-Control: public header, or if the user set the pref
 8464:     if (!gHttpHandler->CanCacheAllSSLContent() &&
 8464:         mConnectionInfo->UsingSSL() && !mResponseHead->CacheControlPublic())
 8464:         mLoadFlags |= INHIBIT_PERSISTENT_CACHING;
 8464: 
    1:     if (mLoadFlags & INHIBIT_PERSISTENT_CACHING) {
    1:         rv = mCacheEntry->SetStoragePolicy(nsICache::STORE_IN_MEMORY);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     // Set the expiration time for this cache entry
    1:     rv = UpdateExpirationTime();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = AddCacheEntryHeaders(mCacheEntry);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     mInitedCacheEntry = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHttpChannel::InitOfflineCacheEntry()
    1: {
    1:     if (!mOfflineCacheEntry) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (mResponseHead->NoStore()) {
    1:         CloseOfflineCacheEntry();
    1: 
    1:         return NS_OK;
    1:     }
    1: 
14110:     // This entry's expiration time should match the main entry's expiration
14110:     // time.  UpdateExpirationTime() will keep it in sync once the offline
14110:     // cache entry has been created.
14110:     if (mCacheEntry) {
14110:         PRUint32 expirationTime;
14110:         nsresult rv = mCacheEntry->GetExpirationTime(&expirationTime);
14110:         NS_ENSURE_SUCCESS(rv, rv);
14110: 
14110:         mOfflineCacheEntry->SetExpirationTime(expirationTime);
14110:     }
14110: 
    1:     return AddCacheEntryHeaders(mOfflineCacheEntry);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHttpChannel::AddCacheEntryHeaders(nsICacheEntryDescriptor *entry)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Store secure data in memory only
    1:     if (mSecurityInfo)
    1:         entry->SetSecurityInfo(mSecurityInfo);
    1: 
    1:     // Store the HTTP request method with the cache entry so we can distinguish
    1:     // for example GET and HEAD responses.
    1:     rv = entry->SetMetaDataElement("request-method",
    1:                                    mRequestHead.Method().get());
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Store the HTTP authorization scheme used if any...
    1:     rv = StoreAuthorizationMetaData(entry);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // Iterate over the headers listed in the Vary response header, and
    1:     // store the value of the corresponding request header so we can verify
    1:     // that it has not varied when we try to re-use the cached response at
    1:     // a later time.  Take care not to store "Cookie" headers though.  We
    1:     // take care of "Vary: cookie" in ResponseWouldVary.
    1:     //
    1:     // NOTE: if "Vary: accept, cookie", then we will store the "accept" header
    1:     // in the cache.  we could try to avoid needlessly storing the "accept"
    1:     // header in this case, but it doesn't seem worth the extra code to perform
    1:     // the check.
    1:     {
    1:         nsCAutoString buf, metaKey;
    1:         mResponseHead->GetHeader(nsHttp::Vary, buf);
    1:         if (!buf.IsEmpty()) {
    1:             NS_NAMED_LITERAL_CSTRING(prefix, "request-");
    1:            
    1:             char *val = buf.BeginWriting(); // going to munge buf
    1:             char *token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
    1:             while (token) {
    1:                 if ((*token != '*') && (PL_strcasecmp(token, "cookie") != 0)) {
    1:                     nsHttpAtom atom = nsHttp::ResolveAtom(token);
    1:                     const char *requestVal = mRequestHead.PeekHeader(atom);
    1:                     if (requestVal) {
    1:                         // build cache meta data key and set meta data element...
    1:                         metaKey = prefix + nsDependentCString(token);
    1:                         entry->SetMetaDataElement(metaKey.get(), requestVal);
    1:                     }
    1:                 }
    1:                 token = nsCRT::strtok(val, NS_HTTP_HEADER_SEPS, &val);
    1:             }
    1:         }
    1:     }
    1: 
    1: 
    1:     // Store the received HTTP head with the cache entry as an element of
    1:     // the meta data.
    1:     nsCAutoString head;
    1:     mResponseHead->Flatten(head, PR_TRUE);
    1:     rv = entry->SetMetaDataElement("response-head", head.get());
    1: 
    1:     return rv;
    1: }
    1: 
21234: inline void
21234: GetAuthType(const char *challenge, nsCString &authType)
21234: {
21234:     const char *p;
21234: 
21234:     // get the challenge type
21234:     if ((p = strchr(challenge, ' ')) != nsnull)
21234:         authType.Assign(challenge, p - challenge);
21234:     else
21234:         authType.Assign(challenge);
21234: }
21234: 
    1: nsresult
    1: nsHttpChannel::StoreAuthorizationMetaData(nsICacheEntryDescriptor *entry)
    1: {
    1:     // Not applicable to proxy authorization...
    1:     const char *val = mRequestHead.PeekHeader(nsHttp::Authorization);
21234:     if (!val)
21234:         return NS_OK;
21234: 
    1:     // eg. [Basic realm="wally world"]
21234:     nsCAutoString buf;
21234:     GetAuthType(val, buf);
    1:     return entry->SetMetaDataElement("auth", buf.get());
    1: }
    1: 
    1: // Finalize the cache entry
    1: //  - may need to rewrite response headers if any headers changed
    1: //  - may need to recalculate the expiration time if any headers changed
    1: //  - called only for freshly written cache entries
    1: nsresult
    1: nsHttpChannel::FinalizeCacheEntry()
    1: {
    1:     LOG(("nsHttpChannel::FinalizeCacheEntry [this=%x]\n", this));
    1: 
    1:     if (mResponseHead && mResponseHeadersModified) {
    1:         // Set the expiration time for this cache entry
    1:         nsresult rv = UpdateExpirationTime();
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: // Open an output stream to the cache entry and insert a listener tee into
    1: // the chain of response listeners.
    1: nsresult
    1: nsHttpChannel::InstallCacheListener(PRUint32 offset)
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("Preparing to write data into the cache [uri=%s]\n", mSpec.get()));
    1: 
    1:     NS_ASSERTION(mCacheEntry, "no cache entry");
    1:     NS_ASSERTION(mListener, "no listener");
    1: 
    1:     nsCOMPtr<nsIOutputStream> out;
    1:     rv = mCacheEntry->OpenOutputStream(offset, getter_AddRefs(out));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // XXX disk cache does not support overlapped i/o yet
    1: #if 0
    1:     // Mark entry valid inorder to allow simultaneous reading...
    1:     rv = mCacheEntry->MarkValid();
    1:     if (NS_FAILED(rv)) return rv;
    1: #endif
    1: 
    1:     nsCOMPtr<nsIStreamListenerTee> tee =
    1:         do_CreateInstance(kStreamListenerTeeCID, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
35006:     rv = tee->Init(mListener, out, nsnull);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     mListener = tee;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::InstallOfflineCacheListener()
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("Preparing to write data into the offline cache [uri=%s]\n",
    1:          mSpec.get()));
    1: 
    1:     NS_ASSERTION(mOfflineCacheEntry, "no offline cache entry");
    1:     NS_ASSERTION(mListener, "no listener");
    1: 
    1:     nsCOMPtr<nsIOutputStream> out;
    1:     rv = mOfflineCacheEntry->OpenOutputStream(0, getter_AddRefs(out));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsCOMPtr<nsIStreamListenerTee> tee =
    1:         do_CreateInstance(kStreamListenerTeeCID, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
35006:     rv = tee->Init(mListener, out, nsnull);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     mListener = tee;
    1: 
    1:     return NS_OK;
    1: }
    1: 
16322: void
16322: nsHttpChannel::ClearBogusContentEncodingIfNeeded()
16322: {
16322:     // For .gz files, apache sends both a Content-Type: application/x-gzip
16322:     // as well as Content-Encoding: gzip, which is completely wrong.  In
16322:     // this case, we choose to ignore the rogue Content-Encoding header. We
16322:     // must do this early on so as to prevent it from being seen up stream.
16322:     // The same problem exists for Content-Encoding: compress in default
16322:     // Apache installs.
16322:     if (mResponseHead->HasHeaderValue(nsHttp::Content_Encoding, "gzip") && (
16322:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP) ||
16322:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP2) ||
16322:         mResponseHead->ContentType().EqualsLiteral(APPLICATION_GZIP3))) {
16322:         // clear the Content-Encoding header
16322:         mResponseHead->ClearHeader(nsHttp::Content_Encoding);
16322:     }
16322:     else if (mResponseHead->HasHeaderValue(nsHttp::Content_Encoding, "compress") && (
16322:              mResponseHead->ContentType().EqualsLiteral(APPLICATION_COMPRESS) ||
16322:              mResponseHead->ContentType().EqualsLiteral(APPLICATION_COMPRESS2))) {
16322:         // clear the Content-Encoding header
16322:         mResponseHead->ClearHeader(nsHttp::Content_Encoding);
16322:     }
16322: }
16322: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel <redirect>
    1: //-----------------------------------------------------------------------------
    1: 
20261: static PLDHashOperator
    1: CopyProperties(const nsAString& aKey, nsIVariant *aData, void *aClosure)
    1: {
 3233:     nsIWritablePropertyBag* bag = static_cast<nsIWritablePropertyBag*>
 3233:                                              (aClosure);
    1:     bag->SetProperty(aKey, aData);
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::SetupReplacementChannel(nsIURI       *newURI, 
    1:                                        nsIChannel   *newChannel,
14455:                                        PRBool        preserveMethod)
    1: {
    1:     PRUint32 newLoadFlags = mLoadFlags | LOAD_REPLACE;
    1:     // if the original channel was using SSL and this channel is not using
    1:     // SSL, then no need to inhibit persistent caching.  however, if the
    1:     // original channel was not using SSL and has INHIBIT_PERSISTENT_CACHING
    1:     // set, then allow the flag to apply to the redirected channel as well.
    1:     // since we force set INHIBIT_PERSISTENT_CACHING on all HTTPS channels,
    1:     // we only need to check if the original channel was using SSL.
    1:     if (mConnectionInfo->UsingSSL())
    1:         newLoadFlags &= ~INHIBIT_PERSISTENT_CACHING;
    1: 
21311:     // Do not pass along LOAD_CHECK_OFFLINE_CACHE
21311:     newLoadFlags &= ~LOAD_CHECK_OFFLINE_CACHE;
21311: 
    1:     newChannel->SetLoadGroup(mLoadGroup); 
    1:     newChannel->SetNotificationCallbacks(mCallbacks);
    1:     newChannel->SetLoadFlags(newLoadFlags);
    1: 
    1:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(newChannel);
    1:     if (!httpChannel)
    1:         return NS_OK; // no other options to set
    1: 
    1:     if (preserveMethod) {
35023:         nsCOMPtr<nsIUploadChannel> uploadChannel =
35023:             do_QueryInterface(httpChannel);
35023:         nsCOMPtr<nsIUploadChannel2> uploadChannel2 =
35023:             do_QueryInterface(httpChannel);
35023:         if (mUploadStream && (uploadChannel2 || uploadChannel)) {
    1:             // rewind upload stream
    1:             nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
    1:             if (seekable)
    1:                 seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
    1: 
    1:             // replicate original call to SetUploadStream...
35023:             if (uploadChannel2) {
    1:                 const char *ctype = mRequestHead.PeekHeader(nsHttp::Content_Type);
32329:                 if (!ctype)
32329:                     ctype = "";
    1:                 const char *clen  = mRequestHead.PeekHeader(nsHttp::Content_Length);
32329:                 if (clen)
35023:                     uploadChannel2->ExplicitSetUploadStream(
32329:                         mUploadStream,
    1:                         nsDependentCString(ctype),
32329:                         nsCRT::atoll(clen),
32329:                         nsDependentCString(mRequestHead.Method()),
32329:                         mUploadStreamHasHeaders);
32329:             }
35023:             else {
35023:                 if (mUploadStreamHasHeaders)
35023:                     uploadChannel->SetUploadStream(mUploadStream, EmptyCString(),
35023:                                                    -1);
35023:                 else {
35023:                     const char *ctype =
35023:                         mRequestHead.PeekHeader(nsHttp::Content_Type);
35023:                     const char *clen =
35023:                         mRequestHead.PeekHeader(nsHttp::Content_Length);
35023:                     if (!ctype) {
35023:                         ctype = "application/octet-stream";
35023:                     }
35023:                     if (clen) {
35023:                         uploadChannel->SetUploadStream(mUploadStream,
35023:                                                        nsDependentCString(ctype),
35023:                                                        atoi(clen));
35023:                     }
35023:                 }
35023:             }
35023:         }
32329:         // since preserveMethod is true, we need to ensure that the appropriate 
32329:         // request method gets set on the channel, regardless of whether or not 
32329:         // we set the upload stream above. This means SetRequestMethod() will
32329:         // be called twice if ExplicitSetUploadStream() gets called above.
32329: 
32114:         httpChannel->SetRequestMethod(nsDependentCString(mRequestHead.Method()));
    1:     }
    1:     // convey the referrer if one was used for this channel to the next one
    1:     if (mReferrer)
    1:         httpChannel->SetReferrer(mReferrer);
    1:     // convey the mAllowPipelining flag
    1:     httpChannel->SetAllowPipelining(mAllowPipelining);
    1:     // convey the new redirection limit
    1:     httpChannel->SetRedirectionLimit(mRedirectionLimit - 1);
    1: 
    1:     nsCOMPtr<nsIHttpChannelInternal> httpInternal = do_QueryInterface(newChannel);
    1:     if (httpInternal) {
    1:         // update the DocumentURI indicator since we are being redirected.
    1:         // if this was a top-level document channel, then the new channel
    1:         // should have its mDocumentURI point to newURI; otherwise, we
    1:         // just need to pass along our mDocumentURI to the new channel.
    1:         if (newURI && (mURI == mDocumentURI))
    1:             httpInternal->SetDocumentURI(newURI);
    1:         else
    1:             httpInternal->SetDocumentURI(mDocumentURI);
    1:     } 
    1:     
    1:     // convey the mApplyConversion flag (bug 91862)
    1:     nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(httpChannel);
    1:     if (encodedChannel)
    1:         encodedChannel->SetApplyConversion(mApplyConversion);
    1: 
    1:     // transfer the resume information
    1:     if (mResuming) {
    1:         nsCOMPtr<nsIResumableChannel> resumableChannel(do_QueryInterface(newChannel));
    1:         if (!resumableChannel) {
    1:             NS_WARNING("Got asked to resume, but redirected to non-resumable channel!");
    1:             return NS_ERROR_NOT_RESUMABLE;
    1:         }
    1:         resumableChannel->ResumeAt(mStartPos, mEntityID);
    1:     }
    1: 
19925:     // transfer application cache information
21311:     nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
19925:         do_QueryInterface(newChannel);
21311:     if (appCacheChannel) {
21311:         appCacheChannel->SetApplicationCache(mApplicationCache);
21311:         appCacheChannel->SetInheritApplicationCache(mInheritApplicationCache);
21311:         // We purposely avoid transfering mChooseApplicationCache.
19925:     }
19925: 
    1:     // transfer any properties
    1:     nsCOMPtr<nsIWritablePropertyBag> bag(do_QueryInterface(newChannel));
    1:     if (bag)
    1:         mPropertyHash.EnumerateRead(CopyProperties, bag.get());
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::ProcessRedirection(PRUint32 redirectType)
    1: {
    1:     LOG(("nsHttpChannel::ProcessRedirection [this=%x type=%u]\n",
    1:         this, redirectType));
    1: 
    1:     const char *location = mResponseHead->PeekHeader(nsHttp::Location);
    1: 
    1:     // if a location header was not given, then we can't perform the redirect,
    1:     // so just carry on as though this were a normal response.
    1:     if (!location)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // make sure non-ASCII characters in the location header are escaped.
    1:     nsCAutoString locationBuf;
    1:     if (NS_EscapeURL(location, -1, esc_OnlyNonASCII, locationBuf))
    1:         location = locationBuf.get();
    1: 
    1:     if (mRedirectionLimit == 0) {
    1:         LOG(("redirection limit reached!\n"));
    1:         // this error code is fatal, and should be conveyed to our listener.
    1:         Cancel(NS_ERROR_REDIRECT_LOOP);
    1:         return NS_ERROR_REDIRECT_LOOP;
    1:     }
    1: 
    1:     LOG(("redirecting to: %s [redirection-limit=%u]\n",
    1:         location, PRUint32(mRedirectionLimit)));
    1: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsIChannel> newChannel;
    1:     nsCOMPtr<nsIURI> newURI;
    1: 
    1:     // create a new URI using the location header and the current URL
    1:     // as a base...
    1:     nsCOMPtr<nsIIOService> ioService;
    1:     rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // the new uri should inherit the origin charset of the current uri
    1:     nsCAutoString originCharset;
    1:     rv = mURI->GetOriginCharset(originCharset);
    1:     if (NS_FAILED(rv))
    1:         originCharset.Truncate();
    1: 
    1:     rv = ioService->NewURI(nsDependentCString(location), originCharset.get(), mURI,
    1:                            getter_AddRefs(newURI));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
25139:     if (mApplicationCache) {
25139:         // if we are redirected to a different origin check if there is a fallback
25139:         // cache entry to fall back to. we don't care about file strict 
25139:         // checking, at least mURI is not a file URI.
25139:         if (!NS_SecurityCompareURIs(mURI, newURI, PR_FALSE)) {
25139:             PRBool fallingBack;
25139:             rv = ProcessFallback(&fallingBack);
25139:             if (NS_SUCCEEDED(rv) && fallingBack) {
25139:                 // do not continue with redirect processing, fallback is in
25139:                 // progress now.
25139:                 return NS_OK;
25139:             }
25139:         }
25139:     }
25139: 
    1:     // Kill the current cache entry if we are redirecting
    1:     // back to ourself.
    1:     PRBool redirectingBackToSameURI = PR_FALSE;
    1:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE) &&
    1:         NS_SUCCEEDED(mURI->Equals(newURI, &redirectingBackToSameURI)) &&
    1:         redirectingBackToSameURI)
    1:             mCacheEntry->Doom();
    1: 
    1:     // move the reference of the old location to the new one if the new
    1:     // one has none.
17022:     nsCOMPtr<nsIURL> newURL = do_QueryInterface(newURI);
17022:     if (newURL) {
    1:         nsCAutoString ref;
    1:         rv = newURL->GetRef(ref);
    1:         if (NS_SUCCEEDED(rv) && ref.IsEmpty()) {
17022:             nsCOMPtr<nsIURL> baseURL(do_QueryInterface(mURI));
17022:             if (baseURL) {
    1:                 baseURL->GetRef(ref);
    1:                 if (!ref.IsEmpty())
    1:                     newURL->SetRef(ref);
    1:             }
    1:         }
    1:     }
    1: 
    1:     // if we need to re-send POST data then be sure to ask the user first.
    1:     PRBool preserveMethod = (redirectType == 307);
    1:     if (preserveMethod && mUploadStream) {
    1:         rv = PromptTempRedirect();
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     rv = ioService->NewChannelFromURI(newURI, getter_AddRefs(newChannel));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
14455:     rv = SetupReplacementChannel(newURI, newChannel, preserveMethod);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     PRUint32 redirectFlags;
    1:     if (redirectType == 301) // Moved Permanently
    1:         redirectFlags = nsIChannelEventSink::REDIRECT_PERMANENT;
    1:     else
    1:         redirectFlags = nsIChannelEventSink::REDIRECT_TEMPORARY;
    1: 
    1:     // verify that this is a legal redirect
    1:     rv = gHttpHandler->OnChannelRedirect(this, newChannel, redirectFlags);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
21937:     // Make sure to do this _after_ calling OnChannelRedirect
21937:     newChannel->SetOriginalURI(mOriginalURI);    
21937: 
    1:     // And now, the deprecated way
    1:     nsCOMPtr<nsIHttpEventSink> httpEventSink;
    1:     GetCallback(httpEventSink);
    1:     if (httpEventSink) {
    1:         // NOTE: nsIHttpEventSink is only used for compatibility with pre-1.8
    1:         // versions.
    1:         rv = httpEventSink->OnRedirect(this, newChannel);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     // XXX we used to talk directly with the script security manager, but that
    1:     // should really be handled by the event sink implementation.
    1: 
    1:     // begin loading the new channel
    1:     rv = newChannel->AsyncOpen(mListener, mListenerContext);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // close down this channel
    1:     Cancel(NS_BINDING_REDIRECTED);
    1:     
    1:     // disconnect from our listener
    1:     mListener = 0;
    1:     mListenerContext = 0;
 5516:     // and from our callbacks
 5516:     mCallbacks = nsnull;
 5516:     mProgressSink = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel <auth>
    1: //-----------------------------------------------------------------------------
    1: 
    1: // buf contains "domain\user"
    1: static void
    1: ParseUserDomain(PRUnichar *buf,
    1:                 const PRUnichar **user,
    1:                 const PRUnichar **domain)
    1: {
    1:     PRUnichar *p = buf;
    1:     while (*p && *p != '\\') ++p;
    1:     if (!*p)
    1:         return;
    1:     *p = '\0';
    1:     *domain = buf;
    1:     *user = p + 1;
    1: }
    1: 
    1: // helper function for setting identity from raw user:pass
    1: static void
    1: SetIdent(nsHttpAuthIdentity &ident,
    1:          PRUint32 authFlags,
    1:          PRUnichar *userBuf,
    1:          PRUnichar *passBuf)
    1: {
    1:     const PRUnichar *user = userBuf;
    1:     const PRUnichar *domain = nsnull;
    1: 
    1:     if (authFlags & nsIHttpAuthenticator::IDENTITY_INCLUDES_DOMAIN)
    1:         ParseUserDomain(userBuf, &user, &domain);
    1: 
    1:     ident.Set(domain, user, passBuf);
    1: }
    1: 
    1: // helper function for getting an auth prompt from an interface requestor
    1: static void
    1: GetAuthPrompt(nsIInterfaceRequestor *ifreq, PRBool proxyAuth,
    1:               nsIAuthPrompt2 **result)
    1: {
    1:     if (!ifreq)
    1:         return;
    1: 
    1:     PRUint32 promptReason;
    1:     if (proxyAuth)
    1:         promptReason = nsIAuthPromptProvider::PROMPT_PROXY;
    1:     else 
    1:         promptReason = nsIAuthPromptProvider::PROMPT_NORMAL;
    1: 
    1:     nsCOMPtr<nsIAuthPromptProvider> promptProvider = do_GetInterface(ifreq);
    1:     if (promptProvider)
    1:         promptProvider->GetAuthPrompt(promptReason,
    1:                                       NS_GET_IID(nsIAuthPrompt2),
 3233:                                       reinterpret_cast<void**>(result));
    1:     else
    1:         NS_QueryAuthPrompt2(ifreq, result);
    1: }
    1: 
    1: // generate credentials for the given challenge, and update the auth cache.
    1: nsresult
    1: nsHttpChannel::GenCredsAndSetEntry(nsIHttpAuthenticator *auth,
    1:                                    PRBool proxyAuth,
    1:                                    const char *scheme,
    1:                                    const char *host,
    1:                                    PRInt32 port,
    1:                                    const char *directory,
    1:                                    const char *realm,
    1:                                    const char *challenge,
    1:                                    const nsHttpAuthIdentity &ident,
    1:                                    nsCOMPtr<nsISupports> &sessionState,
    1:                                    char **result)
    1: {
    1:     nsresult rv;
    1:     PRUint32 authFlags;
    1: 
    1:     rv = auth->GetAuthFlags(&authFlags);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsISupports *ss = sessionState;
    1: 
    1:     // set informations that depend on whether
    1:     // we're authenticating against a proxy
    1:     // or a webserver
    1:     nsISupports **continuationState;
    1: 
    1:     if (proxyAuth) {
    1:         continuationState = &mProxyAuthContinuationState;
    1:     } else {
    1:         continuationState = &mAuthContinuationState;
    1:     }
    1: 
    1:     rv = auth->GenerateCredentials(this,
    1:                                    challenge,
    1:                                    proxyAuth,
    1:                                    ident.Domain(),
    1:                                    ident.User(),
    1:                                    ident.Password(),
    1:                                    &ss,
    1:                                    &*continuationState,
    1:                                    result);
    1: 
    1:     sessionState.swap(ss);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // don't log this in release build since it could contain sensitive info.
    1: #ifdef DEBUG 
    1:     LOG(("generated creds: %s\n", *result));
    1: #endif
    1: 
    1:     // find out if this authenticator allows reuse of credentials and/or
    1:     // challenge.
    1:     PRBool saveCreds =
12048:         0 != (authFlags & nsIHttpAuthenticator::REUSABLE_CREDENTIALS);
    1:     PRBool saveChallenge =
12048:         0 != (authFlags & nsIHttpAuthenticator::REUSABLE_CHALLENGE);
    1: 
    1:     // this getter never fails
    1:     nsHttpAuthCache *authCache = gHttpHandler->AuthCache();
    1: 
    1:     // create a cache entry.  we do this even though we don't yet know that
    1:     // these credentials are valid b/c we need to avoid prompting the user
    1:     // more than once in case the credentials are valid.
    1:     //
    1:     // if the credentials are not reusable, then we don't bother sticking
    1:     // them in the auth cache.
    1:     rv = authCache->SetAuthEntry(scheme, host, port, directory, realm,
    1:                                  saveCreds ? *result : nsnull,
    1:                                  saveChallenge ? challenge : nsnull,
    1:                                  ident, sessionState);
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::ProcessAuthentication(PRUint32 httpStatus)
    1: {
    1:     LOG(("nsHttpChannel::ProcessAuthentication [this=%x code=%u]\n",
    1:         this, httpStatus));
    1: 
19954:     if (mLoadFlags & LOAD_ANONYMOUS) {
19954:       return NS_ERROR_NOT_AVAILABLE;
19954:     }
19954: 
    1:     const char *challenges;
30469:     mProxyAuth = (httpStatus == 407);
30469: 
30469:     nsresult rv = PrepareForAuthentication(mProxyAuth);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
30469:     if (mProxyAuth) {
    1:         // only allow a proxy challenge if we have a proxy server configured.
    1:         // otherwise, we could inadvertantly expose the user's proxy
    1:         // credentials to an origin server.  We could attempt to proceed as
    1:         // if we had received a 401 from the server, but why risk flirting
    1:         // with trouble?  IE similarly rejects 407s when a proxy server is
    1:         // not configured, so there's no reason not to do the same.
    1:         if (!mConnectionInfo->UsingHttpProxy()) {
    1:             LOG(("rejecting 407 when proxy server not configured!\n"));
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1:         if (mConnectionInfo->UsingSSL() && !mTransaction->SSLConnectFailed()) {
    1:             // we need to verify that this challenge came from the proxy
    1:             // server itself, and not some server on the other side of the
    1:             // SSL tunnel.
    1:             LOG(("rejecting 407 from origin server!\n"));
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1:         challenges = mResponseHead->PeekHeader(nsHttp::Proxy_Authenticate);
    1:     }
    1:     else
    1:         challenges = mResponseHead->PeekHeader(nsHttp::WWW_Authenticate);
    1:     NS_ENSURE_TRUE(challenges, NS_ERROR_UNEXPECTED);
    1: 
    1:     nsCAutoString creds;
30469:     rv = GetCredentials(challenges, mProxyAuth, creds);
30469:     if (rv == NS_ERROR_IN_PROGRESS)  {
30469:         // authentication prompt has been invoked and result
30469:         // is expected asynchronously
30469:         mAuthRetryPending = PR_TRUE;
30469:         // suspend the transaction pump to stop receiving the
30469:         // unauthenticated content data. We will throw that data
30469:         // away when user provides credentials or resume the pump
30469:         // when user refuses to authenticate.
30469:         LOG(("Suspending the transaction, asynchronously prompting for credentials"));
30469:         mTransactionPump->Suspend();
30469:         return NS_OK;
30469:     }
30469:     else if (NS_FAILED(rv))
    1:         LOG(("unable to authenticate\n"));
    1:     else {
    1:         // set the authentication credentials
30469:         if (mProxyAuth)
    1:             mRequestHead.SetHeader(nsHttp::Proxy_Authorization, creds);
    1:         else
    1:             mRequestHead.SetHeader(nsHttp::Authorization, creds);
    1: 
    1:         mAuthRetryPending = PR_TRUE; // see DoAuthRetry
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::PrepareForAuthentication(PRBool proxyAuth)
    1: {
    1:     LOG(("nsHttpChannel::PrepareForAuthentication [this=%x]\n", this));
    1: 
    1:     if (!proxyAuth) {
    1:         // reset the current proxy continuation state because our last
    1:         // authentication attempt was completed successfully.
    1:         NS_IF_RELEASE(mProxyAuthContinuationState);
    1:         LOG(("  proxy continuation state has been reset"));
    1:     }
    1: 
    1:     if (!mConnectionInfo->UsingHttpProxy() || mProxyAuthType.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     // We need to remove any Proxy_Authorization header left over from a
    1:     // non-request based authentication handshake (e.g., for NTLM auth).
    1: 
    1:     nsCAutoString contractId;
    1:     contractId.Assign(NS_HTTP_AUTHENTICATOR_CONTRACTID_PREFIX);
    1:     contractId.Append(mProxyAuthType);
    1: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsIHttpAuthenticator> precedingAuth =
    1:         do_GetService(contractId.get(), &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 precedingAuthFlags;
    1:     rv = precedingAuth->GetAuthFlags(&precedingAuthFlags);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (!(precedingAuthFlags & nsIHttpAuthenticator::REQUEST_BASED)) {
    1:         const char *challenges =
    1:                 mResponseHead->PeekHeader(nsHttp::Proxy_Authenticate);
    1:         if (!challenges) {
    1:             // delete the proxy authorization header because we weren't
    1:             // asked to authenticate
    1:             mRequestHead.ClearHeader(nsHttp::Proxy_Authorization);
    1:             LOG(("  cleared proxy authorization header"));
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::GetCredentials(const char *challenges,
    1:                               PRBool proxyAuth,
    1:                               nsAFlatCString &creds)
    1: {
    1:     nsCOMPtr<nsIHttpAuthenticator> auth;
    1:     nsCAutoString challenge;
    1: 
    1:     nsCString authType; // force heap allocation to enable string sharing since
    1:                         // we'll be assigning this value into mAuthType.
    1: 
    1:     // set informations that depend on whether we're authenticating against a
    1:     // proxy or a webserver
    1:     nsISupports **currentContinuationState;
    1:     nsCString *currentAuthType;
    1: 
    1:     if (proxyAuth) {
    1:         currentContinuationState = &mProxyAuthContinuationState;
    1:         currentAuthType = &mProxyAuthType;
    1:     } else {
    1:         currentContinuationState = &mAuthContinuationState;
    1:         currentAuthType = &mAuthType;
    1:     }
    1: 
    1:     nsresult rv = NS_ERROR_NOT_AVAILABLE;
    1:     PRBool gotCreds = PR_FALSE;
    1:     
    1:     // figure out which challenge we can handle and which authenticator to use.
    1:     for (const char *eol = challenges - 1; eol; ) {
    1:         const char *p = eol + 1;
    1: 
    1:         // get the challenge string (LF separated -- see nsHttpHeaderArray)
    1:         if ((eol = strchr(p, '\n')) != nsnull)
    1:             challenge.Assign(p, eol - p);
    1:         else
    1:             challenge.Assign(p);
    1: 
    1:         rv = GetAuthenticator(challenge.get(), authType, getter_AddRefs(auth));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             //
    1:             // if we've already selected an auth type from a previous challenge
    1:             // received while processing this channel, then skip others until
    1:             // we find a challenge corresponding to the previously tried auth
    1:             // type.
    1:             //
    1:             if (!currentAuthType->IsEmpty() && authType != *currentAuthType)
    1:                 continue;
    1: 
    1:             //
    1:             // we allow the routines to run all the way through before we
    1:             // decide if they are valid.
    1:             //
    1:             // we don't worry about the auth cache being altered because that
    1:             // would have been the last step, and if the error is from updating
    1:             // the authcache it wasn't really altered anyway. -CTN 
    1:             //
    1:             // at this point the code is really only useful for client side
    1:             // errors (it will not automatically fail over to do a different
    1:             // auth type if the server keeps rejecting what is being sent, even
    1:             // if a particular auth method only knows 1 thing, like a
    1:             // non-identity based authentication method)
    1:             //
    1:             rv = GetCredentialsForChallenge(challenge.get(), authType.get(),
    1:                                             proxyAuth, auth, creds);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 gotCreds = PR_TRUE;
    1:                 *currentAuthType = authType;
    1: 
    1:                 break;
    1:             }
30469:             else if (rv == NS_ERROR_IN_PROGRESS) {
30469:                 // authentication prompt has been invoked and result is
30469:                 // expected asynchronously, save current challenge being
30469:                 // processed and all remaining challenges to use later in
30469:                 // OnAuthAvailable and now immediately return
30469:                 mCurrentChallenge = challenge;
30469:                 mRemainingChallenges = eol ? eol+1 : nsnull;
30469:                 return rv;
30469:             }
    1: 
    1:             // reset the auth type and continuation state
    1:             NS_IF_RELEASE(*currentContinuationState);
    1:             currentAuthType->Truncate();
    1:         }
    1:     }
    1: 
    1:     if (!gotCreds && !currentAuthType->IsEmpty()) {
    1:         // looks like we never found the auth type we were looking for.
    1:         // reset the auth type and continuation state, and try again.
    1:         currentAuthType->Truncate();
    1:         NS_IF_RELEASE(*currentContinuationState);
    1: 
    1:         rv = GetCredentials(challenges, proxyAuth, creds);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
30469: nsHttpChannel::GetAuthorizationMembers(PRBool proxyAuth,
30469:                                        nsCSubstring& scheme,
30469:                                        const char*& host,
30469:                                        PRInt32& port,
30469:                                        nsCSubstring& path,
30469:                                        nsHttpAuthIdentity*& ident,
30469:                                        nsISupports**& continuationState)
30469: {
30469:     if (proxyAuth) {
30469:         NS_ASSERTION (mConnectionInfo->UsingHttpProxy(), "proxyAuth is true, but no HTTP proxy is configured!");
30469: 
30469:         host = mConnectionInfo->ProxyHost();
30469:         port = mConnectionInfo->ProxyPort();
30469:         ident = &mProxyIdent;
30469:         scheme.AssignLiteral("http");
30469: 
30469:         continuationState = &mProxyAuthContinuationState;
30469:     }
30469:     else {
30469:         host = mConnectionInfo->Host();
30469:         port = mConnectionInfo->Port();
30469:         ident = &mIdent;
30469: 
30469:         nsresult rv;
30469:         rv = GetCurrentPath(path);
30469:         if (NS_FAILED(rv)) return rv;
30469: 
30469:         rv = mURI->GetScheme(scheme);
30469:         if (NS_FAILED(rv)) return rv;
30469: 
30469:         continuationState = &mAuthContinuationState;
30469:     }
30469: 
30469:     return NS_OK;
30469: }
30469: 
30469: nsresult
    1: nsHttpChannel::GetCredentialsForChallenge(const char *challenge,
    1:                                           const char *authType,
    1:                                           PRBool proxyAuth,
    1:                                           nsIHttpAuthenticator *auth,
    1:                                           nsAFlatCString &creds)
    1: {
    1:     LOG(("nsHttpChannel::GetCredentialsForChallenge [this=%x proxyAuth=%d challenges=%s]\n",
    1:         this, proxyAuth, challenge));
    1: 
    1:     // this getter never fails
    1:     nsHttpAuthCache *authCache = gHttpHandler->AuthCache();
    1: 
    1:     PRUint32 authFlags;
    1:     nsresult rv = auth->GetAuthFlags(&authFlags);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsCAutoString realm;
    1:     ParseRealm(challenge, realm);
    1: 
    1:     // if no realm, then use the auth type as the realm.  ToUpperCase so the
    1:     // ficticious realm stands out a bit more.
    1:     // XXX this will cause some single signon misses!
    1:     // XXX this was meant to be used with NTLM, which supplies no realm.
    1:     /*
    1:     if (realm.IsEmpty()) {
    1:         realm = authType;
    1:         ToUpperCase(realm);
    1:     }
    1:     */
    1: 
    1:     // set informations that depend on whether
    1:     // we're authenticating against a proxy
    1:     // or a webserver
    1:     const char *host;
    1:     PRInt32 port;
    1:     nsHttpAuthIdentity *ident;
    1:     nsCAutoString path, scheme;
    1:     PRBool identFromURI = PR_FALSE;
    1:     nsISupports **continuationState;
    1: 
30469:     rv = GetAuthorizationMembers(proxyAuth, scheme, host, port, path, ident, continuationState);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
30469:     if (!proxyAuth) {
    1:         // if this is the first challenge, then try using the identity
    1:         // specified in the URL.
    1:         if (mIdent.IsEmpty()) {
    1:             GetIdentityFromURI(authFlags, mIdent);
    1:             identFromURI = !mIdent.IsEmpty();
    1:         }
    1:     }
    1: 
    1:     //
    1:     // if we already tried some credentials for this transaction, then
    1:     // we need to possibly clear them from the cache, unless the credentials
    1:     // in the cache have changed, in which case we'd want to give them a
    1:     // try instead.
    1:     //
    1:     nsHttpAuthEntry *entry = nsnull;
    1:     authCache->GetAuthEntryForDomain(scheme.get(), host, port, realm.get(), &entry);
    1: 
    1:     // hold reference to the auth session state (in case we clear our
    1:     // reference to the entry).
    1:     nsCOMPtr<nsISupports> sessionStateGrip;
    1:     if (entry)
    1:         sessionStateGrip = entry->mMetaData;
    1: 
    1:     // for digest auth, maybe our cached nonce value simply timed out...
    1:     PRBool identityInvalid;
    1:     nsISupports *sessionState = sessionStateGrip;
    1:     rv = auth->ChallengeReceived(this,
    1:                                  challenge,
    1:                                  proxyAuth,
    1:                                  &sessionState,
    1:                                  &*continuationState,
    1:                                  &identityInvalid);
    1:     sessionStateGrip.swap(sessionState);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     LOG(("  identity invalid = %d\n", identityInvalid));
    1: 
    1:     if (identityInvalid) {
    1:         if (entry) {
    1:             if (ident->Equals(entry->Identity())) {
    1:                 LOG(("  clearing bad auth cache entry\n"));
    1:                 // ok, we've already tried this user identity, so clear the
    1:                 // corresponding entry from the auth cache.
    1:                 authCache->ClearAuthEntry(scheme.get(), host, port, realm.get());
    1:                 entry = nsnull;
    1:                 ident->Clear();
    1:             }
    1:             else if (!identFromURI || nsCRT::strcmp(ident->User(), entry->Identity().User()) == 0) {
    1:                 LOG(("  taking identity from auth cache\n"));
    1:                 // the password from the auth cache is more likely to be
    1:                 // correct than the one in the URL.  at least, we know that it
    1:                 // works with the given username.  it is possible for a server
    1:                 // to distinguish logons based on the supplied password alone,
    1:                 // but that would be quite unusual... and i don't think we need
    1:                 // to worry about such unorthodox cases.
    1:                 ident->Set(entry->Identity());
    1:                 identFromURI = PR_FALSE;
    1:                 if (entry->Creds()[0] != '\0') {
    1:                     LOG(("    using cached credentials!\n"));
    1:                     creds.Assign(entry->Creds());
    1:                     return entry->AddPath(path.get());
    1:                 }
    1:             }
    1:         }
    1:         else if (!identFromURI) {
    1:             // hmm... identity invalid, but no auth entry!  the realm probably
    1:             // changed (see bug 201986).
    1:             ident->Clear();
    1:         }
    1: 
    1:         if (!entry && ident->IsEmpty()) {
    1:             PRUint32 level = nsIAuthPrompt2::LEVEL_NONE;
    1:             if (scheme.EqualsLiteral("https"))
    1:                 level = nsIAuthPrompt2::LEVEL_SECURE;
    1:             else if (authFlags & nsIHttpAuthenticator::IDENTITY_ENCRYPTED)
    1:                 level = nsIAuthPrompt2::LEVEL_PW_ENCRYPTED;
    1: 
    1:             // at this point we are forced to interact with the user to get
    1:             // their username and password for this domain.
    1:             rv = PromptForIdentity(level, proxyAuth, realm.get(), 
    1:                                    authType, authFlags, *ident);
    1:             if (NS_FAILED(rv)) return rv;
    1:             identFromURI = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     if (identFromURI) {
    1:         // Warn the user before automatically using the identity from the URL
    1:         // to automatically log them into a site (see bug 232567).
    1:         if (!ConfirmAuth(NS_LITERAL_STRING("AutomaticAuth"), PR_FALSE)) {
    1:             // calling cancel here sets our mStatus and aborts the HTTP
    1:             // transaction, which prevents OnDataAvailable events.
    1:             Cancel(NS_ERROR_ABORT);
    1:             // this return code alone is not equivalent to Cancel, since
    1:             // it only instructs our caller that authentication failed.
    1:             // without an explicit call to Cancel, our caller would just
    1:             // load the page that accompanies the HTTP auth challenge.
    1:             return NS_ERROR_ABORT;
    1:         }
    1:     }
    1: 
    1:     //
    1:     // get credentials for the given user:pass
    1:     //
    1:     // always store the credentials we're trying now so that they will be used
    1:     // on subsequent links.  This will potentially remove good credentials from
    1:     // the cache.  This is ok as we don't want to use cached credentials if the
    1:     // user specified something on the URI or in another manner.  This is so
    1:     // that we don't transparently authenticate as someone they're not
    1:     // expecting to authenticate as.
    1:     //
    1:     nsXPIDLCString result;
    1:     rv = GenCredsAndSetEntry(auth, proxyAuth, scheme.get(), host, port, path.get(),
    1:                              realm.get(), challenge, *ident, sessionStateGrip,
    1:                              getter_Copies(result));
    1:     if (NS_SUCCEEDED(rv))
    1:         creds = result;
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::GetAuthenticator(const char *challenge,
    1:                                 nsCString &authType,
    1:                                 nsIHttpAuthenticator **auth)
    1: {
    1:     LOG(("nsHttpChannel::GetAuthenticator [this=%x]\n", this));
    1: 
21234:     GetAuthType(challenge, authType);
    1:  
    1:     // normalize to lowercase
    1:     ToLowerCase(authType);
    1: 
    1:     nsCAutoString contractid;
    1:     contractid.Assign(NS_HTTP_AUTHENTICATOR_CONTRACTID_PREFIX);
    1:     contractid.Append(authType);
    1: 
    1:     return CallGetService(contractid.get(), auth);
    1: }
    1: 
    1: void
    1: nsHttpChannel::GetIdentityFromURI(PRUint32 authFlags, nsHttpAuthIdentity &ident)
    1: {
    1:     LOG(("nsHttpChannel::GetIdentityFromURI [this=%x]\n", this));
    1: 
    1:     nsAutoString userBuf;
    1:     nsAutoString passBuf;
    1: 
    1:     // XXX i18n
    1:     nsCAutoString buf;
    1:     mURI->GetUsername(buf);
    1:     if (!buf.IsEmpty()) {
    1:         NS_UnescapeURL(buf);
    1:         CopyASCIItoUTF16(buf, userBuf);
    1:         mURI->GetPassword(buf);
    1:         if (!buf.IsEmpty()) {
    1:             NS_UnescapeURL(buf);
    1:             CopyASCIItoUTF16(buf, passBuf);
    1:         }
    1:     }
    1: 
    1:     if (!userBuf.IsEmpty())
    1:         SetIdent(ident, authFlags, (PRUnichar *) userBuf.get(), (PRUnichar *) passBuf.get());
    1: }
    1: 
    1: void
    1: nsHttpChannel::ParseRealm(const char *challenge, nsACString &realm)
    1: {
    1:     //
    1:     // From RFC2617 section 1.2, the realm value is defined as such:
    1:     //
    1:     //    realm       = "realm" "=" realm-value
    1:     //    realm-value = quoted-string
    1:     //
    1:     // but, we'll accept anything after the the "=" up to the first space, or
    1:     // end-of-line, if the string is not quoted.
    1:     //
    1:     const char *p = PL_strcasestr(challenge, "realm=");
    1:     if (p) {
    1:         PRBool has_quote = PR_FALSE;
    1:         p += 6;
    1:         if (*p == '"') {
    1:             has_quote = PR_TRUE;
    1:             p++;
    1:         }
    1: 
    1:         const char *end = p;
    1:         while (*end && has_quote) {
    1:            // Loop through all the string characters to find the closing
    1:            // quote, ignoring escaped quotes.
    1:             if (*end == '"' && end[-1] != '\\')
    1:                 break;
    1:             ++end;
    1:         }
    1: 
    1:         if (!has_quote)
    1:             end = strchr(p, ' '); 
    1:         if (end)
    1:             realm.Assign(p, end - p);
    1:         else
    1:             realm.Assign(p);
    1:     }
    1: }
    1: 
    1: 
    1: class nsHTTPAuthInformation : public nsAuthInformationHolder {
    1: public:
    1:     nsHTTPAuthInformation(PRUint32 aFlags, const nsString& aRealm,
    1:                           const nsCString& aAuthType)
    1:         : nsAuthInformationHolder(aFlags, aRealm, aAuthType) {}
    1: 
    1:     void SetToHttpAuthIdentity(PRUint32 authFlags, nsHttpAuthIdentity& identity);
    1: };
    1: 
    1: void
    1: nsHTTPAuthInformation::SetToHttpAuthIdentity(PRUint32 authFlags, nsHttpAuthIdentity& identity)
    1: {
    1:     identity.Set(Domain().get(), User().get(), Password().get());
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::PromptForIdentity(PRUint32    level,
    1:                                  PRBool      proxyAuth,
    1:                                  const char *realm,
    1:                                  const char *authType,
    1:                                  PRUint32 authFlags,
    1:                                  nsHttpAuthIdentity &ident)
    1: {
    1:     LOG(("nsHttpChannel::PromptForIdentity [this=%x]\n", this));
    1: 
    1:     nsCOMPtr<nsIAuthPrompt2> authPrompt;
    1:     GetAuthPrompt(mCallbacks, proxyAuth, getter_AddRefs(authPrompt));
    1:     if (!authPrompt && mLoadGroup) {
    1:         nsCOMPtr<nsIInterfaceRequestor> cbs;
    1:         mLoadGroup->GetNotificationCallbacks(getter_AddRefs(cbs));
    1:         GetAuthPrompt(cbs, proxyAuth, getter_AddRefs(authPrompt));
    1:     }
    1:     if (!authPrompt)
    1:         return NS_ERROR_NO_INTERFACE;
    1: 
    1:     // XXX i18n: need to support non-ASCII realm strings (see bug 41489)
    1:     NS_ConvertASCIItoUTF16 realmU(realm);
    1: 
    1:     nsresult rv;
    1: 
    1:     // prompt the user...
    1:     PRUint32 promptFlags = 0;
    1:     if (proxyAuth)
    1:         promptFlags |= nsIAuthInformation::AUTH_PROXY;
    1:     else
    1:         promptFlags |= nsIAuthInformation::AUTH_HOST;
    1: 
    1:     if (authFlags & nsIHttpAuthenticator::IDENTITY_INCLUDES_DOMAIN)
    1:         promptFlags |= nsIAuthInformation::NEED_DOMAIN;
    1: 
    1:     nsRefPtr<nsHTTPAuthInformation> holder =
    1:         new nsHTTPAuthInformation(promptFlags, realmU,
    1:                                   nsDependentCString(authType));
    1:     if (!holder)
    1:         return NS_ERROR_OUT_OF_MEMORY;
30469: 
30469:     rv = authPrompt->AsyncPromptAuth(this, this, nsnull, level, holder,
30469:                      getter_AddRefs(mAsyncPromptAuthCancelable));
30469: 
30469:     if (NS_SUCCEEDED(rv)) {
30469:         // indicate using this error code that authentication prompt
30469:         // result is expected asynchronously
30469:         rv = NS_ERROR_IN_PROGRESS;
30469:     }
30469:     else {
30469:         // Fall back to synchronous prompt
    1:         PRBool retval = PR_FALSE;
30469:         rv = authPrompt->PromptAuth(this, level, holder, &retval);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         if (!retval)
    1:             rv = NS_ERROR_ABORT;
    1:         else
    1:             holder->SetToHttpAuthIdentity(authFlags, ident);
30469:     }
30469: 
30469:     // remember that we successfully showed the user an auth dialog
30469:     if (!proxyAuth)
30469:         mSuppressDefensiveAuth = PR_TRUE;
    1: 
    1:     return rv;
    1: }
    1: 
30469: NS_IMETHODIMP nsHttpChannel::OnAuthAvailable(nsISupports *aContext,
30469:                                              nsIAuthInformation *aAuthInfo)
30469: {
30469:     LOG(("nsHttpChannel::OnAuthAvailable [this=%x]", this));
30469:     mAsyncPromptAuthCancelable = nsnull;
30469: 
30469:     nsresult rv;
30469: 
30469:     const char *host;
30469:     PRInt32 port;
30469:     nsHttpAuthIdentity *ident;
30469:     nsCAutoString path, scheme;
30469:     nsISupports **continuationState;
30469:     rv = GetAuthorizationMembers(mProxyAuth, scheme, host, port, path, ident, continuationState);
30469:     if (NS_FAILED(rv))
30469:         OnAuthCancelled(aContext, PR_FALSE);
30469: 
30469:     nsCAutoString realm;
30469:     ParseRealm(mCurrentChallenge.get(), realm);
30469: 
30469:     nsHttpAuthCache *authCache = gHttpHandler->AuthCache();
30469:     nsHttpAuthEntry *entry = nsnull;
30469:     authCache->GetAuthEntryForDomain(scheme.get(), host, port, realm.get(), &entry);
30469: 
30469:     nsCOMPtr<nsISupports> sessionStateGrip;
30469:     if (entry)
30469:         sessionStateGrip = entry->mMetaData;
30469: 
30469:     nsAuthInformationHolder* holder =
30469:             static_cast<nsAuthInformationHolder*>(aAuthInfo);
30469:     ident->Set(holder->Domain().get(),
30469:                holder->User().get(),
30469:                holder->Password().get());
30469: 
30469:     nsCAutoString unused;
30469:     nsCOMPtr<nsIHttpAuthenticator> auth;
30469:     rv = GetAuthenticator(mCurrentChallenge.get(), unused, getter_AddRefs(auth));
30469:     if (NS_FAILED(rv)) {
30469:         NS_ASSERTION(PR_FALSE, "GetAuthenticator failed");
30469:         OnAuthCancelled(aContext, PR_TRUE);
30469:         return NS_OK;
30469:     }
30469: 
30469:     nsXPIDLCString creds;
30469:     rv = GenCredsAndSetEntry(auth, mProxyAuth,
30469:                              scheme.get(), host, port, path.get(),
30469:                              realm.get(), mCurrentChallenge.get(), *ident, sessionStateGrip,
30469:                              getter_Copies(creds));
30469: 
30469:     mCurrentChallenge.Truncate();
30469:     if (NS_FAILED(rv)) {
30469:         OnAuthCancelled(aContext, PR_TRUE);
30469:         return NS_OK;
30469:     }
30469: 
30469:     return ContinueOnAuthAvailable(creds);
30469: }
30469: 
30469: NS_IMETHODIMP nsHttpChannel::OnAuthCancelled(nsISupports *aContext, 
30469:                                              PRBool userCancel)
30469: {
30469:     LOG(("nsHttpChannel::OnAuthCancelled [this=%x]", this));
30469:     mAsyncPromptAuthCancelable = nsnull;
30469:     if (userCancel) {
30469:         if (!mRemainingChallenges.IsEmpty()) {
30469:             // there are still some challenges to process, do so
30469:             nsresult rv;
30469: 
30469:             nsCAutoString creds;
30469:             rv = GetCredentials(mRemainingChallenges.get(), mProxyAuth, creds);
30469:             if (NS_SUCCEEDED(rv)) {
30469:                 // GetCredentials loaded the credentials from the cache or
30469:                 // some other way in a synchronous manner, process those
30469:                 // credentials now
30469:                 mRemainingChallenges.Truncate();
30469:                 return ContinueOnAuthAvailable(creds);
30469:             }
30469:             else if (rv == NS_ERROR_IN_PROGRESS) {
30469:                 // GetCredentials successfully queued another authprompt for
30469:                 // a challenge from the list, we are now waiting for the user
30469:                 // to provide the credentials
30469:                 return NS_OK;
30469:             }
30469: 
30469:             // otherwise, we failed...
30469:         }
30469: 
30469:         mRemainingChallenges.Truncate();
30469: 
30469:         // ensure call of OnStartRequest of the current listener here,
30469:         // it would not be called otherwise at all
30469:         nsresult rv = CallOnStartRequest();
30469: 
30469:         // drop mAuthRetryPending flag and resume the transaction
30469:         // this resumes load of the unauthenticated content data
30469:         mAuthRetryPending = PR_FALSE;
30469:         LOG(("Resuming the transaction, user cancelled the auth dialog"));
30469:         mTransactionPump->Resume();
30469: 
30469:         if (NS_FAILED(rv))
30469:             mTransactionPump->Cancel(rv);
30469:     }
30469: 
30469:     return NS_OK;
30469: }
30469: 
30469: nsresult
30469: nsHttpChannel::ContinueOnAuthAvailable(const nsCSubstring& creds)
30469: {
30469:     if (mProxyAuth)
30469:         mRequestHead.SetHeader(nsHttp::Proxy_Authorization, creds);
30469:     else
30469:         mRequestHead.SetHeader(nsHttp::Authorization, creds);
30469: 
30469:     // drop our remaining list of challenges.  We don't need them, because we
30469:     // have now authenticated against a challenge and will be sending that
30469:     // information to the server (or proxy).  If it doesn't accept our
30469:     // authentication it'll respond with failure and resend the challenge list
30469:     mRemainingChallenges.Truncate();
30469: 
30469:     // setting mAuthRetryPending flag and resuming the transaction
30469:     // triggers process of throwing away the unauthenticated data already
30469:     // coming from the network
30469:     mAuthRetryPending = PR_TRUE;
30469:     LOG(("Resuming the transaction, we got credentials from user"));
30469:     mTransactionPump->Resume();
30469: 
30469:     return NS_OK;
30469: }
30469: 
    1: PRBool
    1: nsHttpChannel::ConfirmAuth(const nsString &bundleKey, PRBool doYesNoPrompt)
    1: {
    1:     // skip prompting the user if
    1:     //   1) we've already prompted the user
    1:     //   2) we're not a toplevel channel
    1:     //   3) the userpass length is less than the "phishy" threshold
    1: 
    1:     if (mSuppressDefensiveAuth || !(mLoadFlags & LOAD_INITIAL_DOCUMENT_URI))
    1:         return PR_TRUE;
    1: 
    1:     nsresult rv;
    1:     nsCAutoString userPass;
    1:     rv = mURI->GetUserPass(userPass);
    1:     if (NS_FAILED(rv) || (userPass.Length() < gHttpHandler->PhishyUserPassLength()))
    1:         return PR_TRUE;
    1: 
    1:     // we try to confirm by prompting the user.  if we cannot do so, then
    1:     // assume the user said ok.  this is done to keep things working in
    1:     // embedded builds, where the string bundle might not be present, etc.
    1: 
    1:     nsCOMPtr<nsIStringBundleService> bundleService =
    1:             do_GetService(NS_STRINGBUNDLE_CONTRACTID);
    1:     if (!bundleService)
    1:         return PR_TRUE;
    1: 
    1:     nsCOMPtr<nsIStringBundle> bundle;
    1:     bundleService->CreateBundle(NECKO_MSGS_URL, getter_AddRefs(bundle));
    1:     if (!bundle)
    1:         return PR_TRUE;
    1: 
    1:     nsCAutoString host;
    1:     rv = mURI->GetHost(host);
    1:     if (NS_FAILED(rv))
    1:         return PR_TRUE;
    1: 
    1:     nsCAutoString user;
    1:     rv = mURI->GetUsername(user);
    1:     if (NS_FAILED(rv))
    1:         return PR_TRUE;
    1: 
    1:     NS_ConvertUTF8toUTF16 ucsHost(host), ucsUser(user);
    1:     const PRUnichar *strs[2] = { ucsHost.get(), ucsUser.get() };
    1: 
    1:     nsXPIDLString msg;
    1:     bundle->FormatStringFromName(bundleKey.get(), strs, 2, getter_Copies(msg));
    1:     if (!msg)
    1:         return PR_TRUE;
    1:     
    1:     nsCOMPtr<nsIPrompt> prompt;
    1:     GetCallback(prompt);
    1:     if (!prompt)
    1:         return PR_TRUE;
    1: 
    1:     // do not prompt again
    1:     mSuppressDefensiveAuth = PR_TRUE;
    1: 
    1:     PRBool confirmed;
    1:     if (doYesNoPrompt) {
    1:         PRInt32 choice;
29073:         PRBool checkState;
    1:         rv = prompt->ConfirmEx(nsnull, msg,
    1:                                nsIPrompt::BUTTON_POS_1_DEFAULT +
    1:                                nsIPrompt::STD_YES_NO_BUTTONS,
29073:                                nsnull, nsnull, nsnull, nsnull, &checkState, &choice);
    1:         if (NS_FAILED(rv))
    1:             return PR_TRUE;
    1: 
    1:         confirmed = choice == 0;
    1:     }
    1:     else {
    1:         rv = prompt->Confirm(nsnull, msg, &confirmed);
    1:         if (NS_FAILED(rv))
    1:             return PR_TRUE;
    1:     }
    1: 
    1:     return confirmed;
    1: }
    1: 
    1: void
    1: nsHttpChannel::CheckForSuperfluousAuth()
    1: {
    1:     // we've been called because it has been determined that this channel is
    1:     // getting loaded without taking the userpass from the URL.  if the URL
    1:     // contained a userpass, then (provided some other conditions are true),
    1:     // we'll give the user an opportunity to abort the channel as this might be
    1:     // an attempt to spoof a different site (see bug 232567).
    1:     if (!mAuthRetryPending) {
    1:         // ask user...
    1:         if (!ConfirmAuth(NS_LITERAL_STRING("SuperfluousAuth"), PR_TRUE)) {
    1:             // calling cancel here sets our mStatus and aborts the HTTP
    1:             // transaction, which prevents OnDataAvailable events.
    1:             Cancel(NS_ERROR_ABORT);
    1:         }
    1:     }
    1: }
    1: 
    1: void
    1: nsHttpChannel::SetAuthorizationHeader(nsHttpAuthCache *authCache,
    1:                                       nsHttpAtom header,
    1:                                       const char *scheme,
    1:                                       const char *host,
    1:                                       PRInt32 port,
    1:                                       const char *path,
    1:                                       nsHttpAuthIdentity &ident)
    1: {
    1:     nsHttpAuthEntry *entry = nsnull;
    1:     nsresult rv;
    1: 
    1:     // set informations that depend on whether
    1:     // we're authenticating against a proxy
    1:     // or a webserver
    1:     nsISupports **continuationState;
    1: 
    1:     if (header == nsHttp::Proxy_Authorization) {
    1:         continuationState = &mProxyAuthContinuationState;
    1:     } else {
    1:         continuationState = &mAuthContinuationState;
    1:     }
    1: 
    1:     rv = authCache->GetAuthEntryForPath(scheme, host, port, path, &entry);
    1:     if (NS_SUCCEEDED(rv)) {
    1:         // if we are trying to add a header for origin server auth and if the
    1:         // URL contains an explicit username, then try the given username first.
    1:         // we only want to do this, however, if we know the URL requires auth
    1:         // based on the presence of an auth cache entry for this URL (which is
    1:         // true since we are here).  but, if the username from the URL matches
    1:         // the username from the cache, then we should prefer the password
    1:         // stored in the cache since that is most likely to be valid.
    1:         if (header == nsHttp::Authorization && entry->Domain()[0] == '\0') {
    1:             GetIdentityFromURI(0, ident);
    1:             // if the usernames match, then clear the ident so we will pick
    1:             // up the one from the auth cache instead.
    1:             if (nsCRT::strcmp(ident.User(), entry->User()) == 0)
    1:                 ident.Clear();
    1:         }
    1:         PRBool identFromURI;
    1:         if (ident.IsEmpty()) {
    1:             ident.Set(entry->Identity());
    1:             identFromURI = PR_FALSE;
    1:         }
    1:         else
    1:             identFromURI = PR_TRUE;
    1: 
    1:         nsXPIDLCString temp;
    1:         const char *creds     = entry->Creds();
    1:         const char *challenge = entry->Challenge();
    1:         // we can only send a preemptive Authorization header if we have either
    1:         // stored credentials or a stored challenge from which to derive
    1:         // credentials.  if the identity is from the URI, then we cannot use
    1:         // the stored credentials.
    1:         if ((!creds[0] || identFromURI) && challenge[0]) {
    1:             nsCOMPtr<nsIHttpAuthenticator> auth;
    1:             nsCAutoString unused;
    1:             rv = GetAuthenticator(challenge, unused, getter_AddRefs(auth));
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 PRBool proxyAuth = (header == nsHttp::Proxy_Authorization);
    1:                 rv = GenCredsAndSetEntry(auth, proxyAuth, scheme, host, port, path,
    1:                                          entry->Realm(), challenge, ident,
    1:                                          entry->mMetaData, getter_Copies(temp));
    1:                 if (NS_SUCCEEDED(rv))
    1:                     creds = temp.get();
    1: 
    1:                 // make sure the continuation state is null since we do not
    1:                 // support mixing preemptive and 'multirequest' authentication.
    1:                 NS_IF_RELEASE(*continuationState);
    1:             }
    1:         }
    1:         if (creds[0]) {
    1:             LOG(("   adding \"%s\" request header\n", header.get()));
    1:             mRequestHead.SetHeader(header, nsDependentCString(creds));
    1: 
    1:             // suppress defensive auth prompting for this channel since we know
    1:             // that we already prompted at least once this session.  we only do
    1:             // this for non-proxy auth since the URL's userpass is not used for
    1:             // proxy auth.
    1:             if (header == nsHttp::Authorization)
    1:                 mSuppressDefensiveAuth = PR_TRUE;
    1:         }
    1:         else
    1:             ident.Clear(); // don't remember the identity
    1:     }
    1: }
    1: 
    1: void
    1: nsHttpChannel::AddAuthorizationHeaders()
    1: {
    1:     LOG(("nsHttpChannel::AddAuthorizationHeaders? [this=%x]\n", this));
    1: 
19954:     if (mLoadFlags & LOAD_ANONYMOUS) {
19954:       return;
19954:     }
19954: 
    1:     // this getter never fails
    1:     nsHttpAuthCache *authCache = gHttpHandler->AuthCache();
    1: 
    1:     // check if proxy credentials should be sent
    1:     const char *proxyHost = mConnectionInfo->ProxyHost();
    1:     if (proxyHost && mConnectionInfo->UsingHttpProxy())
    1:         SetAuthorizationHeader(authCache, nsHttp::Proxy_Authorization,
    1:                                "http", proxyHost, mConnectionInfo->ProxyPort(),
    1:                                nsnull, // proxy has no path
    1:                                mProxyIdent);
    1: 
    1:     // check if server credentials should be sent
    1:     nsCAutoString path, scheme;
    1:     if (NS_SUCCEEDED(GetCurrentPath(path)) &&
    1:         NS_SUCCEEDED(mURI->GetScheme(scheme))) {
    1:         SetAuthorizationHeader(authCache, nsHttp::Authorization,
    1:                                scheme.get(),
    1:                                mConnectionInfo->Host(),
    1:                                mConnectionInfo->Port(),
    1:                                path.get(),
    1:                                mIdent);
    1:     }
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::GetCurrentPath(nsACString &path)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIURL> url = do_QueryInterface(mURI);
    1:     if (url)
    1:         rv = url->GetDirectory(path);
    1:     else
    1:         rv = mURI->GetPath(path);
    1:     return rv;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsISupports
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsHttpChannel, nsHashPropertyBag)
    1: NS_IMPL_RELEASE_INHERITED(nsHttpChannel, nsHashPropertyBag)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsHttpChannel)
    1:     NS_INTERFACE_MAP_ENTRY(nsIRequest)
    1:     NS_INTERFACE_MAP_ENTRY(nsIChannel)
    1:     NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
    1:     NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
    1:     NS_INTERFACE_MAP_ENTRY(nsIHttpChannel)
    1:     NS_INTERFACE_MAP_ENTRY(nsICachingChannel)
    1:     NS_INTERFACE_MAP_ENTRY(nsIUploadChannel)
32329:     NS_INTERFACE_MAP_ENTRY(nsIUploadChannel2)
    1:     NS_INTERFACE_MAP_ENTRY(nsICacheListener)
    1:     NS_INTERFACE_MAP_ENTRY(nsIEncodedChannel)
    1:     NS_INTERFACE_MAP_ENTRY(nsIHttpChannelInternal)
    1:     NS_INTERFACE_MAP_ENTRY(nsIResumableChannel)
    1:     NS_INTERFACE_MAP_ENTRY(nsITransportEventSink)
    1:     NS_INTERFACE_MAP_ENTRY(nsISupportsPriority)
    1:     NS_INTERFACE_MAP_ENTRY(nsIProtocolProxyCallback)
    1:     NS_INTERFACE_MAP_ENTRY(nsIProxiedChannel)
18377:     NS_INTERFACE_MAP_ENTRY(nsITraceableChannel)
18430:     NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheContainer)
21311:     NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheChannel)
30469:     NS_INTERFACE_MAP_ENTRY(nsIAuthPromptCallback)
    1: NS_INTERFACE_MAP_END_INHERITING(nsHashPropertyBag)
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIRequest
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetName(nsACString &aName)
    1: {
    1:     aName = mSpec;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::IsPending(PRBool *value)
    1: {
    1:     NS_ENSURE_ARG_POINTER(value);
    1:     *value = mIsPending;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetStatus(nsresult *aStatus)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aStatus);
    1:     *aStatus = mStatus;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::Cancel(nsresult status)
    1: {
    1:     LOG(("nsHttpChannel::Cancel [this=%x status=%x]\n", this, status));
    1:     if (mCanceled) {
    1:         LOG(("  ignoring; already canceled\n"));
    1:         return NS_OK;
    1:     }
    1:     mCanceled = PR_TRUE;
    1:     mStatus = status;
    1:     if (mProxyRequest)
    1:         mProxyRequest->Cancel(status);
    1:     if (mTransaction)
    1:         gHttpHandler->CancelTransaction(mTransaction, status);
    1:     if (mTransactionPump)
    1:         mTransactionPump->Cancel(status);
    1:     if (mCachePump)
    1:         mCachePump->Cancel(status);
30469:     if (mAsyncPromptAuthCancelable)
30469:         mAsyncPromptAuthCancelable->Cancel(status);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::Suspend()
    1: {
 5208:     NS_ENSURE_TRUE(mIsPending, NS_ERROR_NOT_AVAILABLE);
 5208:     
    1:     LOG(("nsHttpChannel::Suspend [this=%x]\n", this));
 5208: 
 5208:     ++mSuspendCount;
 5208: 
    1:     if (mTransactionPump)
    1:         return mTransactionPump->Suspend();
    1:     if (mCachePump)
    1:         return mCachePump->Suspend();
    1: 
 5208:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::Resume()
    1: {
 5208:     NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);
 5208:     
    1:     LOG(("nsHttpChannel::Resume [this=%x]\n", this));
 5208:         
 5208:     if (--mSuspendCount == 0 && mPendingAsyncCallOnResume) {
 5208:         nsresult rv = AsyncCall(mPendingAsyncCallOnResume);
 5208:         mPendingAsyncCallOnResume = nsnull;
 5208:         NS_ENSURE_SUCCESS(rv, rv);
 5208:     }
 5208: 
    1:     if (mTransactionPump)
    1:         return mTransactionPump->Resume();
    1:     if (mCachePump)
    1:         return mCachePump->Resume();
    1: 
 5208:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetLoadGroup(nsILoadGroup **aLoadGroup)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aLoadGroup);
    1:     *aLoadGroup = mLoadGroup;
    1:     NS_IF_ADDREF(*aLoadGroup);
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetLoadGroup(nsILoadGroup *aLoadGroup)
    1: {
    1:     mLoadGroup = aLoadGroup;
    1:     mProgressSink = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetLoadFlags(nsLoadFlags *aLoadFlags)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aLoadFlags);
    1:     *aLoadFlags = mLoadFlags;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetLoadFlags(nsLoadFlags aLoadFlags)
    1: {
    1:     mLoadFlags = aLoadFlags;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIChannel
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetOriginalURI(nsIURI **originalURI)
    1: {
    1:     NS_ENSURE_ARG_POINTER(originalURI);
    1:     *originalURI = mOriginalURI;
20508:     NS_ADDREF(*originalURI);
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetOriginalURI(nsIURI *originalURI)
    1: {
20508:     NS_ENSURE_ARG_POINTER(originalURI);
    1:     mOriginalURI = originalURI;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetURI(nsIURI **URI)
    1: {
    1:     NS_ENSURE_ARG_POINTER(URI);
    1:     *URI = mURI;
    1:     NS_IF_ADDREF(*URI);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetOwner(nsISupports **owner)
    1: {
    1:     NS_ENSURE_ARG_POINTER(owner);
    1:     *owner = mOwner;
    1:     NS_IF_ADDREF(*owner);
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetOwner(nsISupports *owner)
    1: {
    1:     mOwner = owner;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetNotificationCallbacks(nsIInterfaceRequestor **callbacks)
    1: {
    1:     NS_IF_ADDREF(*callbacks = mCallbacks);
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetNotificationCallbacks(nsIInterfaceRequestor *callbacks)
    1: {
    1:     mCallbacks = callbacks;
    1:     mProgressSink = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetSecurityInfo(nsISupports **securityInfo)
    1: {
    1:     NS_ENSURE_ARG_POINTER(securityInfo);
    1:     *securityInfo = mSecurityInfo;
    1:     NS_IF_ADDREF(*securityInfo);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetContentType(nsACString &value)
    1: {
    1:     if (!mResponseHead) {
    1:         // We got no data, we got no headers, we got nothing
    1:         value.Truncate();
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
    1:     if (!mResponseHead->ContentType().IsEmpty()) {
    1:         value = mResponseHead->ContentType();
    1:         return NS_OK;
    1:     }
    1: 
    1:     
    1:     value.AssignLiteral(UNKNOWN_CONTENT_TYPE);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetContentType(const nsACString &value)
    1: {
 1410:     if (mListener || mWasOpened) {
    1:         if (!mResponseHead)
    1:             return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:         nsCAutoString contentTypeBuf, charsetBuf;
    1:         PRBool hadCharset;
    1:         net_ParseContentType(value, contentTypeBuf, charsetBuf, &hadCharset);
    1: 
    1:         mResponseHead->SetContentType(contentTypeBuf);
    1: 
    1:         // take care not to stomp on an existing charset
    1:         if (hadCharset)
    1:             mResponseHead->SetContentCharset(charsetBuf);
    1:     } else {
    1:         // We are being given a content-type hint.
    1:         PRBool dummy;
    1:         net_ParseContentType(value, mContentTypeHint, mContentCharsetHint,
    1:                              &dummy);
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetContentCharset(nsACString &value)
    1: {
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     value = mResponseHead->ContentCharset();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetContentCharset(const nsACString &value)
    1: {
    1:     if (mListener) {
    1:         if (!mResponseHead)
    1:             return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:         mResponseHead->SetContentCharset(value);
    1:     } else {
    1:         // Charset hint
    1:         mContentCharsetHint = value;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetContentLength(PRInt32 *value)
    1: {
    1:     NS_ENSURE_ARG_POINTER(value);
    1: 
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // XXX truncates to 32 bit
    1:     LL_L2I(*value, mResponseHead->ContentLength());
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetContentLength(PRInt32 value)
    1: {
    1:     NS_NOTYETIMPLEMENTED("nsHttpChannel::SetContentLength");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::Open(nsIInputStream **_retval)
    1: {
   51:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_IN_PROGRESS);
    1:     return NS_ImplementChannelOpen(this, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::AsyncOpen(nsIStreamListener *listener, nsISupports *context)
    1: {
    1:     LOG(("nsHttpChannel::AsyncOpen [this=%x]\n", this));
    1: 
    1:     NS_ENSURE_ARG_POINTER(listener);
    1:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
   51:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
    1: 
    1:     nsresult rv;
    1: 
    1:     rv = NS_CheckPortSafety(mURI);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
22391:     if (!(mConnectionInfo && mConnectionInfo->UsingHttpProxy())) {
21577:         // Start a DNS lookup very early in case the real open is queued the DNS can 
22391:         // happen in parallel. Do not do so in the presence of an HTTP proxy as 
22391:         // all lookups other than for the proxy itself are done by the proxy.
21577:         nsRefPtr<nsDNSPrefetch> prefetch = new nsDNSPrefetch(mURI);
21577:         if (prefetch) {
21577:             prefetch->PrefetchHigh();
21577:         }
22391:     }
21577:     
    1:     // Remember the cookie header that was set, if any
    1:     const char *cookieHeader = mRequestHead.PeekHeader(nsHttp::Cookie);
    1:     if (cookieHeader)
    1:         mUserSetCookieHeader = cookieHeader;
    1: 
    1:     // fetch cookies, and add them to the request header
    1:     AddCookiesToRequest();
    1: 
    1:     // notify "http-on-modify-request" observers
    1:     gHttpHandler->OnModifyRequest(this);
    1: 
    1:     // Adjust mCaps according to our request headers:
    1:     //  - If "Connection: close" is set as a request header, then do not bother
    1:     //    trying to establish a keep-alive connection.
    1:     if (mRequestHead.HasHeaderValue(nsHttp::Connection, "close"))
    1:         mCaps &= ~(NS_HTTP_ALLOW_KEEPALIVE | NS_HTTP_ALLOW_PIPELINING);
    1:     
21294:     if ((mLoadFlags & VALIDATE_ALWAYS) || 
21294:         (BYPASS_LOCAL_CACHE(mLoadFlags)))
21294:         mCaps |= NS_HTTP_REFRESH_DNS;
21294: 
    1:     mIsPending = PR_TRUE;
   51:     mWasOpened = PR_TRUE;
    1: 
    1:     mListener = listener;
    1:     mListenerContext = context;
    1: 
    1:     // add ourselves to the load group.  from this point forward, we'll report
    1:     // all failures asynchronously.
    1:     if (mLoadGroup)
    1:         mLoadGroup->AddRequest(this, nsnull);
    1: 
    1:     // We may have been cancelled already, either by on-modify-request
    1:     // listeners or by load group observers; in that case, we should
    1:     // not send the request to the server
    1:     if (mCanceled)
    1:         rv = mStatus;
    1:     else
    1:         rv = Connect();
    1:     if (NS_FAILED(rv)) {
    1:         LOG(("Calling AsyncAbort [rv=%x mCanceled=%i]\n", rv, mCanceled));
19028:         CloseCacheEntry(PR_TRUE);
    1:         AsyncAbort(rv);
    1:     }
    1:     return NS_OK;
    1: }
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIHttpChannel
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetRequestMethod(nsACString &method)
    1: {
    1:     method = mRequestHead.Method();
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetRequestMethod(const nsACString &method)
    1: {
    1:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
    1: 
    1:     const nsCString &flatMethod = PromiseFlatCString(method);
    1: 
    1:     // Method names are restricted to valid HTTP tokens.
    1:     if (!nsHttp::IsValidToken(flatMethod))
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsHttpAtom atom = nsHttp::ResolveAtom(flatMethod.get());
    1:     if (!atom)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     mRequestHead.SetMethod(atom);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetReferrer(nsIURI **referrer)
    1: {
    1:     NS_ENSURE_ARG_POINTER(referrer);
    1:     *referrer = mReferrer;
    1:     NS_IF_ADDREF(*referrer);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetReferrer(nsIURI *referrer)
    1: {
    1:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
    1: 
    1:     // clear existing referrer, if any
    1:     mReferrer = nsnull;
    1:     mRequestHead.ClearHeader(nsHttp::Referer);
    1: 
    1:     if (!referrer)
    1:         return NS_OK;
    1: 
    1:     // check referrer blocking pref
    1:     PRUint32 referrerLevel;
    1:     if (mLoadFlags & LOAD_INITIAL_DOCUMENT_URI)
    1:         referrerLevel = 1; // user action
    1:     else
    1:         referrerLevel = 2; // inline content
    1:     if (gHttpHandler->ReferrerLevel() < referrerLevel)
    1:         return NS_OK;
    1: 
    1:     nsCOMPtr<nsIURI> referrerGrip;
    1:     nsresult rv;
    1:     PRBool match;
    1: 
    1:     //
    1:     // Strip off "wyciwyg://123/" from wyciwyg referrers.
    1:     //
    1:     // XXX this really belongs elsewhere since wyciwyg URLs aren't part of necko.
    1:     //     perhaps some sort of generic nsINestedURI could be used.  then, if an URI
    1:     //     fails the whitelist test, then we could check for an inner URI and try
    1:     //     that instead.  though, that might be too automatic.
    1:     // 
    1:     rv = referrer->SchemeIs("wyciwyg", &match);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (match) {
    1:         nsCAutoString path;
    1:         rv = referrer->GetPath(path);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         PRUint32 pathLength = path.Length();
    1:         if (pathLength <= 2) return NS_ERROR_FAILURE;
    1: 
    1:         // Path is of the form "//123/http://foo/bar", with a variable number of digits.
    1:         // To figure out where the "real" URL starts, search path for a '/', starting at 
    1:         // the third character.
    1:         PRInt32 slashIndex = path.FindChar('/', 2);
    1:         if (slashIndex == kNotFound) return NS_ERROR_FAILURE;
    1: 
    1:         // Get the charset of the original URI so we can pass it to our fixed up URI.
    1:         nsCAutoString charset;
    1:         referrer->GetOriginCharset(charset);
    1: 
    1:         // Replace |referrer| with a URI without wyciwyg://123/.
    1:         rv = NS_NewURI(getter_AddRefs(referrerGrip),
    1:                        Substring(path, slashIndex + 1, pathLength - slashIndex - 1),
    1:                        charset.get());
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         referrer = referrerGrip.get();
    1:     }
    1: 
    1:     //
    1:     // block referrer if not on our white list...
    1:     //
    1:     static const char *const referrerWhiteList[] = {
    1:         "http",
    1:         "https",
    1:         "ftp",
    1:         "gopher",
    1:         nsnull
    1:     };
    1:     match = PR_FALSE;
    1:     const char *const *scheme = referrerWhiteList;
    1:     for (; *scheme && !match; ++scheme) {
    1:         rv = referrer->SchemeIs(*scheme, &match);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     if (!match)
    1:         return NS_OK; // kick out....
    1: 
    1:     //
    1:     // Handle secure referrals.
    1:     //
    1:     // Support referrals from a secure server if this is a secure site
    1:     // and (optionally) if the host names are the same.
    1:     //
    1:     rv = referrer->SchemeIs("https", &match);
    1:     if (NS_FAILED(rv)) return rv;
    1:     if (match) {
    1:         rv = mURI->SchemeIs("https", &match);
    1:         if (NS_FAILED(rv)) return rv;
    1:         if (!match)
    1:             return NS_OK;
    1: 
    1:         if (!gHttpHandler->SendSecureXSiteReferrer()) {
    1:             nsCAutoString referrerHost;
    1:             nsCAutoString host;
    1: 
    1:             rv = referrer->GetAsciiHost(referrerHost);
    1:             if (NS_FAILED(rv)) return rv;
    1: 
    1:             rv = mURI->GetAsciiHost(host);
    1:             if (NS_FAILED(rv)) return rv;
    1: 
    1:             // GetAsciiHost returns lowercase hostname.
    1:             if (!referrerHost.Equals(host))
    1:                 return NS_OK;
    1:         }
    1:     }
    1: 
    1:     nsCOMPtr<nsIURI> clone;
    1:     //
    1:     // we need to clone the referrer, so we can:
    1:     //  (1) modify it
    1:     //  (2) keep a reference to it after returning from this function
    1:     //
    1:     rv = referrer->Clone(getter_AddRefs(clone));
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // strip away any userpass; we don't want to be giving out passwords ;-)
    1:     clone->SetUserPass(EmptyCString());
    1: 
    1:     // strip away any fragment per RFC 2616 section 14.36
    1:     nsCOMPtr<nsIURL> url = do_QueryInterface(clone);
    1:     if (url)
    1:         url->SetRef(EmptyCString());
    1: 
    1:     nsCAutoString spec;
    1:     rv = clone->GetAsciiSpec(spec);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // finally, remember the referrer URI and set the Referer header.
    1:     mReferrer = clone;
    1:     mRequestHead.SetHeader(nsHttp::Referer, spec);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetRequestHeader(const nsACString &header, nsACString &value)
    1: {
    1:     // XXX might be better to search the header list directly instead of
    1:     // hitting the http atom hash table.
    1: 
    1:     nsHttpAtom atom = nsHttp::ResolveAtom(header);
    1:     if (!atom)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     return mRequestHead.GetHeader(atom, value);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetRequestHeader(const nsACString &header,
    1:                                 const nsACString &value,
    1:                                 PRBool merge)
    1: {
    1:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
    1: 
    1:     const nsCString &flatHeader = PromiseFlatCString(header);
    1:     const nsCString &flatValue  = PromiseFlatCString(value);
    1: 
    1:     LOG(("nsHttpChannel::SetRequestHeader [this=%x header=\"%s\" value=\"%s\" merge=%u]\n",
    1:         this, flatHeader.get(), flatValue.get(), merge));
    1: 
    1:     // Header names are restricted to valid HTTP tokens.
    1:     if (!nsHttp::IsValidToken(flatHeader))
    1:         return NS_ERROR_INVALID_ARG;
    1:     
    1:     // Header values MUST NOT contain line-breaks.  RFC 2616 technically
    1:     // permits CTL characters, including CR and LF, in header values provided
    1:     // they are quoted.  However, this can lead to problems if servers do not
    1:     // interpret quoted strings properly.  Disallowing CR and LF here seems
    1:     // reasonable and keeps things simple.  We also disallow a null byte.
    1:     if (flatValue.FindCharInSet("\r\n") != kNotFound ||
    1:         flatValue.Length() != strlen(flatValue.get()))
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsHttpAtom atom = nsHttp::ResolveAtom(flatHeader.get());
    1:     if (!atom) {
    1:         NS_WARNING("failed to resolve atom");
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
    1:     return mRequestHead.SetHeader(atom, flatValue, merge);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::VisitRequestHeaders(nsIHttpHeaderVisitor *visitor)
    1: {
    1:     return mRequestHead.Headers().VisitHeaders(visitor);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetUploadStream(nsIInputStream **stream)
    1: {
    1:     NS_ENSURE_ARG_POINTER(stream);
    1:     *stream = mUploadStream;
    1:     NS_IF_ADDREF(*stream);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32329: nsHttpChannel::SetUploadStream(nsIInputStream *stream,
32329:                                const nsACString &contentType,
32329:                                PRInt32 contentLength)
    1: {
    1:     // NOTE: for backwards compatibility and for compatibility with old style
    1:     // plugins, |stream| may include headers, specifically Content-Type and
    1:     // Content-Length headers.  in this case, |contentType| and |contentLength|
    1:     // would be unspecified.  this is traditionally the case of a POST request,
    1:     // and so we select POST as the request method if contentType and
    1:     // contentLength are unspecified.
    1:     
    1:     if (stream) {
    1:         if (!contentType.IsEmpty()) {
    1:             if (contentLength < 0) {
    1:                 stream->Available((PRUint32 *) &contentLength);
    1:                 if (contentLength < 0) {
    1:                     NS_ERROR("unable to determine content length");
    1:                     return NS_ERROR_FAILURE;
    1:                 }
    1:             }
32329:             mRequestHead.SetHeader(nsHttp::Content_Length,
32329:                                    nsPrintfCString("%d", contentLength));
    1:             mRequestHead.SetHeader(nsHttp::Content_Type, contentType);
    1:             mUploadStreamHasHeaders = PR_FALSE;
    1:             mRequestHead.SetMethod(nsHttp::Put); // PUT request
    1:         }
    1:         else {
    1:             mUploadStreamHasHeaders = PR_TRUE;
    1:             mRequestHead.SetMethod(nsHttp::Post); // POST request
    1:         }
    1:     }
    1:     else {
    1:         mUploadStreamHasHeaders = PR_FALSE;
    1:         mRequestHead.SetMethod(nsHttp::Get); // revert to GET request
    1:     }
    1:     mUploadStream = stream;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
32329: nsHttpChannel::ExplicitSetUploadStream(nsIInputStream *aStream,
32329:                                        const nsACString &aContentType,
32329:                                        PRInt64 aContentLength,
32329:                                        const nsACString &aMethod,
32329:                                        PRBool aStreamHasHeaders)
32329: {
32329:     // Ensure stream is set and method is valid 
32329:     NS_ENSURE_TRUE(aStream, NS_ERROR_FAILURE);
32329: 
32329:     if (aContentLength < 0) {
32329:         PRUint32 streamLength;
32329:         aStream->Available(&streamLength);
32329:         aContentLength = streamLength;
32329:         if (aContentLength < 0) {
32329:             NS_ERROR("unable to determine content length");
32329:             return NS_ERROR_FAILURE;
32329:         }
32329:     }
32329: 
32329:     nsresult rv = SetRequestMethod(aMethod);
32329:     NS_ENSURE_SUCCESS(rv, rv);
32329: 
32329:     mRequestHead.SetHeader(nsHttp::Content_Length, nsPrintfCString("%lld", aContentLength));
32329:     mRequestHead.SetHeader(nsHttp::Content_Type, aContentType);
32329: 
32329:     mUploadStreamHasHeaders = aStreamHasHeaders;
32329:     mUploadStream = aStream;
32329:     return NS_OK;
32329: }
32329: 
32329: NS_IMETHODIMP
    1: nsHttpChannel::GetResponseStatus(PRUint32 *value)
    1: {
    1:     NS_ENSURE_ARG_POINTER(value);
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     *value = mResponseHead->Status();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetResponseStatusText(nsACString &value)
    1: {
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     value = mResponseHead->StatusText();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetRequestSucceeded(PRBool *value)
    1: {
    1:     NS_PRECONDITION(value, "Don't ever pass a null arg to this function");
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     PRUint32 status = mResponseHead->Status();
    1:     *value = (status / 100 == 2);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetResponseHeader(const nsACString &header, nsACString &value)
    1: {
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     nsHttpAtom atom = nsHttp::ResolveAtom(header);
    1:     if (!atom)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     return mResponseHead->GetHeader(atom, value);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetResponseHeader(const nsACString &header,
    1:                                  const nsACString &value,
    1:                                  PRBool merge)
    1: {
    1:     LOG(("nsHttpChannel::SetResponseHeader [this=%x header=\"%s\" value=\"%s\" merge=%u]\n",
    1:         this, PromiseFlatCString(header).get(), PromiseFlatCString(value).get(), merge));
    1: 
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     nsHttpAtom atom = nsHttp::ResolveAtom(header);
    1:     if (!atom)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // these response headers must not be changed 
    1:     if (atom == nsHttp::Content_Type ||
    1:         atom == nsHttp::Content_Length ||
    1:         atom == nsHttp::Content_Encoding ||
    1:         atom == nsHttp::Trailer ||
    1:         atom == nsHttp::Transfer_Encoding)
    1:         return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:     mResponseHeadersModified = PR_TRUE;
    1: 
    1:     return mResponseHead->SetHeader(atom, value, merge);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::VisitResponseHeaders(nsIHttpHeaderVisitor *visitor)
    1: {
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     return mResponseHead->Headers().VisitHeaders(visitor);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::IsNoStoreResponse(PRBool *value)
    1: {
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     *value = mResponseHead->NoStore();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::IsNoCacheResponse(PRBool *value)
    1: {
    1:     if (!mResponseHead)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     *value = mResponseHead->NoCache();
    1:     if (!*value)
    1:         *value = mResponseHead->ExpiresInPast();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetApplyConversion(PRBool *value)
    1: {
    1:     NS_ENSURE_ARG_POINTER(value);
    1:     *value = mApplyConversion;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetApplyConversion(PRBool value)
    1: {
    1:     LOG(("nsHttpChannel::SetApplyConversion [this=%x value=%d]\n", this, value));
    1:     mApplyConversion = value;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetAllowPipelining(PRBool *value)
    1: {
    1:     NS_ENSURE_ARG_POINTER(value);
    1:     *value = mAllowPipelining;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetAllowPipelining(PRBool value)
    1: {
    1:     if (mIsPending)
    1:         return NS_ERROR_FAILURE;
    1:     mAllowPipelining = value;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetRedirectionLimit(PRUint32 *value)
    1: {
    1:     NS_ENSURE_ARG_POINTER(value);
    1:     *value = PRUint32(mRedirectionLimit);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetRedirectionLimit(PRUint32 value)
    1: {
    1:     mRedirectionLimit = PR_MIN(value, 0xff);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetContentEncodings(nsIUTF8StringEnumerator** aEncodings)
    1: {
    1:     NS_PRECONDITION(aEncodings, "Null out param");
    1:     if (!mResponseHead) {
    1:         *aEncodings = nsnull;
    1:         return NS_OK;
    1:     }
    1:     
    1:     const char *encoding = mResponseHead->PeekHeader(nsHttp::Content_Encoding);
    1:     if (!encoding) {
    1:         *aEncodings = nsnull;
    1:         return NS_OK;
    1:     }
    1:     nsContentEncodings* enumerator = new nsContentEncodings(this, encoding);
    1:     if (!enumerator)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ADDREF(*aEncodings = enumerator);
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIHttpChannelInternal
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetDocumentURI(nsIURI **aDocumentURI)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aDocumentURI);
    1:     *aDocumentURI = mDocumentURI;
    1:     NS_IF_ADDREF(*aDocumentURI);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetDocumentURI(nsIURI *aDocumentURI)
    1: {
    1:     mDocumentURI = aDocumentURI;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29288: nsHttpChannel::GetForceAllowThirdPartyCookie(PRBool *aForceAllowThirdPartyCookie)
29288: {
29288:     *aForceAllowThirdPartyCookie = mForceAllowThirdPartyCookie;
29288:     return NS_OK;
29288: }
29288: 
29288: NS_IMETHODIMP
29288: nsHttpChannel::SetForceAllowThirdPartyCookie(PRBool aForceAllowThirdPartyCookie)
29288: {
29288:     mForceAllowThirdPartyCookie = aForceAllowThirdPartyCookie;
29288:     return NS_OK;
29288: }
29288: 
29288: NS_IMETHODIMP
    1: nsHttpChannel::GetRequestVersion(PRUint32 *major, PRUint32 *minor)
    1: {
    1:   int version = mRequestHead.Version();
    1: 
    1:   if (major) { *major = version / 10; }
    1:   if (minor) { *minor = version % 10; }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetResponseVersion(PRUint32 *major, PRUint32 *minor)
    1: {
    1:   if (!mResponseHead)
    1:   {
    1:     *major = *minor = 0;                   // we should at least be kind about it
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   int version = mResponseHead->Version();
    1: 
    1:   if (major) { *major = version / 10; }
    1:   if (minor) { *minor = version % 10; }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetCookie(const char *aCookieHeader)
    1: {
19954:     if (mLoadFlags & LOAD_ANONYMOUS) {
19954:       return NS_OK;
19954:     }
19954: 
    1:     // empty header isn't an error
    1:     if (!(aCookieHeader && *aCookieHeader))
    1:         return NS_OK;
    1: 
    1:     nsICookieService *cs = gHttpHandler->GetCookieService();
    1:     NS_ENSURE_TRUE(cs, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIPrompt> prompt;
    1:     GetCallback(prompt);
    1: 
    1:     return cs->SetCookieStringFromHttp(mURI,
    1:                                        mDocumentURI ? mDocumentURI : mOriginalURI,
    1:                                        prompt,
    1:                                        aCookieHeader,
    1:                                        mResponseHead->PeekHeader(nsHttp::Date),
    1:                                        this);
    1: }
    1: 
19925: NS_IMETHODIMP
19925: nsHttpChannel::SetupFallbackChannel(const char *aFallbackKey)
19925: {
19925:     LOG(("nsHttpChannel::SetupFallbackChannel [this=%x, key=%s]",
19925:          this, aFallbackKey));
19925:     mFallbackChannel = PR_TRUE;
19925:     mFallbackKey = aFallbackKey;
19925: 
19925:     return NS_OK;
19925: }
19925: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsISupportsPriority
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetPriority(PRInt32 *value)
    1: {
    1:     *value = mPriority;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetPriority(PRInt32 value)
    1: {
    1:     PRInt16 newValue = CLAMP(value, PR_INT16_MIN, PR_INT16_MAX);
    1:     if (mPriority == newValue)
    1:         return NS_OK;
    1:     mPriority = newValue;
    1:     if (mTransaction)
    1:         gHttpHandler->RescheduleTransaction(mTransaction, mPriority);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::AdjustPriority(PRInt32 delta)
    1: {
    1:     return SetPriority(mPriority + delta);
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIProtocolProxyCallback
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::OnProxyAvailable(nsICancelable *request, nsIURI *uri,
    1:                                 nsIProxyInfo *pi, nsresult status)
    1: {
    1:     mProxyRequest = nsnull;
    1: 
    1:     // If status is a failure code, then it means that we failed to resolve
    1:     // proxy info.  That is a non-fatal error assuming it wasn't because the
    1:     // request was canceled.  We just failover to DIRECT when proxy resolution
    1:     // fails (failure can mean that the PAC URL could not be loaded).
    1:     
    1:     // Need to replace this channel with a new one.  It would be complex to try
    1:     // to change the value of mConnectionInfo since so much of our state may
    1:     // depend on its state.
 5208:     mTargetProxyInfo = pi;
 5208:     HandleAsyncReplaceWithProxy();
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIProxiedChannel
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetProxyInfo(nsIProxyInfo **result)
    1: {
    1:     if (!mConnectionInfo)
    1:         *result = nsnull;
    1:     else {
    1:         *result = mConnectionInfo->ProxyInfo();
    1:         NS_IF_ADDREF(*result);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIRequestObserver
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
    1: {
    1:     if (!(mCanceled || NS_FAILED(mStatus))) {
    1:         // capture the request's status, so our consumers will know ASAP of any
    1:         // connection failures, etc - bug 93581
    1:         request->GetStatus(&mStatus);
    1:     }
    1: 
    1:     LOG(("nsHttpChannel::OnStartRequest [this=%x request=%x status=%x]\n",
    1:         this, request, mStatus));
    1: 
    1:     // Make sure things are what we expect them to be...
    1:     NS_ASSERTION(request == mCachePump || request == mTransactionPump,
    1:                  "Unexpected request");
    1:     NS_ASSERTION(!(mTransactionPump && mCachePump) || mCachedContentIsPartial,
    1:                  "If we have both pumps, the cache content must be partial");
    1: 
    1:     if (!mSecurityInfo && !mCachePump && mTransaction) {
    1:         // grab the security info from the connection object; the transaction
    1:         // is guaranteed to own a reference to the connection.
    1:         mSecurityInfo = mTransaction->SecurityInfo();
    1:     }
    1: 
    1:     // don't enter this block if we're reading from the cache...
    1:     if (NS_SUCCEEDED(mStatus) && !mCachePump && mTransaction) {
    1:         NS_ASSERTION(mResponseHead == nsnull, "leaking mResponseHead");
    1: 
    1:         // all of the response headers have been acquired, so we can take ownership
    1:         // of them from the transaction.
    1:         mResponseHead = mTransaction->TakeResponseHead();
    1:         // the response head may be null if the transaction was cancelled.  in
    1:         // which case we just need to call OnStartRequest/OnStopRequest.
    1:         if (mResponseHead)
    1:             return ProcessResponse();
    1: 
    1:         NS_WARNING("No response head in OnStartRequest");
    1:     }
    1: 
    1:     // avoid crashing if mListener happens to be null...
    1:     if (!mListener) {
    1:         NS_NOTREACHED("mListener is null");
    1:         return NS_OK;
    1:     }
    1: 
    1:     // on proxy errors, try to failover
    1:     if (mConnectionInfo->ProxyInfo() &&
    1:            (mStatus == NS_ERROR_PROXY_CONNECTION_REFUSED ||
    1:             mStatus == NS_ERROR_UNKNOWN_PROXY_HOST ||
    1:             mStatus == NS_ERROR_NET_TIMEOUT)) {
    1:         if (NS_SUCCEEDED(ProxyFailover()))
    1:             return NS_OK;
    1:     }
    1: 
19925:     // on other request errors, try to fall back
19925:     PRBool fallingBack;
19925:     if (NS_FAILED(mStatus) &&
19925:         NS_SUCCEEDED(ProcessFallback(&fallingBack)) &&
19925:         fallingBack) {
19925: 
19925:         return NS_OK;
19925:     }
19925: 
    1:     return CallOnStartRequest();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult status)
    1: {
    1:     LOG(("nsHttpChannel::OnStopRequest [this=%x request=%x status=%x]\n",
    1:         this, request, status));
    1: 
    1:     // honor the cancelation status even if the underlying transaction completed.
    1:     if (mCanceled || NS_FAILED(mStatus))
    1:         status = mStatus;
    1: 
    1:     if (mCachedContentIsPartial) {
    1:         if (NS_SUCCEEDED(status)) {
    1:             // mTransactionPump should be suspended
    1:             NS_ASSERTION(request != mTransactionPump,
    1:                 "byte-range transaction finished prematurely");
    1: 
    1:             if (request == mCachePump) {
    1:                 PRBool streamDone;
    1:                 status = OnDoneReadingPartialCacheEntry(&streamDone);
    1:                 if (NS_SUCCEEDED(status) && !streamDone)
    1:                     return status;
    1:                 // otherwise, fall through and fire OnStopRequest...
    1:             }
    1:             else
    1:                 NS_NOTREACHED("unexpected request");
    1:         }
    1:         // Do not to leave the transaction in a suspended state in error cases.
    1:         if (NS_FAILED(status) && mTransaction)
    1:             gHttpHandler->CancelTransaction(mTransaction, status); 
    1:     }
    1: 
    1:     if (mTransaction) {
    1:         // determine if we should call DoAuthRetry
    1:         PRBool authRetry = mAuthRetryPending && NS_SUCCEEDED(status);
    1: 
    1:         //
    1:         // grab reference to connection in case we need to retry an
    1:         // authentication request over it.  this applies to connection based
    1:         // authentication schemes only.  for request based schemes, conn is not
    1:         // needed, so it may be null.
    1:         // 
    1:         // this code relies on the code in nsHttpTransaction::Close, which
    1:         // tests for NS_HTTP_STICKY_CONNECTION to determine whether or not to
    1:         // keep the connection around after the transaction is finished.
    1:         //
    1:         nsRefPtr<nsAHttpConnection> conn;
30469:         if (authRetry && (mCaps & NS_HTTP_STICKY_CONNECTION)) {
    1:             conn = mTransaction->Connection();
30469:             // This is so far a workaround to fix leak when reusing unpersistent
30469:             // connection for authentication retry. See bug 459620 comment 4
30469:             // for details.
30469:             if (conn && !conn->IsPersistent())
30469:                 conn = nsnull;
30469:         }
    1: 
    1:         // at this point, we're done with the transaction
    1:         NS_RELEASE(mTransaction);
    1:         mTransactionPump = 0;
    1: 
    1:         // handle auth retry...
    1:         if (authRetry) {
    1:             mAuthRetryPending = PR_FALSE;
    1:             status = DoAuthRetry(conn);
    1:             if (NS_SUCCEEDED(status))
    1:                 return NS_OK;
    1:         }
    1: 
 4357:         // If DoAuthRetry failed, or if we have been cancelled since showing
 4357:         // the auth. dialog, then we need to send OnStartRequest now
 4357:         if (authRetry || (mAuthRetryPending && NS_FAILED(status))) {
 4357:             NS_ASSERTION(NS_FAILED(status), "should have a failure code here");
 4357:             // NOTE: since we have a failure status, we can ignore the return
 4357:             // value from onStartRequest.
 4357:             mListener->OnStartRequest(this, mListenerContext);
 4357:         }
 4357: 
    1:         // if this transaction has been replaced, then bail.
    1:         if (mTransactionReplaced)
    1:             return NS_OK;
    1:     }
    1: 
    1:     mIsPending = PR_FALSE;
    1:     mStatus = status;
    1: 
    1:     // perform any final cache operations before we close the cache entry.
    1:     if (mCacheEntry && (mCacheAccess & nsICache::ACCESS_WRITE))
    1:         FinalizeCacheEntry();
    1:     
    1:     if (mListener) {
    1:         LOG(("  calling OnStopRequest\n"));
    1:         mListener->OnStopRequest(this, mListenerContext, status);
    1:         mListener = 0;
    1:         mListenerContext = 0;
    1:     }
    1: 
    1:     if (mCacheEntry)
31698:         CloseCacheEntry(PR_TRUE);
    1: 
    1:     if (mOfflineCacheEntry)
    1:         CloseOfflineCacheEntry();
    1: 
    1:     if (mLoadGroup)
    1:         mLoadGroup->RemoveRequest(this, nsnull, status);
    1: 
    1:     mCallbacks = nsnull;
    1:     mProgressSink = nsnull;
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIStreamListener
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::OnDataAvailable(nsIRequest *request, nsISupports *ctxt,
    1:                                nsIInputStream *input,
    1:                                PRUint32 offset, PRUint32 count)
    1: {
    1:     LOG(("nsHttpChannel::OnDataAvailable [this=%x request=%x offset=%u count=%u]\n",
    1:         this, request, offset, count));
    1: 
    1:     // don't send out OnDataAvailable notifications if we've been canceled.
    1:     if (mCanceled)
    1:         return mStatus;
    1: 
    1:     NS_ASSERTION(mResponseHead, "No response head in ODA!!");
    1: 
    1:     NS_ASSERTION(!(mCachedContentIsPartial && (request == mTransactionPump)),
    1:             "transaction pump not suspended");
    1: 
    1:     if (mAuthRetryPending || (request == mTransactionPump && mTransactionReplaced)) {
    1:         PRUint32 n;
    1:         return input->ReadSegments(NS_DiscardSegment, nsnull, count, &n);
    1:     }
    1: 
    1:     if (mListener) {
    1:         //
    1:         // synthesize transport progress event.  we do this here since we want
    1:         // to delay OnProgress events until we start streaming data.  this is
    1:         // crucially important since it impacts the lock icon (see bug 240053).
    1:         //
    1:         nsresult transportStatus;
    1:         if (request == mCachePump)
    1:             transportStatus = nsITransport::STATUS_READING;
    1:         else
    1:             transportStatus = nsISocketTransport::STATUS_RECEIVING_FROM;
    1: 
    1:         // mResponseHead may reference new or cached headers, but either way it
    1:         // holds our best estimate of the total content length.  Even in the case
    1:         // of a byte range request, the content length stored in the cached
    1:         // response headers is what we want to use here.
    1: 
31382:         PRUint64 progressMax(PRUint64(mResponseHead->ContentLength()));
31382:         PRUint64 progress = mLogicalOffset + PRUint64(count);
    1:         NS_ASSERTION(progress <= progressMax, "unexpected progress values");
    1: 
    1:         OnTransportStatus(nsnull, transportStatus, progress, progressMax);
    1: 
    1:         //
    1:         // we have to manually keep the logical offset of the stream up-to-date.
 8132:         // we cannot depend solely on the offset provided, since we may have 
    1:         // already streamed some data from another source (see, for example,
    1:         // OnDoneReadingPartialCacheEntry).
    1:         //
    1:         nsresult rv =  mListener->OnDataAvailable(this,
    1:                                                   mListenerContext,
    1:                                                   input,
    1:                                                   mLogicalOffset,
    1:                                                   count);
    1:         if (NS_SUCCEEDED(rv))
    1:             mLogicalOffset = progress;
    1:         return rv;
    1:     }
    1: 
    1:     return NS_ERROR_ABORT;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsITransportEventSink
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::OnTransportStatus(nsITransport *trans, nsresult status,
    1:                                  PRUint64 progress, PRUint64 progressMax)
    1: {
    1:     // cache the progress sink so we don't have to query for it each time.
    1:     if (!mProgressSink)
    1:         GetCallback(mProgressSink);
    1: 
    1:     // block socket status event after Cancel or OnStopRequest has been called.
    1:     if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending && !(mLoadFlags & LOAD_BACKGROUND)) {
    1:         LOG(("sending status notification [this=%x status=%x progress=%llu/%llu]\n",
    1:             this, status, progress, progressMax));
    1: 
    1:         nsCAutoString host;
    1:         mURI->GetHost(host);
    1:         mProgressSink->OnStatus(this, nsnull, status,
    1:                                 NS_ConvertUTF8toUTF16(host).get());
    1: 
19099:         if (progress > 0) {
19099:             NS_ASSERTION(progress <= progressMax, "unexpected progress values");
    1:             mProgressSink->OnProgress(this, nsnull, progress, progressMax);
    1:         }
19099:     }
    1: #ifdef DEBUG
    1:     else
    1:         LOG(("skipping status notification [this=%x sink=%x pending=%u background=%x]\n",
    1:             this, mProgressSink.get(), mIsPending, (mLoadFlags & LOAD_BACKGROUND)));
    1: #endif
    1: 
    1:     return NS_OK;
    1: } 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsICachingChannel
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetCacheToken(nsISupports **token)
    1: {
    1:     NS_ENSURE_ARG_POINTER(token);
    1:     if (!mCacheEntry)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     return CallQueryInterface(mCacheEntry, token);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetCacheToken(nsISupports *token)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
10900: nsHttpChannel::GetOfflineCacheToken(nsISupports **token)
10900: {
10900:     NS_ENSURE_ARG_POINTER(token);
10900:     if (!mOfflineCacheEntry)
10900:         return NS_ERROR_NOT_AVAILABLE;
10900:     return CallQueryInterface(mOfflineCacheEntry, token);
10900: }
10900: 
10900: NS_IMETHODIMP
10900: nsHttpChannel::SetOfflineCacheToken(nsISupports *token)
10900: {
10900:     return NS_ERROR_NOT_IMPLEMENTED;
10900: }
10900: 
10900: NS_IMETHODIMP
    1: nsHttpChannel::GetCacheKey(nsISupports **key)
    1: {
    1:     nsresult rv;
    1:     NS_ENSURE_ARG_POINTER(key);
    1: 
    1:     LOG(("nsHttpChannel::GetCacheKey [this=%x]\n", this));
    1: 
    1:     *key = nsnull;
    1: 
    1:     nsCOMPtr<nsISupportsPRUint32> container =
    1:         do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = container->SetData(mPostID);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return CallQueryInterface(container, key);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetCacheKey(nsISupports *key)
    1: {
    1:     nsresult rv;
    1: 
    1:     LOG(("nsHttpChannel::SetCacheKey [this=%x key=%x]\n", this, key));
    1: 
    1:     // can only set the cache key if a load is not in progress
    1:     NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
    1: 
    1:     if (!key)
    1:         mPostID = 0;
    1:     else {
    1:         // extract the post id
    1:         nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(key, &rv);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         rv = container->GetData(&mPostID);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetCacheAsFile(PRBool *value)
    1: {
    1:     NS_ENSURE_ARG_POINTER(value);
    1:     if (!mCacheEntry)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     nsCacheStoragePolicy storagePolicy;
    1:     mCacheEntry->GetStoragePolicy(&storagePolicy);
    1:     *value = (storagePolicy == nsICache::STORE_ON_DISK_AS_FILE);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetCacheAsFile(PRBool value)
    1: {
    1:     if (!mCacheEntry || mLoadFlags & INHIBIT_PERSISTENT_CACHING)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     nsCacheStoragePolicy policy;
    1:     if (value)
    1:         policy = nsICache::STORE_ON_DISK_AS_FILE;
    1:     else
    1:         policy = nsICache::STORE_ANYWHERE;
    1:     return mCacheEntry->SetStoragePolicy(policy);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetCacheForOfflineUse(PRBool *value)
    1: {
    1:     *value = mCacheForOfflineUse;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::SetCacheForOfflineUse(PRBool value)
    1: {
    1:     mCacheForOfflineUse = value;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 3947: nsHttpChannel::GetOfflineCacheClientID(nsACString &value)
 3947: {
 3947:     value = mOfflineCacheClientID;
 3947: 
 3947:     return NS_OK;
 3947: }
 3947: 
 3947: NS_IMETHODIMP
 3947: nsHttpChannel::SetOfflineCacheClientID(const nsACString &value)
 3947: {
 3947:     mOfflineCacheClientID = value;
 3947: 
 3947:     return NS_OK;
 3947: }
 3947: 
 3947: NS_IMETHODIMP
    1: nsHttpChannel::GetCacheFile(nsIFile **cacheFile)
    1: {
    1:     if (!mCacheEntry)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     return mCacheEntry->GetFile(cacheFile);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::IsFromCache(PRBool *value)
    1: {
    1:     if (!mIsPending)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // return false if reading a partial cache entry; the data isn't entirely
    1:     // from the cache!
    1: 
    1:     *value = (mCachePump || (mLoadFlags & LOAD_ONLY_IF_MODIFIED)) &&
    1:               mCachedContentIsValid && !mCachedContentIsPartial;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsIResumableChannel
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::ResumeAt(PRUint64 aStartPos,
    1:                         const nsACString& aEntityID)
    1: {
 5258:     LOG(("nsHttpChannel::ResumeAt [this=%p startPos=%llu id='%s']\n",
 5258:          this, aStartPos, PromiseFlatCString(aEntityID).get()));
    1:     mEntityID = aEntityID;
    1:     mStartPos = aStartPos;
    1:     mResuming = PR_TRUE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::GetEntityID(nsACString& aEntityID)
    1: {
11008:     // Don't return an entity ID for Non-GET requests which require
11008:     // additional data
    1:     if (mRequestHead.Method() != nsHttp::Get) {
    1:         return NS_ERROR_NOT_RESUMABLE;
    1:     }
    1: 
22105:     // Don't return an entity if the server sent the following header:
22105:     // Accept-Ranges: none
22105:     // Not sending the Accept-Ranges header means we can still try
22105:     // sending range requests.
22105:     const char* acceptRanges =
22105:         mResponseHead->PeekHeader(nsHttp::Accept_Ranges);
22105:     if (acceptRanges &&
22105:         !nsHttp::FindToken(acceptRanges, "bytes", HTTP_HEADER_VALUE_SEPS)) {
22105:         return NS_ERROR_NOT_RESUMABLE;
22105:     }
22105: 
    1:     PRUint64 size = LL_MAXUINT;
    1:     nsCAutoString etag, lastmod;
    1:     if (mResponseHead) {
    1:         size = mResponseHead->TotalEntitySize();
    1:         const char* cLastMod = mResponseHead->PeekHeader(nsHttp::Last_Modified);
    1:         if (cLastMod)
    1:             lastmod = cLastMod;
    1:         const char* cEtag = mResponseHead->PeekHeader(nsHttp::ETag);
    1:         if (cEtag)
    1:             etag = cEtag;
    1:     }
    1:     nsCString entityID;
    1:     NS_EscapeURL(etag.BeginReading(), etag.Length(), esc_AlwaysCopy |
    1:             esc_FileBaseName | esc_Forced, entityID);
    1:     entityID.Append('/');
    1:     entityID.AppendInt(PRInt64(size));
    1:     entityID.Append('/');
    1:     entityID.Append(lastmod);
    1:     // NOTE: Appending lastmod as the last part avoids having to escape it
    1: 
    1:     aEntityID = entityID;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsICacheListener
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::OnCacheEntryAvailable(nsICacheEntryDescriptor *entry,
    1:                                      nsCacheAccessMode access,
    1:                                      nsresult status)
    1: {
    1:     LOG(("nsHttpChannel::OnCacheEntryAvailable [this=%x entry=%x "
    1:          "access=%x status=%x]\n", this, entry, access, status));
    1: 
    1:     // if the channel's already fired onStopRequest, then we should ignore
    1:     // this event.
    1:     if (!mIsPending)
    1:         return NS_OK;
    1: 
    1:     // otherwise, we have to handle this event.
    1:     if (NS_SUCCEEDED(status)) {
    1:         mCacheEntry = entry;
    1:         mCacheAccess = access;
    1:     }
    1: 
    1:     nsresult rv;
    1: 
    1:     if (mCanceled && NS_FAILED(mStatus)) {
    1:         LOG(("channel was canceled [this=%x status=%x]\n", this, mStatus));
    1:         rv = mStatus;
    1:     }
    1:     else if ((mLoadFlags & LOAD_ONLY_FROM_CACHE) && NS_FAILED(status))
    1:         // if this channel is only allowed to pull from the cache, then
    1:         // we must fail if we were unable to open a cache entry.
    1:         rv = NS_ERROR_DOCUMENT_NOT_CACHED;
    1:     else
    1:         // advance to the next state...
    1:         rv = Connect(PR_FALSE);
    1: 
    1:     // a failure from Connect means that we have to abort the channel.
    1:     if (NS_FAILED(rv)) {
19028:         CloseCacheEntry(PR_TRUE);
    1:         AsyncAbort(rv);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHttpChannel::DoAuthRetry(nsAHttpConnection *conn)
    1: {
    1:     LOG(("nsHttpChannel::DoAuthRetry [this=%x]\n", this));
    1: 
    1:     NS_ASSERTION(!mTransaction, "should not have a transaction");
    1:     nsresult rv;
    1: 
    1:     // toggle mIsPending to allow nsIObserver implementations to modify
    1:     // the request headers (bug 95044).
    1:     mIsPending = PR_FALSE;
    1: 
    1:     // fetch cookies, and add them to the request header.
    1:     // the server response could have included cookies that must be sent with
    1:     // this authentication attempt (bug 84794).
    1:     AddCookiesToRequest();
    1: 
    1:     // notify "http-on-modify-request" observers
    1:     gHttpHandler->OnModifyRequest(this);
    1: 
    1:     mIsPending = PR_TRUE;
    1: 
    1:     // get rid of the old response headers
    1:     delete mResponseHead;
    1:     mResponseHead = nsnull;
    1: 
    1:     // set sticky connection flag and disable pipelining.
    1:     mCaps |=  NS_HTTP_STICKY_CONNECTION;
    1:     mCaps &= ~NS_HTTP_ALLOW_PIPELINING;
    1:    
    1:     // and create a new one...
    1:     rv = SetupTransaction();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // transfer ownership of connection to transaction
    1:     if (conn)
    1:         mTransaction->SetConnection(conn);
    1: 
    1:     // rewind the upload stream
    1:     if (mUploadStream) {
    1:         nsCOMPtr<nsISeekableStream> seekable = do_QueryInterface(mUploadStream);
    1:         if (seekable)
    1:             seekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
    1:     }
    1: 
    1:     rv = gHttpHandler->InitiateTransaction(mTransaction, mPriority);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return mTransactionPump->AsyncRead(this, nsnull);
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
21311: // nsHttpChannel::nsIApplicationCacheChannel
18430: //-----------------------------------------------------------------------------
18430: NS_IMETHODIMP
18430: nsHttpChannel::GetApplicationCache(nsIApplicationCache **out)
18430: {
18430:     NS_IF_ADDREF(*out = mApplicationCache);
18430:     return NS_OK;
18430: }
18430: 
18430: NS_IMETHODIMP
18430: nsHttpChannel::SetApplicationCache(nsIApplicationCache *appCache)
18430: {
21311:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
21311: 
18430:     mApplicationCache = appCache;
18430:     return NS_OK;
18430: }
18430: 
21311: NS_IMETHODIMP
21367: nsHttpChannel::GetLoadedFromApplicationCache(PRBool *aLoadedFromApplicationCache)
21367: {
21367:     *aLoadedFromApplicationCache = mLoadedFromApplicationCache;
21367:     return NS_OK;
21367: }
21367: 
21367: NS_IMETHODIMP
21311: nsHttpChannel::GetInheritApplicationCache(PRBool *aInherit)
21311: {
21311:     *aInherit = mInheritApplicationCache;
21311:     return NS_OK;
21311: }
21311: 
21311: NS_IMETHODIMP
21311: nsHttpChannel::SetInheritApplicationCache(PRBool aInherit)
21311: {
21311:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
21311: 
21311:     mInheritApplicationCache = aInherit;
21311:     return NS_OK;
21311: }
21311: 
21311: NS_IMETHODIMP
21311: nsHttpChannel::GetChooseApplicationCache(PRBool *aChoose)
21311: {
21311:     *aChoose = mChooseApplicationCache;
21311:     return NS_OK;
21311: }
21311: 
21311: NS_IMETHODIMP
21311: nsHttpChannel::SetChooseApplicationCache(PRBool aChoose)
21311: {
21311:     NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
21311: 
21311:     mChooseApplicationCache = aChoose;
21311:     return NS_OK;
21311: }
18430: 
18430: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsContentEncodings <public>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsHttpChannel::nsContentEncodings::nsContentEncodings(nsIHttpChannel* aChannel,
    1:                                                           const char* aEncodingHeader) :
    1:     mEncodingHeader(aEncodingHeader), mChannel(aChannel), mReady(PR_FALSE)
    1: {
    1:     mCurEnd = aEncodingHeader + strlen(aEncodingHeader);
    1:     mCurStart = mCurEnd;
    1: }
    1:     
    1: nsHttpChannel::nsContentEncodings::~nsContentEncodings()
    1: {
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsContentEncodings::nsISimpleEnumerator
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::nsContentEncodings::HasMore(PRBool* aMoreEncodings)
    1: {
    1:     if (mReady) {
    1:         *aMoreEncodings = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1:     
    1:     nsresult rv = PrepareForNext();
    1:     *aMoreEncodings = NS_SUCCEEDED(rv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHttpChannel::nsContentEncodings::GetNext(nsACString& aNextEncoding)
    1: {
    1:     aNextEncoding.Truncate();
    1:     if (!mReady) {
    1:         nsresult rv = PrepareForNext();
    1:         if (NS_FAILED(rv)) {
    1:             return NS_ERROR_FAILURE;
    1:         }
    1:     }
    1: 
    1:     const nsACString & encoding = Substring(mCurStart, mCurEnd);
    1: 
    1:     nsACString::const_iterator start, end;
    1:     encoding.BeginReading(start);
    1:     encoding.EndReading(end);
    1: 
    1:     PRBool haveType = PR_FALSE;
    1:     if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("gzip"),
    1:                                       start,
    1:                                       end)) {
    1:         aNextEncoding.AssignLiteral(APPLICATION_GZIP);
    1:         haveType = PR_TRUE;
    1:     }
    1: 
    1:     if (!haveType) {
    1:         encoding.BeginReading(start);
    1:         if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("compress"),
    1:                                           start,
    1:                                           end)) {
    1:             aNextEncoding.AssignLiteral(APPLICATION_COMPRESS);
    1:                                            
    1:             haveType = PR_TRUE;
    1:         }
    1:     }
    1:     
    1:     if (! haveType) {
    1:         encoding.BeginReading(start);
    1:         if (CaseInsensitiveFindInReadable(NS_LITERAL_CSTRING("deflate"),
    1:                                           start,
    1:                                           end)) {
    1:             aNextEncoding.AssignLiteral(APPLICATION_ZIP);
    1:             haveType = PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     // Prepare to fetch the next encoding
    1:     mCurEnd = mCurStart;
    1:     mReady = PR_FALSE;
    1:     
    1:     if (haveType)
    1:         return NS_OK;
    1: 
    1:     NS_WARNING("Unknown encoding type");
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsContentEncodings::nsISupports
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMPL_ISUPPORTS1(nsHttpChannel::nsContentEncodings, nsIUTF8StringEnumerator)
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsHttpChannel::nsContentEncodings <private>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsHttpChannel::nsContentEncodings::PrepareForNext(void)
    1: {
    1:     NS_PRECONDITION(mCurStart == mCurEnd, "Indeterminate state");
    1:     
    1:     // At this point both mCurStart and mCurEnd point to somewhere
    1:     // past the end of the next thing we want to return
    1:     
    1:     while (mCurEnd != mEncodingHeader) {
    1:         --mCurEnd;
    1:         if (*mCurEnd != ',' && !nsCRT::IsAsciiSpace(*mCurEnd))
    1:             break;
    1:     }
    1:     if (mCurEnd == mEncodingHeader)
    1:         return NS_ERROR_NOT_AVAILABLE; // no more encodings
    1:     ++mCurEnd;
    1:         
    1:     // At this point mCurEnd points to the first char _after_ the
    1:     // header we want.  Furthermore, mCurEnd - 1 != mEncodingHeader
    1:     
    1:     mCurStart = mCurEnd - 1;
    1:     while (mCurStart != mEncodingHeader &&
    1:            *mCurStart != ',' && !nsCRT::IsAsciiSpace(*mCurStart))
    1:         --mCurStart;
    1:     if (*mCurStart == ',' || nsCRT::IsAsciiSpace(*mCurStart))
    1:         ++mCurStart; // we stopped because of a weird char, so move up one
    1:         
    1:     // At this point mCurStart and mCurEnd bracket the encoding string
    1:     // we want.  Check that it's not "identity"
    1:     if (Substring(mCurStart, mCurEnd).Equals("identity",
    1:                                              nsCaseInsensitiveCStringComparator())) {
    1:         mCurEnd = mCurStart;
    1:         return PrepareForNext();
    1:     }
    1:         
    1:     mReady = PR_TRUE;
    1:     return NS_OK;
    1: }
18377: 
18377: //-----------------------------------------------------------------------------
18377: // nsStreamListenerWrapper <private>
18377: //-----------------------------------------------------------------------------
18377: 
18377: // Wrapper class to make replacement of nsHttpChannel's listener
18377: // from JavaScript possible. It is workaround for bug 433711.
18377: class nsStreamListenerWrapper : public nsIStreamListener
18377: {
18377: public:
18377:     nsStreamListenerWrapper(nsIStreamListener *listener);
18377: 
18377:     NS_DECL_ISUPPORTS
18377:     NS_FORWARD_NSIREQUESTOBSERVER(mListener->)
18377:     NS_FORWARD_NSISTREAMLISTENER(mListener->)
18377: 
18377: private:
18377:     ~nsStreamListenerWrapper() {}
18377:     nsCOMPtr<nsIStreamListener> mListener;
18377: };
18377: 
18377: nsStreamListenerWrapper::nsStreamListenerWrapper(nsIStreamListener *listener)
18377:     : mListener(listener) 
18377: {
18377:     NS_ASSERTION(mListener, "no stream listener specified");
18377: }
18377: 
18377: NS_IMPL_ISUPPORTS2(nsStreamListenerWrapper,
18377:                    nsIStreamListener,
18377:                    nsIRequestObserver)
18377: 
18377: //-----------------------------------------------------------------------------
18377: // nsHttpChannel::nsITraceableChannel
18377: //-----------------------------------------------------------------------------
18377: 
18377: NS_IMETHODIMP
18377: nsHttpChannel::SetNewListener(nsIStreamListener *aListener, nsIStreamListener **_retval)
18377: {
18377:     if (!mTracingEnabled)
18377:         return NS_ERROR_FAILURE;
18377: 
18377:     NS_ENSURE_ARG_POINTER(aListener);
18377: 
18377:     nsCOMPtr<nsIStreamListener> wrapper = 
18377:         new nsStreamListenerWrapper(mListener);
18377: 
18377:     if (!wrapper)
18377:         return NS_ERROR_OUT_OF_MEMORY;
18377: 
18377:     wrapper.forget(_retval);
18377:     mListener = aListener;
18377:     return NS_OK;
18377: }
20265: 
20265: void
20265: nsHttpChannel::MaybeInvalidateCacheEntryForSubsequentGet()
20265: {
20265:     // See RFC 2616 section 5.1.1. These are considered valid
20265:     // methods which DO NOT invalidate cache-entries for the
20265:     // referred resource. POST, PUT and DELETE as well as any
20265:     // other method not listed here will potentially invalidate
20265:     // any cached copy of the resource
20265:     if (mRequestHead.Method() == nsHttp::Options ||
20265:        mRequestHead.Method() == nsHttp::Get ||
20265:        mRequestHead.Method() == nsHttp::Head ||
20265:        mRequestHead.Method() == nsHttp::Trace ||
20265:        mRequestHead.Method() == nsHttp::Connect)
20265:         return;
20265:         
20265:     // NOTE:
20265:     // Following comments 24,32 and 33 in bug #327765, we only care about
20265:     // the cache in the protocol-handler.
20265:     // The logic below deviates from the original logic in OpenCacheEntry on
20265:     // one point by using only READ_ONLY access-policy. I think this is safe.
20265:     LOG(("MaybeInvalidateCacheEntryForSubsequentGet [this=%x]\n", this));
20265: 
20265:     nsCAutoString tmpCacheKey;
20265:     // passing 0 in first param gives the cache-key for a GET to my resource
20265:     GenerateCacheKey(0, tmpCacheKey);
20265: 
20265:     // Now, find the session holding the cache-entry
20265:     nsCOMPtr<nsICacheSession> session;
20265:     nsCacheStoragePolicy storagePolicy = DetermineStoragePolicy();
20265: 
20265:     nsresult rv;
20265:     rv = gHttpHandler->GetCacheSession(storagePolicy,
20265:                                        getter_AddRefs(session));
20265: 
20265:     if (NS_FAILED(rv)) return;
20265: 
20265:     // Finally, find the actual cache-entry
20265:     nsCOMPtr<nsICacheEntryDescriptor> tmpCacheEntry;
20265:     rv = session->OpenCacheEntry(tmpCacheKey, nsICache::ACCESS_READ,
20265:                                  PR_FALSE,
20265:                                  getter_AddRefs(tmpCacheEntry));
20265:     
20265:     // If entry was found, set its expiration-time = 0
20265:     if(NS_SUCCEEDED(rv)) {
20265:        tmpCacheEntry->SetExpirationTime(0);
20265:     }
20265: }
20265: 
20265: nsCacheStoragePolicy
20265: nsHttpChannel::DetermineStoragePolicy()
20265: {
20265:     nsCacheStoragePolicy policy = nsICache::STORE_ANYWHERE;
20265:     if (mLoadFlags & INHIBIT_PERSISTENT_CACHING)
20265:         policy = nsICache::STORE_IN_MEMORY;
20265: 
20265:     return policy;
20265: }
20265: 
24936: void
24936: nsHttpChannel::AsyncOnExamineCachedResponse()
24936: {
24936:     gHttpHandler->OnExamineCachedResponse(this);
24936: }
