    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * construction of a frame tree that is nearly isomorphic to the content
    1:  * tree and updating of that tree in response to dynamic changes
    1:  */
    1: 
    1: #ifndef nsCSSFrameConstructor_h___
    1: #define nsCSSFrameConstructor_h___
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsIXBLService.h"
    1: #include "nsQuoteList.h"
    1: #include "nsCounterManager.h"
    1: #include "nsHashKeys.h"
    1: #include "nsThreadUtils.h"
 4347: #include "nsPageContentFrame.h"
35554: #include "nsCSSPseudoElements.h"
43788: #include "RestyleTracker.h"
    1: 
    1: class nsIDocument;
    1: struct nsFrameItems;
    1: struct nsAbsoluteItems;
    1: class nsStyleContext;
    1: struct nsStyleContent;
    1: struct nsStyleDisplay;
    1: class nsIPresShell;
    1: class nsFrameManager;
    1: class nsIDOMHTMLSelectElement;
    1: class nsPresContext;
    1: class nsStyleChangeList;
    1: class nsIFrame;
16976: struct nsGenConInitializer;
24404: class ChildIterator;
26208: class nsICSSAnonBoxPseudo;
33649: class nsPageContentFrame;
34614: struct PendingBinding;
50365: class nsRefreshDriver;
    1: 
    1: class nsFrameConstructorState;
    1: class nsFrameConstructorSaveState;
    1: 
50365: class nsCSSFrameConstructor
    1: {
50365:   friend class nsRefreshDriver;
50365: 
    1: public:
42329:   typedef mozilla::dom::Element Element;
43788:   typedef mozilla::css::RestyleTracker RestyleTracker;
42329: 
    1:   nsCSSFrameConstructor(nsIDocument *aDocument, nsIPresShell* aPresShell);
23008:   ~nsCSSFrameConstructor(void) {
23008:     NS_ASSERTION(mUpdateCount == 0, "Dying in the middle of our own update?");
23008:   }
    1: 
32401:   struct RestyleData;
32401:   friend struct RestyleData;
32401: 
    1:   // Maintain global objects - gXBLService
    1:   static nsIXBLService * GetXBLService();
    1:   static void ReleaseGlobals() { NS_IF_RELEASE(gXBLService); }
    1: 
    1:   // get the alternate text for a content node
    1:   static void GetAlternateTextFor(nsIContent*    aContent,
    1:                                   nsIAtom*       aTag,  // content object's tag
    1:                                   nsXPIDLString& aAltText);
36646: 
    1: private: 
    1:   // These are not supported and are not implemented! 
    1:   nsCSSFrameConstructor(const nsCSSFrameConstructor& aCopy); 
    1:   nsCSSFrameConstructor& operator=(const nsCSSFrameConstructor& aCopy); 
    1: 
    1: public:
    1:   // XXXbz this method needs to actually return errors!
28215:   nsresult ConstructRootFrame(nsIFrame** aNewFrame);
    1: 
    1:   nsresult ReconstructDocElementHierarchy();
    1: 
40938:   // Create frames for content nodes that are marked as needing frames. This
40938:   // should be called before ProcessPendingRestyles.
40938:   // Note: It's the caller's responsibility to make sure to wrap a
40938:   // CreateNeededFrames call in a view update batch and a script blocker.
40938:   void CreateNeededFrames();
40938: 
40938: private:
40938:   void CreateNeededFrames(nsIContent* aContent);
40938: 
40938:   enum Operation {
40938:     CONTENTAPPEND,
40938:     CONTENTINSERT
40938:   };
40938: 
47659:   // aChild is the child being inserted for inserts, and the first
47659:   // child being appended for appends.
40938:   PRBool MaybeConstructLazily(Operation aOperation,
40938:                               nsIContent* aContainer,
47659:                               nsIContent* aChild);
40938: 
40939:   // Issues a single ContentInserted for each child of aContainer in the range
47667:   // [aStartChild, aEndChild).
40939:   void IssueSingleInsertNofications(nsIContent* aContainer,
47667:                                     nsIContent* aStartChild,
47667:                                     nsIContent* aEndChild,
40939:                                     PRBool aAllowLazyConstruction);
40939:   
47664:   // Checks if the children of aContainer in the range [aStartChild, aEndChild)
47664:   // can be inserted/appended to one insertion point together. If so, returns
47664:   // that insertion point. If not, returns null and issues single
47664:   // ContentInserted calls for each child.  aEndChild = nsnull indicates that we
47664:   // are dealing with an append.
40939:   nsIFrame* GetRangeInsertionPoint(nsIContent* aContainer,
40939:                                    nsIFrame* aParentFrame,
47664:                                    nsIContent* aStartChild,
47664:                                    nsIContent* aEndChild,
40939:                                    PRBool aAllowLazyConstruction);
40939: 
40939:   // Returns true if parent was recreated due to frameset child, false otherwise.
47658:   PRBool MaybeRecreateForFrameset(nsIFrame* aParentFrame,
47658:                                   nsIContent* aStartChild,
47658:                                   nsIContent* aEndChild);
40939: 
40938: public:
40938:   /**
40938:    * Lazy frame construction is controlled by the aAllowLazyConstruction bool
40938:    * parameter of nsCSSFrameConstructor::ContentAppended/Inserted. It is true
40938:    * for all inserts/appends as passed from the presshell, except for the
40938:    * insert of the root element, which is always non-lazy. Even if the
40938:    * aAllowLazyConstruction passed to ContentAppended/Inserted is true we still
40938:    * may not be able to construct lazily, so we call MaybeConstructLazily.
40938:    * MaybeConstructLazily does not allow lazy construction if any of the
40938:    * following are true:
40938:    *  -we are in chrome
40938:    *  -the container is in a native anonymous subtree
40938:    *  -the container is XUL
40938:    *  -is any of the appended/inserted nodes are XUL or editable
47659:    *  -(for inserts) the child is anonymous.  In the append case this function
47659:    *   must not be called with anonymous children.
40938:    * The XUL and chrome checks are because XBL bindings only get applied at
40938:    * frame construction time and some things depend on the bindings getting
40938:    * attached synchronously. The editable checks are because the editor seems
40938:    * to expect frames to be constructed synchronously.
40938:    *
40938:    * If MaybeConstructLazily returns false we construct as usual, but if it
40938:    * returns true then it adds NODE_NEEDS_FRAME bits to the newly
40938:    * inserted/appended nodes and adds NODE_DESCENDANTS_NEED_FRAMES bits to the
40938:    * container and up along the parent chain until it hits the root or another
40938:    * node with that bit set. Then it posts a restyle event to ensure that a
40938:    * flush happens to construct those frames.
40938:    *
40938:    * When the flush happens the presshell calls
40938:    * nsCSSFrameConstructor::CreateNeededFrames. CreateNeededFrames follows any
40938:    * nodes with NODE_DESCENDANTS_NEED_FRAMES set down the content tree looking
40938:    * for nodes with NODE_NEEDS_FRAME set. It calls ContentAppended for any runs
40938:    * of nodes with NODE_NEEDS_FRAME set that are at the end of their childlist,
40939:    * and ContentRangeInserted for any other runs that aren't.
40938:    *
40938:    * If a node is removed from the document then we don't bother unsetting any
40938:    * of the lazy bits that might be set on it, its descendants, or any of its
40938:    * ancestor nodes because that is a slow operation, the work might be wasted
40938:    * if another node gets inserted in its place, and we can clear the bits
40938:    * quicker by processing the content tree from top down the next time we call
40938:    * CreateNeededFrames. (We do clear the bits when BindToTree is called on any
40938:    * nsIContent; so any nodes added to the document will not have any lazy bits
40938:    * set.)
40938:    */
40938: 
40938:   // If aAllowLazyConstruction is true then frame construction of the new
40938:   // children can be done lazily.
    1:   nsresult ContentAppended(nsIContent* aContainer,
42107:                            nsIContent* aFirstNewContent,
40938:                            PRBool      aAllowLazyConstruction);
    1: 
40938:   // If aAllowLazyConstruction is true then frame construction of the new child
40938:   // can be done lazily.
    1:   nsresult ContentInserted(nsIContent*            aContainer,
    1:                            nsIContent*            aChild,
40938:                            nsILayoutHistoryState* aFrameState,
40938:                            PRBool                 aAllowLazyConstruction);
    1: 
40939:   // Like ContentInserted but handles inserting the children of aContainer in
47667:   // the range [aStartChild, aEndChild).  aStartChild must be non-null.
47667:   // aEndChild may be null to indicate the range includes all kids after
47667:   // aStartChild.  If aAllowLazyConstruction is true then frame construction of
47656:   // the new children can be done lazily. It is only allowed to be true when
47656:   // inserting a single node.
40939:   nsresult ContentRangeInserted(nsIContent*            aContainer,
47656:                                 nsIContent*            aStartChild,
47656:                                 nsIContent*            aEndChild,
40939:                                 nsILayoutHistoryState* aFrameState,
40939:                                 PRBool                 aAllowLazyConstruction);
40939: 
29501:   enum RemoveFlags { REMOVE_CONTENT, REMOVE_FOR_RECONSTRUCTION };
    1:   nsresult ContentRemoved(nsIContent* aContainer,
    1:                           nsIContent* aChild,
47669:                           nsIContent* aOldNextSibling,
29501:                           RemoveFlags aFlags,
 7681:                           PRBool*     aDidReconstruct);
    1: 
    1:   nsresult CharacterDataChanged(nsIContent* aContent,
31131:                                 CharacterDataChangeInfo* aInfo);
    1: 
    1:   nsresult ContentStatesChanged(nsIContent*     aContent1,
    1:                                 nsIContent*     aContent2,
    1:                                 PRInt32         aStateMask);
    1: 
52061:   // generate the child frames and process bindings
52061:   nsresult GenerateChildFrames(nsIFrame* aFrame);
 3129: 
    1:   // Should be called when a frame is going to be destroyed and
    1:   // WillDestroyFrameTree hasn't been called yet.
    1:   void NotifyDestroyingFrame(nsIFrame* aFrame);
    1: 
51352:   void AttributeWillChange(Element* aElement,
35534:                            PRInt32  aNameSpaceID,
35534:                            nsIAtom* aAttribute,
35534:                            PRInt32  aModType);
51350:   void AttributeChanged(Element* aElement,
    1:                         PRInt32  aNameSpaceID,
    1:                         nsIAtom* aAttribute,
35535:                         PRInt32  aModType);
    1: 
11856:   void BeginUpdate();
    1:   void EndUpdate();
  550:   void RecalcQuotesAndCounters();
    1: 
26803:   // Gets called when the presshell is destroying itself and also
26803:   // when we tear down our frame tree to reconstruct it
26803:   void WillDestroyFrameTree();
    1: 
22471:   // Get an integer that increments every time there is a style change
22471:   // as a result of a change to the :hover content state.
22471:   PRUint32 GetHoverGeneration() const { return mHoverGeneration; }
22471: 
    1:   // Note: It's the caller's responsibility to make sure to wrap a
23652:   // ProcessRestyledFrames call in a view update batch and a script blocker.
    1:   // This function does not call ProcessAttachedQueue() on the binding manager.
    1:   // If the caller wants that to happen synchronously, it needs to handle that
    1:   // itself.
    1:   nsresult ProcessRestyledFrames(nsStyleChangeList& aRestyleArray);
    1: 
    1: private:
11856: 
43788:   friend class mozilla::css::RestyleTracker;
    1: 
42349:   void RestyleForEmptyChange(Element* aContainer);
42349: 
    1: public:
11845:   // Restyling for a ContentInserted (notification after insertion) or
11845:   // for a CharacterDataChanged.  |aContainer| must be non-null; when
11845:   // the container is null, no work is needed.
42329:   void RestyleForInsertOrChange(Element* aContainer, nsIContent* aChild);
42329: 
11845:   // This would be the same as RestyleForInsertOrChange if we got the
47668:   // notification before the removal.  However, we get it after, so we need the
47668:   // following sibling in addition to the old child.  |aContainer| must be
47668:   // non-null; when the container is null, no work is needed.  aFollowingSibling
47668:   // is the sibling that used to come after aOldChild before the removal.
42329:   void RestyleForRemove(Element* aContainer,
42324:                         nsIContent* aOldChild,
42324:                         nsIContent* aFollowingSibling);
11845:   // Same for a ContentAppended.  |aContainer| must be non-null; when
11845:   // the container is null, no work is needed.
42329:   void RestyleForAppend(Element* aContainer, nsIContent* aFirstNewContent);
11845: 
40938:   // Process any pending restyles. This should be called after
40938:   // CreateNeededFrames.
    1:   // Note: It's the caller's responsibility to make sure to wrap a
23652:   // ProcessPendingRestyles call in a view update batch and a script blocker.
 5872:   // This function does not call ProcessAttachedQueue() on the binding manager.
 5872:   // If the caller wants that to happen synchronously, it needs to handle that
 5872:   // itself.
    1:   void ProcessPendingRestyles();
    1:   
22339:   // Rebuilds all style data by throwing out the old rule tree and
22339:   // building a new one, and additionally applying aExtraHint (which
22339:   // must not contain nsChangeHint_ReconstructFrame) to the root frame.
11409:   void RebuildAllStyleData(nsChangeHint aExtraHint);
10073: 
32401:   // See PostRestyleEventCommon below.
42329:   void PostRestyleEvent(Element* aElement,
42328:                         nsRestyleHint aRestyleHint,
32401:                         nsChangeHint aMinChangeHint)
32401:   {
32401:     nsPresContext *presContext = mPresShell->GetPresContext();
32401:     if (presContext) {
42328:       PostRestyleEventCommon(aElement, aRestyleHint, aMinChangeHint,
32401:                              presContext->IsProcessingAnimationStyleChange());
32401:     }
32401:   }
32401: 
32401:   // See PostRestyleEventCommon below.
42329:   void PostAnimationRestyleEvent(Element* aElement,
40075:                                  nsRestyleHint aRestyleHint,
32401:                                  nsChangeHint aMinChangeHint)
32401:   {
42328:     PostRestyleEventCommon(aElement, aRestyleHint, aMinChangeHint, PR_TRUE);
32401:   }
22339: private:
32401:   /**
42328:    * Notify the frame constructor that an element needs to have its
32401:    * style recomputed.
42328:    * @param aElement: The element to be restyled.
32401:    * @param aRestyleHint: Which nodes need to have selector matching run
32401:    *                      on them.
32401:    * @param aMinChangeHint: A minimum change hint for aContent and its
32401:    *                        descendants.
32401:    * @param aForAnimation: Whether the style should be computed with or
32401:    *                       without animation data.  Animation code
32401:    *                       sometimes needs to pass true; other code
32401:    *                       should generally pass the the pres context's
32401:    *                       IsProcessingAnimationStyleChange() value
32401:    *                       (which is the default value).
32401:    */
42329:   void PostRestyleEventCommon(Element* aElement,
42328:                               nsRestyleHint aRestyleHint,
32401:                               nsChangeHint aMinChangeHint,
32401:                               PRBool aForAnimation);
40938:   void PostRestyleEventInternal(PRBool aForLazyConstruction);
22339: public:
    1: 
10073:   /**
10073:    * Asynchronously clear style data from the root frame downwards and ensure
10073:    * it will all be rebuilt. This is safe to call anytime; it will schedule
10073:    * a restyle and take effect next time style changes are flushed.
10073:    * This method is used to recompute the style data when some change happens
10073:    * outside of any style rules, like a color preference change or a change
10073:    * in a system font size, or to fix things up when an optimization in the
10073:    * style data has become invalid. We assume that the root frame will not
10073:    * need to be reframed.
10073:    */
22339:   void PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint);
10073: 
    1:   // Request to create a continuing frame
    1:   nsresult CreateContinuingFrame(nsPresContext* aPresContext,
    1:                                  nsIFrame*       aFrame,
    1:                                  nsIFrame*       aParentFrame,
    1:                                  nsIFrame**      aContinuingFrame,
    1:                                  PRBool          aIsFluid = PR_TRUE);
    1: 
 4347:   // Copy over fixed frames from aParentFrame's prev-in-flow
 4347:   nsresult ReplicateFixedFrames(nsPageContentFrame* aParentFrame);
 4347: 
    1:   // Get the XBL insertion point for a child
    1:   nsresult GetInsertionPoint(nsIFrame*     aParentFrame,
    1:                              nsIContent*   aChildContent,
    1:                              nsIFrame**    aInsertionPoint,
    1:                              PRBool*       aMultiple = nsnull);
    1: 
    1:   nsresult CreateListBoxContent(nsPresContext* aPresContext,
    1:                                 nsIFrame*       aParentFrame,
    1:                                 nsIFrame*       aPrevFrame,
    1:                                 nsIContent*     aChild,
    1:                                 nsIFrame**      aResult,
    1:                                 PRBool          aIsAppend,
    1:                                 PRBool          aIsScrollbar,
    1:                                 nsILayoutHistoryState* aFrameState);
    1: 
24659:   // GetInitialContainingBlock() is deprecated in favor of GetRootElementFrame();
24659:   // nsIFrame* GetInitialContainingBlock() { return mRootElementFrame; }
16509:   // This returns the outermost frame for the root element
24659:   nsIFrame* GetRootElementFrame() { return mRootElementFrame; }
16509:   // This returns the frame for the root element that does not
16509:   // have a psuedo-element style
16509:   nsIFrame* GetRootElementStyleFrame() { return mRootElementStyleFrame; }
    1:   nsIFrame* GetPageSequenceFrame() { return mPageSequenceFrame; }
    1: 
23830:   // Get the frame that is the parent of the root element.
23830:   nsIFrame* GetDocElementContainingBlock()
23830:     { return mDocElementContainingBlock; }
23830: 
    1: private:
25768:   struct FrameConstructionItem;
25774:   class FrameConstructionItemList;
    1: 
    1:   nsresult ConstructPageFrame(nsIPresShell*  aPresShell, 
    1:                               nsPresContext* aPresContext,
    1:                               nsIFrame*      aParentFrame,
    1:                               nsIFrame*      aPrevPageFrame,
    1:                               nsIFrame*&     aPageFrame,
18953:                               nsIFrame*&     aCanvasFrame);
    1: 
42329:   void DoContentStateChanged(Element* aElement,
    1:                              PRInt32 aStateMask);
    1: 
    1:   /* aMinHint is the minimal change that should be made to the element */
36653:   // XXXbz do we really need the aPrimaryFrame argument here?
42329:   void RestyleElement(Element* aElement,
    1:                       nsIFrame*       aPrimaryFrame,
43790:                       nsChangeHint    aMinHint,
43794:                       RestyleTracker& aRestyleTracker,
43794:                       PRBool          aRestyleDescendants);
    1: 
    1:   nsresult InitAndRestoreFrame (const nsFrameConstructorState& aState,
    1:                                 nsIContent*                    aContent,
    1:                                 nsIFrame*                      aParentFrame,
    1:                                 nsIFrame*                      aPrevInFlow,
    1:                                 nsIFrame*                      aNewFrame,
    1:                                 PRBool                         aAllowCounters = PR_TRUE);
    1: 
    1:   already_AddRefed<nsStyleContext>
    1:   ResolveStyleContext(nsIFrame*         aParentFrame,
    1:                       nsIContent*       aContent);
25772:   already_AddRefed<nsStyleContext>
25772:   ResolveStyleContext(nsStyleContext* aParentStyleContext,
25772:                       nsIContent* aContent);
    1: 
26208:   // Construct a frame for aContent and put it in aFrameItems.  This should
26208:   // only be used in cases when it's known that the frame won't need table
26208:   // pseudo-frame construction and the like.
    1:   nsresult ConstructFrame(nsFrameConstructorState& aState,
    1:                           nsIContent*              aContent,
    1:                           nsIFrame*                aParentFrame,
    1:                           nsFrameItems&            aFrameItems);
    1: 
25771:   // Add the frame construction items for the given aContent and aParentFrame
25771:   // to the list.  This might add more than one item in some rare cases.
47661:   // If aSuppressWhiteSpaceOptimizations is true, optimizations that
29501:   // may suppress the construction of white-space-only text frames
47661:   // must be skipped for these items and items around them.
25771:   void AddFrameConstructionItems(nsFrameConstructorState& aState,
25768:                                  nsIContent*              aContent,
47661:                                  PRBool                   aSuppressWhiteSpaceOptimizations,
25768:                                  nsIFrame*                aParentFrame,
25774:                                  FrameConstructionItemList& aItems);
25768: 
28215:   // Construct the frames for the document element.  This must always return a
28215:   // singe new frame (which may, of course, have a bunch of kids).
28215:   // XXXbz no need to return a frame here, imo.
42329:   nsresult ConstructDocElementFrame(Element*                 aDocElement,
28215:                                     nsILayoutHistoryState*   aFrameState,
    1:                                     nsIFrame**               aNewFrame);
    1: 
28215:   // Set up our mDocElementContainingBlock correctly for the given root
28215:   // content.
28215:   nsresult SetUpDocElementContainingBlock(nsIContent* aDocElement);
    1: 
    1:   /**
    1:    * CreateAttributeContent creates a single content/frame combination for an
    1:    * |attr(foo)| generated content.
    1:    *
    1:    * @param aParentContent the parent content for the generated content
    1:    * @param aParentFrame the parent frame for the generated frame
    1:    * @param aAttrNamespace the namespace of the attribute in question
    1:    * @param aAttrName the localname of the attribute
    1:    * @param aStyleContext the style context to use
 3793:    * @param aGeneratedContent the array of generated content to append the
 3793:    *                          created content to.
    1:    * @param [out] aNewContent the content node we create
    1:    * @param [out] aNewFrame the new frame we create
    1:    */
    1:   nsresult CreateAttributeContent(nsIContent* aParentContent,
    1:                                   nsIFrame* aParentFrame,
    1:                                   PRInt32 aAttrNamespace,
    1:                                   nsIAtom* aAttrName,
    1:                                   nsStyleContext* aStyleContext,
 3793:                                   nsCOMArray<nsIContent>& aGeneratedContent,
    1:                                   nsIContent** aNewContent,
    1:                                   nsIFrame** aNewFrame);
    1: 
16976:   /**
16976:    * Create a text node containing the given string. If aText is non-null
16976:    * then we also set aText to the returned node.
16976:    */
31438:   already_AddRefed<nsIContent> CreateGenConTextNode(nsFrameConstructorState& aState,
31438:                                                     const nsString& aString,
16976:                                                     nsCOMPtr<nsIDOMCharacterData>* aText,
16976:                                                     nsGenConInitializer* aInitializer);
16976: 
16976:   /**
16976:    * Create a content node for the given generated content style.
16976:    * The caller takes care of making it SetNativeAnonymous, binding it
16976:    * to the document, and creating frames for it.
16976:    * @param aParentContent is the node that has the before/after style
16976:    * @param aStyleContext is the 'before' or 'after' pseudo-element
16976:    * style context
16976:    * @param aContentIndex is the index of the content item to create
16976:    */
31438:   already_AddRefed<nsIContent> CreateGeneratedContent(nsFrameConstructorState& aState,
31438:                                                       nsIContent*     aParentContent,
16477:                                                       nsStyleContext* aStyleContext,
16976:                                                       PRUint32        aContentIndex);
16461: 
25772:   // aFrame may be null; this method doesn't use it directly in any case.
25768:   void CreateGeneratedContentItem(nsFrameConstructorState&   aState,
    1:                                   nsIFrame*                  aFrame,
    1:                                   nsIContent*                aContent,
    1:                                   nsStyleContext*            aStyleContext,
35554:                                   nsCSSPseudoElements::Type  aPseudoElement,
25774:                                   FrameConstructionItemList& aItems);
    1: 
34462:   // This method can change aFrameList: it can chop off the beginning and put
34462:   // it in aParentFrame while putting the remainder into a special sibling of
34462:   // aParentFrame.  aPrevSibling must be the frame after which aFrameList is to
34462:   // be placed on aParentFrame's principal child list.  It may be null if
27310:   // aFrameList is being added at the beginning of the child list.
 4696:   nsresult AppendFrames(nsFrameConstructorState&       aState,
    1:                         nsIFrame*                      aParentFrame,
 4696:                         nsFrameItems&                  aFrameList,
36623:                         nsIFrame*                      aPrevSibling,
36623:                         PRBool                         aIsRecursiveCall = PR_FALSE);
    1: 
    1:   // BEGIN TABLE SECTION
    1:   /**
25131:    * Construct an outer table frame.  This is the FrameConstructionData
25131:    * callback used for the job.
25131:    */
25131:   nsresult ConstructTable(nsFrameConstructorState& aState,
25769:                           FrameConstructionItem&   aItem,
25131:                           nsIFrame*                aParentFrame,
25131:                           const nsStyleDisplay*    aDisplay,
25131:                           nsFrameItems&            aFrameItems,
25131:                           nsIFrame**               aNewFrame);
25131: 
25131:   /**
26207:    * FrameConstructionData callback used for constructing table rows.
26207:    */
26207:   nsresult ConstructTableRow(nsFrameConstructorState& aState,
26207:                              FrameConstructionItem&   aItem,
26207:                              nsIFrame*                aParentFrame,
26207:                              const nsStyleDisplay*    aStyleDisplay,
26207:                              nsFrameItems&            aFrameItems,
26207:                              nsIFrame**               aNewFrame);
    1: 
26207:   /**
26207:    * FrameConstructionData callback used for constructing table columns.
26207:    */
26207:   nsresult ConstructTableCol(nsFrameConstructorState& aState,
26207:                              FrameConstructionItem&   aItem,
26207:                              nsIFrame*                aParentFrame,
26207:                              const nsStyleDisplay*    aStyleDisplay,
26207:                              nsFrameItems&            aFrameItems,
26207:                              nsIFrame**               aNewFrame);
    1: 
26207:   /**
26207:    * FrameConstructionData callback used for constructing table cells.
26207:    */
26207:   nsresult ConstructTableCell(nsFrameConstructorState& aState,
26207:                               FrameConstructionItem&   aItem,
26207:                               nsIFrame*                aParentFrame,
26207:                               const nsStyleDisplay*    aStyleDisplay,
26207:                               nsFrameItems&            aFrameItems,
26207:                               nsIFrame**               aNewFrame);
26207: 
26208: private:
26208:   /* An enum of possible parent types for anonymous table object construction */
26208:   enum ParentType {
26208:     eTypeBlock = 0, /* This includes all non-table-related frames */
26208:     eTypeRow,
26208:     eTypeRowGroup,
26208:     eTypeColGroup,
26208:     eTypeTable,
26208:     eParentTypeCount
26208:   };
    1: 
26208:   /* 3 bits is enough to handle our ParentType values */
26208: #define FCDATA_PARENT_TYPE_OFFSET 29
26208:   /* Macro to get the desired parent type out of an mBits member of
26208:      FrameConstructionData */
26208: #define FCDATA_DESIRED_PARENT_TYPE(_bits)           \
26208:   ParentType((_bits) >> FCDATA_PARENT_TYPE_OFFSET)
26208:   /* Macro to create FrameConstructionData bits out of a desired parent type */
26208: #define FCDATA_DESIRED_PARENT_TYPE_TO_BITS(_type)     \
26208:   (((PRUint32)(_type)) << FCDATA_PARENT_TYPE_OFFSET)
    1: 
26208:   /* Get the parent type that aParentFrame has. */
29580:   static ParentType GetParentType(nsIFrame* aParentFrame) {
29580:     return GetParentType(aParentFrame->GetType());
29580:   }
29580: 
29580:   /* Get the parent type for the given nsIFrame type atom */
29580:   static ParentType GetParentType(nsIAtom* aFrameType);
    1: 
23944:   /* A constructor function that just creates an nsIFrame object.  The caller
23944:      is responsible for initializing the object, adding it to frame lists,
23944:      constructing frames for the children, etc.
23944: 
23944:      @param nsIPresShell the presshell whose arena should be used to allocate
23944:                          the frame.
23944:      @param nsStyleContext the style context to use for the frame. */
23944:   typedef nsIFrame* (* FrameCreationFunc)(nsIPresShell*, nsStyleContext*);
23944: 
23944:   /* A function that can be used to get a FrameConstructionData.  Such
23944:      a function is allowed to return null.
23944: 
23944:      @param nsIContent the node for which the frame is being constructed.
23944:      @param nsStyleContext the style context to be used for the frame.
23944:   */
23944:   struct FrameConstructionData;
23944:   typedef const FrameConstructionData*
23944:     (* FrameConstructionDataGetter)(nsIContent*, nsStyleContext*);
23944: 
23944:   /* A constructor function that's used for complicated construction tasks.
23944:      This is expected to create the new frame, initialize it, add whatever
23944:      needs to be added to aFrameItems (XXXbz is that really necessary?  Could
23944:      caller add?  Might there be cases when *aNewFrame or its placeholder is
23944:      not the thing that ends up in aFrameItems?  If not, would it be safe to do
23944:      the add into the frame construction state after processing kids?  Look
23944:      into this as a followup!), process children as needed, etc.  It is NOT
36653:      expected to deal with setting the frame on the content.
23944: 
23944:      @param aState the frame construction state to use.
25769:      @param aItem the frame construction item to use
23944:      @param aParentFrame the frame to set as the parent of the
23944:                          newly-constructed frame.
25769:      @param aStyleDisplay the display struct from aItem's mStyleContext
23944:      @param aFrameItems the frame list to add the new frame (or its
23944:                         placeholder) to.
23944:      @param aFrame out param handing out the frame that was constructed.  This
36653:                    frame is what the caller will set as the frame on the content.
23944:   */
23944:   typedef nsresult
23944:     (nsCSSFrameConstructor::* FrameFullConstructor)(nsFrameConstructorState& aState,
25769:                                                     FrameConstructionItem& aItem,
23944:                                                     nsIFrame* aParentFrame,
23944:                                                     const nsStyleDisplay* aStyleDisplay,
23944:                                                     nsFrameItems& aFrameItems,
23944:                                                     nsIFrame** aFrame);
23944: 
23944:   /* Bits that modify the way a FrameConstructionData is handled */
23944: 
36653:   /* If the FCDATA_SKIP_FRAMESET bit is set, then the frame created should not
36653:      be set as the primary frame on the content node.  This should only be used
36653:      in very rare cases when we create more than one frame for a given content
36653:      node. */
36653: #define FCDATA_SKIP_FRAMESET 0x1
23944:   /* If the FCDATA_FUNC_IS_DATA_GETTER bit is set, then the mFunc of the
23944:      FrameConstructionData is a getter function that can be used to get the
23944:      actual FrameConstructionData to use. */
23944: #define FCDATA_FUNC_IS_DATA_GETTER 0x2
23944:   /* If the FCDATA_FUNC_IS_FULL_CTOR bit is set, then the FrameConstructionData
23944:      has an mFullConstructor.  In this case, there is no relevant mData or
23944:      mFunc */
23944: #define FCDATA_FUNC_IS_FULL_CTOR 0x4
23944:   /* If FCDATA_DISALLOW_OUT_OF_FLOW is set, do not allow the frame to
25772:      float or be absolutely positioned.  This can also be used with
25772:      FCDATA_FUNC_IS_FULL_CTOR to indicate what the full-constructor
25772:      function will do. */
23944: #define FCDATA_DISALLOW_OUT_OF_FLOW 0x8
23944:   /* If FCDATA_FORCE_NULL_ABSPOS_CONTAINER is set, make sure to push a
23944:      null absolute containing block before processing children for this
23944:      frame.  If this is not set, the frame will be pushed as the
23944:      absolute containing block as needed, based on its style */
23944: #define FCDATA_FORCE_NULL_ABSPOS_CONTAINER 0x10
23946: #ifdef MOZ_MATHML
23946:   /* If FCDATA_WRAP_KIDS_IN_BLOCKS is set, the inline kids of the frame
23946:      will be wrapped in blocks.  This is only usable for MathML at the
23946:      moment. */
23946: #define FCDATA_WRAP_KIDS_IN_BLOCKS 0x20
23952: #endif /* MOZ_MATHML */
23952:   /* If FCDATA_SUPPRESS_FRAME is set, no frame should be created for the
23952:      content.  If this bit is set, nothing else in the struct needs to be
23952:      set. */
23952: #define FCDATA_SUPPRESS_FRAME 0x40
23952:   /* If FCDATA_MAY_NEED_SCROLLFRAME is set, the new frame should be wrapped in
36793:      a scrollframe if its overflow type so requires. */
23952: #define FCDATA_MAY_NEED_SCROLLFRAME 0x80
23952: #ifdef MOZ_XUL
23952:   /* If FCDATA_IS_POPUP is set, the new frame is a XUL popup frame.  These need
23952:      some really weird special handling.  */
23952: #define FCDATA_IS_POPUP 0x100
23952: #endif /* MOZ_XUL */
23952:   /* If FCDATA_SKIP_ABSPOS_PUSH is set, don't push this frame as an
23952:      absolute containing block, no matter what its style says. */
23952: #define FCDATA_SKIP_ABSPOS_PUSH 0x200
23954:   /* If FCDATA_FORCE_VIEW is set, then force creation of a view for the frame.
23954:      this is only used if a scrollframe is not created and a full constructor
23954:      isn't used, so this flag shouldn't be used with
23954:      FCDATA_MAY_NEED_SCROLLFRAME or FCDATA_FUNC_IS_FULL_CTOR.  */
23954: #define FCDATA_FORCE_VIEW 0x400
23954:   /* If FCDATA_DISALLOW_GENERATED_CONTENT is set, then don't allow generated
23954:      content when processing kids of this frame.  This should not be used with
23954:      FCDATA_FUNC_IS_FULL_CTOR */
23954: #define FCDATA_DISALLOW_GENERATED_CONTENT 0x800
25131:   /* If FCDATA_IS_TABLE_PART is set, then the frame is some sort of
25131:      table-related thing and we should not attempt to fetch a table-cell parent
25131:      for it if it's inside another table-related frame. */
25131: #define FCDATA_IS_TABLE_PART 0x1000
25772:   /* If FCDATA_IS_INLINE is set, then the frame is a non-replaced CSS
25772:      inline box. */
25772: #define FCDATA_IS_INLINE 0x2000
29501:   /* If FCDATA_IS_LINE_PARTICIPANT is set, the frame is something that will
25773:      return true for IsFrameOfType(nsIFrame::eLineParticipant) */
25773: #define FCDATA_IS_LINE_PARTICIPANT 0x4000
29501:   /* If FCDATA_IS_LINE_BREAK is set, the frame is something that will
29501:      induce a line break boundary before and after itself. */
29501: #define FCDATA_IS_LINE_BREAK 0x8000
26207:   /* If FCDATA_ALLOW_BLOCK_STYLES is set, allow block styles when processing
26207:      children.  This should not be used with FCDATA_FUNC_IS_FULL_CTOR. */
29501: #define FCDATA_ALLOW_BLOCK_STYLES 0x10000
26208:   /* If FCDATA_USE_CHILD_ITEMS is set, then use the mChildItems in the relevant
26208:      FrameConstructionItem instead of trying to process the content's children.
26208:      This can be used with or without FCDATA_FUNC_IS_FULL_CTOR.
26208:      The child items might still need table pseudo processing. */
29501: #define FCDATA_USE_CHILD_ITEMS 0x20000
23944: 
23944:   /* Structure representing information about how a frame should be
23944:      constructed.  */
23944:   struct FrameConstructionData {
23944:     // Flag bits that can modify the way the construction happens
23944:     PRUint32 mBits;
23944:     // We have exactly one of three types of functions, so use a union for
23944:     // better cache locality for the ones that aren't pointer-to-member.  That
23944:     // one needs to be separate, because we can't cast between it and the
23944:     // others and hence wouldn't be able to initialize the union without a
23944:     // constructor and all the resulting generated code.  See documentation
23944:     // above for FrameCreationFunc, FrameConstructionDataGetter, and
23944:     // FrameFullConstructor to see what the functions would do.
23944:     union Func {
23944:       FrameCreationFunc mCreationFunc;
23944:       FrameConstructionDataGetter mDataGetter;
23944:     } mFunc;
23944:     FrameFullConstructor mFullConstructor;
23944:   };
23944: 
23944:   /* Structure representing a mapping of an atom to a FrameConstructionData.
23944:      This can be used with non-static atoms, assuming that the nsIAtom* is
23944:      stored somewhere that this struct can point to (that is, a static
23944:      nsIAtom*) and that it's allocated before the struct is ever used. */
23944:   struct FrameConstructionDataByTag {
23944:     // Pointer to nsIAtom* is used because we want to initialize this
23944:     // statically, so before our atom tables are set up.
23944:     const nsIAtom * const * const mTag;
23944:     const FrameConstructionData mData;
23944:   };
23944: 
23944:   /* Structure representing a mapping of an integer to a
23944:      FrameConstructionData. There are no magic integer values here. */
23944:   struct FrameConstructionDataByInt {
23944:     /* Could be used for display or whatever else */
23944:     const PRInt32 mInt;
23944:     const FrameConstructionData mData;
23944:   };
23944: 
26208:   /* Structure that has a FrameConstructionData and style context pseudo-type
26208:      for a table pseudo-frame */
26208:   struct PseudoParentData {
26208:     const FrameConstructionData mFCData;
26208:     nsICSSAnonBoxPseudo * const * const mPseudoType;
26208:   };
26208:   /* Array of such structures that we use to properly construct table
26208:      pseudo-frames as needed */
26208:   static const PseudoParentData sPseudoParentData[eParentTypeCount];
26208: 
23944:   /* A function that takes an integer, content, style context, and array of
23944:      FrameConstructionDataByInts and finds the appropriate frame construction
23944:      data to use and returns it.  This can return null if none of the integers
23944:      match or if the matching integer has a FrameConstructionDataGetter that
23944:      returns null. */
23944:   static const FrameConstructionData*
23944:     FindDataByInt(PRInt32 aInt, nsIContent* aContent,
23944:                   nsStyleContext* aStyleContext,
23944:                   const FrameConstructionDataByInt* aDataPtr,
23944:                   PRUint32 aDataLength);
23944: 
23944:   /* A function that takes a tag, content, style context, and array of
23944:      FrameConstructionDataByTags and finds the appropriate frame construction
23944:      data to use and returns it.  This can return null if none of the tags
23944:      match or if the matching tag has a FrameConstructionDataGetter that
23944:      returns null. */
23944:   static const FrameConstructionData*
23944:     FindDataByTag(nsIAtom* aTag, nsIContent* aContent,
23944:                   nsStyleContext* aStyleContext,
23944:                   const FrameConstructionDataByTag* aDataPtr,
23944:                   PRUint32 aDataLength);
23944: 
25774:   /* A class representing a list of FrameConstructionItems */
25774:   class FrameConstructionItemList {
25774:   public:
25774:     FrameConstructionItemList() :
25774:       mInlineCount(0),
34462:       mBlockCount(0),
25981:       mLineParticipantCount(0),
29501:       mItemCount(0),
29501:       mLineBoundaryAtStart(PR_FALSE),
29501:       mLineBoundaryAtEnd(PR_FALSE),
29501:       mParentHasNoXBLChildren(PR_FALSE)
25981:     {
25981:       PR_INIT_CLIST(&mItems);
26208:       memset(mDesiredParentCounts, 0, sizeof(mDesiredParentCounts));
25981:     }
25774: 
25981:     ~FrameConstructionItemList() {
25981:       PRCList* cur = PR_NEXT_LINK(&mItems);
25981:       while (cur != &mItems) {
25981:         PRCList* next = PR_NEXT_LINK(cur);
25981:         delete ToItem(cur);
25981:         cur = next;
25981:       }
25981: 
25981:       // Leaves our mItems pointing to deleted memory in both directions,
25981:       // but that's OK at this point.
25981:     }
25981: 
29501:     void SetLineBoundaryAtStart(PRBool aBoundary) { mLineBoundaryAtStart = aBoundary; }
29501:     void SetLineBoundaryAtEnd(PRBool aBoundary) { mLineBoundaryAtEnd = aBoundary; }
29501:     void SetParentHasNoXBLChildren(PRBool aHasNoXBLChildren) {
29501:       mParentHasNoXBLChildren = aHasNoXBLChildren;
29501:     }
29501:     PRBool HasLineBoundaryAtStart() { return mLineBoundaryAtStart; }
29501:     PRBool HasLineBoundaryAtEnd() { return mLineBoundaryAtEnd; }
29501:     PRBool ParentHasNoXBLChildren() { return mParentHasNoXBLChildren; }
25981:     PRBool IsEmpty() const { return PR_CLIST_IS_EMPTY(&mItems); }
25774:     PRBool AnyItemsNeedBlockParent() const { return mLineParticipantCount != 0; }
25981:     PRBool AreAllItemsInline() const { return mInlineCount == mItemCount; }
34462:     PRBool AreAllItemsBlock() const { return mBlockCount == mItemCount; }
26208:     PRBool AllWantParentType(ParentType aDesiredParentType) const {
26208:       return mDesiredParentCounts[aDesiredParentType] == mItemCount;
26208:     }
25774: 
47661:     // aSuppressWhiteSpaceOptimizations is true if optimizations that
47661:     // skip constructing whitespace frames for this item or items
47661:     // around it cannot be performed.
25981:     FrameConstructionItem* AppendItem(const FrameConstructionData* aFCData,
25981:                                       nsIContent* aContent,
25981:                                       nsIAtom* aTag,
25981:                                       PRInt32 aNameSpaceID,
34614:                                       PendingBinding* aPendingBinding,
47661:                                       already_AddRefed<nsStyleContext> aStyleContext,
47661:                                       PRBool aSuppressWhiteSpaceOptimizations)
25981:     {
25981:       FrameConstructionItem* item =
25981:         new FrameConstructionItem(aFCData, aContent, aTag, aNameSpaceID,
47661:                                   aPendingBinding, aStyleContext,
47661:                                   aSuppressWhiteSpaceOptimizations);
25981:       if (item) {
25981:         PR_APPEND_LINK(item, &mItems);
25981:         ++mItemCount;
26208:         ++mDesiredParentCounts[item->DesiredParentType()];
25981:       } else {
25981:         // Clean up the style context
25981:         nsRefPtr<nsStyleContext> sc(aStyleContext);
25981:       }
25981:       return item;
25774:     }
25774: 
25774:     void InlineItemAdded() { ++mInlineCount; }
34462:     void BlockItemAdded() { ++mBlockCount; }
25774:     void LineParticipantItemAdded() { ++mLineParticipantCount; }
25774: 
25774:     class Iterator;
25774:     friend class Iterator;
26208: 
25774:     class Iterator {
25774:     public:
25774:       Iterator(FrameConstructionItemList& list) :
25981:         mCurrent(PR_NEXT_LINK(&list.mItems)),
26208:         mEnd(&list.mItems),
26208:         mList(list)
26208:       {}
26208:       Iterator(const Iterator& aOther) :
26208:         mCurrent(aOther.mCurrent),
26208:         mEnd(aOther.mEnd),
26208:         mList(aOther.mList)
25774:       {}
25774: 
26208:       PRBool operator==(const Iterator& aOther) const {
26208:         NS_ASSERTION(mEnd == aOther.mEnd, "Iterators for different lists?");
26208:         return mCurrent == aOther.mCurrent;
26208:       }
26208:       PRBool operator!=(const Iterator& aOther) const {
26208:         return !(*this == aOther);
26208:       }
27311:       Iterator& operator=(const Iterator& aOther) {
27311:         NS_ASSERTION(mEnd == aOther.mEnd, "Iterators for different lists?");
27311:         mCurrent = aOther.mCurrent;
27311:         return *this;
27311:       }
26208: 
29501:       FrameConstructionItemList* List() {
29501:         return &mList;
29501:       }
29501: 
25981:       operator FrameConstructionItem& () {
26208:         return item();
26208:       }
26208: 
26208:       FrameConstructionItem& item() {
25981:         return *FrameConstructionItemList::ToItem(mCurrent);
25981:       }
25981:       PRBool IsDone() const { return mCurrent == mEnd; }
26208:       PRBool AtStart() const { return mCurrent == PR_NEXT_LINK(mEnd); }
25774:       void Next() {
25981:         NS_ASSERTION(!IsDone(), "Should have checked IsDone()!");
25981:         mCurrent = PR_NEXT_LINK(mCurrent);
25774:       }
29501:       void Prev() {
29501:         NS_ASSERTION(!AtStart(), "Should have checked AtStart()!");
29501:         mCurrent = PR_PREV_LINK(mCurrent);
29501:       }
27311:       void SetToEnd() { mCurrent = mEnd; }
27311: 
27311:       // Skip over all items that want a parent type different from the given
27311:       // one.  Return whether the iterator is done after doing that.  The
27311:       // iterator must not be done when this is called.
27311:       inline PRBool SkipItemsWantingParentType(ParentType aParentType);
27311: 
27311:       // Skip over whitespace.  Return whether the iterator is done after doing
27311:       // that.  The iterator must not be done, and must be pointing to a
27311:       // whitespace item when this is called.
41931:       inline PRBool SkipWhitespace(nsFrameConstructorState& aState);
26208: 
26208:       // Remove the item pointed to by this iterator from its current list and
26208:       // Append it to aTargetList.  This iterator is advanced to point to the
26208:       // next item in its list.  aIter must not be done.  aOther must not be
26208:       // the list this iterator is iterating over..
26208:       void AppendItemToList(FrameConstructionItemList& aTargetList);
26208: 
26208:       // As above, but moves all items starting with this iterator until we
26208:       // get to aEnd; the item pointed to by aEnd is not stolen.  This method
26208:       // might have optimizations over just looping and doing StealItem for
26208:       // some special cases.  After this method returns, this iterator will
26208:       // point to the item aEnd points to now; aEnd is not modified.
26208:       // aTargetList must not be the list this iterator is iterating over.
26208:       void AppendItemsToList(const Iterator& aEnd,
26208:                              FrameConstructionItemList& aTargetList);
26208: 
26208:       // Insert aItem in this iterator's list right before the item pointed to
26208:       // by this iterator.  After the insertion, this iterator will continue to
26208:       // point to the item it now points to (the one just after the
26208:       // newly-inserted item).  This iterator is allowed to be done; in that
26208:       // case this call just appends the given item to the list.
26208:       void InsertItem(FrameConstructionItem* aItem);
26208: 
27311:       // Delete the items between this iterator and aEnd, including the item
27311:       // this iterator currently points to but not including the item pointed
27311:       // to by aEnd.  When this returns, this iterator will point to the same
27311:       // item as aEnd.  This iterator must not equal aEnd when this method is
27311:       // called.
27311:       void DeleteItemsTo(const Iterator& aEnd);
26208: 
25774:     private:
25981:       PRCList* mCurrent;
25981:       PRCList* mEnd;
26208:       FrameConstructionItemList& mList;
25774:     };
25774: 
25774:   private:
25981:     static FrameConstructionItem* ToItem(PRCList* item) {
25981:       return static_cast<FrameConstructionItem*>(item);
25981:     }
25981: 
26208:     // Adjust our various counts for aItem being added or removed.  aDelta
26208:     // should be either +1 or -1 depending on which is happening.
26208:     void AdjustCountsForItem(FrameConstructionItem* aItem, PRInt32 aDelta);
26208: 
25981:     PRCList mItems;
25774:     PRUint32 mInlineCount;
34462:     PRUint32 mBlockCount;
25774:     PRUint32 mLineParticipantCount;
25981:     PRUint32 mItemCount;
26208:     PRUint32 mDesiredParentCounts[eParentTypeCount];
29501:     // True if there is guaranteed to be a line boundary before the
29501:     // frames created by these items
29501:     PRPackedBool mLineBoundaryAtStart;
29501:     // True if there is guaranteed to be a line boundary after the
29501:     // frames created by these items
29501:     PRPackedBool mLineBoundaryAtEnd;
29501:     // True if the parent is guaranteed to have no XBL anonymous children
29501:     PRPackedBool mParentHasNoXBLChildren;
25774:   };
25774: 
25774:   typedef FrameConstructionItemList::Iterator FCItemIterator;
25774: 
25768:   /* A struct representing an item for which frames might need to be
25768:    * constructed.  This contains all the information needed to construct the
25768:    * frame other than the parent frame and whatever would be stored in the
25768:    * frame constructor state. */
25981:   struct FrameConstructionItem : public PRCList {
25981:     // No need to PR_INIT_CLIST in the constructor because the only
25981:     // place that creates us immediately appends us.
25981:     FrameConstructionItem(const FrameConstructionData* aFCData,
25981:                           nsIContent* aContent,
25981:                           nsIAtom* aTag,
25981:                           PRInt32 aNameSpaceID,
34614:                           PendingBinding* aPendingBinding,
47661:                           already_AddRefed<nsStyleContext> aStyleContext,
47661:                           PRBool aSuppressWhiteSpaceOptimizations) :
25981:       mFCData(aFCData), mContent(aContent), mTag(aTag),
47661:       mNameSpaceID(aNameSpaceID),
34614:       mPendingBinding(aPendingBinding), mStyleContext(aStyleContext),
47661:       mSuppressWhiteSpaceOptimizations(aSuppressWhiteSpaceOptimizations),
25981:       mIsText(PR_FALSE), mIsGeneratedContent(PR_FALSE),
34462:       mIsRootPopupgroup(PR_FALSE), mIsAllInline(PR_FALSE), mIsBlock(PR_FALSE),
29075:       mHasInlineEnds(PR_FALSE), mIsPopup(PR_FALSE),
29075:       mIsLineParticipant(PR_FALSE)
25981:     {}
25768:     ~FrameConstructionItem() {
25768:       if (mIsGeneratedContent) {
25768:         mContent->UnbindFromTree();
25768:         NS_RELEASE(mContent);
25768:       }
25768:     }
25768: 
26208:     ParentType DesiredParentType() {
26208:       return FCDATA_DESIRED_PARENT_TYPE(mFCData->mBits);
26208:     }
27311: 
27311:     // Don't call this unless the frametree really depends on the answer!
27311:     // Especially so for generated content, where we don't want to reframe
27311:     // things.
41931:     PRBool IsWhitespace(nsFrameConstructorState& aState) const;
26208: 
29501:     PRBool IsLineBoundary() const {
34462:       return mIsBlock || (mFCData->mBits & FCDATA_IS_LINE_BREAK);
29501:     }
29501: 
25768:     // The FrameConstructionData to use.
25768:     const FrameConstructionData* mFCData;
25768:     // The nsIContent node to use when initializing the new frame.
25768:     nsIContent* mContent;
25768:     // The XBL-resolved tag name to use for frame construction.
25768:     nsIAtom* mTag;
25768:     // The XBL-resolved namespace to use for frame construction.
25768:     PRInt32 mNameSpaceID;
34614:     // The PendingBinding for this frame construction item, if any.  May be
34614:     // null.  We maintain a list of PendingBindings in the frame construction
34614:     // state in the order in which AddToAttachedQueue should be called on them:
34614:     // depth-first, post-order traversal order.  Since we actually traverse the
34614:     // DOM in a mix of breadth-first and depth-first, it is the responsibility
34614:     // of whoever constructs FrameConstructionItem kids of a given
34614:     // FrameConstructionItem to push its mPendingBinding as the current
34614:     // insertion point before doing so and pop it afterward.
34614:     PendingBinding* mPendingBinding;
25768:     // The style context to use for creating the new frame.
25768:     nsRefPtr<nsStyleContext> mStyleContext;
47661:     // Whether optimizations to skip constructing textframes around
47661:     // this content need to be suppressed.
47661:     PRPackedBool mSuppressWhiteSpaceOptimizations;
25768:     // Whether this is a text content item.
25768:     PRPackedBool mIsText;
29501:     // Whether this is a generated content container.
29501:     // If it is, mContent is a strong pointer.
25768:     PRPackedBool mIsGeneratedContent;
25769:     // Whether this is an item for the root popupgroup.
25769:     PRPackedBool mIsRootPopupgroup;
25772:     // Whether construction from this item will create only frames that are
34462:     // IsInlineOutside() in the principal child list.  This is not precise, but
34462:     // conservative: if true the frames will really be inline, whereas if false
34462:     // they might still all be inline.
25772:     PRPackedBool mIsAllInline;
34462:     // Whether construction from this item will create only frames that are
34462:     // IsBlockOutside() in the principal child list.  This is not precise, but
34462:     // conservative: if true the frames will really be blocks, whereas if false
34462:     // they might still be blocks (and in particular, out-of-flows that didn't
34462:     // find a containing block).
34462:     PRPackedBool mIsBlock;
25773:     // Whether construction from this item will give leading and trailing
25773:     // inline frames.  This is equal to mIsAllInline, except for inline frame
25773:     // items, where it's always true, whereas mIsAllInline might be false due
25773:     // to {ib} splits.
25773:     PRPackedBool mHasInlineEnds;
25772:     // Whether construction from this item will create a popup that needs to
25772:     // go into the global popup items.
25772:     PRPackedBool mIsPopup;
29075:     // Whether this item should be treated as a line participant
29075:     PRPackedBool mIsLineParticipant;
25772: 
25772:     // Child frame construction items.
25774:     FrameConstructionItemList mChildItems;
25768: 
25768:   private:
25768:     FrameConstructionItem(const FrameConstructionItem& aOther); /* not implemented */
25768:   };
25768: 
    1:   /**
26208:    * Function to create the table pseudo items we need.
26208:    * @param aItems the child frame construction items before pseudo creation
26208:    * @param aParentFrame the parent frame we're creating pseudos for
26208:    */
41931:   inline nsresult CreateNeededTablePseudos(nsFrameConstructorState& aState,
41931:                                            FrameConstructionItemList& aItems,
26208:                                            nsIFrame* aParentFrame);
26208: 
26208:   /**
26208:    * Function to adjust aParentFrame to deal with captions.
    1:    * @param aParentFrame the frame we think should be the parent.  This will be
26208:    *        adjusted to point to the right parent frame.
23955:    * @param aFCData the FrameConstructionData that would be used for frame
25131:    *        construction.
25768:    * @param aStyleContext the style context for aChildContent
    1:    */
    1:   // XXXbz this function should really go away once we rework pseudo-frame
    1:   // handling to be better. This should simply be part of the job of
    1:   // GetGeometricParent, and stuff like the frameitems and parent frame should
    1:   // be kept track of in the state...
26208:   void AdjustParentFrame(nsIFrame* &                  aParentFrame,
23955:                          const FrameConstructionData* aFCData,
26208:                          nsStyleContext*              aStyleContext);
    1: 
    1:   // END TABLE SECTION
    1: 
    1: protected:
    1:   static nsresult CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
    1:                                             nsIContent*      aContent,
    1:                                             nsIFrame*        aFrame,
    1:                                             nsStyleContext*  aStyleContext,
    1:                                             nsIFrame*        aParentFrame,
 6219:                                             nsIFrame*        aPrevInFlow,
34912:                                             nsFrameState     aTypeBit,
    1:                                             nsIFrame**       aPlaceholderFrame);
    1: 
    1: private:
    1:   // ConstructButtonFrame puts the new frame in aFrameItems and
    1:   // handles the kids of the button.
    1:   nsresult ConstructButtonFrame(nsFrameConstructorState& aState,
25769:                                 FrameConstructionItem&    aItem,
    1:                                 nsIFrame*                aParentFrame,
    1:                                 const nsStyleDisplay*    aStyleDisplay,
 4461:                                 nsFrameItems&            aFrameItems,
23944:                                 nsIFrame**               aNewFrame);
    1: 
    1:   // ConstructSelectFrame puts the new frame in aFrameItems and
    1:   // handles the kids of the select.
    1:   nsresult ConstructSelectFrame(nsFrameConstructorState& aState,
25769:                                 FrameConstructionItem&   aItem,
    1:                                 nsIFrame*                aParentFrame,
    1:                                 const nsStyleDisplay*    aStyleDisplay,
23944:                                 nsFrameItems&            aFrameItems,
23944:                                 nsIFrame**               aNewFrame);
    1: 
    1:   // ConstructFieldSetFrame puts the new frame in aFrameItems and
    1:   // handles the kids of the fieldset
    1:   nsresult ConstructFieldSetFrame(nsFrameConstructorState& aState,
25769:                                   FrameConstructionItem&   aItem,
    1:                                   nsIFrame*                aParentFrame,
23944:                                   const nsStyleDisplay*    aStyleDisplay,
    1:                                   nsFrameItems&            aFrameItems,
23944:                                   nsIFrame**               aNewFrame);
    1: 
25772:   // aParentFrame might be null.  If it is, that means it was an
25772:   // inline frame.
23955:   static const FrameConstructionData* FindTextData(nsIFrame* aParentFrame);
23955: 
23955:   nsresult ConstructTextFrame(const FrameConstructionData* aData,
23955:                               nsFrameConstructorState& aState,
    1:                               nsIContent*              aContent,
    1:                               nsIFrame*                aParentFrame,
    1:                               nsStyleContext*          aStyleContext,
26208:                               nsFrameItems&            aFrameItems);
    1: 
47665:   // If aPossibleTextContent is a text node and doesn't have a frame, append a
47665:   // frame construction item for it to aItems.
29525:   void AddTextItemIfNeeded(nsFrameConstructorState& aState,
29525:                            nsIFrame* aParentFrame,
47665:                            nsIContent* aPossibleTextContent,
29501:                            FrameConstructionItemList& aItems);
29501: 
47669:   // If aParentContent's child aContent is a text node and
29501:   // doesn't have a frame, try to create a frame for it.
29501:   void ReframeTextIfNeeded(nsIContent* aParentContent,
47669:                            nsIContent* aContent);
29501: 
25771:   void AddPageBreakItem(nsIContent* aContent,
25771:                         nsStyleContext* aMainStyleContext,
25774:                         FrameConstructionItemList& aItems);
    1: 
23944:   // Function to find FrameConstructionData for aContent.  Will return
23944:   // null if aContent is not HTML.
25772:   // aParentFrame might be null.  If it is, that means it was an
25772:   // inline frame.
23944:   static const FrameConstructionData* FindHTMLData(nsIContent* aContent,
23944:                                                    nsIAtom* aTag,
23944:                                                    PRInt32 aNameSpaceID,
24550:                                                    nsIFrame* aParentFrame,
23944:                                                    nsStyleContext* aStyleContext);
23944:   // HTML data-finding helper functions
23944:   static const FrameConstructionData*
23944:     FindImgData(nsIContent* aContent, nsStyleContext* aStyleContext);
23944:   static const FrameConstructionData*
23944:     FindImgControlData(nsIContent* aContent, nsStyleContext* aStyleContext);
23944:   static const FrameConstructionData*
23944:     FindInputData(nsIContent* aContent, nsStyleContext* aStyleContext);
23944:   static const FrameConstructionData*
23944:     FindObjectData(nsIContent* aContent, nsStyleContext* aStyleContext);
23944: 
25769:   /* Construct a frame from the given FrameConstructionItem.  This function
36653:      will handle adding the frame to frame lists, processing children, setting
36653:      the frame as the primary frame for the item's content, and so forth.
23944: 
25769:      @param aItem the FrameConstructionItem to use.
23944:      @param aState the frame construction state to use.
23944:      @param aParentFrame the frame to set as the parent of the
23944:                          newly-constructed frame.
23944:      @param aFrameItems the frame list to add the new frame (or its
23944:                         placeholder) to.
23944:   */
25769:   nsresult ConstructFrameFromItemInternal(FrameConstructionItem& aItem,
23944:                                           nsFrameConstructorState& aState,
    1:                                           nsIFrame* aParentFrame,
26208:                                           nsFrameItems& aFrameItems);
    1: 
25768:   // possible flags for AddFrameConstructionItemInternal's aFlags argument
25768:   /* Allow xbl:base to affect the tag/namespace used. */
25768: #define ITEM_ALLOW_XBL_BASE 0x1
25768:   /* Allow page-break before and after items to be created if the
25768:      style asks for them. */
25768: #define ITEM_ALLOW_PAGE_BREAK 0x2
25768:   /* The item is a generated content item. */
25768: #define ITEM_IS_GENERATED_CONTENT 0x4
25771:   // The guts of AddFrameConstructionItems
25772:   // aParentFrame might be null.  If it is, that means it was an
25772:   // inline frame.
25771:   void AddFrameConstructionItemsInternal(nsFrameConstructorState& aState,
    1:                                          nsIContent*              aContent,
    1:                                          nsIFrame*                aParentFrame,
    1:                                          nsIAtom*                 aTag,
    1:                                          PRInt32                  aNameSpaceID,
47661:                                          PRBool                   aSuppressWhiteSpaceOptimizations,
    1:                                          nsStyleContext*          aStyleContext,
25768:                                          PRUint32                 aFlags,
25774:                                          FrameConstructionItemList& aItems);
25768: 
29501:   /**
29501:    * Construct frames for the given item list and parent frame, and put the
29501:    * resulting frames in aFrameItems.
29501:    */
29501:   nsresult ConstructFramesFromItemList(nsFrameConstructorState& aState,
29501:                                        FrameConstructionItemList& aItems,
25768:                                        nsIFrame* aParentFrame,
25768:                                        nsFrameItems& aFrameItems);
29501:   nsresult ConstructFramesFromItem(nsFrameConstructorState& aState,
29501:                                    FCItemIterator& aItem,
29501:                                    nsIFrame* aParentFrame,
29501:                                    nsFrameItems& aFrameItems);
29501:   static PRBool AtLineBoundary(FCItemIterator& aIter);
    1: 
    1:   nsresult CreateAnonymousFrames(nsFrameConstructorState& aState,
    1:                                  nsIContent*              aParent,
23342:                                  nsIFrame*                aParentFrame,
34614:                                  PendingBinding  *        aPendingBinding,
    1:                                  nsFrameItems&            aChildItems);
    1: 
25768:   nsresult GetAnonymousContent(nsIContent* aParent,
25768:                                nsIFrame* aParentFrame,
25768:                                nsTArray<nsIContent*>& aAnonContent);
25768: 
    1: //MathML Mod - RBS
    1: #ifdef MOZ_MATHML
 6862:   /**
 6862:    * Takes the frames in aBlockItems and wraps them in a new anonymous block
 6862:    * frame whose content is aContent and whose parent will be aParentFrame.
 6862:    * The anonymous block is added to aNewItems and aBlockItems is cleared.
 6862:    */
 6862:   nsresult FlushAccumulatedBlock(nsFrameConstructorState& aState,
 6862:                                  nsIContent* aContent,
 6862:                                  nsIFrame* aParentFrame,
 6862:                                  nsFrameItems* aBlockItems,
 6862:                                  nsFrameItems* aNewItems);
 6862: 
23946:   // Function to find FrameConstructionData for aContent.  Will return
23946:   // null if aContent is not MathML.
23946:   static const FrameConstructionData* FindMathMLData(nsIContent* aContent,
    1:                                                      nsIAtom* aTag,
    1:                                                      PRInt32 aNameSpaceID,
23946:                                                      nsStyleContext* aStyleContext);
    1: #endif
    1: 
23952:   // Function to find FrameConstructionData for aContent.  Will return
23952:   // null if aContent is not XUL.
23952:   static const FrameConstructionData* FindXULTagData(nsIContent* aContent,
    1:                                                      nsIAtom* aTag,
    1:                                                      PRInt32 aNameSpaceID,
23952:                                                      nsStyleContext* aStyleContext);
23952:   // XUL data-finding helper functions and structures
23952: #ifdef MOZ_XUL
23952:   static const FrameConstructionData*
23952:     FindPopupGroupData(nsIContent* aContent, nsStyleContext* aStyleContext);
23952:   // sXULTextBoxData used for both labels and descriptions
23952:   static const FrameConstructionData sXULTextBoxData;
23952:   static const FrameConstructionData*
23952:     FindXULLabelData(nsIContent* aContent, nsStyleContext* aStyleContext);
23952:   static const FrameConstructionData*
23952:     FindXULDescriptionData(nsIContent* aContent, nsStyleContext* aStyleContext);
23952: #ifdef XP_MACOSX
23952:   static const FrameConstructionData*
23952:     FindXULMenubarData(nsIContent* aContent, nsStyleContext* aStyleContext);
23952: #endif /* XP_MACOSX */
23952:   static const FrameConstructionData*
23952:     FindXULListBoxBodyData(nsIContent* aContent, nsStyleContext* aStyleContext);
23952:   static const FrameConstructionData*
23952:     FindXULListItemData(nsIContent* aContent, nsStyleContext* aStyleContext);
23952: #endif /* MOZ_XUL */
23952: 
23955:   // Function to find FrameConstructionData for aContent using one of the XUL
23955:   // display types.  Will return null if aDisplay doesn't have a XUL display
23955:   // type.  This function performs no other checks, so should only be called if
23955:   // we know for sure that the content is not something that should get a frame
23955:   // constructed by tag.
23955:   static const FrameConstructionData*
23955:     FindXULDisplayData(const nsStyleDisplay* aDisplay,
23955:                        nsIContent* aContent,
23952:                        nsStyleContext* aStyleContext);
    1: 
    1: // SVG - rods
    1: #ifdef MOZ_SVG
23954:   static const FrameConstructionData* FindSVGData(nsIContent* aContent,
23954:                                                   nsIAtom* aTag,
23954:                                                   PRInt32 aNameSpaceID,
23954:                                                   nsIFrame* aParentFrame,
23954:                                                   nsStyleContext* aStyleContext);
23954: 
23954:   nsresult ConstructSVGForeignObjectFrame(nsFrameConstructorState& aState,
25769:                                           FrameConstructionItem&   aItem,
    1:                                           nsIFrame* aParentFrame,
23954:                                           const nsStyleDisplay* aStyleDisplay,
    1:                                           nsFrameItems& aFrameItems,
23954:                                           nsIFrame** aNewFrame);
    1: #endif
    1: 
25131:   /* Not static because it does PropagateScrollToViewport.  If this
25131:      changes, make this static */
25131:   const FrameConstructionData*
26207:     FindDisplayData(const nsStyleDisplay* aDisplay, nsIContent* aContent,
26207:                     nsStyleContext* aStyleContext);
25131: 
25131:   /**
25131:    * Construct a scrollable block frame
25131:    */
25131:   nsresult ConstructScrollableBlock(nsFrameConstructorState& aState,
25769:                                     FrameConstructionItem&   aItem,
25131:                                     nsIFrame*                aParentFrame,
    1:                                     const nsStyleDisplay*    aDisplay,
25131:                                     nsFrameItems&            aFrameItems,
25131:                                     nsIFrame**               aNewFrame);
25131: 
25131:   /**
25131:    * Construct a non-scrollable block frame
25131:    */
25131:   nsresult ConstructNonScrollableBlock(nsFrameConstructorState& aState,
25769:                                        FrameConstructionItem&   aItem,
25131:                                        nsIFrame*                aParentFrame,
25131:                                        const nsStyleDisplay*    aDisplay,
    1:                                        nsFrameItems&            aFrameItems,
25131:                                        nsIFrame**               aNewFrame);
    1: 
23352:   /**
23352:    * Construct the frames for the children of aContent.  "children" is defined
23352:    * as "whatever ChildIterator returns for aContent".  This means we're
23352:    * basically operating on children in the "flattened tree" per sXBL/XBL2.
23352:    * This method will also handle constructing ::before, ::after,
23352:    * ::first-letter, and ::first-line frames, as needed and if allowed.
23352:    *
23352:    * If the parent is a float containing block, this method will handle pushing
23352:    * it as the float containing block in aState (so there's no need for callers
23352:    * to push it themselves).
23352:    *
23352:    * @param aState the frame construction state
23352:    * @param aContent the content node whose children need frames
23352:    * @param aStyleContext the style context for aContent
23352:    * @param aFrame the frame to use as the parent frame for the new in-flow
23352:    *        kids. Note that this must be its own content insertion frame, but
23352:    *        need not be be the primary frame for aContent.  This frame will be
23352:    *        pushed as the float containing block, as needed.  aFrame is also
23352:    *        used to find the parent style context for the kids' style contexts
23352:    *        (not necessary aFrame's style context).
23352:    * @param aCanHaveGeneratedContent Whether to allow :before and
23352:    *        :after styles on the parent.
23352:    * @param aFrameItems the list in which we should place the in-flow children
23352:    * @param aAllowBlockStyles Whether to allow first-letter and first-line
23352:    *        styles on the parent.
34614:    * @param aPendingBinding Make sure to push this into aState before doing any
34614:    *        child item construction.
23352:    */
    1:   nsresult ProcessChildren(nsFrameConstructorState& aState,
    1:                            nsIContent*              aContent,
23352:                            nsStyleContext*          aStyleContext,
    1:                            nsIFrame*                aFrame,
25768:                            const PRBool             aCanHaveGeneratedContent,
    1:                            nsFrameItems&            aFrameItems,
34614:                            const PRBool             aAllowBlockStyles,
34614:                            PendingBinding*          aPendingBinding);
    1: 
    1:   nsIFrame* GetFrameFor(nsIContent* aContent);
    1: 
    1:   /**
10522:    * These two functions are used when we start frame creation from a non-root
    1:    * element. They should recreate the same state that we would have
    1:    * arrived at if we had built frames from the root frame to aFrame.
    1:    * Therefore, any calls to PushFloatContainingBlock and
    1:    * PushAbsoluteContainingBlock during frame construction should get
    1:    * corresponding logic in these functions.
    1:    */
10522: public:
    1:   nsIFrame* GetAbsoluteContainingBlock(nsIFrame* aFrame);
10522: private:
    1:   nsIFrame* GetFloatContainingBlock(nsIFrame* aFrame);
    1: 
    1:   nsIContent* PropagateScrollToViewport();
    1: 
    1:   // Build a scroll frame: 
    1:   //  Calls BeginBuildingScrollFrame, InitAndRestoreFrame, and then FinishBuildingScrollFrame.
    1:   // @param aNewFrame the created scrollframe --- output only
23395:   // @param aParentFrame the geometric parent that the scrollframe will have.
    1:   nsresult
    1:   BuildScrollFrame(nsFrameConstructorState& aState,
    1:                    nsIContent*              aContent,
    1:                    nsStyleContext*          aContentStyle,
    1:                    nsIFrame*                aScrolledFrame,
    1:                    nsIFrame*                aParentFrame,
23950:                    nsIFrame*&               aNewFrame);
    1: 
    1:   // Builds the initial ScrollFrame
    1:   already_AddRefed<nsStyleContext>
    1:   BeginBuildingScrollFrame(nsFrameConstructorState& aState,
    1:                            nsIContent*              aContent,
    1:                            nsStyleContext*          aContentStyle,
    1:                            nsIFrame*                aParentFrame,
    1:                            nsIAtom*                 aScrolledPseudo,
    1:                            PRBool                   aIsRoot,
    1:                            nsIFrame*&               aNewFrame);
    1: 
    1:   // Completes the building of the scrollframe:
    1:   // Creates a view for the scrolledframe and makes it the child of the scrollframe.
    1:   void
    1:   FinishBuildingScrollFrame(nsIFrame* aScrollFrame,
    1:                             nsIFrame* aScrolledFrame);
    1: 
    1:   // InitializeSelectFrame puts scrollFrame in aFrameItems if aBuildCombobox is false
    1:   nsresult
    1:   InitializeSelectFrame(nsFrameConstructorState& aState,
    1:                         nsIFrame*                scrollFrame,
    1:                         nsIFrame*                scrolledFrame,
    1:                         nsIContent*              aContent,
    1:                         nsIFrame*                aParentFrame,
    1:                         nsStyleContext*          aStyleContext,
    1:                         PRBool                   aBuildCombobox,
34614:                         PendingBinding*          aPendingBinding,
    1:                         nsFrameItems&            aFrameItems);
    1: 
42329:   nsresult MaybeRecreateFramesForElement(Element* aElement);
    1: 
31031:   // If aAsyncInsert is true then a restyle event will be posted to handle the
31031:   // required ContentInserted call instead of doing it immediately.
31031:   nsresult RecreateFramesForContent(nsIContent* aContent, PRBool aAsyncInsert);
    1: 
 4696:   // If removal of aFrame from the frame tree requires reconstruction of some
26471:   // containing block (either of aFrame or of its parent) due to {ib} splits or
26471:   // table pseudo-frames, recreate the relevant frame subtree.  The return value
26471:   // indicates whether this happened.  If this method returns true, *aResult is
36653:   // the return value of ReframeContainingBlock or RecreateFramesForContent.  If
36653:   // this method returns false, the value of *aResult is not affected.  aFrame
36653:   // and aResult must not be null.  aFrame must be the result of a
36653:   // GetPrimaryFrame() call on a content node (which means its parent is also
36653:   // not null).
26471:   PRBool MaybeRecreateContainerForFrameRemoval(nsIFrame* aFrame,
 4696:                                                nsresult* aResult);
    1: 
    1:   nsresult CreateContinuingOuterTableFrame(nsIPresShell*    aPresShell, 
    1:                                            nsPresContext*  aPresContext,
    1:                                            nsIFrame*        aFrame,
    1:                                            nsIFrame*        aParentFrame,
    1:                                            nsIContent*      aContent,
    1:                                            nsStyleContext*  aStyleContext,
    1:                                            nsIFrame**       aContinuingFrame);
    1: 
    1:   nsresult CreateContinuingTableFrame(nsIPresShell*    aPresShell, 
    1:                                       nsPresContext*  aPresContext,
    1:                                       nsIFrame*        aFrame,
    1:                                       nsIFrame*        aParentFrame,
    1:                                       nsIContent*      aContent,
    1:                                       nsStyleContext*  aStyleContext,
    1:                                       nsIFrame**       aContinuingFrame);
    1: 
    1:   //----------------------------------------
    1: 
    1:   // Methods support creating block frames and their children
    1: 
    1:   already_AddRefed<nsStyleContext>
    1:   GetFirstLetterStyle(nsIContent*      aContent,
    1:                       nsStyleContext*  aStyleContext);
    1: 
    1:   already_AddRefed<nsStyleContext>
    1:   GetFirstLineStyle(nsIContent*      aContent,
    1:                     nsStyleContext*  aStyleContext);
    1: 
 1254:   PRBool ShouldHaveFirstLetterStyle(nsIContent*      aContent,
    1:                                     nsStyleContext*  aStyleContext);
    1: 
  551:   // Check whether a given block has first-letter style.  Make sure to
  551:   // only pass in blocks!  And don't pass in null either.
 1254:   PRBool HasFirstLetterStyle(nsIFrame* aBlockFrame);
  551: 
 1254:   PRBool ShouldHaveFirstLineStyle(nsIContent*      aContent,
    1:                                   nsStyleContext*  aStyleContext);
    1: 
 1254:   void ShouldHaveSpecialBlockStyle(nsIContent*      aContent,
    1:                                    nsStyleContext*  aStyleContext,
    1:                                    PRBool*          aHaveFirstLetterStyle,
    1:                                    PRBool*          aHaveFirstLineStyle);
    1: 
    1:   // |aContentParentFrame| should be null if it's really the same as
    1:   // |aParentFrame|.
    1:   // @param aFrameItems where we want to put the block in case it's in-flow.
    1:   // @param aNewFrame an in/out parameter. On input it is the block to be
    1:   // constructed. On output it is reset to the outermost
    1:   // frame constructed (e.g. if we need to wrap the block in an
    1:   // nsColumnSetFrame.
    1:   // @param aParentFrame is the desired parent for the (possibly wrapped)
    1:   // block
    1:   // @param aContentParent is the parent the block would have if it
    1:   // were in-flow
34614:   // @param aPendingBinding the pending binding  from this block's frame
34614:   // construction item.
    1:   nsresult ConstructBlock(nsFrameConstructorState& aState,
    1:                           const nsStyleDisplay*    aDisplay,
    1:                           nsIContent*              aContent,
    1:                           nsIFrame*                aParentFrame,
    1:                           nsIFrame*                aContentParentFrame,
    1:                           nsStyleContext*          aStyleContext,
    1:                           nsIFrame**               aNewFrame,
    1:                           nsFrameItems&            aFrameItems,
34614:                           PRBool                   aAbsPosContainer,
34614:                           PendingBinding*          aPendingBinding);
    1: 
    1:   nsresult ConstructInline(nsFrameConstructorState& aState,
25769:                            FrameConstructionItem&   aItem,
    1:                            nsIFrame*                aParentFrame,
25131:                            const nsStyleDisplay*    aDisplay,
25131:                            nsFrameItems&            aFrameItems,
25131:                            nsIFrame**               aNewFrame);
    1: 
 4696:   /**
34462:    * Create any additional {ib} siblings needed to contain aChildItems and put
34462:    * them in aSiblings.
34462:    *
34462:    * @param aState the frame constructor state
34462:    * @param aInitialInline is an already-existing inline frame that will be
34462:    *                       part of this {ib} split and come before everything
34462:    *                       in aSiblings.
34462:    * @param aIsPositioned true if aInitialInline is positioned.
34462:    * @param aChildItems is a child list starting with a block; this method
34462:    *                    assumes that the inline has already taken all the
34462:    *                    children it wants.  When the method returns aChildItems
34462:    *                    will be empty.
34462:    * @param aSiblings the nsFrameItems to put the newly-created siblings into.
34462:    *
34462:    * This method is responsible for making any SetFrameIsSpecial calls that are
34462:    * needed.
34462:    */
34462:   void CreateIBSiblings(nsFrameConstructorState& aState,
34462:                         nsIFrame* aInitialInline,
34462:                         PRBool aIsPositioned,
34462:                         nsFrameItems& aChildItems,
34462:                         nsFrameItems& aSiblings);
34462: 
34462:   /**
25772:    * For an inline aParentItem, construct its list of child
25772:    * FrameConstructionItems and set its mIsAllInline flag appropriately.
25772:    */
25772:   void BuildInlineChildItems(nsFrameConstructorState& aState,
25772:                              FrameConstructionItem& aParentItem);
25772: 
 4696:   // Determine whether we need to wipe out what we just did and start over
 4696:   // because we're doing something like adding block kids to an inline frame
27310:   // (and therefore need an {ib} split).  aPrevSibling must be correct, even in
27310:   // aIsAppend cases.  Passing aIsAppend false even when an append is happening
27310:   // is ok in terms of correctness, but can lead to unnecessary reframing.  If
27310:   // aIsAppend is true, then the caller MUST call
27310:   // nsCSSFrameConstructor::AppendFrames (as opposed to
27310:   // nsFrameManager::InsertFrames directly) to add the new frames.
 4696:   // @return PR_TRUE if we reconstructed the containing block, PR_FALSE
 4696:   // otherwise
    1:   PRBool WipeContainingBlock(nsFrameConstructorState& aState,
 4696:                              nsIFrame*                aContainingBlock,
    1:                              nsIFrame*                aFrame,
27311:                              FrameConstructionItemList& aItems,
 4696:                              PRBool                   aIsAppend,
 4696:                              nsIFrame*                aPrevSibling);
    1: 
    1:   nsresult ReframeContainingBlock(nsIFrame* aFrame);
    1: 
31101:   nsresult StyleChangeReflow(nsIFrame* aFrame, nsChangeHint aHint);
    1: 
    1:   //----------------------------------------
    1: 
    1:   // Methods support :first-letter style
    1: 
    1:   void CreateFloatingLetterFrame(nsFrameConstructorState& aState,
    1:                                  nsIFrame*                aBlockFrame,
    1:                                  nsIContent*              aTextContent,
    1:                                  nsIFrame*                aTextFrame,
    1:                                  nsIContent*              aBlockContent,
    1:                                  nsIFrame*                aParentFrame,
    1:                                  nsStyleContext*          aStyleContext,
    1:                                  nsFrameItems&            aResult);
    1: 
23461:   nsresult CreateLetterFrame(nsIFrame*                aBlockFrame,
37867:                              nsIFrame*                aBlockContinuation,
    1:                              nsIContent*              aTextContent,
    1:                              nsIFrame*                aParentFrame,
    1:                              nsFrameItems&            aResult);
    1: 
23461:   nsresult WrapFramesInFirstLetterFrame(nsIContent*   aBlockContent,
    1:                                         nsIFrame*     aBlockFrame,
    1:                                         nsFrameItems& aBlockFrames);
    1: 
37867:   /**
37867:    * Looks in the block aBlockFrame for a text frame that contains the
37867:    * first-letter of the block and creates the necessary first-letter frames
37867:    * and returns them in aLetterFrames.
37867:    *
37867:    * @param aBlockFrame the (first-continuation of) the block we are creating a
37867:    *                    first-letter frame for
37867:    * @param aBlockContinuation the current continuation of the block that we
37867:    *                           are looking in for a textframe with suitable
37867:    *                           contents for first-letter
37867:    * @param aParentFrame the current frame whose children we are looking at for
37867:    *                     a suitable first-letter textframe
37867:    * @param aParentFrameList the first child of aParentFrame
37867:    * @param aModifiedParent returns the parent of the textframe that contains
37867:    *                        the first-letter
37867:    * @param aTextFrame returns the textframe that had the first-letter
37867:    * @param aPrevFrame returns the previous sibling of aTextFrame
37867:    * @param aLetterFrames returns the frames that were created
37867:    * @param aStopLooking returns whether we should stop looking for a
37867:    *                     first-letter either because it was found or won't be
37867:    *                     found
37867:    */
23461:   nsresult WrapFramesInFirstLetterFrame(nsIFrame*     aBlockFrame,
37867:                                         nsIFrame*     aBlockContinuation,
    1:                                         nsIFrame*     aParentFrame,
    1:                                         nsIFrame*     aParentFrameList,
    1:                                         nsIFrame**    aModifiedParent,
    1:                                         nsIFrame**    aTextFrame,
    1:                                         nsIFrame**    aPrevFrame,
37867:                                         nsFrameItems& aLetterFrames,
    1:                                         PRBool*       aStopLooking);
    1: 
23461:   nsresult RecoverLetterFrames(nsIFrame* aBlockFrame);
    1: 
    1:   // 
    1:   nsresult RemoveLetterFrames(nsPresContext*  aPresContext,
    1:                               nsIPresShell*    aPresShell,
    1:                               nsFrameManager*  aFrameManager,
    1:                               nsIFrame*        aBlockFrame);
    1: 
    1:   // Recursive helper for RemoveLetterFrames
    1:   nsresult RemoveFirstLetterFrames(nsPresContext*  aPresContext,
    1:                                    nsIPresShell*    aPresShell,
    1:                                    nsFrameManager*  aFrameManager,
    1:                                    nsIFrame*        aFrame,
36804:                                    nsIFrame*        aBlockFrame,
    1:                                    PRBool*          aStopLooking);
    1: 
    1:   // Special remove method for those pesky floating first-letter frames
    1:   nsresult RemoveFloatingFirstLetterFrames(nsPresContext*  aPresContext,
    1:                                            nsIPresShell*    aPresShell,
    1:                                            nsFrameManager*  aFrameManager,
    1:                                            nsIFrame*        aBlockFrame,
    1:                                            PRBool*          aStopLooking);
    1: 
    1:   // Capture state for the frame tree rooted at the frame associated with the
    1:   // content object, aContent
    1:   nsresult CaptureStateForFramesOf(nsIContent* aContent,
    1:                                    nsILayoutHistoryState* aHistoryState);
    1: 
    1:   // Capture state for the frame tree rooted at aFrame.
    1:   nsresult CaptureStateFor(nsIFrame*              aFrame,
    1:                            nsILayoutHistoryState* aHistoryState);
    1: 
    1:   //----------------------------------------
    1: 
    1:   // Methods support :first-line style
    1: 
30788:   // This method chops the initial inline-outside frames out of aFrameItems.
30788:   // If aLineFrame is non-null, it appends them to that frame.  Otherwise, it
30788:   // creates a new line frame, sets the inline frames as its initial child
30788:   // list, and inserts that line frame at the front of what's left of
30788:   // aFrameItems.  In both cases, the kids are reparented to the line frame.
30788:   // After this call, aFrameItems holds the frames that need to become kids of
30788:   // the block (possibly including line frames).
    1:   nsresult WrapFramesInFirstLineFrame(nsFrameConstructorState& aState,
    1:                                       nsIContent*              aBlockContent,
    1:                                       nsIFrame*                aBlockFrame,
30788:                                       nsIFrame*                aLineFrame,
    1:                                       nsFrameItems&            aFrameItems);
    1: 
30788:   // Handle the case when a block with first-line style is appended to (by
30788:   // possibly calling WrapFramesInFirstLineFrame as needed).
    1:   nsresult AppendFirstLineFrames(nsFrameConstructorState& aState,
    1:                                  nsIContent*              aContent,
    1:                                  nsIFrame*                aBlockFrame,
    1:                                  nsFrameItems&            aFrameItems);
    1: 
    1:   nsresult InsertFirstLineFrames(nsFrameConstructorState& aState,
    1:                                  nsIContent*              aContent,
    1:                                  nsIFrame*                aBlockFrame,
    1:                                  nsIFrame**               aParentFrame,
    1:                                  nsIFrame*                aPrevSibling,
    1:                                  nsFrameItems&            aFrameItems);
    1: 
 7655:   // Find the right frame to use for aContent when looking for sibling
 7655:   // frames for aTargetContent.  If aPrevSibling is true, this
 7655:   // will look for last continuations, etc, as necessary.  This calls
 7655:   // IsValidSibling as needed; if that returns false it returns null.
 7655:   //
 7655:   // @param aTargetContentDisplay the CSS display enum for aTargetContent if
40939:   // already known, UNSET_DISPLAY otherwise. It will be filled in if needed.
 7655:   nsIFrame* FindFrameForContentSibling(nsIContent* aContent,
 7655:                                        nsIContent* aTargetContent,
 7655:                                        PRUint8& aTargetContentDisplay,
 7655:                                        PRBool aPrevSibling);
 7655: 
24404:   // Find the ``rightmost'' frame for the content immediately preceding the one
24404:   // aIter points to, following continuations if necessary.  aIter is passed by
40939:   // value on purpose, so as not to modify the caller's iterator.
24404:   nsIFrame* FindPreviousSibling(const ChildIterator& aFirst,
40939:                                 ChildIterator aIter,
40939:                                 PRUint8& aTargetContentDisplay);
    1: 
24404:   // Find the frame for the content node immediately following the one aIter
24404:   // points to, following continuations if necessary.  aIter is passed by value
40939:   // on purpose, so as not to modify the caller's iterator.
24404:   nsIFrame* FindNextSibling(ChildIterator aIter,
40939:                             const ChildIterator& aLast,
40939:                             PRUint8& aTargetContentDisplay);
    1: 
27696:   // Find the right previous sibling for an insertion.  This also updates the
27696:   // parent frame to point to the correct continuation of the parent frame to
27696:   // use, and returns whether this insertion is to be treated as an append.
47663:   // aChild is the child being inserted.
40939:   // aIsRangeInsertSafe returns whether it is safe to do a range insert with
40939:   // aChild being the first child in the range. It is the callers'
40939:   // responsibility to check whether a range insert is safe with regards to
40939:   // fieldsets.
40939:   // The skip parameters are used to ignore a range of children when looking
47663:   // for a sibling. All nodes starting from aStartSkipChild and up to but not
47663:   // including aEndSkipChild will be skipped over when looking for sibling
47663:   // frames. Skipping a range can deal with XBL but not when there are multiple
47663:   // insertion points.
27696:   nsIFrame* GetInsertionPrevSibling(nsIFrame*& aParentFrame, /* inout */
27696:                                     nsIContent* aContainer,
27696:                                     nsIContent* aChild,
40939:                                     PRBool* aIsAppend,
40939:                                     PRBool* aIsRangeInsertSafe,
40939:                                     nsIContent* aStartSkipChild = nsnull,
40939:                                     nsIContent *aEndSkipChild = nsnull);
27696: 
    1:   // see if aContent and aSibling are legitimate siblings due to restrictions
    1:   // imposed by table columns
 1502:   // XXXbz this code is generally wrong, since the frame for aContent
 1502:   // may be constructed based on tag, not based on aDisplay!
 7655:   PRBool IsValidSibling(nsIFrame*              aSibling,
 7655:                         nsIContent*            aContent,
    1:                         PRUint8&               aDisplay);
    1:   
    1:   void QuotesDirty() {
 6518:     NS_PRECONDITION(mUpdateCount != 0, "Instant quote updates are bad news");
    1:     mQuotesDirty = PR_TRUE;
    1:   }
    1: 
    1:   void CountersDirty() {
 6518:     NS_PRECONDITION(mUpdateCount != 0, "Instant counter updates are bad news");
    1:     mCountersDirty = PR_TRUE;
    1:   }
    1: 
    1: public:
    1: 
    1:   friend class nsFrameConstructorState;
    1: 
    1: private:
 3129: 
    1:   nsIDocument*        mDocument;  // Weak ref
    1:   nsIPresShell*       mPresShell; // Weak ref
    1: 
18953:   // See the comment at the start of ConstructRootFrame for more details
18953:   // about the following frames.
18953:   
24659:   // This is just the outermost frame for the root element.
24659:   nsIFrame*           mRootElementFrame;
16509:   // This is the frame for the root element that has no pseudo-element style.
16509:   nsIFrame*           mRootElementStyleFrame;
28215:   // This is the containing block for fixed-pos frames --- the
28215:   // viewport or page frame
    1:   nsIFrame*           mFixedContainingBlock;
16509:   // This is the containing block that contains the root element ---
16509:   // the real "initial containing block" according to CSS 2.1.
    1:   nsIFrame*           mDocElementContainingBlock;
    1:   nsIFrame*           mGfxScrollFrame;
    1:   nsIFrame*           mPageSequenceFrame;
    1:   nsQuoteList         mQuoteList;
    1:   nsCounterManager    mCounterManager;
    1:   PRUint16            mUpdateCount;
    1:   PRPackedBool        mQuotesDirty : 1;
    1:   PRPackedBool        mCountersDirty : 1;
    1:   PRPackedBool        mIsDestroyingFrameTree : 1;
10073:   PRPackedBool        mRebuildAllStyleData : 1;
18953:   // This is true if mDocElementContainingBlock supports absolute positioning
18953:   PRPackedBool        mHasRootAbsPosContainingBlock : 1;
36797:   // True if we're already waiting for a refresh notification
36797:   PRPackedBool        mObservingRefreshDriver : 1;
36797:   // True if we're in the middle of a nsRefreshDriver refresh
36797:   PRPackedBool        mInStyleRefresh : 1;
22471:   PRUint32            mHoverGeneration;
22339:   nsChangeHint        mRebuildAllExtraHint;
    1: 
    1:   nsCOMPtr<nsILayoutHistoryState> mTempFrameTreeState;
    1: 
43788:   RestyleTracker mPendingRestyles;
43788:   RestyleTracker mPendingAnimationRestyles;
    1: 
    1:   static nsIXBLService * gXBLService;
    1: };
    1: 
    1: #endif /* nsCSSFrameConstructor_h___ */
