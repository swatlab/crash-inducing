126599: /* This Source Code Form is subject to the terms of the Mozilla Public
126599:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
126599:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
126599: 
126599: // This file is an XPCOM component that implements nsIContentPrefService2.
126599: // Although it's a JSM, it's not intended to be imported by consumers like JSMs
126599: // are usually imported.  It's only a JSM so that nsContentPrefService.js can
126599: // easily use it.  Consumers should access this component with the usual XPCOM
126599: // rigmarole:
126599: //
126599: //   Cc["@mozilla.org/content-pref/service;1"].
126599: //   getService(Ci.nsIContentPrefService2);
126599: //
126599: // That contract ID actually belongs to nsContentPrefService.js, which, when
126599: // QI'ed to nsIContentPrefService2, returns an instance of this component.
126599: //
126599: // The plan is to eventually remove nsIContentPrefService and its
126599: // implementation, nsContentPrefService.js.  At such time this file can stop
126599: // being a JSM, and the "_cps" parts that ContentPrefService2 relies on and
126599: // NSGetFactory and all the other XPCOM initialization goop in
126599: // nsContentPrefService.js can be moved here.
126599: //
126599: // See https://bugzilla.mozilla.org/show_bug.cgi?id=699859
126599: 
126599: let EXPORTED_SYMBOLS = [
126599:   "ContentPrefService2",
126599: ];
126599: 
126599: const { interfaces: Ci, classes: Cc, results: Cr, utils: Cu } = Components;
126599: 
126599: Cu.import("resource://gre/modules/Services.jsm");
126599: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
126599: Cu.import("resource://gre/modules/ContentPrefStore.jsm");
126599: 
126599: function ContentPrefService2(cps) {
126599:   this._cps = cps;
126599:   this._cache = cps._cache;
126599:   this._pbStore = cps._privModeStorage;
126599: }
126599: 
126599: ContentPrefService2.prototype = {
126599: 
126599:   getByDomainAndName: function CPS2_getByDomainAndName(group, name, context,
126599:                                                        callback) {
126599:     checkGroupArg(group);
126599:     this._get(group, name, false, context, callback);
126599:   },
126599: 
126599:   getBySubdomainAndName: function CPS2_getBySubdomainAndName(group, name,
126599:                                                              context,
126599:                                                              callback) {
126599:     checkGroupArg(group);
126599:     this._get(group, name, true, context, callback);
126599:   },
126599: 
126599:   getGlobal: function CPS2_getGlobal(name, context, callback) {
126599:     this._get(null, name, false, context, callback);
126599:   },
126599: 
126599:   _get: function CPS2__get(group, name, includeSubdomains, context, callback) {
126599:     group = this._parseGroup(group);
126599:     checkNameArg(name);
126599:     checkCallbackArg(callback, true);
126599: 
126599:     // Some prefs may be in both the database and the private browsing store.
126599:     // Notify the caller of such prefs only once, using the values from private
126599:     // browsing.
126599:     let pbPrefs = new ContentPrefStore();
126599:     if (context && context.usePrivateBrowsing) {
126599:       for (let [sgroup, val] in
126599:              this._pbStore.match(group, name, includeSubdomains)) {
126599:         pbPrefs.set(sgroup, name, val);
126599:       }
126599:     }
126599: 
126599:     this._execStmts([this._commonGetStmt(group, name, includeSubdomains)], {
126599:       onRow: function onRow(row) {
126599:         let grp = row.getResultByName("grp");
126599:         let val = row.getResultByName("value");
126599:         this._cache.set(grp, name, val);
126599:         if (!pbPrefs.has(group, name))
126599:           cbHandleResult(callback, new ContentPref(grp, name, val));
126599:       },
126599:       onDone: function onDone(reason, ok, gotRow) {
126599:         if (ok) {
126599:           if (!gotRow)
126599:             this._cache.set(group, name, undefined);
126599:           for (let [pbGroup, pbName, pbVal] in pbPrefs) {
126599:             cbHandleResult(callback, new ContentPref(pbGroup, pbName, pbVal));
126599:           }
126599:         }
126599:         cbHandleCompletion(callback, reason);
126599:       },
126599:       onError: function onError(nsresult) {
126599:         cbHandleError(callback, nsresult);
126599:       }
126599:     });
126599:   },
126599: 
126599:   _commonGetStmt: function CPS2__commonGetStmt(group, name, includeSubdomains) {
126599:     let stmt = group ?
126599:       this._stmtWithGroupClause(group, includeSubdomains,
126599:         "SELECT groups.name AS grp, prefs.value AS value",
126599:         "FROM prefs",
126599:         "JOIN settings ON settings.id = prefs.settingID",
126599:         "JOIN groups ON groups.id = prefs.groupID",
126599:         "WHERE settings.name = :name AND prefs.groupID IN ($)"
126599:       ) :
126599:       this._stmt(
126599:         "SELECT NULL AS grp, prefs.value AS value",
126599:         "FROM prefs",
126599:         "JOIN settings ON settings.id = prefs.settingID",
126599:         "WHERE settings.name = :name AND prefs.groupID ISNULL"
126599:       );
126599:     stmt.params.name = name;
126599:     return stmt;
126599:   },
126599: 
126599:   _stmtWithGroupClause: function CPS2__stmtWithGroupClause(group,
126599:                                                            includeSubdomains) {
126599:     let stmt = this._stmt(joinArgs(Array.slice(arguments, 2)).replace("$",
126599:       "SELECT id " +
126599:       "FROM groups " +
126599:       "WHERE name = :group OR " +
126599:             "(:includeSubdomains AND name LIKE :pattern ESCAPE '/')"
126599:     ));
126599:     stmt.params.group = group;
126599:     stmt.params.includeSubdomains = includeSubdomains || false;
126599:     stmt.params.pattern = "%." + stmt.escapeStringForLIKE(group, "/");
126599:     return stmt;
126599:   },
126599: 
126599:   getCachedByDomainAndName: function CPS2_getCachedByDomainAndName(group,
126599:                                                                    name,
126599:                                                                    context) {
126599:     checkGroupArg(group);
126599:     let prefs = this._getCached(group, name, false, context);
126599:     return prefs[0] || null;
126599:   },
126599: 
126599:   getCachedBySubdomainAndName: function CPS2_getCachedBySubdomainAndName(group,
126599:                                                                          name,
126599:                                                                          context,
126599:                                                                          len) {
126599:     checkGroupArg(group);
126599:     let prefs = this._getCached(group, name, true, context);
126599:     if (len)
126599:       len.value = prefs.length;
126599:     return prefs;
126599:   },
126599: 
126599:   getCachedGlobal: function CPS2_getCachedGlobal(name, context) {
126599:     let prefs = this._getCached(null, name, false, context);
126599:     return prefs[0] || null;
126599:   },
126599: 
126599:   _getCached: function CPS2__getCached(group, name, includeSubdomains,
126599:                                        context) {
126599:     group = this._parseGroup(group);
126599:     checkNameArg(name);
126599: 
126599:     let storesToCheck = [this._cache];
126599:     if (context && context.usePrivateBrowsing)
126599:       storesToCheck.push(this._pbStore);
126599: 
126599:     let outStore = new ContentPrefStore();
126599:     storesToCheck.forEach(function (store) {
126599:       for (let [sgroup, val] in store.match(group, name, includeSubdomains)) {
126599:         outStore.set(sgroup, name, val);
126599:       }
126599:     });
126599: 
126599:     let prefs = [];
126599:     for (let [sgroup, sname, val] in outStore) {
126599:       prefs.push(new ContentPref(sgroup, sname, val));
126599:     }
126599:     return prefs;
126599:   },
126599: 
126599:   set: function CPS2_set(group, name, value, context, callback) {
126599:     checkGroupArg(group);
126599:     this._set(group, name, value, context, callback);
126599:   },
126599: 
126599:   setGlobal: function CPS2_setGlobal(name, value, context, callback) {
126599:     this._set(null, name, value, context, callback);
126599:   },
126599: 
126599:   _set: function CPS2__set(group, name, value, context, callback) {
126599:     group = this._parseGroup(group);
126599:     checkNameArg(name);
126599:     checkValueArg(value);
126599:     checkCallbackArg(callback, false);
126599: 
126599:     if (context && context.usePrivateBrowsing) {
126599:       this._pbStore.set(group, name, value);
126599:       this._schedule(function () {
137506:         this._cps._broadcastPrefSet(group, name, value);
137490:         cbHandleCompletion(callback, Ci.nsIContentPrefCallback2.COMPLETE_OK);
126599:       });
126599:       return;
126599:     }
126599: 
126599:     let stmts = [];
126599: 
126599:     // Create the setting if it doesn't exist.
126599:     let stmt = this._stmt(
126599:       "INSERT OR IGNORE INTO settings (id, name)",
126599:       "VALUES((SELECT id FROM settings WHERE name = :name), :name)"
126599:     );
126599:     stmt.params.name = name;
126599:     stmts.push(stmt);
126599: 
126599:     // Create the group if it doesn't exist.
126599:     if (group) {
126599:       stmt = this._stmt(
126599:         "INSERT OR IGNORE INTO groups (id, name)",
126599:         "VALUES((SELECT id FROM groups WHERE name = :group), :group)"
126599:       );
126599:       stmt.params.group = group;
126599:       stmts.push(stmt);
126599:     }
126599: 
126599:     // Finally create or update the pref.
126599:     if (group) {
126599:       stmt = this._stmt(
126599:         "INSERT OR REPLACE INTO prefs (id, groupID, settingID, value)",
126599:         "VALUES(",
126599:           "(SELECT prefs.id",
126599:            "FROM prefs",
126599:            "JOIN groups ON groups.id = prefs.groupID",
126599:            "JOIN settings ON settings.id = prefs.settingID",
126599:            "WHERE groups.name = :group AND settings.name = :name),",
126599:           "(SELECT id FROM groups WHERE name = :group),",
126599:           "(SELECT id FROM settings WHERE name = :name),",
126599:           ":value",
126599:         ")"
126599:       );
126599:       stmt.params.group = group;
126599:     }
126599:     else {
126599:       stmt = this._stmt(
126599:         "INSERT OR REPLACE INTO prefs (id, groupID, settingID, value)",
126599:         "VALUES(",
126599:           "(SELECT prefs.id",
126599:            "FROM prefs",
126599:            "JOIN settings ON settings.id = prefs.settingID",
126599:            "WHERE prefs.groupID IS NULL AND settings.name = :name),",
126599:           "NULL,",
126599:           "(SELECT id FROM settings WHERE name = :name),",
126599:           ":value",
126599:         ")"
126599:       );
126599:     }
126599:     stmt.params.name = name;
126599:     stmt.params.value = value;
126599:     stmts.push(stmt);
126599: 
126599:     this._execStmts(stmts, {
126599:       onDone: function onDone(reason, ok) {
137506:         if (ok) {
126599:           this._cache.setWithCast(group, name, value);
137506:           this._cps._broadcastPrefSet(group, name, value);
137506:         }
137490:         cbHandleCompletion(callback, reason);
126599:       },
126599:       onError: function onError(nsresult) {
126599:         cbHandleError(callback, nsresult);
126599:       }
126599:     });
126599:   },
126599: 
126599:   removeByDomainAndName: function CPS2_removeByDomainAndName(group, name,
126599:                                                              context,
126599:                                                              callback) {
126599:     checkGroupArg(group);
126599:     this._remove(group, name, false, context, callback);
126599:   },
126599: 
126599:   removeBySubdomainAndName: function CPS2_removeBySubdomainAndName(group, name,
126599:                                                                    context,
126599:                                                                    callback) {
126599:     checkGroupArg(group);
126599:     this._remove(group, name, true, context, callback);
126599:   },
126599: 
126599:   removeGlobal: function CPS2_removeGlobal(name, context,callback) {
126599:     this._remove(null, name, false, context, callback);
126599:   },
126599: 
126599:   _remove: function CPS2__remove(group, name, includeSubdomains, context,
126599:                                  callback) {
126599:     group = this._parseGroup(group);
126599:     checkNameArg(name);
126599:     checkCallbackArg(callback, false);
126599: 
126599:     let stmts = [];
126599: 
126599:     // First get the matching prefs.
126599:     stmts.push(this._commonGetStmt(group, name, includeSubdomains));
126599: 
126599:     // Delete the matching prefs.
126599:     let stmt = this._stmtWithGroupClause(group, includeSubdomains,
126599:       "DELETE FROM prefs",
126599:       "WHERE settingID = (SELECT id FROM settings WHERE name = :name) AND",
126599:             "CASE typeof(:group)",
126599:             "WHEN 'null' THEN prefs.groupID IS NULL",
126599:             "ELSE prefs.groupID IN ($)",
126599:             "END"
126599:     );
126599:     stmt.params.name = name;
126599:     stmts.push(stmt);
126599: 
126599:     // Delete settings and groups that are no longer used.  The NOTNULL term in
126599:     // the subquery of the second statment is needed because of SQLite's weird
126599:     // IN behavior vis-a-vis NULLs.  See http://sqlite.org/lang_expr.html.
126599:     stmts.push(this._stmt(
126599:       "DELETE FROM settings",
126599:       "WHERE id NOT IN (SELECT DISTINCT settingID FROM prefs)"
126599:     ));
126599:     stmts.push(this._stmt(
126599:       "DELETE FROM groups WHERE id NOT IN (",
126599:         "SELECT DISTINCT groupID FROM prefs WHERE groupID NOTNULL",
126599:       ")"
126599:     ));
126599: 
126599:     let prefs = new ContentPrefStore();
126599: 
126599:     this._execStmts(stmts, {
126599:       onRow: function onRow(row) {
126599:         let grp = row.getResultByName("grp");
126599:         prefs.set(grp, name);
126599:         this._cache.set(grp, name, undefined);
126599:       },
126599:       onDone: function onDone(reason, ok) {
126599:         if (ok) {
126599:           this._cache.set(group, name, undefined);
126599:           if (context && context.usePrivateBrowsing) {
126599:             for (let [sgroup, ] in
126599:                    this._pbStore.match(group, name, includeSubdomains)) {
126599:               prefs.set(sgroup, name);
126599:               this._pbStore.remove(sgroup, name);
126599:             }
126599:           }
126599:           for (let [sgroup, , ] in prefs) {
131405:             this._cps._broadcastPrefRemoved(sgroup, name);
126599:           }
126599:         }
137506:         cbHandleCompletion(callback, reason);
126599:       },
126599:       onError: function onError(nsresult) {
126599:         cbHandleError(callback, nsresult);
126599:       }
126599:     });
126599:   },
126599: 
126599:   removeByDomain: function CPS2_removeByDomain(group, context, callback) {
126599:     checkGroupArg(group);
126599:     this._removeByDomain(group, false, context, callback);
126599:   },
126599: 
126599:   removeBySubdomain: function CPS2_removeBySubdomain(group, context, callback) {
126599:     checkGroupArg(group);
126599:     this._removeByDomain(group, true, context, callback);
126599:   },
126599: 
126599:   removeAllGlobals: function CPS2_removeAllGlobals(context, callback) {
126599:     this._removeByDomain(null, false, context, callback);
126599:   },
126599: 
126599:   _removeByDomain: function CPS2__removeByDomain(group, includeSubdomains,
126599:                                                  context, callback) {
126599:     group = this._parseGroup(group);
126599:     checkCallbackArg(callback, false);
126599: 
126599:     let stmts = [];
126599: 
126599:     // First get the matching prefs, then delete groups and prefs that reference
126599:     // deleted groups.
126599:     if (group) {
126599:       stmts.push(this._stmtWithGroupClause(group, includeSubdomains,
126599:         "SELECT groups.name AS grp, settings.name AS name",
126599:         "FROM prefs",
126599:         "JOIN settings ON settings.id = prefs.settingID",
126599:         "JOIN groups ON groups.id = prefs.groupID",
126599:         "WHERE prefs.groupID IN ($)"
126599:       ));
126599:       stmts.push(this._stmtWithGroupClause(group, includeSubdomains,
126599:         "DELETE FROM groups WHERE id IN ($)"
126599:       ));
126599:       stmts.push(this._stmt(
126599:         "DELETE FROM prefs",
126599:         "WHERE groupID NOTNULL AND groupID NOT IN (SELECT id FROM groups)"
126599:       ));
126599:     }
126599:     else {
126599:       stmts.push(this._stmt(
126599:         "SELECT NULL AS grp, settings.name AS name",
126599:         "FROM prefs",
126599:         "JOIN settings ON settings.id = prefs.settingID",
126599:         "WHERE prefs.groupID IS NULL"
126599:       ));
126599:       stmts.push(this._stmt(
126599:         "DELETE FROM prefs WHERE groupID IS NULL"
126599:       ));
126599:     }
126599: 
126599:     // Finally delete settings that are no longer referenced.
126599:     stmts.push(this._stmt(
126599:       "DELETE FROM settings",
126599:       "WHERE id NOT IN (SELECT DISTINCT settingID FROM prefs)"
126599:     ));
126599: 
126599:     let prefs = new ContentPrefStore();
126599: 
126599:     this._execStmts(stmts, {
126599:       onRow: function onRow(row) {
126599:         let grp = row.getResultByName("grp");
126599:         let name = row.getResultByName("name");
126599:         prefs.set(grp, name);
126599:         this._cache.set(grp, name, undefined);
126599:       },
126599:       onDone: function onDone(reason, ok) {
137506:         if (ok) {
137506:           if (context && context.usePrivateBrowsing) {
126599:             for (let [sgroup, sname, ] in this._pbStore) {
126599:               prefs.set(sgroup, sname);
126599:               this._pbStore.remove(sgroup, sname);
126599:             }
126599:           }
126599:           for (let [sgroup, sname, ] in prefs) {
131405:             this._cps._broadcastPrefRemoved(sgroup, sname);
126599:           }
126599:         }
137506:         cbHandleCompletion(callback, reason);
126599:       },
126599:       onError: function onError(nsresult) {
126599:         cbHandleError(callback, nsresult);
126599:       }
126599:     });
126599:   },
126599: 
126599:   removeAllDomains: function CPS2_removeAllDomains(context, callback) {
126599:     checkCallbackArg(callback, false);
126599:     let stmts = [];
126599: 
126599:     // First get the matching prefs.
126599:     stmts.push(this._stmt(
126599:       "SELECT groups.name AS grp, settings.name AS name",
126599:       "FROM prefs",
126599:       "JOIN settings ON settings.id = prefs.settingID",
126599:       "JOIN groups ON groups.id = prefs.groupID"
126599:     ));
126599: 
126599:     stmts.push(this._stmt(
126599:       "DELETE FROM prefs WHERE groupID NOTNULL"
126599:     ));
126599:     stmts.push(this._stmt(
126599:       "DELETE FROM groups"
126599:     ));
126599:     stmts.push(this._stmt(
126599:       "DELETE FROM settings",
126599:       "WHERE id NOT IN (SELECT DISTINCT settingID FROM prefs)"
126599:     ));
126599: 
126599:     let prefs = new ContentPrefStore();
126599: 
126599:     this._execStmts(stmts, {
126599:       onRow: function onRow(row) {
126599:         let grp = row.getResultByName("grp");
126599:         let name = row.getResultByName("name");
126599:         prefs.set(grp, name);
126599:         this._cache.set(grp, name, undefined);
126599:       },
126599:       onDone: function onDone(reason, ok) {
137506:         if (ok) {
137506:           if (context && context.usePrivateBrowsing) {
126599:             for (let [sgroup, sname, ] in this._pbStore) {
126599:               prefs.set(sgroup, sname);
126599:             }
126599:             this._pbStore.removeGrouped();
126599:           }
126599:           for (let [sgroup, sname, ] in prefs) {
131405:             this._cps._broadcastPrefRemoved(sgroup, sname);
126599:           }
126599:         }
137506:         cbHandleCompletion(callback, reason);
126599:       },
126599:       onError: function onError(nsresult) {
126599:         cbHandleError(callback, nsresult);
126599:       }
126599:     });
126599:   },
126599: 
126599:   removeByName: function CPS2_removeByName(name, context, callback) {
126599:     checkNameArg(name);
126599:     checkCallbackArg(callback, false);
126599: 
126599:     let stmts = [];
126599: 
126599:     // First get the matching prefs.  Include null if any of those prefs are
126599:     // global.
126599:     let stmt = this._stmt(
126599:       "SELECT groups.name AS grp",
126599:       "FROM prefs",
126599:       "JOIN settings ON settings.id = prefs.settingID",
126599:       "JOIN groups ON groups.id = prefs.groupID",
126599:       "WHERE settings.name = :name",
126599:       "UNION",
126599:       "SELECT NULL AS grp",
126599:       "WHERE EXISTS (",
126599:         "SELECT prefs.id",
126599:         "FROM prefs",
126599:         "JOIN settings ON settings.id = prefs.settingID",
126599:         "WHERE settings.name = :name AND prefs.groupID IS NULL",
126599:       ")"
126599:     );
126599:     stmt.params.name = name;
126599:     stmts.push(stmt);
126599: 
126599:     // Delete the target settings.
126599:     stmt = this._stmt(
126599:       "DELETE FROM settings WHERE name = :name"
126599:     );
126599:     stmt.params.name = name;
126599:     stmts.push(stmt);
126599: 
126599:     // Delete prefs and groups that are no longer used.
126599:     stmts.push(this._stmt(
126599:       "DELETE FROM prefs WHERE settingID NOT IN (SELECT id FROM settings)"
126599:     ));
126599:     stmts.push(this._stmt(
126599:       "DELETE FROM groups WHERE id NOT IN (",
126599:         "SELECT DISTINCT groupID FROM prefs WHERE groupID NOTNULL",
126599:       ")"
126599:     ));
126599: 
126599:     let prefs = new ContentPrefStore();
126599: 
126599:     this._execStmts(stmts, {
126599:       onRow: function onRow(row) {
126599:         let grp = row.getResultByName("grp");
126599:         prefs.set(grp, name);
126599:         this._cache.set(grp, name, undefined);
126599:       },
126599:       onDone: function onDone(reason, ok) {
137506:         if (ok) {
137506:           if (context && context.usePrivateBrowsing) {
126599:             for (let [sgroup, sname, ] in this._pbStore) {
126599:               if (sname === name) {
126599:                 prefs.set(sgroup, name);
126599:                 this._pbStore.remove(sgroup, name);
126599:               }
126599:             }
126599:           }
126599:           for (let [sgroup, , ] in prefs) {
131405:             this._cps._broadcastPrefRemoved(sgroup, name);
126599:           }
126599:         }
137506:         cbHandleCompletion(callback, reason);
126599:       },
126599:       onError: function onError(nsresult) {
126599:         cbHandleError(callback, nsresult);
126599:       }
126599:     });
126599:   },
126599: 
126599:   destroy: function CPS2_destroy() {
126599:     for each (let stmt in this._statements) {
126599:       stmt.finalize();
126599:     }
126599:   },
126599: 
126599:   /**
126599:    * Returns the cached mozIStorageAsyncStatement for the given SQL.  If no such
126599:    * statement is cached, one is created and cached.
126599:    *
126599:    * @param sql  The SQL query string.  If more than one string is given, then
126599:    *             all are concatenated.  The concatenation process inserts
126599:    *             spaces where appropriate and removes unnecessary contiguous
126599:    *             spaces.  Call like _stmt("SELECT *", "FROM foo").
126599:    * @return     The cached, possibly new, statement.
126599:    */
126599:   _stmt: function CPS2__stmt(sql /*, sql2, sql3, ... */) {
126599:     let sql = joinArgs(arguments);
126599:     if (!this._statements)
126599:       this._statements = {};
126599:     if (!this._statements[sql])
126599:       this._statements[sql] = this._cps._dbConnection.createAsyncStatement(sql);
126599:     return this._statements[sql];
126599:   },
126599: 
126599:   /**
126599:    * Executes some async statements.
126599:    *
126599:    * @param stmts      An array of mozIStorageAsyncStatements.
126599:    * @param callbacks  An object with the following methods:
126599:    *                   onRow(row) (optional)
126599:    *                     Called once for each result row.
126599:    *                     row: A mozIStorageRow.
126599:    *                   onDone(reason, reasonOK, didGetRow) (required)
126599:    *                     Called when done.
126599:    *                     reason: A nsIContentPrefService2.COMPLETE_* value.
126599:    *                     reasonOK: reason == nsIContentPrefService2.COMPLETE_OK.
126599:    *                     didGetRow: True if onRow was ever called.
126599:    *                   onError(nsresult) (optional)
126599:    *                     Called on error.
126599:    *                     nsresult: The error code.
126599:    */
126599:   _execStmts: function CPS2__execStmts(stmts, callbacks) {
126599:     let self = this;
126599:     let gotRow = false;
126599:     this._cps._dbConnection.executeAsync(stmts, stmts.length, {
126599:       handleResult: function handleResult(results) {
126599:         try {
126599:           let row = null;
126599:           while ((row = results.getNextRow())) {
126599:             gotRow = true;
126599:             if (callbacks.onRow)
126599:               callbacks.onRow.call(self, row);
126599:           }
126599:         }
126599:         catch (err) {
126599:           Cu.reportError(err);
126599:         }
126599:       },
126599:       handleCompletion: function handleCompletion(reason) {
126599:         try {
126599:           let ok = reason == Ci.mozIStorageStatementCallback.REASON_FINISHED;
126599:           callbacks.onDone.call(self,
126599:                                 ok ? Ci.nsIContentPrefCallback2.COMPLETE_OK :
126599:                                   Ci.nsIContentPrefCallback2.COMPLETE_ERROR,
126599:                                 ok, gotRow);
126599:         }
126599:         catch (err) {
126599:           Cu.reportError(err);
126599:         }
126599:       },
126599:       handleError: function handleError(error) {
126599:         try {
126599:           if (callbacks.onError)
126599:             callbacks.onError.call(self, Cr.NS_ERROR_FAILURE);
126599:         }
126599:         catch (err) {
126599:           Cu.reportError(err);
126599:         }
126599:       }
126599:     });
126599:   },
126599: 
126599:   /**
126599:    * Parses the domain (the "group", to use the database's term) from the given
126599:    * string.
126599:    *
126599:    * @param groupStr  Assumed to be either a string or falsey.
126599:    * @return          If groupStr is a valid URL string, returns the domain of
126599:    *                  that URL.  If groupStr is some other nonempty string,
126599:    *                  returns groupStr itself.  Otherwise returns null.
126599:    */
126599:   _parseGroup: function CPS2__parseGroup(groupStr) {
126599:     if (!groupStr)
126599:       return null;
126599:     try {
126599:       var groupURI = Services.io.newURI(groupStr, null, null);
126599:     }
126599:     catch (err) {
126599:       return groupStr;
126599:     }
126599:     return this._cps.grouper.group(groupURI);
126599:   },
126599: 
126599:   _schedule: function CPS2__schedule(fn) {
126599:     Services.tm.mainThread.dispatch(fn.bind(this),
126599:                                     Ci.nsIThread.DISPATCH_NORMAL);
126599:   },
126599: 
126599:   addObserverForName: function CPS2_addObserverForName(name, observer) {
126599:     this._cps.addObserver(name, observer);
126599:   },
126599: 
126599:   removeObserverForName: function CPS2_removeObserverForName(name, observer) {
126599:     this._cps.removeObserver(name, observer);
126599:   },
126599: 
126599:   /**
126599:    * Tests use this as a backchannel by calling it directly.
126599:    *
126599:    * @param subj   This value depends on topic.
126599:    * @param topic  The backchannel "method" name.
126599:    * @param data   This value depends on topic.
126599:    */
126599:   observe: function CPS2_observe(subj, topic, data) {
126599:     switch (topic) {
126599:     case "test:reset":
126599:       let fn = subj.QueryInterface(Ci.xpcIJSWeakReference).get();
126599:       this._reset(fn);
126599:       break;
126599:     case "test:db":
126599:       let obj = subj.QueryInterface(Ci.xpcIJSWeakReference).get();
126599:       obj.value = this._cps._dbConnection;
126599:       break;
126599:     }
126599:   },
126599: 
126599:   /**
126599:    * Removes all state from the service.  Used by tests.
126599:    *
126599:    * @param callback  A function that will be called when done.
126599:    */
126599:   _reset: function CPS2__reset(callback) {
126599:     this._pbStore.removeAll();
126599:     this._cache.removeAll();
126599: 
126599:     let cps = this._cps;
126599:     cps._observers = {};
126599:     cps._genericObservers = [];
126599: 
126599:     let tables = ["prefs", "groups", "settings"];
126599:     let stmts = tables.map(function (t) this._stmt("DELETE FROM", t), this);
126599:     this._execStmts(stmts, { onDone: function () callback() });
126599:   },
126599: 
126599:   QueryInterface: function CPS2_QueryInterface(iid) {
126599:     let supportedIIDs = [
130915:       Ci.nsIContentPrefService2,
126599:       Ci.nsIObserver,
126599:       Ci.nsISupports,
126599:     ];
126599:     if (supportedIIDs.some(function (i) iid.equals(i)))
126599:       return this;
126599:     if (iid.equals(Ci.nsIContentPrefService))
126599:       return this._cps;
126599:     throw Cr.NS_ERROR_NO_INTERFACE;
126599:   },
126599: };
126599: 
126599: function ContentPref(domain, name, value) {
126599:   this.domain = domain;
126599:   this.name = name;
126599:   this.value = value;
126599: }
126599: 
126599: ContentPref.prototype = {
126599:   QueryInterface: XPCOMUtils.generateQI([Ci.nsIContentPref]),
126599: };
126599: 
126599: function cbHandleResult(callback, pref) {
126599:   safeCallback(callback, "handleResult", [pref]);
126599: }
126599: 
126599: function cbHandleCompletion(callback, reason) {
126599:   safeCallback(callback, "handleCompletion", [reason]);
126599: }
126599: 
126599: function cbHandleError(callback, nsresult) {
126599:   safeCallback(callback, "handleError", [nsresult]);
126599: }
126599: 
126599: function safeCallback(callbackObj, methodName, args) {
126599:   if (!callbackObj || typeof(callbackObj[methodName]) != "function")
126599:     return;
126599:   try {
126599:     callbackObj[methodName].apply(callbackObj, args);
126599:   }
126599:   catch (err) {
126599:     Cu.reportError(err);
126599:   }
126599: }
126599: 
126599: function checkGroupArg(group) {
126599:   if (!group || typeof(group) != "string")
126599:     throw invalidArg("domain must be nonempty string.");
126599: }
126599: 
126599: function checkNameArg(name) {
126599:   if (!name || typeof(name) != "string")
126599:     throw invalidArg("name must be nonempty string.");
126599: }
126599: 
126599: function checkValueArg(value) {
126599:   if (value === undefined)
126599:     throw invalidArg("value must not be undefined.");
126599: }
126599: 
126599: function checkCallbackArg(callback, required) {
126599:   if (callback && !(callback instanceof Ci.nsIContentPrefCallback2))
126599:     throw invalidArg("callback must be an nsIContentPrefCallback2.");
126599:   if (!callback && required)
126599:     throw invalidArg("callback must be given.");
126599: }
126599: 
126599: function invalidArg(msg) {
126599:   return Components.Exception(msg, Cr.NS_ERROR_INVALID_ARG);
126599: }
126599: 
126599: function joinArgs(args) {
126599:   return Array.join(args, " ").trim().replace(/\s{2,}/g, " ");
126599: }
