108747: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
108747:  * This Source Code Form is subject to the terms of the Mozilla Public
108747:  * License, v. 2.0. If a copy of the MPL was not distributed with this
108747:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
108747: 
108747: #ifndef GFX_IMAGECONTAINER_H
108747: #define GFX_IMAGECONTAINER_H
108747: 
108747: #include "mozilla/Mutex.h"
108747: #include "mozilla/ReentrantMonitor.h"
108747: #include "gfxASurface.h" // for gfxImageFormat
108747: #include "LayersTypes.h" // for LayersBackend
108747: #include "mozilla/TimeStamp.h"
108747: #include "ImageTypes.h"
108747: 
108747: #ifdef XP_WIN
108747: struct ID3D10Texture2D;
108747: struct ID3D10Device;
108747: struct ID3D10ShaderResourceView;
108747: #endif
108747: 
108747: #ifdef XP_MACOSX
108747: #include "mozilla/gfx/MacIOSurface.h"
108747: #endif
108747: 
108747: #ifdef MOZ_WIDGET_GONK
108747: # include <ui/GraphicBuffer.h>
108747: #endif
108747: 
108747: typedef void* HANDLE;
108747: 
108747: namespace mozilla {
108747: 
108747: class CrossProcessMutex;
108747: namespace ipc {
108747: class Shmem;
108747: }
108747:     
108747: namespace layers {
108747: 
108747: class ImageContainerChild;
108747: 
108747: struct ImageBackendData
108747: {
108747:   virtual ~ImageBackendData() {}
108747: 
108747: protected:
108747:   ImageBackendData() {}
108747: };
108747: 
108747: /**
108747:  * A class representing a buffer of pixel data. The data can be in one
108747:  * of various formats including YCbCr.
108747:  * 
108747:  * Create an image using an ImageContainer. Fill the image with data, and
108747:  * then call ImageContainer::SetImage to display it. An image must not be
108747:  * modified after calling SetImage. Image implementations do not need to
108747:  * perform locking; when filling an Image, the Image client is responsible
108747:  * for ensuring only one thread accesses the Image at a time, and after
108747:  * SetImage the image is immutable.
108747:  * 
108747:  * When resampling an Image, only pixels within the buffer should be
108747:  * sampled. For example, cairo images should be sampled in EXTEND_PAD mode.
108747:  */
108747: class THEBES_API Image {
108747:   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(Image)
108747: 
108747: public:
108747:   virtual ~Image() {}
108747: 
108747: 
108747:   ImageFormat GetFormat() { return mFormat; }
108747:   void* GetImplData() { return mImplData; }
108747: 
108747:   virtual already_AddRefed<gfxASurface> GetAsSurface() = 0;
108747:   virtual gfxIntSize GetSize() = 0;
108747: 
108747:   ImageBackendData* GetBackendData(LayersBackend aBackend)
108747:   { return mBackendData[aBackend]; }
108747:   void SetBackendData(LayersBackend aBackend, ImageBackendData* aData)
108747:   { mBackendData[aBackend] = aData; }
108747: 
109106:   int32_t GetSerial() { return mSerial; }
109083: 
108747: protected:
108747:   Image(void* aImplData, ImageFormat aFormat) :
108747:     mImplData(aImplData),
109083:     mSerial(PR_ATOMIC_INCREMENT(&sSerialCounter)),
108747:     mFormat(aFormat)
108747:   {}
108747: 
108747:   nsAutoPtr<ImageBackendData> mBackendData[mozilla::layers::LAYERS_LAST];
108747: 
108747:   void* mImplData;
109106:   int32_t mSerial;
108747:   ImageFormat mFormat;
109106:   static int32_t sSerialCounter;
108747: };
108747: 
108747: /**
108747:  * A RecycleBin is owned by an ImageContainer. We store buffers in it that we
108747:  * want to recycle from one image to the next.It's a separate object from 
108747:  * ImageContainer because images need to store a strong ref to their RecycleBin
108747:  * and we must avoid creating a reference loop between an ImageContainer and
108747:  * its active image.
108747:  */
108747: class BufferRecycleBin {
108747:   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(RecycleBin)
108747: 
108747:   //typedef mozilla::gl::GLContext GLContext;
108747: 
108747: public:
108747:   BufferRecycleBin();
108747: 
108991:   void RecycleBuffer(uint8_t* aBuffer, uint32_t aSize);
108747:   // Returns a recycled buffer of the right size, or allocates a new buffer.
108991:   uint8_t* GetBuffer(uint32_t aSize);
108747: 
108747: private:
108747:   typedef mozilla::Mutex Mutex;
108747: 
108747:   // This protects mRecycledBuffers, mRecycledBufferSize, mRecycledTextures
108747:   // and mRecycledTextureSizes
108747:   Mutex mLock;
108747: 
108747:   // We should probably do something to prune this list on a timer so we don't
108747:   // eat excess memory while video is paused...
108991:   nsTArray<nsAutoArrayPtr<uint8_t> > mRecycledBuffers;
108747:   // This is only valid if mRecycledBuffers is non-empty
108991:   uint32_t mRecycledBufferSize;
108747: };
108747: 
108747: /**
108747:  * Returns true if aFormat is in the given format array.
108747:  */
108747: static inline bool
108991: FormatInList(const ImageFormat* aFormats, uint32_t aNumFormats,
108747:              ImageFormat aFormat)
108747: {
108991:   for (uint32_t i = 0; i < aNumFormats; ++i) {
108747:     if (aFormats[i] == aFormat) {
108747:       return true;
108747:     }
108747:   }
108747:   return false;
108747: }
108747: 
108747: class CompositionNotifySink
108747: {
108747: public:
108747:   virtual void DidComposite() = 0;
108747:   virtual ~CompositionNotifySink() {}
108747: };
108747: 
108747: /**
108747:  * A class that manages Image creation for a LayerManager. The only reason
108747:  * we need a separate class here is that LayerMananers aren't threadsafe
108747:  * (because layers can only be used on the main thread) and we want to
108747:  * be able to create images from any thread, to facilitate video playback
108747:  * without involving the main thread, for example.
108747:  * Different layer managers can implement child classes of this making it
108747:  * possible to create layer manager specific images.
108747:  * This class is not meant to be used directly but rather can be set on an
108747:  * image container. This is usually done by the layer system internally and
108747:  * not explicitly by users. For PlanarYCbCr or Cairo images the default
108747:  * implementation will creates images whose data lives in system memory, for
108747:  * MacIOSurfaces the default implementation will be a simple MacIOSurface
108747:  * wrapper.
108747:  */
108747: 
108747: class THEBES_API ImageFactory
108747: {
108747:   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ImageFactory)
108747: protected:
108747:   friend class ImageContainer;
108747: 
108747:   ImageFactory() {}
108747:   virtual ~ImageFactory() {}
108747: 
108747:   virtual already_AddRefed<Image> CreateImage(const ImageFormat* aFormats,
108991:                                               uint32_t aNumFormats,
108747:                                               const gfxIntSize &aScaleHint,
108747:                                               BufferRecycleBin *aRecycleBin);
108747: 
108747: };
108747:  
108747: /**
108747:  * This struct is used to store RemoteImages, it is meant to be able to live in
108747:  * shared memory. Therefor it should not contain a vtable pointer. Remote
108747:  * users can manipulate the data in this structure to specify what image is to
108747:  * be drawn by the container. When accessing this data users should make sure
108747:  * the mutex synchronizing access to the structure is held!
108747:  */
108747: struct RemoteImageData {
108747:   enum Type {
108747:     /**
108747:      * This is a format that uses raw bitmap data.
108747:      */
108747:     RAW_BITMAP,
108747: 
108747:     /**
108747:      * This is a format that uses a pointer to a texture do draw directly
108747:      * from a shared texture. Any process may have created this texture handle,
108747:      * the process creating the texture handle is responsible for managing it's
108747:      * lifetime by managing the lifetime of the first D3D texture object this
108747:      * handle was created for. It must also ensure the handle is not set
108747:      * current anywhere when the last reference to this object is released.
108747:      */
108747:     DXGI_TEXTURE_HANDLE
108747:   };
108747:   /* These formats describe the format in the memory byte-order */
108747:   enum Format {
108747:     /* 8 bits per channel */
108747:     BGRA32,
108747:     /* 8 bits per channel, alpha channel is ignored */
108747:     BGRX32
108747:   };
108747: 
108747:   // This should be set to true if a change was made so that the ImageContainer
108747:   // knows to throw out any cached RemoteImage objects.
108747:   bool mWasUpdated;
108747:   Type mType;
108747:   Format mFormat;
108747:   gfxIntSize mSize;
108747:   union {
108747:     struct {
108747:       /* This pointer is set by a remote process, however it will be set to
108747:        * the container process' address the memory of the raw bitmap resides
108747:        * at.
108747:        */
108747:       unsigned char *mData;
108747:       int mStride;
108747:     } mBitmap;
108747: #ifdef XP_WIN
108747:     HANDLE mTextureHandle;
108747: #endif
108747:   };
108747: };
108747: 
108747: /**
108747:  * A class that manages Images for an ImageLayer. The only reason
108747:  * we need a separate class here is that ImageLayers aren't threadsafe
108747:  * (because layers can only be used on the main thread) and we want to
108747:  * be able to set the current Image from any thread, to facilitate
108747:  * video playback without involving the main thread, for example.
108747:  *
108747:  * An ImageContainer can operate in one of three modes:
108747:  * 1) Normal. Triggered by constructing the ImageContainer with
108747:  * DISABLE_ASYNC or when compositing is happening on the main thread.
108747:  * SetCurrentImage changes ImageContainer state but nothing is sent to the
108747:  * compositor until the next layer transaction.
108747:  * 2) Asynchronous. Initiated by constructing the ImageContainer with
108747:  * ENABLE_ASYNC when compositing is happening on the main thread.
108747:  * SetCurrentImage sends a message through the ImageBridge to the compositor
108747:  * thread to update the image, without going through the main thread or
108747:  * a layer transaction.
108747:  * 3) Remote. Initiated by calling SetRemoteImageData on the ImageContainer
108747:  * before any other activity.
108747:  * The ImageContainer uses a shared memory block containing a cross-process mutex
108747:  * to communicate with the compositor thread. SetCurrentImage synchronously
108747:  * updates the shared state to point to the new image and the old image
108747:  * is immediately released (not true in Normal or Asynchronous modes).
108747:  */
108747: class THEBES_API ImageContainer {
108747:   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ImageContainer)
108747: public:
108747: 
108747:   enum { DISABLE_ASYNC = 0x0, ENABLE_ASYNC = 0x01 };
108747: 
108747:   ImageContainer(int flag = 0);
108747: 
108747:   ~ImageContainer();
108747: 
108747:   /**
108747:    * Create an Image in one of the given formats.
108747:    * Picks the "best" format from the list and creates an Image of that
108747:    * format.
108747:    * Returns null if this backend does not support any of the formats.
108747:    * Can be called on any thread. This method takes mReentrantMonitor
108747:    * when accessing thread-shared state.
108747:    */
108747:   already_AddRefed<Image> CreateImage(const ImageFormat* aFormats,
108991:                                       uint32_t aNumFormats);
108747: 
108747:   /**
108747:    * Set an Image as the current image to display. The Image must have
108747:    * been created by this ImageContainer.
108747:    * Can be called on any thread. This method takes mReentrantMonitor
108747:    * when accessing thread-shared state.
108747:    * aImage can be null. While it's null, nothing will be painted.
108747:    * 
108747:    * The Image data must not be modified after this method is called!
108747:    * Note that this must not be called if ENABLE_ASYNC has not been set.
108747:    *
108747:    * Implementations must call CurrentImageChanged() while holding
108747:    * mReentrantMonitor.
108747:    *
108747:    * If this ImageContainer has an ImageContainerChild for async video: 
108747:    * Schelude a task to send the image to the compositor using the 
108747:    * PImageBridge protcol without using the main thread.
108747:    */
108747:   void SetCurrentImage(Image* aImage);
108747: 
108747:   /**
108747:    * Set an Image as the current image to display. The Image must have
108747:    * been created by this ImageContainer.
108747:    * Must be called on the main thread, within a layers transaction. 
108747:    * 
108747:    * This method takes mReentrantMonitor
108747:    * when accessing thread-shared state.
108747:    * aImage can be null. While it's null, nothing will be painted.
108747:    * 
108747:    * The Image data must not be modified after this method is called!
108747:    * Note that this must not be called if ENABLE_ASYNC been set.
108747:    *
108747:    * Implementations must call CurrentImageChanged() while holding
108747:    * mReentrantMonitor.
108747:    */
108747:   void SetCurrentImageInTransaction(Image* aImage);
108747: 
108747:   /**
108747:    * Returns true if this ImageContainer uses the ImageBridge IPDL protocol.
108747:    *
108747:    * Can be called from any thread.
108747:    */
108747:   bool IsAsync() const;
108747: 
108747:   /**
108747:    * If this ImageContainer uses ImageBridge, returns the ID associated to
108747:    * this container, for use in the ImageBridge protocol.
108747:    * Returns 0 if this ImageContainer does not use ImageBridge. Note that
108747:    * 0 is always an invalid ID for asynchronous image containers. 
108747:    *
108747:    * Can be called from ay thread.
108747:    */
108991:   uint64_t GetAsyncContainerID() const;
108747: 
108747:   /**
108747:    * Returns if the container currently has an image.
108747:    * Can be called on any thread. This method takes mReentrantMonitor
108747:    * when accessing thread-shared state.
108747:    */
108747:   bool HasCurrentImage();
108747: 
108747:   /**
108747:    * Lock the current Image.
108747:    * This has to add a reference since otherwise there are race conditions
108747:    * where the current image is destroyed before the caller can add
108747:    * a reference. This lock strictly guarantees the underlying image remains
108747:    * valid, it does not mean the current image cannot change.
108747:    * Can be called on any thread. This method will lock the cross-process
108747:    * mutex to ensure remote processes cannot alter underlying data. This call
108747:    * -must- be balanced by a call to UnlockCurrentImage and users should avoid
108747:    * holding the image locked for a long time.
108747:    */
108747:   already_AddRefed<Image> LockCurrentImage();
108747: 
108747:   /**
108747:    * This call unlocks the image. For remote images releasing the cross-process
108747:    * mutex.
108747:    */
108747:   void UnlockCurrentImage();
108747: 
108747:   /**
108747:    * Get the current image as a gfxASurface. This is useful for fallback
108747:    * rendering.
108747:    * This can only be called from the main thread, since cairo objects
108747:    * can only be used from the main thread.
108747:    * This is defined here and not on Image because it's possible (likely)
108747:    * that some backends will make an Image "ready to draw" only when it
108747:    * becomes the current image for an image container.
108747:    * Returns null if there is no current image.
108747:    * Returns the size in aSize.
108747:    * The returned surface will never be modified. The caller must not
108747:    * modify it.
108747:    * Can be called on any thread. This method takes mReentrantMonitor
108747:    * when accessing thread-shared state.
108747:    * If the current image is a remote image, that is, if it is an image that
108747:    * may be shared accross processes, calling this function will make
108747:    * a copy of the image data while holding the mRemoteDataMutex. If possible,
108747:    * the lock methods should be used to avoid the copy, however this should be
108747:    * avoided if the surface is required for a long period of time.
108747:    */
108747:   already_AddRefed<gfxASurface> GetCurrentAsSurface(gfxIntSize* aSizeResult);
108747: 
108747:   /**
108747:    * This is similar to GetCurrentAsSurface, however this does not make a copy
108747:    * of the image data and requires the user to call UnlockCurrentImage when
108747:    * done with the image data. Once UnlockCurrentImage has been called the
108747:    * surface returned by this function is no longer valid! This works for any
108747:    * type of image. Optionally a pointer can be passed to receive the current
108747:    * image.
108747:    */
108747:   already_AddRefed<gfxASurface> LockCurrentAsSurface(gfxIntSize* aSizeResult,
108747:                                                      Image** aCurrentImage = nullptr);
108747: 
108747:   /**
108747:    * Returns the size of the image in pixels.
108747:    * Can be called on any thread. This method takes mReentrantMonitor when accessing
108747:    * thread-shared state.
108747:    */
108747:   gfxIntSize GetCurrentSize();
108747: 
108747:   /**
108747:    * Sets a size that the image is expected to be rendered at.
108747:    * This is a hint for image backends to optimize scaling.
108747:    * Default implementation in this class is to ignore the hint.
108747:    * Can be called on any thread. This method takes mReentrantMonitor
108747:    * when accessing thread-shared state.
108747:    */
108747:   void SetScaleHint(const gfxIntSize& aScaleHint)
108747:   { mScaleHint = aScaleHint; }
108747: 
108747:   void SetImageFactory(ImageFactory *aFactory)
108747:   {
108747:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
108747:     mImageFactory = aFactory ? aFactory : new ImageFactory();
108747:   }
108747: 
108747:   /**
108747:    * Returns the time at which the currently contained image was first
108747:    * painted.  This is reset every time a new image is set as the current
108747:    * image.  Note this may return a null timestamp if the current image
108747:    * has not yet been painted.  Can be called from any thread.
108747:    */
108747:   TimeStamp GetPaintTime() {
108747:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
108747:     return mPaintTime;
108747:   }
108747: 
108747:   /**
108747:    * Returns the number of images which have been contained in this container
108747:    * and painted at least once.  Can be called from any thread.
108747:    */
108991:   uint32_t GetPaintCount() {
108747:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
108747:     return mPaintCount;
108747:   }
108747: 
108747:   /**
108747:    * Increments mPaintCount if this is the first time aPainted has been
108747:    * painted, and sets mPaintTime if the painted image is the current image.
108747:    * current image.  Can be called from any thread.
108747:    */
108747:   void NotifyPaintedImage(Image* aPainted) {
108747:     ReentrantMonitorAutoEnter mon(mReentrantMonitor);
108747: 
108747:     nsRefPtr<Image> current = mActiveImage;
108747:     if (aPainted == current) {
108747:       if (mPaintTime.IsNull()) {
108747:         mPaintTime = TimeStamp::Now();
108747:         mPaintCount++;
108747:       }
108747:     } else if (!mPreviousImagePainted) {
108747:       // While we were painting this image, the current image changed. We
108747:       // still must count it as painted, but can't set mPaintTime, since we're
108747:       // no longer the current image.
108747:       mPaintCount++;
108747:       mPreviousImagePainted = true;
108747:     }
108747: 
108747:     if (mCompositionNotifySink) {
108747:       mCompositionNotifySink->DidComposite();
108747:     }
108747:   }
108747: 
108747:   void SetCompositionNotifySink(CompositionNotifySink *aSink) {
108747:     mCompositionNotifySink = aSink;
108747:   }
108747: 
108747:   /**
108747:    * This function is called to tell the ImageContainer where the
108747:    * (cross-process) segment lives where the shared data about possible
108747:    * remote images are stored. In addition to this a CrossProcessMutex object
108747:    * is passed telling the container how to synchronize access to this data.
108747:    * NOTE: This should be called during setup of the container and not after
108747:    * usage has started.
108747:    */
108747:   void SetRemoteImageData(RemoteImageData *aRemoteData,
108747:                           CrossProcessMutex *aRemoteDataMutex);
108747:   /**
108747:    * This can be used to check if the container has RemoteData set.
108747:    */
108747:   RemoteImageData *GetRemoteImageData() { return mRemoteData; }
108747: 
108747: protected:
108747:   typedef mozilla::ReentrantMonitor ReentrantMonitor;
108747: 
108747:   void SetCurrentImageInternal(Image* aImage);
108747: 
108747:   // This is called to ensure we have an active image, this may not be true
108747:   // when we're storing image information in a RemoteImageData structure.
108747:   // NOTE: If we have remote data mRemoteDataMutex should be locked when
108747:   // calling this function!
108747:   void EnsureActiveImage();
108747: 
108747:   // ReentrantMonitor to protect thread safe access to the "current
108747:   // image", and any other state which is shared between threads.
108747:   ReentrantMonitor mReentrantMonitor;
108747: 
108747:   // Performs necessary housekeeping to ensure the painted frame statistics
108747:   // are accurate. Must be called by SetCurrentImage() implementations with
108747:   // mReentrantMonitor held.
108747:   void CurrentImageChanged() {
108747:     mReentrantMonitor.AssertCurrentThreadIn();
108747:     mPreviousImagePainted = !mPaintTime.IsNull();
108747:     mPaintTime = TimeStamp();
108747:   }
108747: 
108747:   nsRefPtr<Image> mActiveImage;
108747: 
108747:   // Number of contained images that have been painted at least once.  It's up
108747:   // to the ImageContainer implementation to ensure accesses to this are
108747:   // threadsafe.
108991:   uint32_t mPaintCount;
108747: 
108747:   // Time stamp at which the current image was first painted.  It's up to the
108747:   // ImageContainer implementation to ensure accesses to this are threadsafe.
108747:   TimeStamp mPaintTime;
108747: 
108747:   // Denotes whether the previous image was painted.
108747:   bool mPreviousImagePainted;
108747: 
108747:   // This is the image factory used by this container, layer managers using
108747:   // this container can set an alternative image factory that will be used to
108747:   // create images for this container.
108747:   nsRefPtr<ImageFactory> mImageFactory;
108747: 
108747:   gfxIntSize mScaleHint;
108747: 
108747:   nsRefPtr<BufferRecycleBin> mRecycleBin;
108747: 
108747:   // This contains the remote image data for this container, if this is NULL
108747:   // that means the container has no other process that may control its active
108747:   // image.
108747:   RemoteImageData *mRemoteData;
108747: 
108747:   // This cross-process mutex is used to synchronise access to mRemoteData.
108747:   // When this mutex is held, we will always be inside the mReentrantMonitor
108747:   // however the same is not true vice versa.
108747:   CrossProcessMutex *mRemoteDataMutex;
108747: 
108747:   CompositionNotifySink *mCompositionNotifySink;
108747: 
108747:   // This member points to an ImageContainerChild if this ImageContainer was 
108747:   // sucessfully created with ENABLE_ASYNC, or points to null otherwise.
108747:   // 'unsuccessful' in this case only means that the ImageContainerChild could not
108747:   // be created, most likely because off-main-thread compositing is not enabled.
108747:   // In this case the ImageContainer is perfectly usable, but it will forward 
108747:   // frames to the compositor through transactions in the main thread rather than 
108747:   // asynchronusly using the ImageBridge IPDL protocol.
108747:   nsRefPtr<ImageContainerChild> mImageContainerChild;
108747: };
108747: 
108747: class AutoLockImage
108747: {
108747: public:
108747:   AutoLockImage(ImageContainer *aContainer) : mContainer(aContainer) { mImage = mContainer->LockCurrentImage(); }
108747:   AutoLockImage(ImageContainer *aContainer, gfxASurface **aSurface) : mContainer(aContainer) {
108747:     *aSurface = mContainer->LockCurrentAsSurface(&mSize, getter_AddRefs(mImage)).get();
108747:   }
108747:   ~AutoLockImage() { if (mContainer) { mContainer->UnlockCurrentImage(); } }
108747: 
108747:   Image* GetImage() { return mImage; }
108747:   const gfxIntSize &GetSize() { return mSize; }
108747: 
108747:   void Unlock() { 
108747:     if (mContainer) {
108747:       mImage = nullptr;
108747:       mContainer->UnlockCurrentImage();
108747:       mContainer = nullptr;
108747:     }
108747:   }
108747: 
108747:   /** Things get a little tricky here, because our underlying image can -still-
108747:    * change, and OS X requires a complicated callback mechanism to update this
108747:    * we need to support staying the lock and getting the new image in a proper
108747:    * way. This method makes any images retrieved with GetImage invalid!
108747:    */
108747:   void Refresh() {
108747:     if (mContainer) {
108747:       mContainer->UnlockCurrentImage();
108747:       mImage = mContainer->LockCurrentImage();
108747:     }
108747:   }
108747: 
108747: private:
108747:   ImageContainer *mContainer;
108747:   nsRefPtr<Image> mImage;
108747:   gfxIntSize mSize;
108747: };
108747: 
108747: /****** Image subtypes for the different formats ******/
108747: 
108747: /**
108747:  * We assume that the image data is in the REC 470M color space (see
108747:  * Theora specification, section 4.3.1).
108747:  *
108747:  * The YCbCr format can be:
108747:  *
108747:  * 4:4:4 - CbCr width/height are the same as Y.
108747:  * 4:2:2 - CbCr width is half that of Y. Height is the same.
108747:  * 4:2:0 - CbCr width and height is half that of Y.
108747:  *
108747:  * The color format is detected based on the height/width ratios
108747:  * defined above.
108747:  * 
108747:  * The Image that is rendered is the picture region defined by
108747:  * mPicX, mPicY and mPicSize. The size of the rendered image is
108747:  * mPicSize, not mYSize or mCbCrSize.
108919:  *
109467:  * mYSkip, mCbSkip, mCrSkip are added to support various output
109467:  * formats from hardware decoder. They are per-pixel skips in the
108919:  * source image.
109467:  *
109467:  * For example when image width is 640, mYStride is 670, mYSkip is 3,
109467:  * the mYChannel buffer looks like:
109467:  *
109467:  * |<----------------------- mYStride ----------------------------->|
109467:  * |<----------------- mYSize.width --------------->|
109467:  *  0   3   6   9   12  15  18  21                659             669
109467:  * |----------------------------------------------------------------|
109467:  * |Y___Y___Y___Y___Y___Y___Y___Y...                      |%%%%%%%%%|
109467:  * |Y___Y___Y___Y___Y___Y___Y___Y...                      |%%%%%%%%%|
109467:  * |Y___Y___Y___Y___Y___Y___Y___Y...                      |%%%%%%%%%|
109467:  * |            |<->|
109467:  *                mYSkip
108747:  */
108747: class THEBES_API PlanarYCbCrImage : public Image {
108747: public:
108747:   struct Data {
108747:     // Luminance buffer
108991:     uint8_t* mYChannel;
108991:     int32_t mYStride;
108747:     gfxIntSize mYSize;
108991:     int32_t mYSkip;
108747:     // Chroma buffers
108991:     uint8_t* mCbChannel;
108991:     uint8_t* mCrChannel;
108991:     int32_t mCbCrStride;
108747:     gfxIntSize mCbCrSize;
108991:     int32_t mCbSkip;
108991:     int32_t mCrSkip;
108747:     // Picture region
108991:     uint32_t mPicX;
108991:     uint32_t mPicY;
108747:     gfxIntSize mPicSize;
108747:     StereoMode mStereoMode;
108747: 
108747:     nsIntRect GetPictureRect() const {
108747:       return nsIntRect(mPicX, mPicY,
108747:                        mPicSize.width,
108747:                        mPicSize.height);
108747:     }
109506: 
109506:     Data()
109506:       : mYChannel(nullptr), mYStride(0), mYSize(0, 0), mYSkip(0)
109506:       , mCbChannel(nullptr), mCrChannel(nullptr)
109506:       , mCbCrStride(0), mCbCrSize(0, 0) , mCbSkip(0), mCrSkip(0)
109506:       , mPicX(0), mPicY(0), mPicSize(0, 0), mStereoMode(STEREO_MODE_MONO)
109506:     {}
108747:   };
108747: 
108747:   enum {
108747:     MAX_DIMENSION = 16384
108747:   };
108747: 
108920:   virtual ~PlanarYCbCrImage();
108747: 
108747:   /**
109183:    * This makes a copy of the data buffers, in order to support functioning
109183:    * in all different layer managers.
108747:    */
108747:   virtual void SetData(const Data& aData);
108747: 
108747:   /**
108747:    * Ask this Image to not convert YUV to RGB during SetData, and make
108747:    * the original data available through GetData. This is optional,
108747:    * and not all PlanarYCbCrImages will support it.
108747:    */
108747:   virtual void SetDelayedConversion(bool aDelayed) { }
108747: 
108747:   /**
108747:    * Grab the original YUV data. This is optional.
108747:    */
108747:   virtual const Data* GetData() { return &mData; }
108747: 
108747:   /**
108919:    * Return the number of bytes of heap memory used to store this image.
108919:    */
108991:   virtual uint32_t GetDataSize() { return mBufferSize; }
108919: 
108919:   virtual bool IsValid() { return !!mBufferSize; }
108919: 
108919:   virtual gfxIntSize GetSize() { return mSize; }
108919: 
108919:   PlanarYCbCrImage(BufferRecycleBin *aRecycleBin);
108919: 
108919: protected:
108919:   /**
108747:    * Make a copy of the YCbCr data into local storage.
108747:    *
108747:    * @param aData           Input image data.
108747:    */
108919:   void CopyData(const Data& aData);
108747: 
108747:   /**
108747:    * Return a buffer to store image data in.
108747:    * The default implementation returns memory that can
108747:    * be freed wit delete[]
108747:    */
108991:   virtual uint8_t* AllocateBuffer(uint32_t aSize);
108747: 
108747:   already_AddRefed<gfxASurface> GetAsSurface();
108747: 
108747:   void SetOffscreenFormat(gfxASurface::gfxImageFormat aFormat) { mOffscreenFormat = aFormat; }
108747:   gfxASurface::gfxImageFormat GetOffscreenFormat() { return mOffscreenFormat; }
108747: 
108991:   nsAutoArrayPtr<uint8_t> mBuffer;
108991:   uint32_t mBufferSize;
108747:   Data mData;
108747:   gfxIntSize mSize;
108747:   gfxASurface::gfxImageFormat mOffscreenFormat;
108747:   nsCountedRef<nsMainThreadSurfaceRef> mSurface;
108747:   nsRefPtr<BufferRecycleBin> mRecycleBin;
108747: };
108747: 
108747: /**
108747:  * Currently, the data in a CairoImage surface is treated as being in the
108747:  * device output color space. This class is very simple as all backends
108747:  * have to know about how to deal with drawing a cairo image.
108747:  */
108747: class THEBES_API CairoImage : public Image {
108747: public:
108747:   struct Data {
108747:     gfxASurface* mSurface;
108747:     gfxIntSize mSize;
108747:   };
108747: 
108747:   /**
108747:    * This can only be called on the main thread. It may add a reference
108747:    * to the surface (which will eventually be released on the main thread).
108747:    * The surface must not be modified after this call!!!
108747:    */
108747:   void SetData(const Data& aData)
108747:   {
108747:     mSurface = aData.mSurface;
108747:     mSize = aData.mSize;
108747:   }
108747: 
108747: 
108747:   virtual already_AddRefed<gfxASurface> GetAsSurface()
108747:   {
108747:     NS_ASSERTION(NS_IsMainThread(), "Must be main thread");
108747:     nsRefPtr<gfxASurface> surface = mSurface.get();
108747:     return surface.forget();
108747:   }
108747: 
108747:   gfxIntSize GetSize() { return mSize; }
108747: 
108747:   CairoImage() : Image(NULL, CAIRO_SURFACE) {}
108747: 
108747:   nsCountedRef<nsMainThreadSurfaceRef> mSurface;
108747:   gfxIntSize mSize;
108747: };
108747: 
108747: #ifdef XP_MACOSX
108747: class THEBES_API MacIOSurfaceImage : public Image {
108747: public:
108747:   struct Data {
108747:     MacIOSurface* mIOSurface;
108747:   };
108747: 
108747:   MacIOSurfaceImage()
108747:     : Image(NULL, MAC_IO_SURFACE)
108747:     , mSize(0, 0)
108747:     , mPluginInstanceOwner(NULL)
108747:     , mUpdateCallback(NULL)
108747:     , mDestroyCallback(NULL)
108747:     {}
108747: 
108747:   virtual ~MacIOSurfaceImage()
108747:   {
108747:     if (mDestroyCallback) {
108747:       mDestroyCallback(mPluginInstanceOwner);
108747:     }
108747:   }
108747: 
108747:  /**
108747:   * This can only be called on the main thread. It may add a reference
108747:   * to the surface (which will eventually be released on the main thread).
108747:   * The surface must not be modified after this call!!!
108747:   */
108747:   virtual void SetData(const Data& aData);
108747: 
108747:   /**
108747:    * Temporary hacks to force plugin drawing during an empty transaction.
108747:    * This should not be used for anything else, and will be removed
108747:    * when async plugin rendering is complete.
108747:    */
108747:   typedef void (*UpdateSurfaceCallback)(ImageContainer* aContainer, void* aInstanceOwner);
108747:   virtual void SetUpdateCallback(UpdateSurfaceCallback aCallback, void* aInstanceOwner)
108747:   {
108747:     mUpdateCallback = aCallback;
108747:     mPluginInstanceOwner = aInstanceOwner;
108747:   }
108747: 
108747:   typedef void (*DestroyCallback)(void* aInstanceOwner);
108747:   virtual void SetDestroyCallback(DestroyCallback aCallback)
108747:   {
108747:     mDestroyCallback = aCallback;
108747:   }
108747: 
108747:   virtual gfxIntSize GetSize()
108747:   {
108747:     return mSize;
108747:   }
108747: 
108747:   MacIOSurface* GetIOSurface()
108747:   {
108747:     return mIOSurface;
108747:   }
108747: 
108747:   void Update(ImageContainer* aContainer);
108747: 
108747:   virtual already_AddRefed<gfxASurface> GetAsSurface();
108747: 
108747: private:
108747:   gfxIntSize mSize;
108747:   RefPtr<MacIOSurface> mIOSurface;
108747:   void* mPluginInstanceOwner;
108747:   UpdateSurfaceCallback mUpdateCallback;
108747:   DestroyCallback mDestroyCallback;
108747: };
108747: #endif
108747: 
108747: class RemoteBitmapImage : public Image {
108747: public:
108747:   RemoteBitmapImage() : Image(NULL, REMOTE_IMAGE_BITMAP) {}
108747: 
108747:   already_AddRefed<gfxASurface> GetAsSurface();
108747: 
108747:   gfxIntSize GetSize() { return mSize; }
108747: 
108747:   unsigned char *mData;
108747:   int mStride;
108747:   gfxIntSize mSize;
108747:   RemoteImageData::Format mFormat;
108747: };
108747: 
108747: 
108747: } //namespace
108747: } //namespace
108747: 
108919: #endif
