    1: # -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1: # ***** BEGIN LICENSE BLOCK *****
    1: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1: #
    1: # The contents of this file are subject to the Mozilla Public License Version
    1: # 1.1 (the "License"); you may not use this file except in compliance with
    1: # the License. You may obtain a copy of the License at
    1: # http://www.mozilla.org/MPL/
    1: #
    1: # Software distributed under the License is distributed on an "AS IS" basis,
    1: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1: # for the specific language governing rights and limitations under the
    1: # License.
    1: #
    1: # The Original Code is View Source Utilities.
    1: #
    1: # The Initial Developer of the Original Code is
    1: # Jason Barnabe.
    1: # Portions created by the Initial Developer are Copyright (C) 2005
    1: # the Initial Developer. All Rights Reserved.
    1: #
    1: # Contributor(s):
18967: #   Simon BÃ¼nzli <zeniko@gmail.com>
    1: #
    1: # Alternatively, the contents of this file may be used under the terms of
    1: # either the GNU General Public License Version 2 or later (the "GPL"), or
    1: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1: # in which case the provisions of the GPL or the LGPL are applicable instead
    1: # of those above. If you wish to allow use of your version of this file only
    1: # under the terms of either the GPL or the LGPL, and not to allow others to
    1: # use your version of this file under the terms of the MPL, indicate your
    1: # decision by deleting the provisions above and replace them with the notice
    1: # and other provisions required by the GPL or the LGPL. If you do not delete
    1: # the provisions above, a recipient may use your version of this file under
    1: # the terms of any one of the MPL, the GPL or the LGPL.
    1: #
    1: # ***** END LICENSE BLOCK *****
    1: 
    1: /*
    1:  * To keep the global namespace safe, don't define global variables and 
    1:  * functions in this file.
    1:  *
18967:  * This file silently depends on contentAreaUtils.js for
18967:  * getDefaultFileName, getNormalizedLeafName and getDefaultExtension
    1:  */
    1: 
    1: var gViewSourceUtils = {
    1: 
    1:   mnsIWebBrowserPersist: Components.interfaces.nsIWebBrowserPersist,
    1:   mnsIWebProgress: Components.interfaces.nsIWebProgress,
    1:   mnsIWebPageDescriptor: Components.interfaces.nsIWebPageDescriptor,
    1: 
18967:   // Opens view source
18967:   viewSource: function(aURL, aPageDescriptor, aDocument, aLineNumber)
18967:   {
18967:     var prefs = Components.classes["@mozilla.org/preferences-service;1"]
18967:                           .getService(Components.interfaces.nsIPrefBranch);
18967:     if (prefs.getBoolPref("view_source.editor.external"))
18967:       this.openInExternalEditor(aURL, aPageDescriptor, aDocument, aLineNumber);
18967:     else
18967:       this.openInInternalViewer(aURL, aPageDescriptor, aDocument, aLineNumber);
18967:   },
18967: 
    1:   // Opens the interval view source viewer
18967:   openInInternalViewer: function(aURL, aPageDescriptor, aDocument, aLineNumber)
    1:   {
    1:     // try to open a view-source window while inheriting the charset (if any)
    1:     var charset = null;
 4528:     var isForcedCharset = false;
 4528:     if (aDocument) {
    1:       charset = "charset=" + aDocument.characterSet;
 4528:       try { 
 4528:         isForcedCharset =
 4528:           aDocument.defaultView
 4528:                    .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
 4528:                    .getInterface(Components.interfaces.nsIDOMWindowUtils)
 4528:                    .docCharsetIsForced;
 4528:       } catch (ex) {
 4528:       }
 4528:     }
    1:     openDialog("chrome://global/content/viewSource.xul",
    1:                "_blank",
    1:                "all,dialog=no",
18967:                aURL, charset, aPageDescriptor, aLineNumber, isForcedCharset);
    1:   },
    1: 
    1:   // aCallBack is a function accepting two arguments - result (true=success) and a data object
    1:   // It defaults to openInInternalViewer if undefined.
18967:   openInExternalEditor: function(aURL, aPageDescriptor, aDocument, aLineNumber, aCallBack)
    1:   {
18967:     var data = {url: aURL, pageDescriptor: aPageDescriptor, doc: aDocument,
18967:                 lineNumber: aLineNumber};
    1: 
    1:     try {
    1:       var editor = this.getExternalViewSourceEditor();    
    1:       if (!editor) {
    1:         this.handleCallBack(aCallBack, false, data);
    1:         return;
    1:       }
    1: 
    1:       // make a uri
    1:       var ios = Components.classes["@mozilla.org/network/io-service;1"]
    1:                           .getService(Components.interfaces.nsIIOService);
    1:       var charset = aDocument ? aDocument.characterSet : null;
    1:       var uri = ios.newURI(aURL, charset, null);
    1:       data.uri = uri;
    1: 
    1:       var path;
    1:       var contentType = aDocument ? aDocument.contentType : null;
    1:       if (uri.scheme == "file") {    
    1:         // it's a local file; we can open it directly
    1:         path = uri.QueryInterface(Components.interfaces.nsIFileURL).file.path;
    1:         editor.run(false, [path], 1);
    1:         this.handleCallBack(aCallBack, true, data);
    1:       } else {
    1:         // set up the progress listener with what we know so far
    1:         this.viewSourceProgressListener.editor = editor;
    1:         this.viewSourceProgressListener.callBack = aCallBack;
    1:         this.viewSourceProgressListener.data = data;      
    1:         if (!aPageDescriptor) {
    1:           // without a page descriptor, loadPage has no chance of working. download the file.
    1:           var file = this.getTemporaryFile(uri, aDocument, contentType);
    1:           this.viewSourceProgressListener.file = file;
    1: 
    1:           var webBrowserPersist = Components
    1:                                   .classes["@mozilla.org/embedding/browser/nsWebBrowserPersist;1"]
    1:                                   .createInstance(this.mnsIWebBrowserPersist);
    1:           // the default setting is to not decode. we need to decode.
    1:           webBrowserPersist.persistFlags = this.mnsIWebBrowserPersist.PERSIST_FLAGS_REPLACE_EXISTING_FILES;
    1:           webBrowserPersist.progressListener = this.viewSourceProgressListener;
    1:           webBrowserPersist.saveURI(uri, null, null, null, null, file);
19514: 
19514:           // register the file to be deleted on app exit
19514:           Components.classes["@mozilla.org/uriloader/external-helper-app-service;1"]
19514:                     .getService(Components.interfaces.nsPIExternalAppLauncher)
19514:                     .deleteTemporaryFileOnExit(file);
    1:         } else {
28078:           // we'll use nsIWebPageDescriptor to get the source because it may
28078:           // not have to refetch the file from the server
28078:           // XXXbz this is so broken...  This code doesn't set up this docshell
28078:           // at all correctly; if somehow the view-source stuff managed to
28078:           // execute script we'd be in big trouble here, I suspect.
28078:           var webShell = Components.classes["@mozilla.org/docshell;1"].createInstance();
33394:           webShell.QueryInterface(Components.interfaces.nsIBaseWindow).create();
    1:           this.viewSourceProgressListener.webShell = webShell;
    1:           var progress = webShell.QueryInterface(this.mnsIWebProgress);
    1:           progress.addProgressListener(this.viewSourceProgressListener,
    1:                                        this.mnsIWebProgress.NOTIFY_STATE_DOCUMENT);
    1:           var pageLoader = webShell.QueryInterface(this.mnsIWebPageDescriptor);    
    1:           pageLoader.loadPage(aPageDescriptor, this.mnsIWebPageDescriptor.DISPLAY_AS_SOURCE);
    1:         }
    1:       }
    1:     } catch (ex) {
    1:       // we failed loading it with the external editor.
    1:       Components.utils.reportError(ex);
    1:       this.handleCallBack(aCallBack, false, data);
    1:       return;
    1:     }
    1:   },
    1: 
    1:   // Default callback - opens the internal viewer if the external editor failed
    1:   internalViewerFallback: function(result, data)
    1:   {
    1:     if (!result) {
18967:       this.openInInternalViewer(data.url, data.pageDescriptor, data.doc, data.lineNumber);
    1:     }
    1:   },
    1: 
    1:   // Calls the callback, keeping in mind undefined or null values.
    1:   handleCallBack: function(aCallBack, result, data)
    1:   {
    1:     // ifcallback is undefined, default to the internal viewer
    1:     if (aCallBack === undefined) {
    1:       this.internalViewerFallback(result, data);
    1:     } else if (aCallBack) {
    1:       aCallBack(result, data);
    1:     }
    1:   },
    1: 
    1:   // Returns nsIProcess of the external view source editor or null
    1:   getExternalViewSourceEditor: function()
    1:   {
    1:     try {
19250:       let prefPath =
19250:           Components.classes["@mozilla.org/preferences-service;1"]
19250:                     .getService(Components.interfaces.nsIPrefBranch)
19250:                     .getCharPref("view_source.editor.path");
19250:       let viewSourceAppPath =
19250:               Components.classes["@mozilla.org/file/local;1"]
    1:                         .createInstance(Components.interfaces.nsILocalFile);
    1:       viewSourceAppPath.initWithPath(prefPath);
19250:       let editor = Components.classes['@mozilla.org/process/util;1']
    1:                              .createInstance(Components.interfaces.nsIProcess);
    1:       editor.init(viewSourceAppPath);
19250: 
19250:       return editor;
    1:     }
    1:     catch (ex) {
    1:       Components.utils.reportError(ex);
    1:     }
19250: 
19250:     return null;
    1:   },
    1: 
    1:   viewSourceProgressListener: {
    1: 
    1:     mnsIWebProgressListener: Components.interfaces.nsIWebProgressListener,
    1: 
    1:     QueryInterface: function(aIID) {
    1:      if (aIID.equals(this.mnsIWebProgressListener) ||
    1:          aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
    1:          aIID.equals(Components.interfaces.nsISupports))
    1:        return this;
    1:      throw Components.results.NS_NOINTERFACE;
    1:     },
    1: 
    1:     destroy: function() {
33394:       this.webShell.QueryInterface(Components.interfaces.nsIBaseWindow).destroy();
    1:       this.webShell = null;
    1:       this.editor = null;
    1:       this.callBack = null;
    1:       this.data = null;
    1:       this.file = null;
    1:     },
    1: 
    1:     onStateChange: function(aProgress, aRequest, aFlag, aStatus) {
    1:       // once it's done loading...
    1:       if ((aFlag & this.mnsIWebProgressListener.STATE_STOP) && aStatus == 0) {
    1:         try {
    1:           if (!this.file) {
    1:             // it's not saved to file yet, it's in the webshell
    1: 
    1:             // get a temporary filename using the attributes from the data object that
    1:             // openInExternalEditor gave us
    1:             this.file = gViewSourceUtils.getTemporaryFile(this.data.uri, this.data.doc, 
    1:                                                           this.data.doc.contentType);
    1: 
    1:             // we have to convert from the source charset.
    1:             var webNavigation = this.webShell.QueryInterface(Components.interfaces.nsIWebNavigation);
    1:             var foStream = Components.classes["@mozilla.org/network/file-output-stream;1"]
    1:                                      .createInstance(Components.interfaces.nsIFileOutputStream);
    1:             foStream.init(this.file, 0x02 | 0x08 | 0x20, 0664, 0); // write | create | truncate
    1:             var coStream = Components.classes["@mozilla.org/intl/converter-output-stream;1"]
    1:                                      .createInstance(Components.interfaces.nsIConverterOutputStream);
    1:             coStream.init(foStream, this.data.doc.characterSet, 0, null);
    1: 
    1:             // write the source to the file
    1:             coStream.writeString(webNavigation.document.body.textContent);
    1:           
    1:             // clean up
    1:             coStream.close();
    1:             foStream.close();
19514: 
19514:             // register the file to be deleted on app exit
19514:             Components.classes["@mozilla.org/uriloader/external-helper-app-service;1"]
19514:                       .getService(Components.interfaces.nsPIExternalAppLauncher)
19514:                       .deleteTemporaryFileOnExit(this.file);
    1:           }
18967: 
18967:           // Determine the command line arguments to pass to the editor.
18967:           // We currently support a %LINE% placeholder which is set to the passed
18967:           // line number (or to 0 if there's none)
18968:           var editorArgs = [];
18967:           var prefs = Components.classes["@mozilla.org/preferences-service;1"]
18967:                                 .getService(Components.interfaces.nsIPrefBranch);
18967:           var args = prefs.getCharPref("view_source.editor.args");
18967:           if (args) {
18967:             args = args.replace("%LINE%", this.data.lineNumber || "0");
18967:             // add the arguments to the array (keeping quoted strings intact)
18967:             const argumentRE = /"([^"]+)"|(\S+)/g;
18967:             while (argumentRE.test(args))
18967:               editorArgs.push(RegExp.$1 || RegExp.$2);
18967:           }
18967:           editorArgs.push(this.file.path);
18967:           this.editor.run(false, editorArgs, editorArgs.length);
    1: 
    1:           gViewSourceUtils.handleCallBack(this.callBack, true, this.data);
    1:         } catch (ex) {
    1:           // we failed loading it with the external editor.
    1:           Components.utils.reportError(ex);
    1:           gViewSourceUtils.handleCallBack(this.callBack, false, this.data);
    1:         } finally {
    1:           this.destroy();
    1:         }
    1:       }
    1:       return 0;
    1:     },
    1: 
    1:     onLocationChange: function() {return 0;},
    1:     onProgressChange: function() {return 0;},
    1:     onStatusChange: function() {return 0;},
    1:     onSecurityChange: function() {return 0;},
    1:     onLinkIconAvailable: function() {return 0;},
    1: 
    1:     webShell: null,
    1:     editor: null,
    1:     callBack: null,
    1:     data: null,
    1:     file: null
    1:   },
    1: 
    1:   // returns an nsIFile for the passed document in the system temp directory
    1:   getTemporaryFile: function(aURI, aDocument, aContentType) {
18967:     // include contentAreaUtils.js in our own context when we first need it
18967:     if (!this._caUtils) {
18967:       var scriptLoader = Components.classes["@mozilla.org/moz/jssubscript-loader;1"]
18967:                                    .getService(Components.interfaces.mozIJSSubScriptLoader);
18967:       this._caUtils = {};
18967:       scriptLoader.loadSubScript("chrome://global/content/contentAreaUtils.js", this._caUtils);
18967:     }
18967: 
    1:     var fileLocator = Components.classes["@mozilla.org/file/directory_service;1"]
    1:                                 .getService(Components.interfaces.nsIProperties);
    1:     var tempFile = fileLocator.get("TmpD", Components.interfaces.nsIFile);
18967:     var fileName = this._caUtils.getDefaultFileName(null, aURI, aDocument, aContentType);
18967:     var extension = this._caUtils.getDefaultExtension(fileName, aURI, aContentType);
18967:     var leafName = this._caUtils.getNormalizedLeafName(fileName, extension);
    1:     tempFile.append(leafName);
    1:     return tempFile;
    1:   }
    1: }
