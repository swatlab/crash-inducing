    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Chris Waterson <waterson@netscape.com>
    1:  *   Ben Goodger <ben@netscape.com>
    1:  *   Jan Varga <varga@ku.sk>
    1:  *   Neil Deakin <enndeakin@sympatico.ca>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nscore.h"
    1: #include "nsIContent.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsILocalStore.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsITreeBoxObject.h"
    1: #include "nsITreeSelection.h"
    1: #include "nsITreeColumns.h"
    1: #include "nsITreeView.h"
    1: #include "nsTreeUtils.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsQuickSort.h"
    1: #include "nsTreeRows.h"
    1: #include "nsTemplateRule.h"
    1: #include "nsTemplateMatch.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsXULContentUtils.h"
    1: #include "nsXULTemplateBuilder.h"
26413: #include "nsTArray.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIDOMClassInfo.h"
    1: 
    1: // For security check
    1: #include "nsIDocument.h"
    1: 
    1: /**
    1:  * A XUL template builder that serves as an tree view, allowing
    1:  * (pretty much) arbitrary RDF to be presented in an tree.
    1:  */
    1: class nsXULTreeBuilder : public nsXULTemplateBuilder,
    1:                          public nsIXULTreeBuilder,
    1:                          public nsINativeTreeView
    1: {
    1: public:
    1:     // nsISupports
    1:     NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:     // nsIXULTreeBuilder
    1:     NS_DECL_NSIXULTREEBUILDER
    1: 
    1:     // nsITreeView
    1:     NS_DECL_NSITREEVIEW
    1:     // nsINativeTreeView: Untrusted code can use us
    1:     NS_IMETHOD EnsureNative() { return NS_OK; }
    1: 
    1:     virtual void NodeWillBeDestroyed(const nsINode* aNode);
    1: 
    1: protected:
    1:     friend NS_IMETHODIMP
    1:     NS_NewXULTreeBuilder(nsISupports* aOuter, REFNSIID aIID, void** aResult);
    1: 
    1:     nsXULTreeBuilder();
    1: 
    1:     /**
    1:      * Uninitialize the template builder
    1:      */
    1:     virtual void Uninit(PRBool aIsFinal);
    1: 
    1:     /**
    1:      * Get sort variables from the active <treecol>
    1:      */
    1:     nsresult
    1:     EnsureSortVariables();
    1: 
    1:     virtual nsresult
    1:     RebuildAll();
    1: 
    1:     /**
    1:      * Given a row, use the row's match to figure out the appropriate
    1:      * <treerow> in the rule's <action>.
    1:      */
    1:     nsresult
    1:     GetTemplateActionRowFor(PRInt32 aRow, nsIContent** aResult);
    1: 
    1:     /**
    1:      * Given a row and a column ID, use the row's match to figure out
    1:      * the appropriate <treecell> in the rule's <action>.
    1:      */
    1:     nsresult
    1:     GetTemplateActionCellFor(PRInt32 aRow, nsITreeColumn* aCol, nsIContent** aResult);
    1: 
    1:     /**
    1:      * Return the resource corresponding to a row in the tree.
    1:      */
    1:     nsresult
    1:     GetResourceFor(PRInt32 aRow, nsIRDFResource** aResource);
    1: 
    1:     /**
    1:      * Open a container row, inserting the container's children into
    1:      * the view.
    1:      */
    1:     nsresult
    1:     OpenContainer(PRInt32 aIndex, nsIXULTemplateResult* aResult);
    1: 
    1:     /**
    1:      * Helper for OpenContainer, recursively open subtrees, remembering
    1:      * persisted ``open'' state
    1:      */
    1:     nsresult
    1:     OpenSubtreeOf(nsTreeRows::Subtree* aSubtree,
    1:                   PRInt32 aIndex,
    1:                   nsIXULTemplateResult *aResult,
    1:                   PRInt32* aDelta);
    1: 
    1:     nsresult
    1:     OpenSubtreeForQuerySet(nsTreeRows::Subtree* aSubtree,
    1:                            PRInt32 aIndex,
    1:                            nsIXULTemplateResult *aResult,
    1:                            nsTemplateQuerySet* aQuerySet,
    1:                            PRInt32* aDelta,
26413:                            nsTArray<PRInt32>& open);
    1: 
    1:     /**
    1:      * Close a container row, removing the container's childrem from
    1:      * the view.
    1:      */
    1:     nsresult
    1:     CloseContainer(PRInt32 aIndex);
    1: 
    1:     /**
    1:      * Remove the matches for the rows in a subtree
    1:      */
    1:     nsresult
    1:     RemoveMatchesFor(nsTreeRows::Subtree& subtree);
    1: 
    1:     /**
    1:      * Helper methods that determine if the specified container is open.
    1:      */
    1:     nsresult
    1:     IsContainerOpen(nsIXULTemplateResult *aResult, PRBool* aOpen);
    1: 
    1:     nsresult
    1:     IsContainerOpen(nsIRDFResource* aResource, PRBool* aOpen);
    1: 
    1:     /**
    1:      * A sorting callback for NS_QuickSort().
    1:      */
20261:     static int
    1:     Compare(const void* aLeft, const void* aRight, void* aClosure);
    1: 
    1:     /**
    1:      * The real sort routine
    1:      */
    1:     PRInt32
    1:     CompareResults(nsIXULTemplateResult* aLeft, nsIXULTemplateResult* aRight);
    1: 
    1:     /**
    1:      * Sort the specified subtree, and recursively sort any subtrees
    1:      * beneath it.
    1:      */
    1:     nsresult
    1:     SortSubtree(nsTreeRows::Subtree* aSubtree);
    1: 
    1:     NS_IMETHOD
    1:     HasGeneratedContent(nsIRDFResource* aResource,
    1:                         nsIAtom* aTag,
    1:                         PRBool* aGenerated);
    1: 
    1:     // GetInsertionLocations, ReplaceMatch and SynchronizeResult are inherited
    1:     // from nsXULTemplateBuilder
    1: 
    1:     /**
    1:      * Return true if the result can be inserted into the template as a new
    1:      * row.
    1:      */
    1:     PRBool
    1:     GetInsertionLocations(nsIXULTemplateResult* aResult,
    1:                           nsCOMArray<nsIContent>** aLocations);
    1: 
    1:     /**
    1:      * Implement result replacement
    1:      */
    1:     virtual nsresult
    1:     ReplaceMatch(nsIXULTemplateResult* aOldResult,
    1:                  nsTemplateMatch* aNewMatch,
    1:                  nsTemplateRule* aNewMatchRule,
    1:                  void *aContext);
    1: 
    1:     /**
    1:      * Implement match synchronization
    1:      */
    1:     virtual nsresult
    1:     SynchronizeResult(nsIXULTemplateResult* aResult);
    1: 
    1:     /**
    1:      * The tree's box object, used to communicate with the front-end.
    1:      */
    1:     nsCOMPtr<nsITreeBoxObject> mBoxObject;
    1: 
    1:     /**
    1:      * The tree's selection object.
    1:      */
    1:     nsCOMPtr<nsITreeSelection> mSelection;
    1: 
    1:     /**
    1:      * The datasource that's used to persist open folder information
    1:      */
    1:     nsCOMPtr<nsIRDFDataSource> mPersistStateStore;
    1: 
    1:     /**
    1:      * The rows in the view
    1:      */
    1:     nsTreeRows mRows;
    1: 
    1:     /**
    1:      * The currently active sort variable
    1:      */
    1:     nsCOMPtr<nsIAtom> mSortVariable;
    1: 
    1:     enum Direction {
    1:         eDirection_Descending = -1,
    1:         eDirection_Natural    =  0,
    1:         eDirection_Ascending  = +1
    1:     };
    1: 
    1:     /**
    1:      * The currently active sort order
    1:      */
    1:     Direction mSortDirection;
    1: 
    1:     /** 
    1:      * The builder observers.
    1:      */
    1:     nsCOMPtr<nsISupportsArray> mObservers;
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: NS_NewXULTreeBuilder(nsISupports* aOuter, REFNSIID aIID, void** aResult)
    1: {
    1:     *aResult = nsnull;
    1: 
    1:     NS_PRECONDITION(aOuter == nsnull, "no aggregation");
    1:     if (aOuter)
    1:         return NS_ERROR_NO_AGGREGATION;
    1: 
    1:     nsresult rv;
    1:     nsXULTreeBuilder* result = new nsXULTreeBuilder();
    1:     if (! result)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ADDREF(result); // stabilize
    1: 
    1:     rv = result->InitGlobals();
    1: 
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = result->QueryInterface(aIID, aResult);
    1: 
    1:     NS_RELEASE(result);
    1:     return rv;
    1: }
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsXULTreeBuilder, nsXULTemplateBuilder)
    1: NS_IMPL_RELEASE_INHERITED(nsXULTreeBuilder, nsXULTemplateBuilder)
    1: 
40490: DOMCI_DATA(XULTreeBuilder, nsXULTreeBuilder)
40490: 
    1: NS_INTERFACE_MAP_BEGIN(nsXULTreeBuilder)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXULTreeBuilder)
    1:   NS_INTERFACE_MAP_ENTRY(nsITreeView)
25059:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XULTreeBuilder)
    1: NS_INTERFACE_MAP_END_INHERITING(nsXULTemplateBuilder)
    1: 
    1: 
    1: nsXULTreeBuilder::nsXULTreeBuilder()
    1:     : mSortDirection(eDirection_Natural)
    1: {
    1: }
    1: 
    1: void
    1: nsXULTreeBuilder::Uninit(PRBool aIsFinal)
    1: {
    1:     PRInt32 count = mRows.Count();
    1:     mRows.Clear();
    1: 
    1:     if (mBoxObject) {
    1:         mBoxObject->BeginUpdateBatch();
    1:         mBoxObject->RowCountChanged(0, -count);
28717:         if (mBoxObject) {
28717:             mBoxObject->EndUpdateBatch();
28717:         }
    1:     }
    1: 
    1:     nsXULTemplateBuilder::Uninit(aIsFinal);
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIXULTreeBuilder methods
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetResourceAtIndex(PRInt32 aRowIndex, nsIRDFResource** aResult)
    1: {
    1:     if (aRowIndex < 0 || aRowIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     return GetResourceFor(aRowIndex, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetIndexOfResource(nsIRDFResource* aResource, PRInt32* aResult)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aResource);
    1:     nsTreeRows::iterator iter = mRows.FindByResource(aResource);
    1:     if (iter == mRows.Last())
    1:         *aResult = -1;
    1:     else
    1:         *aResult = iter.GetRowIndex();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::AddObserver(nsIXULTreeBuilderObserver* aObserver)
    1: {
    1:     nsresult rv;  
    1:     if (!mObservers) {
    1:         rv = NS_NewISupportsArray(getter_AddRefs(mObservers));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     return mObservers->AppendElement(aObserver);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::RemoveObserver(nsIXULTreeBuilderObserver* aObserver)
    1: {
    1:     return mObservers ? mObservers->RemoveElement(aObserver) : NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::Sort(nsIDOMElement* aElement)
    1: {
    1:     nsCOMPtr<nsIContent> header = do_QueryInterface(aElement);
    1:     if (! header)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     if (header->AttrValueIs(kNameSpaceID_None, nsGkAtoms::sortLocked,
    1:                             nsGkAtoms::_true, eCaseMatters))
    1:         return NS_OK;
    1: 
    1:     nsAutoString sort;
    1:     header->GetAttr(kNameSpaceID_None, nsGkAtoms::sort, sort);
    1: 
    1:     if (sort.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     // Grab the new sort variable
    1:     mSortVariable = do_GetAtom(sort);
    1: 
    1:     // Cycle the sort direction
    1:     nsAutoString dir;
    1:     header->GetAttr(kNameSpaceID_None, nsGkAtoms::sortDirection, dir);
    1: 
    1:     if (dir.EqualsLiteral("ascending")) {
    1:         dir.AssignLiteral("descending");
    1:         mSortDirection = eDirection_Descending;
    1:     }
    1:     else if (dir.EqualsLiteral("descending")) {
    1:         dir.AssignLiteral("natural");
    1:         mSortDirection = eDirection_Natural;
    1:     }
    1:     else {
    1:         dir.AssignLiteral("ascending");
    1:         mSortDirection = eDirection_Ascending;
    1:     }
    1: 
    1:     // Sort it.
    1:     SortSubtree(mRows.GetRoot());
    1:     mRows.InvalidateCachedRow();
    1:     if (mBoxObject) 
    1:         mBoxObject->Invalidate();
    1: 
    1:     nsTreeUtils::UpdateSortIndicators(header, dir);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsITreeView methods
    1: //
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetRowCount(PRInt32* aRowCount)
    1: {
    1:     *aRowCount = mRows.Count();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetSelection(nsITreeSelection** aSelection)
    1: {
    1:     NS_IF_ADDREF(*aSelection = mSelection.get());
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::SetSelection(nsITreeSelection* aSelection)
    1: {
    1:     mSelection = aSelection;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetRowProperties(PRInt32 aIndex, nsISupportsArray* aProperties)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aProperties);
    1:     NS_PRECONDITION(aIndex >= 0 && aIndex < mRows.Count(), "bad row");
    1:     if (aIndex < 0 || aIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsCOMPtr<nsIContent> row;
    1:     GetTemplateActionRowFor(aIndex, getter_AddRefs(row));
    1:     if (row) {
    1:         nsAutoString raw;
    1:         row->GetAttr(kNameSpaceID_None, nsGkAtoms::properties, raw);
    1: 
    1:         if (!raw.IsEmpty()) {
    1:             nsAutoString cooked;
    1:             SubstituteText(mRows[aIndex]->mMatch->mResult, raw, cooked);
    1: 
    1:             nsTreeUtils::TokenizeProperties(cooked, aProperties);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetCellProperties(PRInt32 aRow, nsITreeColumn* aCol, nsISupportsArray* aProperties)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     NS_ENSURE_ARG_POINTER(aProperties);
    1:     NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad row");
    1:     if (aRow < 0 || aRow >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsCOMPtr<nsIContent> cell;
    1:     GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
    1:     if (cell) {
    1:         nsAutoString raw;
    1:         cell->GetAttr(kNameSpaceID_None, nsGkAtoms::properties, raw);
    1: 
    1:         if (!raw.IsEmpty()) {
    1:             nsAutoString cooked;
    1:             SubstituteText(mRows[aRow]->mMatch->mResult, raw, cooked);
    1: 
    1:             nsTreeUtils::TokenizeProperties(cooked, aProperties);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetColumnProperties(nsITreeColumn* aCol,
    1:                                       nsISupportsArray* aProperties)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     NS_ENSURE_ARG_POINTER(aProperties);
    1:     // XXX sortactive fu
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::IsContainer(PRInt32 aIndex, PRBool* aResult)
    1: {
    1:     NS_PRECONDITION(aIndex >= 0 && aIndex < mRows.Count(), "bad row");
    1:     if (aIndex < 0 || aIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsTreeRows::iterator iter = mRows[aIndex];
    1: 
    1:     if (iter->mContainerType == nsTreeRows::eContainerType_Unknown) {
    1:         PRBool isContainer;
    1:         iter->mMatch->mResult->GetIsContainer(&isContainer);
    1: 
    1:         iter->mContainerType = isContainer
    1:             ? nsTreeRows::eContainerType_Container
    1:             : nsTreeRows::eContainerType_Noncontainer;
    1:     }
    1: 
    1:     *aResult = (iter->mContainerType == nsTreeRows::eContainerType_Container);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::IsContainerOpen(PRInt32 aIndex, PRBool* aOpen)
    1: {
    1:     NS_PRECONDITION(aIndex >= 0 && aIndex < mRows.Count(), "bad row");
    1:     if (aIndex < 0 || aIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsTreeRows::iterator iter = mRows[aIndex];
    1: 
    1:     if (iter->mContainerState == nsTreeRows::eContainerState_Unknown) {
    1:         PRBool isOpen;
    1:         IsContainerOpen(iter->mMatch->mResult, &isOpen);
    1: 
    1:         iter->mContainerState = isOpen
    1:             ? nsTreeRows::eContainerState_Open
    1:             : nsTreeRows::eContainerState_Closed;
    1:     }
    1: 
    1:     *aOpen = (iter->mContainerState == nsTreeRows::eContainerState_Open);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::IsContainerEmpty(PRInt32 aIndex, PRBool* aResult)
    1: {
    1:     NS_PRECONDITION(aIndex >= 0 && aIndex < mRows.Count(), "bad row");
    1:     if (aIndex < 0 || aIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsTreeRows::iterator iter = mRows[aIndex];
    1:     NS_ASSERTION(iter->mContainerType == nsTreeRows::eContainerType_Container,
    1:                  "asking for empty state on non-container");
    1: 
    1:     // if recursion is disabled, pretend that the container is empty. This
    1:     // ensures that folders are still displayed as such, yet won't display
    1:     // their children
    1:     if ((mFlags & eDontRecurse) && (iter->mMatch->mResult != mRootResult)) {
    1:         *aResult = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (iter->mContainerFill == nsTreeRows::eContainerFill_Unknown) {
    1:         PRBool isEmpty;
    1:         iter->mMatch->mResult->GetIsEmpty(&isEmpty);
    1: 
    1:         iter->mContainerFill = isEmpty
    1:             ? nsTreeRows::eContainerFill_Empty
    1:             : nsTreeRows::eContainerFill_Nonempty;
    1:     }
    1: 
    1:     *aResult = (iter->mContainerFill == nsTreeRows::eContainerFill_Empty);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::IsSeparator(PRInt32 aIndex, PRBool* aResult)
    1: {
    1:     NS_PRECONDITION(aIndex >= 0 && aIndex < mRows.Count(), "bad row");
    1:     if (aIndex < 0 || aIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsAutoString type;
    1:     nsTreeRows::Row& row = *(mRows[aIndex]);
    1:     row.mMatch->mResult->GetType(type);
    1: 
    1:     *aResult = type.EqualsLiteral("separator");
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetParentIndex(PRInt32 aRowIndex, PRInt32* aResult)
    1: {
    1:     NS_PRECONDITION(aRowIndex >= 0 && aRowIndex < mRows.Count(), "bad row");
    1:     if (aRowIndex < 0 || aRowIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // Construct a path to the row
    1:     nsTreeRows::iterator iter = mRows[aRowIndex];
    1: 
    1:     // The parent of the row will be at the top of the path
    1:     nsTreeRows::Subtree* parent = iter.GetParent();
    1: 
    1:     // Now walk through our previous siblings, subtracting off each
    1:     // one's subtree size
    1:     PRInt32 index = iter.GetChildIndex();
    1:     while (--index >= 0)
    1:         aRowIndex -= mRows.GetSubtreeSizeFor(parent, index) + 1;
    1: 
    1:     // Now the parent's index will be the first row's index, less one.
    1:     *aResult = aRowIndex - 1;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::HasNextSibling(PRInt32 aRowIndex, PRInt32 aAfterIndex, PRBool* aResult)
    1: {
    1:     NS_PRECONDITION(aRowIndex >= 0 && aRowIndex < mRows.Count(), "bad row");
    1:     if (aRowIndex < 0 || aRowIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // Construct a path to the row
    1:     nsTreeRows::iterator iter = mRows[aRowIndex];
    1: 
    1:     // The parent of the row will be at the top of the path
    1:     nsTreeRows::Subtree* parent = iter.GetParent();
    1: 
    1:     // We have a next sibling if the child is not the last in the
    1:     // subtree.
    1:     *aResult = iter.GetChildIndex() != parent->Count() - 1;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetLevel(PRInt32 aRowIndex, PRInt32* aResult)
    1: {
    1:     NS_PRECONDITION(aRowIndex >= 0 && aRowIndex < mRows.Count(), "bad row");
    1:     if (aRowIndex < 0 || aRowIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // Construct a path to the row; the ``level'' is the path length
    1:     // less one.
    1:     nsTreeRows::iterator iter = mRows[aRowIndex];
    1:     *aResult = iter.GetDepth() - 1;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetImageSrc(PRInt32 aRow, nsITreeColumn* aCol, nsAString& aResult)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad index");
    1:     if (aRow < 0 || aRow >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // Find the <cell> that corresponds to the column we want.
    1:     nsCOMPtr<nsIContent> cell;
    1:     GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
    1:     if (cell) {
    1:         nsAutoString raw;
    1:         cell->GetAttr(kNameSpaceID_None, nsGkAtoms::src, raw);
    1: 
    1:         SubstituteText(mRows[aRow]->mMatch->mResult, raw, aResult);
    1:     }
    1:     else
    1:         aResult.Truncate();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetProgressMode(PRInt32 aRow, nsITreeColumn* aCol, PRInt32* aResult)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad index");
    1:     if (aRow < 0 || aRow >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     *aResult = nsITreeView::PROGRESS_NONE;
    1: 
    1:     // Find the <cell> that corresponds to the column we want.
    1:     nsCOMPtr<nsIContent> cell;
    1:     GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
    1:     if (cell) {
    1:         nsAutoString raw;
    1:         cell->GetAttr(kNameSpaceID_None, nsGkAtoms::mode, raw);
    1: 
    1:         nsAutoString mode;
    1:         SubstituteText(mRows[aRow]->mMatch->mResult, raw, mode);
    1: 
    1:         if (mode.EqualsLiteral("normal"))
    1:             *aResult = nsITreeView::PROGRESS_NORMAL;
    1:         else if (mode.EqualsLiteral("undetermined"))
    1:             *aResult = nsITreeView::PROGRESS_UNDETERMINED;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetCellValue(PRInt32 aRow, nsITreeColumn* aCol, nsAString& aResult)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad index");
    1:     if (aRow < 0 || aRow >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // Find the <cell> that corresponds to the column we want.
    1:     nsCOMPtr<nsIContent> cell;
    1:     GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
    1:     if (cell) {
    1:         nsAutoString raw;
    1:         cell->GetAttr(kNameSpaceID_None, nsGkAtoms::value, raw);
    1: 
    1:         SubstituteText(mRows[aRow]->mMatch->mResult, raw, aResult);
    1:     }
    1:     else
    1:         aResult.Truncate();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::GetCellText(PRInt32 aRow, nsITreeColumn* aCol, nsAString& aResult)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad index");
    1:     if (aRow < 0 || aRow >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // Find the <cell> that corresponds to the column we want.
    1:     nsCOMPtr<nsIContent> cell;
    1:     GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
    1:     if (cell) {
    1:         nsAutoString raw;
    1:         cell->GetAttr(kNameSpaceID_None, nsGkAtoms::label, raw);
    1: 
    1:         SubstituteText(mRows[aRow]->mMatch->mResult, raw, aResult);
    1: 
    1:     }
    1:     else
    1:         aResult.Truncate();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::SetTree(nsITreeBoxObject* aTree)
    1: {
    1:     mBoxObject = aTree;
    1: 
    1:     // If this is teardown time, then we're done.
    1:     if (!mBoxObject) {
    1:         Uninit(PR_FALSE);
    1:         return NS_OK;
    1:     }
11838:     NS_ENSURE_TRUE(mRoot, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     // Is our root's principal trusted?
    1:     PRBool isTrusted = PR_FALSE;
    1:     nsresult rv = IsSystemPrincipal(mRoot->NodePrincipal(), &isTrusted);
    1:     if (NS_SUCCEEDED(rv) && isTrusted) {
    1:         // Get the datasource we intend to use to remember open state.
    1:         nsAutoString datasourceStr;
    1:         mRoot->GetAttr(kNameSpaceID_None, nsGkAtoms::statedatasource, datasourceStr);
    1: 
    1:         // since we are trusted, use the user specified datasource
    1:         // if non specified, use localstore, which gives us
    1:         // persistence across sessions
    1:         if (! datasourceStr.IsEmpty()) {
    1:             gRDFService->GetDataSource(NS_ConvertUTF16toUTF8(datasourceStr).get(),
    1:                                        getter_AddRefs(mPersistStateStore));
    1:         }
    1:         else {
    1:             gRDFService->GetDataSource("rdf:local-store",
    1:                                        getter_AddRefs(mPersistStateStore));
    1:         }
    1:     }
    1: 
    1:     // Either no specific datasource was specified, or we failed
    1:     // to get one because we are not trusted.
    1:     //
    1:     // XXX if it were possible to ``write an arbitrary datasource
    1:     // back'', then we could also allow an untrusted document to
    1:     // use a statedatasource from the same codebase.
    1:     if (! mPersistStateStore) {
    1:         mPersistStateStore =
    1:             do_CreateInstance("@mozilla.org/rdf/datasource;1?name=in-memory-datasource");
    1:     }
    1: 
    1:     NS_ASSERTION(mPersistStateStore, "failed to get a persistent state store");
    1:     if (! mPersistStateStore)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     Rebuild();
    1: 
    1:     EnsureSortVariables();
    1:     if (mSortVariable)
    1:         SortSubtree(mRows.GetRoot());
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::ToggleOpenState(PRInt32 aIndex)
    1: {
    1:     if (aIndex < 0 || aIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsIXULTemplateResult* result = mRows[aIndex]->mMatch->mResult;
    1:     if (! result)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     if (mFlags & eDontRecurse)
    1:         return NS_OK;
    1: 
    1:     if (result && result != mRootResult) {
    1:         // don't open containers if child processing isn't allowed
    1:         PRBool mayProcessChildren;
    1:         nsresult rv = result->GetMayProcessChildren(&mayProcessChildren);
    1:         if (NS_FAILED(rv) || !mayProcessChildren)
    1:             return rv;
    1:     }
    1: 
    1:     if (mObservers) {
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer)
    1:                 observer->OnToggleOpenState(aIndex);
    1:         }
    1:     }
    1: 
    1:     if (mPersistStateStore) {
    1:         PRBool isOpen;
    1:         IsContainerOpen(aIndex, &isOpen);
    1: 
    1:         nsCOMPtr<nsIRDFResource> container;
    1:         GetResourceFor(aIndex, getter_AddRefs(container));
    1:         if (! container)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         PRBool hasProperty;
    1:         IsContainerOpen(container, &hasProperty);
    1: 
    1:         if (isOpen) {
    1:             if (hasProperty) {
    1:                 mPersistStateStore->Unassert(container,
    1:                                              nsXULContentUtils::NC_open,
    1:                                              nsXULContentUtils::true_);
    1:             }
    1: 
    1:             CloseContainer(aIndex);
    1:         }
    1:         else {
    1:             if (! hasProperty) {
    1:                 mPersistStateStore->Assert(container,
    1:                                            nsXULContentUtils::NC_open,
    1:                                            nsXULContentUtils::true_,
    1:                                            PR_TRUE);
    1:             }
    1: 
    1:             OpenContainer(aIndex, result);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::CycleHeader(nsITreeColumn* aCol)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     nsCOMPtr<nsIDOMElement> element;
    1:     aCol->GetElement(getter_AddRefs(element));
    1: 
    1:     if (mObservers) {
    1:         nsAutoString id;
    1:         aCol->GetId(id);
    1: 
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer)
    1:                 observer->OnCycleHeader(id.get(), element);
    1:         }
    1:     }
    1: 
    1:     return Sort(element);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::SelectionChanged()
    1: {
    1:     if (mObservers) {
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer)
    1:                 observer->OnSelectionChanged();
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::CycleCell(PRInt32 aRow, nsITreeColumn* aCol)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     if (mObservers) {
    1:         nsAutoString id;
    1:         aCol->GetId(id);
    1: 
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer)
    1:                 observer->OnCycleCell(aRow, id.get());
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::IsEditable(PRInt32 aRow, nsITreeColumn* aCol, PRBool* _retval)
    1: {
    1:     *_retval = PR_TRUE;
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad index");
    1:     if (aRow < 0 || aRow >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // Find the <cell> that corresponds to the column we want.
    1:     nsCOMPtr<nsIContent> cell;
    1:     GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
    1:     if (cell) {
    1:         nsAutoString raw;
    1:         cell->GetAttr(kNameSpaceID_None, nsGkAtoms::editable, raw);
    1: 
    1:         nsAutoString editable;
    1:         SubstituteText(mRows[aRow]->mMatch->mResult, raw, editable);
    1: 
    1:         if (editable.EqualsLiteral("false"))
    1:             *_retval = PR_FALSE;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::IsSelectable(PRInt32 aRow, nsITreeColumn* aCol, PRBool* _retval)
    1: {
    1:     NS_PRECONDITION(aRow >= 0 && aRow < mRows.Count(), "bad index");
    1:     if (aRow < 0 || aRow >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     *_retval = PR_TRUE;
    1: 
    1:     // Find the <cell> that corresponds to the column we want.
    1:     nsCOMPtr<nsIContent> cell;
    1:     GetTemplateActionCellFor(aRow, aCol, getter_AddRefs(cell));
    1:     if (cell) {
    1:         nsAutoString raw;
    1:         cell->GetAttr(kNameSpaceID_None, nsGkAtoms::selectable, raw);
    1: 
    1:         nsAutoString selectable;
    1:         SubstituteText(mRows[aRow]->mMatch->mResult, raw, selectable);
    1: 
    1:         if (selectable.EqualsLiteral("false"))
    1:             *_retval = PR_FALSE;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::SetCellValue(PRInt32 aRow, nsITreeColumn* aCol, const nsAString& aValue)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::SetCellText(PRInt32 aRow, nsITreeColumn* aCol, const nsAString& aValue)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::PerformAction(const PRUnichar* aAction)
    1: {
    1:     if (mObservers) {  
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer)
    1:                 observer->OnPerformAction(aAction);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::PerformActionOnRow(const PRUnichar* aAction, PRInt32 aRow)
    1: {
    1:     if (mObservers) {  
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer)
    1:                 observer->OnPerformActionOnRow(aAction, aRow);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::PerformActionOnCell(const PRUnichar* aAction, PRInt32 aRow, nsITreeColumn* aCol)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCol);
    1:     if (mObservers) {  
    1:         nsAutoString id;
    1:         aCol->GetId(id);
    1: 
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer)
    1:                 observer->OnPerformActionOnCell(aAction, aRow, id.get());
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: void
    1: nsXULTreeBuilder::NodeWillBeDestroyed(const nsINode* aNode)
    1: {
    1:     if (mObservers)
    1:         mObservers->Clear();
    1: 
    1:     nsXULTemplateBuilder::NodeWillBeDestroyed(aNode);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::HasGeneratedContent(nsIRDFResource* aResource,
    1:                                       nsIAtom* aTag,
    1:                                       PRBool* aGenerated)
    1: {
    1:     *aGenerated = PR_FALSE;
    1:     NS_ENSURE_ARG_POINTER(aResource);
    1: 
    1:     if (!mRootResult)
    1:         return NS_OK;
    1: 
    1:     nsCOMPtr<nsIRDFResource> rootresource;
    1:     nsresult rv = mRootResult->GetResource(getter_AddRefs(rootresource));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (aResource == rootresource ||
    1:         mRows.FindByResource(aResource) != mRows.Last())
    1:         *aGenerated = PR_TRUE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsXULTreeBuilder::GetInsertionLocations(nsIXULTemplateResult* aResult,
    1:                                         nsCOMArray<nsIContent>** aLocations)
    1: {
    1:     *aLocations = nsnull;
    1: 
    1:     // Get the reference point and check if it is an open container. Rows
    1:     // should not be generated otherwise.
    1: 
    1:     nsAutoString ref;
    1:     nsresult rv = aResult->GetBindingFor(mRefVariable, ref);
    1:     if (NS_FAILED(rv) || ref.IsEmpty())
    1:         return PR_FALSE;
    1: 
    1:     nsCOMPtr<nsIRDFResource> container;
    1:     rv = gRDFService->GetUnicodeResource(ref, getter_AddRefs(container));
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     // Can always insert into the root resource
    1:     if (container == mRows.GetRootResource())
    1:         return PR_TRUE;
    1: 
    1:     nsTreeRows::iterator iter = mRows.FindByResource(container);
    1:     if (iter == mRows.Last())
    1:         return PR_FALSE;
    1: 
    1:     return (iter->mContainerState == nsTreeRows::eContainerState_Open);
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::ReplaceMatch(nsIXULTemplateResult* aOldResult,
    1:                                nsTemplateMatch* aNewMatch,
    1:                                nsTemplateRule* aNewMatchRule,
    1:                                void *aLocation)
    1: {
    1:     if (! mBoxObject)
    1:         return NS_OK;
    1: 
    1:     if (aOldResult) {
    1:         // Grovel through the rows looking for oldresult.
    1:         nsTreeRows::iterator iter = mRows.Find(aOldResult);
    1: 
    1:         NS_ASSERTION(iter != mRows.Last(), "couldn't find row");
    1:         if (iter == mRows.Last())
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         // Remove the rows from the view
    1:         PRInt32 row = iter.GetRowIndex();
    1: 
    1:         // If the row contains children, remove the matches from the
    1:         // children so that they can be regenerated again if the element
    1:         // gets added back.
    1:         PRInt32 delta = mRows.GetSubtreeSizeFor(iter);
    1:         if (delta)
    1:             RemoveMatchesFor(*(iter->mSubtree));
    1: 
    1:         if (mRows.RemoveRowAt(iter) == 0 && iter.GetRowIndex() >= 0) {
    1: 
    1:             // In this case iter now points to its parent
    1:             // Invalidate the row's cached fill state
    1:             iter->mContainerFill = nsTreeRows::eContainerFill_Unknown;
    1: 
    1:             nsCOMPtr<nsITreeColumns> cols;
    1:             mBoxObject->GetColumns(getter_AddRefs(cols));
    1:             if (cols) {
    1:                 nsCOMPtr<nsITreeColumn> primaryCol;
    1:                 cols->GetPrimaryColumn(getter_AddRefs(primaryCol));
    1:                 if (primaryCol)
    1:                     mBoxObject->InvalidateCell(iter.GetRowIndex(), primaryCol);
    1:             }
    1:         }
    1: 
    1:         // Notify the box object
    1:         mBoxObject->RowCountChanged(row, -delta - 1);
    1:     }
    1: 
    1:     if (aNewMatch && aNewMatch->mResult) {
    1:         // Insertion.
    1:         PRInt32 row = -1;
    1:         nsTreeRows::Subtree* parent = nsnull;
    1:         nsIXULTemplateResult* result = aNewMatch->mResult;
    1: 
    1:         nsAutoString ref;
    1:         nsresult rv = result->GetBindingFor(mRefVariable, ref);
    1:         if (NS_FAILED(rv) || ref.IsEmpty())
    1:             return rv;
    1: 
    1:         nsCOMPtr<nsIRDFResource> container;
    1:         rv = gRDFService->GetUnicodeResource(ref, getter_AddRefs(container));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         if (container != mRows.GetRootResource()) {
    1:             nsTreeRows::iterator iter = mRows.FindByResource(container);
    1:             row = iter.GetRowIndex();
    1: 
    1:             NS_ASSERTION(iter != mRows.Last(), "couldn't find container row");
    1:             if (iter == mRows.Last())
    1:                 return NS_ERROR_FAILURE;
    1: 
    1:             // Use the persist store to remember if the container
    1:             // is open or closed.
    1:             PRBool open = PR_FALSE;
    1:             IsContainerOpen(row, &open);
    1: 
    1:             // If it's open, make sure that we've got a subtree structure ready.
    1:             if (open)
    1:                 parent = mRows.EnsureSubtreeFor(iter);
    1: 
    1:             // We know something has just been inserted into the
    1:             // container, so whether its open or closed, make sure
    1:             // that we've got our tree row's state correct.
    1:             if ((iter->mContainerType != nsTreeRows::eContainerType_Container) ||
    1:                 (iter->mContainerFill != nsTreeRows::eContainerFill_Nonempty)) {
    1:                 iter->mContainerType  = nsTreeRows::eContainerType_Container;
    1:                 iter->mContainerFill = nsTreeRows::eContainerFill_Nonempty;
    1:                 mBoxObject->InvalidateRow(iter.GetRowIndex());
    1:             }
    1:         }
    1:         else {
    1:             parent = mRows.GetRoot();
    1:         }
    1: 
    1:         if (parent) {
    1:             // If we get here, then we're inserting into an open
    1:             // container. By default, place the new element at the
    1:             // end of the container
    1:             PRInt32 index = parent->Count();
    1: 
    1:             if (mSortVariable) {
    1:                 // Figure out where to put the new element by doing an
    1:                 // insertion sort.
    1:                 PRInt32 left = 0;
    1:                 PRInt32 right = index;
    1: 
    1:                 while (left < right) {
    1:                     index = (left + right) / 2;
    1:                     PRInt32 cmp = CompareResults((*parent)[index].mMatch->mResult, result);
    1:                     if (cmp < 0)
    1:                         left = ++index;
    1:                     else if (cmp > 0)
    1:                         right = index;
    1:                     else
    1:                         break;
    1:                 }
    1:             }
    1: 
    1:             nsTreeRows::iterator iter =
    1:                 mRows.InsertRowAt(aNewMatch, parent, index);
    1: 
    1:             mBoxObject->RowCountChanged(iter.GetRowIndex(), +1);
    1: 
    1:             // See if this newly added row is open; in which case,
    1:             // recursively add its children to the tree, too.
    1: 
    1:             if (mFlags & eDontRecurse)
    1:                 return NS_OK;
    1: 
    1:             if (result && (result != mRootResult)) {
    1:                 // don't open containers if child processing isn't allowed
    1:                 PRBool mayProcessChildren;
    1:                 nsresult rv = result->GetMayProcessChildren(&mayProcessChildren);
    1:                 if (NS_FAILED(rv) || ! mayProcessChildren) return NS_OK;
    1:             }
    1: 
    1:             PRBool open;
    1:             IsContainerOpen(result, &open);
    1:             if (open)
    1:                 OpenContainer(iter.GetRowIndex(), result);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::SynchronizeResult(nsIXULTemplateResult* aResult)
    1: {
    1:     if (mBoxObject) {
    1:         // XXX we could be more conservative and just invalidate the cells
    1:         // that got whacked...
    1: 
    1:         nsTreeRows::iterator iter = mRows.Find(aResult);
    1: 
    1:         NS_ASSERTION(iter != mRows.Last(), "couldn't find row");
    1:         if (iter == mRows.Last())
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         PRInt32 row = iter.GetRowIndex();
    1:         if (row >= 0)
    1:             mBoxObject->InvalidateRow(row);
    1: 
    1:         PR_LOG(gXULTemplateLog, PR_LOG_DEBUG,
    1:                ("xultemplate[%p]   => row %d", this, row));
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsXULTreeBuilder::EnsureSortVariables()
    1: {
    1:     // Grovel through <treecols> kids to find the <treecol>
    1:     // with the sort attributes.
    1:     nsCOMPtr<nsIContent> treecols;
    1:  
    1:     nsXULContentUtils::FindChildByTag(mRoot, kNameSpaceID_XUL,
    1:                                       nsGkAtoms::treecols,
    1:                                       getter_AddRefs(treecols));
    1: 
    1:     if (!treecols)
    1:         return NS_OK;
    1: 
    1:     PRUint32 count = treecols->GetChildCount();
    1:     for (PRUint32 i = 0; i < count; ++i) {
    1:         nsIContent *child = treecols->GetChildAt(i);
    1: 
    1:         if (child->NodeInfo()->Equals(nsGkAtoms::treecol,
    1:                                       kNameSpaceID_XUL)) {
    1:             if (child->AttrValueIs(kNameSpaceID_None, nsGkAtoms::sortActive,
    1:                                    nsGkAtoms::_true, eCaseMatters)) {
    1:                 nsAutoString sort;
    1:                 child->GetAttr(kNameSpaceID_None, nsGkAtoms::sort, sort);
    1:                 if (! sort.IsEmpty()) {
    1:                     mSortVariable = do_GetAtom(sort);
    1: 
    1:                     static nsIContent::AttrValuesArray strings[] =
    1:                       {&nsGkAtoms::ascending, &nsGkAtoms::descending, nsnull};
    1:                     switch (child->FindAttrValueIn(kNameSpaceID_None,
    1:                                                    nsGkAtoms::sortDirection,
    1:                                                    strings, eCaseMatters)) {
    1:                        case 0: mSortDirection = eDirection_Ascending; break;
    1:                        case 1: mSortDirection = eDirection_Descending; break;
    1:                        default: mSortDirection = eDirection_Natural; break;
    1:                     }
    1:                 }
    1:                 break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::RebuildAll()
    1: {
11838:     NS_ENSURE_TRUE(mRoot, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     nsCOMPtr<nsIDocument> doc = mRoot->GetDocument();
    1: 
    1:     // Bail out early if we are being torn down.
    1:     if (!doc)
    1:         return NS_OK;
    1: 
    1:     if (! mQueryProcessor)
    1:         return NS_OK;
    1: 
28717:     if (mBoxObject) {
28717:         mBoxObject->BeginUpdateBatch();
28717:     }
28717: 
    1:     if (mQueriesCompiled) {
    1:         Uninit(PR_FALSE);
    1:     }
    1:     else if (mBoxObject) {
    1:         PRInt32 count = mRows.Count();
    1:         mRows.Clear();
    1:         mBoxObject->RowCountChanged(0, -count);
    1:     }
    1: 
    1:     nsresult rv = CompileQueries();
28717:     if (NS_SUCCEEDED(rv) && mQuerySets.Length() > 0) {
    1:         // Seed the rule network with assignments for the tree row variable
    1:         nsAutoString ref;
    1:         mRoot->GetAttr(kNameSpaceID_None, nsGkAtoms::ref, ref);
    1:         if (!ref.IsEmpty()) {
 2435:             rv = mQueryProcessor->TranslateRef(mDataSource, ref,
 2435:                                                getter_AddRefs(mRootResult));
28717:             if (NS_SUCCEEDED(rv) && mRootResult) {
    1:                 OpenContainer(-1, mRootResult);
    1: 
    1:                 nsCOMPtr<nsIRDFResource> rootResource;
    1:                 GetResultResource(mRootResult, getter_AddRefs(rootResource));
    1: 
    1:                 mRows.SetRootResource(rootResource);
    1:             }
    1:         }
28717:     }
    1: 
    1:     if (mBoxObject) {
    1:         mBoxObject->EndUpdateBatch();
    1:     }
    1: 
28717:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::GetTemplateActionRowFor(PRInt32 aRow, nsIContent** aResult)
    1: {
    1:     // Get the template in the DOM from which we're supposed to
    1:     // generate text
    1:     nsTreeRows::Row& row = *(mRows[aRow]);
    1: 
    1:     // The match stores the indices of the rule and query to use. Use these
    1:     // to look up the right nsTemplateRule and use that rule's action to get
    1:     // the treerow in the template.
    1:     PRInt16 ruleindex = row.mMatch->RuleIndex();
    1:     if (ruleindex >= 0) {
    1:         nsTemplateQuerySet* qs = mQuerySets[row.mMatch->QuerySetPriority()];
    1:         nsTemplateRule* rule = qs->GetRuleAt(ruleindex);
    1:         if (rule) {
    1:             nsCOMPtr<nsIContent> children;
22939:             nsXULContentUtils::FindChildByTag(rule->GetAction(), kNameSpaceID_XUL,
    1:                                               nsGkAtoms::treechildren,
    1:                                               getter_AddRefs(children));
    1:             if (children) {
    1:                 nsCOMPtr<nsIContent> item;
    1:                 nsXULContentUtils::FindChildByTag(children, kNameSpaceID_XUL,
    1:                                                   nsGkAtoms::treeitem,
    1:                                                   getter_AddRefs(item));
    1:                 if (item)
    1:                     return nsXULContentUtils::FindChildByTag(item,
    1:                                                              kNameSpaceID_XUL,
    1:                                                              nsGkAtoms::treerow,
    1:                                                              aResult);
    1:             }
    1:         }
    1:     }
    1: 
    1:     *aResult = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::GetTemplateActionCellFor(PRInt32 aRow,
    1:                                            nsITreeColumn* aCol,
    1:                                            nsIContent** aResult)
    1: {
    1:     *aResult = nsnull;
    1: 
    1:     if (!aCol) return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsCOMPtr<nsIContent> row;
    1:     GetTemplateActionRowFor(aRow, getter_AddRefs(row));
    1:     if (row) {
    1:         nsCOMPtr<nsIAtom> colAtom;
    1:         PRInt32 colIndex;
    1:         aCol->GetAtom(getter_AddRefs(colAtom));
    1:         aCol->GetIndex(&colIndex);
    1: 
    1:         PRUint32 count = row->GetChildCount();
    1:         PRUint32 j = 0;
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsIContent *child = row->GetChildAt(i);
    1: 
    1:             if (child->NodeInfo()->Equals(nsGkAtoms::treecell,
    1:                                           kNameSpaceID_XUL)) {
    1:                 if (colAtom &&
    1:                     child->AttrValueIs(kNameSpaceID_None, nsGkAtoms::ref,
    1:                                        colAtom, eCaseMatters)) {
    1:                     *aResult = child;
    1:                     break;
    1:                 }
    1:                 else if (j == (PRUint32)colIndex)
    1:                     *aResult = child;
    1:                 j++;
    1:             }
    1:         }
    1:     }
    1:     NS_IF_ADDREF(*aResult);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::GetResourceFor(PRInt32 aRow, nsIRDFResource** aResource)
    1: {
    1:     nsTreeRows::Row& row = *(mRows[aRow]);
    1:     return GetResultResource(row.mMatch->mResult, aResource);
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::OpenContainer(PRInt32 aIndex, nsIXULTemplateResult* aResult)
    1: {
    1:     // A row index of -1 in this case means ``open tree body''
    1:     NS_ASSERTION(aIndex >= -1 && aIndex < mRows.Count(), "bad row");
    1:     if (aIndex < -1 || aIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsTreeRows::Subtree* container;
    1: 
    1:     if (aIndex >= 0) {
    1:         nsTreeRows::iterator iter = mRows[aIndex];
    1:         container = mRows.EnsureSubtreeFor(iter.GetParent(),
    1:                                            iter.GetChildIndex());
    1: 
    1:         iter->mContainerState = nsTreeRows::eContainerState_Open;
    1:     }
    1:     else
    1:         container = mRows.GetRoot();
    1: 
    1:     if (! container)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     PRInt32 count;
    1:     OpenSubtreeOf(container, aIndex, aResult, &count);
    1: 
    1:     // Notify the box object
    1:     if (mBoxObject) {
    1:         if (aIndex >= 0)
    1:             mBoxObject->InvalidateRow(aIndex);
    1: 
    1:         if (count)
    1:             mBoxObject->RowCountChanged(aIndex + 1, count);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::OpenSubtreeOf(nsTreeRows::Subtree* aSubtree,
    1:                                 PRInt32 aIndex,
    1:                                 nsIXULTemplateResult *aResult,
    1:                                 PRInt32* aDelta)
    1: {
26413:     nsAutoTArray<PRInt32, 8> open;
    1:     PRInt32 count = 0;
    1: 
    1:     PRInt32 rulecount = mQuerySets.Length();
    1: 
    1:     for (PRInt32 r = 0; r < rulecount; r++) {
    1:         nsTemplateQuerySet* queryset = mQuerySets[r];
    1:         OpenSubtreeForQuerySet(aSubtree, aIndex, aResult, queryset, &count, open);
    1:     }
    1: 
    1:     // Now recursively deal with any open sub-containers that just got
    1:     // inserted. We need to do this back-to-front to avoid skewing offsets.
26413:     for (PRInt32 i = open.Length() - 1; i >= 0; --i) {
26413:         PRInt32 index = open[i];
    1: 
    1:         nsTreeRows::Subtree* child =
    1:             mRows.EnsureSubtreeFor(aSubtree, index);
    1: 
    1:         nsIXULTemplateResult* result = (*aSubtree)[index].mMatch->mResult;
    1: 
    1:         PRInt32 delta;
    1:         OpenSubtreeOf(child, aIndex + index, result, &delta);
    1:         count += delta;
    1:     }
    1: 
    1:     // Sort the container.
    1:     if (mSortVariable) {
    1:         NS_QuickSort(mRows.GetRowsFor(aSubtree),
    1:                      aSubtree->Count(),
    1:                      sizeof(nsTreeRows::Row),
    1:                      Compare,
    1:                      this);
    1:     }
    1: 
    1:     *aDelta = count;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::OpenSubtreeForQuerySet(nsTreeRows::Subtree* aSubtree,
    1:                                          PRInt32 aIndex,
    1:                                          nsIXULTemplateResult* aResult,
    1:                                          nsTemplateQuerySet* aQuerySet,
    1:                                          PRInt32* aDelta,
26413:                                          nsTArray<PRInt32>& open)
    1: {
    1:     PRInt32 count = *aDelta;
    1:     
    1:     nsCOMPtr<nsISimpleEnumerator> results;
 2435:     nsresult rv = mQueryProcessor->GenerateResults(mDataSource, aResult,
    1:                                                    aQuerySet->mCompiledQuery,
    1:                                                    getter_AddRefs(results));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRBool hasMoreResults;
    1:     rv = results->HasMoreElements(&hasMoreResults);
    1: 
    1:     for (; NS_SUCCEEDED(rv) && hasMoreResults;
    1:            rv = results->HasMoreElements(&hasMoreResults)) {
    1:         nsCOMPtr<nsISupports> nr;
    1:         rv = results->GetNext(getter_AddRefs(nr));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsCOMPtr<nsIXULTemplateResult> nextresult = do_QueryInterface(nr);
    1:         if (!nextresult)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         nsCOMPtr<nsIRDFResource> resultid;
    1:         rv = GetResultResource(nextresult, getter_AddRefs(resultid));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         if (! resultid)
    1:             continue;
    1: 
    1:         // check if there is already an existing match. If so, a previous
    1:         // query already generated content so the match is just added to the
    1:         // end of the set of matches.
    1: 
    1:         PRBool generateContent = PR_TRUE;
    1: 
    1:         nsTemplateMatch* prevmatch = nsnull;
    1:         nsTemplateMatch* existingmatch = nsnull;
    1:         if (mMatchMap.Get(resultid, &existingmatch)){
    1:             // check if there is an existing match that matched a rule
    1:             while (existingmatch) {
    1:                 if (existingmatch->IsActive())
    1:                     generateContent = PR_FALSE;
    1:                 prevmatch = existingmatch;
    1:                 existingmatch = existingmatch->mNext;
    1:             }
    1:         }
    1: 
    1:         nsTemplateMatch *newmatch =
    1:             nsTemplateMatch::Create(mPool, aQuerySet->Priority(),
    1:                                     nextresult, nsnull);
    1:         if (!newmatch)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         if (generateContent) {
    1:             // Don't allow cyclic graphs to get our knickers in a knot.
    1:             PRBool cyclic = PR_FALSE;
    1: 
    1:             if (aIndex >= 0) {
    1:                 for (nsTreeRows::iterator iter = mRows[aIndex]; iter.GetDepth() > 0; iter.Pop()) {
    1:                     nsCOMPtr<nsIRDFResource> parentid;
    1:                     rv = GetResultResource(iter->mMatch->mResult, getter_AddRefs(parentid));
    1:                     if (NS_FAILED(rv)) {
 2434:                         nsTemplateMatch::Destroy(mPool, newmatch, PR_FALSE);
    1:                         return rv;
    1:                     }
    1: 
    1:                     if (resultid == parentid) {
    1:                         cyclic = PR_TRUE;
    1:                         break;
    1:                     }
    1:                 }
    1:             }
    1: 
    1:             if (cyclic) {
    1:                 NS_WARNING("tree cannot handle cyclic graphs");
 2434:                 nsTemplateMatch::Destroy(mPool, newmatch, PR_FALSE);
    1:                 continue;
    1:             }
    1: 
    1:             PRInt16 ruleindex;
    1:             nsTemplateRule* matchedrule = nsnull;
    1:             rv = DetermineMatchedRule(nsnull, nextresult, aQuerySet,
    1:                                       &matchedrule, &ruleindex);
    1:             if (NS_FAILED(rv)) {
 2434:                 nsTemplateMatch::Destroy(mPool, newmatch, PR_FALSE);
    1:                 return rv;
    1:             }
    1: 
    1:             if (matchedrule) {
    1:                 rv = newmatch->RuleMatched(aQuerySet, matchedrule, ruleindex,
    1:                                            nextresult);
    1:                 if (NS_FAILED(rv)) {
 2434:                     nsTemplateMatch::Destroy(mPool, newmatch, PR_FALSE);
    1:                     return rv;
    1:                 }
    1: 
    1:                 // Remember that this match applied to this row
    1:                 mRows.InsertRowAt(newmatch, aSubtree, count);
    1: 
    1:                 // If this is open, then remember it so we can recursively add
    1:                 // *its* rows to the tree.
    1:                 PRBool isOpen = PR_FALSE;
    1:                 IsContainerOpen(nextresult, &isOpen);
    1:                 if (isOpen) {
26413:                     if (open.AppendElement(count) == nsnull)
    1:                         return NS_ERROR_OUT_OF_MEMORY;
    1:                 }
    1: 
    1:                 ++count;
    1:             }
37799: 
37799:             if (mFlags & eLoggingEnabled)
37799:                 OutputMatchToLog(resultid, newmatch, PR_TRUE);
37799: 
    1:         }
    1: 
    1:         if (prevmatch) {
    1:             prevmatch->mNext = newmatch;
    1:         }
    1:         else if (!mMatchMap.Put(resultid, newmatch)) {
 2434:             nsTemplateMatch::Destroy(mPool, newmatch, PR_TRUE);
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:     }
    1: 
    1:     *aDelta = count;
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::CloseContainer(PRInt32 aIndex)
    1: {
    1:     NS_ASSERTION(aIndex >= 0 && aIndex < mRows.Count(), "bad row");
    1:     if (aIndex < 0 || aIndex >= mRows.Count())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     nsTreeRows::iterator iter = mRows[aIndex];
    1: 
42619:     if (iter->mSubtree)
42619:         RemoveMatchesFor(*iter->mSubtree);
    1: 
    1: 
    1:     PRInt32 count = mRows.GetSubtreeSizeFor(iter);
    1:     mRows.RemoveSubtreeFor(iter);
    1: 
    1:     iter->mContainerState = nsTreeRows::eContainerState_Closed;
    1: 
    1:     if (mBoxObject) {
    1:         mBoxObject->InvalidateRow(aIndex);
    1: 
    1:         if (count)
    1:             mBoxObject->RowCountChanged(aIndex + 1, -count);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::RemoveMatchesFor(nsTreeRows::Subtree& subtree)
    1: {
    1:     for (PRInt32 i = subtree.Count() - 1; i >= 0; --i) {
    1:         nsTreeRows::Row& row = subtree[i];
    1: 
    1:         nsTemplateMatch* match = row.mMatch;
    1: 
    1:         nsCOMPtr<nsIRDFResource> id;
    1:         nsresult rv = GetResultResource(match->mResult, getter_AddRefs(id));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsTemplateMatch* existingmatch;
    1:         if (mMatchMap.Get(id, &existingmatch)) {
    1:             while (existingmatch) {
    1:                 nsTemplateMatch* nextmatch = existingmatch->mNext;
 2434:                 nsTemplateMatch::Destroy(mPool, existingmatch, PR_TRUE);
    1:                 existingmatch = nextmatch;
    1:             }
    1: 
    1:             mMatchMap.Remove(id);
    1:         }
    1: 
    1:         if ((row.mContainerState == nsTreeRows::eContainerState_Open) && row.mSubtree)
    1:             RemoveMatchesFor(*(row.mSubtree));
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::IsContainerOpen(nsIXULTemplateResult *aResult, PRBool* aOpen)
    1: {
    1:     // items are never open if recursion is disabled
    1:     if ((mFlags & eDontRecurse) && aResult != mRootResult) {
    1:         *aOpen = PR_FALSE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<nsIRDFResource> id;
    1:     nsresult rv = GetResultResource(aResult, getter_AddRefs(id));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     return IsContainerOpen(id, aOpen);
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::IsContainerOpen(nsIRDFResource* aResource, PRBool* aOpen)
    1: {
    1:     if (mPersistStateStore)
    1:         mPersistStateStore->HasAssertion(aResource,
    1:                                          nsXULContentUtils::NC_open,
    1:                                          nsXULContentUtils::true_,
    1:                                          PR_TRUE,
    1:                                          aOpen);
    1:     else
    1:         *aOpen = PR_FALSE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: int
    1: nsXULTreeBuilder::Compare(const void* aLeft, const void* aRight, void* aClosure)
    1: {
 3233:     nsXULTreeBuilder* self = static_cast<nsXULTreeBuilder*>(aClosure);
    1: 
 3233:     nsTreeRows::Row* left = static_cast<nsTreeRows::Row*>
 3233:                                        (const_cast<void*>(aLeft));
    1: 
 3233:     nsTreeRows::Row* right = static_cast<nsTreeRows::Row*>
 3233:                                         (const_cast<void*>(aRight));
    1: 
    1:     return self->CompareResults(left->mMatch->mResult, right->mMatch->mResult);
    1: }
    1: 
    1: PRInt32
    1: nsXULTreeBuilder::CompareResults(nsIXULTemplateResult* aLeft, nsIXULTemplateResult* aRight)
    1: {
 2435:     // this is an extra check done for RDF queries such that results appear in
 2435:     // the order they appear in their containing Seq
 2435:     if (mSortDirection == eDirection_Natural && mDB) {
    1:         // If the sort order is ``natural'', then see if the container
    1:         // is an RDF sequence. If so, we'll try to use the ordinal
    1:         // properties to determine order.
    1:         //
    1:         // XXX the problem with this is, it doesn't always get the
    1:         // *real* container; e.g.,
    1:         //
    1:         //  <treerow uri="?uri" />
    1:         //
    1:         //  <triple subject="?uri"
    1:         //          predicate="http://home.netscape.com/NC-rdf#subheadings"
    1:         //          object="?subheadings" />
    1:         //
    1:         //  <member container="?subheadings" child="?subheading" />
    1:         //
    1:         // In this case mRefVariable is bound to ?uri, not
    1:         // ?subheadings. (The ``container'' in the template sense !=
    1:         // container in the RDF sense.)
    1: 
    1:         nsCOMPtr<nsISupports> ref;
    1:         nsresult rv = aLeft->GetBindingObjectFor(mRefVariable, getter_AddRefs(ref));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsCOMPtr<nsIRDFResource> container = do_QueryInterface(ref);
    1:         if (container) {
    1:             PRBool isSequence = PR_FALSE;
    1:             gRDFContainerUtils->IsSeq(mDB, container, &isSequence);
    1:             if (isSequence) {
    1:                 // Determine the indices of the left and right elements
    1:                 // in the container.
    1:                 PRInt32 lindex = 0, rindex = 0;
    1: 
    1:                 nsCOMPtr<nsIRDFResource> leftitem;
    1:                 aLeft->GetResource(getter_AddRefs(leftitem));
    1:                 if (leftitem) {
    1:                     gRDFContainerUtils->IndexOf(mDB, container, leftitem, &lindex);
    1:                     if (lindex < 0)
    1:                         return 0;
    1:                 }
    1: 
    1:                 nsCOMPtr<nsIRDFResource> rightitem;
    1:                 aRight->GetResource(getter_AddRefs(rightitem));
    1:                 if (rightitem) {
    1:                     gRDFContainerUtils->IndexOf(mDB, container, rightitem, &rindex);
    1:                     if (rindex < 0)
    1:                         return 0;
    1:                 }
    1: 
    1:                 return lindex - rindex;
    1:             }
    1:         }
    1:     }
    1: 
    1:     PRInt32 sortorder;
    1:     mQueryProcessor->CompareResults(aLeft, aRight, mSortVariable, &sortorder);
    1: 
    1:     if (sortorder)
    1:         sortorder = sortorder * mSortDirection;
    1:     return sortorder;
    1: }
    1: 
    1: nsresult
    1: nsXULTreeBuilder::SortSubtree(nsTreeRows::Subtree* aSubtree)
    1: {
    1:     NS_QuickSort(mRows.GetRowsFor(aSubtree),
    1:                  aSubtree->Count(),
    1:                  sizeof(nsTreeRows::Row),
    1:                  Compare,
    1:                  this);
    1: 
    1:     for (PRInt32 i = aSubtree->Count() - 1; i >= 0; --i) {
    1:         nsTreeRows::Subtree* child = (*aSubtree)[i].mSubtree;
    1:         if (child)
    1:             SortSubtree(child);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: /* boolean canDrop (in long index, in long orientation); */
    1: NS_IMETHODIMP
29545: nsXULTreeBuilder::CanDrop(PRInt32 index, PRInt32 orientation,
29545:                           nsIDOMDataTransfer* dataTransfer, PRBool *_retval)
    1: {
    1:     *_retval = PR_FALSE;
    1:     if (mObservers) {
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer) {
29545:                 observer->CanDrop(index, orientation, dataTransfer, _retval);
    1:                 if (*_retval)
    1:                     break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
29545: nsXULTreeBuilder::Drop(PRInt32 row, PRInt32 orient, nsIDOMDataTransfer* dataTransfer)
    1: {
    1:     if (mObservers) {
    1:         PRUint32 count;
    1:         mObservers->Count(&count);
    1:         for (PRUint32 i = 0; i < count; ++i) {
    1:             nsCOMPtr<nsIXULTreeBuilderObserver> observer = do_QueryElementAt(mObservers, i);
    1:             if (observer) {
    1:                 PRBool canDrop = PR_FALSE;
29545:                 observer->CanDrop(row, orient, dataTransfer, &canDrop);
    1:                 if (canDrop)
29545:                     observer->OnDrop(row, orient, dataTransfer);
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULTreeBuilder::IsSorted(PRBool *_retval)
    1: {
    1:   *_retval = (mSortVariable != nsnull);
    1:   return NS_OK;
    1: }
    1: 
