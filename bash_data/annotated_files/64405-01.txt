16300: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
16300: /* vim:set ts=2 sw=2 sts=2 et cindent: */
16300: /* ***** BEGIN LICENSE BLOCK *****
39436:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
16300:  *
16300:  * The contents of this file are subject to the Mozilla Public License Version
16300:  * 1.1 (the "License"); you may not use this file except in compliance with
16300:  * the License. You may obtain a copy of the License at
16300:  * http://www.mozilla.org/MPL/
16300:  *
16300:  * Software distributed under the License is distributed on an "AS IS" basis,
16300:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
16300:  * for the specific language governing rights and limitations under the
16300:  * License.
16300:  *
16300:  * The Original Code is Mozilla code.
16300:  *
16300:  * The Initial Developer of the Original Code is the Mozilla Corporation.
16300:  * Portions created by the Initial Developer are Copyright (C) 2007
16300:  * the Initial Developer. All Rights Reserved.
16300:  *
16300:  * Contributor(s):
16300:  *  Chris Double <chris.double@double.co.nz>
40132:  *  Chris Pearce <chris@pearce.org.nz>
16300:  *
16300:  * Alternatively, the contents of this file may be used under the terms of
16300:  * either the GNU General Public License Version 2 or later (the "GPL"), or
16300:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
16300:  * in which case the provisions of the GPL or the LGPL are applicable instead
16300:  * of those above. If you wish to allow use of your version of this file only
16300:  * under the terms of either the GPL or the LGPL, and not to allow others to
16300:  * use your version of this file under the terms of the MPL, indicate your
16300:  * decision by deleting the provisions above and replace them with the notice
16300:  * and other provisions required by the GPL or the LGPL. If you do not delete
16300:  * the provisions above, a recipient may use your version of this file under
16300:  * the terms of any one of the MPL, the GPL or the LGPL.
16300:  *
16300:  * ***** END LICENSE BLOCK ***** */
16300: /*
41387: Each video element based on nsBuiltinDecoder has at least one thread
41387: dedicated to decoding video.
28267: 
41387: This thread (called the state machine thread owns the resources for
41387: downloading and reading the media file. nsDecoderStateMachine is the
41387: class that needs to be implemented and it gets run on the state
41387: machine thread.
28267: 
41387: The state machine thread has one event that is dispatched to it (the
41387: implementation of nsDecoderStateMachine) and that event runs for the
41387: lifetime of the playback of the resource. State shared between threads
41387: is synchronised with the main thread via a monitor held by the
41387: nsBuiltinDecoder object.
28267: 
41387: The state machine thread event consist of a Run method which is an
41387: infinite loop that performs the decoding operation and checks the
41387: state that the state machine is in and processes operations on that
41387: state.
20627: 
20627: The Main thread controls the decode state machine by setting the value
41387: of a mPlayState variable and notifying on the monitor based on the
41387: high level player actions required (Seek, Pause, Play, etc).
20627: 
20627: The player states are the states requested by the client through the
20627: DOM API.  They represent the desired state of the player, while the
20627: decoder's state represents the actual state of the decoder.
20627: 
20627: The high level state of the player is maintained via a PlayState value. 
20627: It can have the following states:
20627: 
20627: START
20627:   The decoder has been initialized but has no resource loaded.
20627: PAUSED
20627:   A request via the API has been received to pause playback.
20627: LOADING
20627:   A request via the API has been received to load a resource.
20627: PLAYING
20627:   A request via the API has been received to start playback.
20627: SEEKING
20627:   A request via the API has been received to start seeking.
20627: COMPLETED
20627:   Playback has completed.
20627: SHUTDOWN
20627:   The decoder is about to be destroyed.
20627: 
20627: State transition occurs when the Media Element calls the Play, Seek,
41387: etc methods on the nsBuiltinDecoder object. When the transition
41387: occurs nsBuiltinDecoder then calls the methods on the decoder state
41387: machine object to cause it to behave appropriate to the play state.
20627: 
41954: An implementation of the nsDecoderStateMachine class is the event
41954: that gets dispatched to the state machine thread. It has the following states:
41954: 
41954: DECODING_METADATA
41954:   The media headers are being loaded, and things like framerate, etc are
41954:   being determined, and the first frame of audio/video data is being decoded.
41954: DECODING
41954:   The decode and audio threads are started and video frames displayed at
41954:   the required time. 
41954: SEEKING
41954:   A seek operation is in progress.
41954: BUFFERING
41954:   Decoding is paused while data is buffered for smooth playback.
41954: COMPLETED
41954:   The resource has completed decoding, but not finished playback. 
41954: SHUTDOWN
41954:   The decoder object is about to be destroyed.
41954: 
41954: The following result in state transitions.
41954: 
41954: Shutdown()
41954:   Clean up any resources the nsDecoderStateMachine owns.
63623: Play()
63623:   Start decoding and playback of media data.
41954: Buffer
41954:   This is not user initiated. It occurs when the
41954:   available data in the stream drops below a certain point.
41954: Complete
41954:   This is not user initiated. It occurs when the
41954:   stream is completely decoded.
60727: Seek(double)
41954:   Seek to the time position given in the resource.
41954: 
41954: A state transition diagram:
41954: 
41954: DECODING_METADATA
41954:   |      |
41954:   v      | Shutdown()
41954:   |      |
41954:   v      -->-------------------->--------------------------|
41954:   |---------------->----->------------------------|        v
41954: DECODING             |          |  |              |        |
41954:   ^                  v Seek(t)  |  |              |        |
63623:   |         Play()   |          v  |              |        |
41954:   ^-----------<----SEEKING      |  v Complete     v        v
41954:   |                  |          |  |              |        |
41954:   |                  |          |  COMPLETED    SHUTDOWN-<-|
41954:   ^                  ^          |  |Shutdown()    |
41954:   |                  |          |  >-------->-----^
63623:   |          Play()  |Seek(t)   |Buffer()         |
41954:   -----------<--------<-------BUFFERING           |
41954:                                 |                 ^
41954:                                 v Shutdown()      |
41954:                                 |                 |
41954:                                 ------------>-----|
41954: 
41954: The following represents the states that the nsBuiltinDecoder object
41954: can be in, and the valid states the nsDecoderStateMachine can be in at that
41954: time:
41954: 
41954: player LOADING   decoder DECODING_METADATA
41954: player PLAYING   decoder DECODING, BUFFERING, SEEKING, COMPLETED
41954: player PAUSED    decoder DECODING, BUFFERING, SEEKING, COMPLETED
41954: player SEEKING   decoder SEEKING
41954: player COMPLETED decoder SHUTDOWN
41954: player SHUTDOWN  decoder SHUTDOWN
41954: 
41387: The general sequence of events is:
20627: 
20627: 1) The video element calls Load on nsMediaDecoder. This creates the
41387:    state machine thread and starts the channel for downloading the
41387:    file. It instantiates and starts the nsDecoderStateMachine. The
41387:    high level LOADING state is entered, which results in the decode
41387:    state machine to start decoding metadata. These are the headers
41387:    that give the video size, framerate, etc.  It returns immediately
41387:    to the calling video element.
16300: 
41387: 2) When the metadata has been loaded by the decode thread it will call
41387:    a method on the video element object to inform it that this step is
41387:    done, so it can do the things required by the video specification
41387:    at this stage. The decoder then continues to decode the first frame
41387:    of data.
16300: 
41387: 3) When the first frame of data has been successfully decoded it calls
41387:    a method on the video element object to inform it that this step
41387:    has been done, once again so it can do the required things by the
41387:    video specification at this stage.
16300: 
20627:    This results in the high level state changing to PLAYING or PAUSED
20627:    depending on any user action that may have occurred.
16300: 
41387:    The decode thread plays audio and video, if the correct frame time
41387:    comes around and the decoder play state is PLAYING.
16300:    
41387: a/v synchronisation is handled by the nsDecoderStateMachine implementation.
16300: 
41387: The Shutdown method on nsBuiltinDecoder can spin the event loop as it
41387: waits for threads to complete. Spinning the event loop is a bad thing
41387: to happen during certain times like destruction of the media
41387: element. To work around this the Shutdown method does nothing but
41387: queue an event to the main thread to perform the actual Shutdown. This
41387: way the shutdown can occur at a safe time.
16300: 
41387: This means the owning object of a nsBuiltinDecoder object *MUST* call
41954: Shutdown when destroying the nsBuiltinDecoder object.  
16300: */
41387: #if !defined(nsBuiltinDecoder_h_)
41387: #define nsBuiltinDecoder_h_
16300: 
33372: #include "nsMediaDecoder.h"
33372: 
16300: #include "nsISupports.h"
16300: #include "nsCOMPtr.h"
16300: #include "nsIThread.h"
16300: #include "nsIChannel.h"
16300: #include "nsIObserver.h"
16300: #include "nsIFrame.h"
16300: #include "nsAutoPtr.h"
16300: #include "nsSize.h"
16300: #include "prlog.h"
16300: #include "gfxContext.h"
16300: #include "gfxRect.h"
40132: #include "nsMediaStream.h"
40132: #include "nsMediaDecoder.h"
41387: #include "nsHTMLMediaElement.h"
40132: #include "mozilla/Monitor.h"
40132: 
41387: class nsAudioStream;
16300: 
41387: static inline PRBool IsCurrentThread(nsIThread* aThread) {
41387:   return NS_GetCurrentThread() == aThread;
41387: }
16300: 
41387: // Decoder backends must implement this class to perform the codec
41387: // specific parts of decoding the video/audio format.
41387: class nsDecoderStateMachine : public nsRunnable
16300: {
41387: public:
41954:   // Enumeration for the valid decoding states
41954:   enum State {
41954:     DECODER_STATE_DECODING_METADATA,
41954:     DECODER_STATE_DECODING,
41954:     DECODER_STATE_SEEKING,
41954:     DECODER_STATE_BUFFERING,
41954:     DECODER_STATE_COMPLETED,
41954:     DECODER_STATE_SHUTDOWN
41954:   };
41954: 
41387:   // Initializes the state machine, returns NS_OK on success, or
41387:   // NS_ERROR_FAILURE on failure.
54993:   virtual nsresult Init(nsDecoderStateMachine* aCloneDonor) = 0;
16300: 
41954:   // Return the current decode state. The decoder monitor must be
41954:   // obtained before calling this.
41954:   virtual State GetState() = 0;
41954: 
41387:   // Set the audio volume. The decoder monitor must be obtained before
41387:   // calling this.
60727:   virtual void SetVolume(double aVolume) = 0;
41387: 
41387:   virtual void Shutdown() = 0;
41387: 
41387:   // Called from the main thread to get the duration. The decoder monitor
41387:   // must be obtained before calling this. It is in units of milliseconds.
41387:   virtual PRInt64 GetDuration() = 0;
41387: 
41387:   // Called from the main thread to set the duration of the media resource
43340:   // if it is able to be obtained via HTTP headers. Called from the 
43340:   // state machine thread to set the duration if it is obtained from the
43340:   // media metadata. The decoder monitor must be obtained before calling this.
41387:   virtual void SetDuration(PRInt64 aDuration) = 0;
41387: 
41387:   // Functions used by assertions to ensure we're calling things
41387:   // on the appropriate threads.
63622:   virtual PRBool OnDecodeThread() const = 0;
41387: 
41387:   virtual nsHTMLMediaElement::NextFrameStatus GetNextFrameStatus() = 0;
41387: 
41387:   // Cause state transitions. These methods obtain the decoder monitor
41387:   // to synchronise the change of state, and to notify other threads
41387:   // that the state has changed.
63623:   virtual void Play() = 0;
41387: 
41387:   // Seeks to aTime in seconds
60727:   virtual void Seek(double aTime) = 0;
41387: 
41387:   // Returns the current playback position in seconds.
41387:   // Called from the main thread to get the current frame time. The decoder
41387:   // monitor must be obtained before calling this.
63622:   virtual double GetCurrentTime() const = 0;
41387: 
41387:   // Clear the flag indicating that a playback position change event
41387:   // is currently queued. This is called from the main thread and must
41387:   // be called with the decode monitor held.
41387:   virtual void ClearPositionChangeFlag() = 0;
41387: 
41387:   // Called from the main thread to set whether the media resource can
41387:   // be seeked. The decoder monitor must be obtained before calling this.
41387:   virtual void SetSeekable(PRBool aSeekable) = 0;
41954: 
41954:   // Update the playback position. This can result in a timeupdate event
41954:   // and an invalidate of the frame being dispatched asynchronously if
41954:   // there is no such event currently queued.
41954:   // Only called on the decoder thread. Must be called with
41954:   // the decode monitor held.
41954:   virtual void UpdatePlaybackPosition(PRInt64 aTime) = 0;
48104: 
51394:   virtual nsresult GetBuffered(nsTimeRanges* aBuffered) = 0;
48902: 
53765:   virtual void NotifyDataArrived(const char* aBuffer, PRUint32 aLength, PRUint32 aOffset) = 0;
53765: 
48104:   // Causes the state machine to switch to buffering state, and to
48104:   // immediately stop playback and buffer downloaded data. Must be called
48104:   // with the decode monitor held. Called on the state machine thread and
48104:   // the main thread.
48104:   virtual void StartBuffering() = 0;
41387: };
41387: 
41387: class nsBuiltinDecoder : public nsMediaDecoder
41387: {
16300:   // ISupports
16300:   NS_DECL_ISUPPORTS
16300: 
16300:   // nsIObserver
16300:   NS_DECL_NSIOBSERVER
16300: 
16300:  public:
41954:   typedef mozilla::Monitor Monitor;
41954: 
20627:   // Enumeration for the valid play states (see mPlayState)
20627:   enum PlayState {
20627:     PLAY_STATE_START,
20627:     PLAY_STATE_LOADING,
20627:     PLAY_STATE_PAUSED,
20627:     PLAY_STATE_PLAYING,
20627:     PLAY_STATE_SEEKING,
20627:     PLAY_STATE_ENDED,
20627:     PLAY_STATE_SHUTDOWN
20627:   };
20627: 
41387:   nsBuiltinDecoder();
41387:   ~nsBuiltinDecoder();
32901:   
23851:   virtual PRBool Init(nsHTMLMediaElement* aElement);
20627: 
20627:   // This method must be called by the owning object before that
20627:   // object disposes of this decoder object.
21079:   virtual void Shutdown();
16300:   
60727:   virtual double GetCurrentTime();
16300: 
32900:   virtual nsresult Load(nsMediaStream* aStream,
54993:                         nsIStreamListener** aListener,
54993:                         nsMediaDecoder* aCloneDonor);
16300: 
41387:   virtual nsDecoderStateMachine* CreateStateMachine() = 0;
41387: 
16300:   // Start playback of a video. 'Load' must have previously been
16300:   // called.
21079:   virtual nsresult Play();
16300: 
16300:   // Seek to the time position in (seconds) from the start of the video.
60727:   virtual nsresult Seek(double aTime);
16300: 
21079:   virtual nsresult PlaybackRateChanged();
16300: 
21079:   virtual void Pause();
60727:   virtual void SetVolume(double aVolume);
60727:   virtual double GetDuration();
16300: 
32898:   virtual nsMediaStream* GetCurrentStream();
26836:   virtual already_AddRefed<nsIPrincipal> GetCurrentPrincipal();
16300: 
26836:   virtual void NotifySuspendedStatusChanged();
26836:   virtual void NotifyBytesDownloaded();
24721:   virtual void NotifyDownloadEnded(nsresult aStatus);
40132:   // Called by the decode thread to keep track of the number of bytes read
40132:   // from the resource.
26836:   void NotifyBytesConsumed(PRInt64 aBytes);
16300: 
20627:   // Called when the video file has completed downloading.
20627:   // Call on the main thread only.
20627:   void ResourceLoaded();
20627: 
21394:   // Called if the media file encounters a network error.
21394:   // Call on the main thread only.
21756:   virtual void NetworkError();
21394: 
20627:   // Call from any thread safely. Return PR_TRUE if we are currently
20627:   // seeking in the media resource.
20627:   virtual PRBool IsSeeking() const;
20627: 
22783:   // Return PR_TRUE if the decoder has reached the end of playback.
22783:   // Call on the main thread only.
22783:   virtual PRBool IsEnded() const;
22783: 
24775:   // Set the duration of the media resource in units of milliseconds.
24775:   // This is called via a channel listener if it can pick up the duration
24775:   // from a content header. Must be called from the main thread only.
24775:   virtual void SetDuration(PRInt64 aDuration);
24775: 
21542:   // Set a flag indicating whether seeking is supported
21542:   virtual void SetSeekable(PRBool aSeekable);
21542: 
21542:   // Return PR_TRUE if seeking is supported.
21542:   virtual PRBool GetSeekable();
21542: 
24721:   virtual Statistics GetStatistics();
24721: 
24020:   // Suspend any media downloads that are in progress. Called by the
24020:   // media element when it is sent to the bfcache. Call on the main
24020:   // thread only.
24020:   virtual void Suspend();
24020: 
24020:   // Resume any media downloads that have been suspended. Called by the
24020:   // media element when it is restored from the bfcache. Call on the
24020:   // main thread only.
48104:   virtual void Resume(PRBool aForceBuffering);
24020: 
27217:   // Tells our nsMediaStream to put all loads in the background.
27217:   virtual void MoveLoadsToBackground();
27217: 
40132:   // Stop the state machine thread and drop references to the thread and
40132:   // state machine.
28622:   void Stop();
28622: 
54997:   void AudioAvailable(float* aFrameBuffer, PRUint32 aFrameBufferLength, float aTime);
51477: 
40132:   // Called by the state machine to notify the decoder that the duration
40132:   // has changed.
40132:   void DurationChanged();
40132: 
41387:   PRBool OnStateMachineThread() {
41387:     return IsCurrentThread(mStateMachineThread);
41387:   }
41387: 
63622:   PRBool OnDecodeThread() const {
41387:     return mDecoderStateMachine->OnDecodeThread();
41387:   }
19675: 
20627:   // Returns the monitor for other threads to synchronise access to
21756:   // state.
41954:   Monitor& GetMonitor() { 
20627:     return mMonitor; 
20627:   }
19675: 
48902:   // Constructs the time ranges representing what segments of the media
48902:   // are buffered and playable.
51394:   virtual nsresult GetBuffered(nsTimeRanges* aBuffered) {
64405:     if (mDecoderStateMachine) {
48902:       return mDecoderStateMachine->GetBuffered(aBuffered);
48902:     }
64405:     return NS_ERROR_FAILURE;
64405:   }
48902: 
53765:   virtual void NotifyDataArrived(const char* aBuffer, PRUint32 aLength, PRUint32 aOffset) {
53765:     return mDecoderStateMachine->NotifyDataArrived(aBuffer, aLength, aOffset);
53765:   }
53765: 
41387:  public:
21756:   // Return the current state. Can be called on any thread. If called from
21756:   // a non-main thread, the decoder monitor must be held.
40132:   PlayState GetState() {
20627:     return mPlayState;
20627:   }
16300: 
23763:   // Stop updating the bytes downloaded for progress notifications. Called
23763:   // when seeking to prevent wild changes to the progress notification.
23763:   // Must be called with the decoder monitor held.
23763:   void StopProgressUpdates();
23763: 
23763:   // Allow updating the bytes downloaded for progress notifications. Must
23763:   // be called with the decoder monitor held.
23763:   void StartProgressUpdates();
23763: 
26836:   // Something has changed that could affect the computed playback rate,
26836:   // so recompute it. The monitor must be held.
26836:   void UpdatePlaybackRate();
26836: 
26836:   // The actual playback rate computation. The monitor must be held.
26836:   double ComputePlaybackRate(PRPackedBool* aReliable);
26836: 
41954:   // Make the decoder state machine update the playback position. Called by
41954:   // the reader on the decoder thread (Assertions for this checked by 
41954:   // mDecoderStateMachine). This must be called with the decode monitor
41954:   // held.
41954:   void UpdatePlaybackPosition(PRInt64 aTime)
41954:   {
41954:     mDecoderStateMachine->UpdatePlaybackPosition(aTime);
41954:   }
41954: 
16300:   /****** 
16300:    * The following methods must only be called on the main
16300:    * thread.
16300:    ******/
16300: 
21756:   // Change to a new play state. This updates the mState variable and
21756:   // notifies any thread blocking on this object's monitor of the
21756:   // change. Call on the main thread only.
21756:   void ChangeState(PlayState aState);
21756: 
41954:   // Called when the metadata from the media file has been read.
16300:   // Call on the main thread only.
51477:   void MetadataLoaded(PRUint32 aChannels,
51477:                       PRUint32 aRate,
51477:                       PRUint32 aFrameBufferLength);
16300: 
16300:   // Called when the first frame has been loaded.
16300:   // Call on the main thread only.
16300:   void FirstFrameLoaded();
16300: 
16300:   // Called when the video has completed playing.
16300:   // Call on the main thread only.
20627:   void PlaybackEnded();
16300: 
20627:   // Seeking has stopped. Inform the element on the main
20627:   // thread.
20627:   void SeekingStopped();
20627: 
28857:   // Seeking has stopped at the end of the resource. Inform the element on the main
28857:   // thread.
28857:   void SeekingStoppedAtEnd();
28857: 
20627:   // Seeking has started. Inform the element on the main
20627:   // thread.
20627:   void SeekingStarted();
20627: 
20776:   // Called when the backend has changed the current playback
20776:   // position. It dispatches a timeupdate event and invalidates the frame.
20776:   // This must be called on the main thread only.
20776:   void PlaybackPositionChanged();
20776: 
39441:   // Calls mElement->UpdateReadyStateForData, telling it which state we have
39441:   // entered.  Main thread only.
39441:   void NextFrameUnavailableBuffering();
39441:   void NextFrameAvailable();
39441:   void NextFrameUnavailable();
39441: 
24919:   // Calls mElement->UpdateReadyStateForData, telling it whether we have
24919:   // data for the next frame and if we're buffering. Main thread only.
24919:   void UpdateReadyStateForData();
24919: 
26836:   // Find the end of the cached data starting at the current decoder
26836:   // position.
26836:   PRInt64 GetDownloadPosition();
26836: 
41391:   // Updates the approximate byte offset which playback has reached. This is
41391:   // used to calculate the readyState transitions.
41391:   void UpdatePlaybackOffset(PRInt64 aOffset);
41391: 
41954:   // Provide access to the state machine object
41954:   nsDecoderStateMachine* GetStateMachine() { return mDecoderStateMachine; }
41954: 
41954:   // Return the current decode state. The decoder monitor must be
41954:   // obtained before calling this.
41954:   nsDecoderStateMachine::State GetDecodeState() { return mDecoderStateMachine->GetState(); }
41954: 
41387: public:
32934:   // Notifies the element that decoding has failed.
32934:   void DecodeError();
32934: 
51397:   // Ensures the state machine thread is running, starting a new one
51397:   // if necessary.
51397:   nsresult StartStateMachineThread();
51397: 
16300:   /******
24721:    * The following members should be accessed with the decoder lock held.
16300:    ******/
24721: 
24721:   // Current decoding position in the stream. This is where the decoder
26836:   // is up to consuming the stream. This is not adjusted during decoder
26836:   // seek operations, but it's updated at the end when we start playing
26836:   // back again.
24721:   PRInt64 mDecoderPosition;
24721:   // Current playback position in the stream. This is (approximately)
26836:   // where we're up to playing back the stream. This is not adjusted
26836:   // during decoder seek operations, but it's updated at the end when we
26836:   // start playing back again.
24721:   PRInt64 mPlaybackPosition;
24721:   // Data needed to estimate playback data rate. The timeline used for
24721:   // this estimate is "decode time" (where the "current time" is the
24721:   // time of the last decoded video frame).
26836:   nsChannelStatistics mPlaybackStatistics;
16300: 
40132:   // Thread to manage playback state machine.
40132:   nsCOMPtr<nsIThread> mStateMachineThread;
16300: 
20776:   // The current playback position of the media resource in units of
20776:   // seconds. This is updated approximately at the framerate of the
20776:   // video (if it is a video) or the callback period of the audio.
20776:   // It is read and written from the main thread only.
60727:   double mCurrentTime;
20776: 
20627:   // Volume that playback should start at.  0.0 = muted. 1.0 = full
40132:   // volume.  Readable/Writeable from the main thread.
60727:   double mInitialVolume;
16300: 
20627:   // Position to seek to when the seek notification is received by the
40132:   // decode thread. Written by the main thread and read via the
40132:   // decode thread. Synchronised using mMonitor. If the
20627:   // value is negative then no seek has been requested. When a seek is
20627:   // started this is reset to negative.
60727:   double mRequestedSeekTime;
19690: 
21542:   // Duration of the media resource. Set to -1 if unknown.
41954:   // Set when the metadata is loaded. Accessed on the main thread
21542:   // only.
21542:   PRInt64 mDuration;
21542: 
21542:   // True if the media resource is seekable (server supports byte range
21542:   // requests).
21542:   PRPackedBool mSeekable;
21542: 
16300:   /******
16300:    * The following member variables can be accessed from any thread.
16300:    ******/
16300: 
40132:   // The state machine object for handling the decoding. It is safe to
40132:   // call methods of this object from other threads. Its internal data
40132:   // is synchronised on a monitor. The lifetime of this object is
40132:   // after mPlayState is LOADING and before mPlayState is SHUTDOWN. It
40132:   // is safe to access it during this period.
41387:   nsCOMPtr<nsDecoderStateMachine> mDecoderStateMachine;
16300: 
40132:   // Stream of media data.
40132:   nsAutoPtr<nsMediaStream> mStream;
16300: 
20627:   // Monitor for detecting when the video play state changes. A call
20627:   // to Wait on this monitor will block the thread until the next
20627:   // state change.
41954:   Monitor mMonitor;
16300: 
20627:   // Set to one of the valid play states. It is protected by the
20627:   // monitor mMonitor. This monitor must be acquired when reading or
20627:   // writing the state. Any change to the state on the main thread
20627:   // must call NotifyAll on the monitor so the decode thread can wake up.
20627:   PlayState mPlayState;
16300: 
21756:   // The state to change to after a seek or load operation. It must only
21756:   // be changed from the main thread. The decoder monitor must be acquired
21756:   // when writing to the state, or when reading from a non-main thread.
21756:   // Any change to the state must call NotifyAll on the monitor.
20627:   PlayState mNextState;	
23763: 
24721:   // True when we have fully loaded the resource and reported that
24721:   // to the element (i.e. reached NETWORK_LOADED state).
24721:   // Accessed on the main thread only.
23763:   PRPackedBool mResourceLoaded;
23763: 
23763:   // True when seeking or otherwise moving the play position around in
23763:   // such a manner that progress event data is inaccurate. This is set
24721:   // during seek and duration operations to prevent the progress indicator
23763:   // from jumping around. Read/Write from any thread. Must have decode monitor
23763:   // locked before accessing.
23763:   PRPackedBool mIgnoreProgressData;
16300: };
16300: 
16300: #endif
