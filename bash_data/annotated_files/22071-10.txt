17092: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
17092:  *
17092:  * ***** BEGIN LICENSE BLOCK *****
17092:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
17092:  *
17092:  * The contents of this file are subject to the Mozilla Public License Version
17092:  * 1.1 (the "License"); you may not use this file except in compliance with
17092:  * the License. You may obtain a copy of the License at
17092:  * http://www.mozilla.org/MPL/
17092:  *
17092:  * Software distributed under the License is distributed on an "AS IS" basis,
17092:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
17092:  * for the specific language governing rights and limitations under the
17092:  * License.
17092:  *
17092:  * The Original Code is mozilla.org code.
17092:  *
17092:  * The Initial Developer of the Original Code is
17092:  *   Mozilla Foundation.
17092:  * Portions created by the Initial Developer are Copyright (C) 2008
17092:  * the Initial Developer. All Rights Reserved.
17092:  *
17092:  * Contributor(s):
17092:  *   Jason Orendorff <jorendorff@mozilla.com>
17092:  *
17092:  * Alternatively, the contents of this file may be used under the terms of
17092:  * either of the GNU General Public License Version 2 or later (the "GPL"),
17092:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
17092:  * in which case the provisions of the GPL or the LGPL are applicable instead
17092:  * of those above. If you wish to allow use of your version of this file only
17092:  * under the terms of either the GPL or the LGPL, and not to allow others to
17092:  * use your version of this file under the terms of the MPL, indicate your
17092:  * decision by deleting the provisions above and replace them with the notice
17092:  * and other provisions required by the GPL or the LGPL. If you do not delete
17092:  * the provisions above, a recipient may use your version of this file under
17092:  * the terms of any one of the MPL, the GPL or the LGPL.
17092:  *
17092:  * ***** END LICENSE BLOCK ***** */
17092: 
17092: #ifndef xpcquickstubs_h___
17092: #define xpcquickstubs_h___
17092: 
17092: /* xpcquickstubs.h - Support functions used only by quick stubs. */
17092: 
17092: class XPCCallContext;
17092: 
17092: #define XPC_QS_NULL_INDEX  ((size_t) -1)
17092: 
17092: struct xpc_qsPropertySpec {
17092:     const char *name;
17092:     JSPropertyOp getter;
17092:     JSPropertyOp setter;
17092: };
17092: 
17092: struct xpc_qsFunctionSpec {
17092:     const char *name;
17092:     JSFastNative native;
17092:     uintN arity;
17092: };
17092: 
17092: /** A table mapping interfaces to quick stubs. */
17092: struct xpc_qsHashEntry {
17092:     nsID iid;
17092:     const xpc_qsPropertySpec *properties;
17092:     const xpc_qsFunctionSpec *functions;
17092:     // These last two fields index to other entries in the same table.
17092:     // XPC_QS_NULL_ENTRY indicates there are no more entries in the chain.
17092:     size_t parentInterface;
17092:     size_t chain;
17092: };
17092: 
17092: JSBool
17092: xpc_qsDefineQuickStubs(JSContext *cx, JSObject *proto, uintN extraFlags,
17092:                        PRUint32 ifacec, const nsIID **interfaces,
17092:                        PRUint32 tableSize, const xpc_qsHashEntry *table);
17092: 
17092: /** Raise an exception on @a cx and return JS_FALSE. */
17092: JSBool
17092: xpc_qsThrow(JSContext *cx, nsresult rv);
17092: 
21218: /**
21218:  * Fail after an XPCOM getter or setter returned rv.
21218:  *
21218:  * NOTE: Here @a obj must be the JSObject whose private data field points to an
21218:  * XPCWrappedNative, not merely an object that has an XPCWrappedNative
21218:  * somewhere along the prototype chain!  The same applies to @a obj in
21218:  * xpc_qsThrowBadSetterValue and <code>vp[1]</code> in xpc_qsThrowMethodFailed
21218:  * and xpc_qsThrowBadArg.
21218:  *
21218:  * This is one reason the UnwrapThis functions below have an out parameter that
21218:  * receives the wrapper JSObject.  (The other reason is to help the caller keep
21218:  * that JSObject GC-reachable.)
21218:  */
17092: JSBool
17092: xpc_qsThrowGetterSetterFailed(JSContext *cx, nsresult rv,
21218:                               JSObject *obj, jsval memberId);
17092: 
21218: /**
21218:  * Fail after an XPCOM method returned rv.
21218:  *
21218:  * See NOTE at xpc_qsThrowGetterSetterFailed.
21218:  */
17092: JSBool
21218: xpc_qsThrowMethodFailed(JSContext *cx, nsresult rv, jsval *vp);
17092: 
17092: JSBool
17092: xpc_qsThrowMethodFailedWithCcx(XPCCallContext &ccx, nsresult rv);
17092: 
21218: /**
21218:  * Fail after converting a method argument fails.
21218:  *
21218:  * See NOTE at xpc_qsThrowGetterSetterFailed.
21218:  */
17092: void
21218: xpc_qsThrowBadArg(JSContext *cx, nsresult rv, jsval *vp, uintN paramnum);
17092: 
17092: void
17092: xpc_qsThrowBadArgWithCcx(XPCCallContext &ccx, nsresult rv, uintN paramnum);
17092: 
21218: /**
21218:  * Fail after converting a setter argument fails.
21218:  *
21218:  * See NOTE at xpc_qsThrowGetterSetterFailed.
21218:  */
17092: void
21218: xpc_qsThrowBadSetterValue(JSContext *cx, nsresult rv, JSObject *obj,
21218:                           jsval propId);
17092: 
17092: 
17092: /* Functions for converting values between COM and JS. */
17092: 
17092: inline JSBool
17092: xpc_qsInt32ToJsval(JSContext *cx, PRInt32 i, jsval *rv)
17092: {
17092:     if(INT_FITS_IN_JSVAL(i))
17092:     {
17092:         *rv = INT_TO_JSVAL(i);
17092:         return JS_TRUE;
17092:     }
17092:     return JS_NewDoubleValue(cx, i, rv);
17092: }
17092: 
17092: inline JSBool
17092: xpc_qsUint32ToJsval(JSContext *cx, PRUint32 u, jsval *rv)
17092: {
17092:     if(u <= JSVAL_INT_MAX)
17092:     {
17092:         *rv = INT_TO_JSVAL(u);
17092:         return JS_TRUE;
17092:     }
17092:     return JS_NewDoubleValue(cx, u, rv);
17092: }
17092: 
17092: #ifdef HAVE_LONG_LONG
17092: 
17092: #define INT64_TO_DOUBLE(i)      ((jsdouble) (i))
17092: // Win32 can't handle uint64 to double conversion
17092: #define UINT64_TO_DOUBLE(u)     ((jsdouble) (int64) (u))
17092: 
17092: #else
17092: 
17092: inline jsdouble
17092: INT64_TO_DOUBLE(const int64 &v)
17092: {
17092:     jsdouble d;
17092:     LL_L2D(d, v);
17092:     return d;
17092: }
17092: 
17092: // if !HAVE_LONG_LONG, then uint64 is a typedef of int64
17092: #define UINT64_TO_DOUBLE INT64_TO_DOUBLE
17092: 
17092: #endif
17092: 
17092: inline JSBool
17092: xpc_qsInt64ToJsval(JSContext *cx, PRInt64 i, jsval *rv)
17092: {
17092:     double d = INT64_TO_DOUBLE(i);
17092:     return JS_NewNumberValue(cx, d, rv);
17092: }
17092: 
17092: inline JSBool
17092: xpc_qsUint64ToJsval(JSContext *cx, PRUint64 u, jsval *rv)
17092: {
17092:     double d = UINT64_TO_DOUBLE(u);
17092:     return JS_NewNumberValue(cx, d, rv);
17092: }
17092: 
17092: 
17092: /* Classes for converting jsvals to string types. */
17092: 
17092: template <class S, class T>
17092: class xpc_qsBasicString
17092: {
17092: public:
17092:     typedef S interface_type;
17092:     typedef T implementation_type;
17092: 
17092:     ~xpc_qsBasicString()
17092:     {
17092:         if (mValid)
17092:             Ptr()->~implementation_type();
17092:     }
17092: 
17092:     JSBool IsValid() { return mValid; }
17092: 
17092:     implementation_type *Ptr()
17092:     {
17092:         return reinterpret_cast<implementation_type *>(mBuf);
17092:     }
17092: 
17092:     operator interface_type &()
17092:     {
17092:         return *Ptr();
17092:     }
17092: 
17092: protected:
17092:     /*
17092:      * Neither field is initialized; that is left to the derived class
17092:      * constructor. However, the destructor destroys the string object
17092:      * stored in mBuf, if mValid is true.
17092:      */
17092:     void *mBuf[JS_HOWMANY(sizeof(implementation_type), sizeof(void *))];
17092:     JSBool mValid;
17092: };
17092: 
17092: /**
17092:  * Class for converting a jsval to DOMString.
17092:  *
17092:  *     xpc_qsDOMString arg0(cx, &argv[0]);
17092:  *     if (!arg0.IsValid())
17092:  *         return JS_FALSE;
17092:  *
17092:  * The second argument to the constructor is an in-out parameter. It must
17092:  * point to a rooted jsval, such as a JSNative argument or return value slot.
17092:  * The value in the jsval on entry is converted to a string. The constructor
17092:  * may overwrite that jsval with a string value, to protect the characters of
17092:  * the string from garbage collection. The caller must leave the jsval alone
17092:  * for the lifetime of the xpc_qsDOMString.
17092:  */
17092: class xpc_qsDOMString : public xpc_qsBasicString<nsAString, nsDependentString>
17092: {
17092: public:
17092:     xpc_qsDOMString(JSContext *cx, jsval *pval);
17092: };
17092: 
17092: /**
17092:  * The same as xpc_qsDOMString, but with slightly different conversion behavior,
17092:  * corresponding to the [astring] magic XPIDL annotation rather than [domstring].
17092:  */
17092: class xpc_qsAString : public xpc_qsBasicString<nsAString, nsDependentString>
17092: {
17092: public:
17092:     xpc_qsAString(JSContext *cx, jsval *pval);
17092: };
17092: 
17092: /**
17092:  * Like xpc_qsDOMString and xpc_qsAString, but for XPIDL native types annotated
17092:  * with [cstring] rather than [domstring] or [astring].
17092:  */
17092: class xpc_qsACString : public xpc_qsBasicString<nsACString, nsCString>
17092: {
17092: public:
17092:     xpc_qsACString(JSContext *cx, jsval *pval);
17092: };
17092: 
21218: struct xpc_qsSelfRef
21218: {
21322:     xpc_qsSelfRef() : ptr(nsnull) {}
21218:     explicit xpc_qsSelfRef(nsISupports *p) : ptr(p) {}
21218:     ~xpc_qsSelfRef() { NS_IF_RELEASE(ptr); }
21218: 
21218:     nsISupports* ptr;
21218: };
21218: 
21218: struct xpc_qsTempRoot
21218: {
21218:   public:
21218:     explicit xpc_qsTempRoot(JSContext *cx)
21218:         : mContext(cx) {
21218:         JS_PUSH_SINGLE_TEMP_ROOT(cx, JSVAL_NULL, &mTvr);
21218:     }
21218: 
21218:     ~xpc_qsTempRoot() {
21218:         JS_POP_TEMP_ROOT(mContext, &mTvr);
21218:     }
21218: 
21218:     jsval * addr() {
21218:         return &mTvr.u.value;
21218:     }
21218: 
21218:   private:
21218:     JSContext *mContext;
21218:     JSTempValueRooter mTvr;
21218: };
21218: 
17092: /**
17092:  * Convert a jsval to char*, returning JS_TRUE on success.
17092:  *
17092:  * @param cx
17092:  *      A context.
17092:  * @param pval
17092:  *     In/out. *pval is the jsval to convert; the function may write to *pval,
17092:  *     using it as a GC root (like xpc_qsDOMString's constructor).
17092:  * @param pstr
17092:  *     Out. On success *pstr receives the converted string or NULL if *pval is
17092:  *     null or undefined. Unicode data is garbled as with JS_GetStringBytes.
17092:  */
17092: JSBool
17092: xpc_qsJsvalToCharStr(JSContext *cx, jsval *pval, char **pstr);
17092: 
17092: JSBool
17092: xpc_qsJsvalToWcharStr(JSContext *cx, jsval *pval, PRUnichar **pstr);
17092: 
17092: 
17092: /** Convert an nsAString to jsval, returning JS_TRUE on success. */
17092: JSBool
17092: xpc_qsStringToJsval(JSContext *cx, const nsAString &str, jsval *rval);
17092: 
17092: JSBool
17092: xpc_qsUnwrapThisImpl(JSContext *cx,
17092:                      JSObject *obj,
17092:                      const nsIID &iid,
17092:                      void **ppThis,
21218:                      nsISupports **ppThisRef,
21218:                      jsval *vp);
17092: 
17092: /**
17092:  * Search @a obj and its prototype chain for an XPCOM object that implements
17092:  * the interface T.
17092:  *
21218:  * If an object implementing T is found, store a reference to the wrapper
21218:  * JSObject in @a *pThisVal, store a pointer to the T in @a *ppThis, and return
17092:  * JS_TRUE. Otherwise, raise an exception on @a cx and return JS_FALSE.
17092:  *
21218:  * @a *pThisRef receives the same pointer as *ppThis if the T was AddRefed.
21218:  * Otherwise it receives null (even on error).
21218:  *
21218:  * This supports split objects and XPConnect tear-offs and it sees through
21218:  * XOWs, XPCNativeWrappers, and SafeJSObjectWrappers.
17092:  *
17092:  * Requires a request on @a cx.
17092:  */
17092: template <class T>
17092: inline JSBool
17092: xpc_qsUnwrapThis(JSContext *cx,
17092:                  JSObject *obj,
17092:                  T **ppThis,
21218:                  nsISupports **pThisRef,
21218:                  jsval *pThisVal)
17092: {
17092:     return xpc_qsUnwrapThisImpl(cx,
17092:                                 obj,
17092:                                 NS_GET_TEMPLATE_IID(T),
17092:                                 reinterpret_cast<void **>(ppThis),
21218:                                 pThisRef,
21218:                                 pThisVal);
17092: }
17092: 
17092: JSBool
17092: xpc_qsUnwrapThisFromCcxImpl(XPCCallContext &ccx,
17092:                             const nsIID &iid,
21218:                             void **ppThis,
21218:                             nsISupports **pThisRef,
21218:                             jsval *vp);
17092: 
17092: /**
17092:  * Alternate implementation of xpc_qsUnwrapThis using information already
17092:  * present in the given XPCCallContext.
17092:  */
17092: template <class T>
17092: inline JSBool
17092: xpc_qsUnwrapThisFromCcx(XPCCallContext &ccx,
21218:                         T **ppThis,
21218:                         nsISupports **pThisRef,
21218:                         jsval *pThisVal)
17092: {
21218:     return xpc_qsUnwrapThisFromCcxImpl(ccx,
21218:                                        NS_GET_TEMPLATE_IID(T),
21218:                                        reinterpret_cast<void **>(ppThis),
21218:                                        pThisRef,
21218:                                        pThisVal);
17092: }
17092: 
17092: nsresult
17092: xpc_qsUnwrapArgImpl(JSContext *cx, jsval v, const nsIID &iid, void **ppArg);
17092: 
17092: /** Convert a jsval to an XPCOM pointer. */
17092: template <class T>
17092: inline nsresult
17092: xpc_qsUnwrapArg(JSContext *cx, jsval v, T **ppArg)
17092: {
17092:     return xpc_qsUnwrapArgImpl(cx, v, NS_GET_TEMPLATE_IID(T),
17092:                                reinterpret_cast<void **>(ppArg));
17092: }
17092: 
17092: /** Convert an XPCOM pointer to jsval. Return JS_TRUE on success. */
17092: JSBool
17092: xpc_qsXPCOMObjectToJsval(XPCCallContext &ccx,
17092:                          nsISupports *p,
22071:                          const nsIID &iid,
17092:                          jsval *rval);
17092: 
17092: /**
17092:  * Convert a variant to jsval. Return JS_TRUE on success.
17092:  *
17092:  * @a paramNum is used in error messages. XPConnect treats the return
17092:  * value as a parameter in this regard.
17092:  */
17092: JSBool
17092: xpc_qsVariantToJsval(XPCCallContext &ccx,
17092:                      nsIVariant *p,
17092:                      uintN paramNum,
17092:                      jsval *rval);
17092: 
17092: /**
17092:  * Use this as the setter for readonly attributes. (The IDL readonly
17092:  * keyword does not map to JSPROP_READONLY. Semantic mismatch.)
17092:  *
17092:  * Always fails, with the same error as setting a property that has
17092:  * JSPROP_GETTER but not JSPROP_SETTER.
17092:  */
17092: JSBool
17092: xpc_qsReadOnlySetter(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
17092: 
17092: #ifdef DEBUG
17092: void
17092: xpc_qsAssertContextOK(JSContext *cx);
17092: 
17092: #define XPC_QS_ASSERT_CONTEXT_OK(cx) xpc_qsAssertContextOK(cx)
17092: #else
17092: #define XPC_QS_ASSERT_CONTEXT_OK(cx) ((void) 0)
17092: #endif
17092: 
17092: #endif /* xpcquickstubs_h___ */
