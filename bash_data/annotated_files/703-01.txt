  1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  1: /* ***** BEGIN LICENSE BLOCK *****
  1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  1:  *
  1:  * The contents of this file are subject to the Mozilla Public License Version
  1:  * 1.1 (the "License"); you may not use this file except in compliance with
  1:  * the License. You may obtain a copy of the License at
  1:  * http://www.mozilla.org/MPL/
  1:  *
  1:  * Software distributed under the License is distributed on an "AS IS" basis,
  1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  1:  * for the specific language governing rights and limitations under the
  1:  * License.
  1:  *
  1:  * The Original Code is mozilla.org code.
  1:  *
  1:  * The Initial Developer of the Original Code is
  1:  * Netscape Communications Corporation.
  1:  * Portions created by the Initial Developer are Copyright (C) 1999
  1:  * the Initial Developer. All Rights Reserved.
  1:  *
  1:  * Contributor(s):
  1:  *
  1:  * Alternatively, the contents of this file may be used under the terms of
  1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
  1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  1:  * in which case the provisions of the GPL or the LGPL are applicable instead
  1:  * of those above. If you wish to allow use of your version of this file only
  1:  * under the terms of either the GPL or the LGPL, and not to allow others to
  1:  * use your version of this file under the terms of the MPL, indicate your
  1:  * decision by deleting the provisions above and replace them with the notice
  1:  * and other provisions required by the GPL or the LGPL. If you do not delete
  1:  * the provisions above, a recipient may use your version of this file under
  1:  * the terms of any one of the MPL, the GPL or the LGPL.
  1:  *
  1:  * ***** END LICENSE BLOCK ***** */
  1: 
  1: #include "nsUnicodeRenderingToolkit.h"
  1: #include "nsUnicodeFontMappingMac.h"
  1: #include "nsUnicodeFallbackCache.h"
  1: #include "nsDrawingSurfaceMac.h"
  1: #include "nsTransform2D.h"
  1: #include "nsFontMetricsMac.h"
  1: #include "nsGraphicState.h"
  1: #include "prprf.h"
  1: #include "nsCarbonHelpers.h"
  1: #include "nsISaveAsCharset.h"
  1: #include "nsIComponentManager.h"
  1: #include "nsUnicharUtils.h"
  1: 
  1: 
  1: #include "nsMacUnicodeFontInfo.h"
  1: #include "nsICharRepresentable.h"
  1: 
  1: #include <FixMath.h>
  1: 
  1: #define STACK_TRESHOLD 1000
  1: 
  1: //#define DISABLE_TEC_FALLBACK
  1: //#define DISABLE_PRECOMPOSEHANGUL_FALLBACK
  1: //#define DISABLE_LATINL_FALLBACK
  1: //#define DISABLE_ATSUI_FALLBACK
  1: //#define DISABLE_TRANSLITERATE_FALLBACK
  1: //#define DISABLE_UPLUS_FALLBACK
  1: 
  1: #define IS_FORMAT_CONTROL_CHARS(c) 	((0x2000==((c)&0xFFF0))||(0x2028==((c)&0xFFF8)))
  1: #define IS_CONTEXTUAL_CHARS(c) 		  ((0x0600<=(c))&&((c)<0x1000))
  1: #define IS_COMBINING_CHARS(c) 		  ((0x0300<=(c))&&((c)<0x0370))
  1: 
  1: #define QUESTION_FALLBACKSIZE 9
  1: #define UPLUS_FALLBACKSIZE 9
  1: #define IN_RANGE(c, l, h) (((l) <= (c)) && ((c) <= (h)))
  1: #define IN_STANDARD_MAC_ROMAN_FONT(c) ( \
  1:   (((c) < 0x180) && (! (\
  1:    (0x0110 == (c)) || \
  1:    (0x012c == (c)) || \
  1:    (0x012d == (c)) || \
  1:    (0x0138 == (c)) || \
  1:    (0x014a == (c)) || \
  1:    (0x014b == (c)) || \
  1:    (0x017f == (c))    \
  1:    )))) 
  1: #define IN_SYMBOL_FONT(c) ( \
  1:   IN_RANGE(c, 0x0391, 0x03a1) || \
  1:   IN_RANGE(c, 0x03a3, 0x03a9) || \
  1:   IN_RANGE(c, 0x03b1, 0x03c1) || \
  1:   IN_RANGE(c, 0x03c3, 0x03c9) || \
  1:   (0x2111 == (c))   || \
  1:   (0x2118 == (c))   || \
  1:   (0x211c == (c))   || \
  1:   (0x2135 == (c))   || \
  1:   IN_RANGE(c, 0x2190, 0x2193) || \
  1:   IN_RANGE(c, 0x21d0, 0x21d3) || \
  1:   IN_RANGE(c, 0x21ed, 0x21ee) || \
  1:   (0x2200 == (c))   || \
  1:   (0x2203 == (c))   || \
  1:   (0x2205 == (c))   || \
  1:   (0x2208 == (c))   || \
  1:   (0x2209 == (c))   || \
  1:   (0x2212 == (c))   || \
  1:   (0x2217 == (c))   || \
  1:   (0x221d == (c))   || \
  1:   (0x2220 == (c))   || \
  1:   IN_RANGE(c, 0x2227, 0x222b) || \
  1:   (0x2234 == (c))   || \
  1:   (0x223c == (c))   || \
  1:   (0x2261 == (c))   || \
  1:   (0x2282 == (c))   || \
  1:   (0x2283 == (c))   || \
  1:   (0x2286 == (c))   || \
  1:   (0x2287 == (c))   || \
  1:   (0x2295 == (c))   || \
  1:   (0x2297 == (c))   || \
  1:   (0x22a5 == (c))   || \
  1:   (0x2320 == (c))   || \
  1:   (0x2321 == (c))   || \
  1:   (0x240d == (c))   || \
  1:   (0x2660 == (c))   || \
  1:   (0x2663 == (c))   || \
  1:   (0x2665 == (c))   || \
  1:   (0x2666 == (c))      \
  1:   )
  1: #define SPECIAL_IN_SYMBOL_FONT(c) ( \
  1:   IN_RANGE(c, 0x2308, 0x230b) || \
  1:   (0x2329 == (c))   || \
  1:   (0x232a == (c))    \
  1:   )
  1: #define BAD_TEXT_ENCODING 0xFFFFFFFF
  1: 
  1: // all the character should not be drawn if there are no glyph
  1: #define IS_ZERO_WIDTH_CHAR(c) ( \
  1:   IN_RANGE(c, 0x200b, 0x200f) || \
  1:   IN_RANGE(c, 0x202a, 0x202e) \
  1:   )
  1:   
  1: 
  1: #define IN_ARABIC_PRESENTATION_A(a) ((0xfb50 <= (a)) && ((a) <= 0xfdff))
  1: #define IN_ARABIC_PRESENTATION_B(a) ((0xfe70 <= (a)) && ((a) <= 0xfeff))
  1: #define IN_ARABIC_PRESENTATION_A_OR_B(a) (IN_ARABIC_PRESENTATION_A(a) || IN_ARABIC_PRESENTATION_B(a))
  1: 
  1: // We should not use TEC fallback for characters in Latin, Greek and Cyrillic scripts
  1: // because Japanese, Chinese and Korean fonts have these characters. If we let them 
  1: // render in the TEC fallback process, then we would use a Japanese/Korean/Chinese font
  1: // to render it even if the current font has a glyph in it.
  1: // if we skip the TEC fallback, then the ATSUI fallback will try to use the glyph 
  1: // in the font first (TEC or TEC fallback are using QuickDraw, which can only use 
  1: // the glyphs that are in the font script's encoding. But a lot of TrueType fonts
  1: // have hundreds more glyphs in addition to the font scripts.
  1: #define IS_LATIN(c)  ( IN_RANGE(c, 0x0000, 0x024F) || IN_RANGE(c, 0x1e00, 0x1eff) )
  1: #define IS_GREEK(c)  ( IN_RANGE(c, 0x0370, 0x03FF) || IN_RANGE(c, 0x1f00, 0x1fff) )
  1: #define IS_CYRILLIC(c)  IN_RANGE(c, 0x0400, 0x04ff)
  1: #define IS_SKIP_TEC_FALLBACK(c) (IS_LATIN(c) || IS_GREEK(c) || IS_CYRILLIC(c))
  1: 
  1: //------------------------------------------------------------------------
  1: #pragma mark -
  1: //------------------------------------------------------------------------
  1: 
  1: nsUnicodeFallbackCache* nsUnicodeRenderingToolkit :: GetTECFallbackCache()
  1: {
  1: 	static nsUnicodeFallbackCache* gTECFallbackCache = nsnull;
  1: 	
  1: 	if( ! gTECFallbackCache)
  1: 		gTECFallbackCache = new nsUnicodeFallbackCache();
  1: 	return gTECFallbackCache;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool 
  1: nsUnicodeRenderingToolkit::TECFallbackGetDimensions(
  1:   const PRUnichar *aCharPt, 
  1:   nsTextDimensions& oDim, 
  1:   short origFontNum, 
  1:   nsUnicodeFontMappingMac& fontMapping)
  1: {
  1:   char buf[20];
  1:   ByteCount processBytes = 0;
  1:   ByteCount outLen = 0;
  1:   ScriptCode fallbackScript;
  1:   nsUnicodeFallbackCache* cache = GetTECFallbackCache();
  1:   short aWidth;
  1:   FontInfo finfo;
  1:   const short *scriptFallbackFonts = fontMapping.GetScriptFallbackFonts();
  1:   
  1:   if ((0xf780 <= *aCharPt) && (*aCharPt <= 0xf7ff))
  1:   {
  1:     // If we are encountering our PUA characters for User-Defined characters, we better
  1:     // just drop the high-byte and return the width for the low-byte.
  1:     *buf = (*aCharPt & 0x00FF);
  1:     ::GetFontInfo(&finfo);
  1:     oDim.ascent = finfo.ascent;
  1:     oDim.descent = finfo.descent;
  1:     
  1:     GetScriptTextWidth (buf,1,aWidth);
  1:     oDim.width = aWidth;
  1: 
  1:     return PR_TRUE;
  1:   }
  1:   else if (cache->Get(*aCharPt, fallbackScript))
  1:   {
  1:     if (BAD_SCRIPT == fallbackScript)
  1:       return PR_FALSE;
  1:     
  1:     if(fontMapping.ConvertUnicodeToGlyphs(scriptFallbackFonts[fallbackScript], aCharPt, 1,
  1:         buf, STACK_TRESHOLD, outLen, processBytes, kUnicodeLooseMappingsMask))
  1:     {  
  1:         ::TextFont(scriptFallbackFonts[fallbackScript]);
  1:         GetScriptTextWidth(buf, outLen, aWidth);
  1:         ::GetFontInfo(&finfo);
  1:         oDim.ascent = finfo.ascent;
  1:         oDim.descent = finfo.descent;
  1:         oDim.width = aWidth;
  1:         ::TextFont(origFontNum);
  1:     }
  1:     return PR_TRUE;
  1:   }
  1:   
  1:   for(fallbackScript = 0 ; fallbackScript < 32; fallbackScript++)
  1:   {
  1:     if (BAD_FONT_NUM != scriptFallbackFonts[fallbackScript])
  1:     {
  1:         if(fontMapping.ConvertUnicodeToGlyphs(scriptFallbackFonts[fallbackScript], aCharPt, 1,
  1:             buf, STACK_TRESHOLD, outLen, processBytes, kUnicodeLooseMappingsMask))
  1:         {
  1:             NS_PRECONDITION(0 == (processBytes % 2), "strange conversion result");
  1:             ::TextFont(scriptFallbackFonts[fallbackScript]);
  1:             GetScriptTextWidth(buf, outLen, aWidth);
  1:             ::GetFontInfo(&finfo);
  1:             oDim.ascent = finfo.ascent;
  1:             oDim.descent = finfo.descent;
  1:             oDim.width = aWidth;
  1:             ::TextFont(origFontNum);        
  1:             break;
  1:         }          
  1:     }
  1:   }
  1:   
  1:   if (0 == outLen)
  1:     fallbackScript = BAD_SCRIPT;
  1:     
  1:   // put into cache
  1:   cache->Set(*aCharPt, fallbackScript);
  1:   
  1:   return (BAD_SCRIPT != fallbackScript);
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: #if MOZ_MATHML
  1: PRBool nsUnicodeRenderingToolkit::TECFallbackGetBoundingMetrics(
  1:     const PRUnichar *aCharPt,
  1:     nsBoundingMetrics& oBoundingMetrics,
  1:     short fontNum,
  1:     nsUnicodeFontMappingMac& fontMapping)
  1: {
  1:     char buf[STACK_TRESHOLD];
  1:     ByteCount processBytes = 0;
  1:     ByteCount outLen = 0;
  1:     ScriptCode fallbackScript;
  1:     nsUnicodeFallbackCache* cache = GetTECFallbackCache();
  1:     const short *scriptFallbackFonts = fontMapping.GetScriptFallbackFonts();
  1:     
  1:     if((0xf780 <= *aCharPt) && (*aCharPt <= 0xf7ff))
  1:     {
  1:         // If we are encountering our PUA characters for User-Defined characters, we better
  1:         // just drop the high-byte and return the width for the low-byte.
  1:         *buf = (*aCharPt & 0x00FF);
  1:         GetScriptTextBoundingMetrics(buf, 1, ::FontToScript(fontNum), oBoundingMetrics);
  1:         return PR_TRUE;
  1:     }
  1:     else if(cache->Get(*aCharPt, fallbackScript))
  1:     {
  1:         if(BAD_SCRIPT == fallbackScript)
  1:             return PR_FALSE;
  1:         
  1:         if(fontMapping.ConvertUnicodeToGlyphs(scriptFallbackFonts[fallbackScript], aCharPt, 1,
  1:             buf, STACK_TRESHOLD, outLen, processBytes, kUnicodeLooseMappingsMask))
  1:         {  
  1:             ::TextFont(scriptFallbackFonts[fallbackScript]);
  1:             GetScriptTextBoundingMetrics(buf, outLen, fallbackScript, oBoundingMetrics);
  1:             ::TextFont(fontNum);
  1:             return PR_TRUE;
  1:         }
  1:         return PR_FALSE;
  1:     }
  1:     
  1:     for(fallbackScript = 0; fallbackScript < 32; fallbackScript++)
  1:     {
  1:         if(BAD_FONT_NUM != scriptFallbackFonts[fallbackScript])
  1:         {
  1:             if(fontMapping.ConvertUnicodeToGlyphs(scriptFallbackFonts[fallbackScript], aCharPt, 1,
  1:                 buf, STACK_TRESHOLD, outLen, processBytes, kUnicodeLooseMappingsMask))
  1:             {
  1:                 NS_PRECONDITION(0 == (processBytes % 2), "strange conversion result");
  1:                 ::TextFont(scriptFallbackFonts[fallbackScript]);
  1:                 GetScriptTextBoundingMetrics(buf, outLen, fallbackScript, oBoundingMetrics);           
  1:                 ::TextFont(fontNum);
  1:                 break;
  1:             }   
  1:         }
  1:     }
  1:     
  1:     if(0 == outLen)
  1:         fallbackScript = BAD_SCRIPT;
  1:         
  1:     // put into cache
  1:     cache->Set(*aCharPt, fallbackScript);
  1:     
  1:     return (BAD_SCRIPT != fallbackScript);
  1: }
  1: #endif // MOZ_MATHML
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: TECFallbackDrawChar(
  1:   const PRUnichar *aCharPt, 
  1:   PRInt32 x, 
  1:   PRInt32 y, 
  1:   short& oWidth, 
  1:   short origFontNum, 
  1:   nsUnicodeFontMappingMac& fontMapping)
  1: {
  1:   char buf[20];
  1:   ByteCount processBytes = 0;
  1:   ByteCount outLen = 0;
  1:   ScriptCode fallbackScript;
  1:   nsUnicodeFallbackCache* cache = GetTECFallbackCache();
  1:   const short *scriptFallbackFonts = fontMapping.GetScriptFallbackFonts();
  1:   
  1:   // since we always call TECFallbackGetWidth before TECFallbackDrawChar
  1:   // we could assume that we can always get the script code from cache.
  1:   if ((0xf780 <= *aCharPt) && (*aCharPt <= 0xf7ff))
  1:   {
  1:     // If we are encountering our PUA characters for User-Defined characters, we better
  1:     // just drop the high-byte and draw the text for the low-byte.
  1:     *buf = (*aCharPt & 0x00FF);
  1:     DrawScriptText (buf,1,x,y,oWidth);
  1: 
  1:     return PR_TRUE;
  1:   }
  1:   else if (cache->Get(*aCharPt, fallbackScript))
  1:   {
  1:     if (BAD_SCRIPT == fallbackScript)
  1:       return PR_FALSE;
  1:     
  1:     if(fontMapping.ConvertUnicodeToGlyphs(scriptFallbackFonts[fallbackScript], aCharPt, 1,
  1:         buf, STACK_TRESHOLD, outLen, processBytes, kUnicodeLooseMappingsMask))
  1:     {
  1:         ::TextFont(scriptFallbackFonts[fallbackScript]);
  1:         DrawScriptText(buf, outLen, x, y, oWidth);
  1:         ::TextFont(origFontNum);
  1:         return PR_TRUE;
  1:     }
  1:   }
  1:   return PR_FALSE;
  1: }
  1: //------------------------------------------------------------------------
  1: static PRUnichar gSymbolReplacement[]={0xf8ee,0xf8f9,0xf8f0,0xf8fb,0x3008,0x3009};
  1: 
  1: //------------------------------------------------------------------------
  1: 
  1: static nsresult FormAorBIsolated(PRUnichar aChar, nsMacUnicodeFontInfo& aInfo, PRUnichar* aOutChar)
  1: {
  1:   static const PRUnichar arabicisolated[]=
  1:   {
  1:     // start of form a
  1:     0xFB50, 0x0671,  0xFB52, 0x067B,  0xFB56, 0x067E,  0xFB5A, 0x0680,  0xFB5E, 0x067A,
  1:     0xFB62, 0x067F,  0xFB66, 0x0679,  0xFB6A, 0x06A4,  0xFB6E, 0x06A6,  0xFB72, 0x0684,
  1:     0xFB76, 0x0683,  0xFB7A, 0x0686,  0xFB7E, 0x0687,  0xFB82, 0x068D,  0xFB84, 0x068C,
  1:     0xFB86, 0x068E,  0xFB88, 0x0688,  0xFB8A, 0x0698,  0xFB8C, 0x0691,  0xFB8E, 0x06A9,
  1:     0xFB92, 0x06AF,  0xFB96, 0x06B3,  0xFB9A, 0x06B1,  0xFB9E, 0x06BA,  0xFBA0, 0x06BB,
  1:     0xFBA4, 0x06C0,  0xFBA6, 0x06C1,  0xFBAA, 0x06BE,  0xFBAE, 0x06D2,  0xFBB0, 0x06D3,
  1:     0xFBD3, 0x06AD,  0xFBD7, 0x06C7,  0xFBD9, 0x06C6,  0xFBDB, 0x06C8,  0xFBDD, 0x0677,
  1:     0xFBDE, 0x06CB,  0xFBE0, 0x06C5,  0xFBE2, 0x06C9,  0xFBE4, 0x06D0,  0xFBFC, 0x06CC,
  1: 
  1:     // start of form b
  1:     0xFE70, 0x064B,  0xFE72, 0x064C,  0xFE74, 0x064D,  0xFE76, 0x064E,  0xFE78, 0x064F,
  1:     0xFE7A, 0x0650,  0xFE7C, 0x0651,  0xFE7E, 0x0652,  0xFE80, 0x0621,  0xFE81, 0x0622,
  1:     0xFE83, 0x0623,  0xFE85, 0x0624,  0xFE87, 0x0625,  0xFE89, 0x0626,  0xFE8D, 0x0627,
  1:     0xFE8F, 0x0628,  0xFE93, 0x0629,  0xFE95, 0x062A,  0xFE99, 0x062B,  0xFE9D, 0x062C,
  1:     0xFEA1, 0x062D,  0xFEA5, 0x062E,  0xFEA9, 0x062F,  0xFEAB, 0x0630,  0xFEAD, 0x0631,
  1:     0xFEAF, 0x0632,  0xFEB1, 0x0633,  0xFEB5, 0x0634,  0xFEB9, 0x0635,  0xFEBD, 0x0636,
  1:     0xFEC1, 0x0637,  0xFEC5, 0x0638,  0xFEC9, 0x0639,  0xFECD, 0x063A,  0xFED1, 0x0641,
  1:     0xFED5, 0x0642,  0xFED9, 0x0643,  0xFEDD, 0x0644,  0xFEE1, 0x0645,  0xFEE5, 0x0646,
  1:     0xFEE9, 0x0647,  0xFEED, 0x0648,  0xFEEF, 0x0649,  0xFEF1, 0x064A,
  1:     0x0000
  1:   };
  1:   const PRUnichar* p;
  1:   for ( p= arabicisolated; *p; p += 2) {
  1:     if (aChar == *p) {
  1:       if (aInfo.HasGlyphFor(*(p+1))) {
  1:         *aOutChar = *(p+1);
  1:         return NS_OK;
  1:       }
  1:     }
  1:   }
  1:   return NS_ERROR_FAILURE;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool 
  1: nsUnicodeRenderingToolkit::ATSUIFallbackGetDimensions(
  1:   const PRUnichar *aCharPt, 
  1:   nsTextDimensions& oDim, 
  1:   short origFontNum,
  1:   short aSize, PRBool aBold, PRBool aItalic, nscolor aColor) 
  1: {
  1:   
  1:   nsMacUnicodeFontInfo info;
  1:   if (nsATSUIUtils::IsAvailable()  
  1:       && (IN_STANDARD_MAC_ROMAN_FONT(*aCharPt) 
  1:          ||IN_SYMBOL_FONT(*aCharPt)
  1:          ||SPECIAL_IN_SYMBOL_FONT(*aCharPt)
  1:          ||info.HasGlyphFor(*aCharPt)))
  1:   {
  1:     mATSUIToolkit.PrepareToDraw(mPort, mContext );
  1:     nsresult res;
  1:     if (SPECIAL_IN_SYMBOL_FONT(*aCharPt))
  1:     {
  1:       short rep = 0;
  1:       if ((*aCharPt) > 0x230b)
  1:          rep = (*aCharPt) - 0x2325;
  1:       else 
  1:          rep = (*aCharPt) - 0x2308;
  1:       res = mATSUIToolkit.GetTextDimensions(gSymbolReplacement+rep, 1, oDim, aSize, 
  1:                                             origFontNum, 
  1:                                             aBold, aItalic, aColor);
  1:     } 
  1:     else 
  1:     {
  1:       res = mATSUIToolkit.GetTextDimensions(aCharPt, 1, oDim, aSize, 
  1:                                             origFontNum, 
  1:                                             aBold, aItalic, aColor);
  1:     }
  1:     if (NS_SUCCEEDED(res)) 
  1:       return PR_TRUE;
  1:   }
  1: 
  1:   if (IN_ARABIC_PRESENTATION_A_OR_B(*aCharPt))
  1:   {      
  1:     PRUnichar isolated;
  1:     if (NS_SUCCEEDED( FormAorBIsolated(*aCharPt, info, &isolated))) 
  1:     {
  1:       if (ATSUIFallbackGetDimensions(&isolated, oDim, origFontNum, 
  1:                                      aSize, aBold, aItalic, aColor))
  1:          return PR_TRUE;
  1:     }                                                 
  1:   }
  1: 
  1:   // we know some ATSUI font do not have bold, turn it off and try again
  1:   if (aBold) 
  1:   {
  1: 	  if (ATSUIFallbackGetDimensions(aCharPt, oDim, origFontNum, 
  1: 	                                 aSize, PR_FALSE, aItalic, aColor))
  1: 	     return PR_TRUE;
  1:   }
  1: 
  1:   // we know some ATSUI font do not have italic, turn it off and try again
  1:   if (aItalic) 
  1:   {
  1: 	  if (ATSUIFallbackGetDimensions(aCharPt, oDim, origFontNum, 
  1: 	                                 aSize, PR_FALSE, PR_FALSE, aColor))
  1: 	     return PR_TRUE;
  1:   }
  1: 
  1:   return PR_FALSE;
  1: }
  1: 
  1: //------------------------------------------------------------------------
  1: 
  1: #ifdef MOZ_MATHML
  1: PRBool
  1: nsUnicodeRenderingToolkit::ATSUIFallbackGetBoundingMetrics(
  1:   const PRUnichar *aCharPt,
  1:   nsBoundingMetrics& oBoundingMetrics,
  1:   short origFontNum,
  1:   short aSize, PRBool aBold, PRBool aItalic, nscolor aColor)
  1: {
  1: 
  1:   nsMacUnicodeFontInfo info;
  1:   if (nsATSUIUtils::IsAvailable()  
  1:       && (IN_STANDARD_MAC_ROMAN_FONT(*aCharPt) 
  1:          ||IN_SYMBOL_FONT(*aCharPt)
  1:          ||SPECIAL_IN_SYMBOL_FONT(*aCharPt)
  1:          ||info.HasGlyphFor(*aCharPt)))
  1:   {
  1:     mATSUIToolkit.PrepareToDraw(mPort, mContext );
  1:     nsresult res;
  1:     if (SPECIAL_IN_SYMBOL_FONT(*aCharPt))
  1:     {
  1:       short rep = 0;
  1:       if ((*aCharPt) > 0x230b)
  1:          rep = (*aCharPt) - 0x2325;
  1:       else
  1:          rep = (*aCharPt) - 0x2308;
  1:       res = mATSUIToolkit.GetBoundingMetrics(gSymbolReplacement+rep, 1, oBoundingMetrics, aSize, 
  1:                                              origFontNum, 
  1:                                              aBold, aItalic, aColor);
  1:     }
  1:     else
  1:     {
  1:       res = mATSUIToolkit.GetBoundingMetrics(aCharPt, 1, oBoundingMetrics, aSize, 
  1:                                              origFontNum, 
  1:                                              aBold, aItalic, aColor);
  1:     }
  1:     if (NS_SUCCEEDED(res))
  1:       return PR_TRUE;
  1:   }
  1: 
  1:   if (IN_ARABIC_PRESENTATION_A_OR_B(*aCharPt))
  1:   {  
  1:     PRUnichar isolated;
  1:     if (NS_SUCCEEDED(FormAorBIsolated(*aCharPt, info, &isolated)))
  1:     {
  1:       if (ATSUIFallbackGetBoundingMetrics(&isolated, oBoundingMetrics, origFontNum, 
  1:                                           aSize, aBold, aItalic, aColor))
  1:         return PR_TRUE;
  1:     }                                                 
  1:   }
  1: 
  1:   // we know some ATSUI font do not have bold, turn it off and try again
  1:   if (aBold)
  1:   {
  1:     if (ATSUIFallbackGetBoundingMetrics(aCharPt, oBoundingMetrics, origFontNum, 
  1:                                         aSize, PR_FALSE, aItalic, aColor))
  1:       return PR_TRUE;
  1:   }
  1: 
  1:   // we know some ATSUI font do not have italic, turn it off and try again
  1:   if (aItalic) 
  1:   {
  1:     if (ATSUIFallbackGetBoundingMetrics(aCharPt, oBoundingMetrics, origFontNum, 
  1:                                         aSize, PR_FALSE, PR_FALSE, aColor))
  1:       return PR_TRUE;
  1:   }
  1: 
  1:   return PR_FALSE;
  1: }
  1: #endif // MOZ_MATHML
  1: 
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: ATSUIFallbackDrawChar(
  1:   const PRUnichar *aCharPt, 
  1:   PRInt32 x,   PRInt32 y, 
  1:   short& oWidth, 
  1:   short origFontNum,
  1:   short aSize, PRBool aBold, PRBool aItalic, nscolor aColor) 
  1: {
  1:   nsMacUnicodeFontInfo info;
  1:   if (nsATSUIUtils::IsAvailable()  
  1:       && (IN_STANDARD_MAC_ROMAN_FONT(*aCharPt) 
  1:          ||IN_SYMBOL_FONT(*aCharPt)
  1:          ||SPECIAL_IN_SYMBOL_FONT(*aCharPt)
  1:          ||info.HasGlyphFor(*aCharPt)))
  1:   {
  1:     mATSUIToolkit.PrepareToDraw(mPort, mContext );
  1:     nsresult res;
  1:     if(SPECIAL_IN_SYMBOL_FONT(*aCharPt)) 
  1:     {
  1:       short rep = 0;
  1:       if ((*aCharPt) > 0x230b)
  1:         rep = (*aCharPt) - 0x2325;
  1:       else 
  1:         rep = (*aCharPt) - 0x2308;
  1:       res = mATSUIToolkit.DrawString(gSymbolReplacement+rep, 1, x, y, oWidth, aSize, 
  1:                                      origFontNum, 
  1:                                      aBold, aItalic, aColor);
  1:     } else {
  1:       res = mATSUIToolkit.DrawString(aCharPt, 1, x, y, oWidth, aSize, 
  1:                                      origFontNum, 
  1:                                      aBold, aItalic, aColor);
  1:     }
  1:     if (NS_SUCCEEDED(res))
  1:       return PR_TRUE;
  1:   }
  1: 
  1:   if (IN_ARABIC_PRESENTATION_A_OR_B(*aCharPt))
  1:   {      
  1:     PRUnichar isolated;
  1:     if (NS_SUCCEEDED(FormAorBIsolated(*aCharPt, info, &isolated))) {
  1:       if (ATSUIFallbackDrawChar(&isolated, x, y, oWidth, origFontNum, 
  1:                                 aSize, aBold, aItalic, aColor))
  1:          return PR_TRUE;
  1:     }                                                 
  1:   }
  1: 
  1:   // we know some ATSUI font do not have bold, turn it off and try again
  1:   if (aBold)
  1:   {
  1:     if (ATSUIFallbackDrawChar(aCharPt, x, y, oWidth, origFontNum, 
  1:                               aSize, PR_FALSE, aItalic, aColor))
  1:        return PR_TRUE;
  1:   }
  1: 
  1:   // we know some ATSUI font do not have italic, turn it off and try again
  1:   if (aItalic)
  1:   {
  1:     if (ATSUIFallbackDrawChar(aCharPt, x, y, oWidth, origFontNum, 
  1:                               aSize, PR_FALSE, PR_FALSE, aColor))
  1:        return PR_TRUE;
  1:   }
  1: 
  1:   return PR_FALSE;
  1: }
  1: 
  1: PRBool  nsUnicodeRenderingToolkit :: SurrogateGetDimensions(
  1:   const PRUnichar *aSurrogatePt, nsTextDimensions& oDim, short origFontNum,  
  1:   short aSize, PRBool aBold, PRBool aItalic, nscolor aColor)
  1: {
  1:   nsresult res;
  1:   mATSUIToolkit.PrepareToDraw(mPort, mContext );
  1:   res = mATSUIToolkit.GetTextDimensions(aSurrogatePt, 2, oDim, aSize, 
  1:                                         origFontNum, 
  1:                                         aBold, aItalic, aColor);
  1:   return NS_SUCCEEDED(res);
  1: }
  1: 
  1: PRBool  nsUnicodeRenderingToolkit :: SurrogateDrawChar(
  1:   const PRUnichar *aSurrogatePt, PRInt32 x, PRInt32 y, short& oWidth, short origFontNum, 
  1:   short aSize, PRBool aBold, PRBool aItalic, nscolor aColor)
  1: {
  1:   nsresult res;
  1:   mATSUIToolkit.PrepareToDraw(mPort, mContext );
  1:   res = mATSUIToolkit.DrawString(aSurrogatePt, 2, x, y, oWidth, aSize, 
  1:                                  origFontNum, 
  1:                                  aBold, aItalic, aColor);
  1:   return NS_SUCCEEDED(res);
  1: }
  1: 
  1: #ifdef MOZ_MATHML
  1: PRBool  nsUnicodeRenderingToolkit :: SurrogateGetBoundingMetrics(
  1:   const PRUnichar *aSurrogatePt, nsBoundingMetrics& oBoundingMetrics, short origFontNum,
  1:   short aSize, PRBool aBold, PRBool aItalic, nscolor aColor)
  1: {
  1:   nsresult res;
  1:   mATSUIToolkit.PrepareToDraw(mPort, mContext );
  1:   res = mATSUIToolkit.GetBoundingMetrics(aSurrogatePt, 2, oBoundingMetrics, aSize, 
  1:                                              origFontNum, 
  1:                                              aBold, aItalic, aColor);
  1: 
  1:   return NS_SUCCEEDED(res);
  1: }
  1: #endif
  1: 
  1: static const char question[] = "<?>";
  1: 
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: QuestionMarkFallbackGetWidth(
  1: 	const PRUnichar *aCharPt, 
  1: 	short& oWidth)
  1: {
  1:   CGrafPtr thePort;
  1:   ::GetPort((GrafPtr*)&thePort);
  1:   short saveSize = ::GetPortTextSize(thePort);		
  1:   ::TextSize(QUESTION_FALLBACKSIZE);
  1:   GetScriptTextWidth(question, 3,oWidth);
  1:   ::TextSize(saveSize);
  1:   return PR_TRUE;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: QuestionMarkFallbackDrawChar(
  1: 	const PRUnichar *aCharPt, 
  1: 	PRInt32 x, 
  1: 	PRInt32 y, 
  1: 	short& oWidth)
  1: {
  1:   CGrafPtr thePort;
  1:   ::GetPort((GrafPtr*)&thePort);
  1:   short saveSize = ::GetPortTextSize(thePort);		
  1:   ::TextSize(QUESTION_FALLBACKSIZE);
  1:   DrawScriptText(question, 3, x, y, oWidth);
  1:   ::TextSize(saveSize);
  1:   return PR_TRUE;
  1: }
  1: //------------------------------------------------------------------------
  1: PRBool nsUnicodeRenderingToolkit :: LoadTransliterator()
  1: {
  1: 	if(mTrans) 
  1: 		return PR_TRUE;
  1: 		
  1: 	nsresult res;
  1:     mTrans = do_CreateInstance(NS_SAVEASCHARSET_CONTRACTID, &res);
  1:     if ( NS_SUCCEEDED(res) )
  1:     {
  1:        res = mTrans->Init("x-mac-roman",
  1:                nsISaveAsCharset::attr_FallbackQuestionMark +
  1:                nsISaveAsCharset::attr_EntityBeforeCharsetConv +
  1:                nsISaveAsCharset::attr_IgnoreIgnorables,
  1:                nsIEntityConverter::transliterate);
  1:       NS_ASSERTION(NS_SUCCEEDED(res), "cannot init the converter");
  1:       if (NS_FAILED(res)) 
  1:       {
  1:         mTrans = nsnull;
  1:         return PR_FALSE;
  1:       }
  1:     }
  1:     return PR_TRUE;
  1: }
  1: //------------------------------------------------------------------------
  1: PRBool nsUnicodeRenderingToolkit :: TransliterateFallbackGetWidth(
  1: 	const PRUnichar *aCharPt, 
  1: 	short& oWidth)
  1: {
  1:   if(LoadTransliterator()) {
  1:     nsAutoString tmp(aCharPt, 1);
  1:     char* conv = nsnull;
  1:     if(NS_SUCCEEDED(mTrans->Convert(tmp.get(), &conv)) && conv) {
  1:       CGrafPtr thePort;
  1:       ::GetPort((GrafPtr*)&thePort);
  1: 	    short aSize = ::GetPortTextSize(thePort);		 		
  1:   		PRInt32 l=strlen(conv);
  1:     	if((l>3) && ('^' == conv[0]) && ('(' == conv[1]) && (')' == conv[l-1])) // sup
  1:     	{
  1:     		short small = aSize * 2 / 3;
  1:     		::TextSize(small);
  1:   			GetScriptTextWidth(conv+2, l-3,oWidth);   
  1:     		::TextSize(aSize);
  1:     	} 
  1:     	else if((l>3) && ('v' == conv[0]) && ('(' == conv[1]) && (')' == conv[l-1])) // sub
  1:     	{
  1:     		short small = aSize * 2 / 3;
  1:     		::TextSize(small);
  1:   			GetScriptTextWidth(conv+2, l-3,oWidth);   
  1:      		::TextSize(aSize);
  1:    		} 
  1:    		else if((l>1) && ('0' <= conv[0]) && ( conv[0] <= '9') && ('/' == conv[1])) // fract
  1:     	{
  1:     		short small = aSize * 2 / 3;
  1:     		short tmpw=0;
  1:     		
  1:     		::TextSize(small);
  1:    			GetScriptTextWidth(conv, 1 ,tmpw);   
  1:    			oWidth = tmpw;
  1:     		
  1:      		::TextSize(aSize);
  1:   			GetScriptTextWidth(conv+1, 1,tmpw);   
  1:     		oWidth += tmpw;
  1:      		
  1:     		if(l>2) {
  1:     			::TextSize(small);
  1:   				GetScriptTextWidth(conv+2, l-2,tmpw);   
  1:     			oWidth += tmpw;
  1:  	    		::TextSize(aSize);
  1:     		}
  1:     	} else {
  1:   			GetScriptTextWidth(conv, l,oWidth);   
  1:   		}
  1:   		
  1:   		 
  1:     	nsMemory::Free(conv);
  1:     	return PR_TRUE;
  1:     }
  1:   }
  1:   return PR_FALSE;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: TransliterateFallbackDrawChar(
  1: 	const PRUnichar *aCharPt, 
  1: 	PRInt32 x, 
  1: 	PRInt32 y, 
  1: 	short& oWidth)
  1: {
  1:   if(LoadTransliterator()) {
  1:     nsAutoString tmp(aCharPt, 1);
  1:     char* conv = nsnull;
  1:     if(NS_SUCCEEDED(mTrans->Convert(tmp.get(), &conv)) && conv) {
  1: 	    CGrafPtr thePort;
  1: 	    ::GetPort((GrafPtr*)&thePort);
  1: 	    short aSize = ::GetPortTextSize(thePort);		
  1:     	PRInt32 l=strlen(conv);
  1:     	if((l>3) && ('^' == conv[0]) && ('(' == conv[1]) && (')' == conv[l-1])) // sup
  1:     	{
  1:     		short small = aSize * 2 / 3;
  1:     		::TextSize(small);
  1:     		DrawScriptText(conv+2, l-3, x, y-small/2, oWidth);
  1:     		::TextSize(aSize);
  1:     	} 
  1:     	else if((l>3) && ('v' == conv[0]) && ('(' == conv[1]) && (')' == conv[l-1])) // sub
  1:     	{
  1:     		short small = aSize * 2 / 3;
  1:     		::TextSize(small);
  1:     		DrawScriptText(conv+2, l-3, x, y+small/2, oWidth);
  1:      		::TextSize(aSize);
  1:    		} 
  1:    		else if((l>1) && ('0' <= conv[0]) && ( conv[0] <= '9') && ('/' == conv[1])) // fract
  1:     	{
  1:     		short small = aSize * 2 / 3;
  1:     		short tmpw=0;
  1:     		
  1:     		::TextSize(small);
  1:     		DrawScriptText(conv, 1, x, y-small/2, tmpw);
  1:     		oWidth = tmpw;
  1:     		
  1:      		::TextSize(aSize);
  1:     		DrawScriptText(conv+1, 1, x+oWidth, y, tmpw);
  1:     		oWidth += tmpw;
  1:      		
  1:     		if(l>2) {
  1:     			::TextSize(small);
  1:     			DrawScriptText(conv+2, l-2, x+oWidth, y+small/2, tmpw);
  1:     			oWidth += tmpw;
  1:  	    		::TextSize(aSize);
  1:     		}
  1:     	} else {
  1:   			DrawScriptText(conv, l, x, y, oWidth);
  1:   		}
  1:     	nsMemory::Free(conv);
  1:     	return PR_TRUE;
  1:     }
  1:   }
  1:   return PR_FALSE;
  1: }
  1: //------------------------------------------------------------------------
  1: #define CAN_DO_PRECOMPOSE_HANGUL(u, f) ((0xAC00<=(u)) && ((u)<=0xD7FF) && ((f) != BAD_FONT_NUM))
  1: #define SBase 0xAC00
  1: #define LCount 19
  1: #define VCount 21
  1: #define TCount 28
  1: #define NCount (VCount * TCount)
  1: static void UnicodePrecomposedHangulTo4EUCKR(PRUnichar in, char *out)
  1: {
  1:         static const PRUint8 lMap[LCount] = {
  1:           0xa1, 0xa2, 0xa4, 0xa7, 0xa8, 0xa9, 0xb1, 0xb2, 0xb3, 0xb5,
  1:           0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe
  1:         };
  1: 
  1:         static const PRUint8 tMap[TCount] = {
  1:           0xd4, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa9, 0xaa, 
  1:           0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb4, 0xb5, 
  1:           0xb6, 0xb7, 0xb8, 0xba, 0xbb, 0xbc, 0xbd, 0xbe
  1:         };
  1:         PRUint16 SIndex, LIndex, VIndex, TIndex;
  1:         /* the following line are copy from Unicode 2.0 page 3-13 */
  1:         /* item 1 of Hangul Syllabel Decomposition */
  1:         SIndex =  in - SBase;
  1: 
  1:         /* the following lines are copy from Unicode 2.0 page 3-14 */
  1:         /* item 2 of Hangul Syllabel Decomposition w/ modification */
  1:         LIndex = SIndex / NCount;
  1:         VIndex = (SIndex % NCount) / TCount;
  1:         TIndex = SIndex % TCount;
  1: 		// somehow Apple's Korean font show glaph on A4D4 :( so we use '[' + L + V + T + ']' intead of 
  1: 		// Filler + L + V + T to display
  1: 		// output '['
  1: 		*out++ = '['; 
  1: 		// output L
  1: 		*out++ = 0xA4;
  1: 		*out++ = lMap[LIndex] ;
  1: 		// output V
  1: 		*out++ = 0xA4;
  1: 		*out++  = (VIndex + 0xbf);
  1: 		// output T
  1: 		*out++ = 0xA4;
  1: 		*out++ = tMap[TIndex] ;
  1: 		// output ']'
  1: 		*out++ = ']'; 
  1: }
  1:     
  1: //------------------------------------------------------------------------
  1: PRBool nsUnicodeRenderingToolkit :: PrecomposeHangulFallbackGetWidth(
  1: 	const PRUnichar *aCharPt, 
  1: 	short& oWidth,
  1: 	short koreanFont,
  1: 	short origFont)
  1: {
  1:   if(CAN_DO_PRECOMPOSE_HANGUL(*aCharPt, koreanFont)) {
  1: 	  char euckr[8];
  1: 	  if(koreanFont != origFont)
  1: 	  	::TextFont(koreanFont);		  
  1: 	  UnicodePrecomposedHangulTo4EUCKR(*aCharPt, euckr);
  1: 	  GetScriptTextWidth(euckr, 8, oWidth); 
  1: 	  if(koreanFont != origFont)
  1: 	  	::TextFont(origFont);		  
  1: 	  return PR_TRUE;
  1:   } else {
  1: 	  return PR_FALSE;
  1:   }
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: PrecomposeHangulFallbackDrawChar(
  1: 	const PRUnichar *aCharPt, 
  1: 	PRInt32 x, 
  1: 	PRInt32 y, 
  1: 	short& oWidth,
  1: 	short koreanFont,
  1: 	short origFont)
  1: {
  1:   if(CAN_DO_PRECOMPOSE_HANGUL(*aCharPt, koreanFont)) {
  1: 	  char euckr[8];
  1: 	  if(koreanFont != origFont)
  1: 	  	::TextFont(koreanFont);		  
  1: 	  UnicodePrecomposedHangulTo4EUCKR(*aCharPt, euckr);
  1: 	  DrawScriptText(euckr, 8, x, y, oWidth); 
  1: 	  if(koreanFont != origFont)
  1: 	  	::TextFont(origFont);		  
  1: 	  return PR_TRUE;
  1:   } else {
  1: 	  return PR_FALSE;
  1:   }
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: UPlusFallbackGetWidth(
  1: 	const PRUnichar *aCharPt, 
  1: 	short& oWidth)
  1: {
  1:   CGrafPtr thePort;
  1:   ::GetPort((GrafPtr*)&thePort);
  1:   short saveSize = ::GetPortTextSize(thePort);		
  1:   char buf[16];
  1:   PRUint32 len = PR_snprintf(buf, 16 , "<U+%04X>", *aCharPt);
  1:   ::TextSize(UPLUS_FALLBACKSIZE);
  1:   if(len != -1) 
  1:     GetScriptTextWidth(buf, len, oWidth);
  1:   ::TextSize(saveSize);
  1:   return (-1 != len);
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: UPlusFallbackDrawChar(
  1: 	const PRUnichar *aCharPt, 
  1: 	PRInt32 x, 
  1: 	PRInt32 y, 
  1: 	short& oWidth)
  1: {
  1:   CGrafPtr thePort;
  1:   ::GetPort((GrafPtr*)&thePort);
  1:   short saveSize = ::GetPortTextSize(thePort);		
  1:   char buf[16];
  1:   PRUint32 len = PR_snprintf(buf, 16 , "<U+%04X>", *aCharPt);
  1:   ::TextSize(UPLUS_FALLBACKSIZE);
  1:   if(len != -1) 
  1:     DrawScriptText(buf, len, x, y, oWidth);
  1:   ::TextSize(saveSize);
  1:   return (-1 != len);
  1: }
  1: //------------------------------------------------------------------------
  1: /*
  1: # capital mean above
  1: # small mean below
  1: # r - ring below
  1: # R - Ring Above
  1: # d - dot below
  1: # D - Dot Above
  1: # l - line below
  1: # L - Line Above
  1: # c - cedilla
  1: # A - Acute
  1: # x - circumflex below
  1: # X - Circumflex Above
  1: # G - Grave above
  1: # T - Tilde above
  1: # t - tilde below
  1: # B - Breve Above
  1: # b - breve below
  1: # U - Diaeresis Above
  1: # u - diaeresis below
  1: # H - Hook Above 
  1: # N - Horn Above
  1: */
  1: static const char * const g1E00Dec = 
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E00 - U+1E0F
  1:  "Ar ar BD bD Bd bd Bl bl CcAccADD dD Dd dd Dl dl "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E10 - U+1E1F
  1:  "Dc dc Dx dx ELGeLGELAeLAEx ex Et et EcBecBFD fD "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E20 - U+1E2F
  1:  "GL gL HD hD Hd hd HU hU Hc hc Hb hb It it IUAiUA"
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E30 - U+1E3F
  1:  "KA kA Kd kd Kl kl Ld ld LdLldLLl ll Lx lx MA mA "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E40 - U+1E4F
  1:  "MD mD Md md ND nD Nd nd Nl nl Nx nx OTAoTAOTUoTU"
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E50 - U+1E5F
  1:  "OLGoLGOLAoLAPA pA PD pD RD rD Rd rd RdLrdLRl rl "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E60 - U+1E6F
  1:  "SD sD Sd sd SADsADSBDsBDSdDsdDTD tD Td td Tl tl "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E70 - U+1E7F
  1:  "Tx tx Uu uu Ut ut Ux ux UTAuTAULUuLUVT vT Vd vd "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E80 - U+1E8F
  1:  "WG wG WA wA WU wU WD wD Wd wd XD xD XU xU YD Yd "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1E90 - U+1E9F
  1:  "ZX zX Zd zd Zl zl Hl tU wR yR aH                "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1EA0 - U+1EAF
  1:  "Ad ad AH aH AXAaXAAXGaXGAXHaXHAXTaXTAdXadXABAaBA"
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1EB0 - U+1EBF
  1:  "ABGaBGABHaBHABTaBTAdBadBEd ed EH eH ET eT EXAeXA"
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1EC0 - U+1ECF
  1:  "EXGeXGEXHeXHEXTeXTEdXedXIH iH Id id Od od OH oH "
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1ED0 - U+1EDF
  1:  "OXAoXAOXGoXGOXHoXHOXToXTOdXodXOAnoAnOGnoGnOHnoHn"
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1EE0 - U+1EEF
  1:  "OHToHTOdTodTUd ud UH uh UAnuAnUGnuGnUHnuHnUTnuTn"
  1: //0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F   U+1EF0 - U+1EFF
  1:  "UdnudnYG yG Yd yd YH yH YT yT                   "
  1: ;
  1: //------------------------------------------------------------------------
  1: static void CCodeToMacRoman(char aIn, char& aOut,short aWidth, short aHeight, short& oXadj, short& oYadj)
  1: {
  1: 	aOut = ' ';
  1: 	oXadj = oYadj = 0;
  1: 	switch(aIn)
  1: 	{
  1: 		case 'r' : aOut = '\xfb'; oYadj = aHeight * 5 / 6; break ;// # r - ring below
  1: 		case 'R' : aOut = '\xfb';                          break ;// # R - Ring Above
  1: 		case 'd' : aOut = '\xfa'; oYadj = aHeight * 5 / 6; break ;// # d - dot below
  1: 		case 'D' : aOut = '\xfa';                          break ;// # D - Dot Above
  1: 		case 'l' : aOut = '_';                             break ;// # l - line below
  1: 		case 'L' : aOut = '\xf8';                          break ;// # L - Line Above
  1: 		case 'c' : aOut = '\xfc';                          break ;// # c - cedilla
  1: 		case 'A' : aOut = '\xab';                          break ;// # A - Acute
  1: 		case 'x' : aOut = '\xf6'; oYadj= aHeight * 5 / 6;  break ;// # x - circumflex below
  1: 		case 'X' : aOut = '\xf6';                          break ;// # X - Circumflex Above
  1: 		case 'G' : aOut = '`';                             break ;// # G - Grave above
  1: 		case 'T' : aOut = '\xf7';                          break ;// # T - Tilde above
  1: 		case 't' : aOut = '\xf7'; oYadj= aHeight * 5 / 6;  break ;// # t - tilde below
  1: 		case 'B' : aOut = '\xf9';                          break ;// # B - Breve Above
  1: 		case 'b' : aOut = '\xf9'; oYadj= aHeight * 5 / 6;  break ;// # b - breve below
  1: 		case 'U' : aOut = '\xac';                          break ;// # U - Diaeresis Above
  1: 		case 'u' : aOut = '\xac'; oYadj= aHeight * 5 / 6;  break ;// # u - diaeresis below
  1: 		case 'H' : aOut = ',';    oYadj= - aHeight * 5 / 6;  break ;// # H - Hook Above 
  1: 		case 'n' : aOut = ',';    oYadj= - aHeight * 5 / 6;  oXadj = aWidth /4; break ;// # N - Horn Above
  1: 		default: NS_ASSERTION(0, "unknown ccode");
  1: 		        break;	
  1: 	}
  1: }
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: LatinFallbackGetWidth(
  1: 	const PRUnichar *aCharPt, 
  1: 	short& oWidth)
  1: {
  1:   if(0x1E00 == (0xFF00 & *aCharPt)) 
  1:   {
  1:   	PRInt32 idx = 3 * ( *aCharPt & 0x00FF);
  1:   	if(' ' != g1E00Dec[idx])
  1:   	{
  1:    		GetScriptTextWidth(g1E00Dec+idx, 1, oWidth);
  1:   		return PR_TRUE;
  1:   	}
  1:   }
  1:   return PR_FALSE;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: PRBool nsUnicodeRenderingToolkit :: LatinFallbackDrawChar(
  1: 	const PRUnichar *aCharPt, 
  1: 	PRInt32 x, 
  1: 	PRInt32 y, 
  1: 	short& oWidth)
  1: {
  1:   if(0x1E00 == (0xFF00 & *aCharPt)) 
  1:   {
  1:   	PRInt32 idx = 3 * ( *aCharPt & 0x00FF);
  1:   	if(' ' != g1E00Dec[idx])
  1:   	{
  1:       CGrafPtr thePort;
  1:       ::GetPort((GrafPtr*)&thePort);
  1: 	    short aSize = ::GetPortTextSize(thePort);	
  1: 	    short dummy;
  1: 	    short realwidth;
  1:   		char comb[2];
  1:   		short xadj;
  1:   		short yadj;
  1:   		short yadjB=0;
  1:   		
  1:   		PRBool baseTooBig = 	('A'<= g1E00Dec[idx]  ) && (g1E00Dec[idx] <= 'Z'  ) 
  1:   		                     || ('f' == g1E00Dec[idx])|| ('l' == g1E00Dec[idx])|| ('k' == g1E00Dec[idx]);
  1:   		PRBool firstIsAbove    = ('A'<= g1E00Dec[idx+1]) && (g1E00Dec[idx+1] <= 'Z') ;
  1:   		PRBool secondIsAbove   = ('A'<= g1E00Dec[idx+2]) && (g1E00Dec[idx+2] <= 'Z') ;
  1:   		
  1:   		GetScriptTextWidth(g1E00Dec+idx, 1, oWidth);
  1:   		if(baseTooBig && (firstIsAbove ||secondIsAbove ))
  1:     		::TextSize(aSize *3/4);		
  1: 
  1:   		DrawScriptText(g1E00Dec+idx, 1, x, y, realwidth);
  1: 
  1:   		if(baseTooBig && (firstIsAbove ||secondIsAbove ))
  1:   			::TextSize(aSize);  			
  1:   		if(' ' != g1E00Dec[idx+1]) {
  1:   			CCodeToMacRoman(g1E00Dec[idx+1],comb[0], realwidth, aSize, xadj, yadj);
  1:   			
  1:   			GetScriptTextWidth(comb, 1, dummy);
  1:   			
  1:   			DrawScriptText( comb, 1, x + xadj + ( realwidth - dummy ) / 2, y + yadj + yadjB, dummy);
  1:   		}
  1:   		if(' ' != g1E00Dec[idx+2]) {
  1:   			if( firstIsAbove && secondIsAbove)
  1:    				yadjB = yadjB - aSize / 6; 		
  1:   		
  1:   			CCodeToMacRoman(g1E00Dec[idx+2],comb[0], realwidth, aSize, xadj, yadj);
  1:   			GetScriptTextWidth(comb, 1, dummy);
  1:   			DrawScriptText( comb, 1, x + xadj+ ( realwidth - dummy ) / 2, y+ yadj + yadjB, dummy);
  1:   		}
  1:   		return PR_TRUE;
  1:   	}
  1:   }
  1:   return PR_FALSE;
  1: }
  1: 
  1: //------------------------------------------------------------------------
  1: void nsUnicodeRenderingToolkit :: GetScriptTextWidth(
  1: 	const char* buf, 
  1: 	ByteCount aLen, 
  1: 	short& oWidth)
  1: {
  1:  	oWidth = ::TextWidth(buf, 0, aLen);
  1: }
  1: 
  1: #if MOZ_MATHML
  1: //------------------------------------------------------------------------
  1: void nsUnicodeRenderingToolkit::GetScriptTextBoundingMetrics(
  1:     const char* buf,
  1:     ByteCount aLen,
  1:     ScriptCode aScript,
  1:     nsBoundingMetrics& oBoundingMetrics)
  1: {
  1:     Point scale = { 1, 1 };
  1:     Fixed stackWidths[STACK_TRESHOLD], *widths;
  1:     Fixed stackLefts[STACK_TRESHOLD], *lefts;
  1:     Rect stackRects[STACK_TRESHOLD], *rects;
  1:     OSStatus err;
  1: 
  1:     NS_PRECONDITION(aLen > 0, "length must be greater than 0");
  1: 
  1:     if(aLen > STACK_TRESHOLD)
  1:     {
  1:         widths = (Fixed*) nsMemory::Alloc(aLen * sizeof(Fixed));
  1:         lefts = (Fixed*) nsMemory::Alloc(aLen * sizeof(Fixed));
703:         rects = (Rect*) nsMemory::Alloc(aLen * sizeof(Rect));
  1:         
  1:         // if any of the allocations failed the 'else' case below will be executed
  1:     }
  1:     else
  1:     {
  1:         widths = stackWidths;
  1:         lefts = stackLefts;
  1:         rects = stackRects;
  1:     }
  1: 
  1:     if(!GetOutlinePreferred())
  1:         SetOutlinePreferred(PR_TRUE);
  1: 
  1:     if(widths && lefts && rects &&
  1:         (err = ::OutlineMetrics(aLen, buf, scale, scale, NULL, NULL, widths, lefts, rects)) == noErr)
  1:     {
  1:         ByteCount byteIndex = 0, glyphIndex = 0;
  1: 
  1:         while(byteIndex < aLen)
  1:         {
  1:             nsBoundingMetrics bounds;
  1:             bounds.leftBearing = rects[glyphIndex].left + FixRound(lefts[glyphIndex]);
  1:             bounds.rightBearing = rects[glyphIndex].right + FixRound(lefts[glyphIndex]);
  1:             bounds.ascent = rects[glyphIndex].bottom;
  1:             bounds.descent = -rects[glyphIndex].top;
  1:             bounds.width = FixRound(widths[glyphIndex]);
  1: 
  1:             if(glyphIndex == 0)
  1:                 oBoundingMetrics = bounds;
  1:             else
  1:                 oBoundingMetrics += bounds;
  1: 
  1:             // for two byte characters byteIndex will increase by 2
  1:             //   while glyph index will only increase by 1
  1:             if(CharacterByteType((Ptr) buf, byteIndex, aScript) == smFirstByte)
  1:                 byteIndex += 2;
  1:             else
  1:                 byteIndex++;
  1:             glyphIndex++;
  1:         }
  1:     }
  1:     else
  1:     {
  1:         NS_WARNING("OulineMetrics failed");
  1: 
  1:         FontInfo fInfo;
  1:         ::GetFontInfo(&fInfo);
  1: 
  1:         oBoundingMetrics.leftBearing = 0;
  1:         oBoundingMetrics.rightBearing = ::TextWidth(buf, 0, aLen);
  1:         oBoundingMetrics.ascent = fInfo.ascent;
  1:         oBoundingMetrics.descent = fInfo.descent;
  1:         oBoundingMetrics.width = oBoundingMetrics.rightBearing;
  1:     }
  1: 
  1:     if(aLen > STACK_TRESHOLD)
  1:     {
  1:         if(widths)
  1:             nsMemory::Free(widths);
  1:         if(lefts)
  1:             nsMemory::Free(lefts);
  1:         if(rects)
  1:             nsMemory::Free(rects);
  1:     }
  1: }
  1: #endif // MOZ_MATHML
  1: 
  1: //------------------------------------------------------------------------
  1: void nsUnicodeRenderingToolkit :: DrawScriptText(
  1: 	const char* buf, 
  1: 	ByteCount aLen, 
  1: 	PRInt32 x, 
  1: 	PRInt32 y, 
  1: 	short& oWidth)
  1: {
  1: 	::MoveTo(x, y);
  1: 	::DrawText(buf,0,aLen);
  1: 	
  1: 	Point   penLoc;
  1: 	::GetPen(&penLoc);
  1: 	oWidth = penLoc.h - x;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: nsresult 
  1: nsUnicodeRenderingToolkit::GetTextSegmentWidth(
  1: 			const PRUnichar *aString, PRUint32 aLength, 
  1: 			short fontNum, nsUnicodeFontMappingMac& fontMapping, 
  1: 			PRUint32& oWidth)
  1: {
  1:   nsTextDimensions dim;
  1:   nsresult res = GetTextSegmentDimensions(aString, aLength, fontNum, fontMapping, dim);
  1:   oWidth = dim.width;
  1:   return res;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: 
  1: nsresult 
  1: nsUnicodeRenderingToolkit::GetTextSegmentDimensions(
  1:       const PRUnichar *aString, PRUint32 aLength, 
  1:       short fontNum, nsUnicodeFontMappingMac& fontMapping, 
  1:       nsTextDimensions& oDim)
  1: {
  1:   oDim.Clear();
  1:   if(aLength == 0 || fontNum == IGNORABLE_FONT_NUM) 
  1:     return NS_OK;
  1:   NS_PRECONDITION(BAD_FONT_NUM != fontNum, "illegal font num");
  1:   PRUint32 processLen = 0;
  1:   char *heapBuf = nsnull;
  1:   PRUint32 heapBufSize = 0;
  1:   short thisWidth = 0;
  1:   char stackBuf[STACK_TRESHOLD];
  1:   char *buf ;
  1:   ByteCount processBytes;
  1:   ByteCount outLen;
  1:   const short *scriptFallbackFonts = fontMapping.GetScriptFallbackFonts();
  1:   
  1:   ::TextFont(fontNum);
  1:   
  1:   FontInfo fInfo;
  1:   ::GetFontInfo(&fInfo);
  1:   nsTextDimensions segDim;
  1:   segDim.ascent = fInfo.ascent;
  1:   segDim.descent = fInfo.descent;
  1:   oDim.Combine(segDim);
  1:   
  1:   // find buf from stack or heap. We only need to do this once in this function.
  1:   // put this out of the loop for performance...
  1:   ByteCount bufLen = aLength * 2 + 10;
  1:   if (bufLen > STACK_TRESHOLD)
  1:   {
  1:     if (bufLen > heapBufSize)
  1:     {
  1:       if (heapBuf)
  1:         nsMemory::Free(heapBuf);
  1:       heapBuf = (char*) nsMemory::Alloc(bufLen);
  1:       heapBufSize = bufLen;
  1:       if (nsnull == heapBuf) 
  1:         return NS_ERROR_OUT_OF_MEMORY;
  1:     } 
  1:     buf = heapBuf;
  1:   } 
  1:   else 
  1:   {
  1:     bufLen = STACK_TRESHOLD;
  1:     buf = stackBuf;
  1:   }
  1:   do {
  1:     outLen = 0;
  1:     processBytes = 0;
  1: 
  1:     if(fontMapping.ConvertUnicodeToGlyphs(fontNum, aString, aLength - processLen,
  1:             buf, bufLen, outLen, processBytes, 0))
  1:     {
  1:         GetScriptTextWidth(buf, outLen, thisWidth);
  1:       
  1:         segDim.Clear();
  1:         segDim.width = thisWidth;
  1:         oDim.Combine(segDim);
  1:     
  1:         NS_PRECONDITION(0 == (processBytes % 2), "strange conversion result");
  1:     
  1:         PRInt32 processUnicode = processBytes / 2;
  1:         processLen += processUnicode;
  1:         aString += processUnicode;
  1:     }
  1:          
  1:     // Cannot precess by TEC, process one char a time by fallback mechanism
  1:     if (processLen < aLength)
  1:     {
  1:       PRBool fallbackDone = PR_FALSE;
  1:       segDim.Clear();
  1:       
  1:       if (NS_IS_HIGH_SURROGATE(*aString) && 
  1:           ((processLen+1) < aLength) &&
  1:           NS_IS_LOW_SURROGATE(*(aString+1)))
  1:       {
  1:          const nsFont *font = &mGS->mFontMetrics->Font();
  1:          fallbackDone = SurrogateGetDimensions(aString, segDim, fontNum, 
  1:                                                font->size, 
  1:                                                (font->weight > NS_FONT_WEIGHT_NORMAL), 
  1:                                                ((NS_FONT_STYLE_ITALIC ==  font->style) || 
  1:                                                (NS_FONT_STYLE_OBLIQUE ==  font->style)),
  1:                                                mGS->mColor );     
  1:          if (fallbackDone)
  1:          {   
  1:            oDim.Combine(segDim);    
  1:            // for fallback measure/drawing, we always do one char a time.
  1:            aString += 2;
  1:            processLen += 2;
  1:            continue;
  1:          }
  1:       }
  1: #ifndef DISABLE_TEC_FALLBACK
  1:       // Fallback by try different Script code
  1:       if (! IS_SKIP_TEC_FALLBACK(*aString))
  1:         fallbackDone = TECFallbackGetDimensions(aString, segDim, fontNum, fontMapping);
  1: #endif
  1: 
  1:       //
  1:       // We really don't care too much of performance after this
  1:       // This will only be called when we cannot display this character in ANY mac script avaliable
  1:       // 
  1: #ifndef DISABLE_ATSUI_FALLBACK  
  1:       // Fallback by using ATSUI
  1:       if (!fallbackDone)  
  1:       {
  1:         const nsFont *font = &mGS->mFontMetrics->Font();
  1:         fallbackDone = ATSUIFallbackGetDimensions(aString, segDim, fontNum, 
  1:                                                   font->size, 
  1:                                                   (font->weight > NS_FONT_WEIGHT_NORMAL), 
  1:                                                   ((NS_FONT_STYLE_ITALIC ==  font->style) || 
  1:                                                    (NS_FONT_STYLE_OBLIQUE ==  font->style)),
  1:                                                   mGS->mColor );
  1:       }
  1: 
  1: #endif
  1: 		  if(! fallbackDone) {
  1: 		     if(IS_ZERO_WIDTH_CHAR(*aString))
  1: 		     {
  1: 		        fallbackDone = PR_TRUE;
  1: 		     }
  1: 		  }
  1: #ifndef DISABLE_LATIN_FALLBACK
  1:       if (!fallbackDone) 
  1:       {
  1:         fallbackDone = LatinFallbackGetWidth(aString, thisWidth);
  1:         if (fallbackDone)
  1:           segDim.width = thisWidth;
  1:       }
  1: #endif
  1: #ifndef DISABLE_PRECOMPOSEHANGUL_FALLBACK
  1:       if (!fallbackDone)
  1:       {
  1:         fallbackDone = PrecomposeHangulFallbackGetWidth(aString, thisWidth,
  1:                                                         scriptFallbackFonts[smKorean], fontNum);
  1:         if (fallbackDone)
  1:           segDim.width = thisWidth;
  1:       }
  1: #endif
  1: #ifndef DISABLE_TRANSLITERATE_FALLBACK  
  1:       // Fallback to Transliteration
  1:       if (!fallbackDone) 
  1:       {
  1:         fallbackDone = TransliterateFallbackGetWidth(aString, thisWidth);
  1:         if (fallbackDone)
  1:           segDim.width = thisWidth;
  1:       }
  1: #endif
  1: #ifndef DISABLE_UPLUS_FALLBACK  
  1:       // Fallback to UPlus
  1:       if (!fallbackDone)
  1:       {
  1:         fallbackDone = UPlusFallbackGetWidth(aString, thisWidth);
  1:         if (fallbackDone)
  1:           segDim.width = thisWidth;
  1:       }
  1: #endif
  1:         
  1:       // Fallback to question mark
  1:       if (!fallbackDone) 
  1:       {
  1:         QuestionMarkFallbackGetWidth(aString, thisWidth);
  1:         if (fallbackDone)
  1:           segDim.width = thisWidth;
  1:       }
  1:       
  1:       oDim.Combine(segDim);    
  1:       // for fallback measure/drawing, we always do one char a time.
  1:       aString++;
  1:       processLen++;
  1:     }
  1:   } while (processLen < aLength);
  1:     
  1:     // release buffer if it is from heap
  1:   if (heapBuf)
  1:     nsMemory::Free(heapBuf);
  1:       
  1:   return NS_OK;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: #ifdef MOZ_MATHML
  1: nsresult
  1: nsUnicodeRenderingToolkit::GetTextSegmentBoundingMetrics(
  1:       const PRUnichar *aString, PRUint32 aLength,
  1:       short fontNum, nsUnicodeFontMappingMac& fontMapping,
  1:       nsBoundingMetrics& oBoundingMetrics)
  1: {
  1:   oBoundingMetrics.Clear();
  1:   if(aLength == 0 || fontNum == IGNORABLE_FONT_NUM) 
  1:     return NS_OK;
  1:   NS_PRECONDITION(BAD_FONT_NUM != fontNum, "illegal font num");
  1:   PRBool firstTime = PR_TRUE;
  1:   PRUint32 processLen = 0;
  1:   nsBoundingMetrics segBoundingMetrics;
  1:   char *heapBuf = nsnull;
  1:   PRUint32 heapBufSize = 0;
  1:   char stackBuf[STACK_TRESHOLD];
  1:   char *buf;
  1:   ByteCount processBytes;
  1:   ByteCount outLen;
  1:   
  1:   ::TextFont(fontNum);
  1:   ScriptCode script = ::FontToScript(fontNum);
  1:   
  1:   // find buf from stack or heap. We only need to do this once in this function.
  1:   // put this out of the loop for performance...
  1:   ByteCount bufLen = aLength * 2 + 10;
  1:   if (bufLen > STACK_TRESHOLD)
  1:   {
  1:     if (bufLen > heapBufSize)
  1:     {
  1:       if (heapBuf)
  1:         nsMemory::Free(heapBuf);
  1:       heapBuf = (char*) nsMemory::Alloc(bufLen);
  1:       heapBufSize = bufLen;
  1:       if (nsnull == heapBuf) 
  1:         return NS_ERROR_OUT_OF_MEMORY;
  1:     } 
  1:     buf = heapBuf;
  1:   } 
  1:   else 
  1:   {
  1:     bufLen = STACK_TRESHOLD;
  1:     buf = stackBuf;
  1:   }
  1: 
  1:   do {
  1:     outLen = 0;
  1:     processBytes = 0;
  1:         
  1:     if(fontMapping.ConvertUnicodeToGlyphs(fontNum, aString, aLength - processLen,
  1:         buf, bufLen, outLen, processBytes, 0))
  1:     {
  1:         segBoundingMetrics.Clear();
  1:         GetScriptTextBoundingMetrics(buf, outLen, script, segBoundingMetrics);
  1:         
  1:         if(firstTime) {
  1:             firstTime = PR_FALSE;
  1:             oBoundingMetrics = segBoundingMetrics;
  1:         }
  1:         else
  1:             oBoundingMetrics += segBoundingMetrics;
  1:         
  1:         NS_PRECONDITION(0 == (processBytes % 2), "strange conversion result");
  1:         
  1:         PRInt32 processUnicode = processBytes / 2;
  1:         processLen += processUnicode;
  1:         aString += processUnicode;
  1:     }
  1:     
  1:     // Cannot process by TEC, process one char a time by fallback mechanism
  1:     if (processLen < aLength)
  1:     {
  1:       PRBool fallbackDone = PR_FALSE;
  1:       segBoundingMetrics.Clear();
  1: 
  1:       if (NS_IS_HIGH_SURROGATE(*aString) && 
  1:           ((processLen+1) < aLength) &&
  1:           NS_IS_LOW_SURROGATE(*(aString+1)) )
  1:       {
  1:          const nsFont *font = &mGS->mFontMetrics->Font();
  1:          fallbackDone = SurrogateGetBoundingMetrics(aString, segBoundingMetrics, fontNum, 
  1:                                                     font->size, 
  1:                                                     (font->weight > NS_FONT_WEIGHT_NORMAL), 
  1:                                                     ((NS_FONT_STYLE_ITALIC ==  font->style) || 
  1:                                                      (NS_FONT_STYLE_OBLIQUE ==  font->style)),
  1:                                                      mGS->mColor );
  1:          if (fallbackDone)
  1:          {      
  1:            if (firstTime) {
  1:              firstTime = PR_FALSE;
  1:              oBoundingMetrics = segBoundingMetrics;
  1:            }
  1:            else
  1:              oBoundingMetrics += segBoundingMetrics;
  1:            aString += 2;
  1:            processLen += 2;
  1:            continue;
  1:          }
  1:       }
  1: #ifndef DISABLE_TEC_FALLBACK
  1:       if (! IS_SKIP_TEC_FALLBACK(*aString))
  1:         fallbackDone = TECFallbackGetBoundingMetrics(aString, segBoundingMetrics, fontNum, fontMapping);
  1: #endif
  1: 
  1: #ifndef DISABLE_ATSUI_FALLBACK  
  1:       // Fallback by using ATSUI
  1:       if (!fallbackDone)  
  1:       {
  1:         const nsFont *font = &mGS->mFontMetrics->Font();
  1:         fallbackDone = ATSUIFallbackGetBoundingMetrics(aString, segBoundingMetrics, fontNum, 
  1:                                                   font->size, 
  1:                                                   (font->weight > NS_FONT_WEIGHT_NORMAL), 
  1:                                                   ((NS_FONT_STYLE_ITALIC ==  font->style) || 
  1:                                                    (NS_FONT_STYLE_OBLIQUE ==  font->style)),
  1:                                                   mGS->mColor );
  1:       }
  1: 
  1: #endif
  1:       if(! fallbackDone) {
  1:          if(IS_ZERO_WIDTH_CHAR(*aString))
  1:          {
  1:            fallbackDone = PR_TRUE;
  1:          }
  1:       }
  1: 
  1:       if (firstTime) {
  1:         firstTime = PR_FALSE;
  1:         oBoundingMetrics = segBoundingMetrics;
  1:       }
  1:       else
  1:         oBoundingMetrics += segBoundingMetrics;
  1:       // for fallback measure/drawing, we always do one char a time.
  1:       aString++;
  1:       processLen++;
  1:     }
  1:   } while (processLen < aLength);
  1:   
  1:   // release buffer if it is from heap
  1:   if (heapBuf)
  1:     nsMemory::Free(heapBuf);
  1:   
  1:   return NS_OK;
  1: }
  1: #endif // MOZ_MATHML
  1: //------------------------------------------------------------------------
  1: 
  1: 
  1: nsresult nsUnicodeRenderingToolkit :: DrawTextSegment(
  1: 			const PRUnichar *aString, PRUint32 aLength, 
  1: 			short fontNum, nsUnicodeFontMappingMac& fontMapping, 
  1: 			PRInt32 x, PRInt32 y, PRUint32& oWidth)
  1: {
  1: 	if(aLength == 0 || fontNum == IGNORABLE_FONT_NUM) {
  1: 		oWidth = 0;
  1: 		return NS_OK;
  1: 	}	
  1:  	NS_PRECONDITION(BAD_FONT_NUM != fontNum, "illegal font num");
  1:     short textWidth = 0;
  1:     PRUint32 processLen = 0;
  1:     char *heapBuf = nsnull;
  1:     PRUint32 heapBufSize = 0;
  1:     short thisWidth = 0;
  1:     char stackBuf[STACK_TRESHOLD];
  1:     char *buf ;
  1:     ByteCount processBytes;
  1:     ByteCount outLen;
  1:   	const short *scriptFallbackFonts = fontMapping.GetScriptFallbackFonts();
  1: 
  1:     ::TextFont(fontNum);
  1:   	
  1:   	// find buf from stack or heap. We only need to do this once in this function.
  1:   	// put this out of the loop for performance...
  1:   	ByteCount bufLen = aLength * 2 + 10;
  1:   	if( bufLen > STACK_TRESHOLD)
  1:   	{
  1:   	 	if(bufLen > heapBufSize )
  1:   	 	{
  1:   	 		if(heapBuf)
  1:   	 			delete[] heapBuf;
  1:   	 		heapBuf = new char [bufLen];
  1:   	 		heapBufSize = bufLen;
  1:   	 		if(nsnull == heapBuf) {
  1:   	 			return NS_ERROR_OUT_OF_MEMORY;
  1:   	 		}  	  	 		
  1:   	 	} 
  1:   	 	buf = heapBuf;
  1:   	 } else {
  1:   	 	bufLen = STACK_TRESHOLD;
  1:   	 	buf = stackBuf;
  1:   	}
  1: 
  1:     do {
  1:       outLen = 0;
  1:       processBytes = 0;
  1:         
  1:       if(fontMapping.ConvertUnicodeToGlyphs(fontNum, aString, aLength - processLen,
  1:                 buf, bufLen, outLen, processBytes, 0))
  1:       {
  1:         DrawScriptText(buf, outLen, x, y, thisWidth);
  1:         
  1:         textWidth += thisWidth;
  1:         x += thisWidth;			
  1:         
  1:         NS_PRECONDITION(0 == (processBytes % 2), "strange conversion result");
  1:         
  1:         PRInt32 processUnicode = processBytes / 2;
  1:         processLen += processUnicode;
  1:         aString += processUnicode;
  1:       }
  1:   	  	 
  1:   	  // Cannot precess by TEC, process one char a time by fallback mechanism
  1:   	  if( processLen < aLength)
  1:   	  {
  1: 		  PRBool fallbackDone = PR_FALSE;
  1: 
  1:       if (NS_IS_HIGH_SURROGATE(*aString) && 
  1:           ((processLen+1) < aLength) &&
  1:           NS_IS_LOW_SURROGATE(*(aString+1)) )
  1:       {
  1:          const nsFont *font = &mGS->mFontMetrics->Font();
  1:          fallbackDone = SurrogateDrawChar(aString, x, y, thisWidth, fontNum, 
  1:                                           font->size, 
  1:                                           (font->weight > NS_FONT_WEIGHT_NORMAL), 
  1:                                           ((NS_FONT_STYLE_ITALIC ==  font->style) || (NS_FONT_STYLE_OBLIQUE ==  font->style)),
  1:                                           mGS->mColor ); 
  1:          if (fallbackDone)
  1:          {      
  1:            textWidth += thisWidth;
  1:            x += thisWidth;         
  1:            aString += 2;
  1:            processLen += 2;
  1:            continue;
  1:          }
  1:       }
  1: #ifndef DISABLE_TEC_FALLBACK
  1: 		  // Fallback by try different Script code
  1: 		  if (! IS_SKIP_TEC_FALLBACK(*aString))
  1:   		  fallbackDone = TECFallbackDrawChar(aString, x, y, thisWidth, fontNum, fontMapping);
  1: #endif
  1: 		  //
  1: 		  // We really don't care too much of performance after this
  1: 		  // This will only be called when we cannot display this character in ANY mac script avaliable
  1: 		  // 
  1: 
  1: #ifndef DISABLE_ATSUI_FALLBACK  
  1: 		  // Fallback by using ATSUI
  1: 		  if(! fallbackDone)  {
  1: 		  	const nsFont *font = &mGS->mFontMetrics->Font();
  1: 		  	fallbackDone = ATSUIFallbackDrawChar(aString, x, y, thisWidth, fontNum, 
  1: 									  		font->size, 
  1: 									  		(font->weight > NS_FONT_WEIGHT_NORMAL), 
  1: 									  		((NS_FONT_STYLE_ITALIC ==  font->style) || (NS_FONT_STYLE_OBLIQUE ==  font->style)),
  1: 									  		mGS->mColor );
  1: 		  }
  1: #endif
  1: 		  if(! fallbackDone) {
  1: 		     if(IS_ZERO_WIDTH_CHAR(*aString))
  1: 		     {
  1: 		        thisWidth = 0;
  1: 		        fallbackDone = PR_TRUE;
  1: 		     }
  1: 		  }
  1:       
  1: #ifndef DISABLE_LATIN_FALLBACK
  1: 		  if(! fallbackDone)
  1: 		  	fallbackDone = LatinFallbackDrawChar(aString, x, y, thisWidth);
  1: #endif
  1: #ifndef DISABLE_PRECOMPOSEHANGUL_FALLBACK
  1: 		  if(! fallbackDone)
  1: 		  	fallbackDone = PrecomposeHangulFallbackDrawChar(aString, x, y, thisWidth,scriptFallbackFonts[smKorean], fontNum);
  1: #endif
  1: #ifndef DISABLE_TRANSLITERATE_FALLBACK  
  1: 		  // Fallback to Transliteration
  1: 		  if(! fallbackDone) {
  1: 		  	fallbackDone = TransliterateFallbackDrawChar(aString, x, y, thisWidth);
  1: 		  }
  1: #endif
  1: #ifndef DISABLE_UPLUS_FALLBACK  
  1: 		  // Fallback to U+xxxx
  1: 		  if(! fallbackDone)
  1: 		  	fallbackDone = UPlusFallbackDrawChar(aString, x, y, thisWidth);
  1: #endif
  1: 		  	
  1: 		  // Fallback to question mark
  1: 		  if(! fallbackDone)
  1: 		  	QuestionMarkFallbackDrawChar(aString, x, y, thisWidth);
  1: 		  	
  1: 		  textWidth += thisWidth;
  1:    	  	  x += thisWidth;
  1: 		  
  1: 		  // for fallback measure/drawing, we always do one char a time.
  1: 	  	  aString++;
  1: 	  	  processLen++;
  1: 	  }
  1:     } while (processLen < aLength);
  1:     
  1:     // release buffer if it is from heap
  1:     if(heapBuf)
  1:     	delete[] heapBuf;
  1:     	
  1:     oWidth = textWidth;
  1:     return NS_OK;
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: nsresult 
  1: nsUnicodeRenderingToolkit::GetWidth(const PRUnichar *aString, PRUint32 aLength, 
  1:                                     nscoord &aWidth, PRInt32 *aFontID)
  1: {
  1:   nsTextDimensions dim;
  1: 
  1:   nsresult res = GetTextDimensions(aString, aLength, dim, aFontID);
  1:   aWidth = dim.width;
  1:   return res;
  1: }
  1: 
  1: nsresult 
  1: nsUnicodeRenderingToolkit::GetTextDimensions(const PRUnichar *aString, PRUint32 aLength, 
  1:                                               nsTextDimensions &aDim, PRInt32 *aFontID)
  1: {
  1:   nsresult res = NS_OK;
  1:   nsFontMetricsMac *metrics = (nsFontMetricsMac*) mGS->mFontMetrics;
  1:   nsUnicodeFontMappingMac* fontmap = metrics->GetUnicodeFontMapping();
  1: 
  1:   PRUint32 i;
  1:   short fontNum[2];
  1:   fontNum[0] = fontNum[1] = BAD_FONT_NUM;
  1:   PRUint32 start;
  1:     
  1:   nsTextDimensions textDim;
  1:   nsTextDimensions thisDim;
  1:   
  1:   for(i =0, start = 0; i < aLength; i++)
  1:   {
  1:     fontNum[ i % 2] = fontmap->GetFontID(aString[i]);
  1:     if ((fontNum[0] != fontNum[1]) && (0 != i))
  1:     {  // start new font run...
  1:       thisDim.Clear();
  1:       res =  GetTextSegmentDimensions(aString+start, i - start, fontNum[(i + 1) % 2], *fontmap, thisDim);
  1:       if (NS_FAILED (res)) 
  1:         return res;    
  1:       textDim.Combine(thisDim);
  1:       start = i;
  1:     }
  1:   }
  1:   res = GetTextSegmentDimensions(aString+start, aLength - start, fontNum[(i + 1) % 2], *fontmap, thisDim);
  1:   if (NS_FAILED (res)) 
  1:     return res;    
  1:   textDim.Combine(thisDim);
  1: 
  1:   aDim.width = NSToCoordRound(float(textDim.width) * mP2T);
  1:   aDim.ascent = NSToCoordRound(float(textDim.ascent) * mP2T);
  1:   aDim.descent = NSToCoordRound(float(textDim.descent) * mP2T);
  1:   return res;  
  1: }
  1: //------------------------------------------------------------------------
  1: 
  1: #ifdef MOZ_MATHML
  1: nsresult
  1: nsUnicodeRenderingToolkit::GetTextBoundingMetrics(const PRUnichar *aString, PRUint32 aLength,
  1:                                                   nsBoundingMetrics &aBoundingMetrics, PRInt32 *aFontID)
  1: {
  1:   nsresult res = NS_OK;
  1:   nsFontMetricsMac *metrics = (nsFontMetricsMac*) mGS->mFontMetrics;
  1:   nsUnicodeFontMappingMac* fontmap = metrics->GetUnicodeFontMapping();
  1: 
  1:   PRUint32 i;
  1:   short fontNum[2];
  1:   fontNum[0] = fontNum[1] = BAD_FONT_NUM;
  1:   PRUint32 start;
  1:   PRBool firstTime = PR_TRUE;
  1:   nsBoundingMetrics thisBoundingMetrics;
  1: 
  1:   for(i =0, start = 0; i < aLength; i++)
  1:   {
  1:     fontNum[ i % 2] = fontmap->GetFontID(aString[i]);
  1:     if ((fontNum[0] != fontNum[1]) && (0 != i))
  1:     {  // start new font run...
  1:       res = GetTextSegmentBoundingMetrics(aString+start, i - start, fontNum[(i + 1) % 2], *fontmap, thisBoundingMetrics);
  1:       if (NS_FAILED (res))
  1:         return res;
  1:       if (firstTime) {
  1:         firstTime = PR_FALSE;
  1:         aBoundingMetrics = thisBoundingMetrics;
  1:       }
  1:       else
  1:         aBoundingMetrics += thisBoundingMetrics;
  1:       start = i;
  1:     }
  1:   }
  1:   res = GetTextSegmentBoundingMetrics(aString+start, aLength - start, fontNum[(i + 1) % 2], *fontmap, thisBoundingMetrics);
  1:   if (NS_FAILED (res))
  1:     return res;
  1:   if (firstTime)
  1:     aBoundingMetrics = thisBoundingMetrics;
  1:   else
  1:     aBoundingMetrics += thisBoundingMetrics;
  1: 
  1:   aBoundingMetrics.leftBearing = NSToCoordRound(float(aBoundingMetrics.leftBearing) * mP2T);
  1:   aBoundingMetrics.rightBearing = NSToCoordRound(float(aBoundingMetrics.rightBearing) * mP2T);
  1:   aBoundingMetrics.ascent = NSToCoordRound(float(aBoundingMetrics.ascent) * mP2T);
  1:   aBoundingMetrics.descent = NSToCoordRound(float(aBoundingMetrics.descent) * mP2T);
  1:   aBoundingMetrics.width = NSToCoordRound(float(aBoundingMetrics.width) * mP2T);
  1: 
  1:   return res;
  1: }
  1: #endif // MOZ_MATHML
  1: 
  1: //------------------------------------------------------------------------
  1: 
  1: nsresult
  1: nsUnicodeRenderingToolkit::DrawString(const PRUnichar *aString, PRUint32 aLength,
  1:                                          nscoord aX, nscoord aY, PRInt32 aFontID,
  1:                                          const nscoord* aSpacing)
  1: {
  1:   nsresult res = NS_OK;
  1:   nsFontMetricsMac *metrics = (nsFontMetricsMac*) mGS->mFontMetrics;
  1:   nsUnicodeFontMappingMac* fontmap = metrics->GetUnicodeFontMapping();
  1: 
  1:   PRInt32 x = aX;
  1:   PRInt32 transformedY = aY;
  1:   mGS->mTMatrix.TransformCoord(&x, &transformedY);
  1: 
  1:   PRUint32 i;
  1:   PRInt32 currentX = aX;
  1:   PRUint32 thisWidth = 0;
  1: 	
  1:   if (aSpacing)
  1:   {
  1:     // fix me ftang -  handle (mRightToLeftText) here
  1:     for (i = 0; i < aLength; )
  1:     {
  1:       PRUint32 drawLen;
  1:       short curFontNum = fontmap->GetFontID(aString[i]);
  1: 
  1:       for (drawLen = 1; (i + drawLen) < aLength; drawLen++)
  1:       {
  1:         PRUnichar uc = aString[i+drawLen];
  1:       	if(! (IS_CONTEXTUAL_CHARS(uc) || 
  1:       		    IS_FORMAT_CONTROL_CHARS(uc) ||
  1:       	      IS_COMBINING_CHARS(uc)) ) {
  1:       	  break;
  1:       	}
  1:       }
  1: 
  1:       PRInt32 transformedX = currentX, ignoreY = 0;
  1:       mGS->mTMatrix.TransformCoord(&transformedX, &ignoreY);
  1:       res = DrawTextSegment(aString+i, drawLen, curFontNum, *fontmap, transformedX, transformedY, thisWidth);
  1: 	    if (NS_FAILED(res))
  1: 	 		  return res;
  1:       
  1:       for (PRUint32 j = 0; j < drawLen; j++)
  1: 	   	  currentX += aSpacing[i + j];
  1: 	   	  
  1: 	   	i += drawLen;
  1:     }
  1:   }
  1:   else    // no spacing array
  1:   {
  1:     short thisFont, nextFont;
  1:     
  1:     PRUint32 start;
  1: 
  1:       // normal left to right
  1:         thisFont = fontmap->GetFontID(aString[0]);
  1: 	    for (i = 1, start = 0; i < aLength; i++)
  1: 	    {
  1: 	    	PRUnichar uch = aString[i];
  1: 	    	if(! IS_FORMAT_CONTROL_CHARS(uch))
  1: 	    	{
  1: 	    		nextFont = fontmap->GetFontID(uch);
  1: 	    		if (thisFont != nextFont) 
  1: 	        {
  1: 	          // start new font run...
  1: 	          PRInt32 transformedX = currentX, ignoreY = 0;
  1: 	          mGS->mTMatrix.TransformCoord(&transformedX, &ignoreY);
  1: 	          
  1:             res = DrawTextSegment(aString + start, i - start, thisFont, *fontmap, transformedX, transformedY, thisWidth);
  1: 	    	  	if (NS_FAILED(res))
  1: 	    	 		  return res;
  1: 	    	 		
  1: 	    		  currentX += NSToCoordRound(float(thisWidth) * mP2T);
  1: 	    		  start = i;
  1: 	    		  thisFont = nextFont;
  1: 	    		}
  1: 	    	}
  1: 	    }
  1: 
  1: 	    PRInt32 transformedX = currentX, ignoreY = 0;
  1: 	    mGS->mTMatrix.TransformCoord(&transformedX, &ignoreY);
  1:       res = DrawTextSegment(aString+start, aLength-start, thisFont, *fontmap, transformedX, transformedY, thisWidth);
  1:     if (NS_FAILED(res))
  1:       return res;
  1:   }
  1:   
  1: 	return NS_OK;
  1: }
  1: 
  1: 
  1: //------------------------------------------------------------------------
  1: nsresult
  1: nsUnicodeRenderingToolkit::PrepareToDraw(float aP2T, nsIDeviceContext* aContext,
  1:                                          nsGraphicState* aGS, 
  1:                                          CGrafPtr aPort, PRBool aRightToLeftText )
  1: {
  1: 	mP2T = aP2T;
  1: 	mContext = aContext;
  1: 	mGS = aGS;
  1: 	mPort = aPort;
  1: 	mRightToLeftText = aRightToLeftText;
  1: 	return NS_OK;
  1: }
