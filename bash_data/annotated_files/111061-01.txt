     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsString.h"
     1: #include "nsIUnicodeEncoder.h"
     1: #include "nsICharsetConverterManager.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsITextToSubURI.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsEscape.h"
     1: #include "prmem.h"
     1: #include "nsTextToSubURI.h"
     1: #include "nsCRT.h"
     1: 
     1: static NS_DEFINE_CID(kCharsetConverterManagerCID, NS_ICHARSETCONVERTERMANAGER_CID);
     1: 
     1: nsTextToSubURI::nsTextToSubURI()
     1: {
     1: }
     1: nsTextToSubURI::~nsTextToSubURI()
     1: {
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS1(nsTextToSubURI, nsITextToSubURI)
     1: 
     1: NS_IMETHODIMP  nsTextToSubURI::ConvertAndEscape(
     1:   const char *charset, const PRUnichar *text, char **_retval) 
     1: {
106838:   if(nullptr == _retval)
     1:     return NS_ERROR_NULL_POINTER;
106838:   *_retval = nullptr;
     1:   nsresult rv = NS_OK;
     1:   
     1:   // Get Charset, get the encoder.
     1:   nsICharsetConverterManager *ccm;
     1:   rv = CallGetService(kCharsetConverterManagerCID, &ccm);
     1:   if(NS_SUCCEEDED(rv)) {
     1:      nsIUnicodeEncoder *encoder;
     1:      rv = ccm->GetUnicodeEncoder(charset, &encoder);
     1:      NS_RELEASE(ccm);
     1:      if (NS_SUCCEEDED(rv)) {
106838:        rv = encoder->SetOutputErrorBehavior(nsIUnicodeEncoder::kOnError_Replace, nullptr, (PRUnichar)'?');
     1:        if(NS_SUCCEEDED(rv))
     1:        {
     1:           char buf[256];
     1:           char *pBuf = buf;
111061:           int32_t ulen = text ? NS_strlen(text) : 0;
108991:           int32_t outlen = 0;
     1:           if(NS_SUCCEEDED(rv = encoder->GetMaxLength(text, ulen, &outlen))) 
     1:           {
     1:              if(outlen >= 256) {
 28381:                 pBuf = (char*)NS_Alloc(outlen+1);
     1:              }
106838:              if(nullptr == pBuf) {
     1:                 outlen = 255;
     1:                 pBuf = buf;
     1:              }
108991:              int32_t bufLen = outlen;
     1:              if(NS_SUCCEEDED(rv = encoder->Convert(text,&ulen, pBuf, &outlen))) {
     1:                 // put termination characters (e.g. ESC(B of ISO-2022-JP) if necessary
108991:                 int32_t finLen = bufLen - outlen;
     1:                 if (finLen > 0) {
     1:                   if (NS_SUCCEEDED(encoder->Finish((char *)(pBuf+outlen), &finLen)))
     1:                     outlen += finLen;
     1:                 }
     1:                 pBuf[outlen] = '\0';
     1:                 *_retval = nsEscape(pBuf, url_XPAlphas);
106838:                 if(nullptr == *_retval)
     1:                   rv = NS_ERROR_OUT_OF_MEMORY;
     1:              }
     1:           }
     1:           if(pBuf != buf)
 28381:              NS_Free(pBuf);
     1:        }
     1:        NS_RELEASE(encoder);
     1:      }
     1:   }
     1:   
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP  nsTextToSubURI::UnEscapeAndConvert(
     1:   const char *charset, const char *text, PRUnichar **_retval) 
     1: {
106838:   if(nullptr == _retval)
     1:     return NS_ERROR_NULL_POINTER;
106838:   if(nullptr == text) {
 34405:     // set empty string instead of returning error
 34405:     // due to compatibility for old version
 34405:     text = "";
 34405:   }
106838:   *_retval = nullptr;
     1:   nsresult rv = NS_OK;
     1:   
     1:   // unescape the string, unescape changes the input
 28381:   char *unescaped = NS_strdup(text);
106838:   if (nullptr == unescaped)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   unescaped = nsUnescape(unescaped);
     1:   NS_ASSERTION(unescaped, "nsUnescape returned null");
     1: 
     1:   // Convert from the charset to unicode
     1:   nsCOMPtr<nsICharsetConverterManager> ccm = 
     1:            do_GetService(kCharsetConverterManagerCID, &rv); 
     1:   if (NS_SUCCEEDED(rv)) {
     1:     nsIUnicodeDecoder *decoder;
     1:     rv = ccm->GetUnicodeDecoder(charset, &decoder);
     1:     if (NS_SUCCEEDED(rv)) {
106838:       PRUnichar *pBuf = nullptr;
108991:       int32_t len = strlen(unescaped);
108991:       int32_t outlen = 0;
     1:       if (NS_SUCCEEDED(rv = decoder->GetMaxLength(unescaped, len, &outlen))) {
 41327:         pBuf = (PRUnichar *) NS_Alloc((outlen+1)*sizeof(PRUnichar));
106838:         if (nullptr == pBuf)
     1:           rv = NS_ERROR_OUT_OF_MEMORY;
     1:         else {
     1:           if (NS_SUCCEEDED(rv = decoder->Convert(unescaped, &len, pBuf, &outlen))) {
     1:             pBuf[outlen] = 0;
     1:             *_retval = pBuf;
     1:           }
     1:           else
 28381:             NS_Free(pBuf);
     1:         }
     1:       }
     1:       NS_RELEASE(decoder);
     1:     }
     1:   }
 28381:   NS_Free(unescaped);
     1: 
     1:   return rv;
     1: }
     1: 
 79445: static bool statefulCharset(const char *charset)
     1: {
     1:   if (!nsCRT::strncasecmp(charset, "ISO-2022-", sizeof("ISO-2022-")-1) ||
     1:       !nsCRT::strcasecmp(charset, "UTF-7") ||
     1:       !nsCRT::strcasecmp(charset, "HZ-GB-2312"))
 80486:     return true;
     1: 
 80486:   return false;
     1: }
     1: 
     1: nsresult nsTextToSubURI::convertURItoUnicode(const nsAFlatCString &aCharset,
     1:                                              const nsAFlatCString &aURI, 
 79445:                                              bool aIRI, 
     1:                                              nsAString &_retval)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
     1:   // check for 7bit encoding the data may not be ASCII after we decode
 79445:   bool isStatefulCharset = statefulCharset(aCharset.get());
     1: 
     1:   if (!isStatefulCharset && IsASCII(aURI)) {
     1:     CopyASCIItoUTF16(aURI, _retval);
     1:     return rv;
     1:   }
     1: 
     1:   if (!isStatefulCharset && aIRI) {
     1:     if (IsUTF8(aURI)) {
     1:       CopyUTF8toUTF16(aURI, _retval);
     1:       return rv;
     1:     }
     1:   }
     1: 
     1:   // empty charset could indicate UTF-8, but aURI turns out not to be UTF-8.
     1:   NS_ENSURE_FALSE(aCharset.IsEmpty(), NS_ERROR_INVALID_ARG);
     1: 
     1:   nsCOMPtr<nsICharsetConverterManager> charsetConverterManager;
     1: 
     1:   charsetConverterManager = do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIUnicodeDecoder> unicodeDecoder;
     1:   rv = charsetConverterManager->GetUnicodeDecoder(aCharset.get(), 
     1:                                                   getter_AddRefs(unicodeDecoder));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
108991:   int32_t srcLen = aURI.Length();
108991:   int32_t dstLen;
     1:   rv = unicodeDecoder->GetMaxLength(aURI.get(), srcLen, &dstLen);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 28381:   PRUnichar *ustr = (PRUnichar *) NS_Alloc(dstLen * sizeof(PRUnichar));
     1:   NS_ENSURE_TRUE(ustr, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   rv = unicodeDecoder->Convert(aURI.get(), &srcLen, ustr, &dstLen);
     1: 
     1:   if (NS_SUCCEEDED(rv))
     1:     _retval.Assign(ustr, dstLen);
     1:   
 28381:   NS_Free(ustr);
     1: 
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP  nsTextToSubURI::UnEscapeURIForUI(const nsACString & aCharset, 
     1:                                                 const nsACString &aURIFragment, 
     1:                                                 nsAString &_retval)
     1: {
110974:   nsAutoCString unescapedSpec;
     1:   // skip control octets (0x00 - 0x1f and 0x7f) when unescaping
     1:   NS_UnescapeURL(PromiseFlatCString(aURIFragment), 
     1:                  esc_SkipControl | esc_AlwaysCopy, unescapedSpec);
     1: 
     1:   // in case of failure, return escaped URI
     1:   // Test for != NS_OK rather than NS_FAILED, because incomplete multi-byte
     1:   // sequences are also considered failure in this context
     1:   if (convertURItoUnicode(
 80486:                 PromiseFlatCString(aCharset), unescapedSpec, true, _retval)
     1:       != NS_OK)
     1:     // assume UTF-8 instead of ASCII  because hostname (IDN) may be in UTF-8
     1:     CopyUTF8toUTF16(aURIFragment, _retval); 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP  nsTextToSubURI::UnEscapeNonAsciiURI(const nsACString & aCharset, 
     1:                                                    const nsACString & aURIFragment, 
     1:                                                    nsAString &_retval)
     1: {
110974:   nsAutoCString unescapedSpec;
     1:   NS_UnescapeURL(PromiseFlatCString(aURIFragment),
     1:                  esc_AlwaysCopy | esc_OnlyNonASCII, unescapedSpec);
 81515:   // leave the URI as it is if it's not UTF-8 and aCharset is not a ASCII
 81515:   // superset since converting "http:" with such an encoding is always a bad 
 81515:   // idea.
 81515:   if (!IsUTF8(unescapedSpec) && 
 81515:       (aCharset.LowerCaseEqualsLiteral("utf-16") ||
 81515:        aCharset.LowerCaseEqualsLiteral("utf-16be") ||
 81515:        aCharset.LowerCaseEqualsLiteral("utf-16le") ||
 81515:        aCharset.LowerCaseEqualsLiteral("utf-7") ||
 81515:        aCharset.LowerCaseEqualsLiteral("x-imap4-modified-utf7"))){
 81515:     CopyASCIItoUTF16(aURIFragment, _retval);
 81515:     return NS_OK;
 81515:   }
     1: 
 80486:   return convertURItoUnicode(PromiseFlatCString(aCharset), unescapedSpec, true, _retval);
     1: }
     1: 
     1: //----------------------------------------------------------------------
