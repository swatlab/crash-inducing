19963: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
19963:  * ***** BEGIN LICENSE BLOCK *****
19963:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19963:  *
19963:  * The contents of this file are subject to the Mozilla Public License Version
19963:  * 1.1 (the "License"); you may not use this file except in compliance with
19963:  * the License. You may obtain a copy of the License at
19963:  * http://www.mozilla.org/MPL/
19963:  *
19963:  * Software distributed under the License is distributed on an "AS IS" basis,
19963:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19963:  * for the specific language governing rights and limitations under the
19963:  * License.
19963:  *
19963:  * The Original Code is thebes gfx code.
19963:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation.
32808:  * Portions created by the Initial Developer are Copyright (C) 2008-2009
19963:  * the Initial Developer. All Rights Reserved.
19963:  *
19963:  * Contributor(s):
19963:  *   John Daggett <jdaggett@mozilla.com>
32808:  *   Jonathan Kew <jfkthame@gmail.com>
19963:  *
19963:  * Alternatively, the contents of this file may be used under the terms of
19963:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19963:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19963:  * in which case the provisions of the GPL or the LGPL are applicable instead
19963:  * of those above. If you wish to allow use of your version of this file only
19963:  * under the terms of either the GPL or the LGPL, and not to allow others to
19963:  * use your version of this file under the terms of the MPL, indicate your
19963:  * decision by deleting the provisions above and replace them with the notice
19963:  * and other provisions required by the GPL or the LGPL. If you do not delete
19963:  * the provisions above, a recipient may use your version of this file under
19963:  * the terms of any one of the MPL, the GPL or the LGPL.
19963:  *
19963:  * ***** END LICENSE BLOCK ***** */
19963: 
19963: #ifdef MOZ_LOGGING
19963: #define FORCE_PR_LOG /* Allow logging in the release build */
19963: #endif /* MOZ_LOGGING */
19963: #include "prlog.h"
19963: 
19963: #include "gfxUserFontSet.h"
19963: #include "gfxPlatform.h"
19963: #include "nsReadableUtils.h"
19963: #include "nsUnicharUtils.h"
19963: #include "prlong.h"
93305: #include "nsNetUtil.h"
93305: #include "nsIProtocolHandler.h"
19963: 
32808: #include "woff.h"
32808: 
55084: #include "opentype-sanitiser.h"
55084: #include "ots-memory-stream.h"
55084: 
55084: using namespace mozilla;
55084: 
19963: #ifdef PR_LOGGING
73711: PRLogModuleInfo *gfxUserFontSet::sUserFontsLog = PR_NewLogModule("userfonts");
19963: #endif /* PR_LOGGING */
19963: 
73711: #define LOG(args) PR_LOG(sUserFontsLog, PR_LOG_DEBUG, args)
73711: #define LOG_ENABLED() PR_LOG_TEST(sUserFontsLog, PR_LOG_DEBUG)
19963: 
19963: static PRUint64 sFontSetGeneration = LL_INIT(0, 0);
19963: 
19963: // TODO: support for unicode ranges not yet implemented
19963: 
19963: gfxProxyFontEntry::gfxProxyFontEntry(const nsTArray<gfxFontFaceSrc>& aFontFaceSrcList,
22397:              gfxMixedFontFamily *aFamily,
19963:              PRUint32 aWeight,
19963:              PRUint32 aStretch,
19963:              PRUint32 aItalicStyle,
58968:              const nsTArray<gfxFontFeature>& aFeatureSettings,
47360:              PRUint32 aLanguageOverride,
19963:              gfxSparseBitSet *aUnicodeRanges)
62296:     : gfxFontEntry(NS_LITERAL_STRING("Proxy"), aFamily),
86676:       mLoadingState(NOT_LOADING),
86676:       mUnsupportedFormat(false)
19963: {
80486:     mIsProxy = true;
19963:     mSrcList = aFontFaceSrcList;
19963:     mSrcIndex = 0;
19963:     mWeight = aWeight;
19963:     mStretch = aStretch;
93220:     mItalic = (aItalicStyle & (NS_FONT_STYLE_ITALIC | NS_FONT_STYLE_OBLIQUE)) != 0;
58968:     mFeatureSettings.AppendElements(aFeatureSettings);
47360:     mLanguageOverride = aLanguageOverride;
80486:     mIsUserFont = true;
19963: }
19963: 
19963: gfxProxyFontEntry::~gfxProxyFontEntry()
19963: {
37211: }
19963: 
37211: gfxFont*
79445: gfxProxyFontEntry::CreateFontInstance(const gfxFontStyle *aFontStyle, bool aNeedsBold)
37211: {
37211:     // cannot create an actual font for a proxy entry
37211:     return nsnull;
19963: }
19963: 
22722: gfxUserFontSet::gfxUserFontSet()
19963: {
19963:     mFontFamilies.Init(5);
19963:     IncrementGeneration();
19963: }
19963: 
19963: gfxUserFontSet::~gfxUserFontSet()
19963: {
19963: }
19963: 
68402: gfxFontEntry*
19963: gfxUserFontSet::AddFontFace(const nsAString& aFamilyName,
19963:                             const nsTArray<gfxFontFaceSrc>& aFontFaceSrcList,
19963:                             PRUint32 aWeight,
19963:                             PRUint32 aStretch,
19963:                             PRUint32 aItalicStyle,
47360:                             const nsString& aFeatureSettings,
47360:                             const nsString& aLanguageOverride,
19963:                             gfxSparseBitSet *aUnicodeRanges)
19963: {
68402:     gfxProxyFontEntry *proxyEntry = nsnull;
68402: 
19963:     nsAutoString key(aFamilyName);
19963:     ToLowerCase(key);
19963: 
79445:     bool found;
19963: 
19963:     if (aWeight == 0)
93220:         aWeight = NS_FONT_WEIGHT_NORMAL;
19963: 
19963:     // stretch, italic/oblique ==> zero implies normal
19963: 
19963:     gfxMixedFontFamily *family = mFontFamilies.GetWeak(key, &found);
19963:     if (!family) {
19963:         family = new gfxMixedFontFamily(aFamilyName);
19963:         mFontFamilies.Put(key, family);
19963:     }
19963: 
19963:     // construct a new face and add it into the family
47360:     nsTArray<gfxFontFeature> featureSettings;
47360:     gfxFontStyle::ParseFontFeatureSettings(aFeatureSettings,
47360:                                            featureSettings);
47360:     PRUint32 languageOverride =
47360:         gfxFontStyle::ParseFontLanguageOverride(aLanguageOverride);
68402:     proxyEntry =
22397:         new gfxProxyFontEntry(aFontFaceSrcList, family, aWeight, aStretch,
47360:                               aItalicStyle,
58968:                               featureSettings,
47360:                               languageOverride,
47360:                               aUnicodeRanges);
19963:     family->AddFontEntry(proxyEntry);
19963: #ifdef PR_LOGGING
19963:     if (LOG_ENABLED()) {
19963:         LOG(("userfonts (%p) added (%s) with style: %s weight: %d stretch: %d",
19963:              this, NS_ConvertUTF16toUTF8(aFamilyName).get(),
93220:              (aItalicStyle & NS_FONT_STYLE_ITALIC ? "italic" :
93220:                  (aItalicStyle & NS_FONT_STYLE_OBLIQUE ? "oblique" : "normal")),
19963:              aWeight, aStretch));
19963:     }
19963: #endif
68402: 
68402:     return proxyEntry;
19963: }
68402: 
68402: void
68402: gfxUserFontSet::AddFontFace(const nsAString& aFamilyName,
68402:                             gfxFontEntry     *aFontEntry)
68402: {
68402:     nsAutoString key(aFamilyName);
68402:     ToLowerCase(key);
68402: 
79445:     bool found;
68402: 
68402:     gfxMixedFontFamily *family = mFontFamilies.GetWeak(key, &found);
68402:     if (!family) {
68402:         family = new gfxMixedFontFamily(aFamilyName);
68402:         mFontFamilies.Put(key, family);
68402:     }
68402: 
68402:     family->AddFontEntry(aFontEntry);
19963: }
19963: 
19963: gfxFontEntry*
19963: gfxUserFontSet::FindFontEntry(const nsAString& aName, 
19963:                               const gfxFontStyle& aFontStyle, 
79445:                               bool& aFoundFamily,
79445:                               bool& aNeedsBold,
79445:                               bool& aWaitForUserFont)
19963: {
80486:     aWaitForUserFont = false;
22397:     gfxMixedFontFamily *family = GetFamily(aName);
19963: 
19963:     // no user font defined for this name
62296:     if (!family) {
80486:         aFoundFamily = false;
19963:         return nsnull;
62296:     }
19963: 
80486:     aFoundFamily = true;
19963:     gfxFontEntry* fe = family->FindFontForStyle(aFontStyle, aNeedsBold);
19963: 
19963:     // if not a proxy, font has already been loaded
62296:     if (!fe->mIsProxy) {
19963:         return fe;
62296:     }
19963: 
19963:     gfxProxyFontEntry *proxyEntry = static_cast<gfxProxyFontEntry*> (fe);
19963: 
19963:     // if currently loading, return null for now
62296:     if (proxyEntry->mLoadingState > gfxProxyFontEntry::NOT_LOADING) {
62296:         aWaitForUserFont =
62296:             (proxyEntry->mLoadingState < gfxProxyFontEntry::LOADING_SLOWLY);
19963:         return nsnull;
62296:     }
19963: 
19963:     // hasn't been loaded yet, start the load process
19963:     LoadStatus status;
19963: 
62416:     // NOTE that if all sources in the entry fail, this will delete proxyEntry,
62416:     // so we cannot use it again if status==STATUS_END_OF_LIST
19963:     status = LoadNext(proxyEntry);
19963: 
19963:     // if the load succeeded immediately, the font entry was replaced so
19963:     // search again
62296:     if (status == STATUS_LOADED) {
19963:         return family->FindFontForStyle(aFontStyle, aNeedsBold);
62296:     }
19963: 
62416:     // check whether we should wait for load to complete before painting
62416:     // a fallback font -- but not if all sources failed (bug 633500)
62416:     aWaitForUserFont = (status != STATUS_END_OF_LIST) &&
62416:         (proxyEntry->mLoadingState < gfxProxyFontEntry::LOADING_SLOWLY);
62416: 
19963:     // if either loading or an error occurred, return null
19963:     return nsnull;
19963: }
19963: 
32808: // Given a buffer of downloaded font data, do any necessary preparation
32808: // to make it into usable OpenType.
32808: // May return the original pointer unchanged, or a newly-allocated
32808: // block (in which case the passed-in block is NS_Free'd).
32808: // aLength is updated if necessary to the new length of the data.
32808: // Returns NULL and NS_Free's the incoming data in case of errors.
55084: static const PRUint8*
32808: PrepareOpenTypeData(const PRUint8* aData, PRUint32* aLength)
32808: {
32808:     switch(gfxFontUtils::DetermineFontDataType(aData, *aLength)) {
19963:     
32808:     case GFX_USERFONT_OPENTYPE:
32808:         // nothing to do
32808:         return aData;
32808:         
32808:     case GFX_USERFONT_WOFF: {
32808:         PRUint32 status = eWOFF_ok;
32808:         PRUint32 bufferSize = woffGetDecodedSize(aData, *aLength, &status);
32808:         if (WOFF_FAILURE(status)) {
32808:             break;
32808:         }
32808:         PRUint8* decodedData = static_cast<PRUint8*>(NS_Alloc(bufferSize));
32808:         if (!decodedData) {
32808:             break;
32808:         }
32808:         woffDecodeToBuffer(aData, *aLength,
32808:                            decodedData, bufferSize,
32808:                            aLength, &status);
32808:         // replace original data with the decoded version
32808:         NS_Free((void*)aData);
32808:         aData = decodedData;
32808:         if (WOFF_FAILURE(status)) {
32808:             // something went wrong, discard the data and return NULL
32808:             break;
32808:         }
32808:         // success, return the decoded data
32808:         return aData;
32808:     }
32808: 
32808:     // xxx - add support for other wrappers here
32808: 
32808:     default:
32808:         NS_WARNING("unknown font format");
32808:         break;
32808:     }
32808: 
32808:     // discard downloaded data that couldn't be used
32808:     NS_Free((void*)aData);
32808: 
32808:     return nsnull;
32808: }
32808: 
55084: // Based on ots::ExpandingMemoryStream from ots-memory-stream.h,
55084: // adapted to use Mozilla allocators and to allow the final
55084: // memory buffer to be adopted by the client.
55084: class ExpandingMemoryStream : public ots::OTSStream {
55084: public:
55084:     ExpandingMemoryStream(size_t initial, size_t limit)
55084:         : mLength(initial), mLimit(limit), mOff(0) {
55084:         mPtr = NS_Alloc(mLength);
55084:     }
55084: 
55084:     ~ExpandingMemoryStream() {
55084:         NS_Free(mPtr);
55084:     }
55084: 
55084:     // return the buffer, and give up ownership of it
55084:     // so the caller becomes responsible to call NS_Free
55084:     // when finished with it
55084:     void* forget() {
55084:         void* p = mPtr;
55084:         mPtr = nsnull;
55084:         return p;
55084:     }
55084: 
55084:     bool WriteRaw(const void *data, size_t length) {
55084:         if ((mOff + length > mLength) ||
55084:             (mLength > std::numeric_limits<size_t>::max() - mOff)) {
55084:             if (mLength == mLimit) {
55084:                 return false;
55084:             }
55084:             size_t newLength = (mLength + 1) * 2;
55084:             if (newLength < mLength) {
55084:                 return false;
55084:             }
55084:             if (newLength > mLimit) {
55084:                 newLength = mLimit;
55084:             }
55084:             mPtr = NS_Realloc(mPtr, newLength);
55084:             mLength = newLength;
55084:             return WriteRaw(data, length);
55084:         }
55084:         std::memcpy(static_cast<char*>(mPtr) + mOff, data, length);
55084:         mOff += length;
55084:         return true;
55084:     }
55084: 
55084:     bool Seek(off_t position) {
55084:         if (position < 0) {
55084:             return false;
55084:         }
55084:         if (static_cast<size_t>(position) > mLength) {
55084:             return false;
55084:         }
55084:         mOff = position;
55084:         return true;
55084:     }
55084: 
55084:     off_t Tell() const {
55084:         return mOff;
55084:     }
55084: 
55084: private:
55084:     void*        mPtr;
55084:     size_t       mLength;
55084:     const size_t mLimit;
55084:     off_t        mOff;
55084: };
55084: 
55084: // Call the OTS library to sanitize an sfnt before attempting to use it.
55084: // Returns a newly-allocated block, or NULL in case of fatal errors.
55084: static const PRUint8*
55084: SanitizeOpenTypeData(const PRUint8* aData, PRUint32 aLength,
55084:                      PRUint32& aSaneLength, bool aIsCompressed)
55084: {
55084:     // limit output/expansion to 256MB
55084:     ExpandingMemoryStream output(aIsCompressed ? aLength * 2 : aLength,
55084:                                  1024 * 1024 * 256);
84391: #ifdef MOZ_GRAPHITE
84391: #define PRESERVE_GRAPHITE true
84391: #else
84391: #define PRESERVE_GRAPHITE false
84391: #endif
84391:     if (ots::Process(&output, aData, aLength, PRESERVE_GRAPHITE)) {
55084:         aSaneLength = output.Tell();
55084:         return static_cast<PRUint8*>(output.forget());
55084:     } else {
55084:         aSaneLength = 0;
55084:         return nsnull;
55084:     }
55084: }
55084: 
71911: static void
71913: StoreUserFontData(gfxFontEntry* aFontEntry, gfxProxyFontEntry* aProxy,
71914:                   const nsAString& aOriginalName,
71913:                   nsTArray<PRUint8>* aMetadata, PRUint32 aMetaOrigLen)
71911: {
71911:     if (!aFontEntry->mUserFontData) {
71911:         aFontEntry->mUserFontData = new gfxUserFontData;
71911:     }
71911:     gfxUserFontData* userFontData = aFontEntry->mUserFontData;
71911:     userFontData->mSrcIndex = aProxy->mSrcIndex;
71911:     const gfxFontFaceSrc& src = aProxy->mSrcList[aProxy->mSrcIndex];
71911:     if (src.mIsLocal) {
71911:         userFontData->mLocalName = src.mLocalName;
71911:     } else {
71911:         userFontData->mURI = src.mURI;
71911:     }
71911:     userFontData->mFormat = src.mFormatFlags;
71914:     userFontData->mRealName = aOriginalName;
71913:     if (aMetadata) {
71913:         userFontData->mMetadata.SwapElements(*aMetadata);
71913:         userFontData->mMetaOrigLen = aMetaOrigLen;
71913:     }
71913: }
71913: 
71913: struct WOFFHeader {
71913:     AutoSwap_PRUint32 signature;
71913:     AutoSwap_PRUint32 flavor;
71913:     AutoSwap_PRUint32 length;
71913:     AutoSwap_PRUint16 numTables;
71913:     AutoSwap_PRUint16 reserved;
71913:     AutoSwap_PRUint32 totalSfntSize;
71913:     AutoSwap_PRUint16 majorVersion;
71913:     AutoSwap_PRUint16 minorVersion;
71913:     AutoSwap_PRUint32 metaOffset;
71913:     AutoSwap_PRUint32 metaCompLen;
71913:     AutoSwap_PRUint32 metaOrigLen;
71913:     AutoSwap_PRUint32 privOffset;
71913:     AutoSwap_PRUint32 privLen;
71913: };
91871: 
91871: void
91871: gfxUserFontSet::CopyWOFFMetadata(const PRUint8* aFontData,
91871:                                  PRUint32 aLength,
91871:                                  nsTArray<PRUint8>* aMetadata,
91871:                                  PRUint32* aMetaOrigLen)
91871: {
91871:     // This function may be called with arbitrary, unvalidated "font" data
91871:     // from @font-face, so it needs to be careful to bounds-check, etc.,
91871:     // before trying to read anything.
91871:     // This just saves a copy of the compressed data block; it does NOT check
91871:     // that the block can be successfully decompressed, or that it contains
91871:     // well-formed/valid XML metadata.
71913:     if (aLength < sizeof(WOFFHeader)) {
71913:         return;
71913:     }
71913:     const WOFFHeader* woff = reinterpret_cast<const WOFFHeader*>(aFontData);
71913:     PRUint32 metaOffset = woff->metaOffset;
71913:     PRUint32 metaCompLen = woff->metaCompLen;
71913:     if (!metaOffset || !metaCompLen || !woff->metaOrigLen) {
71913:         return;
71913:     }
71913:     if (metaOffset >= aLength || metaCompLen > aLength - metaOffset) {
71913:         return;
71913:     }
71913:     if (!aMetadata->SetLength(woff->metaCompLen)) {
71913:         return;
71913:     }
71913:     memcpy(aMetadata->Elements(), aFontData + metaOffset, metaCompLen);
71913:     *aMetaOrigLen = woff->metaOrigLen;
71911: }
71911: 
32808: // This is called when a font download finishes.
32808: // Ownership of aFontData passes in here, and the font set must
32808: // ensure that it is eventually deleted via NS_Free().
79445: bool
69055: gfxUserFontSet::OnLoadComplete(gfxProxyFontEntry *aProxy,
21067:                                const PRUint8 *aFontData, PRUint32 aLength,
19963:                                nsresult aDownloadStatus)
19963: {
19963:     // download successful, make platform font using font data
19963:     if (NS_SUCCEEDED(aDownloadStatus)) {
93305:         gfxFontEntry *fe = LoadFont(aProxy, aFontData, aLength);
93308:         aFontData = nsnull;
93305: 
93305:         if (fe) {
93305:             IncrementGeneration();
93305:             return true;
93305:         }
93305: 
93305:     } else {
93305:         // download failed
93305:         LogMessage(aProxy, "download failed", nsIScriptError::errorFlag,
93305:                    aDownloadStatus);
93305:     }
93305: 
93305:     if (aFontData) {
93305:         NS_Free((void*)aFontData);
93305:     }
93305: 
93305:     // error occurred, load next src
93305:     (void)LoadNext(aProxy);
93305: 
93305:     // We ignore the status returned by LoadNext();
93305:     // even if loading failed, we need to bump the font-set generation
93305:     // and return true in order to trigger reflow, so that fallback
93305:     // will be used where the text was "masked" by the pending download
93305:     IncrementGeneration();
93305:     return true;
93305: }
93305: 
93305: 
93305: gfxUserFontSet::LoadStatus
93305: gfxUserFontSet::LoadNext(gfxProxyFontEntry *aProxyEntry)
93305: {
93305:     PRUint32 numSrc = aProxyEntry->mSrcList.Length();
93305: 
93305:     NS_ASSERTION(aProxyEntry->mSrcIndex < numSrc,
93305:                  "already at the end of the src list for user font");
93305: 
93305:     if (aProxyEntry->mLoadingState == gfxProxyFontEntry::NOT_LOADING) {
93305:         aProxyEntry->mLoadingState = gfxProxyFontEntry::LOADING_STARTED;
93305:         aProxyEntry->mUnsupportedFormat = false;
93305:     } else {
93305:         // we were already loading; move to the next source,
93305:         // but don't reset state - if we've already timed out,
93305:         // that counts against the new download
93305:         aProxyEntry->mSrcIndex++;
93305:     }
93305: 
93305:     // load each src entry in turn, until a local face is found
93305:     // or a download begins successfully
93305:     while (aProxyEntry->mSrcIndex < numSrc) {
93305:         const gfxFontFaceSrc& currSrc = aProxyEntry->mSrcList[aProxyEntry->mSrcIndex];
93305: 
93305:         // src local ==> lookup and load immediately
93305: 
93305:         if (currSrc.mIsLocal) {
93305:             gfxFontEntry *fe =
93305:                 gfxPlatform::GetPlatform()->LookupLocalFont(aProxyEntry,
93305:                                                             currSrc.mLocalName);
93305:             if (fe) {
93305:                 LOG(("userfonts (%p) [src %d] loaded local: (%s) for (%s) gen: %8.8x\n",
93305:                      this, aProxyEntry->mSrcIndex,
93305:                      NS_ConvertUTF16toUTF8(currSrc.mLocalName).get(),
93305:                      NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get(),
93305:                      PRUint32(mGeneration)));
93305:                 fe->mFeatureSettings.AppendElements(aProxyEntry->mFeatureSettings);
93305:                 fe->mLanguageOverride = aProxyEntry->mLanguageOverride;
93305:                 StoreUserFontData(fe, aProxyEntry, nsString(), nsnull, 0);
93305:                 ReplaceFontEntry(aProxyEntry, fe);
93305:                 return STATUS_LOADED;
93305:             } else {
93305:                 LOG(("userfonts (%p) [src %d] failed local: (%s) for (%s)\n",
93305:                      this, aProxyEntry->mSrcIndex,
93305:                      NS_ConvertUTF16toUTF8(currSrc.mLocalName).get(),
93305:                      NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get()));
93305:             }
93305:         }
93305: 
93305:         // src url ==> start the load process
93305:         else {
93305:             if (gfxPlatform::GetPlatform()->IsFontFormatSupported(currSrc.mURI,
93305:                     currSrc.mFormatFlags)) {
93305: 
93305:                 nsresult rv;
93305:                 bool loadDoesntSpin = false;
93305:                 rv = NS_URIChainHasFlags(currSrc.mURI,
93308:                        nsIProtocolHandler::URI_SYNC_LOAD_IS_OK,
93305:                        &loadDoesntSpin);
93305: 
93308:                 if (NS_SUCCEEDED(rv) && loadDoesntSpin) {
93305:                     PRUint8 *buffer = nsnull;
93305:                     PRUint32 bufferLength = 0;
93305: 
93305:                     // sync load font immediately
93305:                     rv = SyncLoadFontData(aProxyEntry, &currSrc, buffer,
93305:                                           bufferLength);
93305: 
93305:                     if (NS_SUCCEEDED(rv) &&
93308:                         LoadFont(aProxyEntry, buffer, bufferLength)) {
93305:                         return STATUS_LOADED;
93305:                     } else {
93305:                         LogMessage(aProxyEntry, "font load failed",
93305:                                    nsIScriptError::errorFlag, rv);
93305:                     }
93305: 
93305:                 } else {
93305:                     // otherwise load font async
93305:                     rv = StartLoad(aProxyEntry, &currSrc);
94737:                     bool loadOK = NS_SUCCEEDED(rv);
93305: 
93305:                     if (loadOK) {
93305: #ifdef PR_LOGGING
93305:                         if (LOG_ENABLED()) {
93305:                             nsCAutoString fontURI;
93305:                             currSrc.mURI->GetSpec(fontURI);
93305:                             LOG(("userfonts (%p) [src %d] loading uri: (%s) for (%s)\n",
93305:                                  this, aProxyEntry->mSrcIndex, fontURI.get(),
93305:                                  NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get()));
93305:                         }
93305: #endif
93305:                         return STATUS_LOADING;
93305:                     } else {
93305:                         LogMessage(aProxyEntry, "download failed",
93305:                                    nsIScriptError::errorFlag, rv);
93305:                     }
93305:                 }
93305:             } else {
93305:                 // We don't log a warning to the web console yet,
93305:                 // as another source may load successfully
93305:                 aProxyEntry->mUnsupportedFormat = true;
93305:             }
93305:         }
93305: 
93305:         aProxyEntry->mSrcIndex++;
93305:     }
93305: 
93305:     if (aProxyEntry->mUnsupportedFormat) {
93305:         LogMessage(aProxyEntry, "no supported format found",
93305:                    nsIScriptError::warningFlag);
93305:     }
93305: 
93305:     // all src's failed; mark this entry as unusable (so fallback will occur)
93305:     LOG(("userfonts (%p) failed all src for (%s)\n",
93305:         this, NS_ConvertUTF16toUTF8(aProxyEntry->mFamily->Name()).get()));
93305:     aProxyEntry->mLoadingState = gfxProxyFontEntry::LOADING_FAILED;
93305: 
93305:     return STATUS_END_OF_LIST;
93305: }
93305: 
93305: void
93305: gfxUserFontSet::IncrementGeneration()
93305: {
93305:     // add one, increment again if zero
93305:     LL_ADD(sFontSetGeneration, sFontSetGeneration, 1);
93305:     if (LL_IS_ZERO(sFontSetGeneration))
93305:         LL_ADD(sFontSetGeneration, sFontSetGeneration, 1);
93305:     mGeneration = sFontSetGeneration;
93305: }
93305: 
93305: 
93305: gfxFontEntry*
93305: gfxUserFontSet::LoadFont(gfxProxyFontEntry *aProxy,
93308:                          const PRUint8 *aFontData, PRUint32 &aLength)
93305: {
96268:     // if the proxy doesn't belong to a family, we just bail as it won't be
96268:     // accessible/usable anyhow (maybe the font set got modified right as
96268:     // the load was completing?)
96268:     if (!aProxy->Family()) {
96270:         NS_Free(const_cast<PRUint8*>(aFontData));
96268:         return nsnull;
96268:     }
96268: 
32808:     gfxFontEntry *fe = nsnull;
32808: 
71913:     gfxUserFontType fontType =
71913:         gfxFontUtils::DetermineFontDataType(aFontData, aLength);
71913: 
71913:     // Save a copy of the metadata block (if present) for nsIDOMFontFace
71913:     // to use if required. Ownership of the metadata block will be passed
71913:     // to the gfxUserFontData record below.
71913:     // NOTE: after the non-OTS codepath using PrepareOpenTypeData is
71913:     // removed, we should defer this until after we've created the new
71913:     // fontEntry.
71913:     nsTArray<PRUint8> metadata;
71913:     PRUint32 metaOrigLen = 0;
71913:     if (fontType == GFX_USERFONT_WOFF) {
71913:         CopyWOFFMetadata(aFontData, aLength, &metadata, &metaOrigLen);
71913:     }
71913: 
71873:     // Unwrap/decompress/sanitize or otherwise munge the downloaded data
71873:     // to make a usable sfnt structure.
71873: 
71914:     // Because platform font activation code may replace the name table
71914:     // in the font with a synthetic one, we save the original name so that
71914:     // it can be reported via the nsIDOMFontFace API.
71914:     nsAutoString originalFullName;
71914: 
71873:     if (gfxPlatform::GetPlatform()->SanitizeDownloadedFonts()) {
55084:        // Call the OTS sanitizer; this will also decode WOFF to sfnt
55084:         // if necessary. The original data in aFontData is left unchanged.
55084:         PRUint32 saneLen;
55084:         const PRUint8* saneData =
55084:             SanitizeOpenTypeData(aFontData, aLength, saneLen,
55084:                                  fontType == GFX_USERFONT_WOFF);
55084:         if (!saneData) {
73711:             LogMessage(aProxy, "rejected by sanitizer");
55084:         }
55084:         if (saneData) {
71914:             // The sanitizer ensures that we have a valid sfnt and a usable
71914:             // name table, so this should never fail unless we're out of
71914:             // memory, and GetFullNameFromSFNT is not directly exposed to
71914:             // arbitrary/malicious data from the web.
71914:             gfxFontUtils::GetFullNameFromSFNT(saneData, saneLen,
71914:                                               originalFullName);
55084:             // Here ownership of saneData is passed to the platform,
55084:             // which will delete it when no longer required
69055:             fe = gfxPlatform::GetPlatform()->MakePlatformFont(aProxy,
55084:                                                               saneData,
55084:                                                               saneLen);
69196:             if (!fe) {
73711:                 LogMessage(aProxy, "not usable by platform");
55084:             }
55084:         }
55084:     } else {
55084:         // FIXME: this code can be removed once we remove the pref to
55084:         // disable the sanitizer; the PrepareOpenTypeData and
55084:         // ValidateSFNTHeaders functions will then be obsolete.
32808:         aFontData = PrepareOpenTypeData(aFontData, &aLength);
55084: 
55084:         if (aFontData) {
55084:             if (gfxFontUtils::ValidateSFNTHeaders(aFontData, aLength)) {
71914:                 // ValidateSFNTHeaders has checked that we have a valid
71914:                 // sfnt structure and a usable 'name' table
71914:                 gfxFontUtils::GetFullNameFromSFNT(aFontData, aLength,
71914:                                                   originalFullName);
32808:                 // Here ownership of aFontData is passed to the platform,
32808:                 // which will delete it when no longer required
69055:                 fe = gfxPlatform::GetPlatform()->MakePlatformFont(aProxy,
32808:                                                                   aFontData,
32808:                                                                   aLength);
73711:                 if (!fe) {
73711:                     LogMessage(aProxy, "not usable by platform");
73711:                 }
93305:                 aFontData = nsnull; // we must NOT free this!
55084:             } else {
55084:                 // the data was unusable, so just discard it
55084:                 // (error will be reported below, if logging is enabled)
73711:                 LogMessage(aProxy, "SFNT header or tables invalid");
55084:             }
55084:         }
55084:     }
55084: 
55084:     if (aFontData) {
55084:         NS_Free((void*)aFontData);
55084:         aFontData = nsnull;
55084:     }
55084: 
47845:     if (fe) {
55084:         // copy OpenType feature/language settings from the proxy to the
55084:         // newly-created font entry
69055:         fe->mFeatureSettings.AppendElements(aProxy->mFeatureSettings);
69055:         fe->mLanguageOverride = aProxy->mLanguageOverride;
71914:         StoreUserFontData(fe, aProxy, originalFullName,
71914:                           &metadata, metaOrigLen);
19963: #ifdef PR_LOGGING
69055:         // must do this before ReplaceFontEntry() because that will
69055:         // clear the proxy's mFamily pointer!
19963:         if (LOG_ENABLED()) {
19963:             nsCAutoString fontURI;
69055:             aProxy->mSrcList[aProxy->mSrcIndex].mURI->GetSpec(fontURI);
21067:             LOG(("userfonts (%p) [src %d] loaded uri: (%s) for (%s) gen: %8.8x\n",
69055:                  this, aProxy->mSrcIndex, fontURI.get(),
69055:                  NS_ConvertUTF16toUTF8(aProxy->mFamily->Name()).get(),
21067:                  PRUint32(mGeneration)));
19963:         }
19963: #endif
69055:         ReplaceFontEntry(aProxy, fe);
19963:     } else {
19963: #ifdef PR_LOGGING
19963:         if (LOG_ENABLED()) {
19963:             nsCAutoString fontURI;
69055:             aProxy->mSrcList[aProxy->mSrcIndex].mURI->GetSpec(fontURI);
93305:             LOG(("userfonts (%p) [src %d] failed uri: (%s) for (%s)"
93305:                  " error making platform font\n",
69055:                  this, aProxy->mSrcIndex, fontURI.get(),
69055:                  NS_ConvertUTF16toUTF8(aProxy->mFamily->Name()).get()));
19963:         }
19963: #endif
19963:     }
19963: 
93305:     return fe;
55084: }
55084: 
22397: gfxMixedFontFamily*
22397: gfxUserFontSet::GetFamily(const nsAString& aFamilyName) const
22397: {
22397:     nsAutoString key(aFamilyName);
22397:     ToLowerCase(key);
22397: 
22397:     return mFontFamilies.GetWeak(key);
22397: }
93305: 
