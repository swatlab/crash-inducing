84016: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
84016:  * ***** BEGIN LICENSE BLOCK *****
84016:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
84016:  *
84016:  * The contents of this file are subject to the Mozilla Public License Version
84016:  * 1.1 (the "License"); you may not use this file except in compliance with
84016:  * the License. You may obtain a copy of the License at
84016:  * http://www.mozilla.org/MPL/
84016:  *
84016:  * Software distributed under the License is distributed on an "AS IS" basis,
84016:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
84016:  * for the specific language governing rights and limitations under the
84016:  * License.
84016:  *
84016:  * The Original Code is Mozilla Android code.
84016:  *
84016:  * The Initial Developer of the Original Code is Mozilla Foundation.
84016:  * Portions created by the Initial Developer are Copyright (C) 2011
84016:  * the Initial Developer. All Rights Reserved.
84016:  *
84016:  * Contributor(s):
84016:  *   Mounir Lamouri <mounir.lamouri@mozilla.com> (Original Author)
84016:  *
84016:  * Alternatively, the contents of this file may be used under the terms of
84016:  * either the GNU General Public License Version 2 or later (the "GPL"), or
84016:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
84016:  * in which case the provisions of the GPL or the LGPL are applicable instead
84016:  * of those above. If you wish to allow use of your version of this file only
84016:  * under the terms of either the GPL or the LGPL, and not to allow others to
84016:  * use your version of this file under the terms of the MPL, indicate your
84016:  * decision by deleting the provisions above and replace them with the notice
84016:  * and other provisions required by the GPL or the LGPL. If you do not delete
84016:  * the provisions above, a recipient may use your version of this file under
84016:  * the terms of any one of the MPL, the GPL or the LGPL.
84016:  *
84016:  * ***** END LICENSE BLOCK ***** */
84016: 
84016: package org.mozilla.gecko;
84016: 
84016: import java.util.ArrayList;
87520: import java.util.Iterator;
84016: 
84016: import android.util.Log;
84016: 
87520: import android.app.PendingIntent;
87520: import android.app.Activity;
87520: 
87533: import android.database.Cursor;
87533: 
84016: import android.content.Intent;
87554: import android.content.IntentFilter;
84016: import android.content.BroadcastReceiver;
84016: import android.content.Context;
87522: import android.content.ContentResolver;
87522: import android.content.ContentValues;
87522: import android.content.ContentUris;
87522: 
87522: import android.net.Uri;
84016: 
84016: import android.os.Bundle;
87532: import android.os.Handler;
87532: import android.os.Looper;
84016: 
84016: import android.telephony.SmsManager;
84016: import android.telephony.SmsMessage;
84016: 
87520: /**
87520:  * This class is returning unique ids for PendingIntent requestCode attribute.
87520:  * There are only |Integer.MAX_VALUE - Integer.MIN_VALUE| unique IDs available,
87520:  * and they wrap around.
87520:  */
87520: class PendingIntentUID
87520: {
87520:   static private int sUID = Integer.MIN_VALUE;
87520: 
87520:   static public int generate() { return sUID++; }
87520: }
87520: 
87520: /**
87520:  * The envelope class contains all information that are needed to keep track of
87520:  * a sent SMS.
87520:  */
87520: class Envelope
87520: {
87525:   enum SubParts {
87525:     SENT_PART,
87525:     DELIVERED_PART
87525:   }
87525: 
87520:   protected int       mId;
87525:   protected int       mMessageId;
87525:   protected long      mMessageTimestamp;
87525: 
87525:   /**
87525:    * Number of sent/delivered remaining parts.
87525:    * @note The array has much slots as SubParts items.
87525:    */
87525:   protected int[]     mRemainingParts;
87525: 
87525:   /**
87525:    * Whether sending/delivering is currently failing.
87525:    * @note The array has much slots as SubParts items.
87525:    */
87525:   protected boolean[] mFailing;
87520: 
87529:   /**
87529:    * Error type (only for sent).
87529:    */
87529:   protected int       mError;
87529: 
87520:   public Envelope(int aId, int aParts) {
87520:     mId = aId;
87525:     mMessageId = -1;
87525:     mMessageTimestamp = 0;
87529:     mError = GeckoSmsManager.kNoError;
87525: 
87525:     int size = Envelope.SubParts.values().length;
87525:     mRemainingParts = new int[size];
87525:     mFailing = new boolean[size];
87525: 
87525:     for (int i=0; i<size; ++i) {
87525:       mRemainingParts[i] = aParts;
87525:       mFailing[i] = false;
87525:     }
87520:   }
87520: 
87525:   public void decreaseRemainingParts(Envelope.SubParts aType) {
87525:     --mRemainingParts[aType.ordinal()];
87525: 
87525:     if (mRemainingParts[SubParts.SENT_PART.ordinal()] >
87525:         mRemainingParts[SubParts.DELIVERED_PART.ordinal()]) {
87525:       Log.e("GeckoSmsManager", "Delivered more parts than we sent!?");
87525:     }
87520:   }
87520: 
87525:   public boolean arePartsRemaining(Envelope.SubParts aType) {
87525:     return mRemainingParts[aType.ordinal()] != 0;
87520:   }
87520: 
87525:   public void markAsFailed(Envelope.SubParts aType) {
87525:     mFailing[aType.ordinal()] = true;
87520:   }
87520: 
87525:   public boolean isFailing(Envelope.SubParts aType) {
87525:     return mFailing[aType.ordinal()];
87525:   }
87525: 
87525:   public int getMessageId() {
87525:     return mMessageId;
87525:   }
87525: 
87525:   public void setMessageId(int aMessageId) {
87525:     mMessageId = aMessageId;
87525:   }
87525: 
87525:   public long getMessageTimestamp() {
87525:     return mMessageTimestamp;
87525:   }
87525: 
87525:   public void setMessageTimestamp(long aMessageTimestamp) {
87525:     mMessageTimestamp = aMessageTimestamp;
87520:   }
87529: 
87529:   public int getError() {
87529:     return mError;
87529:   }
87529: 
87529:   public void setError(int aError) {
87529:     mError = aError;
87529:   }
87520: }
87520: 
87520: /**
87520:  * Postman class is a singleton that manages Envelope instances.
87520:  */
87520: class Postman
87520: {
87520:   public static final int kUnknownEnvelopeId = -1;
87520: 
87520:   private static final Postman sInstance = new Postman();
87520: 
87520:   private ArrayList<Envelope> mEnvelopes = new ArrayList<Envelope>(1);
87520: 
87520:   private Postman() {}
87520: 
87520:   public static Postman getInstance() {
87520:     return sInstance;
87520:   }
87520: 
87520:   public int createEnvelope(int aParts) {
87520:     /*
87520:      * We are going to create the envelope in the first empty slot in the array
87520:      * list. If there is no empty slot, we create a new one.
87520:      */
87520:     int size = mEnvelopes.size();
87520: 
87520:     for (int i=0; i<size; ++i) {
87520:       if (mEnvelopes.get(i) == null) {
87520:         mEnvelopes.set(i, new Envelope(i, aParts));
87520:         return i;
87520:       }
87520:     }
87520: 
87520:     mEnvelopes.add(new Envelope(size, aParts));
87520:     return size;
87520:   }
87520: 
87520:   public Envelope getEnvelope(int aId) {
87520:     if (aId < 0 || mEnvelopes.size() <= aId) {
87520:       Log.e("GeckoSmsManager", "Trying to get an unknown Envelope!");
87520:       return null;
87520:     }
87520: 
87520:     Envelope envelope = mEnvelopes.get(aId);
87520:     if (envelope == null) {
87520:       Log.e("GeckoSmsManager", "Trying to get an empty Envelope!");
87520:     }
87520: 
87520:     return envelope;
87520:   }
87520: 
87520:   public void destroyEnvelope(int aId) {
87520:     if (aId < 0 || mEnvelopes.size() <= aId) {
87520:       Log.e("GeckoSmsManager", "Trying to destroy an unknown Envelope!");
87520:       return;
87520:     }
87520: 
87520:     if (mEnvelopes.set(aId, null) == null) {
87520:       Log.e("GeckoSmsManager", "Trying to destroy an empty Envelope!");
87520:     }
87520:   }
87520: }
87520: 
87532: class SmsIOThread extends Thread {
87532:   private final static SmsIOThread sInstance = new SmsIOThread();
87532: 
87532:   private Handler mHandler;
87532: 
87532:   public static SmsIOThread getInstance() {
87532:     return sInstance;
87532:   }
87532: 
87532:   public boolean execute(Runnable r) {
87532:     return mHandler.post(r);
87532:   }
87532: 
87532:   public void run() {
87532:     Looper.prepare();
87532: 
87532:     mHandler = new Handler();
87532: 
87532:     Looper.loop();
87532:   }
87532: }
87532: 
87542: class MessagesListManager
87542: {
87542:   private static final MessagesListManager sInstance = new MessagesListManager();
87542: 
87542:   public static MessagesListManager getInstance() {
87542:     return sInstance;
87542:   }
87542: 
87542:   private ArrayList<Cursor> mCursors = new ArrayList<Cursor>(0);
87542: 
87542:   public int add(Cursor aCursor) {
87542:     int size = mCursors.size();
87542: 
87542:     for (int i=0; i<size; ++i) {
87542:       if (mCursors.get(i) == null) {
87542:         mCursors.set(i, aCursor);
87542:         return i;
87542:       }
87542:     }
87542: 
87542:     mCursors.add(aCursor);
87542:     return size;
87542:   }
87542: 
87542:   public Cursor get(int aId) {
87542:     if (aId < 0 || mCursors.size() <= aId) {
87542:       Log.e("GeckoSmsManager", "Trying to get an unknown list!");
87542:       return null;
87542:     }
87542: 
87542:     Cursor cursor = mCursors.get(aId);
87542:     if (cursor == null) {
87542:       Log.e("GeckoSmsManager", "Trying to get an empty list!");
87542:     }
87542: 
87542:     return cursor;
87542:   }
87542: 
87542:   public void remove(int aId) {
87542:     if (aId < 0 || mCursors.size() <= aId) {
87542:       Log.e("GeckoSmsManager", "Trying to destroy an unknown list!");
87542:       return;
87542:     }
87542: 
87542:     Cursor cursor = mCursors.set(aId, null);
87542:     if (cursor == null) {
87542:       Log.e("GeckoSmsManager", "Trying to destroy an empty list!");
87542:       return;
87542:     }
87542: 
87542:     cursor.close();
87542:   }
87542: 
87542:   public void clear() {
87542:     for (int i=0; i<mCursors.size(); ++i) {
87542:       Cursor c = mCursors.get(i);
87542:       if (c != null) {
87542:         c.close();
87542:       }
87542:     }
87542: 
87542:     mCursors.clear();
87542:   }
87542: }
87542: 
84016: public class GeckoSmsManager
84016:   extends BroadcastReceiver
87554:   implements ISmsManager
84016: {
87520:   public final static String ACTION_SMS_RECEIVED  = "android.provider.Telephony.SMS_RECEIVED";
87520:   public final static String ACTION_SMS_SENT      = "org.mozilla.gecko.SMS_SENT";
87525:   public final static String ACTION_SMS_DELIVERED = "org.mozilla.gecko.SMS_DELIVERED";
87525: 
87529:   /*
87541:    * Make sure that the following error codes are in sync with |ErrorType| in:
87541:    * dom/sms/src/Types.h
87541:    * The error code are owned by the DOM.
87529:    */
87529:   public final static int kNoError       = 0;
87529:   public final static int kNoSignalError = 1;
87534:   public final static int kNotFoundError = 2;
87534:   public final static int kUnknownError  = 3;
87534:   public final static int kInternalError = 4;
87529: 
87533:   private final static int kMaxMessageSize    = 160;
87533: 
87533:   private final static Uri kSmsContentUri     = Uri.parse("content://sms");
87533:   private final static Uri kSmsSentContentUri = Uri.parse("content://sms/sent");
87533: 
87533:   private final static int kSmsTypeInbox      = 1;
87533:   private final static int kSmsTypeSentbox    = 2;
87533: 
87541:   /*
87541:    * Keep the following error codes in syng with |DeliveryState| in:
87541:    * dom/sms/src/Types.h
87541:    */
87541:   private final static int kDeliveryStateSent     = 0;
87541:   private final static int kDeliveryStateReceived = 1;
87541:   private final static int kDeliveryStateUnknown  = 2;
87541:   private final static int kDeliveryStateEndGuard = 3;
87541: 
87541:   private final static String[] kRequiredMessageRows = new String[] { "_id", "address", "body", "date", "type" };
87541: 
88061:   public GeckoSmsManager() {
88061:     SmsIOThread.getInstance().start();
88061:   }
88061: 
88061:   public void start() {
87554:     IntentFilter smsFilter = new IntentFilter();
87554:     smsFilter.addAction(GeckoSmsManager.ACTION_SMS_RECEIVED);
87554:     smsFilter.addAction(GeckoSmsManager.ACTION_SMS_SENT);
87554:     smsFilter.addAction(GeckoSmsManager.ACTION_SMS_DELIVERED);
87554: 
87554:     GeckoApp.mAppContext.registerReceiver(this, smsFilter);
87532:   }
87532: 
84016:   @Override
84016:   public void onReceive(Context context, Intent intent) {
87520:     if (intent.getAction().equals(ACTION_SMS_RECEIVED)) {
84016:       // TODO: Try to find the receiver number to be able to populate
84016:       //       SmsMessage.receiver.
84016:       // TODO: Get the id and the date from the stock app saved message.
84016:       //       Using the stock app saved message require us to wait for it to
84016:       //       be saved which can lead to race conditions.
84016: 
84016:       Bundle bundle = intent.getExtras();
84016: 
84016:       if (bundle == null) {
84016:         return;
84016:       }
84016: 
84016:       Object[] pdus = (Object[]) bundle.get("pdus");
84016: 
84016:       for (int i=0; i<pdus.length; ++i) {
84016:         SmsMessage msg = SmsMessage.createFromPdu((byte[])pdus[i]);
84016: 
84016:         GeckoAppShell.notifySmsReceived(msg.getDisplayOriginatingAddress(),
84016:                                         msg.getDisplayMessageBody(),
84016:                                         System.currentTimeMillis());
84016:       }
87520: 
87520:       return;
87520:     }
87520: 
87525:     if (intent.getAction().equals(ACTION_SMS_SENT) ||
87525:         intent.getAction().equals(ACTION_SMS_DELIVERED)) {
87520:       Bundle bundle = intent.getExtras();
87520: 
87520:       if (bundle == null || !bundle.containsKey("envelopeId") ||
87528:           !bundle.containsKey("number") || !bundle.containsKey("message") ||
87528:           !bundle.containsKey("requestId") || !bundle.containsKey("processId")) {
87528:         Log.e("GeckoSmsManager", "Got an invalid ACTION_SMS_SENT/ACTION_SMS_DELIVERED!");
87520:         return;
87520:       }
87520: 
87520:       int envelopeId = bundle.getInt("envelopeId");
87520:       Postman postman = Postman.getInstance();
87525: 
87520:       Envelope envelope = postman.getEnvelope(envelopeId);
87525:       if (envelope == null) {
87525:         Log.e("GeckoSmsManager", "Got an invalid envelope id (or Envelope has been destroyed)!");
87525:         return;
87525:       }
87520: 
87525:       Envelope.SubParts part = intent.getAction().equals(ACTION_SMS_SENT)
87525:                                  ? Envelope.SubParts.SENT_PART
87525:                                  : Envelope.SubParts.DELIVERED_PART;
87525:       envelope.decreaseRemainingParts(part);
87525:  
87520: 
87520:       if (getResultCode() != Activity.RESULT_OK) {
87529:         switch (getResultCode()) {
87529:           case SmsManager.RESULT_ERROR_NULL_PDU:
87529:             envelope.setError(kInternalError);
87529:             break;
87529:           case SmsManager.RESULT_ERROR_NO_SERVICE:
87529:           case SmsManager.RESULT_ERROR_RADIO_OFF:
87529:             envelope.setError(kNoSignalError);
87529:             break;
87529:           case SmsManager.RESULT_ERROR_GENERIC_FAILURE:
87529:           default:
87529:             envelope.setError(kUnknownError);
87529:             break;
87529:         }
87529:         envelope.markAsFailed(part);
87520:         Log.i("GeckoSmsManager", "SMS part sending failed!");
87520:       }
87520: 
87525:       if (envelope.arePartsRemaining(part)) {
87520:         return;
87520:       }
87520: 
87525:       if (envelope.isFailing(part)) {
87525:         if (part == Envelope.SubParts.SENT_PART) {
87529:           GeckoAppShell.notifySmsSendFailed(envelope.getError(),
87529:                                             bundle.getInt("requestId"),
87529:                                             bundle.getLong("processId"));
87520:           Log.i("GeckoSmsManager", "SMS sending failed!");
87520:         } else {
87525:           // It seems unlikely to get a result code for a failure to deliver.
87525:           // Even if, we don't want to do anything with this.
87525:           Log.e("GeckoSmsManager", "SMS failed to be delivered... is that even possible?");
87525:         }
87525:       } else {
87525:         if (part == Envelope.SubParts.SENT_PART) {
87525:           String number = bundle.getString("number");
87525:           String message = bundle.getString("message");
87525:           long timestamp = System.currentTimeMillis();
87525: 
87525:           int id = GeckoAppShell.saveMessageInSentbox(number, message, timestamp);
87525: 
87528:           GeckoAppShell.notifySmsSent(id, number, message, timestamp,
87528:                                       bundle.getInt("requestId"),
87528:                                       bundle.getLong("processId"));
87525: 
87525:           envelope.setMessageId(id);
87525:           envelope.setMessageTimestamp(timestamp);
87525: 
87525:           Log.i("GeckoSmsManager", "SMS sending was successfull!");
87525:         } else {
87525:           GeckoAppShell.notifySmsDelivered(envelope.getMessageId(),
87525:                                            bundle.getString("number"),
87522:                                            bundle.getString("message"),
87525:                                            envelope.getMessageTimestamp());
87525:           Log.i("GeckoSmsManager", "SMS succesfully delivered!");
87525:         }
87520:       }
87520: 
87525:       // Destroy the envelope object only if the SMS has been sent and delivered.
87525:       if (!envelope.arePartsRemaining(Envelope.SubParts.SENT_PART) &&
87525:           !envelope.arePartsRemaining(Envelope.SubParts.DELIVERED_PART)) {
87520:         postman.destroyEnvelope(envelopeId);
87525:       }
87520: 
87520:       return;
84016:     }
84016:   }
84016: 
87554:   public int getNumberOfMessagesForText(String aText) {
84016:     return SmsManager.getDefault().divideMessage(aText).size();
84016:   }
84016: 
87554:   public void send(String aNumber, String aMessage, int aRequestId, long aProcessId) {
87520:     int envelopeId = Postman.kUnknownEnvelopeId;
87520: 
84016:     try {
84016:       SmsManager sm = SmsManager.getDefault();
84016: 
87520:       Intent sentIntent = new Intent(ACTION_SMS_SENT);
87525:       Intent deliveredIntent = new Intent(ACTION_SMS_DELIVERED);
87525: 
87520:       Bundle bundle = new Bundle();
87520:       bundle.putString("number", aNumber);
87520:       bundle.putString("message", aMessage);
87528:       bundle.putInt("requestId", aRequestId);
87528:       bundle.putLong("processId", aProcessId);
87520: 
84016:       if (aMessage.length() <= kMaxMessageSize) {
87520:         envelopeId = Postman.getInstance().createEnvelope(1);
87525:         bundle.putInt("envelopeId", envelopeId);
87520: 
87520:         sentIntent.putExtras(bundle);
87525:         deliveredIntent.putExtras(bundle);
87520: 
87520:         /*
87520:          * There are a few things to know about getBroadcast and pending intents:
87520:          * - the pending intents are in a shared pool maintained by the system;
87520:          * - each pending intent is identified by a token;
87520:          * - when a new pending intent is created, if it has the same token as
87520:          *   another intent in the pool, one of them has to be removed.
87520:          *
87520:          * To prevent having a hard time because of this situation, we give a
87520:          * unique id to all pending intents we are creating. This unique id is
87520:          * generated by GetPendingIntentUID().
87520:          */
87520:         PendingIntent sentPendingIntent =
87554:           PendingIntent.getBroadcast(GeckoApp.mAppContext,
87520:                                      PendingIntentUID.generate(), sentIntent,
87520:                                      PendingIntent.FLAG_CANCEL_CURRENT);
87520: 
87525:         PendingIntent deliveredPendingIntent =
87554:           PendingIntent.getBroadcast(GeckoApp.mAppContext,
87525:                                      PendingIntentUID.generate(), deliveredIntent,
87525:                                      PendingIntent.FLAG_CANCEL_CURRENT);
87525: 
87525:         sm.sendTextMessage(aNumber, "", aMessage,
87525:                            sentPendingIntent, deliveredPendingIntent);
84016:       } else {
84016:         ArrayList<String> parts = sm.divideMessage(aMessage);
87520:         envelopeId = Postman.getInstance().createEnvelope(parts.size());
87525:         bundle.putInt("envelopeId", envelopeId);
87520: 
87520:         sentIntent.putExtras(bundle);
87525:         deliveredIntent.putExtras(bundle);
87520: 
87520:         ArrayList<PendingIntent> sentPendingIntents =
87520:           new ArrayList<PendingIntent>(parts.size());
87525:         ArrayList<PendingIntent> deliveredPendingIntents =
87525:           new ArrayList<PendingIntent>(parts.size());
87520: 
87520:         for (int i=0; i<parts.size(); ++i) {
87520:           sentPendingIntents.add(
87554:             PendingIntent.getBroadcast(GeckoApp.mAppContext,
87520:                                        PendingIntentUID.generate(), sentIntent,
87520:                                        PendingIntent.FLAG_CANCEL_CURRENT)
87520:           );
87525: 
87525:           deliveredPendingIntents.add(
87554:             PendingIntent.getBroadcast(GeckoApp.mAppContext,
87525:                                        PendingIntentUID.generate(), deliveredIntent,
87525:                                        PendingIntent.FLAG_CANCEL_CURRENT)
87525:           );
87520:         }
87520: 
87525:         sm.sendMultipartTextMessage(aNumber, "", parts, sentPendingIntents,
87525:                                     deliveredPendingIntents);
84016:       }
84016:     } catch (Exception e) {
87520:       Log.e("GeckoSmsManager", "Failed to send an SMS: ", e);
87520: 
87520:       if (envelopeId != Postman.kUnknownEnvelopeId) {
87520:         Postman.getInstance().destroyEnvelope(envelopeId);
84016:       }
87529: 
87529:       GeckoAppShell.notifySmsSendFailed(kUnknownError, aRequestId, aProcessId);
84016:     }
84016:   }
87522: 
87554:   public int saveSentMessage(String aRecipient, String aBody, long aDate) {
87522:     class IdTooHighException extends Exception { }
87522: 
87522:     try {
87522:       ContentValues values = new ContentValues();
87522:       values.put("address", aRecipient);
87522:       values.put("body", aBody);
87522:       values.put("date", aDate);
87522: 
87554:       ContentResolver cr = GeckoApp.mAppContext.getContentResolver();
87533:       Uri uri = cr.insert(kSmsSentContentUri, values);
87522: 
87522:       long id = ContentUris.parseId(uri);
87522: 
87522:       // The DOM API takes a 32bits unsigned int for the id. It's unlikely that
87522:       // we happen to need more than that but it doesn't cost to check.
87522:       if (id > Integer.MAX_VALUE) {
87522:         throw new IdTooHighException();
87520:       }
87522: 
87522:       return (int)id;
87522:     } catch (IdTooHighException e) {
87522:       Log.e("GeckoSmsManager", "The id we received is higher than the higher allowed value.");
87522:       return -1;
87522:     } catch (Exception e) {
87522:       Log.e("GeckoSmsManager", "Something went wrong when trying to write a sent message: " + e);
87522:       return -1;
87522:     }
87522:   }
87532: 
87554:   public void getMessage(int aMessageId, int aRequestId, long aProcessId) {
87533:     class GetMessageRunnable implements Runnable {
87533:       private int mMessageId;
87533:       private int mRequestId;
87533:       private long mProcessId;
87533: 
87533:       GetMessageRunnable(int aMessageId, int aRequestId, long aProcessId) {
87533:         mMessageId = aMessageId;
87533:         mRequestId = aRequestId;
87533:         mProcessId = aProcessId;
87533:       }
87533: 
87533:       @Override
87533:       public void run() {
87533:         class NotFoundException extends Exception { }
87533:         class UnmatchingIdException extends Exception { }
87533:         class TooManyResultsException extends Exception { }
87533:         class InvalidTypeException extends Exception { }
87533: 
87533:         Cursor cursor = null;
87533: 
87533:         try {
87554:           ContentResolver cr = GeckoApp.mAppContext.getContentResolver();
87533:           Uri message = ContentUris.withAppendedId(kSmsContentUri, mMessageId);
87533: 
87541:           cursor = cr.query(message, kRequiredMessageRows, null, null, null);
87533:           if (cursor == null || cursor.getCount() == 0) {
87533:             throw new NotFoundException();
87533:           }
87533: 
87533:           if (cursor.getCount() != 1) {
87533:             throw new TooManyResultsException();
87533:           }
87533: 
87533:           cursor.moveToFirst();
87533: 
87533:           if (cursor.getInt(cursor.getColumnIndex("_id")) != mMessageId) {
87533:             throw new UnmatchingIdException();
87533:           }
87533: 
87533:           int type = cursor.getInt(cursor.getColumnIndex("type"));
87533:           String sender = "";
87533:           String receiver = "";
87533: 
87533:           if (type == kSmsTypeInbox) {
87533:             sender = cursor.getString(cursor.getColumnIndex("address"));
87533:           } else if (type == kSmsTypeSentbox) {
87533:             receiver = cursor.getString(cursor.getColumnIndex("address"));
87533:           } else {
87533:             throw new InvalidTypeException();
87533:           }
87533: 
87533:           GeckoAppShell.notifyGetSms(cursor.getInt(cursor.getColumnIndex("_id")),
87533:                                      receiver, sender,
87533:                                      cursor.getString(cursor.getColumnIndex("body")),
87533:                                      cursor.getLong(cursor.getColumnIndex("date")),
87533:                                      mRequestId, mProcessId);
87533:         } catch (NotFoundException e) {
87533:           Log.i("GeckoSmsManager", "Message id " + mMessageId + " not found");
87534:           GeckoAppShell.notifyGetSmsFailed(kNotFoundError, mRequestId, mProcessId);
87533:         } catch (UnmatchingIdException e) {
87533:           Log.e("GeckoSmsManager", "Requested message id (" + mMessageId +
87533:                                    ") is different from the one we got.");
87534:           GeckoAppShell.notifyGetSmsFailed(kUnknownError, mRequestId, mProcessId);
87533:         } catch (TooManyResultsException e) {
87533:           Log.e("GeckoSmsManager", "Get too many results for id " + mMessageId);
87534:           GeckoAppShell.notifyGetSmsFailed(kUnknownError, mRequestId, mProcessId);
87533:         } catch (InvalidTypeException e) {
87533:           Log.i("GeckoSmsManager", "Message has an invalid type, we ignore it.");
87534:           GeckoAppShell.notifyGetSmsFailed(kNotFoundError, mRequestId, mProcessId);
87533:         } catch (Exception e) {
87533:           Log.e("GeckoSmsManager", "Error while trying to get message: " + e);
87534:           GeckoAppShell.notifyGetSmsFailed(kUnknownError, mRequestId, mProcessId);
87533:         } finally {
87533:           if (cursor != null) {
87533:             cursor.close();
87533:           }
87533:         }
87533:       }
87533:     }
87533: 
87533:     if (!SmsIOThread.getInstance().execute(new GetMessageRunnable(aMessageId, aRequestId, aProcessId))) {
87533:       Log.e("GeckoSmsManager", "Failed to add GetMessageRunnable to the SmsIOThread");
87534:       GeckoAppShell.notifyGetSmsFailed(kUnknownError, aRequestId, aProcessId);
87533:     }
87533:   }
87533: 
87554:   public void deleteMessage(int aMessageId, int aRequestId, long aProcessId) {
87536:     class DeleteMessageRunnable implements Runnable {
87536:       private int mMessageId;
87536:       private int mRequestId;
87536:       private long mProcessId;
87536: 
87536:       DeleteMessageRunnable(int aMessageId, int aRequestId, long aProcessId) {
87536:         mMessageId = aMessageId;
87536:         mRequestId = aRequestId;
87536:         mProcessId = aProcessId;
87536:       }
87536: 
87536:       @Override
87536:       public void run() {
87536:         class TooManyResultsException extends Exception { }
87536: 
87536:         try {
87554:           ContentResolver cr = GeckoApp.mAppContext.getContentResolver();
87536:           Uri message = ContentUris.withAppendedId(kSmsContentUri, mMessageId);
87536: 
87536:           int count = cr.delete(message, null, null);
87536: 
87536:           if (count > 1) {
87536:             throw new TooManyResultsException();
87536:           }
87536: 
87536:           GeckoAppShell.notifySmsDeleted(count == 1, mRequestId, mProcessId);
87536:         } catch (TooManyResultsException e) {
87536:           Log.e("GeckoSmsManager", "Delete more than one message? " + e);
87537:           GeckoAppShell.notifySmsDeleteFailed(kUnknownError, mRequestId, mProcessId);
87536:         } catch (Exception e) {
87536:           Log.e("GeckoSmsManager", "Error while trying to delete a message: " + e);
87537:           GeckoAppShell.notifySmsDeleteFailed(kUnknownError, mRequestId, mProcessId);
87536:         }
87536:       }
87536:     }
87536: 
87536:     if (!SmsIOThread.getInstance().execute(new DeleteMessageRunnable(aMessageId, aRequestId, aProcessId))) {
87536:       Log.e("GeckoSmsManager", "Failed to add GetMessageRunnable to the SmsIOThread");
87537:       GeckoAppShell.notifySmsDeleteFailed(kUnknownError, aRequestId, aProcessId);
87536:     }
87536:   }
87536: 
87554:   public void createMessageList(long aStartDate, long aEndDate, String[] aNumbers, int aNumbersCount, int aDeliveryState, boolean aReverse, int aRequestId, long aProcessId) {
87541:     class CreateMessageListRunnable implements Runnable {
87541:       private long     mStartDate;
87541:       private long     mEndDate;
87541:       private String[] mNumbers;
87541:       private int      mNumbersCount;
87541:       private int      mDeliveryState;
87541:       private boolean  mReverse;
87541:       private int      mRequestId;
87541:       private long     mProcessId;
87541: 
87541:       CreateMessageListRunnable(long aStartDate, long aEndDate, String[] aNumbers, int aNumbersCount, int aDeliveryState, boolean aReverse, int aRequestId, long aProcessId) {
87541:         mStartDate = aStartDate;
87541:         mEndDate = aEndDate;
87541:         mNumbers = aNumbers;
87541:         mNumbersCount = aNumbersCount;
87541:         mDeliveryState = aDeliveryState;
87541:         mReverse = aReverse;
87541:         mRequestId = aRequestId;
87541:         mProcessId = aProcessId;
87541:       }
87541: 
87541:       @Override
87541:       public void run() {
87541:         class UnexpectedDeliveryStateException extends Exception { };
87542:         class InvalidTypeException extends Exception { }
87541: 
87542:         Cursor cursor = null;
87542:         boolean closeCursor = true;
87541: 
87541:         try {
87541:           // TODO: should use the |selectionArgs| argument in |ContentResolver.query()|.
87541:           ArrayList<String> restrictions = new ArrayList<String>();
87541: 
87541:           if (mStartDate != 0) {
87541:             restrictions.add("date >= " + mStartDate);
87541:           }
87541: 
87541:           if (mEndDate != 0) {
87541:             restrictions.add("date <= " + mEndDate);
87541:           }
87541: 
87541:           if (mNumbersCount > 0) {
87541:             String numberRestriction = "address IN ('" + mNumbers[0] + "'";
87541: 
87541:             for (int i=1; i<mNumbersCount; ++i) {
87541:               numberRestriction += ", '" + mNumbers[i] + "'";
87541:             }
87541:             numberRestriction += ")";
87541: 
87541:             restrictions.add(numberRestriction);
87541:           }
87541: 
87542:           if (mDeliveryState == kDeliveryStateUnknown) {
87542:             restrictions.add("type IN ('" + kSmsTypeSentbox + "', '" + kSmsTypeInbox + "')");
87542:           } else if (mDeliveryState == kDeliveryStateSent) {
87541:             restrictions.add("type = " + kSmsTypeSentbox);
87541:           } else if (mDeliveryState == kDeliveryStateReceived) {
87541:             restrictions.add("type = " + kSmsTypeInbox);
87541:           } else {
87541:             throw new UnexpectedDeliveryStateException();
87541:           }
87541: 
87541:           String restrictionText = restrictions.size() > 0 ? restrictions.get(0) : "";
87541: 
87541:           for (int i=1; i<restrictions.size(); ++i) {
87541:             restrictionText += " AND " + restrictions.get(i);
87541:           }
87541: 
87554:           ContentResolver cr = GeckoApp.mAppContext.getContentResolver();
87542:           cursor = cr.query(kSmsContentUri, kRequiredMessageRows, restrictionText, null,
87541:                             mReverse ? "date DESC" : "date ASC");
87541: 
87542:           if (cursor.getCount() == 0) {
87542:             GeckoAppShell.notifyNoMessageInList(mRequestId, mProcessId);
87542:             return;
87542:           }
87542: 
87542:           cursor.moveToFirst();
87542: 
87542:           int type = cursor.getInt(cursor.getColumnIndex("type"));
87542:           String sender = "";
87542:           String receiver = "";
87542: 
87542:           if (type == kSmsTypeInbox) {
87542:             sender = cursor.getString(cursor.getColumnIndex("address"));
87542:           } else if (type == kSmsTypeSentbox) {
87542:             receiver = cursor.getString(cursor.getColumnIndex("address"));
87542:           } else {
87542:             throw new UnexpectedDeliveryStateException();
87542:           }
87542: 
87542:           int listId = MessagesListManager.getInstance().add(cursor);
87542:           closeCursor = false;
87542:           GeckoAppShell.notifyListCreated(listId,
87542:                                           cursor.getInt(cursor.getColumnIndex("_id")),
87542:                                           receiver, sender,
87542:                                           cursor.getString(cursor.getColumnIndex("body")),
87542:                                           cursor.getLong(cursor.getColumnIndex("date")),
87542:                                           mRequestId, mProcessId);
87541:         } catch (UnexpectedDeliveryStateException e) {
87541:           Log.e("GeckoSmsManager", "Unexcepted delivery state type: " + e);
87550:           GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, mRequestId, mProcessId);
87541:         } catch (Exception e) {
87541:           Log.e("GeckoSmsManager", "Error while trying to create a message list cursor: " + e);
87550:           GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, mRequestId, mProcessId);
87541:         } finally {
87542:           // Close the cursor if MessagesListManager isn't taking care of it.
87542:           // We could also just check if it is in the MessagesListManager list but
87542:           // that would be less efficient.
87542:           if (cursor != null && closeCursor) {
87542:             cursor.close();
87541:           }
87541:         }
87541:       }
87541:     }
87541: 
87541:     if (!SmsIOThread.getInstance().execute(new CreateMessageListRunnable(aStartDate, aEndDate, aNumbers, aNumbersCount, aDeliveryState, aReverse, aRequestId, aProcessId))) {
87541:       Log.e("GeckoSmsManager", "Failed to add CreateMessageListRunnable to the SmsIOThread");
87550:       GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, aRequestId, aProcessId);
87541:     }
87541:   }
87541: 
87554:   public void getNextMessageInList(int aListId, int aRequestId, long aProcessId) {
87547:     class GetNextMessageInListRunnable implements Runnable {
87547:       private int mListId;
87547:       private int mRequestId;
87547:       private long mProcessId;
87547: 
87547:       GetNextMessageInListRunnable(int aListId, int aRequestId, long aProcessId) {
87547:         mListId = aListId;
87547:         mRequestId = aRequestId;
87547:         mProcessId = aProcessId;
87547:       }
87547: 
87547:       @Override
87547:       public void run() {
87547:         class UnexpectedDeliveryStateException extends Exception { };
87547: 
87547:         try {
87547:           Cursor cursor = MessagesListManager.getInstance().get(mListId);
87547: 
87547:           if (!cursor.moveToNext()) {
87547:             MessagesListManager.getInstance().remove(mListId);
87547:             GeckoAppShell.notifyNoMessageInList(mRequestId, mProcessId);
87547:             return;
87547:           }
87547: 
87547:           int type = cursor.getInt(cursor.getColumnIndex("type"));
87547:           String sender = "";
87547:           String receiver = "";
87547: 
87547:           if (type == kSmsTypeInbox) {
87547:             sender = cursor.getString(cursor.getColumnIndex("address"));
87547:           } else if (type == kSmsTypeSentbox) {
87547:             receiver = cursor.getString(cursor.getColumnIndex("address"));
87547:           } else {
87547:             throw new UnexpectedDeliveryStateException();
87547:           }
87547: 
87547:           int listId = MessagesListManager.getInstance().add(cursor);
87547:           GeckoAppShell.notifyGotNextMessage(cursor.getInt(cursor.getColumnIndex("_id")),
87547:                                              receiver, sender,
87547:                                              cursor.getString(cursor.getColumnIndex("body")),
87547:                                              cursor.getLong(cursor.getColumnIndex("date")),
87547:                                              mRequestId, mProcessId);
87547:         } catch (UnexpectedDeliveryStateException e) {
87547:           Log.e("GeckoSmsManager", "Unexcepted delivery state type: " + e);
87550:           GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, mRequestId, mProcessId);
87547:         } catch (Exception e) {
87547:           Log.e("GeckoSmsManager", "Error while trying to get the next message of a list: " + e);
87550:           GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, mRequestId, mProcessId);
87547:         }
87547:       }
87547:     }
87547: 
87547:     if (!SmsIOThread.getInstance().execute(new GetNextMessageInListRunnable(aListId, aRequestId, aProcessId))) {
87547:       Log.e("GeckoSmsManager", "Failed to add GetNextMessageInListRunnable to the SmsIOThread");
87550:       GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, aRequestId, aProcessId);
87547:     }
87547:   }
87547: 
87554:   public void clearMessageList(int aListId) {
87551:     MessagesListManager.getInstance().remove(aListId);
87551:   }
87551: 
88061:   public void stop() {
88061:     GeckoApp.mAppContext.unregisterReceiver(this);
88061:   }
88061: 
87554:   public void shutdown() {
87532:     SmsIOThread.getInstance().interrupt();
87542:     MessagesListManager.getInstance().clear();
87522:   }
87532: }
