42525: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
42525:  * ***** BEGIN LICENSE BLOCK *****
42525:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42525:  *
42525:  * The contents of this file are subject to the Mozilla Public License Version
42525:  * 1.1 (the "License"); you may not use this file except in compliance with
42525:  * the License. You may obtain a copy of the License at
42525:  * http://www.mozilla.org/MPL/
42525:  *
42525:  * Software distributed under the License is distributed on an "AS IS" basis,
42525:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42525:  * for the specific language governing rights and limitations under the
42525:  * License.
42525:  *
42525:  * The Original Code is Mozilla Corporation code.
42525:  *
42525:  * The Initial Developer of the Original Code is Mozilla Foundation.
42525:  * Portions created by the Initial Developer are Copyright (C) 2010
42525:  * the Initial Developer. All Rights Reserved.
42525:  *
42525:  * Contributor(s):
42525:  *   Robert O'Callahan <robert@ocallahan.org>
42525:  *
42525:  * Alternatively, the contents of this file may be used under the terms of
42525:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42525:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42525:  * in which case the provisions of the GPL or the LGPL are applicable instead
42525:  * of those above. If you wish to allow use of your version of this file only
42525:  * under the terms of either the GPL or the LGPL, and not to allow others to
42525:  * use your version of this file under the terms of the MPL, indicate your
42525:  * decision by deleting the provisions above and replace them with the notice
42525:  * and other provisions required by the GPL or the LGPL. If you do not delete
42525:  * the provisions above, a recipient may use your version of this file under
42525:  * the terms of any one of the MPL, the GPL or the LGPL.
42525:  *
42525:  * ***** END LICENSE BLOCK ***** */
42525: 
42525: #ifndef FRAMELAYERBUILDER_H_
42525: #define FRAMELAYERBUILDER_H_
42525: 
47736: #include "nsTHashtable.h"
47736: #include "nsHashKeys.h"
47736: #include "nsTArray.h"
47736: #include "nsRegion.h"
47736: #include "nsIFrame.h"
51752: #include "Layers.h"
42525: 
42525: class nsDisplayListBuilder;
42525: class nsDisplayList;
42525: class nsDisplayItem;
47731: class gfxContext;
42525: 
42525: namespace mozilla {
42525: 
47751: enum LayerState {
47751:   LAYER_NONE,
47751:   LAYER_INACTIVE,
47751:   LAYER_ACTIVE
47751: };
47751: 
47736: /**
47736:  * The FrameLayerBuilder belongs to an nsDisplayListBuilder and is
47736:  * responsible for converting display lists into layer trees.
47736:  * 
47736:  * The most important API in this class is BuildContainerLayerFor. This
47736:  * method takes a display list as input and constructs a ContainerLayer
47736:  * with child layers that render the contents of the display list. It
47736:  * also updates userdata for the retained layer manager, and
47736:  * DisplayItemDataProperty data for frames, to record the relationship
47736:  * between frames and layers.
47736:  * 
47736:  * That data enables us to retain layer trees. When constructing a
47736:  * ContainerLayer, we first check to see if there's an existing
47736:  * ContainerLayer for the same frame that can be recycled. If we recycle
47736:  * it, we also try to reuse its existing ThebesLayer children to render
47736:  * the display items without layers of their own. The idea is that by
47736:  * recycling layers deterministically, we can ensure that when nothing
47736:  * changes in a display list, we will reuse the existing layers without
47736:  * changes.
47736:  * 
47736:  * We expose a GetLeafLayerFor method that can be called by display items
47736:  * that make their own layers (e.g. canvas and video); this method
47736:  * locates the last layer used to render the display item, if any, and
47736:  * return it as a candidate for recycling.
47736:  * 
47736:  * FrameLayerBuilder sets up ThebesLayers so that 0,0 in the Thebes layer
47736:  * corresponds to the (pixel-snapped) top-left of the aActiveScrolledRoot.
47736:  * It sets up ContainerLayers so that 0,0 in the container layer
47736:  * corresponds to the snapped top-left of the display list reference frame.
47736:  */
42525: class FrameLayerBuilder {
42525: public:
47736:   typedef layers::Layer Layer; 
47736:   typedef layers::ThebesLayer ThebesLayer;
47736:   typedef layers::LayerManager LayerManager;
47736: 
53935:   FrameLayerBuilder();
42525: 
42525:   /**
47771:    * Call this to notify that we are about to start a transaction on the
47771:    * retained layer manager aManager.
47736:    */
47771:   void WillBeginRetainedLayerTransaction(LayerManager* aManager);
47736: 
47736:   /**
47771:    * Call this just before we end a transaction on aManager. If aManager
47771:    * is not the retained layer manager then it must be a temporary layer
47771:    * manager that will not be used again.
47771:    */
47771:   void WillEndTransaction(LayerManager* aManager);
47771: 
47771:   /**
47771:    * Call this after we end a transaction on aManager. If aManager
47736:    * is not the retained layer manager then it must be a temporary layer
47736:    * manager that will not be used again.
47736:    */
47736:   void DidEndTransaction(LayerManager* aManager);
47736: 
47736:   /**
47736:    * Build a container layer for a display item that contains a child
47736:    * list, either reusing an existing one or creating a new one. It
47736:    * sets the container layer children to layers which together render
47736:    * the contents of the display list. It reuses existing layers from
47736:    * the retained layer manager if possible.
42525:    * aContainer may be null, in which case we construct a root layer.
47736:    * This gets called by display list code. It calls BuildLayer on the
47736:    * items in the display list, making items with their own layers
47736:    * children of the new container, and assigning all other items to
47736:    * ThebesLayer children created and managed by the FrameLayerBuilder.
47736:    * Returns a layer with clip rect cleared; it is the
47736:    * caller's responsibility to add any clip rect and set the visible
47736:    * region.
42525:    */
47736:   already_AddRefed<Layer> BuildContainerLayerFor(nsDisplayListBuilder* aBuilder,
42525:                                                  LayerManager* aManager,
47736:                                                  nsIFrame* aContainerFrame,
47736:                                                  nsDisplayItem* aContainerItem,
42525:                                                  const nsDisplayList& aChildren);
42525: 
42525:   /**
47736:    * Get a retained layer for a display item that needs to create its own
47736:    * layer for rendering (i.e. under nsDisplayItem::BuildLayer). Returns
47736:    * null if no retained layer is available, which usually means that this
47736:    * display item didn't have a layer before so the caller will
47736:    * need to create one.
47736:    * Returns a layer with clip rect cleared; it is the
47736:    * caller's responsibility to add any clip rect and set the visible
47736:    * region.
47731:    */
47731:   Layer* GetLeafLayerFor(nsDisplayListBuilder* aBuilder,
47731:                          LayerManager* aManager,
47731:                          nsDisplayItem* aItem);
47731: 
47731:   /**
47731:    * Call this during invalidation if aFrame has
47731:    * the NS_FRAME_HAS_CONTAINER_LAYER state bit. Only the nearest
47731:    * ancestor frame of the damaged frame that has
47731:    * NS_FRAME_HAS_CONTAINER_LAYER needs to be invalidated this way.
47731:    */
47731:   static void InvalidateThebesLayerContents(nsIFrame* aFrame,
47731:                                             const nsRect& aRect);
47731: 
47731:   /**
51752:    * For any descendant frame of aFrame (including across documents) that
51752:    * has an associated container layer, invalidate all the contents of
51752:    * all ThebesLayer children of the container. Useful when aFrame is
51752:    * being moved and we need to invalidate everything in aFrame's subtree.
51752:    */
51752:   static void InvalidateThebesLayersInSubtree(nsIFrame* aFrame);
51752: 
51752:   /**
47736:    * Call this to force *all* retained layer contents to be discarded at
47736:    * the next paint.
47736:    */
47736:   static void InvalidateAllThebesLayerContents(LayerManager* aManager);
47736: 
47736:   /**
47736:    * Call this to force all retained layers to be discarded and recreated at
47736:    * the next paint.
47736:    */
47736:   static void InvalidateAllLayers(LayerManager* aManager);
47736: 
47736:   /**
47740:    * Call this to determine if a frame has a dedicated (non-Thebes) layer
47740:    * for the given display item key.
47740:    */
47740:   static PRBool HasDedicatedLayer(nsIFrame* aFrame, PRUint32 aDisplayItemKey);
47740: 
47740:   /**
42525:    * This callback must be provided to EndTransaction. The callback data
42525:    * must be the nsDisplayListBuilder containing this FrameLayerBuilder.
42525:    */
42525:   static void DrawThebesLayer(ThebesLayer* aLayer,
42525:                               gfxContext* aContext,
42525:                               const nsIntRegion& aRegionToDraw,
47108:                               const nsIntRegion& aRegionToInvalidate,
42525:                               void* aCallbackData);
47736: 
47736: #ifdef DEBUG
47736:   /**
47736:    * Dumps this FrameLayerBuilder's retained layer manager's retained
47736:    * layer tree to stderr.
47736:    */
47736:   void DumpRetainedLayerTree();
47736: #endif
47736: 
47736:   /******* PRIVATE METHODS to FrameLayerBuilder.cpp ********/
47736:   /* These are only in the public section because they need
47736:    * to be called by file-scope helper functions in FrameLayerBuilder.cpp.
47736:    */
47736:   
47736:   /**
47736:    * Record aItem as a display item that is rendered by aLayer.
47736:    */
47736:   void AddLayerDisplayItem(Layer* aLayer, nsDisplayItem* aItem);
47736: 
47736:   /**
47736:    * Record aItem as a display item that is rendered by the ThebesLayer
47736:    * aLayer, with aClipRect, where aContainerLayerFrame is the frame
47736:    * for the container layer this ThebesItem belongs to.
47736:    * aItem must have an underlying frame.
47736:    */
52292:   struct Clip;
47751:   void AddThebesDisplayItem(ThebesLayer* aLayer,
47751:                             nsDisplayItem* aItem,
52292:                             const Clip& aClip,
47751:                             nsIFrame* aContainerLayerFrame,
48765:                             LayerState aLayerState,
48765:                             LayerManager* aTempManager);
47736: 
47736:   /**
47736:    * Given a frame and a display item key that uniquely identifies a
47736:    * display item for the frame, find the layer that was last used to
47736:    * render that display item. Returns null if there is no such layer.
47736:    * This could be a dedicated layer for the display item, or a ThebesLayer
47736:    * that renders many display items.
47736:    */
47736:   Layer* GetOldLayerFor(nsIFrame* aFrame, PRUint32 aDisplayItemKey);
47736: 
51947:   /**
51947:    * A useful hashtable iteration function that removes the
51947:    * DisplayItemData property for the frame, clears its
51947:    * NS_FRAME_HAS_CONTAINER_LAYER bit and returns PL_DHASH_REMOVE.
51947:    * aClosure is ignored.
51947:    */
51947:   static PLDHashOperator RemoveDisplayItemDataForFrame(nsPtrHashKey<nsIFrame>* aEntry,
51947:                                                        void* aClosure)
51947:   {
51947:     return UpdateDisplayItemDataForFrame(aEntry, nsnull);
51947:   }
51947: 
51947:   /**
51947:    * Try to determine whether the ThebesLayer aLayer paints an opaque
51947:    * single color everywhere it's visible in aRect.
51947:    * If successful, return that color, otherwise return NS_RGBA(0,0,0,0).
51947:    */
51947:   nscolor FindOpaqueColorCovering(nsDisplayListBuilder* aBuilder,
51947:                                   ThebesLayer* aLayer, const nsRect& aRect);
51947: 
52292:   /**
52292:    * Clip represents the intersection of an optional rectangle with a
52292:    * list of rounded rectangles.
52292:    */
52292:   struct Clip {
52292:     struct RoundedRect {
52292:       nsRect mRect;
52292:       // Indices into mRadii are the NS_CORNER_* constants in nsStyleConsts.h
52292:       nscoord mRadii[8];
52292: 
52292:       bool operator==(const RoundedRect& aOther) const {
52292:         if (mRect != aOther.mRect) {
52292:           return false;
52292:         }
52292: 
52292:         NS_FOR_CSS_HALF_CORNERS(corner) {
52292:           if (mRadii[corner] != aOther.mRadii[corner]) {
52292:             return false;
52292:           }
52292:         }
52292:         return true;
52292:       }
52292:       bool operator!=(const RoundedRect& aOther) const {
52292:         return !(*this == aOther);
52292:       }
52292:     };
52292:     nsRect mClipRect;
52292:     nsTArray<RoundedRect> mRoundedClipRects;
52292:     PRPackedBool mHaveClipRect;
52292: 
52292:     Clip() : mHaveClipRect(PR_FALSE) {}
52292: 
52292:     // Construct as the intersection of aOther and aClipItem.
52292:     Clip(const Clip& aOther, nsDisplayItem* aClipItem);
52292: 
52292:     // Apply this |Clip| to the given gfxContext.  Any saving of state
52292:     // or clearing of other clips must be done by the caller.
52292:     void ApplyTo(gfxContext* aContext, nsPresContext* aPresContext);
52292: 
52292:     bool operator==(const Clip& aOther) const {
52292:       return mHaveClipRect == aOther.mHaveClipRect &&
52292:              (!mHaveClipRect || mClipRect == aOther.mClipRect) &&
52292:              mRoundedClipRects == aOther.mRoundedClipRects;
52292:     }
52292:     bool operator!=(const Clip& aOther) const {
52292:       return !(*this == aOther);
52292:     }
52292:   };
52292: 
47736: protected:
47736:   /**
47736:    * We store an array of these for each frame that is associated with
47736:    * one or more retained layers. Each DisplayItemData records the layer
47736:    * used to render one of the frame's display items.
47736:    */
47736:   class DisplayItemData {
47736:   public:
47736:     DisplayItemData(Layer* aLayer, PRUint32 aKey)
47736:       : mLayer(aLayer), mDisplayItemKey(aKey) {}
47736: 
47736:     nsRefPtr<Layer> mLayer;
47736:     PRUint32        mDisplayItemKey;
47736:   };
47736: 
47736:   static void InternalDestroyDisplayItemData(nsIFrame* aFrame,
47736:                                              void* aPropertyValue,
47736:                                              PRBool aRemoveFromFramesWithLayers);
47736:   static void DestroyDisplayItemData(nsIFrame* aFrame, void* aPropertyValue);
47736: 
47736:   /**
47736:    * For DisplayItemDataProperty, the property value *is* an
47736:    * nsTArray<DisplayItemData>, not a pointer to an array. This works
47736:    * because sizeof(nsTArray<T>) == sizeof(void*).
47736:    */
47736:   NS_DECLARE_FRAME_PROPERTY_WITH_FRAME_IN_DTOR(DisplayItemDataProperty,
47736:                                                DestroyDisplayItemData)
47736: 
47736:   /**
47736:    * We accumulate DisplayItemData elements in a hashtable during
47736:    * the paint process, and store them in the frame property only when
47736:    * paint is complete. This is the hashentry for that hashtable.
47736:    */
47736:   class DisplayItemDataEntry : public nsPtrHashKey<nsIFrame> {
47736:   public:
47736:     DisplayItemDataEntry(const nsIFrame *key) : nsPtrHashKey<nsIFrame>(key) {}
47736:     DisplayItemDataEntry(const DisplayItemDataEntry &toCopy) :
47736:       nsPtrHashKey<nsIFrame>(toCopy.mKey), mData(toCopy.mData)
47736:     {
47736:       NS_ERROR("Should never be called, since we ALLOW_MEMMOVE");
47736:     }
47736: 
47736:     PRBool HasContainerLayer();
47736: 
47736:     nsTArray<DisplayItemData> mData;
47736: 
47736:     enum { ALLOW_MEMMOVE = PR_TRUE };
47736:   };
47736: 
47736:   /**
47736:    * We store one of these for each display item associated with a
47736:    * ThebesLayer, in a hashtable that maps each ThebesLayer to an array
47736:    * of ClippedDisplayItems. (ThebesLayerItemsEntry is the hash entry
47736:    * for that hashtable.)
47736:    * These are only stored during the paint process, so that the
47736:    * DrawThebesLayer callback can figure out which items to draw for the
47736:    * ThebesLayer.
47736:    * mItem always has an underlying frame.
47736:    */
47736:   struct ClippedDisplayItem {
52292:     ClippedDisplayItem(nsDisplayItem* aItem, const Clip& aClip)
52292:       : mItem(aItem), mClip(aClip)
47736:     {
47736:     }
47736: 
47736:     nsDisplayItem* mItem;
47751:     nsRefPtr<LayerManager> mTempLayerManager;
52292:     Clip mClip;
47736:   };
47736: 
47736:   /**
47736:    * We accumulate ClippedDisplayItem elements in a hashtable during
47736:    * the paint process. This is the hashentry for that hashtable.
47736:    */
47736:   class ThebesLayerItemsEntry : public nsPtrHashKey<ThebesLayer> {
47736:   public:
47736:     ThebesLayerItemsEntry(const ThebesLayer *key) : nsPtrHashKey<ThebesLayer>(key) {}
47736:     ThebesLayerItemsEntry(const ThebesLayerItemsEntry &toCopy) :
47736:       nsPtrHashKey<ThebesLayer>(toCopy.mKey), mItems(toCopy.mItems)
47736:     {
47736:       NS_ERROR("Should never be called, since we ALLOW_MEMMOVE");
47736:     }
47736: 
47736:     nsTArray<ClippedDisplayItem> mItems;
47736:     nsIFrame* mContainerLayerFrame;
47736: 
47736:     enum { ALLOW_MEMMOVE = PR_TRUE };
47736:   };
47736: 
47736:   void RemoveThebesItemsForLayerSubtree(Layer* aLayer);
47736: 
47736:   static PLDHashOperator UpdateDisplayItemDataForFrame(nsPtrHashKey<nsIFrame>* aEntry,
47736:                                                        void* aUserArg);
47736:   static PLDHashOperator StoreNewDisplayItemData(DisplayItemDataEntry* aEntry,
47736:                                                  void* aUserArg);
47736: 
47736:   /**
53935:    * Returns true if the DOM has been modified since we started painting,
53935:    * in which case we should bail out and not paint anymore. This should
53935:    * never happen, but plugins can trigger it in some cases.
53935:    */
53935:   PRBool CheckDOMModified();
53935: 
53935:   /**
47736:    * The layer manager belonging to the widget that is being retained
47736:    * across paints.
47736:    */
47736:   LayerManager*                       mRetainingManager;
47736:   /**
47736:    * A map from frames to a list of (display item key, layer) pairs that
47736:    * describes what layers various parts of the frame are assigned to.
47736:    */
47736:   nsTHashtable<DisplayItemDataEntry>  mNewDisplayItemData;
47736:   /**
47736:    * A map from ThebesLayers to the list of display items (plus
47736:    * clipping data) to be rendered in the layer.
47736:    */
47736:   nsTHashtable<ThebesLayerItemsEntry> mThebesLayerItems;
47736:   /**
53935:    * Saved generation counter so we can detect DOM changes.
53935:    */
53935:   PRUint32                            mInitialDOMGeneration;
53935:   /**
53935:    * Set to true if we have detected and reported DOM modification during
53935:    * the current paint.
53935:    */
53935:   PRPackedBool                        mDetectedDOMModification;
53935:   /**
47736:    * Indicates that the contents of all ThebesLayers should be rerendered
47736:    * during this paint.
47736:    */
47736:   PRPackedBool                        mInvalidateAllThebesContent;
47736:   /**
47736:    * Indicates that the entire layer tree should be rerendered
47736:    * during this paint.
47736:    */
47736:   PRPackedBool                        mInvalidateAllLayers;
42525: };
42525: 
42525: }
42525: 
42525: #endif /* FRAMELAYERBUILDER_H_ */
