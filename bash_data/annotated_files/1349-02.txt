   1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
   1:  * ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Oracle Corporation code.
   1:  *
   1:  * The Initial Developer of the Original Code is Oracle Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 2005
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Stuart Parmenter <pavlov@pavlov.net>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #ifndef GFX_ASURFACE_H
   1: #define GFX_ASURFACE_H
   1: 
   1: #include "gfxTypes.h"
   1: #include "gfxRect.h"
   1: #include "nsStringFwd.h"
   1: 
   1: typedef struct _cairo_surface cairo_surface_t;
   1: typedef struct _cairo_user_data_key cairo_user_data_key_t;
   1: 
   1: typedef void (*thebes_destroy_func_t) (void *data);
   1: 
   1: /**
   1:  * A surface is something you can draw on. Instantiate a subclass of this
   1:  * abstract class, and use gfxContext to draw on this surface.
   1:  */
   1: class THEBES_API gfxASurface {
   1: public:
   1:     nsrefcnt AddRef(void);
   1:     nsrefcnt Release(void);
   1: 
   1: public:
   1:     /**
   1:      * The format for an image surface. For all formats with alpha data, 0
   1:      * means transparent, 1 or 255 means fully opaque.
   1:      */
   1:     typedef enum {
   1:         ImageFormatARGB32, ///< ARGB data in native endianness, using premultiplied alpha
   1:         ImageFormatRGB24,  ///< xRGB data in native endianness
   1:         ImageFormatA8,     ///< Only an alpha channel
   1:         ImageFormatA1,     ///< Packed transparency information (one byte refers to 8 pixels)
   1:         ImageFormatUnknown
   1:     } gfxImageFormat;
   1: 
   1:     typedef enum {
   1:         SurfaceTypeImage,
   1:         SurfaceTypePDF,
   1:         SurfaceTypePS,
   1:         SurfaceTypeXlib,
   1:         SurfaceTypeXcb,
   1:         SurfaceTypeGlitz,
   1:         SurfaceTypeQuartz,
   1:         SurfaceTypeWin32,
   1:         SurfaceTypeBeOS,
   1:         SurfaceTypeDirectFB,
   1:         SurfaceTypeSVG,
   1:         SurfaceTypeOS2
   1:     } gfxSurfaceType;
   1: 
   1:     typedef enum {
   1:         CONTENT_COLOR       = 0x1000,
   1:         CONTENT_ALPHA       = 0x2000,
   1:         CONTENT_COLOR_ALPHA = 0x3000
   1:     } gfxContentType;
   1: 
   1:     /* Wrap the given cairo surface and return a gfxASurface for it */
   1:     static already_AddRefed<gfxASurface> Wrap(cairo_surface_t *csurf);
   1: 
   1:     /*** this DOES NOT addref the surface */
1349:     cairo_surface_t *CairoSurface() {
1349:         NS_ASSERTION(mSurface != nsnull, "gfxASurface::CairoSurface called with mSurface == nsnull!");
1349:         return mSurface;
1349:     }
   1: 
   1:     gfxSurfaceType GetType() const;
   1: 
   1:     gfxContentType GetContentType() const;
   1: 
   1:     void SetDeviceOffset(const gfxPoint& offset);
   1:     gfxPoint GetDeviceOffset() const;
   1: 
   1:     void Flush();
   1:     void MarkDirty();
   1:     void MarkDirty(const gfxRect& r);
   1: 
   1:     /* Printing backend functions */
   1:     virtual nsresult BeginPrinting(const nsAString& aTitle, const nsAString& aPrintToFileName) { return NS_ERROR_NOT_IMPLEMENTED; }
   1:     virtual nsresult EndPrinting() { return NS_ERROR_NOT_IMPLEMENTED; }
   1:     virtual nsresult AbortPrinting() { return NS_ERROR_NOT_IMPLEMENTED; }
   1:     virtual nsresult BeginPage() { return NS_ERROR_NOT_IMPLEMENTED; }
   1:     virtual nsresult EndPage() { return NS_ERROR_NOT_IMPLEMENTED; }
   1: 
   1:     void SetData(const cairo_user_data_key_t *key,
   1:                  void *user_data,
   1:                  thebes_destroy_func_t destroy);
   1:     void *GetData(const cairo_user_data_key_t *key);
   1: 
   1:     virtual void Finish();
   1: 
1349:     int Status();
1349: 
1349:     /* Make sure that the given dimensions don't overflow a 32-bit signed int
1349:      * using 4 bytes per pixel; optionally, make sure that either dimension
1349:      * doesn't exceed the given limit.
1349:      */
1349:     static PRBool CheckSurfaceSize(const gfxIntSize& sz, PRInt32 limit = 0);
1349: 
   1: protected:
1349:     gfxASurface() : mSurface(nsnull), mFloatingRefs(0), mSurfaceValid(PR_FALSE) { }
1349: 
   1:     static gfxASurface* GetSurfaceWrapper(cairo_surface_t *csurf);
   1:     static void SetSurfaceWrapper(cairo_surface_t *csurf, gfxASurface *asurf);
   1: 
   1:     void Init(cairo_surface_t *surface, PRBool existingSurface = PR_FALSE);
   1: 
   1:     virtual ~gfxASurface() {
   1:     }
   1: private:
1349:     static void SurfaceDestroyFunc(void *data);
1349: 
   1:     cairo_surface_t *mSurface;
1349:     PRInt32 mFloatingRefs;
   1: 
1349: protected:
1349:     PRPackedBool mSurfaceValid;
   1: };
   1: 
   1: /**
   1:  * An Unknown surface; used to wrap unknown cairo_surface_t returns from cairo
   1:  */
   1: class THEBES_API gfxUnknownSurface : public gfxASurface {
   1: public:
   1:     gfxUnknownSurface(cairo_surface_t *surf) {
   1:         Init(surf, PR_TRUE);
   1:     }
   1: 
   1:     virtual ~gfxUnknownSurface() { }
   1: };
   1: 
   1: #endif /* GFX_ASURFACE_H */
