    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <stdio.h>
    1: #include "nsIDragService.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsNativeDragTarget.h"
    1: #include "nsDragService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsCOMPtr.h"
    1: 
    1: #include "nsIWidget.h"
    1: #include "nsWindow.h"
19097: #include "nsClipboard.h"
    1: 
    1: /* Define Class IDs */
    1: static NS_DEFINE_IID(kCDragServiceCID,  NS_DRAGSERVICE_CID);
    1: 
    1: /* Define Interface IDs */
    1: static NS_DEFINE_IID(kIDragServiceIID, NS_IDRAGSERVICE_IID);
    1: 
    1: // This is cached for Leave notification
    1: static POINTL gDragLastPoint;
    1: 
    1: /*
    1:  * class nsNativeDragTarget
    1:  */
    1: nsNativeDragTarget::nsNativeDragTarget(nsIWidget * aWnd)
23271:   : m_cRef(0), mWindow(aWnd), mCanMove(PR_TRUE), mTookOwnRef(PR_FALSE),
43018:   mDropTargetHelper(nsnull)
    1: {
    1:   mHWnd = (HWND)mWindow->GetNativeData(NS_NATIVE_WINDOW);
    1: 
    1:   /*
    1:    * Create/Get the DragService that we have implemented
    1:    */
    1:   CallGetService(kCDragServiceCID, &mDragService);
 8112: 
 8112:   // Drag target helper for drag image support
 8112:   CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER,
 8112:                    IID_IDropTargetHelper, (LPVOID*)&mDropTargetHelper);
    1: }
    1: 
    1: nsNativeDragTarget::~nsNativeDragTarget()
    1: {
    1:   NS_RELEASE(mDragService);
23271: 
 8112:   if (mDropTargetHelper) {
 8112:     mDropTargetHelper->Release();
 8112:     mDropTargetHelper = nsnull;
 8112:   }
    1: }
    1: 
    1: // IUnknown methods - see iunknown.h for documentation
    1: STDMETHODIMP
    1: nsNativeDragTarget::QueryInterface(REFIID riid, void** ppv)
    1: {
    1:   *ppv=NULL;
    1: 
    1:   if (IID_IUnknown == riid || IID_IDropTarget == riid)
    1:     *ppv=this;
    1: 
    1:   if (NULL!=*ppv) {
    1:     ((LPUNKNOWN)*ppv)->AddRef();
38326:     return S_OK;
    1:   }
    1: 
38326:   return E_NOINTERFACE;
    1: }
    1: 
    1: STDMETHODIMP_(ULONG)
    1: nsNativeDragTarget::AddRef(void)
    1: {
    1:   ++m_cRef;
    1:   NS_LOG_ADDREF(this, m_cRef, "nsNativeDragTarget", sizeof(*this));
    1:   return m_cRef;
    1: }
    1: 
    1: STDMETHODIMP_(ULONG) nsNativeDragTarget::Release(void)
    1: {
    1:   --m_cRef;
    1:   NS_LOG_RELEASE(this, m_cRef, "nsNativeDragTarget");
    1:   if (0 != m_cRef)
    1:     return m_cRef;
    1: 
    1:   delete this;
    1:   return 0;
    1: }
    1: 
    1: void
    1: nsNativeDragTarget::GetGeckoDragAction(LPDATAOBJECT pData, DWORD grfKeyState,
    1:                                        LPDWORD pdwEffect,
    1:                                        PRUint32 * aGeckoAction)
    1: {
    1:   // Check if we can link from this data object as well.
    1:   PRBool canLink = PR_FALSE;
    1:   if (pData)
    1:     canLink = (S_OK == ::OleQueryLinkFromData(pData) ? PR_TRUE : PR_FALSE);
    1: 
    1:   // Default is move if we can, in fact drop here,
    1:   // and if the drop source supports a move operation.
19097:   // If move is not preferred (mMovePreferred is false)
19097:   // move only when the shift key is down.
19097:   if (mCanMove && (mMovePreferred || (grfKeyState & MK_SHIFT))) {
19097:     *aGeckoAction = nsIDragService::DRAGDROP_ACTION_MOVE;
    1:     *pdwEffect    = DROPEFFECT_MOVE;
    1:   } else {
    1:     *aGeckoAction = nsIDragService::DRAGDROP_ACTION_COPY;
    1:     *pdwEffect    = DROPEFFECT_COPY;
    1:   }
    1: 
    1:   // Given the key modifiers figure out what state we are in for both
    1:   // the native system and Gecko
    1:   if (grfKeyState & MK_CONTROL) {
    1:     if (canLink && (grfKeyState & MK_SHIFT)) {
    1:       *aGeckoAction = nsIDragService::DRAGDROP_ACTION_LINK;
    1:       *pdwEffect    = DROPEFFECT_LINK;
    1:     } else {
    1:       *aGeckoAction = nsIDragService::DRAGDROP_ACTION_COPY;
    1:       *pdwEffect    = DROPEFFECT_COPY;
    1:     }
    1:   }
    1: }
    1: 
    1: inline
    1: PRBool
    1: IsKeyDown(char key)
    1: {
    1:   return GetKeyState(key) < 0;
    1: }
    1: 
    1: void
    1: nsNativeDragTarget::DispatchDragDropEvent(PRUint32 aEventType, POINTL aPT)
    1: {
    1:   nsEventStatus status;
18445:   nsDragEvent event(PR_TRUE, aEventType, mWindow);
    1: 
 3233:   nsWindow * win = static_cast<nsWindow *>(mWindow);
    1:   win->InitEvent(event);
    1:   POINT cpos;
    1: 
    1:   cpos.x = aPT.x;
    1:   cpos.y = aPT.y;
    1: 
    1:   if (mHWnd != NULL) {
    1:     ::ScreenToClient(mHWnd, &cpos);
    1:     event.refPoint.x = cpos.x;
    1:     event.refPoint.y = cpos.y;
    1:   } else {
    1:     event.refPoint.x = 0;
    1:     event.refPoint.y = 0;
    1:   }
    1: 
    1:   event.isShift   = IsKeyDown(NS_VK_SHIFT);
    1:   event.isControl = IsKeyDown(NS_VK_CONTROL);
    1:   event.isMeta    = PR_FALSE;
    1:   event.isAlt     = IsKeyDown(NS_VK_ALT);
40485:   event.inputSource = static_cast<nsBaseDragService*>(mDragService)->GetInputSource();
    1: 
    1:   mWindow->DispatchEvent(&event, status);
    1: }
    1: 
    1: void
    1: nsNativeDragTarget::ProcessDrag(LPDATAOBJECT pData,
    1:                                 PRUint32     aEventType,
    1:                                 DWORD        grfKeyState,
 8112:                                 POINTL       ptl,
    1:                                 DWORD*       pdwEffect)
    1: {
    1:   // Before dispatching the event make sure we have the correct drop action set
    1:   PRUint32 geckoAction;
    1:   GetGeckoDragAction(pData, grfKeyState, pdwEffect, &geckoAction);
    1: 
    1:   // Set the current action into the Gecko specific type
    1:   nsCOMPtr<nsIDragSession> currSession;
    1:   mDragService->GetCurrentSession(getter_AddRefs(currSession));
14163:   if (!currSession) {
14163:     return;
14163:   }
14163: 
    1:   currSession->SetDragAction(geckoAction);
    1: 
    1:   // Dispatch the event into Gecko
 8112:   DispatchDragDropEvent(aEventType, ptl);
    1: 
    1:   // Now get the cached Drag effect from the drag service
    1:   // the data memeber should have been set by who ever handled the
    1:   // nsGUIEvent or nsIDOMEvent
    1:   PRBool canDrop;
    1:   currSession->GetCanDrop(&canDrop);
    1:   if (!canDrop)
    1:     *pdwEffect = DROPEFFECT_NONE;
    1: 
    1:   // Clear the cached value
    1:   currSession->SetCanDrop(PR_FALSE);
    1: }
    1: 
    1: // IDropTarget methods
    1: STDMETHODIMP
    1: nsNativeDragTarget::DragEnter(LPDATAOBJECT pIDataSource,
    1:                               DWORD        grfKeyState,
 8112:                               POINTL       ptl,
    1:                               DWORD*       pdwEffect)
    1: {
    1:   if (!mDragService) {
38326:     return E_FAIL;
    1:   }
    1: 
 8112:   // Drag and drop image helper
 8112:   if (mDropTargetHelper) {
 8112:     POINT pt = { ptl.x, ptl.y };
 8112:     mDropTargetHelper->DragEnter(mHWnd, pIDataSource, &pt, *pdwEffect);
 8112:   }
 8112: 
23271:   // save a ref to this, in case the window is destroyed underneath us
23271:   NS_ASSERTION(!mTookOwnRef, "own ref already taken!");
23271:   this->AddRef();
23271:   mTookOwnRef = PR_TRUE;
23271: 
    1:   // tell the drag service about this drag (it may have come from an
    1:   // outside app).
    1:   mDragService->StartDragSession();
    1: 
    1:   // Remember if this operation allows a move.
    1:   mCanMove = (*pdwEffect) & DROPEFFECT_MOVE;
    1: 
19097:   void* tempOutData = nsnull;
19097:   PRUint32 tempDataLen = 0;
19097:   nsresult loadResult = nsClipboard::GetNativeDataOffClipboard(
20662:       pIDataSource, 0, ::RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT), nsnull, &tempOutData, &tempDataLen);
19097:   if (NS_SUCCEEDED(loadResult) && tempOutData) {
19097:     NS_ASSERTION(tempDataLen == 2, "Expected word size");
19097:     WORD preferredEffect = *((WORD*)tempOutData);
19097: 
19097:     // Mask effect coming from function call with effect preferred by the source.
19097:     mMovePreferred = (preferredEffect & DROPEFFECT_MOVE) != 0;
19097:   }
19097:   else
19097:     mMovePreferred = mCanMove;
19097: 
    1:   // Set the native data object into drag service
    1:   //
    1:   // This cast is ok because in the constructor we created a
    1:   // the actual implementation we wanted, so we know this is
    1:   // a nsDragService. It should be a private interface, though.
    1:   nsDragService * winDragService =
 3233:     static_cast<nsDragService *>(mDragService);
    1:   winDragService->SetIDataObject(pIDataSource);
    1: 
    1:   // Now process the native drag state and then dispatch the event
 8112:   ProcessDrag(pIDataSource, NS_DRAGDROP_ENTER, grfKeyState, ptl, pdwEffect);
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP
    1: nsNativeDragTarget::DragOver(DWORD   grfKeyState,
 8112:                              POINTL  ptl,
    1:                              LPDWORD pdwEffect)
    1: {
    1:   if (!mDragService) {
38326:     return E_FAIL;
    1:   }
    1: 
43018:   nsCOMPtr<nsIDragSession> currentDragSession;
43018:   mDragService->GetCurrentSession(getter_AddRefs(currentDragSession));
43018:   if (!currentDragSession) {
43018:     return S_OK;  // Drag was canceled.
43018:   }
43018: 
 6417:   // without the AddRef() |this| can get destroyed in an event handler
 6417:   this->AddRef();
 8112: 
 8112:   // Drag and drop image helper
 8112:   if (mDropTargetHelper) {
 8112:     POINT pt = { ptl.x, ptl.y };
 8112:     mDropTargetHelper->DragOver(&pt, *pdwEffect);
 8112:   }
 8112: 
  482:   mDragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
    1:   // Now process the native drag state and then dispatch the event
 8112:   ProcessDrag(nsnull, NS_DRAGDROP_OVER, grfKeyState, ptl, pdwEffect);
 8112: 
 6417:   this->Release();
 6417: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP
    1: nsNativeDragTarget::DragLeave()
    1: {
    1:   if (!mDragService) {
38326:     return E_FAIL;
    1:   }
    1: 
 8112:   // Drag and drop image helper
 8112:   if (mDropTargetHelper) {
 8112:     mDropTargetHelper->DragLeave();
 8112:   }
 8112: 
    1:   // dispatch the event into Gecko
    1:   DispatchDragDropEvent(NS_DRAGDROP_EXIT, gDragLastPoint);
    1: 
    1:   nsCOMPtr<nsIDragSession> currentDragSession;
    1:   mDragService->GetCurrentSession(getter_AddRefs(currentDragSession));
    1: 
    1:   if (currentDragSession) {
    1:     nsCOMPtr<nsIDOMNode> sourceNode;
    1:     currentDragSession->GetSourceNode(getter_AddRefs(sourceNode));
    1: 
    1:     if (!sourceNode) {
    1:       // We're leaving a window while doing a drag that was
    1:       // initiated in a different app. End the drag session, since
    1:       // we're done with it for now (until the user drags back into
    1:       // mozilla).
  482:       mDragService->EndDragSession(PR_FALSE);
    1:     }
    1:   }
    1: 
23271:   // release the ref that was taken in DragEnter
23271:   NS_ASSERTION(mTookOwnRef, "want to release own ref, but not taken!");
23271:   if (mTookOwnRef) {
23271:     this->Release();
23271:     mTookOwnRef = PR_FALSE;
23271:   }
23271: 
    1:   return S_OK;
    1: }
    1: 
43018: void
43018: nsNativeDragTarget::DragCancel()
43018: {
43018:   if (mDropTargetHelper) {
43018:     mDropTargetHelper->DragLeave();
43018:   }
43018:   if (mDragService) {
43018:     mDragService->EndDragSession(PR_FALSE);
43018:   }
43018:   // release the ref that we might have taken in DragEnter
43018:   if (mTookOwnRef) {
43018:     this->Release();
43018:     mTookOwnRef = PR_FALSE;
43018:   }
43018: }
43018: 
    1: STDMETHODIMP
    1: nsNativeDragTarget::Drop(LPDATAOBJECT pData,
    1:                          DWORD        grfKeyState,
    1:                          POINTL       aPT,
    1:                          LPDWORD      pdwEffect)
    1: {
    1:   if (!mDragService) {
38326:     return E_FAIL;
    1:   }
    1: 
 8112:   // Drag and drop image helper
 8112:   if (mDropTargetHelper) {
 8112:     POINT pt = { aPT.x, aPT.y };
 8112:     mDropTargetHelper->Drop(pData, &pt, *pdwEffect);
 8112:   }
 8112: 
    1:   // Set the native data object into the drag service
    1:   //
    1:   // This cast is ok because in the constructor we created a
    1:   // the actual implementation we wanted, so we know this is
    1:   // a nsDragService (but it should still be a private interface)
    1:   nsDragService * winDragService =
 3233:     static_cast<nsDragService *>(mDragService);
    1:   winDragService->SetIDataObject(pData);
    1: 
    1:   // Note: Calling ProcessDrag can destroy us; don't touch members after that.
    1:   nsCOMPtr<nsIDragService> serv = mDragService;
    1: 
    1:   // Now process the native drag state and then dispatch the event
    1:   ProcessDrag(pData, NS_DRAGDROP_DROP, grfKeyState, aPT, pdwEffect);
    1: 
19854:   // Let the win drag service know whether this session experienced 
19854:   // a drop event within the application. Drop will not oocur if the
19854:   // drop landed outside the app. (used in tab tear off, bug 455884)
19854:   winDragService->SetDroppedLocal();
19854: 
    1:   // tell the drag service we're done with the session
31301:   // Use GetMessagePos to get the position of the mouse at the last message
31301:   // seen by the event loop. (Bug 489729)
31301:   DWORD pos = ::GetMessagePos();
31301:   POINT cpos;
31301:   cpos.x = GET_X_LPARAM(pos);
31301:   cpos.y = GET_Y_LPARAM(pos);
31301:   winDragService->SetDragEndPoint(nsIntPoint(cpos.x, cpos.y));
  482:   serv->EndDragSession(PR_TRUE);
23271: 
23271:   // release the ref that was taken in DragEnter
23271:   NS_ASSERTION(mTookOwnRef, "want to release own ref, but not taken!");
23271:   if (mTookOwnRef) {
23271:     this->Release();
23271:     mTookOwnRef = PR_FALSE;
23271:   }
23271: 
    1:   return S_OK;
    1: }
